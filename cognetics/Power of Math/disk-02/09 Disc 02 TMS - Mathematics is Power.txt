Let's talk about one of the people who's considered one of the founding geniuses of computers.
His name was Alan Turing.
He was wondering about machines and the power of machines and the limits of computation.
He wanted to solve a problem that was posed by Leibniz, who was one of the co-creators of calculus.
Can a machine prove all possible true theorems?
Is there an automated process that will correctly take axioms and assemble them into proofs?
And the way Turing decided to attack this problem was to create an abstract model of a computing process.
And it sounds remarkably simple and very different than our computers today.
He said, imagine you have an arbitrarily long piece of tape that you divide into squares.
It can be finite and you can add squares whenever you need to.
Your machine has a finite list of instructions.
And the instructions are very simple.
It reads a symbol from where the square it happens to be on the tape.
The symbol is from a finite alphabet, usually just 0 and 1.
Here are the possible things the machine can do when it reads it.
It can erase it.
It can write a new symbol.
It can move left one square to the next square with the next symbol in it.
Or it can move right one square, ladder, rinse, repeat.
That's it.
Now, that sounds like, how can that possibly be something that allows me to surf the Internet
or send email or post to Facebook or watch YouTube videos.
But in fact, that computer that I've just described, it's much slower than the one you have,
but it is equally powerful, more powerful, because it can, in principle, compute things that your computer cannot do.
So we'll talk more about this later, but it raises the question of what can be actually computed?
What numbers can be computed?
And there are infinitely many programs because there's infinitely many ways of creating a finite list.
However, as we'll talk about a little bit later, there are more irrational numbers than simply infinity,
which is a great idea.
So there are more irrational numbers than simply infinite.
There's a bigger infinity, if you will.
And so what that says, not all those numbers can be computed.
You might want to know if Turing did solve the problem he wanted to solve.
Yes, he did.
And it brings up some of the ideas of incompleteness that we talked about in the preceding lecture.
So to recapitulate, before moving on, what we've seen in this is how math creates the software
to allow calculators and computers to find numbers to functions.
And we've learned a little bit about how the abstract idea of computing plays into it.
And just for a confection, you saw how all possible books are buried as miniature islands of sense within a vast ocean of junk.
What we've heard in this lecture is how calculus and mathematics has figured out ways to use polynomials
to find close approximations to other functions and numbers, which is how calculators and computers have worked.
We've also seen how zeros and ones can create all possible books and writings of humans
as little gems of coherence and information in vast oceans of junk zeros and ones.
And we've seen a bit about how a prototypical computer of Alan Turing's has the computing power of whatever desktop
or laptop or iPad you happen to be using.
The next lecture will be on using probability and statistics, the tools of prediction and perfection.
This ends lecture three.
