Welcome. In the previous lecture, we taught digital circuits to remember things. We built
memory. Today, we're going to teach digital circuits to count. Now, why would you want
to count? Well, I can think of lots of reasons for counting. You might want to count the number
of people going in through a door. You might be working in a factory and you want to count
the number of products going down an assembly line. You might be in the medical profession.
You need to count red blood cells. What's my red blood cell count? You literally want
to know how many red blood cells there are in a given volume. If you're a physicist
or a health physicist or a radiation physicist, you might want to count radioactive decays.
It's not called a Geiger counter for no reason. It counts radioactive decays. If you're an
archaeologist, you want to count individual carbon-14 atoms for the most precise form
of radiocarbon dating. You might want to count the pulses coming out of some electronic device
as a very precise measure of the frequency. How many pulses occurred in one second? If
it's a thousand, the frequency is one kilohertz, a thousand hertz. In some very sophisticated
physics experiments, we want to count the interference fringes, the light and dark regions
when two waves interfere, the kind of thing that we dealt with if you took one of the
other physics courses with the Michelson-Morley experiment and the advent of relativity. Today
we do those with exquisite precision and part of the reason is we can count individual items.
So we want to build counters today. You might think, well, we're only going to use them
to count, but that's not true. In the couple lectures, hence, we'll understand some other
uses for counters that really don't seem to have anything to do with counting individual
objects, but enable us to make conversions between the analog realm and the digital realm.
So we're going to be building counters today of all sorts and looking at some of the questions
and some of the subtleties involved in building electronic counters. So let's begin with a
review from a couple of lectures ago when I introduced the divide by four frequency divider,
which consisted of two toggle flip flops connected, so the output of one went to the clock input
of the other, and each one went at half the rate of the clock signal coming into it, so
the first flip flop went at half the rate of whatever clock I was bringing in. Remember,
a clock is a square wave generated by the way by a waveform generator of some sort,
which could be like one of the ones we developed in the very last lecture on analog electronics.
The second flip flop sees the output of the first flip flop, and so it halves the frequency
again, and I had promised you a watch, and so at the end I gave you this example of the
watch, which has a clock, if you will, inside it, a quartz crystal oscillating at 32,768
Hertz, and that's 2 to the power 15, and so we have a string of 15 flip flops that divides
that down to make a output of 1 Hertz, which runs your watch. Now, I would like to look
in a little bit more detail at this frequency divider and see what it does. So notice first
that I've redrawn the frequency divider with the flip flop on the right that's going to
get the clock, and the reason I want to do that is because I want to treat that as binary
digit 1, the digit in the 1's column, and I'm calling that flip flop 1, T1, for toggle
flip flop 1, and its input is clock 1, and the output of that flip flop, the Q1 connection,
the contents of that flip flop, whether it's a 1 or 0, is connected to the clock input
of the second flip flop, which I'm calling T2, its output is Q2, it's got clock 2, and
the 2, you might think stands for it being the second flip flop, well yes it does in
this case, but it stands for it being the 2's bit, the 2's bit, the power, the number
you'd multiply by 2 to figure out what this final number is in this flip flop combination.
And let's take a look at what happens now as we go through the clock. So we begin with
Q1 and Q2 both in the 0 state, so initially we have 0, 0, and I'm making a table here
in which I'm going to translate that binary digit, or that binary number, 0, 0, consisting
of two binary digits, into a decimal number. 0, 0 is the decimal number 0. Next, the clock
changes and that flips flip flop Q1, and flip flop Q1 goes to high, so we now have 0, 1,
and by the way, these flip flops I've chosen devices that happen to be changing when the
clock falls. That's similar to the master slave flip flop I introduced earlier in this
course, but you can buy flip flops that work either way, or design flip flops that work
either way, these work on the falling edge. So what happens? When the clock first falls,
Q1 goes high, nothing happens to Q2, but then on the next clock cycle, Q1 goes low, that's
a falling edge delivered to the clock input of Q2, and so Q2 goes high, and so now we
have the state 1, 0. Q1 is flipped back again to 0, Q2 is now gone to 1, and that's the
binary equivalent of the number 2. Next time around, nothing happens to Q2 because Q1 doesn't
fall, Q1 rises, and now we have 1, 1, and that's the binary equivalent of 3, and now
we're in that 1, 1 state, and the next cycle Q1 falls again, and that brings Q2 down also
because the falling edge, as Q1 goes down, clocks the second flip flop, the flip flop
T2. And so if we look at our table N sub 10, these are the decimal numbers we're seeing
out of this device, it's 0, 1, 2, 3, and 0 again. So this frequency divider is not only
a frequency divider, if we just look at the input clock and the output of the final flip
flop, it just divides frequency. But if we look at the intermediate outputs and look
at what they mean in terms of binary numbers, this is a counter. It counts 0, 1, 2, 3, 0,
and keeps repeating that, and that's the most we can do with two flip flops because two
binary digits have four possible combinations, and here they correspond to the numbers 0,
1, 2, and 3, and we'll find that's always the case. If we have N flip flops, we'll get
2 to the N, and we'll go from 0 to the N states, and we'll go from 0 to 2 to the N minus 1,
and I'll show you some other examples of that. But let's stop for a moment and actually demonstrate
one of these devices. So over here, on my board, I have exactly the same 2-bit binary
divider that I demonstrated a couple of lectures ago. The only difference is I'm now looking
at the intermediate states, both Q1 and Q2, I've carried them over into this system of
lights. You'll remember that the green means a 0, and the red means a 1, and I've organized
these the way I would a binary number, so the 1's digit is on the right and the 2's
digit is on the left. I've connected the clock of this device, I'm going to call it a counter,
that's what it is, a 2-bit binary counter, to one of my debounce push buttons. I talked
earlier about how debounce push buttons are another application of flip flops. Really
important here to use a debounced one, because if I had a bouncing push button, I pressed
it once, I might get 10 different pulses, and I'd count all of them, and the counter
would end up in some random state, but I'm going to get one nice clean pulse each time
I press the push button. Now I've done another thing. One of the early lectures in digital
electronics, if you did the project, we had this funny project where I asked you to design
a circuit that produced a 1 at its output when its input was the binary equivalent
of 2 or 6 or 8, and that was a really strange request. But if you did that project, you
know that that was the decoder that turns on the bottom segment of one of these ubiquitous
7-segment displays that we use to display binary information in decimal form. And so
what I have here is one of those displays hooked up, I have the actual display there,
I have some resistors that limit the current to the LEDs in that display, and down here
I have a 7-4-4-7 TTL binary to decimal decoder. It takes the binary input, a four-digit binary
input, and it produces seven outputs which do all the complicated logic to tell which
of these segments took the light. So we're going to be able to see the output of this
counter in two places, one over here with these lights and also on this display right
here. So I'm going to press the push button once. The display goes to one. Now a lot of
complicated logic is happening to display that one, but over here we see very clearly
that in the one's place, the right-hand digit has gone to a one, but the two's place, the
digit is still a zero. Okay, press the button again. Now the two's place is high and the
one's place is low. So we have the number one zero, that corresponds to two, and we
indeed get a two on the display. Press it again, we go to one one, that's the binary
equivalent of three, and we indeed get a three on the seven-segment display. Press the button
again and we're back to zero. So this system cycles through these possible states. Zero,
one, two, three, and back to zero. It has only four possible states. They correspond to the
numbers zero to three. It's a two-bit binary counter. Now let me do one more thing with
this before we move on. Let me turn on the oscilloscope, put it on the big screen, and
let me take what was the clock input to this circuit, and instead of connecting it to the
push button, let me connect it to my clock here, my square wave generator, and what do
you see? You see the outputs of Q1, the one's bit, and the output of Q2, the two's bit, and
what do you see? Well, let's start anywhere. Here we are at zero and zero, and the next
time we're at zero in the two's bit and one in the one's bit, there's our one, next time
we're at one in the two's bit, zero in the one's bit, that's one zero or two, then they're
both up, that's one one or three, and then they go back down to zero again. So this pattern
is repeating rapidly. The clock is running here at about a hundred hertz, and if in fact
you look at the board, you can kind of see that this clock rate is slow enough that you
can just kind of see the counter actually jittering, and if I turn this down a bit, we can actually
watch it count through its paces because now I'm feeding this with an input clock. So you
can see the numbers changing there, you can see the numbers changing there, now the oscilloscope
is really working in a regime where it isn't doing a very good job for us, but you can
see things jumping up and down. So there is a two bit binary counter, and we want to continue
to look now at other examples of counting circuits. And now let me ask you what this
is. Well here I have three flip flops, and notice something about them. I have not called
them flip flop one, flip flop two, and flip flop three. I could, and some conventions do
that, but I much prefer to call them T1, T2, and T4. There's no T3. Why? Because these
are the places. We have the ones place, the twos place, the fours place in the binary
number sequence that these flip flops can represent. Now here we have three flip flops,
so we can represent two to the three states, two to the three is eight, we can't get all
the way to eight because we start at zero, so we have zero, one, two, three, four, five,
six, seven. So I've got the clock coming in on the right just like I did before, the
only difference between this and the previous circuit is I've added one more flip flop, so
this is a three-bit binary counter. It has eight states, and if we look at the chart
it goes through. We start at zero, zero, zero. The first clock pulse changes only T1. The
second clock pulse changes T1 again. T1 always changes zero, one, zero, one, zero, one. The
second clock pulse changes T2, and we get one, zero, the two state, then we get one,
one, the three state. In our previous counter, our two-bit counter, we flip back to zero
at that point, but now the change in Q2 flips Q4, and we have one, zero, zero, and that's
the number four, then we add the one, the one, zero, the one, one, and we go up to seven,
and finally we flip back down to zero again. So we can build a three-bit counter that will
count up to seven, and we could build a four-bit counter that would count up to, think about
it, 15, zero to 15, 16 states, and you could build an n-bit counter which would count two
to the n. Well, that's interesting, but we happen to come with ten fingers, and ten fingers
is the basis of our decimal number system, which is not a power of two. So what if you
want to count something else? What if you want to count some number of states that isn't
two to the n? Well, gating, logic gates can come to the rescue on this one, and before
I show you how that's done, let me introduce yet another type of flip flop. So here is
a toggle flip flop, the kind we've been talking about, and this is a flip flop with only a
minor modification, and most commercial integrated circuit flip flops have this modification.
There is an additional input here called clear, CLR, clear. And what that does is if you put
a one on that clear, no matter what else is going on, q goes to zero. Sometimes that clear
is said to be asynchronous. You can really hit that with a one anytime, and q goes directly
to, did I say zero? q goes directly to, yeah, q goes directly to zero. You clear it. You
put it in the zero state. Sometimes the clear is so-called synchronous, and then when you
put a one on the clear at the next clock pulse, q will go to zero. I don't care what it is.
The point is you have a flip flop that you can have a different input to, and you can
force it to go to the zero state by putting a one on that clear input. So we're going
to use the toggle flip flop with clear in our next circuit. So here is a four-bit counter,
and I'd like you to pause a minute and see if you can figure out what this counter does
and focus particularly on that AND gate at the left. So take a pause, think about it,
I'll come back and describe its operation. Four T flip flops with clear, all connected
together, those clears, and they're connected to the output of that AND gate. What's it
do? Okay, well, let's take a look at it. Here I've made a list now getting complicated
of all 16 states from 0, 0, 0, 0, 0 to 1, 1, 1, 1, from 0 to 15 carries all the decimal
numbers in between. But notice how I've connected that AND gate. The AND gate's inputs are
connected to q8 and to q2, and it's an AND gate. So its output will be high only when
both q8 and q2 are high, and the output of the AND gate goes to all the clear inputs.
So if we ever encounter a condition in which both q8 and q2 go high, we will set this counter
back to zero. Now let's look down the table and see when that happens. If you scan down
that table, you will see the first time that both q8 and q2 are high is when we get the
decimal number 10. So what happens? This counter starts counting. 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, and then it flips just for an instant to 10, but it can't stay there. It immediately
clears the flip-flops, brings us back to the 0, 0, 0 state, and so this counter actually
counts 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, and then the next clock pulse, it's back to zero. What
is it? It's a decade counter. It counts the number of digits we have on our fingers. It's
a decade counter. It's also called a BCD counter, which stands for binary coded decimal, because
it does count decimal. It counts to 10. It counts 10 states. It counts to 9s, 0 to 9,
but the numbers are still coded as binary numbers. In a way, this counter is a sort
of waste, because we've wasted the capability of a 4-bit counter to go all the way up to
the number 15 to have 16 states. We've frustrated it by not allowing it ever to get into states
corresponding to 11, 12, 13, 14, 15, but what we've gained, of course, is a counter that
counts in our typical number system. So there's a decade counter. You don't want to just count
to 10. Let's count to 9. Let's count to 99. Just take one of these BCD counters. It goes
from 0 to 9. Take its Q8 output. Put that into the clock of another BCD counter, and
you count to 99. So that's easy enough to do. So now we can understand how we could
make counters that countered really to any amount we wanted, in base 10, in base 2, and
in any other base we wanted, if we wanted some peculiar gating that would close the
counter back to 0. Now, we might, in some cases, want to count down. In fact, these lectures
I give you, I watch a clock which is counting down to tell me how much time I have left.
There's a down counter involved in that clock. How do you count down? Well, the easiest way
to count down is to just change the flip-flop to change state on the rising edge. And if
you look at the situation when you have flip-flops that change on the rising edge, we start with
the flip-flops in, say, the 0, 0 state. In comes the clock. The rising edge of the clock
changes Q1 to a 1. Q1 goes up to a 1. The rising edge of the clock changes Q2 to a 1.
We're in the 1, 1 state. The next one flips Q1 only, and so we're in the 1, 0 state. That's
the number 2. Next we flip both of them and get into the 0, 1 state. That's 1, and then
we get back to 0, 0 again. So this is a two-bit binary down counter, and we could easily make
a four-bit binary down counter, or a four-bit decade down counter, or whatever we wanted.
In fact, we can make up-down counters, but I'm not going to show you how to do that in
this lecture, but if you do the project for this lecture, you will build yourself a three-bit
up-down counter, which is a pretty sophisticated piece of electronics. You can choose which
way it goes, and we're going to use that a couple of lectures hence to build an analog
to digital converter, but that's stuff to come. So let me talk about a few other issues
involving counters. There's a problem with these counters that have cascaded flip flops,
and the problem is the output of one flip flop goes to the next flip flop, and it takes
a little bit of time, something I haven't talked about, but digital gates have a so-called
propagation time. It's typically measured in billions of a second, nanoseconds, for
the input here to change the state of the flip flop. The electronics in there takes a little
bit of time to do its thing, and so the first flip flop changes, and only after it changes
does the next one change, and so the count kind of ripples through from one flip flop
to the next, and briefly while it's rippling through, the output lines have intermediate
states that are not the correct count. Now you could blank the outputs during those times
if you wanted, but a much more elegant approach is to build what's called a synchronous counter
that clocks all the flip flops together, and they all change at the same time, and that
requires either gating or more sophisticated flip flop design, or both, and so let's go
there, and to go there we have to look at one more flip flop, this is the most versatile
flip flop, it's the final one I'm going to introduce, it's called the JK flip flop, and
it can do anything, any of the other flip flops we talked about can do, you can make
it into a D, you can make it into a T, you can make it into an RS, anything you want.
So we're going to start with our RS or SR, set reset, clocked flip flop, and we're going
to add a couple of gates at the inputs, at the RNS inputs, a couple of AND gates, and
we're going to call the input to one of the AND gates, J, and the input to the other AND
gate, we're going to call K, and we're going to do this kind of feedback thing where Q
bar goes up to the other input on the flip flop at the S input, and Q itself goes down
to the other input on the gate at the K input. What is this thing doing? Well, let's just
take this thing before we see what it does and shrink it down and give it, as we have
always, a symbol of its own. J and K are its inputs, Q and Q bar are its outputs, and it's
got a clock. What does it do? Well, I'm not going to go through the details, but I'll
tell you, you can work this out. J and K, if they're both zero, and see the last column
is QN plus one, that means what's Q after the next clock pulse in terms of what it was
after the previous clock pulse, QN. Well, if they're both zero, nothing changes, and
it's a storage unit. Q stays what it was before. If you put J to zero and K to one,
you get a zero on Q. That's a reset. If you put J to one and K to zero, you get a one
for Q. That is a set. And finally, if you put J and K both to one, and if you're working
with TTL, sometimes you can get away with just leaving them unconnected, then it becomes
a T flip flop, and QN plus one goes to not QN. In other words, it changes state. So this
is the most versatile flip flop, and we're now going to use it to build a synchronous
counter. So here's a two-bit synchronous counter. It consists of two JK flip flops.
By the way, I'm using the J and K on the rightmost flip flop, the one's bit, to be a so-called
enable input. I might, under some occasions, and we'll see some of them in future lectures,
I might want to be able to turn a counter on and off, let it start counting, and then
let it stop counting. And so I have this enable. And remember, J and K, if they're both zero,
nothing happens. So I got J and K connected together. If I put them to one, then this
thing is able to count, because it becomes a T flip flop, and the first flip flop changes
on the count just as on the clock, just as we've seen in the counters we've dealt with
before. So there's a JK flip flop. So we're going to be initially in the zero-zero state.
And let's ask what happens when the first clock comes along. The first clock comes along,
and it flips the first flip flop, which is acting as a toggle flip flop, to the one state.
However, the second flip flop has its J and K inputs initially at zero when that clock
pulse came along, because Q1 was initially zero, and so they aren't set up to change.
So the second flip flop doesn't change on the clock. So we get the zero-one state. Now
the next clock comes along. At this point, Q1 is a one, and that Q1 is connected into
both the J and K of the second flip flop. And so we've got that one in a state where it's
going to toggle, and so we get the one zero. The first one always toggles. The flip flop
two toggles this time, and we continue that process. And so we have the same two-bit counting
we had before, zero, one, two, three in decimal. But the point is the flip flops change at
the same time. They change synchronously. Here is, if you want to get more complicated,
a three-bit synchronous counter. And I'm not going to go through the details. You can
work it out if you'd like to understand how it works. But it's more complicated because
not only do we need the J and the K, but we also need this gating to decide what happens.
But the key to this flip flop, to any synchronous, to this counter, any synchronous counter is
all the flip flops have their clocks connected together. So they change state at once, and
there are none of these spurious intermediate states. And if you work through the gating,
you will see that this flip flop goes zero, zero, zero, zero, zero, one, zero, one, zero,
et cetera, counting the decimal numbers zero through seven, and then restarting. It's just
like the three-bit counter I entered just before, but all of the flip flops change state
at once. So there is a three-bit synchronous counter. Now, don't go building these things
unless you do the project, in which case you're going to build a three-bit synchronous up-down
counter, which will be more sophisticated than this one I'm showing you. But you don't
really build counters. You go out and buy counters. There are chips, semiconductor chips,
integrated circuits that do counting. And here are just a handful of them that I've
found useful, the 74XXX or XX160, the XX standing for low-power, Schottky LS, or HC or HT or
whatever. It's a decade counter with asynchronous clear. That means you could always clear the
counter to zero whenever you want, and it's already got the gating in to make it a decade
counter. The next one up is the same thing but binary. And the next two are similar,
but with synchronous clears. And finally, the last one, which is getting obsolete, but
I really like it, and we're going to use it in circuit shortly in another lecture, is
the 74190 decade counter, and it's an up-down counter. And it has a companion 74191, which
is the same thing, but without the gating to make it a decade counter. So it's an up-down
four-bit binary counter. So don't build buy. These things cost about 40 cents each. But
it's nice to know how they work, and that's what this lecture is about.
Okay, let's put a lot of electronics together now and build a real practical counting device.
One nice way to count things, people going through a door, products going down an assembly
line, is to have them interrupt a light beam and have that make the pulse that you're going
to count. And so that's what I'm going to do in the circuit I'm showing you now. This
circuit consists of a photo resistor. I showed you a photo resistor, a special kind of resistor
whose resistance increases with decreasing light. As it gets darker, it gets higher resistance.
And so you'll notice on the left, I've got a voltage divider between 5 volts and this
photo resistor. That means as the light goes down, the photo resistor's resistance is going
to go up, and therefore the voltage at the junction between those two resistors is going
to rise. I've got that fed into an op amp in comparator mode that says, give me an output
that depends only on whether one input is greater or less than the other. However, because
the change in light intensity could be gradual and there could be some noise on it, we really
need that Schmidt trigger idea that I introduced in lecture 14 that has that hysteresis that
says once you change state, don't change back again until the threshold alters a little
bit. In fact, I built the circuit first without the Schmidt trigger and it went haywire and
I realized that's what I needed. So the second thing is the Schmidt trigger and this op amp
is pretty much like the ones we used before except it has an output that swings between
0 and 5 volts rather than plus 15 and minus 15 to make it compatible with logic. And the
output of that Schmidt trigger, that op amp is going into the clock input of a decade counter
like the one I just demonstrated and the decade counter goes through the decoder and display
system. So there is the circuit for what I'm about to show you, the counting thing. So
we've got the photo resistor, the Schmidt trigger, the decoder display that you might
have built in lecture 7 or built part of in lecture 17's project and the counter that
we've introduced in this lecture. Let's take a look and see how it works. So what I've
got here is the photo resistor is that little cylindrical object right there. The lower integrated
circuit is the comparator, the op amp. It's actually a chip that has four comparators on
it but I'm using just one of them. You can see the resistors that are involved in the
Schmidt trigger and also the resistor going down to that photo conductive cell. I do have
a voltmeter hooked up and the reason I do that is because this thing doesn't work the
same way it did in my lab back at Middlebury because it's very sensitive to the ambient
light levels. And what I have to do is set the comparison voltage on that Schmidt trigger,
the voltage at the plus input of the op amp. I have to set that to somewhere between the
voltage which is at the junction of the photo resistor and the other resistor when it's
in full studio light versus when it's obscured. So I had to do that just before I got this
thing hooked up or it wouldn't work well in this environment. And so what I then have
is the output of that comparator is going into the clock input to this 74190 decade
counter and that's feeding in again to my display system. So I'm going to take this
black eraser, make a good blocker and I'm going to move it across the photo conductive
cell and the way this circuit is set up, change of state takes place when the clock flips
in such a way that I've pulled the obscuring object out and I've made it bright again.
So it goes over eight, goes over nine, goes over it's a decade counter, swings back to
zero, one, two, three, four, five, six, seven, eight, nine and back to zero. So you could
imagine interrupting a light beam periodically by people walking by, by products going down
an assembly line or whatever and you get a count of how many objects have been. That's
a real nice example of a lot of the electronics we've developed in this course. So that's
the end of my discussion of counters, but if you want to do more with counters, do the
project and the project is more sophisticated than the counters I showed in the lecture.
It's to first explore your circuit simulators built in JK flip flop and ask yourself, does
it work on the rising or falling edge and verify its truth table and then simulate the
three-bit synchronous up-down counter shown below and verify that it counts both up and
down. And you'll have slightly different operations here depending on which of the
circuit simulators you use. And by the way, if you want to get real fancy, you'll find
that do circuits allows you to connect an actual display and decoder and actually see
the numbers that your counter is producing. But this is a sophisticated counter. It can
go both up and down and it's the kind of counter we'll need a couple lectures hence.
So lecture 21 looked at counters and counters were built from flip flops and in particular
we looked at synchronous counters that use JK flip flops. So for your project, I'd like
to explore, I'd like you to explore your circuit simulators built in JK flip flop and
answer the question, is it a rising or falling edge triggered flip flop? Does it change state
when the clock goes up or when the clock goes down? And I'd like you to verify its truth
table and then I'd like you to simulate a very sophisticated circuit that I didn't cover
in lecture, a three-bit synchronous up-down counter that can count both up and down.
So we'll move on. Let's look first at the circuit simulators built in JK flip flop. In
the case of circuit lab, circuit lab doesn't have real time displays like those blinking
lights in do circuits. So rather than try to go through the exploration of the JK flip
flop in real time, I'm simply going to show you the results. So I took the JK flip flop
and I connected it to switches which could swing between either a zero or a one logic
primitive at the input and I took it through a variety of states. And I also looked at
what happened as the clock was changing and what happened to Q and so on. And so if you
look at the clock going up and down and look at what's happening to Q and look at the situation
in both the upper and lower states, you will find that I have a rising edge triggered flip
flop. So the flip flop is rising edge triggered and it does indeed satisfy the truth table
but it's a little bit hard to see it from this one. So let's go straight to do circuits
and look at what the JK flip flop does in do circuits. So here is the JK flip flop in
do circuits. Same kind of thing. I'm going to clock now the clock input and I'm going
to clock the J and the K input separately. So I'm going to take this thing through all
its paces and I've got these lights, these digital logic probes that will flash on and
off to tell us the state of the clock, the state of the J and K inputs and finally the
state of Q as the output. So let's run the simulation. We got some open ports. We don't
mind that. Simulation is running. Okay, so let's look at what we have here. When J and
K are both zero, no matter what the clock is doing, the output stays zero because nothing
changes when J and K are both zero. When J is one and K is zero, that causes the next
clock rise. It's a rising edge triggered flip flop to set us to one. And in the opposite
state we get set to zero. And finally when they're both ones, we toggle on the clock.
But don't take my word for it. We could go out and look at this whole long sequence and
see what's happening. But rather than that, let's look at what's going on in real time.
So here are the lights flashing. The clock is coming on and off. When J and K are both
high, let's get to that state, then the clock changes the state of Q. When J and K go through
J as a set, K is a reset. And now we're done with the simulation. I could only run it for
a certain amount of time. But if you look at this and build this circuit yourself and
do the simulation and quickly shut off the graphs so you don't have to look at them,
you'll see the lights flashing and you'll see the circuit does go through the truth
table for the J, K flip flop. Okay, that's project solution one. Project
solution two was to build a counter. So let me load up my counters and we'll see how they
work. So here we have the counter wired in circuit lab and on the left I have the up-down
count input. And let's see whether it counts up or down when I've got a zero there. I'm
doing one other trick here with circuit lab which is sometimes useful. If I want to plot
all the outputs on the same graph, they're going to sit right on top of each other because
they're swinging between zero and five volts. So sometimes I'll add artificially a six-volt
power supply and a 12-volt power supply. It's not really for electronics. It's simply to
separate the graphs when I do the simulation in circuit lab. And let's take a look at what
this simulation gives us. So here's the graph. Here's the output. We're seeing the clock and
we're seeing the up-down counter and we're seeing the outputs. And so right now the up-down
is at zero. And let's see what happens. We start with zero, zero, zero. Those are the
outputs of the three-foot flops. Then we have one, zero, one, one, one. So we've gone from
zero, zero, zero to one, one, one. That sounds like we're counting backwards. And let's check
that. Now we're at one, one, zero. One, one, zero. Let's see. That's a digital eight, I'm
sorry, a four, and a two. That's six. And then we are at one, zero, one. That's five. And
then we're at one, zero, zero. That's four. And then we're at zero, one, one. That's three
and so on. So this is a down counter when we put zero at the up-down input. Now caution,
that isn't always true for counters. It is for this particular circuit. So let's change
that zero to a one. So let me go into build mode, delete the zero, go get the digital
primitive for a one. There's the one. Put the one to the up-down. There's the one and
simulate the circuit again. And now the up-down is at one, you can see here. And now you can
clearly see we go from zero, zero, zero to zero, zero, one to zero, one, zero. That's
two. To zero, one, one. That's three. To one, zero, zero. That's four. To one, zero, one
is five. And so on up to one, one, one, which is seven. This being a three-bit counter, it
has eight states, zero to seven. And then we start over. So there's that circuit simulated
in CircuitLab. Now it's a little bit hard to interpret in CircuitLab because we've got
to look at the individual outputs and put together the binary numbers. Do circuits has
its own built-in display. And so let's go to Do circuits and see what it looks like when
we use that built-in display. So here is the same circuit in Do circuits. It's the same
circuit. You can look at all the gating and the flip-flops. You'll see it's the same. I
have an up-down connection here. I'm actually going to clock the, I've got the up-down
connection set to a particular level. We'll take a look at it. And right now it's high
because the light is on. But Do circuits has actually an additional display. And it's a
seven-segment display. And it needs a decoder, just like we talked about in an earlier lecture.
Do circuits also has some individual actual chips. And I happen to know that a 7447 chip
is a binary coded decimal for binary bits coming in to seven-segment decoder. And I
actually had to go to the spec sheet for that. I went online and googled the spec sheet for
the 7447. And I found that to make it count, I had to have these three pins connected to
a one and this pin connected to a zero. Had I not known that, had I not figured that out,
I couldn't have made it work. And then I looked at the circuit at which pins go where. And
the digital inputs are coming in here and here. One of them is coming in. Well, let's
see. Here are the outputs to this. And there's some more digital inputs coming in up here.
And I put one of the bits to zero because this is a three-bit counter. So there is no
eights bit. So I put that one to zero. And so now let's run this simulation of this circuit
with the up down in the one mode. So we'll run the simulation. And I'm not going to bother
to look at the graphical outputs. I'm just going to watch the simulation. And there it
goes. Counting one, two, three, four, five, six, seven. You can see the clock going on
and off. Eight. But there is no eight, so it's zero. One, two, three, four. You can see
Q1, Q2, and Q4 switching. Five, six, seven. And then we flip back to zero because it's
a three-bit counter. Okay, let's just go into build mode and quickly change the up-down
counter. So I'm in build mode. I'm going to double click this input here. This is a input
and its property is, it's a steady input. Its property is it's one. It's a source bit
of one. I'm going to change it to zero. I'm going to save that change. And I'm going to
run the simulation once again. Got some open because we don't care about that. We run the
simulation. And now seven, six, five, four, three, two, one, zero. And now it flips back
to its highest state, which is seven. So we've built quite a sophisticated circuit here.
An up-down synchronous counter. We're going to need up-down counters in the next to the
last lecture when we build the most sophisticated circuit of all. So we've got this one and
it's good and we're going to use it in that really final big project which we'll do in
lecture 23.
