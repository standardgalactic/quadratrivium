In the last lecture we have been discussing about part 2 of our proof in equivalence of CFG and PDA
and we were trying to prove that a language is context-free if and only if some push-on
automator recognizes it and we were discussing part 2 in which we were given a PDA and we are
trying to show how to construct a context-free grammar that recognizes the same class of languages
accepted by the given PDA and we also saw that there are two steps involved in this process
step one which was to simplify the PDA which we have already done in the first part that is part 2a
and in this lecture which is part 2b we will be discussing step two that is to build the
context-free grammar so I hope you remember how we simplified the PDA and what were the
simplification steps that we had to perform and after we have simplified our PDA the next step
is to build the context-free grammar from the PDA that we have simplified so let's see how we can
do it so here is the main idea that is involved in this process of building our context-free grammar
so first of all we have to consider two states let's say we are considering two states p and q
in the push down automata so assume that states p and q are two states in the push down automata
and as I already told you for every pair of states there will be a non-terminal representing that
state so for every pair of states in our push down automata we will have a non-terminal in our
context-free grammar so if we consider two states p and q in the PDA we have to see could we go from
p to q without stack underflow and maintaining an empty stack at the beginning and end or if
something were already on the stack they would never be touched so you have to see can you go from
state p to state q without stack underflow so I already explained in the last lecture what we
mean by stack underflow stack underflow means you should not try to pop anything from an empty
stack that is the condition of stack underflow so we should not go into stack underflow and also
we should start with an empty stack and end with an empty stack so can you go from state p to q
by maintaining an empty stack at the beginning and at the end in the course of execution you
may push and pop elements or symbols from the stack but you should make sure that in the beginning
the stack is empty and at the end also the stack is empty so can you go from state p to q by doing
that or if something were already on the stack they would never be touched so let's say that
something was already there on the stack okay when we came from some other states something was
already there on the stack and can you go from state p to state q without touching or modifying
the symbols which were already there on the stack so we have to see if we can do that and we have to
see what strings would do that so by following which sequence of strings can you go from state p
to q by maintaining all these stack conditions that is mentioned over here so we will create a
non-terminal called a subscript pq in our grammar and apq will generate exactly those strings that
will take us from p to q maintaining all the above stack conditions so I told you for going from state
p to q what are the sequence of strings that you need to follow so that all these stack conditions
which are written here are fulfilled those strings will be the string that will be generated by
this non-terminal apq because we are trying to go from state p to state q and for this pair of state
we create a non-terminal in our context free grammar which we call apq and what is the string
that this non-terminal is going to generate it will be those strings that will take us from
state p to state q maintaining all these stack conditions which we have mentioned here so let
me just mention once more what are the stack conditions we should not go to stack underflow
and we should always start with an empty stack and end with an empty stack if the stack was
already empty or if something was already there on the stack then those things which are already
there should not be touched so from going from state p to q you may push or pop other elements
to the stack but if something was already there before you go to this state p and q then those
things should not be touched so maintaining all these stack conditions if you are able to go from
p to q then you should see which are the strings that are taking you from p to q so those strings
will be the strings that will be generated by this non-terminal apq all right so this is the main idea
that we need to follow now we will see two different cases that we have so here is case number one
so in case number one what we want to do is that we want to go from state p to state q so we are
going to create a non-terminal in our grammar for this pair of state p and q and this is what happens
in this transition so let's see what happens so this is the stack that we have here and let's say
that this is my stack and let's say that when we are in state p there was already something
on the stack there were already some symbols on the stack but as I told you we are not allowed to
touch this we are not allowed to modify what is already on the stack so this portion it represents
the things that are already there on the stack and then on going from state p to r the symbol a is
read in state p when the symbol a is read we push the symbol z onto the stack and then we go to the
next state state r so remember that we are trying to go from state p to state q but we cannot directly
reach to state q like this so we have to go through some other states so the first step is we have to
go from p to r and on going from p to r we read the input symbol a and the symbol z is pushed
onto the stack so this is my stack right now and then when we are in state r we see that z was already
pushed in state p so z is already there in the stack and we have to go from r to s now and in
going from r to s this z is already there in the stack and from going from r to s this z is also
the portion that we considered that should not be touched so from going from r to s this z is not
touched okay this z which was already pushed by state p is not touched or not popped and then
some other things may be popped or pushed onto the stack for going from state r to s all right
and let's say that when we reach s the next transition is to go to state q so in q what
happens we read the symbol b and we pop the symbol z all right the z which was pushed over here from
state p is finally popped when we come to state q so here we see that the symbol that is pushed
which was z by the state that we are first considering that is p and the symbol that is popped
when we reach the state where we want to reach that is also z that means they are the same the
symbol pushed here and the symbol popped here are the same so this is case number one when the
symbol pushed in the beginning and the symbol popped at the end are the same so we have to
ask ourselves what strings can be generated by following this path if we follow this path what
are the strings that will be generated so we see that here a was red and then here b is red so a
and then there are something which happens in between and then b so these are the strings
that will be generated by following this path now i say that a is red here and b is red over here
and in between there are there are some dots now what will be there in these dots so we see that
the dots represents this part for going from state r to s now how can we represent the non-terminals
that will represent states r and s so we can represent the pair of states r s by using the
non-terminal a r s so a r s will be the non-terminal that represents the pair of states r s now what
will be generated by this non-terminal you have to follow the same thing that you did for pq all
right in the same way for r s also those strings that will take you from r to s by following those
tag conditions that will be the string generated by this a r s so i can say that for going from
state p to q i create this non-terminal apq and what does it give it gives a this a this one and then
in between there is another non-terminal a r s r s and then this b so this is the rule that we have
and this rule will generate exactly those strings and what do we mean by those strings those strings
are the strings that will take us from state p to q maintaining all the tag conditions that we have
already discussed so for this much portion of our pda we have converted it to a rule which will be
added to our context-free grammar so this is the cfg that we have created you for this pushdown
automata okay so this is case number one now let's see another case which is case number two
so in case two we see that here also we want to go from state p to state q and again we cannot go
directly from p to q but there are some states that we need to go through in order to reach q
from p and these are the stacks that we have so here let's say that we are starting with this state
and then we are reading a over here and then we push a symbol w to our stack so here w gets
pushed on to the stack so the first symbol that get pushed on to the stack is w and again we assume
that there were some other things in the stack which we are not supposed to touch or modify so
these are there as it is and w is the first symbol that is pushed when we go from state p and then
let's say that as we continue our execution we encounter some other states like r and maybe
there are some more in between and somewhere in the middle this w which was pushed it somehow gets
popped okay it somehow gets popped so in case number one you remember that once that z was pushed
it could not be popped until it reached the state q but here the first symbol that is pushed by p
somewhere in the middle of the execution it gets popped all right it gets popped and then this
becomes my stack now this w is gone it's popped and those things which were remaining in the stack
only those things are there in the stack and then where is state r and when we continue from state r
let's say that some symbol called z it gets pushed on to the stack means it gets inserted to the stack
so in between in the execution when we go from r to q somewhere in the middle the symbol z got
pushed to the stack okay so this becomes my stack now the things which were already remaining
they are already here and then the symbol z is pushed on to the stack and then in state q when
we reach state q b is red and then z is popped so this z will be popped okay so here also what
happens we started with an empty stack empty in the sense that all the things that were already
there we did not touch them we pushed something and we popped something but when we reached this
state q those things which we were not supposed to touch they remain as it is and then the things
that were pushed in the course of this execution from p to q are all popped when we reached state
q okay but the thing that you notice here is that the first symbol that is pushed which is w
which is pushed by p is not the last symbol that is popped the last symbol that is popped is z so
the symbol that was pushed here and the symbol that was popped here are different so when we
are pushing different symbol and popping different symbols then we have to see what are the strings
that can be generated by following this path so if you have this kind of a path where different
symbols are pushed and popped in the beginning and the end then by following this path what are
the strings that will be generated and if we can find out those then we can say that those are the
strings that will take us from state p to state q without modifying the stack now how can we write
it we can write it like this we want to go from state p to q p to q so we create a non-terminal
for this pair of state pq which we call a subscript pq and then what will it give it has to give the
non-terminal a pr and why do we do this this is because from p we have to go to r first and some
pushing and popping is occurring in this area so a pr represents a non-terminal for the pair of
states p and r and then from r we again have to go to q here again some different things are
pushed and popped to the stack so this pair of states r and q are represented by the non-terminal
a r q so the non-terminal apq for the pair of states p and q gives the non-terminal a pr and
a r q so this rule will generate exactly those strings what do i mean by those strings those
strings that will take us from p to q maintaining all the mentioned stack conditions so if you have
this kind of a case then this is the rule that has to be added to your context-free grammar so in
case one we saw if we have that kind of a case what is the rule that we should add to the grammar
and in case two this is the kind of rule that you should add to the grammar so even if you
have pda of this form we have converted it into context-free grammar by converting it into rules
of this form okay so this was about case two now there are a few more things that we need to remember
we have already seen two cases and we have seen how to form the rules for those two cases of pda
to convert it to context-free grammar now if you want to get from any state p to itself then what is
a rule that you have to add so we have seen that in pda there are self loops that means there are
states that goes to itself on getting some kind of inputs so if you want to get from any state
let's say p to itself then what is a rule that we should add to our context-free grammar that
means how can we convert this kind of a state to context-free grammar so for doing that it is like
this we add a non-terminal called app and why do we call it pp because we are going from p to p itself
that is why we are calling it app and what does it give it gives epsilon so a subscript pp giving
epsilon this is the rule that will be used to substitute the state that is going to itself
so if you have a pda in which a state is going to itself then this is how you will convert it to the
equivalent rule in your context-free grammar so these were the main rules and this one let me
just mention it again i have already taught you this in the first part of part 2a so it says that
if a pda accepts some strings then there is a way to go from the starting state which is q0
to the final state which is qf that does not modify the stack and our start non-terminal
is aq0qf so if our pda is going to accept some kind of strings that means what does it mean
if a string is accepted by our pda means there is a way in which that string can travel from the
starting state q0 to the final state qf without modifying the stack so without modifying the
stack means that we start with an empty stack and end with an empty stack and then our start
non-terminal is aq0qf so you always know that in context-free grammar we used to have a start
symbol which we denote by s so that start symbol or the start non-terminal will be aq0qf the pair
for the state's q0 the starting state and the final state qf will be the starting non-terminal
for our pushdown automata all right so these are the rules that you need to follow and you
saw that whatever kind of pushdown automata you have you are able to convert it into its equivalent
rule for a context-free grammar so we have shown how to build our cfg we have already simplified
the pda in the last lecture and then we have also built the context-free grammar in this lecture
by following those rules we have seen what are the rules we need to follow and using those cases
we have seen whatever kind of pushdown automata we have we are able to put it in the form of
rules in context-free grammar so given a pda we have already shown how to construct a context-free
grammar that recognizes the same language and hence we have proven part two of our proof and hence
we can say that a language is context-free if and only if some pushdown automata recognizes it
we have proved part one and also part two and now we can say that pda and cfg or cfg and pda are
equivalent or the class of languages accepted by pushdown automatas and context-free grammars
are exactly the same so this was about the equivalents of cfg and pda so i hope you understand
this thank you for watching and see you in the next one
