In the last few lectures we have been studying about pushdown automata and we have seen the working
of pushdown automata and we have also seen in detail how pushdown automata actually works
with the help of examples. Now in this lecture we will be studying about the equivalence of
context-free grammar and pushdown automata. So if you remember when we first started studying
about pushdown automata, I already taught you that pushdown automata are used to accept the
languages generated by context-free grammars. So there is a theorem which says that a language
is context-free if and only if some pushdown automata recognizes it. So a language is said to
be context-free only if some pushdown automata can recognize it. So that is what we are going to
prove and hence we will find that the context-free grammars and pushdown automata are the same.
The same means that the language generated by context-free grammars and the language
accepted by pushdown automata are actually the same class of languages. So that is what we
are trying to prove. So the proof is divided into two parts. We have part one and part two.
Part one says that given a CFG, show how to construct a PDA that recognizes it. That means
if we are given a context-free grammar, we have to show how we can construct a pushdown automata
that recognizes the same kind of languages that is accepted by the given context-free grammar.
And then part two says, given a PDA, show how to construct a CFG that recognizes the same language.
So part two is just the reverse of part one. So in part one, we were given a CFG but in part two,
we are given a pushdown automata. And then we have to show how to construct a context-free grammar
that recognizes the same kind of language that is accepted by the given pushdown automata. So
these are the two parts that we have in our proof. And in this lecture, we will be discussing about
part one, which says given a CFG, show how to construct a PDA that recognizes it. So we are
going from CFG to PDA, which we will be discussing in this lecture. All right, so now let's see how
we can do this. So for doing this, we are going to prove it using construction. That means we have
an example given and we will show how we can construct a PDA for a given context-free grammar.
So here we are given a grammar, which says s gives bs and also a, a gives 0, a and also epsilon and
b gives bb1 and also 2. So we don't have to worry too much about the productions that this grammar
is giving. But what we have to do is, if we are given this grammar, we have to find or build
a pushdown automata for this grammar. So if we are able to build a pushdown automata for this
context-free grammar, then we are able to prove part one. That is, if we are given a CFG, we are
able to construct a PDA. And hence, we will be able to prove the theorem, which says a language
is context-free if and only if some PDA recognizes it. And hence, we can say that CFG and PDA are
equivalent. All right, so let's see how we can do this. So here what we are going to do is,
we are going to take the leftmost derivation from this grammar. Now, what do we mean by leftmost
derivation? When we studied about a regular grammar, I already taught you what are leftmost
derivation. So in leftmost derivation, what we do is, we expand or we consider the leftmost non-terminal
that we have in our production. And we keep expanding the leftmost non-terminal until we
reach the required string. All right, so let us see. First of all, we start with S, which is our
start symbol. This is the production we are considering. And we take S over here. And if we expand S,
we see that S gives BS and also A. So let me take this production, which says S gives BS. So S gives
BS. So this is what I have. Now, in this BS, if we see, there are two non-terminal symbols,
B and S. And we have to see which is the leftmost non-terminal. The leftmost non-terminal is B. So
we have to expand this B. Now, this B, it has a production which says it gives BB1 and also 2.
So let me take this one, which says BB1. So instead of this B, I write BB1. And then this
S, it comes down as it is. And now if you look at this one, here, which is the leftmost non-terminal,
it is B. So we have to expand B now, because we are considering the leftmost derivation.
Now, if you look here, B, it gives 2 also. So I am going to take this production now,
which says B gives 2. So instead of this B, I write 2 over here. And now this is the production
that we have. And here, which is the leftmost non-terminal, it is B now, because 2 is a terminal
symbol. Following which, we have B, which is the non-terminal symbol. And this is the leftmost
non-terminal. So now I have to expand this B. And for that also, I take the production,
which says B gives 2. So I write 2 over here instead of this B. And this 1S, it comes down as it is.
Now, if you look at this one, here, 2, 2 and 1, these are all terminal symbols. And then,
the only non-terminal symbol that we have is S, which is also the leftmost non-terminal that we
have. Now, if I expand S, I have a production which says that S gives A. So instead of S,
I write A over here. And in this one also, A is the leftmost non-terminal. And if I expand this
A, what do I get? That is a production which says A gives epsilon. So I will replace this A with
epsilon now. So finally, I just get 2 to 1. This is the string that we get. So this is how you
expand the production using the leftmost derivation. And now one thing I want to tell you is that,
during this leftmost derivation, any of the forms that you get, you are getting many productions
over here. Many forms are there. So any of the forms that you get during a leftmost derivation is
known as a left sentential form. Now, we will see how can we put this into our PDA or how can we
design a PDA for this kind of productions of the grammar that we have. Okay, so here I am writing
this in a general form. So here we have different forms as I told you in left sentential form.
And here, let's say, if I take this one, here I have 2 to 1. These are my terminal symbols.
And this is a non-terminal symbol, which is yet to be expanded. So I can write it like this.
I have AAA, which represents my terminals. And then this represents the rest of the symbols that
have to be considered. So here I have B, which is a non-terminal, then I may again have a terminal.
And again, I may have a non-terminal B and another non-terminal C. So just for understanding, I am
writing this in a general form, where these are my terminals, and these are the rest of the symbols,
which are yet to be considered. So if you have a push-run automata, these are my inputs. And
this part, it represents the terminals, which I already told you. And we assume that these
terminals are already scanned. And then the rest of the symbols that are yet to be scanned,
that is stored in the stack. So we know that in push-run automata, we always have a stack.
So the rest of the symbols will be stored in the stack of our push-down automata.
All right, now this general form that we have, let me put it into this push-run automata and
show you how it actually works. So here I have my push-run automata. And then the terminal symbols,
which have already been considered in the input AAA, these are the input symbols,
which is written here. And then I told you that the rest of the symbols, which are yet to be scanned,
they are stored in the stack. So I showed you there that BABC was there, which was yet to be
considered. So I put them on the stack. And Z0 is the bottom most element of the stack. So
when I taught you push-run automata, I already told you, we always put an element at the bottom
most of the stack. It is either represented by Z0 or sometimes by the dollar symbol. And this is
used to represent the bottom most element of the stack in order to know when we have reached the
end of the stack. So Z0 is there. And then the rest of the elements are stored on the stack like
this, BABC. And then here I have just tilted the stack to the left in order to make you understand.
Don't get confused. This stack and this stack is just exactly the same thing. I have just tilted it
to the left in order to make it look sequential and continuous. All right. So we assume that we
have been expanding a production using the leftmost derivation. And during one of the
stage, during one of the left sentential forms, we are getting this. So we are doing the leftmost
derivation. And we assume that we have got this AAA, which is what it is scanned. And this BABC
is that it what that is remaining. So don't get confused. Just think that you are expanding some
production just like I showed you in the beginning. And then this is one of the stages that you
encounter where these are the things that has already been expanded. And these are the things
that is yet to be done. And then what we have to do is at each step, expand the leftmost derivation.
So I already told you in leftmost derivation, what we do is we always expand the leftmost
non terminal. But when we do it in our push on automata, how do we actually do it? We have to
do it using our inputs and stacks and all this. So how do we do it using the push on automata?
So let us say that we have a rule which says B gives ASA XBA. So let's say this is one of the
rules. So what we do is we check if the top of the stack matches to any of the rule. So this is
my stack. Okay, it has just tilted down. Don't be confused. So the top most element of my stack is
B. So I check that in my set of productions, do I have a rule in which B is there on the left-hand
side? That means does B have any production? So we see that yes, B is having a production and it gives
ASA XBA. So how do we proceed if we find it? If we find it, what we do is we have to pop this B out
and instead of this B, we will push the right hand side of the production that B was giving.
So here we see that B gives ASA XBA. So this B will be popped and instead of this B, we will push all
this right-hand side onto the stack. Alright, so this is how we do it. ASA XBA, B is popped and ASA
XBA is pushed onto the stack and then the rest of the things ABC, they remain as it is. So ABC
was already there and on top of that, we push this production, the right-hand side of the rule.
Alright, and this was already the things that were already scanned. So they are here as it is.
Okay, so this is the state that we reach when we do this. So what we do is we match the stack top
to a rule. The stack top, which is this one, we match it to a rule. Is there any rule that is
matching to the top of the stack? And if it is there, pop the stack. That means pop the topmost
element of the stack, which was matching the rule and then push the right-hand side of the rule onto
the stack. And we just push right-hand side of the rule to the stack. So that is what you have to do
when you have a non-terminal on the topmost of your stack. Alright, so let us now try to draw the
transition diagram and represent it in form of a push-down automata. So as I told you, if you have
a rule of the form A gives BCD, then you have to just add it to the push-down automata. And how do
we add it? I told you, you have to match this A with the top of the stack. And if it is matching,
then you have to pop that A from the top of the stack, and you have to push the right-hand side
onto the stack. So this is the PDF for that. So we have one state here, and we have another state
here. So this is epsilon because the input is not advanced. You don't have to advance the input.
And then if you are seeing A here, you have to match it to the top of the stack. If it is matching
the top of the stack and the rule, then you can pop it. You can pop it, and then you have to push
BCD onto the stack. This is the right-hand side of the rule, and that is pushed onto the stack.
Alright, so this is how you do it. If you have a rule of the form A gives BCD, and if this is
the topmost element of the stack. Now, one thing you must have noticed is that we are pushing three
elements BCD onto the stack. But you must be knowing that we cannot just directly push three
elements all at once to the stack. You cannot push more than one element to the stack at one time.
You can only push one element to the stack at one time. So if you want to push BCD to the stack,
you will have to make more transitions or more states in order to achieve this
like this. So if you want to push BCD, you need to use more states like this in order to do it.
So we see that here, this epsilon is this epsilon over here, and then we are matching this A to the
top of the stack, the top of the stack and the rule that A is matched over here. And then we are
first pushing D onto the stack. We are pushing D, and after pushing D, this epsilon remains epsilon
because this is epsilon over here. And then now we don't want to pop anything, but we are pushing C.
And then here also, we are not popping anything, but we are pushing B to the stack. Now we are
creating these states just in order to accommodate this BCD. And then if you see that we have been
pushing this in the reverse order, we have been doing DCB instead of BCD. And why is that?
That is because that is the right order in which you should be pushing elements to the stack. So
let us see if this is your stack that you have over here, you first push D, you first push D,
and then you push C, then you push C, and then you push B, then you push B. So when you look,
it comes in the order BCD, but you have to push it in this way, first D, then C, and then B. So
that is why we are pushing it this way. Okay, so now we have understood what we have to do if we have
rules of this form, and we have seen what to do when we encounter this kind of rules, when we have
a non-terminal on the top of the stack. Now let us see another condition. Now let us say that we
have a rule of this form. A gives 0, 1, 0, 2, B, 3, and C. So we know that what is our fundamental
rule. Our fundamental rule is that whenever we see a non-terminal, we have to match it to the
top of the stack. And if it is matching, we have to push the right hand side to the
top of the stack. So let us assume that we already encountered this A, and then we matched it to the
rule. Let us assume that this A was on the top of the stack, and then we matched this A to one of the
rule that we had, and this is the rule that we had. So what we did, we have already popped A,
and we have pushed this on top of the stack, on top of whatever was there. So this is the stack
that we have. So let us say that something was already there in the stack, Z0 being the bottom
most element, and let us say that we encountered A. A was the top most element on the stack at this
point, and then we matched that A with one of the rules, and then when we match what will we do,
we pop that A, and then we push the right hand side. So this is the right hand side,
0, 1, 0, 2, B, 3, C. So 0, 1, 0, 2, B, 3, C is pushed on top of the stack after popping A.
Now if you look at this stack, you see that the top most element of this
stack is a terminal symbol, which is 0. Now in the last rule, I have told you if you
encountered a non-terminal symbol, what you have to do, and we know what to do. But if we encounter
a terminal symbol, then what do we have to do? So if you encounter a terminal symbol, what you
have to see is you have to look at the input. This is our input, and you have to see if the
next input that is going to be scanned and the top most element of the stack are matching or not.
So we see that the next input to be scanned is 0, and then the top of the stack is also 0. So
they are matching. So what you have to do? You have to pop this 0 from the stack, and then you
have to advance the input. It comes to the next one. So remember that in the previous rule,
we were not advancing the input. But in this one, when you have a terminal on top of the stack,
you match it with the input, and then you pop it, and then you advance the input. So now
it comes here. And again, it checks. Here we have 1, and then here also the next one is 1,
because 0 is already popped. And since they are matching, this one also will be popped. Then it
checks 0, 2 in the similar way. 0 and 2 will be checked in the similar way, and they will be popped,
and the input advances till here. And then after that, we get B, which is a non-terminal symbol.
And then if you get a B, what do you have to do? You have to apply the rule that we
studied just before this. And then it goes on like that till we reach the end of the stack. So
what you have to do is match the terminal symbols to the stack top and pop them. So if you have a
terminal symbol, this is what you have to do. And this is the push-down automata that I have
designed for this. So it actually means that when you have a terminal symbol, you have to see if
the terminal symbol is there, and you have to pop it from the stack and don't push anything onto
the stack. Just advance it, but don't push anything. So even if you have 1 or Z, whichever terminal
symbols are there, you have to just match them, pop them, and don't push anything. So these are
just some terminal symbols. For example, I have written, and then this is the general form x.
If you have x, so x is popped and nothing is pushed. And what is x? For all x belongs to sigma.
Sigma denotes the set of terminal symbols. This is one of the basic notation that we have studied.
And from the start of this lecture series, sigma denotes the set of terminal symbols. Whenever
you have a terminal symbol, then you have to just advance the input, pop it, and don't push anything
onto the stack. So this is what you have to do whenever you have a terminal symbol. So now we
have already studied that whenever you are doing this, if you encounter a non terminal symbol,
we have learned what to do. And if you encounter a terminal symbol, also you have learned what to do.
Now let us design the final PDF for this. And let us see if we can actually design it or not,
so that we can prove our theorem. So here we have the final pushdown automata for our context
free grammars. So here we have our starting state. And in the starting state, what do we do?
We don't read anything, we don't pop anything, but we push z0 onto our stack. And why do we do this?
This is the basic and first thing that we always do in every pushdown automata. We used to push
an element on the bottom most of the stack in order to denote the bottom most element of the
stack so that we can know when we have reached the end of the stack. So z0 is first pushed onto
the stack. And then what do we do? We see that we are pushing the start symbol onto our stack,
because every production we start with the starting symbol, which is denoted by s. So we first push
the starting symbol. And then we come to this transition where we have many rules over here.
And then what are they? These are the rules that we just studied before. So if we have a terminal,
then what do we have to do? We have to advance the input, and we have to pop the terminal symbol,
and we don't have to push anything onto the stack. So this is for all the terminal symbols.
And then what about rules? If we are getting rules, that means non-terminals, then
we don't advance the input, but we match the top of the stack with the rule. And then we pop that
element, that is the left hand side or the top most element of the stack, which should be the
same. And then we push the right hand side of the production to the stack. So this state over here,
it is just a generalized way to denote all the transitions that we have if we get a terminal
symbol or a non-terminal symbol. So when you practically design it, this will not be one
state. This will be many states. You have to design multiple states in order to do all this. But
in order to make it simple, and to accommodate all this, I have just drawn one state here showing
all the different transitions. So after doing all this, we come to the final state when we encounter
Z0 at the end of the stack. So after doing all this, if we find that our stack is empty, that is
Z0 was the first element that was pushed to the stack. And if we at the end, if we find that Z0,
then we can pop it. And then we make sure that we have reached the end of the stack,
and we don't push anything. And at that time, you can come to the final state. And hence that
language generated by that context-free grammar will be accepted. So this is how you design the
pushdown automata for the context-free grammar. And we see that in a generalized way, we were able
to design the pushdown automata for the context-free grammar. So hence, we were able to prove our
theorem, which said that a language is context-free if and only if some pushdown automata recognizes
it. So part one, we were able to do it. We were given a CFG and we could construct the pushdown
automata that was able to recognize that CFG. So this is how you prove the first part. And from
the first part, we can say that context-free grammars and PDA, they are equivalent. So I hope
this was clear to you. In the next lecture, we will be seeing the second part of this proof.
So thank you for watching this and see you in the next one.
