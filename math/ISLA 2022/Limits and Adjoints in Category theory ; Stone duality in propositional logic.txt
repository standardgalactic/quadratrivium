you
you
you
you
you
you
you
you
you
you
you
What are you doing?
What are you doing?
What are you doing?
What are you doing?
What are you doing?
What are you doing?
What are you doing?
What are you doing?
What are you doing?
What are you doing?
What are you doing?
What are you doing?
Can you raise your time?
Okay?
Sure.
So,
ok.
Okay, let's start our first session of third day of SLA.
And the topic is category theory and speakers is Dipankar and Animesh.
Okay, so very less number of people here.
Can I just turn on your videos?
Yeah.
Okay.
What about others?
Maybe others are not here. Okay, whatever. Let me start.
So, yeah, for the past few days, I have been saying that you have different mathematical theories.
And they have similar structures, properties, they share something.
Though they are studied differently, there is something similar inside them.
Something is going on. They are developed in different areas, different timelines, but they have something similar.
Let me give you an example.
So, on the first day, you have seen the notion of a pre-order.
And yesterday, you have seen the notion of taking, taking infimum in some sense or rather defining, so take a pre-order.
If defining the meat operation of two elements, X and Y.
Do you remember how it was defined? It was called the greatest lower bound, right?
And if I want to think of this pre-order as a category, as I have talked about in the first lecture as a category,
then you would say that, okay, so this is a lower bound, first of all, which means there is an arrow from X-meet Y to X and X-meet Y to Y.
So, this is a lower bound, first of all.
And greatest lower bound means that if there is any other element Z, which is smaller than X and smaller than Y, then Z is smaller than X-meet Y.
So, these arrows are just representing less than equal to symbol.
So, there is this diagram in a pre-order or a poset.
Whereas, if you go large enough, let's say to the category of sets and take two different sets, let's say X and Y, think about the Cartesian product.
I hope you all know about Cartesian products.
Do you have a similar situation there?
Do you have a map from here to here, a natural map?
Is this the projection map?
Okay, I'm going to call it as pi X and pi Y, let's say.
You have this two map.
And now I want to mimic this there.
Suppose that there is another object in this category, which is just a set.
Then there is a map to X and X to Y, Z to Y.
Just to mimic this situation, just as you had Z less than equal to X and Z less than equal to Y.
Suppose you are given to map F here and G here.
Can you deduce a map from Z to X cross Y just as you could from Z to X-meet Y?
Yeah, you can.
This is the map.
This is send Z to FZ, GZ.
Note that this triangle commute and this triangle commute.
This was also the case here because you do not have two maps in the poset between two elements, Z and X, let's say.
So this triangle was commuting there.
This is just a transitivity property, if you wish.
This triangle was also commuting.
Moreover, if you think of this map, can you produce a different map from Z to X cross Y such that this triangle is commuting?
Let's say you have another map H from Z to X cross Y such that this triangle commutes.
Which means pi X compose H is equal to F and pi Y compose H is equal to G.
Then what is H of Z?
Try to think of it.
It will have two components.
Let's say A and B.
It will have two components.
Then if you compose with pi X, you get back A, which is pi X compose H of Z, which is going to be A.
But that is just F of A because of this relation.
On the other hand, you are going to deduce that B is equal to G of Z, which is just going to tell you that H is the same map as you gave earlier.
So there cannot be two maps, which means that if you are given two map F and G from Z to X and Z to Y,
then there is a unique map from Z to X cross Y, which makes this triangle commute.
Well, in this case also, you had a unique map because nonetheless, it's a poor set that cannot be two maps.
So this triangle was commuting with this being unique.
So you see, there are two different things.
One is a poor set, another is the collection of all sets.
You have to similar structure in both of them, though they were developed in different areas.
So I am going to generalize this to a categorical property or a categorical, okay.
So this is going to be called a categorical product.
So this is a categorical structure here.
My bad, I said categorical property first.
So this is a categorical structure.
I am going to call it product.
So let's say C is a category.
Let's see the category.
And A and B or X and Y for that matter are two objects.
Then the categorical product
of X and Y, if it exists,
is given by a tuple.
Well, so this is the tuple.
This object with pi X and pi Y as map.
So a tuple, let me denote this by P, pi X, pi Y,
which is P to X, P to Y, this is pi X, this is pi Y,
such that given any object or a tuple of this form,
such that given any tuple, any other tuple,
let's say D comma or Z comma Z comma F comma G.
So this is of this form.
F, this is G.
There exists a unique map, H from Z to P,
which is I'll write as dotted arrows, H,
such that this triangle is coming.
Such that pi X compose H is equal to F and pi Y compose H is equal to G.
So this is the categorical product.
Now that I have defined something general in a general category,
you might ask, oh, you have just declared what it is,
but is this well defined if at all it exists?
I might find a product and someone else can come and give me another product.
Do the two agree?
Well, such questions arise almost always in mathematics.
What you are supposed to do, you're supposed to prove that if there are two of them,
then they are somehow equal or identifiable.
As I said, equality is evil in category theory.
What I prove instead is that they're isomorphic.
They are indeed isomorphic.
Suppose there are two products.
Let's say P, so I'll just draw the diagrams.
So let's say X and Y are my objects for which I want to take a product.
Suppose P1 is a product and let's say pi X and pi Y, this is a product.
Suppose there is another product.
Let's say P2 with pi X or let me call this P and P prime.
There is pi X prime and there is pi Y prime.
Suppose there are two products.
Now, first of all, if you consider P pi X pi Y as a product, then due to this property,
there is going to be a unique map.
Let's say H from P prime to P such that this triangle is commute.
On the other hand, if you consider P prime as the product, P prime as the product,
then due to the same property, if you think of now Z as P,
then there would be a map from P to P prime.
So this is the map.
Let's say this is K.
Now that you have done this, you have just shown the existence of these two arrows.
You realize that there are two arrows.
For example, if you think of P once again, this is pi X, this is pi Y,
then this is also a diagram of that sort.
This is pi X, pi Y.
Just a similar situation where you replace Z by P itself and pi X, pi Y.
There is this identity already, which makes this diagram commute.
But now you have another map, which is H compose K.
This is H compose K.
This is just a matter of fact that once you write down equalities,
you will find that H compose K also makes this diagram commute.
But I said that there is a unique arrow if a product exists, which factorizes this.
So H compose K and 1 both factorizes this.
You must have therefore H compose K.
H compose K is equal to 1 or 1 on P.
Then similarly, you can show that K compose H is equal to 1 on P prime
because P prime is also a product.
In this way, you have reduced that if a product exists, then it is going to be unique up to isomorphism.
Well, some people say unique up to unique isomorphism.
This isomorphism is also unique.
You cannot find more than one isomorphism.
So if a product exists, then it is unique up to unique isomorphism.
And if it exists, we write the product.
So if it exists, if the product exists, then just as we did in sets,
we are copying that notation, the product of X and Y is denoted X cross Y.
It is written as denoted X cross Y.
How do you define a unique isomorphism?
So you see, not defining.
So you are asking how do you define?
You cannot find more than one isomorphism.
There is going to be a single isomorphism between them, which factorizes this diagnosis.
Meaning that?
X is unique.
Sorry?
How do we know the H?
How do we know H is unique from Z to P in the definition?
You start with saying that there is a unique Z, right?
So even, yeah, so there is a unique H from Z to P.
In this case, Z was my P prime.
So it is going to be unique.
Yeah, indeed part of the definition, right?
Is that clear?
So here my P prime was Z.
So H is going to be unique due to definition.
Is this clear?
Not really.
I mean, we can always find out how do we suppose that there can exist an H1 from Z to P, which makes the diagram commute.
Okay, let's do that.
Suppose there is another H prime, which makes the diagram commute.
This is, let's say this is pi X prime.
So is it the definition?
Yeah, the doubt is inside the definition.
Oh, I am giving you the definition.
In the definition, I'm asking you to give me an unique isomorphism, then unique map H from Z to P.
Then you are going to call it product.
If you cannot find one, then it is not a product.
Okay, fine.
Yeah, sorry.
I did not get your question.
Right.
So that's about products.
Now, let me, let me do something more over here.
Let me erase this part.
No, no, no.
It's just a notation.
So this is just a notation.
Now, what about something else?
So I have done, I have shown you that there is similar ideas about products and infimums.
What about this one?
Have you heard of a maximal element in a poset?
What is it?
A maximal element.
Yeah, a maximum element.
Or a top element in a poset.
What is it?
So it is a, it is an element in the poset so that, so M, so that if X is any element in
P, then X is less than equal to M.
Right.
What about sets?
There is this singleton set, such that if X is any other set, there is a unique map from
X to star.
Send every element down to the single element star.
So there are two, they are two different notions, but they are similar in this sense.
So there exists a unique map.
In some sense, a maximum element of a poset and the singleton is somehow similar.
Right.
We have already shown or given you a definition of a terminal object in the tutorial sheet
if you follow that, then you would immediately deduce that in a poset, a maximal element
is but a terminal element.
A maximum element is terminal and then the singleton is terminal in sets.
I could write down the definition of a terminal element.
It is already given in the tutorial.
So let's not write that down properly.
If anyone have any doubt about this, then please ask.
Okay.
If things does not look familiar, then you can think of your favorite categories and
you can try writing down products and terminal elements.
So in sets, it's Cartesian product.
Terminal is singleton.
What about groups?
We have direct product.
And the trivial group.
Is fill of this chart.
Then, okay, so far so good.
Let me turn my attention to something else.
So in a poset, you do not have two different morphisms between two given elements.
Right.
But in a general category where you have many morphisms, how are you going to distinguish
between two different morphisms?
Suppose you are in the category of sets once again and you have two functions f and g,
let's say, from x to y.
How are you going to distinguish between them?
Like, when do you say that?
When you say that this two morphisms are different.
It is customary to write down this set as let's say over here, which is you collect
all elements x in x such that fx is equal to gx.
Now, if s turns out to be equal to x, then you see that f and g are really equal.
If it is not, then they're different, but at least on s, they agree.
If you think of this as an inclusion, then this agree on s.
You denote this by, let's say, i.
So f compose i is equal to g compose i.
But you see this definition of s is so point theoretic in the sense that you are taking a point inside a set.
And then defining this set.
But in a general category, you don't have a notion of point inside an object.
You're not given that idea.
Then how do you construct s?
So what you have to do is instead of this definition, you'll have to figure out something else which does not rely upon the idea of point.
Let me tell you how to do that.
So you have already noted that f compose i is equal to g compose i.
And throughout all this structure, what I was doing, I was taking another object where there is another tuple of that form.
So here I am going to consider s, i as this tuple, which I was thinking about while dealing with product.
Instead of that tuple, now let's think about s, i as similar tuple.
Then to construct something similar of this type, you'd like to consider a map.
Let's say maybe L.
So that similar properties hold.
You must have realized that all what we are doing is that we are comparing this thing with something of the similar property and saying that this universal structure, this structure is somehow minimal to all of them, whichever is given here as well.
Let's think of H, let's think of D, given with this map L, so that f compose L is equal to g compose.
Then what happens?
For all D inside D, you deduce that f of L of D is equal to g of L of D.
But then means this L of D belong to this sector, which means that this diagram factors through this.
This is just L itself.
This diagram commutes.
I'll write H just to avoid confusion, which is just sending an element D to L of D.
And you can check that H is unique in that sense.
There cannot be more than one which factorizes this diagram.
Now, this is a nice property.
So, you may ask, is this the property which is going to give me the set is back at least up to isomorphism or bijection.
The answer is yes, you can check.
I'm not going to do that now.
So, this property is what is going to tell you when to distinguish or how to distinguish between two morphism in a category.
So, this is what I'm going to call as equalizer.
So, definition in a category C.
So, C is known here.
If you have two morphism from X to Y or I'll write A to B now.
Why not X to Y?
F and G.
Then an equalizer is a tuple.
An equalizer is a tuple.
And let's say P comma something, let's say I.
So that G compose I is equal to F compose I.
And if you're given, if you're given any other.
Okay, so let me draw the diagram below.
So that if D comma L is any other pair.
Such that G compose L is equal to F compose L.
Then there exists a unique map.
Just as in that case, say H from D to P.
Such that this triangle commute, which is the copy of the same diagram.
Once again, you can check using this property that this unique property that if an equalizer to different morphism to two different morphism exists, then it is unique up to unique isomorphism.
Well, that's what a definition looks like.
What about filling up this table?
Why don't you fill up how equalizers look like.
Let's see what it looks like in set. What about groups?
For that matter, let's consider abelian groups.
Just to make things simple.
Here you have direct sum.
You have zero group.
How do you fill up equalizer there.
So let me ask you this question instead.
If you have two different, let's say, abelian group, A and B, and two group homomorphism, F and G.
How do you define equalizer?
Or as far as the idea is concerned, how do you distinguish these two maps?
Well, you can think of the map A to B, which is F minus G.
And then ask for its kernel.
You know that already in kernel, the difference goes to zero.
On the kernel, F minus G really goes to zero, which means on the kernel of F minus G, F and G agree.
So that should be the replacement for the notion of an equalizer.
And just check that this indeed has the property as I have defined.
That is given any group, any abelian group D and L such that F compose L is equal to G compose L, then there is this unique map.
Because in that case, G or F minus G compose L is going to be zero.
And therefore L is going to land directly inside the kernel.
Yeah, yeah.
That's the same definition.
Kernel is just that.
But one thing you have to make sure is that even if you are considering categories where objects are just sets with some property, then this inclusion morphism may not be a morphism in that category.
This is just an inclusion of sets.
But you cannot ensure that this inclusion is going to be a morphism in that category.
It just turns out that in group it is, but there will be cases where this inclusion is not going to be a morphism in that category.
Yeah, yeah, there is no problem as such.
You can still define, let's say these are not abelian groups, then then you can still think of the kernel.
But in that case, what you have to do is you instead of looking at F minus G, you look at FG inverse in some sense, which means that send an element A.
To FA times G of A inverse.
Sorry.
Yeah, right.
Sorry.
Yeah, this is not going to be a morphism.
Yeah, this inclusion is not going to be a morphism in.
Yes.
Right.
All right.
Yeah, I hope this is clear now why said theoretic inclusion is not going to work.
Right.
So this were different structures in a category which you could consider.
Well, they may look very different to you, but they are not.
What I have done throughout all of this is that let me resist.
So while considering products, I had to object X and Y.
And a product was a structure like this.
This is pi X, this is pi Y.
And it was minimal in some sense that if you are given any other double D F and G, there exist a unique map such that this triangles commute.
So a product was a cone of this sort over this block, which was minimal in some sense.
What about equalizer?
Well, you have say you have two map X to Y F and G.
And a cone was something like this or an equalizer was something like this.
So this was I for me.
And you can think of this being F compose I which is equal to G compose I this triangles, both of the triangles commute, whichever you can think of.
And such that if you are given any object B with another map L, such that F compose L is equal to G compose L.
And there was a unique map which factor this diagram.
So this were two different things, but they look similar in some sense.
They were all being built upon a given data as a cone.
What about terminal object?
Let me think of an empty block.
Then what should be a structure like this?
Yeah, yeah, yeah, that is the thing.
This is a given data to you.
Not only more objects, you're also given.
Think of an empty block over here.
What is, how do you define something of this sort?
This is going to be an object first of all P with a morphism to each of the object in this block, but there is no such object.
So therefore you don't need to give me any, any, any map over here.
You're good.
But to fill up, if you have any other object with similar property, meaning a morphism to objects, which is nothing.
If you're given just an object, then there has to exist a unique map from D to P.
That was just the, just a terminal object, right?
So yeah, this is a terminal object.
Equal.
And this is product.
By the terminal objects are written as one.
So this is two or rather three different diagrams where they were constructed in a similar fashion over given given some diagram, right?
These are called universal objects and this property that they are minimal in the sense is called universal property.
This is universal property.
Okay.
So the, the, these things may look similar to you and we are going to call them as limits.
Though they have different properties, they share a similar structure.
So in this way, if you have a, so let me give you another example.
First of all, you think of this block now.
Yeah.
So this is, so this structure, not only P, but with this morphisms, this whole cone is called.
So this is P pi X.
In this case, in this case, this is P comma I.
And in this case, this is just.
Let me give you another example. Let me ask you about that.
What should be an universal structure over here?
So this is the diagram given to you.
What do you think should be the universal structure or limit as I call it should be.
Yeah, there'll be P such that.
No, no, this is the diagram given to you.
Just like in this case, instead of two, you have three now and morphisms over here.
What should be a limit of this sort?
Someone from the online audience was saying something.
Yeah, I was saying that there'll be a P object piece.
It's that morphisms from P to X and P to Y.
Yeah.
And this whole diagram will come out.
Yeah.
Because you need to have a map to W as well.
And this triangles commute.
Yeah.
And this arrow, if you remove and say that this whole diagram commute is the same thing
such that given any other object with such arrows so that the outer ones commute, then
there is a unique map which is called.
Sorry.
You have 10 minutes.
Yeah.
Yeah.
So this is called the pullback.
I wanted to give you example of this, but let me not do that now.
So instead of the simple things, you can think of a diagram of any general type to be X to
Y, W to Z, something like that.
A limit would be an object with the object.
This morphisms such that given any other thing with all this data, there is a unique map to P,
which factorizes each of the triangles.
So that is what is going to be called as a limit of this diagram.
So this is a diagram and P with all this map is the limit limit of this diagram.
Okay.
So, and in each of the cases, if they exist, they're going to be unique up to unique isomorphism.
By the way, if you can construct all such limit in a category, then you are going to call it as a complete
category.
If you can construct all such limits over all such diagrams, one can show that if you have products
and equalizer, then the category is complete.
So for us, it is going to be.
Yeah.
So if you have, if you can construct product, if you are, if you have given out any diagram of this type,
you can construct a limit.
It may or may not exist, but if it exists in the category is going to be complete.
You can show that if you have all product and all equalizer, then the category is complete.
So this is in some sense a maximal limit and this is in some sense a minimal type, like they can generate all
limits and the less.
Okay.
In the terminal case, wouldn't morphisms would be from block to P?
Block to.
I mean the block should be.
The block is empty.
You see, there is nothing over here.
There is no object, no morphism.
Just an empty, empty diagram.
So a limit to that is going to be an object with no morphism needs needed.
So that is the case.
All right.
Now, one can say that, oh, why only arrows upward or so in a product, I have defined object with downward arrows.
What about constructing something similar over the given block, but in a downward direction,
meaning that I want to put the object downward with arrow downward.
So every time my arrows are going to be downward and now I want to put the object below.
This is going to be a below cone.
So a diagram of this type is going to be a dual notion to this.
If you remember that I had defined a dual category where I just reverse the direction of arrows.
In this case, I am also reversing the direction of arrows.
Instead of going from P to X, P to Y, they're now coming inside P.
So find a unique map from P to D.
This is what I'm going to call as co-product.
And if it exists, I'm going to denote it by X as joint union Y.
You can already see that this disjoint union symbol is telling you that in sets, they're just disjoint union of sets.
You can think of similar notion here.
This is called co-equalizer.
So every time we just add this adjective co.
So this is co-equalizer.
This is initial instead.
So this was already defined and so on.
So these are co-limits.
Now, so far so good.
So till now what I have done is I have told you that there are categories, small enough and large enough, which says similar structure.
One was infimum and then product, their structures.
What about properties?
So let's come to the category of sets.
What is an injective morphism there?
Or when you call a morphism to be injective?
So if you take a morphism from X to Y, F, you call it injective if F is injective.
If Fx equal to Fy or Fx equal to X prime for X, X prime in X, if it implies that X equal to X prime.
Why erase that diagram?
But if you remember correctly that while defining equalizer, I had a similar problem that they were defined using points.
This is also defined using points.
So let's generalize this property of a morphism.
In some sense you want to define let's say an injective morphism in a category.
How do you do that?
So you have to translate this problem into something which concerns morphism only, which does not talk about points.
So let's think of it in this way.
Let's note one thing that a point in X can be thought of as a morphism from the single term, X bar, which sends this single element to X.
Can you think of it that way?
And then you can define F of X bar, F compose X bar, as F of X whole bar.
That's of the purpose.
So if you look at that carefully, then you have two different morphism, let's say X bar and X prime bar.
This condition is telling you that F of X bar is equal to F of X prime whole bar, which is to say that F compose X bar is F compose X prime bar.
So I'll erase all of this now.
Now simply there are two morphism.
So F is injective, it is given to you.
There are two morphism X prime and X prime bar such that F compose X bar is equal to F compose X prime bar.
Then this conclusion tells you that this was giving you X equal to X prime.
This conclusion now implies that X bar is equal to X prime bar, if F is injective.
So this is still about terminal objects.
What about this?
What about you if you remove this single term and put any general object and morphism there.
Let's say you take this, Z to X and let's say this, any other morphism H and G.
If you consider F compose H is equal to F compose G, then for all Z inside Z, you have that F of H of Z is equal to F of G of Z, which implies that H of Z is equal to G of Z.
And this implies that H is equal to G.
So if F is injective in sets, then this property holds that if you are given any object and two morphism going to the domain of F, if they compose to equality then H is going to be equal to Z.
And not only that, you can prove the converse that if this is the property given to you for F, then this property holds just by considering J as single term and these two maps instead of H and G.
So this is an if and only if condition in sets.
Now this property does not concern about points.
So you can easily generalize it to a general category now.
So this is a property of a morphism.
From sets, I'm going to generalize this to a category.
So this is the definition.
Let me write down it here.
I have this equation.
So in C, C be a category.
F from X to Y is injective or monomorphism.
I'm going to rename it.
If given this data such that F compose H is equal to such that F compose H is equal to F compose G implies that H equal to G.
And this is going to be called a monomorphism.
So this is generalization of a property of a morphism.
You can try to generalize the notion of subjective morphism and call it epimorphism.
You can even check that this is also dualizable and the epimorphism of this, the notion of epimorphism is just dual to this in the sense that you reverse all the direction of error in the diagram.
The conclusion what you get is that this is an epimorphism, the dual notion.
So I'd like to stop here.
There is any question, please ask.
Is there any question?
Oh, I see.
Okay.
If there are no questions, then I'll leave.
Animesh will talk to you.
Yeah.
Yeah, so, so first of all, there are two ways.
What you can do, if you try to mimic this idea that you reverse all the direction, you get a dual notion.
Even for a surjective morphism, I'll just give a disclaimer.
This problem is there in the tutorial.
If you have a surjective morphism F from X to Y.
I am already telling you that you have to reverse all the direction of the arrows to make it a dual or an epimorphism.
So if you are given something like this, so I'll write Y, X and Z.
If H compose Z is equal to G compose Z, then this should imply that H equal to Z.
Then you, sorry, not Z, but F.
Then you are going to call F to be an epimorphism.
Try showing that if something is surjective in the category of sets, then this has this property or this property implies surjection.
It'll be there in the tutorial.
So you're welcome to do this.
Animesh will continue from here.
We'll talk about preservation of limits.
Oh, sorry.
Okay, so this is the last lecture on talk on basic category theory.
And for this occasion, all of these are very abstract things, as you might have noticed.
For this purpose, I want to begin with something very basic.
We all know from real analysis that what is a continuous function.
Let's begin from there.
You have a map F R to R.
And it is continuous.
What do you mean by that?
Anyone, anyone from online or offline audience?
When do you say a function is continuous?
Given delta there exists an epsilon such that F of X minus F of X plus.
Yeah, the distances are not known apart.
It's continuous.
It's ball is open in that neighborhood.
That's one definition.
And there's another definition which is very useful.
Does anyone remembers that?
Something about sequences.
Yeah, yeah.
Continuous function takes convergent sequences to convergent sequences to the same to the point in the image.
So that is, if you have a sequence which is convergent,
then under the action of F,
FXN will be going to FX in R.
In other words, I will write this.
I can write this F of limit of X and N going to infinity is equal to limit of N tending to infinity.
And it is this feeling that we have, right, that you can take limits out that makes continuous functions so interesting.
And it is this feeling that we also want to capture in the case of functors.
We just learned what limits are.
We also learned that you should not think of limits as, or at least limits where diagrams have finitely many objects, finitely many objects and arrow.
You should not think of them as these general things you can, as Dipankar told you, you can think of all these finite limits as just some amalgamation of these two equalizers and binary products and terminal objects.
Taking limit out in the case of continuous function is a very natural thing and which comes out of the definition of a continuous function, but not of any function.
Any function will may or may not preserve this may or may or may not preserve convergence of limits. Similarly, every function in may or may not preserve a limit of any of these.
And it is expected out in the definition of a functor you never say that you want to preserve things like these.
Because in the axioms of a functor you never said that you should preserve the universal property or preserve those objects which has universal property along with their universal property you never had these conditions and you should therefore not even think that all functors should preserve these type of things.
Just like continuous functions do not all functions similarly we need to specify a class of functors which actually preserves these limits.
So let's see first for example what are some examples of functors which actually fail to preserve say products.
And those functors which preserve products. So, so let's see.
Some first example of a functor is one which preserve products. So let's begin with.
Very name this as you, which takes this is the functor which you studied yesterday.
It takes a topological space and just gives you back the set which which constituted the topological space.
Is this we established that this is a functor is this a functor which is preserving products.
Can anyone see what does a functor preserving product will look like well it will take say x cross y.
Product of topological spaces with product topology and it will just map the underlying set of it which will be x cross y to maybe we have not heard of what does product of topological spaces look like, but it's something a topology on the product of the sets.
Whatever this topology is okay for the timing let's not care about this, but anyways this function is going to forget whatever that is and will give me the set back x cross y.
This set, well this is the product of sets Cartesian product of sets. So basically what you're doing is this, you can take this topological space.
x cross y with its product topology, you apply this functor to it, you will get x cross y but you note that this is exactly you x with its topology times you why with it.
That is, you can take you inside of.
So you is a functor which is preserving products.
One example of a functor which preserve products. I hope this is clear. In fact, this is very simple.
Even if you don't know what is a product topology you anyways is going to forget it.
So, that's an example.
This
Reserves
products.
Also note that a terminal object in the category of top is the singleton with its discrete topology that is the open sets are just that single object itself and underlying functor will forget the topology whatever that is, and just will give you just the set.
And that set. Well, again, it's the singleton and this again is a terminal object in sets. So you not only preserve products binary products here.
Because arbitrary products may seem.
Even though it will preserve binary all products. I have not shown you that that is the case. But in that case of terminal objects, it will also preserve the terminal objects.
And terminal objects.
So that's a functor which is preserving products.
Other.
On the other hand, we have cases where functor does not preserve products. And those cases come from the other side.
We had a companion to this functor in fact we had what we call the left adjoint of this, which, if you remember this was a part of an adjunction.
If you don't remember it, but this was the other companion of this functor, which they took any set and mapped it to its discrete topology and discrete space with its discrete topology.
If you take a product of sets here s cross t, and you applied this functor to it, you will land in a in a new topological space which will be s cross t with its product approach.
With its discrete topology, that is the power set of s cross t. And it is not a difficult thing to see that power set of product of two sets is not same as power set of individual sets, even in the finite case you can just look at it by cardinality arguments.
So, what this tells you that you cannot write the following.
This tells me that when I apply a functor on s cross t, I don't get the following product of those two discrete topological space because of this.
So, this is an instance of a functor which does not preserve product.
So, what these pairs of examples tells you that not all functors preserve products, some do some don't.
And hopefully that's a convincing argument and what you're seeing is that this is not true for only these cases.
I do have already noticed that this is the exactly the same functor which we introduced yesterday to motivate adjoint functors.
But that's not a coincidence. The following is also true that in an adjunction the left adjoint and right adjoint preserve various have some very special preservation properties.
So,
you
can see that.
Yeah, so this is, so what I'm trying to say is what a special class of categorical construction that we saw yesterday of left of adjunction, they both the functors left and right adjoint functors there.
Have a special preservation properties.
And their instance can be seen in the examples which I just explained, where we saw that D does not preserve products but you does.
And to understand it better. It might be a good idea to look at what to remind ourselves what is the notion of a disjoint union of sense.
So if you have two sets, S and T, you can define disjoint union between them, which is just a collection of, which is a set in which every element of the, the some and is at is every element of the some and is attached with an identifier from which
some and it's coming from so an element of S will be attached with a special symbol so that to identify that this is not that this is coming from an element of the set and similarly for T.
And this is the notion of disjoint union of sets.
And this is a good exercise to see that this functor D.
When you apply, when you will apply D to this disjoint union of sets, you will actually get that disjoint union of topological space is back.
Again, you all you have to check is what it does on power sets.
And that's not a difficult thing to see.
So not only D does not preserve products.
D preserve disjoint unions and disjoint unions are also known as co-products in category of sets.
Co-products because these are exactly the opposite of products, preserve co-products.
So you preserve products.
D does not preserve products.
D does preserve co-products.
What about you?
Well, in this case, what about you in the sense of co-products?
What does you do with co-products?
Well, this is very simple to see topological disjoint union of topological spaces are built upon disjoint union of sets.
And since I'm just forgetting the topology on that set, on that disjoint union of sets, so I will get the disjoint union back here.
So in particular, you will also preserve co-products.
But that's, well, it just happens because you is a very simple fun.
Okay.
Actually, this for data, all the four combinations with, you know, products and co-products with two functors, these four cases will have in out of these two.
You preserving products and deep preserving co-products is a case is an observation, which carries on to all adjoint functors.
In particular, here's a very big theorem, which of course we cannot prove right now.
Okay.
Yeah, so, so what Sir is trying to say is that the fact that you preserve co-products is not an artifact of its simplicity.
And there's a further further right adjoint to this functor, which takes a set to its indiscreet topology and being left adjoint it as we will see soon see, and that's the reason why it will preserve all co-products.
So, let me explain the theorem then this might be more clear.
So, you have the following theorem.
Let, let the following be an adjunction, be an adjunction.
What is the adjunction here you have two categories, you have a functor L, you have R, and you have this as an adjunction.
Then, maybe I'm speaking just the small part of that theorem, but that will do enough job for us that L, the functor L, L preserves co-products.
And by the fact that L and R appear in an adjunction, that's enough to tell you that L will preserve co-products and R will preserve products.
And R preserves products.
More is true but for simplicity, let us focus on this.
Hopefully now it's clear why these two things are happening.
You is preserve, you is preserving product because well that's the right adjoint, these preserving co-products because it's the left adjoint.
So, it is an artifact of this theorem.
Okay, so that's a situation where adjoint functors come into play very nicely most of the functors which you will.
We'll encounter in nature with which we preserve products and co-products more often than not they will form a nice adjunction.
But that's just one part of it.
And let me give you to have a good intuition of what preservation of functors is let me give you some special simple examples and we will together work them out.
Okay.
So, I think we all like finite sets a lot.
So, let's see some simple examples.
So, we know about this small, very, very simple functor which we introduced.
Maybe I should be more simple.
Take three sets x, y, z. These are sets in this category, category of sets is the following true.
I hope we all know what product of sets Cartesian products of sets are x to y cross z is this in bijection with the following set all functions from x to z, and all functions from x, oh, all functions from x to y, and
all functions from x to z.
Can someone give me a bijection or prove me that this is not bijective between these two. These are, this is a very simple question, you can think of it.
You have a map here from x to Cartesian product of sets, you have individual individual maps here.
Let's begin by analyzing what an element here will look like.
It will look like a map from x to y cross.
Can you get from this map, a map from x to y and a map from x to z. Of course you can.
Maybe I should write this a bit above x to y cross z. It is an element on this set, and this has two projections to z, say pi y and pi z.
You compose pi y with f, you will get a map from x to y, an element here.
You compose pi z with f, you will get an element here.
An easy verification will tell you that this is not only a map, it's injective and bijective and hence a set bijection.
So in particular, it will be explicit by y, oh, f, and pi z, oh.
This holds, and will someone like to conclude what this tells me?
Anyone from online audience?
This tells me something about preservation property of a functor which is hiding in here, which hopefully you can see.
Anyone?
Sorry.
Yeah, which functor preserve products?
Home x, y to y.
Okay.
A functor.
So, so, okay, so first of all, this functor will be from sets to sets. What will this functor do on a set x.
Set y.
So, if we fix a, if we fix a set x.
Yes.
So this will send y to home of x, y.
Yes. Yeah, that's I hopefully, hopefully that's what you were getting. Okay.
So, yeah, the functor which is doing the preservation of products here is as follows.
You, the functor is this home sets.
And it's accepting an input on the other side from a set of sets to sets.
What is it doing on a set y here? It's mapping it to the set of maps from x to y. Right. So when I replace that y by y cross that I get this set.
Right.
And so what this is doing, telling me that home x blank, it's preserving binary products. Right.
You can take the functor out of the products. So you can take the funter inside the products. That's, that's how you think about preservation.
So that's one example.
There's one more example of a similar functor. This is a covariant home fun if you remember the name.
There's another functor called contra variant home functor. Let's see what does that preserve. So co and home functor preserve is preserving products so we should expect that it should preserve.
If co and Tom is preserving products.
Are you expecting contra variant home to preserve products as well.
So let me write that if this is here.
So, we had this functor was home x blank. The other companion to this was as we saw home blank.
So, let me pose the question more concretely, is the following true. And again, you can check.
Home sets.
Y cross Z to X. Is it same as.
Home sets.
Home Y to X cross home.
That's Z to X.
Is this same.
You can think here for a little bit.
Yes, why.
You can use the cardinality are in fact here's here's a very simple argument take Y and Z to be singletons Y cross Z will be singleton, all the maps from set singleton to X correspond to all elements of X.
Well, so if Y equal to Z equal to singleton, then the cardinality of this set will be.
Cardinality of X, but since why is also singleton and Z is also singleton so it's also cardinality of X, and it's cardinality is also X.
Of course, if X is any, anything greater than or equal to two then this will never hold. So, so contra variant home.
The blank X sets.
There's also said, does not preserve products.
Does not preserve products.
So that's one conclusion and this preserve products co variant home.
In fact, the fact that the fact that co variant home preserve products contra variant home does not preserve products is as important as it's as important as co variant and contra.
In fact, the fact we use co variant and contra variant home functors is of their nice preservation properties at times. Okay, so, so that's for preservation.
We saw how adjoints nicely preserve adjoint functors give me nice preservation properties.
Now, I didn't complete the adjoint functors much. I want to give you more examples in adjoint functors because I think that that topic is.
Anyway, it's very abstract and I didn't give give it enough justice. So, let me hopefully this thing is clear.
And this is the I think the first time you have seen a theorem in this three days lecture in category theory. So, that's something good.
So let me give you some more examples of adjunctions of course, as pre orders and partially order sets gives us very nice class of examples of adjunctions so I will keep my focus only on there, even though there are many, many,
many more examples of adjunctions at times in certain courses, a given adjunction to prove that this is an adjunction is very useful, not useful it is the main theorem at times.
So, so let's go back to adjunctions.
I'm sorry adjunctions and adjoint functors, the name is same it's just just different.
The names are different but they are same.
No sound again.
Sorry.
So,
yesterday we discussed monotone Galois connections as an example of adjunctions, and they themselves, that is a definition, but that definition is itself a part of is itself an adjoint functor.
So, I want to give it's contra variant functor to me.
So, which is called, as I will soon explain to you but let me give an example first so take a group G, or yeah.
Group G, you have this preorder, or opposed all normal subgroups, groups and G under inclusion.
Okay.
And you have here all the quotients, you know, take you can take quotient of a group G with normal subgroups so you have quotients, all quotient groups.
Oops, G by.
Okay, thank you.
G by and under.
And someone give me maps between these two posts.
What about this side.
This is a very simple mapping, you take a normal subgroup and do what quotient it out.
It's very simple. So, let me write this as F takes a normal subgroup and maps it to G by.
Okay, what about this side.
This side is interesting.
Well, we're not so interesting.
You take a quotient group, say, so whenever you have a quotient you have this map right.
It's a subjective map on to G by and what's special about this is that its kernel is exactly the normal subgroup with which I'm quotiently.
So if this is five, then I'm going to take.
So let me write by G by and to denote that this is the subjective map of the discussion so kernel of five G by and is exactly and the normal subgroup of G.
Okay.
So, so this is the map of which takes the kernel.
That's fine.
Colonel of the trivial subject associated to that portion.
Now, note the following.
If you have a normal subgroup.
That inclusion of normal subgroups. So, maybe what I will write here is the kernel of five G by and to.
So, this will be exactly and to write.
So, if anyone is contained in and to, then what about the quotient group of G by quotient group G by and so if I write G by anyone here.
Will it be contained in G by and to or will it contain G by and to.
So, because anyone is contained inside and to. So what will happen is that when you call the smaller the normal subgroup the larger the quotient.
So this will be larger, and it will contain G by.
Right.
So, this is in, in this side, and this is in this side.
This is if and only hope that's clear.
If anyone is contained in and to if and only if the quotients are containing the quotients are contained in the other direction.
And for the same reason, the smaller the normal subgroup the larger the quotient.
So, this tells you something different than monotone Galois connection, you might remember.
Okay, let me write this in much more approachable fashion maybe. So this will be G by and one will be exactly equal to f of.
What we are seeing here that and one is contained inside of this.
G of G by and to.
If and only if.
If and only if G by and to is contained inside.
Okay, so.
So, what we are seeing here is the following fact that you have this post that you have these posts this post it, and G and f are contra variant in some sense, the G is taking f is taking a large,
large element here large in the sense of its rank in the whole post it, and it's mapping it to something small.
And a small element here will be mapped to a larger element monotone Galois connection on the other hand, preserve their respective positions, whereas this where you are seeing that we write the monotone Galois connection.
So you had f here, had G here, and Q.
And what you were seeing there was, if you have an element P here.
So, if P is less than Q, if and only if he is less than GT, whereas here, you're not seeing that you're, you're seeing that both of them are kept on the one side, this is not an incidence.
Here, monotone Galois connections were supposed to preserve their respective positions.
And this contra variant version of that is not supposed to do that. Well, because it's by the nature of the relevant mappings. This mapping in particular is taking is order reversing both of them are order reversing maps.
And for order reversing maps. We have another version of Galois connections which is called anti tone Galois connections. So, thank you.
Let me write this here because we don't need this.
So anti tone Galois connections are exactly contra variant versions of monotone Galois connections. And they are also adjoint but contra variant something that we have not seen by the way contra variant adjunctions is a
requirement. So, anti tone Galois connections.
So, if you have four sets of pre-order speed and Q and order reversing maps.
It's not preserving but reversing.
So what that means I will write synapse.
So, I have a map F from P to and it said to be order reversing if even if this even less than P to here is mapped to.
So it's order reversing as is visible and order reversing maps F in this side and so that's order reversing that's very clear.
So F is going from P to Q G is going from Q to P and both are order reversing. So that's for F and similarly for what will happen for G is that it will take to G Q to G Q.
Note that this is exactly what we are seeing there.
F and G are order reverse smaller normal subgroup will be taken to larger quotient. So, if this is the case.
If these two functions F and G F from here G to here satisfies the following such that if you have P, which is less than G Q.
Only if Q is less than F P then then F and G said to establish antitone Galois connection antitone Galois connection.
So, here's an example of an antitone Galois connection.
And this shows that this is indeed an antitone Galois connection and for the final example of category 30 lecture talks we have the following famous antitone Galois connection.
Let me remove this.
So, Galois theory deals with seeing how much symmetry is there in roots of polynomials.
And it is very famous because it has various applications of one part of fundamental theorem of Galois theory says the following that if you have.
So, this is of course not supposed to be digested by all but this is good to have in mind as an important example of antitone Galois connection, so to remind yourself where this name is coming from.
So, if you have a Galois extension L over K of fields then you have the following all intermediate field extensions.
Say L containing M and containing K and on the other side you have all subgroups of Galois group, famous Galois group of L over K is a Galois extension.
Sorry that's just of course not supposed to see digest this but as I said it's good to have subgroups of Galois group of Galois group of Galois L over K.
Both of them are first of all posets and under inclusion of course you can include one intermediate extension into other and subgroups this is just the subgroup lattice and on the other so this mapping takes an intermediate field extensions and say M and maps it to its Galois group L over K.
Note that the larger the for those who know the larger the intermediate field extension the smaller will be this Galois group in particular when M will be L the Galois group will be crib and it takes a subgroup to its fixed field and fix H.
Let me not explain what this is but whatever this is this is very important.
Yeah, so, so that's a very famous example of an anti tone Galois connection, these are order reversing mappings, the larger your subgroup is the smaller it's fixed field and the larger your intermediate field extension is the smaller the Galois group.
So, and of course all monotone Galois connections and the whole of the examples suit of examples which I talked about all of them comes under the umbrella of I joined functors so of course all of them are adjoints.
So here's one of course this is not the fundamental theorem Galois theory tells you something more, but this is one part of it.
So, my time so great.
Thank you very much.
Any questions from online audience.
The previous adjoint functor example was actually part of equivalence right FNG booth.
I think it's based but with the one which involved normal groups and yes, yes, yes, yes they were because when you compose when you go around in a whole circle you will land back where you in fact this this fundamental even Galois thing is also part of equivalence.
Yes, yes, yes.
Correct.
Thank you.
Okay.
Any more questions.
Oh, no, no, no, no.
Let me just draw pictorially what we are, where we were. So these are all the adjoint functors.
Here's monotone Galois connections, and here's anti tone Galois connections.
Yesterday I gave you this suit of examples.
Today I gave you this adjoint there are many adjoint. We are biased here because we have only learned about pre orders for sets.
There are various in very interesting examples of adjoint functors which of course we cannot explain. Okay, I hope that's, yeah, please don't conflate between Galois connections and adjoint functors not all Galois connections are adjoint functors.
Oh, sorry, yeah, sorry, sorry, all, not all adjoint functors are Galois.
Okay, so we end our session here. And if someone continue to talk with on English. Okay, so we have a small tea session and after that we meet at 1145.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
So audible.
Hello.
Are we audible.
Yes, yes. Okay, okay.
So, welcome to the second session of the day. Yeah, Professor move our energy will continue talking about propositional logic and stone realities.
Thank you.
So, I'll begin from where I left yesterday. So that was kind of hurried.
So we had said something about the quality of the single term style and the double term style right. So, just to give up.
I was actually pointed this out by Amit and another participant that something more needs to be told about this at least the history.
So, as I said, this direction I mean is expected and that's called the soundness I mean, otherwise why would you be proposing an action for a semantic you want this thing to capture, or at least whatever you are proposing here should be, you know,
something to capture things in your whatever semantics, you're proposing. So this is kind of like already embedded that highly non trivial direction is the completeness that is the reverse direction this I mentioned.
Now, as far as the first order logic goals which is what I think you will learn in a later lecture. So that I also mentioned yesterday.
So we have to include quantifiers and things like that it's a far richer language, but don't forget that propositional logic constitutes the base of it okay so we don't want to lose what we call tautologies and we have enriched the language so we can capture a lot of other expressions as well.
So in this system, any system you build, you will be talking of a notion of derivability, and or provability, and the notion of validity.
All right, so the goal in each case would be to make the two coincide. So in case of a first order logic, the name that comes foremost here.
In 1929 is when the famous goal, I hope, all of you have heard of this famous logician. So go ahead and prove the completeness in case of first order logic as far as, and then later on this was simplified by Henkin in late 1940s, I think 1949 or so.
And that is the proof of completeness that has become very popular and most of us use it post office have learned it that way which is based on this model existence theorem that is consistent sets have a model and so on right.
But as far as propositional logic is concerned, which is what we were discussing yesterday, the completeness proof was given very simply by post, and that was earlier in 1921.
So that's a different proof. I mean, different in the sense.
Well, some approaches follow that one. It's a very neat proof. But there are other proofs to make you know, treaties or discussion simpler.
You just adopt Henkin's proof into the statement calculus or a propositional logic. So, here also you define some notion of consistency and so on. So that also can be done.
So now in this. So that's about the brief, you know, history about someness and completeness results, which I hope you're appreciating are really fundamental when you want to propose a formal system of reasoning.
And the next thing that I want to point out is this minimum Tarski algebra that we defined. Recall that how we define the equivalence classes that is the elements in the quotient set were basically all those formally which are logically equivalent to alpha.
So this, please recall, we defined in several equivalent ways, right? One of them being now that we know all the notations that this is valid. At that time, we had said alpha by implication beta is a tautology, but we know that's just the same as this in the notation of the
Now, if you assume this one, right, so you can equivalently talk of an equivalence class being, you know, consisting of beta, which are provably, you know, the by implication is a provable is a theorem.
So that's the word we used, right, is a theorem. Now, so that so independently of this approach, just like the syntactic approach we developed totally independently of the semantic one, you can define the Lindenbaum Tarski algebra completely independently of this way.
How would you do that? You would simply replace this by, so called to formally equivalent provided alpha by implication beta is a theorem, okay, and that has nothing to do, need not refer at all to true or false or anything.
You got my point, right? So that would be an equivalence relation as well. Okay, so in terms of the single term style, okay, so just to be clear. So here I am just replacing this one by this.
All right, so please note this one. All right. So now, just to come back to the last thing I think I discussed yesterday, that how we generalize this one, the original one being with reference to the
Boolean algebra 2, we can generalize this one to validate you over the class of Boolean algebras, the whole collection of Boolean algebras, right? So what did this mean? That in any Boolean algebra, alpha must be true.
What did truth in a Boolean algebra mean? That you first of all generalize the notion of evaluation to go not necessarily to the special Boolean algebra 2, but to whatever Boolean algebra you're choosing, right?
And so here you will have a top element. So truth would simply mean of a formula would mean that is goes to that top element, right? So if that happens for every evaluation in every Boolean algebra, then you said this.
So we were wondering whether this has any connection with this, right? So in order to prove that we, this direction we said is again very simple. You just go to your Boolean algebra, look at your actions that you have defined in propositional logic.
You translate them, all of them very trivially follow to, you know, go to the top element in every Boolean algebra, right? So about the converse, we did kind of cheating.
So what did we do? We said that, okay, let us assume this one, but then that means alpha is true in every Boolean algebra under every evaluation.
In particular, it is true in 2, the Boolean algebra 2 under every evaluation, but that simply means that you've got back this one, because that's, as we noted, that's simply just two double-turn style alpha, right, in that notation.
So assuming this one, you then get this, right? So this was our, if you have in hand this Boolean, this Lindemann-Tarski formulation, what you can do is you can actually drop this and directly there's, this is a very patent proof that goes on.
So here note in this Lindemann-Tarski algebra, what is the top element? There we had all the tautologies forming the class, right?
So here you would have, similarly, you can prove that all the theorems constitute exactly one class, all the anti-theorems or the negations of theorems form another class and so on, all right?
So using that fact, you can actually come back, take the, this Lindemann algebra in particular, so this is 2 under every Boolean algebra, right? So now consider this Boolean algebra.
So in this Boolean algebra also it's going to be true, right? So there you just figure out what one particular canonical valuation, because it's going to be 2 under every valuation.
So you pick out once appropriate valuation, which is called the canonical valuation, and then you use that fact that under that canonical valuation also it should be true.
You show that under the canonical valuation, the formula must go to the class of all theorems, so it becomes a theorem, okay?
So that was kind of a very rough sketch of the proof, but what I just wanted to mention here was that instead of this, if you look at this version, but note that these are just the same.
These sets are just the same, because these classes are just the same, right? It's just a different way of looking at them. Please understand that, right?
So the only point I'm trying to make is that instead of this one, if you begin with this Boolean algebra, you can get a direct proof of this implies this, rather than, you know, go to this and then use that one.
All right, so that's one point I thought I should make.
Okay, as far as reference goes, so I'll now move into the Boolean algebra and duality terrain.
So as far as reference goes, I have, I mean, I don't know what exactly reference to give because I've been teaching this now for some 20 plus years.
So I have a lecture note set, which I prepared for NPTEL, so that I can share with you if you want, but that has a whole lot of things.
So the propositional logic portion, because there are loads of other fascinating aspects of propositional logic, which we are, of course, unable to talk about here, even touch.
So like you have syntactic issues like adequacy, you have compactness, you know, so all this activity and all those things.
So, you know, so those other kinds of proof theories, we just talked about the axiomatic method, there are various ways of getting hold of single term style.
All right, so those things you may get an idea of and you may decide to follow up later. Okay.
Okay, so now I come back to our minimum Tarski algebra, which we discussed yesterday, and we already noted that with respect to these induced operations, right.
These contradictions, this is a Boolean algebra, but I am sure you were told that in a Boolean algebra, you can induce an order, right, because it's finally a lattice, right.
So in any Boolean algebra, you can define a partial order in this manner.
All right, so one may be curious to note what is the order here.
So when do I say that the class of alpha is below, so to speak, class of beta.
So if I just follow that one, then I should have this one, right, and this we know is this class.
So basically we are saying that this is a tautology, right, of which one direction of the implication all of us know.
So now just connect everything with, you know, and our natural understanding of and and also alpha and beta will of course imply alpha.
It's like the lower bound kind of thing. Okay, so what is actually coming out of this one is this.
All right, so when you have an order and so it's very simple to actually connect as well.
So essentially when we are saying class alpha lies below class of beta if and only if this fellow is a tautology.
So it's very neat because the equivalence you defined with the bi implication, the order you are defining by a single implication.
Okay, so that's how that's what the order is fine.
So let's keep that in mind.
And now let's move to so another thing that we have already noted yesterday by some argument is that when our positional variable set is finite.
Let's say n propositional variables, then this also the cardinality is I mean this is also finite.
And this is another point that you may do as an I have given as an exercise where it's very simple that any finite Boolean algebra is atomic.
Okay, so what's atomic.
For that, let's recall what the notion of an atom in a Boolean algebra B is.
So atom A. So what's an atom supposed to be that it's.
No, you are taught an atom.
Okay, so, so what do we expect from the word atom so it's like you know one of the basic, you know, so you cannot basically go below it kind of thing but what is below the bottom there is a bottom element there's a zero.
So it's like you can visualize it as you have a zero here, and you're talking of a here so a definitely cannot be zero.
And you should not have anything in between.
Right.
So which means you can write that as if we less equal to a, then B is either zero or equal to a.
Any finite and okay so that's a notion of an atom and a Boolean algebra is said to be atomic provided below every element you actually can go to get hold of an atom below every element of such a Boolean algebra you should be able to get hold of an
atom.
Very easy power set Boolean algebra is it atomic.
Because look at the singletons, they will lie below whatever element you take you'll get a single can be okay.
So, the exercises in particular if you take in any finite Boolean algebra it will turn out to be atomic.
Okay, so that's not very hard to do you can take that out.
So, given that one, if I restrict myself to this scenario, this Boolean algebra becomes atomic.
Okay, that's fine.
But what I want to sort of take you through is what do those atoms look like here is like you know it's an atomic so what are the atoms I don't know from just that statement right.
So, let's go to that.
So, I am what is the scenario I'm considering.
I'm considering that PV is this one, and I want to find out when a class alpha belonging here is an atom.
And I wanted to do this because we have spent some time yesterday dealing with some very very special formulae.
So, remember that construction we did towards the end of a truth function and for every truth function getting hold of a formula, right F and AS, how did we construct the AF safe.
If you take the formula AF how was it constructed you looked at you first constructed those conjuncts those very special conjuncts.
For every row then you just picked out the true rows did the disjunct of the corresponding conjuncts right.
So, this kind of indicates that you take any arbitrary formula, because this is going to be finally a disjunct of this one, right.
So, these fellows seem to be lying below so lying below by that I mean should imply that formula, which is the disjunct of these guys.
Are you getting my point so this AF was defined in this manner now if you just focus on this guy.
So, this is a disjunct of this one right.
So, this or this or this kind of thing.
So, it indicates that a disjunct is obviously above.
I mean components, yeah the whole disjunct is above any of the components right so above by above I mean so this above below thing we will be using in a informal manner but I mean implication.
Like we did that in case of the order.
So, what we are claiming is so this also is part of the exercise is that if you just take these classes.
So, like if your I were equal to two, how many such classes would you have what would be the inhabitants of those classes P1 and P2 P1 and not P2 right.
Getting the picture.
Each of them will belong to some class they are not equivalent to each other each of them will belong to a class.
And what is the special feature of these there is a unique valuation satisfying them right.
So, this cannot be the contradiction class.
Where we are going right so this is certainly not the contradiction class and I can verify that if you take any beta which is below this guy.
So, and suppose that beta is also not the contradiction class then you can show that this will have to be equivalent to this one that is then beta must be equivalent to your this.
Of which one direction please note is already ensured by this is an assumption right we have said like this and this we want to show this to show.
So, this direction of the implication is already assumed.
So, what we are asking is about the converse that if you just give it a thought is kind of very simple because given the fact that there is exactly one valuation satisfying this right.
So, you have to check out if beta is falsified by every other valuation or every valuation other than the fellow which makes this true.
Right. So, for so, so that you should check but and there you also make use of the fact that there is at least one valuation which makes me that true.
So, these two facts coupled together and will give you the fact that these are all atoms plus every atom has to look like this.
So, that's the next exercise.
So, complete this one and that every atom is of this form.
In fact, so, yeah, so every atom is of this form and we've already noted this is finite so atomic but you can directly show also that below every class alpha you will find such an atom.
All right, which will make directly give you a direct proof of the fact that this Boolean algebra is atomic.
Below it. So, that's where we will make use of this result that every formula can be actually expressed equivalently as you know a disjunct of this one.
Exactly. So, that's very crucial. That's why I sort of made it a point to mention that.
So, that you use here to get that. So, you start from an arbitrary class alpha, you make use of that equivalent formulation that's why it's called the canonical disjunctive novel form.
Okay, so make use of that and get hold of that and below it. Right. So, this one is kind of sums up the picture when the collection of propositional variables is finite.
Okay, so now let's translate to the other extreme, suppose it's infinite.
What is the scenario.
Right.
So, here I again construct my Boolean algebra in Mumtarski algebra and there my claim is that you have gone to the other extreme here.
The result is also the other extreme. The Boolean algebra is atomless.
There isn't any atom in that algebra. Okay. So, in order to prove that. So, how do you show there isn't any atom in the algebra.
That means you take any element here. Whatever element you take below it. Right.
There will be something. So, that cannot be an atom. So, which means there will be something strictly below it also.
Right. It is non zero. Right. This is basically what we have to figure out. Right. So, given any beta.
So, this is a very nice exercise. So, where clearly this thing has to feature right in that verification. Right.
So, what is given to us only this beta is given to us beta is a string finite sequence.
There are only finite number of propositional variables in it. Your collection is infinite.
So, you just pick out some propositional variable, which is not one of the ones inside beta and do something with it. So, get hold of a new formula and then you know.
So, whether. So, I don't know whether it will work for the. So, you just work this out. I think it's part of the exercise, but so the other special thing about this atom less thing is that up to isomorphism.
So, this is a countably infinite set as we have discussed mentioned yesterday. Right. So, up to isomorphism.
There is only one countably infinite atom less Boolean algebra.
So, there can be various ways of, you know, defining those countably infinite atom less Boolean algebras, but they will all be isomorphic at the end. That's the, and that's a non trivial statement, but what's nice is that you have actually an example sitting in
there, like you to which every other countably infinite atom less Boolean algebra would be isomorphic. All right. So, that's why I thought that I will mention this to you.
Fine. So, this is my discussion about the atoms. And now I will move to the representative. Yes.
So, the Boolean algebra with the resulting from, you know, countably infinite TV based on a countably infinite TV, when you what Boolean I'll do the question set Boolean algebra you get will be at.
And this is up to us. No, no, no, no, wait a minute.
The TV is infinite, right? You have taken an infinite TV, you've constructed the question set, you've got the Boolean algebra. So what I was mentioning there is that because this is infinite, you will be able to prove that it's
atom less, you take any other countably infinite atom less Boolean algebra, it must be isomorphic to this guy. That's what I'm saying.
Exactly. That's what I'm saying.
So, yeah.
There are many, I mean, uncountably you take all the power set Boolean algebras, right? So, they're going to be power set Boolean algebra, they're going to be atomic and then you can have various different kinds.
I mean, all atomic Boolean algebras needn't be isomorphic to each other and so on, right? So you
I didn't.
No, not necessarily, right? So power set Boolean algebra would be, I mean, often is that would be uncountable, right? So then, but it's atomic. So not necessarily all uncountable Boolean algebras must be
atom less, right? So for when it's, so when you have countably infinite Boolean algebras, which happen to be atom, which are atom less, then you get this one, this result of isomorphism.
So, I think I'll just.
Okay, that proof is very involved. I'm not getting into it just now. Yeah, yeah, so definitely, yeah, so that has to, that will play a role here. So I don't think I want to get into it, but we can discuss it here.
Okay, so because there's a load, I wasn't supposed to do this, but I did it because I wanted to give the connection. So let me now get into the representation theorem.
Only representation theorem part one.
So part one or one.
So that will be dealing with finite Boolean algebras. Okay, so for that homomorphisms were discussed.
Between, well, okay.
Like we do, we're used to homomorphism notions in algebra.
So suppose the NBR to Boolean algebras, so they're supposed to preserve the structure, right? What are the structure involved here those meet join complement zero one.
So, what you would define this one as is, so you have some meat join here let's do an abuser of notation use the same notation. So, if the meat is preserved.
And the complement is preserved.
Okay, or if I have been using the, this one negation then this.
And it's a simple exercise to show that the rest of the things will follow that is join will be preserved, H of one will go to one H of zero will go to zero.
So duly you could have started with a joint as well so that's not an issue.
One important very useful fact that we are going to use will be that a characterization of isomorphisms. Okay, in representation theorems you're always going to kind of talk of isomorphisms finally.
So, a given a surjective map.
Okay, so suppose you're taking two Boolean algebras, and you have taken an onto map between them.
Then you can show this I've given as an exercise is an isomorphism.
So all of us understand what an isomorphism is. So that's a bijective homomorphism, right. So this would be an isomorphism if and only if you have the following order preserved both ways.
So you begin with an onto map, you will be able to show that it is an isomorphism. So please understand then that we have this is embedding in itself, injectivity, as well as homomorphism, right.
So you're saying that it will be injective it will be a homomorphism provided you have this. Okay, this if and only if.
And then you have very nice results that atomicity is preserved atoms are preserved and so on so all those things kind of coming immediately.
All right, so now I'm ready to state the representation theorem one, which is that any finite Boolean algebra is isomorphic to the power set Boolean algebra of some over some set.
Let's talk of the Boolean algebra be fine. And it's finite. So it's going to be atomic. Right.
Consider it set of atoms. We are not going to consider degenerate Boolean algebras.
Atom set will be non-empty. Okay, so A is non-empty.
Oh well, empty. The minimum one we are taking is 0 comma 1. Okay.
So set of atoms of B that will be your non-empty. So the powers. So the set we are thinking looking for is just a and so the idea is to show that this will be isomorphic.
Okay, so what is the map.
So it will map every element to.
Okay, so you're given an element on the right hand side you have atoms, atoms we know are kind of the bottom elements just above zero right and you have some B sitting somewhere in the Boolean algebra.
So you want a collection of atoms here. So somehow you wanted the all the atoms here to be related to that be right. So what would you choose.
Just choose the guys line below B to all the atoms that lie below B. There is at least one atomic.
Okay, so you just take this one and show now using this fact that which is on the right hand side you have sex right.
And the fact that it is on to let me just give a sketch of the proofs for one. So notice that H of zero is just the empty set.
Atoms below zero. None. So the other way round that is not other way round so you'd now just take any other that means non empty. So empty set we found a pre image right so now take a non empty subset of atoms.
So everything is finite out here so note how very how we will have to show you we will be using that one. So suppose you have this S as this collection.
You want to define an X such that H of X must be S. So that means all of these right must lie below X. So again what I was informally trying to say earlier what would be below.
You know they would all lie below all these AIs will lie below which element the disjunction right. So if I just took a one join a two join and then that would be definitely above each of the AIs right so the candidate for X then is
right. So then you just one direction is again very trivial. So you just look at how H X will be a subset of S. So now why H X should be a subset of a so that means I'm going to take any element here that is a less equal
to X and A belonging to A and we want to show then that it must be one of these AIs. See it may not be so obvious. So I've taken an arbitrary atom. The thing I've assumed about it is it's below X. I want to show that it must coincide with one of the AIs.
That's it. That will complete my proof. AIs are also atoms. So what we show is we just show that there is some I that A is below AI. Now if I'm able to show that because A and AI are both atoms it will mean that A will be just has to be just the same as AI right.
Now we argue by contradiction. Suppose this doesn't happen for any of those eyes. That means A is suppose A is not less equal to AI for each I right. So I equal to one.
Now there is this thing that I've also given as an exercise is a very salient feature which we very often use is that in a Boolean algebra you have this if and only if A meet B complement is equal to 0. So I just pardon me I may be using this complement or negation you know alternatively.
So this is another very easy exercise that you can do. So now if I am assuming this one, then I'm basically saying that.
Oh, wait a minute. So I'm mixing that up. That's that's not the one that we will use here is one nice property of atoms that we get in a Boolean algebra which is this is also an exercise there so for a moment I just.
Yeah, so a property of an atom is that given any x either a is below it or it is below the x complement.
Okay, got this result.
If a is an atom give me any element of the Boolean algebra, either the atom will be below that element or below its complement one of the two.
This is also very simple thing to prove. So now we use this one here. So a will be below for each eye.
Right. So that means it will be below the conjunct of A1 complement A2 complement and so on. Right. So that means it will be below the disjuncts complement.
So in other words, I'm saying that this is below x complement. Just use demorgan. Okay, but we've already assumed that it is below x. That means it's only choice for it is to be zero but is an atom not possible.
So that's how you get this the subjectivity proof completed. And so try it out yourself. And as for the other one, the second part.
Again, one direction is very simple. This will clearly imply this one. So for the converse also is very simple. I think I'll just leave this for you.
What you will be using is the atomicity. So I mean, I can start you off by, so I want to show this implies this. So I'll do the contraposition of that. So suppose this is not the case.
Okay. And that's where I will use that result, which I just mentioned. So this will mean that x me to y complement is not zero.
Okay, so what have you got you've got a nonzero element, your Boolean algebra is atomic. So there will have to be an an atom below it.
All right, and then you complete the argument. Okay, so that will complete this proof.
And yeah, so there are two important corollaries that immediately come out of this representation theorem. One is that now you can identify all Boolean algebras finite Boolean algebras to be just they have to be powers of two.
Because you've made it isomorphic to the power set Boolean algebra, right, then power set Boolean algebra I think a power set. I think all of you know will be in bijection with two raised to a right.
So, your, if you're asked to give an if you're asked for example whether a three, you can have a three element Boolean algebra, not possible.
Right, so every Boolean finite Boolean algebra has to have cardinality two ways to something clear. The other one is that every element in a finite Boolean algebra through this proof if you've followed it or just do it I would suggest that you do it if you haven't, you know, just to convince
yourself every element in a finite Boolean algebra will turns out to be exactly the disjunct of all atoms below it.
Okay, that's the other color corollary. Every element must be the disjunct of all atoms below it. And that will come from this part of the proof that we were doing.
Okay.
So that is about our finite case. Now I'm ready to go to the general case. Now, so obviously the question that one will ask is that, okay, you got an isomorphism in the finite case you expect an isomorphism when you drop the finiteness condition.
No, may I ask one question here? Yes, yes. How will you tackle with this two element Boolean algebra in this remark? You need a set and you need a power set. Yeah.
So it is actually it should be a single term set.
Sorry, I didn't get the question.
So if you want to get the two element Boolean algebra, an isomorphism of the two element Boolean algebra.
Oh.
So what are the atoms there? So that's just one element, right?
One element. So it becomes dk.
Now you are going to the power set of that one.
Yeah, so that one has how many elements that means, that means you, you, I mean, the, the set you are going to take.
This case becomes a degenerate one sort of the power set Boolean algebra offers of this.
It should be a single term set that is, we also have two elements, right?
In the power set, there are two elements that two elements and that is the answer.
Yeah, but my question is whether you mentioned that it should not be degenerate.
Yeah, so you can have actually there are ways of looking at degenerate means you can have zero equal to one or you take the empty you cannot have zero equal to one is the case when you say, you know,
the Boolean algebra is degenerate in that sense.
There is various ways of putting it degeneracy could be when you're zero and one coincide but even that I don't know degeneracy.
Yeah, that is the ultimate one.
Yeah, so this two element Boolean algebra one would not call a degenerate is as far as I know.
What is that when you say that the atom set is non zero and you define atoms as element other than zero.
Yeah, then you are really perhaps facing a little problem.
No, if you have two elements, then you don't.
So you have at least so if you have zero comma one, then one is the atom there.
Isn't it.
So you have non emptiness.
One is the atom.
Yes, one is that.
Yes, yes, yes, of course.
Oh, fine.
Yeah, okay.
Yeah, okay.
One is that.
Yeah, so now the question let me return to that.
So do we expect this isomorphism.
In the, if you drop the finance.
Why not.
Sorry.
So, in which case we will it not work.
So what kind of bees.
So if you, yeah, of course.
So, so basically you are just, I mean, now that now you are you have all the information.
So for example, we have in hand atom less Boolean algebra is also right.
So, on the right hand side you necessarily have an atomic Boolean algebra you could never have an isomorphism between the two.
Okay.
So, you know, there are, we are so various ways of putting it. So what happens in the general case.
So for that we come to the notion of prime filter.
Now you will have to tell me what was defined.
Okay.
So ultra filter.
Was not defined.
All right.
So let me define this.
Okay.
So, so prime filter.
So we all know what a filter is.
Right.
So, let me write everything.
So filter.
Well, non empty.
This gets in.
This is inside and it's below something that will also get in.
This will define a filter for me and a proper filter.
So sometimes people assume properness inside this one.
I'm just separating it out.
So proper, as we all understand, you know, proper subset.
So what it will mean is this, but that's equivalent to just saying that zero doesn't belong here.
And primeness comes here or and that's equivalent to ultra filter condition in Boolean algebra.
This means, so in a Boolean algebra, see we have talked of me, we have talked of the order and so on.
But there's another operation very clearly featuring in a Boolean algebra, which is that of.
Negation.
Right.
A complementation.
That's not yet here.
That's where it will come in.
So this will mean that given any exactly one of a compliment will belong to me.
Now, this is a sort of overloaded statement.
One of it will anyway follow from the other one, but so because zero is not there.
So you cannot have both together inside.
So basically, sorry.
Sorry.
Yes, thank you.
Yeah.
So what one is actually saying for the prime condition is that you have at least one of these two getting.
So if you have a not enough, definitely a compliment must get inside.
That's precisely what the definition of primeness will be.
Okay.
And this happens to coincide with the so ultra filter definition if you encounter it anywhere, it is given in terms of the disjunction.
So that if you have alpha joint a joint beta B, then that gets in if and only if either A is inside or B is inside.
That happens to be equivalent to this one.
In case of a Boolean algebra, but anyway, we are going to look at these entities only so such filters.
Fine.
Okay, I'm not going into examples and so on.
I'll just straight away rush into this one.
Now, since we have already looked at the notion of a homomorphism, prime filters and morphisms share a very nice connection.
I think I've given that also as an exercise.
So given any homomorphism you can define a prime filter, which contains exactly those elements which are mapped by the homomorphism to the top element.
Okay.
And the other way around as well.
Anyway, the important feature of prime filters that we are going to use is the prime filter theorem.
So what is that it says that you give me any proper filter, I will always be able to extend it to a prime filter.
All right, so this is kind of sort of zon slimmer uses kind of staring at your face.
So those of you can just try the proof out.
I just use zon slimmer anyways, I'm not going to that either so I'm going to assume this fine.
So now I come to the proof of this one.
So what are we trying to prove, we are trying to prove that
let's introduce this quotation.
The set of so we are given a Boolean algebra be
all
time filters.
All right.
So any Boolean algebra is isomorphic to a subalgebra
of the power set algebra of some set.
So as expected, we don't get the total isomorphism with the whole part set algebra but you can embed it inside some part set algebra.
So you started with a B.
You therefore get XB.
What is the set.
So as I told you a little while ago, there is this nice connection between homomorphism and prime filter.
So in some approaches, you will find that instead of start giving the representation in terms of the set of all prime filters, they take set of all homomorphisms from B to two.
Okay, so that you can also do.
So this one and so you go to the power set Boolean algebra of this one. And what we will be able to, what we would want to do is the following that you define a map phi from B to the power set of XB as taking any element.
Where do I want to take it? So I want to take it to a prime filter, a collection of prime filters.
Right hand side is the power set of XB. XB is the collection of prime filters.
So what we are going to take is so we are going to take to take it to some sub collection of prime filters.
So all prime filters, so there has to be a connection with the small b, right?
This is the obvious connection that we want.
Okay, so again we will make use of that homomorphism thing which I have erased now.
So what we will show is, so if you call this phi of B, what we will want to show is that
the image. Note that if I am able to show that this is a homomorphism, right? Then the image, I mean the image of this one also happens to be a Boolean algebra, right?
So I mean, so what you want to show therefore what I am trying to say is that this, for this phi using that result, we will just show that.
So on-to-ness is already taken care of because I am just going into the image. All I will show is the order of reservation.
That's it. So then by virtue of that result at state characterization result I had stated earlier, you will be able to conclude that this is a homomorphism, right?
So homomorphism which is injected. So the activity is already there. Is it alright? What we have to show?
So again one side is trivial. If I have x less equal to y, note what is phi of A? All prime filters which contain A is less equal to B then obviously that's.
So what you are interested in is the converse, right? So for the converse what do I have?
So again I will assume this. Yes?
So as a special case you will get that. Definitely.
So in this one suppose you have, so again we are back to that result. So x not less equal to y in a Boolean algebra will mean x neat is non-zero.
So there is one more thing that I will be using which is notion that I will be using which is the filter generated by a set.
So what is that? That is just the smallest filter containing A. It can be put in different ways. It's the intersection of all filters containing A and so on.
But this is I have also given this as an exercise in a neat thing about this is that there is a characterization.
So it just consists of all those elements below which for which you will be able to find some finite number of elements from this set concerned which the conjunct of which will belong here.
So and in and the filter generated by a single term we will just you know just abuse the notation drop the brackets. So f of A the other thing will be given this one if A is non-zero then clearly if A is non-zero this one will be proper.
Just use and you get it really. So if it's not proper then zero will lie inside here right. So then you will be able to find some finite number of elements but there is only one element so which will be below that so that should be then zero but that's what you know you're saying it's not right.
Okay, so that's proper. I come back here. You've got a non-zero element. You take the filter generated by this one. That's going to be proper.
Who's the prime filter theorem? You'll get a prime filter containing this fellow. So let's call that f naught. So f naught belonging to XB. So there is this one such that f naught contains this.
And you're done because note that A is a member of this right. A is already here. So X meet Y complement is a member of that one and therefore it's a member of f naught.
f naught is a filter. So X belongs there. Y complement will also belong there but X belongs to f naught. Look at the definition of phi. X belongs to f naught means f naught belongs to phi of A.
Okay, so the next part of the proof is that X meet Y complement belongs to f naught. So that will mean X and Y complement both belong to f naught.
So that will mean f naught is in phi of A but Y complement is here. Invoke the primeness. Y cannot be there. Therefore, so Y is not there. So f naught does not belong to phi of X.
So therefore, you've got the negation of the statement. Is that fine? So that's it. Your proof is done of this one.
Okay, so I come to, yes.
If B is not atomic.
Yes.
The prime filter extension was not there.
Why? It in fact cannot be because prime filter has to be proper, right? So it will not contain zero.
Oh, one will have to think. But why does it depend on atomicity?
It won't depend.
Yes, certainly. It will be a filter.
No, it depends on whether it's proper or not, right?
Oh, if of B is not...
I'm not sure.
So, okay, let me, if f of B is not atomic, but not atomic means that there is not atomic or atomless, which one are you talking about?
Okay.
Okay.
So it won't be proper. That's why, yeah.
Okay, so maybe something is missing out there. Okay, let me think about this.
Okay.
Okay, right now I don't have an answer, but let me...
So your question is that if B is not atomic, yeah, so then what...
No, I mean, I cannot say anything more than what it is just saying. Do you have any answer?
If B is not an atom, and B is not a specific element, then if it is connected to any time filter, there is only to any atom below, the time filter generated by any atom below.
So how B does not belong to any of the time filter?
Small B, it does. It belongs to all the prime filters, which are at principle.
Yeah, that means f of B.
It is in the intersection.
It is the smallest, right, filter. Yeah. Okay, so I'm glad that. Thanks.
Okay, so now I come to the last part of it. I hope that I can, most of the things I will have to skip, but actually, yeah, there's no purpose of going too fast here.
So what have we got? We've got, we began with B, we got this XB, right, and then we had this power set of XB, but then we got phi of B, right, which is a subset here, and we have shown that this is these two are basically isomorphic Boolean algebra, right.
Now we would like to, so what have we got? We've started with propositional logic. We showed that Boolean algebras give a model for propositional logic.
Now we will, so we had the domain of logic we began with, we've came to algebra. Now we will make this nice connection with topology by equipping this Boolean algebra with a topology.
Okay, so notice that this is closed with respect to finite intersection, phi is a homomorphism, right. So if you take phi of A meet B, what are the elements here? These are, right, these are my elements.
So this is, right, which is also a member here, right. So your, this image set is closed with respect to finite intersections. What we could take is what they say is that you just treat this as a sub basis and look at the corresponding topology.
But since it's already closed with respect to finite intersection, you just take it as a basis, all right. So basically you take the null set, whole set and any open set becomes a union of elements here.
So what does an open set look like? So open set is the union of some elements here. So it will essentially look like some phi of t where t is a subset of t, right.
So what have we done? We are equipping XB, the set of all prime filters with a topology, all right. So you may wish to call that tau B or something. So what is this tau B? It has this phi B as its basis, all right.
So the point is that we will try to understand what this topology, what properties this topology has and how can we characterize this phi B in terms of that topology.
So in a series of results, I mean I just maybe state some of them. So what the first thing that one observes is that with respect to that topology, phi B is nothing but the top open sets of tau B or XB.
I am just writing it as XB, okay. So you understand what topon sets are closed as well as open, right. So this is the first result.
So notice that in any, if you take it, start with any topological space, consider its topon sets. The topon sets actually form a Boolean subalgebra of the power set algebra, right.
The topon sets will be closed with respect to intersection, complement, et cetera, right. So topon sets always form that. So if you have XB here and you have taken the topon set, so the right hand side is already also a Boolean algebra, right.
It's a, right. Left hand side is also a Boolean algebra. So what you have in fact shown is that by virtue of this one, so I am assuming this for the moment.
So B becomes isomorphic to actually the collection or the Boolean algebra defined by the collection of topon sets of that topology, okay. So this is one thing that you get out of it.
There is one nice result that one can use that I'm not sure if I've given that as an exercise, but this phi, the homomorphism phi that we define in the second representation theorem, that is very special in this fact that if you take any two subsets of B,
okay, such that union, sorry, intersection of phi of S happens to be included in the union of phi of T,
okay, then there are finite subsets in stash of S and T dash of T such that you have meet of S dash to be less equal to join of T dash.
Notice this is happening to B and this, this is happening in XB, right, so on the right. So this is referred to as the compactness of the embedding.
So you can see why we are using the word compactness because from this arbitrary you're pulling it down to some finite collection, okay.
So this is a nice feature, so phi is said to be a compact embedding. This is a nice feature of that one and the construction, I'll just start you off, you can complete the proof, it's a very nice proof that you just take,
define the set A as S union, the negation of T, what is negation of T? Negation of T is just the collection of the T complement elements, alright, so suppose I consider this set.
So it has this S, the whole of S and the complement elements of that T, right, then you consider f of A.
So f of A, remember it has that feature, right, so it basically consists of all elements below which you will have the conjunct of a finite number of elements from A, right.
So you divide it into two cases, one is that it is not proper, another when it is proper, if it is not proper that means 0 belongs here, right.
So then what will happen? By that characterization, you will have some A1 meet An to be equal to 0, less equal to 0 means equal to 0, right, for some elements in A, elements in A are from S or look like T complement.
So basically here, so now you actually you see here, we are nearly there because we've got the finite thing, right, it came from that f of A.
So some of these elements will be like, you know, S1 meet S2 meet SK type of thing where the SIs come from S, the other elements will be like T1 complement, T2 complement and TL complement kind of thing, right, TIs will come from T, right.
So it will look like some meet of Si, meet of Ti, Pj, let's say complement is equal to 0.
So use de Morgan, so this will mean that it is joint Ti's complement, right.
So this will mean that you have meet Si, meet joint Ti, Pj complement where all of this is finite.
So I equal to let's say 1 to K and J equal to let's say 1 to L, this is equal to 0.
Back to that property of Boolean algebra, A meet B complement is 0 means A less equal to B.
So you see how very often we use this.
So basically you have meet Si less equal to 1 to J, right, joint teacher, right, and that's what you had there.
So the last part of the proof will be show that this guy cannot be proper.
So rule this case out.
So we'll just be left with this one and for that we have it.
All right, so this feature will now can now be used for showing this equality.
So one direction of which is very simple because if you take, so now I'll come to this result.
So proof of 1.
So what do you have here?
So you take any element here, so that's going to look like this, right.
But this is closed under complement.
By definition it's open, right.
So it's already a open set.
Got it, right.
Yeah, phi of P, any element there will then lie on the right hand side.
Fine.
So it's for the other direction that you require all of these things.
So you will take any, let's say u, which is, which is clopen, and there then what do you do?
So let me just, because I have to hurry.
I'm just giving you a second.
Yeah, so.
So if it is, yeah.
So u is clopen, so this is, therefore it is closed as well as open.
So this is going to be the union of some phi of T, but then your complement is also open.
So this is also going to be some union of what?
Phi, let's say s, where s and t are subsets of b, right.
So then this you can then write as u will then be equal to intersection of phi of not s.
So this is a simple security exercise, just work it out.
So because u will be equal to this whole complement and that you can check out will be just intersection of this one.
So what have you got?
You've got a to b, u to be equal to both the union of this as well as the intersection of this.
Use this one.
Okay, so you will get some finite components from each of the sides and so I'm just leaving you with that hint.
You will get this kind of inequality, then apply phi on both sides and you will get something.
We'll just try it out, okay.
I don't have time, so I will not, but I think that with this kind, just this little bit of, you know, hint, you should be able to do it.
All right.
So what we have got is effectively that this is equal to that one.
So these are just, phi b exactly collects all the clop and sets under the topology it is defining.
Fine.
What about x b itself?
Now we look at properties that x b enjoys.
It's going to be compact.
Again, we will be using that compactness of the embedding to prove this one.
You start with any open cover of this one.
And so without loss of generality, you just take the open cover to come from this, you know, this basis part.
Okay, so phi of b.
So, okay, so you assume that this is a subset of phi of b.
Fine.
And then you produce a finite sub cover for it.
Okay, that's the task.
So now since this is here, so you every element here will be union of some phi of t.
Right.
And then again, you will have to invoke this one.
I really don't have time to go into the proof, but the reference that I will give you use.
So the only thing I will just say here is that you use that compactness of the embedding again to, you know, get hold of this one, the finite sub cover.
Okay.
So it's compact.
And there is just so much material here.
So I'll just give you the sketch of the rest of the time.
So XP is also what is called totally disconnected.
I think this must have been mentioned in the topology lecture.
So what we mean here, let's be very precise, is that given any two distinct elements in the set.
You have a clone set which contains one and doesn't contain the other.
Okay.
So that's what we mean by totally disconnected.
And that XP will be totally disconnected will be actually trivial.
Okay.
So basically you take what is XP collection of prime filters.
So take two prime filters, which are distinct from each other.
There will be some element which lies here, which doesn't lie here.
Right.
But then you go to your phi, phi, how was phi defined?
F will belong to phi of B, B is there.
Right.
So that A lies here.
So F one will be in that phi of that one, but it won't be and phi of that is just a clone
set here.
Right.
We've already said that.
So this happens to be totally disconnected.
And we arrive at the notion of the stone space, which is by definition, a compact, totally
disconnected space.
Okay.
So this will imply house, darkness.
This will imply your zero dimensionality.
That is every open set will be union of some open sets and so on.
All those things will come here.
All right.
And so what have we got again?
Let me summarize.
You began with the Boolean algebra.
You gave rise to a stone space.
So that it's called the stone, that space is also called a Boolean space.
So this is called, usually called the dual space of the Boolean algebra.
Okay.
So from B, you came to a.
So naturally, remember our goal is to talk about duality, how you transit from one to
the other and return and so on.
So a natural question, begin with a stone space.
Can we return somewhere, which is in consonance with all this discussion.
So you, if you begin with a stone space, any topological space for that matter, we just
mentioned the collection of clopin sets forms a Boolean subalgebra of the parset algebra.
Right.
So let this be the collection of all the clopin sets of that topological space.
Right.
But remember, it's not just any topological space.
It has those special features.
Right.
So this fellow, then we will be, so this anyway is a Boolean.
This will be a Boolean algebra that we already know what you can show is that this one will
actually be isomorphic to, what am I saying?
Sorry.
So this is already a Boolean algebra.
So for, yeah, so for this Boolean algebra, you will have its dual space.
Right.
So that's where I'm going.
This is a Boolean algebra for any topological space.
Go to the collection of prime filters for it.
That is the dual space that we already know must be a stone space.
This you began with as a stone space.
So question, what's the connection?
So the connection is if I use the same notation, but this is now for homomorphic.
So what's the map?
Take any Y.
So call it psi.
So this map I'm calling psi.
So what does it do?
So where is it supposed to go?
So it's going, it's supposed to go to a prime filter to some prime filter of this Boolean
algebra.
Right.
So what is the Boolean algebra?
The collection of clopin sets.
So therefore on the right, you want some clopin sets to come in.
Right.
So again, what we need to now show, because this is compact and so on, it suffices to
just show, you want it to actually show it's a homomorphism.
It suffices to show that it's continuous and that it's bijective.
All right.
So injectivity is very easy.
What you show is continuity is also in fact very easy.
So there is one nice thing that you will be able to make use of.
So you will invoke phi again.
So of this will turn out to be a itself.
So for example, when you're proving continuity, you will take any open set from the, from
here and show that it's inverse image under psi also is open.
Right.
So you take any member from the basis and that one.
So that means you're basically taking sign worse of some phi a type of thing that is a
subset of that.
So this you can show very easily that this is because of the definitions of phi and psi.
This is what's going to happen.
But then is already an open set.
Right.
So that makes the job easy for subjectivity.
Again, you need to do a little bit of work.
So I don't have time for that.
But again, the reference I will give will have that one.
So you have this.
Okay.
So what I will now summarize is the final picture of it.
So we began with the Boolean algebra.
We went to its dual space, which happened to be a stone space.
You showed that the Boolean algebra is isomorphic to the clock and sets of that stone space.
Conversely, if you begin with a stone space, you look at the Boolean algebra form.
By its globin sets, you go to its dual space.
What you are able to show is that the original stone space happens to be homeomorphic with
the dual space.
Right.
So this is already pointing to some, you know, category theoretic duality at the object level.
So it's easy to notice that you already have two, you know, categories sitting here.
One is the category of which has objects as Boolean algebras morphisms as your homomorphisms.
On the other side, you have a cat.
So that's going to be a subcategory, for example, of the category of all ordered sets and
or morphisms right on the other hand, you have, let's say the category of topological
spaces and continuous maps.
Here you've got this subcategory formed by objects as stone spaces and morphisms as
continuous maps.
All right.
So what is the relation between these two categories?
So if I call the category of Boolean algebras, if I denote it as B, the category of stone
spaces, if I denote as S, all right.
Then, clearly, we have these two functors that are coming out of our discussion that
we took place so far that one from here to here and another in the reverse direction.
What are these guys doing?
So at the object level, we will be taken to XB, right, the dual space.
Here, which Boolean algebra?
A clopin sense, right.
So this is already there and what you have got, in fact, is an isomorphism for this B,
for every B belonging to B, that is object B, I should say, right.
So we have this isomorphism, right, which goes from, where does it go from?
B to, right, what is F of B?
XB.
What is G of XB?
That is just the clopin of XB, right, this is XB and G of XB is clopin of XB, but we
have already noted that B is isomorphic to that one, right.
So similarly, we are deliberately using this one because so if you begin with a stone space,
you have a psi Y, which goes from Y to FG of Y, right.
G of Y goes to the clopin sets of Y and F of that will take it to X of that one and
we have observed the homomorphism, right.
So you get a isomorphism out here of Boolean algebra, you get a homomorphism here of the
stone spaces, right.
So this is already there and now, yeah, what you can show is that both of these very easily
that F and G both are contravariant functors.
So I think all of this has already been done, right, I mean contravariant functors and all
that.
So these two happen to be contravariant functors, right, and what else do I want to say here.
So object level, you have already these two isomorphisms sitting here.
So then the thing will be complete, the discussion will be complete if we can address this at the
morphism level as well, right.
So that means we want morphisms to be mapped to appropriate morphisms on the other side.
So let's take in B, let's take a homomorphism between these two Boolean algebras, ok.
This will give us, we want to define something like this contravariant dual space of B to
dual space of A, you will get, so what will this be?
This will be a continuous map, how is it defined?
Defined as F of H of a prime filter, ok, so let's call it A or F or whatever you want
it, right.
So that will be, so now what is F?
F is a subset of A, right, sorry, it's a subset of B, I am taking it from X of B.
Now I can apply H inverse to that set, this is my definition, H inverse has applied to
a set, please be careful, all right, it's not this one element, fine.
So you can show that this is going to be a continuous map, this you can take as an exercise
on, sorry, which one?
Yeah, yeah, yeah, so that you will be, that's part of the exercise, that's very easy, it
should not be a problem, ok.
So you have to show it's well defined, then you have to show it's continuous, right, so
that will happen.
And on the other side, you talk of the stone space and you take, let's say X to Y, so
you have two stone spaces, you are taking a continuous map, fine.
And so you will define G of F, so you want to define this from clopin Y to clopin X,
right, and this should be a homomorphism, well defined an homomorphism, so how do we
define it?
So it's very similarly, so G of F, so you take any A, which is a clopin set in Y, so
again this is a subset of Y, right, so you can apply the F inverse, so again exercise
to show that it's well defined and that it's going to be a homomorphism, it's a really
routine verification.
So, in fact, what we have, so I think I already mentioned that you can show that F and G both
preserve the identity and the composition in a contravariant manner, so they're going
to be contravariant with this one, so I will end with these two diagrams that will, in
fact tell us, so they have learned natural transformations as well, so what you have in
fact that already shown is that these two categories are what's called anti-equivalent
alright, and you have this diagram, so on both sides, so what do you have?
Let's be on the Boolean algebra side, so here, right, this is nothing but the Boolean algebra
A, clopin of that xA, right, so here you have the pi A sitting in, right, and you also
have its inverse, so quality, sorry, so then here similarly you have pi B and you have
the inverse, and here you have GFH, this diagram commutes.
Similarly, if you begin with the map here, right, so you have the psi x and the psi y
and the inverses, and here we will have FG of F, right, all these morphisms are all now
clearly defined, we just did that, isn't it, so this also commutes, so in fact what you
have given rise to are this collection, right, so B Boolean algebras and this one stone spaces,
you have given rise to a couple of natural transformations, right, because you have this
commuting of the respective diagrams, I think I have finished bang on that, okay, so yeah,
so I don't think I have anything more to say, because it was really too hurried, I may not
have been able to answer some questions, but yeah, but I am, yeah, I really enjoyed this
one, because this one, I have to confess I have never really taught this in such, in
this, you know, these details, so I really enjoyed preparing for this one, you know,
of course I couldn't finally communicate everything, but I hope that something went across, so this
thing between Boolean algebras, stone spaces, and in fact not just the object level, you
also have the morphisms nicely, you know, going to and fro, and so it gives you, so I
think I will end with this remark that, okay, the one that, there have been a lot of references,
so Devi and Priestly for one, then there was this nice master's thesis by Decker's done
with my Gehrke, so that, in fact I will recommend to all students here, you should see how nicely
that master's thesis is written, and that in fact I will give as a reference for the, you
know, so this, this is done in 2008, if I remember it correctly, Decker's, so you, so
another thing that I want to point out is other directions, so I see Nupur here, right,
so you have others who have done theory of computation courses, you will note that, you
have regular languages, so you take any alphabet, okay, sigma let's say, and then you take this
collection of all strings, so you take sigma star over that alphabet, and of course the
power set of sigma star will form a Boolean algebra, the regular languages form a Boolean
subalgebra, remember the closure, I am saying remember to go wrongly, but the regular languages
are very, very nicely behaved in that they are closed with respect to all the opposite
theoretic operations, but it's not just in a Boolean subalgebra, it has these extra
operations also of, you know, concatenation, so those were extra operations that one
defines on formal languages, concatenation, then quotienting and so on, so the other nice
thing about this duality, that's where I wanted to end, is that this thing going from
algebra to the topological space, not just ends here, you can actually extract from there
and look at for example subalgebras, you get connected to using this, exploiting this duality,
you can take subalgebras here, they get related to some, you know, quotients of this dual
space, on the other hand, if you take Boolean algebras, equip it with additional operations
like I was just saying, that gets connected to some relational structure, you can add,
define a relation on that dual space, so then there is also to and fro, you see the duality
at this level that we explained here can be extended to such other situations as well,
this is what one is trying to say, so for example that cases and there is other work by
Maya as well, where they talk of this connection between automata and formal languages and they
expect this duality thing there as well, so that I found interesting and yeah, so I think
I'll end there. Let's thank the speaker.
We are actually like five minutes late but still if you have any quick question you can
ask.
Even the online participants.
Yes.
Like we often are able to convert games into the trees.
I have no idea, no I don't know, but that may be a good thing to look at.
No but see duality in general means that you're going from one domain to another, but it's not
just going to and fro, you need to preserve some things like you saw that neat thing should
be there, so you can check if that happens there, I don't know.
Hello.
Am I audible?
Hello.
Yes, yes you're audible.
Yeah, so I don't really understand what is topology on XB.
Oh, so you understood what the image of understanding.
Yeah, that is the closed and open sets, open sets.
So to understand the open sets you need to understand the topology first.
So phi of B, so as I said the open sets will just look, so you had B, you define phi of
B, so this was just the collection of these guys.
What were these?
These were just the collection of all those prime filters which contain B, right?
So these are your entities corresponding to every element of the Boolean algebra, right?
And so this entire set is inhabiting here for every Boolean element, you are just taking
this collection of elements, right?
So what you are saying that the topology if we denote it as tau B is just generated by
this phi B, so what does generated by mean taking this as a basis?
So what does taking it as a basis mean that you take, so any open set, so how do you define
a topology to an essential feature will be to define any open set.
Yeah, yeah, I get it.
You got it?
Yes, I think I had said, so this is a nice thing to observe.
So this will just be the union of some phi Bs, right?
So of course it may not be finite, but yeah, so that's how any open set.
So that's why when you're doing all the proofs that some, most I think I left, what you do
is you focus on the phi B type of elements and do your proof because they're finally
loaded.
Yeah, okay, thank you.
We can as well replace the constraint that B is enough to buy B not enough.
Because that will also.
You've been the compliment, right?
So each of them is open.
Yeah, so you can write it in.
So another basis will be all those prime filters in XB, which
Yeah, that will be just equivalent, right?
So you have B in F if and only if we compliment B is compliment is not enough and so on.
So you can always replace.
Done.
Okay, thank you.
Hello, we'll meet again in an hour like at 2.30.
