Okay, so there's a lot of different results in mathematics. There's results which have
important philosophical implications, and there's results which are mostly just used
for doing calculations. I remember hearing someone say a long time ago that most mathematicians
don't have time to care about philosophy very much, because there's just so many calculations
to be done, and so many times when the important thing, the task in hand, is just how are you
going to calculate a particular thing, and the time to step back and wonder what it really
means in the grand scheme of things is sometimes lacking. Now, the yonidilema is one of the most
useful results in category theory for calculations, but it also has very broad
philosophical implications. It's the kind of result which, for me at least, I found it really
changed my perception on what spaces are, what shapes are, basically what things are,
because it really goes into the sort of core matter of category theory, which is
one of the core matters, which is how can we refer to particular things. You see, there's
at least two ways you can describe a mathematical object. You can describe it kind of internally,
so let's say you have a graph, for example, a load of dots and arrows. You can describe it as just
that. You can say, well, we have a set of dots, and we have a set of arrows, and they touch each
other in certain ways, and that describes the graph. That's a kind of internal description of it.
That's a description of the graph kind of from inside, but one of the main kind of ideas in
category theory is that we also want to have these kind of external pictures of things,
so we want to be able to describe mathematical objects, not just kind of internally, but sort
of externally. We want to be able to describe them with respect to their relations to other things,
and if you think about the real world, this is also true to some extent in the real world.
For example, if you wanted to describe a particular person, you could describe them from a kind of
internal perspective. What's the layout of their physiology? How is their brain wired up and so
forth? Or you could describe them from a kind of external point of view. Where do they live?
Who are they friends with, etc. We have these kind of two different ways that we
think about things, and the yonidilema connects them together. One of the main ideas in category
theory then is that you can describe an object in a category by referring to the sort of arrows
around that object and whatever object it's related to in different ways, and we've seen this
happen in the category of sets, and I've kind of hinted in these videos that it's possible to do
that in more general categories. But with the yonidilema, we're really going to see exactly
how this works, and it's just such an amazing result. It's such a short kind of result, but
there's so much there. To me, it really gave me a big sense of wonder to see how all these
mathematical objects have this kind of dual nature, to have the kind of internal definition
and the external definition. It even makes one think about things like particle physics and the
structure of the universe and the kind of fractal nature of a lot of reality. It's really a very
interesting result. Now to begin with, let's just remember about this category set. This has sets
objects and the arrows are functions. One of the things I did in my first video in this series
was say something about how we can talk about sets and we can sort of pick out the particular
details of things from this kind of categorical view where we don't look inside these objects and
say, oh well, this object represents a set with three elements, for example. No, what we do is we
just think of these as objects and we think of the functions as arrows and simply by looking at that
conglomeration of dots slash objects and arrows between them, we're able to actually identify
what things are. So how did this work? Well, one of the key things for us in the category of sets
was to identify this singleton set, a set with just one element. And if you recall, that's a
terminal object in the category of sets. It has the property that for any set, there's just one
arrow into this singleton set, this terminal object. And that arrow corresponds to a kind of
function which collapses all the elements in our set down to our singleton set. So we see that
this set here has a property that for any other set like this one, there's just one arrow, one
function into it. So okay, we can determine the set that has one element just by looking at the
arrows and the objects. But we can do much more than that because once we have this
singleton set, once we know which object represents it, we can then find out about other sets.
So for example, we can ask how many arrows are there from this object here to this object here
in the category of sets. And we find that there are two. There's one arrow which kind of
injects this singleton element into this first element of our set. And then there'll be another
arrow which sends it to the other one. So we can essentially refer to the elements in a general
set as arrows from the terminal object into them. Okay, so that's nice. That means this
category of sets does indeed have this sort of property that I was talking about that we can
refer to the objects. And if you think about it, we can also describe things like
what the actual functions are and so forth, just by looking at the relations, by taking this kind
of external or relational kind of view of what the objects and arrows are. Okay, so that's nice.
But what about other categories? So another very nice category is this category of graphs.
Okay, so this category of graphs, it has these directed graphs as objects.
And then the arrows are so-called graph homomorphisms. So an arrow in this category of
graphs is a pair of functions. One function that sends the vertex set of our source graph
to the vertex set of our target graph. And another one indicated by these dotted arrows,
which sends the edge set of our source graph to the edge set of our target graph. So for example,
this homomorphism here sends these two vertices to these two, and it sends this directed edge to
this directed edge. And the only property we require these graph homomorphisms to have
is that the source and target of the image of an edge
are the images of the source and target of that edge. So basically, the graph homomorphism works
in a way that it kind of, so basically the graph homomorphism has to work in a way that it kind
of preserves the incidence of the kind of structurally preserving transformation that
you'd probably naturally think of. Okay, so those are our arrows in this category of graphs.
I'll go into this in more kind of technical detail later. But what I want to indicate here is that
in this category of graphs, we actually have a similar kind of results to what we see in the
category of sets, this kind of idea that if we have a graph, let's say this one here, yes,
of course, it has an internal description, we can describe it as these vertices and these edges
with some incidence relations. But more than that, we can also refer to this graph in an
external kind of way. So just like in the category of sets, we can sort of talk about these elements
of our sets as if they're basically just arrows from this terminal object. So we can think of
its terminal object as a kind of template, which is like injecting its information into the particular
elements and sort of referring to them. And in the category of graphs, well, we have this
graph here, which just has a single vertex. And we can basically think of the vertices of a general
graph as corresponding to arrows from this singleton graph here, this single vertex. And so
we could refer to this vertex here as an arrow from this to this, we could refer to this vertex
here as an arrow from this to this, and so forth. And so there's a way to describe the vertex set
of a particular graph, just in terms of arrows from this graph, which just has one vertex.
So okay, that's great. But there's obviously, okay, so that's great, but it begs a couple of
questions. The first one is, how do we actually identify this graph here, which just has one
vertex and no edges? How can we kind of refer to that in a categorical way? And secondly,
probably more importantly, it begs the question of, how do we describe the edges of a particular
graph? Well, the way that we can describe the edges is kind of similar. We can have this other kind
of fundamental type of graph, which just has two vertices and a single arrow, kind of single edge
and again, we can think about graph homomorphisms or arrows from this kind of graph into our
graph of interest. And we can use those to actually refer to the particular
directed edges in our graph. Okay, so this is really quite remarkable. I mean, we could identify
this graph here as something which has, so we can sort of say that this graph here has the
property that there are three arrows into it from this single vertex graph here, one picking out
each of its vertices. And there are two arrows into it from this graph here. Now, is that enough
information to actually tell us which graph here we're talking about? Well, if you think about it
for a bit, you probably discovered that the answer is no. Okay, because that information, just saying
how many arrows there are into this from these different things. Yes, it tells us that we're
talking about a graph which has three vertices and two directed edges. But there are other graphs
which have three vertices and two directed edges. For example, there's this one here,
which is different. Okay, so we need more information. In particular, we need a way to
really talk about not just what the constituent elements are within this kind of graph, not
just what it's made out of, but how the things it's made out of are joined together. And this is
one really beautiful aspect of a yo-nida lemma is that it explains how we can talk about such
things from an external kind of point of view. So internally, the way that we talk about this
is we'd say, okay, we have two edges and this edge here has this vertex as its target and this
one is its source and this one has this as its target and this is its source. That's enough
information to describe this internally. But how would we describe it externally? And the kind
of magical idea is that we have these fundamental kind of types of graphs, the sort of elementary
particles in the universe of graphs, if you like. And we can think about the interactions between
them, the arrows between them and somehow they actually represent and somehow the way that the
kind of interactions between them are related to the kind of injections into our structure of
interest reflects the way that the internal kind of elements of our structure are interconnected.
So in particular, how could we then, how could we say from a sort of external point of view,
how could we communicate that this vertex here is the source of this edge here?
Well, a way that we can do it is we can say, okay, there's an arrow from this directed edge here
to this edge here of our graph. And there's an arrow from this single vertex graph to this
vertex of interest. But there's also an arrow kind of externally, which sends this vertex here to
the source of this directed edge here. And it has the property that if we go along this arrow,
and then we go along this arrow, we get the same thing as if we go along this arrow. Composing
this with this gives our yellow arrow. And if you think about it, that information is a kind of
external way of saying that this is the source vertex of this edge. Now, this is just one example,
okay? And I'm talking about graphs in this example. But the Yonida lemma very, very neatly
describes how to do this in general. It's actually once you get your head around the terminology,
it's much easier to get your head around. So once you get your head around the terminology,
it's much easier to sort of understand what I'm talking about here with this kind of
internal versus external ways of describing things, just using the Yonida lemma. It's a very,
very useful calculation. It's a very, very kind of computational tool, and it's very succinct.
Now, my main goal in this video is to explain what the Yonida lemma is, what it says, and so forth.
And hopefully by the end of it, you'll have this kind of appreciation of these kind of
different ways of referring to things. And believe me, it's much more general than just talking
about graphs. There's so many different types of categories which the Yonida lemma can be applied
to. And in so many of these cases, we see how it really gives us this kind of dual way of describing
things. And to be honest, I think it's extremely beautiful. And I think we're very lucky actually
in this day and age that category theory is just taking off. Because to be honest, a lot of this
sort of territory is unexplored. People are starting to realize things like the profound
implications of things like the Yonida lemma, and what it really means for the kind of,
well, I might say what it means for the kind of philosophy of form, really,
and what things really are, and how we should think about what shapes are, and so forth.
But more than that, I also, but I mean, I think it's brilliant that we live in this kind of age
when these ideas are around things like the Yonida lemma, which, you know, gives so much
insight into the sort of true nature of things. But on the other hand, these are all very new
kind of ideas. And there's not many people who know enough category theory to actually,
you know, be able to run with these things. Now, of course, that's a bad thing. But the other side
to it is that it's on us to sort of take these results and try and understand them. And I think
there's so much new kind of ground to be covered and new kind of places that we can take these
ideas and apply them and use them to gain new insights. So for the pioneering type,
most of you, this is a very fruitful kind of opportunity. A case of a Yonida lemma is expressed
in terms of functors and natural transformations. Basically, what I'm saying is that to understand
what the Yonida lemma says, we're going to have to take a kind of high level view of what these
kind of structures are. So for example, we're going to have to really think about what a graph is
in terms of category theory. Now, in my previous video, category theory for beginners graphs and
dynamical systems, I go through this kind of way of thinking about these structures in detail. So
it might help you to watch that video first. So it might help you to watch that video first,
although I'll try and go over the basic ideas quickly. Okay, so here's a graph. It has these
vertices and these edges. So we need to think about how we can describe this thing properly. For
example, how would we put this in a computer program? And one way to do it is to say that we have a
set of edges, in this case, A and B. So there's our set of edges. And we have a set of vertices,
1, 2, and 3. There they are. And then there are two functions, which sort of describe how this
structure is connected together. There's a source function, which sends every edge to its source
vertex. So for example, this edge here A starts from vertex one, so its source is one. So this
function g of s, this thing that gives us our source vertex, sends A to one. And similarly,
it sends B to two because edge B here starts at vertex two. Now, the other function we need
is the target function. This is going to send an edge to its target. So it sends edge A to three
because this edge A points at three. So this is our way of talking about what a graph is
in kind of concrete terms. It's a set of edges and a set of vertices and a function, which will
call g of s, which sends every edge to a vertex, which is thought of as its source. And then there's
this other function, which associates an edge with its target vertex. So if you think about it,
any kind of graph can be described in these terms. And it's a nice sort of language because
it allows us to do things, for example, like have many arrows from one vertex to another.
But there's another kind of layer to this because we can actually think about this kind of representation
as a functor. So in that previous video, I described how we can think of this category
of graphs as we can basically write it like this. So what this means is that the graphs,
the objects in this category are functors from this category here with two objects and
two parallel arrows to this category of sets. So let me explain how that works again. So
let's draw out this category here a bit more clearly. We can draw it like this. It has an object
called e. And it has an object called v. And it has these two arrows, which we call s and t.
There's also identity arrows, but I won't bother drawing those. So this itself is a category.
And what I'm saying a graph is, is it's going to be a functor from this category to the category
of sets. So all of this gubbins, we think of all of this as just a few things which are going on
in this category of sets. Okay, we have these sets and these functions. And so
how can we think of this as a functor from this category here to the category set? Well,
we can imagine there's a functor which associates this object e here with this set.
And it associates this object v here with this set. And it associates this arrow here
with this function g of s. And it associates this arrow here t with this function g of t.
Okay, and this has to be a functor. Okay, so that's all I'm going to say about this.
If you're still confused at this point, I encourage you to watch my video on graphs and
dynamical systems because I build up this intuition more gradually. But basically,
we can think of a graph as a functor, which associates the kind of edge objects with an edge
set, the vertex objects with a vertex set. And this arrow here s gets mapped into a kind of function
which picks out the source vertex of a particular edge. And similarly for this
t arrow here becomes this target function. Okay, so we'll have many different graphs.
And each of these different graphs corresponds to a functor from this category here.
To the category set somehow, somehow associating this e with a set, this v with a set, and these
arrows here with these kind of functions which tell us which edges are connected with which
vertices. Okay, so that's the basic way we can describe what a graph is. A graph is a functor
from this category here to the category set. Okay, so we have many different...
Okay, so we have all these different graphs. We kind of know now what the objects are in this
category. But obviously, this being a category, it doesn't just have objects. It doesn't just have
these functors which pick out particular graphs. It also has to have arrows. Okay, we have to somehow
have arrows between our different graphs in this category. So how are the arrows defined?
Well, the arrows in this are just natural transformations between these different
functors. So let me illustrate that next. Okay, so now we know how to talk about graphs. For
example, I've said how we can describe this graph here as this functor G from this
category of two parallel arrows to our category set. Now, of course, the category of graphs has
many graphs. So here's another one. I'm calling this graph A, and it corresponds to this functor
from our parallel arrow category here to the category set in this way. Okay, so this functor
here sends this object E to this set here, which is a single element here representing
this single arrow. And it sends V here to this vertex set of two elements, one bar and two bar.
And when the, and then the S and the T arrows are sent to these functions A of S and A of T,
which are telling us which vertex this edge starts at and which vertex it ends at. Okay.
But in the category of graphs, of course, we also have arrows between graphs, graph homomorphisms.
So here's an example of graph homomorphism. It goes from our graph G to our graph A.
I'm calling it A for arrow. Okay. And the way that this particular graph homomorphism works is it
sort of takes this graph and folds, folds the two arrows on top of each other and sends them there.
Okay. So it is a graph homomorphism. It preserves the source and target of edges. Okay.
But how can we talk about these graph homomorphisms like alpha here? How can we talk about these
arrows in our category of graphs in terms of functors? Okay. Well, the idea is that an arrow
between graphs is precisely a natural transformation between functors. Okay. So here we have a
functor G representing this graph here. We have a functor A representing this graph here.
And a natural transformation from G to A is precisely this kind of graph homomorphism here,
this kind of arrow in the category of graphs. Okay. So how do we set up this particular homomorphism?
Well, what's it going to be? It's going to be a natural transformation from G to A.
So how do natural transformations work? Well, a natural transformation has a component
for each object in our kind of source category here that we're making functors from. And so
there's going to be two components to this natural transformation. We can call them alpha E and alpha
V. Now alpha E is going to be an arrow in the target category, which goes from where E got
sent under the first functor to where E got sent under the second functor. In other words, alpha
E is just going to be a function from the edge set of our first graph to the edge set of our second
graph. And it's basically what I've drawn with these dotted arrows here. So we can think of this
as a sort of graphical representation of the ETH components of this natural transformation alpha.
Or we can just draw it more concretely like this.
So that's going to be alpha E. It goes from where E got sent to under G to where E got sent to
under A. And because it's landing in the category set, it's actually a function, okay? Arrows in
set are functions. Next thing is we need a similar kind of component for V, okay? So this is what
I've drawn with these solid arrows here. So these solid arrows are representing alpha of V. This is
the kind of VEF component of our natural transformation. It makes sense in the context of graphs. If
you're going to transform graphs, you have to say, where are you sending your edges to? That's
alpha E. And where are you sending your vertices to? That's alpha V. In our kind of functor picture
here, this is just going to be an arrow which goes from where V got sent to under G to where V got
sent to under A. So in this case, with this picture, it sends one three to one bar.
And it sends two to two bar. So that's going to be alpha V.
Maybe I'll make these arrows dotted here to correspond with the picture below. Okay? So this
is our picture then of what a arrow is between graphs. It's a natural transformation from this
functor G to this functor A. Now, such a natural transformation has to have these components
but it has to also satisfy an extra condition called the naturality condition. We have to
have these kind of commuting squares for every arrow of our source category. Okay? So
we have two arrows in our source category, S and T. And these get sent to different functions
over here in the category of sets. And so there's these kind of squares that we can
walk around in this picture. And we require that paths around these squares give similar
results. More specifically, for this edge S, we can see that S gets sent to A of S under this
functor A and G of S under this functor G. And so we require that there be a kind of
naturality square associated with this arrow S. So what that means is that if we do this natural
so what that means is that if we go along this arrow alpha E, the EVE component of our natural
transformation, and then we compose that with this arrow A of S, we have to get the same results
as if we go along this square the other way around. So if we go along G of S and then
alpha of V, so let's write that condition down. So we require that
A of S after alpha E
equals alpha V after G of S.
So what this condition is saying is that if we look at where this S arrow got sent to
under these different functors, it has to make kind of commuting square with these components
of the natural transformation. And it boils down to this condition here that A of S after alpha E
equals alpha V after G of S. And in order to have a natural transformation, all we require is that
there's a kind of commuting condition like this for every arrow of our source category. So we have
one over arrow, which is T, and so we're going to have a similar condition for the T's. So that's
just going to say that A of T after alpha E is alpha V
after G of T. What do these two conditions mean? Well, what they're really saying is
basically what a graph homomorphism is, something that preserves the kind of source
and targets vertices of the edges that it maps. In particular, what's this equation mean? Well,
what it's basically saying is that the source of the image of the edge is going to equal the image
of the source of the edge. And similarly, this is just saying that the target of the image
of an edge is going to equal the image of the target of the edge. So these are really natural
conditions for a kind of transformation of graphs, probably part of why we have the name
natural transformation for such things. So that's the whole story then. We know that the
graphs are functors from this category here to set, and we know that the arrows are natural
transformations. And if this seems particularly alien to you, I recommend you watch my video
on graphs and dynamical systems, where I explain this more gradually. So it's really
rewarding to get one's head around these levels of abstraction, because it allows us an amazing
amount of compression with regard to the kind of structural things which we're representing.
In particular, we can just write a very, very succinct little expression here to describe what's
going on in our pictures to basically say that we have this category here with two dots and two
parallel arrows. This is just a kind of small picture of this category here that's our sort of
template category that we're making graphs out of by doing functors from it. And we're saying we
have these two graphs, G and A, which correspond to functors from this category here to the
category set. And then we have this natural transformation alpha from this functor G to
this functor A. So now we can start to see why this here is notation, which means the category of
graphs. This basic notation means this is the category of functors from this category here
to the category set. In fact, if you want to connect even more neurons together,
you might notice that this is an exponential object in the category of categories. However,
we're not going to need that kind of information today. The important thing is to understand
that the graphs correspond to functors and the arrows between the graphs correspond to natural
transformations. And of course, also, you should notice that we could have many other different
kinds of categories instead of this one, which we could consider functors from. So these are kind of
set valued functor categories. And there's an amazing amount of different mathematical structures,
which you can describe. Another example being the category of dynamical systems, which we'll
get on to later. And basically, these kind of functor categories are extremely natural ways of
representing families of mathematical objects. And these kind of functor categories have
some extremely nice properties. In particular, for us today, the yo-needle emma applies to them,
which gives us this wonderful insight. Another thing which is true of these kind of categories
is that each of them is something called a topos. And we'll get on to topos theory later. But
basically, it means that there are sort of special parts of these kind of categories,
which represent logic in the way that space is interrelated. And it's just absolutely magical
stuff. But today, we're going to be talking about how the yo-needle emma applies to these kind of
functor categories. Okay, so we've recapped this language of functors and natural transformations.
And we've seen that these kind of functors that go into the category set can often be interpreted
as kind of structured sets, as in the graphs we've just talked about. Now, in addition to
natural transformations and functors, there's one more thing that we need to know about,
another piece of terminology, before we can discuss the yo-needle emma. And this is the
idea of hom sets. So it's really quite a simple idea, maybe a little bit strange at first glance.
But here it goes. The basic idea is, suppose we have some category, and we have some objects. So
let's say we have an object n and an object x. Now, there may be some arrows in this category
going from n to x. In particular, there will be a set of arrows going from n to x.
There may be an empty set, but there will be a set. And so this set of arrows from n to x,
this is what's known as the hom set. Okay, so it's written hom n comma x. And this is simply the set
of arrows, which goes from object n to object x. Now, I must admit, I do find this terminology
a little bit annoying. Why is it called a hom set? Well, I think it's a kind of abbreviation
for the set of homomorphisms from n to x. Remember that some category theorists like to call arrows
morphisms and sometimes call arrows homomorphisms. Okay, so this is kind of an abbreviation for the
set of homomorphisms from n to x. Maybe a better kind of terminology for it would be to call it
the arrow set from n to x. Some people would call this c n comma x. So it's a set of arrows in c,
which go from object n to object x, where c is this category that we're working in. Okay,
maybe this notation is a little bit better. But I'm sticking with this hom notation, because
that's kind of standard. And there we go. Another way we might refer to this kind of
collection of arrows in certain categories is we might call it x to the power of n. Okay,
so this will be an exponential object. Don't worry too much about that if this seems peculiar to you,
because we're not going to use that terminology. But it just happens that in some categories,
we have these exponential objects, which are sort of objects which somehow represent collections
of arrows between other objects. But we won't worry about that today. So simply, hom n comma x,
for hom sets, n comma x is the set of arrows from n to x. So what? Well, we use this to define
something called a hom functor. Okay. So this hom functor is denoted hom n comma blank. Okay. So
there'll be one of these hom functors for every object n in our category C. And as you can see,
this is a functor which goes from our category C to the category set. So what does it mean?
Well, basically, this is a functor which somehow sends objects in the category C
to the category set. And this n here is really part of the sort of name or definition of the
functor. So how does it work? Well, it's pretty simple really. Here's an object x in our category C.
And the way this functor works is when we operate this functor on this object x,
it gets sent to a set, of course, because this is a functor sending objects to sets.
Because this is a functor sending objects of category C to sets. So which set does
this functor send this object x to? Well, it sends it to the set of arrows from n to x.
Okay. So simply this hom functor here, hom n comma blank, when we operate it on an object x,
we get the hom set n comma x, the set of arrows from n to x. So in this case,
there's two arrows from n to x, which we call it a and b. And so this hom functor is going to send
x to this set a and b. Okay. So this is kind of half of the story, because this is a functor.
So we need to say how it works on objects, what we just did. The other thing we have to say is how
it works on arrows. And this is a bit more detail, but it's quite intuitive. Okay. If you think about
it. So suppose we have some general arrow in our category C, let's say we have an arrow
f from an object x to an object y, I've drawn it here. Well, when we lift this arrow under our
hom functor, it gets sent to an arrow, which we write like this, hom n comma f. And this ought to
be an arrow, which goes from hom n comma x to hom n comma y. Okay. So remember, hom n comma x and
hom n comma y are just sets. Okay. So here's the set hom n comma x. It's the set of a and b,
these arrows out of n into x. And here's hom n comma y. It's these three arrows, c, d and e,
which go from n to y. So how can we make a function which sends arrows coming into x from n
to arrows coming into y from n using this arrow f? Well, if you think about it, there's a very
natural way to do this. And that is that if we take an arrow, let's say an arrow a here,
which goes from n to x, that's going to be a member of hom n comma x. And then if we just
compose this arrow f after a, then that'll give us an arrow, which goes from n to y.
In this case, as I've written here, we're supposed that c is actually equal to f after a.
And so what this means is that when we
operate this hom n comma f function on this arrow little a here, we get this arrow little c.
Okay. So what I'm saying basically is the way that this function is defined,
which sends arrows from n to x to arrows from n to y is when we operate this function here,
hom n comma f on an arrow little x from n to capital X. What we do is we just compose f after
little x and that'll give us an arrow, which will go from n to y. So you can see I've written how
hom n comma f works in this case. Okay. So this is basically how this hom function all works.
Okay. It, it maps objects to the set of it maps and it sends an object to a set of arrows
from n into that object. And it sends an arrow into this kind of function, which translates one
hom set to another by composing with the kind of arrow, which we're lifting under this hom functor.
Okay. So if this is the first time you've seen this, if I suggest you kind of pause the video,
draw out a category or two, and kind of play around with this and try and get a feeling for
how this hom functor works. Perhaps you'd also like to convince yourself that this is actually a
functor when we're working with a general category C. Okay. And of course, there's going to be one
of these hom functors for every object M. I should also say just for completion, that there's actually
another kind of hom functor as well. We're not going to talk about that yet. But there's another
kind of hom functor, which works kind of the other way round, which we denote as hom dash,
and then some object X. And that's a kind of different type of hom functor. It has a similar
definition. But we'll talk about that properly later. For the moment, it's definitely going to
suffice just to use this kind of more straightforward hom functor here, hom n comma blank.
And this is the kind of final thing we need to know. And now we can talk about the yo needle
ever. And it's fascinating results. Okay, then. So here comes the yo needle ever. Here it is.
So what does it say? Well, it says that if we have any category C,
and suppose we have a functor G from the category C to set. Okay, so a good example of this would be
when C is this category here, in which case a cat in which case a functor from C to set
could be thought of as a graph. Okay, we've discussed this. But the yo needle m is more general.
Okay, it just says if we have any functor G from a category C to set, then this statement holds
true. What's this statement say? Well, firstly, Nat. What does Nat mean? Well, simply, Nat
of F comma G for functors F and G. This just represents the set of natural transformations
from functor F to functor G. This is when, of course, F and G are going to be two functors
in our case going from this category C to set. Okay, and this is just the set of different
natural transformations between them. That's what Nat F comma G means. Okay, so the yo needle ever
says that the set of natural transformations from this functor to this functor is isomorphic
to this functor G operating on this object E. Okay, so this is a very, very general statement.
It holds for any category C and any object E of this category C and any functor G from C to set.
And this is what the yo needle ever says. Now, if this is the first time you've seen this,
you're probably quite confused by this, right? Because there's a lot of different machinery
of category theory all mixed together in this kind of equation here. Okay, we've got isomorphisms,
we have a set of natural transformations, we have this hum functor, some of the functor,
lots of things going on. But once we unpack this, you will hopefully see that this is such a kind of
sensible results. And it's the kind of thing that you really can get a lot of intuition from.
So the best way to understand what this means is to look at an example. Okay, and then we're going
to go back and look at this yo needle Emma in more detail. There's actually a little bit more to the
yo needle Emma than just this. It's actually a stronger condition than just an isomorphism.
This is actually something called a natural isomorphism. We'll talk about that later. Let's just
start by looking at an example. Okay, I should also say that the real magic of the yo needle Emma
is actually in the proof. Okay, because it's it's how we construct this isomorphism, which is really
important. But the proof is actually amazingly straightforward. It's like a three line proof
or something. So anyway, once we have a look at an example, this is going to make a lot more sense.
So let's pick a category C. Okay, how about this one? This is our kind of category of two parallel
arrows, which is the thing we're using to make graphs. Okay, as I was saying at the beginning
of a video, graphs can be thought of as functors from this category to the category set. Okay,
so we'll talk about graphs. Now we need to pick an object E of this category C will actually pick
this object E up here. Okay, so it's going to look like I'm talking about graphs now. But of
course, remember that this is a general statement. It just happens that I'm using an e here and an
e here just so I can step straight into an example. Okay, so they're all the things we need. Now what
does this you need a lemma say? Well, okay, so we have a category C, there it is. We have an object
E of category C. The other thing we need is a functor G from C to set. Okay, so what's a functor
from this category to the category of sets look like? Well, it's a graph is an example, this graph
here. Okay, we talked about this one already. It has three vertices, one, two, and three, and these
two edges, A and B. Okay, so how do we represent this graph as a functor? Well, it's here. Okay,
so we have, we think of this graph as a functor from this category C to the category of sets.
It sends this object E to this set G of E, which has two elements, these edges A and B. Okay,
and it sends this object V here to this set of vertices, one, two, and three. Okay, so this
functor here is representing this graph, essentially, it sends this S arrow here to this function,
which picks out the source vertices of our, of our edges. And similarly, T gets sent to G of T,
picking out the targets, vertices of our edges. Okay, so this functor just represents this graph.
Now, the real magic of this is to understand what this means. Okay, what is home E comma dash?
Well, that is a home functor. That's what I just discussed on the last,
on the last load of writing on the blackboard. And what it really is, is it's a, it's just a
functor, which goes from this category C to the category of sets. Okay, and so remarkably,
in this context, that should be a graph. Well, that's interesting, isn't it? Because this is
obviously a fairly special kind of functor, because it has this kind of natural definition
in terms of this actual sets of arrows of the kind of template thing, which we're using to make graphs.
Okay, so it's all to be a fairly important graph. So let's find out what graph this is. Let's
calculate what this home functor is. Okay, so what we need to do is think about how this home functor
home E comma dash operates on the different objects and arrows of our category C. So let's start
by determining what home
E comma E is. So that's where this object here E is going to get sent to under this home functor.
Okay, so what's home E comma E, it's just the set of arrows from E to itself. Okay, so it's
just going to be one such arrow. And it's just going to be the identity arrow of this object E.
Okay, so this is just a set with one element, which we call IDE.
Okay, so far so good. Now there's just one of our objects that we have to operate our home
functor on. And that's V. Okay, so the next question is what's home E comma V. That's going to be where
this object gets sent to under this functor. So what's that going to be? Well, that's going to be
the set of arrows from E to V. So let's draw home E comma V down here. So what are the arrows from
E to V? Well, there's two of them, S and T. So this is a set, S, T.
Okay, so we're nearly done. We've operated our home functor on the different objects of our
category C. All we have to do now is operate our home functor on the different arrows in this
category C and see what kind of functions they get sent to under this home functor. Okay, so let's
just remember the definition of our home functor. So the way it works, just in general, okay, just
for a second forgetting about this specific category that we're talking about. The way this
works is that if we have an object E, maybe we have a load of arrows from that to some object
X, okay, maybe here's a specific arrow with Lex. And then suppose we have an arrow F from X to Y.
Well, then what's going to happen to this arrow with Lex? Well, it's going to get sent under
this lifted home functor home E comma F of X is going to equal F after X. Okay, so this
lifted home functor sends this arrow X here to F after X. Okay, so this is the effect of doing home
E comma F on this element here of this home set. Okay, that's the definition we've already looked at.
Okay, so now let's use this kind of intuition here. And we're going to use it in this specific case
of our category C. Okay, so let's just pick an arrow and figure out what happens to it
when we lift it under our home functor. So how about this arrow here S from E to V?
Well, what's going to happen when we lift it? We're going to get home E comma S.
And that's going to be an arrow which goes from home E comma E to home E comma V.
Right. And so it's somehow going to send arrows which go from E to itself to arrows which go
from E to V. How is it going to work? Well, we can just use this formula here. Okay, so in this
case, this formula becomes home of E comma S operating on an arrow X equals S after X.
Okay, that basically tells us then how this arrow is going to get lifted under this home functor.
So what's it going to do? It's going to be a function from this set here to this set here.
And how does it operate on an element X of this set here? Well, it sends it to S after X.
So in particular, there's just one element in this set here, which is IDE. And when we do S
after IDE, we just get S. And so this here is going to be the function home
E comma S.
Now, in a pretty much analogous way, we can figure out what happens to this arrow here T
when we lift it under our home functor. And that's just going to be another function from this set
here home E comma E to this set home E comma V. This time it's going to send this identity thing
to T. That's going to be the effect of this other lifted arrow here home E comma T.
Okay, you may want to pause the video and check out for yourself that this works.
Now ask yourself, what kind of graph would this represent? Okay, it's a good question.
We're going to get to that in more detail in a moment. Let's just make sure we finish this job
of figuring out how we lift all these different arrows.
So if we're going to finish this job, we then, if we're being very methodical about this,
we then want to ask, okay, what kind of, we then want to ask, okay, what happens to this
arrow here, this identity arrow of E when we lift it under this home functor? In other words,
we're now curious about what is home E comma
IDE. And if you think about it, this is going to be an arrow which goes from home
E comma E to home E comma E. And how does this arrow work? Well, in fact, it has to just send
everything in home E comma E to itself. Okay, indeed, we need this kind of condition
that when we operate our functor on an identity arrow, we get a resulting identity arrow. Okay,
that's one of the things we require of a home. That's one of the things we require for something
to be a functor. And indeed, this home thing here is a functor. So all this home E comma IDE is,
is it simply an identity arrow of the edge set here? And in a similar way,
this arrow IDV just gets lifted to an identity arrow of home E comma V. Okay, so we don't need
to draw those in. This is the important part of the picture here. This is a sort of representation
of what our home functor looks like without drawing in the identity arrows. Okay.
And you can see that it has a kind of similar layout to this. And why is that? That's because
this represents a graph. Which graph does this represent? Well, this is the kind of magical bit.
So which graph does this home functor represent? Well, this would be the edge set, and this would
be the vertex set. So we have one edge, which we'll call IDE. And we'll have two vertices,
S, which is the source of this edge, and T, which is the target of the edge. So this is a graph.
And we can rightly call this graph home E comma dash home E comma blank. Okay,
this home functor here represents this graph. Now, this is a very elementary graph. This is a
very important graph. As I said before, this kind of graph has the property that we can
really identify things about any other kind of graph by thinking about the arrows from this
graph to it in the category of graphs. Okay, so now comes the moment of realization,
because what's the yo needle MS saying? It's talking about natural transformations
from this home functor here to G. What's a natural transformation? In this case,
it's a it's a arrow in the category of graphs from this graph to this graph. Okay, so here's an
example. We might send T to three, and we might send S to one, and we might send this edge here
to a. Okay, so that would be a natural transformation from this graph here to this graph
here would be a natural transformation from this home functor here to this other functor here G,
which represents this graph. Now, what's the yo needle MS saying? It's saying that the set of
natural transformations from this graph here to this graph here, or equivalently from this
functor here to this functor here is isomorphic to this thing we get by operating our functor G
on E. So what's G of E? Well, it's just the edge set of our graph. Okay, so this is why we're
saying at the beginning, the edge set of our graph, each edge in our graph corresponds to a kind of
arrow from this special sort of single edge graph to G. Okay, so something quite profound is happening.
The home functor here, which is this kind of very natural functor
in the yo needle Emma turns out to be in this example of graphs, it turns out to be this
special kind of elementary graph. And what the yo needle Emma is saying is that the set of
natural transformations from this home functor to another functor in graph language that the set
of graph homomorphisms from this single edge graph into our other graph is isomorphic to G of E.
What's G of E in this context, it's just the set of edges of our graph. So the yo needle Emma is
telling us that the set of edges in our graph, each edge in our graph corresponds to a natural
transformation, an arrow in the category of graphs from this special kind of template graph
into our graph G. Okay, this is basically explaining to us how the structure of G, how its bits and
pieces, well, its edges in this case are being put in correspondence with these kind of special
arrows coming out of this special kind of template graph. Indeed, this special kind of template graph,
this single arrow is really picked out because it corresponds to this special kind of home functor,
this special functor from C to set. Okay. And there's more to the yo needle Emma. So I mean,
in this case, we picked this object E. In this case, it was this object here. What do you think
would have happened if instead we picked this object V. Well, in that case, we wouldn't have
got this graph here as our home functor, we would have got, can you guess, we'd have got this graph
here, single vertex. And indeed the vertices of our graph correspond to arrows from this single
vertex. And there's even more to it because the yo needle Emma also has an extra kind of layer to
it, which I haven't mentioned yet much. And what this extra layer is, this is the, the
finished result is, is not just saying that this set of natural is is not just saying that this
set of natural transformations is isomorphic to G of E. The yo needle Emma says that this set of
natural transformations is naturally isomorphic to G of E. It's natural in both G and E. Now,
I haven't explained what that means yet. And I will get around to it. But the long shot of that
is basically that by looking at the interactions between these different home functors, we can
actually talk about which edges are connected to which vertices. And, you know, the amazing thing
about all of this is that graphs, this amazing category of graphs is just one example and an
infinite number of examples that this yo needle Emma can be applied to. And in every case, it's
explaining exactly how this kind of internal external sorts of relationship works.
Okay, so perhaps I'm getting ahead of myself a little bit. I'm extolling the virtues of this
result that haven't really explained it properly. And I think the best way is for me to sort of
sketch a proof of the yo needle Emma. Now, this might sound intimidating with all this kind of
exotic gadgetry going on. But in fact, the proof is remarkably simple. It's so simple. It's,
which is very, very short. Actually, this is really just a proof sketch. What I really want to do
is to describe what this isomorphism is, because basically I'm saying that there's a sort of
correspondence between the natural transformations from this home functor to this functor,
and the elements of this set, the set that we get by operating this functor G on this object E.
Okay, so I'm going to go through this argument now. I'm using these kind of symbols, which
all seem familiar from this example of graphs, but you should bear in mind that this is a
completely general type of argument. Okay, so what we really want to do is to make a natural
transformation from this home functor here to G. Okay, so what do we know about such a natural
transformation? Well, we know that for every component, say the vif component of these functors,
there's going to be a vif component of this natural transformation, which sends, say,
home E comma V to G of V. Okay, here V is just any object in this category C. Okay, so we know that
our natural transformation is going to have a component alpha V. And because all this stuff's
just happening in set, this is just going to be a function from this set of arrows from E to V
to the set of elements of G of V. So all we're going to do is think about what these kind of
natural transformations will look like. Okay, so the one thing we do know about them is that
for every arrow, say an arrow from
E to V, we're going to have a naturality square like this. Okay, and so we have this
naturality square. So we know that going along alpha E and then G of S gives us the same function
as going along home E comma S and then alpha V. Okay, so we know these two functions have to be
the same and this has to hold for every arrow coming out of our object E. Okay, so we want to
construct such a natural transformation. So let's just ask ourselves, do we know of any
elements which are going to be in this set here, home E comma E in a general category?
Okay, so what's home E comma E? It's the set of arrows from object E to itself. Okay, so what kind
of elements are definitely going to be in that kind of set? Well, there's just one that we can be
sure of being there and that's ID E. Okay, now I've written this in red and it represents an
element of this set. Okay, now what happens when we apply alpha of E onto this element here?
Well, it's sort of like what's going on over here. Okay, we're going to do some kind of natural
transformation. It's going to have an EVE component and that's going to send this element
somewhere in G of E, isn't it? So alpha E is going to look like that. Now, in a general context,
of course, there may be more elements in this set, there may be more arrows from home E to
itself. So we know that ID E is going to get sent to some element of G of E.
So why don't we give this element a name? Okay, we'll call alpha E
of ID E, we'll give it a name, we'll call it E star. Okay, so there it is. It's just going to be
some element of this set here, G of E. So in this kind of context, ID E gets sent over here. So we
could call this E star. Okay, over here is like that. Now, let's just continue to think around
this naturality square. Okay, so the next thing we're going to do going this way around the square
is we're going to do G of S on E star. So what are we going to get down here? We're going to get
G of S of E star.
Now, all we're going to do now is we're going to go the other way around this naturality square.
Okay, so we take ID E and then we want to apply this function here, home E comma S. Now, remember
in general, the way this works is that home E comma S operating on X
gives us S after X. Okay, we've already talked about how this works. So for us, our X is just ID E.
So what happens when we operate this function on it? Well, we simply get S.
Now, all we do is we apply alpha V onto S. And what do we get?
We get that this must be equal to alpha V
of S. And that's the end of our argument. So what does this mean? Well, it really means something
quite profound. Okay, because what's happened here? Let's say we want to know what this natural
transformation alpha is doing. Okay, we made one choice in this construction. We made one choice,
which was to send ID E to some particular element of G of E. We call that element E star. Okay.
And everything else about this natural transformation has actually been fixed by that choice.
Because if we want to know what the V component of our natural transformation is for a general
object V, well, we do know that. Why? Because we know what happens when we do alpha V on an element S.
What is this element S? It's just a general element, a general arrow from E to V. And we know that alpha
V operating on S is equal to this G of S of E star. And this is going to hold for every arrow S
from E to V. In other words, it's going to hold for every element S in hom E comma V. In other words,
this equation here, if we think of S as varying in this set, this is telling us how alpha V works
on every single member of this set. So it's actually telling us exactly how this function alpha V is
defined. And this holds for any object V. So if we have any object V in our category, don't be confused
by this connection with the graphs because this is all general kind of arguments here.
This could hold in any category C and E can be any object and S can be any arrow from
E to any other object V. And in general, we always have this kind of equation holding through.
So this describes the isomorphism between the set of natural transformations
and the elements of G of E. Why? Well, because given any element E star of G of E,
we can always define a natural transformation like this. So we can always define it so that
it sends the identity element of E to this element E star, which we've picked out of G of E. And that
then forces the rest of the natural transformation into having a particular form.
Conversely, if we have a natural transformation alpha, we can just see how that operates on IDE and
that will pick out the kind of labeling elements of G of E. So this is really describing an isomorphism
between these. So now we kind of know what this isomorphism looks like. We can be a bit more
descriptive here. So I'm going to actually write what these functions are here, what this isomorphism
actually is. So I'll write it as psi subscript e comma g. And it has an inverse, which we can call
the psi to the minus one, e comma g. So how is psi defined?
Well, psi of e comma g operating on an element E star
of G of E is going to give us a natural transformation alpha,
where alpha
V of s equals G of s
of E star
for all
arrows s from E to V. Okay. And what about the inverse? Well, the inverse is pretty simple.
So alpha e comma g inverse operating on alpha
is just going to be alpha e
of IDE. Okay. So how does this work in the context of our graphs then? Well, what it's saying is,
for example, let's say we're talking about a natural transformation from home E comma dash
to G. Well, what we're saying is that if we're going to send IDE here, this kind of labeling of
our fundamental edge, if we're going to send that to some edge E star of our graph, well, then
we know how this natural transformation works on the rest of its components as well.
In particular, we know that for this element s here of home E comma V, in other words, we know
that for this kind of source vertex, we know that the V component of this natural transformation,
alpha of V is going to send s to what we get if we operate G of s on E star. What do we get
if we operate G of s on E star? We get one. Okay. So going around the so going around the
naturality square this way is sort of like doing our natural transformation, you know,
sending our edge to where it's supposed to go, and then looking internally where its source is.
And then going around the naturality square this way is sort of looking at the home front door
and looking at where this sort of source vertex is. And then doing the vertex components of
the natural transformation on that and they're giving us the same thing. Okay. So it's really
saying in this context that just by specifying how this fundamental edge is getting mapped,
the rest of this natural transformation has been fixed. Okay. So this is the basic layout then.
It's time for a little bit of clarification about the general and the specific because
in this kind of argument, I'm sort of mixing discussion of the general yonidilema with this
particular example involving the graphs. Okay. So just to clarify what I'm writing here,
this is a general statement of the yonidilema and this works for any functors are going from
any category C. And down here this is the sort of general argument for the yonidilema. I won't
exactly say it's a proof because I haven't shown that this kind of isomorphism which I'm constructing
here is a natural isomorphism. I'll talk about that a bit more later. But I have given this sort
of basic idea of how we construct it, how we can take an element E star from G of E and use it to
define a natural transformation. And this is a sort of basic way that we relate elements of this
set G of E with natural transformations from this homfunctor to G. Okay. And then up here,
I've written the general kind of description of this isomorphism. So we'll actually have one of
these isomorphisms psi of E comma G for every object E of which we sort of construct a homfunctor
about in every other functor G from C to sets. Okay. And then the other stuff on this board
is about this specific case of graphs. Okay. And so and so what I'm trying to do with this example
is to sort of show an application of the yonidilema. So I'm basically saying in this case,
we're going to use the isomorphism going this way around. So we're basically imagining that we
are thinking about doing a graph homomorphism, or if you like, a natural transformation from
this homfunctor to this functor representing our graph. And the way we're doing this,
let's say is we have this homfunctor, which basically corresponds to just a graph with one edge.
And we're saying, okay, imagine that we're just specifying how the ETH component of this homfunctor
is mapping this element here, this IDE, which is really representing the single edge of our graph.
And we're saying, well, if we're fixing it so that IDE is getting sent to E star under this
alpha E component of this natural transformation, then that fixes the rest of the natural
transformation. How does it fix it? Well, it's described here. Okay. We're saying that
given this element, E star of G of E, the whole, the rest of the natural transformation is fixed
because for any object V and any arrow, S from E to V, we're going to have this equation holding
true. So the VTH components of the natural transformation operating on this S is going
to be G of S operating on E star. Again, this is general notation up here. So I do have a specific
S, sorry, I do have a specific S involved in this talk of graphs, this arrow S here.
But this is just a source of coincidence in a sense because over here, when I'm talking about S,
I'm talking about a general arrow S from E to a general object V. Okay. But in this specific
case of graphs, yes, I do have a particular arrow, which I have named S. And we can see how
the way that alpha V, which in this graph case corresponds to the kind of way this graph homomorphism
works on vertices, we can see that the way that that's working on this
source vertex here is described by this. So in particular, what's this statement say? Well,
what's alpha V of S? Well, alpha V is going to be the sort of VTH component of this natural
transformation. And we can see, you know, by how our graph looks like, we can
we can see by this picture here how this is supposed to be drawn. And the Yonita lemma says
that alpha V of S is sort of fixed by the way that we've mapped IDE, it's fixed by this equation to
be G of S of E star, which is the source of E star. So we know that alpha V of S is one. Okay, so
there it is. Now, we also have another arrow from E to V. We have another arrow like this,
which we're actually calling T. And, you know, we could just use this same equation and put T's
in here instead. And then of course, we get that alpha V of T is going to equal G of T of E star.
So in other words, this sort of VTH component of this natural transformation has to send T here
to number three. So this is a drawing then of the VTH component of our natural transformation as
it's working on these kind of edge sets. And as it's working on this vertex sets here. So there we are.
Okay, so now let's talk about the specifics again. Let's talk about this specific example
of graphs. Okay, so the thing is, we've already seen some evidence that this
home functor here turned out to be very special for describing graphs because it turned out to
just be a single edge. Okay, and it turns out in general, when you're dealing with these functor
categories, which are sort of categories of structured sets, and there are many of them,
they're very important. And if you're interested in one of them, then it turns out that these
home functors are very important because the arrows out of them, the natural transformations out of
them, basically tell you about the structure of other objects in your category. This is what
the O'Neill-Emer is about from this perspective. Okay. And so it's a good idea to get all the
home functors that it's kind of like a collection of elementary particles that describe the rest
of the goings on in your category. Okay, so we have one of them. And how did we get it? Well,
it's home E comma dash. So we got it by picking this object E. We picked this object that represents
the edge sets. So let's get the other one. Let's, let's get the other home functor and see what
that looks like. So we just pick the other object of our category C here, which is V. And now we're
interested in what's the form of home V comma dash. Okay, this is another home functor. And in this
case, it can be visualized as another graph. Okay, so we'll just why sort of shown how to
construct it here. Okay, so all we do, we say, okay, well, we want home V comma E. What's that?
Well, that's the set of arrows from V to E. There aren't any. Okay, so that's just going to be the
empty set. Now, the other object of this is going to be home V comma V, which is the set of arrows
in category C from V to V. Oh, there's just one such arrow. That's the identity arrow of this
object V. So home V comma V is just a set with a single element. Okay, now we think of this as the
edge set. And this is the vertex set when we're thinking of this functor as a graph. So we have a
graph with no edges and one vertex. And so we can draw it. Okay, and here it is.
You probably anticipated this. This is the other sort of fundamental elementary kind of graph,
just the graph that has one vertex and nothing else. And we can now rightly call this graph
home V comma blank, because that's the functor that it corresponds to. Now, I've just gone through a
bit more work here to flesh out what the rest of this home functor looks like, because I think
it's quite useful. It's actually a really great exercise to make these home funtals and to sort
of go through them because it really validates a lot of the kind of language which we use and even
the kind of observations which we've already seen, for example, regarding empty sets and things like
that. So I've already described the two objects. So I've already described how this home functor
works on these two objects. Okay, it will send E to this empty set, and it will send V to this
set with one element. Of course, this home functor also works on the arrows. So how does it do that?
Well, a funny case, maybe the funniest case to contemplate is what happens to this arrow
S from E to V when we lift it under this home functor, home V comma blank. Well, this arrow S
from E to V is going to get lifted to become an arrow from home V comma E to home V comma V. So
it's going to be a function from this empty set to this singleton set. And how is this function
defined? Well, if you remember the way that these sort of arrows lifted onto under this home functor
defined, they send an element X to the arrow S after X. So it's going to be a function from this
set to this set, and it will take an element from here and send it to S after that element,
a composition. Okay. However, this set doesn't have any elements. So this is a bit kind of
vacuous. We've sort of defined a function, we've defined how it works on inputs, but it doesn't
have any inputs. So this is a function from the empty set to IDV. So we actually have encountered
this idea already when we talked about initial objects. I think it was in,
so I think it was in my video on functors and duality around about there, right, talked about
this. So there is this curious idea in the category of sets that if we have an empty set,
and we have another set, then there is a function from the empty set to the other set,
it sort of doesn't have any inputs. So in fact, it's just one weird kind of function that doesn't
do anything, even though we seem to have actually programmed the function to do a specific thing,
it doesn't have anything to do that thing on. So there you are. So okay, that's home V comma S
as a funny case. What about this arrow just to make sure we've seen the different cases. So this
is an arrow in this category C is IDV. It goes from object V to object V. So when we lift it,
we're going to get this arrow here from home V comma V to home V comma V. And how does this
arrow this function work? Well, it takes an element and then it sends it to IDV after
that element. This is like arrow composition. Here this sort of arrow with a line before it,
this is notation mathematician sometimes used to mean maps to. So this is a function which maps X
to IDV after X in other words, this is the image of X under our function. So how does this work?
Well, there's just one element for it to work on, which is IDV. And it just takes it and
composes it with IDV, which gives IDV. Okay, so this is just an identity function. So we can
rightly say home V comma IDV is ID home of V comma V. It's just the identity function on this set.
Similarly, there'll be an identity function on this set, which is the image of IDE.
And there should be similar stuff drawn over here, which would be the images of these two arrows,
which would give identity functions of these two sets. I didn't bother drawing those. I didn't
want to have too many things coming out new at the same time. So as you can see, a lot of this
is pretty vacuous. The only really important thing here is that this corresponds to a graph
with one vertex. So we can draw it over here. So it's basically just a graph with one vertex and
no edges. Okay, so now we get to an issue that's really interesting to think about, which is,
okay, so now we have this. Let me ask you an interesting question, which is,
if you're working in the category of graphs at this kind of high categorical level,
where you're just sort of looking at the objects in the arrows, how can you say that this vertex
here is the source of this edge? Okay, now we can refer to this edge using this natural
transformation from this single arrow graph here, as I've already talked about. We can also refer
to this vertex here, in terms of a natural transformation from this single vertex graph,
this thing we can call hom v comma blank. So we could say that there's a natural transformation
beta, which looks like this. Okay, this will be the v component of beta. The eth component
of beta is sort of vacuous. Okay, it doesn't really have any elements to work on. There are no edges
to map. Okay, so we could draw, we could draw this on our diagram as well. In terms of the sets,
it's going to start looking a bit messy, maybe, but let's try.
So that's going to be the v component of beta. And then the eth component of beta
is just this kind of function without inputs, like so. Okay, so this is a drawing then of this
natural transformation from this functal hom v comma e to this functal g that represents
our graph. And here I've actually drawn it graphically. Okay, so thinking about the graphs
again, we have a arrow alpha, which picks out this edge a, which I'm saying is e star. Okay,
and we have this arrow beta, which picks out this vertex one. Okay,
so how can we say that these two arrows are talking about the same vertex? Well, this is
really quite magical, I think. What we do is we say, what we do is we say, well, imagine there's
a natural transformation gamma, which goes like this. Okay, so that'll be the v component of gamma.
So gamma is some kind of natural transformation, which sends this vertex to
the kind of source vertex of our single edge. And moreover, this is the important bit,
let's suppose that beta
is equal to alpha
after gamma. Okay, and this is our key kind of way of externally describing that this vertex
is the source vertex of this edge. By saying that if we sort of send this vertex into our,
by saying that if we send this vertex to be the source of our single edge graph,
and then we send our single edge graph into this graph here, and that doing so has the same
effect as sending this vertex over here, that information is communicating that this vertex
gets sent under this transformation beta to the place which is the source vertex of where
this edge gets sent to. Okay, so this is an external way of describing how these bits and
pieces in this graph are connected. And we could describe the rest of the information in this graph
in a similar way. We can say, well, there's a arrow from here to number three,
which is the same thing we'd get if we compose the arrow from here into t and then alpha.
And that would pick out this vertex three and say that's the target of this edge.
And we could have other arrows representing this edge b and more of these kind of triangles of
natural transformations to describe how vertex two is the source of b and vertex three is the
target of b. So there's a collection of arrows from these home functors and kind of arrows between
them with these kind of equations representing commuting triangles, which describe the whole
structure of this graph, but they describe it from a kind of external perspective. Okay.
And we actually get a better description of how all this stuff works from the yo-nida lemma.
Okay, because there's this other kind of level to the yo-nida lemma, which I haven't discussed yet,
which is basically saying that this isn't just an isomorphism between these two sets. It's a
natural isomorphism. And it's in that kind of naturality that we see how this kind of stuff works.
I should just draw this natural transformation gamma in this set language as well. Okay, so it's
a natural transformation from hom v comma dash to hom e comma dash. So actually, I want to give this
natural transformation a more kind of elaborate name. I want to actually call it gamma superscript s
just to remind me that it goes from this single vertex to the source of our ourograph. Okay.
So I should actually say beta equals alpha after gamma superscript s. So this s here, this isn't
like a component or anything. This is just a name that I'm just putting upstairs. Okay.
So let's draw gamma in the set language as well.
So there's the vive components of gamma s. And again, the kind of eave components of gamma s
is a bit sort of vacuous
because it doesn't have any inputs. Okay. Okay, so I've just cleaned up this picture a little bit.
I thought I'd only write the hom v comma v since hom v comma e is empty. And I've deleted a lot of
these kind of vacuous arrows which were here. So this is basically just what was here before. I've
just kind of cleaned it up a bit and deleted some of the empty sets and arrows, which are sort of
vacuous. Okay. And what I've written here is something in general. Okay. So we're keeping
shifting between this case of talking about the graphs, because that's really illustrating the
yo needle Emma, and also then talking about the kind of generality. So now I want to talk about
the generality of it. And what I really want to talk about is how we can make a natural
transformation from one home functor to another home functor. Okay. So this gamma here was an
example of that in the graphs, but I want to talk about this in general. Okay. So in a general
category C, let's suppose we want to cook up a natural transformation from home v comma dash
to home e comma dash, where v and e are just general objects in our category C. Well,
we can do it if we have an arrow s from e to v. And then we can make a natural transformation,
which we can call gamma superscript s. How do we make it? So what we want to do is that for every
object x of our category C, we want to have an x component of this natural transformation. So
gamma s of x, and that ought to go from where x got sent to under our first home functor
to where x got sent to under our second home functor. So gamma s of x ought to be a function,
which goes from home v comma x to home e comma x. Okay. So what we want to do is we want to make a
function which sends arrows from v to x to arrows from e to x. This is in our category C. Okay. Our
general category. So let's suppose we have an arrow u from v to x. How are we going to map it
under this function here? Well, a way we can change it to get an arrow from e to x is we can
do u after s. So that's how we define this function here, this x components
of our natural transformation. We define it so that if we have an arrow u from v to x,
then we send that arrow to u after s. Okay. And that'll give us
an arrow from e to x.
And we're going to use this very shortly when we talk about this
isomorphism here being natural in object E of our category C.
Okay. So I believe at this point, a quick aside to recap what natural isomorphisms are would be a
good idea. Okay. So let's just consider a general situation where we have categories D and E and
front doors L and M each going from D to E. So I think I've talked about natural isomorphisms
before in this series. And there's several equivalent ways to define them. And I think
the definition I went for before was to say that it's a natural transformation psi from L to M
is a natural isomorphism when there's another natural transformation, psi to the minus one
from M to L, such that composing psi and then psi to the minus one gives the identity
natural transformation on L. And similarly, composing psi to the minus one and then psi
gives the identity natural transformation on M. Okay. So that's just a fancy way of saying
that a natural isomorphism is just an isomorphism between objects L and M in the category of
front doors from D to E. If this seems unfamiliar to you, don't worry, we're not going to build on
this because I'm actually going to tell you an equivalent definition of a natural isomorphism.
So basically would say that psi being a functor from L to M is a natural isomorphism.
If it's a natural transformation from L to M and each of its components is an isomorphism.
Okay. This is an equivalent way to define a natural isomorphism. Okay. So we just require
that each of these arrows, each of these components like psi of X from L of X to M of X is an isomorphism
between these two objects. And that will be an isomorphism in this case, in this category E here.
There's okay. So there's something else which is relevant to our discussion. And that is that if we
want to prove that psi is a natural isomorphism, we just have to show that psi is a natural
transformation and that psi of X is a natural isomorphism. And then it will follow that psi to the
minus one, this natural transformation obtained by gathering together all the inverses of these
components is also a natural isomorphism. It's the sort of inverse of this one. Okay. So we can see
this quite easily because we'll have to have naturality squares like this in order for psi
to be a natural transformation. Okay. And then supposing that psi is also and supposing that
each component psi of X is a isomorphism, that means it has this kind of inverse psi to the minus
one of X and so forth. And we can show that psi to the minus one is also a natural transformation.
So how do we do it? Well, the fact that this square is natural implies we have this equation here.
And then all we have to do is multiply it by
psi, the Y components of psi to the minus one on the left.
And the X components of psi to the minus one on the right.
Now, this doesn't change the equality because we've done the same thing to both sides of
this equation. But what does happen is that these two cancel and these two cancel because
each of them become identities. And what we end up with is this new equation that psi to the minus
one of Y of after M of F equals L of F after psi of X to the minus one. And what does that mean?
It means that this square is natural. Okay. L of F after psi of X minus one is psi of Y minus one
after M of F. Okay. So this square is natural. So we've now shown that psi to the minus one
made out of these kind of components is also going to be a natural transformation.
So what I'm basically trying to say is that if you have a collection of arrows, one arrow
for each object in this kind of natural transformation style, if you know each of those
arrows is an isomorphism and you have the inverses, then if you can just show that that
collection of arrows forms a natural transformation, then you know that you have a natural isomorphism
and you know that the collection of inverses of those arrows is also going to be a natural
isomorphism, the inverse of what you have. So how this becomes relevant for us is because
we have in the case of the sort of yo-nida isomorphism, we have the size and the
psi to the minus ones and I choose to show you that the psi to the minus ones are sort of natural.
And that's the way I argue for the naturality, but you see that you can work with the psi to the
minus ones or you can work with the size either way, showing that collection is natural implies
that the collection associated with the inverse is natural as well. Okay so let's carry on talking
in generalities and I'm now going to move on to this thing which I kept hinting at which is that
there's a bit more to the yo-nida lemma. It's not just that this isomorphism here puts the elements
of GIV and these natural transformations in one-to-one correspondence with each other.
It does that but it's more than just an isomorphism, it's a natural isomorphism. So what does that mean?
Well basically if you have two functors then you may have a natural transformation from one
to the other. And what is that natural transformation? Well it's a load of components
for every object of your sort of source category. There's one of these components of the natural
transformation, an arrow. Okay and sometimes arrows can be isomorphisms and if every component
of the natural transformation is an isomorphism then we call such a natural transformation
a natural isomorphism. So what I'm saying then is that this psi thing which I defined relating
GIV and this set of natural transformations is a natural isomorphism. So what does that mean?
Well one thing it implies is that it's a natural transformation. Okay but how can it be a natural
transformation? Natural transformations go between functors right? So somehow that means that
this GIV when we consider somehow that means that this GIV can be considered to be a sort of value
of a functor as can this. Okay so how do we think of these things as functors? Well I'm trying not
load too many new ideas into one video but it's difficult with the your needle emma because
so many things are going on at once but basically we can consider this to be the value of a functor
on an object and this to be a value of a functor on an object. So what do these kind of functors look
like? Well they're functors which go from
C
times set to the power of C
to set
okay. So if this seems a little abstract don't worry we're kind of going to skirt around this
we're not really going to have to get into depth about what this means but basically what I'm saying
is that we can consider that to be a functor which goes from the product of these two categories
to the category set. Okay what does that mean? Well what it basically means is that it's a functor
that takes an object of C and it takes an object of this category and it gives us a set. Now what's
an object of this category? Well it's just a functor from C to set. Okay this is the category
of functors from C to set and so what this is basically saying is that this is a functor which
when it's operating on objects it takes an object E and it takes a functor G and it gives us a set.
Well that's what this does and surprisingly that's also what this does so it's quite remarkable
that this G of E can actually be considered to be a sort of thing that an object in this
category gets sent to under a particular functor there's a particular functor that sort of has
the output's objects of this form. So what I'm saying here is that this Psi can be considered
to be a natural transformation from this kind of functor to this kind of functor. Okay so I've
already tried to demonstrate that the components of this natural transformation this Psi E comma G
are isomorphisms okay and so that means I just have to demonstrate that
that this Psi E is kind of natural in objects E of C and these functors G these objects have
set to the power of C okay but that's why I'm labeling the components of Psi with these two
different things here because actually this is a natural transformation between functors
which are dependent on objects E and functors G. There's one extra kind of thing to bear in mind
here because what I want to do at the top is I want to argue that this Psi here is natural
in objects E okay because I don't really want to have to deal with all the sort of complicated
machinery involved in thinking about these kind of functors from the product of two categories
to another category. So what I'm first going to do is show that Psi is natural when we consider
stuff in C and we hold our functor G constants and then I'm going to look at the other way around
so I'm going to then hold the object constant and vary the functor and show again that the thing is
natural. So the other kind of extra funny thing going on here is that I'm actually with this square
I'm about to demonstrate that the inverse of Psi is natural okay so it's something which is true
of natural isomorphisms that if you know that each component is an isomorphism of course that means
that these components have inverses and you know the collection of all those inverses gives you the
kind of inverse of the natural transformation so sort of conversely if I can prove to you
that Psi to the minus one the inverse of Psi is natural then I'll have proved that Psi itself
is natural. So let me try and give a sort of rough sketch about why we can consider Psi to the minus
one as a natural transformation so as I say this this kind of transformation kind of works in two
components it works in sort of two directions one is where we might vary the object that we're
interested in say either a E or a V and then the other way we might vary things is we might change
the functor G but I just want to talk about the first case to start with so let's suppose that we
hold this we hold this functor G fixed okay so what we then have is that for every object E
we have one of these kind of functions Psi to the minus one E comma G
and that's going to be a function which goes from a natural which sends a natural transformation
to an element of G of E okay and so I want to show that this whole collection of
sort of functions indexed by objects of C
constitutes a natural transformation so what I really want to do is to
so what I really want to do is to sort of fill out these naturality squares and to try and show
you how this works so we're going to do something similar to what we did before with this square
down here because these functors here they have sets as their values okay so they're
so these arrows here are just functions so we can just consider what happens when we put an element
alpha in here a general element a general natural transformation from this home functor
to G and we'll see what happens to it when we go both ways around this naturality square so
let's start by going this way around so what happens when we go along this arrow well we do
site in a minus one E comma G on our natural transformation alpha and that gives us this
okay so what we end up with up here is
psi of E of one of E and sometimes we're calling that E star okay so what's the next thing we need
to do to go down here well we just need to apply G of S to E star so a bit like what was going on
down here we're just considering S to be a sort of general arrow from E to V and this is all happening
in a general category okay so what happens when we apply G of S to this well we simply get G of S
of E star
okay now the funny bit which is how do we go down this arrow here so I've told you that this can be
considered to be um what's some functor sends an object E in a functor G to but I haven't told you
how this functor operates on arrows you see we'll have an arrow S from E to V and we essentially
want to kind of lift that arrow under this functor that makes these things I haven't really
described properly and we're going to see that that gives us a certain kind of function which
somehow sends natural transformations from home E to G to natural transformations from home V
comma dash to G
okay so how does that work well it turns out it's not as complicated as it sounds okay
um because we've already seen down here how we can make a natural transformation
which I'm calling gamma to the power of S which goes from home of V comma blank to home of E comma
blank okay we figured out that if we have an arrow S from E to V then we can make this thing
and it's defined so that its x components is this type of function here and so we really have this
kind of picture okay we have alpha which is a natural transformation from home E comma blank to G
and we know how to make these kind of gamma S's which is a natural transformation from home V comma
blank to home E comma blank so is there a way that we can combine these to give us a natural
transformation from home V comma blank to G or sure there is we can just do alpha after gamma of S
and that turns out to be just how this function works here it takes in an alpha
and it gives us alpha after gamma to the power of S okay where gamma is this natural transformation
defined like so and so all we have to do now to complete this naturality square is just to apply
this side to the minus one of V comma G to this and that'll have to equal this so we get the
G of S operating on E star gives us
side to the minus one V comma G
of alpha after gamma to the power of S
well we can go further because we know how side to the minus one works we have it here
so when we go along this arrow then we just get side to the minus one of V comma G
of alpha after gamma S and since we know how side to the minus one works we can expand this out
and we can just see that that's going to be alpha after gamma to the power of S and the
V component of that and that's going to be a function operating on idea V
and since this is just vertical composition of natural transformations we can just take
the components here and we can write this as alpha V after gamma to the power of S of V operating
on idea V so crucially what we have is that this equals this okay that's what mean that's what it
means for our sort of yonida isomorphism to be natural in objects of C okay it means that this
here equals this here and what does this mean well it means just what I was talking about down here
okay so let's interpret what this stuff means now in this category of graphs okay we'll go
back to this specific case so so what's going on here well we're starting off with a natural
isomorphism alpha from hum E to G and then when we apply this we just see that that's
associated with this edge E star where IDE gets sent to under this natural transformation
okay and then when we apply G of S we get this source vertex of E star here so that's one way
we can refer to this vertex now what this is telling us is that there's another way to refer
to it and this is the sort of external way of referring to it because it's saying that
if instead we take our alpha like so and then we consider alpha after gamma to the power of S
well what's that that's a natural transformation from hum V comma dash so it goes from this single
vertex to G and the way did it works is that it goes along gamma and then it goes along alpha so
it's just this beta here that I defined like this okay and then what this is saying is that if we then
take that natural transformation and we just get this element here of it alpha V after gamma S of V
IDV so in other words if we find out how this sends its sort of basic element IDV
into hum E comma dash and then we just apply the V component of alpha upon it we'll get the same
vertex okay so what this is basically telling us is that there's two ways we can refer to
this vertex we can say well you can refer to it by doing a natural transformation alpha
and seeing where the main edge of that gets sent and looking where the source of that is
or you can or you can do this natural transformation gamma starting from this
single vertex and transform that vertex to the source vertex of your edge
and then just do the V component of this natural transformation and you'll talk about the same
vertex okay so more basically this is telling us that when we're sending vertices into our graph
in such a way that we can break that sending into these two steps firstly sending it somewhere in
the initial edge and then sending the edge in that's a kind of another way that we can say
that a vertex is a source of a particular edge and in a similar way of course we could show that
the vertex in a similar way we could externally describe when a vertex is the target of a particular
edge and if you think about it I encourage you to do so we can really describe all of the goings on
in a particular graph just by saying well we have certain natural transformations from this
edge graph here and this vertex graph and then we have these natural transformations sending a
vertex to a source or a vertex to a target and we have certain sorts of commuting triangles
and that's really a totally external way of describing what's inside a particular
graph structure I mean it's sort of reminiscent of what they do it's sort of reminiscent of what
they did in particle physics and things where they sort of bombard a certain thing with particles
and see how they bounce off each other and so on and figure out what's inside something okay
okay so I've tried to argue about what this naturality of the yomedar isomorphism
in objects means in terms of internally and externally referring to things in graphs but
I think I better actually prove that that these things really are natural in these objects of
category C so we've gone around the naturality square these two different ways
so just to recap we have alpha here we do side to the minus one of it and we get alpha E of IDE
and then we can do g of s on it and we get this that's one way around the square the other way
around the square we go from alpha to alpha after gamma to power of s and then we do side to minus
one of that so we want to actually prove that these two things are equal so the first thing is to look
at this expression here and then if you remember the kind of main naturality square that used to be
down here that was just sort of what we got from going one way around the square and we know that's
equal to what we would have got going the other way around the square so we know that this is equal
actually to alpha of v operating on s we got that from our old yoneda square
and then now we just have to look at this expression here alpha of v after gamma to the power of s of
v operating on idv the thing that we got by going this way around and now if we just have a look at
the definition of gamma we see that gamma the x components of gamma s operating on u gives us u
after s so here's the vif components of gamma s operating on idv so that'll give us idv after s
in other words it'll give us s so this stuff here becomes an s and we have alpha v operating on s
just as we had up here so that proves this naturality in objects of c
okay so now just to complete our sort of tour de yoneda we're now going to show that this
sort of yoneda isomorphism psi is also natural in funk tours and again this is surprisingly
straightforward so we have these different objects and somehow these things and these things are
functorial in the actual funk tours that we're plugging in them and then we're considering this
psi here to be a source of natural transformation between these from these kind of funk tours to
these kind of funk tours well this is the inverse of psi which is this natural transformation so
what we're doing this time is similar to what we just did but now we're going to hold the
object e fixed and we're going to vary the funk tour and we want to sort of think about
what it means for this square to be natural okay so what's that mean then well it basically means
that we ought to have an arrow from g to h okay because we're thinking well in our source category
which now we're really thinking of as the category of funk tours from c to set and we're thinking
well we have an arrow we have an arrow from a funk tour g to a funk tour h so it's going to be a
natural transformation we're going to have a natural transformation delta from g to h here's a picture
of what something like that might look like in the category of graphs we're talking in generalities
now okay and it's actually quite easy to see in this case that the thing really is natural
when we vary these funk tours okay so what happens then well we need to construct this
naturality square so here's here's what happens when we operate this kind of NAT
hom comma funk tour thing on our funk tour and we get this set of natural transformations from
home e comma dash to g and then somehow we need to lift this this arrow here from funk tour g
to funk tour h under this funny kind of funk tour here and that sounds complicated but it's actually
not that bad because what we have here are sets and so we know that this is going to be some kind of
a function which sends a natural transformation alpha from home e comma dash to g and it sends that
to a natural transformation from home e comma dash to h okay so we really have this kind of picture
we're starting with a natural transformation alpha from home e comma dash to g and we also
know there's this natural transformation delta from g to h so how can we use these to make a
natural transformation from home e comma dash to h well we can simply do alpha we can simply do
delta after alpha okay so if we just send alpha to delta after alpha then that'll do the job for us
okay but it turns out that that's the kind of function that this natural transformation delta
gets kind of lifted to it gets lifted to this kind of function which sends a set like this to a set
like this by sending an element alpha to delta after alpha and actually if you sort of look at
this form and then compare it to the contravariant version of home funk tools which I'm going to
introduce at the end of this video and think about how this is to do with sets of essentially sets
of arrows in this funk tool category then this will actually seem very natural to you at that
point anyhow that's how this lifting works and so how about this one how do we lift this arrow
delta which goes from g to h to some kind of an arrow which goes from this object here g of e to
this object here h of e well how can we use a natural transformation delta to go from g of e
to h of e well that's simple we just take the eith components of our natural transformation
and that'll be an arrow from g of e to h of e so that's what this arrow looks like okay
so all we have to do now is argue that this is a naturality square to show that this kind of
yonida isomorphism is natural in the funk tools so how does it work then well we'll
just load a generic element into this top set just writing a red alpha here to represent
an element of this and then we're just going to show you that doing this function and then this
function gives us the same result as doing this function and then this function so let's go the
top way around and we have alpha with each side to the minus one of it and we get alpha of e of i
d e that's here okay now we just do delta e of it we get delta e after alpha e of i d e so that's
going this way around now what about going the other way around the square well alpha and then
when we do this function on it we get delta after alpha and then when we do this function on it
we get the same thing we just get delta of e after alpha of e of i d e so that's pretty much
all there is to it how can we interpret this in our picture of graphs well here's our natural
transformation alpha from home e comma dash to g and then going along here that gives us this
edge e star and then going down here that does the e th component of delta so just sends a equals e
star to a bar in this graph so the other way of getting at this edge here is to sort of do the
natural transformation delta after alpha so that's just both of these composed together and then
take the and then find out where i d e gets sent to under that so of course that's referring to the
same edge okay so now we've seen a demonstration of why the young needle emmer is natural
a couple of things i should say i noticed that i've been going a bit wrong with my notation
i also have been using dots because these are vertical
i also have been using these closed dots because these are vertical compositions of natural
transformations the the easy ones okay so there's a lot to go into here i mean i think it's such a
interesting exercise actually it says just go through the young needle emmer the different
things i've discussed today claims about things being natural transformations claims about things
being isomorphisms descriptions of how things work and just to actually go through some of these
examples yourself i think it's a very very worthwhile exercise because i mean number one it gives you
so much kind of exposure to all of these important ideas in category theory or working together
and secondly i mean the young needle emmer is one of the most fundamental results in category
theory it's one of the most useful ones for computation i've been discussing it a lot in
terms of these funk tour categories particularly the category of graphs but you know it is true
that the young needle emmer is very useful for understanding funk tour categories categories
of funk tours into sets but it has lots of other uses as well okay it's used all over the place in
many different creative ways and i mean i think this is such a peculiar result actually it's
i mean so many mathematical results look like generalizations of things that came earlier
i mean the young needle emmer could be considered to be a sort of generalization of
i think it's kaley's theorem from group theory but it's such a massive generalization and it's
weird i mean it's not like most of the results and i think we're really in the early stages of
appreciating what this result actually means so i mean if you're so inclined i really encourage you
to go into this and explore some new areas of this result for yourself because i believe there's
still lots of low hanging fruit to be picked okay then so understanding the category of graphs is one
of the lovely applications of the young needle emmer by going through what it means we really
see how we can refer to the structure of graphs internally and externally now this category
of graphs which we usually write as set to the power of this category with two parallel arrows
that's just one of these categories of funk tools into set another one a very lovely one
is this one this is the category of dynamical systems and the young needle emmer can be applied
there as well and if anything it's even more beautiful in this case now time is getting on so i don't
really um have time to slowly explain um how the young needle emmer works in the category of
dynamical systems but i'm going to go through a brief sketch of it and i really encourage you to
fill out the details because it's just so nice okay in my opinion at least um because it's just
such an interesting kind of thing and it yeah it's it's very lovely actually to figure this out
for yourself so let's just recap then how does this category of dynamical systems work well
the objects are funk tools from this category here to set okay so what's this category here
well it's sometimes called the additive monoid of natural numbers or a free monoid with just one
generator um it's actually a pretty simple thing it's just one object and of course we have an
identity arrow i'm calling this object star and there's also one non-identity arrow called s
and in addition to having s we also have s after s s after s after s and so on all of the different
kind of iterates or compositions of s with itself as as many times as you want okay so
when you think of the identity arrow it's doing s zero times and this is doing s ones and twice
and thrice and we can do s as many times as we want so we never get any other arrow from doing
that we always get something new by composing a sequence of s's with another s okay so in a way
it's sort of like the natural numbers this is almost like a kind of successor operation anyway
um what's a funk tool from this category to the category of sets well it'll send this object star
to a set and it'll send s here to some function g of s that goes from this set to itself and it'll
also send s after s to the thing we get by applying this function twice and this will get sent to what
we get if we apply this function three times and so on and that's why this is called a dynamical
system because s really gets sent to something that we can think of as a kind of update function
so we could visualize this um this funk tool like this with a couple of sets and this function here
maybe better to give it a kind of internal diagram like this i mean we have these elements
and then we just internally draw how this function maps these elements and we can
think of iterating um as in repeatedly applying g of s it's just kind of walking around um on
these arrows okay so a gets updated to go and b and so forth okay um so this is one dynamical system
this is one of these funk tools here's another one i'm calling this one h and here's internal
picture of it what do the arrows look like in this category well they're just natural transformations
between these funk tools okay so basically what what an arrow is going to be is a function from
this set here to this set here which has the property that if you do the transformation and then you
do the update you get the same thing as if you do the update over here and then you do the transformation
so an example would be sort of folding this picture here onto this picture here so if we send
a to b bar
b to a bar
and c to b bar i believe that works so let's just draw it out over here so a gets sent to b bar
so this would be the only component of this natural transformation okay um so what happens
a got sent to b bar
b got sent to a bar
and c got sent to b bar
so hopefully you can check that this is a natural transformation for example a gets
sent to b under the update and then gets transformed to a bar and a gets transformed to b bar which
gets sent to a bar under the update and so forth so okay then what does the yoni dilemma tell us
about this category of dynamical systems well basically the way that i think of applying the yoni
dilemma to these categories of funk tools into sets is basically find the home funk tools find
what kind of structured sets they represent and consider the arrows out of them and that'll tell
you about the other things in the category okay so um there's going to be a home funk tool for
every object in our category c well that's easy there's only one object so there's just one home
funk tool um what kind of dynamical system does that look like um well i'll leave it to you as
an exercise to convince yourself but basically it looks like the natural numbers we're including
zero here and one two three and so on and um so it's going to be the set of non-negative whole
numbers or at least we can think of it like that and then the update function is just this successor
function which sends zero to one one to two two to three and so on so it's this very kind of natural
kind of dynamical system and it turns out that this is what our home funk tool looks like so what's
the yo needle Emma tell us well it tells us that natural transformations from this sort of
dynamical system of counting this home funk or home star blank into another dynamical system g
um this set of natural transformations is going to be isomorphic naturally isomorphic to the actual
set of elements in our dynamical system okay so what's this telling us is telling us that arrows
in this category of dynamical systems from this sort of um counting dynamical system
into another one um are in correspondence with the states of the system and how does this work
exactly well let's think about a arrow or a natural transformation if you like like this
so we can send zero to anywhere we want let's send it to element a okay now actually the kind of
constraints on this being a natural transformation forces the rest of our natural transformation
to have a particular form because we know that um updating in the counting system and then mapping
all to go to the same thing we get if we map and then update so we know that one has to go to b
and two has to go to c and three has to go to b and four has to go to c and and so on okay so
the whole trajectory gets forced by the way that we decide to map zero okay and we also
have this very interesting feature that kind of updating in here and then mapping is essentially
emulating doing an update here um but there's more to it than that um you see that there's
exactly one of these sort of transformations um for every state of our dynamical system
and the whole transformation the way it works kind of tells us the future trajectory of our system
so we have this lovely kind of correspondence and it also allows us to sort of refer to what's
going on in a dynamical system um from a kind of external standpoint okay so what we can do
we can think about a
natural transformation from this home functor to itself
so what about if we send zero to one then we have said one to two and two has to get sent
three and so on so we can call this natural transformation sigma
and what about if we have another natural transformation from this home functor to g
which is actually the composition of these two okay um
well it's going to send zero to where b to sends one so it's going to send zero to b
and it'll send one to c and it'll send two to b and so on
so if we call that natural transformation gamma
then what we're going to actually have is that
gamma of zero
is equal to
beta star after sigma
of zero which is equal to
beta star of one and so on and so just by specifying that this gamma is the composition of a kind of
counting plus one transformation and then beta we're basically saying that this gamma
is the transformation we get which represents this kind of trajectory here wound on by one
time step so we're essentially talking about the updating that's happening in this system
and the states and all the rest of it in terms of these arrows from this functor home star
which is basically representing the natural numbers so it's really very very entertaining I
think to actually go through and look at this category of dynamical systems and really see how the
the claims of the yo needle emma mean things in this category because it basically
informs you of the fact that you can really talk about what's going on in a dynamical system just
by thinking about the arrows into it from this special kind of functor here this sort of dynamical
system of natural numbers this kind of counting dynamical system here okay so now we know the
yo needle emma we can just quickly sort of double our money by exploiting duality because
there's another kind of dual result called the co yo needle emma so everything I've talked about
so far the functors involved have basically been covariant the kind of normal type of functors
but the other type of functors are these contra variant ones which essentially kind of reverse
for directions of the arrows and the co yo needle emma works when we have a contra variant functor
g and what it says is in this case the set of natural transformations from home dash comma e
to g is naturally isomorphic to g of e so it basically looks the same as the ordinary yo
needle emma it's just that we've kind of reversed the positions of our object and the blank so we're
now talking about the kind of other type of home functor here this home functor when it operates
on an object it sends it to the set of arrows from that object into e so home y comma e will be the
set of arrows from y to e and this is actually this type of home functor the kind of other kind
of home functor is actually a contra variant functor okay because if we have an arrow f from an
object x to y then when we lift that we'll get this arrow home f comma e which goes from home y
comma e to home x comma e how does it work well it's a sort of function which sends arrows from y
to e to arrows from x d and hopefully you can see by this picture how it works if we have an arrow
little y from capital y to e then when we do this sort of lifted arrow under our home functor
on that element little y we just get y after f which will indeed be an arrow from x to e
okay so now we know about the yo needle emma and after doing all that maths i feel kind of
licensed to be able to talk a little bit about philosophy indeed i may get a little bit carried
away but please bear in mind that these are just my own opinions and you know that's just it but
basically uh in my opinion what the yo needle emma is saying is it saying that there's two
kind of ways to refer to things we can refer to them from a kind of internal perspective
or from this kind of external perspective now of course from what i've demonstrated so far
we just see that this is true of the kind of functor categories these categories of functor
into sets but these are basically describing structured sets and there are so many of them
they describe you know there's there's different kinds of structured sets to represent
so many mathematical objects that we think about and the fact that this kind of
internal slash external kind of duality exists for all of those kind of categories of
interesting mathematical objects in my opinion means that this is a deep result about reality
now what does it mean well i think it points to a kind of duality between the kind of internal
structure of things and the external structure of things or hermeticism for example there's
one of the main sayings from hermetic teachings is as above so below well it kind of indicates
that there is this sort of quality in these categories of functors for example the way that
a graph is internally is a sort of reflection of the way that the other graphs around it are
externally and how they are related to it it also reminds me while we're talking about kind of
ancient ideas it reminds me of a sort of i think it's a buddhist kind of idea of indra's pearls or
indra's necklace basically this kind of metaphor for the universe that it's sort of like a a load
of mirrored balls and within each mirrored ball is a reflection of all the others and so reality
is built out of a kind of load of things which are reflecting one another making a kind of fractal
aspect and so on and it indeed seems like maybe mathematical structures are arranged in this way
um what's it mean for real life well maybe one could almost say that it's a sort of justification
for being good in a sense if reality is structured so that the kind of internal goings on let's say
for example in our bodies our reflections of the way that we interact with things in the world
then that's a good reason to be good right making a good environment around yourself
will make your internal kind of states good what's it mean sort of in a more down-to-earth way well
i see parallels with particle physics i mean the idea of particle physics as i understand it
is that we're looking for these kind of elementary particles which the other stuff is made out of
what's the analogy of that in our functor categories well it'd be kind of like finding
these home funtors these things like the single vertex or the single edge which the other graphs
were made out of and what does the yoneda lemma tell us it tells us that the kind of internal
structure of things is just a reflection of how they kind of interact with the particles and also
that the kind of particle interactions and the way that those particle interactions relate to the
flux of stuff coming into an object kind of defines the internal structure of that object so
if something like the yoneda lemma is true of our universe we should probably expect that the way that
elementary particles interact with each other is related to the way that elementary particles
are bound to each other inside objects now all of this is just my own speculation but
it really makes me think for example in other subjects like say ecology or psychology my other
kinds of analogous things be true might there be kind of elementary things which are kind of like
the basic entities in those subjects which interact with each other and the other objects and kind
of like projects there's the structure in such and kind of like projects the structure of the
other objects that are going on might it also and I also I kind of get a bit carried away
I wonder if the I wonder about things like this sort of view that we have as humans generally
that the things around us are made out of bits they're made out of elements and sets and so on
and it seems to be the kind of unsaid kind of idea in mathematics that that is the basic way that
that mathematical objects are most basically they are a load of stuff which is interrelated
somehow but with the yoneda lemma we kind of see that actually when we have something like that
like a structured set its internal structure is just a sort of reflection of the relations that
that mathematical object has with other things so might it be that this case of things being made
out of stuff kind of internally is actually not the rule but the exception might it be that the
kinds of objects we generally think about a structured set and that's why we always view
them as being a made out of stuff might it be that the more general kinds of mathematical objects like
say objects in a category which is not a functional category are actually primarily defined in terms
of their relations with other things might it be that our idea of things being made out of stuff
could it even be illusionary could it even be that you know at the basic level when we're talking
about quantum mechanics and so on what we really just have is a load of relations between things
and somehow our minds imagine that that means that things are made out of concrete internal
structures all just complete conjecture but I find this yoneda lemma very kind of
it really makes one think about stuff like this
