you
you
you
you
okay hopefully we're live so hello hi everyone thanks for joining us so today I'm Jonathan
Goddard and today I'm going to be giving a kind of brief overview of some new functionality
for doing computational general relativity in the Wolfram language so that includes
both kind of analytical general relativity so doing analytical computation tensor computations
over you know space times with closed form metrics but also numerical general relativity
so doing kind of numerical simulations of space times to which for which to the best of our
knowledge that does not exist any closed form solution like so things like compact binary
inspirals black hole mergers certain kinds of gravitational collapse things like that
so this is this is new functionality that is partially deployed through the Wolfram function
repository and partially deployed as a standalone packet I'll talk a little bit in a moment about
how exactly you can you can start to use some of this stuff but so it's a framework that's
based on that's really trying to reflect one of the kind of core design principles of the
Wolfram language one of the core philosophies of the Wolfram language so and namely a wherever
possible a kind of lack of distinction between uh symbolics and numerics or between if you like
you know continuous mathematics and discrete mathematics so you know in the Wolfram language
typically if you use a function like I don't know eigenvalues you know you can you can put in a
purely symbolic matrix or you can put in a purely numerical matrix and you know the functionality
will work pretty much the same you know the internal algorithms are completely different to
handle those two cases but you as an end user shouldn't have to care and so the Wolfram language
is kind of designed in a way that lets you chop and change between sort of symbolic and numerical
computations to the greatest extent possible and the general relativity framework that we're
developing is essentially designed to reflect the same you know the same core principle so that
you know fundamentally it doesn't care whether you're deep whether you're doing you know analytical
computations over some smooth you know closed form Romani and manifold or you're doing numerical
computations over some kind of coarse discrete you know approximation to a continuous space
time represented in terms of hypergraphs and causal graphs and that's actually a fairly
non-trivial thing to do and in fact to a large extent it's only made possible thanks to some
fairly recent you know sort of research innovations that have been made as you know via the Wolfram
physics project and maybe towards the end if people are interested I'll talk a little bit about
what the you know the what the precedence to these to these ideas and this functionality
actually was and what and a little bit about the history of the underlying research.
Okay so this is ostensibly a live stream so although there will be a kind of structured
part to the talk you guys we've also tried to schedule in sort of sufficient time for questions
and discussion if there are things that so I'll be vaguely monitoring the chat and Sabrina and
Rachel and people are here to sort of to help manage some of that as usual and so I'll be kind
of vaguely keeping an eye on what you guys are saying so if there are things that you particularly
want me to focus on things you things that I said that you found interesting questions that you have
things I said that you thought didn't make any sense or you know things that you're confused
about whatever please post those in chat I may not interrupt the you know the main proceedings
but we'll definitely try to get to all of that towards the end okay so with that I should probably
share my screen and you should make sure I share the right screen and make sure that I've got the
right notebook open and hopefully someone can tell me if I've done something horrifyingly wrong
but hopefully you should you should see a notebook that says computational general relativity in the
war from language so first things first is what you know the part of the idea here is that all
of the stuff I'm going to be demoing here today you should be able to do yourself in your own
you know in any mathematical kernel or wolf from desktop instance or even you know within the
wolf from cloud or the wolf from programming lab or whatever so the the code name the internal
code name for this for this general relativity framework is gravitas and by this point a lot
of the core functionality of gravitas is now fully documented and has been exposed via the
wolf from function repository so if you take any one of these functions like say you know admd
composition and that's conveniently opened in the long browser but if I take this over here
okay so you can see okay so you know all these all these core functions are documented like this
you've got you know specifications of syntax there's a bunch of sort of internal you know
implementation details of the underlying mathematical formalism you know so for the
particular case of the admd composition we have details of like you know what what gauge
conditions do we do we support how are we doing the you know the canonical decomposition of the
metric what assumptions do we make about metric signature and so on you know here's for instance
a list of some of our inbuilt we you know a lot of these functions have inbuilt libraries of things
like known spacetime geometries or you know known stress energy distributions and so on so this is
some documentation about some of the inbuilt metrics that we support yeah here's a list of the
properties of that function so you know here are over here we've got a bunch of the you know a bunch
of the the slicing conditions for the laps function of the decomposition here are a bunch of the
coordinate conditions for the for the shift vector of the decomposition etc and then of course as
with any uh wolf and function repository documentation we have plenty of documentation
page we have plenty of examples trying to show the complete scope of this of this particular
function so several of our core functions have been documented and are exposed in this way
and so if you want to use any of them you can you should just be able to call
resource function and then the name like metric tensor and you know let's say metric tensor schwarz
chilled then without having to download anything without having to install anything your your
wolf and desktop kernels should just pull in that function and you'll be able to run that
as directly within your notebook so here we we just managed to produce a symbolic
representation of the schwarzschild metric and we'll we'll we'll dig into it a little bit more
about about all of that later and the one particular one that I want to highlight by the way
just because it has the most probably the most aesthetically appealing
documentation page is a discrete hyperservice decomposition this is the thing that produces
many of the kind of cool visualizations that if those of you who've been following some of the
papers that have been coming out of the wolf and physics project recently it was this function
and its various descendants that were used to produce a lot of those pictures so these are
these are kind of graph representations of space like hypersurfaces produced through
numerical evolution of some initial spatial metric and again we'll I'll walk you through
in more detail what exactly these means and what exactly these mean and how you can produce
pictures like this yourself however an important thing to note is that this is only a this is
really only a small part of the core functionality of gravitas and there's a lot more functionality
that is not yet been fully documented or is not yet fully exposed through the wolf and function
repository either because we just haven't got around to documenting it yet or because it's
still actively under development but if you want to use that stuff which I heartily recommend
you to do then you can download you can always download a kind of a the latest snapshot of the
gravitas build by going to github.com slash jonathan guard slash gravitas that will take
you to this github repository you'll see that internally this is just a large collection
of wolf and language package files if you download all of these run all of them then you
should be able to reproduce all of the examples that that I'm going to be showing you here today
so the examples that I'm going to be demoing will be a mixture of functions that are currently
exposed to the function repository and functions that have only been exposed so far through the
github repository of course eventually we would like to have all of them fully exposed through
through wfr but this is a a fairly large framework and it's still under active development I mean
it's right now it's it's about I think well at least last time I checked which was a few weeks
ago it was about 25 000 lines of symbolic wolf and language code and it's constantly growing
and we currently only support a small fraction of the things that I would eventually like us to
be able to support okay so before I show some examples let me just first explain you know what
is this framework what is it meant to do why does it exist why did we bother to build it etc so
you may know already that if you want to do numerical general relativity there are already
plenty of frameworks out there there's the open source Einstein toolkit there's part of that which
is the cactus framework there are things that have been built on top of cactus like the whiskey
code and so on and there are also open source libraries like like gr chombo and all of these
things allow you to effectively solve initial value formulations of the Einstein field equations
and do numerical evolutions of spacetimes involving say binary black hole systems or whatever
so you might think something like gravitas is not really not really required but one thing to
know about the workflow of these things is that uh you know typically okay so if you want to build a
numerical general relativity code uh very often the 40 the hyperbolic partial differential equations
that you're solving have many tens or hundreds or even thousands of terms in them and you know
it used to be that people would kind of code all of those in by hand in some low level language
like c or c plus plus but of course that became uh that very quickly becomes essentially intractable
and you introduce all kinds of bugs and so these days the the state of the artist used
automatic code generation so typically what you do is you input the equations you want to solve in
some in some kind of high level Einstein tensor notation form uh say uh in in in the Wolfram
language uh and then you use a framework like crank that then takes that abstract representation
of the equations and goes and automatically synthesizes a bunch of c plus plus code um that
you can then plug into a framework like cactus or whiskey then you run that numerical simulation
that produces some some some data files then you take those data files and you plug those into
another piece of software which is responsible for analyzing the data you know visualizing the
space like hypersurfaces uh you know detecting event horizons extracting gravitational wave data
whatever it is that you want to do so you end up having to kind of stitch together uh in many
cases maybe four or five quite complicated pieces of code if you want to do even a fairly basic
numerical GR simulation so and very often this is kind of beyond the scope of what what the
average user is is really prepared to do um and so one of the core features of one of the core
design principles of gravitas um is that uh you know what we're trying to do is have a general
relativity framework where you can do all of that stuff you can you can define the initial
equations you can define the the the metric splitting you can do all the you know coordinate
conditions gauge conditions all that stuff uh you know define the initial space like hypersurface
run the simulation with all the fancy you know background code synthesis and automatic optimization
so on get the results back analyze the results visualize them you know extract your gravitational
wave profiles etc all without exiting your notebook you should be able to do all of those
things from within a single notebook that's one of the big design features okay another question
you might have is well you know there are already lots of frameworks out there for doing computational
kind of tensor calculus of the kind that's that's relevant for general relativity so in the case
of the wolfman language there are things like exact which is a very general very powerful
sort of tensor calculus uh framework uh that is mostly written in kind of abstract index uh that
mostly allows you to manipulate tensor equations in kind of abstract index form um but there are
specific libraries in x-act like specifically x-coba that also allow you to do kind of coordinate
specific uh you know component computations in a fairly general way as well and so you might say
well you know what what why bother building something like uh is that something like gravitas
of all these tensor calculus libraries already accessed well again uh another point is that
we're not really trying to replace these things i mean if you want to do general purpose tensor
calculus you know go use x-act you know the general the wolfman language's general relativity
framework is not going to replace any of that uh but the the the point is um what we're trying to do
is we have support for only the kind of the particular kinds of tensor calculus operations
that are relevant for doing computational general relativity and the reason we've
re-implemented that is as i say one of the design features of gravitas is that uh we're trying to
set things up in a way that doesn't care whether the space time the underlying space time you're
dealing with is continuous or discrete and so we need to have representations of things like
uh you know affine connections and curvature tensors and so on that work equally well on smooth
romanian or pseudo romanian manifolds and on course hypergraphs and causal graphs and so that
necessarily that inevitably requires a certain amount of re-implementation of kind of core
functionality so we're not trying to to compete with a with any kind of general purpose tensor
calculus framework but nevertheless we do have uh inbuilt tensor calculus functionality for you
know at least doing the basic things right you know uh covariant derivatives covariant integrals
index contractions index manipulation all that sort of basic stuff but again uh just like with
many functions of the wolfman language we try to do that in a way that is maximally automated
so that you as the end user you know you don't have to worry about details of index juggling
or calculating christoffal symbols or whatever unless you absolutely want to we try to handle
that behind the scenes wherever possible as I say this is really only possible to a great extent
because of uh because of functionality and algorithms and and scientific ideas that have
arisen from the from the physics project and again I won't get into that now because I've
already yanked for too long but uh you know maybe towards the end if people are interested we can
talk a little bit about the about the sort of research background of this uh let me also just
show some nice pictures I'll try and reproduce at least some of some things like this in in the
course of this talk but you know these are fairly high resolution or relatively high resolution
simulations that take a little bit longer to run but here are examples of things like
here's a a collision of two of two schwarzschild black holes or I guess more generally of any
of any compact binary system described by the schwarzschild metric here's an example of a
gravitational collapse of a of an idealized scale of fields down to a schwarzschild black hole
and so these are all numerical simulations over hypergraphs that have been produced
using this functionality and again I one thing I want to try to convey uh today is is how you
can go about reproducing things like this yourself so okay let's start with the beginning
so uh the basic one of the you know arguably the basic object in in in this general relativity
framework is is a metric tensor so if we if we just call metric tensor with no arguments you'll see
a list of inbuilt metric tensors um that that we support so so uh so the gravitas framework has a
library that right now is still a little bit small but we're trying to actively grow it
but it contains a library of kind of of of pre-packaged spacetime geometries metric tensors
and things as well as stress energy distributions and that you can put on top of those spacetimes
and coordinate conditions that you can apply to them so here's a list of the at least the basic
metric tensors that we support right now so if we take one of these like I mean I okay up here I
took the schwarzschild metric let's use that in this example um so if I say properties we can see
all the various things that we can do with that metric tensor so perhaps the most basic thing we
can do is just display it as a matrix so by default we we uh we define we have our metric
tensor in covariant form um so covariant q this is this is a this is effectively telling us that
both of its indices are currently lowered um so if I say symbol you can see we've got g lower mu new
if I took this thing and I instead I said false false um this would represent the uh this would
give us the metric tensor in contravariant form and so you can now see the the the the mu new
indices have gone uh as upper indices so contravariant q uh that would now return true uh and
of course if I if I said like true false or something I would get something in mixed index form
which if I reduced it we'll just reduce to the identity matrix because it's um
because this is a metric tensor um so I I'll talk a little bit about more about index juggling in
just a moment but I wanted to show that uh show that first of all so uh so we're starting off with
with a covariant right so we're representing this metric tensor as a covariant matrix i.e a
matrix in which all components transform uh covariantly under arbitrary transformations of
coordinates um we could also choose to represent this say in a line element form uh so you here
you can see so this is our spacetime line element with with respect to the coordinates r, t, theta,
and uh and phi uh so if I if I say coordinates you can see here's here's the default choice of
coordinates for the Schwarzschild metric um if I say coordinate one forms
you can see here's here's the list of differential one forms that are being
used in this representation of the line element uh what else could we do we could do something like
in it so the so the line element effectively is the thing that allows us to measure distances
we could also say something like volume form and this will give us the a representation of the
of the function that allows us to measure uh volumes um if I say reduced volume form though
you'll notice this will eventually just this effectively just reduces to the Minkowski in
form of the of the volume element this is represent this is effectively a byproduct of the fact that
the Schwarzschild metric is Ricci flat and we'll we'll get on to that in in a minute um but okay so
uh what else could we do with with something like this or what else is worth saying okay so maybe
it's worth just explaining a little bit about the summary box so you can see here we've got a
list of the spacetime coordinates where we're using we we can see that our metric tensor is symmetric
all metric tensors by default are symmetric although in principle we do have support for
for non-symmetric metrics and so we we can support things like Einstein Cartian gravity
non-zero spin tensors torsion metrics contortion tensors all that kind of stuff maybe if we have
time I'll get on to some of that a bit later um but uh okay hang on sorry I've got a message saying
can we increase our notebook view from 100 to 125 percent oh yes sorry sorry sorry yes uh
uh let's try that maybe that's a little bit better um
okay yes please uh if if uh if anything's not not not directly visible uh yeah just just uh let me
know um okay so um right what was I saying yes okay so if we now take this thing uh what else
can we do so we so we we we looked at the line element we looked at uh uh volume form um we can
okay yeah sorry I was I was walking through you through the summary box so uh you can see here
it says signature indeterminate so what that means is that uh that the framework is not yet readily
able to tell whether this metric tensor corresponds to a romanian or pseudo romanian or or lorenzian
metric and the reason for that is because it's you know it's obviously represented in terms of
these symbolic coordinates and it doesn't know yet what the restrictions on those coordinate values
are if we gave it something like say the minkowski metric the metric tensor minkowski
uh then it would then it knows that the signature of this is lorenzian because it can compute it can
directly compute its eigenvalues or if I said you if I take the euclidean metric uh the three
dimensional euclidean metric it's going to know that it signatures romanian but in the case of
schwarzschild it can't it can't know that but we can always ask so so I mean if we say lorenzian q
it will say indeterminate but we can always ask something like lorenzian conditions and it will
return us a list of the minimal conditions that are necessary on the on the spacetime coordinates
necessary to guarantee that the schwarzschild metric is over the underlying manifold has
has lorenzian signature equivalently we could say something like romanian conditions and it would
give us in correspondingly the the the minimal set of coordinate conditions necessary to guarantee
the metric is romanian and so you see it's it's exactly the same as the lorenzian case except
that this this inequality sign is the the other way around so really all that's doing is it's
figuring out what conditions would need to be true in order for the you know for the eigenvalues to
be all positive or all negative or you know one negative and the rest positive or what have you
other things I mean there are plenty of things we can do with metric tensors we can take say you
know we could say something like uh let's let's take an example what would be a good thing to do
I don't know time like q or something and so this will return a pure function that if you if we take
this pure function we apply it to any spacetime vector it will return a boolean so that tells us
effectively whether you know whether that vector is a time like vector or you know we can have
corresponding um functions that tell us whether it's a space like vector or a light like vector
we can say something like length pure function and it will synthesize a function which again we
we apply that to a spacetime vector and it will tell us the length of that spacetime vector within
the minkowski or sorry within the schwarzschild metric I could say angle pure function and it
will do the same thing except this time it's this is now a two argument pure function you can see
there are two slots hash one and hash two so we give it two uh spacetime vectors and it will compute
the angle between them uh within within the schwarzschild geometry and so on so it's you
we can do a bunch of kind of automated wolfram language code generation that's you know so so
that if you know you you you request back a piece of uh of synthesized symbolic symbolic
wolfram language code uh that allows you to compute these various things so if we change
this to something a bit more complicated like say the Kerr metric okay so with the Kerr metric
by show it's matrix representation so now you can see it depends not just on this mass parameter
m but also on this kind of symbolic angular momentum type parameter j so I should clarify
for those of you who don't know you know the schwarzschild metric kind of broadly represents a
sort of static non-rotating spherically symmetric body like a like a non-rotating black hole uh
the Kerr metric represents a a spinning black hole with with with some symbolic angular momentum
but we can do exactly the same things we can say line element we get a slightly more complicated
thing or time like q uh or length pure function uh angle pure function so we can make these we can
make these kind of as as as complicated as we like and grammatize can can still handle those
so here I'm just using inbuilt metrics but it's important to note of course that we can just
take you know we could we could put any any any uh any uh symbolic metric that we liked and here
we could just give it any any matrix um I don't know why I've opted to just type in a random
matrix by hand rather than generating one symbolically but uh so be it that's what I've done okay so
then we get some some matrix and in this particular oh I wasn't even planning for that to be the case
but apparently this is I accidentally input a lorenzian metric uh so that's nice um anyway
that's probably enough about metric tensor for now so I just wanted to give you an indication
because you know the if you like the the core design of metric tensor tells you a lot about the
core design of a bunch of this a bunch of the other functionality that's that's within the
framework because uh essentially all the other stuff in within the gravitas framework is really
just a metric tensor past some additional wrapping so uh so there are various things that we can
immediately do with a metric tensor so we could for instance we could compute uh something like
the richi tensor so um let's let's say just okay right I'm going to do this even though I know
it's going to be super boring so if I say richi tensor metric okay so this will compute a symbolic
richi tensor so if I just say matrix representation of this we'll get some some complicated thing
but of course the schwarzschild metric is richi flat so we know that if I say reduced matrix
representation this is just going to reduce to the zero matrix um so when I say uh that when I input
reduced in one of these properties what that's doing is it's taking some symbolic in this case
some symbolic tensor object and it's effectively modding out by all by all known tensor equivalences
so uh because gravitas has a kind of inbuilt tensor algebra and tensor calculus framework
it's able to keep track of all the kind of known equivalences between tens between abstract tensor
expressions that you kind of accumulate as you do successively more more complicated calculations
so in this particular case uh it managed to reduce that thing down to just a zero matrix
and we can confirm that by saying richi flat q and it will say true right so so it's telling us
that this particular metric tensor corresponds to a richi flat spacetime but if I used a different
metric tensor like say the flrw metric so the flrw metric of course the freedman le metre
roberton walker metric being the metric for a homogeneous and isotropic uh sort of uniformly
expanding or uniformly contracting universe with some scale factor a and some some discrete curvature
k if I take this and I compute its richi tensor um then even in reduced form this thing is
generically non-zero so if I now say richi flat q it will say false of course I can always say
richi flat conditions and it will tell me the the list of conditions that would need to be
satisfied by our curvature parameter and our sorry by our scale factor and our curvature
parameter in order for the flrw to be a richi flat solution um similarly I compute the richi scalar um
I get actually what that's called if it's scalar curvature or richi scalar I think it's richi
scalar uh yes it is so if I say richi scalar or reduced richi scalar
for the flrw metric uh you know I could equivalently say something like um vanishing
richi scalar q so this is telling us so this so the the richi scalar does not vanish for the
for the flrw metric generically but there is a condition in which it does vanish and that condition
is this um so uh the richi scalar by the way is you know what what happens if you you take the
richi tensor which is itself a contraction of the of the reman tensor the full curvature tensor
uh and then you just so you contract the reman tensor along its first and third indices
and then you contract the the the richi tensor so you just effectively take a trace and that gives
you the richi scalar so if we wanted to we could see in detail exactly how this thing was computed
because we can we have all the pieces necessary to do that uh within the framework so if I say
christoffel symbols metric so this will compute the christoffel symbols for in this case the flrw
metric so if I say uh so this is not this is a rank three object it's not actually a tensor it's a
it's uh it's it's more like a sort of it's a higher dimensional array that sort of acts a bit
like a tensor under linear coordinate transformations but not under general diffeomorphism transformations
but anyway so this these christoffel symbols represent the components of the affine connection
for this for the flrw metric so if you like intuitively what they're telling you is you
know how do the how do the basis vectors change as they move from point to point along a manifold
that's that's the that satisfies the flrw metric um and so this is this is effectively
been computed by by calculating certain partial derivatives of the metric tensor by the way another
thing to note is and this will become important for the for the numerical computations I'm going to
do later by default gravitas will try to evaluate all of these complicated partial derivatives and so
on uh analytically wherever it can there may be cases where it can't do that um so uh so in those
particular cases if we say uh sorry why did I call this this was why did I call this metric
this is ridiculous sorry yeah let's call that christoffel symbols that's a good name
um so if I now say christoffel symbols if I instead of saying tensor representation or for
that matter reduce tensor representation which will again try and simplify this expression
wherever it can by by applying tensor by applying possible algebraic or tensor equivalences I can
instead say symbolic tensor representation and in that case it will return us a purely symbolic form
where you can see all we've got all of these symbolic inactivated partial derivative operators
with respect to each of the spacetime coordinates so this is just returning us purely symbolically
what what form will the christoffel symbol take uh for for this particular metric tensor and you
know so in cases where for instance that these partial derivatives are actually not analytically
tractable uh then you know we can we can just we can still compute something in finite time by just
saying give me the symbolic representation and then the point is this is then something which we
can potentially numerically approximate using methods like nd solve and we'll get on to that in
in a little while um uh oh actually one thing that's that's worth saying now that we've got so
this christoffel symbol thing is a is obviously a higher rank object so if I take christ so in
particular we can compute its index contractions so by by default if I say symbol you'll see that
the christoffel symbol is is by default computed with with the first index raised and the last
two indices lowered although of course we can change that in a moment as I'll show you so that
means if I say index contractions uh let's to reduce index contractions okay so that will
simplify it a little bit so you can see with with these three indices configured in that way there
are two possible contractions of the of the christoffel symbols we can contract along the first uh
index uh sorry the first and second indices so you can see there's a repeated sigma here so we're
using effectively Einstein summation convention uh so so we get this kind of we get this uh
what would it be this is a covector object um or we can contract between the first and third
indices so we get six so this is sigma sigma nu this is sigma mu sigma and we get this different
covector object uh although actually in this particular case not very different it's exactly
the same um never mind uh this would not be true if we had if we had a more general kind of connection
that was not necessarily symmetric um but uh okay so uh but if we now took this thing so if I take
this this christoffel symbols object and I raise or lower some of its indices so if I said
christoffel symbols christoffel symbol let's take the old thing say christoffel symbols two is that
and then I'm going to say uh let's do true true true so uh these boolean flags are specifying whether
a given index is covariant or contravariant i i whether it's lowered or raised so true true true
means that all of these things are covariant you can see this is now tight covariant so if I say
christoffel symbols two symbol it will be that but if I now try and try and take index contractions
it's going to return an empty association because there's nothing to contract we can't contract two
covariant indices we can only contract covariant and a contravariant index so uh if I if I said
false true true then that would get that would take us back to the case we had before but I could
equally say I don't know true uh uh no what should I do I could do let's do false false true that's
a slightly different case uh and now we get a more complicated thing uh but okay so we get a
different set of index contractions now so now we're contracting you know sigma mu sigma versus
rho sigma sigma um and we get we get a different uh so in this case that those are going to be
whereas before those we contracted the thing we got uh covectors now we're going to be contracting
this thing and we're going to get ordinary vectors right because now now the the free index is the
one that's that's raised so uh I'm just the only reason I'm showing you this is to show how how sort
of symbolic how um uh these sort of symbolic tensor calculus operations are are handled within
the general relativity framework but as I say kind of the whole point of this framework is that for
the most part you don't really need to worry about this I mean but you know we've tried to design
everything in a sufficiently high level way that you know all the kind of standard things you would
want to do in general relativity you can do without having to worry about the internal details of
index raising index lowering and and all that kind of nasty stuff so although in particular okay so if
we took uh so this was the Ricci tensor if we recall this is the Ricci tensor for the uh for
the um uh for the FLRW metric if we if we took this uh let's just check with that yeah that is
still working we could take this particular thing we could say something like covariant derivatives
uh and actually let's do reduced covariant derivatives to try and get them in the simplest
form and so here we'll get back an association of covariant derivatives of the Ricci tensor so
you can see this is the the covariant derivative with respect to time of RTT is this and and so on
so we so we get this complete association of all the all the different covariant derivatives
that can be computed of this particular tensor object and and you can see that a lot of them are
zero because this is a happens to be a diagonal matrix um but uh uh and and of course okay if we
took so this is this is with the Ricci tensor being in in covariant form if we did say true
false so we had it in in mixed index form we get a slightly different thing and if I now say that
you can see we get a different association with with different values of the covariant derivatives
because we've added and subtracted the different collection of Christoffel symbols and we
and done all that kind of all the sort of nasty raising and lowering operations that you would
need to do so so again the point is the gravitas kind of handles all this for you you don't need
to worry about about you know when are you adding a Christoffel symbol when you're subtracting one
or any of that stuff and as I said moreover for the most part you don't even need to be using
functions like reduced covariant derivatives because you know for all the kinds of things that you
would ordinarily want to take covariant derivatives like constructing Einstein equations or doing
numerical solutions uh you know the the framework will handle all of that for you so it's really only
for sort of certain power user types we expect to be uh that we expect them to be using these
functions like like you know for computing covariant derivatives and so on um okay so oh right I was
showing you how you know how we would go about computing the Ricci tensor from first principles
so once we've computed the Christoffel symbols we can then take derivatives of those uh and we
obtain the Riemann tensor so if I say a resource function Riemann tensor of our original metric
for the FLRW metric let's just call that Riemann but sorry Riemann equals that
I say tensor representation so this is now going to be this is an even higher rank object this is
a rank four tensor uh that we as we we've computed by by evaluating certain partial derivatives of
the Christoffel symbols for the uh for the FLRW metric so this is what the Riemann tensor looks
like for for FLRW um and uh so again we can do all this all the same things that I showed for
the things like the Christoffel symbols we compute its index contractions you know in this
case we're going to get more index contractions we've got three now because it's a rank four tensor
and if we if we say had if we had this in mixed index form like this uh so we had two oh this is
okay raising and lowering those indices is probably
resulting in something overly complicated okay there we go so we get a slightly different thing
if I now say Riemann index contractions okay now we get four index contractions we because
we've got two raised indices two lowered indices and we get these these things which are uh each
one of these is effectively a matrix that we you know a rank two matrix that we've obtained by by
contract by doing index contractions of this rank four tensor um and in the same way we could
just as we saw for the for the Ricci tensor and things we could say we could take any of the
any tensor expression uh with the exception of things like the exception of obviously silly
things like the metric tensor but any tensor expression represented in the framework you
can do index contractions you can take traces you can take over in derivatives you can do all
the kind of ordinary things you would expect to do within you know in the context of tensor
calculus and it will handle all of that uh you know all that stuff for you behind the scenes
wherever that makes sense so then once we've once we've got the Riemann tensor uh by by taking the
you know its index contraction between the first and third indices with the first index raised and
the third index lowered then we obtain the that that allows us to derive the Ricci tensor which is
of course the thing that then appears in the Einstein field equations uh the Ricci the the
significance of the Ricci tensor by the way being that uh it's it's essentially the thing that determines
the uh the volumes of of space time cones and it's and the Ricci scalar the thing that the
summons the volumes of uh of things like spatial balls uh relative to the corresponding volumes
that they would have been had the space been been flat so if we if we take say this this Ricci tensor
for FLW and I say something like volume form expansion what it will return is effectively
a Taylor expansion of the volume of a of a of a space time cone um uh represented in terms of the
corresponding of the volume of the corresponding cone mu so v is the is the volume of the of the
space time cone in the FLW geometry d you know mu is the volume of that space time cone uh in in the
corresponding Minkowski geometry and so this Taylor expansion is effectively the thing that's
defining the the discrepancy and this Taylor expansion uh is represented in terms of uh
terms that have come from the Ricci Ricci curvature tensor equivalently if I say uh something like
scalar volume expansion this will give me the corresponding uh uh uh uh uh Taylor expansion
for the case of an un not so here we're we're not talking about a a directed space time cone
we're talking about a sort of undirected uh spatial ball um so in so in this case so v epsilon
is going to be the volume of a ball of radius epsilon uh in in the in the FLW uh space time
mu epsilon is going to be the volume of a ball of radius epsilon in the corresponding Minkowski
space time and again this Taylor expansion is going to give us the discrepancy between the two
represented in terms of the Ricci scalar um so again the the framework allows us to compute all
of this stuff um if we want to I mean so so uh for instance uh we I know that if I say uh curvature
singularities uh so I you're right okay so so there there is there are certain coordinate
values where we know that the FLW metric is going to become the Ricci tensor for the FLW
metric is going to become singular incidentally this is in contrast to for instance if we take
if I say
Schwarzschild uh I say metric singularities you know so there there are certain coordinate values so
so r equals zero that's the kind of physical singularity r equals 2m that's the coordinate
singularity at the event horizon but of course the because the because that meant because the
Schwarzschild metric is Ricci flat those things don't persist uh if I take if I compute its Ricci
tensor and I try and find its curvature singularities those will not show up as curvature singularities
they will show up as curvature singularities for the Riemann tensor but they will not show up as
curvature singularities for the um uh for the for the Ricci tensor and in particular this particular
the specific thing will show up as a singularity for the Kretschmann scalar so if I take the the
Riemann tensor and I uh so unlike with the Ricci tensor where there's only one sort of uh scalar
quantity you know a curvature invariant that we can compute from the Ricci tensor there are three
curvature invariants that we can compute from the Riemann tensor uh I've spelled Kretschmann wrong
I think that's how you spell it so I can compute the Kretschmann scalar for the um this is me
computing the Kretschmann scalar for the Schwarzschild metric so the Kretschmann scalar is is that's
the thing that effectively quantifies you know because there's no Ricci curvature it's essentially
it's all vile curvature the Kretschmann scalar is the thing that effectively quantifies the
spacetime curvature for a black hole spacetime like like like the Schwarzschild spacetime uh okay
that's that's the that's not its simplest form if I said reduced Kretschmann scalar I would have
got something a little bit simpler but uh equally I could take um actually maybe maybe the Schwarzschild
metric is too complicated for this maybe I may not be able to do this in reasonable time let's
let's go back to doing it with the uh with the FLRW metric but so in addition to computing
say the Kretschmann scalar I could also compute something like Czern-Pontriagin scalar
or the Euler scalar um so the Czern-Pontriagin scalar this is uh related to you know for those of
you who know a bit of algebraic geometry or algebraic topology this is related to the theory
of characteristic classes and in particular the Czern class uh so specifically the if you took
the integral of the Czern-Pontriagin scalar over the spacetime that would give you a Czern
characteristic class it would effectively determine if you like the instanton number of that space
if you know about the if you know about gauge theory um and uh likewise with the Euler scalar
the the integral of the Euler scalar over that spacetime will effectively determine
the Euler characteristic of that space which is of course a kind of a a a homological invariant
so we can do all of these all these nice things uh I fear that this computation may be a little bit
beyond what I can do whilst simultaneously streaming so uh in the interest of not eating
up too much time let me abort that but I promise you those those do work if you give them sufficient
time um okay so I I'll I appreciate I'm getting a little bit lost in the kind of uh in in the
mathematical details here so let me just let's just blitz through and show you uh you know show
you the various functions and then move on to to some of the cool things that you can do so
once you've computed the Ricci tensor a natural thing to do is to compute the Einstein tensor
you take r mu nu you subtract one half uh r times times the metric um and then that gives you the
Einstein tensor so if we say matrix representation for that so this is the Einstein tensor for us
to reduce matrix representation let's get this is now the Einstein tensor for the FLW metric
um and if I were to say I don't know uh equivalently I could do reduced covariant derivatives
okay so this is what happened when we compute covariant derivatives of the Einstein tensor for
for the FLW metric um but you know of course uh physically the significance or mathematically
the significance of the Einstein tensor is that it's used to define Einstein manifolds
but physically it's because it's exactly the thing that appears in the Einstein field equations
the governing equations for general relativity so uh so one thing you could do is given any metric
if I if I take um I should I should be clear as well by the way I mean so right now we're
using the Schwarzschild metric uh things in in Schwarzschild coordinates or you know if I if I
take the the Kerr metric like this we're representing Kerr metric in Kerr uh in sorry in uh in Boyer-Lindquist
coordinates instead so if I if I take its extension like the Kerr Newman metric so the Kerr
Newman metric being the extension for uh of these of the metric for a spinning back hole to the case
where that where where you have a spinning back hole that's also charged and so all these other
metrics like Reissner Nordstrom and Schwarzschild and Kerr uh effectively can be derived to special
cases of the Kerr Newman metric but so this is all represented in Boyer-Lindquist coordinates by
default when I if I take the Schwarzschild metric or the Reissner Nordstrom metric
this is the Reissner Nordstrom metric for a static uh non-rotating but charged black hole
with electric charge q um but in all these cases you know like for Schwarzschild or Reissner Nordstrom
we're using Schwarzschild coordinates by default but there's no particular reason why we have to
use Schwarzschild coordinates and and the the the general relativity framework supports uh
sort of effectively uh transformations between arbitrary coordinate systems so I could take
the Schwarzschild metric and instead I could say something like isotropic Schwarzschild
and uh what it's going to do so now it's this is the this is the same metric it's the still the
Schwarzschild metric but now it's represented in this kind of quasi-cartesian coordinate system
with x y and z um and uh and and and the the coordinate system is so chosen as to make the
as to make the metric isotropic in other words to make the to make the light cones all appear perfectly
round um uh equivalently I could take I don't know Gulstrand-Panleve coordinates uh sorry Gulstrand
Panleve coordinates or something and so these are these are the coordinates as would be seen
from a kind of distant uh free falling observer towards the black hole or equally I could take
say Eddington Finkelstein and these would be the coordinates as seen from a you know from an
observer that was sort of falling that was capable of falling past the the the event horizon so an
observer that's falling with the gravitational with the gravitational field rather than in the
case of Schwarzschild which is the which is the the coordinate system as seen by an observer that's
kind of infinitely far away from the black hole um so this these pluses are minus it indicate that
we've got both ingoing and outgoing components I think we can say ingoing Eddington Finkelstein
and that will that will take the positive case and if I say outgoing Eddington Finkelstein
that will give us the negative case anyway so all I'm trying to illustrate here is that we can do
you know we don't have to represent the Schwarzschild metric just in Schwarzschild coordinates we
can represent it in any coordinate system that we like but anyway if we if we take the Schwarzschild
metric represented in Schwarzschild coordinates and we we want to ask okay do how do we know that
this is a valid solution to the Einstein field equations well of course one thing we could do
is we could just go check we could we could we could compute the Einstein tensor directly and
check whether its components are equal to zero but another thing we can do is just say solve
vacuum Einstein equations of that metric and what it will do is it will return what this
function will do is it will return a symbolic vacuum solution object that tells us that in
this case it's not a solution hang on what have we done ah I know what we've done
let's do that yes okay so we can see that not only is this a valid solution but it's also
an exact solution what that means is that that gravitas was able to to verify that the Schwarzschild
metric solves the the vacuum form of the Einstein field equations exactly without the need for any
approximations or additional assumptions and so I had to put in a zero here to specify that we
want to solve it with zero cosmological constant if we have a non-zero cosmological constant then
then the Schwarzschild metric is not a valid solution to the Einstein equations um and whereas
if I were to take if I instead were to replace this with FLRW again uh so now this is still a
solution but it's no longer an exact solution and the reason it's not an exact solution is because
the FLRW metric only solves the Einstein equations under a very restrictive set of assumptions we
can compute those assumptions here by by by saying field by requesting field equations and it will
return the minimal set of constraints that are needed on the curvature parameter and on the
scale factor in order for the FLRW metric to constitute a valid solution to the Einstein
field equations in the vacuum case if I if I got rid of this zero and allowed it instead to be a
symbolic cosmological constant now the field equations are going to be uh and are going to
involve this this symbolic lambda there's the you know the cosmological constant if I want to do I
could see uh the the precise that the full form of the Einstein equations that that gravitas is
attempting to solve and then if I say reduced Einstein equations it will it will it will display
for me effectively the the fully reduced form of the vacuum Einstein field equation so you can
several of these are reduced to true but several of them have not and the and the and the ones that
have not when once we've modded out for kind of symmetries and redundancies those are the
things which become the field equations those are the things which become uh the assumptions
that have to be made in order for FLRW to constitute a valid solution to uh to to the
vacuum Einstein equations so we can take any metric that we like and and and check whether
it constitutes a you know a valid solution to Einstein's equations so we if I did the same
thing with the Kerr metric uh it might take a little bit more effort but we should eventually
deduce that the Kerr metric is also a valid solution to the vacuum equations oh sorry I
should actually again give this a zero uh let's see whether this runs it's remarkable how much
slower the notebook is when I've got zoom and livestream stuff running in the background I'm
not even the person livestream but so but anyway so you can see again we this has given us an exact
solution but it takes a moment to validate that it's an exact solution but in this particular case
the the uh forget it the analytic form of the Einstein equations that it needed to solve
is significantly more complicated you can see the waffle language is not going to to choose to
display all that all that complexity by default but anyway so so that's what that's what it's
solving internally um so that you know that's for the case of the vacuum Einstein equations
but you know of course we could take uh we could also consider space times that contain
energy distributions so if I take if I say stress energy tensor bracket bracket
then I can I'll get a list of the of the built-in stress energy distributions that we support
again there's this plans to dramatically increase this library but you can see that we all we we
naturally have support for things like perfect relativistic fluids relativistic dust relativistic
radiation electromagnetic fields are being the Einstein Maxwell equations scale of fields
things like that so if I take something like the perfect fluid so by default this is going to give
me the stress energy tensor for a perfect fluid distribution in minkowski space so this is a
perfect fluid with uh with symbolic pressure p symbolic energy density u and relativistic
four velocity given by u1 u2 u3 u4 um but uh so this is for the particular case of the minkowski
metric which is by default but if I gave it a another metric so if I gave it something like
schwarzschild then I could solve uh then I then I can consider a perfect what a perfect fluid would do
when embedded in a schwarzschild geometry so so for the case of schwarzschild okay let's
reduce that a little bit you can see the the the stress energy tensor is a little bit more
complicated for a schwarzschild geometry and and various terms now have dependence on on the say
the on the mass of the black hole or the or the radial coordinate and in particular we could say
something like you know stress energy tensor what is the energy density of the stress energy
distribution um what is the reduced energy density when we mod out by tensor equivalences
or you know what is the uh what is the reduced momentum density uh the the spatial momentum
or what is the uh I don't know what is the what is the reduced pressure of this fluid something
um so this is and so all this is doing is it's computing you know for a perfect relativistic
fluid embedded in a schwarzschild geometry you know what are all these various continuum parameters
what is its energy density what is its pressure how does it depend on the mass of the black hole
your radial distance from the black hole uh all of that kind of stuff uh you know we can compute
if we want if we want to see we can compute the Cauchy stress tensor for this um we can compute
its shear stress tensor so reduced shear stress tensor that's a surprise that's that's a surprisingly
long time uh let's see okay I guess because it's having to subtract out uh weird traces and things
but okay so that's what the that's what the Cauchy though the generalization of the Cauchy
stress tensor looks like for a perfect relativistic fluid around a static black hole uh or I could say
you know continuity equations and so what it will do is it will compute the the covariant divergence
of the stress energy tensor in upper index form uh and it will figure out uh the the conditions
that that are imposed when we say that that covariant divergence has to vanish which is
effectively the which is a what which is precisely the statement of of conservation of energy and
momentum in the context of general relativity now of course we know in general relativity the
reason why that's why why these continuity equations have to hold i.e why the covariant
divergence of the stress energy tensor has to vanish is because the covariant divergence of the
of the Einstein tensor vanishes as a consequence of the Bianchi identities and so again we can
we can go and if we want to do we could validate any of that so if we if we talk to the Einstein
tensor here uh I think this is we computed over here the Einstein tensor for the um for the FLRW
metric if I want to I could say Bianchi identities and it would give me a full list of the Bianchi
identities for the for the Einstein tensor and you know if we if we wished we could just say
full simplify and of course we determined that they're true that you know that all these Bianchi
identities are true we could we could confirm that for the for the for the case of the Einstein
tensor for the Ricci tensor we can even take the full form of the Bianchi identities for that so
these are all the and when we compute these for the Einstein tensor or the Ricci tensor this is
giving us the contract of the anti-identities if we do it for the for the Riemann tensor it's
obviously going to give us the the the full uh the full Bianchi identities say the anti-identities
for this, we get, you can see it's a 1,024 different equations, but if I say full simplify on that,
and I wait for a little bit, it will confirm that all of these equations are indeed satisfied,
as indeed they have to be axiomatically as a kind of theorem of differential geometry
for any Riemann tensor that's produced from a metric in this way.
So anyway, so although the Bianchi identities are a kind of trivial theorem in differential
geometry, when they're combined with the Einstein field equations, they become a
non-trivial observation about physics, namely the statement that the covariant divergence of
stress energy vanishes, and therefore the energy momentum are conserved. So anyway, so this allows
us to compute a stress energy tensor for an arbitrary, you know, for a sort of arbitrary
mass distribution. So actually, let's do this, let's do a perfect fluid, but in the FLRW metric,
because now what I want to do, so of course the, although the Schwarzschild equations,
the Schwarzschild metric is a vacuum metric, the FLRW metric is not by nature a vacuum metric,
it's really, it's most naturally considered as a perfect fluid metric, at least in the
context of cosmology. So if you combine the FLRW metric with the equations for a perfect
relativistic fluid, you effectively get the general form of the Friedmann equations for
an expanding universe. So if I say now solve, not vacuum Einstein equations, but solve Einstein
equations, and I give it this stress energy tensor, and I say solution, then it's going to say,
okay, so we, so it's deduced that this is indeed a valid solution, it's deduced that the solution
is exact. But it's, sorry, it's deduced that the solution is not exact, and the reason it's not
exact is because it requires the assumption of an additional set of field equations, which you can
see here, so I've solved the full form of the Einstein equations involving, including cosmological
constant here. So you can see here, we've got a list of field equations, effectively, in this case,
second order ordinary differential equations for the scale parameter A, that have ended up
involving the cosmological constant, but also the pressure and the density and the form momentum
of this relativistic fluid. And so in the general form, these are exactly the Friedmann equations
for relativistic cosmology that we've just derived kind of directly from, by solving Einstein
field equations. So we can do this for any stress energy distribution in any metric,
and we can effectively derive effective field equations. So if we took this thing, in addition
to saying, in addition to being able to say something like Einstein equations, and see,
and seeing what's the completeness of Einstein equations that it solved, we can also say something
like continuity equations, and we can see what's the complete set of continuity equations that
it had to solve in order to guarantee compatibility with the Bianchi identities.
And once we've got a stress energy distribution, you know, there are obviously various other things
that we might want to do with it, like, okay, I'm not going to, we probably don't have them,
hang on, this is for that. Or we don't have time to cover all this in full detail, but if I say,
you know, angular momentum density tensor, and I give it the stress energy tensor,
then I'll get an angular momentum density about some symbolic. So this is a covariant rank 3 tensor,
if I say angular momentum density, you know, tensor representation, you can see this
covariant rank 3 tensor in matrix form. So here it's computed the angular momentum density
about the four vector x1, x2, x3, x4, for the case of a perfect fluid in an FLRW geometry.
And so that gives us the angular momentum density, which is rank 3, but then by integrating that
angular momentum density around the boundary of our spacetime, I get the full angular momentum
tensor. So I could say angular momentum equals angular momentum tensor of stress energy.
That's a representation matrix form. Oh, sorry. No, I'm a matrix representation,
like that. So, okay, now, and this is going to give us a rank two,
contravariant tensor, whose components you can see have been determined by integrating
with respect to the spacetime coordinates tr theta phi over the boundary d omega of our spacetime.
So we've just taken these, we've effectively taken the angular momentum density tensor,
and we've integrated out with respect to one of the tensor components.
And that gives us the angular momentum. And there are, you know, there are lots of other things
that you might want to compute for any arbitrary spacetime. And we effectively either currently
support them or very soon plan to support them. Like, you know, if you want to calculate
gravitational wave data or something, you could take the, you could take the vial tensor for an
arbitrary metric. So the vial tensor for the FLRW metric should vanish. If this is,
I forget which one metric is now, I think this is FLRW. Yes. So if we say reduced, this is a rank,
again, another rank for tensor, if I say reduced tensor representation, this should come out as
all zeros because the, because the FLRW solution is, is, is conformally flat. But if I did this
for something like Schwarzschild, we should get something else. We should get, we should actually
get nonzero components to the vial tensor, which we can, which we can confirm. Okay, so, so yeah,
we've now got a, we've got a form of the vial tensor that now has, that now has some nonzero
components. And so it's worth confirming, I mean, I, let me, I'm going to stop to, I'm realizing
we're coming up to the top of the hour. And I still haven't got on to actually the most exciting
stuff, which is all the numerics. I've just been talking about symbolic so far. But so,
suffice it to say, there's a lot more that's, that's going on with the kind of symbolic and
analytic side that I haven't shown you. Again, if people have questions about specific things,
or, or, you know, questions about whether, whether there are certain things this framework can and
can't do, please let me know the chances are, as I say, either it can or it very soon will be able to
do, to do those things. But so what one important thing to notice that is actually quite a, there's
a bunch of, in many cases, quite sophisticated algorithmic stuff that's going on behind the
scenes. So for instance, when we manipulate one of these higher rank tensors, like the Riemann
tensor or the vial tensor, being able to do that in an efficient way and keeping track of all the
different algebraic equivalences that have to be kept track of in order to be able to do
the kinds of reductions that I've been showing you actually involves some pretty sophisticated
algorithms. So for instance, we make extensive use of the Wolfram languages in built implementation
of the Butler-Portugal algorithm for tensor canonicalization with respect to slot symmetries.
So effectively what we're doing is what that algorithm allows you to do is to take the basic
problem of tensor canonicalization of a higher rank tensor, like the Riemann tensor, and convert it
into a problem of computational group theory, which is effectively, you know, computing canonical
forms with respect to a group that's defined by the symmetries of the slots of that tensor.
So again, the part of the part of the point of this framework is that it's trying to it's trying
to to insulate you wherever you wherever it can from all that from all that kind of complexity.
So you as the end user don't really have to worry about it. There are plenty of other things that
I could show like, you know, support for electromagnetic fields. So if I if I say electromagnetic tensor,
Schwarzschild or something, I'm overusing let's do Reissner Nordstrom, I'm overusing the Schwarzschild
metric. If I say electromagnetic tensor Reissner Nordstrom, then I get a symbolic electromagnetic
field tensor in covariant form, on which I can then for it. So this is the so this is the
electromagnetic tensor with with, you know, scalar electric potential phi and vector magnetic
potential a1, a2, a3. And so from this, I compute say the electromagnetic stress energy tensor,
let's say electromagnetic stress energy tensor. So that's the that's the stress energy tensor
corresponding to us to a vacuum space time, consisting only of that electromagnetic field,
I could say, you know, electric field, and I get the I get the form of the electric field
components, I could say magnetic field. And I get the form of the magnetic field, I could say,
you know, homogeneous Maxwell equations. Okay, those are all satisfied trivially,
I could say inhomogeneous Maxwell equations. These are not satisfied so trivially, I could
compute the charge conservation equations, all that kind of stuff. So all the things I'm showing
here for things like the Einstein equations, we also have we are also we also have support for
things like the Einstein for the full Einstein Maxwell equations, thanks to some of the functionality
in stress energy tensor. It means that means that we can do not only general relativistic hydrodynamics
using relativistic Euler equations, but also general relativistic magneto hydrodynamics in
both ideal and resistive cases involving kind of arbitrary electromagnetic fields. So again,
I'm not I don't want to show too much more of the symbolic side. But what I'm trying to illustrate
to you is that that the symbolic side is pretty powerful is quite general. And there's, as I say,
if there are particular functions that you want to try and do symbolically involving
general relativity or its various extensions, there's a decent chance that the symbolic
components of the framework either can do those things, or soon we'll be able to do those things.
Okay, so with that, maybe I should move on and talk a little bit about the numeric side,
because that's that's really the the exciting part. I realize we're coming up to the to the
top of the hour. So ostensibly, we only have a half an hour left, or I think we I think we
can go a little bit beyond that, if necessary, and if people want want to do so. So, oh, sorry,
before I forget, let's let's, while I start a fresh notebook, let's go back up to 150%.
Um, so, if I say resource function, discrete hyper surface decomposition, okay, so,
let me start by, let's construct a Schwarzschild metric, let's construct a static,
uncharged, non rotating black hole, but rather than having its mass be symbolic,
which is ordinarily what we do, right? So, you know, ordinarily,
the Schwarzschild metric, we just let we just have this this purely symbolic mass parameter
m, rather than having its mass be symbolic, let me make it let me give it a mass, you know,
an actual numerical mass, let's give it a mass of one. So that then our metric simplifies to this.
And also, let me let me modify the coordinates, so that I instead of having these kind of
formal symbol coordinates, let me actually use t r a one and a two as the as the coordinate
system for the for this metric. And so now what I can do is I can say I can request a
discrete hyper surface decomposition. So I can give it, let's call this thing decomposition.
I can say metric t zero once I was I'm saying evolve this this space time metric from from
type between time zero and time one. Let's let's do this simulation in the coordinate patch given
by the radial coordinate being between zero and four, the angular coordinate between being
between minus pi and pi. Let's do 200. 1.5. Okay. And let me let me start this running.
And then I'll explain in a moment what all of this means.
So if I say and I can also do polar graph. So what I'm effectively doing here is so ordinarily
the Einstein equations, you know, our system of, you know, in the four dimensional case,
there are a system of 10 independent partial differential equations of mixed hyperbolic elliptic
type that are defined over the entirety of space time. But ordinarily, when we want to think about
evolution, we, you know, the evolution of some relativistic system, we want to think about it
as evolving from kind of one space like hyper surface to another space like hyper surface. In
other words, we want to think of general relativity as being an initial value problem. And so to do
that, we need to find some way of taking the space time and decomposing it into space like hyper
surfaces in such a way that the Einstein equations effectively define how one space like hyper surface
evolves to the next space like hyper surface. And so to do that numerically, we use this function
that's essentially implementing a hyper graph generalization of adaptive mesh refinement. So
here you can see after, you know, after that evolution from time t zero to time t one, we've
obtained this space like hyper surface. This is represent this space like hyper surface is
effectively representing the discrete geometry of what the Schwarzschild metric looks like when we
take a spatial slice at time t equals one. Now, and this is the this is that same geometry, but
but without the coordinate information. So we're just looking purely at graph topology. So this is
the kind of thing that one would want to be interested in studying in the context of the
physics project. And again, maybe, maybe we'll talk a bit about that about that later. But so
if I say, coordinate ties, polar graph, evolution, followed by
I could say, polar graph,
okay, so, so to explain a little bit. So, as I say, we give it effectively a spacetime metric.
We give it a time interval, we give it spatial coordinate parameters. And then we and then we
specify how many what resolution do I want to perform the simulation at in other words,
how many vertices do I want to use in my discrete approximation to this space like
hypersurface. And 1.5 is effectively the initial refinement resolution, because what we're doing
is essentially akin to adaptive mesh refinement, except it's adaptive hypergraph refinement. So
what we're doing is we start with a hypergraph approximation to the initial space like hypersurface,
and then in places where there's high curvature, we refine the hypergraph and in places where
there's low curvature, we course on the hypergraph. And that gives us eventually an evolution
of the kind that we see here. And, and so but so you can you can choose to tune those parameters
like, like increase the resolution, decrease the resolution, change the initial, you know, the
initial level of mesh refinement and so on. You know, 1.5 actually may be a little bit too coarse
from looking at these pictures. But anyway, so here, by saying polo, coordinateized polygraph
evolution colored, you can see, so this is the initial space like hypersurface at time t equals
zero. And this is the final space like hypersurface at time t equals one. So in this case, it's not
particularly interesting because we ran it on the Schwarzschild metric, which is of course static.
And so it's not particularly interesting to it's not particularly useful to simulate this,
except it's just a check that our methods are working, which they which they do in C, which
they do indeed seem to be. So this is the corresponding evolution from initial space
like hypersurface to final space like hypersurface. But here with all the coordinate information
thrown away. So we just have the raw graph objects. And the connection to the physics
projects is actually rather interesting. Just to briefly summarize, I mean, so as I say, when we do
this coursing and refining, the way that the way that that's effectively being implemented is through
a graphic writing rule or through a hypergraphic writing rule. So if you like, in the process of
doing these numerical simulations, what we're doing is effectively amounts to Wolfram model
evolution, except with where the state evolution or the event selection function for that Wolfram
model evolution is dependent on the measured curvature of the hypergraph. And it turns out
that's actually a result in being a remarkably efficient way to do numerical general relativity.
So that and if you go to the as I mentioned before, I think if you go to the to the
documentation page of discrete hyperservice decomposition, you'll see plenty of pictures
like this that you can quite that you should be very easily able to to reproduce in your own notebooks.
But an important question is, okay, so how exactly is a simulation like this being done?
And how could we do a more interesting simulation like like something like a,
you know, a compact binary inspire or whatever? Well, so glossing over a lot of the technical
detail, but the standard way this gets done in numerical relativity, which is the approach that
we use is to do what's called a metric decomposition or a three plus one or canonical decomposition.
So we use specifically the ADM decomposition, the Arnawit-Deser-Misner decomposition.
So if I choose to do that for the Schwarzschild metric, let's see what that does. So
what this allows us to do is to split the four dimensional space time into a
foliated sequence of space like a three dimensional space like hypersurfaces
related by certain coordinate constraints. So by saying spatial metric tensor, we get a
three dimensional metric tensor that represents the metric on the initial space like hypersurface
for this Schwarzschild metric. So this is a three by three matrix. And then if I say space time
metric tensor, this will give us a four dimensional metric tensor for the space time that's obtained
by evolving this initial space like hypersurface forwards in time. And you can see here that this
space time metric tensor, it depends on a bunch of these coordinates on a bunch of these functions,
alpha, beta one, beta two and beta three. So alpha is what we call the so and and these functions
are effectively how we parameterize the foliation of our space time into space like hypersurfaces
in order to obtain a well-posed initial value problem. So alpha is what's called the lapse
function. It effectively defines the time like distance from a point on one space like hypersurface
to a corresponding point on the neighboring space like hypersurface and beta one, beta two,
beta three corresponds to what's called the shift vector. And that effectively tells us how we
relabel the spatial coordinates as we move from one space like hypersurface to the next.
So you can see that the full space time metric tensor depends on not just on the initial spatial
metric, which you can see in this three by three sub matrix, but also on the on the forms of these
of these so-called ADM gauge parameters on the lapse and the shift. So if I take ADM and I say
properties, you can see this is a function with quite a lot of properties, ADM decomposition is
really this function is really the thing that's at the heart of the whole numerical subsystem of
this general relativity framework. So if we take this thing, we can compute things like gauge
conditions are obviously extremely important for okay, so if I extract out the lapse function,
I extract out the shift vector, we might reasonably ask what are the constraints that these functions
should satisfy and that depends on the gauge conditions. So because the Einstein field equations
are covariant general relativity is a covariant theory, that means we have a huge amount of
freedom to choose our coordinate systems. And so we have to effectively impose certain constraints
that tell us how the lapse function shift vector evolve as we move from space like hypersurface
to space like hypersurface. So there are certain constraints that are just imposed by the geometry.
So things like Gauss equations or the cadacity minority equations.
Actually, okay, what I'm going to do is this is going to be too complicated to
compute in full form. So what I'm going to do is I'm going to reduce our degrees of gauge
freedom a little bit. I'm going to introduce a lapse function and only one component of our shift
vector. So I'm going to have B, I'm going to have A be our lapse function, I'm going to have B be
the radial component of our shift vector, I'm going to have the angular components be both be zero.
So now that's now our lapse, that's now our shift. And if I say Gauss equations,
this will return the, so the Gauss equations and the cadacity minority equations are effectively
these correspond to the particular equations that have to be satisfied in order for our
space like hypersurfaces to embed correctly into a background space time. They are effectively,
if you like, coherence conditions between the spatial form of the Ricci, of the Ricci tensor
and the Riemann tensor and the spacetime form of the Ricci tensor and the Ricci and the Riemann tensor.
And so you can think of these as being effectively constraints that are imposed axiomatically
on our gauge variables. Equally, you know, we can impose our own coordinate constraints. We can
say to something like, you know, maximal slicing condition. So this is going to impose a, this
is a particular gauge choice that we can choose to make when simulating a black hole spacetime
that's sort of a particular case of maximal slicing. This is a condition that's imposed
on the on the lapse function on A that's intended to make the
volumes of the three-dimensional volumes of the space like hypersurfaces as large as possible.
And that turns out for various complicated reasons to be quite a stable way of evolving
black hole spacetime. Or we could take something like, I've actually forgotten the names of all of
the various coordinate conditions that we've implemented. So we could take, you know, one
plus log slicing. This turns out, one plus log slicing turns out to be a very good,
sorry, one plus log slicing condition. One plus log slicing turns out to be a very good
coordinate slicing condition to use when simulating black hole inspirals. It turns out to give
comparatively stable, you know, stable evolutions for those kinds of spacetimes. And in addition
to conditions on the lapse function, we can also compute conditions on the shift vector.
So we can say, for instance, harmonic coordinate conditions or generalized harmonic coordinate
conditions. And this is going to give us a list of constraints that have to be satisfied by the
components of the shift vector in order to, in order for the degrees of freedom, the gauge
degrees of freedom to be so-called harmonic. So the gauge equations, the equations for alpha,
beta 1, beta 2, beta 3, which will otherwise be elliptic equations, the harmonic coordinate conditions
correspond to the conditions necessary to, for those equations to go from being elliptic to
being hyperbolic wave equations. And then we can take things like, you know, the, so the point
of doing the, the ADM decomposition is that it allows us to take the, the 10, I understand field
equations that are ordinarily of mixed hyperbolic elliptic type and, and, and, and define effectively
over the whole spacetime and reduce them to a purely hyperbolic initial value form of the field
equations that allow us to evolve from an initial space like hyper surface to a final space like
hyper surface using kind of standard hyperbolic partial differential equation methods. So if we
take ADM decomposition, we compute evolution equations, it will give us the, at least the
geometrical form of those hyperbolic evolution equations for this particular black hole spacetime.
And if we take that and we do a full simplify, we should see that those evolution equations are
satisfied identically because this is a, because right now ADM decomposition is a purely geometrical
construction. In a moment, we'll see how to, to also incorporate some actual physics in this,
but to do that requires, you know, replacing Ricci tensors with stress energy tensors and
doing some, some, some fancy footwork. But the evolution equations only determine if you like
six tenths of the, of the spacetime metric because they are, they are evolution equations
only on the space like variables. So we've still got four time like component, you know,
four additional components that are obtained from the time like projection that are not determined
this way. And so those are instead determined by the so-called Hamiltonian and momentum constraints.
So if I say Hamiltonian constraints, this will compute this thing here. If I say momentum constraints,
wait, momentum constraints, sorry, momentum constraints that will compute this list here.
And so these you can think of as again, being additional. So the Hamiltonian constraints is
effectively a constraint on the laps, the momentum constraints are effectively constraints on the
shift. And these are the, and these correspond to the remaining four degrees of freedom that
have to be determined in order to close the system of equations and produce something
that can actually be solved in a well-posed way. And so, so when we actually, when we want to take
one of these things and solve the Einstein field equations. So if I take this, and I say, okay,
so if I take that ADM decomposition for the Schwarzschild metric, and I say solve
vacuum ADM equations of ADM, that might take a moment. Okay, I'll tell you what, let's, let's,
let's start with something simpler because this may be asking too much. So let's say
ADM decomposition, I should say, of course, you know, so just like, just like metric tensor
incorporates a library of inbuilt space time geometries, ADM decomposition incorporates a
library of sort of inbuilt initial space like hypersurface geometries, initial,
inbuilt initial values for, for solving the Einstein equations numerically. So if I take
this, let's say Schwarzschild, time coordinate t, special coordinates RA1, A2, let's do
lapse function zero, sorry, lapse, yeah, lapse function zero shift vector,
lapse function one shift vector zero zero zero, let's produce that solution. Let's do that with
zero cosmological constant. Okay, so you can see we've got a vacuum ADM solution. It is a valid
solution, but it's not exact. It had to use some approximations or some additional assumptions.
And we can, again, we can find out what those approximations or additional assumptions were
by computing field equations. And in this case, it tells us that one over r is equal to zero. So
that's not very useful, right? That's effectively saying that this, these gauge conditions are
only satisfied if you are infinitely far away from the black holes. That's not very good. So let's,
let's replace that with say ATR A1, A2, and maybe this with, again, let's go back to our old, no,
actually, no, let's not do that. Let's do this. Let's see what happens here. If we just, if we
just introduce a freedom of the lapse function, but we don't introduce a freedom of the shift
vector, so we get nine field equations. The thing is, remains a valid solution, which we can
just confirm here. And if I compute field equations, it's going to show, okay, these are the nine
additional field equations, which effectively reduce the conditions on the lapse function
that would need to be satisfied in order for this to be a valid solution to the vacuum ADM
equations. So, and so this is now a system of purely hyperbolic partial differential equations,
which we can solve using standard numerical methods. And in addition, we can check. So for
instance, is the Hamiltonian constraint satisfied? Let's see. I spelt that. What did I do? Satisfied,
which it is. And I can say other momentum constraints satisfied,
which they are. So in that particular case, we don't need to worry about the Hamiltonian
momentum constraints. We only have to worry about the field equations. So all we need to do is to
work out, okay, what's a function, what's a form for this lapse function that's going to satisfy
these equations? And as I say, we can use kind of standard numerical techniques, which is exactly
what what what Gravitas does internally. And, you know, okay, so in this particular case, I happen
to know that if we give this a symbolic mass m, and I make my shift vector be one minus two m over r,
and I solve the field equations. Now, we get an exact solution to the vacuum ADM equations. There
are no field equations that have to be assumed. And again, the Hamiltonian momentum constraint
equations are satisfied identically. And so this is how we can determine this is so we've just
computed from first principles, the valid space time produced from from evolution of an initial
space like hypersurface for the Schwarzschild metric. And so perhaps unsurprisingly, if I say
ADM space time metric, that's the thing we get out is exactly the form of the Schwarzschild metric
that we're all that we're all familiar with. So doing this for for something like a for something
like the Schwarzschild metric, as I mentioned, is is perhaps not not super useful, because,
you know, we already know that there's an analytic form of the Schwarzschild metric,
why would you use numerical relativity to compute this? But there are plenty of space
times where there is no known, you know, analytical form. So for instance,
if we want to simulate a compact binary inspiral, you know, a collision of two black holes,
I could give it a Brill-Lindquist initial data. So again, I'm going to simplify this a bit by
removing the redundant degrees of gauge freedom. So we don't get we don't get computational
bottlenecks too quickly. So if I say spatial metric tensor of this, matrix representation.
Okay, so this is the this is the initial space like hypersurface for the so called Brill-Lindquist
type initial data. So the Brill-Lindquist initial data corresponds to two, if you like,
two Schwarzschild black holes, or two bodies obeying Schwarzschild metrics, that are initially
widely separated. So in this particular case, in the default case, these are two bodies,
each with mass, each with symbolic mass m, and they're located in a kind of cylindrical,
in a setup of cylindrical symmetry, with coordinate z equals plus z naught, and z equals minus z
naught. And so what we what we typically want to do in something like a relativistic
inspiral simulation, is we want to start with an initial space like hypersurface like this,
and we want to crash these black holes into each other, either in a head on collision,
or in the more interesting case in a kind of inspiral collision. And so we want to find a
way to solve the Einstein field equations numerically for this initial value problem.
Okay, so we can do that. So in this particular case, it's not it's not super interesting,
because I've imposed unphysically high degrees of gauge constraints.
But okay, so you know, that's what our that's what our spacetime metric tensor would look like.
But just as we did for the case of the Schwarzschild metric up here, in principle, we can take this
brilliant, we can take this representation of the Berlin quest initial data, we can say solve
vacuum ADM equations, I can give it ADM two, I can say solve that with zero cosmological constant.
Okay, so I'm running this on a MacBook Air with, you know, while simultaneously doing zoom. So,
you know, this is not this, this particular function is not going to converge in any reasonable
amount of time. But you know, if you so but I encourage you if you have access to a to a
powerful computer or even better if you have access to a super computer cluster or something,
you know, I hardly encourage you to go and use this framework and, you know, spend a spend
an afternoon or something just crashing black holes into each other. So it's a very satisfying
thing to do. And so, so the the pictures I showed you at the beginning, over here,
of the compact binary inspirals, these were produced as high as you know, these are high
resolution simulation outputs produced by essentially evolving a brilliant quest initial
data, solving the vacuum, the vacuum ADM equations in exactly this way. For those of you who know
about numerical gr, we are currently in the process of implementing other initial value
formulations of the field equations that are better suited for, for compact binaries and
compact binary inspirals, particularly the so called bssn and ccc four equations and various
refinements of those. But but those things are not yet exposed to the function repository,
but hopefully they will be soon. And of course, you know, just as we did for the ordinary
Einstein equations, if we wanted to do if we wanted to simulate not just the evolution of
vacuum space times, but actually, as is in the case of the these gravitational collapse
simulations, if we wanted to simulate space times involving, you know, energy matter
distributions, we could say, you know, take a we could say take a stress energy tensor and do an
ADM decomposition of that. So we could say take the perfect fluid stress energy tensor. And if I
say ADM stress energy, okay, and okay, right, if I do this, this is by default going to be a perfect
fluid in the ADM form of the Minkowski metric. So it's stress energy tensor is going to look
like this, and it's going to have these again, these dependence on alpha b to one beats two,
b to three, because we're doing this in a space time that's been that's been that's
undergone a three plus one split. But I could do this in any in any ADM decomposed space time.
So if I did this, so if I say ADM composition, let's do Schwarzschild
er a one a two. And again, let's just do with let's do that with with the lapse function being a
free with it being free and the shift vector being constrained. So I do that.
And now the stress energy tensor is going to be a little bit
more complicated. It's going to okay, so it's going to end up involving
this this lapse function and other things. So if I say ADM stress energy, I could say what I mean
something like energy density, you know, all the same things that we could do for just the ordinary
ordinary space time forms of the stress energy tensor, we can also do for ADM decomposed forms
of stress energy tensor. And so in particular, what we're what we're doing here is we're taking
the space time stress energy tensor and we're projecting it in this in this three plus one
decomposition. And so then the what would have given us just general continuity equations in
the space time case, which are of mixed hyperbolic elliptic type now gives us a purely hyperbolic
system of conservation equations with the time like projection giving us effectively energy
conservation equations, and the space like projections giving us momentum conservation
equations. If I say energy conservation equation, we get this. If I say, you know, momentum
conservation equations, we get these and so on. And so in exactly the same way as we did for the
for the space time variables themselves, we can also solve essentially the equations of general
relativistic hydrodynamics, you know, the you know, or the general relativistic Euler equations
using kind of standard numerical hyperbolic solvers. And again, so this is this is exactly
the thing that we did in a for these gravitational collapse simulations, these are effectively
like perfect fluid or perfect relativistic dust collapse simulations that are only possible by
by taking a perfect fluid or perfect dust stress energy tensor and projecting that
in accordance with this with this ADM three plus one decomposition.
So that's really what's going on internally, when we when we when we run these kind of
simulations, as we're taking a specification of an initial space like hypersurface,
we take the user defined kind of coordinate constraints and degrees of gauge freedom,
and we then we choose to solve those those evolution equations numerically using these
hypergraph based adaptive refinement algorithms. And then and then we produce these these results
and then because because the design of this framework once we've got these results, we can
then feed those back into the symbolic framework, and we can extract things like angular momentum
variables, we can do event horizon checking using coordinates, you know, using the coordinate
singularities code, we can, you know, we can extract gravitational wave data by by kind of
computing symbolic vial tensors, all of that kind of stuff. So really the complete workflow
of doing an end to end numerical relativity simulation from initial problem formulation
to simulation to, you know, to post simulation visualization and analysis, all of that should
be able to be done within just a single notebook using us, you know, using a single framework.
And that's, you know, again, that's that's that's sort of what that's one of the core ideas
behind what we're trying to do with this with this system. So there are lots of other things
that I could show. But I've covered I think most of the main bits of the the salient parts of the
framework. And given that we are coming towards the end of the schedule time, maybe I should we
should we should take, I'll stop talking for just a moment. And we can, if there if there have been
things in the chat, which I haven't really been following, then then we can take a look at those.
So if you have people have questions, things they want me to talk about things I said they
didn't understand, things they want me to go into more detail about, then then let me know.
But so I'll start to look through the through the chat questions.
Okay, so Krishna Aditya is asking, will gravitas have a quantum advantage?
Okay, I'm going to try to if you, I'm going to try to interpret your question, because I'm not
entirely sure that I understand it. So quantum advantage is something that people talk about
in the context of quantum computers, where you say, you know, I've got some quantum algorithm,
and in principle, it offers me such and such a speed up over the corresponding classical algorithm.
Everything we're doing here is purely classical, this is just classical general relativity,
and it's, you know, it's discretization in terms of the Wolfram model, we're not doing
anything quantum mechanical here. You may be asking whether it's possible to use the algorithms
that have been designed in gravitas on quantum computers or to develop quantum analogs of them.
It's an interesting question. And of course, you know, for those of you who know about the
physics project, I mean, one of the kind of core lessons we learn is that anything that involves
sort of multiway systems, and evolution to multiway systems, which all of this implicitly
very much does, all of those things are in principle, kind of quantum, quantumizable.
And so it's conceivable that we could produce something that was kind of a quantum, at least
in theory, a quantum computational implementation of these kinds of algorithms. I'm enough of a
quantum computing skeptic to be to be not entirely convinced that would be a fruitful thing to do.
But I'm not, I'm not, I'm not entirely sure that I understand your question. It's, as I say,
this is a purely classical framework, all the algorithms are purely classical algorithms.
So this is not the kind of thing where there's where there's obvious quantum advantages to
talk about. There is algorithmic advantage to using this functionality, because as I say,
in some sense, as we've shown in other papers, by doing these numerical simulations using
hypergraphs, rather than using kind of fixed coordinate system, you know, curvilinear coordinate
systems or Cartesian coordinate systems, like other frameworks, such as GR Chombo or, or, or,
or the cactus framework do, but by having our topology being might be much less structured,
we are able to get quite significant performance benefits from that, we can, we can simulate,
you know, extreme space times without the need to do kind of complicated excision or moving
puncture gauge conditions or all that kind of stuff. Although gravitas supports all of that,
those things too. But actually, in a lot of cases, you don't really need to do that.
So there are, there are algorithmic advantages to using hypergraphic writing to doing numerical
relativity, but I'm not sure it's useful to think of those being quantum advantages. This is really
a classical system. Okay, Andres Monterey Moreno is asking how to make Einstein some,
how to make Einstein some for make operations with tensor in general relativity. So I think I kind of
covered that with, so when I, when I showed, when I was showing off the, I mean, the symbolic
framework, all of this uses Einstein summation convention by default. And in fact, you can see
it very explicitly in the cases where, where we're computing index contractions, right. So
kind of remember where I did this now. Yeah, so here, places like this, you can see, you know,
these repeated indices like Sigma that appeared when I, when I was contracting these Christoffel
symbols along their indices, all of this is making use of Einstein summation convention. So we can,
so we support, so anything in the gravitas framework that is of kind of, that is of abstract
type tensor supports Einstein summation convention, you can take covariant derivatives of them,
you can do index contraction, you can do all that kind of stuff. I don't know if that fully
answers your question. I'm not, so I mean, yes, you can do Einstein summation is the,
is the, is the basic answer. If there was a more specific thing you were asking about, then,
then, then please do let me know. I just got a message from zoom that says participants
can now shit see your screen. I hope that, I hope that was a bug. I hope it wasn't the case that
participants can only now see my screen. But anyway, so, okay, what else do we got to tech
prefix as really neat. Okay, thank you. This, yeah, I agree. I think this is, this is an exciting
framework. Jimmy way, Jimmy way, they, I want to say they like, like, or why like home and vile,
but I don't know how to pronounce your surname. symbolic side is very neat application beyond
physics into chemistry would be interesting. That's interesting. I don't, I don't quite know
what the, I mean, I'm not sure what formal similarities there are between, you know,
solutions to the Einstein equations and the kinds of things that chemists would be interested in.
I know that there are, for instance, formal similarities between like, so in the description of
well, okay, so particularly in things like solid state physics, which I guess is you could kind
of think I was being related to as being a branch of chemistry, you know, when people are computing
like, you know, distortion tensors for, for elastic solids or they're computing q tensors for,
for liquid crystals and things, there's a bunch of just kind of general purpose tensor calculus
stuff that's probably shared, you know, that's a shared interest between gr and chemistry.
That may have been what you were referring to, I don't know, in which case, yeah, maybe you can
use some of the functionality for gravitas to do that. I don't think, I don't think this framework
is really the right thing to use. I think using something like exact a more general
tensor calculus library is probably the way to go if you want to do, you know, computations of q
tensors for, for, I don't know, smectic liquid crystals or whatever. But maybe again, maybe
you meant something else, play your question in which case, so yeah, please do clarify if you're,
if you're still around. Okay, Jack Reese, hello, Jack Reese, I, I, someone I know. Hello, any book
in the works, it'll be cool to see all these in slow motion. A book about this framework,
I don't think that I'm not really a book writing kind of person. And I'm not sure this framework
is large enough to really warrant a book. I mean, I actually, okay, what one thing that's worth
saying, by the way, is that although, you know, obviously, this was designed as a framework for
doing general relativity research. I hope that this is a framework that ends up getting used by
educators. I mean, in the same way as we saw with the quantum framework, I mean, we originally
designed the Wolfram Languages quantum framework again, to be a kind of research tool. But one
thing we very quickly found after we released it is that it ended up being used in a bunch of,
you know, intro courses in foundations of quantum mechanics or quantum information.
And so I hope that, you know, that if you're an educator who's teaching a course on an
introductory course on general relativity or cosmology or something, that you'll find some
way to use some of the functionality that I've shown here to help illustrate some of those concepts
and help to, to shield your students from all the, all the horrifying complexity of doing
tensor calculations by hand. You know, I think in 21st century, people should not still be
computing Christoffel symbols of the Schratzschild metric themselves. So in that sense, if you're
an educator and you want to go write a book that's kind of introducing the, you know,
that's introducing general relativity using this framework, I think that's a great idea. You should
absolutely, you know, people should absolutely go and do that. I'm not sure that I'm going to do it
myself. But, but yeah, people should do that. You do say it would be cool to see this in slow
motion. I agree. I appreciate this has been a very fast-paced introduction to the framework,
but I've never really, I haven't really talked about the framework in public before. So,
so that was kind of why, why I wanted to, I wanted to kind of give at least a summary of,
of many of the core features of, of what this does. I agree it would be good to do
something in slow motion. Maybe one thing we could do, you know, we have both through Wolfram
U and through the, and through the, the Wolfram Research YouTube channel, there's some provision,
I believe, for kind of having slower-paced video tutorials and things, or even written
tutorials that kind of show you in a, in a more step-by-step way how to build up and,
and use a framework like this. And I think maybe once, once we're a bit further along in the design,
it may be worth, in fact, I think it'd be quite a good idea to, to, to make a tutorial of that
kind that would be a little bit slower and a little bit more digestible. I'm, I'm, I'm, I'm
completely in favor of doing that. Davan V says, recently you said black hole creation is, is too
observable in finite observation to an observer from outside, help understand and visualize. Okay.
So I think this person is referencing a tweet that I made earlier today, in which I was pointing
out this very basic fact about black hole physics that a lot of people don't seem to know, which is
that, that, that, if you have a collapsing star or something, an astrophysic, you're forming an
astrophysical black hole, the black hole doesn't form. If you're an outside observer watching
that collapse, that black hole does not form in finite time. It own, the event horizon for that
black hole only forms in the sort of infinite time limit. And the reason for that is very
simple. It's because that the, the, the, the, the, for relativistic reasons, the, the collapsing,
sort of, you know, sphere of material cannot ever be seen to, to, to sort of pass its own,
its own Schwarzschild radius, because to do so when involved, it's, it's co-moving velocity going,
going faster than light. And so to you as an observer, you just see the thing collapse more
and more slowly, and the material appears to get more and more redshifted and more and more
distorted until eventually it just kind of fades away. But you never, you never actually see,
if you like, the formation of the event horizon. That's why when, when we, when we look at, you
know, when we, when we produce visualizations of black holes, you know, and you imagine kind of
stuff being sucked into a black hole, it never falls directly in. You, you, instead you see
the stuff just kind of accumulate around in an accretion disk that surrounds the black hole,
and the, and the disk gets hotter and hotter, and, and you, you get the kind of high energy plasma
things that get formed, which, which ultimately are believed to be the, the origins of quasars
around, around rapidly rotating black holes. But, but, but yeah, you, but you never see the
matter fall past the event horizon because you can't, it's against the rules of general relativity
for you to ever observe matter falling past the event horizon. And so, so for that reason,
it's really, you know, black holes really only exist in some sense if you fall into them, or if
you wait infinite time. If you fall into a black hole, then, then you would see the surface of
that material recede away from you, and then, and then once you're inside, then, then the event
horizon is there. But until, until that happens, if you're on the outside, the event horizon doesn't
form in any finite amount of time, you ask if I can visualize that. I mean, yes. So in effect,
when, when, when you, when you see this, so the Schwarzschild metric that we used here
is an external black, is a metric for the exterior geometry of a black hole. And you can see there's
a hole in the middle here where, where, where effectively where the thing is, is ill, is, is
not defined. And the reason for that is because of this, is precisely because of this coordinate
singularity. If we take, if we take the Schwarzschild metric, and I compute its singularity structure,
we get this coordinate singularity at r equals 2m. And so everything, you know, so, so that,
that's, that's effectively the limit to, to, to the radius of any, of any compact body that's
undergoing gravitational collapse. It can't collapse at, at two or below r equals 2m, because it
would end up violating, it would violate general relativity. And so that's effectively the thing
you see here. So this, this gap in the middle is, is essentially the, the, the, the bit of the
metric that's missing, because it, because it goes beyond this r equals 2m coordinate singularity.
And so to visualize the thing I was saying about being an infalling observer, all you have to do
is, is, is switch to a different coordinate system, right? So if you switch to, in going Eddington-
Finkelstein coordinates, so you get matrix representation like this. Okay. So this, this
is now the coordinate system as seen by an infalling observer. And in this coordinate system,
if we now, if we now compute metric singularities,
then you see there is only one, right? There's only the, there's only this sort of physical
singularity at r equals zero. And this coordinate singularity at r equals 2m has disappeared. And
this is a consequence of the fact that it is merely a coordinate singularity. It is a coordinate
artifact as, as was, I think originally pointed out by, by George Lemaitre. So, so this transformation
to the, in going Eddington- Finkelstein coordinates is a way to visualize exactly that point that,
that it's only if you're an infalling observer that the, that the event horizon forms in finite
time. If you, if you remain on the outside, the event horizon doesn't form in any finite time.
I, if you want to know more about this, see my, see my Twitter feed.
Okay. Khalid al-Tabih says, how does this algorithm is as hypergraphs compare in computational
complexity to traditional numerical algorithms? Okay. So I kind of, I kind of mentioned that a
little bit. And actually one of the papers that I showed this, where is it? This paper,
in particular, where I first proposed this, the, the, the, the kind of proto version of this algorithm
did an analysis of this. But yeah. So effectively in terms of the, the computational complexity,
I mean, look, we, the, the, the, the, the complex part in any, in any finite volume,
numerical algorithm of this kind is computing the fluxes, right? Computing the inter-node
fluxes. You know, effectively along each one of these, along each one of these edges,
we have to compute a flux that corresponds to the, to the flow of, of information in, in the
kind of, in the sense of characteristic analysis between the, between the values at each of those
nodes. And it's almost always in any numerical algorithm, based on finite volume approximations,
it's almost always the flux computations that are going to be the computational bottleneck.
And so using hypergraphs in that sense doesn't help us at all, right? We still have to do those
computations. So it's not, it's not going to speed anything up from that point of view.
But the, the, the interesting thing, which I already alluded to is that because we have a much
more unstructured hypergraph topology than you would if you just had a fixed curvilinear coordinate
system, as, as standard sort of numerical relativity codes do, because of that, rather
astonishingly, for the, for the same number of points, for the same number of nodes or cells,
we can get actually much higher resolution than you could get with, you know, with, with our,
with our adaptive refinement algorithms, we can get much higher resolution than you would be able
to get with the corresponding fixed curvilinear coordinate grid, even, even if that curvilinear
coordinate grid had its own kind of hierarchical adaptive refinement. And yeah, in that paper I
do a kind of more systematic analysis that compares the two approaches. But, but yes, I mean,
broadly speaking, it's, I think in four-dimension, for four-dimensional spacetimes, if I recall
correctly, you get approximately a cubic increase in the, in the relative level of, of, of resolution
as measured in terms of the L1, L2, and L infinity errors on the, on the Hamiltonian constraint. So
in other words, you need cubically fewer, you know, polynomially fewer nodes in order to achieve the
same bound on the, on the L1 error in the Hamiltonian constraint as you would with a typical
numerical algorithm based on kind of, on a fixed coordinate topology. So, but yeah, go read those
papers if you want to know more details, or if you have more specific questions about the,
about the computational complexity aspects, I can try to address them. The universe within
Federica Befa, all saying very nice complementary things. So thank you. David Hansen is asking,
does this bring into question the nature of spacetime? I can remember during the regular
physics project meeting, spacetime looked to behave differently than what tradition would dictate.
I mean, so, okay, so these, what we're trying to do with these simulations is, is reproduce
general relativity. We're trying to reproduce the predictions made about, you know, about, about
continuous spacetime. So in that sense, the answer is no for this particular framework. But one
interesting feature of this is, you know, ordinarily in numerical analysis, if you have a low resolution
simulation, or you have a simulation where, where you have only kind of comparatively few grid
points in some region, then you introduce a bunch of kind of discretization errors, right? You
introduce for instance, you can get the phenomenon where you get kind of spurious waves that get
produced around corners and things, you know, between your computational cells. And ordinarily,
those are viewed as errors that you kind of want to get rid of in the design of your numerical
algorithm. One thing that's kind of interesting though, if we're right about kind of the, you know,
the Wolfram model approach, and we're right, we're kind of correct in thinking about the
fundamental structure of spacetime as being combinatorial, then one interesting feature of
that is that the kind that those things, those sort of discretization phenomena are in fact not
just numerical artifacts, they might in fact be kind of observable physical effects. And so,
you know, one, one interesting thing that you see in simulations produced using the
gravitas framework is that when you have very strong relativistic field dynamics,
where spacetime is getting stretched and squashed in all kinds of complicated ways,
you can end up in a situation where you have comparatively sparse
graph representations that kind of essentially lay bare the underlying discretization scheme.
And when that happens, you can see discretization effects manifest, for instance,
in terms of phase shifts in the gravitational radiation. And again, if you go look at the
early papers that I wrote about this algorithmic approach, you can see some of those effects
being computed explicitly. But essentially, you see a phase shift in the components of the
vial tensor that get emitted, for instance, after a black hole in spiral, where the degree
of the phase shift depends in a very sensitive way on the discretization scale of the underlying
spacetime. So in that sense, we made, you know, one thing that I'm very excited about is using this
general relativity framework as a way of probing, you know, possible astrophysical or cosmological
predictions that we can make as a consequence of the discrete spacetime model. You know,
essentially, we can potentially use this framework to predict places where the continuum
approximation to spacetime that's made in general relativity might reasonably break down
in high energy astrophysical or cosmological scenarios. But that's, it's important to stress
that's a much more speculative idea that's really a kind of basic science idea. You know,
the focus of this particular talk was not supposed to be on basic science, it was supposed to be on
demoing this new lawful language functionality, which you can all go and use. But there is,
of course, there is a whole separate interesting basic science question of what does this mean
for the physics project and is it possible we might be able to use this to make astrophysical
predictions? Tentatively, the answer doesn't appear to be yes, and I'd love to talk about that in
more detail at some other point. I have some ideas about how that might work, but it's not,
unfortunately, that's not the, that's not what wasn't really intended to be the subject of the
stream. The universe within is asking, if you're working out the collision of two black holes
in your model, are you able to see what's happening in the ruleal and branchial graphs?
So, with this framework, no, because we, so, in effect, when we do this ADM decomposition,
we assign these coordinate constraints, we make certain coordinate constraints that
constrain our gauge variables. The reason we're doing that, if you like, is we're essentially
trying to ensure that we only have one well-defined evolution path. We are effectively defining
unambiguously an event selection function that eliminates the multi-way structure.
If you like, one way to think about the multi-way system is that it's a byproduct of the fact that
you have gauge, you know, you have gauge freedom in the model. Gauge freedom in the model corresponds
to freedom of choice in how you apply the rules or more broadly in which rules you apply, and that
manifests in the fact that the multi-way system is not merely a path graph. And so, in a sense,
for the purpose of doing numerical relativity computations, because general relativity emerges
from the model as the approximation that you get, if you only consider the geometry of the
hypergraph and the causal graph, and you ignore everything about the multi-way system. And so,
for that reason, we're trying to get rid of all the multi-way structure, which is why we have these
very, very kind of hard gauge conditions that are used to ensure that there's absolutely no
degrees of coordinate freedom, so we don't get any multi-way behavior. Now, of course, in principle,
one very interesting thing to do, again, from a basic science point of view, is to say, well,
let's relax that assumption. Now, what we've got is no longer a classical general relativistic
simulation, but something more like a kind of discrete quantum gravity simulation that involves
multi-way behavior and has branched your graphs, and you could even consider the interaction of
multiple rules and consider rule your graphs and so on. And that's a perfectly interesting thing
to do. And, you know, for instance, there's recent work that I've been doing with collaborators
involved in essentially investigating how one can reproduce predictions of quantum field theory
and curved spacetime using methods of this kind. So effectively, doing these kind of general
relativistic simulations where the gauge constraints are relaxed, so you look at the
multi-way behavior, and then it turns out that certain semi-classical correlations that you get
from doing quantum field theory and curved spacetime, you can actually compute directly from the
combinatorics of the branch of graphs. I have various papers about that. Again, I'd be happy
to talk about that at some other point, but that's maybe slightly beyond the scope of this
particular stream. Okay, I think we've basically reached the end of the, okay, we've reached the
end of the questions that I at least can see. So maybe this is a good time to start to close down
the stream. So thank you very much again for coming. I hope this has been vaguely useful. I'm
sorry we covered so much material in such a short period of time. Let me just double-check
there was nothing particularly that I want to show. I mean, there's loads of stuff we could
have talked about. I didn't talk anything about the extrinsic curvature tensor. I didn't talk about
other bits of curvature, Schausson tensors and so on. I barely showed the electromagnetism
subsystem. I barely showed how angular momentum works. We only kind of scratched the surface
of how the 3 plus 1 decomposition works. We didn't talk about electrovacuum solutions. We didn't
talk about other 3 plus 1 formulations of the field equations that are supported.
So there's lots of lots of stuff to play around with that goes beyond the scope of what I showed
in this stream. And so if you want to see that or you want to play around with it, please just,
you know, go and go and check out the functional repository entries, look at the documentation,
go and, you know, look at the GitHub repository. And yeah, hopefully we'll try to get once we're
a little bit further on in the design of this, hopefully we'll try to get a more systematic
tutorial produced at some point so that you can follow along hopefully in a more reasonably
paced way and a slightly more structured way than this more than this mildly scattergun approach
that I've taken in this particular stream. But anyway, so thanks very much for joining.
Thanks for the thanks for your great questions. And yeah, we'll see you soon. Thanks.
