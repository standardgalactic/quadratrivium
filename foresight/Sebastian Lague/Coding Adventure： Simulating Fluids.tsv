start	end	text
0	5320	Hello everyone, and welcome to another episode of Coding Adventures.
5320	10440	Today, I'd like to dive into the world of fluid simulations.
10440	18280	So to begin with, let's draw a circle.
18280	19960	Very nice.
19960	24920	This circle represents a tiny bit of water, or whatever fluid we want to imagine, and
24920	28280	it's going to move around in response to various forces.
28280	31600	For instance, gravity is probably a good place to start.
31600	36000	So back in the code, I'll add in a gravity variable, and let's also keep track of the
36000	39880	particle's position and velocity.
39880	44280	Each time step, we'll then want it to be accelerated downward by gravity, and to then
44280	47840	move according to its new velocity.
47840	50000	Let's take a look.
50000	55920	Okay, not bad, but it is falling off the screen, which is a bit annoying, so I've added a
55920	60560	tiny function that just checks if the particle has moved outside of a box, and if so, we
60560	65320	shove it back into the box, and send it bouncing off in the opposite direction.
65320	70320	I'd actually also like to multiply the velocity by some collision-dumping factor between
70320	75160	0 and 1 here, so that we can control how much energy it loses with each bounce.
75160	80880	Alright, so we can set up our little bounding box, and turn on the gravity again, and off
80880	83720	we go bouncing.
83720	87560	By the way, I've also made it so that we can control the display size of the particle
87560	89560	here.
89560	96600	Okay, let's then also try out our collision-dumping setting, and we can see the particle now bounces
96600	100600	low and low each time until it comes to a stop.
100600	105280	Believe it or not though, one particle is not enough particles to simulate a fluid,
105280	110160	so I've quickly upgraded our position and velocity variables to instead store a whole
110240	114800	array of positions and velocities, which we can then loop over and just do the same
114800	118600	update as before to each of them.
118600	122840	I've also created a simple function that runs at the beginning to set up the particles
122840	128120	in a little grid arrangement, just so that they're not all on top of one another.
128120	132960	So let's make a bunch of particles, and I'll quickly tweak the size and spacing over here
132960	137600	to something more reasonable, and then we can let this run.
138480	142360	Okay, there's a pretty clear problem though, which is that the particles are all just collapsing
142360	147520	on top of one another, so I guess we need some sort of force to push them apart.
147520	152040	I'm curious to learn how this is typically handled in the fluid simulation world, so
152040	153760	I'm going to do some reading.
153760	158400	I found a bunch of intriguing particle-based fluid papers, and I've just spent the last
158400	161640	few hours trying to work my way through those.
161640	166800	Honestly, most of the maths has gone well over my head, as it often does, but the broad
166800	172000	ideas at least are encouragingly simple, so I think my goal for today is not to try and
172000	176480	make some amazingly accurate simulation, but just to build a rough starting point from
176480	180720	which we can delve deeper into the maths and physics in the future, when I'm hopefully
180720	182480	a little bit smarter.
182480	187760	Anyway, the first step to fixing that overlapping particle problem we were having is to be able
187760	191680	to estimate the density of our fluid at any point.
191680	196080	So I've just scattered our particles around randomly for this example, and of course since
196080	199960	we're imagining that this represents some kind of fluid, in reality there should be
199960	204560	way more particles in this, but we're always going to be limited by what our computers
204560	210480	can handle, so to approximate reality, we can just cheat a little bit by blurring or
210480	215360	smoothing out the few that we have, so that it appears more as a continuous field than
215360	217680	a bunch of individual points.
217680	222800	This simple idea is the basis of smoothed particle hydrodynamics, a technique introduced
222800	227440	back in the 70s to help solve astrophysics problems and further our understanding of
227440	231960	the universe, which today we'll be using for the equally lofty goal of making some
231960	234840	little pixels go splash splash for our amusement.
234840	240120	Alright, so to see how we're going to calculate this sort of density field we have here, let's
240120	245280	zoom in on a single particle and define a smoothing radius, which gives us this circle
245280	250000	of influence around the particle, where it will have maximum influence at the centre,
250000	253280	falling off to no influence at all at the outer edge.
253280	258040	Let's draw a little graph of this behaviour, so on the x-axis we'll have the distance
258040	262120	from the centre of the particle, and because negative distance doesn't make a huge amount
262120	267480	of sense, I'll just make the left side of the graph be a mirror of the positive side.
267480	272760	Then the y-axis will represent the influence of the particle at any given distance, and
272760	276920	let's say for now that our smoothing radius is just 1.
276920	281240	So a simple simple function we could use would be something like this, just subtracting
281240	285920	the distance from the radius and clamping it to never go below zero, and here's what
285920	288240	that gives us.
288240	293520	This is not very smooth though, so we could take that straight line and qubit for example,
293520	297680	which will ease it out as it approaches zero.
297680	301920	Another option if we wanted to be smooth at the start as well, would be to also square
301920	306840	the radius and distance before subtracting them, and here's how that comes out.
306840	310800	Obviously we could also try different powers or different functions altogether, I think
310800	314680	it's mostly a case of just playing around and seeing what works best.
314680	317100	But let's go with this one for now.
317100	321260	So I've used that to write this little density function, which takes in the point we want
321260	325680	to find the density at, and then for each particle it gets the distance to that sample
325680	330200	point, which determines how much influence the particle has at that location, and then
330200	336260	it simply increases the density by the particle's mass, multiplied by the influence value.
336260	340860	And the mass I've just defined to always be one for simplicity.
340860	345380	So let's test this quickly with an evenly spaced grid of particles, and I'll just try
345380	351420	sampling the density at the centre here, with a radius of 0.5 for example.
351420	356620	Now at the moment the density is coming to about 0.48, but if we squish the particles
356620	361180	closer together, we can see that the density value goes up, which makes sense, and if we
361180	365520	move them further apart, it goes down of course.
365520	368800	But what about if we increase the smoothing radius?
368800	374160	Well, our density value has just shut up through the roof, which is very concerning, because
374160	379200	making the radius bigger should only make the result more blurry, which for this uniform
379200	383220	grid of particles should actually have no effect on the density at all.
383220	385280	So let's think about this a bit.
385280	390760	For each particle we are calculating an influence value, which we could draw as a height, and
390760	394760	here we can of course see the shape of our smoothing function emerge.
394760	399200	Now we're effectively just adding all these heights together to create our density value,
399200	403080	but it's kind of helpful to note that if we were to first also multiply the heights
403080	407000	by the width and breadth of these little boxes I've drawn here, what we'd actually
407000	412260	be doing is estimating the volume of the smoothing function.
412260	416240	So with that in mind, I think it's reasonable to say that if we want the density to stay
416240	421000	the same as we change the smoothing radius, then what we'll need to do is make sure that
421000	426640	the volume of our smoothing function remains the same when we change the smoothing radius.
426640	430440	That means we're going to need to calculate its volume, or make Wolfram calculated for
430440	436560	us at any rate, and that is come out to pi times the smoothing radius to the power h
436560	438480	divided by 4.
438480	442760	We can then just go back to our smoothing function and calculate the volume in here,
442760	447080	and then simply divide the output by the volume, which means that now the new volume of the
447080	450400	function will always be 1.
450400	455320	Let's quickly make sure this is working, so the density is 187 at the moment, and now
455320	460360	if we change the smoothing radius that should stay the same, which it does.
460360	464320	Of course if we make the radius too small, the results will get a little dodgy since
464320	469080	there just aren't enough particles, but apart from that we now have a nice way of determining
469080	473760	the density at any point, with whatever smoothing radius we choose to use.
473760	479380	Ok, so let's return to our random arrangement of particles, and we can now properly visualize
479380	484180	the density values here as we increase the smoothing radius.
484180	488460	Now we're claiming that this represents a fluid, so one would probably assume it's
488460	493180	a guess at the moment, because we have all these regions with different densities.
493180	499300	But I'm more interested in simulating liquids today, which in practical terms are incompressible,
499300	503500	meaning their molecules are packed together as tightly as they can be, and so we'd expect
503500	506260	the density to be the same everywhere.
506260	510020	For our simulation to behave at least somewhat like a liquid then, we're going to need
510020	515860	to rapidly correct these density differences by moving particles from areas of high density
515860	518100	towards areas of low density.
518100	522740	So we need to figure out how to calculate that, but I started to get a bit confused at
522740	527060	this point while I was doing my research, so I'd like to take a step back for a moment
527060	531180	and just play around a bit with an abstract example to try and wrap my head around some
531180	537260	stuff first, and then we'll come back and apply what we've learnt to our actual problem.
537260	542140	So here's a simple little function that takes in a point in 2D space and outputs a single
542140	544580	value, which looks like this.
544580	548820	And what it represents is nothing at all, it's just a made up function that we're
548820	553340	going to try and represent with particles to hopefully gain a better understanding of
553340	557180	this whole smooth particle business we're working with today.
557180	562020	So I've now added some code that spawns in a bunch of particles at random positions,
562020	566460	and each of these just looks up the value of the example function at its location and
566460	570980	stores that in this vaguely named particle properties array.
570980	575460	Now we're going to pretend that we no longer have access to that example function for whatever
575460	580700	reason, so we only know the values at the particle positions, and our first goal is
580700	584020	to simply approximate the missing values.
584020	587740	To do that, we'll use the same smoothing idea from when we calculated the density
587740	588740	earlier.
588740	593700	So I've made this little calculate property function that takes in a point in space, loops
593700	599140	over all the particles, and just adds up the values of their properties multiplied by the
599140	603260	smoothing function, since again that just tells us how much influence the particle has
603260	608380	at the current point, and then also multiplied by the mass, since that effectively scales
608380	610660	how much influence the particles have.
611140	615980	Let's see how that comes out, so here's the original function again just for reference,
615980	618180	and here's our approximation.
618180	622660	Obviously, the shape isn't perfect, but we could simply use more particles to improve
622660	623660	that.
623660	628700	What's more concerning though is that the values are clearly being greatly exaggerated.
628700	633380	Now we could try to correct this by reducing the particle mass, but that just reveals a
633380	638180	deeper problem, which is that the values are being particularly exaggerated in regions
638180	643020	of high particle density, since obviously more values are being added together there
643020	645780	than in regions of low density.
645780	650380	So to fix that, all we actually need to do is calculate the density at each particle,
650380	654780	using the function we wrote earlier of course, and then divide each particle's contribution
654780	656780	by its density.
656780	661420	Now our approximated result looks like this, without needing to make any adjustments to
661420	667940	the mass, which is a whole lot better, and it's reasonably close to the original function.
667940	672500	So what we've arrived at here is actually one of the core equations of this whole technique,
672500	677780	which says that to calculate some property a at any position x, we just need to loop
677780	682740	over all the particles and add together the value of that property that's stored in
682740	688420	each particle, multiplied by the particle's mass, divided by its density, and finally
688420	692980	multiplied by the smoothing function, given the distance between the particle and the
692980	695340	sample point.
695340	699300	What's interesting to note here is, say that the property we want to calculate with
699300	703180	this equation is the particle's density.
703180	707620	In that case, we replace a with the density, which then cancels out with the density over
707620	712260	here, leaving us with just mass times the smoothing function, which is exactly what
712260	717140	we came up with in the beginning, so that bit of math seems to check out at least.
717140	721740	Okay, that's nice and all, but what we're more interested in right now than calculating
721740	726900	the value of a property at any point, is calculating in which direction it's most
726900	731300	rapidly changing, since that's essential to our problem of correcting the density in
731300	732660	our fluid.
732660	736860	So I've started writing this little calculate gradient function to do that, and all this
736860	742340	does is define a tiny step size, and then figure out how much the value changes if we
742340	747660	take that tiny step along the x and y axes, using the calculate property function we just
747660	748860	wrote.
748860	753580	And the estimated gradient is just those two changes, each divided by the size of the step
753580	754580	that we talk.
754580	759100	Let's try it out, so I've drawn in some little arrows to visualize the gradients
759100	763500	at different points, and just visually it looks like these are all correctly pointing
763500	767180	along the direction where the values are most rapidly increasing.
767180	769340	So that's great.
769340	773980	What's less great is that it's taking almost 20 seconds to calculate all of these, which
773980	776020	is ridiculously slow.
776020	779140	Unfortunately though, there is a more efficient approach.
779140	783380	Imagine we have just a single particle, and I'll draw on the smoothing radius here as
783380	788340	well, and we're trying to calculate the gradient of whatever property at this point
788340	789340	over here.
789340	794580	Well, first of all, the direction in which that property will most rapidly be increasing
794580	799860	is either directly towards the particle, or directly away from it if the property is negative,
799860	801780	so that's easy enough.
801780	805980	The gradient doesn't only tell us the direction though, but also how fast the property is
805980	810980	changing, and that depends purely on our smoothing function.
810980	814620	At the current distance, we can see that the smoothing function isn't very steep, which
814620	818860	means that the property will be changing quite slowly over here, whereas of course if our
818860	823980	sample point was over here for example, then it would be changing a lot more rapidly.
823980	833660	So after struggling to remember how basic calculus works for a few minutes, I finally
833660	837500	figured out the equation for the slope of the smoothing function, which I've just
837500	840180	translated into code over here.
840180	846020	And that means that we can now easily look up the slope value at any distance.
846020	850060	So let's return to our fast attempt at the gradient function, and I'll delete the old
850060	854740	code and replace it with our CalculateProperty code, since that's almost exactly what
854740	859060	we need, except since we want to know the gradient now, we'll multiply not by the
859060	864220	smoothing function, but by the slope of the smoothing function, and then also by the direction
864220	869660	towards the current particle.
869660	875260	By summing up all these individual gradients, we should logically get the overall gradient.
875260	879580	Then if we return to our little visualization and just run it again, it should look exactly
879580	881340	the same as before.
881340	885580	Which it doesn't, I guess I got the direction back to front, so I'll just stick a minus
885580	886900	sign in there quickly.
886900	890820	I come from the trial and error school of mathematics, but now it does look the same
890820	892420	as before.
892420	898260	This optimization has taken us from 20 seconds down to about 5, which is still uselessly
898260	901580	slow, but headed in the right direction at least.
901580	905900	Okay, I've just been having another look at our gradient function, and we definitely
905900	908460	need to stop calling CalculateDensity all the time.
908460	912220	I somehow forgot already that that's also looping over all the particles.
912220	914700	No wonder this is so slow.
914700	919500	So what we can do is just create an array of density values, and then pre-calculate those
919500	925900	for each particle, so that we can just use those cached values in our gradient function.
925900	931140	That brings our computation time down from 5 seconds to 18 milliseconds.
931140	933420	I probably should have started with that.
933420	938340	Anyway, it's still not fantastic, but it's at least usable for now.
938340	942780	So let's return at last to our little density test over here, and see if we can apply this
942780	946780	gradient stuff to make the density be the same everywhere.
946780	951500	So in the code, I've defined a target density that we want to aim for, along with a pressure
951500	956100	multiplier, which is just how strongly we're going to push the particles to try and reach
956100	957820	that density.
957820	962180	Then I've also added this little function for converting the density to a kind of pressure
962180	966900	value, and this just looks at how far away the density is from what we want it to be,
966900	970060	and then multiplies that by the pressure multiplier.
970060	974020	From what I understand, this isn't really a super realistic way to calculate pressures
974020	979540	in a liquid, it more so describes the behavior of gases, but it still seems to be a popular
979540	983540	choice for its simplicity, so let's stick with it for now at least.
983540	987780	I would like to quickly visualize these values, so I've set up three different colors over
987780	992260	here, one for the regions where it's negative, just meaning that the density is lower than
992260	996780	we want it to be, another for where the value is positive, meaning of course that the density
996780	1001420	is higher than we want it to be, and finally one for the boundary between them, where the
1001420	1003020	density is just right.
1003020	1007860	I'll also change the particle color to black, so that it stands out a bit better here.
1007860	1012620	Okay, so let's finally get these particles moving along the pressure gradient, and for
1012620	1017220	that we can just use the gradient function we wrote, which I'll rename to calculate
1017220	1021740	pressure force, and then the property we're interested in here is of course the pressure,
1021740	1026460	so let's substitute in our little pressure calculation.
1026460	1031340	Then our simulation update loop now looks like this, we still have the gravity, position,
1031340	1035660	and collision stuff from before, but I've added in the density caching we decided to
1035660	1036820	do.
1036820	1040740	We still need to actually apply the pressure forces here though, so I'll make another
1040740	1045220	loop quickly to calculate those for each of the particles, and then we know that force
1045220	1050700	equals mass times acceleration, so acceleration is force over mass.
1050700	1055500	So my first thought was to just calculate the acceleration like this, but actually we're
1055500	1060860	thinking about the movement of tiny volumes of fluid here, and density is the mass per
1060860	1064660	volume, so it's in fact the density that we want to use instead.
1064660	1068900	Alright, all that's left then is to just increase the particles of velocity by this
1068900	1073140	acceleration, and we can finally try it out.
1073140	1078420	This has been a long time coming, so let's get a little drumroll going.
1078420	1083380	Ah, the curse of the drumroll continues.
1083380	1088180	Okay, the positions are all not a number I see, so most likely we're dividing by
1088180	1089180	zero somewhere.
1089180	1094380	Oh, of course, we're being given the position of a particle here, but then we're also
1094380	1098580	looping over all the particles and finding the distance between the two.
1098580	1101100	And that's where everything's going wrong.
1101100	1105140	I guess what I'll do is just have this function take in the particle index instead of the
1105140	1109620	position, and that way we can very easily just skip over the case where the two particles
1109620	1111340	are the same.
1111340	1116780	Okay, I just need to fix this up quickly, and I suppose it is technically possible for
1116780	1121540	two different particles to be in the same position, so if that edge case occurs, let's
1121540	1124100	just pick a random direction then.
1124100	1127940	Alright, let's try this out again.
1128940	1133620	Well, at least everything hasn't blinked out of existence, but the particles are getting
1133620	1136860	more dense, which is the opposite of what we want.
1136860	1139620	I guess I need to stick another minus sign in there somewhere.
1139620	1143380	Let's see if this works now at the third time.
1143380	1150300	Okay, that's… that was looking promising for a moment there, for a brief instant I
1150300	1151540	thought it was working.
1151540	1154460	But there's still a lot more red areas than I'm hoping to see.
1154460	1159900	Ideally, the whole screen should turn white, since that represents our target density.
1159900	1163740	So to try and figure out what's going on, I want to see what happens if, instead of
1163740	1168660	adding the acceleration to the velocity, we just assign it directly, so we're removing
1168660	1172940	any inertia from the particles, they're just purely moving based on the current pressure
1172940	1173940	force.
1173940	1179180	Okay, if we run this now, nothing happens, but that's fine, we aren't accumulating
1179180	1183300	velocity anymore, so I guess we just need to turn the pressure multiplier up really
1183300	1184300	high.
1184300	1187300	Alright, that looks interesting.
1187300	1191500	I am a bit surprised by how close together some of these particles are, although they
1191500	1194860	seem to gradually be pushing each other apart.
1194860	1198560	And I actually remember one of the papers mentioning this potential problem with the
1198560	1203300	smoothing function we're using, since its slope becomes very shallow as the distance
1203300	1207860	becomes small, meaning that our pressure force will also be small when the particles are
1207940	1209740	close together.
1209740	1215380	That seems odd, so let's maybe ditch this nice smooth curve for the spiky version instead,
1215380	1219060	since of course the slope of this one just gets steeper towards zero.
1219060	1223780	So I had to do the volume and derivative calculations again, but ended up with these
1223780	1226020	two functions here.
1226020	1230220	Plugging those in, we can see our little map looks just ever so slightly different, and
1230220	1235460	then I'm going to turn up the pressure multiplier again now, and see what happens.
1236420	1238980	Okay, that's looking a lot better actually.
1238980	1242940	The question now though is what does it look like if we put the acceleration back to how
1242940	1244700	it's supposed to be.
1244700	1250860	So I've changed it back, and I'm going to try running this again.
1250860	1255060	Let's maybe try increasing the pressure multiplier a bit, so that the particles can react more
1255060	1257380	quickly.
1257380	1261860	That's looking reasonably good I think, although maybe I'm imagining this, but it
1261860	1265380	seems to be getting worse over time.
1265380	1271060	Okay, I'm definitely not imagining it.
1271060	1275620	So another thing we need to think about is Newton's third law of motion.
1275620	1284660	Every force has an equal and opposite reaction force.
1284660	1288780	So when we're adding on this pressure force between the current particle and some other
1288780	1294420	particle, we want to make sure that the other particle experiences the same force, just in
1294420	1295420	the other direction.
1295420	1300380	I've seen a bunch of different suggestions on how to actually do this, but a nice simple
1300380	1305620	version is to calculate this shared pressure, which is literally just the average of the
1305620	1309940	pressure values calculated at both particles.
1309940	1318580	So let's try that out quickly, and I'll just increase the pressure multiplier again.
1318580	1321500	And this does seem to have made a pretty big difference.
1321500	1325100	I guess maybe that Newton guy was onto something.
1325100	1329140	Now we're only dealing with a few hundred particles at the moment, which is not very
1329140	1334780	many, so let's ramp this up to a few thousand instead.
1334780	1338220	And this is running at 5 frames per second.
1338220	1340420	So we'd better start optimizing.
1340420	1344900	And by far the most critical place to do that is when we're calculating the densities
1344900	1349940	and pressure forces, we should rarely avoid looping over all the particles that lie outside
1349940	1354220	of the smoothing radius, since those don't contribute anything, and they're slowing
1354220	1357020	us down immensely.
1357020	1361680	To do this, we're going to need to chop space up into a grid, and we'll choose the size
1361680	1366820	of the grid cells to be the same as our smoothing radius, since that means, if we imagine there's
1366820	1371380	a bunch of particles on here, that means that to find the particles inside of the smoothing
1371380	1377620	radius, we only need to consider the 3x3 grid of cells around the center of our circle.
1377620	1385180	And in that way of course, we cut out a huge amount of unnecessary work.
1385180	1389500	Now to actually implement this, we could say that each cell has its own list that grows
1389500	1393780	or shrinks to hold however many particles are currently inside of it.
1393780	1397660	But we're probably going to want to convert the whole simulation to a compute shader at
1397660	1402780	some point to run on the GPU, and there we need to be able to specify ahead of time how
1402780	1404700	much memory we're going to use.
1404700	1409020	So I'd like to experiment with a different GPU friendly approach, which I've been reading
1409020	1411260	about in this paper here.
1411260	1415100	I'm going to modify it very slightly though, so that we don't need to know the dimensions
1415100	1419620	of the grid ahead of time, meaning that particles can travel anywhere in the world, and it'll
1419620	1422380	still work.
1422380	1428300	So what we'll do is create a single array with at least as many entries as we have particles,
1428300	1433660	so here it has 10 entries, meaning in this case we could have at most 10 particles.
1433660	1437220	Then for each of these particles, we're going to calculate the coordinate of the cell that
1437220	1438220	it's in.
1438220	1444980	So for example particle 0, which happens to be this one over here, is in the cell 2,0.
1444980	1449260	We need to turn that coordinate into a single number to make it easy to work with though,
1449260	1453980	so we can just do something like multiply the x and y by two different prime numbers,
1453980	1457820	and then add them together to get some arbitrary hash value.
1457820	1462140	We can then wrap that around the length of the array so that it becomes a valid index,
1462140	1468500	3 in this case, and let's call that our cell key, not to be confused with the seal people.
1468500	1474780	So since this was point 0, we'll store the cell key over here at index 0 in the array.
1474780	1480060	And the next point, it turns out, has a key of 6, and so we'll record that in the next
1480060	1481420	place.
1481420	1488100	And so on and so forth for all of the particles that we have.
1488100	1492500	Now we want the points that share a cell to be next to one another in this array, so that
1492500	1494740	we can efficiently loop over them.
1494740	1499260	Of course if they're in the same cell, they're going to have the same cell key, so we can
1499260	1503420	simply sort the list based on those keys to do that.
1503420	1508420	And now we can easily see from this array that particles 2, 5 and 7 are all together
1508420	1514180	in the same cell, particle 0 is in a cell all by itself, and so on.
1514180	1519620	Anyway, let's call this array our spatial lookup, because that sounds nice and fancy,
1519620	1524420	and then the final thing we need to do is create a second array of start indices, which
1524420	1526100	looks like this.
1526100	1529500	To understand this second array, let's just do a quick example.
1529500	1533580	So say we want to know which points are in this cell over here.
1533580	1538460	We would first calculate the cell's key like before, which is 9 in this case.
1538460	1543180	And then we'd proceed to look up the 9th element in the array of start indices, which
1543180	1546500	is this last one over here, the number 6.
1546500	1550700	That lets us know that we need to head over to index 6 in the spatial lookup, in order
1550700	1554760	to find the first entry with the cell key that we're interested in.
1554760	1558740	We can then simply loop over all of those to get the indices of the particles that are
1558740	1560660	in that cell.
1560660	1565580	Unfortunately it is possible for different cells to end up mapping to the same key,
1565580	1570380	which would mess with these results, but we're anyway going to need to do distance checks
1570380	1575180	to see which points are actually inside the smoothing radius, and so that'll get rid
1575180	1576780	of any mistakes.
1576780	1581300	Obviously, having to check extra particles from some other random cell that just happens
1581300	1585820	to have the same key does waste time, but that's what we get for trying to implement
1585820	1590340	an infinite grid with a sadly non-infinite amount of memory.
1590340	1596180	Anyway, turning this concept into code didn't go as smoothly as it possibly could have,
1596180	1599860	but after a bit of frustration, here's what I finally ended up with.
1599860	1604480	We have a function for updating the lookup whenever the points have moved, and this just
1604480	1610820	calculates the cell key for every particle, and records that along with the particle index.
1610820	1616180	The array is then sorted based on those keys, and lastly the start indices are calculated,
1616180	1620740	simply by testing if each key is the same as the key that came before it, because if
1620740	1625780	not then it must be the first occurrence of that key, and we can record its index as the
1625780	1626780	start index.
1626780	1631980	Here are the little helper functions, by the way, for calculating the cell coordinate,
1631980	1634900	hash, and key.
1634900	1638740	Then finally there's the function that allows us to actually find all of the points within
1638740	1641980	the radius of some given sample point.
1641980	1646300	This works as we've seen by just looping over the 3x3 block of cells around that sample
1646300	1649820	point, and calculating each of their keys.
1649820	1653980	Each key is then used to look up the start index for that cell, so we can loop over all
1653980	1658460	the points in the cell, and of course once we reach a point that has a different key,
1658460	1660500	we just exit out of the loop.
1660500	1664700	All that remains then is to do a quick distance check to make sure the point is actually inside
1664700	1669220	the circle, and then we can do whatever we want with it.
1669220	1674540	Trying this out now, we've gone from barely 5 frames per second up to 120, so there was
1674540	1679780	a reasonable success, but I'd be a lot happier about it if our simulation wasn't in total
1679780	1683980	chaos over here.
1683980	1688580	One clunky way I found to improve this is to simply start off with a really low pressure
1688580	1689980	multiplier.
1689980	1694220	This way the particles don't have such a huge initial burst of acceleration, and they
1694220	1698820	can spread out a little, and then we just gradually increase the multiplier, and it
1698820	1701900	seems to work a bit better at least.
1701900	1706220	That's not really a usable solution though, so I've just been implementing an IGRI
1706220	1710460	read about where we basically predict what the next position of each particle is going
1710460	1716260	to be, simply based on the current velocity, and use those predicted positions when calculating
1716260	1719060	the densities and pressure forces.
1719060	1724900	I guess this could help the particles to better react to upcoming situations, and maybe compensate
1724900	1729780	a bit for the fact that time is obviously not continuous in a computer simulation, but
1729780	1732580	rather broken up into discrete steps.
1732580	1734580	Okay, let's try it out.
1734580	1740980	I honestly don't see it making a big difference though.
1740980	1744300	Never mind, it's actually making a pretty massive difference I'd say.
1744300	1747340	Well, that's a nice surprise.
1747420	1751620	Also fun, I've quickly gone into the particle rendering code I have here, and just set it
1751620	1756260	up so that we can visualise the speed of the particles with a colour.
1756260	1760100	Then here's a little gradient I made for that, so the slowest particles will appear
1760100	1765700	blue, fading to red for the fastest particles.
1765700	1770300	I also added in some simple controls for things like pausing the simulation, stepping through
1770300	1774460	frame by frame, and resetting it.
1781100	1784460	Alright, I've been playing around with this some more, and one thing I've noticed
1784460	1789060	is that it behaves very inconsistently at different simulation frame rates.
1789060	1793860	Here's a little grid of simulations I set up to observe this problem, so we're going
1793860	1799580	from 60 simulation steps per second on the top left, to almost 1000 steps per second
1799580	1801140	on the bottom right.
1801140	1806700	And as we can see here, if the number of steps is higher, meaning the time step is smaller,
1806700	1811220	and so we're predicting less fine to the future, the particles take longer to settle
1811220	1812700	down.
1812700	1816700	So even though this feels a bit wrong to me, I'm going to try just removing the delta
1816700	1821100	time here, and use a constant look ahead factor instead.
1821100	1826460	Let's then run the same comparison again, and interestingly it is actually behaving
1826460	1828300	a lot more consistently now.
1828780	1832100	Well okay, I guess we'll go with that then.
1832100	1836380	Now I think it'd be fun if we could interact with the particles in some way, so I've written
1836380	1841100	this little function that basically just pulls nearby particles in towards the mouse, or
1841100	1845940	pushes them away if the input strength is negative, which is controlled by left or right
1845940	1847700	clicking.
1847700	1854180	So let's give it a shot, I'm going to start by pushing these particles outwards,
1854180	1857180	and then let's try slicing through the fluid.
1860180	1864220	Alright, I feel like this is slowly starting to get somewhere.
1864220	1869300	Clearly, we haven't really succeeded in our goal of making this fluid incompressible,
1869300	1873860	it's certainly compressing and expanding all over the place, but the density does even
1873860	1878740	out over time, so that's something at least, and we can look into fancier methods to try
1878740	1881060	and solve this better in the future.
1881540	1886140	Anyway, now that this seems to be somewhat working at any rate, I think it's time we
1886140	1889620	brought gravity back into the mix.
1889620	1893900	So I'll reset this quickly, and let's bring in our settings window.
1893900	1898340	I feel like the density could maybe be set a bit higher, so I'll turn that up, and then
1898340	1901060	let's get the simulation going again.
1901060	1905460	Okay, I guess that's a little too high now.
1905460	1912460	So, I'll dial that setting back down a bit.
1912460	1916300	Then, let's turn on the gravity.
1916300	1920660	Wait, that's upside down, let me make it go the other way instead.
1920660	1924980	The particles are quite wild at the moment, so I'll also increase the pressure multiplier
1924980	1928580	to try and drain them in a little.
1929580	1939220	Okay, let's try picking up a ball of water.
1939220	1941340	And dropping it back in.
1941340	1943340	Splash.
1943340	1947420	This is actually working surprisingly well I'd say, I mean I realise I've been droning
1947420	1951620	on for over half an hour already, but all that we've really done is made a bunch of
1951620	1956700	points that don't like to be too close together, but not too far apart either.
1956700	1960980	And while this is obviously far from being super realistic or anything, I think it's
1960980	1965660	still quite fascinating that this fluid-like behaviour has already arisen from just the
1965660	1975180	few little things we've implemented.
1975180	1979460	Anyway, let's see if we can still improve this at least a little bit more today, and
1979460	1982860	perhaps even venture into the third dimension.
1982860	1985580	So a few issues are jumping out to me at the moment.
1985580	1989740	For example, there's the fact that the particles are really tightly squeezed together along
1989740	1994900	the edges here, and that's causing a gap between the rest of the particles since they're
1994900	1997900	trying to get away from that overly dense region.
1997900	2002820	And a similar effect seems to be happening along the surface of the fluid as well.
2002820	2007420	Another thing is that when we have fast-moving particles, such as when starting up the simulation
2007420	2011820	for instance, the fluid seems to be overly chaotic.
2011820	2016260	For example, if we zoom in on a single frame here, we can see from these colours how the
2016260	2021100	velocities are all over the place, even between nearby regions.
2021100	2025300	For this last problem at least, I think it'd be a good idea to try and add a bit of friction
2025300	2030620	between the particles in the fluid, more commonly known as viscosity.
2030620	2035500	So let's actually take a moment to look at the famous Navier-Stokes equations for incompressible
2035500	2039780	fluid flow, which underpin everything that we've been doing.
2039780	2043540	First of all, this equation here just says that the density of the fluid must remain
2043540	2047820	the same everywhere, and I mean, we're trying.
2047820	2052420	Then the other equation tells us that each tiny little volume of fluid is accelerated
2052420	2058260	down the pressure gradient, and that it responds to external forces such as gravity and mice
2058260	2062100	in our case, so we've done both of those terms.
2062100	2066620	But then this slightly scary looking term here is the viscosity, and essentially what
2066620	2072460	it does is cause the velocities of nearby regions of fluid to become blurred together.
2072460	2076660	Now we could implement it this way, but for today at least, I actually want to go with
2076660	2080780	a different approach I've seen that seems much simpler, but still achieves the same
2080780	2082220	sort of thing.
2082220	2086700	So I've added this little function here, which just takes in the index of a particle,
2086700	2090780	and loops over all the other particles within the smoothing radius.
2090780	2094300	For each of those, it then calculates the difference between the velocities of the two
2094300	2100380	particles, and adds that on to the viscosity force, meaning that over time, each particle's
2100380	2105100	velocity will become more like its neighbors, and nearby neighbors have more influence as
2105100	2110060	usual, which is done using this viscosity kernel, for which I've just repurposed that
2110060	2113580	function that we were originally using for the pressure force.
2113580	2116060	Okay, let's try it out.
2116060	2120980	Oh, my settings have been reset, so we're back to no gravity at the moment, but let's
2120980	2122660	see what that looks like.
2122860	2127500	Currently, our viscosity is at zero, so let's turn it up, I'm not sure what a good value
2127500	2130860	would be, let's just try 5 maybe.
2130860	2134340	Nope, definitely not, that looks very strange.
2134340	2138420	My guess is that the viscosity is just way too high at the moment, and so some of these
2138420	2142740	particles are almost exactly matching one another in velocity, and that's causing
2142740	2145100	them to clump together weirdly.
2145100	2150140	So let's reduce it to maybe 0.5 instead, and see how that goes.
2151140	2154420	Okay, this is looking pretty good actually.
2154420	2158500	We can see how the particle velocities are more smoothed out, and so we no longer have
2158500	2162900	those few particles with super high velocities shooting off on their own.
2162900	2167700	I want to see how this looks with gravity enabled again, so I've set up a quick comparison
2167700	2174220	here with a range of different viscosity values, and let's see how it goes.
2174220	2181660	I think the one on the top right looked best to me, but let's see that again quickly.
2185660	2189500	And I'll freeze it here actually, because this gives us a nice view of the increasingly
2189500	2193660	smoothed out results we get with this new artificial viscosity term.
2193660	2197220	Obviously, we don't want to smooth out too much detail though, so I'm going to keep
2197220	2199100	that value pretty low.
2199100	2203980	Okay, now I'm not quite sure yet how to tackle that boundary problem I mentioned earlier,
2203980	2207860	so I'm going to just ignore that for now, and instead work on something else that's
2207860	2209260	bothering me.
2209260	2214780	If we lift up a bunch of water, and then let it go, we can see how it quickly splits up
2214780	2221660	into these little droplets of just a few particles each, which looks a little strange.
2221660	2225340	We could get rid of this behaviour by simply clamping the pressure values that they can't
2225340	2231060	go below zero, meaning that the particles won't pull each other together anymore.
2231060	2234740	So let's try that out.
2234740	2239900	But now the particles are just raining down individually, which doesn't look right either.
2239900	2244380	I guess allowing that negative pressure was giving us a very crude kind of surface tension
2244380	2249260	effect, and so I think until we implement a more accurate version of that in a future
2249260	2253020	video perhaps, we should probably hang on to it.
2253020	2257380	So I'm going to undo that change, and instead I want to try an interesting workaround one
2257380	2262900	of the papers suggested, which is to simply have a second pressure force, purely for pushing
2262900	2266680	apart particles that get too close together.
2266680	2270660	So this is the shape of the smoothing function we're using for our density calculation at
2270660	2275820	the moment, and what the paper recommends is to use another, even spikier version, to
2275820	2279700	calculate what they call the near density.
2279700	2284020	From this near density, we calculate the near pressure, simply by multiplying it by some
2284020	2288900	constant, meaning that this will be a purely repulsive force.
2288900	2292700	So let's try it out quickly, and just for fun, I'm going to see what happens if we
2292700	2295860	make the near pressure multiplier negative.
2295860	2301860	Okay, they just collapse in on one another, which makes sense, so let's then try a positive
2301860	2303660	value.
2303660	2311420	And now I want to try picking up a ball of fluid again, and dropping it.
2311420	2316620	And as we can see, this time it's able to hold its shape a lot better, since the particles
2316620	2321380	are no longer getting pulled into those tiny clusters we saw before.
2321380	2325900	So I think we've succeeded in improving the fluid a bit with these last two changes,
2325900	2329900	although I'm certainly not entirely happy with how it's behaving yet.
2329900	2334340	For example, something that bothers me quite a lot is how it often appears to sort of bounce
2334340	2337020	more like a jelly than a liquid.
2337020	2341340	This is happening pretty much all the time, but we can see a dramatic example if I just
2341340	2347700	let the fluid come to a rest, and then change the target density for example.
2347700	2352380	Now we could get less jiggly results simply by increasing the pressure multiplier, which
2352380	2356100	is often called the stiffness constant by the way.
2356100	2361380	So here I've set up a little test where it has a value of 1000, and if I change the
2361380	2366820	density now, we can see that it does settle down a lot more quickly.
2366820	2370780	But that doesn't come for free though, because the greater the forces in our fluid are, the
2370780	2376340	more simulation steps we need to run per frame to avoid things devolving into chaos.
2376340	2380600	For example, if I just lower the number of steps here slightly, we can see that already
2380600	2384220	we're on the brink of pandemonium.
2384220	2390340	Anyway, I'm sure we'll learn about ways to overcome, or at least improve this problem
2390340	2395140	in the future, but for right now what I'd like to do is finally convert the whole simulation
2395140	2400060	to a computer shader, so that we can run it on the GPU, which excels at doing loads
2400060	2406260	of tiny tasks in parallel, which should be a perfect fit for our particle calculations.
2406260	2409180	I doubt that'll take very long, so I'll see you in a minute.
2425140	2453100	Ok, I kept finding new and creative ways to mess everything up, but this finally seems
2453100	2456220	to be running properly in a computer shader.
2456220	2459940	I'll still need to test the performance with more particles of course, but just glancing
2459940	2466180	at the FPS counter looks promising so far, hovering at around 500 frames per second.
2466180	2471500	By far the trickiest part was translating just one line of code, the array.sort from our
2471500	2473140	neighbourhood search.
2473140	2477380	I ended up spending quite a while trying to figure out how to implement a parallel sorting
2477380	2481420	algorithm called bitonic merge sort to replace it.
2481420	2486140	In particular, I was trying to generate this pattern of lines, and generalize it for any
2486140	2487860	number of inputs.
2487860	2493500	The inputs here are represented by the horizontal lines, and we have 16 of them in this case,
2493500	2496460	meaning that this network can sort 16 values.
2496460	2502100	Let's actually assign a random value to each input, so we can see how this goes.
2502100	2507380	Then each of these little vertical lines represents a pair of inputs that we're going to compare,
2507380	2509820	and potentially swap around.
2509820	2514140	So to start with, we're going to look at each of the 8 pairs that we have over here,
2514140	2518940	and let's say we want to sort from high to low, so in the first pair we have 5 on top
2518940	2523860	and 3 on the bottom, which we're happy with, so that can stay unchanged.
2523860	2528860	In the next pair though, we can see 7 on top and 8 on the bottom, so the bottom is a higher
2528860	2533140	number which is not ok, and we'll need to swap them around.
2533140	2537380	So we can look at all these pairs in parallel, figure out which need to be swapped, and then
2537380	2538880	swap them.
2538880	2542960	Of course this alone is unlikely to sort the list, so once that's done we'll need
2542960	2545480	to continue to the next stage.
2545480	2550600	Here the pairs are arranged a little differently, but the operation is still exactly the same.
2550600	2555520	We can see this first pair has 5 on top, 7 on the bottom, so it will need to swap, as
2555520	2566180	will this pair with 3 on top and 8 on the bottom, and so on.
2566180	2570340	This pattern has been carefully devised by some clever person, such that following it
2570340	2577100	will do all the comparisons required to guarantee that the result is fully sorted by the end.
2577100	2580860	For anyone interested, I'll quickly show the implementation I came up with, so this
2580860	2586020	part runs on the CPU and is responsible for simply looping through each of those patterns,
2586020	2589280	and telling the GPU to sort the pairs.
2589280	2593220	And then here's the code that actually does that pairwise sorting, so it starts by just
2593220	2596700	figuring out which pair of numbers it's actually looking at, and then it compares
2596700	2601300	them to see if they need to be swapped, and if they do, it of course swaps them.
2601300	2606260	Alright, I've been doing some testing with different amounts of particles, so here is
2606260	2610940	100 particles for example, and I think it's kind of cute watching these little droplets
2610940	2612620	wobble about.
2612620	2618260	Then after that I tried 100,000 particles, but my computer was not happy about that,
2618260	2621860	so there's definitely a lot of room left for optimization.
2622860	2627420	Here's a test with about 40,000 particles though, which seems to be running okay, although
2627420	2630940	I'll have to fine tune the settings of course, because at the moment there are some weird
2630940	2634700	tendrils shooting out of the liquid, and I really don't know why.
2634700	2639420	Or perhaps we could call this a speculative simulation of how liquids might behave on an
2639420	2641260	alien planet.
2641260	2644620	The settings are definitely quite finicky at the moment though, so that's something
2644620	2648060	else I want to improve.
2648060	2651780	Here's another little test I've set up by the way, and this one has an obstacle over
2651780	2656220	here with a gap beneath it, because I just want to see if this simulation is able to
2656220	2662180	keep the height of the liquid the same on both sides.
2662180	2666700	So I'm just going to start bucketing some of this liquid over to the other end here,
2666700	2671940	and then let's grab another blob, and another, and then let's just wait a bit for this to
2671940	2676140	settle down, but already we can see the height gradually leveling out.
2676140	2680380	So even though our simulation is far from being super realistic, it's nice to say at
2680380	2683500	least that it's not entirely unrealistic either.
2683500	2688340	Okay, now as always there's so much more I still want to do, but to end with for today,
2688340	2692300	let's see if we can get this working in the third dimension.
2692300	2697780	This basically just means replacing a bunch of float 2s with float 3s in the compute shader,
2697780	2702460	as well as updating the scaling factors of the various smoothing functions and their
2703220	2707420	and making sure our neighborhood search is aware of this brand new dimension as well,
2707420	2708420	of course.
2708420	2713820	I've also updated the collision function to work in 3D, and I tweaked it to account
2713820	2718940	for the bounding box being moved or rotated as well as scaled, simply by transforming
2718940	2724740	the points and velocities to its local coordinate system, then resolving those the same as before,
2724740	2730220	and then finally transforming them back into world coordinates.
2730220	2734580	My first attempt at running this did not go particularly well, but after some trial
2734580	2739100	and error with the settings I managed to get this rather goopy looking result, and with
2739100	2742740	a few more tweaks from there I was finally able to get something that I was reasonably
2742740	2748340	happy with.
2748340	2752580	So let's just play around with this a bit, I'm going to try squeezing it together,
2752580	2756180	and what's nice about how we implemented the neighborhood search stuff, is that we
2756180	2760380	aren't constrained to any predetermined bounds, so we can stretch this out however much we
2760380	2769260	want as well, and it should still work.
2769260	2772980	Those little waves were looking quite nice I think, so let's actually smush this together
2772980	2787140	again, and then try that out once more.
2787140	2791180	Now another thing to add to my list of a million things I want to improve is how the
2791180	2794100	fluid is actually rendered.
2794100	2798060	These little balls are good for seeing what's going on of course, but it would be nice to
2798060	2802620	make it actually look more fluid like, and I guess some sort of ray matching is probably
2802620	2809660	a good way to approach that, but we'll have to see.
2809660	2814740	So let me actually make a quick note here of my sort of wish list for this project.
2814740	2819940	I want the simulation to be more stable and performant so that we can have many more particles,
2819940	2824180	and I'd like the parameters to be less finicky so it's easier to get good results, and also
2824180	2828100	for the particles to behave better along the boundaries, because it looks really odd at
2828100	2829860	the moment.
2829860	2833220	Another thing that'll be really nice is to be able to do stuff like put little boats
2833220	2838020	or rubber ducks in the water, and just watch them bob about.
2838020	2843300	Then finally of course there's the rendering stuff I just mentioned as well.
2843300	2847260	So plenty of work for the future, but until then I hope you've enjoyed following along
2847260	2849220	with the process so far.
2849220	2853620	Okay, that's all for today, let me know if you have any suggestions for this project
2853620	2855700	or for anything else you'd like to see.
2855700	2858220	Alright, thanks for watching and goodbye.
