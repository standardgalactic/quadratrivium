1
00:00:00,000 --> 00:00:05,320
Hello everyone, and welcome to another episode of Coding Adventures.

2
00:00:05,320 --> 00:00:10,440
Today, I'd like to dive into the world of fluid simulations.

3
00:00:10,440 --> 00:00:18,280
So to begin with, let's draw a circle.

4
00:00:18,280 --> 00:00:19,960
Very nice.

5
00:00:19,960 --> 00:00:24,920
This circle represents a tiny bit of water, or whatever fluid we want to imagine, and

6
00:00:24,920 --> 00:00:28,280
it's going to move around in response to various forces.

7
00:00:28,280 --> 00:00:31,600
For instance, gravity is probably a good place to start.

8
00:00:31,600 --> 00:00:36,000
So back in the code, I'll add in a gravity variable, and let's also keep track of the

9
00:00:36,000 --> 00:00:39,880
particle's position and velocity.

10
00:00:39,880 --> 00:00:44,280
Each time step, we'll then want it to be accelerated downward by gravity, and to then

11
00:00:44,280 --> 00:00:47,840
move according to its new velocity.

12
00:00:47,840 --> 00:00:50,000
Let's take a look.

13
00:00:50,000 --> 00:00:55,920
Okay, not bad, but it is falling off the screen, which is a bit annoying, so I've added a

14
00:00:55,920 --> 00:01:00,560
tiny function that just checks if the particle has moved outside of a box, and if so, we

15
00:01:00,560 --> 00:01:05,320
shove it back into the box, and send it bouncing off in the opposite direction.

16
00:01:05,320 --> 00:01:10,320
I'd actually also like to multiply the velocity by some collision-dumping factor between

17
00:01:10,320 --> 00:01:15,160
0 and 1 here, so that we can control how much energy it loses with each bounce.

18
00:01:15,160 --> 00:01:20,880
Alright, so we can set up our little bounding box, and turn on the gravity again, and off

19
00:01:20,880 --> 00:01:23,720
we go bouncing.

20
00:01:23,720 --> 00:01:27,560
By the way, I've also made it so that we can control the display size of the particle

21
00:01:27,560 --> 00:01:29,560
here.

22
00:01:29,560 --> 00:01:36,600
Okay, let's then also try out our collision-dumping setting, and we can see the particle now bounces

23
00:01:36,600 --> 00:01:40,600
low and low each time until it comes to a stop.

24
00:01:40,600 --> 00:01:45,280
Believe it or not though, one particle is not enough particles to simulate a fluid,

25
00:01:45,280 --> 00:01:50,160
so I've quickly upgraded our position and velocity variables to instead store a whole

26
00:01:50,240 --> 00:01:54,800
array of positions and velocities, which we can then loop over and just do the same

27
00:01:54,800 --> 00:01:58,600
update as before to each of them.

28
00:01:58,600 --> 00:02:02,840
I've also created a simple function that runs at the beginning to set up the particles

29
00:02:02,840 --> 00:02:08,120
in a little grid arrangement, just so that they're not all on top of one another.

30
00:02:08,120 --> 00:02:12,960
So let's make a bunch of particles, and I'll quickly tweak the size and spacing over here

31
00:02:12,960 --> 00:02:17,600
to something more reasonable, and then we can let this run.

32
00:02:18,480 --> 00:02:22,360
Okay, there's a pretty clear problem though, which is that the particles are all just collapsing

33
00:02:22,360 --> 00:02:27,520
on top of one another, so I guess we need some sort of force to push them apart.

34
00:02:27,520 --> 00:02:32,040
I'm curious to learn how this is typically handled in the fluid simulation world, so

35
00:02:32,040 --> 00:02:33,760
I'm going to do some reading.

36
00:02:33,760 --> 00:02:38,400
I found a bunch of intriguing particle-based fluid papers, and I've just spent the last

37
00:02:38,400 --> 00:02:41,640
few hours trying to work my way through those.

38
00:02:41,640 --> 00:02:46,800
Honestly, most of the maths has gone well over my head, as it often does, but the broad

39
00:02:46,800 --> 00:02:52,000
ideas at least are encouragingly simple, so I think my goal for today is not to try and

40
00:02:52,000 --> 00:02:56,480
make some amazingly accurate simulation, but just to build a rough starting point from

41
00:02:56,480 --> 00:03:00,720
which we can delve deeper into the maths and physics in the future, when I'm hopefully

42
00:03:00,720 --> 00:03:02,480
a little bit smarter.

43
00:03:02,480 --> 00:03:07,760
Anyway, the first step to fixing that overlapping particle problem we were having is to be able

44
00:03:07,760 --> 00:03:11,680
to estimate the density of our fluid at any point.

45
00:03:11,680 --> 00:03:16,080
So I've just scattered our particles around randomly for this example, and of course since

46
00:03:16,080 --> 00:03:19,960
we're imagining that this represents some kind of fluid, in reality there should be

47
00:03:19,960 --> 00:03:24,560
way more particles in this, but we're always going to be limited by what our computers

48
00:03:24,560 --> 00:03:30,480
can handle, so to approximate reality, we can just cheat a little bit by blurring or

49
00:03:30,480 --> 00:03:35,360
smoothing out the few that we have, so that it appears more as a continuous field than

50
00:03:35,360 --> 00:03:37,680
a bunch of individual points.

51
00:03:37,680 --> 00:03:42,800
This simple idea is the basis of smoothed particle hydrodynamics, a technique introduced

52
00:03:42,800 --> 00:03:47,440
back in the 70s to help solve astrophysics problems and further our understanding of

53
00:03:47,440 --> 00:03:51,960
the universe, which today we'll be using for the equally lofty goal of making some

54
00:03:51,960 --> 00:03:54,840
little pixels go splash splash for our amusement.

55
00:03:54,840 --> 00:04:00,120
Alright, so to see how we're going to calculate this sort of density field we have here, let's

56
00:04:00,120 --> 00:04:05,280
zoom in on a single particle and define a smoothing radius, which gives us this circle

57
00:04:05,280 --> 00:04:10,000
of influence around the particle, where it will have maximum influence at the centre,

58
00:04:10,000 --> 00:04:13,280
falling off to no influence at all at the outer edge.

59
00:04:13,280 --> 00:04:18,040
Let's draw a little graph of this behaviour, so on the x-axis we'll have the distance

60
00:04:18,040 --> 00:04:22,120
from the centre of the particle, and because negative distance doesn't make a huge amount

61
00:04:22,120 --> 00:04:27,480
of sense, I'll just make the left side of the graph be a mirror of the positive side.

62
00:04:27,480 --> 00:04:32,760
Then the y-axis will represent the influence of the particle at any given distance, and

63
00:04:32,760 --> 00:04:36,920
let's say for now that our smoothing radius is just 1.

64
00:04:36,920 --> 00:04:41,240
So a simple simple function we could use would be something like this, just subtracting

65
00:04:41,240 --> 00:04:45,920
the distance from the radius and clamping it to never go below zero, and here's what

66
00:04:45,920 --> 00:04:48,240
that gives us.

67
00:04:48,240 --> 00:04:53,520
This is not very smooth though, so we could take that straight line and qubit for example,

68
00:04:53,520 --> 00:04:57,680
which will ease it out as it approaches zero.

69
00:04:57,680 --> 00:05:01,920
Another option if we wanted to be smooth at the start as well, would be to also square

70
00:05:01,920 --> 00:05:06,840
the radius and distance before subtracting them, and here's how that comes out.

71
00:05:06,840 --> 00:05:10,800
Obviously we could also try different powers or different functions altogether, I think

72
00:05:10,800 --> 00:05:14,680
it's mostly a case of just playing around and seeing what works best.

73
00:05:14,680 --> 00:05:17,100
But let's go with this one for now.

74
00:05:17,100 --> 00:05:21,260
So I've used that to write this little density function, which takes in the point we want

75
00:05:21,260 --> 00:05:25,680
to find the density at, and then for each particle it gets the distance to that sample

76
00:05:25,680 --> 00:05:30,200
point, which determines how much influence the particle has at that location, and then

77
00:05:30,200 --> 00:05:36,260
it simply increases the density by the particle's mass, multiplied by the influence value.

78
00:05:36,260 --> 00:05:40,860
And the mass I've just defined to always be one for simplicity.

79
00:05:40,860 --> 00:05:45,380
So let's test this quickly with an evenly spaced grid of particles, and I'll just try

80
00:05:45,380 --> 00:05:51,420
sampling the density at the centre here, with a radius of 0.5 for example.

81
00:05:51,420 --> 00:05:56,620
Now at the moment the density is coming to about 0.48, but if we squish the particles

82
00:05:56,620 --> 00:06:01,180
closer together, we can see that the density value goes up, which makes sense, and if we

83
00:06:01,180 --> 00:06:05,520
move them further apart, it goes down of course.

84
00:06:05,520 --> 00:06:08,800
But what about if we increase the smoothing radius?

85
00:06:08,800 --> 00:06:14,160
Well, our density value has just shut up through the roof, which is very concerning, because

86
00:06:14,160 --> 00:06:19,200
making the radius bigger should only make the result more blurry, which for this uniform

87
00:06:19,200 --> 00:06:23,220
grid of particles should actually have no effect on the density at all.

88
00:06:23,220 --> 00:06:25,280
So let's think about this a bit.

89
00:06:25,280 --> 00:06:30,760
For each particle we are calculating an influence value, which we could draw as a height, and

90
00:06:30,760 --> 00:06:34,760
here we can of course see the shape of our smoothing function emerge.

91
00:06:34,760 --> 00:06:39,200
Now we're effectively just adding all these heights together to create our density value,

92
00:06:39,200 --> 00:06:43,080
but it's kind of helpful to note that if we were to first also multiply the heights

93
00:06:43,080 --> 00:06:47,000
by the width and breadth of these little boxes I've drawn here, what we'd actually

94
00:06:47,000 --> 00:06:52,260
be doing is estimating the volume of the smoothing function.

95
00:06:52,260 --> 00:06:56,240
So with that in mind, I think it's reasonable to say that if we want the density to stay

96
00:06:56,240 --> 00:07:01,000
the same as we change the smoothing radius, then what we'll need to do is make sure that

97
00:07:01,000 --> 00:07:06,640
the volume of our smoothing function remains the same when we change the smoothing radius.

98
00:07:06,640 --> 00:07:10,440
That means we're going to need to calculate its volume, or make Wolfram calculated for

99
00:07:10,440 --> 00:07:16,560
us at any rate, and that is come out to pi times the smoothing radius to the power h

100
00:07:16,560 --> 00:07:18,480
divided by 4.

101
00:07:18,480 --> 00:07:22,760
We can then just go back to our smoothing function and calculate the volume in here,

102
00:07:22,760 --> 00:07:27,080
and then simply divide the output by the volume, which means that now the new volume of the

103
00:07:27,080 --> 00:07:30,400
function will always be 1.

104
00:07:30,400 --> 00:07:35,320
Let's quickly make sure this is working, so the density is 187 at the moment, and now

105
00:07:35,320 --> 00:07:40,360
if we change the smoothing radius that should stay the same, which it does.

106
00:07:40,360 --> 00:07:44,320
Of course if we make the radius too small, the results will get a little dodgy since

107
00:07:44,320 --> 00:07:49,080
there just aren't enough particles, but apart from that we now have a nice way of determining

108
00:07:49,080 --> 00:07:53,760
the density at any point, with whatever smoothing radius we choose to use.

109
00:07:53,760 --> 00:07:59,380
Ok, so let's return to our random arrangement of particles, and we can now properly visualize

110
00:07:59,380 --> 00:08:04,180
the density values here as we increase the smoothing radius.

111
00:08:04,180 --> 00:08:08,460
Now we're claiming that this represents a fluid, so one would probably assume it's

112
00:08:08,460 --> 00:08:13,180
a guess at the moment, because we have all these regions with different densities.

113
00:08:13,180 --> 00:08:19,300
But I'm more interested in simulating liquids today, which in practical terms are incompressible,

114
00:08:19,300 --> 00:08:23,500
meaning their molecules are packed together as tightly as they can be, and so we'd expect

115
00:08:23,500 --> 00:08:26,260
the density to be the same everywhere.

116
00:08:26,260 --> 00:08:30,020
For our simulation to behave at least somewhat like a liquid then, we're going to need

117
00:08:30,020 --> 00:08:35,860
to rapidly correct these density differences by moving particles from areas of high density

118
00:08:35,860 --> 00:08:38,100
towards areas of low density.

119
00:08:38,100 --> 00:08:42,740
So we need to figure out how to calculate that, but I started to get a bit confused at

120
00:08:42,740 --> 00:08:47,060
this point while I was doing my research, so I'd like to take a step back for a moment

121
00:08:47,060 --> 00:08:51,180
and just play around a bit with an abstract example to try and wrap my head around some

122
00:08:51,180 --> 00:08:57,260
stuff first, and then we'll come back and apply what we've learnt to our actual problem.

123
00:08:57,260 --> 00:09:02,140
So here's a simple little function that takes in a point in 2D space and outputs a single

124
00:09:02,140 --> 00:09:04,580
value, which looks like this.

125
00:09:04,580 --> 00:09:08,820
And what it represents is nothing at all, it's just a made up function that we're

126
00:09:08,820 --> 00:09:13,340
going to try and represent with particles to hopefully gain a better understanding of

127
00:09:13,340 --> 00:09:17,180
this whole smooth particle business we're working with today.

128
00:09:17,180 --> 00:09:22,020
So I've now added some code that spawns in a bunch of particles at random positions,

129
00:09:22,020 --> 00:09:26,460
and each of these just looks up the value of the example function at its location and

130
00:09:26,460 --> 00:09:30,980
stores that in this vaguely named particle properties array.

131
00:09:30,980 --> 00:09:35,460
Now we're going to pretend that we no longer have access to that example function for whatever

132
00:09:35,460 --> 00:09:40,700
reason, so we only know the values at the particle positions, and our first goal is

133
00:09:40,700 --> 00:09:44,020
to simply approximate the missing values.

134
00:09:44,020 --> 00:09:47,740
To do that, we'll use the same smoothing idea from when we calculated the density

135
00:09:47,740 --> 00:09:48,740
earlier.

136
00:09:48,740 --> 00:09:53,700
So I've made this little calculate property function that takes in a point in space, loops

137
00:09:53,700 --> 00:09:59,140
over all the particles, and just adds up the values of their properties multiplied by the

138
00:09:59,140 --> 00:10:03,260
smoothing function, since again that just tells us how much influence the particle has

139
00:10:03,260 --> 00:10:08,380
at the current point, and then also multiplied by the mass, since that effectively scales

140
00:10:08,380 --> 00:10:10,660
how much influence the particles have.

141
00:10:11,140 --> 00:10:15,980
Let's see how that comes out, so here's the original function again just for reference,

142
00:10:15,980 --> 00:10:18,180
and here's our approximation.

143
00:10:18,180 --> 00:10:22,660
Obviously, the shape isn't perfect, but we could simply use more particles to improve

144
00:10:22,660 --> 00:10:23,660
that.

145
00:10:23,660 --> 00:10:28,700
What's more concerning though is that the values are clearly being greatly exaggerated.

146
00:10:28,700 --> 00:10:33,380
Now we could try to correct this by reducing the particle mass, but that just reveals a

147
00:10:33,380 --> 00:10:38,180
deeper problem, which is that the values are being particularly exaggerated in regions

148
00:10:38,180 --> 00:10:43,020
of high particle density, since obviously more values are being added together there

149
00:10:43,020 --> 00:10:45,780
than in regions of low density.

150
00:10:45,780 --> 00:10:50,380
So to fix that, all we actually need to do is calculate the density at each particle,

151
00:10:50,380 --> 00:10:54,780
using the function we wrote earlier of course, and then divide each particle's contribution

152
00:10:54,780 --> 00:10:56,780
by its density.

153
00:10:56,780 --> 00:11:01,420
Now our approximated result looks like this, without needing to make any adjustments to

154
00:11:01,420 --> 00:11:07,940
the mass, which is a whole lot better, and it's reasonably close to the original function.

155
00:11:07,940 --> 00:11:12,500
So what we've arrived at here is actually one of the core equations of this whole technique,

156
00:11:12,500 --> 00:11:17,780
which says that to calculate some property a at any position x, we just need to loop

157
00:11:17,780 --> 00:11:22,740
over all the particles and add together the value of that property that's stored in

158
00:11:22,740 --> 00:11:28,420
each particle, multiplied by the particle's mass, divided by its density, and finally

159
00:11:28,420 --> 00:11:32,980
multiplied by the smoothing function, given the distance between the particle and the

160
00:11:32,980 --> 00:11:35,340
sample point.

161
00:11:35,340 --> 00:11:39,300
What's interesting to note here is, say that the property we want to calculate with

162
00:11:39,300 --> 00:11:43,180
this equation is the particle's density.

163
00:11:43,180 --> 00:11:47,620
In that case, we replace a with the density, which then cancels out with the density over

164
00:11:47,620 --> 00:11:52,260
here, leaving us with just mass times the smoothing function, which is exactly what

165
00:11:52,260 --> 00:11:57,140
we came up with in the beginning, so that bit of math seems to check out at least.

166
00:11:57,140 --> 00:12:01,740
Okay, that's nice and all, but what we're more interested in right now than calculating

167
00:12:01,740 --> 00:12:06,900
the value of a property at any point, is calculating in which direction it's most

168
00:12:06,900 --> 00:12:11,300
rapidly changing, since that's essential to our problem of correcting the density in

169
00:12:11,300 --> 00:12:12,660
our fluid.

170
00:12:12,660 --> 00:12:16,860
So I've started writing this little calculate gradient function to do that, and all this

171
00:12:16,860 --> 00:12:22,340
does is define a tiny step size, and then figure out how much the value changes if we

172
00:12:22,340 --> 00:12:27,660
take that tiny step along the x and y axes, using the calculate property function we just

173
00:12:27,660 --> 00:12:28,860
wrote.

174
00:12:28,860 --> 00:12:33,580
And the estimated gradient is just those two changes, each divided by the size of the step

175
00:12:33,580 --> 00:12:34,580
that we talk.

176
00:12:34,580 --> 00:12:39,100
Let's try it out, so I've drawn in some little arrows to visualize the gradients

177
00:12:39,100 --> 00:12:43,500
at different points, and just visually it looks like these are all correctly pointing

178
00:12:43,500 --> 00:12:47,180
along the direction where the values are most rapidly increasing.

179
00:12:47,180 --> 00:12:49,340
So that's great.

180
00:12:49,340 --> 00:12:53,980
What's less great is that it's taking almost 20 seconds to calculate all of these, which

181
00:12:53,980 --> 00:12:56,020
is ridiculously slow.

182
00:12:56,020 --> 00:12:59,140
Unfortunately though, there is a more efficient approach.

183
00:12:59,140 --> 00:13:03,380
Imagine we have just a single particle, and I'll draw on the smoothing radius here as

184
00:13:03,380 --> 00:13:08,340
well, and we're trying to calculate the gradient of whatever property at this point

185
00:13:08,340 --> 00:13:09,340
over here.

186
00:13:09,340 --> 00:13:14,580
Well, first of all, the direction in which that property will most rapidly be increasing

187
00:13:14,580 --> 00:13:19,860
is either directly towards the particle, or directly away from it if the property is negative,

188
00:13:19,860 --> 00:13:21,780
so that's easy enough.

189
00:13:21,780 --> 00:13:25,980
The gradient doesn't only tell us the direction though, but also how fast the property is

190
00:13:25,980 --> 00:13:30,980
changing, and that depends purely on our smoothing function.

191
00:13:30,980 --> 00:13:34,620
At the current distance, we can see that the smoothing function isn't very steep, which

192
00:13:34,620 --> 00:13:38,860
means that the property will be changing quite slowly over here, whereas of course if our

193
00:13:38,860 --> 00:13:43,980
sample point was over here for example, then it would be changing a lot more rapidly.

194
00:13:43,980 --> 00:13:53,660
So after struggling to remember how basic calculus works for a few minutes, I finally

195
00:13:53,660 --> 00:13:57,500
figured out the equation for the slope of the smoothing function, which I've just

196
00:13:57,500 --> 00:14:00,180
translated into code over here.

197
00:14:00,180 --> 00:14:06,020
And that means that we can now easily look up the slope value at any distance.

198
00:14:06,020 --> 00:14:10,060
So let's return to our fast attempt at the gradient function, and I'll delete the old

199
00:14:10,060 --> 00:14:14,740
code and replace it with our CalculateProperty code, since that's almost exactly what

200
00:14:14,740 --> 00:14:19,060
we need, except since we want to know the gradient now, we'll multiply not by the

201
00:14:19,060 --> 00:14:24,220
smoothing function, but by the slope of the smoothing function, and then also by the direction

202
00:14:24,220 --> 00:14:29,660
towards the current particle.

203
00:14:29,660 --> 00:14:35,260
By summing up all these individual gradients, we should logically get the overall gradient.

204
00:14:35,260 --> 00:14:39,580
Then if we return to our little visualization and just run it again, it should look exactly

205
00:14:39,580 --> 00:14:41,340
the same as before.

206
00:14:41,340 --> 00:14:45,580
Which it doesn't, I guess I got the direction back to front, so I'll just stick a minus

207
00:14:45,580 --> 00:14:46,900
sign in there quickly.

208
00:14:46,900 --> 00:14:50,820
I come from the trial and error school of mathematics, but now it does look the same

209
00:14:50,820 --> 00:14:52,420
as before.

210
00:14:52,420 --> 00:14:58,260
This optimization has taken us from 20 seconds down to about 5, which is still uselessly

211
00:14:58,260 --> 00:15:01,580
slow, but headed in the right direction at least.

212
00:15:01,580 --> 00:15:05,900
Okay, I've just been having another look at our gradient function, and we definitely

213
00:15:05,900 --> 00:15:08,460
need to stop calling CalculateDensity all the time.

214
00:15:08,460 --> 00:15:12,220
I somehow forgot already that that's also looping over all the particles.

215
00:15:12,220 --> 00:15:14,700
No wonder this is so slow.

216
00:15:14,700 --> 00:15:19,500
So what we can do is just create an array of density values, and then pre-calculate those

217
00:15:19,500 --> 00:15:25,900
for each particle, so that we can just use those cached values in our gradient function.

218
00:15:25,900 --> 00:15:31,140
That brings our computation time down from 5 seconds to 18 milliseconds.

219
00:15:31,140 --> 00:15:33,420
I probably should have started with that.

220
00:15:33,420 --> 00:15:38,340
Anyway, it's still not fantastic, but it's at least usable for now.

221
00:15:38,340 --> 00:15:42,780
So let's return at last to our little density test over here, and see if we can apply this

222
00:15:42,780 --> 00:15:46,780
gradient stuff to make the density be the same everywhere.

223
00:15:46,780 --> 00:15:51,500
So in the code, I've defined a target density that we want to aim for, along with a pressure

224
00:15:51,500 --> 00:15:56,100
multiplier, which is just how strongly we're going to push the particles to try and reach

225
00:15:56,100 --> 00:15:57,820
that density.

226
00:15:57,820 --> 00:16:02,180
Then I've also added this little function for converting the density to a kind of pressure

227
00:16:02,180 --> 00:16:06,900
value, and this just looks at how far away the density is from what we want it to be,

228
00:16:06,900 --> 00:16:10,060
and then multiplies that by the pressure multiplier.

229
00:16:10,060 --> 00:16:14,020
From what I understand, this isn't really a super realistic way to calculate pressures

230
00:16:14,020 --> 00:16:19,540
in a liquid, it more so describes the behavior of gases, but it still seems to be a popular

231
00:16:19,540 --> 00:16:23,540
choice for its simplicity, so let's stick with it for now at least.

232
00:16:23,540 --> 00:16:27,780
I would like to quickly visualize these values, so I've set up three different colors over

233
00:16:27,780 --> 00:16:32,260
here, one for the regions where it's negative, just meaning that the density is lower than

234
00:16:32,260 --> 00:16:36,780
we want it to be, another for where the value is positive, meaning of course that the density

235
00:16:36,780 --> 00:16:41,420
is higher than we want it to be, and finally one for the boundary between them, where the

236
00:16:41,420 --> 00:16:43,020
density is just right.

237
00:16:43,020 --> 00:16:47,860
I'll also change the particle color to black, so that it stands out a bit better here.

238
00:16:47,860 --> 00:16:52,620
Okay, so let's finally get these particles moving along the pressure gradient, and for

239
00:16:52,620 --> 00:16:57,220
that we can just use the gradient function we wrote, which I'll rename to calculate

240
00:16:57,220 --> 00:17:01,740
pressure force, and then the property we're interested in here is of course the pressure,

241
00:17:01,740 --> 00:17:06,460
so let's substitute in our little pressure calculation.

242
00:17:06,460 --> 00:17:11,340
Then our simulation update loop now looks like this, we still have the gravity, position,

243
00:17:11,340 --> 00:17:15,660
and collision stuff from before, but I've added in the density caching we decided to

244
00:17:15,660 --> 00:17:16,820
do.

245
00:17:16,820 --> 00:17:20,740
We still need to actually apply the pressure forces here though, so I'll make another

246
00:17:20,740 --> 00:17:25,220
loop quickly to calculate those for each of the particles, and then we know that force

247
00:17:25,220 --> 00:17:30,700
equals mass times acceleration, so acceleration is force over mass.

248
00:17:30,700 --> 00:17:35,500
So my first thought was to just calculate the acceleration like this, but actually we're

249
00:17:35,500 --> 00:17:40,860
thinking about the movement of tiny volumes of fluid here, and density is the mass per

250
00:17:40,860 --> 00:17:44,660
volume, so it's in fact the density that we want to use instead.

251
00:17:44,660 --> 00:17:48,900
Alright, all that's left then is to just increase the particles of velocity by this

252
00:17:48,900 --> 00:17:53,140
acceleration, and we can finally try it out.

253
00:17:53,140 --> 00:17:58,420
This has been a long time coming, so let's get a little drumroll going.

254
00:17:58,420 --> 00:18:03,380
Ah, the curse of the drumroll continues.

255
00:18:03,380 --> 00:18:08,180
Okay, the positions are all not a number I see, so most likely we're dividing by

256
00:18:08,180 --> 00:18:09,180
zero somewhere.

257
00:18:09,180 --> 00:18:14,380
Oh, of course, we're being given the position of a particle here, but then we're also

258
00:18:14,380 --> 00:18:18,580
looping over all the particles and finding the distance between the two.

259
00:18:18,580 --> 00:18:21,100
And that's where everything's going wrong.

260
00:18:21,100 --> 00:18:25,140
I guess what I'll do is just have this function take in the particle index instead of the

261
00:18:25,140 --> 00:18:29,620
position, and that way we can very easily just skip over the case where the two particles

262
00:18:29,620 --> 00:18:31,340
are the same.

263
00:18:31,340 --> 00:18:36,780
Okay, I just need to fix this up quickly, and I suppose it is technically possible for

264
00:18:36,780 --> 00:18:41,540
two different particles to be in the same position, so if that edge case occurs, let's

265
00:18:41,540 --> 00:18:44,100
just pick a random direction then.

266
00:18:44,100 --> 00:18:47,940
Alright, let's try this out again.

267
00:18:48,940 --> 00:18:53,620
Well, at least everything hasn't blinked out of existence, but the particles are getting

268
00:18:53,620 --> 00:18:56,860
more dense, which is the opposite of what we want.

269
00:18:56,860 --> 00:18:59,620
I guess I need to stick another minus sign in there somewhere.

270
00:18:59,620 --> 00:19:03,380
Let's see if this works now at the third time.

271
00:19:03,380 --> 00:19:10,300
Okay, that's… that was looking promising for a moment there, for a brief instant I

272
00:19:10,300 --> 00:19:11,540
thought it was working.

273
00:19:11,540 --> 00:19:14,460
But there's still a lot more red areas than I'm hoping to see.

274
00:19:14,460 --> 00:19:19,900
Ideally, the whole screen should turn white, since that represents our target density.

275
00:19:19,900 --> 00:19:23,740
So to try and figure out what's going on, I want to see what happens if, instead of

276
00:19:23,740 --> 00:19:28,660
adding the acceleration to the velocity, we just assign it directly, so we're removing

277
00:19:28,660 --> 00:19:32,940
any inertia from the particles, they're just purely moving based on the current pressure

278
00:19:32,940 --> 00:19:33,940
force.

279
00:19:33,940 --> 00:19:39,180
Okay, if we run this now, nothing happens, but that's fine, we aren't accumulating

280
00:19:39,180 --> 00:19:43,300
velocity anymore, so I guess we just need to turn the pressure multiplier up really

281
00:19:43,300 --> 00:19:44,300
high.

282
00:19:44,300 --> 00:19:47,300
Alright, that looks interesting.

283
00:19:47,300 --> 00:19:51,500
I am a bit surprised by how close together some of these particles are, although they

284
00:19:51,500 --> 00:19:54,860
seem to gradually be pushing each other apart.

285
00:19:54,860 --> 00:19:58,560
And I actually remember one of the papers mentioning this potential problem with the

286
00:19:58,560 --> 00:20:03,300
smoothing function we're using, since its slope becomes very shallow as the distance

287
00:20:03,300 --> 00:20:07,860
becomes small, meaning that our pressure force will also be small when the particles are

288
00:20:07,940 --> 00:20:09,740
close together.

289
00:20:09,740 --> 00:20:15,380
That seems odd, so let's maybe ditch this nice smooth curve for the spiky version instead,

290
00:20:15,380 --> 00:20:19,060
since of course the slope of this one just gets steeper towards zero.

291
00:20:19,060 --> 00:20:23,780
So I had to do the volume and derivative calculations again, but ended up with these

292
00:20:23,780 --> 00:20:26,020
two functions here.

293
00:20:26,020 --> 00:20:30,220
Plugging those in, we can see our little map looks just ever so slightly different, and

294
00:20:30,220 --> 00:20:35,460
then I'm going to turn up the pressure multiplier again now, and see what happens.

295
00:20:36,420 --> 00:20:38,980
Okay, that's looking a lot better actually.

296
00:20:38,980 --> 00:20:42,940
The question now though is what does it look like if we put the acceleration back to how

297
00:20:42,940 --> 00:20:44,700
it's supposed to be.

298
00:20:44,700 --> 00:20:50,860
So I've changed it back, and I'm going to try running this again.

299
00:20:50,860 --> 00:20:55,060
Let's maybe try increasing the pressure multiplier a bit, so that the particles can react more

300
00:20:55,060 --> 00:20:57,380
quickly.

301
00:20:57,380 --> 00:21:01,860
That's looking reasonably good I think, although maybe I'm imagining this, but it

302
00:21:01,860 --> 00:21:05,380
seems to be getting worse over time.

303
00:21:05,380 --> 00:21:11,060
Okay, I'm definitely not imagining it.

304
00:21:11,060 --> 00:21:15,620
So another thing we need to think about is Newton's third law of motion.

305
00:21:15,620 --> 00:21:24,660
Every force has an equal and opposite reaction force.

306
00:21:24,660 --> 00:21:28,780
So when we're adding on this pressure force between the current particle and some other

307
00:21:28,780 --> 00:21:34,420
particle, we want to make sure that the other particle experiences the same force, just in

308
00:21:34,420 --> 00:21:35,420
the other direction.

309
00:21:35,420 --> 00:21:40,380
I've seen a bunch of different suggestions on how to actually do this, but a nice simple

310
00:21:40,380 --> 00:21:45,620
version is to calculate this shared pressure, which is literally just the average of the

311
00:21:45,620 --> 00:21:49,940
pressure values calculated at both particles.

312
00:21:49,940 --> 00:21:58,580
So let's try that out quickly, and I'll just increase the pressure multiplier again.

313
00:21:58,580 --> 00:22:01,500
And this does seem to have made a pretty big difference.

314
00:22:01,500 --> 00:22:05,100
I guess maybe that Newton guy was onto something.

315
00:22:05,100 --> 00:22:09,140
Now we're only dealing with a few hundred particles at the moment, which is not very

316
00:22:09,140 --> 00:22:14,780
many, so let's ramp this up to a few thousand instead.

317
00:22:14,780 --> 00:22:18,220
And this is running at 5 frames per second.

318
00:22:18,220 --> 00:22:20,420
So we'd better start optimizing.

319
00:22:20,420 --> 00:22:24,900
And by far the most critical place to do that is when we're calculating the densities

320
00:22:24,900 --> 00:22:29,940
and pressure forces, we should rarely avoid looping over all the particles that lie outside

321
00:22:29,940 --> 00:22:34,220
of the smoothing radius, since those don't contribute anything, and they're slowing

322
00:22:34,220 --> 00:22:37,020
us down immensely.

323
00:22:37,020 --> 00:22:41,680
To do this, we're going to need to chop space up into a grid, and we'll choose the size

324
00:22:41,680 --> 00:22:46,820
of the grid cells to be the same as our smoothing radius, since that means, if we imagine there's

325
00:22:46,820 --> 00:22:51,380
a bunch of particles on here, that means that to find the particles inside of the smoothing

326
00:22:51,380 --> 00:22:57,620
radius, we only need to consider the 3x3 grid of cells around the center of our circle.

327
00:22:57,620 --> 00:23:05,180
And in that way of course, we cut out a huge amount of unnecessary work.

328
00:23:05,180 --> 00:23:09,500
Now to actually implement this, we could say that each cell has its own list that grows

329
00:23:09,500 --> 00:23:13,780
or shrinks to hold however many particles are currently inside of it.

330
00:23:13,780 --> 00:23:17,660
But we're probably going to want to convert the whole simulation to a compute shader at

331
00:23:17,660 --> 00:23:22,780
some point to run on the GPU, and there we need to be able to specify ahead of time how

332
00:23:22,780 --> 00:23:24,700
much memory we're going to use.

333
00:23:24,700 --> 00:23:29,020
So I'd like to experiment with a different GPU friendly approach, which I've been reading

334
00:23:29,020 --> 00:23:31,260
about in this paper here.

335
00:23:31,260 --> 00:23:35,100
I'm going to modify it very slightly though, so that we don't need to know the dimensions

336
00:23:35,100 --> 00:23:39,620
of the grid ahead of time, meaning that particles can travel anywhere in the world, and it'll

337
00:23:39,620 --> 00:23:42,380
still work.

338
00:23:42,380 --> 00:23:48,300
So what we'll do is create a single array with at least as many entries as we have particles,

339
00:23:48,300 --> 00:23:53,660
so here it has 10 entries, meaning in this case we could have at most 10 particles.

340
00:23:53,660 --> 00:23:57,220
Then for each of these particles, we're going to calculate the coordinate of the cell that

341
00:23:57,220 --> 00:23:58,220
it's in.

342
00:23:58,220 --> 00:24:04,980
So for example particle 0, which happens to be this one over here, is in the cell 2,0.

343
00:24:04,980 --> 00:24:09,260
We need to turn that coordinate into a single number to make it easy to work with though,

344
00:24:09,260 --> 00:24:13,980
so we can just do something like multiply the x and y by two different prime numbers,

345
00:24:13,980 --> 00:24:17,820
and then add them together to get some arbitrary hash value.

346
00:24:17,820 --> 00:24:22,140
We can then wrap that around the length of the array so that it becomes a valid index,

347
00:24:22,140 --> 00:24:28,500
3 in this case, and let's call that our cell key, not to be confused with the seal people.

348
00:24:28,500 --> 00:24:34,780
So since this was point 0, we'll store the cell key over here at index 0 in the array.

349
00:24:34,780 --> 00:24:40,060
And the next point, it turns out, has a key of 6, and so we'll record that in the next

350
00:24:40,060 --> 00:24:41,420
place.

351
00:24:41,420 --> 00:24:48,100
And so on and so forth for all of the particles that we have.

352
00:24:48,100 --> 00:24:52,500
Now we want the points that share a cell to be next to one another in this array, so that

353
00:24:52,500 --> 00:24:54,740
we can efficiently loop over them.

354
00:24:54,740 --> 00:24:59,260
Of course if they're in the same cell, they're going to have the same cell key, so we can

355
00:24:59,260 --> 00:25:03,420
simply sort the list based on those keys to do that.

356
00:25:03,420 --> 00:25:08,420
And now we can easily see from this array that particles 2, 5 and 7 are all together

357
00:25:08,420 --> 00:25:14,180
in the same cell, particle 0 is in a cell all by itself, and so on.

358
00:25:14,180 --> 00:25:19,620
Anyway, let's call this array our spatial lookup, because that sounds nice and fancy,

359
00:25:19,620 --> 00:25:24,420
and then the final thing we need to do is create a second array of start indices, which

360
00:25:24,420 --> 00:25:26,100
looks like this.

361
00:25:26,100 --> 00:25:29,500
To understand this second array, let's just do a quick example.

362
00:25:29,500 --> 00:25:33,580
So say we want to know which points are in this cell over here.

363
00:25:33,580 --> 00:25:38,460
We would first calculate the cell's key like before, which is 9 in this case.

364
00:25:38,460 --> 00:25:43,180
And then we'd proceed to look up the 9th element in the array of start indices, which

365
00:25:43,180 --> 00:25:46,500
is this last one over here, the number 6.

366
00:25:46,500 --> 00:25:50,700
That lets us know that we need to head over to index 6 in the spatial lookup, in order

367
00:25:50,700 --> 00:25:54,760
to find the first entry with the cell key that we're interested in.

368
00:25:54,760 --> 00:25:58,740
We can then simply loop over all of those to get the indices of the particles that are

369
00:25:58,740 --> 00:26:00,660
in that cell.

370
00:26:00,660 --> 00:26:05,580
Unfortunately it is possible for different cells to end up mapping to the same key,

371
00:26:05,580 --> 00:26:10,380
which would mess with these results, but we're anyway going to need to do distance checks

372
00:26:10,380 --> 00:26:15,180
to see which points are actually inside the smoothing radius, and so that'll get rid

373
00:26:15,180 --> 00:26:16,780
of any mistakes.

374
00:26:16,780 --> 00:26:21,300
Obviously, having to check extra particles from some other random cell that just happens

375
00:26:21,300 --> 00:26:25,820
to have the same key does waste time, but that's what we get for trying to implement

376
00:26:25,820 --> 00:26:30,340
an infinite grid with a sadly non-infinite amount of memory.

377
00:26:30,340 --> 00:26:36,180
Anyway, turning this concept into code didn't go as smoothly as it possibly could have,

378
00:26:36,180 --> 00:26:39,860
but after a bit of frustration, here's what I finally ended up with.

379
00:26:39,860 --> 00:26:44,480
We have a function for updating the lookup whenever the points have moved, and this just

380
00:26:44,480 --> 00:26:50,820
calculates the cell key for every particle, and records that along with the particle index.

381
00:26:50,820 --> 00:26:56,180
The array is then sorted based on those keys, and lastly the start indices are calculated,

382
00:26:56,180 --> 00:27:00,740
simply by testing if each key is the same as the key that came before it, because if

383
00:27:00,740 --> 00:27:05,780
not then it must be the first occurrence of that key, and we can record its index as the

384
00:27:05,780 --> 00:27:06,780
start index.

385
00:27:06,780 --> 00:27:11,980
Here are the little helper functions, by the way, for calculating the cell coordinate,

386
00:27:11,980 --> 00:27:14,900
hash, and key.

387
00:27:14,900 --> 00:27:18,740
Then finally there's the function that allows us to actually find all of the points within

388
00:27:18,740 --> 00:27:21,980
the radius of some given sample point.

389
00:27:21,980 --> 00:27:26,300
This works as we've seen by just looping over the 3x3 block of cells around that sample

390
00:27:26,300 --> 00:27:29,820
point, and calculating each of their keys.

391
00:27:29,820 --> 00:27:33,980
Each key is then used to look up the start index for that cell, so we can loop over all

392
00:27:33,980 --> 00:27:38,460
the points in the cell, and of course once we reach a point that has a different key,

393
00:27:38,460 --> 00:27:40,500
we just exit out of the loop.

394
00:27:40,500 --> 00:27:44,700
All that remains then is to do a quick distance check to make sure the point is actually inside

395
00:27:44,700 --> 00:27:49,220
the circle, and then we can do whatever we want with it.

396
00:27:49,220 --> 00:27:54,540
Trying this out now, we've gone from barely 5 frames per second up to 120, so there was

397
00:27:54,540 --> 00:27:59,780
a reasonable success, but I'd be a lot happier about it if our simulation wasn't in total

398
00:27:59,780 --> 00:28:03,980
chaos over here.

399
00:28:03,980 --> 00:28:08,580
One clunky way I found to improve this is to simply start off with a really low pressure

400
00:28:08,580 --> 00:28:09,980
multiplier.

401
00:28:09,980 --> 00:28:14,220
This way the particles don't have such a huge initial burst of acceleration, and they

402
00:28:14,220 --> 00:28:18,820
can spread out a little, and then we just gradually increase the multiplier, and it

403
00:28:18,820 --> 00:28:21,900
seems to work a bit better at least.

404
00:28:21,900 --> 00:28:26,220
That's not really a usable solution though, so I've just been implementing an IGRI

405
00:28:26,220 --> 00:28:30,460
read about where we basically predict what the next position of each particle is going

406
00:28:30,460 --> 00:28:36,260
to be, simply based on the current velocity, and use those predicted positions when calculating

407
00:28:36,260 --> 00:28:39,060
the densities and pressure forces.

408
00:28:39,060 --> 00:28:44,900
I guess this could help the particles to better react to upcoming situations, and maybe compensate

409
00:28:44,900 --> 00:28:49,780
a bit for the fact that time is obviously not continuous in a computer simulation, but

410
00:28:49,780 --> 00:28:52,580
rather broken up into discrete steps.

411
00:28:52,580 --> 00:28:54,580
Okay, let's try it out.

412
00:28:54,580 --> 00:29:00,980
I honestly don't see it making a big difference though.

413
00:29:00,980 --> 00:29:04,300
Never mind, it's actually making a pretty massive difference I'd say.

414
00:29:04,300 --> 00:29:07,340
Well, that's a nice surprise.

415
00:29:07,420 --> 00:29:11,620
Also fun, I've quickly gone into the particle rendering code I have here, and just set it

416
00:29:11,620 --> 00:29:16,260
up so that we can visualise the speed of the particles with a colour.

417
00:29:16,260 --> 00:29:20,100
Then here's a little gradient I made for that, so the slowest particles will appear

418
00:29:20,100 --> 00:29:25,700
blue, fading to red for the fastest particles.

419
00:29:25,700 --> 00:29:30,300
I also added in some simple controls for things like pausing the simulation, stepping through

420
00:29:30,300 --> 00:29:34,460
frame by frame, and resetting it.

421
00:29:41,100 --> 00:29:44,460
Alright, I've been playing around with this some more, and one thing I've noticed

422
00:29:44,460 --> 00:29:49,060
is that it behaves very inconsistently at different simulation frame rates.

423
00:29:49,060 --> 00:29:53,860
Here's a little grid of simulations I set up to observe this problem, so we're going

424
00:29:53,860 --> 00:29:59,580
from 60 simulation steps per second on the top left, to almost 1000 steps per second

425
00:29:59,580 --> 00:30:01,140
on the bottom right.

426
00:30:01,140 --> 00:30:06,700
And as we can see here, if the number of steps is higher, meaning the time step is smaller,

427
00:30:06,700 --> 00:30:11,220
and so we're predicting less fine to the future, the particles take longer to settle

428
00:30:11,220 --> 00:30:12,700
down.

429
00:30:12,700 --> 00:30:16,700
So even though this feels a bit wrong to me, I'm going to try just removing the delta

430
00:30:16,700 --> 00:30:21,100
time here, and use a constant look ahead factor instead.

431
00:30:21,100 --> 00:30:26,460
Let's then run the same comparison again, and interestingly it is actually behaving

432
00:30:26,460 --> 00:30:28,300
a lot more consistently now.

433
00:30:28,780 --> 00:30:32,100
Well okay, I guess we'll go with that then.

434
00:30:32,100 --> 00:30:36,380
Now I think it'd be fun if we could interact with the particles in some way, so I've written

435
00:30:36,380 --> 00:30:41,100
this little function that basically just pulls nearby particles in towards the mouse, or

436
00:30:41,100 --> 00:30:45,940
pushes them away if the input strength is negative, which is controlled by left or right

437
00:30:45,940 --> 00:30:47,700
clicking.

438
00:30:47,700 --> 00:30:54,180
So let's give it a shot, I'm going to start by pushing these particles outwards,

439
00:30:54,180 --> 00:30:57,180
and then let's try slicing through the fluid.

440
00:31:00,180 --> 00:31:04,220
Alright, I feel like this is slowly starting to get somewhere.

441
00:31:04,220 --> 00:31:09,300
Clearly, we haven't really succeeded in our goal of making this fluid incompressible,

442
00:31:09,300 --> 00:31:13,860
it's certainly compressing and expanding all over the place, but the density does even

443
00:31:13,860 --> 00:31:18,740
out over time, so that's something at least, and we can look into fancier methods to try

444
00:31:18,740 --> 00:31:21,060
and solve this better in the future.

445
00:31:21,540 --> 00:31:26,140
Anyway, now that this seems to be somewhat working at any rate, I think it's time we

446
00:31:26,140 --> 00:31:29,620
brought gravity back into the mix.

447
00:31:29,620 --> 00:31:33,900
So I'll reset this quickly, and let's bring in our settings window.

448
00:31:33,900 --> 00:31:38,340
I feel like the density could maybe be set a bit higher, so I'll turn that up, and then

449
00:31:38,340 --> 00:31:41,060
let's get the simulation going again.

450
00:31:41,060 --> 00:31:45,460
Okay, I guess that's a little too high now.

451
00:31:45,460 --> 00:31:52,460
So, I'll dial that setting back down a bit.

452
00:31:52,460 --> 00:31:56,300
Then, let's turn on the gravity.

453
00:31:56,300 --> 00:32:00,660
Wait, that's upside down, let me make it go the other way instead.

454
00:32:00,660 --> 00:32:04,980
The particles are quite wild at the moment, so I'll also increase the pressure multiplier

455
00:32:04,980 --> 00:32:08,580
to try and drain them in a little.

456
00:32:09,580 --> 00:32:19,220
Okay, let's try picking up a ball of water.

457
00:32:19,220 --> 00:32:21,340
And dropping it back in.

458
00:32:21,340 --> 00:32:23,340
Splash.

459
00:32:23,340 --> 00:32:27,420
This is actually working surprisingly well I'd say, I mean I realise I've been droning

460
00:32:27,420 --> 00:32:31,620
on for over half an hour already, but all that we've really done is made a bunch of

461
00:32:31,620 --> 00:32:36,700
points that don't like to be too close together, but not too far apart either.

462
00:32:36,700 --> 00:32:40,980
And while this is obviously far from being super realistic or anything, I think it's

463
00:32:40,980 --> 00:32:45,660
still quite fascinating that this fluid-like behaviour has already arisen from just the

464
00:32:45,660 --> 00:32:55,180
few little things we've implemented.

465
00:32:55,180 --> 00:32:59,460
Anyway, let's see if we can still improve this at least a little bit more today, and

466
00:32:59,460 --> 00:33:02,860
perhaps even venture into the third dimension.

467
00:33:02,860 --> 00:33:05,580
So a few issues are jumping out to me at the moment.

468
00:33:05,580 --> 00:33:09,740
For example, there's the fact that the particles are really tightly squeezed together along

469
00:33:09,740 --> 00:33:14,900
the edges here, and that's causing a gap between the rest of the particles since they're

470
00:33:14,900 --> 00:33:17,900
trying to get away from that overly dense region.

471
00:33:17,900 --> 00:33:22,820
And a similar effect seems to be happening along the surface of the fluid as well.

472
00:33:22,820 --> 00:33:27,420
Another thing is that when we have fast-moving particles, such as when starting up the simulation

473
00:33:27,420 --> 00:33:31,820
for instance, the fluid seems to be overly chaotic.

474
00:33:31,820 --> 00:33:36,260
For example, if we zoom in on a single frame here, we can see from these colours how the

475
00:33:36,260 --> 00:33:41,100
velocities are all over the place, even between nearby regions.

476
00:33:41,100 --> 00:33:45,300
For this last problem at least, I think it'd be a good idea to try and add a bit of friction

477
00:33:45,300 --> 00:33:50,620
between the particles in the fluid, more commonly known as viscosity.

478
00:33:50,620 --> 00:33:55,500
So let's actually take a moment to look at the famous Navier-Stokes equations for incompressible

479
00:33:55,500 --> 00:33:59,780
fluid flow, which underpin everything that we've been doing.

480
00:33:59,780 --> 00:34:03,540
First of all, this equation here just says that the density of the fluid must remain

481
00:34:03,540 --> 00:34:07,820
the same everywhere, and I mean, we're trying.

482
00:34:07,820 --> 00:34:12,420
Then the other equation tells us that each tiny little volume of fluid is accelerated

483
00:34:12,420 --> 00:34:18,260
down the pressure gradient, and that it responds to external forces such as gravity and mice

484
00:34:18,260 --> 00:34:22,100
in our case, so we've done both of those terms.

485
00:34:22,100 --> 00:34:26,620
But then this slightly scary looking term here is the viscosity, and essentially what

486
00:34:26,620 --> 00:34:32,460
it does is cause the velocities of nearby regions of fluid to become blurred together.

487
00:34:32,460 --> 00:34:36,660
Now we could implement it this way, but for today at least, I actually want to go with

488
00:34:36,660 --> 00:34:40,780
a different approach I've seen that seems much simpler, but still achieves the same

489
00:34:40,780 --> 00:34:42,220
sort of thing.

490
00:34:42,220 --> 00:34:46,700
So I've added this little function here, which just takes in the index of a particle,

491
00:34:46,700 --> 00:34:50,780
and loops over all the other particles within the smoothing radius.

492
00:34:50,780 --> 00:34:54,300
For each of those, it then calculates the difference between the velocities of the two

493
00:34:54,300 --> 00:35:00,380
particles, and adds that on to the viscosity force, meaning that over time, each particle's

494
00:35:00,380 --> 00:35:05,100
velocity will become more like its neighbors, and nearby neighbors have more influence as

495
00:35:05,100 --> 00:35:10,060
usual, which is done using this viscosity kernel, for which I've just repurposed that

496
00:35:10,060 --> 00:35:13,580
function that we were originally using for the pressure force.

497
00:35:13,580 --> 00:35:16,060
Okay, let's try it out.

498
00:35:16,060 --> 00:35:20,980
Oh, my settings have been reset, so we're back to no gravity at the moment, but let's

499
00:35:20,980 --> 00:35:22,660
see what that looks like.

500
00:35:22,860 --> 00:35:27,500
Currently, our viscosity is at zero, so let's turn it up, I'm not sure what a good value

501
00:35:27,500 --> 00:35:30,860
would be, let's just try 5 maybe.

502
00:35:30,860 --> 00:35:34,340
Nope, definitely not, that looks very strange.

503
00:35:34,340 --> 00:35:38,420
My guess is that the viscosity is just way too high at the moment, and so some of these

504
00:35:38,420 --> 00:35:42,740
particles are almost exactly matching one another in velocity, and that's causing

505
00:35:42,740 --> 00:35:45,100
them to clump together weirdly.

506
00:35:45,100 --> 00:35:50,140
So let's reduce it to maybe 0.5 instead, and see how that goes.

507
00:35:51,140 --> 00:35:54,420
Okay, this is looking pretty good actually.

508
00:35:54,420 --> 00:35:58,500
We can see how the particle velocities are more smoothed out, and so we no longer have

509
00:35:58,500 --> 00:36:02,900
those few particles with super high velocities shooting off on their own.

510
00:36:02,900 --> 00:36:07,700
I want to see how this looks with gravity enabled again, so I've set up a quick comparison

511
00:36:07,700 --> 00:36:14,220
here with a range of different viscosity values, and let's see how it goes.

512
00:36:14,220 --> 00:36:21,660
I think the one on the top right looked best to me, but let's see that again quickly.

513
00:36:25,660 --> 00:36:29,500
And I'll freeze it here actually, because this gives us a nice view of the increasingly

514
00:36:29,500 --> 00:36:33,660
smoothed out results we get with this new artificial viscosity term.

515
00:36:33,660 --> 00:36:37,220
Obviously, we don't want to smooth out too much detail though, so I'm going to keep

516
00:36:37,220 --> 00:36:39,100
that value pretty low.

517
00:36:39,100 --> 00:36:43,980
Okay, now I'm not quite sure yet how to tackle that boundary problem I mentioned earlier,

518
00:36:43,980 --> 00:36:47,860
so I'm going to just ignore that for now, and instead work on something else that's

519
00:36:47,860 --> 00:36:49,260
bothering me.

520
00:36:49,260 --> 00:36:54,780
If we lift up a bunch of water, and then let it go, we can see how it quickly splits up

521
00:36:54,780 --> 00:37:01,660
into these little droplets of just a few particles each, which looks a little strange.

522
00:37:01,660 --> 00:37:05,340
We could get rid of this behaviour by simply clamping the pressure values that they can't

523
00:37:05,340 --> 00:37:11,060
go below zero, meaning that the particles won't pull each other together anymore.

524
00:37:11,060 --> 00:37:14,740
So let's try that out.

525
00:37:14,740 --> 00:37:19,900
But now the particles are just raining down individually, which doesn't look right either.

526
00:37:19,900 --> 00:37:24,380
I guess allowing that negative pressure was giving us a very crude kind of surface tension

527
00:37:24,380 --> 00:37:29,260
effect, and so I think until we implement a more accurate version of that in a future

528
00:37:29,260 --> 00:37:33,020
video perhaps, we should probably hang on to it.

529
00:37:33,020 --> 00:37:37,380
So I'm going to undo that change, and instead I want to try an interesting workaround one

530
00:37:37,380 --> 00:37:42,900
of the papers suggested, which is to simply have a second pressure force, purely for pushing

531
00:37:42,900 --> 00:37:46,680
apart particles that get too close together.

532
00:37:46,680 --> 00:37:50,660
So this is the shape of the smoothing function we're using for our density calculation at

533
00:37:50,660 --> 00:37:55,820
the moment, and what the paper recommends is to use another, even spikier version, to

534
00:37:55,820 --> 00:37:59,700
calculate what they call the near density.

535
00:37:59,700 --> 00:38:04,020
From this near density, we calculate the near pressure, simply by multiplying it by some

536
00:38:04,020 --> 00:38:08,900
constant, meaning that this will be a purely repulsive force.

537
00:38:08,900 --> 00:38:12,700
So let's try it out quickly, and just for fun, I'm going to see what happens if we

538
00:38:12,700 --> 00:38:15,860
make the near pressure multiplier negative.

539
00:38:15,860 --> 00:38:21,860
Okay, they just collapse in on one another, which makes sense, so let's then try a positive

540
00:38:21,860 --> 00:38:23,660
value.

541
00:38:23,660 --> 00:38:31,420
And now I want to try picking up a ball of fluid again, and dropping it.

542
00:38:31,420 --> 00:38:36,620
And as we can see, this time it's able to hold its shape a lot better, since the particles

543
00:38:36,620 --> 00:38:41,380
are no longer getting pulled into those tiny clusters we saw before.

544
00:38:41,380 --> 00:38:45,900
So I think we've succeeded in improving the fluid a bit with these last two changes,

545
00:38:45,900 --> 00:38:49,900
although I'm certainly not entirely happy with how it's behaving yet.

546
00:38:49,900 --> 00:38:54,340
For example, something that bothers me quite a lot is how it often appears to sort of bounce

547
00:38:54,340 --> 00:38:57,020
more like a jelly than a liquid.

548
00:38:57,020 --> 00:39:01,340
This is happening pretty much all the time, but we can see a dramatic example if I just

549
00:39:01,340 --> 00:39:07,700
let the fluid come to a rest, and then change the target density for example.

550
00:39:07,700 --> 00:39:12,380
Now we could get less jiggly results simply by increasing the pressure multiplier, which

551
00:39:12,380 --> 00:39:16,100
is often called the stiffness constant by the way.

552
00:39:16,100 --> 00:39:21,380
So here I've set up a little test where it has a value of 1000, and if I change the

553
00:39:21,380 --> 00:39:26,820
density now, we can see that it does settle down a lot more quickly.

554
00:39:26,820 --> 00:39:30,780
But that doesn't come for free though, because the greater the forces in our fluid are, the

555
00:39:30,780 --> 00:39:36,340
more simulation steps we need to run per frame to avoid things devolving into chaos.

556
00:39:36,340 --> 00:39:40,600
For example, if I just lower the number of steps here slightly, we can see that already

557
00:39:40,600 --> 00:39:44,220
we're on the brink of pandemonium.

558
00:39:44,220 --> 00:39:50,340
Anyway, I'm sure we'll learn about ways to overcome, or at least improve this problem

559
00:39:50,340 --> 00:39:55,140
in the future, but for right now what I'd like to do is finally convert the whole simulation

560
00:39:55,140 --> 00:40:00,060
to a computer shader, so that we can run it on the GPU, which excels at doing loads

561
00:40:00,060 --> 00:40:06,260
of tiny tasks in parallel, which should be a perfect fit for our particle calculations.

562
00:40:06,260 --> 00:40:09,180
I doubt that'll take very long, so I'll see you in a minute.

563
00:40:25,140 --> 00:40:53,100
Ok, I kept finding new and creative ways to mess everything up, but this finally seems

564
00:40:53,100 --> 00:40:56,220
to be running properly in a computer shader.

565
00:40:56,220 --> 00:40:59,940
I'll still need to test the performance with more particles of course, but just glancing

566
00:40:59,940 --> 00:41:06,180
at the FPS counter looks promising so far, hovering at around 500 frames per second.

567
00:41:06,180 --> 00:41:11,500
By far the trickiest part was translating just one line of code, the array.sort from our

568
00:41:11,500 --> 00:41:13,140
neighbourhood search.

569
00:41:13,140 --> 00:41:17,380
I ended up spending quite a while trying to figure out how to implement a parallel sorting

570
00:41:17,380 --> 00:41:21,420
algorithm called bitonic merge sort to replace it.

571
00:41:21,420 --> 00:41:26,140
In particular, I was trying to generate this pattern of lines, and generalize it for any

572
00:41:26,140 --> 00:41:27,860
number of inputs.

573
00:41:27,860 --> 00:41:33,500
The inputs here are represented by the horizontal lines, and we have 16 of them in this case,

574
00:41:33,500 --> 00:41:36,460
meaning that this network can sort 16 values.

575
00:41:36,460 --> 00:41:42,100
Let's actually assign a random value to each input, so we can see how this goes.

576
00:41:42,100 --> 00:41:47,380
Then each of these little vertical lines represents a pair of inputs that we're going to compare,

577
00:41:47,380 --> 00:41:49,820
and potentially swap around.

578
00:41:49,820 --> 00:41:54,140
So to start with, we're going to look at each of the 8 pairs that we have over here,

579
00:41:54,140 --> 00:41:58,940
and let's say we want to sort from high to low, so in the first pair we have 5 on top

580
00:41:58,940 --> 00:42:03,860
and 3 on the bottom, which we're happy with, so that can stay unchanged.

581
00:42:03,860 --> 00:42:08,860
In the next pair though, we can see 7 on top and 8 on the bottom, so the bottom is a higher

582
00:42:08,860 --> 00:42:13,140
number which is not ok, and we'll need to swap them around.

583
00:42:13,140 --> 00:42:17,380
So we can look at all these pairs in parallel, figure out which need to be swapped, and then

584
00:42:17,380 --> 00:42:18,880
swap them.

585
00:42:18,880 --> 00:42:22,960
Of course this alone is unlikely to sort the list, so once that's done we'll need

586
00:42:22,960 --> 00:42:25,480
to continue to the next stage.

587
00:42:25,480 --> 00:42:30,600
Here the pairs are arranged a little differently, but the operation is still exactly the same.

588
00:42:30,600 --> 00:42:35,520
We can see this first pair has 5 on top, 7 on the bottom, so it will need to swap, as

589
00:42:35,520 --> 00:42:46,180
will this pair with 3 on top and 8 on the bottom, and so on.

590
00:42:46,180 --> 00:42:50,340
This pattern has been carefully devised by some clever person, such that following it

591
00:42:50,340 --> 00:42:57,100
will do all the comparisons required to guarantee that the result is fully sorted by the end.

592
00:42:57,100 --> 00:43:00,860
For anyone interested, I'll quickly show the implementation I came up with, so this

593
00:43:00,860 --> 00:43:06,020
part runs on the CPU and is responsible for simply looping through each of those patterns,

594
00:43:06,020 --> 00:43:09,280
and telling the GPU to sort the pairs.

595
00:43:09,280 --> 00:43:13,220
And then here's the code that actually does that pairwise sorting, so it starts by just

596
00:43:13,220 --> 00:43:16,700
figuring out which pair of numbers it's actually looking at, and then it compares

597
00:43:16,700 --> 00:43:21,300
them to see if they need to be swapped, and if they do, it of course swaps them.

598
00:43:21,300 --> 00:43:26,260
Alright, I've been doing some testing with different amounts of particles, so here is

599
00:43:26,260 --> 00:43:30,940
100 particles for example, and I think it's kind of cute watching these little droplets

600
00:43:30,940 --> 00:43:32,620
wobble about.

601
00:43:32,620 --> 00:43:38,260
Then after that I tried 100,000 particles, but my computer was not happy about that,

602
00:43:38,260 --> 00:43:41,860
so there's definitely a lot of room left for optimization.

603
00:43:42,860 --> 00:43:47,420
Here's a test with about 40,000 particles though, which seems to be running okay, although

604
00:43:47,420 --> 00:43:50,940
I'll have to fine tune the settings of course, because at the moment there are some weird

605
00:43:50,940 --> 00:43:54,700
tendrils shooting out of the liquid, and I really don't know why.

606
00:43:54,700 --> 00:43:59,420
Or perhaps we could call this a speculative simulation of how liquids might behave on an

607
00:43:59,420 --> 00:44:01,260
alien planet.

608
00:44:01,260 --> 00:44:04,620
The settings are definitely quite finicky at the moment though, so that's something

609
00:44:04,620 --> 00:44:08,060
else I want to improve.

610
00:44:08,060 --> 00:44:11,780
Here's another little test I've set up by the way, and this one has an obstacle over

611
00:44:11,780 --> 00:44:16,220
here with a gap beneath it, because I just want to see if this simulation is able to

612
00:44:16,220 --> 00:44:22,180
keep the height of the liquid the same on both sides.

613
00:44:22,180 --> 00:44:26,700
So I'm just going to start bucketing some of this liquid over to the other end here,

614
00:44:26,700 --> 00:44:31,940
and then let's grab another blob, and another, and then let's just wait a bit for this to

615
00:44:31,940 --> 00:44:36,140
settle down, but already we can see the height gradually leveling out.

616
00:44:36,140 --> 00:44:40,380
So even though our simulation is far from being super realistic, it's nice to say at

617
00:44:40,380 --> 00:44:43,500
least that it's not entirely unrealistic either.

618
00:44:43,500 --> 00:44:48,340
Okay, now as always there's so much more I still want to do, but to end with for today,

619
00:44:48,340 --> 00:44:52,300
let's see if we can get this working in the third dimension.

620
00:44:52,300 --> 00:44:57,780
This basically just means replacing a bunch of float 2s with float 3s in the compute shader,

621
00:44:57,780 --> 00:45:02,460
as well as updating the scaling factors of the various smoothing functions and their

622
00:45:03,220 --> 00:45:07,420
and making sure our neighborhood search is aware of this brand new dimension as well,

623
00:45:07,420 --> 00:45:08,420
of course.

624
00:45:08,420 --> 00:45:13,820
I've also updated the collision function to work in 3D, and I tweaked it to account

625
00:45:13,820 --> 00:45:18,940
for the bounding box being moved or rotated as well as scaled, simply by transforming

626
00:45:18,940 --> 00:45:24,740
the points and velocities to its local coordinate system, then resolving those the same as before,

627
00:45:24,740 --> 00:45:30,220
and then finally transforming them back into world coordinates.

628
00:45:30,220 --> 00:45:34,580
My first attempt at running this did not go particularly well, but after some trial

629
00:45:34,580 --> 00:45:39,100
and error with the settings I managed to get this rather goopy looking result, and with

630
00:45:39,100 --> 00:45:42,740
a few more tweaks from there I was finally able to get something that I was reasonably

631
00:45:42,740 --> 00:45:48,340
happy with.

632
00:45:48,340 --> 00:45:52,580
So let's just play around with this a bit, I'm going to try squeezing it together,

633
00:45:52,580 --> 00:45:56,180
and what's nice about how we implemented the neighborhood search stuff, is that we

634
00:45:56,180 --> 00:46:00,380
aren't constrained to any predetermined bounds, so we can stretch this out however much we

635
00:46:00,380 --> 00:46:09,260
want as well, and it should still work.

636
00:46:09,260 --> 00:46:12,980
Those little waves were looking quite nice I think, so let's actually smush this together

637
00:46:12,980 --> 00:46:27,140
again, and then try that out once more.

638
00:46:27,140 --> 00:46:31,180
Now another thing to add to my list of a million things I want to improve is how the

639
00:46:31,180 --> 00:46:34,100
fluid is actually rendered.

640
00:46:34,100 --> 00:46:38,060
These little balls are good for seeing what's going on of course, but it would be nice to

641
00:46:38,060 --> 00:46:42,620
make it actually look more fluid like, and I guess some sort of ray matching is probably

642
00:46:42,620 --> 00:46:49,660
a good way to approach that, but we'll have to see.

643
00:46:49,660 --> 00:46:54,740
So let me actually make a quick note here of my sort of wish list for this project.

644
00:46:54,740 --> 00:46:59,940
I want the simulation to be more stable and performant so that we can have many more particles,

645
00:46:59,940 --> 00:47:04,180
and I'd like the parameters to be less finicky so it's easier to get good results, and also

646
00:47:04,180 --> 00:47:08,100
for the particles to behave better along the boundaries, because it looks really odd at

647
00:47:08,100 --> 00:47:09,860
the moment.

648
00:47:09,860 --> 00:47:13,220
Another thing that'll be really nice is to be able to do stuff like put little boats

649
00:47:13,220 --> 00:47:18,020
or rubber ducks in the water, and just watch them bob about.

650
00:47:18,020 --> 00:47:23,300
Then finally of course there's the rendering stuff I just mentioned as well.

651
00:47:23,300 --> 00:47:27,260
So plenty of work for the future, but until then I hope you've enjoyed following along

652
00:47:27,260 --> 00:47:29,220
with the process so far.

653
00:47:29,220 --> 00:47:33,620
Okay, that's all for today, let me know if you have any suggestions for this project

654
00:47:33,620 --> 00:47:35,700
or for anything else you'd like to see.

655
00:47:35,700 --> 00:47:38,220
Alright, thanks for watching and goodbye.

