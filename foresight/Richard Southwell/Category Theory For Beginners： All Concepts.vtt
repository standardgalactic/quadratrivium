WEBVTT

00:00.000 --> 00:08.720
Okay, so what we're going to do this time is to talk about the most powerful concepts

00:08.720 --> 00:10.920
in category theory.

00:10.920 --> 00:16.480
So to introduce this, I'd like to talk about planets.

00:16.480 --> 00:20.240
You see, planets are very complicated.

00:20.240 --> 00:25.440
I don't think anyone truly understands planets fully.

00:25.440 --> 00:31.320
Nobody's walked all around a planet, nobody's drilled into the center of a planet.

00:31.320 --> 00:39.120
However, it's very interesting that through astronomy, basically by observing the interactions

00:39.120 --> 00:45.840
of many planets and many celestial bodies, we can gain a tremendous amount of understanding

00:45.840 --> 00:48.920
about the nature of planets.

00:48.920 --> 00:54.640
And I think it's very similar with some of these highly abstract structures in category

00:54.640 --> 00:56.200
theory.

00:56.200 --> 00:58.600
So there are certain kinds of structures.

00:58.600 --> 01:05.440
I'm talking about things like can extensions, weighted co-limits, co-ends.

01:05.440 --> 01:11.240
There are these kind of structures which are so general that every other concept in category

01:11.240 --> 01:16.680
theory can be explained in terms of these things.

01:16.680 --> 01:23.400
And this leads to quotes like all concepts are can extensions, which is a famous quote

01:23.400 --> 01:25.840
by Saunders MacLean.

01:25.840 --> 01:32.880
And so it's really remarkable that these kind of highly abstract, super general concepts

01:32.880 --> 01:34.600
do exist.

01:34.600 --> 01:40.800
And in a sense, if we can understand them, it gives us a way to understand everything

01:40.800 --> 01:43.800
else in our theory.

01:43.800 --> 01:50.600
Now the issue, a bit like with a planet, is that when one focuses directly on something

01:50.600 --> 01:57.280
like the notion of can extensions, they can look rather complicated and difficult to understand

01:57.280 --> 01:59.240
in isolation.

01:59.240 --> 02:04.880
And so the approach we're going to take today is to investigate the sort of interactions

02:04.880 --> 02:07.360
between these different concepts.

02:07.360 --> 02:11.840
How can these different ideas be related to each other?

02:11.840 --> 02:15.840
And it's really remarkable how this is going to end up.

02:15.840 --> 02:22.080
It's as if what we have here is some kind of like a family of fractal structures, each

02:22.080 --> 02:28.960
of which is so kind of rich that that fractal contains all of the other fractals in the

02:28.960 --> 02:29.960
family.

02:29.960 --> 02:36.400
So we could, for example, explain what weighted co-limits and co-ends are in terms of can

02:36.400 --> 02:43.120
extensions, or we could decide that we want to explain what things are in terms of weighted

02:43.120 --> 02:46.360
co-limits and weighted limits and so on.

02:46.360 --> 02:52.360
So basically we want to explore how these super powerful concepts are interrelated.

02:52.360 --> 02:55.920
And this is going to be a very, very profitable thing to do.

02:55.920 --> 03:00.920
I mean, in a sense, I view this video as a kind of celebration of how far we've come

03:00.920 --> 03:07.200
because now we can define and explore these super general concepts.

03:07.200 --> 03:12.880
It's kind of as if we've got above the clouds of category theory and we can see these great

03:12.880 --> 03:18.360
peaks, these super powerful structures and how they're related to each other.

03:18.360 --> 03:23.640
And so what we're going to do today, we're going to start by recapping the idea of can

03:23.640 --> 03:25.600
extensions.

03:25.600 --> 03:30.800
And then we're going to get to these fascinating ideas of your need or extension and freco

03:30.800 --> 03:31.800
completion.

03:31.800 --> 03:36.680
And we're going to see how all of these other fascinating concepts kind of spring from there

03:36.680 --> 03:37.680
like a fountain.

03:37.680 --> 03:43.120
Okay, so this is one of the most informative videos I think I've put on YouTube.

03:43.120 --> 03:46.720
And I wanted to give some recommendations about how to watch it.

03:46.720 --> 03:50.520
So my main one would be 2x.

03:50.520 --> 03:57.560
So for the first hour or so of this video, I would recommend watching it on double speed.

03:57.560 --> 04:04.920
The reason is because I like to try and define everything I'm talking about, but when we

04:04.920 --> 04:12.600
get into can extensions and so on, the kind of level of abstraction is going to go up.

04:12.600 --> 04:16.760
So this is sort of the first hour.

04:16.760 --> 04:21.880
And you know, with most people, it gets to a point when it's kind of difficult to understand

04:21.880 --> 04:24.080
on a first viewing.

04:24.080 --> 04:27.480
So I would recommend watching the thing on double speed.

04:27.480 --> 04:33.760
And then once we kind of get through the definition of can extensions and onto freco completions,

04:33.760 --> 04:41.920
like the level of abstraction decreases and we start looking at lots of examples.

04:41.920 --> 04:44.280
And these examples are seriously beautiful.

04:44.840 --> 04:48.000
Especially this idea of a density theorem.

04:48.000 --> 04:54.200
It's basically like the idea that, for example, you can take a graph and you can make it out

04:54.200 --> 04:59.520
of vertices and edges by kind of gluing them together, but there's a sort of recipe that

04:59.520 --> 05:02.280
works for any graph for doing that.

05:02.280 --> 05:08.200
And it just comes directly out of the maths that we've been looking at for free.

05:08.200 --> 05:12.600
And the same idea applies for all sorts of other structures like dynamical systems and

05:12.720 --> 05:15.120
plus your sets and all sorts of things.

05:15.120 --> 05:16.480
It's it's pretty crazy.

05:16.480 --> 05:21.360
It's it's almost like a universal recipe for making structures that we're going to kind

05:21.360 --> 05:22.520
of get to.

05:22.520 --> 05:25.320
And that's just one of the things that we're going to get to.

05:25.320 --> 05:32.880
We're going to get to understand about profunctals and co-ends and loads of really interesting

05:32.880 --> 05:33.880
things.

05:33.880 --> 05:40.200
And so I'd say that the kind of level of insights which can be derived from this video

05:40.240 --> 05:43.360
is going to sort of go up like this.

05:43.360 --> 05:52.160
And so the the thing really is to get past this kind of hump where we're setting up the

05:52.160 --> 05:56.000
initial structures, and it seems like it's kind of abstract.

05:56.000 --> 06:00.840
And that's why I'd recommend watching this thing on double speed, because, you know,

06:00.840 --> 06:07.080
we can kind of zoom through this on a first viewing and then look at these fascinating

06:07.080 --> 06:12.640
applications, and then that's going to hopefully give you the motivation to go back and watch

06:12.640 --> 06:18.240
the thing again, slowly get the pen and paper, try and follow all the diagrams.

06:18.840 --> 06:26.480
And a lot of this stuff is in Emily Reels book, Category Theory in Context, which I

06:26.480 --> 06:34.280
highly recommend, particularly in one of the last chapters, she talks about can extensions

06:34.520 --> 06:39.160
and it's a very nice clear description of can extensions where you can look at all of

06:39.160 --> 06:46.160
the kind of formulas, details, proofs of things that I've been talking about and dig

06:46.160 --> 06:48.160
into those in more detail.

06:48.880 --> 06:50.680
So, yeah, I hope you enjoy.

06:51.880 --> 06:54.840
OK, so let me start with the idea of can extensions.

06:55.320 --> 07:00.160
I have talked about them before, but they're a pretty abstract concept.

07:00.160 --> 07:04.640
And I think they're worth introducing again, especially because I think I might

07:04.640 --> 07:08.520
have found a slightly kind of easier way to introduce them.

07:08.880 --> 07:10.560
So let's start with this question.

07:10.960 --> 07:12.920
What comes next in this sequence?

07:15.480 --> 07:18.240
OK, you can pause the video and think about it.

07:19.080 --> 07:27.440
Now, most people would say the next number in this sequence zero to four would be six.

07:28.440 --> 07:35.520
However, it's important to realize that there are mathematical sequences that don't go like this.

07:36.600 --> 07:42.320
There are some mathematical sequences that go zero to four, five, for example.

07:43.720 --> 07:55.200
And so really this question of what comes next in a sequence is not really usually very

07:55.520 --> 08:02.480
well defined, but it is an instance of something called an extension problem, which very roughly

08:02.480 --> 08:09.480
speaking is kind of like a problem of extending a pattern to a larger structure.

08:10.800 --> 08:12.200
So let's have a look at that.

08:14.120 --> 08:17.080
Here's how we can view that as an extension problem.

08:18.080 --> 08:30.400
Let's take this set here, one, two, three, as C, and this set here of numbers on a right.

08:30.400 --> 08:32.120
Let's call that E.

08:34.720 --> 08:44.480
Now, the sequence that I talked about initially can be represented by a function.

08:45.480 --> 08:53.480
The first number was zero, the second number was two, the third number was four.

08:54.480 --> 08:58.480
And then I asked what should be the next thing in this sequence.

08:59.480 --> 09:09.480
And so a way we can visualize what's going on is to say that what we want to do is we want to extend the domain

09:10.480 --> 09:13.480
of this function or the source set of this function.

09:15.480 --> 09:20.480
And so what we could say is instead of having a function that goes from the set one, two, three,

09:21.480 --> 09:24.480
we want to think about a function that goes from the set one, two, three, four.

09:25.480 --> 09:34.480
But the crucial thing is that that function ought to act similarly on the values one, two, and three.

09:34.480 --> 09:38.480
So a way we can formalize this is as follows.

09:39.480 --> 09:47.480
We know that let's consider this slightly larger source set here, D.

09:48.480 --> 10:02.480
Now, we know that there is a inclusion function like this from C to D.

10:02.480 --> 10:09.480
Let's call this inclusion function K and let's call this thing that we started with F.

10:10.480 --> 10:24.480
And so now our problem is to find a function from D to E, which acts like F does on the values that came from C.

10:24.480 --> 10:34.480
So just like in this case down here, this function that we want to cook up ought to send one to zero,

10:35.480 --> 10:41.480
and it ought to send two to two, and it ought to send three to four.

10:42.480 --> 10:46.480
Now the question we basically want to know is where should we send four?

10:46.480 --> 10:55.480
And like I was saying, there isn't really a well-defined answer, but we could send four to six, just to finish the pattern.

10:56.480 --> 11:08.480
And so what we're really doing here is we're trying to find an extension of the function F to this set D here that has a larger domain.

11:09.480 --> 11:17.480
And the key property that we want this extension to have is that this diagram commutes.

11:18.480 --> 11:32.480
So if we call this new purple function G, then the key property that we are sort of trying to get here is that G after K equals F.

11:32.480 --> 11:47.480
And you can see that, right? If you pick anything in C and then you do K upon it, and then you do G upon it, you get to the same answer as if you do F upon it.

11:48.480 --> 12:05.480
So this is the extension problem, but what I've sort of been trying to illustrate with my what number comes next problem is that extension problems involving sets and functions don't usually have unique solutions.

12:05.480 --> 12:14.480
So let's think about this situation I've just described a bit more abstractly.

12:15.480 --> 12:21.480
OK, we could say that what we've just drawn here is something that's happening in the category set.

12:22.480 --> 12:43.480
All right, so in other words, we could say, well, we have sets C D and E and we are given an arrow F from C to E in the category set and an arrow K from C to D.

12:44.480 --> 12:55.480
And then this extension problem is defined an arrow G such that G after K equals F.

12:56.480 --> 12:59.480
That's the idea of an extension problem.

13:00.480 --> 13:03.480
And you can think about extension problems in any category.

13:04.480 --> 13:21.480
Now, for can extensions, we're sort of going to think about extension problems in cat in the category of categories, but there's a bit of a twist.

13:22.480 --> 13:25.480
You see, you've probably got a bit of a flavor now.

13:25.480 --> 13:34.480
You see, you've probably got a bit of intuition now that's telling you, well, extension problems don't normally have unique solutions.

13:34.480 --> 13:35.480
And this is true.

13:36.480 --> 13:37.480
It's true in set.

13:37.480 --> 13:38.480
It's true in cat.

13:39.480 --> 13:46.480
If you want to get just a diagram that commutes like this on the nose, it's not easy.

13:46.480 --> 13:56.480
Usually there won't be a unique way to extend a particular arrow to make a triangle commute on the nose.

13:57.480 --> 14:06.480
And so the idea with can extensions is that we sort of relax what we're asking for a little bit.

14:06.480 --> 14:17.480
We're not really asking for a G, which is exactly going to make.

14:19.480 --> 14:25.480
We're not really asking for a G that's exactly going to make a diagram like this commute.

14:26.480 --> 14:42.480
Instead, we're going to use some kind of two cells or natural transformations to make it so that this kind of problem basically does have a unique solution, at least up to isomorphism.

14:43.480 --> 14:53.480
So basically, we want to sort of warp this extension problem into something that can be described through universal properties.

14:54.480 --> 15:00.480
And so for the problem of can extensions, well, firstly, it's taking place in cats.

15:00.480 --> 15:06.480
So our objects are going to be categories and our arrows are going to be functals.

15:06.480 --> 15:13.480
But the crucial thing is that we're not just looking for a functal G to close this triangle.

15:13.480 --> 15:25.480
What we're looking for is a pair of a functal G and a natural transformation, which we call eta.

15:27.480 --> 15:32.480
And G here is going to have a special name.

15:33.480 --> 15:39.480
It's called the left can extension of F along K.

15:40.480 --> 15:48.480
And so this is the data that defines a can extension.

15:51.480 --> 15:54.480
I'm just going to talk about left can extensions today.

15:55.480 --> 15:58.480
Right can extensions are very, very similar.

15:58.480 --> 16:02.480
Again, they're talked about in my other video.

16:02.480 --> 16:05.480
They're basically just the dual concept.

16:05.480 --> 16:10.480
But basically what I'm going to do today is look at some really nice structures.

16:11.480 --> 16:22.480
But everything I talk about can be dualized so you can have a lot of fun understanding all the duals of these concepts.

16:22.480 --> 16:26.480
But basically the idea of can extensions is like this.

16:27.480 --> 16:36.480
You're given a functal F from C to E and a functal K from C to D.

16:37.480 --> 16:47.480
And what the can extension consists of is a functal from D to E, which is called the left can extension of F along K,

16:47.480 --> 16:56.480
together with a natural transformation, eta from F to land KF after K.

16:57.480 --> 17:06.480
And that kind of data has to satisfy a certain sort of universal property.

17:07.480 --> 17:09.480
What is that universal property?

17:09.480 --> 17:17.480
Well, it's the normal kind of idea that if we make any kind of similar structure.

17:17.480 --> 17:31.480
So a functal H from D to E and a natural transformation alpha from F to H after K.

17:32.480 --> 17:42.480
Well, then there's going to exist a unique way to convert the real deal into this sort of phony candidate.

17:42.480 --> 17:44.480
What do I mean by that?

17:44.480 --> 17:51.480
I mean that there's going to exist a unique natural transformation.

17:53.480 --> 18:00.480
Let's call it gamma.

18:02.480 --> 18:09.480
Which is such that if we compose these two cells here, we get this one.

18:10.480 --> 18:14.480
Now here's a place I think some people get confused, right?

18:14.480 --> 18:22.480
Because they would say, well, I don't understand what it means to compose gamma with eta here.

18:23.480 --> 18:31.480
Because this is some kind of peculiar notation and notion of composing two cells.

18:31.480 --> 18:38.480
In this case, natural transformations, which is not fully explained in many places.

18:38.480 --> 18:43.480
So what's it mean to compose this with this?

18:43.480 --> 18:45.480
Well, it's illustrated down here.

18:45.480 --> 19:03.480
So basically the meaning of this is this is the composition of this natural transformation here, shown in green, after the natural transformation eta.

19:03.480 --> 19:06.480
What's this natural transformation here shown in green?

19:06.480 --> 19:15.480
This is gamma horizontally composed with the identity natural transformation of K.

19:15.480 --> 19:20.480
So this is the so-called whiskering of gamma with K.

19:20.480 --> 19:25.480
And it really is just this horizontal composition, which is indicated here.

19:25.480 --> 19:35.480
And you can look back at my video on natural transformations to remind yourself about how horizontal composition works, if you like.

19:35.480 --> 19:44.480
But the basic idea then with can extensions is it's one of these kind of universal constructions.

19:44.480 --> 19:52.480
And what we say is we say, well, I have this function F and this function K.

19:52.480 --> 19:58.480
I wish to find the left can extension of F along K.

19:58.480 --> 20:10.480
That consists of a function like this from D to E together with this natural transformation eta, which has this kind of form.

20:10.480 --> 20:25.480
And this has to and is defined by having the universal property that for any similar such thing, basically for any alpha and H,

20:25.480 --> 20:29.480
such that alpha is natural transformation from H after K to F.

20:29.480 --> 20:39.480
We have that there's going to exist a unique gamma such that if we compose gamma with eta,

20:39.480 --> 20:44.480
which basically ends up giving this kind of result.

20:44.480 --> 20:49.480
Well, that result ought to equal alpha.

20:49.480 --> 21:12.480
So basically, the pattern is that we want one K F and eta such that for anything similar.

21:12.480 --> 21:24.480
So for H and alpha, there's going to exist a unique gamma that makes this a quality hold.

21:24.480 --> 21:25.480
OK, then.

21:25.480 --> 21:30.480
So this video isn't really focused on can extensions particularly.

21:30.480 --> 21:37.480
And I don't think it's necessary to have a really in depth understanding of them,

21:37.480 --> 21:45.480
but I can't resist just going over the basic sort of formulas for them and things.

21:45.480 --> 21:55.480
So we're concerned with thinking about the left can extension of a functor F along K.

21:55.480 --> 22:08.480
Now, the meaning of that, at least the way I think of it is think that we're trying to extend the domain of this functor F.

22:08.480 --> 22:13.480
And we're trying to extend it to this larger domain D.

22:13.480 --> 22:18.480
So for these purposes, you could think of K as a sort of inclusion functor.

22:18.480 --> 22:26.480
And so sort of F is defined on C, but we want to sort of extend it to a larger domain.

22:26.480 --> 22:31.480
So we're sort of extending it along this inclusion functor.

22:31.480 --> 22:37.480
Although in truth, K doesn't have to be an inclusion functor.

22:37.480 --> 22:42.480
It doesn't have to be a monomorphism or anything like that.

22:42.480 --> 22:51.480
However, we are going to make some assumptions to make it easier for us to think about these can extensions.

22:51.480 --> 23:00.480
So recall that we say that a collection is small when it's a set.

23:00.480 --> 23:07.480
Recall that to set up category theory to speak about things like the category set.

23:07.480 --> 23:14.480
We really have to go sort of beyond set theory, otherwise we run into Russell's paradoxes and things like this.

23:14.480 --> 23:22.480
So we should really say that a category has a class of objects if we want to.

23:22.480 --> 23:35.480
I mean, it depends how which sort of method we want to use to overcome these kind of problems of collections which are too large.

23:35.480 --> 23:49.480
But anyway, so a category small when it has a set of objects or maybe just like a finite set of objects or it could be an infinite set or whatever.

23:49.480 --> 23:55.480
So the category set is not small because there isn't a set of sets.

23:55.480 --> 23:58.480
Otherwise, we'd be in paradox country.

23:58.480 --> 24:00.480
So set is not small.

24:00.480 --> 24:02.480
It has too many objects.

24:02.480 --> 24:06.480
So we're going to suppose now that C here is small.

24:06.480 --> 24:17.480
And we're going to suppose that D is locally small, which means that if we pick any pair of objects, the collections of arrows from A to B is forming a set.

24:17.480 --> 24:21.480
And we're also going to suppose that E is co-complete.

24:21.480 --> 24:27.480
That means that there's going to be a co-limit of every small diagram in E.

24:27.480 --> 24:41.480
So in other words, if we take any small category like C and we do a functor, there's always going to be a co-limit of that functor.

24:41.480 --> 24:52.480
So for example, it could be that E is set or E could be any category of pre-sheaves.

24:52.480 --> 24:54.480
It could be a category of vector spaces.

24:54.480 --> 24:57.480
There's loads and loads of co-complete categories.

24:57.480 --> 25:00.480
And we're going to suppose that E is one of those.

25:00.480 --> 25:08.480
And so with these assumptions, we can really understand the structure of these can extensions.

25:08.480 --> 25:17.480
So in particular, whenever we have these assumptions holding, this left-can extension here is always going to exist.

25:17.480 --> 25:20.480
And I'll tell you the formula for it.

25:20.480 --> 25:23.480
So here's the formula for it.

25:23.480 --> 25:33.480
So Lang K of F is going to be a functor from D to E.

25:33.480 --> 25:40.480
And so we need to really describe how this functor works on objects of D and arrows of D.

25:40.480 --> 25:42.480
So what about objects?

25:42.480 --> 25:47.480
So what about if we have an object, little D of D?

25:47.480 --> 25:49.480
What does Lang K F do to it?

25:49.480 --> 25:52.480
Well, it sends it to this thing here.

25:52.480 --> 25:57.480
And you see that this is a co-limit of a diagram in E.

25:57.480 --> 26:02.480
And in particular, it's given by this composition here.

26:02.480 --> 26:08.480
So what we have here is the comma category.

26:08.480 --> 26:20.480
So we have this functor K from C to D.

26:20.480 --> 26:32.480
And we're sort of slicing or comering that with this functor little D from a trivial category into big D.

26:32.480 --> 26:38.480
And so this thing here is a comma category.

26:38.480 --> 26:44.480
In some previous videos, I wrote it with this notation instead with the downwards arrow, but I prefer to slice now.

26:44.480 --> 26:57.480
But anyway, you can see my video on universal properties or the video on Khan extensions for more details about comma categories.

26:57.480 --> 27:01.480
Here's the very, very brief recap.

27:01.480 --> 27:06.480
The objects of K slice D look like this.

27:06.480 --> 27:14.480
The arrows of K slice D look like this arrow H from C to C dash that should make these kind of diagrams commute.

27:14.480 --> 27:25.480
OK, so let's write this thing that we get when we do our left Khan extension on D as LD.

27:25.480 --> 27:30.480
So you see that this is given by a co-limit.

27:30.480 --> 27:35.480
And so this thing here is going to be an object of category E.

27:35.480 --> 27:42.480
But it's also going to come with this sort of universal cone, which we'll call lambda D.

27:42.480 --> 27:52.480
So that should, of course, be a natural transformation from this functor here to a constant functor.

27:52.480 --> 27:55.480
So that will be delta LD.

27:55.480 --> 28:01.480
That sends everything in this category here to this object LD of E.

28:01.480 --> 28:07.480
So we could pretty much define this as to say it's this composition here.

28:07.480 --> 28:19.480
And that's why I'm writing this equals sign here to say that this little triangle at the bottom here to say that this triangle at the bottom here commutes.

28:19.480 --> 28:28.480
So this is telling us how this functor here is defined on objects.

28:28.480 --> 28:31.480
How is it defined on arrows?

28:31.480 --> 28:48.480
Well, basically, if we have an arrow G from D to D dash, then this kind of...

28:48.480 --> 28:58.480
So I mean, basically, if we have an arrow G, then it's going to get sent by our left Khan extension of K along F to this arrow Q here,

28:58.480 --> 29:05.480
which is going to be unique such that this kind of triangle commutes.

29:05.480 --> 29:09.480
So I don't really want to go into the minutiae of this.

29:09.480 --> 29:14.480
Basically, this is a diagram in a functor category.

29:14.480 --> 29:26.480
And we know that there's going to be a unique arrow that makes this thing commute because this is like a universal cone.

29:26.480 --> 29:29.480
And what we have here is a horizontal composition.

29:29.480 --> 29:36.480
And this functor here works on objects like this and works on arrows like the identity.

29:36.480 --> 29:38.480
I'm not going to dwell on this.

29:38.480 --> 29:46.480
If you watch my video on Khan extensions, I go through all this in much more detail.

29:46.480 --> 29:55.480
But I just wanted to quickly show you how you can calculate all the parts of these Khan extensions.

29:55.480 --> 30:05.480
And so the final bit is how do we actually calculate this natural transformation here, this eta?

30:05.480 --> 30:09.480
And basically the formulas over here.

30:09.480 --> 30:17.480
So this is the key formula here.

30:17.480 --> 30:25.480
Where this lambda here is our sort of universal cone, which comes from calculating that co-limit I was talking about before.

30:25.480 --> 30:35.480
So the point really is that when these conditions hold, we have all these nice formulas to be able to compute this left-can extension.

30:35.480 --> 30:41.480
Actually, I should just say quickly that something else really, really nice happens in this case.

30:41.480 --> 30:52.480
In fact, we can think of this LAN-K thing here as a functor, which goes from this functor category here to this functor category here.

30:52.480 --> 30:57.480
And it's actually just going to be the left adjoint of K star.

30:57.480 --> 31:00.480
So let's remember our setup.

31:00.480 --> 31:06.480
We have this functor K, which goes from C to D.

31:06.480 --> 31:10.480
And that means that we can form this functor K star.

31:10.480 --> 31:15.480
And basically this just works by pre-composition.

31:15.480 --> 31:20.480
So it works according to this formula here or this expression here.

31:20.480 --> 31:34.480
If we have an object of D comma E as in a functor G from D to E, then K star just sends that to G after K, which is going to be a functor from C to E.

31:34.480 --> 31:45.480
And you can see that it sends this arrow beta here of this category to this arrow here of this category.

31:45.480 --> 31:54.480
So it's very cool because basically we can also think of these can extensions in terms of adjoint functors.

31:54.480 --> 32:01.480
Basically, we're just computing the left adjoint of K star.

32:01.480 --> 32:03.480
And this is LAN-K.

32:03.480 --> 32:14.480
And then if we take an object of this category here like F, well, if we operate LAN-K on F, then we get the thing that comes from this triangle here.

32:14.480 --> 32:20.480
Which is the way that we originally defined this left can extension.

32:20.480 --> 32:35.480
And so it's very cool that when we have all these conditions holding these ones here, like it's not just that we can compute the left can extension of F or on K.

32:35.480 --> 32:42.480
We can compute the left can extension of any functor from C to E or on K.

32:42.480 --> 32:55.480
And actually that gives us those all sort of fit together to give us this sort of bigger functor, which allows us to go between these two functor categories.

32:55.480 --> 33:00.480
Just to finish, you know, to complete the picture.

33:01.480 --> 33:15.480
For this adjunction, there should be a unit, of course, which should go from this identity functor here to K star after LAN-K.

33:15.480 --> 33:27.480
If we look at a general component of this natural transformation E to dash, well, let's say we look at the F component, it should have this kind of form.

33:27.480 --> 33:32.480
And can you guess what it is? Well, it's just exactly Eta.

33:32.480 --> 33:41.480
It's exactly the natural transformation that fills in the triangle from the definition of the left can extension in the first place.

33:41.480 --> 33:47.480
So there we are, a sort of very quick recap of can extensions.

33:47.480 --> 34:01.480
And now let's get on to a really fascinating application of these things where we're going to think about all sorts of things to do with free co-completions and density,

34:01.480 --> 34:12.480
and how we can make lots of objects by sticking other objects together and co-ends and all sorts of really fascinating connections with lots of things in maths.

34:12.480 --> 34:14.480
So let's go.

34:14.480 --> 34:21.480
Okay, and here's one final result, which is going to be really useful for us to simplify things.

34:21.480 --> 34:34.480
And it basically says that in a special case, which is going to occur for us frequently, there's some details of these can extensions that becomes simpler.

34:34.480 --> 34:38.480
So we're going to keep with this assumption here.

34:38.480 --> 34:43.480
And in that case, we have this result holding.

34:43.480 --> 34:57.480
And it says that if this K here is a fully faithful functor, which basically means that it acts like a kind of bijection on Homsets.

34:57.480 --> 35:16.480
In other words, this is going to, for example, send the arrows from C to C dash to the arrows from K C to K C dash.

35:16.480 --> 35:22.480
And it should always do that kind of thing like a bijection if it's fully faithful functor.

35:22.480 --> 35:35.480
Well, in that case, we have that this ether here, this kind of natural transformation that fills in the triangle is always going to be a natural isomorphism.

35:35.480 --> 35:45.480
So the particular case where this is going to occur for us is basically when C is just a full subcategory of D.

35:45.480 --> 35:56.480
In other words, when we get C just by picking a load of objects of D and looking at all the arrows between those objects and that basically gives us C.

35:56.480 --> 36:04.480
So in that special case where C is a full subcategory of D and K is just this inclusion functor.

36:04.480 --> 36:12.480
Basically, this result says that essentially, we don't have to worry about this natural transformation, right?

36:12.480 --> 36:23.480
This diagram commutes in that case, at least up to a sort of natural isomorphism here.

36:23.480 --> 36:24.480
So this is really nice.

36:24.480 --> 36:41.480
Like, remember, the way I introduced Can extensions, I basically said, well, we're talking about this extension problem, but then, oh, we have to add in these high dimensional cells to make things so that we have unique solutions

36:41.480 --> 36:42.480
yada yada yada.

36:42.480 --> 37:00.480
Well, in this special case here, basically where K is a fully faithful functor, and we have these nice conditions which give us this kind of co-limity way of describing this left can extension.

37:00.480 --> 37:14.480
Well, in this case, basically, up to isomorphism, we pretty much do have that this triangle commutes and we don't really have to worry about the form of eta in this case.

37:14.480 --> 37:15.480
Okay, then.

37:15.480 --> 37:21.480
So now we've got our can extension ideas ready.

37:21.480 --> 37:32.480
Let's get on with the central idea I want to talk about today, which is something called the free co-completion of a category.

37:32.480 --> 37:38.480
So the easiest way to explain it is just directly.

37:38.480 --> 37:46.480
There's various ways of looking at this notion, but the simplest one is just to say, well, we have a category C.

37:46.480 --> 37:51.480
We want to determine the so-called free co-completion of that category.

37:51.480 --> 38:00.480
And basically that is just the category of pre-sheaves of C.

38:00.480 --> 38:07.480
So that's the category of functors from the opposite of C into set.

38:07.480 --> 38:10.480
And this is something we've seen a lot before.

38:10.480 --> 38:14.480
We've seen a lot of these pre-sheaves.

38:14.480 --> 38:23.480
We've seen that things like the category of graphs and the category of dynamical systems can be thought of as categories of pre-sheaves.

38:23.480 --> 38:26.480
And we're pretty familiar with these ideas.

38:26.480 --> 38:34.480
And you may know that these categories of pre-sheaves are always co-complete.

38:34.480 --> 38:54.480
So in a sense, you can see this free co-completion operation as a way to take a category C and sort of freely add co-limits to it so that we end up with a co-complete category.

38:54.480 --> 38:58.480
Now, there's a bit more to this idea.

38:58.480 --> 39:12.480
Another piece of information which comes along when we make this free co-completion is this functor here, which is called the yonida embedding.

39:12.480 --> 39:32.480
And what this does is it takes an object C to this honfunctor, C of blank comma C.

39:32.480 --> 39:36.480
So this is your contravariant honfunctor.

39:36.480 --> 39:43.480
So when I write this thing here, this is a functor from C op to set.

39:43.480 --> 39:58.480
If we have an arrow in C, let's say from C dash to C dash dash, let's say it's this arrow G.

39:58.480 --> 39:59.480
So there we are.

39:59.480 --> 40:02.480
That's an arrow of C.

40:02.480 --> 40:14.480
It's going to correspond with this arrow G op in C op.

40:14.480 --> 40:37.480
And when we do this honfunctor on it, that's going to give us an arrow like this.

40:38.480 --> 41:06.480
And the way that you can think of this working is that if we have an arrow of C, let's say R from C dash dash to C,

41:07.480 --> 41:23.480
then this is going to send it to this arrow R after G, which is going to go from C dash to R.

41:23.480 --> 41:27.480
So that's basically the nature of this functor here.

41:28.480 --> 41:36.480
However, there's a bit more to this, of course, because this you need a embedding.

41:36.480 --> 41:42.480
Yes, OK, it sends an object C to a honfunctor like this.

41:42.480 --> 41:51.480
But what about if we have an arrow H from C to D?

41:52.480 --> 42:04.480
Well, that's going to give us an arrow in the target category, which will be called C of,

42:04.480 --> 42:10.480
well, let's call it C of blank comma H.

42:10.480 --> 42:14.480
And it's going to go like this.

42:14.480 --> 42:16.480
And how does this work?

42:16.480 --> 42:36.480
Well, if we look at the eighth component of this, that's just going to be a function like this.

42:36.480 --> 42:52.480
And it's going to be sending an arrow R to the arrow like this.

42:52.480 --> 42:54.480
And there we have it.

42:54.480 --> 42:58.480
So that's basically the nature of this Yonita embedding.

42:58.480 --> 43:01.480
And it's very interesting is this Yonita embedding.

43:01.480 --> 43:10.480
It comes up all over the place and it is a fully faithful functor.

43:10.480 --> 43:16.480
OK, so it's sort of, I mean, it's actually, it's pretty fascinating.

43:16.480 --> 43:28.480
If you consider, for example, C equals this category here.

43:28.480 --> 43:34.480
If you, it turns out that in this case, this category of pre-sheaves.

43:34.480 --> 43:40.480
Well, it turns out that in this case, this category of pre-sheaves is the category of graphs.

43:40.480 --> 43:45.480
And so that's kind of interesting for several reasons.

43:45.480 --> 43:50.480
One of them is that you can kind of think of this C as something like a graph.

43:50.480 --> 43:57.480
OK, we've kind of injecting this vertex and as a source or a target of this edge.

43:57.480 --> 44:01.480
But then when we do its Freco completion, we get all of the graphs.

44:01.480 --> 44:11.480
And in a way, you can kind of think of that as making all graphs by starting with something basic and sticking things together.

44:11.480 --> 44:13.480
Less hand wavy.

44:13.480 --> 44:25.480
Well, we can see that this Yonita embedding is basically injecting this sort of basic structure that kind of lies behind all graphs

44:25.480 --> 44:32.480
into the category of graphs as a sort of full subcategory of the category of graphs.

44:32.480 --> 44:37.480
Actually, the full subcategory, which is on these kind of home functors.

44:37.480 --> 44:42.480
So I sometimes wonder if our universe is similarly constructed.

44:42.480 --> 44:54.480
If there's some kind of a category C that represents the way that all of the elementary particles in our universe interact and somehow that's embedded into our universe.

44:54.480 --> 45:05.480
All of the other structures that we have in our universe are sort of, you know, made out of those elementary bits in some kind of a free way.

45:05.480 --> 45:18.480
But that aside, the point here is that we're looking at some kind of a universal construction which gives us this kind of Yonita embedding.

45:18.480 --> 45:21.480
And this is called the free co completion.

45:22.480 --> 45:38.480
So again, just to say it briefly, the hand wavy idea between a free co completion is that we take a category C and then we sort of freely add all co limits to it in some sense.

45:38.480 --> 45:50.480
We sort of take the bits of C and we glue them together and sort of freely produce and make a structure in a kind of free way that has all co limits.

45:51.480 --> 46:04.480
Another example we can look at for free co completion is the trivial category one, the category that just has one object and the only arrow is the identity arrow.

46:04.480 --> 46:11.480
In that case, again, we can consider the free co completion of that.

46:11.480 --> 46:17.480
And you see that that's just going to be isomorphic to the category set itself.

46:17.480 --> 46:34.480
Now, what this reminds me of is the idea that we can make all sets by starting with a kind of singleton and then doing things like co products and repeatedly adding this singleton.

46:34.480 --> 46:41.480
And if we have our ability to do injections and whatnot, then we can get all of the structure of set.

46:41.480 --> 46:44.480
Okay, so I think that's enough hand waving.

46:44.480 --> 46:52.480
Let's actually look at the kind of universal property that this free co completion has.

46:52.480 --> 47:04.480
So recall that we have this category cat, which has objects as categories and arrows as functors.

47:05.480 --> 47:07.480
Now there is a

47:10.480 --> 47:17.480
Now what we can do is we can think just about the co complete categories.

47:24.480 --> 47:32.480
Okay, so they're going to be the categories that are co complete that have all of these small co limits.

47:32.480 --> 47:41.480
And we can just restrict our attention to the objects of cat, which correspond to these co complete categories.

47:41.480 --> 47:49.480
And then we can also restrict our attention to the arrows of cats, which preserve co limits.

47:49.480 --> 47:57.480
Okay, so then we can think of this sub category of cats that we'll call cat co comp.

47:57.480 --> 48:04.480
So basically cat co comp here is it's going to be a sub category of cats.

48:04.480 --> 48:14.480
The objects it has are going to be the categories which are co complete.

48:14.480 --> 48:27.480
So the ones which have all small co limits or the co limits of each small diagram, if you like.

48:27.480 --> 48:43.480
And then the arrows of this thing here are going to be the functors which preserve those small co limits.

48:45.480 --> 48:50.480
So to say it more briefly cat co comp is the foot.

48:50.480 --> 49:09.480
So to say it more briefly cat co comp is the sub category of cat on the objects which are the co complete categories and the arrows which are the co continuous functors that the functors that preserve the small co limits.

49:10.480 --> 49:15.480
So basically this is the stuff that plays nicely with co limits.

49:15.480 --> 49:29.480
Now there's clearly going to be an inclusion functor I from cat co comp into cat.

49:29.480 --> 49:41.480
And it's this that we're going to use to find our kind of universal property, this kind of universal property behind free co completion.

49:41.480 --> 49:44.480
So okay, what's the big idea?

49:44.480 --> 49:51.480
Well, the big idea is that in cats, let's pick any category C.

49:51.480 --> 50:04.480
And let's ask, is there an initial morphism from C to I, or you know, we could also say there are universal morphism from C to I, it means the same thing.

50:04.480 --> 50:11.480
And what it means is that we're looking for some kind of a universal construction.

50:12.480 --> 50:15.480
And it turns out that there is such a thing.

50:15.480 --> 50:20.480
And what it is is the free co completion of C.

50:20.480 --> 50:35.480
And what it consists of is this category of pre sheaves, the category of functors from C up to set.

50:35.480 --> 50:43.480
And also, there's going to be this arrow in this right hand side category.

50:43.480 --> 50:51.480
I mean, technically it's going to go from I of this category of pre sheaves.

50:51.480 --> 50:55.480
I mean, technically it's going to go to I of this category of pre sheaves.

50:55.480 --> 50:59.480
And that's going to be our, you know, need a embedding.

50:59.480 --> 51:07.480
Now, often I might just rub out that I because I is just an inclusion functor doesn't really affect the nature of the objects.

51:07.480 --> 51:13.480
Sometimes there's sort of no point writing it, but I'll write it for now.

51:13.480 --> 51:27.480
So the point is that this together with this is going to be forming an initial morphism from C to I.

51:27.480 --> 51:30.480
Now, let me remind you what that means.

51:30.480 --> 51:36.480
What it means is that for any object E over here on the left.

51:36.480 --> 51:41.480
So he's just going to be any old co complete category.

51:41.480 --> 51:50.480
Well, if we have some arrow, which sort of looks like why over here.

51:50.480 --> 51:52.480
So this is just a kind of candidate arrow.

51:52.480 --> 51:57.480
It's going to be an arrow F from C to I of E.

51:57.480 --> 52:06.480
Well, there's going to be this sort of corresponding intermediary arrow, which we're going to call F hat.

52:06.480 --> 52:16.480
And that has the feature that when we do I on it, it's going to make this triangle commute.

52:16.480 --> 52:22.480
All of this just comes from the definition of an initial or universal morphism.

52:22.480 --> 52:30.480
Now, like, there's a lot of things going on here, a lot of structures just appeared at once.

52:30.480 --> 52:34.480
Let me just point out a couple of things that I'll come back to later.

52:34.480 --> 52:38.480
Firstly, I is just an inclusion functor.

52:38.480 --> 52:46.480
So in a sense, we could just kind of rub out these eyes here and it wouldn't really change the meaning too much.

52:46.480 --> 52:53.480
And now does this structure remind you of anything that we've been looking at?

52:53.480 --> 53:01.480
What about if I wrote this as Lan Y of F?

53:01.480 --> 53:09.480
Do you see that this is the same pattern as we've been looking at with our can extensions?

53:09.480 --> 53:12.480
In particular, this thing's fully faithful.

53:12.480 --> 53:23.480
So this thing which has to fill out the triangle, this natural transformation eater can effectively be ignored.

53:23.480 --> 53:31.480
And so basically, you can see that this kind of idea of can extensions is appearing here.

53:31.480 --> 53:43.480
In particular, just this notion of these universal morphisms is basically forcing us to find a unique way to close this triangle here.

53:43.480 --> 53:47.480
And this is exactly what can extensions do for us.

53:47.480 --> 54:00.480
So it turns out that not only is this category of pre-sheaves together with the yonida embedding giving us an initial morphism from C to I.

54:00.480 --> 54:11.480
But moreover, the left can extension of any functor F from C to some co-complete category E.

54:11.480 --> 54:24.480
Well, the left can extension of such an F along the yonida embedding Y is exactly giving us this kind of intermediary arrow,

54:24.480 --> 54:33.480
which allows us to emulate our kind of candidate arrow F for being an initial morphism with respect to the real deal,

54:33.480 --> 54:36.480
which is of course the yonida embedding.

54:36.480 --> 54:43.480
So you can see that there are lots of ideas, lots of very cool ideas kind of interacting here.

54:43.480 --> 54:46.480
I mean, I'm probably going a bit too fast, right?

54:46.480 --> 54:55.480
There's a lot of things coming out at once, but we're going to get more kind of familiarity with this idea.

54:55.480 --> 55:14.480
But just to sort of finish explaining the gist of this, basically the point here is that when we have this category of pre-sheaves together with this yonida embedding,

55:14.480 --> 55:18.480
that's giving us an initial morphism from C to I.

55:18.480 --> 55:30.480
Now, if you have a look at my video on representable functors, I talk about how this kind of phenomenon appears over and over again in category theory

55:30.480 --> 55:35.480
and how there's several different perspectives to look at the same idea.

55:35.480 --> 55:44.480
So another way to look at the same kind of happening is to say that this category of pre-sheaves together with this yonida embedding

55:44.480 --> 55:52.480
is going to be an initial object of this comma category here, C slice I.

55:52.480 --> 55:56.480
We could also write it like this and then it looks like a category of elements.

55:56.480 --> 56:04.480
Another way to look at this is that this thing here is a functor into set, okay?

56:04.480 --> 56:12.480
It's really a functor from this cat co-comp into set.

56:12.480 --> 56:29.480
And what the yonida embedding really is, is it's just going to be like an object or an element of this kind of set-valued functor applied to this input.

56:29.480 --> 56:43.480
Okay, so when we do this functor on this object here of this category, we get this set and y is just going to be an object of this set.

56:43.480 --> 56:54.480
And so we can apply the yonida lemma, which is telling us that the elements of this set correspond to natural transformations

56:54.480 --> 57:00.480
into this functor here from the corresponding hon functor.

57:00.480 --> 57:05.480
And so this thing here is going to correspond to a natural transformation like this.

57:05.480 --> 57:09.480
Turns out it's actually going to be a natural isomorphism.

57:09.480 --> 57:14.480
And so we get this, which is like a really cool idea.

57:14.480 --> 57:25.480
And just to sort of fill in this dummy variable here, what this is telling us is that if we pick a co-complete category E,

57:25.480 --> 57:40.480
then the co-continuous functors from this category of pre-sheves into E are going to be in one-to-one correspondence with the ordinary functors from C to E.

57:40.480 --> 57:43.480
So this is a pretty cool idea.

57:43.480 --> 57:48.480
And it's especially cool because we kind of already know how this works.

57:48.480 --> 57:56.480
Okay, so if we have a category C and then we have something in this set here,

57:56.480 --> 58:02.480
so we can really just think of this as a functor F from C to this co-complete category E.

58:02.480 --> 58:08.480
Well, how do we get the corresponding kind of co-continuous functor over here?

58:08.480 --> 58:17.480
All we do is we go, okay, we've got a yonita embedding here from this into this category of pre-sheves.

58:17.480 --> 58:23.480
And now let's just do the can extension of F on Y.

58:23.480 --> 58:29.480
The left can extension, lan y F.

58:29.480 --> 58:31.480
And there we have it.

58:31.480 --> 58:38.480
We have F over here and we have lan y F over here.

58:38.480 --> 58:44.480
And so that's how this kind of isomorphism of Homsets works.

58:44.480 --> 58:57.480
We basically just get it using our can extensions and also provided that C is small, we have a formula for this lan y F.

58:57.480 --> 59:03.480
We've already seen a formula for it in terms of co-limits, so we can compute all this stuff.

59:03.480 --> 59:05.480
And that's very nice.

59:05.480 --> 59:15.480
So now we can kind of come back down from the heavens for a moment and just think about a particular case to get some intuition.

59:15.480 --> 59:22.480
So we can say, well, what happens when C is one?

59:22.480 --> 59:25.480
So let's just have a look what we've got here.

59:25.480 --> 59:31.480
We can rub out these eyes, as I say, they don't really change much.

59:31.480 --> 59:33.480
We can put one in here.

59:33.480 --> 59:39.480
This is just our trivial category.

59:39.480 --> 59:46.480
And so what we've got going on on the right here is going to be a functor F from one to E.

59:46.480 --> 59:51.480
So this is just going to basically be picking out an object of E.

59:51.480 --> 59:59.480
And we can see that this is going to correspond to a co-continuous functor of this kind of form.

59:59.480 --> 01:00:05.480
Well, the functors from one to set basically just look like sets.

01:00:05.480 --> 01:00:08.480
So this is telling us something pretty interesting.

01:00:08.480 --> 01:00:37.480
It's telling us that the objects E of this category, script E ought to be corresponding with these co-continuous functors

01:00:37.480 --> 01:00:41.480
from set into E.

01:00:41.480 --> 01:00:49.480
And I think that this is actually kind of intuitive, really, because think about it.

01:00:49.480 --> 01:00:58.480
E is a co-complete category, and we want to do a co-continuous functor from set into E.

01:00:58.480 --> 01:01:01.480
So what's the first thing that we might ask ourselves?

01:01:01.480 --> 01:01:06.480
Well, where are we going to send the terminal object?

01:01:06.480 --> 01:01:21.480
Well, this yoneda embedding is going to be sending our one here into the singleton set.

01:01:21.480 --> 01:01:31.480
So we better send the singleton set to this object E here, where F sends the object over here.

01:01:32.480 --> 01:01:46.480
So the question we're asking here is how do we cook up this functor H, which corresponds to this object E?

01:01:46.480 --> 01:01:56.480
And the answer is, well, we better send the singleton set to E.

01:01:56.480 --> 01:02:00.480
But then what about the set with two elements?

01:02:00.480 --> 01:02:03.480
Well, that's going to be the co-product of one and one.

01:02:03.480 --> 01:02:15.480
And the fact that we're forcing H to be continuous means that this better look like H of one co-producted with H of one in E.

01:02:15.480 --> 01:02:29.480
And so you can see that the way that we're acting on all of the other sets, all of the other kind of objects over here is fixed by the way that we're dealing with the terminal objects.

01:02:29.480 --> 01:02:40.480
So you can see that just picking any objective E is really going to give us a sort of co-continuous functor H from set to E,

01:02:40.480 --> 01:02:49.480
because any such functors essentially having all its form fixed by the way that it operates upon the singleton set.

01:02:50.480 --> 01:03:01.480
And you can kind of think of this intuitively as well, like co-completion is all about taking some initial structure and sticking the bits together in a kind of freeway.

01:03:01.480 --> 01:03:09.480
So you're doing co-products where you're sort of doing disjoint unions and you're doing co-equalizers where you're sticking stuff together.

01:03:09.480 --> 01:03:17.480
And if you just start with one dot and you start doing that kind of stuff, you're going to get lots of different sets.

01:03:17.480 --> 01:03:25.480
So it kind of seems to make sense to me that the free co-completion of a singleton set.

01:03:25.480 --> 01:03:33.480
So it seems to kind of make sense to me that the free co-completion of a trivial category is set itself.

01:03:33.480 --> 01:03:36.480
But you know, this intuition goes much further.

01:03:36.480 --> 01:03:44.480
Like if you think about your category of graphs, you can think of graphs as things that you get by sticking together.

01:03:44.480 --> 01:03:50.480
Your basic graphs, you know, like your single vertex and single edge.

01:03:50.480 --> 01:04:01.480
Again, with the category of simple as your sets, you know, you can make simplices or be simple as your complexes by sticking together these basic simplexes.

01:04:01.480 --> 01:04:07.480
And again, you know, it's described by a category of pre-sheaves.

01:04:07.480 --> 01:04:10.480
There's co-completions of foot.

01:04:10.480 --> 01:04:20.480
And yeah, this is like a really kind of important idea, which touches lots of things in mathematics.

01:04:20.480 --> 01:04:21.480
OK, then.

01:04:21.480 --> 01:04:32.480
So basically, most of the rest of the video is just looking at some very interesting applications of the kind of things we've already talked about.

01:04:32.480 --> 01:04:37.480
Now, I know it's a pretty high level of abstraction that we're dealing with.

01:04:37.480 --> 01:04:58.480
But I just want to sort of urge you to just hold on a little bit longer and soon all the applications we're going to look at are really going to help you to kind of cement these things in memory and so on.

01:04:58.480 --> 01:05:19.480
So basically, just before we start looking at the applications, like the first one I want to look at, I think, is basically the idea that we have a sort of universal recipe for making any graph by looking at the vertices and edges inside it and sticking them together.

01:05:19.480 --> 01:05:27.480
And we can see that one of the applications of the ideas we've already looked at, so it tells us how to do that instantly.

01:05:27.480 --> 01:05:34.480
And of course, it doesn't just work for the category of graphs, it works for simplices and dynamical systems and innumerable other cases.

01:05:34.480 --> 01:05:36.480
So soon we'll be there.

01:05:36.480 --> 01:05:47.480
But to make this more efficient, we're going to do some kind of a little bit of calculation now, which is really going to help us later.

01:05:47.480 --> 01:06:14.480
So you can see that most of this stuff to do with free co-completion boils down to this diagram here, which is really representing the left-can extension of this functor F into this co-complete category E along the yonida embedding.

01:06:14.480 --> 01:06:32.480
Now, since y is a fully faithful functor, we basically know that this can extension after y is naturally isomorphic to F, so we don't have to worry about this eta natural transformation.

01:06:32.480 --> 01:06:42.480
And really, we're mostly just interested in calculating this land y F thing that we're going to abbreviate to be F hat.

01:06:42.480 --> 01:06:47.480
And in particular, let's just suppose that we have an object in this category at the top here.

01:06:47.480 --> 01:06:49.480
So we have a pre-sheaf w.

01:06:49.480 --> 01:06:53.480
Well, how do we calculate F hat of w?

01:06:53.480 --> 01:06:56.480
Well, we've already seen a formula for this.

01:06:56.480 --> 01:07:00.480
And here it is.

01:07:00.480 --> 01:07:09.480
So we can calculate this functor F hat operating on w to be equal to this co-limit here.

01:07:09.480 --> 01:07:22.480
But the thing is with this co-limit, it starts with y slice w or y slice or y comma w, this category here.

01:07:22.480 --> 01:07:32.480
And it turns out that I don't think that's such an easy thing to understand directly, but it has a sort of equivalent form that's much easier to think about.

01:07:33.480 --> 01:07:39.480
Let's think about what this is, y slice w.

01:07:39.480 --> 01:07:43.480
I mean, it's actually just a comma category of these two functors here.

01:07:43.480 --> 01:07:49.480
We can see that y is a functor into this category of pre-sheaves, and so is w.

01:07:49.480 --> 01:07:53.480
I mean, w is really just a functor from the trivial category.

01:07:53.480 --> 01:07:56.480
It's just picking out a single pre-sheaf.

01:07:56.480 --> 01:08:08.480
Now, this category, y slice w, more concretely, its objects are going to look like this,

01:08:08.480 --> 01:08:17.480
that they're going to consist of an object of c and an arrow from y of that object into w.

01:08:18.480 --> 01:08:28.480
And the arrows are just going to be these arrows in this slice category.

01:08:28.480 --> 01:08:39.480
And the arrows in this comma category here are just going to be like this arrow h from c to c dash that makes this kind of diagram commute.

01:08:39.480 --> 01:08:46.480
But basically, we can transform this slice category into this one here.

01:08:46.480 --> 01:08:52.480
And the key to this is the go needle Emma, because what's an object in y slice w?

01:08:52.480 --> 01:09:01.480
Well, it's basically going to be a natural transformation e from this home functor here into w.

01:09:01.480 --> 01:09:06.480
And whenever you see a natural transformation coming out of a home functor,

01:09:06.480 --> 01:09:15.480
you should get a Japanese voice in your head that says you need to transform this into a form of elements.

01:09:15.480 --> 01:09:17.480
So that's what we'll do.

01:09:17.480 --> 01:09:27.480
We apply the yonidilema and we see that this kind of natural transformation is equivalent to this element e hat of w of c,

01:09:27.480 --> 01:09:44.480
where this is given by e c of w c.

01:09:44.480 --> 01:09:56.480
Now, basically applying this gives us this kind of isomorphism between this category here and this category here.

01:09:56.480 --> 01:09:58.480
What is this category here?

01:09:58.480 --> 01:10:02.480
Well, what I've written at the top here is the singleton sets.

01:10:02.480 --> 01:10:07.480
The singleton sets can be considered to be a functor into sets.

01:10:07.480 --> 01:10:12.480
W can also be considered to be a functor into set from C op.

01:10:12.480 --> 01:10:17.480
And so star slice w is this comma category here.

01:10:17.480 --> 01:10:22.480
But it turns out that we want to take the opposite of that.

01:10:22.480 --> 01:10:31.480
So really this is, well, some people would call this a category of elements for a contra variant functor.

01:10:31.480 --> 01:10:34.480
Yes.

01:10:34.480 --> 01:10:47.480
But the point of this really is that what we have here is just a category that has objects like this and arrows like this H.

01:10:47.480 --> 01:10:57.480
And I'll sort of leave it to you to work out the details of this correspondence here, but just to give a very sort of brief five minute outline.

01:10:57.480 --> 01:11:08.480
The idea is that we have an arrow H in this category down here.

01:11:08.480 --> 01:11:11.480
So it's going to go for an object like this to an object like this.

01:11:11.480 --> 01:11:17.480
But remember that what we have here is really the opposite of star slice W.

01:11:17.480 --> 01:11:29.480
So this H here corresponds to this arrow H op that goes from C dash E dash hat to C E hat in star W.

01:11:29.480 --> 01:11:39.480
And that just corresponds with this arrow H op of C op, which makes this kind of triangle commute.

01:11:39.480 --> 01:11:54.480
And then if you apply for your needle Emma, you can see that this basically just corresponds with an arrow of this kind of form in Y slice W.

01:11:54.480 --> 01:11:57.480
So I know that's a lot to take in.

01:11:57.480 --> 01:12:08.480
Maybe don't worry about the details of this on the first viewing, but the point basically is that we can rewrite this expression here.

01:12:08.480 --> 01:12:11.480
In this kind of form here.

01:12:11.480 --> 01:12:16.480
So here this projection functor here.

01:12:16.480 --> 01:12:28.480
That's going to take an arrow C comma Y C E W.

01:12:28.480 --> 01:12:33.480
And it's just going to project it to become C.

01:12:33.480 --> 01:12:38.480
And this kind of projection functor here is going to work in a sort of analogous way.

01:12:38.480 --> 01:12:43.480
So what we're going to have here are objects of the form C comma E hat.

01:12:43.480 --> 01:12:47.480
And the projection functor is just going to send those to C.

01:12:47.480 --> 01:12:57.480
And then the arrows in each of these categories just look like arrows of C and we can think of those at least symbolically is just sort of unaltered by these projection functors.

01:12:57.480 --> 01:13:06.480
So this is very nice because the final form of this basically involves a sort of category of elements here.

01:13:06.480 --> 01:13:16.480
And then we're just sort of projecting those elements down into C so we can almost think of this as a sort of vibration.

01:13:16.480 --> 01:13:27.480
We can think of these as sort of fibers above these objects of C in a way which is as described by this kind of pre-sheaf W.

01:13:27.480 --> 01:13:32.480
And then we're just sort of functoring these into F.

01:13:32.480 --> 01:13:38.480
We're just sort of functoring these into E and then asking for a co-limit of the resulting functor.

01:13:38.480 --> 01:13:42.480
I know still this is pretty abstract.

01:13:42.480 --> 01:13:53.480
But now we're going to start looking at some examples and hopefully we'll end up happy that we made this simplification step here because it's going to save us some work later on.

01:13:53.480 --> 01:13:56.480
So OK, we've done the hard part.

01:13:56.480 --> 01:14:05.480
Now we can start to look at some applications of this free co-completion concept.

01:14:05.480 --> 01:14:12.480
So the first one I want to look at is the so-called density theorem.

01:14:12.480 --> 01:14:22.480
And so for this, all we're going to do is pick a particular functor F here to focus on.

01:14:22.480 --> 01:14:28.480
And we're going to focus on the case where F itself is also the yonida embedding.

01:14:28.480 --> 01:14:40.480
So what we're essentially looking at here is the left can extension of the yonida embedding along the yonida embedding.

01:14:40.480 --> 01:14:57.480
And if you recall, the idea behind these can extensions usually is that we're to find a two-cell eta that fills in this triangle in a sort of universal way.

01:14:57.480 --> 01:15:06.480
However, in the special case where this functor here is fully faithful, as is the case with the yonida embedding,

01:15:06.480 --> 01:15:15.480
essentially we're just looking for the unique kind of arrow here, which just makes this triangle commute.

01:15:15.480 --> 01:15:22.480
And it's easy to see in this case that there's an arrow that makes this triangle commute, which is just the identity functor, right?

01:15:22.480 --> 01:15:26.480
Because identity after y equals y.

01:15:26.480 --> 01:15:32.480
And so we already know the form of this left can extension.

01:15:32.480 --> 01:15:39.480
We know that it's the identity, but we also have a formula for it from before.

01:15:39.480 --> 01:15:43.480
Okay, you remember this formula we were just looking at?

01:15:43.480 --> 01:15:47.480
Okay, you remember this formula that we were just looking at in the general case?

01:15:47.480 --> 01:16:02.480
Well, we can just look at this in the case where this f here is the yonida embedding, and this y here is our category of pre-sheaves.

01:16:02.480 --> 01:16:13.480
And so what we get, and so if we do that, we see that we have this formula here, which is for this.

01:16:13.480 --> 01:16:25.480
But we also know that this is equal to the identity functor operating on w, which is just w.

01:16:25.480 --> 01:16:34.480
And so we have this equation here, and this is our density theorem.

01:16:34.480 --> 01:16:39.480
Maybe I should write isomorphic here.

01:16:39.480 --> 01:16:48.480
And this is quite remarkable because it basically gives us a way to think about this functor w.

01:16:48.480 --> 01:16:53.480
So think about w as a sort of structured set.

01:16:53.480 --> 01:17:02.480
Okay, a lot of these pre-sheaves, you can think of them as structured sets, things like graphs and dynamical systems and things like that.

01:17:02.480 --> 01:17:14.480
Well, what this results basically telling us is how we can build this structured set here by sticking together humfunctores.

01:17:14.480 --> 01:17:20.480
And think of the humfunctores as sort of like elementary particles or elementary structured sets.

01:17:20.480 --> 01:17:27.480
So think about, for example, a single vertex or a single edge in the category of graphs.

01:17:27.480 --> 01:17:30.480
Those will correspond to the humfunctores.

01:17:30.480 --> 01:17:37.480
And what this result is telling us is how we can glue those things together to make w.

01:17:37.480 --> 01:17:43.480
And the reason is basically because this is some category.

01:17:43.480 --> 01:17:51.480
Basically, this is going to turn out to have sort of all the bits and pieces that make w.

01:17:51.480 --> 01:18:00.480
And then when we do this functor composition here, it's going to replace these bits and pieces with the corresponding humfunctores.

01:18:00.480 --> 01:18:05.480
So we're going to have all these kind of, we're going to have this sort of diagram.

01:18:05.480 --> 01:18:15.480
For example, in the category of graphs, it's going to consist of a load of lone vertices and lone edges with some maps telling you where to go.

01:18:15.480 --> 01:18:29.480
And then when we form this co-limit, we're essentially gluing all of those vertices and edges together to actually give the graph w that we want.

01:18:29.480 --> 01:18:43.480
So it's pretty amazing that we basically get this blueprint for building any kind of structured set at all out of its sort of elementary parts.

01:18:43.480 --> 01:18:54.480
And the whole thing just is given to us automatically as a fairly special case of this idea of free co-completion.

01:18:54.480 --> 01:19:12.480
So, you know, it's stuff like this that like really, you know, it really makes me glad to know category theory because it's kind of like, to me, it seems pretty obvious that this is like the right way to think about.

01:19:13.480 --> 01:19:22.480
Like how structures are assembled from elementary pieces because it's not like something that people have to figure out.

01:19:22.480 --> 01:19:30.480
This is given towards automatically as a small piece of a large, elegant structure.

01:19:30.480 --> 01:19:41.480
Okay, so let's apply this density theorem and we're going to apply it to the category of graphs and it's going to tell us how graphs are assembled.

01:19:41.480 --> 01:19:47.480
Okay, so for our category C here, we're going to pick this category here.

01:19:47.480 --> 01:19:54.480
So it's got two objects, E and V, and these two arrows S dash and T dash from V to E.

01:19:54.480 --> 01:20:00.480
And so now C op is going to look like this.

01:20:00.480 --> 01:20:08.480
And as we've seen before many times, functors from this category into sets are going to correspond to graphs.

01:20:08.480 --> 01:20:11.480
So let's have a look at an example.

01:20:11.480 --> 01:20:28.480
Here's a functor W from C op to set and it's going to send E to this set here and V to this set here and S is going to get sent to this function here and T is going to get sent to this green function here.

01:20:28.480 --> 01:20:35.480
So we can visualize this in this manner shown below here.

01:20:35.480 --> 01:20:49.480
And what we're doing here is visualizing each of these elements of W E as an edge that goes from the place it gets sent by W S to the place it gets sent by W T.

01:20:49.480 --> 01:20:53.480
So this is a sort of visualization of the graph W.

01:20:53.480 --> 01:20:59.480
Now all we have to do is apply this formula here.

01:20:59.480 --> 01:21:05.480
And so we want to be calculating a co-limit of this functor here.

01:21:05.480 --> 01:21:19.480
So to calculate this category of elements here, we just look at this picture and then we sort of rub out these bubbles and reverse the arrows and we get this category here.

01:21:19.480 --> 01:21:23.480
This is our category of elements. This is star slice W op.

01:21:23.480 --> 01:21:30.480
Now this projection functor here is just going to forget the second entries.

01:21:30.480 --> 01:21:39.480
And so it's going to send these two onto E and these two onto V.

01:21:39.480 --> 01:21:51.480
And then after that we want to do this yonida embedding, which is going to send this object E to the graph that just holds a single edge between two distinct vertices and nothing else.

01:21:51.480 --> 01:21:57.480
And also the yonida embedding is going to send V here to the graph that just has a single vertex.

01:21:57.480 --> 01:22:05.480
And so when we compose these, we get a diagram in the category of graphs and that diagram is going to look like this.

01:22:05.480 --> 01:22:10.480
And then we just want to calculate the co-limit of this diagram.

01:22:10.480 --> 01:22:20.480
And basically all that corresponds to is sort of imagine each of these lines here that showing how things getting mapped as a sort of thread.

01:22:20.480 --> 01:22:25.480
And we just sort of pull those threads tight and glue the structure together.

01:22:25.480 --> 01:22:40.480
And you can see that if you do that, you recover the graph that we had originally because this directed edge here has its source and its target as this vertex here.

01:22:40.480 --> 01:22:48.480
And this directed edge here is going to be going from one to two.

01:22:48.480 --> 01:22:52.480
And so yes, when we do the co-limits, we get this structure.

01:22:52.480 --> 01:23:04.480
And it's interesting to see how this theorem basically tells us how we can recover our graph from these kind of elementary pieces.

01:23:04.480 --> 01:23:15.480
Okay, so now if we return to the fountain, we return to this expression here for our free co-completion.

01:23:15.480 --> 01:23:24.480
Well, this F hat here, this one YF, this is sometimes called the yonida extension of this functor F.

01:23:24.480 --> 01:23:31.480
And it turns out that this is related to another of the super powerful categorical concepts.

01:23:31.480 --> 01:23:35.480
And that's the idea of a weighted co-limit.

01:23:35.480 --> 01:23:39.480
So the connection is pretty simple.

01:23:39.480 --> 01:23:49.480
If we have a functor W in this category up here, this category of pre-sheaves, if W is a pre-sheave basically.

01:23:49.480 --> 01:23:58.480
Well, when we do F hat on W, we can call that result the W-weighted co-limit of F.

01:23:58.480 --> 01:24:03.480
And so this is this idea of weighted co-limits.

01:24:03.480 --> 01:24:08.480
And they're normally characterized in a somewhat different way.

01:24:08.480 --> 01:24:13.480
Normally one would characterize a weighted co-limit by an expression like this.

01:24:13.480 --> 01:24:25.480
And we'd say that the W-weighted co-limit of F, where F is a functor from C to E and W is a functor from C up to set.

01:24:25.480 --> 01:24:38.480
The W-weighted co-limit of F is defined such that we have these kind of isomorphisms natural in E.

01:24:38.480 --> 01:24:50.480
But I think it's easier to think of them directly as just being produced by doing this F hat on these pre-sheaves W.

01:24:50.480 --> 01:24:57.480
So we can see that there are a couple of interesting special cases of these weighted co-limits.

01:24:57.480 --> 01:25:10.480
One of them is where we take W to be this diagonal functor here, this functor which is constantly equal to the singleton set.

01:25:10.480 --> 01:25:18.480
And if we use that as our weight, then it turns out that our weighted co-limit is just going to look like an ordinary co-limit.

01:25:18.480 --> 01:25:26.480
And you can check that by unpacking the actual formulas that we've got for F hat as we've described above.

01:25:26.480 --> 01:25:35.480
Now, another thing that you could do with this formula is you could instead set C to be a singleton set.

01:25:35.480 --> 01:25:41.480
Is you could instead set C to be the trivial category of a single object.

01:25:41.480 --> 01:25:46.480
In that case, F is just going to be an object of E essentially.

01:25:46.480 --> 01:26:00.480
And if you look at the meaning of this formula in this case, well, it reduces to this kind of form.

01:26:00.480 --> 01:26:09.480
And you see where we wrote a co-lim W of F, we're now writing W dot of F.

01:26:09.480 --> 01:26:20.480
And that's because this thing over here is what's known as the co-powering of F by W.

01:26:20.480 --> 01:26:36.480
And you can really think of it like if this category E has co-products, then you can think of this expression here as the co-product of this object F with itself W times.

01:26:36.480 --> 01:26:49.480
So if we think of W now as a set, let's say it's a set of three elements, well, this would just be F plus F plus F.

01:26:49.480 --> 01:26:57.480
So this is basically F co-product with itself once for every element in W.

01:26:57.480 --> 01:27:11.480
And you can see that this kind of expression here ought to hold, right, because like let's say W was a two element set, well, this would be like an arrow from F plus F to E.

01:27:11.480 --> 01:27:23.480
And that's going to correspond with two arrows from F to E, or if you like a function from a two element set, two to set of arrows from F to E.

01:27:23.480 --> 01:27:30.480
So this is the idea of so-called co-powering, which is also known as tensoring.

01:27:30.480 --> 01:27:35.480
And it turns out that we can get something else out of this kind of idea as well.

01:27:35.480 --> 01:27:43.480
So if we then think of another special case, let's suppose we have a category A.

01:27:43.480 --> 01:27:53.480
And what we're going to do is we're going to set C to equal A op times A, and we're going to set E to equal set.

01:27:53.480 --> 01:28:01.480
And so what we're going to have as F here is a functor from A op times A to set.

01:28:01.480 --> 01:28:06.480
So things that have that kind of form are sometimes called bifunctores.

01:28:06.480 --> 01:28:13.480
And we'll call this functor H just because it's a bit weird, so we'll give it a different name.

01:28:13.480 --> 01:28:16.480
So just write it down.

01:28:16.480 --> 01:28:28.480
We're supposing that C is A op times A, we're calling this FH, and we're supposing it's going to set.

01:28:28.480 --> 01:28:36.480
And now if we look at this particular case, of course, the same kind of resort holds.

01:28:36.480 --> 01:28:48.480
But what we can do is consider a special case where this W here, so here W is going to be going from C op to set,

01:28:48.480 --> 01:28:57.480
or if you like, it's going from A times A op to set, so that's the form that W is going to have.

01:28:57.480 --> 01:29:07.480
Well, we're going to consider the case where W is the humfunctor of A op.

01:29:07.480 --> 01:29:13.480
Because the humfunctor of A is going to be a functor from A op times A to set.

01:29:13.480 --> 01:29:19.480
So the humfunctor of A op is going to have this kind of form here.

01:29:19.480 --> 01:29:21.480
And so we'll take that as our W.

01:29:21.480 --> 01:29:31.480
And now if we just work out what this kind of thing is,

01:29:31.480 --> 01:29:37.480
well, what we end up with is this sort of formula here.

01:29:37.480 --> 01:29:53.480
So we're doing this arrow here, which we should probably put H here now instead of a W.

01:29:53.480 --> 01:30:00.480
We're doing H hat on this hum A op.

01:30:00.480 --> 01:30:11.480
So what we have here is that this is H hat operating on hum of A op.

01:30:11.480 --> 01:30:14.480
And we can write it directly like this.

01:30:14.480 --> 01:30:19.480
Here's the same thing written as a weighted co-limit.

01:30:19.480 --> 01:30:26.480
But now what I'm telling you is that there's this other idea in category theory called a co-end.

01:30:26.480 --> 01:30:31.480
And it turns out that we can really define a co-end to be this.

01:30:31.480 --> 01:30:42.480
So the co-end of this bifunctor H can be defined to be the hum A op weighted co-limit of H.

01:30:42.480 --> 01:30:47.480
And we usually write these co-ends with this kind of integral form like this

01:30:47.480 --> 01:30:51.480
with the kind of thing that we're integrating upstairs.

01:30:51.480 --> 01:31:00.480
So there we are. We've just got this notion of co-ends totally free out of this theory.

01:31:00.480 --> 01:31:06.480
Okay, so now we're ready for the final application of these big ideas.

01:31:06.480 --> 01:31:10.480
And that is understanding profunctals.

01:31:10.480 --> 01:31:20.480
So a profunctor from A to B is the same thing as a functor P from A op times B to set.

01:31:20.480 --> 01:31:29.480
And a good way to think of it is that, well, you can think of it as a generalization of a humfunctor.

01:31:29.480 --> 01:31:32.480
That's quite a good way of looking at it.

01:31:32.480 --> 01:31:38.480
So, you know, if A equals B and this is a humfunctor, well, that's a kind of profunctor.

01:31:38.480 --> 01:31:46.480
Or you can think, well, I'm sending a pair of an object of A and an object of B to this set.

01:31:46.480 --> 01:31:54.480
And you can kind of maybe think about something like the set of proofs that A implies B or something like this.

01:31:54.480 --> 01:32:03.480
Or maybe you can think about something like the set of proofs that the first proposition, the object in A,

01:32:03.480 --> 01:32:06.480
implies the second proposition, the object in B.

01:32:06.480 --> 01:32:10.480
There's various different types of intuition that you can have.

01:32:10.480 --> 01:32:15.480
Now, it turns out that there's a category of profunctals.

01:32:15.480 --> 01:32:21.480
And with this kind of machinery we've been talking about today, we can understand it.

01:32:21.480 --> 01:32:28.480
So, as I say, a profunctor P corresponds to a functor of this kind of form.

01:32:28.480 --> 01:32:37.480
We're free to apply a kind of swap of the order on the left and some currying.

01:32:37.480 --> 01:32:40.480
And then we can change it into a functor of this kind of form.

01:32:40.480 --> 01:32:42.480
So, we'll call that P dash.

01:32:42.480 --> 01:32:45.480
That's clearly an equivalent form.

01:32:45.480 --> 01:32:56.480
But the sort of maths that we've been talking about today tells us that a functor from B to this category of pre-sheaves here

01:32:56.480 --> 01:33:01.480
corresponds to a co-continuous functor of this kind of form.

01:33:01.480 --> 01:33:07.480
A co-continuous functor between these two categories of pre-sheaves.

01:33:07.480 --> 01:33:12.480
So, this is another equivalent form for this profunctor P.

01:33:12.480 --> 01:33:20.480
Now, there's a nice analogy in what's going on here with linear algebra.

01:33:20.480 --> 01:33:25.480
I haven't covered linear algebra in this course if this doesn't mean much to you, don't worry.

01:33:25.480 --> 01:33:28.480
This is the basic sort of analogy.

01:33:28.480 --> 01:33:39.480
It's that if you think about A and B as finite sets, then we could have an A times B matrix.

01:33:39.480 --> 01:33:47.480
And that corresponds to a linear map from B dimensional space to A dimensional space.

01:33:47.480 --> 01:33:54.480
We could also think of it as just a function sending the elements of B to A dimensional space.

01:33:54.480 --> 01:34:00.480
And if you look at this pattern, it's pretty much analogous with this pattern here.

01:34:00.480 --> 01:34:05.480
It's just here we have profunctores instead of functions.

01:34:05.480 --> 01:34:11.480
And we have co-continuous functores instead of linear functions.

01:34:11.480 --> 01:34:20.480
But basically, the idea is that once we start with a profunctor of this form, we can convert it into this form trivially.

01:34:20.480 --> 01:34:28.480
And then this idea of free co-completeness, and in particular this type of diagram here,

01:34:28.480 --> 01:34:38.480
gives us this equivalent co-continuous functor, which sort of corresponds with this functor P-dash.

01:34:38.480 --> 01:34:44.480
And this turns out to be the key towards defining profunctor composition.

01:34:44.480 --> 01:34:55.480
You see, there's actually a category called prof, and it has objects as categories, and it has arrows as profunctores.

01:34:55.480 --> 01:35:08.480
Now, the identity arrow of an object A is just going to be this profunctor, which is just the hom functor of A.

01:35:08.480 --> 01:35:17.480
That's, of course, a functor from... We can, of course, think of that as a functor from A op times A to set.

01:35:17.480 --> 01:35:26.480
So it is a profunctor. It turns out that it really acts like the identity in this category of profunctores.

01:35:26.480 --> 01:35:33.480
A more interesting question is, how can we compose general profunctores?

01:35:33.480 --> 01:35:42.480
So what about if we have a profunctor P from A to B, and a profunctor Q from B to C, and we want to compose them?

01:35:42.480 --> 01:35:53.480
Well, then we want to end up with some kind of thing that we could call a composition, which ends up being a functor from A op times C to set.

01:35:54.480 --> 01:36:00.480
And it turns out that, basically, we can just define it to be this kind of composition here.

01:36:00.480 --> 01:36:07.480
So this LANYP dash is, as shown in this diagram, we know how to compute it.

01:36:07.480 --> 01:36:10.480
We've looked at a formula for it earlier and so on.

01:36:10.480 --> 01:36:19.480
And if we just compose this after this, you can see that we have something that goes from C to this category of pre-sheaves.

01:36:19.480 --> 01:36:29.480
And if we just sort of untangle this, we can put it into this kind of form and consider it to be the composition Q after P.

01:36:29.480 --> 01:36:36.480
So basically, that's how profunctor...

01:36:44.480 --> 01:36:47.480
So basically, that's how profunctores work.

01:36:47.480 --> 01:36:56.480
Now, it turns out that the normal way of thinking about this is that one writes profunctor composition with a co-end formula like this.

01:36:56.480 --> 01:37:06.480
But, you know, we don't need to do that because we have this way of thinking about it in terms of can extensions and co-completeness.

01:37:06.480 --> 01:37:23.480
By the way, the stuff I just talked about to do with composing profunctores is basically remark 5.1.7 of Fosco's book, Co-end Calculus, if one wants to dig deeper into this.

01:37:23.480 --> 01:37:35.480
So if you want to understand about profunctores, definitely the best advice I can think of is that you should consider what happens when the categories of profunctores

01:37:35.480 --> 01:37:48.480
are discrete. Okay? Because if you think about it, what's a profunctor from A to B when A and B are discrete categories?

01:37:48.480 --> 01:37:57.480
Well, in that case, these things don't have any arrows. It doesn't matter about taking the opposite of the categories because there's no arrows to reverse.

01:37:57.480 --> 01:38:10.480
You know, we only have identity arrows. And basically for every object of A and object of B, we just have a set and that's all the data which goes into defining the profunctor.

01:38:10.480 --> 01:38:22.480
And if we think about finite sets, then essentially we can just think of a profunctor as something like a matrix of non-negative integers.

01:38:22.480 --> 01:38:32.480
And in that case, if one looks at the way that profunctor composition works, it looks exactly like matrix multiplication.

01:38:32.480 --> 01:38:43.480
And this is really beautiful because you'll see that basically if you look at the full subcategory of this category of profunctores on the discrete categories,

01:38:43.480 --> 01:38:54.480
well, it just looks like linear algebra basically. It just looks like the profunctores or like matrices and composing them is matrix multiplication.

01:38:54.480 --> 01:38:59.480
That's all there is to it. And so that's kind of beautiful.

01:39:00.480 --> 01:39:09.480
The final thing I want to say just to come full circle is that co-ends are another one of these super powerful ideas.

01:39:09.480 --> 01:39:18.480
And it turns out that we can express can extensions in terms of co-ends.

01:39:18.480 --> 01:39:32.480
So when E here has co-powers, we can express this formula for the left can extension here in terms of co-ends like this.

01:39:32.480 --> 01:39:36.480
So now we've kind of come full circle.

01:39:36.480 --> 01:39:42.480
And remember, everything I've talked about today can be dualized.

01:39:42.480 --> 01:39:53.480
So if we go back, back, back way back in time to our original diagram.

01:39:53.480 --> 01:39:59.480
Yeah, you can dualize all this. So you've got right can extension here.

01:39:59.480 --> 01:40:06.480
There's a sort of analog of the yoneder extension. There's the idea of free completion.

01:40:06.480 --> 01:40:13.480
We have weighted limits. There's an idea of powering, which is also called co-tensoring and so on.

01:40:13.480 --> 01:40:19.480
So, you know, there's a very rich web of ideas here.

01:40:19.480 --> 01:40:28.480
And in particular, the main sort of point I want to get across and, you know, you can dig into further resources like nlabs to understand more about this.

01:40:28.480 --> 01:40:40.480
But the big idea is that like can extensions, weighted co-limits and co-ends are also general that you can talk about the other concepts from inside them.

01:40:40.480 --> 01:40:49.480
So we kind of have this idea of these concepts, which is so general that any other concept can be expressed in terms of them.

