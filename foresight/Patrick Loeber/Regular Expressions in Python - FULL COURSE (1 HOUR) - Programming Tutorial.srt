1
00:00:00,000 --> 00:00:04,640
Hey guys, welcome to a new Python tutorial. Today I want to show you how we can work with

2
00:00:04,640 --> 00:00:11,600
regular expressions in Python. Regular expressions or short RE or REGX is a powerful method that is

3
00:00:11,600 --> 00:00:17,520
used to search for matching text patterns. For example, typical patterns that can be extracted

4
00:00:17,520 --> 00:00:24,000
from large text files with regular expressions are emails or domain names. So at the end of this

5
00:00:24,000 --> 00:00:30,720
tutorial, you will be able to understand what this regular expression here does. And there's a lot

6
00:00:30,720 --> 00:00:36,240
to cover in this tutorial. Don't be overwhelmed. I promise that once you have understood the concepts,

7
00:00:36,240 --> 00:00:42,160
it's not so hard anymore. And it can simplify and speed up your search tasks a lot. So if you

8
00:00:42,160 --> 00:00:46,960
watch the whole tutorial, then you will be able to understand any pattern that you want to look up.

9
00:00:47,840 --> 00:00:53,440
So now let me quickly show you what we will cover in this video. So of course,

10
00:00:53,440 --> 00:00:59,520
we will see how we work with the RE module in Python. Then I will show you what methods we

11
00:00:59,520 --> 00:01:06,320
have to search for matches, what we can do with a match object. Then we will talk about matter

12
00:01:06,320 --> 00:01:14,160
characters and more special sequences that can be used in patterns. Then we talk about sets,

13
00:01:14,160 --> 00:01:24,320
quantifiers, conditions, and then grouping, then modifications, so how we can modify strings with

14
00:01:24,320 --> 00:01:33,360
REs. And at the end, I show you some different compilation flags. So let's start. So as I already

15
00:01:33,360 --> 00:01:41,440
said, Python has a built in module that is called RE, which we can use to work with regular expressions.

16
00:01:41,440 --> 00:01:48,560
So we have to import RE. And then we can start working with regular expressions. So let me show

17
00:01:48,560 --> 00:01:57,440
you a very simple example first. So let's say here I have some test strings already. So let me copy

18
00:01:57,440 --> 00:02:04,960
and paste this here. So this is our test strings. And now let's say for example, we want to search

19
00:02:05,040 --> 00:02:14,000
for the pattern ABC. So we see we have this three times here. And now let's say we want to look

20
00:02:14,000 --> 00:02:22,400
for ABC, then we create a pattern. So let's say pattern equals and then we use the RE module

21
00:02:22,400 --> 00:02:31,360
and the compile method. And then here we say R and then the string ABC. So I will explain what

22
00:02:31,360 --> 00:02:40,000
R means in a second. And then we can use this pattern to find matches. So we say matches equals

23
00:02:40,800 --> 00:02:50,800
pattern dot find iter. And then we want to find the matches from the test string. And now this will

24
00:02:50,800 --> 00:03:01,760
be a object that we can iterate over. So we can say for match in matches. And then we simply print

25
00:03:01,760 --> 00:03:13,040
the match. So now let's run this. And then we see we have two matches. So this is a match object.

26
00:03:13,040 --> 00:03:19,520
And we can see more details. So for example, we can see the span. So this is the start

27
00:03:20,080 --> 00:03:29,360
and the end position. So this is three, four and five. And this is our match ABC and a second

28
00:03:29,360 --> 00:03:37,040
match at position 12. So this is position or index 12 in our string. So we see that we have

29
00:03:37,040 --> 00:03:44,720
two matches here. And what we also see here that our regular expression is case sensitive. So it

30
00:03:44,720 --> 00:03:54,400
doesn't include the uppercase ABC into our matches. So this is one thing that we must know. So one

31
00:03:54,400 --> 00:04:02,080
thing that I want to mention here is that instead of compiling our pattern explicitly, we can use

32
00:04:02,080 --> 00:04:12,320
the find iter method directly on the RE module. So we could also just write that our matches

33
00:04:13,120 --> 00:04:23,520
equals RE dot find iter. And then we want to look for our let's say string,

34
00:04:24,320 --> 00:04:35,040
our ABC, and then from our test string. So you can use it directly on the RE module. And then we

35
00:04:35,040 --> 00:04:43,040
will if we run this, we will see that we get the same results. So there is not much of a difference

36
00:04:43,040 --> 00:04:53,280
here. But I prefer to do it this way to explicitly compile them pattern and bind it to this object

37
00:04:53,360 --> 00:05:01,200
here. So this improves readability. And it's also a little bit more flexible. So I prefer it this

38
00:05:01,200 --> 00:05:10,320
way, but you should know that you can use both ways. And now let's talk about why I'm using this

39
00:05:10,320 --> 00:05:21,280
R here briefly. So this means that this is a raw string. So for example, if I have a string A,

40
00:05:22,080 --> 00:05:30,000
and this includes some special characters like a tap, so a backslash T that this is a tap or a

41
00:05:30,000 --> 00:05:40,000
backslash N for new line. And then I have a string. So now if I print this, then you will see that we

42
00:05:40,000 --> 00:05:48,240
have the tap here at the beginning. So it didn't print the backslash T. And in a pattern, I usually

43
00:05:48,240 --> 00:05:56,320
want to look for the actual characters in my pattern. So then I can write an R here. And then

44
00:05:56,320 --> 00:06:03,040
this means that this this is a raw string. So Python will print this the same way as it is

45
00:06:03,040 --> 00:06:10,800
specified here. And yeah, so I recommend to always use a raw string for your patterns, you can use

46
00:06:10,800 --> 00:06:18,480
just a normal string. But remember that you should use a raw string. And yeah, so this is a short

47
00:06:18,480 --> 00:06:24,800
example how a regular expression is used. So typically, we come up with our pattern, then we

48
00:06:24,800 --> 00:06:33,440
compile it. And then we use the pattern to find our matches. And I will show you the different

49
00:06:33,440 --> 00:06:42,240
methods that we have on the matches now. So now let's go over the methods to search for matches.

50
00:06:42,960 --> 00:06:52,160
So we already have seen the find iter method. And this will give us a match object. And I

51
00:06:52,160 --> 00:06:58,880
will show you what we can do with a match object in a second. So now let's talk about the other

52
00:06:58,880 --> 00:07:07,920
methods. So there are three other methods. So we can use the dot match method. So here dot match,

53
00:07:07,920 --> 00:07:21,120
then we have search. And then we also have find all. So now let's look about the find all method

54
00:07:21,120 --> 00:07:28,960
first. So if we can say pattern dot find all, then we will simply get the string. So if you see

55
00:07:28,960 --> 00:07:36,960
here, I'm printing the whole match object. So now if I want just a string, then I can use find all.

56
00:07:36,960 --> 00:07:42,560
And now if I run this, then it will just print the two strings that I'm looking for.

57
00:07:43,520 --> 00:07:53,520
So this is the find all method. Now the match method determines if the expression matches at

58
00:07:53,520 --> 00:08:04,240
the beginning of the string. So this will only return one match. So here I can say match equals

59
00:08:04,240 --> 00:08:16,240
pattern, and then match. And now if I print the match, so let's print the match and run this,

60
00:08:16,240 --> 00:08:23,120
then we will see this is none, because the match looks only for patterns at the beginning of our

61
00:08:23,120 --> 00:08:32,960
string. So ABC is not at the beginning. So now if I use 123 as a pattern, then we will see this is

62
00:08:34,240 --> 00:08:42,000
at the beginning. So this will return one match. And we also have the pattern here again. But again,

63
00:08:42,960 --> 00:08:50,240
the match does only return the first match if it is at the beginning of the string.

64
00:08:51,360 --> 00:08:59,280
And now we also have the search method. So the search method scans through the string

65
00:08:59,280 --> 00:09:08,000
and looks for any location where the RE matches. So if you use, for example, let's look for the match

66
00:09:08,560 --> 00:09:16,320
ABC again, then we will see this will return none because ABC has to be at the beginning.

67
00:09:16,320 --> 00:09:23,280
And now if we use this search method, then it will find the match object again, and

68
00:09:23,280 --> 00:09:34,160
it will simply return the first match. So we have search match find all and find iter. And this is my

69
00:09:34,160 --> 00:09:40,960
preferred method. So from now on, I will only use this one. And then we also have some

70
00:09:41,680 --> 00:09:51,040
functions that can be used to modify an object. So we also have split and sub. So I will come to them

71
00:09:51,040 --> 00:10:00,240
later. So now let's continue using the find iter method. And let's have a look at what we can do

72
00:10:00,240 --> 00:10:08,960
with the match object. So again, let's say our matches equals pattern, and then find iter.

73
00:10:09,600 --> 00:10:17,920
And then let's iterate over this. So for match in matches, and then we want to print the match.

74
00:10:18,880 --> 00:10:29,840
Then again, we see we have the whole match object here. And we can use four different methods on

75
00:10:29,840 --> 00:10:39,440
this. So we can use the group method, we can use the start and the end method. And we can get the

76
00:10:39,760 --> 00:10:52,480
span. So let's start with the span. So this will give me the start and the stop index, where this

77
00:10:52,480 --> 00:11:02,960
pattern is located. So let's print the match dot span. So then we simply get this as a tuple here.

78
00:11:03,920 --> 00:11:11,120
So we get three and six. So this is a tuple. And we can also get the

79
00:11:12,400 --> 00:11:23,680
just the start and the end right away by saying print match dot start and print match dot end.

80
00:11:23,680 --> 00:11:35,120
Oh, sorry, here is a dot match dot start. So then we get the start in the stop index. And now let's

81
00:11:35,120 --> 00:11:43,280
talk about the group method. So now if we call match dot group, then we will get or print the

82
00:11:44,160 --> 00:11:52,160
actual string of the match. And we can also give this group method arguments to find the group

83
00:11:52,160 --> 00:12:00,800
zero or one and or two. And we will talk about this grouping later. But for now on, if you

84
00:12:00,800 --> 00:12:08,080
just want the string then from the match, then just call match dot group or group zero. So this

85
00:12:08,080 --> 00:12:15,840
is the same. And yeah, so these are the four different methods that we can use on a match

86
00:12:15,840 --> 00:12:25,600
object. And now let's come to the matter characters. So in regular expressions,

87
00:12:25,600 --> 00:12:34,080
there are these method characters that have a special meaning. So these are all the method

88
00:12:34,080 --> 00:12:40,320
characters we must know. And you don't have to know them by heart. So I recommend that you

89
00:12:40,320 --> 00:12:46,640
keep a cheat sheet somewhere with all this stuff. And I will also provide a cheat sheet on

90
00:12:46,640 --> 00:12:52,880
my website. So you can check that out on Python minus engineer dot com. And this is all you need

91
00:12:52,880 --> 00:13:00,560
to know. So now let's talk about these method characters one by one. And then I will show

92
00:13:00,560 --> 00:13:09,040
you what this means. So the first one is the dot. So the dot means that we want to look for any

93
00:13:09,040 --> 00:13:15,760
character. So any character except a new line character, then the carrot means that we want

94
00:13:15,760 --> 00:13:22,320
to look for a pattern that starts with that starts with the pattern we are looking for. So that

95
00:13:22,320 --> 00:13:27,840
starts with the string hello, for example, then the dollar sign is the opposite. If you want to

96
00:13:27,840 --> 00:13:38,080
look for a string at the end of our text, then we have some quantifiers. So the asterisk, the plus

97
00:13:38,080 --> 00:13:46,160
and square brackets. And I will talk about them later in more detail. Then we have the set operator,

98
00:13:46,800 --> 00:13:55,680
which I will also cover later. Then we have conditions and grouping with parentheses. So I

99
00:13:55,680 --> 00:14:01,680
will also talk about this later. And of course, we have to look, we have the backslash. So with

100
00:14:01,680 --> 00:14:09,760
the backslash, we can get more special sequences, or we can escape characters. So for example,

101
00:14:09,760 --> 00:14:16,720
if you actually want to search for the dot, then we have to escape this in our pattern.

102
00:14:17,680 --> 00:14:25,440
So now let's talk about the first three and show you some examples. And then later we will cover

103
00:14:25,440 --> 00:14:34,000
the other meta characters in more detail. So now first let's say we want to look for the dot and

104
00:14:34,000 --> 00:14:43,920
then print all the matches, then we see we get all all the characters in our string,

105
00:14:44,480 --> 00:14:52,000
because the dot is looking for any character except new line. So this is the dot.

106
00:14:52,000 --> 00:15:00,880
And now let's say we have a dot here at the end, and we actually want to get this dot. So then we

107
00:15:00,880 --> 00:15:08,880
escape it with a backslash. And now if we run this, then we just get the dot. So now let's print the

108
00:15:08,880 --> 00:15:18,000
whole match object. Then we get the dot and we see that it is at this position. So this is the

109
00:15:18,000 --> 00:15:25,200
dot. And then let's have a look at the carrot. So this is the carrot. So let's say we want to look

110
00:15:25,200 --> 00:15:36,240
for 123 if it starts with this. And then we get one match object. And for example, now if we look

111
00:15:36,240 --> 00:15:44,400
for ABC, then it will return nothing, because it's not at the beginning. And the opposite if you

112
00:15:44,400 --> 00:15:51,920
want to have a look, if we want to look if this is at the end, so then we can say dollar here.

113
00:15:52,480 --> 00:15:58,880
And now if you run this, and this will find nothing because I'm sorry, we have the

114
00:16:00,000 --> 00:16:07,840
colon here, this will find nothing, because as I said, it is case sensitive. Now if I'm looking

115
00:16:07,920 --> 00:16:15,760
for uppercase ABC, and dollar at the end, so then it found the match at the end.

116
00:16:16,640 --> 00:16:24,080
All right, so now we will talk about the other meta characters later. And now let's look at

117
00:16:24,080 --> 00:16:30,400
some more special characters. So there are more special characters that start with a backslash.

118
00:16:30,400 --> 00:16:40,480
So there is the backslash and small D. This looks for any digit, so zero until nine.

119
00:16:41,120 --> 00:16:47,040
Then there's the capital backslash capital D. So this matches any non digit character.

120
00:16:47,760 --> 00:16:54,880
Then there's backslash, small s, this matches any white space character, for example, space,

121
00:16:54,880 --> 00:17:03,040
tap or new line. Then we have backslash capital is s, this matches any non white space character.

122
00:17:03,040 --> 00:17:07,040
So for all these patterns, all these special characters, the capital

123
00:17:08,400 --> 00:17:17,520
pattern is kind of the opposite of the small character here. So then we have backslash,

124
00:17:17,520 --> 00:17:27,600
small w, this matches any word character. So we have characters from A to C. We also have

125
00:17:27,600 --> 00:17:38,080
all the capital characters, and also digits and the underscore. Then the capital w is the

126
00:17:38,080 --> 00:17:44,800
opposite. So any non word character, non alphanumeric character. Then we have the

127
00:17:45,280 --> 00:17:54,560
backslash b. So this matches where the specified characters are at the beginning or at the end

128
00:17:54,560 --> 00:18:01,760
of a word. And again, we have the opposite. So where this is not at the beginning. So let's

129
00:18:01,760 --> 00:18:10,320
have a look at them in detail. So let's use another test string here. So let's, for example,

130
00:18:10,320 --> 00:18:22,000
use this one. And now if we want to look for any digit here, we can simply say we want to look for

131
00:18:22,000 --> 00:18:30,560
backslash d. And now if you run this, then we will see we have three matches, the digits one,

132
00:18:30,560 --> 00:18:40,080
two and three. Now if we use the opposite, so capital D, so any non digit, then it will find

133
00:18:40,080 --> 00:18:49,360
all the characters except one, two and three. Then let's have a look at the white space. So

134
00:18:50,080 --> 00:19:00,080
backslash s finds any white space character. So here we see we have a space here, a space here,

135
00:19:00,080 --> 00:19:08,880
and a space here. And then again, the opposite, so any non white space character is any other

136
00:19:08,880 --> 00:19:20,960
character. So this is the s special character. Then let's have a look at the w characters. So any

137
00:19:20,960 --> 00:19:30,640
alphanumeric character. So if I put in a w here, then it finds all the word characters.

138
00:19:32,320 --> 00:19:41,280
And again, the opposite capital D, this will just find the spaces in this example. And now

139
00:19:41,280 --> 00:19:53,120
let's have a look at the backslash B. So now if I am looking for hello, then it will find it because

140
00:19:53,120 --> 00:20:02,400
it is at the beginning of a block. And a block is not only the beginning of a string, but the

141
00:20:02,400 --> 00:20:13,600
beginning of any block that follows a white space character. So for example, if we look for

142
00:20:14,800 --> 00:20:26,800
hay, then it will also find the hay, but it will only find this pattern and not this one because

143
00:20:26,800 --> 00:20:35,280
it's looking for matches that are at the beginning of a block. So for example, if we put this

144
00:20:36,640 --> 00:20:45,520
before a space, then it will find and then it will find this pattern or this match to

145
00:20:46,720 --> 00:20:51,760
and again, the opposite. Now if we are looking for this, and we put

146
00:20:52,080 --> 00:21:00,080
ho hay here again, then it will find this hay because it is not at the beginning of a block

147
00:21:00,080 --> 00:21:08,800
where this is at the beginning of a block. So these are the special sequence, special characters

148
00:21:09,760 --> 00:21:23,920
that we should know. And now let's continue with sets. So we can use square brackets to look for

149
00:21:24,640 --> 00:21:32,560
sets. And let me show you what this means. So let's say we only have this string now.

150
00:21:33,120 --> 00:21:40,560
But now let's say we only want to look for a non-numeric character. So only for these ones,

151
00:21:41,120 --> 00:21:52,880
then we can use a set for this. So a set is a pattern between square brackets. And now here

152
00:21:52,880 --> 00:22:02,320
in this set, we can use multiple characters that we want to look up. For example, we want to look

153
00:22:02,400 --> 00:22:14,800
for a L and a O. And now if we run this, then it will find all these characters. And you must be

154
00:22:14,800 --> 00:22:24,240
careful here because it doesn't look for L O, but for any single character that we put into this set.

155
00:22:24,640 --> 00:22:34,400
And we can also specify ranges here. So we can instead of, let's say we also want to have the

156
00:22:35,200 --> 00:22:46,640
H and the E, then it will find any character here that is not a number and also not the

157
00:22:47,360 --> 00:22:55,120
not the underscore. So we can also specify a range here. And this is a very typical,

158
00:22:55,120 --> 00:23:06,720
very common example in regular expressions to use A dash C, so A to C. So all the lowercase

159
00:23:06,720 --> 00:23:14,640
characters, now if you run this, sometimes it's not saving this file automatically. So now if

160
00:23:14,640 --> 00:23:26,640
you run this, then we see that we will find all the letters here. And we can also look for digits.

161
00:23:26,640 --> 00:23:34,720
So let's say we want only the digits two and three. And again, here we can have a range. So we can

162
00:23:34,720 --> 00:23:44,800
say one to nine. So this is or let's say zero to nine. And this will find all the digits. So this

163
00:23:44,800 --> 00:23:56,960
is the same as using backslash D to find a digit. And so yeah, so if you want to specify a

164
00:23:57,920 --> 00:24:08,880
range, then that the dash can be used to declare to define the range. And now if you use it after a

165
00:24:08,880 --> 00:24:15,600
range, then it's looking for the actual dash. So now if you also want to look up a dash,

166
00:24:16,160 --> 00:24:24,000
then we can find it here. And if you put it between two things, then it is a range. So be

167
00:24:24,000 --> 00:24:36,560
careful here. And we can also write our different ranges back to back. So for example, if we have

168
00:24:37,600 --> 00:24:45,520
hello here in uppercase letters, and first of all, let's say we only want the lowercase letters.

169
00:24:46,080 --> 00:24:53,280
And then we also want to have all the uppercase characters from A to C, then we can write this

170
00:24:53,280 --> 00:25:04,240
back to back. So we can say small a to C or a dash C, then capital A dash C. Then this will also

171
00:25:04,240 --> 00:25:12,480
include all the uppercase characters. And again, we can use back to back and also include numbers.

172
00:25:13,280 --> 00:25:23,760
So yeah, then it also finds the numbers here. So the digits. So yeah, so this is how we can use

173
00:25:23,760 --> 00:25:37,920
sets with this brackets. And now let's talk about quantifier. So we have these quantifier, the

174
00:25:38,880 --> 00:25:50,000
meta meta characters. So we have a an asterisk. So a the multiplication sign, this means zero or

175
00:25:50,000 --> 00:25:57,200
more. Then we have the plus this means one or more, then we have the question mark. So this

176
00:25:57,200 --> 00:26:05,440
means zero or one. And this means or this can be used when we want to look for an optional

177
00:26:05,520 --> 00:26:12,560
character. So it may be there, but it may also be not there. Then if we want to look for a specific

178
00:26:12,560 --> 00:26:20,080
exact number, we can use curly braces and then a number here will look for the exact number.

179
00:26:21,600 --> 00:26:29,680
And then we can also specify a range with minimum and maximum. So if we put two numbers between

180
00:26:29,680 --> 00:26:37,360
the curly braces, then it's looking for a range. Okay, so let's have a look at them in detail. So

181
00:26:38,560 --> 00:26:48,160
let's say we have a string, let's say hello underscore 123. And now let's say we want to have

182
00:26:48,720 --> 00:26:55,920
or we want to find digits. And remember, we can do this with with backslash D. And then it will

183
00:26:55,920 --> 00:27:06,160
find all the digits. And let's say we want to look if we have zero or more. So then we use an

184
00:27:06,160 --> 00:27:15,280
asterisk. And then it will also find all the other characters here. Because here there is no

185
00:27:16,560 --> 00:27:24,560
digit, but it was looking for zero or more. And in this case, our match is just an empty string.

186
00:27:25,440 --> 00:27:32,400
And then again, an empty string, empty string, empty string. And then here we have digits. And

187
00:27:32,400 --> 00:27:41,760
then it will combine them into one match. So now if we just use the and use it without a quantifier,

188
00:27:41,760 --> 00:27:50,320
then it puts any every single digit as one match. And if we want to look for zero or more, we can

189
00:27:50,320 --> 00:27:58,160
use this with an asterisk. And now in this case, a plus is better. So we want to look for one or

190
00:27:58,160 --> 00:28:08,640
more. And then we will see it has only one match. And it combined all the digits into one match.

191
00:28:08,640 --> 00:28:14,640
And let's say we want to look for a digit that has an underscore in front of it. So let's say we

192
00:28:14,640 --> 00:28:24,400
want to look for underscore and then the digit, then it will find the one. And but now let's say

193
00:28:24,400 --> 00:28:30,320
we don't know if there is an underscore or not. So now if the string looks like this,

194
00:28:31,120 --> 00:28:37,920
and then if we run it, then it doesn't find a string, a match. And then we can say that the

195
00:28:38,000 --> 00:28:47,680
underscore is optional by using the question mark. And now if we run it, it finds all the matches,

196
00:28:48,720 --> 00:28:55,840
because it doesn't has an underscore. And now if we do it like this, then it will

197
00:28:57,520 --> 00:29:06,400
find the same matches because it can also have an underscore here. So this is the question mark.

198
00:29:07,120 --> 00:29:15,680
And now let's talk about specific ranges or a specific number of

199
00:29:17,760 --> 00:29:26,240
characters. So now if you want to look for three digits, then we can say a digit and then curly

200
00:29:26,240 --> 00:29:33,920
raise and then three, then it will find our match. So now if we are looking for four of the digits

201
00:29:33,920 --> 00:29:40,560
and run it, then we don't have a match. And we can also use a range here. So this can be between

202
00:29:40,560 --> 00:29:50,640
can be between one and three. And then it will also find the match. So these are the quantifiers.

203
00:29:51,280 --> 00:29:57,040
Now let's stop for a second with all the concepts and just make or just do an example.

204
00:29:57,600 --> 00:30:05,600
So let me copy this string here. And now let's use some of the concepts that we already know.

205
00:30:08,240 --> 00:30:16,800
So let's say our string is now the date string. So this is dates in different formats. So for

206
00:30:16,800 --> 00:30:25,120
example, here, we have the day and the month and then the year and this is separated by a colon.

207
00:30:25,120 --> 00:30:33,440
Then here it's the year first, then a colon, then here we have year, month and day separated by a

208
00:30:33,440 --> 00:30:42,960
dash and here by a slash and also by an underscore. And now let's say we only want to extract

209
00:30:44,080 --> 00:30:53,200
the dates with this format. So year, month and day, and only with a dash in between. So

210
00:30:53,200 --> 00:31:02,960
let's do this. So the first thing we can do is now here is to look for

211
00:31:05,520 --> 00:31:14,400
this pattern. So four, two and again two digits. So we can write this up. So backslash d backslash

212
00:31:15,280 --> 00:31:26,880
d. And then let's say first of all, we want to look for any character between. So remember,

213
00:31:26,880 --> 00:31:33,920
the point is a meta character. So this is looking, if you have a look at this here,

214
00:31:33,920 --> 00:31:42,320
this is looking for any character except new line. Then we have two digits. So backslash d,

215
00:31:42,320 --> 00:31:50,400
then again, we can have any character and then d and backslash d. So for example,

216
00:31:50,400 --> 00:31:56,800
if our string has also some text in it. And now if we run this,

217
00:31:59,440 --> 00:32:07,520
now it's called dates, the string. Now if we run this, then it will find all the

218
00:32:08,320 --> 00:32:19,200
all the states with with the numbers, but only in this format. So four, two, two. So for example,

219
00:32:19,760 --> 00:32:26,880
it didn't put the text here, the hello text in here. And it didn't put this date in here because

220
00:32:26,960 --> 00:32:42,000
it has a different format. So now this is our first try. And now what we can do here is, for

221
00:32:42,000 --> 00:32:50,240
example, the next thing we want to do is to find only these in this format. So now let's have a

222
00:32:50,240 --> 00:32:59,760
look at, so let's exchange the dot by a dash. So this is looking for an actual dash. And then we

223
00:32:59,760 --> 00:33:10,640
have only the dates in this format. So four, two and two numbers separated by a dash. And let's say

224
00:33:10,720 --> 00:33:22,080
we this may also be a valid date. So we can also looking for a slash as a separator here. So then

225
00:33:22,080 --> 00:33:32,320
we can use a set. So remember a set is defined in square brackets. And then we can define the

226
00:33:32,320 --> 00:33:40,240
characters that may be at this position. So for example, we have a dash. And we have also or may

227
00:33:40,400 --> 00:33:50,800
have a slash. And again, here we are using a set. So then we have dash slash and are closing our set.

228
00:33:50,800 --> 00:34:00,720
And now if we run this again, then we see, sorry, we see that this is also included in the matches.

229
00:34:00,720 --> 00:34:11,520
And now let's say, for example, we are looking only for dates in May or June. So how do we do

230
00:34:11,520 --> 00:34:22,720
that? So the month here. So what we do here is now this is not any digit. So here we are only

231
00:34:22,720 --> 00:34:34,400
looking for month 05 and 06. So we always have a zero here. And then we can again use a set.

232
00:34:35,120 --> 00:34:43,440
And here we can use, let's say only five and six. And now if we run this, then we only have the

233
00:34:43,440 --> 00:34:51,440
dates in May or June. And remember, we can also use a range here. So let's say we want to have

234
00:34:52,080 --> 00:35:02,160
May, June and July, then we can say five to seven. And then we have all the dates from May to July.

235
00:35:03,040 --> 00:35:13,280
And now let's use a quantifier here. So instead of writing for these here, backslash D, we can say

236
00:35:13,280 --> 00:35:23,440
D and then curly braces and use the quantifier for so we want to have exactly four digits here.

237
00:35:23,440 --> 00:35:32,880
And here we want to have exactly two digits. So then we can do it like this. So this finds all

238
00:35:32,880 --> 00:35:41,920
the dates in May, June or July in this format. So this is one typical example how regular

239
00:35:41,920 --> 00:35:50,720
expressions are useful. And yeah, so now let's continue. So we already covered a lot here.

240
00:35:50,720 --> 00:36:01,840
So let's talk about conditions next. So let me copy another string and do another example.

241
00:36:02,480 --> 00:36:11,520
So here I have another string with some names. So let me copy and paste this here. So this is

242
00:36:11,520 --> 00:36:19,840
my new string. So here we have a Mr. Simpson, a Mrs. Simpson, a Mr. Brown, a Miss Smith,

243
00:36:19,840 --> 00:36:35,120
and a Mr. T. And sometimes we have a dot between Mr. And sometimes not. And now let's just extract

244
00:36:35,120 --> 00:36:43,760
all the different names here. So for example, there's some more in our files. So for example,

245
00:36:43,840 --> 00:37:00,480
we have Hello World 123 date. And now we only we want to extract only the names and we want to

246
00:37:00,480 --> 00:37:12,480
have the whole name. So let's build up our pattern here. So let's look for Mr. First. So first we

247
00:37:12,480 --> 00:37:25,760
want to look for a Mr. So Mr. And then we have a white space. So backslash s. And then we have one

248
00:37:25,760 --> 00:37:36,560
or more characters, so word characters. So here we use a backslash w. And then we say plus. So this

249
00:37:36,640 --> 00:37:47,440
remember this is a quantifier. So one or more. And then I'm looking for the my string here. And I don't

250
00:37:47,440 --> 00:37:54,480
actually write the space here because I have this backslash s. And now if I run this, then we see

251
00:37:54,480 --> 00:38:06,080
that we have one match here. So this is our Mr. Simpson. So here we have the m r and then a space

252
00:38:06,080 --> 00:38:15,760
and then one or more word characters. And now as a next step, let's also include a Mr. Where we

253
00:38:15,760 --> 00:38:25,600
have the dot here. So we can have the dot. And now if you just write it like this and run it,

254
00:38:26,480 --> 00:38:34,000
then it finds a sorry, I have to use backslash dot, of course, here, because it's looking for an

255
00:38:34,000 --> 00:38:43,680
actual, I want to look for the actual dot. And now it only finds Mr. Brown and Mr. T, but not Mr.

256
00:38:43,680 --> 00:38:52,320
Simpson anymore. So now as we just learned, we have the optional quantifier with a question mark.

257
00:38:52,320 --> 00:39:01,680
So now let's make our dot optional. And now if we run this, then we have all the Mr. And

258
00:39:02,640 --> 00:39:12,720
now let's talk about where conditions are useful. So in this case, we may not only have Mr, but we

259
00:39:12,720 --> 00:39:21,840
may also have a miss or a misses. So then we can use a condition. So we use parentheses here.

260
00:39:22,560 --> 00:39:32,640
And then we separate them. So let's have a look at this here. This meta character is the either or.

261
00:39:33,440 --> 00:39:47,920
So now if we use this, we can write Mr or miss or misses. And then if we run this, then we see

262
00:39:48,880 --> 00:39:58,640
it extracted all the names from this text. So this is where a condition is useful.

263
00:39:59,600 --> 00:40:09,840
And as we have just seen, we grouped this condition together with the parentheses. So this is

264
00:40:10,800 --> 00:40:21,040
again one meta character. And now let's talk about grouping a little bit more. So let's do

265
00:40:21,040 --> 00:40:31,760
another example for this. This is also a typical example. So let's copy some emails into our text.

266
00:40:32,560 --> 00:40:39,440
And let's say we only want to extract the emails from this string here.

267
00:40:40,160 --> 00:40:52,560
So again, let's build up our pattern. So what we can do here is we can use sets to do this.

268
00:40:53,520 --> 00:41:00,560
So let's build this up. So let's say we want to have some characters here.

269
00:41:01,600 --> 00:41:09,200
So this may be word characters, but this may also be a dash and numbers.

270
00:41:10,800 --> 00:41:19,760
So let's use a set here and let's use back to back ranges here. So we can use small a to c

271
00:41:20,560 --> 00:41:32,080
or capital A to C, or also the digits zero to nine. Or we may also have a dash here.

272
00:41:32,800 --> 00:41:42,640
So now we are you looking for any of these characters here. And we want to have multiple

273
00:41:42,640 --> 00:41:52,640
of them. So we say we want to have multiple. So one or more. So this combines this group into one

274
00:41:52,640 --> 00:42:02,320
match. And then it is followed by an add sign. So now if we compile this and run this, then we see

275
00:42:03,040 --> 00:42:13,760
that it extracted all these patterns here with any words or numbers or dashes and then an

276
00:42:13,760 --> 00:42:26,000
add sign. So this is the name before the email. And then our email can have different domains.

277
00:42:26,000 --> 00:42:35,840
So for example, we have at gmail.com at gmx.de or at my domain or my dash domain dot org.

278
00:42:36,400 --> 00:42:45,280
So we want to extract all the different domains. And the next thing we want to look is to look for

279
00:42:45,280 --> 00:42:52,000
only for word characters. So the domain doesn't have a digit in it.

280
00:42:52,960 --> 00:43:03,040
So the only allowed characters are let's use another set. And here we use again, maybe a to c,

281
00:43:04,080 --> 00:43:13,520
a capital A to C, and also a dash. And then we have the dot. So now let's run this.

282
00:43:14,480 --> 00:43:27,360
And of course, there are again, one or more. So here I have to do a plus. And then it's looking

283
00:43:27,360 --> 00:43:38,480
for one or more. So now we see our match also includes the domain name and the dot. And then

284
00:43:38,560 --> 00:43:49,760
here at the very end, let's do another set. So here we say our ending. For example, we can say

285
00:43:49,760 --> 00:44:00,640
here we have dot. Sorry, again, I missed, I was not looking for an actual dot here. So this is a

286
00:44:00,640 --> 00:44:10,320
typical mistake that I make. So now it for example, it would have also found this one here. But this

287
00:44:10,320 --> 00:44:16,720
is not a valid email address. So I have to look for the actual dot by using the backslash.

288
00:44:18,400 --> 00:44:28,640
And then let's say I'm looking only for dot com. But it can also be dot de or dot org. So for

289
00:44:28,640 --> 00:44:40,000
example, I can use a group here by using parentheses and then use the condition here com or de or

290
00:44:40,000 --> 00:44:51,200
dot org. So now it would only find these endings here. And now let's not use a condition. But

291
00:44:51,200 --> 00:44:57,840
I just wanted to show you the condition here again. But we can also just use a set here. So

292
00:44:57,840 --> 00:45:11,280
let's use the set. And again, here, we may have a to C and a to C and capital and then one or more.

293
00:45:12,720 --> 00:45:23,920
And no digits here. So now if you run this, then this will extract all the emails for us. So this

294
00:45:23,920 --> 00:45:31,760
is a typical regular expression pattern to look for emails. And this is what I showed you in the

295
00:45:31,760 --> 00:45:40,320
beginning. So now you understand what this means. And now let's talk about grouping a little bit

296
00:45:40,320 --> 00:45:48,240
more. So there was one case just where I used the condition and then I have had to use parentheses.

297
00:45:49,200 --> 00:45:59,840
But we can also explicitly group our match object here into different substrings. So for example,

298
00:45:59,840 --> 00:46:13,280
I can put all of these before the ad sign into a group. So now let's use parentheses. And then

299
00:46:13,440 --> 00:46:26,080
let's use the ad sign. And then let's use the domain name. So this is one group until the dot.

300
00:46:26,800 --> 00:46:38,080
And then we have one group to have the ending here. And now we have three groups here.

301
00:46:38,560 --> 00:46:47,200
And as I showed you in the beginning, now if we run this, then this will give the same results.

302
00:46:47,200 --> 00:46:58,240
And here we are printing the whole match object. And then we can use the dot group to return the

303
00:46:58,240 --> 00:47:06,560
actual string. And this is by default, this is group zero. So this is the whole match string.

304
00:47:06,640 --> 00:47:16,480
But now we can also print the single groups that we just defined. So for example, we have group one,

305
00:47:16,480 --> 00:47:23,600
two and three now. And now if we run this and print this, then we see,

306
00:47:25,760 --> 00:47:33,120
let's just print the group one for now. Here, let's comment this out too.

307
00:47:33,840 --> 00:47:43,440
Then we see it only prints this group here. So only the name of the email before the ad sign.

308
00:47:43,440 --> 00:47:49,760
Then here this is the second group. So now if we print the group two, then this is

309
00:47:50,720 --> 00:47:58,080
the domain name. And if we want to have the ending, then we can print group three.

310
00:47:58,640 --> 00:48:06,880
So this is where grouping is useful. If we only want to have a look at specific things in our

311
00:48:06,880 --> 00:48:16,000
match, then we can use parentheses. Now let's move on. So now let's see, we talked about grouping.

312
00:48:16,000 --> 00:48:25,520
Now let's talk about modifications. So we have two methods to modify a string.

313
00:48:26,160 --> 00:48:35,920
So we have the split method and we have the sub method. So let's talk about both of them.

314
00:48:35,920 --> 00:48:42,880
So the split method will split the string into a list and splits wherever our

315
00:48:43,680 --> 00:48:50,720
regular expression matches. And the sub method will find all substrings where the regular

316
00:48:50,720 --> 00:48:58,080
expression matches and replaces them with a different string. So let's look at two examples.

317
00:48:58,720 --> 00:49:07,920
So let's say, let me grab a string here. So let's use this one again.

318
00:49:08,640 --> 00:49:19,520
So this is our test string. And now we use the pattern equals our e.compile and then we are

319
00:49:19,520 --> 00:49:33,120
looking for the raw string 123. Sorry, let's use a different one. Do I have it here? No, let's write

320
00:49:34,080 --> 00:49:49,840
it myself. So let's say abc123abcdef and capital letters again 123 and abc. And now let's say

321
00:49:49,840 --> 00:50:01,440
this is our pattern. So 123. And now we say our split it equals and then we say pattern dot split

322
00:50:02,160 --> 00:50:10,640
and give the test string as argument. And now let's print this split it. Now this will be a list

323
00:50:12,560 --> 00:50:24,160
where our string split it. Oh, sorry, this was a bad example. So let's use abc as split. And then we

324
00:50:24,160 --> 00:50:34,800
have splits where it's split it our string into different substrings and use this pattern here

325
00:50:35,600 --> 00:50:46,000
as the split. So here as the matching split. So here it has abc. So it's split it our string into

326
00:50:46,000 --> 00:50:55,840
this part. So there we have 123. And then this part. And then it found our pattern again abc.

327
00:50:57,440 --> 00:51:03,680
And then again, it's split it the string. And then at the end, we have the rest of the string. So

328
00:51:03,680 --> 00:51:11,920
this is the third substring that it found and and returned with this split method. So this is the

329
00:51:12,000 --> 00:51:22,480
split method. And now the sub method with the sub method, we find all the substrings where our

330
00:51:22,480 --> 00:51:31,440
pattern matches and then replace them with a different string. So let's say our test string

331
00:51:31,440 --> 00:51:44,640
equals hello world. And then let's say you are the best world. And use the so we use the word

332
00:51:44,640 --> 00:51:54,960
world two times. And then let's say we want to look for the pattern world. So we say pattern equals

333
00:51:54,960 --> 00:52:07,680
re.compile. And then an R raw string. And here we have world. And then we say our sub string

334
00:52:08,320 --> 00:52:18,160
equals and then we use pattern dot sub. And then what we want to put in as replacement,

335
00:52:18,800 --> 00:52:25,520
let's say we want to put in planet. And we also have to put in the test string.

336
00:52:26,240 --> 00:52:36,720
Now it took our test string, looked for all the matches where pattern matches. So it looked for

337
00:52:36,720 --> 00:52:44,880
world and replaced them with planet. So now this will return another string that was modified.

338
00:52:44,880 --> 00:52:53,360
And now if we print this, then we see it printed hello planet, you are the best planet. So this

339
00:52:53,360 --> 00:53:05,120
is the sub method. And now let's do another example to combine all that we have learned.

340
00:53:06,000 --> 00:53:12,240
And again, use the sub method. And yeah, so let's do this. So

341
00:53:14,640 --> 00:53:23,760
so let me grab this string here. So this is our URL strings. So here we have, again, let's say we

342
00:53:23,760 --> 00:53:36,240
have different things here. And then we are only looking for URLs, but they may have different

343
00:53:36,240 --> 00:53:49,600
formats. So for example, we have an HTTP URL, an HTTPS URL. And then sometimes we have a www

344
00:53:50,240 --> 00:53:59,440
and sometimes we don't have this. And then we have the typical domain name and ending.

345
00:54:00,480 --> 00:54:11,520
So yeah, so let's extract this. So let's build up our pattern again. So pattern equals re.compile and

346
00:54:11,520 --> 00:54:23,440
then a raw string. So now let's start by saying it starts with HTTP. And then a colon and two slashes.

347
00:54:24,320 --> 00:54:38,160
And then we have www and then we have a dot. So an actual dot. And then we have

348
00:54:38,720 --> 00:54:53,920
one or more word characters. So for example, we can use a set here again and use a to c and

349
00:54:53,920 --> 00:55:06,480
uppercase a to c and also a dash here. So like here. And so then we have a plus. So one or more.

350
00:55:07,520 --> 00:55:16,800
And let's put this into a group here right away. So this will return the same thing.

351
00:55:17,520 --> 00:55:27,120
And then we can later use this group here. And the next thing we again have a dot. So

352
00:55:27,120 --> 00:55:37,840
backslash dot. And then again, we can use a set here a to c and capital A to C.

353
00:55:38,800 --> 00:55:49,120
And now let's try this out. So let's say matches equals pattern dot find iter.

354
00:55:49,840 --> 00:56:02,160
And then we call this urls. And then for match in matches, we want to print the match. And let's

355
00:56:02,240 --> 00:56:10,000
try this and run this. And then we see we made some mistakes here. And this is because here I

356
00:56:10,000 --> 00:56:20,800
have to say plus, of course, so one or more. And now it only found this URL, because it didn't

357
00:56:20,800 --> 00:56:30,960
find this one because we have HTTPS here. And this one doesn't have www. So the first thing

358
00:56:30,960 --> 00:56:38,640
we can do here is to use an s. And this is an optional s. So remember s question mark. So this

359
00:56:39,840 --> 00:56:46,960
is optional then. And if we don't put this into a group, then the question mark will only refer

360
00:56:46,960 --> 00:56:56,480
to this character here. So now let's try this out. And now we see it also found the HTTPS URL.

361
00:56:57,280 --> 00:57:06,320
And now the same thing with the www. So this may be there or may not be there. So again,

362
00:57:06,320 --> 00:57:14,320
let's put this into a group. And then use an question mark to make this optional. And now if

363
00:57:14,320 --> 00:57:22,560
you run this again, then it still doesn't find it. And this is because our it must be www.

364
00:57:22,560 --> 00:57:30,880
So backslash dot, which must be optional. And then I don't need it here anymore. So let's

365
00:57:30,880 --> 00:57:40,240
run this. And then we see that it found all of the URLs and extracted them. And now let's say

366
00:57:40,240 --> 00:57:48,160
our string has only the URLs here. And now let's say we want to return a new string,

367
00:57:48,800 --> 00:57:57,680
where we replaced all of these optional beginnings. So it should only print the actual domain name

368
00:57:57,680 --> 00:58:06,080
with the ending. So as we have learned, we can use the sub method. So we can say,

369
00:58:08,080 --> 00:58:16,880
instead of just finding the matches, what we want to do here is let's also print this. And then

370
00:58:16,960 --> 00:58:27,840
let's say our sub URLs equals and then we use pattern and then sub. And then what we want to

371
00:58:27,840 --> 00:58:40,080
put in the replacement here. So for example, if we just say hello, and then URLs as a string and

372
00:58:40,080 --> 00:58:54,880
then print the sub URLs. So then we see that this is the new string here. So it's replaced all of

373
00:58:54,880 --> 00:59:07,200
the matches with hello. And now let's say we only want to put this in our string and only this,

374
00:59:07,920 --> 00:59:19,360
then what we can do here is we can group this and we already did this. So we have a group here,

375
00:59:19,360 --> 00:59:30,320
we have a group here. And let's also put this into our group into a group. And then what we

376
00:59:30,320 --> 00:59:41,120
can do is we can use back references to replace them. So here we can say backslash two and

377
00:59:43,360 --> 00:59:55,440
we must use a string so a raw string. And then we say backslash two and backslash three. And now

378
00:59:55,440 --> 01:00:05,520
if we run this, then this is our new string. So if I comment this out, then we see, then this is our

379
01:00:05,520 --> 01:00:14,720
new string. And what happened here, again, if we have a look at the group, so we can say,

380
01:00:15,360 --> 01:00:22,800
let's print all the different groups. So we have match dot group. So this will be the whole

381
01:00:23,600 --> 01:00:34,160
string. And now, so this is group zero again. Now let's have a look at what is group one.

382
01:00:34,720 --> 01:00:45,600
So for example, here, this is the group one, the first one in parentheses. And because this may

383
01:00:45,920 --> 01:00:55,200
optional, this may also be none. So the first URL has none as the first group because it doesn't

384
01:00:55,200 --> 01:01:04,800
have w w w. And this is the first group. So now let's print the second group. So this is the actual

385
01:01:05,360 --> 01:01:13,040
name of the domain. So the beginning. And then the group three is the ending so dot com dot com

386
01:01:13,040 --> 01:01:23,040
dot net. And now here we use this group two and group three with this back reference. And then

387
01:01:23,040 --> 01:01:30,320
replace the whole found pattern only with the domain name. So this is what happens here.

388
01:01:31,040 --> 01:01:38,320
And so this is also very often used in regular expressions. And now you know what this means.

389
01:01:39,680 --> 01:01:48,480
And I guess now we are almost through with all the context, all the things that I wanted to

390
01:01:48,480 --> 01:01:58,320
show you. And now as a last thing, let's quickly talk about compilation flags. So when we compile

391
01:01:58,320 --> 01:02:07,280
the pattern, then we also have to option to use different compilation flags. So here I listed

392
01:02:07,280 --> 01:02:12,960
them. And again, you don't have to remember them, just keep a cheat sheet. So here we have the

393
01:02:12,960 --> 01:02:22,480
different compilation flags. So ASCII dot all ignore case local multi line or verbose.

394
01:02:22,720 --> 01:02:29,520
So I recommend that you check out the official documentation to see what all of them mean

395
01:02:29,520 --> 01:02:37,600
in detail. And now I just want to show you the ignore case compilation flag. So this is also a

396
01:02:37,600 --> 01:02:51,600
very common use case. So let's say we have the string my string equals hello world. And then

397
01:02:52,560 --> 01:03:02,800
we want to look for the string world. And now if we compile this, and then try to find the matches

398
01:03:02,800 --> 01:03:14,320
and print them. So print the match. Now if you run this, sorry, this is called my string. Now if

399
01:03:14,320 --> 01:03:22,640
we run this, then it doesn't find a string. So because remember, this is case sensitive. Now if

400
01:03:22,640 --> 01:03:32,400
you make a capital W, then it finds the match world. And let's say we don't know what our string is.

401
01:03:32,400 --> 01:03:39,040
So it may be uppercase, but it may not be uppercase. So it doesn't matter for us. Then we can just

402
01:03:39,200 --> 01:03:49,600
use the compilation flag, our e dot ignore case. So we can write this out. So we can say ignore

403
01:03:50,240 --> 01:04:04,880
case. Or we can just say our re dot I. And then if we use a small w, then it will still find the

404
01:04:04,880 --> 01:04:12,640
match. And because now it ignored the cases. So this is the ignore case compilation flag.

405
01:04:12,640 --> 01:04:20,400
And now, yeah, you also have these compilation flags. So I recommend that you check them out

406
01:04:20,400 --> 01:04:26,800
for yourself. I will provide a link to the official documentation in the description.

407
01:04:27,360 --> 01:04:33,920
And now I think we are done. And now you should be able to understand all the different

408
01:04:33,920 --> 01:04:39,680
regular expressions. I hope it wasn't too complicated for you. And I hope you enjoyed

409
01:04:39,680 --> 01:04:44,400
this tutorial. If you like this, then please consider subscribing to the channel and leave

410
01:04:44,400 --> 01:04:47,040
me a like and see you next time. Bye.

