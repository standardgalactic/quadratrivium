{"text": " Hey guys, welcome to a new Python tutorial. Today I want to show you how we can work with regular expressions in Python. Regular expressions or short RE or REGX is a powerful method that is used to search for matching text patterns. For example, typical patterns that can be extracted from large text files with regular expressions are emails or domain names. So at the end of this tutorial, you will be able to understand what this regular expression here does. And there's a lot to cover in this tutorial. Don't be overwhelmed. I promise that once you have understood the concepts, it's not so hard anymore. And it can simplify and speed up your search tasks a lot. So if you watch the whole tutorial, then you will be able to understand any pattern that you want to look up. So now let me quickly show you what we will cover in this video. So of course, we will see how we work with the RE module in Python. Then I will show you what methods we have to search for matches, what we can do with a match object. Then we will talk about matter characters and more special sequences that can be used in patterns. Then we talk about sets, quantifiers, conditions, and then grouping, then modifications, so how we can modify strings with REs. And at the end, I show you some different compilation flags. So let's start. So as I already said, Python has a built in module that is called RE, which we can use to work with regular expressions. So we have to import RE. And then we can start working with regular expressions. So let me show you a very simple example first. So let's say here I have some test strings already. So let me copy and paste this here. So this is our test strings. And now let's say for example, we want to search for the pattern ABC. So we see we have this three times here. And now let's say we want to look for ABC, then we create a pattern. So let's say pattern equals and then we use the RE module and the compile method. And then here we say R and then the string ABC. So I will explain what R means in a second. And then we can use this pattern to find matches. So we say matches equals pattern dot find iter. And then we want to find the matches from the test string. And now this will be a object that we can iterate over. So we can say for match in matches. And then we simply print the match. So now let's run this. And then we see we have two matches. So this is a match object. And we can see more details. So for example, we can see the span. So this is the start and the end position. So this is three, four and five. And this is our match ABC and a second match at position 12. So this is position or index 12 in our string. So we see that we have two matches here. And what we also see here that our regular expression is case sensitive. So it doesn't include the uppercase ABC into our matches. So this is one thing that we must know. So one thing that I want to mention here is that instead of compiling our pattern explicitly, we can use the find iter method directly on the RE module. So we could also just write that our matches equals RE dot find iter. And then we want to look for our let's say string, our ABC, and then from our test string. So you can use it directly on the RE module. And then we will if we run this, we will see that we get the same results. So there is not much of a difference here. But I prefer to do it this way to explicitly compile them pattern and bind it to this object here. So this improves readability. And it's also a little bit more flexible. So I prefer it this way, but you should know that you can use both ways. And now let's talk about why I'm using this R here briefly. So this means that this is a raw string. So for example, if I have a string A, and this includes some special characters like a tap, so a backslash T that this is a tap or a backslash N for new line. And then I have a string. So now if I print this, then you will see that we have the tap here at the beginning. So it didn't print the backslash T. And in a pattern, I usually want to look for the actual characters in my pattern. So then I can write an R here. And then this means that this this is a raw string. So Python will print this the same way as it is specified here. And yeah, so I recommend to always use a raw string for your patterns, you can use just a normal string. But remember that you should use a raw string. And yeah, so this is a short example how a regular expression is used. So typically, we come up with our pattern, then we compile it. And then we use the pattern to find our matches. And I will show you the different methods that we have on the matches now. So now let's go over the methods to search for matches. So we already have seen the find iter method. And this will give us a match object. And I will show you what we can do with a match object in a second. So now let's talk about the other methods. So there are three other methods. So we can use the dot match method. So here dot match, then we have search. And then we also have find all. So now let's look about the find all method first. So if we can say pattern dot find all, then we will simply get the string. So if you see here, I'm printing the whole match object. So now if I want just a string, then I can use find all. And now if I run this, then it will just print the two strings that I'm looking for. So this is the find all method. Now the match method determines if the expression matches at the beginning of the string. So this will only return one match. So here I can say match equals pattern, and then match. And now if I print the match, so let's print the match and run this, then we will see this is none, because the match looks only for patterns at the beginning of our string. So ABC is not at the beginning. So now if I use 123 as a pattern, then we will see this is at the beginning. So this will return one match. And we also have the pattern here again. But again, the match does only return the first match if it is at the beginning of the string. And now we also have the search method. So the search method scans through the string and looks for any location where the RE matches. So if you use, for example, let's look for the match ABC again, then we will see this will return none because ABC has to be at the beginning. And now if we use this search method, then it will find the match object again, and it will simply return the first match. So we have search match find all and find iter. And this is my preferred method. So from now on, I will only use this one. And then we also have some functions that can be used to modify an object. So we also have split and sub. So I will come to them later. So now let's continue using the find iter method. And let's have a look at what we can do with the match object. So again, let's say our matches equals pattern, and then find iter. And then let's iterate over this. So for match in matches, and then we want to print the match. Then again, we see we have the whole match object here. And we can use four different methods on this. So we can use the group method, we can use the start and the end method. And we can get the span. So let's start with the span. So this will give me the start and the stop index, where this pattern is located. So let's print the match dot span. So then we simply get this as a tuple here. So we get three and six. So this is a tuple. And we can also get the just the start and the end right away by saying print match dot start and print match dot end. Oh, sorry, here is a dot match dot start. So then we get the start in the stop index. And now let's talk about the group method. So now if we call match dot group, then we will get or print the actual string of the match. And we can also give this group method arguments to find the group zero or one and or two. And we will talk about this grouping later. But for now on, if you just want the string then from the match, then just call match dot group or group zero. So this is the same. And yeah, so these are the four different methods that we can use on a match object. And now let's come to the matter characters. So in regular expressions, there are these method characters that have a special meaning. So these are all the method characters we must know. And you don't have to know them by heart. So I recommend that you keep a cheat sheet somewhere with all this stuff. And I will also provide a cheat sheet on my website. So you can check that out on Python minus engineer dot com. And this is all you need to know. So now let's talk about these method characters one by one. And then I will show you what this means. So the first one is the dot. So the dot means that we want to look for any character. So any character except a new line character, then the carrot means that we want to look for a pattern that starts with that starts with the pattern we are looking for. So that starts with the string hello, for example, then the dollar sign is the opposite. If you want to look for a string at the end of our text, then we have some quantifiers. So the asterisk, the plus and square brackets. And I will talk about them later in more detail. Then we have the set operator, which I will also cover later. Then we have conditions and grouping with parentheses. So I will also talk about this later. And of course, we have to look, we have the backslash. So with the backslash, we can get more special sequences, or we can escape characters. So for example, if you actually want to search for the dot, then we have to escape this in our pattern. So now let's talk about the first three and show you some examples. And then later we will cover the other meta characters in more detail. So now first let's say we want to look for the dot and then print all the matches, then we see we get all all the characters in our string, because the dot is looking for any character except new line. So this is the dot. And now let's say we have a dot here at the end, and we actually want to get this dot. So then we escape it with a backslash. And now if we run this, then we just get the dot. So now let's print the whole match object. Then we get the dot and we see that it is at this position. So this is the dot. And then let's have a look at the carrot. So this is the carrot. So let's say we want to look for 123 if it starts with this. And then we get one match object. And for example, now if we look for ABC, then it will return nothing, because it's not at the beginning. And the opposite if you want to have a look, if we want to look if this is at the end, so then we can say dollar here. And now if you run this, and this will find nothing because I'm sorry, we have the colon here, this will find nothing, because as I said, it is case sensitive. Now if I'm looking for uppercase ABC, and dollar at the end, so then it found the match at the end. All right, so now we will talk about the other meta characters later. And now let's look at some more special characters. So there are more special characters that start with a backslash. So there is the backslash and small D. This looks for any digit, so zero until nine. Then there's the capital backslash capital D. So this matches any non digit character. Then there's backslash, small s, this matches any white space character, for example, space, tap or new line. Then we have backslash capital is s, this matches any non white space character. So for all these patterns, all these special characters, the capital pattern is kind of the opposite of the small character here. So then we have backslash, small w, this matches any word character. So we have characters from A to C. We also have all the capital characters, and also digits and the underscore. Then the capital w is the opposite. So any non word character, non alphanumeric character. Then we have the backslash b. So this matches where the specified characters are at the beginning or at the end of a word. And again, we have the opposite. So where this is not at the beginning. So let's have a look at them in detail. So let's use another test string here. So let's, for example, use this one. And now if we want to look for any digit here, we can simply say we want to look for backslash d. And now if you run this, then we will see we have three matches, the digits one, two and three. Now if we use the opposite, so capital D, so any non digit, then it will find all the characters except one, two and three. Then let's have a look at the white space. So backslash s finds any white space character. So here we see we have a space here, a space here, and a space here. And then again, the opposite, so any non white space character is any other character. So this is the s special character. Then let's have a look at the w characters. So any alphanumeric character. So if I put in a w here, then it finds all the word characters. And again, the opposite capital D, this will just find the spaces in this example. And now let's have a look at the backslash B. So now if I am looking for hello, then it will find it because it is at the beginning of a block. And a block is not only the beginning of a string, but the beginning of any block that follows a white space character. So for example, if we look for hay, then it will also find the hay, but it will only find this pattern and not this one because it's looking for matches that are at the beginning of a block. So for example, if we put this before a space, then it will find and then it will find this pattern or this match to and again, the opposite. Now if we are looking for this, and we put ho hay here again, then it will find this hay because it is not at the beginning of a block where this is at the beginning of a block. So these are the special sequence, special characters that we should know. And now let's continue with sets. So we can use square brackets to look for sets. And let me show you what this means. So let's say we only have this string now. But now let's say we only want to look for a non-numeric character. So only for these ones, then we can use a set for this. So a set is a pattern between square brackets. And now here in this set, we can use multiple characters that we want to look up. For example, we want to look for a L and a O. And now if we run this, then it will find all these characters. And you must be careful here because it doesn't look for L O, but for any single character that we put into this set. And we can also specify ranges here. So we can instead of, let's say we also want to have the H and the E, then it will find any character here that is not a number and also not the not the underscore. So we can also specify a range here. And this is a very typical, very common example in regular expressions to use A dash C, so A to C. So all the lowercase characters, now if you run this, sometimes it's not saving this file automatically. So now if you run this, then we see that we will find all the letters here. And we can also look for digits. So let's say we want only the digits two and three. And again, here we can have a range. So we can say one to nine. So this is or let's say zero to nine. And this will find all the digits. So this is the same as using backslash D to find a digit. And so yeah, so if you want to specify a range, then that the dash can be used to declare to define the range. And now if you use it after a range, then it's looking for the actual dash. So now if you also want to look up a dash, then we can find it here. And if you put it between two things, then it is a range. So be careful here. And we can also write our different ranges back to back. So for example, if we have hello here in uppercase letters, and first of all, let's say we only want the lowercase letters. And then we also want to have all the uppercase characters from A to C, then we can write this back to back. So we can say small a to C or a dash C, then capital A dash C. Then this will also include all the uppercase characters. And again, we can use back to back and also include numbers. So yeah, then it also finds the numbers here. So the digits. So yeah, so this is how we can use sets with this brackets. And now let's talk about quantifier. So we have these quantifier, the meta meta characters. So we have a an asterisk. So a the multiplication sign, this means zero or more. Then we have the plus this means one or more, then we have the question mark. So this means zero or one. And this means or this can be used when we want to look for an optional character. So it may be there, but it may also be not there. Then if we want to look for a specific exact number, we can use curly braces and then a number here will look for the exact number. And then we can also specify a range with minimum and maximum. So if we put two numbers between the curly braces, then it's looking for a range. Okay, so let's have a look at them in detail. So let's say we have a string, let's say hello underscore 123. And now let's say we want to have or we want to find digits. And remember, we can do this with with backslash D. And then it will find all the digits. And let's say we want to look if we have zero or more. So then we use an asterisk. And then it will also find all the other characters here. Because here there is no digit, but it was looking for zero or more. And in this case, our match is just an empty string. And then again, an empty string, empty string, empty string. And then here we have digits. And then it will combine them into one match. So now if we just use the and use it without a quantifier, then it puts any every single digit as one match. And if we want to look for zero or more, we can use this with an asterisk. And now in this case, a plus is better. So we want to look for one or more. And then we will see it has only one match. And it combined all the digits into one match. And let's say we want to look for a digit that has an underscore in front of it. So let's say we want to look for underscore and then the digit, then it will find the one. And but now let's say we don't know if there is an underscore or not. So now if the string looks like this, and then if we run it, then it doesn't find a string, a match. And then we can say that the underscore is optional by using the question mark. And now if we run it, it finds all the matches, because it doesn't has an underscore. And now if we do it like this, then it will find the same matches because it can also have an underscore here. So this is the question mark. And now let's talk about specific ranges or a specific number of characters. So now if you want to look for three digits, then we can say a digit and then curly raise and then three, then it will find our match. So now if we are looking for four of the digits and run it, then we don't have a match. And we can also use a range here. So this can be between can be between one and three. And then it will also find the match. So these are the quantifiers. Now let's stop for a second with all the concepts and just make or just do an example. So let me copy this string here. And now let's use some of the concepts that we already know. So let's say our string is now the date string. So this is dates in different formats. So for example, here, we have the day and the month and then the year and this is separated by a colon. Then here it's the year first, then a colon, then here we have year, month and day separated by a dash and here by a slash and also by an underscore. And now let's say we only want to extract the dates with this format. So year, month and day, and only with a dash in between. So let's do this. So the first thing we can do is now here is to look for this pattern. So four, two and again two digits. So we can write this up. So backslash d backslash d. And then let's say first of all, we want to look for any character between. So remember, the point is a meta character. So this is looking, if you have a look at this here, this is looking for any character except new line. Then we have two digits. So backslash d, then again, we can have any character and then d and backslash d. So for example, if our string has also some text in it. And now if we run this, now it's called dates, the string. Now if we run this, then it will find all the all the states with with the numbers, but only in this format. So four, two, two. So for example, it didn't put the text here, the hello text in here. And it didn't put this date in here because it has a different format. So now this is our first try. And now what we can do here is, for example, the next thing we want to do is to find only these in this format. So now let's have a look at, so let's exchange the dot by a dash. So this is looking for an actual dash. And then we have only the dates in this format. So four, two and two numbers separated by a dash. And let's say we this may also be a valid date. So we can also looking for a slash as a separator here. So then we can use a set. So remember a set is defined in square brackets. And then we can define the characters that may be at this position. So for example, we have a dash. And we have also or may have a slash. And again, here we are using a set. So then we have dash slash and are closing our set. And now if we run this again, then we see, sorry, we see that this is also included in the matches. And now let's say, for example, we are looking only for dates in May or June. So how do we do that? So the month here. So what we do here is now this is not any digit. So here we are only looking for month 05 and 06. So we always have a zero here. And then we can again use a set. And here we can use, let's say only five and six. And now if we run this, then we only have the dates in May or June. And remember, we can also use a range here. So let's say we want to have May, June and July, then we can say five to seven. And then we have all the dates from May to July. And now let's use a quantifier here. So instead of writing for these here, backslash D, we can say D and then curly braces and use the quantifier for so we want to have exactly four digits here. And here we want to have exactly two digits. So then we can do it like this. So this finds all the dates in May, June or July in this format. So this is one typical example how regular expressions are useful. And yeah, so now let's continue. So we already covered a lot here. So let's talk about conditions next. So let me copy another string and do another example. So here I have another string with some names. So let me copy and paste this here. So this is my new string. So here we have a Mr. Simpson, a Mrs. Simpson, a Mr. Brown, a Miss Smith, and a Mr. T. And sometimes we have a dot between Mr. And sometimes not. And now let's just extract all the different names here. So for example, there's some more in our files. So for example, we have Hello World 123 date. And now we only we want to extract only the names and we want to have the whole name. So let's build up our pattern here. So let's look for Mr. First. So first we want to look for a Mr. So Mr. And then we have a white space. So backslash s. And then we have one or more characters, so word characters. So here we use a backslash w. And then we say plus. So this remember this is a quantifier. So one or more. And then I'm looking for the my string here. And I don't actually write the space here because I have this backslash s. And now if I run this, then we see that we have one match here. So this is our Mr. Simpson. So here we have the m r and then a space and then one or more word characters. And now as a next step, let's also include a Mr. Where we have the dot here. So we can have the dot. And now if you just write it like this and run it, then it finds a sorry, I have to use backslash dot, of course, here, because it's looking for an actual, I want to look for the actual dot. And now it only finds Mr. Brown and Mr. T, but not Mr. Simpson anymore. So now as we just learned, we have the optional quantifier with a question mark. So now let's make our dot optional. And now if we run this, then we have all the Mr. And now let's talk about where conditions are useful. So in this case, we may not only have Mr, but we may also have a miss or a misses. So then we can use a condition. So we use parentheses here. And then we separate them. So let's have a look at this here. This meta character is the either or. So now if we use this, we can write Mr or miss or misses. And then if we run this, then we see it extracted all the names from this text. So this is where a condition is useful. And as we have just seen, we grouped this condition together with the parentheses. So this is again one meta character. And now let's talk about grouping a little bit more. So let's do another example for this. This is also a typical example. So let's copy some emails into our text. And let's say we only want to extract the emails from this string here. So again, let's build up our pattern. So what we can do here is we can use sets to do this. So let's build this up. So let's say we want to have some characters here. So this may be word characters, but this may also be a dash and numbers. So let's use a set here and let's use back to back ranges here. So we can use small a to c or capital A to C, or also the digits zero to nine. Or we may also have a dash here. So now we are you looking for any of these characters here. And we want to have multiple of them. So we say we want to have multiple. So one or more. So this combines this group into one match. And then it is followed by an add sign. So now if we compile this and run this, then we see that it extracted all these patterns here with any words or numbers or dashes and then an add sign. So this is the name before the email. And then our email can have different domains. So for example, we have at gmail.com at gmx.de or at my domain or my dash domain dot org. So we want to extract all the different domains. And the next thing we want to look is to look for only for word characters. So the domain doesn't have a digit in it. So the only allowed characters are let's use another set. And here we use again, maybe a to c, a capital A to C, and also a dash. And then we have the dot. So now let's run this. And of course, there are again, one or more. So here I have to do a plus. And then it's looking for one or more. So now we see our match also includes the domain name and the dot. And then here at the very end, let's do another set. So here we say our ending. For example, we can say here we have dot. Sorry, again, I missed, I was not looking for an actual dot here. So this is a typical mistake that I make. So now it for example, it would have also found this one here. But this is not a valid email address. So I have to look for the actual dot by using the backslash. And then let's say I'm looking only for dot com. But it can also be dot de or dot org. So for example, I can use a group here by using parentheses and then use the condition here com or de or dot org. So now it would only find these endings here. And now let's not use a condition. But I just wanted to show you the condition here again. But we can also just use a set here. So let's use the set. And again, here, we may have a to C and a to C and capital and then one or more. And no digits here. So now if you run this, then this will extract all the emails for us. So this is a typical regular expression pattern to look for emails. And this is what I showed you in the beginning. So now you understand what this means. And now let's talk about grouping a little bit more. So there was one case just where I used the condition and then I have had to use parentheses. But we can also explicitly group our match object here into different substrings. So for example, I can put all of these before the ad sign into a group. So now let's use parentheses. And then let's use the ad sign. And then let's use the domain name. So this is one group until the dot. And then we have one group to have the ending here. And now we have three groups here. And as I showed you in the beginning, now if we run this, then this will give the same results. And here we are printing the whole match object. And then we can use the dot group to return the actual string. And this is by default, this is group zero. So this is the whole match string. But now we can also print the single groups that we just defined. So for example, we have group one, two and three now. And now if we run this and print this, then we see, let's just print the group one for now. Here, let's comment this out too. Then we see it only prints this group here. So only the name of the email before the ad sign. Then here this is the second group. So now if we print the group two, then this is the domain name. And if we want to have the ending, then we can print group three. So this is where grouping is useful. If we only want to have a look at specific things in our match, then we can use parentheses. Now let's move on. So now let's see, we talked about grouping. Now let's talk about modifications. So we have two methods to modify a string. So we have the split method and we have the sub method. So let's talk about both of them. So the split method will split the string into a list and splits wherever our regular expression matches. And the sub method will find all substrings where the regular expression matches and replaces them with a different string. So let's look at two examples. So let's say, let me grab a string here. So let's use this one again. So this is our test string. And now we use the pattern equals our e.compile and then we are looking for the raw string 123. Sorry, let's use a different one. Do I have it here? No, let's write it myself. So let's say abc123abcdef and capital letters again 123 and abc. And now let's say this is our pattern. So 123. And now we say our split it equals and then we say pattern dot split and give the test string as argument. And now let's print this split it. Now this will be a list where our string split it. Oh, sorry, this was a bad example. So let's use abc as split. And then we have splits where it's split it our string into different substrings and use this pattern here as the split. So here as the matching split. So here it has abc. So it's split it our string into this part. So there we have 123. And then this part. And then it found our pattern again abc. And then again, it's split it the string. And then at the end, we have the rest of the string. So this is the third substring that it found and and returned with this split method. So this is the split method. And now the sub method with the sub method, we find all the substrings where our pattern matches and then replace them with a different string. So let's say our test string equals hello world. And then let's say you are the best world. And use the so we use the word world two times. And then let's say we want to look for the pattern world. So we say pattern equals re.compile. And then an R raw string. And here we have world. And then we say our sub string equals and then we use pattern dot sub. And then what we want to put in as replacement, let's say we want to put in planet. And we also have to put in the test string. Now it took our test string, looked for all the matches where pattern matches. So it looked for world and replaced them with planet. So now this will return another string that was modified. And now if we print this, then we see it printed hello planet, you are the best planet. So this is the sub method. And now let's do another example to combine all that we have learned. And again, use the sub method. And yeah, so let's do this. So so let me grab this string here. So this is our URL strings. So here we have, again, let's say we have different things here. And then we are only looking for URLs, but they may have different formats. So for example, we have an HTTP URL, an HTTPS URL. And then sometimes we have a www and sometimes we don't have this. And then we have the typical domain name and ending. So yeah, so let's extract this. So let's build up our pattern again. So pattern equals re.compile and then a raw string. So now let's start by saying it starts with HTTP. And then a colon and two slashes. And then we have www and then we have a dot. So an actual dot. And then we have one or more word characters. So for example, we can use a set here again and use a to c and uppercase a to c and also a dash here. So like here. And so then we have a plus. So one or more. And let's put this into a group here right away. So this will return the same thing. And then we can later use this group here. And the next thing we again have a dot. So backslash dot. And then again, we can use a set here a to c and capital A to C. And now let's try this out. So let's say matches equals pattern dot find iter. And then we call this urls. And then for match in matches, we want to print the match. And let's try this and run this. And then we see we made some mistakes here. And this is because here I have to say plus, of course, so one or more. And now it only found this URL, because it didn't find this one because we have HTTPS here. And this one doesn't have www. So the first thing we can do here is to use an s. And this is an optional s. So remember s question mark. So this is optional then. And if we don't put this into a group, then the question mark will only refer to this character here. So now let's try this out. And now we see it also found the HTTPS URL. And now the same thing with the www. So this may be there or may not be there. So again, let's put this into a group. And then use an question mark to make this optional. And now if you run this again, then it still doesn't find it. And this is because our it must be www. So backslash dot, which must be optional. And then I don't need it here anymore. So let's run this. And then we see that it found all of the URLs and extracted them. And now let's say our string has only the URLs here. And now let's say we want to return a new string, where we replaced all of these optional beginnings. So it should only print the actual domain name with the ending. So as we have learned, we can use the sub method. So we can say, instead of just finding the matches, what we want to do here is let's also print this. And then let's say our sub URLs equals and then we use pattern and then sub. And then what we want to put in the replacement here. So for example, if we just say hello, and then URLs as a string and then print the sub URLs. So then we see that this is the new string here. So it's replaced all of the matches with hello. And now let's say we only want to put this in our string and only this, then what we can do here is we can group this and we already did this. So we have a group here, we have a group here. And let's also put this into our group into a group. And then what we can do is we can use back references to replace them. So here we can say backslash two and we must use a string so a raw string. And then we say backslash two and backslash three. And now if we run this, then this is our new string. So if I comment this out, then we see, then this is our new string. And what happened here, again, if we have a look at the group, so we can say, let's print all the different groups. So we have match dot group. So this will be the whole string. And now, so this is group zero again. Now let's have a look at what is group one. So for example, here, this is the group one, the first one in parentheses. And because this may optional, this may also be none. So the first URL has none as the first group because it doesn't have w w w. And this is the first group. So now let's print the second group. So this is the actual name of the domain. So the beginning. And then the group three is the ending so dot com dot com dot net. And now here we use this group two and group three with this back reference. And then replace the whole found pattern only with the domain name. So this is what happens here. And so this is also very often used in regular expressions. And now you know what this means. And I guess now we are almost through with all the context, all the things that I wanted to show you. And now as a last thing, let's quickly talk about compilation flags. So when we compile the pattern, then we also have to option to use different compilation flags. So here I listed them. And again, you don't have to remember them, just keep a cheat sheet. So here we have the different compilation flags. So ASCII dot all ignore case local multi line or verbose. So I recommend that you check out the official documentation to see what all of them mean in detail. And now I just want to show you the ignore case compilation flag. So this is also a very common use case. So let's say we have the string my string equals hello world. And then we want to look for the string world. And now if we compile this, and then try to find the matches and print them. So print the match. Now if you run this, sorry, this is called my string. Now if we run this, then it doesn't find a string. So because remember, this is case sensitive. Now if you make a capital W, then it finds the match world. And let's say we don't know what our string is. So it may be uppercase, but it may not be uppercase. So it doesn't matter for us. Then we can just use the compilation flag, our e dot ignore case. So we can write this out. So we can say ignore case. Or we can just say our re dot I. And then if we use a small w, then it will still find the match. And because now it ignored the cases. So this is the ignore case compilation flag. And now, yeah, you also have these compilation flags. So I recommend that you check them out for yourself. I will provide a link to the official documentation in the description. And now I think we are done. And now you should be able to understand all the different regular expressions. I hope it wasn't too complicated for you. And I hope you enjoyed this tutorial. If you like this, then please consider subscribing to the channel and leave me a like and see you next time. Bye.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 4.64, "text": " Hey guys, welcome to a new Python tutorial. Today I want to show you how we can work with", "tokens": [50364, 1911, 1074, 11, 2928, 281, 257, 777, 15329, 7073, 13, 2692, 286, 528, 281, 855, 291, 577, 321, 393, 589, 365, 50596], "temperature": 0.0, "avg_logprob": -0.12437937725549457, "compression_ratio": 1.6565217391304348, "no_speech_prob": 0.050177738070487976}, {"id": 1, "seek": 0, "start": 4.64, "end": 11.6, "text": " regular expressions in Python. Regular expressions or short RE or REGX is a powerful method that is", "tokens": [50596, 3890, 15277, 294, 15329, 13, 45659, 15277, 420, 2099, 10869, 420, 10869, 38, 55, 307, 257, 4005, 3170, 300, 307, 50944], "temperature": 0.0, "avg_logprob": -0.12437937725549457, "compression_ratio": 1.6565217391304348, "no_speech_prob": 0.050177738070487976}, {"id": 2, "seek": 0, "start": 11.6, "end": 17.52, "text": " used to search for matching text patterns. For example, typical patterns that can be extracted", "tokens": [50944, 1143, 281, 3164, 337, 14324, 2487, 8294, 13, 1171, 1365, 11, 7476, 8294, 300, 393, 312, 34086, 51240], "temperature": 0.0, "avg_logprob": -0.12437937725549457, "compression_ratio": 1.6565217391304348, "no_speech_prob": 0.050177738070487976}, {"id": 3, "seek": 0, "start": 17.52, "end": 24.0, "text": " from large text files with regular expressions are emails or domain names. So at the end of this", "tokens": [51240, 490, 2416, 2487, 7098, 365, 3890, 15277, 366, 12524, 420, 9274, 5288, 13, 407, 412, 264, 917, 295, 341, 51564], "temperature": 0.0, "avg_logprob": -0.12437937725549457, "compression_ratio": 1.6565217391304348, "no_speech_prob": 0.050177738070487976}, {"id": 4, "seek": 2400, "start": 24.0, "end": 30.72, "text": " tutorial, you will be able to understand what this regular expression here does. And there's a lot", "tokens": [50364, 7073, 11, 291, 486, 312, 1075, 281, 1223, 437, 341, 3890, 6114, 510, 775, 13, 400, 456, 311, 257, 688, 50700], "temperature": 0.0, "avg_logprob": -0.08206180773283306, "compression_ratio": 1.7324561403508771, "no_speech_prob": 0.4181460738182068}, {"id": 5, "seek": 2400, "start": 30.72, "end": 36.24, "text": " to cover in this tutorial. Don't be overwhelmed. I promise that once you have understood the concepts,", "tokens": [50700, 281, 2060, 294, 341, 7073, 13, 1468, 380, 312, 19042, 13, 286, 6228, 300, 1564, 291, 362, 7320, 264, 10392, 11, 50976], "temperature": 0.0, "avg_logprob": -0.08206180773283306, "compression_ratio": 1.7324561403508771, "no_speech_prob": 0.4181460738182068}, {"id": 6, "seek": 2400, "start": 36.24, "end": 42.16, "text": " it's not so hard anymore. And it can simplify and speed up your search tasks a lot. So if you", "tokens": [50976, 309, 311, 406, 370, 1152, 3602, 13, 400, 309, 393, 20460, 293, 3073, 493, 428, 3164, 9608, 257, 688, 13, 407, 498, 291, 51272], "temperature": 0.0, "avg_logprob": -0.08206180773283306, "compression_ratio": 1.7324561403508771, "no_speech_prob": 0.4181460738182068}, {"id": 7, "seek": 2400, "start": 42.16, "end": 46.96, "text": " watch the whole tutorial, then you will be able to understand any pattern that you want to look up.", "tokens": [51272, 1159, 264, 1379, 7073, 11, 550, 291, 486, 312, 1075, 281, 1223, 604, 5102, 300, 291, 528, 281, 574, 493, 13, 51512], "temperature": 0.0, "avg_logprob": -0.08206180773283306, "compression_ratio": 1.7324561403508771, "no_speech_prob": 0.4181460738182068}, {"id": 8, "seek": 4696, "start": 47.84, "end": 53.44, "text": " So now let me quickly show you what we will cover in this video. So of course,", "tokens": [50408, 407, 586, 718, 385, 2661, 855, 291, 437, 321, 486, 2060, 294, 341, 960, 13, 407, 295, 1164, 11, 50688], "temperature": 0.0, "avg_logprob": -0.069382796126805, "compression_ratio": 1.6682242990654206, "no_speech_prob": 0.17768031358718872}, {"id": 9, "seek": 4696, "start": 53.44, "end": 59.52, "text": " we will see how we work with the RE module in Python. Then I will show you what methods we", "tokens": [50688, 321, 486, 536, 577, 321, 589, 365, 264, 10869, 10088, 294, 15329, 13, 1396, 286, 486, 855, 291, 437, 7150, 321, 50992], "temperature": 0.0, "avg_logprob": -0.069382796126805, "compression_ratio": 1.6682242990654206, "no_speech_prob": 0.17768031358718872}, {"id": 10, "seek": 4696, "start": 59.52, "end": 66.32, "text": " have to search for matches, what we can do with a match object. Then we will talk about matter", "tokens": [50992, 362, 281, 3164, 337, 10676, 11, 437, 321, 393, 360, 365, 257, 2995, 2657, 13, 1396, 321, 486, 751, 466, 1871, 51332], "temperature": 0.0, "avg_logprob": -0.069382796126805, "compression_ratio": 1.6682242990654206, "no_speech_prob": 0.17768031358718872}, {"id": 11, "seek": 4696, "start": 66.32, "end": 74.16, "text": " characters and more special sequences that can be used in patterns. Then we talk about sets,", "tokens": [51332, 4342, 293, 544, 2121, 22978, 300, 393, 312, 1143, 294, 8294, 13, 1396, 321, 751, 466, 6352, 11, 51724], "temperature": 0.0, "avg_logprob": -0.069382796126805, "compression_ratio": 1.6682242990654206, "no_speech_prob": 0.17768031358718872}, {"id": 12, "seek": 7416, "start": 74.16, "end": 84.32, "text": " quantifiers, conditions, and then grouping, then modifications, so how we can modify strings with", "tokens": [50364, 4426, 23463, 11, 4487, 11, 293, 550, 40149, 11, 550, 26881, 11, 370, 577, 321, 393, 16927, 13985, 365, 50872], "temperature": 0.0, "avg_logprob": -0.10541101455688477, "compression_ratio": 1.5, "no_speech_prob": 0.005639573559165001}, {"id": 13, "seek": 7416, "start": 84.32, "end": 93.36, "text": " REs. And at the end, I show you some different compilation flags. So let's start. So as I already", "tokens": [50872, 10869, 82, 13, 400, 412, 264, 917, 11, 286, 855, 291, 512, 819, 40261, 23265, 13, 407, 718, 311, 722, 13, 407, 382, 286, 1217, 51324], "temperature": 0.0, "avg_logprob": -0.10541101455688477, "compression_ratio": 1.5, "no_speech_prob": 0.005639573559165001}, {"id": 14, "seek": 7416, "start": 93.36, "end": 101.44, "text": " said, Python has a built in module that is called RE, which we can use to work with regular expressions.", "tokens": [51324, 848, 11, 15329, 575, 257, 3094, 294, 10088, 300, 307, 1219, 10869, 11, 597, 321, 393, 764, 281, 589, 365, 3890, 15277, 13, 51728], "temperature": 0.0, "avg_logprob": -0.10541101455688477, "compression_ratio": 1.5, "no_speech_prob": 0.005639573559165001}, {"id": 15, "seek": 10144, "start": 101.44, "end": 108.56, "text": " So we have to import RE. And then we can start working with regular expressions. So let me show", "tokens": [50364, 407, 321, 362, 281, 974, 10869, 13, 400, 550, 321, 393, 722, 1364, 365, 3890, 15277, 13, 407, 718, 385, 855, 50720], "temperature": 0.0, "avg_logprob": -0.09526268432014867, "compression_ratio": 1.6153846153846154, "no_speech_prob": 0.012819668278098106}, {"id": 16, "seek": 10144, "start": 108.56, "end": 117.44, "text": " you a very simple example first. So let's say here I have some test strings already. So let me copy", "tokens": [50720, 291, 257, 588, 2199, 1365, 700, 13, 407, 718, 311, 584, 510, 286, 362, 512, 1500, 13985, 1217, 13, 407, 718, 385, 5055, 51164], "temperature": 0.0, "avg_logprob": -0.09526268432014867, "compression_ratio": 1.6153846153846154, "no_speech_prob": 0.012819668278098106}, {"id": 17, "seek": 10144, "start": 117.44, "end": 124.96, "text": " and paste this here. So this is our test strings. And now let's say for example, we want to search", "tokens": [51164, 293, 9163, 341, 510, 13, 407, 341, 307, 527, 1500, 13985, 13, 400, 586, 718, 311, 584, 337, 1365, 11, 321, 528, 281, 3164, 51540], "temperature": 0.0, "avg_logprob": -0.09526268432014867, "compression_ratio": 1.6153846153846154, "no_speech_prob": 0.012819668278098106}, {"id": 18, "seek": 12496, "start": 125.03999999999999, "end": 134.0, "text": " for the pattern ABC. So we see we have this three times here. And now let's say we want to look", "tokens": [50368, 337, 264, 5102, 22342, 13, 407, 321, 536, 321, 362, 341, 1045, 1413, 510, 13, 400, 586, 718, 311, 584, 321, 528, 281, 574, 50816], "temperature": 0.0, "avg_logprob": -0.10060746418802362, "compression_ratio": 1.6264367816091954, "no_speech_prob": 0.0591936819255352}, {"id": 19, "seek": 12496, "start": 134.0, "end": 142.4, "text": " for ABC, then we create a pattern. So let's say pattern equals and then we use the RE module", "tokens": [50816, 337, 22342, 11, 550, 321, 1884, 257, 5102, 13, 407, 718, 311, 584, 5102, 6915, 293, 550, 321, 764, 264, 10869, 10088, 51236], "temperature": 0.0, "avg_logprob": -0.10060746418802362, "compression_ratio": 1.6264367816091954, "no_speech_prob": 0.0591936819255352}, {"id": 20, "seek": 12496, "start": 142.4, "end": 151.35999999999999, "text": " and the compile method. And then here we say R and then the string ABC. So I will explain what", "tokens": [51236, 293, 264, 31413, 3170, 13, 400, 550, 510, 321, 584, 497, 293, 550, 264, 6798, 22342, 13, 407, 286, 486, 2903, 437, 51684], "temperature": 0.0, "avg_logprob": -0.10060746418802362, "compression_ratio": 1.6264367816091954, "no_speech_prob": 0.0591936819255352}, {"id": 21, "seek": 15136, "start": 151.36, "end": 160.0, "text": " R means in a second. And then we can use this pattern to find matches. So we say matches equals", "tokens": [50364, 497, 1355, 294, 257, 1150, 13, 400, 550, 321, 393, 764, 341, 5102, 281, 915, 10676, 13, 407, 321, 584, 10676, 6915, 50796], "temperature": 0.0, "avg_logprob": -0.10616034507751465, "compression_ratio": 1.598360655737705, "no_speech_prob": 0.07474793493747711}, {"id": 22, "seek": 15136, "start": 160.8, "end": 170.8, "text": " pattern dot find iter. And then we want to find the matches from the test string. And now this will", "tokens": [50836, 5102, 5893, 915, 17138, 13, 400, 550, 321, 528, 281, 915, 264, 10676, 490, 264, 1500, 6798, 13, 400, 586, 341, 486, 51336], "temperature": 0.0, "avg_logprob": -0.10616034507751465, "compression_ratio": 1.598360655737705, "no_speech_prob": 0.07474793493747711}, {"id": 23, "seek": 17080, "start": 170.8, "end": 181.76000000000002, "text": " be a object that we can iterate over. So we can say for match in matches. And then we simply print", "tokens": [50364, 312, 257, 2657, 300, 321, 393, 44497, 670, 13, 407, 321, 393, 584, 337, 2995, 294, 10676, 13, 400, 550, 321, 2935, 4482, 50912], "temperature": 0.0, "avg_logprob": -0.057648207924582744, "compression_ratio": 1.5433070866141732, "no_speech_prob": 0.34495702385902405}, {"id": 24, "seek": 17080, "start": 181.76000000000002, "end": 193.04000000000002, "text": " the match. So now let's run this. And then we see we have two matches. So this is a match object.", "tokens": [50912, 264, 2995, 13, 407, 586, 718, 311, 1190, 341, 13, 400, 550, 321, 536, 321, 362, 732, 10676, 13, 407, 341, 307, 257, 2995, 2657, 13, 51476], "temperature": 0.0, "avg_logprob": -0.057648207924582744, "compression_ratio": 1.5433070866141732, "no_speech_prob": 0.34495702385902405}, {"id": 25, "seek": 19304, "start": 193.04, "end": 199.51999999999998, "text": " And we can see more details. So for example, we can see the span. So this is the start", "tokens": [50364, 400, 321, 393, 536, 544, 4365, 13, 407, 337, 1365, 11, 321, 393, 536, 264, 16174, 13, 407, 341, 307, 264, 722, 50688], "temperature": 0.0, "avg_logprob": -0.06670604070027669, "compression_ratio": 1.732484076433121, "no_speech_prob": 0.03845895826816559}, {"id": 26, "seek": 19304, "start": 200.07999999999998, "end": 209.35999999999999, "text": " and the end position. So this is three, four and five. And this is our match ABC and a second", "tokens": [50716, 293, 264, 917, 2535, 13, 407, 341, 307, 1045, 11, 1451, 293, 1732, 13, 400, 341, 307, 527, 2995, 22342, 293, 257, 1150, 51180], "temperature": 0.0, "avg_logprob": -0.06670604070027669, "compression_ratio": 1.732484076433121, "no_speech_prob": 0.03845895826816559}, {"id": 27, "seek": 19304, "start": 209.35999999999999, "end": 217.04, "text": " match at position 12. So this is position or index 12 in our string. So we see that we have", "tokens": [51180, 2995, 412, 2535, 2272, 13, 407, 341, 307, 2535, 420, 8186, 2272, 294, 527, 6798, 13, 407, 321, 536, 300, 321, 362, 51564], "temperature": 0.0, "avg_logprob": -0.06670604070027669, "compression_ratio": 1.732484076433121, "no_speech_prob": 0.03845895826816559}, {"id": 28, "seek": 21704, "start": 217.04, "end": 224.72, "text": " two matches here. And what we also see here that our regular expression is case sensitive. So it", "tokens": [50364, 732, 10676, 510, 13, 400, 437, 321, 611, 536, 510, 300, 527, 3890, 6114, 307, 1389, 9477, 13, 407, 309, 50748], "temperature": 0.0, "avg_logprob": -0.04256285230318705, "compression_ratio": 1.575268817204301, "no_speech_prob": 0.07367585599422455}, {"id": 29, "seek": 21704, "start": 224.72, "end": 234.39999999999998, "text": " doesn't include the uppercase ABC into our matches. So this is one thing that we must know. So one", "tokens": [50748, 1177, 380, 4090, 264, 11775, 2869, 651, 22342, 666, 527, 10676, 13, 407, 341, 307, 472, 551, 300, 321, 1633, 458, 13, 407, 472, 51232], "temperature": 0.0, "avg_logprob": -0.04256285230318705, "compression_ratio": 1.575268817204301, "no_speech_prob": 0.07367585599422455}, {"id": 30, "seek": 21704, "start": 234.39999999999998, "end": 242.07999999999998, "text": " thing that I want to mention here is that instead of compiling our pattern explicitly, we can use", "tokens": [51232, 551, 300, 286, 528, 281, 2152, 510, 307, 300, 2602, 295, 715, 4883, 527, 5102, 20803, 11, 321, 393, 764, 51616], "temperature": 0.0, "avg_logprob": -0.04256285230318705, "compression_ratio": 1.575268817204301, "no_speech_prob": 0.07367585599422455}, {"id": 31, "seek": 24208, "start": 242.08, "end": 252.32000000000002, "text": " the find iter method directly on the RE module. So we could also just write that our matches", "tokens": [50364, 264, 915, 17138, 3170, 3838, 322, 264, 10869, 10088, 13, 407, 321, 727, 611, 445, 2464, 300, 527, 10676, 50876], "temperature": 0.0, "avg_logprob": -0.1497570059516213, "compression_ratio": 1.3125, "no_speech_prob": 0.18467995524406433}, {"id": 32, "seek": 24208, "start": 253.12, "end": 263.52000000000004, "text": " equals RE dot find iter. And then we want to look for our let's say string,", "tokens": [50916, 6915, 10869, 5893, 915, 17138, 13, 400, 550, 321, 528, 281, 574, 337, 527, 718, 311, 584, 6798, 11, 51436], "temperature": 0.0, "avg_logprob": -0.1497570059516213, "compression_ratio": 1.3125, "no_speech_prob": 0.18467995524406433}, {"id": 33, "seek": 26352, "start": 264.32, "end": 275.03999999999996, "text": " our ABC, and then from our test string. So you can use it directly on the RE module. And then we", "tokens": [50404, 527, 22342, 11, 293, 550, 490, 527, 1500, 6798, 13, 407, 291, 393, 764, 309, 3838, 322, 264, 10869, 10088, 13, 400, 550, 321, 50940], "temperature": 0.0, "avg_logprob": -0.12242161143909801, "compression_ratio": 1.5206185567010309, "no_speech_prob": 0.08387820422649384}, {"id": 34, "seek": 26352, "start": 275.03999999999996, "end": 283.03999999999996, "text": " will if we run this, we will see that we get the same results. So there is not much of a difference", "tokens": [50940, 486, 498, 321, 1190, 341, 11, 321, 486, 536, 300, 321, 483, 264, 912, 3542, 13, 407, 456, 307, 406, 709, 295, 257, 2649, 51340], "temperature": 0.0, "avg_logprob": -0.12242161143909801, "compression_ratio": 1.5206185567010309, "no_speech_prob": 0.08387820422649384}, {"id": 35, "seek": 26352, "start": 283.03999999999996, "end": 293.28, "text": " here. But I prefer to do it this way to explicitly compile them pattern and bind it to this object", "tokens": [51340, 510, 13, 583, 286, 4382, 281, 360, 309, 341, 636, 281, 20803, 31413, 552, 5102, 293, 14786, 309, 281, 341, 2657, 51852], "temperature": 0.0, "avg_logprob": -0.12242161143909801, "compression_ratio": 1.5206185567010309, "no_speech_prob": 0.08387820422649384}, {"id": 36, "seek": 29328, "start": 293.35999999999996, "end": 301.2, "text": " here. So this improves readability. And it's also a little bit more flexible. So I prefer it this", "tokens": [50368, 510, 13, 407, 341, 24771, 1401, 2310, 13, 400, 309, 311, 611, 257, 707, 857, 544, 11358, 13, 407, 286, 4382, 309, 341, 50760], "temperature": 0.0, "avg_logprob": -0.09743627309799194, "compression_ratio": 1.5372340425531914, "no_speech_prob": 0.012819657102227211}, {"id": 37, "seek": 29328, "start": 301.2, "end": 310.32, "text": " way, but you should know that you can use both ways. And now let's talk about why I'm using this", "tokens": [50760, 636, 11, 457, 291, 820, 458, 300, 291, 393, 764, 1293, 2098, 13, 400, 586, 718, 311, 751, 466, 983, 286, 478, 1228, 341, 51216], "temperature": 0.0, "avg_logprob": -0.09743627309799194, "compression_ratio": 1.5372340425531914, "no_speech_prob": 0.012819657102227211}, {"id": 38, "seek": 29328, "start": 310.32, "end": 321.28, "text": " R here briefly. So this means that this is a raw string. So for example, if I have a string A,", "tokens": [51216, 497, 510, 10515, 13, 407, 341, 1355, 300, 341, 307, 257, 8936, 6798, 13, 407, 337, 1365, 11, 498, 286, 362, 257, 6798, 316, 11, 51764], "temperature": 0.0, "avg_logprob": -0.09743627309799194, "compression_ratio": 1.5372340425531914, "no_speech_prob": 0.012819657102227211}, {"id": 39, "seek": 32128, "start": 322.08, "end": 330.0, "text": " and this includes some special characters like a tap, so a backslash T that this is a tap or a", "tokens": [50404, 293, 341, 5974, 512, 2121, 4342, 411, 257, 5119, 11, 370, 257, 646, 10418, 1299, 314, 300, 341, 307, 257, 5119, 420, 257, 50800], "temperature": 0.0, "avg_logprob": -0.10215038972742417, "compression_ratio": 1.6263736263736264, "no_speech_prob": 0.014500831253826618}, {"id": 40, "seek": 32128, "start": 330.0, "end": 340.0, "text": " backslash N for new line. And then I have a string. So now if I print this, then you will see that we", "tokens": [50800, 646, 10418, 1299, 426, 337, 777, 1622, 13, 400, 550, 286, 362, 257, 6798, 13, 407, 586, 498, 286, 4482, 341, 11, 550, 291, 486, 536, 300, 321, 51300], "temperature": 0.0, "avg_logprob": -0.10215038972742417, "compression_ratio": 1.6263736263736264, "no_speech_prob": 0.014500831253826618}, {"id": 41, "seek": 32128, "start": 340.0, "end": 348.23999999999995, "text": " have the tap here at the beginning. So it didn't print the backslash T. And in a pattern, I usually", "tokens": [51300, 362, 264, 5119, 510, 412, 264, 2863, 13, 407, 309, 994, 380, 4482, 264, 646, 10418, 1299, 314, 13, 400, 294, 257, 5102, 11, 286, 2673, 51712], "temperature": 0.0, "avg_logprob": -0.10215038972742417, "compression_ratio": 1.6263736263736264, "no_speech_prob": 0.014500831253826618}, {"id": 42, "seek": 34824, "start": 348.24, "end": 356.32, "text": " want to look for the actual characters in my pattern. So then I can write an R here. And then", "tokens": [50364, 528, 281, 574, 337, 264, 3539, 4342, 294, 452, 5102, 13, 407, 550, 286, 393, 2464, 364, 497, 510, 13, 400, 550, 50768], "temperature": 0.0, "avg_logprob": -0.06166344472806748, "compression_ratio": 1.6079545454545454, "no_speech_prob": 0.030206644907593727}, {"id": 43, "seek": 34824, "start": 356.32, "end": 363.04, "text": " this means that this this is a raw string. So Python will print this the same way as it is", "tokens": [50768, 341, 1355, 300, 341, 341, 307, 257, 8936, 6798, 13, 407, 15329, 486, 4482, 341, 264, 912, 636, 382, 309, 307, 51104], "temperature": 0.0, "avg_logprob": -0.06166344472806748, "compression_ratio": 1.6079545454545454, "no_speech_prob": 0.030206644907593727}, {"id": 44, "seek": 34824, "start": 363.04, "end": 370.8, "text": " specified here. And yeah, so I recommend to always use a raw string for your patterns, you can use", "tokens": [51104, 22206, 510, 13, 400, 1338, 11, 370, 286, 2748, 281, 1009, 764, 257, 8936, 6798, 337, 428, 8294, 11, 291, 393, 764, 51492], "temperature": 0.0, "avg_logprob": -0.06166344472806748, "compression_ratio": 1.6079545454545454, "no_speech_prob": 0.030206644907593727}, {"id": 45, "seek": 37080, "start": 370.8, "end": 378.48, "text": " just a normal string. But remember that you should use a raw string. And yeah, so this is a short", "tokens": [50364, 445, 257, 2710, 6798, 13, 583, 1604, 300, 291, 820, 764, 257, 8936, 6798, 13, 400, 1338, 11, 370, 341, 307, 257, 2099, 50748], "temperature": 0.0, "avg_logprob": -0.04616988036367628, "compression_ratio": 1.5405405405405406, "no_speech_prob": 0.07583964616060257}, {"id": 46, "seek": 37080, "start": 378.48, "end": 384.8, "text": " example how a regular expression is used. So typically, we come up with our pattern, then we", "tokens": [50748, 1365, 577, 257, 3890, 6114, 307, 1143, 13, 407, 5850, 11, 321, 808, 493, 365, 527, 5102, 11, 550, 321, 51064], "temperature": 0.0, "avg_logprob": -0.04616988036367628, "compression_ratio": 1.5405405405405406, "no_speech_prob": 0.07583964616060257}, {"id": 47, "seek": 37080, "start": 384.8, "end": 393.44, "text": " compile it. And then we use the pattern to find our matches. And I will show you the different", "tokens": [51064, 31413, 309, 13, 400, 550, 321, 764, 264, 5102, 281, 915, 527, 10676, 13, 400, 286, 486, 855, 291, 264, 819, 51496], "temperature": 0.0, "avg_logprob": -0.04616988036367628, "compression_ratio": 1.5405405405405406, "no_speech_prob": 0.07583964616060257}, {"id": 48, "seek": 39344, "start": 393.44, "end": 402.24, "text": " methods that we have on the matches now. So now let's go over the methods to search for matches.", "tokens": [50364, 7150, 300, 321, 362, 322, 264, 10676, 586, 13, 407, 586, 718, 311, 352, 670, 264, 7150, 281, 3164, 337, 10676, 13, 50804], "temperature": 0.0, "avg_logprob": -0.08681871439959551, "compression_ratio": 1.709090909090909, "no_speech_prob": 0.34845682978630066}, {"id": 49, "seek": 39344, "start": 402.96, "end": 412.15999999999997, "text": " So we already have seen the find iter method. And this will give us a match object. And I", "tokens": [50840, 407, 321, 1217, 362, 1612, 264, 915, 17138, 3170, 13, 400, 341, 486, 976, 505, 257, 2995, 2657, 13, 400, 286, 51300], "temperature": 0.0, "avg_logprob": -0.08681871439959551, "compression_ratio": 1.709090909090909, "no_speech_prob": 0.34845682978630066}, {"id": 50, "seek": 39344, "start": 412.15999999999997, "end": 418.88, "text": " will show you what we can do with a match object in a second. So now let's talk about the other", "tokens": [51300, 486, 855, 291, 437, 321, 393, 360, 365, 257, 2995, 2657, 294, 257, 1150, 13, 407, 586, 718, 311, 751, 466, 264, 661, 51636], "temperature": 0.0, "avg_logprob": -0.08681871439959551, "compression_ratio": 1.709090909090909, "no_speech_prob": 0.34845682978630066}, {"id": 51, "seek": 41888, "start": 418.88, "end": 427.92, "text": " methods. So there are three other methods. So we can use the dot match method. So here dot match,", "tokens": [50364, 7150, 13, 407, 456, 366, 1045, 661, 7150, 13, 407, 321, 393, 764, 264, 5893, 2995, 3170, 13, 407, 510, 5893, 2995, 11, 50816], "temperature": 0.0, "avg_logprob": -0.0678718090057373, "compression_ratio": 1.603305785123967, "no_speech_prob": 0.13291099667549133}, {"id": 52, "seek": 41888, "start": 427.92, "end": 441.12, "text": " then we have search. And then we also have find all. So now let's look about the find all method", "tokens": [50816, 550, 321, 362, 3164, 13, 400, 550, 321, 611, 362, 915, 439, 13, 407, 586, 718, 311, 574, 466, 264, 915, 439, 3170, 51476], "temperature": 0.0, "avg_logprob": -0.0678718090057373, "compression_ratio": 1.603305785123967, "no_speech_prob": 0.13291099667549133}, {"id": 53, "seek": 44112, "start": 441.12, "end": 448.96, "text": " first. So if we can say pattern dot find all, then we will simply get the string. So if you see", "tokens": [50364, 700, 13, 407, 498, 321, 393, 584, 5102, 5893, 915, 439, 11, 550, 321, 486, 2935, 483, 264, 6798, 13, 407, 498, 291, 536, 50756], "temperature": 0.0, "avg_logprob": -0.0626801116557061, "compression_ratio": 1.6470588235294117, "no_speech_prob": 0.327455073595047}, {"id": 54, "seek": 44112, "start": 448.96, "end": 456.96, "text": " here, I'm printing the whole match object. So now if I want just a string, then I can use find all.", "tokens": [50756, 510, 11, 286, 478, 14699, 264, 1379, 2995, 2657, 13, 407, 586, 498, 286, 528, 445, 257, 6798, 11, 550, 286, 393, 764, 915, 439, 13, 51156], "temperature": 0.0, "avg_logprob": -0.0626801116557061, "compression_ratio": 1.6470588235294117, "no_speech_prob": 0.327455073595047}, {"id": 55, "seek": 44112, "start": 456.96, "end": 462.56, "text": " And now if I run this, then it will just print the two strings that I'm looking for.", "tokens": [51156, 400, 586, 498, 286, 1190, 341, 11, 550, 309, 486, 445, 4482, 264, 732, 13985, 300, 286, 478, 1237, 337, 13, 51436], "temperature": 0.0, "avg_logprob": -0.0626801116557061, "compression_ratio": 1.6470588235294117, "no_speech_prob": 0.327455073595047}, {"id": 56, "seek": 46256, "start": 463.52, "end": 473.52, "text": " So this is the find all method. Now the match method determines if the expression matches at", "tokens": [50412, 407, 341, 307, 264, 915, 439, 3170, 13, 823, 264, 2995, 3170, 24799, 498, 264, 6114, 10676, 412, 50912], "temperature": 0.0, "avg_logprob": -0.10784480836656359, "compression_ratio": 1.4803149606299213, "no_speech_prob": 0.046715546399354935}, {"id": 57, "seek": 46256, "start": 473.52, "end": 484.24, "text": " the beginning of the string. So this will only return one match. So here I can say match equals", "tokens": [50912, 264, 2863, 295, 264, 6798, 13, 407, 341, 486, 787, 2736, 472, 2995, 13, 407, 510, 286, 393, 584, 2995, 6915, 51448], "temperature": 0.0, "avg_logprob": -0.10784480836656359, "compression_ratio": 1.4803149606299213, "no_speech_prob": 0.046715546399354935}, {"id": 58, "seek": 48424, "start": 484.24, "end": 496.24, "text": " pattern, and then match. And now if I print the match, so let's print the match and run this,", "tokens": [50364, 5102, 11, 293, 550, 2995, 13, 400, 586, 498, 286, 4482, 264, 2995, 11, 370, 718, 311, 4482, 264, 2995, 293, 1190, 341, 11, 50964], "temperature": 0.0, "avg_logprob": -0.07371133333676821, "compression_ratio": 1.7839506172839505, "no_speech_prob": 0.10967143625020981}, {"id": 59, "seek": 48424, "start": 496.24, "end": 503.12, "text": " then we will see this is none, because the match looks only for patterns at the beginning of our", "tokens": [50964, 550, 321, 486, 536, 341, 307, 6022, 11, 570, 264, 2995, 1542, 787, 337, 8294, 412, 264, 2863, 295, 527, 51308], "temperature": 0.0, "avg_logprob": -0.07371133333676821, "compression_ratio": 1.7839506172839505, "no_speech_prob": 0.10967143625020981}, {"id": 60, "seek": 48424, "start": 503.12, "end": 512.96, "text": " string. So ABC is not at the beginning. So now if I use 123 as a pattern, then we will see this is", "tokens": [51308, 6798, 13, 407, 22342, 307, 406, 412, 264, 2863, 13, 407, 586, 498, 286, 764, 34466, 382, 257, 5102, 11, 550, 321, 486, 536, 341, 307, 51800], "temperature": 0.0, "avg_logprob": -0.07371133333676821, "compression_ratio": 1.7839506172839505, "no_speech_prob": 0.10967143625020981}, {"id": 61, "seek": 51424, "start": 514.24, "end": 522.0, "text": " at the beginning. So this will return one match. And we also have the pattern here again. But again,", "tokens": [50364, 412, 264, 2863, 13, 407, 341, 486, 2736, 472, 2995, 13, 400, 321, 611, 362, 264, 5102, 510, 797, 13, 583, 797, 11, 50752], "temperature": 0.0, "avg_logprob": -0.06840985471552069, "compression_ratio": 1.7647058823529411, "no_speech_prob": 0.005218814127147198}, {"id": 62, "seek": 51424, "start": 522.96, "end": 530.24, "text": " the match does only return the first match if it is at the beginning of the string.", "tokens": [50800, 264, 2995, 775, 787, 2736, 264, 700, 2995, 498, 309, 307, 412, 264, 2863, 295, 264, 6798, 13, 51164], "temperature": 0.0, "avg_logprob": -0.06840985471552069, "compression_ratio": 1.7647058823529411, "no_speech_prob": 0.005218814127147198}, {"id": 63, "seek": 51424, "start": 531.36, "end": 539.28, "text": " And now we also have the search method. So the search method scans through the string", "tokens": [51220, 400, 586, 321, 611, 362, 264, 3164, 3170, 13, 407, 264, 3164, 3170, 35116, 807, 264, 6798, 51616], "temperature": 0.0, "avg_logprob": -0.06840985471552069, "compression_ratio": 1.7647058823529411, "no_speech_prob": 0.005218814127147198}, {"id": 64, "seek": 53928, "start": 539.28, "end": 548.0, "text": " and looks for any location where the RE matches. So if you use, for example, let's look for the match", "tokens": [50364, 293, 1542, 337, 604, 4914, 689, 264, 10869, 10676, 13, 407, 498, 291, 764, 11, 337, 1365, 11, 718, 311, 574, 337, 264, 2995, 50800], "temperature": 0.0, "avg_logprob": -0.11961555480957031, "compression_ratio": 1.5536723163841808, "no_speech_prob": 0.031133711338043213}, {"id": 65, "seek": 53928, "start": 548.56, "end": 556.3199999999999, "text": " ABC again, then we will see this will return none because ABC has to be at the beginning.", "tokens": [50828, 22342, 797, 11, 550, 321, 486, 536, 341, 486, 2736, 6022, 570, 22342, 575, 281, 312, 412, 264, 2863, 13, 51216], "temperature": 0.0, "avg_logprob": -0.11961555480957031, "compression_ratio": 1.5536723163841808, "no_speech_prob": 0.031133711338043213}, {"id": 66, "seek": 53928, "start": 556.3199999999999, "end": 563.28, "text": " And now if we use this search method, then it will find the match object again, and", "tokens": [51216, 400, 586, 498, 321, 764, 341, 3164, 3170, 11, 550, 309, 486, 915, 264, 2995, 2657, 797, 11, 293, 51564], "temperature": 0.0, "avg_logprob": -0.11961555480957031, "compression_ratio": 1.5536723163841808, "no_speech_prob": 0.031133711338043213}, {"id": 67, "seek": 56328, "start": 563.28, "end": 574.16, "text": " it will simply return the first match. So we have search match find all and find iter. And this is my", "tokens": [50364, 309, 486, 2935, 2736, 264, 700, 2995, 13, 407, 321, 362, 3164, 2995, 915, 439, 293, 915, 17138, 13, 400, 341, 307, 452, 50908], "temperature": 0.0, "avg_logprob": -0.1168469880756579, "compression_ratio": 1.6111111111111112, "no_speech_prob": 0.019715841859579086}, {"id": 68, "seek": 56328, "start": 574.16, "end": 580.9599999999999, "text": " preferred method. So from now on, I will only use this one. And then we also have some", "tokens": [50908, 16494, 3170, 13, 407, 490, 586, 322, 11, 286, 486, 787, 764, 341, 472, 13, 400, 550, 321, 611, 362, 512, 51248], "temperature": 0.0, "avg_logprob": -0.1168469880756579, "compression_ratio": 1.6111111111111112, "no_speech_prob": 0.019715841859579086}, {"id": 69, "seek": 56328, "start": 581.68, "end": 591.04, "text": " functions that can be used to modify an object. So we also have split and sub. So I will come to them", "tokens": [51284, 6828, 300, 393, 312, 1143, 281, 16927, 364, 2657, 13, 407, 321, 611, 362, 7472, 293, 1422, 13, 407, 286, 486, 808, 281, 552, 51752], "temperature": 0.0, "avg_logprob": -0.1168469880756579, "compression_ratio": 1.6111111111111112, "no_speech_prob": 0.019715841859579086}, {"id": 70, "seek": 59104, "start": 591.04, "end": 600.24, "text": " later. So now let's continue using the find iter method. And let's have a look at what we can do", "tokens": [50364, 1780, 13, 407, 586, 718, 311, 2354, 1228, 264, 915, 17138, 3170, 13, 400, 718, 311, 362, 257, 574, 412, 437, 321, 393, 360, 50824], "temperature": 0.0, "avg_logprob": -0.07766320830897282, "compression_ratio": 1.6647058823529413, "no_speech_prob": 0.016399787738919258}, {"id": 71, "seek": 59104, "start": 600.24, "end": 608.9599999999999, "text": " with the match object. So again, let's say our matches equals pattern, and then find iter.", "tokens": [50824, 365, 264, 2995, 2657, 13, 407, 797, 11, 718, 311, 584, 527, 10676, 6915, 5102, 11, 293, 550, 915, 17138, 13, 51260], "temperature": 0.0, "avg_logprob": -0.07766320830897282, "compression_ratio": 1.6647058823529413, "no_speech_prob": 0.016399787738919258}, {"id": 72, "seek": 59104, "start": 609.5999999999999, "end": 617.92, "text": " And then let's iterate over this. So for match in matches, and then we want to print the match.", "tokens": [51292, 400, 550, 718, 311, 44497, 670, 341, 13, 407, 337, 2995, 294, 10676, 11, 293, 550, 321, 528, 281, 4482, 264, 2995, 13, 51708], "temperature": 0.0, "avg_logprob": -0.07766320830897282, "compression_ratio": 1.6647058823529413, "no_speech_prob": 0.016399787738919258}, {"id": 73, "seek": 61792, "start": 618.88, "end": 629.8399999999999, "text": " Then again, we see we have the whole match object here. And we can use four different methods on", "tokens": [50412, 1396, 797, 11, 321, 536, 321, 362, 264, 1379, 2995, 2657, 510, 13, 400, 321, 393, 764, 1451, 819, 7150, 322, 50960], "temperature": 0.0, "avg_logprob": -0.13315841784844032, "compression_ratio": 1.5772357723577235, "no_speech_prob": 0.006386744789779186}, {"id": 74, "seek": 61792, "start": 629.8399999999999, "end": 639.4399999999999, "text": " this. So we can use the group method, we can use the start and the end method. And we can get the", "tokens": [50960, 341, 13, 407, 321, 393, 764, 264, 1594, 3170, 11, 321, 393, 764, 264, 722, 293, 264, 917, 3170, 13, 400, 321, 393, 483, 264, 51440], "temperature": 0.0, "avg_logprob": -0.13315841784844032, "compression_ratio": 1.5772357723577235, "no_speech_prob": 0.006386744789779186}, {"id": 75, "seek": 63944, "start": 639.7600000000001, "end": 652.48, "text": " span. So let's start with the span. So this will give me the start and the stop index, where this", "tokens": [50380, 16174, 13, 407, 718, 311, 722, 365, 264, 16174, 13, 407, 341, 486, 976, 385, 264, 722, 293, 264, 1590, 8186, 11, 689, 341, 51016], "temperature": 0.0, "avg_logprob": -0.11571617993441495, "compression_ratio": 1.5433070866141732, "no_speech_prob": 0.10663744062185287}, {"id": 76, "seek": 63944, "start": 652.48, "end": 662.96, "text": " pattern is located. So let's print the match dot span. So then we simply get this as a tuple here.", "tokens": [51016, 5102, 307, 6870, 13, 407, 718, 311, 4482, 264, 2995, 5893, 16174, 13, 407, 550, 321, 2935, 483, 341, 382, 257, 2604, 781, 510, 13, 51540], "temperature": 0.0, "avg_logprob": -0.11571617993441495, "compression_ratio": 1.5433070866141732, "no_speech_prob": 0.10663744062185287}, {"id": 77, "seek": 66296, "start": 663.9200000000001, "end": 671.12, "text": " So we get three and six. So this is a tuple. And we can also get the", "tokens": [50412, 407, 321, 483, 1045, 293, 2309, 13, 407, 341, 307, 257, 2604, 781, 13, 400, 321, 393, 611, 483, 264, 50772], "temperature": 0.0, "avg_logprob": -0.08645134386808975, "compression_ratio": 1.4684684684684686, "no_speech_prob": 0.05339347571134567}, {"id": 78, "seek": 66296, "start": 672.4000000000001, "end": 683.6800000000001, "text": " just the start and the end right away by saying print match dot start and print match dot end.", "tokens": [50836, 445, 264, 722, 293, 264, 917, 558, 1314, 538, 1566, 4482, 2995, 5893, 722, 293, 4482, 2995, 5893, 917, 13, 51400], "temperature": 0.0, "avg_logprob": -0.08645134386808975, "compression_ratio": 1.4684684684684686, "no_speech_prob": 0.05339347571134567}, {"id": 79, "seek": 68368, "start": 683.68, "end": 695.12, "text": " Oh, sorry, here is a dot match dot start. So then we get the start in the stop index. And now let's", "tokens": [50364, 876, 11, 2597, 11, 510, 307, 257, 5893, 2995, 5893, 722, 13, 407, 550, 321, 483, 264, 722, 294, 264, 1590, 8186, 13, 400, 586, 718, 311, 50936], "temperature": 0.0, "avg_logprob": -0.09939723893215782, "compression_ratio": 1.6744186046511629, "no_speech_prob": 0.07261857390403748}, {"id": 80, "seek": 68368, "start": 695.12, "end": 703.28, "text": " talk about the group method. So now if we call match dot group, then we will get or print the", "tokens": [50936, 751, 466, 264, 1594, 3170, 13, 407, 586, 498, 321, 818, 2995, 5893, 1594, 11, 550, 321, 486, 483, 420, 4482, 264, 51344], "temperature": 0.0, "avg_logprob": -0.09939723893215782, "compression_ratio": 1.6744186046511629, "no_speech_prob": 0.07261857390403748}, {"id": 81, "seek": 68368, "start": 704.16, "end": 712.16, "text": " actual string of the match. And we can also give this group method arguments to find the group", "tokens": [51388, 3539, 6798, 295, 264, 2995, 13, 400, 321, 393, 611, 976, 341, 1594, 3170, 12869, 281, 915, 264, 1594, 51788], "temperature": 0.0, "avg_logprob": -0.09939723893215782, "compression_ratio": 1.6744186046511629, "no_speech_prob": 0.07261857390403748}, {"id": 82, "seek": 71216, "start": 712.16, "end": 720.8, "text": " zero or one and or two. And we will talk about this grouping later. But for now on, if you", "tokens": [50364, 4018, 420, 472, 293, 420, 732, 13, 400, 321, 486, 751, 466, 341, 40149, 1780, 13, 583, 337, 586, 322, 11, 498, 291, 50796], "temperature": 0.0, "avg_logprob": -0.08584775663401982, "compression_ratio": 1.5953757225433527, "no_speech_prob": 0.012622770853340626}, {"id": 83, "seek": 71216, "start": 720.8, "end": 728.0799999999999, "text": " just want the string then from the match, then just call match dot group or group zero. So this", "tokens": [50796, 445, 528, 264, 6798, 550, 490, 264, 2995, 11, 550, 445, 818, 2995, 5893, 1594, 420, 1594, 4018, 13, 407, 341, 51160], "temperature": 0.0, "avg_logprob": -0.08584775663401982, "compression_ratio": 1.5953757225433527, "no_speech_prob": 0.012622770853340626}, {"id": 84, "seek": 71216, "start": 728.0799999999999, "end": 735.8399999999999, "text": " is the same. And yeah, so these are the four different methods that we can use on a match", "tokens": [51160, 307, 264, 912, 13, 400, 1338, 11, 370, 613, 366, 264, 1451, 819, 7150, 300, 321, 393, 764, 322, 257, 2995, 51548], "temperature": 0.0, "avg_logprob": -0.08584775663401982, "compression_ratio": 1.5953757225433527, "no_speech_prob": 0.012622770853340626}, {"id": 85, "seek": 73584, "start": 735.84, "end": 745.6, "text": " object. And now let's come to the matter characters. So in regular expressions,", "tokens": [50364, 2657, 13, 400, 586, 718, 311, 808, 281, 264, 1871, 4342, 13, 407, 294, 3890, 15277, 11, 50852], "temperature": 0.0, "avg_logprob": -0.06849886879088386, "compression_ratio": 1.5818181818181818, "no_speech_prob": 0.07584130764007568}, {"id": 86, "seek": 73584, "start": 745.6, "end": 754.08, "text": " there are these method characters that have a special meaning. So these are all the method", "tokens": [50852, 456, 366, 613, 3170, 4342, 300, 362, 257, 2121, 3620, 13, 407, 613, 366, 439, 264, 3170, 51276], "temperature": 0.0, "avg_logprob": -0.06849886879088386, "compression_ratio": 1.5818181818181818, "no_speech_prob": 0.07584130764007568}, {"id": 87, "seek": 73584, "start": 754.08, "end": 760.32, "text": " characters we must know. And you don't have to know them by heart. So I recommend that you", "tokens": [51276, 4342, 321, 1633, 458, 13, 400, 291, 500, 380, 362, 281, 458, 552, 538, 1917, 13, 407, 286, 2748, 300, 291, 51588], "temperature": 0.0, "avg_logprob": -0.06849886879088386, "compression_ratio": 1.5818181818181818, "no_speech_prob": 0.07584130764007568}, {"id": 88, "seek": 76032, "start": 760.32, "end": 766.6400000000001, "text": " keep a cheat sheet somewhere with all this stuff. And I will also provide a cheat sheet on", "tokens": [50364, 1066, 257, 17470, 8193, 4079, 365, 439, 341, 1507, 13, 400, 286, 486, 611, 2893, 257, 17470, 8193, 322, 50680], "temperature": 0.0, "avg_logprob": -0.06265264749526978, "compression_ratio": 1.6877828054298643, "no_speech_prob": 0.199262335896492}, {"id": 89, "seek": 76032, "start": 766.6400000000001, "end": 772.88, "text": " my website. So you can check that out on Python minus engineer dot com. And this is all you need", "tokens": [50680, 452, 3144, 13, 407, 291, 393, 1520, 300, 484, 322, 15329, 3175, 11403, 5893, 395, 13, 400, 341, 307, 439, 291, 643, 50992], "temperature": 0.0, "avg_logprob": -0.06265264749526978, "compression_ratio": 1.6877828054298643, "no_speech_prob": 0.199262335896492}, {"id": 90, "seek": 76032, "start": 772.88, "end": 780.5600000000001, "text": " to know. So now let's talk about these method characters one by one. And then I will show", "tokens": [50992, 281, 458, 13, 407, 586, 718, 311, 751, 466, 613, 3170, 4342, 472, 538, 472, 13, 400, 550, 286, 486, 855, 51376], "temperature": 0.0, "avg_logprob": -0.06265264749526978, "compression_ratio": 1.6877828054298643, "no_speech_prob": 0.199262335896492}, {"id": 91, "seek": 76032, "start": 780.5600000000001, "end": 789.0400000000001, "text": " you what this means. So the first one is the dot. So the dot means that we want to look for any", "tokens": [51376, 291, 437, 341, 1355, 13, 407, 264, 700, 472, 307, 264, 5893, 13, 407, 264, 5893, 1355, 300, 321, 528, 281, 574, 337, 604, 51800], "temperature": 0.0, "avg_logprob": -0.06265264749526978, "compression_ratio": 1.6877828054298643, "no_speech_prob": 0.199262335896492}, {"id": 92, "seek": 78904, "start": 789.04, "end": 795.76, "text": " character. So any character except a new line character, then the carrot means that we want", "tokens": [50364, 2517, 13, 407, 604, 2517, 3993, 257, 777, 1622, 2517, 11, 550, 264, 22767, 1355, 300, 321, 528, 50700], "temperature": 0.0, "avg_logprob": -0.08715984946803043, "compression_ratio": 1.900497512437811, "no_speech_prob": 0.03460737690329552}, {"id": 93, "seek": 78904, "start": 795.76, "end": 802.3199999999999, "text": " to look for a pattern that starts with that starts with the pattern we are looking for. So that", "tokens": [50700, 281, 574, 337, 257, 5102, 300, 3719, 365, 300, 3719, 365, 264, 5102, 321, 366, 1237, 337, 13, 407, 300, 51028], "temperature": 0.0, "avg_logprob": -0.08715984946803043, "compression_ratio": 1.900497512437811, "no_speech_prob": 0.03460737690329552}, {"id": 94, "seek": 78904, "start": 802.3199999999999, "end": 807.8399999999999, "text": " starts with the string hello, for example, then the dollar sign is the opposite. If you want to", "tokens": [51028, 3719, 365, 264, 6798, 7751, 11, 337, 1365, 11, 550, 264, 7241, 1465, 307, 264, 6182, 13, 759, 291, 528, 281, 51304], "temperature": 0.0, "avg_logprob": -0.08715984946803043, "compression_ratio": 1.900497512437811, "no_speech_prob": 0.03460737690329552}, {"id": 95, "seek": 78904, "start": 807.8399999999999, "end": 818.0799999999999, "text": " look for a string at the end of our text, then we have some quantifiers. So the asterisk, the plus", "tokens": [51304, 574, 337, 257, 6798, 412, 264, 917, 295, 527, 2487, 11, 550, 321, 362, 512, 4426, 23463, 13, 407, 264, 257, 3120, 7797, 11, 264, 1804, 51816], "temperature": 0.0, "avg_logprob": -0.08715984946803043, "compression_ratio": 1.900497512437811, "no_speech_prob": 0.03460737690329552}, {"id": 96, "seek": 81808, "start": 818.08, "end": 826.1600000000001, "text": " and square brackets. And I will talk about them later in more detail. Then we have the set operator,", "tokens": [50364, 293, 3732, 26179, 13, 400, 286, 486, 751, 466, 552, 1780, 294, 544, 2607, 13, 1396, 321, 362, 264, 992, 12973, 11, 50768], "temperature": 0.0, "avg_logprob": -0.0943166001202309, "compression_ratio": 1.698224852071006, "no_speech_prob": 0.012621697969734669}, {"id": 97, "seek": 81808, "start": 826.8000000000001, "end": 835.6800000000001, "text": " which I will also cover later. Then we have conditions and grouping with parentheses. So I", "tokens": [50800, 597, 286, 486, 611, 2060, 1780, 13, 1396, 321, 362, 4487, 293, 40149, 365, 34153, 13, 407, 286, 51244], "temperature": 0.0, "avg_logprob": -0.0943166001202309, "compression_ratio": 1.698224852071006, "no_speech_prob": 0.012621697969734669}, {"id": 98, "seek": 81808, "start": 835.6800000000001, "end": 841.6800000000001, "text": " will also talk about this later. And of course, we have to look, we have the backslash. So with", "tokens": [51244, 486, 611, 751, 466, 341, 1780, 13, 400, 295, 1164, 11, 321, 362, 281, 574, 11, 321, 362, 264, 646, 10418, 1299, 13, 407, 365, 51544], "temperature": 0.0, "avg_logprob": -0.0943166001202309, "compression_ratio": 1.698224852071006, "no_speech_prob": 0.012621697969734669}, {"id": 99, "seek": 84168, "start": 841.68, "end": 849.76, "text": " the backslash, we can get more special sequences, or we can escape characters. So for example,", "tokens": [50364, 264, 646, 10418, 1299, 11, 321, 393, 483, 544, 2121, 22978, 11, 420, 321, 393, 7615, 4342, 13, 407, 337, 1365, 11, 50768], "temperature": 0.0, "avg_logprob": -0.06418445076740964, "compression_ratio": 1.532967032967033, "no_speech_prob": 0.048130642622709274}, {"id": 100, "seek": 84168, "start": 849.76, "end": 856.7199999999999, "text": " if you actually want to search for the dot, then we have to escape this in our pattern.", "tokens": [50768, 498, 291, 767, 528, 281, 3164, 337, 264, 5893, 11, 550, 321, 362, 281, 7615, 341, 294, 527, 5102, 13, 51116], "temperature": 0.0, "avg_logprob": -0.06418445076740964, "compression_ratio": 1.532967032967033, "no_speech_prob": 0.048130642622709274}, {"id": 101, "seek": 84168, "start": 857.68, "end": 865.4399999999999, "text": " So now let's talk about the first three and show you some examples. And then later we will cover", "tokens": [51164, 407, 586, 718, 311, 751, 466, 264, 700, 1045, 293, 855, 291, 512, 5110, 13, 400, 550, 1780, 321, 486, 2060, 51552], "temperature": 0.0, "avg_logprob": -0.06418445076740964, "compression_ratio": 1.532967032967033, "no_speech_prob": 0.048130642622709274}, {"id": 102, "seek": 86544, "start": 865.44, "end": 874.0, "text": " the other meta characters in more detail. So now first let's say we want to look for the dot and", "tokens": [50364, 264, 661, 19616, 4342, 294, 544, 2607, 13, 407, 586, 700, 718, 311, 584, 321, 528, 281, 574, 337, 264, 5893, 293, 50792], "temperature": 0.0, "avg_logprob": -0.08973107409121385, "compression_ratio": 1.6540880503144655, "no_speech_prob": 0.06752542406320572}, {"id": 103, "seek": 86544, "start": 874.0, "end": 883.9200000000001, "text": " then print all the matches, then we see we get all all the characters in our string,", "tokens": [50792, 550, 4482, 439, 264, 10676, 11, 550, 321, 536, 321, 483, 439, 439, 264, 4342, 294, 527, 6798, 11, 51288], "temperature": 0.0, "avg_logprob": -0.08973107409121385, "compression_ratio": 1.6540880503144655, "no_speech_prob": 0.06752542406320572}, {"id": 104, "seek": 86544, "start": 884.48, "end": 892.0, "text": " because the dot is looking for any character except new line. So this is the dot.", "tokens": [51316, 570, 264, 5893, 307, 1237, 337, 604, 2517, 3993, 777, 1622, 13, 407, 341, 307, 264, 5893, 13, 51692], "temperature": 0.0, "avg_logprob": -0.08973107409121385, "compression_ratio": 1.6540880503144655, "no_speech_prob": 0.06752542406320572}, {"id": 105, "seek": 89200, "start": 892.0, "end": 900.88, "text": " And now let's say we have a dot here at the end, and we actually want to get this dot. So then we", "tokens": [50364, 400, 586, 718, 311, 584, 321, 362, 257, 5893, 510, 412, 264, 917, 11, 293, 321, 767, 528, 281, 483, 341, 5893, 13, 407, 550, 321, 50808], "temperature": 0.0, "avg_logprob": -0.08761595557717716, "compression_ratio": 1.69364161849711, "no_speech_prob": 0.008443568833172321}, {"id": 106, "seek": 89200, "start": 900.88, "end": 908.88, "text": " escape it with a backslash. And now if we run this, then we just get the dot. So now let's print the", "tokens": [50808, 7615, 309, 365, 257, 646, 10418, 1299, 13, 400, 586, 498, 321, 1190, 341, 11, 550, 321, 445, 483, 264, 5893, 13, 407, 586, 718, 311, 4482, 264, 51208], "temperature": 0.0, "avg_logprob": -0.08761595557717716, "compression_ratio": 1.69364161849711, "no_speech_prob": 0.008443568833172321}, {"id": 107, "seek": 89200, "start": 908.88, "end": 918.0, "text": " whole match object. Then we get the dot and we see that it is at this position. So this is the", "tokens": [51208, 1379, 2995, 2657, 13, 1396, 321, 483, 264, 5893, 293, 321, 536, 300, 309, 307, 412, 341, 2535, 13, 407, 341, 307, 264, 51664], "temperature": 0.0, "avg_logprob": -0.08761595557717716, "compression_ratio": 1.69364161849711, "no_speech_prob": 0.008443568833172321}, {"id": 108, "seek": 91800, "start": 918.0, "end": 925.2, "text": " dot. And then let's have a look at the carrot. So this is the carrot. So let's say we want to look", "tokens": [50364, 5893, 13, 400, 550, 718, 311, 362, 257, 574, 412, 264, 22767, 13, 407, 341, 307, 264, 22767, 13, 407, 718, 311, 584, 321, 528, 281, 574, 50724], "temperature": 0.0, "avg_logprob": -0.09221544383484641, "compression_ratio": 1.6187845303867403, "no_speech_prob": 0.027999309822916985}, {"id": 109, "seek": 91800, "start": 925.2, "end": 936.24, "text": " for 123 if it starts with this. And then we get one match object. And for example, now if we look", "tokens": [50724, 337, 34466, 498, 309, 3719, 365, 341, 13, 400, 550, 321, 483, 472, 2995, 2657, 13, 400, 337, 1365, 11, 586, 498, 321, 574, 51276], "temperature": 0.0, "avg_logprob": -0.09221544383484641, "compression_ratio": 1.6187845303867403, "no_speech_prob": 0.027999309822916985}, {"id": 110, "seek": 91800, "start": 936.24, "end": 944.4, "text": " for ABC, then it will return nothing, because it's not at the beginning. And the opposite if you", "tokens": [51276, 337, 22342, 11, 550, 309, 486, 2736, 1825, 11, 570, 309, 311, 406, 412, 264, 2863, 13, 400, 264, 6182, 498, 291, 51684], "temperature": 0.0, "avg_logprob": -0.09221544383484641, "compression_ratio": 1.6187845303867403, "no_speech_prob": 0.027999309822916985}, {"id": 111, "seek": 94440, "start": 944.4, "end": 951.92, "text": " want to have a look, if we want to look if this is at the end, so then we can say dollar here.", "tokens": [50364, 528, 281, 362, 257, 574, 11, 498, 321, 528, 281, 574, 498, 341, 307, 412, 264, 917, 11, 370, 550, 321, 393, 584, 7241, 510, 13, 50740], "temperature": 0.0, "avg_logprob": -0.13297490949754592, "compression_ratio": 1.644578313253012, "no_speech_prob": 0.04602573439478874}, {"id": 112, "seek": 94440, "start": 952.48, "end": 958.88, "text": " And now if you run this, and this will find nothing because I'm sorry, we have the", "tokens": [50768, 400, 586, 498, 291, 1190, 341, 11, 293, 341, 486, 915, 1825, 570, 286, 478, 2597, 11, 321, 362, 264, 51088], "temperature": 0.0, "avg_logprob": -0.13297490949754592, "compression_ratio": 1.644578313253012, "no_speech_prob": 0.04602573439478874}, {"id": 113, "seek": 94440, "start": 960.0, "end": 967.84, "text": " colon here, this will find nothing, because as I said, it is case sensitive. Now if I'm looking", "tokens": [51144, 8255, 510, 11, 341, 486, 915, 1825, 11, 570, 382, 286, 848, 11, 309, 307, 1389, 9477, 13, 823, 498, 286, 478, 1237, 51536], "temperature": 0.0, "avg_logprob": -0.13297490949754592, "compression_ratio": 1.644578313253012, "no_speech_prob": 0.04602573439478874}, {"id": 114, "seek": 96784, "start": 967.9200000000001, "end": 975.76, "text": " for uppercase ABC, and dollar at the end, so then it found the match at the end.", "tokens": [50368, 337, 11775, 2869, 651, 22342, 11, 293, 7241, 412, 264, 917, 11, 370, 550, 309, 1352, 264, 2995, 412, 264, 917, 13, 50760], "temperature": 0.0, "avg_logprob": -0.06968283653259277, "compression_ratio": 1.6341463414634145, "no_speech_prob": 0.1894567310810089}, {"id": 115, "seek": 96784, "start": 976.64, "end": 984.08, "text": " All right, so now we will talk about the other meta characters later. And now let's look at", "tokens": [50804, 1057, 558, 11, 370, 586, 321, 486, 751, 466, 264, 661, 19616, 4342, 1780, 13, 400, 586, 718, 311, 574, 412, 51176], "temperature": 0.0, "avg_logprob": -0.06968283653259277, "compression_ratio": 1.6341463414634145, "no_speech_prob": 0.1894567310810089}, {"id": 116, "seek": 96784, "start": 984.08, "end": 990.4, "text": " some more special characters. So there are more special characters that start with a backslash.", "tokens": [51176, 512, 544, 2121, 4342, 13, 407, 456, 366, 544, 2121, 4342, 300, 722, 365, 257, 646, 10418, 1299, 13, 51492], "temperature": 0.0, "avg_logprob": -0.06968283653259277, "compression_ratio": 1.6341463414634145, "no_speech_prob": 0.1894567310810089}, {"id": 117, "seek": 99040, "start": 990.4, "end": 1000.48, "text": " So there is the backslash and small D. This looks for any digit, so zero until nine.", "tokens": [50364, 407, 456, 307, 264, 646, 10418, 1299, 293, 1359, 413, 13, 639, 1542, 337, 604, 14293, 11, 370, 4018, 1826, 4949, 13, 50868], "temperature": 0.0, "avg_logprob": -0.17548610794712122, "compression_ratio": 1.736842105263158, "no_speech_prob": 0.20934996008872986}, {"id": 118, "seek": 99040, "start": 1001.12, "end": 1007.04, "text": " Then there's the capital backslash capital D. So this matches any non digit character.", "tokens": [50900, 1396, 456, 311, 264, 4238, 646, 10418, 1299, 4238, 413, 13, 407, 341, 10676, 604, 2107, 14293, 2517, 13, 51196], "temperature": 0.0, "avg_logprob": -0.17548610794712122, "compression_ratio": 1.736842105263158, "no_speech_prob": 0.20934996008872986}, {"id": 119, "seek": 99040, "start": 1007.76, "end": 1014.88, "text": " Then there's backslash, small s, this matches any white space character, for example, space,", "tokens": [51232, 1396, 456, 311, 646, 10418, 1299, 11, 1359, 262, 11, 341, 10676, 604, 2418, 1901, 2517, 11, 337, 1365, 11, 1901, 11, 51588], "temperature": 0.0, "avg_logprob": -0.17548610794712122, "compression_ratio": 1.736842105263158, "no_speech_prob": 0.20934996008872986}, {"id": 120, "seek": 101488, "start": 1014.88, "end": 1023.04, "text": " tap or new line. Then we have backslash capital is s, this matches any non white space character.", "tokens": [50364, 5119, 420, 777, 1622, 13, 1396, 321, 362, 646, 10418, 1299, 4238, 307, 262, 11, 341, 10676, 604, 2107, 2418, 1901, 2517, 13, 50772], "temperature": 0.0, "avg_logprob": -0.1369510143995285, "compression_ratio": 1.7162162162162162, "no_speech_prob": 0.14026883244514465}, {"id": 121, "seek": 101488, "start": 1023.04, "end": 1027.04, "text": " So for all these patterns, all these special characters, the capital", "tokens": [50772, 407, 337, 439, 613, 8294, 11, 439, 613, 2121, 4342, 11, 264, 4238, 50972], "temperature": 0.0, "avg_logprob": -0.1369510143995285, "compression_ratio": 1.7162162162162162, "no_speech_prob": 0.14026883244514465}, {"id": 122, "seek": 101488, "start": 1028.4, "end": 1037.52, "text": " pattern is kind of the opposite of the small character here. So then we have backslash,", "tokens": [51040, 5102, 307, 733, 295, 264, 6182, 295, 264, 1359, 2517, 510, 13, 407, 550, 321, 362, 646, 10418, 1299, 11, 51496], "temperature": 0.0, "avg_logprob": -0.1369510143995285, "compression_ratio": 1.7162162162162162, "no_speech_prob": 0.14026883244514465}, {"id": 123, "seek": 103752, "start": 1037.52, "end": 1047.6, "text": " small w, this matches any word character. So we have characters from A to C. We also have", "tokens": [50364, 1359, 261, 11, 341, 10676, 604, 1349, 2517, 13, 407, 321, 362, 4342, 490, 316, 281, 383, 13, 492, 611, 362, 50868], "temperature": 0.0, "avg_logprob": -0.1797319953121356, "compression_ratio": 1.7058823529411764, "no_speech_prob": 0.16661609709262848}, {"id": 124, "seek": 103752, "start": 1047.6, "end": 1058.08, "text": " all the capital characters, and also digits and the underscore. Then the capital w is the", "tokens": [50868, 439, 264, 4238, 4342, 11, 293, 611, 27011, 293, 264, 37556, 13, 1396, 264, 4238, 261, 307, 264, 51392], "temperature": 0.0, "avg_logprob": -0.1797319953121356, "compression_ratio": 1.7058823529411764, "no_speech_prob": 0.16661609709262848}, {"id": 125, "seek": 103752, "start": 1058.08, "end": 1064.8, "text": " opposite. So any non word character, non alphanumeric character. Then we have the", "tokens": [51392, 6182, 13, 407, 604, 2107, 1349, 2517, 11, 2107, 419, 950, 282, 15583, 299, 2517, 13, 1396, 321, 362, 264, 51728], "temperature": 0.0, "avg_logprob": -0.1797319953121356, "compression_ratio": 1.7058823529411764, "no_speech_prob": 0.16661609709262848}, {"id": 126, "seek": 106480, "start": 1065.28, "end": 1074.56, "text": " backslash b. So this matches where the specified characters are at the beginning or at the end", "tokens": [50388, 646, 10418, 1299, 272, 13, 407, 341, 10676, 689, 264, 22206, 4342, 366, 412, 264, 2863, 420, 412, 264, 917, 50852], "temperature": 0.0, "avg_logprob": -0.10705503664518658, "compression_ratio": 1.6607142857142858, "no_speech_prob": 0.009558161720633507}, {"id": 127, "seek": 106480, "start": 1074.56, "end": 1081.76, "text": " of a word. And again, we have the opposite. So where this is not at the beginning. So let's", "tokens": [50852, 295, 257, 1349, 13, 400, 797, 11, 321, 362, 264, 6182, 13, 407, 689, 341, 307, 406, 412, 264, 2863, 13, 407, 718, 311, 51212], "temperature": 0.0, "avg_logprob": -0.10705503664518658, "compression_ratio": 1.6607142857142858, "no_speech_prob": 0.009558161720633507}, {"id": 128, "seek": 106480, "start": 1081.76, "end": 1090.32, "text": " have a look at them in detail. So let's use another test string here. So let's, for example,", "tokens": [51212, 362, 257, 574, 412, 552, 294, 2607, 13, 407, 718, 311, 764, 1071, 1500, 6798, 510, 13, 407, 718, 311, 11, 337, 1365, 11, 51640], "temperature": 0.0, "avg_logprob": -0.10705503664518658, "compression_ratio": 1.6607142857142858, "no_speech_prob": 0.009558161720633507}, {"id": 129, "seek": 109032, "start": 1090.32, "end": 1102.0, "text": " use this one. And now if we want to look for any digit here, we can simply say we want to look for", "tokens": [50364, 764, 341, 472, 13, 400, 586, 498, 321, 528, 281, 574, 337, 604, 14293, 510, 11, 321, 393, 2935, 584, 321, 528, 281, 574, 337, 50948], "temperature": 0.0, "avg_logprob": -0.11933186224528722, "compression_ratio": 1.5483870967741935, "no_speech_prob": 0.09805456548929214}, {"id": 130, "seek": 109032, "start": 1102.0, "end": 1110.56, "text": " backslash d. And now if you run this, then we will see we have three matches, the digits one,", "tokens": [50948, 646, 10418, 1299, 274, 13, 400, 586, 498, 291, 1190, 341, 11, 550, 321, 486, 536, 321, 362, 1045, 10676, 11, 264, 27011, 472, 11, 51376], "temperature": 0.0, "avg_logprob": -0.11933186224528722, "compression_ratio": 1.5483870967741935, "no_speech_prob": 0.09805456548929214}, {"id": 131, "seek": 111056, "start": 1110.56, "end": 1120.08, "text": " two and three. Now if we use the opposite, so capital D, so any non digit, then it will find", "tokens": [50364, 732, 293, 1045, 13, 823, 498, 321, 764, 264, 6182, 11, 370, 4238, 413, 11, 370, 604, 2107, 14293, 11, 550, 309, 486, 915, 50840], "temperature": 0.0, "avg_logprob": -0.12603064072437775, "compression_ratio": 1.696969696969697, "no_speech_prob": 0.22806686162948608}, {"id": 132, "seek": 111056, "start": 1120.08, "end": 1129.36, "text": " all the characters except one, two and three. Then let's have a look at the white space. So", "tokens": [50840, 439, 264, 4342, 3993, 472, 11, 732, 293, 1045, 13, 1396, 718, 311, 362, 257, 574, 412, 264, 2418, 1901, 13, 407, 51304], "temperature": 0.0, "avg_logprob": -0.12603064072437775, "compression_ratio": 1.696969696969697, "no_speech_prob": 0.22806686162948608}, {"id": 133, "seek": 111056, "start": 1130.08, "end": 1140.08, "text": " backslash s finds any white space character. So here we see we have a space here, a space here,", "tokens": [51340, 646, 10418, 1299, 262, 10704, 604, 2418, 1901, 2517, 13, 407, 510, 321, 536, 321, 362, 257, 1901, 510, 11, 257, 1901, 510, 11, 51840], "temperature": 0.0, "avg_logprob": -0.12603064072437775, "compression_ratio": 1.696969696969697, "no_speech_prob": 0.22806686162948608}, {"id": 134, "seek": 114008, "start": 1140.08, "end": 1148.8799999999999, "text": " and a space here. And then again, the opposite, so any non white space character is any other", "tokens": [50364, 293, 257, 1901, 510, 13, 400, 550, 797, 11, 264, 6182, 11, 370, 604, 2107, 2418, 1901, 2517, 307, 604, 661, 50804], "temperature": 0.0, "avg_logprob": -0.1455478572845459, "compression_ratio": 1.5158730158730158, "no_speech_prob": 0.003944559954106808}, {"id": 135, "seek": 114008, "start": 1148.8799999999999, "end": 1160.96, "text": " character. So this is the s special character. Then let's have a look at the w characters. So any", "tokens": [50804, 2517, 13, 407, 341, 307, 264, 262, 2121, 2517, 13, 1396, 718, 311, 362, 257, 574, 412, 264, 261, 4342, 13, 407, 604, 51408], "temperature": 0.0, "avg_logprob": -0.1455478572845459, "compression_ratio": 1.5158730158730158, "no_speech_prob": 0.003944559954106808}, {"id": 136, "seek": 116096, "start": 1160.96, "end": 1170.64, "text": " alphanumeric character. So if I put in a w here, then it finds all the word characters.", "tokens": [50364, 419, 950, 282, 15583, 299, 2517, 13, 407, 498, 286, 829, 294, 257, 261, 510, 11, 550, 309, 10704, 439, 264, 1349, 4342, 13, 50848], "temperature": 0.0, "avg_logprob": -0.08076221466064454, "compression_ratio": 1.4015748031496063, "no_speech_prob": 0.09805348515510559}, {"id": 137, "seek": 116096, "start": 1172.32, "end": 1181.28, "text": " And again, the opposite capital D, this will just find the spaces in this example. And now", "tokens": [50932, 400, 797, 11, 264, 6182, 4238, 413, 11, 341, 486, 445, 915, 264, 7673, 294, 341, 1365, 13, 400, 586, 51380], "temperature": 0.0, "avg_logprob": -0.08076221466064454, "compression_ratio": 1.4015748031496063, "no_speech_prob": 0.09805348515510559}, {"id": 138, "seek": 118128, "start": 1181.28, "end": 1193.12, "text": " let's have a look at the backslash B. So now if I am looking for hello, then it will find it because", "tokens": [50364, 718, 311, 362, 257, 574, 412, 264, 646, 10418, 1299, 363, 13, 407, 586, 498, 286, 669, 1237, 337, 7751, 11, 550, 309, 486, 915, 309, 570, 50956], "temperature": 0.0, "avg_logprob": -0.07521293844495501, "compression_ratio": 1.4809160305343512, "no_speech_prob": 0.019119679927825928}, {"id": 139, "seek": 118128, "start": 1193.12, "end": 1202.3999999999999, "text": " it is at the beginning of a block. And a block is not only the beginning of a string, but the", "tokens": [50956, 309, 307, 412, 264, 2863, 295, 257, 3461, 13, 400, 257, 3461, 307, 406, 787, 264, 2863, 295, 257, 6798, 11, 457, 264, 51420], "temperature": 0.0, "avg_logprob": -0.07521293844495501, "compression_ratio": 1.4809160305343512, "no_speech_prob": 0.019119679927825928}, {"id": 140, "seek": 120240, "start": 1202.4, "end": 1213.6000000000001, "text": " beginning of any block that follows a white space character. So for example, if we look for", "tokens": [50364, 2863, 295, 604, 3461, 300, 10002, 257, 2418, 1901, 2517, 13, 407, 337, 1365, 11, 498, 321, 574, 337, 50924], "temperature": 0.0, "avg_logprob": -0.09666906519139067, "compression_ratio": 1.4351145038167938, "no_speech_prob": 0.06752526015043259}, {"id": 141, "seek": 120240, "start": 1214.8000000000002, "end": 1226.8000000000002, "text": " hay, then it will also find the hay, but it will only find this pattern and not this one because", "tokens": [50984, 4842, 11, 550, 309, 486, 611, 915, 264, 4842, 11, 457, 309, 486, 787, 915, 341, 5102, 293, 406, 341, 472, 570, 51584], "temperature": 0.0, "avg_logprob": -0.09666906519139067, "compression_ratio": 1.4351145038167938, "no_speech_prob": 0.06752526015043259}, {"id": 142, "seek": 122680, "start": 1226.8, "end": 1235.28, "text": " it's looking for matches that are at the beginning of a block. So for example, if we put this", "tokens": [50364, 309, 311, 1237, 337, 10676, 300, 366, 412, 264, 2863, 295, 257, 3461, 13, 407, 337, 1365, 11, 498, 321, 829, 341, 50788], "temperature": 0.0, "avg_logprob": -0.11802130756956158, "compression_ratio": 1.625, "no_speech_prob": 0.022282522171735764}, {"id": 143, "seek": 122680, "start": 1236.6399999999999, "end": 1245.52, "text": " before a space, then it will find and then it will find this pattern or this match to", "tokens": [50856, 949, 257, 1901, 11, 550, 309, 486, 915, 293, 550, 309, 486, 915, 341, 5102, 420, 341, 2995, 281, 51300], "temperature": 0.0, "avg_logprob": -0.11802130756956158, "compression_ratio": 1.625, "no_speech_prob": 0.022282522171735764}, {"id": 144, "seek": 122680, "start": 1246.72, "end": 1251.76, "text": " and again, the opposite. Now if we are looking for this, and we put", "tokens": [51360, 293, 797, 11, 264, 6182, 13, 823, 498, 321, 366, 1237, 337, 341, 11, 293, 321, 829, 51612], "temperature": 0.0, "avg_logprob": -0.11802130756956158, "compression_ratio": 1.625, "no_speech_prob": 0.022282522171735764}, {"id": 145, "seek": 125176, "start": 1252.08, "end": 1260.08, "text": " ho hay here again, then it will find this hay because it is not at the beginning of a block", "tokens": [50380, 1106, 4842, 510, 797, 11, 550, 309, 486, 915, 341, 4842, 570, 309, 307, 406, 412, 264, 2863, 295, 257, 3461, 50780], "temperature": 0.0, "avg_logprob": -0.19973375486290973, "compression_ratio": 1.5798319327731092, "no_speech_prob": 0.007009380962699652}, {"id": 146, "seek": 125176, "start": 1260.08, "end": 1268.8, "text": " where this is at the beginning of a block. So these are the special sequence, special characters", "tokens": [50780, 689, 341, 307, 412, 264, 2863, 295, 257, 3461, 13, 407, 613, 366, 264, 2121, 8310, 11, 2121, 4342, 51216], "temperature": 0.0, "avg_logprob": -0.19973375486290973, "compression_ratio": 1.5798319327731092, "no_speech_prob": 0.007009380962699652}, {"id": 147, "seek": 126880, "start": 1269.76, "end": 1283.9199999999998, "text": " that we should know. And now let's continue with sets. So we can use square brackets to look for", "tokens": [50412, 300, 321, 820, 458, 13, 400, 586, 718, 311, 2354, 365, 6352, 13, 407, 321, 393, 764, 3732, 26179, 281, 574, 337, 51120], "temperature": 0.0, "avg_logprob": -0.07814349174499512, "compression_ratio": 1.4108527131782946, "no_speech_prob": 0.6220372319221497}, {"id": 148, "seek": 126880, "start": 1284.6399999999999, "end": 1292.56, "text": " sets. And let me show you what this means. So let's say we only have this string now.", "tokens": [51156, 6352, 13, 400, 718, 385, 855, 291, 437, 341, 1355, 13, 407, 718, 311, 584, 321, 787, 362, 341, 6798, 586, 13, 51552], "temperature": 0.0, "avg_logprob": -0.07814349174499512, "compression_ratio": 1.4108527131782946, "no_speech_prob": 0.6220372319221497}, {"id": 149, "seek": 129256, "start": 1293.12, "end": 1300.56, "text": " But now let's say we only want to look for a non-numeric character. So only for these ones,", "tokens": [50392, 583, 586, 718, 311, 584, 321, 787, 528, 281, 574, 337, 257, 2107, 12, 77, 15583, 299, 2517, 13, 407, 787, 337, 613, 2306, 11, 50764], "temperature": 0.0, "avg_logprob": -0.1169432004292806, "compression_ratio": 1.6627218934911243, "no_speech_prob": 0.04466865956783295}, {"id": 150, "seek": 129256, "start": 1301.12, "end": 1312.8799999999999, "text": " then we can use a set for this. So a set is a pattern between square brackets. And now here", "tokens": [50792, 550, 321, 393, 764, 257, 992, 337, 341, 13, 407, 257, 992, 307, 257, 5102, 1296, 3732, 26179, 13, 400, 586, 510, 51380], "temperature": 0.0, "avg_logprob": -0.1169432004292806, "compression_ratio": 1.6627218934911243, "no_speech_prob": 0.04466865956783295}, {"id": 151, "seek": 129256, "start": 1312.8799999999999, "end": 1322.32, "text": " in this set, we can use multiple characters that we want to look up. For example, we want to look", "tokens": [51380, 294, 341, 992, 11, 321, 393, 764, 3866, 4342, 300, 321, 528, 281, 574, 493, 13, 1171, 1365, 11, 321, 528, 281, 574, 51852], "temperature": 0.0, "avg_logprob": -0.1169432004292806, "compression_ratio": 1.6627218934911243, "no_speech_prob": 0.04466865956783295}, {"id": 152, "seek": 132232, "start": 1322.3999999999999, "end": 1334.8, "text": " for a L and a O. And now if we run this, then it will find all these characters. And you must be", "tokens": [50368, 337, 257, 441, 293, 257, 422, 13, 400, 586, 498, 321, 1190, 341, 11, 550, 309, 486, 915, 439, 613, 4342, 13, 400, 291, 1633, 312, 50988], "temperature": 0.0, "avg_logprob": -0.10730061097578569, "compression_ratio": 1.4042553191489362, "no_speech_prob": 0.01261945255100727}, {"id": 153, "seek": 132232, "start": 1334.8, "end": 1344.24, "text": " careful here because it doesn't look for L O, but for any single character that we put into this set.", "tokens": [50988, 5026, 510, 570, 309, 1177, 380, 574, 337, 441, 422, 11, 457, 337, 604, 2167, 2517, 300, 321, 829, 666, 341, 992, 13, 51460], "temperature": 0.0, "avg_logprob": -0.10730061097578569, "compression_ratio": 1.4042553191489362, "no_speech_prob": 0.01261945255100727}, {"id": 154, "seek": 134424, "start": 1344.64, "end": 1354.4, "text": " And we can also specify ranges here. So we can instead of, let's say we also want to have the", "tokens": [50384, 400, 321, 393, 611, 16500, 22526, 510, 13, 407, 321, 393, 2602, 295, 11, 718, 311, 584, 321, 611, 528, 281, 362, 264, 50872], "temperature": 0.0, "avg_logprob": -0.19206512451171875, "compression_ratio": 1.381679389312977, "no_speech_prob": 0.08267701417207718}, {"id": 155, "seek": 134424, "start": 1355.2, "end": 1366.64, "text": " H and the E, then it will find any character here that is not a number and also not the", "tokens": [50912, 389, 293, 264, 462, 11, 550, 309, 486, 915, 604, 2517, 510, 300, 307, 406, 257, 1230, 293, 611, 406, 264, 51484], "temperature": 0.0, "avg_logprob": -0.19206512451171875, "compression_ratio": 1.381679389312977, "no_speech_prob": 0.08267701417207718}, {"id": 156, "seek": 136664, "start": 1367.3600000000001, "end": 1375.1200000000001, "text": " not the underscore. So we can also specify a range here. And this is a very typical,", "tokens": [50400, 406, 264, 37556, 13, 407, 321, 393, 611, 16500, 257, 3613, 510, 13, 400, 341, 307, 257, 588, 7476, 11, 50788], "temperature": 0.0, "avg_logprob": -0.15462375368390766, "compression_ratio": 1.4835164835164836, "no_speech_prob": 0.13292472064495087}, {"id": 157, "seek": 136664, "start": 1375.1200000000001, "end": 1386.72, "text": " very common example in regular expressions to use A dash C, so A to C. So all the lowercase", "tokens": [50788, 588, 2689, 1365, 294, 3890, 15277, 281, 764, 316, 8240, 383, 11, 370, 316, 281, 383, 13, 407, 439, 264, 3126, 9765, 51368], "temperature": 0.0, "avg_logprob": -0.15462375368390766, "compression_ratio": 1.4835164835164836, "no_speech_prob": 0.13292472064495087}, {"id": 158, "seek": 136664, "start": 1386.72, "end": 1394.64, "text": " characters, now if you run this, sometimes it's not saving this file automatically. So now if", "tokens": [51368, 4342, 11, 586, 498, 291, 1190, 341, 11, 2171, 309, 311, 406, 6816, 341, 3991, 6772, 13, 407, 586, 498, 51764], "temperature": 0.0, "avg_logprob": -0.15462375368390766, "compression_ratio": 1.4835164835164836, "no_speech_prob": 0.13292472064495087}, {"id": 159, "seek": 139464, "start": 1394.64, "end": 1406.64, "text": " you run this, then we see that we will find all the letters here. And we can also look for digits.", "tokens": [50364, 291, 1190, 341, 11, 550, 321, 536, 300, 321, 486, 915, 439, 264, 7825, 510, 13, 400, 321, 393, 611, 574, 337, 27011, 13, 50964], "temperature": 0.0, "avg_logprob": -0.05175696526254926, "compression_ratio": 1.481203007518797, "no_speech_prob": 0.009267142042517662}, {"id": 160, "seek": 139464, "start": 1406.64, "end": 1414.72, "text": " So let's say we want only the digits two and three. And again, here we can have a range. So we can", "tokens": [50964, 407, 718, 311, 584, 321, 528, 787, 264, 27011, 732, 293, 1045, 13, 400, 797, 11, 510, 321, 393, 362, 257, 3613, 13, 407, 321, 393, 51368], "temperature": 0.0, "avg_logprob": -0.05175696526254926, "compression_ratio": 1.481203007518797, "no_speech_prob": 0.009267142042517662}, {"id": 161, "seek": 141472, "start": 1414.72, "end": 1424.8, "text": " say one to nine. So this is or let's say zero to nine. And this will find all the digits. So this", "tokens": [50364, 584, 472, 281, 4949, 13, 407, 341, 307, 420, 718, 311, 584, 4018, 281, 4949, 13, 400, 341, 486, 915, 439, 264, 27011, 13, 407, 341, 50868], "temperature": 0.0, "avg_logprob": -0.07277805763378478, "compression_ratio": 1.46875, "no_speech_prob": 0.21991807222366333}, {"id": 162, "seek": 141472, "start": 1424.8, "end": 1436.96, "text": " is the same as using backslash D to find a digit. And so yeah, so if you want to specify a", "tokens": [50868, 307, 264, 912, 382, 1228, 646, 10418, 1299, 413, 281, 915, 257, 14293, 13, 400, 370, 1338, 11, 370, 498, 291, 528, 281, 16500, 257, 51476], "temperature": 0.0, "avg_logprob": -0.07277805763378478, "compression_ratio": 1.46875, "no_speech_prob": 0.21991807222366333}, {"id": 163, "seek": 143696, "start": 1437.92, "end": 1448.88, "text": " range, then that the dash can be used to declare to define the range. And now if you use it after a", "tokens": [50412, 3613, 11, 550, 300, 264, 8240, 393, 312, 1143, 281, 19710, 281, 6964, 264, 3613, 13, 400, 586, 498, 291, 764, 309, 934, 257, 50960], "temperature": 0.0, "avg_logprob": -0.13936083829855617, "compression_ratio": 1.6951219512195121, "no_speech_prob": 0.07054813951253891}, {"id": 164, "seek": 143696, "start": 1448.88, "end": 1455.6000000000001, "text": " range, then it's looking for the actual dash. So now if you also want to look up a dash,", "tokens": [50960, 3613, 11, 550, 309, 311, 1237, 337, 264, 3539, 8240, 13, 407, 586, 498, 291, 611, 528, 281, 574, 493, 257, 8240, 11, 51296], "temperature": 0.0, "avg_logprob": -0.13936083829855617, "compression_ratio": 1.6951219512195121, "no_speech_prob": 0.07054813951253891}, {"id": 165, "seek": 143696, "start": 1456.16, "end": 1464.0, "text": " then we can find it here. And if you put it between two things, then it is a range. So be", "tokens": [51324, 550, 321, 393, 915, 309, 510, 13, 400, 498, 291, 829, 309, 1296, 732, 721, 11, 550, 309, 307, 257, 3613, 13, 407, 312, 51716], "temperature": 0.0, "avg_logprob": -0.13936083829855617, "compression_ratio": 1.6951219512195121, "no_speech_prob": 0.07054813951253891}, {"id": 166, "seek": 146400, "start": 1464.0, "end": 1476.56, "text": " careful here. And we can also write our different ranges back to back. So for example, if we have", "tokens": [50364, 5026, 510, 13, 400, 321, 393, 611, 2464, 527, 819, 22526, 646, 281, 646, 13, 407, 337, 1365, 11, 498, 321, 362, 50992], "temperature": 0.0, "avg_logprob": -0.07448407581874303, "compression_ratio": 1.6235955056179776, "no_speech_prob": 0.05032268911600113}, {"id": 167, "seek": 146400, "start": 1477.6, "end": 1485.52, "text": " hello here in uppercase letters, and first of all, let's say we only want the lowercase letters.", "tokens": [51044, 7751, 510, 294, 11775, 2869, 651, 7825, 11, 293, 700, 295, 439, 11, 718, 311, 584, 321, 787, 528, 264, 3126, 9765, 7825, 13, 51440], "temperature": 0.0, "avg_logprob": -0.07448407581874303, "compression_ratio": 1.6235955056179776, "no_speech_prob": 0.05032268911600113}, {"id": 168, "seek": 146400, "start": 1486.08, "end": 1493.28, "text": " And then we also want to have all the uppercase characters from A to C, then we can write this", "tokens": [51468, 400, 550, 321, 611, 528, 281, 362, 439, 264, 11775, 2869, 651, 4342, 490, 316, 281, 383, 11, 550, 321, 393, 2464, 341, 51828], "temperature": 0.0, "avg_logprob": -0.07448407581874303, "compression_ratio": 1.6235955056179776, "no_speech_prob": 0.05032268911600113}, {"id": 169, "seek": 149328, "start": 1493.28, "end": 1504.24, "text": " back to back. So we can say small a to C or a dash C, then capital A dash C. Then this will also", "tokens": [50364, 646, 281, 646, 13, 407, 321, 393, 584, 1359, 257, 281, 383, 420, 257, 8240, 383, 11, 550, 4238, 316, 8240, 383, 13, 1396, 341, 486, 611, 50912], "temperature": 0.0, "avg_logprob": -0.11576870137994939, "compression_ratio": 1.4661654135338347, "no_speech_prob": 0.008060837164521217}, {"id": 170, "seek": 149328, "start": 1504.24, "end": 1512.48, "text": " include all the uppercase characters. And again, we can use back to back and also include numbers.", "tokens": [50912, 4090, 439, 264, 11775, 2869, 651, 4342, 13, 400, 797, 11, 321, 393, 764, 646, 281, 646, 293, 611, 4090, 3547, 13, 51324], "temperature": 0.0, "avg_logprob": -0.11576870137994939, "compression_ratio": 1.4661654135338347, "no_speech_prob": 0.008060837164521217}, {"id": 171, "seek": 151248, "start": 1513.28, "end": 1523.76, "text": " So yeah, then it also finds the numbers here. So the digits. So yeah, so this is how we can use", "tokens": [50404, 407, 1338, 11, 550, 309, 611, 10704, 264, 3547, 510, 13, 407, 264, 27011, 13, 407, 1338, 11, 370, 341, 307, 577, 321, 393, 764, 50928], "temperature": 0.0, "avg_logprob": -0.17135163073269827, "compression_ratio": 1.4179104477611941, "no_speech_prob": 0.2172589749097824}, {"id": 172, "seek": 151248, "start": 1523.76, "end": 1537.92, "text": " sets with this brackets. And now let's talk about quantifier. So we have these quantifier, the", "tokens": [50928, 6352, 365, 341, 26179, 13, 400, 586, 718, 311, 751, 466, 4426, 9902, 13, 407, 321, 362, 613, 4426, 9902, 11, 264, 51636], "temperature": 0.0, "avg_logprob": -0.17135163073269827, "compression_ratio": 1.4179104477611941, "no_speech_prob": 0.2172589749097824}, {"id": 173, "seek": 153792, "start": 1538.88, "end": 1550.0, "text": " meta meta characters. So we have a an asterisk. So a the multiplication sign, this means zero or", "tokens": [50412, 19616, 19616, 4342, 13, 407, 321, 362, 257, 364, 257, 3120, 7797, 13, 407, 257, 264, 27290, 1465, 11, 341, 1355, 4018, 420, 50968], "temperature": 0.0, "avg_logprob": -0.12150135555782833, "compression_ratio": 1.7547169811320755, "no_speech_prob": 0.019415587186813354}, {"id": 174, "seek": 153792, "start": 1550.0, "end": 1557.2, "text": " more. Then we have the plus this means one or more, then we have the question mark. So this", "tokens": [50968, 544, 13, 1396, 321, 362, 264, 1804, 341, 1355, 472, 420, 544, 11, 550, 321, 362, 264, 1168, 1491, 13, 407, 341, 51328], "temperature": 0.0, "avg_logprob": -0.12150135555782833, "compression_ratio": 1.7547169811320755, "no_speech_prob": 0.019415587186813354}, {"id": 175, "seek": 153792, "start": 1557.2, "end": 1565.44, "text": " means zero or one. And this means or this can be used when we want to look for an optional", "tokens": [51328, 1355, 4018, 420, 472, 13, 400, 341, 1355, 420, 341, 393, 312, 1143, 562, 321, 528, 281, 574, 337, 364, 17312, 51740], "temperature": 0.0, "avg_logprob": -0.12150135555782833, "compression_ratio": 1.7547169811320755, "no_speech_prob": 0.019415587186813354}, {"id": 176, "seek": 156544, "start": 1565.52, "end": 1572.56, "text": " character. So it may be there, but it may also be not there. Then if we want to look for a specific", "tokens": [50368, 2517, 13, 407, 309, 815, 312, 456, 11, 457, 309, 815, 611, 312, 406, 456, 13, 1396, 498, 321, 528, 281, 574, 337, 257, 2685, 50720], "temperature": 0.0, "avg_logprob": -0.06881493738252822, "compression_ratio": 1.6744186046511629, "no_speech_prob": 0.026753243058919907}, {"id": 177, "seek": 156544, "start": 1572.56, "end": 1580.0800000000002, "text": " exact number, we can use curly braces and then a number here will look for the exact number.", "tokens": [50720, 1900, 1230, 11, 321, 393, 764, 32066, 41537, 293, 550, 257, 1230, 510, 486, 574, 337, 264, 1900, 1230, 13, 51096], "temperature": 0.0, "avg_logprob": -0.06881493738252822, "compression_ratio": 1.6744186046511629, "no_speech_prob": 0.026753243058919907}, {"id": 178, "seek": 156544, "start": 1581.6000000000001, "end": 1589.68, "text": " And then we can also specify a range with minimum and maximum. So if we put two numbers between", "tokens": [51172, 400, 550, 321, 393, 611, 16500, 257, 3613, 365, 7285, 293, 6674, 13, 407, 498, 321, 829, 732, 3547, 1296, 51576], "temperature": 0.0, "avg_logprob": -0.06881493738252822, "compression_ratio": 1.6744186046511629, "no_speech_prob": 0.026753243058919907}, {"id": 179, "seek": 158968, "start": 1589.68, "end": 1597.3600000000001, "text": " the curly braces, then it's looking for a range. Okay, so let's have a look at them in detail. So", "tokens": [50364, 264, 32066, 41537, 11, 550, 309, 311, 1237, 337, 257, 3613, 13, 1033, 11, 370, 718, 311, 362, 257, 574, 412, 552, 294, 2607, 13, 407, 50748], "temperature": 0.0, "avg_logprob": -0.0900521967784468, "compression_ratio": 1.5769230769230769, "no_speech_prob": 0.08386661112308502}, {"id": 180, "seek": 158968, "start": 1598.5600000000002, "end": 1608.16, "text": " let's say we have a string, let's say hello underscore 123. And now let's say we want to have", "tokens": [50808, 718, 311, 584, 321, 362, 257, 6798, 11, 718, 311, 584, 7751, 37556, 34466, 13, 400, 586, 718, 311, 584, 321, 528, 281, 362, 51288], "temperature": 0.0, "avg_logprob": -0.0900521967784468, "compression_ratio": 1.5769230769230769, "no_speech_prob": 0.08386661112308502}, {"id": 181, "seek": 158968, "start": 1608.72, "end": 1615.92, "text": " or we want to find digits. And remember, we can do this with with backslash D. And then it will", "tokens": [51316, 420, 321, 528, 281, 915, 27011, 13, 400, 1604, 11, 321, 393, 360, 341, 365, 365, 646, 10418, 1299, 413, 13, 400, 550, 309, 486, 51676], "temperature": 0.0, "avg_logprob": -0.0900521967784468, "compression_ratio": 1.5769230769230769, "no_speech_prob": 0.08386661112308502}, {"id": 182, "seek": 161592, "start": 1615.92, "end": 1626.16, "text": " find all the digits. And let's say we want to look if we have zero or more. So then we use an", "tokens": [50364, 915, 439, 264, 27011, 13, 400, 718, 311, 584, 321, 528, 281, 574, 498, 321, 362, 4018, 420, 544, 13, 407, 550, 321, 764, 364, 50876], "temperature": 0.0, "avg_logprob": -0.05173184321476863, "compression_ratio": 1.6079545454545454, "no_speech_prob": 0.02716384269297123}, {"id": 183, "seek": 161592, "start": 1626.16, "end": 1635.28, "text": " asterisk. And then it will also find all the other characters here. Because here there is no", "tokens": [50876, 257, 3120, 7797, 13, 400, 550, 309, 486, 611, 915, 439, 264, 661, 4342, 510, 13, 1436, 510, 456, 307, 572, 51332], "temperature": 0.0, "avg_logprob": -0.05173184321476863, "compression_ratio": 1.6079545454545454, "no_speech_prob": 0.02716384269297123}, {"id": 184, "seek": 161592, "start": 1636.5600000000002, "end": 1644.5600000000002, "text": " digit, but it was looking for zero or more. And in this case, our match is just an empty string.", "tokens": [51396, 14293, 11, 457, 309, 390, 1237, 337, 4018, 420, 544, 13, 400, 294, 341, 1389, 11, 527, 2995, 307, 445, 364, 6707, 6798, 13, 51796], "temperature": 0.0, "avg_logprob": -0.05173184321476863, "compression_ratio": 1.6079545454545454, "no_speech_prob": 0.02716384269297123}, {"id": 185, "seek": 164456, "start": 1645.44, "end": 1652.3999999999999, "text": " And then again, an empty string, empty string, empty string. And then here we have digits. And", "tokens": [50408, 400, 550, 797, 11, 364, 6707, 6798, 11, 6707, 6798, 11, 6707, 6798, 13, 400, 550, 510, 321, 362, 27011, 13, 400, 50756], "temperature": 0.0, "avg_logprob": -0.07291604311038287, "compression_ratio": 1.713450292397661, "no_speech_prob": 0.0222755316644907}, {"id": 186, "seek": 164456, "start": 1652.3999999999999, "end": 1661.76, "text": " then it will combine them into one match. So now if we just use the and use it without a quantifier,", "tokens": [50756, 550, 309, 486, 10432, 552, 666, 472, 2995, 13, 407, 586, 498, 321, 445, 764, 264, 293, 764, 309, 1553, 257, 4426, 9902, 11, 51224], "temperature": 0.0, "avg_logprob": -0.07291604311038287, "compression_ratio": 1.713450292397661, "no_speech_prob": 0.0222755316644907}, {"id": 187, "seek": 164456, "start": 1661.76, "end": 1670.32, "text": " then it puts any every single digit as one match. And if we want to look for zero or more, we can", "tokens": [51224, 550, 309, 8137, 604, 633, 2167, 14293, 382, 472, 2995, 13, 400, 498, 321, 528, 281, 574, 337, 4018, 420, 544, 11, 321, 393, 51652], "temperature": 0.0, "avg_logprob": -0.07291604311038287, "compression_ratio": 1.713450292397661, "no_speech_prob": 0.0222755316644907}, {"id": 188, "seek": 167032, "start": 1670.32, "end": 1678.1599999999999, "text": " use this with an asterisk. And now in this case, a plus is better. So we want to look for one or", "tokens": [50364, 764, 341, 365, 364, 257, 3120, 7797, 13, 400, 586, 294, 341, 1389, 11, 257, 1804, 307, 1101, 13, 407, 321, 528, 281, 574, 337, 472, 420, 50756], "temperature": 0.0, "avg_logprob": -0.04700438373060112, "compression_ratio": 1.7159763313609468, "no_speech_prob": 0.04602115601301193}, {"id": 189, "seek": 167032, "start": 1678.1599999999999, "end": 1688.6399999999999, "text": " more. And then we will see it has only one match. And it combined all the digits into one match.", "tokens": [50756, 544, 13, 400, 550, 321, 486, 536, 309, 575, 787, 472, 2995, 13, 400, 309, 9354, 439, 264, 27011, 666, 472, 2995, 13, 51280], "temperature": 0.0, "avg_logprob": -0.04700438373060112, "compression_ratio": 1.7159763313609468, "no_speech_prob": 0.04602115601301193}, {"id": 190, "seek": 167032, "start": 1688.6399999999999, "end": 1694.6399999999999, "text": " And let's say we want to look for a digit that has an underscore in front of it. So let's say we", "tokens": [51280, 400, 718, 311, 584, 321, 528, 281, 574, 337, 257, 14293, 300, 575, 364, 37556, 294, 1868, 295, 309, 13, 407, 718, 311, 584, 321, 51580], "temperature": 0.0, "avg_logprob": -0.04700438373060112, "compression_ratio": 1.7159763313609468, "no_speech_prob": 0.04602115601301193}, {"id": 191, "seek": 169464, "start": 1694.64, "end": 1704.4, "text": " want to look for underscore and then the digit, then it will find the one. And but now let's say", "tokens": [50364, 528, 281, 574, 337, 37556, 293, 550, 264, 14293, 11, 550, 309, 486, 915, 264, 472, 13, 400, 457, 586, 718, 311, 584, 50852], "temperature": 0.0, "avg_logprob": -0.0545402006669478, "compression_ratio": 1.691358024691358, "no_speech_prob": 0.01281958632171154}, {"id": 192, "seek": 169464, "start": 1704.4, "end": 1710.3200000000002, "text": " we don't know if there is an underscore or not. So now if the string looks like this,", "tokens": [50852, 321, 500, 380, 458, 498, 456, 307, 364, 37556, 420, 406, 13, 407, 586, 498, 264, 6798, 1542, 411, 341, 11, 51148], "temperature": 0.0, "avg_logprob": -0.0545402006669478, "compression_ratio": 1.691358024691358, "no_speech_prob": 0.01281958632171154}, {"id": 193, "seek": 169464, "start": 1711.1200000000001, "end": 1717.92, "text": " and then if we run it, then it doesn't find a string, a match. And then we can say that the", "tokens": [51188, 293, 550, 498, 321, 1190, 309, 11, 550, 309, 1177, 380, 915, 257, 6798, 11, 257, 2995, 13, 400, 550, 321, 393, 584, 300, 264, 51528], "temperature": 0.0, "avg_logprob": -0.0545402006669478, "compression_ratio": 1.691358024691358, "no_speech_prob": 0.01281958632171154}, {"id": 194, "seek": 171792, "start": 1718.0, "end": 1727.68, "text": " underscore is optional by using the question mark. And now if we run it, it finds all the matches,", "tokens": [50368, 37556, 307, 17312, 538, 1228, 264, 1168, 1491, 13, 400, 586, 498, 321, 1190, 309, 11, 309, 10704, 439, 264, 10676, 11, 50852], "temperature": 0.0, "avg_logprob": -0.08548705918448311, "compression_ratio": 1.7421383647798743, "no_speech_prob": 0.054184261709451675}, {"id": 195, "seek": 171792, "start": 1728.72, "end": 1735.8400000000001, "text": " because it doesn't has an underscore. And now if we do it like this, then it will", "tokens": [50904, 570, 309, 1177, 380, 575, 364, 37556, 13, 400, 586, 498, 321, 360, 309, 411, 341, 11, 550, 309, 486, 51260], "temperature": 0.0, "avg_logprob": -0.08548705918448311, "compression_ratio": 1.7421383647798743, "no_speech_prob": 0.054184261709451675}, {"id": 196, "seek": 171792, "start": 1737.52, "end": 1746.4, "text": " find the same matches because it can also have an underscore here. So this is the question mark.", "tokens": [51344, 915, 264, 912, 10676, 570, 309, 393, 611, 362, 364, 37556, 510, 13, 407, 341, 307, 264, 1168, 1491, 13, 51788], "temperature": 0.0, "avg_logprob": -0.08548705918448311, "compression_ratio": 1.7421383647798743, "no_speech_prob": 0.054184261709451675}, {"id": 197, "seek": 174640, "start": 1747.1200000000001, "end": 1755.68, "text": " And now let's talk about specific ranges or a specific number of", "tokens": [50400, 400, 586, 718, 311, 751, 466, 2685, 22526, 420, 257, 2685, 1230, 295, 50828], "temperature": 0.0, "avg_logprob": -0.07582647872693611, "compression_ratio": 1.608695652173913, "no_speech_prob": 0.012051221914589405}, {"id": 198, "seek": 174640, "start": 1757.76, "end": 1766.24, "text": " characters. So now if you want to look for three digits, then we can say a digit and then curly", "tokens": [50932, 4342, 13, 407, 586, 498, 291, 528, 281, 574, 337, 1045, 27011, 11, 550, 321, 393, 584, 257, 14293, 293, 550, 32066, 51356], "temperature": 0.0, "avg_logprob": -0.07582647872693611, "compression_ratio": 1.608695652173913, "no_speech_prob": 0.012051221914589405}, {"id": 199, "seek": 174640, "start": 1766.24, "end": 1773.92, "text": " raise and then three, then it will find our match. So now if we are looking for four of the digits", "tokens": [51356, 5300, 293, 550, 1045, 11, 550, 309, 486, 915, 527, 2995, 13, 407, 586, 498, 321, 366, 1237, 337, 1451, 295, 264, 27011, 51740], "temperature": 0.0, "avg_logprob": -0.07582647872693611, "compression_ratio": 1.608695652173913, "no_speech_prob": 0.012051221914589405}, {"id": 200, "seek": 177392, "start": 1773.92, "end": 1780.5600000000002, "text": " and run it, then we don't have a match. And we can also use a range here. So this can be between", "tokens": [50364, 293, 1190, 309, 11, 550, 321, 500, 380, 362, 257, 2995, 13, 400, 321, 393, 611, 764, 257, 3613, 510, 13, 407, 341, 393, 312, 1296, 50696], "temperature": 0.0, "avg_logprob": -0.07488838418737634, "compression_ratio": 1.5875706214689265, "no_speech_prob": 0.01133034098893404}, {"id": 201, "seek": 177392, "start": 1780.5600000000002, "end": 1790.64, "text": " can be between one and three. And then it will also find the match. So these are the quantifiers.", "tokens": [50696, 393, 312, 1296, 472, 293, 1045, 13, 400, 550, 309, 486, 611, 915, 264, 2995, 13, 407, 613, 366, 264, 4426, 23463, 13, 51200], "temperature": 0.0, "avg_logprob": -0.07488838418737634, "compression_ratio": 1.5875706214689265, "no_speech_prob": 0.01133034098893404}, {"id": 202, "seek": 177392, "start": 1791.28, "end": 1797.04, "text": " Now let's stop for a second with all the concepts and just make or just do an example.", "tokens": [51232, 823, 718, 311, 1590, 337, 257, 1150, 365, 439, 264, 10392, 293, 445, 652, 420, 445, 360, 364, 1365, 13, 51520], "temperature": 0.0, "avg_logprob": -0.07488838418737634, "compression_ratio": 1.5875706214689265, "no_speech_prob": 0.01133034098893404}, {"id": 203, "seek": 179704, "start": 1797.6, "end": 1805.6, "text": " So let me copy this string here. And now let's use some of the concepts that we already know.", "tokens": [50392, 407, 718, 385, 5055, 341, 6798, 510, 13, 400, 586, 718, 311, 764, 512, 295, 264, 10392, 300, 321, 1217, 458, 13, 50792], "temperature": 0.0, "avg_logprob": -0.09138545989990235, "compression_ratio": 1.6511627906976745, "no_speech_prob": 0.19676347076892853}, {"id": 204, "seek": 179704, "start": 1808.24, "end": 1816.8, "text": " So let's say our string is now the date string. So this is dates in different formats. So for", "tokens": [50924, 407, 718, 311, 584, 527, 6798, 307, 586, 264, 4002, 6798, 13, 407, 341, 307, 11691, 294, 819, 25879, 13, 407, 337, 51352], "temperature": 0.0, "avg_logprob": -0.09138545989990235, "compression_ratio": 1.6511627906976745, "no_speech_prob": 0.19676347076892853}, {"id": 205, "seek": 179704, "start": 1816.8, "end": 1825.12, "text": " example, here, we have the day and the month and then the year and this is separated by a colon.", "tokens": [51352, 1365, 11, 510, 11, 321, 362, 264, 786, 293, 264, 1618, 293, 550, 264, 1064, 293, 341, 307, 12005, 538, 257, 8255, 13, 51768], "temperature": 0.0, "avg_logprob": -0.09138545989990235, "compression_ratio": 1.6511627906976745, "no_speech_prob": 0.19676347076892853}, {"id": 206, "seek": 182512, "start": 1825.12, "end": 1833.4399999999998, "text": " Then here it's the year first, then a colon, then here we have year, month and day separated by a", "tokens": [50364, 1396, 510, 309, 311, 264, 1064, 700, 11, 550, 257, 8255, 11, 550, 510, 321, 362, 1064, 11, 1618, 293, 786, 12005, 538, 257, 50780], "temperature": 0.0, "avg_logprob": -0.14635127469113, "compression_ratio": 1.6706586826347305, "no_speech_prob": 0.007458507549017668}, {"id": 207, "seek": 182512, "start": 1833.4399999999998, "end": 1842.9599999999998, "text": " dash and here by a slash and also by an underscore. And now let's say we only want to extract", "tokens": [50780, 8240, 293, 510, 538, 257, 17330, 293, 611, 538, 364, 37556, 13, 400, 586, 718, 311, 584, 321, 787, 528, 281, 8947, 51256], "temperature": 0.0, "avg_logprob": -0.14635127469113, "compression_ratio": 1.6706586826347305, "no_speech_prob": 0.007458507549017668}, {"id": 208, "seek": 182512, "start": 1844.08, "end": 1853.1999999999998, "text": " the dates with this format. So year, month and day, and only with a dash in between. So", "tokens": [51312, 264, 11691, 365, 341, 7877, 13, 407, 1064, 11, 1618, 293, 786, 11, 293, 787, 365, 257, 8240, 294, 1296, 13, 407, 51768], "temperature": 0.0, "avg_logprob": -0.14635127469113, "compression_ratio": 1.6706586826347305, "no_speech_prob": 0.007458507549017668}, {"id": 209, "seek": 185320, "start": 1853.2, "end": 1862.96, "text": " let's do this. So the first thing we can do is now here is to look for", "tokens": [50364, 718, 311, 360, 341, 13, 407, 264, 700, 551, 321, 393, 360, 307, 586, 510, 307, 281, 574, 337, 50852], "temperature": 0.0, "avg_logprob": -0.2212506807767428, "compression_ratio": 1.4695652173913043, "no_speech_prob": 0.00475457776337862}, {"id": 210, "seek": 185320, "start": 1865.52, "end": 1874.4, "text": " this pattern. So four, two and again two digits. So we can write this up. So backslash d backslash", "tokens": [50980, 341, 5102, 13, 407, 1451, 11, 732, 293, 797, 732, 27011, 13, 407, 321, 393, 2464, 341, 493, 13, 407, 646, 10418, 1299, 274, 646, 10418, 1299, 51424], "temperature": 0.0, "avg_logprob": -0.2212506807767428, "compression_ratio": 1.4695652173913043, "no_speech_prob": 0.00475457776337862}, {"id": 211, "seek": 187440, "start": 1875.2800000000002, "end": 1886.88, "text": " d. And then let's say first of all, we want to look for any character between. So remember,", "tokens": [50408, 274, 13, 400, 550, 718, 311, 584, 700, 295, 439, 11, 321, 528, 281, 574, 337, 604, 2517, 1296, 13, 407, 1604, 11, 50988], "temperature": 0.0, "avg_logprob": -0.1409244795103331, "compression_ratio": 1.5892857142857142, "no_speech_prob": 0.06655259430408478}, {"id": 212, "seek": 187440, "start": 1886.88, "end": 1893.92, "text": " the point is a meta character. So this is looking, if you have a look at this here,", "tokens": [50988, 264, 935, 307, 257, 19616, 2517, 13, 407, 341, 307, 1237, 11, 498, 291, 362, 257, 574, 412, 341, 510, 11, 51340], "temperature": 0.0, "avg_logprob": -0.1409244795103331, "compression_ratio": 1.5892857142857142, "no_speech_prob": 0.06655259430408478}, {"id": 213, "seek": 187440, "start": 1893.92, "end": 1902.3200000000002, "text": " this is looking for any character except new line. Then we have two digits. So backslash d,", "tokens": [51340, 341, 307, 1237, 337, 604, 2517, 3993, 777, 1622, 13, 1396, 321, 362, 732, 27011, 13, 407, 646, 10418, 1299, 274, 11, 51760], "temperature": 0.0, "avg_logprob": -0.1409244795103331, "compression_ratio": 1.5892857142857142, "no_speech_prob": 0.06655259430408478}, {"id": 214, "seek": 190232, "start": 1902.32, "end": 1910.3999999999999, "text": " then again, we can have any character and then d and backslash d. So for example,", "tokens": [50364, 550, 797, 11, 321, 393, 362, 604, 2517, 293, 550, 274, 293, 646, 10418, 1299, 274, 13, 407, 337, 1365, 11, 50768], "temperature": 0.0, "avg_logprob": -0.12765561288862087, "compression_ratio": 1.486842105263158, "no_speech_prob": 0.008710428141057491}, {"id": 215, "seek": 190232, "start": 1910.3999999999999, "end": 1916.8, "text": " if our string has also some text in it. And now if we run this,", "tokens": [50768, 498, 527, 6798, 575, 611, 512, 2487, 294, 309, 13, 400, 586, 498, 321, 1190, 341, 11, 51088], "temperature": 0.0, "avg_logprob": -0.12765561288862087, "compression_ratio": 1.486842105263158, "no_speech_prob": 0.008710428141057491}, {"id": 216, "seek": 190232, "start": 1919.4399999999998, "end": 1927.52, "text": " now it's called dates, the string. Now if we run this, then it will find all the", "tokens": [51220, 586, 309, 311, 1219, 11691, 11, 264, 6798, 13, 823, 498, 321, 1190, 341, 11, 550, 309, 486, 915, 439, 264, 51624], "temperature": 0.0, "avg_logprob": -0.12765561288862087, "compression_ratio": 1.486842105263158, "no_speech_prob": 0.008710428141057491}, {"id": 217, "seek": 192752, "start": 1928.32, "end": 1939.2, "text": " all the states with with the numbers, but only in this format. So four, two, two. So for example,", "tokens": [50404, 439, 264, 4368, 365, 365, 264, 3547, 11, 457, 787, 294, 341, 7877, 13, 407, 1451, 11, 732, 11, 732, 13, 407, 337, 1365, 11, 50948], "temperature": 0.0, "avg_logprob": -0.16607887961647727, "compression_ratio": 1.4809160305343512, "no_speech_prob": 0.0212815310806036}, {"id": 218, "seek": 192752, "start": 1939.76, "end": 1946.8799999999999, "text": " it didn't put the text here, the hello text in here. And it didn't put this date in here because", "tokens": [50976, 309, 994, 380, 829, 264, 2487, 510, 11, 264, 7751, 2487, 294, 510, 13, 400, 309, 994, 380, 829, 341, 4002, 294, 510, 570, 51332], "temperature": 0.0, "avg_logprob": -0.16607887961647727, "compression_ratio": 1.4809160305343512, "no_speech_prob": 0.0212815310806036}, {"id": 219, "seek": 194688, "start": 1946.96, "end": 1962.0, "text": " it has a different format. So now this is our first try. And now what we can do here is, for", "tokens": [50368, 309, 575, 257, 819, 7877, 13, 407, 586, 341, 307, 527, 700, 853, 13, 400, 586, 437, 321, 393, 360, 510, 307, 11, 337, 51120], "temperature": 0.0, "avg_logprob": -0.046544922722710505, "compression_ratio": 1.413533834586466, "no_speech_prob": 0.30720487236976624}, {"id": 220, "seek": 194688, "start": 1962.0, "end": 1970.24, "text": " example, the next thing we want to do is to find only these in this format. So now let's have a", "tokens": [51120, 1365, 11, 264, 958, 551, 321, 528, 281, 360, 307, 281, 915, 787, 613, 294, 341, 7877, 13, 407, 586, 718, 311, 362, 257, 51532], "temperature": 0.0, "avg_logprob": -0.046544922722710505, "compression_ratio": 1.413533834586466, "no_speech_prob": 0.30720487236976624}, {"id": 221, "seek": 197024, "start": 1970.24, "end": 1979.76, "text": " look at, so let's exchange the dot by a dash. So this is looking for an actual dash. And then we", "tokens": [50364, 574, 412, 11, 370, 718, 311, 7742, 264, 5893, 538, 257, 8240, 13, 407, 341, 307, 1237, 337, 364, 3539, 8240, 13, 400, 550, 321, 50840], "temperature": 0.0, "avg_logprob": -0.11203766736117277, "compression_ratio": 1.4411764705882353, "no_speech_prob": 0.060074906796216965}, {"id": 222, "seek": 197024, "start": 1979.76, "end": 1990.64, "text": " have only the dates in this format. So four, two and two numbers separated by a dash. And let's say", "tokens": [50840, 362, 787, 264, 11691, 294, 341, 7877, 13, 407, 1451, 11, 732, 293, 732, 3547, 12005, 538, 257, 8240, 13, 400, 718, 311, 584, 51384], "temperature": 0.0, "avg_logprob": -0.11203766736117277, "compression_ratio": 1.4411764705882353, "no_speech_prob": 0.060074906796216965}, {"id": 223, "seek": 199064, "start": 1990.72, "end": 2002.0800000000002, "text": " we this may also be a valid date. So we can also looking for a slash as a separator here. So then", "tokens": [50368, 321, 341, 815, 611, 312, 257, 7363, 4002, 13, 407, 321, 393, 611, 1237, 337, 257, 17330, 382, 257, 3128, 1639, 510, 13, 407, 550, 50936], "temperature": 0.0, "avg_logprob": -0.13409832196357924, "compression_ratio": 1.6647398843930636, "no_speech_prob": 0.18941572308540344}, {"id": 224, "seek": 199064, "start": 2002.0800000000002, "end": 2012.3200000000002, "text": " we can use a set. So remember a set is defined in square brackets. And then we can define the", "tokens": [50936, 321, 393, 764, 257, 992, 13, 407, 1604, 257, 992, 307, 7642, 294, 3732, 26179, 13, 400, 550, 321, 393, 6964, 264, 51448], "temperature": 0.0, "avg_logprob": -0.13409832196357924, "compression_ratio": 1.6647398843930636, "no_speech_prob": 0.18941572308540344}, {"id": 225, "seek": 199064, "start": 2012.3200000000002, "end": 2020.24, "text": " characters that may be at this position. So for example, we have a dash. And we have also or may", "tokens": [51448, 4342, 300, 815, 312, 412, 341, 2535, 13, 407, 337, 1365, 11, 321, 362, 257, 8240, 13, 400, 321, 362, 611, 420, 815, 51844], "temperature": 0.0, "avg_logprob": -0.13409832196357924, "compression_ratio": 1.6647398843930636, "no_speech_prob": 0.18941572308540344}, {"id": 226, "seek": 202024, "start": 2020.4, "end": 2030.8, "text": " have a slash. And again, here we are using a set. So then we have dash slash and are closing our set.", "tokens": [50372, 362, 257, 17330, 13, 400, 797, 11, 510, 321, 366, 1228, 257, 992, 13, 407, 550, 321, 362, 8240, 17330, 293, 366, 10377, 527, 992, 13, 50892], "temperature": 0.0, "avg_logprob": -0.08636316500212017, "compression_ratio": 1.558139534883721, "no_speech_prob": 0.016910580918192863}, {"id": 227, "seek": 202024, "start": 2030.8, "end": 2040.72, "text": " And now if we run this again, then we see, sorry, we see that this is also included in the matches.", "tokens": [50892, 400, 586, 498, 321, 1190, 341, 797, 11, 550, 321, 536, 11, 2597, 11, 321, 536, 300, 341, 307, 611, 5556, 294, 264, 10676, 13, 51388], "temperature": 0.0, "avg_logprob": -0.08636316500212017, "compression_ratio": 1.558139534883721, "no_speech_prob": 0.016910580918192863}, {"id": 228, "seek": 204072, "start": 2040.72, "end": 2051.52, "text": " And now let's say, for example, we are looking only for dates in May or June. So how do we do", "tokens": [50364, 400, 586, 718, 311, 584, 11, 337, 1365, 11, 321, 366, 1237, 787, 337, 11691, 294, 1891, 420, 6928, 13, 407, 577, 360, 321, 360, 50904], "temperature": 0.0, "avg_logprob": -0.10043448209762573, "compression_ratio": 1.406015037593985, "no_speech_prob": 0.03620981425046921}, {"id": 229, "seek": 204072, "start": 2051.52, "end": 2062.7200000000003, "text": " that? So the month here. So what we do here is now this is not any digit. So here we are only", "tokens": [50904, 300, 30, 407, 264, 1618, 510, 13, 407, 437, 321, 360, 510, 307, 586, 341, 307, 406, 604, 14293, 13, 407, 510, 321, 366, 787, 51464], "temperature": 0.0, "avg_logprob": -0.10043448209762573, "compression_ratio": 1.406015037593985, "no_speech_prob": 0.03620981425046921}, {"id": 230, "seek": 206272, "start": 2062.72, "end": 2074.3999999999996, "text": " looking for month 05 and 06. So we always have a zero here. And then we can again use a set.", "tokens": [50364, 1237, 337, 1618, 1958, 20, 293, 1958, 21, 13, 407, 321, 1009, 362, 257, 4018, 510, 13, 400, 550, 321, 393, 797, 764, 257, 992, 13, 50948], "temperature": 0.0, "avg_logprob": -0.093285431581385, "compression_ratio": 1.5988700564971752, "no_speech_prob": 0.14604301750659943}, {"id": 231, "seek": 206272, "start": 2075.12, "end": 2083.4399999999996, "text": " And here we can use, let's say only five and six. And now if we run this, then we only have the", "tokens": [50984, 400, 510, 321, 393, 764, 11, 718, 311, 584, 787, 1732, 293, 2309, 13, 400, 586, 498, 321, 1190, 341, 11, 550, 321, 787, 362, 264, 51400], "temperature": 0.0, "avg_logprob": -0.093285431581385, "compression_ratio": 1.5988700564971752, "no_speech_prob": 0.14604301750659943}, {"id": 232, "seek": 206272, "start": 2083.4399999999996, "end": 2091.4399999999996, "text": " dates in May or June. And remember, we can also use a range here. So let's say we want to have", "tokens": [51400, 11691, 294, 1891, 420, 6928, 13, 400, 1604, 11, 321, 393, 611, 764, 257, 3613, 510, 13, 407, 718, 311, 584, 321, 528, 281, 362, 51800], "temperature": 0.0, "avg_logprob": -0.093285431581385, "compression_ratio": 1.5988700564971752, "no_speech_prob": 0.14604301750659943}, {"id": 233, "seek": 209144, "start": 2092.08, "end": 2102.16, "text": " May, June and July, then we can say five to seven. And then we have all the dates from May to July.", "tokens": [50396, 1891, 11, 6928, 293, 7370, 11, 550, 321, 393, 584, 1732, 281, 3407, 13, 400, 550, 321, 362, 439, 264, 11691, 490, 1891, 281, 7370, 13, 50900], "temperature": 0.0, "avg_logprob": -0.10428493598411823, "compression_ratio": 1.3846153846153846, "no_speech_prob": 0.028857165947556496}, {"id": 234, "seek": 209144, "start": 2103.04, "end": 2113.28, "text": " And now let's use a quantifier here. So instead of writing for these here, backslash D, we can say", "tokens": [50944, 400, 586, 718, 311, 764, 257, 4426, 9902, 510, 13, 407, 2602, 295, 3579, 337, 613, 510, 11, 646, 10418, 1299, 413, 11, 321, 393, 584, 51456], "temperature": 0.0, "avg_logprob": -0.10428493598411823, "compression_ratio": 1.3846153846153846, "no_speech_prob": 0.028857165947556496}, {"id": 235, "seek": 211328, "start": 2113.28, "end": 2123.44, "text": " D and then curly braces and use the quantifier for so we want to have exactly four digits here.", "tokens": [50364, 413, 293, 550, 32066, 41537, 293, 764, 264, 4426, 9902, 337, 370, 321, 528, 281, 362, 2293, 1451, 27011, 510, 13, 50872], "temperature": 0.0, "avg_logprob": -0.06828826665878296, "compression_ratio": 1.6091954022988506, "no_speech_prob": 0.14029891788959503}, {"id": 236, "seek": 211328, "start": 2123.44, "end": 2132.88, "text": " And here we want to have exactly two digits. So then we can do it like this. So this finds all", "tokens": [50872, 400, 510, 321, 528, 281, 362, 2293, 732, 27011, 13, 407, 550, 321, 393, 360, 309, 411, 341, 13, 407, 341, 10704, 439, 51344], "temperature": 0.0, "avg_logprob": -0.06828826665878296, "compression_ratio": 1.6091954022988506, "no_speech_prob": 0.14029891788959503}, {"id": 237, "seek": 211328, "start": 2132.88, "end": 2141.92, "text": " the dates in May, June or July in this format. So this is one typical example how regular", "tokens": [51344, 264, 11691, 294, 1891, 11, 6928, 420, 7370, 294, 341, 7877, 13, 407, 341, 307, 472, 7476, 1365, 577, 3890, 51796], "temperature": 0.0, "avg_logprob": -0.06828826665878296, "compression_ratio": 1.6091954022988506, "no_speech_prob": 0.14029891788959503}, {"id": 238, "seek": 214192, "start": 2141.92, "end": 2150.7200000000003, "text": " expressions are useful. And yeah, so now let's continue. So we already covered a lot here.", "tokens": [50364, 15277, 366, 4420, 13, 400, 1338, 11, 370, 586, 718, 311, 2354, 13, 407, 321, 1217, 5343, 257, 688, 510, 13, 50804], "temperature": 0.0, "avg_logprob": -0.06872408286384914, "compression_ratio": 1.4031007751937985, "no_speech_prob": 0.04335606098175049}, {"id": 239, "seek": 214192, "start": 2150.7200000000003, "end": 2161.84, "text": " So let's talk about conditions next. So let me copy another string and do another example.", "tokens": [50804, 407, 718, 311, 751, 466, 4487, 958, 13, 407, 718, 385, 5055, 1071, 6798, 293, 360, 1071, 1365, 13, 51360], "temperature": 0.0, "avg_logprob": -0.06872408286384914, "compression_ratio": 1.4031007751937985, "no_speech_prob": 0.04335606098175049}, {"id": 240, "seek": 216184, "start": 2162.48, "end": 2171.52, "text": " So here I have another string with some names. So let me copy and paste this here. So this is", "tokens": [50396, 407, 510, 286, 362, 1071, 6798, 365, 512, 5288, 13, 407, 718, 385, 5055, 293, 9163, 341, 510, 13, 407, 341, 307, 50848], "temperature": 0.0, "avg_logprob": -0.11084819273515181, "compression_ratio": 1.4918032786885247, "no_speech_prob": 0.40342220664024353}, {"id": 241, "seek": 216184, "start": 2171.52, "end": 2179.84, "text": " my new string. So here we have a Mr. Simpson, a Mrs. Simpson, a Mr. Brown, a Miss Smith,", "tokens": [50848, 452, 777, 6798, 13, 407, 510, 321, 362, 257, 2221, 13, 38184, 11, 257, 9814, 13, 38184, 11, 257, 2221, 13, 8030, 11, 257, 5275, 8538, 11, 51264], "temperature": 0.0, "avg_logprob": -0.11084819273515181, "compression_ratio": 1.4918032786885247, "no_speech_prob": 0.40342220664024353}, {"id": 242, "seek": 217984, "start": 2179.84, "end": 2195.1200000000003, "text": " and a Mr. T. And sometimes we have a dot between Mr. And sometimes not. And now let's just extract", "tokens": [50364, 293, 257, 2221, 13, 314, 13, 400, 2171, 321, 362, 257, 5893, 1296, 2221, 13, 400, 2171, 406, 13, 400, 586, 718, 311, 445, 8947, 51128], "temperature": 0.0, "avg_logprob": -0.0955241581179061, "compression_ratio": 1.4883720930232558, "no_speech_prob": 0.11277658492326736}, {"id": 243, "seek": 217984, "start": 2195.1200000000003, "end": 2203.76, "text": " all the different names here. So for example, there's some more in our files. So for example,", "tokens": [51128, 439, 264, 819, 5288, 510, 13, 407, 337, 1365, 11, 456, 311, 512, 544, 294, 527, 7098, 13, 407, 337, 1365, 11, 51560], "temperature": 0.0, "avg_logprob": -0.0955241581179061, "compression_ratio": 1.4883720930232558, "no_speech_prob": 0.11277658492326736}, {"id": 244, "seek": 220376, "start": 2203.84, "end": 2220.48, "text": " we have Hello World 123 date. And now we only we want to extract only the names and we want to", "tokens": [50368, 321, 362, 2425, 3937, 34466, 4002, 13, 400, 586, 321, 787, 321, 528, 281, 8947, 787, 264, 5288, 293, 321, 528, 281, 51200], "temperature": 0.0, "avg_logprob": -0.1117548147837321, "compression_ratio": 1.411764705882353, "no_speech_prob": 0.04602724686264992}, {"id": 245, "seek": 220376, "start": 2220.48, "end": 2232.48, "text": " have the whole name. So let's build up our pattern here. So let's look for Mr. First. So first we", "tokens": [51200, 362, 264, 1379, 1315, 13, 407, 718, 311, 1322, 493, 527, 5102, 510, 13, 407, 718, 311, 574, 337, 2221, 13, 2386, 13, 407, 700, 321, 51800], "temperature": 0.0, "avg_logprob": -0.1117548147837321, "compression_ratio": 1.411764705882353, "no_speech_prob": 0.04602724686264992}, {"id": 246, "seek": 223248, "start": 2232.48, "end": 2245.76, "text": " want to look for a Mr. So Mr. And then we have a white space. So backslash s. And then we have one", "tokens": [50364, 528, 281, 574, 337, 257, 2221, 13, 407, 2221, 13, 400, 550, 321, 362, 257, 2418, 1901, 13, 407, 646, 10418, 1299, 262, 13, 400, 550, 321, 362, 472, 51028], "temperature": 0.0, "avg_logprob": -0.1409427767894307, "compression_ratio": 1.584, "no_speech_prob": 0.042711079120635986}, {"id": 247, "seek": 223248, "start": 2245.76, "end": 2256.56, "text": " or more characters, so word characters. So here we use a backslash w. And then we say plus. So this", "tokens": [51028, 420, 544, 4342, 11, 370, 1349, 4342, 13, 407, 510, 321, 764, 257, 646, 10418, 1299, 261, 13, 400, 550, 321, 584, 1804, 13, 407, 341, 51568], "temperature": 0.0, "avg_logprob": -0.1409427767894307, "compression_ratio": 1.584, "no_speech_prob": 0.042711079120635986}, {"id": 248, "seek": 225656, "start": 2256.64, "end": 2267.44, "text": " remember this is a quantifier. So one or more. And then I'm looking for the my string here. And I don't", "tokens": [50368, 1604, 341, 307, 257, 4426, 9902, 13, 407, 472, 420, 544, 13, 400, 550, 286, 478, 1237, 337, 264, 452, 6798, 510, 13, 400, 286, 500, 380, 50908], "temperature": 0.0, "avg_logprob": -0.09764490688548369, "compression_ratio": 1.633879781420765, "no_speech_prob": 0.1127389594912529}, {"id": 249, "seek": 225656, "start": 2267.44, "end": 2274.48, "text": " actually write the space here because I have this backslash s. And now if I run this, then we see", "tokens": [50908, 767, 2464, 264, 1901, 510, 570, 286, 362, 341, 646, 10418, 1299, 262, 13, 400, 586, 498, 286, 1190, 341, 11, 550, 321, 536, 51260], "temperature": 0.0, "avg_logprob": -0.09764490688548369, "compression_ratio": 1.633879781420765, "no_speech_prob": 0.1127389594912529}, {"id": 250, "seek": 225656, "start": 2274.48, "end": 2286.08, "text": " that we have one match here. So this is our Mr. Simpson. So here we have the m r and then a space", "tokens": [51260, 300, 321, 362, 472, 2995, 510, 13, 407, 341, 307, 527, 2221, 13, 38184, 13, 407, 510, 321, 362, 264, 275, 367, 293, 550, 257, 1901, 51840], "temperature": 0.0, "avg_logprob": -0.09764490688548369, "compression_ratio": 1.633879781420765, "no_speech_prob": 0.1127389594912529}, {"id": 251, "seek": 228608, "start": 2286.08, "end": 2295.7599999999998, "text": " and then one or more word characters. And now as a next step, let's also include a Mr. Where we", "tokens": [50364, 293, 550, 472, 420, 544, 1349, 4342, 13, 400, 586, 382, 257, 958, 1823, 11, 718, 311, 611, 4090, 257, 2221, 13, 2305, 321, 50848], "temperature": 0.0, "avg_logprob": -0.1023341489125447, "compression_ratio": 1.5294117647058822, "no_speech_prob": 0.0027148574590682983}, {"id": 252, "seek": 228608, "start": 2295.7599999999998, "end": 2305.6, "text": " have the dot here. So we can have the dot. And now if you just write it like this and run it,", "tokens": [50848, 362, 264, 5893, 510, 13, 407, 321, 393, 362, 264, 5893, 13, 400, 586, 498, 291, 445, 2464, 309, 411, 341, 293, 1190, 309, 11, 51340], "temperature": 0.0, "avg_logprob": -0.1023341489125447, "compression_ratio": 1.5294117647058822, "no_speech_prob": 0.0027148574590682983}, {"id": 253, "seek": 228608, "start": 2306.48, "end": 2314.0, "text": " then it finds a sorry, I have to use backslash dot, of course, here, because it's looking for an", "tokens": [51384, 550, 309, 10704, 257, 2597, 11, 286, 362, 281, 764, 646, 10418, 1299, 5893, 11, 295, 1164, 11, 510, 11, 570, 309, 311, 1237, 337, 364, 51760], "temperature": 0.0, "avg_logprob": -0.1023341489125447, "compression_ratio": 1.5294117647058822, "no_speech_prob": 0.0027148574590682983}, {"id": 254, "seek": 231400, "start": 2314.0, "end": 2323.68, "text": " actual, I want to look for the actual dot. And now it only finds Mr. Brown and Mr. T, but not Mr.", "tokens": [50364, 3539, 11, 286, 528, 281, 574, 337, 264, 3539, 5893, 13, 400, 586, 309, 787, 10704, 2221, 13, 8030, 293, 2221, 13, 314, 11, 457, 406, 2221, 13, 50848], "temperature": 0.0, "avg_logprob": -0.10812908926127869, "compression_ratio": 1.5777777777777777, "no_speech_prob": 0.009266821667551994}, {"id": 255, "seek": 231400, "start": 2323.68, "end": 2332.32, "text": " Simpson anymore. So now as we just learned, we have the optional quantifier with a question mark.", "tokens": [50848, 38184, 3602, 13, 407, 586, 382, 321, 445, 3264, 11, 321, 362, 264, 17312, 4426, 9902, 365, 257, 1168, 1491, 13, 51280], "temperature": 0.0, "avg_logprob": -0.10812908926127869, "compression_ratio": 1.5777777777777777, "no_speech_prob": 0.009266821667551994}, {"id": 256, "seek": 231400, "start": 2332.32, "end": 2341.68, "text": " So now let's make our dot optional. And now if we run this, then we have all the Mr. And", "tokens": [51280, 407, 586, 718, 311, 652, 527, 5893, 17312, 13, 400, 586, 498, 321, 1190, 341, 11, 550, 321, 362, 439, 264, 2221, 13, 400, 51748], "temperature": 0.0, "avg_logprob": -0.10812908926127869, "compression_ratio": 1.5777777777777777, "no_speech_prob": 0.009266821667551994}, {"id": 257, "seek": 234168, "start": 2342.64, "end": 2352.72, "text": " now let's talk about where conditions are useful. So in this case, we may not only have Mr, but we", "tokens": [50412, 586, 718, 311, 751, 466, 689, 4487, 366, 4420, 13, 407, 294, 341, 1389, 11, 321, 815, 406, 787, 362, 2221, 11, 457, 321, 50916], "temperature": 0.0, "avg_logprob": -0.11210974207464254, "compression_ratio": 1.465648854961832, "no_speech_prob": 0.004264192655682564}, {"id": 258, "seek": 234168, "start": 2352.72, "end": 2361.8399999999997, "text": " may also have a miss or a misses. So then we can use a condition. So we use parentheses here.", "tokens": [50916, 815, 611, 362, 257, 1713, 420, 257, 29394, 13, 407, 550, 321, 393, 764, 257, 4188, 13, 407, 321, 764, 34153, 510, 13, 51372], "temperature": 0.0, "avg_logprob": -0.11210974207464254, "compression_ratio": 1.465648854961832, "no_speech_prob": 0.004264192655682564}, {"id": 259, "seek": 236184, "start": 2362.56, "end": 2372.6400000000003, "text": " And then we separate them. So let's have a look at this here. This meta character is the either or.", "tokens": [50400, 400, 550, 321, 4994, 552, 13, 407, 718, 311, 362, 257, 574, 412, 341, 510, 13, 639, 19616, 2517, 307, 264, 2139, 420, 13, 50904], "temperature": 0.0, "avg_logprob": -0.12865009478160314, "compression_ratio": 1.503875968992248, "no_speech_prob": 0.11276567727327347}, {"id": 260, "seek": 236184, "start": 2373.44, "end": 2387.92, "text": " So now if we use this, we can write Mr or miss or misses. And then if we run this, then we see", "tokens": [50944, 407, 586, 498, 321, 764, 341, 11, 321, 393, 2464, 2221, 420, 1713, 420, 29394, 13, 400, 550, 498, 321, 1190, 341, 11, 550, 321, 536, 51668], "temperature": 0.0, "avg_logprob": -0.12865009478160314, "compression_ratio": 1.503875968992248, "no_speech_prob": 0.11276567727327347}, {"id": 261, "seek": 238792, "start": 2388.88, "end": 2398.64, "text": " it extracted all the names from this text. So this is where a condition is useful.", "tokens": [50412, 309, 34086, 439, 264, 5288, 490, 341, 2487, 13, 407, 341, 307, 689, 257, 4188, 307, 4420, 13, 50900], "temperature": 0.0, "avg_logprob": -0.0849971660347872, "compression_ratio": 1.4193548387096775, "no_speech_prob": 0.02478860132396221}, {"id": 262, "seek": 238792, "start": 2399.6, "end": 2409.84, "text": " And as we have just seen, we grouped this condition together with the parentheses. So this is", "tokens": [50948, 400, 382, 321, 362, 445, 1612, 11, 321, 41877, 341, 4188, 1214, 365, 264, 34153, 13, 407, 341, 307, 51460], "temperature": 0.0, "avg_logprob": -0.0849971660347872, "compression_ratio": 1.4193548387096775, "no_speech_prob": 0.02478860132396221}, {"id": 263, "seek": 240984, "start": 2410.8, "end": 2421.04, "text": " again one meta character. And now let's talk about grouping a little bit more. So let's do", "tokens": [50412, 797, 472, 19616, 2517, 13, 400, 586, 718, 311, 751, 466, 40149, 257, 707, 857, 544, 13, 407, 718, 311, 360, 50924], "temperature": 0.0, "avg_logprob": -0.09608194779376594, "compression_ratio": 1.4, "no_speech_prob": 0.04602644592523575}, {"id": 264, "seek": 240984, "start": 2421.04, "end": 2431.76, "text": " another example for this. This is also a typical example. So let's copy some emails into our text.", "tokens": [50924, 1071, 1365, 337, 341, 13, 639, 307, 611, 257, 7476, 1365, 13, 407, 718, 311, 5055, 512, 12524, 666, 527, 2487, 13, 51460], "temperature": 0.0, "avg_logprob": -0.09608194779376594, "compression_ratio": 1.4, "no_speech_prob": 0.04602644592523575}, {"id": 265, "seek": 243176, "start": 2432.5600000000004, "end": 2439.44, "text": " And let's say we only want to extract the emails from this string here.", "tokens": [50404, 400, 718, 311, 584, 321, 787, 528, 281, 8947, 264, 12524, 490, 341, 6798, 510, 13, 50748], "temperature": 0.0, "avg_logprob": -0.08465493993556246, "compression_ratio": 1.3360655737704918, "no_speech_prob": 0.11120352894067764}, {"id": 266, "seek": 243176, "start": 2440.1600000000003, "end": 2452.5600000000004, "text": " So again, let's build up our pattern. So what we can do here is we can use sets to do this.", "tokens": [50784, 407, 797, 11, 718, 311, 1322, 493, 527, 5102, 13, 407, 437, 321, 393, 360, 510, 307, 321, 393, 764, 6352, 281, 360, 341, 13, 51404], "temperature": 0.0, "avg_logprob": -0.08465493993556246, "compression_ratio": 1.3360655737704918, "no_speech_prob": 0.11120352894067764}, {"id": 267, "seek": 245256, "start": 2453.52, "end": 2460.56, "text": " So let's build this up. So let's say we want to have some characters here.", "tokens": [50412, 407, 718, 311, 1322, 341, 493, 13, 407, 718, 311, 584, 321, 528, 281, 362, 512, 4342, 510, 13, 50764], "temperature": 0.0, "avg_logprob": -0.0744028091430664, "compression_ratio": 1.7, "no_speech_prob": 0.11122211813926697}, {"id": 268, "seek": 245256, "start": 2461.6, "end": 2469.2, "text": " So this may be word characters, but this may also be a dash and numbers.", "tokens": [50816, 407, 341, 815, 312, 1349, 4342, 11, 457, 341, 815, 611, 312, 257, 8240, 293, 3547, 13, 51196], "temperature": 0.0, "avg_logprob": -0.0744028091430664, "compression_ratio": 1.7, "no_speech_prob": 0.11122211813926697}, {"id": 269, "seek": 245256, "start": 2470.7999999999997, "end": 2479.7599999999998, "text": " So let's use a set here and let's use back to back ranges here. So we can use small a to c", "tokens": [51276, 407, 718, 311, 764, 257, 992, 510, 293, 718, 311, 764, 646, 281, 646, 22526, 510, 13, 407, 321, 393, 764, 1359, 257, 281, 269, 51724], "temperature": 0.0, "avg_logprob": -0.0744028091430664, "compression_ratio": 1.7, "no_speech_prob": 0.11122211813926697}, {"id": 270, "seek": 247976, "start": 2480.5600000000004, "end": 2492.0800000000004, "text": " or capital A to C, or also the digits zero to nine. Or we may also have a dash here.", "tokens": [50404, 420, 4238, 316, 281, 383, 11, 420, 611, 264, 27011, 4018, 281, 4949, 13, 1610, 321, 815, 611, 362, 257, 8240, 510, 13, 50980], "temperature": 0.0, "avg_logprob": -0.1451582908630371, "compression_ratio": 1.3515625, "no_speech_prob": 0.04206879809498787}, {"id": 271, "seek": 247976, "start": 2492.8, "end": 2502.6400000000003, "text": " So now we are you looking for any of these characters here. And we want to have multiple", "tokens": [51016, 407, 586, 321, 366, 291, 1237, 337, 604, 295, 613, 4342, 510, 13, 400, 321, 528, 281, 362, 3866, 51508], "temperature": 0.0, "avg_logprob": -0.1451582908630371, "compression_ratio": 1.3515625, "no_speech_prob": 0.04206879809498787}, {"id": 272, "seek": 250264, "start": 2502.64, "end": 2512.64, "text": " of them. So we say we want to have multiple. So one or more. So this combines this group into one", "tokens": [50364, 295, 552, 13, 407, 321, 584, 321, 528, 281, 362, 3866, 13, 407, 472, 420, 544, 13, 407, 341, 29520, 341, 1594, 666, 472, 50864], "temperature": 0.0, "avg_logprob": -0.0972004543651234, "compression_ratio": 1.4736842105263157, "no_speech_prob": 0.16875943541526794}, {"id": 273, "seek": 250264, "start": 2512.64, "end": 2522.3199999999997, "text": " match. And then it is followed by an add sign. So now if we compile this and run this, then we see", "tokens": [50864, 2995, 13, 400, 550, 309, 307, 6263, 538, 364, 909, 1465, 13, 407, 586, 498, 321, 31413, 341, 293, 1190, 341, 11, 550, 321, 536, 51348], "temperature": 0.0, "avg_logprob": -0.0972004543651234, "compression_ratio": 1.4736842105263157, "no_speech_prob": 0.16875943541526794}, {"id": 274, "seek": 252232, "start": 2523.04, "end": 2533.76, "text": " that it extracted all these patterns here with any words or numbers or dashes and then an", "tokens": [50400, 300, 309, 34086, 439, 613, 8294, 510, 365, 604, 2283, 420, 3547, 420, 8240, 279, 293, 550, 364, 50936], "temperature": 0.0, "avg_logprob": -0.09557973013983832, "compression_ratio": 1.393939393939394, "no_speech_prob": 0.4260358214378357}, {"id": 275, "seek": 252232, "start": 2533.76, "end": 2546.0, "text": " add sign. So this is the name before the email. And then our email can have different domains.", "tokens": [50936, 909, 1465, 13, 407, 341, 307, 264, 1315, 949, 264, 3796, 13, 400, 550, 527, 3796, 393, 362, 819, 25514, 13, 51548], "temperature": 0.0, "avg_logprob": -0.09557973013983832, "compression_ratio": 1.393939393939394, "no_speech_prob": 0.4260358214378357}, {"id": 276, "seek": 254600, "start": 2546.0, "end": 2555.84, "text": " So for example, we have at gmail.com at gmx.de or at my domain or my dash domain dot org.", "tokens": [50364, 407, 337, 1365, 11, 321, 362, 412, 290, 11799, 13, 1112, 412, 290, 76, 87, 13, 1479, 420, 412, 452, 9274, 420, 452, 8240, 9274, 5893, 14045, 13, 50856], "temperature": 0.0, "avg_logprob": -0.14454850635013064, "compression_ratio": 1.620253164556962, "no_speech_prob": 0.07805537432432175}, {"id": 277, "seek": 254600, "start": 2556.4, "end": 2565.28, "text": " So we want to extract all the different domains. And the next thing we want to look is to look for", "tokens": [50884, 407, 321, 528, 281, 8947, 439, 264, 819, 25514, 13, 400, 264, 958, 551, 321, 528, 281, 574, 307, 281, 574, 337, 51328], "temperature": 0.0, "avg_logprob": -0.14454850635013064, "compression_ratio": 1.620253164556962, "no_speech_prob": 0.07805537432432175}, {"id": 278, "seek": 254600, "start": 2565.28, "end": 2572.0, "text": " only for word characters. So the domain doesn't have a digit in it.", "tokens": [51328, 787, 337, 1349, 4342, 13, 407, 264, 9274, 1177, 380, 362, 257, 14293, 294, 309, 13, 51664], "temperature": 0.0, "avg_logprob": -0.14454850635013064, "compression_ratio": 1.620253164556962, "no_speech_prob": 0.07805537432432175}, {"id": 279, "seek": 257200, "start": 2572.96, "end": 2583.04, "text": " So the only allowed characters are let's use another set. And here we use again, maybe a to c,", "tokens": [50412, 407, 264, 787, 4350, 4342, 366, 718, 311, 764, 1071, 992, 13, 400, 510, 321, 764, 797, 11, 1310, 257, 281, 269, 11, 50916], "temperature": 0.0, "avg_logprob": -0.20029066227100514, "compression_ratio": 1.3587786259541985, "no_speech_prob": 0.016912583261728287}, {"id": 280, "seek": 257200, "start": 2584.08, "end": 2593.52, "text": " a capital A to C, and also a dash. And then we have the dot. So now let's run this.", "tokens": [50968, 257, 4238, 316, 281, 383, 11, 293, 611, 257, 8240, 13, 400, 550, 321, 362, 264, 5893, 13, 407, 586, 718, 311, 1190, 341, 13, 51440], "temperature": 0.0, "avg_logprob": -0.20029066227100514, "compression_ratio": 1.3587786259541985, "no_speech_prob": 0.016912583261728287}, {"id": 281, "seek": 259352, "start": 2594.48, "end": 2607.36, "text": " And of course, there are again, one or more. So here I have to do a plus. And then it's looking", "tokens": [50412, 400, 295, 1164, 11, 456, 366, 797, 11, 472, 420, 544, 13, 407, 510, 286, 362, 281, 360, 257, 1804, 13, 400, 550, 309, 311, 1237, 51056], "temperature": 0.0, "avg_logprob": -0.0962330765194363, "compression_ratio": 1.4351145038167938, "no_speech_prob": 0.20940864086151123}, {"id": 282, "seek": 259352, "start": 2607.36, "end": 2618.48, "text": " for one or more. So now we see our match also includes the domain name and the dot. And then", "tokens": [51056, 337, 472, 420, 544, 13, 407, 586, 321, 536, 527, 2995, 611, 5974, 264, 9274, 1315, 293, 264, 5893, 13, 400, 550, 51612], "temperature": 0.0, "avg_logprob": -0.0962330765194363, "compression_ratio": 1.4351145038167938, "no_speech_prob": 0.20940864086151123}, {"id": 283, "seek": 261848, "start": 2618.56, "end": 2629.76, "text": " here at the very end, let's do another set. So here we say our ending. For example, we can say", "tokens": [50368, 510, 412, 264, 588, 917, 11, 718, 311, 360, 1071, 992, 13, 407, 510, 321, 584, 527, 8121, 13, 1171, 1365, 11, 321, 393, 584, 50928], "temperature": 0.0, "avg_logprob": -0.06886350062855504, "compression_ratio": 1.3941605839416058, "no_speech_prob": 0.010169065557420254}, {"id": 284, "seek": 261848, "start": 2629.76, "end": 2640.64, "text": " here we have dot. Sorry, again, I missed, I was not looking for an actual dot here. So this is a", "tokens": [50928, 510, 321, 362, 5893, 13, 4919, 11, 797, 11, 286, 6721, 11, 286, 390, 406, 1237, 337, 364, 3539, 5893, 510, 13, 407, 341, 307, 257, 51472], "temperature": 0.0, "avg_logprob": -0.06886350062855504, "compression_ratio": 1.3941605839416058, "no_speech_prob": 0.010169065557420254}, {"id": 285, "seek": 264064, "start": 2640.64, "end": 2650.3199999999997, "text": " typical mistake that I make. So now it for example, it would have also found this one here. But this", "tokens": [50364, 7476, 6146, 300, 286, 652, 13, 407, 586, 309, 337, 1365, 11, 309, 576, 362, 611, 1352, 341, 472, 510, 13, 583, 341, 50848], "temperature": 0.0, "avg_logprob": -0.09745245575904846, "compression_ratio": 1.5240641711229947, "no_speech_prob": 0.12762534618377686}, {"id": 286, "seek": 264064, "start": 2650.3199999999997, "end": 2656.72, "text": " is not a valid email address. So I have to look for the actual dot by using the backslash.", "tokens": [50848, 307, 406, 257, 7363, 3796, 2985, 13, 407, 286, 362, 281, 574, 337, 264, 3539, 5893, 538, 1228, 264, 646, 10418, 1299, 13, 51168], "temperature": 0.0, "avg_logprob": -0.09745245575904846, "compression_ratio": 1.5240641711229947, "no_speech_prob": 0.12762534618377686}, {"id": 287, "seek": 264064, "start": 2658.4, "end": 2668.64, "text": " And then let's say I'm looking only for dot com. But it can also be dot de or dot org. So for", "tokens": [51252, 400, 550, 718, 311, 584, 286, 478, 1237, 787, 337, 5893, 395, 13, 583, 309, 393, 611, 312, 5893, 368, 420, 5893, 14045, 13, 407, 337, 51764], "temperature": 0.0, "avg_logprob": -0.09745245575904846, "compression_ratio": 1.5240641711229947, "no_speech_prob": 0.12762534618377686}, {"id": 288, "seek": 266864, "start": 2668.64, "end": 2680.0, "text": " example, I can use a group here by using parentheses and then use the condition here com or de or", "tokens": [50364, 1365, 11, 286, 393, 764, 257, 1594, 510, 538, 1228, 34153, 293, 550, 764, 264, 4188, 510, 395, 420, 368, 420, 50932], "temperature": 0.0, "avg_logprob": -0.07335658975549646, "compression_ratio": 1.6647058823529413, "no_speech_prob": 0.013426631689071655}, {"id": 289, "seek": 266864, "start": 2680.0, "end": 2691.2, "text": " dot org. So now it would only find these endings here. And now let's not use a condition. But", "tokens": [50932, 5893, 14045, 13, 407, 586, 309, 576, 787, 915, 613, 42474, 510, 13, 400, 586, 718, 311, 406, 764, 257, 4188, 13, 583, 51492], "temperature": 0.0, "avg_logprob": -0.07335658975549646, "compression_ratio": 1.6647058823529413, "no_speech_prob": 0.013426631689071655}, {"id": 290, "seek": 266864, "start": 2691.2, "end": 2697.8399999999997, "text": " I just wanted to show you the condition here again. But we can also just use a set here. So", "tokens": [51492, 286, 445, 1415, 281, 855, 291, 264, 4188, 510, 797, 13, 583, 321, 393, 611, 445, 764, 257, 992, 510, 13, 407, 51824], "temperature": 0.0, "avg_logprob": -0.07335658975549646, "compression_ratio": 1.6647058823529413, "no_speech_prob": 0.013426631689071655}, {"id": 291, "seek": 269784, "start": 2697.84, "end": 2711.28, "text": " let's use the set. And again, here, we may have a to C and a to C and capital and then one or more.", "tokens": [50364, 718, 311, 764, 264, 992, 13, 400, 797, 11, 510, 11, 321, 815, 362, 257, 281, 383, 293, 257, 281, 383, 293, 4238, 293, 550, 472, 420, 544, 13, 51036], "temperature": 0.0, "avg_logprob": -0.10166445425001241, "compression_ratio": 1.437956204379562, "no_speech_prob": 0.005219454411417246}, {"id": 292, "seek": 269784, "start": 2712.7200000000003, "end": 2723.92, "text": " And no digits here. So now if you run this, then this will extract all the emails for us. So this", "tokens": [51108, 400, 572, 27011, 510, 13, 407, 586, 498, 291, 1190, 341, 11, 550, 341, 486, 8947, 439, 264, 12524, 337, 505, 13, 407, 341, 51668], "temperature": 0.0, "avg_logprob": -0.10166445425001241, "compression_ratio": 1.437956204379562, "no_speech_prob": 0.005219454411417246}, {"id": 293, "seek": 272392, "start": 2723.92, "end": 2731.76, "text": " is a typical regular expression pattern to look for emails. And this is what I showed you in the", "tokens": [50364, 307, 257, 7476, 3890, 6114, 5102, 281, 574, 337, 12524, 13, 400, 341, 307, 437, 286, 4712, 291, 294, 264, 50756], "temperature": 0.0, "avg_logprob": -0.04839889662606375, "compression_ratio": 1.5103092783505154, "no_speech_prob": 0.013221465051174164}, {"id": 294, "seek": 272392, "start": 2731.76, "end": 2740.32, "text": " beginning. So now you understand what this means. And now let's talk about grouping a little bit", "tokens": [50756, 2863, 13, 407, 586, 291, 1223, 437, 341, 1355, 13, 400, 586, 718, 311, 751, 466, 40149, 257, 707, 857, 51184], "temperature": 0.0, "avg_logprob": -0.04839889662606375, "compression_ratio": 1.5103092783505154, "no_speech_prob": 0.013221465051174164}, {"id": 295, "seek": 272392, "start": 2740.32, "end": 2748.2400000000002, "text": " more. So there was one case just where I used the condition and then I have had to use parentheses.", "tokens": [51184, 544, 13, 407, 456, 390, 472, 1389, 445, 689, 286, 1143, 264, 4188, 293, 550, 286, 362, 632, 281, 764, 34153, 13, 51580], "temperature": 0.0, "avg_logprob": -0.04839889662606375, "compression_ratio": 1.5103092783505154, "no_speech_prob": 0.013221465051174164}, {"id": 296, "seek": 274824, "start": 2749.2, "end": 2759.8399999999997, "text": " But we can also explicitly group our match object here into different substrings. So for example,", "tokens": [50412, 583, 321, 393, 611, 20803, 1594, 527, 2995, 2657, 510, 666, 819, 4594, 25782, 13, 407, 337, 1365, 11, 50944], "temperature": 0.0, "avg_logprob": -0.13727215925852457, "compression_ratio": 1.3714285714285714, "no_speech_prob": 0.046025604009628296}, {"id": 297, "seek": 274824, "start": 2759.8399999999997, "end": 2773.2799999999997, "text": " I can put all of these before the ad sign into a group. So now let's use parentheses. And then", "tokens": [50944, 286, 393, 829, 439, 295, 613, 949, 264, 614, 1465, 666, 257, 1594, 13, 407, 586, 718, 311, 764, 34153, 13, 400, 550, 51616], "temperature": 0.0, "avg_logprob": -0.13727215925852457, "compression_ratio": 1.3714285714285714, "no_speech_prob": 0.046025604009628296}, {"id": 298, "seek": 277328, "start": 2773.44, "end": 2786.0800000000004, "text": " let's use the ad sign. And then let's use the domain name. So this is one group until the dot.", "tokens": [50372, 718, 311, 764, 264, 614, 1465, 13, 400, 550, 718, 311, 764, 264, 9274, 1315, 13, 407, 341, 307, 472, 1594, 1826, 264, 5893, 13, 51004], "temperature": 0.0, "avg_logprob": -0.11429787617103726, "compression_ratio": 1.6454545454545455, "no_speech_prob": 0.006796650588512421}, {"id": 299, "seek": 277328, "start": 2786.8, "end": 2798.0800000000004, "text": " And then we have one group to have the ending here. And now we have three groups here.", "tokens": [51040, 400, 550, 321, 362, 472, 1594, 281, 362, 264, 8121, 510, 13, 400, 586, 321, 362, 1045, 3935, 510, 13, 51604], "temperature": 0.0, "avg_logprob": -0.11429787617103726, "compression_ratio": 1.6454545454545455, "no_speech_prob": 0.006796650588512421}, {"id": 300, "seek": 279808, "start": 2798.56, "end": 2807.2, "text": " And as I showed you in the beginning, now if we run this, then this will give the same results.", "tokens": [50388, 400, 382, 286, 4712, 291, 294, 264, 2863, 11, 586, 498, 321, 1190, 341, 11, 550, 341, 486, 976, 264, 912, 3542, 13, 50820], "temperature": 0.0, "avg_logprob": -0.16132411441287478, "compression_ratio": 1.653179190751445, "no_speech_prob": 0.011157117784023285}, {"id": 301, "seek": 279808, "start": 2807.2, "end": 2818.24, "text": " And here we are printing the whole match object. And then we can use the dot group to return the", "tokens": [50820, 400, 510, 321, 366, 14699, 264, 1379, 2995, 2657, 13, 400, 550, 321, 393, 764, 264, 5893, 1594, 281, 2736, 264, 51372], "temperature": 0.0, "avg_logprob": -0.16132411441287478, "compression_ratio": 1.653179190751445, "no_speech_prob": 0.011157117784023285}, {"id": 302, "seek": 279808, "start": 2818.24, "end": 2826.56, "text": " actual string. And this is by default, this is group zero. So this is the whole match string.", "tokens": [51372, 3539, 6798, 13, 400, 341, 307, 538, 7576, 11, 341, 307, 1594, 4018, 13, 407, 341, 307, 264, 1379, 2995, 6798, 13, 51788], "temperature": 0.0, "avg_logprob": -0.16132411441287478, "compression_ratio": 1.653179190751445, "no_speech_prob": 0.011157117784023285}, {"id": 303, "seek": 282656, "start": 2826.64, "end": 2836.48, "text": " But now we can also print the single groups that we just defined. So for example, we have group one,", "tokens": [50368, 583, 586, 321, 393, 611, 4482, 264, 2167, 3935, 300, 321, 445, 7642, 13, 407, 337, 1365, 11, 321, 362, 1594, 472, 11, 50860], "temperature": 0.0, "avg_logprob": -0.13737230715544327, "compression_ratio": 1.5909090909090908, "no_speech_prob": 0.014954406768083572}, {"id": 304, "seek": 282656, "start": 2836.48, "end": 2843.6, "text": " two and three now. And now if we run this and print this, then we see,", "tokens": [50860, 732, 293, 1045, 586, 13, 400, 586, 498, 321, 1190, 341, 293, 4482, 341, 11, 550, 321, 536, 11, 51216], "temperature": 0.0, "avg_logprob": -0.13737230715544327, "compression_ratio": 1.5909090909090908, "no_speech_prob": 0.014954406768083572}, {"id": 305, "seek": 282656, "start": 2845.7599999999998, "end": 2853.12, "text": " let's just print the group one for now. Here, let's comment this out too.", "tokens": [51324, 718, 311, 445, 4482, 264, 1594, 472, 337, 586, 13, 1692, 11, 718, 311, 2871, 341, 484, 886, 13, 51692], "temperature": 0.0, "avg_logprob": -0.13737230715544327, "compression_ratio": 1.5909090909090908, "no_speech_prob": 0.014954406768083572}, {"id": 306, "seek": 285312, "start": 2853.8399999999997, "end": 2863.44, "text": " Then we see it only prints this group here. So only the name of the email before the ad sign.", "tokens": [50400, 1396, 321, 536, 309, 787, 22305, 341, 1594, 510, 13, 407, 787, 264, 1315, 295, 264, 3796, 949, 264, 614, 1465, 13, 50880], "temperature": 0.0, "avg_logprob": -0.1006223269871303, "compression_ratio": 1.7039473684210527, "no_speech_prob": 0.016399884596467018}, {"id": 307, "seek": 285312, "start": 2863.44, "end": 2869.7599999999998, "text": " Then here this is the second group. So now if we print the group two, then this is", "tokens": [50880, 1396, 510, 341, 307, 264, 1150, 1594, 13, 407, 586, 498, 321, 4482, 264, 1594, 732, 11, 550, 341, 307, 51196], "temperature": 0.0, "avg_logprob": -0.1006223269871303, "compression_ratio": 1.7039473684210527, "no_speech_prob": 0.016399884596467018}, {"id": 308, "seek": 285312, "start": 2870.72, "end": 2878.08, "text": " the domain name. And if we want to have the ending, then we can print group three.", "tokens": [51244, 264, 9274, 1315, 13, 400, 498, 321, 528, 281, 362, 264, 8121, 11, 550, 321, 393, 4482, 1594, 1045, 13, 51612], "temperature": 0.0, "avg_logprob": -0.1006223269871303, "compression_ratio": 1.7039473684210527, "no_speech_prob": 0.016399884596467018}, {"id": 309, "seek": 287808, "start": 2878.64, "end": 2886.88, "text": " So this is where grouping is useful. If we only want to have a look at specific things in our", "tokens": [50392, 407, 341, 307, 689, 40149, 307, 4420, 13, 759, 321, 787, 528, 281, 362, 257, 574, 412, 2685, 721, 294, 527, 50804], "temperature": 0.0, "avg_logprob": -0.08952809051728584, "compression_ratio": 1.5574712643678161, "no_speech_prob": 0.03113551251590252}, {"id": 310, "seek": 287808, "start": 2886.88, "end": 2896.0, "text": " match, then we can use parentheses. Now let's move on. So now let's see, we talked about grouping.", "tokens": [50804, 2995, 11, 550, 321, 393, 764, 34153, 13, 823, 718, 311, 1286, 322, 13, 407, 586, 718, 311, 536, 11, 321, 2825, 466, 40149, 13, 51260], "temperature": 0.0, "avg_logprob": -0.08952809051728584, "compression_ratio": 1.5574712643678161, "no_speech_prob": 0.03113551251590252}, {"id": 311, "seek": 287808, "start": 2896.0, "end": 2905.52, "text": " Now let's talk about modifications. So we have two methods to modify a string.", "tokens": [51260, 823, 718, 311, 751, 466, 26881, 13, 407, 321, 362, 732, 7150, 281, 16927, 257, 6798, 13, 51736], "temperature": 0.0, "avg_logprob": -0.08952809051728584, "compression_ratio": 1.5574712643678161, "no_speech_prob": 0.03113551251590252}, {"id": 312, "seek": 290552, "start": 2906.16, "end": 2915.92, "text": " So we have the split method and we have the sub method. So let's talk about both of them.", "tokens": [50396, 407, 321, 362, 264, 7472, 3170, 293, 321, 362, 264, 1422, 3170, 13, 407, 718, 311, 751, 466, 1293, 295, 552, 13, 50884], "temperature": 0.0, "avg_logprob": -0.07971349309702389, "compression_ratio": 1.7724137931034483, "no_speech_prob": 0.020327571779489517}, {"id": 313, "seek": 290552, "start": 2915.92, "end": 2922.88, "text": " So the split method will split the string into a list and splits wherever our", "tokens": [50884, 407, 264, 7472, 3170, 486, 7472, 264, 6798, 666, 257, 1329, 293, 37741, 8660, 527, 51232], "temperature": 0.0, "avg_logprob": -0.07971349309702389, "compression_ratio": 1.7724137931034483, "no_speech_prob": 0.020327571779489517}, {"id": 314, "seek": 290552, "start": 2923.68, "end": 2930.72, "text": " regular expression matches. And the sub method will find all substrings where the regular", "tokens": [51272, 3890, 6114, 10676, 13, 400, 264, 1422, 3170, 486, 915, 439, 4594, 25782, 689, 264, 3890, 51624], "temperature": 0.0, "avg_logprob": -0.07971349309702389, "compression_ratio": 1.7724137931034483, "no_speech_prob": 0.020327571779489517}, {"id": 315, "seek": 293072, "start": 2930.72, "end": 2938.08, "text": " expression matches and replaces them with a different string. So let's look at two examples.", "tokens": [50364, 6114, 10676, 293, 46734, 552, 365, 257, 819, 6798, 13, 407, 718, 311, 574, 412, 732, 5110, 13, 50732], "temperature": 0.0, "avg_logprob": -0.060735095630992546, "compression_ratio": 1.3728813559322033, "no_speech_prob": 0.012052105739712715}, {"id": 316, "seek": 293072, "start": 2938.72, "end": 2947.9199999999996, "text": " So let's say, let me grab a string here. So let's use this one again.", "tokens": [50764, 407, 718, 311, 584, 11, 718, 385, 4444, 257, 6798, 510, 13, 407, 718, 311, 764, 341, 472, 797, 13, 51224], "temperature": 0.0, "avg_logprob": -0.060735095630992546, "compression_ratio": 1.3728813559322033, "no_speech_prob": 0.012052105739712715}, {"id": 317, "seek": 294792, "start": 2948.64, "end": 2959.52, "text": " So this is our test string. And now we use the pattern equals our e.compile and then we are", "tokens": [50400, 407, 341, 307, 527, 1500, 6798, 13, 400, 586, 321, 764, 264, 5102, 6915, 527, 308, 13, 21541, 794, 293, 550, 321, 366, 50944], "temperature": 0.0, "avg_logprob": -0.21754208632877894, "compression_ratio": 1.3426573426573427, "no_speech_prob": 0.20429791510105133}, {"id": 318, "seek": 294792, "start": 2959.52, "end": 2973.12, "text": " looking for the raw string 123. Sorry, let's use a different one. Do I have it here? No, let's write", "tokens": [50944, 1237, 337, 264, 8936, 6798, 34466, 13, 4919, 11, 718, 311, 764, 257, 819, 472, 13, 1144, 286, 362, 309, 510, 30, 883, 11, 718, 311, 2464, 51624], "temperature": 0.0, "avg_logprob": -0.21754208632877894, "compression_ratio": 1.3426573426573427, "no_speech_prob": 0.20429791510105133}, {"id": 319, "seek": 297312, "start": 2974.08, "end": 2989.8399999999997, "text": " it myself. So let's say abc123abcdef and capital letters again 123 and abc. And now let's say", "tokens": [50412, 309, 2059, 13, 407, 718, 311, 584, 410, 66, 4762, 18, 455, 66, 20595, 293, 4238, 7825, 797, 34466, 293, 410, 66, 13, 400, 586, 718, 311, 584, 51200], "temperature": 0.0, "avg_logprob": -0.21317724595990098, "compression_ratio": 1.5039370078740157, "no_speech_prob": 0.07918442040681839}, {"id": 320, "seek": 297312, "start": 2989.8399999999997, "end": 3001.44, "text": " this is our pattern. So 123. And now we say our split it equals and then we say pattern dot split", "tokens": [51200, 341, 307, 527, 5102, 13, 407, 34466, 13, 400, 586, 321, 584, 527, 7472, 309, 6915, 293, 550, 321, 584, 5102, 5893, 7472, 51780], "temperature": 0.0, "avg_logprob": -0.21317724595990098, "compression_ratio": 1.5039370078740157, "no_speech_prob": 0.07918442040681839}, {"id": 321, "seek": 300144, "start": 3002.16, "end": 3010.64, "text": " and give the test string as argument. And now let's print this split it. Now this will be a list", "tokens": [50400, 293, 976, 264, 1500, 6798, 382, 6770, 13, 400, 586, 718, 311, 4482, 341, 7472, 309, 13, 823, 341, 486, 312, 257, 1329, 50824], "temperature": 0.0, "avg_logprob": -0.12309451688799941, "compression_ratio": 1.4275362318840579, "no_speech_prob": 0.021283123642206192}, {"id": 322, "seek": 300144, "start": 3012.56, "end": 3024.16, "text": " where our string split it. Oh, sorry, this was a bad example. So let's use abc as split. And then we", "tokens": [50920, 689, 527, 6798, 7472, 309, 13, 876, 11, 2597, 11, 341, 390, 257, 1578, 1365, 13, 407, 718, 311, 764, 410, 66, 382, 7472, 13, 400, 550, 321, 51500], "temperature": 0.0, "avg_logprob": -0.12309451688799941, "compression_ratio": 1.4275362318840579, "no_speech_prob": 0.021283123642206192}, {"id": 323, "seek": 302416, "start": 3024.16, "end": 3034.7999999999997, "text": " have splits where it's split it our string into different substrings and use this pattern here", "tokens": [50364, 362, 37741, 689, 309, 311, 7472, 309, 527, 6798, 666, 819, 4594, 25782, 293, 764, 341, 5102, 510, 50896], "temperature": 0.0, "avg_logprob": -0.12088617324829101, "compression_ratio": 1.7454545454545454, "no_speech_prob": 0.048126470297575}, {"id": 324, "seek": 302416, "start": 3035.6, "end": 3046.0, "text": " as the split. So here as the matching split. So here it has abc. So it's split it our string into", "tokens": [50936, 382, 264, 7472, 13, 407, 510, 382, 264, 14324, 7472, 13, 407, 510, 309, 575, 410, 66, 13, 407, 309, 311, 7472, 309, 527, 6798, 666, 51456], "temperature": 0.0, "avg_logprob": -0.12088617324829101, "compression_ratio": 1.7454545454545454, "no_speech_prob": 0.048126470297575}, {"id": 325, "seek": 304600, "start": 3046.0, "end": 3055.84, "text": " this part. So there we have 123. And then this part. And then it found our pattern again abc.", "tokens": [50364, 341, 644, 13, 407, 456, 321, 362, 34466, 13, 400, 550, 341, 644, 13, 400, 550, 309, 1352, 527, 5102, 797, 410, 66, 13, 50856], "temperature": 0.0, "avg_logprob": -0.0840746058693415, "compression_ratio": 1.864516129032258, "no_speech_prob": 0.24212104082107544}, {"id": 326, "seek": 304600, "start": 3057.44, "end": 3063.68, "text": " And then again, it's split it the string. And then at the end, we have the rest of the string. So", "tokens": [50936, 400, 550, 797, 11, 309, 311, 7472, 309, 264, 6798, 13, 400, 550, 412, 264, 917, 11, 321, 362, 264, 1472, 295, 264, 6798, 13, 407, 51248], "temperature": 0.0, "avg_logprob": -0.0840746058693415, "compression_ratio": 1.864516129032258, "no_speech_prob": 0.24212104082107544}, {"id": 327, "seek": 304600, "start": 3063.68, "end": 3071.92, "text": " this is the third substring that it found and and returned with this split method. So this is the", "tokens": [51248, 341, 307, 264, 2636, 4594, 2937, 300, 309, 1352, 293, 293, 8752, 365, 341, 7472, 3170, 13, 407, 341, 307, 264, 51660], "temperature": 0.0, "avg_logprob": -0.0840746058693415, "compression_ratio": 1.864516129032258, "no_speech_prob": 0.24212104082107544}, {"id": 328, "seek": 307192, "start": 3072.0, "end": 3082.48, "text": " split method. And now the sub method with the sub method, we find all the substrings where our", "tokens": [50368, 7472, 3170, 13, 400, 586, 264, 1422, 3170, 365, 264, 1422, 3170, 11, 321, 915, 439, 264, 4594, 25782, 689, 527, 50892], "temperature": 0.0, "avg_logprob": -0.07790973981221518, "compression_ratio": 1.5, "no_speech_prob": 0.012239834293723106}, {"id": 329, "seek": 307192, "start": 3082.48, "end": 3091.44, "text": " pattern matches and then replace them with a different string. So let's say our test string", "tokens": [50892, 5102, 10676, 293, 550, 7406, 552, 365, 257, 819, 6798, 13, 407, 718, 311, 584, 527, 1500, 6798, 51340], "temperature": 0.0, "avg_logprob": -0.07790973981221518, "compression_ratio": 1.5, "no_speech_prob": 0.012239834293723106}, {"id": 330, "seek": 309144, "start": 3091.44, "end": 3104.64, "text": " equals hello world. And then let's say you are the best world. And use the so we use the word", "tokens": [50364, 6915, 7751, 1002, 13, 400, 550, 718, 311, 584, 291, 366, 264, 1151, 1002, 13, 400, 764, 264, 370, 321, 764, 264, 1349, 51024], "temperature": 0.0, "avg_logprob": -0.14800853912646955, "compression_ratio": 1.6495726495726495, "no_speech_prob": 0.25963523983955383}, {"id": 331, "seek": 309144, "start": 3104.64, "end": 3114.96, "text": " world two times. And then let's say we want to look for the pattern world. So we say pattern equals", "tokens": [51024, 1002, 732, 1413, 13, 400, 550, 718, 311, 584, 321, 528, 281, 574, 337, 264, 5102, 1002, 13, 407, 321, 584, 5102, 6915, 51540], "temperature": 0.0, "avg_logprob": -0.14800853912646955, "compression_ratio": 1.6495726495726495, "no_speech_prob": 0.25963523983955383}, {"id": 332, "seek": 311496, "start": 3114.96, "end": 3127.68, "text": " re.compile. And then an R raw string. And here we have world. And then we say our sub string", "tokens": [50364, 319, 13, 21541, 794, 13, 400, 550, 364, 497, 8936, 6798, 13, 400, 510, 321, 362, 1002, 13, 400, 550, 321, 584, 527, 1422, 6798, 51000], "temperature": 0.0, "avg_logprob": -0.179658571879069, "compression_ratio": 1.4754098360655739, "no_speech_prob": 0.07583373039960861}, {"id": 333, "seek": 311496, "start": 3128.32, "end": 3138.16, "text": " equals and then we use pattern dot sub. And then what we want to put in as replacement,", "tokens": [51032, 6915, 293, 550, 321, 764, 5102, 5893, 1422, 13, 400, 550, 437, 321, 528, 281, 829, 294, 382, 14419, 11, 51524], "temperature": 0.0, "avg_logprob": -0.179658571879069, "compression_ratio": 1.4754098360655739, "no_speech_prob": 0.07583373039960861}, {"id": 334, "seek": 313816, "start": 3138.7999999999997, "end": 3145.52, "text": " let's say we want to put in planet. And we also have to put in the test string.", "tokens": [50396, 718, 311, 584, 321, 528, 281, 829, 294, 5054, 13, 400, 321, 611, 362, 281, 829, 294, 264, 1500, 6798, 13, 50732], "temperature": 0.0, "avg_logprob": -0.09411116500399005, "compression_ratio": 1.6071428571428572, "no_speech_prob": 0.054986994713544846}, {"id": 335, "seek": 313816, "start": 3146.24, "end": 3156.72, "text": " Now it took our test string, looked for all the matches where pattern matches. So it looked for", "tokens": [50768, 823, 309, 1890, 527, 1500, 6798, 11, 2956, 337, 439, 264, 10676, 689, 5102, 10676, 13, 407, 309, 2956, 337, 51292], "temperature": 0.0, "avg_logprob": -0.09411116500399005, "compression_ratio": 1.6071428571428572, "no_speech_prob": 0.054986994713544846}, {"id": 336, "seek": 313816, "start": 3156.72, "end": 3164.8799999999997, "text": " world and replaced them with planet. So now this will return another string that was modified.", "tokens": [51292, 1002, 293, 10772, 552, 365, 5054, 13, 407, 586, 341, 486, 2736, 1071, 6798, 300, 390, 15873, 13, 51700], "temperature": 0.0, "avg_logprob": -0.09411116500399005, "compression_ratio": 1.6071428571428572, "no_speech_prob": 0.054986994713544846}, {"id": 337, "seek": 316488, "start": 3164.88, "end": 3173.36, "text": " And now if we print this, then we see it printed hello planet, you are the best planet. So this", "tokens": [50364, 400, 586, 498, 321, 4482, 341, 11, 550, 321, 536, 309, 13567, 7751, 5054, 11, 291, 366, 264, 1151, 5054, 13, 407, 341, 50788], "temperature": 0.0, "avg_logprob": -0.09292300866574657, "compression_ratio": 1.3834586466165413, "no_speech_prob": 0.04333645850419998}, {"id": 338, "seek": 316488, "start": 3173.36, "end": 3185.12, "text": " is the sub method. And now let's do another example to combine all that we have learned.", "tokens": [50788, 307, 264, 1422, 3170, 13, 400, 586, 718, 311, 360, 1071, 1365, 281, 10432, 439, 300, 321, 362, 3264, 13, 51376], "temperature": 0.0, "avg_logprob": -0.09292300866574657, "compression_ratio": 1.3834586466165413, "no_speech_prob": 0.04333645850419998}, {"id": 339, "seek": 318512, "start": 3186.0, "end": 3192.24, "text": " And again, use the sub method. And yeah, so let's do this. So", "tokens": [50408, 400, 797, 11, 764, 264, 1422, 3170, 13, 400, 1338, 11, 370, 718, 311, 360, 341, 13, 407, 50720], "temperature": 0.0, "avg_logprob": -0.11730475425720215, "compression_ratio": 1.382608695652174, "no_speech_prob": 0.1870901733636856}, {"id": 340, "seek": 318512, "start": 3194.64, "end": 3203.7599999999998, "text": " so let me grab this string here. So this is our URL strings. So here we have, again, let's say we", "tokens": [50840, 370, 718, 385, 4444, 341, 6798, 510, 13, 407, 341, 307, 527, 12905, 13985, 13, 407, 510, 321, 362, 11, 797, 11, 718, 311, 584, 321, 51296], "temperature": 0.0, "avg_logprob": -0.11730475425720215, "compression_ratio": 1.382608695652174, "no_speech_prob": 0.1870901733636856}, {"id": 341, "seek": 320376, "start": 3203.76, "end": 3216.2400000000002, "text": " have different things here. And then we are only looking for URLs, but they may have different", "tokens": [50364, 362, 819, 721, 510, 13, 400, 550, 321, 366, 787, 1237, 337, 43267, 11, 457, 436, 815, 362, 819, 50988], "temperature": 0.0, "avg_logprob": -0.12209370613098144, "compression_ratio": 1.449612403100775, "no_speech_prob": 0.0939938947558403}, {"id": 342, "seek": 320376, "start": 3216.2400000000002, "end": 3229.6000000000004, "text": " formats. So for example, we have an HTTP URL, an HTTPS URL. And then sometimes we have a www", "tokens": [50988, 25879, 13, 407, 337, 1365, 11, 321, 362, 364, 33283, 12905, 11, 364, 11751, 51, 6273, 12905, 13, 400, 550, 2171, 321, 362, 257, 12520, 51656], "temperature": 0.0, "avg_logprob": -0.12209370613098144, "compression_ratio": 1.449612403100775, "no_speech_prob": 0.0939938947558403}, {"id": 343, "seek": 322960, "start": 3230.24, "end": 3239.44, "text": " and sometimes we don't have this. And then we have the typical domain name and ending.", "tokens": [50396, 293, 2171, 321, 500, 380, 362, 341, 13, 400, 550, 321, 362, 264, 7476, 9274, 1315, 293, 8121, 13, 50856], "temperature": 0.0, "avg_logprob": -0.1472932591157801, "compression_ratio": 1.4242424242424243, "no_speech_prob": 0.09133895486593246}, {"id": 344, "seek": 322960, "start": 3240.48, "end": 3251.52, "text": " So yeah, so let's extract this. So let's build up our pattern again. So pattern equals re.compile and", "tokens": [50908, 407, 1338, 11, 370, 718, 311, 8947, 341, 13, 407, 718, 311, 1322, 493, 527, 5102, 797, 13, 407, 5102, 6915, 319, 13, 21541, 794, 293, 51460], "temperature": 0.0, "avg_logprob": -0.1472932591157801, "compression_ratio": 1.4242424242424243, "no_speech_prob": 0.09133895486593246}, {"id": 345, "seek": 325152, "start": 3251.52, "end": 3263.44, "text": " then a raw string. So now let's start by saying it starts with HTTP. And then a colon and two slashes.", "tokens": [50364, 550, 257, 8936, 6798, 13, 407, 586, 718, 311, 722, 538, 1566, 309, 3719, 365, 33283, 13, 400, 550, 257, 8255, 293, 732, 1061, 12808, 13, 50960], "temperature": 0.0, "avg_logprob": -0.13078007608089806, "compression_ratio": 1.5294117647058822, "no_speech_prob": 0.22256457805633545}, {"id": 346, "seek": 325152, "start": 3264.32, "end": 3278.16, "text": " And then we have www and then we have a dot. So an actual dot. And then we have", "tokens": [51004, 400, 550, 321, 362, 12520, 293, 550, 321, 362, 257, 5893, 13, 407, 364, 3539, 5893, 13, 400, 550, 321, 362, 51696], "temperature": 0.0, "avg_logprob": -0.13078007608089806, "compression_ratio": 1.5294117647058822, "no_speech_prob": 0.22256457805633545}, {"id": 347, "seek": 327816, "start": 3278.72, "end": 3293.92, "text": " one or more word characters. So for example, we can use a set here again and use a to c and", "tokens": [50392, 472, 420, 544, 1349, 4342, 13, 407, 337, 1365, 11, 321, 393, 764, 257, 992, 510, 797, 293, 764, 257, 281, 269, 293, 51152], "temperature": 0.0, "avg_logprob": -0.20809489709359627, "compression_ratio": 1.1375, "no_speech_prob": 0.046700313687324524}, {"id": 348, "seek": 329392, "start": 3293.92, "end": 3306.48, "text": " uppercase a to c and also a dash here. So like here. And so then we have a plus. So one or more.", "tokens": [50364, 11775, 2869, 651, 257, 281, 269, 293, 611, 257, 8240, 510, 13, 407, 411, 510, 13, 400, 370, 550, 321, 362, 257, 1804, 13, 407, 472, 420, 544, 13, 50992], "temperature": 0.0, "avg_logprob": -0.09168884970925072, "compression_ratio": 1.4251968503937007, "no_speech_prob": 0.15809190273284912}, {"id": 349, "seek": 329392, "start": 3307.52, "end": 3316.8, "text": " And let's put this into a group here right away. So this will return the same thing.", "tokens": [51044, 400, 718, 311, 829, 341, 666, 257, 1594, 510, 558, 1314, 13, 407, 341, 486, 2736, 264, 912, 551, 13, 51508], "temperature": 0.0, "avg_logprob": -0.09168884970925072, "compression_ratio": 1.4251968503937007, "no_speech_prob": 0.15809190273284912}, {"id": 350, "seek": 331680, "start": 3317.52, "end": 3327.1200000000003, "text": " And then we can later use this group here. And the next thing we again have a dot. So", "tokens": [50400, 400, 550, 321, 393, 1780, 764, 341, 1594, 510, 13, 400, 264, 958, 551, 321, 797, 362, 257, 5893, 13, 407, 50880], "temperature": 0.0, "avg_logprob": -0.11397076588050992, "compression_ratio": 1.4224137931034482, "no_speech_prob": 0.20935751497745514}, {"id": 351, "seek": 331680, "start": 3327.1200000000003, "end": 3337.84, "text": " backslash dot. And then again, we can use a set here a to c and capital A to C.", "tokens": [50880, 646, 10418, 1299, 5893, 13, 400, 550, 797, 11, 321, 393, 764, 257, 992, 510, 257, 281, 269, 293, 4238, 316, 281, 383, 13, 51416], "temperature": 0.0, "avg_logprob": -0.11397076588050992, "compression_ratio": 1.4224137931034482, "no_speech_prob": 0.20935751497745514}, {"id": 352, "seek": 333784, "start": 3338.8, "end": 3349.1200000000003, "text": " And now let's try this out. So let's say matches equals pattern dot find iter.", "tokens": [50412, 400, 586, 718, 311, 853, 341, 484, 13, 407, 718, 311, 584, 10676, 6915, 5102, 5893, 915, 17138, 13, 50928], "temperature": 0.0, "avg_logprob": -0.1800960922241211, "compression_ratio": 1.4583333333333333, "no_speech_prob": 0.25374168157577515}, {"id": 353, "seek": 333784, "start": 3349.84, "end": 3362.1600000000003, "text": " And then we call this urls. And then for match in matches, we want to print the match. And let's", "tokens": [50964, 400, 550, 321, 818, 341, 4038, 11784, 13, 400, 550, 337, 2995, 294, 10676, 11, 321, 528, 281, 4482, 264, 2995, 13, 400, 718, 311, 51580], "temperature": 0.0, "avg_logprob": -0.1800960922241211, "compression_ratio": 1.4583333333333333, "no_speech_prob": 0.25374168157577515}, {"id": 354, "seek": 336216, "start": 3362.24, "end": 3370.0, "text": " try this and run this. And then we see we made some mistakes here. And this is because here I", "tokens": [50368, 853, 341, 293, 1190, 341, 13, 400, 550, 321, 536, 321, 1027, 512, 8038, 510, 13, 400, 341, 307, 570, 510, 286, 50756], "temperature": 0.0, "avg_logprob": -0.09710863309028821, "compression_ratio": 1.6184971098265897, "no_speech_prob": 0.26573994755744934}, {"id": 355, "seek": 336216, "start": 3370.0, "end": 3380.7999999999997, "text": " have to say plus, of course, so one or more. And now it only found this URL, because it didn't", "tokens": [50756, 362, 281, 584, 1804, 11, 295, 1164, 11, 370, 472, 420, 544, 13, 400, 586, 309, 787, 1352, 341, 12905, 11, 570, 309, 994, 380, 51296], "temperature": 0.0, "avg_logprob": -0.09710863309028821, "compression_ratio": 1.6184971098265897, "no_speech_prob": 0.26573994755744934}, {"id": 356, "seek": 336216, "start": 3380.7999999999997, "end": 3390.96, "text": " find this one because we have HTTPS here. And this one doesn't have www. So the first thing", "tokens": [51296, 915, 341, 472, 570, 321, 362, 11751, 51, 6273, 510, 13, 400, 341, 472, 1177, 380, 362, 12520, 13, 407, 264, 700, 551, 51804], "temperature": 0.0, "avg_logprob": -0.09710863309028821, "compression_ratio": 1.6184971098265897, "no_speech_prob": 0.26573994755744934}, {"id": 357, "seek": 339096, "start": 3390.96, "end": 3398.64, "text": " we can do here is to use an s. And this is an optional s. So remember s question mark. So this", "tokens": [50364, 321, 393, 360, 510, 307, 281, 764, 364, 262, 13, 400, 341, 307, 364, 17312, 262, 13, 407, 1604, 262, 1168, 1491, 13, 407, 341, 50748], "temperature": 0.0, "avg_logprob": -0.09431085468810281, "compression_ratio": 1.574585635359116, "no_speech_prob": 0.04601551964879036}, {"id": 358, "seek": 339096, "start": 3399.84, "end": 3406.96, "text": " is optional then. And if we don't put this into a group, then the question mark will only refer", "tokens": [50808, 307, 17312, 550, 13, 400, 498, 321, 500, 380, 829, 341, 666, 257, 1594, 11, 550, 264, 1168, 1491, 486, 787, 2864, 51164], "temperature": 0.0, "avg_logprob": -0.09431085468810281, "compression_ratio": 1.574585635359116, "no_speech_prob": 0.04601551964879036}, {"id": 359, "seek": 339096, "start": 3406.96, "end": 3416.48, "text": " to this character here. So now let's try this out. And now we see it also found the HTTPS URL.", "tokens": [51164, 281, 341, 2517, 510, 13, 407, 586, 718, 311, 853, 341, 484, 13, 400, 586, 321, 536, 309, 611, 1352, 264, 11751, 51, 6273, 12905, 13, 51640], "temperature": 0.0, "avg_logprob": -0.09431085468810281, "compression_ratio": 1.574585635359116, "no_speech_prob": 0.04601551964879036}, {"id": 360, "seek": 341648, "start": 3417.28, "end": 3426.32, "text": " And now the same thing with the www. So this may be there or may not be there. So again,", "tokens": [50404, 400, 586, 264, 912, 551, 365, 264, 12520, 13, 407, 341, 815, 312, 456, 420, 815, 406, 312, 456, 13, 407, 797, 11, 50856], "temperature": 0.0, "avg_logprob": -0.13033899508024516, "compression_ratio": 1.6094674556213018, "no_speech_prob": 0.0414532832801342}, {"id": 361, "seek": 341648, "start": 3426.32, "end": 3434.32, "text": " let's put this into a group. And then use an question mark to make this optional. And now if", "tokens": [50856, 718, 311, 829, 341, 666, 257, 1594, 13, 400, 550, 764, 364, 1168, 1491, 281, 652, 341, 17312, 13, 400, 586, 498, 51256], "temperature": 0.0, "avg_logprob": -0.13033899508024516, "compression_ratio": 1.6094674556213018, "no_speech_prob": 0.0414532832801342}, {"id": 362, "seek": 341648, "start": 3434.32, "end": 3442.56, "text": " you run this again, then it still doesn't find it. And this is because our it must be www.", "tokens": [51256, 291, 1190, 341, 797, 11, 550, 309, 920, 1177, 380, 915, 309, 13, 400, 341, 307, 570, 527, 309, 1633, 312, 12520, 13, 51668], "temperature": 0.0, "avg_logprob": -0.13033899508024516, "compression_ratio": 1.6094674556213018, "no_speech_prob": 0.0414532832801342}, {"id": 363, "seek": 344256, "start": 3442.56, "end": 3450.88, "text": " So backslash dot, which must be optional. And then I don't need it here anymore. So let's", "tokens": [50364, 407, 646, 10418, 1299, 5893, 11, 597, 1633, 312, 17312, 13, 400, 550, 286, 500, 380, 643, 309, 510, 3602, 13, 407, 718, 311, 50780], "temperature": 0.0, "avg_logprob": -0.08795063119185598, "compression_ratio": 1.567251461988304, "no_speech_prob": 0.008444830775260925}, {"id": 364, "seek": 344256, "start": 3450.88, "end": 3460.24, "text": " run this. And then we see that it found all of the URLs and extracted them. And now let's say", "tokens": [50780, 1190, 341, 13, 400, 550, 321, 536, 300, 309, 1352, 439, 295, 264, 43267, 293, 34086, 552, 13, 400, 586, 718, 311, 584, 51248], "temperature": 0.0, "avg_logprob": -0.08795063119185598, "compression_ratio": 1.567251461988304, "no_speech_prob": 0.008444830775260925}, {"id": 365, "seek": 344256, "start": 3460.24, "end": 3468.16, "text": " our string has only the URLs here. And now let's say we want to return a new string,", "tokens": [51248, 527, 6798, 575, 787, 264, 43267, 510, 13, 400, 586, 718, 311, 584, 321, 528, 281, 2736, 257, 777, 6798, 11, 51644], "temperature": 0.0, "avg_logprob": -0.08795063119185598, "compression_ratio": 1.567251461988304, "no_speech_prob": 0.008444830775260925}, {"id": 366, "seek": 346816, "start": 3468.7999999999997, "end": 3477.68, "text": " where we replaced all of these optional beginnings. So it should only print the actual domain name", "tokens": [50396, 689, 321, 10772, 439, 295, 613, 17312, 37281, 13, 407, 309, 820, 787, 4482, 264, 3539, 9274, 1315, 50840], "temperature": 0.0, "avg_logprob": -0.1034181935446603, "compression_ratio": 1.550561797752809, "no_speech_prob": 0.05261135846376419}, {"id": 367, "seek": 346816, "start": 3477.68, "end": 3486.08, "text": " with the ending. So as we have learned, we can use the sub method. So we can say,", "tokens": [50840, 365, 264, 8121, 13, 407, 382, 321, 362, 3264, 11, 321, 393, 764, 264, 1422, 3170, 13, 407, 321, 393, 584, 11, 51260], "temperature": 0.0, "avg_logprob": -0.1034181935446603, "compression_ratio": 1.550561797752809, "no_speech_prob": 0.05261135846376419}, {"id": 368, "seek": 346816, "start": 3488.08, "end": 3496.8799999999997, "text": " instead of just finding the matches, what we want to do here is let's also print this. And then", "tokens": [51360, 2602, 295, 445, 5006, 264, 10676, 11, 437, 321, 528, 281, 360, 510, 307, 718, 311, 611, 4482, 341, 13, 400, 550, 51800], "temperature": 0.0, "avg_logprob": -0.1034181935446603, "compression_ratio": 1.550561797752809, "no_speech_prob": 0.05261135846376419}, {"id": 369, "seek": 349688, "start": 3496.96, "end": 3507.84, "text": " let's say our sub URLs equals and then we use pattern and then sub. And then what we want to", "tokens": [50368, 718, 311, 584, 527, 1422, 43267, 6915, 293, 550, 321, 764, 5102, 293, 550, 1422, 13, 400, 550, 437, 321, 528, 281, 50912], "temperature": 0.0, "avg_logprob": -0.16657277649524166, "compression_ratio": 1.4210526315789473, "no_speech_prob": 0.006096957251429558}, {"id": 370, "seek": 349688, "start": 3507.84, "end": 3520.08, "text": " put in the replacement here. So for example, if we just say hello, and then URLs as a string and", "tokens": [50912, 829, 294, 264, 14419, 510, 13, 407, 337, 1365, 11, 498, 321, 445, 584, 7751, 11, 293, 550, 43267, 382, 257, 6798, 293, 51524], "temperature": 0.0, "avg_logprob": -0.16657277649524166, "compression_ratio": 1.4210526315789473, "no_speech_prob": 0.006096957251429558}, {"id": 371, "seek": 352008, "start": 3520.08, "end": 3534.88, "text": " then print the sub URLs. So then we see that this is the new string here. So it's replaced all of", "tokens": [50364, 550, 4482, 264, 1422, 43267, 13, 407, 550, 321, 536, 300, 341, 307, 264, 777, 6798, 510, 13, 407, 309, 311, 10772, 439, 295, 51104], "temperature": 0.0, "avg_logprob": -0.09554879170543742, "compression_ratio": 1.4296296296296296, "no_speech_prob": 0.028430268168449402}, {"id": 372, "seek": 352008, "start": 3534.88, "end": 3547.2, "text": " the matches with hello. And now let's say we only want to put this in our string and only this,", "tokens": [51104, 264, 10676, 365, 7751, 13, 400, 586, 718, 311, 584, 321, 787, 528, 281, 829, 341, 294, 527, 6798, 293, 787, 341, 11, 51720], "temperature": 0.0, "avg_logprob": -0.09554879170543742, "compression_ratio": 1.4296296296296296, "no_speech_prob": 0.028430268168449402}, {"id": 373, "seek": 354720, "start": 3547.9199999999996, "end": 3559.3599999999997, "text": " then what we can do here is we can group this and we already did this. So we have a group here,", "tokens": [50400, 550, 437, 321, 393, 360, 510, 307, 321, 393, 1594, 341, 293, 321, 1217, 630, 341, 13, 407, 321, 362, 257, 1594, 510, 11, 50972], "temperature": 0.0, "avg_logprob": -0.09504593543286594, "compression_ratio": 1.6403508771929824, "no_speech_prob": 0.04602055251598358}, {"id": 374, "seek": 354720, "start": 3559.3599999999997, "end": 3570.3199999999997, "text": " we have a group here. And let's also put this into our group into a group. And then what we", "tokens": [50972, 321, 362, 257, 1594, 510, 13, 400, 718, 311, 611, 829, 341, 666, 527, 1594, 666, 257, 1594, 13, 400, 550, 437, 321, 51520], "temperature": 0.0, "avg_logprob": -0.09504593543286594, "compression_ratio": 1.6403508771929824, "no_speech_prob": 0.04602055251598358}, {"id": 375, "seek": 357032, "start": 3570.32, "end": 3581.1200000000003, "text": " can do is we can use back references to replace them. So here we can say backslash two and", "tokens": [50364, 393, 360, 307, 321, 393, 764, 646, 15400, 281, 7406, 552, 13, 407, 510, 321, 393, 584, 646, 10418, 1299, 732, 293, 50904], "temperature": 0.0, "avg_logprob": -0.10625046270864981, "compression_ratio": 1.5982905982905984, "no_speech_prob": 0.0980588048696518}, {"id": 376, "seek": 357032, "start": 3583.36, "end": 3595.44, "text": " we must use a string so a raw string. And then we say backslash two and backslash three. And now", "tokens": [51016, 321, 1633, 764, 257, 6798, 370, 257, 8936, 6798, 13, 400, 550, 321, 584, 646, 10418, 1299, 732, 293, 646, 10418, 1299, 1045, 13, 400, 586, 51620], "temperature": 0.0, "avg_logprob": -0.10625046270864981, "compression_ratio": 1.5982905982905984, "no_speech_prob": 0.0980588048696518}, {"id": 377, "seek": 359544, "start": 3595.44, "end": 3605.52, "text": " if we run this, then this is our new string. So if I comment this out, then we see, then this is our", "tokens": [50364, 498, 321, 1190, 341, 11, 550, 341, 307, 527, 777, 6798, 13, 407, 498, 286, 2871, 341, 484, 11, 550, 321, 536, 11, 550, 341, 307, 527, 50868], "temperature": 0.0, "avg_logprob": -0.08751157522201539, "compression_ratio": 1.688622754491018, "no_speech_prob": 0.03258517384529114}, {"id": 378, "seek": 359544, "start": 3605.52, "end": 3614.7200000000003, "text": " new string. And what happened here, again, if we have a look at the group, so we can say,", "tokens": [50868, 777, 6798, 13, 400, 437, 2011, 510, 11, 797, 11, 498, 321, 362, 257, 574, 412, 264, 1594, 11, 370, 321, 393, 584, 11, 51328], "temperature": 0.0, "avg_logprob": -0.08751157522201539, "compression_ratio": 1.688622754491018, "no_speech_prob": 0.03258517384529114}, {"id": 379, "seek": 359544, "start": 3615.36, "end": 3622.8, "text": " let's print all the different groups. So we have match dot group. So this will be the whole", "tokens": [51360, 718, 311, 4482, 439, 264, 819, 3935, 13, 407, 321, 362, 2995, 5893, 1594, 13, 407, 341, 486, 312, 264, 1379, 51732], "temperature": 0.0, "avg_logprob": -0.08751157522201539, "compression_ratio": 1.688622754491018, "no_speech_prob": 0.03258517384529114}, {"id": 380, "seek": 362280, "start": 3623.6000000000004, "end": 3634.1600000000003, "text": " string. And now, so this is group zero again. Now let's have a look at what is group one.", "tokens": [50404, 6798, 13, 400, 586, 11, 370, 341, 307, 1594, 4018, 797, 13, 823, 718, 311, 362, 257, 574, 412, 437, 307, 1594, 472, 13, 50932], "temperature": 0.0, "avg_logprob": -0.15111697637117827, "compression_ratio": 1.4122137404580153, "no_speech_prob": 0.01565726101398468}, {"id": 381, "seek": 362280, "start": 3634.7200000000003, "end": 3645.6000000000004, "text": " So for example, here, this is the group one, the first one in parentheses. And because this may", "tokens": [50960, 407, 337, 1365, 11, 510, 11, 341, 307, 264, 1594, 472, 11, 264, 700, 472, 294, 34153, 13, 400, 570, 341, 815, 51504], "temperature": 0.0, "avg_logprob": -0.15111697637117827, "compression_ratio": 1.4122137404580153, "no_speech_prob": 0.01565726101398468}, {"id": 382, "seek": 364560, "start": 3645.92, "end": 3655.2, "text": " optional, this may also be none. So the first URL has none as the first group because it doesn't", "tokens": [50380, 17312, 11, 341, 815, 611, 312, 6022, 13, 407, 264, 700, 12905, 575, 6022, 382, 264, 700, 1594, 570, 309, 1177, 380, 50844], "temperature": 0.0, "avg_logprob": -0.12863242184674298, "compression_ratio": 1.53125, "no_speech_prob": 0.37354910373687744}, {"id": 383, "seek": 364560, "start": 3655.2, "end": 3664.7999999999997, "text": " have w w w. And this is the first group. So now let's print the second group. So this is the actual", "tokens": [50844, 362, 261, 261, 261, 13, 400, 341, 307, 264, 700, 1594, 13, 407, 586, 718, 311, 4482, 264, 1150, 1594, 13, 407, 341, 307, 264, 3539, 51324], "temperature": 0.0, "avg_logprob": -0.12863242184674298, "compression_ratio": 1.53125, "no_speech_prob": 0.37354910373687744}, {"id": 384, "seek": 366480, "start": 3665.36, "end": 3673.04, "text": " name of the domain. So the beginning. And then the group three is the ending so dot com dot com", "tokens": [50392, 1315, 295, 264, 9274, 13, 407, 264, 2863, 13, 400, 550, 264, 1594, 1045, 307, 264, 8121, 370, 5893, 395, 5893, 395, 50776], "temperature": 0.0, "avg_logprob": -0.1423700719639875, "compression_ratio": 1.7222222222222223, "no_speech_prob": 0.4724701941013336}, {"id": 385, "seek": 366480, "start": 3673.04, "end": 3683.04, "text": " dot net. And now here we use this group two and group three with this back reference. And then", "tokens": [50776, 5893, 2533, 13, 400, 586, 510, 321, 764, 341, 1594, 732, 293, 1594, 1045, 365, 341, 646, 6408, 13, 400, 550, 51276], "temperature": 0.0, "avg_logprob": -0.1423700719639875, "compression_ratio": 1.7222222222222223, "no_speech_prob": 0.4724701941013336}, {"id": 386, "seek": 366480, "start": 3683.04, "end": 3690.32, "text": " replace the whole found pattern only with the domain name. So this is what happens here.", "tokens": [51276, 7406, 264, 1379, 1352, 5102, 787, 365, 264, 9274, 1315, 13, 407, 341, 307, 437, 2314, 510, 13, 51640], "temperature": 0.0, "avg_logprob": -0.1423700719639875, "compression_ratio": 1.7222222222222223, "no_speech_prob": 0.4724701941013336}, {"id": 387, "seek": 369032, "start": 3691.04, "end": 3698.32, "text": " And so this is also very often used in regular expressions. And now you know what this means.", "tokens": [50400, 400, 370, 341, 307, 611, 588, 2049, 1143, 294, 3890, 15277, 13, 400, 586, 291, 458, 437, 341, 1355, 13, 50764], "temperature": 0.0, "avg_logprob": -0.07199578966413225, "compression_ratio": 1.5297297297297296, "no_speech_prob": 0.05664006993174553}, {"id": 388, "seek": 369032, "start": 3699.6800000000003, "end": 3708.48, "text": " And I guess now we are almost through with all the context, all the things that I wanted to", "tokens": [50832, 400, 286, 2041, 586, 321, 366, 1920, 807, 365, 439, 264, 4319, 11, 439, 264, 721, 300, 286, 1415, 281, 51272], "temperature": 0.0, "avg_logprob": -0.07199578966413225, "compression_ratio": 1.5297297297297296, "no_speech_prob": 0.05664006993174553}, {"id": 389, "seek": 369032, "start": 3708.48, "end": 3718.32, "text": " show you. And now as a last thing, let's quickly talk about compilation flags. So when we compile", "tokens": [51272, 855, 291, 13, 400, 586, 382, 257, 1036, 551, 11, 718, 311, 2661, 751, 466, 40261, 23265, 13, 407, 562, 321, 31413, 51764], "temperature": 0.0, "avg_logprob": -0.07199578966413225, "compression_ratio": 1.5297297297297296, "no_speech_prob": 0.05664006993174553}, {"id": 390, "seek": 371832, "start": 3718.32, "end": 3727.28, "text": " the pattern, then we also have to option to use different compilation flags. So here I listed", "tokens": [50364, 264, 5102, 11, 550, 321, 611, 362, 281, 3614, 281, 764, 819, 40261, 23265, 13, 407, 510, 286, 10052, 50812], "temperature": 0.0, "avg_logprob": -0.1349890981401716, "compression_ratio": 1.5988372093023255, "no_speech_prob": 0.12936681509017944}, {"id": 391, "seek": 371832, "start": 3727.28, "end": 3732.96, "text": " them. And again, you don't have to remember them, just keep a cheat sheet. So here we have the", "tokens": [50812, 552, 13, 400, 797, 11, 291, 500, 380, 362, 281, 1604, 552, 11, 445, 1066, 257, 17470, 8193, 13, 407, 510, 321, 362, 264, 51096], "temperature": 0.0, "avg_logprob": -0.1349890981401716, "compression_ratio": 1.5988372093023255, "no_speech_prob": 0.12936681509017944}, {"id": 392, "seek": 371832, "start": 3732.96, "end": 3742.48, "text": " different compilation flags. So ASCII dot all ignore case local multi line or verbose.", "tokens": [51096, 819, 40261, 23265, 13, 407, 7469, 34, 9503, 5893, 439, 11200, 1389, 2654, 4825, 1622, 420, 9595, 541, 13, 51572], "temperature": 0.0, "avg_logprob": -0.1349890981401716, "compression_ratio": 1.5988372093023255, "no_speech_prob": 0.12936681509017944}, {"id": 393, "seek": 374248, "start": 3742.72, "end": 3749.52, "text": " So I recommend that you check out the official documentation to see what all of them mean", "tokens": [50376, 407, 286, 2748, 300, 291, 1520, 484, 264, 4783, 14333, 281, 536, 437, 439, 295, 552, 914, 50716], "temperature": 0.0, "avg_logprob": -0.17057251930236816, "compression_ratio": 1.521978021978022, "no_speech_prob": 0.0212856475263834}, {"id": 394, "seek": 374248, "start": 3749.52, "end": 3757.6, "text": " in detail. And now I just want to show you the ignore case compilation flag. So this is also a", "tokens": [50716, 294, 2607, 13, 400, 586, 286, 445, 528, 281, 855, 291, 264, 11200, 1389, 40261, 7166, 13, 407, 341, 307, 611, 257, 51120], "temperature": 0.0, "avg_logprob": -0.17057251930236816, "compression_ratio": 1.521978021978022, "no_speech_prob": 0.0212856475263834}, {"id": 395, "seek": 374248, "start": 3757.6, "end": 3771.6, "text": " very common use case. So let's say we have the string my string equals hello world. And then", "tokens": [51120, 588, 2689, 764, 1389, 13, 407, 718, 311, 584, 321, 362, 264, 6798, 452, 6798, 6915, 7751, 1002, 13, 400, 550, 51820], "temperature": 0.0, "avg_logprob": -0.17057251930236816, "compression_ratio": 1.521978021978022, "no_speech_prob": 0.0212856475263834}, {"id": 396, "seek": 377160, "start": 3772.56, "end": 3782.7999999999997, "text": " we want to look for the string world. And now if we compile this, and then try to find the matches", "tokens": [50412, 321, 528, 281, 574, 337, 264, 6798, 1002, 13, 400, 586, 498, 321, 31413, 341, 11, 293, 550, 853, 281, 915, 264, 10676, 50924], "temperature": 0.0, "avg_logprob": -0.13779558958830657, "compression_ratio": 1.4885496183206106, "no_speech_prob": 0.019715039059519768}, {"id": 397, "seek": 377160, "start": 3782.7999999999997, "end": 3794.3199999999997, "text": " and print them. So print the match. Now if you run this, sorry, this is called my string. Now if", "tokens": [50924, 293, 4482, 552, 13, 407, 4482, 264, 2995, 13, 823, 498, 291, 1190, 341, 11, 2597, 11, 341, 307, 1219, 452, 6798, 13, 823, 498, 51500], "temperature": 0.0, "avg_logprob": -0.13779558958830657, "compression_ratio": 1.4885496183206106, "no_speech_prob": 0.019715039059519768}, {"id": 398, "seek": 379432, "start": 3794.32, "end": 3802.6400000000003, "text": " we run this, then it doesn't find a string. So because remember, this is case sensitive. Now if", "tokens": [50364, 321, 1190, 341, 11, 550, 309, 1177, 380, 915, 257, 6798, 13, 407, 570, 1604, 11, 341, 307, 1389, 9477, 13, 823, 498, 50780], "temperature": 0.0, "avg_logprob": -0.1161546041799146, "compression_ratio": 1.5691489361702127, "no_speech_prob": 0.007120900321751833}, {"id": 399, "seek": 379432, "start": 3802.6400000000003, "end": 3812.4, "text": " you make a capital W, then it finds the match world. And let's say we don't know what our string is.", "tokens": [50780, 291, 652, 257, 4238, 343, 11, 550, 309, 10704, 264, 2995, 1002, 13, 400, 718, 311, 584, 321, 500, 380, 458, 437, 527, 6798, 307, 13, 51268], "temperature": 0.0, "avg_logprob": -0.1161546041799146, "compression_ratio": 1.5691489361702127, "no_speech_prob": 0.007120900321751833}, {"id": 400, "seek": 379432, "start": 3812.4, "end": 3819.04, "text": " So it may be uppercase, but it may not be uppercase. So it doesn't matter for us. Then we can just", "tokens": [51268, 407, 309, 815, 312, 11775, 2869, 651, 11, 457, 309, 815, 406, 312, 11775, 2869, 651, 13, 407, 309, 1177, 380, 1871, 337, 505, 13, 1396, 321, 393, 445, 51600], "temperature": 0.0, "avg_logprob": -0.1161546041799146, "compression_ratio": 1.5691489361702127, "no_speech_prob": 0.007120900321751833}, {"id": 401, "seek": 381904, "start": 3819.2, "end": 3829.6, "text": " use the compilation flag, our e dot ignore case. So we can write this out. So we can say ignore", "tokens": [50372, 764, 264, 40261, 7166, 11, 527, 308, 5893, 11200, 1389, 13, 407, 321, 393, 2464, 341, 484, 13, 407, 321, 393, 584, 11200, 50892], "temperature": 0.0, "avg_logprob": -0.2126330648149763, "compression_ratio": 1.5118110236220472, "no_speech_prob": 0.11119837313890457}, {"id": 402, "seek": 381904, "start": 3830.24, "end": 3844.88, "text": " case. Or we can just say our re dot I. And then if we use a small w, then it will still find the", "tokens": [50924, 1389, 13, 1610, 321, 393, 445, 584, 527, 319, 5893, 286, 13, 400, 550, 498, 321, 764, 257, 1359, 261, 11, 550, 309, 486, 920, 915, 264, 51656], "temperature": 0.0, "avg_logprob": -0.2126330648149763, "compression_ratio": 1.5118110236220472, "no_speech_prob": 0.11119837313890457}, {"id": 403, "seek": 384488, "start": 3844.88, "end": 3852.6400000000003, "text": " match. And because now it ignored the cases. So this is the ignore case compilation flag.", "tokens": [50364, 2995, 13, 400, 570, 586, 309, 19735, 264, 3331, 13, 407, 341, 307, 264, 11200, 1389, 40261, 7166, 13, 50752], "temperature": 0.0, "avg_logprob": -0.08123320624941871, "compression_ratio": 1.6872037914691944, "no_speech_prob": 0.1403018981218338}, {"id": 404, "seek": 384488, "start": 3852.6400000000003, "end": 3860.4, "text": " And now, yeah, you also have these compilation flags. So I recommend that you check them out", "tokens": [50752, 400, 586, 11, 1338, 11, 291, 611, 362, 613, 40261, 23265, 13, 407, 286, 2748, 300, 291, 1520, 552, 484, 51140], "temperature": 0.0, "avg_logprob": -0.08123320624941871, "compression_ratio": 1.6872037914691944, "no_speech_prob": 0.1403018981218338}, {"id": 405, "seek": 384488, "start": 3860.4, "end": 3866.8, "text": " for yourself. I will provide a link to the official documentation in the description.", "tokens": [51140, 337, 1803, 13, 286, 486, 2893, 257, 2113, 281, 264, 4783, 14333, 294, 264, 3855, 13, 51460], "temperature": 0.0, "avg_logprob": -0.08123320624941871, "compression_ratio": 1.6872037914691944, "no_speech_prob": 0.1403018981218338}, {"id": 406, "seek": 384488, "start": 3867.36, "end": 3873.92, "text": " And now I think we are done. And now you should be able to understand all the different", "tokens": [51488, 400, 586, 286, 519, 321, 366, 1096, 13, 400, 586, 291, 820, 312, 1075, 281, 1223, 439, 264, 819, 51816], "temperature": 0.0, "avg_logprob": -0.08123320624941871, "compression_ratio": 1.6872037914691944, "no_speech_prob": 0.1403018981218338}, {"id": 407, "seek": 387392, "start": 3873.92, "end": 3879.6800000000003, "text": " regular expressions. I hope it wasn't too complicated for you. And I hope you enjoyed", "tokens": [50364, 3890, 15277, 13, 286, 1454, 309, 2067, 380, 886, 6179, 337, 291, 13, 400, 286, 1454, 291, 4626, 50652], "temperature": 0.0, "avg_logprob": -0.14185109228458045, "compression_ratio": 1.4078947368421053, "no_speech_prob": 0.0979350358247757}, {"id": 408, "seek": 387392, "start": 3879.6800000000003, "end": 3884.4, "text": " this tutorial. If you like this, then please consider subscribing to the channel and leave", "tokens": [50652, 341, 7073, 13, 759, 291, 411, 341, 11, 550, 1767, 1949, 19981, 281, 264, 2269, 293, 1856, 50888], "temperature": 0.0, "avg_logprob": -0.14185109228458045, "compression_ratio": 1.4078947368421053, "no_speech_prob": 0.0979350358247757}, {"id": 409, "seek": 387392, "start": 3884.4, "end": 3887.04, "text": " me a like and see you next time. Bye.", "tokens": [50888, 385, 257, 411, 293, 536, 291, 958, 565, 13, 4621, 13, 51020], "temperature": 0.0, "avg_logprob": -0.14185109228458045, "compression_ratio": 1.4078947368421053, "no_speech_prob": 0.0979350358247757}], "language": "en"}