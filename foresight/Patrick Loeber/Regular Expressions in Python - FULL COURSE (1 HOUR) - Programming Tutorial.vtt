WEBVTT

00:00.000 --> 00:04.640
Hey guys, welcome to a new Python tutorial. Today I want to show you how we can work with

00:04.640 --> 00:11.600
regular expressions in Python. Regular expressions or short RE or REGX is a powerful method that is

00:11.600 --> 00:17.520
used to search for matching text patterns. For example, typical patterns that can be extracted

00:17.520 --> 00:24.000
from large text files with regular expressions are emails or domain names. So at the end of this

00:24.000 --> 00:30.720
tutorial, you will be able to understand what this regular expression here does. And there's a lot

00:30.720 --> 00:36.240
to cover in this tutorial. Don't be overwhelmed. I promise that once you have understood the concepts,

00:36.240 --> 00:42.160
it's not so hard anymore. And it can simplify and speed up your search tasks a lot. So if you

00:42.160 --> 00:46.960
watch the whole tutorial, then you will be able to understand any pattern that you want to look up.

00:47.840 --> 00:53.440
So now let me quickly show you what we will cover in this video. So of course,

00:53.440 --> 00:59.520
we will see how we work with the RE module in Python. Then I will show you what methods we

00:59.520 --> 01:06.320
have to search for matches, what we can do with a match object. Then we will talk about matter

01:06.320 --> 01:14.160
characters and more special sequences that can be used in patterns. Then we talk about sets,

01:14.160 --> 01:24.320
quantifiers, conditions, and then grouping, then modifications, so how we can modify strings with

01:24.320 --> 01:33.360
REs. And at the end, I show you some different compilation flags. So let's start. So as I already

01:33.360 --> 01:41.440
said, Python has a built in module that is called RE, which we can use to work with regular expressions.

01:41.440 --> 01:48.560
So we have to import RE. And then we can start working with regular expressions. So let me show

01:48.560 --> 01:57.440
you a very simple example first. So let's say here I have some test strings already. So let me copy

01:57.440 --> 02:04.960
and paste this here. So this is our test strings. And now let's say for example, we want to search

02:05.040 --> 02:14.000
for the pattern ABC. So we see we have this three times here. And now let's say we want to look

02:14.000 --> 02:22.400
for ABC, then we create a pattern. So let's say pattern equals and then we use the RE module

02:22.400 --> 02:31.360
and the compile method. And then here we say R and then the string ABC. So I will explain what

02:31.360 --> 02:40.000
R means in a second. And then we can use this pattern to find matches. So we say matches equals

02:40.800 --> 02:50.800
pattern dot find iter. And then we want to find the matches from the test string. And now this will

02:50.800 --> 03:01.760
be a object that we can iterate over. So we can say for match in matches. And then we simply print

03:01.760 --> 03:13.040
the match. So now let's run this. And then we see we have two matches. So this is a match object.

03:13.040 --> 03:19.520
And we can see more details. So for example, we can see the span. So this is the start

03:20.080 --> 03:29.360
and the end position. So this is three, four and five. And this is our match ABC and a second

03:29.360 --> 03:37.040
match at position 12. So this is position or index 12 in our string. So we see that we have

03:37.040 --> 03:44.720
two matches here. And what we also see here that our regular expression is case sensitive. So it

03:44.720 --> 03:54.400
doesn't include the uppercase ABC into our matches. So this is one thing that we must know. So one

03:54.400 --> 04:02.080
thing that I want to mention here is that instead of compiling our pattern explicitly, we can use

04:02.080 --> 04:12.320
the find iter method directly on the RE module. So we could also just write that our matches

04:13.120 --> 04:23.520
equals RE dot find iter. And then we want to look for our let's say string,

04:24.320 --> 04:35.040
our ABC, and then from our test string. So you can use it directly on the RE module. And then we

04:35.040 --> 04:43.040
will if we run this, we will see that we get the same results. So there is not much of a difference

04:43.040 --> 04:53.280
here. But I prefer to do it this way to explicitly compile them pattern and bind it to this object

04:53.360 --> 05:01.200
here. So this improves readability. And it's also a little bit more flexible. So I prefer it this

05:01.200 --> 05:10.320
way, but you should know that you can use both ways. And now let's talk about why I'm using this

05:10.320 --> 05:21.280
R here briefly. So this means that this is a raw string. So for example, if I have a string A,

05:22.080 --> 05:30.000
and this includes some special characters like a tap, so a backslash T that this is a tap or a

05:30.000 --> 05:40.000
backslash N for new line. And then I have a string. So now if I print this, then you will see that we

05:40.000 --> 05:48.240
have the tap here at the beginning. So it didn't print the backslash T. And in a pattern, I usually

05:48.240 --> 05:56.320
want to look for the actual characters in my pattern. So then I can write an R here. And then

05:56.320 --> 06:03.040
this means that this this is a raw string. So Python will print this the same way as it is

06:03.040 --> 06:10.800
specified here. And yeah, so I recommend to always use a raw string for your patterns, you can use

06:10.800 --> 06:18.480
just a normal string. But remember that you should use a raw string. And yeah, so this is a short

06:18.480 --> 06:24.800
example how a regular expression is used. So typically, we come up with our pattern, then we

06:24.800 --> 06:33.440
compile it. And then we use the pattern to find our matches. And I will show you the different

06:33.440 --> 06:42.240
methods that we have on the matches now. So now let's go over the methods to search for matches.

06:42.960 --> 06:52.160
So we already have seen the find iter method. And this will give us a match object. And I

06:52.160 --> 06:58.880
will show you what we can do with a match object in a second. So now let's talk about the other

06:58.880 --> 07:07.920
methods. So there are three other methods. So we can use the dot match method. So here dot match,

07:07.920 --> 07:21.120
then we have search. And then we also have find all. So now let's look about the find all method

07:21.120 --> 07:28.960
first. So if we can say pattern dot find all, then we will simply get the string. So if you see

07:28.960 --> 07:36.960
here, I'm printing the whole match object. So now if I want just a string, then I can use find all.

07:36.960 --> 07:42.560
And now if I run this, then it will just print the two strings that I'm looking for.

07:43.520 --> 07:53.520
So this is the find all method. Now the match method determines if the expression matches at

07:53.520 --> 08:04.240
the beginning of the string. So this will only return one match. So here I can say match equals

08:04.240 --> 08:16.240
pattern, and then match. And now if I print the match, so let's print the match and run this,

08:16.240 --> 08:23.120
then we will see this is none, because the match looks only for patterns at the beginning of our

08:23.120 --> 08:32.960
string. So ABC is not at the beginning. So now if I use 123 as a pattern, then we will see this is

08:34.240 --> 08:42.000
at the beginning. So this will return one match. And we also have the pattern here again. But again,

08:42.960 --> 08:50.240
the match does only return the first match if it is at the beginning of the string.

08:51.360 --> 08:59.280
And now we also have the search method. So the search method scans through the string

08:59.280 --> 09:08.000
and looks for any location where the RE matches. So if you use, for example, let's look for the match

09:08.560 --> 09:16.320
ABC again, then we will see this will return none because ABC has to be at the beginning.

09:16.320 --> 09:23.280
And now if we use this search method, then it will find the match object again, and

09:23.280 --> 09:34.160
it will simply return the first match. So we have search match find all and find iter. And this is my

09:34.160 --> 09:40.960
preferred method. So from now on, I will only use this one. And then we also have some

09:41.680 --> 09:51.040
functions that can be used to modify an object. So we also have split and sub. So I will come to them

09:51.040 --> 10:00.240
later. So now let's continue using the find iter method. And let's have a look at what we can do

10:00.240 --> 10:08.960
with the match object. So again, let's say our matches equals pattern, and then find iter.

10:09.600 --> 10:17.920
And then let's iterate over this. So for match in matches, and then we want to print the match.

10:18.880 --> 10:29.840
Then again, we see we have the whole match object here. And we can use four different methods on

10:29.840 --> 10:39.440
this. So we can use the group method, we can use the start and the end method. And we can get the

10:39.760 --> 10:52.480
span. So let's start with the span. So this will give me the start and the stop index, where this

10:52.480 --> 11:02.960
pattern is located. So let's print the match dot span. So then we simply get this as a tuple here.

11:03.920 --> 11:11.120
So we get three and six. So this is a tuple. And we can also get the

11:12.400 --> 11:23.680
just the start and the end right away by saying print match dot start and print match dot end.

11:23.680 --> 11:35.120
Oh, sorry, here is a dot match dot start. So then we get the start in the stop index. And now let's

11:35.120 --> 11:43.280
talk about the group method. So now if we call match dot group, then we will get or print the

11:44.160 --> 11:52.160
actual string of the match. And we can also give this group method arguments to find the group

11:52.160 --> 12:00.800
zero or one and or two. And we will talk about this grouping later. But for now on, if you

12:00.800 --> 12:08.080
just want the string then from the match, then just call match dot group or group zero. So this

12:08.080 --> 12:15.840
is the same. And yeah, so these are the four different methods that we can use on a match

12:15.840 --> 12:25.600
object. And now let's come to the matter characters. So in regular expressions,

12:25.600 --> 12:34.080
there are these method characters that have a special meaning. So these are all the method

12:34.080 --> 12:40.320
characters we must know. And you don't have to know them by heart. So I recommend that you

12:40.320 --> 12:46.640
keep a cheat sheet somewhere with all this stuff. And I will also provide a cheat sheet on

12:46.640 --> 12:52.880
my website. So you can check that out on Python minus engineer dot com. And this is all you need

12:52.880 --> 13:00.560
to know. So now let's talk about these method characters one by one. And then I will show

13:00.560 --> 13:09.040
you what this means. So the first one is the dot. So the dot means that we want to look for any

13:09.040 --> 13:15.760
character. So any character except a new line character, then the carrot means that we want

13:15.760 --> 13:22.320
to look for a pattern that starts with that starts with the pattern we are looking for. So that

13:22.320 --> 13:27.840
starts with the string hello, for example, then the dollar sign is the opposite. If you want to

13:27.840 --> 13:38.080
look for a string at the end of our text, then we have some quantifiers. So the asterisk, the plus

13:38.080 --> 13:46.160
and square brackets. And I will talk about them later in more detail. Then we have the set operator,

13:46.800 --> 13:55.680
which I will also cover later. Then we have conditions and grouping with parentheses. So I

13:55.680 --> 14:01.680
will also talk about this later. And of course, we have to look, we have the backslash. So with

14:01.680 --> 14:09.760
the backslash, we can get more special sequences, or we can escape characters. So for example,

14:09.760 --> 14:16.720
if you actually want to search for the dot, then we have to escape this in our pattern.

14:17.680 --> 14:25.440
So now let's talk about the first three and show you some examples. And then later we will cover

14:25.440 --> 14:34.000
the other meta characters in more detail. So now first let's say we want to look for the dot and

14:34.000 --> 14:43.920
then print all the matches, then we see we get all all the characters in our string,

14:44.480 --> 14:52.000
because the dot is looking for any character except new line. So this is the dot.

14:52.000 --> 15:00.880
And now let's say we have a dot here at the end, and we actually want to get this dot. So then we

15:00.880 --> 15:08.880
escape it with a backslash. And now if we run this, then we just get the dot. So now let's print the

15:08.880 --> 15:18.000
whole match object. Then we get the dot and we see that it is at this position. So this is the

15:18.000 --> 15:25.200
dot. And then let's have a look at the carrot. So this is the carrot. So let's say we want to look

15:25.200 --> 15:36.240
for 123 if it starts with this. And then we get one match object. And for example, now if we look

15:36.240 --> 15:44.400
for ABC, then it will return nothing, because it's not at the beginning. And the opposite if you

15:44.400 --> 15:51.920
want to have a look, if we want to look if this is at the end, so then we can say dollar here.

15:52.480 --> 15:58.880
And now if you run this, and this will find nothing because I'm sorry, we have the

16:00.000 --> 16:07.840
colon here, this will find nothing, because as I said, it is case sensitive. Now if I'm looking

16:07.920 --> 16:15.760
for uppercase ABC, and dollar at the end, so then it found the match at the end.

16:16.640 --> 16:24.080
All right, so now we will talk about the other meta characters later. And now let's look at

16:24.080 --> 16:30.400
some more special characters. So there are more special characters that start with a backslash.

16:30.400 --> 16:40.480
So there is the backslash and small D. This looks for any digit, so zero until nine.

16:41.120 --> 16:47.040
Then there's the capital backslash capital D. So this matches any non digit character.

16:47.760 --> 16:54.880
Then there's backslash, small s, this matches any white space character, for example, space,

16:54.880 --> 17:03.040
tap or new line. Then we have backslash capital is s, this matches any non white space character.

17:03.040 --> 17:07.040
So for all these patterns, all these special characters, the capital

17:08.400 --> 17:17.520
pattern is kind of the opposite of the small character here. So then we have backslash,

17:17.520 --> 17:27.600
small w, this matches any word character. So we have characters from A to C. We also have

17:27.600 --> 17:38.080
all the capital characters, and also digits and the underscore. Then the capital w is the

17:38.080 --> 17:44.800
opposite. So any non word character, non alphanumeric character. Then we have the

17:45.280 --> 17:54.560
backslash b. So this matches where the specified characters are at the beginning or at the end

17:54.560 --> 18:01.760
of a word. And again, we have the opposite. So where this is not at the beginning. So let's

18:01.760 --> 18:10.320
have a look at them in detail. So let's use another test string here. So let's, for example,

18:10.320 --> 18:22.000
use this one. And now if we want to look for any digit here, we can simply say we want to look for

18:22.000 --> 18:30.560
backslash d. And now if you run this, then we will see we have three matches, the digits one,

18:30.560 --> 18:40.080
two and three. Now if we use the opposite, so capital D, so any non digit, then it will find

18:40.080 --> 18:49.360
all the characters except one, two and three. Then let's have a look at the white space. So

18:50.080 --> 19:00.080
backslash s finds any white space character. So here we see we have a space here, a space here,

19:00.080 --> 19:08.880
and a space here. And then again, the opposite, so any non white space character is any other

19:08.880 --> 19:20.960
character. So this is the s special character. Then let's have a look at the w characters. So any

19:20.960 --> 19:30.640
alphanumeric character. So if I put in a w here, then it finds all the word characters.

19:32.320 --> 19:41.280
And again, the opposite capital D, this will just find the spaces in this example. And now

19:41.280 --> 19:53.120
let's have a look at the backslash B. So now if I am looking for hello, then it will find it because

19:53.120 --> 20:02.400
it is at the beginning of a block. And a block is not only the beginning of a string, but the

20:02.400 --> 20:13.600
beginning of any block that follows a white space character. So for example, if we look for

20:14.800 --> 20:26.800
hay, then it will also find the hay, but it will only find this pattern and not this one because

20:26.800 --> 20:35.280
it's looking for matches that are at the beginning of a block. So for example, if we put this

20:36.640 --> 20:45.520
before a space, then it will find and then it will find this pattern or this match to

20:46.720 --> 20:51.760
and again, the opposite. Now if we are looking for this, and we put

20:52.080 --> 21:00.080
ho hay here again, then it will find this hay because it is not at the beginning of a block

21:00.080 --> 21:08.800
where this is at the beginning of a block. So these are the special sequence, special characters

21:09.760 --> 21:23.920
that we should know. And now let's continue with sets. So we can use square brackets to look for

21:24.640 --> 21:32.560
sets. And let me show you what this means. So let's say we only have this string now.

21:33.120 --> 21:40.560
But now let's say we only want to look for a non-numeric character. So only for these ones,

21:41.120 --> 21:52.880
then we can use a set for this. So a set is a pattern between square brackets. And now here

21:52.880 --> 22:02.320
in this set, we can use multiple characters that we want to look up. For example, we want to look

22:02.400 --> 22:14.800
for a L and a O. And now if we run this, then it will find all these characters. And you must be

22:14.800 --> 22:24.240
careful here because it doesn't look for L O, but for any single character that we put into this set.

22:24.640 --> 22:34.400
And we can also specify ranges here. So we can instead of, let's say we also want to have the

22:35.200 --> 22:46.640
H and the E, then it will find any character here that is not a number and also not the

22:47.360 --> 22:55.120
not the underscore. So we can also specify a range here. And this is a very typical,

22:55.120 --> 23:06.720
very common example in regular expressions to use A dash C, so A to C. So all the lowercase

23:06.720 --> 23:14.640
characters, now if you run this, sometimes it's not saving this file automatically. So now if

23:14.640 --> 23:26.640
you run this, then we see that we will find all the letters here. And we can also look for digits.

23:26.640 --> 23:34.720
So let's say we want only the digits two and three. And again, here we can have a range. So we can

23:34.720 --> 23:44.800
say one to nine. So this is or let's say zero to nine. And this will find all the digits. So this

23:44.800 --> 23:56.960
is the same as using backslash D to find a digit. And so yeah, so if you want to specify a

23:57.920 --> 24:08.880
range, then that the dash can be used to declare to define the range. And now if you use it after a

24:08.880 --> 24:15.600
range, then it's looking for the actual dash. So now if you also want to look up a dash,

24:16.160 --> 24:24.000
then we can find it here. And if you put it between two things, then it is a range. So be

24:24.000 --> 24:36.560
careful here. And we can also write our different ranges back to back. So for example, if we have

24:37.600 --> 24:45.520
hello here in uppercase letters, and first of all, let's say we only want the lowercase letters.

24:46.080 --> 24:53.280
And then we also want to have all the uppercase characters from A to C, then we can write this

24:53.280 --> 25:04.240
back to back. So we can say small a to C or a dash C, then capital A dash C. Then this will also

25:04.240 --> 25:12.480
include all the uppercase characters. And again, we can use back to back and also include numbers.

25:13.280 --> 25:23.760
So yeah, then it also finds the numbers here. So the digits. So yeah, so this is how we can use

25:23.760 --> 25:37.920
sets with this brackets. And now let's talk about quantifier. So we have these quantifier, the

25:38.880 --> 25:50.000
meta meta characters. So we have a an asterisk. So a the multiplication sign, this means zero or

25:50.000 --> 25:57.200
more. Then we have the plus this means one or more, then we have the question mark. So this

25:57.200 --> 26:05.440
means zero or one. And this means or this can be used when we want to look for an optional

26:05.520 --> 26:12.560
character. So it may be there, but it may also be not there. Then if we want to look for a specific

26:12.560 --> 26:20.080
exact number, we can use curly braces and then a number here will look for the exact number.

26:21.600 --> 26:29.680
And then we can also specify a range with minimum and maximum. So if we put two numbers between

26:29.680 --> 26:37.360
the curly braces, then it's looking for a range. Okay, so let's have a look at them in detail. So

26:38.560 --> 26:48.160
let's say we have a string, let's say hello underscore 123. And now let's say we want to have

26:48.720 --> 26:55.920
or we want to find digits. And remember, we can do this with with backslash D. And then it will

26:55.920 --> 27:06.160
find all the digits. And let's say we want to look if we have zero or more. So then we use an

27:06.160 --> 27:15.280
asterisk. And then it will also find all the other characters here. Because here there is no

27:16.560 --> 27:24.560
digit, but it was looking for zero or more. And in this case, our match is just an empty string.

27:25.440 --> 27:32.400
And then again, an empty string, empty string, empty string. And then here we have digits. And

27:32.400 --> 27:41.760
then it will combine them into one match. So now if we just use the and use it without a quantifier,

27:41.760 --> 27:50.320
then it puts any every single digit as one match. And if we want to look for zero or more, we can

27:50.320 --> 27:58.160
use this with an asterisk. And now in this case, a plus is better. So we want to look for one or

27:58.160 --> 28:08.640
more. And then we will see it has only one match. And it combined all the digits into one match.

28:08.640 --> 28:14.640
And let's say we want to look for a digit that has an underscore in front of it. So let's say we

28:14.640 --> 28:24.400
want to look for underscore and then the digit, then it will find the one. And but now let's say

28:24.400 --> 28:30.320
we don't know if there is an underscore or not. So now if the string looks like this,

28:31.120 --> 28:37.920
and then if we run it, then it doesn't find a string, a match. And then we can say that the

28:38.000 --> 28:47.680
underscore is optional by using the question mark. And now if we run it, it finds all the matches,

28:48.720 --> 28:55.840
because it doesn't has an underscore. And now if we do it like this, then it will

28:57.520 --> 29:06.400
find the same matches because it can also have an underscore here. So this is the question mark.

29:07.120 --> 29:15.680
And now let's talk about specific ranges or a specific number of

29:17.760 --> 29:26.240
characters. So now if you want to look for three digits, then we can say a digit and then curly

29:26.240 --> 29:33.920
raise and then three, then it will find our match. So now if we are looking for four of the digits

29:33.920 --> 29:40.560
and run it, then we don't have a match. And we can also use a range here. So this can be between

29:40.560 --> 29:50.640
can be between one and three. And then it will also find the match. So these are the quantifiers.

29:51.280 --> 29:57.040
Now let's stop for a second with all the concepts and just make or just do an example.

29:57.600 --> 30:05.600
So let me copy this string here. And now let's use some of the concepts that we already know.

30:08.240 --> 30:16.800
So let's say our string is now the date string. So this is dates in different formats. So for

30:16.800 --> 30:25.120
example, here, we have the day and the month and then the year and this is separated by a colon.

30:25.120 --> 30:33.440
Then here it's the year first, then a colon, then here we have year, month and day separated by a

30:33.440 --> 30:42.960
dash and here by a slash and also by an underscore. And now let's say we only want to extract

30:44.080 --> 30:53.200
the dates with this format. So year, month and day, and only with a dash in between. So

30:53.200 --> 31:02.960
let's do this. So the first thing we can do is now here is to look for

31:05.520 --> 31:14.400
this pattern. So four, two and again two digits. So we can write this up. So backslash d backslash

31:15.280 --> 31:26.880
d. And then let's say first of all, we want to look for any character between. So remember,

31:26.880 --> 31:33.920
the point is a meta character. So this is looking, if you have a look at this here,

31:33.920 --> 31:42.320
this is looking for any character except new line. Then we have two digits. So backslash d,

31:42.320 --> 31:50.400
then again, we can have any character and then d and backslash d. So for example,

31:50.400 --> 31:56.800
if our string has also some text in it. And now if we run this,

31:59.440 --> 32:07.520
now it's called dates, the string. Now if we run this, then it will find all the

32:08.320 --> 32:19.200
all the states with with the numbers, but only in this format. So four, two, two. So for example,

32:19.760 --> 32:26.880
it didn't put the text here, the hello text in here. And it didn't put this date in here because

32:26.960 --> 32:42.000
it has a different format. So now this is our first try. And now what we can do here is, for

32:42.000 --> 32:50.240
example, the next thing we want to do is to find only these in this format. So now let's have a

32:50.240 --> 32:59.760
look at, so let's exchange the dot by a dash. So this is looking for an actual dash. And then we

32:59.760 --> 33:10.640
have only the dates in this format. So four, two and two numbers separated by a dash. And let's say

33:10.720 --> 33:22.080
we this may also be a valid date. So we can also looking for a slash as a separator here. So then

33:22.080 --> 33:32.320
we can use a set. So remember a set is defined in square brackets. And then we can define the

33:32.320 --> 33:40.240
characters that may be at this position. So for example, we have a dash. And we have also or may

33:40.400 --> 33:50.800
have a slash. And again, here we are using a set. So then we have dash slash and are closing our set.

33:50.800 --> 34:00.720
And now if we run this again, then we see, sorry, we see that this is also included in the matches.

34:00.720 --> 34:11.520
And now let's say, for example, we are looking only for dates in May or June. So how do we do

34:11.520 --> 34:22.720
that? So the month here. So what we do here is now this is not any digit. So here we are only

34:22.720 --> 34:34.400
looking for month 05 and 06. So we always have a zero here. And then we can again use a set.

34:35.120 --> 34:43.440
And here we can use, let's say only five and six. And now if we run this, then we only have the

34:43.440 --> 34:51.440
dates in May or June. And remember, we can also use a range here. So let's say we want to have

34:52.080 --> 35:02.160
May, June and July, then we can say five to seven. And then we have all the dates from May to July.

35:03.040 --> 35:13.280
And now let's use a quantifier here. So instead of writing for these here, backslash D, we can say

35:13.280 --> 35:23.440
D and then curly braces and use the quantifier for so we want to have exactly four digits here.

35:23.440 --> 35:32.880
And here we want to have exactly two digits. So then we can do it like this. So this finds all

35:32.880 --> 35:41.920
the dates in May, June or July in this format. So this is one typical example how regular

35:41.920 --> 35:50.720
expressions are useful. And yeah, so now let's continue. So we already covered a lot here.

35:50.720 --> 36:01.840
So let's talk about conditions next. So let me copy another string and do another example.

36:02.480 --> 36:11.520
So here I have another string with some names. So let me copy and paste this here. So this is

36:11.520 --> 36:19.840
my new string. So here we have a Mr. Simpson, a Mrs. Simpson, a Mr. Brown, a Miss Smith,

36:19.840 --> 36:35.120
and a Mr. T. And sometimes we have a dot between Mr. And sometimes not. And now let's just extract

36:35.120 --> 36:43.760
all the different names here. So for example, there's some more in our files. So for example,

36:43.840 --> 37:00.480
we have Hello World 123 date. And now we only we want to extract only the names and we want to

37:00.480 --> 37:12.480
have the whole name. So let's build up our pattern here. So let's look for Mr. First. So first we

37:12.480 --> 37:25.760
want to look for a Mr. So Mr. And then we have a white space. So backslash s. And then we have one

37:25.760 --> 37:36.560
or more characters, so word characters. So here we use a backslash w. And then we say plus. So this

37:36.640 --> 37:47.440
remember this is a quantifier. So one or more. And then I'm looking for the my string here. And I don't

37:47.440 --> 37:54.480
actually write the space here because I have this backslash s. And now if I run this, then we see

37:54.480 --> 38:06.080
that we have one match here. So this is our Mr. Simpson. So here we have the m r and then a space

38:06.080 --> 38:15.760
and then one or more word characters. And now as a next step, let's also include a Mr. Where we

38:15.760 --> 38:25.600
have the dot here. So we can have the dot. And now if you just write it like this and run it,

38:26.480 --> 38:34.000
then it finds a sorry, I have to use backslash dot, of course, here, because it's looking for an

38:34.000 --> 38:43.680
actual, I want to look for the actual dot. And now it only finds Mr. Brown and Mr. T, but not Mr.

38:43.680 --> 38:52.320
Simpson anymore. So now as we just learned, we have the optional quantifier with a question mark.

38:52.320 --> 39:01.680
So now let's make our dot optional. And now if we run this, then we have all the Mr. And

39:02.640 --> 39:12.720
now let's talk about where conditions are useful. So in this case, we may not only have Mr, but we

39:12.720 --> 39:21.840
may also have a miss or a misses. So then we can use a condition. So we use parentheses here.

39:22.560 --> 39:32.640
And then we separate them. So let's have a look at this here. This meta character is the either or.

39:33.440 --> 39:47.920
So now if we use this, we can write Mr or miss or misses. And then if we run this, then we see

39:48.880 --> 39:58.640
it extracted all the names from this text. So this is where a condition is useful.

39:59.600 --> 40:09.840
And as we have just seen, we grouped this condition together with the parentheses. So this is

40:10.800 --> 40:21.040
again one meta character. And now let's talk about grouping a little bit more. So let's do

40:21.040 --> 40:31.760
another example for this. This is also a typical example. So let's copy some emails into our text.

40:32.560 --> 40:39.440
And let's say we only want to extract the emails from this string here.

40:40.160 --> 40:52.560
So again, let's build up our pattern. So what we can do here is we can use sets to do this.

40:53.520 --> 41:00.560
So let's build this up. So let's say we want to have some characters here.

41:01.600 --> 41:09.200
So this may be word characters, but this may also be a dash and numbers.

41:10.800 --> 41:19.760
So let's use a set here and let's use back to back ranges here. So we can use small a to c

41:20.560 --> 41:32.080
or capital A to C, or also the digits zero to nine. Or we may also have a dash here.

41:32.800 --> 41:42.640
So now we are you looking for any of these characters here. And we want to have multiple

41:42.640 --> 41:52.640
of them. So we say we want to have multiple. So one or more. So this combines this group into one

41:52.640 --> 42:02.320
match. And then it is followed by an add sign. So now if we compile this and run this, then we see

42:03.040 --> 42:13.760
that it extracted all these patterns here with any words or numbers or dashes and then an

42:13.760 --> 42:26.000
add sign. So this is the name before the email. And then our email can have different domains.

42:26.000 --> 42:35.840
So for example, we have at gmail.com at gmx.de or at my domain or my dash domain dot org.

42:36.400 --> 42:45.280
So we want to extract all the different domains. And the next thing we want to look is to look for

42:45.280 --> 42:52.000
only for word characters. So the domain doesn't have a digit in it.

42:52.960 --> 43:03.040
So the only allowed characters are let's use another set. And here we use again, maybe a to c,

43:04.080 --> 43:13.520
a capital A to C, and also a dash. And then we have the dot. So now let's run this.

43:14.480 --> 43:27.360
And of course, there are again, one or more. So here I have to do a plus. And then it's looking

43:27.360 --> 43:38.480
for one or more. So now we see our match also includes the domain name and the dot. And then

43:38.560 --> 43:49.760
here at the very end, let's do another set. So here we say our ending. For example, we can say

43:49.760 --> 44:00.640
here we have dot. Sorry, again, I missed, I was not looking for an actual dot here. So this is a

44:00.640 --> 44:10.320
typical mistake that I make. So now it for example, it would have also found this one here. But this

44:10.320 --> 44:16.720
is not a valid email address. So I have to look for the actual dot by using the backslash.

44:18.400 --> 44:28.640
And then let's say I'm looking only for dot com. But it can also be dot de or dot org. So for

44:28.640 --> 44:40.000
example, I can use a group here by using parentheses and then use the condition here com or de or

44:40.000 --> 44:51.200
dot org. So now it would only find these endings here. And now let's not use a condition. But

44:51.200 --> 44:57.840
I just wanted to show you the condition here again. But we can also just use a set here. So

44:57.840 --> 45:11.280
let's use the set. And again, here, we may have a to C and a to C and capital and then one or more.

45:12.720 --> 45:23.920
And no digits here. So now if you run this, then this will extract all the emails for us. So this

45:23.920 --> 45:31.760
is a typical regular expression pattern to look for emails. And this is what I showed you in the

45:31.760 --> 45:40.320
beginning. So now you understand what this means. And now let's talk about grouping a little bit

45:40.320 --> 45:48.240
more. So there was one case just where I used the condition and then I have had to use parentheses.

45:49.200 --> 45:59.840
But we can also explicitly group our match object here into different substrings. So for example,

45:59.840 --> 46:13.280
I can put all of these before the ad sign into a group. So now let's use parentheses. And then

46:13.440 --> 46:26.080
let's use the ad sign. And then let's use the domain name. So this is one group until the dot.

46:26.800 --> 46:38.080
And then we have one group to have the ending here. And now we have three groups here.

46:38.560 --> 46:47.200
And as I showed you in the beginning, now if we run this, then this will give the same results.

46:47.200 --> 46:58.240
And here we are printing the whole match object. And then we can use the dot group to return the

46:58.240 --> 47:06.560
actual string. And this is by default, this is group zero. So this is the whole match string.

47:06.640 --> 47:16.480
But now we can also print the single groups that we just defined. So for example, we have group one,

47:16.480 --> 47:23.600
two and three now. And now if we run this and print this, then we see,

47:25.760 --> 47:33.120
let's just print the group one for now. Here, let's comment this out too.

47:33.840 --> 47:43.440
Then we see it only prints this group here. So only the name of the email before the ad sign.

47:43.440 --> 47:49.760
Then here this is the second group. So now if we print the group two, then this is

47:50.720 --> 47:58.080
the domain name. And if we want to have the ending, then we can print group three.

47:58.640 --> 48:06.880
So this is where grouping is useful. If we only want to have a look at specific things in our

48:06.880 --> 48:16.000
match, then we can use parentheses. Now let's move on. So now let's see, we talked about grouping.

48:16.000 --> 48:25.520
Now let's talk about modifications. So we have two methods to modify a string.

48:26.160 --> 48:35.920
So we have the split method and we have the sub method. So let's talk about both of them.

48:35.920 --> 48:42.880
So the split method will split the string into a list and splits wherever our

48:43.680 --> 48:50.720
regular expression matches. And the sub method will find all substrings where the regular

48:50.720 --> 48:58.080
expression matches and replaces them with a different string. So let's look at two examples.

48:58.720 --> 49:07.920
So let's say, let me grab a string here. So let's use this one again.

49:08.640 --> 49:19.520
So this is our test string. And now we use the pattern equals our e.compile and then we are

49:19.520 --> 49:33.120
looking for the raw string 123. Sorry, let's use a different one. Do I have it here? No, let's write

49:34.080 --> 49:49.840
it myself. So let's say abc123abcdef and capital letters again 123 and abc. And now let's say

49:49.840 --> 50:01.440
this is our pattern. So 123. And now we say our split it equals and then we say pattern dot split

50:02.160 --> 50:10.640
and give the test string as argument. And now let's print this split it. Now this will be a list

50:12.560 --> 50:24.160
where our string split it. Oh, sorry, this was a bad example. So let's use abc as split. And then we

50:24.160 --> 50:34.800
have splits where it's split it our string into different substrings and use this pattern here

50:35.600 --> 50:46.000
as the split. So here as the matching split. So here it has abc. So it's split it our string into

50:46.000 --> 50:55.840
this part. So there we have 123. And then this part. And then it found our pattern again abc.

50:57.440 --> 51:03.680
And then again, it's split it the string. And then at the end, we have the rest of the string. So

51:03.680 --> 51:11.920
this is the third substring that it found and and returned with this split method. So this is the

51:12.000 --> 51:22.480
split method. And now the sub method with the sub method, we find all the substrings where our

51:22.480 --> 51:31.440
pattern matches and then replace them with a different string. So let's say our test string

51:31.440 --> 51:44.640
equals hello world. And then let's say you are the best world. And use the so we use the word

51:44.640 --> 51:54.960
world two times. And then let's say we want to look for the pattern world. So we say pattern equals

51:54.960 --> 52:07.680
re.compile. And then an R raw string. And here we have world. And then we say our sub string

52:08.320 --> 52:18.160
equals and then we use pattern dot sub. And then what we want to put in as replacement,

52:18.800 --> 52:25.520
let's say we want to put in planet. And we also have to put in the test string.

52:26.240 --> 52:36.720
Now it took our test string, looked for all the matches where pattern matches. So it looked for

52:36.720 --> 52:44.880
world and replaced them with planet. So now this will return another string that was modified.

52:44.880 --> 52:53.360
And now if we print this, then we see it printed hello planet, you are the best planet. So this

52:53.360 --> 53:05.120
is the sub method. And now let's do another example to combine all that we have learned.

53:06.000 --> 53:12.240
And again, use the sub method. And yeah, so let's do this. So

53:14.640 --> 53:23.760
so let me grab this string here. So this is our URL strings. So here we have, again, let's say we

53:23.760 --> 53:36.240
have different things here. And then we are only looking for URLs, but they may have different

53:36.240 --> 53:49.600
formats. So for example, we have an HTTP URL, an HTTPS URL. And then sometimes we have a www

53:50.240 --> 53:59.440
and sometimes we don't have this. And then we have the typical domain name and ending.

54:00.480 --> 54:11.520
So yeah, so let's extract this. So let's build up our pattern again. So pattern equals re.compile and

54:11.520 --> 54:23.440
then a raw string. So now let's start by saying it starts with HTTP. And then a colon and two slashes.

54:24.320 --> 54:38.160
And then we have www and then we have a dot. So an actual dot. And then we have

54:38.720 --> 54:53.920
one or more word characters. So for example, we can use a set here again and use a to c and

54:53.920 --> 55:06.480
uppercase a to c and also a dash here. So like here. And so then we have a plus. So one or more.

55:07.520 --> 55:16.800
And let's put this into a group here right away. So this will return the same thing.

55:17.520 --> 55:27.120
And then we can later use this group here. And the next thing we again have a dot. So

55:27.120 --> 55:37.840
backslash dot. And then again, we can use a set here a to c and capital A to C.

55:38.800 --> 55:49.120
And now let's try this out. So let's say matches equals pattern dot find iter.

55:49.840 --> 56:02.160
And then we call this urls. And then for match in matches, we want to print the match. And let's

56:02.240 --> 56:10.000
try this and run this. And then we see we made some mistakes here. And this is because here I

56:10.000 --> 56:20.800
have to say plus, of course, so one or more. And now it only found this URL, because it didn't

56:20.800 --> 56:30.960
find this one because we have HTTPS here. And this one doesn't have www. So the first thing

56:30.960 --> 56:38.640
we can do here is to use an s. And this is an optional s. So remember s question mark. So this

56:39.840 --> 56:46.960
is optional then. And if we don't put this into a group, then the question mark will only refer

56:46.960 --> 56:56.480
to this character here. So now let's try this out. And now we see it also found the HTTPS URL.

56:57.280 --> 57:06.320
And now the same thing with the www. So this may be there or may not be there. So again,

57:06.320 --> 57:14.320
let's put this into a group. And then use an question mark to make this optional. And now if

57:14.320 --> 57:22.560
you run this again, then it still doesn't find it. And this is because our it must be www.

57:22.560 --> 57:30.880
So backslash dot, which must be optional. And then I don't need it here anymore. So let's

57:30.880 --> 57:40.240
run this. And then we see that it found all of the URLs and extracted them. And now let's say

57:40.240 --> 57:48.160
our string has only the URLs here. And now let's say we want to return a new string,

57:48.800 --> 57:57.680
where we replaced all of these optional beginnings. So it should only print the actual domain name

57:57.680 --> 58:06.080
with the ending. So as we have learned, we can use the sub method. So we can say,

58:08.080 --> 58:16.880
instead of just finding the matches, what we want to do here is let's also print this. And then

58:16.960 --> 58:27.840
let's say our sub URLs equals and then we use pattern and then sub. And then what we want to

58:27.840 --> 58:40.080
put in the replacement here. So for example, if we just say hello, and then URLs as a string and

58:40.080 --> 58:54.880
then print the sub URLs. So then we see that this is the new string here. So it's replaced all of

58:54.880 --> 59:07.200
the matches with hello. And now let's say we only want to put this in our string and only this,

59:07.920 --> 59:19.360
then what we can do here is we can group this and we already did this. So we have a group here,

59:19.360 --> 59:30.320
we have a group here. And let's also put this into our group into a group. And then what we

59:30.320 --> 59:41.120
can do is we can use back references to replace them. So here we can say backslash two and

59:43.360 --> 59:55.440
we must use a string so a raw string. And then we say backslash two and backslash three. And now

59:55.440 --> 01:00:05.520
if we run this, then this is our new string. So if I comment this out, then we see, then this is our

01:00:05.520 --> 01:00:14.720
new string. And what happened here, again, if we have a look at the group, so we can say,

01:00:15.360 --> 01:00:22.800
let's print all the different groups. So we have match dot group. So this will be the whole

01:00:23.600 --> 01:00:34.160
string. And now, so this is group zero again. Now let's have a look at what is group one.

01:00:34.720 --> 01:00:45.600
So for example, here, this is the group one, the first one in parentheses. And because this may

01:00:45.920 --> 01:00:55.200
optional, this may also be none. So the first URL has none as the first group because it doesn't

01:00:55.200 --> 01:01:04.800
have w w w. And this is the first group. So now let's print the second group. So this is the actual

01:01:05.360 --> 01:01:13.040
name of the domain. So the beginning. And then the group three is the ending so dot com dot com

01:01:13.040 --> 01:01:23.040
dot net. And now here we use this group two and group three with this back reference. And then

01:01:23.040 --> 01:01:30.320
replace the whole found pattern only with the domain name. So this is what happens here.

01:01:31.040 --> 01:01:38.320
And so this is also very often used in regular expressions. And now you know what this means.

01:01:39.680 --> 01:01:48.480
And I guess now we are almost through with all the context, all the things that I wanted to

01:01:48.480 --> 01:01:58.320
show you. And now as a last thing, let's quickly talk about compilation flags. So when we compile

01:01:58.320 --> 01:02:07.280
the pattern, then we also have to option to use different compilation flags. So here I listed

01:02:07.280 --> 01:02:12.960
them. And again, you don't have to remember them, just keep a cheat sheet. So here we have the

01:02:12.960 --> 01:02:22.480
different compilation flags. So ASCII dot all ignore case local multi line or verbose.

01:02:22.720 --> 01:02:29.520
So I recommend that you check out the official documentation to see what all of them mean

01:02:29.520 --> 01:02:37.600
in detail. And now I just want to show you the ignore case compilation flag. So this is also a

01:02:37.600 --> 01:02:51.600
very common use case. So let's say we have the string my string equals hello world. And then

01:02:52.560 --> 01:03:02.800
we want to look for the string world. And now if we compile this, and then try to find the matches

01:03:02.800 --> 01:03:14.320
and print them. So print the match. Now if you run this, sorry, this is called my string. Now if

01:03:14.320 --> 01:03:22.640
we run this, then it doesn't find a string. So because remember, this is case sensitive. Now if

01:03:22.640 --> 01:03:32.400
you make a capital W, then it finds the match world. And let's say we don't know what our string is.

01:03:32.400 --> 01:03:39.040
So it may be uppercase, but it may not be uppercase. So it doesn't matter for us. Then we can just

01:03:39.200 --> 01:03:49.600
use the compilation flag, our e dot ignore case. So we can write this out. So we can say ignore

01:03:50.240 --> 01:04:04.880
case. Or we can just say our re dot I. And then if we use a small w, then it will still find the

01:04:04.880 --> 01:04:12.640
match. And because now it ignored the cases. So this is the ignore case compilation flag.

01:04:12.640 --> 01:04:20.400
And now, yeah, you also have these compilation flags. So I recommend that you check them out

01:04:20.400 --> 01:04:26.800
for yourself. I will provide a link to the official documentation in the description.

01:04:27.360 --> 01:04:33.920
And now I think we are done. And now you should be able to understand all the different

01:04:33.920 --> 01:04:39.680
regular expressions. I hope it wasn't too complicated for you. And I hope you enjoyed

01:04:39.680 --> 01:04:44.400
this tutorial. If you like this, then please consider subscribing to the channel and leave

01:04:44.400 --> 01:04:47.040
me a like and see you next time. Bye.

