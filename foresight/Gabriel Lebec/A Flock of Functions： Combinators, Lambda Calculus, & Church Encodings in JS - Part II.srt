1
00:00:00,000 --> 00:00:10,000
Okay, we left off. I was going to teach you numbers. So how are we going to do this?

2
00:00:10,000 --> 00:00:15,000
You know, we don't have multiplication. We don't have a quality. We don't have numbers.

3
00:00:15,000 --> 00:00:19,000
We've got nothing. How are you going to do it? 0, 1, 2, 3, successor.

4
00:00:19,000 --> 00:00:26,000
All right, let's think about instead of nouns 1 and 2 and 3, we're going to use adverbs.

5
00:00:26,000 --> 00:00:33,000
Once, twice, thrice, etc. So how's this going to work? Let's look at 1 to start with.

6
00:00:33,000 --> 00:00:39,000
1 is going to take a function and argument, and it's going to apply the function to the argument.

7
00:00:39,000 --> 00:00:45,000
One time. It's going to call the function once. See you later, Elmer.

8
00:00:45,000 --> 00:00:51,000
Ah, let's try it. Oops, that's not where I wanted that to go. That's where I wanted it to go.

9
00:00:51,000 --> 00:01:04,000
Okay, so once is going to take a function and argument. It's going to apply the function to the argument a single time.

10
00:01:04,000 --> 00:01:14,000
What is once of identity of 2?

11
00:01:14,000 --> 00:01:23,000
2. That makes sense. What about once of not on true?

12
00:01:23,000 --> 00:01:28,000
Yeah, straightforward so far.

13
00:01:28,000 --> 00:01:36,000
So what about 2? 2 will take a function and argument, and it will apply the function twofold times.

14
00:01:36,000 --> 00:01:41,000
It will apply the function to the argument, and then it will apply the function again to the result of that.

15
00:01:41,000 --> 00:01:46,000
It will apply the function over and over again. So let's do twice.

16
00:01:46,000 --> 00:01:53,000
Twice takes a function and an argument, and we'll apply the function to the function of the argument.

17
00:01:53,000 --> 00:02:04,000
And we do twice not of false is, say again, wait, twice not. Not of not of false.

18
00:02:04,000 --> 00:02:10,000
What's a double negative? It just loops back around, right?

19
00:02:10,000 --> 00:02:16,000
And three times, well, that's just thrice. So we'll define that thrice takes a function and its argument.

20
00:02:16,000 --> 00:02:20,000
It applies the function to the function to the function to the argument.

21
00:02:20,000 --> 00:02:25,000
And we could do thrice not true.

22
00:02:25,000 --> 00:02:31,000
False. Yeah, I'm flipping you back and forth. You got to keep on staying on your toes.

23
00:02:31,000 --> 00:02:38,000
Well, this is kind of cool. You can see these building out here. We got a number of hard-coded in Fs, and that's kind of our number system.

24
00:02:38,000 --> 00:02:43,000
So we just demoed this. Once not true is not true, which is false.

25
00:02:43,000 --> 00:02:47,000
Twice not true is not not true, which is true.

26
00:02:47,000 --> 00:02:52,000
Thrice not true is not not not true, which is false again.

27
00:02:52,000 --> 00:02:56,000
We start to get this building up of a number system.

28
00:02:56,000 --> 00:03:01,000
What is zero? What's the theme of the talk?

29
00:03:01,000 --> 00:03:06,000
It's a function. It takes the same signature as all of our other numbers.

30
00:03:06,000 --> 00:03:11,000
This is like a good rule in general. As you got a class of functions, they all got to share the same signature.

31
00:03:11,000 --> 00:03:21,000
Even if you don't know how to design one of the functions, you start thinking, well, wait, it's got to take the same arguments as all my other functions.

32
00:03:21,000 --> 00:03:28,000
Twice applies the two-fold F to A. Once applies the single F to A. What does zero do?

33
00:03:28,000 --> 00:03:40,000
It just gives you back A. It applies F to A no times.

34
00:03:40,000 --> 00:03:45,000
Does that look familiar to anybody?

35
00:03:45,000 --> 00:03:47,000
Which one?

36
00:03:47,000 --> 00:03:52,000
Not quite. Identity would be A to A. But this is F A to A.

37
00:03:52,000 --> 00:03:55,000
Something other thing, return other thing.

38
00:03:55,000 --> 00:04:01,000
First thing, second thing, return second thing. Zero is false.

39
00:04:01,000 --> 00:04:05,000
That's really nice. I like that. That's cool, right?

40
00:04:05,000 --> 00:04:13,000
So zero times not of true is of course just true because we didn't apply the function to true. We just returned it.

41
00:04:13,000 --> 00:04:21,000
And of course it could say false of not true and that gives us the same thing. So zero is false.

42
00:04:21,000 --> 00:04:23,000
Yeah, we saw this already.

43
00:04:23,000 --> 00:04:31,000
So we start to do church encodings for numerals. Zero, one, two, three, four, five, and so on and so forth.

44
00:04:31,000 --> 00:04:37,000
But we have a small annoyance here, which is that we've manually gone and written all these functions down.

45
00:04:37,000 --> 00:04:42,000
Well, that's not math. That's numbers, but it's not math. That's not arithmetic, right?

46
00:04:42,000 --> 00:04:47,000
Like we're not dynamically generating these functions. Zero is false.

47
00:04:47,000 --> 00:04:53,000
By the way, what's once? Look at it carefully. It takes two things and it just gives you back those two things.

48
00:04:53,000 --> 00:04:58,000
That sounds familiar. What did you say a second ago? What was your name again?

49
00:04:58,000 --> 00:04:59,000
Truman.

50
00:04:59,000 --> 00:05:04,000
Identity. This is the identity once removed, like the mockingbird once removed.

51
00:05:04,000 --> 00:05:11,000
Yeah, an A to an A. Now we got AB to AB. It's the same thing. It acts exactly like the identity function.

52
00:05:11,000 --> 00:05:17,000
That's kind of also fun. Zero is false and one is identity. That's really, really nice.

53
00:05:17,000 --> 00:05:21,000
I mean, as a mathematician, that makes me smile.

54
00:05:21,000 --> 00:05:28,000
But we got a problem. We want dynamically generate numbers. How are we going to do it? How can we add one?

55
00:05:28,000 --> 00:05:33,000
It sounds trivial on the face of it, but it's not obvious. We need a successor function.

56
00:05:33,000 --> 00:05:39,000
We want a function that if you give it a number, it gives you back the next number somehow.

57
00:05:39,000 --> 00:05:46,000
If you give it two, it gives you three. And you could do it like this. You could say the successor of successor of one is three.

58
00:05:46,000 --> 00:05:54,000
Well, that's Peano numbers. We're going way back to 1889 here. Sort of.

59
00:05:54,000 --> 00:05:59,000
So we know our successors got to take in one of these church numerals.

60
00:05:59,000 --> 00:06:04,000
And let's do a concrete example. The successor of one is two.

61
00:06:04,000 --> 00:06:09,000
Well, let's replace these numbers by their implementations to see what this looks like.

62
00:06:09,000 --> 00:06:16,000
One is the identity once removed. It takes a function and argument and applies the function once to the argument.

63
00:06:16,000 --> 00:06:23,000
Twice takes a function and arguments and applies the function twice to the argument.

64
00:06:23,000 --> 00:06:30,000
The thing on the left is really similar to the thing on the right. What's the difference? One extra F.

65
00:06:30,000 --> 00:06:37,000
What we need the successor function to do is tack on an extra F at the beginning.

66
00:06:37,000 --> 00:06:49,000
So if the successor takes a function, that end function, that church numeral, it's going to return a new number function, one that takes F and A.

67
00:06:49,000 --> 00:06:55,000
And what does that new number function do? It does the original number of function applications.

68
00:06:55,000 --> 00:07:03,000
And then it does one more on top of that. Wow.

69
00:07:03,000 --> 00:07:11,000
So there's my successor function, NFA to F of NFA, an additional F, just one extra F. Let's try it out.

70
00:07:12,000 --> 00:07:18,000
Successor takes a church numeral and it does, what am I doing here?

71
00:07:18,000 --> 00:07:33,000
I'm doing N to F to A to N of F of A, but an F in front of all of that for one extra application of F.

72
00:07:33,000 --> 00:07:40,000
Now, I've got this zero function and I've got this, did I have one? No, did I have once? I have once.

73
00:07:40,000 --> 00:07:51,000
So if I get the successor of zero, this is some number function, but this is not intentionally equal to what we saw before.

74
00:07:51,000 --> 00:07:55,000
It's only extensionally equal. So I need to prove that this is the one function.

75
00:07:55,000 --> 00:08:00,000
So I can apply a function like not to an argument like true and I get false.

76
00:08:00,000 --> 00:08:04,000
So that actually worked. This gets a little annoying.

77
00:08:04,000 --> 00:08:11,000
So I'm going to just find this new JS num function. It'll take a church numeral and we'll apply the church numeral.

78
00:08:11,000 --> 00:08:20,000
I'll say, hey, take this and do the addition of one N times starting at zero.

79
00:08:20,000 --> 00:08:26,000
So the addition of one is I have some X and I add one to it.

80
00:08:26,000 --> 00:08:32,000
So now I can call JS num on the successor of zero and it tells me that's one.

81
00:08:32,000 --> 00:08:37,000
That's cool. I'm going to convert my church numbers into JavaScript numbers.

82
00:08:37,000 --> 00:08:42,000
What about the successor of successor of zero?

83
00:08:42,000 --> 00:08:48,000
Let's do successor of successor of successor of zero is three.

84
00:08:48,000 --> 00:08:58,000
This is useful. So let's let's actually like start storing these things and zero equals zero and one equals once and two equals twice.

85
00:08:58,000 --> 00:09:05,000
Is there a twice? Yeah, N2 is twice.

86
00:09:05,000 --> 00:09:12,000
N3 equals the successor of N2 and four is the successor of N3.

87
00:09:12,000 --> 00:09:16,000
I'll stop there for now, but we could do things like wait a second.

88
00:09:16,000 --> 00:09:27,000
The successor of N4 ought to be five and it is not too shabby.

89
00:09:27,000 --> 00:09:36,000
This is just demonstrating that and the purpose here is just to show that that new F gets tacked on and that's how we get a successor.

90
00:09:36,000 --> 00:09:40,000
So we have our successor function tax on an extra application of F.

91
00:09:40,000 --> 00:09:44,000
And at this point I want to talk about my favorite combinator of all.

92
00:09:44,000 --> 00:09:48,000
This is probably the most extolled and beloved of all combinators.

93
00:09:48,000 --> 00:09:51,000
Even the Y combinator doesn't compare to this.

94
00:09:51,000 --> 00:09:56,000
This combinator gets more mentions probably, I think, than the Y combinator.

95
00:09:56,000 --> 00:10:00,000
I'd have to do a Google search to prove that true. I might be wrong, but I wouldn't be surprised.

96
00:10:00,000 --> 00:10:04,000
Except you won't find it if you go search for the Bluebird combinator.

97
00:10:04,000 --> 00:10:07,000
You'll find it being talked about as something else.

98
00:10:07,000 --> 00:10:14,000
Do any mathematicians or functional programmers want to identify this for me?

99
00:10:14,000 --> 00:10:25,000
What am I looking at? What does the Bluebird do?

100
00:10:25,000 --> 00:10:38,000
It takes G and then it applies F. It applies G to A and then F to that.

101
00:10:38,000 --> 00:10:46,000
It's a pipeline. It takes A, puts it into G, puts the result of that into F, and that's the result you get out.

102
00:10:46,000 --> 00:10:51,000
What is it? It's composed. This is function composition.

103
00:10:51,000 --> 00:10:55,000
The Bluebird or the B combinator is function composition.

104
00:10:55,000 --> 00:10:58,000
That's why I'm saying it's the most famous one of all.

105
00:10:58,000 --> 00:11:03,000
Any time anybody tries to evangelize functional programming, what do they mention?

106
00:11:03,000 --> 00:11:08,000
Composition. That's what this is. Let's make it.

107
00:11:08,000 --> 00:11:15,000
B takes an F into G and it does G first and then F.

108
00:11:16,000 --> 00:11:24,000
This is interesting. Let's do B of not and not.

109
00:11:24,000 --> 00:11:28,000
This isn't as interesting because it doesn't matter whether it's right to left or left to right.

110
00:11:28,000 --> 00:11:32,000
They're identical, but that's okay. We'll show other things in a moment.

111
00:11:32,000 --> 00:11:38,000
This composition, the not not composition, is a function that first does not and then does the other not.

112
00:11:38,000 --> 00:11:44,000
If we pass in something like true, oops, I got a mistake.

113
00:11:44,000 --> 00:11:50,000
First mistake. A is not defined.

114
00:11:50,000 --> 00:11:54,000
Oh, FG. I forgot. Yep. There we go.

115
00:11:54,000 --> 00:11:57,000
It takes an F, a G, and an A.

116
00:11:57,000 --> 00:12:01,000
Oh, JavaScript. There we go. That's what I expected.

117
00:12:01,000 --> 00:12:07,000
I can compose these. I can pipeline them, chain them together into a new function that is their composition.

118
00:12:07,000 --> 00:12:11,000
Use that composition on some argument.

119
00:12:11,000 --> 00:12:14,000
This is boring because it doesn't matter whether it's right to left or left to right.

120
00:12:14,000 --> 00:12:20,000
Let's say Yale takes some string. I'm sorry to pollute our Lambda calculus topic with JavaScript strings.

121
00:12:20,000 --> 00:12:27,000
I would avoid it if I could, but just for demonstration, I don't know a better way yet of doing this.

122
00:12:27,000 --> 00:12:32,000
It just tax on an exclamation point.

123
00:12:32,000 --> 00:12:39,000
So if I yell Lambda, I get Lambda.

124
00:12:39,000 --> 00:12:43,000
Well, now I can do a little bit more interesting things.

125
00:12:43,000 --> 00:12:50,000
For instance, if I compose, first I will get the successor.

126
00:12:50,000 --> 00:12:57,000
That's the right most. Then I will yell it and I call this, actually, I'll do a JS note.

127
00:12:57,000 --> 00:13:04,000
First I'll get the successor, then I'll convert it to its JavaScript equivalent of N4.

128
00:13:04,000 --> 00:13:11,000
I get 5. Right to left function composition.

129
00:13:11,000 --> 00:13:14,000
We've seen these examples already. We can compose.

130
00:13:14,000 --> 00:13:18,000
The T goes into the first one on the right, then the next one on the left, and that is our result.

131
00:13:18,000 --> 00:13:21,000
So we get true.

132
00:13:21,000 --> 00:13:25,000
So the composition is expressed in that other way.

133
00:13:25,000 --> 00:13:29,000
And the right most one is the right most one in Haskell.

134
00:13:29,000 --> 00:13:34,000
This is built in. It's that little dot, which is wonderful.

135
00:13:34,000 --> 00:13:37,000
That's such a nice way of doing function composition.

136
00:13:37,000 --> 00:13:41,000
So odd in Haskell is not even.

137
00:13:41,000 --> 00:13:44,000
This is great.

138
00:13:44,000 --> 00:13:47,000
This is a combinator. It's the bluebird, so we'll put it in there.

139
00:13:47,000 --> 00:13:50,000
It's unary to unary composition going right to left.

140
00:13:50,000 --> 00:13:52,000
It's a period in Haskell.

141
00:13:52,000 --> 00:13:56,000
You can section it and turn it into the B combinator in prefix notation with parentheses.

142
00:13:56,000 --> 00:14:01,000
So that would be parentheses period two functions instead of function period function.

143
00:14:01,000 --> 00:14:07,000
But infix notation is more pleasant for function composition, I think.

144
00:14:07,000 --> 00:14:10,000
So here's our successor. We already saw this.

145
00:14:10,000 --> 00:14:17,000
It takes an N, returns a function FA that applies an extra F on top of NFA.

146
00:14:17,000 --> 00:14:19,000
There's a nicer way of doing this.

147
00:14:19,000 --> 00:14:21,000
Look what we have here.

148
00:14:21,000 --> 00:14:25,000
F is a function and NF is a function.

149
00:14:25,000 --> 00:14:28,000
This feeds an argument into the right most function

150
00:14:28,000 --> 00:14:34,000
and then feeds the result of that into the left function, generating a result.

151
00:14:34,000 --> 00:14:37,000
So which combinator it is?

152
00:14:37,000 --> 00:14:40,000
It's the bluebird.

153
00:14:40,000 --> 00:14:44,000
This is wrong. Successor...

154
00:14:44,000 --> 00:14:46,000
No, that's right. Okay, good.

155
00:14:46,000 --> 00:14:53,000
So the successor is the composition of one extra function on top of the original number of functions.

156
00:14:53,000 --> 00:14:58,000
That's a little bit prettier to my eyes.

157
00:14:58,000 --> 00:15:04,000
So we'll rearrange this. I'm not going to bother to demo it. It works.

158
00:15:04,000 --> 00:15:06,000
Let's do some more math.

159
00:15:06,000 --> 00:15:09,000
We've got adding by one. What about adding two numbers together?

160
00:15:09,000 --> 00:15:11,000
Binary addition.

161
00:15:11,000 --> 00:15:16,000
We're not binary in the sense of binary number systems, but two numbers together.

162
00:15:16,000 --> 00:15:20,000
What is add? What's the theme of the talk?

163
00:15:20,000 --> 00:15:24,000
How many arguments does it take?

164
00:15:24,000 --> 00:15:27,000
All right, so it takes two church numerals.

165
00:15:27,000 --> 00:15:29,000
If we're going to put them in the parameter list,

166
00:15:29,000 --> 00:15:33,000
we're probably going to have to use them in the body of the function, right?

167
00:15:33,000 --> 00:15:35,000
So let's consider a concrete example.

168
00:15:35,000 --> 00:15:40,000
Adding one and five should be the successor of five.

169
00:15:40,000 --> 00:15:44,000
Adding two and five should be the successor of five.

170
00:15:44,000 --> 00:15:49,000
Adding three to five should be the successor of successor of successor of five.

171
00:15:49,000 --> 00:15:52,000
But wait a second. What are we doing here?

172
00:15:52,000 --> 00:15:54,000
This is function composition, right?

173
00:15:54,000 --> 00:15:56,000
And what are church numerals?

174
00:15:56,000 --> 00:15:59,000
They create n-fold compositions.

175
00:15:59,000 --> 00:16:03,000
So that's the three-fold composition of successor.

176
00:16:04,000 --> 00:16:07,000
And if that's the three-fold composition of successor,

177
00:16:07,000 --> 00:16:11,000
we can generate that using a church numeral.

178
00:16:11,000 --> 00:16:19,000
This is saying adding three and five is doing thrice the successor of five.

179
00:16:19,000 --> 00:16:22,000
And that's our application there.

180
00:16:22,000 --> 00:16:25,000
So let's code it out.

181
00:16:25,000 --> 00:16:31,000
The add lambda calculus function takes an n and a k.

182
00:16:31,000 --> 00:16:37,000
And it does an n-fold succession on top of k.

183
00:16:37,000 --> 00:16:39,000
We'll try it.

184
00:16:39,000 --> 00:16:42,000
We'll do a convert this to JavaScript.

185
00:16:42,000 --> 00:16:49,000
We'll say add two church numerals like n-three and n-four, seven.

186
00:16:49,000 --> 00:16:51,000
It works.

187
00:16:51,000 --> 00:16:56,000
So let's redo this and start storing a couple more numbers for fun.

188
00:16:56,000 --> 00:17:01,000
Okay, n-seven is equal to that church numeral.

189
00:17:01,000 --> 00:17:05,000
And six is the addition of three and three.

190
00:17:05,000 --> 00:17:08,000
And five is the addition of two and three.

191
00:17:08,000 --> 00:17:15,000
So now we got the church numeral zero through seven, I believe.

192
00:17:15,000 --> 00:17:18,000
This is an Englishy way, but pure lambda calculus.

193
00:17:18,000 --> 00:17:22,000
Just all we have to do is replace our shorthand with the equivalent lambda notation

194
00:17:22,000 --> 00:17:25,000
to convert this into true lambda calculus.

195
00:17:25,000 --> 00:17:30,000
So you can see this n-three successor in five is saying thrice successor of five-fold,

196
00:17:30,000 --> 00:17:34,000
which is eight-fold. Nice.

197
00:17:34,000 --> 00:17:38,000
Church arithmetic, we now have addition.

198
00:17:38,000 --> 00:17:41,000
What about multiplication?

199
00:17:41,000 --> 00:17:43,000
What is it?

200
00:17:43,000 --> 00:17:45,000
Yeah.

201
00:17:45,000 --> 00:17:49,000
All right, so we know that multiplying two by three should give us six.

202
00:17:49,000 --> 00:17:54,000
But six is the six-fold composition of some function to an argument.

203
00:17:54,000 --> 00:17:58,000
Okay, so it's six f's that we apply to an argument.

204
00:17:58,000 --> 00:18:05,000
But six f's is also because composition is associative and commutative.

205
00:18:05,000 --> 00:18:06,000
It's not associative.

206
00:18:06,000 --> 00:18:07,000
Associative?

207
00:18:07,000 --> 00:18:10,000
Yeah, it's associative, but it's not commutative.

208
00:18:10,000 --> 00:18:13,000
It is associative.

209
00:18:13,000 --> 00:18:15,000
Function composition is associative.

210
00:18:15,000 --> 00:18:18,000
So this isn't just a six-fold composition of f.

211
00:18:18,000 --> 00:18:24,000
It's also the two-fold composition of the three-fold composition of f.

212
00:18:24,000 --> 00:18:28,000
Well, there's the three-fold composition, and I could just say n-three f to get that.

213
00:18:28,000 --> 00:18:33,000
And the two-fold composition of that is n-two of that.

214
00:18:33,000 --> 00:18:35,000
But now look what I've got here.

215
00:18:35,000 --> 00:18:37,000
I've got an a on the end on both sides.

216
00:18:37,000 --> 00:18:38,000
That just cancels out.

217
00:18:38,000 --> 00:18:40,000
Bye-bye.

218
00:18:40,000 --> 00:18:46,000
So multiplying two numbers and applying that new result to a function

219
00:18:46,000 --> 00:18:51,000
that first does that, you know, three-fold composition of f

220
00:18:51,000 --> 00:18:54,000
and then two-fold composition of that result.

221
00:18:54,000 --> 00:18:59,000
So we can use that, and we can go ahead and say, yeah, that's twice thricef,

222
00:18:59,000 --> 00:19:01,000
which is six-fold f.

223
00:19:01,000 --> 00:19:03,000
Makes sense.

224
00:19:03,000 --> 00:19:07,000
And we can write that down and say, yeah, sure, it's fine,

225
00:19:07,000 --> 00:19:08,000
but there's an even better way.

226
00:19:08,000 --> 00:19:15,000
Does anybody see it?

227
00:19:16,000 --> 00:19:19,000
I take an argument f, and I apply it to the right-most function.

228
00:19:19,000 --> 00:19:22,000
I take that result and apply it to the left-most function.

229
00:19:22,000 --> 00:19:24,000
That generates my result.

230
00:19:24,000 --> 00:19:27,000
That means it's really the composition of two and three.

231
00:19:27,000 --> 00:19:29,000
But look what I've got here on the sides.

232
00:19:29,000 --> 00:19:31,000
f and f, those cancel out.

233
00:19:31,000 --> 00:19:35,000
So multiplying two numbers is just getting their composition.

234
00:19:35,000 --> 00:19:39,000
But how do I get their composition, the lambda calculus, with the b-compinator?

235
00:19:39,000 --> 00:19:41,000
But wait a second.

236
00:19:41,000 --> 00:19:43,000
Two and three are arguments as well.

237
00:19:43,000 --> 00:19:44,000
I take that out.

238
00:19:44,000 --> 00:19:45,000
Oh, my gosh.

239
00:19:45,000 --> 00:19:48,000
Multiplication is just composition.

240
00:19:48,000 --> 00:19:51,000
Wow.

241
00:19:51,000 --> 00:19:53,000
That's amazing.

242
00:19:53,000 --> 00:19:55,000
These are identical functions.

243
00:19:55,000 --> 00:19:59,000
They're alpha-equivalent, meaning that all we've done is change the variable names around.

244
00:19:59,000 --> 00:20:02,000
But the really nice way of noting this is that multiplication

245
00:20:02,000 --> 00:20:05,000
is just the composition of trig mammals.

246
00:20:05,000 --> 00:20:09,000
So let's do this.

247
00:20:09,000 --> 00:20:12,000
Multi-equals b, we're done.

248
00:20:13,000 --> 00:20:15,000
We can demonstrate it, of course.

249
00:20:15,000 --> 00:20:22,000
js num of the multiplication of two and three is a mistake.

250
00:20:22,000 --> 00:20:24,000
What did I do wrong?

251
00:20:24,000 --> 00:20:26,000
G is not a function.

252
00:20:26,000 --> 00:20:30,000
Oh, I said two and three instead of my lambda two and lambda three.

253
00:20:30,000 --> 00:20:32,000
There we go, six.

254
00:20:32,000 --> 00:20:34,000
Neat.

255
00:20:34,000 --> 00:20:37,000
Do something fun that we haven't done before, like five and four.

256
00:20:37,000 --> 00:20:38,000
There's 20.

257
00:20:38,000 --> 00:20:41,000
That's nice.

258
00:20:41,000 --> 00:20:44,000
What about exponentiation?

259
00:20:44,000 --> 00:20:46,000
Hmm.

260
00:20:46,000 --> 00:20:49,000
Exponentiation.

261
00:20:49,000 --> 00:20:51,000
It's going to take two arguments.

262
00:20:51,000 --> 00:20:54,000
We know two to the third power is eight.

263
00:20:54,000 --> 00:20:56,000
How did you do this in grade school?

264
00:20:56,000 --> 00:21:00,000
What is two to the third?

265
00:21:00,000 --> 00:21:02,000
Yeah.

266
00:21:02,000 --> 00:21:07,000
But what's multiplication in the lambda calculus?

267
00:21:07,000 --> 00:21:09,000
Composition.

268
00:21:09,000 --> 00:21:11,000
And so we've done a three-fold composition of n two.

269
00:21:11,000 --> 00:21:17,000
How do we express that using trig numerals?

270
00:21:17,000 --> 00:21:19,000
How do you do the n-fold composition of anything?

271
00:21:19,000 --> 00:21:21,000
It's just a trig number.

272
00:21:21,000 --> 00:21:23,000
That's just n three n twos.

273
00:21:23,000 --> 00:21:25,000
But wait a second.

274
00:21:25,000 --> 00:21:29,000
That means a power just takes nk and it flips them around.

275
00:21:29,000 --> 00:21:32,000
This is the thrush combinator.

276
00:21:32,000 --> 00:21:34,000
Thrice of twice.

277
00:21:34,000 --> 00:21:36,000
Well, that's doing twice of twice of twice.

278
00:21:36,000 --> 00:21:39,000
Twice of twice of twice is eight-fold.

279
00:21:39,000 --> 00:21:42,000
Beautiful.

280
00:21:42,000 --> 00:21:45,000
Really nice.

281
00:21:45,000 --> 00:21:47,000
So we've added a combinator.

282
00:21:47,000 --> 00:21:49,000
We've added exponentiation.

283
00:21:49,000 --> 00:21:53,000
We'll define this.

284
00:21:53,000 --> 00:21:57,000
I'll say that this is pow.

285
00:21:57,000 --> 00:22:00,000
The thrush, I'll call it pow.

286
00:22:00,000 --> 00:22:05,000
It takes an n and a k and applies the k to n.

287
00:22:06,000 --> 00:22:10,000
And of course I can try it out.

288
00:22:10,000 --> 00:22:14,000
Raising three to the second power should give me nine.

289
00:22:14,000 --> 00:22:17,000
Oops, I did this again.

290
00:22:17,000 --> 00:22:21,000
There it is.

291
00:22:21,000 --> 00:22:24,000
And by the way, the thrush is the cardinal of identity.

292
00:22:24,000 --> 00:22:27,000
I don't find that particularly exciting, but it's cool, I guess.

293
00:22:27,000 --> 00:22:32,000
Just one more example of things going on in the combinatorial logic.

294
00:22:32,000 --> 00:22:37,000
We've got arithmetic uses of thrush.

295
00:22:37,000 --> 00:22:39,000
Here's a nice little one.

296
00:22:39,000 --> 00:22:41,000
I like this one. It's cute.

297
00:22:41,000 --> 00:22:43,000
Checking if something is zero.

298
00:22:43,000 --> 00:22:46,000
We know that if we give it zero, it should give us true.

299
00:22:46,000 --> 00:22:48,000
If we give it one, it should be false.

300
00:22:48,000 --> 00:22:49,000
Two should be false.

301
00:22:49,000 --> 00:22:50,000
And so on and so forth.

302
00:22:50,000 --> 00:22:52,000
It's pretty straightforward.

303
00:22:52,000 --> 00:22:54,000
How can we define this?

304
00:22:54,000 --> 00:22:55,000
It's a function.

305
00:22:55,000 --> 00:22:57,000
It takes a church numeral.

306
00:22:57,000 --> 00:22:59,000
Now here's where it gets interesting.

307
00:22:59,000 --> 00:23:02,000
Well, if you're going to get a numeral and use your parameter,

308
00:23:02,000 --> 00:23:05,000
you're probably going to have to use it in the function body.

309
00:23:05,000 --> 00:23:07,000
What do church numerals do?

310
00:23:07,000 --> 00:23:14,000
Where do they take its arguments?

311
00:23:14,000 --> 00:23:15,000
Does anybody remember?

312
00:23:15,000 --> 00:23:16,000
They take two arguments.

313
00:23:16,000 --> 00:23:19,000
What are the two arguments?

314
00:23:19,000 --> 00:23:26,000
When I say twice, yeah, twice a function applied to an argument.

315
00:23:26,000 --> 00:23:28,000
So that's what a church numeral does.

316
00:23:28,000 --> 00:23:32,000
It applies some function a certain number of times to an argument.

317
00:23:32,000 --> 00:23:35,000
Well, what if n is zero?

318
00:23:35,000 --> 00:23:38,000
It doesn't apply the function at all.

319
00:23:38,000 --> 00:23:40,000
It just returns the second thing.

320
00:23:40,000 --> 00:23:44,000
The function I'm trying to create here is the is zero function.

321
00:23:44,000 --> 00:23:46,000
So if n is zero, it's just going to return arg.

322
00:23:46,000 --> 00:23:52,000
So what should arg be?

323
00:23:52,000 --> 00:23:56,000
True.

324
00:23:56,000 --> 00:23:59,000
And n is zero, return true.

325
00:23:59,000 --> 00:24:01,000
Pretty straightforward.

326
00:24:01,000 --> 00:24:02,000
Skip the function.

327
00:24:02,000 --> 00:24:03,000
Forget about it.

328
00:24:03,000 --> 00:24:05,000
Don't run it.

329
00:24:05,000 --> 00:24:06,000
Well, that's nice.

330
00:24:06,000 --> 00:24:07,000
But what about the other case?

331
00:24:07,000 --> 00:24:12,000
What if it's one or two or something else?

332
00:24:12,000 --> 00:24:14,000
We want it to return false.

333
00:24:14,000 --> 00:24:17,000
So somehow, however many times we do funk,

334
00:24:17,000 --> 00:24:21,000
if we do it once, twice, thrice a billion times,

335
00:24:21,000 --> 00:24:23,000
no matter how many times we do funk,

336
00:24:23,000 --> 00:24:25,000
it's got to return false.

337
00:24:25,000 --> 00:24:32,000
What's a function that always returns false?

338
00:24:32,000 --> 00:24:33,000
Not quite.

339
00:24:33,000 --> 00:24:36,000
The false function takes two arguments and chooses the second.

340
00:24:36,000 --> 00:24:44,000
What's a function that always returns false?

341
00:24:44,000 --> 00:24:54,000
This is going way back.

342
00:24:55,000 --> 00:24:58,000
Remember how I showed you that the kestrel with one argument

343
00:24:58,000 --> 00:25:00,000
is a constant function?

344
00:25:00,000 --> 00:25:01,000
It's fixated.

345
00:25:01,000 --> 00:25:03,000
It always returns a given argument.

346
00:25:03,000 --> 00:25:10,000
So apply the constant false function n times true.

347
00:25:10,000 --> 00:25:13,000
If I do this three times, that's the constant false

348
00:25:13,000 --> 00:25:16,000
of constant false of constant false of true.

349
00:25:16,000 --> 00:25:17,000
But who cares?

350
00:25:17,000 --> 00:25:23,000
Because the constant false function always gives you back false.

351
00:25:23,000 --> 00:25:26,000
And the only time this gives you true is if you don't run

352
00:25:26,000 --> 00:25:28,000
the constant false function at all,

353
00:25:28,000 --> 00:25:31,000
which happens when n is zero.

354
00:25:31,000 --> 00:25:32,000
I think that's kind of neat.

355
00:25:32,000 --> 00:25:33,000
Let's do that.

356
00:25:33,000 --> 00:25:35,000
Clear this up.

357
00:25:35,000 --> 00:25:38,000
Is zero takes a church numeral,

358
00:25:38,000 --> 00:25:42,000
flies the church numeral to the constant false function

359
00:25:42,000 --> 00:25:45,000
and to true.

360
00:25:45,000 --> 00:25:52,000
And we can check if a church numeral like n7 is zero.

361
00:25:52,000 --> 00:25:54,000
Zero, well, it's not.

362
00:25:54,000 --> 00:26:01,000
One is also not, but zero is.

363
00:26:01,000 --> 00:26:06,000
So we've got our first merging of booleans and arithmetic.

364
00:26:06,000 --> 00:26:08,000
Multi-type functions go on here.

365
00:26:08,000 --> 00:26:11,000
It takes in a number and gives you back a boolean.

366
00:26:11,000 --> 00:26:13,000
Interesting.

367
00:26:13,000 --> 00:26:16,000
We've defined addition, multiplication,

368
00:26:16,000 --> 00:26:21,000
exponentiation from scratch with no numbers, no operators.

369
00:26:21,000 --> 00:26:23,000
I'm not subtracting by one.

370
00:26:23,000 --> 00:26:25,000
How hard could it be?

371
00:26:25,000 --> 00:26:27,000
This bird knows how to do it.

372
00:26:27,000 --> 00:26:30,000
Take out a dollar.

373
00:26:30,000 --> 00:26:33,000
Oh, dear.

374
00:26:33,000 --> 00:26:36,000
Yeah, I'm not going to explain this one to you.

375
00:26:36,000 --> 00:26:38,000
It took me a long time to get this.

376
00:26:38,000 --> 00:26:40,000
Then I tried to write an explanation for it,

377
00:26:40,000 --> 00:26:43,000
and it was like a page of size 12 font.

378
00:26:43,000 --> 00:26:47,000
It's like, no, we're going to skip that for a minute,

379
00:26:47,000 --> 00:26:50,000
and we're going to teach you data structures in lambda calculus.

380
00:26:50,000 --> 00:26:52,000
Just one data structure.

381
00:26:52,000 --> 00:26:54,000
It's the smallest one.

382
00:26:54,000 --> 00:26:57,000
The virio.

383
00:26:57,000 --> 00:27:02,000
The virio takes two arguments and holds onto them.

384
00:27:02,000 --> 00:27:04,000
It pairs things together.

385
00:27:04,000 --> 00:27:08,000
And then you've got a box that's closed over two arguments.

386
00:27:08,000 --> 00:27:12,000
You can move the box around, do things that they put in other boxes.

387
00:27:12,000 --> 00:27:15,000
And when you want to access the things in the box,

388
00:27:15,000 --> 00:27:17,000
you give the box a function,

389
00:27:17,000 --> 00:27:21,000
and that function gets those two arguments.

390
00:27:21,000 --> 00:27:23,000
It's closures.

391
00:27:23,000 --> 00:27:26,000
Using closures as data structures.

392
00:27:26,000 --> 00:27:28,000
So let's code it out.

393
00:27:28,000 --> 00:27:32,000
The virio takes an A and a B,

394
00:27:32,000 --> 00:27:34,000
and then waits for a function.

395
00:27:34,000 --> 00:27:36,000
And once you give it a function,

396
00:27:36,000 --> 00:27:40,000
it supplies A and B to the function.

397
00:27:40,000 --> 00:27:44,000
That's the pair function.

398
00:27:44,000 --> 00:27:46,000
There's a vim joke in there somewhere,

399
00:27:46,000 --> 00:27:48,000
so let's get that.

400
00:27:48,000 --> 00:27:52,000
The virio, the pair of identity and mockingbird,

401
00:27:52,000 --> 00:27:56,000
is a function that holds onto the identity of mockingbird

402
00:27:56,000 --> 00:27:59,000
and provides you an interface for interacting with it.

403
00:27:59,000 --> 00:28:04,000
Give me a function, and I'll give you these two things that I'm holding onto.

404
00:28:04,000 --> 00:28:08,000
So what if we give it the kestrel?

405
00:28:08,000 --> 00:28:15,000
What do we get back?

406
00:28:15,000 --> 00:28:17,000
What's that?

407
00:28:17,000 --> 00:28:19,000
The kestrel comes into the function as f.

408
00:28:19,000 --> 00:28:21,000
The kestrel takes two arguments, i and m,

409
00:28:21,000 --> 00:28:24,000
and gives you back the first one.

410
00:28:24,000 --> 00:28:27,000
The virio of i and m.

411
00:28:27,000 --> 00:28:31,000
We'll call this vim for fun.

412
00:28:31,000 --> 00:28:36,000
If I supply the virio with first,

413
00:28:36,000 --> 00:28:38,000
it gives me back identity.

414
00:28:38,000 --> 00:28:44,000
If I supply it with kite, what is it going to give me?

415
00:28:45,000 --> 00:28:50,000
The virio of i and m holds onto i and m.

416
00:28:50,000 --> 00:28:55,000
If I give it a function, it applies that function to two things, i and m.

417
00:28:55,000 --> 00:28:57,000
There it is.

418
00:28:57,000 --> 00:29:00,000
So this vim thing is a box holding onto my two arguments,

419
00:29:00,000 --> 00:29:06,000
and it can get access to them by passing them functions.

420
00:29:06,000 --> 00:29:11,000
This is a purely functional data structure,

421
00:29:11,000 --> 00:29:15,000
like a birdhouse for a pair of birds.

422
00:29:15,000 --> 00:29:18,000
That one was a stretch.

423
00:29:18,000 --> 00:29:20,000
So there it is.

424
00:29:20,000 --> 00:29:23,000
It's also the composition of the cardinal and the fresh.

425
00:29:23,000 --> 00:29:27,000
Again, I'm not too excited about that, but cool, okay.

426
00:29:27,000 --> 00:29:29,000
And we got church pairs.

427
00:29:29,000 --> 00:29:31,000
Pairing things is the virio.

428
00:29:31,000 --> 00:29:33,000
Pairs to arguments.

429
00:29:33,000 --> 00:29:35,000
What are these two functions?

430
00:29:35,000 --> 00:29:38,000
This one takes a pair and calls the pair with the kestrel.

431
00:29:38,000 --> 00:29:40,000
The kite.

432
00:29:40,000 --> 00:29:47,000
What do these do?

433
00:29:47,000 --> 00:29:52,000
If the pair or the virio is holding onto two elements, two items,

434
00:29:52,000 --> 00:29:56,000
and you give it kestrel, what do you get back?

435
00:29:56,000 --> 00:29:58,000
The first one.

436
00:29:58,000 --> 00:30:02,000
And that means if you give it the kite, you get the second one.

437
00:30:02,000 --> 00:30:04,000
So let's define those.

438
00:30:04,000 --> 00:30:07,000
They're just syntactic sugar for what we just did.

439
00:30:07,000 --> 00:30:11,000
First takes a pair and it calls the pair with the kestrel.

440
00:30:11,000 --> 00:30:17,000
Second takes a pair and it calls the pair with the kite.

441
00:30:17,000 --> 00:30:28,000
So the vim, the first of vim is I, and the second of vim is M.

442
00:30:28,000 --> 00:30:30,000
First and second.

443
00:30:30,000 --> 00:30:34,000
Extract elements from our pair.

444
00:30:34,000 --> 00:30:36,000
Closures.

445
00:30:36,000 --> 00:30:37,000
Beautiful.

446
00:30:37,000 --> 00:30:38,000
Wonderful.

447
00:30:38,000 --> 00:30:39,000
Here's an interesting one.

448
00:30:39,000 --> 00:30:42,000
The reason I'm showing you this is not obvious right now.

449
00:30:42,000 --> 00:30:45,000
This is the Phi combinator function.

450
00:30:45,000 --> 00:30:47,000
Maybe it's a combinator?

451
00:30:47,000 --> 00:30:48,000
I don't know.

452
00:30:48,000 --> 00:30:49,000
It's the Phi function.

453
00:30:49,000 --> 00:30:50,000
What does it do?

454
00:30:50,000 --> 00:30:51,000
It's a little weird.

455
00:30:51,000 --> 00:30:54,000
I'm going to use this red parens with a comma to mean a pair.

456
00:30:54,000 --> 00:30:57,000
Because I don't want to have to show you pair of M and N7.

457
00:30:57,000 --> 00:30:59,000
It gets verbose.

458
00:30:59,000 --> 00:31:02,000
So just imagine I paired those two things together with the virio.

459
00:31:02,000 --> 00:31:04,000
I'm calling Phi on this.

460
00:31:04,000 --> 00:31:06,000
Let's look at what it does.

461
00:31:06,000 --> 00:31:08,000
Well, it generates a new pair.

462
00:31:08,000 --> 00:31:11,000
It pairs two new things together.

463
00:31:11,000 --> 00:31:15,000
The first thing in the pair is the second of the old pair.

464
00:31:15,000 --> 00:31:21,000
The next thing of the pair is the successor of the second of the old pair.

465
00:31:21,000 --> 00:31:24,000
Okay, not too bad.

466
00:31:24,000 --> 00:31:26,000
Let's do it together now ourselves.

467
00:31:26,000 --> 00:31:30,000
What does this generate?

468
00:31:30,000 --> 00:31:33,000
Phi of M3.

469
00:31:33,000 --> 00:31:40,000
It shifts the second thing to the first thing and it increments the second thing.

470
00:31:40,000 --> 00:31:43,000
Okay, that's what the Phi combinator does to pairs.

471
00:31:43,000 --> 00:31:46,000
What's Phi of 0, 0?

472
00:31:46,000 --> 00:31:49,000
Phi of 0, 1?

473
00:31:49,000 --> 00:31:51,000
Phi of 1, 2?

474
00:31:51,000 --> 00:31:53,000
2, 3?

475
00:31:53,000 --> 00:31:59,000
What's 8 applications of Phi to 0, 0?

476
00:31:59,000 --> 00:32:01,000
Someone say it out loud.

477
00:32:01,000 --> 00:32:09,000
Say it proud.

478
00:32:09,000 --> 00:32:13,000
Just look at the pattern.

479
00:32:13,000 --> 00:32:18,000
1 application of Phi to 0, 0 gave you a 1 on the right and a 0 on the left.

480
00:32:18,000 --> 00:32:22,000
3 applications of Phi gave you a 3 on the right and a 2 on the left.

481
00:32:22,000 --> 00:32:25,000
What's 8 applications going to do?

482
00:32:25,000 --> 00:32:28,000
8 on the right, 7 on the left.

483
00:32:28,000 --> 00:32:34,000
Aha, what's the first of that?

484
00:32:34,000 --> 00:32:37,000
It's 7.

485
00:32:37,000 --> 00:32:39,000
I've got subtraction.

486
00:32:39,000 --> 00:32:42,000
I've got subtraction, Eureka.

487
00:32:42,000 --> 00:32:44,000
This is my predecessor function.

488
00:32:44,000 --> 00:32:46,000
I can subtract by 1.

489
00:32:46,000 --> 00:32:50,000
Let's make sure I have the Phi combinator written down first because I don't think I do.

490
00:32:50,000 --> 00:32:52,000
Nope, I don't.

491
00:32:52,000 --> 00:32:56,000
Okay, what's Phi do?

492
00:32:56,000 --> 00:33:08,000
It takes a pair and it pairs together the second of the pair along with the successor of the second of the pair.

493
00:33:08,000 --> 00:33:10,000
1, 2, 3?

494
00:33:10,000 --> 00:33:13,000
Okay, that makes sense.

495
00:33:13,000 --> 00:33:17,000
I'll just double check that it works.

496
00:33:18,000 --> 00:33:22,000
Vim doesn't have a number in it, so I've got a pair together or something.

497
00:33:22,000 --> 00:33:25,000
Who cares what the first thing is?

498
00:33:25,000 --> 00:33:30,000
N3, I guess.

499
00:33:30,000 --> 00:33:32,000
Does that make sense?

500
00:33:32,000 --> 00:33:35,000
Phi of that, and I'll get the first thing of this.

501
00:33:35,000 --> 00:33:39,000
I'll get its js num form.

502
00:33:39,000 --> 00:33:42,000
And I've made a mistake.

503
00:33:42,000 --> 00:33:47,000
F is not a function.

504
00:33:47,000 --> 00:33:52,000
Let's double check this inside out.

505
00:33:52,000 --> 00:33:54,000
Does that work?

506
00:33:54,000 --> 00:33:56,000
Yeah, it gives me a function.

507
00:33:56,000 --> 00:34:02,000
Phi of that, what about the first of this?

508
00:34:02,000 --> 00:34:04,000
Also a function.

509
00:34:04,000 --> 00:34:06,000
What about the js num of that?

510
00:34:06,000 --> 00:34:08,000
That's where it throws.

511
00:34:08,000 --> 00:34:11,000
I've made a mistake somewhere.

512
00:34:11,000 --> 00:34:15,000
What does Phi look like?

513
00:34:15,000 --> 00:34:17,000
Phi takes a pair.

514
00:34:17,000 --> 00:34:23,000
It pairs together the second of P.

515
00:34:23,000 --> 00:34:25,000
Sorry?

516
00:34:25,000 --> 00:34:27,000
Yes, it is very much so.

517
00:34:27,000 --> 00:34:29,000
Very much so.

518
00:34:29,000 --> 00:34:36,000
Successor's second of P.

519
00:34:36,000 --> 00:34:38,000
No, I'm not sure.

520
00:34:38,000 --> 00:34:40,000
What were you going to say?

521
00:34:40,000 --> 00:34:51,000
Yes, that's what I'm trying to do, but it's getting confused.

522
00:34:51,000 --> 00:34:55,000
Pair together the second thing with the successor of the second thing.

523
00:34:55,000 --> 00:34:58,000
That feels right to me.

524
00:34:58,000 --> 00:35:02,000
Let's call Phi on pairing.

525
00:35:02,000 --> 00:35:04,000
Oh, I think that's the problem I did.

526
00:35:04,000 --> 00:35:09,000
Pair together N0 and N0.

527
00:35:09,000 --> 00:35:12,000
That's fine.

528
00:35:12,000 --> 00:35:16,000
If I get the first of that, that's function 0.

529
00:35:16,000 --> 00:35:24,000
Now if I do something like N4, that's a function and I can convert it.

530
00:35:24,000 --> 00:35:26,000
The first of that is that.

531
00:35:26,000 --> 00:35:34,000
What about the second?

532
00:35:34,000 --> 00:35:37,000
The second of that should be 5.

533
00:35:37,000 --> 00:35:38,000
It does work.

534
00:35:38,000 --> 00:35:40,000
I was just messing up something somewhere.

535
00:35:40,000 --> 00:35:42,000
Who knows?

536
00:35:42,000 --> 00:35:45,000
That's my predecessor.

537
00:35:45,000 --> 00:35:46,000
Write it down.

538
00:35:46,000 --> 00:35:48,000
We're almost at the end.

539
00:35:48,000 --> 00:35:51,000
You're troopers for staying this long.

540
00:35:51,000 --> 00:36:06,000
Predecessor of N is the first of N applications of Phi to the pair of N0 and N0.

541
00:36:06,000 --> 00:36:08,000
I've got to watch my friends here.

542
00:36:08,000 --> 00:36:09,000
Close the pair.

543
00:36:09,000 --> 00:36:11,000
Close the first.

544
00:36:11,000 --> 00:36:13,000
All right, there's my predecessor.

545
00:36:13,000 --> 00:36:17,000
We'll get the JS version of the predecessor of N7.

546
00:36:17,000 --> 00:36:19,000
It is a mistake.

547
00:36:19,000 --> 00:36:21,000
Pair is not defined.

548
00:36:21,000 --> 00:36:22,000
Oh, okay.

549
00:36:22,000 --> 00:36:27,000
Because I said this is burial.

550
00:36:27,000 --> 00:36:28,000
6.

551
00:36:28,000 --> 00:36:30,000
Predecessor of 7, 6.

552
00:36:30,000 --> 00:36:34,000
Wow.

553
00:36:34,000 --> 00:36:40,000
There was our totally impossible, crazy predecessor and here's our beautiful data structures-based

554
00:36:40,000 --> 00:36:44,000
predecessor where we count up, but we always remember the last thing, too.

555
00:36:44,000 --> 00:36:45,000
That's all we're doing.

556
00:36:45,000 --> 00:36:49,000
Counting up, remembering the previous thing.

557
00:36:49,000 --> 00:36:51,000
I'm going to fly through this bit.

558
00:36:51,000 --> 00:36:56,000
Subtraction is just doing K predecessors to N.

559
00:36:56,000 --> 00:37:06,000
Less than or equal to is just subtracting K from N and seeing if we bottom out and checking if that's 0.

560
00:37:06,000 --> 00:37:11,000
Equality is just checking if it's less than or equal to in both directions.

561
00:37:11,000 --> 00:37:19,000
If they're less than or equal to in both directions, then they must be equal because there's no other way that that would make sense.

562
00:37:19,000 --> 00:37:21,000
So we got those things.

563
00:37:21,000 --> 00:37:22,000
Greater than.

564
00:37:22,000 --> 00:37:27,000
This one's fun because it's clearly not less than or equal to, right?

565
00:37:27,000 --> 00:37:35,000
So we got an N and a K and an N and a K, but that looks kind of like function composition, except it's binary function composition.

566
00:37:35,000 --> 00:37:37,000
The rightmost function doesn't take a single input.

567
00:37:37,000 --> 00:37:39,000
It takes two inputs.

568
00:37:39,000 --> 00:37:43,000
So we can't simply say it's the bluebird of not and less than or equal to.

569
00:37:43,000 --> 00:37:45,000
That doesn't work.

570
00:37:45,000 --> 00:37:53,000
We need some new combinator that does two arguments for the right function and then the result into the second function.

571
00:37:53,000 --> 00:37:57,000
And that combinator is the blackbird.

572
00:37:57,000 --> 00:38:03,000
So the blackbird, let's say the blackbird of not less than or equal to is greater than.

573
00:38:03,000 --> 00:38:07,000
This is, we're really starting to cook with gas here.

574
00:38:07,000 --> 00:38:10,000
You know what is absolutely mind blowing to me?

575
00:38:10,000 --> 00:38:17,000
The blackbird is the composition of composition and composition.

576
00:38:17,000 --> 00:38:23,000
Put that in your pipe and smoke it.

577
00:38:23,000 --> 00:38:27,000
All right, and then we hit the conclusion of the talk, which is actually in part one.

578
00:38:27,000 --> 00:38:31,000
So that's the entire talk.

579
00:38:31,000 --> 00:38:35,000
Thank you very much.

580
00:38:35,000 --> 00:38:38,000
Pretty mind blowing stuff.

581
00:38:38,000 --> 00:38:40,000
And guess what? This can keep on going on and on.

582
00:38:40,000 --> 00:38:43,000
We can do infinite lists of data structures that hold other lists.

583
00:38:43,000 --> 00:38:48,000
And you could have, if the list has a head or a tail and is empty, and it just keeps going out from there.

584
00:38:48,000 --> 00:38:50,000
And you can build up an entire language that way.

585
00:38:50,000 --> 00:38:54,000
And people have, and they're called functional programming languages.

586
00:38:54,000 --> 00:38:59,000
Now, real functional programming languages don't use church numerals, because that would be ridiculous.

587
00:38:59,000 --> 00:39:04,000
Because if you wanted to calculate something with 50 million, you have to do 50 million function implications.

588
00:39:04,000 --> 00:39:07,000
So real functional programming languages take shortcuts.

589
00:39:07,000 --> 00:39:11,000
They let you do things with numbers that are actually using hardware based math.

590
00:39:11,000 --> 00:39:16,000
So the compiler has to compile down to Turing machine, stateful computations.

591
00:39:16,000 --> 00:39:22,000
But as much as possible, the languages have this backbone of lambda calculus built into them,

592
00:39:22,000 --> 00:39:26,000
which proves very useful in a variety of situations.

593
00:39:26,000 --> 00:39:30,000
Any questions before I stop the recording?

594
00:39:30,000 --> 00:39:36,000
Anything beyond a pair are sort of like, well done, like you're talking about?

595
00:39:36,000 --> 00:39:41,000
Yeah, so you can make a list by doing a pair whose second element is a pair,

596
00:39:41,000 --> 00:39:44,000
whose second element is a pair, and so on and so forth.

597
00:39:44,000 --> 00:39:47,000
And then one of the elements of the pair, like the first element,

598
00:39:47,000 --> 00:39:52,000
is always like a flag of whether it's the end of the list or not, or something like that.

599
00:39:52,000 --> 00:39:54,000
And you start to do equation checks.

600
00:39:54,000 --> 00:39:59,000
So like if this first element is, or the first element is the element you're holding on to,

601
00:39:59,000 --> 00:40:02,000
and the second element is the continuation of the list.

602
00:40:02,000 --> 00:40:07,000
And if the continuation of the list is not a new pair, but it's some other value, like zero,

603
00:40:07,000 --> 00:40:12,000
then that's the end of the list.

604
00:40:12,000 --> 00:40:16,000
Right, the empty list is zero or something like that.

605
00:40:16,000 --> 00:40:19,000
Or it's a pair of zero and zero or something.

606
00:40:19,000 --> 00:40:22,000
So all sorts of interesting ways of building this out.

607
00:40:22,000 --> 00:40:25,000
Some of those resources I have show how you can do that.

608
00:40:25,000 --> 00:40:36,000
And it's not, it's really not too difficult once you've got this kind of way of thinking about functions down.

609
00:40:36,000 --> 00:40:43,000
But as I said before, I really think that does this make you a better functional programmer?

610
00:40:43,000 --> 00:40:45,000
Only in a very indirect way.

611
00:40:45,000 --> 00:40:52,000
A mental workout slash being very comfortable with currying and partial function application and higher order functions.

612
00:40:52,000 --> 00:40:58,000
And some of those combinators are useful like composition and flip and ID and constant.

613
00:40:58,000 --> 00:41:00,000
There's a reason those are built into Haskell.

614
00:41:00,000 --> 00:41:04,000
They show up again and again and again in very practical examples.

615
00:41:04,000 --> 00:41:10,000
So being familiar with these things gives you a little bit of a boost or a leg up or a formal way of thinking about them.

616
00:41:10,000 --> 00:41:14,000
And if you want to go make your own functional programming language, that's cool too.

617
00:41:14,000 --> 00:41:17,000
But why do this?

618
00:41:17,000 --> 00:41:19,000
I don't think it's necessary at all.

619
00:41:19,000 --> 00:41:20,000
I think it's nice.

620
00:41:20,000 --> 00:41:23,000
I think it's interesting and I hope you think so too.

621
00:41:23,000 --> 00:41:27,000
As evidenced by the fact that you're here at 834.

622
00:41:27,000 --> 00:41:29,000
So thank you all very much.

623
00:41:29,000 --> 00:41:33,000
You've been a really great audience and have a good night.

