1
00:00:00,000 --> 00:00:02,280
Hello, can everyone hear me?

2
00:00:02,280 --> 00:00:03,880
The mic on and everything.

3
00:00:03,880 --> 00:00:04,960
Good to go.

4
00:00:04,960 --> 00:00:06,040
Thank you, Boodle.

5
00:00:06,040 --> 00:00:07,880
And thank you for having me here.

6
00:00:07,880 --> 00:00:11,160
All right, I had a totally different talk plan

7
00:00:11,160 --> 00:00:13,280
and then Phil's talk was really cool.

8
00:00:13,280 --> 00:00:15,360
And then I was like, oh, I'll do something

9
00:00:15,360 --> 00:00:17,440
with Lambda Calculus and Mini-Canron.

10
00:00:17,440 --> 00:00:19,160
And then I was talking to people last night

11
00:00:19,160 --> 00:00:24,160
and basically Andrea and Mark and Stefan,

12
00:00:25,080 --> 00:00:27,400
a few other people convinced me to try something

13
00:00:27,400 --> 00:00:29,560
like much more radical than I normally do

14
00:00:29,560 --> 00:00:30,760
with my live coding.

15
00:00:30,760 --> 00:00:33,520
So I want you all to be doing live coding,

16
00:00:33,520 --> 00:00:34,880
at least anyone who's interested.

17
00:00:34,880 --> 00:00:39,880
So if you can get out your lapis and go to this URL,

18
00:00:42,080 --> 00:00:46,800
and that holds doubly true for anyone watching on video.

19
00:00:46,800 --> 00:00:49,640
This is specially designed so that people in the audience

20
00:00:49,640 --> 00:00:52,640
and people on video can kind of follow along.

21
00:00:52,640 --> 00:00:54,720
And basically what I'm gonna do is I'm gonna check in

22
00:00:54,720 --> 00:00:57,200
the code as I'm talking and I'll let you know

23
00:00:57,200 --> 00:00:58,800
when I did a check-in so you can do a poll,

24
00:00:58,800 --> 00:01:00,400
so you can sync up with me.

25
00:01:00,400 --> 00:01:04,360
And there's a really cool web-based version

26
00:01:04,360 --> 00:01:06,400
of Mini-Canron that David Kahn created.

27
00:01:06,400 --> 00:01:10,720
And you can just paste that code into the web browser

28
00:01:10,720 --> 00:01:13,400
and you should be able to run Mini-Canron, okay?

29
00:01:13,400 --> 00:01:16,000
So we'll try that and it might crash and burn.

30
00:01:16,000 --> 00:01:17,400
We'll just see how it goes.

31
00:01:17,400 --> 00:01:19,440
But the great thing is if someone's watching a video

32
00:01:19,440 --> 00:01:21,960
afterwards they should be able to follow along and stop.

33
00:01:21,960 --> 00:01:25,000
And if anyone here is confused about something,

34
00:01:25,000 --> 00:01:26,520
you can't get an example to run or whatever,

35
00:01:26,520 --> 00:01:28,160
you can ask a question, okay?

36
00:01:28,160 --> 00:01:29,440
Or you can take it offline, whatever.

37
00:01:29,440 --> 00:01:32,440
But it's one thing to show this stuff,

38
00:01:32,440 --> 00:01:34,600
but at some point people will have all these questions

39
00:01:34,600 --> 00:01:36,720
and if you can't really play with it,

40
00:01:36,720 --> 00:01:39,720
you don't really get the sense, I think, of what it's about.

41
00:01:39,720 --> 00:01:41,720
So I want everyone to be able to try it.

42
00:01:42,880 --> 00:01:47,880
Okay, so the web browser version of Mini-Canron

43
00:01:48,280 --> 00:01:51,340
is at this link right here, the veneer stuff, okay?

44
00:01:52,720 --> 00:01:53,560
All right.

45
00:01:54,000 --> 00:01:58,320
So here's my repo and I've got a file called talk.scm

46
00:01:58,320 --> 00:02:00,560
and that's where I'm gonna have my code in it.

47
00:02:00,560 --> 00:02:03,720
And the way I'm gonna do this is I'm gonna basically type

48
00:02:03,720 --> 00:02:08,400
into the code into Emacs and then I'll paste it into veneer

49
00:02:08,400 --> 00:02:11,200
and that's basically what y'all can do in terms of

50
00:02:11,200 --> 00:02:14,240
opening up the file and get pasting into veneer,

51
00:02:14,240 --> 00:02:16,280
running it and you can edit it in your own text editor,

52
00:02:16,280 --> 00:02:17,400
you can edit it in veneer.

53
00:02:17,400 --> 00:02:20,560
And I encourage you to try some different combinations

54
00:02:20,560 --> 00:02:22,920
or different queries and see if you can break it,

55
00:02:23,120 --> 00:02:24,440
see if you can run in infinite loops,

56
00:02:24,440 --> 00:02:27,640
which you probably can, and so forth.

57
00:02:27,640 --> 00:02:30,360
And if you have a cool example, you can share it.

58
00:02:30,360 --> 00:02:35,360
This is, by the way, like version 0.01 of the technology

59
00:02:35,560 --> 00:02:37,560
I would really like for giving interactive talks

60
00:02:37,560 --> 00:02:42,000
where either Super Emacs mode or a web browser

61
00:02:42,000 --> 00:02:43,440
or something like that where people in the audience

62
00:02:43,440 --> 00:02:45,560
really could do this more seamlessly,

63
00:02:45,560 --> 00:02:48,200
but that's tech I'm working on with other people

64
00:02:48,200 --> 00:02:49,400
like Michael Valentine.

65
00:02:50,400 --> 00:02:54,280
All right, so let's talk about mini-canon

66
00:02:54,280 --> 00:02:58,280
and I'm gonna bring up the veneer editor,

67
00:02:58,280 --> 00:02:59,120
let me refresh.

68
00:02:59,120 --> 00:03:00,960
If veneer ever gets in a bad state,

69
00:03:00,960 --> 00:03:02,520
you can just click refresh.

70
00:03:04,840 --> 00:03:09,840
Let's see, is there, I can kind of make the font bigger.

71
00:03:09,880 --> 00:03:13,920
The way you use veneer is if you've got code

72
00:03:13,920 --> 00:03:15,760
on the left-hand side, you click the run button

73
00:03:15,760 --> 00:03:18,960
and it'll evaluate this code and there's like

74
00:03:18,960 --> 00:03:20,560
a little redeval print loop thing

75
00:03:20,560 --> 00:03:22,160
you can just type for small expressions

76
00:03:22,160 --> 00:03:23,760
if you wanna try those, okay?

77
00:03:25,080 --> 00:03:27,240
And this is a relational scheme interpreter,

78
00:03:27,240 --> 00:03:30,320
which we'll play around with something like that in a minute.

79
00:03:30,320 --> 00:03:31,880
The main button you're gonna care about

80
00:03:31,880 --> 00:03:33,640
is this create file button.

81
00:03:33,640 --> 00:03:37,000
So if you create file, it's gonna blank whatever's

82
00:03:37,000 --> 00:03:39,640
on the left, then you can just type in code here,

83
00:03:39,640 --> 00:03:42,200
mini-canon code, and then click run

84
00:03:42,200 --> 00:03:44,600
and it'll be evaluated on the right-hand side.

85
00:03:44,600 --> 00:03:47,240
So let's just try something simple.

86
00:03:49,080 --> 00:03:52,520
So I said I'll go to Emacs, but well,

87
00:03:52,520 --> 00:03:54,000
let me try doing it in the veneer.

88
00:03:54,000 --> 00:03:55,640
First of all, is the font big enough?

89
00:03:55,640 --> 00:03:56,480
Can people see that?

90
00:03:56,480 --> 00:03:58,280
I can try to bump it up a little bit.

91
00:04:02,520 --> 00:04:03,760
If the run button will cooperate.

92
00:04:03,760 --> 00:04:07,300
Maybe I can, there we go, look.

93
00:04:08,800 --> 00:04:10,280
That run button's oversized.

94
00:04:10,280 --> 00:04:12,360
Okay, so the first thing I'm gonna show,

95
00:04:12,360 --> 00:04:15,240
so mini-canon, core mini-canon only has three operators.

96
00:04:15,240 --> 00:04:17,160
It's a very small language, just like lambda calculus

97
00:04:17,160 --> 00:04:18,080
is very small, right?

98
00:04:18,120 --> 00:04:21,080
Lambda calculus has three parts,

99
00:04:21,080 --> 00:04:23,480
and so does mini-canon for the core parts of the language.

100
00:04:23,480 --> 00:04:25,240
And you can extend it, just like you can extend

101
00:04:25,240 --> 00:04:27,280
mini-canon to get something like scheme, right?

102
00:04:27,280 --> 00:04:31,560
So the most fundamental operator in mini-canon,

103
00:04:31,560 --> 00:04:33,760
and mini-canon's a type of logic programming language,

104
00:04:33,760 --> 00:04:37,200
like Prolog, it's got some real differences as well,

105
00:04:37,200 --> 00:04:39,840
the fundamental operator is something called unification.

106
00:04:39,840 --> 00:04:41,720
And unification you can think of as sort of like

107
00:04:41,720 --> 00:04:44,800
a two-way super pattern matcher.

108
00:04:44,800 --> 00:04:47,000
So if you're familiar with pattern matching,

109
00:04:47,000 --> 00:04:49,440
then in a pattern match, you have some value

110
00:04:49,440 --> 00:04:51,520
you're pattern matching against,

111
00:04:51,520 --> 00:04:54,520
and then you've got some sort of pattern, right?

112
00:04:54,520 --> 00:04:56,520
And in the pattern, you can have variables,

113
00:04:56,520 --> 00:04:59,600
we call those match variables, or pattern variables, okay?

114
00:04:59,600 --> 00:05:02,080
And those pattern variables get values filled in

115
00:05:02,080 --> 00:05:04,480
from the value you're matching is.

116
00:05:04,480 --> 00:05:07,200
Similar with unification, except you can have essentially

117
00:05:07,200 --> 00:05:12,200
pattern variables on each side, okay?

118
00:05:13,520 --> 00:05:16,680
So you can have variables on both sides.

119
00:05:16,680 --> 00:05:19,320
And the variables don't actually ever have to be filled in.

120
00:05:19,320 --> 00:05:21,080
That's fine also.

121
00:05:21,080 --> 00:05:24,840
Variables don't ever have to get values in this paradigm.

122
00:05:24,840 --> 00:05:26,240
So here we're gonna do something simple,

123
00:05:26,240 --> 00:05:30,680
and you can also think of unification,

124
00:05:30,680 --> 00:05:33,120
we call it equal, equal here really.

125
00:05:33,120 --> 00:05:35,920
It's like a type of a quality operator also.

126
00:05:35,920 --> 00:05:40,920
So here we're asking whether or not five is equal to five.

127
00:05:40,920 --> 00:05:43,840
Or another way to look at it is we're asserting

128
00:05:43,840 --> 00:05:46,120
that five must be equal to five.

129
00:05:46,120 --> 00:05:47,840
And if it's not equal to five,

130
00:05:47,840 --> 00:05:52,000
then we've reached inconsistent conclusion basically.

131
00:05:52,000 --> 00:05:53,680
So is five equal to five?

132
00:05:55,560 --> 00:05:58,120
One would hope, okay, yeah.

133
00:05:58,120 --> 00:06:00,920
The logic isn't that weird, so let's run it.

134
00:06:00,920 --> 00:06:03,280
And you can see, copy the expression,

135
00:06:03,280 --> 00:06:05,640
and the answer is yes, well that's good.

136
00:06:05,640 --> 00:06:07,280
That makes me happy.

137
00:06:07,280 --> 00:06:08,120
All right.

138
00:06:09,360 --> 00:06:12,680
Okay, so I promised I would do the interactive thing.

139
00:06:12,680 --> 00:06:14,760
So here's our first program.

140
00:06:14,760 --> 00:06:17,160
Equal, equal five, five, and I will check that in.

141
00:06:18,280 --> 00:06:19,120
Okay.

142
00:06:21,120 --> 00:06:25,400
So, are you supposed to like, how do you do this thing?

143
00:06:25,400 --> 00:06:27,560
You do like a get add or something?

144
00:06:29,720 --> 00:06:30,560
Get upload?

145
00:06:32,160 --> 00:06:33,440
Add dot.

146
00:06:33,440 --> 00:06:34,520
Oh, whoa, okay.

147
00:06:34,520 --> 00:06:36,160
And I'm not really good at get, so.

148
00:06:36,160 --> 00:06:38,360
And then get commit, is that how you do it?

149
00:06:39,440 --> 00:06:41,200
Oh yeah, they do it.

150
00:06:41,200 --> 00:06:43,760
Okay, so get commit, and I have to give a message,

151
00:06:43,760 --> 00:06:45,400
and I'll say one is the message,

152
00:06:45,400 --> 00:06:47,080
because that's the first one.

153
00:06:47,080 --> 00:06:48,080
Okay?

154
00:06:48,080 --> 00:06:49,360
All right, so you're following along,

155
00:06:49,360 --> 00:06:52,640
that's the first, so you can do a pull,

156
00:06:52,640 --> 00:06:56,160
and you can paste that complicated program into veneer.

157
00:06:56,160 --> 00:06:58,920
Let's all do it, make sure we get the tech working,

158
00:06:58,920 --> 00:07:02,960
and then click run, and you should be able to see yes, okay?

159
00:07:02,960 --> 00:07:05,840
That's the first program, great.

160
00:07:05,840 --> 00:07:06,680
Okay.

161
00:07:06,680 --> 00:07:07,520
Yes.

162
00:07:07,520 --> 00:07:09,200
For future reference, instead of doing the get add,

163
00:07:09,200 --> 00:07:12,200
you can just put in dash A on the get commit.

164
00:07:12,240 --> 00:07:14,720
Get commit dash A, ooh, yeah, okay.

165
00:07:14,720 --> 00:07:16,080
All right, I like this, I'm learning.

166
00:07:16,080 --> 00:07:20,800
Okay, so we can do another program, let's do a variant.

167
00:07:20,800 --> 00:07:22,560
This is program number two.

168
00:07:22,560 --> 00:07:24,080
What about six and five?

169
00:07:25,440 --> 00:07:26,280
No.

170
00:07:26,280 --> 00:07:28,140
No, that's right.

171
00:07:28,140 --> 00:07:29,440
Computer says no.

172
00:07:29,440 --> 00:07:30,720
All right, so.

173
00:07:31,720 --> 00:07:33,120
What's about the proof of this?

174
00:07:33,120 --> 00:07:35,120
The proof of it?

175
00:07:35,120 --> 00:07:35,960
Okay, what is it?

176
00:07:35,960 --> 00:07:37,760
Well, hold on, let me check in, my code, I promised.

177
00:07:37,760 --> 00:07:38,600
Okay.

178
00:07:38,600 --> 00:07:40,520
I guess I could, I could like,

179
00:07:40,520 --> 00:07:43,120
look, like get keeps track of revisions.

180
00:07:43,120 --> 00:07:45,400
So I'm not even gonna add another expression.

181
00:07:45,400 --> 00:07:47,680
I'm just gonna like do that, and then it works, all right?

182
00:07:47,680 --> 00:07:49,680
So I could do get, was it?

183
00:07:49,680 --> 00:07:54,680
Get commit dash A, ooh, dash A and then two, right?

184
00:07:58,640 --> 00:07:59,480
Do a pull.

185
00:08:01,200 --> 00:08:03,560
Okay, so what's your question, Boodle?

186
00:08:03,560 --> 00:08:05,440
You wanna know about the proof?

187
00:08:05,440 --> 00:08:07,360
Why is five equal to five?

188
00:08:07,360 --> 00:08:09,600
Why is five equal to five?

189
00:08:09,600 --> 00:08:11,600
Well, let me change it up a little bit,

190
00:08:11,600 --> 00:08:13,280
and maybe I'll answer your question.

191
00:08:13,280 --> 00:08:15,040
I'm gonna put in something else.

192
00:08:15,040 --> 00:08:17,480
Instead of a number, so having two numbers,

193
00:08:17,480 --> 00:08:20,800
I'm gonna put in X, and X is a logic variable.

194
00:08:20,800 --> 00:08:21,800
So you can think of it sort of like

195
00:08:21,800 --> 00:08:23,440
this pattern variable, right?

196
00:08:23,440 --> 00:08:26,080
Okay, so, so is X equal to five?

197
00:08:27,720 --> 00:08:28,920
Yes, we don't know yet.

198
00:08:28,920 --> 00:08:31,200
Yes, we don't know yet, okay?

199
00:08:31,200 --> 00:08:36,200
We don't know, it could be, if X doesn't have a value yet,

200
00:08:36,360 --> 00:08:38,840
then now it does have a value, right?

201
00:08:38,840 --> 00:08:40,960
The answer is yes, and X is five.

202
00:08:40,960 --> 00:08:44,560
But if X is already six, then the answer is no.

203
00:08:44,560 --> 00:08:45,440
All right, so we don't really know,

204
00:08:45,440 --> 00:08:48,160
but I'll say that X is starting out fresh.

205
00:08:48,160 --> 00:08:49,520
We say fresh, it doesn't have a value yet.

206
00:08:49,520 --> 00:08:52,880
So let's run that, yes, and beyond yes,

207
00:08:52,880 --> 00:08:57,200
we see that X has a value associated with it, five, okay?

208
00:08:57,200 --> 00:08:58,040
All right, cool.

209
00:09:03,960 --> 00:09:04,960
Yeah, what?

210
00:09:07,200 --> 00:09:08,040
What did that work?

211
00:09:09,040 --> 00:09:10,840
Oh, I didn't say it.

212
00:09:12,280 --> 00:09:13,120
Oh, you're right.

213
00:09:14,160 --> 00:09:15,680
I got this hard, okay.

214
00:09:15,680 --> 00:09:19,640
All right, so that's one thing we can do, all right?

215
00:09:19,640 --> 00:09:21,940
And so if you look at it this way,

216
00:09:21,940 --> 00:09:25,720
then basically what we're really saying is an assertion.

217
00:09:25,720 --> 00:09:28,440
We're saying that the thing on the left

218
00:09:28,440 --> 00:09:31,200
is syntactically equal to the thing on the right.

219
00:09:33,320 --> 00:09:36,800
As long as you kind of find some set of values

220
00:09:36,840 --> 00:09:39,320
that are assigned to these variables inside the terms

221
00:09:39,320 --> 00:09:41,120
that will make them syntactically equal, right?

222
00:09:41,120 --> 00:09:45,000
So the question is, is there any possible assignment for X

223
00:09:45,000 --> 00:09:46,800
that will make the left and right hand side equal?

224
00:09:46,800 --> 00:09:49,680
And the answer is yes, as long as X is five,

225
00:09:49,680 --> 00:09:51,200
then they'll be equal, okay?

226
00:09:51,200 --> 00:09:54,560
So that's the sort of reasoning you do with unification.

227
00:09:54,560 --> 00:09:58,720
And we can even put variables on both sides, X and Y.

228
00:09:58,720 --> 00:10:00,560
So what should the answer be here?

229
00:10:02,080 --> 00:10:04,640
Yes, and furthermore, what else do we know?

230
00:10:05,640 --> 00:10:08,000
We know that Y is five.

231
00:10:08,000 --> 00:10:10,360
Well, let's say we got rid of the original program, right?

232
00:10:10,360 --> 00:10:13,860
This is the whole program now, so there are no fives anymore.

233
00:10:13,860 --> 00:10:17,040
X and Y are the same, presumably.

234
00:10:17,040 --> 00:10:20,080
And so we can see here that X and Y

235
00:10:20,080 --> 00:10:21,880
are both associated with some value.

236
00:10:21,880 --> 00:10:24,440
And this itself is a representation of a logic variable

237
00:10:24,440 --> 00:10:25,640
that doesn't have a value.

238
00:10:25,640 --> 00:10:27,860
And you can see that they have the same number.

239
00:10:27,860 --> 00:10:30,000
If they were different, you'd see a one here

240
00:10:30,000 --> 00:10:31,280
in one of them and a zero in the other.

241
00:10:31,280 --> 00:10:33,480
So it's telling us it really is the same,

242
00:10:33,520 --> 00:10:35,160
the same logic variable, okay?

243
00:10:38,560 --> 00:10:40,920
I'm gonna get the hang of this soon, so that's...

244
00:10:40,920 --> 00:10:42,560
So the definition of the point to that,

245
00:10:42,560 --> 00:10:44,680
that's not too much you can make?

246
00:10:44,680 --> 00:10:46,760
It's basically a syntactic definition, yeah.

247
00:10:46,760 --> 00:10:51,400
So you could define it recursively, like over a tree.

248
00:10:51,400 --> 00:10:53,080
Okay, so that's the big operator.

249
00:10:53,080 --> 00:10:55,520
And of course, we can have more complicated data structures.

250
00:10:55,520 --> 00:10:59,800
So we could do, you know, I think Vanir has this.

251
00:10:59,800 --> 00:11:02,320
Let's see if Vanir has a list.

252
00:11:04,480 --> 00:11:07,720
Yeah, so Vanir has a list in it.

253
00:11:07,720 --> 00:11:10,480
So we're creating a list containing X and a list containing Y.

254
00:11:10,480 --> 00:11:12,080
And because they have the same structure,

255
00:11:12,080 --> 00:11:13,760
that's fine also, okay?

256
00:11:13,760 --> 00:11:18,560
But if we had, say, list X and Y,

257
00:11:21,360 --> 00:11:23,120
well, what would happen in this case?

258
00:11:24,160 --> 00:11:25,000
Is it gonna succeed?

259
00:11:25,000 --> 00:11:25,840
Is it gonna fail?

260
00:11:29,680 --> 00:11:31,320
It's gonna be yes.

261
00:11:31,320 --> 00:11:35,440
And notice, we have the same logic variable here for the X,

262
00:11:35,440 --> 00:11:37,920
but now Y wraps a list around it, okay?

263
00:11:38,840 --> 00:11:39,680
Yes?

264
00:11:39,680 --> 00:11:41,000
Why do you use nothing rather than

265
00:11:41,000 --> 00:11:43,280
supposed to create a substitution

266
00:11:43,280 --> 00:11:45,840
that says X equals Y, Y equals X?

267
00:11:45,840 --> 00:11:47,040
So that's a good question.

268
00:11:47,040 --> 00:11:48,640
Internally, there is a substitution.

269
00:11:48,640 --> 00:11:51,040
The question is about why aren't we using a substitution?

270
00:11:51,040 --> 00:11:52,360
Internally, there is a substitution,

271
00:11:52,360 --> 00:11:54,280
and this is actually the representation

272
00:11:54,280 --> 00:11:56,280
of the substitution, okay?

273
00:11:56,280 --> 00:11:58,880
We're seeing as the output representation of substitution.

274
00:11:58,880 --> 00:12:00,440
All right, here's one more.

275
00:12:01,320 --> 00:12:05,640
List X and X, what's the value there?

276
00:12:08,040 --> 00:12:08,880
Yes, no?

277
00:12:09,840 --> 00:12:11,440
What should I get printed out as?

278
00:12:16,000 --> 00:12:17,200
Infinite tree.

279
00:12:19,200 --> 00:12:24,200
No, we're not allowed to have a term unified with a term,

280
00:12:25,880 --> 00:12:28,360
with a structure containing that term, okay?

281
00:12:28,360 --> 00:12:30,960
And this gets to what Phil was talking about,

282
00:12:30,960 --> 00:12:32,800
where you can have these infinite structures

283
00:12:32,800 --> 00:12:34,280
and you run into trouble with that.

284
00:12:34,280 --> 00:12:36,280
So we're doing what's called the occur check.

285
00:12:36,280 --> 00:12:38,360
We're checking to see if X occurs in the structure,

286
00:12:38,360 --> 00:12:42,720
and if so, we're going to say, no, no answer, we fail, okay?

287
00:12:42,720 --> 00:12:44,840
And that's important, this is how we get soundness.

288
00:12:44,840 --> 00:12:47,560
If we don't have that, we can prove all sorts of things

289
00:12:47,560 --> 00:12:50,040
that aren't true and get in trouble.

290
00:12:50,040 --> 00:12:52,800
Okay, so that's unification, that's the main operator.

291
00:12:54,640 --> 00:12:55,880
What else do we have?

292
00:12:55,880 --> 00:12:59,200
Well, we have the ability, yes, all right.

293
00:12:59,200 --> 00:13:00,040
Question around?

294
00:13:00,200 --> 00:13:04,880
I couldn't get it to fail on more than one term.

295
00:13:04,880 --> 00:13:07,320
You couldn't get to fail on more than one term, so.

296
00:13:07,320 --> 00:13:09,800
If we have unification between X and five,

297
00:13:09,800 --> 00:13:10,880
and then I get everything.

298
00:13:10,880 --> 00:13:13,040
Ah, I see, okay, good question, good point.

299
00:13:13,040 --> 00:13:17,600
So I think what Rob's saying is if you do something like this,

300
00:13:17,600 --> 00:13:19,840
and then you have another equal equal,

301
00:13:19,840 --> 00:13:23,160
and we're saying six and X, right?

302
00:13:23,160 --> 00:13:25,280
Then you think that's inconsistent information,

303
00:13:25,280 --> 00:13:27,400
but we're still getting a yes that X is six.

304
00:13:27,400 --> 00:13:29,960
So let me go ahead and show you

305
00:13:29,960 --> 00:13:31,520
how we can sequence things.

306
00:13:31,520 --> 00:13:33,440
So what Vanir is doing is it's assuming

307
00:13:33,440 --> 00:13:34,520
these are two separate programs,

308
00:13:34,520 --> 00:13:36,080
it's ignoring the first, essentially,

309
00:13:36,080 --> 00:13:38,200
and just giving us the answer from the second.

310
00:13:38,200 --> 00:13:39,280
That's a good point.

311
00:13:39,280 --> 00:13:41,920
So let me show you the second operator of mini-canon,

312
00:13:41,920 --> 00:13:43,560
which is called fresh.

313
00:13:43,560 --> 00:13:46,020
And what fresh allows you to do is a conjunction.

314
00:13:47,520 --> 00:13:51,400
Okay, so now we have a conjunction of goals like that,

315
00:13:51,400 --> 00:13:54,120
and I can run that, and now my answer is no.

316
00:13:54,120 --> 00:13:56,180
Okay, so fresh acts as a conjunction.

317
00:13:56,180 --> 00:13:58,040
Fresh has one other purpose.

318
00:13:58,040 --> 00:14:01,400
Fresh also lets me introduce new logic variables.

319
00:14:01,400 --> 00:14:02,480
Now the way Vanir works,

320
00:14:02,480 --> 00:14:04,560
which is a little different from standard mini-canon,

321
00:14:04,560 --> 00:14:06,320
Vanir acts more like prologue,

322
00:14:06,320 --> 00:14:10,640
and these variables that aren't defined lexically,

323
00:14:10,640 --> 00:14:12,320
those become new logic variables.

324
00:14:12,320 --> 00:14:15,000
So you need to use fresh less than Vanir

325
00:14:15,000 --> 00:14:16,560
than you do in standard mini-canon.

326
00:14:16,560 --> 00:14:18,040
But if we add a Y there,

327
00:14:18,040 --> 00:14:20,880
that will allow us to create a locally defined

328
00:14:20,880 --> 00:14:23,560
logic variable that has no value called Y.

329
00:14:25,360 --> 00:14:26,760
So that's the fresh form.

330
00:14:28,040 --> 00:14:29,760
All right, that's a pretty complicated program,

331
00:14:29,760 --> 00:14:32,640
so I better add that.

332
00:14:33,760 --> 00:14:38,360
And yeah, okay.

333
00:14:38,360 --> 00:14:39,760
All right, good.

334
00:14:39,760 --> 00:14:42,440
So you've seen two-thirds of the language now,

335
00:14:42,440 --> 00:14:46,120
fresh and equal, and then I'll show you the last part.

336
00:14:46,120 --> 00:14:47,520
Last part's con-dee,

337
00:14:47,520 --> 00:14:49,080
and this is something that allows us

338
00:14:49,080 --> 00:14:50,880
to get more than one answer back.

339
00:14:50,880 --> 00:14:53,040
Okay, because it'd be kind of boring

340
00:14:53,040 --> 00:14:55,680
if our programs could only return one answer.

341
00:14:55,680 --> 00:14:57,480
And one of the points of logic programming

342
00:14:57,480 --> 00:15:01,080
is that we can return potentially infinitely many answers.

343
00:15:01,080 --> 00:15:02,600
So the way we're gonna do that,

344
00:15:02,600 --> 00:15:06,200
and mini-canon syntactically looks a lot like scheme,

345
00:15:06,200 --> 00:15:09,400
because it's the original implementation of the scheme.

346
00:15:09,400 --> 00:15:12,480
So con-dee is based on Lisp's con operator,

347
00:15:12,480 --> 00:15:13,600
which is a conditional operator,

348
00:15:13,600 --> 00:15:17,120
sort of like a big, giant type of if,

349
00:15:17,120 --> 00:15:19,560
or pattern, sort of like a pattern matching syntax,

350
00:15:19,560 --> 00:15:20,560
but it doesn't have a pattern match

351
00:15:20,560 --> 00:15:22,400
or build into it explicitly.

352
00:15:22,400 --> 00:15:24,240
So we're gonna have a con here.

353
00:15:25,080 --> 00:15:30,080
Sorry, con-dee, e stands for every answer.

354
00:15:30,560 --> 00:15:34,080
And the syntax for con-dee is that for each clause,

355
00:15:34,080 --> 00:15:36,600
each con-dee clause has set of parentheses,

356
00:15:36,600 --> 00:15:40,360
and then it takes one or more of these sub-expressions,

357
00:15:40,360 --> 00:15:41,520
there's other mini-canon expressions,

358
00:15:41,520 --> 00:15:42,760
which are called goals.

359
00:15:43,920 --> 00:15:48,400
So equal five x is a goal, I'll pop that in there,

360
00:15:48,400 --> 00:15:52,520
and equal six x is a goal, I'll pop that in the second case.

361
00:15:55,040 --> 00:15:58,720
And, all right.

362
00:15:58,720 --> 00:16:00,360
So what's gonna happen here?

363
00:16:00,360 --> 00:16:03,200
Well, the idea is that we're trying

364
00:16:03,200 --> 00:16:05,280
each of these two clauses independently.

365
00:16:05,280 --> 00:16:06,960
We're gonna try one of the two clauses,

366
00:16:06,960 --> 00:16:09,520
and it's unspecified mini-canon, which one we try first.

367
00:16:09,520 --> 00:16:11,760
Let's say we try the second one first.

368
00:16:11,760 --> 00:16:13,960
So we would try unifying x with six,

369
00:16:13,960 --> 00:16:17,320
x would get, we get yes, x would be associated with six,

370
00:16:17,320 --> 00:16:19,880
and then we could ask for another answer.

371
00:16:19,880 --> 00:16:21,280
And we ask for another answer,

372
00:16:21,280 --> 00:16:23,720
it's as if we had never tried this one.

373
00:16:23,720 --> 00:16:24,920
We try the other one.

374
00:16:24,920 --> 00:16:28,360
And now we forget this association between x and six,

375
00:16:28,360 --> 00:16:31,680
x is refreshed magically, and we're gonna try it again,

376
00:16:31,680 --> 00:16:33,080
and now x will be five.

377
00:16:33,080 --> 00:16:35,800
So it gives us a chance to try different branches

378
00:16:35,800 --> 00:16:36,640
of a program.

379
00:16:36,640 --> 00:16:38,120
So it's similar to like an if,

380
00:16:38,120 --> 00:16:41,720
except an if where you can independently try

381
00:16:41,720 --> 00:16:43,960
all the possibilities, all the tests,

382
00:16:43,960 --> 00:16:46,320
and the consequence, and so forth independently.

383
00:16:48,480 --> 00:16:52,880
Condi is like a disjunction, and fresh is like a conjunct.

384
00:16:52,880 --> 00:16:55,640
Condi is disjunction, fresh is conjunction.

385
00:16:55,640 --> 00:16:56,960
That's right.

386
00:16:56,960 --> 00:16:58,920
And there's a simplified version of mini-canon

387
00:16:58,920 --> 00:17:02,160
called micro-canon, where conjunction and disjunction,

388
00:17:02,160 --> 00:17:04,400
binary versions of those, are the primitive operators.

389
00:17:04,400 --> 00:17:06,040
So those are much closer to logic.

390
00:17:06,040 --> 00:17:08,720
This is closer to maybe a nicer syntax

391
00:17:08,720 --> 00:17:10,400
to program with for real programs,

392
00:17:10,400 --> 00:17:12,240
but if you wanna see the more primitive stuff

393
00:17:12,240 --> 00:17:14,200
that's closer to logic, look at micro-canon.

394
00:17:14,200 --> 00:17:16,480
And that has the very short implementation,

395
00:17:16,480 --> 00:17:17,800
the implementation of micro-canon,

396
00:17:17,800 --> 00:17:19,440
something like 46 lines of scheme code

397
00:17:19,440 --> 00:17:21,800
for all the logic programming system.

398
00:17:21,800 --> 00:17:25,000
So we can try running this, and we get the first answer,

399
00:17:25,000 --> 00:17:28,120
so we try the first one, first clause

400
00:17:28,120 --> 00:17:29,480
in this version of mini-canon,

401
00:17:29,480 --> 00:17:31,680
and we can click on more answers,

402
00:17:31,680 --> 00:17:33,680
and hey, now we've tried the other clause,

403
00:17:33,680 --> 00:17:35,960
where x is six, so we're not inconsistent

404
00:17:35,960 --> 00:17:37,200
because we're trying these clauses

405
00:17:37,200 --> 00:17:38,920
totally independently of each other,

406
00:17:38,920 --> 00:17:40,160
and we can ask for more answers,

407
00:17:40,160 --> 00:17:43,320
and finally we say no, no more answers, that's it.

408
00:17:43,320 --> 00:17:46,320
And if you've ever used Prolog, this part is very similar.

409
00:17:47,480 --> 00:17:49,600
All right, and that's the entire language,

410
00:17:49,600 --> 00:17:50,920
the entire core language.

411
00:17:50,920 --> 00:17:52,960
There are basically three other operators

412
00:17:52,960 --> 00:17:56,600
that we might run into, but that's the basis of it, okay?

413
00:17:56,600 --> 00:17:57,700
Any questions?

414
00:17:59,520 --> 00:18:01,200
Who's playing along, by the way, I'm just curious,

415
00:18:01,200 --> 00:18:02,360
how many people?

416
00:18:02,360 --> 00:18:03,960
Oh, whoa, that's pretty good, all right.

417
00:18:03,960 --> 00:18:07,400
So now let's try something more complicated, all right?

418
00:18:08,480 --> 00:18:10,400
All right, let me keep myself honest,

419
00:18:11,360 --> 00:18:12,880
and check myself in.

420
00:18:14,040 --> 00:18:15,520
All right, and our programs are gonna become

421
00:18:15,520 --> 00:18:18,640
more complicated here, so the check-in thing will be a little,

422
00:18:18,680 --> 00:18:21,720
whoops, oh, I checked that in, it's five.

423
00:18:21,720 --> 00:18:26,120
Oh, here, I'll hack it, I'll put in a space,

424
00:18:26,120 --> 00:18:27,600
and check it in as six.

425
00:18:27,600 --> 00:18:32,600
Yes, I need to work on my get skills, that's fine.

426
00:18:35,600 --> 00:18:38,480
Oh, I need to push, yeah, thank you.

427
00:18:39,720 --> 00:18:44,720
Yeah, my dream tool would have me not have to do this step.

428
00:18:45,640 --> 00:18:48,480
All right, okay, so let's try

429
00:18:48,480 --> 00:18:50,280
something a little more interesting.

430
00:18:50,280 --> 00:18:53,360
So Phil was talking about Lambda Calculus yesterday,

431
00:18:53,360 --> 00:18:55,800
and he showed that there are three

432
00:18:55,800 --> 00:18:59,000
basically parts of Lambda Calculus, so you have variables,

433
00:18:59,000 --> 00:19:01,600
you have Lambda terms themselves,

434
00:19:02,840 --> 00:19:05,000
which are called abstraction in Lambda Calculus,

435
00:19:05,000 --> 00:19:06,560
and then you have application,

436
00:19:06,560 --> 00:19:08,400
applying something to something else.

437
00:19:08,400 --> 00:19:11,160
So we have these three things,

438
00:19:11,160 --> 00:19:13,000
and if I write down comments,

439
00:19:13,000 --> 00:19:14,440
hopefully Vanir will check on this,

440
00:19:14,560 --> 00:19:17,760
so we have, something like X is a variable,

441
00:19:19,680 --> 00:19:21,400
and then we have something like,

442
00:19:22,920 --> 00:19:25,440
I'm gonna write it in sort of like the schemely way,

443
00:19:25,440 --> 00:19:30,440
like Lambda X, Y, so that's an abstraction,

444
00:19:32,360 --> 00:19:37,360
ABS, and then you have something like an application,

445
00:19:37,760 --> 00:19:42,760
so we're applying F to G or something like that.

446
00:19:43,480 --> 00:19:46,240
So that's an application.

447
00:19:46,240 --> 00:19:48,880
So those are the three syntactic forms

448
00:19:48,880 --> 00:19:51,080
that we have in the Lambda Calculus.

449
00:19:51,080 --> 00:19:54,920
So let's try just writing something in mini-canon

450
00:19:54,920 --> 00:19:57,680
that will actually recognize

451
00:19:58,400 --> 00:20:01,560
a valid Lambda Calculus term syntactically.

452
00:20:01,560 --> 00:20:03,120
So let's just try doing that.

453
00:20:03,120 --> 00:20:05,680
So how should we do that?

454
00:20:05,680 --> 00:20:08,040
Well, we're gonna define a function,

455
00:20:08,040 --> 00:20:10,760
so this part is pretty much like scheme.

456
00:20:10,760 --> 00:20:12,560
Let's try defining a function,

457
00:20:12,680 --> 00:20:17,680
and so let's call this, I don't know,

458
00:20:17,880 --> 00:20:22,880
Lambda Calculus Syntax Syn, LC Syn, okay?

459
00:20:23,960 --> 00:20:28,760
And because we're in a schemely language,

460
00:20:28,760 --> 00:20:33,200
we're going to ourselves define this function using Lambda,

461
00:20:33,200 --> 00:20:35,320
and we're gonna give it some argument,

462
00:20:35,320 --> 00:20:38,920
so I'll say we're taking, well, under a term,

463
00:20:38,920 --> 00:20:41,680
Lambda Calculus term, okay?

464
00:20:41,680 --> 00:20:44,760
And now what we wanna do is basically match

465
00:20:44,760 --> 00:20:46,800
against the three possible terms.

466
00:20:46,800 --> 00:20:50,840
So which form do you think I should write here next,

467
00:20:50,840 --> 00:20:53,120
or which mini-canon operator?

468
00:20:54,040 --> 00:20:56,760
So I got, Kandee, Kandee,

469
00:20:56,760 --> 00:20:58,640
because I have choices to make, right?

470
00:20:58,640 --> 00:21:00,460
So I've got Kandee, and how many clauses

471
00:21:00,460 --> 00:21:02,440
am I gonna have for this Kandee?

472
00:21:02,440 --> 00:21:05,040
Three, okay, that's right.

473
00:21:05,040 --> 00:21:07,960
So I go ahead and write down my clauses to begin with,

474
00:21:07,960 --> 00:21:11,840
all right, and now what I'm gonna do

475
00:21:11,840 --> 00:21:14,480
is for each of my syntactic forms,

476
00:21:14,480 --> 00:21:17,800
I'm going to write down a clause for that, okay?

477
00:21:17,800 --> 00:21:21,800
So let's start with, I don't know,

478
00:21:24,480 --> 00:21:26,040
the application term.

479
00:21:26,040 --> 00:21:28,200
All right, let's do the Lambda term, actually.

480
00:21:28,200 --> 00:21:29,640
Okay, so what am I gonna write,

481
00:21:29,640 --> 00:21:31,920
what sort of mini-canon expression am I gonna write

482
00:21:31,920 --> 00:21:34,120
in that clause to match against the Lambda?

483
00:21:35,120 --> 00:21:36,760
I'm gonna write Kandee, I'm gonna write Fresh,

484
00:21:36,760 --> 00:21:38,920
I'm gonna write Equal Equal.

485
00:21:38,920 --> 00:21:41,400
What would I use for pattern matching, basically?

486
00:21:42,400 --> 00:21:43,240
Equal Equal, right?

487
00:21:43,240 --> 00:21:45,360
That's sort of like the two-way super pattern matcher.

488
00:21:45,360 --> 00:21:47,480
So let me write an Equal Equal expression,

489
00:21:47,480 --> 00:21:51,480
unification expression, and what am I gonna unify?

490
00:21:51,480 --> 00:21:55,640
I need two terms, two values, so I'll unify what?

491
00:21:59,480 --> 00:22:02,800
Term, okay, the term that came in, that's right,

492
00:22:02,840 --> 00:22:04,880
and I'm gonna unify that with,

493
00:22:04,880 --> 00:22:06,840
well, something that looks like my Lambda expression,

494
00:22:06,840 --> 00:22:08,280
right, I have to write something down

495
00:22:08,280 --> 00:22:10,600
that syntactically looks like it.

496
00:22:10,600 --> 00:22:13,600
Okay, so what I'm gonna do is I'm gonna just copy this thing.

497
00:22:18,280 --> 00:22:20,160
All right, and,

498
00:22:26,040 --> 00:22:27,920
ninja it a little bit.

499
00:22:27,920 --> 00:22:29,280
Oh, look at that, huh.

500
00:22:30,280 --> 00:22:33,360
Yeah, okay.

501
00:22:33,360 --> 00:22:37,680
All right, so that's kind of what my expression looks like.

502
00:22:37,680 --> 00:22:39,520
Now, there are a couple things here.

503
00:22:39,520 --> 00:22:41,960
So I've got like X as a variable,

504
00:22:41,960 --> 00:22:44,120
and this thing in the middle is really like

505
00:22:44,120 --> 00:22:48,520
the body expression, or E, or T, some other term, okay?

506
00:22:48,520 --> 00:22:51,280
So we got a variable, and we got some term here.

507
00:22:52,760 --> 00:22:57,440
And to make this schemely, we need to make this

508
00:22:57,440 --> 00:23:00,720
not a Lambda expression in many cannon or scheme

509
00:23:00,720 --> 00:23:03,360
in the host language, we need to make this a data structure

510
00:23:03,360 --> 00:23:05,600
that we can literally pattern match against.

511
00:23:05,600 --> 00:23:08,240
So we're gonna create a list,

512
00:23:08,240 --> 00:23:10,080
and the one way to do this in scheme

513
00:23:10,080 --> 00:23:14,680
was with this back tick operator called quasi quote,

514
00:23:14,680 --> 00:23:18,000
and it's sort of like a string interpolation style thing

515
00:23:18,000 --> 00:23:19,560
if you're familiar with that.

516
00:23:19,560 --> 00:23:24,560
Basically, if we put a comma in front of sub expressions,

517
00:23:25,320 --> 00:23:27,920
that means that these things here

518
00:23:27,920 --> 00:23:29,760
are gonna be literally filled in,

519
00:23:29,760 --> 00:23:31,520
they're like holes to be filled in,

520
00:23:31,520 --> 00:23:35,220
with whether the values of X and T are at that time.

521
00:23:36,360 --> 00:23:38,700
And we need to have some X's and T's here.

522
00:23:38,700 --> 00:23:42,000
So what I'm gonna do is I'm gonna create a fresh

523
00:23:42,000 --> 00:23:45,000
so I can have two new variables for X and T.

524
00:23:46,120 --> 00:23:48,240
Okay, so I'm creating two new logic variables,

525
00:23:49,320 --> 00:23:52,440
and I'm gonna grab that.

526
00:23:55,560 --> 00:23:59,440
And I might have to drag this even more.

527
00:24:00,800 --> 00:24:02,880
All right, there we go, perfect.

528
00:24:02,880 --> 00:24:07,480
Okay, so when we're writing these sorts of programs,

529
00:24:07,480 --> 00:24:10,560
it's good to try to test them sort of incrementally.

530
00:24:10,560 --> 00:24:14,560
So what I'm gonna do is I'm gonna temporarily comment out

531
00:24:14,560 --> 00:24:19,360
the first and the third clause with the comments and scheme,

532
00:24:19,360 --> 00:24:21,640
and I'm gonna just try running this thing

533
00:24:21,640 --> 00:24:22,900
to see if it works,

534
00:24:22,940 --> 00:24:24,420
because I'm not sure if it will,

535
00:24:24,420 --> 00:24:26,980
because I don't use veneer normally.

536
00:24:26,980 --> 00:24:28,900
So let's see if it works.

537
00:24:28,900 --> 00:24:32,500
Hash T, ah, cool, okay,

538
00:24:32,500 --> 00:24:33,620
because we didn't actually call it.

539
00:24:33,620 --> 00:24:37,320
So we can actually make a call to LC sin now.

540
00:24:37,320 --> 00:24:42,320
Let's try calling LC sin, and let's give it a term.

541
00:24:42,320 --> 00:24:47,320
So let's give it the term lambda z, z,

542
00:24:48,860 --> 00:24:50,720
and see if that succeeds.

543
00:24:50,720 --> 00:24:53,200
And it says yes, it does succeed.

544
00:24:53,200 --> 00:24:55,600
So this means that this is syntactically valid.

545
00:24:55,600 --> 00:24:57,480
Great, okay.

546
00:24:58,920 --> 00:25:03,480
So let me come up that in, or check that in.

547
00:25:04,640 --> 00:25:06,240
So here's our first version of it.

548
00:25:10,720 --> 00:25:13,600
And version seven.

549
00:25:14,760 --> 00:25:18,360
Okay, all right, and notice I could just test it

550
00:25:18,360 --> 00:25:19,440
one line at a time, right?

551
00:25:19,440 --> 00:25:21,480
So let's do the application line now.

552
00:25:22,640 --> 00:25:25,080
Okay, so here we're gonna have an application.

553
00:25:25,080 --> 00:25:26,880
Once again, I'm gonna wanna have a fresh

554
00:25:26,880 --> 00:25:28,980
to introduce some logic variables.

555
00:25:28,980 --> 00:25:30,560
I'll say e1 and e2.

556
00:25:31,600 --> 00:25:35,320
And the syntax of an application

557
00:25:35,320 --> 00:25:39,360
is that we have term e1 applied to term e2.

558
00:25:39,360 --> 00:25:41,160
And so that's what that looks like.

559
00:25:41,160 --> 00:25:46,160
And I'll go ahead and check that out.

560
00:26:01,280 --> 00:26:04,000
All right, so two thirds of the way done.

561
00:26:04,000 --> 00:26:05,200
And I could test that also,

562
00:26:05,200 --> 00:26:07,240
but I've got some confidence in it.

563
00:26:07,240 --> 00:26:11,040
So let's now do the last one, which is the variable x.

564
00:26:11,880 --> 00:26:15,240
And we're gonna represent a variable as a symbol

565
00:26:15,240 --> 00:26:16,960
and scheme, a scheme symbol.

566
00:26:16,960 --> 00:26:21,240
And so we've added to sort of the core logical foundations

567
00:26:21,240 --> 00:26:24,900
of many canron, a few constraints that make it easier

568
00:26:24,900 --> 00:26:26,760
for writing things like interpreters

569
00:26:26,760 --> 00:26:28,760
and type inferences and type checkers

570
00:26:28,760 --> 00:26:31,640
and grammar-based programs.

571
00:26:31,640 --> 00:26:34,920
And one of the constraints we have is called simbolo.

572
00:26:36,480 --> 00:26:40,760
So, simbolo, so if the term is a symbol,

573
00:26:41,280 --> 00:26:43,120
then we say, hey, that's a variable.

574
00:26:43,120 --> 00:26:45,320
That's syntactically legal.

575
00:26:45,320 --> 00:26:49,640
So simbolo is the last way we can represent.

576
00:26:49,640 --> 00:26:50,480
We're not actually saying,

577
00:26:50,480 --> 00:26:52,400
we don't care if it's x or y or whatever, right?

578
00:26:52,400 --> 00:26:54,200
But we care that it's a symbol.

579
00:26:54,200 --> 00:26:56,200
So let's see if that runs.

580
00:26:56,200 --> 00:26:58,200
Yes, okay, cool.

581
00:26:58,200 --> 00:27:02,680
And we can try if we want some other tests.

582
00:27:02,680 --> 00:27:07,480
So we could say, well, actually maybe it's lambda,

583
00:27:11,320 --> 00:27:16,320
z and z applied to z or something like that, okay?

584
00:27:16,800 --> 00:27:18,480
So we got an application,

585
00:27:18,480 --> 00:27:22,960
we have variable reference and we have a lambda.

586
00:27:22,960 --> 00:27:25,960
So let's see if that's syntactically valid.

587
00:27:25,960 --> 00:27:29,040
Yes, that's syntactically valid, okay?

588
00:27:29,040 --> 00:27:31,960
All right, so we've implemented our grammar

589
00:27:31,960 --> 00:27:33,760
and we've got all that stuff working

590
00:27:33,760 --> 00:27:35,440
and let me check that in.

591
00:27:36,440 --> 00:27:40,920
And this is check-in number nine.

592
00:27:42,680 --> 00:27:44,240
All right, cool.

593
00:27:44,240 --> 00:27:48,360
Now, okay, that's kind of cool that we can write that.

594
00:27:48,360 --> 00:27:52,360
But what would be more cool is if we can use

595
00:27:52,360 --> 00:27:54,800
those logic variables we've been using other places,

596
00:27:54,800 --> 00:27:55,840
if we could actually use that

597
00:27:55,840 --> 00:27:57,920
inside of our call to LC-SIN.

598
00:27:57,920 --> 00:28:00,120
So right now we're having to give a fully ground

599
00:28:00,120 --> 00:28:04,200
or fully specified lambda calculus term.

600
00:28:04,200 --> 00:28:06,960
And we're checking, we're verifying, validating that term

601
00:28:06,960 --> 00:28:09,160
and make sure it's syntactically legal.

602
00:28:09,160 --> 00:28:12,760
But it'd be really cool if we could instead

603
00:28:12,760 --> 00:28:16,920
put in a logic variable and say generate a valid lambda term.

604
00:28:16,920 --> 00:28:18,080
So let's try that.

605
00:28:18,080 --> 00:28:20,520
So I'm gonna get rid of that term.

606
00:28:20,520 --> 00:28:25,320
And I'm going to put in my term,

607
00:28:26,360 --> 00:28:30,240
or I don't know, I was called Q for a query variable, okay?

608
00:28:30,240 --> 00:28:34,440
So now I've got this query variable in place of the call.

609
00:28:34,440 --> 00:28:36,160
And let's try doing a run now.

610
00:28:37,920 --> 00:28:42,480
And so the first answer is yes.

611
00:28:42,480 --> 00:28:44,600
So we're getting back this underscore zero thing

612
00:28:44,600 --> 00:28:46,200
bound to Q, that's, if you remember,

613
00:28:46,200 --> 00:28:49,080
that's a representation of our fresh logic variable.

614
00:28:49,080 --> 00:28:50,840
And we have the side condition.

615
00:28:50,840 --> 00:28:52,280
The side condition is saying

616
00:28:52,280 --> 00:28:55,280
that that underscore zero thing has to be a symbol.

617
00:28:55,280 --> 00:28:58,400
So it has to be, if you were ever to instantiate it

618
00:28:58,400 --> 00:29:01,440
to a ground value, it would have to be a legal scheme symbol.

619
00:29:01,440 --> 00:29:04,000
And scheme symbols are how we're representing variables.

620
00:29:04,000 --> 00:29:06,960
So what this is saying is that any symbol, that's fine.

621
00:29:06,960 --> 00:29:09,200
That's just a lambda calculus variable.

622
00:29:09,200 --> 00:29:10,760
So that's actually representing

623
00:29:10,760 --> 00:29:12,560
infinitely many concrete values,

624
00:29:12,560 --> 00:29:14,640
infinitely many ground symbols.

625
00:29:14,640 --> 00:29:16,720
Now let's see if we can get another answer.

626
00:29:16,720 --> 00:29:20,000
Okay, here we're saying,

627
00:29:20,000 --> 00:29:23,640
ah, if we have a lambda term

628
00:29:23,640 --> 00:29:26,200
and it has the right structure,

629
00:29:26,200 --> 00:29:27,920
has parentheses and something, that's fine.

630
00:29:27,920 --> 00:29:30,080
And if it has something else in the back

631
00:29:30,080 --> 00:29:32,280
and could be different, that's fine.

632
00:29:32,280 --> 00:29:34,520
That's not very constrained.

633
00:29:34,520 --> 00:29:37,720
But okay, that's fine as far as it goes.

634
00:29:37,720 --> 00:29:38,960
What about this underscore zero thing?

635
00:29:38,960 --> 00:29:41,720
What should that be syntactically for this to be legal?

636
00:29:42,880 --> 00:29:43,720
Should be a symbol.

637
00:29:43,720 --> 00:29:45,720
Okay, so maybe we're a little sloppy.

638
00:29:45,720 --> 00:29:47,040
Let's go back.

639
00:29:47,040 --> 00:29:49,920
And so we can add a side condition maybe.

640
00:29:49,920 --> 00:29:52,120
Okay, so what else can I write here

641
00:29:52,120 --> 00:29:53,920
to kind of lock it down a little more?

642
00:29:54,640 --> 00:30:00,040
So I can do symbolic x, okay, and symbolic t.

643
00:30:00,040 --> 00:30:01,960
So do we know if t is actually a symbol?

644
00:30:01,960 --> 00:30:03,280
That's a good question.

645
00:30:03,280 --> 00:30:04,120
What is t?

646
00:30:06,160 --> 00:30:08,880
It's an arbitrary lambda calculus expression.

647
00:30:08,880 --> 00:30:10,520
So what do we need to write here?

648
00:30:12,640 --> 00:30:14,760
LC sin, yeah, we need recursion.

649
00:30:14,760 --> 00:30:16,760
LC sin on t.

650
00:30:16,760 --> 00:30:17,840
So that was part of the problem.

651
00:30:17,840 --> 00:30:19,120
We weren't recurring properly.

652
00:30:19,120 --> 00:30:21,320
Anything else you see that's wrong

653
00:30:21,320 --> 00:30:23,760
in those along the similar vein?

654
00:30:23,760 --> 00:30:25,560
Anywhere else where we were sloppy?

655
00:30:26,840 --> 00:30:27,760
Application, right?

656
00:30:27,760 --> 00:30:29,400
We have about these e1 and e2 things.

657
00:30:29,400 --> 00:30:31,160
We're not putting any structure on those.

658
00:30:31,160 --> 00:30:35,600
Those actually have to be lambda calculus terms themselves.

659
00:30:35,600 --> 00:30:37,720
So we need to recur.

660
00:30:37,720 --> 00:30:42,720
Okay, sin on e1, okay, LC sin on e2.

661
00:30:43,720 --> 00:30:46,720
All right, so hopefully that'll work.

662
00:30:46,720 --> 00:30:47,560
Let's see.

663
00:30:47,560 --> 00:30:50,320
Sin, okay, sin.

664
00:30:51,720 --> 00:30:53,200
Good, thank you.

665
00:30:54,760 --> 00:30:55,840
Ah, okay, cool.

666
00:30:55,840 --> 00:30:57,440
So let me paste that in.

667
00:31:02,600 --> 00:31:05,920
All right, so this is check-in number 10.

668
00:31:09,040 --> 00:31:11,320
All right, so if I run that, let's see.

669
00:31:11,320 --> 00:31:13,760
So we have the symbol answer like we had before.

670
00:31:15,120 --> 00:31:17,120
Ah, okay, so this looks better.

671
00:31:17,120 --> 00:31:20,200
So now when I get a second answer that I'm generating,

672
00:31:20,200 --> 00:31:21,480
it's like, okay, well, it still has

673
00:31:21,480 --> 00:31:22,960
that same structure we saw before,

674
00:31:23,000 --> 00:31:24,360
but now we have some side conditions.

675
00:31:24,360 --> 00:31:27,640
We're saying underscore zero has to be a symbol.

676
00:31:27,640 --> 00:31:31,160
And here we're saying the body is a symbol in that case.

677
00:31:31,160 --> 00:31:35,320
So this, and they could potentially be separate symbols,

678
00:31:35,320 --> 00:31:36,400
but they could be the same symbol.

679
00:31:36,400 --> 00:31:39,000
That's what having the underscore zero and underscore one means.

680
00:31:39,000 --> 00:31:40,760
So this could be lambda zed zed,

681
00:31:40,760 --> 00:31:43,040
or it could be lambda zed w or something like that.

682
00:31:43,040 --> 00:31:44,600
Those would both be legal.

683
00:31:44,600 --> 00:31:45,960
And I can ask for more.

684
00:31:45,960 --> 00:31:48,280
So here's an application where you have a symbol applied

685
00:31:48,280 --> 00:31:51,960
to a symbol, okay, and I can keep generating more of these.

686
00:31:51,960 --> 00:31:56,040
So here's a lambda whose body is another lambda, right?

687
00:31:56,040 --> 00:31:57,280
So now I can generate these

688
00:31:57,280 --> 00:32:00,360
and I can enumerate every possible lambda calculus terms

689
00:32:00,360 --> 00:32:01,360
and tactically, right?

690
00:32:02,600 --> 00:32:07,520
Okay, so that's basically the cool idea

691
00:32:07,520 --> 00:32:10,700
about pure logic programming.

692
00:32:10,700 --> 00:32:13,440
And many canons really language for pure logic programming

693
00:32:13,440 --> 00:32:15,880
where the idea is you can just write down

694
00:32:15,880 --> 00:32:18,040
mathematical specifications, something like that,

695
00:32:18,040 --> 00:32:19,640
and have something close to the math.

696
00:32:19,640 --> 00:32:21,720
And then once you have that,

697
00:32:21,720 --> 00:32:23,640
you can just use the same code,

698
00:32:23,640 --> 00:32:25,680
not just to check that something's correct,

699
00:32:25,680 --> 00:32:27,800
but also to generate answers.

700
00:32:29,240 --> 00:32:34,240
All right, so let's do this.

701
00:32:35,240 --> 00:32:38,880
Okay, so what I'm gonna do is I'm gonna refresh veneer.

702
00:32:40,920 --> 00:32:42,920
Just refresh the browser,

703
00:32:42,920 --> 00:32:44,900
make sure it's not in a goofy state.

704
00:32:44,900 --> 00:32:47,720
And you can see up top there are some different programs.

705
00:32:47,720 --> 00:32:50,840
So let's see if I try type inference.

706
00:32:50,840 --> 00:32:53,260
Okay, so if I go to type inference,

707
00:32:57,520 --> 00:33:02,520
you can see that we've got this mini canron definition

708
00:33:03,160 --> 00:33:07,800
called bang slash zero or dash zero or something, okay?

709
00:33:07,800 --> 00:33:08,800
What it's supposed to look like

710
00:33:08,800 --> 00:33:11,560
is a turn style operator in logic.

711
00:33:11,560 --> 00:33:13,840
It's supposed to look like one of those special symbols

712
00:33:13,840 --> 00:33:17,160
that you saw in Phil's presentation.

713
00:33:17,160 --> 00:33:19,760
So this is gonna be a type inferencer.

714
00:33:19,760 --> 00:33:23,120
And if you've ever used a language like ML, for example,

715
00:33:23,120 --> 00:33:24,960
you know what type inference is,

716
00:33:24,960 --> 00:33:26,800
you can write down the expression,

717
00:33:26,800 --> 00:33:28,840
and the type inferencer will try to figure out

718
00:33:28,840 --> 00:33:31,080
what the type of that expression is.

719
00:33:31,080 --> 00:33:33,880
So here we have three moving parts.

720
00:33:33,880 --> 00:33:37,880
We have the expression that we're gonna type infer.

721
00:33:37,880 --> 00:33:41,240
We have gamma, which is like a type environment,

722
00:33:41,240 --> 00:33:43,560
it allows us to accumulate information

723
00:33:43,560 --> 00:33:45,280
about the subparts of the expressions,

724
00:33:45,280 --> 00:33:46,320
what those types are.

725
00:33:46,360 --> 00:33:51,360
And then type is the type of that expression, all right?

726
00:33:51,480 --> 00:33:53,680
And you could see actually already

727
00:33:53,680 --> 00:33:55,320
what some of the similarities are.

728
00:33:55,320 --> 00:33:58,320
So symbolo expert, this is the symbol case,

729
00:33:58,320 --> 00:34:00,160
this is our variable case, right?

730
00:34:00,160 --> 00:34:01,640
And in this case, it's not just saying,

731
00:34:01,640 --> 00:34:03,720
well, that's it, you have a symbol.

732
00:34:03,720 --> 00:34:06,640
Now we're gonna look up in the type environment

733
00:34:06,640 --> 00:34:09,400
what that symbol is, what the type of that symbol is,

734
00:34:09,400 --> 00:34:12,280
because hopefully this is not a free variable,

735
00:34:12,280 --> 00:34:13,800
this is a bound variable.

736
00:34:13,800 --> 00:34:15,920
And we might know that that variable, for example,

737
00:34:15,920 --> 00:34:19,400
is bound to an int, has type int, okay?

738
00:34:19,400 --> 00:34:21,900
And there's some other cases, like for example,

739
00:34:21,900 --> 00:34:24,960
is the expression coming in a number?

740
00:34:24,960 --> 00:34:26,880
So number is another constraint.

741
00:34:26,880 --> 00:34:29,800
And if so, we're gonna say the type

742
00:34:29,800 --> 00:34:31,920
of that sub-expression is int, okay?

743
00:34:31,920 --> 00:34:32,760
That's our int type.

744
00:34:32,760 --> 00:34:34,800
So five would have type int.

745
00:34:34,800 --> 00:34:37,360
If it's a Boolean, like hashf in the scheme,

746
00:34:37,360 --> 00:34:39,920
it's gonna have type bool and so forth.

747
00:34:39,920 --> 00:34:44,360
And then we're also gonna have some more sophisticated rules

748
00:34:44,360 --> 00:34:47,560
for lambda, okay?

749
00:34:47,560 --> 00:34:51,400
And if you look at the lambda rule closely,

750
00:34:51,400 --> 00:34:53,720
and if you look at the math that Phil put up,

751
00:34:53,720 --> 00:34:58,560
or is in his paper, you'll notice that these rules

752
00:34:58,560 --> 00:35:00,320
essentially are the same, okay?

753
00:35:00,320 --> 00:35:01,640
So this is what he was talking about

754
00:35:01,640 --> 00:35:04,140
with the Curry-Howard isomorphism,

755
00:35:04,140 --> 00:35:07,720
and that basically we have a little theorem prover here

756
00:35:07,720 --> 00:35:10,040
in the form of a type inferencer.

757
00:35:10,040 --> 00:35:13,440
And similarly, we have application rule,

758
00:35:13,440 --> 00:35:15,800
and we also have a special version of let,

759
00:35:15,800 --> 00:35:18,280
and we have things like addition and so forth, okay?

760
00:35:18,280 --> 00:35:22,680
So let's just try doing something that says type inferencer.

761
00:35:22,680 --> 00:35:25,480
So here's an expression that it comes with,

762
00:35:25,480 --> 00:35:28,080
but let's try something simpler.

763
00:35:28,080 --> 00:35:30,960
So let's try calling our type inferencer,

764
00:35:30,960 --> 00:35:34,160
and we have to give it an initial type environment.

765
00:35:34,160 --> 00:35:36,000
And we're gonna say that that initial type environment

766
00:35:36,000 --> 00:35:36,840
is empty.

767
00:35:38,760 --> 00:35:41,200
And now we have to give it some expression,

768
00:35:41,200 --> 00:35:43,320
I don't know what that expression is gonna be,

769
00:35:43,320 --> 00:35:45,280
and then it's gonna have some type,

770
00:35:45,280 --> 00:35:48,280
and I will just write Q for the query variable for the type.

771
00:35:49,240 --> 00:35:52,240
So what's an expression that we might want to type check?

772
00:35:52,240 --> 00:35:55,400
Well, let's do something simple, like five.

773
00:35:55,400 --> 00:35:57,400
I'm putting a quote here, by the way,

774
00:35:57,400 --> 00:36:02,080
to make sure that whatever expression is here

775
00:36:02,080 --> 00:36:06,040
isn't evaluated at the host level, at the scheme level,

776
00:36:06,040 --> 00:36:08,840
but it's actually evaluated or looked at,

777
00:36:08,840 --> 00:36:12,060
that term is looked at in the type inferencer itself.

778
00:36:12,100 --> 00:36:13,660
So what should the type be here?

779
00:36:13,660 --> 00:36:15,140
What should the type of Q be?

780
00:36:17,980 --> 00:36:21,860
Should be an int, yeah, so that worked, it's an int, okay?

781
00:36:21,860 --> 00:36:26,260
And I can do something like plus, right?

782
00:36:26,260 --> 00:36:28,820
So plus three, four, what should the type of that be?

783
00:36:29,820 --> 00:36:33,060
That should be int, okay, sure enough, we got an int.

784
00:36:33,060 --> 00:36:38,060
What about plus hash f, four, what should the type of that be?

785
00:36:38,260 --> 00:36:42,060
Computer says no, all right, and we can also look

786
00:36:42,060 --> 00:36:44,060
at things like a lambda expression.

787
00:36:44,060 --> 00:36:47,060
What about lambda xx, which of the type of that be?

788
00:36:50,060 --> 00:36:53,060
Well, it should be equivalent to some sort of function type,

789
00:36:53,060 --> 00:36:56,060
right, so yeah, so we're gonna have something like a arrow a,

790
00:36:56,060 --> 00:36:59,060
and you can see that we have a fresh logic variable,

791
00:36:59,060 --> 00:37:01,060
arrow, fresh logic variable, so the thing on the left

792
00:37:01,060 --> 00:37:03,060
is the input type for the function,

793
00:37:03,060 --> 00:37:05,060
the thing on the right is the output type.

794
00:37:05,060 --> 00:37:07,060
The underscore zero means that this is a fresh variable,

795
00:37:07,060 --> 00:37:09,060
it means it could be anything,

796
00:37:09,060 --> 00:37:11,060
but the input and the output have to be the same

797
00:37:11,060 --> 00:37:13,060
because it's the identity function, okay?

798
00:37:13,060 --> 00:37:16,060
So this is a very general answer, all right?

799
00:37:16,060 --> 00:37:18,060
And we could try doing an application.

800
00:37:18,060 --> 00:37:23,060
We could try doing something like applying that lambda term

801
00:37:23,060 --> 00:37:28,060
to the value of plus three, four,

802
00:37:28,060 --> 00:37:30,060
and now what type should we get back?

803
00:37:31,060 --> 00:37:33,060
Should get back in it.

804
00:37:34,060 --> 00:37:36,060
Should get back in it, okay?

805
00:37:36,060 --> 00:37:38,060
Cool, all right, so that all works.

806
00:37:38,060 --> 00:37:40,060
So this is a working type inferencer,

807
00:37:40,060 --> 00:37:43,060
and for the most part we just kind of wrote down the rules,

808
00:37:43,060 --> 00:37:46,060
the math, you know, you could take the rules

809
00:37:46,060 --> 00:37:49,060
Phil showed and essentially type those in.

810
00:37:49,060 --> 00:37:52,060
Now where it gets more interesting is,

811
00:37:52,060 --> 00:37:55,060
and this is where the Curry-Howard part really becomes

812
00:37:55,060 --> 00:37:58,060
way more interesting to me, is that we can say,

813
00:37:58,060 --> 00:38:00,060
because we're in the logic programming domain,

814
00:38:00,060 --> 00:38:03,060
we can say that the type is going to be int

815
00:38:03,060 --> 00:38:07,060
and that we don't know what the input program is, right?

816
00:38:07,060 --> 00:38:10,060
So now we're going from type inference

817
00:38:10,060 --> 00:38:13,060
to type habitation or inhabitation.

818
00:38:13,060 --> 00:38:16,060
We're trying to find a term that inhabits this type, okay?

819
00:38:16,060 --> 00:38:20,060
So what would be a simple term that would have the type int?

820
00:38:20,060 --> 00:38:23,060
Zero, okay, sure.

821
00:38:23,060 --> 00:38:26,060
Well, zero is a little specific of an answer.

822
00:38:26,060 --> 00:38:28,060
We get back a more general answer that includes zero.

823
00:38:28,060 --> 00:38:30,060
So we're getting back some fresh logic variable

824
00:38:30,060 --> 00:38:32,060
with a side condition that has to be a number, okay?

825
00:38:32,060 --> 00:38:36,060
So that's zero, but it's also 42.

826
00:38:36,060 --> 00:38:38,060
Is there any distinction between numbers and integers

827
00:38:38,060 --> 00:38:40,060
and not supporting floating points?

828
00:38:40,060 --> 00:38:42,060
Okay, so good question.

829
00:38:42,060 --> 00:38:44,060
Are we supporting integers, floating points, so forth?

830
00:38:44,060 --> 00:38:48,060
Right now, in this one, we're only supporting positive integers.

831
00:38:48,060 --> 00:38:50,060
Actually, if we could probably do negative integers, I don't know.

832
00:38:50,060 --> 00:38:53,060
This one, yeah, I think this one works with negative integers, too.

833
00:38:53,060 --> 00:38:55,060
But, well, we could try that.

834
00:38:55,060 --> 00:38:59,060
See what the type of negative five is.

835
00:38:59,060 --> 00:39:01,060
But I think this is only handling integers.

836
00:39:01,060 --> 00:39:03,060
But we could add other constraints

837
00:39:03,060 --> 00:39:05,060
that would handle other numeric types.

838
00:39:05,060 --> 00:39:08,060
Oh, okay, it doesn't like negative five, I guess.

839
00:39:08,060 --> 00:39:11,060
So I guess number O in this implementation

840
00:39:11,060 --> 00:39:14,060
only handles non-negative integers.

841
00:39:14,060 --> 00:39:16,060
But you could add more things.

842
00:39:16,060 --> 00:39:20,060
In fact, when I worked with Eric Holk and Claire Alvis

843
00:39:20,060 --> 00:39:24,060
on this language called Harlan,

844
00:39:24,060 --> 00:39:28,060
the original version of Harlan is sort of like a schemely language

845
00:39:28,060 --> 00:39:30,060
for GPU programming,

846
00:39:30,060 --> 00:39:34,060
but it had like an ML-style type system.

847
00:39:34,060 --> 00:39:40,060
And the original type inferencer for that was written in C Canron.

848
00:39:40,060 --> 00:39:43,060
And we had to extend these operators

849
00:39:43,060 --> 00:39:45,060
to handle different types of numbers.

850
00:39:45,060 --> 00:39:48,060
So you can do that. You just have to add other constraints.

851
00:39:48,060 --> 00:39:51,060
Okay, so what else can we do here?

852
00:39:51,060 --> 00:39:54,060
What other sorts of things should we get back

853
00:39:54,060 --> 00:39:56,060
other than just a literal number?

854
00:39:56,060 --> 00:39:58,060
Well, let's see what many Canons says.

855
00:39:58,060 --> 00:40:01,060
So here we have a let.

856
00:40:01,060 --> 00:40:05,060
So we're saying let some variable, which is a symbol,

857
00:40:05,060 --> 00:40:08,060
which has some number value.

858
00:40:08,060 --> 00:40:10,060
It doesn't matter what it is, because we're ignoring it,

859
00:40:10,060 --> 00:40:13,060
and the body of the let is some other number.

860
00:40:13,060 --> 00:40:15,060
Okay, well, that's true. That has type in.

861
00:40:15,060 --> 00:40:18,060
And it's well-typed. It's the type checks, right?

862
00:40:18,060 --> 00:40:19,060
And here's another one.

863
00:40:19,060 --> 00:40:23,060
So here we're saying let some variable, the symbol, be hash f.

864
00:40:23,060 --> 00:40:24,060
We're ignoring that.

865
00:40:24,060 --> 00:40:26,060
We're returning the body, which is underscore one,

866
00:40:26,060 --> 00:40:28,060
and that has to be a number.

867
00:40:28,060 --> 00:40:30,060
And so we could play these games.

868
00:40:30,060 --> 00:40:35,060
And at some point, okay, so now we get an addition of two numbers.

869
00:40:35,060 --> 00:40:37,060
And here, now we start getting into applications.

870
00:40:37,060 --> 00:40:40,060
So we're getting a lambda term, a lambda expression,

871
00:40:40,060 --> 00:40:42,060
and it's being applied to something.

872
00:40:42,060 --> 00:40:43,060
So let's make sure the types work.

873
00:40:43,060 --> 00:40:44,060
So we're passing in a number.

874
00:40:44,060 --> 00:40:46,060
That's our constraint.

875
00:40:46,060 --> 00:40:48,060
And here we have some symbol.

876
00:40:48,060 --> 00:40:49,060
And we're ignoring what's passed in,

877
00:40:49,060 --> 00:40:53,060
and we're returning some other potentially different number.

878
00:40:53,060 --> 00:40:58,060
So you can play these games all day.

879
00:40:58,060 --> 00:41:00,060
And yes, you get.

880
00:41:00,060 --> 00:41:03,060
You can keep clicking more answers for as long as you want.

881
00:41:03,060 --> 00:41:05,060
All right, I'm going to refresh one more time.

882
00:41:05,060 --> 00:41:10,060
And I'm going to show you something that's a little more fancy.

883
00:41:10,060 --> 00:41:12,060
But by the way, that type inference stuff,

884
00:41:12,060 --> 00:41:14,060
or the type inhabitation,

885
00:41:14,060 --> 00:41:20,060
that is the thing that many of the modern proof assistants work on.

886
00:41:20,060 --> 00:41:22,060
Okay, I'm going to be Dijkstra in two minutes,

887
00:41:22,060 --> 00:41:25,060
but I'm going to go ahead and show you very quickly

888
00:41:25,060 --> 00:41:27,060
what you can do with a relational interpreter.

889
00:41:27,060 --> 00:41:32,060
So here we have an interpreter for a significant subset of scheme.

890
00:41:32,060 --> 00:41:34,060
It's basically our extended lambda calculus,

891
00:41:34,060 --> 00:41:36,060
if you want to look at it that way.

892
00:41:36,060 --> 00:41:40,060
And so we have this, a val expo thing.

893
00:41:40,060 --> 00:41:43,060
And so we can evaluate an expression.

894
00:41:43,060 --> 00:41:47,060
I think we have something called, yeah, a val expo.

895
00:41:47,060 --> 00:41:50,060
And let me just show you one query to a val expo,

896
00:41:50,060 --> 00:41:52,060
and hopefully this will work.

897
00:41:52,060 --> 00:41:55,060
So we're going to call a val expo.

898
00:41:55,060 --> 00:41:58,060
And a val expo takes, sort of like the type inference,

899
00:41:58,060 --> 00:42:07,060
it's going to take an expression and an environment and then an output.

900
00:42:07,060 --> 00:42:10,060
So we're going to say, we've got some expression we don't know.

901
00:42:10,060 --> 00:42:12,060
We're going to start in the empty environment.

902
00:42:12,060 --> 00:42:16,060
And we want to see if we can create some expression,

903
00:42:16,060 --> 00:42:20,060
find some expression that in the empty environment evaluates to itself.

904
00:42:20,060 --> 00:42:23,060
Well, let's see if we can do that.

905
00:42:23,060 --> 00:42:27,060
Whoa, what is that thing?

906
00:42:27,060 --> 00:42:29,060
Well, that's kind of weird.

907
00:42:29,060 --> 00:42:33,060
Okay, so we got this weird looking thing.

908
00:42:33,060 --> 00:42:38,060
And let me just go to Emacs and start up scheme.

909
00:42:38,060 --> 00:42:41,060
I'm going to try to type that in.

910
00:42:41,060 --> 00:42:45,060
Format it in ways a little easier to understand.

911
00:42:45,060 --> 00:42:47,060
I'm going to try running that.

912
00:42:47,060 --> 00:42:50,060
Oh, wow, I got back the same thing.

913
00:42:50,060 --> 00:42:52,060
So that's called a quine.

914
00:42:52,060 --> 00:42:55,060
That's a program that evaluates to itself.

915
00:42:55,060 --> 00:42:59,060
And by the way, if you look at, you know,

916
00:42:59,060 --> 00:43:02,060
here's my last comment that I'll make that's historical.

917
00:43:02,060 --> 00:43:09,060
If you look at the micro manual for Lisp by John McCarthy,

918
00:43:09,060 --> 00:43:16,060
he says, it's a difficult mathematical type challenge exercise right here.

919
00:43:16,060 --> 00:43:20,060
Find the list E such that the value of E is equal to E.

920
00:43:20,060 --> 00:43:24,060
And that's what we just did by typing in the rules for scheme

921
00:43:24,060 --> 00:43:27,060
and letting many canren do it.

922
00:43:27,060 --> 00:43:29,060
So I hope you'll have fun playing with it.

923
00:43:29,060 --> 00:43:31,060
And if you have any questions, I'm happy to answer them.

924
00:43:31,060 --> 00:43:33,060
Thank you.

