start	end	text
0	2280	Hello, can everyone hear me?
2280	3880	The mic on and everything.
3880	4960	Good to go.
4960	6040	Thank you, Boodle.
6040	7880	And thank you for having me here.
7880	11160	All right, I had a totally different talk plan
11160	13280	and then Phil's talk was really cool.
13280	15360	And then I was like, oh, I'll do something
15360	17440	with Lambda Calculus and Mini-Canron.
17440	19160	And then I was talking to people last night
19160	24160	and basically Andrea and Mark and Stefan,
25080	27400	a few other people convinced me to try something
27400	29560	like much more radical than I normally do
29560	30760	with my live coding.
30760	33520	So I want you all to be doing live coding,
33520	34880	at least anyone who's interested.
34880	39880	So if you can get out your lapis and go to this URL,
42080	46800	and that holds doubly true for anyone watching on video.
46800	49640	This is specially designed so that people in the audience
49640	52640	and people on video can kind of follow along.
52640	54720	And basically what I'm gonna do is I'm gonna check in
54720	57200	the code as I'm talking and I'll let you know
57200	58800	when I did a check-in so you can do a poll,
58800	60400	so you can sync up with me.
60400	64360	And there's a really cool web-based version
64360	66400	of Mini-Canron that David Kahn created.
66400	70720	And you can just paste that code into the web browser
70720	73400	and you should be able to run Mini-Canron, okay?
73400	76000	So we'll try that and it might crash and burn.
76000	77400	We'll just see how it goes.
77400	79440	But the great thing is if someone's watching a video
79440	81960	afterwards they should be able to follow along and stop.
81960	85000	And if anyone here is confused about something,
85000	86520	you can't get an example to run or whatever,
86520	88160	you can ask a question, okay?
88160	89440	Or you can take it offline, whatever.
89440	92440	But it's one thing to show this stuff,
92440	94600	but at some point people will have all these questions
94600	96720	and if you can't really play with it,
96720	99720	you don't really get the sense, I think, of what it's about.
99720	101720	So I want everyone to be able to try it.
102880	107880	Okay, so the web browser version of Mini-Canron
108280	111340	is at this link right here, the veneer stuff, okay?
112720	113560	All right.
114000	118320	So here's my repo and I've got a file called talk.scm
118320	120560	and that's where I'm gonna have my code in it.
120560	123720	And the way I'm gonna do this is I'm gonna basically type
123720	128400	into the code into Emacs and then I'll paste it into veneer
128400	131200	and that's basically what y'all can do in terms of
131200	134240	opening up the file and get pasting into veneer,
134240	136280	running it and you can edit it in your own text editor,
136280	137400	you can edit it in veneer.
137400	140560	And I encourage you to try some different combinations
140560	142920	or different queries and see if you can break it,
143120	144440	see if you can run in infinite loops,
144440	147640	which you probably can, and so forth.
147640	150360	And if you have a cool example, you can share it.
150360	155360	This is, by the way, like version 0.01 of the technology
155560	157560	I would really like for giving interactive talks
157560	162000	where either Super Emacs mode or a web browser
162000	163440	or something like that where people in the audience
163440	165560	really could do this more seamlessly,
165560	168200	but that's tech I'm working on with other people
168200	169400	like Michael Valentine.
170400	174280	All right, so let's talk about mini-canon
174280	178280	and I'm gonna bring up the veneer editor,
178280	179120	let me refresh.
179120	180960	If veneer ever gets in a bad state,
180960	182520	you can just click refresh.
184840	189840	Let's see, is there, I can kind of make the font bigger.
189880	193920	The way you use veneer is if you've got code
193920	195760	on the left-hand side, you click the run button
195760	198960	and it'll evaluate this code and there's like
198960	200560	a little redeval print loop thing
200560	202160	you can just type for small expressions
202160	203760	if you wanna try those, okay?
205080	207240	And this is a relational scheme interpreter,
207240	210320	which we'll play around with something like that in a minute.
210320	211880	The main button you're gonna care about
211880	213640	is this create file button.
213640	217000	So if you create file, it's gonna blank whatever's
217000	219640	on the left, then you can just type in code here,
219640	222200	mini-canon code, and then click run
222200	224600	and it'll be evaluated on the right-hand side.
224600	227240	So let's just try something simple.
229080	232520	So I said I'll go to Emacs, but well,
232520	234000	let me try doing it in the veneer.
234000	235640	First of all, is the font big enough?
235640	236480	Can people see that?
236480	238280	I can try to bump it up a little bit.
242520	243760	If the run button will cooperate.
243760	247300	Maybe I can, there we go, look.
248800	250280	That run button's oversized.
250280	252360	Okay, so the first thing I'm gonna show,
252360	255240	so mini-canon, core mini-canon only has three operators.
255240	257160	It's a very small language, just like lambda calculus
257160	258080	is very small, right?
258120	261080	Lambda calculus has three parts,
261080	263480	and so does mini-canon for the core parts of the language.
263480	265240	And you can extend it, just like you can extend
265240	267280	mini-canon to get something like scheme, right?
267280	271560	So the most fundamental operator in mini-canon,
271560	273760	and mini-canon's a type of logic programming language,
273760	277200	like Prolog, it's got some real differences as well,
277200	279840	the fundamental operator is something called unification.
279840	281720	And unification you can think of as sort of like
281720	284800	a two-way super pattern matcher.
284800	287000	So if you're familiar with pattern matching,
287000	289440	then in a pattern match, you have some value
289440	291520	you're pattern matching against,
291520	294520	and then you've got some sort of pattern, right?
294520	296520	And in the pattern, you can have variables,
296520	299600	we call those match variables, or pattern variables, okay?
299600	302080	And those pattern variables get values filled in
302080	304480	from the value you're matching is.
304480	307200	Similar with unification, except you can have essentially
307200	312200	pattern variables on each side, okay?
313520	316680	So you can have variables on both sides.
316680	319320	And the variables don't actually ever have to be filled in.
319320	321080	That's fine also.
321080	324840	Variables don't ever have to get values in this paradigm.
324840	326240	So here we're gonna do something simple,
326240	330680	and you can also think of unification,
330680	333120	we call it equal, equal here really.
333120	335920	It's like a type of a quality operator also.
335920	340920	So here we're asking whether or not five is equal to five.
340920	343840	Or another way to look at it is we're asserting
343840	346120	that five must be equal to five.
346120	347840	And if it's not equal to five,
347840	352000	then we've reached inconsistent conclusion basically.
352000	353680	So is five equal to five?
355560	358120	One would hope, okay, yeah.
358120	360920	The logic isn't that weird, so let's run it.
360920	363280	And you can see, copy the expression,
363280	365640	and the answer is yes, well that's good.
365640	367280	That makes me happy.
367280	368120	All right.
369360	372680	Okay, so I promised I would do the interactive thing.
372680	374760	So here's our first program.
374760	377160	Equal, equal five, five, and I will check that in.
378280	379120	Okay.
381120	385400	So, are you supposed to like, how do you do this thing?
385400	387560	You do like a get add or something?
389720	390560	Get upload?
392160	393440	Add dot.
393440	394520	Oh, whoa, okay.
394520	396160	And I'm not really good at get, so.
396160	398360	And then get commit, is that how you do it?
399440	401200	Oh yeah, they do it.
401200	403760	Okay, so get commit, and I have to give a message,
403760	405400	and I'll say one is the message,
405400	407080	because that's the first one.
407080	408080	Okay?
408080	409360	All right, so you're following along,
409360	412640	that's the first, so you can do a pull,
412640	416160	and you can paste that complicated program into veneer.
416160	418920	Let's all do it, make sure we get the tech working,
418920	422960	and then click run, and you should be able to see yes, okay?
422960	425840	That's the first program, great.
425840	426680	Okay.
426680	427520	Yes.
427520	429200	For future reference, instead of doing the get add,
429200	432200	you can just put in dash A on the get commit.
432240	434720	Get commit dash A, ooh, yeah, okay.
434720	436080	All right, I like this, I'm learning.
436080	440800	Okay, so we can do another program, let's do a variant.
440800	442560	This is program number two.
442560	444080	What about six and five?
445440	446280	No.
446280	448140	No, that's right.
448140	449440	Computer says no.
449440	450720	All right, so.
451720	453120	What's about the proof of this?
453120	455120	The proof of it?
455120	455960	Okay, what is it?
455960	457760	Well, hold on, let me check in, my code, I promised.
457760	458600	Okay.
458600	460520	I guess I could, I could like,
460520	463120	look, like get keeps track of revisions.
463120	465400	So I'm not even gonna add another expression.
465400	467680	I'm just gonna like do that, and then it works, all right?
467680	469680	So I could do get, was it?
469680	474680	Get commit dash A, ooh, dash A and then two, right?
478640	479480	Do a pull.
481200	483560	Okay, so what's your question, Boodle?
483560	485440	You wanna know about the proof?
485440	487360	Why is five equal to five?
487360	489600	Why is five equal to five?
489600	491600	Well, let me change it up a little bit,
491600	493280	and maybe I'll answer your question.
493280	495040	I'm gonna put in something else.
495040	497480	Instead of a number, so having two numbers,
497480	500800	I'm gonna put in X, and X is a logic variable.
500800	501800	So you can think of it sort of like
501800	503440	this pattern variable, right?
503440	506080	Okay, so, so is X equal to five?
507720	508920	Yes, we don't know yet.
508920	511200	Yes, we don't know yet, okay?
511200	516200	We don't know, it could be, if X doesn't have a value yet,
516360	518840	then now it does have a value, right?
518840	520960	The answer is yes, and X is five.
520960	524560	But if X is already six, then the answer is no.
524560	525440	All right, so we don't really know,
525440	528160	but I'll say that X is starting out fresh.
528160	529520	We say fresh, it doesn't have a value yet.
529520	532880	So let's run that, yes, and beyond yes,
532880	537200	we see that X has a value associated with it, five, okay?
537200	538040	All right, cool.
543960	544960	Yeah, what?
547200	548040	What did that work?
549040	550840	Oh, I didn't say it.
552280	553120	Oh, you're right.
554160	555680	I got this hard, okay.
555680	559640	All right, so that's one thing we can do, all right?
559640	561940	And so if you look at it this way,
561940	565720	then basically what we're really saying is an assertion.
565720	568440	We're saying that the thing on the left
568440	571200	is syntactically equal to the thing on the right.
573320	576800	As long as you kind of find some set of values
576840	579320	that are assigned to these variables inside the terms
579320	581120	that will make them syntactically equal, right?
581120	585000	So the question is, is there any possible assignment for X
585000	586800	that will make the left and right hand side equal?
586800	589680	And the answer is yes, as long as X is five,
589680	591200	then they'll be equal, okay?
591200	594560	So that's the sort of reasoning you do with unification.
594560	598720	And we can even put variables on both sides, X and Y.
598720	600560	So what should the answer be here?
602080	604640	Yes, and furthermore, what else do we know?
605640	608000	We know that Y is five.
608000	610360	Well, let's say we got rid of the original program, right?
610360	613860	This is the whole program now, so there are no fives anymore.
613860	617040	X and Y are the same, presumably.
617040	620080	And so we can see here that X and Y
620080	621880	are both associated with some value.
621880	624440	And this itself is a representation of a logic variable
624440	625640	that doesn't have a value.
625640	627860	And you can see that they have the same number.
627860	630000	If they were different, you'd see a one here
630000	631280	in one of them and a zero in the other.
631280	633480	So it's telling us it really is the same,
633520	635160	the same logic variable, okay?
638560	640920	I'm gonna get the hang of this soon, so that's...
640920	642560	So the definition of the point to that,
642560	644680	that's not too much you can make?
644680	646760	It's basically a syntactic definition, yeah.
646760	651400	So you could define it recursively, like over a tree.
651400	653080	Okay, so that's the big operator.
653080	655520	And of course, we can have more complicated data structures.
655520	659800	So we could do, you know, I think Vanir has this.
659800	662320	Let's see if Vanir has a list.
664480	667720	Yeah, so Vanir has a list in it.
667720	670480	So we're creating a list containing X and a list containing Y.
670480	672080	And because they have the same structure,
672080	673760	that's fine also, okay?
673760	678560	But if we had, say, list X and Y,
681360	683120	well, what would happen in this case?
684160	685000	Is it gonna succeed?
685000	685840	Is it gonna fail?
689680	691320	It's gonna be yes.
691320	695440	And notice, we have the same logic variable here for the X,
695440	697920	but now Y wraps a list around it, okay?
698840	699680	Yes?
699680	701000	Why do you use nothing rather than
701000	703280	supposed to create a substitution
703280	705840	that says X equals Y, Y equals X?
705840	707040	So that's a good question.
707040	708640	Internally, there is a substitution.
708640	711040	The question is about why aren't we using a substitution?
711040	712360	Internally, there is a substitution,
712360	714280	and this is actually the representation
714280	716280	of the substitution, okay?
716280	718880	We're seeing as the output representation of substitution.
718880	720440	All right, here's one more.
721320	725640	List X and X, what's the value there?
728040	728880	Yes, no?
729840	731440	What should I get printed out as?
736000	737200	Infinite tree.
739200	744200	No, we're not allowed to have a term unified with a term,
745880	748360	with a structure containing that term, okay?
748360	750960	And this gets to what Phil was talking about,
750960	752800	where you can have these infinite structures
752800	754280	and you run into trouble with that.
754280	756280	So we're doing what's called the occur check.
756280	758360	We're checking to see if X occurs in the structure,
758360	762720	and if so, we're going to say, no, no answer, we fail, okay?
762720	764840	And that's important, this is how we get soundness.
764840	767560	If we don't have that, we can prove all sorts of things
767560	770040	that aren't true and get in trouble.
770040	772800	Okay, so that's unification, that's the main operator.
774640	775880	What else do we have?
775880	779200	Well, we have the ability, yes, all right.
779200	780040	Question around?
780200	784880	I couldn't get it to fail on more than one term.
784880	787320	You couldn't get to fail on more than one term, so.
787320	789800	If we have unification between X and five,
789800	790880	and then I get everything.
790880	793040	Ah, I see, okay, good question, good point.
793040	797600	So I think what Rob's saying is if you do something like this,
797600	799840	and then you have another equal equal,
799840	803160	and we're saying six and X, right?
803160	805280	Then you think that's inconsistent information,
805280	807400	but we're still getting a yes that X is six.
807400	809960	So let me go ahead and show you
809960	811520	how we can sequence things.
811520	813440	So what Vanir is doing is it's assuming
813440	814520	these are two separate programs,
814520	816080	it's ignoring the first, essentially,
816080	818200	and just giving us the answer from the second.
818200	819280	That's a good point.
819280	821920	So let me show you the second operator of mini-canon,
821920	823560	which is called fresh.
823560	826020	And what fresh allows you to do is a conjunction.
827520	831400	Okay, so now we have a conjunction of goals like that,
831400	834120	and I can run that, and now my answer is no.
834120	836180	Okay, so fresh acts as a conjunction.
836180	838040	Fresh has one other purpose.
838040	841400	Fresh also lets me introduce new logic variables.
841400	842480	Now the way Vanir works,
842480	844560	which is a little different from standard mini-canon,
844560	846320	Vanir acts more like prologue,
846320	850640	and these variables that aren't defined lexically,
850640	852320	those become new logic variables.
852320	855000	So you need to use fresh less than Vanir
855000	856560	than you do in standard mini-canon.
856560	858040	But if we add a Y there,
858040	860880	that will allow us to create a locally defined
860880	863560	logic variable that has no value called Y.
865360	866760	So that's the fresh form.
868040	869760	All right, that's a pretty complicated program,
869760	872640	so I better add that.
873760	878360	And yeah, okay.
878360	879760	All right, good.
879760	882440	So you've seen two-thirds of the language now,
882440	886120	fresh and equal, and then I'll show you the last part.
886120	887520	Last part's con-dee,
887520	889080	and this is something that allows us
889080	890880	to get more than one answer back.
890880	893040	Okay, because it'd be kind of boring
893040	895680	if our programs could only return one answer.
895680	897480	And one of the points of logic programming
897480	901080	is that we can return potentially infinitely many answers.
901080	902600	So the way we're gonna do that,
902600	906200	and mini-canon syntactically looks a lot like scheme,
906200	909400	because it's the original implementation of the scheme.
909400	912480	So con-dee is based on Lisp's con operator,
912480	913600	which is a conditional operator,
913600	917120	sort of like a big, giant type of if,
917120	919560	or pattern, sort of like a pattern matching syntax,
919560	920560	but it doesn't have a pattern match
920560	922400	or build into it explicitly.
922400	924240	So we're gonna have a con here.
925080	930080	Sorry, con-dee, e stands for every answer.
930560	934080	And the syntax for con-dee is that for each clause,
934080	936600	each con-dee clause has set of parentheses,
936600	940360	and then it takes one or more of these sub-expressions,
940360	941520	there's other mini-canon expressions,
941520	942760	which are called goals.
943920	948400	So equal five x is a goal, I'll pop that in there,
948400	952520	and equal six x is a goal, I'll pop that in the second case.
955040	958720	And, all right.
958720	960360	So what's gonna happen here?
960360	963200	Well, the idea is that we're trying
963200	965280	each of these two clauses independently.
965280	966960	We're gonna try one of the two clauses,
966960	969520	and it's unspecified mini-canon, which one we try first.
969520	971760	Let's say we try the second one first.
971760	973960	So we would try unifying x with six,
973960	977320	x would get, we get yes, x would be associated with six,
977320	979880	and then we could ask for another answer.
979880	981280	And we ask for another answer,
981280	983720	it's as if we had never tried this one.
983720	984920	We try the other one.
984920	988360	And now we forget this association between x and six,
988360	991680	x is refreshed magically, and we're gonna try it again,
991680	993080	and now x will be five.
993080	995800	So it gives us a chance to try different branches
995800	996640	of a program.
996640	998120	So it's similar to like an if,
998120	1001720	except an if where you can independently try
1001720	1003960	all the possibilities, all the tests,
1003960	1006320	and the consequence, and so forth independently.
1008480	1012880	Condi is like a disjunction, and fresh is like a conjunct.
1012880	1015640	Condi is disjunction, fresh is conjunction.
1015640	1016960	That's right.
1016960	1018920	And there's a simplified version of mini-canon
1018920	1022160	called micro-canon, where conjunction and disjunction,
1022160	1024400	binary versions of those, are the primitive operators.
1024400	1026040	So those are much closer to logic.
1026040	1028720	This is closer to maybe a nicer syntax
1028720	1030400	to program with for real programs,
1030400	1032240	but if you wanna see the more primitive stuff
1032240	1034200	that's closer to logic, look at micro-canon.
1034200	1036480	And that has the very short implementation,
1036480	1037800	the implementation of micro-canon,
1037800	1039440	something like 46 lines of scheme code
1039440	1041800	for all the logic programming system.
1041800	1045000	So we can try running this, and we get the first answer,
1045000	1048120	so we try the first one, first clause
1048120	1049480	in this version of mini-canon,
1049480	1051680	and we can click on more answers,
1051680	1053680	and hey, now we've tried the other clause,
1053680	1055960	where x is six, so we're not inconsistent
1055960	1057200	because we're trying these clauses
1057200	1058920	totally independently of each other,
1058920	1060160	and we can ask for more answers,
1060160	1063320	and finally we say no, no more answers, that's it.
1063320	1066320	And if you've ever used Prolog, this part is very similar.
1067480	1069600	All right, and that's the entire language,
1069600	1070920	the entire core language.
1070920	1072960	There are basically three other operators
1072960	1076600	that we might run into, but that's the basis of it, okay?
1076600	1077700	Any questions?
1079520	1081200	Who's playing along, by the way, I'm just curious,
1081200	1082360	how many people?
1082360	1083960	Oh, whoa, that's pretty good, all right.
1083960	1087400	So now let's try something more complicated, all right?
1088480	1090400	All right, let me keep myself honest,
1091360	1092880	and check myself in.
1094040	1095520	All right, and our programs are gonna become
1095520	1098640	more complicated here, so the check-in thing will be a little,
1098680	1101720	whoops, oh, I checked that in, it's five.
1101720	1106120	Oh, here, I'll hack it, I'll put in a space,
1106120	1107600	and check it in as six.
1107600	1112600	Yes, I need to work on my get skills, that's fine.
1115600	1118480	Oh, I need to push, yeah, thank you.
1119720	1124720	Yeah, my dream tool would have me not have to do this step.
1125640	1128480	All right, okay, so let's try
1128480	1130280	something a little more interesting.
1130280	1133360	So Phil was talking about Lambda Calculus yesterday,
1133360	1135800	and he showed that there are three
1135800	1139000	basically parts of Lambda Calculus, so you have variables,
1139000	1141600	you have Lambda terms themselves,
1142840	1145000	which are called abstraction in Lambda Calculus,
1145000	1146560	and then you have application,
1146560	1148400	applying something to something else.
1148400	1151160	So we have these three things,
1151160	1153000	and if I write down comments,
1153000	1154440	hopefully Vanir will check on this,
1154560	1157760	so we have, something like X is a variable,
1159680	1161400	and then we have something like,
1162920	1165440	I'm gonna write it in sort of like the schemely way,
1165440	1170440	like Lambda X, Y, so that's an abstraction,
1172360	1177360	ABS, and then you have something like an application,
1177760	1182760	so we're applying F to G or something like that.
1183480	1186240	So that's an application.
1186240	1188880	So those are the three syntactic forms
1188880	1191080	that we have in the Lambda Calculus.
1191080	1194920	So let's try just writing something in mini-canon
1194920	1197680	that will actually recognize
1198400	1201560	a valid Lambda Calculus term syntactically.
1201560	1203120	So let's just try doing that.
1203120	1205680	So how should we do that?
1205680	1208040	Well, we're gonna define a function,
1208040	1210760	so this part is pretty much like scheme.
1210760	1212560	Let's try defining a function,
1212680	1217680	and so let's call this, I don't know,
1217880	1222880	Lambda Calculus Syntax Syn, LC Syn, okay?
1223960	1228760	And because we're in a schemely language,
1228760	1233200	we're going to ourselves define this function using Lambda,
1233200	1235320	and we're gonna give it some argument,
1235320	1238920	so I'll say we're taking, well, under a term,
1238920	1241680	Lambda Calculus term, okay?
1241680	1244760	And now what we wanna do is basically match
1244760	1246800	against the three possible terms.
1246800	1250840	So which form do you think I should write here next,
1250840	1253120	or which mini-canon operator?
1254040	1256760	So I got, Kandee, Kandee,
1256760	1258640	because I have choices to make, right?
1258640	1260460	So I've got Kandee, and how many clauses
1260460	1262440	am I gonna have for this Kandee?
1262440	1265040	Three, okay, that's right.
1265040	1267960	So I go ahead and write down my clauses to begin with,
1267960	1271840	all right, and now what I'm gonna do
1271840	1274480	is for each of my syntactic forms,
1274480	1277800	I'm going to write down a clause for that, okay?
1277800	1281800	So let's start with, I don't know,
1284480	1286040	the application term.
1286040	1288200	All right, let's do the Lambda term, actually.
1288200	1289640	Okay, so what am I gonna write,
1289640	1291920	what sort of mini-canon expression am I gonna write
1291920	1294120	in that clause to match against the Lambda?
1295120	1296760	I'm gonna write Kandee, I'm gonna write Fresh,
1296760	1298920	I'm gonna write Equal Equal.
1298920	1301400	What would I use for pattern matching, basically?
1302400	1303240	Equal Equal, right?
1303240	1305360	That's sort of like the two-way super pattern matcher.
1305360	1307480	So let me write an Equal Equal expression,
1307480	1311480	unification expression, and what am I gonna unify?
1311480	1315640	I need two terms, two values, so I'll unify what?
1319480	1322800	Term, okay, the term that came in, that's right,
1322840	1324880	and I'm gonna unify that with,
1324880	1326840	well, something that looks like my Lambda expression,
1326840	1328280	right, I have to write something down
1328280	1330600	that syntactically looks like it.
1330600	1333600	Okay, so what I'm gonna do is I'm gonna just copy this thing.
1338280	1340160	All right, and,
1346040	1347920	ninja it a little bit.
1347920	1349280	Oh, look at that, huh.
1350280	1353360	Yeah, okay.
1353360	1357680	All right, so that's kind of what my expression looks like.
1357680	1359520	Now, there are a couple things here.
1359520	1361960	So I've got like X as a variable,
1361960	1364120	and this thing in the middle is really like
1364120	1368520	the body expression, or E, or T, some other term, okay?
1368520	1371280	So we got a variable, and we got some term here.
1372760	1377440	And to make this schemely, we need to make this
1377440	1380720	not a Lambda expression in many cannon or scheme
1380720	1383360	in the host language, we need to make this a data structure
1383360	1385600	that we can literally pattern match against.
1385600	1388240	So we're gonna create a list,
1388240	1390080	and the one way to do this in scheme
1390080	1394680	was with this back tick operator called quasi quote,
1394680	1398000	and it's sort of like a string interpolation style thing
1398000	1399560	if you're familiar with that.
1399560	1404560	Basically, if we put a comma in front of sub expressions,
1405320	1407920	that means that these things here
1407920	1409760	are gonna be literally filled in,
1409760	1411520	they're like holes to be filled in,
1411520	1415220	with whether the values of X and T are at that time.
1416360	1418700	And we need to have some X's and T's here.
1418700	1422000	So what I'm gonna do is I'm gonna create a fresh
1422000	1425000	so I can have two new variables for X and T.
1426120	1428240	Okay, so I'm creating two new logic variables,
1429320	1432440	and I'm gonna grab that.
1435560	1439440	And I might have to drag this even more.
1440800	1442880	All right, there we go, perfect.
1442880	1447480	Okay, so when we're writing these sorts of programs,
1447480	1450560	it's good to try to test them sort of incrementally.
1450560	1454560	So what I'm gonna do is I'm gonna temporarily comment out
1454560	1459360	the first and the third clause with the comments and scheme,
1459360	1461640	and I'm gonna just try running this thing
1461640	1462900	to see if it works,
1462940	1464420	because I'm not sure if it will,
1464420	1466980	because I don't use veneer normally.
1466980	1468900	So let's see if it works.
1468900	1472500	Hash T, ah, cool, okay,
1472500	1473620	because we didn't actually call it.
1473620	1477320	So we can actually make a call to LC sin now.
1477320	1482320	Let's try calling LC sin, and let's give it a term.
1482320	1487320	So let's give it the term lambda z, z,
1488860	1490720	and see if that succeeds.
1490720	1493200	And it says yes, it does succeed.
1493200	1495600	So this means that this is syntactically valid.
1495600	1497480	Great, okay.
1498920	1503480	So let me come up that in, or check that in.
1504640	1506240	So here's our first version of it.
1510720	1513600	And version seven.
1514760	1518360	Okay, all right, and notice I could just test it
1518360	1519440	one line at a time, right?
1519440	1521480	So let's do the application line now.
1522640	1525080	Okay, so here we're gonna have an application.
1525080	1526880	Once again, I'm gonna wanna have a fresh
1526880	1528980	to introduce some logic variables.
1528980	1530560	I'll say e1 and e2.
1531600	1535320	And the syntax of an application
1535320	1539360	is that we have term e1 applied to term e2.
1539360	1541160	And so that's what that looks like.
1541160	1546160	And I'll go ahead and check that out.
1561280	1564000	All right, so two thirds of the way done.
1564000	1565200	And I could test that also,
1565200	1567240	but I've got some confidence in it.
1567240	1571040	So let's now do the last one, which is the variable x.
1571880	1575240	And we're gonna represent a variable as a symbol
1575240	1576960	and scheme, a scheme symbol.
1576960	1581240	And so we've added to sort of the core logical foundations
1581240	1584900	of many canron, a few constraints that make it easier
1584900	1586760	for writing things like interpreters
1586760	1588760	and type inferences and type checkers
1588760	1591640	and grammar-based programs.
1591640	1594920	And one of the constraints we have is called simbolo.
1596480	1600760	So, simbolo, so if the term is a symbol,
1601280	1603120	then we say, hey, that's a variable.
1603120	1605320	That's syntactically legal.
1605320	1609640	So simbolo is the last way we can represent.
1609640	1610480	We're not actually saying,
1610480	1612400	we don't care if it's x or y or whatever, right?
1612400	1614200	But we care that it's a symbol.
1614200	1616200	So let's see if that runs.
1616200	1618200	Yes, okay, cool.
1618200	1622680	And we can try if we want some other tests.
1622680	1627480	So we could say, well, actually maybe it's lambda,
1631320	1636320	z and z applied to z or something like that, okay?
1636800	1638480	So we got an application,
1638480	1642960	we have variable reference and we have a lambda.
1642960	1645960	So let's see if that's syntactically valid.
1645960	1649040	Yes, that's syntactically valid, okay?
1649040	1651960	All right, so we've implemented our grammar
1651960	1653760	and we've got all that stuff working
1653760	1655440	and let me check that in.
1656440	1660920	And this is check-in number nine.
1662680	1664240	All right, cool.
1664240	1668360	Now, okay, that's kind of cool that we can write that.
1668360	1672360	But what would be more cool is if we can use
1672360	1674800	those logic variables we've been using other places,
1674800	1675840	if we could actually use that
1675840	1677920	inside of our call to LC-SIN.
1677920	1680120	So right now we're having to give a fully ground
1680120	1684200	or fully specified lambda calculus term.
1684200	1686960	And we're checking, we're verifying, validating that term
1686960	1689160	and make sure it's syntactically legal.
1689160	1692760	But it'd be really cool if we could instead
1692760	1696920	put in a logic variable and say generate a valid lambda term.
1696920	1698080	So let's try that.
1698080	1700520	So I'm gonna get rid of that term.
1700520	1705320	And I'm going to put in my term,
1706360	1710240	or I don't know, I was called Q for a query variable, okay?
1710240	1714440	So now I've got this query variable in place of the call.
1714440	1716160	And let's try doing a run now.
1717920	1722480	And so the first answer is yes.
1722480	1724600	So we're getting back this underscore zero thing
1724600	1726200	bound to Q, that's, if you remember,
1726200	1729080	that's a representation of our fresh logic variable.
1729080	1730840	And we have the side condition.
1730840	1732280	The side condition is saying
1732280	1735280	that that underscore zero thing has to be a symbol.
1735280	1738400	So it has to be, if you were ever to instantiate it
1738400	1741440	to a ground value, it would have to be a legal scheme symbol.
1741440	1744000	And scheme symbols are how we're representing variables.
1744000	1746960	So what this is saying is that any symbol, that's fine.
1746960	1749200	That's just a lambda calculus variable.
1749200	1750760	So that's actually representing
1750760	1752560	infinitely many concrete values,
1752560	1754640	infinitely many ground symbols.
1754640	1756720	Now let's see if we can get another answer.
1756720	1760000	Okay, here we're saying,
1760000	1763640	ah, if we have a lambda term
1763640	1766200	and it has the right structure,
1766200	1767920	has parentheses and something, that's fine.
1767920	1770080	And if it has something else in the back
1770080	1772280	and could be different, that's fine.
1772280	1774520	That's not very constrained.
1774520	1777720	But okay, that's fine as far as it goes.
1777720	1778960	What about this underscore zero thing?
1778960	1781720	What should that be syntactically for this to be legal?
1782880	1783720	Should be a symbol.
1783720	1785720	Okay, so maybe we're a little sloppy.
1785720	1787040	Let's go back.
1787040	1789920	And so we can add a side condition maybe.
1789920	1792120	Okay, so what else can I write here
1792120	1793920	to kind of lock it down a little more?
1794640	1800040	So I can do symbolic x, okay, and symbolic t.
1800040	1801960	So do we know if t is actually a symbol?
1801960	1803280	That's a good question.
1803280	1804120	What is t?
1806160	1808880	It's an arbitrary lambda calculus expression.
1808880	1810520	So what do we need to write here?
1812640	1814760	LC sin, yeah, we need recursion.
1814760	1816760	LC sin on t.
1816760	1817840	So that was part of the problem.
1817840	1819120	We weren't recurring properly.
1819120	1821320	Anything else you see that's wrong
1821320	1823760	in those along the similar vein?
1823760	1825560	Anywhere else where we were sloppy?
1826840	1827760	Application, right?
1827760	1829400	We have about these e1 and e2 things.
1829400	1831160	We're not putting any structure on those.
1831160	1835600	Those actually have to be lambda calculus terms themselves.
1835600	1837720	So we need to recur.
1837720	1842720	Okay, sin on e1, okay, LC sin on e2.
1843720	1846720	All right, so hopefully that'll work.
1846720	1847560	Let's see.
1847560	1850320	Sin, okay, sin.
1851720	1853200	Good, thank you.
1854760	1855840	Ah, okay, cool.
1855840	1857440	So let me paste that in.
1862600	1865920	All right, so this is check-in number 10.
1869040	1871320	All right, so if I run that, let's see.
1871320	1873760	So we have the symbol answer like we had before.
1875120	1877120	Ah, okay, so this looks better.
1877120	1880200	So now when I get a second answer that I'm generating,
1880200	1881480	it's like, okay, well, it still has
1881480	1882960	that same structure we saw before,
1883000	1884360	but now we have some side conditions.
1884360	1887640	We're saying underscore zero has to be a symbol.
1887640	1891160	And here we're saying the body is a symbol in that case.
1891160	1895320	So this, and they could potentially be separate symbols,
1895320	1896400	but they could be the same symbol.
1896400	1899000	That's what having the underscore zero and underscore one means.
1899000	1900760	So this could be lambda zed zed,
1900760	1903040	or it could be lambda zed w or something like that.
1903040	1904600	Those would both be legal.
1904600	1905960	And I can ask for more.
1905960	1908280	So here's an application where you have a symbol applied
1908280	1911960	to a symbol, okay, and I can keep generating more of these.
1911960	1916040	So here's a lambda whose body is another lambda, right?
1916040	1917280	So now I can generate these
1917280	1920360	and I can enumerate every possible lambda calculus terms
1920360	1921360	and tactically, right?
1922600	1927520	Okay, so that's basically the cool idea
1927520	1930700	about pure logic programming.
1930700	1933440	And many canons really language for pure logic programming
1933440	1935880	where the idea is you can just write down
1935880	1938040	mathematical specifications, something like that,
1938040	1939640	and have something close to the math.
1939640	1941720	And then once you have that,
1941720	1943640	you can just use the same code,
1943640	1945680	not just to check that something's correct,
1945680	1947800	but also to generate answers.
1949240	1954240	All right, so let's do this.
1955240	1958880	Okay, so what I'm gonna do is I'm gonna refresh veneer.
1960920	1962920	Just refresh the browser,
1962920	1964900	make sure it's not in a goofy state.
1964900	1967720	And you can see up top there are some different programs.
1967720	1970840	So let's see if I try type inference.
1970840	1973260	Okay, so if I go to type inference,
1977520	1982520	you can see that we've got this mini canron definition
1983160	1987800	called bang slash zero or dash zero or something, okay?
1987800	1988800	What it's supposed to look like
1988800	1991560	is a turn style operator in logic.
1991560	1993840	It's supposed to look like one of those special symbols
1993840	1997160	that you saw in Phil's presentation.
1997160	1999760	So this is gonna be a type inferencer.
1999760	2003120	And if you've ever used a language like ML, for example,
2003120	2004960	you know what type inference is,
2004960	2006800	you can write down the expression,
2006800	2008840	and the type inferencer will try to figure out
2008840	2011080	what the type of that expression is.
2011080	2013880	So here we have three moving parts.
2013880	2017880	We have the expression that we're gonna type infer.
2017880	2021240	We have gamma, which is like a type environment,
2021240	2023560	it allows us to accumulate information
2023560	2025280	about the subparts of the expressions,
2025280	2026320	what those types are.
2026360	2031360	And then type is the type of that expression, all right?
2031480	2033680	And you could see actually already
2033680	2035320	what some of the similarities are.
2035320	2038320	So symbolo expert, this is the symbol case,
2038320	2040160	this is our variable case, right?
2040160	2041640	And in this case, it's not just saying,
2041640	2043720	well, that's it, you have a symbol.
2043720	2046640	Now we're gonna look up in the type environment
2046640	2049400	what that symbol is, what the type of that symbol is,
2049400	2052280	because hopefully this is not a free variable,
2052280	2053800	this is a bound variable.
2053800	2055920	And we might know that that variable, for example,
2055920	2059400	is bound to an int, has type int, okay?
2059400	2061900	And there's some other cases, like for example,
2061900	2064960	is the expression coming in a number?
2064960	2066880	So number is another constraint.
2066880	2069800	And if so, we're gonna say the type
2069800	2071920	of that sub-expression is int, okay?
2071920	2072760	That's our int type.
2072760	2074800	So five would have type int.
2074800	2077360	If it's a Boolean, like hashf in the scheme,
2077360	2079920	it's gonna have type bool and so forth.
2079920	2084360	And then we're also gonna have some more sophisticated rules
2084360	2087560	for lambda, okay?
2087560	2091400	And if you look at the lambda rule closely,
2091400	2093720	and if you look at the math that Phil put up,
2093720	2098560	or is in his paper, you'll notice that these rules
2098560	2100320	essentially are the same, okay?
2100320	2101640	So this is what he was talking about
2101640	2104140	with the Curry-Howard isomorphism,
2104140	2107720	and that basically we have a little theorem prover here
2107720	2110040	in the form of a type inferencer.
2110040	2113440	And similarly, we have application rule,
2113440	2115800	and we also have a special version of let,
2115800	2118280	and we have things like addition and so forth, okay?
2118280	2122680	So let's just try doing something that says type inferencer.
2122680	2125480	So here's an expression that it comes with,
2125480	2128080	but let's try something simpler.
2128080	2130960	So let's try calling our type inferencer,
2130960	2134160	and we have to give it an initial type environment.
2134160	2136000	And we're gonna say that that initial type environment
2136000	2136840	is empty.
2138760	2141200	And now we have to give it some expression,
2141200	2143320	I don't know what that expression is gonna be,
2143320	2145280	and then it's gonna have some type,
2145280	2148280	and I will just write Q for the query variable for the type.
2149240	2152240	So what's an expression that we might want to type check?
2152240	2155400	Well, let's do something simple, like five.
2155400	2157400	I'm putting a quote here, by the way,
2157400	2162080	to make sure that whatever expression is here
2162080	2166040	isn't evaluated at the host level, at the scheme level,
2166040	2168840	but it's actually evaluated or looked at,
2168840	2172060	that term is looked at in the type inferencer itself.
2172100	2173660	So what should the type be here?
2173660	2175140	What should the type of Q be?
2177980	2181860	Should be an int, yeah, so that worked, it's an int, okay?
2181860	2186260	And I can do something like plus, right?
2186260	2188820	So plus three, four, what should the type of that be?
2189820	2193060	That should be int, okay, sure enough, we got an int.
2193060	2198060	What about plus hash f, four, what should the type of that be?
2198260	2202060	Computer says no, all right, and we can also look
2202060	2204060	at things like a lambda expression.
2204060	2207060	What about lambda xx, which of the type of that be?
2210060	2213060	Well, it should be equivalent to some sort of function type,
2213060	2216060	right, so yeah, so we're gonna have something like a arrow a,
2216060	2219060	and you can see that we have a fresh logic variable,
2219060	2221060	arrow, fresh logic variable, so the thing on the left
2221060	2223060	is the input type for the function,
2223060	2225060	the thing on the right is the output type.
2225060	2227060	The underscore zero means that this is a fresh variable,
2227060	2229060	it means it could be anything,
2229060	2231060	but the input and the output have to be the same
2231060	2233060	because it's the identity function, okay?
2233060	2236060	So this is a very general answer, all right?
2236060	2238060	And we could try doing an application.
2238060	2243060	We could try doing something like applying that lambda term
2243060	2248060	to the value of plus three, four,
2248060	2250060	and now what type should we get back?
2251060	2253060	Should get back in it.
2254060	2256060	Should get back in it, okay?
2256060	2258060	Cool, all right, so that all works.
2258060	2260060	So this is a working type inferencer,
2260060	2263060	and for the most part we just kind of wrote down the rules,
2263060	2266060	the math, you know, you could take the rules
2266060	2269060	Phil showed and essentially type those in.
2269060	2272060	Now where it gets more interesting is,
2272060	2275060	and this is where the Curry-Howard part really becomes
2275060	2278060	way more interesting to me, is that we can say,
2278060	2280060	because we're in the logic programming domain,
2280060	2283060	we can say that the type is going to be int
2283060	2287060	and that we don't know what the input program is, right?
2287060	2290060	So now we're going from type inference
2290060	2293060	to type habitation or inhabitation.
2293060	2296060	We're trying to find a term that inhabits this type, okay?
2296060	2300060	So what would be a simple term that would have the type int?
2300060	2303060	Zero, okay, sure.
2303060	2306060	Well, zero is a little specific of an answer.
2306060	2308060	We get back a more general answer that includes zero.
2308060	2310060	So we're getting back some fresh logic variable
2310060	2312060	with a side condition that has to be a number, okay?
2312060	2316060	So that's zero, but it's also 42.
2316060	2318060	Is there any distinction between numbers and integers
2318060	2320060	and not supporting floating points?
2320060	2322060	Okay, so good question.
2322060	2324060	Are we supporting integers, floating points, so forth?
2324060	2328060	Right now, in this one, we're only supporting positive integers.
2328060	2330060	Actually, if we could probably do negative integers, I don't know.
2330060	2333060	This one, yeah, I think this one works with negative integers, too.
2333060	2335060	But, well, we could try that.
2335060	2339060	See what the type of negative five is.
2339060	2341060	But I think this is only handling integers.
2341060	2343060	But we could add other constraints
2343060	2345060	that would handle other numeric types.
2345060	2348060	Oh, okay, it doesn't like negative five, I guess.
2348060	2351060	So I guess number O in this implementation
2351060	2354060	only handles non-negative integers.
2354060	2356060	But you could add more things.
2356060	2360060	In fact, when I worked with Eric Holk and Claire Alvis
2360060	2364060	on this language called Harlan,
2364060	2368060	the original version of Harlan is sort of like a schemely language
2368060	2370060	for GPU programming,
2370060	2374060	but it had like an ML-style type system.
2374060	2380060	And the original type inferencer for that was written in C Canron.
2380060	2383060	And we had to extend these operators
2383060	2385060	to handle different types of numbers.
2385060	2388060	So you can do that. You just have to add other constraints.
2388060	2391060	Okay, so what else can we do here?
2391060	2394060	What other sorts of things should we get back
2394060	2396060	other than just a literal number?
2396060	2398060	Well, let's see what many Canons says.
2398060	2401060	So here we have a let.
2401060	2405060	So we're saying let some variable, which is a symbol,
2405060	2408060	which has some number value.
2408060	2410060	It doesn't matter what it is, because we're ignoring it,
2410060	2413060	and the body of the let is some other number.
2413060	2415060	Okay, well, that's true. That has type in.
2415060	2418060	And it's well-typed. It's the type checks, right?
2418060	2419060	And here's another one.
2419060	2423060	So here we're saying let some variable, the symbol, be hash f.
2423060	2424060	We're ignoring that.
2424060	2426060	We're returning the body, which is underscore one,
2426060	2428060	and that has to be a number.
2428060	2430060	And so we could play these games.
2430060	2435060	And at some point, okay, so now we get an addition of two numbers.
2435060	2437060	And here, now we start getting into applications.
2437060	2440060	So we're getting a lambda term, a lambda expression,
2440060	2442060	and it's being applied to something.
2442060	2443060	So let's make sure the types work.
2443060	2444060	So we're passing in a number.
2444060	2446060	That's our constraint.
2446060	2448060	And here we have some symbol.
2448060	2449060	And we're ignoring what's passed in,
2449060	2453060	and we're returning some other potentially different number.
2453060	2458060	So you can play these games all day.
2458060	2460060	And yes, you get.
2460060	2463060	You can keep clicking more answers for as long as you want.
2463060	2465060	All right, I'm going to refresh one more time.
2465060	2470060	And I'm going to show you something that's a little more fancy.
2470060	2472060	But by the way, that type inference stuff,
2472060	2474060	or the type inhabitation,
2474060	2480060	that is the thing that many of the modern proof assistants work on.
2480060	2482060	Okay, I'm going to be Dijkstra in two minutes,
2482060	2485060	but I'm going to go ahead and show you very quickly
2485060	2487060	what you can do with a relational interpreter.
2487060	2492060	So here we have an interpreter for a significant subset of scheme.
2492060	2494060	It's basically our extended lambda calculus,
2494060	2496060	if you want to look at it that way.
2496060	2500060	And so we have this, a val expo thing.
2500060	2503060	And so we can evaluate an expression.
2503060	2507060	I think we have something called, yeah, a val expo.
2507060	2510060	And let me just show you one query to a val expo,
2510060	2512060	and hopefully this will work.
2512060	2515060	So we're going to call a val expo.
2515060	2518060	And a val expo takes, sort of like the type inference,
2518060	2527060	it's going to take an expression and an environment and then an output.
2527060	2530060	So we're going to say, we've got some expression we don't know.
2530060	2532060	We're going to start in the empty environment.
2532060	2536060	And we want to see if we can create some expression,
2536060	2540060	find some expression that in the empty environment evaluates to itself.
2540060	2543060	Well, let's see if we can do that.
2543060	2547060	Whoa, what is that thing?
2547060	2549060	Well, that's kind of weird.
2549060	2553060	Okay, so we got this weird looking thing.
2553060	2558060	And let me just go to Emacs and start up scheme.
2558060	2561060	I'm going to try to type that in.
2561060	2565060	Format it in ways a little easier to understand.
2565060	2567060	I'm going to try running that.
2567060	2570060	Oh, wow, I got back the same thing.
2570060	2572060	So that's called a quine.
2572060	2575060	That's a program that evaluates to itself.
2575060	2579060	And by the way, if you look at, you know,
2579060	2582060	here's my last comment that I'll make that's historical.
2582060	2589060	If you look at the micro manual for Lisp by John McCarthy,
2589060	2596060	he says, it's a difficult mathematical type challenge exercise right here.
2596060	2600060	Find the list E such that the value of E is equal to E.
2600060	2604060	And that's what we just did by typing in the rules for scheme
2604060	2607060	and letting many canren do it.
2607060	2609060	So I hope you'll have fun playing with it.
2609060	2611060	And if you have any questions, I'm happy to answer them.
2611060	2613060	Thank you.
