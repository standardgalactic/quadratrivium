1
00:00:00,000 --> 00:00:16,040
Thank you. This always happens to me at CodeMesh. I have an idea for a talk, and then after

2
00:00:16,040 --> 00:00:20,560
seeing a keynote or having a conversation with someone, I'm like, throw that out. Actually,

3
00:00:20,560 --> 00:00:23,940
Boodle last night tried to convince me to give a talk on StarCraft instead, which I'm

4
00:00:23,940 --> 00:00:32,620
sorely tempted to do, but maybe next year. Yes. But I saw Guy Steele's keynote last night,

5
00:00:32,620 --> 00:00:38,260
which I loved, and I have to say that I love Scheme. I agree with Alan Kay that Lisp is

6
00:00:38,260 --> 00:00:42,960
the most important programming language ever created, and for my money, Scheme is the most

7
00:00:42,960 --> 00:00:50,240
important Lisp. So I think Scheme is one of the great joys of my life. I love programming

8
00:00:50,240 --> 00:00:55,920
and Scheme, and when I went to Indiana University to get my PhD, I went there specifically to

9
00:00:55,920 --> 00:01:01,140
work with Dan Friedman and get my PhD in Scheme. On the first day of grad school, I walked

10
00:01:01,140 --> 00:01:07,820
up to Dan, and I said, I'm so excited to be here at Indiana University so that you could

11
00:01:07,820 --> 00:01:13,640
teach me Scheme, and he says, I don't do Scheme anymore. I do logic programming. It's like

12
00:01:13,640 --> 00:01:17,920
something you could have told me two weeks ago, and I would have gone Northeastern, but

13
00:01:17,920 --> 00:01:23,360
I didn't. Anyway, but Dan should have told me something else instead. He shouldn't have

14
00:01:23,360 --> 00:01:26,900
said, I don't do Scheme anymore. I do logic programming. He should have said something

15
00:01:26,900 --> 00:01:36,240
else, and so this talk is kind of about what Dan really should have told me, and sort of

16
00:01:36,240 --> 00:01:40,760
trying to explain what we've been doing the last 13 plus years. I've been doing it for

17
00:01:40,760 --> 00:01:45,660
the last 13 years. Dan's been doing it longer than that. What is it we're trying to do,

18
00:01:45,660 --> 00:01:50,240
and what is this weird mini-canon language we're working on, and why is it not prologue,

19
00:01:50,240 --> 00:01:56,180
and how does that fit into Guy's keynote, and all these other things? The original talk

20
00:01:56,180 --> 00:02:01,700
was relational interpreters, program census, and Barlaman strange, beautiful, and possibly

21
00:02:01,700 --> 00:02:07,780
useful. Maybe it'll be useful someday, but I don't really care about useful so much,

22
00:02:07,780 --> 00:02:15,540
as you might see. The language we're working on is called mini-canon, and I got to get

23
00:02:15,540 --> 00:02:21,020
my memes in, and my ponies for Boodle, but someone made this up. Fresh is one of the

24
00:02:21,020 --> 00:02:28,180
key operators. There are only three operators in the core language, but here's my second

25
00:02:28,180 --> 00:02:33,860
meme, and this is something I've heard a lot of. Mini-canon is the worst logic programming

26
00:02:33,860 --> 00:02:41,700
language I've ever heard of, but you have heard of it, right? People often say, well,

27
00:02:41,740 --> 00:02:46,980
this is terrible. Prologue has all these extra features, or prologue implementations are

28
00:02:46,980 --> 00:02:53,980
faster, so why use mini-canon? The point is, in my mind, isn't to build a logic language.

29
00:02:54,900 --> 00:02:59,040
That's not what I'm trying to do, at least. I don't care about logic programming. I don't

30
00:02:59,040 --> 00:03:06,040
care about mini-canon. That's not what I'm trying to do. Let me tell you a story, and

31
00:03:06,880 --> 00:03:12,880
I'll do my first live coding. I'm going to show you the first program I ever wrote. I

32
00:03:12,880 --> 00:03:17,000
was nine years old. My father bought this beautiful computer. Anyone know what this

33
00:03:17,000 --> 00:03:24,000
is? No one knows what that computer is, really. TRS-80 Coco, trash 80, color computer. Believe

34
00:03:29,400 --> 00:03:34,600
it or not, but one point in the time, this was the most popular computer in the world,

35
00:03:35,000 --> 00:03:40,400
and Radio Shack actually had summer camps. My first class in programming was taught by

36
00:03:40,400 --> 00:03:47,400
Radio Shack, the summer school in programming, in Logo. The TRS-80 Coco, that came out in

37
00:03:47,920 --> 00:03:54,920
1980, hence the name. Let's see if I can show you the program. We got this new computer,

38
00:03:57,440 --> 00:04:03,400
and normally I used to think that I'd seen war games or whatever, and I knew how to program,

39
00:04:03,400 --> 00:04:07,240
but war games I don't think was out yet, so I must have seen Star Wars, but I thought

40
00:04:07,240 --> 00:04:11,920
I knew how to program, so we get this computer, and it's like, all right, I'm going to show

41
00:04:11,920 --> 00:04:16,480
off to my brother, my little brother, because I'd watched all these movies. Here is exactly

42
00:04:16,480 --> 00:04:23,480
the program that I wrote. Oh, I got to click on it.

43
00:04:34,400 --> 00:04:41,400
As I recall, the exact program I wrote 37 years ago, and that's the exact result I got.

44
00:04:44,400 --> 00:04:49,320
I basically flipped the table, and I said, this is not for me, and I didn't touch the

45
00:04:49,320 --> 00:04:56,320
computer or programming for several years after. In effect, I haven't really changed.

46
00:04:57,320 --> 00:05:04,320
This is really my philosophy of what programming should be like. The fact that I have become

47
00:05:05,720 --> 00:05:11,720
an expert and have a PhD in programming, to me, is offensive. It's not something joyful.

48
00:05:11,720 --> 00:05:18,720
It's like the same thing where writing books with Dan, or writing latex papers, or whatever.

49
00:05:19,120 --> 00:05:24,120
The fact that I've become a master in mangling latex files and post-processing latex files

50
00:05:24,120 --> 00:05:29,120
with Perl scripts is not something I'm proud of. It's something I'm ashamed of.

51
00:05:29,120 --> 00:05:36,120
The fact that I still, to this day, have to program at a much higher level, in a sense,

52
00:05:36,120 --> 00:05:41,120
I can't write that sort of program, really offends me.

53
00:05:41,520 --> 00:05:48,520
Let's see. I think you can sum up my attitude with this epigram in programming.

54
00:05:54,320 --> 00:05:58,320
If you haven't read Alan Perlis' epigrams in programming, you should read those. They're

55
00:05:58,320 --> 00:06:03,320
fantastic. The epigram 93. When someone says, I want a programming language in which I need

56
00:06:03,320 --> 00:06:08,320
only say what I wish done, give him a lollipop.

57
00:06:08,520 --> 00:06:15,520
I understand his philosophy or why he said that, but if someone wants to just type something

58
00:06:19,920 --> 00:06:26,220
in sort of naively, I think we should give him or her a lollipop, but we should also

59
00:06:26,220 --> 00:06:33,220
give them what they ask for. If you think of it that way, what I really want to do is

60
00:06:34,020 --> 00:06:40,020
lollipop-driven development. Rich Hickey has this idea of hammock-driven development,

61
00:06:40,020 --> 00:06:45,020
which is fine, but I prefer lollipop-driven development. I want to just be able to say

62
00:06:45,020 --> 00:06:48,020
what should happen and just have it happen.

63
00:06:48,020 --> 00:06:50,020
I think it's milkshake-driven.

64
00:06:50,020 --> 00:06:55,580
Milkshake-driven development, yes. Going back to Guy's keynote last night, he showed

65
00:06:55,580 --> 00:07:02,580
inference rules, typing judgments, context-free grammars, BNF, all these sorts of things.

66
00:07:03,740 --> 00:07:10,340
When I went to Indiana, really what Dan was trying to do at the time, which took a while

67
00:07:10,340 --> 00:07:16,300
for me to understand, was he wanted a way to write these sorts of rules down, make them

68
00:07:16,300 --> 00:07:23,300
executable, and be able to explore the resulting system. That's really what he was interested

69
00:07:23,380 --> 00:07:30,380
in. Anyway, we want some way to explore this. Going back to Guy's naming of the informal

70
00:07:33,260 --> 00:07:39,860
language use, computer science meta notation, basically we want to have an executable relational

71
00:07:39,860 --> 00:07:46,860
version of computer science meta notation. Just one other source of inspiration for the

72
00:07:48,220 --> 00:07:54,420
Commodore Amiga, which was my third computer, I think. There was a fantastic program for

73
00:07:54,420 --> 00:08:01,420
it called Doug's Math Aquarium. I love this program. You can see, this was on the September

74
00:08:02,420 --> 00:08:09,420
87 issue of Info. You can see on the lower left the image again. You can do Manobrot,

75
00:08:10,020 --> 00:08:14,860
plus you can do wireframe. There are a whole bunch of ways you could visualize mathematics.

76
00:08:14,860 --> 00:08:18,540
The way it would work is like, hey, I want to zoom in on Manobrot's set. The computer

77
00:08:18,540 --> 00:08:22,740
was so slow, and the software was so slow, you would hit return, and you would see it

78
00:08:22,740 --> 00:08:27,540
draw each pixel. Then you would go away, and eight hours later, you would see a little

79
00:08:27,540 --> 00:08:32,020
bit of the Manobrot set. But it was still amazing. It was still incredibly inspiring

80
00:08:32,020 --> 00:08:39,020
to me. What I want is a computer science meta notation aquarium, just like the math aquarium.

81
00:08:41,300 --> 00:08:46,780
Even if it's slow, and even it's awkward to use, just being able to explore and play

82
00:08:46,780 --> 00:08:52,020
around with it to me would be far, far better than just writing interpreters the standard

83
00:08:52,020 --> 00:08:59,020
way. That's really what we're trying to do, I'd say. I'm going to not teach you the

84
00:09:02,900 --> 00:09:06,940
mini-canon language, and I'm not going to teach you how it's implemented. We actually

85
00:09:06,940 --> 00:09:13,940
have lots of resources and talks and things like that about this, about mini-canon, and

86
00:09:15,100 --> 00:09:20,380
how to use it, and how to write mini-canon programs. To really do it right would take

87
00:09:20,420 --> 00:09:25,140
far more time than I have, but I just want to show you maybe a couple of examples of

88
00:09:25,140 --> 00:09:32,140
what the rules look like. This is a type inferencer for the simply typed lambda calculus on the

89
00:09:32,660 --> 00:09:39,660
left, how we would write it with the computer science meta notation. Was that right, CSM?

90
00:09:40,020 --> 00:09:43,820
Computer science meta notation. That's how we might write it on the left. Then on the

91
00:09:43,820 --> 00:09:50,320
right is how you might write it in mini-canon using a macro called matchup, and then on

92
00:09:50,360 --> 00:09:55,960
the right is a little higher level syntax than what we normally use. You can see it's

93
00:09:55,960 --> 00:10:02,960
roughly the same. It's still awkward. It's not the greatest notation, but you can see

94
00:10:03,720 --> 00:10:10,520
it's not 100 times longer or 10 times longer or whatever. Here we have something similar

95
00:10:10,520 --> 00:10:16,720
for commentatory logic. We have another meta notation, and on the right is the mini-canon,

96
00:10:16,740 --> 00:10:22,920
and that's roughly the same length. Here is the program that we're going to play with

97
00:10:22,920 --> 00:10:28,440
today in Explorer. This is an environment passing interpreter for a subset of scheme

98
00:10:28,440 --> 00:10:35,440
or a subset of racket. If you know the rules, this is procedure application, this is abstraction

99
00:10:35,800 --> 00:10:41,040
or lambda, that's variable reference. Here we have lists. There we've got quote. We've

100
00:10:41,040 --> 00:10:44,600
actually added some other forms to various versions of the interpreter. I'll show you

101
00:10:44,640 --> 00:10:51,640
this version first. Then here on the right is the mini-canon code that corresponds to

102
00:10:51,640 --> 00:10:58,640
it. Then we also have to have some extra code for doing things like environment lookup

103
00:10:58,840 --> 00:11:02,440
and some side conditions where in the math when you write it down, you don't have to

104
00:11:02,440 --> 00:11:08,840
worry about it as much. Anyway, the point is we can write something that doesn't really

105
00:11:08,840 --> 00:11:14,040
look like the notation. It would be very nice to have something much closer to the notation,

106
00:11:14,080 --> 00:11:20,280
and it's roughly the same length or maybe twice as long or something like that. We're

107
00:11:20,280 --> 00:11:27,040
going to assume that we've already implemented an environment passing interpreter in mini-canon,

108
00:11:27,040 --> 00:11:33,400
and we've already implemented mini-canon. Mini-canon is a language that is sort of a

109
00:11:33,400 --> 00:11:38,640
combination of logic programming and constraint programming. This is basically a constraint

110
00:11:38,640 --> 00:11:43,240
logic programming language. It's a mixture of constraints and logic programming. I heard

111
00:11:43,320 --> 00:11:48,920
Peter Van Roy question last night to Guy, both logic programming and constraint programming

112
00:11:48,920 --> 00:11:54,800
came up. Basically, you can think of it as a language that's been optimized to write

113
00:11:54,800 --> 00:11:58,760
rules like this, not necessarily in terms of the syntax, like how you write them down,

114
00:11:58,760 --> 00:12:04,240
but more in terms of if you want to explore the resulting rules. The language is optimized

115
00:12:04,240 --> 00:12:13,320
for that, and the implementation is optimized for that. Okay. Now is the most fun part. This

116
00:12:13,320 --> 00:12:18,960
is always the part that scares me, loading a file. We haven't really solved the loading

117
00:12:19,040 --> 00:12:27,040
the file part, but let me make sure I can do this. Oh, okay. Great. Let me see if I can do this one.

118
00:12:37,040 --> 00:12:48,040
Good. All right. Okay. Can people see that? Is that big enough? Okay. Let me make sure we got,

119
00:12:48,120 --> 00:12:56,120
great. Okay. So, show of hands, please. Who here can read Scheme, Racket, Closure, or

120
00:12:56,120 --> 00:13:04,120
some other Lisp? At least a little bit. Emacs Lisp? Absolutely. Okay. So, most people,

121
00:13:04,120 --> 00:13:10,120
maybe not 100%. I think in the interest of time, I'm going to ask the people who aren't

122
00:13:10,120 --> 00:13:15,360
as familiar with parentheses to please try to bear with me and try to think at the high

123
00:13:15,440 --> 00:13:21,280
level what we're trying to do. Okay. Just from the standpoint of time, I can't also teach you all

124
00:13:21,280 --> 00:13:26,720
of Scheme, unfortunately. Although I gave a talk at Papers We Love recently where I actually do

125
00:13:26,720 --> 00:13:30,960
teach enough Scheme to do all the things we do, but I had an hour and a half then. So, if you

126
00:13:30,960 --> 00:13:36,400
look on YouTube, you can find papers we love to talk on called the most beautiful program ever

127
00:13:36,400 --> 00:13:42,080
written where I talk about some of these topics. Okay. So, what I've loaded is an interpreter for

128
00:13:42,080 --> 00:13:49,040
a subset of Scheme. And a language like Scheme, sort of like a language like Python, maybe,

129
00:13:49,040 --> 00:13:54,560
we have something called a vowel. So, a vowel is an evaluator. It can evaluate an expression,

130
00:13:54,560 --> 00:14:04,560
which we quote. So, I could do plus 3, 5. And this expression, a Scheme uses a prefix notation.

131
00:14:04,560 --> 00:14:11,280
We're adding 3 plus 5. That quote means that we're delaying evaluation. We're turning the

132
00:14:11,280 --> 00:14:19,600
plus 3, 5. We're treating that as a list of data instead of as a procedure call. So, you can see

133
00:14:19,600 --> 00:14:24,160
the difference. If I put the quote mark, we get back the list. If I don't put the quote mark,

134
00:14:24,160 --> 00:14:29,120
it evaluates immediately, we get back 8. Okay. So, a vowel sort of cancels out the quote mark,

135
00:14:29,120 --> 00:14:33,120
if you want to think of it that way. We're taking this list and we're going to evaluate it. So,

136
00:14:33,120 --> 00:14:39,040
we're going to look at the parts of the list and do some evaluation procedure. Okay. So, that's a

137
00:14:39,040 --> 00:14:45,920
vowel and Scheme. What we're going to do is use something called a vowel. So, a vowel is the

138
00:14:45,920 --> 00:14:52,400
relational version of the vowel function. So, the vowel function takes one argument, which is

139
00:14:52,400 --> 00:14:56,320
going to be a Scheme expression, as quoted, evaluates that and gives us back the value.

140
00:14:56,880 --> 00:15:01,520
The vowel, however, is going to take two arguments instead of one. It's going to take an expression

141
00:15:01,520 --> 00:15:06,960
as the first argument and it's going to take a value as the second argument. So, let's try using a

142
00:15:06,960 --> 00:15:30,480
vowel. Okay. Great. So, it's working. All right. How about I do something simple like

143
00:15:31,040 --> 00:15:40,960
I think this will work. Oh, yeah. Okay. So, for the people who don't know Scheme,

144
00:15:42,720 --> 00:15:49,760
Lisp stands for list processing. So, the list is a very common data structure we use. So,

145
00:15:49,760 --> 00:15:56,160
list 3, 4 creates a list containing 3 and 4. What I just did with this run expression is I

146
00:15:56,160 --> 00:16:03,360
called a vowel, which is my relational evaluator. And the quoted expression is list 3, 4, just like

147
00:16:03,360 --> 00:16:09,040
I typed directly in the Scheme. So, that's the expression. The first part of the first argument

148
00:16:09,040 --> 00:16:14,960
to a vowel is the expression I want to evaluate. Q is a query variable. You can say I introduce it

149
00:16:14,960 --> 00:16:21,520
right after the run one in parentheses. Q is my query variable. And I'm putting Q in the place

150
00:16:21,520 --> 00:16:27,920
of the value. I'm saying that whatever a list 3, 4 evaluates to, bind that to the variable Q.

151
00:16:27,920 --> 00:16:31,280
Okay. So, Q is a logic variable, query variable, whatever you want to call it,

152
00:16:31,920 --> 00:16:38,400
unification variable. Run one, the one means that I want one answer back. Sometimes we can get

153
00:16:38,400 --> 00:16:42,480
more than one answer back. Sometimes we can get infinitely many answers back. And in fact, we

154
00:16:42,480 --> 00:16:47,440
also might want to prove or show that there are only a finite number of answers, that there are

155
00:16:47,440 --> 00:16:53,600
only five answers that exist. Run is our interface operator between Scheme and Minikanron. So,

156
00:16:53,600 --> 00:16:58,560
Minikanron is embedded in a host language, most implementations. This implementation,

157
00:16:58,560 --> 00:17:03,600
Minikanron is embedded in Scheme. I'm running it in Shea Scheme. All right. So, that's the basic

158
00:17:03,600 --> 00:17:10,320
interface. The underlying language that we wrote a vowel in is quite simple. It basically extends

159
00:17:10,400 --> 00:17:17,920
Scheme with three operators, core operators. And then we've got a couple extensions for helping

160
00:17:17,920 --> 00:17:23,600
write interpreters and type in things like that. Okay. So, that's a vowel. And you can see that

161
00:17:23,600 --> 00:17:29,440
we can write things like list 3, 4. Now, what's interesting is that a vowel is written as a

162
00:17:29,440 --> 00:17:37,200
relation. And so, Guy talked about this a little bit yesterday. But, you know, the interesting

163
00:17:37,680 --> 00:17:47,200
thing about the rules, and in fact, I can show you the rules for interpreter, the interesting

164
00:17:47,200 --> 00:17:56,240
thing about these sorts of rules is that they don't really have a direction. So, here is a paper

165
00:17:57,200 --> 00:18:06,080
that was an ICFP in Oxford this year. And in this paper, you can see these rules written as

166
00:18:06,080 --> 00:18:09,840
inference rules. And the code on the right, which is Minikanron. This is kind of lower-level

167
00:18:09,840 --> 00:18:15,440
Minikanron, so it's a little longer. But the important thing is to realize that, you know,

168
00:18:15,440 --> 00:18:23,040
there's this bar here, right, that Guy was talking about. And normally, the way we read it is we

169
00:18:23,040 --> 00:18:28,880
have some antecedents, a consequence. So, we have some things that have to hold. And if these

170
00:18:28,880 --> 00:18:35,360
three things hold, then we can infer the thing on the bottom. And we also sort of read it as,

171
00:18:35,360 --> 00:18:41,120
okay, so this turnstile operator, we can read it as like an interpret or evaluate. So, in a

172
00:18:41,120 --> 00:18:45,760
certain environment, row, this particular expression, which is a procedure application,

173
00:18:45,760 --> 00:18:51,360
evaluates to the value v3. And the rules up top tell you what v3 is. So, if you're writing an

174
00:18:51,360 --> 00:18:57,600
interpreter in a standard way, you would read these rules as, okay, I'm going from left to right.

175
00:18:57,600 --> 00:19:02,400
Here's my expression. Here's my value. Notice there's an arrow instead of an equal sign. So,

176
00:19:02,400 --> 00:19:08,080
that's how you'd often think about it. But there's no reason that we have to go in any sort of

177
00:19:08,080 --> 00:19:13,360
direction. We could actually consider this more like an algebra problem, where we have variables

178
00:19:13,360 --> 00:19:18,640
that we want to place in the different parts. Maybe the row p. We replace that with some variable x.

179
00:19:18,640 --> 00:19:26,240
I don't know what x is. Or the expression or the value. Okay, so if we can put variables in

180
00:19:26,880 --> 00:19:32,160
and then have a system that can do a mixture of maybe things like search and constraint solving,

181
00:19:32,160 --> 00:19:37,760
then we can try putting variables in to get more flexibility. So, that's exactly what we've done.

182
00:19:38,720 --> 00:19:48,080
So, what that means is, if I go back to this valo call, I don't have to just put in an expression

183
00:19:48,640 --> 00:19:54,480
that's known in the first position and then put an unknown in the value position. I can do the

184
00:19:54,480 --> 00:19:59,600
opposite. So, what I could do is I say, okay, well, I know that the list is supposed to be

185
00:19:59,680 --> 00:20:06,880
three, four, right? And grab this list. The extra prens, by the way, and that answer up top have to

186
00:20:06,880 --> 00:20:11,600
do with, first of all, the fact that we can get more than one answer back and also that we can get

187
00:20:11,600 --> 00:20:17,040
some side conditions to help interpret the answer. Anyway, I'm going to replace that query variable

188
00:20:17,040 --> 00:20:24,800
with quote three, four. So, that's the expected value. And I'm going to replace the expression

189
00:20:25,760 --> 00:20:32,320
with my query variable Q. So, now what I'm asking is, give me an expression in scheme

190
00:20:32,320 --> 00:20:36,560
that evaluates the list three, four. So, what would be one such expression do you think?

191
00:20:41,120 --> 00:20:45,600
List three, four. Okay. So, list three, four is one. Quote three, four is another. So, I can ask

192
00:20:45,600 --> 00:20:50,720
for, you know, let me ask for two answers. Okay. So, list three, four was the second one I got.

193
00:20:51,600 --> 00:20:57,840
And I can ask for three answers. And we can see list three, quote, four. So, it turns out that

194
00:20:57,840 --> 00:21:03,920
if you quote three or four, it's the same as just writing three or four. And so, you can see that

195
00:21:03,920 --> 00:21:10,480
we have a number of answers, right? And so, some of those answers involve things like lambda and

196
00:21:10,480 --> 00:21:15,440
procedure application. So, as I say, hey, as function call can give you three, the list three,

197
00:21:15,440 --> 00:21:26,720
four. All right. Now, back to Lollipop land. So, Matt might, who's giving keynote tonight and

198
00:21:27,360 --> 00:21:33,200
whose lab I work in and work with for many years. He wrote a blog post for Valentine's Day

199
00:21:34,160 --> 00:21:39,600
a couple years ago called 99 ways to say I love you in racket. So, the idea of this was to teach

200
00:21:40,480 --> 00:21:44,400
students and beginning racket programmers a little bit of racket and a little bit of how

201
00:21:44,400 --> 00:21:52,080
they manipulate lists because racket's a list and list is list processing. So, the idea is to

202
00:21:52,080 --> 00:21:58,400
show 99 different expressions and there are various complicated ones and so forth that

203
00:21:59,440 --> 00:22:04,640
would evaluate to list I love you. And PD Aldous, who's one of the grad students said, hey,

204
00:22:05,440 --> 00:22:12,560
do you think you could use mini-canron to generate such programs? So, let's try doing that. We're

205
00:22:12,560 --> 00:22:18,560
going to generate 99 programs that evaluate to I love you. So, can you help me out with the query?

206
00:22:18,560 --> 00:22:30,400
What would that look like? Run 99? Sure. Okay. What else is going to change?

207
00:22:31,200 --> 00:22:43,440
Sure. Okay. How about I love you? Okay. All right. So, here are 99 programs that evaluate to I love

208
00:22:43,440 --> 00:22:55,840
you. So, I don't know. Let me, what's a fun one? How about, let's just start down here.

209
00:22:56,640 --> 00:23:02,480
Let me just grab that out and I'm running it in scheme now and you can see that evaluates I love

210
00:23:02,480 --> 00:23:08,480
you. So, we've got list quote I, quote love and then the last sub expression is a procedure call

211
00:23:08,480 --> 00:23:12,960
to a function which is variadic. It takes any number of arguments. The underscore dot zero

212
00:23:12,960 --> 00:23:17,600
represents a symbol representing, that's a symbol representing a variable. The name doesn't matter.

213
00:23:17,600 --> 00:23:21,440
That's why I picked underscore dot zero. That's our convention saying it doesn't matter. You could

214
00:23:21,440 --> 00:23:29,280
pick foo if you wanted there. And this quote underscore one thing. So, this is a quoted symbol

215
00:23:29,280 --> 00:23:32,960
also. If you look at the side conditions, you'll see these things. So, that could be any quoted

216
00:23:32,960 --> 00:23:38,800
symbol and this will hold. There might be some other side conditions like the symbol can't be

217
00:23:38,800 --> 00:23:42,480
called quote. Under score zero can't be called quote because you don't want to shadow quote,

218
00:23:42,480 --> 00:23:49,360
that kind of thing. Okay. So, that's a simple example. And after, after we started playing

219
00:23:49,360 --> 00:23:54,000
around with this a little bit, Dan Friedman and I gave a talk at closure conge and we,

220
00:23:54,000 --> 00:23:59,440
we showed this relational interpreter or variant of it and Stu Holloway at the end said, well,

221
00:23:59,440 --> 00:24:07,040
you know, you should be able to generate quines using this. Anyone know what a quine is? What's a

222
00:24:07,040 --> 00:24:14,320
quine? A program that outputs itself. That's right. Okay. In fact, if we go back to history,

223
00:24:14,320 --> 00:24:24,400
let's see if we can go back and, you know, I love the fact the guy went through so many papers,

224
00:24:24,400 --> 00:24:28,320
old papers. Well, this is a paper I really like by John McCarthy who is the creator of,

225
00:24:28,880 --> 00:24:36,000
of Lisp called a micromanual for Lisp, not the whole truth. And then this he gives rules for

226
00:24:36,800 --> 00:24:42,080
the Lisp language. So, you can see like what equal means, what cons means and so forth.

227
00:24:43,040 --> 00:24:49,280
Notice by the way he uses an equal sign. Right? Not narrow. But then he has this neat little

228
00:24:49,280 --> 00:24:56,960
problem. Difficult mathematical type exercise. Final list E such that value of E equals E.

229
00:24:57,840 --> 00:25:02,240
So, value is the name of his evaluator function, his eval. So, basically,

230
00:25:04,000 --> 00:25:09,120
what he's calling value is what we would call eval or evalo. And so, he's trying to find an

231
00:25:09,120 --> 00:25:14,640
expression E such that the value of E is E. So, that is also trying to find a quine. So,

232
00:25:14,640 --> 00:25:20,880
he was trying to find a quine or Gittis to find a quine in, I think, 1978. So, let's try to do that.

233
00:25:22,320 --> 00:25:28,160
So, given what you know, how would we find a quine? What would, how would we change

234
00:25:28,160 --> 00:25:37,760
our query so we could generate a quine? QQ, a value of QQ, that's right. Now, of course,

235
00:25:37,760 --> 00:25:42,160
there's nothing special about the name Q. So, why don't we, out of respect for John McCarthy,

236
00:25:42,160 --> 00:25:50,000
call it E instead. Valo EE. And let's do a run one. Okay. So, we're trying to find an expression E

237
00:25:50,000 --> 00:25:55,520
that evaluates to itself. This is pretty close to what John McCarthy wrote, right? I mean,

238
00:25:55,520 --> 00:26:02,720
we're calling it a valo instead of, instead of value. But, you know, this is exactly what you

239
00:26:02,720 --> 00:26:07,920
would want to be able to type into a system. So, let's see what Minicandron gives us back.

240
00:26:09,440 --> 00:26:15,920
Well, the first thing it says is that underscore zero is a number, which is true. Okay. So,

241
00:26:15,920 --> 00:26:21,040
in scheme five is a quine. So, five evaluates to itself. That's true. Okay. So, that's what

242
00:26:21,040 --> 00:26:26,480
Minicandron's telling us. Let's ask for a second one. It says hash t. Hash t is true in scheme.

243
00:26:27,040 --> 00:26:31,920
All right. So, those are all quines. Hash f is a quine. How about four?

244
00:26:33,920 --> 00:26:37,040
Now, it's thinking for a minute. Okay. Now, we've got something a little more interesting.

245
00:26:38,160 --> 00:26:44,480
I'm going to grab that expression and type it in. And sure enough, that's a quine. So,

246
00:26:44,480 --> 00:26:50,480
that's a self-evaluating expression. In fact, if you look at the quines page, you will see this

247
00:26:50,480 --> 00:26:56,640
quine. This is sort of the canonical quine. And we can generate all sorts of quines. We can generate

248
00:26:56,640 --> 00:27:03,280
twin quines and triple quines and that kind of thing. But what I love about this, and in some

249
00:27:03,280 --> 00:27:08,400
sense, this is probably my favorite Minicandron query using a relational interpreter, but I love

250
00:27:08,400 --> 00:27:12,480
it as the query is so simple. This is actually the shortest query you can write in terms of the

251
00:27:12,480 --> 00:27:17,200
number of distinct identifiers. This is like the shortest thing you can write. And it generates

252
00:27:17,200 --> 00:27:22,880
quines and it actually works. And I personally was shocked that like, oh, yeah, this actually,

253
00:27:22,880 --> 00:27:27,600
this actually, you can actually do something with this. You type it in. I figured it would take

254
00:27:27,600 --> 00:27:36,240
a million years or something. Okay. So, at that point, a grad student at Utah named Michael

255
00:27:36,240 --> 00:27:43,600
Ballantyne said, well, that's kind of fun. But what if you, now you have this interpreter,

256
00:27:43,600 --> 00:27:51,280
what if you were to take a scheme program and fill in the scheme program in the first expression,

257
00:27:51,280 --> 00:27:56,400
but leave some of the arguments to that program, to that function, you know, make those variables?

258
00:27:56,400 --> 00:28:01,920
Could you, could you get interesting behavior? And so he suggested append. So let's try doing that.

259
00:28:02,560 --> 00:28:12,800
So append in scheme takes two lists, like ABC and DE, and concatenates the list. So get ABCDE,

260
00:28:12,800 --> 00:28:15,200
in this case. So what we're going to do is we're going to write append.

261
00:28:22,960 --> 00:28:30,400
And the way I'll write append is using something called let rec. Let's me define a recursive relation

262
00:28:31,360 --> 00:28:40,000
or a function.

263
00:28:40,000 --> 00:29:07,600
Okay. So that's append. Did I get it right?

264
00:29:10,160 --> 00:29:16,880
And now we're going to call append. I'll use the same arguments as before, ABC to DE.

265
00:29:19,600 --> 00:29:25,840
Okay. So I just ran it forward. So, so what did I do? I took the scheme definition of append.

266
00:29:25,840 --> 00:29:29,440
This is not mini-canon code. This is not logic programming code or constraint logic program

267
00:29:29,440 --> 00:29:35,120
code. This is just scheme code. I ran it inside of a valo as the first argument. This is the

268
00:29:35,120 --> 00:29:40,800
expression argument. And I said we have an unknown value. So my query variable Q represents

269
00:29:40,800 --> 00:29:50,400
the unknown value. So what can we do? Okay. So now what we can do is we can say we know ABCDE

270
00:29:51,200 --> 00:29:58,240
is the output. And where else could I put a variable? Where could I put this Q variable?

271
00:29:58,720 --> 00:30:06,480
Well, how about I put it in a position of one of the arguments to append? How about I put it

272
00:30:06,480 --> 00:30:11,360
right here? I have to put a comma there because this whole thing is back-quoted if you know scheme.

273
00:30:11,920 --> 00:30:16,400
All right. So what do you think I'm going to get back in the place of the Q variable?

274
00:30:20,400 --> 00:30:27,840
ABC, right? So let's see if that works. Yeah. Quote ABC. Is there a second answer? What if I do a

275
00:30:27,840 --> 00:30:37,760
run two? Should there be a second answer or should it say no? No more answers. List ABC. All right.

276
00:30:37,760 --> 00:30:44,720
Well, let's see if we get something like that. It's not list ABC, but we get a procedure application.

277
00:30:44,720 --> 00:30:49,600
And if I evaluate that in scheme, I get back ABC. So what happens is we get an expression

278
00:30:49,600 --> 00:30:57,440
that evaluates to ABC. If I put a quote, I get back ABC itself. Okay. So that's a little subtle

279
00:30:57,440 --> 00:31:04,720
if you're not a schemer, but the point is we're making a distinction between expressions and values.

280
00:31:04,720 --> 00:31:09,360
So if I put a quote in front of the comma Q, that's going to say, well, I want the value,

281
00:31:09,360 --> 00:31:15,280
the list that's going to concatenate to give me ABCDE. If I don't put the quote, that means this

282
00:31:15,280 --> 00:31:21,360
could be an arbitrary expression in my subset of scheme that I'm handling. All right. Where else can

283
00:31:21,360 --> 00:31:34,320
I put Q? Inside the list, like here. Sure. Yep. In fact, I could have two variables. I could do

284
00:31:34,320 --> 00:31:46,720
like x and y. And I can do things like... In fact, I can ask for all the answers. So if you're familiar

285
00:31:46,720 --> 00:31:51,680
with logic programming and prologue or mini-canon or something like that, you've seen this before,

286
00:31:51,680 --> 00:31:57,920
things like a pen. That's a standard answer or a standard program. But we didn't write a pen in

287
00:31:59,360 --> 00:32:04,000
mini-canon or prologue. We wrote a pen in scheme. We'd get the relationality through the relational

288
00:32:04,000 --> 00:32:09,440
interpreter. All right. What else can we do? Where else can we put variable? How about

289
00:32:10,160 --> 00:32:16,960
if we put a variable inside the code? What if I put a variable where the s is?

290
00:32:19,280 --> 00:32:28,560
Okay. That used to be the symbol s. What should I get back? I get back the s, right? So I could

291
00:32:28,560 --> 00:32:36,000
also replace it here, like the car of L. Oh, I got two... I was doing a run two.

292
00:32:36,960 --> 00:32:42,480
Yeah. So I got car of L and another expression, which is the same as car of L, equivalent to it.

293
00:32:43,200 --> 00:32:49,920
All right. Now, I could show you much, much more. If you're interested in that sort of thing,

294
00:32:49,920 --> 00:32:58,000
I recommend you look at our paper in ICFP 2017. But I just want to show you what happens if you

295
00:32:59,360 --> 00:33:04,160
sort of put an interface on this. And you also speed up the naive version by about

296
00:33:04,160 --> 00:33:09,680
nine orders of magnitude, because that's what we've done. Michael Valentine and Greg Rosenblatt

297
00:33:09,680 --> 00:33:16,320
have been speeding up the system. So Greg gave us eight orders of magnitude in

298
00:33:17,120 --> 00:33:21,600
eight months or something. So now what we're going to do is we're going to do some program

299
00:33:21,600 --> 00:33:27,440
synthesis. So this... What's happening underneath the hood is we're just generating calls to our

300
00:33:27,440 --> 00:33:32,640
Valo. We're doing example-based program synthesis. So here I have a call to a pen. I've got a

301
00:33:32,640 --> 00:33:37,360
fragment of the append definition, the comma A, comma B, comma C. Those are logic variables

302
00:33:37,360 --> 00:33:41,280
representing holes in our program. And you can see at the bottom that Barleman's trying to figure out

303
00:33:42,880 --> 00:33:50,720
what we have. I can do this in various ways, but one way I might want to do it to try to keep

304
00:33:51,360 --> 00:33:56,560
the system from over-specializing is to use these G1, G2 things, which sort of represent

305
00:33:56,560 --> 00:34:00,800
universally quantified variables, if you want to think of that way, or sort of like Jenssen's

306
00:34:01,200 --> 00:34:06,400
skull invariables. So I don't quite have enough structure. So let me try one more example.

307
00:34:17,600 --> 00:34:19,760
Okay. Let that think for a minute.

308
00:34:25,280 --> 00:34:30,640
Okay. Now it's figured out the recursion. And it's a little hard to read it. So I'm going to just

309
00:34:30,640 --> 00:34:40,480
put in variable names, concrete variable names. And now you can see, you can read a little more.

310
00:34:40,480 --> 00:34:45,440
And if you know scheme, this is the correct definition of a pen. Okay. So what's happened?

311
00:34:45,440 --> 00:34:54,720
We've taken minicanron. We've implemented the semantics written in something similar to the CMS,

312
00:34:55,680 --> 00:35:02,880
computer science meta, or is it CMN? Whatever it's called. The computer science meta notation or

313
00:35:02,880 --> 00:35:13,920
whatever. Okay. Something like that. And through some cleverness on the back end, which we're hoping

314
00:35:13,920 --> 00:35:20,080
to generalize, so it's not just for our interpreter, but we'll work with a wider range of semantics

315
00:35:20,800 --> 00:35:24,320
and type systems and things like that. You would just type in. We can also do this for

316
00:35:24,320 --> 00:35:29,600
grammars, regular expressions, and so forth. We're able to get to the point where we can just type

317
00:35:29,600 --> 00:35:36,720
in input-output examples, and the system is able to do recursive, higher-order synthesis for our

318
00:35:36,720 --> 00:35:42,320
subset of scheme. We can also write type inferences in this way. So I'm hoping we can combine those.

319
00:35:42,320 --> 00:35:46,240
We'd write type inferences in the same way. We'd write the operational semantics for the

320
00:35:47,040 --> 00:35:51,520
evaluator. And we can also write grammars. There's also a grammar written in exactly the

321
00:35:51,520 --> 00:35:56,560
same style underneath this. So we can do grammars. We can generate expressions in exactly the same

322
00:35:56,560 --> 00:36:04,720
way. So I'm hoping as we improve this technology that we'll get closer and closer, I don't think we'll

323
00:36:04,720 --> 00:36:10,160
ever get there perfectly, but we'll get closer and closer to being able to be naive and just take

324
00:36:10,160 --> 00:36:15,680
a paper or some operational semantics or typing judgments or whatever, just type it in, hopefully

325
00:36:15,680 --> 00:36:22,400
with a nicer syntax, and then be able to start exploring this world and asking queries that

326
00:36:23,120 --> 00:36:29,600
maybe other people haven't thought of before or just being surprised. That's the best part for me.

327
00:36:29,600 --> 00:36:33,680
That's why I like Doug's math aquarium. It would surprise you. And that's why I like playing around

328
00:36:33,680 --> 00:36:37,760
with mini-canner. There's things like quines that surprise me. There are all sorts of programs that

329
00:36:37,760 --> 00:36:43,040
we're generating that surprise me. I didn't think it would be either possible or I had a different

330
00:36:43,040 --> 00:36:47,360
idea of which program would meet a certain specification, and mini-canner said, hey, this

331
00:36:47,360 --> 00:36:54,800
program meets it also, often sort of trolling me in the process. So anyway, this is lollipop

332
00:36:54,800 --> 00:37:00,400
driven development, if you will, where you just type the semantics, sort of like you'd read in the

333
00:37:00,400 --> 00:37:05,840
paper, write down examples, maybe write down types and things like that, get the system to fill in

334
00:37:05,840 --> 00:37:15,120
the unknowns for you in an exploratory way. So that's basically what Dan should have told me.

335
00:37:15,120 --> 00:37:21,760
He should have said, well, eight years from now, Guy Steele will give a keynote at CodeMesh,

336
00:37:22,640 --> 00:37:29,200
and at that point, we want to be able to type in those rules and just have it do things like

337
00:37:29,200 --> 00:37:36,080
and further program. So that's the idea. If you're interested in this, look at an ICFP 2017

338
00:37:36,080 --> 00:37:42,240
paper, go to mini-canron.org, look at the paper on micro-canron, which shows an implementation

339
00:37:42,240 --> 00:37:47,040
of a simple version, and look for the second edition of the Reason Schemer, which is about

340
00:37:47,040 --> 00:37:59,280
to come out. Thank you. Well, we actually have two minutes left. I think this is the first for

341
00:37:59,280 --> 00:38:19,440
you, Will, so we can take a question if you want. So the second test didn't work. Could you just go

342
00:38:19,440 --> 00:38:26,000
back and do that again, but fill it in with kind of the readable symbols so we can see why. So you

343
00:38:26,320 --> 00:38:31,600
want this one? Yeah. Well, the second one did work in a sense. It depends what you mean by work.

344
00:38:32,160 --> 00:38:39,520
So the mini-canron or Barleman's idea is prove me wrong, right? So this program

345
00:38:39,520 --> 00:38:44,400
absolutely matches that specification, but you're right that it's not what we had in mind, and this

346
00:38:44,400 --> 00:38:50,320
is part of the problem, right? So even if you can imagine Barleman being 500 orders of magnitude

347
00:38:50,320 --> 00:38:56,640
faster, and in some sense it solves program census by example, in another sense you still

348
00:38:56,640 --> 00:39:02,320
have the problem of writing down a specification that is complete enough and correct enough

349
00:39:02,320 --> 00:39:07,120
that you're going to get the right output, even if we're much, much faster, right? So this shows

350
00:39:07,120 --> 00:39:11,360
that census really has at least two problems. One is the speed problem of dealing with this

351
00:39:11,360 --> 00:39:15,440
exponential space and dealing with, you know, synthesizing programs that could go in infant

352
00:39:15,440 --> 00:39:21,040
loops, but there's also the specification problem. So how did you know what to type in the box labeled

353
00:39:21,040 --> 00:39:27,120
test three? How do you know what to type in there? Well, so that's a good question. There are

354
00:39:27,120 --> 00:39:31,200
different ways to give a specification. So you could write types, right? We don't currently

355
00:39:31,200 --> 00:39:35,040
support that, but you could write types, you could write examples, you could write properties,

356
00:39:35,040 --> 00:39:39,440
high-level properties, right? The other thing you can do, which I didn't show you, is that this is

357
00:39:39,440 --> 00:39:44,400
an IDE, so you can edit the code. So you can be writing some of the code and writing some of the

358
00:39:44,400 --> 00:39:48,800
tests and writing some of the types, and it's going to fill in the rest for you. So you could also

359
00:39:48,800 --> 00:39:53,520
use it as sort of like an IDE. But at some point, if you don't know what the program should do

360
00:39:54,640 --> 00:39:58,400
and you don't know any of the code, it's not going to figure that out for you. So you're going to

361
00:39:58,400 --> 00:40:04,800
have to do a little work. You know, even with my example, my stupid box example, I still had to

362
00:40:04,800 --> 00:40:09,680
figure out that I wanted a box that was two inches by two inches, right? So yes. Thank you.

363
00:40:10,640 --> 00:40:14,800
So basically, this is automated TDD, isn't it?

364
00:40:15,600 --> 00:40:21,840
That's part of it, but the reason I gave that intro is the problem is every time I give a talk,

365
00:40:21,840 --> 00:40:25,680
and I've given many variants of this talk, every single time I give a talk, someone comes away

366
00:40:25,680 --> 00:40:30,000
thinking, oh, well, so your research is on program census, or your research is on test-driven

367
00:40:30,000 --> 00:40:33,440
development, or your research is on logic programming, or your research is like, no,

368
00:40:33,440 --> 00:40:39,360
no, that's not it. The research is on lollipops, okay? The research is on lollipops and being able

369
00:40:39,360 --> 00:40:44,240
to sort of do things like just write down the rules and explore it, okay? That's really what

370
00:40:44,240 --> 00:40:50,080
the dream is. Program census falls out of this. Now, if we can do, if we make the system much

371
00:40:50,080 --> 00:40:55,040
faster and we can get a useful program census tool, or a useful test-driven development tool,

372
00:40:55,040 --> 00:41:01,520
or a useful IDE, great. But that's only a very small part of really the overall goal.

373
00:41:01,520 --> 00:41:03,680
Thank you, Will.

