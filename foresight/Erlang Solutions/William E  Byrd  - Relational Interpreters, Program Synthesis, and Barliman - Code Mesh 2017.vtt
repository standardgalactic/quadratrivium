WEBVTT

00:00.000 --> 00:16.040
Thank you. This always happens to me at CodeMesh. I have an idea for a talk, and then after

00:16.040 --> 00:20.560
seeing a keynote or having a conversation with someone, I'm like, throw that out. Actually,

00:20.560 --> 00:23.940
Boodle last night tried to convince me to give a talk on StarCraft instead, which I'm

00:23.940 --> 00:32.620
sorely tempted to do, but maybe next year. Yes. But I saw Guy Steele's keynote last night,

00:32.620 --> 00:38.260
which I loved, and I have to say that I love Scheme. I agree with Alan Kay that Lisp is

00:38.260 --> 00:42.960
the most important programming language ever created, and for my money, Scheme is the most

00:42.960 --> 00:50.240
important Lisp. So I think Scheme is one of the great joys of my life. I love programming

00:50.240 --> 00:55.920
and Scheme, and when I went to Indiana University to get my PhD, I went there specifically to

00:55.920 --> 01:01.140
work with Dan Friedman and get my PhD in Scheme. On the first day of grad school, I walked

01:01.140 --> 01:07.820
up to Dan, and I said, I'm so excited to be here at Indiana University so that you could

01:07.820 --> 01:13.640
teach me Scheme, and he says, I don't do Scheme anymore. I do logic programming. It's like

01:13.640 --> 01:17.920
something you could have told me two weeks ago, and I would have gone Northeastern, but

01:17.920 --> 01:23.360
I didn't. Anyway, but Dan should have told me something else instead. He shouldn't have

01:23.360 --> 01:26.900
said, I don't do Scheme anymore. I do logic programming. He should have said something

01:26.900 --> 01:36.240
else, and so this talk is kind of about what Dan really should have told me, and sort of

01:36.240 --> 01:40.760
trying to explain what we've been doing the last 13 plus years. I've been doing it for

01:40.760 --> 01:45.660
the last 13 years. Dan's been doing it longer than that. What is it we're trying to do,

01:45.660 --> 01:50.240
and what is this weird mini-canon language we're working on, and why is it not prologue,

01:50.240 --> 01:56.180
and how does that fit into Guy's keynote, and all these other things? The original talk

01:56.180 --> 02:01.700
was relational interpreters, program census, and Barlaman strange, beautiful, and possibly

02:01.700 --> 02:07.780
useful. Maybe it'll be useful someday, but I don't really care about useful so much,

02:07.780 --> 02:15.540
as you might see. The language we're working on is called mini-canon, and I got to get

02:15.540 --> 02:21.020
my memes in, and my ponies for Boodle, but someone made this up. Fresh is one of the

02:21.020 --> 02:28.180
key operators. There are only three operators in the core language, but here's my second

02:28.180 --> 02:33.860
meme, and this is something I've heard a lot of. Mini-canon is the worst logic programming

02:33.860 --> 02:41.700
language I've ever heard of, but you have heard of it, right? People often say, well,

02:41.740 --> 02:46.980
this is terrible. Prologue has all these extra features, or prologue implementations are

02:46.980 --> 02:53.980
faster, so why use mini-canon? The point is, in my mind, isn't to build a logic language.

02:54.900 --> 02:59.040
That's not what I'm trying to do, at least. I don't care about logic programming. I don't

02:59.040 --> 03:06.040
care about mini-canon. That's not what I'm trying to do. Let me tell you a story, and

03:06.880 --> 03:12.880
I'll do my first live coding. I'm going to show you the first program I ever wrote. I

03:12.880 --> 03:17.000
was nine years old. My father bought this beautiful computer. Anyone know what this

03:17.000 --> 03:24.000
is? No one knows what that computer is, really. TRS-80 Coco, trash 80, color computer. Believe

03:29.400 --> 03:34.600
it or not, but one point in the time, this was the most popular computer in the world,

03:35.000 --> 03:40.400
and Radio Shack actually had summer camps. My first class in programming was taught by

03:40.400 --> 03:47.400
Radio Shack, the summer school in programming, in Logo. The TRS-80 Coco, that came out in

03:47.920 --> 03:54.920
1980, hence the name. Let's see if I can show you the program. We got this new computer,

03:57.440 --> 04:03.400
and normally I used to think that I'd seen war games or whatever, and I knew how to program,

04:03.400 --> 04:07.240
but war games I don't think was out yet, so I must have seen Star Wars, but I thought

04:07.240 --> 04:11.920
I knew how to program, so we get this computer, and it's like, all right, I'm going to show

04:11.920 --> 04:16.480
off to my brother, my little brother, because I'd watched all these movies. Here is exactly

04:16.480 --> 04:23.480
the program that I wrote. Oh, I got to click on it.

04:34.400 --> 04:41.400
As I recall, the exact program I wrote 37 years ago, and that's the exact result I got.

04:44.400 --> 04:49.320
I basically flipped the table, and I said, this is not for me, and I didn't touch the

04:49.320 --> 04:56.320
computer or programming for several years after. In effect, I haven't really changed.

04:57.320 --> 05:04.320
This is really my philosophy of what programming should be like. The fact that I have become

05:05.720 --> 05:11.720
an expert and have a PhD in programming, to me, is offensive. It's not something joyful.

05:11.720 --> 05:18.720
It's like the same thing where writing books with Dan, or writing latex papers, or whatever.

05:19.120 --> 05:24.120
The fact that I've become a master in mangling latex files and post-processing latex files

05:24.120 --> 05:29.120
with Perl scripts is not something I'm proud of. It's something I'm ashamed of.

05:29.120 --> 05:36.120
The fact that I still, to this day, have to program at a much higher level, in a sense,

05:36.120 --> 05:41.120
I can't write that sort of program, really offends me.

05:41.520 --> 05:48.520
Let's see. I think you can sum up my attitude with this epigram in programming.

05:54.320 --> 05:58.320
If you haven't read Alan Perlis' epigrams in programming, you should read those. They're

05:58.320 --> 06:03.320
fantastic. The epigram 93. When someone says, I want a programming language in which I need

06:03.320 --> 06:08.320
only say what I wish done, give him a lollipop.

06:08.520 --> 06:15.520
I understand his philosophy or why he said that, but if someone wants to just type something

06:19.920 --> 06:26.220
in sort of naively, I think we should give him or her a lollipop, but we should also

06:26.220 --> 06:33.220
give them what they ask for. If you think of it that way, what I really want to do is

06:34.020 --> 06:40.020
lollipop-driven development. Rich Hickey has this idea of hammock-driven development,

06:40.020 --> 06:45.020
which is fine, but I prefer lollipop-driven development. I want to just be able to say

06:45.020 --> 06:48.020
what should happen and just have it happen.

06:48.020 --> 06:50.020
I think it's milkshake-driven.

06:50.020 --> 06:55.580
Milkshake-driven development, yes. Going back to Guy's keynote last night, he showed

06:55.580 --> 07:02.580
inference rules, typing judgments, context-free grammars, BNF, all these sorts of things.

07:03.740 --> 07:10.340
When I went to Indiana, really what Dan was trying to do at the time, which took a while

07:10.340 --> 07:16.300
for me to understand, was he wanted a way to write these sorts of rules down, make them

07:16.300 --> 07:23.300
executable, and be able to explore the resulting system. That's really what he was interested

07:23.380 --> 07:30.380
in. Anyway, we want some way to explore this. Going back to Guy's naming of the informal

07:33.260 --> 07:39.860
language use, computer science meta notation, basically we want to have an executable relational

07:39.860 --> 07:46.860
version of computer science meta notation. Just one other source of inspiration for the

07:48.220 --> 07:54.420
Commodore Amiga, which was my third computer, I think. There was a fantastic program for

07:54.420 --> 08:01.420
it called Doug's Math Aquarium. I love this program. You can see, this was on the September

08:02.420 --> 08:09.420
87 issue of Info. You can see on the lower left the image again. You can do Manobrot,

08:10.020 --> 08:14.860
plus you can do wireframe. There are a whole bunch of ways you could visualize mathematics.

08:14.860 --> 08:18.540
The way it would work is like, hey, I want to zoom in on Manobrot's set. The computer

08:18.540 --> 08:22.740
was so slow, and the software was so slow, you would hit return, and you would see it

08:22.740 --> 08:27.540
draw each pixel. Then you would go away, and eight hours later, you would see a little

08:27.540 --> 08:32.020
bit of the Manobrot set. But it was still amazing. It was still incredibly inspiring

08:32.020 --> 08:39.020
to me. What I want is a computer science meta notation aquarium, just like the math aquarium.

08:41.300 --> 08:46.780
Even if it's slow, and even it's awkward to use, just being able to explore and play

08:46.780 --> 08:52.020
around with it to me would be far, far better than just writing interpreters the standard

08:52.020 --> 08:59.020
way. That's really what we're trying to do, I'd say. I'm going to not teach you the

09:02.900 --> 09:06.940
mini-canon language, and I'm not going to teach you how it's implemented. We actually

09:06.940 --> 09:13.940
have lots of resources and talks and things like that about this, about mini-canon, and

09:15.100 --> 09:20.380
how to use it, and how to write mini-canon programs. To really do it right would take

09:20.420 --> 09:25.140
far more time than I have, but I just want to show you maybe a couple of examples of

09:25.140 --> 09:32.140
what the rules look like. This is a type inferencer for the simply typed lambda calculus on the

09:32.660 --> 09:39.660
left, how we would write it with the computer science meta notation. Was that right, CSM?

09:40.020 --> 09:43.820
Computer science meta notation. That's how we might write it on the left. Then on the

09:43.820 --> 09:50.320
right is how you might write it in mini-canon using a macro called matchup, and then on

09:50.360 --> 09:55.960
the right is a little higher level syntax than what we normally use. You can see it's

09:55.960 --> 10:02.960
roughly the same. It's still awkward. It's not the greatest notation, but you can see

10:03.720 --> 10:10.520
it's not 100 times longer or 10 times longer or whatever. Here we have something similar

10:10.520 --> 10:16.720
for commentatory logic. We have another meta notation, and on the right is the mini-canon,

10:16.740 --> 10:22.920
and that's roughly the same length. Here is the program that we're going to play with

10:22.920 --> 10:28.440
today in Explorer. This is an environment passing interpreter for a subset of scheme

10:28.440 --> 10:35.440
or a subset of racket. If you know the rules, this is procedure application, this is abstraction

10:35.800 --> 10:41.040
or lambda, that's variable reference. Here we have lists. There we've got quote. We've

10:41.040 --> 10:44.600
actually added some other forms to various versions of the interpreter. I'll show you

10:44.640 --> 10:51.640
this version first. Then here on the right is the mini-canon code that corresponds to

10:51.640 --> 10:58.640
it. Then we also have to have some extra code for doing things like environment lookup

10:58.840 --> 11:02.440
and some side conditions where in the math when you write it down, you don't have to

11:02.440 --> 11:08.840
worry about it as much. Anyway, the point is we can write something that doesn't really

11:08.840 --> 11:14.040
look like the notation. It would be very nice to have something much closer to the notation,

11:14.080 --> 11:20.280
and it's roughly the same length or maybe twice as long or something like that. We're

11:20.280 --> 11:27.040
going to assume that we've already implemented an environment passing interpreter in mini-canon,

11:27.040 --> 11:33.400
and we've already implemented mini-canon. Mini-canon is a language that is sort of a

11:33.400 --> 11:38.640
combination of logic programming and constraint programming. This is basically a constraint

11:38.640 --> 11:43.240
logic programming language. It's a mixture of constraints and logic programming. I heard

11:43.320 --> 11:48.920
Peter Van Roy question last night to Guy, both logic programming and constraint programming

11:48.920 --> 11:54.800
came up. Basically, you can think of it as a language that's been optimized to write

11:54.800 --> 11:58.760
rules like this, not necessarily in terms of the syntax, like how you write them down,

11:58.760 --> 12:04.240
but more in terms of if you want to explore the resulting rules. The language is optimized

12:04.240 --> 12:13.320
for that, and the implementation is optimized for that. Okay. Now is the most fun part. This

12:13.320 --> 12:18.960
is always the part that scares me, loading a file. We haven't really solved the loading

12:19.040 --> 12:27.040
the file part, but let me make sure I can do this. Oh, okay. Great. Let me see if I can do this one.

12:37.040 --> 12:48.040
Good. All right. Okay. Can people see that? Is that big enough? Okay. Let me make sure we got,

12:48.120 --> 12:56.120
great. Okay. So, show of hands, please. Who here can read Scheme, Racket, Closure, or

12:56.120 --> 13:04.120
some other Lisp? At least a little bit. Emacs Lisp? Absolutely. Okay. So, most people,

13:04.120 --> 13:10.120
maybe not 100%. I think in the interest of time, I'm going to ask the people who aren't

13:10.120 --> 13:15.360
as familiar with parentheses to please try to bear with me and try to think at the high

13:15.440 --> 13:21.280
level what we're trying to do. Okay. Just from the standpoint of time, I can't also teach you all

13:21.280 --> 13:26.720
of Scheme, unfortunately. Although I gave a talk at Papers We Love recently where I actually do

13:26.720 --> 13:30.960
teach enough Scheme to do all the things we do, but I had an hour and a half then. So, if you

13:30.960 --> 13:36.400
look on YouTube, you can find papers we love to talk on called the most beautiful program ever

13:36.400 --> 13:42.080
written where I talk about some of these topics. Okay. So, what I've loaded is an interpreter for

13:42.080 --> 13:49.040
a subset of Scheme. And a language like Scheme, sort of like a language like Python, maybe,

13:49.040 --> 13:54.560
we have something called a vowel. So, a vowel is an evaluator. It can evaluate an expression,

13:54.560 --> 14:04.560
which we quote. So, I could do plus 3, 5. And this expression, a Scheme uses a prefix notation.

14:04.560 --> 14:11.280
We're adding 3 plus 5. That quote means that we're delaying evaluation. We're turning the

14:11.280 --> 14:19.600
plus 3, 5. We're treating that as a list of data instead of as a procedure call. So, you can see

14:19.600 --> 14:24.160
the difference. If I put the quote mark, we get back the list. If I don't put the quote mark,

14:24.160 --> 14:29.120
it evaluates immediately, we get back 8. Okay. So, a vowel sort of cancels out the quote mark,

14:29.120 --> 14:33.120
if you want to think of it that way. We're taking this list and we're going to evaluate it. So,

14:33.120 --> 14:39.040
we're going to look at the parts of the list and do some evaluation procedure. Okay. So, that's a

14:39.040 --> 14:45.920
vowel and Scheme. What we're going to do is use something called a vowel. So, a vowel is the

14:45.920 --> 14:52.400
relational version of the vowel function. So, the vowel function takes one argument, which is

14:52.400 --> 14:56.320
going to be a Scheme expression, as quoted, evaluates that and gives us back the value.

14:56.880 --> 15:01.520
The vowel, however, is going to take two arguments instead of one. It's going to take an expression

15:01.520 --> 15:06.960
as the first argument and it's going to take a value as the second argument. So, let's try using a

15:06.960 --> 15:30.480
vowel. Okay. Great. So, it's working. All right. How about I do something simple like

15:31.040 --> 15:40.960
I think this will work. Oh, yeah. Okay. So, for the people who don't know Scheme,

15:42.720 --> 15:49.760
Lisp stands for list processing. So, the list is a very common data structure we use. So,

15:49.760 --> 15:56.160
list 3, 4 creates a list containing 3 and 4. What I just did with this run expression is I

15:56.160 --> 16:03.360
called a vowel, which is my relational evaluator. And the quoted expression is list 3, 4, just like

16:03.360 --> 16:09.040
I typed directly in the Scheme. So, that's the expression. The first part of the first argument

16:09.040 --> 16:14.960
to a vowel is the expression I want to evaluate. Q is a query variable. You can say I introduce it

16:14.960 --> 16:21.520
right after the run one in parentheses. Q is my query variable. And I'm putting Q in the place

16:21.520 --> 16:27.920
of the value. I'm saying that whatever a list 3, 4 evaluates to, bind that to the variable Q.

16:27.920 --> 16:31.280
Okay. So, Q is a logic variable, query variable, whatever you want to call it,

16:31.920 --> 16:38.400
unification variable. Run one, the one means that I want one answer back. Sometimes we can get

16:38.400 --> 16:42.480
more than one answer back. Sometimes we can get infinitely many answers back. And in fact, we

16:42.480 --> 16:47.440
also might want to prove or show that there are only a finite number of answers, that there are

16:47.440 --> 16:53.600
only five answers that exist. Run is our interface operator between Scheme and Minikanron. So,

16:53.600 --> 16:58.560
Minikanron is embedded in a host language, most implementations. This implementation,

16:58.560 --> 17:03.600
Minikanron is embedded in Scheme. I'm running it in Shea Scheme. All right. So, that's the basic

17:03.600 --> 17:10.320
interface. The underlying language that we wrote a vowel in is quite simple. It basically extends

17:10.400 --> 17:17.920
Scheme with three operators, core operators. And then we've got a couple extensions for helping

17:17.920 --> 17:23.600
write interpreters and type in things like that. Okay. So, that's a vowel. And you can see that

17:23.600 --> 17:29.440
we can write things like list 3, 4. Now, what's interesting is that a vowel is written as a

17:29.440 --> 17:37.200
relation. And so, Guy talked about this a little bit yesterday. But, you know, the interesting

17:37.680 --> 17:47.200
thing about the rules, and in fact, I can show you the rules for interpreter, the interesting

17:47.200 --> 17:56.240
thing about these sorts of rules is that they don't really have a direction. So, here is a paper

17:57.200 --> 18:06.080
that was an ICFP in Oxford this year. And in this paper, you can see these rules written as

18:06.080 --> 18:09.840
inference rules. And the code on the right, which is Minikanron. This is kind of lower-level

18:09.840 --> 18:15.440
Minikanron, so it's a little longer. But the important thing is to realize that, you know,

18:15.440 --> 18:23.040
there's this bar here, right, that Guy was talking about. And normally, the way we read it is we

18:23.040 --> 18:28.880
have some antecedents, a consequence. So, we have some things that have to hold. And if these

18:28.880 --> 18:35.360
three things hold, then we can infer the thing on the bottom. And we also sort of read it as,

18:35.360 --> 18:41.120
okay, so this turnstile operator, we can read it as like an interpret or evaluate. So, in a

18:41.120 --> 18:45.760
certain environment, row, this particular expression, which is a procedure application,

18:45.760 --> 18:51.360
evaluates to the value v3. And the rules up top tell you what v3 is. So, if you're writing an

18:51.360 --> 18:57.600
interpreter in a standard way, you would read these rules as, okay, I'm going from left to right.

18:57.600 --> 19:02.400
Here's my expression. Here's my value. Notice there's an arrow instead of an equal sign. So,

19:02.400 --> 19:08.080
that's how you'd often think about it. But there's no reason that we have to go in any sort of

19:08.080 --> 19:13.360
direction. We could actually consider this more like an algebra problem, where we have variables

19:13.360 --> 19:18.640
that we want to place in the different parts. Maybe the row p. We replace that with some variable x.

19:18.640 --> 19:26.240
I don't know what x is. Or the expression or the value. Okay, so if we can put variables in

19:26.880 --> 19:32.160
and then have a system that can do a mixture of maybe things like search and constraint solving,

19:32.160 --> 19:37.760
then we can try putting variables in to get more flexibility. So, that's exactly what we've done.

19:38.720 --> 19:48.080
So, what that means is, if I go back to this valo call, I don't have to just put in an expression

19:48.640 --> 19:54.480
that's known in the first position and then put an unknown in the value position. I can do the

19:54.480 --> 19:59.600
opposite. So, what I could do is I say, okay, well, I know that the list is supposed to be

19:59.680 --> 20:06.880
three, four, right? And grab this list. The extra prens, by the way, and that answer up top have to

20:06.880 --> 20:11.600
do with, first of all, the fact that we can get more than one answer back and also that we can get

20:11.600 --> 20:17.040
some side conditions to help interpret the answer. Anyway, I'm going to replace that query variable

20:17.040 --> 20:24.800
with quote three, four. So, that's the expected value. And I'm going to replace the expression

20:25.760 --> 20:32.320
with my query variable Q. So, now what I'm asking is, give me an expression in scheme

20:32.320 --> 20:36.560
that evaluates the list three, four. So, what would be one such expression do you think?

20:41.120 --> 20:45.600
List three, four. Okay. So, list three, four is one. Quote three, four is another. So, I can ask

20:45.600 --> 20:50.720
for, you know, let me ask for two answers. Okay. So, list three, four was the second one I got.

20:51.600 --> 20:57.840
And I can ask for three answers. And we can see list three, quote, four. So, it turns out that

20:57.840 --> 21:03.920
if you quote three or four, it's the same as just writing three or four. And so, you can see that

21:03.920 --> 21:10.480
we have a number of answers, right? And so, some of those answers involve things like lambda and

21:10.480 --> 21:15.440
procedure application. So, as I say, hey, as function call can give you three, the list three,

21:15.440 --> 21:26.720
four. All right. Now, back to Lollipop land. So, Matt might, who's giving keynote tonight and

21:27.360 --> 21:33.200
whose lab I work in and work with for many years. He wrote a blog post for Valentine's Day

21:34.160 --> 21:39.600
a couple years ago called 99 ways to say I love you in racket. So, the idea of this was to teach

21:40.480 --> 21:44.400
students and beginning racket programmers a little bit of racket and a little bit of how

21:44.400 --> 21:52.080
they manipulate lists because racket's a list and list is list processing. So, the idea is to

21:52.080 --> 21:58.400
show 99 different expressions and there are various complicated ones and so forth that

21:59.440 --> 22:04.640
would evaluate to list I love you. And PD Aldous, who's one of the grad students said, hey,

22:05.440 --> 22:12.560
do you think you could use mini-canron to generate such programs? So, let's try doing that. We're

22:12.560 --> 22:18.560
going to generate 99 programs that evaluate to I love you. So, can you help me out with the query?

22:18.560 --> 22:30.400
What would that look like? Run 99? Sure. Okay. What else is going to change?

22:31.200 --> 22:43.440
Sure. Okay. How about I love you? Okay. All right. So, here are 99 programs that evaluate to I love

22:43.440 --> 22:55.840
you. So, I don't know. Let me, what's a fun one? How about, let's just start down here.

22:56.640 --> 23:02.480
Let me just grab that out and I'm running it in scheme now and you can see that evaluates I love

23:02.480 --> 23:08.480
you. So, we've got list quote I, quote love and then the last sub expression is a procedure call

23:08.480 --> 23:12.960
to a function which is variadic. It takes any number of arguments. The underscore dot zero

23:12.960 --> 23:17.600
represents a symbol representing, that's a symbol representing a variable. The name doesn't matter.

23:17.600 --> 23:21.440
That's why I picked underscore dot zero. That's our convention saying it doesn't matter. You could

23:21.440 --> 23:29.280
pick foo if you wanted there. And this quote underscore one thing. So, this is a quoted symbol

23:29.280 --> 23:32.960
also. If you look at the side conditions, you'll see these things. So, that could be any quoted

23:32.960 --> 23:38.800
symbol and this will hold. There might be some other side conditions like the symbol can't be

23:38.800 --> 23:42.480
called quote. Under score zero can't be called quote because you don't want to shadow quote,

23:42.480 --> 23:49.360
that kind of thing. Okay. So, that's a simple example. And after, after we started playing

23:49.360 --> 23:54.000
around with this a little bit, Dan Friedman and I gave a talk at closure conge and we,

23:54.000 --> 23:59.440
we showed this relational interpreter or variant of it and Stu Holloway at the end said, well,

23:59.440 --> 24:07.040
you know, you should be able to generate quines using this. Anyone know what a quine is? What's a

24:07.040 --> 24:14.320
quine? A program that outputs itself. That's right. Okay. In fact, if we go back to history,

24:14.320 --> 24:24.400
let's see if we can go back and, you know, I love the fact the guy went through so many papers,

24:24.400 --> 24:28.320
old papers. Well, this is a paper I really like by John McCarthy who is the creator of,

24:28.880 --> 24:36.000
of Lisp called a micromanual for Lisp, not the whole truth. And then this he gives rules for

24:36.800 --> 24:42.080
the Lisp language. So, you can see like what equal means, what cons means and so forth.

24:43.040 --> 24:49.280
Notice by the way he uses an equal sign. Right? Not narrow. But then he has this neat little

24:49.280 --> 24:56.960
problem. Difficult mathematical type exercise. Final list E such that value of E equals E.

24:57.840 --> 25:02.240
So, value is the name of his evaluator function, his eval. So, basically,

25:04.000 --> 25:09.120
what he's calling value is what we would call eval or evalo. And so, he's trying to find an

25:09.120 --> 25:14.640
expression E such that the value of E is E. So, that is also trying to find a quine. So,

25:14.640 --> 25:20.880
he was trying to find a quine or Gittis to find a quine in, I think, 1978. So, let's try to do that.

25:22.320 --> 25:28.160
So, given what you know, how would we find a quine? What would, how would we change

25:28.160 --> 25:37.760
our query so we could generate a quine? QQ, a value of QQ, that's right. Now, of course,

25:37.760 --> 25:42.160
there's nothing special about the name Q. So, why don't we, out of respect for John McCarthy,

25:42.160 --> 25:50.000
call it E instead. Valo EE. And let's do a run one. Okay. So, we're trying to find an expression E

25:50.000 --> 25:55.520
that evaluates to itself. This is pretty close to what John McCarthy wrote, right? I mean,

25:55.520 --> 26:02.720
we're calling it a valo instead of, instead of value. But, you know, this is exactly what you

26:02.720 --> 26:07.920
would want to be able to type into a system. So, let's see what Minicandron gives us back.

26:09.440 --> 26:15.920
Well, the first thing it says is that underscore zero is a number, which is true. Okay. So,

26:15.920 --> 26:21.040
in scheme five is a quine. So, five evaluates to itself. That's true. Okay. So, that's what

26:21.040 --> 26:26.480
Minicandron's telling us. Let's ask for a second one. It says hash t. Hash t is true in scheme.

26:27.040 --> 26:31.920
All right. So, those are all quines. Hash f is a quine. How about four?

26:33.920 --> 26:37.040
Now, it's thinking for a minute. Okay. Now, we've got something a little more interesting.

26:38.160 --> 26:44.480
I'm going to grab that expression and type it in. And sure enough, that's a quine. So,

26:44.480 --> 26:50.480
that's a self-evaluating expression. In fact, if you look at the quines page, you will see this

26:50.480 --> 26:56.640
quine. This is sort of the canonical quine. And we can generate all sorts of quines. We can generate

26:56.640 --> 27:03.280
twin quines and triple quines and that kind of thing. But what I love about this, and in some

27:03.280 --> 27:08.400
sense, this is probably my favorite Minicandron query using a relational interpreter, but I love

27:08.400 --> 27:12.480
it as the query is so simple. This is actually the shortest query you can write in terms of the

27:12.480 --> 27:17.200
number of distinct identifiers. This is like the shortest thing you can write. And it generates

27:17.200 --> 27:22.880
quines and it actually works. And I personally was shocked that like, oh, yeah, this actually,

27:22.880 --> 27:27.600
this actually, you can actually do something with this. You type it in. I figured it would take

27:27.600 --> 27:36.240
a million years or something. Okay. So, at that point, a grad student at Utah named Michael

27:36.240 --> 27:43.600
Ballantyne said, well, that's kind of fun. But what if you, now you have this interpreter,

27:43.600 --> 27:51.280
what if you were to take a scheme program and fill in the scheme program in the first expression,

27:51.280 --> 27:56.400
but leave some of the arguments to that program, to that function, you know, make those variables?

27:56.400 --> 28:01.920
Could you, could you get interesting behavior? And so he suggested append. So let's try doing that.

28:02.560 --> 28:12.800
So append in scheme takes two lists, like ABC and DE, and concatenates the list. So get ABCDE,

28:12.800 --> 28:15.200
in this case. So what we're going to do is we're going to write append.

28:22.960 --> 28:30.400
And the way I'll write append is using something called let rec. Let's me define a recursive relation

28:31.360 --> 28:40.000
or a function.

28:40.000 --> 29:07.600
Okay. So that's append. Did I get it right?

29:10.160 --> 29:16.880
And now we're going to call append. I'll use the same arguments as before, ABC to DE.

29:19.600 --> 29:25.840
Okay. So I just ran it forward. So, so what did I do? I took the scheme definition of append.

29:25.840 --> 29:29.440
This is not mini-canon code. This is not logic programming code or constraint logic program

29:29.440 --> 29:35.120
code. This is just scheme code. I ran it inside of a valo as the first argument. This is the

29:35.120 --> 29:40.800
expression argument. And I said we have an unknown value. So my query variable Q represents

29:40.800 --> 29:50.400
the unknown value. So what can we do? Okay. So now what we can do is we can say we know ABCDE

29:51.200 --> 29:58.240
is the output. And where else could I put a variable? Where could I put this Q variable?

29:58.720 --> 30:06.480
Well, how about I put it in a position of one of the arguments to append? How about I put it

30:06.480 --> 30:11.360
right here? I have to put a comma there because this whole thing is back-quoted if you know scheme.

30:11.920 --> 30:16.400
All right. So what do you think I'm going to get back in the place of the Q variable?

30:20.400 --> 30:27.840
ABC, right? So let's see if that works. Yeah. Quote ABC. Is there a second answer? What if I do a

30:27.840 --> 30:37.760
run two? Should there be a second answer or should it say no? No more answers. List ABC. All right.

30:37.760 --> 30:44.720
Well, let's see if we get something like that. It's not list ABC, but we get a procedure application.

30:44.720 --> 30:49.600
And if I evaluate that in scheme, I get back ABC. So what happens is we get an expression

30:49.600 --> 30:57.440
that evaluates to ABC. If I put a quote, I get back ABC itself. Okay. So that's a little subtle

30:57.440 --> 31:04.720
if you're not a schemer, but the point is we're making a distinction between expressions and values.

31:04.720 --> 31:09.360
So if I put a quote in front of the comma Q, that's going to say, well, I want the value,

31:09.360 --> 31:15.280
the list that's going to concatenate to give me ABCDE. If I don't put the quote, that means this

31:15.280 --> 31:21.360
could be an arbitrary expression in my subset of scheme that I'm handling. All right. Where else can

31:21.360 --> 31:34.320
I put Q? Inside the list, like here. Sure. Yep. In fact, I could have two variables. I could do

31:34.320 --> 31:46.720
like x and y. And I can do things like... In fact, I can ask for all the answers. So if you're familiar

31:46.720 --> 31:51.680
with logic programming and prologue or mini-canon or something like that, you've seen this before,

31:51.680 --> 31:57.920
things like a pen. That's a standard answer or a standard program. But we didn't write a pen in

31:59.360 --> 32:04.000
mini-canon or prologue. We wrote a pen in scheme. We'd get the relationality through the relational

32:04.000 --> 32:09.440
interpreter. All right. What else can we do? Where else can we put variable? How about

32:10.160 --> 32:16.960
if we put a variable inside the code? What if I put a variable where the s is?

32:19.280 --> 32:28.560
Okay. That used to be the symbol s. What should I get back? I get back the s, right? So I could

32:28.560 --> 32:36.000
also replace it here, like the car of L. Oh, I got two... I was doing a run two.

32:36.960 --> 32:42.480
Yeah. So I got car of L and another expression, which is the same as car of L, equivalent to it.

32:43.200 --> 32:49.920
All right. Now, I could show you much, much more. If you're interested in that sort of thing,

32:49.920 --> 32:58.000
I recommend you look at our paper in ICFP 2017. But I just want to show you what happens if you

32:59.360 --> 33:04.160
sort of put an interface on this. And you also speed up the naive version by about

33:04.160 --> 33:09.680
nine orders of magnitude, because that's what we've done. Michael Valentine and Greg Rosenblatt

33:09.680 --> 33:16.320
have been speeding up the system. So Greg gave us eight orders of magnitude in

33:17.120 --> 33:21.600
eight months or something. So now what we're going to do is we're going to do some program

33:21.600 --> 33:27.440
synthesis. So this... What's happening underneath the hood is we're just generating calls to our

33:27.440 --> 33:32.640
Valo. We're doing example-based program synthesis. So here I have a call to a pen. I've got a

33:32.640 --> 33:37.360
fragment of the append definition, the comma A, comma B, comma C. Those are logic variables

33:37.360 --> 33:41.280
representing holes in our program. And you can see at the bottom that Barleman's trying to figure out

33:42.880 --> 33:50.720
what we have. I can do this in various ways, but one way I might want to do it to try to keep

33:51.360 --> 33:56.560
the system from over-specializing is to use these G1, G2 things, which sort of represent

33:56.560 --> 34:00.800
universally quantified variables, if you want to think of that way, or sort of like Jenssen's

34:01.200 --> 34:06.400
skull invariables. So I don't quite have enough structure. So let me try one more example.

34:17.600 --> 34:19.760
Okay. Let that think for a minute.

34:25.280 --> 34:30.640
Okay. Now it's figured out the recursion. And it's a little hard to read it. So I'm going to just

34:30.640 --> 34:40.480
put in variable names, concrete variable names. And now you can see, you can read a little more.

34:40.480 --> 34:45.440
And if you know scheme, this is the correct definition of a pen. Okay. So what's happened?

34:45.440 --> 34:54.720
We've taken minicanron. We've implemented the semantics written in something similar to the CMS,

34:55.680 --> 35:02.880
computer science meta, or is it CMN? Whatever it's called. The computer science meta notation or

35:02.880 --> 35:13.920
whatever. Okay. Something like that. And through some cleverness on the back end, which we're hoping

35:13.920 --> 35:20.080
to generalize, so it's not just for our interpreter, but we'll work with a wider range of semantics

35:20.800 --> 35:24.320
and type systems and things like that. You would just type in. We can also do this for

35:24.320 --> 35:29.600
grammars, regular expressions, and so forth. We're able to get to the point where we can just type

35:29.600 --> 35:36.720
in input-output examples, and the system is able to do recursive, higher-order synthesis for our

35:36.720 --> 35:42.320
subset of scheme. We can also write type inferences in this way. So I'm hoping we can combine those.

35:42.320 --> 35:46.240
We'd write type inferences in the same way. We'd write the operational semantics for the

35:47.040 --> 35:51.520
evaluator. And we can also write grammars. There's also a grammar written in exactly the

35:51.520 --> 35:56.560
same style underneath this. So we can do grammars. We can generate expressions in exactly the same

35:56.560 --> 36:04.720
way. So I'm hoping as we improve this technology that we'll get closer and closer, I don't think we'll

36:04.720 --> 36:10.160
ever get there perfectly, but we'll get closer and closer to being able to be naive and just take

36:10.160 --> 36:15.680
a paper or some operational semantics or typing judgments or whatever, just type it in, hopefully

36:15.680 --> 36:22.400
with a nicer syntax, and then be able to start exploring this world and asking queries that

36:23.120 --> 36:29.600
maybe other people haven't thought of before or just being surprised. That's the best part for me.

36:29.600 --> 36:33.680
That's why I like Doug's math aquarium. It would surprise you. And that's why I like playing around

36:33.680 --> 36:37.760
with mini-canner. There's things like quines that surprise me. There are all sorts of programs that

36:37.760 --> 36:43.040
we're generating that surprise me. I didn't think it would be either possible or I had a different

36:43.040 --> 36:47.360
idea of which program would meet a certain specification, and mini-canner said, hey, this

36:47.360 --> 36:54.800
program meets it also, often sort of trolling me in the process. So anyway, this is lollipop

36:54.800 --> 37:00.400
driven development, if you will, where you just type the semantics, sort of like you'd read in the

37:00.400 --> 37:05.840
paper, write down examples, maybe write down types and things like that, get the system to fill in

37:05.840 --> 37:15.120
the unknowns for you in an exploratory way. So that's basically what Dan should have told me.

37:15.120 --> 37:21.760
He should have said, well, eight years from now, Guy Steele will give a keynote at CodeMesh,

37:22.640 --> 37:29.200
and at that point, we want to be able to type in those rules and just have it do things like

37:29.200 --> 37:36.080
and further program. So that's the idea. If you're interested in this, look at an ICFP 2017

37:36.080 --> 37:42.240
paper, go to mini-canron.org, look at the paper on micro-canron, which shows an implementation

37:42.240 --> 37:47.040
of a simple version, and look for the second edition of the Reason Schemer, which is about

37:47.040 --> 37:59.280
to come out. Thank you. Well, we actually have two minutes left. I think this is the first for

37:59.280 --> 38:19.440
you, Will, so we can take a question if you want. So the second test didn't work. Could you just go

38:19.440 --> 38:26.000
back and do that again, but fill it in with kind of the readable symbols so we can see why. So you

38:26.320 --> 38:31.600
want this one? Yeah. Well, the second one did work in a sense. It depends what you mean by work.

38:32.160 --> 38:39.520
So the mini-canron or Barleman's idea is prove me wrong, right? So this program

38:39.520 --> 38:44.400
absolutely matches that specification, but you're right that it's not what we had in mind, and this

38:44.400 --> 38:50.320
is part of the problem, right? So even if you can imagine Barleman being 500 orders of magnitude

38:50.320 --> 38:56.640
faster, and in some sense it solves program census by example, in another sense you still

38:56.640 --> 39:02.320
have the problem of writing down a specification that is complete enough and correct enough

39:02.320 --> 39:07.120
that you're going to get the right output, even if we're much, much faster, right? So this shows

39:07.120 --> 39:11.360
that census really has at least two problems. One is the speed problem of dealing with this

39:11.360 --> 39:15.440
exponential space and dealing with, you know, synthesizing programs that could go in infant

39:15.440 --> 39:21.040
loops, but there's also the specification problem. So how did you know what to type in the box labeled

39:21.040 --> 39:27.120
test three? How do you know what to type in there? Well, so that's a good question. There are

39:27.120 --> 39:31.200
different ways to give a specification. So you could write types, right? We don't currently

39:31.200 --> 39:35.040
support that, but you could write types, you could write examples, you could write properties,

39:35.040 --> 39:39.440
high-level properties, right? The other thing you can do, which I didn't show you, is that this is

39:39.440 --> 39:44.400
an IDE, so you can edit the code. So you can be writing some of the code and writing some of the

39:44.400 --> 39:48.800
tests and writing some of the types, and it's going to fill in the rest for you. So you could also

39:48.800 --> 39:53.520
use it as sort of like an IDE. But at some point, if you don't know what the program should do

39:54.640 --> 39:58.400
and you don't know any of the code, it's not going to figure that out for you. So you're going to

39:58.400 --> 40:04.800
have to do a little work. You know, even with my example, my stupid box example, I still had to

40:04.800 --> 40:09.680
figure out that I wanted a box that was two inches by two inches, right? So yes. Thank you.

40:10.640 --> 40:14.800
So basically, this is automated TDD, isn't it?

40:15.600 --> 40:21.840
That's part of it, but the reason I gave that intro is the problem is every time I give a talk,

40:21.840 --> 40:25.680
and I've given many variants of this talk, every single time I give a talk, someone comes away

40:25.680 --> 40:30.000
thinking, oh, well, so your research is on program census, or your research is on test-driven

40:30.000 --> 40:33.440
development, or your research is on logic programming, or your research is like, no,

40:33.440 --> 40:39.360
no, that's not it. The research is on lollipops, okay? The research is on lollipops and being able

40:39.360 --> 40:44.240
to sort of do things like just write down the rules and explore it, okay? That's really what

40:44.240 --> 40:50.080
the dream is. Program census falls out of this. Now, if we can do, if we make the system much

40:50.080 --> 40:55.040
faster and we can get a useful program census tool, or a useful test-driven development tool,

40:55.040 --> 41:01.520
or a useful IDE, great. But that's only a very small part of really the overall goal.

41:01.520 --> 41:03.680
Thank you, Will.

