WEBVTT

00:00.000 --> 00:02.280
Hello, can everyone hear me?

00:02.280 --> 00:03.880
The mic on and everything.

00:03.880 --> 00:04.960
Good to go.

00:04.960 --> 00:06.040
Thank you, Boodle.

00:06.040 --> 00:07.880
And thank you for having me here.

00:07.880 --> 00:11.160
All right, I had a totally different talk plan

00:11.160 --> 00:13.280
and then Phil's talk was really cool.

00:13.280 --> 00:15.360
And then I was like, oh, I'll do something

00:15.360 --> 00:17.440
with Lambda Calculus and Mini-Canron.

00:17.440 --> 00:19.160
And then I was talking to people last night

00:19.160 --> 00:24.160
and basically Andrea and Mark and Stefan,

00:25.080 --> 00:27.400
a few other people convinced me to try something

00:27.400 --> 00:29.560
like much more radical than I normally do

00:29.560 --> 00:30.760
with my live coding.

00:30.760 --> 00:33.520
So I want you all to be doing live coding,

00:33.520 --> 00:34.880
at least anyone who's interested.

00:34.880 --> 00:39.880
So if you can get out your lapis and go to this URL,

00:42.080 --> 00:46.800
and that holds doubly true for anyone watching on video.

00:46.800 --> 00:49.640
This is specially designed so that people in the audience

00:49.640 --> 00:52.640
and people on video can kind of follow along.

00:52.640 --> 00:54.720
And basically what I'm gonna do is I'm gonna check in

00:54.720 --> 00:57.200
the code as I'm talking and I'll let you know

00:57.200 --> 00:58.800
when I did a check-in so you can do a poll,

00:58.800 --> 01:00.400
so you can sync up with me.

01:00.400 --> 01:04.360
And there's a really cool web-based version

01:04.360 --> 01:06.400
of Mini-Canron that David Kahn created.

01:06.400 --> 01:10.720
And you can just paste that code into the web browser

01:10.720 --> 01:13.400
and you should be able to run Mini-Canron, okay?

01:13.400 --> 01:16.000
So we'll try that and it might crash and burn.

01:16.000 --> 01:17.400
We'll just see how it goes.

01:17.400 --> 01:19.440
But the great thing is if someone's watching a video

01:19.440 --> 01:21.960
afterwards they should be able to follow along and stop.

01:21.960 --> 01:25.000
And if anyone here is confused about something,

01:25.000 --> 01:26.520
you can't get an example to run or whatever,

01:26.520 --> 01:28.160
you can ask a question, okay?

01:28.160 --> 01:29.440
Or you can take it offline, whatever.

01:29.440 --> 01:32.440
But it's one thing to show this stuff,

01:32.440 --> 01:34.600
but at some point people will have all these questions

01:34.600 --> 01:36.720
and if you can't really play with it,

01:36.720 --> 01:39.720
you don't really get the sense, I think, of what it's about.

01:39.720 --> 01:41.720
So I want everyone to be able to try it.

01:42.880 --> 01:47.880
Okay, so the web browser version of Mini-Canron

01:48.280 --> 01:51.340
is at this link right here, the veneer stuff, okay?

01:52.720 --> 01:53.560
All right.

01:54.000 --> 01:58.320
So here's my repo and I've got a file called talk.scm

01:58.320 --> 02:00.560
and that's where I'm gonna have my code in it.

02:00.560 --> 02:03.720
And the way I'm gonna do this is I'm gonna basically type

02:03.720 --> 02:08.400
into the code into Emacs and then I'll paste it into veneer

02:08.400 --> 02:11.200
and that's basically what y'all can do in terms of

02:11.200 --> 02:14.240
opening up the file and get pasting into veneer,

02:14.240 --> 02:16.280
running it and you can edit it in your own text editor,

02:16.280 --> 02:17.400
you can edit it in veneer.

02:17.400 --> 02:20.560
And I encourage you to try some different combinations

02:20.560 --> 02:22.920
or different queries and see if you can break it,

02:23.120 --> 02:24.440
see if you can run in infinite loops,

02:24.440 --> 02:27.640
which you probably can, and so forth.

02:27.640 --> 02:30.360
And if you have a cool example, you can share it.

02:30.360 --> 02:35.360
This is, by the way, like version 0.01 of the technology

02:35.560 --> 02:37.560
I would really like for giving interactive talks

02:37.560 --> 02:42.000
where either Super Emacs mode or a web browser

02:42.000 --> 02:43.440
or something like that where people in the audience

02:43.440 --> 02:45.560
really could do this more seamlessly,

02:45.560 --> 02:48.200
but that's tech I'm working on with other people

02:48.200 --> 02:49.400
like Michael Valentine.

02:50.400 --> 02:54.280
All right, so let's talk about mini-canon

02:54.280 --> 02:58.280
and I'm gonna bring up the veneer editor,

02:58.280 --> 02:59.120
let me refresh.

02:59.120 --> 03:00.960
If veneer ever gets in a bad state,

03:00.960 --> 03:02.520
you can just click refresh.

03:04.840 --> 03:09.840
Let's see, is there, I can kind of make the font bigger.

03:09.880 --> 03:13.920
The way you use veneer is if you've got code

03:13.920 --> 03:15.760
on the left-hand side, you click the run button

03:15.760 --> 03:18.960
and it'll evaluate this code and there's like

03:18.960 --> 03:20.560
a little redeval print loop thing

03:20.560 --> 03:22.160
you can just type for small expressions

03:22.160 --> 03:23.760
if you wanna try those, okay?

03:25.080 --> 03:27.240
And this is a relational scheme interpreter,

03:27.240 --> 03:30.320
which we'll play around with something like that in a minute.

03:30.320 --> 03:31.880
The main button you're gonna care about

03:31.880 --> 03:33.640
is this create file button.

03:33.640 --> 03:37.000
So if you create file, it's gonna blank whatever's

03:37.000 --> 03:39.640
on the left, then you can just type in code here,

03:39.640 --> 03:42.200
mini-canon code, and then click run

03:42.200 --> 03:44.600
and it'll be evaluated on the right-hand side.

03:44.600 --> 03:47.240
So let's just try something simple.

03:49.080 --> 03:52.520
So I said I'll go to Emacs, but well,

03:52.520 --> 03:54.000
let me try doing it in the veneer.

03:54.000 --> 03:55.640
First of all, is the font big enough?

03:55.640 --> 03:56.480
Can people see that?

03:56.480 --> 03:58.280
I can try to bump it up a little bit.

04:02.520 --> 04:03.760
If the run button will cooperate.

04:03.760 --> 04:07.300
Maybe I can, there we go, look.

04:08.800 --> 04:10.280
That run button's oversized.

04:10.280 --> 04:12.360
Okay, so the first thing I'm gonna show,

04:12.360 --> 04:15.240
so mini-canon, core mini-canon only has three operators.

04:15.240 --> 04:17.160
It's a very small language, just like lambda calculus

04:17.160 --> 04:18.080
is very small, right?

04:18.120 --> 04:21.080
Lambda calculus has three parts,

04:21.080 --> 04:23.480
and so does mini-canon for the core parts of the language.

04:23.480 --> 04:25.240
And you can extend it, just like you can extend

04:25.240 --> 04:27.280
mini-canon to get something like scheme, right?

04:27.280 --> 04:31.560
So the most fundamental operator in mini-canon,

04:31.560 --> 04:33.760
and mini-canon's a type of logic programming language,

04:33.760 --> 04:37.200
like Prolog, it's got some real differences as well,

04:37.200 --> 04:39.840
the fundamental operator is something called unification.

04:39.840 --> 04:41.720
And unification you can think of as sort of like

04:41.720 --> 04:44.800
a two-way super pattern matcher.

04:44.800 --> 04:47.000
So if you're familiar with pattern matching,

04:47.000 --> 04:49.440
then in a pattern match, you have some value

04:49.440 --> 04:51.520
you're pattern matching against,

04:51.520 --> 04:54.520
and then you've got some sort of pattern, right?

04:54.520 --> 04:56.520
And in the pattern, you can have variables,

04:56.520 --> 04:59.600
we call those match variables, or pattern variables, okay?

04:59.600 --> 05:02.080
And those pattern variables get values filled in

05:02.080 --> 05:04.480
from the value you're matching is.

05:04.480 --> 05:07.200
Similar with unification, except you can have essentially

05:07.200 --> 05:12.200
pattern variables on each side, okay?

05:13.520 --> 05:16.680
So you can have variables on both sides.

05:16.680 --> 05:19.320
And the variables don't actually ever have to be filled in.

05:19.320 --> 05:21.080
That's fine also.

05:21.080 --> 05:24.840
Variables don't ever have to get values in this paradigm.

05:24.840 --> 05:26.240
So here we're gonna do something simple,

05:26.240 --> 05:30.680
and you can also think of unification,

05:30.680 --> 05:33.120
we call it equal, equal here really.

05:33.120 --> 05:35.920
It's like a type of a quality operator also.

05:35.920 --> 05:40.920
So here we're asking whether or not five is equal to five.

05:40.920 --> 05:43.840
Or another way to look at it is we're asserting

05:43.840 --> 05:46.120
that five must be equal to five.

05:46.120 --> 05:47.840
And if it's not equal to five,

05:47.840 --> 05:52.000
then we've reached inconsistent conclusion basically.

05:52.000 --> 05:53.680
So is five equal to five?

05:55.560 --> 05:58.120
One would hope, okay, yeah.

05:58.120 --> 06:00.920
The logic isn't that weird, so let's run it.

06:00.920 --> 06:03.280
And you can see, copy the expression,

06:03.280 --> 06:05.640
and the answer is yes, well that's good.

06:05.640 --> 06:07.280
That makes me happy.

06:07.280 --> 06:08.120
All right.

06:09.360 --> 06:12.680
Okay, so I promised I would do the interactive thing.

06:12.680 --> 06:14.760
So here's our first program.

06:14.760 --> 06:17.160
Equal, equal five, five, and I will check that in.

06:18.280 --> 06:19.120
Okay.

06:21.120 --> 06:25.400
So, are you supposed to like, how do you do this thing?

06:25.400 --> 06:27.560
You do like a get add or something?

06:29.720 --> 06:30.560
Get upload?

06:32.160 --> 06:33.440
Add dot.

06:33.440 --> 06:34.520
Oh, whoa, okay.

06:34.520 --> 06:36.160
And I'm not really good at get, so.

06:36.160 --> 06:38.360
And then get commit, is that how you do it?

06:39.440 --> 06:41.200
Oh yeah, they do it.

06:41.200 --> 06:43.760
Okay, so get commit, and I have to give a message,

06:43.760 --> 06:45.400
and I'll say one is the message,

06:45.400 --> 06:47.080
because that's the first one.

06:47.080 --> 06:48.080
Okay?

06:48.080 --> 06:49.360
All right, so you're following along,

06:49.360 --> 06:52.640
that's the first, so you can do a pull,

06:52.640 --> 06:56.160
and you can paste that complicated program into veneer.

06:56.160 --> 06:58.920
Let's all do it, make sure we get the tech working,

06:58.920 --> 07:02.960
and then click run, and you should be able to see yes, okay?

07:02.960 --> 07:05.840
That's the first program, great.

07:05.840 --> 07:06.680
Okay.

07:06.680 --> 07:07.520
Yes.

07:07.520 --> 07:09.200
For future reference, instead of doing the get add,

07:09.200 --> 07:12.200
you can just put in dash A on the get commit.

07:12.240 --> 07:14.720
Get commit dash A, ooh, yeah, okay.

07:14.720 --> 07:16.080
All right, I like this, I'm learning.

07:16.080 --> 07:20.800
Okay, so we can do another program, let's do a variant.

07:20.800 --> 07:22.560
This is program number two.

07:22.560 --> 07:24.080
What about six and five?

07:25.440 --> 07:26.280
No.

07:26.280 --> 07:28.140
No, that's right.

07:28.140 --> 07:29.440
Computer says no.

07:29.440 --> 07:30.720
All right, so.

07:31.720 --> 07:33.120
What's about the proof of this?

07:33.120 --> 07:35.120
The proof of it?

07:35.120 --> 07:35.960
Okay, what is it?

07:35.960 --> 07:37.760
Well, hold on, let me check in, my code, I promised.

07:37.760 --> 07:38.600
Okay.

07:38.600 --> 07:40.520
I guess I could, I could like,

07:40.520 --> 07:43.120
look, like get keeps track of revisions.

07:43.120 --> 07:45.400
So I'm not even gonna add another expression.

07:45.400 --> 07:47.680
I'm just gonna like do that, and then it works, all right?

07:47.680 --> 07:49.680
So I could do get, was it?

07:49.680 --> 07:54.680
Get commit dash A, ooh, dash A and then two, right?

07:58.640 --> 07:59.480
Do a pull.

08:01.200 --> 08:03.560
Okay, so what's your question, Boodle?

08:03.560 --> 08:05.440
You wanna know about the proof?

08:05.440 --> 08:07.360
Why is five equal to five?

08:07.360 --> 08:09.600
Why is five equal to five?

08:09.600 --> 08:11.600
Well, let me change it up a little bit,

08:11.600 --> 08:13.280
and maybe I'll answer your question.

08:13.280 --> 08:15.040
I'm gonna put in something else.

08:15.040 --> 08:17.480
Instead of a number, so having two numbers,

08:17.480 --> 08:20.800
I'm gonna put in X, and X is a logic variable.

08:20.800 --> 08:21.800
So you can think of it sort of like

08:21.800 --> 08:23.440
this pattern variable, right?

08:23.440 --> 08:26.080
Okay, so, so is X equal to five?

08:27.720 --> 08:28.920
Yes, we don't know yet.

08:28.920 --> 08:31.200
Yes, we don't know yet, okay?

08:31.200 --> 08:36.200
We don't know, it could be, if X doesn't have a value yet,

08:36.360 --> 08:38.840
then now it does have a value, right?

08:38.840 --> 08:40.960
The answer is yes, and X is five.

08:40.960 --> 08:44.560
But if X is already six, then the answer is no.

08:44.560 --> 08:45.440
All right, so we don't really know,

08:45.440 --> 08:48.160
but I'll say that X is starting out fresh.

08:48.160 --> 08:49.520
We say fresh, it doesn't have a value yet.

08:49.520 --> 08:52.880
So let's run that, yes, and beyond yes,

08:52.880 --> 08:57.200
we see that X has a value associated with it, five, okay?

08:57.200 --> 08:58.040
All right, cool.

09:03.960 --> 09:04.960
Yeah, what?

09:07.200 --> 09:08.040
What did that work?

09:09.040 --> 09:10.840
Oh, I didn't say it.

09:12.280 --> 09:13.120
Oh, you're right.

09:14.160 --> 09:15.680
I got this hard, okay.

09:15.680 --> 09:19.640
All right, so that's one thing we can do, all right?

09:19.640 --> 09:21.940
And so if you look at it this way,

09:21.940 --> 09:25.720
then basically what we're really saying is an assertion.

09:25.720 --> 09:28.440
We're saying that the thing on the left

09:28.440 --> 09:31.200
is syntactically equal to the thing on the right.

09:33.320 --> 09:36.800
As long as you kind of find some set of values

09:36.840 --> 09:39.320
that are assigned to these variables inside the terms

09:39.320 --> 09:41.120
that will make them syntactically equal, right?

09:41.120 --> 09:45.000
So the question is, is there any possible assignment for X

09:45.000 --> 09:46.800
that will make the left and right hand side equal?

09:46.800 --> 09:49.680
And the answer is yes, as long as X is five,

09:49.680 --> 09:51.200
then they'll be equal, okay?

09:51.200 --> 09:54.560
So that's the sort of reasoning you do with unification.

09:54.560 --> 09:58.720
And we can even put variables on both sides, X and Y.

09:58.720 --> 10:00.560
So what should the answer be here?

10:02.080 --> 10:04.640
Yes, and furthermore, what else do we know?

10:05.640 --> 10:08.000
We know that Y is five.

10:08.000 --> 10:10.360
Well, let's say we got rid of the original program, right?

10:10.360 --> 10:13.860
This is the whole program now, so there are no fives anymore.

10:13.860 --> 10:17.040
X and Y are the same, presumably.

10:17.040 --> 10:20.080
And so we can see here that X and Y

10:20.080 --> 10:21.880
are both associated with some value.

10:21.880 --> 10:24.440
And this itself is a representation of a logic variable

10:24.440 --> 10:25.640
that doesn't have a value.

10:25.640 --> 10:27.860
And you can see that they have the same number.

10:27.860 --> 10:30.000
If they were different, you'd see a one here

10:30.000 --> 10:31.280
in one of them and a zero in the other.

10:31.280 --> 10:33.480
So it's telling us it really is the same,

10:33.520 --> 10:35.160
the same logic variable, okay?

10:38.560 --> 10:40.920
I'm gonna get the hang of this soon, so that's...

10:40.920 --> 10:42.560
So the definition of the point to that,

10:42.560 --> 10:44.680
that's not too much you can make?

10:44.680 --> 10:46.760
It's basically a syntactic definition, yeah.

10:46.760 --> 10:51.400
So you could define it recursively, like over a tree.

10:51.400 --> 10:53.080
Okay, so that's the big operator.

10:53.080 --> 10:55.520
And of course, we can have more complicated data structures.

10:55.520 --> 10:59.800
So we could do, you know, I think Vanir has this.

10:59.800 --> 11:02.320
Let's see if Vanir has a list.

11:04.480 --> 11:07.720
Yeah, so Vanir has a list in it.

11:07.720 --> 11:10.480
So we're creating a list containing X and a list containing Y.

11:10.480 --> 11:12.080
And because they have the same structure,

11:12.080 --> 11:13.760
that's fine also, okay?

11:13.760 --> 11:18.560
But if we had, say, list X and Y,

11:21.360 --> 11:23.120
well, what would happen in this case?

11:24.160 --> 11:25.000
Is it gonna succeed?

11:25.000 --> 11:25.840
Is it gonna fail?

11:29.680 --> 11:31.320
It's gonna be yes.

11:31.320 --> 11:35.440
And notice, we have the same logic variable here for the X,

11:35.440 --> 11:37.920
but now Y wraps a list around it, okay?

11:38.840 --> 11:39.680
Yes?

11:39.680 --> 11:41.000
Why do you use nothing rather than

11:41.000 --> 11:43.280
supposed to create a substitution

11:43.280 --> 11:45.840
that says X equals Y, Y equals X?

11:45.840 --> 11:47.040
So that's a good question.

11:47.040 --> 11:48.640
Internally, there is a substitution.

11:48.640 --> 11:51.040
The question is about why aren't we using a substitution?

11:51.040 --> 11:52.360
Internally, there is a substitution,

11:52.360 --> 11:54.280
and this is actually the representation

11:54.280 --> 11:56.280
of the substitution, okay?

11:56.280 --> 11:58.880
We're seeing as the output representation of substitution.

11:58.880 --> 12:00.440
All right, here's one more.

12:01.320 --> 12:05.640
List X and X, what's the value there?

12:08.040 --> 12:08.880
Yes, no?

12:09.840 --> 12:11.440
What should I get printed out as?

12:16.000 --> 12:17.200
Infinite tree.

12:19.200 --> 12:24.200
No, we're not allowed to have a term unified with a term,

12:25.880 --> 12:28.360
with a structure containing that term, okay?

12:28.360 --> 12:30.960
And this gets to what Phil was talking about,

12:30.960 --> 12:32.800
where you can have these infinite structures

12:32.800 --> 12:34.280
and you run into trouble with that.

12:34.280 --> 12:36.280
So we're doing what's called the occur check.

12:36.280 --> 12:38.360
We're checking to see if X occurs in the structure,

12:38.360 --> 12:42.720
and if so, we're going to say, no, no answer, we fail, okay?

12:42.720 --> 12:44.840
And that's important, this is how we get soundness.

12:44.840 --> 12:47.560
If we don't have that, we can prove all sorts of things

12:47.560 --> 12:50.040
that aren't true and get in trouble.

12:50.040 --> 12:52.800
Okay, so that's unification, that's the main operator.

12:54.640 --> 12:55.880
What else do we have?

12:55.880 --> 12:59.200
Well, we have the ability, yes, all right.

12:59.200 --> 13:00.040
Question around?

13:00.200 --> 13:04.880
I couldn't get it to fail on more than one term.

13:04.880 --> 13:07.320
You couldn't get to fail on more than one term, so.

13:07.320 --> 13:09.800
If we have unification between X and five,

13:09.800 --> 13:10.880
and then I get everything.

13:10.880 --> 13:13.040
Ah, I see, okay, good question, good point.

13:13.040 --> 13:17.600
So I think what Rob's saying is if you do something like this,

13:17.600 --> 13:19.840
and then you have another equal equal,

13:19.840 --> 13:23.160
and we're saying six and X, right?

13:23.160 --> 13:25.280
Then you think that's inconsistent information,

13:25.280 --> 13:27.400
but we're still getting a yes that X is six.

13:27.400 --> 13:29.960
So let me go ahead and show you

13:29.960 --> 13:31.520
how we can sequence things.

13:31.520 --> 13:33.440
So what Vanir is doing is it's assuming

13:33.440 --> 13:34.520
these are two separate programs,

13:34.520 --> 13:36.080
it's ignoring the first, essentially,

13:36.080 --> 13:38.200
and just giving us the answer from the second.

13:38.200 --> 13:39.280
That's a good point.

13:39.280 --> 13:41.920
So let me show you the second operator of mini-canon,

13:41.920 --> 13:43.560
which is called fresh.

13:43.560 --> 13:46.020
And what fresh allows you to do is a conjunction.

13:47.520 --> 13:51.400
Okay, so now we have a conjunction of goals like that,

13:51.400 --> 13:54.120
and I can run that, and now my answer is no.

13:54.120 --> 13:56.180
Okay, so fresh acts as a conjunction.

13:56.180 --> 13:58.040
Fresh has one other purpose.

13:58.040 --> 14:01.400
Fresh also lets me introduce new logic variables.

14:01.400 --> 14:02.480
Now the way Vanir works,

14:02.480 --> 14:04.560
which is a little different from standard mini-canon,

14:04.560 --> 14:06.320
Vanir acts more like prologue,

14:06.320 --> 14:10.640
and these variables that aren't defined lexically,

14:10.640 --> 14:12.320
those become new logic variables.

14:12.320 --> 14:15.000
So you need to use fresh less than Vanir

14:15.000 --> 14:16.560
than you do in standard mini-canon.

14:16.560 --> 14:18.040
But if we add a Y there,

14:18.040 --> 14:20.880
that will allow us to create a locally defined

14:20.880 --> 14:23.560
logic variable that has no value called Y.

14:25.360 --> 14:26.760
So that's the fresh form.

14:28.040 --> 14:29.760
All right, that's a pretty complicated program,

14:29.760 --> 14:32.640
so I better add that.

14:33.760 --> 14:38.360
And yeah, okay.

14:38.360 --> 14:39.760
All right, good.

14:39.760 --> 14:42.440
So you've seen two-thirds of the language now,

14:42.440 --> 14:46.120
fresh and equal, and then I'll show you the last part.

14:46.120 --> 14:47.520
Last part's con-dee,

14:47.520 --> 14:49.080
and this is something that allows us

14:49.080 --> 14:50.880
to get more than one answer back.

14:50.880 --> 14:53.040
Okay, because it'd be kind of boring

14:53.040 --> 14:55.680
if our programs could only return one answer.

14:55.680 --> 14:57.480
And one of the points of logic programming

14:57.480 --> 15:01.080
is that we can return potentially infinitely many answers.

15:01.080 --> 15:02.600
So the way we're gonna do that,

15:02.600 --> 15:06.200
and mini-canon syntactically looks a lot like scheme,

15:06.200 --> 15:09.400
because it's the original implementation of the scheme.

15:09.400 --> 15:12.480
So con-dee is based on Lisp's con operator,

15:12.480 --> 15:13.600
which is a conditional operator,

15:13.600 --> 15:17.120
sort of like a big, giant type of if,

15:17.120 --> 15:19.560
or pattern, sort of like a pattern matching syntax,

15:19.560 --> 15:20.560
but it doesn't have a pattern match

15:20.560 --> 15:22.400
or build into it explicitly.

15:22.400 --> 15:24.240
So we're gonna have a con here.

15:25.080 --> 15:30.080
Sorry, con-dee, e stands for every answer.

15:30.560 --> 15:34.080
And the syntax for con-dee is that for each clause,

15:34.080 --> 15:36.600
each con-dee clause has set of parentheses,

15:36.600 --> 15:40.360
and then it takes one or more of these sub-expressions,

15:40.360 --> 15:41.520
there's other mini-canon expressions,

15:41.520 --> 15:42.760
which are called goals.

15:43.920 --> 15:48.400
So equal five x is a goal, I'll pop that in there,

15:48.400 --> 15:52.520
and equal six x is a goal, I'll pop that in the second case.

15:55.040 --> 15:58.720
And, all right.

15:58.720 --> 16:00.360
So what's gonna happen here?

16:00.360 --> 16:03.200
Well, the idea is that we're trying

16:03.200 --> 16:05.280
each of these two clauses independently.

16:05.280 --> 16:06.960
We're gonna try one of the two clauses,

16:06.960 --> 16:09.520
and it's unspecified mini-canon, which one we try first.

16:09.520 --> 16:11.760
Let's say we try the second one first.

16:11.760 --> 16:13.960
So we would try unifying x with six,

16:13.960 --> 16:17.320
x would get, we get yes, x would be associated with six,

16:17.320 --> 16:19.880
and then we could ask for another answer.

16:19.880 --> 16:21.280
And we ask for another answer,

16:21.280 --> 16:23.720
it's as if we had never tried this one.

16:23.720 --> 16:24.920
We try the other one.

16:24.920 --> 16:28.360
And now we forget this association between x and six,

16:28.360 --> 16:31.680
x is refreshed magically, and we're gonna try it again,

16:31.680 --> 16:33.080
and now x will be five.

16:33.080 --> 16:35.800
So it gives us a chance to try different branches

16:35.800 --> 16:36.640
of a program.

16:36.640 --> 16:38.120
So it's similar to like an if,

16:38.120 --> 16:41.720
except an if where you can independently try

16:41.720 --> 16:43.960
all the possibilities, all the tests,

16:43.960 --> 16:46.320
and the consequence, and so forth independently.

16:48.480 --> 16:52.880
Condi is like a disjunction, and fresh is like a conjunct.

16:52.880 --> 16:55.640
Condi is disjunction, fresh is conjunction.

16:55.640 --> 16:56.960
That's right.

16:56.960 --> 16:58.920
And there's a simplified version of mini-canon

16:58.920 --> 17:02.160
called micro-canon, where conjunction and disjunction,

17:02.160 --> 17:04.400
binary versions of those, are the primitive operators.

17:04.400 --> 17:06.040
So those are much closer to logic.

17:06.040 --> 17:08.720
This is closer to maybe a nicer syntax

17:08.720 --> 17:10.400
to program with for real programs,

17:10.400 --> 17:12.240
but if you wanna see the more primitive stuff

17:12.240 --> 17:14.200
that's closer to logic, look at micro-canon.

17:14.200 --> 17:16.480
And that has the very short implementation,

17:16.480 --> 17:17.800
the implementation of micro-canon,

17:17.800 --> 17:19.440
something like 46 lines of scheme code

17:19.440 --> 17:21.800
for all the logic programming system.

17:21.800 --> 17:25.000
So we can try running this, and we get the first answer,

17:25.000 --> 17:28.120
so we try the first one, first clause

17:28.120 --> 17:29.480
in this version of mini-canon,

17:29.480 --> 17:31.680
and we can click on more answers,

17:31.680 --> 17:33.680
and hey, now we've tried the other clause,

17:33.680 --> 17:35.960
where x is six, so we're not inconsistent

17:35.960 --> 17:37.200
because we're trying these clauses

17:37.200 --> 17:38.920
totally independently of each other,

17:38.920 --> 17:40.160
and we can ask for more answers,

17:40.160 --> 17:43.320
and finally we say no, no more answers, that's it.

17:43.320 --> 17:46.320
And if you've ever used Prolog, this part is very similar.

17:47.480 --> 17:49.600
All right, and that's the entire language,

17:49.600 --> 17:50.920
the entire core language.

17:50.920 --> 17:52.960
There are basically three other operators

17:52.960 --> 17:56.600
that we might run into, but that's the basis of it, okay?

17:56.600 --> 17:57.700
Any questions?

17:59.520 --> 18:01.200
Who's playing along, by the way, I'm just curious,

18:01.200 --> 18:02.360
how many people?

18:02.360 --> 18:03.960
Oh, whoa, that's pretty good, all right.

18:03.960 --> 18:07.400
So now let's try something more complicated, all right?

18:08.480 --> 18:10.400
All right, let me keep myself honest,

18:11.360 --> 18:12.880
and check myself in.

18:14.040 --> 18:15.520
All right, and our programs are gonna become

18:15.520 --> 18:18.640
more complicated here, so the check-in thing will be a little,

18:18.680 --> 18:21.720
whoops, oh, I checked that in, it's five.

18:21.720 --> 18:26.120
Oh, here, I'll hack it, I'll put in a space,

18:26.120 --> 18:27.600
and check it in as six.

18:27.600 --> 18:32.600
Yes, I need to work on my get skills, that's fine.

18:35.600 --> 18:38.480
Oh, I need to push, yeah, thank you.

18:39.720 --> 18:44.720
Yeah, my dream tool would have me not have to do this step.

18:45.640 --> 18:48.480
All right, okay, so let's try

18:48.480 --> 18:50.280
something a little more interesting.

18:50.280 --> 18:53.360
So Phil was talking about Lambda Calculus yesterday,

18:53.360 --> 18:55.800
and he showed that there are three

18:55.800 --> 18:59.000
basically parts of Lambda Calculus, so you have variables,

18:59.000 --> 19:01.600
you have Lambda terms themselves,

19:02.840 --> 19:05.000
which are called abstraction in Lambda Calculus,

19:05.000 --> 19:06.560
and then you have application,

19:06.560 --> 19:08.400
applying something to something else.

19:08.400 --> 19:11.160
So we have these three things,

19:11.160 --> 19:13.000
and if I write down comments,

19:13.000 --> 19:14.440
hopefully Vanir will check on this,

19:14.560 --> 19:17.760
so we have, something like X is a variable,

19:19.680 --> 19:21.400
and then we have something like,

19:22.920 --> 19:25.440
I'm gonna write it in sort of like the schemely way,

19:25.440 --> 19:30.440
like Lambda X, Y, so that's an abstraction,

19:32.360 --> 19:37.360
ABS, and then you have something like an application,

19:37.760 --> 19:42.760
so we're applying F to G or something like that.

19:43.480 --> 19:46.240
So that's an application.

19:46.240 --> 19:48.880
So those are the three syntactic forms

19:48.880 --> 19:51.080
that we have in the Lambda Calculus.

19:51.080 --> 19:54.920
So let's try just writing something in mini-canon

19:54.920 --> 19:57.680
that will actually recognize

19:58.400 --> 20:01.560
a valid Lambda Calculus term syntactically.

20:01.560 --> 20:03.120
So let's just try doing that.

20:03.120 --> 20:05.680
So how should we do that?

20:05.680 --> 20:08.040
Well, we're gonna define a function,

20:08.040 --> 20:10.760
so this part is pretty much like scheme.

20:10.760 --> 20:12.560
Let's try defining a function,

20:12.680 --> 20:17.680
and so let's call this, I don't know,

20:17.880 --> 20:22.880
Lambda Calculus Syntax Syn, LC Syn, okay?

20:23.960 --> 20:28.760
And because we're in a schemely language,

20:28.760 --> 20:33.200
we're going to ourselves define this function using Lambda,

20:33.200 --> 20:35.320
and we're gonna give it some argument,

20:35.320 --> 20:38.920
so I'll say we're taking, well, under a term,

20:38.920 --> 20:41.680
Lambda Calculus term, okay?

20:41.680 --> 20:44.760
And now what we wanna do is basically match

20:44.760 --> 20:46.800
against the three possible terms.

20:46.800 --> 20:50.840
So which form do you think I should write here next,

20:50.840 --> 20:53.120
or which mini-canon operator?

20:54.040 --> 20:56.760
So I got, Kandee, Kandee,

20:56.760 --> 20:58.640
because I have choices to make, right?

20:58.640 --> 21:00.460
So I've got Kandee, and how many clauses

21:00.460 --> 21:02.440
am I gonna have for this Kandee?

21:02.440 --> 21:05.040
Three, okay, that's right.

21:05.040 --> 21:07.960
So I go ahead and write down my clauses to begin with,

21:07.960 --> 21:11.840
all right, and now what I'm gonna do

21:11.840 --> 21:14.480
is for each of my syntactic forms,

21:14.480 --> 21:17.800
I'm going to write down a clause for that, okay?

21:17.800 --> 21:21.800
So let's start with, I don't know,

21:24.480 --> 21:26.040
the application term.

21:26.040 --> 21:28.200
All right, let's do the Lambda term, actually.

21:28.200 --> 21:29.640
Okay, so what am I gonna write,

21:29.640 --> 21:31.920
what sort of mini-canon expression am I gonna write

21:31.920 --> 21:34.120
in that clause to match against the Lambda?

21:35.120 --> 21:36.760
I'm gonna write Kandee, I'm gonna write Fresh,

21:36.760 --> 21:38.920
I'm gonna write Equal Equal.

21:38.920 --> 21:41.400
What would I use for pattern matching, basically?

21:42.400 --> 21:43.240
Equal Equal, right?

21:43.240 --> 21:45.360
That's sort of like the two-way super pattern matcher.

21:45.360 --> 21:47.480
So let me write an Equal Equal expression,

21:47.480 --> 21:51.480
unification expression, and what am I gonna unify?

21:51.480 --> 21:55.640
I need two terms, two values, so I'll unify what?

21:59.480 --> 22:02.800
Term, okay, the term that came in, that's right,

22:02.840 --> 22:04.880
and I'm gonna unify that with,

22:04.880 --> 22:06.840
well, something that looks like my Lambda expression,

22:06.840 --> 22:08.280
right, I have to write something down

22:08.280 --> 22:10.600
that syntactically looks like it.

22:10.600 --> 22:13.600
Okay, so what I'm gonna do is I'm gonna just copy this thing.

22:18.280 --> 22:20.160
All right, and,

22:26.040 --> 22:27.920
ninja it a little bit.

22:27.920 --> 22:29.280
Oh, look at that, huh.

22:30.280 --> 22:33.360
Yeah, okay.

22:33.360 --> 22:37.680
All right, so that's kind of what my expression looks like.

22:37.680 --> 22:39.520
Now, there are a couple things here.

22:39.520 --> 22:41.960
So I've got like X as a variable,

22:41.960 --> 22:44.120
and this thing in the middle is really like

22:44.120 --> 22:48.520
the body expression, or E, or T, some other term, okay?

22:48.520 --> 22:51.280
So we got a variable, and we got some term here.

22:52.760 --> 22:57.440
And to make this schemely, we need to make this

22:57.440 --> 23:00.720
not a Lambda expression in many cannon or scheme

23:00.720 --> 23:03.360
in the host language, we need to make this a data structure

23:03.360 --> 23:05.600
that we can literally pattern match against.

23:05.600 --> 23:08.240
So we're gonna create a list,

23:08.240 --> 23:10.080
and the one way to do this in scheme

23:10.080 --> 23:14.680
was with this back tick operator called quasi quote,

23:14.680 --> 23:18.000
and it's sort of like a string interpolation style thing

23:18.000 --> 23:19.560
if you're familiar with that.

23:19.560 --> 23:24.560
Basically, if we put a comma in front of sub expressions,

23:25.320 --> 23:27.920
that means that these things here

23:27.920 --> 23:29.760
are gonna be literally filled in,

23:29.760 --> 23:31.520
they're like holes to be filled in,

23:31.520 --> 23:35.220
with whether the values of X and T are at that time.

23:36.360 --> 23:38.700
And we need to have some X's and T's here.

23:38.700 --> 23:42.000
So what I'm gonna do is I'm gonna create a fresh

23:42.000 --> 23:45.000
so I can have two new variables for X and T.

23:46.120 --> 23:48.240
Okay, so I'm creating two new logic variables,

23:49.320 --> 23:52.440
and I'm gonna grab that.

23:55.560 --> 23:59.440
And I might have to drag this even more.

24:00.800 --> 24:02.880
All right, there we go, perfect.

24:02.880 --> 24:07.480
Okay, so when we're writing these sorts of programs,

24:07.480 --> 24:10.560
it's good to try to test them sort of incrementally.

24:10.560 --> 24:14.560
So what I'm gonna do is I'm gonna temporarily comment out

24:14.560 --> 24:19.360
the first and the third clause with the comments and scheme,

24:19.360 --> 24:21.640
and I'm gonna just try running this thing

24:21.640 --> 24:22.900
to see if it works,

24:22.940 --> 24:24.420
because I'm not sure if it will,

24:24.420 --> 24:26.980
because I don't use veneer normally.

24:26.980 --> 24:28.900
So let's see if it works.

24:28.900 --> 24:32.500
Hash T, ah, cool, okay,

24:32.500 --> 24:33.620
because we didn't actually call it.

24:33.620 --> 24:37.320
So we can actually make a call to LC sin now.

24:37.320 --> 24:42.320
Let's try calling LC sin, and let's give it a term.

24:42.320 --> 24:47.320
So let's give it the term lambda z, z,

24:48.860 --> 24:50.720
and see if that succeeds.

24:50.720 --> 24:53.200
And it says yes, it does succeed.

24:53.200 --> 24:55.600
So this means that this is syntactically valid.

24:55.600 --> 24:57.480
Great, okay.

24:58.920 --> 25:03.480
So let me come up that in, or check that in.

25:04.640 --> 25:06.240
So here's our first version of it.

25:10.720 --> 25:13.600
And version seven.

25:14.760 --> 25:18.360
Okay, all right, and notice I could just test it

25:18.360 --> 25:19.440
one line at a time, right?

25:19.440 --> 25:21.480
So let's do the application line now.

25:22.640 --> 25:25.080
Okay, so here we're gonna have an application.

25:25.080 --> 25:26.880
Once again, I'm gonna wanna have a fresh

25:26.880 --> 25:28.980
to introduce some logic variables.

25:28.980 --> 25:30.560
I'll say e1 and e2.

25:31.600 --> 25:35.320
And the syntax of an application

25:35.320 --> 25:39.360
is that we have term e1 applied to term e2.

25:39.360 --> 25:41.160
And so that's what that looks like.

25:41.160 --> 25:46.160
And I'll go ahead and check that out.

26:01.280 --> 26:04.000
All right, so two thirds of the way done.

26:04.000 --> 26:05.200
And I could test that also,

26:05.200 --> 26:07.240
but I've got some confidence in it.

26:07.240 --> 26:11.040
So let's now do the last one, which is the variable x.

26:11.880 --> 26:15.240
And we're gonna represent a variable as a symbol

26:15.240 --> 26:16.960
and scheme, a scheme symbol.

26:16.960 --> 26:21.240
And so we've added to sort of the core logical foundations

26:21.240 --> 26:24.900
of many canron, a few constraints that make it easier

26:24.900 --> 26:26.760
for writing things like interpreters

26:26.760 --> 26:28.760
and type inferences and type checkers

26:28.760 --> 26:31.640
and grammar-based programs.

26:31.640 --> 26:34.920
And one of the constraints we have is called simbolo.

26:36.480 --> 26:40.760
So, simbolo, so if the term is a symbol,

26:41.280 --> 26:43.120
then we say, hey, that's a variable.

26:43.120 --> 26:45.320
That's syntactically legal.

26:45.320 --> 26:49.640
So simbolo is the last way we can represent.

26:49.640 --> 26:50.480
We're not actually saying,

26:50.480 --> 26:52.400
we don't care if it's x or y or whatever, right?

26:52.400 --> 26:54.200
But we care that it's a symbol.

26:54.200 --> 26:56.200
So let's see if that runs.

26:56.200 --> 26:58.200
Yes, okay, cool.

26:58.200 --> 27:02.680
And we can try if we want some other tests.

27:02.680 --> 27:07.480
So we could say, well, actually maybe it's lambda,

27:11.320 --> 27:16.320
z and z applied to z or something like that, okay?

27:16.800 --> 27:18.480
So we got an application,

27:18.480 --> 27:22.960
we have variable reference and we have a lambda.

27:22.960 --> 27:25.960
So let's see if that's syntactically valid.

27:25.960 --> 27:29.040
Yes, that's syntactically valid, okay?

27:29.040 --> 27:31.960
All right, so we've implemented our grammar

27:31.960 --> 27:33.760
and we've got all that stuff working

27:33.760 --> 27:35.440
and let me check that in.

27:36.440 --> 27:40.920
And this is check-in number nine.

27:42.680 --> 27:44.240
All right, cool.

27:44.240 --> 27:48.360
Now, okay, that's kind of cool that we can write that.

27:48.360 --> 27:52.360
But what would be more cool is if we can use

27:52.360 --> 27:54.800
those logic variables we've been using other places,

27:54.800 --> 27:55.840
if we could actually use that

27:55.840 --> 27:57.920
inside of our call to LC-SIN.

27:57.920 --> 28:00.120
So right now we're having to give a fully ground

28:00.120 --> 28:04.200
or fully specified lambda calculus term.

28:04.200 --> 28:06.960
And we're checking, we're verifying, validating that term

28:06.960 --> 28:09.160
and make sure it's syntactically legal.

28:09.160 --> 28:12.760
But it'd be really cool if we could instead

28:12.760 --> 28:16.920
put in a logic variable and say generate a valid lambda term.

28:16.920 --> 28:18.080
So let's try that.

28:18.080 --> 28:20.520
So I'm gonna get rid of that term.

28:20.520 --> 28:25.320
And I'm going to put in my term,

28:26.360 --> 28:30.240
or I don't know, I was called Q for a query variable, okay?

28:30.240 --> 28:34.440
So now I've got this query variable in place of the call.

28:34.440 --> 28:36.160
And let's try doing a run now.

28:37.920 --> 28:42.480
And so the first answer is yes.

28:42.480 --> 28:44.600
So we're getting back this underscore zero thing

28:44.600 --> 28:46.200
bound to Q, that's, if you remember,

28:46.200 --> 28:49.080
that's a representation of our fresh logic variable.

28:49.080 --> 28:50.840
And we have the side condition.

28:50.840 --> 28:52.280
The side condition is saying

28:52.280 --> 28:55.280
that that underscore zero thing has to be a symbol.

28:55.280 --> 28:58.400
So it has to be, if you were ever to instantiate it

28:58.400 --> 29:01.440
to a ground value, it would have to be a legal scheme symbol.

29:01.440 --> 29:04.000
And scheme symbols are how we're representing variables.

29:04.000 --> 29:06.960
So what this is saying is that any symbol, that's fine.

29:06.960 --> 29:09.200
That's just a lambda calculus variable.

29:09.200 --> 29:10.760
So that's actually representing

29:10.760 --> 29:12.560
infinitely many concrete values,

29:12.560 --> 29:14.640
infinitely many ground symbols.

29:14.640 --> 29:16.720
Now let's see if we can get another answer.

29:16.720 --> 29:20.000
Okay, here we're saying,

29:20.000 --> 29:23.640
ah, if we have a lambda term

29:23.640 --> 29:26.200
and it has the right structure,

29:26.200 --> 29:27.920
has parentheses and something, that's fine.

29:27.920 --> 29:30.080
And if it has something else in the back

29:30.080 --> 29:32.280
and could be different, that's fine.

29:32.280 --> 29:34.520
That's not very constrained.

29:34.520 --> 29:37.720
But okay, that's fine as far as it goes.

29:37.720 --> 29:38.960
What about this underscore zero thing?

29:38.960 --> 29:41.720
What should that be syntactically for this to be legal?

29:42.880 --> 29:43.720
Should be a symbol.

29:43.720 --> 29:45.720
Okay, so maybe we're a little sloppy.

29:45.720 --> 29:47.040
Let's go back.

29:47.040 --> 29:49.920
And so we can add a side condition maybe.

29:49.920 --> 29:52.120
Okay, so what else can I write here

29:52.120 --> 29:53.920
to kind of lock it down a little more?

29:54.640 --> 30:00.040
So I can do symbolic x, okay, and symbolic t.

30:00.040 --> 30:01.960
So do we know if t is actually a symbol?

30:01.960 --> 30:03.280
That's a good question.

30:03.280 --> 30:04.120
What is t?

30:06.160 --> 30:08.880
It's an arbitrary lambda calculus expression.

30:08.880 --> 30:10.520
So what do we need to write here?

30:12.640 --> 30:14.760
LC sin, yeah, we need recursion.

30:14.760 --> 30:16.760
LC sin on t.

30:16.760 --> 30:17.840
So that was part of the problem.

30:17.840 --> 30:19.120
We weren't recurring properly.

30:19.120 --> 30:21.320
Anything else you see that's wrong

30:21.320 --> 30:23.760
in those along the similar vein?

30:23.760 --> 30:25.560
Anywhere else where we were sloppy?

30:26.840 --> 30:27.760
Application, right?

30:27.760 --> 30:29.400
We have about these e1 and e2 things.

30:29.400 --> 30:31.160
We're not putting any structure on those.

30:31.160 --> 30:35.600
Those actually have to be lambda calculus terms themselves.

30:35.600 --> 30:37.720
So we need to recur.

30:37.720 --> 30:42.720
Okay, sin on e1, okay, LC sin on e2.

30:43.720 --> 30:46.720
All right, so hopefully that'll work.

30:46.720 --> 30:47.560
Let's see.

30:47.560 --> 30:50.320
Sin, okay, sin.

30:51.720 --> 30:53.200
Good, thank you.

30:54.760 --> 30:55.840
Ah, okay, cool.

30:55.840 --> 30:57.440
So let me paste that in.

31:02.600 --> 31:05.920
All right, so this is check-in number 10.

31:09.040 --> 31:11.320
All right, so if I run that, let's see.

31:11.320 --> 31:13.760
So we have the symbol answer like we had before.

31:15.120 --> 31:17.120
Ah, okay, so this looks better.

31:17.120 --> 31:20.200
So now when I get a second answer that I'm generating,

31:20.200 --> 31:21.480
it's like, okay, well, it still has

31:21.480 --> 31:22.960
that same structure we saw before,

31:23.000 --> 31:24.360
but now we have some side conditions.

31:24.360 --> 31:27.640
We're saying underscore zero has to be a symbol.

31:27.640 --> 31:31.160
And here we're saying the body is a symbol in that case.

31:31.160 --> 31:35.320
So this, and they could potentially be separate symbols,

31:35.320 --> 31:36.400
but they could be the same symbol.

31:36.400 --> 31:39.000
That's what having the underscore zero and underscore one means.

31:39.000 --> 31:40.760
So this could be lambda zed zed,

31:40.760 --> 31:43.040
or it could be lambda zed w or something like that.

31:43.040 --> 31:44.600
Those would both be legal.

31:44.600 --> 31:45.960
And I can ask for more.

31:45.960 --> 31:48.280
So here's an application where you have a symbol applied

31:48.280 --> 31:51.960
to a symbol, okay, and I can keep generating more of these.

31:51.960 --> 31:56.040
So here's a lambda whose body is another lambda, right?

31:56.040 --> 31:57.280
So now I can generate these

31:57.280 --> 32:00.360
and I can enumerate every possible lambda calculus terms

32:00.360 --> 32:01.360
and tactically, right?

32:02.600 --> 32:07.520
Okay, so that's basically the cool idea

32:07.520 --> 32:10.700
about pure logic programming.

32:10.700 --> 32:13.440
And many canons really language for pure logic programming

32:13.440 --> 32:15.880
where the idea is you can just write down

32:15.880 --> 32:18.040
mathematical specifications, something like that,

32:18.040 --> 32:19.640
and have something close to the math.

32:19.640 --> 32:21.720
And then once you have that,

32:21.720 --> 32:23.640
you can just use the same code,

32:23.640 --> 32:25.680
not just to check that something's correct,

32:25.680 --> 32:27.800
but also to generate answers.

32:29.240 --> 32:34.240
All right, so let's do this.

32:35.240 --> 32:38.880
Okay, so what I'm gonna do is I'm gonna refresh veneer.

32:40.920 --> 32:42.920
Just refresh the browser,

32:42.920 --> 32:44.900
make sure it's not in a goofy state.

32:44.900 --> 32:47.720
And you can see up top there are some different programs.

32:47.720 --> 32:50.840
So let's see if I try type inference.

32:50.840 --> 32:53.260
Okay, so if I go to type inference,

32:57.520 --> 33:02.520
you can see that we've got this mini canron definition

33:03.160 --> 33:07.800
called bang slash zero or dash zero or something, okay?

33:07.800 --> 33:08.800
What it's supposed to look like

33:08.800 --> 33:11.560
is a turn style operator in logic.

33:11.560 --> 33:13.840
It's supposed to look like one of those special symbols

33:13.840 --> 33:17.160
that you saw in Phil's presentation.

33:17.160 --> 33:19.760
So this is gonna be a type inferencer.

33:19.760 --> 33:23.120
And if you've ever used a language like ML, for example,

33:23.120 --> 33:24.960
you know what type inference is,

33:24.960 --> 33:26.800
you can write down the expression,

33:26.800 --> 33:28.840
and the type inferencer will try to figure out

33:28.840 --> 33:31.080
what the type of that expression is.

33:31.080 --> 33:33.880
So here we have three moving parts.

33:33.880 --> 33:37.880
We have the expression that we're gonna type infer.

33:37.880 --> 33:41.240
We have gamma, which is like a type environment,

33:41.240 --> 33:43.560
it allows us to accumulate information

33:43.560 --> 33:45.280
about the subparts of the expressions,

33:45.280 --> 33:46.320
what those types are.

33:46.360 --> 33:51.360
And then type is the type of that expression, all right?

33:51.480 --> 33:53.680
And you could see actually already

33:53.680 --> 33:55.320
what some of the similarities are.

33:55.320 --> 33:58.320
So symbolo expert, this is the symbol case,

33:58.320 --> 34:00.160
this is our variable case, right?

34:00.160 --> 34:01.640
And in this case, it's not just saying,

34:01.640 --> 34:03.720
well, that's it, you have a symbol.

34:03.720 --> 34:06.640
Now we're gonna look up in the type environment

34:06.640 --> 34:09.400
what that symbol is, what the type of that symbol is,

34:09.400 --> 34:12.280
because hopefully this is not a free variable,

34:12.280 --> 34:13.800
this is a bound variable.

34:13.800 --> 34:15.920
And we might know that that variable, for example,

34:15.920 --> 34:19.400
is bound to an int, has type int, okay?

34:19.400 --> 34:21.900
And there's some other cases, like for example,

34:21.900 --> 34:24.960
is the expression coming in a number?

34:24.960 --> 34:26.880
So number is another constraint.

34:26.880 --> 34:29.800
And if so, we're gonna say the type

34:29.800 --> 34:31.920
of that sub-expression is int, okay?

34:31.920 --> 34:32.760
That's our int type.

34:32.760 --> 34:34.800
So five would have type int.

34:34.800 --> 34:37.360
If it's a Boolean, like hashf in the scheme,

34:37.360 --> 34:39.920
it's gonna have type bool and so forth.

34:39.920 --> 34:44.360
And then we're also gonna have some more sophisticated rules

34:44.360 --> 34:47.560
for lambda, okay?

34:47.560 --> 34:51.400
And if you look at the lambda rule closely,

34:51.400 --> 34:53.720
and if you look at the math that Phil put up,

34:53.720 --> 34:58.560
or is in his paper, you'll notice that these rules

34:58.560 --> 35:00.320
essentially are the same, okay?

35:00.320 --> 35:01.640
So this is what he was talking about

35:01.640 --> 35:04.140
with the Curry-Howard isomorphism,

35:04.140 --> 35:07.720
and that basically we have a little theorem prover here

35:07.720 --> 35:10.040
in the form of a type inferencer.

35:10.040 --> 35:13.440
And similarly, we have application rule,

35:13.440 --> 35:15.800
and we also have a special version of let,

35:15.800 --> 35:18.280
and we have things like addition and so forth, okay?

35:18.280 --> 35:22.680
So let's just try doing something that says type inferencer.

35:22.680 --> 35:25.480
So here's an expression that it comes with,

35:25.480 --> 35:28.080
but let's try something simpler.

35:28.080 --> 35:30.960
So let's try calling our type inferencer,

35:30.960 --> 35:34.160
and we have to give it an initial type environment.

35:34.160 --> 35:36.000
And we're gonna say that that initial type environment

35:36.000 --> 35:36.840
is empty.

35:38.760 --> 35:41.200
And now we have to give it some expression,

35:41.200 --> 35:43.320
I don't know what that expression is gonna be,

35:43.320 --> 35:45.280
and then it's gonna have some type,

35:45.280 --> 35:48.280
and I will just write Q for the query variable for the type.

35:49.240 --> 35:52.240
So what's an expression that we might want to type check?

35:52.240 --> 35:55.400
Well, let's do something simple, like five.

35:55.400 --> 35:57.400
I'm putting a quote here, by the way,

35:57.400 --> 36:02.080
to make sure that whatever expression is here

36:02.080 --> 36:06.040
isn't evaluated at the host level, at the scheme level,

36:06.040 --> 36:08.840
but it's actually evaluated or looked at,

36:08.840 --> 36:12.060
that term is looked at in the type inferencer itself.

36:12.100 --> 36:13.660
So what should the type be here?

36:13.660 --> 36:15.140
What should the type of Q be?

36:17.980 --> 36:21.860
Should be an int, yeah, so that worked, it's an int, okay?

36:21.860 --> 36:26.260
And I can do something like plus, right?

36:26.260 --> 36:28.820
So plus three, four, what should the type of that be?

36:29.820 --> 36:33.060
That should be int, okay, sure enough, we got an int.

36:33.060 --> 36:38.060
What about plus hash f, four, what should the type of that be?

36:38.260 --> 36:42.060
Computer says no, all right, and we can also look

36:42.060 --> 36:44.060
at things like a lambda expression.

36:44.060 --> 36:47.060
What about lambda xx, which of the type of that be?

36:50.060 --> 36:53.060
Well, it should be equivalent to some sort of function type,

36:53.060 --> 36:56.060
right, so yeah, so we're gonna have something like a arrow a,

36:56.060 --> 36:59.060
and you can see that we have a fresh logic variable,

36:59.060 --> 37:01.060
arrow, fresh logic variable, so the thing on the left

37:01.060 --> 37:03.060
is the input type for the function,

37:03.060 --> 37:05.060
the thing on the right is the output type.

37:05.060 --> 37:07.060
The underscore zero means that this is a fresh variable,

37:07.060 --> 37:09.060
it means it could be anything,

37:09.060 --> 37:11.060
but the input and the output have to be the same

37:11.060 --> 37:13.060
because it's the identity function, okay?

37:13.060 --> 37:16.060
So this is a very general answer, all right?

37:16.060 --> 37:18.060
And we could try doing an application.

37:18.060 --> 37:23.060
We could try doing something like applying that lambda term

37:23.060 --> 37:28.060
to the value of plus three, four,

37:28.060 --> 37:30.060
and now what type should we get back?

37:31.060 --> 37:33.060
Should get back in it.

37:34.060 --> 37:36.060
Should get back in it, okay?

37:36.060 --> 37:38.060
Cool, all right, so that all works.

37:38.060 --> 37:40.060
So this is a working type inferencer,

37:40.060 --> 37:43.060
and for the most part we just kind of wrote down the rules,

37:43.060 --> 37:46.060
the math, you know, you could take the rules

37:46.060 --> 37:49.060
Phil showed and essentially type those in.

37:49.060 --> 37:52.060
Now where it gets more interesting is,

37:52.060 --> 37:55.060
and this is where the Curry-Howard part really becomes

37:55.060 --> 37:58.060
way more interesting to me, is that we can say,

37:58.060 --> 38:00.060
because we're in the logic programming domain,

38:00.060 --> 38:03.060
we can say that the type is going to be int

38:03.060 --> 38:07.060
and that we don't know what the input program is, right?

38:07.060 --> 38:10.060
So now we're going from type inference

38:10.060 --> 38:13.060
to type habitation or inhabitation.

38:13.060 --> 38:16.060
We're trying to find a term that inhabits this type, okay?

38:16.060 --> 38:20.060
So what would be a simple term that would have the type int?

38:20.060 --> 38:23.060
Zero, okay, sure.

38:23.060 --> 38:26.060
Well, zero is a little specific of an answer.

38:26.060 --> 38:28.060
We get back a more general answer that includes zero.

38:28.060 --> 38:30.060
So we're getting back some fresh logic variable

38:30.060 --> 38:32.060
with a side condition that has to be a number, okay?

38:32.060 --> 38:36.060
So that's zero, but it's also 42.

38:36.060 --> 38:38.060
Is there any distinction between numbers and integers

38:38.060 --> 38:40.060
and not supporting floating points?

38:40.060 --> 38:42.060
Okay, so good question.

38:42.060 --> 38:44.060
Are we supporting integers, floating points, so forth?

38:44.060 --> 38:48.060
Right now, in this one, we're only supporting positive integers.

38:48.060 --> 38:50.060
Actually, if we could probably do negative integers, I don't know.

38:50.060 --> 38:53.060
This one, yeah, I think this one works with negative integers, too.

38:53.060 --> 38:55.060
But, well, we could try that.

38:55.060 --> 38:59.060
See what the type of negative five is.

38:59.060 --> 39:01.060
But I think this is only handling integers.

39:01.060 --> 39:03.060
But we could add other constraints

39:03.060 --> 39:05.060
that would handle other numeric types.

39:05.060 --> 39:08.060
Oh, okay, it doesn't like negative five, I guess.

39:08.060 --> 39:11.060
So I guess number O in this implementation

39:11.060 --> 39:14.060
only handles non-negative integers.

39:14.060 --> 39:16.060
But you could add more things.

39:16.060 --> 39:20.060
In fact, when I worked with Eric Holk and Claire Alvis

39:20.060 --> 39:24.060
on this language called Harlan,

39:24.060 --> 39:28.060
the original version of Harlan is sort of like a schemely language

39:28.060 --> 39:30.060
for GPU programming,

39:30.060 --> 39:34.060
but it had like an ML-style type system.

39:34.060 --> 39:40.060
And the original type inferencer for that was written in C Canron.

39:40.060 --> 39:43.060
And we had to extend these operators

39:43.060 --> 39:45.060
to handle different types of numbers.

39:45.060 --> 39:48.060
So you can do that. You just have to add other constraints.

39:48.060 --> 39:51.060
Okay, so what else can we do here?

39:51.060 --> 39:54.060
What other sorts of things should we get back

39:54.060 --> 39:56.060
other than just a literal number?

39:56.060 --> 39:58.060
Well, let's see what many Canons says.

39:58.060 --> 40:01.060
So here we have a let.

40:01.060 --> 40:05.060
So we're saying let some variable, which is a symbol,

40:05.060 --> 40:08.060
which has some number value.

40:08.060 --> 40:10.060
It doesn't matter what it is, because we're ignoring it,

40:10.060 --> 40:13.060
and the body of the let is some other number.

40:13.060 --> 40:15.060
Okay, well, that's true. That has type in.

40:15.060 --> 40:18.060
And it's well-typed. It's the type checks, right?

40:18.060 --> 40:19.060
And here's another one.

40:19.060 --> 40:23.060
So here we're saying let some variable, the symbol, be hash f.

40:23.060 --> 40:24.060
We're ignoring that.

40:24.060 --> 40:26.060
We're returning the body, which is underscore one,

40:26.060 --> 40:28.060
and that has to be a number.

40:28.060 --> 40:30.060
And so we could play these games.

40:30.060 --> 40:35.060
And at some point, okay, so now we get an addition of two numbers.

40:35.060 --> 40:37.060
And here, now we start getting into applications.

40:37.060 --> 40:40.060
So we're getting a lambda term, a lambda expression,

40:40.060 --> 40:42.060
and it's being applied to something.

40:42.060 --> 40:43.060
So let's make sure the types work.

40:43.060 --> 40:44.060
So we're passing in a number.

40:44.060 --> 40:46.060
That's our constraint.

40:46.060 --> 40:48.060
And here we have some symbol.

40:48.060 --> 40:49.060
And we're ignoring what's passed in,

40:49.060 --> 40:53.060
and we're returning some other potentially different number.

40:53.060 --> 40:58.060
So you can play these games all day.

40:58.060 --> 41:00.060
And yes, you get.

41:00.060 --> 41:03.060
You can keep clicking more answers for as long as you want.

41:03.060 --> 41:05.060
All right, I'm going to refresh one more time.

41:05.060 --> 41:10.060
And I'm going to show you something that's a little more fancy.

41:10.060 --> 41:12.060
But by the way, that type inference stuff,

41:12.060 --> 41:14.060
or the type inhabitation,

41:14.060 --> 41:20.060
that is the thing that many of the modern proof assistants work on.

41:20.060 --> 41:22.060
Okay, I'm going to be Dijkstra in two minutes,

41:22.060 --> 41:25.060
but I'm going to go ahead and show you very quickly

41:25.060 --> 41:27.060
what you can do with a relational interpreter.

41:27.060 --> 41:32.060
So here we have an interpreter for a significant subset of scheme.

41:32.060 --> 41:34.060
It's basically our extended lambda calculus,

41:34.060 --> 41:36.060
if you want to look at it that way.

41:36.060 --> 41:40.060
And so we have this, a val expo thing.

41:40.060 --> 41:43.060
And so we can evaluate an expression.

41:43.060 --> 41:47.060
I think we have something called, yeah, a val expo.

41:47.060 --> 41:50.060
And let me just show you one query to a val expo,

41:50.060 --> 41:52.060
and hopefully this will work.

41:52.060 --> 41:55.060
So we're going to call a val expo.

41:55.060 --> 41:58.060
And a val expo takes, sort of like the type inference,

41:58.060 --> 42:07.060
it's going to take an expression and an environment and then an output.

42:07.060 --> 42:10.060
So we're going to say, we've got some expression we don't know.

42:10.060 --> 42:12.060
We're going to start in the empty environment.

42:12.060 --> 42:16.060
And we want to see if we can create some expression,

42:16.060 --> 42:20.060
find some expression that in the empty environment evaluates to itself.

42:20.060 --> 42:23.060
Well, let's see if we can do that.

42:23.060 --> 42:27.060
Whoa, what is that thing?

42:27.060 --> 42:29.060
Well, that's kind of weird.

42:29.060 --> 42:33.060
Okay, so we got this weird looking thing.

42:33.060 --> 42:38.060
And let me just go to Emacs and start up scheme.

42:38.060 --> 42:41.060
I'm going to try to type that in.

42:41.060 --> 42:45.060
Format it in ways a little easier to understand.

42:45.060 --> 42:47.060
I'm going to try running that.

42:47.060 --> 42:50.060
Oh, wow, I got back the same thing.

42:50.060 --> 42:52.060
So that's called a quine.

42:52.060 --> 42:55.060
That's a program that evaluates to itself.

42:55.060 --> 42:59.060
And by the way, if you look at, you know,

42:59.060 --> 43:02.060
here's my last comment that I'll make that's historical.

43:02.060 --> 43:09.060
If you look at the micro manual for Lisp by John McCarthy,

43:09.060 --> 43:16.060
he says, it's a difficult mathematical type challenge exercise right here.

43:16.060 --> 43:20.060
Find the list E such that the value of E is equal to E.

43:20.060 --> 43:24.060
And that's what we just did by typing in the rules for scheme

43:24.060 --> 43:27.060
and letting many canren do it.

43:27.060 --> 43:29.060
So I hope you'll have fun playing with it.

43:29.060 --> 43:31.060
And if you have any questions, I'm happy to answer them.

43:31.060 --> 43:33.060
Thank you.

