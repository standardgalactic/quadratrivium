1
00:00:00,000 --> 00:00:06,560
Hello. Welcome to today's coding challenge. In today's coding challenge, I am going to

2
00:00:06,560 --> 00:00:13,080
attempt to program this, the game of life cellular automaton in JavaScript. I'm going

3
00:00:13,080 --> 00:00:18,200
to use the P5.js framework. What's running right here right now is a processing example

4
00:00:18,200 --> 00:00:22,120
using the Java programming language that I made several years ago as part of the nature

5
00:00:22,120 --> 00:00:26,680
of code book. Now, if you're interested in that, you can also look at my whole playlist

6
00:00:26,680 --> 00:00:32,680
about this thing that I can't pronounce called cellular automata, the plural of automaton.

7
00:00:32,680 --> 00:00:36,800
And I do have some videos that give you some historical background and looking at different

8
00:00:36,800 --> 00:00:43,280
Wolfram's elementary CA and some exercises and things. But I'm really just showing examples

9
00:00:43,280 --> 00:00:48,040
and talking about the systems in those videos. In this video, I'm going to try to just start

10
00:00:48,040 --> 00:00:53,360
from no code and finish with the simulation. Hopefully it's going to work. It generally

11
00:00:53,440 --> 00:00:59,640
doesn't, so don't get your hopes up. But I would encourage you to do some background

12
00:00:59,640 --> 00:01:07,560
reading. This is the first sort of public appearance of the game of life as created

13
00:01:07,560 --> 00:01:13,800
by John Conway, a mathematician from an article in Scientific American in 1970 by Martin Gardner.

14
00:01:13,800 --> 00:01:18,040
Of course, you can always refer to the Wikipedia page. I'm going to need this, which is going

15
00:01:18,040 --> 00:01:22,720
to, which outlines the rules for how the system behaves. And you can also think that there's

16
00:01:22,760 --> 00:01:28,040
a lot of possible stuff. There's all these kinds of interesting, repeating patterns and

17
00:01:28,040 --> 00:01:32,600
different types of things that you can create and do with the game of life simulation. But

18
00:01:32,600 --> 00:01:37,000
I'm going to program a simple version of it. Hopefully that will happen. Then at the end,

19
00:01:37,000 --> 00:01:40,360
I'll talk about some variations that you might think about. And maybe someday I'm going to

20
00:01:40,360 --> 00:01:45,640
try to like make one in 3D or something like that. Okay, so let's get started. Here's what

21
00:01:45,680 --> 00:01:53,680
we need. A cellular automaton is a system of cells that exist in a grid. It could be

22
00:01:53,680 --> 00:02:00,160
in one dimension, two dimensions, three dimensions. The game of life system is one that exists

23
00:02:00,160 --> 00:02:07,160
in two dimensions. And the idea is that you have generations. So if this is generation

24
00:02:08,440 --> 00:02:14,040
zero, I'm going to run some computation on the system of cells on a grid, and then I'm

25
00:02:14,080 --> 00:02:21,080
going to have a new set of cells on that grid. And that's going to be generation one. So

26
00:02:24,720 --> 00:02:30,480
the cells that exist on that grid all have a state. That's part of a CA system. So that

27
00:02:30,480 --> 00:02:35,320
state could be a floating point number. It could be a kind of animal. You could really

28
00:02:35,320 --> 00:02:38,240
imagine in a lot of different ways. I'm going to do something very simple with the game

29
00:02:38,680 --> 00:02:44,280
of life is a simple system of discrete states, two states, zero or one, on or off, alive

30
00:02:44,280 --> 00:02:51,280
or dead. So you could imagine a configuration of this being something like this. And for

31
00:02:53,200 --> 00:03:00,200
each time, each tick, each generation, each frame of animation, I evaluate each cell one

32
00:03:01,360 --> 00:03:08,120
by one and get a new state based on the previous state. So let's say I'm trying to do this

33
00:03:08,200 --> 00:03:13,680
cell. I need this cell's new state. I'm going to get a new state based on this state and

34
00:03:13,680 --> 00:03:18,160
its neighbors. So what are its neighbors? That's up to us to find. It could be its left

35
00:03:18,160 --> 00:03:22,760
neighbor, its right neighbor. It's only its neighbors to its left. But in the game of

36
00:03:22,760 --> 00:03:28,560
life system, its neighborhood are the eight cells surrounding it. So it's this three by

37
00:03:28,560 --> 00:03:33,600
three area, one, two, three, four, five, six, seven, eight. So I need to evaluate all those

38
00:03:33,600 --> 00:03:39,800
cells and decide whether it should stay as a zero or turn into a one. And the reason

39
00:03:39,800 --> 00:03:46,800
why it's called the game of life is the rules. The rules for how we move from one generation

40
00:03:47,600 --> 00:03:54,320
to another resembles some type of like biological process that you might think about population

41
00:03:54,320 --> 00:04:00,120
or bacterial growth. And the idea is that a cell that is surrounded by neighbors that

42
00:04:00,120 --> 00:04:06,480
aren't alive cannot stay alive. A cell surrounded by neighbors that are alive can come to life

43
00:04:06,480 --> 00:04:11,560
or stay alive. And a cell that's surrounded by too many neighbors cannot stay alive due

44
00:04:11,560 --> 00:04:16,800
to overpopulation. And we can go back to the Wikipedia page and read those rules precisely

45
00:04:16,800 --> 00:04:23,800
right here. So any live cell with fewer than two neighbors dies as if caused by underpopulation.

46
00:04:24,520 --> 00:04:28,760
Any live cell with two or three neighbors lives onto the next generation. Any cell with

47
00:04:28,760 --> 00:04:33,960
more than three neighbors dies by overpopulation. And any dead cell with exactly three, three

48
00:04:33,960 --> 00:04:38,200
live neighbors becomes a live cell. So this is written as if by reproduction. So this

49
00:04:38,200 --> 00:04:42,800
is written in a somewhat of a confusing way. I think I could simplify this. I think we

50
00:04:42,800 --> 00:04:49,800
could say like, let's say the cell is dead. It's a zero. It's only going to change to

51
00:04:50,080 --> 00:04:57,080
a one if it has three live neighbors. Then it changes to a one. Otherwise it stays a

52
00:04:57,080 --> 00:05:04,080
zero. A one is going to stay a one unless it has less than two, less than two live and

53
00:05:07,320 --> 00:05:14,320
greater than three live. Then it dies. So birth reproduction happens with exactly three

54
00:05:17,040 --> 00:05:23,480
neighbors. Death happens with fewer than two or greater than three. Now I don't know if

55
00:05:23,520 --> 00:05:30,520
I got those numbers right. Let's go check the Wikipedia page again. Thank you. Thank you.

56
00:05:30,520 --> 00:05:37,520
I hit the sound effect by accident. Live cell with fewer than two live neighbors dies. Yes,

57
00:05:39,440 --> 00:05:44,160
less than two dies. Live cell with two or three neighbors lives. I don't care about

58
00:05:44,160 --> 00:05:47,600
that. I'm not going to kind of not care about change. Then it stays the same. I can kind

59
00:05:47,600 --> 00:05:52,400
of ignore that. Live cell with more than three neighbors dies. Yep. That's what I've got

60
00:05:52,440 --> 00:05:58,440
over there. Then any dead cell with exactly three live neighbors becomes alive. Okay,

61
00:05:58,440 --> 00:06:02,520
so I've got those rules correct. So now, what do I need? Hello, you're over there. I'm

62
00:06:02,520 --> 00:06:08,120
going to go back over here. I need something. All I need to make this program work is a

63
00:06:08,120 --> 00:06:13,200
data structure to store this grid. This is where I'm kind of having like a bit of a

64
00:06:13,200 --> 00:06:18,040
headache and I'm really not sure what to do. The way that I've always done this in previous

65
00:06:18,040 --> 00:06:21,560
examples is by using something called the two dimensional array. I think I have a video

66
00:06:21,600 --> 00:06:26,960
tutorial about that somewhere, which I will link to in this video's description. But two

67
00:06:26,960 --> 00:06:31,120
dimensional arrays are kind of not so much fun in JavaScript. They can become a little

68
00:06:31,120 --> 00:06:34,600
bit weird and there really is no such thing as a two dimensional array. A two dimensional

69
00:06:34,600 --> 00:06:40,080
array is a construct of our own human mind saying like it's really just an array of arrays,

70
00:06:40,080 --> 00:06:45,400
which makes sense. This is an array, you know, each row is an array and then the grid is

71
00:06:45,400 --> 00:06:49,400
an array of rows or each column is an array and the grid is an array of columns. So I

72
00:06:49,440 --> 00:06:52,680
think I'm going to do it that way with a two dimensional array. I just should say that it's

73
00:06:52,680 --> 00:06:56,560
a little bit awkward two dimensional arrays in JavaScript, but I'm going to go ahead anyway.

74
00:06:56,560 --> 00:07:01,600
So the first thing that I want to do in this program is just make a two dimensional array

75
00:07:01,600 --> 00:07:09,600
that stores a random collection of zeros and ones. So let's go do that. I'm going to go to the

76
00:07:09,600 --> 00:07:14,600
code and you know what I'm going to do? I'm going to actually just write a function. I'm having

77
00:07:14,600 --> 00:07:18,600
like weird deja vu. I probably did this in another video somewhere. I'm going to just write a

78
00:07:18,640 --> 00:07:23,720
function called make two D array and I want a certain number of columns and rows. Okay,

79
00:07:23,720 --> 00:07:29,480
because that way I can just say, I can have a global variable called the grid. I'll call it

80
00:07:29,480 --> 00:07:36,280
grid. And I could just say grid equals make two D array. And I could say I want a 10 by 10 grid.

81
00:07:36,280 --> 00:07:40,560
So this is kind of what I want to do. I'm going to just farm out the making of the array to

82
00:07:40,560 --> 00:07:45,680
another function. And oh, I know I do remember doing this because I'm going to write this in a

83
00:07:46,640 --> 00:07:51,200
whole coding challenge or video. I'm going to do this in a kind of horrific way. And then

84
00:07:51,200 --> 00:07:55,640
everyone's going to give me all these amazing ES6 JavaScript fancy ways of doing this whole

85
00:07:55,640 --> 00:08:04,080
function in one line of code. So I'm going to come back and do that. Okay, so now let me see

86
00:08:04,080 --> 00:08:10,560
here. So what I need to do is first is I need to have some sort of array. And it's going to be,

87
00:08:11,400 --> 00:08:20,960
it's going, this is always where I get confused too. Do I want the columns? The point of using a

88
00:08:20,960 --> 00:08:24,960
2D array is that eventually at some point I'm going to be able to say something like grid,

89
00:08:24,960 --> 00:08:34,280
you know, index two, index three. And I guess I usually think of this as x and y and x being the

90
00:08:34,280 --> 00:08:40,560
columns. So I want this, the outer array, if I'm thinking about arrays of arrays, to be every

91
00:08:40,560 --> 00:08:49,240
single column. Every single, no, no, that's what x is column, right? And then the y is everything

92
00:08:49,240 --> 00:08:59,000
over. Okay, so I'm going to do that. So I'm going to make a new array of columns. And then I am

93
00:08:59,000 --> 00:09:09,720
going to say four, let i equals zero, i is less than that array dot length, i plus plus, make a

94
00:09:09,720 --> 00:09:18,760
array index, i is a new array of rows. Again, I know there are all sorts of shorter and fancier

95
00:09:18,760 --> 00:09:23,840
automatic functions for generating and configuring arrays like fill and map and reduce and all that

96
00:09:23,840 --> 00:09:33,200
kind of stuff, even more. So I'm going to do this. And then I am going to, what I want to do here now

97
00:09:33,200 --> 00:09:44,760
is I also want to fill them with, I guess I could fill it with values down here. So maybe I won't,

98
00:09:44,760 --> 00:09:49,400
maybe I'll actually just do that. So this is going to make me an empty 2D array with nothing in it.

99
00:09:50,200 --> 00:10:01,640
And then I think what I want is, I probably want to have these global variables. I know this is a little bit

100
00:10:01,640 --> 00:10:10,960
goofy that I'm doing this. And then what I'm going to do, I could make a, and I'm going to say let i

101
00:10:10,960 --> 00:10:21,920
equals zero, i is less than columns, i plus plus. And then I'm going to do j is less than zero, j is less

102
00:10:21,920 --> 00:10:34,360
than rows. I'm going to do a nested loop so that I can say grid i, j equals floor random two. This is going

103
00:10:35,360 --> 00:10:42,160
to give me a nested loop, this is a nested loop. So I make this sort of like 2D array structure that's

104
00:10:42,160 --> 00:10:48,840
empty. And then I iterate over every single column and every single row. And I fill each one with a random

105
00:10:48,840 --> 00:10:56,960
number zero or one. And I'm just, now I'm going to run this. And I'm going to go back to, I'm going to go to my

106
00:10:56,960 --> 00:11:05,440
code. Okay, cannot read property zero of undefined. Well, you know what would be nice if I actually return that

107
00:11:05,440 --> 00:11:12,040
array. So they make 2D a function array. It's making this array. It's also got to return it so that I can get it back

108
00:11:12,040 --> 00:11:19,560
here. And then now if I look at grid, I'm going to see it's an array of arrays. And I forgot there's this wonderful

109
00:11:19,560 --> 00:11:29,360
thing you can do like console.table grid, which shows me now I can see it here. So we can see this is that two

110
00:11:29,360 --> 00:11:34,720
dimensional array. That's what it looks like. It's a two dimensional array with rows and columns filled with zeros and

111
00:11:34,720 --> 00:11:45,880
ones. So step one is finished. Now what I need to do is I need some mechanism to every frame of animation

112
00:11:45,880 --> 00:11:52,400
iterate over every single spot and set a new spot. Actually, you know what I should do first? I need to render this

113
00:11:52,400 --> 00:12:00,080
thing. I want to be able to see it as a grid of red and blue squares or black and white squares or zeros and ones of

114
00:12:00,080 --> 00:12:05,200
the screens, any number of ways you could render this. I'm going to do it in the traditional way of a grid, the

115
00:12:05,200 --> 00:12:11,880
square, the cell of the grid is black at the value of zero is white at the value of one or vice versa. Okay, what I

116
00:12:11,880 --> 00:12:21,600
want to do now is I'm going to add a draw function. And I'm going to be using this loop over and over again. I'm going to

117
00:12:21,600 --> 00:12:27,840
add this loop. Right, because I'm always going to anytime I want to look at everything, I'm going to go through all the

118
00:12:27,840 --> 00:12:34,160
columns and all the rows. It's been pointed out in the chat that there are some JavaScript libraries and packages that

119
00:12:34,160 --> 00:12:39,400
manage grid systems and neighbors for you. It'd be great to use those. I'm going to just do it all without that right now

120
00:12:39,400 --> 00:12:48,040
just to kind of like figure it out. I'm going to say background zero. And I'm going to create a canvas. I think to make my

121
00:12:48,040 --> 00:12:56,640
life easier for the moment, I'm going to make the canvas also a square. And then what I need to do is I need to draw I want to

122
00:12:56,640 --> 00:13:04,880
draw a rectangle add an x and a y with some width and height. And it's going to they're going to be squares. So some width

123
00:13:04,880 --> 00:13:18,560
and width. And that value is going to be the width of the I should probably calculate the number of columns and rows. Here's the

124
00:13:18,560 --> 00:13:25,600
thing. I'm going to redo the way that I'm doing this. So I'm not going to actually have a fixed number of columns and rows. I'm

125
00:13:25,600 --> 00:13:33,200
actually going to do like a scale or I'm just going to have a variable called resolution. I'm going to say that's 10 or 40. I'm

126
00:13:33,240 --> 00:13:43,240
going to say that's 40. So that'll be 10 by 10. And what I'm going to do is I'm going to say columns equals the width of the

127
00:13:43,240 --> 00:13:51,440
canvas divided by resolution, rows equals the height of the can canvas divided by resolution. This way I can kind of

128
00:13:51,440 --> 00:13:59,160
dynamically you'll see what I can dynamically make a 2d array based on how big I want the squares to be so the columns and rows are

129
00:13:59,160 --> 00:14:04,920
being calculated based on how big I want the squares to be and the canvas size. And then I have that global variable

130
00:14:04,920 --> 00:14:15,960
resolution, which is probably too long of a name, which I can just use down here. And now x equals I times resolution and y

131
00:14:15,960 --> 00:14:32,720
equals j times resolution. And I'm going to now say if grid i j equals one, fill 255. And you know, since I made the background

132
00:14:32,720 --> 00:14:40,440
zero, I can actually, in this case, I can just draw wreck white rectangles only for the values of one. So let's see, I probably got

133
00:14:40,440 --> 00:14:46,840
something wrong here, but let's try to run this. No, I didn't. So we can see there we go now there's some goofiness like oh, it's

134
00:14:46,840 --> 00:14:55,920
sort of like my math is a little off and I what's this weird like nonsense over here flickering. I kind of feel the need to fix

135
00:14:55,920 --> 00:15:08,360
that. And the other thing that I can do that this is going to help is if I make this 600 by 400, and I make this like 20. Right, it

136
00:15:08,360 --> 00:15:16,800
still works. And now this is driving me crazy. I think what I want to do is it's there's a sort of issue with the stroke. So I could

137
00:15:16,800 --> 00:15:24,680
say I could also say stroke 255. And then I'm getting something like this. But I don't know design wise, I'm not going to worry about that

138
00:15:24,680 --> 00:15:31,600
too much. Actually, I kind of like being able to see the grid. So let me actually put in stroke zero. And then I'm going to do

139
00:15:31,600 --> 00:15:41,880
something kind of goofy, which is I think if I say just draw the all the rectangles like one pixel less. Whoops. I think I'm going

140
00:15:41,880 --> 00:15:48,400
to get the look that I want. Yeah. So whatever there's countless ways I could deal with this. But now I have I have the grid, I have

141
00:15:48,400 --> 00:15:59,240
all the cells. So now it's up to me to simply implement these rules. I need to for every single cell count the number of live

142
00:15:59,280 --> 00:16:10,080
neighbors, look at its own state and have these rules play out. Here's the thing. This is really important. While I'm checking each cell, I

143
00:16:10,080 --> 00:16:19,520
check this cell first, let's say, I cannot change its value, and then go on and check the next cell, because the next cell's new

144
00:16:19,520 --> 00:16:25,240
state should not be dependent on this cell's new state, but it's previous state. And if I've changed a state, I've lost its old

145
00:16:25,240 --> 00:16:34,600
state. So this is where what I actually need is I need two two dimensional arrays. One is the sort of old one. And one is the new

146
00:16:34,600 --> 00:16:44,400
one. Now, probably the simplest thing for me to do is just make a new one every frame. That's sort of like, in some ways, a bad idea in terms

147
00:16:44,400 --> 00:16:50,360
of memory management. And if you look at my processing example that I referenced at the beginning of this video, what I actually do in

148
00:16:50,360 --> 00:16:55,880
that example is I just have two different arrays. I have an old one, and then I have a new one. Then the new one is then the old

149
00:16:55,880 --> 00:17:00,640
one. And I write the new one over here, I just keep swapping them. So I could maybe add that in at some point during this video.

150
00:17:00,680 --> 00:17:06,520
But for right now, at the beginning of draw, I'm just always going to make a new generation. At the beginning, what I can do here.

151
00:17:08,840 --> 00:17:19,080
Why does that keep happening? When I press the button to change the camera? At the beginning of draw, I can say let next for next

152
00:17:19,080 --> 00:17:32,240
generation equal make 2D array columns and rows. Okay, now I'm going to leave this here for the rendering. And what I'm actually going to do is at

153
00:17:32,240 --> 00:17:44,360
the end, what I'm going to do is I'm going to say, I guess it doesn't really matter. Do I want to like render first? This is kind of like a

154
00:17:44,360 --> 00:17:51,200
philosophical, deep philosophical question. Do I want to compute and then render or render and then compute kind of could matter in some

155
00:17:51,200 --> 00:17:56,120
situations. This matter in the situation doesn't really matter. But what I what I the reason why is like I'm never going to see the first

156
00:17:56,120 --> 00:18:08,240
generation, because what I want to do is say grid equals next. So basically, the algorithm here is compute next, based on grid, because

157
00:18:08,240 --> 00:18:16,880
draw is looping. So I want to compute the next generation based on the grid, make grid that render, and then compute the next generation based

158
00:18:16,880 --> 00:18:24,640
on grid make grid that render. So I don't know that's bothering me. I'm going to do this. I'm going to do this after. So at least I draw the first

159
00:18:24,640 --> 00:18:33,440
one and I'm going to do some computation for the next frame. Okay, okay. So now what do I need to do once again, loop through all of

160
00:18:33,440 --> 00:18:49,080
these loop through all of these. Now what I need to do is count live neighbors. I need to count the number of live neighbors, the neighbors

161
00:18:49,080 --> 00:18:59,840
that have one. So I could do a kind of internal loop here. And that would probably be a smart thing to do. Maybe I will do that. Where

162
00:18:59,840 --> 00:19:07,720
basically what I do is I say I have a certain I'm at a certain cell. Let me look at the cells between negative one and one and negative one and

163
00:19:07,720 --> 00:19:18,200
one offset from where I am. I could also just do something really silly like let me do the really silly thing first. I could say let

164
00:19:18,200 --> 00:19:34,280
sum equals zero. Then I could say sum plus equal grid i minus one j. That would be the neighbor to the so right. If this is i comma j i minus

165
00:19:34,280 --> 00:19:44,000
one comma j is there i minus one j minus one i j minus one that sort of thing. So if I'm thinking about this, I might like add go I could

166
00:19:44,000 --> 00:20:02,360
just like manually put in all the neighbors. Just like add them all up. This is like going around the horn here. Right. Plus i plus one j plus one. I sometimes I like doing

167
00:20:02,360 --> 00:20:13,440
ridiculous things like this just to figure this stuff out. Now I got to go i minus one j plus one. And then what's the last one i minus

168
00:20:13,680 --> 00:20:31,840
one j. This should be eight neighbors. Right. This is eight neighbors. One two three four. Oh wait. One two three four five six seven. What did I forget? I

169
00:20:31,840 --> 00:20:51,520
minus one j minus one i j minus one i plus one j minus one. Forgot to do that whole top row. And then i plus one j i plus one j plus one i yeah. So this should now be

170
00:20:51,520 --> 00:21:01,720
eight. One two three four one two three four. Okay. I kind of hate that I did this. Throwing your tomatoes at your television screen because of

171
00:21:01,720 --> 00:21:10,240
course you're all watching this on the television screen. So this is the idea. I need to add up all those neighbors. Let's do this in a loop. So another way I could do it is I could

172
00:21:10,240 --> 00:21:28,760
say you have a better idea. Let's neighbors I have a better idea. Let's write a function to do this. Neighbors equals count. I'm going to give it the grid and I'm going to give it the i and the j. So I'm

173
00:21:28,760 --> 00:21:42,240
going to write a function. I'll put it all the way at the bottom of my code that receives. I'm going to call it count. Account neighbors. Let's call it. And it's going to receive some 2D array. And it's going to

174
00:21:42,240 --> 00:21:58,480
receive an x and a y location. And then what I'm going to do is I'm going to say i equals negative one i is less than two i plus plus. Then so I'm going to do a little nested loop using i and

175
00:21:58,480 --> 00:22:20,280
j around that spot. And I'm going to say let some equals zero. And then I'm going to say some plus equals grid i j. However, here's a problem. I don't want to count myself as a neighbor. So there's a few

176
00:22:20,280 --> 00:22:27,840
different ways I could do this. But it's a little bit silly. I'm just going to like subtract it at the end. Like I'll just subtract it out. I could have like put an if

177
00:22:27,840 --> 00:22:38,040
statement here, like ignore it if i equals x and j equals x. But I'm just going to subtract it out at the end. And then I'm going to return that sum. So this is you could see like a couple of

178
00:22:38,040 --> 00:22:48,920
different ways of doing this right now. This is one way to kind of do this. What this is doing is it's saying let me do a little loop around here negative one zero positive one negative one zero positive

179
00:22:48,920 --> 00:23:03,000
one. So let me check this this this and then subtract this out because I don't really want to count that one. Okay, so now I should be able to I'm going to just delete this. I've now counted all of the neighbors. I've got a big

180
00:23:03,000 --> 00:23:16,360
problem. What do I do with the fact that if I'm on the edge, there's no neighbor to the left. If I'm on the bottom, there's no neighbor below. If I'm the top, there's no neighbor to the

181
00:23:16,360 --> 00:23:26,880
above. If I'm the right, there's no name. If I'm on the edge, there's no neighbor to the right. So what I could do, there's a bunch of things I could do. I could consider this like an infinite wrap around world. We're like this neighbor to the right is

182
00:23:26,880 --> 00:23:45,280
this this neighbor to the left is this. I could there's other ways that I could approach it. What I'm going to do is I'm going to leave the edges as fixed values and just not bother to check them. Which is I so what I'm going to do here is I am

183
00:23:45,280 --> 00:24:02,160
going to I wanted to do like I was going to do this loop like this. You know what? Let's do the wrap around. Do I dare? No, no, no, let's do it the simple way first. I was like, I'll just add the wrap around code because I could add the wrap around

184
00:24:02,160 --> 00:24:28,360
code here. But I'm going to let me I'll maybe I'll leave that as an exercise or do that later. The issue is, you know what I really want? I think then what I want? The problem is if I change this loop, so I have to I have to treat the edges differently. Oh, so much so much heartache here. But I can say what I'm going to do here is I'm going to say, Oh, this is the drawing.

185
00:24:28,360 --> 00:24:55,800
Whoa, all right, this is the compute computation. So I'm going to say if I equals zero or I equals columns minus one minus one or J equals zero or J equals rows minus one. These are this is like all of the edges. I'm just going to treat them differently.

186
00:24:59,200 --> 00:25:19,280
I'm going to say next I J equals grid I J. So I'm just going to keep the same values from before. This is not a great solution, but it's a quick one that I can do right now. So I'm if I'm on an edge, I'm just going to use the same value.

187
00:25:20,280 --> 00:25:40,800
Because now what I can do is say, look at this, my state is grid I J. Now it's time for me to implement those rules, right? Okay, if my state is zero and three neighbors are alive, change my state to one.

188
00:25:41,800 --> 00:26:04,800
If state equals zero and neighbors equals zero, then next I J equals one. Okay, that's rule number one. If not zero equals three. Okay, now what else?

189
00:26:05,800 --> 00:26:30,800
If I'm alive and less than two or greater than three are alive, then change my state to zero. Else if my state is one and neighbors is less than two or neighbors is greater than three, and I probably should put a little parentheses around that one.

190
00:26:30,800 --> 00:26:47,800
And again, I'm sure they're like some nicer ways I could write this in a more concise way, but you can see this is the rule, right? If I'm alive and I have less than two or greater than three neighbors, then the new state is zero.

191
00:26:47,800 --> 00:27:07,800
In all other cases, the next state is just the current state. Okay, so and this makes me want to put this up here at the top so that I can also just use this here. So that's the state, right? The state, this is the current state.

192
00:27:07,800 --> 00:27:20,800
If I'm an edge, just ignore me. I'm the same state. If I'm not an edge, count all the neighbors, check if I should change my state or say the same. I'm seeing in the chat, there's a typo at neighbors in the first if. Thank you.

193
00:27:20,800 --> 00:27:34,800
Neighbors. Okay. What's the chance I've actually finished this? So there we go. I think I have mostly all the code for it. Okay, count is not defined.

194
00:27:34,800 --> 00:27:44,800
Sketch.js line 55. Oh, right, because I called it count neighbors, which is a better name for the function than counts. Try that.

195
00:27:44,800 --> 00:28:03,800
Cannot read property negative one of undefined at count neighbors. So what is undefined? Oh, no, no, no, no. Ah, look at this. This is a big mistake, right? What was I doing here? This loop, negative, right? This loop which goes, which is basically a loop for like a little,

196
00:28:04,800 --> 00:28:28,800
subsection, right? If this is x and y, right? I is an offset negative one to positive one. J is an offset negative one to positive one. The cells I'm looking at are not i, j, but x plus i and y plus j, because I'm just looking relative to where that x, y point is.

197
00:28:28,800 --> 00:28:53,800
So that was a big mistake here. This should be x plus i, y plus j. Oh, so close. Count neighbors at draw, sketch line 55. Okay, ooh, sketch line 55. Count neighbors, wait, wait, wait, wait. Cannot read property negative one of undefined.

198
00:28:53,800 --> 00:29:18,800
What's undefined? Grid neighbors? Okay, hold on. Let's look at some stuff here. Or if j is zero. Oh, look at this. I just keep going anyway. So this I really, I need to break out of the loop. So this is really like, I'm done. Leave the loop or continue or something. I don't know. I'm going to, I'm just going to put an elf in here as much as I hate that.

199
00:29:18,800 --> 00:29:31,800
So because I shouldn't be, I'm basically doing the edges or the neighbors. Boy, this will be much nicer if I just, in this function, add some code to deal with the wrap around, which is not going to be that hard to do. So but now I should be good.

200
00:29:33,800 --> 00:29:43,800
There we go. The game of life. Now it looks weird because the edges are ever changing, but this is actually now the game of life working.

201
00:29:43,800 --> 00:29:56,800
I really got to implement this wrap around thing. So let's do that now. Let's fix it so that the edges consider the other sides as neighbors. So how do I do that?

202
00:29:57,800 --> 00:30:09,800
Well, one way to do that is with something called modulus. This is really, this is great. And I can refer you to Golan Levin's guest tutorial video on modulus which was made as part of this channel. So I will link to that.

203
00:30:10,800 --> 00:30:31,800
But basically what I'm saying here is if I have 10 columns, zero through nine, what could, and I'm always looking for the neighbor plus one, right? So zero plus one is one, one plus one is two, et cetera, et cetera, et cetera.

204
00:30:31,800 --> 00:30:45,800
Nine plus one is 10, but I want the neighbor to be zero. Well, guess what? Nine plus one modulus 10 equals zero because modulus is the operator that gives you the remainder of division.

205
00:30:46,800 --> 00:30:57,800
10 divided by 10 is one remainder zero. So I encourage you to watch that modulus video if you're not familiar with modulus. So this will actually work almost getting closer if I say,

206
00:31:01,800 --> 00:31:08,800
I'm going to just say like, I'm going to have a new, I need like a new variable name for X plus, I guess I could say column.

207
00:31:09,800 --> 00:31:29,800
I don't like column and I'm going to say X plus I modulus columns and row equals Y plus J modulus rows. So this gets me close. It doesn't get me all the way there, but it gets me close. So now I'm adding it up like this.

208
00:31:30,800 --> 00:31:42,800
And I'm going to, I'm going to get rid of this whole edges thing because no longer, okay? So I've got to get this done. Now I'm going to have an error here, right?

209
00:31:42,800 --> 00:31:51,800
I'm still getting like an out of bounds error because I'm going to negative one. Why? Because what if in the case of I equal negative one?

210
00:31:52,800 --> 00:32:11,800
So what is, if I is zero, right? So let me come to the console here. 10 modulus 10 is zero. But let's say I'm looking for the left neighbors. So I'm going through negative one.

211
00:32:11,800 --> 00:32:21,800
Negative one, modulus 10 is negative one. But I need that to be nine. I need negative one to be nine. Well, guess what?

212
00:32:22,800 --> 00:32:34,800
If I actually just add the number of columns to everything, right? If I'm actually working with the numbers instead of the numbers zero through nine, the numbers 10 through 19, right?

213
00:32:34,800 --> 00:32:47,800
10 minus one is nine. Modulus 10 is nine. So the formula is negative one is negative one plus the number of columns, modulus the number of columns.

214
00:32:50,800 --> 00:32:57,800
Oh, but that's not 10. There's a different numbers in my system. But, so let's, let's try to confirm this again, okay?

215
00:32:57,800 --> 00:33:11,800
The idea is that I have an x and a y point. So that point might be, let's say if it's on an edge, for example, might be like zero, comma, it's on the left edge, might be something like zero, comma, whatever the y is.

216
00:33:12,800 --> 00:33:27,800
You know, 10. It's five. So this is the x value. And I want to take x plus i plus the number of columns, modulus the number of columns.

217
00:33:28,800 --> 00:33:36,800
Instead of this is going to be simple, but it's kind of, it's really kind of like a crazy thing to do. But you might write this out and practice it a bit on your own. It will make sense to you eventually.

218
00:33:37,800 --> 00:33:47,800
So when this is going to work basically, let's say i is going to be the values negative one, zero, and one, right?

219
00:33:48,800 --> 00:33:55,800
x is going to be the values zero through nine if I'm thinking about all the possible, all the possible columns.

220
00:33:55,800 --> 00:34:12,800
So let's just take zero and negative one, for example. Zero minus one plus, and in this case I have ten columns, plus ten, modulus ten is actually nine, modulus ten, which equals nine.

221
00:34:12,800 --> 00:34:19,800
So zero, negative one to the left of it, that wraps it around to get the neighbor on the right, right?

222
00:34:19,800 --> 00:34:35,800
It doesn't work for just any arbitrary thing in the middle. Like if I take i to be three, sorry, if I take, if I take, sorry, x to be three, three minus one plus ten, modulus ten.

223
00:34:35,800 --> 00:34:45,800
We'll see how this ten and ten, it kind of cancels itself out. Can you see that? Am I off the whiteboard? I'm close to being off the whiteboard. That equals two, right?

224
00:34:45,800 --> 00:34:53,800
Because this is twelve, modulus ten is two. So this actually works, and then what if I'm on the edge if I'm at like nine, right?

225
00:34:53,800 --> 00:35:06,800
If x is nine, nine plus one is ten, plus the number of columns is ten, is twenty, modulus columns, twenty divided by ten is two, remainder zero, zero.

226
00:35:06,800 --> 00:35:13,800
So nine to the right gets neighbor zero. So this is kind of goofy, it like shifts everything over so it can kind of look across the edges.

227
00:35:13,800 --> 00:35:20,800
So this is going to work. You can believe me or not believe me, but it's going to work, and I'm going to put this in.

228
00:35:20,800 --> 00:35:39,800
So now what I want is x plus i plus columns, modulus columns, y plus j plus rows, modulus rows, add those all up, and the game of life.

229
00:35:40,800 --> 00:35:44,800
Thank you. Thank you for watching this coding challenge. Thank you, thank you.

230
00:35:44,800 --> 00:35:56,800
So let's try making, let's try doing a couple things, just to get a little further here. Let's, let's, I don't know, no I'm not going to do, you do all the next stuff.

231
00:35:56,800 --> 00:36:04,800
I'm just curious, like let me make the resolution ten, so we can see that's with the ten. So you can see it's running pretty fast in the browser.

232
00:36:04,800 --> 00:36:09,800
I have a pretty slow, low resolution. So here's what you should do now.

233
00:36:09,800 --> 00:36:15,800
I'm going to stop. This is a perfect opportunity for people watching this video to make some variations.

234
00:36:15,800 --> 00:36:20,800
Some things you can think about. Well, one thing is, what if you make each one of these cells an object?

235
00:36:20,800 --> 00:36:25,800
So its state might not actually just be, it can keep track of more than just its state zero or one.

236
00:36:25,800 --> 00:36:30,800
It could keep track of whether it's change state or stay the same or how long it stayed the same.

237
00:36:30,800 --> 00:36:36,800
What if you visualize those, what if you visualize with different colors based on the history of the system?

238
00:36:36,800 --> 00:36:41,800
What if you allow a user to draw with the mouse and set cells on?

239
00:36:41,800 --> 00:36:47,800
What if you look up some of these repeating, special repeating patterns that you can create certain kinds of patterns?

240
00:36:47,800 --> 00:36:53,800
What if you, are you going to think of more, and what if you did the edges in a different way?

241
00:36:53,800 --> 00:36:58,800
What if you used the floating point numbers instead of zeros and ones and did like an average or something?

242
00:36:58,800 --> 00:37:02,800
There are so many ways you can create a system lowering the resolution.

243
00:37:02,800 --> 00:37:06,800
What if you drew, didn't draw squares but circles, used images.

244
00:37:06,800 --> 00:37:09,800
How can you visualize this system? How can you change the rules?

245
00:37:09,800 --> 00:37:15,800
Or how can you visualize the system in a different way to create a piece of art or for some other purpose?

246
00:37:15,800 --> 00:37:18,800
I look forward to you share what you make in the comments.

247
00:37:18,800 --> 00:37:21,800
There'll be the code link from here in a read me where you can submit your versions.

248
00:37:21,800 --> 00:37:25,800
And I'll come back in a future live stream. I'll share some of the community made versions.

249
00:37:25,800 --> 00:37:26,800
Run this again.

250
00:37:26,800 --> 00:37:32,800
There's one other thing, but I do think that making cell objects is a path.

251
00:37:32,800 --> 00:37:36,800
Right now I just have, and you should probably do the swapping thing.

252
00:37:36,800 --> 00:37:41,800
Maybe that's one other thing you could do is like, maybe not, don't make a new 2D array every time.

253
00:37:41,800 --> 00:37:47,800
But what I'm thinking about here is what if instead of each one of these being a random value,

254
00:37:47,800 --> 00:37:51,800
you set something like new cell i, j.

255
00:37:51,800 --> 00:37:57,800
And this cell object can animate, it can move around, the cells could move, they could grow,

256
00:37:57,800 --> 00:37:59,800
they could shrink, they could keep track of their history.

257
00:37:59,800 --> 00:38:02,800
There's so many possibilities there if you make an object for the cell.

258
00:38:02,800 --> 00:38:04,800
Okay, thanks for watching.

259
00:38:04,800 --> 00:38:08,800
I hope you enjoyed this coding challenge and you share with me what you make. Goodbye.

