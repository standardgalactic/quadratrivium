start	end	text
0	3000	You
30000	44320	Micro Focus, creators of visual programming tools for software development, is pleased
44320	59640	to provide major funding for the computer chronicles, the story of this continuing evolution.
59640	63640	Welcome to the Computer Chronicles, I'm Stuart Chiffet and this is Gary Kildall.
63640	67640	Monsieur Kildall, est-ce que je peux avoir un dollar?
67640	70640	If you got me on that one.
70640	73640	What I was asking you was would you lend me a dollar?
73640	77640	Only I was using the French language to communicate to your brain, your computer,
77640	80640	and I guess you're programmed in the English language so you didn't perform the program
80640	82640	the way I hoped you would and you didn't give me the dollar.
82640	87640	The point of this little story is that our subject today is computer programming languages, Gary,
87640	90640	and of course there are many languages you can program in just like there are many languages
90640	92640	we can speak in.
92640	95640	Before we talk about these different individual programming languages, I thought you might
95640	98640	explain the different levels of computer language.
98640	101640	Well there are three major levels of computer programming languages that sort of depend
101640	105640	upon your level of sophistication, what you're going to use the language for.
105640	109640	The lowest level is what's called machine language and that's the language the machine
109640	111640	understands, the ones and the zeros.
111640	116640	The next level up from that is what they call systems languages and languages like the
116640	119640	programming language C would be in that category.
119640	124640	And those languages are used to program applications such as word processors or spreadsheets.
124640	128640	And then the third level, the highest level is what's called an application language
128640	132640	or an end user language and those languages like Fortran, Cobol, Logo,
132640	134640	so forth fit into that category.
134640	137640	And so we'll get a chance today to talk about some of those languages and see how they're used.
137640	142640	Okay indeed, we'll see a demonstration of Cobol, Fort, Logo, we'll talk about Pascal.
142640	145640	First though let's try to understand a bit better this problem created by having so many
145640	152640	different programming languages.
152640	157640	This multi-lingual keyboard can perform the tasks of interpreter, grammatical advisor,
157640	161640	and artist in translating English sounds into Japanese text.
161640	166640	The program does for human languages what most computers are incapable of doing
166640	168640	with their own languages.
168640	172640	Because machine codes vary from one microprocessor to another,
172640	176640	the same programming language cannot be shared by two different computers.
176640	179640	For example, AppleBasic is not IBMBasic.
179640	183640	A language customized for one machine will not run on another.
183640	187640	Like their human counterparts, computer programming languages differ in structure,
187640	190640	syntax, code, and even symbols.
190640	195640	But the lack of standard transferable code puts the programmer at a time-consuming disadvantage.
195640	200640	After learning to write a program for one computer, he must rewrite it for another.
200640	205640	Because of a computer's wide range of applications, languages are specialized.
205640	208640	Fortran for science and math.
208640	210640	Cobol for business.
210640	212640	Logo for education.
212640	216640	The more friendly a high-level language, the more translation it requires before it can be
216640	221640	executed at the machine level and correspondingly the slower it runs.
221640	227640	In some cases, lack of speed at the machine level is a trade-off for quick interaction with the user.
227640	231640	Adding a third layer of complexity to computer programming is the assembly language,
231640	235640	required to translate high-level languages into machine code.
235640	239640	Programs written in assembly language are faster in execution,
239640	243640	but more difficult to write than those in a high-level language.
243640	248640	Software firms are developing more powerful, portable languages for use in micros,
248640	254640	but as long as computer manufacturers design exclusivity into their products and languages,
254640	257640	users are faced with the same dilemma.
257640	261640	Machines that will communicate with everyone accept each other.
261640	265640	Ruski jazik.
275640	279640	Our guests today are Paolo Grady, Paolo's executive vice president
279640	282640	for strategic development at Micro Focus, and Paolo works with Cobol.
282640	287640	Next to Paolo, Dave Eisenberg, a senior engineer and software developer with Apple Computers,
287640	289640	and Dave works with Pascal.
289640	290640	Gary.
290640	295640	Stuart, there's been a lot of languages around for several years that are considered traditional languages
295640	299640	like PL-1, Fortran, Cobol is a good example of that,
299640	306640	and one of the difficulties in the small computer industry is trying to bring those down into really usable languages.
306640	310640	Nowadays, people expect a lot more interaction in the way they deal with computer systems,
310640	316640	but we know that Micro Focus has been working on Cobol trying to make that more of a personal orientation,
316640	318640	so what have you done?
318640	324640	Well, we see ourselves, Gary, as in the business of exploding myths about Cobol.
324640	329640	The mainframe people have myths about it that it can't run on this kind of equipment,
329640	335640	and the micro-computer people have myths about it in the sense that they just don't like the language at all,
335640	337640	a lot of people.
337640	342640	What we try to do is we try to differentiate between the environment and the language itself,
342640	346640	and the environment in the past for Cobol has been the mainframe environment.
346640	352640	We believe that that is what has led to much dissatisfaction in that environment.
352640	357640	What we've done here, though, with Personal Cobol, which is one of our latest products,
357640	364640	is show what we believe is the kind of thing that can be done and which is very appealing on this kind of equipment.
364640	367640	I've already put this into Personal Cobol.
367640	374640	Personal Cobol is a combination of an editor, a forms generator, a checker, a syntax checker,
374640	378640	and the ability to run programs.
378640	384640	In this case, I'm going to go straight into the forms part,
384640	389640	and I've already created a form for us.
389640	393640	This is a form that you created by drawing the lines in and so forth.
393640	401640	Everything that you see on this screen here was created by directly keying in the lines,
401640	405640	the text, the x's, the square brackets, the whole thing.
405640	411640	I did it in approximately five minutes or so before the programs started.
411640	417640	What I'm going to do now is to start to generate the Cobol for this,
417640	423640	because another of the businesses that Microfocus sees itself as being in
423640	426640	is trying to redefine the term programming,
426640	432640	and programming for us is simply generating code in whatever way possible,
432640	434640	the most effective way possible.
434640	439640	In this case, we're going to generate all of the code for this screen automatically.
439640	442640	That I'll do now.
443640	448640	We also wrote this program so that people who have finger trouble like me
448640	450640	never really crashed the program.
450640	453640	I hope to prove that.
453640	457640	I'm going to create a complete program, an index program.
457640	461640	I've positioned the cursor as it tells me to,
461640	466640	and we're now generating Cobol in the lower part of the screen.
466640	470640	Now, this traditionally, again, if you talk about traditional Cobol programming,
470640	474640	you'd start with a program that would work out all the details of it
474640	476640	that would produce this screen.
476640	479640	In this case, what you've done is you've manually made the screen up
479640	482640	by moving the cursor around, and it's doing the inverse.
482640	484640	It's actually producing the program instead.
484640	486640	That is correct, yes, and we've already produced it.
486640	489640	We've produced the Cobol for that.
489640	495640	What I can now do is I can decide whether or not I want to save that.
495640	500640	In this case, I'll exit without saving.
500640	507640	I've already created the text elsewhere.
507640	510640	As I said, some people have finger trouble,
510640	514640	and I always have finger trouble at points like this.
514640	518640	Paul, you mentioned that some programmers have not liked Cobol in the past.
518640	519640	Why is that?
519640	524640	What is it about it that created a problem?
524640	527640	There's a lot of detail to the syntax.
527640	532640	The period at the end of each Cobol statement often cause problems,
532640	538640	but there is also the need to define records at the beginning of a program
538640	543640	prior to getting into the guts of it, making the program do the work.
543640	551640	However, that comes from the type of application that Cobol was designed to bear upon.
551640	554640	Those are typically data handling applications,
554640	559640	far-manipulating applications, and for that kind of application,
559640	564640	it is necessary to create the records to start with.
564640	570640	Which I work with here is, again, a program generation concept.
570640	573640	If you talk about forms, you put up forms ahead of time,
573640	575640	and then you generate a Cobol program.
575640	577640	Can you also do that for data structures for accessing files,
577640	580640	or is this something that would come up in the future?
580640	583640	In terms of the data structures,
583640	588640	they're already built into the index sequential file mechanism of the Cobol,
588640	591640	and we adhere to the Cobol standard.
591640	596640	But yes, in the future, one can conceive of the ability to input the data structure
596640	601640	directly into the program prior to generating it.
601640	603640	Dave, you work primarily with Pascal,
603640	606640	and tell us about Pascal and why you like it.
606640	608640	What are its special features?
608640	611640	One of the nicer things about Pascal is its power of expression
611640	616640	in terms of, for a small amount of text on the screen,
616640	620640	which is given the right program or awfully readable,
620640	622640	you can get a lot of power out of it.
622640	625640	It allows you to express an algorithm,
625640	628640	a method for doing a computation or some process,
628640	629640	the way you think about it,
629640	632640	instead of having to force it into some other mold.
632640	635640	And that's one of the advantages of Cobol for business applications.
635640	640640	It's built for that, such that you can think in terms of a business or record problem
640640	641640	and do it that way.
641640	647640	Pascal is similar, but pretty much for more general purpose applications.
647640	653640	Pascal had several years ago a lot of interest in terms of using it as a systems language,
653640	656640	and it was sort of touted as the all-purpose language of doing everything.
656640	660640	What happened? Why did that not really take place?
660640	664640	Pascal was first designed as a language for teaching about computing and computer science,
664640	671640	and even its inventor admitted that that was what it was for,
671640	674640	and he's been at work lately on something called Modula,
674640	678640	which is designed to take over from Pascal in terms of the systems area,
678640	681640	which lets you get closer to the machine level,
681640	685640	but still again have the power of expression that Pascal has.
685640	688640	Paul, in coming up with something like personal Cobol,
688640	693640	a Cobol we think of as you say, a mainframe, big corporation environment type language,
693640	697640	what kind of use, what kind of application do you see with something like personal Cobol?
697640	703640	Well, we see not just the classic business data processing applications,
703640	709640	we see personal applications such as diary application, personal filing applications,
709640	715640	and we also see office automation applications all being applicable to Cobol.
715640	721640	They all require data handling and file maintenance, which Cobol was originally designed for.
721640	725640	I think it's also important to think of Cobol as being a system implementer's language.
725640	730640	That is, it's not the kind of a language that you really promote as, say, an end user language.
730640	731640	Is that correct?
731640	732640	I would agree with that.
732640	736640	More to the kind of an individual who is going to go out and write some extensive programs
736640	738640	and then go off and sell those programs,
738640	742640	and so there's a whole layer of programming languages that fit in that category
742640	745640	that maybe an end user might not even want to consider,
745640	748640	at least until they've had some experience with programming languages.
748640	750640	Yes, I agree.
750640	755640	I think none of the standard, the normally accepted programming languages,
755640	760640	are applicable for end users at this point personally, not even basic.
760640	764640	Okay, well, our third guest is going to talk to us about fourth,
764640	767640	and that's coming up in just a moment.
767640	776640	Music
776640	778640	Joining us now is Elizabeth Rather.
778640	781640	Elizabeth is president of Fourth Incorporated over most of Beach, California.
781640	783640	Elizabeth, tell us about fourth.
783640	785640	What makes that a unique programming language?
785640	788640	It's unique in two respects.
788640	794640	First, it is the only language that I'm aware of that was designed from first principles
794640	800640	to run in a small computer doing interactive software development for real-time applications.
800640	806640	The second area that it's unique relates to Gary's remark early in the program
806640	810640	when he mentioned the three levels of programming,
810640	812640	and fourth incorporates all of them.
812640	816640	You can work right down at the machine code level when you need to.
816640	818640	You can do system programming in fourth.
818640	823640	In fact, the operating system that we're running on here was all written in fourth.
823640	830640	And you can do very high-level kinds of things, very high-level application-oriented programming.
830640	835640	For example, we have here a graphics program that is loaded,
835640	841640	and I have a list of a large number of demo programs that I could run here.
841640	847640	I'm going to try one of them called Logos, which draws, it's not related to the language logo.
847640	852640	It draws our company's logo, which is a little bit chauvinistic,
852640	857640	but the principal thing that this is illustrating, this is a rather complex figure here,
857640	863640	and we're doing area fill, which is a fairly sophisticated graphics technique,
863640	867640	and it's doing it very fast and very well.
867640	872640	It's now got everything all white except for what was concealed in the little spots there,
872640	878640	and eventually we'll be able to make even the little spots go away.
878640	882640	There are high-level words that put together this entire process,
882640	884640	and I can show you some of them.
884640	889640	Was that entirely done in fourth, as far as any assembly language involved in that area fill,
889640	891640	or was that entirely done in fourth?
891640	893640	No, there is some assembly language.
893640	897640	Yes, and you put in as much assembly language as you need,
897640	901640	either to control hardware directly or to make things run fast,
901640	904640	and you notice this is a very fast program,
904640	907640	but you have the high-level version.
907640	916640	I can say locate logos, locate fill, for example.
916640	921640	This is the area fill routine, which is written in code,
921640	925640	because area fill is something that needs to run very, very fast,
925640	927640	so you have assembly language code here,
927640	933640	and then we have some other words called dark and light that are what we call high-level.
933640	937640	As far as this is assembly language, you're showing us part of this is fourth in the fourth statement, is that true?
937640	941640	Yes, that's right.
941640	944640	The word dark, for example, that I'm highlighting here,
944640	949640	makes the screen go dark, like that,
949640	954640	and it simply picks up the color and blackens the screen,
954640	958640	and then resets what the previous color was so that when you draw something again,
958640	960640	you'll draw it in whatever color it was.
960640	962640	You can work with very high-level things.
962640	964640	The highlighted line itself is fourth in this case.
964640	966640	Yes, that's right.
966640	969640	Gary, your company, Digital Research, has logo out on it.
969640	971640	I just happen to have a disc with you.
971640	974640	Maybe you could load up logo for a minute and show us how logo comes in.
974640	975640	Give me some help over there.
975640	977640	Compare us to these other languages.
977640	980640	Dave, while we're waiting for logo to boot up there,
980640	984640	let me ask you, are there always going to be all these different languages,
984640	987640	or are they going to merge into a smaller number?
987640	989640	Well, it would be nice to have an ideal language,
989640	991640	but I don't think it will ever really happen.
991640	994640	Mostly because, well, for example, Kobal, which we saw earlier,
994640	998640	is designed and used primarily for business applications.
998640	1001640	Fourth is designed for real-time applications.
1001640	1004640	Logo is designed for education, teaching people to program.
1004640	1009640	And, well, when you discuss languages, it almost becomes a religious argument,
1009640	1011640	but really a language is just a tool,
1011640	1014640	and it's like arguing, well, which is better, a hammer or a screwdriver?
1014640	1017640	And you tell me what you want to do with it, and then I'll tell you which one's better.
1017640	1020640	I think that's probably the most important point about languages,
1020640	1022640	is that if you use the right one for the right application,
1022640	1024640	then it's the most effective thing you can do.
1024640	1028640	Logo is like a lot of different interpreted languages.
1028640	1033640	It gives you an immediate feedback to the work that you're doing.
1033640	1040640	And what I'll do here, I'm just going to make this screen into a split screen.
1040640	1043640	And I'll show you what I mean by the immediate interaction.
1043640	1050640	For example, if I type forward to 30, then you see the pointer or the turtle is called moved in a direction.
1050640	1052640	Now, that's immediate feedback to what you typed in.
1052640	1057640	Now, a lot of programming languages like Fortran or, let's say, many Pascal versions
1057640	1061640	are what they call compiled languages, and you don't get immediate feedback.
1061640	1065640	You have to go through an edit step and a compile step and maybe even linkage editing.
1065640	1069640	And that requires a lot of abstraction, a lot of thinking about what you're doing.
1069640	1073640	Where languages that are interactive like Logo and Fortran and other interpreters
1073640	1075640	give you immediate feedback.
1075640	1080640	Now, the next thing I'm going to load in here is called Blackjack.
1080640	1082640	And it happens to be a demo program.
1082640	1083640	It's familiar with that program.
1083640	1084640	It's familiar with that program.
1084640	1089640	Now, the reason I'm loading this one, this happens to be an example of how you use turtle graphics
1089640	1092640	or graphics to draw pictures.
1092640	1097640	And this particular program was written by a 13-year-old in about three or four days.
1097640	1098640	Now, it's a rather precocious 13-year-old.
1098640	1099640	Yeah, you're a son.
1099640	1100640	Well, no, actually.
1100640	1102640	It's genetically superior, Gary.
1102640	1104640	It was actually his friend.
1104640	1113640	But the point of it is that you can do things like this, like a little game of Blackjack
1113640	1118640	without a great deal of effort in a language that's interactive and graphical in nature.
1118640	1122640	One of the nice things about these languages where you define your own words is that you
1122640	1124640	can make it read fairly close to English.
1124640	1127640	You can actually pick up a program and read it.
1127640	1128640	Gary.
1128640	1132640	Well, you're playing Blackjack there.
1132640	1136640	Many most new computer users get exposed to BASIC as their kind of language.
1136640	1138640	And we haven't really talked about that yet.
1138640	1140640	You're showing how easy it is to do a game like this in Logo.
1140640	1142640	How is it better than BASIC?
1142640	1144640	What are the problems in BASIC as a programming language?
1144640	1147640	Well, BASIC historically came from Fortran.
1147640	1150640	It has a lot of the original problems of Fortran.
1150640	1155640	Fortran is one of the, in fact, may have been the very first, I guess, high-level programming language,
1155640	1157640	recognized high-level programming language.
1157640	1163640	And so BASIC sort of followed that genealogy and has a scientific orientation to it,
1163640	1170640	step-by-step breakdown of the problem into simple steps that sometimes,
1170640	1174640	not really the best way to think about the breaking a problem apart.
1174640	1180640	Now, Logo came from the MIT Learning Project where they thought about the problem of problem solving itself
1180640	1184640	and then the language, an underlying language that would be good for that.
1184640	1189640	So I think BASIC is just, it's an easy language to learn,
1189640	1192640	but it has its limitations as soon as you start to do anything complicated.
1192640	1199640	BASIC was designed to be learned quickly by college undergraduates doing very simple things.
1199640	1203640	It wasn't designed to do either sophisticated programs nor was it designed to grow.
1203640	1211640	And I think both Fortran and Logo have the capacity to grow in the sense that you can teach them new things.
1211640	1218640	And there is a learning process going on in the computer or between the programmer and the computer,
1218640	1224640	which is very similar to the learning process of teaching a small child to do new things.
1224640	1230640	Well, I think that's interesting with Logo also is that it's sort of a bait-and-switch tactic
1230640	1235640	in the sense that you sort of get children interested in the language because of the graphics,
1235640	1240640	because they think of it as a big track that the programmer runs around the floor, in this case a turtle.
1240640	1245640	But behind it is a language, a LISP, which has been used for years in artificial intelligence
1245640	1249640	and all the LISP processing that's a part of LISP is also part of Logo.
1249640	1255640	And so the Fortran LISP shares actually some foundations that are somewhat similar.
1255640	1259640	Dave, are there any new languages on the horizon or do we have a finite number now?
1260640	1265640	The last roster of programming languages that I saw had about seven or eight hundred names in it,
1265640	1267640	and I don't see an end in sight.
1267640	1270640	A lot of languages are designed for one specific thing.
1270640	1274640	I guess you'd call them almost a toy language except for the person who invents it.
1274640	1283640	So most of them are, I think, are offshoots of the main languages like Fortran, Kobal, Algal, or LISP.
1283640	1289640	And yes, as long as people have ideas for things they want to do, they'll invent a new language.
1289640	1293640	So it's a kind of evolutionary process, I think all of you said, where one language builds on another language.
1293640	1298640	Well, I think also it's a matter of getting started as far as learning a language.
1298640	1302640	Once you've learned one language, it's not very difficult to start picking up other languages,
1302640	1305640	but it seems to be a threshold to get over the very first time.
1305640	1309640	So I think that's what an interesting thing about learning languages is that you get started at least.
1309640	1311640	Okay, well, we started and we're finished.
1311640	1316640	Thank you very much for being with us, and thank you for joining us in this edition of the Computer Chronicles.
1339640	1349640	The Computer Chronicles
1369640	1380640	The Computer Chronicles
