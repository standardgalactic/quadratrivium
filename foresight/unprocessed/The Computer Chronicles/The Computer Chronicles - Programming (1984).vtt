WEBVTT

00:00.000 --> 00:03.000
You

00:30.000 --> 00:44.320
Micro Focus, creators of visual programming tools for software development, is pleased

00:44.320 --> 00:59.640
to provide major funding for the computer chronicles, the story of this continuing evolution.

00:59.640 --> 01:03.640
Welcome to the Computer Chronicles, I'm Stuart Chiffet and this is Gary Kildall.

01:03.640 --> 01:07.640
Monsieur Kildall, est-ce que je peux avoir un dollar?

01:07.640 --> 01:10.640
If you got me on that one.

01:10.640 --> 01:13.640
What I was asking you was would you lend me a dollar?

01:13.640 --> 01:17.640
Only I was using the French language to communicate to your brain, your computer,

01:17.640 --> 01:20.640
and I guess you're programmed in the English language so you didn't perform the program

01:20.640 --> 01:22.640
the way I hoped you would and you didn't give me the dollar.

01:22.640 --> 01:27.640
The point of this little story is that our subject today is computer programming languages, Gary,

01:27.640 --> 01:30.640
and of course there are many languages you can program in just like there are many languages

01:30.640 --> 01:32.640
we can speak in.

01:32.640 --> 01:35.640
Before we talk about these different individual programming languages, I thought you might

01:35.640 --> 01:38.640
explain the different levels of computer language.

01:38.640 --> 01:41.640
Well there are three major levels of computer programming languages that sort of depend

01:41.640 --> 01:45.640
upon your level of sophistication, what you're going to use the language for.

01:45.640 --> 01:49.640
The lowest level is what's called machine language and that's the language the machine

01:49.640 --> 01:51.640
understands, the ones and the zeros.

01:51.640 --> 01:56.640
The next level up from that is what they call systems languages and languages like the

01:56.640 --> 01:59.640
programming language C would be in that category.

01:59.640 --> 02:04.640
And those languages are used to program applications such as word processors or spreadsheets.

02:04.640 --> 02:08.640
And then the third level, the highest level is what's called an application language

02:08.640 --> 02:12.640
or an end user language and those languages like Fortran, Cobol, Logo,

02:12.640 --> 02:14.640
so forth fit into that category.

02:14.640 --> 02:17.640
And so we'll get a chance today to talk about some of those languages and see how they're used.

02:17.640 --> 02:22.640
Okay indeed, we'll see a demonstration of Cobol, Fort, Logo, we'll talk about Pascal.

02:22.640 --> 02:25.640
First though let's try to understand a bit better this problem created by having so many

02:25.640 --> 02:32.640
different programming languages.

02:32.640 --> 02:37.640
This multi-lingual keyboard can perform the tasks of interpreter, grammatical advisor,

02:37.640 --> 02:41.640
and artist in translating English sounds into Japanese text.

02:41.640 --> 02:46.640
The program does for human languages what most computers are incapable of doing

02:46.640 --> 02:48.640
with their own languages.

02:48.640 --> 02:52.640
Because machine codes vary from one microprocessor to another,

02:52.640 --> 02:56.640
the same programming language cannot be shared by two different computers.

02:56.640 --> 02:59.640
For example, AppleBasic is not IBMBasic.

02:59.640 --> 03:03.640
A language customized for one machine will not run on another.

03:03.640 --> 03:07.640
Like their human counterparts, computer programming languages differ in structure,

03:07.640 --> 03:10.640
syntax, code, and even symbols.

03:10.640 --> 03:15.640
But the lack of standard transferable code puts the programmer at a time-consuming disadvantage.

03:15.640 --> 03:20.640
After learning to write a program for one computer, he must rewrite it for another.

03:20.640 --> 03:25.640
Because of a computer's wide range of applications, languages are specialized.

03:25.640 --> 03:28.640
Fortran for science and math.

03:28.640 --> 03:30.640
Cobol for business.

03:30.640 --> 03:32.640
Logo for education.

03:32.640 --> 03:36.640
The more friendly a high-level language, the more translation it requires before it can be

03:36.640 --> 03:41.640
executed at the machine level and correspondingly the slower it runs.

03:41.640 --> 03:47.640
In some cases, lack of speed at the machine level is a trade-off for quick interaction with the user.

03:47.640 --> 03:51.640
Adding a third layer of complexity to computer programming is the assembly language,

03:51.640 --> 03:55.640
required to translate high-level languages into machine code.

03:55.640 --> 03:59.640
Programs written in assembly language are faster in execution,

03:59.640 --> 04:03.640
but more difficult to write than those in a high-level language.

04:03.640 --> 04:08.640
Software firms are developing more powerful, portable languages for use in micros,

04:08.640 --> 04:14.640
but as long as computer manufacturers design exclusivity into their products and languages,

04:14.640 --> 04:17.640
users are faced with the same dilemma.

04:17.640 --> 04:21.640
Machines that will communicate with everyone accept each other.

04:21.640 --> 04:25.640
Ruski jazik.

04:35.640 --> 04:39.640
Our guests today are Paolo Grady, Paolo's executive vice president

04:39.640 --> 04:42.640
for strategic development at Micro Focus, and Paolo works with Cobol.

04:42.640 --> 04:47.640
Next to Paolo, Dave Eisenberg, a senior engineer and software developer with Apple Computers,

04:47.640 --> 04:49.640
and Dave works with Pascal.

04:49.640 --> 04:50.640
Gary.

04:50.640 --> 04:55.640
Stuart, there's been a lot of languages around for several years that are considered traditional languages

04:55.640 --> 04:59.640
like PL-1, Fortran, Cobol is a good example of that,

04:59.640 --> 05:06.640
and one of the difficulties in the small computer industry is trying to bring those down into really usable languages.

05:06.640 --> 05:10.640
Nowadays, people expect a lot more interaction in the way they deal with computer systems,

05:10.640 --> 05:16.640
but we know that Micro Focus has been working on Cobol trying to make that more of a personal orientation,

05:16.640 --> 05:18.640
so what have you done?

05:18.640 --> 05:24.640
Well, we see ourselves, Gary, as in the business of exploding myths about Cobol.

05:24.640 --> 05:29.640
The mainframe people have myths about it that it can't run on this kind of equipment,

05:29.640 --> 05:35.640
and the micro-computer people have myths about it in the sense that they just don't like the language at all,

05:35.640 --> 05:37.640
a lot of people.

05:37.640 --> 05:42.640
What we try to do is we try to differentiate between the environment and the language itself,

05:42.640 --> 05:46.640
and the environment in the past for Cobol has been the mainframe environment.

05:46.640 --> 05:52.640
We believe that that is what has led to much dissatisfaction in that environment.

05:52.640 --> 05:57.640
What we've done here, though, with Personal Cobol, which is one of our latest products,

05:57.640 --> 06:04.640
is show what we believe is the kind of thing that can be done and which is very appealing on this kind of equipment.

06:04.640 --> 06:07.640
I've already put this into Personal Cobol.

06:07.640 --> 06:14.640
Personal Cobol is a combination of an editor, a forms generator, a checker, a syntax checker,

06:14.640 --> 06:18.640
and the ability to run programs.

06:18.640 --> 06:24.640
In this case, I'm going to go straight into the forms part,

06:24.640 --> 06:29.640
and I've already created a form for us.

06:29.640 --> 06:33.640
This is a form that you created by drawing the lines in and so forth.

06:33.640 --> 06:41.640
Everything that you see on this screen here was created by directly keying in the lines,

06:41.640 --> 06:45.640
the text, the x's, the square brackets, the whole thing.

06:45.640 --> 06:51.640
I did it in approximately five minutes or so before the programs started.

06:51.640 --> 06:57.640
What I'm going to do now is to start to generate the Cobol for this,

06:57.640 --> 07:03.640
because another of the businesses that Microfocus sees itself as being in

07:03.640 --> 07:06.640
is trying to redefine the term programming,

07:06.640 --> 07:12.640
and programming for us is simply generating code in whatever way possible,

07:12.640 --> 07:14.640
the most effective way possible.

07:14.640 --> 07:19.640
In this case, we're going to generate all of the code for this screen automatically.

07:19.640 --> 07:22.640
That I'll do now.

07:23.640 --> 07:28.640
We also wrote this program so that people who have finger trouble like me

07:28.640 --> 07:30.640
never really crashed the program.

07:30.640 --> 07:33.640
I hope to prove that.

07:33.640 --> 07:37.640
I'm going to create a complete program, an index program.

07:37.640 --> 07:41.640
I've positioned the cursor as it tells me to,

07:41.640 --> 07:46.640
and we're now generating Cobol in the lower part of the screen.

07:46.640 --> 07:50.640
Now, this traditionally, again, if you talk about traditional Cobol programming,

07:50.640 --> 07:54.640
you'd start with a program that would work out all the details of it

07:54.640 --> 07:56.640
that would produce this screen.

07:56.640 --> 07:59.640
In this case, what you've done is you've manually made the screen up

07:59.640 --> 08:02.640
by moving the cursor around, and it's doing the inverse.

08:02.640 --> 08:04.640
It's actually producing the program instead.

08:04.640 --> 08:06.640
That is correct, yes, and we've already produced it.

08:06.640 --> 08:09.640
We've produced the Cobol for that.

08:09.640 --> 08:15.640
What I can now do is I can decide whether or not I want to save that.

08:15.640 --> 08:20.640
In this case, I'll exit without saving.

08:20.640 --> 08:27.640
I've already created the text elsewhere.

08:27.640 --> 08:30.640
As I said, some people have finger trouble,

08:30.640 --> 08:34.640
and I always have finger trouble at points like this.

08:34.640 --> 08:38.640
Paul, you mentioned that some programmers have not liked Cobol in the past.

08:38.640 --> 08:39.640
Why is that?

08:39.640 --> 08:44.640
What is it about it that created a problem?

08:44.640 --> 08:47.640
There's a lot of detail to the syntax.

08:47.640 --> 08:52.640
The period at the end of each Cobol statement often cause problems,

08:52.640 --> 08:58.640
but there is also the need to define records at the beginning of a program

08:58.640 --> 09:03.640
prior to getting into the guts of it, making the program do the work.

09:03.640 --> 09:11.640
However, that comes from the type of application that Cobol was designed to bear upon.

09:11.640 --> 09:14.640
Those are typically data handling applications,

09:14.640 --> 09:19.640
far-manipulating applications, and for that kind of application,

09:19.640 --> 09:24.640
it is necessary to create the records to start with.

09:24.640 --> 09:30.640
Which I work with here is, again, a program generation concept.

09:30.640 --> 09:33.640
If you talk about forms, you put up forms ahead of time,

09:33.640 --> 09:35.640
and then you generate a Cobol program.

09:35.640 --> 09:37.640
Can you also do that for data structures for accessing files,

09:37.640 --> 09:40.640
or is this something that would come up in the future?

09:40.640 --> 09:43.640
In terms of the data structures,

09:43.640 --> 09:48.640
they're already built into the index sequential file mechanism of the Cobol,

09:48.640 --> 09:51.640
and we adhere to the Cobol standard.

09:51.640 --> 09:56.640
But yes, in the future, one can conceive of the ability to input the data structure

09:56.640 --> 10:01.640
directly into the program prior to generating it.

10:01.640 --> 10:03.640
Dave, you work primarily with Pascal,

10:03.640 --> 10:06.640
and tell us about Pascal and why you like it.

10:06.640 --> 10:08.640
What are its special features?

10:08.640 --> 10:11.640
One of the nicer things about Pascal is its power of expression

10:11.640 --> 10:16.640
in terms of, for a small amount of text on the screen,

10:16.640 --> 10:20.640
which is given the right program or awfully readable,

10:20.640 --> 10:22.640
you can get a lot of power out of it.

10:22.640 --> 10:25.640
It allows you to express an algorithm,

10:25.640 --> 10:28.640
a method for doing a computation or some process,

10:28.640 --> 10:29.640
the way you think about it,

10:29.640 --> 10:32.640
instead of having to force it into some other mold.

10:32.640 --> 10:35.640
And that's one of the advantages of Cobol for business applications.

10:35.640 --> 10:40.640
It's built for that, such that you can think in terms of a business or record problem

10:40.640 --> 10:41.640
and do it that way.

10:41.640 --> 10:47.640
Pascal is similar, but pretty much for more general purpose applications.

10:47.640 --> 10:53.640
Pascal had several years ago a lot of interest in terms of using it as a systems language,

10:53.640 --> 10:56.640
and it was sort of touted as the all-purpose language of doing everything.

10:56.640 --> 11:00.640
What happened? Why did that not really take place?

11:00.640 --> 11:04.640
Pascal was first designed as a language for teaching about computing and computer science,

11:04.640 --> 11:11.640
and even its inventor admitted that that was what it was for,

11:11.640 --> 11:14.640
and he's been at work lately on something called Modula,

11:14.640 --> 11:18.640
which is designed to take over from Pascal in terms of the systems area,

11:18.640 --> 11:21.640
which lets you get closer to the machine level,

11:21.640 --> 11:25.640
but still again have the power of expression that Pascal has.

11:25.640 --> 11:28.640
Paul, in coming up with something like personal Cobol,

11:28.640 --> 11:33.640
a Cobol we think of as you say, a mainframe, big corporation environment type language,

11:33.640 --> 11:37.640
what kind of use, what kind of application do you see with something like personal Cobol?

11:37.640 --> 11:43.640
Well, we see not just the classic business data processing applications,

11:43.640 --> 11:49.640
we see personal applications such as diary application, personal filing applications,

11:49.640 --> 11:55.640
and we also see office automation applications all being applicable to Cobol.

11:55.640 --> 12:01.640
They all require data handling and file maintenance, which Cobol was originally designed for.

12:01.640 --> 12:05.640
I think it's also important to think of Cobol as being a system implementer's language.

12:05.640 --> 12:10.640
That is, it's not the kind of a language that you really promote as, say, an end user language.

12:10.640 --> 12:11.640
Is that correct?

12:11.640 --> 12:12.640
I would agree with that.

12:12.640 --> 12:16.640
More to the kind of an individual who is going to go out and write some extensive programs

12:16.640 --> 12:18.640
and then go off and sell those programs,

12:18.640 --> 12:22.640
and so there's a whole layer of programming languages that fit in that category

12:22.640 --> 12:25.640
that maybe an end user might not even want to consider,

12:25.640 --> 12:28.640
at least until they've had some experience with programming languages.

12:28.640 --> 12:30.640
Yes, I agree.

12:30.640 --> 12:35.640
I think none of the standard, the normally accepted programming languages,

12:35.640 --> 12:40.640
are applicable for end users at this point personally, not even basic.

12:40.640 --> 12:44.640
Okay, well, our third guest is going to talk to us about fourth,

12:44.640 --> 12:47.640
and that's coming up in just a moment.

12:47.640 --> 12:56.640
Music

12:56.640 --> 12:58.640
Joining us now is Elizabeth Rather.

12:58.640 --> 13:01.640
Elizabeth is president of Fourth Incorporated over most of Beach, California.

13:01.640 --> 13:03.640
Elizabeth, tell us about fourth.

13:03.640 --> 13:05.640
What makes that a unique programming language?

13:05.640 --> 13:08.640
It's unique in two respects.

13:08.640 --> 13:14.640
First, it is the only language that I'm aware of that was designed from first principles

13:14.640 --> 13:20.640
to run in a small computer doing interactive software development for real-time applications.

13:20.640 --> 13:26.640
The second area that it's unique relates to Gary's remark early in the program

13:26.640 --> 13:30.640
when he mentioned the three levels of programming,

13:30.640 --> 13:32.640
and fourth incorporates all of them.

13:32.640 --> 13:36.640
You can work right down at the machine code level when you need to.

13:36.640 --> 13:38.640
You can do system programming in fourth.

13:38.640 --> 13:43.640
In fact, the operating system that we're running on here was all written in fourth.

13:43.640 --> 13:50.640
And you can do very high-level kinds of things, very high-level application-oriented programming.

13:50.640 --> 13:55.640
For example, we have here a graphics program that is loaded,

13:55.640 --> 14:01.640
and I have a list of a large number of demo programs that I could run here.

14:01.640 --> 14:07.640
I'm going to try one of them called Logos, which draws, it's not related to the language logo.

14:07.640 --> 14:12.640
It draws our company's logo, which is a little bit chauvinistic,

14:12.640 --> 14:17.640
but the principal thing that this is illustrating, this is a rather complex figure here,

14:17.640 --> 14:23.640
and we're doing area fill, which is a fairly sophisticated graphics technique,

14:23.640 --> 14:27.640
and it's doing it very fast and very well.

14:27.640 --> 14:32.640
It's now got everything all white except for what was concealed in the little spots there,

14:32.640 --> 14:38.640
and eventually we'll be able to make even the little spots go away.

14:38.640 --> 14:42.640
There are high-level words that put together this entire process,

14:42.640 --> 14:44.640
and I can show you some of them.

14:44.640 --> 14:49.640
Was that entirely done in fourth, as far as any assembly language involved in that area fill,

14:49.640 --> 14:51.640
or was that entirely done in fourth?

14:51.640 --> 14:53.640
No, there is some assembly language.

14:53.640 --> 14:57.640
Yes, and you put in as much assembly language as you need,

14:57.640 --> 15:01.640
either to control hardware directly or to make things run fast,

15:01.640 --> 15:04.640
and you notice this is a very fast program,

15:04.640 --> 15:07.640
but you have the high-level version.

15:07.640 --> 15:16.640
I can say locate logos, locate fill, for example.

15:16.640 --> 15:21.640
This is the area fill routine, which is written in code,

15:21.640 --> 15:25.640
because area fill is something that needs to run very, very fast,

15:25.640 --> 15:27.640
so you have assembly language code here,

15:27.640 --> 15:33.640
and then we have some other words called dark and light that are what we call high-level.

15:33.640 --> 15:37.640
As far as this is assembly language, you're showing us part of this is fourth in the fourth statement, is that true?

15:37.640 --> 15:41.640
Yes, that's right.

15:41.640 --> 15:44.640
The word dark, for example, that I'm highlighting here,

15:44.640 --> 15:49.640
makes the screen go dark, like that,

15:49.640 --> 15:54.640
and it simply picks up the color and blackens the screen,

15:54.640 --> 15:58.640
and then resets what the previous color was so that when you draw something again,

15:58.640 --> 16:00.640
you'll draw it in whatever color it was.

16:00.640 --> 16:02.640
You can work with very high-level things.

16:02.640 --> 16:04.640
The highlighted line itself is fourth in this case.

16:04.640 --> 16:06.640
Yes, that's right.

16:06.640 --> 16:09.640
Gary, your company, Digital Research, has logo out on it.

16:09.640 --> 16:11.640
I just happen to have a disc with you.

16:11.640 --> 16:14.640
Maybe you could load up logo for a minute and show us how logo comes in.

16:14.640 --> 16:15.640
Give me some help over there.

16:15.640 --> 16:17.640
Compare us to these other languages.

16:17.640 --> 16:20.640
Dave, while we're waiting for logo to boot up there,

16:20.640 --> 16:24.640
let me ask you, are there always going to be all these different languages,

16:24.640 --> 16:27.640
or are they going to merge into a smaller number?

16:27.640 --> 16:29.640
Well, it would be nice to have an ideal language,

16:29.640 --> 16:31.640
but I don't think it will ever really happen.

16:31.640 --> 16:34.640
Mostly because, well, for example, Kobal, which we saw earlier,

16:34.640 --> 16:38.640
is designed and used primarily for business applications.

16:38.640 --> 16:41.640
Fourth is designed for real-time applications.

16:41.640 --> 16:44.640
Logo is designed for education, teaching people to program.

16:44.640 --> 16:49.640
And, well, when you discuss languages, it almost becomes a religious argument,

16:49.640 --> 16:51.640
but really a language is just a tool,

16:51.640 --> 16:54.640
and it's like arguing, well, which is better, a hammer or a screwdriver?

16:54.640 --> 16:57.640
And you tell me what you want to do with it, and then I'll tell you which one's better.

16:57.640 --> 17:00.640
I think that's probably the most important point about languages,

17:00.640 --> 17:02.640
is that if you use the right one for the right application,

17:02.640 --> 17:04.640
then it's the most effective thing you can do.

17:04.640 --> 17:08.640
Logo is like a lot of different interpreted languages.

17:08.640 --> 17:13.640
It gives you an immediate feedback to the work that you're doing.

17:13.640 --> 17:20.640
And what I'll do here, I'm just going to make this screen into a split screen.

17:20.640 --> 17:23.640
And I'll show you what I mean by the immediate interaction.

17:23.640 --> 17:30.640
For example, if I type forward to 30, then you see the pointer or the turtle is called moved in a direction.

17:30.640 --> 17:32.640
Now, that's immediate feedback to what you typed in.

17:32.640 --> 17:37.640
Now, a lot of programming languages like Fortran or, let's say, many Pascal versions

17:37.640 --> 17:41.640
are what they call compiled languages, and you don't get immediate feedback.

17:41.640 --> 17:45.640
You have to go through an edit step and a compile step and maybe even linkage editing.

17:45.640 --> 17:49.640
And that requires a lot of abstraction, a lot of thinking about what you're doing.

17:49.640 --> 17:53.640
Where languages that are interactive like Logo and Fortran and other interpreters

17:53.640 --> 17:55.640
give you immediate feedback.

17:55.640 --> 18:00.640
Now, the next thing I'm going to load in here is called Blackjack.

18:00.640 --> 18:02.640
And it happens to be a demo program.

18:02.640 --> 18:03.640
It's familiar with that program.

18:03.640 --> 18:04.640
It's familiar with that program.

18:04.640 --> 18:09.640
Now, the reason I'm loading this one, this happens to be an example of how you use turtle graphics

18:09.640 --> 18:12.640
or graphics to draw pictures.

18:12.640 --> 18:17.640
And this particular program was written by a 13-year-old in about three or four days.

18:17.640 --> 18:18.640
Now, it's a rather precocious 13-year-old.

18:18.640 --> 18:19.640
Yeah, you're a son.

18:19.640 --> 18:20.640
Well, no, actually.

18:20.640 --> 18:22.640
It's genetically superior, Gary.

18:22.640 --> 18:24.640
It was actually his friend.

18:24.640 --> 18:33.640
But the point of it is that you can do things like this, like a little game of Blackjack

18:33.640 --> 18:38.640
without a great deal of effort in a language that's interactive and graphical in nature.

18:38.640 --> 18:42.640
One of the nice things about these languages where you define your own words is that you

18:42.640 --> 18:44.640
can make it read fairly close to English.

18:44.640 --> 18:47.640
You can actually pick up a program and read it.

18:47.640 --> 18:48.640
Gary.

18:48.640 --> 18:52.640
Well, you're playing Blackjack there.

18:52.640 --> 18:56.640
Many most new computer users get exposed to BASIC as their kind of language.

18:56.640 --> 18:58.640
And we haven't really talked about that yet.

18:58.640 --> 19:00.640
You're showing how easy it is to do a game like this in Logo.

19:00.640 --> 19:02.640
How is it better than BASIC?

19:02.640 --> 19:04.640
What are the problems in BASIC as a programming language?

19:04.640 --> 19:07.640
Well, BASIC historically came from Fortran.

19:07.640 --> 19:10.640
It has a lot of the original problems of Fortran.

19:10.640 --> 19:15.640
Fortran is one of the, in fact, may have been the very first, I guess, high-level programming language,

19:15.640 --> 19:17.640
recognized high-level programming language.

19:17.640 --> 19:23.640
And so BASIC sort of followed that genealogy and has a scientific orientation to it,

19:23.640 --> 19:30.640
step-by-step breakdown of the problem into simple steps that sometimes,

19:30.640 --> 19:34.640
not really the best way to think about the breaking a problem apart.

19:34.640 --> 19:40.640
Now, Logo came from the MIT Learning Project where they thought about the problem of problem solving itself

19:40.640 --> 19:44.640
and then the language, an underlying language that would be good for that.

19:44.640 --> 19:49.640
So I think BASIC is just, it's an easy language to learn,

19:49.640 --> 19:52.640
but it has its limitations as soon as you start to do anything complicated.

19:52.640 --> 19:59.640
BASIC was designed to be learned quickly by college undergraduates doing very simple things.

19:59.640 --> 20:03.640
It wasn't designed to do either sophisticated programs nor was it designed to grow.

20:03.640 --> 20:11.640
And I think both Fortran and Logo have the capacity to grow in the sense that you can teach them new things.

20:11.640 --> 20:18.640
And there is a learning process going on in the computer or between the programmer and the computer,

20:18.640 --> 20:24.640
which is very similar to the learning process of teaching a small child to do new things.

20:24.640 --> 20:30.640
Well, I think that's interesting with Logo also is that it's sort of a bait-and-switch tactic

20:30.640 --> 20:35.640
in the sense that you sort of get children interested in the language because of the graphics,

20:35.640 --> 20:40.640
because they think of it as a big track that the programmer runs around the floor, in this case a turtle.

20:40.640 --> 20:45.640
But behind it is a language, a LISP, which has been used for years in artificial intelligence

20:45.640 --> 20:49.640
and all the LISP processing that's a part of LISP is also part of Logo.

20:49.640 --> 20:55.640
And so the Fortran LISP shares actually some foundations that are somewhat similar.

20:55.640 --> 20:59.640
Dave, are there any new languages on the horizon or do we have a finite number now?

21:00.640 --> 21:05.640
The last roster of programming languages that I saw had about seven or eight hundred names in it,

21:05.640 --> 21:07.640
and I don't see an end in sight.

21:07.640 --> 21:10.640
A lot of languages are designed for one specific thing.

21:10.640 --> 21:14.640
I guess you'd call them almost a toy language except for the person who invents it.

21:14.640 --> 21:23.640
So most of them are, I think, are offshoots of the main languages like Fortran, Kobal, Algal, or LISP.

21:23.640 --> 21:29.640
And yes, as long as people have ideas for things they want to do, they'll invent a new language.

21:29.640 --> 21:33.640
So it's a kind of evolutionary process, I think all of you said, where one language builds on another language.

21:33.640 --> 21:38.640
Well, I think also it's a matter of getting started as far as learning a language.

21:38.640 --> 21:42.640
Once you've learned one language, it's not very difficult to start picking up other languages,

21:42.640 --> 21:45.640
but it seems to be a threshold to get over the very first time.

21:45.640 --> 21:49.640
So I think that's what an interesting thing about learning languages is that you get started at least.

21:49.640 --> 21:51.640
Okay, well, we started and we're finished.

21:51.640 --> 21:56.640
Thank you very much for being with us, and thank you for joining us in this edition of the Computer Chronicles.

22:19.640 --> 22:29.640
The Computer Chronicles

22:49.640 --> 23:00.640
The Computer Chronicles

