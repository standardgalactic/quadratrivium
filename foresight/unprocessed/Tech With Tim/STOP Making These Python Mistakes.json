{"text": " If you're watching this video and you write code in Python, then chances are you're familiar with what a unique language it is, and you utilize some of the awesome features that Python provides. Now, this is great and Python is an awesome language, but because it is pretty unique and it's not like a lot of the traditional programming languages, there's a lot of ways that you can make mistakes in Python without really realizing it. Python is, as I said, a unique and kind of quirky language. It allows you to do a ton of stuff and it's very flexible, but with that flexibility, it allows you to make a bunch of mistakes that are really hard to catch if you haven't watched a video like this. So with that said, let's get into this video and I'm going to walk you through some mistakes that you're probably making in Python and that you can easily fix by going through these tips. So the first mistake that I'm sure many of you are making is that you haven't checked out my programming course yet called programming expert. I'll leave it in the description. This is a unique course that teaches Python, specifically some more advanced features of Python. And we recently added go to it as a second language. So don't make that mistake. Check that out from the link in the description. But in all seriousness here, the first mistake that you're probably making is something called name shadowing. Now name shadowing occurs when you name your variable parameter function, really anything you're defining a name for a built in function, some built in name or something in the current scope that's already defined. So for example, here, if we have this function called get database record, we have a parameter here called ID. Now this is a shadowed name. And the reason this is shadowed is because you're naming this a built in function. So in Python, we actually have a built in function here called ID. Many people don't know about this function. And so they'll do something like this, where they write a function and then they name this parameter. They give a parameter name of ID. Now you'll notice here, when I write ID, I'm getting the syntax highlighting as if it was a function, because that's what Python knows to do. But this is not going to be treated as a function. It's going to be treated as the parameter. So that is the intended behavior when we're looking at a function like this, but it can be really confusing if you're familiar with the built in functions. And you have kind of a long function or a long class or something like that when you're reading shadowed names. So really you want to avoid name shadowing as much as you can. And one of the only ways to do that in Python, it's just to ensure that you're not naming your parameters, functions, et cetera, a built in name. So something like ID, maybe something like max, that's a really common one, something like min, you want to avoid those names because again, they're built in functions. And if you do name something that in the current scope, so in this function, you can no longer use this as the function. So if I try to do something like ID here, let's just call this function. So get database record. Let's pass in one. Notice it says the int object is not callable because I've overridden the ID function by shadowing its name. Now this can occur when you have nested functions as well in all, and in all kinds of other scenarios. Another really common thing here is when you shadow a name from the global scope. So for example, if I make my parameter here named database, or I accept maybe like ID and database like that. Again, if you have a longer function, it can be confusing when I'm reading this code. If I'm referring to the database parameter, if I spelt that correctly, or the database variable in the global scope. So obviously this isn't always avoidable. The main thing here is just don't name your parameters or variables a built in name like max min ID, not only because it's confusing, but because you also now make it so you can no longer use those functions inside of wherever you've given that name. So another mistake that you are likely unintentionally making in Python is using a mutable object as the default value for an optional parameter. Now, I know that's a mouthful, but if you look here at this function, it's called mutable parameter. And we have an optional parameter. We know it's optional because we have it assigned to a default value. If you don't pass it against the default value and the default value is a mutable object, which is a list. Now, let me show you why this is bad by running the code. So when I run the code, we actually get an unexpected output. If you're from another programming language where we get one, two, one, two, one, two, and then one, two, one, two, one, two. Now, the reason this occurs is because this is mutable. That means we can actually mutate it. We can change it in place. So when I do something like LST dot append one and LST dot append two, I'm actually mutating this list right here, which is the same list that's going to be the default value for the next call to this function. So you can see on every consecutive call, we're actually adding elements to this same list. This list does not get recreated every single time the function is called. It gets created one time when we define the function. That's the way that the, uh, the default value works here. So if you want to avoid this and you do want to actually have a, uh, mutable value or a mutable object as your default parameter, you should do something like this instead and then manually check inside of the function. If this is not, so I'm going to say if LST is none, then I will say LST is equal to and make that a list. So now if I run this notice, we don't get that error anymore because I'm recreating a new list object, every function call as opposed to using the same one that's only created one time when my, uh, program is actually kind of initialized and the function is read by the interpreter. Hopefully that makes a bit of sense. Try not to make this issue or try not to make this mistake. This also happens if you use dictionaries, if you set in any other mutable object. So the next mistake I have here is a more general one. This could apply to any programming language, and this is modifying an iterable object while you're iterating through it. So in this case, I have something that's iterable, which is a list just means I can loop through it, right? Using a for loop in this case, and I have for I comma value in enumerate list. So it's going to give me the value as well as the index of each element. And I'm saying if the index is divisible by two, then I'm going to pop this index from my list. Now, if you're looking at this here, uh, and you just kind of take all the indices and apply this to it. We should be popping one. We should be popping three because that's index two. We should be popping five. That's index four, popping seven, and then popping nine. However, when I run this, notice that I get kind of a weird result. I get two, three, five, six, eight, nine kind of strange why I'm getting that. But the reason is because I'm modifying this iterable object while I'm looping through it. So if I have a look here and I print out I value, and actually let's not print out value. Let's print out I and LST. And let's have a look at it at every iteration. We see I zero and then one, two, three, four, five all the way up until six. And what happens is we don't actually end up iterating through every unique element in the list because we're popping it as we go. And the enumerate function works a little bit differently than the range function in Python. And to show you this, uh, let's do another example. So let's change this now to say for I, and this is going to be in range. And then this will be the length of LST. So you would imagine we just get the exact same result here. But when I run this, notice now we get pop index out of range. Well, the issue here is that we're reducing the length of the list while we're iterating through it. And the range function has kind of a constant range that we're going to be iterating through. So as soon as I define that I'm going to iterate through the range of zero to nine, that doesn't change the whole time I'm going through this for loop. So even if I modify the length of the list, this hasn't changed because I've put a constant value here. Whereas when we have the enumerate, this will actually change based on the length of the list. And again, that's why you get that weird result. So that's what I wanted to share with you. Don't do this. It cause a lot of headaches. Only do this. If you really understand what you're doing. And if you want to make a modification to a list while you're iterating through it, usually what I like to do is store the modifications I want to make somewhere else, iterate through the list entirely one time and then run a for loop and just make those specific iterations that I want to. Hopefully that makes a bit of sense, but that is mistake number three. So the next mistake I have to share with you is one that is super tricky to figure out if you've never seen this before. And this is called name clashing. Now this happens when you name your Python file, which we're going to refer to as a module here, the name of a built in module in Python or a third party module that you've installed using something like PIP. So looking at this example here, I have a little script where I import Pi game. Pi game is a third party Python module. I installed this on my system and this lets me build 2D games. You guys have probably seen this on my channel before. Anyways, I have Pi game. Now when I run this, I get an error and it says this is most likely due to a circular import, but this is only happening in this file. If I throw this in another file, this code will work completely fine. So what's going on here? Well, the issue is I've named my Python module Pi game. So I've named it the thing that I'm trying to import. So what happens is when I try to import Pi game, I'm trying to import the module that I'm currently working in myself. And then I get this error and it's saying it doesn't have the attribute. So to show you how you would fix this, you would rename the file. So let's call this Pi game one now. And when I run this code, notice we no longer get that error and actually pops up a little Pi game screen. Obviously it goes away because I haven't coded anything else out. So be careful about that. Do not name your Python modules, your Python files, a built in module or a module that you're going to be importing or using in your program. So moving on, the next mistake I have for you is using a naked accept. Now here I have a try accept block and this exception or this accept block is going to accept any exception. So if anything happens in here, that's an error that crashes the program, we're going to go in here and print. I crashed. Now that's great. It's useful that we have this feature. The issue is this accepts anything, which means I don't know why I crashed when I'm reading this code and I see this message being printed out. Now this is really bad practice because it makes it really hard to debug your code. Uh, and you just really shouldn't do this. You should handle each individual exception as opposed to just any general exception, uh, kind of for obvious reasons. But in this case, I have two things inside of here that could fail, right? This could fail, trying to open a file in read mode, because if the file doesn't exist, we'll get an exception and then dividing one by zero. Well, zero division, that's an error, no matter what. So two things that could fail. And when I run the code here, all I get is I crashed. So I don't know if it was because I was unable to open the file or because I divided by zero. And now if I delete the file that currently exists, so Tim dot TXT, I have that there and I run this again, I get, I crashed. So of course the solution here is to accept a specific exception and multiple of them if you want to. So you kind of just need to know what the names of these are. You can look them up. You also can just crash your program and see what the exception is. But for now, let's accept the zero division error. So the zero division error is simply called zero division error. You shall also get some syntax highlighting for it. And now I can say I tried to divide by zero dot, dot, dot. Okay. Uh, now let's just comment this line out. Let's run this and then we get, I tried to divide by zero. If I uncomment that and make my new file. So let's save this as Tim dot TXT. You guys put tests inside of there, save and run. Uh, notice that I get, I tried to divide by zero, uh, because I'm accepting the zero division error. This obviously did not have an exception. All right. Now though, if we want to handle both of these exceptions, we can write multiple except blocks. So I can do accept and then I can accept. I think this is the file not found error and I can print out. I could not find the file dot dot dot. So now if I delete the file again, let's delete that. Let's run this. Then I get, I could not find the file. One last thing I will throw in here before I leave. Uh, you also can have as E or as something. Now when I do that, it will actually give me access to the error in the scope. So I can do something like print E. Let's just comment this out now. And then you can actually view what the exception string message is. So keep that in mind. That sometimes can be useful, but please, when you're writing your except blocks, except a specific exception, it will help you later on. So moving on to my next mistake. And this one is using the wrong data structure. Now this is common and you could do this in any programming language, but this is very important in Python because there's a lot of operations that you can perform on a data structure that are very inefficient and that if you were to use a different data structure, you'd have a much more efficient algorithm. And if you're unfamiliar with time complexity, don't worry. That's kind of what I'm referring to here. Really, what we're talking about is how fast can you perform an operation and which data structure or built in type is going to be the best for what it is that you're doing. So in Python, we have really three core data structures you should understand. And that's going to be a list set in dictionary. We have string as well, but I won't put that in here. Anyways, the point is if we're looking at something like a list, a list is used when you care about a ordered collection of elements. So if the order and the frequency of elements that you have is important, then you use a list. There's not really another way to get around that. If you want to store something ordered and you care about the frequency, you use a list. Moving on, we have a set. Now a set is used when you do not care about the frequency or the order of elements. You only care about the presence of elements. So you care if something is in the set or if it's not in the set. Now these two structures have drastically different time complexities in a list. If I wanted to determine if something's inside of it, that's what's known as a big O of end time operation. And that essentially means that I have to look through at most every element in the list. And there could be millions of elements to determine if something is there. Whereas with a set, it's actually pretty much an instant or constant time operation for me to determine if an element is in there. So if there's 10 million elements or a hundred elements, it's going to take relatively the same amount of time for me to determine if an element's in the set. So it's very fast for doing lookups, right? And then you have a dictionary. This is kind of a hybrid. What this allows you to do is store key value pairs. But similarly to a set, this allows you to have constant time lookup and access to an element so I can access an element at a key pretty much instantly. And I can check if an element is in the dictionary. Those are the three different data structures. And you want to use them appropriately because of what I'm about to show you. So I have a list here, for example, and I'll get to these in one second, by the way. And with this list, I can perform all kinds of operations on it. Some are going to be much more efficient than others though. For example, if I want to remove the very last element, I can do pop and that just removes last element. And this is a constant time operation happens very quickly. Time doesn't change depending on the size of the list. However, if I want to remove the first element, this is a big O of end time operation. And this could take a very long amount of time depending on how long the list is. So in this situation, if you know, you need to have an order collection of elements and you want to be say popping something from the middle of the list or the beginning of the list or something along those lines, you should use one of the two data structures I have up here. And sorry, that's from collections. So Python has a built in module. It's called collections. And inside of it, it has something called a deck and a queue. I believe it also has a heap. It has a ton of other data structures that you can use. Now a deck or a DQ, however you say this is a double ended queue and a queue is essentially a first in first out data structure. It acts kind of like a queue that you'd have when you're on the phone, like waiting on hold or something like that. But a double ended queue, essentially all you need to know about the double ended queue is it allows you to remove something from the beginning and the end of it in constant time. So if you know, you want to pop something from say the beginning of a list instead of using a list, just use a queue. It has very similar properties to the list, but it allows you to actually remove elements from the front and from the back of it in constant time. I'm not going to do a whole tutorial on these. I actually think I have some on my channel way, way back. Just wanted to mention though, that there is these built in data structures. They are much more efficient for specific operations. And just be careful which one you're using based on what it is that you actually want to do. So moving on here to my final mistake, and this one is using the global keyword and global variables. Now, if you watch this channel, you should be familiar with why you should not do that. I have an entire video that I posted talking about why not to do this, but I will quickly summarize it here. So this program, very simple. I have a global variable called global var. I have two functions bar and foo. In the first function, I say global global var. That means that I am going to access or whenever I access this name, I'm going to treat it as the global variable. So when I print global var, I'm going to print this. When I say global var is equal to X. I'm going to print this. In fact, let me just say print. And let's go with global var down here. And who's the other point? That's what's happened. Then I have foo and inside of here, I print global var. I define global var equal to X. And then I print global var. Now, first of all, just say guess what you think the output of this program is going to be. Pause the video if you need to. I'm about to run the code. And then I'll talk about kind of the weird stuff that we're getting. So when I run this, you see that we get 10, 20, and then we get an exception. Now, let's talk about this. So what's happening is I'm calling bar. The bar function actually executes fine. And what it does is it prints out 10 and 20. So I'm printing the value of the global variable. I'm then changing global var to be equal to X, which I pass in here as 20. And then I'm printing it again. And of course I'm getting 20 because I've changed this in the global scope. However, when I then go and call foo, what happens here is I get this exception. It says unbounded local error, uh, our local variable global var reference before assignment. Now that is on this line right here. So line, uh, 10. And the reason I'm getting this is because I have actually defined a local variable, global var, uh, inside of this function. And it's kind of weird how Python does this, but essentially, since this is defined down here, when I try to print global var, even though I have a global variable with that name, it's not going to reference that it's going to reference the one in the local scope. And since it's not yet defined, I get an exception. I know kind of weird. One of the reasons, again, you don't really want to be using global variables is because if you try to write a local version of that inside of the function, you're going to get these weird errors when you try to access that value above in the function. Now, if I were to do this, this would work fine. I wouldn't get any issues with that. However, again, since I'm doing this before I am defining this variable, I get that error. So hopefully it makes a bit of sense as to why that is occurring again. Really, it's because I have a local version of my global variable. Whenever I have that in a function, that's what I'm going to be accessing when I use that name. So when I try to access it here, it's not yet defined. Well, that causes an exception. Anyways, that was my final mistake for you guys. I wanted to keep this video nice and short and just quickly give you a few things to help you improve your Python coding. If you enjoyed, make sure you leave a like, subscribe to the channel, and I hope to see you in another YouTube video.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 13.08, "text": " If you're watching this video and you write code in Python, then chances are you're familiar", "tokens": [50364, 759, 291, 434, 1976, 341, 960, 293, 291, 2464, 3089, 294, 15329, 11, 550, 10486, 366, 291, 434, 4963, 51018], "temperature": 0.0, "avg_logprob": -0.12093246273878144, "compression_ratio": 1.669811320754717, "no_speech_prob": 0.5140356421470642}, {"id": 1, "seek": 0, "start": 13.08, "end": 17.0, "text": " with what a unique language it is, and you utilize some of the awesome features that", "tokens": [51018, 365, 437, 257, 3845, 2856, 309, 307, 11, 293, 291, 16117, 512, 295, 264, 3476, 4122, 300, 51214], "temperature": 0.0, "avg_logprob": -0.12093246273878144, "compression_ratio": 1.669811320754717, "no_speech_prob": 0.5140356421470642}, {"id": 2, "seek": 0, "start": 17.0, "end": 21.92, "text": " Python provides. Now, this is great and Python is an awesome language, but because it is", "tokens": [51214, 15329, 6417, 13, 823, 11, 341, 307, 869, 293, 15329, 307, 364, 3476, 2856, 11, 457, 570, 309, 307, 51460], "temperature": 0.0, "avg_logprob": -0.12093246273878144, "compression_ratio": 1.669811320754717, "no_speech_prob": 0.5140356421470642}, {"id": 3, "seek": 0, "start": 21.92, "end": 26.28, "text": " pretty unique and it's not like a lot of the traditional programming languages, there's", "tokens": [51460, 1238, 3845, 293, 309, 311, 406, 411, 257, 688, 295, 264, 5164, 9410, 8650, 11, 456, 311, 51678], "temperature": 0.0, "avg_logprob": -0.12093246273878144, "compression_ratio": 1.669811320754717, "no_speech_prob": 0.5140356421470642}, {"id": 4, "seek": 2628, "start": 26.28, "end": 31.080000000000002, "text": " a lot of ways that you can make mistakes in Python without really realizing it. Python", "tokens": [50364, 257, 688, 295, 2098, 300, 291, 393, 652, 8038, 294, 15329, 1553, 534, 16734, 309, 13, 15329, 50604], "temperature": 0.0, "avg_logprob": -0.09788816757784545, "compression_ratio": 1.8275862068965518, "no_speech_prob": 0.3274812400341034}, {"id": 5, "seek": 2628, "start": 31.080000000000002, "end": 35.64, "text": " is, as I said, a unique and kind of quirky language. It allows you to do a ton of stuff", "tokens": [50604, 307, 11, 382, 286, 848, 11, 257, 3845, 293, 733, 295, 49515, 2856, 13, 467, 4045, 291, 281, 360, 257, 2952, 295, 1507, 50832], "temperature": 0.0, "avg_logprob": -0.09788816757784545, "compression_ratio": 1.8275862068965518, "no_speech_prob": 0.3274812400341034}, {"id": 6, "seek": 2628, "start": 35.64, "end": 40.84, "text": " and it's very flexible, but with that flexibility, it allows you to make a bunch of mistakes", "tokens": [50832, 293, 309, 311, 588, 11358, 11, 457, 365, 300, 12635, 11, 309, 4045, 291, 281, 652, 257, 3840, 295, 8038, 51092], "temperature": 0.0, "avg_logprob": -0.09788816757784545, "compression_ratio": 1.8275862068965518, "no_speech_prob": 0.3274812400341034}, {"id": 7, "seek": 2628, "start": 40.84, "end": 45.44, "text": " that are really hard to catch if you haven't watched a video like this. So with that said,", "tokens": [51092, 300, 366, 534, 1152, 281, 3745, 498, 291, 2378, 380, 6337, 257, 960, 411, 341, 13, 407, 365, 300, 848, 11, 51322], "temperature": 0.0, "avg_logprob": -0.09788816757784545, "compression_ratio": 1.8275862068965518, "no_speech_prob": 0.3274812400341034}, {"id": 8, "seek": 2628, "start": 45.44, "end": 48.52, "text": " let's get into this video and I'm going to walk you through some mistakes that you're", "tokens": [51322, 718, 311, 483, 666, 341, 960, 293, 286, 478, 516, 281, 1792, 291, 807, 512, 8038, 300, 291, 434, 51476], "temperature": 0.0, "avg_logprob": -0.09788816757784545, "compression_ratio": 1.8275862068965518, "no_speech_prob": 0.3274812400341034}, {"id": 9, "seek": 2628, "start": 48.52, "end": 53.400000000000006, "text": " probably making in Python and that you can easily fix by going through these tips. So", "tokens": [51476, 1391, 1455, 294, 15329, 293, 300, 291, 393, 3612, 3191, 538, 516, 807, 613, 6082, 13, 407, 51720], "temperature": 0.0, "avg_logprob": -0.09788816757784545, "compression_ratio": 1.8275862068965518, "no_speech_prob": 0.3274812400341034}, {"id": 10, "seek": 5340, "start": 53.4, "end": 56.44, "text": " the first mistake that I'm sure many of you are making is that you haven't checked out", "tokens": [50364, 264, 700, 6146, 300, 286, 478, 988, 867, 295, 291, 366, 1455, 307, 300, 291, 2378, 380, 10033, 484, 50516], "temperature": 0.0, "avg_logprob": -0.12240529231887927, "compression_ratio": 1.8150289017341041, "no_speech_prob": 0.02033075876533985}, {"id": 11, "seek": 5340, "start": 56.44, "end": 60.839999999999996, "text": " my programming course yet called programming expert. I'll leave it in the description.", "tokens": [50516, 452, 9410, 1164, 1939, 1219, 9410, 5844, 13, 286, 603, 1856, 309, 294, 264, 3855, 13, 50736], "temperature": 0.0, "avg_logprob": -0.12240529231887927, "compression_ratio": 1.8150289017341041, "no_speech_prob": 0.02033075876533985}, {"id": 12, "seek": 5340, "start": 60.839999999999996, "end": 64.67999999999999, "text": " This is a unique course that teaches Python, specifically some more advanced features of", "tokens": [50736, 639, 307, 257, 3845, 1164, 300, 16876, 15329, 11, 4682, 512, 544, 7339, 4122, 295, 50928], "temperature": 0.0, "avg_logprob": -0.12240529231887927, "compression_ratio": 1.8150289017341041, "no_speech_prob": 0.02033075876533985}, {"id": 13, "seek": 5340, "start": 64.67999999999999, "end": 69.44, "text": " Python. And we recently added go to it as a second language. So don't make that mistake.", "tokens": [50928, 15329, 13, 400, 321, 3938, 3869, 352, 281, 309, 382, 257, 1150, 2856, 13, 407, 500, 380, 652, 300, 6146, 13, 51166], "temperature": 0.0, "avg_logprob": -0.12240529231887927, "compression_ratio": 1.8150289017341041, "no_speech_prob": 0.02033075876533985}, {"id": 14, "seek": 5340, "start": 69.44, "end": 73.24, "text": " Check that out from the link in the description. But in all seriousness here, the first mistake", "tokens": [51166, 6881, 300, 484, 490, 264, 2113, 294, 264, 3855, 13, 583, 294, 439, 44880, 510, 11, 264, 700, 6146, 51356], "temperature": 0.0, "avg_logprob": -0.12240529231887927, "compression_ratio": 1.8150289017341041, "no_speech_prob": 0.02033075876533985}, {"id": 15, "seek": 5340, "start": 73.24, "end": 77.64, "text": " that you're probably making is something called name shadowing. Now name shadowing occurs", "tokens": [51356, 300, 291, 434, 1391, 1455, 307, 746, 1219, 1315, 8576, 278, 13, 823, 1315, 8576, 278, 11843, 51576], "temperature": 0.0, "avg_logprob": -0.12240529231887927, "compression_ratio": 1.8150289017341041, "no_speech_prob": 0.02033075876533985}, {"id": 16, "seek": 5340, "start": 77.64, "end": 82.68, "text": " when you name your variable parameter function, really anything you're defining a name for", "tokens": [51576, 562, 291, 1315, 428, 7006, 13075, 2445, 11, 534, 1340, 291, 434, 17827, 257, 1315, 337, 51828], "temperature": 0.0, "avg_logprob": -0.12240529231887927, "compression_ratio": 1.8150289017341041, "no_speech_prob": 0.02033075876533985}, {"id": 17, "seek": 8268, "start": 82.68, "end": 87.84, "text": " a built in function, some built in name or something in the current scope that's already", "tokens": [50364, 257, 3094, 294, 2445, 11, 512, 3094, 294, 1315, 420, 746, 294, 264, 2190, 11923, 300, 311, 1217, 50622], "temperature": 0.0, "avg_logprob": -0.12014339506164078, "compression_ratio": 1.9452554744525548, "no_speech_prob": 0.12588603794574738}, {"id": 18, "seek": 8268, "start": 87.84, "end": 92.64000000000001, "text": " defined. So for example, here, if we have this function called get database record,", "tokens": [50622, 7642, 13, 407, 337, 1365, 11, 510, 11, 498, 321, 362, 341, 2445, 1219, 483, 8149, 2136, 11, 50862], "temperature": 0.0, "avg_logprob": -0.12014339506164078, "compression_ratio": 1.9452554744525548, "no_speech_prob": 0.12588603794574738}, {"id": 19, "seek": 8268, "start": 92.64000000000001, "end": 97.42, "text": " we have a parameter here called ID. Now this is a shadowed name. And the reason this is", "tokens": [50862, 321, 362, 257, 13075, 510, 1219, 7348, 13, 823, 341, 307, 257, 8576, 292, 1315, 13, 400, 264, 1778, 341, 307, 51101], "temperature": 0.0, "avg_logprob": -0.12014339506164078, "compression_ratio": 1.9452554744525548, "no_speech_prob": 0.12588603794574738}, {"id": 20, "seek": 8268, "start": 97.42, "end": 102.52000000000001, "text": " shadowed is because you're naming this a built in function. So in Python, we actually have", "tokens": [51101, 8576, 292, 307, 570, 291, 434, 25290, 341, 257, 3094, 294, 2445, 13, 407, 294, 15329, 11, 321, 767, 362, 51356], "temperature": 0.0, "avg_logprob": -0.12014339506164078, "compression_ratio": 1.9452554744525548, "no_speech_prob": 0.12588603794574738}, {"id": 21, "seek": 8268, "start": 102.52000000000001, "end": 106.92000000000002, "text": " a built in function here called ID. Many people don't know about this function. And", "tokens": [51356, 257, 3094, 294, 2445, 510, 1219, 7348, 13, 5126, 561, 500, 380, 458, 466, 341, 2445, 13, 400, 51576], "temperature": 0.0, "avg_logprob": -0.12014339506164078, "compression_ratio": 1.9452554744525548, "no_speech_prob": 0.12588603794574738}, {"id": 22, "seek": 8268, "start": 106.92000000000002, "end": 111.56, "text": " so they'll do something like this, where they write a function and then they name this parameter.", "tokens": [51576, 370, 436, 603, 360, 746, 411, 341, 11, 689, 436, 2464, 257, 2445, 293, 550, 436, 1315, 341, 13075, 13, 51808], "temperature": 0.0, "avg_logprob": -0.12014339506164078, "compression_ratio": 1.9452554744525548, "no_speech_prob": 0.12588603794574738}, {"id": 23, "seek": 11156, "start": 111.56, "end": 115.8, "text": " They give a parameter name of ID. Now you'll notice here, when I write ID, I'm getting", "tokens": [50364, 814, 976, 257, 13075, 1315, 295, 7348, 13, 823, 291, 603, 3449, 510, 11, 562, 286, 2464, 7348, 11, 286, 478, 1242, 50576], "temperature": 0.0, "avg_logprob": -0.11592528758904873, "compression_ratio": 1.8115942028985508, "no_speech_prob": 0.10085858404636383}, {"id": 24, "seek": 11156, "start": 115.8, "end": 120.76, "text": " the syntax highlighting as if it was a function, because that's what Python knows to do. But", "tokens": [50576, 264, 28431, 26551, 382, 498, 309, 390, 257, 2445, 11, 570, 300, 311, 437, 15329, 3255, 281, 360, 13, 583, 50824], "temperature": 0.0, "avg_logprob": -0.11592528758904873, "compression_ratio": 1.8115942028985508, "no_speech_prob": 0.10085858404636383}, {"id": 25, "seek": 11156, "start": 120.76, "end": 124.84, "text": " this is not going to be treated as a function. It's going to be treated as the parameter.", "tokens": [50824, 341, 307, 406, 516, 281, 312, 8668, 382, 257, 2445, 13, 467, 311, 516, 281, 312, 8668, 382, 264, 13075, 13, 51028], "temperature": 0.0, "avg_logprob": -0.11592528758904873, "compression_ratio": 1.8115942028985508, "no_speech_prob": 0.10085858404636383}, {"id": 26, "seek": 11156, "start": 124.84, "end": 128.12, "text": " So that is the intended behavior when we're looking at a function like this, but it can", "tokens": [51028, 407, 300, 307, 264, 10226, 5223, 562, 321, 434, 1237, 412, 257, 2445, 411, 341, 11, 457, 309, 393, 51192], "temperature": 0.0, "avg_logprob": -0.11592528758904873, "compression_ratio": 1.8115942028985508, "no_speech_prob": 0.10085858404636383}, {"id": 27, "seek": 11156, "start": 128.12, "end": 132.24, "text": " be really confusing if you're familiar with the built in functions. And you have kind", "tokens": [51192, 312, 534, 13181, 498, 291, 434, 4963, 365, 264, 3094, 294, 6828, 13, 400, 291, 362, 733, 51398], "temperature": 0.0, "avg_logprob": -0.11592528758904873, "compression_ratio": 1.8115942028985508, "no_speech_prob": 0.10085858404636383}, {"id": 28, "seek": 11156, "start": 132.24, "end": 137.28, "text": " of a long function or a long class or something like that when you're reading shadowed names.", "tokens": [51398, 295, 257, 938, 2445, 420, 257, 938, 1508, 420, 746, 411, 300, 562, 291, 434, 3760, 8576, 292, 5288, 13, 51650], "temperature": 0.0, "avg_logprob": -0.11592528758904873, "compression_ratio": 1.8115942028985508, "no_speech_prob": 0.10085858404636383}, {"id": 29, "seek": 11156, "start": 137.28, "end": 140.9, "text": " So really you want to avoid name shadowing as much as you can. And one of the only ways", "tokens": [51650, 407, 534, 291, 528, 281, 5042, 1315, 8576, 278, 382, 709, 382, 291, 393, 13, 400, 472, 295, 264, 787, 2098, 51831], "temperature": 0.0, "avg_logprob": -0.11592528758904873, "compression_ratio": 1.8115942028985508, "no_speech_prob": 0.10085858404636383}, {"id": 30, "seek": 14090, "start": 140.92000000000002, "end": 145.26000000000002, "text": " to do that in Python, it's just to ensure that you're not naming your parameters, functions,", "tokens": [50365, 281, 360, 300, 294, 15329, 11, 309, 311, 445, 281, 5586, 300, 291, 434, 406, 25290, 428, 9834, 11, 6828, 11, 50582], "temperature": 0.0, "avg_logprob": -0.15198523756386578, "compression_ratio": 1.8916083916083917, "no_speech_prob": 0.04885188490152359}, {"id": 31, "seek": 14090, "start": 145.26000000000002, "end": 150.54000000000002, "text": " et cetera, a built in name. So something like ID, maybe something like max, that's a really", "tokens": [50582, 1030, 11458, 11, 257, 3094, 294, 1315, 13, 407, 746, 411, 7348, 11, 1310, 746, 411, 11469, 11, 300, 311, 257, 534, 50846], "temperature": 0.0, "avg_logprob": -0.15198523756386578, "compression_ratio": 1.8916083916083917, "no_speech_prob": 0.04885188490152359}, {"id": 32, "seek": 14090, "start": 150.54000000000002, "end": 155.14000000000001, "text": " common one, something like min, you want to avoid those names because again, they're built", "tokens": [50846, 2689, 472, 11, 746, 411, 923, 11, 291, 528, 281, 5042, 729, 5288, 570, 797, 11, 436, 434, 3094, 51076], "temperature": 0.0, "avg_logprob": -0.15198523756386578, "compression_ratio": 1.8916083916083917, "no_speech_prob": 0.04885188490152359}, {"id": 33, "seek": 14090, "start": 155.14000000000001, "end": 159.84, "text": " in functions. And if you do name something that in the current scope, so in this function,", "tokens": [51076, 294, 6828, 13, 400, 498, 291, 360, 1315, 746, 300, 294, 264, 2190, 11923, 11, 370, 294, 341, 2445, 11, 51311], "temperature": 0.0, "avg_logprob": -0.15198523756386578, "compression_ratio": 1.8916083916083917, "no_speech_prob": 0.04885188490152359}, {"id": 34, "seek": 14090, "start": 159.84, "end": 165.02, "text": " you can no longer use this as the function. So if I try to do something like ID here,", "tokens": [51311, 291, 393, 572, 2854, 764, 341, 382, 264, 2445, 13, 407, 498, 286, 853, 281, 360, 746, 411, 7348, 510, 11, 51570], "temperature": 0.0, "avg_logprob": -0.15198523756386578, "compression_ratio": 1.8916083916083917, "no_speech_prob": 0.04885188490152359}, {"id": 35, "seek": 14090, "start": 165.02, "end": 169.82, "text": " let's just call this function. So get database record. Let's pass in one. Notice it says", "tokens": [51570, 718, 311, 445, 818, 341, 2445, 13, 407, 483, 8149, 2136, 13, 961, 311, 1320, 294, 472, 13, 13428, 309, 1619, 51810], "temperature": 0.0, "avg_logprob": -0.15198523756386578, "compression_ratio": 1.8916083916083917, "no_speech_prob": 0.04885188490152359}, {"id": 36, "seek": 16982, "start": 169.85999999999999, "end": 174.98, "text": " the int object is not callable because I've overridden the ID function by shadowing its", "tokens": [50366, 264, 560, 2657, 307, 406, 818, 712, 570, 286, 600, 670, 81, 6171, 264, 7348, 2445, 538, 8576, 278, 1080, 50622], "temperature": 0.0, "avg_logprob": -0.11062784840289812, "compression_ratio": 1.7740863787375416, "no_speech_prob": 0.020330365747213364}, {"id": 37, "seek": 16982, "start": 174.98, "end": 179.73999999999998, "text": " name. Now this can occur when you have nested functions as well in all, and in all kinds", "tokens": [50622, 1315, 13, 823, 341, 393, 5160, 562, 291, 362, 15646, 292, 6828, 382, 731, 294, 439, 11, 293, 294, 439, 3685, 50860], "temperature": 0.0, "avg_logprob": -0.11062784840289812, "compression_ratio": 1.7740863787375416, "no_speech_prob": 0.020330365747213364}, {"id": 38, "seek": 16982, "start": 179.73999999999998, "end": 183.66, "text": " of other scenarios. Another really common thing here is when you shadow a name from", "tokens": [50860, 295, 661, 15077, 13, 3996, 534, 2689, 551, 510, 307, 562, 291, 8576, 257, 1315, 490, 51056], "temperature": 0.0, "avg_logprob": -0.11062784840289812, "compression_ratio": 1.7740863787375416, "no_speech_prob": 0.020330365747213364}, {"id": 39, "seek": 16982, "start": 183.66, "end": 189.9, "text": " the global scope. So for example, if I make my parameter here named database, or I accept", "tokens": [51056, 264, 4338, 11923, 13, 407, 337, 1365, 11, 498, 286, 652, 452, 13075, 510, 4926, 8149, 11, 420, 286, 3241, 51368], "temperature": 0.0, "avg_logprob": -0.11062784840289812, "compression_ratio": 1.7740863787375416, "no_speech_prob": 0.020330365747213364}, {"id": 40, "seek": 16982, "start": 189.9, "end": 195.7, "text": " maybe like ID and database like that. Again, if you have a longer function, it can be confusing", "tokens": [51368, 1310, 411, 7348, 293, 8149, 411, 300, 13, 3764, 11, 498, 291, 362, 257, 2854, 2445, 11, 309, 393, 312, 13181, 51658], "temperature": 0.0, "avg_logprob": -0.11062784840289812, "compression_ratio": 1.7740863787375416, "no_speech_prob": 0.020330365747213364}, {"id": 41, "seek": 16982, "start": 195.7, "end": 199.74, "text": " when I'm reading this code. If I'm referring to the database parameter, if I spelt that", "tokens": [51658, 562, 286, 478, 3760, 341, 3089, 13, 759, 286, 478, 13761, 281, 264, 8149, 13075, 11, 498, 286, 637, 2018, 300, 51860], "temperature": 0.0, "avg_logprob": -0.11062784840289812, "compression_ratio": 1.7740863787375416, "no_speech_prob": 0.020330365747213364}, {"id": 42, "seek": 19974, "start": 199.78, "end": 204.58, "text": " correctly, or the database variable in the global scope. So obviously this isn't always", "tokens": [50366, 8944, 11, 420, 264, 8149, 7006, 294, 264, 4338, 11923, 13, 407, 2745, 341, 1943, 380, 1009, 50606], "temperature": 0.0, "avg_logprob": -0.10211427943913017, "compression_ratio": 1.6728971962616823, "no_speech_prob": 0.0022516916505992413}, {"id": 43, "seek": 19974, "start": 204.58, "end": 208.78, "text": " avoidable. The main thing here is just don't name your parameters or variables a built", "tokens": [50606, 5042, 712, 13, 440, 2135, 551, 510, 307, 445, 500, 380, 1315, 428, 9834, 420, 9102, 257, 3094, 50816], "temperature": 0.0, "avg_logprob": -0.10211427943913017, "compression_ratio": 1.6728971962616823, "no_speech_prob": 0.0022516916505992413}, {"id": 44, "seek": 19974, "start": 208.78, "end": 214.02, "text": " in name like max min ID, not only because it's confusing, but because you also now", "tokens": [50816, 294, 1315, 411, 11469, 923, 7348, 11, 406, 787, 570, 309, 311, 13181, 11, 457, 570, 291, 611, 586, 51078], "temperature": 0.0, "avg_logprob": -0.10211427943913017, "compression_ratio": 1.6728971962616823, "no_speech_prob": 0.0022516916505992413}, {"id": 45, "seek": 19974, "start": 214.02, "end": 218.9, "text": " make it so you can no longer use those functions inside of wherever you've given that name.", "tokens": [51078, 652, 309, 370, 291, 393, 572, 2854, 764, 729, 6828, 1854, 295, 8660, 291, 600, 2212, 300, 1315, 13, 51322], "temperature": 0.0, "avg_logprob": -0.10211427943913017, "compression_ratio": 1.6728971962616823, "no_speech_prob": 0.0022516916505992413}, {"id": 46, "seek": 19974, "start": 218.9, "end": 224.34, "text": " So another mistake that you are likely unintentionally making in Python is using a mutable object", "tokens": [51322, 407, 1071, 6146, 300, 291, 366, 3700, 45514, 379, 1455, 294, 15329, 307, 1228, 257, 5839, 712, 2657, 51594], "temperature": 0.0, "avg_logprob": -0.10211427943913017, "compression_ratio": 1.6728971962616823, "no_speech_prob": 0.0022516916505992413}, {"id": 47, "seek": 19974, "start": 224.34, "end": 228.94, "text": " as the default value for an optional parameter. Now, I know that's a mouthful, but if you", "tokens": [51594, 382, 264, 7576, 2158, 337, 364, 17312, 13075, 13, 823, 11, 286, 458, 300, 311, 257, 4525, 906, 11, 457, 498, 291, 51824], "temperature": 0.0, "avg_logprob": -0.10211427943913017, "compression_ratio": 1.6728971962616823, "no_speech_prob": 0.0022516916505992413}, {"id": 48, "seek": 22894, "start": 228.98, "end": 233.38, "text": " look here at this function, it's called mutable parameter. And we have an optional parameter.", "tokens": [50366, 574, 510, 412, 341, 2445, 11, 309, 311, 1219, 5839, 712, 13075, 13, 400, 321, 362, 364, 17312, 13075, 13, 50586], "temperature": 0.0, "avg_logprob": -0.11253783437940809, "compression_ratio": 1.8975265017667844, "no_speech_prob": 0.04741789773106575}, {"id": 49, "seek": 22894, "start": 233.38, "end": 237.7, "text": " We know it's optional because we have it assigned to a default value. If you don't pass it against", "tokens": [50586, 492, 458, 309, 311, 17312, 570, 321, 362, 309, 13279, 281, 257, 7576, 2158, 13, 759, 291, 500, 380, 1320, 309, 1970, 50802], "temperature": 0.0, "avg_logprob": -0.11253783437940809, "compression_ratio": 1.8975265017667844, "no_speech_prob": 0.04741789773106575}, {"id": 50, "seek": 22894, "start": 237.7, "end": 242.98, "text": " the default value and the default value is a mutable object, which is a list. Now, let", "tokens": [50802, 264, 7576, 2158, 293, 264, 7576, 2158, 307, 257, 5839, 712, 2657, 11, 597, 307, 257, 1329, 13, 823, 11, 718, 51066], "temperature": 0.0, "avg_logprob": -0.11253783437940809, "compression_ratio": 1.8975265017667844, "no_speech_prob": 0.04741789773106575}, {"id": 51, "seek": 22894, "start": 242.98, "end": 247.5, "text": " me show you why this is bad by running the code. So when I run the code, we actually", "tokens": [51066, 385, 855, 291, 983, 341, 307, 1578, 538, 2614, 264, 3089, 13, 407, 562, 286, 1190, 264, 3089, 11, 321, 767, 51292], "temperature": 0.0, "avg_logprob": -0.11253783437940809, "compression_ratio": 1.8975265017667844, "no_speech_prob": 0.04741789773106575}, {"id": 52, "seek": 22894, "start": 247.5, "end": 251.34, "text": " get an unexpected output. If you're from another programming language where we get", "tokens": [51292, 483, 364, 13106, 5598, 13, 759, 291, 434, 490, 1071, 9410, 2856, 689, 321, 483, 51484], "temperature": 0.0, "avg_logprob": -0.11253783437940809, "compression_ratio": 1.8975265017667844, "no_speech_prob": 0.04741789773106575}, {"id": 53, "seek": 22894, "start": 251.34, "end": 255.86, "text": " one, two, one, two, one, two, and then one, two, one, two, one, two. Now, the reason this", "tokens": [51484, 472, 11, 732, 11, 472, 11, 732, 11, 472, 11, 732, 11, 293, 550, 472, 11, 732, 11, 472, 11, 732, 11, 472, 11, 732, 13, 823, 11, 264, 1778, 341, 51710], "temperature": 0.0, "avg_logprob": -0.11253783437940809, "compression_ratio": 1.8975265017667844, "no_speech_prob": 0.04741789773106575}, {"id": 54, "seek": 25586, "start": 255.9, "end": 260.62, "text": " occurs is because this is mutable. That means we can actually mutate it. We can change it", "tokens": [50366, 11843, 307, 570, 341, 307, 5839, 712, 13, 663, 1355, 321, 393, 767, 5839, 473, 309, 13, 492, 393, 1319, 309, 50602], "temperature": 0.0, "avg_logprob": -0.09892315147197352, "compression_ratio": 1.7431906614785992, "no_speech_prob": 0.41470345854759216}, {"id": 55, "seek": 25586, "start": 260.62, "end": 265.5, "text": " in place. So when I do something like LST dot append one and LST dot append two, I'm", "tokens": [50602, 294, 1081, 13, 407, 562, 286, 360, 746, 411, 441, 6840, 5893, 34116, 472, 293, 441, 6840, 5893, 34116, 732, 11, 286, 478, 50846], "temperature": 0.0, "avg_logprob": -0.09892315147197352, "compression_ratio": 1.7431906614785992, "no_speech_prob": 0.41470345854759216}, {"id": 56, "seek": 25586, "start": 265.5, "end": 271.3, "text": " actually mutating this list right here, which is the same list that's going to be the default", "tokens": [50846, 767, 5839, 990, 341, 1329, 558, 510, 11, 597, 307, 264, 912, 1329, 300, 311, 516, 281, 312, 264, 7576, 51136], "temperature": 0.0, "avg_logprob": -0.09892315147197352, "compression_ratio": 1.7431906614785992, "no_speech_prob": 0.41470345854759216}, {"id": 57, "seek": 25586, "start": 271.3, "end": 276.74, "text": " value for the next call to this function. So you can see on every consecutive call, we're", "tokens": [51136, 2158, 337, 264, 958, 818, 281, 341, 2445, 13, 407, 291, 393, 536, 322, 633, 30497, 818, 11, 321, 434, 51408], "temperature": 0.0, "avg_logprob": -0.09892315147197352, "compression_ratio": 1.7431906614785992, "no_speech_prob": 0.41470345854759216}, {"id": 58, "seek": 25586, "start": 276.74, "end": 282.14, "text": " actually adding elements to this same list. This list does not get recreated every single", "tokens": [51408, 767, 5127, 4959, 281, 341, 912, 1329, 13, 639, 1329, 775, 406, 483, 850, 26559, 633, 2167, 51678], "temperature": 0.0, "avg_logprob": -0.09892315147197352, "compression_ratio": 1.7431906614785992, "no_speech_prob": 0.41470345854759216}, {"id": 59, "seek": 28214, "start": 282.14, "end": 287.41999999999996, "text": " time the function is called. It gets created one time when we define the function. That's", "tokens": [50364, 565, 264, 2445, 307, 1219, 13, 467, 2170, 2942, 472, 565, 562, 321, 6964, 264, 2445, 13, 663, 311, 50628], "temperature": 0.0, "avg_logprob": -0.1175638916146042, "compression_ratio": 1.7588932806324111, "no_speech_prob": 0.03308267518877983}, {"id": 60, "seek": 28214, "start": 287.41999999999996, "end": 291.3, "text": " the way that the, uh, the default value works here. So if you want to avoid this and you", "tokens": [50628, 264, 636, 300, 264, 11, 2232, 11, 264, 7576, 2158, 1985, 510, 13, 407, 498, 291, 528, 281, 5042, 341, 293, 291, 50822], "temperature": 0.0, "avg_logprob": -0.1175638916146042, "compression_ratio": 1.7588932806324111, "no_speech_prob": 0.03308267518877983}, {"id": 61, "seek": 28214, "start": 291.3, "end": 297.18, "text": " do want to actually have a, uh, mutable value or a mutable object as your default parameter,", "tokens": [50822, 360, 528, 281, 767, 362, 257, 11, 2232, 11, 5839, 712, 2158, 420, 257, 5839, 712, 2657, 382, 428, 7576, 13075, 11, 51116], "temperature": 0.0, "avg_logprob": -0.1175638916146042, "compression_ratio": 1.7588932806324111, "no_speech_prob": 0.03308267518877983}, {"id": 62, "seek": 28214, "start": 297.18, "end": 301.82, "text": " you should do something like this instead and then manually check inside of the function.", "tokens": [51116, 291, 820, 360, 746, 411, 341, 2602, 293, 550, 16945, 1520, 1854, 295, 264, 2445, 13, 51348], "temperature": 0.0, "avg_logprob": -0.1175638916146042, "compression_ratio": 1.7588932806324111, "no_speech_prob": 0.03308267518877983}, {"id": 63, "seek": 28214, "start": 301.82, "end": 308.34, "text": " If this is not, so I'm going to say if LST is none, then I will say LST is equal to", "tokens": [51348, 759, 341, 307, 406, 11, 370, 286, 478, 516, 281, 584, 498, 441, 6840, 307, 6022, 11, 550, 286, 486, 584, 441, 6840, 307, 2681, 281, 51674], "temperature": 0.0, "avg_logprob": -0.1175638916146042, "compression_ratio": 1.7588932806324111, "no_speech_prob": 0.03308267518877983}, {"id": 64, "seek": 30834, "start": 308.46, "end": 312.78, "text": " and make that a list. So now if I run this notice, we don't get that error anymore because", "tokens": [50370, 293, 652, 300, 257, 1329, 13, 407, 586, 498, 286, 1190, 341, 3449, 11, 321, 500, 380, 483, 300, 6713, 3602, 570, 50586], "temperature": 0.0, "avg_logprob": -0.11989942718954648, "compression_ratio": 1.7275641025641026, "no_speech_prob": 0.584932267665863}, {"id": 65, "seek": 30834, "start": 312.78, "end": 319.02, "text": " I'm recreating a new list object, every function call as opposed to using the same one that's", "tokens": [50586, 286, 478, 850, 44613, 257, 777, 1329, 2657, 11, 633, 2445, 818, 382, 8851, 281, 1228, 264, 912, 472, 300, 311, 50898], "temperature": 0.0, "avg_logprob": -0.11989942718954648, "compression_ratio": 1.7275641025641026, "no_speech_prob": 0.584932267665863}, {"id": 66, "seek": 30834, "start": 319.02, "end": 323.62, "text": " only created one time when my, uh, program is actually kind of initialized and the function", "tokens": [50898, 787, 2942, 472, 565, 562, 452, 11, 2232, 11, 1461, 307, 767, 733, 295, 5883, 1602, 293, 264, 2445, 51128], "temperature": 0.0, "avg_logprob": -0.11989942718954648, "compression_ratio": 1.7275641025641026, "no_speech_prob": 0.584932267665863}, {"id": 67, "seek": 30834, "start": 323.62, "end": 327.38, "text": " is read by the interpreter. Hopefully that makes a bit of sense. Try not to make this", "tokens": [51128, 307, 1401, 538, 264, 34132, 13, 10429, 300, 1669, 257, 857, 295, 2020, 13, 6526, 406, 281, 652, 341, 51316], "temperature": 0.0, "avg_logprob": -0.11989942718954648, "compression_ratio": 1.7275641025641026, "no_speech_prob": 0.584932267665863}, {"id": 68, "seek": 30834, "start": 327.38, "end": 331.65999999999997, "text": " issue or try not to make this mistake. This also happens if you use dictionaries, if you", "tokens": [51316, 2734, 420, 853, 406, 281, 652, 341, 6146, 13, 639, 611, 2314, 498, 291, 764, 22352, 4889, 11, 498, 291, 51530], "temperature": 0.0, "avg_logprob": -0.11989942718954648, "compression_ratio": 1.7275641025641026, "no_speech_prob": 0.584932267665863}, {"id": 69, "seek": 30834, "start": 331.65999999999997, "end": 336.7, "text": " set in any other mutable object. So the next mistake I have here is a more general one.", "tokens": [51530, 992, 294, 604, 661, 5839, 712, 2657, 13, 407, 264, 958, 6146, 286, 362, 510, 307, 257, 544, 2674, 472, 13, 51782], "temperature": 0.0, "avg_logprob": -0.11989942718954648, "compression_ratio": 1.7275641025641026, "no_speech_prob": 0.584932267665863}, {"id": 70, "seek": 33670, "start": 336.74, "end": 341.65999999999997, "text": " This could apply to any programming language, and this is modifying an iterable object while", "tokens": [50366, 639, 727, 3079, 281, 604, 9410, 2856, 11, 293, 341, 307, 42626, 364, 17138, 712, 2657, 1339, 50612], "temperature": 0.0, "avg_logprob": -0.13995440252896013, "compression_ratio": 1.8047138047138047, "no_speech_prob": 0.03963465988636017}, {"id": 71, "seek": 33670, "start": 341.65999999999997, "end": 345.38, "text": " you're iterating through it. So in this case, I have something that's iterable, which is", "tokens": [50612, 291, 434, 17138, 990, 807, 309, 13, 407, 294, 341, 1389, 11, 286, 362, 746, 300, 311, 17138, 712, 11, 597, 307, 50798], "temperature": 0.0, "avg_logprob": -0.13995440252896013, "compression_ratio": 1.8047138047138047, "no_speech_prob": 0.03963465988636017}, {"id": 72, "seek": 33670, "start": 345.38, "end": 349.5, "text": " a list just means I can loop through it, right? Using a for loop in this case, and I have", "tokens": [50798, 257, 1329, 445, 1355, 286, 393, 6367, 807, 309, 11, 558, 30, 11142, 257, 337, 6367, 294, 341, 1389, 11, 293, 286, 362, 51004], "temperature": 0.0, "avg_logprob": -0.13995440252896013, "compression_ratio": 1.8047138047138047, "no_speech_prob": 0.03963465988636017}, {"id": 73, "seek": 33670, "start": 349.5, "end": 353.46, "text": " for I comma value in enumerate list. So it's going to give me the value as well as the", "tokens": [51004, 337, 286, 22117, 2158, 294, 465, 15583, 473, 1329, 13, 407, 309, 311, 516, 281, 976, 385, 264, 2158, 382, 731, 382, 264, 51202], "temperature": 0.0, "avg_logprob": -0.13995440252896013, "compression_ratio": 1.8047138047138047, "no_speech_prob": 0.03963465988636017}, {"id": 74, "seek": 33670, "start": 353.46, "end": 358.65999999999997, "text": " index of each element. And I'm saying if the index is divisible by two, then I'm going", "tokens": [51202, 8186, 295, 1184, 4478, 13, 400, 286, 478, 1566, 498, 264, 8186, 307, 25974, 964, 538, 732, 11, 550, 286, 478, 516, 51462], "temperature": 0.0, "avg_logprob": -0.13995440252896013, "compression_ratio": 1.8047138047138047, "no_speech_prob": 0.03963465988636017}, {"id": 75, "seek": 33670, "start": 358.65999999999997, "end": 363.41999999999996, "text": " to pop this index from my list. Now, if you're looking at this here, uh, and you just kind", "tokens": [51462, 281, 1665, 341, 8186, 490, 452, 1329, 13, 823, 11, 498, 291, 434, 1237, 412, 341, 510, 11, 2232, 11, 293, 291, 445, 733, 51700], "temperature": 0.0, "avg_logprob": -0.13995440252896013, "compression_ratio": 1.8047138047138047, "no_speech_prob": 0.03963465988636017}, {"id": 76, "seek": 36342, "start": 363.42, "end": 368.14000000000004, "text": " of take all the indices and apply this to it. We should be popping one. We should be", "tokens": [50364, 295, 747, 439, 264, 43840, 293, 3079, 341, 281, 309, 13, 492, 820, 312, 18374, 472, 13, 492, 820, 312, 50600], "temperature": 0.0, "avg_logprob": -0.15419946867844153, "compression_ratio": 1.8416666666666666, "no_speech_prob": 0.06953081488609314}, {"id": 77, "seek": 36342, "start": 368.14000000000004, "end": 372.90000000000003, "text": " popping three because that's index two. We should be popping five. That's index four,", "tokens": [50600, 18374, 1045, 570, 300, 311, 8186, 732, 13, 492, 820, 312, 18374, 1732, 13, 663, 311, 8186, 1451, 11, 50838], "temperature": 0.0, "avg_logprob": -0.15419946867844153, "compression_ratio": 1.8416666666666666, "no_speech_prob": 0.06953081488609314}, {"id": 78, "seek": 36342, "start": 372.90000000000003, "end": 377.78000000000003, "text": " popping seven, and then popping nine. However, when I run this, notice that I get kind of", "tokens": [50838, 18374, 3407, 11, 293, 550, 18374, 4949, 13, 2908, 11, 562, 286, 1190, 341, 11, 3449, 300, 286, 483, 733, 295, 51082], "temperature": 0.0, "avg_logprob": -0.15419946867844153, "compression_ratio": 1.8416666666666666, "no_speech_prob": 0.06953081488609314}, {"id": 79, "seek": 36342, "start": 377.78000000000003, "end": 383.5, "text": " a weird result. I get two, three, five, six, eight, nine kind of strange why I'm getting", "tokens": [51082, 257, 3657, 1874, 13, 286, 483, 732, 11, 1045, 11, 1732, 11, 2309, 11, 3180, 11, 4949, 733, 295, 5861, 983, 286, 478, 1242, 51368], "temperature": 0.0, "avg_logprob": -0.15419946867844153, "compression_ratio": 1.8416666666666666, "no_speech_prob": 0.06953081488609314}, {"id": 80, "seek": 36342, "start": 383.5, "end": 388.70000000000005, "text": " that. But the reason is because I'm modifying this iterable object while I'm looping through", "tokens": [51368, 300, 13, 583, 264, 1778, 307, 570, 286, 478, 42626, 341, 17138, 712, 2657, 1339, 286, 478, 6367, 278, 807, 51628], "temperature": 0.0, "avg_logprob": -0.15419946867844153, "compression_ratio": 1.8416666666666666, "no_speech_prob": 0.06953081488609314}, {"id": 81, "seek": 38870, "start": 388.7, "end": 393.42, "text": " it. So if I have a look here and I print out I value, and actually let's not print", "tokens": [50364, 309, 13, 407, 498, 286, 362, 257, 574, 510, 293, 286, 4482, 484, 286, 2158, 11, 293, 767, 718, 311, 406, 4482, 50600], "temperature": 0.0, "avg_logprob": -0.11687393711037831, "compression_ratio": 1.7664473684210527, "no_speech_prob": 0.15607956051826477}, {"id": 82, "seek": 38870, "start": 393.42, "end": 398.02, "text": " out value. Let's print out I and LST. And let's have a look at it at every iteration.", "tokens": [50600, 484, 2158, 13, 961, 311, 4482, 484, 286, 293, 441, 6840, 13, 400, 718, 311, 362, 257, 574, 412, 309, 412, 633, 24784, 13, 50830], "temperature": 0.0, "avg_logprob": -0.11687393711037831, "compression_ratio": 1.7664473684210527, "no_speech_prob": 0.15607956051826477}, {"id": 83, "seek": 38870, "start": 398.02, "end": 403.38, "text": " We see I zero and then one, two, three, four, five all the way up until six. And what happens", "tokens": [50830, 492, 536, 286, 4018, 293, 550, 472, 11, 732, 11, 1045, 11, 1451, 11, 1732, 439, 264, 636, 493, 1826, 2309, 13, 400, 437, 2314, 51098], "temperature": 0.0, "avg_logprob": -0.11687393711037831, "compression_ratio": 1.7664473684210527, "no_speech_prob": 0.15607956051826477}, {"id": 84, "seek": 38870, "start": 403.38, "end": 407.82, "text": " is we don't actually end up iterating through every unique element in the list because we're", "tokens": [51098, 307, 321, 500, 380, 767, 917, 493, 17138, 990, 807, 633, 3845, 4478, 294, 264, 1329, 570, 321, 434, 51320], "temperature": 0.0, "avg_logprob": -0.11687393711037831, "compression_ratio": 1.7664473684210527, "no_speech_prob": 0.15607956051826477}, {"id": 85, "seek": 38870, "start": 407.82, "end": 412.41999999999996, "text": " popping it as we go. And the enumerate function works a little bit differently than the range", "tokens": [51320, 18374, 309, 382, 321, 352, 13, 400, 264, 465, 15583, 473, 2445, 1985, 257, 707, 857, 7614, 813, 264, 3613, 51550], "temperature": 0.0, "avg_logprob": -0.11687393711037831, "compression_ratio": 1.7664473684210527, "no_speech_prob": 0.15607956051826477}, {"id": 86, "seek": 38870, "start": 412.41999999999996, "end": 417.94, "text": " function in Python. And to show you this, uh, let's do another example. So let's change", "tokens": [51550, 2445, 294, 15329, 13, 400, 281, 855, 291, 341, 11, 2232, 11, 718, 311, 360, 1071, 1365, 13, 407, 718, 311, 1319, 51826], "temperature": 0.0, "avg_logprob": -0.11687393711037831, "compression_ratio": 1.7664473684210527, "no_speech_prob": 0.15607956051826477}, {"id": 87, "seek": 41794, "start": 417.98, "end": 422.98, "text": " this now to say for I, and this is going to be in range. And then this will be the", "tokens": [50366, 341, 586, 281, 584, 337, 286, 11, 293, 341, 307, 516, 281, 312, 294, 3613, 13, 400, 550, 341, 486, 312, 264, 50616], "temperature": 0.0, "avg_logprob": -0.11316959463435111, "compression_ratio": 1.872791519434629, "no_speech_prob": 0.01854514330625534}, {"id": 88, "seek": 41794, "start": 422.98, "end": 427.42, "text": " length of LST. So you would imagine we just get the exact same result here. But when I", "tokens": [50616, 4641, 295, 441, 6840, 13, 407, 291, 576, 3811, 321, 445, 483, 264, 1900, 912, 1874, 510, 13, 583, 562, 286, 50838], "temperature": 0.0, "avg_logprob": -0.11316959463435111, "compression_ratio": 1.872791519434629, "no_speech_prob": 0.01854514330625534}, {"id": 89, "seek": 41794, "start": 427.42, "end": 432.5, "text": " run this, notice now we get pop index out of range. Well, the issue here is that we're", "tokens": [50838, 1190, 341, 11, 3449, 586, 321, 483, 1665, 8186, 484, 295, 3613, 13, 1042, 11, 264, 2734, 510, 307, 300, 321, 434, 51092], "temperature": 0.0, "avg_logprob": -0.11316959463435111, "compression_ratio": 1.872791519434629, "no_speech_prob": 0.01854514330625534}, {"id": 90, "seek": 41794, "start": 432.5, "end": 437.74, "text": " reducing the length of the list while we're iterating through it. And the range function", "tokens": [51092, 12245, 264, 4641, 295, 264, 1329, 1339, 321, 434, 17138, 990, 807, 309, 13, 400, 264, 3613, 2445, 51354], "temperature": 0.0, "avg_logprob": -0.11316959463435111, "compression_ratio": 1.872791519434629, "no_speech_prob": 0.01854514330625534}, {"id": 91, "seek": 41794, "start": 437.74, "end": 442.74, "text": " has kind of a constant range that we're going to be iterating through. So as soon as I define", "tokens": [51354, 575, 733, 295, 257, 5754, 3613, 300, 321, 434, 516, 281, 312, 17138, 990, 807, 13, 407, 382, 2321, 382, 286, 6964, 51604], "temperature": 0.0, "avg_logprob": -0.11316959463435111, "compression_ratio": 1.872791519434629, "no_speech_prob": 0.01854514330625534}, {"id": 92, "seek": 41794, "start": 442.74, "end": 446.54, "text": " that I'm going to iterate through the range of zero to nine, that doesn't change the whole", "tokens": [51604, 300, 286, 478, 516, 281, 44497, 807, 264, 3613, 295, 4018, 281, 4949, 11, 300, 1177, 380, 1319, 264, 1379, 51794], "temperature": 0.0, "avg_logprob": -0.11316959463435111, "compression_ratio": 1.872791519434629, "no_speech_prob": 0.01854514330625534}, {"id": 93, "seek": 44654, "start": 446.62, "end": 450.3, "text": " time I'm going through this for loop. So even if I modify the length of the list, this", "tokens": [50368, 565, 286, 478, 516, 807, 341, 337, 6367, 13, 407, 754, 498, 286, 16927, 264, 4641, 295, 264, 1329, 11, 341, 50552], "temperature": 0.0, "avg_logprob": -0.10355065744134444, "compression_ratio": 1.8708708708708708, "no_speech_prob": 0.06369886547327042}, {"id": 94, "seek": 44654, "start": 450.3, "end": 454.82, "text": " hasn't changed because I've put a constant value here. Whereas when we have the enumerate,", "tokens": [50552, 6132, 380, 3105, 570, 286, 600, 829, 257, 5754, 2158, 510, 13, 13813, 562, 321, 362, 264, 465, 15583, 473, 11, 50778], "temperature": 0.0, "avg_logprob": -0.10355065744134444, "compression_ratio": 1.8708708708708708, "no_speech_prob": 0.06369886547327042}, {"id": 95, "seek": 44654, "start": 454.82, "end": 458.58000000000004, "text": " this will actually change based on the length of the list. And again, that's why you get", "tokens": [50778, 341, 486, 767, 1319, 2361, 322, 264, 4641, 295, 264, 1329, 13, 400, 797, 11, 300, 311, 983, 291, 483, 50966], "temperature": 0.0, "avg_logprob": -0.10355065744134444, "compression_ratio": 1.8708708708708708, "no_speech_prob": 0.06369886547327042}, {"id": 96, "seek": 44654, "start": 458.58000000000004, "end": 462.66, "text": " that weird result. So that's what I wanted to share with you. Don't do this. It cause", "tokens": [50966, 300, 3657, 1874, 13, 407, 300, 311, 437, 286, 1415, 281, 2073, 365, 291, 13, 1468, 380, 360, 341, 13, 467, 3082, 51170], "temperature": 0.0, "avg_logprob": -0.10355065744134444, "compression_ratio": 1.8708708708708708, "no_speech_prob": 0.06369886547327042}, {"id": 97, "seek": 44654, "start": 462.66, "end": 467.1, "text": " a lot of headaches. Only do this. If you really understand what you're doing. And if you want", "tokens": [51170, 257, 688, 295, 35046, 13, 5686, 360, 341, 13, 759, 291, 534, 1223, 437, 291, 434, 884, 13, 400, 498, 291, 528, 51392], "temperature": 0.0, "avg_logprob": -0.10355065744134444, "compression_ratio": 1.8708708708708708, "no_speech_prob": 0.06369886547327042}, {"id": 98, "seek": 44654, "start": 467.1, "end": 471.78000000000003, "text": " to make a modification to a list while you're iterating through it, usually what I like", "tokens": [51392, 281, 652, 257, 26747, 281, 257, 1329, 1339, 291, 434, 17138, 990, 807, 309, 11, 2673, 437, 286, 411, 51626], "temperature": 0.0, "avg_logprob": -0.10355065744134444, "compression_ratio": 1.8708708708708708, "no_speech_prob": 0.06369886547327042}, {"id": 99, "seek": 44654, "start": 471.78000000000003, "end": 476.18, "text": " to do is store the modifications I want to make somewhere else, iterate through the list", "tokens": [51626, 281, 360, 307, 3531, 264, 26881, 286, 528, 281, 652, 4079, 1646, 11, 44497, 807, 264, 1329, 51846], "temperature": 0.0, "avg_logprob": -0.10355065744134444, "compression_ratio": 1.8708708708708708, "no_speech_prob": 0.06369886547327042}, {"id": 100, "seek": 47618, "start": 476.22, "end": 481.18, "text": " entirely one time and then run a for loop and just make those specific iterations that", "tokens": [50366, 7696, 472, 565, 293, 550, 1190, 257, 337, 6367, 293, 445, 652, 729, 2685, 36540, 300, 50614], "temperature": 0.0, "avg_logprob": -0.0989822778176135, "compression_ratio": 1.6945337620578778, "no_speech_prob": 0.0055545540526509285}, {"id": 101, "seek": 47618, "start": 481.18, "end": 485.58, "text": " I want to. Hopefully that makes a bit of sense, but that is mistake number three. So the", "tokens": [50614, 286, 528, 281, 13, 10429, 300, 1669, 257, 857, 295, 2020, 11, 457, 300, 307, 6146, 1230, 1045, 13, 407, 264, 50834], "temperature": 0.0, "avg_logprob": -0.0989822778176135, "compression_ratio": 1.6945337620578778, "no_speech_prob": 0.0055545540526509285}, {"id": 102, "seek": 47618, "start": 485.58, "end": 489.82, "text": " next mistake I have to share with you is one that is super tricky to figure out if you've", "tokens": [50834, 958, 6146, 286, 362, 281, 2073, 365, 291, 307, 472, 300, 307, 1687, 12414, 281, 2573, 484, 498, 291, 600, 51046], "temperature": 0.0, "avg_logprob": -0.0989822778176135, "compression_ratio": 1.6945337620578778, "no_speech_prob": 0.0055545540526509285}, {"id": 103, "seek": 47618, "start": 489.82, "end": 494.86, "text": " never seen this before. And this is called name clashing. Now this happens when you", "tokens": [51046, 1128, 1612, 341, 949, 13, 400, 341, 307, 1219, 1315, 596, 11077, 13, 823, 341, 2314, 562, 291, 51298], "temperature": 0.0, "avg_logprob": -0.0989822778176135, "compression_ratio": 1.6945337620578778, "no_speech_prob": 0.0055545540526509285}, {"id": 104, "seek": 47618, "start": 494.86, "end": 500.14, "text": " name your Python file, which we're going to refer to as a module here, the name of a built", "tokens": [51298, 1315, 428, 15329, 3991, 11, 597, 321, 434, 516, 281, 2864, 281, 382, 257, 10088, 510, 11, 264, 1315, 295, 257, 3094, 51562], "temperature": 0.0, "avg_logprob": -0.0989822778176135, "compression_ratio": 1.6945337620578778, "no_speech_prob": 0.0055545540526509285}, {"id": 105, "seek": 47618, "start": 500.14, "end": 504.78000000000003, "text": " in module in Python or a third party module that you've installed using something like", "tokens": [51562, 294, 10088, 294, 15329, 420, 257, 2636, 3595, 10088, 300, 291, 600, 8899, 1228, 746, 411, 51794], "temperature": 0.0, "avg_logprob": -0.0989822778176135, "compression_ratio": 1.6945337620578778, "no_speech_prob": 0.0055545540526509285}, {"id": 106, "seek": 50478, "start": 504.85999999999996, "end": 509.9, "text": " PIP. So looking at this example here, I have a little script where I import Pi game. Pi", "tokens": [50368, 430, 9139, 13, 407, 1237, 412, 341, 1365, 510, 11, 286, 362, 257, 707, 5755, 689, 286, 974, 17741, 1216, 13, 17741, 50620], "temperature": 0.0, "avg_logprob": -0.14004743013450568, "compression_ratio": 1.673015873015873, "no_speech_prob": 0.14409060776233673}, {"id": 107, "seek": 50478, "start": 509.9, "end": 514.62, "text": " game is a third party Python module. I installed this on my system and this lets me build 2D", "tokens": [50620, 1216, 307, 257, 2636, 3595, 15329, 10088, 13, 286, 8899, 341, 322, 452, 1185, 293, 341, 6653, 385, 1322, 568, 35, 50856], "temperature": 0.0, "avg_logprob": -0.14004743013450568, "compression_ratio": 1.673015873015873, "no_speech_prob": 0.14409060776233673}, {"id": 108, "seek": 50478, "start": 514.62, "end": 518.9, "text": " games. You guys have probably seen this on my channel before. Anyways, I have Pi game.", "tokens": [50856, 2813, 13, 509, 1074, 362, 1391, 1612, 341, 322, 452, 2269, 949, 13, 15585, 11, 286, 362, 17741, 1216, 13, 51070], "temperature": 0.0, "avg_logprob": -0.14004743013450568, "compression_ratio": 1.673015873015873, "no_speech_prob": 0.14409060776233673}, {"id": 109, "seek": 50478, "start": 518.9, "end": 522.9399999999999, "text": " Now when I run this, I get an error and it says this is most likely due to a circular", "tokens": [51070, 823, 562, 286, 1190, 341, 11, 286, 483, 364, 6713, 293, 309, 1619, 341, 307, 881, 3700, 3462, 281, 257, 16476, 51272], "temperature": 0.0, "avg_logprob": -0.14004743013450568, "compression_ratio": 1.673015873015873, "no_speech_prob": 0.14409060776233673}, {"id": 110, "seek": 50478, "start": 522.9399999999999, "end": 527.8199999999999, "text": " import, but this is only happening in this file. If I throw this in another file, this", "tokens": [51272, 974, 11, 457, 341, 307, 787, 2737, 294, 341, 3991, 13, 759, 286, 3507, 341, 294, 1071, 3991, 11, 341, 51516], "temperature": 0.0, "avg_logprob": -0.14004743013450568, "compression_ratio": 1.673015873015873, "no_speech_prob": 0.14409060776233673}, {"id": 111, "seek": 50478, "start": 527.8199999999999, "end": 531.98, "text": " code will work completely fine. So what's going on here? Well, the issue is I've named", "tokens": [51516, 3089, 486, 589, 2584, 2489, 13, 407, 437, 311, 516, 322, 510, 30, 1042, 11, 264, 2734, 307, 286, 600, 4926, 51724], "temperature": 0.0, "avg_logprob": -0.14004743013450568, "compression_ratio": 1.673015873015873, "no_speech_prob": 0.14409060776233673}, {"id": 112, "seek": 53198, "start": 532.02, "end": 536.98, "text": " my Python module Pi game. So I've named it the thing that I'm trying to import. So what", "tokens": [50366, 452, 15329, 10088, 17741, 1216, 13, 407, 286, 600, 4926, 309, 264, 551, 300, 286, 478, 1382, 281, 974, 13, 407, 437, 50614], "temperature": 0.0, "avg_logprob": -0.11754197659699814, "compression_ratio": 1.8419243986254294, "no_speech_prob": 0.021613432094454765}, {"id": 113, "seek": 53198, "start": 536.98, "end": 541.1800000000001, "text": " happens is when I try to import Pi game, I'm trying to import the module that I'm currently", "tokens": [50614, 2314, 307, 562, 286, 853, 281, 974, 17741, 1216, 11, 286, 478, 1382, 281, 974, 264, 10088, 300, 286, 478, 4362, 50824], "temperature": 0.0, "avg_logprob": -0.11754197659699814, "compression_ratio": 1.8419243986254294, "no_speech_prob": 0.021613432094454765}, {"id": 114, "seek": 53198, "start": 541.1800000000001, "end": 545.66, "text": " working in myself. And then I get this error and it's saying it doesn't have the attribute.", "tokens": [50824, 1364, 294, 2059, 13, 400, 550, 286, 483, 341, 6713, 293, 309, 311, 1566, 309, 1177, 380, 362, 264, 19667, 13, 51048], "temperature": 0.0, "avg_logprob": -0.11754197659699814, "compression_ratio": 1.8419243986254294, "no_speech_prob": 0.021613432094454765}, {"id": 115, "seek": 53198, "start": 545.66, "end": 548.4200000000001, "text": " So to show you how you would fix this, you would rename the file. So let's call this", "tokens": [51048, 407, 281, 855, 291, 577, 291, 576, 3191, 341, 11, 291, 576, 36741, 264, 3991, 13, 407, 718, 311, 818, 341, 51186], "temperature": 0.0, "avg_logprob": -0.11754197659699814, "compression_ratio": 1.8419243986254294, "no_speech_prob": 0.021613432094454765}, {"id": 116, "seek": 53198, "start": 548.4200000000001, "end": 553.62, "text": " Pi game one now. And when I run this code, notice we no longer get that error and actually", "tokens": [51186, 17741, 1216, 472, 586, 13, 400, 562, 286, 1190, 341, 3089, 11, 3449, 321, 572, 2854, 483, 300, 6713, 293, 767, 51446], "temperature": 0.0, "avg_logprob": -0.11754197659699814, "compression_ratio": 1.8419243986254294, "no_speech_prob": 0.021613432094454765}, {"id": 117, "seek": 53198, "start": 553.62, "end": 557.3000000000001, "text": " pops up a little Pi game screen. Obviously it goes away because I haven't coded anything", "tokens": [51446, 16795, 493, 257, 707, 17741, 1216, 2568, 13, 7580, 309, 1709, 1314, 570, 286, 2378, 380, 34874, 1340, 51630], "temperature": 0.0, "avg_logprob": -0.11754197659699814, "compression_ratio": 1.8419243986254294, "no_speech_prob": 0.021613432094454765}, {"id": 118, "seek": 55730, "start": 557.3, "end": 562.4599999999999, "text": " else out. So be careful about that. Do not name your Python modules, your Python files,", "tokens": [50364, 1646, 484, 13, 407, 312, 5026, 466, 300, 13, 1144, 406, 1315, 428, 15329, 16679, 11, 428, 15329, 7098, 11, 50622], "temperature": 0.0, "avg_logprob": -0.12107648568994858, "compression_ratio": 1.907473309608541, "no_speech_prob": 0.061867717653512955}, {"id": 119, "seek": 55730, "start": 562.4599999999999, "end": 567.62, "text": " a built in module or a module that you're going to be importing or using in your program.", "tokens": [50622, 257, 3094, 294, 10088, 420, 257, 10088, 300, 291, 434, 516, 281, 312, 43866, 420, 1228, 294, 428, 1461, 13, 50880], "temperature": 0.0, "avg_logprob": -0.12107648568994858, "compression_ratio": 1.907473309608541, "no_speech_prob": 0.061867717653512955}, {"id": 120, "seek": 55730, "start": 567.62, "end": 572.62, "text": " So moving on, the next mistake I have for you is using a naked accept. Now here I have", "tokens": [50880, 407, 2684, 322, 11, 264, 958, 6146, 286, 362, 337, 291, 307, 1228, 257, 15791, 3241, 13, 823, 510, 286, 362, 51130], "temperature": 0.0, "avg_logprob": -0.12107648568994858, "compression_ratio": 1.907473309608541, "no_speech_prob": 0.061867717653512955}, {"id": 121, "seek": 55730, "start": 572.62, "end": 578.6999999999999, "text": " a try accept block and this exception or this accept block is going to accept any exception.", "tokens": [51130, 257, 853, 3241, 3461, 293, 341, 11183, 420, 341, 3241, 3461, 307, 516, 281, 3241, 604, 11183, 13, 51434], "temperature": 0.0, "avg_logprob": -0.12107648568994858, "compression_ratio": 1.907473309608541, "no_speech_prob": 0.061867717653512955}, {"id": 122, "seek": 55730, "start": 578.6999999999999, "end": 582.3, "text": " So if anything happens in here, that's an error that crashes the program, we're going", "tokens": [51434, 407, 498, 1340, 2314, 294, 510, 11, 300, 311, 364, 6713, 300, 28642, 264, 1461, 11, 321, 434, 516, 51614], "temperature": 0.0, "avg_logprob": -0.12107648568994858, "compression_ratio": 1.907473309608541, "no_speech_prob": 0.061867717653512955}, {"id": 123, "seek": 55730, "start": 582.3, "end": 587.2199999999999, "text": " to go in here and print. I crashed. Now that's great. It's useful that we have this feature.", "tokens": [51614, 281, 352, 294, 510, 293, 4482, 13, 286, 24190, 13, 823, 300, 311, 869, 13, 467, 311, 4420, 300, 321, 362, 341, 4111, 13, 51860], "temperature": 0.0, "avg_logprob": -0.12107648568994858, "compression_ratio": 1.907473309608541, "no_speech_prob": 0.061867717653512955}, {"id": 124, "seek": 58722, "start": 587.22, "end": 592.74, "text": " The issue is this accepts anything, which means I don't know why I crashed when I'm", "tokens": [50364, 440, 2734, 307, 341, 33538, 1340, 11, 597, 1355, 286, 500, 380, 458, 983, 286, 24190, 562, 286, 478, 50640], "temperature": 0.0, "avg_logprob": -0.1313211899395137, "compression_ratio": 1.6888888888888889, "no_speech_prob": 0.04084017500281334}, {"id": 125, "seek": 58722, "start": 592.74, "end": 597.6600000000001, "text": " reading this code and I see this message being printed out. Now this is really bad practice", "tokens": [50640, 3760, 341, 3089, 293, 286, 536, 341, 3636, 885, 13567, 484, 13, 823, 341, 307, 534, 1578, 3124, 50886], "temperature": 0.0, "avg_logprob": -0.1313211899395137, "compression_ratio": 1.6888888888888889, "no_speech_prob": 0.04084017500281334}, {"id": 126, "seek": 58722, "start": 597.6600000000001, "end": 601.98, "text": " because it makes it really hard to debug your code. Uh, and you just really shouldn't do", "tokens": [50886, 570, 309, 1669, 309, 534, 1152, 281, 24083, 428, 3089, 13, 4019, 11, 293, 291, 445, 534, 4659, 380, 360, 51102], "temperature": 0.0, "avg_logprob": -0.1313211899395137, "compression_ratio": 1.6888888888888889, "no_speech_prob": 0.04084017500281334}, {"id": 127, "seek": 58722, "start": 601.98, "end": 606.78, "text": " this. You should handle each individual exception as opposed to just any general exception,", "tokens": [51102, 341, 13, 509, 820, 4813, 1184, 2609, 11183, 382, 8851, 281, 445, 604, 2674, 11183, 11, 51342], "temperature": 0.0, "avg_logprob": -0.1313211899395137, "compression_ratio": 1.6888888888888889, "no_speech_prob": 0.04084017500281334}, {"id": 128, "seek": 58722, "start": 606.78, "end": 610.94, "text": " uh, kind of for obvious reasons. But in this case, I have two things inside of here that", "tokens": [51342, 2232, 11, 733, 295, 337, 6322, 4112, 13, 583, 294, 341, 1389, 11, 286, 362, 732, 721, 1854, 295, 510, 300, 51550], "temperature": 0.0, "avg_logprob": -0.1313211899395137, "compression_ratio": 1.6888888888888889, "no_speech_prob": 0.04084017500281334}, {"id": 129, "seek": 58722, "start": 610.94, "end": 615.02, "text": " could fail, right? This could fail, trying to open a file in read mode, because if the", "tokens": [51550, 727, 3061, 11, 558, 30, 639, 727, 3061, 11, 1382, 281, 1269, 257, 3991, 294, 1401, 4391, 11, 570, 498, 264, 51754], "temperature": 0.0, "avg_logprob": -0.1313211899395137, "compression_ratio": 1.6888888888888889, "no_speech_prob": 0.04084017500281334}, {"id": 130, "seek": 61502, "start": 615.02, "end": 619.26, "text": " file doesn't exist, we'll get an exception and then dividing one by zero. Well, zero", "tokens": [50364, 3991, 1177, 380, 2514, 11, 321, 603, 483, 364, 11183, 293, 550, 26764, 472, 538, 4018, 13, 1042, 11, 4018, 50576], "temperature": 0.0, "avg_logprob": -0.1352039064679827, "compression_ratio": 1.7781569965870307, "no_speech_prob": 0.038463473320007324}, {"id": 131, "seek": 61502, "start": 619.26, "end": 623.1, "text": " division, that's an error, no matter what. So two things that could fail. And when I", "tokens": [50576, 10044, 11, 300, 311, 364, 6713, 11, 572, 1871, 437, 13, 407, 732, 721, 300, 727, 3061, 13, 400, 562, 286, 50768], "temperature": 0.0, "avg_logprob": -0.1352039064679827, "compression_ratio": 1.7781569965870307, "no_speech_prob": 0.038463473320007324}, {"id": 132, "seek": 61502, "start": 623.1, "end": 627.78, "text": " run the code here, all I get is I crashed. So I don't know if it was because I was unable", "tokens": [50768, 1190, 264, 3089, 510, 11, 439, 286, 483, 307, 286, 24190, 13, 407, 286, 500, 380, 458, 498, 309, 390, 570, 286, 390, 11299, 51002], "temperature": 0.0, "avg_logprob": -0.1352039064679827, "compression_ratio": 1.7781569965870307, "no_speech_prob": 0.038463473320007324}, {"id": 133, "seek": 61502, "start": 627.78, "end": 632.3, "text": " to open the file or because I divided by zero. And now if I delete the file that currently", "tokens": [51002, 281, 1269, 264, 3991, 420, 570, 286, 6666, 538, 4018, 13, 400, 586, 498, 286, 12097, 264, 3991, 300, 4362, 51228], "temperature": 0.0, "avg_logprob": -0.1352039064679827, "compression_ratio": 1.7781569965870307, "no_speech_prob": 0.038463473320007324}, {"id": 134, "seek": 61502, "start": 632.3, "end": 636.86, "text": " exists, so Tim dot TXT, I have that there and I run this again, I get, I crashed. So", "tokens": [51228, 8198, 11, 370, 7172, 5893, 314, 20542, 11, 286, 362, 300, 456, 293, 286, 1190, 341, 797, 11, 286, 483, 11, 286, 24190, 13, 407, 51456], "temperature": 0.0, "avg_logprob": -0.1352039064679827, "compression_ratio": 1.7781569965870307, "no_speech_prob": 0.038463473320007324}, {"id": 135, "seek": 61502, "start": 636.86, "end": 641.46, "text": " of course the solution here is to accept a specific exception and multiple of them if", "tokens": [51456, 295, 1164, 264, 3827, 510, 307, 281, 3241, 257, 2685, 11183, 293, 3866, 295, 552, 498, 51686], "temperature": 0.0, "avg_logprob": -0.1352039064679827, "compression_ratio": 1.7781569965870307, "no_speech_prob": 0.038463473320007324}, {"id": 136, "seek": 64146, "start": 641.46, "end": 645.0600000000001, "text": " you want to. So you kind of just need to know what the names of these are. You can look", "tokens": [50364, 291, 528, 281, 13, 407, 291, 733, 295, 445, 643, 281, 458, 437, 264, 5288, 295, 613, 366, 13, 509, 393, 574, 50544], "temperature": 0.0, "avg_logprob": -0.1091920906770314, "compression_ratio": 1.8661971830985915, "no_speech_prob": 0.414784699678421}, {"id": 137, "seek": 64146, "start": 645.0600000000001, "end": 649.74, "text": " them up. You also can just crash your program and see what the exception is. But for now,", "tokens": [50544, 552, 493, 13, 509, 611, 393, 445, 8252, 428, 1461, 293, 536, 437, 264, 11183, 307, 13, 583, 337, 586, 11, 50778], "temperature": 0.0, "avg_logprob": -0.1091920906770314, "compression_ratio": 1.8661971830985915, "no_speech_prob": 0.414784699678421}, {"id": 138, "seek": 64146, "start": 649.74, "end": 653.74, "text": " let's accept the zero division error. So the zero division error is simply called zero", "tokens": [50778, 718, 311, 3241, 264, 4018, 10044, 6713, 13, 407, 264, 4018, 10044, 6713, 307, 2935, 1219, 4018, 50978], "temperature": 0.0, "avg_logprob": -0.1091920906770314, "compression_ratio": 1.8661971830985915, "no_speech_prob": 0.414784699678421}, {"id": 139, "seek": 64146, "start": 653.74, "end": 659.4200000000001, "text": " division error. You shall also get some syntax highlighting for it. And now I can say I tried", "tokens": [50978, 10044, 6713, 13, 509, 4393, 611, 483, 512, 28431, 26551, 337, 309, 13, 400, 586, 286, 393, 584, 286, 3031, 51262], "temperature": 0.0, "avg_logprob": -0.1091920906770314, "compression_ratio": 1.8661971830985915, "no_speech_prob": 0.414784699678421}, {"id": 140, "seek": 64146, "start": 659.4200000000001, "end": 666.14, "text": " to divide by zero dot, dot, dot. Okay. Uh, now let's just comment this line out. Let's", "tokens": [51262, 281, 9845, 538, 4018, 5893, 11, 5893, 11, 5893, 13, 1033, 13, 4019, 11, 586, 718, 311, 445, 2871, 341, 1622, 484, 13, 961, 311, 51598], "temperature": 0.0, "avg_logprob": -0.1091920906770314, "compression_ratio": 1.8661971830985915, "no_speech_prob": 0.414784699678421}, {"id": 141, "seek": 64146, "start": 666.14, "end": 670.62, "text": " run this and then we get, I tried to divide by zero. If I uncomment that and make my", "tokens": [51598, 1190, 341, 293, 550, 321, 483, 11, 286, 3031, 281, 9845, 538, 4018, 13, 759, 286, 8585, 518, 300, 293, 652, 452, 51822], "temperature": 0.0, "avg_logprob": -0.1091920906770314, "compression_ratio": 1.8661971830985915, "no_speech_prob": 0.414784699678421}, {"id": 142, "seek": 67062, "start": 670.62, "end": 677.14, "text": " new file. So let's save this as Tim dot TXT. You guys put tests inside of there, save", "tokens": [50364, 777, 3991, 13, 407, 718, 311, 3155, 341, 382, 7172, 5893, 314, 20542, 13, 509, 1074, 829, 6921, 1854, 295, 456, 11, 3155, 50690], "temperature": 0.0, "avg_logprob": -0.14609214587089342, "compression_ratio": 1.6367041198501873, "no_speech_prob": 0.05339804291725159}, {"id": 143, "seek": 67062, "start": 677.14, "end": 682.02, "text": " and run. Uh, notice that I get, I tried to divide by zero, uh, because I'm accepting", "tokens": [50690, 293, 1190, 13, 4019, 11, 3449, 300, 286, 483, 11, 286, 3031, 281, 9845, 538, 4018, 11, 2232, 11, 570, 286, 478, 17391, 50934], "temperature": 0.0, "avg_logprob": -0.14609214587089342, "compression_ratio": 1.6367041198501873, "no_speech_prob": 0.05339804291725159}, {"id": 144, "seek": 67062, "start": 682.02, "end": 686.86, "text": " the zero division error. This obviously did not have an exception. All right. Now though,", "tokens": [50934, 264, 4018, 10044, 6713, 13, 639, 2745, 630, 406, 362, 364, 11183, 13, 1057, 558, 13, 823, 1673, 11, 51176], "temperature": 0.0, "avg_logprob": -0.14609214587089342, "compression_ratio": 1.6367041198501873, "no_speech_prob": 0.05339804291725159}, {"id": 145, "seek": 67062, "start": 686.86, "end": 691.86, "text": " if we want to handle both of these exceptions, we can write multiple except blocks. So I", "tokens": [51176, 498, 321, 528, 281, 4813, 1293, 295, 613, 22847, 11, 321, 393, 2464, 3866, 3993, 8474, 13, 407, 286, 51426], "temperature": 0.0, "avg_logprob": -0.14609214587089342, "compression_ratio": 1.6367041198501873, "no_speech_prob": 0.05339804291725159}, {"id": 146, "seek": 67062, "start": 691.86, "end": 697.34, "text": " can do accept and then I can accept. I think this is the file not found error and I can", "tokens": [51426, 393, 360, 3241, 293, 550, 286, 393, 3241, 13, 286, 519, 341, 307, 264, 3991, 406, 1352, 6713, 293, 286, 393, 51700], "temperature": 0.0, "avg_logprob": -0.14609214587089342, "compression_ratio": 1.6367041198501873, "no_speech_prob": 0.05339804291725159}, {"id": 147, "seek": 69734, "start": 697.34, "end": 705.22, "text": " print out. I could not find the file dot dot dot. So now if I delete the file again,", "tokens": [50364, 4482, 484, 13, 286, 727, 406, 915, 264, 3991, 5893, 5893, 5893, 13, 407, 586, 498, 286, 12097, 264, 3991, 797, 11, 50758], "temperature": 0.0, "avg_logprob": -0.11988892594004065, "compression_ratio": 1.753968253968254, "no_speech_prob": 0.07806926965713501}, {"id": 148, "seek": 69734, "start": 705.22, "end": 709.82, "text": " let's delete that. Let's run this. Then I get, I could not find the file. One last thing", "tokens": [50758, 718, 311, 12097, 300, 13, 961, 311, 1190, 341, 13, 1396, 286, 483, 11, 286, 727, 406, 915, 264, 3991, 13, 1485, 1036, 551, 50988], "temperature": 0.0, "avg_logprob": -0.11988892594004065, "compression_ratio": 1.753968253968254, "no_speech_prob": 0.07806926965713501}, {"id": 149, "seek": 69734, "start": 709.82, "end": 715.3000000000001, "text": " I will throw in here before I leave. Uh, you also can have as E or as something. Now when", "tokens": [50988, 286, 486, 3507, 294, 510, 949, 286, 1856, 13, 4019, 11, 291, 611, 393, 362, 382, 462, 420, 382, 746, 13, 823, 562, 51262], "temperature": 0.0, "avg_logprob": -0.11988892594004065, "compression_ratio": 1.753968253968254, "no_speech_prob": 0.07806926965713501}, {"id": 150, "seek": 69734, "start": 715.3000000000001, "end": 719.6600000000001, "text": " I do that, it will actually give me access to the error in the scope. So I can do something", "tokens": [51262, 286, 360, 300, 11, 309, 486, 767, 976, 385, 2105, 281, 264, 6713, 294, 264, 11923, 13, 407, 286, 393, 360, 746, 51480], "temperature": 0.0, "avg_logprob": -0.11988892594004065, "compression_ratio": 1.753968253968254, "no_speech_prob": 0.07806926965713501}, {"id": 151, "seek": 69734, "start": 719.6600000000001, "end": 724.02, "text": " like print E. Let's just comment this out now. And then you can actually view what the", "tokens": [51480, 411, 4482, 462, 13, 961, 311, 445, 2871, 341, 484, 586, 13, 400, 550, 291, 393, 767, 1910, 437, 264, 51698], "temperature": 0.0, "avg_logprob": -0.11988892594004065, "compression_ratio": 1.753968253968254, "no_speech_prob": 0.07806926965713501}, {"id": 152, "seek": 72402, "start": 724.02, "end": 728.78, "text": " exception string message is. So keep that in mind. That sometimes can be useful, but", "tokens": [50364, 11183, 6798, 3636, 307, 13, 407, 1066, 300, 294, 1575, 13, 663, 2171, 393, 312, 4420, 11, 457, 50602], "temperature": 0.0, "avg_logprob": -0.13047146028087986, "compression_ratio": 1.742671009771987, "no_speech_prob": 0.30067166686058044}, {"id": 153, "seek": 72402, "start": 728.78, "end": 732.9, "text": " please, when you're writing your except blocks, except a specific exception, it will help", "tokens": [50602, 1767, 11, 562, 291, 434, 3579, 428, 3993, 8474, 11, 3993, 257, 2685, 11183, 11, 309, 486, 854, 50808], "temperature": 0.0, "avg_logprob": -0.13047146028087986, "compression_ratio": 1.742671009771987, "no_speech_prob": 0.30067166686058044}, {"id": 154, "seek": 72402, "start": 732.9, "end": 739.38, "text": " you later on. So moving on to my next mistake. And this one is using the wrong data structure.", "tokens": [50808, 291, 1780, 322, 13, 407, 2684, 322, 281, 452, 958, 6146, 13, 400, 341, 472, 307, 1228, 264, 2085, 1412, 3877, 13, 51132], "temperature": 0.0, "avg_logprob": -0.13047146028087986, "compression_ratio": 1.742671009771987, "no_speech_prob": 0.30067166686058044}, {"id": 155, "seek": 72402, "start": 739.38, "end": 742.6999999999999, "text": " Now this is common and you could do this in any programming language, but this is very", "tokens": [51132, 823, 341, 307, 2689, 293, 291, 727, 360, 341, 294, 604, 9410, 2856, 11, 457, 341, 307, 588, 51298], "temperature": 0.0, "avg_logprob": -0.13047146028087986, "compression_ratio": 1.742671009771987, "no_speech_prob": 0.30067166686058044}, {"id": 156, "seek": 72402, "start": 742.6999999999999, "end": 746.8199999999999, "text": " important in Python because there's a lot of operations that you can perform on a data", "tokens": [51298, 1021, 294, 15329, 570, 456, 311, 257, 688, 295, 7705, 300, 291, 393, 2042, 322, 257, 1412, 51504], "temperature": 0.0, "avg_logprob": -0.13047146028087986, "compression_ratio": 1.742671009771987, "no_speech_prob": 0.30067166686058044}, {"id": 157, "seek": 72402, "start": 746.8199999999999, "end": 751.46, "text": " structure that are very inefficient and that if you were to use a different data structure,", "tokens": [51504, 3877, 300, 366, 588, 43495, 293, 300, 498, 291, 645, 281, 764, 257, 819, 1412, 3877, 11, 51736], "temperature": 0.0, "avg_logprob": -0.13047146028087986, "compression_ratio": 1.742671009771987, "no_speech_prob": 0.30067166686058044}, {"id": 158, "seek": 75146, "start": 751.46, "end": 755.62, "text": " you'd have a much more efficient algorithm. And if you're unfamiliar with time complexity,", "tokens": [50364, 291, 1116, 362, 257, 709, 544, 7148, 9284, 13, 400, 498, 291, 434, 29415, 365, 565, 14024, 11, 50572], "temperature": 0.0, "avg_logprob": -0.1161498884214972, "compression_ratio": 1.7106918238993711, "no_speech_prob": 0.19189220666885376}, {"id": 159, "seek": 75146, "start": 755.62, "end": 759.7, "text": " don't worry. That's kind of what I'm referring to here. Really, what we're talking about", "tokens": [50572, 500, 380, 3292, 13, 663, 311, 733, 295, 437, 286, 478, 13761, 281, 510, 13, 4083, 11, 437, 321, 434, 1417, 466, 50776], "temperature": 0.0, "avg_logprob": -0.1161498884214972, "compression_ratio": 1.7106918238993711, "no_speech_prob": 0.19189220666885376}, {"id": 160, "seek": 75146, "start": 759.7, "end": 764.5400000000001, "text": " is how fast can you perform an operation and which data structure or built in type is going", "tokens": [50776, 307, 577, 2370, 393, 291, 2042, 364, 6916, 293, 597, 1412, 3877, 420, 3094, 294, 2010, 307, 516, 51018], "temperature": 0.0, "avg_logprob": -0.1161498884214972, "compression_ratio": 1.7106918238993711, "no_speech_prob": 0.19189220666885376}, {"id": 161, "seek": 75146, "start": 764.5400000000001, "end": 769.5400000000001, "text": " to be the best for what it is that you're doing. So in Python, we have really three core data", "tokens": [51018, 281, 312, 264, 1151, 337, 437, 309, 307, 300, 291, 434, 884, 13, 407, 294, 15329, 11, 321, 362, 534, 1045, 4965, 1412, 51268], "temperature": 0.0, "avg_logprob": -0.1161498884214972, "compression_ratio": 1.7106918238993711, "no_speech_prob": 0.19189220666885376}, {"id": 162, "seek": 75146, "start": 769.5400000000001, "end": 773.4200000000001, "text": " structures you should understand. And that's going to be a list set in dictionary. We have", "tokens": [51268, 9227, 291, 820, 1223, 13, 400, 300, 311, 516, 281, 312, 257, 1329, 992, 294, 25890, 13, 492, 362, 51462], "temperature": 0.0, "avg_logprob": -0.1161498884214972, "compression_ratio": 1.7106918238993711, "no_speech_prob": 0.19189220666885376}, {"id": 163, "seek": 75146, "start": 773.4200000000001, "end": 778.58, "text": " string as well, but I won't put that in here. Anyways, the point is if we're looking at", "tokens": [51462, 6798, 382, 731, 11, 457, 286, 1582, 380, 829, 300, 294, 510, 13, 15585, 11, 264, 935, 307, 498, 321, 434, 1237, 412, 51720], "temperature": 0.0, "avg_logprob": -0.1161498884214972, "compression_ratio": 1.7106918238993711, "no_speech_prob": 0.19189220666885376}, {"id": 164, "seek": 77858, "start": 778.58, "end": 784.34, "text": " something like a list, a list is used when you care about a ordered collection of elements.", "tokens": [50364, 746, 411, 257, 1329, 11, 257, 1329, 307, 1143, 562, 291, 1127, 466, 257, 8866, 5765, 295, 4959, 13, 50652], "temperature": 0.0, "avg_logprob": -0.10505193695986181, "compression_ratio": 2.132, "no_speech_prob": 0.56197589635849}, {"id": 165, "seek": 77858, "start": 784.34, "end": 788.7, "text": " So if the order and the frequency of elements that you have is important, then you use a", "tokens": [50652, 407, 498, 264, 1668, 293, 264, 7893, 295, 4959, 300, 291, 362, 307, 1021, 11, 550, 291, 764, 257, 50870], "temperature": 0.0, "avg_logprob": -0.10505193695986181, "compression_ratio": 2.132, "no_speech_prob": 0.56197589635849}, {"id": 166, "seek": 77858, "start": 788.7, "end": 792.0600000000001, "text": " list. There's not really another way to get around that. If you want to store something", "tokens": [50870, 1329, 13, 821, 311, 406, 534, 1071, 636, 281, 483, 926, 300, 13, 759, 291, 528, 281, 3531, 746, 51038], "temperature": 0.0, "avg_logprob": -0.10505193695986181, "compression_ratio": 2.132, "no_speech_prob": 0.56197589635849}, {"id": 167, "seek": 77858, "start": 792.0600000000001, "end": 797.14, "text": " ordered and you care about the frequency, you use a list. Moving on, we have a set. Now", "tokens": [51038, 8866, 293, 291, 1127, 466, 264, 7893, 11, 291, 764, 257, 1329, 13, 14242, 322, 11, 321, 362, 257, 992, 13, 823, 51292], "temperature": 0.0, "avg_logprob": -0.10505193695986181, "compression_ratio": 2.132, "no_speech_prob": 0.56197589635849}, {"id": 168, "seek": 77858, "start": 797.14, "end": 802.0200000000001, "text": " a set is used when you do not care about the frequency or the order of elements. You only", "tokens": [51292, 257, 992, 307, 1143, 562, 291, 360, 406, 1127, 466, 264, 7893, 420, 264, 1668, 295, 4959, 13, 509, 787, 51536], "temperature": 0.0, "avg_logprob": -0.10505193695986181, "compression_ratio": 2.132, "no_speech_prob": 0.56197589635849}, {"id": 169, "seek": 77858, "start": 802.0200000000001, "end": 806.1, "text": " care about the presence of elements. So you care if something is in the set or if it's", "tokens": [51536, 1127, 466, 264, 6814, 295, 4959, 13, 407, 291, 1127, 498, 746, 307, 294, 264, 992, 420, 498, 309, 311, 51740], "temperature": 0.0, "avg_logprob": -0.10505193695986181, "compression_ratio": 2.132, "no_speech_prob": 0.56197589635849}, {"id": 170, "seek": 80610, "start": 806.12, "end": 811.1, "text": " not in the set. Now these two structures have drastically different time complexities in", "tokens": [50365, 406, 294, 264, 992, 13, 823, 613, 732, 9227, 362, 29673, 819, 565, 48705, 294, 50614], "temperature": 0.0, "avg_logprob": -0.10651918846791185, "compression_ratio": 1.8451178451178452, "no_speech_prob": 0.4377287030220032}, {"id": 171, "seek": 80610, "start": 811.1, "end": 815.58, "text": " a list. If I wanted to determine if something's inside of it, that's what's known as a big", "tokens": [50614, 257, 1329, 13, 759, 286, 1415, 281, 6997, 498, 746, 311, 1854, 295, 309, 11, 300, 311, 437, 311, 2570, 382, 257, 955, 50838], "temperature": 0.0, "avg_logprob": -0.10651918846791185, "compression_ratio": 1.8451178451178452, "no_speech_prob": 0.4377287030220032}, {"id": 172, "seek": 80610, "start": 815.58, "end": 820.26, "text": " O of end time operation. And that essentially means that I have to look through at most", "tokens": [50838, 422, 295, 917, 565, 6916, 13, 400, 300, 4476, 1355, 300, 286, 362, 281, 574, 807, 412, 881, 51072], "temperature": 0.0, "avg_logprob": -0.10651918846791185, "compression_ratio": 1.8451178451178452, "no_speech_prob": 0.4377287030220032}, {"id": 173, "seek": 80610, "start": 820.26, "end": 824.66, "text": " every element in the list. And there could be millions of elements to determine if something", "tokens": [51072, 633, 4478, 294, 264, 1329, 13, 400, 456, 727, 312, 6803, 295, 4959, 281, 6997, 498, 746, 51292], "temperature": 0.0, "avg_logprob": -0.10651918846791185, "compression_ratio": 1.8451178451178452, "no_speech_prob": 0.4377287030220032}, {"id": 174, "seek": 80610, "start": 824.66, "end": 830.38, "text": " is there. Whereas with a set, it's actually pretty much an instant or constant time operation", "tokens": [51292, 307, 456, 13, 13813, 365, 257, 992, 11, 309, 311, 767, 1238, 709, 364, 9836, 420, 5754, 565, 6916, 51578], "temperature": 0.0, "avg_logprob": -0.10651918846791185, "compression_ratio": 1.8451178451178452, "no_speech_prob": 0.4377287030220032}, {"id": 175, "seek": 80610, "start": 830.38, "end": 834.14, "text": " for me to determine if an element is in there. So if there's 10 million elements or a hundred", "tokens": [51578, 337, 385, 281, 6997, 498, 364, 4478, 307, 294, 456, 13, 407, 498, 456, 311, 1266, 2459, 4959, 420, 257, 3262, 51766], "temperature": 0.0, "avg_logprob": -0.10651918846791185, "compression_ratio": 1.8451178451178452, "no_speech_prob": 0.4377287030220032}, {"id": 176, "seek": 83414, "start": 834.18, "end": 838.38, "text": " elements, it's going to take relatively the same amount of time for me to determine if", "tokens": [50366, 4959, 11, 309, 311, 516, 281, 747, 7226, 264, 912, 2372, 295, 565, 337, 385, 281, 6997, 498, 50576], "temperature": 0.0, "avg_logprob": -0.13523916764692825, "compression_ratio": 1.8075601374570447, "no_speech_prob": 0.036215659230947495}, {"id": 177, "seek": 83414, "start": 838.38, "end": 842.3, "text": " an element's in the set. So it's very fast for doing lookups, right? And then you have", "tokens": [50576, 364, 4478, 311, 294, 264, 992, 13, 407, 309, 311, 588, 2370, 337, 884, 574, 7528, 11, 558, 30, 400, 550, 291, 362, 50772], "temperature": 0.0, "avg_logprob": -0.13523916764692825, "compression_ratio": 1.8075601374570447, "no_speech_prob": 0.036215659230947495}, {"id": 178, "seek": 83414, "start": 842.3, "end": 847.5, "text": " a dictionary. This is kind of a hybrid. What this allows you to do is store key value pairs.", "tokens": [50772, 257, 25890, 13, 639, 307, 733, 295, 257, 13051, 13, 708, 341, 4045, 291, 281, 360, 307, 3531, 2141, 2158, 15494, 13, 51032], "temperature": 0.0, "avg_logprob": -0.13523916764692825, "compression_ratio": 1.8075601374570447, "no_speech_prob": 0.036215659230947495}, {"id": 179, "seek": 83414, "start": 847.5, "end": 853.02, "text": " But similarly to a set, this allows you to have constant time lookup and access to an", "tokens": [51032, 583, 14138, 281, 257, 992, 11, 341, 4045, 291, 281, 362, 5754, 565, 574, 1010, 293, 2105, 281, 364, 51308], "temperature": 0.0, "avg_logprob": -0.13523916764692825, "compression_ratio": 1.8075601374570447, "no_speech_prob": 0.036215659230947495}, {"id": 180, "seek": 83414, "start": 853.02, "end": 857.66, "text": " element so I can access an element at a key pretty much instantly. And I can check if", "tokens": [51308, 4478, 370, 286, 393, 2105, 364, 4478, 412, 257, 2141, 1238, 709, 13518, 13, 400, 286, 393, 1520, 498, 51540], "temperature": 0.0, "avg_logprob": -0.13523916764692825, "compression_ratio": 1.8075601374570447, "no_speech_prob": 0.036215659230947495}, {"id": 181, "seek": 83414, "start": 857.66, "end": 861.46, "text": " an element is in the dictionary. Those are the three different data structures. And you", "tokens": [51540, 364, 4478, 307, 294, 264, 25890, 13, 3950, 366, 264, 1045, 819, 1412, 9227, 13, 400, 291, 51730], "temperature": 0.0, "avg_logprob": -0.13523916764692825, "compression_ratio": 1.8075601374570447, "no_speech_prob": 0.036215659230947495}, {"id": 182, "seek": 86146, "start": 861.46, "end": 865.4200000000001, "text": " want to use them appropriately because of what I'm about to show you. So I have a list", "tokens": [50364, 528, 281, 764, 552, 23505, 570, 295, 437, 286, 478, 466, 281, 855, 291, 13, 407, 286, 362, 257, 1329, 50562], "temperature": 0.0, "avg_logprob": -0.09536731243133545, "compression_ratio": 1.755700325732899, "no_speech_prob": 0.08754303306341171}, {"id": 183, "seek": 86146, "start": 865.4200000000001, "end": 869.5400000000001, "text": " here, for example, and I'll get to these in one second, by the way. And with this list,", "tokens": [50562, 510, 11, 337, 1365, 11, 293, 286, 603, 483, 281, 613, 294, 472, 1150, 11, 538, 264, 636, 13, 400, 365, 341, 1329, 11, 50768], "temperature": 0.0, "avg_logprob": -0.09536731243133545, "compression_ratio": 1.755700325732899, "no_speech_prob": 0.08754303306341171}, {"id": 184, "seek": 86146, "start": 869.5400000000001, "end": 873.4200000000001, "text": " I can perform all kinds of operations on it. Some are going to be much more efficient than", "tokens": [50768, 286, 393, 2042, 439, 3685, 295, 7705, 322, 309, 13, 2188, 366, 516, 281, 312, 709, 544, 7148, 813, 50962], "temperature": 0.0, "avg_logprob": -0.09536731243133545, "compression_ratio": 1.755700325732899, "no_speech_prob": 0.08754303306341171}, {"id": 185, "seek": 86146, "start": 873.4200000000001, "end": 879.7, "text": " others though. For example, if I want to remove the very last element, I can do pop and that", "tokens": [50962, 2357, 1673, 13, 1171, 1365, 11, 498, 286, 528, 281, 4159, 264, 588, 1036, 4478, 11, 286, 393, 360, 1665, 293, 300, 51276], "temperature": 0.0, "avg_logprob": -0.09536731243133545, "compression_ratio": 1.755700325732899, "no_speech_prob": 0.08754303306341171}, {"id": 186, "seek": 86146, "start": 879.7, "end": 883.98, "text": " just removes last element. And this is a constant time operation happens very quickly. Time", "tokens": [51276, 445, 30445, 1036, 4478, 13, 400, 341, 307, 257, 5754, 565, 6916, 2314, 588, 2661, 13, 6161, 51490], "temperature": 0.0, "avg_logprob": -0.09536731243133545, "compression_ratio": 1.755700325732899, "no_speech_prob": 0.08754303306341171}, {"id": 187, "seek": 86146, "start": 883.98, "end": 888.38, "text": " doesn't change depending on the size of the list. However, if I want to remove the first", "tokens": [51490, 1177, 380, 1319, 5413, 322, 264, 2744, 295, 264, 1329, 13, 2908, 11, 498, 286, 528, 281, 4159, 264, 700, 51710], "temperature": 0.0, "avg_logprob": -0.09536731243133545, "compression_ratio": 1.755700325732899, "no_speech_prob": 0.08754303306341171}, {"id": 188, "seek": 88838, "start": 888.38, "end": 893.42, "text": " element, this is a big O of end time operation. And this could take a very long amount of", "tokens": [50364, 4478, 11, 341, 307, 257, 955, 422, 295, 917, 565, 6916, 13, 400, 341, 727, 747, 257, 588, 938, 2372, 295, 50616], "temperature": 0.0, "avg_logprob": -0.10133294112809742, "compression_ratio": 1.8541666666666667, "no_speech_prob": 0.13293592631816864}, {"id": 189, "seek": 88838, "start": 893.42, "end": 898.5, "text": " time depending on how long the list is. So in this situation, if you know, you need to", "tokens": [50616, 565, 5413, 322, 577, 938, 264, 1329, 307, 13, 407, 294, 341, 2590, 11, 498, 291, 458, 11, 291, 643, 281, 50870], "temperature": 0.0, "avg_logprob": -0.10133294112809742, "compression_ratio": 1.8541666666666667, "no_speech_prob": 0.13293592631816864}, {"id": 190, "seek": 88838, "start": 898.5, "end": 902.5, "text": " have an order collection of elements and you want to be say popping something from the", "tokens": [50870, 362, 364, 1668, 5765, 295, 4959, 293, 291, 528, 281, 312, 584, 18374, 746, 490, 264, 51070], "temperature": 0.0, "avg_logprob": -0.10133294112809742, "compression_ratio": 1.8541666666666667, "no_speech_prob": 0.13293592631816864}, {"id": 191, "seek": 88838, "start": 902.5, "end": 906.82, "text": " middle of the list or the beginning of the list or something along those lines, you should", "tokens": [51070, 2808, 295, 264, 1329, 420, 264, 2863, 295, 264, 1329, 420, 746, 2051, 729, 3876, 11, 291, 820, 51286], "temperature": 0.0, "avg_logprob": -0.10133294112809742, "compression_ratio": 1.8541666666666667, "no_speech_prob": 0.13293592631816864}, {"id": 192, "seek": 88838, "start": 906.82, "end": 911.42, "text": " use one of the two data structures I have up here. And sorry, that's from collections.", "tokens": [51286, 764, 472, 295, 264, 732, 1412, 9227, 286, 362, 493, 510, 13, 400, 2597, 11, 300, 311, 490, 16641, 13, 51516], "temperature": 0.0, "avg_logprob": -0.10133294112809742, "compression_ratio": 1.8541666666666667, "no_speech_prob": 0.13293592631816864}, {"id": 193, "seek": 88838, "start": 911.42, "end": 915.42, "text": " So Python has a built in module. It's called collections. And inside of it, it has something", "tokens": [51516, 407, 15329, 575, 257, 3094, 294, 10088, 13, 467, 311, 1219, 16641, 13, 400, 1854, 295, 309, 11, 309, 575, 746, 51716], "temperature": 0.0, "avg_logprob": -0.10133294112809742, "compression_ratio": 1.8541666666666667, "no_speech_prob": 0.13293592631816864}, {"id": 194, "seek": 91542, "start": 915.4599999999999, "end": 919.9799999999999, "text": " called a deck and a queue. I believe it also has a heap. It has a ton of other data structures", "tokens": [50366, 1219, 257, 9341, 293, 257, 18639, 13, 286, 1697, 309, 611, 575, 257, 33591, 13, 467, 575, 257, 2952, 295, 661, 1412, 9227, 50592], "temperature": 0.0, "avg_logprob": -0.1343947962710732, "compression_ratio": 1.910071942446043, "no_speech_prob": 0.25081706047058105}, {"id": 195, "seek": 91542, "start": 919.9799999999999, "end": 925.86, "text": " that you can use. Now a deck or a DQ, however you say this is a double ended queue and a", "tokens": [50592, 300, 291, 393, 764, 13, 823, 257, 9341, 420, 257, 413, 48, 11, 4461, 291, 584, 341, 307, 257, 3834, 4590, 18639, 293, 257, 50886], "temperature": 0.0, "avg_logprob": -0.1343947962710732, "compression_ratio": 1.910071942446043, "no_speech_prob": 0.25081706047058105}, {"id": 196, "seek": 91542, "start": 925.86, "end": 931.4599999999999, "text": " queue is essentially a first in first out data structure. It acts kind of like a queue", "tokens": [50886, 18639, 307, 4476, 257, 700, 294, 700, 484, 1412, 3877, 13, 467, 10672, 733, 295, 411, 257, 18639, 51166], "temperature": 0.0, "avg_logprob": -0.1343947962710732, "compression_ratio": 1.910071942446043, "no_speech_prob": 0.25081706047058105}, {"id": 197, "seek": 91542, "start": 931.4599999999999, "end": 935.02, "text": " that you'd have when you're on the phone, like waiting on hold or something like that.", "tokens": [51166, 300, 291, 1116, 362, 562, 291, 434, 322, 264, 2593, 11, 411, 3806, 322, 1797, 420, 746, 411, 300, 13, 51344], "temperature": 0.0, "avg_logprob": -0.1343947962710732, "compression_ratio": 1.910071942446043, "no_speech_prob": 0.25081706047058105}, {"id": 198, "seek": 91542, "start": 935.02, "end": 938.5799999999999, "text": " But a double ended queue, essentially all you need to know about the double ended queue", "tokens": [51344, 583, 257, 3834, 4590, 18639, 11, 4476, 439, 291, 643, 281, 458, 466, 264, 3834, 4590, 18639, 51522], "temperature": 0.0, "avg_logprob": -0.1343947962710732, "compression_ratio": 1.910071942446043, "no_speech_prob": 0.25081706047058105}, {"id": 199, "seek": 91542, "start": 938.5799999999999, "end": 942.5, "text": " is it allows you to remove something from the beginning and the end of it in constant", "tokens": [51522, 307, 309, 4045, 291, 281, 4159, 746, 490, 264, 2863, 293, 264, 917, 295, 309, 294, 5754, 51718], "temperature": 0.0, "avg_logprob": -0.1343947962710732, "compression_ratio": 1.910071942446043, "no_speech_prob": 0.25081706047058105}, {"id": 200, "seek": 94250, "start": 942.5, "end": 946.3, "text": " time. So if you know, you want to pop something from say the beginning of a list instead of", "tokens": [50364, 565, 13, 407, 498, 291, 458, 11, 291, 528, 281, 1665, 746, 490, 584, 264, 2863, 295, 257, 1329, 2602, 295, 50554], "temperature": 0.0, "avg_logprob": -0.10594370524088542, "compression_ratio": 1.7535816618911175, "no_speech_prob": 0.18238785862922668}, {"id": 201, "seek": 94250, "start": 946.3, "end": 950.86, "text": " using a list, just use a queue. It has very similar properties to the list, but it allows", "tokens": [50554, 1228, 257, 1329, 11, 445, 764, 257, 18639, 13, 467, 575, 588, 2531, 7221, 281, 264, 1329, 11, 457, 309, 4045, 50782], "temperature": 0.0, "avg_logprob": -0.10594370524088542, "compression_ratio": 1.7535816618911175, "no_speech_prob": 0.18238785862922668}, {"id": 202, "seek": 94250, "start": 950.86, "end": 955.7, "text": " you to actually remove elements from the front and from the back of it in constant", "tokens": [50782, 291, 281, 767, 4159, 4959, 490, 264, 1868, 293, 490, 264, 646, 295, 309, 294, 5754, 51024], "temperature": 0.0, "avg_logprob": -0.10594370524088542, "compression_ratio": 1.7535816618911175, "no_speech_prob": 0.18238785862922668}, {"id": 203, "seek": 94250, "start": 955.7, "end": 959.18, "text": " time. I'm not going to do a whole tutorial on these. I actually think I have some on", "tokens": [51024, 565, 13, 286, 478, 406, 516, 281, 360, 257, 1379, 7073, 322, 613, 13, 286, 767, 519, 286, 362, 512, 322, 51198], "temperature": 0.0, "avg_logprob": -0.10594370524088542, "compression_ratio": 1.7535816618911175, "no_speech_prob": 0.18238785862922668}, {"id": 204, "seek": 94250, "start": 959.18, "end": 963.66, "text": " my channel way, way back. Just wanted to mention though, that there is these built in data", "tokens": [51198, 452, 2269, 636, 11, 636, 646, 13, 1449, 1415, 281, 2152, 1673, 11, 300, 456, 307, 613, 3094, 294, 1412, 51422], "temperature": 0.0, "avg_logprob": -0.10594370524088542, "compression_ratio": 1.7535816618911175, "no_speech_prob": 0.18238785862922668}, {"id": 205, "seek": 94250, "start": 963.66, "end": 967.7, "text": " structures. They are much more efficient for specific operations. And just be careful", "tokens": [51422, 9227, 13, 814, 366, 709, 544, 7148, 337, 2685, 7705, 13, 400, 445, 312, 5026, 51624], "temperature": 0.0, "avg_logprob": -0.10594370524088542, "compression_ratio": 1.7535816618911175, "no_speech_prob": 0.18238785862922668}, {"id": 206, "seek": 94250, "start": 967.7, "end": 971.7, "text": " which one you're using based on what it is that you actually want to do. So moving on", "tokens": [51624, 597, 472, 291, 434, 1228, 2361, 322, 437, 309, 307, 300, 291, 767, 528, 281, 360, 13, 407, 2684, 322, 51824], "temperature": 0.0, "avg_logprob": -0.10594370524088542, "compression_ratio": 1.7535816618911175, "no_speech_prob": 0.18238785862922668}, {"id": 207, "seek": 97170, "start": 971.74, "end": 977.4200000000001, "text": " here to my final mistake, and this one is using the global keyword and global variables.", "tokens": [50366, 510, 281, 452, 2572, 6146, 11, 293, 341, 472, 307, 1228, 264, 4338, 20428, 293, 4338, 9102, 13, 50650], "temperature": 0.0, "avg_logprob": -0.15102544952841365, "compression_ratio": 1.832214765100671, "no_speech_prob": 0.41471341252326965}, {"id": 208, "seek": 97170, "start": 977.4200000000001, "end": 980.9000000000001, "text": " Now, if you watch this channel, you should be familiar with why you should not do that.", "tokens": [50650, 823, 11, 498, 291, 1159, 341, 2269, 11, 291, 820, 312, 4963, 365, 983, 291, 820, 406, 360, 300, 13, 50824], "temperature": 0.0, "avg_logprob": -0.15102544952841365, "compression_ratio": 1.832214765100671, "no_speech_prob": 0.41471341252326965}, {"id": 209, "seek": 97170, "start": 980.9000000000001, "end": 984.86, "text": " I have an entire video that I posted talking about why not to do this, but I will quickly", "tokens": [50824, 286, 362, 364, 2302, 960, 300, 286, 9437, 1417, 466, 983, 406, 281, 360, 341, 11, 457, 286, 486, 2661, 51022], "temperature": 0.0, "avg_logprob": -0.15102544952841365, "compression_ratio": 1.832214765100671, "no_speech_prob": 0.41471341252326965}, {"id": 210, "seek": 97170, "start": 984.86, "end": 989.62, "text": " summarize it here. So this program, very simple. I have a global variable called global var.", "tokens": [51022, 20858, 309, 510, 13, 407, 341, 1461, 11, 588, 2199, 13, 286, 362, 257, 4338, 7006, 1219, 4338, 1374, 13, 51260], "temperature": 0.0, "avg_logprob": -0.15102544952841365, "compression_ratio": 1.832214765100671, "no_speech_prob": 0.41471341252326965}, {"id": 211, "seek": 97170, "start": 989.62, "end": 994.5400000000001, "text": " I have two functions bar and foo. In the first function, I say global global var. That means", "tokens": [51260, 286, 362, 732, 6828, 2159, 293, 726, 78, 13, 682, 264, 700, 2445, 11, 286, 584, 4338, 4338, 1374, 13, 663, 1355, 51506], "temperature": 0.0, "avg_logprob": -0.15102544952841365, "compression_ratio": 1.832214765100671, "no_speech_prob": 0.41471341252326965}, {"id": 212, "seek": 97170, "start": 994.5400000000001, "end": 999.7, "text": " that I am going to access or whenever I access this name, I'm going to treat it as the global", "tokens": [51506, 300, 286, 669, 516, 281, 2105, 420, 5699, 286, 2105, 341, 1315, 11, 286, 478, 516, 281, 2387, 309, 382, 264, 4338, 51764], "temperature": 0.0, "avg_logprob": -0.15102544952841365, "compression_ratio": 1.832214765100671, "no_speech_prob": 0.41471341252326965}, {"id": 213, "seek": 99970, "start": 999.7, "end": 1003.5400000000001, "text": " variable. So when I print global var, I'm going to print this. When I say global var", "tokens": [50364, 7006, 13, 407, 562, 286, 4482, 4338, 1374, 11, 286, 478, 516, 281, 4482, 341, 13, 1133, 286, 584, 4338, 1374, 50556], "temperature": 0.0, "avg_logprob": -0.1513975633893694, "compression_ratio": 1.9871794871794872, "no_speech_prob": 0.05183975771069527}, {"id": 214, "seek": 99970, "start": 1003.5400000000001, "end": 1007.5400000000001, "text": " is equal to X. I'm going to print this. In fact, let me just say print. And let's go", "tokens": [50556, 307, 2681, 281, 1783, 13, 286, 478, 516, 281, 4482, 341, 13, 682, 1186, 11, 718, 385, 445, 584, 4482, 13, 400, 718, 311, 352, 50756], "temperature": 0.0, "avg_logprob": -0.1513975633893694, "compression_ratio": 1.9871794871794872, "no_speech_prob": 0.05183975771069527}, {"id": 215, "seek": 99970, "start": 1007.5400000000001, "end": 1012.3000000000001, "text": " with global var down here. And who's the other point? That's what's happened. Then I have", "tokens": [50756, 365, 4338, 1374, 760, 510, 13, 400, 567, 311, 264, 661, 935, 30, 663, 311, 437, 311, 2011, 13, 1396, 286, 362, 50994], "temperature": 0.0, "avg_logprob": -0.1513975633893694, "compression_ratio": 1.9871794871794872, "no_speech_prob": 0.05183975771069527}, {"id": 216, "seek": 99970, "start": 1012.3000000000001, "end": 1016.9000000000001, "text": " foo and inside of here, I print global var. I define global var equal to X. And then I", "tokens": [50994, 726, 78, 293, 1854, 295, 510, 11, 286, 4482, 4338, 1374, 13, 286, 6964, 4338, 1374, 2681, 281, 1783, 13, 400, 550, 286, 51224], "temperature": 0.0, "avg_logprob": -0.1513975633893694, "compression_ratio": 1.9871794871794872, "no_speech_prob": 0.05183975771069527}, {"id": 217, "seek": 99970, "start": 1016.9000000000001, "end": 1020.5, "text": " print global var. Now, first of all, just say guess what you think the output of this program", "tokens": [51224, 4482, 4338, 1374, 13, 823, 11, 700, 295, 439, 11, 445, 584, 2041, 437, 291, 519, 264, 5598, 295, 341, 1461, 51404], "temperature": 0.0, "avg_logprob": -0.1513975633893694, "compression_ratio": 1.9871794871794872, "no_speech_prob": 0.05183975771069527}, {"id": 218, "seek": 99970, "start": 1020.5, "end": 1024.22, "text": " is going to be. Pause the video if you need to. I'm about to run the code. And then I'll", "tokens": [51404, 307, 516, 281, 312, 13, 31973, 264, 960, 498, 291, 643, 281, 13, 286, 478, 466, 281, 1190, 264, 3089, 13, 400, 550, 286, 603, 51590], "temperature": 0.0, "avg_logprob": -0.1513975633893694, "compression_ratio": 1.9871794871794872, "no_speech_prob": 0.05183975771069527}, {"id": 219, "seek": 99970, "start": 1024.22, "end": 1028.22, "text": " talk about kind of the weird stuff that we're getting. So when I run this, you see that we", "tokens": [51590, 751, 466, 733, 295, 264, 3657, 1507, 300, 321, 434, 1242, 13, 407, 562, 286, 1190, 341, 11, 291, 536, 300, 321, 51790], "temperature": 0.0, "avg_logprob": -0.1513975633893694, "compression_ratio": 1.9871794871794872, "no_speech_prob": 0.05183975771069527}, {"id": 220, "seek": 102822, "start": 1028.22, "end": 1034.06, "text": " get 10, 20, and then we get an exception. Now, let's talk about this. So what's happening", "tokens": [50364, 483, 1266, 11, 945, 11, 293, 550, 321, 483, 364, 11183, 13, 823, 11, 718, 311, 751, 466, 341, 13, 407, 437, 311, 2737, 50656], "temperature": 0.0, "avg_logprob": -0.10977508200973761, "compression_ratio": 1.6567164179104477, "no_speech_prob": 0.05664355307817459}, {"id": 221, "seek": 102822, "start": 1034.06, "end": 1039.78, "text": " is I'm calling bar. The bar function actually executes fine. And what it does is it prints", "tokens": [50656, 307, 286, 478, 5141, 2159, 13, 440, 2159, 2445, 767, 4454, 1819, 2489, 13, 400, 437, 309, 775, 307, 309, 22305, 50942], "temperature": 0.0, "avg_logprob": -0.10977508200973761, "compression_ratio": 1.6567164179104477, "no_speech_prob": 0.05664355307817459}, {"id": 222, "seek": 102822, "start": 1039.78, "end": 1045.26, "text": " out 10 and 20. So I'm printing the value of the global variable. I'm then changing global", "tokens": [50942, 484, 1266, 293, 945, 13, 407, 286, 478, 14699, 264, 2158, 295, 264, 4338, 7006, 13, 286, 478, 550, 4473, 4338, 51216], "temperature": 0.0, "avg_logprob": -0.10977508200973761, "compression_ratio": 1.6567164179104477, "no_speech_prob": 0.05664355307817459}, {"id": 223, "seek": 102822, "start": 1045.26, "end": 1050.66, "text": " var to be equal to X, which I pass in here as 20. And then I'm printing it again. And", "tokens": [51216, 1374, 281, 312, 2681, 281, 1783, 11, 597, 286, 1320, 294, 510, 382, 945, 13, 400, 550, 286, 478, 14699, 309, 797, 13, 400, 51486], "temperature": 0.0, "avg_logprob": -0.10977508200973761, "compression_ratio": 1.6567164179104477, "no_speech_prob": 0.05664355307817459}, {"id": 224, "seek": 102822, "start": 1050.66, "end": 1054.26, "text": " of course I'm getting 20 because I've changed this in the global scope. However, when I", "tokens": [51486, 295, 1164, 286, 478, 1242, 945, 570, 286, 600, 3105, 341, 294, 264, 4338, 11923, 13, 2908, 11, 562, 286, 51666], "temperature": 0.0, "avg_logprob": -0.10977508200973761, "compression_ratio": 1.6567164179104477, "no_speech_prob": 0.05664355307817459}, {"id": 225, "seek": 105426, "start": 1054.26, "end": 1060.22, "text": " then go and call foo, what happens here is I get this exception. It says unbounded local", "tokens": [50364, 550, 352, 293, 818, 726, 78, 11, 437, 2314, 510, 307, 286, 483, 341, 11183, 13, 467, 1619, 517, 18767, 292, 2654, 50662], "temperature": 0.0, "avg_logprob": -0.13063374736852812, "compression_ratio": 1.6444444444444444, "no_speech_prob": 0.14411881566047668}, {"id": 226, "seek": 105426, "start": 1060.22, "end": 1065.9, "text": " error, uh, our local variable global var reference before assignment. Now that is on this line", "tokens": [50662, 6713, 11, 2232, 11, 527, 2654, 7006, 4338, 1374, 6408, 949, 15187, 13, 823, 300, 307, 322, 341, 1622, 50946], "temperature": 0.0, "avg_logprob": -0.13063374736852812, "compression_ratio": 1.6444444444444444, "no_speech_prob": 0.14411881566047668}, {"id": 227, "seek": 105426, "start": 1065.9, "end": 1071.34, "text": " right here. So line, uh, 10. And the reason I'm getting this is because I have actually", "tokens": [50946, 558, 510, 13, 407, 1622, 11, 2232, 11, 1266, 13, 400, 264, 1778, 286, 478, 1242, 341, 307, 570, 286, 362, 767, 51218], "temperature": 0.0, "avg_logprob": -0.13063374736852812, "compression_ratio": 1.6444444444444444, "no_speech_prob": 0.14411881566047668}, {"id": 228, "seek": 105426, "start": 1071.34, "end": 1077.58, "text": " defined a local variable, global var, uh, inside of this function. And it's kind of", "tokens": [51218, 7642, 257, 2654, 7006, 11, 4338, 1374, 11, 2232, 11, 1854, 295, 341, 2445, 13, 400, 309, 311, 733, 295, 51530], "temperature": 0.0, "avg_logprob": -0.13063374736852812, "compression_ratio": 1.6444444444444444, "no_speech_prob": 0.14411881566047668}, {"id": 229, "seek": 105426, "start": 1077.58, "end": 1082.82, "text": " weird how Python does this, but essentially, since this is defined down here, when I try", "tokens": [51530, 3657, 577, 15329, 775, 341, 11, 457, 4476, 11, 1670, 341, 307, 7642, 760, 510, 11, 562, 286, 853, 51792], "temperature": 0.0, "avg_logprob": -0.13063374736852812, "compression_ratio": 1.6444444444444444, "no_speech_prob": 0.14411881566047668}, {"id": 230, "seek": 108282, "start": 1082.86, "end": 1088.4199999999998, "text": " to print global var, even though I have a global variable with that name, it's not going", "tokens": [50366, 281, 4482, 4338, 1374, 11, 754, 1673, 286, 362, 257, 4338, 7006, 365, 300, 1315, 11, 309, 311, 406, 516, 50644], "temperature": 0.0, "avg_logprob": -0.1029508534599753, "compression_ratio": 1.816326530612245, "no_speech_prob": 0.02843366004526615}, {"id": 231, "seek": 108282, "start": 1088.4199999999998, "end": 1091.7, "text": " to reference that it's going to reference the one in the local scope. And since it's", "tokens": [50644, 281, 6408, 300, 309, 311, 516, 281, 6408, 264, 472, 294, 264, 2654, 11923, 13, 400, 1670, 309, 311, 50808], "temperature": 0.0, "avg_logprob": -0.1029508534599753, "compression_ratio": 1.816326530612245, "no_speech_prob": 0.02843366004526615}, {"id": 232, "seek": 108282, "start": 1091.7, "end": 1096.74, "text": " not yet defined, I get an exception. I know kind of weird. One of the reasons, again,", "tokens": [50808, 406, 1939, 7642, 11, 286, 483, 364, 11183, 13, 286, 458, 733, 295, 3657, 13, 1485, 295, 264, 4112, 11, 797, 11, 51060], "temperature": 0.0, "avg_logprob": -0.1029508534599753, "compression_ratio": 1.816326530612245, "no_speech_prob": 0.02843366004526615}, {"id": 233, "seek": 108282, "start": 1096.74, "end": 1102.06, "text": " you don't really want to be using global variables is because if you try to write a local version", "tokens": [51060, 291, 500, 380, 534, 528, 281, 312, 1228, 4338, 9102, 307, 570, 498, 291, 853, 281, 2464, 257, 2654, 3037, 51326], "temperature": 0.0, "avg_logprob": -0.1029508534599753, "compression_ratio": 1.816326530612245, "no_speech_prob": 0.02843366004526615}, {"id": 234, "seek": 108282, "start": 1102.06, "end": 1105.8999999999999, "text": " of that inside of the function, you're going to get these weird errors when you try to", "tokens": [51326, 295, 300, 1854, 295, 264, 2445, 11, 291, 434, 516, 281, 483, 613, 3657, 13603, 562, 291, 853, 281, 51518], "temperature": 0.0, "avg_logprob": -0.1029508534599753, "compression_ratio": 1.816326530612245, "no_speech_prob": 0.02843366004526615}, {"id": 235, "seek": 108282, "start": 1105.8999999999999, "end": 1111.86, "text": " access that value above in the function. Now, if I were to do this, this would work fine.", "tokens": [51518, 2105, 300, 2158, 3673, 294, 264, 2445, 13, 823, 11, 498, 286, 645, 281, 360, 341, 11, 341, 576, 589, 2489, 13, 51816], "temperature": 0.0, "avg_logprob": -0.1029508534599753, "compression_ratio": 1.816326530612245, "no_speech_prob": 0.02843366004526615}, {"id": 236, "seek": 111186, "start": 1111.8999999999999, "end": 1117.26, "text": " I wouldn't get any issues with that. However, again, since I'm doing this before I am defining", "tokens": [50366, 286, 2759, 380, 483, 604, 2663, 365, 300, 13, 2908, 11, 797, 11, 1670, 286, 478, 884, 341, 949, 286, 669, 17827, 50634], "temperature": 0.0, "avg_logprob": -0.10268971559812697, "compression_ratio": 1.7258064516129032, "no_speech_prob": 0.025176698341965675}, {"id": 237, "seek": 111186, "start": 1117.26, "end": 1121.58, "text": " this variable, I get that error. So hopefully it makes a bit of sense as to why that is", "tokens": [50634, 341, 7006, 11, 286, 483, 300, 6713, 13, 407, 4696, 309, 1669, 257, 857, 295, 2020, 382, 281, 983, 300, 307, 50850], "temperature": 0.0, "avg_logprob": -0.10268971559812697, "compression_ratio": 1.7258064516129032, "no_speech_prob": 0.025176698341965675}, {"id": 238, "seek": 111186, "start": 1121.58, "end": 1126.58, "text": " occurring again. Really, it's because I have a local version of my global variable. Whenever", "tokens": [50850, 18386, 797, 13, 4083, 11, 309, 311, 570, 286, 362, 257, 2654, 3037, 295, 452, 4338, 7006, 13, 14159, 51100], "temperature": 0.0, "avg_logprob": -0.10268971559812697, "compression_ratio": 1.7258064516129032, "no_speech_prob": 0.025176698341965675}, {"id": 239, "seek": 111186, "start": 1126.58, "end": 1130.5, "text": " I have that in a function, that's what I'm going to be accessing when I use that name.", "tokens": [51100, 286, 362, 300, 294, 257, 2445, 11, 300, 311, 437, 286, 478, 516, 281, 312, 26440, 562, 286, 764, 300, 1315, 13, 51296], "temperature": 0.0, "avg_logprob": -0.10268971559812697, "compression_ratio": 1.7258064516129032, "no_speech_prob": 0.025176698341965675}, {"id": 240, "seek": 111186, "start": 1130.5, "end": 1134.34, "text": " So when I try to access it here, it's not yet defined. Well, that causes an exception.", "tokens": [51296, 407, 562, 286, 853, 281, 2105, 309, 510, 11, 309, 311, 406, 1939, 7642, 13, 1042, 11, 300, 7700, 364, 11183, 13, 51488], "temperature": 0.0, "avg_logprob": -0.10268971559812697, "compression_ratio": 1.7258064516129032, "no_speech_prob": 0.025176698341965675}, {"id": 241, "seek": 111186, "start": 1134.34, "end": 1138.1799999999998, "text": " Anyways, that was my final mistake for you guys. I wanted to keep this video nice and", "tokens": [51488, 15585, 11, 300, 390, 452, 2572, 6146, 337, 291, 1074, 13, 286, 1415, 281, 1066, 341, 960, 1481, 293, 51680], "temperature": 0.0, "avg_logprob": -0.10268971559812697, "compression_ratio": 1.7258064516129032, "no_speech_prob": 0.025176698341965675}, {"id": 242, "seek": 113818, "start": 1138.18, "end": 1142.3, "text": " short and just quickly give you a few things to help you improve your Python coding. If", "tokens": [50364, 2099, 293, 445, 2661, 976, 291, 257, 1326, 721, 281, 854, 291, 3470, 428, 15329, 17720, 13, 759, 50570], "temperature": 0.0, "avg_logprob": -0.19211993497960708, "compression_ratio": 1.393103448275862, "no_speech_prob": 0.8372006416320801}, {"id": 243, "seek": 113818, "start": 1142.3, "end": 1145.78, "text": " you enjoyed, make sure you leave a like, subscribe to the channel, and I hope to see you in", "tokens": [50570, 291, 4626, 11, 652, 988, 291, 1856, 257, 411, 11, 3022, 281, 264, 2269, 11, 293, 286, 1454, 281, 536, 291, 294, 50744], "temperature": 0.0, "avg_logprob": -0.19211993497960708, "compression_ratio": 1.393103448275862, "no_speech_prob": 0.8372006416320801}, {"id": 244, "seek": 113818, "start": 1145.78, "end": 1147.5, "text": " another YouTube video.", "tokens": [50744, 1071, 3088, 960, 13, 50830], "temperature": 0.0, "avg_logprob": -0.19211993497960708, "compression_ratio": 1.393103448275862, "no_speech_prob": 0.8372006416320801}], "language": "en"}