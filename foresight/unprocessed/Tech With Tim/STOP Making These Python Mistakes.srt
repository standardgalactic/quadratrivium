1
00:00:00,000 --> 00:00:13,080
If you're watching this video and you write code in Python, then chances are you're familiar

2
00:00:13,080 --> 00:00:17,000
with what a unique language it is, and you utilize some of the awesome features that

3
00:00:17,000 --> 00:00:21,920
Python provides. Now, this is great and Python is an awesome language, but because it is

4
00:00:21,920 --> 00:00:26,280
pretty unique and it's not like a lot of the traditional programming languages, there's

5
00:00:26,280 --> 00:00:31,080
a lot of ways that you can make mistakes in Python without really realizing it. Python

6
00:00:31,080 --> 00:00:35,640
is, as I said, a unique and kind of quirky language. It allows you to do a ton of stuff

7
00:00:35,640 --> 00:00:40,840
and it's very flexible, but with that flexibility, it allows you to make a bunch of mistakes

8
00:00:40,840 --> 00:00:45,440
that are really hard to catch if you haven't watched a video like this. So with that said,

9
00:00:45,440 --> 00:00:48,520
let's get into this video and I'm going to walk you through some mistakes that you're

10
00:00:48,520 --> 00:00:53,400
probably making in Python and that you can easily fix by going through these tips. So

11
00:00:53,400 --> 00:00:56,440
the first mistake that I'm sure many of you are making is that you haven't checked out

12
00:00:56,440 --> 00:01:00,840
my programming course yet called programming expert. I'll leave it in the description.

13
00:01:00,840 --> 00:01:04,680
This is a unique course that teaches Python, specifically some more advanced features of

14
00:01:04,680 --> 00:01:09,440
Python. And we recently added go to it as a second language. So don't make that mistake.

15
00:01:09,440 --> 00:01:13,240
Check that out from the link in the description. But in all seriousness here, the first mistake

16
00:01:13,240 --> 00:01:17,640
that you're probably making is something called name shadowing. Now name shadowing occurs

17
00:01:17,640 --> 00:01:22,680
when you name your variable parameter function, really anything you're defining a name for

18
00:01:22,680 --> 00:01:27,840
a built in function, some built in name or something in the current scope that's already

19
00:01:27,840 --> 00:01:32,640
defined. So for example, here, if we have this function called get database record,

20
00:01:32,640 --> 00:01:37,420
we have a parameter here called ID. Now this is a shadowed name. And the reason this is

21
00:01:37,420 --> 00:01:42,520
shadowed is because you're naming this a built in function. So in Python, we actually have

22
00:01:42,520 --> 00:01:46,920
a built in function here called ID. Many people don't know about this function. And

23
00:01:46,920 --> 00:01:51,560
so they'll do something like this, where they write a function and then they name this parameter.

24
00:01:51,560 --> 00:01:55,800
They give a parameter name of ID. Now you'll notice here, when I write ID, I'm getting

25
00:01:55,800 --> 00:02:00,760
the syntax highlighting as if it was a function, because that's what Python knows to do. But

26
00:02:00,760 --> 00:02:04,840
this is not going to be treated as a function. It's going to be treated as the parameter.

27
00:02:04,840 --> 00:02:08,120
So that is the intended behavior when we're looking at a function like this, but it can

28
00:02:08,120 --> 00:02:12,240
be really confusing if you're familiar with the built in functions. And you have kind

29
00:02:12,240 --> 00:02:17,280
of a long function or a long class or something like that when you're reading shadowed names.

30
00:02:17,280 --> 00:02:20,900
So really you want to avoid name shadowing as much as you can. And one of the only ways

31
00:02:20,920 --> 00:02:25,260
to do that in Python, it's just to ensure that you're not naming your parameters, functions,

32
00:02:25,260 --> 00:02:30,540
et cetera, a built in name. So something like ID, maybe something like max, that's a really

33
00:02:30,540 --> 00:02:35,140
common one, something like min, you want to avoid those names because again, they're built

34
00:02:35,140 --> 00:02:39,840
in functions. And if you do name something that in the current scope, so in this function,

35
00:02:39,840 --> 00:02:45,020
you can no longer use this as the function. So if I try to do something like ID here,

36
00:02:45,020 --> 00:02:49,820
let's just call this function. So get database record. Let's pass in one. Notice it says

37
00:02:49,860 --> 00:02:54,980
the int object is not callable because I've overridden the ID function by shadowing its

38
00:02:54,980 --> 00:02:59,740
name. Now this can occur when you have nested functions as well in all, and in all kinds

39
00:02:59,740 --> 00:03:03,660
of other scenarios. Another really common thing here is when you shadow a name from

40
00:03:03,660 --> 00:03:09,900
the global scope. So for example, if I make my parameter here named database, or I accept

41
00:03:09,900 --> 00:03:15,700
maybe like ID and database like that. Again, if you have a longer function, it can be confusing

42
00:03:15,700 --> 00:03:19,740
when I'm reading this code. If I'm referring to the database parameter, if I spelt that

43
00:03:19,780 --> 00:03:24,580
correctly, or the database variable in the global scope. So obviously this isn't always

44
00:03:24,580 --> 00:03:28,780
avoidable. The main thing here is just don't name your parameters or variables a built

45
00:03:28,780 --> 00:03:34,020
in name like max min ID, not only because it's confusing, but because you also now

46
00:03:34,020 --> 00:03:38,900
make it so you can no longer use those functions inside of wherever you've given that name.

47
00:03:38,900 --> 00:03:44,340
So another mistake that you are likely unintentionally making in Python is using a mutable object

48
00:03:44,340 --> 00:03:48,940
as the default value for an optional parameter. Now, I know that's a mouthful, but if you

49
00:03:48,980 --> 00:03:53,380
look here at this function, it's called mutable parameter. And we have an optional parameter.

50
00:03:53,380 --> 00:03:57,700
We know it's optional because we have it assigned to a default value. If you don't pass it against

51
00:03:57,700 --> 00:04:02,980
the default value and the default value is a mutable object, which is a list. Now, let

52
00:04:02,980 --> 00:04:07,500
me show you why this is bad by running the code. So when I run the code, we actually

53
00:04:07,500 --> 00:04:11,340
get an unexpected output. If you're from another programming language where we get

54
00:04:11,340 --> 00:04:15,860
one, two, one, two, one, two, and then one, two, one, two, one, two. Now, the reason this

55
00:04:15,900 --> 00:04:20,620
occurs is because this is mutable. That means we can actually mutate it. We can change it

56
00:04:20,620 --> 00:04:25,500
in place. So when I do something like LST dot append one and LST dot append two, I'm

57
00:04:25,500 --> 00:04:31,300
actually mutating this list right here, which is the same list that's going to be the default

58
00:04:31,300 --> 00:04:36,740
value for the next call to this function. So you can see on every consecutive call, we're

59
00:04:36,740 --> 00:04:42,140
actually adding elements to this same list. This list does not get recreated every single

60
00:04:42,140 --> 00:04:47,420
time the function is called. It gets created one time when we define the function. That's

61
00:04:47,420 --> 00:04:51,300
the way that the, uh, the default value works here. So if you want to avoid this and you

62
00:04:51,300 --> 00:04:57,180
do want to actually have a, uh, mutable value or a mutable object as your default parameter,

63
00:04:57,180 --> 00:05:01,820
you should do something like this instead and then manually check inside of the function.

64
00:05:01,820 --> 00:05:08,340
If this is not, so I'm going to say if LST is none, then I will say LST is equal to

65
00:05:08,460 --> 00:05:12,780
and make that a list. So now if I run this notice, we don't get that error anymore because

66
00:05:12,780 --> 00:05:19,020
I'm recreating a new list object, every function call as opposed to using the same one that's

67
00:05:19,020 --> 00:05:23,620
only created one time when my, uh, program is actually kind of initialized and the function

68
00:05:23,620 --> 00:05:27,380
is read by the interpreter. Hopefully that makes a bit of sense. Try not to make this

69
00:05:27,380 --> 00:05:31,660
issue or try not to make this mistake. This also happens if you use dictionaries, if you

70
00:05:31,660 --> 00:05:36,700
set in any other mutable object. So the next mistake I have here is a more general one.

71
00:05:36,740 --> 00:05:41,660
This could apply to any programming language, and this is modifying an iterable object while

72
00:05:41,660 --> 00:05:45,380
you're iterating through it. So in this case, I have something that's iterable, which is

73
00:05:45,380 --> 00:05:49,500
a list just means I can loop through it, right? Using a for loop in this case, and I have

74
00:05:49,500 --> 00:05:53,460
for I comma value in enumerate list. So it's going to give me the value as well as the

75
00:05:53,460 --> 00:05:58,660
index of each element. And I'm saying if the index is divisible by two, then I'm going

76
00:05:58,660 --> 00:06:03,420
to pop this index from my list. Now, if you're looking at this here, uh, and you just kind

77
00:06:03,420 --> 00:06:08,140
of take all the indices and apply this to it. We should be popping one. We should be

78
00:06:08,140 --> 00:06:12,900
popping three because that's index two. We should be popping five. That's index four,

79
00:06:12,900 --> 00:06:17,780
popping seven, and then popping nine. However, when I run this, notice that I get kind of

80
00:06:17,780 --> 00:06:23,500
a weird result. I get two, three, five, six, eight, nine kind of strange why I'm getting

81
00:06:23,500 --> 00:06:28,700
that. But the reason is because I'm modifying this iterable object while I'm looping through

82
00:06:28,700 --> 00:06:33,420
it. So if I have a look here and I print out I value, and actually let's not print

83
00:06:33,420 --> 00:06:38,020
out value. Let's print out I and LST. And let's have a look at it at every iteration.

84
00:06:38,020 --> 00:06:43,380
We see I zero and then one, two, three, four, five all the way up until six. And what happens

85
00:06:43,380 --> 00:06:47,820
is we don't actually end up iterating through every unique element in the list because we're

86
00:06:47,820 --> 00:06:52,420
popping it as we go. And the enumerate function works a little bit differently than the range

87
00:06:52,420 --> 00:06:57,940
function in Python. And to show you this, uh, let's do another example. So let's change

88
00:06:57,980 --> 00:07:02,980
this now to say for I, and this is going to be in range. And then this will be the

89
00:07:02,980 --> 00:07:07,420
length of LST. So you would imagine we just get the exact same result here. But when I

90
00:07:07,420 --> 00:07:12,500
run this, notice now we get pop index out of range. Well, the issue here is that we're

91
00:07:12,500 --> 00:07:17,740
reducing the length of the list while we're iterating through it. And the range function

92
00:07:17,740 --> 00:07:22,740
has kind of a constant range that we're going to be iterating through. So as soon as I define

93
00:07:22,740 --> 00:07:26,540
that I'm going to iterate through the range of zero to nine, that doesn't change the whole

94
00:07:26,620 --> 00:07:30,300
time I'm going through this for loop. So even if I modify the length of the list, this

95
00:07:30,300 --> 00:07:34,820
hasn't changed because I've put a constant value here. Whereas when we have the enumerate,

96
00:07:34,820 --> 00:07:38,580
this will actually change based on the length of the list. And again, that's why you get

97
00:07:38,580 --> 00:07:42,660
that weird result. So that's what I wanted to share with you. Don't do this. It cause

98
00:07:42,660 --> 00:07:47,100
a lot of headaches. Only do this. If you really understand what you're doing. And if you want

99
00:07:47,100 --> 00:07:51,780
to make a modification to a list while you're iterating through it, usually what I like

100
00:07:51,780 --> 00:07:56,180
to do is store the modifications I want to make somewhere else, iterate through the list

101
00:07:56,220 --> 00:08:01,180
entirely one time and then run a for loop and just make those specific iterations that

102
00:08:01,180 --> 00:08:05,580
I want to. Hopefully that makes a bit of sense, but that is mistake number three. So the

103
00:08:05,580 --> 00:08:09,820
next mistake I have to share with you is one that is super tricky to figure out if you've

104
00:08:09,820 --> 00:08:14,860
never seen this before. And this is called name clashing. Now this happens when you

105
00:08:14,860 --> 00:08:20,140
name your Python file, which we're going to refer to as a module here, the name of a built

106
00:08:20,140 --> 00:08:24,780
in module in Python or a third party module that you've installed using something like

107
00:08:24,860 --> 00:08:29,900
PIP. So looking at this example here, I have a little script where I import Pi game. Pi

108
00:08:29,900 --> 00:08:34,620
game is a third party Python module. I installed this on my system and this lets me build 2D

109
00:08:34,620 --> 00:08:38,900
games. You guys have probably seen this on my channel before. Anyways, I have Pi game.

110
00:08:38,900 --> 00:08:42,940
Now when I run this, I get an error and it says this is most likely due to a circular

111
00:08:42,940 --> 00:08:47,820
import, but this is only happening in this file. If I throw this in another file, this

112
00:08:47,820 --> 00:08:51,980
code will work completely fine. So what's going on here? Well, the issue is I've named

113
00:08:52,020 --> 00:08:56,980
my Python module Pi game. So I've named it the thing that I'm trying to import. So what

114
00:08:56,980 --> 00:09:01,180
happens is when I try to import Pi game, I'm trying to import the module that I'm currently

115
00:09:01,180 --> 00:09:05,660
working in myself. And then I get this error and it's saying it doesn't have the attribute.

116
00:09:05,660 --> 00:09:08,420
So to show you how you would fix this, you would rename the file. So let's call this

117
00:09:08,420 --> 00:09:13,620
Pi game one now. And when I run this code, notice we no longer get that error and actually

118
00:09:13,620 --> 00:09:17,300
pops up a little Pi game screen. Obviously it goes away because I haven't coded anything

119
00:09:17,300 --> 00:09:22,460
else out. So be careful about that. Do not name your Python modules, your Python files,

120
00:09:22,460 --> 00:09:27,620
a built in module or a module that you're going to be importing or using in your program.

121
00:09:27,620 --> 00:09:32,620
So moving on, the next mistake I have for you is using a naked accept. Now here I have

122
00:09:32,620 --> 00:09:38,700
a try accept block and this exception or this accept block is going to accept any exception.

123
00:09:38,700 --> 00:09:42,300
So if anything happens in here, that's an error that crashes the program, we're going

124
00:09:42,300 --> 00:09:47,220
to go in here and print. I crashed. Now that's great. It's useful that we have this feature.

125
00:09:47,220 --> 00:09:52,740
The issue is this accepts anything, which means I don't know why I crashed when I'm

126
00:09:52,740 --> 00:09:57,660
reading this code and I see this message being printed out. Now this is really bad practice

127
00:09:57,660 --> 00:10:01,980
because it makes it really hard to debug your code. Uh, and you just really shouldn't do

128
00:10:01,980 --> 00:10:06,780
this. You should handle each individual exception as opposed to just any general exception,

129
00:10:06,780 --> 00:10:10,940
uh, kind of for obvious reasons. But in this case, I have two things inside of here that

130
00:10:10,940 --> 00:10:15,020
could fail, right? This could fail, trying to open a file in read mode, because if the

131
00:10:15,020 --> 00:10:19,260
file doesn't exist, we'll get an exception and then dividing one by zero. Well, zero

132
00:10:19,260 --> 00:10:23,100
division, that's an error, no matter what. So two things that could fail. And when I

133
00:10:23,100 --> 00:10:27,780
run the code here, all I get is I crashed. So I don't know if it was because I was unable

134
00:10:27,780 --> 00:10:32,300
to open the file or because I divided by zero. And now if I delete the file that currently

135
00:10:32,300 --> 00:10:36,860
exists, so Tim dot TXT, I have that there and I run this again, I get, I crashed. So

136
00:10:36,860 --> 00:10:41,460
of course the solution here is to accept a specific exception and multiple of them if

137
00:10:41,460 --> 00:10:45,060
you want to. So you kind of just need to know what the names of these are. You can look

138
00:10:45,060 --> 00:10:49,740
them up. You also can just crash your program and see what the exception is. But for now,

139
00:10:49,740 --> 00:10:53,740
let's accept the zero division error. So the zero division error is simply called zero

140
00:10:53,740 --> 00:10:59,420
division error. You shall also get some syntax highlighting for it. And now I can say I tried

141
00:10:59,420 --> 00:11:06,140
to divide by zero dot, dot, dot. Okay. Uh, now let's just comment this line out. Let's

142
00:11:06,140 --> 00:11:10,620
run this and then we get, I tried to divide by zero. If I uncomment that and make my

143
00:11:10,620 --> 00:11:17,140
new file. So let's save this as Tim dot TXT. You guys put tests inside of there, save

144
00:11:17,140 --> 00:11:22,020
and run. Uh, notice that I get, I tried to divide by zero, uh, because I'm accepting

145
00:11:22,020 --> 00:11:26,860
the zero division error. This obviously did not have an exception. All right. Now though,

146
00:11:26,860 --> 00:11:31,860
if we want to handle both of these exceptions, we can write multiple except blocks. So I

147
00:11:31,860 --> 00:11:37,340
can do accept and then I can accept. I think this is the file not found error and I can

148
00:11:37,340 --> 00:11:45,220
print out. I could not find the file dot dot dot. So now if I delete the file again,

149
00:11:45,220 --> 00:11:49,820
let's delete that. Let's run this. Then I get, I could not find the file. One last thing

150
00:11:49,820 --> 00:11:55,300
I will throw in here before I leave. Uh, you also can have as E or as something. Now when

151
00:11:55,300 --> 00:11:59,660
I do that, it will actually give me access to the error in the scope. So I can do something

152
00:11:59,660 --> 00:12:04,020
like print E. Let's just comment this out now. And then you can actually view what the

153
00:12:04,020 --> 00:12:08,780
exception string message is. So keep that in mind. That sometimes can be useful, but

154
00:12:08,780 --> 00:12:12,900
please, when you're writing your except blocks, except a specific exception, it will help

155
00:12:12,900 --> 00:12:19,380
you later on. So moving on to my next mistake. And this one is using the wrong data structure.

156
00:12:19,380 --> 00:12:22,700
Now this is common and you could do this in any programming language, but this is very

157
00:12:22,700 --> 00:12:26,820
important in Python because there's a lot of operations that you can perform on a data

158
00:12:26,820 --> 00:12:31,460
structure that are very inefficient and that if you were to use a different data structure,

159
00:12:31,460 --> 00:12:35,620
you'd have a much more efficient algorithm. And if you're unfamiliar with time complexity,

160
00:12:35,620 --> 00:12:39,700
don't worry. That's kind of what I'm referring to here. Really, what we're talking about

161
00:12:39,700 --> 00:12:44,540
is how fast can you perform an operation and which data structure or built in type is going

162
00:12:44,540 --> 00:12:49,540
to be the best for what it is that you're doing. So in Python, we have really three core data

163
00:12:49,540 --> 00:12:53,420
structures you should understand. And that's going to be a list set in dictionary. We have

164
00:12:53,420 --> 00:12:58,580
string as well, but I won't put that in here. Anyways, the point is if we're looking at

165
00:12:58,580 --> 00:13:04,340
something like a list, a list is used when you care about a ordered collection of elements.

166
00:13:04,340 --> 00:13:08,700
So if the order and the frequency of elements that you have is important, then you use a

167
00:13:08,700 --> 00:13:12,060
list. There's not really another way to get around that. If you want to store something

168
00:13:12,060 --> 00:13:17,140
ordered and you care about the frequency, you use a list. Moving on, we have a set. Now

169
00:13:17,140 --> 00:13:22,020
a set is used when you do not care about the frequency or the order of elements. You only

170
00:13:22,020 --> 00:13:26,100
care about the presence of elements. So you care if something is in the set or if it's

171
00:13:26,120 --> 00:13:31,100
not in the set. Now these two structures have drastically different time complexities in

172
00:13:31,100 --> 00:13:35,580
a list. If I wanted to determine if something's inside of it, that's what's known as a big

173
00:13:35,580 --> 00:13:40,260
O of end time operation. And that essentially means that I have to look through at most

174
00:13:40,260 --> 00:13:44,660
every element in the list. And there could be millions of elements to determine if something

175
00:13:44,660 --> 00:13:50,380
is there. Whereas with a set, it's actually pretty much an instant or constant time operation

176
00:13:50,380 --> 00:13:54,140
for me to determine if an element is in there. So if there's 10 million elements or a hundred

177
00:13:54,180 --> 00:13:58,380
elements, it's going to take relatively the same amount of time for me to determine if

178
00:13:58,380 --> 00:14:02,300
an element's in the set. So it's very fast for doing lookups, right? And then you have

179
00:14:02,300 --> 00:14:07,500
a dictionary. This is kind of a hybrid. What this allows you to do is store key value pairs.

180
00:14:07,500 --> 00:14:13,020
But similarly to a set, this allows you to have constant time lookup and access to an

181
00:14:13,020 --> 00:14:17,660
element so I can access an element at a key pretty much instantly. And I can check if

182
00:14:17,660 --> 00:14:21,460
an element is in the dictionary. Those are the three different data structures. And you

183
00:14:21,460 --> 00:14:25,420
want to use them appropriately because of what I'm about to show you. So I have a list

184
00:14:25,420 --> 00:14:29,540
here, for example, and I'll get to these in one second, by the way. And with this list,

185
00:14:29,540 --> 00:14:33,420
I can perform all kinds of operations on it. Some are going to be much more efficient than

186
00:14:33,420 --> 00:14:39,700
others though. For example, if I want to remove the very last element, I can do pop and that

187
00:14:39,700 --> 00:14:43,980
just removes last element. And this is a constant time operation happens very quickly. Time

188
00:14:43,980 --> 00:14:48,380
doesn't change depending on the size of the list. However, if I want to remove the first

189
00:14:48,380 --> 00:14:53,420
element, this is a big O of end time operation. And this could take a very long amount of

190
00:14:53,420 --> 00:14:58,500
time depending on how long the list is. So in this situation, if you know, you need to

191
00:14:58,500 --> 00:15:02,500
have an order collection of elements and you want to be say popping something from the

192
00:15:02,500 --> 00:15:06,820
middle of the list or the beginning of the list or something along those lines, you should

193
00:15:06,820 --> 00:15:11,420
use one of the two data structures I have up here. And sorry, that's from collections.

194
00:15:11,420 --> 00:15:15,420
So Python has a built in module. It's called collections. And inside of it, it has something

195
00:15:15,460 --> 00:15:19,980
called a deck and a queue. I believe it also has a heap. It has a ton of other data structures

196
00:15:19,980 --> 00:15:25,860
that you can use. Now a deck or a DQ, however you say this is a double ended queue and a

197
00:15:25,860 --> 00:15:31,460
queue is essentially a first in first out data structure. It acts kind of like a queue

198
00:15:31,460 --> 00:15:35,020
that you'd have when you're on the phone, like waiting on hold or something like that.

199
00:15:35,020 --> 00:15:38,580
But a double ended queue, essentially all you need to know about the double ended queue

200
00:15:38,580 --> 00:15:42,500
is it allows you to remove something from the beginning and the end of it in constant

201
00:15:42,500 --> 00:15:46,300
time. So if you know, you want to pop something from say the beginning of a list instead of

202
00:15:46,300 --> 00:15:50,860
using a list, just use a queue. It has very similar properties to the list, but it allows

203
00:15:50,860 --> 00:15:55,700
you to actually remove elements from the front and from the back of it in constant

204
00:15:55,700 --> 00:15:59,180
time. I'm not going to do a whole tutorial on these. I actually think I have some on

205
00:15:59,180 --> 00:16:03,660
my channel way, way back. Just wanted to mention though, that there is these built in data

206
00:16:03,660 --> 00:16:07,700
structures. They are much more efficient for specific operations. And just be careful

207
00:16:07,700 --> 00:16:11,700
which one you're using based on what it is that you actually want to do. So moving on

208
00:16:11,740 --> 00:16:17,420
here to my final mistake, and this one is using the global keyword and global variables.

209
00:16:17,420 --> 00:16:20,900
Now, if you watch this channel, you should be familiar with why you should not do that.

210
00:16:20,900 --> 00:16:24,860
I have an entire video that I posted talking about why not to do this, but I will quickly

211
00:16:24,860 --> 00:16:29,620
summarize it here. So this program, very simple. I have a global variable called global var.

212
00:16:29,620 --> 00:16:34,540
I have two functions bar and foo. In the first function, I say global global var. That means

213
00:16:34,540 --> 00:16:39,700
that I am going to access or whenever I access this name, I'm going to treat it as the global

214
00:16:39,700 --> 00:16:43,540
variable. So when I print global var, I'm going to print this. When I say global var

215
00:16:43,540 --> 00:16:47,540
is equal to X. I'm going to print this. In fact, let me just say print. And let's go

216
00:16:47,540 --> 00:16:52,300
with global var down here. And who's the other point? That's what's happened. Then I have

217
00:16:52,300 --> 00:16:56,900
foo and inside of here, I print global var. I define global var equal to X. And then I

218
00:16:56,900 --> 00:17:00,500
print global var. Now, first of all, just say guess what you think the output of this program

219
00:17:00,500 --> 00:17:04,220
is going to be. Pause the video if you need to. I'm about to run the code. And then I'll

220
00:17:04,220 --> 00:17:08,220
talk about kind of the weird stuff that we're getting. So when I run this, you see that we

221
00:17:08,220 --> 00:17:14,060
get 10, 20, and then we get an exception. Now, let's talk about this. So what's happening

222
00:17:14,060 --> 00:17:19,780
is I'm calling bar. The bar function actually executes fine. And what it does is it prints

223
00:17:19,780 --> 00:17:25,260
out 10 and 20. So I'm printing the value of the global variable. I'm then changing global

224
00:17:25,260 --> 00:17:30,660
var to be equal to X, which I pass in here as 20. And then I'm printing it again. And

225
00:17:30,660 --> 00:17:34,260
of course I'm getting 20 because I've changed this in the global scope. However, when I

226
00:17:34,260 --> 00:17:40,220
then go and call foo, what happens here is I get this exception. It says unbounded local

227
00:17:40,220 --> 00:17:45,900
error, uh, our local variable global var reference before assignment. Now that is on this line

228
00:17:45,900 --> 00:17:51,340
right here. So line, uh, 10. And the reason I'm getting this is because I have actually

229
00:17:51,340 --> 00:17:57,580
defined a local variable, global var, uh, inside of this function. And it's kind of

230
00:17:57,580 --> 00:18:02,820
weird how Python does this, but essentially, since this is defined down here, when I try

231
00:18:02,860 --> 00:18:08,420
to print global var, even though I have a global variable with that name, it's not going

232
00:18:08,420 --> 00:18:11,700
to reference that it's going to reference the one in the local scope. And since it's

233
00:18:11,700 --> 00:18:16,740
not yet defined, I get an exception. I know kind of weird. One of the reasons, again,

234
00:18:16,740 --> 00:18:22,060
you don't really want to be using global variables is because if you try to write a local version

235
00:18:22,060 --> 00:18:25,900
of that inside of the function, you're going to get these weird errors when you try to

236
00:18:25,900 --> 00:18:31,860
access that value above in the function. Now, if I were to do this, this would work fine.

237
00:18:31,900 --> 00:18:37,260
I wouldn't get any issues with that. However, again, since I'm doing this before I am defining

238
00:18:37,260 --> 00:18:41,580
this variable, I get that error. So hopefully it makes a bit of sense as to why that is

239
00:18:41,580 --> 00:18:46,580
occurring again. Really, it's because I have a local version of my global variable. Whenever

240
00:18:46,580 --> 00:18:50,500
I have that in a function, that's what I'm going to be accessing when I use that name.

241
00:18:50,500 --> 00:18:54,340
So when I try to access it here, it's not yet defined. Well, that causes an exception.

242
00:18:54,340 --> 00:18:58,180
Anyways, that was my final mistake for you guys. I wanted to keep this video nice and

243
00:18:58,180 --> 00:19:02,300
short and just quickly give you a few things to help you improve your Python coding. If

244
00:19:02,300 --> 00:19:05,780
you enjoyed, make sure you leave a like, subscribe to the channel, and I hope to see you in

245
00:19:05,780 --> 00:19:07,500
another YouTube video.

