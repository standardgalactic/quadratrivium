start	end	text
0	13080	If you're watching this video and you write code in Python, then chances are you're familiar
13080	17000	with what a unique language it is, and you utilize some of the awesome features that
17000	21920	Python provides. Now, this is great and Python is an awesome language, but because it is
21920	26280	pretty unique and it's not like a lot of the traditional programming languages, there's
26280	31080	a lot of ways that you can make mistakes in Python without really realizing it. Python
31080	35640	is, as I said, a unique and kind of quirky language. It allows you to do a ton of stuff
35640	40840	and it's very flexible, but with that flexibility, it allows you to make a bunch of mistakes
40840	45440	that are really hard to catch if you haven't watched a video like this. So with that said,
45440	48520	let's get into this video and I'm going to walk you through some mistakes that you're
48520	53400	probably making in Python and that you can easily fix by going through these tips. So
53400	56440	the first mistake that I'm sure many of you are making is that you haven't checked out
56440	60840	my programming course yet called programming expert. I'll leave it in the description.
60840	64680	This is a unique course that teaches Python, specifically some more advanced features of
64680	69440	Python. And we recently added go to it as a second language. So don't make that mistake.
69440	73240	Check that out from the link in the description. But in all seriousness here, the first mistake
73240	77640	that you're probably making is something called name shadowing. Now name shadowing occurs
77640	82680	when you name your variable parameter function, really anything you're defining a name for
82680	87840	a built in function, some built in name or something in the current scope that's already
87840	92640	defined. So for example, here, if we have this function called get database record,
92640	97420	we have a parameter here called ID. Now this is a shadowed name. And the reason this is
97420	102520	shadowed is because you're naming this a built in function. So in Python, we actually have
102520	106920	a built in function here called ID. Many people don't know about this function. And
106920	111560	so they'll do something like this, where they write a function and then they name this parameter.
111560	115800	They give a parameter name of ID. Now you'll notice here, when I write ID, I'm getting
115800	120760	the syntax highlighting as if it was a function, because that's what Python knows to do. But
120760	124840	this is not going to be treated as a function. It's going to be treated as the parameter.
124840	128120	So that is the intended behavior when we're looking at a function like this, but it can
128120	132240	be really confusing if you're familiar with the built in functions. And you have kind
132240	137280	of a long function or a long class or something like that when you're reading shadowed names.
137280	140900	So really you want to avoid name shadowing as much as you can. And one of the only ways
140920	145260	to do that in Python, it's just to ensure that you're not naming your parameters, functions,
145260	150540	et cetera, a built in name. So something like ID, maybe something like max, that's a really
150540	155140	common one, something like min, you want to avoid those names because again, they're built
155140	159840	in functions. And if you do name something that in the current scope, so in this function,
159840	165020	you can no longer use this as the function. So if I try to do something like ID here,
165020	169820	let's just call this function. So get database record. Let's pass in one. Notice it says
169860	174980	the int object is not callable because I've overridden the ID function by shadowing its
174980	179740	name. Now this can occur when you have nested functions as well in all, and in all kinds
179740	183660	of other scenarios. Another really common thing here is when you shadow a name from
183660	189900	the global scope. So for example, if I make my parameter here named database, or I accept
189900	195700	maybe like ID and database like that. Again, if you have a longer function, it can be confusing
195700	199740	when I'm reading this code. If I'm referring to the database parameter, if I spelt that
199780	204580	correctly, or the database variable in the global scope. So obviously this isn't always
204580	208780	avoidable. The main thing here is just don't name your parameters or variables a built
208780	214020	in name like max min ID, not only because it's confusing, but because you also now
214020	218900	make it so you can no longer use those functions inside of wherever you've given that name.
218900	224340	So another mistake that you are likely unintentionally making in Python is using a mutable object
224340	228940	as the default value for an optional parameter. Now, I know that's a mouthful, but if you
228980	233380	look here at this function, it's called mutable parameter. And we have an optional parameter.
233380	237700	We know it's optional because we have it assigned to a default value. If you don't pass it against
237700	242980	the default value and the default value is a mutable object, which is a list. Now, let
242980	247500	me show you why this is bad by running the code. So when I run the code, we actually
247500	251340	get an unexpected output. If you're from another programming language where we get
251340	255860	one, two, one, two, one, two, and then one, two, one, two, one, two. Now, the reason this
255900	260620	occurs is because this is mutable. That means we can actually mutate it. We can change it
260620	265500	in place. So when I do something like LST dot append one and LST dot append two, I'm
265500	271300	actually mutating this list right here, which is the same list that's going to be the default
271300	276740	value for the next call to this function. So you can see on every consecutive call, we're
276740	282140	actually adding elements to this same list. This list does not get recreated every single
282140	287420	time the function is called. It gets created one time when we define the function. That's
287420	291300	the way that the, uh, the default value works here. So if you want to avoid this and you
291300	297180	do want to actually have a, uh, mutable value or a mutable object as your default parameter,
297180	301820	you should do something like this instead and then manually check inside of the function.
301820	308340	If this is not, so I'm going to say if LST is none, then I will say LST is equal to
308460	312780	and make that a list. So now if I run this notice, we don't get that error anymore because
312780	319020	I'm recreating a new list object, every function call as opposed to using the same one that's
319020	323620	only created one time when my, uh, program is actually kind of initialized and the function
323620	327380	is read by the interpreter. Hopefully that makes a bit of sense. Try not to make this
327380	331660	issue or try not to make this mistake. This also happens if you use dictionaries, if you
331660	336700	set in any other mutable object. So the next mistake I have here is a more general one.
336740	341660	This could apply to any programming language, and this is modifying an iterable object while
341660	345380	you're iterating through it. So in this case, I have something that's iterable, which is
345380	349500	a list just means I can loop through it, right? Using a for loop in this case, and I have
349500	353460	for I comma value in enumerate list. So it's going to give me the value as well as the
353460	358660	index of each element. And I'm saying if the index is divisible by two, then I'm going
358660	363420	to pop this index from my list. Now, if you're looking at this here, uh, and you just kind
363420	368140	of take all the indices and apply this to it. We should be popping one. We should be
368140	372900	popping three because that's index two. We should be popping five. That's index four,
372900	377780	popping seven, and then popping nine. However, when I run this, notice that I get kind of
377780	383500	a weird result. I get two, three, five, six, eight, nine kind of strange why I'm getting
383500	388700	that. But the reason is because I'm modifying this iterable object while I'm looping through
388700	393420	it. So if I have a look here and I print out I value, and actually let's not print
393420	398020	out value. Let's print out I and LST. And let's have a look at it at every iteration.
398020	403380	We see I zero and then one, two, three, four, five all the way up until six. And what happens
403380	407820	is we don't actually end up iterating through every unique element in the list because we're
407820	412420	popping it as we go. And the enumerate function works a little bit differently than the range
412420	417940	function in Python. And to show you this, uh, let's do another example. So let's change
417980	422980	this now to say for I, and this is going to be in range. And then this will be the
422980	427420	length of LST. So you would imagine we just get the exact same result here. But when I
427420	432500	run this, notice now we get pop index out of range. Well, the issue here is that we're
432500	437740	reducing the length of the list while we're iterating through it. And the range function
437740	442740	has kind of a constant range that we're going to be iterating through. So as soon as I define
442740	446540	that I'm going to iterate through the range of zero to nine, that doesn't change the whole
446620	450300	time I'm going through this for loop. So even if I modify the length of the list, this
450300	454820	hasn't changed because I've put a constant value here. Whereas when we have the enumerate,
454820	458580	this will actually change based on the length of the list. And again, that's why you get
458580	462660	that weird result. So that's what I wanted to share with you. Don't do this. It cause
462660	467100	a lot of headaches. Only do this. If you really understand what you're doing. And if you want
467100	471780	to make a modification to a list while you're iterating through it, usually what I like
471780	476180	to do is store the modifications I want to make somewhere else, iterate through the list
476220	481180	entirely one time and then run a for loop and just make those specific iterations that
481180	485580	I want to. Hopefully that makes a bit of sense, but that is mistake number three. So the
485580	489820	next mistake I have to share with you is one that is super tricky to figure out if you've
489820	494860	never seen this before. And this is called name clashing. Now this happens when you
494860	500140	name your Python file, which we're going to refer to as a module here, the name of a built
500140	504780	in module in Python or a third party module that you've installed using something like
504860	509900	PIP. So looking at this example here, I have a little script where I import Pi game. Pi
509900	514620	game is a third party Python module. I installed this on my system and this lets me build 2D
514620	518900	games. You guys have probably seen this on my channel before. Anyways, I have Pi game.
518900	522940	Now when I run this, I get an error and it says this is most likely due to a circular
522940	527820	import, but this is only happening in this file. If I throw this in another file, this
527820	531980	code will work completely fine. So what's going on here? Well, the issue is I've named
532020	536980	my Python module Pi game. So I've named it the thing that I'm trying to import. So what
536980	541180	happens is when I try to import Pi game, I'm trying to import the module that I'm currently
541180	545660	working in myself. And then I get this error and it's saying it doesn't have the attribute.
545660	548420	So to show you how you would fix this, you would rename the file. So let's call this
548420	553620	Pi game one now. And when I run this code, notice we no longer get that error and actually
553620	557300	pops up a little Pi game screen. Obviously it goes away because I haven't coded anything
557300	562460	else out. So be careful about that. Do not name your Python modules, your Python files,
562460	567620	a built in module or a module that you're going to be importing or using in your program.
567620	572620	So moving on, the next mistake I have for you is using a naked accept. Now here I have
572620	578700	a try accept block and this exception or this accept block is going to accept any exception.
578700	582300	So if anything happens in here, that's an error that crashes the program, we're going
582300	587220	to go in here and print. I crashed. Now that's great. It's useful that we have this feature.
587220	592740	The issue is this accepts anything, which means I don't know why I crashed when I'm
592740	597660	reading this code and I see this message being printed out. Now this is really bad practice
597660	601980	because it makes it really hard to debug your code. Uh, and you just really shouldn't do
601980	606780	this. You should handle each individual exception as opposed to just any general exception,
606780	610940	uh, kind of for obvious reasons. But in this case, I have two things inside of here that
610940	615020	could fail, right? This could fail, trying to open a file in read mode, because if the
615020	619260	file doesn't exist, we'll get an exception and then dividing one by zero. Well, zero
619260	623100	division, that's an error, no matter what. So two things that could fail. And when I
623100	627780	run the code here, all I get is I crashed. So I don't know if it was because I was unable
627780	632300	to open the file or because I divided by zero. And now if I delete the file that currently
632300	636860	exists, so Tim dot TXT, I have that there and I run this again, I get, I crashed. So
636860	641460	of course the solution here is to accept a specific exception and multiple of them if
641460	645060	you want to. So you kind of just need to know what the names of these are. You can look
645060	649740	them up. You also can just crash your program and see what the exception is. But for now,
649740	653740	let's accept the zero division error. So the zero division error is simply called zero
653740	659420	division error. You shall also get some syntax highlighting for it. And now I can say I tried
659420	666140	to divide by zero dot, dot, dot. Okay. Uh, now let's just comment this line out. Let's
666140	670620	run this and then we get, I tried to divide by zero. If I uncomment that and make my
670620	677140	new file. So let's save this as Tim dot TXT. You guys put tests inside of there, save
677140	682020	and run. Uh, notice that I get, I tried to divide by zero, uh, because I'm accepting
682020	686860	the zero division error. This obviously did not have an exception. All right. Now though,
686860	691860	if we want to handle both of these exceptions, we can write multiple except blocks. So I
691860	697340	can do accept and then I can accept. I think this is the file not found error and I can
697340	705220	print out. I could not find the file dot dot dot. So now if I delete the file again,
705220	709820	let's delete that. Let's run this. Then I get, I could not find the file. One last thing
709820	715300	I will throw in here before I leave. Uh, you also can have as E or as something. Now when
715300	719660	I do that, it will actually give me access to the error in the scope. So I can do something
719660	724020	like print E. Let's just comment this out now. And then you can actually view what the
724020	728780	exception string message is. So keep that in mind. That sometimes can be useful, but
728780	732900	please, when you're writing your except blocks, except a specific exception, it will help
732900	739380	you later on. So moving on to my next mistake. And this one is using the wrong data structure.
739380	742700	Now this is common and you could do this in any programming language, but this is very
742700	746820	important in Python because there's a lot of operations that you can perform on a data
746820	751460	structure that are very inefficient and that if you were to use a different data structure,
751460	755620	you'd have a much more efficient algorithm. And if you're unfamiliar with time complexity,
755620	759700	don't worry. That's kind of what I'm referring to here. Really, what we're talking about
759700	764540	is how fast can you perform an operation and which data structure or built in type is going
764540	769540	to be the best for what it is that you're doing. So in Python, we have really three core data
769540	773420	structures you should understand. And that's going to be a list set in dictionary. We have
773420	778580	string as well, but I won't put that in here. Anyways, the point is if we're looking at
778580	784340	something like a list, a list is used when you care about a ordered collection of elements.
784340	788700	So if the order and the frequency of elements that you have is important, then you use a
788700	792060	list. There's not really another way to get around that. If you want to store something
792060	797140	ordered and you care about the frequency, you use a list. Moving on, we have a set. Now
797140	802020	a set is used when you do not care about the frequency or the order of elements. You only
802020	806100	care about the presence of elements. So you care if something is in the set or if it's
806120	811100	not in the set. Now these two structures have drastically different time complexities in
811100	815580	a list. If I wanted to determine if something's inside of it, that's what's known as a big
815580	820260	O of end time operation. And that essentially means that I have to look through at most
820260	824660	every element in the list. And there could be millions of elements to determine if something
824660	830380	is there. Whereas with a set, it's actually pretty much an instant or constant time operation
830380	834140	for me to determine if an element is in there. So if there's 10 million elements or a hundred
834180	838380	elements, it's going to take relatively the same amount of time for me to determine if
838380	842300	an element's in the set. So it's very fast for doing lookups, right? And then you have
842300	847500	a dictionary. This is kind of a hybrid. What this allows you to do is store key value pairs.
847500	853020	But similarly to a set, this allows you to have constant time lookup and access to an
853020	857660	element so I can access an element at a key pretty much instantly. And I can check if
857660	861460	an element is in the dictionary. Those are the three different data structures. And you
861460	865420	want to use them appropriately because of what I'm about to show you. So I have a list
865420	869540	here, for example, and I'll get to these in one second, by the way. And with this list,
869540	873420	I can perform all kinds of operations on it. Some are going to be much more efficient than
873420	879700	others though. For example, if I want to remove the very last element, I can do pop and that
879700	883980	just removes last element. And this is a constant time operation happens very quickly. Time
883980	888380	doesn't change depending on the size of the list. However, if I want to remove the first
888380	893420	element, this is a big O of end time operation. And this could take a very long amount of
893420	898500	time depending on how long the list is. So in this situation, if you know, you need to
898500	902500	have an order collection of elements and you want to be say popping something from the
902500	906820	middle of the list or the beginning of the list or something along those lines, you should
906820	911420	use one of the two data structures I have up here. And sorry, that's from collections.
911420	915420	So Python has a built in module. It's called collections. And inside of it, it has something
915460	919980	called a deck and a queue. I believe it also has a heap. It has a ton of other data structures
919980	925860	that you can use. Now a deck or a DQ, however you say this is a double ended queue and a
925860	931460	queue is essentially a first in first out data structure. It acts kind of like a queue
931460	935020	that you'd have when you're on the phone, like waiting on hold or something like that.
935020	938580	But a double ended queue, essentially all you need to know about the double ended queue
938580	942500	is it allows you to remove something from the beginning and the end of it in constant
942500	946300	time. So if you know, you want to pop something from say the beginning of a list instead of
946300	950860	using a list, just use a queue. It has very similar properties to the list, but it allows
950860	955700	you to actually remove elements from the front and from the back of it in constant
955700	959180	time. I'm not going to do a whole tutorial on these. I actually think I have some on
959180	963660	my channel way, way back. Just wanted to mention though, that there is these built in data
963660	967700	structures. They are much more efficient for specific operations. And just be careful
967700	971700	which one you're using based on what it is that you actually want to do. So moving on
971740	977420	here to my final mistake, and this one is using the global keyword and global variables.
977420	980900	Now, if you watch this channel, you should be familiar with why you should not do that.
980900	984860	I have an entire video that I posted talking about why not to do this, but I will quickly
984860	989620	summarize it here. So this program, very simple. I have a global variable called global var.
989620	994540	I have two functions bar and foo. In the first function, I say global global var. That means
994540	999700	that I am going to access or whenever I access this name, I'm going to treat it as the global
999700	1003540	variable. So when I print global var, I'm going to print this. When I say global var
1003540	1007540	is equal to X. I'm going to print this. In fact, let me just say print. And let's go
1007540	1012300	with global var down here. And who's the other point? That's what's happened. Then I have
1012300	1016900	foo and inside of here, I print global var. I define global var equal to X. And then I
1016900	1020500	print global var. Now, first of all, just say guess what you think the output of this program
1020500	1024220	is going to be. Pause the video if you need to. I'm about to run the code. And then I'll
1024220	1028220	talk about kind of the weird stuff that we're getting. So when I run this, you see that we
1028220	1034060	get 10, 20, and then we get an exception. Now, let's talk about this. So what's happening
1034060	1039780	is I'm calling bar. The bar function actually executes fine. And what it does is it prints
1039780	1045260	out 10 and 20. So I'm printing the value of the global variable. I'm then changing global
1045260	1050660	var to be equal to X, which I pass in here as 20. And then I'm printing it again. And
1050660	1054260	of course I'm getting 20 because I've changed this in the global scope. However, when I
1054260	1060220	then go and call foo, what happens here is I get this exception. It says unbounded local
1060220	1065900	error, uh, our local variable global var reference before assignment. Now that is on this line
1065900	1071340	right here. So line, uh, 10. And the reason I'm getting this is because I have actually
1071340	1077580	defined a local variable, global var, uh, inside of this function. And it's kind of
1077580	1082820	weird how Python does this, but essentially, since this is defined down here, when I try
1082860	1088420	to print global var, even though I have a global variable with that name, it's not going
1088420	1091700	to reference that it's going to reference the one in the local scope. And since it's
1091700	1096740	not yet defined, I get an exception. I know kind of weird. One of the reasons, again,
1096740	1102060	you don't really want to be using global variables is because if you try to write a local version
1102060	1105900	of that inside of the function, you're going to get these weird errors when you try to
1105900	1111860	access that value above in the function. Now, if I were to do this, this would work fine.
1111900	1117260	I wouldn't get any issues with that. However, again, since I'm doing this before I am defining
1117260	1121580	this variable, I get that error. So hopefully it makes a bit of sense as to why that is
1121580	1126580	occurring again. Really, it's because I have a local version of my global variable. Whenever
1126580	1130500	I have that in a function, that's what I'm going to be accessing when I use that name.
1130500	1134340	So when I try to access it here, it's not yet defined. Well, that causes an exception.
1134340	1138180	Anyways, that was my final mistake for you guys. I wanted to keep this video nice and
1138180	1142300	short and just quickly give you a few things to help you improve your Python coding. If
1142300	1145780	you enjoyed, make sure you leave a like, subscribe to the channel, and I hope to see you in
1145780	1147500	another YouTube video.
