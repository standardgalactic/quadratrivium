start	end	text
0	12800	In this video, I'm going to be introducing you to an awesome module in Python called
12800	17800	iter tools. Now this module is indeed magical. And the reason for that is it provides a bunch
17800	23580	of built in functionality, specifically functions for creating iterators for efficient looping.
23580	27560	If I'm just quickly scrolling through here, you can see we have stuff like count, cycle,
27560	33880	repeat, accumulate, chain, chain from iterable, compress, pairwise, star map, product, permutations,
33880	38920	combinations, and a ton of stuff that you've probably done by yourself from scratch, simply
38920	43880	because you did not know the function existed in a built in module called iter tools. So
43880	47120	with that said, let's head over to the code editor and I'll start walking you through
47120	51160	some of the more useful functions from the iter tools module. So the first thing I'm
51160	55200	going to do here is give you a very quick explanation of what an iterator is because
55200	59360	all of the iter tools functions are going to return an iterator object, and we should
59360	63320	probably understand how that works. Now I will mention that if you do have my programming
63320	67560	course, programming expert, then you would already understand iterators, you'd understand
67560	72760	generators, decorators, more advanced programming, object oriented programming and all kinds
72760	77600	of cool features in Python. So if you're interested, check it out from the link in the description,
77600	82360	programming expert.io, you can use discount code Tim. Anyways, what is an iterator?
82360	85840	Well, to demonstrate this to you, let's start by having a look at something known as the
85840	90360	range function. Now we've probably seen this before, but if I do something like R is equal
90360	95840	to range, and then let's go with the range of say one to 10. When I print this out here,
95840	101360	let's have a look and notice I simply get range 110. Now range itself is not an iterator,
101360	107600	but it's known as iterable. Now anything that's iterable simply has an iter method on. So
107600	112360	iter is this function that you can call. And what this does is actually call the corresponding
112360	117560	underscore, underscore, iter, which is on the class that represents this range function.
117560	121280	So I know this is a bit complicated, but on range, there is this underscore underscore
121280	126120	iter function that you can call. When you call that, it returns to you an iterator,
126120	131140	and the iterator is what you iterate over to get all of the values in the range created
131140	136280	by this object. So for example, if I print out the iter of R, you're going to see that
136280	141880	I get a range iterator object. Now this range iterator object is something I can iterate
141880	147040	over. So let's have a look here. Let's just say I is equal to that. And now let's print
147040	151520	out, for example, the list of I when I do this, I get one, two, three, four, five, six,
151520	155400	seven, eight, nine, because this is iterable. So I can use the list function on it. And
155400	160520	it gives me all of the elements in this iterator. However, an iterator is an iterator when
160520	165960	it has an underscore underscore next underscore underscore method. So this method is a special
165960	170720	method that returns to you the next, the value in the iterable sequence. So when I have
170720	175520	a range of one to 10, what I can do is the following. I can print out the next of my
175520	180560	iterator, which is I, and let's print this out a few times. Now, when I do this, notice
180560	185160	I get one, two, and three, right? It's giving me all of the values in my sequence. And then
185160	189440	to go even further, let's have a look at something like this for X in, and then I'm going to
189440	193800	say I, because I can loop through an iterator, right? And I have my iterator I. And when
193800	199640	I start printing X here, let's have a look and notice that I don't get any repeated values.
199640	203520	So I have my one, two, three from all of the next up here. And then when I continue looping
203520	207240	through the iterator, I get four, five, six, seven, eight, nine, because since we've called
207240	212720	the next method manually, we've been moved to the next values in the iterable sequence.
212720	216120	I know this is a little bit confusing if this is the first time that you're seeing it, but
216120	220720	essentially when you have an iterator or something that's iterable, sorry, you can call this
220720	225320	iter function on it. That returns to you an iterator. And then the iterator, you can
225320	230480	call this next function on, and it gives you the next value in the iterator sequence.
230480	234840	You know that you're finished iterating when a specific exception is raised. This exception
234840	240320	is known as stop iteration. And to show you that, let's just print next a bunch of times.
240320	245700	So we only have nine values in our sequence here. So when I print, uh, the next of I more
245700	250400	than nine times, you'll see here that we get a stop iteration exception. Uh, and that tells
250480	255000	us there's no more values in our iterator to be returned. So that was a very high level
255000	259920	overview of iterators and iterable objects. However, you may be interested to know that
259920	264440	when we have a for loop like this, and we're looping through an iterable object, what actually
264440	270400	happens implicitly is you're going to call the iter function or method on this, uh, iterable
270400	275000	object. That's going to return an iterator. And then the for loop is going to continually
275000	280320	call the next method on this iterator until eventually the stop iteration exception
280320	284520	is raised. So once that exception is raised, the for loop knows there's no more objects
284520	288800	to loop through, and it can stop iterating. And the value that you're going to look at
288800	294400	for I here for our iterator variable is going to be equal to whatever that next method returned
294400	298760	at every single step in the iterator. Hopefully that makes a little bit of sense. But again,
298760	303960	we have the next function, we have the iter function, and these are really just mapping
303960	312480	to the dot underscore underscore, uh, next like this and to the dot. And then this is
312480	317720	going to be underscore underscore, iter underscore underscore method. So anything that is iterable
317720	322040	has this iter method and anything that is an iterator has this next method. And when
322040	326560	you use the next function and the iter function, you're just calling these methods on those
326560	331320	objects. All right. Hopefully that is clear. Now let's have a look at the iter tools module.
331320	334800	So the first type of functions I'm going to show you from the iter tools module are
334800	338920	known as infinite iterators. And what that means is that they can return an infinite
338920	343640	sequence and they actually do this by using something known as the generator syntax. I'm
343640	346760	not going to explain what a generator is in this video. Again, you could learn that from
346760	351160	something like programming expert. Uh, but for now, let's have a look at the first function,
351160	355960	which is count. So this is an infinite iterator. And the way this works is you pass a start
355960	361160	and an optional step value. If you don't pass a step, this will by default be one. And this
361200	365560	will do exactly what it says. It will simply count a sequence starting at some value and
365560	369760	going up by the step every single time. So if I start at 10, which is what I'm passing
369760	374480	for the start here, and then I have a step of five, we're going to count up by five until
374480	379160	we decide we no longer want to iterate over this iterator. So if I run the code here,
379160	383120	you can see that we get a sequence where we are starting at 10 going up by five and I've
383120	387560	just made it so we manually stop here at a hundred. If I didn't have this break, then
387640	392520	this would happen infinitely because again, this is an infinite sequence. So that is cool.
392720	397040	That is the count function. Now let's move on to the next one. The next function that
397040	401760	I have for you is also an infinite iterator. And this is known as repeat. Now, this is
401760	405360	pretty straightforward, but this is going to take in a element. This element could be
405360	409320	a list. It could be a string. It can be really anything you want. And then the maximum number
409320	413600	of times you'd like to repeat this, this is optional. If you do not pass this, it will
413640	418600	repeat indefinitely. So for here, if I have repeat, and I'm repeating hello, and I say
418600	423280	a maximum of 10 times, then I can loop through this repeater iterator. That's what's going
423280	428040	to be returned here when you call the repeat function up to 10 times and print out the
428040	433000	value. So if I do this, you'll just see that we get 10 hellos showing up on the screen.
433000	437320	So this is useful if you want to repeat something a certain number of times. So the next function
437320	441280	that I have for you is known as cycle. Now, this is pretty straightforward. This is going
441320	445360	to take in some iterable object. It could be a string, could be a tuple, could be a
445360	449560	list, really, whatever you want. And it's going to allow you to cycle over all of the
449560	454080	elements as many times as you would like. Again, these are infinite iterators. So you
454080	458280	have to decide when you want to stop iterating over them. They will continue to generate
458280	462880	a sequence forever. So let's run the code here and have a look at what this does. Notice
462880	468000	that we just cycle through ABCDEF constantly until I have a manual stop here where we've
468000	472520	done this over 100 times. So what I'm actually doing is manually calling the next method
472520	477520	here on my cycler, which is equal to a cycle iterator. And if we want to just have a quick
477520	482880	look here at what the iterator object actually looks like, we can print out our cycler and
482880	487080	notice here that I get an iter tools dot cycle object, which is an iterator. And we know
487080	491640	it's an iterator because it has this next method, which I can manually call using the
491640	495920	next function. I also could loop over this using a for loop if I wanted to. So I could
495960	501560	just do something like for I in, and then this would be cycler. However, if I did this,
501560	506160	I would need to implement a manual break condition, because again, that would go infinitely unless
506160	510600	I manually broke it at some point. So that is cycle again, takes in some iterable and
510600	514480	allows you to cycle over it as many times as you would like. So the next set of iterators
514480	519000	that I'm going to show you are known as terminating iterators. They're not infinite. They do have
519000	523240	a defined number of elements that they will return to you. So the first iterator to look
523240	527640	at here is known as accumulate. And the best example of this is something like a running
527640	531640	sum. So I can say the running sum is equal to accumulate and then accumulate an iterable
531640	536120	object in this case, a bunch of integers. And what this does is give me the sum of all
536120	541000	of the elements at the current position and prior in the list. So if I print this out
541000	544840	here, you see we get one, three, six, 10, so on and so forth. So the first element is
544840	549480	the sum of just the first element, which is one second is the sum of these two elements.
549480	553720	The third is some of these three elements, so on until you get to the very end. And one
553720	558080	thing to note here about this is that you've probably implemented this behavior by yourself
558080	563080	in Python before. This will be much more memory efficient as well as faster than if you were
563080	567400	just to write this story with your own for loop. And again, the reason for this is it's
567400	572160	going to use the generator syntax. It's actually only going to give you these values when you
572160	577160	request them. It's not going to be storing them in memory and taking up unnecessary space.
577200	580160	One other thing to note here is that whenever you're looking at an iterator, so in this
580160	584360	case, we have accumulate, we can call the list function on it directly, and that will
584360	589040	run the next method on the iterator until there's no more elements left and just collect
589040	592760	all of those values in a list. So rather than manually looping through this, using a for
592760	597240	loop or calling the next method ourselves, we're just using lists now to quickly grab
597240	602040	the results of the iterate. Hopefully that makes sense. That is accumulate. So the next
602040	605800	iterator to show you is known as chain. This is very straightforward. It simply chains
605840	610840	two iterable objects together. If I run this code, you can see that we get ABC and then
610840	615880	D E F where the first iterable was this string and the second iterable was this one. Again,
615880	619760	this is going to be more performance and memory efficient than if you were to try to implement
619760	624280	this behavior on your own and say, can coordinate two lists together. This is not concatenating
624280	629360	to list. It is returning to an iterator that allows you to retrieve one element at a time
629360	633760	and process and use that as you need to. That is the point of the iterators is that you're
633760	638480	not storing everything in memory. You're grabbing one individual element at a time
638480	643560	and using it as you need to be as opposed to storing everything in memory when you only
643560	647000	need the current element in the sequence. Hopefully that makes a bit of sense. Let's
647000	651080	move on to the next example. The next example is very similar to the first one, but this
651080	655520	is chain from iterable. Now, let's just have a look at what this does when we pass in a
655520	660800	nested list. So notice here that I actually get this list. So this is something that you
660840	665680	can do with the chain from iterable, pass in some type of nested structure, and it will
665680	671560	actually flatten that structure for you by chaining all of the elements that are inside
671560	677320	of this iterable object. Next, we'll move on to compress. As I was saying, the next
677320	682160	iterator that we have here is known as compress. Now, what this does is take in some data source
682160	687680	as well as some selectors, and it simply keeps all of the items that are inside of this data.
687680	692520	If the corresponding item in the selector is true. So in this case, I have a nested
692520	698920	structure that has three elements. So this, this, and this, then I pass in an array here,
698920	703280	I guess, sorry, a list that contains Booleans. Now, true indicates that we're going to keep
703280	706920	an element. False means we are not going to keep it. So if I run this, you'll see that
706920	714280	we only keep a BNC because true was here for the first element. Now, if I make this true,
714280	717840	you'll see that now we get the second element as well. And I could alternatively change
717840	722800	these to be anything that returns a truthy value. So I could put, say, zero and one,
722800	727040	and this would work as well. Moving on, we have the pairwise function. This one is cool.
727040	731240	It's simply going to pair all of the adjacent elements in our iterable. So let's run this
731240	736800	and have a look and notice we get one, two, two, three, three, four, so on and so forth.
736800	741360	Moving on, the next set of iterators I'm going to show you are known as combinatoronic iterators.
741360	745400	Now the first one to have a look at here is a product. Now what the product is going
745400	750160	to do is return the Cartesian product of two iterable objects. Now this would be equivalent
750160	754920	to kind of a nested for loop looping through every single possible pair of the items in
754920	759240	iterable one and iterable two. So let's have a look here when I print this out. Notice
759240	765360	I get one A, one B, one C, two A, two B, two C, three A, three B, three C. That is what
765360	770960	the Cartesian product returns. Moving on, we have the permutations iterator or function,
770960	775040	whatever you'd like to refer to it as. And what this does is return all of the permutations
775040	779960	of a particular size of an iterable object. So let's just have a look at what this returns.
779960	785320	We get A, B, A, C, A, D, B, A, B, C, so on and so forth. And notice the order here is
785320	790920	important. So something like a BC and CB are different permutations because the C and the
790920	795000	B are in a different order. That is not the same as what I'm going to show you next, which
795000	800200	is combinations. So as I promised, the next function to look at here is combinations.
800200	805080	This is going to give you all of the combinations of a particular size of an iterable object.
805080	809440	So let's have a look at this and notice these are the combinations. Note there is a lot
809440	814120	less combinations than there is permutations. And the reason for that is that the ordering
814120	820740	of the elements does not matter in a combination. So AC and CA would be the same combination.
820740	825720	Hence why we're getting less pairs here. Now let's have a look at a size of three.
825760	830400	Notice we're going to have four possible combinations here. If we have a look at four, we're only
830400	834760	going to have one combination because there's only one unique combination of A, B, C and
834760	838680	D. So with that said, I will start wrapping up the video here. I will mention that these
838680	843720	can become very powerful when you start combining them together. So combining, say the combinatoronic
843720	848400	iterator is with a terminating iterator, maybe mixing in a map and filter function somewhere
848400	852360	along the line. And there's a bunch of other functions here that I did not show you from
852360	856760	the iterator module. So feel free to have a look at those from the documentation in
856760	860560	the description. Hopefully you guys found some value from this video. If you did make
860560	864080	sure they like subscribe to the channel and I will see you in another one.
