WEBVTT

00:00.000 --> 00:13.080
If you're watching this video and you write code in Python, then chances are you're familiar

00:13.080 --> 00:17.000
with what a unique language it is, and you utilize some of the awesome features that

00:17.000 --> 00:21.920
Python provides. Now, this is great and Python is an awesome language, but because it is

00:21.920 --> 00:26.280
pretty unique and it's not like a lot of the traditional programming languages, there's

00:26.280 --> 00:31.080
a lot of ways that you can make mistakes in Python without really realizing it. Python

00:31.080 --> 00:35.640
is, as I said, a unique and kind of quirky language. It allows you to do a ton of stuff

00:35.640 --> 00:40.840
and it's very flexible, but with that flexibility, it allows you to make a bunch of mistakes

00:40.840 --> 00:45.440
that are really hard to catch if you haven't watched a video like this. So with that said,

00:45.440 --> 00:48.520
let's get into this video and I'm going to walk you through some mistakes that you're

00:48.520 --> 00:53.400
probably making in Python and that you can easily fix by going through these tips. So

00:53.400 --> 00:56.440
the first mistake that I'm sure many of you are making is that you haven't checked out

00:56.440 --> 01:00.840
my programming course yet called programming expert. I'll leave it in the description.

01:00.840 --> 01:04.680
This is a unique course that teaches Python, specifically some more advanced features of

01:04.680 --> 01:09.440
Python. And we recently added go to it as a second language. So don't make that mistake.

01:09.440 --> 01:13.240
Check that out from the link in the description. But in all seriousness here, the first mistake

01:13.240 --> 01:17.640
that you're probably making is something called name shadowing. Now name shadowing occurs

01:17.640 --> 01:22.680
when you name your variable parameter function, really anything you're defining a name for

01:22.680 --> 01:27.840
a built in function, some built in name or something in the current scope that's already

01:27.840 --> 01:32.640
defined. So for example, here, if we have this function called get database record,

01:32.640 --> 01:37.420
we have a parameter here called ID. Now this is a shadowed name. And the reason this is

01:37.420 --> 01:42.520
shadowed is because you're naming this a built in function. So in Python, we actually have

01:42.520 --> 01:46.920
a built in function here called ID. Many people don't know about this function. And

01:46.920 --> 01:51.560
so they'll do something like this, where they write a function and then they name this parameter.

01:51.560 --> 01:55.800
They give a parameter name of ID. Now you'll notice here, when I write ID, I'm getting

01:55.800 --> 02:00.760
the syntax highlighting as if it was a function, because that's what Python knows to do. But

02:00.760 --> 02:04.840
this is not going to be treated as a function. It's going to be treated as the parameter.

02:04.840 --> 02:08.120
So that is the intended behavior when we're looking at a function like this, but it can

02:08.120 --> 02:12.240
be really confusing if you're familiar with the built in functions. And you have kind

02:12.240 --> 02:17.280
of a long function or a long class or something like that when you're reading shadowed names.

02:17.280 --> 02:20.900
So really you want to avoid name shadowing as much as you can. And one of the only ways

02:20.920 --> 02:25.260
to do that in Python, it's just to ensure that you're not naming your parameters, functions,

02:25.260 --> 02:30.540
et cetera, a built in name. So something like ID, maybe something like max, that's a really

02:30.540 --> 02:35.140
common one, something like min, you want to avoid those names because again, they're built

02:35.140 --> 02:39.840
in functions. And if you do name something that in the current scope, so in this function,

02:39.840 --> 02:45.020
you can no longer use this as the function. So if I try to do something like ID here,

02:45.020 --> 02:49.820
let's just call this function. So get database record. Let's pass in one. Notice it says

02:49.860 --> 02:54.980
the int object is not callable because I've overridden the ID function by shadowing its

02:54.980 --> 02:59.740
name. Now this can occur when you have nested functions as well in all, and in all kinds

02:59.740 --> 03:03.660
of other scenarios. Another really common thing here is when you shadow a name from

03:03.660 --> 03:09.900
the global scope. So for example, if I make my parameter here named database, or I accept

03:09.900 --> 03:15.700
maybe like ID and database like that. Again, if you have a longer function, it can be confusing

03:15.700 --> 03:19.740
when I'm reading this code. If I'm referring to the database parameter, if I spelt that

03:19.780 --> 03:24.580
correctly, or the database variable in the global scope. So obviously this isn't always

03:24.580 --> 03:28.780
avoidable. The main thing here is just don't name your parameters or variables a built

03:28.780 --> 03:34.020
in name like max min ID, not only because it's confusing, but because you also now

03:34.020 --> 03:38.900
make it so you can no longer use those functions inside of wherever you've given that name.

03:38.900 --> 03:44.340
So another mistake that you are likely unintentionally making in Python is using a mutable object

03:44.340 --> 03:48.940
as the default value for an optional parameter. Now, I know that's a mouthful, but if you

03:48.980 --> 03:53.380
look here at this function, it's called mutable parameter. And we have an optional parameter.

03:53.380 --> 03:57.700
We know it's optional because we have it assigned to a default value. If you don't pass it against

03:57.700 --> 04:02.980
the default value and the default value is a mutable object, which is a list. Now, let

04:02.980 --> 04:07.500
me show you why this is bad by running the code. So when I run the code, we actually

04:07.500 --> 04:11.340
get an unexpected output. If you're from another programming language where we get

04:11.340 --> 04:15.860
one, two, one, two, one, two, and then one, two, one, two, one, two. Now, the reason this

04:15.900 --> 04:20.620
occurs is because this is mutable. That means we can actually mutate it. We can change it

04:20.620 --> 04:25.500
in place. So when I do something like LST dot append one and LST dot append two, I'm

04:25.500 --> 04:31.300
actually mutating this list right here, which is the same list that's going to be the default

04:31.300 --> 04:36.740
value for the next call to this function. So you can see on every consecutive call, we're

04:36.740 --> 04:42.140
actually adding elements to this same list. This list does not get recreated every single

04:42.140 --> 04:47.420
time the function is called. It gets created one time when we define the function. That's

04:47.420 --> 04:51.300
the way that the, uh, the default value works here. So if you want to avoid this and you

04:51.300 --> 04:57.180
do want to actually have a, uh, mutable value or a mutable object as your default parameter,

04:57.180 --> 05:01.820
you should do something like this instead and then manually check inside of the function.

05:01.820 --> 05:08.340
If this is not, so I'm going to say if LST is none, then I will say LST is equal to

05:08.460 --> 05:12.780
and make that a list. So now if I run this notice, we don't get that error anymore because

05:12.780 --> 05:19.020
I'm recreating a new list object, every function call as opposed to using the same one that's

05:19.020 --> 05:23.620
only created one time when my, uh, program is actually kind of initialized and the function

05:23.620 --> 05:27.380
is read by the interpreter. Hopefully that makes a bit of sense. Try not to make this

05:27.380 --> 05:31.660
issue or try not to make this mistake. This also happens if you use dictionaries, if you

05:31.660 --> 05:36.700
set in any other mutable object. So the next mistake I have here is a more general one.

05:36.740 --> 05:41.660
This could apply to any programming language, and this is modifying an iterable object while

05:41.660 --> 05:45.380
you're iterating through it. So in this case, I have something that's iterable, which is

05:45.380 --> 05:49.500
a list just means I can loop through it, right? Using a for loop in this case, and I have

05:49.500 --> 05:53.460
for I comma value in enumerate list. So it's going to give me the value as well as the

05:53.460 --> 05:58.660
index of each element. And I'm saying if the index is divisible by two, then I'm going

05:58.660 --> 06:03.420
to pop this index from my list. Now, if you're looking at this here, uh, and you just kind

06:03.420 --> 06:08.140
of take all the indices and apply this to it. We should be popping one. We should be

06:08.140 --> 06:12.900
popping three because that's index two. We should be popping five. That's index four,

06:12.900 --> 06:17.780
popping seven, and then popping nine. However, when I run this, notice that I get kind of

06:17.780 --> 06:23.500
a weird result. I get two, three, five, six, eight, nine kind of strange why I'm getting

06:23.500 --> 06:28.700
that. But the reason is because I'm modifying this iterable object while I'm looping through

06:28.700 --> 06:33.420
it. So if I have a look here and I print out I value, and actually let's not print

06:33.420 --> 06:38.020
out value. Let's print out I and LST. And let's have a look at it at every iteration.

06:38.020 --> 06:43.380
We see I zero and then one, two, three, four, five all the way up until six. And what happens

06:43.380 --> 06:47.820
is we don't actually end up iterating through every unique element in the list because we're

06:47.820 --> 06:52.420
popping it as we go. And the enumerate function works a little bit differently than the range

06:52.420 --> 06:57.940
function in Python. And to show you this, uh, let's do another example. So let's change

06:57.980 --> 07:02.980
this now to say for I, and this is going to be in range. And then this will be the

07:02.980 --> 07:07.420
length of LST. So you would imagine we just get the exact same result here. But when I

07:07.420 --> 07:12.500
run this, notice now we get pop index out of range. Well, the issue here is that we're

07:12.500 --> 07:17.740
reducing the length of the list while we're iterating through it. And the range function

07:17.740 --> 07:22.740
has kind of a constant range that we're going to be iterating through. So as soon as I define

07:22.740 --> 07:26.540
that I'm going to iterate through the range of zero to nine, that doesn't change the whole

07:26.620 --> 07:30.300
time I'm going through this for loop. So even if I modify the length of the list, this

07:30.300 --> 07:34.820
hasn't changed because I've put a constant value here. Whereas when we have the enumerate,

07:34.820 --> 07:38.580
this will actually change based on the length of the list. And again, that's why you get

07:38.580 --> 07:42.660
that weird result. So that's what I wanted to share with you. Don't do this. It cause

07:42.660 --> 07:47.100
a lot of headaches. Only do this. If you really understand what you're doing. And if you want

07:47.100 --> 07:51.780
to make a modification to a list while you're iterating through it, usually what I like

07:51.780 --> 07:56.180
to do is store the modifications I want to make somewhere else, iterate through the list

07:56.220 --> 08:01.180
entirely one time and then run a for loop and just make those specific iterations that

08:01.180 --> 08:05.580
I want to. Hopefully that makes a bit of sense, but that is mistake number three. So the

08:05.580 --> 08:09.820
next mistake I have to share with you is one that is super tricky to figure out if you've

08:09.820 --> 08:14.860
never seen this before. And this is called name clashing. Now this happens when you

08:14.860 --> 08:20.140
name your Python file, which we're going to refer to as a module here, the name of a built

08:20.140 --> 08:24.780
in module in Python or a third party module that you've installed using something like

08:24.860 --> 08:29.900
PIP. So looking at this example here, I have a little script where I import Pi game. Pi

08:29.900 --> 08:34.620
game is a third party Python module. I installed this on my system and this lets me build 2D

08:34.620 --> 08:38.900
games. You guys have probably seen this on my channel before. Anyways, I have Pi game.

08:38.900 --> 08:42.940
Now when I run this, I get an error and it says this is most likely due to a circular

08:42.940 --> 08:47.820
import, but this is only happening in this file. If I throw this in another file, this

08:47.820 --> 08:51.980
code will work completely fine. So what's going on here? Well, the issue is I've named

08:52.020 --> 08:56.980
my Python module Pi game. So I've named it the thing that I'm trying to import. So what

08:56.980 --> 09:01.180
happens is when I try to import Pi game, I'm trying to import the module that I'm currently

09:01.180 --> 09:05.660
working in myself. And then I get this error and it's saying it doesn't have the attribute.

09:05.660 --> 09:08.420
So to show you how you would fix this, you would rename the file. So let's call this

09:08.420 --> 09:13.620
Pi game one now. And when I run this code, notice we no longer get that error and actually

09:13.620 --> 09:17.300
pops up a little Pi game screen. Obviously it goes away because I haven't coded anything

09:17.300 --> 09:22.460
else out. So be careful about that. Do not name your Python modules, your Python files,

09:22.460 --> 09:27.620
a built in module or a module that you're going to be importing or using in your program.

09:27.620 --> 09:32.620
So moving on, the next mistake I have for you is using a naked accept. Now here I have

09:32.620 --> 09:38.700
a try accept block and this exception or this accept block is going to accept any exception.

09:38.700 --> 09:42.300
So if anything happens in here, that's an error that crashes the program, we're going

09:42.300 --> 09:47.220
to go in here and print. I crashed. Now that's great. It's useful that we have this feature.

09:47.220 --> 09:52.740
The issue is this accepts anything, which means I don't know why I crashed when I'm

09:52.740 --> 09:57.660
reading this code and I see this message being printed out. Now this is really bad practice

09:57.660 --> 10:01.980
because it makes it really hard to debug your code. Uh, and you just really shouldn't do

10:01.980 --> 10:06.780
this. You should handle each individual exception as opposed to just any general exception,

10:06.780 --> 10:10.940
uh, kind of for obvious reasons. But in this case, I have two things inside of here that

10:10.940 --> 10:15.020
could fail, right? This could fail, trying to open a file in read mode, because if the

10:15.020 --> 10:19.260
file doesn't exist, we'll get an exception and then dividing one by zero. Well, zero

10:19.260 --> 10:23.100
division, that's an error, no matter what. So two things that could fail. And when I

10:23.100 --> 10:27.780
run the code here, all I get is I crashed. So I don't know if it was because I was unable

10:27.780 --> 10:32.300
to open the file or because I divided by zero. And now if I delete the file that currently

10:32.300 --> 10:36.860
exists, so Tim dot TXT, I have that there and I run this again, I get, I crashed. So

10:36.860 --> 10:41.460
of course the solution here is to accept a specific exception and multiple of them if

10:41.460 --> 10:45.060
you want to. So you kind of just need to know what the names of these are. You can look

10:45.060 --> 10:49.740
them up. You also can just crash your program and see what the exception is. But for now,

10:49.740 --> 10:53.740
let's accept the zero division error. So the zero division error is simply called zero

10:53.740 --> 10:59.420
division error. You shall also get some syntax highlighting for it. And now I can say I tried

10:59.420 --> 11:06.140
to divide by zero dot, dot, dot. Okay. Uh, now let's just comment this line out. Let's

11:06.140 --> 11:10.620
run this and then we get, I tried to divide by zero. If I uncomment that and make my

11:10.620 --> 11:17.140
new file. So let's save this as Tim dot TXT. You guys put tests inside of there, save

11:17.140 --> 11:22.020
and run. Uh, notice that I get, I tried to divide by zero, uh, because I'm accepting

11:22.020 --> 11:26.860
the zero division error. This obviously did not have an exception. All right. Now though,

11:26.860 --> 11:31.860
if we want to handle both of these exceptions, we can write multiple except blocks. So I

11:31.860 --> 11:37.340
can do accept and then I can accept. I think this is the file not found error and I can

11:37.340 --> 11:45.220
print out. I could not find the file dot dot dot. So now if I delete the file again,

11:45.220 --> 11:49.820
let's delete that. Let's run this. Then I get, I could not find the file. One last thing

11:49.820 --> 11:55.300
I will throw in here before I leave. Uh, you also can have as E or as something. Now when

11:55.300 --> 11:59.660
I do that, it will actually give me access to the error in the scope. So I can do something

11:59.660 --> 12:04.020
like print E. Let's just comment this out now. And then you can actually view what the

12:04.020 --> 12:08.780
exception string message is. So keep that in mind. That sometimes can be useful, but

12:08.780 --> 12:12.900
please, when you're writing your except blocks, except a specific exception, it will help

12:12.900 --> 12:19.380
you later on. So moving on to my next mistake. And this one is using the wrong data structure.

12:19.380 --> 12:22.700
Now this is common and you could do this in any programming language, but this is very

12:22.700 --> 12:26.820
important in Python because there's a lot of operations that you can perform on a data

12:26.820 --> 12:31.460
structure that are very inefficient and that if you were to use a different data structure,

12:31.460 --> 12:35.620
you'd have a much more efficient algorithm. And if you're unfamiliar with time complexity,

12:35.620 --> 12:39.700
don't worry. That's kind of what I'm referring to here. Really, what we're talking about

12:39.700 --> 12:44.540
is how fast can you perform an operation and which data structure or built in type is going

12:44.540 --> 12:49.540
to be the best for what it is that you're doing. So in Python, we have really three core data

12:49.540 --> 12:53.420
structures you should understand. And that's going to be a list set in dictionary. We have

12:53.420 --> 12:58.580
string as well, but I won't put that in here. Anyways, the point is if we're looking at

12:58.580 --> 13:04.340
something like a list, a list is used when you care about a ordered collection of elements.

13:04.340 --> 13:08.700
So if the order and the frequency of elements that you have is important, then you use a

13:08.700 --> 13:12.060
list. There's not really another way to get around that. If you want to store something

13:12.060 --> 13:17.140
ordered and you care about the frequency, you use a list. Moving on, we have a set. Now

13:17.140 --> 13:22.020
a set is used when you do not care about the frequency or the order of elements. You only

13:22.020 --> 13:26.100
care about the presence of elements. So you care if something is in the set or if it's

13:26.120 --> 13:31.100
not in the set. Now these two structures have drastically different time complexities in

13:31.100 --> 13:35.580
a list. If I wanted to determine if something's inside of it, that's what's known as a big

13:35.580 --> 13:40.260
O of end time operation. And that essentially means that I have to look through at most

13:40.260 --> 13:44.660
every element in the list. And there could be millions of elements to determine if something

13:44.660 --> 13:50.380
is there. Whereas with a set, it's actually pretty much an instant or constant time operation

13:50.380 --> 13:54.140
for me to determine if an element is in there. So if there's 10 million elements or a hundred

13:54.180 --> 13:58.380
elements, it's going to take relatively the same amount of time for me to determine if

13:58.380 --> 14:02.300
an element's in the set. So it's very fast for doing lookups, right? And then you have

14:02.300 --> 14:07.500
a dictionary. This is kind of a hybrid. What this allows you to do is store key value pairs.

14:07.500 --> 14:13.020
But similarly to a set, this allows you to have constant time lookup and access to an

14:13.020 --> 14:17.660
element so I can access an element at a key pretty much instantly. And I can check if

14:17.660 --> 14:21.460
an element is in the dictionary. Those are the three different data structures. And you

14:21.460 --> 14:25.420
want to use them appropriately because of what I'm about to show you. So I have a list

14:25.420 --> 14:29.540
here, for example, and I'll get to these in one second, by the way. And with this list,

14:29.540 --> 14:33.420
I can perform all kinds of operations on it. Some are going to be much more efficient than

14:33.420 --> 14:39.700
others though. For example, if I want to remove the very last element, I can do pop and that

14:39.700 --> 14:43.980
just removes last element. And this is a constant time operation happens very quickly. Time

14:43.980 --> 14:48.380
doesn't change depending on the size of the list. However, if I want to remove the first

14:48.380 --> 14:53.420
element, this is a big O of end time operation. And this could take a very long amount of

14:53.420 --> 14:58.500
time depending on how long the list is. So in this situation, if you know, you need to

14:58.500 --> 15:02.500
have an order collection of elements and you want to be say popping something from the

15:02.500 --> 15:06.820
middle of the list or the beginning of the list or something along those lines, you should

15:06.820 --> 15:11.420
use one of the two data structures I have up here. And sorry, that's from collections.

15:11.420 --> 15:15.420
So Python has a built in module. It's called collections. And inside of it, it has something

15:15.460 --> 15:19.980
called a deck and a queue. I believe it also has a heap. It has a ton of other data structures

15:19.980 --> 15:25.860
that you can use. Now a deck or a DQ, however you say this is a double ended queue and a

15:25.860 --> 15:31.460
queue is essentially a first in first out data structure. It acts kind of like a queue

15:31.460 --> 15:35.020
that you'd have when you're on the phone, like waiting on hold or something like that.

15:35.020 --> 15:38.580
But a double ended queue, essentially all you need to know about the double ended queue

15:38.580 --> 15:42.500
is it allows you to remove something from the beginning and the end of it in constant

15:42.500 --> 15:46.300
time. So if you know, you want to pop something from say the beginning of a list instead of

15:46.300 --> 15:50.860
using a list, just use a queue. It has very similar properties to the list, but it allows

15:50.860 --> 15:55.700
you to actually remove elements from the front and from the back of it in constant

15:55.700 --> 15:59.180
time. I'm not going to do a whole tutorial on these. I actually think I have some on

15:59.180 --> 16:03.660
my channel way, way back. Just wanted to mention though, that there is these built in data

16:03.660 --> 16:07.700
structures. They are much more efficient for specific operations. And just be careful

16:07.700 --> 16:11.700
which one you're using based on what it is that you actually want to do. So moving on

16:11.740 --> 16:17.420
here to my final mistake, and this one is using the global keyword and global variables.

16:17.420 --> 16:20.900
Now, if you watch this channel, you should be familiar with why you should not do that.

16:20.900 --> 16:24.860
I have an entire video that I posted talking about why not to do this, but I will quickly

16:24.860 --> 16:29.620
summarize it here. So this program, very simple. I have a global variable called global var.

16:29.620 --> 16:34.540
I have two functions bar and foo. In the first function, I say global global var. That means

16:34.540 --> 16:39.700
that I am going to access or whenever I access this name, I'm going to treat it as the global

16:39.700 --> 16:43.540
variable. So when I print global var, I'm going to print this. When I say global var

16:43.540 --> 16:47.540
is equal to X. I'm going to print this. In fact, let me just say print. And let's go

16:47.540 --> 16:52.300
with global var down here. And who's the other point? That's what's happened. Then I have

16:52.300 --> 16:56.900
foo and inside of here, I print global var. I define global var equal to X. And then I

16:56.900 --> 17:00.500
print global var. Now, first of all, just say guess what you think the output of this program

17:00.500 --> 17:04.220
is going to be. Pause the video if you need to. I'm about to run the code. And then I'll

17:04.220 --> 17:08.220
talk about kind of the weird stuff that we're getting. So when I run this, you see that we

17:08.220 --> 17:14.060
get 10, 20, and then we get an exception. Now, let's talk about this. So what's happening

17:14.060 --> 17:19.780
is I'm calling bar. The bar function actually executes fine. And what it does is it prints

17:19.780 --> 17:25.260
out 10 and 20. So I'm printing the value of the global variable. I'm then changing global

17:25.260 --> 17:30.660
var to be equal to X, which I pass in here as 20. And then I'm printing it again. And

17:30.660 --> 17:34.260
of course I'm getting 20 because I've changed this in the global scope. However, when I

17:34.260 --> 17:40.220
then go and call foo, what happens here is I get this exception. It says unbounded local

17:40.220 --> 17:45.900
error, uh, our local variable global var reference before assignment. Now that is on this line

17:45.900 --> 17:51.340
right here. So line, uh, 10. And the reason I'm getting this is because I have actually

17:51.340 --> 17:57.580
defined a local variable, global var, uh, inside of this function. And it's kind of

17:57.580 --> 18:02.820
weird how Python does this, but essentially, since this is defined down here, when I try

18:02.860 --> 18:08.420
to print global var, even though I have a global variable with that name, it's not going

18:08.420 --> 18:11.700
to reference that it's going to reference the one in the local scope. And since it's

18:11.700 --> 18:16.740
not yet defined, I get an exception. I know kind of weird. One of the reasons, again,

18:16.740 --> 18:22.060
you don't really want to be using global variables is because if you try to write a local version

18:22.060 --> 18:25.900
of that inside of the function, you're going to get these weird errors when you try to

18:25.900 --> 18:31.860
access that value above in the function. Now, if I were to do this, this would work fine.

18:31.900 --> 18:37.260
I wouldn't get any issues with that. However, again, since I'm doing this before I am defining

18:37.260 --> 18:41.580
this variable, I get that error. So hopefully it makes a bit of sense as to why that is

18:41.580 --> 18:46.580
occurring again. Really, it's because I have a local version of my global variable. Whenever

18:46.580 --> 18:50.500
I have that in a function, that's what I'm going to be accessing when I use that name.

18:50.500 --> 18:54.340
So when I try to access it here, it's not yet defined. Well, that causes an exception.

18:54.340 --> 18:58.180
Anyways, that was my final mistake for you guys. I wanted to keep this video nice and

18:58.180 --> 19:02.300
short and just quickly give you a few things to help you improve your Python coding. If

19:02.300 --> 19:05.780
you enjoyed, make sure you leave a like, subscribe to the channel, and I hope to see you in

19:05.780 --> 19:07.500
another YouTube video.

