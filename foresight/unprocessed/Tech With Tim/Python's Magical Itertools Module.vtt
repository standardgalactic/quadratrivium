WEBVTT

00:00.000 --> 00:12.800
In this video, I'm going to be introducing you to an awesome module in Python called

00:12.800 --> 00:17.800
iter tools. Now this module is indeed magical. And the reason for that is it provides a bunch

00:17.800 --> 00:23.580
of built in functionality, specifically functions for creating iterators for efficient looping.

00:23.580 --> 00:27.560
If I'm just quickly scrolling through here, you can see we have stuff like count, cycle,

00:27.560 --> 00:33.880
repeat, accumulate, chain, chain from iterable, compress, pairwise, star map, product, permutations,

00:33.880 --> 00:38.920
combinations, and a ton of stuff that you've probably done by yourself from scratch, simply

00:38.920 --> 00:43.880
because you did not know the function existed in a built in module called iter tools. So

00:43.880 --> 00:47.120
with that said, let's head over to the code editor and I'll start walking you through

00:47.120 --> 00:51.160
some of the more useful functions from the iter tools module. So the first thing I'm

00:51.160 --> 00:55.200
going to do here is give you a very quick explanation of what an iterator is because

00:55.200 --> 00:59.360
all of the iter tools functions are going to return an iterator object, and we should

00:59.360 --> 01:03.320
probably understand how that works. Now I will mention that if you do have my programming

01:03.320 --> 01:07.560
course, programming expert, then you would already understand iterators, you'd understand

01:07.560 --> 01:12.760
generators, decorators, more advanced programming, object oriented programming and all kinds

01:12.760 --> 01:17.600
of cool features in Python. So if you're interested, check it out from the link in the description,

01:17.600 --> 01:22.360
programming expert.io, you can use discount code Tim. Anyways, what is an iterator?

01:22.360 --> 01:25.840
Well, to demonstrate this to you, let's start by having a look at something known as the

01:25.840 --> 01:30.360
range function. Now we've probably seen this before, but if I do something like R is equal

01:30.360 --> 01:35.840
to range, and then let's go with the range of say one to 10. When I print this out here,

01:35.840 --> 01:41.360
let's have a look and notice I simply get range 110. Now range itself is not an iterator,

01:41.360 --> 01:47.600
but it's known as iterable. Now anything that's iterable simply has an iter method on. So

01:47.600 --> 01:52.360
iter is this function that you can call. And what this does is actually call the corresponding

01:52.360 --> 01:57.560
underscore, underscore, iter, which is on the class that represents this range function.

01:57.560 --> 02:01.280
So I know this is a bit complicated, but on range, there is this underscore underscore

02:01.280 --> 02:06.120
iter function that you can call. When you call that, it returns to you an iterator,

02:06.120 --> 02:11.140
and the iterator is what you iterate over to get all of the values in the range created

02:11.140 --> 02:16.280
by this object. So for example, if I print out the iter of R, you're going to see that

02:16.280 --> 02:21.880
I get a range iterator object. Now this range iterator object is something I can iterate

02:21.880 --> 02:27.040
over. So let's have a look here. Let's just say I is equal to that. And now let's print

02:27.040 --> 02:31.520
out, for example, the list of I when I do this, I get one, two, three, four, five, six,

02:31.520 --> 02:35.400
seven, eight, nine, because this is iterable. So I can use the list function on it. And

02:35.400 --> 02:40.520
it gives me all of the elements in this iterator. However, an iterator is an iterator when

02:40.520 --> 02:45.960
it has an underscore underscore next underscore underscore method. So this method is a special

02:45.960 --> 02:50.720
method that returns to you the next, the value in the iterable sequence. So when I have

02:50.720 --> 02:55.520
a range of one to 10, what I can do is the following. I can print out the next of my

02:55.520 --> 03:00.560
iterator, which is I, and let's print this out a few times. Now, when I do this, notice

03:00.560 --> 03:05.160
I get one, two, and three, right? It's giving me all of the values in my sequence. And then

03:05.160 --> 03:09.440
to go even further, let's have a look at something like this for X in, and then I'm going to

03:09.440 --> 03:13.800
say I, because I can loop through an iterator, right? And I have my iterator I. And when

03:13.800 --> 03:19.640
I start printing X here, let's have a look and notice that I don't get any repeated values.

03:19.640 --> 03:23.520
So I have my one, two, three from all of the next up here. And then when I continue looping

03:23.520 --> 03:27.240
through the iterator, I get four, five, six, seven, eight, nine, because since we've called

03:27.240 --> 03:32.720
the next method manually, we've been moved to the next values in the iterable sequence.

03:32.720 --> 03:36.120
I know this is a little bit confusing if this is the first time that you're seeing it, but

03:36.120 --> 03:40.720
essentially when you have an iterator or something that's iterable, sorry, you can call this

03:40.720 --> 03:45.320
iter function on it. That returns to you an iterator. And then the iterator, you can

03:45.320 --> 03:50.480
call this next function on, and it gives you the next value in the iterator sequence.

03:50.480 --> 03:54.840
You know that you're finished iterating when a specific exception is raised. This exception

03:54.840 --> 04:00.320
is known as stop iteration. And to show you that, let's just print next a bunch of times.

04:00.320 --> 04:05.700
So we only have nine values in our sequence here. So when I print, uh, the next of I more

04:05.700 --> 04:10.400
than nine times, you'll see here that we get a stop iteration exception. Uh, and that tells

04:10.480 --> 04:15.000
us there's no more values in our iterator to be returned. So that was a very high level

04:15.000 --> 04:19.920
overview of iterators and iterable objects. However, you may be interested to know that

04:19.920 --> 04:24.440
when we have a for loop like this, and we're looping through an iterable object, what actually

04:24.440 --> 04:30.400
happens implicitly is you're going to call the iter function or method on this, uh, iterable

04:30.400 --> 04:35.000
object. That's going to return an iterator. And then the for loop is going to continually

04:35.000 --> 04:40.320
call the next method on this iterator until eventually the stop iteration exception

04:40.320 --> 04:44.520
is raised. So once that exception is raised, the for loop knows there's no more objects

04:44.520 --> 04:48.800
to loop through, and it can stop iterating. And the value that you're going to look at

04:48.800 --> 04:54.400
for I here for our iterator variable is going to be equal to whatever that next method returned

04:54.400 --> 04:58.760
at every single step in the iterator. Hopefully that makes a little bit of sense. But again,

04:58.760 --> 05:03.960
we have the next function, we have the iter function, and these are really just mapping

05:03.960 --> 05:12.480
to the dot underscore underscore, uh, next like this and to the dot. And then this is

05:12.480 --> 05:17.720
going to be underscore underscore, iter underscore underscore method. So anything that is iterable

05:17.720 --> 05:22.040
has this iter method and anything that is an iterator has this next method. And when

05:22.040 --> 05:26.560
you use the next function and the iter function, you're just calling these methods on those

05:26.560 --> 05:31.320
objects. All right. Hopefully that is clear. Now let's have a look at the iter tools module.

05:31.320 --> 05:34.800
So the first type of functions I'm going to show you from the iter tools module are

05:34.800 --> 05:38.920
known as infinite iterators. And what that means is that they can return an infinite

05:38.920 --> 05:43.640
sequence and they actually do this by using something known as the generator syntax. I'm

05:43.640 --> 05:46.760
not going to explain what a generator is in this video. Again, you could learn that from

05:46.760 --> 05:51.160
something like programming expert. Uh, but for now, let's have a look at the first function,

05:51.160 --> 05:55.960
which is count. So this is an infinite iterator. And the way this works is you pass a start

05:55.960 --> 06:01.160
and an optional step value. If you don't pass a step, this will by default be one. And this

06:01.200 --> 06:05.560
will do exactly what it says. It will simply count a sequence starting at some value and

06:05.560 --> 06:09.760
going up by the step every single time. So if I start at 10, which is what I'm passing

06:09.760 --> 06:14.480
for the start here, and then I have a step of five, we're going to count up by five until

06:14.480 --> 06:19.160
we decide we no longer want to iterate over this iterator. So if I run the code here,

06:19.160 --> 06:23.120
you can see that we get a sequence where we are starting at 10 going up by five and I've

06:23.120 --> 06:27.560
just made it so we manually stop here at a hundred. If I didn't have this break, then

06:27.640 --> 06:32.520
this would happen infinitely because again, this is an infinite sequence. So that is cool.

06:32.720 --> 06:37.040
That is the count function. Now let's move on to the next one. The next function that

06:37.040 --> 06:41.760
I have for you is also an infinite iterator. And this is known as repeat. Now, this is

06:41.760 --> 06:45.360
pretty straightforward, but this is going to take in a element. This element could be

06:45.360 --> 06:49.320
a list. It could be a string. It can be really anything you want. And then the maximum number

06:49.320 --> 06:53.600
of times you'd like to repeat this, this is optional. If you do not pass this, it will

06:53.640 --> 06:58.600
repeat indefinitely. So for here, if I have repeat, and I'm repeating hello, and I say

06:58.600 --> 07:03.280
a maximum of 10 times, then I can loop through this repeater iterator. That's what's going

07:03.280 --> 07:08.040
to be returned here when you call the repeat function up to 10 times and print out the

07:08.040 --> 07:13.000
value. So if I do this, you'll just see that we get 10 hellos showing up on the screen.

07:13.000 --> 07:17.320
So this is useful if you want to repeat something a certain number of times. So the next function

07:17.320 --> 07:21.280
that I have for you is known as cycle. Now, this is pretty straightforward. This is going

07:21.320 --> 07:25.360
to take in some iterable object. It could be a string, could be a tuple, could be a

07:25.360 --> 07:29.560
list, really, whatever you want. And it's going to allow you to cycle over all of the

07:29.560 --> 07:34.080
elements as many times as you would like. Again, these are infinite iterators. So you

07:34.080 --> 07:38.280
have to decide when you want to stop iterating over them. They will continue to generate

07:38.280 --> 07:42.880
a sequence forever. So let's run the code here and have a look at what this does. Notice

07:42.880 --> 07:48.000
that we just cycle through ABCDEF constantly until I have a manual stop here where we've

07:48.000 --> 07:52.520
done this over 100 times. So what I'm actually doing is manually calling the next method

07:52.520 --> 07:57.520
here on my cycler, which is equal to a cycle iterator. And if we want to just have a quick

07:57.520 --> 08:02.880
look here at what the iterator object actually looks like, we can print out our cycler and

08:02.880 --> 08:07.080
notice here that I get an iter tools dot cycle object, which is an iterator. And we know

08:07.080 --> 08:11.640
it's an iterator because it has this next method, which I can manually call using the

08:11.640 --> 08:15.920
next function. I also could loop over this using a for loop if I wanted to. So I could

08:15.960 --> 08:21.560
just do something like for I in, and then this would be cycler. However, if I did this,

08:21.560 --> 08:26.160
I would need to implement a manual break condition, because again, that would go infinitely unless

08:26.160 --> 08:30.600
I manually broke it at some point. So that is cycle again, takes in some iterable and

08:30.600 --> 08:34.480
allows you to cycle over it as many times as you would like. So the next set of iterators

08:34.480 --> 08:39.000
that I'm going to show you are known as terminating iterators. They're not infinite. They do have

08:39.000 --> 08:43.240
a defined number of elements that they will return to you. So the first iterator to look

08:43.240 --> 08:47.640
at here is known as accumulate. And the best example of this is something like a running

08:47.640 --> 08:51.640
sum. So I can say the running sum is equal to accumulate and then accumulate an iterable

08:51.640 --> 08:56.120
object in this case, a bunch of integers. And what this does is give me the sum of all

08:56.120 --> 09:01.000
of the elements at the current position and prior in the list. So if I print this out

09:01.000 --> 09:04.840
here, you see we get one, three, six, 10, so on and so forth. So the first element is

09:04.840 --> 09:09.480
the sum of just the first element, which is one second is the sum of these two elements.

09:09.480 --> 09:13.720
The third is some of these three elements, so on until you get to the very end. And one

09:13.720 --> 09:18.080
thing to note here about this is that you've probably implemented this behavior by yourself

09:18.080 --> 09:23.080
in Python before. This will be much more memory efficient as well as faster than if you were

09:23.080 --> 09:27.400
just to write this story with your own for loop. And again, the reason for this is it's

09:27.400 --> 09:32.160
going to use the generator syntax. It's actually only going to give you these values when you

09:32.160 --> 09:37.160
request them. It's not going to be storing them in memory and taking up unnecessary space.

09:37.200 --> 09:40.160
One other thing to note here is that whenever you're looking at an iterator, so in this

09:40.160 --> 09:44.360
case, we have accumulate, we can call the list function on it directly, and that will

09:44.360 --> 09:49.040
run the next method on the iterator until there's no more elements left and just collect

09:49.040 --> 09:52.760
all of those values in a list. So rather than manually looping through this, using a for

09:52.760 --> 09:57.240
loop or calling the next method ourselves, we're just using lists now to quickly grab

09:57.240 --> 10:02.040
the results of the iterate. Hopefully that makes sense. That is accumulate. So the next

10:02.040 --> 10:05.800
iterator to show you is known as chain. This is very straightforward. It simply chains

10:05.840 --> 10:10.840
two iterable objects together. If I run this code, you can see that we get ABC and then

10:10.840 --> 10:15.880
D E F where the first iterable was this string and the second iterable was this one. Again,

10:15.880 --> 10:19.760
this is going to be more performance and memory efficient than if you were to try to implement

10:19.760 --> 10:24.280
this behavior on your own and say, can coordinate two lists together. This is not concatenating

10:24.280 --> 10:29.360
to list. It is returning to an iterator that allows you to retrieve one element at a time

10:29.360 --> 10:33.760
and process and use that as you need to. That is the point of the iterators is that you're

10:33.760 --> 10:38.480
not storing everything in memory. You're grabbing one individual element at a time

10:38.480 --> 10:43.560
and using it as you need to be as opposed to storing everything in memory when you only

10:43.560 --> 10:47.000
need the current element in the sequence. Hopefully that makes a bit of sense. Let's

10:47.000 --> 10:51.080
move on to the next example. The next example is very similar to the first one, but this

10:51.080 --> 10:55.520
is chain from iterable. Now, let's just have a look at what this does when we pass in a

10:55.520 --> 11:00.800
nested list. So notice here that I actually get this list. So this is something that you

11:00.840 --> 11:05.680
can do with the chain from iterable, pass in some type of nested structure, and it will

11:05.680 --> 11:11.560
actually flatten that structure for you by chaining all of the elements that are inside

11:11.560 --> 11:17.320
of this iterable object. Next, we'll move on to compress. As I was saying, the next

11:17.320 --> 11:22.160
iterator that we have here is known as compress. Now, what this does is take in some data source

11:22.160 --> 11:27.680
as well as some selectors, and it simply keeps all of the items that are inside of this data.

11:27.680 --> 11:32.520
If the corresponding item in the selector is true. So in this case, I have a nested

11:32.520 --> 11:38.920
structure that has three elements. So this, this, and this, then I pass in an array here,

11:38.920 --> 11:43.280
I guess, sorry, a list that contains Booleans. Now, true indicates that we're going to keep

11:43.280 --> 11:46.920
an element. False means we are not going to keep it. So if I run this, you'll see that

11:46.920 --> 11:54.280
we only keep a BNC because true was here for the first element. Now, if I make this true,

11:54.280 --> 11:57.840
you'll see that now we get the second element as well. And I could alternatively change

11:57.840 --> 12:02.800
these to be anything that returns a truthy value. So I could put, say, zero and one,

12:02.800 --> 12:07.040
and this would work as well. Moving on, we have the pairwise function. This one is cool.

12:07.040 --> 12:11.240
It's simply going to pair all of the adjacent elements in our iterable. So let's run this

12:11.240 --> 12:16.800
and have a look and notice we get one, two, two, three, three, four, so on and so forth.

12:16.800 --> 12:21.360
Moving on, the next set of iterators I'm going to show you are known as combinatoronic iterators.

12:21.360 --> 12:25.400
Now the first one to have a look at here is a product. Now what the product is going

12:25.400 --> 12:30.160
to do is return the Cartesian product of two iterable objects. Now this would be equivalent

12:30.160 --> 12:34.920
to kind of a nested for loop looping through every single possible pair of the items in

12:34.920 --> 12:39.240
iterable one and iterable two. So let's have a look here when I print this out. Notice

12:39.240 --> 12:45.360
I get one A, one B, one C, two A, two B, two C, three A, three B, three C. That is what

12:45.360 --> 12:50.960
the Cartesian product returns. Moving on, we have the permutations iterator or function,

12:50.960 --> 12:55.040
whatever you'd like to refer to it as. And what this does is return all of the permutations

12:55.040 --> 12:59.960
of a particular size of an iterable object. So let's just have a look at what this returns.

12:59.960 --> 13:05.320
We get A, B, A, C, A, D, B, A, B, C, so on and so forth. And notice the order here is

13:05.320 --> 13:10.920
important. So something like a BC and CB are different permutations because the C and the

13:10.920 --> 13:15.000
B are in a different order. That is not the same as what I'm going to show you next, which

13:15.000 --> 13:20.200
is combinations. So as I promised, the next function to look at here is combinations.

13:20.200 --> 13:25.080
This is going to give you all of the combinations of a particular size of an iterable object.

13:25.080 --> 13:29.440
So let's have a look at this and notice these are the combinations. Note there is a lot

13:29.440 --> 13:34.120
less combinations than there is permutations. And the reason for that is that the ordering

13:34.120 --> 13:40.740
of the elements does not matter in a combination. So AC and CA would be the same combination.

13:40.740 --> 13:45.720
Hence why we're getting less pairs here. Now let's have a look at a size of three.

13:45.760 --> 13:50.400
Notice we're going to have four possible combinations here. If we have a look at four, we're only

13:50.400 --> 13:54.760
going to have one combination because there's only one unique combination of A, B, C and

13:54.760 --> 13:58.680
D. So with that said, I will start wrapping up the video here. I will mention that these

13:58.680 --> 14:03.720
can become very powerful when you start combining them together. So combining, say the combinatoronic

14:03.720 --> 14:08.400
iterator is with a terminating iterator, maybe mixing in a map and filter function somewhere

14:08.400 --> 14:12.360
along the line. And there's a bunch of other functions here that I did not show you from

14:12.360 --> 14:16.760
the iterator module. So feel free to have a look at those from the documentation in

14:16.760 --> 14:20.560
the description. Hopefully you guys found some value from this video. If you did make

14:20.560 --> 14:24.080
sure they like subscribe to the channel and I will see you in another one.

