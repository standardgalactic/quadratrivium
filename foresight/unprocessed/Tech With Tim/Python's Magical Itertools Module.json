{"text": " In this video, I'm going to be introducing you to an awesome module in Python called iter tools. Now this module is indeed magical. And the reason for that is it provides a bunch of built in functionality, specifically functions for creating iterators for efficient looping. If I'm just quickly scrolling through here, you can see we have stuff like count, cycle, repeat, accumulate, chain, chain from iterable, compress, pairwise, star map, product, permutations, combinations, and a ton of stuff that you've probably done by yourself from scratch, simply because you did not know the function existed in a built in module called iter tools. So with that said, let's head over to the code editor and I'll start walking you through some of the more useful functions from the iter tools module. So the first thing I'm going to do here is give you a very quick explanation of what an iterator is because all of the iter tools functions are going to return an iterator object, and we should probably understand how that works. Now I will mention that if you do have my programming course, programming expert, then you would already understand iterators, you'd understand generators, decorators, more advanced programming, object oriented programming and all kinds of cool features in Python. So if you're interested, check it out from the link in the description, programming expert.io, you can use discount code Tim. Anyways, what is an iterator? Well, to demonstrate this to you, let's start by having a look at something known as the range function. Now we've probably seen this before, but if I do something like R is equal to range, and then let's go with the range of say one to 10. When I print this out here, let's have a look and notice I simply get range 110. Now range itself is not an iterator, but it's known as iterable. Now anything that's iterable simply has an iter method on. So iter is this function that you can call. And what this does is actually call the corresponding underscore, underscore, iter, which is on the class that represents this range function. So I know this is a bit complicated, but on range, there is this underscore underscore iter function that you can call. When you call that, it returns to you an iterator, and the iterator is what you iterate over to get all of the values in the range created by this object. So for example, if I print out the iter of R, you're going to see that I get a range iterator object. Now this range iterator object is something I can iterate over. So let's have a look here. Let's just say I is equal to that. And now let's print out, for example, the list of I when I do this, I get one, two, three, four, five, six, seven, eight, nine, because this is iterable. So I can use the list function on it. And it gives me all of the elements in this iterator. However, an iterator is an iterator when it has an underscore underscore next underscore underscore method. So this method is a special method that returns to you the next, the value in the iterable sequence. So when I have a range of one to 10, what I can do is the following. I can print out the next of my iterator, which is I, and let's print this out a few times. Now, when I do this, notice I get one, two, and three, right? It's giving me all of the values in my sequence. And then to go even further, let's have a look at something like this for X in, and then I'm going to say I, because I can loop through an iterator, right? And I have my iterator I. And when I start printing X here, let's have a look and notice that I don't get any repeated values. So I have my one, two, three from all of the next up here. And then when I continue looping through the iterator, I get four, five, six, seven, eight, nine, because since we've called the next method manually, we've been moved to the next values in the iterable sequence. I know this is a little bit confusing if this is the first time that you're seeing it, but essentially when you have an iterator or something that's iterable, sorry, you can call this iter function on it. That returns to you an iterator. And then the iterator, you can call this next function on, and it gives you the next value in the iterator sequence. You know that you're finished iterating when a specific exception is raised. This exception is known as stop iteration. And to show you that, let's just print next a bunch of times. So we only have nine values in our sequence here. So when I print, uh, the next of I more than nine times, you'll see here that we get a stop iteration exception. Uh, and that tells us there's no more values in our iterator to be returned. So that was a very high level overview of iterators and iterable objects. However, you may be interested to know that when we have a for loop like this, and we're looping through an iterable object, what actually happens implicitly is you're going to call the iter function or method on this, uh, iterable object. That's going to return an iterator. And then the for loop is going to continually call the next method on this iterator until eventually the stop iteration exception is raised. So once that exception is raised, the for loop knows there's no more objects to loop through, and it can stop iterating. And the value that you're going to look at for I here for our iterator variable is going to be equal to whatever that next method returned at every single step in the iterator. Hopefully that makes a little bit of sense. But again, we have the next function, we have the iter function, and these are really just mapping to the dot underscore underscore, uh, next like this and to the dot. And then this is going to be underscore underscore, iter underscore underscore method. So anything that is iterable has this iter method and anything that is an iterator has this next method. And when you use the next function and the iter function, you're just calling these methods on those objects. All right. Hopefully that is clear. Now let's have a look at the iter tools module. So the first type of functions I'm going to show you from the iter tools module are known as infinite iterators. And what that means is that they can return an infinite sequence and they actually do this by using something known as the generator syntax. I'm not going to explain what a generator is in this video. Again, you could learn that from something like programming expert. Uh, but for now, let's have a look at the first function, which is count. So this is an infinite iterator. And the way this works is you pass a start and an optional step value. If you don't pass a step, this will by default be one. And this will do exactly what it says. It will simply count a sequence starting at some value and going up by the step every single time. So if I start at 10, which is what I'm passing for the start here, and then I have a step of five, we're going to count up by five until we decide we no longer want to iterate over this iterator. So if I run the code here, you can see that we get a sequence where we are starting at 10 going up by five and I've just made it so we manually stop here at a hundred. If I didn't have this break, then this would happen infinitely because again, this is an infinite sequence. So that is cool. That is the count function. Now let's move on to the next one. The next function that I have for you is also an infinite iterator. And this is known as repeat. Now, this is pretty straightforward, but this is going to take in a element. This element could be a list. It could be a string. It can be really anything you want. And then the maximum number of times you'd like to repeat this, this is optional. If you do not pass this, it will repeat indefinitely. So for here, if I have repeat, and I'm repeating hello, and I say a maximum of 10 times, then I can loop through this repeater iterator. That's what's going to be returned here when you call the repeat function up to 10 times and print out the value. So if I do this, you'll just see that we get 10 hellos showing up on the screen. So this is useful if you want to repeat something a certain number of times. So the next function that I have for you is known as cycle. Now, this is pretty straightforward. This is going to take in some iterable object. It could be a string, could be a tuple, could be a list, really, whatever you want. And it's going to allow you to cycle over all of the elements as many times as you would like. Again, these are infinite iterators. So you have to decide when you want to stop iterating over them. They will continue to generate a sequence forever. So let's run the code here and have a look at what this does. Notice that we just cycle through ABCDEF constantly until I have a manual stop here where we've done this over 100 times. So what I'm actually doing is manually calling the next method here on my cycler, which is equal to a cycle iterator. And if we want to just have a quick look here at what the iterator object actually looks like, we can print out our cycler and notice here that I get an iter tools dot cycle object, which is an iterator. And we know it's an iterator because it has this next method, which I can manually call using the next function. I also could loop over this using a for loop if I wanted to. So I could just do something like for I in, and then this would be cycler. However, if I did this, I would need to implement a manual break condition, because again, that would go infinitely unless I manually broke it at some point. So that is cycle again, takes in some iterable and allows you to cycle over it as many times as you would like. So the next set of iterators that I'm going to show you are known as terminating iterators. They're not infinite. They do have a defined number of elements that they will return to you. So the first iterator to look at here is known as accumulate. And the best example of this is something like a running sum. So I can say the running sum is equal to accumulate and then accumulate an iterable object in this case, a bunch of integers. And what this does is give me the sum of all of the elements at the current position and prior in the list. So if I print this out here, you see we get one, three, six, 10, so on and so forth. So the first element is the sum of just the first element, which is one second is the sum of these two elements. The third is some of these three elements, so on until you get to the very end. And one thing to note here about this is that you've probably implemented this behavior by yourself in Python before. This will be much more memory efficient as well as faster than if you were just to write this story with your own for loop. And again, the reason for this is it's going to use the generator syntax. It's actually only going to give you these values when you request them. It's not going to be storing them in memory and taking up unnecessary space. One other thing to note here is that whenever you're looking at an iterator, so in this case, we have accumulate, we can call the list function on it directly, and that will run the next method on the iterator until there's no more elements left and just collect all of those values in a list. So rather than manually looping through this, using a for loop or calling the next method ourselves, we're just using lists now to quickly grab the results of the iterate. Hopefully that makes sense. That is accumulate. So the next iterator to show you is known as chain. This is very straightforward. It simply chains two iterable objects together. If I run this code, you can see that we get ABC and then D E F where the first iterable was this string and the second iterable was this one. Again, this is going to be more performance and memory efficient than if you were to try to implement this behavior on your own and say, can coordinate two lists together. This is not concatenating to list. It is returning to an iterator that allows you to retrieve one element at a time and process and use that as you need to. That is the point of the iterators is that you're not storing everything in memory. You're grabbing one individual element at a time and using it as you need to be as opposed to storing everything in memory when you only need the current element in the sequence. Hopefully that makes a bit of sense. Let's move on to the next example. The next example is very similar to the first one, but this is chain from iterable. Now, let's just have a look at what this does when we pass in a nested list. So notice here that I actually get this list. So this is something that you can do with the chain from iterable, pass in some type of nested structure, and it will actually flatten that structure for you by chaining all of the elements that are inside of this iterable object. Next, we'll move on to compress. As I was saying, the next iterator that we have here is known as compress. Now, what this does is take in some data source as well as some selectors, and it simply keeps all of the items that are inside of this data. If the corresponding item in the selector is true. So in this case, I have a nested structure that has three elements. So this, this, and this, then I pass in an array here, I guess, sorry, a list that contains Booleans. Now, true indicates that we're going to keep an element. False means we are not going to keep it. So if I run this, you'll see that we only keep a BNC because true was here for the first element. Now, if I make this true, you'll see that now we get the second element as well. And I could alternatively change these to be anything that returns a truthy value. So I could put, say, zero and one, and this would work as well. Moving on, we have the pairwise function. This one is cool. It's simply going to pair all of the adjacent elements in our iterable. So let's run this and have a look and notice we get one, two, two, three, three, four, so on and so forth. Moving on, the next set of iterators I'm going to show you are known as combinatoronic iterators. Now the first one to have a look at here is a product. Now what the product is going to do is return the Cartesian product of two iterable objects. Now this would be equivalent to kind of a nested for loop looping through every single possible pair of the items in iterable one and iterable two. So let's have a look here when I print this out. Notice I get one A, one B, one C, two A, two B, two C, three A, three B, three C. That is what the Cartesian product returns. Moving on, we have the permutations iterator or function, whatever you'd like to refer to it as. And what this does is return all of the permutations of a particular size of an iterable object. So let's just have a look at what this returns. We get A, B, A, C, A, D, B, A, B, C, so on and so forth. And notice the order here is important. So something like a BC and CB are different permutations because the C and the B are in a different order. That is not the same as what I'm going to show you next, which is combinations. So as I promised, the next function to look at here is combinations. This is going to give you all of the combinations of a particular size of an iterable object. So let's have a look at this and notice these are the combinations. Note there is a lot less combinations than there is permutations. And the reason for that is that the ordering of the elements does not matter in a combination. So AC and CA would be the same combination. Hence why we're getting less pairs here. Now let's have a look at a size of three. Notice we're going to have four possible combinations here. If we have a look at four, we're only going to have one combination because there's only one unique combination of A, B, C and D. So with that said, I will start wrapping up the video here. I will mention that these can become very powerful when you start combining them together. So combining, say the combinatoronic iterator is with a terminating iterator, maybe mixing in a map and filter function somewhere along the line. And there's a bunch of other functions here that I did not show you from the iterator module. So feel free to have a look at those from the documentation in the description. Hopefully you guys found some value from this video. If you did make sure they like subscribe to the channel and I will see you in another one.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 12.8, "text": " In this video, I'm going to be introducing you to an awesome module in Python called", "tokens": [50364, 682, 341, 960, 11, 286, 478, 516, 281, 312, 15424, 291, 281, 364, 3476, 10088, 294, 15329, 1219, 51004], "temperature": 0.0, "avg_logprob": -0.14876156761532738, "compression_ratio": 1.5646551724137931, "no_speech_prob": 0.22766563296318054}, {"id": 1, "seek": 0, "start": 12.8, "end": 17.8, "text": " iter tools. Now this module is indeed magical. And the reason for that is it provides a bunch", "tokens": [51004, 17138, 3873, 13, 823, 341, 10088, 307, 6451, 12066, 13, 400, 264, 1778, 337, 300, 307, 309, 6417, 257, 3840, 51254], "temperature": 0.0, "avg_logprob": -0.14876156761532738, "compression_ratio": 1.5646551724137931, "no_speech_prob": 0.22766563296318054}, {"id": 2, "seek": 0, "start": 17.8, "end": 23.580000000000002, "text": " of built in functionality, specifically functions for creating iterators for efficient looping.", "tokens": [51254, 295, 3094, 294, 14980, 11, 4682, 6828, 337, 4084, 17138, 3391, 337, 7148, 6367, 278, 13, 51543], "temperature": 0.0, "avg_logprob": -0.14876156761532738, "compression_ratio": 1.5646551724137931, "no_speech_prob": 0.22766563296318054}, {"id": 3, "seek": 0, "start": 23.580000000000002, "end": 27.560000000000002, "text": " If I'm just quickly scrolling through here, you can see we have stuff like count, cycle,", "tokens": [51543, 759, 286, 478, 445, 2661, 29053, 807, 510, 11, 291, 393, 536, 321, 362, 1507, 411, 1207, 11, 6586, 11, 51742], "temperature": 0.0, "avg_logprob": -0.14876156761532738, "compression_ratio": 1.5646551724137931, "no_speech_prob": 0.22766563296318054}, {"id": 4, "seek": 2756, "start": 27.56, "end": 33.879999999999995, "text": " repeat, accumulate, chain, chain from iterable, compress, pairwise, star map, product, permutations,", "tokens": [50364, 7149, 11, 33384, 11, 5021, 11, 5021, 490, 17138, 712, 11, 14778, 11, 6119, 3711, 11, 3543, 4471, 11, 1674, 11, 4784, 325, 763, 11, 50680], "temperature": 0.0, "avg_logprob": -0.1490085455087515, "compression_ratio": 1.732258064516129, "no_speech_prob": 0.08752502501010895}, {"id": 5, "seek": 2756, "start": 33.879999999999995, "end": 38.92, "text": " combinations, and a ton of stuff that you've probably done by yourself from scratch, simply", "tokens": [50680, 21267, 11, 293, 257, 2952, 295, 1507, 300, 291, 600, 1391, 1096, 538, 1803, 490, 8459, 11, 2935, 50932], "temperature": 0.0, "avg_logprob": -0.1490085455087515, "compression_ratio": 1.732258064516129, "no_speech_prob": 0.08752502501010895}, {"id": 6, "seek": 2756, "start": 38.92, "end": 43.879999999999995, "text": " because you did not know the function existed in a built in module called iter tools. So", "tokens": [50932, 570, 291, 630, 406, 458, 264, 2445, 13135, 294, 257, 3094, 294, 10088, 1219, 17138, 3873, 13, 407, 51180], "temperature": 0.0, "avg_logprob": -0.1490085455087515, "compression_ratio": 1.732258064516129, "no_speech_prob": 0.08752502501010895}, {"id": 7, "seek": 2756, "start": 43.879999999999995, "end": 47.12, "text": " with that said, let's head over to the code editor and I'll start walking you through", "tokens": [51180, 365, 300, 848, 11, 718, 311, 1378, 670, 281, 264, 3089, 9839, 293, 286, 603, 722, 4494, 291, 807, 51342], "temperature": 0.0, "avg_logprob": -0.1490085455087515, "compression_ratio": 1.732258064516129, "no_speech_prob": 0.08752502501010895}, {"id": 8, "seek": 2756, "start": 47.12, "end": 51.16, "text": " some of the more useful functions from the iter tools module. So the first thing I'm", "tokens": [51342, 512, 295, 264, 544, 4420, 6828, 490, 264, 17138, 3873, 10088, 13, 407, 264, 700, 551, 286, 478, 51544], "temperature": 0.0, "avg_logprob": -0.1490085455087515, "compression_ratio": 1.732258064516129, "no_speech_prob": 0.08752502501010895}, {"id": 9, "seek": 2756, "start": 51.16, "end": 55.2, "text": " going to do here is give you a very quick explanation of what an iterator is because", "tokens": [51544, 516, 281, 360, 510, 307, 976, 291, 257, 588, 1702, 10835, 295, 437, 364, 17138, 1639, 307, 570, 51746], "temperature": 0.0, "avg_logprob": -0.1490085455087515, "compression_ratio": 1.732258064516129, "no_speech_prob": 0.08752502501010895}, {"id": 10, "seek": 5520, "start": 55.2, "end": 59.36, "text": " all of the iter tools functions are going to return an iterator object, and we should", "tokens": [50364, 439, 295, 264, 17138, 3873, 6828, 366, 516, 281, 2736, 364, 17138, 1639, 2657, 11, 293, 321, 820, 50572], "temperature": 0.0, "avg_logprob": -0.15504369579377722, "compression_ratio": 1.8127090301003344, "no_speech_prob": 0.31053435802459717}, {"id": 11, "seek": 5520, "start": 59.36, "end": 63.32000000000001, "text": " probably understand how that works. Now I will mention that if you do have my programming", "tokens": [50572, 1391, 1223, 577, 300, 1985, 13, 823, 286, 486, 2152, 300, 498, 291, 360, 362, 452, 9410, 50770], "temperature": 0.0, "avg_logprob": -0.15504369579377722, "compression_ratio": 1.8127090301003344, "no_speech_prob": 0.31053435802459717}, {"id": 12, "seek": 5520, "start": 63.32000000000001, "end": 67.56, "text": " course, programming expert, then you would already understand iterators, you'd understand", "tokens": [50770, 1164, 11, 9410, 5844, 11, 550, 291, 576, 1217, 1223, 17138, 3391, 11, 291, 1116, 1223, 50982], "temperature": 0.0, "avg_logprob": -0.15504369579377722, "compression_ratio": 1.8127090301003344, "no_speech_prob": 0.31053435802459717}, {"id": 13, "seek": 5520, "start": 67.56, "end": 72.76, "text": " generators, decorators, more advanced programming, object oriented programming and all kinds", "tokens": [50982, 38662, 11, 7919, 3391, 11, 544, 7339, 9410, 11, 2657, 21841, 9410, 293, 439, 3685, 51242], "temperature": 0.0, "avg_logprob": -0.15504369579377722, "compression_ratio": 1.8127090301003344, "no_speech_prob": 0.31053435802459717}, {"id": 14, "seek": 5520, "start": 72.76, "end": 77.60000000000001, "text": " of cool features in Python. So if you're interested, check it out from the link in the description,", "tokens": [51242, 295, 1627, 4122, 294, 15329, 13, 407, 498, 291, 434, 3102, 11, 1520, 309, 484, 490, 264, 2113, 294, 264, 3855, 11, 51484], "temperature": 0.0, "avg_logprob": -0.15504369579377722, "compression_ratio": 1.8127090301003344, "no_speech_prob": 0.31053435802459717}, {"id": 15, "seek": 5520, "start": 77.60000000000001, "end": 82.36, "text": " programming expert.io, you can use discount code Tim. Anyways, what is an iterator?", "tokens": [51484, 9410, 5844, 13, 1004, 11, 291, 393, 764, 11635, 3089, 7172, 13, 15585, 11, 437, 307, 364, 17138, 1639, 30, 51722], "temperature": 0.0, "avg_logprob": -0.15504369579377722, "compression_ratio": 1.8127090301003344, "no_speech_prob": 0.31053435802459717}, {"id": 16, "seek": 8236, "start": 82.36, "end": 85.84, "text": " Well, to demonstrate this to you, let's start by having a look at something known as the", "tokens": [50364, 1042, 11, 281, 11698, 341, 281, 291, 11, 718, 311, 722, 538, 1419, 257, 574, 412, 746, 2570, 382, 264, 50538], "temperature": 0.0, "avg_logprob": -0.1611485004425049, "compression_ratio": 1.7568627450980392, "no_speech_prob": 0.3139641582965851}, {"id": 17, "seek": 8236, "start": 85.84, "end": 90.36, "text": " range function. Now we've probably seen this before, but if I do something like R is equal", "tokens": [50538, 3613, 2445, 13, 823, 321, 600, 1391, 1612, 341, 949, 11, 457, 498, 286, 360, 746, 411, 497, 307, 2681, 50764], "temperature": 0.0, "avg_logprob": -0.1611485004425049, "compression_ratio": 1.7568627450980392, "no_speech_prob": 0.3139641582965851}, {"id": 18, "seek": 8236, "start": 90.36, "end": 95.84, "text": " to range, and then let's go with the range of say one to 10. When I print this out here,", "tokens": [50764, 281, 3613, 11, 293, 550, 718, 311, 352, 365, 264, 3613, 295, 584, 472, 281, 1266, 13, 1133, 286, 4482, 341, 484, 510, 11, 51038], "temperature": 0.0, "avg_logprob": -0.1611485004425049, "compression_ratio": 1.7568627450980392, "no_speech_prob": 0.3139641582965851}, {"id": 19, "seek": 8236, "start": 95.84, "end": 101.36, "text": " let's have a look and notice I simply get range 110. Now range itself is not an iterator,", "tokens": [51038, 718, 311, 362, 257, 574, 293, 3449, 286, 2935, 483, 3613, 20154, 13, 823, 3613, 2564, 307, 406, 364, 17138, 1639, 11, 51314], "temperature": 0.0, "avg_logprob": -0.1611485004425049, "compression_ratio": 1.7568627450980392, "no_speech_prob": 0.3139641582965851}, {"id": 20, "seek": 8236, "start": 101.36, "end": 107.6, "text": " but it's known as iterable. Now anything that's iterable simply has an iter method on. So", "tokens": [51314, 457, 309, 311, 2570, 382, 17138, 712, 13, 823, 1340, 300, 311, 17138, 712, 2935, 575, 364, 17138, 3170, 322, 13, 407, 51626], "temperature": 0.0, "avg_logprob": -0.1611485004425049, "compression_ratio": 1.7568627450980392, "no_speech_prob": 0.3139641582965851}, {"id": 21, "seek": 10760, "start": 107.6, "end": 112.36, "text": " iter is this function that you can call. And what this does is actually call the corresponding", "tokens": [50364, 17138, 307, 341, 2445, 300, 291, 393, 818, 13, 400, 437, 341, 775, 307, 767, 818, 264, 11760, 50602], "temperature": 0.0, "avg_logprob": -0.1399112671844719, "compression_ratio": 1.952029520295203, "no_speech_prob": 0.5076285004615784}, {"id": 22, "seek": 10760, "start": 112.36, "end": 117.56, "text": " underscore, underscore, iter, which is on the class that represents this range function.", "tokens": [50602, 37556, 11, 37556, 11, 17138, 11, 597, 307, 322, 264, 1508, 300, 8855, 341, 3613, 2445, 13, 50862], "temperature": 0.0, "avg_logprob": -0.1399112671844719, "compression_ratio": 1.952029520295203, "no_speech_prob": 0.5076285004615784}, {"id": 23, "seek": 10760, "start": 117.56, "end": 121.28, "text": " So I know this is a bit complicated, but on range, there is this underscore underscore", "tokens": [50862, 407, 286, 458, 341, 307, 257, 857, 6179, 11, 457, 322, 3613, 11, 456, 307, 341, 37556, 37556, 51048], "temperature": 0.0, "avg_logprob": -0.1399112671844719, "compression_ratio": 1.952029520295203, "no_speech_prob": 0.5076285004615784}, {"id": 24, "seek": 10760, "start": 121.28, "end": 126.11999999999999, "text": " iter function that you can call. When you call that, it returns to you an iterator,", "tokens": [51048, 17138, 2445, 300, 291, 393, 818, 13, 1133, 291, 818, 300, 11, 309, 11247, 281, 291, 364, 17138, 1639, 11, 51290], "temperature": 0.0, "avg_logprob": -0.1399112671844719, "compression_ratio": 1.952029520295203, "no_speech_prob": 0.5076285004615784}, {"id": 25, "seek": 10760, "start": 126.11999999999999, "end": 131.14, "text": " and the iterator is what you iterate over to get all of the values in the range created", "tokens": [51290, 293, 264, 17138, 1639, 307, 437, 291, 44497, 670, 281, 483, 439, 295, 264, 4190, 294, 264, 3613, 2942, 51541], "temperature": 0.0, "avg_logprob": -0.1399112671844719, "compression_ratio": 1.952029520295203, "no_speech_prob": 0.5076285004615784}, {"id": 26, "seek": 10760, "start": 131.14, "end": 136.28, "text": " by this object. So for example, if I print out the iter of R, you're going to see that", "tokens": [51541, 538, 341, 2657, 13, 407, 337, 1365, 11, 498, 286, 4482, 484, 264, 17138, 295, 497, 11, 291, 434, 516, 281, 536, 300, 51798], "temperature": 0.0, "avg_logprob": -0.1399112671844719, "compression_ratio": 1.952029520295203, "no_speech_prob": 0.5076285004615784}, {"id": 27, "seek": 13628, "start": 136.28, "end": 141.88, "text": " I get a range iterator object. Now this range iterator object is something I can iterate", "tokens": [50364, 286, 483, 257, 3613, 17138, 1639, 2657, 13, 823, 341, 3613, 17138, 1639, 2657, 307, 746, 286, 393, 44497, 50644], "temperature": 0.0, "avg_logprob": -0.11968743720022189, "compression_ratio": 1.8680555555555556, "no_speech_prob": 0.020961981266736984}, {"id": 28, "seek": 13628, "start": 141.88, "end": 147.04, "text": " over. So let's have a look here. Let's just say I is equal to that. And now let's print", "tokens": [50644, 670, 13, 407, 718, 311, 362, 257, 574, 510, 13, 961, 311, 445, 584, 286, 307, 2681, 281, 300, 13, 400, 586, 718, 311, 4482, 50902], "temperature": 0.0, "avg_logprob": -0.11968743720022189, "compression_ratio": 1.8680555555555556, "no_speech_prob": 0.020961981266736984}, {"id": 29, "seek": 13628, "start": 147.04, "end": 151.52, "text": " out, for example, the list of I when I do this, I get one, two, three, four, five, six,", "tokens": [50902, 484, 11, 337, 1365, 11, 264, 1329, 295, 286, 562, 286, 360, 341, 11, 286, 483, 472, 11, 732, 11, 1045, 11, 1451, 11, 1732, 11, 2309, 11, 51126], "temperature": 0.0, "avg_logprob": -0.11968743720022189, "compression_ratio": 1.8680555555555556, "no_speech_prob": 0.020961981266736984}, {"id": 30, "seek": 13628, "start": 151.52, "end": 155.4, "text": " seven, eight, nine, because this is iterable. So I can use the list function on it. And", "tokens": [51126, 3407, 11, 3180, 11, 4949, 11, 570, 341, 307, 17138, 712, 13, 407, 286, 393, 764, 264, 1329, 2445, 322, 309, 13, 400, 51320], "temperature": 0.0, "avg_logprob": -0.11968743720022189, "compression_ratio": 1.8680555555555556, "no_speech_prob": 0.020961981266736984}, {"id": 31, "seek": 13628, "start": 155.4, "end": 160.52, "text": " it gives me all of the elements in this iterator. However, an iterator is an iterator when", "tokens": [51320, 309, 2709, 385, 439, 295, 264, 4959, 294, 341, 17138, 1639, 13, 2908, 11, 364, 17138, 1639, 307, 364, 17138, 1639, 562, 51576], "temperature": 0.0, "avg_logprob": -0.11968743720022189, "compression_ratio": 1.8680555555555556, "no_speech_prob": 0.020961981266736984}, {"id": 32, "seek": 13628, "start": 160.52, "end": 165.96, "text": " it has an underscore underscore next underscore underscore method. So this method is a special", "tokens": [51576, 309, 575, 364, 37556, 37556, 958, 37556, 37556, 3170, 13, 407, 341, 3170, 307, 257, 2121, 51848], "temperature": 0.0, "avg_logprob": -0.11968743720022189, "compression_ratio": 1.8680555555555556, "no_speech_prob": 0.020961981266736984}, {"id": 33, "seek": 16596, "start": 165.96, "end": 170.72, "text": " method that returns to you the next, the value in the iterable sequence. So when I have", "tokens": [50364, 3170, 300, 11247, 281, 291, 264, 958, 11, 264, 2158, 294, 264, 17138, 712, 8310, 13, 407, 562, 286, 362, 50602], "temperature": 0.0, "avg_logprob": -0.13011077142530872, "compression_ratio": 1.785953177257525, "no_speech_prob": 0.03963430970907211}, {"id": 34, "seek": 16596, "start": 170.72, "end": 175.52, "text": " a range of one to 10, what I can do is the following. I can print out the next of my", "tokens": [50602, 257, 3613, 295, 472, 281, 1266, 11, 437, 286, 393, 360, 307, 264, 3480, 13, 286, 393, 4482, 484, 264, 958, 295, 452, 50842], "temperature": 0.0, "avg_logprob": -0.13011077142530872, "compression_ratio": 1.785953177257525, "no_speech_prob": 0.03963430970907211}, {"id": 35, "seek": 16596, "start": 175.52, "end": 180.56, "text": " iterator, which is I, and let's print this out a few times. Now, when I do this, notice", "tokens": [50842, 17138, 1639, 11, 597, 307, 286, 11, 293, 718, 311, 4482, 341, 484, 257, 1326, 1413, 13, 823, 11, 562, 286, 360, 341, 11, 3449, 51094], "temperature": 0.0, "avg_logprob": -0.13011077142530872, "compression_ratio": 1.785953177257525, "no_speech_prob": 0.03963430970907211}, {"id": 36, "seek": 16596, "start": 180.56, "end": 185.16, "text": " I get one, two, and three, right? It's giving me all of the values in my sequence. And then", "tokens": [51094, 286, 483, 472, 11, 732, 11, 293, 1045, 11, 558, 30, 467, 311, 2902, 385, 439, 295, 264, 4190, 294, 452, 8310, 13, 400, 550, 51324], "temperature": 0.0, "avg_logprob": -0.13011077142530872, "compression_ratio": 1.785953177257525, "no_speech_prob": 0.03963430970907211}, {"id": 37, "seek": 16596, "start": 185.16, "end": 189.44, "text": " to go even further, let's have a look at something like this for X in, and then I'm going to", "tokens": [51324, 281, 352, 754, 3052, 11, 718, 311, 362, 257, 574, 412, 746, 411, 341, 337, 1783, 294, 11, 293, 550, 286, 478, 516, 281, 51538], "temperature": 0.0, "avg_logprob": -0.13011077142530872, "compression_ratio": 1.785953177257525, "no_speech_prob": 0.03963430970907211}, {"id": 38, "seek": 16596, "start": 189.44, "end": 193.8, "text": " say I, because I can loop through an iterator, right? And I have my iterator I. And when", "tokens": [51538, 584, 286, 11, 570, 286, 393, 6367, 807, 364, 17138, 1639, 11, 558, 30, 400, 286, 362, 452, 17138, 1639, 286, 13, 400, 562, 51756], "temperature": 0.0, "avg_logprob": -0.13011077142530872, "compression_ratio": 1.785953177257525, "no_speech_prob": 0.03963430970907211}, {"id": 39, "seek": 19380, "start": 193.8, "end": 199.64000000000001, "text": " I start printing X here, let's have a look and notice that I don't get any repeated values.", "tokens": [50364, 286, 722, 14699, 1783, 510, 11, 718, 311, 362, 257, 574, 293, 3449, 300, 286, 500, 380, 483, 604, 10477, 4190, 13, 50656], "temperature": 0.0, "avg_logprob": -0.08847162458631727, "compression_ratio": 1.7532051282051282, "no_speech_prob": 0.014956056140363216}, {"id": 40, "seek": 19380, "start": 199.64000000000001, "end": 203.52, "text": " So I have my one, two, three from all of the next up here. And then when I continue looping", "tokens": [50656, 407, 286, 362, 452, 472, 11, 732, 11, 1045, 490, 439, 295, 264, 958, 493, 510, 13, 400, 550, 562, 286, 2354, 6367, 278, 50850], "temperature": 0.0, "avg_logprob": -0.08847162458631727, "compression_ratio": 1.7532051282051282, "no_speech_prob": 0.014956056140363216}, {"id": 41, "seek": 19380, "start": 203.52, "end": 207.24, "text": " through the iterator, I get four, five, six, seven, eight, nine, because since we've called", "tokens": [50850, 807, 264, 17138, 1639, 11, 286, 483, 1451, 11, 1732, 11, 2309, 11, 3407, 11, 3180, 11, 4949, 11, 570, 1670, 321, 600, 1219, 51036], "temperature": 0.0, "avg_logprob": -0.08847162458631727, "compression_ratio": 1.7532051282051282, "no_speech_prob": 0.014956056140363216}, {"id": 42, "seek": 19380, "start": 207.24, "end": 212.72000000000003, "text": " the next method manually, we've been moved to the next values in the iterable sequence.", "tokens": [51036, 264, 958, 3170, 16945, 11, 321, 600, 668, 4259, 281, 264, 958, 4190, 294, 264, 17138, 712, 8310, 13, 51310], "temperature": 0.0, "avg_logprob": -0.08847162458631727, "compression_ratio": 1.7532051282051282, "no_speech_prob": 0.014956056140363216}, {"id": 43, "seek": 19380, "start": 212.72000000000003, "end": 216.12, "text": " I know this is a little bit confusing if this is the first time that you're seeing it, but", "tokens": [51310, 286, 458, 341, 307, 257, 707, 857, 13181, 498, 341, 307, 264, 700, 565, 300, 291, 434, 2577, 309, 11, 457, 51480], "temperature": 0.0, "avg_logprob": -0.08847162458631727, "compression_ratio": 1.7532051282051282, "no_speech_prob": 0.014956056140363216}, {"id": 44, "seek": 19380, "start": 216.12, "end": 220.72000000000003, "text": " essentially when you have an iterator or something that's iterable, sorry, you can call this", "tokens": [51480, 4476, 562, 291, 362, 364, 17138, 1639, 420, 746, 300, 311, 17138, 712, 11, 2597, 11, 291, 393, 818, 341, 51710], "temperature": 0.0, "avg_logprob": -0.08847162458631727, "compression_ratio": 1.7532051282051282, "no_speech_prob": 0.014956056140363216}, {"id": 45, "seek": 22072, "start": 220.72, "end": 225.32, "text": " iter function on it. That returns to you an iterator. And then the iterator, you can", "tokens": [50364, 17138, 2445, 322, 309, 13, 663, 11247, 281, 291, 364, 17138, 1639, 13, 400, 550, 264, 17138, 1639, 11, 291, 393, 50594], "temperature": 0.0, "avg_logprob": -0.10453946050936289, "compression_ratio": 1.8869257950530036, "no_speech_prob": 0.23927494883537292}, {"id": 46, "seek": 22072, "start": 225.32, "end": 230.48, "text": " call this next function on, and it gives you the next value in the iterator sequence.", "tokens": [50594, 818, 341, 958, 2445, 322, 11, 293, 309, 2709, 291, 264, 958, 2158, 294, 264, 17138, 1639, 8310, 13, 50852], "temperature": 0.0, "avg_logprob": -0.10453946050936289, "compression_ratio": 1.8869257950530036, "no_speech_prob": 0.23927494883537292}, {"id": 47, "seek": 22072, "start": 230.48, "end": 234.84, "text": " You know that you're finished iterating when a specific exception is raised. This exception", "tokens": [50852, 509, 458, 300, 291, 434, 4335, 17138, 990, 562, 257, 2685, 11183, 307, 6005, 13, 639, 11183, 51070], "temperature": 0.0, "avg_logprob": -0.10453946050936289, "compression_ratio": 1.8869257950530036, "no_speech_prob": 0.23927494883537292}, {"id": 48, "seek": 22072, "start": 234.84, "end": 240.32, "text": " is known as stop iteration. And to show you that, let's just print next a bunch of times.", "tokens": [51070, 307, 2570, 382, 1590, 24784, 13, 400, 281, 855, 291, 300, 11, 718, 311, 445, 4482, 958, 257, 3840, 295, 1413, 13, 51344], "temperature": 0.0, "avg_logprob": -0.10453946050936289, "compression_ratio": 1.8869257950530036, "no_speech_prob": 0.23927494883537292}, {"id": 49, "seek": 22072, "start": 240.32, "end": 245.7, "text": " So we only have nine values in our sequence here. So when I print, uh, the next of I more", "tokens": [51344, 407, 321, 787, 362, 4949, 4190, 294, 527, 8310, 510, 13, 407, 562, 286, 4482, 11, 2232, 11, 264, 958, 295, 286, 544, 51613], "temperature": 0.0, "avg_logprob": -0.10453946050936289, "compression_ratio": 1.8869257950530036, "no_speech_prob": 0.23927494883537292}, {"id": 50, "seek": 22072, "start": 245.7, "end": 250.4, "text": " than nine times, you'll see here that we get a stop iteration exception. Uh, and that tells", "tokens": [51613, 813, 4949, 1413, 11, 291, 603, 536, 510, 300, 321, 483, 257, 1590, 24784, 11183, 13, 4019, 11, 293, 300, 5112, 51848], "temperature": 0.0, "avg_logprob": -0.10453946050936289, "compression_ratio": 1.8869257950530036, "no_speech_prob": 0.23927494883537292}, {"id": 51, "seek": 25040, "start": 250.48000000000002, "end": 255.0, "text": " us there's no more values in our iterator to be returned. So that was a very high level", "tokens": [50368, 505, 456, 311, 572, 544, 4190, 294, 527, 17138, 1639, 281, 312, 8752, 13, 407, 300, 390, 257, 588, 1090, 1496, 50594], "temperature": 0.0, "avg_logprob": -0.12042881158682016, "compression_ratio": 1.8842105263157896, "no_speech_prob": 0.017440425232052803}, {"id": 52, "seek": 25040, "start": 255.0, "end": 259.92, "text": " overview of iterators and iterable objects. However, you may be interested to know that", "tokens": [50594, 12492, 295, 17138, 3391, 293, 17138, 712, 6565, 13, 2908, 11, 291, 815, 312, 3102, 281, 458, 300, 50840], "temperature": 0.0, "avg_logprob": -0.12042881158682016, "compression_ratio": 1.8842105263157896, "no_speech_prob": 0.017440425232052803}, {"id": 53, "seek": 25040, "start": 259.92, "end": 264.44, "text": " when we have a for loop like this, and we're looping through an iterable object, what actually", "tokens": [50840, 562, 321, 362, 257, 337, 6367, 411, 341, 11, 293, 321, 434, 6367, 278, 807, 364, 17138, 712, 2657, 11, 437, 767, 51066], "temperature": 0.0, "avg_logprob": -0.12042881158682016, "compression_ratio": 1.8842105263157896, "no_speech_prob": 0.017440425232052803}, {"id": 54, "seek": 25040, "start": 264.44, "end": 270.4, "text": " happens implicitly is you're going to call the iter function or method on this, uh, iterable", "tokens": [51066, 2314, 26947, 356, 307, 291, 434, 516, 281, 818, 264, 17138, 2445, 420, 3170, 322, 341, 11, 2232, 11, 17138, 712, 51364], "temperature": 0.0, "avg_logprob": -0.12042881158682016, "compression_ratio": 1.8842105263157896, "no_speech_prob": 0.017440425232052803}, {"id": 55, "seek": 25040, "start": 270.4, "end": 275.0, "text": " object. That's going to return an iterator. And then the for loop is going to continually", "tokens": [51364, 2657, 13, 663, 311, 516, 281, 2736, 364, 17138, 1639, 13, 400, 550, 264, 337, 6367, 307, 516, 281, 22277, 51594], "temperature": 0.0, "avg_logprob": -0.12042881158682016, "compression_ratio": 1.8842105263157896, "no_speech_prob": 0.017440425232052803}, {"id": 56, "seek": 25040, "start": 275.0, "end": 280.32, "text": " call the next method on this iterator until eventually the stop iteration exception", "tokens": [51594, 818, 264, 958, 3170, 322, 341, 17138, 1639, 1826, 4728, 264, 1590, 24784, 11183, 51860], "temperature": 0.0, "avg_logprob": -0.12042881158682016, "compression_ratio": 1.8842105263157896, "no_speech_prob": 0.017440425232052803}, {"id": 57, "seek": 28032, "start": 280.32, "end": 284.52, "text": " is raised. So once that exception is raised, the for loop knows there's no more objects", "tokens": [50364, 307, 6005, 13, 407, 1564, 300, 11183, 307, 6005, 11, 264, 337, 6367, 3255, 456, 311, 572, 544, 6565, 50574], "temperature": 0.0, "avg_logprob": -0.11272909858010031, "compression_ratio": 1.7346153846153847, "no_speech_prob": 0.004070015624165535}, {"id": 58, "seek": 28032, "start": 284.52, "end": 288.8, "text": " to loop through, and it can stop iterating. And the value that you're going to look at", "tokens": [50574, 281, 6367, 807, 11, 293, 309, 393, 1590, 17138, 990, 13, 400, 264, 2158, 300, 291, 434, 516, 281, 574, 412, 50788], "temperature": 0.0, "avg_logprob": -0.11272909858010031, "compression_ratio": 1.7346153846153847, "no_speech_prob": 0.004070015624165535}, {"id": 59, "seek": 28032, "start": 288.8, "end": 294.4, "text": " for I here for our iterator variable is going to be equal to whatever that next method returned", "tokens": [50788, 337, 286, 510, 337, 527, 17138, 1639, 7006, 307, 516, 281, 312, 2681, 281, 2035, 300, 958, 3170, 8752, 51068], "temperature": 0.0, "avg_logprob": -0.11272909858010031, "compression_ratio": 1.7346153846153847, "no_speech_prob": 0.004070015624165535}, {"id": 60, "seek": 28032, "start": 294.4, "end": 298.76, "text": " at every single step in the iterator. Hopefully that makes a little bit of sense. But again,", "tokens": [51068, 412, 633, 2167, 1823, 294, 264, 17138, 1639, 13, 10429, 300, 1669, 257, 707, 857, 295, 2020, 13, 583, 797, 11, 51286], "temperature": 0.0, "avg_logprob": -0.11272909858010031, "compression_ratio": 1.7346153846153847, "no_speech_prob": 0.004070015624165535}, {"id": 61, "seek": 28032, "start": 298.76, "end": 303.96, "text": " we have the next function, we have the iter function, and these are really just mapping", "tokens": [51286, 321, 362, 264, 958, 2445, 11, 321, 362, 264, 17138, 2445, 11, 293, 613, 366, 534, 445, 18350, 51546], "temperature": 0.0, "avg_logprob": -0.11272909858010031, "compression_ratio": 1.7346153846153847, "no_speech_prob": 0.004070015624165535}, {"id": 62, "seek": 30396, "start": 303.96, "end": 312.47999999999996, "text": " to the dot underscore underscore, uh, next like this and to the dot. And then this is", "tokens": [50364, 281, 264, 5893, 37556, 37556, 11, 2232, 11, 958, 411, 341, 293, 281, 264, 5893, 13, 400, 550, 341, 307, 50790], "temperature": 0.0, "avg_logprob": -0.17783555360597986, "compression_ratio": 1.9739130434782608, "no_speech_prob": 0.22811588644981384}, {"id": 63, "seek": 30396, "start": 312.47999999999996, "end": 317.71999999999997, "text": " going to be underscore underscore, iter underscore underscore method. So anything that is iterable", "tokens": [50790, 516, 281, 312, 37556, 37556, 11, 17138, 37556, 37556, 3170, 13, 407, 1340, 300, 307, 17138, 712, 51052], "temperature": 0.0, "avg_logprob": -0.17783555360597986, "compression_ratio": 1.9739130434782608, "no_speech_prob": 0.22811588644981384}, {"id": 64, "seek": 30396, "start": 317.71999999999997, "end": 322.03999999999996, "text": " has this iter method and anything that is an iterator has this next method. And when", "tokens": [51052, 575, 341, 17138, 3170, 293, 1340, 300, 307, 364, 17138, 1639, 575, 341, 958, 3170, 13, 400, 562, 51268], "temperature": 0.0, "avg_logprob": -0.17783555360597986, "compression_ratio": 1.9739130434782608, "no_speech_prob": 0.22811588644981384}, {"id": 65, "seek": 30396, "start": 322.03999999999996, "end": 326.56, "text": " you use the next function and the iter function, you're just calling these methods on those", "tokens": [51268, 291, 764, 264, 958, 2445, 293, 264, 17138, 2445, 11, 291, 434, 445, 5141, 613, 7150, 322, 729, 51494], "temperature": 0.0, "avg_logprob": -0.17783555360597986, "compression_ratio": 1.9739130434782608, "no_speech_prob": 0.22811588644981384}, {"id": 66, "seek": 30396, "start": 326.56, "end": 331.32, "text": " objects. All right. Hopefully that is clear. Now let's have a look at the iter tools module.", "tokens": [51494, 6565, 13, 1057, 558, 13, 10429, 300, 307, 1850, 13, 823, 718, 311, 362, 257, 574, 412, 264, 17138, 3873, 10088, 13, 51732], "temperature": 0.0, "avg_logprob": -0.17783555360597986, "compression_ratio": 1.9739130434782608, "no_speech_prob": 0.22811588644981384}, {"id": 67, "seek": 33132, "start": 331.32, "end": 334.8, "text": " So the first type of functions I'm going to show you from the iter tools module are", "tokens": [50364, 407, 264, 700, 2010, 295, 6828, 286, 478, 516, 281, 855, 291, 490, 264, 17138, 3873, 10088, 366, 50538], "temperature": 0.0, "avg_logprob": -0.1160584244073606, "compression_ratio": 1.8486646884272997, "no_speech_prob": 0.11278053373098373}, {"id": 68, "seek": 33132, "start": 334.8, "end": 338.92, "text": " known as infinite iterators. And what that means is that they can return an infinite", "tokens": [50538, 2570, 382, 13785, 17138, 3391, 13, 400, 437, 300, 1355, 307, 300, 436, 393, 2736, 364, 13785, 50744], "temperature": 0.0, "avg_logprob": -0.1160584244073606, "compression_ratio": 1.8486646884272997, "no_speech_prob": 0.11278053373098373}, {"id": 69, "seek": 33132, "start": 338.92, "end": 343.64, "text": " sequence and they actually do this by using something known as the generator syntax. I'm", "tokens": [50744, 8310, 293, 436, 767, 360, 341, 538, 1228, 746, 2570, 382, 264, 19265, 28431, 13, 286, 478, 50980], "temperature": 0.0, "avg_logprob": -0.1160584244073606, "compression_ratio": 1.8486646884272997, "no_speech_prob": 0.11278053373098373}, {"id": 70, "seek": 33132, "start": 343.64, "end": 346.76, "text": " not going to explain what a generator is in this video. Again, you could learn that from", "tokens": [50980, 406, 516, 281, 2903, 437, 257, 19265, 307, 294, 341, 960, 13, 3764, 11, 291, 727, 1466, 300, 490, 51136], "temperature": 0.0, "avg_logprob": -0.1160584244073606, "compression_ratio": 1.8486646884272997, "no_speech_prob": 0.11278053373098373}, {"id": 71, "seek": 33132, "start": 346.76, "end": 351.15999999999997, "text": " something like programming expert. Uh, but for now, let's have a look at the first function,", "tokens": [51136, 746, 411, 9410, 5844, 13, 4019, 11, 457, 337, 586, 11, 718, 311, 362, 257, 574, 412, 264, 700, 2445, 11, 51356], "temperature": 0.0, "avg_logprob": -0.1160584244073606, "compression_ratio": 1.8486646884272997, "no_speech_prob": 0.11278053373098373}, {"id": 72, "seek": 33132, "start": 351.15999999999997, "end": 355.96, "text": " which is count. So this is an infinite iterator. And the way this works is you pass a start", "tokens": [51356, 597, 307, 1207, 13, 407, 341, 307, 364, 13785, 17138, 1639, 13, 400, 264, 636, 341, 1985, 307, 291, 1320, 257, 722, 51596], "temperature": 0.0, "avg_logprob": -0.1160584244073606, "compression_ratio": 1.8486646884272997, "no_speech_prob": 0.11278053373098373}, {"id": 73, "seek": 33132, "start": 355.96, "end": 361.15999999999997, "text": " and an optional step value. If you don't pass a step, this will by default be one. And this", "tokens": [51596, 293, 364, 17312, 1823, 2158, 13, 759, 291, 500, 380, 1320, 257, 1823, 11, 341, 486, 538, 7576, 312, 472, 13, 400, 341, 51856], "temperature": 0.0, "avg_logprob": -0.1160584244073606, "compression_ratio": 1.8486646884272997, "no_speech_prob": 0.11278053373098373}, {"id": 74, "seek": 36116, "start": 361.20000000000005, "end": 365.56, "text": " will do exactly what it says. It will simply count a sequence starting at some value and", "tokens": [50366, 486, 360, 2293, 437, 309, 1619, 13, 467, 486, 2935, 1207, 257, 8310, 2891, 412, 512, 2158, 293, 50584], "temperature": 0.0, "avg_logprob": -0.10032172203063965, "compression_ratio": 1.7830508474576272, "no_speech_prob": 0.04467400535941124}, {"id": 75, "seek": 36116, "start": 365.56, "end": 369.76000000000005, "text": " going up by the step every single time. So if I start at 10, which is what I'm passing", "tokens": [50584, 516, 493, 538, 264, 1823, 633, 2167, 565, 13, 407, 498, 286, 722, 412, 1266, 11, 597, 307, 437, 286, 478, 8437, 50794], "temperature": 0.0, "avg_logprob": -0.10032172203063965, "compression_ratio": 1.7830508474576272, "no_speech_prob": 0.04467400535941124}, {"id": 76, "seek": 36116, "start": 369.76000000000005, "end": 374.48, "text": " for the start here, and then I have a step of five, we're going to count up by five until", "tokens": [50794, 337, 264, 722, 510, 11, 293, 550, 286, 362, 257, 1823, 295, 1732, 11, 321, 434, 516, 281, 1207, 493, 538, 1732, 1826, 51030], "temperature": 0.0, "avg_logprob": -0.10032172203063965, "compression_ratio": 1.7830508474576272, "no_speech_prob": 0.04467400535941124}, {"id": 77, "seek": 36116, "start": 374.48, "end": 379.16, "text": " we decide we no longer want to iterate over this iterator. So if I run the code here,", "tokens": [51030, 321, 4536, 321, 572, 2854, 528, 281, 44497, 670, 341, 17138, 1639, 13, 407, 498, 286, 1190, 264, 3089, 510, 11, 51264], "temperature": 0.0, "avg_logprob": -0.10032172203063965, "compression_ratio": 1.7830508474576272, "no_speech_prob": 0.04467400535941124}, {"id": 78, "seek": 36116, "start": 379.16, "end": 383.12, "text": " you can see that we get a sequence where we are starting at 10 going up by five and I've", "tokens": [51264, 291, 393, 536, 300, 321, 483, 257, 8310, 689, 321, 366, 2891, 412, 1266, 516, 493, 538, 1732, 293, 286, 600, 51462], "temperature": 0.0, "avg_logprob": -0.10032172203063965, "compression_ratio": 1.7830508474576272, "no_speech_prob": 0.04467400535941124}, {"id": 79, "seek": 36116, "start": 383.12, "end": 387.56, "text": " just made it so we manually stop here at a hundred. If I didn't have this break, then", "tokens": [51462, 445, 1027, 309, 370, 321, 16945, 1590, 510, 412, 257, 3262, 13, 759, 286, 994, 380, 362, 341, 1821, 11, 550, 51684], "temperature": 0.0, "avg_logprob": -0.10032172203063965, "compression_ratio": 1.7830508474576272, "no_speech_prob": 0.04467400535941124}, {"id": 80, "seek": 38756, "start": 387.64, "end": 392.52, "text": " this would happen infinitely because again, this is an infinite sequence. So that is cool.", "tokens": [50368, 341, 576, 1051, 36227, 570, 797, 11, 341, 307, 364, 13785, 8310, 13, 407, 300, 307, 1627, 13, 50612], "temperature": 0.0, "avg_logprob": -0.09536768595377604, "compression_ratio": 1.8150684931506849, "no_speech_prob": 0.11917833983898163}, {"id": 81, "seek": 38756, "start": 392.72, "end": 397.04, "text": " That is the count function. Now let's move on to the next one. The next function that", "tokens": [50622, 663, 307, 264, 1207, 2445, 13, 823, 718, 311, 1286, 322, 281, 264, 958, 472, 13, 440, 958, 2445, 300, 50838], "temperature": 0.0, "avg_logprob": -0.09536768595377604, "compression_ratio": 1.8150684931506849, "no_speech_prob": 0.11917833983898163}, {"id": 82, "seek": 38756, "start": 397.04, "end": 401.76, "text": " I have for you is also an infinite iterator. And this is known as repeat. Now, this is", "tokens": [50838, 286, 362, 337, 291, 307, 611, 364, 13785, 17138, 1639, 13, 400, 341, 307, 2570, 382, 7149, 13, 823, 11, 341, 307, 51074], "temperature": 0.0, "avg_logprob": -0.09536768595377604, "compression_ratio": 1.8150684931506849, "no_speech_prob": 0.11917833983898163}, {"id": 83, "seek": 38756, "start": 401.76, "end": 405.36, "text": " pretty straightforward, but this is going to take in a element. This element could be", "tokens": [51074, 1238, 15325, 11, 457, 341, 307, 516, 281, 747, 294, 257, 4478, 13, 639, 4478, 727, 312, 51254], "temperature": 0.0, "avg_logprob": -0.09536768595377604, "compression_ratio": 1.8150684931506849, "no_speech_prob": 0.11917833983898163}, {"id": 84, "seek": 38756, "start": 405.36, "end": 409.32, "text": " a list. It could be a string. It can be really anything you want. And then the maximum number", "tokens": [51254, 257, 1329, 13, 467, 727, 312, 257, 6798, 13, 467, 393, 312, 534, 1340, 291, 528, 13, 400, 550, 264, 6674, 1230, 51452], "temperature": 0.0, "avg_logprob": -0.09536768595377604, "compression_ratio": 1.8150684931506849, "no_speech_prob": 0.11917833983898163}, {"id": 85, "seek": 38756, "start": 409.32, "end": 413.6, "text": " of times you'd like to repeat this, this is optional. If you do not pass this, it will", "tokens": [51452, 295, 1413, 291, 1116, 411, 281, 7149, 341, 11, 341, 307, 17312, 13, 759, 291, 360, 406, 1320, 341, 11, 309, 486, 51666], "temperature": 0.0, "avg_logprob": -0.09536768595377604, "compression_ratio": 1.8150684931506849, "no_speech_prob": 0.11917833983898163}, {"id": 86, "seek": 41360, "start": 413.64000000000004, "end": 418.6, "text": " repeat indefinitely. So for here, if I have repeat, and I'm repeating hello, and I say", "tokens": [50366, 7149, 24162, 10925, 13, 407, 337, 510, 11, 498, 286, 362, 7149, 11, 293, 286, 478, 18617, 7751, 11, 293, 286, 584, 50614], "temperature": 0.0, "avg_logprob": -0.1327901976449149, "compression_ratio": 1.7532467532467533, "no_speech_prob": 0.08267847448587418}, {"id": 87, "seek": 41360, "start": 418.6, "end": 423.28000000000003, "text": " a maximum of 10 times, then I can loop through this repeater iterator. That's what's going", "tokens": [50614, 257, 6674, 295, 1266, 1413, 11, 550, 286, 393, 6367, 807, 341, 4301, 771, 17138, 1639, 13, 663, 311, 437, 311, 516, 50848], "temperature": 0.0, "avg_logprob": -0.1327901976449149, "compression_ratio": 1.7532467532467533, "no_speech_prob": 0.08267847448587418}, {"id": 88, "seek": 41360, "start": 423.28000000000003, "end": 428.04, "text": " to be returned here when you call the repeat function up to 10 times and print out the", "tokens": [50848, 281, 312, 8752, 510, 562, 291, 818, 264, 7149, 2445, 493, 281, 1266, 1413, 293, 4482, 484, 264, 51086], "temperature": 0.0, "avg_logprob": -0.1327901976449149, "compression_ratio": 1.7532467532467533, "no_speech_prob": 0.08267847448587418}, {"id": 89, "seek": 41360, "start": 428.04, "end": 433.0, "text": " value. So if I do this, you'll just see that we get 10 hellos showing up on the screen.", "tokens": [51086, 2158, 13, 407, 498, 286, 360, 341, 11, 291, 603, 445, 536, 300, 321, 483, 1266, 4921, 329, 4099, 493, 322, 264, 2568, 13, 51334], "temperature": 0.0, "avg_logprob": -0.1327901976449149, "compression_ratio": 1.7532467532467533, "no_speech_prob": 0.08267847448587418}, {"id": 90, "seek": 41360, "start": 433.0, "end": 437.32000000000005, "text": " So this is useful if you want to repeat something a certain number of times. So the next function", "tokens": [51334, 407, 341, 307, 4420, 498, 291, 528, 281, 7149, 746, 257, 1629, 1230, 295, 1413, 13, 407, 264, 958, 2445, 51550], "temperature": 0.0, "avg_logprob": -0.1327901976449149, "compression_ratio": 1.7532467532467533, "no_speech_prob": 0.08267847448587418}, {"id": 91, "seek": 41360, "start": 437.32000000000005, "end": 441.28000000000003, "text": " that I have for you is known as cycle. Now, this is pretty straightforward. This is going", "tokens": [51550, 300, 286, 362, 337, 291, 307, 2570, 382, 6586, 13, 823, 11, 341, 307, 1238, 15325, 13, 639, 307, 516, 51748], "temperature": 0.0, "avg_logprob": -0.1327901976449149, "compression_ratio": 1.7532467532467533, "no_speech_prob": 0.08267847448587418}, {"id": 92, "seek": 44128, "start": 441.32, "end": 445.35999999999996, "text": " to take in some iterable object. It could be a string, could be a tuple, could be a", "tokens": [50366, 281, 747, 294, 512, 17138, 712, 2657, 13, 467, 727, 312, 257, 6798, 11, 727, 312, 257, 2604, 781, 11, 727, 312, 257, 50568], "temperature": 0.0, "avg_logprob": -0.10921148370813441, "compression_ratio": 1.7114754098360656, "no_speech_prob": 0.20682434737682343}, {"id": 93, "seek": 44128, "start": 445.35999999999996, "end": 449.55999999999995, "text": " list, really, whatever you want. And it's going to allow you to cycle over all of the", "tokens": [50568, 1329, 11, 534, 11, 2035, 291, 528, 13, 400, 309, 311, 516, 281, 2089, 291, 281, 6586, 670, 439, 295, 264, 50778], "temperature": 0.0, "avg_logprob": -0.10921148370813441, "compression_ratio": 1.7114754098360656, "no_speech_prob": 0.20682434737682343}, {"id": 94, "seek": 44128, "start": 449.55999999999995, "end": 454.08, "text": " elements as many times as you would like. Again, these are infinite iterators. So you", "tokens": [50778, 4959, 382, 867, 1413, 382, 291, 576, 411, 13, 3764, 11, 613, 366, 13785, 17138, 3391, 13, 407, 291, 51004], "temperature": 0.0, "avg_logprob": -0.10921148370813441, "compression_ratio": 1.7114754098360656, "no_speech_prob": 0.20682434737682343}, {"id": 95, "seek": 44128, "start": 454.08, "end": 458.28, "text": " have to decide when you want to stop iterating over them. They will continue to generate", "tokens": [51004, 362, 281, 4536, 562, 291, 528, 281, 1590, 17138, 990, 670, 552, 13, 814, 486, 2354, 281, 8460, 51214], "temperature": 0.0, "avg_logprob": -0.10921148370813441, "compression_ratio": 1.7114754098360656, "no_speech_prob": 0.20682434737682343}, {"id": 96, "seek": 44128, "start": 458.28, "end": 462.88, "text": " a sequence forever. So let's run the code here and have a look at what this does. Notice", "tokens": [51214, 257, 8310, 5680, 13, 407, 718, 311, 1190, 264, 3089, 510, 293, 362, 257, 574, 412, 437, 341, 775, 13, 13428, 51444], "temperature": 0.0, "avg_logprob": -0.10921148370813441, "compression_ratio": 1.7114754098360656, "no_speech_prob": 0.20682434737682343}, {"id": 97, "seek": 44128, "start": 462.88, "end": 468.0, "text": " that we just cycle through ABCDEF constantly until I have a manual stop here where we've", "tokens": [51444, 300, 321, 445, 6586, 807, 22342, 22296, 37, 6460, 1826, 286, 362, 257, 9688, 1590, 510, 689, 321, 600, 51700], "temperature": 0.0, "avg_logprob": -0.10921148370813441, "compression_ratio": 1.7114754098360656, "no_speech_prob": 0.20682434737682343}, {"id": 98, "seek": 46800, "start": 468.0, "end": 472.52, "text": " done this over 100 times. So what I'm actually doing is manually calling the next method", "tokens": [50364, 1096, 341, 670, 2319, 1413, 13, 407, 437, 286, 478, 767, 884, 307, 16945, 5141, 264, 958, 3170, 50590], "temperature": 0.0, "avg_logprob": -0.11491284753284316, "compression_ratio": 1.9, "no_speech_prob": 0.04885052144527435}, {"id": 99, "seek": 46800, "start": 472.52, "end": 477.52, "text": " here on my cycler, which is equal to a cycle iterator. And if we want to just have a quick", "tokens": [50590, 510, 322, 452, 38154, 1918, 11, 597, 307, 2681, 281, 257, 6586, 17138, 1639, 13, 400, 498, 321, 528, 281, 445, 362, 257, 1702, 50840], "temperature": 0.0, "avg_logprob": -0.11491284753284316, "compression_ratio": 1.9, "no_speech_prob": 0.04885052144527435}, {"id": 100, "seek": 46800, "start": 477.52, "end": 482.88, "text": " look here at what the iterator object actually looks like, we can print out our cycler and", "tokens": [50840, 574, 510, 412, 437, 264, 17138, 1639, 2657, 767, 1542, 411, 11, 321, 393, 4482, 484, 527, 38154, 1918, 293, 51108], "temperature": 0.0, "avg_logprob": -0.11491284753284316, "compression_ratio": 1.9, "no_speech_prob": 0.04885052144527435}, {"id": 101, "seek": 46800, "start": 482.88, "end": 487.08, "text": " notice here that I get an iter tools dot cycle object, which is an iterator. And we know", "tokens": [51108, 3449, 510, 300, 286, 483, 364, 17138, 3873, 5893, 6586, 2657, 11, 597, 307, 364, 17138, 1639, 13, 400, 321, 458, 51318], "temperature": 0.0, "avg_logprob": -0.11491284753284316, "compression_ratio": 1.9, "no_speech_prob": 0.04885052144527435}, {"id": 102, "seek": 46800, "start": 487.08, "end": 491.64, "text": " it's an iterator because it has this next method, which I can manually call using the", "tokens": [51318, 309, 311, 364, 17138, 1639, 570, 309, 575, 341, 958, 3170, 11, 597, 286, 393, 16945, 818, 1228, 264, 51546], "temperature": 0.0, "avg_logprob": -0.11491284753284316, "compression_ratio": 1.9, "no_speech_prob": 0.04885052144527435}, {"id": 103, "seek": 46800, "start": 491.64, "end": 495.92, "text": " next function. I also could loop over this using a for loop if I wanted to. So I could", "tokens": [51546, 958, 2445, 13, 286, 611, 727, 6367, 670, 341, 1228, 257, 337, 6367, 498, 286, 1415, 281, 13, 407, 286, 727, 51760], "temperature": 0.0, "avg_logprob": -0.11491284753284316, "compression_ratio": 1.9, "no_speech_prob": 0.04885052144527435}, {"id": 104, "seek": 49592, "start": 495.96000000000004, "end": 501.56, "text": " just do something like for I in, and then this would be cycler. However, if I did this,", "tokens": [50366, 445, 360, 746, 411, 337, 286, 294, 11, 293, 550, 341, 576, 312, 38154, 1918, 13, 2908, 11, 498, 286, 630, 341, 11, 50646], "temperature": 0.0, "avg_logprob": -0.09820841360783232, "compression_ratio": 1.7941176470588236, "no_speech_prob": 0.07157891243696213}, {"id": 105, "seek": 49592, "start": 501.56, "end": 506.16, "text": " I would need to implement a manual break condition, because again, that would go infinitely unless", "tokens": [50646, 286, 576, 643, 281, 4445, 257, 9688, 1821, 4188, 11, 570, 797, 11, 300, 576, 352, 36227, 5969, 50876], "temperature": 0.0, "avg_logprob": -0.09820841360783232, "compression_ratio": 1.7941176470588236, "no_speech_prob": 0.07157891243696213}, {"id": 106, "seek": 49592, "start": 506.16, "end": 510.6, "text": " I manually broke it at some point. So that is cycle again, takes in some iterable and", "tokens": [50876, 286, 16945, 6902, 309, 412, 512, 935, 13, 407, 300, 307, 6586, 797, 11, 2516, 294, 512, 17138, 712, 293, 51098], "temperature": 0.0, "avg_logprob": -0.09820841360783232, "compression_ratio": 1.7941176470588236, "no_speech_prob": 0.07157891243696213}, {"id": 107, "seek": 49592, "start": 510.6, "end": 514.48, "text": " allows you to cycle over it as many times as you would like. So the next set of iterators", "tokens": [51098, 4045, 291, 281, 6586, 670, 309, 382, 867, 1413, 382, 291, 576, 411, 13, 407, 264, 958, 992, 295, 17138, 3391, 51292], "temperature": 0.0, "avg_logprob": -0.09820841360783232, "compression_ratio": 1.7941176470588236, "no_speech_prob": 0.07157891243696213}, {"id": 108, "seek": 49592, "start": 514.48, "end": 519.0, "text": " that I'm going to show you are known as terminating iterators. They're not infinite. They do have", "tokens": [51292, 300, 286, 478, 516, 281, 855, 291, 366, 2570, 382, 1433, 8205, 17138, 3391, 13, 814, 434, 406, 13785, 13, 814, 360, 362, 51518], "temperature": 0.0, "avg_logprob": -0.09820841360783232, "compression_ratio": 1.7941176470588236, "no_speech_prob": 0.07157891243696213}, {"id": 109, "seek": 49592, "start": 519.0, "end": 523.24, "text": " a defined number of elements that they will return to you. So the first iterator to look", "tokens": [51518, 257, 7642, 1230, 295, 4959, 300, 436, 486, 2736, 281, 291, 13, 407, 264, 700, 17138, 1639, 281, 574, 51730], "temperature": 0.0, "avg_logprob": -0.09820841360783232, "compression_ratio": 1.7941176470588236, "no_speech_prob": 0.07157891243696213}, {"id": 110, "seek": 52324, "start": 523.24, "end": 527.64, "text": " at here is known as accumulate. And the best example of this is something like a running", "tokens": [50364, 412, 510, 307, 2570, 382, 33384, 13, 400, 264, 1151, 1365, 295, 341, 307, 746, 411, 257, 2614, 50584], "temperature": 0.0, "avg_logprob": -0.1018680263968075, "compression_ratio": 1.875, "no_speech_prob": 0.2172505259513855}, {"id": 111, "seek": 52324, "start": 527.64, "end": 531.64, "text": " sum. So I can say the running sum is equal to accumulate and then accumulate an iterable", "tokens": [50584, 2408, 13, 407, 286, 393, 584, 264, 2614, 2408, 307, 2681, 281, 33384, 293, 550, 33384, 364, 17138, 712, 50784], "temperature": 0.0, "avg_logprob": -0.1018680263968075, "compression_ratio": 1.875, "no_speech_prob": 0.2172505259513855}, {"id": 112, "seek": 52324, "start": 531.64, "end": 536.12, "text": " object in this case, a bunch of integers. And what this does is give me the sum of all", "tokens": [50784, 2657, 294, 341, 1389, 11, 257, 3840, 295, 41674, 13, 400, 437, 341, 775, 307, 976, 385, 264, 2408, 295, 439, 51008], "temperature": 0.0, "avg_logprob": -0.1018680263968075, "compression_ratio": 1.875, "no_speech_prob": 0.2172505259513855}, {"id": 113, "seek": 52324, "start": 536.12, "end": 541.0, "text": " of the elements at the current position and prior in the list. So if I print this out", "tokens": [51008, 295, 264, 4959, 412, 264, 2190, 2535, 293, 4059, 294, 264, 1329, 13, 407, 498, 286, 4482, 341, 484, 51252], "temperature": 0.0, "avg_logprob": -0.1018680263968075, "compression_ratio": 1.875, "no_speech_prob": 0.2172505259513855}, {"id": 114, "seek": 52324, "start": 541.0, "end": 544.84, "text": " here, you see we get one, three, six, 10, so on and so forth. So the first element is", "tokens": [51252, 510, 11, 291, 536, 321, 483, 472, 11, 1045, 11, 2309, 11, 1266, 11, 370, 322, 293, 370, 5220, 13, 407, 264, 700, 4478, 307, 51444], "temperature": 0.0, "avg_logprob": -0.1018680263968075, "compression_ratio": 1.875, "no_speech_prob": 0.2172505259513855}, {"id": 115, "seek": 52324, "start": 544.84, "end": 549.48, "text": " the sum of just the first element, which is one second is the sum of these two elements.", "tokens": [51444, 264, 2408, 295, 445, 264, 700, 4478, 11, 597, 307, 472, 1150, 307, 264, 2408, 295, 613, 732, 4959, 13, 51676], "temperature": 0.0, "avg_logprob": -0.1018680263968075, "compression_ratio": 1.875, "no_speech_prob": 0.2172505259513855}, {"id": 116, "seek": 54948, "start": 549.48, "end": 553.72, "text": " The third is some of these three elements, so on until you get to the very end. And one", "tokens": [50364, 440, 2636, 307, 512, 295, 613, 1045, 4959, 11, 370, 322, 1826, 291, 483, 281, 264, 588, 917, 13, 400, 472, 50576], "temperature": 0.0, "avg_logprob": -0.11089777392010357, "compression_ratio": 1.7412140575079873, "no_speech_prob": 0.2941589057445526}, {"id": 117, "seek": 54948, "start": 553.72, "end": 558.08, "text": " thing to note here about this is that you've probably implemented this behavior by yourself", "tokens": [50576, 551, 281, 3637, 510, 466, 341, 307, 300, 291, 600, 1391, 12270, 341, 5223, 538, 1803, 50794], "temperature": 0.0, "avg_logprob": -0.11089777392010357, "compression_ratio": 1.7412140575079873, "no_speech_prob": 0.2941589057445526}, {"id": 118, "seek": 54948, "start": 558.08, "end": 563.08, "text": " in Python before. This will be much more memory efficient as well as faster than if you were", "tokens": [50794, 294, 15329, 949, 13, 639, 486, 312, 709, 544, 4675, 7148, 382, 731, 382, 4663, 813, 498, 291, 645, 51044], "temperature": 0.0, "avg_logprob": -0.11089777392010357, "compression_ratio": 1.7412140575079873, "no_speech_prob": 0.2941589057445526}, {"id": 119, "seek": 54948, "start": 563.08, "end": 567.4, "text": " just to write this story with your own for loop. And again, the reason for this is it's", "tokens": [51044, 445, 281, 2464, 341, 1657, 365, 428, 1065, 337, 6367, 13, 400, 797, 11, 264, 1778, 337, 341, 307, 309, 311, 51260], "temperature": 0.0, "avg_logprob": -0.11089777392010357, "compression_ratio": 1.7412140575079873, "no_speech_prob": 0.2941589057445526}, {"id": 120, "seek": 54948, "start": 567.4, "end": 572.16, "text": " going to use the generator syntax. It's actually only going to give you these values when you", "tokens": [51260, 516, 281, 764, 264, 19265, 28431, 13, 467, 311, 767, 787, 516, 281, 976, 291, 613, 4190, 562, 291, 51498], "temperature": 0.0, "avg_logprob": -0.11089777392010357, "compression_ratio": 1.7412140575079873, "no_speech_prob": 0.2941589057445526}, {"id": 121, "seek": 54948, "start": 572.16, "end": 577.16, "text": " request them. It's not going to be storing them in memory and taking up unnecessary space.", "tokens": [51498, 5308, 552, 13, 467, 311, 406, 516, 281, 312, 26085, 552, 294, 4675, 293, 1940, 493, 19350, 1901, 13, 51748], "temperature": 0.0, "avg_logprob": -0.11089777392010357, "compression_ratio": 1.7412140575079873, "no_speech_prob": 0.2941589057445526}, {"id": 122, "seek": 57716, "start": 577.1999999999999, "end": 580.16, "text": " One other thing to note here is that whenever you're looking at an iterator, so in this", "tokens": [50366, 1485, 661, 551, 281, 3637, 510, 307, 300, 5699, 291, 434, 1237, 412, 364, 17138, 1639, 11, 370, 294, 341, 50514], "temperature": 0.0, "avg_logprob": -0.12322190689713988, "compression_ratio": 1.7894736842105263, "no_speech_prob": 0.15199533104896545}, {"id": 123, "seek": 57716, "start": 580.16, "end": 584.36, "text": " case, we have accumulate, we can call the list function on it directly, and that will", "tokens": [50514, 1389, 11, 321, 362, 33384, 11, 321, 393, 818, 264, 1329, 2445, 322, 309, 3838, 11, 293, 300, 486, 50724], "temperature": 0.0, "avg_logprob": -0.12322190689713988, "compression_ratio": 1.7894736842105263, "no_speech_prob": 0.15199533104896545}, {"id": 124, "seek": 57716, "start": 584.36, "end": 589.04, "text": " run the next method on the iterator until there's no more elements left and just collect", "tokens": [50724, 1190, 264, 958, 3170, 322, 264, 17138, 1639, 1826, 456, 311, 572, 544, 4959, 1411, 293, 445, 2500, 50958], "temperature": 0.0, "avg_logprob": -0.12322190689713988, "compression_ratio": 1.7894736842105263, "no_speech_prob": 0.15199533104896545}, {"id": 125, "seek": 57716, "start": 589.04, "end": 592.76, "text": " all of those values in a list. So rather than manually looping through this, using a for", "tokens": [50958, 439, 295, 729, 4190, 294, 257, 1329, 13, 407, 2831, 813, 16945, 6367, 278, 807, 341, 11, 1228, 257, 337, 51144], "temperature": 0.0, "avg_logprob": -0.12322190689713988, "compression_ratio": 1.7894736842105263, "no_speech_prob": 0.15199533104896545}, {"id": 126, "seek": 57716, "start": 592.76, "end": 597.24, "text": " loop or calling the next method ourselves, we're just using lists now to quickly grab", "tokens": [51144, 6367, 420, 5141, 264, 958, 3170, 4175, 11, 321, 434, 445, 1228, 14511, 586, 281, 2661, 4444, 51368], "temperature": 0.0, "avg_logprob": -0.12322190689713988, "compression_ratio": 1.7894736842105263, "no_speech_prob": 0.15199533104896545}, {"id": 127, "seek": 57716, "start": 597.24, "end": 602.04, "text": " the results of the iterate. Hopefully that makes sense. That is accumulate. So the next", "tokens": [51368, 264, 3542, 295, 264, 44497, 13, 10429, 300, 1669, 2020, 13, 663, 307, 33384, 13, 407, 264, 958, 51608], "temperature": 0.0, "avg_logprob": -0.12322190689713988, "compression_ratio": 1.7894736842105263, "no_speech_prob": 0.15199533104896545}, {"id": 128, "seek": 57716, "start": 602.04, "end": 605.8, "text": " iterator to show you is known as chain. This is very straightforward. It simply chains", "tokens": [51608, 17138, 1639, 281, 855, 291, 307, 2570, 382, 5021, 13, 639, 307, 588, 15325, 13, 467, 2935, 12626, 51796], "temperature": 0.0, "avg_logprob": -0.12322190689713988, "compression_ratio": 1.7894736842105263, "no_speech_prob": 0.15199533104896545}, {"id": 129, "seek": 60580, "start": 605.8399999999999, "end": 610.8399999999999, "text": " two iterable objects together. If I run this code, you can see that we get ABC and then", "tokens": [50366, 732, 17138, 712, 6565, 1214, 13, 759, 286, 1190, 341, 3089, 11, 291, 393, 536, 300, 321, 483, 22342, 293, 550, 50616], "temperature": 0.0, "avg_logprob": -0.15806452897343323, "compression_ratio": 1.830564784053156, "no_speech_prob": 0.044674020260572433}, {"id": 130, "seek": 60580, "start": 610.8399999999999, "end": 615.88, "text": " D E F where the first iterable was this string and the second iterable was this one. Again,", "tokens": [50616, 413, 462, 479, 689, 264, 700, 17138, 712, 390, 341, 6798, 293, 264, 1150, 17138, 712, 390, 341, 472, 13, 3764, 11, 50868], "temperature": 0.0, "avg_logprob": -0.15806452897343323, "compression_ratio": 1.830564784053156, "no_speech_prob": 0.044674020260572433}, {"id": 131, "seek": 60580, "start": 615.88, "end": 619.76, "text": " this is going to be more performance and memory efficient than if you were to try to implement", "tokens": [50868, 341, 307, 516, 281, 312, 544, 3389, 293, 4675, 7148, 813, 498, 291, 645, 281, 853, 281, 4445, 51062], "temperature": 0.0, "avg_logprob": -0.15806452897343323, "compression_ratio": 1.830564784053156, "no_speech_prob": 0.044674020260572433}, {"id": 132, "seek": 60580, "start": 619.76, "end": 624.28, "text": " this behavior on your own and say, can coordinate two lists together. This is not concatenating", "tokens": [51062, 341, 5223, 322, 428, 1065, 293, 584, 11, 393, 15670, 732, 14511, 1214, 13, 639, 307, 406, 1588, 7186, 990, 51288], "temperature": 0.0, "avg_logprob": -0.15806452897343323, "compression_ratio": 1.830564784053156, "no_speech_prob": 0.044674020260572433}, {"id": 133, "seek": 60580, "start": 624.28, "end": 629.3599999999999, "text": " to list. It is returning to an iterator that allows you to retrieve one element at a time", "tokens": [51288, 281, 1329, 13, 467, 307, 12678, 281, 364, 17138, 1639, 300, 4045, 291, 281, 30254, 472, 4478, 412, 257, 565, 51542], "temperature": 0.0, "avg_logprob": -0.15806452897343323, "compression_ratio": 1.830564784053156, "no_speech_prob": 0.044674020260572433}, {"id": 134, "seek": 60580, "start": 629.3599999999999, "end": 633.76, "text": " and process and use that as you need to. That is the point of the iterators is that you're", "tokens": [51542, 293, 1399, 293, 764, 300, 382, 291, 643, 281, 13, 663, 307, 264, 935, 295, 264, 17138, 3391, 307, 300, 291, 434, 51762], "temperature": 0.0, "avg_logprob": -0.15806452897343323, "compression_ratio": 1.830564784053156, "no_speech_prob": 0.044674020260572433}, {"id": 135, "seek": 63376, "start": 633.76, "end": 638.48, "text": " not storing everything in memory. You're grabbing one individual element at a time", "tokens": [50364, 406, 26085, 1203, 294, 4675, 13, 509, 434, 23771, 472, 2609, 4478, 412, 257, 565, 50600], "temperature": 0.0, "avg_logprob": -0.09859224408864975, "compression_ratio": 1.7661016949152541, "no_speech_prob": 0.009708104655146599}, {"id": 136, "seek": 63376, "start": 638.48, "end": 643.56, "text": " and using it as you need to be as opposed to storing everything in memory when you only", "tokens": [50600, 293, 1228, 309, 382, 291, 643, 281, 312, 382, 8851, 281, 26085, 1203, 294, 4675, 562, 291, 787, 50854], "temperature": 0.0, "avg_logprob": -0.09859224408864975, "compression_ratio": 1.7661016949152541, "no_speech_prob": 0.009708104655146599}, {"id": 137, "seek": 63376, "start": 643.56, "end": 647.0, "text": " need the current element in the sequence. Hopefully that makes a bit of sense. Let's", "tokens": [50854, 643, 264, 2190, 4478, 294, 264, 8310, 13, 10429, 300, 1669, 257, 857, 295, 2020, 13, 961, 311, 51026], "temperature": 0.0, "avg_logprob": -0.09859224408864975, "compression_ratio": 1.7661016949152541, "no_speech_prob": 0.009708104655146599}, {"id": 138, "seek": 63376, "start": 647.0, "end": 651.08, "text": " move on to the next example. The next example is very similar to the first one, but this", "tokens": [51026, 1286, 322, 281, 264, 958, 1365, 13, 440, 958, 1365, 307, 588, 2531, 281, 264, 700, 472, 11, 457, 341, 51230], "temperature": 0.0, "avg_logprob": -0.09859224408864975, "compression_ratio": 1.7661016949152541, "no_speech_prob": 0.009708104655146599}, {"id": 139, "seek": 63376, "start": 651.08, "end": 655.52, "text": " is chain from iterable. Now, let's just have a look at what this does when we pass in a", "tokens": [51230, 307, 5021, 490, 17138, 712, 13, 823, 11, 718, 311, 445, 362, 257, 574, 412, 437, 341, 775, 562, 321, 1320, 294, 257, 51452], "temperature": 0.0, "avg_logprob": -0.09859224408864975, "compression_ratio": 1.7661016949152541, "no_speech_prob": 0.009708104655146599}, {"id": 140, "seek": 63376, "start": 655.52, "end": 660.8, "text": " nested list. So notice here that I actually get this list. So this is something that you", "tokens": [51452, 15646, 292, 1329, 13, 407, 3449, 510, 300, 286, 767, 483, 341, 1329, 13, 407, 341, 307, 746, 300, 291, 51716], "temperature": 0.0, "avg_logprob": -0.09859224408864975, "compression_ratio": 1.7661016949152541, "no_speech_prob": 0.009708104655146599}, {"id": 141, "seek": 66080, "start": 660.8399999999999, "end": 665.68, "text": " can do with the chain from iterable, pass in some type of nested structure, and it will", "tokens": [50366, 393, 360, 365, 264, 5021, 490, 17138, 712, 11, 1320, 294, 512, 2010, 295, 15646, 292, 3877, 11, 293, 309, 486, 50608], "temperature": 0.0, "avg_logprob": -0.12992395318072775, "compression_ratio": 1.8072289156626506, "no_speech_prob": 0.017985377460718155}, {"id": 142, "seek": 66080, "start": 665.68, "end": 671.56, "text": " actually flatten that structure for you by chaining all of the elements that are inside", "tokens": [50608, 767, 24183, 300, 3877, 337, 291, 538, 417, 3686, 439, 295, 264, 4959, 300, 366, 1854, 50902], "temperature": 0.0, "avg_logprob": -0.12992395318072775, "compression_ratio": 1.8072289156626506, "no_speech_prob": 0.017985377460718155}, {"id": 143, "seek": 66080, "start": 671.56, "end": 677.3199999999999, "text": " of this iterable object. Next, we'll move on to compress. As I was saying, the next", "tokens": [50902, 295, 341, 17138, 712, 2657, 13, 3087, 11, 321, 603, 1286, 322, 281, 14778, 13, 1018, 286, 390, 1566, 11, 264, 958, 51190], "temperature": 0.0, "avg_logprob": -0.12992395318072775, "compression_ratio": 1.8072289156626506, "no_speech_prob": 0.017985377460718155}, {"id": 144, "seek": 66080, "start": 677.3199999999999, "end": 682.16, "text": " iterator that we have here is known as compress. Now, what this does is take in some data source", "tokens": [51190, 17138, 1639, 300, 321, 362, 510, 307, 2570, 382, 14778, 13, 823, 11, 437, 341, 775, 307, 747, 294, 512, 1412, 4009, 51432], "temperature": 0.0, "avg_logprob": -0.12992395318072775, "compression_ratio": 1.8072289156626506, "no_speech_prob": 0.017985377460718155}, {"id": 145, "seek": 66080, "start": 682.16, "end": 687.68, "text": " as well as some selectors, and it simply keeps all of the items that are inside of this data.", "tokens": [51432, 382, 731, 382, 512, 3048, 830, 11, 293, 309, 2935, 5965, 439, 295, 264, 4754, 300, 366, 1854, 295, 341, 1412, 13, 51708], "temperature": 0.0, "avg_logprob": -0.12992395318072775, "compression_ratio": 1.8072289156626506, "no_speech_prob": 0.017985377460718155}, {"id": 146, "seek": 68768, "start": 687.68, "end": 692.52, "text": " If the corresponding item in the selector is true. So in this case, I have a nested", "tokens": [50364, 759, 264, 11760, 3174, 294, 264, 23264, 1672, 307, 2074, 13, 407, 294, 341, 1389, 11, 286, 362, 257, 15646, 292, 50606], "temperature": 0.0, "avg_logprob": -0.14354325879004695, "compression_ratio": 1.7333333333333334, "no_speech_prob": 0.04467470943927765}, {"id": 147, "seek": 68768, "start": 692.52, "end": 698.92, "text": " structure that has three elements. So this, this, and this, then I pass in an array here,", "tokens": [50606, 3877, 300, 575, 1045, 4959, 13, 407, 341, 11, 341, 11, 293, 341, 11, 550, 286, 1320, 294, 364, 10225, 510, 11, 50926], "temperature": 0.0, "avg_logprob": -0.14354325879004695, "compression_ratio": 1.7333333333333334, "no_speech_prob": 0.04467470943927765}, {"id": 148, "seek": 68768, "start": 698.92, "end": 703.28, "text": " I guess, sorry, a list that contains Booleans. Now, true indicates that we're going to keep", "tokens": [50926, 286, 2041, 11, 2597, 11, 257, 1329, 300, 8306, 23351, 24008, 13, 823, 11, 2074, 16203, 300, 321, 434, 516, 281, 1066, 51144], "temperature": 0.0, "avg_logprob": -0.14354325879004695, "compression_ratio": 1.7333333333333334, "no_speech_prob": 0.04467470943927765}, {"id": 149, "seek": 68768, "start": 703.28, "end": 706.92, "text": " an element. False means we are not going to keep it. So if I run this, you'll see that", "tokens": [51144, 364, 4478, 13, 50040, 1355, 321, 366, 406, 516, 281, 1066, 309, 13, 407, 498, 286, 1190, 341, 11, 291, 603, 536, 300, 51326], "temperature": 0.0, "avg_logprob": -0.14354325879004695, "compression_ratio": 1.7333333333333334, "no_speech_prob": 0.04467470943927765}, {"id": 150, "seek": 68768, "start": 706.92, "end": 714.28, "text": " we only keep a BNC because true was here for the first element. Now, if I make this true,", "tokens": [51326, 321, 787, 1066, 257, 363, 45, 34, 570, 2074, 390, 510, 337, 264, 700, 4478, 13, 823, 11, 498, 286, 652, 341, 2074, 11, 51694], "temperature": 0.0, "avg_logprob": -0.14354325879004695, "compression_ratio": 1.7333333333333334, "no_speech_prob": 0.04467470943927765}, {"id": 151, "seek": 71428, "start": 714.28, "end": 717.8399999999999, "text": " you'll see that now we get the second element as well. And I could alternatively change", "tokens": [50364, 291, 603, 536, 300, 586, 321, 483, 264, 1150, 4478, 382, 731, 13, 400, 286, 727, 8535, 356, 1319, 50542], "temperature": 0.0, "avg_logprob": -0.13091116982537346, "compression_ratio": 1.7639344262295082, "no_speech_prob": 0.5923828482627869}, {"id": 152, "seek": 71428, "start": 717.8399999999999, "end": 722.8, "text": " these to be anything that returns a truthy value. So I could put, say, zero and one,", "tokens": [50542, 613, 281, 312, 1340, 300, 11247, 257, 3494, 88, 2158, 13, 407, 286, 727, 829, 11, 584, 11, 4018, 293, 472, 11, 50790], "temperature": 0.0, "avg_logprob": -0.13091116982537346, "compression_ratio": 1.7639344262295082, "no_speech_prob": 0.5923828482627869}, {"id": 153, "seek": 71428, "start": 722.8, "end": 727.04, "text": " and this would work as well. Moving on, we have the pairwise function. This one is cool.", "tokens": [50790, 293, 341, 576, 589, 382, 731, 13, 14242, 322, 11, 321, 362, 264, 6119, 3711, 2445, 13, 639, 472, 307, 1627, 13, 51002], "temperature": 0.0, "avg_logprob": -0.13091116982537346, "compression_ratio": 1.7639344262295082, "no_speech_prob": 0.5923828482627869}, {"id": 154, "seek": 71428, "start": 727.04, "end": 731.24, "text": " It's simply going to pair all of the adjacent elements in our iterable. So let's run this", "tokens": [51002, 467, 311, 2935, 516, 281, 6119, 439, 295, 264, 24441, 4959, 294, 527, 17138, 712, 13, 407, 718, 311, 1190, 341, 51212], "temperature": 0.0, "avg_logprob": -0.13091116982537346, "compression_ratio": 1.7639344262295082, "no_speech_prob": 0.5923828482627869}, {"id": 155, "seek": 71428, "start": 731.24, "end": 736.8, "text": " and have a look and notice we get one, two, two, three, three, four, so on and so forth.", "tokens": [51212, 293, 362, 257, 574, 293, 3449, 321, 483, 472, 11, 732, 11, 732, 11, 1045, 11, 1045, 11, 1451, 11, 370, 322, 293, 370, 5220, 13, 51490], "temperature": 0.0, "avg_logprob": -0.13091116982537346, "compression_ratio": 1.7639344262295082, "no_speech_prob": 0.5923828482627869}, {"id": 156, "seek": 71428, "start": 736.8, "end": 741.36, "text": " Moving on, the next set of iterators I'm going to show you are known as combinatoronic iterators.", "tokens": [51490, 14242, 322, 11, 264, 958, 992, 295, 17138, 3391, 286, 478, 516, 281, 855, 291, 366, 2570, 382, 2512, 31927, 11630, 17138, 3391, 13, 51718], "temperature": 0.0, "avg_logprob": -0.13091116982537346, "compression_ratio": 1.7639344262295082, "no_speech_prob": 0.5923828482627869}, {"id": 157, "seek": 74136, "start": 741.36, "end": 745.4, "text": " Now the first one to have a look at here is a product. Now what the product is going", "tokens": [50364, 823, 264, 700, 472, 281, 362, 257, 574, 412, 510, 307, 257, 1674, 13, 823, 437, 264, 1674, 307, 516, 50566], "temperature": 0.0, "avg_logprob": -0.12418608469505833, "compression_ratio": 1.8206896551724139, "no_speech_prob": 0.03209853917360306}, {"id": 158, "seek": 74136, "start": 745.4, "end": 750.16, "text": " to do is return the Cartesian product of two iterable objects. Now this would be equivalent", "tokens": [50566, 281, 360, 307, 2736, 264, 22478, 42434, 1674, 295, 732, 17138, 712, 6565, 13, 823, 341, 576, 312, 10344, 50804], "temperature": 0.0, "avg_logprob": -0.12418608469505833, "compression_ratio": 1.8206896551724139, "no_speech_prob": 0.03209853917360306}, {"id": 159, "seek": 74136, "start": 750.16, "end": 754.92, "text": " to kind of a nested for loop looping through every single possible pair of the items in", "tokens": [50804, 281, 733, 295, 257, 15646, 292, 337, 6367, 6367, 278, 807, 633, 2167, 1944, 6119, 295, 264, 4754, 294, 51042], "temperature": 0.0, "avg_logprob": -0.12418608469505833, "compression_ratio": 1.8206896551724139, "no_speech_prob": 0.03209853917360306}, {"id": 160, "seek": 74136, "start": 754.92, "end": 759.24, "text": " iterable one and iterable two. So let's have a look here when I print this out. Notice", "tokens": [51042, 17138, 712, 472, 293, 17138, 712, 732, 13, 407, 718, 311, 362, 257, 574, 510, 562, 286, 4482, 341, 484, 13, 13428, 51258], "temperature": 0.0, "avg_logprob": -0.12418608469505833, "compression_ratio": 1.8206896551724139, "no_speech_prob": 0.03209853917360306}, {"id": 161, "seek": 74136, "start": 759.24, "end": 765.36, "text": " I get one A, one B, one C, two A, two B, two C, three A, three B, three C. That is what", "tokens": [51258, 286, 483, 472, 316, 11, 472, 363, 11, 472, 383, 11, 732, 316, 11, 732, 363, 11, 732, 383, 11, 1045, 316, 11, 1045, 363, 11, 1045, 383, 13, 663, 307, 437, 51564], "temperature": 0.0, "avg_logprob": -0.12418608469505833, "compression_ratio": 1.8206896551724139, "no_speech_prob": 0.03209853917360306}, {"id": 162, "seek": 74136, "start": 765.36, "end": 770.96, "text": " the Cartesian product returns. Moving on, we have the permutations iterator or function,", "tokens": [51564, 264, 22478, 42434, 1674, 11247, 13, 14242, 322, 11, 321, 362, 264, 4784, 325, 763, 17138, 1639, 420, 2445, 11, 51844], "temperature": 0.0, "avg_logprob": -0.12418608469505833, "compression_ratio": 1.8206896551724139, "no_speech_prob": 0.03209853917360306}, {"id": 163, "seek": 77096, "start": 770.96, "end": 775.0400000000001, "text": " whatever you'd like to refer to it as. And what this does is return all of the permutations", "tokens": [50364, 2035, 291, 1116, 411, 281, 2864, 281, 309, 382, 13, 400, 437, 341, 775, 307, 2736, 439, 295, 264, 4784, 325, 763, 50568], "temperature": 0.0, "avg_logprob": -0.11286983991924085, "compression_ratio": 1.7866666666666666, "no_speech_prob": 0.025176307186484337}, {"id": 164, "seek": 77096, "start": 775.0400000000001, "end": 779.96, "text": " of a particular size of an iterable object. So let's just have a look at what this returns.", "tokens": [50568, 295, 257, 1729, 2744, 295, 364, 17138, 712, 2657, 13, 407, 718, 311, 445, 362, 257, 574, 412, 437, 341, 11247, 13, 50814], "temperature": 0.0, "avg_logprob": -0.11286983991924085, "compression_ratio": 1.7866666666666666, "no_speech_prob": 0.025176307186484337}, {"id": 165, "seek": 77096, "start": 779.96, "end": 785.32, "text": " We get A, B, A, C, A, D, B, A, B, C, so on and so forth. And notice the order here is", "tokens": [50814, 492, 483, 316, 11, 363, 11, 316, 11, 383, 11, 316, 11, 413, 11, 363, 11, 316, 11, 363, 11, 383, 11, 370, 322, 293, 370, 5220, 13, 400, 3449, 264, 1668, 510, 307, 51082], "temperature": 0.0, "avg_logprob": -0.11286983991924085, "compression_ratio": 1.7866666666666666, "no_speech_prob": 0.025176307186484337}, {"id": 166, "seek": 77096, "start": 785.32, "end": 790.9200000000001, "text": " important. So something like a BC and CB are different permutations because the C and the", "tokens": [51082, 1021, 13, 407, 746, 411, 257, 14359, 293, 18745, 366, 819, 4784, 325, 763, 570, 264, 383, 293, 264, 51362], "temperature": 0.0, "avg_logprob": -0.11286983991924085, "compression_ratio": 1.7866666666666666, "no_speech_prob": 0.025176307186484337}, {"id": 167, "seek": 77096, "start": 790.9200000000001, "end": 795.0, "text": " B are in a different order. That is not the same as what I'm going to show you next, which", "tokens": [51362, 363, 366, 294, 257, 819, 1668, 13, 663, 307, 406, 264, 912, 382, 437, 286, 478, 516, 281, 855, 291, 958, 11, 597, 51566], "temperature": 0.0, "avg_logprob": -0.11286983991924085, "compression_ratio": 1.7866666666666666, "no_speech_prob": 0.025176307186484337}, {"id": 168, "seek": 77096, "start": 795.0, "end": 800.2, "text": " is combinations. So as I promised, the next function to look at here is combinations.", "tokens": [51566, 307, 21267, 13, 407, 382, 286, 10768, 11, 264, 958, 2445, 281, 574, 412, 510, 307, 21267, 13, 51826], "temperature": 0.0, "avg_logprob": -0.11286983991924085, "compression_ratio": 1.7866666666666666, "no_speech_prob": 0.025176307186484337}, {"id": 169, "seek": 80020, "start": 800.2, "end": 805.08, "text": " This is going to give you all of the combinations of a particular size of an iterable object.", "tokens": [50364, 639, 307, 516, 281, 976, 291, 439, 295, 264, 21267, 295, 257, 1729, 2744, 295, 364, 17138, 712, 2657, 13, 50608], "temperature": 0.0, "avg_logprob": -0.11724744401536547, "compression_ratio": 1.8252032520325203, "no_speech_prob": 0.050323259085416794}, {"id": 170, "seek": 80020, "start": 805.08, "end": 809.44, "text": " So let's have a look at this and notice these are the combinations. Note there is a lot", "tokens": [50608, 407, 718, 311, 362, 257, 574, 412, 341, 293, 3449, 613, 366, 264, 21267, 13, 11633, 456, 307, 257, 688, 50826], "temperature": 0.0, "avg_logprob": -0.11724744401536547, "compression_ratio": 1.8252032520325203, "no_speech_prob": 0.050323259085416794}, {"id": 171, "seek": 80020, "start": 809.44, "end": 814.12, "text": " less combinations than there is permutations. And the reason for that is that the ordering", "tokens": [50826, 1570, 21267, 813, 456, 307, 4784, 325, 763, 13, 400, 264, 1778, 337, 300, 307, 300, 264, 21739, 51060], "temperature": 0.0, "avg_logprob": -0.11724744401536547, "compression_ratio": 1.8252032520325203, "no_speech_prob": 0.050323259085416794}, {"id": 172, "seek": 80020, "start": 814.12, "end": 820.74, "text": " of the elements does not matter in a combination. So AC and CA would be the same combination.", "tokens": [51060, 295, 264, 4959, 775, 406, 1871, 294, 257, 6562, 13, 407, 8157, 293, 22852, 576, 312, 264, 912, 6562, 13, 51391], "temperature": 0.0, "avg_logprob": -0.11724744401536547, "compression_ratio": 1.8252032520325203, "no_speech_prob": 0.050323259085416794}, {"id": 173, "seek": 80020, "start": 820.74, "end": 825.72, "text": " Hence why we're getting less pairs here. Now let's have a look at a size of three.", "tokens": [51391, 22229, 983, 321, 434, 1242, 1570, 15494, 510, 13, 823, 718, 311, 362, 257, 574, 412, 257, 2744, 295, 1045, 13, 51640], "temperature": 0.0, "avg_logprob": -0.11724744401536547, "compression_ratio": 1.8252032520325203, "no_speech_prob": 0.050323259085416794}, {"id": 174, "seek": 82572, "start": 825.76, "end": 830.4, "text": " Notice we're going to have four possible combinations here. If we have a look at four, we're only", "tokens": [50366, 13428, 321, 434, 516, 281, 362, 1451, 1944, 21267, 510, 13, 759, 321, 362, 257, 574, 412, 1451, 11, 321, 434, 787, 50598], "temperature": 0.0, "avg_logprob": -0.11208322154941844, "compression_ratio": 1.8633333333333333, "no_speech_prob": 0.3275850713253021}, {"id": 175, "seek": 82572, "start": 830.4, "end": 834.76, "text": " going to have one combination because there's only one unique combination of A, B, C and", "tokens": [50598, 516, 281, 362, 472, 6562, 570, 456, 311, 787, 472, 3845, 6562, 295, 316, 11, 363, 11, 383, 293, 50816], "temperature": 0.0, "avg_logprob": -0.11208322154941844, "compression_ratio": 1.8633333333333333, "no_speech_prob": 0.3275850713253021}, {"id": 176, "seek": 82572, "start": 834.76, "end": 838.6800000000001, "text": " D. So with that said, I will start wrapping up the video here. I will mention that these", "tokens": [50816, 413, 13, 407, 365, 300, 848, 11, 286, 486, 722, 21993, 493, 264, 960, 510, 13, 286, 486, 2152, 300, 613, 51012], "temperature": 0.0, "avg_logprob": -0.11208322154941844, "compression_ratio": 1.8633333333333333, "no_speech_prob": 0.3275850713253021}, {"id": 177, "seek": 82572, "start": 838.6800000000001, "end": 843.72, "text": " can become very powerful when you start combining them together. So combining, say the combinatoronic", "tokens": [51012, 393, 1813, 588, 4005, 562, 291, 722, 21928, 552, 1214, 13, 407, 21928, 11, 584, 264, 2512, 31927, 11630, 51264], "temperature": 0.0, "avg_logprob": -0.11208322154941844, "compression_ratio": 1.8633333333333333, "no_speech_prob": 0.3275850713253021}, {"id": 178, "seek": 82572, "start": 843.72, "end": 848.4, "text": " iterator is with a terminating iterator, maybe mixing in a map and filter function somewhere", "tokens": [51264, 17138, 1639, 307, 365, 257, 1433, 8205, 17138, 1639, 11, 1310, 11983, 294, 257, 4471, 293, 6608, 2445, 4079, 51498], "temperature": 0.0, "avg_logprob": -0.11208322154941844, "compression_ratio": 1.8633333333333333, "no_speech_prob": 0.3275850713253021}, {"id": 179, "seek": 82572, "start": 848.4, "end": 852.36, "text": " along the line. And there's a bunch of other functions here that I did not show you from", "tokens": [51498, 2051, 264, 1622, 13, 400, 456, 311, 257, 3840, 295, 661, 6828, 510, 300, 286, 630, 406, 855, 291, 490, 51696], "temperature": 0.0, "avg_logprob": -0.11208322154941844, "compression_ratio": 1.8633333333333333, "no_speech_prob": 0.3275850713253021}, {"id": 180, "seek": 85236, "start": 852.36, "end": 856.76, "text": " the iterator module. So feel free to have a look at those from the documentation in", "tokens": [50364, 264, 17138, 1639, 10088, 13, 407, 841, 1737, 281, 362, 257, 574, 412, 729, 490, 264, 14333, 294, 50584], "temperature": 0.0, "avg_logprob": -0.19690972361071357, "compression_ratio": 1.4878048780487805, "no_speech_prob": 0.14800874888896942}, {"id": 181, "seek": 85236, "start": 856.76, "end": 860.5600000000001, "text": " the description. Hopefully you guys found some value from this video. If you did make", "tokens": [50584, 264, 3855, 13, 10429, 291, 1074, 1352, 512, 2158, 490, 341, 960, 13, 759, 291, 630, 652, 50774], "temperature": 0.0, "avg_logprob": -0.19690972361071357, "compression_ratio": 1.4878048780487805, "no_speech_prob": 0.14800874888896942}, {"id": 182, "seek": 85236, "start": 860.5600000000001, "end": 864.08, "text": " sure they like subscribe to the channel and I will see you in another one.", "tokens": [50774, 988, 436, 411, 3022, 281, 264, 2269, 293, 286, 486, 536, 291, 294, 1071, 472, 13, 50950], "temperature": 0.0, "avg_logprob": -0.19690972361071357, "compression_ratio": 1.4878048780487805, "no_speech_prob": 0.14800874888896942}], "language": "en"}