1
00:00:00,000 --> 00:00:12,800
In this video, I'm going to be introducing you to an awesome module in Python called

2
00:00:12,800 --> 00:00:17,800
iter tools. Now this module is indeed magical. And the reason for that is it provides a bunch

3
00:00:17,800 --> 00:00:23,580
of built in functionality, specifically functions for creating iterators for efficient looping.

4
00:00:23,580 --> 00:00:27,560
If I'm just quickly scrolling through here, you can see we have stuff like count, cycle,

5
00:00:27,560 --> 00:00:33,880
repeat, accumulate, chain, chain from iterable, compress, pairwise, star map, product, permutations,

6
00:00:33,880 --> 00:00:38,920
combinations, and a ton of stuff that you've probably done by yourself from scratch, simply

7
00:00:38,920 --> 00:00:43,880
because you did not know the function existed in a built in module called iter tools. So

8
00:00:43,880 --> 00:00:47,120
with that said, let's head over to the code editor and I'll start walking you through

9
00:00:47,120 --> 00:00:51,160
some of the more useful functions from the iter tools module. So the first thing I'm

10
00:00:51,160 --> 00:00:55,200
going to do here is give you a very quick explanation of what an iterator is because

11
00:00:55,200 --> 00:00:59,360
all of the iter tools functions are going to return an iterator object, and we should

12
00:00:59,360 --> 00:01:03,320
probably understand how that works. Now I will mention that if you do have my programming

13
00:01:03,320 --> 00:01:07,560
course, programming expert, then you would already understand iterators, you'd understand

14
00:01:07,560 --> 00:01:12,760
generators, decorators, more advanced programming, object oriented programming and all kinds

15
00:01:12,760 --> 00:01:17,600
of cool features in Python. So if you're interested, check it out from the link in the description,

16
00:01:17,600 --> 00:01:22,360
programming expert.io, you can use discount code Tim. Anyways, what is an iterator?

17
00:01:22,360 --> 00:01:25,840
Well, to demonstrate this to you, let's start by having a look at something known as the

18
00:01:25,840 --> 00:01:30,360
range function. Now we've probably seen this before, but if I do something like R is equal

19
00:01:30,360 --> 00:01:35,840
to range, and then let's go with the range of say one to 10. When I print this out here,

20
00:01:35,840 --> 00:01:41,360
let's have a look and notice I simply get range 110. Now range itself is not an iterator,

21
00:01:41,360 --> 00:01:47,600
but it's known as iterable. Now anything that's iterable simply has an iter method on. So

22
00:01:47,600 --> 00:01:52,360
iter is this function that you can call. And what this does is actually call the corresponding

23
00:01:52,360 --> 00:01:57,560
underscore, underscore, iter, which is on the class that represents this range function.

24
00:01:57,560 --> 00:02:01,280
So I know this is a bit complicated, but on range, there is this underscore underscore

25
00:02:01,280 --> 00:02:06,120
iter function that you can call. When you call that, it returns to you an iterator,

26
00:02:06,120 --> 00:02:11,140
and the iterator is what you iterate over to get all of the values in the range created

27
00:02:11,140 --> 00:02:16,280
by this object. So for example, if I print out the iter of R, you're going to see that

28
00:02:16,280 --> 00:02:21,880
I get a range iterator object. Now this range iterator object is something I can iterate

29
00:02:21,880 --> 00:02:27,040
over. So let's have a look here. Let's just say I is equal to that. And now let's print

30
00:02:27,040 --> 00:02:31,520
out, for example, the list of I when I do this, I get one, two, three, four, five, six,

31
00:02:31,520 --> 00:02:35,400
seven, eight, nine, because this is iterable. So I can use the list function on it. And

32
00:02:35,400 --> 00:02:40,520
it gives me all of the elements in this iterator. However, an iterator is an iterator when

33
00:02:40,520 --> 00:02:45,960
it has an underscore underscore next underscore underscore method. So this method is a special

34
00:02:45,960 --> 00:02:50,720
method that returns to you the next, the value in the iterable sequence. So when I have

35
00:02:50,720 --> 00:02:55,520
a range of one to 10, what I can do is the following. I can print out the next of my

36
00:02:55,520 --> 00:03:00,560
iterator, which is I, and let's print this out a few times. Now, when I do this, notice

37
00:03:00,560 --> 00:03:05,160
I get one, two, and three, right? It's giving me all of the values in my sequence. And then

38
00:03:05,160 --> 00:03:09,440
to go even further, let's have a look at something like this for X in, and then I'm going to

39
00:03:09,440 --> 00:03:13,800
say I, because I can loop through an iterator, right? And I have my iterator I. And when

40
00:03:13,800 --> 00:03:19,640
I start printing X here, let's have a look and notice that I don't get any repeated values.

41
00:03:19,640 --> 00:03:23,520
So I have my one, two, three from all of the next up here. And then when I continue looping

42
00:03:23,520 --> 00:03:27,240
through the iterator, I get four, five, six, seven, eight, nine, because since we've called

43
00:03:27,240 --> 00:03:32,720
the next method manually, we've been moved to the next values in the iterable sequence.

44
00:03:32,720 --> 00:03:36,120
I know this is a little bit confusing if this is the first time that you're seeing it, but

45
00:03:36,120 --> 00:03:40,720
essentially when you have an iterator or something that's iterable, sorry, you can call this

46
00:03:40,720 --> 00:03:45,320
iter function on it. That returns to you an iterator. And then the iterator, you can

47
00:03:45,320 --> 00:03:50,480
call this next function on, and it gives you the next value in the iterator sequence.

48
00:03:50,480 --> 00:03:54,840
You know that you're finished iterating when a specific exception is raised. This exception

49
00:03:54,840 --> 00:04:00,320
is known as stop iteration. And to show you that, let's just print next a bunch of times.

50
00:04:00,320 --> 00:04:05,700
So we only have nine values in our sequence here. So when I print, uh, the next of I more

51
00:04:05,700 --> 00:04:10,400
than nine times, you'll see here that we get a stop iteration exception. Uh, and that tells

52
00:04:10,480 --> 00:04:15,000
us there's no more values in our iterator to be returned. So that was a very high level

53
00:04:15,000 --> 00:04:19,920
overview of iterators and iterable objects. However, you may be interested to know that

54
00:04:19,920 --> 00:04:24,440
when we have a for loop like this, and we're looping through an iterable object, what actually

55
00:04:24,440 --> 00:04:30,400
happens implicitly is you're going to call the iter function or method on this, uh, iterable

56
00:04:30,400 --> 00:04:35,000
object. That's going to return an iterator. And then the for loop is going to continually

57
00:04:35,000 --> 00:04:40,320
call the next method on this iterator until eventually the stop iteration exception

58
00:04:40,320 --> 00:04:44,520
is raised. So once that exception is raised, the for loop knows there's no more objects

59
00:04:44,520 --> 00:04:48,800
to loop through, and it can stop iterating. And the value that you're going to look at

60
00:04:48,800 --> 00:04:54,400
for I here for our iterator variable is going to be equal to whatever that next method returned

61
00:04:54,400 --> 00:04:58,760
at every single step in the iterator. Hopefully that makes a little bit of sense. But again,

62
00:04:58,760 --> 00:05:03,960
we have the next function, we have the iter function, and these are really just mapping

63
00:05:03,960 --> 00:05:12,480
to the dot underscore underscore, uh, next like this and to the dot. And then this is

64
00:05:12,480 --> 00:05:17,720
going to be underscore underscore, iter underscore underscore method. So anything that is iterable

65
00:05:17,720 --> 00:05:22,040
has this iter method and anything that is an iterator has this next method. And when

66
00:05:22,040 --> 00:05:26,560
you use the next function and the iter function, you're just calling these methods on those

67
00:05:26,560 --> 00:05:31,320
objects. All right. Hopefully that is clear. Now let's have a look at the iter tools module.

68
00:05:31,320 --> 00:05:34,800
So the first type of functions I'm going to show you from the iter tools module are

69
00:05:34,800 --> 00:05:38,920
known as infinite iterators. And what that means is that they can return an infinite

70
00:05:38,920 --> 00:05:43,640
sequence and they actually do this by using something known as the generator syntax. I'm

71
00:05:43,640 --> 00:05:46,760
not going to explain what a generator is in this video. Again, you could learn that from

72
00:05:46,760 --> 00:05:51,160
something like programming expert. Uh, but for now, let's have a look at the first function,

73
00:05:51,160 --> 00:05:55,960
which is count. So this is an infinite iterator. And the way this works is you pass a start

74
00:05:55,960 --> 00:06:01,160
and an optional step value. If you don't pass a step, this will by default be one. And this

75
00:06:01,200 --> 00:06:05,560
will do exactly what it says. It will simply count a sequence starting at some value and

76
00:06:05,560 --> 00:06:09,760
going up by the step every single time. So if I start at 10, which is what I'm passing

77
00:06:09,760 --> 00:06:14,480
for the start here, and then I have a step of five, we're going to count up by five until

78
00:06:14,480 --> 00:06:19,160
we decide we no longer want to iterate over this iterator. So if I run the code here,

79
00:06:19,160 --> 00:06:23,120
you can see that we get a sequence where we are starting at 10 going up by five and I've

80
00:06:23,120 --> 00:06:27,560
just made it so we manually stop here at a hundred. If I didn't have this break, then

81
00:06:27,640 --> 00:06:32,520
this would happen infinitely because again, this is an infinite sequence. So that is cool.

82
00:06:32,720 --> 00:06:37,040
That is the count function. Now let's move on to the next one. The next function that

83
00:06:37,040 --> 00:06:41,760
I have for you is also an infinite iterator. And this is known as repeat. Now, this is

84
00:06:41,760 --> 00:06:45,360
pretty straightforward, but this is going to take in a element. This element could be

85
00:06:45,360 --> 00:06:49,320
a list. It could be a string. It can be really anything you want. And then the maximum number

86
00:06:49,320 --> 00:06:53,600
of times you'd like to repeat this, this is optional. If you do not pass this, it will

87
00:06:53,640 --> 00:06:58,600
repeat indefinitely. So for here, if I have repeat, and I'm repeating hello, and I say

88
00:06:58,600 --> 00:07:03,280
a maximum of 10 times, then I can loop through this repeater iterator. That's what's going

89
00:07:03,280 --> 00:07:08,040
to be returned here when you call the repeat function up to 10 times and print out the

90
00:07:08,040 --> 00:07:13,000
value. So if I do this, you'll just see that we get 10 hellos showing up on the screen.

91
00:07:13,000 --> 00:07:17,320
So this is useful if you want to repeat something a certain number of times. So the next function

92
00:07:17,320 --> 00:07:21,280
that I have for you is known as cycle. Now, this is pretty straightforward. This is going

93
00:07:21,320 --> 00:07:25,360
to take in some iterable object. It could be a string, could be a tuple, could be a

94
00:07:25,360 --> 00:07:29,560
list, really, whatever you want. And it's going to allow you to cycle over all of the

95
00:07:29,560 --> 00:07:34,080
elements as many times as you would like. Again, these are infinite iterators. So you

96
00:07:34,080 --> 00:07:38,280
have to decide when you want to stop iterating over them. They will continue to generate

97
00:07:38,280 --> 00:07:42,880
a sequence forever. So let's run the code here and have a look at what this does. Notice

98
00:07:42,880 --> 00:07:48,000
that we just cycle through ABCDEF constantly until I have a manual stop here where we've

99
00:07:48,000 --> 00:07:52,520
done this over 100 times. So what I'm actually doing is manually calling the next method

100
00:07:52,520 --> 00:07:57,520
here on my cycler, which is equal to a cycle iterator. And if we want to just have a quick

101
00:07:57,520 --> 00:08:02,880
look here at what the iterator object actually looks like, we can print out our cycler and

102
00:08:02,880 --> 00:08:07,080
notice here that I get an iter tools dot cycle object, which is an iterator. And we know

103
00:08:07,080 --> 00:08:11,640
it's an iterator because it has this next method, which I can manually call using the

104
00:08:11,640 --> 00:08:15,920
next function. I also could loop over this using a for loop if I wanted to. So I could

105
00:08:15,960 --> 00:08:21,560
just do something like for I in, and then this would be cycler. However, if I did this,

106
00:08:21,560 --> 00:08:26,160
I would need to implement a manual break condition, because again, that would go infinitely unless

107
00:08:26,160 --> 00:08:30,600
I manually broke it at some point. So that is cycle again, takes in some iterable and

108
00:08:30,600 --> 00:08:34,480
allows you to cycle over it as many times as you would like. So the next set of iterators

109
00:08:34,480 --> 00:08:39,000
that I'm going to show you are known as terminating iterators. They're not infinite. They do have

110
00:08:39,000 --> 00:08:43,240
a defined number of elements that they will return to you. So the first iterator to look

111
00:08:43,240 --> 00:08:47,640
at here is known as accumulate. And the best example of this is something like a running

112
00:08:47,640 --> 00:08:51,640
sum. So I can say the running sum is equal to accumulate and then accumulate an iterable

113
00:08:51,640 --> 00:08:56,120
object in this case, a bunch of integers. And what this does is give me the sum of all

114
00:08:56,120 --> 00:09:01,000
of the elements at the current position and prior in the list. So if I print this out

115
00:09:01,000 --> 00:09:04,840
here, you see we get one, three, six, 10, so on and so forth. So the first element is

116
00:09:04,840 --> 00:09:09,480
the sum of just the first element, which is one second is the sum of these two elements.

117
00:09:09,480 --> 00:09:13,720
The third is some of these three elements, so on until you get to the very end. And one

118
00:09:13,720 --> 00:09:18,080
thing to note here about this is that you've probably implemented this behavior by yourself

119
00:09:18,080 --> 00:09:23,080
in Python before. This will be much more memory efficient as well as faster than if you were

120
00:09:23,080 --> 00:09:27,400
just to write this story with your own for loop. And again, the reason for this is it's

121
00:09:27,400 --> 00:09:32,160
going to use the generator syntax. It's actually only going to give you these values when you

122
00:09:32,160 --> 00:09:37,160
request them. It's not going to be storing them in memory and taking up unnecessary space.

123
00:09:37,200 --> 00:09:40,160
One other thing to note here is that whenever you're looking at an iterator, so in this

124
00:09:40,160 --> 00:09:44,360
case, we have accumulate, we can call the list function on it directly, and that will

125
00:09:44,360 --> 00:09:49,040
run the next method on the iterator until there's no more elements left and just collect

126
00:09:49,040 --> 00:09:52,760
all of those values in a list. So rather than manually looping through this, using a for

127
00:09:52,760 --> 00:09:57,240
loop or calling the next method ourselves, we're just using lists now to quickly grab

128
00:09:57,240 --> 00:10:02,040
the results of the iterate. Hopefully that makes sense. That is accumulate. So the next

129
00:10:02,040 --> 00:10:05,800
iterator to show you is known as chain. This is very straightforward. It simply chains

130
00:10:05,840 --> 00:10:10,840
two iterable objects together. If I run this code, you can see that we get ABC and then

131
00:10:10,840 --> 00:10:15,880
D E F where the first iterable was this string and the second iterable was this one. Again,

132
00:10:15,880 --> 00:10:19,760
this is going to be more performance and memory efficient than if you were to try to implement

133
00:10:19,760 --> 00:10:24,280
this behavior on your own and say, can coordinate two lists together. This is not concatenating

134
00:10:24,280 --> 00:10:29,360
to list. It is returning to an iterator that allows you to retrieve one element at a time

135
00:10:29,360 --> 00:10:33,760
and process and use that as you need to. That is the point of the iterators is that you're

136
00:10:33,760 --> 00:10:38,480
not storing everything in memory. You're grabbing one individual element at a time

137
00:10:38,480 --> 00:10:43,560
and using it as you need to be as opposed to storing everything in memory when you only

138
00:10:43,560 --> 00:10:47,000
need the current element in the sequence. Hopefully that makes a bit of sense. Let's

139
00:10:47,000 --> 00:10:51,080
move on to the next example. The next example is very similar to the first one, but this

140
00:10:51,080 --> 00:10:55,520
is chain from iterable. Now, let's just have a look at what this does when we pass in a

141
00:10:55,520 --> 00:11:00,800
nested list. So notice here that I actually get this list. So this is something that you

142
00:11:00,840 --> 00:11:05,680
can do with the chain from iterable, pass in some type of nested structure, and it will

143
00:11:05,680 --> 00:11:11,560
actually flatten that structure for you by chaining all of the elements that are inside

144
00:11:11,560 --> 00:11:17,320
of this iterable object. Next, we'll move on to compress. As I was saying, the next

145
00:11:17,320 --> 00:11:22,160
iterator that we have here is known as compress. Now, what this does is take in some data source

146
00:11:22,160 --> 00:11:27,680
as well as some selectors, and it simply keeps all of the items that are inside of this data.

147
00:11:27,680 --> 00:11:32,520
If the corresponding item in the selector is true. So in this case, I have a nested

148
00:11:32,520 --> 00:11:38,920
structure that has three elements. So this, this, and this, then I pass in an array here,

149
00:11:38,920 --> 00:11:43,280
I guess, sorry, a list that contains Booleans. Now, true indicates that we're going to keep

150
00:11:43,280 --> 00:11:46,920
an element. False means we are not going to keep it. So if I run this, you'll see that

151
00:11:46,920 --> 00:11:54,280
we only keep a BNC because true was here for the first element. Now, if I make this true,

152
00:11:54,280 --> 00:11:57,840
you'll see that now we get the second element as well. And I could alternatively change

153
00:11:57,840 --> 00:12:02,800
these to be anything that returns a truthy value. So I could put, say, zero and one,

154
00:12:02,800 --> 00:12:07,040
and this would work as well. Moving on, we have the pairwise function. This one is cool.

155
00:12:07,040 --> 00:12:11,240
It's simply going to pair all of the adjacent elements in our iterable. So let's run this

156
00:12:11,240 --> 00:12:16,800
and have a look and notice we get one, two, two, three, three, four, so on and so forth.

157
00:12:16,800 --> 00:12:21,360
Moving on, the next set of iterators I'm going to show you are known as combinatoronic iterators.

158
00:12:21,360 --> 00:12:25,400
Now the first one to have a look at here is a product. Now what the product is going

159
00:12:25,400 --> 00:12:30,160
to do is return the Cartesian product of two iterable objects. Now this would be equivalent

160
00:12:30,160 --> 00:12:34,920
to kind of a nested for loop looping through every single possible pair of the items in

161
00:12:34,920 --> 00:12:39,240
iterable one and iterable two. So let's have a look here when I print this out. Notice

162
00:12:39,240 --> 00:12:45,360
I get one A, one B, one C, two A, two B, two C, three A, three B, three C. That is what

163
00:12:45,360 --> 00:12:50,960
the Cartesian product returns. Moving on, we have the permutations iterator or function,

164
00:12:50,960 --> 00:12:55,040
whatever you'd like to refer to it as. And what this does is return all of the permutations

165
00:12:55,040 --> 00:12:59,960
of a particular size of an iterable object. So let's just have a look at what this returns.

166
00:12:59,960 --> 00:13:05,320
We get A, B, A, C, A, D, B, A, B, C, so on and so forth. And notice the order here is

167
00:13:05,320 --> 00:13:10,920
important. So something like a BC and CB are different permutations because the C and the

168
00:13:10,920 --> 00:13:15,000
B are in a different order. That is not the same as what I'm going to show you next, which

169
00:13:15,000 --> 00:13:20,200
is combinations. So as I promised, the next function to look at here is combinations.

170
00:13:20,200 --> 00:13:25,080
This is going to give you all of the combinations of a particular size of an iterable object.

171
00:13:25,080 --> 00:13:29,440
So let's have a look at this and notice these are the combinations. Note there is a lot

172
00:13:29,440 --> 00:13:34,120
less combinations than there is permutations. And the reason for that is that the ordering

173
00:13:34,120 --> 00:13:40,740
of the elements does not matter in a combination. So AC and CA would be the same combination.

174
00:13:40,740 --> 00:13:45,720
Hence why we're getting less pairs here. Now let's have a look at a size of three.

175
00:13:45,760 --> 00:13:50,400
Notice we're going to have four possible combinations here. If we have a look at four, we're only

176
00:13:50,400 --> 00:13:54,760
going to have one combination because there's only one unique combination of A, B, C and

177
00:13:54,760 --> 00:13:58,680
D. So with that said, I will start wrapping up the video here. I will mention that these

178
00:13:58,680 --> 00:14:03,720
can become very powerful when you start combining them together. So combining, say the combinatoronic

179
00:14:03,720 --> 00:14:08,400
iterator is with a terminating iterator, maybe mixing in a map and filter function somewhere

180
00:14:08,400 --> 00:14:12,360
along the line. And there's a bunch of other functions here that I did not show you from

181
00:14:12,360 --> 00:14:16,760
the iterator module. So feel free to have a look at those from the documentation in

182
00:14:16,760 --> 00:14:20,560
the description. Hopefully you guys found some value from this video. If you did make

183
00:14:20,560 --> 00:14:24,080
sure they like subscribe to the channel and I will see you in another one.

