WEBVTT

00:00.000 --> 00:20.400
Now, till this point, we have seen the language fundamentals of Python, right?

00:20.400 --> 00:25.080
We have seen variables, how to pass a variable to a function, we have seen function, right?

00:25.080 --> 00:29.680
How to define function, how to call a function, and then we moved towards module and now

00:29.800 --> 00:31.480
we know how to create different files.

00:31.840 --> 00:36.200
Now, once we have talked about the language fundamentals, let's move towards the concepts.

00:36.560 --> 00:41.160
Now, one of the concepts which is very important is, oops, which is object oriented programming.

00:41.520 --> 00:46.920
Now, one of the unique selling point of Python, you know, why Python is so famous because of this thing.

00:47.320 --> 00:51.960
Python supports all different programming paradigm, you know, it supports functional programming,

00:52.120 --> 00:57.400
it supports object oriented programming, and it also works with procedure oriented programming.

00:57.720 --> 01:00.320
Now, we have talked about procedure, right?

01:00.320 --> 01:04.120
What is procedure now is, whenever you work with Python, we define functions, right?

01:04.120 --> 01:05.560
We call a function from a function.

01:05.560 --> 01:09.880
So if you want to create a software, you will break down your project into small, small part,

01:09.880 --> 01:12.600
and those modules, small modules will be functions.

01:12.800 --> 01:15.520
Now, Python is also functional programming.

01:15.520 --> 01:21.120
So functional programming basically means if you can achieve a certain task, implementing functions

01:21.120 --> 01:26.960
as a mathematical functions where you will not manipulate a data, which is instead of changing data,

01:27.000 --> 01:28.720
you will still accomplish a task.

01:28.920 --> 01:33.760
One of the ways you can pass a function to a function, you know, we have seen this, again,

01:33.760 --> 01:37.160
we have a very deep concept of functional programming, we'll talk about that later.

01:37.320 --> 01:42.480
But time being, procedures and functions, which is something we have already done, for example, lambdas.

01:42.840 --> 01:46.200
Now, we are going for a concept of ops.

01:46.200 --> 01:50.200
Now, which is very famous in the industry, you know, so if you are working on big softwares,

01:50.200 --> 01:53.960
enterprise projects, you need to think everything in a format of objects.

01:54.200 --> 01:57.720
Now, you might be thinking why objects, we were happy with functions, right?

01:58.000 --> 02:01.560
Now, see, even from start itself, I was I'm talking about objects, right?

02:01.560 --> 02:04.840
Maybe in some programming, I said, OK, this is an object in teachers, an object.

02:05.120 --> 02:06.800
But then we were skipping that part.

02:06.800 --> 02:09.080
What is object and why it's so important?

02:09.120 --> 02:15.840
See, ultimately, if we talk about programming world, what we do is we try to solve a real world issue

02:16.000 --> 02:18.600
with the help of a virtual world solution, right?

02:18.760 --> 02:21.800
So example, programming softwares, everything is virtual world.

02:22.120 --> 02:24.520
Now, in real world, we all use objects, right?

02:24.520 --> 02:28.160
Example, if I want to record this video, I need a camera, right?

02:28.160 --> 02:29.880
If I want to call someone, I need a phone.

02:29.880 --> 02:32.120
If you want to type a code, you need a laptop, right?

02:32.400 --> 02:35.120
So for everything, you need object.

02:35.520 --> 02:38.160
So in real world, everything is object, in fact, persons, right?

02:38.160 --> 02:42.560
Example, if I have a company, if I want some work to be done, of course, I need employees, right?

02:42.560 --> 02:45.400
And for me, every employee is an object, right?

02:45.640 --> 02:48.480
So an employee object is using a laptop object.

02:48.520 --> 02:51.520
So some employee object needs a AC object, right?

02:51.520 --> 02:52.440
So that's how things work.

02:52.440 --> 02:53.640
Everything is an object.

02:53.640 --> 02:55.880
Even humans, we treat them as object.

02:56.320 --> 02:57.440
Now, what object will have?

02:57.440 --> 02:58.560
Object will have two things.

02:58.800 --> 03:03.000
Every object will have certain attributes and every object will have certain behavior.

03:03.360 --> 03:07.840
Now, when I say attribute, you can imagine them as data, or you can say properties.

03:08.080 --> 03:13.840
Example, my height is one attribute, my age is one attribute, my name is one attribute.

03:14.040 --> 03:16.560
The company I work for is one attribute, right?

03:16.560 --> 03:18.400
Everything is those things that attribute.

03:18.760 --> 03:20.240
And then comes my behavior.

03:20.320 --> 03:22.680
I'm talking, I'm walking, I'm dancing.

03:22.960 --> 03:24.440
All these are behavior, right?

03:24.680 --> 03:27.080
So our actions defines our behavior.

03:27.480 --> 03:30.080
And then we have attributes, which we know.

03:30.480 --> 03:33.320
In other terms, you can say, as an object, I know something.

03:33.320 --> 03:35.080
As an object, I do something, right?

03:35.160 --> 03:38.160
So I do something based on something which I know, right?

03:38.360 --> 03:39.240
So this is object.

03:39.400 --> 03:43.840
Object will have something where you can store data and object will have some behavior.

03:44.080 --> 03:47.040
Now, this data, which we normally use, those are variables, right?

03:47.040 --> 03:48.120
We have same variables.

03:48.320 --> 03:51.920
So if you want to store something, an object, we need to define variables.

03:52.040 --> 03:55.160
If you want to define the behavior, we need to use methods.

03:55.360 --> 03:56.360
Oh, that's something new now.

03:56.360 --> 03:57.040
What is method?

03:57.680 --> 03:58.960
We have done with functions, right?

03:59.160 --> 04:03.880
So functions in object-oriented programming, they're called as methods.

04:04.160 --> 04:04.360
Right?

04:04.360 --> 04:05.000
It's just so simple.

04:05.000 --> 04:06.120
We have done all those stuff.

04:06.120 --> 04:10.200
The only change we have now is we need to think in an object term.

04:10.400 --> 04:13.560
See, object-oriented programming is not just about different syntax.

04:13.560 --> 04:15.080
It's also about the way you think.

04:15.480 --> 04:19.800
So now, if you want to achieve anything in programming, you need to think about objects.

04:19.800 --> 04:23.480
So the moment you say you have a complex problem, think about the object,

04:23.480 --> 04:26.840
think about multiple objects, and how can you connect them, right?

04:27.040 --> 04:29.080
Because in OOPS, we have so many concepts.

04:29.080 --> 04:31.440
One of the concepts is object, which we are going to see now.

04:31.840 --> 04:33.200
We have a concept of classes.

04:33.200 --> 04:37.040
We have a concept of encapsulation, abstraction, polymorphism.

04:37.280 --> 04:38.640
I know weird words, right?

04:38.640 --> 04:42.480
But don't worry, we will be covering everything in detail in the subsequent tutorials.

04:42.920 --> 04:44.920
So there's one thing which is important to discuss here.

04:45.080 --> 04:48.760
About classes, because we have an object and we have a concept of class.

04:48.880 --> 04:53.320
It doesn't matter which language you work on, maybe Java, C++, or C sharp,

04:53.400 --> 04:56.240
whichever whatever language which uses OOPS concept, you know,

04:56.240 --> 04:59.960
we always use this thing, which is object and class together.

05:00.320 --> 05:01.040
But why?

05:01.040 --> 05:02.480
Why they are so important?

05:02.480 --> 05:05.840
Of course, objects are important because whatever you want to do can be done

05:05.840 --> 05:07.360
with the help of object.

05:07.360 --> 05:09.120
But why class is important?

05:09.120 --> 05:10.320
Now, think about this.

05:10.320 --> 05:15.360
When you see an object in real world, for example, this camera, a fan, or a clock,

05:15.560 --> 05:17.800
right, all these things are manufactured, right?

05:17.800 --> 05:20.640
So in some factory, they have been manufactured.

05:20.640 --> 05:21.920
Or maybe you can talk about a phone.

05:21.920 --> 05:22.760
Now, look at this phone.

05:22.760 --> 05:24.120
This is Motorola G3.

05:24.120 --> 05:26.960
OK, now it's not the only phone available here, right?

05:26.960 --> 05:28.400
So a lot of people, they have this phone.

05:28.400 --> 05:31.440
So that means we don't have one object of Moto G3.

05:31.440 --> 05:33.800
We have thousands or millions of objects.

05:33.880 --> 05:35.120
I'm using any number here.

05:35.120 --> 05:39.320
So imagine we have five million of this type of phones, which is Moto G3.

05:39.880 --> 05:42.160
Now, of course, someone must have designed it, right?

05:42.160 --> 05:44.560
And all these phones have been manufactured somewhere.

05:44.560 --> 05:47.840
Maybe maybe you can say all these phones are made in China.

05:47.840 --> 05:52.080
OK, so we have a factory in China who is producing all this phone.

05:52.320 --> 05:54.240
But then Motorola says it is their phone, right?

05:54.240 --> 05:56.280
Of course, we don't say this is a China phone.

05:56.280 --> 05:58.080
We say this is a Motorola phone.

05:58.080 --> 06:00.240
Or we don't say, let's say the manufacturing is in India.

06:00.240 --> 06:02.080
We don't say it's an Indian phone.

06:02.080 --> 06:03.200
We say it's a Motorola phone.

06:03.200 --> 06:04.040
Why?

06:04.040 --> 06:05.880
Because manufacturing is not important.

06:05.880 --> 06:07.640
You can manufacture stuff anywhere.

06:07.960 --> 06:11.280
What is important is where it has been designed.

06:11.280 --> 06:13.360
OK, so this is designed by Motorola.

06:13.760 --> 06:17.800
But even if you talk about this phone, this has been designed once.

06:17.920 --> 06:20.480
And then they have manufactured multiple times.

06:20.800 --> 06:24.440
And that design in programming or in, oops, we say class.

06:24.720 --> 06:27.120
So in a class, you will write a design of the object.

06:27.440 --> 06:30.800
Imagine there's some factory in your machine who will create these objects.

06:30.800 --> 06:34.600
OK, so you have to provide a design so that you will get the object.

06:35.120 --> 06:37.960
So that means class is a design and objects.

06:37.960 --> 06:39.200
They are real stuff, right?

06:39.200 --> 06:41.120
They are real entities, you can say.

06:41.120 --> 06:43.080
Or you can use another term called as instance.

06:43.400 --> 06:46.880
So you can imagine this is an instance of a class.

06:47.600 --> 06:48.760
That's awesome, right?

06:48.760 --> 06:53.200
So point to remember class is a design or you can call them as blueprint.

06:53.720 --> 06:58.200
So if you have a class, you can manufacture thousands of billions of these devices.

06:58.440 --> 06:59.960
So that's about class and object.

07:04.960 --> 07:09.200
In the last video, we have talked about the theory of objects and a class, right?

07:09.560 --> 07:12.480
So of course, before creating an object, you need to create a class, right?

07:12.480 --> 07:14.920
Because class is a design for the object.

07:14.920 --> 07:17.560
And if you don't have a design, how can you build something?

07:17.920 --> 07:23.280
In fact, even before building a tower, you need to create a blueprint of it, right?

07:23.280 --> 07:24.440
And that's the same case here.

07:24.440 --> 07:27.400
So if you want an object, you need to create a class.

07:27.600 --> 07:31.520
So what I'm talking about is, you know, let's say I want to work with computers.

07:31.520 --> 07:32.720
So I'm a person.

07:32.720 --> 07:33.840
I want to work with a computer.

07:33.840 --> 07:36.000
So of course, I want an object of a computer, right?

07:36.000 --> 07:39.000
So let's say I'm a programmer and of course I want to work with a computer.

07:39.280 --> 07:40.520
So I will say comp one.

07:40.520 --> 07:41.960
So this is my computer.

07:41.960 --> 07:45.360
But see, the thing is, till this point, we have worked with integers.

07:45.360 --> 07:47.840
We have worked with float string.

07:48.000 --> 07:50.240
Now, all those are inbuilt types, right?

07:50.320 --> 07:52.160
We don't have any type as computer.

07:52.160 --> 07:53.920
So of course, we need to create our own type.

07:53.920 --> 07:55.840
So we have to get our own class for it.

07:55.840 --> 07:58.480
So if you want to use a computer, you need to define a class here.

07:58.480 --> 08:00.120
So how do we define a class?

08:00.120 --> 08:03.720
The way we define a function is by saying def and function name.

08:04.000 --> 08:07.400
The way we define a class is using a class keyword.

08:07.400 --> 08:10.280
So we have to say class and this class will, of course, have a name.

08:10.560 --> 08:12.800
In this case, I will use a name as computer.

08:12.920 --> 08:14.680
OK, now this is how you define a class.

08:14.680 --> 08:16.560
You have to specify a colon.

08:16.560 --> 08:19.320
Now, after colon, this is your suite, right?

08:19.320 --> 08:21.560
So this is where you will mention your stuff.

08:21.560 --> 08:23.920
Now, what stuff we can put in a class?

08:23.920 --> 08:26.480
Two things. The first thing is the attributes.

08:26.560 --> 08:28.360
The second one is the behavior.

08:28.440 --> 08:30.560
Oh, now, when you say attribute, it is your variables.

08:30.560 --> 08:32.040
OK, the way you create variables.

08:32.040 --> 08:36.080
And the next thing we'll be having here is behavior, which is methods.

08:36.200 --> 08:37.480
What is methods functions?

08:37.480 --> 08:39.600
You know, the functions which we are using from a long time,

08:39.600 --> 08:41.400
but here we call them as methods.

08:41.400 --> 08:42.920
So next time when you are calling a function,

08:42.920 --> 08:46.760
but that function is a part of a class instead of calling them as functions,

08:46.760 --> 08:47.960
we have to say methods, right?

08:47.960 --> 08:50.320
OK, now let's define some methods here.

08:50.320 --> 08:53.080
Now, what I'm talking about, let me get a method here.

08:53.080 --> 08:53.800
I will say def.

08:53.800 --> 08:57.240
I will say config because every machine has a configuration, right?

08:57.240 --> 08:58.280
So I will say config.

08:58.280 --> 09:00.560
We got that self keyword that that's weird.

09:00.560 --> 09:02.360
What is self because I'm not typing it.

09:02.360 --> 09:05.120
OK, so I mean, the moment I say bracket, it says self.

09:05.200 --> 09:06.560
We'll talk about that self later.

09:06.560 --> 09:08.040
But time being, let's keep it there.

09:08.040 --> 09:09.680
You can imagine we don't have any self there.

09:09.680 --> 09:12.200
OK, for time being, imagine we don't have anything like self.

09:12.280 --> 09:15.120
OK, and here we'll say we got a complete class

09:15.120 --> 09:17.520
and then we got a config method or you can say function,

09:17.520 --> 09:21.320
but try to move from that function term to method term.

09:21.560 --> 09:23.400
Right, so we got a method here, which is config.

09:23.400 --> 09:25.880
And here I'm printing the config of this machine.

09:25.880 --> 09:30.760
And I want to say, hey, this is i5 machine with 16 GB RAM,

09:30.760 --> 09:33.560
and it has one data point hudder.

09:33.560 --> 09:36.720
Now, this is very common config now, which we find nowadays, right?

09:36.720 --> 09:37.840
And that's what I'm doing here.

09:37.840 --> 09:39.320
So we got a class computer.

09:39.320 --> 09:41.240
We got a method in that example here.

09:41.240 --> 09:44.600
I'm saying comp one is the object of computer.

09:44.800 --> 09:46.120
But we cannot simply do that, right?

09:46.120 --> 09:48.720
We cannot simply say comp one because no one will understand

09:48.720 --> 09:49.960
what this comp one is.

09:49.960 --> 09:54.240
Example, if I say there's a variable a, what is a type of this variable?

09:54.240 --> 09:57.120
Right now, since in Python, we don't have to

09:57.120 --> 09:59.280
statically mention the type of it.

09:59.280 --> 10:01.840
So what we can do is when you say a equal to 5,

10:01.840 --> 10:04.240
now the type of a becomes integer, right?

10:04.240 --> 10:07.200
If I say a is 5.5, the type of a becomes float.

10:07.200 --> 10:10.400
If I assign a value of string type, if I say 8,

10:10.400 --> 10:12.960
even if that 8 is number, we are putting that in single code, right?

10:12.960 --> 10:14.160
That becomes a string.

10:14.160 --> 10:15.520
What about comp one?

10:15.520 --> 10:17.760
Comp one here, don't have a type.

10:17.760 --> 10:21.600
We have to mention, hey, this comp one is an object of computer.

10:21.680 --> 10:24.720
In that case, you will say equal to computer.

10:24.720 --> 10:26.960
And you have to give this round brackets.

10:26.960 --> 10:29.280
Now, if you are coming from another, you know,

10:29.280 --> 10:32.240
from different programming background like Java, C sharp,

10:32.240 --> 10:34.000
we have a concept of constructor, right?

10:34.000 --> 10:35.440
So these are constructed there.

10:35.440 --> 10:38.160
So this will give you the object of computer.

10:38.160 --> 10:39.280
Now, how do I know that?

10:39.280 --> 10:43.680
If you remember in one of the video, we have talked about a type function, right?

10:43.680 --> 10:45.280
So you can use type function here.

10:45.280 --> 10:46.800
So I will say print.

10:46.800 --> 10:50.400
I will define type, print the type of con one.

10:50.400 --> 10:52.320
Let's see what happens, what it gives you.

10:52.320 --> 10:54.560
So if I run this code, it says, hey, this is a class.

10:54.560 --> 10:56.640
Okay, now we have a different keyword class.

10:56.640 --> 10:59.200
And this belongs to a computer.

10:59.200 --> 10:59.840
That's important.

10:59.840 --> 11:00.320
Okay.

11:00.320 --> 11:01.680
So it gives you the module name.

11:01.680 --> 11:04.720
The module name is main because we are running this code from here.

11:04.720 --> 11:07.360
And then we have a class for this computer.

11:07.360 --> 11:10.080
Now, if you remember, when we work with string as well,

11:10.080 --> 11:11.040
string gives the same thing.

11:11.040 --> 11:14.480
So if I print the type of a, it also says the same thing.

11:14.480 --> 11:15.040
Can you see that?

11:15.040 --> 11:17.040
It says class str, right?

11:17.040 --> 11:19.120
So we are using this concept from a long time,

11:19.120 --> 11:21.200
but this is where we are defining it now.

11:21.200 --> 11:24.480
So string str is also a class, the same way computers are class.

11:24.480 --> 11:27.040
The difference is str is an in-built class.

11:27.040 --> 11:28.240
Computer is our class.

11:28.240 --> 11:28.400
Okay.

11:28.400 --> 11:29.600
That's how you define it.

11:29.600 --> 11:34.720
So you say class, computer, and then we have def config.

11:34.720 --> 11:36.160
In fact, there's one more thing.

11:36.160 --> 11:38.720
If you remember, when we worked with integers,

11:38.720 --> 11:41.360
we have also said that integers are also object.

11:41.360 --> 11:42.160
Let's try it here.

11:42.160 --> 11:43.760
I will say x equal to nine.

11:43.760 --> 11:46.240
And let me print the type of x.

11:46.240 --> 11:47.120
Can you see that?

11:47.120 --> 11:50.480
When I print the type of x, it says class int.

11:50.480 --> 11:54.880
So even this integer, this x, is an object of integer now, right?

11:54.880 --> 11:58.560
So everything is object in Python, right?

11:58.560 --> 12:00.240
So there are some in-built objects,

12:00.240 --> 12:01.760
and there are some objects which we create.

12:01.760 --> 12:04.320
And the way you create your own class is by saying class,

12:04.320 --> 12:05.920
computer, whatever class name.

12:05.920 --> 12:08.000
Make sure that you don't use in-built class name,

12:08.000 --> 12:09.600
because it will give you error, right?

12:09.600 --> 12:11.360
Or maybe you might face some bugs.

12:11.360 --> 12:14.160
So we have, so in a class, we are defining a function config,

12:14.160 --> 12:15.280
and then, oh, not function.

12:15.280 --> 12:18.320
Method front config, and then we are printing just a statement.

12:18.320 --> 12:20.400
Now, question arise, how will you call it?

12:20.400 --> 12:22.880
So let me remove this, all this extra stuff which we are doing.

12:22.880 --> 12:24.560
So we got a class, we got the object.

12:24.560 --> 12:26.400
I want to call that config.

12:26.400 --> 12:27.440
Now, what do you think?

12:27.440 --> 12:28.320
How will you do it?

12:28.320 --> 12:29.520
So normally, when you have a function,

12:29.520 --> 12:30.880
you mentioned the function name, right?

12:30.880 --> 12:32.240
Here in this case, it is config.

12:32.960 --> 12:35.520
But you are getting an error.

12:35.520 --> 12:36.160
Why error?

12:36.160 --> 12:39.360
So if I go back here, it says unresolved reference,

12:39.360 --> 12:40.160
or that's weird.

12:40.160 --> 12:41.280
Why it is giving you unresolved?

12:41.280 --> 12:43.200
Because of course, normally, till this point,

12:43.200 --> 12:46.080
we were mentioning the function as it is, right, open.

12:46.080 --> 12:50.000
But now, we have written that function or a method inside a class.

12:50.000 --> 12:53.200
So in order to access that, we have to mention the class name.

12:53.200 --> 12:55.040
And the class name here is computer.

12:55.040 --> 12:58.080
So we have to say computer.config, important.

12:58.080 --> 12:59.440
So steps, remember the steps.

12:59.440 --> 13:01.840
You have to mention the computer class, which is class name,

13:01.840 --> 13:03.520
and then you have to say config.

13:03.520 --> 13:06.160
So let me repeat, if you want to use a method,

13:06.160 --> 13:08.240
we have to mention a class name first, which is,

13:08.240 --> 13:11.120
I mean, it belongs to computer, and then you have to mention config.

13:11.120 --> 13:14.560
And if I run this code, oh, we got an error.

13:14.560 --> 13:15.360
But why?

13:15.360 --> 13:16.800
See, think about this.

13:16.800 --> 13:18.720
One class can have multiple objects, right?

13:18.720 --> 13:20.560
One object, two object, five objects,

13:20.560 --> 13:22.400
maybe billions of objects, right?

13:22.400 --> 13:25.680
In this case, we are using only one object, which is comp1.

13:25.680 --> 13:28.640
The thing is, this config function or a method

13:28.640 --> 13:32.080
will change its behavior based on the object, right?

13:32.080 --> 13:34.080
Because different objects have a different behavior,

13:34.080 --> 13:35.520
because depending upon what they know,

13:35.520 --> 13:36.960
they have a different behavior.

13:36.960 --> 13:40.000
See, in this case, I'm not depending on any data, right?

13:40.000 --> 13:42.640
But maybe there's a chance that this config

13:42.640 --> 13:44.720
will depend upon some data, and every object

13:44.720 --> 13:46.320
will have its own data, right?

13:46.320 --> 13:47.760
Again, we'll talk about that later.

13:47.760 --> 13:49.360
But every object is different, right?

13:49.360 --> 13:52.400
If I'm calling config, for which object I'm doing that?

13:52.400 --> 13:55.920
So if I say, hey, walk, but whom am I supposed to say walk?

13:55.920 --> 13:58.000
So I have to mention, hey, Ravi, walk.

13:58.000 --> 13:59.440
Hey, Mukesh, walk.

13:59.440 --> 14:00.480
Hey, Kiran, walk.

14:00.480 --> 14:02.400
So I have to mention the names as well, right?

14:02.400 --> 14:04.880
In the same way, when I say computer config,

14:04.880 --> 14:07.600
you have to also mention for which object you're talking about.

14:07.600 --> 14:09.440
And I'm talking about comp1.

14:09.520 --> 14:12.400
So I'm saying, hey, I want the config for comp1.

14:12.400 --> 14:14.240
Now, luckily, we have only one object here,

14:14.240 --> 14:15.200
so there's no confusion.

14:15.200 --> 14:16.640
But let's say if you have thousands of objects,

14:16.640 --> 14:18.560
you have to mention the object name as well.

14:18.560 --> 14:19.840
So we are doing comp1 here.

14:19.840 --> 14:21.360
So if I run this code now,

14:21.360 --> 14:21.920
oh, it works.

14:21.920 --> 14:23.520
You can see that we got the output.

14:23.520 --> 14:27.360
So we are calling config, and we are passing comp1.

14:27.360 --> 14:29.360
And this comp1 is a parameter, right?

14:29.360 --> 14:30.320
It's an argument.

14:30.320 --> 14:33.360
So when you call config, you're passing this comp1

14:33.360 --> 14:35.760
as the argument, and it is going in self.

14:35.760 --> 14:36.640
So what is this self?

14:36.640 --> 14:39.280
Self is the object which you're passing.

14:39.280 --> 14:41.040
Again, this thing will get more clear

14:41.040 --> 14:42.400
once you see further videos, right?

14:42.400 --> 14:43.840
So this is a complex concept

14:43.840 --> 14:45.520
if you are learning UPS for the first time.

14:45.520 --> 14:48.240
But step by step, everything will go inside your brain, okay?

14:48.240 --> 14:49.600
So this is the first layer.

14:49.600 --> 14:50.400
Again, in the next video,

14:50.400 --> 14:51.920
we'll talk about some more layers to it.

14:51.920 --> 14:52.720
We'll add more layers,

14:52.720 --> 14:55.040
and then I will make sure that you'll get everything about it.

14:55.040 --> 14:56.640
Okay, let's create some more objects, okay?

14:56.640 --> 14:59.520
So I will say comp2 is equal to computer, right?

14:59.520 --> 15:01.520
So we got comp1, we got comp2.

15:01.520 --> 15:03.120
So in total, we have two objects,

15:03.120 --> 15:05.040
which is comp1 and comp2.

15:05.040 --> 15:07.040
But we have only one class, which is computer.

15:07.040 --> 15:09.120
If I want to call config for comp2,

15:09.120 --> 15:09.760
what you will do?

15:09.760 --> 15:12.640
You will say computer.config,

15:12.640 --> 15:13.680
and this time you're saying,

15:13.680 --> 15:16.320
hey, I want to call config for comp2.

15:16.320 --> 15:17.840
So in the first instance, I'm saying,

15:17.840 --> 15:19.520
Mukesh, walk, right?

15:19.520 --> 15:21.680
Or I will say, hey, human, walk.

15:21.680 --> 15:23.120
In background, I'm passing Mukesh.

15:23.120 --> 15:24.880
I will say, hey, human, walk.

15:24.880 --> 15:26.880
In background, I'm passing Ravi, right?

15:26.880 --> 15:28.400
In the same way here, I'm saying,

15:28.400 --> 15:30.560
hey, computer, show me a configuration,

15:30.560 --> 15:32.080
and I'm talking about comp1.

15:32.080 --> 15:34.720
Hey, computer, I want your configuration for comp2.

15:34.720 --> 15:36.080
So if I run this code, you can see

15:36.080 --> 15:37.200
we are getting same data,

15:37.200 --> 15:40.000
because at this point, we are not changing data

15:40.000 --> 15:40.960
for different objects.

15:40.960 --> 15:42.000
We can do that later.

15:42.000 --> 15:43.040
So this is one way, right?

15:43.040 --> 15:45.440
If you want to call config, we have another way.

15:45.440 --> 15:47.840
If you think about this, this looks good, right?

15:47.840 --> 15:49.760
This looks clean, because we are saying,

15:49.760 --> 15:52.080
hey, config method belongs to computer,

15:52.080 --> 15:54.800
and then we have to pass the object name, which is comp1.

15:54.800 --> 15:55.680
But there is one more way.

15:55.680 --> 15:58.400
What you can do is you can mention comp1.config.

15:58.400 --> 16:01.920
Now, in this case, you are using the object itself

16:01.920 --> 16:03.440
to call the function.

16:03.440 --> 16:06.000
So you're saying comp1.config.

16:06.080 --> 16:07.840
But the question is, we are not passing it, right?

16:07.840 --> 16:09.760
For example, let's do it for comp2 as well.

16:09.760 --> 16:11.680
I will say comp2.config,

16:11.680 --> 16:12.880
and you can see this time,

16:12.880 --> 16:15.520
I'm not passing anything inside config, and still it works.

16:15.520 --> 16:17.040
So you can see the output, it works.

16:17.040 --> 16:18.560
We got four times the same data,

16:18.560 --> 16:20.880
because the first two is because of these lines,

16:20.880 --> 16:24.000
and the second, next two is because of this line, right?

16:24.000 --> 16:25.040
But why is it working?

16:25.760 --> 16:28.480
It's because this is another behavior of it.

16:28.480 --> 16:32.240
So when you say comp1.config, you are calling config.

16:32.240 --> 16:34.800
See, we are specifying which class it is, right?

16:34.880 --> 16:36.560
So comp1 belongs to computer.

16:36.560 --> 16:38.800
So now we know config belongs to computer.

16:38.800 --> 16:40.880
The moment you say comp1.config,

16:40.880 --> 16:43.360
when you're calling it behind the scene,

16:43.360 --> 16:46.480
this config will take comp1 as a parameter.

16:46.480 --> 16:51.120
So behind the scene, config will take that comp1 as an argument,

16:51.120 --> 16:53.680
and it will pass that in self, okay?

16:53.680 --> 16:56.480
So in most of the code, you will see this type of syntax,

16:56.480 --> 16:57.440
not this one.

16:57.440 --> 17:00.080
But I have done this just to explain you

17:00.080 --> 17:01.760
how this syntax linked like, okay?

17:01.760 --> 17:02.880
So how this exactly works,

17:02.880 --> 17:04.240
but normally we use this syntax.

17:04.240 --> 17:05.200
The second one.

17:05.200 --> 17:07.520
And that's why whatever we have done till now,

17:07.520 --> 17:09.680
example, if I work with a variable of n size,

17:09.680 --> 17:12.960
if I say a equal to five, and if I say a dot,

17:12.960 --> 17:14.320
so whatever function we use here,

17:14.320 --> 17:16.160
example, I want to know the bit length.

17:16.160 --> 17:18.800
Now in this thing, you can see if I say control space,

17:18.800 --> 17:20.720
you know, you can actually see the documentation

17:20.720 --> 17:23.920
by clicking on this control and click on the function name.

17:23.920 --> 17:26.560
So press control and click on the function name.

17:26.560 --> 17:27.840
You can see it takes to the function,

17:27.840 --> 17:30.400
it says bit length self.

17:30.400 --> 17:33.280
So as a definition, it is accepting self,

17:33.280 --> 17:34.640
but when you're passing it,

17:34.640 --> 17:36.640
when you're calling bit length, we're not passing it.

17:36.640 --> 17:38.400
So this a is an object, right?

17:38.400 --> 17:40.400
It goes as a parameter.

17:40.400 --> 17:42.720
So self is the object which you're passing.

17:42.720 --> 17:45.440
We'll discuss more about that once we start with variables

17:45.440 --> 17:47.200
and then attributes, all the stuff.

17:47.200 --> 17:49.200
But time being, this is how you create a class

17:49.200 --> 17:50.400
and that's how you create an object.

17:55.280 --> 17:56.080
Now in the last video,

17:56.080 --> 17:58.160
we have talked about oops concept, right?

17:58.160 --> 18:00.560
We have seen what is object and a class.

18:01.120 --> 18:02.720
Let's explore it more.

18:02.800 --> 18:04.800
Now if you remember, when we talked about objects,

18:04.800 --> 18:06.480
object will be having two stuff, right?

18:06.480 --> 18:08.560
One is it will be having some attributes

18:08.560 --> 18:10.320
and it will also have a behavior.

18:10.320 --> 18:12.560
Now when you say attributes, those are variables, right?

18:12.560 --> 18:14.080
We can create variables.

18:14.080 --> 18:15.920
And behavior is your methods

18:15.920 --> 18:18.640
and then methods are almost same as functions,

18:18.640 --> 18:21.360
but in oops, we call them as methods, right?

18:21.360 --> 18:24.240
Now here, we have to work with methods, right?

18:24.240 --> 18:26.320
We have not worked with variables yet.

18:26.320 --> 18:28.000
So what I will do is just to demonstrate that,

18:28.000 --> 18:29.600
let me just remove this thing here

18:29.600 --> 18:32.080
because we know that we can call config

18:32.080 --> 18:33.440
using the object itself

18:33.440 --> 18:35.120
or we can call it with the help of class

18:35.120 --> 18:36.560
by passing the object.

18:36.560 --> 18:39.280
Now syntactically, we normally go for the second one

18:39.280 --> 18:41.600
which is calling the method from the object.

18:41.600 --> 18:43.440
It makes much more sense, right?

18:43.440 --> 18:44.720
So we'll remove that part.

18:44.720 --> 18:46.320
And so once we got the object,

18:46.320 --> 18:48.960
let's remove this A as well just to clean that stuff here.

18:48.960 --> 18:51.840
Now what I will do is I want to have certain variables.

18:51.840 --> 18:54.000
Now when I say variables, what I want to do is,

18:54.000 --> 18:56.240
I want to have two variables,

18:56.240 --> 18:59.760
one which defines the type of CPU I'm working with

18:59.760 --> 19:01.200
and the amount of RAM I have.

19:01.200 --> 19:02.960
Example, if you talk about any computer,

19:02.960 --> 19:04.160
these two are very important, right?

19:04.160 --> 19:06.800
The CPU which you are using and a RAM,

19:06.800 --> 19:08.720
maybe 8GB RAM or 16GB RAM.

19:08.720 --> 19:12.000
And in terms of CPU, we have let's say i3, i5, i7

19:12.000 --> 19:13.600
or maybe some AMD series.

19:13.600 --> 19:15.440
Okay, we have different parameters as well,

19:15.440 --> 19:16.800
but just to keep it simple,

19:16.800 --> 19:18.000
let's only focus on two things,

19:18.000 --> 19:19.760
CPU and RAM capacity.

19:19.760 --> 19:21.600
Now when you say we have two variables,

19:21.600 --> 19:22.560
where do you find that?

19:22.560 --> 19:24.400
So we can use a special method

19:24.400 --> 19:25.920
which is available in a class.

19:25.920 --> 19:27.600
Now when I say special, you know, right?

19:27.600 --> 19:28.960
So the moment you say special,

19:28.960 --> 19:30.400
we have talked about special variable

19:30.480 --> 19:32.000
which is underscore underscore name

19:32.000 --> 19:34.160
in the same way we have special method

19:34.160 --> 19:35.440
which is init.

19:35.440 --> 19:36.320
And when I say special,

19:36.320 --> 19:38.800
it will be having underscores as well.

19:38.800 --> 19:39.680
So let's define that.

19:39.680 --> 19:42.160
So we'll say def underscore underscore init.

19:42.160 --> 19:44.320
You can see that we are getting suggestions as well.

19:44.320 --> 19:45.680
And the moment I say enter,

19:45.680 --> 19:48.320
you can see we have the function name or the method name

19:48.320 --> 19:50.960
as init and we are passing self.

19:50.960 --> 19:52.480
Now see, self is not something

19:52.480 --> 19:54.480
which I'm typing that is coming automatically.

19:54.480 --> 19:56.960
So it's compulsory to have those argument, okay,

19:56.960 --> 19:57.920
which is self.

19:57.920 --> 19:59.760
And in here, we can do something.

19:59.760 --> 20:02.560
Normally we use init to initialize the variables, okay?

20:02.560 --> 20:05.360
And that's what the name itself init initialize, right?

20:05.360 --> 20:08.400
Now if you are coming from C, C++ or Java background,

20:08.400 --> 20:09.600
we use constructor, right?

20:09.600 --> 20:12.160
So you can imagine this is our constructor,

20:12.160 --> 20:13.920
but then it is init method.

20:13.920 --> 20:15.760
The advantage here is normally,

20:15.760 --> 20:17.520
see, if you want to work with config,

20:17.520 --> 20:19.440
you are supposed to call config, okay?

20:19.440 --> 20:21.760
So it's compulsory for you to call config.

20:21.760 --> 20:23.520
Otherwise it will not get executed.

20:23.520 --> 20:25.120
The idea behind init is,

20:25.120 --> 20:27.040
it will be getting called automatically.

20:27.040 --> 20:29.920
Example, if I go back here and let's say,

20:29.920 --> 20:32.480
I want to print something and I will print in init.

20:32.480 --> 20:34.800
So you can see I have defined a function called init

20:34.800 --> 20:35.600
and not calling it, okay?

20:35.600 --> 20:37.600
So anywhere in the code, I'm not calling init.

20:37.600 --> 20:39.600
I'm calling config because I want to execute it.

20:39.600 --> 20:41.280
The moment I run this code,

20:41.280 --> 20:43.120
you can see it prints in init

20:43.120 --> 20:44.480
and that way it prints two times.

20:44.480 --> 20:45.360
Now why two times?

20:45.360 --> 20:48.480
Because for every object, it will get called once.

20:48.480 --> 20:51.360
So you can see in total, I'm getting two objects.

20:51.360 --> 20:53.600
One is com one, one second is com two.

20:53.600 --> 20:56.800
So we got two objects and it will call init two times.

20:56.800 --> 20:57.920
So this is the object creation.

20:57.920 --> 21:00.480
So when you say computer bracket, it will instantiate.

21:00.480 --> 21:02.160
It will call init for you.

21:02.160 --> 21:05.920
Now I want to pass some arguments, okay?

21:05.920 --> 21:07.600
I want to pass CPU and RAM.

21:07.600 --> 21:10.320
So in the constructor itself, you can pass that.

21:10.320 --> 21:12.560
So in the computer bracket itself, you can pass it.

21:12.560 --> 21:15.920
So I can say I have a CPU here, which is let's say i5

21:15.920 --> 21:18.240
and the amount of RAM we have is 16 GB.

21:18.240 --> 21:20.240
The second computer we have, let's say,

21:20.240 --> 21:23.200
reason three and the amount of RAM we have, let's say 8 GB.

21:23.200 --> 21:25.600
So we have two computers with two different CPUs, right?

21:25.600 --> 21:27.920
And now how to accept these values?

21:27.920 --> 21:30.480
So of course you have to pass these values here, right?

21:30.480 --> 21:33.120
So you have to say self comma, you have to pass two values.

21:33.120 --> 21:34.800
You have to accept these two values.

21:34.800 --> 21:37.840
So you have to say CPU comma RAM, okay?

21:37.840 --> 21:38.960
That's how you accept it.

21:38.960 --> 21:40.080
Now I know your question.

21:40.080 --> 21:43.040
Your question is we are passing two parameters, right?

21:43.040 --> 21:44.240
Or we are passing two arguments.

21:44.240 --> 21:46.160
One is CPU and second is RAM.

21:46.160 --> 21:48.640
And we are accepting the arguments here.

21:48.640 --> 21:51.600
So the thing is, you are actually passing three arguments here.

21:51.600 --> 21:53.840
Remember, we are also passing comp one.

21:53.840 --> 21:55.840
The moment you say computer in the back end,

21:55.840 --> 21:58.480
you are passing that comp one by default.

21:58.480 --> 22:00.400
The same thing happened with config, right?

22:00.400 --> 22:04.320
When we call config, we are not passing self or the object itself.

22:04.320 --> 22:06.480
But it gets passed automatically.

22:06.480 --> 22:09.360
The same way, when you say computer by passing two parameters,

22:09.360 --> 22:10.400
you're actually passing three.

22:10.400 --> 22:11.920
The first one is the object itself.

22:11.920 --> 22:15.040
The second one, the value, the first value here and then RAM.

22:15.040 --> 22:16.240
Okay, that makes sense.

22:16.240 --> 22:17.200
But will it work?

22:17.200 --> 22:19.440
So the thing is, every object need to have a value

22:19.440 --> 22:21.680
because this is just an argument now.

22:21.680 --> 22:23.840
So CPU and RAM is just an argument.

22:23.840 --> 22:25.920
If you want it to be a part of your object,

22:25.920 --> 22:27.600
you need to say, because see,

22:27.600 --> 22:30.240
we have to assign this value to an object, right?

22:30.240 --> 22:32.400
And the object here is self, right?

22:32.400 --> 22:34.160
So you have to say self dot.

22:34.160 --> 22:34.720
That's right, right?

22:34.720 --> 22:36.560
So this comp one, this is our object, right?

22:36.560 --> 22:40.880
So we have to say self dot CPU is equal to CPU.

22:40.880 --> 22:43.600
Again, there's no compulsion that you should be having same name.

22:43.600 --> 22:44.400
You can have a different name.

22:44.400 --> 22:45.200
That's fine.

22:45.200 --> 22:48.240
So you will say self dot RAM is equal to RAM.

22:48.240 --> 22:49.520
So whatever value you're passing here,

22:49.520 --> 22:52.640
which is I5 goes to the CPU as an argument.

22:52.640 --> 22:55.360
It will be assigned to the object, which is self.

22:55.360 --> 22:56.720
So the self, you can imagine now.

22:56.720 --> 22:59.120
So in the background, you can see we have two objects here.

22:59.120 --> 23:00.880
So in total, we've got two objects.

23:00.880 --> 23:03.040
Each object will have its own variables.

23:03.040 --> 23:04.480
Okay, it will have its own CPU.

23:04.480 --> 23:06.160
It will have its own RAM.

23:06.160 --> 23:08.880
And then whatever value you pass in the arguments,

23:08.880 --> 23:10.720
it will be assigned to those objects.

23:10.720 --> 23:13.040
Okay, so we have two objects, two different values.

23:13.040 --> 23:15.520
And now in the config, instead of printing this stuff,

23:15.520 --> 23:19.360
I will say CPU comma RAM.

23:19.360 --> 23:20.400
That's what we do.

23:20.400 --> 23:21.840
Oh, we got an error.

23:21.840 --> 23:22.720
What's wrong here?

23:22.720 --> 23:25.280
So the thing is, this CPU is not a local variable, right?

23:25.280 --> 23:27.200
This CPU belongs to an object.

23:27.200 --> 23:28.560
And how do we refer to object?

23:28.560 --> 23:29.200
It's very simple.

23:29.200 --> 23:30.080
You have to use self, right?

23:30.080 --> 23:31.120
That's why you are passing it.

23:31.120 --> 23:34.240
So you have to say self dot CPU.

23:34.240 --> 23:36.560
And here as well, you have to say self dot RAM.

23:36.560 --> 23:39.200
And that's the idea behind passing this self, right?

23:39.200 --> 23:43.120
We are passing self so that you can use it to fetch the values.

23:43.120 --> 23:46.480
So you can imagine your methods and your data works together.

23:46.480 --> 23:48.480
And we have a name for this concept.

23:48.480 --> 23:49.840
Again, we'll talk about that name later.

23:49.840 --> 23:50.640
It's a surprise.

23:50.640 --> 23:54.480
But we are binding our data with every method.

23:54.480 --> 23:58.960
So one object will have its own methods and its own variables, right?

23:58.960 --> 24:00.080
So they are working together.

24:00.720 --> 24:02.800
And now let's run this code and let's see what happens.

24:02.800 --> 24:04.560
So the moment you run this code, you can see it says,

24:04.560 --> 24:08.480
config is i5-16 and config is raisin-3-8.

24:08.480 --> 24:09.600
So that's the idea.

24:09.600 --> 24:11.280
That's how you create a variable.

24:11.280 --> 24:13.440
So every object will have its own values.

24:13.440 --> 24:14.160
That's amazing.

24:19.120 --> 24:21.920
In the last video, we have talked about OOPS concept, right?

24:21.920 --> 24:23.280
We have talked about objects.

24:23.280 --> 24:24.960
We have talked about classes.

24:24.960 --> 24:28.080
And then somewhere we have talked about init, right?

24:28.080 --> 24:30.400
In this video, we'll focus on two concepts.

24:30.400 --> 24:33.360
One is constructor and self.

24:33.360 --> 24:33.920
But hold on.

24:33.920 --> 24:36.160
We have seen self before, right?

24:36.160 --> 24:38.240
But let's try to expand more of it, okay?

24:38.240 --> 24:40.960
Because self is something which is very easy to understand.

24:40.960 --> 24:43.120
At the same time, it is a bit confusing, okay?

24:43.120 --> 24:44.400
So we'll try to get that.

24:44.400 --> 24:46.560
And then we also talk about constructor.

24:46.560 --> 24:49.520
Now in the last video, we have talked about init, right?

24:49.520 --> 24:51.440
Now init is actually a constructor.

24:51.440 --> 24:52.880
But why this course constructor?

24:52.880 --> 24:54.080
We'll see that here.

24:54.080 --> 24:55.440
And why this is so important?

24:55.440 --> 24:57.360
So what we'll do is let's remove this thing.

24:57.360 --> 24:59.280
And let's see a computer class again.

24:59.280 --> 25:00.640
Let's go back to computer class.

25:00.640 --> 25:01.600
So this is a class, right?

25:01.600 --> 25:04.800
And of course, every class will have an object, right?

25:04.800 --> 25:07.760
As we mentioned, we have a concept of a design, right?

25:07.760 --> 25:10.240
So this computer class is a design.

25:10.240 --> 25:12.400
And then we need to create an object of it.

25:12.400 --> 25:15.520
So what I will do is I will say C1 is equal to computer.

25:15.520 --> 25:17.840
Now this computer here is an object, right?

25:17.840 --> 25:19.200
I mean, this C1 is an object.

25:19.200 --> 25:22.080
Or you can say C1 is referring to the object.

25:22.080 --> 25:24.320
So what happens, you know, in your system,

25:24.320 --> 25:27.600
we have a special memory called as heap memory.

25:27.600 --> 25:31.120
Now inside this heap memory, you will get all the objects, right?

25:31.120 --> 25:33.120
Example, the moment you say you want an object now,

25:33.120 --> 25:36.080
if you remember, we have talked about integers, string,

25:36.080 --> 25:38.400
everything is object in Python, right?

25:38.400 --> 25:42.640
Now in this scenario, here, this object will take some space

25:42.640 --> 25:44.480
in your heap memory.

25:44.480 --> 25:46.960
Now, every space will have some address, right?

25:46.960 --> 25:49.360
We have talked about ID function, remember?

25:49.360 --> 25:53.920
So we can use an ID function here and we can print the value of C1.

25:53.920 --> 25:55.520
So we can print the address.

25:55.520 --> 25:57.760
So of course, this object is created somewhere

25:57.760 --> 25:59.600
and we need to print the address as well.

25:59.600 --> 26:01.600
And the way you can print the address is by saying,

26:01.600 --> 26:04.640
print, I want to print the address of C1.

26:04.640 --> 26:05.440
Let's do that.

26:05.440 --> 26:06.720
Oh, we are getting an error.

26:06.720 --> 26:08.720
Now, if you remember, we have talked about this stuff.

26:08.720 --> 26:10.320
So I'm keeping this class empty, right?

26:10.320 --> 26:11.280
We cannot do that.

26:11.280 --> 26:13.840
So let's write pass because I have not mentioned anything

26:13.840 --> 26:14.960
in the class here.

26:14.960 --> 26:15.840
So let's write pass.

26:15.840 --> 26:16.800
Let's run this code now.

26:17.360 --> 26:21.520
And you can see we got the output as 155 with the number, right?

26:21.520 --> 26:23.280
Now, this is an address, okay?

26:23.280 --> 26:25.840
So this is the address of that memory.

26:25.840 --> 26:28.000
Now, what happens if I create another object?

26:28.000 --> 26:31.040
Let's say if I say C2 equal to computer,

26:31.040 --> 26:32.640
now we are creating another object, right?

26:32.640 --> 26:34.720
So in total, we got two objects.

26:34.720 --> 26:37.040
So will it take different space or will it be accommodated

26:37.040 --> 26:37.760
in the same place?

26:37.760 --> 26:39.600
Of course, we have talked about this before

26:39.600 --> 26:41.520
when we talked about integers, allocation.

26:41.520 --> 26:44.000
If I run this code, you can see we got different addresses.

26:44.000 --> 26:45.360
And again, every time you run this code,

26:45.360 --> 26:46.640
you will get different address, right?

26:46.640 --> 26:48.160
Because every time you run this code,

26:48.160 --> 26:50.000
it will create a new object for you.

26:50.000 --> 26:51.680
So this time we got two new objects.

26:51.680 --> 26:54.000
Now, if I run this again, we will get two different objects,

26:54.000 --> 26:55.120
not the same object again, right?

26:55.120 --> 26:56.640
Because this is new execution.

26:56.640 --> 26:59.840
So point to remember is every time you create the object,

26:59.840 --> 27:01.920
it will take two different spaces.

27:01.920 --> 27:04.560
Now, for sure, how much space it will take?

27:05.120 --> 27:08.240
Maybe one MB, maybe one KB, maybe five KB.

27:08.240 --> 27:11.200
So who will decide and who will allocate the memory?

27:11.200 --> 27:14.000
Now, first of all, the size of the object

27:14.000 --> 27:15.840
is dependent upon the number of variables we have

27:15.840 --> 27:17.360
or the attributes, remember?

27:17.360 --> 27:20.000
If this class has five variables of different type,

27:20.000 --> 27:21.760
it depends upon how much data you pass,

27:21.760 --> 27:23.440
it will change the size of it, okay?

27:23.440 --> 27:25.680
So the size of the object is dependent upon

27:25.680 --> 27:27.920
the size of the variables and number of variables.

27:28.560 --> 27:31.360
But who is responsible to assign that memory?

27:31.360 --> 27:33.840
Or who is responsible to calculate the memory?

27:33.920 --> 27:35.840
And that's your constructor.

27:35.840 --> 27:38.240
Now, this thing here, which is computer brackets,

27:38.240 --> 27:39.920
this is your constructor, right?

27:39.920 --> 27:41.280
So whenever you write a constructor,

27:41.280 --> 27:43.360
it will call the init method for you.

27:43.360 --> 27:45.360
Of course, you don't have to call it explicitly,

27:45.360 --> 27:46.880
it will be called internally.

27:47.520 --> 27:48.960
Now, let me define some variables here.

27:48.960 --> 27:50.880
How do we create a variables, right?

27:50.880 --> 27:53.760
So how do we define a variable for the object?

27:53.760 --> 27:55.600
Now, in this case, if you want to define a variable,

27:55.600 --> 27:58.400
we have one choice, which you can define a function,

27:58.400 --> 27:59.200
which is init.

27:59.200 --> 28:00.560
Again, we have seen that.

28:00.560 --> 28:02.240
So this is the init function, right?

28:02.240 --> 28:03.840
Now, it uses self, but as of now,

28:03.840 --> 28:06.320
we'll not talk about self, we'll continue here.

28:06.320 --> 28:07.520
And I will use two variables.

28:07.520 --> 28:08.640
Again, we have talked about this,

28:08.640 --> 28:10.480
but let me just do it once again.

28:10.480 --> 28:12.080
I will say self.h.

28:12.080 --> 28:13.440
I want to have two attributes.

28:13.440 --> 28:14.400
One is name.

28:14.400 --> 28:17.440
I will say name is Navin and age.

28:17.440 --> 28:19.040
So let's say age is equal to 28.

28:19.040 --> 28:21.760
So we got two things, we got name and we got age.

28:21.760 --> 28:24.080
Now, both the object will have the same values, right?

28:24.080 --> 28:25.600
So you can imagine we have two objects

28:25.600 --> 28:27.360
and both the objects have the same value.

28:27.920 --> 28:29.040
If I want to change it,

28:29.040 --> 28:31.280
if I want to change the value of one object,

28:31.280 --> 28:33.120
the way you can do that is, in fact,

28:33.120 --> 28:36.000
instead of printing IDs, I want to change it now

28:36.000 --> 28:38.160
because of course, the IDs will print different now.

28:38.160 --> 28:38.960
We know that.

28:38.960 --> 28:40.400
So we'll say c1.

28:40.400 --> 28:42.240
I want to print name of c1

28:42.240 --> 28:44.160
and I want to print the name of c2 as well.

28:44.880 --> 28:45.760
So what will happen?

28:45.760 --> 28:47.760
Will it print the same data or different data?

28:47.760 --> 28:48.240
That's a question.

28:48.240 --> 28:50.000
So let's run this code and you can see

28:50.000 --> 28:51.920
they are printing Navin, of course, right?

28:51.920 --> 28:54.160
Because the moment you create the object,

28:54.160 --> 28:55.680
both will have the same value

28:55.680 --> 28:58.000
because that is what by default you're getting.

28:58.000 --> 29:00.480
If you want to assign your own values,

29:00.560 --> 29:01.840
you have two choices here.

29:01.840 --> 29:03.280
What we can do is, before printing it,

29:03.280 --> 29:04.400
we can change the value for c1.

29:04.400 --> 29:07.280
We can say c1.name is equal to Rashi.

29:07.280 --> 29:08.640
So we are changing the name, right?

29:08.640 --> 29:10.400
And now if I run this code,

29:10.400 --> 29:12.640
you can see we got Rashi and we got Navin.

29:12.640 --> 29:14.080
So of course, c1 is different objects.

29:14.080 --> 29:16.160
c2 is different object and we got different names.

29:16.160 --> 29:17.840
So that perfectly makes sense.

29:17.840 --> 29:19.760
We can change the age of c1.

29:19.760 --> 29:22.080
We can say c1.age is listed 12.

29:22.080 --> 29:24.160
We've got Rashi with age 12.

29:24.160 --> 29:26.080
And of course, we are not printing age here

29:26.080 --> 29:26.960
but we can do that.

29:26.960 --> 29:29.440
So we can change the value of one object

29:29.440 --> 29:30.240
from different objects.

29:30.320 --> 29:32.160
But of course, there are two different entities.

29:32.160 --> 29:34.080
So remember this, we got two different objects

29:34.080 --> 29:36.400
and both the objects will have different variables.

29:36.400 --> 29:37.600
Okay, you can assign the values there.

29:37.600 --> 29:39.120
You can change it your wish.

29:39.120 --> 29:40.400
Now, question arise.

29:40.400 --> 29:42.560
Why do we need this self?

29:42.560 --> 29:44.400
So what I will do is just to explain that,

29:44.400 --> 29:46.080
let me take one more method here.

29:46.080 --> 29:47.440
We'll say def update.

29:47.440 --> 29:49.840
Okay, so I'm changing the value of something.

29:49.840 --> 29:50.880
And the moment I say update,

29:50.880 --> 29:52.720
I want to change age.

29:52.720 --> 29:55.840
I will assign new age and we'll say age is let's say 30.

29:56.720 --> 29:58.400
So we are changing the age now, right?

29:58.480 --> 30:01.120
So we got a method which will change the age totally.

30:01.680 --> 30:03.920
Now, I want to call update.

30:03.920 --> 30:06.000
Now, how do you call update with the help of class name

30:06.000 --> 30:07.840
or with the help of object name?

30:08.560 --> 30:09.760
Let's try with objects.

30:09.760 --> 30:11.760
I will say c1.update.

30:12.400 --> 30:14.000
Now see, we have two different objects, right?

30:14.000 --> 30:15.520
So what is program execution, right?

30:15.520 --> 30:16.880
So execution will start from here.

30:17.520 --> 30:19.600
You got the object, you got the object,

30:19.600 --> 30:21.520
you are changing the names and everything is fine.

30:22.080 --> 30:24.480
The moment you say c1.update,

30:24.480 --> 30:26.480
your pointer, which is your focus,

30:26.480 --> 30:29.520
will move towards this update function of update method.

30:29.520 --> 30:30.880
So it is executing it, right?

30:31.520 --> 30:33.200
Update will say, okay, I'm getting called.

30:33.200 --> 30:34.560
I belong to a class computer.

30:34.560 --> 30:35.840
My job is to do something.

30:35.840 --> 30:38.160
My job is to change the value of age.

30:38.160 --> 30:39.680
But hold on, we got two objects.

30:40.320 --> 30:42.000
Which value you want to change, right?

30:42.000 --> 30:43.680
Because we are calling update.

30:43.680 --> 30:46.560
And we are not mentioning which object I'm talking about

30:46.560 --> 30:48.400
because when you call this update,

30:48.400 --> 30:50.320
we have not mentioned is it c1 or c2.

30:50.320 --> 30:51.600
We have mentioned that by calling it.

30:51.600 --> 30:53.600
So we are saying c1.update.

30:53.600 --> 30:56.080
But we are not passing anything in the bracket.

30:56.080 --> 30:58.320
So when you're calling it, when you're calling update,

30:58.320 --> 31:02.000
how your pointer will know which object I'm talking about.

31:02.000 --> 31:04.960
Is it the c1 age or is it the c2 age?

31:04.960 --> 31:07.520
And that's where you need to use self.

31:07.520 --> 31:09.280
So this self is a pointer.

31:09.280 --> 31:12.320
Or you can say self is directing to c1 or c2.

31:12.320 --> 31:13.520
So we have two objects.

31:13.520 --> 31:15.840
This self will direct either on c1 or c2

31:15.840 --> 31:17.760
based on what you're calling.

31:17.760 --> 31:19.360
So if you're saying c1.update,

31:19.360 --> 31:21.120
then in the bracket, it is passing c1.

31:21.120 --> 31:23.680
So self will be assigned to c1, okay?

31:23.680 --> 31:25.920
So that's the importance of that self.

31:25.920 --> 31:28.480
It is very important because it is referring to the object.

31:28.480 --> 31:29.840
If you have 10 objects,

31:29.840 --> 31:32.080
and if you want to refer to one object, you can use self.

31:32.080 --> 31:34.400
So it is the current instance you can say.

31:34.400 --> 31:35.440
Even if you have 10 objects,

31:35.440 --> 31:38.240
at one point you're working with one object, that is self.

31:39.040 --> 31:40.400
I hope that makes sense.

31:40.400 --> 31:41.280
So that is self, right?

31:41.280 --> 31:44.240
So we have talked about constructor and self here.

31:44.240 --> 31:46.000
Let me show you one more thing.

31:46.000 --> 31:48.400
What if I want to compare two objects here, okay?

31:48.400 --> 31:49.200
So I want to compare.

31:49.200 --> 31:52.240
Let's say we have c1, c2, and both have same names, right?

31:52.240 --> 31:54.640
So they have same name and they have same age.

31:54.640 --> 31:56.480
But let's say I want to compare the age.

31:56.480 --> 31:59.040
So I will say if c1 is equal to equal to c2.

31:59.040 --> 32:01.440
So I want to compare two people based on their age.

32:01.440 --> 32:03.760
If their age is same, I want to print their same.

32:03.760 --> 32:08.480
So I will say c1 is equal to equal to c2, print, they are the same.

32:08.480 --> 32:09.120
So let's do that.

32:09.120 --> 32:11.120
So I want to check if both the objects are same,

32:11.120 --> 32:12.640
then I will print their same.

32:12.640 --> 32:15.520
But then I don't want to compare the object address, right?

32:15.520 --> 32:17.600
I want to compare their values.

32:17.600 --> 32:18.800
I want to compare their age.

32:18.800 --> 32:20.160
Name doesn't matter if name is different.

32:20.160 --> 32:21.760
What is what should be same is age.

32:22.320 --> 32:24.800
Now in this case, we cannot simply say c1 equal to c2

32:24.800 --> 32:28.160
because we don't know, your Python don't know how to compare.

32:28.160 --> 32:33.040
So in this case, what you will do is, you will use a separate function to do that.

32:33.040 --> 32:36.000
I will say, hey, I want to compare c1 with c2.

32:36.000 --> 32:40.080
So I will say c1, compare, and you can pass c2

32:40.080 --> 32:41.040
because we are comparing it.

32:41.040 --> 32:43.680
Well, again, this compare is not an inbuilt function.

32:43.680 --> 32:46.320
So if I click on this, you can see it says,

32:46.320 --> 32:48.560
cannot find declaration to go to something.

32:48.560 --> 32:52.720
The thing is, compare is not an inbuilt method we have.

32:52.720 --> 32:55.280
So in order to work with compare, you have to define your function.

32:55.280 --> 32:57.120
You have to say, compare.

32:57.120 --> 33:00.080
And in this compare, of course, you have to pass self.

33:00.080 --> 33:04.320
And then you have to also pass one more object, which is of c2.

33:04.320 --> 33:04.880
Right?

33:04.880 --> 33:06.160
So we are comparing two objects.

33:06.160 --> 33:06.320
Right?

33:06.320 --> 33:07.600
So we have to pass self.

33:07.600 --> 33:08.960
So what is self here?

33:08.960 --> 33:13.360
So the c1 becomes self and c2 becomes c2.

33:13.360 --> 33:14.400
Again, you can change in the name.

33:14.400 --> 33:15.120
You see your choice, right?

33:15.120 --> 33:17.360
You can say other, right?

33:17.440 --> 33:18.960
So you're comparing self with other.

33:18.960 --> 33:21.520
So c1 becomes self and c2 becomes other.

33:21.520 --> 33:24.320
Now, why c1 becomes self is because c1 is calling it.

33:24.320 --> 33:27.120
So c1 is comparing itself with c2.

33:27.120 --> 33:27.920
You can reverse it.

33:27.920 --> 33:30.640
You can say c2.compare c1.

33:30.640 --> 33:34.080
In that case, c2 becomes self and c1 becomes other.

33:34.080 --> 33:34.560
Right?

33:34.560 --> 33:37.440
And now once you have this self and other, you can compare.

33:37.440 --> 33:45.120
If self.h is equal to equal to other.h, you will return true.

33:46.080 --> 33:49.200
Else return false.

33:49.200 --> 33:50.640
In fact, you could have done that in one line.

33:50.640 --> 33:52.720
But just to make it look good, I'm doing this.

33:52.720 --> 33:54.240
And now you can compare it.

33:54.240 --> 33:54.640
Right?

33:54.640 --> 33:58.160
So they don't have same age because we are changing it after update.

33:58.160 --> 33:59.680
Let's remove the update part here.

33:59.680 --> 34:00.880
They have the same age.

34:00.880 --> 34:01.120
Right?

34:01.120 --> 34:03.920
Let's run this demo and you can see, oh, we got an error.

34:03.920 --> 34:06.000
We forgot to put a code in there.

34:06.000 --> 34:06.480
My bad.

34:07.120 --> 34:08.240
Let's run this code.

34:08.240 --> 34:10.400
And so you can see just printing, they are same.

34:10.400 --> 34:11.040
So they are same.

34:11.040 --> 34:11.520
Right?

34:11.520 --> 34:13.360
Now what if they have different age?

34:13.360 --> 34:17.200
So what I will do is once I got c1, I will change this age of c1.

34:17.200 --> 34:19.280
I will say age of c1 is 30.

34:19.280 --> 34:20.880
Anyway, we are not using update here.

34:20.880 --> 34:22.240
And we can say run demo.

34:22.240 --> 34:23.520
And you can see it is not printing.

34:23.520 --> 34:24.480
They are same.

34:24.480 --> 34:25.840
We should print the as well.

34:25.840 --> 34:27.520
So that we'll see, is it different?

34:27.520 --> 34:28.160
Let's print.

34:28.800 --> 34:30.160
They are different.

34:31.040 --> 34:32.640
And let's run this code.

34:32.640 --> 34:34.240
In case of that, we got they are different.

34:34.240 --> 34:37.280
Now, since that age is different, we are getting that different.

34:37.280 --> 34:38.320
See, names are same.

34:38.320 --> 34:39.920
What is different is age.

34:39.920 --> 34:43.360
So we can compare two objects by defining our own function,

34:43.360 --> 34:45.840
which is compare in this case or method in this case.

34:45.840 --> 34:48.080
But remember this thing, compare takes two parameters,

34:48.080 --> 34:52.080
the first one who is calling it, and second one whom to compare.

34:52.080 --> 34:52.240
Right?

34:52.240 --> 34:55.120
So here in this case, we are saying c1.compare with c2.

34:55.120 --> 34:57.280
So c1 becomes self, c2 becomes other.

34:57.280 --> 34:58.240
This is very important.

34:58.240 --> 34:59.840
I know it is a bit confusing at the start,

34:59.840 --> 35:02.560
but the moment you start working on it, it becomes very easy.

35:02.720 --> 35:10.480
Now, we know how to work with class and object, right?

35:10.480 --> 35:13.920
And we have also seen how can you create a variable inside an object.

35:13.920 --> 35:14.560
Of course, right?

35:14.560 --> 35:16.640
Every object should know something.

35:16.640 --> 35:19.280
But when it comes to variable, in oops,

35:19.280 --> 35:21.280
we have two different types of variable.

35:21.280 --> 35:24.320
The first one is an instance variable,

35:24.320 --> 35:26.800
and the second one is a class variable,

35:26.800 --> 35:29.120
or you can call them as static variables.

35:29.120 --> 35:30.560
What is the difference between them?

35:30.560 --> 35:31.360
Now, think about this.

35:31.360 --> 35:33.760
Let me just remove this code, whatever we have done till now.

35:33.760 --> 35:35.280
So let me just clean this up.

35:35.280 --> 35:35.760
Okay?

35:35.760 --> 35:37.920
So we will start from a plain slate.

35:37.920 --> 35:40.400
So here, let's go with another very example.

35:40.400 --> 35:42.000
Let's take a class call us car.

35:42.000 --> 35:42.320
Okay?

35:42.320 --> 35:43.600
We all love cars, right?

35:43.600 --> 35:45.200
So let's say we have a class car,

35:45.200 --> 35:48.320
and of course, every car will have different variables, right?

35:48.320 --> 35:49.840
Of course, you can mention the company name,

35:49.840 --> 35:51.920
you can mention the type of engineer you're working with,

35:51.920 --> 35:54.000
and the mileage what it gives you.

35:54.000 --> 35:55.280
So we have different variables.

35:55.280 --> 35:55.440
Okay?

35:55.440 --> 35:58.640
So what I will do is, if I want to use those variables here,

35:58.720 --> 36:01.520
we need to use a function, which is init.

36:01.520 --> 36:03.280
So you will say init function,

36:03.280 --> 36:05.760
and in this, you can define those variables, right?

36:05.760 --> 36:07.520
I can say self dot mileage,

36:07.520 --> 36:09.840
and I will say mileage is, let's say, 10.

36:09.840 --> 36:11.360
And then I will say the company.

36:11.360 --> 36:14.160
So company would be, let's say, bmw.

36:14.160 --> 36:15.920
Any random company doesn't matter.

36:15.920 --> 36:17.600
So we have these two values, right?

36:17.600 --> 36:20.480
Now, these two variables are called as instance variables.

36:20.480 --> 36:23.120
So when you talk about mileage and comm, these are instance.

36:23.120 --> 36:25.040
Now, why is our instance is because,

36:25.040 --> 36:27.760
as your car changes, as the object changes,

36:27.760 --> 36:29.200
this value also change.

36:29.200 --> 36:31.040
By default, the value is 10 and bmw,

36:31.040 --> 36:32.480
but you can change it, right?

36:32.480 --> 36:35.200
Example, we have done that before just to give you a glimpse.

36:35.200 --> 36:38.080
I will say the first one is c1, and this is car.

36:38.080 --> 36:39.040
That's my first object.

36:39.040 --> 36:41.200
I got c2, which is, again, a car.

36:41.200 --> 36:42.640
That is, we got c1, c2.

36:42.640 --> 36:44.320
Now, we got two different objects,

36:44.320 --> 36:46.640
and both the object will have different variables, right?

36:46.640 --> 36:48.560
Different area for the variables.

36:48.560 --> 36:52.000
And now, if I print the value, so I will say c.com,

36:52.000 --> 36:55.280
and I also want to print c1.milit.

36:55.280 --> 36:56.400
So I want to print both.

36:56.720 --> 36:57.840
Both the variables.

36:57.840 --> 37:01.280
So you can see we got c1.com, c1.milit, c2.com, c2.milit.

37:01.280 --> 37:01.840
That's perfect.

37:01.840 --> 37:03.120
And now, if I run this code, of course,

37:03.120 --> 37:05.360
it will print same values because they are same.

37:05.360 --> 37:06.320
But can we change it?

37:06.320 --> 37:06.880
Yes, we can.

37:06.880 --> 37:11.200
So I will say, if I change for c1, so let's say c1.milit.

37:11.200 --> 37:14.160
So let's say c1.milit changes from 10 to, let's say, 8.

37:14.160 --> 37:15.840
This is what happens, you know, with some cars.

37:15.840 --> 37:16.640
And let's run this code.

37:16.640 --> 37:18.080
You can see the value is changing now.

37:18.080 --> 37:19.680
So, of course, both the objects are different,

37:19.680 --> 37:21.040
and they will have different values.

37:21.040 --> 37:24.000
But what if I want to create a variable,

37:24.000 --> 37:26.160
which is common for all the objects?

37:26.160 --> 37:28.560
Of course, these variables, which are instance variable,

37:28.560 --> 37:30.960
they are different for different objects, right?

37:30.960 --> 37:34.080
If you change one object, it will not affect other objects.

37:34.080 --> 37:36.480
What if you want to have a variable,

37:36.480 --> 37:39.200
which will change, it will affect all other objects?

37:39.200 --> 37:42.960
Example, the number of wheels in a car is 4, right?

37:42.960 --> 37:44.640
By default, it is 4, right?

37:44.640 --> 37:46.960
But what if, in future, we got a new concept?

37:46.960 --> 37:48.400
And they're saying, hey, now, this time,

37:48.400 --> 37:50.800
we will have five tires, or five wheels.

37:50.800 --> 37:53.360
I don't know why we'll have five wheels, but let's imagine.

37:53.360 --> 37:54.720
In this case, what you will do is,

37:54.720 --> 37:57.440
you will define a variable outside in it, okay?

37:57.440 --> 38:01.200
Because if you create, or if you define the variable inside in it,

38:01.200 --> 38:02.960
it becomes an instance variable.

38:02.960 --> 38:05.360
If you define a variable outside in it,

38:05.360 --> 38:08.560
and inside a class, of course, it becomes a class variable.

38:08.560 --> 38:10.320
Let's say, we'll say wheels.

38:10.320 --> 38:13.680
So, let's say wheels are by default 4, of course, will be 4, right?

38:13.680 --> 38:17.520
And if I print the wheels as well, now, how do you print wheels?

38:17.520 --> 38:19.120
The way you can print is very simple.

38:19.120 --> 38:23.680
You can say C1.wheels, and here as well, I'll say C2.wheels.

38:23.680 --> 38:26.160
And let's run this code now, and you can see we got the output.

38:26.160 --> 38:27.280
We got 4 and 4.

38:27.280 --> 38:32.000
So, if you want to access wheels, you can use C1.wheels and C2.wheels.

38:32.000 --> 38:34.800
So, instead of using the object name, we can also use class name.

38:34.800 --> 38:36.720
Because see, if you talk about mill and com,

38:36.720 --> 38:38.560
it is specific to the object, right?

38:38.560 --> 38:40.400
But that's not the case with wheels.

38:40.400 --> 38:42.080
Wheels is common to all the objects.

38:42.080 --> 38:44.320
So, every object can share the same value of it.

38:44.320 --> 38:48.080
So, we can use object name, or we can use class name, both works.

38:48.080 --> 38:49.280
So, you're getting value 4, right?

38:49.280 --> 38:51.120
What if you want to change the value of it?

38:51.120 --> 38:53.200
If you want to change the value, you can come here,

38:53.280 --> 38:54.800
and you can change the value.

38:54.800 --> 38:55.520
See, what happens?

38:55.520 --> 38:57.600
You know, in your memory, you have different namespace.

38:57.600 --> 38:58.480
Now, what is namespace?

38:58.480 --> 39:00.880
The place where you create an object or the variables,

39:00.880 --> 39:01.920
there was namespace.

39:01.920 --> 39:03.360
So, we have two types of namespace.

39:03.360 --> 39:07.120
One is class namespace, where you will store all the class variables,

39:07.120 --> 39:09.280
and then we have an instance namespace,

39:09.280 --> 39:11.360
where you will create all the instance variable.

39:11.360 --> 39:14.640
So, these variables, which is mill and com, they are instance, right?

39:14.640 --> 39:16.480
So, they will belong to instance namespace.

39:16.480 --> 39:19.280
This wheel belongs to class namespace, right?

39:19.280 --> 39:21.920
So, if you want to work with wheels, if you want to modify it,

39:21.920 --> 39:22.880
you have to use a class name.

39:22.880 --> 39:25.760
You have to say car.wheels, and you can assign the value to 5.

39:25.760 --> 39:27.280
Now, the moment you change the value for wheels,

39:27.280 --> 39:29.120
it will affect all the objects, right?

39:29.120 --> 39:30.160
Because they are shared.

39:30.160 --> 39:32.400
So, this wheel is shared between all the objects,

39:32.400 --> 39:35.200
and neither on this code, you can see the output is 5 and 5.

39:35.200 --> 39:36.480
So, that's your class variable.

39:36.480 --> 39:38.960
So, the point to remember is we have two types of variables,

39:38.960 --> 39:41.200
instance variables, and class variables.

39:41.200 --> 39:43.600
Or, in fact, class variables are also called as steady variables.

39:48.480 --> 39:50.080
Now, till this point, we have talked about

39:50.080 --> 39:51.600
different types of variables, right?

39:51.600 --> 39:54.640
We have seen instance variable and a class variable.

39:54.640 --> 39:56.640
We can call them as steady variables, right?

39:56.640 --> 39:58.880
Now, in this video, we'll talk about methods

39:58.880 --> 40:00.080
and different types of methods.

40:00.080 --> 40:01.200
Now, we have seen that, right?

40:01.200 --> 40:03.680
When you talk about objects, object will have two things, right?

40:03.680 --> 40:05.840
The first one it will have is variables,

40:05.840 --> 40:07.280
and second one is methods.

40:07.280 --> 40:10.880
Now, variable to store data and methods for the behavior, right?

40:10.880 --> 40:12.880
So, if you want to perform some operation,

40:12.880 --> 40:14.560
that's where methods comes into picture.

40:14.560 --> 40:17.200
As human as well, we know something and we do something, right?

40:17.200 --> 40:19.200
So, those are your variables and methods, right?

40:19.200 --> 40:20.640
Now, here, when you talk about methods,

40:20.640 --> 40:22.720
we have different types of methods.

40:22.720 --> 40:24.560
Now, basically, we have three types of methods.

40:24.560 --> 40:26.800
The first one is instance method.

40:26.800 --> 40:29.440
The second one we have is class method,

40:29.440 --> 40:30.960
and then we have static method.

40:30.960 --> 40:31.680
Now, hold on.

40:31.680 --> 40:33.680
When you talk about variables, we only have two, right?

40:33.680 --> 40:37.040
Because class and static behave the same way in variables.

40:37.040 --> 40:39.040
But, hold on. In variables, we have the same thing, right?

40:39.040 --> 40:42.160
In variables, we have class variables and static variables,

40:42.160 --> 40:43.360
which are same.

40:43.360 --> 40:44.720
That's not the case with methods, okay?

40:44.720 --> 40:48.880
So, class methods and static methods are different in methods.

40:48.880 --> 40:49.920
Okay, so, let's get started.

40:49.920 --> 40:52.160
So, understand this concept, we'll take an example.

40:52.160 --> 40:55.200
So, let's take a class here and we'll name this class as student.

40:55.200 --> 40:57.760
So, in this student class, we'll be having multiple variables, right?

40:57.760 --> 40:59.200
Now, of course, when you talk about student,

40:59.200 --> 41:02.160
we have names, we have roll number, and then we have marks.

41:02.160 --> 41:04.880
At this point, let me only focus on marks, okay?

41:04.880 --> 41:07.040
So, what I will do is let me create a function,

41:07.040 --> 41:08.080
which is your init function,

41:08.080 --> 41:09.600
because I want to declare some variables.

41:09.600 --> 41:11.040
So, it says self.

41:11.040 --> 41:12.800
Now, I want to go for three variables here.

41:12.800 --> 41:14.080
One is marks one,

41:14.080 --> 41:16.800
and marks one, I want to pass this value from the user, okay?

41:16.800 --> 41:18.880
Of course, you can define your own values here,

41:18.880 --> 41:21.200
but I want to pass the value when I create the object.

41:21.200 --> 41:23.600
And the way you do that is by saying self comma,

41:23.600 --> 41:25.200
you will pass m1, m2, m3.

41:25.200 --> 41:26.640
I want to pass three variables.

41:26.640 --> 41:28.800
And m1 value will be assigned to the object

41:28.800 --> 41:31.040
by saying self.m1 equal to m1.

41:31.040 --> 41:32.640
I will go to same thing for m2.

41:32.640 --> 41:35.200
I will say m2 and the same thing for m3, right?

41:35.200 --> 41:36.960
So, we got m1, m2, and m3.

41:36.960 --> 41:38.080
Now, we got three variables.

41:38.080 --> 41:39.680
I want to create certain objects here.

41:39.680 --> 41:41.280
Okay, let's create objects for this.

41:41.280 --> 41:42.320
I will go back here.

41:42.320 --> 41:43.360
So, let's create the object here.

41:43.360 --> 41:45.200
I will say s1 is equal to,

41:45.200 --> 41:47.360
and as usual, we can create multiple objects.

41:47.360 --> 41:49.680
But time it will go for s1 equal to,

41:49.680 --> 41:51.040
I will say student.

41:51.040 --> 41:52.160
That's my first object.

41:52.160 --> 41:53.200
And let me get one more object.

41:53.200 --> 41:55.680
We'll say s2 equal to student.

41:55.680 --> 41:57.440
So, we basically, we got two objects here.

41:57.440 --> 41:58.880
One is s1 and s2.

41:58.880 --> 42:00.880
I also want to pass a value to it, right?

42:00.880 --> 42:02.000
Because we are not passing it.

42:02.000 --> 42:03.680
So, let me pass any value, a random value.

42:03.680 --> 42:05.520
I'm not actually saying what I'm typing here,

42:05.520 --> 42:07.200
but then we got three values there.

42:07.200 --> 42:09.280
And here as well, I will go for any random value.

42:09.280 --> 42:11.520
That doesn't make any sense to see that.

42:11.520 --> 42:12.560
So, we got these values, right?

42:12.560 --> 42:15.040
So, first student got 34, 67, and 32.

42:15.040 --> 42:17.040
Second student got 87, 32, and 12.

42:17.040 --> 42:18.240
Now, what I'll do is, of course,

42:18.240 --> 42:20.400
these variables here, m1, m2, and m3,

42:20.400 --> 42:21.760
those are instance variables, right?

42:21.760 --> 42:23.200
We have talked about that.

42:23.200 --> 42:25.520
At this point, we have not created any methods.

42:25.520 --> 42:26.320
Let me just do that.

42:26.320 --> 42:27.520
In fact, before going for methods,

42:27.520 --> 42:30.400
let me also create a variable, a static variable this time.

42:30.400 --> 42:32.720
And the way you create a static or a class variable

42:32.720 --> 42:34.720
just by defining or declaring the variable

42:34.720 --> 42:36.880
outside the constructor, right?

42:36.880 --> 42:39.600
So, here, I will say, I have a variable,

42:39.600 --> 42:41.520
and we'll name this variable as school.

42:41.520 --> 42:43.520
Because, of course, a student belongs to a school,

42:43.520 --> 42:44.400
right, or a college.

42:44.400 --> 42:46.720
At this point, all the students belongs to the same school,

42:46.720 --> 42:47.520
which is the disco.

42:47.520 --> 42:49.280
Imagine, if we have the disco university,

42:49.280 --> 42:50.560
we'll be having a school.

42:50.560 --> 42:52.240
So, we got the school name as well, right?

42:52.240 --> 42:54.560
So, you can print those values by simply saying,

42:54.560 --> 42:56.160
in fact, you can print those values here as well.

42:56.160 --> 42:59.200
You can say, s1.m1, and x2.m1, we can do that.

42:59.200 --> 43:01.200
What I am concerned about here is,

43:01.200 --> 43:03.440
I want to know the average of marks, okay?

43:03.440 --> 43:04.800
So, I've got these three variables, right?

43:04.800 --> 43:06.160
I want to performance and operation.

43:06.160 --> 43:07.280
How do you find the average, right?

43:07.280 --> 43:09.920
So, the logic of average you can define by yourself,

43:09.920 --> 43:11.840
you know, everyone has their own way of doing it.

43:11.840 --> 43:13.360
I will be doing a very simple calculation.

43:13.360 --> 43:15.280
So, let me create a method called as def,

43:15.280 --> 43:16.720
method called average.

43:16.720 --> 43:18.400
So, when I say object.average,

43:18.400 --> 43:19.760
it will give me average marks, okay?

43:19.760 --> 43:21.280
So, I want to return the average marks.

43:21.280 --> 43:22.720
And the way you do that by saying return,

43:22.720 --> 43:23.840
you want to return the value.

43:23.840 --> 43:26.480
And here, you will simply say m1,

43:26.480 --> 43:31.200
or not just m1, you have to say self.m1 plus self.m3.

43:31.200 --> 43:32.720
So, we have to divide this number by three,

43:32.720 --> 43:34.080
that's how you find the average, right?

43:34.080 --> 43:35.040
And we know the stuff, right?

43:35.040 --> 43:36.720
That's how you find the average of multiple numbers.

43:36.720 --> 43:38.640
So, we got the average and we are returning the value.

43:38.640 --> 43:40.640
Okay, so now this, if you focus on this average,

43:40.640 --> 43:42.640
this is an instance method.

43:42.640 --> 43:44.000
How do you know that's an instance method

43:44.000 --> 43:45.280
because we are passing self.

43:45.280 --> 43:46.320
Now, when you say self,

43:46.320 --> 43:48.560
it means it belongs to a particular object, right?

43:48.560 --> 43:50.080
Of course, we are defining that in a class,

43:50.080 --> 43:51.600
but it works with the object.

43:51.600 --> 43:52.880
And that's why we are passing self.

43:52.880 --> 43:54.320
So, if you want to call average,

43:54.320 --> 43:56.160
you have to say s1.average,

43:56.160 --> 43:58.080
or you have to say s2.average,

43:58.080 --> 43:59.520
because we are passing self.

43:59.520 --> 44:01.680
We cannot simply say student.average,

44:01.680 --> 44:03.280
because we are not using object there.

44:03.280 --> 44:06.320
But in this case, we have to say s1.avg.

44:06.320 --> 44:06.960
That's how you do it.

44:06.960 --> 44:08.880
So, I have to say s1.avg.

44:08.880 --> 44:10.000
It will give you the values.

44:10.000 --> 44:11.040
I will print the value here.

44:11.040 --> 44:12.560
I will say print the average here.

44:12.560 --> 44:14.080
So, let's run this code and you can see it works.

44:14.080 --> 44:16.000
We got the average of our student.

44:16.000 --> 44:17.520
You can do the same thing for second student.

44:17.520 --> 44:19.600
You can stop saying s1.avg.

44:19.600 --> 44:21.200
You can say s2.avg.

44:21.200 --> 44:22.160
And if you run this code,

44:22.160 --> 44:24.240
you can see we got the average for second student as well.

44:24.240 --> 44:26.560
And they almost say, I don't know why.

44:26.560 --> 44:27.840
Okay, so after changing value,

44:27.840 --> 44:29.040
we got different average, you know?

44:29.040 --> 44:30.720
So, this was just for coincidence, you know?

44:30.720 --> 44:31.760
I have given some values

44:31.760 --> 44:33.600
and then they were giving the same average, right?

44:33.600 --> 44:35.440
So, yeah, so you got different average for s1

44:35.440 --> 44:36.560
and different average for s2.

44:36.560 --> 44:37.360
So, that works.

44:37.360 --> 44:38.160
Now, what we are going to do is,

44:38.160 --> 44:39.040
so this method here,

44:39.040 --> 44:40.960
this average is an instance method

44:40.960 --> 44:42.240
because it works with the object.

44:42.240 --> 44:43.520
Now, in instance itself,

44:43.520 --> 44:45.200
we have two different types, okay?

44:45.200 --> 44:47.200
The first type of instance which we use

44:47.200 --> 44:48.640
is called as accessors.

44:48.640 --> 44:50.800
And the second type we use is mutators.

44:50.800 --> 44:52.880
So, we have accessors and mutators.

44:52.880 --> 44:54.080
Now, what is accessors?

44:54.080 --> 44:55.840
So, if you are only fetching the value,

44:55.840 --> 44:57.600
see ultimately, when you talk about this method,

44:57.600 --> 45:00.000
they are only responsible to work with variables, right?

45:00.000 --> 45:01.840
Which is your instance variables.

45:01.840 --> 45:04.640
So, if you want to just fetch the value of the instance variable,

45:04.640 --> 45:06.400
we will be using accessors.

45:06.400 --> 45:07.840
If you want to modify the value,

45:07.840 --> 45:09.360
you will use mutators.

45:09.360 --> 45:10.560
So, the way you do that example,

45:10.560 --> 45:12.720
but if you want to fetch the value of m1.

45:12.720 --> 45:14.640
So, if you want to know the value for m1,

45:14.640 --> 45:15.440
you can fetch directly,

45:15.440 --> 45:17.360
you can say print s1.m1,

45:17.360 --> 45:18.960
you will get the value like this.

45:18.960 --> 45:20.880
Or, instead of using the variables,

45:20.880 --> 45:22.320
we should actually use methods.

45:22.320 --> 45:23.440
So, what we'll do here is,

45:23.440 --> 45:26.960
we'll say def and we'll define the function as get m1.

45:26.960 --> 45:29.600
So, we'll say get m1 and which m1 you want.

45:29.600 --> 45:30.560
So, you will say return,

45:30.560 --> 45:33.200
I want to return the value for self.m1.

45:33.200 --> 45:33.840
This is how you do it.

45:33.840 --> 45:35.040
So, if you want the value for m1,

45:35.040 --> 45:37.280
you will say get m1 and you've got the value.

45:37.280 --> 45:40.080
Normally, it's not compulsion to have that get keyword there.

45:40.080 --> 45:41.760
You can also say m1, that's fine.

45:41.760 --> 45:43.360
But, when you write a code conventionally,

45:43.360 --> 45:44.960
you simply specify get there.

45:44.960 --> 45:46.400
So, whether you say get methods

45:46.400 --> 45:48.000
or in fact, to set the value,

45:48.000 --> 45:48.960
we use set methods.

45:48.960 --> 45:51.040
Example, if you want to set the value for m1,

45:51.040 --> 45:53.280
you will say set m1.

45:53.280 --> 45:55.360
Of course, we are passing that from a constructor.

45:55.360 --> 45:56.880
So, we can say set m1

45:56.880 --> 45:57.920
and you can pass some values here.

45:57.920 --> 45:59.120
I would pass a value f.

45:59.120 --> 46:00.000
I will say a value.

46:00.000 --> 46:02.000
And this value will be assigned to m1.

46:02.000 --> 46:05.040
So, we'll say self.m1 is equal to value.

46:05.040 --> 46:06.880
So, you can use constructor to pass the value

46:06.880 --> 46:08.480
or we can use setters, right?

46:08.480 --> 46:11.040
So, we have get methods and we have set methods.

46:11.040 --> 46:11.920
Now, for different variables,

46:11.920 --> 46:14.240
we'll be having different get and set methods, right?

46:14.240 --> 46:15.360
So, if you have three variables,

46:15.360 --> 46:18.000
you might be using three get methods and three set methods.

46:18.000 --> 46:20.720
And that's why they're called as getters and setters, right?

46:20.720 --> 46:23.200
So, getters get the value, setters set the value.

46:23.200 --> 46:24.640
Getters only fetch the value.

46:24.640 --> 46:25.600
It will not change the value.

46:25.600 --> 46:27.120
That's why we say accessors.

46:27.120 --> 46:28.320
Setters, they change the value

46:28.320 --> 46:29.760
and that's why we say mutators.

46:29.760 --> 46:30.560
So, this makes sense.

46:30.560 --> 46:32.320
Whether you can call this method, right?

46:32.320 --> 46:33.200
But, this works.

46:33.200 --> 46:34.880
Now, once you talked about instance,

46:34.880 --> 46:37.200
the second type we have is a class method.

46:37.200 --> 46:38.480
Now, why we use class method?

46:38.480 --> 46:40.720
See, if you talk about these variables, m1, m2, m3,

46:40.720 --> 46:42.880
those are your instance variable, right?

46:42.880 --> 46:45.760
An instance variable can be used with instance methods.

46:45.760 --> 46:46.560
What about this one?

46:46.560 --> 46:47.440
This is cool, right?

46:47.440 --> 46:49.600
Now, school is basically your class variable.

46:49.600 --> 46:51.040
And if you want to work with class variable,

46:51.040 --> 46:52.800
you need to use a class method.

46:52.800 --> 46:53.680
And the way you do that,

46:53.680 --> 46:55.520
let's say I want to know the info of a student.

46:55.520 --> 46:57.120
So, I will set def info.

46:57.120 --> 46:59.200
Info will print the name of the school, okay?

46:59.200 --> 47:00.800
So, let's say if you are studying for Therisco,

47:00.800 --> 47:02.240
it will print Therisco.

47:02.240 --> 47:04.560
And of course, all the students belong to same school, right?

47:04.560 --> 47:06.480
If you change the school name for one student,

47:06.480 --> 47:07.440
it will affect all the students.

47:07.440 --> 47:10.400
For example, this channel name earlier was NavinSkills, right?

47:10.400 --> 47:11.840
And we have changed it to Therisco.

47:11.840 --> 47:14.800
So, if the name changes for one subscriber,

47:14.800 --> 47:16.320
it will affect all the subscribers, right?

47:16.320 --> 47:17.440
And that's what is happening here.

47:17.440 --> 47:20.000
So, if I want to print info and that to a school name,

47:20.000 --> 47:21.360
I don't want marks here.

47:21.360 --> 47:23.280
Of course, we don't want to work with self.

47:23.280 --> 47:25.040
We want to work with class, right?

47:25.040 --> 47:26.880
So, if you are working with instance,

47:26.880 --> 47:28.560
you will use a self keyword.

47:28.560 --> 47:30.320
If you are working with a class variable,

47:30.320 --> 47:32.960
you have to use class, CLS, okay?

47:32.960 --> 47:35.040
It should be CLS, it should not be something else.

47:35.040 --> 47:37.280
Now, once you got that, you can simply print the value.

47:37.280 --> 47:40.160
So, you can say print or you can return the value, your choice.

47:40.160 --> 47:43.200
We can say return CLS.school.

47:43.200 --> 47:43.760
That's how you do it.

47:43.760 --> 47:45.200
So, you have to say CLS.school.

47:45.200 --> 47:47.200
So, whenever you want to work with class variable,

47:47.200 --> 47:49.120
you have to say CLS.school.

47:49.120 --> 47:51.120
Okay, but then how do you call info?

47:51.120 --> 47:51.840
It's very simple.

47:51.840 --> 47:55.120
You will say print S1.info.

47:55.120 --> 47:57.440
We can do that, but there's only one problem.

47:57.440 --> 47:59.120
Info should work with all the objects, right?

47:59.120 --> 48:00.640
It's not specific to one object.

48:00.640 --> 48:04.160
So, instead of using S1, we can use a student.info.

48:04.160 --> 48:05.040
Now, this should work.

48:05.040 --> 48:05.760
Let's try.

48:05.760 --> 48:06.880
I will say run.

48:06.880 --> 48:08.080
Oh, we got an error.

48:08.080 --> 48:11.360
It says, inform is seeing one required potential argument,

48:11.360 --> 48:13.520
which is a position argument, which is CLS.

48:13.520 --> 48:15.360
Oh, we have to pass CLS.

48:15.360 --> 48:15.920
That's weird.

48:15.920 --> 48:17.280
I don't want to pass CLS, right?

48:17.280 --> 48:19.120
In fact, we are not even doing that for average.

48:19.120 --> 48:20.400
We are not passing S1.

48:20.400 --> 48:22.320
Here also, I don't want to pass thing.

48:22.320 --> 48:23.520
Normally, what happens, you know,

48:23.520 --> 48:25.600
if you want to create a class method,

48:25.600 --> 48:29.120
we need to use a special symbol or special way of doing that.

48:29.120 --> 48:31.440
And we can use something called decorators.

48:31.440 --> 48:32.800
So, we have to say add rate.

48:32.800 --> 48:34.800
And you have to mention this as a class method.

48:34.800 --> 48:36.880
Again, we'll talk about decorators later in detail.

48:36.880 --> 48:39.680
But time being, we got a class method as decorator.

48:39.680 --> 48:42.560
So, if you want to use info as a class method,

48:42.560 --> 48:44.560
you have to say at class method, okay?

48:44.560 --> 48:45.360
That's how you define it.

48:45.360 --> 48:47.200
So, let's run this code now and it works.

48:47.200 --> 48:48.720
You can see that we got the disco there.

48:48.720 --> 48:49.760
Quite simple, right?

48:49.760 --> 48:51.440
So, now we know about instance method

48:51.440 --> 48:53.200
because it works with instance variables.

48:53.200 --> 48:54.640
Now, we know about class method

48:54.640 --> 48:56.320
because it works with class variables.

48:56.320 --> 48:57.600
How about static methods?

48:57.600 --> 48:58.480
See, think about this.

48:58.480 --> 49:00.080
Let's say if you want any method, okay?

49:00.080 --> 49:01.680
It doesn't matter what method we want here.

49:01.680 --> 49:05.840
If you want a method which has nothing to do with instance variable,

49:05.840 --> 49:08.560
which has nothing to do with the class variables,

49:08.560 --> 49:10.000
we want to do something extra, okay?

49:10.000 --> 49:12.800
So, something different which is not concerned with the variables.

49:12.800 --> 49:15.760
At that time, you will be using a static method

49:15.760 --> 49:17.920
because we are not concerned about instance variable.

49:17.920 --> 49:19.840
We are not concerned about class variables.

49:19.840 --> 49:23.520
Example, let's say I want to print the info about this class, okay?

49:23.520 --> 49:24.960
Not about student, but the class.

49:24.960 --> 49:27.840
So, I will say def about, you know, in fact,

49:27.840 --> 49:29.600
instead of saying info for class,

49:29.680 --> 49:31.120
I would say get school name.

49:31.120 --> 49:32.320
That will make more sense.

49:32.320 --> 49:35.360
So, I'm changing the name from info to get school for class method, okay?

49:35.360 --> 49:36.080
Not for this.

49:36.080 --> 49:37.360
And let me also change from here.

49:37.360 --> 49:38.400
So, we'll say get school.

49:38.400 --> 49:39.760
Here, I will define a function

49:39.760 --> 49:41.200
and the function name will be info

49:41.200 --> 49:43.920
because when I say info, I want to know the class name, okay?

49:43.920 --> 49:46.160
So, this is not related to the object.

49:46.160 --> 49:48.560
This is not related to class as I will keep it blank, okay?

49:48.560 --> 49:51.440
So, if you don't want to relate this to a class, keep it blank.

49:51.440 --> 49:54.480
If you don't want to relate this to an object, keep it blank.

49:54.480 --> 49:55.680
No self, no class, okay?

49:55.680 --> 49:56.400
Static method.

49:56.400 --> 49:57.360
And this will return.

49:57.360 --> 49:58.080
This will print.

49:58.080 --> 49:59.360
In fact, not return, this will print.

49:59.360 --> 50:00.480
We can do whatever you want.

50:00.480 --> 50:04.000
So, we can say this is student class.

50:04.000 --> 50:04.720
You can do that, right?

50:04.720 --> 50:06.320
So, we are printing this is student class

50:06.320 --> 50:08.720
and in ABC module.

50:08.720 --> 50:09.040
That's it.

50:09.040 --> 50:10.080
You can print whatever you want.

50:10.080 --> 50:12.480
As I mentioned, important is this method

50:12.480 --> 50:14.480
is nothing to do with the class variables

50:14.480 --> 50:15.680
and the instance variable.

50:15.680 --> 50:16.960
Now, where it will be useful.

50:16.960 --> 50:19.520
So, let's say if you want to perform any operation

50:19.520 --> 50:21.120
which has something to do with the other objects

50:21.120 --> 50:23.200
or the class objects, we can use static methods here.

50:23.200 --> 50:24.480
Or if you want to perform some operation

50:24.480 --> 50:26.400
like finding a factorial for number, right?

50:26.400 --> 50:28.000
Because the factorial has nothing to do

50:28.000 --> 50:29.680
with the class variables or instance variable.

50:29.680 --> 50:30.800
Maybe you're passing a value.

50:30.800 --> 50:32.880
You just want to know what's the factor of the number.

50:32.880 --> 50:34.240
You can use static methods there.

50:34.240 --> 50:36.240
Now, since we are using a static method,

50:36.240 --> 50:39.120
we need to use a special decorator here as well.

50:39.120 --> 50:40.880
So, we have to say any guess.

50:40.880 --> 50:42.480
We will be using static method.

50:42.480 --> 50:44.640
So, for class method, we have to say class method

50:44.640 --> 50:46.880
and for static method, we have to use static method, okay?

50:46.880 --> 50:48.160
And then you can call it.

50:48.160 --> 50:50.480
So, you can say, you have to use a class name.

50:50.480 --> 50:52.640
So, you will say student dot info, right?

50:52.640 --> 50:53.280
So, this is static.

50:53.280 --> 50:54.400
So, you don't have to pass anything.

50:54.400 --> 50:55.920
Not even class and not even object.

50:55.920 --> 50:57.600
Let's run this code and it works.

50:57.600 --> 50:58.080
Okay?

50:58.080 --> 51:00.000
So, basically, we have different types of methods.

51:00.000 --> 51:02.400
We have instance method which works with instance variable.

51:02.400 --> 51:05.920
Class method works with class variable and static works with nothing.

51:05.920 --> 51:08.320
It has, if you want to do something extra with a class,

51:08.320 --> 51:10.640
nothing to do with class variables or instance variables,

51:10.640 --> 51:11.360
go with static.

51:16.160 --> 51:18.800
Now, to this point, we have talked about different types of variables

51:18.800 --> 51:21.200
and we have talked about different types of methods, right?

51:21.200 --> 51:24.320
So, we can write variable and methods instead of class, right?

51:24.320 --> 51:27.040
So, a class will have variables and methods.

51:27.040 --> 51:30.640
The question is, can we have a class inside a class?

51:30.640 --> 51:31.760
That sounds weird, right?

51:31.760 --> 51:33.920
Why would anyone want to have a class inside a class?

51:33.920 --> 51:35.120
So, let's try to understand that.

51:35.120 --> 51:38.720
So, let's say I have a class here and this class name is student,

51:38.720 --> 51:40.800
as usual, the way we have done earlier.

51:40.800 --> 51:43.520
And when we talk about students, we have different types of variables, right?

51:43.520 --> 51:45.040
Let me define that function first.

51:45.040 --> 51:47.600
And the variables which I want here is self.

51:47.600 --> 51:48.880
First, I want a name.

51:48.880 --> 51:50.800
Of course, in the last example, we have taken marks,

51:50.800 --> 51:52.480
but here, let's take something different.

51:52.480 --> 51:55.920
I would take a name of a person and that will be coming from a user,

51:55.920 --> 51:57.760
of course, or from when you create an object.

51:57.760 --> 51:58.480
We'll say name.

51:58.480 --> 52:01.680
The second thing I want is roll number and I want these two details.

52:01.680 --> 52:05.200
And then I will assign name here and I will say self.roll number.

52:05.200 --> 52:06.560
Now, we have used to it, right?

52:06.560 --> 52:08.560
So, I would say roll number, right?

52:08.560 --> 52:11.760
Now, once we got these two variables, what I want is I want to print them.

52:11.760 --> 52:15.200
The way you print these values is by defining some functions, right?

52:15.200 --> 52:16.800
Of course, you can do that directly.

52:16.800 --> 52:18.320
Example, if I create an object here.

52:18.320 --> 52:21.520
So, let's say the object is S1 and I will say student.

52:21.520 --> 52:23.840
And when you create this object, you have to pass values as well, right?

52:23.840 --> 52:27.520
The first one I want is navin and roll number is let's say 2.

52:27.520 --> 52:30.960
The second object we want here is S2 and we'll say student,

52:30.960 --> 52:32.560
in which we'll be having two things.

52:32.560 --> 52:36.880
Of course, I would say this is Jenny and the roll number is let's say 3.

52:36.880 --> 52:39.920
So, I have navin and we have Jenny here, we got 2 and 3.

52:39.920 --> 52:41.600
Okay, so let's say I want to print.

52:41.600 --> 52:42.960
I want to print S1.

52:42.960 --> 52:45.520
So, I want to print all the details about S1, okay?

52:45.520 --> 52:47.360
I want to print the name and roll number.

52:47.360 --> 52:53.120
So, the way you do that is by saying S1.name and we can say S1.roll number.

52:53.200 --> 52:54.800
So, this is how you can print the values, right?

52:54.800 --> 52:56.400
Let me run this code and you can say it works.

52:56.400 --> 52:58.240
We got the details about S1.

52:58.240 --> 53:01.680
Now, what I want to do is I don't want to, see, this doesn't look good, right?

53:01.680 --> 53:04.400
What you should be saying is you should say S1.show.

53:04.400 --> 53:07.920
So, when I say S1.show, it should print all the details about S1.

53:07.920 --> 53:10.880
Maybe it has roll number, name or different variables, right?

53:10.880 --> 53:13.680
So, of course, we need to define that function or method here.

53:13.680 --> 53:15.120
So, we'll set F, show.

53:15.120 --> 53:20.080
So, this will print self.name and we'll print self.roll number.

53:20.080 --> 53:21.520
So, we are printing these two data, right?

53:21.520 --> 53:24.000
It should work. Let's run this code and you can see we got the same data.

53:24.000 --> 53:26.720
Now, let's say student also has a laptop.

53:26.720 --> 53:27.280
Of course, right?

53:27.280 --> 53:29.920
When you say you are doing IT, in fact, we have done that, right?

53:29.920 --> 53:31.520
So, you are a student of Therisco.

53:31.520 --> 53:34.800
You will be using a laptop to run your code or the extra doesn't matter.

53:34.800 --> 53:36.720
And let's say we want laptop here.

53:36.720 --> 53:39.200
So, of course, I want to know which laptop we are using.

53:39.200 --> 53:40.400
So, I want to know your config.

53:40.400 --> 53:44.560
Now, in that case, I will also ask a user, hey, tell me which laptop you are using.

53:44.560 --> 53:47.680
The problem is when you talk about laptop, there are different things important, right?

53:47.680 --> 53:48.880
It's not just about brand.

53:48.880 --> 53:51.120
You will not simply say, hey, I have HP laptop.

53:51.120 --> 53:52.320
I have a Lenovo laptop.

53:52.320 --> 53:55.200
You will also mention the configuration, maybe CPU and RAM.

53:55.200 --> 53:56.080
That's very important.

53:56.080 --> 53:59.200
Maybe any i5 CPU with, let's say, 8GB RAM is enough.

53:59.200 --> 54:00.560
So, I want to know your config.

54:00.560 --> 54:01.360
So, what you will do?

54:01.360 --> 54:03.040
Will you pass three variables?

54:03.040 --> 54:07.760
Like, you will pass a brand, HP, and then you will also pass the CPU,

54:07.760 --> 54:12.160
which you are using, let's say i5, or you will also pass, let's say, RAM of 8GB.

54:12.160 --> 54:13.200
Yes, you can do that, okay?

54:13.200 --> 54:14.960
So, I have to accept these variables here.

54:14.960 --> 54:16.640
I have to accept that here, right?

54:16.640 --> 54:17.680
And we can do that.

54:17.680 --> 54:19.920
The other option which we have is different, okay?

54:19.920 --> 54:23.600
So, the other option which we can do here is, we can create a class, okay?

54:23.600 --> 54:29.200
We can create a supply class as laptop, or instead of creating a class outside the student,

54:29.200 --> 54:31.040
we can also create a laptop inside student.

54:31.040 --> 54:33.760
So, a laptop will be only used by student, and in this case.

54:33.760 --> 54:35.760
So, I will say a class and I will say laptop.

54:35.760 --> 54:40.160
So, we are creating a laptop class inside a student, so that we can get that group, okay?

54:40.160 --> 54:44.240
So, we have to also set depth here, and we have to say init, right?

54:44.240 --> 54:45.520
And then let's create a variable.

54:45.520 --> 54:49.200
So, the first variable we need here is brand, and let's say the brand is HP.

54:49.280 --> 54:50.320
That's the first thing we need.

54:50.320 --> 54:52.960
Second thing we need is the CPU which you are working with.

54:52.960 --> 54:56.720
I would say CPU is i5, and the third one is RAM.

54:56.720 --> 54:57.440
Let's say aGB RAM.

54:57.440 --> 54:58.880
So, we got these three things, right?

54:58.880 --> 55:00.400
Now, we got these three variables.

55:00.400 --> 55:02.080
And where to create the object of it?

55:02.080 --> 55:04.400
So, we can create the object here itself.

55:04.400 --> 55:07.760
So, we can create the object inside the init, and normally that's what we do.

55:07.760 --> 55:11.840
So, if you want to create the object of laptop, we should be creating that object inside the

55:11.840 --> 55:12.800
outer class, okay?

55:12.800 --> 55:16.080
So, the object of laptop will be inside the student class.

55:16.080 --> 55:17.280
The way to do that is very simple.

55:17.360 --> 55:19.600
Here, you will say self.lap.

55:19.600 --> 55:22.320
You can create any variable you want, and you will say laptop.

55:22.320 --> 55:24.720
Or we are getting error, so we have to say self.laptop.

55:24.720 --> 55:25.440
Okay, this works.

55:25.440 --> 55:28.480
So, you can see in the constructor itself, you can define a variable.

55:28.480 --> 55:31.920
So, in the outer class, you can define a variable lab, and you can define the object.

55:31.920 --> 55:36.960
So, if you really want to use a laptop, you have to say the student object.lap.

55:36.960 --> 55:41.760
Example, outside, if I want to use it, I will say s1.lap.

55:41.760 --> 55:43.280
Whatever brand you want to fetch.

55:43.280 --> 55:47.120
So, you cannot simply say lab.brand, you have to say s1.lab.brand.

55:47.120 --> 55:49.680
Because the lab object is inside the student class.

55:49.680 --> 55:50.560
This is one way.

55:50.560 --> 55:52.800
What if you want to create another object of it?

55:52.800 --> 55:54.080
Let's say I don't want lab.

55:54.080 --> 55:54.400
I want...

55:54.400 --> 55:57.680
So, you can simply say lab1 is equal to s1.lab.

55:57.680 --> 55:59.440
You can get another object for s2.

55:59.440 --> 56:02.720
You can say lab2 is equal to s2.lab.

56:02.720 --> 56:05.200
Because for every object, you will get different laptop object.

56:05.200 --> 56:06.800
Okay, trust me, this is how it works.

56:06.800 --> 56:08.400
In fact, you can also check that.

56:08.400 --> 56:09.840
We got two different laptop objects here.

56:09.840 --> 56:10.960
We will print lab1.

56:10.960 --> 56:11.760
And let's print laptop.

56:11.760 --> 56:13.520
So, let's print the ideas of lab1, lab2.

56:13.520 --> 56:14.720
We got two different objects here.

56:14.720 --> 56:15.600
So, this works.

56:15.600 --> 56:16.000
Okay?

56:16.000 --> 56:17.760
This is where you create inner class.

56:17.760 --> 56:18.000
Okay?

56:18.000 --> 56:21.520
So, we have a laptop as an inner class of a student.

56:21.520 --> 56:22.000
Right?

56:22.000 --> 56:23.920
You could have done the outer class as well.

56:23.920 --> 56:26.400
I mean, you could have created different classes that you want that works.

56:26.400 --> 56:30.720
But sometime, when you know that this class will be used only for student, nothing else,

56:30.720 --> 56:32.720
then you don't have to create a separate file for that.

56:32.720 --> 56:34.480
You can do that in student class itself.

56:34.480 --> 56:36.480
Now, can I directly create the object outside?

56:36.480 --> 56:39.360
Let's say I don't want to get an object of laptop inside the student class.

56:39.360 --> 56:40.880
Can we do it outside directly?

56:40.880 --> 56:41.360
Let's try.

56:41.360 --> 56:43.760
So, I will say lab1 is equal to...

56:43.760 --> 56:45.760
I will say student.laptop.

56:45.760 --> 56:46.800
Now, why student here?

56:46.800 --> 56:49.120
Because you cannot simply access laptop directly.

56:49.120 --> 56:49.280
Right?

56:49.280 --> 56:51.920
Because laptop class belongs to a student class.

56:51.920 --> 56:55.360
So, we have to always say student.laptop constructor.

56:55.360 --> 56:57.280
You cannot simply create laptop directly.

56:57.280 --> 56:57.520
Okay?

56:57.520 --> 56:58.720
So, this is one thing you have to remember.

56:58.720 --> 57:02.640
You can create the object of inner class inside outer class.

57:02.640 --> 57:05.280
Or you can do that outside the outer class provided.

57:05.280 --> 57:06.720
You are using the outer class name.

57:06.720 --> 57:08.160
So, you have to say student.laptop.

57:08.160 --> 57:08.320
Okay?

57:08.320 --> 57:08.960
This works.

57:08.960 --> 57:11.840
In fact, just to enhance the example, what I will also do is,

57:11.920 --> 57:15.360
we can create a show method for a laptop as well.

57:15.360 --> 57:16.880
So, we can say show for laptop.

57:16.880 --> 57:18.480
And you can see we have two show methods.

57:18.480 --> 57:19.840
One is student and one is laptop.

57:19.840 --> 57:20.080
Okay?

57:20.080 --> 57:23.120
So, in such student, we have show method inside laptop.

57:23.120 --> 57:23.840
Also, we have show.

57:23.840 --> 57:25.520
But these are two different show methods.

57:25.520 --> 57:28.960
The show method of student will print the data about a student.

57:28.960 --> 57:31.840
And the show method of laptop will print the show method of student.

57:31.840 --> 57:32.640
I know that makes it.

57:32.640 --> 57:33.120
That's weird.

57:33.120 --> 57:33.760
So, let's do that.

57:33.760 --> 57:40.800
So, I will say print self.brand, self.cpu, and self.ram.

57:40.800 --> 57:42.000
Okay? So, we are printing this data.

57:42.000 --> 57:44.400
So, this show is different from this show.

57:44.400 --> 57:46.080
Let me now print laptop here.

57:46.080 --> 57:46.800
Let me on this quote.

57:46.800 --> 57:50.160
And you can see it brings only the name and the roll number.

57:50.160 --> 57:51.360
I also want to print the laptop.

57:51.360 --> 57:52.400
Oh, you need the object, right?

57:52.400 --> 57:53.520
We have removed that statement.

57:53.520 --> 57:58.800
Because if you want to access laptop, you have to say self.lap is equal to laptop.

57:58.800 --> 58:00.400
But you have to say self.

58:00.400 --> 58:01.120
So, this is important.

58:01.120 --> 58:04.800
And after printing, this will call laptop show because we also want to do that.

58:04.800 --> 58:06.880
So, you will say self.laptop show.

58:06.880 --> 58:07.040
Okay?

58:07.040 --> 58:09.840
So, we are printing data about a student and laptop as well.

58:09.840 --> 58:10.560
So, this should work.

58:10.560 --> 58:12.400
Let's run this code and it worked.

58:12.400 --> 58:15.440
You can see we got data about a student and laptop as well.

58:15.440 --> 58:18.400
So, this is how you create the class inside a class.

58:23.440 --> 58:26.480
Now, in this video, we'll talk about inheritance.

58:26.480 --> 58:28.560
Now, we talk about a concept of oops, you know,

58:28.560 --> 58:30.880
where which is object-oriented programming.

58:30.880 --> 58:33.040
We have so many concepts to talk about.

58:33.040 --> 58:34.960
And one of them is inheritance.

58:34.960 --> 58:39.440
Now, in real life, what we have is we have this parent and child relationship, right?

58:39.440 --> 58:41.680
So, whatever belongs to your parents belongs to you.

58:41.680 --> 58:45.040
Example, if my father or mother has a phone, it's my phone, right?

58:45.040 --> 58:47.200
By default, my phone would be my phone.

58:47.200 --> 58:49.120
But my father's phone would be my phone, right?

58:49.120 --> 58:50.000
That's how it works.

58:50.000 --> 58:52.000
So, if your parent's house, it's your house.

58:52.000 --> 58:53.840
That's what we say inheritance, right?

58:53.840 --> 58:57.280
In the same concept, you can implement in programming as well.

58:57.280 --> 59:00.240
In fact, all the languages which follows oops concept,

59:00.240 --> 59:02.080
they do implement inheritance, right?

59:02.080 --> 59:04.320
And the way you do that is with the help of classes.

59:04.320 --> 59:05.760
Class inherit a class.

59:05.760 --> 59:06.400
Let's try that.

59:06.400 --> 59:09.120
What I'm talking about is, let's say if you have a class

59:09.200 --> 59:10.800
and class is a, okay?

59:10.800 --> 59:12.720
Again, it should be a logical name.

59:12.720 --> 59:15.360
So, you can go with employee class, you can go with student class,

59:15.360 --> 59:18.080
you can go with laptop class, whatever class you love.

59:18.080 --> 59:23.200
But time being, just for the example, we are going for class a and class b or class c.

59:23.200 --> 59:26.080
In future, we'll try to implement some other examples

59:26.080 --> 59:28.320
using different names and with proper example.

59:28.320 --> 59:31.600
But at this point, just to keep it simple, let's go for class a.

59:31.600 --> 59:35.360
Now, if we talk about this class a, this class a will have multiple features, right?

59:35.360 --> 59:37.120
Maybe we can define two methods here.

59:37.120 --> 59:38.320
So, we'll set definition there.

59:38.320 --> 59:42.000
The first method which I want to go for is, let's say feature one, okay?

59:42.000 --> 59:44.480
So, let's say we got this function which is feature one

59:44.480 --> 59:47.120
and this function does provide you something, okay?

59:47.120 --> 59:50.320
So, time being, we are printing feature one working.

59:50.320 --> 59:51.440
That's it, nothing much.

59:51.440 --> 59:53.840
Of course, it can be a complex code, but make it simple.

59:53.840 --> 59:55.040
Let's keep it that.

59:55.040 --> 59:56.560
And then we can have another feature here.

59:56.560 --> 59:57.760
Let me just copy paste this code.

59:57.760 --> 01:00:01.200
So, I will say copy and paste and this would be my feature two.

01:00:01.200 --> 01:00:05.200
So, we got feature one and feature two and this will point feature two is working.

01:00:05.200 --> 01:00:07.120
So, this class a has two features.

01:00:07.120 --> 01:00:08.960
We got feature one, feature two, right?

01:00:08.960 --> 01:00:12.160
And the way you can access them is with the help of object, right?

01:00:12.160 --> 01:00:13.840
And the way you create an object is very simple.

01:00:13.840 --> 01:00:17.840
You simply say a one is equal to a, that's how you create the object, right?

01:00:17.840 --> 01:00:19.280
Where a is your constructor.

01:00:19.280 --> 01:00:22.640
Again, you can define that in it method here, but not needed at this point.

01:00:22.640 --> 01:00:23.520
So, this will work.

01:00:23.520 --> 01:00:27.040
And using this a one, you can call feature one, you can call feature two, right?

01:00:27.040 --> 01:00:31.360
So, you can say a one dot feature one and a one dot feature two.

01:00:31.360 --> 01:00:32.160
And this will work.

01:00:32.160 --> 01:00:35.120
Let me just run this code and you can see we got feature one working,

01:00:35.120 --> 01:00:35.920
feature two working.

01:00:35.920 --> 01:00:37.360
So, this code is working.

01:00:37.360 --> 01:00:40.640
Now, what I'm excited about is, let's say we have one more class.

01:00:40.640 --> 01:00:42.000
Let's talk about class B.

01:00:42.000 --> 01:00:44.080
So, let me just create a class B here itself.

01:00:44.080 --> 01:00:46.240
So, here I will say class B.

01:00:46.240 --> 01:00:48.160
And class B will also have two features.

01:00:48.160 --> 01:00:50.800
I will name this as feature three and feature four.

01:00:50.800 --> 01:00:53.280
Instead of typing them, let me just copy paste the code here.

01:00:53.280 --> 01:00:57.200
And we'll name this as feature three and feature four, right?

01:00:57.200 --> 01:00:59.600
See, normally what happens, you know, when you work on a project,

01:00:59.600 --> 01:01:01.440
of course, we have a very big team, right?

01:01:01.440 --> 01:01:04.240
So, example, if one person is defining a class, okay?

01:01:04.240 --> 01:01:07.520
In that class, we provide you four features or four methods.

01:01:07.520 --> 01:01:11.600
Maybe you want to define some other class in which you need some extra features

01:01:11.600 --> 01:01:14.160
and you also want the existing features.

01:01:14.160 --> 01:01:15.760
You don't have to really find it, right?

01:01:15.760 --> 01:01:16.560
You can use it.

01:01:16.560 --> 01:01:18.160
And the way you do that, you're simply saying,

01:01:18.160 --> 01:01:20.720
example, in this class B, we got two features, right?

01:01:20.720 --> 01:01:22.960
We got feature three, we got feature four.

01:01:22.960 --> 01:01:26.160
And of course, if I create the object of B one,

01:01:26.160 --> 01:01:28.640
so it's a B one is equal to B.

01:01:28.640 --> 01:01:30.960
And the functions which you can call using B one.

01:01:30.960 --> 01:01:33.840
So, if I say B one dot, you can see we got only two options.

01:01:33.840 --> 01:01:35.920
We got feature three and feature four, of course, right?

01:01:35.920 --> 01:01:38.480
Because in B class, we have only two features.

01:01:38.480 --> 01:01:42.000
What if you want to get the features of A as well?

01:01:42.000 --> 01:01:44.960
And that's where inheritance comes into picture.

01:01:44.960 --> 01:01:49.520
So, we can say, hey, this B is a child class of A, right?

01:01:49.520 --> 01:01:52.560
And the moment you say child class, it will import all the features.

01:01:52.560 --> 01:01:57.040
What I will say is this B is a child class or you can say subclass.

01:01:57.040 --> 01:01:59.120
We have different terminology we can use here.

01:01:59.120 --> 01:02:01.840
And we can simply say in the bracket, you can say A.

01:02:01.840 --> 01:02:06.240
So, this class B is inheriting all the features from A.

01:02:06.240 --> 01:02:07.200
And we got it, right?

01:02:07.200 --> 01:02:10.000
Just writing that one thing, you know, just bracket A.

01:02:10.000 --> 01:02:13.040
We are saying B is inheriting the features from A,

01:02:13.040 --> 01:02:16.080
which means with the object of B, which is B one in this case,

01:02:16.080 --> 01:02:18.720
the moment I say B one dot, see the options.

01:02:18.720 --> 01:02:21.840
You can access feature one, feature two, feature three and feature four.

01:02:21.840 --> 01:02:24.320
And that's the importance of inheritance,

01:02:24.320 --> 01:02:27.600
which simply means if you already have a class which provides you some feature,

01:02:27.600 --> 01:02:30.720
and in future, if you want to create your own classes,

01:02:30.720 --> 01:02:34.720
in which you want to use those features, you just need to inherit them, right?

01:02:34.720 --> 01:02:36.240
So, we can use some terminologies here.

01:02:36.240 --> 01:02:40.640
We can say superclass, subclass, or we can say parent class or child class.

01:02:40.640 --> 01:02:42.960
So, timing will refer them as superclass and subclass.

01:02:42.960 --> 01:02:48.160
So, super is a class which is A and a class which inherits the class,

01:02:48.160 --> 01:02:49.840
we will call them as subclass.

01:02:49.840 --> 01:02:52.240
So, B is subclass and A is superclass.

01:02:52.240 --> 01:02:54.720
So, that's the concept about inheritance.

01:02:54.720 --> 01:02:58.320
Now, this is also called as a single level inheritance.

01:02:58.320 --> 01:02:59.840
We have some other types as well.

01:02:59.840 --> 01:03:02.160
We also have a multi-level inheritance.

01:03:02.160 --> 01:03:03.040
Now, what it means?

01:03:03.040 --> 01:03:04.800
Example, let's say if I have another class here,

01:03:04.800 --> 01:03:07.920
let me get one more class here, and this class is let's say C.

01:03:07.920 --> 01:03:11.760
So, we'll call this class C or this class C inherits B.

01:03:11.760 --> 01:03:14.960
Now, what will happen is whatever you do in this class, let's say timebin,

01:03:14.960 --> 01:03:17.600
I will define only one feature here, we'll say feature five.

01:03:17.600 --> 01:03:19.440
You can see how lazy I am.

01:03:19.440 --> 01:03:21.600
So, this is feature five working, right?

01:03:21.600 --> 01:03:23.680
So, we got C class which has only one feature.

01:03:23.680 --> 01:03:28.320
But the moment you create an object for C one, so I will say C one is equal to C.

01:03:28.400 --> 01:03:31.280
The moment I say C one dot, see the methods you can use.

01:03:31.280 --> 01:03:32.640
So, we can use feature one now.

01:03:32.640 --> 01:03:34.960
So, feature one feature two are coming from A, right?

01:03:34.960 --> 01:03:36.560
But C is only extending B.

01:03:36.560 --> 01:03:37.440
So, that's our relationship.

01:03:37.440 --> 01:03:40.480
We have grandparent, we have parent, and then we have child, right?

01:03:40.480 --> 01:03:45.360
So, a child can access all the features from parent, grandparent, great grandparent, right?

01:03:45.360 --> 01:03:46.320
So, that's how it works.

01:03:46.320 --> 01:03:47.360
Okay, this is working, right?

01:03:47.360 --> 01:03:50.240
So, we got single where you have one superclass, one subclass,

01:03:50.240 --> 01:03:53.040
then we have multi-level where you have superclass, subclass,

01:03:53.040 --> 01:03:54.800
and then I get subclass of that superclass.

01:03:54.800 --> 01:03:55.760
Okay, this is working.

01:03:55.760 --> 01:03:57.520
What if you go for multiple?

01:03:57.520 --> 01:03:58.880
What is multiple here?

01:03:58.880 --> 01:04:01.840
Let's say the C is not only taking from A and B.

01:04:01.840 --> 01:04:03.280
We got some other class as well.

01:04:03.280 --> 01:04:08.000
Just for time being, what I will do is I will say B is not inheriting A, okay?

01:04:08.000 --> 01:04:10.160
So, A and B, they are two different classes.

01:04:10.160 --> 01:04:11.840
Nothing, they are not related to each other.

01:04:11.840 --> 01:04:14.400
A provides two features, B provides two features, okay?

01:04:14.400 --> 01:04:16.240
So, there's no relationship between A and B.

01:04:16.240 --> 01:04:18.080
They are two different classes.

01:04:18.080 --> 01:04:21.360
C says, I want to access features from both, from A and B.

01:04:21.360 --> 01:04:24.240
So, in this case, the C will inherit from A and B both.

01:04:24.240 --> 01:04:25.600
So, you will say A, B.

01:04:25.680 --> 01:04:28.400
So, C will copy from both, or C will inherit from both.

01:04:28.400 --> 01:04:29.520
So, we will say C1.

01:04:29.520 --> 01:04:32.080
The moment you say C1, you can see you can access all the features.

01:04:32.080 --> 01:04:33.440
That's not the case with B1 now.

01:04:33.440 --> 01:04:36.560
B1 can only access two features, feature three and feature four,

01:04:36.560 --> 01:04:40.000
because B is not inheriting A, okay?

01:04:40.000 --> 01:04:40.640
Point to remember.

01:04:40.640 --> 01:04:42.960
So, we got A, we got B, and then we got C.

01:04:42.960 --> 01:04:45.680
C is inheriting both the classes, A and B.

01:04:45.680 --> 01:04:47.520
So, this is called as multi-pull.

01:04:47.520 --> 01:04:49.120
So, this is your multi-pull, right?

01:04:49.120 --> 01:04:51.840
So, we have done with single, we have done with multi-level,

01:04:51.840 --> 01:04:53.360
and then we have multi-pull.

01:04:53.440 --> 01:04:55.280
This is how we can work with inheritance.

01:05:00.080 --> 01:05:03.280
Now, to this point, we have talked about OOPS concept, right?

01:05:03.280 --> 01:05:05.760
In which we have seen inheritance, right?

01:05:05.760 --> 01:05:06.720
Now, what is inheritance?

01:05:06.720 --> 01:05:11.520
If you already have some classes, and if you want to use the existing features,

01:05:11.520 --> 01:05:16.000
you will simply say class B, which will take the features from A, right?

01:05:16.000 --> 01:05:18.240
So, class B inherits A.

01:05:18.240 --> 01:05:21.600
Or you can go with a concept of multiple inheritance,

01:05:21.600 --> 01:05:24.800
where one class will extend from two different classes,

01:05:24.800 --> 01:05:26.400
or more than two classes, right?

01:05:26.400 --> 01:05:28.560
So, in this case, we have class A, class B,

01:05:28.560 --> 01:05:31.840
and then we have class C, which has a feature five,

01:05:31.840 --> 01:05:33.840
but it is also inheriting A and B.

01:05:33.840 --> 01:05:36.080
So, we can say C has five features, right?

01:05:36.080 --> 01:05:37.280
So, that makes sense.

01:05:37.280 --> 01:05:39.840
Now, what we'll do in this video is we'll talk about two topics.

01:05:39.840 --> 01:05:44.400
The first one is the constructor in inheritance, how it behaves,

01:05:44.400 --> 01:05:49.680
and we'll also talk about method resolution order, or you can say MRO.

01:05:49.680 --> 01:05:51.200
So, let's start with the constructor.

01:05:51.200 --> 01:05:53.840
Timebin, let's ignore C, okay?

01:05:53.840 --> 01:05:56.640
So, let's say we don't have this C, so we'll ignore that part.

01:05:56.640 --> 01:06:00.160
And, in fact, we'll delete that part for timebin.

01:06:00.160 --> 01:06:04.960
And let's focus only on A and B, where B is inheriting A, okay?

01:06:04.960 --> 01:06:07.520
So, in total, in B, we have four features, right?

01:06:07.520 --> 01:06:09.920
Now, what happens is, if I create an object of A,

01:06:09.920 --> 01:06:13.520
so let's say if I say A1 is equal to constructor of A,

01:06:13.520 --> 01:06:14.400
so this will work, right?

01:06:14.400 --> 01:06:16.240
So, when you say A bracket, that's a constructor,

01:06:16.240 --> 01:06:18.400
it will call a method which is in it.

01:06:18.400 --> 01:06:21.120
Now, even if you don't define it, it is there somewhere, right?

01:06:21.120 --> 01:06:23.760
But let me define my own constructor, own init here.

01:06:23.760 --> 01:06:26.320
So, I will set def, and we'll define the init method,

01:06:26.320 --> 01:06:28.240
and this init method will print one stuff.

01:06:28.240 --> 01:06:31.200
So, I will say print in A init.

01:06:31.200 --> 01:06:33.200
Nothing much, we are not doing anything extra here,

01:06:33.200 --> 01:06:36.000
we are just printing in A init, that's it.

01:06:36.000 --> 01:06:36.640
Now, what do you think?

01:06:36.640 --> 01:06:37.360
What it will print?

01:06:37.360 --> 01:06:39.520
Of course, we are creating object of A, right?

01:06:39.520 --> 01:06:41.120
So, it will only execute A.

01:06:41.120 --> 01:06:44.000
See, with the object of A, you cannot access features of B, okay?

01:06:44.000 --> 01:06:46.480
So, even if I try example, if I say A1 dot,

01:06:46.480 --> 01:06:49.600
you can only access feature one and feature two.

01:06:49.600 --> 01:06:51.520
But yes, if you have an object of B,

01:06:51.520 --> 01:06:53.520
you can access all the features, right?

01:06:53.520 --> 01:06:54.880
Features from A and B,

01:06:54.880 --> 01:06:58.320
because B is a subclass and A is superclass.

01:06:58.320 --> 01:07:01.280
And as I mentioned, subclass can access all the features

01:07:01.280 --> 01:07:03.520
from superclass, but that's not vice versa, right?

01:07:03.520 --> 01:07:05.840
A superclass cannot access all the features of subclass,

01:07:05.840 --> 01:07:07.280
not even one feature of subclass.

01:07:07.280 --> 01:07:08.160
Okay, this is fun.

01:07:08.160 --> 01:07:10.640
Now, what if I create object of B?

01:07:10.640 --> 01:07:12.080
So, I'm not getting object of A here,

01:07:12.080 --> 01:07:12.800
I'm getting object of B.

01:07:12.800 --> 01:07:14.800
Doesn't matter what is A1 or B1,

01:07:14.800 --> 01:07:16.560
important is if I create an object,

01:07:16.560 --> 01:07:18.880
B, which call the constructor, that's the question,

01:07:18.880 --> 01:07:20.480
because we are not getting object of A,

01:07:20.480 --> 01:07:21.760
we are getting object of B.

01:07:21.760 --> 01:07:24.240
Will it call the constructor of A?

01:07:24.240 --> 01:07:24.880
That's the question.

01:07:24.880 --> 01:07:27.200
Let me just run this code and it works, okay?

01:07:27.200 --> 01:07:29.040
So, even if you have the object of B,

01:07:29.040 --> 01:07:32.240
it will still call the constructor of A, right?

01:07:32.240 --> 01:07:33.360
That's how it works.

01:07:33.360 --> 01:07:35.840
But what if you have your own constructor?

01:07:35.840 --> 01:07:38.080
What if you have your own init method?

01:07:38.080 --> 01:07:40.560
Example in B, see in B, we don't have that init, right?

01:07:40.560 --> 01:07:41.680
And that's why it is going up.

01:07:41.680 --> 01:07:45.280
So, let me repeat, since we don't have init inside B,

01:07:45.280 --> 01:07:47.440
that's why it is going to A.

01:07:47.520 --> 01:07:50.000
But what if you already have an init with you?

01:07:50.000 --> 01:07:52.080
So, I will simply copy paste here in B.

01:07:52.080 --> 01:07:54.160
So, both have init, but then in this,

01:07:54.160 --> 01:07:56.400
I will print in B init, right?

01:07:56.400 --> 01:07:58.640
So, in A, we are printing in A init,

01:07:58.640 --> 01:08:00.640
in B, we are printing in B init.

01:08:00.640 --> 01:08:01.680
So, this makes sense.

01:08:01.680 --> 01:08:03.680
Now, if I run this code, what it will print?

01:08:03.680 --> 01:08:06.960
It will print in A init or in B init.

01:08:06.960 --> 01:08:08.960
Of course, if you are getting object of B,

01:08:08.960 --> 01:08:11.360
it should only call the init of B, right?

01:08:11.360 --> 01:08:12.720
And let's see if that works.

01:08:12.720 --> 01:08:14.800
And let me just run this code and we are right.

01:08:14.800 --> 01:08:19.120
So, when you run the code, you can see we only got in B init.

01:08:19.120 --> 01:08:21.680
So, that means if you create an object of B,

01:08:21.680 --> 01:08:25.120
first it will try to find the init of B.

01:08:25.120 --> 01:08:27.200
If it is not there, then it will go for A.

01:08:27.200 --> 01:08:28.880
Okay, that's the point you have to remember.

01:08:28.880 --> 01:08:32.000
But what if you also want to call the init of A?

01:08:32.000 --> 01:08:32.800
Is it possible?

01:08:32.800 --> 01:08:35.040
I mean, if I create an object of B,

01:08:35.040 --> 01:08:38.160
can I call the init of both the classes?

01:08:38.160 --> 01:08:39.840
I mean A and B.

01:08:39.840 --> 01:08:41.840
See, by default, it will call only B, right?

01:08:41.840 --> 01:08:43.760
What if I want to call A as well?

01:08:43.840 --> 01:08:47.040
And that's where we have a very special keyword or a method,

01:08:47.040 --> 01:08:49.440
you can say, and that is super.

01:08:49.440 --> 01:08:50.720
So, with the help of super,

01:08:50.720 --> 01:08:53.840
so you can say super and it's a method, basically.

01:08:53.840 --> 01:08:55.680
So, you will say super dot.

01:08:55.680 --> 01:08:57.040
The moment you say super,

01:08:57.040 --> 01:08:59.840
you can access all the features of the parent class.

01:08:59.840 --> 01:09:01.120
So, you can say super dot init.

01:09:01.120 --> 01:09:03.040
So, what we are doing is we are trying to call

01:09:03.040 --> 01:09:05.200
an init method of class A.

01:09:05.200 --> 01:09:06.560
So, the moment you say super,

01:09:06.560 --> 01:09:08.960
you are representing the super class, okay?

01:09:08.960 --> 01:09:10.720
Which in this case, it is A.

01:09:10.720 --> 01:09:14.400
So, we are trying to call the init method of class A.

01:09:14.400 --> 01:09:15.440
That's important.

01:09:15.440 --> 01:09:16.560
And now, let's run this quote.

01:09:16.560 --> 01:09:18.080
And you can see we got both the output.

01:09:18.080 --> 01:09:21.440
We got in A end and we got in B end.

01:09:21.440 --> 01:09:24.080
So, point to remember is when you create an object of B,

01:09:24.080 --> 01:09:26.560
it will call the init of B first.

01:09:26.560 --> 01:09:27.920
And from the init of B,

01:09:27.920 --> 01:09:30.000
you are trying to call the init of A.

01:09:30.000 --> 01:09:31.200
So, it will jump up,

01:09:31.200 --> 01:09:32.960
it will execute the init of A first,

01:09:32.960 --> 01:09:34.960
which will print in A in it.

01:09:34.960 --> 01:09:37.600
And then it will come back to print in B in it, okay?

01:09:37.600 --> 01:09:39.040
That's why we got the output.

01:09:39.040 --> 01:09:40.080
So, this makes sense.

01:09:40.080 --> 01:09:43.120
So, we can work with constructor in inheritance, right?

01:09:43.120 --> 01:09:44.880
Now, let me add a twist here.

01:09:44.880 --> 01:09:47.600
So, what I will do is I will remove this super from here.

01:09:47.600 --> 01:09:48.480
Let's clean it.

01:09:48.480 --> 01:09:52.320
And I will not even say that this is B.

01:09:52.320 --> 01:09:54.960
So, class A and class B, two different things, okay?

01:09:54.960 --> 01:09:56.320
They're not linked with each other.

01:09:56.320 --> 01:09:57.360
But then we have class C.

01:09:57.360 --> 01:09:59.920
As we have done earlier, we'll say class C.

01:09:59.920 --> 01:10:04.640
And class C will inherit both the classes A and B, okay?

01:10:04.640 --> 01:10:08.320
And now, if I say def and init,

01:10:08.400 --> 01:10:10.160
you know what we are trying to do here.

01:10:10.160 --> 01:10:14.160
First of all, we'll print in C in it, okay?

01:10:14.160 --> 01:10:15.840
And then I will create the object of C.

01:10:15.840 --> 01:10:17.680
So, there's no object of A and B.

01:10:17.680 --> 01:10:18.720
I'm trying to object of C.

01:10:19.440 --> 01:10:20.160
Now, what do you think?

01:10:20.160 --> 01:10:24.000
Will it call the init of C or A or B?

01:10:24.000 --> 01:10:24.640
Of course, right?

01:10:24.640 --> 01:10:26.240
When you say the object is of C,

01:10:26.240 --> 01:10:28.480
it will call the init of C only.

01:10:28.480 --> 01:10:29.440
Let's run this code.

01:10:29.440 --> 01:10:30.080
And that's right.

01:10:30.080 --> 01:10:32.240
We got the output as in C in it.

01:10:32.240 --> 01:10:33.520
So, this works perfectly.

01:10:34.080 --> 01:10:37.360
But what if you want to call the init method

01:10:37.360 --> 01:10:38.640
of a superclass?

01:10:38.640 --> 01:10:40.240
But there's a twist here.

01:10:40.240 --> 01:10:42.320
Now, C has two superclasses, right?

01:10:42.320 --> 01:10:44.000
One is A and B.

01:10:44.000 --> 01:10:46.960
The moment you say super, dot init.

01:10:46.960 --> 01:10:48.080
Now, what do you think?

01:10:48.080 --> 01:10:49.280
Which init it will call?

01:10:49.280 --> 01:10:51.440
Will it call the init of A or B?

01:10:51.440 --> 01:10:52.480
That's a question.

01:10:52.480 --> 01:10:53.680
Let's run this and let's see what happens.

01:10:53.680 --> 01:10:54.880
The moment you run this code,

01:10:54.880 --> 01:10:56.880
you can see it says in A init.

01:10:56.880 --> 01:10:58.640
That means we are unfair here.

01:10:58.640 --> 01:11:00.160
We are biased towards A.

01:11:00.160 --> 01:11:02.240
We are not taking B here, right?

01:11:02.240 --> 01:11:04.000
This is completely wrong.

01:11:04.000 --> 01:11:06.960
Oh, but the thing is, we have a concept of MRO,

01:11:07.040 --> 01:11:09.840
which is method resolution order.

01:11:09.840 --> 01:11:10.720
So, what happens is,

01:11:10.720 --> 01:11:13.040
whenever you have this multiple inheritance,

01:11:13.040 --> 01:11:15.840
it will always start from left to right.

01:11:15.840 --> 01:11:17.360
Which means, so first,

01:11:17.360 --> 01:11:18.640
so the moment you say init,

01:11:18.640 --> 01:11:21.920
it will try to find the init of itself.

01:11:21.920 --> 01:11:23.520
So, since we have init here,

01:11:23.520 --> 01:11:25.360
it will execute the init of C.

01:11:25.360 --> 01:11:27.520
Then, the moment you say super, dot init,

01:11:27.520 --> 01:11:28.800
now we have two classes, right?

01:11:28.800 --> 01:11:29.760
A and B.

01:11:29.760 --> 01:11:31.360
And on the left side, we have A

01:11:31.360 --> 01:11:32.880
and on the right side, we have B.

01:11:32.880 --> 01:11:34.800
So, it will prefer left one first.

01:11:35.200 --> 01:11:37.200
It goes from left to right.

01:11:37.200 --> 01:11:38.800
And that's something you have to remember.

01:11:38.800 --> 01:11:41.920
It's always from left to right, okay?

01:11:41.920 --> 01:11:43.760
And that's why we got in A init.

01:11:43.760 --> 01:11:45.840
The same thing can be done for methods.

01:11:45.840 --> 01:11:48.560
Example, let's say, we have two methods which are same.

01:11:48.560 --> 01:11:51.360
So, in this case, you can see we have feature one in A

01:11:51.360 --> 01:11:52.880
and feature one in B.

01:11:52.880 --> 01:11:55.840
Both are the same methods with the same name, of course.

01:11:55.840 --> 01:11:58.240
And in this, I will print some different message.

01:11:58.240 --> 01:12:00.880
Here, I will print feature one A.

01:12:00.880 --> 01:12:03.280
And here, I will say feature one B.

01:12:03.280 --> 01:12:05.280
That means, the feature one is in A

01:12:05.280 --> 01:12:06.800
and feature one is in B.

01:12:06.800 --> 01:12:11.200
And now, if I try to call, so I will say A1 dot feature one.

01:12:11.200 --> 01:12:12.880
Will it call from A or B?

01:12:12.880 --> 01:12:14.960
That's a question and we know the answer, right?

01:12:14.960 --> 01:12:18.960
It will always call from A, because it goes from left to right.

01:12:18.960 --> 01:12:20.400
And you can see the output.

01:12:20.400 --> 01:12:21.440
So, this is something you have to remember,

01:12:21.440 --> 01:12:24.560
which is a concept of method resolution order.

01:12:24.560 --> 01:12:26.720
So, basically, in this video, we have talked about three things.

01:12:26.720 --> 01:12:30.640
The first one is how constructor behaves in inheritance.

01:12:30.640 --> 01:12:33.600
The second one is how to use that super method.

01:12:33.600 --> 01:12:38.160
And the third one is MRO, which is method resolution order.

01:12:38.160 --> 01:12:40.160
Now, in fact, with the help of super method,

01:12:40.160 --> 01:12:40.960
it can be called function.

01:12:40.960 --> 01:12:41.840
Let's see that.

01:12:41.840 --> 01:12:45.440
So, let's say from, we have a function here, which is def,

01:12:45.440 --> 01:12:47.360
and I will say feature, feed.

01:12:47.360 --> 01:12:48.080
That's it.

01:12:48.080 --> 01:12:52.160
And in this, I'm trying to call the method of super class, right?

01:12:52.160 --> 01:12:54.400
So, we can say super dot.

01:12:54.400 --> 01:12:55.680
And we can use that thing, okay?

01:12:55.680 --> 01:12:57.680
So, we can say super dot feature two.

01:12:57.680 --> 01:12:59.040
And let's see if it is working.

01:12:59.040 --> 01:13:00.400
Let me call feature.

01:13:00.400 --> 01:13:01.920
It should call the feature two.

01:13:01.920 --> 01:13:02.880
So, yes, it works.

01:13:02.880 --> 01:13:06.000
So, you can also use super method to call other methods as well,

01:13:06.000 --> 01:13:06.880
not just in it.

01:13:06.880 --> 01:13:10.320
So, to represent this super class, we use super method, okay?

01:13:15.280 --> 01:13:17.840
Now, we have started talking about objects, right?

01:13:17.840 --> 01:13:19.200
Then, we move towards class.

01:13:19.200 --> 01:13:21.600
And then, we have discussed about inheritance.

01:13:21.600 --> 01:13:24.720
Now, it's time to focus on one of the major concept in OPS,

01:13:24.720 --> 01:13:26.080
which is polymorphism.

01:13:26.080 --> 01:13:27.760
Oh, that's a weird word, right?

01:13:27.760 --> 01:13:29.440
Now, when we talk about polymorphism,

01:13:29.440 --> 01:13:32.160
it's break down this word poly and morphism.

01:13:32.160 --> 01:13:33.840
So, poly means many, right?

01:13:33.840 --> 01:13:35.840
And when you say morph, it means forms.

01:13:35.840 --> 01:13:39.600
So, that means one thing can take multiple forms.

01:13:39.600 --> 01:13:42.480
Example, like, as human, you know, we have different forms.

01:13:42.480 --> 01:13:45.280
As the situation changes, we change ourselves, right?

01:13:45.280 --> 01:13:49.120
Example, we behave differently at different location at office.

01:13:49.120 --> 01:13:51.280
We behave differently when we are with our friends.

01:13:51.280 --> 01:13:52.400
We behave differently.

01:13:52.400 --> 01:13:54.080
So, we are polymorphic.

01:13:54.080 --> 01:13:56.800
In the same way, when we talk about object-oriented,

01:13:56.880 --> 01:13:59.280
objects will have multiple forms.

01:13:59.280 --> 01:14:02.160
So, this concept is very important when you talk about software development.

01:14:02.160 --> 01:14:05.360
So, we use this concept a lot when it comes to loose coupling,

01:14:05.360 --> 01:14:06.560
dependency injection.

01:14:06.560 --> 01:14:09.520
We also have a concept of interfaces, which we'll see later.

01:14:09.520 --> 01:14:11.760
There are four ways of implementing polymorphism.

01:14:11.760 --> 01:14:14.880
The first one is duct typing in Python.

01:14:14.880 --> 01:14:17.360
The second one is operator overloading.

01:14:17.360 --> 01:14:20.720
Then, we have method overloading and method overriding.

01:14:20.720 --> 01:14:24.240
In the next few videos, we are going to talk about all these topics, okay?

01:14:24.240 --> 01:14:26.480
And one of the interesting ones is duct typing,

01:14:26.480 --> 01:14:28.880
especially if you are coming from different backgrounds, let's say,

01:14:28.880 --> 01:14:32.480
if you have already seen Java or C++ or C sharp,

01:14:32.480 --> 01:14:35.920
this has been different for you because in Java or in C sharp,

01:14:35.920 --> 01:14:38.800
we have to mention the type of the variable which you work with, right?

01:14:38.800 --> 01:14:41.120
We have to mention the type of object you work with.

01:14:41.120 --> 01:14:43.040
But Python, we have something different, right?

01:14:47.920 --> 01:14:50.480
In the last video, we have talked about polymorphism, right?

01:14:50.480 --> 01:14:53.840
Which simply means you have one thing which will behave in a different way.

01:14:53.840 --> 01:14:56.720
Or you can say one thing and multiple forms, right?

01:14:56.720 --> 01:14:57.760
That is many forms.

01:14:58.480 --> 01:15:02.160
Now, in this video, we'll talk about the first way of doing that,

01:15:02.160 --> 01:15:03.680
and that is your duct typing.

01:15:03.680 --> 01:15:05.120
I know that's a weird word, right?

01:15:05.120 --> 01:15:06.000
Duck typing.

01:15:06.000 --> 01:15:11.040
We have this famous line, which is if there's a bird which is walking like a duck,

01:15:11.040 --> 01:15:15.040
which is quacking like a duck, and which is swimming like a duck,

01:15:15.040 --> 01:15:17.280
that bird is a duck, right?

01:15:17.280 --> 01:15:19.680
Which simply means it doesn't matter if it's a duck or not,

01:15:19.680 --> 01:15:22.640
what matters is the behavior of that bird.

01:15:22.640 --> 01:15:25.680
If it is matching with duck, that's a duck, right?

01:15:25.680 --> 01:15:28.240
Now, how do you implement that in programming?

01:15:28.240 --> 01:15:30.400
So what we will do here is let's take an example.

01:15:30.400 --> 01:15:32.480
Let's say if I have x equal to 5.

01:15:32.480 --> 01:15:33.600
Now, we talk about the type.

01:15:33.600 --> 01:15:36.080
Now, in Python, we have a concept of dynamic typing,

01:15:36.080 --> 01:15:38.720
which simply means the type you can mention later.

01:15:38.720 --> 01:15:40.720
Example, when you say x equal to 5,

01:15:40.720 --> 01:15:43.680
the type which we are representing now is integer.

01:15:43.680 --> 01:15:46.560
But what if you say x equal to, let's say, Navin?

01:15:47.120 --> 01:15:49.520
Are we changing the type of x here?

01:15:49.520 --> 01:15:50.400
See, that's not the case.

01:15:50.400 --> 01:15:53.840
What is happening here is when you say 5, in your memory,

01:15:53.840 --> 01:15:56.480
you got a space which is of type integer.

01:15:56.480 --> 01:15:58.080
When you say Navin, in your memory,

01:15:58.080 --> 01:16:00.720
you got a space which is of type string.

01:16:00.720 --> 01:16:03.040
The x is just a name to it, okay?

01:16:03.040 --> 01:16:06.960
So when you say x equal to 5, there is an object of type integer,

01:16:06.960 --> 01:16:08.800
you are just naming it as x.

01:16:09.360 --> 01:16:10.960
Later, when you say you got Navin,

01:16:10.960 --> 01:16:14.800
you got some space in your memory and you are representing that with x.

01:16:14.800 --> 01:16:17.120
x is just a name to it, okay?

01:16:17.120 --> 01:16:19.280
So we don't have specific type to x.

01:16:19.280 --> 01:16:22.560
The moment you say type of x, you are actually getting the type of 5.

01:16:22.560 --> 01:16:25.840
When you say the type of x, you are getting the type of Navin, right?

01:16:25.840 --> 01:16:27.040
So that's one thing you have to remember.

01:16:27.040 --> 01:16:31.120
The moment you give a variable name, that's just a name to a memory.

01:16:31.120 --> 01:16:34.160
Now, to understand that typing what we'll do is we'll take another example.

01:16:34.160 --> 01:16:36.160
To explain this, what we'll do is we'll create a class

01:16:36.160 --> 01:16:37.840
and we'll name this class as laptop.

01:16:37.840 --> 01:16:40.800
And this laptop class will have a method which is, let's say, code.

01:16:40.800 --> 01:16:44.000
So in this code, what I will do is I want to execute my code, right?

01:16:44.000 --> 01:16:46.400
So as a programmer, what we do is we write code, right?

01:16:46.400 --> 01:16:48.160
We write code and we compile it,

01:16:48.160 --> 01:16:50.320
we run it and we get the output at the end.

01:16:50.880 --> 01:16:56.880
But then to do that, we also need an IDE which is Integrated Development Environment.

01:16:56.880 --> 01:17:01.120
And in this case, if you want to write a code, you need to pass an IDE.

01:17:01.120 --> 01:17:06.640
So we are expecting in the arguments that someone will pass an IDE to us.

01:17:06.640 --> 01:17:10.560
And using this IDE, I will say IDE.execute.

01:17:10.560 --> 01:17:14.000
So the question is, the IDE is of what type?

01:17:14.000 --> 01:17:15.280
Is it a type of integer?

01:17:15.280 --> 01:17:16.160
Is it a type of float?

01:17:16.160 --> 01:17:17.520
Is it a type of string?

01:17:17.600 --> 01:17:20.080
Now, of course, when you say execute, that means there's something

01:17:20.080 --> 01:17:22.800
which is not there in the existing classes which you have.

01:17:22.800 --> 01:17:25.600
That means the type of IDE is something very unique,

01:17:25.600 --> 01:17:27.920
it is something which is user is defining, right?

01:17:27.920 --> 01:17:30.400
That means if you want to create this object IDE,

01:17:30.400 --> 01:17:31.680
you need to create your own class.

01:17:31.680 --> 01:17:34.960
Let me get a class here and I will call this class as PyCharm.

01:17:34.960 --> 01:17:37.280
Now, for different languages, we use different IDEs.

01:17:37.280 --> 01:17:40.080
In fact, for one language, we have multiple options, right?

01:17:40.080 --> 01:17:43.040
Example, when you work on Java, maybe you will be using NetBeans,

01:17:43.040 --> 01:17:46.880
Eclipse, IntelliJ, for Python as well, we have different IDEs.

01:17:46.880 --> 01:17:49.840
We are using PyCharm here because it works well.

01:17:49.840 --> 01:17:52.400
Now, when you say PyCharm, of course, it will have a method, right?

01:17:52.400 --> 01:17:55.520
So let me define a method which is def execute.

01:17:55.520 --> 01:17:57.120
So you can see we have these two statements.

01:17:57.120 --> 01:17:59.680
The moment you say execute, it will say compiling and running.

01:17:59.680 --> 01:18:00.560
That's what you do, right?

01:18:00.560 --> 01:18:03.520
We are code gets compiled and your code get run.

01:18:03.520 --> 01:18:04.400
Now, will this work?

01:18:04.400 --> 01:18:06.640
Of course not because we are not calling anything.

01:18:06.640 --> 01:18:08.800
So when you run this code, you will not get any output.

01:18:08.800 --> 01:18:09.680
Let me just try it out.

01:18:09.680 --> 01:18:11.200
I will right click and say run demo.

01:18:11.200 --> 01:18:14.080
You can see there's no output because we are not calling methods.

01:18:14.080 --> 01:18:15.920
Let me call code.

01:18:16.000 --> 01:18:19.040
The way you call code is by creating the object of laptop first

01:18:19.040 --> 01:18:20.960
because you cannot call code without laptop.

01:18:20.960 --> 01:18:24.880
So I will say lap one is equal to laptop.

01:18:24.880 --> 01:18:27.440
And with the help of lap one, now you can call code.

01:18:27.440 --> 01:18:29.440
So you can say lap one dot code.

01:18:29.440 --> 01:18:32.480
But there's one problem here, which is inside a code,

01:18:32.480 --> 01:18:35.440
you have to pass an argument which is of IDE.

01:18:35.440 --> 01:18:36.320
That's a question now.

01:18:36.320 --> 01:18:38.640
How do you pass an IDE here?

01:18:38.640 --> 01:18:41.520
So what I will do is first you need to create an object of IDE.

01:18:41.520 --> 01:18:43.920
You will say IDE, of course, you can have different names here,

01:18:43.920 --> 01:18:45.280
but let me go with IDE.

01:18:45.280 --> 01:18:48.560
So IDE equal to this will be of type PyCharm.

01:18:48.560 --> 01:18:52.960
So the type of IDE we are working with is PyCharm, which is usually fine,

01:18:52.960 --> 01:18:53.440
of course.

01:18:53.440 --> 01:18:56.560
And then when you are calling code, you have to pass IDE.

01:18:56.560 --> 01:18:57.360
And now it should work.

01:18:57.360 --> 01:18:59.920
You can see from this code, you got compiling and running.

01:18:59.920 --> 01:19:02.560
So the type of IDE here is PyCharm.

01:19:02.560 --> 01:19:04.080
But is it fixed?

01:19:04.080 --> 01:19:06.320
Can we change the type of IDE later?

01:19:06.320 --> 01:19:08.240
Maybe let's say we have one more IDE.

01:19:08.240 --> 01:19:10.640
Let's say in future, I'm creating my own editor,

01:19:10.640 --> 01:19:12.720
which is way better than PyCharm, maybe.

01:19:12.720 --> 01:19:14.960
And in that as well, we have the same method.

01:19:15.040 --> 01:19:15.920
Let's say execute.

01:19:15.920 --> 01:19:17.920
And in that, I'm doing some extra stuff.

01:19:17.920 --> 01:19:20.880
So my IDE also does spell check.

01:19:20.880 --> 01:19:22.320
Maybe PyCharm does that.

01:19:22.320 --> 01:19:24.400
My IDE also does what?

01:19:24.400 --> 01:19:27.920
Convention checks, the name of the variable and different stuff.

01:19:27.920 --> 01:19:31.120
And then it also does compiling and running.

01:19:31.120 --> 01:19:33.120
So my IDE does extra stuff.

01:19:33.120 --> 01:19:36.000
Now what if I want to change the type of IDE?

01:19:36.000 --> 01:19:39.040
Is the IDE type fixed to PyCharm not exactly

01:19:39.040 --> 01:19:40.720
because this is dynamic typing?

01:19:40.720 --> 01:19:43.840
So you can replace this IDE type from PyCharm

01:19:43.840 --> 01:19:45.440
to editor provided.

01:19:45.440 --> 01:19:47.600
You have that method, which is execute.

01:19:47.600 --> 01:19:51.200
It doesn't matter which class object you're passing.

01:19:51.200 --> 01:19:55.520
What matters is that object should have the execute method.

01:19:55.520 --> 01:19:57.520
Because in IDE, we are saying execute.

01:19:57.520 --> 01:20:01.440
So now, even if you change from PyCharm to my editor,

01:20:01.440 --> 01:20:02.560
there is no problem.

01:20:02.560 --> 01:20:04.880
The code will still work.

01:20:04.880 --> 01:20:06.240
Provided you have that method.

01:20:06.240 --> 01:20:08.720
So if you should be having this method, which is execute.

01:20:08.720 --> 01:20:09.760
And that's the case.

01:20:09.760 --> 01:20:12.960
If there's a bird, and if that bird behaves like a duck,

01:20:12.960 --> 01:20:15.280
it works like a duck, it quacks like a duck,

01:20:15.280 --> 01:20:17.840
it swims like a duck, it should be a duck.

01:20:17.840 --> 01:20:21.040
In the same way, if there is an object, which is IDE,

01:20:21.040 --> 01:20:23.280
and it has a method execute, that's it.

01:20:23.280 --> 01:20:25.920
We are not concerned about which class object it is.

01:20:25.920 --> 01:20:28.240
What we are concerned about, it should have that method,

01:20:28.240 --> 01:20:29.200
which is execute.

01:20:29.200 --> 01:20:31.520
And that is called as duck typing.

01:20:31.520 --> 01:20:32.400
I know it is amazing.

01:20:32.400 --> 01:20:34.720
And if you're coming from different background, like Java,

01:20:34.720 --> 01:20:36.480
so we have a concept of interfaces.

01:20:36.480 --> 01:20:37.120
So that's what we do.

01:20:37.120 --> 01:20:38.320
We create interface.

01:20:38.320 --> 01:20:41.360
And we have this my editor and PyCharm as a class,

01:20:41.360 --> 01:20:42.960
which will implement that interface.

01:20:42.960 --> 01:20:45.440
But if you are new to this programming, don't worry.

01:20:45.440 --> 01:20:46.320
That's the Java part.

01:20:46.320 --> 01:20:46.960
This is simple.

01:20:51.920 --> 01:20:54.400
We have started talking about polymorphism.

01:20:54.400 --> 01:20:57.840
And in that, we have seen one example of duck typing.

01:20:57.840 --> 01:21:01.440
Now, in this video, we'll talk about operator overloading.

01:21:01.440 --> 01:21:03.760
So what is operator overloading?

01:21:03.760 --> 01:21:05.680
So we know the concept of operators.

01:21:05.680 --> 01:21:06.960
So we have two operands.

01:21:06.960 --> 01:21:08.640
Example, if you want to add two numbers,

01:21:08.640 --> 01:21:12.800
you can say 5 plus 6, where 5 and 6 are your operands.

01:21:12.800 --> 01:21:14.560
And plus is the operator.

01:21:14.560 --> 01:21:16.160
So we know that.

01:21:16.160 --> 01:21:18.240
And then we have a concept of polymorphism.

01:21:18.240 --> 01:21:20.000
So it simply means you have one thing

01:21:20.000 --> 01:21:21.760
which has multiple forms.

01:21:21.760 --> 01:21:24.320
Now, if you can think about this, we have two integers.

01:21:24.320 --> 01:21:26.160
And then we are trying to add them.

01:21:26.160 --> 01:21:28.880
We can also add an integer and a float.

01:21:28.880 --> 01:21:31.200
So in different programming language, it does support.

01:21:31.200 --> 01:21:32.160
What about two strings?

01:21:32.160 --> 01:21:34.000
So if you say you have two strings, let's say,

01:21:34.000 --> 01:21:35.120
hello plus world.

01:21:35.120 --> 01:21:35.760
Will it work?

01:21:35.760 --> 01:21:36.880
And the answer is yes.

01:21:36.880 --> 01:21:39.600
So plus works with the strings as well.

01:21:39.600 --> 01:21:42.640
But what if you want to say you have a number 5?

01:21:42.640 --> 01:21:46.240
So let's say we got a and a is 5.

01:21:46.240 --> 01:21:49.760
And then we got b and b is, let's say, world.

01:21:49.760 --> 01:21:52.960
Now, can I print by saying a plus b?

01:21:52.960 --> 01:21:56.160
The moment you try to underscore, you can see we got an error.

01:21:56.160 --> 01:22:00.000
It says unsupported operand types for plus.

01:22:00.000 --> 01:22:03.600
So we cannot use int and string for plus.

01:22:03.600 --> 01:22:06.080
So all these things are predefined.

01:22:06.080 --> 01:22:09.360
All these things, they are called as a synthetic sugar,

01:22:09.360 --> 01:22:12.400
which simply means it is trying to simplify the code

01:22:12.400 --> 01:22:13.360
for the user.

01:22:13.360 --> 01:22:16.000
See, behind the scene, things are a bit different.

01:22:16.000 --> 01:22:16.720
Imagine this one.

01:22:16.720 --> 01:22:20.640
Example, if I say a is 5 and b is 6.

01:22:20.640 --> 01:22:21.360
Now, what do you think?

01:22:21.360 --> 01:22:23.120
What is happening behind the scene?

01:22:23.120 --> 01:22:25.520
Now, trust me, whatever happens in Python

01:22:25.520 --> 01:22:27.680
happens with the help of object.

01:22:27.680 --> 01:22:30.560
And here as well, when we talk about a and b,

01:22:30.560 --> 01:22:32.800
the type of it is int.

01:22:32.800 --> 01:22:35.040
So int is a class here.

01:22:35.040 --> 01:22:36.400
And when you say class, of course,

01:22:36.400 --> 01:22:38.400
class will have certain methods.

01:22:38.400 --> 01:22:40.160
So behind the scene, what is happening

01:22:40.160 --> 01:22:44.160
is when you say a plus b, which is of type integer,

01:22:44.160 --> 01:22:45.440
it is calling something.

01:22:45.440 --> 01:22:49.040
So behind the scene, it is calling int dot.

01:22:49.040 --> 01:22:51.520
The moment you say int dot, int is a class.

01:22:51.520 --> 01:22:54.400
And you can see we have a method called as init.

01:22:54.400 --> 01:22:55.840
We have a method called as abs.

01:22:55.840 --> 01:22:57.760
And we also have a method called as add,

01:22:57.760 --> 01:22:59.040
which is very important here.

01:22:59.040 --> 01:23:01.760
The moment you say int dot add, this

01:23:01.760 --> 01:23:03.360
is taking two parameters.

01:23:03.360 --> 01:23:05.760
The first one is a comma b.

01:23:05.760 --> 01:23:08.680
So what we are doing here in print a plus b,

01:23:08.680 --> 01:23:10.720
the same thing can be done here.

01:23:10.720 --> 01:23:12.040
Let me just run this code here.

01:23:12.040 --> 01:23:13.520
You can see we've got the same output.

01:23:13.520 --> 01:23:15.200
So both are printing 11.

01:23:15.200 --> 01:23:19.000
So you can say a plus b, or you can say int dot add

01:23:19.000 --> 01:23:21.360
by passing two parameters a comma b.

01:23:21.360 --> 01:23:23.320
And of course, the first one looks cool, right?

01:23:23.320 --> 01:23:25.120
You're simply saying a plus b.

01:23:25.120 --> 01:23:26.880
Because from our childhood, we are doing that.

01:23:26.880 --> 01:23:29.600
We are trying to add numbers using plus operator.

01:23:29.600 --> 01:23:31.600
But the moment you come to programming in programming,

01:23:31.600 --> 01:23:33.200
whatever you want to do, you will

01:23:33.200 --> 01:23:35.400
be doing that with the help of methods.

01:23:35.400 --> 01:23:39.000
And add is a method which belongs to the int class, right?

01:23:39.000 --> 01:23:41.840
If I jump to integer, so you can press on the control button

01:23:41.840 --> 01:23:43.640
and click on the method which you want to see,

01:23:43.640 --> 01:23:45.280
or the class which you want to see.

01:23:45.280 --> 01:23:46.560
You can see it's a class.

01:23:46.560 --> 01:23:48.680
And this class has multiple methods.

01:23:48.680 --> 01:23:51.400
In the same way, the moment you say int dot,

01:23:51.400 --> 01:23:53.320
you can access a method called as add,

01:23:53.320 --> 01:23:55.000
and you're calling a comma b.

01:23:55.000 --> 01:23:58.480
So even if you say a plus b behind the scene,

01:23:58.480 --> 01:24:01.040
this is getting called, right?

01:24:01.040 --> 01:24:02.600
So this is one thing you have to remember, OK?

01:24:02.600 --> 01:24:04.360
So we'll talk about operator overloading later,

01:24:04.360 --> 01:24:05.800
but this is something you have to remember.

01:24:05.800 --> 01:24:07.640
So whenever you add two numbers, this

01:24:07.640 --> 01:24:09.640
is what is getting called behind the scene.

01:24:09.640 --> 01:24:11.200
Now, if these two things are strings,

01:24:11.200 --> 01:24:14.120
so if I make a string here, now this is not integers, right?

01:24:14.120 --> 01:24:14.680
They are strings.

01:24:14.680 --> 01:24:17.240
So I have to say str dot add.

01:24:17.240 --> 01:24:19.520
Now, when you say str dot add, in fact, str

01:24:19.520 --> 01:24:22.160
also has an add method which takes two parameters.

01:24:22.160 --> 01:24:24.600
And both should be of the same type, which is string type.

01:24:24.600 --> 01:24:25.960
And then it will work, right?

01:24:25.960 --> 01:24:28.200
So if I run this code, and you can see it is working.

01:24:28.200 --> 01:24:30.240
So we got five and six as a string.

01:24:30.240 --> 01:24:32.400
So they got concatenated here.

01:24:32.400 --> 01:24:33.280
So this works.

01:24:33.280 --> 01:24:34.880
The moment you change the type of it,

01:24:34.880 --> 01:24:37.200
it will not work because the inbuilt class

01:24:37.200 --> 01:24:40.560
doesn't have two things, which is integer and string

01:24:40.560 --> 01:24:41.800
together, right?

01:24:41.800 --> 01:24:43.120
So this thing you have to remember.

01:24:43.120 --> 01:24:45.880
Now, once we know the moment you add a plus operator,

01:24:45.880 --> 01:24:47.200
it calls the add method.

01:24:47.200 --> 01:24:48.800
The moment you put a minus operator,

01:24:48.800 --> 01:24:50.480
it will call a sub method.

01:24:50.480 --> 01:24:52.840
The moment you use a star symbol, which is multiplication,

01:24:52.840 --> 01:24:54.040
it will call a mul method.

01:24:54.040 --> 01:24:57.280
So we have different methods for different operators, right?

01:24:57.280 --> 01:24:59.400
And normally, those things are called as magic methods,

01:24:59.440 --> 01:25:01.440
but that's what they say, magic methods, right?

01:25:01.440 --> 01:25:03.520
So all these operators, behind the scene,

01:25:03.520 --> 01:25:05.000
they work as methods.

01:25:05.000 --> 01:25:07.840
Now, to understand the concept of operator overloading,

01:25:07.840 --> 01:25:09.600
what I will do is I will say class.

01:25:09.600 --> 01:25:11.560
And let's say we have a student class.

01:25:11.560 --> 01:25:13.800
And every student will have, let's say, two variables.

01:25:13.800 --> 01:25:15.360
And that will be marks one and marks two,

01:25:15.360 --> 01:25:16.800
just to keep it simple.

01:25:16.800 --> 01:25:20.360
So what I will do here is I will set def and init.

01:25:20.360 --> 01:25:24.280
And here, I will say self.m1 is equal to oh,

01:25:24.280 --> 01:25:26.840
now we want the value from the user, right?

01:25:26.840 --> 01:25:28.880
So maybe I want to pass the value.

01:25:28.880 --> 01:25:31.960
So I will pass it from here, m1 comma m2.

01:25:31.960 --> 01:25:35.680
And let's specify self.m2 is equal to m2.

01:25:35.680 --> 01:25:37.080
So we got these two values, right?

01:25:37.080 --> 01:25:39.360
Now, what I want to do is I want to create two objects,

01:25:39.360 --> 01:25:40.480
okay, two students object.

01:25:40.480 --> 01:25:44.040
One is, let's say, s1 is equal to student.

01:25:44.040 --> 01:25:45.240
And this will take two values.

01:25:45.240 --> 01:25:49.240
I would say 58 comma 69, that's the value here.

01:25:49.240 --> 01:25:51.520
And then s2 is equal to student.

01:25:51.520 --> 01:25:54.360
And this student will have, let's say, 60 comma 65.

01:25:54.360 --> 01:25:55.640
So we got two marks here, right?

01:25:55.640 --> 01:25:58.320
We got two student and each student have two marks.

01:25:58.320 --> 01:26:00.320
Now, I want to apply the operator here,

01:26:00.320 --> 01:26:01.200
which is plus operator.

01:26:01.200 --> 01:26:02.600
So I want to add these two students.

01:26:02.600 --> 01:26:05.200
So the moment I say s1 plus s2,

01:26:05.200 --> 01:26:07.560
I want a different student object, right?

01:26:07.560 --> 01:26:08.560
Is it possible to do that?

01:26:08.560 --> 01:26:09.400
Let's try.

01:26:09.400 --> 01:26:12.960
So I will say s3 is equal to s1 plus s2.

01:26:12.960 --> 01:26:15.520
Because now we know that plus operator means

01:26:15.520 --> 01:26:17.520
it will add two values.

01:26:17.520 --> 01:26:19.280
But it is possible with the help of integer.

01:26:19.280 --> 01:26:20.920
It is possible with the help of string.

01:26:20.920 --> 01:26:23.880
Is it possible to use plus operator with student class?

01:26:23.880 --> 01:26:24.800
That's a question.

01:26:24.800 --> 01:26:25.640
So let's run this code.

01:26:25.640 --> 01:26:26.480
Let's see what happens.

01:26:26.480 --> 01:26:27.960
Okay, we are not printing the value of s3,

01:26:27.960 --> 01:26:29.120
but let's run this code.

01:26:29.120 --> 01:26:31.720
The moment you try to run this code, you will get an error.

01:26:31.720 --> 01:26:33.680
Oh, okay, we got different error here.

01:26:33.680 --> 01:26:35.800
It says student takes no argument,

01:26:35.800 --> 01:26:37.200
but it is taking arguments, right?

01:26:37.200 --> 01:26:38.040
What's wrong?

01:26:38.040 --> 01:26:40.720
Oh, we have written the wrong name, my bad.

01:26:40.720 --> 01:26:42.120
Let's run this code once again.

01:26:42.120 --> 01:26:44.440
So I was expecting this error, not the first one.

01:26:44.440 --> 01:26:48.080
And the error is it says unsupported operant type plus.

01:26:48.080 --> 01:26:50.360
We cannot use plus between student and student

01:26:50.360 --> 01:26:52.480
because we have not defined it, right?

01:26:52.480 --> 01:26:54.280
If you remember, behind the scene,

01:26:54.280 --> 01:26:56.080
even if you use plus with integers,

01:26:56.080 --> 01:26:58.120
it will be calling an add method.

01:26:58.120 --> 01:26:59.440
But if you see our class,

01:26:59.440 --> 01:27:01.240
we don't have that add method, right?

01:27:01.240 --> 01:27:03.200
Because if you say s1 plus s2,

01:27:03.200 --> 01:27:06.520
how your compiler, how your Python will know what to do?

01:27:06.520 --> 01:27:08.080
And that's where you have to define it.

01:27:08.080 --> 01:27:09.240
Yeah, that's where you have to say,

01:27:09.240 --> 01:27:11.960
hey, the moment anyone says plus of a student,

01:27:11.960 --> 01:27:14.760
you need to call this method called as add.

01:27:14.760 --> 01:27:17.720
Okay, so you can overload the operator

01:27:17.720 --> 01:27:19.160
and you can change definition for it.

01:27:19.160 --> 01:27:21.640
You can define anything you want, right?

01:27:21.640 --> 01:27:25.000
So I can say add and this add will take two parameters.

01:27:25.000 --> 01:27:28.240
The first one is self comma other.

01:27:28.240 --> 01:27:31.200
And you can see it takes two parameters, self and other.

01:27:31.200 --> 01:27:32.600
Okay, guess what is happening?

01:27:32.600 --> 01:27:33.800
So behind the scene,

01:27:33.800 --> 01:27:36.640
this code is getting converted into,

01:27:36.640 --> 01:27:39.600
it is student dot add,

01:27:39.600 --> 01:27:42.560
which takes two parameters, s1 comma s2.

01:27:42.560 --> 01:27:44.440
So what is self and what is other here?

01:27:44.440 --> 01:27:46.320
So the first parameter is self

01:27:46.320 --> 01:27:47.800
and s2 is the other parameter.

01:27:47.800 --> 01:27:50.960
You can change the variable name, that's fine, okay?

01:27:50.960 --> 01:27:53.920
You can say this is o and it should work.

01:27:53.960 --> 01:27:55.000
It's a variable name, right?

01:27:55.000 --> 01:27:57.240
So this is what is getting called behind the scene, right?

01:27:57.240 --> 01:27:59.120
So here what I will do is I will say,

01:27:59.120 --> 01:28:00.840
let's take two variables, m1,

01:28:00.840 --> 01:28:04.040
m1 is equal to self dot m1

01:28:04.040 --> 01:28:06.800
and m2 is equal to self dot m2.

01:28:06.800 --> 01:28:08.640
So we got two variables, right?

01:28:08.640 --> 01:28:10.120
Oh, not just self m1 plus,

01:28:10.120 --> 01:28:13.560
it is other dot m1 plus other dot m2.

01:28:13.560 --> 01:28:15.040
So this is how you add values, right?

01:28:15.040 --> 01:28:17.520
So self m1 and other m1

01:28:17.520 --> 01:28:21.280
and then m2 will have the addition of self m2 and other m2.

01:28:21.280 --> 01:28:22.520
So this works.

01:28:22.520 --> 01:28:24.160
And once you've got these two values,

01:28:24.160 --> 01:28:25.440
what you will be doing is you will be getting

01:28:25.440 --> 01:28:26.960
a new student object, we'll call that s3,

01:28:26.960 --> 01:28:28.480
you can have any name as a matter.

01:28:28.480 --> 01:28:30.720
So s3 is equal to student

01:28:30.720 --> 01:28:33.880
by passing these two values, m1 comma m2.

01:28:33.880 --> 01:28:35.160
And now once you've got this student,

01:28:35.160 --> 01:28:37.280
you will return s3 here, right?

01:28:37.280 --> 01:28:38.160
That is what you're expecting.

01:28:38.160 --> 01:28:41.160
So the moment you say s1 plus s2,

01:28:41.160 --> 01:28:42.160
it will return the value,

01:28:42.160 --> 01:28:43.760
it will return a new object of student

01:28:43.760 --> 01:28:45.680
and you will assign that to s3.

01:28:45.680 --> 01:28:46.880
Okay, so this is what will happen.

01:28:46.880 --> 01:28:48.760
Now if I print the value for s3,

01:28:48.760 --> 01:28:51.360
so I will let me print s3 dot m1

01:28:51.400 --> 01:28:53.280
and the moment you run this code, run

01:28:53.280 --> 01:28:55.880
and you can see it works, you've got 118.

01:28:55.880 --> 01:28:56.720
Is it right?

01:28:56.720 --> 01:28:57.720
Of course it should be, right?

01:28:57.720 --> 01:29:00.160
So it is 58 plus 60 and that's right.

01:29:00.160 --> 01:29:01.640
We got 118.

01:29:01.640 --> 01:29:02.840
This thing is working, right?

01:29:02.840 --> 01:29:03.680
Perfect.

01:29:03.680 --> 01:29:05.160
So if you want to add two students,

01:29:05.160 --> 01:29:08.000
you need to overload the operator of plus

01:29:08.000 --> 01:29:09.600
because integer knows what is plus,

01:29:09.600 --> 01:29:10.680
string knows what is plus,

01:29:10.680 --> 01:29:13.360
your student class don't know what is that plus means.

01:29:13.360 --> 01:29:15.480
So plus means call the add method,

01:29:15.480 --> 01:29:17.160
but we don't have an add method here.

01:29:17.160 --> 01:29:19.000
So we have to define our own method.

01:29:19.000 --> 01:29:20.840
The same thing can be done with subtraction,

01:29:20.840 --> 01:29:23.520
is minus, the same thing can be done with multiplication.

01:29:23.520 --> 01:29:26.320
So I would recommend you to explore more on this, you know?

01:29:26.320 --> 01:29:29.120
So the moment you say def underscore underscore,

01:29:29.120 --> 01:29:30.400
you can see we have so many methods.

01:29:30.400 --> 01:29:33.000
We also have greater than, we also have equal to symbol.

01:29:33.000 --> 01:29:34.600
We can compare two objects.

01:29:34.600 --> 01:29:37.040
We can say that different methods are available here.

01:29:37.040 --> 01:29:37.880
Okay, so try it out.

01:29:37.880 --> 01:29:39.560
We also have multiplication somewhere.

01:29:39.560 --> 01:29:40.920
So you can see we also have mull.

01:29:40.920 --> 01:29:43.080
So everything is predefined, you can just use them.

01:29:43.080 --> 01:29:45.560
In fact, for this example, I will take one more.

01:29:45.560 --> 01:29:48.040
I want to compare if two objects are

01:29:48.040 --> 01:29:49.200
greater than or equal to example,

01:29:49.200 --> 01:29:52.400
if I say if S1 is greater than S2,

01:29:52.400 --> 01:29:54.360
this is the horrible way of comparing students

01:29:54.360 --> 01:29:55.960
because marks is not a criteria

01:29:55.960 --> 01:29:57.000
where you can compare students.

01:29:57.000 --> 01:30:01.200
But just for the example, I will say S1 wins.

01:30:01.200 --> 01:30:03.720
So whoever has maximum marks, I will say they win.

01:30:03.720 --> 01:30:07.360
I will say else, print S2 wins.

01:30:07.360 --> 01:30:08.840
So what we are trying to do here is

01:30:08.840 --> 01:30:11.080
whoever has maximum marks, they will win.

01:30:11.080 --> 01:30:13.040
But when you say maximum marks, how do you check it?

01:30:13.040 --> 01:30:14.800
Because we are not defining it, right?

01:30:14.800 --> 01:30:16.640
Maybe I want to check only first marks,

01:30:16.640 --> 01:30:18.920
which is M1 or maybe I want to check M2

01:30:18.920 --> 01:30:20.320
or maybe the addition of both.

01:30:20.320 --> 01:30:21.160
You can try it out.

01:30:21.160 --> 01:30:23.880
So what I will do here is this will work, of course not

01:30:23.880 --> 01:30:25.440
because the moment you try to run this code,

01:30:25.440 --> 01:30:27.400
it will give you an error by saying

01:30:27.400 --> 01:30:29.520
the greater than symbol not supported

01:30:29.520 --> 01:30:31.440
between two instances of student.

01:30:31.440 --> 01:30:34.000
It is supported for integers because it is predefined.

01:30:34.000 --> 01:30:35.960
So here as well, if you want to make it work,

01:30:35.960 --> 01:30:38.920
you have to define a function of method, which is GT.

01:30:38.920 --> 01:30:43.080
GT is greater than, GE is greater than equal to.

01:30:43.080 --> 01:30:44.720
So you want to check only greater than.

01:30:44.720 --> 01:30:48.400
And then here you'll be using self and other as usual

01:30:48.400 --> 01:30:50.040
because behind the scene, that is what is happening.

01:30:50.040 --> 01:30:53.880
It is saying student.GT and it's passing two variables,

01:30:53.880 --> 01:30:55.000
S1, S2.

01:30:55.000 --> 01:30:57.480
So S1 goes to self, S2 goes to other.

01:30:57.480 --> 01:30:59.320
And now, how do I compare?

01:30:59.320 --> 01:31:01.560
So we'll say S1 doesn't matter, is it S1 or something?

01:31:01.560 --> 01:31:06.560
So we'll say S1 is equal to self.M1 plus self.M2.

01:31:07.640 --> 01:31:12.640
And we'll say S2 is equal to other.M1 plus other.M2.

01:31:12.880 --> 01:31:14.680
So we are adding their marks basically.

01:31:14.680 --> 01:31:15.520
You can compare.

01:31:15.560 --> 01:31:18.040
If S1 is greater than S2,

01:31:18.040 --> 01:31:20.560
now this time S1, S2, they're not objects, okay?

01:31:20.560 --> 01:31:23.040
They are simple variables of integer.

01:31:23.040 --> 01:31:24.480
Okay, if I'm getting confused with this,

01:31:24.480 --> 01:31:26.720
let me just make it R, that should make sense.

01:31:26.720 --> 01:31:28.840
So let's compare R1 and R2.

01:31:28.840 --> 01:31:30.280
Now those are just marks, right?

01:31:30.280 --> 01:31:34.940
If R1 is greater than R2, we will say return true,

01:31:34.940 --> 01:31:37.760
else return false.

01:31:37.760 --> 01:31:38.600
Simple.

01:31:38.600 --> 01:31:40.480
Now if you're on this code, we are comparing it, right?

01:31:40.480 --> 01:31:42.040
Let's compare and let's run.

01:31:42.040 --> 01:31:44.880
And it worked, you can see S1 wins, right?

01:31:44.880 --> 01:31:46.640
Because S1 values are higher.

01:31:46.640 --> 01:31:50.240
So 58 plus 69 is higher than 60 plus 65.

01:31:50.240 --> 01:31:52.720
But what if I change the value for S2?

01:31:52.720 --> 01:31:55.080
Let's say there's 69 and you can see, of course,

01:31:55.080 --> 01:31:57.600
now S2 is bigger, so let's run this code.

01:31:57.600 --> 01:31:59.800
And you can see it says S2 wins, so that's right.

01:31:59.800 --> 01:32:02.240
So what we are doing is we are adding those values

01:32:02.240 --> 01:32:04.040
and then we are comparing it.

01:32:04.040 --> 01:32:07.920
So if you want to perform any operation on the objects

01:32:07.920 --> 01:32:10.840
which I usually find, you have to define all these methods.

01:32:10.840 --> 01:32:11.800
Okay, there's one more.

01:32:11.800 --> 01:32:15.800
What if you have a variable, let's say A is equal to nine?

01:32:15.800 --> 01:32:17.920
Now when you say print A, and you can see

01:32:17.920 --> 01:32:20.200
it will print the value of A, there's nothing wrong with that.

01:32:20.200 --> 01:32:22.200
You can see it is printing the value of A.

01:32:22.200 --> 01:32:24.160
Now is it printing the address of A?

01:32:24.160 --> 01:32:25.000
That's not the case.

01:32:25.000 --> 01:32:26.640
Why it is not printing the address of A?

01:32:26.640 --> 01:32:28.600
It is printing the value of A.

01:32:28.600 --> 01:32:31.560
But what happens, the moment you try to print S1,

01:32:31.560 --> 01:32:33.360
it will not print the values of S1.

01:32:33.360 --> 01:32:36.440
It will try to print the address of S1.

01:32:36.440 --> 01:32:38.760
Okay, so you can see that it says it's a student object

01:32:38.760 --> 01:32:40.680
at the address at this position.

01:32:40.680 --> 01:32:42.080
Okay, we don't want that address, right?

01:32:42.080 --> 01:32:43.640
We want values.

01:32:43.640 --> 01:32:45.000
What is happening?

01:32:45.000 --> 01:32:46.720
So when you try to print the object,

01:32:46.720 --> 01:32:49.120
doesn't matter is it integer or your class,

01:32:49.120 --> 01:32:53.520
behind the scene, it is calling a method called as str.

01:32:53.520 --> 01:32:55.240
It is happening behind the scene, okay?

01:32:55.240 --> 01:32:57.800
Even if you don't call it, it is happening behind the scene.

01:32:57.800 --> 01:32:59.600
So the moment you say print A,

01:32:59.600 --> 01:33:01.800
it will try to call A.str.

01:33:01.800 --> 01:33:04.160
And that's why you are getting the output, right?

01:33:04.160 --> 01:33:06.440
You're getting nine because it is calling str.

01:33:06.440 --> 01:33:09.400
In the same way, the moment you say S1,

01:33:09.400 --> 01:33:13.200
even this is calling str, right?

01:33:13.200 --> 01:33:14.680
And now if you run this code,

01:33:14.680 --> 01:33:16.680
you can see it is still giving the same output.

01:33:16.680 --> 01:33:18.400
That means it is calling str.

01:33:18.400 --> 01:33:19.400
What is this str?

01:33:19.400 --> 01:33:22.160
So if I click on this, you can see it is in built-in.

01:33:22.160 --> 01:33:24.400
So even if you don't define str function

01:33:24.400 --> 01:33:26.080
or method in your own class,

01:33:26.080 --> 01:33:27.800
it is getting defined somewhere.

01:33:27.800 --> 01:33:29.560
And that definition, what is printing?

01:33:29.560 --> 01:33:31.640
It is printing the module name.

01:33:31.640 --> 01:33:33.000
It is printing the name of the class

01:33:33.000 --> 01:33:35.440
and it is printing the object address.

01:33:35.440 --> 01:33:37.720
We don't want that, we want values, right?

01:33:37.720 --> 01:33:40.440
That means we need to override this method.

01:33:40.440 --> 01:33:43.200
So what I will do is I will say def.

01:33:43.200 --> 01:33:44.560
And the method name is str,

01:33:44.560 --> 01:33:46.880
so you have to define this by yourself.

01:33:46.880 --> 01:33:49.360
So we want to return the value of m1 and m2, right?

01:33:49.360 --> 01:33:53.000
So you will say self.m1, self.m2.

01:33:53.000 --> 01:33:54.480
And now if I run this code,

01:33:54.480 --> 01:33:55.640
it will return a tuple, of course.

01:33:55.640 --> 01:33:57.040
Let's run this code and you got it.

01:33:57.040 --> 01:33:59.640
Can you see that we got 58 and 69.

01:33:59.640 --> 01:34:01.760
So now if you want to print the object,

01:34:01.760 --> 01:34:03.440
it will not print the address,

01:34:03.440 --> 01:34:05.080
it will print the values, right?

01:34:05.080 --> 01:34:07.720
Because we are overriding the str.

01:34:07.720 --> 01:34:08.680
So if you remove str,

01:34:08.680 --> 01:34:10.440
if you run this code, you got an error.

01:34:10.440 --> 01:34:12.200
So it is returning a non-string value.

01:34:12.200 --> 01:34:13.360
We have to return a string value.

01:34:13.360 --> 01:34:14.440
How do we do that?

01:34:14.440 --> 01:34:16.000
Because by default, when you say print,

01:34:16.000 --> 01:34:17.080
you want to print a string, right?

01:34:17.080 --> 01:34:17.920
So what you will do is,

01:34:17.920 --> 01:34:18.920
you will use a format here.

01:34:18.920 --> 01:34:21.000
So you can say curly packets,

01:34:21.000 --> 01:34:23.920
curly packets, you're printing two stuff, dot, format.

01:34:23.920 --> 01:34:25.640
And inside this format, you can pass this to value.

01:34:25.640 --> 01:34:27.280
So what will happen is those curly packets

01:34:27.280 --> 01:34:28.920
will be replaced by these values.

01:34:28.920 --> 01:34:31.240
So you are returning a string now.

01:34:31.240 --> 01:34:32.480
And we have seen that before, right?

01:34:32.480 --> 01:34:34.360
So let's run this code and it worked.

01:34:34.360 --> 01:34:36.880
You can see it got 58 and 69.

01:34:36.880 --> 01:34:39.440
So even if you say print S1, it does work.

01:34:39.440 --> 01:34:41.560
You can also print S2 if you want.

01:34:41.560 --> 01:34:42.880
And let's run this code.

01:34:42.880 --> 01:34:45.560
And you can see we got 69 and 65.

01:34:45.560 --> 01:34:46.600
So that's perfect.

01:34:46.600 --> 01:34:50.840
So this is how you work with operator overloading, okay?

01:34:50.840 --> 01:34:52.360
So point to remember is,

01:34:52.360 --> 01:34:55.000
whenever you perform any operator like addition,

01:34:55.000 --> 01:34:56.440
subtraction, deletion,

01:34:56.440 --> 01:34:59.560
behind this scene, we are calling methods, okay?

01:34:59.560 --> 01:35:01.560
So for plus, we use add method,

01:35:01.560 --> 01:35:03.520
for minus, we use sub method.

01:35:03.520 --> 01:35:05.160
And for star, we use mult method.

01:35:05.160 --> 01:35:07.160
In fact, we have a list of methods there.

01:35:11.520 --> 01:35:14.440
In the last video, we have talked about operator overloading,

01:35:14.440 --> 01:35:15.280
right?

01:35:15.280 --> 01:35:17.680
Which simply means you have operator like plus,

01:35:17.680 --> 01:35:20.160
minus, or division, or multiplication.

01:35:20.160 --> 01:35:21.800
So the operator will remain same,

01:35:21.800 --> 01:35:24.000
but the operands will change, right?

01:35:24.000 --> 01:35:26.720
The type of parameters we are passing, it will change.

01:35:26.720 --> 01:35:28.120
Example, when you say plus,

01:35:28.120 --> 01:35:30.160
we are calling the add method, right?

01:35:30.160 --> 01:35:32.920
And add method takes different types of parameters

01:35:32.960 --> 01:35:34.800
or different types of arguments.

01:35:34.800 --> 01:35:35.880
So that is overloading.

01:35:35.880 --> 01:35:39.040
So it simply means you have the same method name,

01:35:39.040 --> 01:35:40.840
but the arguments are different.

01:35:40.840 --> 01:35:42.200
Or maybe the number of arguments

01:35:42.200 --> 01:35:44.640
or the type of arguments are different.

01:35:44.640 --> 01:35:48.160
In the same way, we have two more types in polymorphism.

01:35:48.160 --> 01:35:52.200
One is method overloading and method overriding.

01:35:52.200 --> 01:35:53.160
So what it means?

01:35:53.160 --> 01:35:54.160
Let's start with the first one,

01:35:54.160 --> 01:35:55.840
which is method overloading.

01:35:55.840 --> 01:35:58.040
Now languages like Java, C sharp,

01:35:58.040 --> 01:35:59.760
or any other oops language,

01:35:59.760 --> 01:36:02.400
they have this concept of method overloading,

01:36:02.400 --> 01:36:04.560
which is not there in Python.

01:36:04.560 --> 01:36:06.120
But what exactly it is?

01:36:06.120 --> 01:36:07.920
So it simply means if you have a class,

01:36:07.920 --> 01:36:09.640
and in that class if you have, let's say,

01:36:09.640 --> 01:36:11.480
two methods with the same name,

01:36:11.480 --> 01:36:13.840
but different parameters or arguments,

01:36:13.840 --> 01:36:15.800
which is called as method overloading.

01:36:15.800 --> 01:36:17.400
Example, let's say if you have student class,

01:36:17.400 --> 01:36:19.240
and in student class if you have two methods,

01:36:19.240 --> 01:36:20.720
let's say average.

01:36:20.720 --> 01:36:22.960
So we have two methods with the same name, average.

01:36:22.960 --> 01:36:26.040
One takes two parameters, one takes three parameters.

01:36:26.040 --> 01:36:27.800
This is called as method overloading.

01:36:27.800 --> 01:36:29.960
But in Python, we don't have this concept.

01:36:29.960 --> 01:36:32.880
So we cannot create two methods with the same name.

01:36:32.880 --> 01:36:35.000
The next one is method overriding,

01:36:35.000 --> 01:36:37.680
which simply means you have two methods

01:36:37.680 --> 01:36:40.440
with the same name and same number of parameters

01:36:40.440 --> 01:36:41.640
or arguments.

01:36:41.640 --> 01:36:44.000
Okay, so that means can we create two methods

01:36:44.000 --> 01:36:46.120
with the same name and same parameter in the same class?

01:36:46.120 --> 01:36:47.920
Of course not, not in the same class.

01:36:47.920 --> 01:36:50.080
But let's say if you have a concept of inheritance,

01:36:50.080 --> 01:36:52.160
we have class A and class B,

01:36:52.160 --> 01:36:54.360
and both the class have the same method

01:36:54.360 --> 01:36:56.280
with the same name, same parameter,

01:36:56.280 --> 01:36:58.400
this is called as overriding.

01:36:58.400 --> 01:36:59.760
Again, we'll see the impact of that.

01:36:59.760 --> 01:37:01.840
Let's start with the method overloading first.

01:37:01.840 --> 01:37:03.800
So if you want to achieve method overloading,

01:37:03.800 --> 01:37:06.040
what I will do is I will just remove this methods from here.

01:37:06.040 --> 01:37:07.680
Just to keep it simple, right?

01:37:07.680 --> 01:37:10.160
So we got a init method and it is working perfectly.

01:37:10.160 --> 01:37:12.920
Let's remove all the extra stuff from here.

01:37:12.920 --> 01:37:15.800
We just want to create one object, not even two.

01:37:15.800 --> 01:37:17.000
I want to add two numbers.

01:37:17.000 --> 01:37:20.000
So I have to create a method, let's say sum,

01:37:20.000 --> 01:37:22.000
and this sum will take two arguments.

01:37:22.000 --> 01:37:24.200
We'll say A and B.

01:37:24.200 --> 01:37:25.640
So I want to add two values, that's it.

01:37:25.640 --> 01:37:27.760
Nothing complex, I want to add two numbers.

01:37:27.760 --> 01:37:29.160
Now if you want to add two numbers,

01:37:30.040 --> 01:37:33.280
I will say S is equal to A plus B,

01:37:33.280 --> 01:37:35.480
and at the end, we'll return S.

01:37:35.480 --> 01:37:36.720
That's what we want to do here.

01:37:36.720 --> 01:37:39.240
We just want to return the value of S, okay?

01:37:39.240 --> 01:37:41.880
And if you want to work with that, you will say S1.

01:37:41.880 --> 01:37:45.040
In fact, you will print the value, you will say S1 dot sum,

01:37:45.040 --> 01:37:46.720
and you want to add two numbers here.

01:37:46.720 --> 01:37:48.680
I will say five and nine.

01:37:48.680 --> 01:37:49.680
And let's see if it is working.

01:37:49.680 --> 01:37:51.120
Let's run this code and it works.

01:37:51.120 --> 01:37:52.640
You can see we got 14.

01:37:52.640 --> 01:37:55.400
So yes, we can create a method in setup class

01:37:55.400 --> 01:37:56.560
which takes two parameters

01:37:56.560 --> 01:37:58.680
and we can pass two parameters, it works.

01:37:58.680 --> 01:38:01.080
What if, if you want to pass three values,

01:38:01.080 --> 01:38:03.920
you want to pass five, nine, and six.

01:38:03.920 --> 01:38:05.080
Now this is not possible, right?

01:38:05.080 --> 01:38:07.280
The moment you run this code, you will get an error

01:38:07.280 --> 01:38:10.280
because you are passing three parameters

01:38:10.280 --> 01:38:11.640
or you're passing three arguments

01:38:11.640 --> 01:38:13.160
and you're accepting only two.

01:38:13.160 --> 01:38:14.400
So this will not work.

01:38:14.400 --> 01:38:16.840
That means you need to create another method called a sum

01:38:16.840 --> 01:38:18.120
which will take three arguments.

01:38:18.120 --> 01:38:20.280
That's what we do in other languages.

01:38:20.280 --> 01:38:21.800
But here we'll not do that.

01:38:21.800 --> 01:38:24.240
Here what you can do is you can also use third variable.

01:38:24.240 --> 01:38:27.080
You will say C, you got A, B, and C,

01:38:27.120 --> 01:38:30.760
and you will simply say A plus B plus C, right?

01:38:30.760 --> 01:38:31.680
So this will work.

01:38:31.680 --> 01:38:34.280
So if I run this code and you can see you got 20

01:38:34.280 --> 01:38:36.080
and this is right, you will get 20.

01:38:36.080 --> 01:38:37.840
So we are passing three arguments

01:38:37.840 --> 01:38:40.240
and we are accepting three arguments, it will work.

01:38:40.240 --> 01:38:42.360
But what if I'm not passing third argument,

01:38:42.360 --> 01:38:43.800
I'm passing only two arguments?

01:38:43.800 --> 01:38:45.040
And now the problem starts, right?

01:38:45.040 --> 01:38:49.080
Because you are expected to pass the third argument as well.

01:38:49.080 --> 01:38:50.240
How do we solve this?

01:38:50.240 --> 01:38:52.320
To solve this thing, we can use a concept

01:38:52.320 --> 01:38:54.640
where you will say A is equal to none.

01:38:54.640 --> 01:38:55.480
So this is one option.

01:38:55.480 --> 01:38:58.520
The other option, we can use the variable length arguments.

01:38:58.520 --> 01:39:00.360
If you remember, we have done that before,

01:39:00.360 --> 01:39:01.880
the star and variable name.

01:39:01.880 --> 01:39:02.720
But this is another option.

01:39:02.720 --> 01:39:05.480
You can say all the values are by default none,

01:39:05.480 --> 01:39:07.880
which means even if you don't pass the value,

01:39:07.880 --> 01:39:09.760
this is default arguments, right?

01:39:09.760 --> 01:39:11.440
So even if you don't pass the value,

01:39:11.440 --> 01:39:12.920
the default value will be none.

01:39:12.920 --> 01:39:15.800
So that means even if you don't pass any value,

01:39:15.800 --> 01:39:18.840
example, even if you don't pass five and nine, it will work.

01:39:18.840 --> 01:39:20.640
All the values will become none.

01:39:20.640 --> 01:39:23.520
I want to pass some values, I will say five comma nine.

01:39:23.520 --> 01:39:24.840
I'm passing with two values, right?

01:39:24.840 --> 01:39:25.680
Let's start with third one.

01:39:25.680 --> 01:39:29.000
Let's say I want to pass three values, five comma nine comma six.

01:39:29.000 --> 01:39:33.480
All these values will be assigned to A, B, and C, respectively.

01:39:33.480 --> 01:39:37.360
So if I will go to A, nine will go to B, and six will go to C.

01:39:37.360 --> 01:39:39.160
So these values will be replaced by none.

01:39:39.160 --> 01:39:40.840
So none will be replaced by these values.

01:39:40.840 --> 01:39:43.920
So now, once I know this, so we can simply add it.

01:39:43.920 --> 01:39:45.560
But what if you're passing two?

01:39:45.560 --> 01:39:46.760
So in this case, you will check.

01:39:46.760 --> 01:39:48.200
So before adding, you will check.

01:39:48.200 --> 01:39:53.000
You will check if A is not equal to none, B is not equal to none,

01:39:53.000 --> 01:39:55.640
and C is not equal to none.

01:39:55.640 --> 01:40:00.040
So if none of them are none, that simply means you're passing three arguments, right?

01:40:00.040 --> 01:40:02.920
And if you're passing three arguments, this is the calculation we have to go for.

01:40:02.920 --> 01:40:06.200
You will say S is equal to A plus B plus C.

01:40:06.200 --> 01:40:10.040
And you want to declare S outside so that you can use it from anywhere.

01:40:10.040 --> 01:40:12.680
So you will say S is by default zero, and you've got this.

01:40:12.680 --> 01:40:15.280
Otherwise, if let's say if I'm passing only two arguments,

01:40:15.280 --> 01:40:19.760
I'm not passing the third argument, in that case, it will go to LF.

01:40:19.760 --> 01:40:22.920
And inside LF, I will check, I forgot a colon here.

01:40:22.920 --> 01:40:26.840
So inside LF, I will check if A is not equal to none.

01:40:26.840 --> 01:40:28.720
So I'm concerned about A and B.

01:40:28.720 --> 01:40:33.440
If they are not none, in that case, I will say S is equal to A plus B,

01:40:33.440 --> 01:40:35.240
because we're not concerned about C, right?

01:40:35.240 --> 01:40:36.720
And then we can go for one more condition.

01:40:36.720 --> 01:40:38.960
What if you pass only one parameter or one argument?

01:40:38.960 --> 01:40:42.240
In that case, you will say else, and you will say S equal to A.

01:40:42.240 --> 01:40:45.400
So when you say only one parameter, let's say if I'm not passing nine and six,

01:40:45.400 --> 01:40:47.800
I'm passing only five, so it will return five, right?

01:40:47.800 --> 01:40:48.920
That's what we want.

01:40:48.920 --> 01:40:49.720
So we can do that.

01:40:49.720 --> 01:40:52.560
Else part is not required here, but just to make it more effective.

01:40:52.560 --> 01:40:56.400
We can pass one argument, we can pass two arguments, we can pass three arguments.

01:40:56.400 --> 01:40:57.320
That's perfect.

01:40:57.320 --> 01:40:59.400
Let's run this code, and it worked.

01:40:59.400 --> 01:41:00.440
You can see we got 20.

01:41:00.440 --> 01:41:05.360
Now, if I pass only five and nine, even this will work because if you pass only

01:41:05.360 --> 01:41:10.360
five and nine, C will get none, and it will execute LF, and you can see we got 14.

01:41:10.360 --> 01:41:13.200
Now, if you pass only one value, let's say five, in this case,

01:41:13.200 --> 01:41:15.000
if you run this code, you got five, right?

01:41:15.000 --> 01:41:16.440
That's how it works.

01:41:16.440 --> 01:41:19.640
So this is your method overloading.

01:41:19.640 --> 01:41:21.280
So we are overloading methods.

01:41:21.280 --> 01:41:24.480
But then we are not doing directly because it doesn't support in Python.

01:41:24.480 --> 01:41:26.080
So we are doing some trick.

01:41:26.080 --> 01:41:28.120
The next one is method overriding.

01:41:28.120 --> 01:41:28.840
So let's go with that.

01:41:28.840 --> 01:41:30.200
Let me just remove this code.

01:41:30.200 --> 01:41:32.880
And let's once again take a simple example.

01:41:32.880 --> 01:41:34.640
And this time we'll go for A and B.

01:41:34.640 --> 01:41:36.000
I love these classes.

01:41:36.000 --> 01:41:38.480
So what I will do is, let's say we have a class A, OK?

01:41:38.480 --> 01:41:40.760
And in this class A, we have a function.

01:41:40.760 --> 01:41:43.240
I will say function name is, or the method name is show.

01:41:43.240 --> 01:41:47.120
And in this method, I will simply print in a show.

01:41:47.120 --> 01:41:50.760
Now, first of all, before going ahead, this concept is method overriding.

01:41:50.760 --> 01:41:53.120
This is very famous in software industry, you know?

01:41:53.120 --> 01:41:55.800
So in future videos, we'll also talk about this thing.

01:41:55.800 --> 01:41:58.560
When we talk about interfaces and abstract classes,

01:41:58.560 --> 01:42:01.320
this concept is used very heavily, OK?

01:42:01.320 --> 01:42:03.960
So make sure that you understand this concept properly.

01:42:03.960 --> 01:42:05.960
Maybe with simple example like A and B.

01:42:05.960 --> 01:42:08.280
But understanding the concept is important here.

01:42:08.280 --> 01:42:10.520
We can go with complex example as well.

01:42:10.520 --> 01:42:11.600
Concept is important.

01:42:11.600 --> 01:42:14.120
So let's say we got class A, which has a method which is show.

01:42:14.120 --> 01:42:15.960
And we are printing in a show.

01:42:15.960 --> 01:42:16.280
That's it.

01:42:16.280 --> 01:42:17.200
Nothing fancy.

01:42:17.200 --> 01:42:19.000
Now, if I create an object of A here.

01:42:19.000 --> 01:42:22.560
So if I go back and if I say A1 is equal to A,

01:42:22.560 --> 01:42:24.520
so we are creating object of A, right?

01:42:24.520 --> 01:42:26.520
And with the help of this, we can call show.

01:42:26.520 --> 01:42:28.440
If you have this code, you can see we got in A show.

01:42:28.440 --> 01:42:29.560
That perfectly worked.

01:42:29.560 --> 01:42:31.600
Now, what if you create another class?

01:42:31.600 --> 01:42:33.920
Let's say class B, OK?

01:42:33.920 --> 01:42:38.400
And now imagine this class A is a parent and class B is a child.

01:42:38.400 --> 01:42:41.000
Example, let's say this is my dad and this is me.

01:42:41.000 --> 01:42:42.480
So we have B here.

01:42:42.480 --> 01:42:44.440
And time in, I'm not writing anything here.

01:42:44.440 --> 01:42:45.280
We say pass.

01:42:45.280 --> 01:42:46.760
I just want to keep it empty.

01:42:46.760 --> 01:42:48.440
OK, so we are keeping it empty.

01:42:48.440 --> 01:42:51.560
And let me create object of B, not A, but let me get object of B.

01:42:51.560 --> 01:42:53.000
And let's run this code.

01:42:53.000 --> 01:42:55.040
And you can see we got an error.

01:42:55.040 --> 01:42:58.200
It says B object has no attribute as show.

01:42:58.200 --> 01:43:00.400
Of course, in B, we don't have anything.

01:43:00.400 --> 01:43:02.600
At this point, you will use a concept of inheritance.

01:43:02.600 --> 01:43:06.960
And you will say, hey, B inherits A. So when you say B inherits A,

01:43:06.960 --> 01:43:10.520
it means you will get all the features of A to B.

01:43:10.520 --> 01:43:11.360
And let's run this code.

01:43:11.360 --> 01:43:13.080
And you can see we got in A show.

01:43:13.080 --> 01:43:15.320
Because of course, in B, we don't have show.

01:43:15.320 --> 01:43:17.280
The moment you run this code, it will first

01:43:17.320 --> 01:43:19.960
search for the method show inside B.

01:43:19.960 --> 01:43:23.160
Now, since we don't have that, it will go to A to search it.

01:43:23.160 --> 01:43:24.360
And that's how it works.

01:43:24.360 --> 01:43:26.080
So before going ahead, let me tell you one story.

01:43:26.080 --> 01:43:26.680
A small story.

01:43:26.680 --> 01:43:28.640
I've used this story in multiple examples

01:43:28.640 --> 01:43:30.080
when I was teaching Java as well.

01:43:30.080 --> 01:43:32.240
So the concept is, when I was in my 11th standard,

01:43:32.240 --> 01:43:35.960
when I've just joined my college, I was not having any phone.

01:43:35.960 --> 01:43:39.280
So a lot of people used to ask me, which phone you have.

01:43:39.280 --> 01:43:40.960
So I used to say, I don't have any phone.

01:43:40.960 --> 01:43:42.240
Because I was not having a phone.

01:43:42.240 --> 01:43:44.600
But then this question got repeated multiple times.

01:43:44.600 --> 01:43:46.560
Then I realized, OK, I have to say something.

01:43:46.560 --> 01:43:48.480
Now, at that point, my father was

01:43:48.480 --> 01:43:50.640
having a phone which is Nokia double one, double zero.

01:43:50.640 --> 01:43:51.760
I was not having any phone.

01:43:51.760 --> 01:43:54.120
So whenever someone used to ask me, which phone you have,

01:43:54.120 --> 01:43:56.560
I used to say, I got Nokia double one, double zero.

01:43:56.560 --> 01:43:57.520
I don't have a phone.

01:43:57.520 --> 01:43:58.880
But my father says a phone.

01:43:58.880 --> 01:44:00.600
So father's phone is my phone.

01:44:00.600 --> 01:44:01.680
That's how I think it works.

01:44:01.680 --> 01:44:05.920
So since B and B, my father is A. So B in hates A.

01:44:05.920 --> 01:44:07.520
So I got all the features.

01:44:07.520 --> 01:44:11.880
In this case, show is in A. In B, we don't have show.

01:44:11.880 --> 01:44:14.720
After some time, after a few months, I got a new phone.

01:44:14.720 --> 01:44:16.320
And that is Motorola phone.

01:44:16.320 --> 01:44:19.240
So my father has a Nokia phone, and I got Motorola phone.

01:44:19.240 --> 01:44:21.480
Now, if you ask me which phone I have, of course,

01:44:21.480 --> 01:44:22.400
I would say Motorola, right?

01:44:22.400 --> 01:44:24.040
I would not say Nokia, right?

01:44:24.040 --> 01:44:27.760
Because my phone overwrites my father's phone.

01:44:27.760 --> 01:44:29.160
That's what happened here.

01:44:29.160 --> 01:44:33.520
The moment you create a show method inside B as well,

01:44:33.520 --> 01:44:37.000
and if you try to print in B show.

01:44:37.000 --> 01:44:39.440
Because when we were not having show inside B,

01:44:39.440 --> 01:44:43.120
it was going to A. Now, since we have show inside B,

01:44:43.160 --> 01:44:46.360
it will print the show of B, right?

01:44:46.360 --> 01:44:47.960
So if you ask me which phone I have now,

01:44:47.960 --> 01:44:49.920
so I will say Motorola, not Nokia, right?

01:44:49.920 --> 01:44:52.760
So my phone overwrites my father's phone in the same way.

01:44:52.760 --> 01:44:56.120
This show overwrites the earlier show method.

01:44:56.120 --> 01:44:58.720
So this is how you work with method overriding.

01:44:58.720 --> 01:45:02.000
Again, we'll be doing this concept more in the next tutorials

01:45:02.000 --> 01:45:04.880
when we talked about abstract classes or interfaces.

01:45:04.880 --> 01:45:06.160
But this is awesome, right?

01:45:06.160 --> 01:45:08.160
Remember this point, when you call show,

01:45:08.160 --> 01:45:11.000
it will call the show method of this subclass

01:45:11.000 --> 01:45:12.760
if you have it, okay?

01:45:12.800 --> 01:45:13.600
So that's it, everyone.

01:45:13.600 --> 01:45:15.120
I hope you enjoyed this session.

01:45:15.120 --> 01:45:16.240
Let me know in the comment section

01:45:16.240 --> 01:45:18.440
and do subscribe for the videos.

