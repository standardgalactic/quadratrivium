1
00:00:00,000 --> 00:00:06,700
I'm going to use a few terms throughout this video that not everyone might understand.

2
00:00:06,700 --> 00:00:10,940
A plane is a mathematical term for a square or rectangle.

3
00:00:10,940 --> 00:00:14,500
This is mostly the walls, ceiling and floor.

4
00:00:14,500 --> 00:00:18,980
Vertices are the corners of said planes, the singular being vertex.

5
00:00:18,980 --> 00:00:23,780
Polygons are another term for surfaces derived from computer science rather than maths.

6
00:00:23,780 --> 00:00:26,500
It's going to be used interchangeably with plane.

7
00:00:26,500 --> 00:00:31,180
To do something recursively means a process must repeat itself over and over until an

8
00:00:31,180 --> 00:00:33,420
end goal is met to solve a problem.

9
00:00:33,420 --> 00:00:37,100
A data type is a way data is classified in programming.

10
00:00:37,100 --> 00:00:42,980
For example, a string, which are words or a series of letters, and int, which is an

11
00:00:42,980 --> 00:00:44,980
integer, a typical number.

12
00:00:44,980 --> 00:00:50,300
There are different kinds of numbers as well, such as float for precise decimal numbers,

13
00:00:50,300 --> 00:00:55,820
and long for, well, long numbers.

14
00:00:55,820 --> 00:01:02,020
Of the total size of the games industry today, around 20% are games within the shooter genre.

15
00:01:02,020 --> 00:01:07,740
Around a fifth of games in this $300 billion industry are shooters, most of them being

16
00:01:07,740 --> 00:01:09,460
first person shooters.

17
00:01:09,460 --> 00:01:14,340
The amount of money generated by and riding on the success of this singular genre in this

18
00:01:14,340 --> 00:01:16,300
industry is stupefying.

19
00:01:16,300 --> 00:01:21,140
The first person shooter as developed early on was a huge departure from every other kind

20
00:01:21,140 --> 00:01:23,500
of game that existed at the time.

21
00:01:23,580 --> 00:01:28,140
Games at the time, PC games especially, were often slow or methodical.

22
00:01:28,140 --> 00:01:32,900
The personal computer platform was known for careful and considered games.

23
00:01:32,900 --> 00:01:38,540
Turn-based strategy, grand RPGs with a slowly unfolding world, oftentimes these games would

24
00:01:38,540 --> 00:01:41,220
be indistinguishable from a spreadsheet.

25
00:01:41,220 --> 00:01:43,660
Action was the realm of console gaming.

26
00:01:43,660 --> 00:01:47,620
Platformers were the most immediate real-time action-packed games available, and besides

27
00:01:47,620 --> 00:01:52,340
notable games like Duke Nukem and Commander Keen, people didn't really play those kind

28
00:01:52,340 --> 00:01:54,300
of action games on PC.

29
00:01:54,300 --> 00:01:56,940
This was until the advent of the first person shooter.

30
00:01:56,940 --> 00:02:01,300
Suddenly, people were hit with this visceral representation of violence.

31
00:02:01,300 --> 00:02:03,580
They represented something which films could not.

32
00:02:03,580 --> 00:02:06,420
You inhabit a world through the lens of the character.

33
00:02:06,420 --> 00:02:10,900
You are closer to the action hero than ever before in any medium in history.

34
00:02:10,900 --> 00:02:16,060
What is widely agreed upon as the first first person shooter ever is Maze War.

35
00:02:16,060 --> 00:02:20,540
Developed in 1973, that's the same year Britain joined the European Union, Dark Side of the

36
00:02:20,540 --> 00:02:24,300
Moon was released, and the United States announced it would withdraw from Vietnam.

37
00:02:24,300 --> 00:02:28,860
It was developed for NASA computers by Steve Colley, Greg Thompson and Howard Palmer.

38
00:02:28,860 --> 00:02:31,620
It was constructed with simple wireframe graphics.

39
00:02:31,620 --> 00:02:36,780
People had the idea of adding multiple players using networking and connecting over the ARPANET.

40
00:02:36,780 --> 00:02:37,780
Then it took off.

41
00:02:37,780 --> 00:02:44,140
We saw other first person shooter games after that point, Spasm or Space Sim in 1974, Battle

42
00:02:44,140 --> 00:02:47,020
Zone for arcades in 1980.

43
00:02:47,020 --> 00:02:51,860
As these few examples, for the majority of the decades following its inception, the first

44
00:02:51,860 --> 00:02:56,540
person perspective was known mostly for its association with the role playing genre.

45
00:02:56,540 --> 00:02:58,300
For example, games like Ultima.

46
00:02:58,300 --> 00:03:03,460
Now, first person shooting did technically exist, but you were merely shooting projectiles

47
00:03:03,460 --> 00:03:04,540
at your friends.

48
00:03:04,540 --> 00:03:06,100
You weren't inhabiting a character.

49
00:03:06,100 --> 00:03:08,460
You weren't the action hero fighting bad guys.

50
00:03:08,460 --> 00:03:11,380
That was until Wolfenstein 3D.

51
00:03:11,380 --> 00:03:16,300
Each software was founded in 1991 by four former soft disk employees, John and Adrian

52
00:03:16,300 --> 00:03:21,280
Carmack, no relation, they just happened to have the same name, Tom Hall and John Romero.

53
00:03:21,280 --> 00:03:24,260
This was the same year the Soviet Union fell.

54
00:03:24,260 --> 00:03:26,380
Carmack is going to be more important later on.

55
00:03:26,380 --> 00:03:30,820
They originally began with a Mario clone named Dangerous Dave before the company was officially

56
00:03:30,820 --> 00:03:31,820
founded.

57
00:03:31,820 --> 00:03:35,580
This was mainly to shelf the beginnings of John Carmack's technical wizardry, encoding

58
00:03:35,580 --> 00:03:38,580
an efficient 2D side scrolling graphics renderer.

59
00:03:38,580 --> 00:03:43,780
The early 90s, when everything was a dark and edgy statement, the satanic inversion

60
00:03:43,780 --> 00:03:46,340
between PC and console was no exception.

61
00:03:46,340 --> 00:03:49,420
PC graphics using software rendering were terrible.

62
00:03:49,420 --> 00:03:54,940
John Carmack developed his adaptive tile refresh for the PC to compete with the raw computational

63
00:03:54,940 --> 00:03:58,660
power of the Super Nintendo, a true beast.

64
00:03:58,660 --> 00:04:02,300
Adapted tile refresh meant that slightly more of the game world could be included in the

65
00:04:02,300 --> 00:04:04,660
screen buffer, just outside of view.

66
00:04:04,660 --> 00:04:07,380
This meant they could render smooth 2D scrolling.

67
00:04:07,380 --> 00:04:11,420
It also made the sprite animations independent from screen scrolling.

68
00:04:11,420 --> 00:04:16,140
This little bit of code magic powered their games, including the Commander Keen series.

69
00:04:16,140 --> 00:04:20,540
The Commander Keen series was spread through shareware with subsequent episodes releasing

70
00:04:20,540 --> 00:04:24,380
over the next year or so for purchase from Apogee, their publisher.

71
00:04:24,380 --> 00:04:29,300
This shareware model would be important because it would be used in their subsequent games.

72
00:04:29,300 --> 00:04:33,220
Speaking of subsequent games.

73
00:04:33,220 --> 00:04:36,860
Wolfenstein 3D began development in 1991.

74
00:04:36,860 --> 00:04:41,660
It would use the ray casting technique, earlier employed in Id's Catacomb 3D.

75
00:04:41,660 --> 00:04:46,500
Ray casting was a rendering technique necessitated again by the limited processing power of

76
00:04:46,500 --> 00:04:48,300
PCs at the time.

77
00:04:48,300 --> 00:04:51,260
PC master race just can't stop losing.

78
00:04:51,260 --> 00:04:55,780
PCs almost all used software rendering, rather than a dedicated graphics chip.

79
00:04:55,780 --> 00:05:00,300
The shareware model involved getting the game on as many PCs as possible.

80
00:05:00,300 --> 00:05:03,060
Ray casting was the solution to help them do this.

81
00:05:03,060 --> 00:05:07,460
Ray casting allowed their game to run on basically any PC.

82
00:05:07,460 --> 00:05:11,740
Ray casting means you're able to draw only the surfaces which are in the player's field

83
00:05:11,740 --> 00:05:12,740
of view.

84
00:05:12,740 --> 00:05:16,140
This helped massively in saving processing power, but how does it work?

85
00:05:16,140 --> 00:05:21,540
In effect, a ray is cast, from the player to the geometry, to the nearest object blocking

86
00:05:21,540 --> 00:05:22,540
its path.

87
00:05:22,540 --> 00:05:25,860
In Wolfenstein, none of the levels were truly 3D.

88
00:05:25,860 --> 00:05:28,820
Every level was drawn out on a flat 2D plane.

89
00:05:28,820 --> 00:05:33,700
The program scans horizontally, checking that every pixel on the horizontal axis has

90
00:05:33,700 --> 00:05:34,940
something drawn in it.

91
00:05:34,940 --> 00:05:39,500
If there's nothing drawn in a position, a pixel column will be drawn out.

92
00:05:39,500 --> 00:05:43,700
This is simplified from the process of ray tracing, where this process is done for every

93
00:05:43,700 --> 00:05:46,580
single pixel, rather than every pixel column.

94
00:05:46,580 --> 00:05:51,060
The distance between the viewer, or the camera, or player, they all have the same meaning,

95
00:05:51,060 --> 00:05:53,420
and the nearest piece of geometry is obtained.

96
00:05:53,420 --> 00:05:58,420
The height of the pixel column is calculated using the distance from point of intersection

97
00:05:58,500 --> 00:06:00,860
in the direction the player is facing.

98
00:06:00,860 --> 00:06:04,420
It uses trigonometry to find this point of intersection.

99
00:06:04,420 --> 00:06:09,220
This effectively allowed them to give the illusion of distance to render a 3D scene.

100
00:06:09,220 --> 00:06:14,580
This makes the process of rendering 3D much easier, as a line, that line being distance

101
00:06:14,580 --> 00:06:20,340
from player to geometry, directly transforms to a line, that being the height of the rendered

102
00:06:20,340 --> 00:06:21,340
column.

103
00:06:21,340 --> 00:06:24,460
This process is done multiple times every single second.

104
00:06:24,460 --> 00:06:29,340
The planes in the scene had been texture mapped, where an image is applied to a 3D surface.

105
00:06:29,340 --> 00:06:34,380
When the columns are drawn, they are really drawing slices of these wall textures at different

106
00:06:34,380 --> 00:06:35,380
sizes.

107
00:06:35,380 --> 00:06:40,300
The height of the column being drawn is smaller when the plane, that being the wall, is further

108
00:06:40,300 --> 00:06:41,300
away from you.

109
00:06:41,300 --> 00:06:45,860
The textures are scaled appropriately to the size of the wall relative to the player.

110
00:06:45,860 --> 00:06:49,340
This gave the world of Wolfenstein so much believability for the time.

111
00:06:49,420 --> 00:06:52,820
You were no longer just navigating wireframe mazes.

112
00:06:52,820 --> 00:06:57,940
You were an action hero, BJ Blazkowicz, infiltrating a Nazi castle.

113
00:06:57,940 --> 00:07:00,900
The walls were adorned with flags of the German Reich.

114
00:07:00,900 --> 00:07:06,220
You felt closer to the world than ever before, you were interacting with a true 3D space.

115
00:07:06,220 --> 00:07:08,460
This process was, however, flawed.

116
00:07:08,460 --> 00:07:13,260
In Wolfenstein 3D, there was no verticality at all, no difference in elevation, only the

117
00:07:13,260 --> 00:07:16,780
walls had texture, the ceiling and floor had to be flat colours.

118
00:07:17,100 --> 00:07:20,700
If they wanted texture on the ceiling and floor, they would have had to add horizontal

119
00:07:20,700 --> 00:07:21,700
scan lines.

120
00:07:21,700 --> 00:07:26,860
You were still ultimately navigating a maze, a colourful maze with Nazis in it, but a maze

121
00:07:26,860 --> 00:07:27,860
nonetheless.

122
00:07:27,860 --> 00:07:33,820
Wolfenstein 3D was released in May 1992, the sequels Spear of Destiny was released later

123
00:07:33,820 --> 00:07:34,820
in the same year.

124
00:07:34,820 --> 00:07:39,540
While the rest of the id team was working on Spear of Destiny, John Carmack, the ascetic,

125
00:07:39,540 --> 00:07:44,420
high priest of technology, locked himself away to study, who had brainstormed the revolutionary

126
00:07:44,420 --> 00:07:47,220
tech that would power their next massive game.

127
00:07:47,220 --> 00:07:52,340
The next game that the rest of the team would start working on in September 1992, it would

128
00:07:52,340 --> 00:07:56,100
be something inspired by Evil Dead, brutal and violent.

129
00:07:56,100 --> 00:08:02,220
The name, green and pissed, was ultimately passed up for the much snappier, Doom.

130
00:08:02,220 --> 00:08:08,020
Doom would launch in 1993, the game would truly be able to transport you into a world.

131
00:08:08,020 --> 00:08:10,660
The levels truly felt like places.

132
00:08:10,660 --> 00:08:15,700
The architecture of Doom consisted of supernatural science facilities, with Geiger-esque and

133
00:08:15,700 --> 00:08:17,740
halish environments as well.

134
00:08:17,740 --> 00:08:23,060
The enemies were a combination of horror and sci-fi with cybernetically enhanced demons.

135
00:08:23,060 --> 00:08:27,820
The architecture, over the top setting and violence was inspired by films such as Evil

136
00:08:27,820 --> 00:08:29,180
Dead and Alien.

137
00:08:29,180 --> 00:08:34,580
The floors could now be angled, they could now have multiple levels with stairs and elevators.

138
00:08:34,580 --> 00:08:38,100
The pools of toxic fluid surrounded these risen platforms.

139
00:08:38,100 --> 00:08:41,540
It was truly 3D, but it wasn't really.

140
00:08:41,540 --> 00:08:46,180
They were yet to achieve the full 6 degrees of freedom that John Romero wanted.

141
00:08:46,180 --> 00:08:48,180
This wouldn't happen until Quake.

142
00:08:48,180 --> 00:08:51,700
Rooms couldn't be stacked on top of each other, there was no vertical aim, the game

143
00:08:51,700 --> 00:08:54,780
was entirely played on the horizontal axis.

144
00:08:54,780 --> 00:08:58,540
The thing is, vertical aim was actually possible at the time.

145
00:08:58,540 --> 00:09:03,020
They could have limited the enemy's vertical hitboxes to the size of the sprite, but they

146
00:09:03,020 --> 00:09:04,020
didn't.

147
00:09:04,060 --> 00:09:06,900
Because they couldn't, but to save processing power.

148
00:09:06,900 --> 00:09:09,780
You see, Doom was still using software rendering.

149
00:09:09,780 --> 00:09:13,940
Its shareware model relied on getting their games on as many computers as possible, like

150
00:09:13,940 --> 00:09:14,940
I said.

151
00:09:14,940 --> 00:09:18,740
It was essentially the beginning of the free-to-play game model we have today.

152
00:09:18,740 --> 00:09:22,980
They aimed for the IBM PC, for machines running DOS.

153
00:09:22,980 --> 00:09:27,460
They had to sell their game to university students and wages who were bored at work

154
00:09:27,460 --> 00:09:29,500
so they could run off as tournaments.

155
00:09:29,500 --> 00:09:33,860
They didn't calculate the enemy's vertical hitbox so that they could save memory.

156
00:09:33,860 --> 00:09:37,900
They didn't want to give the enemy's hitboxes a height value, just have another factor to

157
00:09:37,900 --> 00:09:38,900
calculate.

158
00:09:38,900 --> 00:09:43,100
All the levels were drawn on a 2D plane, like Wolfenstein.

159
00:09:43,100 --> 00:09:46,140
Just this time, the map creator is quite different.

160
00:09:46,140 --> 00:09:50,700
The ground is divided into sectors, this will be very important later.

161
00:09:50,700 --> 00:09:56,060
Each sector has two associated values, ceiling height and floor height, well it has several

162
00:09:56,060 --> 00:09:59,420
associated values, but those are two important ones.

163
00:09:59,420 --> 00:10:03,380
This is also why one room could not be placed above another and why every surface had to

164
00:10:03,380 --> 00:10:06,340
be made out of a flat square or rectangle.

165
00:10:06,340 --> 00:10:10,140
Another reason that vertical aim couldn't have worked is due to how the texture mapping

166
00:10:10,140 --> 00:10:11,140
worked.

167
00:10:11,140 --> 00:10:16,060
One game that did have vertical aim and levels on top of each other, before Quake and not

168
00:10:16,060 --> 00:10:19,420
that long after Doom, was Bungie's Marathon.

169
00:10:19,420 --> 00:10:22,820
And look what happens when you look up and down in that game.

170
00:10:22,820 --> 00:10:29,620
The textures start to distort, this is because the game, like Doom, uses affine texture mapping.

171
00:10:29,620 --> 00:10:34,780
This, like many of the other methods, was done to save memory on the processor by taking

172
00:10:34,780 --> 00:10:37,180
advantage of CPU caching.

173
00:10:37,180 --> 00:10:43,660
Basically what happens is that texture coordinates are linearly interpolated, using screen space

174
00:10:43,660 --> 00:10:49,700
distance between vertices, rather than the actual 3D in-engine distance between them.

175
00:10:49,700 --> 00:10:54,020
The distance between points on a plane remains the same when you look up and down.

176
00:10:54,020 --> 00:10:58,380
What this means is that perspective when looking up and down is not accounted for.

177
00:10:58,380 --> 00:11:02,220
You know how pixels on a texture start to warp as you get closer?

178
00:11:02,220 --> 00:11:07,620
What looks like a straight line from far away begins to turn inward as closer pixels get

179
00:11:07,620 --> 00:11:11,380
larger while more distant pixels get smaller.

180
00:11:11,380 --> 00:11:17,260
This doesn't happen in Doom, because accounting for perspective is taxing on 90s computers.

181
00:11:17,260 --> 00:11:21,500
You know how the game only draws things in columns to save processing time?

182
00:11:21,500 --> 00:11:25,780
They'd have had to do vertical scans as well as horizontal scans.

183
00:11:25,780 --> 00:11:31,580
Several ports of Doom with newer rendering engines made for new hardware like GZDOOM

184
00:11:31,580 --> 00:11:33,860
obviously don't have this limitation.

185
00:11:33,860 --> 00:11:37,940
As such, they use more current texture mapping and don't have this issue.

186
00:11:37,940 --> 00:11:40,460
But all of these concessions weren't enough.

187
00:11:40,460 --> 00:11:46,300
John Carmack's coding brilliance met its most devious enemy yet, Stairs.

188
00:11:46,300 --> 00:11:51,820
John Romero came out with a really way out and strange idea on his early incarnation of

189
00:11:51,820 --> 00:11:52,820
E1M2.

190
00:11:53,180 --> 00:11:58,740
Yes, he wanted to mix things up with the earth-shattering invention of Stairs.

191
00:11:58,740 --> 00:12:03,620
You see, just raycasting alone wasn't enough to efficiently optimise the game.

192
00:12:03,620 --> 00:12:07,460
Raycasting saves memory by only rendering things which are visible to the player.

193
00:12:07,460 --> 00:12:12,900
However, surfaces on the inside of these stairs were visible to the existing algorithm, thus

194
00:12:12,900 --> 00:12:15,340
they were drawn when they shouldn't have been.

195
00:12:15,340 --> 00:12:20,900
You see, for 3D rendering to not waste performance, they need to draw as few surfaces as few planes

196
00:12:20,900 --> 00:12:21,900
as possible.

197
00:12:21,900 --> 00:12:27,460
This necessitates occlusion culling, or visible surface determination, or backface culling.

198
00:12:27,460 --> 00:12:33,340
Basically, the renderer should only draw what is in the player's field of view.

199
00:12:33,340 --> 00:12:37,020
They need to be absolutely no overdraw whatsoever.

200
00:12:37,020 --> 00:12:43,060
Adding height as a variable, such as with Romero's stairs, requires a much more sophisticated

201
00:12:43,060 --> 00:12:48,980
algorithm than was present in Wolfenstein and in Id's existing rendering engine.

202
00:12:48,980 --> 00:12:53,260
There are many different rendering algorithms out there, it seems that we need to dip into

203
00:12:53,260 --> 00:12:58,660
the hypothetical algorithms to start trawling the literature for some better algorithms.

204
00:12:58,660 --> 00:13:00,460
Let's explore some of the options.

205
00:13:00,460 --> 00:13:04,140
There's the painter's algorithm, named so because, like in a painting, the background

206
00:13:04,140 --> 00:13:07,020
is rendered first, with detail laid on top.

207
00:13:07,020 --> 00:13:10,980
Basically, the polygons are sorted by their distance from the viewer, and the more distant

208
00:13:10,980 --> 00:13:14,820
polygons are rendered first, and the close polygon is rendered last.

209
00:13:14,820 --> 00:13:21,420
It is easily the most simple solution, it was developed in 1972, the year MASH started,

210
00:13:21,420 --> 00:13:24,140
as an easy to implement solution for CAD.

211
00:13:24,140 --> 00:13:29,260
It also has the worst possible case for space complexity, meaning it takes up as much memory

212
00:13:29,260 --> 00:13:31,820
as an algorithm possibly could.

213
00:13:31,820 --> 00:13:34,620
Every single surface in the field of view is drawn.

214
00:13:34,620 --> 00:13:37,140
Obviously, this isn't a good fit.

215
00:13:37,140 --> 00:13:41,380
It's more of an example from the early days of exactly what not to do.

216
00:13:41,380 --> 00:13:45,900
There's also Warnock's algorithm, John Warnock was the founder of Adobe, and this algorithm

217
00:13:45,900 --> 00:13:51,780
originated in his doctoral thesis in 1969, the year man landed on the moon and in the

218
00:13:51,780 --> 00:13:53,860
court of the crimson king was released.

219
00:13:53,860 --> 00:13:57,900
Essentially, it recursively subdivides the screen into four parts.

220
00:13:57,900 --> 00:14:01,820
What this means is it splits the screen into four windows and splits each window into four

221
00:14:01,820 --> 00:14:02,940
smaller windows.

222
00:14:02,940 --> 00:14:07,980
It does this again and again until each window is trivial to render, meaning it has only

223
00:14:07,980 --> 00:14:10,700
one or zero polygons present.

224
00:14:10,700 --> 00:14:14,940
The algorithm also checks if multiple polygons are within one window.

225
00:14:14,940 --> 00:14:19,020
If the closest polygon covers the whole window, then it is drawn.

226
00:14:19,020 --> 00:14:23,460
This is more efficient than painter's algorithm as it renders front to back, but it's still

227
00:14:23,460 --> 00:14:25,140
not very well suited.

228
00:14:25,140 --> 00:14:30,780
It will eventually keep subdividing to a ridiculous degree, to the point where a window is smaller

229
00:14:30,780 --> 00:14:31,780
than a pixel.

230
00:14:31,780 --> 00:14:34,380
Yet, this ain't a good fit for a game.

231
00:14:34,380 --> 00:14:38,060
You could do a Zed buffer, for every pixel you want to draw, check if there's anything

232
00:14:38,060 --> 00:14:39,060
in front of it.

233
00:14:39,060 --> 00:14:40,780
Doing a check on every single pixel?

234
00:14:40,780 --> 00:14:42,740
Yeah, there's no chance in hell.

235
00:14:42,740 --> 00:14:47,700
The final solution does kinda use a Zed buffer, but it doesn't do that check on every single

236
00:14:47,700 --> 00:14:48,700
pixel.

237
00:14:48,700 --> 00:14:50,820
It finds a much more efficient way to do it.

238
00:14:50,820 --> 00:14:51,820
No.

239
00:14:51,820 --> 00:14:57,860
In order to truly revolutionise not just gaming, but 3D graphics forever, our protagonist,

240
00:14:57,860 --> 00:15:02,100
John Carmack, needs to go to a much more inspired source.

241
00:15:02,100 --> 00:15:04,940
Something that hadn't actually been implemented before.

242
00:15:04,940 --> 00:15:06,940
Something you just read in a white paper.

243
00:15:06,940 --> 00:15:07,940
Just a concept.

244
00:15:07,940 --> 00:15:12,980
Yes, how common is it in gaming to see people run into optimisation issues, and seek out

245
00:15:12,980 --> 00:15:15,340
a white paper to solve their problem?

246
00:15:15,340 --> 00:15:17,220
Cause nobody else had done it before.

247
00:15:17,220 --> 00:15:19,100
Yes, that's Carmack for you.

248
00:15:19,100 --> 00:15:23,700
We needed a renderer that would draw objects closest to the player to furthest away until

249
00:15:23,700 --> 00:15:25,780
every pixel was written to.

250
00:15:25,780 --> 00:15:27,540
That had no overdraw.

251
00:15:27,540 --> 00:15:30,660
The solution was in a 1980 white paper.

252
00:15:30,660 --> 00:15:33,900
That's the same year Genesis released the reclaimed album.

253
00:15:33,900 --> 00:15:40,460
Dook, where they really came into their own.

254
00:15:40,460 --> 00:15:45,820
This 1980 white paper by Bruce Nailot was given the humble title, On visible surface

255
00:15:45,820 --> 00:15:49,060
generation by a priori tree structures.

256
00:15:49,060 --> 00:15:55,460
It described a rendering model we know as binary space partitioning, or BSP for short.

257
00:15:55,460 --> 00:15:58,700
This was the method that would change gaming for years.

258
00:15:58,700 --> 00:16:02,260
This wasn't the first time binary space partitioning was alluded to.

259
00:16:02,260 --> 00:16:08,420
A 1969 study by the Air Force of the Good Old US of A, alluded to the use of partitioning

260
00:16:08,420 --> 00:16:12,020
3D scenes to solve the visible surface problem.

261
00:16:12,020 --> 00:16:17,340
The study was conducted to determine the viability of 3D for flight simulation.

262
00:16:17,340 --> 00:16:21,380
We can thank the armed forces of the United States for giving us doom.

263
00:16:21,380 --> 00:16:24,900
They explored using a matrix to track which objects are occluded.

264
00:16:24,900 --> 00:16:29,220
This of course wouldn't do so well as the size of the matrix would need to be the square

265
00:16:29,220 --> 00:16:31,780
of the number of objects in a scene.

266
00:16:31,780 --> 00:16:33,660
That wouldn't scale very well.

267
00:16:33,660 --> 00:16:39,220
It wasn't until 1980 that binary space partitioning was properly realised in the white paper that

268
00:16:39,220 --> 00:16:43,860
would reach John Carmack alongside its core tenet, the binary tree.

269
00:16:43,860 --> 00:16:46,860
But what is binary space partitioning anyway?

270
00:16:46,860 --> 00:16:48,780
Well, the name gives you a clue.

271
00:16:48,780 --> 00:16:52,060
Is partitioning space in a 3D environment?

272
00:16:52,060 --> 00:16:54,940
This is done using a BSP tree.

273
00:16:54,940 --> 00:16:57,100
What is a BSP tree you may ask?

274
00:16:57,100 --> 00:17:02,020
In computer science, a tree is a data structure used as a mathematical model for displaying

275
00:17:02,020 --> 00:17:03,940
certain data types.

276
00:17:03,940 --> 00:17:08,540
It's separated into nodes with parent nodes that have child nodes.

277
00:17:08,540 --> 00:17:11,500
BSP uses binary trees.

278
00:17:11,500 --> 00:17:13,260
Binary essentially meaning two.

279
00:17:13,260 --> 00:17:18,740
A binary tree is a tree where there are two or less child nodes stemming from any given

280
00:17:18,740 --> 00:17:20,260
parent, from any node.

281
00:17:20,260 --> 00:17:23,340
There are never more than two child nodes.

282
00:17:23,340 --> 00:17:28,140
This is as opposed to a non-binary tree, which is a tree that has dyed hair and a gender

283
00:17:28,140 --> 00:17:29,300
studies degree.

284
00:17:29,300 --> 00:17:34,820
The data stored in the nodes of the binary tree are the subsectors of the map.

285
00:17:34,820 --> 00:17:39,620
Subsectors being smaller parts of those map sectors I spoke about earlier.

286
00:17:39,620 --> 00:17:45,380
Remember, each map is designed on a flat 2D map editor, with each sector having associated

287
00:17:45,380 --> 00:17:46,580
height values.

288
00:17:46,580 --> 00:17:51,740
The genius is that the map is sliced up via binary space partitioning after the map is

289
00:17:51,740 --> 00:17:52,740
built.

290
00:17:52,740 --> 00:17:58,660
The hard work is done when the map is created, rather than by the processor at runtime, while

291
00:17:58,660 --> 00:18:00,380
the player is playing the game.

292
00:18:00,380 --> 00:18:06,220
The map is already split, already partitioned when the player loads it, reducing processing

293
00:18:06,220 --> 00:18:07,900
needed at runtime.

294
00:18:07,900 --> 00:18:13,020
To create the binary tree, a root node is established, covering the whole map.

295
00:18:13,020 --> 00:18:19,620
After this, the map is recursively subdivided along every plane, until only convex subsectors

296
00:18:19,620 --> 00:18:20,620
are left.

297
00:18:20,620 --> 00:18:24,100
Subsectors are carved into smaller subsectors.

298
00:18:24,100 --> 00:18:28,900
The entire map is essentially cut in two, along every single wall.

299
00:18:28,900 --> 00:18:33,860
Every time the map is cut in half, the two halves are added as nodes at the bottom of

300
00:18:33,860 --> 00:18:34,860
the tree.

301
00:18:34,860 --> 00:18:40,380
By the end, you're left with a tree where each node at the bottom of the tree represents

302
00:18:40,380 --> 00:18:42,380
a distinct subsector.

303
00:18:42,380 --> 00:18:47,500
Remember, this tree is entirely conceptual, it doesn't actually exist.

304
00:18:47,500 --> 00:18:52,940
So long as the planes don't move, vertical movement is accepted from this because vertical

305
00:18:52,940 --> 00:18:58,100
movement is a separate value, the same BSP tree can be used.

306
00:18:58,100 --> 00:19:04,060
Dooms BSP tree generation was done after levels were complete and would search for the best

307
00:19:04,060 --> 00:19:09,020
possible tree, that being the one that generates the fewest binary tree nodes.

308
00:19:09,020 --> 00:19:13,220
A binary search is performed to determine what sector the player is in.

309
00:19:13,220 --> 00:19:18,660
A binary search is when an array of pre-sorted data is searched through by continually halving

310
00:19:18,660 --> 00:19:19,660
said array.

311
00:19:19,660 --> 00:19:24,700
A search through a binary tree is, by its nature, a binary search, because every time

312
00:19:24,700 --> 00:19:29,060
you go down a node, you're removing half of the possibilities.

313
00:19:29,060 --> 00:19:34,060
After the player's sector is determined using this binary search, the subsectors are then

314
00:19:34,060 --> 00:19:38,220
sorted by their distance from the player, closest to furthest.

315
00:19:38,220 --> 00:19:42,260
The tree is iterated through to determine which planes to draw.

316
00:19:42,260 --> 00:19:47,180
The horizontal scan lines from ray casting are still used to track the parts of the screen

317
00:19:47,180 --> 00:19:48,820
that have been drawn over.

318
00:19:48,820 --> 00:19:53,580
This way they are able to render front to back and ensure that there is no overdraw.

319
00:19:53,580 --> 00:19:57,820
When each node is passed over in the iteration, a few things are checked.

320
00:19:57,820 --> 00:19:59,980
Has that area already been painted over?

321
00:19:59,980 --> 00:20:02,260
If so, don't bother drawing it.

322
00:20:02,300 --> 00:20:08,620
When a plane, polygon, or wall is drawn, it is akin to a curtain being drawn left to right.

323
00:20:08,620 --> 00:20:10,700
To unveil an area, so to speak.

324
00:20:10,700 --> 00:20:16,500
Whenever a curtain is seen by the player, it is unveiled, from closest to the furthest.

325
00:20:16,500 --> 00:20:20,660
To be exact, it's the closest 256 walls that are displayed.

326
00:20:20,660 --> 00:20:26,180
Remember how height of the pixel columns drawn on screen depended on distance from the player?

327
00:20:26,180 --> 00:20:31,780
For Doom, this required determining the angle of both ends of every wall, relative to the

328
00:20:31,780 --> 00:20:33,420
player's field of view.

329
00:20:33,420 --> 00:20:38,540
In the early 90s, most processors didn't have dedicated floating point capability.

330
00:20:38,540 --> 00:20:43,020
This is a float in programming, if you've ever heard of that, basically a data type

331
00:20:43,020 --> 00:20:45,340
for very precise decimal numbers.

332
00:20:45,340 --> 00:20:51,620
The Doom engine had to use binary angle measurements, which avoid floats, and used a lookup table

333
00:20:51,620 --> 00:20:53,980
to determine the X coordinates.

334
00:20:53,980 --> 00:20:56,940
A lookup table is essentially a cheat sheet.

335
00:20:56,940 --> 00:21:01,660
Instead of the processor doing the maths itself, it just looks up the answer in this lookup

336
00:21:02,300 --> 00:21:03,300
table.

337
00:21:03,300 --> 00:21:09,140
They also use these angles for backface culling, with a simple and elegant piece of mathematics.

338
00:21:09,140 --> 00:21:14,380
Backface culling basically means the renderer doesn't draw the inside of every polygon.

339
00:21:14,380 --> 00:21:18,100
It only draws the part on the outside that you actually see.

340
00:21:18,100 --> 00:21:22,380
The walls are rendered first as pixel columns, from front to back.

341
00:21:22,380 --> 00:21:25,820
Then the ceilings and floors, using pixel rows.

342
00:21:25,820 --> 00:21:31,500
The objects, such as barrels and enemies, are rendered from the furthest to the closest.

343
00:21:31,500 --> 00:21:37,580
The ceilings and floors are determined using visplane underscore T, or visplanes.

344
00:21:37,580 --> 00:21:41,260
Visplanes were determined using height values within each sector.

345
00:21:41,260 --> 00:21:46,940
Visplanes are not constrained to single sectors, and will be continuous provided they all possess

346
00:21:46,940 --> 00:21:50,580
the same height, illumination, and textures.

347
00:21:50,580 --> 00:21:53,180
Pixel rows are drawn, top to bottom.

348
00:21:53,180 --> 00:21:58,300
One final thing you may wonder about Doom's graphics, is why are all the enemies just

349
00:21:58,300 --> 00:22:00,780
pictures facing towards you?

350
00:22:00,860 --> 00:22:04,820
There's nothing to do with them being what we call front facing sprites.

351
00:22:04,820 --> 00:22:08,940
They're rendered last, and like I said, furthest to closest.

352
00:22:08,940 --> 00:22:11,300
That's the opposite order to the geometry.

353
00:22:11,300 --> 00:22:16,300
They are just pictures, taken from the data files and projected onto screen.

354
00:22:16,300 --> 00:22:18,820
Of course, there are a range of pictures.

355
00:22:18,820 --> 00:22:23,980
The one that is drawn depends on the player's location relative to the enemy, and the direction

356
00:22:23,980 --> 00:22:25,460
the enemy is facing.

357
00:22:25,460 --> 00:22:29,020
The enemies do actually have a full 3D hitbox.

358
00:22:29,020 --> 00:22:34,220
The pictures, as most fans know, are actually from real pictures taken of sculptures made

359
00:22:34,220 --> 00:22:35,580
by the artists.

360
00:22:35,580 --> 00:22:41,500
So, John Carmack was faced with a fierce issue in the problem of visible surface determination.

361
00:22:41,500 --> 00:22:46,740
He had to find a solution that was both incredibly fast and very accurate.

362
00:22:46,740 --> 00:22:52,980
BSP doesn't completely solve the visible surface determination problem, but it is one

363
00:22:52,980 --> 00:22:56,940
of the most reliable and efficient methods of optimization.

364
00:22:56,940 --> 00:22:59,180
It saw massive acceptance.

365
00:22:59,180 --> 00:23:04,340
BSPs were evolved and made their way into Quake's dramatically improved game engine

366
00:23:04,340 --> 00:23:09,820
when they took on Michael A. Brash and finally figured out the full 6 degrees of freedom.

367
00:23:09,820 --> 00:23:14,660
From there, it was in every FPS, and I mean all of them.

368
00:23:14,660 --> 00:23:20,660
Half-Life and Half-Life 2, every source game, Counter-Strike to Left 4 Dead, the Halo series

369
00:23:20,660 --> 00:23:21,660
used it.

370
00:23:21,660 --> 00:23:24,740
You know the Scarab from Halo 2 is actually a BSP object?

371
00:23:24,740 --> 00:23:27,980
Yes, it's a moving piece of level geometry.

372
00:23:27,980 --> 00:23:33,020
Many would say it's a sign of Carmack's genius, that he took an idea from concept to

373
00:23:33,020 --> 00:23:34,820
mainstream solution.

374
00:23:34,820 --> 00:23:41,300
He did all this crazy work in between supercharging Ferraris and becoming a judo master.

375
00:23:41,300 --> 00:23:44,380
You know, one time he got locked inside a building.

376
00:23:44,380 --> 00:23:49,740
Instead of, say, waiting for security or calling a locksmith, he devised a brilliant solution.

377
00:23:49,740 --> 00:23:54,780
He'd luckily gone to Renaissance Fair earlier, where he bought a medieval battle axe.

378
00:23:54,780 --> 00:23:58,780
So naturally, he smashed down the door with his mighty axe.

379
00:23:58,780 --> 00:24:01,540
He was rich so he could afford to get the door fixed.

380
00:24:01,540 --> 00:24:07,300
He truly is a unique figure in the gaming industry, and you can see why he's so highly

381
00:24:07,300 --> 00:24:08,300
respected.

382
00:24:08,300 --> 00:24:12,020
If you made it this far, comment, thank you John Carmack.

383
00:24:12,020 --> 00:24:17,700
The use of BSP trees has begun to be replaced over the last few years.

384
00:24:17,700 --> 00:24:20,740
These instead opt for things like static meshes.

385
00:24:20,740 --> 00:24:25,620
With more powerful hardware now, they could afford some level of overdraw.

386
00:24:25,620 --> 00:24:30,380
Other methods give artists more creative freedom and a much quicker workflow.

387
00:24:30,380 --> 00:24:36,420
BSP often leads to the distinct blocky look that many old games had.

388
00:24:36,420 --> 00:24:41,820
One could certainly argue that these technical limitations are what gave Source Maps and

389
00:24:41,820 --> 00:24:47,540
early 2000's maps in general, their distinct charm, their soul.

390
00:24:47,540 --> 00:24:54,500
With stark and distinct architectural choices, some magic is truly lost in busy modern day

391
00:24:54,500 --> 00:24:55,500
maps.

392
00:24:55,500 --> 00:25:01,140
Many new games have actually tried to go back to recreating these older, cleaner, more distinct

393
00:25:01,140 --> 00:25:02,140
visuals.

394
00:25:02,140 --> 00:25:07,620
BSP is still occasionally used today in prototyping levels for games, quickly blocking them out.

395
00:25:07,620 --> 00:25:11,260
It's of course still used in games such as Counter-Strike Go.

396
00:25:11,260 --> 00:25:16,000
This was a big video and naturally took a bit of research which I've provided links

397
00:25:16,000 --> 00:25:17,500
to in the description.

398
00:25:17,500 --> 00:25:24,060
If I got anything wrong, please feel free, in fact feel obligated to call me out in the

399
00:25:24,060 --> 00:25:25,060
comments.

400
00:25:25,060 --> 00:25:31,340
Like, join the Discord server and subscribe with notifications on to join the Nerd Army

401
00:25:31,340 --> 00:25:32,980
and become a Sigma Male.

402
00:25:32,980 --> 00:25:34,860
Thanks for watching, goodbye.

403
00:25:41,260 --> 00:25:43,460
This video really was a lot of work for me.

404
00:25:43,460 --> 00:25:47,380
If you didn't understand this video entirely, that's fine, because to be honest I didn't

405
00:25:47,380 --> 00:25:50,740
understand entirely going in and I still don't fully understand it.

406
00:25:50,740 --> 00:25:55,660
If you saw anything in this video that was factually incorrect, please do not hesitate

407
00:25:55,660 --> 00:25:58,400
to correct me in the comments to contact me.

408
00:25:58,400 --> 00:26:01,460
As well as that, there were actually some tools that I was trying to get running to

409
00:26:01,460 --> 00:26:04,220
visualize some of the graphics rendering.

410
00:26:04,220 --> 00:26:08,740
This includes the Doom Vism and Headless Doom, for which I've included both of the

411
00:26:08,740 --> 00:26:10,420
Githubs in the comments section.

412
00:26:10,500 --> 00:26:14,780
I've also included every source I used in this video, or specifically helpful during

413
00:26:14,780 --> 00:26:17,780
this video was this article by Fabian Sunglad.

414
00:26:17,780 --> 00:26:21,540
I definitely recommend checking it out, if this interested you at all, please check out

415
00:26:21,540 --> 00:26:23,700
these sources for further reading.

416
00:26:23,700 --> 00:26:24,700
Thank you and goodbye.

