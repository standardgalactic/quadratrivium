WEBVTT

00:00.000 --> 00:06.700
I'm going to use a few terms throughout this video that not everyone might understand.

00:06.700 --> 00:10.940
A plane is a mathematical term for a square or rectangle.

00:10.940 --> 00:14.500
This is mostly the walls, ceiling and floor.

00:14.500 --> 00:18.980
Vertices are the corners of said planes, the singular being vertex.

00:18.980 --> 00:23.780
Polygons are another term for surfaces derived from computer science rather than maths.

00:23.780 --> 00:26.500
It's going to be used interchangeably with plane.

00:26.500 --> 00:31.180
To do something recursively means a process must repeat itself over and over until an

00:31.180 --> 00:33.420
end goal is met to solve a problem.

00:33.420 --> 00:37.100
A data type is a way data is classified in programming.

00:37.100 --> 00:42.980
For example, a string, which are words or a series of letters, and int, which is an

00:42.980 --> 00:44.980
integer, a typical number.

00:44.980 --> 00:50.300
There are different kinds of numbers as well, such as float for precise decimal numbers,

00:50.300 --> 00:55.820
and long for, well, long numbers.

00:55.820 --> 01:02.020
Of the total size of the games industry today, around 20% are games within the shooter genre.

01:02.020 --> 01:07.740
Around a fifth of games in this $300 billion industry are shooters, most of them being

01:07.740 --> 01:09.460
first person shooters.

01:09.460 --> 01:14.340
The amount of money generated by and riding on the success of this singular genre in this

01:14.340 --> 01:16.300
industry is stupefying.

01:16.300 --> 01:21.140
The first person shooter as developed early on was a huge departure from every other kind

01:21.140 --> 01:23.500
of game that existed at the time.

01:23.580 --> 01:28.140
Games at the time, PC games especially, were often slow or methodical.

01:28.140 --> 01:32.900
The personal computer platform was known for careful and considered games.

01:32.900 --> 01:38.540
Turn-based strategy, grand RPGs with a slowly unfolding world, oftentimes these games would

01:38.540 --> 01:41.220
be indistinguishable from a spreadsheet.

01:41.220 --> 01:43.660
Action was the realm of console gaming.

01:43.660 --> 01:47.620
Platformers were the most immediate real-time action-packed games available, and besides

01:47.620 --> 01:52.340
notable games like Duke Nukem and Commander Keen, people didn't really play those kind

01:52.340 --> 01:54.300
of action games on PC.

01:54.300 --> 01:56.940
This was until the advent of the first person shooter.

01:56.940 --> 02:01.300
Suddenly, people were hit with this visceral representation of violence.

02:01.300 --> 02:03.580
They represented something which films could not.

02:03.580 --> 02:06.420
You inhabit a world through the lens of the character.

02:06.420 --> 02:10.900
You are closer to the action hero than ever before in any medium in history.

02:10.900 --> 02:16.060
What is widely agreed upon as the first first person shooter ever is Maze War.

02:16.060 --> 02:20.540
Developed in 1973, that's the same year Britain joined the European Union, Dark Side of the

02:20.540 --> 02:24.300
Moon was released, and the United States announced it would withdraw from Vietnam.

02:24.300 --> 02:28.860
It was developed for NASA computers by Steve Colley, Greg Thompson and Howard Palmer.

02:28.860 --> 02:31.620
It was constructed with simple wireframe graphics.

02:31.620 --> 02:36.780
People had the idea of adding multiple players using networking and connecting over the ARPANET.

02:36.780 --> 02:37.780
Then it took off.

02:37.780 --> 02:44.140
We saw other first person shooter games after that point, Spasm or Space Sim in 1974, Battle

02:44.140 --> 02:47.020
Zone for arcades in 1980.

02:47.020 --> 02:51.860
As these few examples, for the majority of the decades following its inception, the first

02:51.860 --> 02:56.540
person perspective was known mostly for its association with the role playing genre.

02:56.540 --> 02:58.300
For example, games like Ultima.

02:58.300 --> 03:03.460
Now, first person shooting did technically exist, but you were merely shooting projectiles

03:03.460 --> 03:04.540
at your friends.

03:04.540 --> 03:06.100
You weren't inhabiting a character.

03:06.100 --> 03:08.460
You weren't the action hero fighting bad guys.

03:08.460 --> 03:11.380
That was until Wolfenstein 3D.

03:11.380 --> 03:16.300
Each software was founded in 1991 by four former soft disk employees, John and Adrian

03:16.300 --> 03:21.280
Carmack, no relation, they just happened to have the same name, Tom Hall and John Romero.

03:21.280 --> 03:24.260
This was the same year the Soviet Union fell.

03:24.260 --> 03:26.380
Carmack is going to be more important later on.

03:26.380 --> 03:30.820
They originally began with a Mario clone named Dangerous Dave before the company was officially

03:30.820 --> 03:31.820
founded.

03:31.820 --> 03:35.580
This was mainly to shelf the beginnings of John Carmack's technical wizardry, encoding

03:35.580 --> 03:38.580
an efficient 2D side scrolling graphics renderer.

03:38.580 --> 03:43.780
The early 90s, when everything was a dark and edgy statement, the satanic inversion

03:43.780 --> 03:46.340
between PC and console was no exception.

03:46.340 --> 03:49.420
PC graphics using software rendering were terrible.

03:49.420 --> 03:54.940
John Carmack developed his adaptive tile refresh for the PC to compete with the raw computational

03:54.940 --> 03:58.660
power of the Super Nintendo, a true beast.

03:58.660 --> 04:02.300
Adapted tile refresh meant that slightly more of the game world could be included in the

04:02.300 --> 04:04.660
screen buffer, just outside of view.

04:04.660 --> 04:07.380
This meant they could render smooth 2D scrolling.

04:07.380 --> 04:11.420
It also made the sprite animations independent from screen scrolling.

04:11.420 --> 04:16.140
This little bit of code magic powered their games, including the Commander Keen series.

04:16.140 --> 04:20.540
The Commander Keen series was spread through shareware with subsequent episodes releasing

04:20.540 --> 04:24.380
over the next year or so for purchase from Apogee, their publisher.

04:24.380 --> 04:29.300
This shareware model would be important because it would be used in their subsequent games.

04:29.300 --> 04:33.220
Speaking of subsequent games.

04:33.220 --> 04:36.860
Wolfenstein 3D began development in 1991.

04:36.860 --> 04:41.660
It would use the ray casting technique, earlier employed in Id's Catacomb 3D.

04:41.660 --> 04:46.500
Ray casting was a rendering technique necessitated again by the limited processing power of

04:46.500 --> 04:48.300
PCs at the time.

04:48.300 --> 04:51.260
PC master race just can't stop losing.

04:51.260 --> 04:55.780
PCs almost all used software rendering, rather than a dedicated graphics chip.

04:55.780 --> 05:00.300
The shareware model involved getting the game on as many PCs as possible.

05:00.300 --> 05:03.060
Ray casting was the solution to help them do this.

05:03.060 --> 05:07.460
Ray casting allowed their game to run on basically any PC.

05:07.460 --> 05:11.740
Ray casting means you're able to draw only the surfaces which are in the player's field

05:11.740 --> 05:12.740
of view.

05:12.740 --> 05:16.140
This helped massively in saving processing power, but how does it work?

05:16.140 --> 05:21.540
In effect, a ray is cast, from the player to the geometry, to the nearest object blocking

05:21.540 --> 05:22.540
its path.

05:22.540 --> 05:25.860
In Wolfenstein, none of the levels were truly 3D.

05:25.860 --> 05:28.820
Every level was drawn out on a flat 2D plane.

05:28.820 --> 05:33.700
The program scans horizontally, checking that every pixel on the horizontal axis has

05:33.700 --> 05:34.940
something drawn in it.

05:34.940 --> 05:39.500
If there's nothing drawn in a position, a pixel column will be drawn out.

05:39.500 --> 05:43.700
This is simplified from the process of ray tracing, where this process is done for every

05:43.700 --> 05:46.580
single pixel, rather than every pixel column.

05:46.580 --> 05:51.060
The distance between the viewer, or the camera, or player, they all have the same meaning,

05:51.060 --> 05:53.420
and the nearest piece of geometry is obtained.

05:53.420 --> 05:58.420
The height of the pixel column is calculated using the distance from point of intersection

05:58.500 --> 06:00.860
in the direction the player is facing.

06:00.860 --> 06:04.420
It uses trigonometry to find this point of intersection.

06:04.420 --> 06:09.220
This effectively allowed them to give the illusion of distance to render a 3D scene.

06:09.220 --> 06:14.580
This makes the process of rendering 3D much easier, as a line, that line being distance

06:14.580 --> 06:20.340
from player to geometry, directly transforms to a line, that being the height of the rendered

06:20.340 --> 06:21.340
column.

06:21.340 --> 06:24.460
This process is done multiple times every single second.

06:24.460 --> 06:29.340
The planes in the scene had been texture mapped, where an image is applied to a 3D surface.

06:29.340 --> 06:34.380
When the columns are drawn, they are really drawing slices of these wall textures at different

06:34.380 --> 06:35.380
sizes.

06:35.380 --> 06:40.300
The height of the column being drawn is smaller when the plane, that being the wall, is further

06:40.300 --> 06:41.300
away from you.

06:41.300 --> 06:45.860
The textures are scaled appropriately to the size of the wall relative to the player.

06:45.860 --> 06:49.340
This gave the world of Wolfenstein so much believability for the time.

06:49.420 --> 06:52.820
You were no longer just navigating wireframe mazes.

06:52.820 --> 06:57.940
You were an action hero, BJ Blazkowicz, infiltrating a Nazi castle.

06:57.940 --> 07:00.900
The walls were adorned with flags of the German Reich.

07:00.900 --> 07:06.220
You felt closer to the world than ever before, you were interacting with a true 3D space.

07:06.220 --> 07:08.460
This process was, however, flawed.

07:08.460 --> 07:13.260
In Wolfenstein 3D, there was no verticality at all, no difference in elevation, only the

07:13.260 --> 07:16.780
walls had texture, the ceiling and floor had to be flat colours.

07:17.100 --> 07:20.700
If they wanted texture on the ceiling and floor, they would have had to add horizontal

07:20.700 --> 07:21.700
scan lines.

07:21.700 --> 07:26.860
You were still ultimately navigating a maze, a colourful maze with Nazis in it, but a maze

07:26.860 --> 07:27.860
nonetheless.

07:27.860 --> 07:33.820
Wolfenstein 3D was released in May 1992, the sequels Spear of Destiny was released later

07:33.820 --> 07:34.820
in the same year.

07:34.820 --> 07:39.540
While the rest of the id team was working on Spear of Destiny, John Carmack, the ascetic,

07:39.540 --> 07:44.420
high priest of technology, locked himself away to study, who had brainstormed the revolutionary

07:44.420 --> 07:47.220
tech that would power their next massive game.

07:47.220 --> 07:52.340
The next game that the rest of the team would start working on in September 1992, it would

07:52.340 --> 07:56.100
be something inspired by Evil Dead, brutal and violent.

07:56.100 --> 08:02.220
The name, green and pissed, was ultimately passed up for the much snappier, Doom.

08:02.220 --> 08:08.020
Doom would launch in 1993, the game would truly be able to transport you into a world.

08:08.020 --> 08:10.660
The levels truly felt like places.

08:10.660 --> 08:15.700
The architecture of Doom consisted of supernatural science facilities, with Geiger-esque and

08:15.700 --> 08:17.740
halish environments as well.

08:17.740 --> 08:23.060
The enemies were a combination of horror and sci-fi with cybernetically enhanced demons.

08:23.060 --> 08:27.820
The architecture, over the top setting and violence was inspired by films such as Evil

08:27.820 --> 08:29.180
Dead and Alien.

08:29.180 --> 08:34.580
The floors could now be angled, they could now have multiple levels with stairs and elevators.

08:34.580 --> 08:38.100
The pools of toxic fluid surrounded these risen platforms.

08:38.100 --> 08:41.540
It was truly 3D, but it wasn't really.

08:41.540 --> 08:46.180
They were yet to achieve the full 6 degrees of freedom that John Romero wanted.

08:46.180 --> 08:48.180
This wouldn't happen until Quake.

08:48.180 --> 08:51.700
Rooms couldn't be stacked on top of each other, there was no vertical aim, the game

08:51.700 --> 08:54.780
was entirely played on the horizontal axis.

08:54.780 --> 08:58.540
The thing is, vertical aim was actually possible at the time.

08:58.540 --> 09:03.020
They could have limited the enemy's vertical hitboxes to the size of the sprite, but they

09:03.020 --> 09:04.020
didn't.

09:04.060 --> 09:06.900
Because they couldn't, but to save processing power.

09:06.900 --> 09:09.780
You see, Doom was still using software rendering.

09:09.780 --> 09:13.940
Its shareware model relied on getting their games on as many computers as possible, like

09:13.940 --> 09:14.940
I said.

09:14.940 --> 09:18.740
It was essentially the beginning of the free-to-play game model we have today.

09:18.740 --> 09:22.980
They aimed for the IBM PC, for machines running DOS.

09:22.980 --> 09:27.460
They had to sell their game to university students and wages who were bored at work

09:27.460 --> 09:29.500
so they could run off as tournaments.

09:29.500 --> 09:33.860
They didn't calculate the enemy's vertical hitbox so that they could save memory.

09:33.860 --> 09:37.900
They didn't want to give the enemy's hitboxes a height value, just have another factor to

09:37.900 --> 09:38.900
calculate.

09:38.900 --> 09:43.100
All the levels were drawn on a 2D plane, like Wolfenstein.

09:43.100 --> 09:46.140
Just this time, the map creator is quite different.

09:46.140 --> 09:50.700
The ground is divided into sectors, this will be very important later.

09:50.700 --> 09:56.060
Each sector has two associated values, ceiling height and floor height, well it has several

09:56.060 --> 09:59.420
associated values, but those are two important ones.

09:59.420 --> 10:03.380
This is also why one room could not be placed above another and why every surface had to

10:03.380 --> 10:06.340
be made out of a flat square or rectangle.

10:06.340 --> 10:10.140
Another reason that vertical aim couldn't have worked is due to how the texture mapping

10:10.140 --> 10:11.140
worked.

10:11.140 --> 10:16.060
One game that did have vertical aim and levels on top of each other, before Quake and not

10:16.060 --> 10:19.420
that long after Doom, was Bungie's Marathon.

10:19.420 --> 10:22.820
And look what happens when you look up and down in that game.

10:22.820 --> 10:29.620
The textures start to distort, this is because the game, like Doom, uses affine texture mapping.

10:29.620 --> 10:34.780
This, like many of the other methods, was done to save memory on the processor by taking

10:34.780 --> 10:37.180
advantage of CPU caching.

10:37.180 --> 10:43.660
Basically what happens is that texture coordinates are linearly interpolated, using screen space

10:43.660 --> 10:49.700
distance between vertices, rather than the actual 3D in-engine distance between them.

10:49.700 --> 10:54.020
The distance between points on a plane remains the same when you look up and down.

10:54.020 --> 10:58.380
What this means is that perspective when looking up and down is not accounted for.

10:58.380 --> 11:02.220
You know how pixels on a texture start to warp as you get closer?

11:02.220 --> 11:07.620
What looks like a straight line from far away begins to turn inward as closer pixels get

11:07.620 --> 11:11.380
larger while more distant pixels get smaller.

11:11.380 --> 11:17.260
This doesn't happen in Doom, because accounting for perspective is taxing on 90s computers.

11:17.260 --> 11:21.500
You know how the game only draws things in columns to save processing time?

11:21.500 --> 11:25.780
They'd have had to do vertical scans as well as horizontal scans.

11:25.780 --> 11:31.580
Several ports of Doom with newer rendering engines made for new hardware like GZDOOM

11:31.580 --> 11:33.860
obviously don't have this limitation.

11:33.860 --> 11:37.940
As such, they use more current texture mapping and don't have this issue.

11:37.940 --> 11:40.460
But all of these concessions weren't enough.

11:40.460 --> 11:46.300
John Carmack's coding brilliance met its most devious enemy yet, Stairs.

11:46.300 --> 11:51.820
John Romero came out with a really way out and strange idea on his early incarnation of

11:51.820 --> 11:52.820
E1M2.

11:53.180 --> 11:58.740
Yes, he wanted to mix things up with the earth-shattering invention of Stairs.

11:58.740 --> 12:03.620
You see, just raycasting alone wasn't enough to efficiently optimise the game.

12:03.620 --> 12:07.460
Raycasting saves memory by only rendering things which are visible to the player.

12:07.460 --> 12:12.900
However, surfaces on the inside of these stairs were visible to the existing algorithm, thus

12:12.900 --> 12:15.340
they were drawn when they shouldn't have been.

12:15.340 --> 12:20.900
You see, for 3D rendering to not waste performance, they need to draw as few surfaces as few planes

12:20.900 --> 12:21.900
as possible.

12:21.900 --> 12:27.460
This necessitates occlusion culling, or visible surface determination, or backface culling.

12:27.460 --> 12:33.340
Basically, the renderer should only draw what is in the player's field of view.

12:33.340 --> 12:37.020
They need to be absolutely no overdraw whatsoever.

12:37.020 --> 12:43.060
Adding height as a variable, such as with Romero's stairs, requires a much more sophisticated

12:43.060 --> 12:48.980
algorithm than was present in Wolfenstein and in Id's existing rendering engine.

12:48.980 --> 12:53.260
There are many different rendering algorithms out there, it seems that we need to dip into

12:53.260 --> 12:58.660
the hypothetical algorithms to start trawling the literature for some better algorithms.

12:58.660 --> 13:00.460
Let's explore some of the options.

13:00.460 --> 13:04.140
There's the painter's algorithm, named so because, like in a painting, the background

13:04.140 --> 13:07.020
is rendered first, with detail laid on top.

13:07.020 --> 13:10.980
Basically, the polygons are sorted by their distance from the viewer, and the more distant

13:10.980 --> 13:14.820
polygons are rendered first, and the close polygon is rendered last.

13:14.820 --> 13:21.420
It is easily the most simple solution, it was developed in 1972, the year MASH started,

13:21.420 --> 13:24.140
as an easy to implement solution for CAD.

13:24.140 --> 13:29.260
It also has the worst possible case for space complexity, meaning it takes up as much memory

13:29.260 --> 13:31.820
as an algorithm possibly could.

13:31.820 --> 13:34.620
Every single surface in the field of view is drawn.

13:34.620 --> 13:37.140
Obviously, this isn't a good fit.

13:37.140 --> 13:41.380
It's more of an example from the early days of exactly what not to do.

13:41.380 --> 13:45.900
There's also Warnock's algorithm, John Warnock was the founder of Adobe, and this algorithm

13:45.900 --> 13:51.780
originated in his doctoral thesis in 1969, the year man landed on the moon and in the

13:51.780 --> 13:53.860
court of the crimson king was released.

13:53.860 --> 13:57.900
Essentially, it recursively subdivides the screen into four parts.

13:57.900 --> 14:01.820
What this means is it splits the screen into four windows and splits each window into four

14:01.820 --> 14:02.940
smaller windows.

14:02.940 --> 14:07.980
It does this again and again until each window is trivial to render, meaning it has only

14:07.980 --> 14:10.700
one or zero polygons present.

14:10.700 --> 14:14.940
The algorithm also checks if multiple polygons are within one window.

14:14.940 --> 14:19.020
If the closest polygon covers the whole window, then it is drawn.

14:19.020 --> 14:23.460
This is more efficient than painter's algorithm as it renders front to back, but it's still

14:23.460 --> 14:25.140
not very well suited.

14:25.140 --> 14:30.780
It will eventually keep subdividing to a ridiculous degree, to the point where a window is smaller

14:30.780 --> 14:31.780
than a pixel.

14:31.780 --> 14:34.380
Yet, this ain't a good fit for a game.

14:34.380 --> 14:38.060
You could do a Zed buffer, for every pixel you want to draw, check if there's anything

14:38.060 --> 14:39.060
in front of it.

14:39.060 --> 14:40.780
Doing a check on every single pixel?

14:40.780 --> 14:42.740
Yeah, there's no chance in hell.

14:42.740 --> 14:47.700
The final solution does kinda use a Zed buffer, but it doesn't do that check on every single

14:47.700 --> 14:48.700
pixel.

14:48.700 --> 14:50.820
It finds a much more efficient way to do it.

14:50.820 --> 14:51.820
No.

14:51.820 --> 14:57.860
In order to truly revolutionise not just gaming, but 3D graphics forever, our protagonist,

14:57.860 --> 15:02.100
John Carmack, needs to go to a much more inspired source.

15:02.100 --> 15:04.940
Something that hadn't actually been implemented before.

15:04.940 --> 15:06.940
Something you just read in a white paper.

15:06.940 --> 15:07.940
Just a concept.

15:07.940 --> 15:12.980
Yes, how common is it in gaming to see people run into optimisation issues, and seek out

15:12.980 --> 15:15.340
a white paper to solve their problem?

15:15.340 --> 15:17.220
Cause nobody else had done it before.

15:17.220 --> 15:19.100
Yes, that's Carmack for you.

15:19.100 --> 15:23.700
We needed a renderer that would draw objects closest to the player to furthest away until

15:23.700 --> 15:25.780
every pixel was written to.

15:25.780 --> 15:27.540
That had no overdraw.

15:27.540 --> 15:30.660
The solution was in a 1980 white paper.

15:30.660 --> 15:33.900
That's the same year Genesis released the reclaimed album.

15:33.900 --> 15:40.460
Dook, where they really came into their own.

15:40.460 --> 15:45.820
This 1980 white paper by Bruce Nailot was given the humble title, On visible surface

15:45.820 --> 15:49.060
generation by a priori tree structures.

15:49.060 --> 15:55.460
It described a rendering model we know as binary space partitioning, or BSP for short.

15:55.460 --> 15:58.700
This was the method that would change gaming for years.

15:58.700 --> 16:02.260
This wasn't the first time binary space partitioning was alluded to.

16:02.260 --> 16:08.420
A 1969 study by the Air Force of the Good Old US of A, alluded to the use of partitioning

16:08.420 --> 16:12.020
3D scenes to solve the visible surface problem.

16:12.020 --> 16:17.340
The study was conducted to determine the viability of 3D for flight simulation.

16:17.340 --> 16:21.380
We can thank the armed forces of the United States for giving us doom.

16:21.380 --> 16:24.900
They explored using a matrix to track which objects are occluded.

16:24.900 --> 16:29.220
This of course wouldn't do so well as the size of the matrix would need to be the square

16:29.220 --> 16:31.780
of the number of objects in a scene.

16:31.780 --> 16:33.660
That wouldn't scale very well.

16:33.660 --> 16:39.220
It wasn't until 1980 that binary space partitioning was properly realised in the white paper that

16:39.220 --> 16:43.860
would reach John Carmack alongside its core tenet, the binary tree.

16:43.860 --> 16:46.860
But what is binary space partitioning anyway?

16:46.860 --> 16:48.780
Well, the name gives you a clue.

16:48.780 --> 16:52.060
Is partitioning space in a 3D environment?

16:52.060 --> 16:54.940
This is done using a BSP tree.

16:54.940 --> 16:57.100
What is a BSP tree you may ask?

16:57.100 --> 17:02.020
In computer science, a tree is a data structure used as a mathematical model for displaying

17:02.020 --> 17:03.940
certain data types.

17:03.940 --> 17:08.540
It's separated into nodes with parent nodes that have child nodes.

17:08.540 --> 17:11.500
BSP uses binary trees.

17:11.500 --> 17:13.260
Binary essentially meaning two.

17:13.260 --> 17:18.740
A binary tree is a tree where there are two or less child nodes stemming from any given

17:18.740 --> 17:20.260
parent, from any node.

17:20.260 --> 17:23.340
There are never more than two child nodes.

17:23.340 --> 17:28.140
This is as opposed to a non-binary tree, which is a tree that has dyed hair and a gender

17:28.140 --> 17:29.300
studies degree.

17:29.300 --> 17:34.820
The data stored in the nodes of the binary tree are the subsectors of the map.

17:34.820 --> 17:39.620
Subsectors being smaller parts of those map sectors I spoke about earlier.

17:39.620 --> 17:45.380
Remember, each map is designed on a flat 2D map editor, with each sector having associated

17:45.380 --> 17:46.580
height values.

17:46.580 --> 17:51.740
The genius is that the map is sliced up via binary space partitioning after the map is

17:51.740 --> 17:52.740
built.

17:52.740 --> 17:58.660
The hard work is done when the map is created, rather than by the processor at runtime, while

17:58.660 --> 18:00.380
the player is playing the game.

18:00.380 --> 18:06.220
The map is already split, already partitioned when the player loads it, reducing processing

18:06.220 --> 18:07.900
needed at runtime.

18:07.900 --> 18:13.020
To create the binary tree, a root node is established, covering the whole map.

18:13.020 --> 18:19.620
After this, the map is recursively subdivided along every plane, until only convex subsectors

18:19.620 --> 18:20.620
are left.

18:20.620 --> 18:24.100
Subsectors are carved into smaller subsectors.

18:24.100 --> 18:28.900
The entire map is essentially cut in two, along every single wall.

18:28.900 --> 18:33.860
Every time the map is cut in half, the two halves are added as nodes at the bottom of

18:33.860 --> 18:34.860
the tree.

18:34.860 --> 18:40.380
By the end, you're left with a tree where each node at the bottom of the tree represents

18:40.380 --> 18:42.380
a distinct subsector.

18:42.380 --> 18:47.500
Remember, this tree is entirely conceptual, it doesn't actually exist.

18:47.500 --> 18:52.940
So long as the planes don't move, vertical movement is accepted from this because vertical

18:52.940 --> 18:58.100
movement is a separate value, the same BSP tree can be used.

18:58.100 --> 19:04.060
Dooms BSP tree generation was done after levels were complete and would search for the best

19:04.060 --> 19:09.020
possible tree, that being the one that generates the fewest binary tree nodes.

19:09.020 --> 19:13.220
A binary search is performed to determine what sector the player is in.

19:13.220 --> 19:18.660
A binary search is when an array of pre-sorted data is searched through by continually halving

19:18.660 --> 19:19.660
said array.

19:19.660 --> 19:24.700
A search through a binary tree is, by its nature, a binary search, because every time

19:24.700 --> 19:29.060
you go down a node, you're removing half of the possibilities.

19:29.060 --> 19:34.060
After the player's sector is determined using this binary search, the subsectors are then

19:34.060 --> 19:38.220
sorted by their distance from the player, closest to furthest.

19:38.220 --> 19:42.260
The tree is iterated through to determine which planes to draw.

19:42.260 --> 19:47.180
The horizontal scan lines from ray casting are still used to track the parts of the screen

19:47.180 --> 19:48.820
that have been drawn over.

19:48.820 --> 19:53.580
This way they are able to render front to back and ensure that there is no overdraw.

19:53.580 --> 19:57.820
When each node is passed over in the iteration, a few things are checked.

19:57.820 --> 19:59.980
Has that area already been painted over?

19:59.980 --> 20:02.260
If so, don't bother drawing it.

20:02.300 --> 20:08.620
When a plane, polygon, or wall is drawn, it is akin to a curtain being drawn left to right.

20:08.620 --> 20:10.700
To unveil an area, so to speak.

20:10.700 --> 20:16.500
Whenever a curtain is seen by the player, it is unveiled, from closest to the furthest.

20:16.500 --> 20:20.660
To be exact, it's the closest 256 walls that are displayed.

20:20.660 --> 20:26.180
Remember how height of the pixel columns drawn on screen depended on distance from the player?

20:26.180 --> 20:31.780
For Doom, this required determining the angle of both ends of every wall, relative to the

20:31.780 --> 20:33.420
player's field of view.

20:33.420 --> 20:38.540
In the early 90s, most processors didn't have dedicated floating point capability.

20:38.540 --> 20:43.020
This is a float in programming, if you've ever heard of that, basically a data type

20:43.020 --> 20:45.340
for very precise decimal numbers.

20:45.340 --> 20:51.620
The Doom engine had to use binary angle measurements, which avoid floats, and used a lookup table

20:51.620 --> 20:53.980
to determine the X coordinates.

20:53.980 --> 20:56.940
A lookup table is essentially a cheat sheet.

20:56.940 --> 21:01.660
Instead of the processor doing the maths itself, it just looks up the answer in this lookup

21:02.300 --> 21:03.300
table.

21:03.300 --> 21:09.140
They also use these angles for backface culling, with a simple and elegant piece of mathematics.

21:09.140 --> 21:14.380
Backface culling basically means the renderer doesn't draw the inside of every polygon.

21:14.380 --> 21:18.100
It only draws the part on the outside that you actually see.

21:18.100 --> 21:22.380
The walls are rendered first as pixel columns, from front to back.

21:22.380 --> 21:25.820
Then the ceilings and floors, using pixel rows.

21:25.820 --> 21:31.500
The objects, such as barrels and enemies, are rendered from the furthest to the closest.

21:31.500 --> 21:37.580
The ceilings and floors are determined using visplane underscore T, or visplanes.

21:37.580 --> 21:41.260
Visplanes were determined using height values within each sector.

21:41.260 --> 21:46.940
Visplanes are not constrained to single sectors, and will be continuous provided they all possess

21:46.940 --> 21:50.580
the same height, illumination, and textures.

21:50.580 --> 21:53.180
Pixel rows are drawn, top to bottom.

21:53.180 --> 21:58.300
One final thing you may wonder about Doom's graphics, is why are all the enemies just

21:58.300 --> 22:00.780
pictures facing towards you?

22:00.860 --> 22:04.820
There's nothing to do with them being what we call front facing sprites.

22:04.820 --> 22:08.940
They're rendered last, and like I said, furthest to closest.

22:08.940 --> 22:11.300
That's the opposite order to the geometry.

22:11.300 --> 22:16.300
They are just pictures, taken from the data files and projected onto screen.

22:16.300 --> 22:18.820
Of course, there are a range of pictures.

22:18.820 --> 22:23.980
The one that is drawn depends on the player's location relative to the enemy, and the direction

22:23.980 --> 22:25.460
the enemy is facing.

22:25.460 --> 22:29.020
The enemies do actually have a full 3D hitbox.

22:29.020 --> 22:34.220
The pictures, as most fans know, are actually from real pictures taken of sculptures made

22:34.220 --> 22:35.580
by the artists.

22:35.580 --> 22:41.500
So, John Carmack was faced with a fierce issue in the problem of visible surface determination.

22:41.500 --> 22:46.740
He had to find a solution that was both incredibly fast and very accurate.

22:46.740 --> 22:52.980
BSP doesn't completely solve the visible surface determination problem, but it is one

22:52.980 --> 22:56.940
of the most reliable and efficient methods of optimization.

22:56.940 --> 22:59.180
It saw massive acceptance.

22:59.180 --> 23:04.340
BSPs were evolved and made their way into Quake's dramatically improved game engine

23:04.340 --> 23:09.820
when they took on Michael A. Brash and finally figured out the full 6 degrees of freedom.

23:09.820 --> 23:14.660
From there, it was in every FPS, and I mean all of them.

23:14.660 --> 23:20.660
Half-Life and Half-Life 2, every source game, Counter-Strike to Left 4 Dead, the Halo series

23:20.660 --> 23:21.660
used it.

23:21.660 --> 23:24.740
You know the Scarab from Halo 2 is actually a BSP object?

23:24.740 --> 23:27.980
Yes, it's a moving piece of level geometry.

23:27.980 --> 23:33.020
Many would say it's a sign of Carmack's genius, that he took an idea from concept to

23:33.020 --> 23:34.820
mainstream solution.

23:34.820 --> 23:41.300
He did all this crazy work in between supercharging Ferraris and becoming a judo master.

23:41.300 --> 23:44.380
You know, one time he got locked inside a building.

23:44.380 --> 23:49.740
Instead of, say, waiting for security or calling a locksmith, he devised a brilliant solution.

23:49.740 --> 23:54.780
He'd luckily gone to Renaissance Fair earlier, where he bought a medieval battle axe.

23:54.780 --> 23:58.780
So naturally, he smashed down the door with his mighty axe.

23:58.780 --> 24:01.540
He was rich so he could afford to get the door fixed.

24:01.540 --> 24:07.300
He truly is a unique figure in the gaming industry, and you can see why he's so highly

24:07.300 --> 24:08.300
respected.

24:08.300 --> 24:12.020
If you made it this far, comment, thank you John Carmack.

24:12.020 --> 24:17.700
The use of BSP trees has begun to be replaced over the last few years.

24:17.700 --> 24:20.740
These instead opt for things like static meshes.

24:20.740 --> 24:25.620
With more powerful hardware now, they could afford some level of overdraw.

24:25.620 --> 24:30.380
Other methods give artists more creative freedom and a much quicker workflow.

24:30.380 --> 24:36.420
BSP often leads to the distinct blocky look that many old games had.

24:36.420 --> 24:41.820
One could certainly argue that these technical limitations are what gave Source Maps and

24:41.820 --> 24:47.540
early 2000's maps in general, their distinct charm, their soul.

24:47.540 --> 24:54.500
With stark and distinct architectural choices, some magic is truly lost in busy modern day

24:54.500 --> 24:55.500
maps.

24:55.500 --> 25:01.140
Many new games have actually tried to go back to recreating these older, cleaner, more distinct

25:01.140 --> 25:02.140
visuals.

25:02.140 --> 25:07.620
BSP is still occasionally used today in prototyping levels for games, quickly blocking them out.

25:07.620 --> 25:11.260
It's of course still used in games such as Counter-Strike Go.

25:11.260 --> 25:16.000
This was a big video and naturally took a bit of research which I've provided links

25:16.000 --> 25:17.500
to in the description.

25:17.500 --> 25:24.060
If I got anything wrong, please feel free, in fact feel obligated to call me out in the

25:24.060 --> 25:25.060
comments.

25:25.060 --> 25:31.340
Like, join the Discord server and subscribe with notifications on to join the Nerd Army

25:31.340 --> 25:32.980
and become a Sigma Male.

25:32.980 --> 25:34.860
Thanks for watching, goodbye.

25:41.260 --> 25:43.460
This video really was a lot of work for me.

25:43.460 --> 25:47.380
If you didn't understand this video entirely, that's fine, because to be honest I didn't

25:47.380 --> 25:50.740
understand entirely going in and I still don't fully understand it.

25:50.740 --> 25:55.660
If you saw anything in this video that was factually incorrect, please do not hesitate

25:55.660 --> 25:58.400
to correct me in the comments to contact me.

25:58.400 --> 26:01.460
As well as that, there were actually some tools that I was trying to get running to

26:01.460 --> 26:04.220
visualize some of the graphics rendering.

26:04.220 --> 26:08.740
This includes the Doom Vism and Headless Doom, for which I've included both of the

26:08.740 --> 26:10.420
Githubs in the comments section.

26:10.500 --> 26:14.780
I've also included every source I used in this video, or specifically helpful during

26:14.780 --> 26:17.780
this video was this article by Fabian Sunglad.

26:17.780 --> 26:21.540
I definitely recommend checking it out, if this interested you at all, please check out

26:21.540 --> 26:23.700
these sources for further reading.

26:23.700 --> 26:24.700
Thank you and goodbye.

