1
00:00:00,000 --> 00:00:03,840
You've likely seen videos on YouTube telling you the number one programming language to learn

2
00:00:03,840 --> 00:00:08,320
right now if you want to be rich. That's not what we're doing today. Instead, we're going to travel

3
00:00:08,320 --> 00:00:12,480
to the deepest, darkest depths of the software engineering field to discover the programming

4
00:00:12,480 --> 00:00:18,000
languages that are loved, hated, beautiful, ugly, compiled, interpreted, useful, weird, and everything

5
00:00:18,000 --> 00:00:21,840
in between. If you make it to the end, you'll have a roadmap for everything you need to know

6
00:00:21,840 --> 00:00:26,640
to land a job as a junior developer in 2023. Or it might just make you extremely depressed

7
00:00:26,640 --> 00:00:30,320
because this iceberg is just the tip of the iceberg of what you actually need to learn.

8
00:00:30,320 --> 00:00:34,400
Choose any language and you'll find another iceberg within this iceberg that goes on forever

9
00:00:34,400 --> 00:00:38,720
like a Mandelbrot set, which ironically you can represent in code with any one of the languages

10
00:00:38,720 --> 00:00:43,120
we're about to look at. Before we get started, there's quite a few programming icebergs out there,

11
00:00:43,120 --> 00:00:47,120
but this one ranks languages based on where I think you might encounter them as a beginner

12
00:00:47,120 --> 00:00:51,280
learning how to code from scratch. Each level has its own theme, so let's get right into it,

13
00:00:51,280 --> 00:00:55,280
with languages that are designed to make programming as easy as possible. If you know

14
00:00:55,280 --> 00:00:59,600
absolutely nothing about programming, the best place to start in my opinion is Scratch. It was

15
00:00:59,600 --> 00:01:04,320
developed at MIT, like some other languages on this list, but instead of typing out code, you drag

16
00:01:04,320 --> 00:01:08,960
and drop these blocks together like Lego bricks to represent things like variables, control flow,

17
00:01:08,960 --> 00:01:12,960
and operators. It makes the thinking process behind programming much more accessible, and you

18
00:01:12,960 --> 00:01:19,040
might be surprised at what you can actually build with it. Long before Scratch, though, we had basic,

19
00:01:19,040 --> 00:01:24,320
or beginner's all-purpose symbolic instruction code, which came out of Dartmouth in 1964. At the

20
00:01:24,320 --> 00:01:29,040
time, Fortran was all the rage, but it wasn't beginner-friendly. Basic provides a bunch of basic

21
00:01:29,040 --> 00:01:34,000
commands like print, go-to, and for, and was included in most personal computers, which made it the

22
00:01:34,000 --> 00:01:38,560
go-to option for people learning to code for the next 50 years. Now moving on to the next tier,

23
00:01:38,560 --> 00:01:42,880
we have the extremely popular dynamic high-level languages. The language most people start with

24
00:01:42,880 --> 00:01:48,560
today is Python, primarily because of its minimal syntax. It doesn't require curly braces, semicolons,

25
00:01:48,560 --> 00:01:53,360
and stuff like that, and instead uses indentation to represent different blocks of code. The other

26
00:01:53,360 --> 00:01:58,160
popular high-level language is JavaScript. Syntactically, it's pretty ugly, but it's a requirement

27
00:01:58,160 --> 00:02:01,840
if you want to do web development, and almost every developer will have to touch it at some point in

28
00:02:01,840 --> 00:02:06,320
their career. Any application that can be written in JavaScript will eventually be written in JavaScript.

29
00:02:06,320 --> 00:02:09,760
Now, after learning one of these languages, you'll be able to build pretty much anything you can

30
00:02:09,760 --> 00:02:14,000
imagine, and you could have an entire career as a software engineer without going any further down

31
00:02:14,000 --> 00:02:18,000
the iceberg. But you don't want to be on your deathbed wondering if you should have tried out PHP.

32
00:02:18,000 --> 00:02:22,320
On this next tier, we have languages that are extremely popular, but a little more specialized.

33
00:02:22,320 --> 00:02:25,680
Programmers like to get things done from the terminal, and there are scripting languages,

34
00:02:25,680 --> 00:02:29,920
like Bash and PowerShell, that allow you to interact with your computer programmatically,

35
00:02:29,920 --> 00:02:33,840
instead of typing out the same commands over and over again, write a Bash script to make it

36
00:02:33,840 --> 00:02:38,560
reproducible. Now, if you get into web development, you'll also need to learn HTML and CSS, which,

37
00:02:38,560 --> 00:02:42,560
when combined together, arguably form a turing-complete programming language. They're not

38
00:02:42,560 --> 00:02:46,560
used for programming in the traditional sense, but rather to define the structure and style of a

39
00:02:46,560 --> 00:02:50,320
website. And if I were to say HTML is not a programming language, I would be immediately

40
00:02:50,320 --> 00:02:54,160
canceled by the tech community. In addition, most apps need a database, and the most common

41
00:02:54,160 --> 00:02:59,600
language for working with databases is structured query language. You can call it SQL, SQL, or

42
00:02:59,600 --> 00:03:03,920
SQL. This turing-complete, although not used for regular programming, but rather to read and

43
00:03:03,920 --> 00:03:08,560
write data in a relational database. Now, Python is great and all, but there are many other dynamic

44
00:03:08,560 --> 00:03:13,600
languages that might be a better fit for certain projects, like PHP made it easy to build server

45
00:03:13,600 --> 00:03:18,880
side web apps in the 90s, and is still very popular today. Lua is easier and faster than Python,

46
00:03:18,880 --> 00:03:23,760
and is embedded into many engines like Roblox and World of Warcraft. Ruby is an easy-to-learn

47
00:03:23,760 --> 00:03:27,760
object-oriented language, also commonly used to build web apps with the Rails framework. If you

48
00:03:27,760 --> 00:03:32,960
work in data science, you'll come across R, which is used for statistics and data viz, or Julia,

49
00:03:32,960 --> 00:03:37,280
a more modern option, also used for scientific computing. The one thing all these languages

50
00:03:37,280 --> 00:03:42,560
have in common is a dynamic type system. However, as you build more complex software, you may realize

51
00:03:42,560 --> 00:03:47,120
that you need a more rigid framework, and one way to accomplish that is with a static type system.

52
00:03:47,120 --> 00:03:51,440
This tier makes up the bulk of production code out in the world. First up, we have Java, which

53
00:03:51,440 --> 00:03:56,080
kind of revolutionized programming with the Java virtual machine. It compiles to bytecode that

54
00:03:56,080 --> 00:04:00,880
runs on the JVM, and that allows developers to target any computer architecture from a single

55
00:04:00,880 --> 00:04:05,520
codebase. Syntactically, it's an absolute dumpster fire for beginners. I made an entire video about

56
00:04:05,520 --> 00:04:10,480
why people hate Java, but having explicit types in your code can make it much easier to understand

57
00:04:10,480 --> 00:04:15,120
and refactor, and modern IDEs like IntelliJ will pretty much make the code write itself.

58
00:04:15,120 --> 00:04:19,840
Java is legendary, but it was followed up by Microsoft with C-sharp. It's similar to Java in

59
00:04:19,840 --> 00:04:24,000
many ways, but gets a lot more love from its users. It's used to build games with Unity,

60
00:04:24,000 --> 00:04:28,640
as well as web and desktop apps with the .NET framework. Another well-loved tool from Microsoft

61
00:04:28,640 --> 00:04:33,920
is TypeScript. It takes JavaScript and adds a type system on top of it, making it much easier to work

62
00:04:33,920 --> 00:04:38,560
with on large complex projects. If you're building a mobile app today, you'll likely be working with

63
00:04:38,560 --> 00:04:43,680
Kotlin for Android, Swift for iOS, or Dart with the Flutter framework. These languages are all

64
00:04:43,680 --> 00:04:48,160
statically typed, but they go about it in a more modern, concise way, with features like type

65
00:04:48,160 --> 00:04:52,960
inference that minimize boilerplate code. Next up, we have Go, which is a high-performance

66
00:04:52,960 --> 00:04:57,920
language developed at Google, to build low-level systems. It was designed as a replacement for C,

67
00:04:57,920 --> 00:05:02,400
and Ken Thompson, one of the original creators of C, helped design it. The syntax is nice and

68
00:05:02,400 --> 00:05:07,440
concise, making it approachable to beginners, and it has a garbage collector, which means unlike C,

69
00:05:07,440 --> 00:05:11,680
developers don't need to worry about manual memory management. Okay, so at this point,

70
00:05:11,680 --> 00:05:15,680
we've reached the level of the iceberg, where most people are afraid to go any deeper. Things

71
00:05:15,680 --> 00:05:19,840
are going to get weird. What happens is that many developers get jaded with these big, heavy,

72
00:05:19,840 --> 00:05:24,640
object-oriented languages and go searching for a better way. At this level, we have functional

73
00:05:24,640 --> 00:05:29,280
languages, the most famous of which is Haskell. Instead of classes and heritans and all kinds

74
00:05:29,280 --> 00:05:34,160
of crazy design patterns, the only abstraction you really need is the function. It was inspired by

75
00:05:34,160 --> 00:05:38,800
the Miranda language and is named after the mathematician Haskell Curry. Most importantly,

76
00:05:38,800 --> 00:05:43,600
variables are immutable, and functions have no side effects. Surprisingly, you can build almost

77
00:05:43,600 --> 00:05:47,280
anything with these limitations, although most production code out there is not functional.

78
00:05:47,280 --> 00:05:51,040
Most of us run into problems when trying to figure out what a monad is, which in layman's

79
00:05:51,040 --> 00:05:56,240
terms is just a monoid in the category of end functors. Haskell is great, but Microsoft developed

80
00:05:56,240 --> 00:06:01,360
a functional sister language to C sharp called F sharp. Unlike Haskell, which is purely functional,

81
00:06:01,360 --> 00:06:06,000
F sharp is also imperative and object-oriented, making it more approachable to developers

82
00:06:06,000 --> 00:06:10,560
coming from higher up in the iceberg. Now, if you hate Java, a good alternative is Scala.

83
00:06:10,560 --> 00:06:14,800
Like F sharp, it supports both object-oriented and functional programming, but it runs on the

84
00:06:14,800 --> 00:06:20,400
JVM. It's statically typed, but there's another JVM language called Clojure that is both functional

85
00:06:20,400 --> 00:06:24,560
and dynamic. This makes it more well suited for getting things done quickly with the trade-off

86
00:06:24,560 --> 00:06:29,840
of type safety. Other popular functional languages include OCaml, which is used extensively at Facebook,

87
00:06:29,840 --> 00:06:35,040
and Elixir, which has a very nice ruby-like syntax and is capable of building high-performance,

88
00:06:35,040 --> 00:06:39,680
real-time web apps. There's also Elm, which is a purely functional language that compiles to

89
00:06:39,680 --> 00:06:44,640
JavaScript, which can build front-end UIs with zero runtime errors, but now it's time to go one

90
00:06:44,640 --> 00:06:49,440
level deeper to the heart of the iceberg. These languages are absolute chads. They're low-level

91
00:06:49,440 --> 00:06:53,920
systems languages that can manually manage and optimize memory and are used to build things

92
00:06:53,920 --> 00:06:58,800
like operating system kernels and compilers that make all the other soy-based languages possible,

93
00:06:58,800 --> 00:07:03,680
the most legendary of which is C. It was used to build the Windows, Mac, and Linux operating system

94
00:07:03,680 --> 00:07:08,240
kernels, and its curly brace syntax inspired many other languages on this list. Surprisingly,

95
00:07:08,240 --> 00:07:11,920
it's not all that hard to learn and has a relatively small set of keywords to memorize.

96
00:07:11,920 --> 00:07:16,720
However, being able to use it effectively requires extensive knowledge of algorithms and computer

97
00:07:16,720 --> 00:07:21,120
architecture. For example, C doesn't have hash maps or dictionaries, so you'll have to learn how

98
00:07:21,120 --> 00:07:25,040
to code up that data structure on your own. C was the perfect programming language when it came out

99
00:07:25,040 --> 00:07:31,040
in 1969, but it only supported procedural programming and eventually developers wanted more. C++ was

100
00:07:31,040 --> 00:07:35,840
originally a superset of C designed to extend it with object-oriented programming patterns,

101
00:07:35,840 --> 00:07:40,640
like classes and inheritance. Unlike C, it's extremely hard to learn and provides many opportunities

102
00:07:40,640 --> 00:07:45,440
to not only shoot yourself in the foot, but blow your entire leg off. This is a reference to manual

103
00:07:45,440 --> 00:07:49,680
memory management with pointers, which got that name because they're just as dangerous as pointing

104
00:07:49,680 --> 00:07:54,000
a gun at someone. Despite its learning curve, it's an extremely prolific language used to build

105
00:07:54,000 --> 00:07:59,440
highly optimized software like game engines, compilers, and so on. C and C++ are still extremely

106
00:07:59,440 --> 00:08:04,240
relevant today, but the modern Chad tends to prefer rust for low-level programming. It doesn't

107
00:08:04,240 --> 00:08:10,080
have a garbage collector, but unlike C and C++, it uses a technique called borrow-checking instead

108
00:08:10,080 --> 00:08:14,720
of pointers for memory management. This makes it much easier to write memory-safe programs and

109
00:08:14,720 --> 00:08:19,040
consistently ranks as the most loved language in the world. The languages on this tier are

110
00:08:19,040 --> 00:08:23,840
extremely popular, but now we descend further into the modern languages that you probably haven't

111
00:08:23,840 --> 00:08:28,480
heard of. First up, we have V, which is a high-performance systems language that feels very

112
00:08:28,560 --> 00:08:34,000
similar to Go, but unlike Go, it doesn't use a garbage collector, and unlike Rust, it doesn't do

113
00:08:34,000 --> 00:08:38,960
borrow-checking, but it can still create memory-safe applications with its own auto-free innovation

114
00:08:38,960 --> 00:08:43,440
where the compiler basically cleans everything up. I have no idea how it works, but it looks cool.

115
00:08:43,440 --> 00:08:48,480
Another modern replacement for C is Zig. It's designed to simplify low-level programming by

116
00:08:48,480 --> 00:08:53,120
eliminating features like macros and metaprogramming and is very explicit when it comes to memory

117
00:08:53,600 --> 00:08:58,720
management, and it can cross-compile C and C++ just like Clang. Zig is not to be confused with NIM,

118
00:08:58,720 --> 00:09:03,120
another high-performance language that's very expressive like Python, but is statically typed,

119
00:09:03,120 --> 00:09:07,520
and interestingly, it has a tunable garbage collector that can be turned off altogether to

120
00:09:07,520 --> 00:09:12,320
enable manual memory management. Recently, Google announced Carbon, designed to be a successor to

121
00:09:12,320 --> 00:09:18,400
C++. What makes it special is that it can fully interop with a legacy C++ codebase. Another low-level

122
00:09:18,480 --> 00:09:23,120
specialty language is Solidity. It's a statically typed object-oriented language, but is designed

123
00:09:23,120 --> 00:09:27,840
for implementing smart contracts, especially on the Ethereum blockchain. Then we've got Hack from

124
00:09:27,840 --> 00:09:32,320
Facebook, which is designed to interop with PHP. The original website was built with PHP,

125
00:09:32,320 --> 00:09:36,880
but they needed a language with better performance and a type system to scale it up to the monstrosity

126
00:09:36,880 --> 00:09:41,040
that it is today. There are many other good modern languages at this point in the iceberg,

127
00:09:41,040 --> 00:09:45,840
like Crystal, Hacks, and Ferro, just to name a few, but now it's time to go down to the next level,

128
00:09:45,840 --> 00:09:49,760
where we look at languages that are still either widely used or historically important,

129
00:09:49,760 --> 00:09:53,600
but not something you would likely choose to program in. Fortran was the first high-level

130
00:09:53,600 --> 00:09:58,000
programming language, and was by far the most popular language for many years until C came

131
00:09:58,000 --> 00:10:04,080
around. Not long after Fortran, Lisp was invented in 1958. It pioneered many ideas we take for granted

132
00:10:04,080 --> 00:10:09,200
in computer science today, like dynamic typing, higher-order functions, recursion, and repel.

133
00:10:09,200 --> 00:10:13,600
It inspired many other languages like racket, scheme, closure, and to a certain extent,

134
00:10:13,600 --> 00:10:18,640
JavaScript. Another highly influential language that came out this year was Algorithmic Language.

135
00:10:18,640 --> 00:10:23,600
It's a big, complex language and never got as popular as Fortran, but its type system and use

136
00:10:23,600 --> 00:10:28,240
of expressions had a major influence on the development of C and C++. The following year,

137
00:10:28,240 --> 00:10:34,000
in 1959, Kobal was born. If you want to make money in the 2020s, learn Kobal, because over 40%

138
00:10:34,000 --> 00:10:39,360
of banking systems still use it, with over 200 billion lines of code in production today. In 62,

139
00:10:39,360 --> 00:10:44,800
APL first appeared, which stands for a programming language. It implements linear algebra directly

140
00:10:44,800 --> 00:10:49,520
into the language with a multi-dimensional array or matrix being the central data type. This leads

141
00:10:49,520 --> 00:10:54,480
to extremely terse code that resembles mathematical notation and makes heavy use of the Greek alphabet.

142
00:10:54,480 --> 00:10:59,360
In 1970, Pascal was invented and took the programming world by storm. It's a procedural

143
00:10:59,360 --> 00:11:04,400
language with a familiar syntax and also had very fast compile times. It eventually became the most

144
00:11:04,400 --> 00:11:09,120
popular language in the early 1980s before the rise of C a few years later. There are many other

145
00:11:09,120 --> 00:11:13,520
important languages from this time period, like Simula, the first object-oriented language that

146
00:11:13,520 --> 00:11:19,120
went on to inspire Smalltalk, which itself inspired many other object-oriented languages like Python,

147
00:11:19,120 --> 00:11:23,680
Java and Ruby. Then there's Erlang, a concurrent functional programming language that basically

148
00:11:23,680 --> 00:11:28,080
powered the entire telecom industry and is still in use today. There's Ada, a general purpose

149
00:11:28,080 --> 00:11:32,720
language named after Ada Lovelace, who's generally considered the world's first computer programmer.

150
00:11:32,720 --> 00:11:36,960
It was extremely popular in the 1980s and is still used today by the Department of Defense

151
00:11:36,960 --> 00:11:40,880
to blow people up. In addition, we should mention Prolog, the language that pioneered

152
00:11:40,880 --> 00:11:45,200
logic programming, and MetaLanguage, which pioneered the polymorphic type system used by

153
00:11:45,200 --> 00:11:49,520
other statically-typed functional languages like Haskell. There are many other historical languages

154
00:11:49,520 --> 00:11:54,080
we could talk about, but now it's time to descend into the realm of the esoteric, where we find

155
00:11:54,080 --> 00:11:58,560
rare and bizarre languages that feel more like works of art than engineering tools. The first

156
00:11:58,560 --> 00:12:04,000
known esoteric language came out in 1972 and was called Intercal, which stands for compiler language

157
00:12:04,000 --> 00:12:08,560
with no pronounceable acronym. It was designed as a parody to make fun of the languages of the day,

158
00:12:08,560 --> 00:12:13,040
like Algol and Fortran. It has an entire paradoxical reference manual that makes no sense,

159
00:12:13,040 --> 00:12:17,360
and has an interesting choice of keywords like please and mingle. Please doesn't actually do

160
00:12:17,360 --> 00:12:22,080
anything, but it makes you a more polite programmer. Next up, we have brainf**k. Brainf**k is most

161
00:12:22,080 --> 00:12:26,400
well-known for being extremely minimal. Urban Mueller created brainf**k in college, and it works

162
00:12:26,400 --> 00:12:31,120
by initializing an array, then gives you a pointer and eight different characters to manipulate memory

163
00:12:31,120 --> 00:12:35,680
in that array. This results in a codebase that will f**k your brain up. It inspired another language

164
00:12:35,680 --> 00:12:40,640
called MaleBulge, or maybe it's Malbulgia, which is named after the Eighth Circle of Hell in the

165
00:12:40,640 --> 00:12:45,280
Divine Comedy or Dante's Inferno. If you thought brainf**k was difficult, this language takes things

166
00:12:45,280 --> 00:12:49,040
to a whole other level. It makes programming so difficult that I can't even summarize how it

167
00:12:49,040 --> 00:12:53,600
works in a single sentence. If that's a little too dark, a far more fun language is Chef, which

168
00:12:53,600 --> 00:12:57,840
is stack-based and is designed to make your code look like a cooking recipe. Instead of concise

169
00:12:57,840 --> 00:13:03,200
keywords, it uses sentences like put ingredient into mixing bowl to push a value onto the stack.

170
00:13:03,200 --> 00:13:07,680
Put these commands together to create a Hello World souffle, then specify how many it serves to

171
00:13:07,680 --> 00:13:11,840
write it to the standard output. That's pretty cool, but it may seem kind of silly to an intellectual.

172
00:13:11,840 --> 00:13:16,320
The Shakespeare programming language will make your code look like a Shakespearean play. It provides

173
00:13:16,320 --> 00:13:21,040
the low-level control of assembly with the verbosity of 16th century poetry, but if words

174
00:13:21,040 --> 00:13:24,960
aren't really your thing, then a good language choice would be Piat, which is named after Piat

175
00:13:25,520 --> 00:13:29,760
Mondrian. It's also stack-based, but you write code utilizing patterns of 20 different colors

176
00:13:29,760 --> 00:13:34,240
on a bitmap image. The end result is a code base that looks like abstract art. Now, if you're a

177
00:13:34,240 --> 00:13:39,040
crazy cat lady, you're really going to love this next language, LOL code, which provides a developer

178
00:13:39,040 --> 00:13:44,640
experience similar to an LOL cat meme. You open a program by saying hi, then end it by saying k

179
00:13:44,640 --> 00:13:49,200
thanks bye. Loops can be performed with I'm in your or broken out of with I'm out of your. That's

180
00:13:49,200 --> 00:13:53,840
nice and easy to understand, but it would be even better if it included emojis. Emoji code is a

181
00:13:53,840 --> 00:13:58,480
language where the syntax is entirely based on emojis. Modern developers like to use so many

182
00:13:58,480 --> 00:14:02,800
emojis in their documentation that this language would just streamline the entire process. It's

183
00:14:02,800 --> 00:14:07,520
a fully featured object-oriented language where you can define code blocks with grapes and watermelons,

184
00:14:07,520 --> 00:14:11,840
classes with rabbits, and generics with shells and eggplants. Another language that's not

185
00:14:11,840 --> 00:14:17,040
necessarily esoteric is C minus minus. It's designed as a portable assembly language that

186
00:14:17,040 --> 00:14:21,680
borrows heavily from C, but omits many of its features. The ultimate dialect of C, though,

187
00:14:21,680 --> 00:14:26,880
is Holy C, which was created by Terry A. Davis and used to build TempleOS, an operating system

188
00:14:26,880 --> 00:14:31,040
written under the direction of God. Holy C is actually really cool because it works like C,

189
00:14:31,040 --> 00:14:35,280
but it's just in time compiled on the operating system, which means you can use it like a scripting

190
00:14:35,280 --> 00:14:39,120
language that can interact directly with the operating system kernel. And that brings us to

191
00:14:39,120 --> 00:14:43,680
the final tier, the absolute lowest level you can go with your learning as a software engineer.

192
00:14:43,680 --> 00:14:48,400
Assembly is a language of which there are many variations that correspond directly to the

193
00:14:48,400 --> 00:14:54,320
architecture on the CPU. Different CPU architectures like x86 and ARM require different machine

194
00:14:54,320 --> 00:14:58,320
code instructions. Assembly allows you to represent this code with simple commands

195
00:14:58,320 --> 00:15:03,280
that manipulate values on the CPU's registers. Now, if that looks too easy, the next level down

196
00:15:03,280 --> 00:15:08,400
is machine code. At this point, we're looking at ones and zeros, or raw binary, usually represented

197
00:15:08,400 --> 00:15:12,400
in hexadecimal format. To code at this level, you'll need to have intimate knowledge of the

198
00:15:12,400 --> 00:15:17,200
computer's architecture and also be able to count in binary. But if we go beyond machine code,

199
00:15:17,200 --> 00:15:22,720
now we're looking at billions of transistors on a CPU. A single transistor represents one bit,

200
00:15:22,720 --> 00:15:27,200
like a one or zero, by controlling the amount of electricity that flows through a piece of

201
00:15:27,200 --> 00:15:32,400
silicon. Now, in order to do anything useful, the transistors need to be organized into logic gates,

202
00:15:32,400 --> 00:15:38,480
like not and or exclusive or and so on. Ultimately, it's these very simple chunks of logic that

203
00:15:38,480 --> 00:15:43,120
perform the miracle of taking some electricity as an input that can produce some other electricity

204
00:15:43,120 --> 00:15:47,120
as an output, and do it billions of times per second all over the world so you can play video

205
00:15:47,120 --> 00:15:51,040
games with your friend in Vietnam. If that was too easy, then you may want to look into the field

206
00:15:51,040 --> 00:15:56,080
of quantum electrodynamics. You fully understand how these particles behave in the electromagnetic

207
00:15:56,080 --> 00:16:01,360
quantum vacuum. You can then use your skills to build a next-gen, blazingly fast quantum computer

208
00:16:01,360 --> 00:16:05,440
and become the richest person in history. At this point in the iceberg, there's only one place left

209
00:16:05,440 --> 00:16:10,240
to go, the scariest place of all, yourself. Once you know everything, the question becomes,

210
00:16:10,320 --> 00:16:14,640
what is knowledge? Epistemology is the theory of knowledge, and philosophers still don't have a

211
00:16:14,640 --> 00:16:19,200
good answer to this day. Reality only exists within my own mind. For all I know, the entire

212
00:16:19,200 --> 00:16:24,320
external world and all the knowledge I've acquired are just illusions and projections from my own ego.

213
00:16:24,320 --> 00:16:28,480
Maybe there's a godlike being that controls all the sensations and knowledge received by my mind,

214
00:16:28,480 --> 00:16:32,880
or perhaps my real body isn't a vat of goo and I'm already living in Zuckerberg's Metaverse,

215
00:16:32,880 --> 00:16:37,200
or maybe I never came out of that ayahuasca trip I took 10 years ago. The only thing I really know

216
00:16:37,200 --> 00:16:41,440
is that I know nothing. Thanks for watching, and I will see you in the next one.

