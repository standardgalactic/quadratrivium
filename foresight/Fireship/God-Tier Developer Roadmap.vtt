WEBVTT

00:00.000 --> 00:03.840
You've likely seen videos on YouTube telling you the number one programming language to learn

00:03.840 --> 00:08.320
right now if you want to be rich. That's not what we're doing today. Instead, we're going to travel

00:08.320 --> 00:12.480
to the deepest, darkest depths of the software engineering field to discover the programming

00:12.480 --> 00:18.000
languages that are loved, hated, beautiful, ugly, compiled, interpreted, useful, weird, and everything

00:18.000 --> 00:21.840
in between. If you make it to the end, you'll have a roadmap for everything you need to know

00:21.840 --> 00:26.640
to land a job as a junior developer in 2023. Or it might just make you extremely depressed

00:26.640 --> 00:30.320
because this iceberg is just the tip of the iceberg of what you actually need to learn.

00:30.320 --> 00:34.400
Choose any language and you'll find another iceberg within this iceberg that goes on forever

00:34.400 --> 00:38.720
like a Mandelbrot set, which ironically you can represent in code with any one of the languages

00:38.720 --> 00:43.120
we're about to look at. Before we get started, there's quite a few programming icebergs out there,

00:43.120 --> 00:47.120
but this one ranks languages based on where I think you might encounter them as a beginner

00:47.120 --> 00:51.280
learning how to code from scratch. Each level has its own theme, so let's get right into it,

00:51.280 --> 00:55.280
with languages that are designed to make programming as easy as possible. If you know

00:55.280 --> 00:59.600
absolutely nothing about programming, the best place to start in my opinion is Scratch. It was

00:59.600 --> 01:04.320
developed at MIT, like some other languages on this list, but instead of typing out code, you drag

01:04.320 --> 01:08.960
and drop these blocks together like Lego bricks to represent things like variables, control flow,

01:08.960 --> 01:12.960
and operators. It makes the thinking process behind programming much more accessible, and you

01:12.960 --> 01:19.040
might be surprised at what you can actually build with it. Long before Scratch, though, we had basic,

01:19.040 --> 01:24.320
or beginner's all-purpose symbolic instruction code, which came out of Dartmouth in 1964. At the

01:24.320 --> 01:29.040
time, Fortran was all the rage, but it wasn't beginner-friendly. Basic provides a bunch of basic

01:29.040 --> 01:34.000
commands like print, go-to, and for, and was included in most personal computers, which made it the

01:34.000 --> 01:38.560
go-to option for people learning to code for the next 50 years. Now moving on to the next tier,

01:38.560 --> 01:42.880
we have the extremely popular dynamic high-level languages. The language most people start with

01:42.880 --> 01:48.560
today is Python, primarily because of its minimal syntax. It doesn't require curly braces, semicolons,

01:48.560 --> 01:53.360
and stuff like that, and instead uses indentation to represent different blocks of code. The other

01:53.360 --> 01:58.160
popular high-level language is JavaScript. Syntactically, it's pretty ugly, but it's a requirement

01:58.160 --> 02:01.840
if you want to do web development, and almost every developer will have to touch it at some point in

02:01.840 --> 02:06.320
their career. Any application that can be written in JavaScript will eventually be written in JavaScript.

02:06.320 --> 02:09.760
Now, after learning one of these languages, you'll be able to build pretty much anything you can

02:09.760 --> 02:14.000
imagine, and you could have an entire career as a software engineer without going any further down

02:14.000 --> 02:18.000
the iceberg. But you don't want to be on your deathbed wondering if you should have tried out PHP.

02:18.000 --> 02:22.320
On this next tier, we have languages that are extremely popular, but a little more specialized.

02:22.320 --> 02:25.680
Programmers like to get things done from the terminal, and there are scripting languages,

02:25.680 --> 02:29.920
like Bash and PowerShell, that allow you to interact with your computer programmatically,

02:29.920 --> 02:33.840
instead of typing out the same commands over and over again, write a Bash script to make it

02:33.840 --> 02:38.560
reproducible. Now, if you get into web development, you'll also need to learn HTML and CSS, which,

02:38.560 --> 02:42.560
when combined together, arguably form a turing-complete programming language. They're not

02:42.560 --> 02:46.560
used for programming in the traditional sense, but rather to define the structure and style of a

02:46.560 --> 02:50.320
website. And if I were to say HTML is not a programming language, I would be immediately

02:50.320 --> 02:54.160
canceled by the tech community. In addition, most apps need a database, and the most common

02:54.160 --> 02:59.600
language for working with databases is structured query language. You can call it SQL, SQL, or

02:59.600 --> 03:03.920
SQL. This turing-complete, although not used for regular programming, but rather to read and

03:03.920 --> 03:08.560
write data in a relational database. Now, Python is great and all, but there are many other dynamic

03:08.560 --> 03:13.600
languages that might be a better fit for certain projects, like PHP made it easy to build server

03:13.600 --> 03:18.880
side web apps in the 90s, and is still very popular today. Lua is easier and faster than Python,

03:18.880 --> 03:23.760
and is embedded into many engines like Roblox and World of Warcraft. Ruby is an easy-to-learn

03:23.760 --> 03:27.760
object-oriented language, also commonly used to build web apps with the Rails framework. If you

03:27.760 --> 03:32.960
work in data science, you'll come across R, which is used for statistics and data viz, or Julia,

03:32.960 --> 03:37.280
a more modern option, also used for scientific computing. The one thing all these languages

03:37.280 --> 03:42.560
have in common is a dynamic type system. However, as you build more complex software, you may realize

03:42.560 --> 03:47.120
that you need a more rigid framework, and one way to accomplish that is with a static type system.

03:47.120 --> 03:51.440
This tier makes up the bulk of production code out in the world. First up, we have Java, which

03:51.440 --> 03:56.080
kind of revolutionized programming with the Java virtual machine. It compiles to bytecode that

03:56.080 --> 04:00.880
runs on the JVM, and that allows developers to target any computer architecture from a single

04:00.880 --> 04:05.520
codebase. Syntactically, it's an absolute dumpster fire for beginners. I made an entire video about

04:05.520 --> 04:10.480
why people hate Java, but having explicit types in your code can make it much easier to understand

04:10.480 --> 04:15.120
and refactor, and modern IDEs like IntelliJ will pretty much make the code write itself.

04:15.120 --> 04:19.840
Java is legendary, but it was followed up by Microsoft with C-sharp. It's similar to Java in

04:19.840 --> 04:24.000
many ways, but gets a lot more love from its users. It's used to build games with Unity,

04:24.000 --> 04:28.640
as well as web and desktop apps with the .NET framework. Another well-loved tool from Microsoft

04:28.640 --> 04:33.920
is TypeScript. It takes JavaScript and adds a type system on top of it, making it much easier to work

04:33.920 --> 04:38.560
with on large complex projects. If you're building a mobile app today, you'll likely be working with

04:38.560 --> 04:43.680
Kotlin for Android, Swift for iOS, or Dart with the Flutter framework. These languages are all

04:43.680 --> 04:48.160
statically typed, but they go about it in a more modern, concise way, with features like type

04:48.160 --> 04:52.960
inference that minimize boilerplate code. Next up, we have Go, which is a high-performance

04:52.960 --> 04:57.920
language developed at Google, to build low-level systems. It was designed as a replacement for C,

04:57.920 --> 05:02.400
and Ken Thompson, one of the original creators of C, helped design it. The syntax is nice and

05:02.400 --> 05:07.440
concise, making it approachable to beginners, and it has a garbage collector, which means unlike C,

05:07.440 --> 05:11.680
developers don't need to worry about manual memory management. Okay, so at this point,

05:11.680 --> 05:15.680
we've reached the level of the iceberg, where most people are afraid to go any deeper. Things

05:15.680 --> 05:19.840
are going to get weird. What happens is that many developers get jaded with these big, heavy,

05:19.840 --> 05:24.640
object-oriented languages and go searching for a better way. At this level, we have functional

05:24.640 --> 05:29.280
languages, the most famous of which is Haskell. Instead of classes and heritans and all kinds

05:29.280 --> 05:34.160
of crazy design patterns, the only abstraction you really need is the function. It was inspired by

05:34.160 --> 05:38.800
the Miranda language and is named after the mathematician Haskell Curry. Most importantly,

05:38.800 --> 05:43.600
variables are immutable, and functions have no side effects. Surprisingly, you can build almost

05:43.600 --> 05:47.280
anything with these limitations, although most production code out there is not functional.

05:47.280 --> 05:51.040
Most of us run into problems when trying to figure out what a monad is, which in layman's

05:51.040 --> 05:56.240
terms is just a monoid in the category of end functors. Haskell is great, but Microsoft developed

05:56.240 --> 06:01.360
a functional sister language to C sharp called F sharp. Unlike Haskell, which is purely functional,

06:01.360 --> 06:06.000
F sharp is also imperative and object-oriented, making it more approachable to developers

06:06.000 --> 06:10.560
coming from higher up in the iceberg. Now, if you hate Java, a good alternative is Scala.

06:10.560 --> 06:14.800
Like F sharp, it supports both object-oriented and functional programming, but it runs on the

06:14.800 --> 06:20.400
JVM. It's statically typed, but there's another JVM language called Clojure that is both functional

06:20.400 --> 06:24.560
and dynamic. This makes it more well suited for getting things done quickly with the trade-off

06:24.560 --> 06:29.840
of type safety. Other popular functional languages include OCaml, which is used extensively at Facebook,

06:29.840 --> 06:35.040
and Elixir, which has a very nice ruby-like syntax and is capable of building high-performance,

06:35.040 --> 06:39.680
real-time web apps. There's also Elm, which is a purely functional language that compiles to

06:39.680 --> 06:44.640
JavaScript, which can build front-end UIs with zero runtime errors, but now it's time to go one

06:44.640 --> 06:49.440
level deeper to the heart of the iceberg. These languages are absolute chads. They're low-level

06:49.440 --> 06:53.920
systems languages that can manually manage and optimize memory and are used to build things

06:53.920 --> 06:58.800
like operating system kernels and compilers that make all the other soy-based languages possible,

06:58.800 --> 07:03.680
the most legendary of which is C. It was used to build the Windows, Mac, and Linux operating system

07:03.680 --> 07:08.240
kernels, and its curly brace syntax inspired many other languages on this list. Surprisingly,

07:08.240 --> 07:11.920
it's not all that hard to learn and has a relatively small set of keywords to memorize.

07:11.920 --> 07:16.720
However, being able to use it effectively requires extensive knowledge of algorithms and computer

07:16.720 --> 07:21.120
architecture. For example, C doesn't have hash maps or dictionaries, so you'll have to learn how

07:21.120 --> 07:25.040
to code up that data structure on your own. C was the perfect programming language when it came out

07:25.040 --> 07:31.040
in 1969, but it only supported procedural programming and eventually developers wanted more. C++ was

07:31.040 --> 07:35.840
originally a superset of C designed to extend it with object-oriented programming patterns,

07:35.840 --> 07:40.640
like classes and inheritance. Unlike C, it's extremely hard to learn and provides many opportunities

07:40.640 --> 07:45.440
to not only shoot yourself in the foot, but blow your entire leg off. This is a reference to manual

07:45.440 --> 07:49.680
memory management with pointers, which got that name because they're just as dangerous as pointing

07:49.680 --> 07:54.000
a gun at someone. Despite its learning curve, it's an extremely prolific language used to build

07:54.000 --> 07:59.440
highly optimized software like game engines, compilers, and so on. C and C++ are still extremely

07:59.440 --> 08:04.240
relevant today, but the modern Chad tends to prefer rust for low-level programming. It doesn't

08:04.240 --> 08:10.080
have a garbage collector, but unlike C and C++, it uses a technique called borrow-checking instead

08:10.080 --> 08:14.720
of pointers for memory management. This makes it much easier to write memory-safe programs and

08:14.720 --> 08:19.040
consistently ranks as the most loved language in the world. The languages on this tier are

08:19.040 --> 08:23.840
extremely popular, but now we descend further into the modern languages that you probably haven't

08:23.840 --> 08:28.480
heard of. First up, we have V, which is a high-performance systems language that feels very

08:28.560 --> 08:34.000
similar to Go, but unlike Go, it doesn't use a garbage collector, and unlike Rust, it doesn't do

08:34.000 --> 08:38.960
borrow-checking, but it can still create memory-safe applications with its own auto-free innovation

08:38.960 --> 08:43.440
where the compiler basically cleans everything up. I have no idea how it works, but it looks cool.

08:43.440 --> 08:48.480
Another modern replacement for C is Zig. It's designed to simplify low-level programming by

08:48.480 --> 08:53.120
eliminating features like macros and metaprogramming and is very explicit when it comes to memory

08:53.600 --> 08:58.720
management, and it can cross-compile C and C++ just like Clang. Zig is not to be confused with NIM,

08:58.720 --> 09:03.120
another high-performance language that's very expressive like Python, but is statically typed,

09:03.120 --> 09:07.520
and interestingly, it has a tunable garbage collector that can be turned off altogether to

09:07.520 --> 09:12.320
enable manual memory management. Recently, Google announced Carbon, designed to be a successor to

09:12.320 --> 09:18.400
C++. What makes it special is that it can fully interop with a legacy C++ codebase. Another low-level

09:18.480 --> 09:23.120
specialty language is Solidity. It's a statically typed object-oriented language, but is designed

09:23.120 --> 09:27.840
for implementing smart contracts, especially on the Ethereum blockchain. Then we've got Hack from

09:27.840 --> 09:32.320
Facebook, which is designed to interop with PHP. The original website was built with PHP,

09:32.320 --> 09:36.880
but they needed a language with better performance and a type system to scale it up to the monstrosity

09:36.880 --> 09:41.040
that it is today. There are many other good modern languages at this point in the iceberg,

09:41.040 --> 09:45.840
like Crystal, Hacks, and Ferro, just to name a few, but now it's time to go down to the next level,

09:45.840 --> 09:49.760
where we look at languages that are still either widely used or historically important,

09:49.760 --> 09:53.600
but not something you would likely choose to program in. Fortran was the first high-level

09:53.600 --> 09:58.000
programming language, and was by far the most popular language for many years until C came

09:58.000 --> 10:04.080
around. Not long after Fortran, Lisp was invented in 1958. It pioneered many ideas we take for granted

10:04.080 --> 10:09.200
in computer science today, like dynamic typing, higher-order functions, recursion, and repel.

10:09.200 --> 10:13.600
It inspired many other languages like racket, scheme, closure, and to a certain extent,

10:13.600 --> 10:18.640
JavaScript. Another highly influential language that came out this year was Algorithmic Language.

10:18.640 --> 10:23.600
It's a big, complex language and never got as popular as Fortran, but its type system and use

10:23.600 --> 10:28.240
of expressions had a major influence on the development of C and C++. The following year,

10:28.240 --> 10:34.000
in 1959, Kobal was born. If you want to make money in the 2020s, learn Kobal, because over 40%

10:34.000 --> 10:39.360
of banking systems still use it, with over 200 billion lines of code in production today. In 62,

10:39.360 --> 10:44.800
APL first appeared, which stands for a programming language. It implements linear algebra directly

10:44.800 --> 10:49.520
into the language with a multi-dimensional array or matrix being the central data type. This leads

10:49.520 --> 10:54.480
to extremely terse code that resembles mathematical notation and makes heavy use of the Greek alphabet.

10:54.480 --> 10:59.360
In 1970, Pascal was invented and took the programming world by storm. It's a procedural

10:59.360 --> 11:04.400
language with a familiar syntax and also had very fast compile times. It eventually became the most

11:04.400 --> 11:09.120
popular language in the early 1980s before the rise of C a few years later. There are many other

11:09.120 --> 11:13.520
important languages from this time period, like Simula, the first object-oriented language that

11:13.520 --> 11:19.120
went on to inspire Smalltalk, which itself inspired many other object-oriented languages like Python,

11:19.120 --> 11:23.680
Java and Ruby. Then there's Erlang, a concurrent functional programming language that basically

11:23.680 --> 11:28.080
powered the entire telecom industry and is still in use today. There's Ada, a general purpose

11:28.080 --> 11:32.720
language named after Ada Lovelace, who's generally considered the world's first computer programmer.

11:32.720 --> 11:36.960
It was extremely popular in the 1980s and is still used today by the Department of Defense

11:36.960 --> 11:40.880
to blow people up. In addition, we should mention Prolog, the language that pioneered

11:40.880 --> 11:45.200
logic programming, and MetaLanguage, which pioneered the polymorphic type system used by

11:45.200 --> 11:49.520
other statically-typed functional languages like Haskell. There are many other historical languages

11:49.520 --> 11:54.080
we could talk about, but now it's time to descend into the realm of the esoteric, where we find

11:54.080 --> 11:58.560
rare and bizarre languages that feel more like works of art than engineering tools. The first

11:58.560 --> 12:04.000
known esoteric language came out in 1972 and was called Intercal, which stands for compiler language

12:04.000 --> 12:08.560
with no pronounceable acronym. It was designed as a parody to make fun of the languages of the day,

12:08.560 --> 12:13.040
like Algol and Fortran. It has an entire paradoxical reference manual that makes no sense,

12:13.040 --> 12:17.360
and has an interesting choice of keywords like please and mingle. Please doesn't actually do

12:17.360 --> 12:22.080
anything, but it makes you a more polite programmer. Next up, we have brainf**k. Brainf**k is most

12:22.080 --> 12:26.400
well-known for being extremely minimal. Urban Mueller created brainf**k in college, and it works

12:26.400 --> 12:31.120
by initializing an array, then gives you a pointer and eight different characters to manipulate memory

12:31.120 --> 12:35.680
in that array. This results in a codebase that will f**k your brain up. It inspired another language

12:35.680 --> 12:40.640
called MaleBulge, or maybe it's Malbulgia, which is named after the Eighth Circle of Hell in the

12:40.640 --> 12:45.280
Divine Comedy or Dante's Inferno. If you thought brainf**k was difficult, this language takes things

12:45.280 --> 12:49.040
to a whole other level. It makes programming so difficult that I can't even summarize how it

12:49.040 --> 12:53.600
works in a single sentence. If that's a little too dark, a far more fun language is Chef, which

12:53.600 --> 12:57.840
is stack-based and is designed to make your code look like a cooking recipe. Instead of concise

12:57.840 --> 13:03.200
keywords, it uses sentences like put ingredient into mixing bowl to push a value onto the stack.

13:03.200 --> 13:07.680
Put these commands together to create a Hello World souffle, then specify how many it serves to

13:07.680 --> 13:11.840
write it to the standard output. That's pretty cool, but it may seem kind of silly to an intellectual.

13:11.840 --> 13:16.320
The Shakespeare programming language will make your code look like a Shakespearean play. It provides

13:16.320 --> 13:21.040
the low-level control of assembly with the verbosity of 16th century poetry, but if words

13:21.040 --> 13:24.960
aren't really your thing, then a good language choice would be Piat, which is named after Piat

13:25.520 --> 13:29.760
Mondrian. It's also stack-based, but you write code utilizing patterns of 20 different colors

13:29.760 --> 13:34.240
on a bitmap image. The end result is a code base that looks like abstract art. Now, if you're a

13:34.240 --> 13:39.040
crazy cat lady, you're really going to love this next language, LOL code, which provides a developer

13:39.040 --> 13:44.640
experience similar to an LOL cat meme. You open a program by saying hi, then end it by saying k

13:44.640 --> 13:49.200
thanks bye. Loops can be performed with I'm in your or broken out of with I'm out of your. That's

13:49.200 --> 13:53.840
nice and easy to understand, but it would be even better if it included emojis. Emoji code is a

13:53.840 --> 13:58.480
language where the syntax is entirely based on emojis. Modern developers like to use so many

13:58.480 --> 14:02.800
emojis in their documentation that this language would just streamline the entire process. It's

14:02.800 --> 14:07.520
a fully featured object-oriented language where you can define code blocks with grapes and watermelons,

14:07.520 --> 14:11.840
classes with rabbits, and generics with shells and eggplants. Another language that's not

14:11.840 --> 14:17.040
necessarily esoteric is C minus minus. It's designed as a portable assembly language that

14:17.040 --> 14:21.680
borrows heavily from C, but omits many of its features. The ultimate dialect of C, though,

14:21.680 --> 14:26.880
is Holy C, which was created by Terry A. Davis and used to build TempleOS, an operating system

14:26.880 --> 14:31.040
written under the direction of God. Holy C is actually really cool because it works like C,

14:31.040 --> 14:35.280
but it's just in time compiled on the operating system, which means you can use it like a scripting

14:35.280 --> 14:39.120
language that can interact directly with the operating system kernel. And that brings us to

14:39.120 --> 14:43.680
the final tier, the absolute lowest level you can go with your learning as a software engineer.

14:43.680 --> 14:48.400
Assembly is a language of which there are many variations that correspond directly to the

14:48.400 --> 14:54.320
architecture on the CPU. Different CPU architectures like x86 and ARM require different machine

14:54.320 --> 14:58.320
code instructions. Assembly allows you to represent this code with simple commands

14:58.320 --> 15:03.280
that manipulate values on the CPU's registers. Now, if that looks too easy, the next level down

15:03.280 --> 15:08.400
is machine code. At this point, we're looking at ones and zeros, or raw binary, usually represented

15:08.400 --> 15:12.400
in hexadecimal format. To code at this level, you'll need to have intimate knowledge of the

15:12.400 --> 15:17.200
computer's architecture and also be able to count in binary. But if we go beyond machine code,

15:17.200 --> 15:22.720
now we're looking at billions of transistors on a CPU. A single transistor represents one bit,

15:22.720 --> 15:27.200
like a one or zero, by controlling the amount of electricity that flows through a piece of

15:27.200 --> 15:32.400
silicon. Now, in order to do anything useful, the transistors need to be organized into logic gates,

15:32.400 --> 15:38.480
like not and or exclusive or and so on. Ultimately, it's these very simple chunks of logic that

15:38.480 --> 15:43.120
perform the miracle of taking some electricity as an input that can produce some other electricity

15:43.120 --> 15:47.120
as an output, and do it billions of times per second all over the world so you can play video

15:47.120 --> 15:51.040
games with your friend in Vietnam. If that was too easy, then you may want to look into the field

15:51.040 --> 15:56.080
of quantum electrodynamics. You fully understand how these particles behave in the electromagnetic

15:56.080 --> 16:01.360
quantum vacuum. You can then use your skills to build a next-gen, blazingly fast quantum computer

16:01.360 --> 16:05.440
and become the richest person in history. At this point in the iceberg, there's only one place left

16:05.440 --> 16:10.240
to go, the scariest place of all, yourself. Once you know everything, the question becomes,

16:10.320 --> 16:14.640
what is knowledge? Epistemology is the theory of knowledge, and philosophers still don't have a

16:14.640 --> 16:19.200
good answer to this day. Reality only exists within my own mind. For all I know, the entire

16:19.200 --> 16:24.320
external world and all the knowledge I've acquired are just illusions and projections from my own ego.

16:24.320 --> 16:28.480
Maybe there's a godlike being that controls all the sensations and knowledge received by my mind,

16:28.480 --> 16:32.880
or perhaps my real body isn't a vat of goo and I'm already living in Zuckerberg's Metaverse,

16:32.880 --> 16:37.200
or maybe I never came out of that ayahuasca trip I took 10 years ago. The only thing I really know

16:37.200 --> 16:41.440
is that I know nothing. Thanks for watching, and I will see you in the next one.

