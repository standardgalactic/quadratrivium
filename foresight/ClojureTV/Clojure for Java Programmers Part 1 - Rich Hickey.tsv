start	end	text
0	10000	Hi. I'm Racheke. I'm here to talk about Closure, which is a programming language I wrote for
10000	17600	the JVM. This particular talk is oriented towards people who program in Java or C sharp
17600	24480	or C++ in particular that I'm not going to presume any knowledge of Lisp. So you might
24480	31280	find some of it tedious, although I am preparing for a talk I'm going to give at ecoup to the
31280	36600	European Lisp workshop, where I'm going to talk about the ways Closure is a different
36600	44600	Lisp. So maybe some of this will be interesting to you in that respect. But that's the nature
44600	48720	of this talk. It's going to be an introduction to the language, a fly-by tour of some of
48720	53720	the features. I'll drill down into some of the others. I started to ask this question
53720	58160	before, but I'll just ask it again to sort of see, is there anyone here who knows or
58160	67360	uses any flavor of Lisp, common Lisp scheme or Closure? Okay. So mostly no. I presume
67360	74760	a lot of Java or anything in that family, C++, C sharp, Scala, anyone? You must be playing
74760	80280	with it, right? How about functional programming languages like ML or Haskell District? Guys,
80320	87160	anyone a little? Don't really want to raise their hands about that one. Okay. That's good. In
87160	93280	particular, I think coming from that background, you'll understand a lot of this straight away.
93280	101480	How about dynamic programming languages, Python, Ruby or Groovy? Yes, about half. And I asked
101480	110200	before, Closure, we have a few people with their toes in the water. The other key aspect
110240	114680	of Closure that would matter to you if you're a Java programmer is whether or not you do
114680	122400	any real multi-threaded programming in Java or in any language. Yes? So some. So you use
122400	135000	locks and all of that nightmare stuff. I'm a practitioner. I programmed in C and C++ and
135040	141120	Java and C sharp and Common Lisp and Python and JavaScript and a bunch of languages over the
141120	149080	years. Way back, this same group, I think it's the same lineage, was the CIG. And when I first
149080	155920	started to come, I started to teach C++ to the CIG and it became the C++ and CIG and eventually
155920	163160	the C++ and Java CIG and now the Java CIG. So back in the 90s, early 90s and mid 90s, I taught
163800	170640	C++ and advanced C++ to this group and ran study groups and I've come back tonight to apologize
174120	183000	for having done that to you and to try to set you off on a better track. So we're going to look at
183000	191080	the fundamentals of Closure and it will be also of Lisp in many ways. But I'm going to say Closure,
191560	197160	don't take offense, all these things or many of the things I say are true of Closure are true of
197160	204600	many Lisp. I didn't invent them, they're not unique to Closure, but some things are. They will
204600	210720	look at the syntax and evaluation model. This is the stuff that will seem most unusual to you if
210720	217480	you've come from a, you know, compile link run language and one of the curly brace C derives
217520	226520	like Java. Then we'll look at some aspects of Closure, sequences in particular and the Java
226520	232760	integration which I imagine will be interesting and I'll finally end up talking about concurrency,
232760	237000	why Closure has some of the features it does and how they address the problems of writing
237000	243880	concurrent programs that run on the new and indefinitely, you know, for the indefinite future
243920	248400	multi-core machines and I'll take some questions. At some point in the middle we'll probably take
248400	255400	a break. I don't know exactly where that's going to go. So what's the fundamentals of Closure?
255400	261240	Closure is a dynamic programming language and dynamic has a lot of different meanings, in
261240	267480	particular it's dynamically typed, that would be an expectation you'd have of Python or Ruby or
267520	277320	Groovy. It achieves that dynamic nature by being a Lisp and I'll talk more about that. I don't see a
277320	285760	lot of people who know Lisp here but that doesn't mean there isn't a bias against Lisp. How many
285760	295000	people have seen Lisp and said oh my god, I can't believe the parentheses and I would say I'd hope
295040	301360	you'd put that bias aside for the purposes of this talk. It ends up that for people who have not used
301360	310000	Lisp, those biases have no basis and for most people who have given it a solid try, they vanish and in
310000	319880	fact many of the things you consider to be problems with Lisp are features down the line. But having
319920	326000	said that, Closure is a very different Lisp. It's syntactically much leaner than a lot of Lisp's. It
326000	334720	has fewer parentheses. It uses more data structures in its syntax and as a result I think is more
334720	343400	succinct and more readable. So maybe the time to try Lisp again. Another aspect of Closure is that
343400	347440	it's a functional programming language and again I'm going to talk in detail about these things. For
347480	353520	now you can just say that means a focus on immutability in your programs. So write programs
353520	358840	primarily with immutable data structures and if you're coming from another Lisp, this will be an
358840	364400	area where Closure is definitely different. I mean different decisions about the data structures
364400	370280	in Closure. The third leg of Closure, you know, it sort of stands on four points. It's dynamic,
370280	376360	it's functional, it's hosted on the JVM and it embraces the JVM, its host platform. There are
376400	380200	ports of other languages that sort of just sit on the JVM. There are ports of, for instance,
380200	386400	common Lisp that sit on the JVM. But they don't really connect very well. For a number of reasons.
386400	391240	One is they're implementing a standard. The standard was written before Java was written and
391240	396760	you know, there's just no merging the type systems. On the other hand, Closure was written for the
396760	404160	JVM and so it's very heavily integrated with it. So not only does it reside there, which is a
404200	409560	benefit because you can run it if that's your environment. But it embraces it, which means the
409560	415880	integration is good and it's pretty transparent to go back and forth. The fourth aspect of Closure
415880	423880	is the concurrency aspect. You know, I work in C-Sharp with guys writing broadcast automation
423880	428760	systems. They're, you know, they're multi-threaded. They have all kinds of nasty stuff going on,
428800	435040	multiple connections to sockets, lots of databases, you know, data feeds from all kinds of places
435040	441040	and it's not fun writing programs like that that need to share data structures amongst
442340	448580	threads and to have them get maintained over time and have everybody remember what the locking
448580	453880	model is. It's extremely challenging. Anyone who's done any extensive multi-threaded programming
453900	459200	with the locking model knows how hard it is to get that right. So Closure is an effort on my
459200	464200	part to solve those problems in an automatic way with language support. And the last thing
466760	471200	is, you know, it is an open source language and it's very transparent, the implementation
471200	478200	and everything else is up there for you to see. We started to talk about this before. Why use a
478200	484440	dynamic language? Some people are very happy, of the people who are programming Java, how we are
484440	489440	happy about that. They like Java. They have no complaints. Okay, not too many. It ends up that I
493240	499420	think many Java programmers look at people who are using Python or Ruby and being very
499420	504420	productive and I think justifiably MV, their productivity, the succinctness, the flexibility
505260	511260	they have and in particular how quickly they can get things done. And it ends up that that is a
512760	518760	fact of the static languages, especially the ones like Java, that they're inherently slower
519840	526340	because of the amount of, well some people call it ceremony, but you have to go through to
526340	532340	communicate with the language. It slows you down. So flexibility is a key thing. You would look for
533340	539340	in a dynamic language. Interactivity is another key point. Again, this goes back to Lisp. Lisp has
539340	544860	pretty much always been an interactive language. And that means a lot of things. In particular, it
544860	550860	means that when you've got Lisp up and running, you feel like you are engaged with an environment as
551460	557460	opposed to, you know, shoveling your text through a compiler phase to produce something else out the
558380	564380	other end. So that interactivity is kind of a deep thing. The repul is part of it. That means read,
564380	570380	eval, print, loop, and I'll talk about that in detail in a little bit. Dynamic languages tend to be
570380	575380	more concise. That doesn't mean that static languages can't be. Haskell in particular is very
575380	581380	concise. But the curly brace languages are not concise. Java is probably a great example of a
582380	588380	language that's not concise. And that's just not a matter of tedium. It's a matter of where is your
588380	595380	logic? How far apart is your logic? How spread out is it? Can you see what you're thinking about? Or is it
595380	601380	in pieces? Is it spread out by a bunch of things that are not about your problem? Dynamic languages are
603380	609380	definitely more suitable for exploration. There's a certain aspect in which static languages are like
609700	615500	concrete. That's a good aspect when you're trying to, you know, finish. In some systems, you know,
615500	620780	concrete is going to be more resilient. It's, you know, it's more resilient to change. It's more
620780	625780	structured and it's rigid. On the other hand, that's not necessarily the kind of materials you
625780	630500	want to be working with when you're trying to figure out what your structure should look like in
630500	638000	the first place. So dynamic languages are better for exploration. And in particular, what I like
638080	644080	about dynamic languages and Lisp fundamentally, and I think in a way other languages don't achieve, is it
646720	651720	lets you focus on your problem. You can, with Lisp and its ability to do syntactic abstraction, suck
654280	660280	everything out of the way, except the problem. And for me, you know, when I discovered Lisp, I was
661280	667280	pretty expert, C++ programmer. I said to myself, what have I been doing with my life? It was that, that
671280	677280	big a deal. So there are many dynamic languages. I'm going to talk about closure and I will do, you
680280	685280	know, bashing of other languages, but I will try to highlight why you might choose closure over some of
685280	690280	the other options. Because in particular now, I think it's a great thing that there are many dynamic
690280	695280	languages available for the JVM and dynamic languages are supported as a concept in the Java community.
698280	703280	A Java one, there was plenty of presentations on Jython and JRuby and Groovy and these other languages.
706280	712280	And Sun has hired some of the developers of these languages and given it, you know, kind of official
712280	717280	support as something that's viable to do on the JVM. So you're going to see mixed language
719280	724280	programming being accepted in Java shops. So how do you pick? I think you can categorize languages in one
727280	732280	dimension pretty straightforward. Are they a port of a language that exists somewhere else or were they
732280	737280	written for the JVM? Ports have a bunch of challenges. One is there is a canonic version out there because
738280	743280	most of these languages are not defined by a specification. They're defined by a canonic
743280	748280	implementation. So they're CRuby. They're CPython. Those are really the languages. And the other things are
752280	757280	ports which have to struggle to follow along with the C version. The other problem ports have is a lot of
760280	765280	the infrastructure for the languages, especially the ones that don't perform very well, are written in C. In
765280	770280	other words, to get the library performance they need, the support libraries for Python are written in C. So
770280	776280	an effort to port Python to Java means having to replicate those C libraries. So there's that. I would
776280	782280	say the main appeal to a ported language is if you already have an investment in Ruby or Python or you
782280	788280	have to really love the language designs. That's a good way to go here. I would say if not, if you're just
789280	794280	starting from scratch, you may find that a language that's native to the JVM is going to give you better
796280	801280	integration. You know the version you're using is the canonic version. The canonic version of Ruby is a JVM
801280	806280	language. The canonic version of Closure is a JVM language. And I would say of the two, Groovy is going to let
810280	815280	you do what you do in Java, except a little bit more easily. Fewer semicolons, more dynamic, there are
818280	823280	some builders, there are some idioms, there are closures, sort of the fun of dynamic programming and a lot of
826280	831280	the similar syntax to Java. So I think if you're just interested in dynamic and want to continue to write
834280	839280	programs that are like your Java programs, Groovy can't be touched. Closure is not about writing programs like
840280	845280	your Java programs. Closure is about realizing what's wrong with your Java programs and doing something
849280	854280	different. And so you'll find some of that through the talk. So Closure itself, it inherits from Lisp, an
860280	865280	expressivity and elegance I think is unmatched. Depending on your mindset, you may or may not agree, but this is a
869280	874280	certain mathematical purity to lambda calculus and the way it's realized in Lisp. The uniformity of the syntax
876280	881280	is elegant. Closure also has very good performance. Again, I'm not going to get involved in any language
884280	888280	bashing, but I'm pretty confident no other dynamic language on the JVM approaches the performance of
890280	895280	Closure in any area and is unlikely to. But everybody's working on performance.
900280	902280	Certainly.
907280	909280	We've converted them.
915280	920280	So the performance is good. I made a point before starting the talk that the objective and objective of
921280	926280	Closure is to be useful in every area in which Java is useful. You can tackle the same kind of problems. I don't
927280	932280	write web apps and put stuff in and take it out of the database kind of applications. I write scheduling
935280	940280	systems, broadcast automation systems, election projection systems, machine listening systems, audio
945280	950280	analysis systems, and I write them in languages like C-sharp and Java and C++ and Closure can be used for those
951280	956280	kinds of problems. It doesn't mean they can't also be used for web apps and people did that right away with
959280	964280	Closure and database and UI stuff. But it has that same kind of reach. One of the nice things about Java is it
968280	973280	has a wide range. Closure has direct wrapper free access to Java. Some of the ported languages have to use
974280	979280	wrappers because those languages have their own object systems that imply a bunch of dynamic features that they
982280	986280	have to glom on top of Java objects when you interoperate with them. Closure was designed to provide direct
989280	994280	access to Java. It looks like Closure, but it's direct. Closure being a list is extensible in a deep way.
995280	1000280	And we'll talk a little bit more about how you get syntactic extensibility through macros. And then Closure, I
1003280	1008280	think, is completely unique amongst the languages on the JVM in promoting immutability and concurrency, much more
1009280	1014280	so than even Scala, which is often talked about as a functional language, but it's also a
1015280	1020280	option. Closure is really oriented towards writing concurrent programs. And immutability for its other benefits
1025280	1031280	outside of concurrency. So how does Closure get to be these things? It is a list. It is a list. It is a list.
1045280	1050280	Again, put what you think about Lisp aside. I'll explain what that means in depth as I go into each of these
1053280	1057280	points, but Lisp in general is dynamic in that way, interacting with an environment, having a REPL,
1058280	1063280	having sort of introspection capabilities on the environment, being able to modify things in a running
1064280	1069280	program, or all characteristics that make it dynamic. A fundamental feature of all Lisp, if they want to be a
1070280	1075280	Lisp, is that code is represented as data. And again, I'll explain that in detail. There is a reader, which is part of the
1084280	1089280	implementation of code as data, sort of something in between your text and the evaluator. Being a Lisp
1092280	1097280	means having an extremely small core. You'll find when you contrast Closure to other languages, even
1097280	1102280	languages that are theoretically lightweight like Python or Ruby, Closure has way less syntax than those languages, far
1105280	1110280	less complexity. In spite of the fact that they appear easy. Lisp generally have tended to emphasize lists.
1118280	1123280	Closure is not exactly the same way. It is an area where Closure differs from Lisp in that it frees the abstract
1124280	1129280	of first and rest from a data structure, the con cells. And in doing so, offers the power of Lisp to many more data
1137280	1142280	structures than most Lisp do. So there's that sequence thing, and I'll talk more about that in detail. And syntactic
1144280	1149280	abstraction. Again, we have abstraction capabilities with functions or methods in most languages. Lisp
1150280	1155280	take that to the next level by allowing you to suck even more repetition out of your programs when that
1158280	1163280	repetition can't be sucked out by making a function. Okay, so we'll dig down a little bit more. What does it mean to do
1167280	1172280	dynamic development? It means that there's going to be something called a REPL, a read eval print loop in which you
1173280	1178280	can type things and press enter and see what happens. I guess we should probably do that. So this is a little
1185280	1190280	editor. It's kind of squashed in the screen resolution, but down below is the REPL. This is Closure in an
1192280	1197280	interactive mode, and we can go and we can say plus one, two, three, and we get six. We can do other things
1198280	1203280	Java like, I'll show you some more of that later. But the general idea is that you're going to be able to type
1206280	1211280	expressions or in your editor, say please evaluate this. I mean, I can go up here to meth.pi and hit the key
1214280	1219280	stroke that says evaluate this and see below, we get that. And that's kind of what it feels like to develop. I'm
1221280	1226280	going to show you even more after I explain what you're looking at because I don't want this talk to be yet another
1228280	1233280	people are shown Lisp and not having had to explain to them what they're looking at. So we're going to do that first.
1235280	1240280	But you have this interactive environment. You can define functions on the fly. You can fix functions on the fly.
1240280	1245280	You can have a running program and fix a bug in a running program. And that's not like being in a mode in a
1247280	1252280	debugger where you have the special capability to reload something. It's always present. If you build an
1253280	1258280	application with some access to the ability to load code, either a remote REPL connection or some way to do that,
1260280	1265280	your running production systems will have this capability to have fixes loaded into running programs.
1270280	1275280	In general, there isn't the same distinction between compile time and run time. Compiling happens all the time.
1276280	1281280	Every time you load code, every time you evaluate an expression, compilation occurs. So that notion of phases of
1286280	1291280	compilation is something you have to relax when you're looking at a language like closure. And I'll show you the
1292280	1296280	evaluation model in a second. I talked a little bit about the introspection, but that's present. You're sitting at a
1298280	1303280	REPL, closure is there, closure has namespaces, you can get a list of them. Closure has symbols, you can get a list of
1304280	1309280	those. You can look inside the infrastructure that underlies the run time and manipulate it. And that's what I
1313280	1318280	mean by an interactive environment. I just don't mean typing things in. I mean, there is a program behind your
1319280	1324280	program that is the run time of closure. And that's accessible. If I say something that you don't
1325280	1331280	understand, you can ask for clarification. I'm endeavoring to try to come up with the ideal way to explain
1337280	1342280	the list to people who have never seen it. And this is what I've come up with, which is to talk about data. Lots of
1345280	1351280	languages have syntax. You can talk about Java. You can talk about here's main and here's what public means and static.
1352280	1357280	And then you can dig into arguments to a function and things like that. But we're going to start here with data, in
1358280	1362280	particular data literals. I think everybody understands data literals from languages they're familiar with. You type in
1363280	1368280	1, 2, 3, 4, and you know that's going to mean 1,234 to your program. So closure has integers, they have
1373280	1379280	arbitrary precision. They can get as large as your memory can support. And the promotion of
1381280	1388280	small integers to larger integers while arithmetic is going on is automatic. It supports doubles as the floating
1389280	1396280	point format. Those are doubles. Those are big D double Java doubles. When you type them in. They're right. Right.
1400280	1405280	They're Java doubles, but they're the big D doubles. So one of the things you're going to see about closure is
1406280	1412280	everything is an object. Okay. All numbers are boxed. At least until you get inside a loop where I can unbox them. But it's a
1416280	1421280	language in which numbers are boxed. Unlike common lists where you have access under the hood to use tagged integers and
1424280	1429280	tagged numbers, which is more efficient than allocating them on the heap, no capability of doing that in the JVM.
1430280	1435280	There's been talk about it, them adding it, which is stunning to me. Apparently the guy, there's this guy, John Rose, at
1438280	1444280	Sun who really does understand this very well. And has talked about all kinds of really neat features, which if they make it into the
1444280	1449280	JVM would make it stunning. Like tail call elimination and tagged numbers. But in the absence of that, numbers are boxed so
1450280	1455280	that everything can be an object and can be treated uniformly. You have big decimal literals. You have ratios. 22 over 7 is
1464280	1469280	something. It's not divide 22 by 7. It's a number. It's a number that's not going to lose any information versus dividing 22 by
1472280	1477280	7 and either truncating or converting into a floating point format where you will lose information. So ratios are first class.
1480280	1485280	String literals are in double quotes. They are Java strings. Same thing. Immutable. No conversions, no mapping. Being, again,
1490280	1495280	being a native JVM language means I can just adopt the semantics of Java literals. I don't have to take strings from a
1499280	1504280	language spec that said, for instance, they could be mutable. I have to force it on the JVM by having my own type and conversions to
1505280	1510280	and from. So because I'm an immutability oriented language, I'm very happy with Java's definition of a string being an immutable
1515280	1520280	thing. So closure strings are Java strings. Yes. Is there any way to work for a cent on the line you do this? In other words,
1520280	1525280	to say there's a total of 1.234, or unless you know the center meter or something like that, you don't show, you don't know.
1531280	1536280	No. Try Frank. Have you ever seen it? No. Oh, you will love it. You can add all kinds of units and figure out how many, you
1541280	1546280	know, balloons of, you know, hydrogen it would take to move a camel across this much distance. It's amazing. Units for
1550280	1555280	absolutely everything. Old, ancient Egyptian unit, it's really, it's fantastic. The guys are just a fanatic about precision,
1559280	1564280	making sure you don't lose anything, but you can arbitrarily multiply all kinds of units. Everything is preserved. Everything works
1565280	1570280	correctly. Fantastic. Frank. Frank, F-R-I-N-K. But no. Frank? Frank is a language for the JVM. It's its own language, but it's a lot of
1581280	1588280	fun. I've seen the guy talking. He just, he has some great examples. You know, some involve how many belches it would take to, you
1589280	1595280	know, move a hot air balloon to the moon and things like that. Okay, so we have string literals and double quotes. We have
1596280	1601280	characters that are preceded by a slash, backslash. So that's a character literal, and that's a big C character, a
1602280	1607280	Java character. Now we're going to get to two things that are possibly a little bit different, because they're not first class
1610280	1615280	things in Java. One would be symbols, which are identifiers. They can't contain any spaces. They have no
1619280	1625280	adornments. Symbols are used as identifiers primarily in code, but they can be used for other things as well. They're
1626280	1631280	first class objects like strings. If you have one of these things, you can look at it, and it will be a symbol, closure
1634280	1640280	laying symbol. Fred and Ethel are two symbols. That's correct. The other thing, closure has our keywords, which are
1644280	1649280	very similar to symbols, except they always designate themselves. So they're not subject to evaluation or mapping to
1650280	1655280	values by the compiler, like symbols are. So symbol might be something you would use for a variable. You could make Fred be
1660280	1665280	equivalent to five. You could never make colon Fred be equal to five. Colon Fred will always mean itself. So when it gets
1669280	1674280	evaluated, the value of the keyword Fred is the keyword Fred. It's sort of an identity thing. And they're extremely useful.
1679280	1684280	They're very useful in particular as keys and maps because they're very fast for comparison, and they print as themselves
1688280	1693280	and read as themselves. That will make a little bit more sense in a minute. There are booleans. This is different from
1696280	1701280	Lisp, although there is still null as false, nil as false. But in addition, there are proper true and false, mostly for the
1702280	1707280	purposes of interoperability. It ends up that you can't solve the nil becoming false problem. At least I couldn't. So there are
1715280	1720280	true and false, and there for use in interoperability with Java, you can use them in your closure programs as
1720280	1726280	well. But conditional evaluation in closure looks for two things. It looks for false or nil, which is the next thing I
1727280	1732280	want to talk about. Nil means nothing. It also is the same thing in closure as Java null. Didn't have to be, but it is. So you can
1742280	1747280	rely on that. So nil means nothing, and it's the same value as Java null. So when you get back nulls from Java, they're
1748280	1753280	going to say nil. Nil is a traditional Lisp word. But I like it because also traditionally in Lisp, if you can say if nil,
1762280	1767280	it will evaluate to the else branch, because nil is false. Nil is not true. So that's another literal thing, that nil. There are
1767280	1772280	some other things. There are regex literals. So if the reader reads that, it's just a string regex, exactly the same syntax as
1783280	1789280	Java's, preceded by hash, will turn into a compiled pattern. So at read time, you can get compiled patterns, which you can then
1790280	1795280	incorporate in macros and things like that, which is very powerful. And shows how that delineation between compilation and runtime is a
1802280	1807280	little bit fungible. Correct. And there's a good reason for that. And the reason is empty list is no longer as special as it was once you
1808280	1813280	have empty vector and empty map. However, the sequencing primitives, the functions that manipulate sequences return nil when they're
1826280	1831280	done, not the empty list. So that aspect of being able to test for the end of iteration with if is still there. So closure sits in a
1832280	1837280	unique point. He's asking about aspects of closure that differ a little bit from common list and scheme. There's like a long standing fight between
1844280	1849280	what should the difference between false, nil and the empty list be? Should they be unified? They are in common list. Should there be some
1853280	1858280	differences? There are some differences in scheme. Closure actually does some of both. There is false. However, there are some
1862280	1867280	differences. However, nil is still testable in a conditional. It does not unify nil and the empty list, which is a difference from common
1870280	1875280	list. However, all of the sequencing or list operations, when they're done, return nil, not the empty list, which is an important thing for
1879280	1884280	common list like idioms, where you want to keep going until it says false, as opposed to having to test for empty explicitly, which you
1885280	1890280	would have to do in scheme. Does anybody know scheme here? But you know both, so you know what I'm talking about. For everyone
1895280	1900280	else, I wouldn't worry too much about that because you wouldn't have presumed nil would have been the empty list, right?
1900280	1907280	Probably not. Okay, so those are the atomic things. They can't be divided, right? That's what atomic means. You can't, a number is in a
1914280	1921280	single thing. But there are composite or aggregate data structures. Enclosure and they're kind of the core abstractions of computer
1926280	1933280	science. One is the list. And in this case, I mean very specifically, the singly linked list. And even more specifically, the singly
1934280	1941280	linked list in which things get added at the front. So when you add to a list, you're adding at the front. The list is a chain of things, which
1948280	1954280	means that finding the nth element is a linear time cost, right? It's going to take n steps to do that. On the other hand, taking
1955280	1962280	stuff on and off the front is constant time, because that's the nature of a singly linked list. So it has all the promises, all the
1966280	1972280	performance promises of a singly linked list with stuff at the front. And it's literal representation is stuff inside
1974280	1980280	parentheses separated by spaces. There's no need for commas. You'll see some commas. Commas are white space enclosures.
1984280	1989280	They're completely ignored. You can put them in if it makes you feel better or makes things somewhat more readable, but they're
1990280	1999280	not actually syntaxed or not considered by the evaluator. So any questions about lists? Stuff in parentheses?
1999280	2001280	Stuff in parentheses?
2010280	2018280	Right. Well, these commas, the ones between 12345 and Fred Atollusi are actually English commas. But there are some commas.
2019280	2024280	For instance, when we get down to maps here, you see commas inside the data structure. Those are ignored. Those are white space.
2030280	2045280	I don't support any commas inside numbers. The printed representations of numbers enclosures are those of Java.
2046280	2055280	In lists? No, in lists, they grow at the front. Cons A onto something makes A the first thing in that list. And that's true of
2055280	2062280	closure, too. Yes? Absolutely not. All of these data structures are unique to closure. I'm only giving you some very high-level descriptions of their
2062280	2068280	representation and their performance characteristics, but we're going to talk about that in a little bit later on.
2068280	2081280	Is it based on the retail structure of lists? Absolutely not. All of these data structures are unique to closure. I'm only giving you some very high-level descriptions of their representation and their performance characteristics, but what we're going to find out later is all of these things, in particular, I'm talking about adding to lists. All of these data structures are immutable. And they're persistent, which is another characteristic. I will explain that in a little bit later on.
2099280	2114280	These are very different beasts, and they have excellent performance, yet they're immutable, and it's sort of the secret sauce of closure. Without these, you can't do what I do in the language.
2114280	2121280	That's correct. Again, how this gets interpreted, we're going to talk about it in a little bit. Right now, what you're looking at is a list of three symbols. You may end up within your program, a data structure that's a list of three symbols. You may pass this to the evaluator and say,
2144280	2157280	evaluate this, in which case it's going to try to interpret, it's going to try to evaluate each of those symbols and find out its value and treat the first one as if it was a function. But we're not there yet.
2157280	2173280	So that is a list of three symbols. The list at the end is a list of one symbol and three numbers. So heterogeneous collections are supported. In all cases, I didn't necessarily show them everywhere, but they are.
2173280	2194280	It's not a list of something. It's a list. It can contain anything and any mix of things. Okay, with lists, the next thing is a vector uses square brackets. That should imply I would hope for Java programmers and people from that domain array, right? Square brackets mean arrays.
2195280	2216280	Well, they do now. So a vector is like an array. In particular, it supports efficient indexed access. It's an expectation you would have of a vector you wouldn't have of a linked list. That getting at the 50th guy is fast. It's not going to be 50 steps to do that.
2217280	2233280	And the closure vectors meet that performance expectation. Fast indexing. In addition, it's a little bit like Java util vector or array list in that it supports growing and in this case, at the end.
2233280	2243280	And that also is efficient, as efficient as your expectation would be of a ray list. That's a constant time operation to put things at the end.
2244280	2251280	Similarly, it can hold anything. The first is a vector of five numbers. The second is a vector of three symbols.
2251280	2267280	All the collections can be heterogeneous. Okay, so far. So that's going to behave like an array in terms of being able to find the element quickly.
2267280	2282280	And finally, as a core data structure, we have maps. And a map is like, well, it's like a Java map or any kind of associative data structure in providing a relationship between a key and a value.
2282280	2298280	Each key occurring only once and having a mapping to a value. So the way they're represented is in curly braces. And they're represented simply as key, value, key, value, key, value.
2298280	2313280	Again, the commas don't matter. So they're whitespace. They get eliminated. For instance, in the second map you see there, that's a map of the number one to the string ethyl and the number two to the string fred.
2313280	2324280	You don't need the commas. And the expectation with the map is that it provides fast access to the value at a particular key.
2324280	2343280	There are usually two kinds of maps you would encounter in ordinary programming languages. One would be sorted. Some sort of sorted map, in which case the access is going to be typically log n to find a particular guy, depending on how many things are in the map.
2343280	2358280	Because they use trees or red, black trees and things like that. And closure does have sorted maps. The one you get from the literal representation like this is a hash map. And the expectation of a hash map is constant or near constant time lookup of values at keys.
2358280	2369280	And that maps to hash tables. So what you have in the closure literal maps is the equivalent of a hash table. It's fast.
2369280	2371280	Okay, so far?
2371280	2377280	I think if I introduce another key, another key in this.
2377280	2378280	Another key?
2378280	2380280	A, A.
2380280	2382280	It will be replaced. Do you want to?
2382280	2384280	The last number replaced.
2384280	2389280	Correct. There are only one instance of a key in a map. Is that your question?
2389280	2390280	Yes.
2390280	2393280	Yes, so if you were to say, the function that...
2393280	2396280	No, I'm saying if I type it out like this.
2396280	2397280	Yes?
2397280	2403280	With the comma and up the cv with a again. Is it an error or is it just a replacement?
2403280	2413280	It's probably a replacement. I say in the same thing, yes. I don't think it's an error. That's a good question. I might type it in later for you.
2413280	2417280	Okay.
2418280	2423280	Yeah, I mean...
2423280	2428280	It's the same thing.
2428280	2435280	Well, but there's no associated values. So Fred will be there. So let's talk about sets. The fourth thing I'm showing you here is sets.
2435280	2444280	Sets are a set of unique values. Each value occurs only once in the set. And really the only thing the set can do for you is to tell you whether or not something's in it.
2444280	2449280	There's no associated values. Just does the set contain this key? Do you have a question?
2449280	2450280	Yes.
2456280	2466280	There are sorted sets and hash sets. Same thing as with the maps. The sets here are hash sets. So no, the order is not retained.
2466280	2471280	You can request a sorted set and the order will be the sort order.
2471280	2476280	Does that answer your question? Okay.
2476280	2479280	What is the test for equality?
2479280	2492280	What is the test for equality? Equal. The equal sign is the test for equality. And equality means the same thing for everything in closure. It means equal value.
2493280	2503280	You'll see that closure definitely de-emphasizes identity and completely. In fact, there is an identity function and I have yet to use it.
2503280	2517280	Closure is about values. Identical contents are identical from by equals. That's made faster than you might imagine by caching hash values.
2518280	2521280	But equality is equality of value in closure.
2521280	2525280	And this immutability helps?
2525280	2535280	Immutability helps certainly. Well, if you've ever read Henry Baker's paper on EGAL, closure implements EGAL. Finally.
2535280	2540280	If you haven't, don't worry about it.
2540280	2543280	So yes, equality is equality of value.
2543280	2548280	All right. Yes. Hi, Rob.
2548280	2555280	If you were going to Java, you would need an active Java?
2555280	2562280	No, you can make arrays and you can interact with Java arrays that are arrays of either objects or native arrays.
2562280	2567280	You can say float array and size and you'll get an array of floats.
2567280	2574280	So you have the ability to do Java stuff. I'm going to emphasize the closure data structures because they let you do what closure lets you do.
2574280	2581280	You can access Java, but if you start accessing mutable things, some of the things closure can do for you, we can't do.
2581280	2584280	It doesn't mean you're not allowed to do them.
2584280	2589280	But there's no point in me showing you how to interact with the Java, right? Except to show you the syntax, which I might later.
2589280	2595280	So the last point about this is that everything nests. A key in a map can be another map. It can be a vector.
2595280	2604280	Anything can be a key or a value. Because of this equality semantics, there's no problem having a vector or a map whose keys are vectors.
2604280	2612280	That's perfectly fine. So if you needed to use tuples as keys, you know, pairs of things as keys, that's just completely doable.
2612280	2624280	Well, you can get the hash of a vector.
2638280	2640280	Correct? Right.
2643280	2652280	Well, it depends on what you're doing. I would imagine that really complex structures are not frequently used as keys, but they could be.
2652280	2664280	Can that be helped? Yes. The fact that these are hash by default means that once and once only the hash value of some aggregate structure will be calculated.
2664280	2672280	And that will be cached. So there's a quick hash test. Otherwise, we do the deep value check.
2672280	2685280	But again, I don't think you're going to encounter complex data structures as hash values that often, but using kind of small things like tuples or other small maps as keys is tremendously useful.
2685280	2690280	It's really, really handy to not even have to think about that.
2690280	2700280	I think we got one other closure program arrived. Who can possibly attest, independent of me, how closure's performance is? How's closure's performance?
2700280	2707280	Fine to me, but I've actually been showing all of this.
2707280	2715280	Right. Well, now there's some extra numeric goodness in there. But these data structures are pretty good. What's the reality?
2715280	2724280	The reality of these data structures is I've tried to keep them all within one to four times a Java data structure, the equivalent Java data structure.
2724280	2732280	In other words, hash map, vector. Well, similar lists are pretty straightforward.
2732280	2740280	So they're within striking distance. The B side is in a concurrent program, there is no locking necessary for use with these data structures.
2740280	2747280	If you want to make an incremental change through data structure in a certain context, there's no copying required to do that.
2747280	2752280	So some of these other costs that would be very high with immutable data structure vanish.
2752280	2755280	So you have to be very careful in looking at that.
2755280	2763280	The other thing that's astounding to me, at least, is that the lookup time, again, the add times are higher than hash map.
2763280	2773280	But the lookup times can be much better because this has better hash cash locality than a big array for hash table.
2773280	2783280	Okay, we're all good on this. I probably have to move a little bit quicker. Yes, more quickly.
2783280	2789280	There is destructuring. Yes, I actually won't get to talk about that today, but there is destructuring.
2789280	2796280	There is not pattern matching. Okay, but there is destructuring to arbitrary depth of all of these.
2796280	2804280	Destructuring means a way to easily say, I want to make this set of symbols that I express in a similar data structure,
2804280	2808280	map to corresponding parts of a complex data structure on past.
2808280	2814280	Clojure has that. It has some really neat destructuring capabilities.
2814280	2820280	All right, so what's the syntax of closure? We just did it.
2820280	2830280	I'm not going to talk about semicolons, curly braces, you know, when you have to say this, when you have to have a new line, or anything else.
2830280	2839280	Because the structure of a closure program is a data structure or a series of data structures.
2839280	2847280	There is no other stuff. There are no rules about where things go. There are no precedence rules. There's nothing else.
2847280	2854280	You write a closure program by writing the data structures I just showed you. That's it.
2854280	2860280	I'll show you.
2860280	2866280	So you write a program by writing data structures. The data structures are the code.
2866280	2873280	That has huge implications. It's, you know, it is the nature of LISP.
2873280	2878280	There's a fancy name for it called Homo Iconicity.
2878280	2885280	And it means that the representation of the program is done in the core data structures of the program.
2885280	2896280	Which means that programs are amenable to processing by other programs because they're data structures.
2896280	2901280	So I'm not going to talk anymore about text-based syntax because there is no more.
2901280	2906280	Now, many people claim of LISPs, well, LISPs has no syntax. And that's not really true.
2906280	2910280	It doesn't have all this little fiddly character syntax necessarily.
2910280	2915280	There is syntax to the interpretation of the data structures.
2915280	2920280	You know, in those, you're going to see a lot of lists. They have different things at the front.
2920280	2926280	The thing at the front will tell you the meaning of the rest.
2926280	2931280	All right. So let's talk a little bit about evaluations. How does this all work?
2931280	2936280	This is, we should all know, from Java or many other languages like Java.
2936280	2941280	It types our program into a text file and we save it.
2941280	2951280	And then we send those characters of that text to the compiler who has a very involved, you know, abstract syntax tree
2951280	2955280	and parser and lexer that interpret the rules of the language.
2955280	2958280	This is what constitutes a character. This is what constitutes a number.
2958280	2965280	And then furthermore, you know, if you've said if and you put parens and then you said some stuff and you put a semicolon
2966280	2969280	and you're still in this construct called if, things like that.
2969280	2972280	It knows all about that and it deals with the text.
2972280	2977280	And it will tell you if you've met the requirements in terms of it being a valid program.
2977280	2980280	And then it will turn it into something that can run.
2980280	2982280	In the case of Java, that something will be bytecode.
2982280	2985280	And it will go into a class file or a draw file. We know this.
2985280	2989280	And then there's a separate step, which is called running.
2989280	2994280	We take that stored executable representation and we ask it to happen.
2994280	3001280	Usually, in this case, we'll say, you know, Java dash something, class file, and it will run.
3001280	3005280	And it will run and then it will end and it will be over.
3005280	3009280	And we could try again if we didn't like it.
3009280	3013280	That's the traditional edit compile run.
3013280	3016280	Be disappointed, start over.
3017280	3022280	Oh, correct.
3022280	3025280	I'm talking about the development process.
3025280	3029280	But yes, the runtime is just that long.
3034280	3041280	Until you realize it's not working and you have to ask everybody to please wait for our downage while we fix it.
3041280	3044280	That's the difference.
3044280	3053280	If you read about Erlang, which is getting a lot of press, they'll tell you about phone switches and how that's really not allowed.
3053280	3060280	And Lisp was doing this for a very long time, this kind of live hot swapping of code and running systems.
3060280	3067280	I think it goes more, in this case, it's less about the production thing than it is about what's the nature of developing a program.
3067280	3072280	Because as a developer, you know, seeing it run and saying, ooh, that was bad.
3072280	3073280	I wonder what happened.
3073280	3075280	I wish I had run it in debug mode.
3075280	3078280	I wish I had put a breakpoint somewhere interesting.
3078280	3086280	And I'm really sad that I spent an hour calculating that data and dropped it on the floor because I have to do it again with the breakpoint in.
3086280	3096280	That's a lot different experience than keeping your program around and having that data stay loaded and fixing your function and running it again without starting over.
3096280	3099280	So that's what happens in closure.
3099280	3102280	You take the code, text could be characters.
3102280	3108280	There is character representation and what you showed there can be represented in characters in ASCII.
3108280	3111280	It does not go first to the evaluator.
3111280	3113280	It goes to something called the reader.
3113280	3120280	And this is the core part of what makes something a Lisp, which is that the reader has a very simple job.
3120280	3122280	Its job is to take the description.
3122280	3130280	I just told you, you know, keyword starts with a colon and a list is in parentheses and a map is in curly braces and it's pairs of stuff.
3130280	3134280	Its job is to take those characters and turn it into data structures.
3134280	3142280	The data structures I described, you start with the parent, you say stuff, you close the parent, that's going to become a list when the reader is done with it.
3142280	3145280	You start with square brackets, that's going to become a vector when the reader is done with it.
3145280	3148280	So what comes out of the reader are data structures.
3148280	3155280	And what's unique about a Lisp enclosure is that the compiler compiles data structures.
3155280	3157280	It does not compile text.
3157280	3160280	It never sees text.
3160280	3168280	What the compiler gets handed is maybe a list with three symbols in it or a vector with five numbers in it.
3168280	3170280	That's actually what the compiler has.
3170280	3176280	It has a data structure in hand with actual data in it, not text.
3176280	3180280	And it compiles it and in the case of closure, it is a compiler.
3180280	3187280	There are many, well, there are actually many lists that are interpreters, but many people believe that Lisp is interpreted.
3187280	3196280	It's certainly easy to make an interpreter for Lisp that would take those data structures and on the fly produce the values they imply.
3197280	3206280	But closure is a compiler and in particular closure compiles those data structures to Java bytecode right away.
3206280	3209280	There is no interpretation in closure.
3209280	3215280	So it's a compiler that produces bytecode just like Java C does.
3215280	3224280	And because it's an interactive environment, it presents that bytecode right away to the JVM to execute.
3224280	3228280	And it executes right away and you can see the effect.
3232280	3235280	When you're in the REPL, you have AVM, right?
3235280	3237280	You have one thing.
3237280	3240280	So yes, your environment is your program.
3240280	3243280	Your compiler is in your program.
3243280	3245280	Yes.
3246280	3257280	Yeah, most commercial lists give you tools to take out the compiler in production, mostly because they don't want you giving away their compiler.
3257280	3264280	Normally, there's no reason to prevent that because it's a useful thing to have, particularly when you want to load code later to fix problems.
3264280	3266280	You're going to need that compiler there.
3266280	3269280	So in closure, there's no strip out the compiler option.
3270280	3279280	We'll see that there is a core of closure.
3279280	3282280	The data structures are written in Java.
3282280	3285280	The special operators are written in Java.
3285280	3289280	And then most of the rest of closure is written in closure.
3289280	3291280	There's no native code.
3291280	3293280	There's no native code.
3293280	3296280	Closure is completely a pure Java project.
3297280	3298280	There's no native code.
3298280	3299280	There's no C libraries.
3299280	3306280	It's all Java, either generated by Java itself or generated by closure.
3306280	3312280	It does not turn off the verifier or anything like that in order to get performances.
3312280	3314280	There have been some schemes that tried to do that.
3314280	3316280	Closure is completely legit that way.
3316280	3322280	So when we have this separation of concerns between the reader and the evaluator, we get a couple of things.
3322280	3327280	One of the other things we get is we don't have to get the text from a file, right?
3327280	3329280	We can get it right from you.
3329280	3332280	You just saw me type right into the REPL, an expression.
3332280	3335280	Never went through a file, never got stored.
3335280	3340280	So the first thing you get is this kind of interactivity of you can just type in stuff and say go.
3340280	3341280	That's a big deal.
3341280	3351280	I mean, if you've been programming in Java or C++ long enough to remember when the debuggers didn't give you the ability to evaluate expressions at a break point,
3351280	3354280	you can't remember how hard that was.
3354280	3360280	You always have that capability here to have expressions directly evaluated.
3360280	3362280	What else do we get from this?
3362280	3366280	Well, we get the ability to skip the characters completely.
3366280	3377280	For instance, it's quite possible to write a program that generates the data structures that the compiler wants to see and have it send them to the compiler to be evaluated.
3377280	3383280	Program generating programs are a common thing in this kind of an environment.
3383280	3389280	Whereas this kind of stuff when you're doing it with text is really messy.
3389280	3394280	By the way, what observation does Charlie actually give a good way to make the same?
3394280	3400280	The art forms I know, because of compliance requirements that they have,
3400280	3409280	we might be very comfortable with code producing stuff going into a reader or a programmer against a programmer that produces stuff.
3409280	3421280	But is that option of saying it's always like the first in this production environment in the influence of COVID to be as a security problem?
3421280	3427280	Well, I mean, that's a security policy thing, whether or not you expose this in a production system.
3427280	3430280	So I'm talking about you could if you needed to.
3430280	3437280	You could have that over a secure soccer channel and have it be just an administrator who knows what they're doing, have that capability.
3437280	3439280	Because the alternative is downing your system.
3439280	3445280	If you don't have that, and of course, opening this in a production system, that's completely a policy thing.
3445280	3446280	It has nothing to do with the language.
3446280	3449280	Except if your language doesn't let you do it, you can't do it.
3449280	3450280	That's fair.
3450280	3452280	So it does.
3452280	3456280	The other thing is that these data structures, you might write this program and have this happen directly.
3456280	3458280	Then you might say, I like this program.
3458280	3463280	Let me take those data structures and there's a thing called the printer, which will turn them back into that,
3463280	3467280	which you could store and so they could sign off on and say this is the canonic program,
3467280	3470280	which our program generated that we're going to use.
3470280	3473280	And we'll lock that down and do whatever.
3473280	3474280	Yes?
3474280	3478280	So are the data structures physical files?
3478280	3481280	No, they're in memory data structures.
3481280	3484280	The ones your program would see.
3484280	3493280	So, you know, an instance of closure laying persistent vector to the compiler.
3493280	3497280	The compiler's got to deal with it, figure it out.
3497280	3503280	So there's one more thing that this allows, and this is the secret sauce of all lists, including closure,
3503280	3505280	which is what would happen.
3505280	3509280	I mean, it's fine to sit standalone and write a program that generates a program.
3509280	3512280	But what would happen if we said, you know what?
3512280	3515280	We're handing these data structures to the compiler.
3515280	3521280	It would be great if the compiler would let us participate in this.
3521280	3523280	If they could send us the data structures.
3523280	3530280	When we write a real program, a very small program, and give it back different data structures,
3530280	3536280	then we could participate very easily in the extension of our language.
3536280	3540280	Because this compiler, it's going to know how to do with those types of data.
3540280	3542280	It's going to know what to do with the vector.
3542280	3546280	It's going to know what if means and a couple of other things.
3546280	3550280	But there'll be new things that we'll think of that we'd love to be able to set.
3550280	3556280	When you have something you'd love to be able to say in Java, what do you have to do with it?
3556280	3563280	You have to beg, son, and wait for years and hope other people beg for the same things and you get it.
3563280	3565280	That's it.
3565280	3567280	You have no say.
3567280	3575280	You have no ability to shape the language unless that's completely not what it's about.
3575280	3577280	It's about getting you in the loop.
3577280	3582280	And in fact, the language itself has a well-defined way for you to say,
3582280	3585280	this is a little program I'd like you to run.
3585280	3590280	When you encounter this name, I don't want you to evaluate it by the way.
3590280	3592280	I'd like you to send me that data structure.
3592280	3594280	I know what to do with it.
3594280	3599280	I'm going to give you back a different data structure and you evaluate that.
3599280	3601280	That's called a macro.
3601280	3610280	And it is what gives lists and closure syntactic abstraction and syntactic extensibility.
3610280	3613280	Can that happen in the context of the namespace?
3613280	3615280	Yes, it can.
3615280	3623280	There are namespaces in enclosure and they allow me to have my cool function and you to have your cool function.
3623280	3625280	Cool function.
3625280	3627280	Yes.
3627280	3632280	So that's what makes Lisp amazing.
3632280	3636280	It's something that I won't have time to dig deeply into tonight.
3636280	3641280	If you can come away with at least the understanding that that's how it works, that's how it's possible.
3641280	3645280	And the fact that these are data structures here makes it easy.
3645280	3650280	You could theoretically say, oh, I could write something and if the compiler could hand me the abstract syntax tree,
3650280	3653280	I could navigate it with some custom API and do whatever.
3653280	3658280	It's not nearly the same, though, when what the compiler is handing you are those three data structures.
3658280	3668280	I just showed you that every program knows how to manipulate and has a wildly huge library that directly can manipulate.
3668280	3670280	So that's how Lisp works.
3670280	3673280	I'm going to try to speed it up a little bit.
3673280	3677280	In closure, unlike Java, everything is an expression.
3677280	3682280	So you know in Java there's a difference between declarations and statements and expressions.
3682280	3684280	There's no distinction in closure.
3684280	3686280	Everything is an expression.
3686280	3687280	Everything has value.
3687280	3689280	Everything gets evaluated and produces a value.
3689280	3695280	Sometimes that value is nil, not particularly meaningful, but everything is an expression.
3695280	3702280	So the job of the compiler is to look at the data structures and evaluate them.
3702280	3705280	There's a really simple rule for that.
3705280	3709280	It's slightly oversimplified, but in general you can understand it this way.
3709280	3719280	All those data literals I showed you, right, symbols, numbers, character literals, vectors, maps, sets,
3719280	3731280	are all evaluated by the compiler to represent themselves, except lists and symbols.
3731280	3735280	Lists and symbols by default are treated specially by the evaluator.
3735280	3740280	So when it reads a list of symbols in particular, it's going to do some work.
3740280	3743280	It's not just going to return the list of symbols to your program.
3743280	3749280	It's going to try to understand them as an operation, which I'll show you in a second.
3749280	3758280	So symbols are going to try to, the compiler is going to try to map to values, like variables.
3758280	3761280	You know in a variable you can say int i equals five.
3761280	3764280	Later in your program in Java you say i.
3764280	3767280	Java is going to try to figure out, oh, that's five.
3767280	3769280	That's the i you set up there.
3769280	3770280	Same thing in closure.
3770280	3776280	When you use a symbol in your data structure, closure is going to try to find a value that's been associated with that symbol.
3776280	3782280	It can be associated with it through a construct called let, sort of the way you create a local name,
3782280	3787280	or through def, which is the way you create a global name.
3787280	3791280	So before it's a list, and it's going to say this is an operation of some sort.
3791280	3795280	I have to figure out what to do with a list.
3795280	3797280	So how does that work?
3797280	3799280	Well, again, we said what's the data structure?
3799280	3804280	It's friends, it starts with something, it may have more stuff or not.
3804280	3809280	But from the evaluator standpoint, all that matters is the first thing.
3809280	3813280	The first thing is the operator, or op.
3813280	3816280	That's going to determine what to do.
3816280	3818280	And it can be one of three things.
3818280	3821280	It can be a special op.
3821280	3822280	This is magic.
3822280	3827280	This is the stuff that's built into the compiler upon which everything else is bootstrapped.
3827280	3829280	So some things are special.
3829280	3832280	I'm going to enumerate them in a second.
3832280	3834280	It can be a macro like we saw before.
3834280	3841280	There's a way to register with the compiler to say, when you see the op, my cool thing,
3841280	3845280	go over here and run this function, which is going to give you something to use
3845280	3848280	in place of the my cool thing call.
3848280	3852280	And the third thing it could be is an ordinary expression.
3852280	3856280	It's going to use the normal means of evaluating an expression.
3856280	3860280	And it's going to say whatever value that yields on a treat as a function
3860280	3864280	and attempt to call with the calling mechanism of closure,
3864280	3870280	which is not limited to functions, but it's main purposes for functions.
3871280	3876280	So for people who know lists, closure is a list one.
3876280	3880280	It is a list one that supports def macro well.
3880280	3887280	And the use of namespaces and the way back quote works makes that possible.
3887280	3889280	And everyone else can ignore that.
3889280	3892280	In a way, back legs pull the bunch.
3892280	3897280	An expression in the genome is a function as opposed to it's the function.
3897280	3901280	Well, what it's going to encounter is it's going to encounter a list
3901280	3903280	and the first thing is going to be the symbol Fred.
3903280	3907280	Fred is not a special operator, no Fred enclosure.
3907280	3911280	Let's say no one has registered a macro called Fred.
3911280	3913280	Then it's going to use the rules we said before.
3913280	3917280	What about symbols to find the value of Fred?
3917280	3921280	Where hopefully someone before has said, Fred is this function.
3922280	3926280	It will keep evaluating.
3926280	3928280	It's going to evaluate that expression.
3928280	3933280	But there are other function like things or callable things in closure
3933280	3934280	in addition to functions.
3934280	3936280	I'll show you that in a second.
3936280	3938280	So let's dig down into each of these three pieces.
3938280	3939280	Yes.
3939280	3941280	It doesn't encounter any one of those three.
3941280	3945280	You have an error at runtime.
3945280	3947280	It'll say it's not a function.
3947280	3949280	Effectively what will happen is it will say this is not a function.
3949280	3954280	If you said Fred is deaf Fred one, so Fred is the number one
3954280	3957280	and you've tried to call Fred or use Fred as an operator,
3957280	3959280	it's going to say one is not a function.
3959280	3965280	Probably with a not very illuminating stack trace.
3969280	3971280	Okay, so special operators.
3971280	3972280	There are very few.
3972280	3974280	I think one of the things that's really cool about lists
3974280	3978280	and it's also cool about closure is you can define most of them
3978280	3980280	in terms of themselves.
3980280	3983280	One of the great brilliant things that John McCarthy did
3983280	3988280	when he invented lists was figure out that with only I think seven primitives,
3988280	3992280	you could define the evaluator for those seven primitives
3992280	3994280	and everything you could build on them.
3994280	3997280	Like the core of computation.
3997280	4000280	It still gives me goosebumps when I say that.
4000280	4003280	It is a beautiful thing.
4003280	4004280	It really is.
4004280	4008280	And if you've never looked at the lambda calculus or at least from that perspective,
4008280	4010280	it's quite stunning.
4010280	4017280	These early papers are just great and they're just brilliant in a transparent way.
4017280	4018280	So let's look at a couple.
4018280	4021280	I'm going to show you two and then I'm going to list the rest.
4021280	4022280	Deaf would be one.
4022280	4026280	How do we establish a value for a name?
4026280	4029280	There's this special operator called deaf.
4029280	4030280	It takes a name.
4030280	4033280	Now that name is going to be a symbol.
4033280	4038280	Obviously, that can't be evaluated, right?
4038280	4042280	Because the whole purpose of this special operator is to give it a value.
4042280	4046280	If the compiler were to use normal evaluation, the name position,
4046280	4050280	you'd have a problem because you're trying to define what it means.
4050280	4051280	How could you do that?
4051280	4055280	So one of the things about special operators that you have to remember,
4055280	4062280	and it's true of macros as well, is they can have non-normal evaluation of their arguments.
4062280	4064280	Like, the arguments might not be evaluated.
4064280	4067280	In fact, deaf doesn't evaluate the name.
4067280	4072280	It uses it as a symbol and it associates that symbol with the value.
4072280	4075280	It does not evaluate the symbol.
4075280	4080280	So this is a simple way to say, if I say deaf name, some expression,
4080280	4084280	the expression will be evaluated, the name will be mapped to that value
4084280	4086280	or bound to that value.
4086280	4089280	When you later go and say name, you'll get the value.
4089280	4091280	It was used to initialize it.
4092280	4097280	You actually can do that more than once.
4097280	4101280	You shouldn't do that more than once unless you're trying to fix something.
4101280	4104280	In other words, deaf should not be used as set.
4104280	4109280	But you can use deaf to define a function and later you can use it again to fix it.
4109280	4113280	So the things that are defined by deaf are mutable at the root
4113280	4121280	and it's probably, you know, it's the only escape hatch for that dynamic change enclosure.
4121280	4127280	That's not governed by transactions or some other mechanism.
4127280	4130280	Okay, so it establishes a global variable.
4130280	4131280	Again, there are namespaces.
4131280	4134280	I don't have the time to talk about them, but it's all subject to a namespace.
4134280	4137280	If you're in a namespace and you define the name, then it's in your namespace.
4137280	4139280	It's distinct from that same name in another namespace.
4139280	4142280	Namespaces are not the same as packages in CommonList.
4142280	4144280	They're very much different in particular.
4144280	4147280	Symbols are not inherently in a namespace.
4147280	4151280	Symbols have no value, sell, they're not places.
4151280	4153280	They're just labels.
4153280	4158280	And there are vars, which are the places more like CommonList symbols.
4160280	4162280	If is another thing that's built in.
4162280	4167280	And if you think about if in your language, which you may not have ever done.
4167280	4171280	If you thought about if is, why couldn't if be a function?
4171280	4177280	Why can't I say if some test expression, some expression, some else expression?
4177280	4179280	Why can't if be a function?
4179280	4180280	I mean, it looks like a function.
4180280	4185280	Well, it doesn't actually look like a function in Java, but why can't it be a function?
4185280	4195280	It should only evaluate one of these two.
4196280	4197280	That's why.
4197280	4199280	And a function evaluates what?
4199280	4201280	All of its arguments.
4201280	4207280	So if you try to write if as a function, you would have a problem because functions evaluate all their arguments.
4207280	4211280	So if has to be special, and if is special in closure too.
4211280	4213280	It evaluates the test expression.
4213280	4219280	And then, depending on the truth or falsity of this in kind of a generic sense,
4219280	4226280	in closure, if this is nil or false, it will evaluate that.
4226280	4229280	If it's anything else, it will evaluate this.
4229280	4233280	But it will only evaluate one of those two things.
4233280	4235280	It must have a false.
4235280	4237280	No, it doesn't have to.
4237280	4241280	The else can be missing in which case it defaults to nil.
4241280	4245280	So if is another example of something that has to be special.
4245280	4247280	It can't evaluate all of its arguments.
4247280	4251280	And then we have these others.
4251280	4253280	In fact, this is it.
4253280	4256280	There's something that defines a function.
4256280	4261280	Something that establishes names in a local scope.
4261280	4266280	A pair of things that allow you to do functional looping.
4266280	4268280	To create a loop in your program.
4268280	4273280	Something that lets you create a block of statements the last of which will be the value.
4273280	4276280	It allocates a new Java thing.
4276280	4279280	Access to members of Java thing.
4279280	4284280	Throw, try, do what you expect from Java.
4284280	4288280	Set, will rebind a value.
4288280	4292280	And code bar are kind of a special purpose for list manipulation things.
4292280	4294280	So I'm not going to get into them tonight.
4294280	4295280	Question.
4295280	4297280	Is that the entire list of?
4297280	4298280	Yeah.
4298280	4300280	So what's the equivalent of death macro?
4300280	4305280	Death macro is bootstrapped on this.
4305280	4309280	So there's a key border.
4309280	4311280	Oh no, there is death macro.
4311280	4316280	It's defined a couple of pages into the boot script for closure, which I might show you.
4316280	4318280	We have some time.
4318280	4319280	Yes.
4319280	4320280	I'm just intrigued.
4320280	4324280	The reason for the explanation point of the set is it trying to say something to the program?
4324280	4326280	Yeah, this is bad.
4326280	4327280	Why are you doing this for?
4328280	4332280	Yes.
4336280	4338280	No, it ends up that enclosure.
4338280	4341280	Macros are functions.
4341280	4352280	And so there's just a way to say this function is a macro and it will be treated as a macro instead of as a function.
4352280	4353280	Okay.
4353280	4356280	So that's a tiny set of things.
4356280	4360280	In fact, when you take out the stuff related to Java, it's an extremely tiny set.
4360280	4362280	I don't think I made it down to seven.
4362280	4367280	One, two, three, four, five, six, seven, eight.
4367280	4369280	I have more than more properties.
4369280	4372280	But I don't have dozens.
4372280	4374280	So how could this possibly work?
4374280	4378280	This is not enough to program with this.
4378280	4380280	No.
4380280	4381280	No, no, no.
4381280	4383280	So we need macros.
4383280	4384280	Okay.
4384280	4389280	There are plenty supplied with closure.
4389280	4397280	And what's beautiful about closure and LISPs is you have the same power that I have to write macros.
4397280	4404280	When you see the kinds of things that are implemented in closure as macros, you realize the kind of power you have as a developer
4404280	4406280	because you can write those same macros.
4406280	4408280	You could have written them.
4408280	4410280	You don't have to wait for me.
4410280	4412280	I'm not son.
4412280	4413280	This is not Java.
4413280	4414280	You want to do something.
4414280	4416280	You have something you want to express a certain way.
4416280	4418280	You want to extend the language that way.
4418280	4425280	If you can do it with a macro, you can do it without contacting me or asking me for the favor of adding a feature for you,
4425280	4428280	which means the language is much more extensible by programs.
4428280	4431280	So let's look a little bit about how they work.
4431280	4436280	If we remember, we're getting data structures passed in the compiler.
4436280	4441280	So it looked at the first thing, and somehow there's a way, and I can't show you that tonight,
4441280	4444280	to say this name designates a macro.
4444280	4448280	And associated with that name, then, is a function.
4448280	4453280	The function expects to be passed the rest of the stuff that's in the parentheses.
4453280	4457280	So we had this cool function, my cool macro.
4457280	4460280	Maybe it expects to be passed two things.
4460280	4462280	The things that gets passed are not evaluated.
4462280	4466280	It gets passed the data structures that the compiler got passed.
4466280	4470280	Because the compiler is going to say, you told me you know how to do this.
4470280	4472280	Here are the data structures.
4472280	4476280	Give me back the data structure I should be processing.
4476280	4483280	So it's a transformation process where the macro is handed the data that's inside the parentheses,
4483280	4486280	as arguments to the function that the macro is.
4486280	4495280	It will run any arbitrary program you want to convert that data structure into a different data structure.
4495280	4498280	You can write macros that look stuff up in databases.
4498280	4503280	That go and ask a rule-based system for advice.
4503280	4505280	Most are not that complicated.
4505280	4508280	But the thing is, it's an arbitrary program transformation.
4508280	4510280	There's not a pattern language.
4510280	4512280	There's not a set of rules about this can be turned into that.
4512280	4515280	It's an arbitrary program, a macro.
4515280	4519280	And in this way, it's like a common list macro.
4519280	4524280	That, given the data structure, gives back its own replacement.
4524280	4528280	Replace me, the expression that began with me, with this.
4528280	4530280	And then keep going.
4530280	4533280	Which may yield another macro and another round of matter.
4533280	4536280	It may yield something that already knows how to process.
4536280	4537280	Yes?
4537280	4542280	So would it be correct to say that a general macro is happening around that problem?
4542280	4545280	No, this is happening at compile time.
4545280	4547280	This is part of compilation, right?
4547280	4549280	The compiler got handed this data structure.
4549280	4552280	It said, oh, it begins with the macro name.
4552280	4553280	Hands it to the macro.
4553280	4554280	It comes back.
4554280	4555280	That transformation occurs.
4555280	4557280	It keeps compiling.
4557280	4558280	Then you get bytecode.
4558280	4561280	After you get bytecode, there's no more talking to the macro.
4561280	4564280	So macros replace themselves with another data structure.
4564280	4567280	And then compilation continues.
4567280	4569280	So we can look at a macro.
4569280	4572280	You'll notice on the list of primitives, there's no or.
4572280	4574280	Or is not primitive enclosure.
4574280	4578280	And in fact, if you think about or, or is not primitive.
4578280	4580280	Or is not a primitive logical operation.
4580280	4585280	You can build or on top of if.
4585280	4586280	Right?
4586280	4592280	The or, what I'm talking about is like the double bar or in, in Java in that what happens
4592280	4596280	if the first part tests true, what happens to the second part?
4596280	4597280	Not evaluated, right?
4597280	4600280	It's still got that magic thing, but if already knows how to do that.
4600280	4606280	If already knows how to do a conditional evaluation of only one of two choices,
4606280	4612280	which means we can define or in terms of if.
4612280	4614280	And so this is what happens.
4614280	4616280	So or is a macro.
4616280	4620280	When it's expanded by the compiler, it, it returns something like this.
4620280	4622280	I'm going to say or X or Y.
4622280	4624280	And this is what comes back.
4624280	4627280	Another data structure begins with the let, which we haven't seen so far,
4627280	4632280	that says it takes a set of pairs of things to make this mean,
4632280	4636280	mean this inside the scope of the let.
4636280	4639280	Like a local variable, except it's not variable.
4639280	4640280	You can't vary it.
4640280	4642280	But it has the same kind of scope.
4642280	4644280	So it says let's, let's do that.
4644280	4648280	And the reason why it does it is because this is going to be some expression.
4648280	4654280	It looks like X here, but it could be like a call to calculate some incredibly difficult
4654280	4656280	thing that's going to take an hour.
4656280	4659280	In which case, I finally want to repeat that more than once in my expansion,
4659280	4661280	because it would calculate that thing twice.
4661280	4665280	So we're going to take whatever that expression is, put in here,
4665280	4669280	assigns that into this variable name, which is made up because,
4669280	4671280	because obviously you didn't pick this name.
4671280	4674280	It's a good machine pick name.
4674280	4676280	So it makes a variable.
4676280	4678280	And then it says if that thing is true, right,
4678280	4680280	and you took an average calculator in this, right,
4680280	4681280	we have that idea.
4681280	4684280	If that's true, return it.
4684280	4687280	If, right, I know, isn't it going to do this?
4687280	4689280	If this is true.
4689280	4692280	Otherwise, it's going to do what?
4692280	4695280	And that's the implementation of OR.
4695280	4698280	If the first thing is true, it returns it.
4698280	4700280	Well, in fact, in Java, you don't get a good value,
4700280	4703280	but in Clojure, you get the value that was true.
4703280	4709280	Then the invocation of any function can both return a value in a true form
4709280	4711280	or you interpret certain types of values.
4711280	4715280	All values can be placed in a conditional, not just Booleans,
4715280	4717280	and it's subject to the rules I said before.
4717280	4724280	If it is nil or if it is false, you'll get the else expression evaluated.
4724280	4732280	If it is anything else, seven, the string fred, anything else is true.
4732280	4737280	So Clojure, like most LISPs, allows any expression to be evaluated
4737280	4739280	as the conditional test.
4739280	4742280	Here.
4742280	4749280	He's also getting the part that there are no spiting effects of the evacuating effects.
4749280	4752280	No, I talked about that.
4752280	4754280	Let's say this x for now.
4754280	4759280	A well-written macro will make sure it only gets evaluated once.
4759280	4764280	I could have put if x, x, y, yes?
4764280	4766280	No, this is the answer to your question.
4766280	4773280	If it said if x, x, otherwise y, then if x had side effects, it would happen twice.
4773280	4776280	Then we make this not a well-written macro.
4776280	4780280	This is a well-written macro where it needs to use that expression twice,
4780280	4785280	which means it's going to bind a temporary variable to the value,
4785280	4788280	which means x only happens if it appears only once here.
4788280	4791280	So if it had a side effect, it would happen only once.
4791280	4794280	If it took a long time, it would take a long time only once.
4794280	4797280	Simple as it is, I still have this simple question.
4797280	4805280	Let appears to take three arguments.
4805280	4811280	Let actually takes, at the top most level, it takes n arguments.
4811280	4817280	The first of which has to be a vector of pairs of things.
4817280	4819280	You can have multiple expressions.
4819280	4823280	Name, value, name, value, value in a letter.
4823280	4828280	This is one symbol there.
4828280	4833280	Let is a block, so it actually can have multiple expressions.
4833280	4836280	In this case, there's only one.
4836280	4839280	And then it just does whatever it's next.
4839280	4841280	It returns the value.
4841280	4845280	Well, this is a macro, and all it's going to do is get the compiler back this,
4845280	4848280	and the compiler has to keep going with this in hand now.
4848280	4851280	Yes, I'm just trying to figure out what led you.
4851280	4856280	Let will, led establishes this name to not this value.
4856280	4862280	Then, when led runs, the series of expressions inside led run,
4862280	4866280	and the last of them is the value of the led expression.
4866280	4871280	In this case, there's only one expression inside the led.
4871280	4873280	In this case, there's only one expression inside the led.
4873280	4877280	So the value of the if expression is the value of the led.
4877280	4880280	Which is what we want, we want this to mean or.
4880280	4882280	And that's the scope.
4882280	4884280	This is the end of the scope over here.
4884280	4887280	And this parent matches that value.
4887280	4889280	That's what I was noticing.
4889280	4893280	Yes, and well, it's one of the beautiful things about the system,
4893280	4898280	which we'll see clarified in a moment, is that all expressions are bound.
4898280	4903280	So we don't have a lot of complexity with precedents and terminators and things like that.
4903280	4909280	It started with the parent, it ends with the matching parent later.
4910280	4913280	Big Boolean?
4913280	4918280	In fact, it has to be big Boolean false.
4918280	4921280	If it's coming from Java, I test to make sure,
4921280	4927280	because an improperly constructed big Boolean may not be Boolean dot false.
4927280	4929280	New Boolean is wrong.
4929280	4932280	And in fact, not only is new Boolean wrong,
4932280	4936280	but the reflection API in Java uses it exactly that way.
4936280	4940280	So it returns multiple different values of big Boolean false.
4940280	4946280	I have a patch that looks for that because I got bit by that already.
4946280	4955280	So it will make conversions of big Boolean false that aren't Boolean dot false into Boolean dot false.
4958280	4962280	I'm sorry, I didn't write Java, I only wrote closure.
4963280	4968280	But the point here is that this seems like a primitive thing,
4968280	4971280	like if the language doesn't have it, you're in trouble.
4971280	4972280	It is not.
4972280	4976280	If I had somehow left out OR, you could have added it.
4976280	4981280	You could have written the macro that does this job and added OR to closure.
4981280	4983280	I'm sure I forgot some things in closure.
4983280	4985280	You could add them.
4985280	4986280	Many things.
4986280	4989280	In fact, we saw how tiny the special operators list is.
4989280	4997280	And OR, con, all kinds of things are built on top of these things as macros and OR functions.
4997280	5003280	And after the point of the special ops, you can add a special operator, but you can add a macro.
5004280	5007280	Now I've got more than 50,000 for the question.
5007280	5010280	So I get this, this is great.
5010280	5016280	So something to build a bunch of macros in these is that it's a powerful, another bunch of macros.
5016280	5020280	Somebody else has got this smoking advantage of this language.
5020280	5025280	People sort of come down to the industry for developers and the industry for locals in.
5025280	5029280	There's a one-time error and I get a stack trace of it going in.
5030280	5035280	You're going to get a reference to the expansion, the inside of the expansion.
5043280	5045280	That can be challenging.
5054280	5056280	It's still an area.
5060280	5069280	I think that one of the things that's good about a list is because you have the ability to work in the small
5069280	5072280	and to say, I just wrote this little component of this thing.
5072280	5074280	I'm going to run this right now.
5074280	5078280	I don't have to wait till the big program that contains this runs.
5078280	5086280	Your ability to do that immediate unit test to make sure that thing is working is good.
5087280	5096280	On the 50,000 foot level, propagating up from macros the source of the problem in the macro is something
5096280	5097280	that's being worked on.
5097280	5100280	Some compilers do it pretty well for common list.
5100280	5104280	It's an area I hope to enhance in closure.
5104280	5109280	But it will always be more challenging than a function.
5109280	5117280	And that's why macro writing is not for newcomers or the inexperienced part of the team.
5119280	5121280	It is language design.
5121280	5123280	It definitely is.
5123280	5129280	On the other hand, without it, you're limited to the abstraction capabilities of functions, which are limited.
5129280	5131280	Think about how much you repeat in Java.
5131280	5135280	Think about how much code you repeat to close files in Java.
5135280	5136280	Think about it.
5136280	5138280	Think about how many times you've written the exact same thing.
5138280	5142280	Having your IDE spit it out is a little bit handier.
5142280	5144280	But when you decide, oh, I need to change my policy about doing this.
5144280	5146280	I want to check something else.
5146280	5150280	All that generated code is not amenable to fixing.
5150280	5154280	So those kinds of things that can't be...
5154280	5159280	whose redundancy can't be eliminated by functions can be eliminated by macros.
5159280	5161280	And that's something you want to do.
5161280	5167280	Because the B side of this is, if you're doing all that stuff by hand, yes, it's transparent.
5167280	5168280	You get this debugger error.
5168280	5170280	Okay, you did that by hand.
5170280	5172280	Where?
5172280	5174280	All over your program.
5174280	5176280	Because you didn't have a macro that generated it.
5176280	5178280	You don't have one place to fix.
5178280	5180280	You have n places to fix.
5180280	5182280	So there's a...
5182280	5186280	If you have n places to fix, where you say, oh, I made this mistake everywhere.
5186280	5190280	But you still have to find everywhere you have to fix it.
5190280	5192280	And these things are idioms.
5192280	5194280	Everybody that programs in Java has to know this.
5194280	5197280	These idioms are only by convention
5197280	5199280	and they have to be manually replicated.
5207280	5210280	It is an attempt to address those cross-cutting concerns.
5210280	5215280	But it's still unproven as to whether or not people will describe them...
5215280	5217280	those things in advance.
5217280	5220280	Because what tends to happen is that you don't know it.
5220280	5222280	And then you say, oh, I'm doing this all over the place.
5222280	5225400	And then will you implement an aspect?
5225400	5226480	Is there a policy?
5226480	5229000	Is there a way to describe an aspect that will insert it
5229000	5230400	everywhere it's needed?
5230400	5232600	That's a very challenging problem.
5232600	5237800	But the problem of this summary is little easier with
5237800	5239640	aspect-oriented programming.
5239640	5242760	I mean, I think aspect-oriented programming is
5242760	5246200	interesting, but it's different.
5246200	5249240	So anyway, the trade-off with macros, yes, it may be less
5249240	5250040	transparent there.
5250040	5252240	On the other side, when you fix a macro, you fix
5252240	5256000	every usage of the macro.
5256000	5257160	Finally, we get to the easier thing.
5257160	5259000	I mean, start with special operators and macros, mostly
5259000	5260920	because that's the evaluation order.
5260920	5264520	But functions exist, and they're kind of straightforward.
5264520	5266320	The first thing about functions you need to know is that
5266320	5267800	they're first-class values.
5267800	5270680	They're values like any other.
5270680	5272920	Methods in Java are not first-class.
5272920	5275640	You can't put a method into a variable.
5275640	5277760	You can't pass a method to a function.
5277760	5280720	There are special things in LISPs.
5280720	5284240	And in fact, in most dynamic languages today, functions are
5284240	5286600	first-class, which means the function is a value.
5286600	5290280	So I've defined 5 to mean 5.
5290280	5291680	And of course, I don't need to do that.
5291680	5297560	But I'm showing you a depth of a symbol to a value.
5297560	5300840	Now I'm going to show you a depth of a symbol, as if you
5300840	5305200	are, to a value, which is according to one of the other
5305200	5307960	special operators called fun.
5307960	5313040	And what fun does is it creates a function object.
5313040	5315640	This is going to turn that code into something that gets
5315640	5319040	compiled into a function that takes one argument and
5319040	5320160	multiplies it by itself.
5332640	5334720	It's a regular function.
5334720	5339200	It's going to be an instance of a Java interface that
5339200	5340120	takes an argument.
5340120	5343560	It's a real, regular method in Java.
5346560	5349720	You'll have an invalidarity problem.
5349720	5351200	OK, I need to move a little bit more quickly.
5351200	5353720	So let's hold the functions for a little bit.
5353720	5355320	Let me move forward.
5355320	5359640	So this fun, I can't describe all of the features of fun.
5359640	5361920	It's an exciting and rich thing.
5361920	5364880	But this fun that we can take as being fun is a special
5364880	5365880	operator.
5365880	5370440	It takes a vector of the names of its arguments, the
5370440	5372120	simplest way of understanding.
5372120	5376200	And then it contains a set of expressions, which will be the
5376200	5377240	body of the function.
5377240	5380080	The last expression is the value returned by the function.
5380080	5385160	There's no return statement in closure.
5385160	5390880	So when we say square five, it returns 25.
5390920	5391920	This is a function call.
5391920	5393280	Again, we said, what does it do?
5393280	5395040	It says, is square a special operator?
5395040	5395920	No.
5395920	5396800	Is it a macro?
5396800	5398920	We're going to say, right now, it isn't.
5398920	5401040	So what's the value of square?
5401040	5402600	It's this function object.
5402600	5404280	OK, call it.
5404280	5407880	And pass it that.
5407880	5410760	The value of that, because the arguments to functions are
5410760	5412400	evaluated.
5412400	5415440	So it's going to pass square the number five.
5415440	5420080	Square is going to multiply by itself and return 25.
5420120	5422320	So functions are first class.
5422320	5424280	There are other things that are like functions.
5424280	5427440	In other words, the compiler says, can I call this?
5427440	5429960	The answer is true of funds.
5429960	5431240	It's also true of other things.
5431240	5433840	In particular, one of the neat things about closure is that
5433840	5436040	maps are functions.
5436040	5439720	Because if you think about maps mathematically, they are
5439720	5440680	functions.
5440680	5442760	Maps are functions of their keys.
5442760	5448920	Given a key, a map should return the value of that key.
5448920	5450960	And it does, in closure.
5450960	5451960	So maps are functions.
5451960	5453640	Sets are also functions.
5453640	5455480	Vectors are also functions.
5455480	5457080	Vectors are functions of their indices.
5461400	5462280	That's cool stuff.
5462280	5465440	And when you see idiomatic closure, some of it is quite
5465440	5470040	beautiful because of that relationship.
5470040	5473920	So we'll try to summarize this.
5473920	5476440	Things that would be declarations or control
5476480	5482480	structures, or function calls, or operators, or whatever.
5482480	5489440	In Java, all are uniform in closure, or any list.
5489440	5495000	In that, there are lists where the operator is the first
5495000	5497560	thing in the list.
5497560	5501840	So we've reduced all of this variation here to something
5501840	5502320	uniform.
5502320	5503440	So look at each one.
5503440	5507920	int i equals 5 establishes i as the name, whose meaning is
5507920	5510120	the value of 5.
5510120	5512800	That i does that as well.
5512800	5514400	Where in this does it say it's a definition?
5514400	5514680	Whatever.
5514680	5517840	Some rule about the shape of this thing says it's a
5517840	5518440	definition.
5518440	5524000	In closure, that says that's what it means.
5524000	5526040	If x is equal to 0, return y.
5526040	5527480	Otherwise, return z.
5527480	5530120	When does this end?
5530120	5531120	I'm showing the rest of the program.
5531120	5534960	Is this done?
5534960	5536000	Got me?
5536000	5536480	You don't know?
5536480	5537480	I don't know.
5537480	5541960	Because it could say else, else, else if.
5541960	5544200	I couldn't say it has to say else if, and then it could say
5544200	5545120	else.
5545120	5547160	We have to keep looking forward.
5547160	5549680	We could not have had an else.
5549680	5551320	It's not closed.
5551320	5554040	In addition, without these returns, it doesn't yield a
5554040	5554360	value.
5554360	5557120	This is a statement in Java.
5557120	5560280	There is an if conditional, which is an expression of two
5560280	5562720	different things.
5562720	5567280	In closure, if, against first, we know we're dealing with if.
5567280	5568360	We saw the syntax.
5568360	5571520	It takes three things.
5571520	5574360	What's the question mark in 0, the question mark in closure?
5574360	5576080	That's a function name.
5576080	5578360	You can have question marks in names.
5578360	5580800	Closure is much more liberal about the symbols that can
5580800	5583280	appear in names, but not completely liberal.
5583280	5588000	Because I need some symbols for myself.
5588040	5588960	x times y times z.
5588960	5591960	What are these?
5591960	5593400	Mathematical operators.
5593400	5595920	Again, another special thing about Java.
5595920	5597400	And they can go in between things.
5597400	5599040	And there's precedence rules.
5599040	5602040	All other kinds of guk, right?
5602040	5603040	Closure is wet.
5603040	5603720	It's a beginning.
5603720	5604680	I don't have to look anywhere.
5604680	5606600	I don't have to look in the middle or read or look for
5606600	5607880	semicolon.
5607880	5608520	What's happening?
5608520	5612280	Multiplication, first.
5612280	5614480	Also, you'll notice multiplication can take
5614480	5616280	multiple operands, more than two.
5616280	5618160	It's not just a binary operator.
5618160	5619240	It's an n-ary operator.
5622160	5622920	Foo x, y, z.
5622920	5625320	This is what?
5625320	5628080	Function call, right?
5628080	5629360	Foo x, y, z.
5629360	5630840	People complain about the parentheses.
5630840	5632560	List how many parentheses difference.
5636040	5637080	None.
5637080	5640160	You move it from here over there.
5640160	5642320	Same thing.
5642320	5642800	Same thing.
5642800	5644520	I don't know what you're talking about.
5644520	5646680	And you're not going to see curly, curly, curly,
5646680	5648840	curly, curly, curly, curly.
5648840	5652160	Yes, you may see friends like that.
5652160	5653680	But that's better, I'm telling you.
5653680	5656360	It keeps your program near itself.
5656360	5658600	You don't have to go down to the next page to see the next
5658600	5659800	step.
5659800	5661880	And then this member access, I'm going to talk more about the
5661880	5664240	Java interoperability.
5664240	5666120	But same kind of thing.
5666120	5668200	Different number of parentheses?
5668200	5668800	No.
5668800	5670480	Different number of dots?
5670480	5671240	No.
5671240	5676000	But dot goes first, because dot tells Clojure we're doing
5676000	5678320	some Java stuff here.
5678320	5680360	That has its own special interpretation, because dot is
5680360	5683640	a special operator, we saw before.
5683640	5686520	So there's a tremendous uniformity.
5686520	5689640	There's a lot of value to that uniformity.
5689640	5691960	I know a lot of programming languages.
5691960	5695840	And every time I have to learn the arcane, whatever the
5695840	5698720	rules are, syntax, and this thing next to that means
5698720	5701160	that, and this character means this, and you can have a
5701160	5705120	semicolon here, but not there, and it better be indented by
5705120	5707680	the same amount, or whatever it is.
5707680	5711160	I really get angry now, because there is no reason for
5711160	5712000	that.
5712000	5714880	It is not better than this.
5714880	5719920	And if you use this for any amount of time, you will not
5719920	5722760	disagree, because there's no one who has, who does.
5725480	5727560	But it also has to have its biggest
5727560	5729480	differences in some ways.
5729480	5735080	Who got far, far more cool for an X in Java?
5735080	5737080	How do I get the expression?
5737080	5738080	I'll show you later.
5742160	5745720	If I only have another hour, I have to go much faster.
5745720	5748640	Everybody ready?
5748640	5752840	So let's hold the questions until a question time, unless
5752840	5755200	you're really confused, but just general interest things
5755400	5758720	will hold, because I may cover it.
5758720	5763040	One of the things that is typical about a Lisp is that
5763040	5767720	it has a rich library for manipulating lists.
5767720	5771200	But it ends up that, I think, in my opinion, it's a
5771200	5775520	shortcoming of Lisp's traditionally, that those
5775520	5779440	functions are limited to a particular data structure,
5779440	5781760	which is the singly linked list.
5781800	5788120	Because the functions that underline that abstraction are
5788120	5790880	broader, and they're three of them.
5790880	5794520	The first is, I'd like to obtain some sort of a sequence
5794520	5799320	like thing from some sort of collection like thing.
5799320	5802080	That's an abstract way to say something.
5802080	5806760	Given that sequence like thing, I want and need only two
5806760	5807880	functions.
5807880	5812120	One is to say, give me the first thing.
5812120	5815800	The other is to say, give me the sequence that is the rest
5815800	5818520	of this sequence.
5818520	5824120	In the case of seek, if there is no stuff, it returns nil,
5824120	5827800	because nil means nothing.
5827800	5830160	Which means you can say seek call, and you can put that in
5830160	5832680	an if expression as a test thing.
5832680	5836680	And because nil returns logical false, you'll know
5836680	5838480	there's nothing to do.
5838480	5842680	That's an important idiom of common Lisp, closure preserves
5842680	5847680	unlike scheme, where you have to say empty all the time.
5847680	5851080	If it's not empty, you will get back an object.
5851080	5854160	That object only makes two promises.
5854160	5855800	You can call these two functions on it.
5859160	5861080	This function promises one thing.
5861080	5863560	There will be a first element, because we're already covered
5863560	5865920	if there's not a first element here.
5865920	5870120	So if you say first of the seek, and this is not nil, it
5870120	5873920	means you have a seek, you get back a guy.
5873920	5877360	The first thing in the sequence.
5877360	5879400	The second thing you can do with the seek is you can call
5879400	5882560	rest on it, which says, give me the sequence that represents
5882560	5885600	the rest, not including the first thing.
5885600	5888920	Of course, if there's no more, what should we get?
5888920	5892560	Nil, because we said here, nothing.
5892560	5893760	If we have nothing, we get nil.
5893760	5896960	Otherwise, we're going to get another seek.
5896960	5900280	This is an extremely abstract way to talk about lists.
5900280	5904480	But the advantage over common Lisp and scheme lists is they
5904480	5907840	would promise that the return value of this thing is a
5907840	5909320	consel.
5909320	5914040	And that is a real limitation, because now I can make
5914040	5916360	seek work on absolutely everything.
5916360	5919480	Seek works on lists, because they have the structure.
5919480	5922640	But it's possible to create a seek object if you think about
5922640	5925240	iterators, and I want to make this analogy extremely
5925240	5926960	weakly.
5926960	5929480	There's a way to walk through a vector.
5929480	5931880	Similarly, there's a way to walk through a map.
5931880	5933800	There's a way to walk through a string.
5933800	5935280	There's a way to walk through a file.
5937920	5940600	And it ends up that seek is supported on all those things.
5940600	5943040	You can walk through Java arrays, all the closure
5943040	5946680	collections, strings, files, everything.
5946680	5950680	And you can use these two operations to move around.
5950720	5955680	This abstraction of listness, which I call a sequence
5955680	5959240	because a list is more of a concrete thing, is bound to
5959240	5962040	lists in most Lisp's.
5962040	5965200	Wow, this is hard to say.
5965200	5967160	But it's not in closure.
5967160	5972840	And it's, I think, one advance of closure in the Lisp world,
5972840	5974720	which means that you can apply these things to everything.
5974720	5975560	So what does this mean?
5975560	5976560	Well, this is kind of primitive.
5976560	5979040	I mean, walking through step by step.
5979040	5982400	But what it means is that you can build a library on top
5982400	5985560	of these primitives that provides a lot of power for
5985560	5987960	manipulating data structures without loops.
5987960	5990840	I'm just going to show you a tiny, tiny little bit.
5990840	5992960	But it should give you a feel for what it's like to program
5992960	5996000	in closure if you would think about what it would take to
5996000	5997040	do these things in Java.
5997040	5999560	For instance, I have a set of things.
5999560	6003520	I'd like to have everything except the first two things.
6003520	6007320	We say drop two from whatever the collection is.
6007360	6009200	That happens to be a vector.
6009200	6011040	It could have been a list.
6011040	6012800	It could have been a string.
6012800	6015680	We'll drop the first two characters.
6015680	6018760	Whatever it is, there's a way to abstract out the notion of
6018760	6019800	walking through it.
6019800	6024360	Drop means leave out that many and give me the rest as a
6024360	6026120	sequence.
6026120	6029000	Take is the opposite.
6029000	6031680	It says, only give me nine of these things.
6031680	6034080	Look at the second function, cycle.
6034080	6036560	Cycle is a function called, it takes 1, 2, 3, 4.
6036560	6041120	In this case, it could take any sequenceable thing.
6041120	6047320	It returns an infinite list, an infinite sequence of those
6047320	6050480	things around and around in a cycle.
6050480	6051880	How could it do that?
6051880	6053760	Isn't that going to chew up all the memory of my machine?
6053760	6056960	Cycle sounds like a really scary function.
6056960	6061480	It does that because if we go back to the definition of
6061480	6064080	this, is there anything about the way I describe the
6064080	6066440	operation of these things that says that the rest of this
6066440	6069440	thing has to exist?
6069440	6072520	I could make up the rest right when you ask me, right?
6072520	6075560	And how much of it would I have to make up?
6075560	6076840	Just one more thing.
6076840	6079200	The thing I give you has to have one more thing in it, and
6079200	6080560	it's I'm OK.
6080560	6084840	It could delay the calculation of the next part until the
6084840	6087120	next time you call rest.
6087120	6088760	That's called laziness.
6088760	6092000	And in fact, all the sequence stuff I'm showing you for
6092000	6097800	closure is lazy, which means that you can write sequence
6097800	6100120	functions that return infinite sets.
6100120	6102160	And you can use them, as long as you don't try to consume
6102160	6104640	all of them, you can consume a little bit of them.
6104640	6107320	So in this case, we're making an infinite sequence out of
6107320	6112560	1, 2, 3, 4, or taking the first nine things from it.
6112560	6115440	This looks like a weird abstract thing, but I've had
6115440	6116880	plenty of programs in reality.
6116880	6119600	I've had to do exactly this thing, round robin.
6119600	6122440	You can use it to round robin, work dispersal.
6122440	6125880	You can use it to get distributions.
6125880	6128400	In cycle, it seems like some theoretical isn't as cool you
6128400	6129920	can make an infinite sequence.
6129920	6131640	But it really has utility.
6131640	6134360	It ends up in real programs.
6134360	6135360	And it goes on and on.
6135360	6136640	Interleave does what you think.
6136640	6138440	One from this sequence, one from that.
6138440	6139800	Makes a new sequence.
6139800	6143320	Again, one of these could be infinite.
6143320	6145440	You'd only make as much of this as you needed to match the
6145440	6148880	length of the non-infinite one.
6148880	6151440	Partition, split this up into pieces.
6151440	6154360	Think about the loops to do this stuff.
6154360	6157400	And in Java, you have to write everyone, every time.
6161600	6163600	Never mind the laziness part.
6163600	6166280	Now we get to a more interesting function, which is map.
6166280	6168760	Now we're not talking about map the data structure.
6168760	6173320	We're talking about map a function, which is, again, from
6173320	6178920	this list land, which says, take this function.
6178920	6182880	So the first argument of map is a function value.
6182880	6189280	And apply it to pairwise, or however many sequences I give
6189280	6192120	you, the elements of the sequences I provide.
6192120	6194720	So in this case, we're going to call the function vector.
6194720	6198120	And we're going to call it on a and one.
6198120	6202080	Then we're going to call it on b and two, and c and three,
6202080	6204320	and d and four, and e and five.
6204320	6207560	And vector makes vectors out of whatever you pass it.
6207560	6211520	So we're mapping vector across this pair of sequences to
6211520	6215440	vectorize corresponding elements of those sequences.
6215440	6219360	We get a set of data structures back out of this.
6219360	6221080	So map is a very powerful thing.
6221080	6223800	Instead of saying, for each blah, blah, blah, do this and
6223800	6226720	stick the answer into this collection, you say, just map
6226720	6228320	this function across this data.
6228320	6231360	And it'll give you back a set of new data, the result of
6231360	6233400	applying that function to each thing.
6233400	6235400	You can also apply it against multiple sequences.
6235400	6236240	That's what this is doing.
6236240	6240080	Maybe I shouldn't have done something this complex here.
6240080	6243760	Apply is also very interesting, and it's a unique thing to
6243760	6247600	lists and languages that are dynamic.
6247600	6250080	Apply says, I'm also going to pass you a function.
6250080	6253800	What I want you to do is take the next expression and figure
6253800	6258540	out the sequence it yields, and then use that as the
6258540	6261860	arguments to a call to this function.
6261860	6264700	So we're going to apply the function stir, and stir says,
6264700	6268180	given any set of things, turn it into a string.
6268180	6270860	Turn each part into a string, and can cat and make them all
6270860	6273500	back together into a string.
6273500	6275580	So we want to put that together, and what interpose
6275580	6278500	does is it says, take this thing and put it in between
6278500	6279820	everything in this sequence.
6279820	6286020	So interpose, comma, ASDF, turn ASDF into a sequence, and
6286020	6287780	return characters.
6287780	6291300	So we're going to have the character A and a comma, S
6291300	6296100	and a comma, D and a comma, F and a comma.
6296100	6297780	Seven things.
6297780	6298620	Yes?
6298620	6300140	Three-four things with three things in two.
6300140	6300780	Seven things.
6300780	6304140	And we say, apply stir to that, which means
6304140	6305700	string can cat and make them.
6305700	6307820	As if they were the arguments to stir.
6307820	6313260	In other words, if I called stir and said stir, A comma,
6313260	6317820	S comma, D comma, F, it would make a string out of them.
6317820	6321180	Well, I can just apply it to the sequence, as if I called it
6321180	6325620	with those arguments, and it will do the job.
6325620	6327620	I get back a single string with that in between.
6330300	6332740	Again, if you don't quite get these, it's OK.
6332740	6334300	I'm just trying to show you the power and the
6334300	6335580	succinctness of this.
6335580	6338660	Reduces another function that takes a function.
6338660	6343700	It says, apply this function to successive pairs of the
6343700	6347300	sequence you're given, taking the result of each application
6347300	6349820	and using it as the first argument of the next.
6349820	6353860	So if you say, reduce with plus, you're going to get the
6353860	6355620	first two things plus each other.
6355620	6358580	And then take that and do that plus the next thing.
6358580	6360780	And take that and do that plus the next thing.
6360780	6362340	That's what reduce does.
6362340	6367820	So this effectively is summing this range.
6368780	6371780	It's a function that returns a sequence of numbers.
6371780	6378540	And you can step where it starts and where it ends and how
6378540	6381100	it steps and things like that.
6381100	6384580	This is obviously a much higher level way to write
6384580	6387580	programs than you do in Java.
6387580	6388380	Yes?
6388380	6389700	No?
6389700	6390740	Your head hurts.
6390740	6393420	I don't know what it's going to be.
6394380	6396820	Yeah, let's take a break.
6396820	6398060	This is going to be a good time for a break.
6398060	6400060	Does anybody have any questions on this real quick?
6415220	6419020	Right, and cycle returns a sequence, which has only got
6419020	6420380	one in it.
6420380	6423860	And the recipe for producing the rest of the cycle.
6423860	6425500	Sort of like a delayed function.
6425500	6428620	That's what happens inside cycle.
6428620	6433100	It doesn't produce an infinite list, obviously.
6433100	6437180	It returns an object that satisfies.
6437180	6438500	It returns a sequence, correct.
6446620	6449220	Why can't you call stirred directly?
6449220	6454100	Well, in this case, well, I'd have to write a comma, s comma,
6454100	6456020	d comma, f comma.
6456020	6456500	Right?
6460500	6465260	Then you're passing stir a sequence.
6465260	6468060	And what I want to do is say, take that sequence and pretend
6468060	6469780	it was the arguments to stir.
6469780	6473900	Not an argument to stir, but n arguments to stir.
6480180	6481780	Because that's the syntax of closure.
6481780	6486260	Slash comma is a character literal for comma.
6486260	6488260	Quote is used for other things.
6488260	6490620	That's why I don't use it for character literals.
6490620	6492620	All right, let's take a break.
