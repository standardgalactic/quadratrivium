1
00:00:00,000 --> 00:00:10,000
Hi. I'm Racheke. I'm here to talk about Closure, which is a programming language I wrote for

2
00:00:10,000 --> 00:00:17,600
the JVM. This particular talk is oriented towards people who program in Java or C sharp

3
00:00:17,600 --> 00:00:24,480
or C++ in particular that I'm not going to presume any knowledge of Lisp. So you might

4
00:00:24,480 --> 00:00:31,280
find some of it tedious, although I am preparing for a talk I'm going to give at ecoup to the

5
00:00:31,280 --> 00:00:36,600
European Lisp workshop, where I'm going to talk about the ways Closure is a different

6
00:00:36,600 --> 00:00:44,600
Lisp. So maybe some of this will be interesting to you in that respect. But that's the nature

7
00:00:44,600 --> 00:00:48,720
of this talk. It's going to be an introduction to the language, a fly-by tour of some of

8
00:00:48,720 --> 00:00:53,720
the features. I'll drill down into some of the others. I started to ask this question

9
00:00:53,720 --> 00:00:58,160
before, but I'll just ask it again to sort of see, is there anyone here who knows or

10
00:00:58,160 --> 00:01:07,360
uses any flavor of Lisp, common Lisp scheme or Closure? Okay. So mostly no. I presume

11
00:01:07,360 --> 00:01:14,760
a lot of Java or anything in that family, C++, C sharp, Scala, anyone? You must be playing

12
00:01:14,760 --> 00:01:20,280
with it, right? How about functional programming languages like ML or Haskell District? Guys,

13
00:01:20,320 --> 00:01:27,160
anyone a little? Don't really want to raise their hands about that one. Okay. That's good. In

14
00:01:27,160 --> 00:01:33,280
particular, I think coming from that background, you'll understand a lot of this straight away.

15
00:01:33,280 --> 00:01:41,480
How about dynamic programming languages, Python, Ruby or Groovy? Yes, about half. And I asked

16
00:01:41,480 --> 00:01:50,200
before, Closure, we have a few people with their toes in the water. The other key aspect

17
00:01:50,240 --> 00:01:54,680
of Closure that would matter to you if you're a Java programmer is whether or not you do

18
00:01:54,680 --> 00:02:02,400
any real multi-threaded programming in Java or in any language. Yes? So some. So you use

19
00:02:02,400 --> 00:02:15,000
locks and all of that nightmare stuff. I'm a practitioner. I programmed in C and C++ and

20
00:02:15,040 --> 00:02:21,120
Java and C sharp and Common Lisp and Python and JavaScript and a bunch of languages over the

21
00:02:21,120 --> 00:02:29,080
years. Way back, this same group, I think it's the same lineage, was the CIG. And when I first

22
00:02:29,080 --> 00:02:35,920
started to come, I started to teach C++ to the CIG and it became the C++ and CIG and eventually

23
00:02:35,920 --> 00:02:43,160
the C++ and Java CIG and now the Java CIG. So back in the 90s, early 90s and mid 90s, I taught

24
00:02:43,800 --> 00:02:50,640
C++ and advanced C++ to this group and ran study groups and I've come back tonight to apologize

25
00:02:54,120 --> 00:03:03,000
for having done that to you and to try to set you off on a better track. So we're going to look at

26
00:03:03,000 --> 00:03:11,080
the fundamentals of Closure and it will be also of Lisp in many ways. But I'm going to say Closure,

27
00:03:11,560 --> 00:03:17,160
don't take offense, all these things or many of the things I say are true of Closure are true of

28
00:03:17,160 --> 00:03:24,600
many Lisp. I didn't invent them, they're not unique to Closure, but some things are. They will

29
00:03:24,600 --> 00:03:30,720
look at the syntax and evaluation model. This is the stuff that will seem most unusual to you if

30
00:03:30,720 --> 00:03:37,480
you've come from a, you know, compile link run language and one of the curly brace C derives

31
00:03:37,520 --> 00:03:46,520
like Java. Then we'll look at some aspects of Closure, sequences in particular and the Java

32
00:03:46,520 --> 00:03:52,760
integration which I imagine will be interesting and I'll finally end up talking about concurrency,

33
00:03:52,760 --> 00:03:57,000
why Closure has some of the features it does and how they address the problems of writing

34
00:03:57,000 --> 00:04:03,880
concurrent programs that run on the new and indefinitely, you know, for the indefinite future

35
00:04:03,920 --> 00:04:08,400
multi-core machines and I'll take some questions. At some point in the middle we'll probably take

36
00:04:08,400 --> 00:04:15,400
a break. I don't know exactly where that's going to go. So what's the fundamentals of Closure?

37
00:04:15,400 --> 00:04:21,240
Closure is a dynamic programming language and dynamic has a lot of different meanings, in

38
00:04:21,240 --> 00:04:27,480
particular it's dynamically typed, that would be an expectation you'd have of Python or Ruby or

39
00:04:27,520 --> 00:04:37,320
Groovy. It achieves that dynamic nature by being a Lisp and I'll talk more about that. I don't see a

40
00:04:37,320 --> 00:04:45,760
lot of people who know Lisp here but that doesn't mean there isn't a bias against Lisp. How many

41
00:04:45,760 --> 00:04:55,000
people have seen Lisp and said oh my god, I can't believe the parentheses and I would say I'd hope

42
00:04:55,040 --> 00:05:01,360
you'd put that bias aside for the purposes of this talk. It ends up that for people who have not used

43
00:05:01,360 --> 00:05:10,000
Lisp, those biases have no basis and for most people who have given it a solid try, they vanish and in

44
00:05:10,000 --> 00:05:19,880
fact many of the things you consider to be problems with Lisp are features down the line. But having

45
00:05:19,920 --> 00:05:26,000
said that, Closure is a very different Lisp. It's syntactically much leaner than a lot of Lisp's. It

46
00:05:26,000 --> 00:05:34,720
has fewer parentheses. It uses more data structures in its syntax and as a result I think is more

47
00:05:34,720 --> 00:05:43,400
succinct and more readable. So maybe the time to try Lisp again. Another aspect of Closure is that

48
00:05:43,400 --> 00:05:47,440
it's a functional programming language and again I'm going to talk in detail about these things. For

49
00:05:47,480 --> 00:05:53,520
now you can just say that means a focus on immutability in your programs. So write programs

50
00:05:53,520 --> 00:05:58,840
primarily with immutable data structures and if you're coming from another Lisp, this will be an

51
00:05:58,840 --> 00:06:04,400
area where Closure is definitely different. I mean different decisions about the data structures

52
00:06:04,400 --> 00:06:10,280
in Closure. The third leg of Closure, you know, it sort of stands on four points. It's dynamic,

53
00:06:10,280 --> 00:06:16,360
it's functional, it's hosted on the JVM and it embraces the JVM, its host platform. There are

54
00:06:16,400 --> 00:06:20,200
ports of other languages that sort of just sit on the JVM. There are ports of, for instance,

55
00:06:20,200 --> 00:06:26,400
common Lisp that sit on the JVM. But they don't really connect very well. For a number of reasons.

56
00:06:26,400 --> 00:06:31,240
One is they're implementing a standard. The standard was written before Java was written and

57
00:06:31,240 --> 00:06:36,760
you know, there's just no merging the type systems. On the other hand, Closure was written for the

58
00:06:36,760 --> 00:06:44,160
JVM and so it's very heavily integrated with it. So not only does it reside there, which is a

59
00:06:44,200 --> 00:06:49,560
benefit because you can run it if that's your environment. But it embraces it, which means the

60
00:06:49,560 --> 00:06:55,880
integration is good and it's pretty transparent to go back and forth. The fourth aspect of Closure

61
00:06:55,880 --> 00:07:03,880
is the concurrency aspect. You know, I work in C-Sharp with guys writing broadcast automation

62
00:07:03,880 --> 00:07:08,760
systems. They're, you know, they're multi-threaded. They have all kinds of nasty stuff going on,

63
00:07:08,800 --> 00:07:15,040
multiple connections to sockets, lots of databases, you know, data feeds from all kinds of places

64
00:07:15,040 --> 00:07:21,040
and it's not fun writing programs like that that need to share data structures amongst

65
00:07:22,340 --> 00:07:28,580
threads and to have them get maintained over time and have everybody remember what the locking

66
00:07:28,580 --> 00:07:33,880
model is. It's extremely challenging. Anyone who's done any extensive multi-threaded programming

67
00:07:33,900 --> 00:07:39,200
with the locking model knows how hard it is to get that right. So Closure is an effort on my

68
00:07:39,200 --> 00:07:44,200
part to solve those problems in an automatic way with language support. And the last thing

69
00:07:46,760 --> 00:07:51,200
is, you know, it is an open source language and it's very transparent, the implementation

70
00:07:51,200 --> 00:07:58,200
and everything else is up there for you to see. We started to talk about this before. Why use a

71
00:07:58,200 --> 00:08:04,440
dynamic language? Some people are very happy, of the people who are programming Java, how we are

72
00:08:04,440 --> 00:08:09,440
happy about that. They like Java. They have no complaints. Okay, not too many. It ends up that I

73
00:08:13,240 --> 00:08:19,420
think many Java programmers look at people who are using Python or Ruby and being very

74
00:08:19,420 --> 00:08:24,420
productive and I think justifiably MV, their productivity, the succinctness, the flexibility

75
00:08:25,260 --> 00:08:31,260
they have and in particular how quickly they can get things done. And it ends up that that is a

76
00:08:32,760 --> 00:08:38,760
fact of the static languages, especially the ones like Java, that they're inherently slower

77
00:08:39,840 --> 00:08:46,340
because of the amount of, well some people call it ceremony, but you have to go through to

78
00:08:46,340 --> 00:08:52,340
communicate with the language. It slows you down. So flexibility is a key thing. You would look for

79
00:08:53,340 --> 00:08:59,340
in a dynamic language. Interactivity is another key point. Again, this goes back to Lisp. Lisp has

80
00:08:59,340 --> 00:09:04,860
pretty much always been an interactive language. And that means a lot of things. In particular, it

81
00:09:04,860 --> 00:09:10,860
means that when you've got Lisp up and running, you feel like you are engaged with an environment as

82
00:09:11,460 --> 00:09:17,460
opposed to, you know, shoveling your text through a compiler phase to produce something else out the

83
00:09:18,380 --> 00:09:24,380
other end. So that interactivity is kind of a deep thing. The repul is part of it. That means read,

84
00:09:24,380 --> 00:09:30,380
eval, print, loop, and I'll talk about that in detail in a little bit. Dynamic languages tend to be

85
00:09:30,380 --> 00:09:35,380
more concise. That doesn't mean that static languages can't be. Haskell in particular is very

86
00:09:35,380 --> 00:09:41,380
concise. But the curly brace languages are not concise. Java is probably a great example of a

87
00:09:42,380 --> 00:09:48,380
language that's not concise. And that's just not a matter of tedium. It's a matter of where is your

88
00:09:48,380 --> 00:09:55,380
logic? How far apart is your logic? How spread out is it? Can you see what you're thinking about? Or is it

89
00:09:55,380 --> 00:10:01,380
in pieces? Is it spread out by a bunch of things that are not about your problem? Dynamic languages are

90
00:10:03,380 --> 00:10:09,380
definitely more suitable for exploration. There's a certain aspect in which static languages are like

91
00:10:09,700 --> 00:10:15,500
concrete. That's a good aspect when you're trying to, you know, finish. In some systems, you know,

92
00:10:15,500 --> 00:10:20,780
concrete is going to be more resilient. It's, you know, it's more resilient to change. It's more

93
00:10:20,780 --> 00:10:25,780
structured and it's rigid. On the other hand, that's not necessarily the kind of materials you

94
00:10:25,780 --> 00:10:30,500
want to be working with when you're trying to figure out what your structure should look like in

95
00:10:30,500 --> 00:10:38,000
the first place. So dynamic languages are better for exploration. And in particular, what I like

96
00:10:38,080 --> 00:10:44,080
about dynamic languages and Lisp fundamentally, and I think in a way other languages don't achieve, is it

97
00:10:46,720 --> 00:10:51,720
lets you focus on your problem. You can, with Lisp and its ability to do syntactic abstraction, suck

98
00:10:54,280 --> 00:11:00,280
everything out of the way, except the problem. And for me, you know, when I discovered Lisp, I was

99
00:11:01,280 --> 00:11:07,280
pretty expert, C++ programmer. I said to myself, what have I been doing with my life? It was that, that

100
00:11:11,280 --> 00:11:17,280
big a deal. So there are many dynamic languages. I'm going to talk about closure and I will do, you

101
00:11:20,280 --> 00:11:25,280
know, bashing of other languages, but I will try to highlight why you might choose closure over some of

102
00:11:25,280 --> 00:11:30,280
the other options. Because in particular now, I think it's a great thing that there are many dynamic

103
00:11:30,280 --> 00:11:35,280
languages available for the JVM and dynamic languages are supported as a concept in the Java community.

104
00:11:38,280 --> 00:11:43,280
A Java one, there was plenty of presentations on Jython and JRuby and Groovy and these other languages.

105
00:11:46,280 --> 00:11:52,280
And Sun has hired some of the developers of these languages and given it, you know, kind of official

106
00:11:52,280 --> 00:11:57,280
support as something that's viable to do on the JVM. So you're going to see mixed language

107
00:11:59,280 --> 00:12:04,280
programming being accepted in Java shops. So how do you pick? I think you can categorize languages in one

108
00:12:07,280 --> 00:12:12,280
dimension pretty straightforward. Are they a port of a language that exists somewhere else or were they

109
00:12:12,280 --> 00:12:17,280
written for the JVM? Ports have a bunch of challenges. One is there is a canonic version out there because

110
00:12:18,280 --> 00:12:23,280
most of these languages are not defined by a specification. They're defined by a canonic

111
00:12:23,280 --> 00:12:28,280
implementation. So they're CRuby. They're CPython. Those are really the languages. And the other things are

112
00:12:32,280 --> 00:12:37,280
ports which have to struggle to follow along with the C version. The other problem ports have is a lot of

113
00:12:40,280 --> 00:12:45,280
the infrastructure for the languages, especially the ones that don't perform very well, are written in C. In

114
00:12:45,280 --> 00:12:50,280
other words, to get the library performance they need, the support libraries for Python are written in C. So

115
00:12:50,280 --> 00:12:56,280
an effort to port Python to Java means having to replicate those C libraries. So there's that. I would

116
00:12:56,280 --> 00:13:02,280
say the main appeal to a ported language is if you already have an investment in Ruby or Python or you

117
00:13:02,280 --> 00:13:08,280
have to really love the language designs. That's a good way to go here. I would say if not, if you're just

118
00:13:09,280 --> 00:13:14,280
starting from scratch, you may find that a language that's native to the JVM is going to give you better

119
00:13:16,280 --> 00:13:21,280
integration. You know the version you're using is the canonic version. The canonic version of Ruby is a JVM

120
00:13:21,280 --> 00:13:26,280
language. The canonic version of Closure is a JVM language. And I would say of the two, Groovy is going to let

121
00:13:30,280 --> 00:13:35,280
you do what you do in Java, except a little bit more easily. Fewer semicolons, more dynamic, there are

122
00:13:38,280 --> 00:13:43,280
some builders, there are some idioms, there are closures, sort of the fun of dynamic programming and a lot of

123
00:13:46,280 --> 00:13:51,280
the similar syntax to Java. So I think if you're just interested in dynamic and want to continue to write

124
00:13:54,280 --> 00:13:59,280
programs that are like your Java programs, Groovy can't be touched. Closure is not about writing programs like

125
00:14:00,280 --> 00:14:05,280
your Java programs. Closure is about realizing what's wrong with your Java programs and doing something

126
00:14:09,280 --> 00:14:14,280
different. And so you'll find some of that through the talk. So Closure itself, it inherits from Lisp, an

127
00:14:20,280 --> 00:14:25,280
expressivity and elegance I think is unmatched. Depending on your mindset, you may or may not agree, but this is a

128
00:14:29,280 --> 00:14:34,280
certain mathematical purity to lambda calculus and the way it's realized in Lisp. The uniformity of the syntax

129
00:14:36,280 --> 00:14:41,280
is elegant. Closure also has very good performance. Again, I'm not going to get involved in any language

130
00:14:44,280 --> 00:14:48,280
bashing, but I'm pretty confident no other dynamic language on the JVM approaches the performance of

131
00:14:50,280 --> 00:14:55,280
Closure in any area and is unlikely to. But everybody's working on performance.

132
00:15:00,280 --> 00:15:02,280
Certainly.

133
00:15:07,280 --> 00:15:09,280
We've converted them.

134
00:15:15,280 --> 00:15:20,280
So the performance is good. I made a point before starting the talk that the objective and objective of

135
00:15:21,280 --> 00:15:26,280
Closure is to be useful in every area in which Java is useful. You can tackle the same kind of problems. I don't

136
00:15:27,280 --> 00:15:32,280
write web apps and put stuff in and take it out of the database kind of applications. I write scheduling

137
00:15:35,280 --> 00:15:40,280
systems, broadcast automation systems, election projection systems, machine listening systems, audio

138
00:15:45,280 --> 00:15:50,280
analysis systems, and I write them in languages like C-sharp and Java and C++ and Closure can be used for those

139
00:15:51,280 --> 00:15:56,280
kinds of problems. It doesn't mean they can't also be used for web apps and people did that right away with

140
00:15:59,280 --> 00:16:04,280
Closure and database and UI stuff. But it has that same kind of reach. One of the nice things about Java is it

141
00:16:08,280 --> 00:16:13,280
has a wide range. Closure has direct wrapper free access to Java. Some of the ported languages have to use

142
00:16:14,280 --> 00:16:19,280
wrappers because those languages have their own object systems that imply a bunch of dynamic features that they

143
00:16:22,280 --> 00:16:26,280
have to glom on top of Java objects when you interoperate with them. Closure was designed to provide direct

144
00:16:29,280 --> 00:16:34,280
access to Java. It looks like Closure, but it's direct. Closure being a list is extensible in a deep way.

145
00:16:35,280 --> 00:16:40,280
And we'll talk a little bit more about how you get syntactic extensibility through macros. And then Closure, I

146
00:16:43,280 --> 00:16:48,280
think, is completely unique amongst the languages on the JVM in promoting immutability and concurrency, much more

147
00:16:49,280 --> 00:16:54,280
so than even Scala, which is often talked about as a functional language, but it's also a

148
00:16:55,280 --> 00:17:00,280
option. Closure is really oriented towards writing concurrent programs. And immutability for its other benefits

149
00:17:05,280 --> 00:17:11,280
outside of concurrency. So how does Closure get to be these things? It is a list. It is a list. It is a list.

150
00:17:25,280 --> 00:17:30,280
Again, put what you think about Lisp aside. I'll explain what that means in depth as I go into each of these

151
00:17:33,280 --> 00:17:37,280
points, but Lisp in general is dynamic in that way, interacting with an environment, having a REPL,

152
00:17:38,280 --> 00:17:43,280
having sort of introspection capabilities on the environment, being able to modify things in a running

153
00:17:44,280 --> 00:17:49,280
program, or all characteristics that make it dynamic. A fundamental feature of all Lisp, if they want to be a

154
00:17:50,280 --> 00:17:55,280
Lisp, is that code is represented as data. And again, I'll explain that in detail. There is a reader, which is part of the

155
00:18:04,280 --> 00:18:09,280
implementation of code as data, sort of something in between your text and the evaluator. Being a Lisp

156
00:18:12,280 --> 00:18:17,280
means having an extremely small core. You'll find when you contrast Closure to other languages, even

157
00:18:17,280 --> 00:18:22,280
languages that are theoretically lightweight like Python or Ruby, Closure has way less syntax than those languages, far

158
00:18:25,280 --> 00:18:30,280
less complexity. In spite of the fact that they appear easy. Lisp generally have tended to emphasize lists.

159
00:18:38,280 --> 00:18:43,280
Closure is not exactly the same way. It is an area where Closure differs from Lisp in that it frees the abstract

160
00:18:44,280 --> 00:18:49,280
of first and rest from a data structure, the con cells. And in doing so, offers the power of Lisp to many more data

161
00:18:57,280 --> 00:19:02,280
structures than most Lisp do. So there's that sequence thing, and I'll talk more about that in detail. And syntactic

162
00:19:04,280 --> 00:19:09,280
abstraction. Again, we have abstraction capabilities with functions or methods in most languages. Lisp

163
00:19:10,280 --> 00:19:15,280
take that to the next level by allowing you to suck even more repetition out of your programs when that

164
00:19:18,280 --> 00:19:23,280
repetition can't be sucked out by making a function. Okay, so we'll dig down a little bit more. What does it mean to do

165
00:19:27,280 --> 00:19:32,280
dynamic development? It means that there's going to be something called a REPL, a read eval print loop in which you

166
00:19:33,280 --> 00:19:38,280
can type things and press enter and see what happens. I guess we should probably do that. So this is a little

167
00:19:45,280 --> 00:19:50,280
editor. It's kind of squashed in the screen resolution, but down below is the REPL. This is Closure in an

168
00:19:52,280 --> 00:19:57,280
interactive mode, and we can go and we can say plus one, two, three, and we get six. We can do other things

169
00:19:58,280 --> 00:20:03,280
Java like, I'll show you some more of that later. But the general idea is that you're going to be able to type

170
00:20:06,280 --> 00:20:11,280
expressions or in your editor, say please evaluate this. I mean, I can go up here to meth.pi and hit the key

171
00:20:14,280 --> 00:20:19,280
stroke that says evaluate this and see below, we get that. And that's kind of what it feels like to develop. I'm

172
00:20:21,280 --> 00:20:26,280
going to show you even more after I explain what you're looking at because I don't want this talk to be yet another

173
00:20:28,280 --> 00:20:33,280
people are shown Lisp and not having had to explain to them what they're looking at. So we're going to do that first.

174
00:20:35,280 --> 00:20:40,280
But you have this interactive environment. You can define functions on the fly. You can fix functions on the fly.

175
00:20:40,280 --> 00:20:45,280
You can have a running program and fix a bug in a running program. And that's not like being in a mode in a

176
00:20:47,280 --> 00:20:52,280
debugger where you have the special capability to reload something. It's always present. If you build an

177
00:20:53,280 --> 00:20:58,280
application with some access to the ability to load code, either a remote REPL connection or some way to do that,

178
00:21:00,280 --> 00:21:05,280
your running production systems will have this capability to have fixes loaded into running programs.

179
00:21:10,280 --> 00:21:15,280
In general, there isn't the same distinction between compile time and run time. Compiling happens all the time.

180
00:21:16,280 --> 00:21:21,280
Every time you load code, every time you evaluate an expression, compilation occurs. So that notion of phases of

181
00:21:26,280 --> 00:21:31,280
compilation is something you have to relax when you're looking at a language like closure. And I'll show you the

182
00:21:32,280 --> 00:21:36,280
evaluation model in a second. I talked a little bit about the introspection, but that's present. You're sitting at a

183
00:21:38,280 --> 00:21:43,280
REPL, closure is there, closure has namespaces, you can get a list of them. Closure has symbols, you can get a list of

184
00:21:44,280 --> 00:21:49,280
those. You can look inside the infrastructure that underlies the run time and manipulate it. And that's what I

185
00:21:53,280 --> 00:21:58,280
mean by an interactive environment. I just don't mean typing things in. I mean, there is a program behind your

186
00:21:59,280 --> 00:22:04,280
program that is the run time of closure. And that's accessible. If I say something that you don't

187
00:22:05,280 --> 00:22:11,280
understand, you can ask for clarification. I'm endeavoring to try to come up with the ideal way to explain

188
00:22:17,280 --> 00:22:22,280
the list to people who have never seen it. And this is what I've come up with, which is to talk about data. Lots of

189
00:22:25,280 --> 00:22:31,280
languages have syntax. You can talk about Java. You can talk about here's main and here's what public means and static.

190
00:22:32,280 --> 00:22:37,280
And then you can dig into arguments to a function and things like that. But we're going to start here with data, in

191
00:22:38,280 --> 00:22:42,280
particular data literals. I think everybody understands data literals from languages they're familiar with. You type in

192
00:22:43,280 --> 00:22:48,280
1, 2, 3, 4, and you know that's going to mean 1,234 to your program. So closure has integers, they have

193
00:22:53,280 --> 00:22:59,280
arbitrary precision. They can get as large as your memory can support. And the promotion of

194
00:23:01,280 --> 00:23:08,280
small integers to larger integers while arithmetic is going on is automatic. It supports doubles as the floating

195
00:23:09,280 --> 00:23:16,280
point format. Those are doubles. Those are big D double Java doubles. When you type them in. They're right. Right.

196
00:23:20,280 --> 00:23:25,280
They're Java doubles, but they're the big D doubles. So one of the things you're going to see about closure is

197
00:23:26,280 --> 00:23:32,280
everything is an object. Okay. All numbers are boxed. At least until you get inside a loop where I can unbox them. But it's a

198
00:23:36,280 --> 00:23:41,280
language in which numbers are boxed. Unlike common lists where you have access under the hood to use tagged integers and

199
00:23:44,280 --> 00:23:49,280
tagged numbers, which is more efficient than allocating them on the heap, no capability of doing that in the JVM.

200
00:23:50,280 --> 00:23:55,280
There's been talk about it, them adding it, which is stunning to me. Apparently the guy, there's this guy, John Rose, at

201
00:23:58,280 --> 00:24:04,280
Sun who really does understand this very well. And has talked about all kinds of really neat features, which if they make it into the

202
00:24:04,280 --> 00:24:09,280
JVM would make it stunning. Like tail call elimination and tagged numbers. But in the absence of that, numbers are boxed so

203
00:24:10,280 --> 00:24:15,280
that everything can be an object and can be treated uniformly. You have big decimal literals. You have ratios. 22 over 7 is

204
00:24:24,280 --> 00:24:29,280
something. It's not divide 22 by 7. It's a number. It's a number that's not going to lose any information versus dividing 22 by

205
00:24:32,280 --> 00:24:37,280
7 and either truncating or converting into a floating point format where you will lose information. So ratios are first class.

206
00:24:40,280 --> 00:24:45,280
String literals are in double quotes. They are Java strings. Same thing. Immutable. No conversions, no mapping. Being, again,

207
00:24:50,280 --> 00:24:55,280
being a native JVM language means I can just adopt the semantics of Java literals. I don't have to take strings from a

208
00:24:59,280 --> 00:25:04,280
language spec that said, for instance, they could be mutable. I have to force it on the JVM by having my own type and conversions to

209
00:25:05,280 --> 00:25:10,280
and from. So because I'm an immutability oriented language, I'm very happy with Java's definition of a string being an immutable

210
00:25:15,280 --> 00:25:20,280
thing. So closure strings are Java strings. Yes. Is there any way to work for a cent on the line you do this? In other words,

211
00:25:20,280 --> 00:25:25,280
to say there's a total of 1.234, or unless you know the center meter or something like that, you don't show, you don't know.

212
00:25:31,280 --> 00:25:36,280
No. Try Frank. Have you ever seen it? No. Oh, you will love it. You can add all kinds of units and figure out how many, you

213
00:25:41,280 --> 00:25:46,280
know, balloons of, you know, hydrogen it would take to move a camel across this much distance. It's amazing. Units for

214
00:25:50,280 --> 00:25:55,280
absolutely everything. Old, ancient Egyptian unit, it's really, it's fantastic. The guys are just a fanatic about precision,

215
00:25:59,280 --> 00:26:04,280
making sure you don't lose anything, but you can arbitrarily multiply all kinds of units. Everything is preserved. Everything works

216
00:26:05,280 --> 00:26:10,280
correctly. Fantastic. Frank. Frank, F-R-I-N-K. But no. Frank? Frank is a language for the JVM. It's its own language, but it's a lot of

217
00:26:21,280 --> 00:26:28,280
fun. I've seen the guy talking. He just, he has some great examples. You know, some involve how many belches it would take to, you

218
00:26:29,280 --> 00:26:35,280
know, move a hot air balloon to the moon and things like that. Okay, so we have string literals and double quotes. We have

219
00:26:36,280 --> 00:26:41,280
characters that are preceded by a slash, backslash. So that's a character literal, and that's a big C character, a

220
00:26:42,280 --> 00:26:47,280
Java character. Now we're going to get to two things that are possibly a little bit different, because they're not first class

221
00:26:50,280 --> 00:26:55,280
things in Java. One would be symbols, which are identifiers. They can't contain any spaces. They have no

222
00:26:59,280 --> 00:27:05,280
adornments. Symbols are used as identifiers primarily in code, but they can be used for other things as well. They're

223
00:27:06,280 --> 00:27:11,280
first class objects like strings. If you have one of these things, you can look at it, and it will be a symbol, closure

224
00:27:14,280 --> 00:27:20,280
laying symbol. Fred and Ethel are two symbols. That's correct. The other thing, closure has our keywords, which are

225
00:27:24,280 --> 00:27:29,280
very similar to symbols, except they always designate themselves. So they're not subject to evaluation or mapping to

226
00:27:30,280 --> 00:27:35,280
values by the compiler, like symbols are. So symbol might be something you would use for a variable. You could make Fred be

227
00:27:40,280 --> 00:27:45,280
equivalent to five. You could never make colon Fred be equal to five. Colon Fred will always mean itself. So when it gets

228
00:27:49,280 --> 00:27:54,280
evaluated, the value of the keyword Fred is the keyword Fred. It's sort of an identity thing. And they're extremely useful.

229
00:27:59,280 --> 00:28:04,280
They're very useful in particular as keys and maps because they're very fast for comparison, and they print as themselves

230
00:28:08,280 --> 00:28:13,280
and read as themselves. That will make a little bit more sense in a minute. There are booleans. This is different from

231
00:28:16,280 --> 00:28:21,280
Lisp, although there is still null as false, nil as false. But in addition, there are proper true and false, mostly for the

232
00:28:22,280 --> 00:28:27,280
purposes of interoperability. It ends up that you can't solve the nil becoming false problem. At least I couldn't. So there are

233
00:28:35,280 --> 00:28:40,280
true and false, and there for use in interoperability with Java, you can use them in your closure programs as

234
00:28:40,280 --> 00:28:46,280
well. But conditional evaluation in closure looks for two things. It looks for false or nil, which is the next thing I

235
00:28:47,280 --> 00:28:52,280
want to talk about. Nil means nothing. It also is the same thing in closure as Java null. Didn't have to be, but it is. So you can

236
00:29:02,280 --> 00:29:07,280
rely on that. So nil means nothing, and it's the same value as Java null. So when you get back nulls from Java, they're

237
00:29:08,280 --> 00:29:13,280
going to say nil. Nil is a traditional Lisp word. But I like it because also traditionally in Lisp, if you can say if nil,

238
00:29:22,280 --> 00:29:27,280
it will evaluate to the else branch, because nil is false. Nil is not true. So that's another literal thing, that nil. There are

239
00:29:27,280 --> 00:29:32,280
some other things. There are regex literals. So if the reader reads that, it's just a string regex, exactly the same syntax as

240
00:29:43,280 --> 00:29:49,280
Java's, preceded by hash, will turn into a compiled pattern. So at read time, you can get compiled patterns, which you can then

241
00:29:50,280 --> 00:29:55,280
incorporate in macros and things like that, which is very powerful. And shows how that delineation between compilation and runtime is a

242
00:30:02,280 --> 00:30:07,280
little bit fungible. Correct. And there's a good reason for that. And the reason is empty list is no longer as special as it was once you

243
00:30:08,280 --> 00:30:13,280
have empty vector and empty map. However, the sequencing primitives, the functions that manipulate sequences return nil when they're

244
00:30:26,280 --> 00:30:31,280
done, not the empty list. So that aspect of being able to test for the end of iteration with if is still there. So closure sits in a

245
00:30:32,280 --> 00:30:37,280
unique point. He's asking about aspects of closure that differ a little bit from common list and scheme. There's like a long standing fight between

246
00:30:44,280 --> 00:30:49,280
what should the difference between false, nil and the empty list be? Should they be unified? They are in common list. Should there be some

247
00:30:53,280 --> 00:30:58,280
differences? There are some differences in scheme. Closure actually does some of both. There is false. However, there are some

248
00:31:02,280 --> 00:31:07,280
differences. However, nil is still testable in a conditional. It does not unify nil and the empty list, which is a difference from common

249
00:31:10,280 --> 00:31:15,280
list. However, all of the sequencing or list operations, when they're done, return nil, not the empty list, which is an important thing for

250
00:31:19,280 --> 00:31:24,280
common list like idioms, where you want to keep going until it says false, as opposed to having to test for empty explicitly, which you

251
00:31:25,280 --> 00:31:30,280
would have to do in scheme. Does anybody know scheme here? But you know both, so you know what I'm talking about. For everyone

252
00:31:35,280 --> 00:31:40,280
else, I wouldn't worry too much about that because you wouldn't have presumed nil would have been the empty list, right?

253
00:31:40,280 --> 00:31:47,280
Probably not. Okay, so those are the atomic things. They can't be divided, right? That's what atomic means. You can't, a number is in a

254
00:31:54,280 --> 00:32:01,280
single thing. But there are composite or aggregate data structures. Enclosure and they're kind of the core abstractions of computer

255
00:32:06,280 --> 00:32:13,280
science. One is the list. And in this case, I mean very specifically, the singly linked list. And even more specifically, the singly

256
00:32:14,280 --> 00:32:21,280
linked list in which things get added at the front. So when you add to a list, you're adding at the front. The list is a chain of things, which

257
00:32:28,280 --> 00:32:34,280
means that finding the nth element is a linear time cost, right? It's going to take n steps to do that. On the other hand, taking

258
00:32:35,280 --> 00:32:42,280
stuff on and off the front is constant time, because that's the nature of a singly linked list. So it has all the promises, all the

259
00:32:46,280 --> 00:32:52,280
performance promises of a singly linked list with stuff at the front. And it's literal representation is stuff inside

260
00:32:54,280 --> 00:33:00,280
parentheses separated by spaces. There's no need for commas. You'll see some commas. Commas are white space enclosures.

261
00:33:04,280 --> 00:33:09,280
They're completely ignored. You can put them in if it makes you feel better or makes things somewhat more readable, but they're

262
00:33:10,280 --> 00:33:19,280
not actually syntaxed or not considered by the evaluator. So any questions about lists? Stuff in parentheses?

263
00:33:19,280 --> 00:33:21,280
Stuff in parentheses?

264
00:33:30,280 --> 00:33:38,280
Right. Well, these commas, the ones between 12345 and Fred Atollusi are actually English commas. But there are some commas.

265
00:33:39,280 --> 00:33:44,280
For instance, when we get down to maps here, you see commas inside the data structure. Those are ignored. Those are white space.

266
00:33:50,280 --> 00:34:05,280
I don't support any commas inside numbers. The printed representations of numbers enclosures are those of Java.

267
00:34:06,280 --> 00:34:15,280
In lists? No, in lists, they grow at the front. Cons A onto something makes A the first thing in that list. And that's true of

268
00:34:15,280 --> 00:34:22,280
closure, too. Yes? Absolutely not. All of these data structures are unique to closure. I'm only giving you some very high-level descriptions of their

269
00:34:22,280 --> 00:34:28,280
representation and their performance characteristics, but we're going to talk about that in a little bit later on.

270
00:34:28,280 --> 00:34:41,280
Is it based on the retail structure of lists? Absolutely not. All of these data structures are unique to closure. I'm only giving you some very high-level descriptions of their representation and their performance characteristics, but what we're going to find out later is all of these things, in particular, I'm talking about adding to lists. All of these data structures are immutable. And they're persistent, which is another characteristic. I will explain that in a little bit later on.

271
00:34:59,280 --> 00:35:14,280
These are very different beasts, and they have excellent performance, yet they're immutable, and it's sort of the secret sauce of closure. Without these, you can't do what I do in the language.

272
00:35:14,280 --> 00:35:21,280
That's correct. Again, how this gets interpreted, we're going to talk about it in a little bit. Right now, what you're looking at is a list of three symbols. You may end up within your program, a data structure that's a list of three symbols. You may pass this to the evaluator and say,

273
00:35:44,280 --> 00:35:57,280
evaluate this, in which case it's going to try to interpret, it's going to try to evaluate each of those symbols and find out its value and treat the first one as if it was a function. But we're not there yet.

274
00:35:57,280 --> 00:36:13,280
So that is a list of three symbols. The list at the end is a list of one symbol and three numbers. So heterogeneous collections are supported. In all cases, I didn't necessarily show them everywhere, but they are.

275
00:36:13,280 --> 00:36:34,280
It's not a list of something. It's a list. It can contain anything and any mix of things. Okay, with lists, the next thing is a vector uses square brackets. That should imply I would hope for Java programmers and people from that domain array, right? Square brackets mean arrays.

276
00:36:35,280 --> 00:36:56,280
Well, they do now. So a vector is like an array. In particular, it supports efficient indexed access. It's an expectation you would have of a vector you wouldn't have of a linked list. That getting at the 50th guy is fast. It's not going to be 50 steps to do that.

277
00:36:57,280 --> 00:37:13,280
And the closure vectors meet that performance expectation. Fast indexing. In addition, it's a little bit like Java util vector or array list in that it supports growing and in this case, at the end.

278
00:37:13,280 --> 00:37:23,280
And that also is efficient, as efficient as your expectation would be of a ray list. That's a constant time operation to put things at the end.

279
00:37:24,280 --> 00:37:31,280
Similarly, it can hold anything. The first is a vector of five numbers. The second is a vector of three symbols.

280
00:37:31,280 --> 00:37:47,280
All the collections can be heterogeneous. Okay, so far. So that's going to behave like an array in terms of being able to find the element quickly.

281
00:37:47,280 --> 00:38:02,280
And finally, as a core data structure, we have maps. And a map is like, well, it's like a Java map or any kind of associative data structure in providing a relationship between a key and a value.

282
00:38:02,280 --> 00:38:18,280
Each key occurring only once and having a mapping to a value. So the way they're represented is in curly braces. And they're represented simply as key, value, key, value, key, value.

283
00:38:18,280 --> 00:38:33,280
Again, the commas don't matter. So they're whitespace. They get eliminated. For instance, in the second map you see there, that's a map of the number one to the string ethyl and the number two to the string fred.

284
00:38:33,280 --> 00:38:44,280
You don't need the commas. And the expectation with the map is that it provides fast access to the value at a particular key.

285
00:38:44,280 --> 00:39:03,280
There are usually two kinds of maps you would encounter in ordinary programming languages. One would be sorted. Some sort of sorted map, in which case the access is going to be typically log n to find a particular guy, depending on how many things are in the map.

286
00:39:03,280 --> 00:39:18,280
Because they use trees or red, black trees and things like that. And closure does have sorted maps. The one you get from the literal representation like this is a hash map. And the expectation of a hash map is constant or near constant time lookup of values at keys.

287
00:39:18,280 --> 00:39:29,280
And that maps to hash tables. So what you have in the closure literal maps is the equivalent of a hash table. It's fast.

288
00:39:29,280 --> 00:39:31,280
Okay, so far?

289
00:39:31,280 --> 00:39:37,280
I think if I introduce another key, another key in this.

290
00:39:37,280 --> 00:39:38,280
Another key?

291
00:39:38,280 --> 00:39:40,280
A, A.

292
00:39:40,280 --> 00:39:42,280
It will be replaced. Do you want to?

293
00:39:42,280 --> 00:39:44,280
The last number replaced.

294
00:39:44,280 --> 00:39:49,280
Correct. There are only one instance of a key in a map. Is that your question?

295
00:39:49,280 --> 00:39:50,280
Yes.

296
00:39:50,280 --> 00:39:53,280
Yes, so if you were to say, the function that...

297
00:39:53,280 --> 00:39:56,280
No, I'm saying if I type it out like this.

298
00:39:56,280 --> 00:39:57,280
Yes?

299
00:39:57,280 --> 00:40:03,280
With the comma and up the cv with a again. Is it an error or is it just a replacement?

300
00:40:03,280 --> 00:40:13,280
It's probably a replacement. I say in the same thing, yes. I don't think it's an error. That's a good question. I might type it in later for you.

301
00:40:13,280 --> 00:40:17,280
Okay.

302
00:40:18,280 --> 00:40:23,280
Yeah, I mean...

303
00:40:23,280 --> 00:40:28,280
It's the same thing.

304
00:40:28,280 --> 00:40:35,280
Well, but there's no associated values. So Fred will be there. So let's talk about sets. The fourth thing I'm showing you here is sets.

305
00:40:35,280 --> 00:40:44,280
Sets are a set of unique values. Each value occurs only once in the set. And really the only thing the set can do for you is to tell you whether or not something's in it.

306
00:40:44,280 --> 00:40:49,280
There's no associated values. Just does the set contain this key? Do you have a question?

307
00:40:49,280 --> 00:40:50,280
Yes.

308
00:40:56,280 --> 00:41:06,280
There are sorted sets and hash sets. Same thing as with the maps. The sets here are hash sets. So no, the order is not retained.

309
00:41:06,280 --> 00:41:11,280
You can request a sorted set and the order will be the sort order.

310
00:41:11,280 --> 00:41:16,280
Does that answer your question? Okay.

311
00:41:16,280 --> 00:41:19,280
What is the test for equality?

312
00:41:19,280 --> 00:41:32,280
What is the test for equality? Equal. The equal sign is the test for equality. And equality means the same thing for everything in closure. It means equal value.

313
00:41:33,280 --> 00:41:43,280
You'll see that closure definitely de-emphasizes identity and completely. In fact, there is an identity function and I have yet to use it.

314
00:41:43,280 --> 00:41:57,280
Closure is about values. Identical contents are identical from by equals. That's made faster than you might imagine by caching hash values.

315
00:41:58,280 --> 00:42:01,280
But equality is equality of value in closure.

316
00:42:01,280 --> 00:42:05,280
And this immutability helps?

317
00:42:05,280 --> 00:42:15,280
Immutability helps certainly. Well, if you've ever read Henry Baker's paper on EGAL, closure implements EGAL. Finally.

318
00:42:15,280 --> 00:42:20,280
If you haven't, don't worry about it.

319
00:42:20,280 --> 00:42:23,280
So yes, equality is equality of value.

320
00:42:23,280 --> 00:42:28,280
All right. Yes. Hi, Rob.

321
00:42:28,280 --> 00:42:35,280
If you were going to Java, you would need an active Java?

322
00:42:35,280 --> 00:42:42,280
No, you can make arrays and you can interact with Java arrays that are arrays of either objects or native arrays.

323
00:42:42,280 --> 00:42:47,280
You can say float array and size and you'll get an array of floats.

324
00:42:47,280 --> 00:42:54,280
So you have the ability to do Java stuff. I'm going to emphasize the closure data structures because they let you do what closure lets you do.

325
00:42:54,280 --> 00:43:01,280
You can access Java, but if you start accessing mutable things, some of the things closure can do for you, we can't do.

326
00:43:01,280 --> 00:43:04,280
It doesn't mean you're not allowed to do them.

327
00:43:04,280 --> 00:43:09,280
But there's no point in me showing you how to interact with the Java, right? Except to show you the syntax, which I might later.

328
00:43:09,280 --> 00:43:15,280
So the last point about this is that everything nests. A key in a map can be another map. It can be a vector.

329
00:43:15,280 --> 00:43:24,280
Anything can be a key or a value. Because of this equality semantics, there's no problem having a vector or a map whose keys are vectors.

330
00:43:24,280 --> 00:43:32,280
That's perfectly fine. So if you needed to use tuples as keys, you know, pairs of things as keys, that's just completely doable.

331
00:43:32,280 --> 00:43:44,280
Well, you can get the hash of a vector.

332
00:43:58,280 --> 00:44:00,280
Correct? Right.

333
00:44:03,280 --> 00:44:12,280
Well, it depends on what you're doing. I would imagine that really complex structures are not frequently used as keys, but they could be.

334
00:44:12,280 --> 00:44:24,280
Can that be helped? Yes. The fact that these are hash by default means that once and once only the hash value of some aggregate structure will be calculated.

335
00:44:24,280 --> 00:44:32,280
And that will be cached. So there's a quick hash test. Otherwise, we do the deep value check.

336
00:44:32,280 --> 00:44:45,280
But again, I don't think you're going to encounter complex data structures as hash values that often, but using kind of small things like tuples or other small maps as keys is tremendously useful.

337
00:44:45,280 --> 00:44:50,280
It's really, really handy to not even have to think about that.

338
00:44:50,280 --> 00:45:00,280
I think we got one other closure program arrived. Who can possibly attest, independent of me, how closure's performance is? How's closure's performance?

339
00:45:00,280 --> 00:45:07,280
Fine to me, but I've actually been showing all of this.

340
00:45:07,280 --> 00:45:15,280
Right. Well, now there's some extra numeric goodness in there. But these data structures are pretty good. What's the reality?

341
00:45:15,280 --> 00:45:24,280
The reality of these data structures is I've tried to keep them all within one to four times a Java data structure, the equivalent Java data structure.

342
00:45:24,280 --> 00:45:32,280
In other words, hash map, vector. Well, similar lists are pretty straightforward.

343
00:45:32,280 --> 00:45:40,280
So they're within striking distance. The B side is in a concurrent program, there is no locking necessary for use with these data structures.

344
00:45:40,280 --> 00:45:47,280
If you want to make an incremental change through data structure in a certain context, there's no copying required to do that.

345
00:45:47,280 --> 00:45:52,280
So some of these other costs that would be very high with immutable data structure vanish.

346
00:45:52,280 --> 00:45:55,280
So you have to be very careful in looking at that.

347
00:45:55,280 --> 00:46:03,280
The other thing that's astounding to me, at least, is that the lookup time, again, the add times are higher than hash map.

348
00:46:03,280 --> 00:46:13,280
But the lookup times can be much better because this has better hash cash locality than a big array for hash table.

349
00:46:13,280 --> 00:46:23,280
Okay, we're all good on this. I probably have to move a little bit quicker. Yes, more quickly.

350
00:46:23,280 --> 00:46:29,280
There is destructuring. Yes, I actually won't get to talk about that today, but there is destructuring.

351
00:46:29,280 --> 00:46:36,280
There is not pattern matching. Okay, but there is destructuring to arbitrary depth of all of these.

352
00:46:36,280 --> 00:46:44,280
Destructuring means a way to easily say, I want to make this set of symbols that I express in a similar data structure,

353
00:46:44,280 --> 00:46:48,280
map to corresponding parts of a complex data structure on past.

354
00:46:48,280 --> 00:46:54,280
Clojure has that. It has some really neat destructuring capabilities.

355
00:46:54,280 --> 00:47:00,280
All right, so what's the syntax of closure? We just did it.

356
00:47:00,280 --> 00:47:10,280
I'm not going to talk about semicolons, curly braces, you know, when you have to say this, when you have to have a new line, or anything else.

357
00:47:10,280 --> 00:47:19,280
Because the structure of a closure program is a data structure or a series of data structures.

358
00:47:19,280 --> 00:47:27,280
There is no other stuff. There are no rules about where things go. There are no precedence rules. There's nothing else.

359
00:47:27,280 --> 00:47:34,280
You write a closure program by writing the data structures I just showed you. That's it.

360
00:47:34,280 --> 00:47:40,280
I'll show you.

361
00:47:40,280 --> 00:47:46,280
So you write a program by writing data structures. The data structures are the code.

362
00:47:46,280 --> 00:47:53,280
That has huge implications. It's, you know, it is the nature of LISP.

363
00:47:53,280 --> 00:47:58,280
There's a fancy name for it called Homo Iconicity.

364
00:47:58,280 --> 00:48:05,280
And it means that the representation of the program is done in the core data structures of the program.

365
00:48:05,280 --> 00:48:16,280
Which means that programs are amenable to processing by other programs because they're data structures.

366
00:48:16,280 --> 00:48:21,280
So I'm not going to talk anymore about text-based syntax because there is no more.

367
00:48:21,280 --> 00:48:26,280
Now, many people claim of LISPs, well, LISPs has no syntax. And that's not really true.

368
00:48:26,280 --> 00:48:30,280
It doesn't have all this little fiddly character syntax necessarily.

369
00:48:30,280 --> 00:48:35,280
There is syntax to the interpretation of the data structures.

370
00:48:35,280 --> 00:48:40,280
You know, in those, you're going to see a lot of lists. They have different things at the front.

371
00:48:40,280 --> 00:48:46,280
The thing at the front will tell you the meaning of the rest.

372
00:48:46,280 --> 00:48:51,280
All right. So let's talk a little bit about evaluations. How does this all work?

373
00:48:51,280 --> 00:48:56,280
This is, we should all know, from Java or many other languages like Java.

374
00:48:56,280 --> 00:49:01,280
It types our program into a text file and we save it.

375
00:49:01,280 --> 00:49:11,280
And then we send those characters of that text to the compiler who has a very involved, you know, abstract syntax tree

376
00:49:11,280 --> 00:49:15,280
and parser and lexer that interpret the rules of the language.

377
00:49:15,280 --> 00:49:18,280
This is what constitutes a character. This is what constitutes a number.

378
00:49:18,280 --> 00:49:25,280
And then furthermore, you know, if you've said if and you put parens and then you said some stuff and you put a semicolon

379
00:49:26,280 --> 00:49:29,280
and you're still in this construct called if, things like that.

380
00:49:29,280 --> 00:49:32,280
It knows all about that and it deals with the text.

381
00:49:32,280 --> 00:49:37,280
And it will tell you if you've met the requirements in terms of it being a valid program.

382
00:49:37,280 --> 00:49:40,280
And then it will turn it into something that can run.

383
00:49:40,280 --> 00:49:42,280
In the case of Java, that something will be bytecode.

384
00:49:42,280 --> 00:49:45,280
And it will go into a class file or a draw file. We know this.

385
00:49:45,280 --> 00:49:49,280
And then there's a separate step, which is called running.

386
00:49:49,280 --> 00:49:54,280
We take that stored executable representation and we ask it to happen.

387
00:49:54,280 --> 00:50:01,280
Usually, in this case, we'll say, you know, Java dash something, class file, and it will run.

388
00:50:01,280 --> 00:50:05,280
And it will run and then it will end and it will be over.

389
00:50:05,280 --> 00:50:09,280
And we could try again if we didn't like it.

390
00:50:09,280 --> 00:50:13,280
That's the traditional edit compile run.

391
00:50:13,280 --> 00:50:16,280
Be disappointed, start over.

392
00:50:17,280 --> 00:50:22,280
Oh, correct.

393
00:50:22,280 --> 00:50:25,280
I'm talking about the development process.

394
00:50:25,280 --> 00:50:29,280
But yes, the runtime is just that long.

395
00:50:34,280 --> 00:50:41,280
Until you realize it's not working and you have to ask everybody to please wait for our downage while we fix it.

396
00:50:41,280 --> 00:50:44,280
That's the difference.

397
00:50:44,280 --> 00:50:53,280
If you read about Erlang, which is getting a lot of press, they'll tell you about phone switches and how that's really not allowed.

398
00:50:53,280 --> 00:51:00,280
And Lisp was doing this for a very long time, this kind of live hot swapping of code and running systems.

399
00:51:00,280 --> 00:51:07,280
I think it goes more, in this case, it's less about the production thing than it is about what's the nature of developing a program.

400
00:51:07,280 --> 00:51:12,280
Because as a developer, you know, seeing it run and saying, ooh, that was bad.

401
00:51:12,280 --> 00:51:13,280
I wonder what happened.

402
00:51:13,280 --> 00:51:15,280
I wish I had run it in debug mode.

403
00:51:15,280 --> 00:51:18,280
I wish I had put a breakpoint somewhere interesting.

404
00:51:18,280 --> 00:51:26,280
And I'm really sad that I spent an hour calculating that data and dropped it on the floor because I have to do it again with the breakpoint in.

405
00:51:26,280 --> 00:51:36,280
That's a lot different experience than keeping your program around and having that data stay loaded and fixing your function and running it again without starting over.

406
00:51:36,280 --> 00:51:39,280
So that's what happens in closure.

407
00:51:39,280 --> 00:51:42,280
You take the code, text could be characters.

408
00:51:42,280 --> 00:51:48,280
There is character representation and what you showed there can be represented in characters in ASCII.

409
00:51:48,280 --> 00:51:51,280
It does not go first to the evaluator.

410
00:51:51,280 --> 00:51:53,280
It goes to something called the reader.

411
00:51:53,280 --> 00:52:00,280
And this is the core part of what makes something a Lisp, which is that the reader has a very simple job.

412
00:52:00,280 --> 00:52:02,280
Its job is to take the description.

413
00:52:02,280 --> 00:52:10,280
I just told you, you know, keyword starts with a colon and a list is in parentheses and a map is in curly braces and it's pairs of stuff.

414
00:52:10,280 --> 00:52:14,280
Its job is to take those characters and turn it into data structures.

415
00:52:14,280 --> 00:52:22,280
The data structures I described, you start with the parent, you say stuff, you close the parent, that's going to become a list when the reader is done with it.

416
00:52:22,280 --> 00:52:25,280
You start with square brackets, that's going to become a vector when the reader is done with it.

417
00:52:25,280 --> 00:52:28,280
So what comes out of the reader are data structures.

418
00:52:28,280 --> 00:52:35,280
And what's unique about a Lisp enclosure is that the compiler compiles data structures.

419
00:52:35,280 --> 00:52:37,280
It does not compile text.

420
00:52:37,280 --> 00:52:40,280
It never sees text.

421
00:52:40,280 --> 00:52:48,280
What the compiler gets handed is maybe a list with three symbols in it or a vector with five numbers in it.

422
00:52:48,280 --> 00:52:50,280
That's actually what the compiler has.

423
00:52:50,280 --> 00:52:56,280
It has a data structure in hand with actual data in it, not text.

424
00:52:56,280 --> 00:53:00,280
And it compiles it and in the case of closure, it is a compiler.

425
00:53:00,280 --> 00:53:07,280
There are many, well, there are actually many lists that are interpreters, but many people believe that Lisp is interpreted.

426
00:53:07,280 --> 00:53:16,280
It's certainly easy to make an interpreter for Lisp that would take those data structures and on the fly produce the values they imply.

427
00:53:17,280 --> 00:53:26,280
But closure is a compiler and in particular closure compiles those data structures to Java bytecode right away.

428
00:53:26,280 --> 00:53:29,280
There is no interpretation in closure.

429
00:53:29,280 --> 00:53:35,280
So it's a compiler that produces bytecode just like Java C does.

430
00:53:35,280 --> 00:53:44,280
And because it's an interactive environment, it presents that bytecode right away to the JVM to execute.

431
00:53:44,280 --> 00:53:48,280
And it executes right away and you can see the effect.

432
00:53:52,280 --> 00:53:55,280
When you're in the REPL, you have AVM, right?

433
00:53:55,280 --> 00:53:57,280
You have one thing.

434
00:53:57,280 --> 00:54:00,280
So yes, your environment is your program.

435
00:54:00,280 --> 00:54:03,280
Your compiler is in your program.

436
00:54:03,280 --> 00:54:05,280
Yes.

437
00:54:06,280 --> 00:54:17,280
Yeah, most commercial lists give you tools to take out the compiler in production, mostly because they don't want you giving away their compiler.

438
00:54:17,280 --> 00:54:24,280
Normally, there's no reason to prevent that because it's a useful thing to have, particularly when you want to load code later to fix problems.

439
00:54:24,280 --> 00:54:26,280
You're going to need that compiler there.

440
00:54:26,280 --> 00:54:29,280
So in closure, there's no strip out the compiler option.

441
00:54:30,280 --> 00:54:39,280
We'll see that there is a core of closure.

442
00:54:39,280 --> 00:54:42,280
The data structures are written in Java.

443
00:54:42,280 --> 00:54:45,280
The special operators are written in Java.

444
00:54:45,280 --> 00:54:49,280
And then most of the rest of closure is written in closure.

445
00:54:49,280 --> 00:54:51,280
There's no native code.

446
00:54:51,280 --> 00:54:53,280
There's no native code.

447
00:54:53,280 --> 00:54:56,280
Closure is completely a pure Java project.

448
00:54:57,280 --> 00:54:58,280
There's no native code.

449
00:54:58,280 --> 00:54:59,280
There's no C libraries.

450
00:54:59,280 --> 00:55:06,280
It's all Java, either generated by Java itself or generated by closure.

451
00:55:06,280 --> 00:55:12,280
It does not turn off the verifier or anything like that in order to get performances.

452
00:55:12,280 --> 00:55:14,280
There have been some schemes that tried to do that.

453
00:55:14,280 --> 00:55:16,280
Closure is completely legit that way.

454
00:55:16,280 --> 00:55:22,280
So when we have this separation of concerns between the reader and the evaluator, we get a couple of things.

455
00:55:22,280 --> 00:55:27,280
One of the other things we get is we don't have to get the text from a file, right?

456
00:55:27,280 --> 00:55:29,280
We can get it right from you.

457
00:55:29,280 --> 00:55:32,280
You just saw me type right into the REPL, an expression.

458
00:55:32,280 --> 00:55:35,280
Never went through a file, never got stored.

459
00:55:35,280 --> 00:55:40,280
So the first thing you get is this kind of interactivity of you can just type in stuff and say go.

460
00:55:40,280 --> 00:55:41,280
That's a big deal.

461
00:55:41,280 --> 00:55:51,280
I mean, if you've been programming in Java or C++ long enough to remember when the debuggers didn't give you the ability to evaluate expressions at a break point,

462
00:55:51,280 --> 00:55:54,280
you can't remember how hard that was.

463
00:55:54,280 --> 00:56:00,280
You always have that capability here to have expressions directly evaluated.

464
00:56:00,280 --> 00:56:02,280
What else do we get from this?

465
00:56:02,280 --> 00:56:06,280
Well, we get the ability to skip the characters completely.

466
00:56:06,280 --> 00:56:17,280
For instance, it's quite possible to write a program that generates the data structures that the compiler wants to see and have it send them to the compiler to be evaluated.

467
00:56:17,280 --> 00:56:23,280
Program generating programs are a common thing in this kind of an environment.

468
00:56:23,280 --> 00:56:29,280
Whereas this kind of stuff when you're doing it with text is really messy.

469
00:56:29,280 --> 00:56:34,280
By the way, what observation does Charlie actually give a good way to make the same?

470
00:56:34,280 --> 00:56:40,280
The art forms I know, because of compliance requirements that they have,

471
00:56:40,280 --> 00:56:49,280
we might be very comfortable with code producing stuff going into a reader or a programmer against a programmer that produces stuff.

472
00:56:49,280 --> 00:57:01,280
But is that option of saying it's always like the first in this production environment in the influence of COVID to be as a security problem?

473
00:57:01,280 --> 00:57:07,280
Well, I mean, that's a security policy thing, whether or not you expose this in a production system.

474
00:57:07,280 --> 00:57:10,280
So I'm talking about you could if you needed to.

475
00:57:10,280 --> 00:57:17,280
You could have that over a secure soccer channel and have it be just an administrator who knows what they're doing, have that capability.

476
00:57:17,280 --> 00:57:19,280
Because the alternative is downing your system.

477
00:57:19,280 --> 00:57:25,280
If you don't have that, and of course, opening this in a production system, that's completely a policy thing.

478
00:57:25,280 --> 00:57:26,280
It has nothing to do with the language.

479
00:57:26,280 --> 00:57:29,280
Except if your language doesn't let you do it, you can't do it.

480
00:57:29,280 --> 00:57:30,280
That's fair.

481
00:57:30,280 --> 00:57:32,280
So it does.

482
00:57:32,280 --> 00:57:36,280
The other thing is that these data structures, you might write this program and have this happen directly.

483
00:57:36,280 --> 00:57:38,280
Then you might say, I like this program.

484
00:57:38,280 --> 00:57:43,280
Let me take those data structures and there's a thing called the printer, which will turn them back into that,

485
00:57:43,280 --> 00:57:47,280
which you could store and so they could sign off on and say this is the canonic program,

486
00:57:47,280 --> 00:57:50,280
which our program generated that we're going to use.

487
00:57:50,280 --> 00:57:53,280
And we'll lock that down and do whatever.

488
00:57:53,280 --> 00:57:54,280
Yes?

489
00:57:54,280 --> 00:57:58,280
So are the data structures physical files?

490
00:57:58,280 --> 00:58:01,280
No, they're in memory data structures.

491
00:58:01,280 --> 00:58:04,280
The ones your program would see.

492
00:58:04,280 --> 00:58:13,280
So, you know, an instance of closure laying persistent vector to the compiler.

493
00:58:13,280 --> 00:58:17,280
The compiler's got to deal with it, figure it out.

494
00:58:17,280 --> 00:58:23,280
So there's one more thing that this allows, and this is the secret sauce of all lists, including closure,

495
00:58:23,280 --> 00:58:25,280
which is what would happen.

496
00:58:25,280 --> 00:58:29,280
I mean, it's fine to sit standalone and write a program that generates a program.

497
00:58:29,280 --> 00:58:32,280
But what would happen if we said, you know what?

498
00:58:32,280 --> 00:58:35,280
We're handing these data structures to the compiler.

499
00:58:35,280 --> 00:58:41,280
It would be great if the compiler would let us participate in this.

500
00:58:41,280 --> 00:58:43,280
If they could send us the data structures.

501
00:58:43,280 --> 00:58:50,280
When we write a real program, a very small program, and give it back different data structures,

502
00:58:50,280 --> 00:58:56,280
then we could participate very easily in the extension of our language.

503
00:58:56,280 --> 00:59:00,280
Because this compiler, it's going to know how to do with those types of data.

504
00:59:00,280 --> 00:59:02,280
It's going to know what to do with the vector.

505
00:59:02,280 --> 00:59:06,280
It's going to know what if means and a couple of other things.

506
00:59:06,280 --> 00:59:10,280
But there'll be new things that we'll think of that we'd love to be able to set.

507
00:59:10,280 --> 00:59:16,280
When you have something you'd love to be able to say in Java, what do you have to do with it?

508
00:59:16,280 --> 00:59:23,280
You have to beg, son, and wait for years and hope other people beg for the same things and you get it.

509
00:59:23,280 --> 00:59:25,280
That's it.

510
00:59:25,280 --> 00:59:27,280
You have no say.

511
00:59:27,280 --> 00:59:35,280
You have no ability to shape the language unless that's completely not what it's about.

512
00:59:35,280 --> 00:59:37,280
It's about getting you in the loop.

513
00:59:37,280 --> 00:59:42,280
And in fact, the language itself has a well-defined way for you to say,

514
00:59:42,280 --> 00:59:45,280
this is a little program I'd like you to run.

515
00:59:45,280 --> 00:59:50,280
When you encounter this name, I don't want you to evaluate it by the way.

516
00:59:50,280 --> 00:59:52,280
I'd like you to send me that data structure.

517
00:59:52,280 --> 00:59:54,280
I know what to do with it.

518
00:59:54,280 --> 00:59:59,280
I'm going to give you back a different data structure and you evaluate that.

519
00:59:59,280 --> 01:00:01,280
That's called a macro.

520
01:00:01,280 --> 01:00:10,280
And it is what gives lists and closure syntactic abstraction and syntactic extensibility.

521
01:00:10,280 --> 01:00:13,280
Can that happen in the context of the namespace?

522
01:00:13,280 --> 01:00:15,280
Yes, it can.

523
01:00:15,280 --> 01:00:23,280
There are namespaces in enclosure and they allow me to have my cool function and you to have your cool function.

524
01:00:23,280 --> 01:00:25,280
Cool function.

525
01:00:25,280 --> 01:00:27,280
Yes.

526
01:00:27,280 --> 01:00:32,280
So that's what makes Lisp amazing.

527
01:00:32,280 --> 01:00:36,280
It's something that I won't have time to dig deeply into tonight.

528
01:00:36,280 --> 01:00:41,280
If you can come away with at least the understanding that that's how it works, that's how it's possible.

529
01:00:41,280 --> 01:00:45,280
And the fact that these are data structures here makes it easy.

530
01:00:45,280 --> 01:00:50,280
You could theoretically say, oh, I could write something and if the compiler could hand me the abstract syntax tree,

531
01:00:50,280 --> 01:00:53,280
I could navigate it with some custom API and do whatever.

532
01:00:53,280 --> 01:00:58,280
It's not nearly the same, though, when what the compiler is handing you are those three data structures.

533
01:00:58,280 --> 01:01:08,280
I just showed you that every program knows how to manipulate and has a wildly huge library that directly can manipulate.

534
01:01:08,280 --> 01:01:10,280
So that's how Lisp works.

535
01:01:10,280 --> 01:01:13,280
I'm going to try to speed it up a little bit.

536
01:01:13,280 --> 01:01:17,280
In closure, unlike Java, everything is an expression.

537
01:01:17,280 --> 01:01:22,280
So you know in Java there's a difference between declarations and statements and expressions.

538
01:01:22,280 --> 01:01:24,280
There's no distinction in closure.

539
01:01:24,280 --> 01:01:26,280
Everything is an expression.

540
01:01:26,280 --> 01:01:27,280
Everything has value.

541
01:01:27,280 --> 01:01:29,280
Everything gets evaluated and produces a value.

542
01:01:29,280 --> 01:01:35,280
Sometimes that value is nil, not particularly meaningful, but everything is an expression.

543
01:01:35,280 --> 01:01:42,280
So the job of the compiler is to look at the data structures and evaluate them.

544
01:01:42,280 --> 01:01:45,280
There's a really simple rule for that.

545
01:01:45,280 --> 01:01:49,280
It's slightly oversimplified, but in general you can understand it this way.

546
01:01:49,280 --> 01:01:59,280
All those data literals I showed you, right, symbols, numbers, character literals, vectors, maps, sets,

547
01:01:59,280 --> 01:02:11,280
are all evaluated by the compiler to represent themselves, except lists and symbols.

548
01:02:11,280 --> 01:02:15,280
Lists and symbols by default are treated specially by the evaluator.

549
01:02:15,280 --> 01:02:20,280
So when it reads a list of symbols in particular, it's going to do some work.

550
01:02:20,280 --> 01:02:23,280
It's not just going to return the list of symbols to your program.

551
01:02:23,280 --> 01:02:29,280
It's going to try to understand them as an operation, which I'll show you in a second.

552
01:02:29,280 --> 01:02:38,280
So symbols are going to try to, the compiler is going to try to map to values, like variables.

553
01:02:38,280 --> 01:02:41,280
You know in a variable you can say int i equals five.

554
01:02:41,280 --> 01:02:44,280
Later in your program in Java you say i.

555
01:02:44,280 --> 01:02:47,280
Java is going to try to figure out, oh, that's five.

556
01:02:47,280 --> 01:02:49,280
That's the i you set up there.

557
01:02:49,280 --> 01:02:50,280
Same thing in closure.

558
01:02:50,280 --> 01:02:56,280
When you use a symbol in your data structure, closure is going to try to find a value that's been associated with that symbol.

559
01:02:56,280 --> 01:03:02,280
It can be associated with it through a construct called let, sort of the way you create a local name,

560
01:03:02,280 --> 01:03:07,280
or through def, which is the way you create a global name.

561
01:03:07,280 --> 01:03:11,280
So before it's a list, and it's going to say this is an operation of some sort.

562
01:03:11,280 --> 01:03:15,280
I have to figure out what to do with a list.

563
01:03:15,280 --> 01:03:17,280
So how does that work?

564
01:03:17,280 --> 01:03:19,280
Well, again, we said what's the data structure?

565
01:03:19,280 --> 01:03:24,280
It's friends, it starts with something, it may have more stuff or not.

566
01:03:24,280 --> 01:03:29,280
But from the evaluator standpoint, all that matters is the first thing.

567
01:03:29,280 --> 01:03:33,280
The first thing is the operator, or op.

568
01:03:33,280 --> 01:03:36,280
That's going to determine what to do.

569
01:03:36,280 --> 01:03:38,280
And it can be one of three things.

570
01:03:38,280 --> 01:03:41,280
It can be a special op.

571
01:03:41,280 --> 01:03:42,280
This is magic.

572
01:03:42,280 --> 01:03:47,280
This is the stuff that's built into the compiler upon which everything else is bootstrapped.

573
01:03:47,280 --> 01:03:49,280
So some things are special.

574
01:03:49,280 --> 01:03:52,280
I'm going to enumerate them in a second.

575
01:03:52,280 --> 01:03:54,280
It can be a macro like we saw before.

576
01:03:54,280 --> 01:04:01,280
There's a way to register with the compiler to say, when you see the op, my cool thing,

577
01:04:01,280 --> 01:04:05,280
go over here and run this function, which is going to give you something to use

578
01:04:05,280 --> 01:04:08,280
in place of the my cool thing call.

579
01:04:08,280 --> 01:04:12,280
And the third thing it could be is an ordinary expression.

580
01:04:12,280 --> 01:04:16,280
It's going to use the normal means of evaluating an expression.

581
01:04:16,280 --> 01:04:20,280
And it's going to say whatever value that yields on a treat as a function

582
01:04:20,280 --> 01:04:24,280
and attempt to call with the calling mechanism of closure,

583
01:04:24,280 --> 01:04:30,280
which is not limited to functions, but it's main purposes for functions.

584
01:04:31,280 --> 01:04:36,280
So for people who know lists, closure is a list one.

585
01:04:36,280 --> 01:04:40,280
It is a list one that supports def macro well.

586
01:04:40,280 --> 01:04:47,280
And the use of namespaces and the way back quote works makes that possible.

587
01:04:47,280 --> 01:04:49,280
And everyone else can ignore that.

588
01:04:49,280 --> 01:04:52,280
In a way, back legs pull the bunch.

589
01:04:52,280 --> 01:04:57,280
An expression in the genome is a function as opposed to it's the function.

590
01:04:57,280 --> 01:05:01,280
Well, what it's going to encounter is it's going to encounter a list

591
01:05:01,280 --> 01:05:03,280
and the first thing is going to be the symbol Fred.

592
01:05:03,280 --> 01:05:07,280
Fred is not a special operator, no Fred enclosure.

593
01:05:07,280 --> 01:05:11,280
Let's say no one has registered a macro called Fred.

594
01:05:11,280 --> 01:05:13,280
Then it's going to use the rules we said before.

595
01:05:13,280 --> 01:05:17,280
What about symbols to find the value of Fred?

596
01:05:17,280 --> 01:05:21,280
Where hopefully someone before has said, Fred is this function.

597
01:05:22,280 --> 01:05:26,280
It will keep evaluating.

598
01:05:26,280 --> 01:05:28,280
It's going to evaluate that expression.

599
01:05:28,280 --> 01:05:33,280
But there are other function like things or callable things in closure

600
01:05:33,280 --> 01:05:34,280
in addition to functions.

601
01:05:34,280 --> 01:05:36,280
I'll show you that in a second.

602
01:05:36,280 --> 01:05:38,280
So let's dig down into each of these three pieces.

603
01:05:38,280 --> 01:05:39,280
Yes.

604
01:05:39,280 --> 01:05:41,280
It doesn't encounter any one of those three.

605
01:05:41,280 --> 01:05:45,280
You have an error at runtime.

606
01:05:45,280 --> 01:05:47,280
It'll say it's not a function.

607
01:05:47,280 --> 01:05:49,280
Effectively what will happen is it will say this is not a function.

608
01:05:49,280 --> 01:05:54,280
If you said Fred is deaf Fred one, so Fred is the number one

609
01:05:54,280 --> 01:05:57,280
and you've tried to call Fred or use Fred as an operator,

610
01:05:57,280 --> 01:05:59,280
it's going to say one is not a function.

611
01:05:59,280 --> 01:06:05,280
Probably with a not very illuminating stack trace.

612
01:06:09,280 --> 01:06:11,280
Okay, so special operators.

613
01:06:11,280 --> 01:06:12,280
There are very few.

614
01:06:12,280 --> 01:06:14,280
I think one of the things that's really cool about lists

615
01:06:14,280 --> 01:06:18,280
and it's also cool about closure is you can define most of them

616
01:06:18,280 --> 01:06:20,280
in terms of themselves.

617
01:06:20,280 --> 01:06:23,280
One of the great brilliant things that John McCarthy did

618
01:06:23,280 --> 01:06:28,280
when he invented lists was figure out that with only I think seven primitives,

619
01:06:28,280 --> 01:06:32,280
you could define the evaluator for those seven primitives

620
01:06:32,280 --> 01:06:34,280
and everything you could build on them.

621
01:06:34,280 --> 01:06:37,280
Like the core of computation.

622
01:06:37,280 --> 01:06:40,280
It still gives me goosebumps when I say that.

623
01:06:40,280 --> 01:06:43,280
It is a beautiful thing.

624
01:06:43,280 --> 01:06:44,280
It really is.

625
01:06:44,280 --> 01:06:48,280
And if you've never looked at the lambda calculus or at least from that perspective,

626
01:06:48,280 --> 01:06:50,280
it's quite stunning.

627
01:06:50,280 --> 01:06:57,280
These early papers are just great and they're just brilliant in a transparent way.

628
01:06:57,280 --> 01:06:58,280
So let's look at a couple.

629
01:06:58,280 --> 01:07:01,280
I'm going to show you two and then I'm going to list the rest.

630
01:07:01,280 --> 01:07:02,280
Deaf would be one.

631
01:07:02,280 --> 01:07:06,280
How do we establish a value for a name?

632
01:07:06,280 --> 01:07:09,280
There's this special operator called deaf.

633
01:07:09,280 --> 01:07:10,280
It takes a name.

634
01:07:10,280 --> 01:07:13,280
Now that name is going to be a symbol.

635
01:07:13,280 --> 01:07:18,280
Obviously, that can't be evaluated, right?

636
01:07:18,280 --> 01:07:22,280
Because the whole purpose of this special operator is to give it a value.

637
01:07:22,280 --> 01:07:26,280
If the compiler were to use normal evaluation, the name position,

638
01:07:26,280 --> 01:07:30,280
you'd have a problem because you're trying to define what it means.

639
01:07:30,280 --> 01:07:31,280
How could you do that?

640
01:07:31,280 --> 01:07:35,280
So one of the things about special operators that you have to remember,

641
01:07:35,280 --> 01:07:42,280
and it's true of macros as well, is they can have non-normal evaluation of their arguments.

642
01:07:42,280 --> 01:07:44,280
Like, the arguments might not be evaluated.

643
01:07:44,280 --> 01:07:47,280
In fact, deaf doesn't evaluate the name.

644
01:07:47,280 --> 01:07:52,280
It uses it as a symbol and it associates that symbol with the value.

645
01:07:52,280 --> 01:07:55,280
It does not evaluate the symbol.

646
01:07:55,280 --> 01:08:00,280
So this is a simple way to say, if I say deaf name, some expression,

647
01:08:00,280 --> 01:08:04,280
the expression will be evaluated, the name will be mapped to that value

648
01:08:04,280 --> 01:08:06,280
or bound to that value.

649
01:08:06,280 --> 01:08:09,280
When you later go and say name, you'll get the value.

650
01:08:09,280 --> 01:08:11,280
It was used to initialize it.

651
01:08:12,280 --> 01:08:17,280
You actually can do that more than once.

652
01:08:17,280 --> 01:08:21,280
You shouldn't do that more than once unless you're trying to fix something.

653
01:08:21,280 --> 01:08:24,280
In other words, deaf should not be used as set.

654
01:08:24,280 --> 01:08:29,280
But you can use deaf to define a function and later you can use it again to fix it.

655
01:08:29,280 --> 01:08:33,280
So the things that are defined by deaf are mutable at the root

656
01:08:33,280 --> 01:08:41,280
and it's probably, you know, it's the only escape hatch for that dynamic change enclosure.

657
01:08:41,280 --> 01:08:47,280
That's not governed by transactions or some other mechanism.

658
01:08:47,280 --> 01:08:50,280
Okay, so it establishes a global variable.

659
01:08:50,280 --> 01:08:51,280
Again, there are namespaces.

660
01:08:51,280 --> 01:08:54,280
I don't have the time to talk about them, but it's all subject to a namespace.

661
01:08:54,280 --> 01:08:57,280
If you're in a namespace and you define the name, then it's in your namespace.

662
01:08:57,280 --> 01:08:59,280
It's distinct from that same name in another namespace.

663
01:08:59,280 --> 01:09:02,280
Namespaces are not the same as packages in CommonList.

664
01:09:02,280 --> 01:09:04,280
They're very much different in particular.

665
01:09:04,280 --> 01:09:07,280
Symbols are not inherently in a namespace.

666
01:09:07,280 --> 01:09:11,280
Symbols have no value, sell, they're not places.

667
01:09:11,280 --> 01:09:13,280
They're just labels.

668
01:09:13,280 --> 01:09:18,280
And there are vars, which are the places more like CommonList symbols.

669
01:09:20,280 --> 01:09:22,280
If is another thing that's built in.

670
01:09:22,280 --> 01:09:27,280
And if you think about if in your language, which you may not have ever done.

671
01:09:27,280 --> 01:09:31,280
If you thought about if is, why couldn't if be a function?

672
01:09:31,280 --> 01:09:37,280
Why can't I say if some test expression, some expression, some else expression?

673
01:09:37,280 --> 01:09:39,280
Why can't if be a function?

674
01:09:39,280 --> 01:09:40,280
I mean, it looks like a function.

675
01:09:40,280 --> 01:09:45,280
Well, it doesn't actually look like a function in Java, but why can't it be a function?

676
01:09:45,280 --> 01:09:55,280
It should only evaluate one of these two.

677
01:09:56,280 --> 01:09:57,280
That's why.

678
01:09:57,280 --> 01:09:59,280
And a function evaluates what?

679
01:09:59,280 --> 01:10:01,280
All of its arguments.

680
01:10:01,280 --> 01:10:07,280
So if you try to write if as a function, you would have a problem because functions evaluate all their arguments.

681
01:10:07,280 --> 01:10:11,280
So if has to be special, and if is special in closure too.

682
01:10:11,280 --> 01:10:13,280
It evaluates the test expression.

683
01:10:13,280 --> 01:10:19,280
And then, depending on the truth or falsity of this in kind of a generic sense,

684
01:10:19,280 --> 01:10:26,280
in closure, if this is nil or false, it will evaluate that.

685
01:10:26,280 --> 01:10:29,280
If it's anything else, it will evaluate this.

686
01:10:29,280 --> 01:10:33,280
But it will only evaluate one of those two things.

687
01:10:33,280 --> 01:10:35,280
It must have a false.

688
01:10:35,280 --> 01:10:37,280
No, it doesn't have to.

689
01:10:37,280 --> 01:10:41,280
The else can be missing in which case it defaults to nil.

690
01:10:41,280 --> 01:10:45,280
So if is another example of something that has to be special.

691
01:10:45,280 --> 01:10:47,280
It can't evaluate all of its arguments.

692
01:10:47,280 --> 01:10:51,280
And then we have these others.

693
01:10:51,280 --> 01:10:53,280
In fact, this is it.

694
01:10:53,280 --> 01:10:56,280
There's something that defines a function.

695
01:10:56,280 --> 01:11:01,280
Something that establishes names in a local scope.

696
01:11:01,280 --> 01:11:06,280
A pair of things that allow you to do functional looping.

697
01:11:06,280 --> 01:11:08,280
To create a loop in your program.

698
01:11:08,280 --> 01:11:13,280
Something that lets you create a block of statements the last of which will be the value.

699
01:11:13,280 --> 01:11:16,280
It allocates a new Java thing.

700
01:11:16,280 --> 01:11:19,280
Access to members of Java thing.

701
01:11:19,280 --> 01:11:24,280
Throw, try, do what you expect from Java.

702
01:11:24,280 --> 01:11:28,280
Set, will rebind a value.

703
01:11:28,280 --> 01:11:32,280
And code bar are kind of a special purpose for list manipulation things.

704
01:11:32,280 --> 01:11:34,280
So I'm not going to get into them tonight.

705
01:11:34,280 --> 01:11:35,280
Question.

706
01:11:35,280 --> 01:11:37,280
Is that the entire list of?

707
01:11:37,280 --> 01:11:38,280
Yeah.

708
01:11:38,280 --> 01:11:40,280
So what's the equivalent of death macro?

709
01:11:40,280 --> 01:11:45,280
Death macro is bootstrapped on this.

710
01:11:45,280 --> 01:11:49,280
So there's a key border.

711
01:11:49,280 --> 01:11:51,280
Oh no, there is death macro.

712
01:11:51,280 --> 01:11:56,280
It's defined a couple of pages into the boot script for closure, which I might show you.

713
01:11:56,280 --> 01:11:58,280
We have some time.

714
01:11:58,280 --> 01:11:59,280
Yes.

715
01:11:59,280 --> 01:12:00,280
I'm just intrigued.

716
01:12:00,280 --> 01:12:04,280
The reason for the explanation point of the set is it trying to say something to the program?

717
01:12:04,280 --> 01:12:06,280
Yeah, this is bad.

718
01:12:06,280 --> 01:12:07,280
Why are you doing this for?

719
01:12:08,280 --> 01:12:12,280
Yes.

720
01:12:16,280 --> 01:12:18,280
No, it ends up that enclosure.

721
01:12:18,280 --> 01:12:21,280
Macros are functions.

722
01:12:21,280 --> 01:12:32,280
And so there's just a way to say this function is a macro and it will be treated as a macro instead of as a function.

723
01:12:32,280 --> 01:12:33,280
Okay.

724
01:12:33,280 --> 01:12:36,280
So that's a tiny set of things.

725
01:12:36,280 --> 01:12:40,280
In fact, when you take out the stuff related to Java, it's an extremely tiny set.

726
01:12:40,280 --> 01:12:42,280
I don't think I made it down to seven.

727
01:12:42,280 --> 01:12:47,280
One, two, three, four, five, six, seven, eight.

728
01:12:47,280 --> 01:12:49,280
I have more than more properties.

729
01:12:49,280 --> 01:12:52,280
But I don't have dozens.

730
01:12:52,280 --> 01:12:54,280
So how could this possibly work?

731
01:12:54,280 --> 01:12:58,280
This is not enough to program with this.

732
01:12:58,280 --> 01:13:00,280
No.

733
01:13:00,280 --> 01:13:01,280
No, no, no.

734
01:13:01,280 --> 01:13:03,280
So we need macros.

735
01:13:03,280 --> 01:13:04,280
Okay.

736
01:13:04,280 --> 01:13:09,280
There are plenty supplied with closure.

737
01:13:09,280 --> 01:13:17,280
And what's beautiful about closure and LISPs is you have the same power that I have to write macros.

738
01:13:17,280 --> 01:13:24,280
When you see the kinds of things that are implemented in closure as macros, you realize the kind of power you have as a developer

739
01:13:24,280 --> 01:13:26,280
because you can write those same macros.

740
01:13:26,280 --> 01:13:28,280
You could have written them.

741
01:13:28,280 --> 01:13:30,280
You don't have to wait for me.

742
01:13:30,280 --> 01:13:32,280
I'm not son.

743
01:13:32,280 --> 01:13:33,280
This is not Java.

744
01:13:33,280 --> 01:13:34,280
You want to do something.

745
01:13:34,280 --> 01:13:36,280
You have something you want to express a certain way.

746
01:13:36,280 --> 01:13:38,280
You want to extend the language that way.

747
01:13:38,280 --> 01:13:45,280
If you can do it with a macro, you can do it without contacting me or asking me for the favor of adding a feature for you,

748
01:13:45,280 --> 01:13:48,280
which means the language is much more extensible by programs.

749
01:13:48,280 --> 01:13:51,280
So let's look a little bit about how they work.

750
01:13:51,280 --> 01:13:56,280
If we remember, we're getting data structures passed in the compiler.

751
01:13:56,280 --> 01:14:01,280
So it looked at the first thing, and somehow there's a way, and I can't show you that tonight,

752
01:14:01,280 --> 01:14:04,280
to say this name designates a macro.

753
01:14:04,280 --> 01:14:08,280
And associated with that name, then, is a function.

754
01:14:08,280 --> 01:14:13,280
The function expects to be passed the rest of the stuff that's in the parentheses.

755
01:14:13,280 --> 01:14:17,280
So we had this cool function, my cool macro.

756
01:14:17,280 --> 01:14:20,280
Maybe it expects to be passed two things.

757
01:14:20,280 --> 01:14:22,280
The things that gets passed are not evaluated.

758
01:14:22,280 --> 01:14:26,280
It gets passed the data structures that the compiler got passed.

759
01:14:26,280 --> 01:14:30,280
Because the compiler is going to say, you told me you know how to do this.

760
01:14:30,280 --> 01:14:32,280
Here are the data structures.

761
01:14:32,280 --> 01:14:36,280
Give me back the data structure I should be processing.

762
01:14:36,280 --> 01:14:43,280
So it's a transformation process where the macro is handed the data that's inside the parentheses,

763
01:14:43,280 --> 01:14:46,280
as arguments to the function that the macro is.

764
01:14:46,280 --> 01:14:55,280
It will run any arbitrary program you want to convert that data structure into a different data structure.

765
01:14:55,280 --> 01:14:58,280
You can write macros that look stuff up in databases.

766
01:14:58,280 --> 01:15:03,280
That go and ask a rule-based system for advice.

767
01:15:03,280 --> 01:15:05,280
Most are not that complicated.

768
01:15:05,280 --> 01:15:08,280
But the thing is, it's an arbitrary program transformation.

769
01:15:08,280 --> 01:15:10,280
There's not a pattern language.

770
01:15:10,280 --> 01:15:12,280
There's not a set of rules about this can be turned into that.

771
01:15:12,280 --> 01:15:15,280
It's an arbitrary program, a macro.

772
01:15:15,280 --> 01:15:19,280
And in this way, it's like a common list macro.

773
01:15:19,280 --> 01:15:24,280
That, given the data structure, gives back its own replacement.

774
01:15:24,280 --> 01:15:28,280
Replace me, the expression that began with me, with this.

775
01:15:28,280 --> 01:15:30,280
And then keep going.

776
01:15:30,280 --> 01:15:33,280
Which may yield another macro and another round of matter.

777
01:15:33,280 --> 01:15:36,280
It may yield something that already knows how to process.

778
01:15:36,280 --> 01:15:37,280
Yes?

779
01:15:37,280 --> 01:15:42,280
So would it be correct to say that a general macro is happening around that problem?

780
01:15:42,280 --> 01:15:45,280
No, this is happening at compile time.

781
01:15:45,280 --> 01:15:47,280
This is part of compilation, right?

782
01:15:47,280 --> 01:15:49,280
The compiler got handed this data structure.

783
01:15:49,280 --> 01:15:52,280
It said, oh, it begins with the macro name.

784
01:15:52,280 --> 01:15:53,280
Hands it to the macro.

785
01:15:53,280 --> 01:15:54,280
It comes back.

786
01:15:54,280 --> 01:15:55,280
That transformation occurs.

787
01:15:55,280 --> 01:15:57,280
It keeps compiling.

788
01:15:57,280 --> 01:15:58,280
Then you get bytecode.

789
01:15:58,280 --> 01:16:01,280
After you get bytecode, there's no more talking to the macro.

790
01:16:01,280 --> 01:16:04,280
So macros replace themselves with another data structure.

791
01:16:04,280 --> 01:16:07,280
And then compilation continues.

792
01:16:07,280 --> 01:16:09,280
So we can look at a macro.

793
01:16:09,280 --> 01:16:12,280
You'll notice on the list of primitives, there's no or.

794
01:16:12,280 --> 01:16:14,280
Or is not primitive enclosure.

795
01:16:14,280 --> 01:16:18,280
And in fact, if you think about or, or is not primitive.

796
01:16:18,280 --> 01:16:20,280
Or is not a primitive logical operation.

797
01:16:20,280 --> 01:16:25,280
You can build or on top of if.

798
01:16:25,280 --> 01:16:26,280
Right?

799
01:16:26,280 --> 01:16:32,280
The or, what I'm talking about is like the double bar or in, in Java in that what happens

800
01:16:32,280 --> 01:16:36,280
if the first part tests true, what happens to the second part?

801
01:16:36,280 --> 01:16:37,280
Not evaluated, right?

802
01:16:37,280 --> 01:16:40,280
It's still got that magic thing, but if already knows how to do that.

803
01:16:40,280 --> 01:16:46,280
If already knows how to do a conditional evaluation of only one of two choices,

804
01:16:46,280 --> 01:16:52,280
which means we can define or in terms of if.

805
01:16:52,280 --> 01:16:54,280
And so this is what happens.

806
01:16:54,280 --> 01:16:56,280
So or is a macro.

807
01:16:56,280 --> 01:17:00,280
When it's expanded by the compiler, it, it returns something like this.

808
01:17:00,280 --> 01:17:02,280
I'm going to say or X or Y.

809
01:17:02,280 --> 01:17:04,280
And this is what comes back.

810
01:17:04,280 --> 01:17:07,280
Another data structure begins with the let, which we haven't seen so far,

811
01:17:07,280 --> 01:17:12,280
that says it takes a set of pairs of things to make this mean,

812
01:17:12,280 --> 01:17:16,280
mean this inside the scope of the let.

813
01:17:16,280 --> 01:17:19,280
Like a local variable, except it's not variable.

814
01:17:19,280 --> 01:17:20,280
You can't vary it.

815
01:17:20,280 --> 01:17:22,280
But it has the same kind of scope.

816
01:17:22,280 --> 01:17:24,280
So it says let's, let's do that.

817
01:17:24,280 --> 01:17:28,280
And the reason why it does it is because this is going to be some expression.

818
01:17:28,280 --> 01:17:34,280
It looks like X here, but it could be like a call to calculate some incredibly difficult

819
01:17:34,280 --> 01:17:36,280
thing that's going to take an hour.

820
01:17:36,280 --> 01:17:39,280
In which case, I finally want to repeat that more than once in my expansion,

821
01:17:39,280 --> 01:17:41,280
because it would calculate that thing twice.

822
01:17:41,280 --> 01:17:45,280
So we're going to take whatever that expression is, put in here,

823
01:17:45,280 --> 01:17:49,280
assigns that into this variable name, which is made up because,

824
01:17:49,280 --> 01:17:51,280
because obviously you didn't pick this name.

825
01:17:51,280 --> 01:17:54,280
It's a good machine pick name.

826
01:17:54,280 --> 01:17:56,280
So it makes a variable.

827
01:17:56,280 --> 01:17:58,280
And then it says if that thing is true, right,

828
01:17:58,280 --> 01:18:00,280
and you took an average calculator in this, right,

829
01:18:00,280 --> 01:18:01,280
we have that idea.

830
01:18:01,280 --> 01:18:04,280
If that's true, return it.

831
01:18:04,280 --> 01:18:07,280
If, right, I know, isn't it going to do this?

832
01:18:07,280 --> 01:18:09,280
If this is true.

833
01:18:09,280 --> 01:18:12,280
Otherwise, it's going to do what?

834
01:18:12,280 --> 01:18:15,280
And that's the implementation of OR.

835
01:18:15,280 --> 01:18:18,280
If the first thing is true, it returns it.

836
01:18:18,280 --> 01:18:20,280
Well, in fact, in Java, you don't get a good value,

837
01:18:20,280 --> 01:18:23,280
but in Clojure, you get the value that was true.

838
01:18:23,280 --> 01:18:29,280
Then the invocation of any function can both return a value in a true form

839
01:18:29,280 --> 01:18:31,280
or you interpret certain types of values.

840
01:18:31,280 --> 01:18:35,280
All values can be placed in a conditional, not just Booleans,

841
01:18:35,280 --> 01:18:37,280
and it's subject to the rules I said before.

842
01:18:37,280 --> 01:18:44,280
If it is nil or if it is false, you'll get the else expression evaluated.

843
01:18:44,280 --> 01:18:52,280
If it is anything else, seven, the string fred, anything else is true.

844
01:18:52,280 --> 01:18:57,280
So Clojure, like most LISPs, allows any expression to be evaluated

845
01:18:57,280 --> 01:18:59,280
as the conditional test.

846
01:18:59,280 --> 01:19:02,280
Here.

847
01:19:02,280 --> 01:19:09,280
He's also getting the part that there are no spiting effects of the evacuating effects.

848
01:19:09,280 --> 01:19:12,280
No, I talked about that.

849
01:19:12,280 --> 01:19:14,280
Let's say this x for now.

850
01:19:14,280 --> 01:19:19,280
A well-written macro will make sure it only gets evaluated once.

851
01:19:19,280 --> 01:19:24,280
I could have put if x, x, y, yes?

852
01:19:24,280 --> 01:19:26,280
No, this is the answer to your question.

853
01:19:26,280 --> 01:19:33,280
If it said if x, x, otherwise y, then if x had side effects, it would happen twice.

854
01:19:33,280 --> 01:19:36,280
Then we make this not a well-written macro.

855
01:19:36,280 --> 01:19:40,280
This is a well-written macro where it needs to use that expression twice,

856
01:19:40,280 --> 01:19:45,280
which means it's going to bind a temporary variable to the value,

857
01:19:45,280 --> 01:19:48,280
which means x only happens if it appears only once here.

858
01:19:48,280 --> 01:19:51,280
So if it had a side effect, it would happen only once.

859
01:19:51,280 --> 01:19:54,280
If it took a long time, it would take a long time only once.

860
01:19:54,280 --> 01:19:57,280
Simple as it is, I still have this simple question.

861
01:19:57,280 --> 01:20:05,280
Let appears to take three arguments.

862
01:20:05,280 --> 01:20:11,280
Let actually takes, at the top most level, it takes n arguments.

863
01:20:11,280 --> 01:20:17,280
The first of which has to be a vector of pairs of things.

864
01:20:17,280 --> 01:20:19,280
You can have multiple expressions.

865
01:20:19,280 --> 01:20:23,280
Name, value, name, value, value in a letter.

866
01:20:23,280 --> 01:20:28,280
This is one symbol there.

867
01:20:28,280 --> 01:20:33,280
Let is a block, so it actually can have multiple expressions.

868
01:20:33,280 --> 01:20:36,280
In this case, there's only one.

869
01:20:36,280 --> 01:20:39,280
And then it just does whatever it's next.

870
01:20:39,280 --> 01:20:41,280
It returns the value.

871
01:20:41,280 --> 01:20:45,280
Well, this is a macro, and all it's going to do is get the compiler back this,

872
01:20:45,280 --> 01:20:48,280
and the compiler has to keep going with this in hand now.

873
01:20:48,280 --> 01:20:51,280
Yes, I'm just trying to figure out what led you.

874
01:20:51,280 --> 01:20:56,280
Let will, led establishes this name to not this value.

875
01:20:56,280 --> 01:21:02,280
Then, when led runs, the series of expressions inside led run,

876
01:21:02,280 --> 01:21:06,280
and the last of them is the value of the led expression.

877
01:21:06,280 --> 01:21:11,280
In this case, there's only one expression inside the led.

878
01:21:11,280 --> 01:21:13,280
In this case, there's only one expression inside the led.

879
01:21:13,280 --> 01:21:17,280
So the value of the if expression is the value of the led.

880
01:21:17,280 --> 01:21:20,280
Which is what we want, we want this to mean or.

881
01:21:20,280 --> 01:21:22,280
And that's the scope.

882
01:21:22,280 --> 01:21:24,280
This is the end of the scope over here.

883
01:21:24,280 --> 01:21:27,280
And this parent matches that value.

884
01:21:27,280 --> 01:21:29,280
That's what I was noticing.

885
01:21:29,280 --> 01:21:33,280
Yes, and well, it's one of the beautiful things about the system,

886
01:21:33,280 --> 01:21:38,280
which we'll see clarified in a moment, is that all expressions are bound.

887
01:21:38,280 --> 01:21:43,280
So we don't have a lot of complexity with precedents and terminators and things like that.

888
01:21:43,280 --> 01:21:49,280
It started with the parent, it ends with the matching parent later.

889
01:21:50,280 --> 01:21:53,280
Big Boolean?

890
01:21:53,280 --> 01:21:58,280
In fact, it has to be big Boolean false.

891
01:21:58,280 --> 01:22:01,280
If it's coming from Java, I test to make sure,

892
01:22:01,280 --> 01:22:07,280
because an improperly constructed big Boolean may not be Boolean dot false.

893
01:22:07,280 --> 01:22:09,280
New Boolean is wrong.

894
01:22:09,280 --> 01:22:12,280
And in fact, not only is new Boolean wrong,

895
01:22:12,280 --> 01:22:16,280
but the reflection API in Java uses it exactly that way.

896
01:22:16,280 --> 01:22:20,280
So it returns multiple different values of big Boolean false.

897
01:22:20,280 --> 01:22:26,280
I have a patch that looks for that because I got bit by that already.

898
01:22:26,280 --> 01:22:35,280
So it will make conversions of big Boolean false that aren't Boolean dot false into Boolean dot false.

899
01:22:38,280 --> 01:22:42,280
I'm sorry, I didn't write Java, I only wrote closure.

900
01:22:43,280 --> 01:22:48,280
But the point here is that this seems like a primitive thing,

901
01:22:48,280 --> 01:22:51,280
like if the language doesn't have it, you're in trouble.

902
01:22:51,280 --> 01:22:52,280
It is not.

903
01:22:52,280 --> 01:22:56,280
If I had somehow left out OR, you could have added it.

904
01:22:56,280 --> 01:23:01,280
You could have written the macro that does this job and added OR to closure.

905
01:23:01,280 --> 01:23:03,280
I'm sure I forgot some things in closure.

906
01:23:03,280 --> 01:23:05,280
You could add them.

907
01:23:05,280 --> 01:23:06,280
Many things.

908
01:23:06,280 --> 01:23:09,280
In fact, we saw how tiny the special operators list is.

909
01:23:09,280 --> 01:23:17,280
And OR, con, all kinds of things are built on top of these things as macros and OR functions.

910
01:23:17,280 --> 01:23:23,280
And after the point of the special ops, you can add a special operator, but you can add a macro.

911
01:23:24,280 --> 01:23:27,280
Now I've got more than 50,000 for the question.

912
01:23:27,280 --> 01:23:30,280
So I get this, this is great.

913
01:23:30,280 --> 01:23:36,280
So something to build a bunch of macros in these is that it's a powerful, another bunch of macros.

914
01:23:36,280 --> 01:23:40,280
Somebody else has got this smoking advantage of this language.

915
01:23:40,280 --> 01:23:45,280
People sort of come down to the industry for developers and the industry for locals in.

916
01:23:45,280 --> 01:23:49,280
There's a one-time error and I get a stack trace of it going in.

917
01:23:50,280 --> 01:23:55,280
You're going to get a reference to the expansion, the inside of the expansion.

918
01:24:03,280 --> 01:24:05,280
That can be challenging.

919
01:24:14,280 --> 01:24:16,280
It's still an area.

920
01:24:20,280 --> 01:24:29,280
I think that one of the things that's good about a list is because you have the ability to work in the small

921
01:24:29,280 --> 01:24:32,280
and to say, I just wrote this little component of this thing.

922
01:24:32,280 --> 01:24:34,280
I'm going to run this right now.

923
01:24:34,280 --> 01:24:38,280
I don't have to wait till the big program that contains this runs.

924
01:24:38,280 --> 01:24:46,280
Your ability to do that immediate unit test to make sure that thing is working is good.

925
01:24:47,280 --> 01:24:56,280
On the 50,000 foot level, propagating up from macros the source of the problem in the macro is something

926
01:24:56,280 --> 01:24:57,280
that's being worked on.

927
01:24:57,280 --> 01:25:00,280
Some compilers do it pretty well for common list.

928
01:25:00,280 --> 01:25:04,280
It's an area I hope to enhance in closure.

929
01:25:04,280 --> 01:25:09,280
But it will always be more challenging than a function.

930
01:25:09,280 --> 01:25:17,280
And that's why macro writing is not for newcomers or the inexperienced part of the team.

931
01:25:19,280 --> 01:25:21,280
It is language design.

932
01:25:21,280 --> 01:25:23,280
It definitely is.

933
01:25:23,280 --> 01:25:29,280
On the other hand, without it, you're limited to the abstraction capabilities of functions, which are limited.

934
01:25:29,280 --> 01:25:31,280
Think about how much you repeat in Java.

935
01:25:31,280 --> 01:25:35,280
Think about how much code you repeat to close files in Java.

936
01:25:35,280 --> 01:25:36,280
Think about it.

937
01:25:36,280 --> 01:25:38,280
Think about how many times you've written the exact same thing.

938
01:25:38,280 --> 01:25:42,280
Having your IDE spit it out is a little bit handier.

939
01:25:42,280 --> 01:25:44,280
But when you decide, oh, I need to change my policy about doing this.

940
01:25:44,280 --> 01:25:46,280
I want to check something else.

941
01:25:46,280 --> 01:25:50,280
All that generated code is not amenable to fixing.

942
01:25:50,280 --> 01:25:54,280
So those kinds of things that can't be...

943
01:25:54,280 --> 01:25:59,280
whose redundancy can't be eliminated by functions can be eliminated by macros.

944
01:25:59,280 --> 01:26:01,280
And that's something you want to do.

945
01:26:01,280 --> 01:26:07,280
Because the B side of this is, if you're doing all that stuff by hand, yes, it's transparent.

946
01:26:07,280 --> 01:26:08,280
You get this debugger error.

947
01:26:08,280 --> 01:26:10,280
Okay, you did that by hand.

948
01:26:10,280 --> 01:26:12,280
Where?

949
01:26:12,280 --> 01:26:14,280
All over your program.

950
01:26:14,280 --> 01:26:16,280
Because you didn't have a macro that generated it.

951
01:26:16,280 --> 01:26:18,280
You don't have one place to fix.

952
01:26:18,280 --> 01:26:20,280
You have n places to fix.

953
01:26:20,280 --> 01:26:22,280
So there's a...

954
01:26:22,280 --> 01:26:26,280
If you have n places to fix, where you say, oh, I made this mistake everywhere.

955
01:26:26,280 --> 01:26:30,280
But you still have to find everywhere you have to fix it.

956
01:26:30,280 --> 01:26:32,280
And these things are idioms.

957
01:26:32,280 --> 01:26:34,280
Everybody that programs in Java has to know this.

958
01:26:34,280 --> 01:26:37,280
These idioms are only by convention

959
01:26:37,280 --> 01:26:39,280
and they have to be manually replicated.

960
01:26:47,280 --> 01:26:50,280
It is an attempt to address those cross-cutting concerns.

961
01:26:50,280 --> 01:26:55,280
But it's still unproven as to whether or not people will describe them...

962
01:26:55,280 --> 01:26:57,280
those things in advance.

963
01:26:57,280 --> 01:27:00,280
Because what tends to happen is that you don't know it.

964
01:27:00,280 --> 01:27:02,280
And then you say, oh, I'm doing this all over the place.

965
01:27:02,280 --> 01:27:05,400
And then will you implement an aspect?

966
01:27:05,400 --> 01:27:06,480
Is there a policy?

967
01:27:06,480 --> 01:27:09,000
Is there a way to describe an aspect that will insert it

968
01:27:09,000 --> 01:27:10,400
everywhere it's needed?

969
01:27:10,400 --> 01:27:12,600
That's a very challenging problem.

970
01:27:12,600 --> 01:27:17,800
But the problem of this summary is little easier with

971
01:27:17,800 --> 01:27:19,640
aspect-oriented programming.

972
01:27:19,640 --> 01:27:22,760
I mean, I think aspect-oriented programming is

973
01:27:22,760 --> 01:27:26,200
interesting, but it's different.

974
01:27:26,200 --> 01:27:29,240
So anyway, the trade-off with macros, yes, it may be less

975
01:27:29,240 --> 01:27:30,040
transparent there.

976
01:27:30,040 --> 01:27:32,240
On the other side, when you fix a macro, you fix

977
01:27:32,240 --> 01:27:36,000
every usage of the macro.

978
01:27:36,000 --> 01:27:37,160
Finally, we get to the easier thing.

979
01:27:37,160 --> 01:27:39,000
I mean, start with special operators and macros, mostly

980
01:27:39,000 --> 01:27:40,920
because that's the evaluation order.

981
01:27:40,920 --> 01:27:44,520
But functions exist, and they're kind of straightforward.

982
01:27:44,520 --> 01:27:46,320
The first thing about functions you need to know is that

983
01:27:46,320 --> 01:27:47,800
they're first-class values.

984
01:27:47,800 --> 01:27:50,680
They're values like any other.

985
01:27:50,680 --> 01:27:52,920
Methods in Java are not first-class.

986
01:27:52,920 --> 01:27:55,640
You can't put a method into a variable.

987
01:27:55,640 --> 01:27:57,760
You can't pass a method to a function.

988
01:27:57,760 --> 01:28:00,720
There are special things in LISPs.

989
01:28:00,720 --> 01:28:04,240
And in fact, in most dynamic languages today, functions are

990
01:28:04,240 --> 01:28:06,600
first-class, which means the function is a value.

991
01:28:06,600 --> 01:28:10,280
So I've defined 5 to mean 5.

992
01:28:10,280 --> 01:28:11,680
And of course, I don't need to do that.

993
01:28:11,680 --> 01:28:17,560
But I'm showing you a depth of a symbol to a value.

994
01:28:17,560 --> 01:28:20,840
Now I'm going to show you a depth of a symbol, as if you

995
01:28:20,840 --> 01:28:25,200
are, to a value, which is according to one of the other

996
01:28:25,200 --> 01:28:27,960
special operators called fun.

997
01:28:27,960 --> 01:28:33,040
And what fun does is it creates a function object.

998
01:28:33,040 --> 01:28:35,640
This is going to turn that code into something that gets

999
01:28:35,640 --> 01:28:39,040
compiled into a function that takes one argument and

1000
01:28:39,040 --> 01:28:40,160
multiplies it by itself.

1001
01:28:52,640 --> 01:28:54,720
It's a regular function.

1002
01:28:54,720 --> 01:28:59,200
It's going to be an instance of a Java interface that

1003
01:28:59,200 --> 01:29:00,120
takes an argument.

1004
01:29:00,120 --> 01:29:03,560
It's a real, regular method in Java.

1005
01:29:06,560 --> 01:29:09,720
You'll have an invalidarity problem.

1006
01:29:09,720 --> 01:29:11,200
OK, I need to move a little bit more quickly.

1007
01:29:11,200 --> 01:29:13,720
So let's hold the functions for a little bit.

1008
01:29:13,720 --> 01:29:15,320
Let me move forward.

1009
01:29:15,320 --> 01:29:19,640
So this fun, I can't describe all of the features of fun.

1010
01:29:19,640 --> 01:29:21,920
It's an exciting and rich thing.

1011
01:29:21,920 --> 01:29:24,880
But this fun that we can take as being fun is a special

1012
01:29:24,880 --> 01:29:25,880
operator.

1013
01:29:25,880 --> 01:29:30,440
It takes a vector of the names of its arguments, the

1014
01:29:30,440 --> 01:29:32,120
simplest way of understanding.

1015
01:29:32,120 --> 01:29:36,200
And then it contains a set of expressions, which will be the

1016
01:29:36,200 --> 01:29:37,240
body of the function.

1017
01:29:37,240 --> 01:29:40,080
The last expression is the value returned by the function.

1018
01:29:40,080 --> 01:29:45,160
There's no return statement in closure.

1019
01:29:45,160 --> 01:29:50,880
So when we say square five, it returns 25.

1020
01:29:50,920 --> 01:29:51,920
This is a function call.

1021
01:29:51,920 --> 01:29:53,280
Again, we said, what does it do?

1022
01:29:53,280 --> 01:29:55,040
It says, is square a special operator?

1023
01:29:55,040 --> 01:29:55,920
No.

1024
01:29:55,920 --> 01:29:56,800
Is it a macro?

1025
01:29:56,800 --> 01:29:58,920
We're going to say, right now, it isn't.

1026
01:29:58,920 --> 01:30:01,040
So what's the value of square?

1027
01:30:01,040 --> 01:30:02,600
It's this function object.

1028
01:30:02,600 --> 01:30:04,280
OK, call it.

1029
01:30:04,280 --> 01:30:07,880
And pass it that.

1030
01:30:07,880 --> 01:30:10,760
The value of that, because the arguments to functions are

1031
01:30:10,760 --> 01:30:12,400
evaluated.

1032
01:30:12,400 --> 01:30:15,440
So it's going to pass square the number five.

1033
01:30:15,440 --> 01:30:20,080
Square is going to multiply by itself and return 25.

1034
01:30:20,120 --> 01:30:22,320
So functions are first class.

1035
01:30:22,320 --> 01:30:24,280
There are other things that are like functions.

1036
01:30:24,280 --> 01:30:27,440
In other words, the compiler says, can I call this?

1037
01:30:27,440 --> 01:30:29,960
The answer is true of funds.

1038
01:30:29,960 --> 01:30:31,240
It's also true of other things.

1039
01:30:31,240 --> 01:30:33,840
In particular, one of the neat things about closure is that

1040
01:30:33,840 --> 01:30:36,040
maps are functions.

1041
01:30:36,040 --> 01:30:39,720
Because if you think about maps mathematically, they are

1042
01:30:39,720 --> 01:30:40,680
functions.

1043
01:30:40,680 --> 01:30:42,760
Maps are functions of their keys.

1044
01:30:42,760 --> 01:30:48,920
Given a key, a map should return the value of that key.

1045
01:30:48,920 --> 01:30:50,960
And it does, in closure.

1046
01:30:50,960 --> 01:30:51,960
So maps are functions.

1047
01:30:51,960 --> 01:30:53,640
Sets are also functions.

1048
01:30:53,640 --> 01:30:55,480
Vectors are also functions.

1049
01:30:55,480 --> 01:30:57,080
Vectors are functions of their indices.

1050
01:31:01,400 --> 01:31:02,280
That's cool stuff.

1051
01:31:02,280 --> 01:31:05,440
And when you see idiomatic closure, some of it is quite

1052
01:31:05,440 --> 01:31:10,040
beautiful because of that relationship.

1053
01:31:10,040 --> 01:31:13,920
So we'll try to summarize this.

1054
01:31:13,920 --> 01:31:16,440
Things that would be declarations or control

1055
01:31:16,480 --> 01:31:22,480
structures, or function calls, or operators, or whatever.

1056
01:31:22,480 --> 01:31:29,440
In Java, all are uniform in closure, or any list.

1057
01:31:29,440 --> 01:31:35,000
In that, there are lists where the operator is the first

1058
01:31:35,000 --> 01:31:37,560
thing in the list.

1059
01:31:37,560 --> 01:31:41,840
So we've reduced all of this variation here to something

1060
01:31:41,840 --> 01:31:42,320
uniform.

1061
01:31:42,320 --> 01:31:43,440
So look at each one.

1062
01:31:43,440 --> 01:31:47,920
int i equals 5 establishes i as the name, whose meaning is

1063
01:31:47,920 --> 01:31:50,120
the value of 5.

1064
01:31:50,120 --> 01:31:52,800
That i does that as well.

1065
01:31:52,800 --> 01:31:54,400
Where in this does it say it's a definition?

1066
01:31:54,400 --> 01:31:54,680
Whatever.

1067
01:31:54,680 --> 01:31:57,840
Some rule about the shape of this thing says it's a

1068
01:31:57,840 --> 01:31:58,440
definition.

1069
01:31:58,440 --> 01:32:04,000
In closure, that says that's what it means.

1070
01:32:04,000 --> 01:32:06,040
If x is equal to 0, return y.

1071
01:32:06,040 --> 01:32:07,480
Otherwise, return z.

1072
01:32:07,480 --> 01:32:10,120
When does this end?

1073
01:32:10,120 --> 01:32:11,120
I'm showing the rest of the program.

1074
01:32:11,120 --> 01:32:14,960
Is this done?

1075
01:32:14,960 --> 01:32:16,000
Got me?

1076
01:32:16,000 --> 01:32:16,480
You don't know?

1077
01:32:16,480 --> 01:32:17,480
I don't know.

1078
01:32:17,480 --> 01:32:21,960
Because it could say else, else, else if.

1079
01:32:21,960 --> 01:32:24,200
I couldn't say it has to say else if, and then it could say

1080
01:32:24,200 --> 01:32:25,120
else.

1081
01:32:25,120 --> 01:32:27,160
We have to keep looking forward.

1082
01:32:27,160 --> 01:32:29,680
We could not have had an else.

1083
01:32:29,680 --> 01:32:31,320
It's not closed.

1084
01:32:31,320 --> 01:32:34,040
In addition, without these returns, it doesn't yield a

1085
01:32:34,040 --> 01:32:34,360
value.

1086
01:32:34,360 --> 01:32:37,120
This is a statement in Java.

1087
01:32:37,120 --> 01:32:40,280
There is an if conditional, which is an expression of two

1088
01:32:40,280 --> 01:32:42,720
different things.

1089
01:32:42,720 --> 01:32:47,280
In closure, if, against first, we know we're dealing with if.

1090
01:32:47,280 --> 01:32:48,360
We saw the syntax.

1091
01:32:48,360 --> 01:32:51,520
It takes three things.

1092
01:32:51,520 --> 01:32:54,360
What's the question mark in 0, the question mark in closure?

1093
01:32:54,360 --> 01:32:56,080
That's a function name.

1094
01:32:56,080 --> 01:32:58,360
You can have question marks in names.

1095
01:32:58,360 --> 01:33:00,800
Closure is much more liberal about the symbols that can

1096
01:33:00,800 --> 01:33:03,280
appear in names, but not completely liberal.

1097
01:33:03,280 --> 01:33:08,000
Because I need some symbols for myself.

1098
01:33:08,040 --> 01:33:08,960
x times y times z.

1099
01:33:08,960 --> 01:33:11,960
What are these?

1100
01:33:11,960 --> 01:33:13,400
Mathematical operators.

1101
01:33:13,400 --> 01:33:15,920
Again, another special thing about Java.

1102
01:33:15,920 --> 01:33:17,400
And they can go in between things.

1103
01:33:17,400 --> 01:33:19,040
And there's precedence rules.

1104
01:33:19,040 --> 01:33:22,040
All other kinds of guk, right?

1105
01:33:22,040 --> 01:33:23,040
Closure is wet.

1106
01:33:23,040 --> 01:33:23,720
It's a beginning.

1107
01:33:23,720 --> 01:33:24,680
I don't have to look anywhere.

1108
01:33:24,680 --> 01:33:26,600
I don't have to look in the middle or read or look for

1109
01:33:26,600 --> 01:33:27,880
semicolon.

1110
01:33:27,880 --> 01:33:28,520
What's happening?

1111
01:33:28,520 --> 01:33:32,280
Multiplication, first.

1112
01:33:32,280 --> 01:33:34,480
Also, you'll notice multiplication can take

1113
01:33:34,480 --> 01:33:36,280
multiple operands, more than two.

1114
01:33:36,280 --> 01:33:38,160
It's not just a binary operator.

1115
01:33:38,160 --> 01:33:39,240
It's an n-ary operator.

1116
01:33:42,160 --> 01:33:42,920
Foo x, y, z.

1117
01:33:42,920 --> 01:33:45,320
This is what?

1118
01:33:45,320 --> 01:33:48,080
Function call, right?

1119
01:33:48,080 --> 01:33:49,360
Foo x, y, z.

1120
01:33:49,360 --> 01:33:50,840
People complain about the parentheses.

1121
01:33:50,840 --> 01:33:52,560
List how many parentheses difference.

1122
01:33:56,040 --> 01:33:57,080
None.

1123
01:33:57,080 --> 01:34:00,160
You move it from here over there.

1124
01:34:00,160 --> 01:34:02,320
Same thing.

1125
01:34:02,320 --> 01:34:02,800
Same thing.

1126
01:34:02,800 --> 01:34:04,520
I don't know what you're talking about.

1127
01:34:04,520 --> 01:34:06,680
And you're not going to see curly, curly, curly,

1128
01:34:06,680 --> 01:34:08,840
curly, curly, curly, curly.

1129
01:34:08,840 --> 01:34:12,160
Yes, you may see friends like that.

1130
01:34:12,160 --> 01:34:13,680
But that's better, I'm telling you.

1131
01:34:13,680 --> 01:34:16,360
It keeps your program near itself.

1132
01:34:16,360 --> 01:34:18,600
You don't have to go down to the next page to see the next

1133
01:34:18,600 --> 01:34:19,800
step.

1134
01:34:19,800 --> 01:34:21,880
And then this member access, I'm going to talk more about the

1135
01:34:21,880 --> 01:34:24,240
Java interoperability.

1136
01:34:24,240 --> 01:34:26,120
But same kind of thing.

1137
01:34:26,120 --> 01:34:28,200
Different number of parentheses?

1138
01:34:28,200 --> 01:34:28,800
No.

1139
01:34:28,800 --> 01:34:30,480
Different number of dots?

1140
01:34:30,480 --> 01:34:31,240
No.

1141
01:34:31,240 --> 01:34:36,000
But dot goes first, because dot tells Clojure we're doing

1142
01:34:36,000 --> 01:34:38,320
some Java stuff here.

1143
01:34:38,320 --> 01:34:40,360
That has its own special interpretation, because dot is

1144
01:34:40,360 --> 01:34:43,640
a special operator, we saw before.

1145
01:34:43,640 --> 01:34:46,520
So there's a tremendous uniformity.

1146
01:34:46,520 --> 01:34:49,640
There's a lot of value to that uniformity.

1147
01:34:49,640 --> 01:34:51,960
I know a lot of programming languages.

1148
01:34:51,960 --> 01:34:55,840
And every time I have to learn the arcane, whatever the

1149
01:34:55,840 --> 01:34:58,720
rules are, syntax, and this thing next to that means

1150
01:34:58,720 --> 01:35:01,160
that, and this character means this, and you can have a

1151
01:35:01,160 --> 01:35:05,120
semicolon here, but not there, and it better be indented by

1152
01:35:05,120 --> 01:35:07,680
the same amount, or whatever it is.

1153
01:35:07,680 --> 01:35:11,160
I really get angry now, because there is no reason for

1154
01:35:11,160 --> 01:35:12,000
that.

1155
01:35:12,000 --> 01:35:14,880
It is not better than this.

1156
01:35:14,880 --> 01:35:19,920
And if you use this for any amount of time, you will not

1157
01:35:19,920 --> 01:35:22,760
disagree, because there's no one who has, who does.

1158
01:35:25,480 --> 01:35:27,560
But it also has to have its biggest

1159
01:35:27,560 --> 01:35:29,480
differences in some ways.

1160
01:35:29,480 --> 01:35:35,080
Who got far, far more cool for an X in Java?

1161
01:35:35,080 --> 01:35:37,080
How do I get the expression?

1162
01:35:37,080 --> 01:35:38,080
I'll show you later.

1163
01:35:42,160 --> 01:35:45,720
If I only have another hour, I have to go much faster.

1164
01:35:45,720 --> 01:35:48,640
Everybody ready?

1165
01:35:48,640 --> 01:35:52,840
So let's hold the questions until a question time, unless

1166
01:35:52,840 --> 01:35:55,200
you're really confused, but just general interest things

1167
01:35:55,400 --> 01:35:58,720
will hold, because I may cover it.

1168
01:35:58,720 --> 01:36:03,040
One of the things that is typical about a Lisp is that

1169
01:36:03,040 --> 01:36:07,720
it has a rich library for manipulating lists.

1170
01:36:07,720 --> 01:36:11,200
But it ends up that, I think, in my opinion, it's a

1171
01:36:11,200 --> 01:36:15,520
shortcoming of Lisp's traditionally, that those

1172
01:36:15,520 --> 01:36:19,440
functions are limited to a particular data structure,

1173
01:36:19,440 --> 01:36:21,760
which is the singly linked list.

1174
01:36:21,800 --> 01:36:28,120
Because the functions that underline that abstraction are

1175
01:36:28,120 --> 01:36:30,880
broader, and they're three of them.

1176
01:36:30,880 --> 01:36:34,520
The first is, I'd like to obtain some sort of a sequence

1177
01:36:34,520 --> 01:36:39,320
like thing from some sort of collection like thing.

1178
01:36:39,320 --> 01:36:42,080
That's an abstract way to say something.

1179
01:36:42,080 --> 01:36:46,760
Given that sequence like thing, I want and need only two

1180
01:36:46,760 --> 01:36:47,880
functions.

1181
01:36:47,880 --> 01:36:52,120
One is to say, give me the first thing.

1182
01:36:52,120 --> 01:36:55,800
The other is to say, give me the sequence that is the rest

1183
01:36:55,800 --> 01:36:58,520
of this sequence.

1184
01:36:58,520 --> 01:37:04,120
In the case of seek, if there is no stuff, it returns nil,

1185
01:37:04,120 --> 01:37:07,800
because nil means nothing.

1186
01:37:07,800 --> 01:37:10,160
Which means you can say seek call, and you can put that in

1187
01:37:10,160 --> 01:37:12,680
an if expression as a test thing.

1188
01:37:12,680 --> 01:37:16,680
And because nil returns logical false, you'll know

1189
01:37:16,680 --> 01:37:18,480
there's nothing to do.

1190
01:37:18,480 --> 01:37:22,680
That's an important idiom of common Lisp, closure preserves

1191
01:37:22,680 --> 01:37:27,680
unlike scheme, where you have to say empty all the time.

1192
01:37:27,680 --> 01:37:31,080
If it's not empty, you will get back an object.

1193
01:37:31,080 --> 01:37:34,160
That object only makes two promises.

1194
01:37:34,160 --> 01:37:35,800
You can call these two functions on it.

1195
01:37:39,160 --> 01:37:41,080
This function promises one thing.

1196
01:37:41,080 --> 01:37:43,560
There will be a first element, because we're already covered

1197
01:37:43,560 --> 01:37:45,920
if there's not a first element here.

1198
01:37:45,920 --> 01:37:50,120
So if you say first of the seek, and this is not nil, it

1199
01:37:50,120 --> 01:37:53,920
means you have a seek, you get back a guy.

1200
01:37:53,920 --> 01:37:57,360
The first thing in the sequence.

1201
01:37:57,360 --> 01:37:59,400
The second thing you can do with the seek is you can call

1202
01:37:59,400 --> 01:38:02,560
rest on it, which says, give me the sequence that represents

1203
01:38:02,560 --> 01:38:05,600
the rest, not including the first thing.

1204
01:38:05,600 --> 01:38:08,920
Of course, if there's no more, what should we get?

1205
01:38:08,920 --> 01:38:12,560
Nil, because we said here, nothing.

1206
01:38:12,560 --> 01:38:13,760
If we have nothing, we get nil.

1207
01:38:13,760 --> 01:38:16,960
Otherwise, we're going to get another seek.

1208
01:38:16,960 --> 01:38:20,280
This is an extremely abstract way to talk about lists.

1209
01:38:20,280 --> 01:38:24,480
But the advantage over common Lisp and scheme lists is they

1210
01:38:24,480 --> 01:38:27,840
would promise that the return value of this thing is a

1211
01:38:27,840 --> 01:38:29,320
consel.

1212
01:38:29,320 --> 01:38:34,040
And that is a real limitation, because now I can make

1213
01:38:34,040 --> 01:38:36,360
seek work on absolutely everything.

1214
01:38:36,360 --> 01:38:39,480
Seek works on lists, because they have the structure.

1215
01:38:39,480 --> 01:38:42,640
But it's possible to create a seek object if you think about

1216
01:38:42,640 --> 01:38:45,240
iterators, and I want to make this analogy extremely

1217
01:38:45,240 --> 01:38:46,960
weakly.

1218
01:38:46,960 --> 01:38:49,480
There's a way to walk through a vector.

1219
01:38:49,480 --> 01:38:51,880
Similarly, there's a way to walk through a map.

1220
01:38:51,880 --> 01:38:53,800
There's a way to walk through a string.

1221
01:38:53,800 --> 01:38:55,280
There's a way to walk through a file.

1222
01:38:57,920 --> 01:39:00,600
And it ends up that seek is supported on all those things.

1223
01:39:00,600 --> 01:39:03,040
You can walk through Java arrays, all the closure

1224
01:39:03,040 --> 01:39:06,680
collections, strings, files, everything.

1225
01:39:06,680 --> 01:39:10,680
And you can use these two operations to move around.

1226
01:39:10,720 --> 01:39:15,680
This abstraction of listness, which I call a sequence

1227
01:39:15,680 --> 01:39:19,240
because a list is more of a concrete thing, is bound to

1228
01:39:19,240 --> 01:39:22,040
lists in most Lisp's.

1229
01:39:22,040 --> 01:39:25,200
Wow, this is hard to say.

1230
01:39:25,200 --> 01:39:27,160
But it's not in closure.

1231
01:39:27,160 --> 01:39:32,840
And it's, I think, one advance of closure in the Lisp world,

1232
01:39:32,840 --> 01:39:34,720
which means that you can apply these things to everything.

1233
01:39:34,720 --> 01:39:35,560
So what does this mean?

1234
01:39:35,560 --> 01:39:36,560
Well, this is kind of primitive.

1235
01:39:36,560 --> 01:39:39,040
I mean, walking through step by step.

1236
01:39:39,040 --> 01:39:42,400
But what it means is that you can build a library on top

1237
01:39:42,400 --> 01:39:45,560
of these primitives that provides a lot of power for

1238
01:39:45,560 --> 01:39:47,960
manipulating data structures without loops.

1239
01:39:47,960 --> 01:39:50,840
I'm just going to show you a tiny, tiny little bit.

1240
01:39:50,840 --> 01:39:52,960
But it should give you a feel for what it's like to program

1241
01:39:52,960 --> 01:39:56,000
in closure if you would think about what it would take to

1242
01:39:56,000 --> 01:39:57,040
do these things in Java.

1243
01:39:57,040 --> 01:39:59,560
For instance, I have a set of things.

1244
01:39:59,560 --> 01:40:03,520
I'd like to have everything except the first two things.

1245
01:40:03,520 --> 01:40:07,320
We say drop two from whatever the collection is.

1246
01:40:07,360 --> 01:40:09,200
That happens to be a vector.

1247
01:40:09,200 --> 01:40:11,040
It could have been a list.

1248
01:40:11,040 --> 01:40:12,800
It could have been a string.

1249
01:40:12,800 --> 01:40:15,680
We'll drop the first two characters.

1250
01:40:15,680 --> 01:40:18,760
Whatever it is, there's a way to abstract out the notion of

1251
01:40:18,760 --> 01:40:19,800
walking through it.

1252
01:40:19,800 --> 01:40:24,360
Drop means leave out that many and give me the rest as a

1253
01:40:24,360 --> 01:40:26,120
sequence.

1254
01:40:26,120 --> 01:40:29,000
Take is the opposite.

1255
01:40:29,000 --> 01:40:31,680
It says, only give me nine of these things.

1256
01:40:31,680 --> 01:40:34,080
Look at the second function, cycle.

1257
01:40:34,080 --> 01:40:36,560
Cycle is a function called, it takes 1, 2, 3, 4.

1258
01:40:36,560 --> 01:40:41,120
In this case, it could take any sequenceable thing.

1259
01:40:41,120 --> 01:40:47,320
It returns an infinite list, an infinite sequence of those

1260
01:40:47,320 --> 01:40:50,480
things around and around in a cycle.

1261
01:40:50,480 --> 01:40:51,880
How could it do that?

1262
01:40:51,880 --> 01:40:53,760
Isn't that going to chew up all the memory of my machine?

1263
01:40:53,760 --> 01:40:56,960
Cycle sounds like a really scary function.

1264
01:40:56,960 --> 01:41:01,480
It does that because if we go back to the definition of

1265
01:41:01,480 --> 01:41:04,080
this, is there anything about the way I describe the

1266
01:41:04,080 --> 01:41:06,440
operation of these things that says that the rest of this

1267
01:41:06,440 --> 01:41:09,440
thing has to exist?

1268
01:41:09,440 --> 01:41:12,520
I could make up the rest right when you ask me, right?

1269
01:41:12,520 --> 01:41:15,560
And how much of it would I have to make up?

1270
01:41:15,560 --> 01:41:16,840
Just one more thing.

1271
01:41:16,840 --> 01:41:19,200
The thing I give you has to have one more thing in it, and

1272
01:41:19,200 --> 01:41:20,560
it's I'm OK.

1273
01:41:20,560 --> 01:41:24,840
It could delay the calculation of the next part until the

1274
01:41:24,840 --> 01:41:27,120
next time you call rest.

1275
01:41:27,120 --> 01:41:28,760
That's called laziness.

1276
01:41:28,760 --> 01:41:32,000
And in fact, all the sequence stuff I'm showing you for

1277
01:41:32,000 --> 01:41:37,800
closure is lazy, which means that you can write sequence

1278
01:41:37,800 --> 01:41:40,120
functions that return infinite sets.

1279
01:41:40,120 --> 01:41:42,160
And you can use them, as long as you don't try to consume

1280
01:41:42,160 --> 01:41:44,640
all of them, you can consume a little bit of them.

1281
01:41:44,640 --> 01:41:47,320
So in this case, we're making an infinite sequence out of

1282
01:41:47,320 --> 01:41:52,560
1, 2, 3, 4, or taking the first nine things from it.

1283
01:41:52,560 --> 01:41:55,440
This looks like a weird abstract thing, but I've had

1284
01:41:55,440 --> 01:41:56,880
plenty of programs in reality.

1285
01:41:56,880 --> 01:41:59,600
I've had to do exactly this thing, round robin.

1286
01:41:59,600 --> 01:42:02,440
You can use it to round robin, work dispersal.

1287
01:42:02,440 --> 01:42:05,880
You can use it to get distributions.

1288
01:42:05,880 --> 01:42:08,400
In cycle, it seems like some theoretical isn't as cool you

1289
01:42:08,400 --> 01:42:09,920
can make an infinite sequence.

1290
01:42:09,920 --> 01:42:11,640
But it really has utility.

1291
01:42:11,640 --> 01:42:14,360
It ends up in real programs.

1292
01:42:14,360 --> 01:42:15,360
And it goes on and on.

1293
01:42:15,360 --> 01:42:16,640
Interleave does what you think.

1294
01:42:16,640 --> 01:42:18,440
One from this sequence, one from that.

1295
01:42:18,440 --> 01:42:19,800
Makes a new sequence.

1296
01:42:19,800 --> 01:42:23,320
Again, one of these could be infinite.

1297
01:42:23,320 --> 01:42:25,440
You'd only make as much of this as you needed to match the

1298
01:42:25,440 --> 01:42:28,880
length of the non-infinite one.

1299
01:42:28,880 --> 01:42:31,440
Partition, split this up into pieces.

1300
01:42:31,440 --> 01:42:34,360
Think about the loops to do this stuff.

1301
01:42:34,360 --> 01:42:37,400
And in Java, you have to write everyone, every time.

1302
01:42:41,600 --> 01:42:43,600
Never mind the laziness part.

1303
01:42:43,600 --> 01:42:46,280
Now we get to a more interesting function, which is map.

1304
01:42:46,280 --> 01:42:48,760
Now we're not talking about map the data structure.

1305
01:42:48,760 --> 01:42:53,320
We're talking about map a function, which is, again, from

1306
01:42:53,320 --> 01:42:58,920
this list land, which says, take this function.

1307
01:42:58,920 --> 01:43:02,880
So the first argument of map is a function value.

1308
01:43:02,880 --> 01:43:09,280
And apply it to pairwise, or however many sequences I give

1309
01:43:09,280 --> 01:43:12,120
you, the elements of the sequences I provide.

1310
01:43:12,120 --> 01:43:14,720
So in this case, we're going to call the function vector.

1311
01:43:14,720 --> 01:43:18,120
And we're going to call it on a and one.

1312
01:43:18,120 --> 01:43:22,080
Then we're going to call it on b and two, and c and three,

1313
01:43:22,080 --> 01:43:24,320
and d and four, and e and five.

1314
01:43:24,320 --> 01:43:27,560
And vector makes vectors out of whatever you pass it.

1315
01:43:27,560 --> 01:43:31,520
So we're mapping vector across this pair of sequences to

1316
01:43:31,520 --> 01:43:35,440
vectorize corresponding elements of those sequences.

1317
01:43:35,440 --> 01:43:39,360
We get a set of data structures back out of this.

1318
01:43:39,360 --> 01:43:41,080
So map is a very powerful thing.

1319
01:43:41,080 --> 01:43:43,800
Instead of saying, for each blah, blah, blah, do this and

1320
01:43:43,800 --> 01:43:46,720
stick the answer into this collection, you say, just map

1321
01:43:46,720 --> 01:43:48,320
this function across this data.

1322
01:43:48,320 --> 01:43:51,360
And it'll give you back a set of new data, the result of

1323
01:43:51,360 --> 01:43:53,400
applying that function to each thing.

1324
01:43:53,400 --> 01:43:55,400
You can also apply it against multiple sequences.

1325
01:43:55,400 --> 01:43:56,240
That's what this is doing.

1326
01:43:56,240 --> 01:44:00,080
Maybe I shouldn't have done something this complex here.

1327
01:44:00,080 --> 01:44:03,760
Apply is also very interesting, and it's a unique thing to

1328
01:44:03,760 --> 01:44:07,600
lists and languages that are dynamic.

1329
01:44:07,600 --> 01:44:10,080
Apply says, I'm also going to pass you a function.

1330
01:44:10,080 --> 01:44:13,800
What I want you to do is take the next expression and figure

1331
01:44:13,800 --> 01:44:18,540
out the sequence it yields, and then use that as the

1332
01:44:18,540 --> 01:44:21,860
arguments to a call to this function.

1333
01:44:21,860 --> 01:44:24,700
So we're going to apply the function stir, and stir says,

1334
01:44:24,700 --> 01:44:28,180
given any set of things, turn it into a string.

1335
01:44:28,180 --> 01:44:30,860
Turn each part into a string, and can cat and make them all

1336
01:44:30,860 --> 01:44:33,500
back together into a string.

1337
01:44:33,500 --> 01:44:35,580
So we want to put that together, and what interpose

1338
01:44:35,580 --> 01:44:38,500
does is it says, take this thing and put it in between

1339
01:44:38,500 --> 01:44:39,820
everything in this sequence.

1340
01:44:39,820 --> 01:44:46,020
So interpose, comma, ASDF, turn ASDF into a sequence, and

1341
01:44:46,020 --> 01:44:47,780
return characters.

1342
01:44:47,780 --> 01:44:51,300
So we're going to have the character A and a comma, S

1343
01:44:51,300 --> 01:44:56,100
and a comma, D and a comma, F and a comma.

1344
01:44:56,100 --> 01:44:57,780
Seven things.

1345
01:44:57,780 --> 01:44:58,620
Yes?

1346
01:44:58,620 --> 01:45:00,140
Three-four things with three things in two.

1347
01:45:00,140 --> 01:45:00,780
Seven things.

1348
01:45:00,780 --> 01:45:04,140
And we say, apply stir to that, which means

1349
01:45:04,140 --> 01:45:05,700
string can cat and make them.

1350
01:45:05,700 --> 01:45:07,820
As if they were the arguments to stir.

1351
01:45:07,820 --> 01:45:13,260
In other words, if I called stir and said stir, A comma,

1352
01:45:13,260 --> 01:45:17,820
S comma, D comma, F, it would make a string out of them.

1353
01:45:17,820 --> 01:45:21,180
Well, I can just apply it to the sequence, as if I called it

1354
01:45:21,180 --> 01:45:25,620
with those arguments, and it will do the job.

1355
01:45:25,620 --> 01:45:27,620
I get back a single string with that in between.

1356
01:45:30,300 --> 01:45:32,740
Again, if you don't quite get these, it's OK.

1357
01:45:32,740 --> 01:45:34,300
I'm just trying to show you the power and the

1358
01:45:34,300 --> 01:45:35,580
succinctness of this.

1359
01:45:35,580 --> 01:45:38,660
Reduces another function that takes a function.

1360
01:45:38,660 --> 01:45:43,700
It says, apply this function to successive pairs of the

1361
01:45:43,700 --> 01:45:47,300
sequence you're given, taking the result of each application

1362
01:45:47,300 --> 01:45:49,820
and using it as the first argument of the next.

1363
01:45:49,820 --> 01:45:53,860
So if you say, reduce with plus, you're going to get the

1364
01:45:53,860 --> 01:45:55,620
first two things plus each other.

1365
01:45:55,620 --> 01:45:58,580
And then take that and do that plus the next thing.

1366
01:45:58,580 --> 01:46:00,780
And take that and do that plus the next thing.

1367
01:46:00,780 --> 01:46:02,340
That's what reduce does.

1368
01:46:02,340 --> 01:46:07,820
So this effectively is summing this range.

1369
01:46:08,780 --> 01:46:11,780
It's a function that returns a sequence of numbers.

1370
01:46:11,780 --> 01:46:18,540
And you can step where it starts and where it ends and how

1371
01:46:18,540 --> 01:46:21,100
it steps and things like that.

1372
01:46:21,100 --> 01:46:24,580
This is obviously a much higher level way to write

1373
01:46:24,580 --> 01:46:27,580
programs than you do in Java.

1374
01:46:27,580 --> 01:46:28,380
Yes?

1375
01:46:28,380 --> 01:46:29,700
No?

1376
01:46:29,700 --> 01:46:30,740
Your head hurts.

1377
01:46:30,740 --> 01:46:33,420
I don't know what it's going to be.

1378
01:46:34,380 --> 01:46:36,820
Yeah, let's take a break.

1379
01:46:36,820 --> 01:46:38,060
This is going to be a good time for a break.

1380
01:46:38,060 --> 01:46:40,060
Does anybody have any questions on this real quick?

1381
01:46:55,220 --> 01:46:59,020
Right, and cycle returns a sequence, which has only got

1382
01:46:59,020 --> 01:47:00,380
one in it.

1383
01:47:00,380 --> 01:47:03,860
And the recipe for producing the rest of the cycle.

1384
01:47:03,860 --> 01:47:05,500
Sort of like a delayed function.

1385
01:47:05,500 --> 01:47:08,620
That's what happens inside cycle.

1386
01:47:08,620 --> 01:47:13,100
It doesn't produce an infinite list, obviously.

1387
01:47:13,100 --> 01:47:17,180
It returns an object that satisfies.

1388
01:47:17,180 --> 01:47:18,500
It returns a sequence, correct.

1389
01:47:26,620 --> 01:47:29,220
Why can't you call stirred directly?

1390
01:47:29,220 --> 01:47:34,100
Well, in this case, well, I'd have to write a comma, s comma,

1391
01:47:34,100 --> 01:47:36,020
d comma, f comma.

1392
01:47:36,020 --> 01:47:36,500
Right?

1393
01:47:40,500 --> 01:47:45,260
Then you're passing stir a sequence.

1394
01:47:45,260 --> 01:47:48,060
And what I want to do is say, take that sequence and pretend

1395
01:47:48,060 --> 01:47:49,780
it was the arguments to stir.

1396
01:47:49,780 --> 01:47:53,900
Not an argument to stir, but n arguments to stir.

1397
01:48:00,180 --> 01:48:01,780
Because that's the syntax of closure.

1398
01:48:01,780 --> 01:48:06,260
Slash comma is a character literal for comma.

1399
01:48:06,260 --> 01:48:08,260
Quote is used for other things.

1400
01:48:08,260 --> 01:48:10,620
That's why I don't use it for character literals.

1401
01:48:10,620 --> 01:48:12,620
All right, let's take a break.

