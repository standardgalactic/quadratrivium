{"text": " Hey, everyone. Welcome to the third part of item 10 in effective Java, which states obey the general contract when overriding equals. So we have been covering this item across multiple videos, and this is just a flow on from part one and two. So therefore, needless to state, please do watch part one and two if any of this is to make any sense. In part two, what we discussed was we discussed the first three properties of what we would call an equivalence relation, and we went through them as being reflexivity, symmetry, and transitivity. And today we're going to discuss consistency and non-nullity. But before that, Merry Christmas and Happy New Year. I hope you have a wonderful New Year's and had a wonderful Christmas. When you do see this though, it's probably going to be a bit later in general mid-gen. The reason being, I'm going to take some time off. I'm going to go to Queensland, and that's going to be nice. Therefore, I won't get time to edit and upload this video. But without further ado, let's get started. So today we're going to discuss consistency and non-nullity. I do apologize if there's some background noise. There's a bit of construction taking place outside. I really can't do anything about it. But I'll try my best to edit the audio or like, what's what I'm looking for? Reduce the background noise when I'm editing the video in the audio. That was a weird way of putting it. What I meant to say was I'll fix up the audio. Let's start with consistency. So consistency is again a part of those equivalence relation properties. And it's important to understand that to understand what the general contract of the equals method is. Consistency states, for any non-null reference values, x and y, multiple invocations of x equals y. So x and y could be of any type, string integer, that doesn't matter. But multiple invocations of x equals y must consistently return true or equal or consistently return false provided no information used in equals comparison is modified. That being, if you compare two strings, let's say x and y are of string type, which is a superclass or a subclass of the object class, which has the equals contract. So let's say you're building a new type of string class and you're overriding the equals contract. And then if you have two strings a and b, pardon me, a and a, because a and b is different, if a equals a returns true, it should do so consistent consistently across the program. And if b equals b returns false, that should also follow across the program that cannot change. But the best way to understand this is of course, by an example. So let's take a look. And as I've been doing recently, a lot of these examples are just me taking code that ChagGPT creates and repurposing them to make things a bit more clearer. So example courtesy of OpenAI or ChagGPT. We have a class called person. So just to again reiterate what we're trying to demo here is what consistency means in pertaining to the general contract. So if a class called person with two private fields, we have a string name and a integer h. Keep in mind, the string is a non primitive class and whereas int is an primitive type, non primitive, non primitive type, I mean to say, and then we do have the constructor where we set the values on the creation of the object. And here we override the equals method that's inherited from the object superclass. So what are we doing here? It's quite straightforward, really, we're checking if it's if it's equal, this equality is a reference equality. And just to save computation time and and and and to make the code more efficient. If this is true, we straight away return true, because that means it's pointing to the same memory address. So there's no question that these two objects in that case will be equal, or the comparison will be equal. If it's an instance, if it's not an instance, then we return false because there's no use in doing the rest of the executing the rest of the code if it's not an instance of the type of person, if this object we pass on to this method. And then here in line number 28 is where we do the comparison, where we are casting the value and we do it in both ways to make sure that the comparison takes place. And then really, all of that, it doesn't pertain to this particular property per se. For consistency, what we expect is we have three objects, three person objects created here. So when we compare Alice and Alice, it should always consistently return true. Whereas if we do compare to P three, person three, which is Bob, it should consistently return false, which is exactly what you'd see here. So true, true, false, false and wherever, well, whoever client that uses this class, and however they create objects of this class, this pattern should be followed. And that's what consistency is. It's really quite straightforward, which is why just your block states, if two objects are equal, they must return equal for all time, unless one or both of them is modified. In other words, mutable objects can be equal to different objects at different times while immutable objects can't. When you write a class, think hard about where they should be immutable. So we'll discuss immutability in a bit. If you conclude that it should make sure that your equals method enforces restriction that equal objects remain equal and unequal objects remain unequal for all time across the lifespan of an immutable object that that bit I added. And many states, whether or not a class is immutable, do not write an equals method that depends on unreliable resources. So he's spoken about an example there. Before we get to the idea of relying on unreliable resources, let's quickly get some theory out of the way. So what is immutability? We've got we've got two definitions here. And after that, we'll look at some demos. Firstly, by Oracle docs. Okay, the best way to think about immutability is it's an object that maintains state. It's the simplest way to think about it as a kind of heuristic. But more formally, an object is considered immutable. If it's state cannot change after it is constructed, maximum reliance on immutable objects is widely accepted as a sound strategy for creating simple, reliable code. So that said, that's from the Oracle docs. And then we have another probably a better definition really, from Biden, an immutable object is an object whose internal state remains constant after it has been entirely created. This means and this is the important part. And this really pertains to even our item. So when it comes to immutability, this means that the public API of an immutable object guarantees us that it will behave in the same way during its whole lifetime. It's that latter bit that we can connect to what Joshua Block has stated here, where he says, again, I'm repeating this point, if you conclude that it should make sure that your equals method enforces the restriction that equals or equal objects remain equal and unequal objects remain unequal for all time. So when he means if you conclude that is if you conclude that an object or a class, you're going to design it to be immutable. So another example that I use strategy to be to create is this one here, we have this class called an immutable class, which I created. And first, you can see I've created it as being public final, which means this class cannot be subclassed. And then afterwards, all the fields are declared private too, which means any outside entity, let's say, cannot tamper with these fields. There's good encapsulation in this class. And in the constructed itself, it's only when the class has been constructed initially, the values are set afterwards, it can't be tampered with. And while we do have getters for this class, where we get certain fields, you can see that there aren't any setters. So you can't even set values in this class, again, maintaining immutability. And then just an additional thing, yeah, just to make sure that it's fully immutable, we've made a deep copy and I'll explain what that is. So this field here, field three, it depends on an error list. An error list is in fact mutable. So which is why you know, let me just read out what strategy PD said itself. If the class has any immutable fields, make a deep copy of those fields in the constructor and assign the copied values to private final fields. This will ensure that the internal state of the immutable class cannot be modified. So by making a deep copy, really what we're doing is because this class or this object, when it's in runtime, depends on another resource that could be immutable, we make them independent, we decouple them so that any change to one of the other. So the field three field field three object will not affect the internal state of our broader object, which is the class at hand, the immutable class. So again, a bit of a formal definition of what a deep copy is. Again, a deep copy, this isn't very much related to what we're discussing in this item. However, of course, because we are discussing immutability, it's important to understand what a deep copy is. But formally in Java, a deep copy is a copy of an object that creates a new object with a new memory address and recursively copies the contents of the original object to the new object. This means that the new object is completely independent of the original object. And any changes made to the new object do not affect the original object. So you can see here, when we are setting the value for get field, we're returning a new object of type area list. And we are just passing the, sorry, this isn't the getter, by the way, we are passing the field three value into the constructor of the area list class. So that creates a new object. And it's an exact copy of the get field or the field three. But any change now in the new object that we give to the client will not affect the state, internal state of our broader immutable class object. That is what a deep copy does. And that's how a deep copy assists with immutability. And then from the JDK itself, I should have shown this example before the previous one, but you still get the point. If you run this code, you'll see, despite in this string, so string class is immutable, sorry, is immutable, pardon me. And in the string class, we're setting it initially to be by or done. And we're doing this replacement and then returning that value to this new name object. But what you'd see here is, even though we're doing the replacement here, that doesn't affect the internal state of the name object. So in line number 12, when we do print it, it's still going to print by or done, whereas a new name now is going to have the replacement is going to be its own object that you created newly. And then getting back to the idea of consistency and immutability, Joshua Block has given an example of mistakes made in the designing of the Java language itself, historical mistakes. So for instance, I didn't I didn't know this, I only figured this out. Oh, I only learned this by the book that the Java dot net dot URL in this library, the sorry, the Java dot net library, the URL class was relying on unreliable was relying, pardon me, was relying on hosts associated with IP addresses to affect the state of the object that it creates. But however, of course, we know that sometimes host names that are connected to IPs, they can change IP addresses can change all the time. And that itself. So the fact that that class relied on that unreliable resource was a mistake, which is why Joshua Block states the behavior of URLs equals method. So pardon me, the equals method was relying on that unreliable resource, which was the IP address, and the host name. And therefore, he states the behavior of URLs equals method was a big mistake and should not be emulated. Unfortunately, it cannot be changed due to compatibility requirements to avoid this sort of problem. Equals methods should perform only deterministic computations on memory resident objects. So as Joshua Block does highlight throughout this book, the language designers itself have made some of these mistakes. So when it comes to this mistake of consistency, or the mistake of not abiding by the property of consistency, even the people who are experts at Java have still made this mistake. And this is another example of that. So in that, let's get to the next property, the final one, last but not least, as they say, which is non knowledge. And non knowledge states, it seems quite straightforward. But once we dive into it, you'll see how there are there can be times when certain mistakes can happen. So non knowledge states for any non null reference values x, x equals null mass return false, because obviously you can't compare an object to a null value. And practically, what that really means is a null point exception can't be thrown in the equals method when the comparison takes place. So as Joshua Block states, it says that all objects must be unequal to null, of course. While it is hard to imagine accidentally returning true in response to the invocation of object dot equals null, it isn't hard to imagine accidentally throwing a null point exception, which violates a general contract or the he says the general contract prohibits this. So then he states that some classes have attempted or tried to do an explicit knowledge check to prevent this null point exception from being thrown. So here's an example of what that would look like. I'll just actually leave that there. Ignore that ever for now. If we just try and check in the equals method when the overriding with the object pass is equal to null, and here we're doing a memory reference comparison. And if it's not returned full straight away, but this isn't required, and we shall see why. So the rest of that part really is about this bit of code. So in this class, my type, what we're doing is we're checking if whatever object we pass onto the equals method, if it's a instance of my type, and if it isn't, we straight away return a false. And only if it is off type, my type, do we do the casting, as you can see here. And this check immediately prevents any class cast exceptions from taking place too, because even if you pass a null here, it's going to return true, which you shall see here. So when the client uses this new my type method and passes a null, it's going to return false as you can see. And the reason it does that is because obviously null is enough type, my type, and then the equals method recognizes that it immediately returns false. It's as straightforward as that really. And on the casting just to block states to test this argument for quality, the equals method must first cast its arguments on appropriate type. So it's accesses can be invoked, or it's fields accessed, which is what we're doing here in the casting. And then we're returning true if what we do cast by that object is equal to this, it has logical equality to this object in this class. And of course, this is just on 9 and 11, a very plain comparison, but the rest of the equals method, a lot more could take place. And we could do a lot more work to ensure there's logical equality. And that's it. That's what non knowledge is. There's not a lot to it except to put in that extra check. And this check, regardless of the context of whether we're passing a null to this method or not, would still be done. So it kind of solves our problem. But it's important to understand the property of non knowledge in principle when designing an equals method for our classes. That's it. And we're not going to move on to the rest of the item because part four is the final part almost damaged my book there. And in part four, really what we discuss is putting it all together after we've discussed all these properties of after we've discussed what equivalence relation is and everything we've discussed in this item so far, putting it all together and how to really design a good quality equals method that respects and abides by the general contract and these properties that we've been delineating and trying to understand saying that. Thank you for watching. I hope you found value in this video. I shall continue on with part four when I'm back from Queensland after my short break. And part four, as I said is putting it all together. It's the it's the it's the grand finale where we put this all together and design a superlative high quality equals method. So hopefully I see you in the next part. That's it. I'll see you in the next one. Cheers.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 7.5200000000000005, "text": " Hey, everyone. Welcome to the third part of item 10 in effective Java, which states obey", "tokens": [50364, 1911, 11, 1518, 13, 4027, 281, 264, 2636, 644, 295, 3174, 1266, 294, 4942, 10745, 11, 597, 4368, 19297, 50740], "temperature": 0.0, "avg_logprob": -0.2036644367689497, "compression_ratio": 1.5972850678733033, "no_speech_prob": 0.104557566344738}, {"id": 1, "seek": 0, "start": 7.5200000000000005, "end": 13.52, "text": " the general contract when overriding equals. So we have been covering this item across", "tokens": [50740, 264, 2674, 4364, 562, 670, 81, 2819, 6915, 13, 407, 321, 362, 668, 10322, 341, 3174, 2108, 51040], "temperature": 0.0, "avg_logprob": -0.2036644367689497, "compression_ratio": 1.5972850678733033, "no_speech_prob": 0.104557566344738}, {"id": 2, "seek": 0, "start": 13.52, "end": 18.44, "text": " multiple videos, and this is just a flow on from part one and two. So therefore, needless", "tokens": [51040, 3866, 2145, 11, 293, 341, 307, 445, 257, 3095, 322, 490, 644, 472, 293, 732, 13, 407, 4412, 11, 643, 1832, 51286], "temperature": 0.0, "avg_logprob": -0.2036644367689497, "compression_ratio": 1.5972850678733033, "no_speech_prob": 0.104557566344738}, {"id": 3, "seek": 0, "start": 18.44, "end": 24.28, "text": " to state, please do watch part one and two if any of this is to make any sense. In part", "tokens": [51286, 281, 1785, 11, 1767, 360, 1159, 644, 472, 293, 732, 498, 604, 295, 341, 307, 281, 652, 604, 2020, 13, 682, 644, 51578], "temperature": 0.0, "avg_logprob": -0.2036644367689497, "compression_ratio": 1.5972850678733033, "no_speech_prob": 0.104557566344738}, {"id": 4, "seek": 2428, "start": 24.28, "end": 32.08, "text": " two, what we discussed was we discussed the first three properties of what we would call", "tokens": [50364, 732, 11, 437, 321, 7152, 390, 321, 7152, 264, 700, 1045, 7221, 295, 437, 321, 576, 818, 50754], "temperature": 0.0, "avg_logprob": -0.17827079545206098, "compression_ratio": 1.5380434782608696, "no_speech_prob": 0.2064271867275238}, {"id": 5, "seek": 2428, "start": 32.08, "end": 42.040000000000006, "text": " an equivalence relation, and we went through them as being reflexivity, symmetry, and transitivity.", "tokens": [50754, 364, 9052, 655, 9721, 11, 293, 321, 1437, 807, 552, 382, 885, 23802, 4253, 11, 25440, 11, 293, 17976, 4253, 13, 51252], "temperature": 0.0, "avg_logprob": -0.17827079545206098, "compression_ratio": 1.5380434782608696, "no_speech_prob": 0.2064271867275238}, {"id": 6, "seek": 2428, "start": 42.040000000000006, "end": 47.8, "text": " And today we're going to discuss consistency and non-nullity. But before that, Merry Christmas", "tokens": [51252, 400, 965, 321, 434, 516, 281, 2248, 14416, 293, 2107, 12, 77, 858, 507, 13, 583, 949, 300, 11, 26572, 5272, 51540], "temperature": 0.0, "avg_logprob": -0.17827079545206098, "compression_ratio": 1.5380434782608696, "no_speech_prob": 0.2064271867275238}, {"id": 7, "seek": 4780, "start": 47.8, "end": 55.199999999999996, "text": " and Happy New Year. I hope you have a wonderful New Year's and had a wonderful Christmas.", "tokens": [50364, 293, 8277, 1873, 10289, 13, 286, 1454, 291, 362, 257, 3715, 1873, 10289, 311, 293, 632, 257, 3715, 5272, 13, 50734], "temperature": 0.0, "avg_logprob": -0.17746124892938334, "compression_ratio": 1.652014652014652, "no_speech_prob": 0.4878866374492645}, {"id": 8, "seek": 4780, "start": 55.199999999999996, "end": 60.72, "text": " When you do see this though, it's probably going to be a bit later in general mid-gen.", "tokens": [50734, 1133, 291, 360, 536, 341, 1673, 11, 309, 311, 1391, 516, 281, 312, 257, 857, 1780, 294, 2674, 2062, 12, 1766, 13, 51010], "temperature": 0.0, "avg_logprob": -0.17746124892938334, "compression_ratio": 1.652014652014652, "no_speech_prob": 0.4878866374492645}, {"id": 9, "seek": 4780, "start": 60.72, "end": 63.44, "text": " The reason being, I'm going to take some time off. I'm going to go to Queensland, and that's", "tokens": [51010, 440, 1778, 885, 11, 286, 478, 516, 281, 747, 512, 565, 766, 13, 286, 478, 516, 281, 352, 281, 36913, 11, 293, 300, 311, 51146], "temperature": 0.0, "avg_logprob": -0.17746124892938334, "compression_ratio": 1.652014652014652, "no_speech_prob": 0.4878866374492645}, {"id": 10, "seek": 4780, "start": 63.44, "end": 68.03999999999999, "text": " going to be nice. Therefore, I won't get time to edit and upload this video. But without", "tokens": [51146, 516, 281, 312, 1481, 13, 7504, 11, 286, 1582, 380, 483, 565, 281, 8129, 293, 6580, 341, 960, 13, 583, 1553, 51376], "temperature": 0.0, "avg_logprob": -0.17746124892938334, "compression_ratio": 1.652014652014652, "no_speech_prob": 0.4878866374492645}, {"id": 11, "seek": 4780, "start": 68.03999999999999, "end": 74.12, "text": " further ado, let's get started. So today we're going to discuss consistency and non-nullity.", "tokens": [51376, 3052, 22450, 11, 718, 311, 483, 1409, 13, 407, 965, 321, 434, 516, 281, 2248, 14416, 293, 2107, 12, 77, 858, 507, 13, 51680], "temperature": 0.0, "avg_logprob": -0.17746124892938334, "compression_ratio": 1.652014652014652, "no_speech_prob": 0.4878866374492645}, {"id": 12, "seek": 7412, "start": 74.12, "end": 77.84, "text": " I do apologize if there's some background noise. There's a bit of construction taking", "tokens": [50364, 286, 360, 12328, 498, 456, 311, 512, 3678, 5658, 13, 821, 311, 257, 857, 295, 6435, 1940, 50550], "temperature": 0.0, "avg_logprob": -0.14019658348777078, "compression_ratio": 1.7467532467532467, "no_speech_prob": 0.1870250403881073}, {"id": 13, "seek": 7412, "start": 77.84, "end": 82.44, "text": " place outside. I really can't do anything about it. But I'll try my best to edit the", "tokens": [50550, 1081, 2380, 13, 286, 534, 393, 380, 360, 1340, 466, 309, 13, 583, 286, 603, 853, 452, 1151, 281, 8129, 264, 50780], "temperature": 0.0, "avg_logprob": -0.14019658348777078, "compression_ratio": 1.7467532467532467, "no_speech_prob": 0.1870250403881073}, {"id": 14, "seek": 7412, "start": 82.44, "end": 87.16000000000001, "text": " audio or like, what's what I'm looking for? Reduce the background noise when I'm editing", "tokens": [50780, 6278, 420, 411, 11, 437, 311, 437, 286, 478, 1237, 337, 30, 4477, 4176, 264, 3678, 5658, 562, 286, 478, 10000, 51016], "temperature": 0.0, "avg_logprob": -0.14019658348777078, "compression_ratio": 1.7467532467532467, "no_speech_prob": 0.1870250403881073}, {"id": 15, "seek": 7412, "start": 87.16000000000001, "end": 91.24000000000001, "text": " the video in the audio. That was a weird way of putting it. What I meant to say was I'll", "tokens": [51016, 264, 960, 294, 264, 6278, 13, 663, 390, 257, 3657, 636, 295, 3372, 309, 13, 708, 286, 4140, 281, 584, 390, 286, 603, 51220], "temperature": 0.0, "avg_logprob": -0.14019658348777078, "compression_ratio": 1.7467532467532467, "no_speech_prob": 0.1870250403881073}, {"id": 16, "seek": 7412, "start": 91.24000000000001, "end": 98.12, "text": " fix up the audio. Let's start with consistency. So consistency is again a part of those equivalence", "tokens": [51220, 3191, 493, 264, 6278, 13, 961, 311, 722, 365, 14416, 13, 407, 14416, 307, 797, 257, 644, 295, 729, 9052, 655, 51564], "temperature": 0.0, "avg_logprob": -0.14019658348777078, "compression_ratio": 1.7467532467532467, "no_speech_prob": 0.1870250403881073}, {"id": 17, "seek": 7412, "start": 98.12, "end": 103.36000000000001, "text": " relation properties. And it's important to understand that to understand what the general", "tokens": [51564, 9721, 7221, 13, 400, 309, 311, 1021, 281, 1223, 300, 281, 1223, 437, 264, 2674, 51826], "temperature": 0.0, "avg_logprob": -0.14019658348777078, "compression_ratio": 1.7467532467532467, "no_speech_prob": 0.1870250403881073}, {"id": 18, "seek": 10336, "start": 103.36, "end": 111.72, "text": " contract of the equals method is. Consistency states, for any non-null reference values,", "tokens": [50364, 4364, 295, 264, 6915, 3170, 307, 13, 6923, 468, 3020, 4368, 11, 337, 604, 2107, 12, 77, 858, 6408, 4190, 11, 50782], "temperature": 0.0, "avg_logprob": -0.18273905633201062, "compression_ratio": 1.6149068322981366, "no_speech_prob": 0.19181261956691742}, {"id": 19, "seek": 10336, "start": 111.72, "end": 118.8, "text": " x and y, multiple invocations of x equals y. So x and y could be of any type, string", "tokens": [50782, 2031, 293, 288, 11, 3866, 1048, 905, 763, 295, 2031, 6915, 288, 13, 407, 2031, 293, 288, 727, 312, 295, 604, 2010, 11, 6798, 51136], "temperature": 0.0, "avg_logprob": -0.18273905633201062, "compression_ratio": 1.6149068322981366, "no_speech_prob": 0.19181261956691742}, {"id": 20, "seek": 10336, "start": 118.8, "end": 125.68, "text": " integer, that doesn't matter. But multiple invocations of x equals y must consistently", "tokens": [51136, 24922, 11, 300, 1177, 380, 1871, 13, 583, 3866, 1048, 905, 763, 295, 2031, 6915, 288, 1633, 14961, 51480], "temperature": 0.0, "avg_logprob": -0.18273905633201062, "compression_ratio": 1.6149068322981366, "no_speech_prob": 0.19181261956691742}, {"id": 21, "seek": 12568, "start": 125.68, "end": 133.68, "text": " return true or equal or consistently return false provided no information used in equals", "tokens": [50364, 2736, 2074, 420, 2681, 420, 14961, 2736, 7908, 5649, 572, 1589, 1143, 294, 6915, 50764], "temperature": 0.0, "avg_logprob": -0.1344903967846399, "compression_ratio": 1.7198067632850242, "no_speech_prob": 0.6148192286491394}, {"id": 22, "seek": 12568, "start": 133.68, "end": 139.8, "text": " comparison is modified. That being, if you compare two strings, let's say x and y are", "tokens": [50764, 9660, 307, 15873, 13, 663, 885, 11, 498, 291, 6794, 732, 13985, 11, 718, 311, 584, 2031, 293, 288, 366, 51070], "temperature": 0.0, "avg_logprob": -0.1344903967846399, "compression_ratio": 1.7198067632850242, "no_speech_prob": 0.6148192286491394}, {"id": 23, "seek": 12568, "start": 139.8, "end": 146.28, "text": " of string type, which is a superclass or a subclass of the object class, which has the", "tokens": [51070, 295, 6798, 2010, 11, 597, 307, 257, 1687, 11665, 420, 257, 1422, 11665, 295, 264, 2657, 1508, 11, 597, 575, 264, 51394], "temperature": 0.0, "avg_logprob": -0.1344903967846399, "compression_ratio": 1.7198067632850242, "no_speech_prob": 0.6148192286491394}, {"id": 24, "seek": 12568, "start": 146.28, "end": 151.72, "text": " equals contract. So let's say you're building a new type of string class and you're overriding", "tokens": [51394, 6915, 4364, 13, 407, 718, 311, 584, 291, 434, 2390, 257, 777, 2010, 295, 6798, 1508, 293, 291, 434, 670, 81, 2819, 51666], "temperature": 0.0, "avg_logprob": -0.1344903967846399, "compression_ratio": 1.7198067632850242, "no_speech_prob": 0.6148192286491394}, {"id": 25, "seek": 15172, "start": 151.72, "end": 158.52, "text": " the equals contract. And then if you have two strings a and b, pardon me, a and a, because", "tokens": [50364, 264, 6915, 4364, 13, 400, 550, 498, 291, 362, 732, 13985, 257, 293, 272, 11, 22440, 385, 11, 257, 293, 257, 11, 570, 50704], "temperature": 0.0, "avg_logprob": -0.15283690558539498, "compression_ratio": 1.7190476190476192, "no_speech_prob": 0.47639209032058716}, {"id": 26, "seek": 15172, "start": 158.52, "end": 164.76, "text": " a and b is different, if a equals a returns true, it should do so consistent consistently", "tokens": [50704, 257, 293, 272, 307, 819, 11, 498, 257, 6915, 257, 11247, 2074, 11, 309, 820, 360, 370, 8398, 14961, 51016], "temperature": 0.0, "avg_logprob": -0.15283690558539498, "compression_ratio": 1.7190476190476192, "no_speech_prob": 0.47639209032058716}, {"id": 27, "seek": 15172, "start": 164.76, "end": 171.07999999999998, "text": " across the program. And if b equals b returns false, that should also follow across the", "tokens": [51016, 2108, 264, 1461, 13, 400, 498, 272, 6915, 272, 11247, 7908, 11, 300, 820, 611, 1524, 2108, 264, 51332], "temperature": 0.0, "avg_logprob": -0.15283690558539498, "compression_ratio": 1.7190476190476192, "no_speech_prob": 0.47639209032058716}, {"id": 28, "seek": 15172, "start": 171.07999999999998, "end": 176.76, "text": " program that cannot change. But the best way to understand this is of course, by an example.", "tokens": [51332, 1461, 300, 2644, 1319, 13, 583, 264, 1151, 636, 281, 1223, 341, 307, 295, 1164, 11, 538, 364, 1365, 13, 51616], "temperature": 0.0, "avg_logprob": -0.15283690558539498, "compression_ratio": 1.7190476190476192, "no_speech_prob": 0.47639209032058716}, {"id": 29, "seek": 17676, "start": 176.76, "end": 181.35999999999999, "text": " So let's take a look. And as I've been doing recently, a lot of these examples are just", "tokens": [50364, 407, 718, 311, 747, 257, 574, 13, 400, 382, 286, 600, 668, 884, 3938, 11, 257, 688, 295, 613, 5110, 366, 445, 50594], "temperature": 0.0, "avg_logprob": -0.20025020398591695, "compression_ratio": 1.5387931034482758, "no_speech_prob": 0.584835410118103}, {"id": 30, "seek": 17676, "start": 181.35999999999999, "end": 188.48, "text": " me taking code that ChagGPT creates and repurposing them to make things a bit more clearer. So", "tokens": [50594, 385, 1940, 3089, 300, 761, 559, 38, 47, 51, 7829, 293, 1085, 20130, 6110, 552, 281, 652, 721, 257, 857, 544, 26131, 13, 407, 50950], "temperature": 0.0, "avg_logprob": -0.20025020398591695, "compression_ratio": 1.5387931034482758, "no_speech_prob": 0.584835410118103}, {"id": 31, "seek": 17676, "start": 188.48, "end": 195.0, "text": " example courtesy of OpenAI or ChagGPT. We have a class called person. So just to again", "tokens": [50950, 1365, 41704, 295, 7238, 48698, 420, 761, 559, 38, 47, 51, 13, 492, 362, 257, 1508, 1219, 954, 13, 407, 445, 281, 797, 51276], "temperature": 0.0, "avg_logprob": -0.20025020398591695, "compression_ratio": 1.5387931034482758, "no_speech_prob": 0.584835410118103}, {"id": 32, "seek": 17676, "start": 195.0, "end": 202.92, "text": " reiterate what we're trying to demo here is what consistency means in pertaining to the", "tokens": [51276, 33528, 437, 321, 434, 1382, 281, 10723, 510, 307, 437, 14416, 1355, 294, 49582, 281, 264, 51672], "temperature": 0.0, "avg_logprob": -0.20025020398591695, "compression_ratio": 1.5387931034482758, "no_speech_prob": 0.584835410118103}, {"id": 33, "seek": 20292, "start": 202.92, "end": 208.64, "text": " general contract. So if a class called person with two private fields, we have a string", "tokens": [50364, 2674, 4364, 13, 407, 498, 257, 1508, 1219, 954, 365, 732, 4551, 7909, 11, 321, 362, 257, 6798, 50650], "temperature": 0.0, "avg_logprob": -0.16162029179659756, "compression_ratio": 1.7259615384615385, "no_speech_prob": 0.11914019286632538}, {"id": 34, "seek": 20292, "start": 208.64, "end": 216.0, "text": " name and a integer h. Keep in mind, the string is a non primitive class and whereas int is", "tokens": [50650, 1315, 293, 257, 24922, 276, 13, 5527, 294, 1575, 11, 264, 6798, 307, 257, 2107, 28540, 1508, 293, 9735, 560, 307, 51018], "temperature": 0.0, "avg_logprob": -0.16162029179659756, "compression_ratio": 1.7259615384615385, "no_speech_prob": 0.11914019286632538}, {"id": 35, "seek": 20292, "start": 216.0, "end": 221.04, "text": " an primitive type, non primitive, non primitive type, I mean to say, and then we do have the", "tokens": [51018, 364, 28540, 2010, 11, 2107, 28540, 11, 2107, 28540, 2010, 11, 286, 914, 281, 584, 11, 293, 550, 321, 360, 362, 264, 51270], "temperature": 0.0, "avg_logprob": -0.16162029179659756, "compression_ratio": 1.7259615384615385, "no_speech_prob": 0.11914019286632538}, {"id": 36, "seek": 20292, "start": 221.04, "end": 227.27999999999997, "text": " constructor where we set the values on the creation of the object. And here we override", "tokens": [51270, 47479, 689, 321, 992, 264, 4190, 322, 264, 8016, 295, 264, 2657, 13, 400, 510, 321, 42321, 51582], "temperature": 0.0, "avg_logprob": -0.16162029179659756, "compression_ratio": 1.7259615384615385, "no_speech_prob": 0.11914019286632538}, {"id": 37, "seek": 22728, "start": 227.28, "end": 235.48, "text": " the equals method that's inherited from the object superclass. So what are we doing here?", "tokens": [50364, 264, 6915, 3170, 300, 311, 27091, 490, 264, 2657, 1687, 11665, 13, 407, 437, 366, 321, 884, 510, 30, 50774], "temperature": 0.0, "avg_logprob": -0.15590687455802127, "compression_ratio": 1.6108597285067874, "no_speech_prob": 0.08032368123531342}, {"id": 38, "seek": 22728, "start": 235.48, "end": 241.72, "text": " It's quite straightforward, really, we're checking if it's if it's equal, this equality", "tokens": [50774, 467, 311, 1596, 15325, 11, 534, 11, 321, 434, 8568, 498, 309, 311, 498, 309, 311, 2681, 11, 341, 14949, 51086], "temperature": 0.0, "avg_logprob": -0.15590687455802127, "compression_ratio": 1.6108597285067874, "no_speech_prob": 0.08032368123531342}, {"id": 39, "seek": 22728, "start": 241.72, "end": 249.12, "text": " is a reference equality. And just to save computation time and and and and to make the", "tokens": [51086, 307, 257, 6408, 14949, 13, 400, 445, 281, 3155, 24903, 565, 293, 293, 293, 293, 281, 652, 264, 51456], "temperature": 0.0, "avg_logprob": -0.15590687455802127, "compression_ratio": 1.6108597285067874, "no_speech_prob": 0.08032368123531342}, {"id": 40, "seek": 22728, "start": 249.12, "end": 254.72, "text": " code more efficient. If this is true, we straight away return true, because that means it's", "tokens": [51456, 3089, 544, 7148, 13, 759, 341, 307, 2074, 11, 321, 2997, 1314, 2736, 2074, 11, 570, 300, 1355, 309, 311, 51736], "temperature": 0.0, "avg_logprob": -0.15590687455802127, "compression_ratio": 1.6108597285067874, "no_speech_prob": 0.08032368123531342}, {"id": 41, "seek": 25472, "start": 254.72, "end": 261.24, "text": " pointing to the same memory address. So there's no question that these two objects in that", "tokens": [50364, 12166, 281, 264, 912, 4675, 2985, 13, 407, 456, 311, 572, 1168, 300, 613, 732, 6565, 294, 300, 50690], "temperature": 0.0, "avg_logprob": -0.14168469947681092, "compression_ratio": 1.9230769230769231, "no_speech_prob": 0.011681887321174145}, {"id": 42, "seek": 25472, "start": 261.24, "end": 265.52, "text": " case will be equal, or the comparison will be equal. If it's an instance, if it's not", "tokens": [50690, 1389, 486, 312, 2681, 11, 420, 264, 9660, 486, 312, 2681, 13, 759, 309, 311, 364, 5197, 11, 498, 309, 311, 406, 50904], "temperature": 0.0, "avg_logprob": -0.14168469947681092, "compression_ratio": 1.9230769230769231, "no_speech_prob": 0.011681887321174145}, {"id": 43, "seek": 25472, "start": 265.52, "end": 270.2, "text": " an instance, then we return false because there's no use in doing the rest of the executing", "tokens": [50904, 364, 5197, 11, 550, 321, 2736, 7908, 570, 456, 311, 572, 764, 294, 884, 264, 1472, 295, 264, 32368, 51138], "temperature": 0.0, "avg_logprob": -0.14168469947681092, "compression_ratio": 1.9230769230769231, "no_speech_prob": 0.011681887321174145}, {"id": 44, "seek": 25472, "start": 270.2, "end": 274.56, "text": " the rest of the code if it's not an instance of the type of person, if this object we pass", "tokens": [51138, 264, 1472, 295, 264, 3089, 498, 309, 311, 406, 364, 5197, 295, 264, 2010, 295, 954, 11, 498, 341, 2657, 321, 1320, 51356], "temperature": 0.0, "avg_logprob": -0.14168469947681092, "compression_ratio": 1.9230769230769231, "no_speech_prob": 0.011681887321174145}, {"id": 45, "seek": 25472, "start": 274.56, "end": 280.48, "text": " on to this method. And then here in line number 28 is where we do the comparison, where we", "tokens": [51356, 322, 281, 341, 3170, 13, 400, 550, 510, 294, 1622, 1230, 7562, 307, 689, 321, 360, 264, 9660, 11, 689, 321, 51652], "temperature": 0.0, "avg_logprob": -0.14168469947681092, "compression_ratio": 1.9230769230769231, "no_speech_prob": 0.011681887321174145}, {"id": 46, "seek": 28048, "start": 280.48, "end": 285.32, "text": " are casting the value and we do it in both ways to make sure that the comparison takes", "tokens": [50364, 366, 17301, 264, 2158, 293, 321, 360, 309, 294, 1293, 2098, 281, 652, 988, 300, 264, 9660, 2516, 50606], "temperature": 0.0, "avg_logprob": -0.16161095952413168, "compression_ratio": 1.5909090909090908, "no_speech_prob": 0.0316099189221859}, {"id": 47, "seek": 28048, "start": 285.32, "end": 292.16, "text": " place. And then really, all of that, it doesn't pertain to this particular property per se.", "tokens": [50606, 1081, 13, 400, 550, 534, 11, 439, 295, 300, 11, 309, 1177, 380, 13269, 491, 281, 341, 1729, 4707, 680, 369, 13, 50948], "temperature": 0.0, "avg_logprob": -0.16161095952413168, "compression_ratio": 1.5909090909090908, "no_speech_prob": 0.0316099189221859}, {"id": 48, "seek": 28048, "start": 292.16, "end": 298.52000000000004, "text": " For consistency, what we expect is we have three objects, three person objects created", "tokens": [50948, 1171, 14416, 11, 437, 321, 2066, 307, 321, 362, 1045, 6565, 11, 1045, 954, 6565, 2942, 51266], "temperature": 0.0, "avg_logprob": -0.16161095952413168, "compression_ratio": 1.5909090909090908, "no_speech_prob": 0.0316099189221859}, {"id": 49, "seek": 28048, "start": 298.52000000000004, "end": 304.72, "text": " here. So when we compare Alice and Alice, it should always consistently return true.", "tokens": [51266, 510, 13, 407, 562, 321, 6794, 16004, 293, 16004, 11, 309, 820, 1009, 14961, 2736, 2074, 13, 51576], "temperature": 0.0, "avg_logprob": -0.16161095952413168, "compression_ratio": 1.5909090909090908, "no_speech_prob": 0.0316099189221859}, {"id": 50, "seek": 30472, "start": 304.72, "end": 311.74, "text": " Whereas if we do compare to P three, person three, which is Bob, it should consistently", "tokens": [50364, 13813, 498, 321, 360, 6794, 281, 430, 1045, 11, 954, 1045, 11, 597, 307, 6085, 11, 309, 820, 14961, 50715], "temperature": 0.0, "avg_logprob": -0.19483533016470975, "compression_ratio": 1.6571428571428573, "no_speech_prob": 0.0758330225944519}, {"id": 51, "seek": 30472, "start": 311.74, "end": 319.16, "text": " return false, which is exactly what you'd see here. So true, true, false, false and", "tokens": [50715, 2736, 7908, 11, 597, 307, 2293, 437, 291, 1116, 536, 510, 13, 407, 2074, 11, 2074, 11, 7908, 11, 7908, 293, 51086], "temperature": 0.0, "avg_logprob": -0.19483533016470975, "compression_ratio": 1.6571428571428573, "no_speech_prob": 0.0758330225944519}, {"id": 52, "seek": 30472, "start": 319.16, "end": 324.52000000000004, "text": " wherever, well, whoever client that uses this class, and however they create objects of", "tokens": [51086, 8660, 11, 731, 11, 11387, 6423, 300, 4960, 341, 1508, 11, 293, 4461, 436, 1884, 6565, 295, 51354], "temperature": 0.0, "avg_logprob": -0.19483533016470975, "compression_ratio": 1.6571428571428573, "no_speech_prob": 0.0758330225944519}, {"id": 53, "seek": 30472, "start": 324.52000000000004, "end": 330.0, "text": " this class, this pattern should be followed. And that's what consistency is. It's really", "tokens": [51354, 341, 1508, 11, 341, 5102, 820, 312, 6263, 13, 400, 300, 311, 437, 14416, 307, 13, 467, 311, 534, 51628], "temperature": 0.0, "avg_logprob": -0.19483533016470975, "compression_ratio": 1.6571428571428573, "no_speech_prob": 0.0758330225944519}, {"id": 54, "seek": 33000, "start": 330.0, "end": 334.88, "text": " quite straightforward, which is why just your block states, if two objects are equal,", "tokens": [50364, 1596, 15325, 11, 597, 307, 983, 445, 428, 3461, 4368, 11, 498, 732, 6565, 366, 2681, 11, 50608], "temperature": 0.0, "avg_logprob": -0.15195968264625187, "compression_ratio": 1.7272727272727273, "no_speech_prob": 0.380948930978775}, {"id": 55, "seek": 33000, "start": 334.88, "end": 340.96, "text": " they must return equal for all time, unless one or both of them is modified. In other", "tokens": [50608, 436, 1633, 2736, 2681, 337, 439, 565, 11, 5969, 472, 420, 1293, 295, 552, 307, 15873, 13, 682, 661, 50912], "temperature": 0.0, "avg_logprob": -0.15195968264625187, "compression_ratio": 1.7272727272727273, "no_speech_prob": 0.380948930978775}, {"id": 56, "seek": 33000, "start": 340.96, "end": 347.2, "text": " words, mutable objects can be equal to different objects at different times while immutable", "tokens": [50912, 2283, 11, 5839, 712, 6565, 393, 312, 2681, 281, 819, 6565, 412, 819, 1413, 1339, 3397, 32148, 51224], "temperature": 0.0, "avg_logprob": -0.15195968264625187, "compression_ratio": 1.7272727272727273, "no_speech_prob": 0.380948930978775}, {"id": 57, "seek": 33000, "start": 347.2, "end": 353.56, "text": " objects can't. When you write a class, think hard about where they should be immutable.", "tokens": [51224, 6565, 393, 380, 13, 1133, 291, 2464, 257, 1508, 11, 519, 1152, 466, 689, 436, 820, 312, 3397, 32148, 13, 51542], "temperature": 0.0, "avg_logprob": -0.15195968264625187, "compression_ratio": 1.7272727272727273, "no_speech_prob": 0.380948930978775}, {"id": 58, "seek": 33000, "start": 353.56, "end": 359.0, "text": " So we'll discuss immutability in a bit. If you conclude that it should make sure that", "tokens": [51542, 407, 321, 603, 2248, 3397, 325, 2310, 294, 257, 857, 13, 759, 291, 16886, 300, 309, 820, 652, 988, 300, 51814], "temperature": 0.0, "avg_logprob": -0.15195968264625187, "compression_ratio": 1.7272727272727273, "no_speech_prob": 0.380948930978775}, {"id": 59, "seek": 35900, "start": 359.0, "end": 364.76, "text": " your equals method enforces restriction that equal objects remain equal and unequal objects", "tokens": [50364, 428, 6915, 3170, 25495, 887, 29529, 300, 2681, 6565, 6222, 2681, 293, 2251, 22345, 6565, 50652], "temperature": 0.0, "avg_logprob": -0.13312700182892556, "compression_ratio": 1.7069767441860466, "no_speech_prob": 0.06461390107870102}, {"id": 60, "seek": 35900, "start": 364.76, "end": 371.56, "text": " remain unequal for all time across the lifespan of an immutable object that that bit I added.", "tokens": [50652, 6222, 2251, 22345, 337, 439, 565, 2108, 264, 40361, 295, 364, 3397, 32148, 2657, 300, 300, 857, 286, 3869, 13, 50992], "temperature": 0.0, "avg_logprob": -0.13312700182892556, "compression_ratio": 1.7069767441860466, "no_speech_prob": 0.06461390107870102}, {"id": 61, "seek": 35900, "start": 371.56, "end": 377.24, "text": " And many states, whether or not a class is immutable, do not write an equals method that", "tokens": [50992, 400, 867, 4368, 11, 1968, 420, 406, 257, 1508, 307, 3397, 32148, 11, 360, 406, 2464, 364, 6915, 3170, 300, 51276], "temperature": 0.0, "avg_logprob": -0.13312700182892556, "compression_ratio": 1.7069767441860466, "no_speech_prob": 0.06461390107870102}, {"id": 62, "seek": 35900, "start": 377.24, "end": 383.24, "text": " depends on unreliable resources. So he's spoken about an example there. Before we get to the", "tokens": [51276, 5946, 322, 20584, 2081, 712, 3593, 13, 407, 415, 311, 10759, 466, 364, 1365, 456, 13, 4546, 321, 483, 281, 264, 51576], "temperature": 0.0, "avg_logprob": -0.13312700182892556, "compression_ratio": 1.7069767441860466, "no_speech_prob": 0.06461390107870102}, {"id": 63, "seek": 38324, "start": 383.24, "end": 389.2, "text": " idea of relying on unreliable resources, let's quickly get some theory out of the way.", "tokens": [50364, 1558, 295, 24140, 322, 20584, 2081, 712, 3593, 11, 718, 311, 2661, 483, 512, 5261, 484, 295, 264, 636, 13, 50662], "temperature": 0.0, "avg_logprob": -0.12626376272249623, "compression_ratio": 1.6704119850187267, "no_speech_prob": 0.021943990141153336}, {"id": 64, "seek": 38324, "start": 389.2, "end": 393.08, "text": " So what is immutability? We've got we've got two definitions here. And after that, we'll", "tokens": [50662, 407, 437, 307, 3397, 325, 2310, 30, 492, 600, 658, 321, 600, 658, 732, 21988, 510, 13, 400, 934, 300, 11, 321, 603, 50856], "temperature": 0.0, "avg_logprob": -0.12626376272249623, "compression_ratio": 1.6704119850187267, "no_speech_prob": 0.021943990141153336}, {"id": 65, "seek": 38324, "start": 393.08, "end": 401.16, "text": " look at some demos. Firstly, by Oracle docs. Okay, the best way to think about immutability", "tokens": [50856, 574, 412, 512, 33788, 13, 20042, 11, 538, 25654, 45623, 13, 1033, 11, 264, 1151, 636, 281, 519, 466, 3397, 325, 2310, 51260], "temperature": 0.0, "avg_logprob": -0.12626376272249623, "compression_ratio": 1.6704119850187267, "no_speech_prob": 0.021943990141153336}, {"id": 66, "seek": 38324, "start": 401.16, "end": 405.44, "text": " is it's an object that maintains state. It's the simplest way to think about it as a kind", "tokens": [51260, 307, 309, 311, 364, 2657, 300, 33385, 1785, 13, 467, 311, 264, 22811, 636, 281, 519, 466, 309, 382, 257, 733, 51474], "temperature": 0.0, "avg_logprob": -0.12626376272249623, "compression_ratio": 1.6704119850187267, "no_speech_prob": 0.021943990141153336}, {"id": 67, "seek": 38324, "start": 405.44, "end": 411.28000000000003, "text": " of heuristic. But more formally, an object is considered immutable. If it's state cannot", "tokens": [51474, 295, 415, 374, 3142, 13, 583, 544, 25983, 11, 364, 2657, 307, 4888, 3397, 32148, 13, 759, 309, 311, 1785, 2644, 51766], "temperature": 0.0, "avg_logprob": -0.12626376272249623, "compression_ratio": 1.6704119850187267, "no_speech_prob": 0.021943990141153336}, {"id": 68, "seek": 41128, "start": 411.32, "end": 417.84, "text": " change after it is constructed, maximum reliance on immutable objects is widely accepted as", "tokens": [50366, 1319, 934, 309, 307, 17083, 11, 6674, 1039, 6276, 322, 3397, 32148, 6565, 307, 13371, 9035, 382, 50692], "temperature": 0.0, "avg_logprob": -0.18269078871783087, "compression_ratio": 1.6752767527675276, "no_speech_prob": 0.3414611220359802}, {"id": 69, "seek": 41128, "start": 417.84, "end": 422.96, "text": " a sound strategy for creating simple, reliable code. So that said, that's from the Oracle", "tokens": [50692, 257, 1626, 5206, 337, 4084, 2199, 11, 12924, 3089, 13, 407, 300, 848, 11, 300, 311, 490, 264, 25654, 50948], "temperature": 0.0, "avg_logprob": -0.18269078871783087, "compression_ratio": 1.6752767527675276, "no_speech_prob": 0.3414611220359802}, {"id": 70, "seek": 41128, "start": 422.96, "end": 428.35999999999996, "text": " docs. And then we have another probably a better definition really, from Biden, an immutable", "tokens": [50948, 45623, 13, 400, 550, 321, 362, 1071, 1391, 257, 1101, 7123, 534, 11, 490, 9877, 11, 364, 3397, 32148, 51218], "temperature": 0.0, "avg_logprob": -0.18269078871783087, "compression_ratio": 1.6752767527675276, "no_speech_prob": 0.3414611220359802}, {"id": 71, "seek": 41128, "start": 428.35999999999996, "end": 435.11999999999995, "text": " object is an object whose internal state remains constant after it has been entirely created.", "tokens": [51218, 2657, 307, 364, 2657, 6104, 6920, 1785, 7023, 5754, 934, 309, 575, 668, 7696, 2942, 13, 51556], "temperature": 0.0, "avg_logprob": -0.18269078871783087, "compression_ratio": 1.6752767527675276, "no_speech_prob": 0.3414611220359802}, {"id": 72, "seek": 41128, "start": 435.11999999999995, "end": 440.44, "text": " This means and this is the important part. And this really pertains to even our item.", "tokens": [51556, 639, 1355, 293, 341, 307, 264, 1021, 644, 13, 400, 341, 534, 13269, 2315, 281, 754, 527, 3174, 13, 51822], "temperature": 0.0, "avg_logprob": -0.18269078871783087, "compression_ratio": 1.6752767527675276, "no_speech_prob": 0.3414611220359802}, {"id": 73, "seek": 44044, "start": 440.44, "end": 444.71999999999997, "text": " So when it comes to immutability, this means that the public API of an immutable object", "tokens": [50364, 407, 562, 309, 1487, 281, 3397, 325, 2310, 11, 341, 1355, 300, 264, 1908, 9362, 295, 364, 3397, 32148, 2657, 50578], "temperature": 0.0, "avg_logprob": -0.13354911254002497, "compression_ratio": 1.7110266159695817, "no_speech_prob": 0.004330446943640709}, {"id": 74, "seek": 44044, "start": 444.71999999999997, "end": 451.36, "text": " guarantees us that it will behave in the same way during its whole lifetime. It's that latter", "tokens": [50578, 32567, 505, 300, 309, 486, 15158, 294, 264, 912, 636, 1830, 1080, 1379, 11364, 13, 467, 311, 300, 18481, 50910], "temperature": 0.0, "avg_logprob": -0.13354911254002497, "compression_ratio": 1.7110266159695817, "no_speech_prob": 0.004330446943640709}, {"id": 75, "seek": 44044, "start": 451.36, "end": 455.64, "text": " bit that we can connect to what Joshua Block has stated here, where he says, again, I'm", "tokens": [50910, 857, 300, 321, 393, 1745, 281, 437, 24005, 17500, 575, 11323, 510, 11, 689, 415, 1619, 11, 797, 11, 286, 478, 51124], "temperature": 0.0, "avg_logprob": -0.13354911254002497, "compression_ratio": 1.7110266159695817, "no_speech_prob": 0.004330446943640709}, {"id": 76, "seek": 44044, "start": 455.64, "end": 460.52, "text": " repeating this point, if you conclude that it should make sure that your equals method", "tokens": [51124, 18617, 341, 935, 11, 498, 291, 16886, 300, 309, 820, 652, 988, 300, 428, 6915, 3170, 51368], "temperature": 0.0, "avg_logprob": -0.13354911254002497, "compression_ratio": 1.7110266159695817, "no_speech_prob": 0.004330446943640709}, {"id": 77, "seek": 44044, "start": 460.52, "end": 466.96, "text": " enforces the restriction that equals or equal objects remain equal and unequal objects remain", "tokens": [51368, 25495, 887, 264, 29529, 300, 6915, 420, 2681, 6565, 6222, 2681, 293, 2251, 22345, 6565, 6222, 51690], "temperature": 0.0, "avg_logprob": -0.13354911254002497, "compression_ratio": 1.7110266159695817, "no_speech_prob": 0.004330446943640709}, {"id": 78, "seek": 46696, "start": 467.03999999999996, "end": 470.71999999999997, "text": " unequal for all time. So when he means if you conclude that is if you conclude that", "tokens": [50368, 2251, 22345, 337, 439, 565, 13, 407, 562, 415, 1355, 498, 291, 16886, 300, 307, 498, 291, 16886, 300, 50552], "temperature": 0.0, "avg_logprob": -0.17116197517939977, "compression_ratio": 1.7670682730923695, "no_speech_prob": 0.040226925164461136}, {"id": 79, "seek": 46696, "start": 470.71999999999997, "end": 475.59999999999997, "text": " an object or a class, you're going to design it to be immutable. So another example that", "tokens": [50552, 364, 2657, 420, 257, 1508, 11, 291, 434, 516, 281, 1715, 309, 281, 312, 3397, 32148, 13, 407, 1071, 1365, 300, 50796], "temperature": 0.0, "avg_logprob": -0.17116197517939977, "compression_ratio": 1.7670682730923695, "no_speech_prob": 0.040226925164461136}, {"id": 80, "seek": 46696, "start": 475.59999999999997, "end": 480.47999999999996, "text": " I use strategy to be to create is this one here, we have this class called an immutable", "tokens": [50796, 286, 764, 5206, 281, 312, 281, 1884, 307, 341, 472, 510, 11, 321, 362, 341, 1508, 1219, 364, 3397, 32148, 51040], "temperature": 0.0, "avg_logprob": -0.17116197517939977, "compression_ratio": 1.7670682730923695, "no_speech_prob": 0.040226925164461136}, {"id": 81, "seek": 46696, "start": 480.47999999999996, "end": 485.12, "text": " class, which I created. And first, you can see I've created it as being public final,", "tokens": [51040, 1508, 11, 597, 286, 2942, 13, 400, 700, 11, 291, 393, 536, 286, 600, 2942, 309, 382, 885, 1908, 2572, 11, 51272], "temperature": 0.0, "avg_logprob": -0.17116197517939977, "compression_ratio": 1.7670682730923695, "no_speech_prob": 0.040226925164461136}, {"id": 82, "seek": 46696, "start": 485.12, "end": 491.15999999999997, "text": " which means this class cannot be subclassed. And then afterwards, all the fields are declared", "tokens": [51272, 597, 1355, 341, 1508, 2644, 312, 1422, 11665, 292, 13, 400, 550, 10543, 11, 439, 264, 7909, 366, 15489, 51574], "temperature": 0.0, "avg_logprob": -0.17116197517939977, "compression_ratio": 1.7670682730923695, "no_speech_prob": 0.040226925164461136}, {"id": 83, "seek": 49116, "start": 491.16, "end": 499.36, "text": " private too, which means any outside entity, let's say, cannot tamper with these fields.", "tokens": [50364, 4551, 886, 11, 597, 1355, 604, 2380, 13977, 11, 718, 311, 584, 11, 2644, 7677, 610, 365, 613, 7909, 13, 50774], "temperature": 0.0, "avg_logprob": -0.16498828578639674, "compression_ratio": 1.7620967741935485, "no_speech_prob": 0.0769491195678711}, {"id": 84, "seek": 49116, "start": 499.36, "end": 505.8, "text": " There's good encapsulation in this class. And in the constructed itself, it's only when", "tokens": [50774, 821, 311, 665, 38745, 2776, 294, 341, 1508, 13, 400, 294, 264, 17083, 2564, 11, 309, 311, 787, 562, 51096], "temperature": 0.0, "avg_logprob": -0.16498828578639674, "compression_ratio": 1.7620967741935485, "no_speech_prob": 0.0769491195678711}, {"id": 85, "seek": 49116, "start": 505.8, "end": 510.0, "text": " the class has been constructed initially, the values are set afterwards, it can't be", "tokens": [51096, 264, 1508, 575, 668, 17083, 9105, 11, 264, 4190, 366, 992, 10543, 11, 309, 393, 380, 312, 51306], "temperature": 0.0, "avg_logprob": -0.16498828578639674, "compression_ratio": 1.7620967741935485, "no_speech_prob": 0.0769491195678711}, {"id": 86, "seek": 49116, "start": 510.0, "end": 514.52, "text": " tampered with. And while we do have getters for this class, where we get certain fields,", "tokens": [51306, 7677, 40004, 365, 13, 400, 1339, 321, 360, 362, 483, 1559, 337, 341, 1508, 11, 689, 321, 483, 1629, 7909, 11, 51532], "temperature": 0.0, "avg_logprob": -0.16498828578639674, "compression_ratio": 1.7620967741935485, "no_speech_prob": 0.0769491195678711}, {"id": 87, "seek": 49116, "start": 514.52, "end": 519.0400000000001, "text": " you can see that there aren't any setters. So you can't even set values in this class,", "tokens": [51532, 291, 393, 536, 300, 456, 3212, 380, 604, 992, 1559, 13, 407, 291, 393, 380, 754, 992, 4190, 294, 341, 1508, 11, 51758], "temperature": 0.0, "avg_logprob": -0.16498828578639674, "compression_ratio": 1.7620967741935485, "no_speech_prob": 0.0769491195678711}, {"id": 88, "seek": 51904, "start": 519.04, "end": 523.48, "text": " again, maintaining immutability. And then just an additional thing, yeah, just to make", "tokens": [50364, 797, 11, 14916, 3397, 325, 2310, 13, 400, 550, 445, 364, 4497, 551, 11, 1338, 11, 445, 281, 652, 50586], "temperature": 0.0, "avg_logprob": -0.20860964791816577, "compression_ratio": 1.6964980544747081, "no_speech_prob": 0.12935206294059753}, {"id": 89, "seek": 51904, "start": 523.48, "end": 527.3199999999999, "text": " sure that it's fully immutable, we've made a deep copy and I'll explain what that is.", "tokens": [50586, 988, 300, 309, 311, 4498, 3397, 32148, 11, 321, 600, 1027, 257, 2452, 5055, 293, 286, 603, 2903, 437, 300, 307, 13, 50778], "temperature": 0.0, "avg_logprob": -0.20860964791816577, "compression_ratio": 1.6964980544747081, "no_speech_prob": 0.12935206294059753}, {"id": 90, "seek": 51904, "start": 527.3199999999999, "end": 534.64, "text": " So this field here, field three, it depends on an error list. An error list is in fact", "tokens": [50778, 407, 341, 2519, 510, 11, 2519, 1045, 11, 309, 5946, 322, 364, 6713, 1329, 13, 1107, 6713, 1329, 307, 294, 1186, 51144], "temperature": 0.0, "avg_logprob": -0.20860964791816577, "compression_ratio": 1.6964980544747081, "no_speech_prob": 0.12935206294059753}, {"id": 91, "seek": 51904, "start": 534.64, "end": 541.1999999999999, "text": " mutable. So which is why you know, let me just read out what strategy PD said itself. If", "tokens": [51144, 5839, 712, 13, 407, 597, 307, 983, 291, 458, 11, 718, 385, 445, 1401, 484, 437, 5206, 10464, 848, 2564, 13, 759, 51472], "temperature": 0.0, "avg_logprob": -0.20860964791816577, "compression_ratio": 1.6964980544747081, "no_speech_prob": 0.12935206294059753}, {"id": 92, "seek": 51904, "start": 541.1999999999999, "end": 548.04, "text": " the class has any immutable fields, make a deep copy of those fields in the constructor", "tokens": [51472, 264, 1508, 575, 604, 3397, 32148, 7909, 11, 652, 257, 2452, 5055, 295, 729, 7909, 294, 264, 47479, 51814], "temperature": 0.0, "avg_logprob": -0.20860964791816577, "compression_ratio": 1.6964980544747081, "no_speech_prob": 0.12935206294059753}, {"id": 93, "seek": 54804, "start": 548.04, "end": 553.8399999999999, "text": " and assign the copied values to private final fields. This will ensure that the internal", "tokens": [50364, 293, 6269, 264, 25365, 4190, 281, 4551, 2572, 7909, 13, 639, 486, 5586, 300, 264, 6920, 50654], "temperature": 0.0, "avg_logprob": -0.14793790835086432, "compression_ratio": 1.795275590551181, "no_speech_prob": 0.09664560109376907}, {"id": 94, "seek": 54804, "start": 553.8399999999999, "end": 558.8, "text": " state of the immutable class cannot be modified. So by making a deep copy, really what we're", "tokens": [50654, 1785, 295, 264, 3397, 32148, 1508, 2644, 312, 15873, 13, 407, 538, 1455, 257, 2452, 5055, 11, 534, 437, 321, 434, 50902], "temperature": 0.0, "avg_logprob": -0.14793790835086432, "compression_ratio": 1.795275590551181, "no_speech_prob": 0.09664560109376907}, {"id": 95, "seek": 54804, "start": 558.8, "end": 564.36, "text": " doing is because this class or this object, when it's in runtime, depends on another resource", "tokens": [50902, 884, 307, 570, 341, 1508, 420, 341, 2657, 11, 562, 309, 311, 294, 34474, 11, 5946, 322, 1071, 7684, 51180], "temperature": 0.0, "avg_logprob": -0.14793790835086432, "compression_ratio": 1.795275590551181, "no_speech_prob": 0.09664560109376907}, {"id": 96, "seek": 54804, "start": 564.36, "end": 570.1999999999999, "text": " that could be immutable, we make them independent, we decouple them so that any change to one", "tokens": [51180, 300, 727, 312, 3397, 32148, 11, 321, 652, 552, 6695, 11, 321, 979, 263, 781, 552, 370, 300, 604, 1319, 281, 472, 51472], "temperature": 0.0, "avg_logprob": -0.14793790835086432, "compression_ratio": 1.795275590551181, "no_speech_prob": 0.09664560109376907}, {"id": 97, "seek": 54804, "start": 570.1999999999999, "end": 575.24, "text": " of the other. So the field three field field three object will not affect the internal", "tokens": [51472, 295, 264, 661, 13, 407, 264, 2519, 1045, 2519, 2519, 1045, 2657, 486, 406, 3345, 264, 6920, 51724], "temperature": 0.0, "avg_logprob": -0.14793790835086432, "compression_ratio": 1.795275590551181, "no_speech_prob": 0.09664560109376907}, {"id": 98, "seek": 57524, "start": 575.24, "end": 580.2, "text": " state of our broader object, which is the class at hand, the immutable class. So again,", "tokens": [50364, 1785, 295, 527, 13227, 2657, 11, 597, 307, 264, 1508, 412, 1011, 11, 264, 3397, 32148, 1508, 13, 407, 797, 11, 50612], "temperature": 0.0, "avg_logprob": -0.11636476681150239, "compression_ratio": 1.7896825396825398, "no_speech_prob": 0.15396302938461304}, {"id": 99, "seek": 57524, "start": 580.2, "end": 586.8, "text": " a bit of a formal definition of what a deep copy is. Again, a deep copy, this isn't very", "tokens": [50612, 257, 857, 295, 257, 9860, 7123, 295, 437, 257, 2452, 5055, 307, 13, 3764, 11, 257, 2452, 5055, 11, 341, 1943, 380, 588, 50942], "temperature": 0.0, "avg_logprob": -0.11636476681150239, "compression_ratio": 1.7896825396825398, "no_speech_prob": 0.15396302938461304}, {"id": 100, "seek": 57524, "start": 586.8, "end": 592.52, "text": " much related to what we're discussing in this item. However, of course, because we are discussing", "tokens": [50942, 709, 4077, 281, 437, 321, 434, 10850, 294, 341, 3174, 13, 2908, 11, 295, 1164, 11, 570, 321, 366, 10850, 51228], "temperature": 0.0, "avg_logprob": -0.11636476681150239, "compression_ratio": 1.7896825396825398, "no_speech_prob": 0.15396302938461304}, {"id": 101, "seek": 57524, "start": 592.52, "end": 596.88, "text": " immutability, it's important to understand what a deep copy is. But formally in Java,", "tokens": [51228, 3397, 325, 2310, 11, 309, 311, 1021, 281, 1223, 437, 257, 2452, 5055, 307, 13, 583, 25983, 294, 10745, 11, 51446], "temperature": 0.0, "avg_logprob": -0.11636476681150239, "compression_ratio": 1.7896825396825398, "no_speech_prob": 0.15396302938461304}, {"id": 102, "seek": 57524, "start": 596.88, "end": 602.6, "text": " a deep copy is a copy of an object that creates a new object with a new memory address and", "tokens": [51446, 257, 2452, 5055, 307, 257, 5055, 295, 364, 2657, 300, 7829, 257, 777, 2657, 365, 257, 777, 4675, 2985, 293, 51732], "temperature": 0.0, "avg_logprob": -0.11636476681150239, "compression_ratio": 1.7896825396825398, "no_speech_prob": 0.15396302938461304}, {"id": 103, "seek": 60260, "start": 602.6, "end": 607.88, "text": " recursively copies the contents of the original object to the new object. This means that", "tokens": [50364, 20560, 3413, 14341, 264, 15768, 295, 264, 3380, 2657, 281, 264, 777, 2657, 13, 639, 1355, 300, 50628], "temperature": 0.0, "avg_logprob": -0.1467052830590142, "compression_ratio": 1.922077922077922, "no_speech_prob": 0.0040697380900382996}, {"id": 104, "seek": 60260, "start": 607.88, "end": 612.6, "text": " the new object is completely independent of the original object. And any changes made", "tokens": [50628, 264, 777, 2657, 307, 2584, 6695, 295, 264, 3380, 2657, 13, 400, 604, 2962, 1027, 50864], "temperature": 0.0, "avg_logprob": -0.1467052830590142, "compression_ratio": 1.922077922077922, "no_speech_prob": 0.0040697380900382996}, {"id": 105, "seek": 60260, "start": 612.6, "end": 619.32, "text": " to the new object do not affect the original object. So you can see here, when we are setting", "tokens": [50864, 281, 264, 777, 2657, 360, 406, 3345, 264, 3380, 2657, 13, 407, 291, 393, 536, 510, 11, 562, 321, 366, 3287, 51200], "temperature": 0.0, "avg_logprob": -0.1467052830590142, "compression_ratio": 1.922077922077922, "no_speech_prob": 0.0040697380900382996}, {"id": 106, "seek": 60260, "start": 619.32, "end": 625.9200000000001, "text": " the value for get field, we're returning a new object of type area list. And we are", "tokens": [51200, 264, 2158, 337, 483, 2519, 11, 321, 434, 12678, 257, 777, 2657, 295, 2010, 1859, 1329, 13, 400, 321, 366, 51530], "temperature": 0.0, "avg_logprob": -0.1467052830590142, "compression_ratio": 1.922077922077922, "no_speech_prob": 0.0040697380900382996}, {"id": 107, "seek": 60260, "start": 625.9200000000001, "end": 631.32, "text": " just passing the, sorry, this isn't the getter, by the way, we are passing the field three", "tokens": [51530, 445, 8437, 264, 11, 2597, 11, 341, 1943, 380, 264, 483, 391, 11, 538, 264, 636, 11, 321, 366, 8437, 264, 2519, 1045, 51800], "temperature": 0.0, "avg_logprob": -0.1467052830590142, "compression_ratio": 1.922077922077922, "no_speech_prob": 0.0040697380900382996}, {"id": 108, "seek": 63132, "start": 631.32, "end": 637.0, "text": " value into the constructor of the area list class. So that creates a new object. And it's", "tokens": [50364, 2158, 666, 264, 47479, 295, 264, 1859, 1329, 1508, 13, 407, 300, 7829, 257, 777, 2657, 13, 400, 309, 311, 50648], "temperature": 0.0, "avg_logprob": -0.12186767208960748, "compression_ratio": 1.7209302325581395, "no_speech_prob": 0.04740680009126663}, {"id": 109, "seek": 63132, "start": 637.0, "end": 644.84, "text": " an exact copy of the get field or the field three. But any change now in the new object", "tokens": [50648, 364, 1900, 5055, 295, 264, 483, 2519, 420, 264, 2519, 1045, 13, 583, 604, 1319, 586, 294, 264, 777, 2657, 51040], "temperature": 0.0, "avg_logprob": -0.12186767208960748, "compression_ratio": 1.7209302325581395, "no_speech_prob": 0.04740680009126663}, {"id": 110, "seek": 63132, "start": 644.84, "end": 652.2, "text": " that we give to the client will not affect the state, internal state of our broader immutable", "tokens": [51040, 300, 321, 976, 281, 264, 6423, 486, 406, 3345, 264, 1785, 11, 6920, 1785, 295, 527, 13227, 3397, 32148, 51408], "temperature": 0.0, "avg_logprob": -0.12186767208960748, "compression_ratio": 1.7209302325581395, "no_speech_prob": 0.04740680009126663}, {"id": 111, "seek": 63132, "start": 652.2, "end": 659.12, "text": " class object. That is what a deep copy does. And that's how a deep copy assists with immutability.", "tokens": [51408, 1508, 2657, 13, 663, 307, 437, 257, 2452, 5055, 775, 13, 400, 300, 311, 577, 257, 2452, 5055, 49416, 365, 3397, 325, 2310, 13, 51754], "temperature": 0.0, "avg_logprob": -0.12186767208960748, "compression_ratio": 1.7209302325581395, "no_speech_prob": 0.04740680009126663}, {"id": 112, "seek": 65912, "start": 659.12, "end": 662.84, "text": " And then from the JDK itself, I should have shown this example before the previous one,", "tokens": [50364, 400, 550, 490, 264, 37082, 42, 2564, 11, 286, 820, 362, 4898, 341, 1365, 949, 264, 3894, 472, 11, 50550], "temperature": 0.0, "avg_logprob": -0.1986081024696087, "compression_ratio": 1.7286821705426356, "no_speech_prob": 0.07053835690021515}, {"id": 113, "seek": 65912, "start": 662.84, "end": 670.48, "text": " but you still get the point. If you run this code, you'll see, despite in this string,", "tokens": [50550, 457, 291, 920, 483, 264, 935, 13, 759, 291, 1190, 341, 3089, 11, 291, 603, 536, 11, 7228, 294, 341, 6798, 11, 50932], "temperature": 0.0, "avg_logprob": -0.1986081024696087, "compression_ratio": 1.7286821705426356, "no_speech_prob": 0.07053835690021515}, {"id": 114, "seek": 65912, "start": 670.48, "end": 676.88, "text": " so string class is immutable, sorry, is immutable, pardon me. And in the string class, we're", "tokens": [50932, 370, 6798, 1508, 307, 3397, 32148, 11, 2597, 11, 307, 3397, 32148, 11, 22440, 385, 13, 400, 294, 264, 6798, 1508, 11, 321, 434, 51252], "temperature": 0.0, "avg_logprob": -0.1986081024696087, "compression_ratio": 1.7286821705426356, "no_speech_prob": 0.07053835690021515}, {"id": 115, "seek": 65912, "start": 676.88, "end": 683.52, "text": " setting it initially to be by or done. And we're doing this replacement and then returning", "tokens": [51252, 3287, 309, 9105, 281, 312, 538, 420, 1096, 13, 400, 321, 434, 884, 341, 14419, 293, 550, 12678, 51584], "temperature": 0.0, "avg_logprob": -0.1986081024696087, "compression_ratio": 1.7286821705426356, "no_speech_prob": 0.07053835690021515}, {"id": 116, "seek": 65912, "start": 683.52, "end": 689.04, "text": " that value to this new name object. But what you'd see here is, even though we're doing", "tokens": [51584, 300, 2158, 281, 341, 777, 1315, 2657, 13, 583, 437, 291, 1116, 536, 510, 307, 11, 754, 1673, 321, 434, 884, 51860], "temperature": 0.0, "avg_logprob": -0.1986081024696087, "compression_ratio": 1.7286821705426356, "no_speech_prob": 0.07053835690021515}, {"id": 117, "seek": 68904, "start": 689.04, "end": 695.76, "text": " the replacement here, that doesn't affect the internal state of the name object. So in line", "tokens": [50364, 264, 14419, 510, 11, 300, 1177, 380, 3345, 264, 6920, 1785, 295, 264, 1315, 2657, 13, 407, 294, 1622, 50700], "temperature": 0.0, "avg_logprob": -0.15713654624091256, "compression_ratio": 1.6703296703296704, "no_speech_prob": 0.002322814427316189}, {"id": 118, "seek": 68904, "start": 695.76, "end": 700.3199999999999, "text": " number 12, when we do print it, it's still going to print by or done, whereas a new name", "tokens": [50700, 1230, 2272, 11, 562, 321, 360, 4482, 309, 11, 309, 311, 920, 516, 281, 4482, 538, 420, 1096, 11, 9735, 257, 777, 1315, 50928], "temperature": 0.0, "avg_logprob": -0.15713654624091256, "compression_ratio": 1.6703296703296704, "no_speech_prob": 0.002322814427316189}, {"id": 119, "seek": 68904, "start": 700.3199999999999, "end": 705.1999999999999, "text": " now is going to have the replacement is going to be its own object that you created newly.", "tokens": [50928, 586, 307, 516, 281, 362, 264, 14419, 307, 516, 281, 312, 1080, 1065, 2657, 300, 291, 2942, 15109, 13, 51172], "temperature": 0.0, "avg_logprob": -0.15713654624091256, "compression_ratio": 1.6703296703296704, "no_speech_prob": 0.002322814427316189}, {"id": 120, "seek": 68904, "start": 705.1999999999999, "end": 709.0799999999999, "text": " And then getting back to the idea of consistency and immutability, Joshua Block has given an", "tokens": [51172, 400, 550, 1242, 646, 281, 264, 1558, 295, 14416, 293, 3397, 325, 2310, 11, 24005, 17500, 575, 2212, 364, 51366], "temperature": 0.0, "avg_logprob": -0.15713654624091256, "compression_ratio": 1.6703296703296704, "no_speech_prob": 0.002322814427316189}, {"id": 121, "seek": 68904, "start": 709.0799999999999, "end": 715.24, "text": " example of mistakes made in the designing of the Java language itself, historical mistakes.", "tokens": [51366, 1365, 295, 8038, 1027, 294, 264, 14685, 295, 264, 10745, 2856, 2564, 11, 8584, 8038, 13, 51674], "temperature": 0.0, "avg_logprob": -0.15713654624091256, "compression_ratio": 1.6703296703296704, "no_speech_prob": 0.002322814427316189}, {"id": 122, "seek": 71524, "start": 715.24, "end": 718.64, "text": " So for instance, I didn't I didn't know this, I only figured this out. Oh, I only learned", "tokens": [50364, 407, 337, 5197, 11, 286, 994, 380, 286, 994, 380, 458, 341, 11, 286, 787, 8932, 341, 484, 13, 876, 11, 286, 787, 3264, 50534], "temperature": 0.0, "avg_logprob": -0.19526241136633832, "compression_ratio": 1.748768472906404, "no_speech_prob": 0.293846994638443}, {"id": 123, "seek": 71524, "start": 718.64, "end": 725.96, "text": " this by the book that the Java dot net dot URL in this library, the sorry, the Java dot", "tokens": [50534, 341, 538, 264, 1446, 300, 264, 10745, 5893, 2533, 5893, 12905, 294, 341, 6405, 11, 264, 2597, 11, 264, 10745, 5893, 50900], "temperature": 0.0, "avg_logprob": -0.19526241136633832, "compression_ratio": 1.748768472906404, "no_speech_prob": 0.293846994638443}, {"id": 124, "seek": 71524, "start": 725.96, "end": 733.76, "text": " net library, the URL class was relying on unreliable was relying, pardon me, was relying", "tokens": [50900, 2533, 6405, 11, 264, 12905, 1508, 390, 24140, 322, 20584, 2081, 712, 390, 24140, 11, 22440, 385, 11, 390, 24140, 51290], "temperature": 0.0, "avg_logprob": -0.19526241136633832, "compression_ratio": 1.748768472906404, "no_speech_prob": 0.293846994638443}, {"id": 125, "seek": 71524, "start": 733.76, "end": 740.72, "text": " on hosts associated with IP addresses to affect the state of the object that it creates.", "tokens": [51290, 322, 21573, 6615, 365, 8671, 16862, 281, 3345, 264, 1785, 295, 264, 2657, 300, 309, 7829, 13, 51638], "temperature": 0.0, "avg_logprob": -0.19526241136633832, "compression_ratio": 1.748768472906404, "no_speech_prob": 0.293846994638443}, {"id": 126, "seek": 74072, "start": 740.72, "end": 745.76, "text": " But however, of course, we know that sometimes host names that are connected to IPs, they", "tokens": [50364, 583, 4461, 11, 295, 1164, 11, 321, 458, 300, 2171, 3975, 5288, 300, 366, 4582, 281, 8671, 82, 11, 436, 50616], "temperature": 0.0, "avg_logprob": -0.14776728012982537, "compression_ratio": 1.6090909090909091, "no_speech_prob": 0.1383679360151291}, {"id": 127, "seek": 74072, "start": 745.76, "end": 750.6, "text": " can change IP addresses can change all the time. And that itself. So the fact that that", "tokens": [50616, 393, 1319, 8671, 16862, 393, 1319, 439, 264, 565, 13, 400, 300, 2564, 13, 407, 264, 1186, 300, 300, 50858], "temperature": 0.0, "avg_logprob": -0.14776728012982537, "compression_ratio": 1.6090909090909091, "no_speech_prob": 0.1383679360151291}, {"id": 128, "seek": 74072, "start": 750.6, "end": 758.36, "text": " class relied on that unreliable resource was a mistake, which is why Joshua Block states", "tokens": [50858, 1508, 35463, 322, 300, 20584, 2081, 712, 7684, 390, 257, 6146, 11, 597, 307, 983, 24005, 17500, 4368, 51246], "temperature": 0.0, "avg_logprob": -0.14776728012982537, "compression_ratio": 1.6090909090909091, "no_speech_prob": 0.1383679360151291}, {"id": 129, "seek": 74072, "start": 758.36, "end": 765.44, "text": " the behavior of URLs equals method. So pardon me, the equals method was relying on that", "tokens": [51246, 264, 5223, 295, 43267, 6915, 3170, 13, 407, 22440, 385, 11, 264, 6915, 3170, 390, 24140, 322, 300, 51600], "temperature": 0.0, "avg_logprob": -0.14776728012982537, "compression_ratio": 1.6090909090909091, "no_speech_prob": 0.1383679360151291}, {"id": 130, "seek": 76544, "start": 765.44, "end": 772.12, "text": " unreliable resource, which was the IP address, and the host name. And therefore, he states", "tokens": [50364, 20584, 2081, 712, 7684, 11, 597, 390, 264, 8671, 2985, 11, 293, 264, 3975, 1315, 13, 400, 4412, 11, 415, 4368, 50698], "temperature": 0.0, "avg_logprob": -0.16957015597943179, "compression_ratio": 1.5729166666666667, "no_speech_prob": 0.1644575446844101}, {"id": 131, "seek": 76544, "start": 772.12, "end": 777.4000000000001, "text": " the behavior of URLs equals method was a big mistake and should not be emulated. Unfortunately,", "tokens": [50698, 264, 5223, 295, 43267, 6915, 3170, 390, 257, 955, 6146, 293, 820, 406, 312, 846, 6987, 13, 8590, 11, 50962], "temperature": 0.0, "avg_logprob": -0.16957015597943179, "compression_ratio": 1.5729166666666667, "no_speech_prob": 0.1644575446844101}, {"id": 132, "seek": 76544, "start": 777.4000000000001, "end": 782.6400000000001, "text": " it cannot be changed due to compatibility requirements to avoid this sort of problem.", "tokens": [50962, 309, 2644, 312, 3105, 3462, 281, 34237, 7728, 281, 5042, 341, 1333, 295, 1154, 13, 51224], "temperature": 0.0, "avg_logprob": -0.16957015597943179, "compression_ratio": 1.5729166666666667, "no_speech_prob": 0.1644575446844101}, {"id": 133, "seek": 76544, "start": 782.6400000000001, "end": 789.36, "text": " Equals methods should perform only deterministic computations on memory resident objects.", "tokens": [51224, 15624, 1124, 7150, 820, 2042, 787, 15957, 3142, 2807, 763, 322, 4675, 10832, 6565, 13, 51560], "temperature": 0.0, "avg_logprob": -0.16957015597943179, "compression_ratio": 1.5729166666666667, "no_speech_prob": 0.1644575446844101}, {"id": 134, "seek": 76544, "start": 789.36, "end": 794.44, "text": " So as Joshua Block does highlight throughout this book, the language designers itself have", "tokens": [51560, 407, 382, 24005, 17500, 775, 5078, 3710, 341, 1446, 11, 264, 2856, 16196, 2564, 362, 51814], "temperature": 0.0, "avg_logprob": -0.16957015597943179, "compression_ratio": 1.5729166666666667, "no_speech_prob": 0.1644575446844101}, {"id": 135, "seek": 79444, "start": 794.44, "end": 799.5600000000001, "text": " made some of these mistakes. So when it comes to this mistake of consistency, or the mistake", "tokens": [50364, 1027, 512, 295, 613, 8038, 13, 407, 562, 309, 1487, 281, 341, 6146, 295, 14416, 11, 420, 264, 6146, 50620], "temperature": 0.0, "avg_logprob": -0.11639148586398952, "compression_ratio": 1.7156398104265402, "no_speech_prob": 0.06550484150648117}, {"id": 136, "seek": 79444, "start": 799.5600000000001, "end": 807.1600000000001, "text": " of not abiding by the property of consistency, even the people who are experts at Java have", "tokens": [50620, 295, 406, 410, 2819, 538, 264, 4707, 295, 14416, 11, 754, 264, 561, 567, 366, 8572, 412, 10745, 362, 51000], "temperature": 0.0, "avg_logprob": -0.11639148586398952, "compression_ratio": 1.7156398104265402, "no_speech_prob": 0.06550484150648117}, {"id": 137, "seek": 79444, "start": 807.1600000000001, "end": 811.72, "text": " still made this mistake. And this is another example of that. So in that, let's get to", "tokens": [51000, 920, 1027, 341, 6146, 13, 400, 341, 307, 1071, 1365, 295, 300, 13, 407, 294, 300, 11, 718, 311, 483, 281, 51228], "temperature": 0.0, "avg_logprob": -0.11639148586398952, "compression_ratio": 1.7156398104265402, "no_speech_prob": 0.06550484150648117}, {"id": 138, "seek": 79444, "start": 811.72, "end": 819.0, "text": " the next property, the final one, last but not least, as they say, which is non knowledge.", "tokens": [51228, 264, 958, 4707, 11, 264, 2572, 472, 11, 1036, 457, 406, 1935, 11, 382, 436, 584, 11, 597, 307, 2107, 3601, 13, 51592], "temperature": 0.0, "avg_logprob": -0.11639148586398952, "compression_ratio": 1.7156398104265402, "no_speech_prob": 0.06550484150648117}, {"id": 139, "seek": 81900, "start": 819.0, "end": 824.44, "text": " And non knowledge states, it seems quite straightforward. But once we dive into it,", "tokens": [50364, 400, 2107, 3601, 4368, 11, 309, 2544, 1596, 15325, 13, 583, 1564, 321, 9192, 666, 309, 11, 50636], "temperature": 0.0, "avg_logprob": -0.19013669652846252, "compression_ratio": 1.6814814814814816, "no_speech_prob": 0.02095986343920231}, {"id": 140, "seek": 81900, "start": 824.44, "end": 829.32, "text": " you'll see how there are there can be times when certain mistakes can happen. So non knowledge", "tokens": [50636, 291, 603, 536, 577, 456, 366, 456, 393, 312, 1413, 562, 1629, 8038, 393, 1051, 13, 407, 2107, 3601, 50880], "temperature": 0.0, "avg_logprob": -0.19013669652846252, "compression_ratio": 1.6814814814814816, "no_speech_prob": 0.02095986343920231}, {"id": 141, "seek": 81900, "start": 829.32, "end": 837.08, "text": " states for any non null reference values x, x equals null mass return false, because obviously", "tokens": [50880, 4368, 337, 604, 2107, 18184, 6408, 4190, 2031, 11, 2031, 6915, 18184, 2758, 2736, 7908, 11, 570, 2745, 51268], "temperature": 0.0, "avg_logprob": -0.19013669652846252, "compression_ratio": 1.6814814814814816, "no_speech_prob": 0.02095986343920231}, {"id": 142, "seek": 81900, "start": 837.08, "end": 841.04, "text": " you can't compare an object to a null value. And practically, what that really means is", "tokens": [51268, 291, 393, 380, 6794, 364, 2657, 281, 257, 18184, 2158, 13, 400, 15667, 11, 437, 300, 534, 1355, 307, 51466], "temperature": 0.0, "avg_logprob": -0.19013669652846252, "compression_ratio": 1.6814814814814816, "no_speech_prob": 0.02095986343920231}, {"id": 143, "seek": 81900, "start": 841.04, "end": 846.32, "text": " a null point exception can't be thrown in the equals method when the comparison takes place.", "tokens": [51466, 257, 18184, 935, 11183, 393, 380, 312, 11732, 294, 264, 6915, 3170, 562, 264, 9660, 2516, 1081, 13, 51730], "temperature": 0.0, "avg_logprob": -0.19013669652846252, "compression_ratio": 1.6814814814814816, "no_speech_prob": 0.02095986343920231}, {"id": 144, "seek": 84632, "start": 846.32, "end": 854.48, "text": " So as Joshua Block states, it says that all objects must be unequal to null, of course.", "tokens": [50364, 407, 382, 24005, 17500, 4368, 11, 309, 1619, 300, 439, 6565, 1633, 312, 2251, 22345, 281, 18184, 11, 295, 1164, 13, 50772], "temperature": 0.0, "avg_logprob": -0.1593989395513767, "compression_ratio": 1.708133971291866, "no_speech_prob": 0.04206770658493042}, {"id": 145, "seek": 84632, "start": 854.48, "end": 860.4000000000001, "text": " While it is hard to imagine accidentally returning true in response to the invocation of object", "tokens": [50772, 3987, 309, 307, 1152, 281, 3811, 15715, 12678, 2074, 294, 4134, 281, 264, 1048, 27943, 295, 2657, 51068], "temperature": 0.0, "avg_logprob": -0.1593989395513767, "compression_ratio": 1.708133971291866, "no_speech_prob": 0.04206770658493042}, {"id": 146, "seek": 84632, "start": 860.4000000000001, "end": 867.88, "text": " dot equals null, it isn't hard to imagine accidentally throwing a null point exception,", "tokens": [51068, 5893, 6915, 18184, 11, 309, 1943, 380, 1152, 281, 3811, 15715, 10238, 257, 18184, 935, 11183, 11, 51442], "temperature": 0.0, "avg_logprob": -0.1593989395513767, "compression_ratio": 1.708133971291866, "no_speech_prob": 0.04206770658493042}, {"id": 147, "seek": 84632, "start": 867.88, "end": 873.72, "text": " which violates a general contract or the he says the general contract prohibits this.", "tokens": [51442, 597, 3448, 1024, 257, 2674, 4364, 420, 264, 415, 1619, 264, 2674, 4364, 16015, 1208, 341, 13, 51734], "temperature": 0.0, "avg_logprob": -0.1593989395513767, "compression_ratio": 1.708133971291866, "no_speech_prob": 0.04206770658493042}, {"id": 148, "seek": 87372, "start": 873.72, "end": 878.36, "text": " So then he states that some classes have attempted or tried to do an explicit knowledge", "tokens": [50364, 407, 550, 415, 4368, 300, 512, 5359, 362, 18997, 420, 3031, 281, 360, 364, 13691, 3601, 50596], "temperature": 0.0, "avg_logprob": -0.16592369439466945, "compression_ratio": 1.63003663003663, "no_speech_prob": 0.0029347077943384647}, {"id": 149, "seek": 87372, "start": 878.36, "end": 883.64, "text": " check to prevent this null point exception from being thrown. So here's an example of", "tokens": [50596, 1520, 281, 4871, 341, 18184, 935, 11183, 490, 885, 11732, 13, 407, 510, 311, 364, 1365, 295, 50860], "temperature": 0.0, "avg_logprob": -0.16592369439466945, "compression_ratio": 1.63003663003663, "no_speech_prob": 0.0029347077943384647}, {"id": 150, "seek": 87372, "start": 883.64, "end": 889.6800000000001, "text": " what that would look like. I'll just actually leave that there. Ignore that ever for now.", "tokens": [50860, 437, 300, 576, 574, 411, 13, 286, 603, 445, 767, 1856, 300, 456, 13, 24754, 418, 300, 1562, 337, 586, 13, 51162], "temperature": 0.0, "avg_logprob": -0.16592369439466945, "compression_ratio": 1.63003663003663, "no_speech_prob": 0.0029347077943384647}, {"id": 151, "seek": 87372, "start": 889.6800000000001, "end": 895.08, "text": " If we just try and check in the equals method when the overriding with the object pass is", "tokens": [51162, 759, 321, 445, 853, 293, 1520, 294, 264, 6915, 3170, 562, 264, 670, 81, 2819, 365, 264, 2657, 1320, 307, 51432], "temperature": 0.0, "avg_logprob": -0.16592369439466945, "compression_ratio": 1.63003663003663, "no_speech_prob": 0.0029347077943384647}, {"id": 152, "seek": 87372, "start": 895.08, "end": 901.52, "text": " equal to null, and here we're doing a memory reference comparison. And if it's not returned", "tokens": [51432, 2681, 281, 18184, 11, 293, 510, 321, 434, 884, 257, 4675, 6408, 9660, 13, 400, 498, 309, 311, 406, 8752, 51754], "temperature": 0.0, "avg_logprob": -0.16592369439466945, "compression_ratio": 1.63003663003663, "no_speech_prob": 0.0029347077943384647}, {"id": 153, "seek": 90152, "start": 901.52, "end": 906.56, "text": " full straight away, but this isn't required, and we shall see why. So the rest of that", "tokens": [50364, 1577, 2997, 1314, 11, 457, 341, 1943, 380, 4739, 11, 293, 321, 4393, 536, 983, 13, 407, 264, 1472, 295, 300, 50616], "temperature": 0.0, "avg_logprob": -0.15457505694890428, "compression_ratio": 1.7611336032388665, "no_speech_prob": 0.38476893305778503}, {"id": 154, "seek": 90152, "start": 906.56, "end": 910.8, "text": " part really is about this bit of code. So in this class, my type, what we're doing is", "tokens": [50616, 644, 534, 307, 466, 341, 857, 295, 3089, 13, 407, 294, 341, 1508, 11, 452, 2010, 11, 437, 321, 434, 884, 307, 50828], "temperature": 0.0, "avg_logprob": -0.15457505694890428, "compression_ratio": 1.7611336032388665, "no_speech_prob": 0.38476893305778503}, {"id": 155, "seek": 90152, "start": 910.8, "end": 916.64, "text": " we're checking if whatever object we pass onto the equals method, if it's a instance", "tokens": [50828, 321, 434, 8568, 498, 2035, 2657, 321, 1320, 3911, 264, 6915, 3170, 11, 498, 309, 311, 257, 5197, 51120], "temperature": 0.0, "avg_logprob": -0.15457505694890428, "compression_ratio": 1.7611336032388665, "no_speech_prob": 0.38476893305778503}, {"id": 156, "seek": 90152, "start": 916.64, "end": 924.6, "text": " of my type, and if it isn't, we straight away return a false. And only if it is off type,", "tokens": [51120, 295, 452, 2010, 11, 293, 498, 309, 1943, 380, 11, 321, 2997, 1314, 2736, 257, 7908, 13, 400, 787, 498, 309, 307, 766, 2010, 11, 51518], "temperature": 0.0, "avg_logprob": -0.15457505694890428, "compression_ratio": 1.7611336032388665, "no_speech_prob": 0.38476893305778503}, {"id": 157, "seek": 90152, "start": 924.6, "end": 929.88, "text": " my type, do we do the casting, as you can see here. And this check immediately prevents", "tokens": [51518, 452, 2010, 11, 360, 321, 360, 264, 17301, 11, 382, 291, 393, 536, 510, 13, 400, 341, 1520, 4258, 22367, 51782], "temperature": 0.0, "avg_logprob": -0.15457505694890428, "compression_ratio": 1.7611336032388665, "no_speech_prob": 0.38476893305778503}, {"id": 158, "seek": 92988, "start": 929.88, "end": 934.4399999999999, "text": " any class cast exceptions from taking place too, because even if you pass a null here,", "tokens": [50364, 604, 1508, 4193, 22847, 490, 1940, 1081, 886, 11, 570, 754, 498, 291, 1320, 257, 18184, 510, 11, 50592], "temperature": 0.0, "avg_logprob": -0.16687084804071445, "compression_ratio": 1.7729083665338645, "no_speech_prob": 0.01450159028172493}, {"id": 159, "seek": 92988, "start": 934.4399999999999, "end": 939.4399999999999, "text": " it's going to return true, which you shall see here. So when the client uses this new", "tokens": [50592, 309, 311, 516, 281, 2736, 2074, 11, 597, 291, 4393, 536, 510, 13, 407, 562, 264, 6423, 4960, 341, 777, 50842], "temperature": 0.0, "avg_logprob": -0.16687084804071445, "compression_ratio": 1.7729083665338645, "no_speech_prob": 0.01450159028172493}, {"id": 160, "seek": 92988, "start": 939.4399999999999, "end": 947.48, "text": " my type method and passes a null, it's going to return false as you can see. And the reason", "tokens": [50842, 452, 2010, 3170, 293, 11335, 257, 18184, 11, 309, 311, 516, 281, 2736, 7908, 382, 291, 393, 536, 13, 400, 264, 1778, 51244], "temperature": 0.0, "avg_logprob": -0.16687084804071445, "compression_ratio": 1.7729083665338645, "no_speech_prob": 0.01450159028172493}, {"id": 161, "seek": 92988, "start": 947.48, "end": 953.12, "text": " it does that is because obviously null is enough type, my type, and then the equals method", "tokens": [51244, 309, 775, 300, 307, 570, 2745, 18184, 307, 1547, 2010, 11, 452, 2010, 11, 293, 550, 264, 6915, 3170, 51526], "temperature": 0.0, "avg_logprob": -0.16687084804071445, "compression_ratio": 1.7729083665338645, "no_speech_prob": 0.01450159028172493}, {"id": 162, "seek": 92988, "start": 953.12, "end": 957.32, "text": " recognizes that it immediately returns false. It's as straightforward as that really. And", "tokens": [51526, 26564, 300, 309, 4258, 11247, 7908, 13, 467, 311, 382, 15325, 382, 300, 534, 13, 400, 51736], "temperature": 0.0, "avg_logprob": -0.16687084804071445, "compression_ratio": 1.7729083665338645, "no_speech_prob": 0.01450159028172493}, {"id": 163, "seek": 95732, "start": 957.32, "end": 962.32, "text": " on the casting just to block states to test this argument for quality, the equals method", "tokens": [50364, 322, 264, 17301, 445, 281, 3461, 4368, 281, 1500, 341, 6770, 337, 3125, 11, 264, 6915, 3170, 50614], "temperature": 0.0, "avg_logprob": -0.22242333423132185, "compression_ratio": 1.6495327102803738, "no_speech_prob": 0.0251751895993948}, {"id": 164, "seek": 95732, "start": 962.32, "end": 968.9200000000001, "text": " must first cast its arguments on appropriate type. So it's accesses can be invoked, or", "tokens": [50614, 1633, 700, 4193, 1080, 12869, 322, 6854, 2010, 13, 407, 309, 311, 2105, 279, 393, 312, 1048, 9511, 11, 420, 50944], "temperature": 0.0, "avg_logprob": -0.22242333423132185, "compression_ratio": 1.6495327102803738, "no_speech_prob": 0.0251751895993948}, {"id": 165, "seek": 95732, "start": 968.9200000000001, "end": 973.32, "text": " it's fields accessed, which is what we're doing here in the casting. And then we're returning", "tokens": [50944, 309, 311, 7909, 34211, 11, 597, 307, 437, 321, 434, 884, 510, 294, 264, 17301, 13, 400, 550, 321, 434, 12678, 51164], "temperature": 0.0, "avg_logprob": -0.22242333423132185, "compression_ratio": 1.6495327102803738, "no_speech_prob": 0.0251751895993948}, {"id": 166, "seek": 95732, "start": 973.32, "end": 981.72, "text": " true if what we do cast by that object is equal to this, it has logical equality to", "tokens": [51164, 2074, 498, 437, 321, 360, 4193, 538, 300, 2657, 307, 2681, 281, 341, 11, 309, 575, 14978, 14949, 281, 51584], "temperature": 0.0, "avg_logprob": -0.22242333423132185, "compression_ratio": 1.6495327102803738, "no_speech_prob": 0.0251751895993948}, {"id": 167, "seek": 98172, "start": 981.72, "end": 988.76, "text": " this object in this class. And of course, this is just on 9 and 11, a very plain comparison,", "tokens": [50364, 341, 2657, 294, 341, 1508, 13, 400, 295, 1164, 11, 341, 307, 445, 322, 1722, 293, 2975, 11, 257, 588, 11121, 9660, 11, 50716], "temperature": 0.0, "avg_logprob": -0.18788041906841732, "compression_ratio": 1.702290076335878, "no_speech_prob": 0.3921436369419098}, {"id": 168, "seek": 98172, "start": 988.76, "end": 992.32, "text": " but the rest of the equals method, a lot more could take place. And we could do a lot more", "tokens": [50716, 457, 264, 1472, 295, 264, 6915, 3170, 11, 257, 688, 544, 727, 747, 1081, 13, 400, 321, 727, 360, 257, 688, 544, 50894], "temperature": 0.0, "avg_logprob": -0.18788041906841732, "compression_ratio": 1.702290076335878, "no_speech_prob": 0.3921436369419098}, {"id": 169, "seek": 98172, "start": 992.32, "end": 996.6800000000001, "text": " work to ensure there's logical equality. And that's it. That's what non knowledge is.", "tokens": [50894, 589, 281, 5586, 456, 311, 14978, 14949, 13, 400, 300, 311, 309, 13, 663, 311, 437, 2107, 3601, 307, 13, 51112], "temperature": 0.0, "avg_logprob": -0.18788041906841732, "compression_ratio": 1.702290076335878, "no_speech_prob": 0.3921436369419098}, {"id": 170, "seek": 98172, "start": 996.6800000000001, "end": 1002.5600000000001, "text": " There's not a lot to it except to put in that extra check. And this check, regardless of", "tokens": [51112, 821, 311, 406, 257, 688, 281, 309, 3993, 281, 829, 294, 300, 2857, 1520, 13, 400, 341, 1520, 11, 10060, 295, 51406], "temperature": 0.0, "avg_logprob": -0.18788041906841732, "compression_ratio": 1.702290076335878, "no_speech_prob": 0.3921436369419098}, {"id": 171, "seek": 98172, "start": 1002.5600000000001, "end": 1007.12, "text": " the context of whether we're passing a null to this method or not, would still be done.", "tokens": [51406, 264, 4319, 295, 1968, 321, 434, 8437, 257, 18184, 281, 341, 3170, 420, 406, 11, 576, 920, 312, 1096, 13, 51634], "temperature": 0.0, "avg_logprob": -0.18788041906841732, "compression_ratio": 1.702290076335878, "no_speech_prob": 0.3921436369419098}, {"id": 172, "seek": 100712, "start": 1007.12, "end": 1012.44, "text": " So it kind of solves our problem. But it's important to understand the property of non", "tokens": [50364, 407, 309, 733, 295, 39890, 527, 1154, 13, 583, 309, 311, 1021, 281, 1223, 264, 4707, 295, 2107, 50630], "temperature": 0.0, "avg_logprob": -0.23831999535654105, "compression_ratio": 1.6973180076628354, "no_speech_prob": 0.2626670002937317}, {"id": 173, "seek": 100712, "start": 1012.44, "end": 1019.36, "text": " knowledge in principle when designing an equals method for our classes. That's it. And we're", "tokens": [50630, 3601, 294, 8665, 562, 14685, 364, 6915, 3170, 337, 527, 5359, 13, 663, 311, 309, 13, 400, 321, 434, 50976], "temperature": 0.0, "avg_logprob": -0.23831999535654105, "compression_ratio": 1.6973180076628354, "no_speech_prob": 0.2626670002937317}, {"id": 174, "seek": 100712, "start": 1019.36, "end": 1025.68, "text": " not going to move on to the rest of the item because part four is the final part almost", "tokens": [50976, 406, 516, 281, 1286, 322, 281, 264, 1472, 295, 264, 3174, 570, 644, 1451, 307, 264, 2572, 644, 1920, 51292], "temperature": 0.0, "avg_logprob": -0.23831999535654105, "compression_ratio": 1.6973180076628354, "no_speech_prob": 0.2626670002937317}, {"id": 175, "seek": 100712, "start": 1025.68, "end": 1031.64, "text": " damaged my book there. And in part four, really what we discuss is putting it all together", "tokens": [51292, 14080, 452, 1446, 456, 13, 400, 294, 644, 1451, 11, 534, 437, 321, 2248, 307, 3372, 309, 439, 1214, 51590], "temperature": 0.0, "avg_logprob": -0.23831999535654105, "compression_ratio": 1.6973180076628354, "no_speech_prob": 0.2626670002937317}, {"id": 176, "seek": 100712, "start": 1031.64, "end": 1035.72, "text": " after we've discussed all these properties of after we've discussed what equivalence", "tokens": [51590, 934, 321, 600, 7152, 439, 613, 7221, 295, 934, 321, 600, 7152, 437, 9052, 655, 51794], "temperature": 0.0, "avg_logprob": -0.23831999535654105, "compression_ratio": 1.6973180076628354, "no_speech_prob": 0.2626670002937317}, {"id": 177, "seek": 103572, "start": 1035.72, "end": 1040.0, "text": " relation is and everything we've discussed in this item so far, putting it all together", "tokens": [50364, 9721, 307, 293, 1203, 321, 600, 7152, 294, 341, 3174, 370, 1400, 11, 3372, 309, 439, 1214, 50578], "temperature": 0.0, "avg_logprob": -0.15730538141159783, "compression_ratio": 1.6509090909090909, "no_speech_prob": 0.034613341093063354}, {"id": 178, "seek": 103572, "start": 1040.0, "end": 1046.56, "text": " and how to really design a good quality equals method that respects and abides by the general", "tokens": [50578, 293, 577, 281, 534, 1715, 257, 665, 3125, 6915, 3170, 300, 24126, 293, 410, 1875, 538, 264, 2674, 50906], "temperature": 0.0, "avg_logprob": -0.15730538141159783, "compression_ratio": 1.6509090909090909, "no_speech_prob": 0.034613341093063354}, {"id": 179, "seek": 103572, "start": 1046.56, "end": 1051.04, "text": " contract and these properties that we've been delineating and trying to understand saying", "tokens": [50906, 4364, 293, 613, 7221, 300, 321, 600, 668, 1103, 533, 990, 293, 1382, 281, 1223, 1566, 51130], "temperature": 0.0, "avg_logprob": -0.15730538141159783, "compression_ratio": 1.6509090909090909, "no_speech_prob": 0.034613341093063354}, {"id": 180, "seek": 103572, "start": 1051.04, "end": 1055.44, "text": " that. Thank you for watching. I hope you found value in this video. I shall continue on with", "tokens": [51130, 300, 13, 1044, 291, 337, 1976, 13, 286, 1454, 291, 1352, 2158, 294, 341, 960, 13, 286, 4393, 2354, 322, 365, 51350], "temperature": 0.0, "avg_logprob": -0.15730538141159783, "compression_ratio": 1.6509090909090909, "no_speech_prob": 0.034613341093063354}, {"id": 181, "seek": 103572, "start": 1055.44, "end": 1061.68, "text": " part four when I'm back from Queensland after my short break. And part four, as I said is", "tokens": [51350, 644, 1451, 562, 286, 478, 646, 490, 36913, 934, 452, 2099, 1821, 13, 400, 644, 1451, 11, 382, 286, 848, 307, 51662], "temperature": 0.0, "avg_logprob": -0.15730538141159783, "compression_ratio": 1.6509090909090909, "no_speech_prob": 0.034613341093063354}, {"id": 182, "seek": 106168, "start": 1061.68, "end": 1065.72, "text": " putting it all together. It's the it's the it's the grand finale where we put this all", "tokens": [50364, 3372, 309, 439, 1214, 13, 467, 311, 264, 309, 311, 264, 309, 311, 264, 2697, 23510, 689, 321, 829, 341, 439, 50566], "temperature": 0.0, "avg_logprob": -0.16578939878023588, "compression_ratio": 1.5973154362416107, "no_speech_prob": 0.5803969502449036}, {"id": 183, "seek": 106168, "start": 1065.72, "end": 1071.16, "text": " together and design a superlative high quality equals method. So hopefully I see you in the", "tokens": [50566, 1214, 293, 1715, 257, 1687, 75, 1166, 1090, 3125, 6915, 3170, 13, 407, 4696, 286, 536, 291, 294, 264, 50838], "temperature": 0.0, "avg_logprob": -0.16578939878023588, "compression_ratio": 1.5973154362416107, "no_speech_prob": 0.5803969502449036}, {"id": 184, "seek": 106168, "start": 1071.16, "end": 1075.16, "text": " next part. That's it. I'll see you in the next one. Cheers.", "tokens": [50838, 958, 644, 13, 663, 311, 309, 13, 286, 603, 536, 291, 294, 264, 958, 472, 13, 13006, 13, 51038], "temperature": 0.0, "avg_logprob": -0.16578939878023588, "compression_ratio": 1.5973154362416107, "no_speech_prob": 0.5803969502449036}], "language": "en"}