WEBVTT

00:00.000 --> 00:06.160
Hey everyone, welcome to yet another episode of this video series on Joshua Bloch's effective Java

00:06.320 --> 00:10.440
where I try and expound and make sense of the items that he has

00:11.160 --> 00:13.400
Animirated in this book and without further ado

00:13.400 --> 00:18.520
Let's get started with the introduction because I sort of anticipate that this item in particular

00:18.520 --> 00:24.960
It's gonna be a lone one because there are a lot of I'd say ancillary points that we need to discuss to

00:25.240 --> 00:29.120
make sense of the crux of this item and the argument that

00:29.800 --> 00:31.800
Joshua Bloch is putting forward

00:32.200 --> 00:38.140
So as per usual, I'm gonna go through the same introduction that I go through in every single

00:38.760 --> 00:40.480
Video in the series

00:40.480 --> 00:46.160
So if you've been following along, please do skip this bit to save your time the proviso goes like this

00:46.760 --> 00:50.720
Which I'm kind of sick of repeating but I feel like I kind of have to repeat it

00:51.160 --> 00:55.280
For let's say due diligence. So just to be ethical about this whole thing

00:56.040 --> 01:00.800
This is not a tutorial. I certainly am not a teacher. No, I'm an expert

01:01.200 --> 01:05.560
So, you know, take what I say with the grain of salt

01:05.880 --> 01:11.640
Don't think of this as any other tutorial on YouTube where what I say is in some sense

01:12.000 --> 01:15.600
Gospel's truth. I don't think every single tutorial on YouTube is like that

01:15.600 --> 01:20.960
But there are some tutorials where certainly, you know, they could quality they come from an expert in the field

01:20.960 --> 01:28.720
And you can trust what they're saying. Don't trust what I say. I'm pretty sure I'm gonna push a lot of things in this item and

01:29.360 --> 01:36.700
in some sense, hopefully try my best to do it as accurately as possible not spilling the bullshit, but

01:38.240 --> 01:40.440
Getting to the points in the item. There certainly are gonna be

01:41.000 --> 01:45.400
Unintentional mistakes that I make. I'd like to think of this as the blind leading the blind

01:45.400 --> 01:48.200
I am as blind as you are perhaps even more

01:48.680 --> 01:51.600
This is merely or not merely. This is a

01:52.400 --> 01:55.960
Exploratory disposition. I'm trying to make sense of this collectively

01:56.800 --> 02:02.520
You know using different forums like Stack Overflow whenever I come across something that I don't understand

02:02.520 --> 02:06.240
I'd post a question on Stack Overflow and I'd really appreciate it if

02:06.960 --> 02:11.280
You know, if I do make any mistakes, which I think I inevitably will

02:11.680 --> 02:13.800
Please point them out in the comment section down below

02:14.200 --> 02:20.680
Not just for my sake, but even for other people that are watching these videos. I really don't want to mislead people in any way

02:21.320 --> 02:23.320
and given that this is a

02:24.560 --> 02:30.320
Programming video series. It only makes sense to have all the code that I use on get up publicly available

02:30.320 --> 02:35.760
I'll leave a link down below not just to my get up account, but also just your blocks sort of official

02:37.080 --> 02:41.120
Public repository that is published and put put out all the code used in the book

02:41.600 --> 02:46.640
And saying all that let's get started on item number seven

02:47.240 --> 02:51.560
Which states eliminate obsolete object references?

02:51.560 --> 02:56.040
And this again is from chapter two creating and destroying objects

02:56.200 --> 03:02.680
So something I've been trying to do in these videos is before we even get to the content of the item to try and

03:03.080 --> 03:05.080
expand on and try to understand

03:05.800 --> 03:10.400
Basically what the words used in the title itself is itself are

03:11.080 --> 03:12.400
so

03:12.400 --> 03:18.440
object references what in the world are object references this diagram or this

03:18.840 --> 03:22.600
image pretty much puts it quite simply and

03:23.400 --> 03:30.800
Object reference is merely a pointer or not merely. It's probably good to conceptualize it as a pointer

03:30.800 --> 03:36.880
So we have objects in the heap memory. So the memory is subdivided into

03:37.800 --> 03:42.320
Different segments by the JVM. There's a heap. There's a stack

03:43.480 --> 03:44.680
and

03:44.680 --> 03:50.240
Generally leaving aside the stack of the heap what a object references is a a

03:50.840 --> 03:57.680
Memory address the pointer points to a memory address of a particular object in the heap and adding on to that in this image

03:57.680 --> 03:59.680
If we take something like an object array, let's say

04:00.200 --> 04:05.080
An array itself is a reference to a another object

04:05.200 --> 04:07.200
what I mean by that is an

04:07.440 --> 04:09.640
array can exist in the heap and

04:10.440 --> 04:16.480
There's a pointer or a memory address that points to that array, but the items in the array itself are

04:17.240 --> 04:25.320
Pointing to other objects within the heap. So in some sense, you can I guess think of it this way the way they've shown in this diagram where

04:26.120 --> 04:31.680
The array contains references itself and it could also contain it out. So if you're not out an array

04:32.280 --> 04:37.400
Which we're gonna see some nulling out in this item, then it's not gonna point to anything

04:37.680 --> 04:42.720
So in Java what happens when we use the new keyword is we reserve a location in memory

04:44.120 --> 04:49.840
When we instantiate a class the constructor of that class and all classes have a constructor

04:51.520 --> 04:56.160
Creates a reference to an object and the reference I said it's like a pointer

04:56.160 --> 05:01.840
But another way of thinking about it is that it's information regarding the location of the object in memory

05:01.880 --> 05:06.760
So what we see here is an example of that where they're creating this

05:07.440 --> 05:09.600
object array a primitive array and

05:10.160 --> 05:11.760
where

05:11.760 --> 05:12.960
instantiating it

05:12.960 --> 05:17.760
In this case with a primitive type. So just repeating the point items seven states again

05:18.160 --> 05:20.720
eliminate obsolete object references

05:21.360 --> 05:22.800
so

05:22.800 --> 05:26.040
Unlike a language like let's say C++

05:26.960 --> 05:36.200
Java this automatic garbage collection. What is garbage collection? It's simply put memory management when we do allocate resources to a certain object

05:36.560 --> 05:41.520
We make sure that once that object is no longer in use we clear it out

05:41.520 --> 05:48.720
We we let that memory go to free out resources so that that resource can be something else and there are different

05:49.280 --> 05:55.760
Algorithms used in garbage collection. In fact, I'll leave some links down below on some videos by

05:56.640 --> 05:59.520
Gaurav Sen, I believe I think it's his son name, but I you know

05:59.520 --> 06:05.480
He does the system design videos on YouTube really good superlative content and he does do a bit of

06:06.720 --> 06:08.720
Explaining of how these algorithms work

06:09.760 --> 06:11.960
specifically Apple Pro JVM

06:12.800 --> 06:13.960
so

06:13.960 --> 06:20.360
Of course because Java this automatic garbage collection as I said unlike a language like C++

06:20.680 --> 06:24.760
We could make the wrong assumption when I mean we I mean a programmer could make the wrong assumption

06:25.320 --> 06:32.320
That we don't have to think about memory management at all. And that's why in the beginning of this item

06:32.880 --> 06:34.720
Joshua Block states

06:34.720 --> 06:40.720
When it comes to garbage collection, it seems almost like magic when you first experience it and

06:41.320 --> 06:46.680
Therefore it can easily lead to the impression that you don't have to think about memory management

06:46.680 --> 06:51.880
But this isn't quite true. I had to take off my cardigan because it was getting really hot in this room

06:52.280 --> 06:54.280
Summer's coming in Melbourne. Yay

06:54.520 --> 06:59.000
So he keeps going consider the following simple stack implementation

06:59.560 --> 07:02.280
I've got the stack implementation right here

07:03.320 --> 07:06.680
However, before we get to the code and do a deep dive

07:06.680 --> 07:11.640
I cut out again. We want to backtrack a bit and discuss some of the terms. So

07:12.360 --> 07:14.360
We discussed what

07:15.000 --> 07:18.240
Object references are and then I want to discuss

07:18.720 --> 07:24.940
What's a obsolete reference an obsolete reference is a reference that will not be

07:25.680 --> 07:27.680
De-referenced again. It's

07:27.680 --> 07:30.520
unintentionally retaining an object now this term here

07:31.520 --> 07:38.000
De-referencing or dereferenced again, this can be quite confusing because dereference does not mean that you

07:38.400 --> 07:41.080
Get rid of the reference not at all. What?

07:42.160 --> 07:44.160
dereferencing in fact means is

07:44.360 --> 07:46.360
when we do refer to an object

07:47.360 --> 07:52.480
In our code somewhere down the line once we do create the reference we may refer to it again

07:52.480 --> 07:57.720
We may get the value that the reference is pointing to that process is called

07:58.440 --> 08:03.800
De-referencing and if we don't de-reference an object, there's no use of keeping an object in memory

08:03.800 --> 08:06.920
So we are unintentionally just leaving an object there

08:07.560 --> 08:09.560
allocating resources making

08:10.440 --> 08:16.760
Application inefficient that that shouldn't be done. So the solution is quite simple. In fact, it's simply to now

08:17.120 --> 08:24.480
references once they become obsolete and we sometimes have to do this explicitly on our code despite

08:25.480 --> 08:28.520
Java doing memory management or garbage collection

08:28.720 --> 08:36.800
So to have a bit of a more formal and clear definition by my favorite Java programming website by all done

08:37.240 --> 08:42.480
De-referencing means the action of accessing an object's features through a reference

08:42.480 --> 08:48.840
And one way to prevent obsolete object references is by narrow scoping and what's narrow scoping?

08:48.920 --> 08:57.200
That's something what you would see in a for loop in a for loop. We have the int you declared int i for instance

08:58.720 --> 09:06.160
That variable is within the scope of that for loop. So narrow scoping. That's an example another example would be

09:06.640 --> 09:10.600
trying not to declare global variables in a class rather

09:11.520 --> 09:17.480
declare variables within a function within a method and keep it localized to that specific method and

09:17.720 --> 09:19.720
That helps with eliminating

09:20.560 --> 09:28.600
obsolete object references because we sort of know what the scope of a variable is in our code base and then in the item

09:28.600 --> 09:33.040
He keeps going and this is the code base for the stack class

09:33.040 --> 09:39.560
And then he asks can you spot the memory leak saying that before we get to the item and try and visualize

09:39.880 --> 09:41.280
What the memory leak is?

09:41.360 --> 09:44.880
Let's take a look at the code base and the code base of this

09:45.320 --> 09:52.160
Stack implementation a really simple stack implementation that just your block has used here as an example to

09:52.520 --> 09:56.880
Illustrate his point. So I'm pretty much going to go through this code line by line despite it being a bit long

09:57.520 --> 10:00.680
Because I think that's the best way to understand this. We have a

10:01.360 --> 10:06.920
Simple class called stack. We have a object array of elements and another

10:07.840 --> 10:11.360
Private of the object array is also private but also another private

10:13.200 --> 10:19.240
Variable called size of primitive type integer of int. Sorry and then this

10:20.160 --> 10:22.360
constant here is what

10:23.440 --> 10:25.440
initially defines the

10:25.720 --> 10:27.720
Initial stack capacity

10:28.400 --> 10:33.680
So when the stack class is instantiated, of course the constructors called

10:34.200 --> 10:36.200
And in the client over here

10:36.920 --> 10:38.920
I am instantiating the class

10:39.280 --> 10:41.280
line number 57

10:41.480 --> 10:42.680
so

10:42.680 --> 10:46.200
When the constructor is called a new

10:47.560 --> 10:49.840
Object array is initialized. So this

10:50.840 --> 10:52.840
array we defined here

10:53.080 --> 10:54.680
elements

10:54.680 --> 10:59.640
that this this new object is passed to that variable and when the

11:00.000 --> 11:06.800
New object array is initialized. It's default capacity. Yes. I've made a mistake here. It's not 26 at 16

11:07.360 --> 11:12.640
And that's assigned to the variable elements. So this variable in line number 10 will hold a

11:12.640 --> 11:16.000
I'm pointing to the code as if you can see where I'm pointing at. That's so funny

11:16.080 --> 11:22.160
Anyway, this object array will hold a reference or elements will hold a reference to this new object

11:22.400 --> 11:26.240
That was created and that's in the heap and then we have a method called push

11:26.640 --> 11:32.200
and what that does is as you'd expect from a stack you can push new elements on new objects onto the

11:32.560 --> 11:37.840
Stack or in this case the elements array, but but in that method we have another

11:38.640 --> 11:41.680
method that we call call ensure capacity

11:42.520 --> 11:44.520
ensure capacity just ensures that

11:45.160 --> 11:52.440
There's space for at least one more element roughly and if not, it'll just double the capacity each time the

11:52.520 --> 11:55.240
Areas to grow because we want the stack to be dynamic

11:55.240 --> 11:59.000
you can see here it's creating a copy of elements and passing it to elements and

11:59.320 --> 12:03.520
The more we keep adding on to the stack the more the area grows so doubles in size

12:03.520 --> 12:10.520
Let's say now we get to the point this pop method is what's pertinent to our item and where we see

12:11.480 --> 12:14.000
Memory leak take place. So we have this

12:15.440 --> 12:18.120
Object method. Sorry, we have this pop method

12:18.760 --> 12:25.800
And we don't here in this method garbage collection doesn't take place and that's why we need to be aware of that

12:26.320 --> 12:32.480
So firstly if the size is equal to zero, which is going to throw an empty stack exception

12:32.480 --> 12:36.120
And we can't add something to an empty stack and here we see

12:37.240 --> 12:39.680
that when we pop the

12:40.600 --> 12:42.200
object of the

12:42.200 --> 12:45.800
Array or when we return the object that's in the array

12:46.400 --> 12:53.560
Where we reduce the size with this counter. So this was the variable we declared here in line number

12:54.320 --> 13:00.360
11 and when we reduce that. Oh, sorry. I didn't I didn't say that in fact in the push

13:01.600 --> 13:07.640
Method whenever we push a new item onto the array. We also increase the count on that variable

13:07.640 --> 13:11.720
And when we pop it we reduce it kind of makes sense. Well, what happens here though is

13:12.880 --> 13:18.480
Whenever we pop an object from the stack or when we take an object out from this array

13:19.480 --> 13:21.480
An object is still

13:21.960 --> 13:27.360
unintentionally retained here despite the client of this class having no use of those objects and

13:28.280 --> 13:36.240
That's where the memory leak takes place and the proper way to do this and again this bit of code here line number 20 to 33

13:36.240 --> 13:42.640
I will illustrate that in this diagram more visually. It'll make a lot more sense. Whoops. That was a mistake

13:43.360 --> 13:45.000
Getting back to this

13:45.000 --> 13:49.640
But this is not the right way to do it because what's happening here is a memory leak

13:50.640 --> 13:52.880
The proper way to do it would be like this

13:55.520 --> 13:57.840
I'm gonna comment out the wrong way

14:00.200 --> 14:02.640
It would still be where we are checking if the

14:03.360 --> 14:08.040
Stack is empty the stack can't be empty and then we are in fact

14:09.000 --> 14:11.400
Assigning this value onto a new

14:12.200 --> 14:18.080
Variable we're gonna create called result. So whatever the elements array returns after we reduce the size

14:18.320 --> 14:21.480
We're gonna assign that value to result and then

14:22.440 --> 14:28.280
simply we null out that location on the array and that's where the elimination of

14:28.560 --> 14:32.240
The obsolete reference takes place and we return the result afterwards

14:32.240 --> 14:37.440
So we assign it to result and return the result will be ensure that that

14:38.280 --> 14:41.000
Element on the in the array that index

14:41.640 --> 14:48.560
That we return that it's not out because when it's not out what happens is something like what we see here

14:48.880 --> 14:54.960
It's clear that it's not obsolete that it's not pointing at something and taking up memory resources

14:54.960 --> 14:58.160
And really if you run this code there really isn't a use in running the code

14:58.160 --> 15:01.520
But this is kind of what you'd see. I can just print out the

15:02.160 --> 15:04.160
Array or the stack in this case

15:05.000 --> 15:10.160
This you can ignore this empty stack exception. The reason for that is because we are pretty much

15:10.960 --> 15:12.480
pushing

15:12.480 --> 15:17.920
Everything into the stack and then popping everything off the stack and then you would at one point as we go through it

15:18.440 --> 15:20.440
expect this

15:21.360 --> 15:25.440
Exception to be thrown here, which is wait, I just missed it

15:28.040 --> 15:33.640
Right here because what happens is we keep popping the stack at one point the stack gets empty

15:33.640 --> 15:36.720
So this is kind of expected this error here

15:39.720 --> 15:45.600
So now before I read out what Joshua book has explained here, let's take a look at this diagram and visualize it

15:45.800 --> 15:50.840
So here we have that elements array that I spoke about before so that's the array

15:51.400 --> 15:58.440
Right here, but the object array that we define. That's what I've illustrated or represented here

15:58.440 --> 16:00.440
And we let's say the objects

16:00.680 --> 16:03.400
Of our integers and we're adding

16:05.240 --> 16:09.400
One two three four five six, I don't know why I put a zero in front

16:09.400 --> 16:11.720
Let's just think of it as one two three four five six

16:12.360 --> 16:16.280
And then this is being added by the push method here

16:19.080 --> 16:24.840
But then for some reason we also pop some of it and we pop three items from the

16:25.560 --> 16:31.720
Array now what happens here is if you don't null out the references the way we've done here

16:32.600 --> 16:38.200
These things are still gonna exist in the array. However for the purpose of the stack class

16:39.000 --> 16:47.000
The client will never use these elements these these objects. They'll just exist in memory making them obsolete and

16:47.560 --> 16:49.560
more importantly

16:49.560 --> 16:51.560
Making it a memory leak because it's taking up

16:52.360 --> 16:56.360
Resources that could be used for something else and that's the problem here

16:56.520 --> 16:57.560
If you don't know that out

16:57.560 --> 17:04.360
So the right way to do it is to treat this array in this way where the way we've done it in the proper pop method

17:05.160 --> 17:07.160
every time we return

17:07.720 --> 17:09.720
Whatever is in the index of this array

17:09.960 --> 17:17.400
We also ensure that it's not out in that way that reference is eliminated. Sorry the obviously reference is eliminated

17:17.800 --> 17:21.880
I hope that makes sense. I'm repeating the same point, but you know repetition is important to

17:22.280 --> 17:28.760
Make sense of this and on the note of repeating. I'm going to read out what Joshua Bloch has said about this particular class in the book

17:30.200 --> 17:32.200
He goes like this

17:32.760 --> 17:35.240
There's nothing obviously wrong with this program

17:36.520 --> 17:41.000
You could test it exhaustively and it would pass every test with flying colors

17:41.640 --> 17:43.640
But there's a problem lurking. Ooh

17:43.800 --> 17:47.960
Indeed indeed loosely speaking the program has a memory leak

17:48.440 --> 17:52.200
Which can silently manifest as reduced performance due to the

17:53.000 --> 17:56.920
increased garbage collectivity or increased memory footprint

17:57.800 --> 18:00.680
Footprint what kind of process would um, yeah, so

18:01.320 --> 18:04.520
That's that the increased memory footprint is what I explained here

18:05.160 --> 18:11.400
That these three, uh, let's say for this example these three indexes create taking up space in the heap

18:11.640 --> 18:14.920
He keeps going if a stack grows and then shrinks

18:15.480 --> 18:19.080
The objects that were popped off the stack will not be garbage collected

18:19.240 --> 18:23.800
Even if the program using the stack has no more references to them

18:24.280 --> 18:27.800
So that is what we saw in the other method the

18:29.000 --> 18:31.000
When it's wrong

18:31.400 --> 18:33.640
The way it shouldn't be done. There's nothing out here

18:34.360 --> 18:38.360
This is because the stack maintains obsolete references to these objects

18:38.840 --> 18:44.040
An obsolete reference is simply a reference that will never be dereferenced again

18:44.120 --> 18:46.600
So never be used by the program again

18:47.800 --> 18:54.280
In this case any references outside of the active potion of the element array are obsolete

18:54.600 --> 18:59.640
It's important to understand what he means by the active potion the active potion really is the

19:00.520 --> 19:05.800
The potion of the array that the client would care about or use the client of this class

19:06.200 --> 19:10.520
So in this example, the active portion really is index zero one and two

19:10.920 --> 19:17.400
Not this but here, which is why they should be not out the active portion consists of the elements whose index is less than size

19:17.480 --> 19:19.800
Yes, so this size here

19:20.600 --> 19:25.080
Is what holds the size of the stack and then he sort of concludes that point by stating

19:25.560 --> 19:30.920
memory leaks in garbage collected languages like java more properly known as

19:31.720 --> 19:34.520
unintentional object retentions iron citys

19:35.240 --> 19:38.440
If an object reference is unintentionally retained

19:38.680 --> 19:42.200
Not only is that object excluded from garbage collection

19:42.680 --> 19:44.680
But so too are any objects

19:45.160 --> 19:51.880
Reference by that object and so on it's an interesting point there because I've had a conversation with a c++

19:52.120 --> 19:54.120
engineer or developer

19:54.680 --> 19:59.640
In my company and he kind of made the point, you know, that's kind of the trade-off we make in programming

20:00.120 --> 20:02.120
the more we sort of

20:02.200 --> 20:08.840
Give control to the virtual machine in this case the jvm the less we know what's going on

20:09.880 --> 20:10.920
kind of

20:10.920 --> 20:12.920
Um behind the scenes under the hood

20:13.320 --> 20:21.000
Uh, the the more abstractions on abstractions we build the less of an understanding we have as to what's going on in our program

20:21.640 --> 20:25.320
Uh, which is why for instance when it comes to using packages

20:26.040 --> 20:30.520
Uh, sometimes it can be dangerous and to use Joshua block's term insidious

20:31.000 --> 20:37.800
Because we don't have a really good power or deep understanding of what's happening. Let's say at a memory management level

20:38.280 --> 20:40.280
so as a good programmer, it's

20:41.080 --> 20:42.520
I guess it's it's

20:42.520 --> 20:48.760
It's important to be kind of prudent and careful about that and and be judicious as to how we write our code

20:49.000 --> 20:51.720
Anyway, before I get carried away, uh, philosophizing about programming

20:52.040 --> 20:57.320
Let's get back to the point here, uh, and the item he states then the fix for this sort of problem is simple

20:57.720 --> 21:02.520
Null out references once they become obsolete. That's what I've shown here. I already showed the solution

21:03.080 --> 21:07.880
In the code itself an added benefit of nulling out obsolete references is that if they are

21:08.440 --> 21:14.520
Subsequently dereference by mistake the program will immediately fail with the null point exception

21:15.160 --> 21:17.160
Rather than quietly doing the wrong thing

21:17.320 --> 21:21.080
It is always beneficial to detect programming errors as quickly as possible

21:21.320 --> 21:24.680
Now, I don't know how in this class someone could dereference

21:25.240 --> 21:27.240
parts of this array that

21:28.040 --> 21:34.760
Theoretically should not be accessed in the stack class, but it's possible if that area was public. Let's say by mistake

21:35.640 --> 21:36.840
and

21:36.840 --> 21:39.160
theoretic it would be a theoretical mistake if

21:39.960 --> 21:41.960
after the size of the

21:42.040 --> 21:47.160
Stack changes, let's say the size of the stack was three and we only had zero

21:47.880 --> 21:49.400
One two and three

21:49.400 --> 21:54.200
And we still get access to the client to uh four and five that would be a mistake

21:54.360 --> 21:56.120
But when we now that out

21:56.120 --> 22:00.520
The error is explicit and clear because the program will throw a null point exception

22:00.600 --> 22:06.840
But interestingly then he also makes the provision that nulling out object references should be the exception

22:07.320 --> 22:09.160
Rather than the norm

22:09.160 --> 22:10.280
so

22:10.280 --> 22:12.520
Technically this thing what you've done here

22:13.640 --> 22:17.560
Shouldn't always be done. There are better ways to handle this or eliminate

22:18.040 --> 22:23.080
obsolete references than just nulling out elements in this area. Let's say in this example

22:23.640 --> 22:27.720
The best way to eliminate an obsolete reference is to let the variable

22:28.200 --> 22:31.000
That contain the reference fall out of scope

22:31.640 --> 22:35.240
This occurs naturally if you define each variable in the

22:35.880 --> 22:39.240
narrowest possible scope and this is kind of what I meant by uh

22:39.960 --> 22:42.360
Narrow scoping is one way that allows

22:43.000 --> 22:50.360
Eliminating obsolete of references and I did explain what narrow scoping is it's ensuring that when we define a variable and we declare a variable

22:50.600 --> 22:51.960
It's in the

22:51.960 --> 22:54.680
Narrowest possible scope in our source code

22:55.000 --> 22:59.480
But if he says nulling out shouldn't be the norm why in this example is given in the stack class

22:59.640 --> 23:07.000
Why are we nulling out uh these references? Why not use narrow scoping as he suggested which he says should be the norm

23:07.800 --> 23:13.240
To put it simply he says it's because the stack class manages its own memory. We see that here

23:13.800 --> 23:15.800
We see that as to what's what's what's going on here

23:16.920 --> 23:21.560
Where we're managing the memory I propose this array here

23:24.120 --> 23:28.120
The storage pool consists of the elements of of the elements array

23:28.600 --> 23:32.920
That's a bit a bit confusing. I know but the elements inside this array. So each

23:33.640 --> 23:34.760
uh

23:34.760 --> 23:42.360
Individual element which he's added here are the object references not the objects themselves. So these are references themselves

23:43.080 --> 23:47.720
And then the elements in the active portion of the array as defined earlier are allocated

23:48.040 --> 23:50.600
And those in the remainder of the array are free

23:51.320 --> 23:55.240
So that's the active portion. That's allocated and these are made free

23:57.880 --> 24:01.080
The garbage collector has no way of knowing this to the garbage collector

24:01.240 --> 24:07.640
All of the object references in the element elements array are equally valid correct because the garbage collector doesn't know

24:08.040 --> 24:12.680
What the purpose of this stack class is the garbage collector isn't that intelligent

24:12.840 --> 24:18.360
Hopefully in the future it would be only the programmer or get up co-pilot perhaps

24:18.840 --> 24:22.200
Knows that the inactive portion of the array is unimportant

24:22.760 --> 24:26.840
The programmer effectively communicates this fact to the garbage collector by manually

24:27.240 --> 24:33.640
Nulling out array elements as soon as they become part of the inactive portion. That's correct. That's what we've done here

24:35.240 --> 24:38.200
And then just to conclude that point joshua block states

24:38.680 --> 24:40.200
Generally speaking

24:40.200 --> 24:45.560
Whenever a class manages its own memory the programmer should be alert for memory leaks

24:45.960 --> 24:48.680
So what are the examples can we think of when it comes to memory leaks?

24:49.240 --> 24:51.240
apropos java and jvm

24:51.880 --> 24:57.800
Another example that he's given here is memory leaks that we would see and sorry. I shouldn't say apropos java and jvm

24:57.880 --> 25:03.000
This is just commonly in programming in let's say op programming in general

25:03.560 --> 25:06.280
These examples he's laid out or laid down

25:06.920 --> 25:08.920
could lead to potential memory leaks

25:09.960 --> 25:17.320
And the first one is given is in caches. It's quite common to see memory leaks in caches because of course what happens a lot in a cache is we

25:18.280 --> 25:21.560
Cache data and when we do cache data we cache objects

25:22.120 --> 25:28.520
There's a high possibility if we don't do it in a smart port art way that it can it can lead to

25:29.960 --> 25:33.480
Obsolete object references because once an object reference is put in a cache

25:33.880 --> 25:36.680
It can be left there long after it stops being relevant

25:36.840 --> 25:41.400
Toss being obsolete and the solution for this problem of memory leaks and caches that

25:41.800 --> 25:45.000
Joshua blocker suggests it is using weak hash maps

25:45.560 --> 25:50.520
And when I said in the beginning of the item that there are some ancillary points some concepts

25:50.520 --> 25:55.080
We need to understand to really get to the crux of this item

25:55.960 --> 25:59.320
This is what I meant. I've never used a weak hash map in my life

26:00.040 --> 26:04.200
Therefore I had to do a bit of reading and styling as to what weak hash maps are

26:05.080 --> 26:09.640
So just a block states before I get to what a weak hash map is and before I go through the code

26:10.120 --> 26:12.440
Which I've got here. I've got a weak hash map demo

26:14.360 --> 26:19.560
Joshua block states if you're lucky enough to implement a cache for which an entry is relevant

26:19.720 --> 26:25.080
Exactly so long as there are references to its key key outside of the cache

26:25.800 --> 26:28.040
Represent the cache as a weak hash map

26:28.840 --> 26:32.600
Entries will be removed automatically after they become obsolete

26:32.680 --> 26:37.080
So conceptually that sort of makes sense, doesn't it because the reason we have a cache is to

26:37.400 --> 26:40.520
for quick access of data of objects and

26:41.240 --> 26:47.720
The key in a cache we we got to make sure that whatever data that's in the cache that the keys are

26:48.280 --> 26:50.280
relevant outside of

26:50.520 --> 26:53.560
The data structure in the cache in this case. It could be a hash map

26:54.200 --> 27:00.840
So that ensures that we don't have obsolete object references and he keeps going that remember that

27:01.240 --> 27:03.240
Weak hash map is useful

27:03.240 --> 27:10.040
Only if the desired lifetime of cache entries is determined by external references to the key not the valley

27:11.160 --> 27:15.080
Okay, now let's understand what a weak hash map is

27:15.720 --> 27:22.040
Firstly before we get to the code, let's get through some definitions. It's important to get a firstly a theoretical understanding

27:22.040 --> 27:24.040
a conceptual understanding of what this is

27:24.440 --> 27:30.280
Uh, and one of the best definitions as for you sure that I found is by about dunks blog

27:31.000 --> 27:39.000
It's this blog now that's on profile is it's this blog post here a guide to weak hash map in java

27:40.600 --> 27:42.600
And he states

27:42.680 --> 27:50.040
Simply put the weak hash map is a hash table based implementation of the map interface with keys that are of a

27:50.680 --> 27:56.600
Weak reference type and now we have another term here. What are weak references for that will open up

27:57.240 --> 28:00.760
The best explanation that I found is this stackover flow answer

28:01.320 --> 28:05.240
Uh, and in fact, this user says that it's by ether necklace

28:05.640 --> 28:08.120
But the name of this user is michael myers

28:09.000 --> 28:15.000
And a weak reference simply put is a reference that isn't strong enough to force an object to remain in memory

28:15.560 --> 28:21.720
weak references allow you to leverage the garbage collectors ability to determine the reach ability for you

28:22.120 --> 28:24.120
So you don't have to do it yourself

28:24.360 --> 28:29.400
But also in this article by bio dung. He's given some pretty good definitions where he

28:30.360 --> 28:36.200
Decerns between strong soft and weak references. So a strong reference is what would normally be when we

28:36.760 --> 28:40.760
Declare a variable like this. Let's say that's a strong reference

28:41.320 --> 28:46.440
And this is the most common type and it's not eligible for garbage collection

28:46.920 --> 28:51.400
A soft reference is eligible for garbage collection, but only when

28:52.120 --> 28:57.640
Uh, the jvm needs more memory. It absolutely needs more memory. And in fact, he's made that point here

28:58.280 --> 29:01.160
It's it's kind of like a last resort kind of thing

29:01.640 --> 29:07.160
But a weak reference is not that a weak reference doesn't the garbage collector is given volition

29:07.800 --> 29:13.240
Where it can so eagerly garbage collect it won't wait until it needs more memory. It'll just

29:14.600 --> 29:17.640
Use it up if required and that's where

29:18.360 --> 29:22.360
Using a weak reference in the context of a cache helps us to eliminate

29:22.840 --> 29:24.840
obsolete object references

29:25.080 --> 29:29.560
So in any case, that's another definition of a weak reference. There's also this article

29:30.120 --> 29:36.680
That I read which is quite good. I think it gave a pretty good practical and sort of applicative explanation of what

29:37.400 --> 29:43.160
Well, the title of the article is practical uses of weak references by this user

29:43.800 --> 29:45.800
philosophical geek or I guess Ben Watson

29:46.200 --> 29:49.000
I'll leave a link to this down below too where he goes through

29:49.560 --> 29:51.560
Well, he starts off the article by saying that

29:52.200 --> 29:55.400
You rarely use weak references, but if you do use them

29:56.280 --> 30:03.240
It'll mostly be for framework building or when it comes to something at more of the memory management level and

30:03.480 --> 30:06.600
Java programmers at least day-to-day Java programmers like myself

30:08.040 --> 30:10.760
Don't don't really do a lot of memory management

30:11.560 --> 30:18.040
But this is a good article to read just for learning. So back to the weak hash map definition, which uses weak reference type, by the way

30:18.840 --> 30:20.360
file then continues

30:20.360 --> 30:24.040
An entry in a weak hash map will automatically be removed

30:24.760 --> 30:31.720
When its key is no longer in ordinary use meaning that there is no single reference that point to that key

30:33.160 --> 30:35.960
When the garbage so what this bit means here

30:37.480 --> 30:38.600
is

30:38.680 --> 30:41.560
In the the key value pairs and in the hash map

30:42.040 --> 30:46.200
If the key isn't being used anywhere outside of the data structure outside of the cache

30:46.840 --> 30:50.680
That means that there's no single reference. Therefore, it just could be removed

30:51.320 --> 30:53.560
automatically and and having a weak reference helps

30:55.080 --> 31:01.640
When the garbage collection process discards a key its entry is effectively removed from the map

31:02.040 --> 31:07.400
So this class behaves somewhat differently from other map implementations because

31:07.960 --> 31:12.600
normal map implementations would have a strong reference and you can't just

31:14.200 --> 31:18.040
Let the garbage collector just do garbage collection as it wishes eagerly

31:19.160 --> 31:21.880
It's a bit more tighter and a bit more stricter

31:22.680 --> 31:25.000
I just realized that I didn't go through this

31:25.640 --> 31:33.240
Canonicalized a mapping bit that is in fact from the oracle docs that defines what weak references are

31:33.240 --> 31:37.400
So the doc state weak reference objects which do not prevent

31:38.120 --> 31:43.160
Their reference from being made finalized finalizable finalized and they're reclaimed

31:44.600 --> 31:47.400
weak references are most awfully used to implement

31:48.680 --> 31:51.640
Canonicalizing mappings. What does that mean?

31:52.520 --> 31:54.840
So this is another really good blog post. I read

31:58.280 --> 32:01.000
On weak references, sorry I had to find the blog post here

32:02.840 --> 32:07.640
And the title of the blog post is itself canonicalized mappings. I'll leave all into that down below

32:07.800 --> 32:10.680
I'm not going to go through the whole thing. But the definition is

32:12.600 --> 32:15.080
But oh the it's by uh, uh, Tom

32:15.800 --> 32:17.320
Tom Roy's own

32:17.480 --> 32:19.480
Rosanne and Ian Lowe

32:19.720 --> 32:24.360
A canonicalized mapping is where you keep one instance of the object in question in memory

32:24.840 --> 32:28.680
And all other lookup that particular instance via pointers

32:29.400 --> 32:31.400
Or some such mechanism

32:32.040 --> 32:35.880
The short answer is that weak reference objects can be used to create

32:36.520 --> 32:44.120
Pointers to objects in your system while still allowing those objects to be reclaimed by the garbage collector once they pass out of scope

32:45.080 --> 32:47.560
That kind of makes sense. I mean, I

32:49.160 --> 32:50.360
Hmm

32:50.360 --> 32:52.360
It makes sense in the sense of

32:52.920 --> 32:54.920
I can see why

32:55.000 --> 32:57.000
theoretically a weak reference type

32:58.440 --> 33:02.200
Can be used in a weak hash map to prevent

33:03.720 --> 33:09.000
Memory leaks in a cache. I can I can see the reason I'm going to be honest. I don't think I can

33:09.560 --> 33:11.080
sell fully

33:11.160 --> 33:13.160
Understand how to implement that in code

33:13.240 --> 33:19.320
But at least conceptually I can see the connection there. So now let's take a look at what a weak hash map is

33:19.320 --> 33:24.680
So I created this class called the weak hash map demo. I kind of repurposed this example

33:25.240 --> 33:27.720
That was used on vile dunks blog

33:28.680 --> 33:34.600
And firstly, uh, this part really isn't a part of the weak hash. I just want to show how to create a weak reference

33:35.080 --> 33:38.040
That's how you do it. It's a generic type. You pass it

33:38.760 --> 33:40.200
of integer

33:40.280 --> 33:43.480
And then you create the weak reference easy as that and then when we

33:45.000 --> 33:47.400
Made this prime reference null

33:48.280 --> 33:50.280
Initially, we declared let me make it null

33:50.600 --> 33:54.440
This object will be garbage collected in the next gc cycle

33:55.000 --> 33:58.760
Um, as there is no other strong reference pointing to it

33:58.920 --> 34:02.760
So when we create the weak reference as you can see here, we are passing that object

34:03.720 --> 34:10.280
Into the constructor of the weak reference class and now this new object is a of type weak reference

34:10.680 --> 34:17.080
But that's just how I create weak references. Now, let's get to the the cracks of this class. I this is terrible coding

34:17.080 --> 34:21.080
I should have put this somewhere else because this in no way is related to this class

34:22.120 --> 34:25.320
But in any case, it's just for demonstration purposes

34:26.200 --> 34:30.280
Here's how we create a weak hash map. Um, so

34:31.240 --> 34:36.520
It's just like creating a normal hash map really. Um, you have to define the key and the value the types of the key and the value

34:37.480 --> 34:39.480
and ideally we want a

34:39.480 --> 34:41.640
map implementation that allows

34:42.280 --> 34:45.160
garbage collection to automatically delete unused objects

34:45.960 --> 34:47.560
correct and

34:47.560 --> 34:51.320
Because we ideally want that is is the reason that we use a weak hash map

34:51.800 --> 34:57.720
When a key of a big image object is not in use and application in any place. So that's

34:58.520 --> 35:03.320
Uh, the key for this object here the unique image name in this case would be the key

35:04.120 --> 35:09.320
This entry will automatically be deleted from memory. It's pretty cool. In fact, how this happened and I'll show you

35:09.720 --> 35:14.760
This and show this to you in code. So we have the weak reference map. Just ignore the other line of code

35:14.760 --> 35:18.200
I've used here. It's just a normal hash map. I've used I was just playing around with this

35:18.280 --> 35:22.200
But what matters really is the the map I've created here in line number 25

35:22.520 --> 35:26.040
So for all intents and purposes this hash map could be our cache

35:26.760 --> 35:28.760
And we are putting a new

35:28.760 --> 35:32.440
big image object into that cache into our hash map

35:34.680 --> 35:39.480
We're also creating key and putting that key too and we're creating the key value pair here

35:41.240 --> 35:44.440
And the image name of course is the object reference, which is the key

35:45.160 --> 35:48.280
Uh, so if I run this code now what you'll see is

35:52.920 --> 35:54.920
Um

35:55.240 --> 36:02.280
So what's this log here map this contain does not contain an image name. Um, so

36:04.440 --> 36:06.200
That is terribly misleading

36:06.200 --> 36:09.720
I just realized that that log can be extremely confusing because

36:10.440 --> 36:14.840
The map is supposed to contain image name because they're putting it in line number 31

36:15.240 --> 36:17.080
And we aren't nulling out any key here

36:17.160 --> 36:23.080
So I I'm gonna run that again because that can be really confusing and kind of ruin the purpose of this demo

36:24.760 --> 36:26.760
The map should contain

36:28.120 --> 36:29.240
Image name

36:29.240 --> 36:34.280
It should contain the key because we haven't nulled it out and I think nothing has happened and of course

36:34.840 --> 36:39.240
The map will also contain a big big image the big image object

36:41.320 --> 36:44.840
Also, that's confusing I should have prepared for this demo much better

36:45.240 --> 36:49.480
I gotta get rid of that line because I'm adding it twice into the hash map. I don't know why I'm doing that

36:49.800 --> 36:52.120
Anyway, in any case, I hope I'm trying I'm making sense

36:52.120 --> 36:55.160
Yeah, I profusely apologize because this is not a good demo

36:55.960 --> 37:02.360
Hey, but uh, as the software engineers, we all know that whenever there's a demo things break. So perhaps it is

37:03.480 --> 37:07.960
Ironically a good demo because this is what a demo would actually look like. Uh, so

37:08.920 --> 37:13.560
Initially, yes, it does contain the key and it also does contain the value

37:14.040 --> 37:15.720
And then what happens is

37:15.720 --> 37:18.920
We null out the key. That's all we're doing. We're not clearing anything out

37:19.240 --> 37:25.640
And then we just run a garbage collection cycle. We force a jvm to write a gc cycle and then

37:26.440 --> 37:28.120
almost magically

37:28.120 --> 37:30.120
The bloody hash map is empty

37:30.440 --> 37:35.480
And how is that this wouldn't happen if it was a normal hash map with a strong reference

37:36.440 --> 37:39.800
The way the hash map is empty in so this is the log here that you see

37:40.760 --> 37:46.920
Uh is in fact because this hash map is a weak hash map using weak reference type

37:47.640 --> 37:49.640
so when the external

37:50.600 --> 37:52.920
Reference to this key was nulled out

37:53.720 --> 37:56.280
The object itself or the key value pair

37:56.920 --> 38:02.440
Was garbage collected because it's it's it's it's not not used. So that's the perfect

38:03.480 --> 38:05.960
implementation of a cache that'll prevent

38:06.680 --> 38:11.960
memory leaks and then for this problem of memory leaks and caches and another solution that he's proposed

38:12.440 --> 38:14.440
is sort of using a

38:14.520 --> 38:17.880
least recently used cache eviction policy, uh

38:18.680 --> 38:24.680
But the implementation of it is a bit more different to kind of the conceptual understanding of what that policy is

38:25.160 --> 38:29.080
And that can be done using a scheduled thread pool executor

38:29.560 --> 38:33.160
And it could be what what this does is in the background on a separate thread

38:33.240 --> 38:39.080
You can run tasks scheduled tasks repeatedly such as cache cleansing

38:39.800 --> 38:45.080
Uh, and to understand what this is what a scheduled thread pool executor does

38:45.560 --> 38:51.160
I came across this article on geeks for geeks by a user called

38:53.400 --> 38:56.600
Samu foe and that's the user's uh pseudonym

38:57.640 --> 38:58.680
and

38:58.680 --> 39:01.960
Here's the implementation of that class. I think it's important to understand what this is doing

39:02.360 --> 39:07.080
Even though this isn't fully related to clearing caches the way it'll work is like this

39:07.720 --> 39:10.440
So I anyway, but by the way all this code is

39:11.080 --> 39:13.400
On the github repository. So please go take a look

39:14.200 --> 39:18.680
And this kind of demonstrates how the schedule thread pool executor works

39:20.600 --> 39:23.240
Initially we create a object called thread pool

39:23.480 --> 39:26.920
We create an instance of the schedule thread pool executor and we pass

39:27.560 --> 39:30.600
The the size so how many threads it's two threads in this case

39:31.240 --> 39:36.440
And then we create two runable tasks. So these tasks could be anything it could even be something like

39:37.480 --> 39:38.440
the main

39:38.440 --> 39:41.160
Let's say the main thread that's running the program and then in the background

39:42.200 --> 39:44.520
clearing the cache in a given time

39:45.240 --> 39:47.240
um, and afterwards

39:48.440 --> 39:52.760
The first one will execute in two seconds and the second one in five seconds

39:53.240 --> 39:56.680
That's it's simple as that so if if I run this method you'll see

39:56.760 --> 39:58.760
The

40:00.280 --> 40:04.440
The first one executed in two seconds and the other one executed a bit later and then

40:05.080 --> 40:07.080
That a bit later. Sorry

40:07.640 --> 40:12.280
That's the current time. I apologize. So that was in the execution. So that was the first task

40:13.000 --> 40:15.000
And that was the second task

40:15.160 --> 40:21.240
So I shouldn't have said every cache every cache of both tasks because this could be in fact, uh, something else. It could be

40:22.040 --> 40:25.560
um, I don't know some some some main task and then the

40:26.120 --> 40:27.880
second one

40:27.880 --> 40:31.000
Which we scheduled to run in five seconds could be the cache eviction

40:32.440 --> 40:35.320
So that's the implementation of of that idea of

40:36.120 --> 40:42.120
Cache eviction policy using a scheduled critical executor and to be you know, pretty more formally and clearly

40:42.760 --> 40:49.080
Joshua block states most commonly the useful lifetime of cache entry is less well defined

40:49.480 --> 40:52.280
With entries becoming less valuable over time

40:52.840 --> 40:59.800
Under these circumstances the cache should occasionally be cleansed of entries that have fallen into disuse. So that's where

41:00.520 --> 41:03.720
scheduling a task like this using uh, these scheduled

41:03.800 --> 41:06.120
Terrapulexecuda could come in handy because

41:06.760 --> 41:11.320
We could time it because schedule a cache eviction in a given period of time

41:11.640 --> 41:17.800
And then he even states that the linked hash map does this so if you take a look at the docs for the linked hash map

41:18.120 --> 41:20.120
there's a protected

41:20.520 --> 41:21.720
Boolean

41:21.720 --> 41:28.360
method called remove eldest entry and that method what that does is in fact

41:32.200 --> 41:38.360
It's an implementation of what Joshua block is described here. It is is clearing the uh, linkless

41:39.640 --> 41:41.640
Sorry the link hash map

41:41.640 --> 41:43.480
By clearing out the old entries

41:43.480 --> 41:49.800
So it says it provides the implement of this class with the opportunity to remove the eldest entry each time a new one is added

41:49.960 --> 41:52.520
And then we get to the third way memory leaks could happen

41:52.840 --> 41:56.120
So we've discussed, uh, how it could happen if classes

41:56.520 --> 42:02.040
Manages their own memory if we discussed how it could happen in caches and the third way is

42:02.600 --> 42:06.520
uh, the third common way is it could happen when it comes to, uh

42:07.480 --> 42:09.480
listeners and other callbacks when we

42:10.360 --> 42:12.360
When a client uses an api

42:12.920 --> 42:16.920
With a callback function. So firstly, what's a callback? Um, so

42:17.640 --> 42:19.240
Rich, uh

42:19.240 --> 42:25.400
Rich of jindal from geeks4geeks states that a callback function is a function that is passed

42:25.800 --> 42:30.200
Into another function as an argument and is expected to execute after some kind of event

42:31.000 --> 42:37.480
I would also add it's also an example of so the how callbacks are implemented is an example of the observer pattern

42:37.880 --> 42:41.240
Where an object should subscribe to another object and listens

42:41.880 --> 42:43.880
To changes in events on runtime

42:44.440 --> 42:48.840
And that's what a callback is. It's a it's a function. It can pass to be executed

42:49.800 --> 42:51.000
you know

42:51.000 --> 42:53.560
Contingent on on on an event during runtime

42:54.920 --> 42:59.400
Uh, even though I've used callbacks obviously javascript uses well we use promises

42:59.400 --> 43:03.240
But then a lot of javascript uses before promises use callbacks

43:03.960 --> 43:09.640
And even in java we use callbacks, uh, but I didn't initially get the understanding

43:09.960 --> 43:11.960
Oh, I didn't initially understand

43:12.600 --> 43:13.960
How it can

43:13.960 --> 43:18.680
Work apropos weak references and how the garbage collection works when it comes to callbacks

43:18.680 --> 43:22.600
So I did post a cycle of low question and I got a really good answer

43:23.160 --> 43:25.160
By this user called, uh

43:25.400 --> 43:27.400
Ingo kegel

43:27.400 --> 43:30.920
I'll leave a link to this question down below in the description. Go take a look

43:31.800 --> 43:36.120
But you think that uses the answer. Let's try and make sense of what

43:36.120 --> 43:38.120
Uh

43:38.440 --> 43:44.280
Well, in fact before I say that I just want to say, uh, just a block states apropos this point

43:44.600 --> 43:47.480
If you implement when I mean apropos this point, that's uh

43:48.120 --> 43:53.080
When it comes to memory leaks with listeners and other callbacks, he says he states

43:53.480 --> 43:59.240
If you implement an api where clients register callbacks, but don't do register them explicitly

43:59.640 --> 44:03.240
They will accumulate unless you take some action

44:04.200 --> 44:07.800
So what does that mean? What what's the action we got to take the action?

44:07.800 --> 44:15.400
We got to take would be using a weak reference. Um, and what before we get to the code. I I realized I should I should read out

44:18.040 --> 44:19.880
Ingo kegel's answer here

44:19.880 --> 44:24.200
He says a client of the api has to keep a strong reference to the listener

44:24.760 --> 44:29.720
That's how it says without correct. So the we can define the listener here as an interface

44:29.720 --> 44:32.440
That's how we would normally do when implementing callbacks in java

44:34.200 --> 44:38.120
The api only holds a weak reference to the listener to do that

44:39.800 --> 44:41.800
So that it does not prevent that's a

44:42.840 --> 44:47.400
Type of that I believe so that it does not prevent the client from being garbage collected

44:47.960 --> 44:49.240
So it allows

44:49.240 --> 44:55.800
Garbage collection to take place if required when the kind is garbage collected the listener is also garbage collected

44:56.280 --> 44:59.080
That's that's a good thing because we want we don't want the

44:59.320 --> 45:05.240
Obsolute object the listener object to exist in memory and take up resources and that's why a weak reference would help

45:06.040 --> 45:12.760
Now the implementation of that would be seen here. So this is the example's courtesy of ingo kegel as I said

45:13.160 --> 45:16.440
This is his code that I've repurposed uh to don't want to write this

45:16.920 --> 45:18.040
um

45:18.040 --> 45:24.120
So firstly, uh since java doesn't support function pointers, this represents a callback effectively

45:24.200 --> 45:26.760
It's a reference to the function which will be called

45:27.720 --> 45:31.560
So because we don't use function pointers, we can use callbacks in java

45:32.040 --> 45:37.480
Function pointers can be used in c++. I believe I don't quote me on that because I'm not a c++ programmer

45:37.800 --> 45:42.600
C++ programmer. Why am I talking so fast and fumbling my words too much of coffee?

45:43.560 --> 45:47.720
So this callback demo represents the mock api that a user would use

45:48.360 --> 45:53.160
Initially, we have defined the listener here. So this listener is of the type the interface listener

45:53.320 --> 46:00.200
Um, and then we've got to initially register this listener. That's what the client would do. So the client of this api

46:00.920 --> 46:07.320
Uh would do that a bit later because the observer of this api has to use that method

46:07.880 --> 46:09.960
And register itself. This is a bit confusing

46:09.960 --> 46:13.080
I should have maybe called it used to separate class and called the client

46:13.080 --> 46:16.600
But this callbacks demo class is the client of this api

46:17.320 --> 46:22.760
Just keep in keep in mind. Um, so that client would have a strong reference

46:22.840 --> 46:24.120
however

46:24.120 --> 46:25.800
once the

46:25.800 --> 46:27.800
registering is done the

46:27.800 --> 46:29.800
api itself

46:29.960 --> 46:36.680
Will maintain a weak reference because then what happens is when this client at one point is garbage collected

46:38.040 --> 46:40.040
So would the listener

46:40.760 --> 46:43.880
That it registers and then we have this file listener method

46:44.280 --> 46:49.640
Which checks for the listener which which checks if it's registered and then fires an event which we've defined

46:50.600 --> 46:56.840
Yeah, which runs some tasks. So that's kind of how it's used in the context of callbacks and listeners

46:58.920 --> 47:01.880
And and that's why using a weak reference would help

47:02.440 --> 47:08.040
With ensuring that there aren't any memory leaks when a client uses our api

47:09.160 --> 47:12.040
And then to conclude in the final paragraph Joshua Block states

47:12.840 --> 47:15.960
Biggest memory leaks typically do not manifest themselves

47:16.440 --> 47:21.080
As obvious failures. They may remain present in a system for years

47:21.560 --> 47:26.040
They typically discovered only as a result of careful code inspection

47:26.520 --> 47:32.680
Or with the aid of a debugging tool known as a heat profiler heat profiler can also be called like a java profiler

47:33.080 --> 47:35.640
And that's a tool pretty much that monitors the bytecode

47:36.120 --> 47:42.120
Constructs and operations at the jvm level at a very low level using a heat profiler. You could

47:43.160 --> 47:45.800
Monitor your code and examine memory usage

47:46.200 --> 47:51.320
How garbage collection takes place if resources are being used waste used wastefully

47:51.960 --> 47:56.520
If there are memory leaks all these things we discussed could be found through a tool like a

47:57.800 --> 47:59.800
Java profiler or heat profiler

48:00.440 --> 48:08.600
And again all done is definition here these these code constructs and opera operations include object creation iterative executions

48:09.160 --> 48:14.920
Including recursive calls method executions threat executions and garbage collections

48:15.160 --> 48:19.560
So it's kind of like a way of instrumenting your application and instrumenting your code. Let's say and really

48:20.520 --> 48:23.720
Digging deep into it and examining it at a bytecode level

48:24.120 --> 48:27.400
And that's obviously something that you know, I've never done it before in my life

48:27.720 --> 48:31.160
Just on your id you can't do that. You need a specific tool for that

48:32.920 --> 48:40.120
Therefore to end it he states it is very desirable to learn to anticipate problems like this before

48:40.440 --> 48:44.360
They occur and prevent them from happening. So that's why this point is great because

48:45.400 --> 48:49.160
Initially just your block points out what the issue is he he kind of

48:50.280 --> 48:55.720
Illustrates it, but then he also gives us three areas where this could potentially occur

48:55.720 --> 49:03.560
We could kind of anticipate where memory leaks could occur when writing code and the three places it could occur

49:05.000 --> 49:07.000
When it comes to having

49:08.280 --> 49:10.760
obsolete object references that we should eliminate

49:11.560 --> 49:13.320
is in

49:13.320 --> 49:18.120
classes that just to reiterate the point in classes that manage its own memory

49:19.080 --> 49:23.000
In caches and when it comes to callbacks and listeners

49:23.720 --> 49:25.720
When you implement that in your api

49:25.880 --> 49:27.880
That's it. That is

49:27.960 --> 49:32.280
The item number seven element obsolete object references

49:33.400 --> 49:40.520
As I did anticipate it did go for over an hour because I did feel even though the item isn't all that long or all that complicated

49:40.840 --> 49:42.840
have a few points like

49:43.560 --> 49:45.720
implementation of the listeners and the callbacks and then the

49:46.360 --> 49:51.880
Weak references that I felt like we need to dive in a bit more and understand at least I needed to to make sense of it

49:52.360 --> 49:55.000
As I said all the code that I used are in

49:55.560 --> 49:58.840
On the github repository and the link to that is in the description down below

49:59.400 --> 50:02.520
Please go to click at the code. It'll make a lot more sense if you study the code

50:03.240 --> 50:05.960
assiduously instead of me kind of explaining it

50:06.840 --> 50:13.000
Again, I'm trying my best to to you know articulate myself while I'm also learning as I go

50:13.160 --> 50:17.720
It's kind of how it works. You probably can see I'm struggling a lot with some of these concepts

50:18.520 --> 50:24.520
But in any case, I sincerely do hope this video brought some value. You learn something from it

50:24.920 --> 50:29.960
I shall see you in the next item. It is item number eight. We're still in chapter two

50:30.840 --> 50:34.920
And item number eight is avoid finalizers and cleaners

50:35.800 --> 50:41.480
And I'll get to that as soon as possible. In fact, I've already started writing the code for it. I'll see you in the next one. Cheers

50:43.000 --> 50:45.960
You

