WEBVTT

00:00.000 --> 00:06.880
Hey everyone, welcome to yet another episode of my video series on, as I fixed this microphone,

00:06.880 --> 00:10.400
on Joshua Bloch's Effective Java.

00:10.400 --> 00:15.640
This is a video series where I expound on the concepts that he has delineated in this

00:15.640 --> 00:16.640
book.

00:16.640 --> 00:19.200
Without further ado, let's get started with the proviso.

00:19.200 --> 00:24.880
I'm trying to keep these things quick because I do repeat this in every single video just

00:24.880 --> 00:28.160
to, you know, for some intelligence, let's say.

00:28.160 --> 00:30.520
And the caveats are, this is not a tutorial.

00:30.520 --> 00:33.000
I am not a teacher, nor an expert.

00:33.000 --> 00:36.040
I certainly am not an expert in any of this.

00:36.040 --> 00:44.160
So while I do try my best to be as accurate as possible, obviously, I certainly will make

00:44.160 --> 00:45.160
mistakes.

00:45.160 --> 00:46.760
So please point them out.

00:46.760 --> 00:51.240
And if it's something significant, I'll even rectify the error in the comment section

00:51.240 --> 00:52.240
down below.

00:52.240 --> 00:55.800
I'd like to think of this as the blind, leading the blind.

00:55.800 --> 01:03.280
I am, as I always say, as blind, or perhaps even more blind than you are, you know, really

01:03.280 --> 01:07.120
quite new to the Java world, given that I've, even though I've been programming with Java

01:07.120 --> 01:13.120
for a couple of years, it's still a very mature language and a mature community and ecosystem.

01:13.120 --> 01:18.160
So consider this to be a exploratory disquisition.

01:18.160 --> 01:23.000
The analogy that I've been using the past couple of videos is that it's like a university

01:23.000 --> 01:25.200
tutorial, except I'm not a tutor.

01:25.200 --> 01:29.520
We're just students kind of working through a problem together.

01:29.520 --> 01:34.160
Of course, though, let's not pretend it's a one-way conversation because I'm doing all

01:34.160 --> 01:35.160
the talking.

01:35.160 --> 01:42.000
Regardless, I have been corrected in past videos, and I have added those in the comment

01:42.000 --> 01:43.400
section down below.

01:43.400 --> 01:49.200
Depending on how this goes, maybe I'll even create a, I don't know, a Discord chat or a

01:49.200 --> 01:51.120
Slack, not a Slack.

01:51.120 --> 01:52.120
That's a bit too much.

01:52.240 --> 01:54.240
I can just go and shout out whatever.

01:54.240 --> 01:55.240
Okay.

01:55.240 --> 01:57.240
Already, this is too long.

01:57.240 --> 02:04.600
The code for this, or this, given it's a programming series, of course, it's going to be on GitHub.

02:04.600 --> 02:08.640
For item 13.2, all the code is going to be on GitHub, even though for this item, it's

02:08.640 --> 02:13.360
going to be two videos because it's quite a big item, but the code in the repository

02:13.360 --> 02:15.840
will be just under one directory.

02:15.840 --> 02:16.840
Alrighty.

02:16.840 --> 02:24.600
Let's get started with item 13, which states override clone judiciously.

02:24.600 --> 02:29.720
And since we've been on chapter three, this item itself is a part of methods common to

02:29.720 --> 02:31.480
all objects.

02:31.480 --> 02:39.600
So for starters, the very first two sentences of the item states, the cloneable interface

02:39.600 --> 02:46.120
was intended as a mixing interface for classes to advertise that they permit cloning.

02:46.120 --> 02:49.240
Unfortunately, it fails to serve this purpose.

02:49.240 --> 02:55.960
Its primary flaw is that it lacks a clone method and objects clone method is protected.

02:55.960 --> 03:00.640
So when he means and objects clone method is protected, he's talking about the object

03:00.640 --> 03:02.320
superclass in Java.

03:02.320 --> 03:05.080
So firstly, in what I read, there were some keywords.

03:05.080 --> 03:08.640
So let's get some basic theory out of the way.

03:08.640 --> 03:09.960
What is the cloneable interface?

03:09.960 --> 03:15.640
According to Oracle docs, a class implements the cloneable interface to indicate to the

03:15.640 --> 03:16.920
object dot clone.

03:16.920 --> 03:22.640
So the clone method in the object superclass, as I said, method that it is legal for that

03:22.640 --> 03:27.320
method to make a field for field copy of instances of that class.

03:27.320 --> 03:32.400
And then Ganesh Chaudhary of GeeksforGeeks says, the Java line cloneable interface is

03:32.400 --> 03:35.000
a marker interface.

03:35.000 --> 03:36.200
What is a marker interface?

03:36.200 --> 03:43.320
It's really simply means it's an interface that's primarily to add metadata to a class.

03:43.320 --> 03:49.240
So as the name suggests, it marks the class, it indicates to the compiler and even the

03:49.240 --> 03:55.320
programmer that this class is of a certain sort, a certain type with this metadata.

03:55.320 --> 04:01.640
He continues, it was introduced in JDK 1.0, there's a method clone in the object class.

04:01.640 --> 04:07.280
Cloneable interface is implemented by a class to make object dot clone method valid, thereby

04:07.280 --> 04:09.520
making a field for field copy.

04:09.520 --> 04:13.680
Again, as the name suggests, what that simply means is when a cloning takes place, so we

04:13.680 --> 04:20.760
have class with an object, and there's object A that's cloned to, let's say object B, when

04:20.760 --> 04:25.240
the cloning happens, it's a field, all the fields in that class, string int, whatever,

04:25.240 --> 04:29.160
that'd be a field for field copy taking place when the cloning happens.

04:29.160 --> 04:32.080
That's why it's called a field for field copy, obviously.

04:32.080 --> 04:36.920
This interface allows the implementing class to have its objects to be cloned instead of

04:36.920 --> 04:38.640
using a new operator.

04:38.640 --> 04:43.200
So simply a cloneable interface indicates that a class in hand supports cloning.

04:43.200 --> 04:48.760
Now the other keyword in what I read before from the book was the word mixing.

04:48.760 --> 04:53.040
Mixing for me is quite interesting, in fact, because I kind of shifted from the Java world

04:53.040 --> 04:59.760
recently with my new job to the Ruby world, or the Ruby and the Rails world, and mixings

04:59.760 --> 05:04.280
are quite common, or the mix and pattern is quite common in the Ruby world.

05:04.280 --> 05:08.400
Even though I didn't even come across the word when I was programming in Java in my

05:08.400 --> 05:15.160
job, but in a very high level, according to Wikipedia, before we get to the mix and interface,

05:15.160 --> 05:17.280
let's talk about what mixings are.

05:17.280 --> 05:24.320
So Wikipedia says in object-oriented programming languages, a mixin is a class that contains

05:24.320 --> 05:33.760
methods for use by other classes without having to be the parent class of those other classes.

05:34.640 --> 05:41.040
Mixings are sometimes described as being included rather than inherited.

05:41.040 --> 05:43.560
So this is a concept of very common in Ruby.

05:43.560 --> 05:47.480
We have sort of like modules, and you could include modules in classes.

05:47.480 --> 05:54.240
So that allows whatever methods in that module to be included in another separate class,

05:54.240 --> 05:55.240
let's say.

05:55.240 --> 05:59.120
But in the context of Java, we don't really do this kind of including modules and whatnot.

05:59.120 --> 06:02.880
What they simply do is they allow composite interfaces.

06:02.880 --> 06:06.800
Mixings allow composite interfaces, allowing programmers to build modular and extensible

06:06.800 --> 06:12.000
software systems, which is why, here again, it said here, the clone interface was intended

06:12.000 --> 06:16.520
as a mix and interface for classes to advertise that they permit cloning.

06:16.520 --> 06:20.240
Okay, a bit of a demo to understand the concept of mixin.

06:20.240 --> 06:26.320
Now, given Java doesn't have a mechanism to explicitly understand what mixins are, like

06:26.320 --> 06:33.040
Ruby, as I said, we can't need to play around a little bit with multiple classes to get the

06:33.040 --> 06:35.400
idea of what a mixin is.

06:35.400 --> 06:40.240
So in this demo, what we have initially at first is a, initially at first, gosh, what

06:40.240 --> 06:48.640
we have here is an interface called mixin interface, where there are two methods defined.

06:48.640 --> 06:52.440
There's a do something and do something else, two void methods.

06:52.440 --> 06:58.840
And then we have a mixin class that implements this interface and then gives a solid implementation

06:58.840 --> 07:00.680
of these methods.

07:00.680 --> 07:03.640
So we have mixin class and then we have another mixin class.

07:03.640 --> 07:04.640
This is a bit confusing.

07:04.640 --> 07:07.640
I should have called it like class A and class B, but you get there are two classes that

07:07.640 --> 07:13.680
implements the mixin interface, and they have their own kinds of implementations for these

07:13.680 --> 07:15.680
methods.

07:15.680 --> 07:22.480
And then we have a composite class also that implements the mixin interface.

07:22.480 --> 07:28.200
But this class is what does the composition of the other two classes or what those two

07:28.200 --> 07:32.160
methods can do via the mixin interface.

07:32.160 --> 07:39.800
So what that means is this composite class sort of acts as a pseudo module in Ruby.

07:39.800 --> 07:43.480
I'm sorry to incorporate Ruby into this because if you're not familiar with Ruby, you have

07:43.480 --> 07:44.840
no idea what I'm talking about.

07:44.840 --> 07:52.880
But this class would be, yeah, it's what does the, it combines the functionality from the

07:52.880 --> 07:59.080
other two classes into this single class, because it provides different implementations

07:59.080 --> 08:06.880
of the do something and do something else methods in mixin.

08:06.880 --> 08:12.840
And then because it provides separate implementation of the two methods, it can delegate it to

08:12.840 --> 08:17.840
the corresponding methods of the mixin interface, which is what I said before.

08:17.840 --> 08:18.840
But see how this works.

08:18.840 --> 08:24.320
Let's just look at the demo and see how a client would use this composite class to allow

08:24.320 --> 08:25.720
this composition.

08:25.720 --> 08:32.440
So what this composite class allows us is to combine the functionality of two classes,

08:32.440 --> 08:37.840
but then also simultaneously the individual mixing classes can also be used independently

08:37.840 --> 08:38.840
as well.

08:38.840 --> 08:47.120
So we have a mixin one, mixin two, which is firstly of the both of mixin interface type,

08:47.120 --> 08:52.360
but one is the mixin class, the other one is another mixin class, and we have the composite

08:52.360 --> 08:57.280
classes composite one and composite two, although as you can see in the constructor, oh, sorry,

08:57.280 --> 08:58.280
I didn't mention that bit.

08:58.280 --> 09:05.320
So what allows that composition to take place is really the constructor where we have the

09:05.800 --> 09:09.000
private final instance of the mixin interface.

09:09.000 --> 09:16.240
And then what we pass into this can be either mixin class or another mixin class.

09:16.240 --> 09:18.640
So two different classes.

09:18.640 --> 09:20.200
And that's what we're doing in the composition.

09:20.200 --> 09:25.160
We're passing mixin one and then mixin two.

09:25.160 --> 09:28.320
And then in the composite, we can do something, do something else.

09:28.320 --> 09:34.280
And then depending on what we pass into the constructor, the corresponding method will

09:34.280 --> 09:37.320
be invoked on the corresponding class.

09:37.320 --> 09:43.400
So if I run this, you'll see it does firstly from mixin class, do something to something

09:43.400 --> 09:48.240
else, and then it'll run another mixin class, do something differently, do something else

09:48.240 --> 09:49.240
differently.

09:49.240 --> 09:53.080
That's the basic idea of what a mixin interface does.

09:53.080 --> 10:01.280
Probably a bad example, really, because clearly, it's not explicit in Java, but at a high

10:01.280 --> 10:04.600
level, again, it allows composite interfaces.

10:04.600 --> 10:09.560
And then of course, I mentioned the clone method, needless to say, that's probably one

10:09.560 --> 10:12.400
of the most important methods in this item.

10:12.400 --> 10:17.280
The clone method, of course, is a built-in method in Java that allows objects to create

10:17.280 --> 10:18.280
a copy of themselves.

10:18.280 --> 10:24.840
A few things to keep in mind, the clone method is protected, and this potentially becomes

10:24.840 --> 10:26.640
a problem in the future.

10:26.640 --> 10:30.760
The fact that none of them in the future will discuss, in the future of this item will discuss

10:30.760 --> 10:31.760
it.

10:31.760 --> 10:36.080
The idea that the clone method is protective can be a bit annoying, we'll discuss that

10:36.080 --> 10:37.080
later.

10:37.080 --> 10:43.000
But just to get a formal definition, which I really liked, Chagypti's definition.

10:43.000 --> 10:49.240
By the way, the reason that it becomes a problem, can become a potential problem is because

10:49.240 --> 10:53.640
only subclasses can use this method because it's protected.

10:53.640 --> 10:58.960
So again, a formal definition by Chagypti, which I thought was a good one, by default,

10:58.960 --> 11:05.080
the clone method performs a shallow copy of the object, which means that only the objects

11:05.080 --> 11:10.400
fields are copied, but any object references, any object references by those fields are

11:10.400 --> 11:11.400
not cloned.

11:11.400 --> 11:18.160
So for this line here, but any objects references by those fields, perhaps the quintessential

11:18.160 --> 11:20.080
example would be an array.

11:20.080 --> 11:25.960
An array would be a problem if a class has an array declared, because then a shallow

11:25.960 --> 11:31.000
copy wouldn't work as there'll be two objects pointing to the same memory instance of that

11:31.000 --> 11:35.680
array, and that can create corrupted states and cause a problem.

11:35.680 --> 11:38.880
Anyway, I'll continue and we'll get to that later too.

11:38.880 --> 11:43.440
If you want to perform a deep copy of the object where all the objects referenced by

11:43.440 --> 11:47.800
the fields are also cloned, you will need to override the clone method and implement

11:47.800 --> 11:54.080
your own cloning logic, which is why most times this, the latter bit where we do override

11:54.080 --> 12:03.120
it does take place because most classes will most most most classes, I can't talk because

12:03.120 --> 12:07.760
most times most use cases a shallow copy will not suffice when we're probably cloning some

12:07.760 --> 12:08.760
cloning an object.

12:08.760 --> 12:10.320
We need a deep copy.

12:10.320 --> 12:15.680
So to understand the problem, we need to look at it in a bipartite way in the sense that

12:15.680 --> 12:22.440
the first part is that the objects, which is the superclass, the objects clone method

12:22.440 --> 12:25.560
is protected, as I said it here.

12:25.560 --> 12:32.920
And the second problem is the cloneable interface is only a, what's what we use a marker interface

12:32.920 --> 12:36.240
as in it doesn't have any defined clone methods.

12:36.240 --> 12:42.600
So one solution keep in mind potential solution is that we could invoke reflection in Java.

12:42.600 --> 12:45.440
We could invoke the clone method with Java reflection.

12:45.440 --> 12:53.160
Now just your block would not suggest that given that Java reflection can be a bit tricky.

12:53.160 --> 13:00.280
It can leave a lot of objects in corrupt state and cause problems in application on runtime.

13:00.280 --> 13:04.200
So it's primarily used by framework builders.

13:04.200 --> 13:10.320
But simply we've discussed Java reflection in many items before, what it allows us to

13:10.320 --> 13:15.360
program is to dynamically inspect and manipulate objects, classes, interfaces at runtime.

13:15.360 --> 13:22.320
So using reflections as the name suggests, in runtime when objects are created and in

13:22.320 --> 13:27.280
memory, you could reflect within the objects or introspect and then manipulate it and play

13:27.280 --> 13:28.560
around with it.

13:28.560 --> 13:37.000
So a simple example or a simple demo, just to again reiterate and demonstrate what reflection

13:37.000 --> 13:46.600
does is this my class class, I got to get better naming classes, my class class.

13:46.600 --> 13:49.000
This class implements cloneable.

13:49.000 --> 13:54.320
We have a private infield called value, we have a setup, sorry, we have a constructor,

13:54.600 --> 13:59.360
let me have a setter, a getter and afterwards in the implementation or the client using

13:59.360 --> 14:02.200
it, firstly, this will not work.

14:02.200 --> 14:08.480
So if you look here, it's going to throw an error because the clone method is protected.

14:08.480 --> 14:14.400
So you can't just go my object.clone because in the superclass of my object, the clone

14:14.400 --> 14:15.400
method is protected.

14:15.400 --> 14:17.320
So that will not work.

14:17.320 --> 14:22.920
Therefore what we've got to do is resort to using reflection and obviously in reflections

14:22.920 --> 14:30.000
always use a try catch block because reflections have a high potential of throwing exceptions.

14:30.000 --> 14:40.880
And then if I run it, okay, that took a while for me to understand because I had to go through

14:40.880 --> 14:45.520
how the reflections work and trying to make sense of it once again because I wrote this

14:45.520 --> 14:52.200
quite a while back, which is probably another reason as to why unless you really need it

14:52.480 --> 14:57.680
using Java reflections is not a good idea because there's a lot of unexpected things

14:57.680 --> 15:00.360
that can happen, let's say.

15:00.360 --> 15:06.720
So firstly, I'm not going to override the clone method in my class.

15:06.720 --> 15:10.120
So we're going to try and use the clone method in the object class.

15:10.120 --> 15:17.600
Now what happens then is I'm going to leave that bit commented out but I'll comment it

15:17.600 --> 15:24.920
and comment out this bit here, which is trying to access the clone method of the superclass,

15:24.920 --> 15:29.680
which you can see here, I'm getting the clone method and I'm setting it as accessible.

15:29.680 --> 15:36.360
And then when I run this, it should technically or theoretically give an error because it

15:36.360 --> 15:40.760
can't access that because it's a protected method.

15:40.760 --> 15:48.240
So the only way really to do it is to override it in the subclass and then do it like this,

15:48.240 --> 15:54.920
which involves...

15:54.920 --> 16:00.280
Now here you don't have to use reflections even though I've just used it, but that involves

16:00.280 --> 16:05.440
accessing it via the subclass and then doing the cloning as such, which is going to happen

16:05.440 --> 16:06.440
here.

16:06.440 --> 16:12.760
Now of course here again, as I said, you don't need to really do reflections, but the point

16:12.760 --> 16:17.560
being, the overall point of all of this being, and I'm probably going to edit out a bit of

16:17.560 --> 16:21.320
the middle because I spent a long time going through this and then googling trying to figure

16:21.320 --> 16:30.160
out what I did wrong, is that because this pesky cloneable interface, this piece of shit

16:30.160 --> 16:36.880
is not providing us with an implementation for the clone method, that makes things unnecessarily

16:36.880 --> 16:42.160
complicated, which is why Joshua Block states, so what does a cloneable do, given that it

16:42.160 --> 16:48.520
contains no method, it determines the behavior of objects protected clone implementation.

16:48.520 --> 16:55.480
If a class implements cloneable, objects clone method returns a field by field copy of the

16:55.480 --> 17:02.800
object, otherwise it throws clone not supported exception as a low malware is making noise

17:02.800 --> 17:03.800
again.

17:03.800 --> 17:09.760
Now by the way, as we go on with this point, that latter bit, throwing the clone not supported

17:09.760 --> 17:17.960
exception that also becomes a pain point with this interface, we'll discuss it in this item.

17:17.960 --> 17:23.760
And he continues, though the specification doesn't say it, and this is an important point,

17:23.760 --> 17:31.200
in practice, a class implementing cloneable is expected to provide a properly functioning

17:31.200 --> 17:36.600
public clone method, in order to achieve this, this class and all of its superclasses must

17:36.600 --> 17:43.600
obey a complex, unenforceable, thinly documented protocol.

17:43.600 --> 17:50.080
The resulting mechanism is fragile, dangerous and extra linguistic, it creates objects without

17:50.080 --> 17:51.880
calling a constructor.

17:51.880 --> 17:58.840
That really is what a clone method does, if you think about it, for all intents and purposes.

17:58.840 --> 18:02.440
So this begs the question, how to implement a well behaved clone method?

18:02.440 --> 18:06.760
And before we get to the implementing strategy, a few caveats.

18:06.760 --> 18:12.560
Firstly, the cloneable interface is an atypical interface, as interfaces aren't supposed

18:12.560 --> 18:17.920
to modify the behavior of a superclass, but are blueprint for what a given class can do

18:17.920 --> 18:18.920
for its clients.

18:18.920 --> 18:25.240
So really, when you implement the cloneable method in a class, let's say class A, it's

18:25.240 --> 18:30.560
kind of an interface for the object class, for the superclass, which is atypical.

18:30.560 --> 18:32.280
And that again is a problem.

18:32.280 --> 18:38.480
And then also, I wouldn't say it's a problem, it's kind of an anti-pattern, it's something

18:38.480 --> 18:40.600
particularly shouldn't follow.

18:40.600 --> 18:44.680
But also the general contract for the objects clone method is weak.

18:44.680 --> 18:50.040
This is the general contract defined in the Oracle docs, and you can see what it does.

18:50.040 --> 18:55.560
I'm not going to go through it too facetiously, but essentially, the idea is the clone takes

18:55.560 --> 19:04.400
place and it creates in return a copy of the past object, past of that method with a new

19:04.400 --> 19:05.920
memory location.

19:05.920 --> 19:13.000
Now, it is vaguely similar to constructor chaining, a pattern, a design pattern, which

19:13.000 --> 19:16.440
allows to create less duplicated code.

19:16.440 --> 19:21.080
But more than me explaining it, let's take a look at what constructor chaining entails

19:21.080 --> 19:27.120
if I open up the class customer.

19:27.120 --> 19:28.320
It's quite a straightforward pattern.

19:28.320 --> 19:31.440
You probably have seen it in a lot of code in the Java world.

19:31.440 --> 19:36.080
We have a class customer that extends the superclass person.

19:36.080 --> 19:41.800
So all the customers are people, at least for now.

19:41.800 --> 19:48.000
And then in constructor chaining, we have the customer class being constructed, that

19:48.000 --> 19:49.840
the object being created.

19:49.840 --> 19:55.880
And we will see as some fields are just inherited directly from the superclass, things like

19:55.880 --> 19:59.080
first name, middle name, last name, age.

19:59.080 --> 20:06.440
And then only this field here, the loyalty card ID, is constructed in this constructor

20:06.440 --> 20:09.040
and that field value is set.

20:09.040 --> 20:15.240
So the way this reduces duplication of coders, let's say if we didn't have this kind of constructor

20:15.240 --> 20:21.680
chaining, this same bit of code here will have to be replicated in this constructor

20:21.680 --> 20:23.160
too.

20:23.160 --> 20:26.480
And that would be a waste of space.

20:26.480 --> 20:32.760
And so by invoking the super keyword and then passing it into the superclass constructor,

20:32.760 --> 20:34.400
this allows the supercoded code.

20:34.400 --> 20:39.720
However, the problem is this kind of pseudo constructor chaining isn't enforced in the

20:39.720 --> 20:40.720
clone method.

20:40.720 --> 20:48.160
So if you'd look at our person customer example, if you mess up the construction here in the

20:48.160 --> 20:52.040
constructor, the compiler will throw an error.

20:52.040 --> 20:58.240
But in this example, which I have, which is a class called food that implements cloneable,

20:58.240 --> 21:01.680
it's overriding the clone method.

21:01.680 --> 21:05.560
And then this class bar extends the food class.

21:05.560 --> 21:08.640
So that's a subclass of food.

21:08.640 --> 21:15.600
And it also is trying to override the clone method of food, of the superclass, but what

21:15.600 --> 21:20.640
happens there is in our track catch block when we run it, it's going to throw an error.

21:20.640 --> 21:29.040
The reason is because the superclass, which is food, is not, it doesn't call the super.clone,

21:29.040 --> 21:34.560
so the objects clone method, rather it's just creating a new instance of food and passing

21:34.560 --> 21:35.560
that.

21:35.560 --> 21:40.000
And that creates errors here because it's on a proper clone taking place.

21:40.000 --> 21:43.600
And because now this error is thrown in runtime.

21:43.600 --> 21:47.480
So if it was in foes, we would catch this error in compile time.

21:47.480 --> 21:48.480
And that's a problem.

21:48.640 --> 21:52.400
However, though, of course, final classes don't have to worry about this problem of it being

21:52.400 --> 21:57.520
not in foes because they will not implement cloneable as they won't be cloned.

21:57.520 --> 22:02.440
So to put it a bit more clearly, Joshua Block states, this mechanism is vaguely similar

22:02.440 --> 22:06.080
to constructor chaining, except that it isn't in foes.

22:06.080 --> 22:12.520
If a classes clone method returns an instance that is not obtained by calling superart clone,

22:12.520 --> 22:24.480
like the problem which we see here, where the superclass foo is not calling super.clone,

22:24.480 --> 22:29.880
but by calling a constructor, which the person is doing here, the compiler won't complain.

22:29.880 --> 22:35.200
But if a subclass of that class calls super.clone, the resulting object will have the wrong class

22:35.200 --> 22:42.320
preventing the subclass from clone.

22:42.320 --> 22:45.400
That's a complicated, weird way of putting it in the sentence.

22:45.400 --> 22:50.320
Those resulting objects will have the wrong class preventing the subclass from clone method

22:50.320 --> 22:51.840
from working properly.

22:51.840 --> 22:55.320
That's like a weird way that he's written the sentence.

22:55.320 --> 22:59.960
In any case, the learning strategy, the simplest thing at first to do is to call the super

22:59.960 --> 23:04.400
dot clone method because that will return an object which is a fully functional replica

23:04.400 --> 23:05.400
of the original.

23:05.400 --> 23:10.920
And if all fields of the class, so in the class you're designing, if all the fields contain

23:10.920 --> 23:16.800
primitive values or reference to an immutable object, no further processing is needed.

23:16.800 --> 23:22.160
As Joshua Block states, any field declared in your class will have values identical to

23:22.160 --> 23:23.720
those of the original.

23:23.720 --> 23:28.560
If every field contains a primitive value or a reference to an immutable object, the

23:28.560 --> 23:31.280
return object may be exactly what you need.

23:31.280 --> 23:35.960
So you don't need to play around with it in your clone method, in your overwritten clone

23:35.960 --> 23:39.720
method, in which case no further processing is necessary.

23:39.720 --> 23:45.600
And he also continues, but note that immutable classes should never provide a clone method

23:45.600 --> 23:48.880
because it would merely encourage wasteful copying.

23:48.880 --> 23:52.800
So an immutable class would be classes where the fields are all final and the class itself

23:52.800 --> 23:55.680
is declared with a final keyword.

23:55.680 --> 24:00.840
And a simple example of this idea is this phone number class where in the phone number

24:00.840 --> 24:07.960
class we have a clone method, it's simply invoking, not invoking invoking the super

24:07.960 --> 24:12.120
dot clone method which is the clone method of the object class and of course doing the

24:12.120 --> 24:18.000
casting so that what's returned by this method is something of type phone number.

24:18.000 --> 24:22.720
And the reason we can do this in a straightforward manner with the casting is because Java does

24:22.720 --> 24:30.120
support covariant return types as he states here, it is legal and desirable to do this

24:30.400 --> 24:33.880
because Java supports covariant return types.

24:33.880 --> 24:36.280
So what are covariant return types in Java?

24:36.280 --> 24:41.240
Firstly, let's understand the theory behind the concept of covariance.

24:41.240 --> 24:49.040
According to Baldung, covariance can be considered as a contract for how a subtype is accepted

24:49.040 --> 24:52.120
when only the super type is defined.

24:52.120 --> 24:58.080
And another definition is covariance means we can access specific elements defined by

24:58.080 --> 24:59.080
the super type.

24:59.080 --> 25:03.520
However, we aren't allowed to put elements into a covariant system since the compiler

25:03.520 --> 25:07.360
would fail to determine the actual type of the generic structure.

25:07.360 --> 25:12.360
I know that's a bit too formal and abstract but simply what it means is a subclass can

25:12.360 --> 25:14.320
override the methods of a superclass.

25:14.320 --> 25:19.200
So in our case a phone number, phone number can override the method of the object class

25:19.200 --> 25:27.960
which is the clone method and afterwards when it returns it can return something or an object

25:27.960 --> 25:32.080
not something, an object of type of the subclass.

25:32.080 --> 25:34.240
So it will not return.

25:34.240 --> 25:40.080
So the phone number clone method will not return an object of type object instead it

25:40.080 --> 25:42.520
will return an object of type phone number.

25:42.520 --> 25:48.760
Now if we didn't have the idea of covariance and if Java didn't have covariant return types

25:48.760 --> 25:50.920
this would be the implementation necessary.

25:50.920 --> 25:52.920
We'll have to do the casting as a client.

25:52.920 --> 25:58.480
So when the client uses the phone number class and uses the clone method that we initially

25:58.480 --> 26:04.480
defined we will have to do the casting as a client and because of covariance this is

26:04.480 --> 26:06.040
not required.

26:06.040 --> 26:09.800
Simply that will suffice and work fine.

26:09.800 --> 26:13.000
So to further understand covariance so let's look at this demo.

26:13.000 --> 26:18.600
We have a class vehicle which starts an engine and then we have a class car that extends

26:18.600 --> 26:19.600
vehicle.

26:19.600 --> 26:25.520
We also have a class motorcycle that extends vehicle and these two have their own implementations

26:25.520 --> 26:28.080
of the start engine method.

26:28.080 --> 26:33.040
Now if we run this code what you'll see is we're first starting the vehicles engine,

26:33.040 --> 26:37.520
the superclasses engine and then we're starting the cars engine and the motorcycles engine.

26:37.520 --> 26:44.720
So in starting this engine the objects return even though we're calling the same start method

26:44.720 --> 26:49.320
and the overriding is taking place in the subclasses.

26:49.320 --> 26:56.000
The return type is of type this which means it can return an object of type car or in

26:56.000 --> 27:02.360
this case an object of type motorcycle and over here no casting is necessary.

27:02.360 --> 27:07.840
For example over here if we do this, this would be redundant and the compiler would

27:07.840 --> 27:12.720
say what are you doing mate, it'll in fact throw an error, sorry I wouldn't throw an

27:12.720 --> 27:18.280
error, I'm just being silly, it would show that it's redundant, it's useless.

27:18.280 --> 27:20.880
So remove redundant cast because you don't need to do that casting.

27:20.880 --> 27:25.440
So the next point is the clone not support exception should have been an unchecked runtime

27:25.440 --> 27:26.440
exception.

27:26.440 --> 27:31.640
Now I think I did discuss this in the beginning of the video but here's the problem.

27:31.640 --> 27:34.240
So firstly let me read from the book.

27:34.240 --> 27:38.460
The code to support our clone is contained in a try catch block.

27:38.460 --> 27:46.000
This is because object declares its clone method to throw clone not support exception

27:46.000 --> 27:49.100
which is a checked exception.

27:49.100 --> 27:53.060
Because phone number implements cloneable we know the code to support our clone will

27:53.060 --> 27:54.060
succeed.

27:54.060 --> 27:59.260
The need for this boilerplate code indicates that clone not support exception should have

27:59.260 --> 28:01.780
been unchecked.

28:01.780 --> 28:05.540
So the problem is because we know across that implements a clone method it's going to implement

28:05.540 --> 28:11.060
the cloneable interface the checked exception won't be thrown which makes this code here

28:11.060 --> 28:15.980
the try catch block superfluous redundant code and it's unnecessary.

28:15.980 --> 28:20.020
Okay now what we're going to try and do is look at the stack class so a bit more high

28:20.020 --> 28:25.140
level view at how the clone method is implemented and the stack class is defined well it was

28:25.140 --> 28:32.180
initially defined in item 7 but we've repurposed it to fit to item 13 and this is really important

28:32.180 --> 28:37.500
because here's why really we need to consider this point as to how do we deal with object

28:37.500 --> 28:42.980
fields or class fields that refer to mutable objects because a simple clone implementation

28:42.980 --> 28:49.380
won't work for such cases such as why in our classes we need to override the clone implementation

28:49.380 --> 28:59.220
of object specially for fields that are mutable or fields that refer to mutable fields pardon

28:59.220 --> 29:05.580
me not mutable fields are mutable objects or data structures and in this case the again

29:05.580 --> 29:11.500
that perhaps a quintessential example would be an array for an array we need to recursively

29:11.500 --> 29:16.860
copy all the elements of the mutable field like an array to solve the problem of destroying

29:16.860 --> 29:22.020
or destroy invariants we don't have we don't want to have arrays in two different states

29:22.020 --> 29:26.620
where we have two objects so we have object A and an object B that was copied of object

29:26.620 --> 29:32.460
A both pointed to the same array that could create corrupt states and that's what we see

29:32.460 --> 29:39.260
in this stack class so this is fine this integer size is fine this is fine especially because

29:39.260 --> 29:47.300
it's final however the objects object array called elements this in our clone method

29:47.300 --> 29:52.380
we need to change it up a bit so as you can see here we are firstly doing the normal cloning

29:52.460 --> 29:59.580
in the super dot clone and then we're specifically cloning all the elements recursively in elements

30:00.620 --> 30:06.140
and then setting it to result so the new object dot elements and then returning that so what we

30:06.140 --> 30:12.460
do here is we in fact create two array instances so to reiterate that point I think it's important

30:12.460 --> 30:20.460
because he's in this part of this item this is the take home point is that when we do the cloning

30:20.460 --> 30:28.060
it can't just be a dumb clone of all the fields a field for field clone if there are let's say

30:28.060 --> 30:33.180
things like arrays which point to other immutable objects because what's going to happen then then

30:33.180 --> 30:37.500
is we're going to destroy the invariance of this clone method where both objects are going to point

30:37.500 --> 30:43.420
to the same array and that's going to corrupt that array where as clients use these objects it'll

30:43.420 --> 30:49.100
either throw not point exceptions or give nonsensical results and this situation as

30:49.180 --> 30:53.100
Joshua block I said earlier which I will read will not happen in a constructor clone method in

30:53.100 --> 30:57.740
many ways acts like a constructor because it's really constructing a new object now this thing

30:57.740 --> 31:02.780
we've defined here will not happen in a typical constructor because we aren't copying things across

31:02.780 --> 31:08.620
in a constructor which is why Joshua block states this situation by the way I shouldn't say this

31:08.620 --> 31:14.700
situation here because what we've done here is correct in fact let's say hypothetically we didn't

31:14.700 --> 31:19.580
do this now this would destroy the invariance of this clone method but here this is correct

31:21.020 --> 31:27.500
so this is not bad code anyways continue this situation could never occur as a result of calling

31:27.500 --> 31:34.060
the sole constructor in the stack class in effect the clone method functions as a constructor you

31:34.060 --> 31:40.140
must ensure that it does no harm to the original object and that it properly establishes invariance

31:40.140 --> 31:47.420
on the clone so yes if we didn't do this what will happen is we'll have object a and then object b

31:47.420 --> 31:53.500
cloned off object a and then if someone messes around with object b in the the elements array

31:53.500 --> 31:58.940
then object a will also be affected because they are both pointing to the same array and that's

31:58.940 --> 32:05.340
the problem we're trying to solve here really if if you get this point from this whole video elaborate

32:05.340 --> 32:11.100
video you get this part of what i'm trying to convey here and then to end this part of the item a

32:11.100 --> 32:16.620
few note of bennets the first one is you probably noticed we aren't doing any casting like this

32:16.620 --> 32:22.940
in this clone method it's not required because in fact this is the only time really uh it's

32:22.940 --> 32:29.180
ideal to simply for an array when i mean the only time it's ideal to use uh the clone method directly

32:29.180 --> 32:34.860
in the superclass object the Joshua block states calling clone on an array returns an array whose

32:34.860 --> 32:42.220
runtime and compile time types are identical to those of the array being cloned this is the preferred

32:42.220 --> 32:48.620
idiom to duplicate an array in fact in fact arrays are the sole compelling use of the clone facility

32:48.620 --> 32:54.460
and the other point is recursively calling the clone method will not work for final fields for

32:54.460 --> 33:02.700
example if let's say uh private final object element so if we go here and if we set this to be final

33:03.180 --> 33:08.380
you'll see an array is going to be thrown here because you can't override the values uh in a final

33:08.380 --> 33:15.420
field uh or overwrite all the values the memory instance in a final field and that's because

33:15.420 --> 33:21.580
uh as Chajipiti states in order to create a proper deep clone you must create a new instance of the

33:21.580 --> 33:27.020
mutable object and assign it to the field in the clone object however with a final field you

33:27.740 --> 33:33.420
can't reassign a new value after initialization which can lead to incorrect behavior or shared

33:33.420 --> 33:39.900
state between the original object and it's cloned and then to end this part of the video this is a

33:39.900 --> 33:46.700
fundamental problem like serialization uh in the cloneable architecture because the cloneable

33:46.700 --> 33:51.180
architecture is the is incompatible with normal the use of final fields referring to mutable

33:51.180 --> 33:56.380
objects except in cases where the mutable objects may be safely shared between an object

33:56.380 --> 34:02.540
and its clone in order to make a class cloneable it may be necessary to remove final mortifiers

34:02.540 --> 34:07.980
from some fields so that's a little caveat there okay that is part one uh just want to

34:07.980 --> 34:15.100
I guess kind of apologize if I didn't properly convey the this part here about the reflections

34:15.100 --> 34:20.140
because that was it did complicate me a little bit because at first the way I've written the code

34:20.140 --> 34:26.780
the demo it wasn't really accurate because the idea was to reflect on the object superclass not to

34:26.780 --> 34:35.180
reflect on the object at hand per se but I think it's still the important point there was it's not

34:35.820 --> 34:41.260
recommended to use reflections and try to use the object the superclass objects clone method

34:41.820 --> 34:46.220
best thing to do is to implement the cloneable interface and then just override it and define

34:46.220 --> 34:53.340
your own clone method all righty that's it for part one of item 13 override clone judiciously

34:53.340 --> 35:00.060
judiciously it's a hard word to pronounce um and I hope I was being judicious in expanding and

35:00.060 --> 35:06.220
explaining the concepts in this item but I shall continue on with the rest of this item in part two

35:07.340 --> 35:11.580
uh saying all that yeah thanks for watching and I hope you got some value from it I'll see you in the

35:11.580 --> 35:15.580
next one cheers

