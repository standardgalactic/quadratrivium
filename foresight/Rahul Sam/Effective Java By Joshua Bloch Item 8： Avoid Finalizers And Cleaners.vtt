WEBVTT

00:00.000 --> 00:06.800
Hey everyone, welcome to yet another episode of my video series on Joshua Block's Effective Java,

00:06.800 --> 00:12.160
where I take the items that he has enumerated in this book and expound on them, trying to make

00:12.160 --> 00:18.080
sense of them. And hopefully, as I do that, you can gain some value from it too. You can

00:18.080 --> 00:23.280
hopefully learn something from it. That at least is one reason that I put out these videos

00:23.280 --> 00:28.960
out in the public. Without further ado, let me get started. This is certainly one of the longest

00:28.960 --> 00:34.400
items that I had to go through and probably going to be the longest video of this series as of yet.

00:35.120 --> 00:40.160
In fact, I was thinking if I should break this down into two videos because the video might be

00:40.160 --> 00:46.720
too long. In any case, let's get started with the proviso. I've been doing this proviso slash

00:46.720 --> 00:51.600
instruction in every single video. So if you have been following along, please do skip this bit to

00:51.600 --> 00:56.720
save your time. The first point in the proviso is of course, and it's a very important point,

00:56.720 --> 01:04.080
this is not a tutorial. I'm not a teacher, nor am I an expert. Therefore, don't think of what I say

01:04.080 --> 01:08.720
as gospel's truth. In fact, when I do make mistakes, I'll try and correct them down

01:08.720 --> 01:14.560
during the comment section. And as I've said in the second point, think of this as the blind,

01:15.120 --> 01:21.120
leading the blind. This is purely an exploratory disposition. I'm trying to figure something

01:21.120 --> 01:30.160
out publicly and in a very, let's say, what's what I'm looking for. I'd say thinking out loud,

01:30.160 --> 01:35.200
trying to make sense of these items, not just in the videos itself, but even preparing for them

01:35.200 --> 01:41.680
as I post questions on Stack Overflow, as I try to involve the community. I feel like hopefully,

01:41.680 --> 01:46.240
you know, I'm adding some value into the programming community, the Java community,

01:46.240 --> 01:51.760
by asking certain questions pertaining to this book, as I'm trying to learn, which is why I call

01:51.760 --> 01:57.840
it an exploratory disposition. It's a collective endeavor. And as I did touch on a bit before,

01:57.840 --> 02:04.320
I will inevitably make mistakes. So please point them out, not just for my sake, perhaps even more

02:04.320 --> 02:12.160
for the sake of the viewers, because I certainly don't want to mislead them by sharing any misinformation

02:12.160 --> 02:18.080
to use a politically overloaded term. And of course, as this is a programming video series,

02:18.080 --> 02:24.720
all the code is available on GitHub, not just mine, but even Joshua Bloch's public repository

02:24.720 --> 02:30.880
where he's published the code that he's used for this book. Saying all that, let us get started

02:30.880 --> 02:36.640
with item number eight, which, as I said, is a long one. There are a few concepts that I had to

02:37.440 --> 02:44.560
sort of think about and muse and reflect for a bit to get my head around. But it was a very

02:44.560 --> 02:49.520
interesting item as I found all the items in this book. And especially if you're a Java fan, like

02:49.520 --> 02:57.280
myself, for all, even though I don't program in Java in my day job anymore, Java is my first love

02:57.280 --> 03:05.120
venue. Never forget your first one, isn't it? I'm sorry, that was pathetic, but I can't help myself.

03:05.120 --> 03:11.360
Okay, item number eight, avoid finalizers and cleaners. And we're still in chapter two,

03:11.360 --> 03:18.160
creating and destroying objects. And again, as I said, all the code available on my GitHub repo,

03:18.720 --> 03:23.440
links down below in the description. And I've kind of added like this, another caveat here.

03:24.000 --> 03:28.640
This item does have a lot of theory. So before we get into the code, which of course I have

03:29.360 --> 03:34.720
right here, before we get into any of this code, I think it's important to get through some theory.

03:36.400 --> 03:43.040
Just in general, I prefer doing that to get a conceptual understanding. But specifically this

03:43.040 --> 03:48.800
item, I think has a lot more theory. So as I normally do, let's look at some keywords here.

03:48.800 --> 03:54.240
Avoid finalizers and cleaners. What the hell are finalizers and cleaners? Full disclosure,

03:54.240 --> 04:00.000
I've never used a finalizer nor a cleaner. A cleaner, yes, but I've never used a finalizer

04:00.800 --> 04:06.080
in my day job when I used to do a lot more hands-on Java programming. But here are a few

04:06.080 --> 04:13.360
definitions that I found on finalizers. In fact, they're from Baildang, my favorite Java

04:14.240 --> 04:21.920
learning blog slash website. And then of course, the Oracle docs. So finalizers, the,

04:24.400 --> 04:28.720
sorry, I had to think about that just for a bit. I didn't want to mindlessly read out the definition.

04:28.720 --> 04:33.440
Essentially, I mean, finalizers is simply a method we're talking about, which is in the

04:33.440 --> 04:39.360
object class, which the, in the class hierarchy in Java, the object class is right at the top. So

04:39.360 --> 04:48.240
everything is a subclass of object Java, FII. The finalize method for all intents and purposes

04:48.240 --> 04:55.120
is what we call the finalizer. Even though finalizers is more like a mechanism. And Baildang states

04:55.120 --> 05:02.880
finalizers get involved when JVM figures out that this particular instance should be garbage collected.

05:03.120 --> 05:11.280
So when the JVM understands that a certain object or an instance of a class is ready to be

05:11.280 --> 05:19.200
garbage collected, it can be involved, this finalized method. Such a finalizer may perform

05:19.200 --> 05:25.680
any operations, including bringing the object back to life. That bit, full disclosure, I don't

05:25.680 --> 05:30.960
understand. I didn't really go into detail as to what it means bringing the object back to life.

05:31.920 --> 05:36.560
Perhaps it's referring to the object later again in the code and then, you know,

05:36.560 --> 05:42.400
allocating memory to it. But even in the item, Joshua Block hasn't really got into what that

05:42.400 --> 05:48.720
means. This is just a definition from Baildang. The main purpose of a finalizer is, however,

05:48.720 --> 05:55.920
to release resources used by objects before they're removed from memory. A finalizer can work as a

05:55.920 --> 06:01.600
primary mechanism for cleanup operations or as a safety net when other methods fail.

06:01.600 --> 06:09.280
So at a very high level, just a good bit of start is to think of finalizers being related to

06:10.080 --> 06:16.000
memory management and garbage collection. It's not something particularly done by the JVM.

06:16.000 --> 06:22.800
Programmers could do it too, explicitly. But of course, a caveat is we should in fact avoid

06:22.800 --> 06:27.920
using finalizers and cleaners. That is the caveat here. So even though it's possible,

06:27.920 --> 06:35.360
doesn't mean we should do it. So again, to repeat the point, think of finalizers as something that

06:35.360 --> 06:42.240
relates to memory management and garbage collection and ensuring that any unreferenced

06:42.240 --> 06:48.640
objects are cleaned and that resources are freed up. And then another definition again from the

06:48.640 --> 06:54.880
Oracle docs this time is, as I said, finalize is part of the object class. If you go take a look

06:54.880 --> 07:02.000
at the docs, it'll even state, if only my internet loads, it'll even state the finalize method is

07:02.000 --> 07:09.360
there. As you can see there, it'll say they're called by the garbage collector on an object

07:09.360 --> 07:14.000
when garbage collection determines that there are no more references to the object.

07:14.000 --> 07:25.760
The general contract of finalize is that it is invoked if and when the Java virtual machine

07:25.760 --> 07:32.560
has determined that there's no longer any means by which this object can be accessed by any thread

07:32.560 --> 07:38.640
that has not yet died, except as a result of an action taken by the finalization of some other

07:38.640 --> 07:45.200
object or class which is ready to be finalized. So, okay, effectively this means when the object is

07:45.200 --> 07:51.600
not going to be used, we need to free up that resource and get that memory back to be used

07:51.600 --> 07:59.280
for something else. That's what finalize is. But, again, we shouldn't use them. That's the point

07:59.280 --> 08:04.640
Joshua Book is trying to make. Okay, so the first keyword finalize is we've got a very high level

08:04.640 --> 08:09.200
conceptual understanding of what it is. Let's take a look at what cleaners are, which is kind of like

08:09.200 --> 08:18.400
an evolution of finalizers and is perhaps a bit safer to use, even though that too should try and

08:18.400 --> 08:29.120
be avoided ideally. Once again from the, so cleaner is in fact, let me open it up. It's an interface.

08:29.520 --> 08:41.120
Sorry. Sorry, I meant to say cleaner is a subclass of object. I was thinking of auto-closable,

08:41.120 --> 08:48.640
which is an interface. We'll talk about that later on. And the definitions for the cleaner is,

08:48.640 --> 08:56.720
again, by the Oracle docs. Cleaner manages a set of object references and corresponding cleaning

08:56.720 --> 09:02.400
actions. Cleaning actions are registered to run after the cleaner is notified that the object has

09:02.400 --> 09:07.680
become phantom reachable. So what is phantom reachable? I did discuss this in the previous

09:09.040 --> 09:14.160
item, item number seven. I'm not going to go into too much detail, because you could just

09:14.160 --> 09:21.040
watch that video. But phantom reachable is when an object has no strong soft or weak references,

09:21.600 --> 09:29.600
but at least one phantom reference. So this kind of has to do with how the JVM algorithms,

09:29.600 --> 09:36.240
or how garbage collection algorithms, decide if a certain object has to be, or can be garbage

09:36.240 --> 09:43.760
collected. So basically, strong objects can never be garbage collected. And then it's sort of the,

09:44.800 --> 09:48.960
there's like a cascading effect, not a cascading effect, there's like a triaging process where

09:48.960 --> 09:53.280
it goes from strong, soft, weak, and then the lowest one is a phantom reference.

09:54.000 --> 10:00.880
Read this document by Bialdown, which goes into detail, of course, linked to this in the

10:00.880 --> 10:05.520
description too, for more context. I'm not going to go into detail because it's sort of out of

10:05.520 --> 10:10.720
scope for this item. And as I've said here, these delineate when objects can be garbage

10:10.720 --> 10:17.520
collected. That's what phantom references do. And with cleaners, cleaners are used when an object

10:17.600 --> 10:23.600
has become phantom reachable. That's how it relates. And then another definition from

10:23.600 --> 10:32.320
inside Java by Roger Riggs is, unlike a finalizer, a cleanup function holds the state needed for

10:32.320 --> 10:37.280
cleanup separately from the object because we want the object to be reclaimed as soon as it is

10:37.280 --> 10:43.360
unreachable. When it states, when it states reclaiming an object, what that really means is

10:43.440 --> 10:49.760
freeing up memory. So we can use it for something else. The cleanup function must be able to work

10:49.760 --> 10:55.200
independently from the object. It's correct. It should be able to run on a separate thread for

10:55.200 --> 11:00.080
instance. And that does happen. We shall see an example. If there are any references to the object

11:00.080 --> 11:03.520
from the cleanup function, it would still be reachable and could not be reclaimed.

11:04.080 --> 11:09.440
Any state needed for the cleanup must be encapsulated in the cleanup function.

11:09.920 --> 11:17.680
What does that mean? I believe what this means is, when the cleanup does take place, so a quick

11:17.680 --> 11:26.800
peek in the code, let's say the cleanup happens. Let's say this close method. This is a bit different.

11:26.800 --> 11:33.040
Ignore all this. But the state of an object should be local to the state of an object.

11:33.520 --> 11:39.440
When the cleanup is taking place. I believe that's what it means. It's encapsulated within this

11:39.440 --> 11:44.400
method. Ignore all this, but it's a really sub-art context, but we shall get this code a bit later.

11:46.640 --> 11:54.160
Okay, now we get to the items, what Joshua Block has stated in the item in the book. And the first

11:54.160 --> 12:00.400
thing is, the first thing we need to do is, we need to take a look at the state of an object.

12:00.720 --> 12:05.440
And the first thing is, he's kind of talking to C++ programmers.

12:07.360 --> 12:16.160
And a point he wants to make salient and very clear is that finalizers or cleaners are not

12:16.160 --> 12:24.160
the same as destructors in C++. Now, obviously, because C++, I'm not a C++ programmer in any way,

12:24.720 --> 12:30.080
I've probably written like 10 lines of C++ code in my life, probably a bit more than that.

12:30.080 --> 12:36.320
I did do a unit, a data structure and a patterns unit back in uni, which was a, which was in C++.

12:37.040 --> 12:43.840
And obviously, so because C++ doesn't have automatic memory management or garbage cleaning,

12:43.840 --> 12:51.360
we need to do it ourselves, the programmer. So I believe it's done through destructors.

12:52.240 --> 12:59.120
Take what I say with a great assault. Maybe they'd rather us do it. But one way it is done in C++,

12:59.120 --> 13:05.760
probably the most popular way is using destructors and Joshua Block and once we make it clear

13:06.400 --> 13:12.000
that cleaners and finalizers are not the same as destructors. And here's what he states.

13:14.320 --> 13:20.640
Finalizers are unpredictable, often dangerous and generally unnecessary. I shall also discuss

13:20.640 --> 13:26.400
that bit about them being unpredictable or non-deterministic as to why that's a huge

13:26.400 --> 13:33.600
risk when programming as we go into the item. And then he states, as of Java 9,

13:33.600 --> 13:39.200
this is an important point, finalizers have been deprecated, but they are still being used by the

13:39.200 --> 13:46.800
Java libraries. The Java 9 replacement for finalizers is cleaners. Cleaners are less dangerous

13:46.800 --> 13:53.040
than finalizers, but still unpredictable, slow and generally unnecessary. So this, which is why

13:53.040 --> 13:59.600
we should be avoiding avoiding old finalizers and cleaners. So despite having the caveat that

13:59.600 --> 14:06.080
finalizers and cleaners aren't the same as destructors, he states, or he continues,

14:06.080 --> 14:14.320
C++ destructors are also used to reclaim other non-memory resources. In Java,

14:14.320 --> 14:20.720
a try with resources or try finally block is used for this purpose. And then he continues,

14:20.720 --> 14:26.000
one shortcoming of finalizers and cleaners is that there's no guarantee they'll be executed

14:26.000 --> 14:29.520
promptly. Yes, before I read that, I need to go through the notes that I took down.

14:31.680 --> 14:35.680
So I had to go through the code base a bit and read up again, because I wrote this a while back

14:35.680 --> 14:41.360
and I've forgotten some bits as to how it's all going to come together. In fact,

14:42.320 --> 14:49.040
by my struggle to demo this, to demonstrate this problem, is in many ways the point

14:49.040 --> 14:53.680
Joshua Block is trying to make that it is non-deterministic. I can't exactly show the problem

14:53.680 --> 14:59.040
with finalizers because due to it's, it's not deterministic. And in programming, you'd expect

14:59.040 --> 15:06.320
code to be deterministic and causal. The big problem with using cleaners and finalizers is

15:06.320 --> 15:12.640
firstly that we aren't sure when the garbage collection will take place. We don't, we aren't

15:12.640 --> 15:22.000
sure when the, when GC will run and JVM can do it, which will be anytime it wants. Even though

15:22.000 --> 15:28.400
it is possible, as I will show in a bit, for us to explicitly run a GC or a garbage collection

15:28.400 --> 15:33.520
cycle, it is not, it's ill-advised. One shouldn't, one shouldn't do this. There are many other side

15:33.520 --> 15:42.560
effects that can affect the program. And it's possible that the finalizer thread, so the thread

15:42.640 --> 15:48.800
where the closing of the objects taking place can be of low priority that can lead to an

15:48.800 --> 15:52.640
out-of-memory error. Because some other threads would run, take up all the memory and when this

15:52.640 --> 15:59.120
thread runs, that can throw an out-of-memory error. Even, and then there's again another caveat that

15:59.120 --> 16:06.640
cleaners in fact do run in the background. And the garbage collection is controlled by the class

16:06.640 --> 16:12.720
itself. The class owns that garbage collection. However, there still is a problem of it not

16:12.720 --> 16:18.640
being, of it not running promptly. Sorry, I made a mistake there. The garbage collection doesn't

16:18.640 --> 16:24.960
have, sorry, the class doesn't have control of the garbage collection, but it has control of its

16:24.960 --> 16:32.240
own threads, which we shall see because we use a runnable interface. And nevertheless, it still

16:32.240 --> 16:41.840
does not guarantee the promptness. And due to the non-determinism in both cleaners and finalizers.

16:41.840 --> 16:48.880
Now I'll quickly show what the hell finalizer even is, because there isn't really a proper example

16:48.880 --> 16:55.600
given in the book. I found an example courtesy of Byle Dunn. But before I show the code base,

16:56.160 --> 17:03.920
let's go through some something a bit more, let's say, clear. And I try to be a bit more

17:04.880 --> 17:09.600
explicit as to what Joshua Block has written here, because I think I didn't do a good job at

17:09.600 --> 17:16.800
explaining that. Here's what he states. One shortcoming of finalizers and cleaners is that

17:16.800 --> 17:21.440
there is no guarantee they'll be executed promptly. It can take arbitrarily a little

17:21.440 --> 17:27.120
between the time that an object becomes unreachable and the time its finalizers or cleaners run.

17:28.640 --> 17:34.080
This means that you should never do anything time critical in a finalizer or cleaner.

17:37.040 --> 17:43.600
The promptness with which finalizes and cleaners executed is primarily a function of the garbage

17:43.600 --> 17:47.920
collection algorithm, which varies widely across implementations.

17:51.680 --> 17:59.040
So what does that mean? The thing is, even after the finalizer runs, a GC still has to run in the

17:59.040 --> 18:05.280
background, clear up resources, clear up memory. But before we get to the idea of the promptness,

18:05.280 --> 18:10.640
let's take a look at what the hell a finalizer even is. So I was going through this example,

18:11.360 --> 18:15.280
as I said, courtesy of Violet Dung, and let me try to open up that

18:17.520 --> 18:21.440
article if I could find it. This one right here.

18:23.680 --> 18:29.040
It was this article that he wrote, and he's just given a background as to what finalizers are.

18:29.680 --> 18:35.120
Even though in the article S it goes, it does say why you shouldn't use it. It talks about

18:36.080 --> 18:40.160
why we should take care of garbage collection, because JVM knows better, in fact.

18:42.960 --> 18:48.720
And I have this class called Finalizable, and I have an instance, a buffered read instance.

18:50.160 --> 18:57.120
And then the constructor, what I'm doing is reading a file, getting an input stream, and then

18:57.200 --> 19:03.760
saving a new buffered read instance in this private variable of declared,

19:04.880 --> 19:12.800
class variable of declared here. And it does specify from the specified class part,

19:13.440 --> 19:20.720
from some nature quotes. And here we have a method called ReadFirstLine, which reads from the first

19:20.720 --> 19:29.280
line. So if this works as expected, it should read without music, life would be a mistake

19:29.280 --> 19:38.320
by Mr. Nietzsche, and I very much agree. And then once we have this instance created, we need to

19:38.320 --> 19:44.400
clean it. We need to finalize it. And here's where, sorry, we need to close it, apologies.

19:44.400 --> 19:48.320
And here's where the problem occurs. Now, once we have this reader, the buffered instance reader,

19:48.400 --> 19:52.720
which we declared here, it's used, we do the reading, whatever, and then it's used,

19:52.720 --> 19:57.120
and then we're done with it. We need to use a finalized method, which, as you can see,

19:57.120 --> 20:01.120
is deprecated. The IntelliJ does specify that, that is deprecated.

20:04.000 --> 20:10.960
It needs to be closed, which implies that the method was called, and it has to clean up the

20:10.960 --> 20:20.400
resource. So in this finalize method, it'll close the resource. And now when I run the unit test,

20:20.400 --> 20:27.840
you will say it'll say closed buffered reader in the finalizer. If not, it'll just throw an error.

20:29.760 --> 20:31.440
If I go to the unit test that I wrote,

20:31.520 --> 20:41.680
and if I run this, you can see it's printing that line here. I could probably zoom into that

20:41.680 --> 20:48.800
a little bit. Closed buffer reader in the finalizer. Really, that's what a finalizer does,

20:48.800 --> 20:54.960
even though we shouldn't use it. And yeah, over here, you can go through the code later on.

20:54.960 --> 20:59.760
I'm just checking if it's printing the first line. That's not pertinent to the point I'm trying to

20:59.760 --> 21:06.640
make. And then this is important, though, because the GC is rather arbitrary. Well, it's not arbitrary,

21:06.640 --> 21:11.920
but we don't have really control of when garbage collection will take place. The JVM does that.

21:12.640 --> 21:19.840
We're using a system.gc, but it shouldn't be invoked this explicitly. This is not something we should

21:19.840 --> 21:27.920
do, again, due to its non-deterministic behavior. So you probably can see it's like a theme that's

21:27.920 --> 21:34.560
going to be in this whole item. The big problem with cleaners and finalizers is non-determinism,

21:35.360 --> 21:42.320
and it's the fact that it's tardy. It's tardiness that's not prompt, which is why Joshua Block states,

21:42.320 --> 21:50.000
as we continue, tardy finalization is not just a theoretical problem. Providing a finalizer

21:50.000 --> 21:55.360
for a class can arbitrarily delay reclamation of its instances. And that's a problem.

21:56.320 --> 22:03.440
The language specification makes no guarantees, sorry, I'll read that again.

22:03.440 --> 22:09.840
The language specification makes no guarantees as to which thread will execute finalizers as there is

22:09.840 --> 22:16.640
no portable way to prevent this sort of problem other than to refrain from using finalizers.

22:17.600 --> 22:23.120
And then, of course, as I stated, unlike finalizers, we still can use cleaners. Cleaners

22:23.120 --> 22:30.320
aren't deprecated yet. And they would give us control of the thread, of the class that's using it.

22:31.120 --> 22:36.720
But still, ultimately, the garbage collection, we still have no control. The JVM has control,

22:36.720 --> 22:42.160
which is probably why we should avoid using cleaners too. As he states here, as a consequence,

22:42.160 --> 22:48.320
you should never depend on a finalizer or cleaner to update persistence state. That's correct if

22:48.320 --> 22:53.680
it's like a database connection or something that requires persistence. For example, depending on

22:53.680 --> 22:59.920
a finalizer or cleaner to release a persistent lock on a shared resource such as a database is a

22:59.920 --> 23:07.120
good way to bring your entire distributed system to a grinding halt. Oh, that is something you

23:07.680 --> 23:15.120
certainly don't need. Programming is easy. It's really easy. It only gets complicated once it

23:15.120 --> 23:23.920
becomes distributed programming and when concurrency gets involved. And that's why I have a beautiful

23:23.920 --> 23:30.160
gift of my favorite actress, Margaret Robbie, probably the most beautiful woman in the world,

23:31.440 --> 23:36.560
after a certain other woman that I'm currently in love with. But we shall not talk about that.

23:38.640 --> 23:43.600
Don't be seduced. That's the point I'm trying to make. Do not be seduced by Margaret Robbie,

23:43.600 --> 23:53.760
nor be seduced by the methods system.gc or system.run finalization. So, which is why,

23:53.760 --> 23:59.680
just to go back to the unit as before, I said it here, one shouldn't do this. This is a bad move.

23:59.680 --> 24:06.160
This, try and prevent, try and, yeah, try and prevent using system.gc in your code,

24:07.120 --> 24:11.600
again, due to its non-determinism, because both of these, the garbage collection and

24:12.400 --> 24:17.280
what runs the finalization method makes no guarantee that they'll actually get executed.

24:19.040 --> 24:24.240
And in fact, these two methods run finalize their own exit, which are two other methods

24:24.240 --> 24:30.400
that can be, that pertains to finalizes have been deprecated because they aren't safe.

24:30.400 --> 24:34.880
Another red flag, especially if you're an API designer and aren't all programmers

24:34.880 --> 24:42.800
designing APIs these days, is that finalizes ignore uncaught exceptions and doesn't notify the client

24:43.520 --> 24:49.680
what the hell is going on if you do use a finalizer and there's a corrupt object. So, for instance,

24:51.440 --> 24:57.040
let's say we have an object in corrupt state due to the non-deterministic arbitrary behavior of

24:57.040 --> 25:02.080
a finalizer. Let's say we have an object that isn't fully cleaned up or an object that shouldn't be

25:02.080 --> 25:11.840
accessed by another thread. When the object crashes, this thread will not be terminated by a finalizer,

25:11.840 --> 25:18.080
whereas a JVM would certainly do that. It would make sure that if a thread crashes,

25:18.080 --> 25:23.280
if some competition goes wrong somewhere and some error is thrown, it's physically clear and explicit

25:24.240 --> 25:29.280
to a user of an API and it would be terminated and cleaned up.

25:31.200 --> 25:41.360
This is a problem because if you do use finalizer, it'll allow objects in a corrupt state to be

25:41.360 --> 25:49.280
accessed by a client of an API, which is why, again, he states, another problem with finalizes is that

25:49.280 --> 25:56.400
an uncaught exception thrown during finalization is ignored and finalization of that object terminates.

25:58.000 --> 26:00.800
Uncaught exceptions can leave other objects in a corrupt state,

26:01.680 --> 26:05.600
but when an object is left in a corrupt state and an exception is thrown,

26:05.600 --> 26:10.160
generally you'd see that exception in the stack trace. With finalizers, there wouldn't be that and,

26:10.160 --> 26:17.840
in fact, he says it won't even print a warning. But, however, with cleaners, it's on an issue because

26:17.840 --> 26:24.880
with cleaners, the library or a class for all intents and purposes using a cleaner has control

26:24.880 --> 26:30.320
of its thread, so the class itself can throw this exception. So it's a bit safer than using finalizers

26:30.880 --> 26:37.920
even though the item as a whole states avoid both. The other issue is performance penalty.

26:37.920 --> 26:42.480
Finalizers inhibit efficient garbage collection because we are trying to manoeuvre do the

26:42.480 --> 26:48.000
garbage collection instead of letting the JVM do it. And even though cleaners are still faster

26:48.000 --> 26:53.520
than finalizers, it's still slower than using the auto-closable interface, which we shall get to

26:54.400 --> 27:00.080
in the item, later on in the item. So the other problem is, of course, yes, performance penalty,

27:00.080 --> 27:04.960
and that's why Dr. Block states there's severe performance penalty for using finalizers and

27:04.960 --> 27:11.920
cleaners. It is about 50 times slower to create and destroy objects with finalizers. This is

27:11.920 --> 27:19.440
primarily because finalizers inhibit efficient garbage collection. And then we get to probably

27:19.440 --> 27:25.760
one of the biggest issues with using finalizers and cleaners, and it's that it does leave our

27:25.760 --> 27:32.400
program vulnerable to malicious code and security attacks. This point, despite being an important

27:32.400 --> 27:40.000
point, I found it a bit difficult to understand, especially because I couldn't get what he meant

27:40.000 --> 27:47.440
by having a malicious subclass. But this is what I meant, but I'm trying to collectively learn here.

27:47.440 --> 27:53.920
I did post a question on Stack Overflow, and I got some really good answers. And then finally,

27:54.480 --> 28:02.000
Holga, great blog. I'm assuming it's a blog. The person answered the question, and it was,

28:02.800 --> 28:09.040
I think it was somewhat clear. It did make sense. So all credit goes to Holga. I'll leave an answer

28:09.120 --> 28:15.680
to this question down below in the description, where he explains how finalizers, in fact,

28:15.680 --> 28:21.200
do create security problems. And before I read what Dr. Block has stated, let's go through

28:22.080 --> 28:31.360
some code and understand what this issue is, practically. So firstly, I've written this

28:31.360 --> 28:37.840
class called Finalizer Attack Example, and that also has an inner class. This inner class, in fact,

28:37.840 --> 28:43.200
is what is supposed to do the cleaning up. So it's got this check call method, which is kind of

28:43.200 --> 28:48.160
like a Boolean, which is just like a security check that verifies where that calls this,

28:48.160 --> 28:54.880
has permissions, let's say. That's a bad way of putting it. But just for all the intents and purposes

28:54.880 --> 28:59.760
think that all callers are invalid for our demo. And then we have this method, which does some

28:59.760 --> 29:04.240
critical action. That's it's really important. So I forgot to mention that since the inner class

29:04.240 --> 29:09.360
is static, that won't allow the JVM to garbage collect this resource. And then we have this

29:09.360 --> 29:16.880
malicious subclass that extends the resource class. So this is where the issue lies. This resource

29:16.880 --> 29:25.280
class, once it was used, should have died on the vine, as Dr. Block would state in this item.

29:25.280 --> 29:29.760
It should have got garbage collected, and no one should have access to it to that object.

29:29.840 --> 29:35.120
However, because we know that the finalized method can be accessed via the object superclass of resource

29:35.120 --> 29:40.800
class. And then the fact that the malicious subclass extends the resource class, all it's

29:40.800 --> 29:45.120
got to do is override the finalized method and invoke it. And the moment it's invoked,

29:45.120 --> 29:51.200
this object, which is probably a corrupt object now is resurrected. And that gives this malicious

29:51.200 --> 29:58.400
subclass access to this critical action method, which probably could do something like access

29:59.360 --> 30:04.400
the database or do something that could potentially calm your application and its uses.

30:05.040 --> 30:10.080
So which is why when I run this code, you'll see in the public static word main function.

30:12.080 --> 30:17.520
Initially, oh, I've added this thread here with the GC. This helps to kind of demonstrate the

30:18.080 --> 30:23.920
non-domestic behavior. I'll just show you that too. Initially, in the try statement,

30:24.000 --> 30:31.200
it creates a new object. And when it does, it'll say because it ran a couple of times,

30:31.200 --> 30:35.760
it would initially say I wouldn't get hands on a resource class. So okay, that's a bit confusing.

30:35.760 --> 30:41.200
I can see I shall first get rid of the sleeping of the thread and try running it again.

30:45.040 --> 30:51.120
When I don't make the thread sleep, it will throw a security exception.

30:52.080 --> 30:59.840
It'll catch that there's an issue here by the check holder and then throw the security exception.

30:59.840 --> 31:06.720
But the important point here is finalizes aren't deterministic. It's a problem. So if we do get

31:06.720 --> 31:12.480
the thread some few minutes, two seconds to sleep, then what you'll see when you run it is

31:13.040 --> 31:20.960
it's printing that look where it's saying, see, I got hands on this object, which is it's printing

31:20.960 --> 31:28.560
that from the finalize method, which was a subclass, well, not subclass, which was inherited

31:28.560 --> 31:35.440
from the resource class. And then because we got access to this object, you can probably see here

31:35.920 --> 31:42.240
you can probably see here what it's printing out is in fact this this object, but then also

31:42.240 --> 31:49.120
it has access to the critical action method, which ideally, which not ideally, but which

31:49.120 --> 31:57.760
actually the malicious subclass shouldn't have access to because once again, it should have died on

31:57.760 --> 32:05.600
the vine. I hope that makes sense. I think I got it. So I was trying to, when I asked a question

32:05.600 --> 32:11.280
on Stack Overflow, here's what I said. I'll read out this bit of the chapter, but then I said,

32:12.160 --> 32:20.240
in like a very systematic way, my understanding is that finalizes are not deterministic,

32:20.240 --> 32:25.120
a malicious subclass can run its finalize method on a particular constructed,

32:25.120 --> 32:31.760
corrupted superclass object, which is what we are doing right here by extending the resource

32:31.760 --> 32:40.560
class. Moving the corrupt objects reference to a static field doesn't let the GCM garbage collect,

32:40.560 --> 32:47.360
not GCM, JVM, I should fix that. So because it's static, it can't be garbage collected.

32:47.920 --> 32:53.920
The attacker can use this object that should have died on the vine and do as they will,

32:53.920 --> 32:59.680
pass the security flow. So this is the problem with the use of finalizes. I hope that makes sense.

33:00.640 --> 33:05.280
I'm asking that question more from myself if I really understood that,

33:07.120 --> 33:11.280
but I think I did, but I think I did. At least I'm going to tell myself how to feel better.

33:13.440 --> 33:19.280
Now that I've kind of demoed that, even though I admit that was a rather pathetic demo,

33:20.080 --> 33:24.880
let's try and get to what Joshua Block has stated here. Please forgive me. I'm trying my best to

33:24.880 --> 33:30.240
demo it here, but because he really hasn't given tangible implementations and examples,

33:30.240 --> 33:34.800
I'm trying my best to see if I could find code and write code and connect it to what he's trying to

33:34.800 --> 33:40.560
say here, given that I haven't really used finalizes before ever in my programming life.

33:41.760 --> 33:45.680
But anyway, let's see if what he's stating here makes a bit more sense.

33:46.560 --> 33:54.640
Finalizes have a serious security problem. They open your class up to finalize their attacks.

33:55.200 --> 34:01.760
The idea behind a finalize attack is simple. If an exception is thrown from a constructor,

34:01.760 --> 34:09.440
or it's serialization equivalence, so that would be the constructor, for instance, of let's say this

34:09.440 --> 34:16.960
class. The finalize of a malicious subclass can run on the partially constructed object that

34:16.960 --> 34:25.360
should have died on the vine. So that was this subclass that extended it. This finalizer can

34:25.360 --> 34:31.280
record a reference to the object in a static field, preventing it from being garbage collected.

34:31.280 --> 34:33.520
Just a point here. You probably noticed I didn't

34:34.320 --> 34:40.800
stole the reference to this resource class anywhere in any static field or didn't really hold the

34:40.800 --> 34:46.960
reference in the subclass. The reason for that was because Holger, the answer that I got, said

34:46.960 --> 34:51.600
something like this. He said your description is basically correct, but over complicating things.

34:52.480 --> 34:57.360
I'm not surprised there. I tend to do that quite a lot. There's no need to store something in a

34:57.360 --> 35:02.560
static variable as soon as the finalize method is invoked. The object is already just resurrected

35:02.560 --> 35:07.760
as invoking a method on an object implies invoking code with access to the object. That really did

35:07.760 --> 35:11.840
make a lot of sense to me because that's exactly what we're doing here in this override method,

35:11.840 --> 35:19.040
in the subclass. Storing the object reference in a variable is a way to expand the lifetime

35:19.040 --> 35:24.320
beyond the execution of the finalize method. But this is not necessary. But this is not a

35:24.320 --> 35:29.680
necessary thing for the attack. Also, instead of using a static variable, the attacker could also

35:29.680 --> 35:35.440
make the subclass and inner class and store the reference in the still reachable outer object.

35:35.440 --> 35:39.040
So the following program is already enough to demonstrate the issue. So that's the program

35:39.040 --> 35:44.080
that I showed to you before, which it's Holger's code. In fact, I just kind of repurposed it and

35:44.080 --> 35:49.040
made it a bit more presentable, which is why I haven't done what Joshua Blocker stated here.

35:53.200 --> 35:58.480
Once the malinformed object has been recorded, it is a simple matter to invoke arbitrary methods

35:58.480 --> 36:04.160
on this object that should have never been allowed to exist in the first place. So that is the

36:04.160 --> 36:08.240
arbitrary method, which was critical action that I did invoke.

36:10.800 --> 36:15.520
Throwing an exception from a constructor should be sufficient to prevent an object

36:15.520 --> 36:21.920
from coming into existence in the presence of finalizes. Unfortunately, it is not. And then he

36:21.920 --> 36:28.640
states, which is kind of what I was, I tried to demo here, to protect non-final classes from

36:28.640 --> 36:34.960
finalizer attacks, write a final finalize method that does nothing. That's exactly what we can do

36:34.960 --> 36:40.800
here. So what you'll see is we have the resource class. And then because the resource class itself

36:40.800 --> 36:47.280
obviously has the finalize method, if we create a final protected void finalize, you'll see that

36:47.360 --> 36:53.120
it'll throw an error. You can't subclass it because, sorry, you can't override it because

36:54.080 --> 37:00.720
this class that inherits that, that subclasses resource class, now can't override it. And that

37:00.720 --> 37:04.720
never really solved the problem here. That's one way of protecting ourselves against the finalize

37:04.720 --> 37:08.960
method. But the better way is to not use it in the first place. And that, of course, begs the

37:08.960 --> 37:15.520
question, given that Joshua Block and the broader Java community, the experts are so adamant as to

37:15.520 --> 37:21.280
why one shouldn't use finalizers or cleaners, what is the alternative? What should we use instead?

37:22.080 --> 37:28.800
And that's what Joshua Block states here, to use the autoclosable interface. Before I get to

37:28.800 --> 37:34.080
what I've written down and taken notes of and kind of try to demo what autoclosable is, let's

37:34.080 --> 37:39.280
first go through the definition because that'll set a foundation, let's say.

37:39.440 --> 37:47.440
So what should you do instead of writing a finalizer or cleaner for a class whose objects

37:47.440 --> 37:54.160
encapsulate resources that require termination, such as files or threads, just have your class

37:54.160 --> 37:59.680
implement autoclosable and require its clients to invoke the close method on each instance,

38:00.320 --> 38:06.160
when it is no longer needed, typically using try with resources to ensure termination,

38:06.160 --> 38:12.720
even in the face of exceptions. So the point on try with resources is in fact the next item.

38:12.720 --> 38:17.840
So I shall go into detail as to what try with resources do in the next video.

38:17.840 --> 38:24.560
So definition of autoclosable, which enforces encapsulation by Oracle docs is an object that

38:24.560 --> 38:30.560
may hold resources such as files or socket handles until it is closed. The close method

38:30.560 --> 38:37.200
of an autoclosable object is called automatically when exiting a try with resources block for

38:37.200 --> 38:45.360
which the object has been declared in the resource specification header. This construction ensures

38:45.360 --> 38:52.560
prompt release avoiding resource exhaustion, avoiding resource exhaustion, exceptions,

38:52.560 --> 38:56.720
and errors that may otherwise occur. So let's take a look at a demo. Let's see

38:57.680 --> 39:04.160
what at how autoclosable has to be used. Also, there's another caveat he's added here that it's

39:04.160 --> 39:12.400
important that when an object has been closed that we should keep track of how if the instance has

39:12.400 --> 39:17.760
been closed and we shouldn't rely on the client to do that. It was a bit hard to find a good

39:19.120 --> 39:24.480
demo of what this meant. So I did ask a question on Stack Overflow on that too. I asked how to

39:24.480 --> 39:30.720
keep track if an instance has been closed with Java autoclosable. I even got a negative

39:31.360 --> 39:36.480
download on that question because I realized it's actually quite simple as to how to do that.

39:36.480 --> 39:43.280
I just got a thought about it a bit more without being lazy. But nevertheless, I did find an answer

39:43.280 --> 39:50.800
and I did post it here. So firstly, the demo, the demo on autoclosable is this. Again, courtesy of

39:50.800 --> 39:56.800
Baldang. So we have a demo class which implements autoclosable. And then we have another buffered

39:56.800 --> 40:02.480
read instance like the previous one we were going through for the final finalizable class,

40:02.480 --> 40:07.680
a similar concept. In fact, the exact class that I've repurposed for this demo.

40:09.200 --> 40:16.560
And this here, this Boolean is in fact what does that bit I asked here. It's what keeps track if

40:16.560 --> 40:24.320
this instance of, in this case, the demo class has been closed. So when in the constructor,

40:24.880 --> 40:30.800
the same way we are accessing a file, reading off the file, creating a new, using a resource reader,

40:32.560 --> 40:38.880
and then we're reading the first line, similar thing doing, and we're checking if we can read

40:38.960 --> 40:46.240
the first line. And here there's something extra added. We're checking if this resource,

40:46.240 --> 40:53.200
so that is reader, has been closed. I think I made a mistake. I said that what this does in line number

40:53.200 --> 40:59.200
13 was keep track of if demo class instance has been closed. That is wrong. I apologize.

40:59.200 --> 41:05.440
What this keeps track of is if the buffered reader instance has been closed. And that's what we're

41:05.440 --> 41:12.000
checking in the read first line method. And if it is closed, we can't access it. So it should

41:12.000 --> 41:18.720
throw a illegal state exception. And that's what we're doing here. And then we override the closed

41:18.720 --> 41:29.440
method, which is the method in the auto-closable interface. That method right there. And in the

41:29.440 --> 41:34.560
class itself, we do the closing. We close that resource. And then, of course, we set the flag

41:34.560 --> 41:40.880
to true because now it has been closed. And if not, it'll throw an IO exception, in this case,

41:40.880 --> 41:47.520
because it's a buffered reader. So if we go to the unit test, you could see if I'm going to run it,

41:51.120 --> 41:58.640
it did pass because all it's going to do is read the line. But of course, if we try to access the

41:59.200 --> 42:04.800
resource, read the instance, and it was closed, it would have thrown an error. The test did pass

42:04.800 --> 42:14.240
because it's just checking if the line, if this line is this. Oh, I should show the log here, in

42:14.240 --> 42:22.400
fact. It's printing this log here, closed buffered reader in the closed method and flag changed to

42:22.480 --> 42:30.720
true. So that is this right here. Where is it? I've got so many classes opened up. Oh, yeah.

42:30.720 --> 42:35.920
That's printing this bit here, closed buffered read instance, and it's printing the flag, which is

42:35.920 --> 42:41.040
true in this case. So that's really, it's quite straightforward, the auto-closable bit and even

42:41.040 --> 42:45.920
how it keeps track of how it closes it. I was over-complicating in my head and I was thinking

42:45.920 --> 42:51.760
there's some way to do it. In fact, it's tabooly. So despite being told not to use them, and we

42:51.840 --> 42:57.280
probably will never have to use them for normal average Java programmers like myself,

42:58.160 --> 43:03.680
what really are they useful for? What are they good for? Caviar there, of course, is that as of

43:03.680 --> 43:09.280
Java 18 finalizes are in fact deprecated and will be entirely removed in the future. So we'll never

43:09.280 --> 43:15.280
use finalizes, but let's say cleaners. What are they really useful for? Firstly, it's for them to

43:15.280 --> 43:23.760
act as a safety net. And let's try to understand what that means. One use of Java cleaners,

43:23.760 --> 43:27.920
I'm going to stop saying finalizes because it's deprecated, is that one use of that is

43:28.880 --> 43:35.040
to act as a safety net in case the owner of a resource neglects to close its, to call its

43:35.040 --> 43:40.800
closed method. Well, there's no guarantee that the cleaner or finalizer will run promptly or at all.

43:41.360 --> 43:46.640
It is better to free the resource later than never if the client fails to do so. If you're

43:46.640 --> 43:52.320
considering writing such a safety net finalizer, think long and hard about whether the protection

43:52.320 --> 43:59.520
is worth the cost. So the way I see it, it's just an extra check one adds when writing an API or a

43:59.520 --> 44:06.400
class just as a safety net. By overriding that finalize method, we could ensure that any of the

44:06.400 --> 44:12.960
resources that should have been closed, sorry, not ensure, we could hope that any of the resources

44:12.960 --> 44:18.160
that should have been closed or were closed because of the finalize method, even though

44:18.160 --> 44:22.800
it's not a domestic. So that's, it's a trade off one has to make and think about carefully.

44:23.440 --> 44:30.320
And then the second use is using it with native peers. What is native peer?

44:31.280 --> 44:36.160
As the simplest way to think about it is that native peers are objects that aren't owned by the

44:36.160 --> 44:44.000
JVM. They're sort of like a platform specific objects that the JVM runs on, the virtual machine

44:44.000 --> 44:50.080
runs on. It could be CEO C++ objects and the JVM can't garbage collect them. And that's why they're

44:50.080 --> 44:54.880
called native peers, even though they call peers because the objects still have dependencies on

44:54.880 --> 45:01.120
them. But the JVM has no control of these objects in memory. It's quite interesting. I really didn't

45:01.120 --> 45:07.120
know much about it. But of course, I found this pretty simple stucco flow answer, which can explain

45:07.120 --> 45:13.680
that it said that a native object is not programmed only in Java, but is a, but in a platform specific

45:13.680 --> 45:20.240
language, typically CEO assembler, even memory allocated by this code cannot be disposed by the

45:20.320 --> 45:27.040
garbage collection by GC. Therefore, you may need to clean it in a finalizer. The native peer is

45:27.040 --> 45:31.600
the native part of a Java object. So I'll leave an answer to this question in the description.

45:33.200 --> 45:38.720
And that's what I wrote out here by the user Andres on stucco overflow. Thanks for that.

45:41.040 --> 45:47.760
And Joshua Block states, a second legitimate use of cleaners concerns objects with native

45:47.760 --> 45:54.400
peers. A native peer is a native non Java object. That's an important point to which a normal object

45:54.400 --> 46:01.680
delegates via native methods. Because a native peer is not a normal object, the garbage collector

46:01.680 --> 46:06.240
doesn't know about it and can't reclaim it when the Java peer is reclaimed.

46:08.160 --> 46:13.760
A cleaner or finalizer may be an appropriate vehicle for this task, assuming the performance

46:13.760 --> 46:18.400
is acceptable and the native peer holds no critical resources.

46:20.560 --> 46:26.560
Saying that finally, we, we in fact get to some actual code in this item, because the other code

46:26.560 --> 46:34.320
I showed was code that I wrote and I kind of use from other people. And that is this room class,

46:34.320 --> 46:40.960
which demonstrates the concept of it being a safety net by implementing auto closeable. Yeah.

46:41.120 --> 46:48.240
So the class is called room. And I do appreciate that pun there because the room must be cleaned

46:48.240 --> 46:54.480
before being reclaimed. I like that. I appreciate that. And it implements, as I said, auto closeable.

46:55.120 --> 47:02.560
It's got a private static final cleaner, which cleans. And this in a class,

47:03.440 --> 47:12.800
which implements runnable is what holds the resources required by cleaner to clean the room.

47:14.000 --> 47:19.680
So this in a class is in fact what does the cleaning in a separate thread in the background

47:19.680 --> 47:26.480
of this broader class. So what you can see is we're simply registering the cleanable instance

47:27.440 --> 47:33.680
with with with the state, which is a variable we hold here in line number 34 and register it.

47:33.680 --> 47:40.080
We assign it. And after that, the number of junk piles should be set to zero. And the way that happens

47:40.080 --> 47:49.680
is the close method, which is what we override from the auto closeable interface that will invoke

47:50.480 --> 47:55.760
the run method, which is inclinable. So once we register it with the with the with the object

47:55.760 --> 48:01.360
itself and then the state. So this refers to the current object and then in the state of the room

48:02.480 --> 48:11.920
that we pass into the uh, we pass the we invoke the clean method of the of the cleanable instance.

48:12.560 --> 48:18.000
And the clean method, what that does is it triggers the run method that sets the number

48:18.000 --> 48:23.920
of junk piles to zero. So every time before it's reclaimed, it has to clean all the resources. Now

48:23.920 --> 48:28.800
I didn't I think I don't think I did a good job at explaining that. It's a bit difficult to explain

48:28.800 --> 48:37.120
because I I lack the verbal visual city and a deep understanding of how cleaner works. Therefore,

48:37.120 --> 48:43.120
probably what I'll do is I'll go through Joshua Bloch's description or sorry, his elucidation

48:43.120 --> 48:49.520
and then I shall refer to the code as I read them out and kind of learn it live, let's say,

48:49.520 --> 48:55.680
which is exactly what I'm doing in this video series. The the room class implements auto close

48:55.680 --> 49:04.640
book that I showed here. The fact that it's automatic cleaning safety net uses a cleaner is

49:04.640 --> 49:11.600
merely an implementation detail. Unlike finalizes cleaners do not pollute across this public API.

49:11.600 --> 49:17.280
That's correct, which is why it's a bit hard to see at first because I'm using it as a client.

49:17.840 --> 49:24.240
The static nested state class holds the resources that are required by the cleaner to clean the room.

49:24.240 --> 49:30.560
So that is the static nested state class. Also, to understand how nested classes work, just go and

49:30.560 --> 49:37.600
read these docs in Oracle. It's pretty simple. It's it's a it's an inner class. I'll leave a link to

49:37.600 --> 49:44.000
that in the description. It's got access to all the properties of the outer class in this case.

49:47.600 --> 49:56.640
And then and then he continues. And then he continues in this case, it is simply the number of junk

49:56.640 --> 50:01.680
piles field, which we need to clean up, which you shall see we're going to be doing this integer value,

50:04.080 --> 50:10.480
which represents the amount of mess in the room. Yep. State implements runnable. So you can see

50:10.480 --> 50:15.840
here it's going to implement runnable because we need to run this in the background. And its run

50:15.840 --> 50:22.960
method is called at most once. So this method, which we're overriding is called at most once and

50:22.960 --> 50:32.320
that is this one method is from runnable because we're running a new thread by the cleanable that

50:32.320 --> 50:38.320
we get when we register a state instance with our cleaner in the room's constructor. So that that bit

50:38.320 --> 50:43.920
here is done right here in the cleanable, which is what I said that we're doing the registering

50:43.920 --> 50:52.160
as we create this new state by passing the number of junk files, junk piles, sorry. And that's what

50:52.160 --> 50:57.360
we're passing onto this and doing the registering, which is what invokes that run method eventually.

51:00.160 --> 51:06.880
The call to the run method will be triggered by one of two things. Usually it is triggered by

51:06.960 --> 51:13.440
call to room's close method, calling cleanable's clean method. So that's the close method,

51:13.440 --> 51:19.360
which we have overridden here of the out-of-class room. If the client fails to call the close

51:19.360 --> 51:25.280
method by the time a room instance is eligible for garbage collection, the cleaner will hopefully

51:25.280 --> 51:32.160
call state's run method. So that's what he meant by a safety net because if the client doesn't

51:32.880 --> 51:36.880
call the close method and clean up that resource or clear up that resource,

51:38.720 --> 51:41.840
then we expect this run method to run, hopefully.

51:44.000 --> 51:49.040
It is critical that a state instance does not refer to the room instance. That's important and we

51:49.040 --> 51:53.680
shall see why. If it did, it would create a circularity that would prevent the room instance

51:53.680 --> 51:58.720
from becoming eligible for garbage collection and from being automatically cleaned. Yes,

51:58.720 --> 52:02.480
because for it to be eligible for garbage collection, we have to make sure that there

52:02.480 --> 52:08.480
aren't any references to that object in memory. Therefore, state must be a static nested class

52:08.480 --> 52:13.520
because non-static nested classes contain references to the end-closing instances,

52:13.520 --> 52:19.520
which is why exactly we've declared this static and I said to do some reading on nested classes

52:19.520 --> 52:23.520
as to how the difference between non-static and static in the Oracle docs.

52:24.240 --> 52:32.720
And then we shall take a look at how this class is used. So if we take a look at, let's say,

52:32.720 --> 52:40.000
teenage up, we're doing some garbage collection manually, explicitly, but we should not depend

52:40.000 --> 52:47.520
on this behavior. So if I go run this and run this, in fact, first let's take a look at adult,

52:47.520 --> 52:53.360
sorry, where we're using a tri-width resource. So the room's cleanest used only as a safety net.

52:53.360 --> 53:00.400
If clients surround all room incantations with tri-width resource blocks, automatic

53:00.400 --> 53:06.160
cleaning will never be required. So as you can see here, I'm not, or just your block in this

53:06.160 --> 53:12.080
case isn't doing any explicit garbage collection because we've used it with a tri-width resource

53:12.080 --> 53:18.880
block. And if I run this, you will see it says goodbye, but also says cleaning the room. So the

53:18.880 --> 53:25.520
object's created and it prints goodbye. But afterwards, this cleaning the room along comes from

53:30.160 --> 53:35.440
this run method here, which we've all written and written. And that also means that the number

53:35.440 --> 53:40.560
of chunk passes zero. So in fact, if you want to print out the number of chunk pass just to,

53:40.560 --> 53:42.800
just to make sure that we know what's going on

53:48.880 --> 53:52.400
and run that again, you will see it's going to print zero.

53:56.800 --> 54:03.200
Yeah, there we go. It printed zero. That's what we expected. But then if you go take a look at the

54:03.200 --> 54:08.800
teenager's room and if you run it, it will not run it unfortunately. Oh, it did, but it's kind of

54:09.120 --> 54:14.560
so I'm going to try it again. I'm going to keep trying it until it does not run it. Oh, actually,

54:14.560 --> 54:19.920
sorry. If I comment the garbage collection, because I had that uncommented, it should have

54:19.920 --> 54:25.760
been commented out. Now it shouldn't run it. You see that it just printed our piece out,

54:25.760 --> 54:30.960
but there was no cleaning done. And then when I do the garbage collection explicitly,

54:31.760 --> 54:37.520
now it's going to print cleaning room. And that's what we expect. And that was though,

54:37.520 --> 54:40.560
that cleaning room was imprinted from the previous line.

54:43.920 --> 54:48.400
Sorry, it was printed off the previous line, of course, because it ran the run method, but

54:49.680 --> 54:54.080
because we did do the garbage collection, that doesn't exist anymore. The memory was cleared.

54:56.000 --> 55:03.840
And that's virtually it. That's kind of the utilities of using auto-closable and how it's

55:03.840 --> 55:08.320
got to be used and why it's preferred over, let's say, using a final asset, for example. And then

55:09.760 --> 55:16.400
just to conclude that point and of that demo, Joshua Block states, you might expect it to print

55:16.400 --> 55:23.760
piece out, followed by cleaning room. But on my machine, it never prints cleaning room. It just

55:23.760 --> 55:30.480
exits, which is kind of, well, that was before we did do the explicit garbage collection.

55:31.120 --> 55:37.360
This is the unpredictability we spoke of earlier. The cleaner spec says, the behavior of a cleaner

55:37.360 --> 55:43.520
during system.exit is implementation specific. No guarantees are made relating to whether

55:43.520 --> 55:49.200
cleaning actions are invoked or not. While the spec does not say it, the same holds true

55:49.200 --> 55:58.080
for normal program exit. On my machine, which is what we did here, adding the line system.gc

55:58.560 --> 56:05.200
to teenagers main method is enough to make it print cleaning room prior to exiting. The reason we

56:05.200 --> 56:11.840
didn't see that log here in line number 30 is because the moment it cleaned the room and cleared

56:11.840 --> 56:17.200
out the resources, it exited and it doesn't really exist in memory anymore. So I repeat that point

56:17.200 --> 56:23.840
again, on my machine, adding the line system.gc to teenagers main method is enough to make it print

56:23.840 --> 56:28.320
cleaning room prior to exit. But there's no guarantee that you'll see the same behavior on

56:28.320 --> 56:34.400
your machine, which is exactly why Joshua Bock states here to test the behavior. But note that

56:34.400 --> 56:42.560
you must not depend on this behavior. Again, not to be on that horse, but the biggest problem is

56:42.560 --> 56:47.600
the non-determinism. And we don't want that in programming. We want things to be logical and

56:47.600 --> 56:54.640
deterministic as script programmers. And in summary, he states, don't use cleaners or in

56:54.640 --> 57:02.480
releases prior to Java 9 finalizes, except as a safety net or to terminate non-critical native

57:02.480 --> 57:09.920
resources. Even then, be aware the indeterminacy and performance consequences. That's it. That

57:09.920 --> 57:17.200
was item number eight, avoid finalizes and cleaners. I hope I did a good job at demoing

57:17.200 --> 57:22.640
certain parts of it. As you all know with these tutorials, the best way to understand it is to

57:23.600 --> 57:28.880
after watching them or while watching them goes through the code base, because that's the best

57:28.880 --> 57:35.920
way to grok these concepts. But nevertheless, I hope my efforts were worth it. I will try and

57:35.920 --> 57:41.040
keep enduring and getting through this whole book because I'm really enjoying it. I'm learning a lot,

57:41.040 --> 57:45.760
but also I want to kind of get into the habit of putting out these videos

57:47.040 --> 57:50.720
in a certain schedule, let's say, at least once every two weeks.

57:52.080 --> 57:56.080
But thanks a lot for watching. I hope you gained some value from it and learned something.

57:56.080 --> 57:58.880
I'll see you in the next item. Cheers.

