WEBVTT

00:00.000 --> 00:07.800
Hey everyone, welcome to part 4, the final part of item 10 in Joshua Block's Effective

00:07.800 --> 00:08.800
Java.

00:08.800 --> 00:15.280
Item 10, as if you've been folding along in the previous parts, is obey the general contract

00:15.280 --> 00:17.600
when overriding equals.

00:17.600 --> 00:23.080
And I'm very excited, and so is the dog barking outside when I decided to record a video.

00:23.080 --> 00:26.840
But I'm very excited because finally, man, this was a really long item.

00:26.840 --> 00:32.880
It's taken me a whole month to get across this item, also because I've been procrastinating.

00:32.880 --> 00:38.880
In any case, this is really good because all the stuff that we've learned in this item,

00:38.880 --> 00:44.280
what to do, what not to do, we're going to put it all together in this final item and

00:44.280 --> 00:51.040
create a high-quality equals method, or as Joshua Block would say, it's the recipe for

00:51.040 --> 00:53.600
a high-quality equals method.

00:53.600 --> 00:56.760
So without further ado, let's get started.

00:56.760 --> 01:01.600
There are a few points that he's laid down on what to do when it comes to designing equals

01:01.600 --> 01:02.600
methods.

01:02.600 --> 01:04.600
The first one is quite straightforward.

01:04.600 --> 01:11.440
It is to use the double equals operator to check if the argument is a reference to an

01:11.440 --> 01:12.440
object.

01:12.440 --> 01:17.800
So with the argument or whatever we are passing onto the equals method, if we use a double

01:17.800 --> 01:23.200
equals operator, we can confirm if it's a memory reference.

01:23.200 --> 01:27.160
So if you're passing the same object, let's say, then obviously it's going to return true.

01:27.160 --> 01:33.760
As you can see in this really quite straightforward example, we have two strings and keep in mind

01:33.760 --> 01:38.520
objects of string, of string class, are immutable.

01:38.520 --> 01:47.800
And in this case, the first if condition will return true because both this new string,

01:47.800 --> 01:53.000
I'm sorry, as I was staring into the code there, I realized I explained that wrongly.

01:53.000 --> 01:56.640
Firstly, the caveat is this is a anti-pattern.

01:56.640 --> 02:01.440
You should never declare strings like this because the new keyword creates a new object

02:01.440 --> 02:02.640
in memory.

02:02.640 --> 02:07.120
That's not required because as I said, string is immutable.

02:07.120 --> 02:13.280
So here, when we compare string one to string two using the equals operator, this will in

02:13.280 --> 02:15.200
fact say that they're not equal.

02:15.200 --> 02:18.480
So this will say they're not in the same memory location.

02:18.480 --> 02:23.160
But if you use the equals keyword, it's going to say they're in, sorry, it's going to say

02:23.160 --> 02:28.400
that they have the same content or that there's logical equality as we've discussed throughout

02:28.400 --> 02:29.840
this item.

02:29.840 --> 02:35.920
So but when it comes to designing our own equals method, the reason that we should first check

02:35.920 --> 02:41.160
using the equals operator, if it's referring to the same object is because if it is, we

02:41.160 --> 02:46.360
just save time, we save computation time instantly, we can return true or false.

02:46.440 --> 02:53.320
Not false, but we could certainly return true if it is equal to the, if the memory reference

02:53.320 --> 02:56.320
is equal using the double equals operator.

02:56.320 --> 03:02.960
And Joshua Block states, yeah, so if so returns true, this is just a performance optimization,

03:02.960 --> 03:07.160
but one that is worth doing if the comparison is potentially expensive.

03:07.160 --> 03:11.560
So if it's not equal, there may be a lot more other checks we need to do in order to have

03:11.560 --> 03:16.520
a good quality equals method, but if it's the same memory reference, just return true.

03:16.520 --> 03:17.520
I'm sorry.

03:17.520 --> 03:21.320
I know I kind of exhausted that point, but it's important to understand why we do that

03:21.320 --> 03:23.160
check initially.

03:23.160 --> 03:28.280
The second one is to check if the, if it's an instance of the correct type.

03:28.280 --> 03:32.360
And firstly, if it's not straight away return false, because if they're going to be two

03:32.360 --> 03:37.480
different types, then there's no logical equality to start with, which is why Joshua

03:37.480 --> 03:43.720
Block states in the second part of putting together this recipe, use the instance of

03:43.720 --> 03:48.400
operator to check if the argument has the correct type.

03:48.400 --> 03:49.640
So what does that mean?

03:49.640 --> 03:53.960
What that means is before I read out what he stated, in fact, maybe I should first read

03:53.960 --> 03:54.960
out.

03:54.960 --> 03:56.880
No, no, no, I'll show this example.

03:56.880 --> 04:01.160
And then before we get to the Java collections framework set example, I'll read out what

04:01.160 --> 04:02.160
he stated.

04:02.160 --> 04:06.920
So we've defined a type, we've defined my interface and we have a class that implements

04:06.920 --> 04:07.920
my interface.

04:07.920 --> 04:13.160
So now this class, my class is of type, my interface.

04:13.160 --> 04:18.600
And then in the equals method, the first thing we are checking is we're first checking, yeah,

04:18.600 --> 04:22.480
we're doing the reference equality, so the memory reference equality, which is what we

04:22.480 --> 04:27.600
discussed in the first part here, or the first section, let's say.

04:27.600 --> 04:32.680
And if it is straight away return true, no need to execute the rest of this code.

04:32.680 --> 04:36.320
But if it's not an instance of my interface.

04:36.320 --> 04:43.120
So whatever object we pass, let me just see if this is that's zoom in a little bit.

04:43.120 --> 04:44.680
There we go.

04:44.680 --> 04:50.320
Whatever object that we pass into the equals method, if it's not an instance of that broader

04:50.320 --> 04:56.640
class or of a type, sorry, of that broader class, then return false.

04:56.640 --> 05:01.160
So in that sense, we save time and only if it is, we get on with the rest of the equals

05:01.160 --> 05:04.280
method to check if there's logical equality.

05:04.280 --> 05:08.800
And that's why Joshua Block states typically the correct type is the class in which the

05:08.800 --> 05:10.800
method occurs.

05:10.800 --> 05:13.560
But if there's an interface like you've seen here, you can implement it.

05:13.560 --> 05:18.480
And that's why he says use an interface if the class implements an interface that refines

05:18.480 --> 05:24.840
the equals contract to permit comparisons across classes that implement the interface.

05:24.840 --> 05:31.200
So what we're checking here in this equals method is not if the object be pass is an

05:31.200 --> 05:38.400
instance of my class rather we're using the interface as a type, as you can see here.

05:38.400 --> 05:44.840
So in that way, this equals method theoretically can be used across other classes, or at least

05:44.840 --> 05:50.160
this part of the equals method can be used across other classes that implement the mind

05:50.160 --> 05:51.560
to face type.

05:51.560 --> 05:56.520
And as an example, he's used a the collections framework, the collections interface or the

05:56.840 --> 06:03.520
collection interface, such as set list map and map entry have this property.

06:03.520 --> 06:09.440
So we have this interface that extends the collection generic interface with this is

06:09.440 --> 06:14.320
a generic parameter or a generic type.

06:14.320 --> 06:19.880
And what that does is when we have my set, when we define a new set that implements this

06:19.880 --> 06:26.440
set interface that we've declared here, oops, I will declare here.

06:26.440 --> 06:30.880
In the equals method, as you saw from the previous example, it's the same thing that

06:30.880 --> 06:35.920
checking if it's an instance of that set interface type.

06:35.920 --> 06:40.520
And only if so, we get to the rest of the equals method, if not, we straight away return

06:40.520 --> 06:41.520
faults.

06:41.520 --> 06:46.120
And then the third section of this is, as you've seen in the myriad equals methods that

06:46.120 --> 06:52.560
we've used throughout this item is to cast the argument to the correct type.

06:52.560 --> 06:58.280
So just your block states cast argument to the correct type, because this cast was preceded

06:58.280 --> 07:02.440
by an interface of test, it is guaranteed to succeed.

07:02.440 --> 07:11.040
So we're passing in the equals method, when we do this check here, sorry, when we do the

07:11.040 --> 07:16.680
check here, this ensures that we can do this cast safely without something like a class

07:16.680 --> 07:21.880
cast exception error, because we are checking if it's of the same type, or at least if this

07:21.880 --> 07:25.400
object is of instance of string.

07:25.400 --> 07:31.160
And in this case, in fact, because it's not an instance of string, it will not do the

07:31.160 --> 07:34.200
casting, it'll move on to do something else.

07:34.200 --> 07:42.800
So if we pass some other object apart, other than let's say what we have here, or actually

07:42.800 --> 07:47.200
sorry, in this case, because we've declared this to be an object is this will go through

07:47.200 --> 07:54.120
I apologize, I realized that the type of object is still sorry, the type of OBJ is still off

07:54.120 --> 07:59.560
type object, which is an instance of string, which is a super type to the string class.

07:59.560 --> 08:02.040
So it'll do the casting here safely.

08:02.040 --> 08:05.320
That's what I was trying to say, that was a bad view of explaining it, but you get the

08:05.320 --> 08:11.120
point because we've done this test here, the casting should work fine.

08:11.120 --> 08:17.440
Okay, now we get to the fourth section, the final part of this recipe.

08:17.440 --> 08:23.680
And this really is most of what part four in this video series is about, because it's

08:23.680 --> 08:29.800
really the biggest part when it comes to designing a good high quality equals method.

08:29.800 --> 08:35.920
And that is that for each significant field in the class, check if that field of the argument

08:35.920 --> 08:39.320
matches the corresponding field of this object.

08:39.320 --> 08:45.040
Now before we get to the definitions defined by man, this dog really is annoying me.

08:45.040 --> 08:50.600
I apologize, I tried to reduce background noise when editing the video, but it is quite

08:50.600 --> 08:51.600
distracting.

08:51.600 --> 08:55.760
Anyway, getting back to this, getting back to this.

08:55.760 --> 09:02.800
So before I read the kind of formal definition in the book, let's quickly take a look at

09:02.800 --> 09:04.240
a demo that I put together.

09:04.240 --> 09:11.400
So what we have here, we have here a, I'm quite distracted today, I apologize, it's

09:11.400 --> 09:16.920
like a lot going on despite me living in a very quiet neighborhood.

09:16.920 --> 09:24.120
So what we have here is a class that I've called class person and it's got a private

09:24.120 --> 09:30.360
field string, a private field called string and of type int.

09:30.360 --> 09:33.520
So keep in mind that's a primitive type.

09:33.520 --> 09:39.600
Then we also have the equals method and then you'll first see, so in the equals method,

09:39.600 --> 09:45.080
as we discussed in the previous sections, we're doing first the memory reference check

09:45.080 --> 09:50.520
and then we're doing the instance of check that gets us across many things.

09:50.520 --> 09:55.080
It first tells us that here that these two are in fact two different objects.

09:55.080 --> 10:01.720
If it returns false and here it says, despite them being two different objects or having

10:01.720 --> 10:04.640
two different memory locations, they are of the same type.

10:04.640 --> 10:05.640
That's good.

10:05.640 --> 10:11.680
Now we get to the comparison and here really what this means is, as you can see, so after

10:11.680 --> 10:18.000
doing the casting, so the object that we get, we cast it to of type person, each significant

10:18.000 --> 10:23.560
field and that is, that really is something we need to think of in terms of logic, which

10:23.560 --> 10:30.560
is why initially in this item, we discussed concepts such as logical equality and equivalence

10:30.560 --> 10:36.840
relations because this call here, each significant field or each field that's significant is

10:36.840 --> 10:38.000
compared.

10:38.000 --> 10:42.120
That's a call that we as the designer of the equals method has to make.

10:42.120 --> 10:47.840
So obviously when we're comparing, let's say two people or two persons in this case, we've

10:47.840 --> 10:53.360
made the call that the name and the age are required for logical equality, which is why,

10:53.360 --> 11:00.680
if you look at line number 20, we're checking to see if both name and both age are equal

11:00.680 --> 11:06.400
and only if it's equal do we pass through and you probably can see here also, when it

11:06.400 --> 11:13.840
comes to age, I'm using a double equals operator, not the equals keyword because it's a primitive

11:13.840 --> 11:14.840
type.

11:14.840 --> 11:15.840
It's not an object.

11:15.840 --> 11:20.120
So accordingly, Joshua Block states, if the type in step two, which is the previous one

11:20.120 --> 11:31.560
we discussed, that is, yeah, the instance of check, if the type in step two is an interface,

11:31.560 --> 11:35.520
you must access the arguments fields via interface methods.

11:35.520 --> 11:40.080
If the type is a class, you may be able to access the fields directly depending on their

11:40.080 --> 11:41.840
accessibility.

11:41.840 --> 11:47.800
And then he says, for primitive fields, whose type is not float or double and we'll get

11:47.800 --> 11:54.640
into why that's the case, use the double equals operator for comparisons, which is what I've

11:54.640 --> 11:55.640
done here.

11:55.640 --> 11:57.960
As you can see, I already made that point.

11:57.960 --> 12:02.280
I apologize if I didn't too kind of over repeat points, but I think it's important, you know,

12:02.280 --> 12:08.400
repetition is the key to truly grogging concept.

12:08.400 --> 12:14.600
And we continue, for object reference fields, call the equals method recursively.

12:14.600 --> 12:19.840
For float fields, use the static float.compare method.

12:19.840 --> 12:23.440
And for double fields, use the double.compare method.

12:23.440 --> 12:24.440
So why is that?

12:24.440 --> 12:30.400
Why do we have to, why is there an exception for float or double fields in this case?

12:30.400 --> 12:32.200
The reason is because of auto boxing.

12:32.200 --> 12:37.080
However, before we get to that part, let's first look at a quick example of what all

12:37.080 --> 12:38.080
of this is.

12:38.080 --> 12:44.160
So here, we have a class called bank account, and we have three fields, three significant

12:44.160 --> 12:45.520
fields, keep in mind.

12:45.520 --> 12:47.920
We have the account number, which is a string.

12:47.920 --> 12:51.840
We have balance, which is of type double.

12:51.840 --> 12:54.120
And then we have a Boolean value called is active.

12:54.120 --> 12:56.520
So again, we're doing the checks here and equals method.

12:56.520 --> 13:02.920
We're doing the casting in line number 17, should I zoom in a bit, line number 17.

13:02.920 --> 13:07.760
And then when comparing the Boolean value because it's a primitive type, we're doing

13:08.440 --> 13:09.440
the equals operator.

13:09.440 --> 13:12.560
We're saying, if it's not equals, return false.

13:12.560 --> 13:18.640
And BA is, by the way, the other object that we've got here after the casting.

13:18.640 --> 13:25.520
And then in the account number, we're using the normal equals method that is in the object

13:25.520 --> 13:27.280
superclass.

13:27.280 --> 13:28.280
And that's fine.

13:28.280 --> 13:34.120
But here, as we've been advised by Joshua Block, we're using the double.compare static

13:34.120 --> 13:40.960
method instead of using the equals method, because, well, by the way, what this does

13:40.960 --> 13:42.840
is it returns a true or false.

13:42.840 --> 13:50.320
Sorry, I should put the proviso that it returns a true or false essentially or for all intents

13:50.320 --> 13:53.080
and purposes in our equals method, because it actually doesn't.

13:53.080 --> 13:57.880
It returns an int value if you look at the method, what it checks for if it's greater

13:57.880 --> 13:58.880
or less than.

13:58.880 --> 14:00.640
And accordingly, it'll return something.

14:00.640 --> 14:05.840
However, if it's not equal to zero, that means there's a difference.

14:05.840 --> 14:07.080
Therefore, it'll return false.

14:07.080 --> 14:13.160
But if it's as in the function of the return false, but if it's equal to zero, that means

14:13.160 --> 14:17.760
it's the same value or it's the same double value.

14:17.760 --> 14:21.560
Therefore, it'll just keep going and return true in the equals method.

14:21.560 --> 14:26.040
So what it looks for is a difference in the two parameters or the two values you pass

14:26.040 --> 14:28.560
to the double.compare function.

14:28.560 --> 14:33.880
But then to understand a bit more why it's better using this double.compare static method

14:33.880 --> 14:39.280
instead of using the double equals operator or the equals method, let's say, it's because

14:39.280 --> 14:46.640
of auto boxing, because if we do use the double equals operator for primitive fields that

14:46.640 --> 14:51.280
are float or double, an auto box will take place where the compiler will automatically

14:51.280 --> 14:57.960
convert these primitive types to the corresponding wrapper class types.

14:57.960 --> 14:58.960
And that is costly.

14:58.960 --> 15:06.840
That's very performance heavy or anti-performance to use a software engineering term.

15:06.840 --> 15:11.160
And that's why Joshua Block states, while you could compare float and double fields

15:11.160 --> 15:16.800
with the static methods float dot equals and double dot equals, this would entail auto

15:16.800 --> 15:21.040
boxing on every comparison, which would have poor performance.

15:21.040 --> 15:25.360
But auto boxing generally isn't a good idea, especially if you're using loops, keep away

15:25.360 --> 15:32.520
from auto boxing because it can be very performance heavy because also it just creates new objects

15:32.520 --> 15:33.600
every single time.

15:33.600 --> 15:41.600
So an example we have here is this int value of type, it's a primitive type.

15:41.600 --> 15:47.280
What auto boxing will do here is convert this int to the wrapper class integer and that's

15:47.280 --> 15:53.520
going to now be an object and any instance of that will create new objects in memory.

15:53.520 --> 15:58.200
And the compiler does that automatically for primitive and wrapper classes.

15:58.200 --> 16:05.880
So that's why it's better to use compare instead of using the equals method for float or double.

16:05.880 --> 16:11.320
And then kind of an ancillary point, a shunt's ancillary, it's still important.

16:11.320 --> 16:14.800
For array fields, apply these guidelines to each element.

16:14.800 --> 16:20.640
If every element in an array field is significant, use one of the array dot equals methods.

16:20.640 --> 16:25.040
And as we're deciding this method, one thing that could come into your mind is what if the

16:25.040 --> 16:29.240
object reference contains null, that is a very real possibility.

16:29.240 --> 16:34.120
So we want to avoid a null point of exception if that happens, if the object reference contains

16:34.120 --> 16:39.600
null and to avoid that, avoid the null point of exception, what we want to do for that

16:39.600 --> 16:44.920
is in fact, use the objects dot equals method where we compare two objects, which is in

16:44.920 --> 16:47.200
the Java util objects class.

16:47.200 --> 16:50.760
So if we take a look at another small demo, it's better looking at code than me trying

16:50.760 --> 16:51.760
to explain it.

16:51.760 --> 16:54.240
We have another class called person.

16:54.240 --> 16:59.760
And again, we have a name of type string, and then we have an age of the primitive

16:59.760 --> 17:00.760
type int.

17:00.760 --> 17:03.920
We have the constructor and then the equals method.

17:03.920 --> 17:09.440
So simply again, same thing, and we're doing the casting chain for the instance, the double

17:09.440 --> 17:11.720
equals operation, all of that.

17:11.720 --> 17:18.560
And then afterwards, in the comparison, we're comparing these significant fields.

17:18.560 --> 17:23.360
It could be possible that one of them could have a null, or in this case, what we pass

17:23.360 --> 17:27.400
this object, we pass onto the equals method.

17:27.400 --> 17:32.920
This object dot equals method will ensure that another point of exception is enthroned.

17:32.920 --> 17:36.960
And that's why when it comes to comparing the name, we are using objects dot equals.

17:36.960 --> 17:38.680
Did I say object dot equals?

17:38.680 --> 17:40.680
I meant to say objects dot equals.

17:40.680 --> 17:41.680
That's important.

17:41.680 --> 17:47.480
And the reason for that is instead of me explaining it, let me just use chatGPT to explain it

17:47.480 --> 17:49.760
better than I ever could.

17:49.760 --> 17:55.480
The object dot equals method is a utility method provided by the Java util objects class

17:55.480 --> 17:56.800
in Java.

17:56.800 --> 18:02.040
It can be used to compare the equality of two objects, taking into account that either

18:02.040 --> 18:04.480
or both objects can be null.

18:04.480 --> 18:05.480
And that's important.

18:05.480 --> 18:08.040
Like the null point exception isn't thrown.

18:08.040 --> 18:13.680
The method will return true if both objects are null, or if the objects are not null,

18:13.680 --> 18:18.360
and the equals method of the first object returns true when called with the second object

18:18.360 --> 18:19.360
as the argument.

18:19.360 --> 18:21.040
So the example for that is seen here.

18:21.040 --> 18:29.960
As you can see, we are passing a null value into person p4, and that returns false as

18:29.960 --> 18:34.160
expected because we're comparing p1 to p4.

18:34.160 --> 18:39.400
And in that comparison, it's clear that there is no logical equality here despite the age

18:39.400 --> 18:41.520
being the same.

18:41.520 --> 18:46.360
And there's also, more importantly, I guess, there's no null point exception being thrown.

18:46.360 --> 18:52.840
And then we get to this concept of canonicalization, which is the idea that in some classes a simple

18:52.840 --> 19:00.360
equality test won't do, especially as Joshua Bloch states for classes that are immutable.

19:00.360 --> 19:06.040
Meaning if an object of an immutable class can potentially change, for logical equality

19:06.040 --> 19:10.680
for or equals method to work properly, we still need to keep a canonical form of that

19:10.680 --> 19:14.680
field somewhere in our class, and we need to store it.

19:14.680 --> 19:17.840
So firstly, what is canonicalization?

19:17.840 --> 19:22.400
And a definition I found probably the best one I could find is really of Wikipedia.

19:22.440 --> 19:27.240
It's a computer science principle, and computer science, canonicalization, sometimes standardization

19:27.240 --> 19:34.440
or normalization, something you hear quite often when it comes to a databases, is a process

19:34.440 --> 19:40.160
for converting data that has more than one possible representation into a standard, normal

19:40.160 --> 19:41.640
or canonical form.

19:41.640 --> 19:47.080
You could probably see that itself hints to that idea that we want the data to exist

19:47.080 --> 19:50.440
in a consistent representation when doing the equality.

19:50.440 --> 19:53.640
And that's why we need to exist in a canonical form.

19:53.640 --> 19:58.760
This can be done to compare different representations by equivalence, like the equals method, to

19:58.760 --> 20:04.600
count the number of distinct data structures, to improve the efficiency of various algorithms

20:04.600 --> 20:10.560
by eliminating repeated calculations, or to make it possible to impose a meaningful sorting

20:10.560 --> 20:11.560
order.

20:11.560 --> 20:17.640
So clearly this CS principle of canonicalization has many uses.

20:17.640 --> 20:24.120
So we're going to look at a demo to exemplify this idea of canonicalization on a previous

20:24.120 --> 20:28.440
class that we designed, which was the case and sensitive string class.

20:28.440 --> 20:34.440
So if you recall, I think in part two, part two or three, when we were discussing symmetry,

20:34.440 --> 20:38.560
we created this class called the case and sensitive string class.

20:38.560 --> 20:43.120
And what we're doing here is really we're storing a canonical field.

20:43.120 --> 20:48.520
We're storing data in a canonical field, which is in this string, we have this private

20:48.520 --> 20:49.520
final field.

20:49.520 --> 20:55.560
So it's going to be immutable called canonical S, which is a canonical string.

20:55.560 --> 21:01.640
And then in the constructor, and we instantiate this class, as we normally set the value for

21:01.640 --> 21:07.640
S, we are also setting the value for canonical S, which converts it to a canonical form.

21:07.640 --> 21:09.480
And what does that method do?

21:09.480 --> 21:11.920
It simply converts everything to lower case.

21:11.920 --> 21:22.400
So in that case, if we go to the equals method, you could see that what we're using here is

21:22.400 --> 21:26.280
the canonical string to check for equivalence relation.

21:26.280 --> 21:34.960
We're not using the other value here, which is S, and that ensures that we have consistency

21:34.960 --> 21:39.800
across the equals method because we have this canonical field that we're using.

21:39.800 --> 21:45.680
And that's why we present the data in that way, despite we know that it can take many

21:45.680 --> 21:46.680
forms.

21:46.680 --> 21:52.200
So of course, apart from having a good quality equals method as soft engineers, what we always

21:52.200 --> 21:54.440
look for is a performance application.

21:54.440 --> 21:59.080
So we want that to be good efficiency in the equals method.

21:59.080 --> 22:02.600
And therefore, just a block towards the end of this section discusses a few things we

22:02.600 --> 22:06.600
can do to improve performance apropos of the equals method.

22:06.600 --> 22:12.280
Firstly, it's important to compare the fields that are more likely to differ or less expensive

22:12.280 --> 22:14.000
to compare, ideally both.

22:14.000 --> 22:17.400
By the way, before we get to the second point, we're going to go through all of this in a

22:17.400 --> 22:18.400
demo.

22:18.400 --> 22:20.400
So first, let's get the theory out of the way.

22:20.400 --> 22:26.200
So the second point is do not compare fields that are not a part of a objects logical state

22:26.200 --> 22:28.440
because we are looking for logical equality.

22:28.440 --> 22:29.520
That's important.

22:29.520 --> 22:32.680
And then need not compare the derived fields.

22:32.680 --> 22:37.440
So these are the three main points when it comes to improving performance on the equals

22:37.440 --> 22:38.440
method.

22:38.440 --> 22:42.880
Now, before we get to the demo, I just want to read the formal definition or the formal

22:42.880 --> 22:44.840
elicitation of Joshua Block.

22:44.840 --> 22:49.480
For best performance, you should first compare fields that are more likely to differ, less

22:49.480 --> 22:51.760
expensive to compare or ideally both.

22:51.760 --> 22:53.960
So that's point one.

22:53.960 --> 22:57.600
If only I can click, there we go.

22:57.600 --> 23:02.160
You must not compare fields that are not part of an objects logical state, such as

23:02.240 --> 23:05.560
lock fields that use to synchronize operations.

23:05.560 --> 23:06.880
You need not compare.

23:06.880 --> 23:09.600
So that's part three.

23:09.600 --> 23:14.360
You need not compare derived fields, which can be calculated from significant fields,

23:14.360 --> 23:18.240
but doing so may improve the performance of the equals method.

23:18.240 --> 23:25.400
If a derived field amounts to a summary description of the entire object, comparing this field

23:25.400 --> 23:31.840
will save you expense of comparing the actual data of if the comparison fails.

23:32.160 --> 23:35.280
So let's look at a demo.

23:35.280 --> 23:37.920
What if we have a polygon class?

23:37.960 --> 23:43.560
Now, this firstly, I want to say, I am not saying that this class of design is an accurate

23:43.800 --> 23:47.800
polygon class, especially when it comes to the calculation of the mathematics.

23:48.160 --> 23:52.840
I kind of did a bit of Googling, used a bit of charge APD and put this together, put this

23:52.840 --> 23:54.120
together, pardon me.

23:54.160 --> 23:56.520
So we have the polygon class.

23:57.120 --> 24:03.440
So sorry, the caveat there was the provider was don't take these calculations.

24:03.440 --> 24:04.160
Don't use them.

24:04.160 --> 24:05.000
They're probably wrong.

24:05.000 --> 24:05.840
I'm not sure.

24:06.320 --> 24:11.560
So do double check before using this class if you want to do the polygon class.

24:12.920 --> 24:14.120
So we have a polygon class.

24:14.120 --> 24:16.400
We have edges vertices as a polygon.

24:16.400 --> 24:19.920
This we have this all the fields here are primitive values.

24:20.240 --> 24:24.920
And then we have a double array called sides with array, array cached or cached.

24:25.240 --> 24:28.320
And then we have the constructor, of course, where we are setting all the values and even

24:28.320 --> 24:33.960
setting the value for a Boolean variable or Boolean field, which checks if the array value

24:33.960 --> 24:34.840
has been cached.

24:35.520 --> 24:39.760
And then in the calculations, the calculation itself, we're checking for we're checking for

24:39.760 --> 24:43.120
the area for a initially for a triangle and a rectangle.

24:43.120 --> 24:45.920
And again, as I said, the formula may be wrong.

24:45.920 --> 24:47.640
So I'm not sure if this formula is correct.

24:48.040 --> 24:54.120
And then also, if necessary, we could use it for other polygons, depending on on the

24:54.120 --> 24:56.320
number of sides, the formula will change.

24:56.840 --> 25:03.120
So but the point is the point pertaining to our item is when we're doing the

25:03.120 --> 25:08.000
equality, we aren't the only thing we really because because we're using a derived field

25:08.000 --> 25:09.400
here, which is the area field.

25:09.800 --> 25:13.360
The only thing we're looking for in the quality is the area value.

25:13.760 --> 25:17.880
We're checking if the if the area is the same between the object we pass.

25:17.880 --> 25:22.680
So the polygon object we pass, which, which for all intents and purposes will be a

25:22.680 --> 25:24.160
polygon object we pass.

25:24.880 --> 25:30.920
And we don't we know things such as the vertices, the edges, many things, even the

25:30.960 --> 25:32.600
obviously things like the area cache.

25:33.080 --> 25:37.920
And if we run this method, you'll see it works as expected because we are looking

25:37.920 --> 25:39.000
for logical equality.

25:40.000 --> 25:45.520
You can see here over here, firstly, comparing a triangle to a rectangle, it'll

25:45.520 --> 25:46.400
return false.

25:46.560 --> 25:47.320
That's correct.

25:47.560 --> 25:49.600
We're setting all the sides in the sides area.

25:50.400 --> 25:54.960
But when we compare a triangle to a triangle, so we have the click to

25:54.960 --> 25:59.040
triangles here, triangle and triangle to it'll return true.

25:59.280 --> 26:03.280
That is because the number of edges and vertices are the same.

26:03.320 --> 26:04.440
So are the sides.

26:04.800 --> 26:07.840
And that is because those values are what gives us the area.

26:08.440 --> 26:10.120
So it's a derived field.

26:10.520 --> 26:15.480
And in the quality all we require to create a high performance equals method is

26:15.480 --> 26:17.520
the derived field value.

26:17.600 --> 26:19.120
In this case, the area value.

26:19.480 --> 26:20.640
I hope that made sense.

26:20.840 --> 26:25.640
So just to repeat myself, to really get the take home point here, it is that we

26:25.640 --> 26:27.840
don't have to compare the derived fields.

26:27.840 --> 26:31.320
I may have misspoken and said we have to before, but we don't.

26:31.400 --> 26:36.120
The idea is the significant field in this class in a polygon class is area.

26:36.480 --> 26:41.680
And therefore we know if the area values are equaled for two objects, that the

26:41.680 --> 26:45.120
vertices and the sides and the edges and all the rest of it is going to be equal

26:45.120 --> 26:48.240
to, and in that way we make our equals method more performant.

26:49.040 --> 26:54.200
Because if two polygons have unequal areas, there's no reason to compare the

26:54.200 --> 26:55.720
edges and vertices.

26:56.600 --> 27:00.000
And that gets us to the final caveats, let's say.

27:00.920 --> 27:02.520
Okay, no, not yet, not yet.

27:02.560 --> 27:03.520
I spoke too soon.

27:04.680 --> 27:05.800
There's a bit more to say here.

27:05.800 --> 27:11.920
So Joshua Block, despite me using many other classes to exemplify this, Joshua

27:11.920 --> 27:16.320
Block has his own class called the phone number class that he's built, which I've

27:16.320 --> 27:18.760
used here too, which is really well built.

27:18.760 --> 27:20.640
It's a high quality equals method here.

27:21.120 --> 27:26.560
And he says, when you're finished writing your equals method, ask yourself three

27:26.560 --> 27:27.320
questions.

27:27.720 --> 27:28.720
Is it symmetric?

27:28.840 --> 27:29.800
Is it transitive?

27:30.000 --> 27:30.960
Is it consistent?

27:31.160 --> 27:37.400
If those three questions are fulfilled, that means, or if they're answered to be

27:37.400 --> 27:40.280
yes, that means it's a high quality equals method.

27:40.440 --> 27:44.600
And then he kind of puts this point, of course, your equals method must also

27:44.600 --> 27:49.400
satisfy the other two properties, reflexivity and nonality, which we discussed

27:49.400 --> 27:54.200
in the previous part, but these two usually take care of themselves.

27:54.320 --> 27:57.520
And then we have the phone number class that is designed here, where in the

27:57.520 --> 28:01.280
phone number class, we have the area code prefix and the line num.

28:01.920 --> 28:05.560
They're all private final short values.

28:08.000 --> 28:12.840
I realize he's used the non primitive type short here because it's a phone

28:12.840 --> 28:15.400
number that helps with saving memory.

28:15.840 --> 28:20.160
I've really not ever used a short method ever short type ever.

28:20.160 --> 28:22.880
I've always used just int, but now that's that's that's good.

28:22.960 --> 28:27.160
It shows that it's very punctilious when it comes to design and classes and

28:27.160 --> 28:29.680
writing code, he pays attention to the small things.

28:30.600 --> 28:34.760
So when it comes to the phone number class, yes, we have the constructor

28:34.760 --> 28:36.000
where we set all the values.

28:36.000 --> 28:38.000
We do a range check in this class.

28:38.000 --> 28:42.920
We make sure that it's within the range using this range check method.

28:44.440 --> 28:48.400
And afterwards we come to the crux of the matter, which is the equals method.

28:48.840 --> 28:50.560
So you can see here what he's done.

28:50.560 --> 28:55.960
He's firstly done the memory reference equality or check for memory reference

28:55.960 --> 29:00.600
and then check for the proper type, the type check and then the casting,

29:01.280 --> 29:05.600
which will be fine because we're doing the type check here.

29:05.600 --> 29:08.160
There won't be any class class exception areas.

29:08.520 --> 29:12.000
And then he's comparing all the significant fields.

29:12.640 --> 29:17.880
And for him, or I guess not for him, even for me, for anyone,

29:18.920 --> 29:21.240
this is a high quality equals method.

29:21.680 --> 29:25.480
And now we get to the final caveats when designing an equals method.

29:25.720 --> 29:31.040
So the first one is always override hash code when overriding equals.

29:32.120 --> 29:36.120
We're not going to get too much into that because the next item is in fact

29:36.120 --> 29:38.360
all on the hash code method.

29:38.920 --> 29:44.400
However, that's mostly to ensure that objects of the class work correctly

29:44.400 --> 29:46.600
in hash based collection.

29:46.600 --> 29:51.920
So objects can be put through a hash function and you want any of these

29:51.920 --> 29:55.560
classes or any of these, yes, classes that use hash,

29:55.880 --> 29:58.680
hash based collections to work properly.

29:59.920 --> 30:03.280
And that's why whenever the equals method is overrided,

30:03.520 --> 30:06.720
we need to ensure that the hash code method is also overrided

30:07.160 --> 30:11.800
and updated appropriately, depending on what we do with the equals method

30:12.120 --> 30:15.200
to make sure these collections and other data structures, in fact,

30:15.320 --> 30:17.320
work well with our objects.

30:17.320 --> 30:20.040
The next point is don't try to be too clever.

30:20.280 --> 30:22.840
Perhaps it's good advice for life itself.

30:23.520 --> 30:26.160
And Joshua Block states, don't try to be too clever.

30:26.160 --> 30:31.560
If you simply test fields for equality, it's not hard to adhere to the equals contract.

30:32.040 --> 30:35.600
If you are overly aggressive in searching for equivalence,

30:35.640 --> 30:37.560
it's easy to get into trouble.

30:37.560 --> 30:42.080
And the example he's given is when it comes to equivalence relation or the comparison,

30:42.680 --> 30:46.640
don't take aliases such as symbolic links into account.

30:46.640 --> 30:51.880
Or the example here is, is the file class has symbolic links

30:51.880 --> 30:57.400
and we shouldn't take that kind of alias into account when doing an equality check.

30:57.560 --> 31:01.880
And a few definitions to understand what the relationship between an alias and a symbolic link is.

31:01.880 --> 31:08.160
So firstly, as Biden has put it, a soft or symbolic link is a file pointer.

31:08.160 --> 31:14.960
So in the file class that behaves as a file that is linking to if the target file gets deleted,

31:15.360 --> 31:17.280
then the link is unusable.

31:17.960 --> 31:19.480
So it's mostly a pointer.

31:19.480 --> 31:24.840
And I think, in fact, charge dpd had a much better explanation than even

31:24.840 --> 31:28.120
well done and I really love well done's blog.

31:28.440 --> 31:32.880
In any case, what charge dpd states is an example of a symbolic link.

31:32.880 --> 31:37.360
Imagine you have a folder called original and you have a large number of files in it.

31:38.040 --> 31:42.480
Now, you want to create another copy of the folder, which is identical to the original folder,

31:42.600 --> 31:44.600
but in another location of your file system.

31:45.200 --> 31:48.160
Instead of copying the entire folder and its contents,

31:48.160 --> 31:53.480
you can create a symbolic link to the original folder and place it in the desired location.

31:54.120 --> 31:58.960
I can access the original files to the symbolic link, which acts as an alias.

31:58.960 --> 32:03.280
So it's that's that's the bit that alias bit or the symbolic link we create

32:03.600 --> 32:07.520
shouldn't be taken into consideration when designing the equals method.

32:07.880 --> 32:09.880
That's a field we should ignore.

32:09.880 --> 32:12.480
And then an example of an alias is, let's say you have an object

32:12.480 --> 32:16.200
A with some properties and methods and you create an object B

32:16.600 --> 32:18.680
that is identical to object A.

32:18.680 --> 32:22.400
Now you can access object A's properties and methods through object B,

32:22.440 --> 32:25.280
which acts as a as an alias for object A.

32:25.360 --> 32:27.160
So that kind of makes is what an alias is.

32:27.160 --> 32:28.880
And this is how you define symbolic links.

32:28.880 --> 32:32.840
So in the files method, we have file, stock, create symbolic link.

32:32.960 --> 32:35.640
We have the link we create and then we have the target.

32:36.000 --> 32:39.760
This link we create shouldn't be used when it comes to

32:40.640 --> 32:43.600
a equivalence relation in I equals method.

32:43.600 --> 32:46.400
That should be ignored and it's not a significant field.

32:46.600 --> 32:48.920
So the final caveat is, in fact, quite important.

32:48.920 --> 32:51.880
Now, the other two caveats are I don't think, at least,

32:51.880 --> 32:54.320
that one would be prone to making those mistakes.

32:54.560 --> 32:58.480
Whereas this most certainly I can see myself making this mistake.

32:58.720 --> 33:03.280
It is that you shouldn't substitute another type for object in the equals

33:03.280 --> 33:08.880
declaration. So as you saw in the equals method as defined in the object super

33:08.880 --> 33:12.320
class, it we all actually, this is a bad example.

33:12.360 --> 33:13.680
This is the way not to do it.

33:13.720 --> 33:17.040
But normally what you'd have here is the object we take in the

33:17.040 --> 33:18.800
parameter would be of type object.

33:19.200 --> 33:21.680
But let's say we define it to be some other type.

33:22.240 --> 33:26.600
This will create some problems because firstly, what this does is

33:26.600 --> 33:30.440
it will the compiler will not inherit the problem implementation of the equals

33:30.440 --> 33:34.320
method. And since the method is strongly typed.

33:34.320 --> 33:38.400
So now we've specifically defined what type we want.

33:38.560 --> 33:40.760
And it can't just be the superclass object.

33:41.400 --> 33:45.680
It'll take objects of a specific class, a specific type instead of object,

33:45.720 --> 33:48.560
which can give false positives, certainly.

33:48.840 --> 33:53.240
And one other point there is the problem with defining the equals method like

33:53.240 --> 34:00.120
this is the method does not override the object dot equals because we do inherit

34:00.120 --> 34:01.840
this from the superclass object.

34:01.840 --> 34:04.560
We do it like this instead of overriding.

34:05.720 --> 34:10.120
It will overload it because the method in the object dot equals class,

34:10.400 --> 34:12.080
the type is object.

34:12.440 --> 34:16.000
And now we've changed it where it's going to be overloaded and the equals

34:16.000 --> 34:19.640
method will still exist in our subclass.

34:20.000 --> 34:21.760
So it'll sort of be like this.

34:21.760 --> 34:26.080
It'll be it'll be this and then there'll be another method.

34:26.960 --> 34:31.360
With object, Java disallowed this because the signature of these two methods

34:31.360 --> 34:33.880
are different. They're both, they've both got the same name.

34:34.000 --> 34:37.200
However, they take in different types of parameters.

34:37.200 --> 34:38.840
So overloading takes place.

34:38.880 --> 34:43.080
And this is a problem again, cause it can mislead the client of our class.

34:43.120 --> 34:47.640
Now, in my opinion, it's always a good habit to use annotations in Java.

34:47.680 --> 34:48.880
I think that's a good idea.

34:49.320 --> 34:54.920
And this is a good example of why perhaps using an annotation is good.

34:54.920 --> 34:58.120
Not for the sake of the compiler, let's say, but more for the programmer,

34:58.120 --> 35:03.040
because what happens here is here, because we explicitly stating,

35:03.720 --> 35:07.160
we're going to override the equals method in the superclass.

35:08.160 --> 35:09.320
This won't compile.

35:09.360 --> 35:10.400
It'll give an error.

35:11.160 --> 35:13.560
It's still broken, of course, but at least it won't compile.

35:13.560 --> 35:16.880
So we'll, you know, pick our mistake and we'll recognize some things.

35:16.880 --> 35:20.880
We've done something wrong here by giving it type my class instead of object.

35:21.720 --> 35:25.720
And I think it's good because now we're saying instead of overloading,

35:25.760 --> 35:30.240
we want it to, we're explicitly stating we want it to override and the compiler

35:30.240 --> 35:33.960
is saying, nope, we can't do this, which is what you'll see here.

35:33.960 --> 35:34.800
So this is demo here.

35:34.800 --> 35:37.920
I have a parent class with a equals method.

35:38.760 --> 35:43.320
And if you look at the child class, this is dangerous because we're doing

35:43.320 --> 35:45.120
overloading here unknowingly.

35:45.360 --> 35:48.640
However, if we do put the override annotations in here,

35:48.640 --> 35:52.520
if we do put the override annotation, it'll throw an error, let's say,

35:52.520 --> 35:57.320
or the override can't take place, can't take place, which then we can fix by

35:57.400 --> 36:01.080
doing it the proper way, which is what I've defined here, where now we have a

36:01.080 --> 36:05.800
proper overriding takes place with the type of object.

36:05.800 --> 36:07.320
So we're taking all the objects in here.

36:08.600 --> 36:09.360
That's great.

36:09.880 --> 36:13.320
And then, of course, that's the end of the item, the end of the part,

36:13.320 --> 36:14.120
and the end of the item.

36:14.120 --> 36:16.240
Wow, that was a long, long item.

36:16.240 --> 36:18.080
It was probably 10, 15 pages.

36:18.080 --> 36:20.200
I feel really good for getting through that.

36:20.200 --> 36:26.160
And I learned so much, but, but, but at the end of the item, Josh Schumburg

36:26.160 --> 36:28.800
states, Hey, look, yes.

36:28.800 --> 36:32.240
Now you know how to design or you have the recipe for a high quality equals

36:32.240 --> 36:32.760
method.

36:33.360 --> 36:34.320
And yeah, it's fantastic.

36:34.320 --> 36:35.000
We learned a lot.

36:35.000 --> 36:38.080
We went through a lot of a bit of computer science, a bit of human logic.

36:38.960 --> 36:44.520
However, most of the time it's a good idea to use the IDE or to use something

36:44.520 --> 36:48.840
like the auto value framework, Google's open source auto value framework, when

36:48.840 --> 36:53.800
designing equals methods, because these frameworks were pretty much take care of

36:53.840 --> 36:56.720
all of these things we discussed in this item.

36:57.080 --> 36:58.520
Look at how long the item is.

36:59.080 --> 37:04.880
Everything from, from, from the properties and, and making the equals

37:04.880 --> 37:06.520
method more performant, all of that.

37:07.280 --> 37:14.000
Which is why Josh Schumburg states, an excellent alternative to writing and

37:14.000 --> 37:19.400
testing these methods manually is to use Google's open source auto value

37:19.400 --> 37:24.280
framework, which automatically generates these methods for you triggered by a

37:24.280 --> 37:26.360
single annotation on the class.

37:26.960 --> 37:32.680
And then he also says, having IDEs generate equals and hash code methods

37:32.680 --> 37:37.240
is generally preferable to implementing them manually because IDEs do not

37:37.240 --> 37:38.360
make careless mistakes.

37:38.360 --> 37:39.880
And of course humans do.

37:40.560 --> 37:41.680
That's the end of the item.

37:41.840 --> 37:46.440
And then he states, in summary, don't override the equals method unless you

37:46.440 --> 37:52.120
have to, in many cases, the implementation inherited from object does exactly

37:52.120 --> 37:52.760
what you want.

37:53.000 --> 37:57.880
If you do override equals, make sure to compare all of the classes, significant

37:57.880 --> 38:03.360
fields, and to compare them in a manner that preserves all five provisions of

38:03.360 --> 38:04.480
the equals contract.

38:05.400 --> 38:06.000
Fantastic.

38:06.280 --> 38:10.280
I'm so happy that I got through that, especially because I feel like I learned

38:10.280 --> 38:14.160
a lot when we were going through that item because it touched on so many

38:14.160 --> 38:16.720
different concepts, which was a really fun item to cover.

38:17.040 --> 38:21.440
And the next one is item 11, as I did state a bit before, always override

38:21.440 --> 38:24.840
hash code when you override equals.

38:25.280 --> 38:27.560
And I shall see you in the next one.

38:27.680 --> 38:28.320
Thanks for watching.

38:28.520 --> 38:29.000
Cheers.

