start	end	text
0	4480	Hey everyone, welcome to this second episode of the video series that I've very
5040	13960	Incipitally and uncreatively called textbook to code where I take software engineering and computer science principles from textbooks and
14800	21680	Convert them to code and expound on them and try and make sense of them in as much detail as I can manage
22400	26760	and the book I've picked for this well, I guess for the start of this series is
27480	34920	Effective Java by Joshua Block certainly the best programming book I've read so far and the book's got I believe
35160	38920	90 yes 90 items and we're still on item two
39480	42520	So I'm sure it's gonna take me a long time to get through the whole book
42600	45400	But that's what's exciting about this because I I feel like
46280	49480	One item leads to another item and that item leads to another item
49880	56040	And that would point to some design pattern that would point to some concept in Java or you know computer science in general
56600	58600	and I find that really interesting and
59240	64840	Really, I hope a lot of a lot of programming books and especially well written the way this book is written
65240	70280	By Joshua Block saying that though as per usual as I did do in the previous episode
70920	73800	I want to make a few caveats or have a little bit of a proviso
73960	77000	So if you did watch the previous episode you can skip this bit
77480	81320	Because I'll pretty much be repeating the same thing for any new viewers
81880	87640	Uh, the first point of course is this is not a tutorial. So unlike many
88200	93960	Programming videos on youtube. I certainly don't want this to be a tutorial. I'm not a teacher
94440	96440	definitely not an expert
96440	98440	and I'm not trying to
98840	102840	Tell you how something is done really what I'm doing is
103720	107960	Collectively trying to make sense of certain concepts in this book
108440	112760	And trying to understand them it really in many ways is a selfish pursuit in that sense
113240	119160	Because I'm not trying to teach anyone. I'm just trying to make sense of it and you know along the way if you get value from it
119480	124680	Fantastic, that's at least what I hope frankly. I like to think of it as blindly leading the blind
125320	130280	Uh, but in this case really I'm not leading but I guess because you're watching this video in some sense
130360	134200	I am but uh, I am as blind and ignorant as you are
134760	136760	Uh, it's this is simply a
137320	144200	Exploratory disposition. That's it. Uh, and I think what I want this to be is is similar to what
144840	146040	We would do what I mean
146040	152840	We if you've done a computer science or software engineering degree in a university tutorial where you get together
153320	154440	There is a tutorial of course
154440	157320	but generally what happens is you get together with your mates with your
158040	162920	The other students and try to make sense of some assignment problem or some programming problem
163720	166840	And I think there's great learning that happens in that kind of
167480	173400	Collaborative collective thinking and needless to say but I have to say it because this is a proviso for all
173880	179720	I will inevitably make mistakes. So please point them out. Leave them down in the comment section below
180360	184600	Of course for my own learning, but especially because I don't want to mislead anyone
185080	188840	And I think that's why in every single video, even though it's going to get a bit repetitive
189240	193720	I am gonna have this bit where I do say, please don't think of this as a tutorial
194040	197160	I don't think I'm in a place to teach anyone programming at the moment
198040	201960	And on the note of programming, of course, this is a programming video
201960	206200	So, uh, it only makes sense to have all the code that I use on get up
206600	209000	Not only my code, but I'll also link
209800	212040	All the code that Joshua block has
212920	215080	Published on his personal get up repository
215560	221480	For item two of effective java. So on that note without further ado, let's get started
222200	228760	The second item states consider a builder method when faced with many constructor parameters
229160	234600	Personally, I found it much easier to understand this item than the previous one. It made a lot more sense
235160	237960	Probably because I have faced this problem
238520	240520	Day to day working in my team
241080	247080	Where there's mostly a utility class with a whole bunch of parameters for constructors
247800	252440	And it can be a real pain to manage and even using it as a client can be
253560	255720	It's quite chaotic at times and quite a mess
256440	258040	So he states
259560	262760	Static factories and constructors share a limitation
263160	267240	They do not scale well to a large number of optional parameters
267800	271640	So of course, I don't think I need to go into detail on what optional parameters mean
272040	274760	The term itself is self-explanatory
275400	280840	And over here though, this example kind of demonstrates that even though what we've done here is use the
281480	283480	telescope constructor pattern, which
283560	287320	Joshua block says is a bad idea that it probably shouldn't be used even though
288120	294680	This is what traditionally programmers have used and in fact in the codebith that I'm working on right now in my current company
295000	297000	I believe this is what we've done. Oh
297400	302440	Well, I think we did this in a previous version, but we did change it up. So that's that's really good
303000	309640	Um, and this is what this really does is as you can see here. I have two instances of the nutrition facts class, which is
310520	313720	Uh, this class here. It's got a bunch of privately defined
314280	316280	member variables and
316760	322920	This is the bit that sort of implements the telescope constructor, but I'll get to that a bit later the idea being
323880	326760	Both these instances Koch and Bundaberg
327320	333960	They've got different number of parameters have been passed into it because of course some optional. In fact, I think most optional
334440	339960	Uh, and depending on how you want to build it how you want to construct your object. You can define it
340520	344040	So now let's go to the bit where dorsal box says
345000	349640	Traditionally, as I did say before programmers have used a telescoping constructor pattern
350280	354440	In which you provide a constructor with only the required parameters
355160	357880	Another with a single optional parameter
358280	360280	a third with two optional parameters
360760	361960	And so on
361960	365800	culminating in a constructor with all the optional parameters
366200	371720	So these two objects Koch and Bundaberg which both are instances of the nutrition facts class
372360	375880	The Koch object is pretty much using all the parameters
376680	379960	It's using this constructor here. Oh, sorry this constructor here
380600	386200	And then the Bundaberg object, which is just using only three optional parameters. We've said which uses
386920	388920	this constructor here
388920	396280	Regardless, you probably can see what I'm doing now. We've passed a lot of zeros. It's unnecessary and even on the client side
397160	403800	Or on the client that's using this constructor has just passed zeros sometimes when for the value fat
404520	410040	Uh, and you know, it's not that complicated if you look at the code base, you can see that it's firstly
410120	414040	It's very verbose just just the constructors itself in the beginning of the class
414680	421000	You got God knows how many I mean here. There are only six parameters, but imagine if it's a class with 20 30
421640	424200	member variables or whatever you want to you want to set
425160	427160	when you know constructing that class
428040	430040	Constructing that object, sorry
430440	435400	And as Joshua Bock says in short the telescoping constructor pattern works
435640	436840	Of course it does
436840	440520	But it is hard to write client code when there are many parameters and
441000	443000	harder still to read
443000	447000	He also states and this is kind of funny. This is uh, I recently tweeted
447800	451240	That I like to call myself a programmer, but IntelliJ
452120	454200	writes most of my code for me
454520	456520	So I don't really do anything anymore
456920	460680	Than just using autofill and IntelliJ kind of taking care of everything else
461720	465800	The id that the modern ids are so good that this problem doesn't really apply anymore
465880	470440	I think because he says here if the client accidentally accidentally
471080	477080	Reverses two such parameters the compiler won't complain, but the program will misbehave at runtime
477480	482280	So what he means here is you probably can see, uh, let's take this second object
482920	484360	Bundaberg
484360	486360	Bundaburg object
487240	493080	And what we need to pass as the first parameter is the serving size and then it'll get it'll get set properly
493720	495000	in the class
495000	495960	member
495960	498360	And then there's servings and calories. So let's say
499160	506360	You said the serving size is two and servings as 360 that is wrong, but the compiler won't complain
507080	512440	The error will only come up at runtime. Maybe the q18 will pick it up or some unit test. Who knows?
513080	515080	um, but
515240	521640	Of course with i with IntelliJ or most modern ids that problem won't be an issue because when the client is using that constructor
521800	527080	It does exactly say what you're supposed to pass. So it's pretty clear and explicit, but nevertheless
528040	532120	That's one downside of it and we shouldn't always rely on ids
532680	533080	um
533080	538840	The negative of course is the problem is scaling and also just passing these useless zeros into constructors
538920	542680	So and it's fair to say arguably, uh, the telescope constructor is an anti-pattern
543000	546280	Where our class has multiple constructors with different signatures
546920	548920	varying parameters in particular and
549320	551320	I believe if you do just google the word
551960	556840	Constructor pattern, there'll be a lot of blog posts regarding why it is an anti-pattern
557560	559480	um
559480	566200	Look at this just the the top searches are regarding alternatives to the telescope constructor pattern it being an anti-pattern whatnot
566840	572840	um, and even this video here saying avoid telescope telescoping constructors with build a pattern
573880	578840	Makes sense. Uh, probably a lot of these blog posts were inspired by Joshua Bloke himself
579000	583000	That moves us to something probably a bit better than the telescope constructor pattern
583560	585560	The java beans pattern in this pattern
585880	586920	you call a
586920	593800	Parameterless constructor to create the object and then call setter methods to set each required parameter
594280	597960	And each optional parameter of interest. So let's see what that means
598360	604440	But before we get to that, I just realized I should expound on these two points. It'll just make things a bit more easier. Um, now
605160	608760	Java beans, what is java beans? We we hear this term everywhere if you're a java developer
609400	611400	All that is is a standard
611560	617960	It gives a class an empty constructor with getters and setters. Um, a public sorry a public
618760	620760	argumentless argumentless
620760	623240	constructor and it's also serializable
623960	630120	Even though this is what a java beans is the java beans pattern still isn't the most apt
630840	632280	pattern to use
632280	635880	when faced with many constructors and as Joshua Bloke him
637080	641080	I'm going to start calling him JB. It's just easier because Joshua Bloke is a mouthful
641160	647480	So as JB himself states the java beans pattern has serious disadvantages
647880	650440	So I did read out the definition of what this pattern is before
650840	655880	This is really much easier to even understand conceptually than the telescoping constructor pattern
656680	661720	Clearly what you're doing here. So we've got another class. We've got a class called nutrition facts JB
662200	664200	Um, why do I call it JB?
665640	669080	I don't know why it's oh, of course because it's uh java beans
669400	676600	I I wanted to call it JB just to differentiate it. I guess and we've declared or we've defined the
676760	678760	empty public constructor here
679000	686040	And that allows us to create a coca-cola object of this from this class and simply using the setters
686920	691000	I've set all the values. So whatever the members are serving size
692040	694040	calories whatnot
694360	701000	And yeah, it's as simple as that. That's what it does. However, as I said before, this is not a good pattern to use
701400	703960	when one is given a class with a lot of
704920	706920	constructor parameters
706920	710360	Firstly, of course, you know practically speaking as you can say it's a bit verbose
710600	712920	It's it's it's just to create this object
712920	716760	You got to do all these things and use setters and set the values kind of annoying
717240	723880	Uh, and the second one and this is an interesting one. I'm going to first read out the paragraph and explain what JB means by this
725720	733000	The class does not have the option of enforcing consistency merely by checking the validity of the constructor parameters
733640	737960	Attempting to use an object when it's in an inconsistent state may cause failures
738280	743000	That are far removed from the code containing the bug and hence difficult to debug
743560	746520	A related disadvantage is that java bean's pattern
746840	749400	precludes the possibility of making a class immutable
749800	755720	And requires added effort on the part of the programmer to ensure threat safety. What that really means is this it's
756360	760440	and I'm again, I there are all these terms some of these terms are a big technical
761400	762200	and
762200	768440	But I'm quite sure, you know, I'm not a senior java and programmer who's been coding for years and years
768520	771320	I've only really been coding for a couple two or three years
771720	773720	But I've I've still seen things like this
774520	776280	day to day at work
776280	777400	so
777400	778920	over here you
778920	783800	Initially construct the coca-cola object with the empty construct empty constructor
784360	790200	And then you say you set the value using a setup set serving whatever and then you say set servings whatever
790440	793720	Set calories whatever and then let's say while
794360	799720	This object is in the process of being constructed. It's it's it's in a certain state
800760	804680	Someone decides to do some computation here using this object
805720	807880	So decides to do some computation
808440	809800	using
809800	811800	This object coca-cola
812120	814920	Now this can give us a lot of problems because the class
815480	816680	doesn't
816680	817880	mandate
817880	821000	For the object to have a consistent state when it's being created
821560	823240	because let's say
823240	829400	When this computation takes place these two values set sodium and set carbohydrate are necessary
830760	833560	And most of these errors will only be called runtime
833800	836040	It cannot be called compile time clearly
836360	841800	It cannot be called compile time because if I just go and let's say do something here system. I'm just gonna print this out
841800	843800	I know it's really not a computation
844280	850200	But it doesn't throw any errors here the id doesn't indicate that all this this this object is in an inconsistent state
850920	854040	And this is a in my opinion when I did
854600	861400	Understand what this is. I think it can be a serious disadvantage, especially in large enterprise level
861800	866040	Systems, which is mostly what chava is used for, you know, in like distributed systems
866440	868920	And he is just to reiterate the point jebi makes
869480	872840	Attempting to use an object when it's in an inconsistent state. So
873640	876520	Let's just assume for all intents and purposes
877320	884520	At best level this critical object is in an inconsistent state. We don't want it to be in that state and be used by a client
886920	891880	Make us failures that are far removed from the code containing the bug and hence difficult to debug
892200	896760	I don't make sense because they're runtime errors and we all know that runtime errors are quite difficult
897560	899560	to debug
900520	905400	And in my notes, I've stated here with a bit more brevity compared to the long-winded way I explained it
906120	911800	Splitting the construction to multiple parts may put the java being in an inconsistent state
911960	916760	So clearly the construction is being split into multiple parts and there's a high possibility
917560	919560	That it could be in such an inconsistent state
921000	922840	Which is why
922840	924440	JB proposes
924440	926440	Using the builder pattern
926440	931400	Now what is the builder pattern? So let's try to understand firstly. There's a quote that I've got here by
932040	935720	But the great book uh from from the great book design patterns by the gang of four
936040	943080	I haven't read that book yet. I I own a copy. I refer to it, but I'm I'm really hoping to do a similar video with that book too
944280	946600	Probably I'll probably get I'll probably do this
946840	949320	But first the head first design patterns
949960	955240	And then I'll see if it's worth doing one of that book too. I'm just gonna do it. I'm just gonna do it
956440	962360	Because I want to because I'm a I'm a fan. I'm a I'm a connoisseur of great programming books
963800	965880	So here's what the gang of four states
966600	970920	What the builder pattern does is separate the construction of a complex object
971640	977960	From its representation so that the same construction process can create different representations
978440	984440	Okay, what in the world does that mean? Let's take a look at another way the nutrition facts class
985160	987160	Was constructed but in this case
987720	992760	Using the builder pattern on the client side using the builder pattern on the nutrition effects class
993160	995320	Constructing the objects using that pattern
996280	1003080	It's done beautifully. It helps us to circumvent some of the disadvantages that we discussed earlier with the previous patterns
1003800	1005240	But saying that though
1005240	1010600	Of course, it's a bit harder to understand as to how it works. The first thing to keep in mind is
1011560	1014360	There's an inner public study class called builder
1014360	1019480	So the separate builder class in the nutrition facts class and when we do construct this object
1019480	1025000	There's no way of constructing it without using this builder class the the inner builder class
1025560	1031000	Let's run go through this line by line. I think that's the best way to understand this when we do construct this object
1031720	1036680	We don't directly use the nutrition facts class. We instead
1037640	1043320	Make the desired object using this inner builder class and of course because it's static
1043560	1047880	You could just access it as it belongs to the nutrition facts class itself
1048680	1052760	You could access it directly. I mean so simply put the way the client
1053160	1058920	Really constructs this object is using the builder object and the builder object has some setup methods
1059320	1061320	How does that work? So let's take a look at this
1062360	1063400	it's got
1063480	1065960	nutrition facts our builder and of course
1066440	1072840	There are some parameters that are mandatory you you need them to even construct this object and those the those two are
1073560	1077160	In this the builder class is serving size and servings
1077720	1079720	So that would be defined here
1080440	1082840	When we do the constructor for the builder class
1083320	1088040	Have these two values as being mandatory and afterwards, of course, it allows us to
1089000	1093880	Simply set the other values as per our requirements as for the client's requirements
1094280	1098440	So in the for coca-cola, we've set the calories the calories are right here
1099720	1101720	And then we've set
1103160	1107960	Oh, there's another thing I want to add here. Do we get to that a bit later?
1110280	1114600	Oh, sorry, there's a bit here about invalid parameters. We shall get to that a bit later
1115080	1117720	So we are adding the calories and the way we're adding the sodium
1118280	1120280	carbohydrate, whatever
1120600	1123480	And those stuff are being passed on to the private
1124280	1129160	constructor construction Jesus the private constructor of the nutrition facts class
1129960	1132840	And it's been accessed through this builder object
1133880	1140280	Then afterwards when the the client is done using or the client is done constructing
1140680	1145640	The coca-cola object you simply use the build method and build the object
1146520	1148840	quite straightforward if you think about it and even
1149960	1155560	Practically or conceptually this makes a lot of no sense. And yeah, I should mention this the client calls a
1156200	1158200	Parameterless build method, which I did mention
1159000	1164200	To generate the object which is typically immutable and now I want to get to that bit that I said I'll discuss a bit later
1164920	1169320	Previously, it's this idea about having valid parameters
1169640	1176360	Here's a good example of this in the builder class. So the only role for the builder class is to really build objects
1176920	1179480	therefore in all these methods one could do
1180440	1183320	checks for invalid parameters and throw
1184120	1191640	Illegal argument exceptions if for instance when building this class. Sorry when building this object someone passes a
1192920	1197160	Parameter of a or an argument which is of illegal typo
1197960	1200360	If it's of illegal quality
1201400	1203400	I'm just looking for the word here doesn't matter
1203960	1207720	Sometimes sorry. It's been a long day my mind my mind my mind brains everywhere
1208520	1210360	Here's here's an example of this
1210360	1216920	So calories, of course anything can't really have negative calories. At least that's what we're told
1217560	1219720	And I think that's true. So over here
1219800	1225800	I've initially I've passed the calories to be 100 when constructing this object and I'm doing a check
1227160	1231000	On the calories method, which is here in this method
1231880	1233880	whether the value is
1234440	1238920	Well, the value should be greater than zero for me to set it into the calories
1240120	1241480	member variable
1241480	1247000	If not, I'll throw a illegal argument exception. So if I go
1247960	1249960	And do minus eight
1251320	1253320	And then if I try to run it
1254120	1261880	There we go at runtime, I'll say, you know, it's negative. You can't have negative calories. What are you crazy?
1262200	1264600	What are you trying to sell one of those?
1266040	1268040	Fit teas on instagram
1269480	1274440	I'm just I'm trying to make a joke and be funny, but that was just a terrible joke
1275000	1276840	pathetic
1276840	1278840	uh, so Joshua block says
1279640	1282520	To detect invalid parameters as soon as possible
1283000	1289320	Check parameter validity in the builders constructor constructor and methods. So that's what I've done here pretty much
1290120	1295480	Check invariance involving multiple parameters. So this is again, I'm checking this parameter here
1296920	1301560	Do the checks on object fields after copying parameters from the builder if a check fails
1302120	1304120	Throw an illegal argument exception
1304440	1307480	Whose detail message indicates which parameter is invalid
1307800	1313720	That's that's actually a good point because it even tells us specifically here where it's failing. So we know
1314520	1320280	Debugging is much easier that that that's a best way of putting it because if you do recall with the
1321320	1322600	previous two
1322600	1324600	patents a big issue is
1324840	1330920	Even if something fails on runtime the debugging can be a lot more harder and much more deeply in the code that is
1331720	1338360	Not gonna make programming easy and of course if I didn't already state before the code is a lot more neater. It looks prettier
1339160	1345080	You could use method chaining keeps the code concise and very importantly. We don't run into that problem of having
1345880	1347880	objects uh in
1348520	1352040	Inconsistent states like we would do with the java beans pattern
1352440	1357640	Because that isn't allowed here because you need to chain all the methods when constructing the object
1357720	1361720	And certainly method chaining is something we see a lot in different jdk libraries
1362280	1364840	It's most probably because they've used the builder pattern
1365400	1368440	Which is why for us using them. It's a lot more easier
1368840	1373800	And then jb states the builder pattern is well suited to class hierarchies
1374760	1379320	Use a parallel hierarchy of builders each nested in the corresponding class
1379800	1381800	Abstract classes can have abstract builders
1382280	1386680	Concrete classes can have concrete builders. This was a bit hard for me to get it
1387160	1391160	I wouldn't say it was hard for me to get but there's one certain part which I'll get to a bit later
1391560	1393160	involving generics
1393160	1396840	Which I had to really struggle to get my head around it
1397560	1402520	But once again, though it does once you once it does make sense once it once it clicks
1403480	1406920	You can see the beauty of the builder pattern in it and that's the best part about it
1407000	1412680	So let's try to understand what he means by the builder pattern is well suited to class hierarchies
1413000	1417560	Firstly, I'll simply define or explain this class hierarchy. I've built here
1418040	1422600	We have a simple abstract pizza class which I've defined here as you can see
1423160	1427320	And then we have two subclasses that inherits this class. We have calzone
1427720	1431480	Which extends which is a concrete class that extends the abstract pizza class
1431960	1437400	And then we have we have sorry new york pizza, which is also another concrete class which extends the
1437960	1441720	abstract pizza class and afterwards if you do go to the client you could see
1442280	1446600	How it's been implemented and again, I know this is a very high level, but I'll go into the details soon
1448200	1450200	Similar pattern if you do run it
1450200	1455720	You'll see both these objects being have been created and I'm getting the superclass
1455800	1460200	It's both got the same pizza superclass make sense similar pattern
1460680	1463160	ending with the build method so firstly
1463480	1468840	Let's take a look at the pizza class the pizza abstract class and see what's going on here
1469480	1473640	In the similar way because we're using the builder pattern. We have another inner
1474440	1476440	static builder class
1476920	1479880	But you probably see it's a bit more different
1480440	1485240	We need to allow something called a simulated self type now
1485320	1487160	This was the bit that
1487160	1494280	Took me a bit to grok and make sense of because it involves using generics and it's doing something called a
1495000	1497000	simulated self type
1497480	1499480	What what does that mean?
1499480	1503160	Let me see if I could explain it. I would say I got it, but
1504040	1506040	I think I'm I'm still struggling
1506200	1508200	to articulate it clearly
1508200	1510600	And and let me let me let me give a shot
1511320	1516600	So I didn't get what a simulated self type was from effective java. I couldn't understand it
1517080	1519080	and then I found this great
1519320	1521320	blog post by
1521800	1524280	This gentleman's name is nicolai palok
1525000	1527000	Fantastic article. It was written in 2016
1527480	1529480	Pretty much goes into everything you need to know about
1529880	1535000	The idea of java not having a a self method or it doesn't allow us
1535800	1539640	Self and this those two keywords are a bit different. We will I'll I'll get you that too
1540200	1543320	Um because java doesn't have that we sort of have to simulate it
1543400	1546120	And that's what just your block is doing in this example
1546520	1549640	But also what one would generally do uh to get a self type
1549880	1556040	And it's important to understand. Oh if we didn't do the simulated self type
1556280	1561400	We may have to use casting and that is not going to work because it's very important to understand
1561880	1564680	that for the builder pattern to work with the
1565800	1569320	Method chaining which I have where where's an example?
1571960	1573640	Nope
1573640	1577640	Always when you need an x. Oh, yeah. No, that's not the exact that's telescope construct
1577640	1582760	Yeah, for this method chaining to happen the proper type or the proper subtype
1583320	1586120	Have has to be passed. Uh, sorry has to be returned
1587000	1591880	And in the hierarchical, this is a bad example. I should be using the hierarchical builders one
1592280	1597080	Yes, over here in the class hierarchies the proper subtype has to be returned
1597560	1602040	For this method chaining to work. So what a simulated self type does
1602840	1604840	is these subclasses so
1605800	1608760	In this instance, it's new york pizza and calzone
1610760	1615400	They can get an instance of their own type instead of the parent and and again
1615640	1618120	I know i'm sort of beating on a dead horse here
1618120	1621720	But it's important to understand that for this method method chaining to work
1622040	1624040	They have to get a instance
1624600	1628280	Of their own type not the parent not the abstract class pizza
1628760	1634120	New york pizza has to get a an instance of new york pizza or of of type of
1634760	1638600	Subtype the new york pizza and before I do a deep dive in the code
1638840	1644280	I want to read these excerpts from nickolai palogues a blog post the recent being again
1644360	1647000	I think it's important to first conceptually understand
1647800	1653960	What a simulated self type is what's the reason for it and its justifications. Let's say so
1654680	1659160	Nikolai states a self type refers to the type on which a method is called
1659720	1661720	more formally the receiver
1662200	1664360	But java doesn't have this feature. So
1665240	1667480	In here the self type would be
1669560	1673320	Why can't I what do I keep losing that that that class or that bit of code?
1674440	1676440	Bloody annoying
1676840	1678840	Where is it?
1679560	1681560	There we go, you son of a bitch
1681720	1685320	Um, so here this in the method chaining
1688440	1691000	On which method is called more formally called the receiver
1692280	1694280	a self type so
1694520	1702360	The receiver should get new york pizza type, but java unfortunately it doesn't have this particular feature of a self type
1704680	1706680	If a soft type
1707080	1709080	Is used in an inherited method
1709400	1714920	It represents a different type in each class that declares or inherits that method
1715480	1717480	Namely that specific class
1718040	1721080	No matter whether it declared or inherited the method
1721800	1727880	casually speaking it is the compile time equivalent of this dot get class or the type of this
1729640	1730840	I think
1730840	1736200	Well, I was gonna say I think that's quite straightforward, but it probably will be quite straightforward once we
1737000	1740200	Look into the code base. Let's start off with the abstract class
1740200	1745720	It kind of makes sense because the subclasses are going to inherit this. So we have this pizza constructor method here
1745720	1747720	Oh, I want to state one thing. Um
1748280	1750600	I will not go into detail on this bit
1750840	1755480	But because we will be discussing it in a future video in item 50 to be
1756040	1762840	Uh specific, but the idea is that over here in line number 33. We are making what one would call a defensive copy
1763480	1765480	this is just to ensure that
1765640	1770120	The encaps and encapsulation of this class is in broken that that fundamental
1770680	1774120	OOP principle isn't infringed upon we
1774680	1777240	Stick to our principles. So as OOP programmers
1777800	1782200	So what this does is when the native class changes immutable objects feel
1783080	1788680	A defensive copy should be made anytime it's passed into a constructor like this or out of the class
1789240	1793880	When the object of this class will be created this topics member is what's going to change
1794040	1795800	It's going to be mutable
1795800	1799960	Because in the add toppings method it's it's being changed essentially
1800680	1803000	And and that's why we create this defensive copy
1803560	1805720	again, I'm not going to go into detail firstly because
1806600	1811640	I think this is a bad example to understand it. It even took me a while. I had to go through some blog posts
1812200	1817560	But also because we will be discussing that in the future and when we do get to item 50
1817720	1822440	Which probably is going to be next year. I shall leave a link to that video in the description too
1822680	1825800	In any case, I don't want to go off on our tangent because I want to focus on the
1826520	1829000	Simulated self type. So pizza dot builder
1829880	1831880	Is a generic type that would be
1832920	1834920	Here when we do
1834920	1837160	construct the builder object
1837880	1844440	Uh, it's a generic type with a recursive type parameter. That's a confusing bit because well, it's called a
1845000	1851320	Recursive type parameter because as you can see pizza dot builder is extending the builder with its own
1851720	1853720	generic type parameter
1854600	1861160	And and I've even left a comment here saying that this the the generic type parameter here is necessary for the training to work
1862280	1865320	And same comment I've left here. It allows to
1865880	1867880	simulate the self type
1867960	1869720	And just a box says
1869720	1873720	this alone with the abstract self method that would be this
1874520	1878360	And this will be overridden by the subclasses
1878920	1885240	Because it's in fact, this is probably a bit more easy to understand because it's called self sort of makes sense
1885640	1891960	This is what gives the subclass an instance of their own type instead of the parent instead of pizza. So
1892760	1898440	Uh, new york pizza would get an instance of their own type instead of the pizza type
1899560	1903720	However in combination with this bit here the recursive
1904520	1906520	Uh, sorry the simulated
1906600	1911880	Man the recursive self parameter. This is really annoying because it's it's it's really how to get your head around it
1913080	1914760	and this
1914760	1916760	abstract self method
1917320	1918920	It allows us
1918920	1923880	For method training to work and this is the key point without the need for casts
1924200	1930600	You probably remember I showed an example before which was this. So let's assume this extends some
1931480	1933480	Superclass called super person
1935400	1937960	And here when this does return it
1938760	1942680	It shouldn't it if you don't put the cast it will return
1943240	1950040	Uh, a type of super person not person and which is why the cast is required here. However in our case
1951000	1956280	When we're using the bill of pattern because of this abstract self method, we don't have to do that
1956280	1964280	We don't have to use the casts and I shall show you now in a subclass. So let's use new york pizza where this happens firstly
1965560	1969320	We we pass the proper subtype of this class to the generic parameter
1969720	1971160	That's for sure
1971160	1974920	And then we have this bit here where the overriding takes place
1975400	1981880	Of the self method where it returns an instance of the subclass of new york pizza and not pizza
1982440	1984440	And in that way as we do use the
1985160	1990040	The method training and finally the build method returns the correct subclass
1990680	1996920	It will not which it's clearly over here. It's saying return new new york pizza of this instance
1997560	2001960	So this is what allows it all to beautifully come together when we do use it
2003800	2005800	Over here with the method chain
2007400	2008600	I don't know
2008600	2013800	How well of a job I did at explaining that it is a difficult concept to grasp especially the
2014360	2016360	the recursive type parameter I
2016440	2019720	I still I'm struggling to understand that really from something honest, but
2020440	2021720	um
2021720	2024360	Maybe in the future videos I should consider
2025480	2026760	Coming up with
2026760	2029240	Married examples not just this particular example
2029240	2033880	But trying to even create because this this this some of this code I got from joshu blocks get up repository
2034440	2038840	Uh, well most of it in fact, so I should probably try and create some examples on my own
2039320	2041320	Which it'll make it easy for me to
2042120	2043400	Expand on
2043400	2045240	in any case, um
2045240	2051240	JB states this technique. It's sort of funny. Sometimes I refer to him as JB sometimes as joshu block
2051800	2057480	What am I doing the perpetual contradictions? I'm just going to stick to joshu block. I changed my mind jb
2058440	2061960	joshu block sounds better. It's it's it's got a beautiful name. What can I say?
2062440	2063640	um
2063640	2069720	This technique wherein a subclass method is declared to return a subtype of the return type
2070040	2074200	declared in the superclass is known as covariant return typing
2074680	2079640	It allows clients to use their builders without the need for casting covariant return typing
2080680	2082680	To be honest, isn't that hard to understand?
2082920	2087800	Um, and what we're really doing here is covariant covariant return typing by getting
2088920	2090920	uh
2091320	2093160	A subtype of the return type
2093160	2099400	So if you go to simply if you go here, I have two classes. I have the class. I created two classes
2099640	2105160	Oh, also, uh, thanks to this stack overflow user who helped me understand this
2105640	2109480	The person's name is the person also gets into something called contra variants
2109560	2115960	But we shall not get into that because it's not that apt to java. Uh, however, it's just an interesting engineering
2116920	2118920	uh, opsof opsof programming
2119480	2120840	concept to
2120840	2122040	understand
2122040	2126280	This user hard coded thanks to this user on stack overflow. I shall leave a
2127160	2130840	Link to the answer down below in the comment section. Sorry in the description
2132440	2134120	so
2134120	2136120	Here's simply what covariant
2137400	2138920	um
2138920	2140920	What was it covariant return
2141000	2142200	typing is
2142200	2144760	We have a class called author, uh, and this author
2145480	2151080	Has this method. So it's got a private member field called name and then of of type object
2151480	2153720	And then you have another method called get author name
2154680	2161400	Simple as that and then we have another subclass uh, distevsky my favorite author who extends the
2162040	2164920	Superclass author, uh, and here we're setting
2165640	2169800	Another private member variable with the name field order stavsky
2170680	2174280	And here we are returning a subtype
2175080	2177080	because string is a
2177640	2182920	Subtype of object of the object class because think about it. This is this is covariance because
2183480	2188520	While they just return a subclass of the return type, which is again object and string as I
2189000	2195320	Describe before it still fulfills the contract of author dot get author name. This contract here
2196040	2198040	Is
2199000	2201000	Fulfilled
2201000	2204600	This is what covariance is and the same concept of course applies
2205320	2207320	in the hierarchical classes
2207880	2211720	With the builder pattern because this returns a subtype of
2212280	2215320	Sorry, new york pizza. Let's say that class returns a subtype
2216120	2218120	It is a subtype of
2218120	2222600	Uh pizza and it does fulfill that contract down the the method chaining
2223080	2225800	If that makes sense and to conclude just your block states
2226280	2229400	the minor advantage of builders over constructors is that
2230040	2232040	Builders can have multiple
2232680	2239320	Parameters because each parameter is specified in its own method make sense. Um, I think new york pizza
2239960	2242520	Oh pizza test probably isn't the best example
2243240	2245240	but a good example would be
2245480	2247480	The nutrition facts class
2247480	2254920	We can have as many constructors as we want because all these constructors get their own method and he continues alternatively
2255560	2260760	Builders can aggregate the parameters passed into multiple calls to a method in a single field
2261240	2266440	As demonstrated in the at toppings method earlier. So this at toppings method as you can see
2266760	2268760	We're passing multiple parameters
2269000	2274440	Into the at toppings method or more accurately making multiple calls and this
2275080	2282120	Builder class is aggregating it continues a single builder can be used repeatedly to build multiple objects, of course. So
2283400	2285400	Examples here pizza calzone
2286120	2290520	Different objects being constructed in different ways using the same builder class
2291320	2293880	The parameters of the builder can be tweaked between
2294280	2297640	invocations of the build method to vary the objects that are created
2297960	2300680	These parameters can be changed as we require
2301240	2303240	depending on how we write
2304200	2309400	The different methods in the builder class a builder can fill in some fields automatically
2309960	2311960	upon object creation
2312120	2313880	such as serial number
2313880	2318680	That increases each time an object is created. This is a very astute point
2319160	2322920	I think a good example of that would be similar to the idea of
2323640	2328520	You know checking what the proper arguments past time doing type checks and different
2328680	2333960	Validations on a method because these are methods a lot can be done within the builder class
2334280	2340040	So if I try to go back to the previous example where I was checking for the
2340680	2342280	proper argument
2342280	2345560	The way we've done this check in calories. We could even have
2346200	2349560	Something which automatically adds a certain value or
2350520	2354600	Changes an object automatically depending on the way it's called
2355320	2360760	And it could all be done simply because it's a method and of course like all great programming and engineering books
2361320	2367000	ineffective java just show bloke does discuss the trade-offs. He explicitly states the
2367800	2371640	Disadvantages of using the builder pattern for this instance
2372120	2376120	And one of them is something I already discussed. It's certainly a bit hard to understand
2376440	2381240	One has to get their head around it, especially with the simulated self typing and whatnot
2381880	2383880	and understanding how the inner
2384760	2387720	Class works within the bigger class
2389080	2391960	And and that can be a bit more verbose and certainly
2392760	2394760	a bit harder to grasp
2395080	2396440	initially
2396440	2398440	and then he also says that
2398920	2400200	if you
2400200	2406520	Start out with obsolete constructors and static factories and then you know move the code base to a builder pattern
2406600	2408600	Which I think is what happens most of the time
2408680	2413560	So this second point, you know, the first point is you know, it's a matter of practice the more you use it
2413640	2415640	I believe the more one will become
2416200	2417720	more
2417720	2419720	Attuned to using the builder pattern
2420360	2422360	but the second one is
2422360	2425160	definitely a trade-off worth considering because
2425960	2429800	Generally what would happen is we would not use a builder pattern in a large code base
2429880	2433080	And then we would want to use it as the number of parameters increases
2434040	2436840	And then making that shift can be quite hard
2437080	2443400	So if it's a green field project and if you're starting from scratch always better to start with the builder pattern
2444360	2445560	even if
2445560	2449080	One has you know a small number of parameters for a certain class
2450040	2454120	That's it. That is the second item of effective java by Joshua block
2454760	2458600	Uh, I sincerely do hope that you got some kind of value out of this
2458760	2464360	And I I really am trying to get better at making these videos and really expanding on these points
2464920	2468200	It is a bit hard because firstly, I don't think
2469400	2470920	Programming and
2470920	2476680	Computational thinking naturally comes to me. I need to really struggle with the problem a lot for it to make sense
2477080	2482600	And I think that's most people really so this isn't like false modesty or whatever. I think it's it's normal for most people
2483160	2488680	Uh, and I did realize for instance the part where I was going through the simulated self type
2489240	2491240	That was a bit harder to understand
2491560	2495560	But on that note, I want to thank you for watching this video
2495800	2498440	Our next item is going to be and I have already started
2499160	2501080	writing the script for it and
2501080	2501960	You know
2501960	2503960	putting putting the code base together
2504360	2509640	The item three is enforced a singleton property with a private constructor or an enum type
2509960	2514440	This item is a bit easier to understand than the previous two. I can assure you that
2515320	2521000	In any case, thank you for watching. Uh, I do appreciate it. Uh, I appreciate you allowing me to ramble
2521240	2522760	and go on
2522760	2524760	It's good. Cheers. See you in the next one
