1
00:00:00,000 --> 00:00:06,640
Hey everyone, welcome to yet another episode of my video series on effective Java by Joshua Block

2
00:00:07,160 --> 00:00:10,880
It's sort of a textbook to code video series where I take

3
00:00:12,080 --> 00:00:17,080
Topics and principles from this book and I'm hoping to do it with many other books and

4
00:00:17,520 --> 00:00:22,960
Expand on these topics and try to understand them and try and see what value or what what we could derive from

5
00:00:23,440 --> 00:00:25,280
What are in these books?

6
00:00:25,280 --> 00:00:30,240
And today, of course, we are on item three, so I've already done this on two other items

7
00:00:31,120 --> 00:00:35,080
And it seems to be going well. I certainly can improve on certain points

8
00:00:35,080 --> 00:00:39,360
Maybe above all on brevity and try and convey the points succinctly

9
00:00:39,880 --> 00:00:42,520
But saying that though, I want to start off with the proviso

10
00:00:42,520 --> 00:00:45,880
So if you did watch the other two episodes, you could skip this bit

11
00:00:45,880 --> 00:00:50,040
I'll leave a timestamp as to where exactly could skip to just to save your time

12
00:00:50,480 --> 00:00:55,520
So for starters, this is not a tutorial. That's a very very important caveat

13
00:00:55,520 --> 00:00:59,120
I'm not a teacher in no way am I a Java expert

14
00:00:59,120 --> 00:01:02,720
In fact, the more I'm learning about Java the more I'm realizing of

15
00:01:03,400 --> 00:01:06,040
More I'm realizing how much of an expert. I'm not

16
00:01:06,960 --> 00:01:12,880
I'd like to think of it as the blind leading the blind in this case, so I'm really not leading

17
00:01:12,880 --> 00:01:18,040
But let's say at least formally because this is a YouTube video kind of formally. I am

18
00:01:19,040 --> 00:01:21,040
Leading the blind somewhere

19
00:01:21,920 --> 00:01:28,440
But that also means that because I'm blind I can make mistakes and run into a wall or something

20
00:01:29,120 --> 00:01:31,120
This is only a

21
00:01:31,240 --> 00:01:34,920
Exploratory discusion. That's pretty much it try to make sense of things

22
00:01:35,480 --> 00:01:38,040
The best I would say analogy

23
00:01:38,600 --> 00:01:44,680
Day-to-day analogy I could use is what would happen in a university tutorial where we have a bunch of students

24
00:01:44,680 --> 00:01:47,440
We have an assignment or a problem statement or some concept

25
00:01:47,440 --> 00:01:49,520
You're trying to grok of course as a tutor

26
00:01:49,520 --> 00:01:56,040
But in this case there really isn't a tutor but just a bunch of students getting together trying to make sense of some programming concept

27
00:01:56,040 --> 00:01:58,320
And needless to state this is a programming video

28
00:01:58,320 --> 00:02:02,720
So it makes sense to have all the code that I use on get out where you could go and play around too

29
00:02:02,840 --> 00:02:05,440
So I shall leave a link down below in the description

30
00:02:05,600 --> 00:02:11,760
Not only do my code but even to the code that Joshua Block has published himself on his personal repository

31
00:02:11,760 --> 00:02:15,600
So with offer the do let's get started on item number three

32
00:02:15,800 --> 00:02:24,120
Which states and foes the singleton property with a private constructor or an enum type and this is still of course a part of chapter 2

33
00:02:24,120 --> 00:02:26,120
Which is regarding?

34
00:02:26,400 --> 00:02:31,800
Creating and destroying objects. So singleton was one of the design patterns that was originally

35
00:02:31,800 --> 00:02:37,600
I don't know if the word is originally, but let's say popularized by the gang of foe in their great software engineering book

36
00:02:38,440 --> 00:02:47,560
Design patterns and a singleton is a design pattern that ensures that a class can only have one object or as Joshua Block states in the book a

37
00:02:48,360 --> 00:02:52,000
Singleton is simply a class that is instantiated exactly once

38
00:02:53,120 --> 00:03:01,240
Singletons typically represent either a stateless object such as a function or a system component that is intrinsically unique

39
00:03:01,360 --> 00:03:07,040
So this creation on design pattern which I said again was proposed or popularized is a more

40
00:03:07,520 --> 00:03:14,880
Accurate term by the angle for it's something one would hear about a lot if you're doing a if you're all be programmer, which is most of us

41
00:03:15,680 --> 00:03:20,720
And it's it's got many advantages, which is probably why we've been told by

42
00:03:21,440 --> 00:03:24,120
The great wise sagacious programming

43
00:03:24,720 --> 00:03:26,720
Gurus to implement it

44
00:03:27,000 --> 00:03:31,760
So I found a few advantages of it keep in mind though if you do follow this link

45
00:03:31,800 --> 00:03:35,760
This is on refactoring guru. By the way, if you do want to understand

46
00:03:37,000 --> 00:03:40,600
Different design patterns this website refactoring guru is fantastic

47
00:03:40,720 --> 00:03:47,680
It'll visualize things and use analogies to the real world which personally for me. I always find that helps me

48
00:03:48,400 --> 00:03:55,640
Comprehend things much better. So this design pattern the singleton pattern has they've expanded on that topic here

49
00:03:56,480 --> 00:04:03,440
They've they've listed listed out not only advantages, but also some cons as you can see here some disadvantage is to

50
00:04:04,000 --> 00:04:08,320
I'm not gonna touch on those because you know going deeply into the single singleton

51
00:04:09,480 --> 00:04:13,520
Because going deeply into the singleton pattern is probably a bit out of scope for this video

52
00:04:13,640 --> 00:04:17,680
But some of the advantages are you can be sure that a class has only a single instance

53
00:04:17,800 --> 00:04:23,120
That really helps with maintaining a certain let's say state of an object more from a

54
00:04:23,800 --> 00:04:30,800
Business perspective, let's say so we we instantiate a class and we give an object object a certain state and

55
00:04:31,120 --> 00:04:35,280
then generally a client would expect this object to behave a certain way and

56
00:04:36,600 --> 00:04:43,840
Forcing or implementing the singleton pattern ensures that this object doesn't behave in ways that a client won't expect

57
00:04:44,360 --> 00:04:49,120
So it helps to sort of maintain the encapsulation of the class and

58
00:04:50,120 --> 00:04:57,120
Yes, you gain a global access point to that instance because obviously only one object access to memory

59
00:04:57,600 --> 00:05:01,880
Whoever that's going to use that object will still use that one single object

60
00:05:03,360 --> 00:05:08,360
The singleton object is initialized only when it's request requested for the first time

61
00:05:08,360 --> 00:05:11,040
So that's kind of like I guess the lacy loading pattern

62
00:05:11,440 --> 00:05:17,160
That again is good because we don't want to create unnecessary objects. Generally, that's bad

63
00:05:17,360 --> 00:05:23,200
That's a bad almost like an anti-pattern in OOP and on that note Joshua block continues

64
00:05:24,040 --> 00:05:28,000
There are two way two common ways. Sorry to implement singletons

65
00:05:28,160 --> 00:05:31,280
Both are based on keeping the constructor private and

66
00:05:32,200 --> 00:05:34,200
exporting a public static member

67
00:05:35,160 --> 00:05:37,280
To provide access to the sole instance

68
00:05:37,280 --> 00:05:44,520
So the first approach is using a public static final field where the the member field that holds this instance is final

69
00:05:44,760 --> 00:05:47,560
Let's explode that and try and make sense of it

70
00:05:47,880 --> 00:05:53,680
What we have here is a class public class called Elvis. By the way, most of this code I've taken from

71
00:05:54,200 --> 00:05:57,160
Joshua blocks the code is used in the book itself

72
00:05:57,200 --> 00:06:02,240
I've just sort of refactored it to make it a bit more easier for us to understand for me to understand

73
00:06:02,240 --> 00:06:03,480
I should speak

74
00:06:03,480 --> 00:06:09,000
Individually because I don't want to pretend as if I'm speaking on behalf of other people here for me to understand

75
00:06:09,640 --> 00:06:11,640
And as you can see here, yeah

76
00:06:11,640 --> 00:06:16,720
The the instance is declared final. So that object becomes immutable

77
00:06:16,720 --> 00:06:22,960
So the Elvis class really has only got a simple method called leave the building which states whoa, baby. I'm out of here

78
00:06:22,960 --> 00:06:29,680
I guess I'm a bit bit too young or from a different generation to really get the Elvis Presley jokes

79
00:06:29,680 --> 00:06:32,600
Which Joshua block has made in this book?

80
00:06:33,360 --> 00:06:35,240
It's kind of a bit

81
00:06:35,240 --> 00:06:41,520
You know before my time, let's say in any case the constructor of course is private because this gives

82
00:06:41,640 --> 00:06:45,080
The class instance control as I've stated in the comment here

83
00:06:45,080 --> 00:06:51,840
And then it's simple as this when we do get that instance access that instance and you can probably see here

84
00:06:51,840 --> 00:06:55,760
We aren't creating any object using the new keyword or what not

85
00:06:55,760 --> 00:07:02,200
We're simply accessing this static member which belongs to the class itself and then through the static member

86
00:07:02,200 --> 00:07:05,080
Which gives us that object the instance we are

87
00:07:05,760 --> 00:07:08,080
Accessing this method. So if I do run this

88
00:07:08,520 --> 00:07:14,720
It'll just say whoa, baby. I'm out of here. Which is really what this object does. There we go right there

89
00:07:14,720 --> 00:07:21,920
And on this bit of code Joshua block states the private constructor is called only once to initialize the public static field

90
00:07:22,240 --> 00:07:24,720
Elvis instance. So that happens here

91
00:07:25,880 --> 00:07:27,880
The the the class itself is

92
00:07:29,040 --> 00:07:34,520
instantiating itself with this private constructor because obviously it has it it has access to this

93
00:07:34,840 --> 00:07:41,680
Constructor within itself and that object is stored in the instance variables. So yeah, the private constructor is called only once

94
00:07:41,680 --> 00:07:44,840
We initialize the public static field Elvis star instance. That's this

95
00:07:45,600 --> 00:07:50,320
the lack of a public or protected constructor guarantees a

96
00:07:51,120 --> 00:07:56,160
Monoelvistic universe. So the idea is as I did show here the client code

97
00:07:56,760 --> 00:08:00,240
You can't instantiate this class. It's impossible because the constructor is private

98
00:08:01,120 --> 00:08:09,520
Exactly one Elvis instance will exist once the Elvis class is initialized. No more. No less

99
00:08:10,400 --> 00:08:14,720
Nothing that a client does can change this with one caveat

100
00:08:15,240 --> 00:08:19,200
This is an interesting point and I shall comment on that in a bit a

101
00:08:20,120 --> 00:08:23,000
Privilege client can invoke the private constructor

102
00:08:23,440 --> 00:08:28,800
Reflectively with the aid of the accessible object dot set accessible method

103
00:08:28,800 --> 00:08:36,400
If you need to defend against its attack modify the constructor to make it throw an exception if it's asked to create a second instance

104
00:08:36,960 --> 00:08:38,960
so firstly, I would say

105
00:08:39,720 --> 00:08:46,560
Before I say anything or comment on what Java reflection is watch this video by code with Joan

106
00:08:46,560 --> 00:08:48,560
Obviously links down below in the description

107
00:08:49,120 --> 00:08:55,520
You know, I've read blog posts what not on this idea of Java reflection, but so far

108
00:08:56,040 --> 00:09:01,840
No one has explained it simply and plainly the way Joan does in his YouTube channel

109
00:09:02,360 --> 00:09:09,080
Just in general code with Joan is a fantastic YouTube channel. I really appreciate his pedagogy and

110
00:09:09,600 --> 00:09:11,600
kind of how what's what I'm looking for

111
00:09:12,360 --> 00:09:14,360
how

112
00:09:14,360 --> 00:09:16,480
Pedestrian and I mean that in the positive sense

113
00:09:17,160 --> 00:09:23,160
He makes Java seem to people like me. Who's to try to you know, truly understand the language

114
00:09:24,160 --> 00:09:31,400
So Java reflection, let me try and explain what it is as the name suggests. It's a way

115
00:09:32,360 --> 00:09:33,960
for a

116
00:09:33,960 --> 00:09:35,960
object or a class to

117
00:09:36,920 --> 00:09:41,720
introspect or reflect on itself. So what it does is generally of course a

118
00:09:42,440 --> 00:09:44,440
client can't go around tampering

119
00:09:45,120 --> 00:09:47,080
private methods and setting

120
00:09:48,640 --> 00:09:51,200
Setting setters or getters in a class

121
00:09:51,960 --> 00:09:57,640
That's not allowed that that violates the OB principle of encapsulation. However

122
00:09:58,640 --> 00:10:03,440
Java disallowed this concept called reflection which from what I've read it's mostly for

123
00:10:03,800 --> 00:10:09,840
Frameworks so for mostly for Java framework builders that does allow a class like this

124
00:10:09,840 --> 00:10:15,160
Which has a private constructor and which don't have any setters which don't have any getters to still

125
00:10:16,000 --> 00:10:20,440
implement that from outside the class using Java reflection

126
00:10:20,440 --> 00:10:26,360
In fact, let me quickly pull out a more of a formal definition of what Java reflection is because I think

127
00:10:26,520 --> 00:10:29,960
It's important to know the concept at least so yes

128
00:10:29,960 --> 00:10:37,560
As I said, this is a definition from Oracle docs like more not really the Oracle doc. Sorry. It's more of a technical article

129
00:10:38,160 --> 00:10:43,000
Whoa written in 1998. That was a yeah after I was born

130
00:10:43,880 --> 00:10:46,240
Reflection is a feature in the Java programming language

131
00:10:46,240 --> 00:10:51,120
It allows an executing Java program to examine or

132
00:10:51,520 --> 00:10:55,280
Interespect upon itself and manipulate internal properties of the program

133
00:10:56,000 --> 00:11:02,120
For example, it's possible for a Java class to obtain the names of all its members and display them

134
00:11:02,200 --> 00:11:07,960
That's an important point here that introspection can be done runtime. So when the program is being executed

135
00:11:08,440 --> 00:11:09,880
but

136
00:11:09,880 --> 00:11:13,240
Better if you just watch this video. It's 22 minutes. Well worth your time

137
00:11:13,240 --> 00:11:18,360
So the second way Joshua block has delineated on creating or implementing singletons is

138
00:11:19,000 --> 00:11:20,800
Using a static factory method

139
00:11:20,800 --> 00:11:25,560
Now if you don't know what that is and don't know the benefits of using a static factory method

140
00:11:25,560 --> 00:11:28,480
I would link you to the first video in the series

141
00:11:28,520 --> 00:11:37,440
Which is item one that talks about the pros or the virtues of using the static factory method and item one states

142
00:11:37,560 --> 00:11:43,840
Consider static factory methods instead of constructors, but for all intents and purposes within our topic

143
00:11:44,000 --> 00:11:50,000
Really, it does the same thing. So if you take this example, which again is another class called Elvis Elvis

144
00:11:51,040 --> 00:11:53,880
Why isn't it opening up? There we go. So yes, same concept

145
00:11:53,880 --> 00:11:55,880
the the constructor is so private and

146
00:11:56,000 --> 00:12:00,960
We only have one object being created here within the class and instead of the client

147
00:12:01,160 --> 00:12:05,480
Directly accessing the member variable that member variable is private in this case

148
00:12:05,480 --> 00:12:09,360
And we rather get it through the static factory method. Oh

149
00:12:10,040 --> 00:12:14,280
This bit here the read resolve will get to that soon for now

150
00:12:14,280 --> 00:12:18,120
Just ignore line number 15 and clearly as he states here

151
00:12:18,120 --> 00:12:24,400
You can see in the code itself one advantage of the static factory approach is that it gives you the flexibility to change your mind

152
00:12:24,400 --> 00:12:28,200
About whether the class is a singleton without changing its API

153
00:12:28,440 --> 00:12:32,880
So what he means by that is if you look at the public field approach

154
00:12:33,680 --> 00:12:40,760
Since we're directly accessing that singleton via the the public member variable

155
00:12:41,600 --> 00:12:45,640
It doesn't really give us a flexibility if we do want to not have a singleton

156
00:12:45,640 --> 00:12:50,120
Let's say if we don't want to fill a singleton single to impact and I should probably add this here

157
00:12:50,120 --> 00:12:52,400
He also states in the previous paragraph

158
00:12:52,400 --> 00:12:58,340
I should have read that before the main advantage of the public field approach is that the API makes it clear

159
00:12:58,680 --> 00:13:00,680
That the class is singleton

160
00:13:01,280 --> 00:13:09,080
The public static field is final so it'll always contain the same object reference, which what do you mean there is from a client perspective?

161
00:13:10,040 --> 00:13:13,240
I've used an inline variable here by the way the the

162
00:13:14,040 --> 00:13:17,520
It's it says here Elvis and we're getting that single instance

163
00:13:17,720 --> 00:13:19,800
Now it's a similar thing we're doing here

164
00:13:19,800 --> 00:13:25,440
The only difference with the static factor method is we're accessing it through this method get instance

165
00:13:25,640 --> 00:13:31,400
Now because it's a method we can play around with it and do what we want so to speak

166
00:13:31,400 --> 00:13:35,360
Which is why Joshua block states it gives you the flexibility to change your mind

167
00:13:36,080 --> 00:13:39,760
About whether the class is a singleton without changing its API

168
00:13:39,840 --> 00:13:43,640
We don't really change anything in this method. What matters is how we handle

169
00:13:43,920 --> 00:13:51,200
This object or what we do inside it from a again from a class clients perspective an example Joshua block has used is something to do with multi-threading

170
00:13:51,640 --> 00:13:56,920
In a multi-thread environment the factory method returns a sole instance

171
00:13:57,000 --> 00:14:03,680
But it could be modified to return say a separate instance for each thread that invokes it that makes sense

172
00:14:03,680 --> 00:14:09,280
We don't want there to be problems with multi-threading by having a single object that all the threads share

173
00:14:09,280 --> 00:14:11,520
Let's that could probably corrupt the state of that object

174
00:14:11,520 --> 00:14:14,640
I don't know just to you know thinking out loud here now

175
00:14:14,640 --> 00:14:18,680
We sort of come to a bit of an ancillary point, but I think is nevertheless important a

176
00:14:19,200 --> 00:14:25,760
Second advantage is that you can write a generic singleton factory if your application requires it

177
00:14:26,440 --> 00:14:33,240
So what is a generic singleton factory? Let's try and make sense of it. Firstly as per usual

178
00:14:33,760 --> 00:14:35,760
I will leave

179
00:14:35,760 --> 00:14:36,680
two

180
00:14:36,680 --> 00:14:37,600
two

181
00:14:37,600 --> 00:14:43,080
Links to two different well one stucco flow answer and then a blog post

182
00:14:43,800 --> 00:14:48,320
Regarding this concept of type erasure, which is what allows generic programming in Java

183
00:14:49,200 --> 00:14:50,320
and

184
00:14:50,320 --> 00:14:55,360
How it happens and why it's it's necessary for generic programming

185
00:14:55,400 --> 00:15:00,720
But it's not really within the scope of what we're discussing here. It's still important to understand though

186
00:15:00,720 --> 00:15:05,760
So what's a generic singleton factory first of all out? I should say we'll be covering this in

187
00:15:06,680 --> 00:15:10,640
item 30 of this book so probably next year

188
00:15:11,480 --> 00:15:17,080
Therefore we shall go into more detail in that video and item 30 simply states favorite generic method

189
00:15:17,080 --> 00:15:19,080
But I propose to

190
00:15:19,120 --> 00:15:21,360
Generic singleton factory in that item

191
00:15:21,880 --> 00:15:28,160
Joshua block states because generics are implemented by ratio. So that's what I meant by this type erasure bit

192
00:15:28,320 --> 00:15:35,480
Please go read up on that blog post article blog post article on that blog post as it'll really expand on the matter

193
00:15:36,640 --> 00:15:42,520
Because generics implemented by ratio you can use a single object for all required type

194
00:15:43,560 --> 00:15:44,600
parameterizations

195
00:15:44,600 --> 00:15:51,440
But you need to write a static factory method to repeatedly dole out the object for each requested type parameterization

196
00:15:51,440 --> 00:15:55,840
This is a very cool concept once you see in an action which I shall which I shall show

197
00:15:56,120 --> 00:16:00,920
It's a bit of tongue twister which I shall show in a bit because it is it is pretty cool

198
00:16:00,920 --> 00:16:06,560
How it all comes together so kind of definition that I came up with for what a generic singleton factory is

199
00:16:06,560 --> 00:16:08,320
It allows to create multiple singletons

200
00:16:08,320 --> 00:16:10,360
That is not a oxymoron

201
00:16:10,360 --> 00:16:16,200
You will see you will see why that is in a bit that behave the same way. So it's kind of got like a same

202
00:16:17,600 --> 00:16:25,400
Supertype which man is how it behaves using generics allows to use a single object for type parameterizations

203
00:16:25,400 --> 00:16:27,400
I'm kind of repeating where Joshua block state

204
00:16:27,520 --> 00:16:34,040
Stay stated and casting is not required that too you shall see so I've got the example here

205
00:16:34,040 --> 00:16:36,040
This too I took from item 30

206
00:16:36,640 --> 00:16:42,640
But I just realized that before I do go through the example and explore the code. I didn't mention

207
00:16:43,640 --> 00:16:49,080
those two the Stack Overflow answer and then this blog post, but I didn't really

208
00:16:49,840 --> 00:16:51,720
even

209
00:16:51,720 --> 00:16:55,840
expand on what what it is or what what they are

210
00:16:56,760 --> 00:17:01,920
So I want to read out a bit of bit of like introduction in this article regarding

211
00:17:02,040 --> 00:17:09,280
Type erasure because type erasure is what allows firstly the the the generic singleton pattern, but also using

212
00:17:10,120 --> 00:17:11,640
generic programming

213
00:17:11,640 --> 00:17:13,200
in Java

214
00:17:13,200 --> 00:17:14,400
generally

215
00:17:14,400 --> 00:17:17,360
Generic programming in Java generally gosh, that's funny

216
00:17:18,200 --> 00:17:22,360
So what does this person say? By the way, this article was written by

217
00:17:23,000 --> 00:17:25,920
Bishal Kumar Dube. So what is Bishal's state here?

218
00:17:26,000 --> 00:17:32,400
Generics concept is introduced in Java language to provide

219
00:17:32,800 --> 00:17:39,160
Tider type checks at compile time and to support generic programming as I said the way to implement generics

220
00:17:39,160 --> 00:17:41,960
The Java compiler applies type erasure

221
00:17:42,520 --> 00:17:50,240
To replace all type parameters in generic types with their bounds or object if the type parameters are unbounded

222
00:17:50,560 --> 00:17:57,280
The produce bytecode we shall go into the bytecode bit to therefore contains only ordinary classes interfaces and methods

223
00:17:58,040 --> 00:18:03,640
Insert type costs if necessary to preserve type safety. That is also something we shall explore

224
00:18:04,680 --> 00:18:06,680
Generate bridge methods to preserve

225
00:18:07,680 --> 00:18:09,480
Polymorphism in extended generic types

226
00:18:09,480 --> 00:18:16,680
So you will see that the the third point here that polymorph polymorphism bit in this example that I'm gonna show soon

227
00:18:16,920 --> 00:18:19,720
See the stochophilons are kind of explained it this way

228
00:18:19,880 --> 00:18:25,720
So we have this class of course here, which is simply a list

229
00:18:25,960 --> 00:18:30,840
Sorry, let's say class. I mean we have the list interface and the other list class

230
00:18:31,840 --> 00:18:35,000
And it's the generic type where the type parameter

231
00:18:35,000 --> 00:18:37,880
We are passing the string and then we're just adding it and we're getting it

232
00:18:38,120 --> 00:18:42,120
But in the bytecode level it really compiles like this

233
00:18:42,280 --> 00:18:44,920
It does do the casting for us now

234
00:18:44,920 --> 00:18:46,920
This is not required for us to do because we're using

235
00:18:47,520 --> 00:18:49,800
Generics and the type erasure allows this

236
00:18:51,120 --> 00:18:56,680
Going to the example here is how the generic singleton pattern works this instance

237
00:18:56,800 --> 00:19:00,360
We have a variable called identity function or identity fm

238
00:19:00,400 --> 00:19:03,560
We have a variable irony function and keep in mind

239
00:19:04,160 --> 00:19:09,720
Object in Java is a superclass for all other classes therefore any subtype of this

240
00:19:10,520 --> 00:19:12,520
Type can be passed into this

241
00:19:12,600 --> 00:19:16,040
So we have this private static final member variable called

242
00:19:17,240 --> 00:19:19,160
Unary operator

243
00:19:19,160 --> 00:19:21,800
And then we have a static factory method

244
00:19:23,320 --> 00:19:27,320
What happens here is that method we can pass a

245
00:19:28,280 --> 00:19:31,640
Type parameters similar to how you would pass a parameter to a method

246
00:19:31,640 --> 00:19:33,640
But in this case it's a type

247
00:19:33,640 --> 00:19:37,640
So then in the client side, you'll firstly see that I'm not using any costs here

248
00:19:38,360 --> 00:19:43,320
And I have two lists up defined. Sorry two arrays not lists in this case

249
00:19:43,960 --> 00:19:47,800
A string array right there. I should probably zoom in a bit more. I apologize

250
00:19:50,360 --> 00:19:53,880
The the string array and then we have the numbers array

251
00:19:54,840 --> 00:19:57,480
So into the same class I'm passing

252
00:19:59,000 --> 00:20:01,320
I'm creating an instance of that class same string

253
00:20:02,040 --> 00:20:04,520
And I'm getting that object same string same number

254
00:20:05,480 --> 00:20:07,080
And I'm passing

255
00:20:07,080 --> 00:20:11,960
In this case the type string and in this case the type number

256
00:20:12,840 --> 00:20:14,840
Now here's where it gets interesting

257
00:20:15,080 --> 00:20:18,920
Despite the different types. It's still using the same object

258
00:20:18,920 --> 00:20:24,360
We're still as Joshua block states here doling out the same object into different types

259
00:20:25,080 --> 00:20:27,880
So in this case we can type we can apply this

260
00:20:28,600 --> 00:20:29,640
and then

261
00:20:29,640 --> 00:20:35,400
Print out all the strings and in this case print out all the numbers, but when we run this code

262
00:20:40,840 --> 00:20:42,840
You'll see here

263
00:20:42,920 --> 00:20:44,920
Why can't I is okay forget about it

264
00:20:45,320 --> 00:20:50,200
When we run this code, you'll see here the object is still the same object that it's using

265
00:20:52,120 --> 00:20:55,240
For both these cases despite them having different types

266
00:20:55,560 --> 00:20:57,960
So I'm printing out the object here same string same number

267
00:20:58,280 --> 00:21:02,840
It's still this object the other any function object that is passing or this single instance

268
00:21:03,080 --> 00:21:03,880
So it's beautiful

269
00:21:03,880 --> 00:21:07,240
And that's what allows generic programming because these are of different types

270
00:21:07,400 --> 00:21:13,080
Yet that object is being passed through these different types to be used and abused. Let's say

271
00:21:14,920 --> 00:21:18,680
So that essentially is what generic singleton factory is it is a factory

272
00:21:18,840 --> 00:21:22,520
We've got a factory here because it's producing or giving we're creating an object

273
00:21:23,160 --> 00:21:26,040
Uh, but no cast is being used. I think that's the biggest advantage

274
00:21:26,280 --> 00:21:33,320
I've seen from that pattern and afterwards joshua block states a final advantage of using a static factory

275
00:21:34,040 --> 00:21:36,040
Is that a method reference

276
00:21:36,440 --> 00:21:38,840
Can be used as a supplier for example?

277
00:21:39,480 --> 00:21:46,840
Elvis get instance, which is the method reference is a supplier for uh is a supplier and Elvis is the type you pass into it

278
00:21:46,920 --> 00:21:50,840
Which is the example I've used here. So let's try and understand. What does it mean?

279
00:21:50,920 --> 00:21:52,920
What what what does he mean by?

280
00:21:52,920 --> 00:21:55,640
method reference being being passed as a supplier

281
00:21:57,000 --> 00:21:59,720
Firstly from the oracle docs, uh, it states

282
00:22:00,280 --> 00:22:03,720
What's a supplier? I want to understand. It's a functional interface supplier

283
00:22:04,520 --> 00:22:08,120
Sorry, the functional interface supplier contains one method

284
00:22:08,440 --> 00:22:13,640
Which is get that takes no argument and returns an object. But but what's important to understand is

285
00:22:15,400 --> 00:22:17,400
It it this get method

286
00:22:17,800 --> 00:22:20,840
Represents a function which does not take any arguments

287
00:22:21,320 --> 00:22:26,600
But produces a value of type t. So yes, the get method doesn't produce any arguments

288
00:22:27,240 --> 00:22:31,720
But it has a type the type could be passed as a generic

289
00:22:32,440 --> 00:22:39,000
By the way, that latter bit I read from this article again in geeks for geeks, uh, which I'll leave a link down below in the description

290
00:22:39,000 --> 00:22:43,480
Which explains what a supplier interface is written by this person

291
00:22:44,440 --> 00:22:51,560
Sell one two three. So this is a bit hard to get intuitively even though most of us in functional programming use

292
00:22:52,680 --> 00:22:56,360
A method reference, but the method reference requires a supplier

293
00:22:56,840 --> 00:23:00,520
This functional interface supplier interface does requires

294
00:23:01,080 --> 00:23:04,120
Yeah, it requires a supplier and we need to pass it a type

295
00:23:04,680 --> 00:23:06,680
In this case with the class Elvis

296
00:23:07,320 --> 00:23:10,680
We could pass the type Elvis as the generic parameter

297
00:23:11,240 --> 00:23:14,120
As as of it being of type Elvis

298
00:23:15,000 --> 00:23:16,440
um

299
00:23:16,440 --> 00:23:18,840
I don't know. I don't know how else to explain it really

300
00:23:19,560 --> 00:23:23,960
It just it just seems like it's something that allows us to do functional programming

301
00:23:24,120 --> 00:23:28,360
And which is why javas introduced that interface. Probably it was in javae. I think

302
00:23:29,160 --> 00:23:29,640
um

303
00:23:29,640 --> 00:23:34,680
And yes, the the static factor method allows us to do that essentially because of the get instance method

304
00:23:35,560 --> 00:23:37,880
That we define right there in any case

305
00:23:37,960 --> 00:23:44,520
I hope that explanation did do some justice to what a supplier interface is if not, please go read the oracle docs

306
00:23:45,240 --> 00:23:48,520
Honestly, I don't really find it too interesting. So I didn't go too deeply into it

307
00:23:49,000 --> 00:23:51,000
But it just seems like something javae introduced

308
00:23:51,800 --> 00:23:53,800
To allow functional programming

309
00:23:54,440 --> 00:23:56,840
But back to this this bit is on

310
00:23:57,960 --> 00:23:59,960
Still providing the singleton guarantee

311
00:24:00,760 --> 00:24:02,760
when serializing classes

312
00:24:03,720 --> 00:24:08,840
To maintain to maintain the singleton guarantee declare all instance instance fields

313
00:24:09,480 --> 00:24:15,000
Transient so what does transient mean? That means it won't be serialized and provide a read resolve method

314
00:24:15,080 --> 00:24:19,160
This is the bit I said I'll get to a bit later that bit right there

315
00:24:20,040 --> 00:24:21,480
this

316
00:24:21,480 --> 00:24:23,480
ensures that there's

317
00:24:23,480 --> 00:24:27,720
The singleton property or the singleton patterns followed during during serialization

318
00:24:28,280 --> 00:24:34,280
However, it's not really worth going too deeply into it. Uh, but uh, sorry, you know what before I go

319
00:24:34,760 --> 00:24:38,600
Going everywhere with this. I'll I'll finish the rest of that sentence or that paragraph

320
00:24:39,080 --> 00:24:43,000
So I'll say to maintain a singleton instance to to maintain the singleton guarantee

321
00:24:43,400 --> 00:24:48,520
Declare all instance fields transient and provide a read resolve method

322
00:24:49,880 --> 00:24:52,840
Which he points to in item 89. I shall get to that too

323
00:24:53,720 --> 00:24:55,720
otherwise each time

324
00:24:55,720 --> 00:25:00,200
A serialized instance is deserialized a new instance will be created

325
00:25:00,760 --> 00:25:02,040
leading

326
00:25:02,040 --> 00:25:05,240
In the case of our example to spurious elvis sightings

327
00:25:05,800 --> 00:25:08,040
So firstly that that idea of

328
00:25:08,760 --> 00:25:10,280
Read resolve method

329
00:25:10,280 --> 00:25:17,480
There's a whole chapter in the book on serialization serial serialization. Why do I find it hard to pronounce that word?

330
00:25:17,880 --> 00:25:19,880
serialization

331
00:25:19,960 --> 00:25:24,360
When item 89, which is why I said it's not worth spending too much time on this because

332
00:25:25,080 --> 00:25:29,320
Joshua block in fact says don't use read resolve methods in item 89

333
00:25:29,400 --> 00:25:33,080
He states for instance control. So that's what we're doing here. We're

334
00:25:33,720 --> 00:25:38,680
Practicing instance control instance control prefer enum types to read resolve

335
00:25:38,760 --> 00:25:40,680
So we're going to get to enum types next therefore

336
00:25:40,840 --> 00:25:46,680
It's not really worth going too deeply into what this read resolve method does but just in general

337
00:25:47,640 --> 00:25:50,520
Because it always returns this single instance we defined here

338
00:25:51,480 --> 00:25:58,680
It enforces singleton once again, but this time especially during serialization serialization

339
00:25:59,800 --> 00:26:01,800
Can't pronounce that word

340
00:26:01,800 --> 00:26:06,360
And according to this definition by michael mayers. I've left a link to that

341
00:26:07,640 --> 00:26:11,240
It's a it's a blog post in this in the description too

342
00:26:12,200 --> 00:26:15,320
Read resolve is used to for replacing the object stream

343
00:26:15,640 --> 00:26:22,200
Object object read from the stream. What can't I read today? The only use I've ever seen for this is enforcing singleton

344
00:26:22,760 --> 00:26:24,760
Oh, sorry. This was from in fact

345
00:26:25,560 --> 00:26:28,520
a stackable flow answer not a blog post but

346
00:26:29,480 --> 00:26:32,440
Nevertheless, I shall leave a link to all of that down below in the description

347
00:26:35,160 --> 00:26:42,600
When an object is read replace it with the singleton instance. So when this object is read, it's going to replace it with this instance

348
00:26:43,160 --> 00:26:50,440
This ensures that nobody can create another instance by serializing and deserializing the singleton

349
00:26:50,840 --> 00:26:54,760
However, it makes no sense to go too deeply into read resolve because

350
00:26:55,720 --> 00:26:57,720
technically or theoretically

351
00:26:57,720 --> 00:26:59,240
As per the

352
00:26:59,240 --> 00:27:02,520
Sagacious advice of just your blog. We shouldn't even be using this method

353
00:27:02,520 --> 00:27:06,040
We should be using the third method technique or the third way

354
00:27:06,600 --> 00:27:12,680
To enforce singleton property, which is with a enum type not an enum type using a single enum

355
00:27:12,760 --> 00:27:17,240
I don't know why I said enum type makes no sense. This is by far the simplest way. It's

356
00:27:18,200 --> 00:27:21,480
I think two lines of code if I'm not mistaken. So let me open it up

357
00:27:22,280 --> 00:27:24,520
It is in fact. Yes, really

358
00:27:25,160 --> 00:27:28,840
I don't even know if you consider this is more like a member variable, but it's one line of code

359
00:27:29,640 --> 00:27:34,040
This is the simplest way to enforce singleton. Look at that. Just two lines of code really

360
00:27:34,600 --> 00:27:37,640
One two, I don't know. I don't want to start a debate here. What's wrong with me?

361
00:27:38,360 --> 00:27:40,360
and really all we're doing is

362
00:27:40,600 --> 00:27:42,600
story that instance and

363
00:27:42,840 --> 00:27:44,840
It's a factor that it's enum

364
00:27:44,840 --> 00:27:48,760
We get most of these things we were trying to explicitly declare in the source code

365
00:27:49,640 --> 00:27:51,640
By by virtue of it being an enum

366
00:27:52,440 --> 00:27:55,000
So, yeah, it provides serialization

367
00:27:55,960 --> 00:28:02,120
Serialization for free and by default won't be able to instantiate multiple times because they're static

368
00:28:02,840 --> 00:28:04,840
And final effectively

369
00:28:04,840 --> 00:28:09,400
In java every enum is implicitly a subclass of the enum class

370
00:28:10,040 --> 00:28:14,760
So it cannot be used if singleton needs to extend a superclass. Oh, yes, this is an important point

371
00:28:15,000 --> 00:28:17,960
He gets to this in the in the in the end of the paragraph

372
00:28:18,120 --> 00:28:23,320
I shall I shall the really the only disadvantage of using an enum to

373
00:28:24,040 --> 00:28:25,560
I wouldn't even say

374
00:28:25,560 --> 00:28:30,920
Disadvantage more of something something to be wary of when using an enum is this last bit

375
00:28:31,080 --> 00:28:35,320
Which I shall touch on a bit in which I which I which I shall touch on in a bit

376
00:28:36,280 --> 00:28:39,080
Ah, my constant struggle to talk

377
00:28:40,760 --> 00:28:47,240
The best approach this approach may feel a bit unnatural. This is where Joshua block states. So, yeah, I mean, I don't know if

378
00:28:49,000 --> 00:28:55,160
In my few years of programming, I haven't really used an enum for much other than as being a container for holding

379
00:28:55,960 --> 00:28:57,160
constants

380
00:28:57,160 --> 00:28:59,160
So it does feel a bit unnatural

381
00:28:59,560 --> 00:29:04,520
But a single element enum type is often the best way to to implement a singleton

382
00:29:05,240 --> 00:29:07,400
And then he states, this is the bit I stood out touch on

383
00:29:08,040 --> 00:29:13,880
Note that you can't use this approach if your singleton must extend a superclass other than enum

384
00:29:15,080 --> 00:29:20,280
Though you can declare an enum to implement interfaces, of course, because in java we can't extend

385
00:29:21,000 --> 00:29:23,000
multiple classes because

386
00:29:23,400 --> 00:29:28,200
By default any enum will is already extending the enum superclass

387
00:29:28,760 --> 00:29:31,000
Let's say Elvis had to

388
00:29:31,720 --> 00:29:33,720
extend a class called human

389
00:29:34,840 --> 00:29:38,120
That wouldn't be allowed because if we use enum

390
00:29:38,760 --> 00:29:43,960
However, you could probably get through that through interfaces. So not really a big deal

391
00:29:44,680 --> 00:29:47,960
That was a much shorter video. It was a much shorter item two

392
00:29:48,520 --> 00:29:53,880
And that's it. That's item number three that that's so essentially the idea is unless we have

393
00:29:55,000 --> 00:29:57,400
to extend a superclass the singleton

394
00:29:58,120 --> 00:30:00,120
Then just use enums to

395
00:30:00,440 --> 00:30:07,240
end for a singleton property and we also did discuss initially some of the advantages of using a singleton

396
00:30:08,440 --> 00:30:11,800
On that note, I shall thank you for letting me again

397
00:30:13,160 --> 00:30:15,160
Go about these things like a drunken sailor

398
00:30:15,720 --> 00:30:20,920
And get lost sometimes in my own musings. It is really interesting though. It is quite interesting how

399
00:30:21,640 --> 00:30:26,600
As I said many times already how all these items are interrelated kind of like the bible

400
00:30:27,080 --> 00:30:31,480
The next item item number four, which I'm hoping to cover soon, which again is a shorter item

401
00:30:31,640 --> 00:30:34,200
It's it's probably the shortest item in this book is

402
00:30:35,000 --> 00:30:40,360
Enforce non instantiability with a private constructor. We've sort of already done that

403
00:30:41,000 --> 00:30:43,000
We've already sort of covered

404
00:30:43,080 --> 00:30:48,440
de facto covered that item in this item because all the examples we used did have private constructors

405
00:30:49,000 --> 00:30:51,000
But it's worth

406
00:30:51,160 --> 00:30:54,040
Way when I say there's an example right this this one right here

407
00:30:54,440 --> 00:31:00,200
But of course as Joshua bloke has identified it's worth going into detail as to why we need to enforce

408
00:31:00,600 --> 00:31:05,400
Non instantiability saying that once again. Thanks for watching. I'll see you in the next one. Cheers

