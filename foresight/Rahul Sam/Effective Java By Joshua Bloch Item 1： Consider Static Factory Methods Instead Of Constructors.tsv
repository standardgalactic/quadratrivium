start	end	text
0	5920	Hey everyone, welcome to this video series called Textbook to Code, where I take computer science
5920	12720	and software engineering textbooks and sort of expand on them and convert them to code and discuss
12720	18720	them, kind of like what one would do in a tutorial in university. Now, if you're new to this channel,
18720	25280	I generally make videos on philosophy, but I realized my other great love, other than philosophy,
25280	30640	is computer science and software engineering. So I was thinking, why not do the same thing with
30640	36400	that field too? And as the title suggests, the first book I'll be covering is Effective Java by
36400	44160	Joshua Block. Certainly the best Java book I've read, even though I'm still trying to grok certain
44160	49360	concepts on it. It was recommended to me by my CTO and my current company, and he's been a Java
49360	54320	programmer for, I don't know, ever since the internet. That was a joke, by the way. I know Java
54320	60640	was created after the internet. He's been a Java programmer for a long time, and he said that this
60640	68080	was a really good book to read, not really for beginners, but more for intermediate Java developers.
68880	73200	I consider myself still a beginner to intermediate. So I don't really know
74800	80960	at what level I should get into this book. However, I do believe really the way it's structured,
80960	85520	anyone can jump into it if you have a basic understanding of programming. So Effective
85520	93440	Java contains about, I believe, 90 items, which means this video series will encompass 90 items.
93440	97440	And afterwards, I'm hoping to get to this book, which probably is going to be next year, because it
97440	103120	takes a long time to make these videos. The Headfirst Design Patterns by O'Reilly, which I've just
103120	110640	started on, and it's brilliant. I'm so grateful for all these authors who just don't take so much
110640	117120	time to educate and help upcoming learning software engineers like myself, who generally
117840	124160	aren't the most intelligent programming wizards out there. Saying that, though, as per usual with
124160	129440	my normal videos, if you do follow this channel, you know that I tend to make a lot of provisos or
129440	135840	caveats. And the first proviso is this is not a tutorial. And that's really important, because
135920	142640	the last thing I want to do is to propagate false information or teach something that's wrong.
143920	150880	And, you know, to make this a video series of misinformation to use a very politically loaded
150880	156480	term. I'm not a teacher, not an expert. I've only been a Java programmer really hands on for about
156480	163040	two years. I'm still learning myself. I'd like to think of this video series and all the videos
163040	170400	in this channel, as a matter of fact, as more of a blind, leading the blind kind of experiment,
170400	176800	let's say, where I am also naive and ignorant about these topics. So it's just more of a
178000	184160	exploratory disquisition, let's say. I'm just trying to see what this particular concept is.
184160	191600	I'm trying to break that down, which means I will inevitably make mistakes. No question about it. So
191600	196240	please point them out. Leave those out in the comment section below. I'm sure there are much
196240	202880	more advanced competent Java programmers who will point out some of my flaws. And when I say a blind
202880	207520	leading the blind, I don't mean I'm leading anyone else in that sense. The point I'm trying to make
207520	214160	is that let's try to collectively work on this. And again, the best example I can use or the best
214160	219600	analogy I can use is what one would typically do in a university tutorial where you work with the
219600	224640	tutor and the other students to solve a particular problem. And of course, since this is a programming
224640	231840	video, engineering video, all the code that I used to expand on the first item, I shall have it on
231840	237600	my GitHub account. I'll leave a link down below. You could go download it and play around with it
237600	242960	yourself. On that note, let's jump into it. We'll start with item one. So this is from
244240	248560	chapter two, creating and destroying objects. I'm not going to cover chapter one because it's
248560	253360	essentially just an introduction. And the same way that I gave caveats in this video,
253360	257600	Joshua Block himself gives a couple of a few caveats on what this book is about.
258400	266800	Just in context, Joshua Block is is brilliant. He he was, I think he created or he was a big part
266800	272240	of the Java collections framework. He's a distinguished engineer at Google, I believe.
272240	278400	So he's been a part of the Java JVM community for a long time. And I suddenly look up to him
278400	284160	and I really enjoy just even watching some of his talks on YouTube. But this book, this book
284160	292240	really opened my mind into the power of the Java language. And in fact, OOP principles in general.
293600	299120	So again, as I said, chapter two is creating and destroying objects. And the first item
299120	304800	we're going to cover is let me zoom in a bit because I don't want this to not be visible.
305360	311200	The first item we're going to cover is consider static factory methods instead of constructors.
314000	319440	So when I read this item, the moment the first time I read this chapter,
320160	325760	oh, sorry, this item, my question was, what is a static factory method?
326000	337680	And and in simple the very textbook answer would be, it's a static method that returns an instance
337680	343920	of a class. Now, don't worry, I've got the code base right here, we're going to jump into all of
343920	348880	these things in much more detail a bit later. But I think it's sort of important at a high level to
348880	355520	get the terms right and get them all in order just to help out thinking. Look, I'm just going to say
355520	360400	my thinking, I'm not going to pretend as if this is a collective thing. It's initially me making a
360400	365520	video. And then eventually, hopefully it can be a collective thing in the comment section down below.
367440	372480	And you know, not a Benet, this is not the same as the factory method design pattern.
374080	379840	Even though I'm not going to lie, it maybe this is my lack of understanding of the design pattern.
379840	385920	I see many similarities between what the static factor method does and then the design pattern.
385920	391600	So perhaps that's why it's called a static factor method. So let's take a look at the keywords,
391600	397840	first of all. So when we say a static factor method, and let me give you a quick example,
397840	404240	in fact. So here we have the big integer class and a static factor method here would be
405200	410800	that right there, public static, big integer, the probable prime method, for instance,
410800	417200	is a static factor method. Which means we got a question that I asked myself was, what is static?
418160	423680	And I took down a few notes. Of course, the word static means a lot in software engineering.
426080	432480	And my notes said that the word static ensures that a member belongs to a specific class. So again,
432480	440560	in the example of this big integer class, this member belongs, this member has in this method
440560	450880	belongs to this specific class. Therefore, only one instance of the member exists, regardless of
450880	458240	the number of objects of the class created. So it doesn't matter how many instances of the big
458320	463600	integer class is created. But there's only going to be one instance of this method,
463600	469360	because this this method, the probable prime method belongs to this big integer class,
469360	476640	there won't be multiple objects of that being created. And a static member is shared amongst
476640	485280	all objects. So because it belongs to a certain class, any any other, let's say, client that
485280	490320	uses this class and creates an instance of this class with the new keyword, just shares
491120	495440	that specific object, pardon me, not all the objects, I think I'm a spoke there,
495440	501840	more the static member, I think it's better to think of it that way. So of course, I'll get into
501840	505520	all of these stuff in detail a bit later. So of course, that means that when you want to use this
505520	511120	method, the probable prime method, one doesn't have to create an object of the class, you know,
511120	515840	use the new keyword, the way it's done in Java, it just makes things easier.
517040	525520	Also, and another caveat here, my understanding of Java memory management is very, very high
525520	531040	level. I know it's a very deep topic. It goes all the way into the depth of what computer science is
531040	536960	and engineering in general. So I have a very, very superficial understanding of it. But my
536960	542480	understanding is that static content, so any, it could be a class, a variable, a method,
542480	549360	doesn't matter, will be stored in a in a place called the dynamic meta space. This is a JVM,
549360	555840	will will store it in a place called the dynamic meta space, which I've learned to replace something
555840	564400	called the permanent generation since Java 8. So all these static members live in the dynamic
564400	570080	meta space. Now, here's, this is an important point that we're going to get to in this video.
570720	577920	I've, I've, I've got a whole bunch of resources and study material that I used as I was creating
577920	585280	this video and studying this book. So for each item, all the, what's the word, supplementary
585280	591600	reading material and studying resources, which I have a whole list here, just articles,
591600	597840	blog posts, videos, whatnot. I shall leave them down below in the description. I really think it's,
597840	605520	it's super useful, along with the book, along with each item, reading those supplementary articles,
605520	610320	it gives, at least for myself, it gave a really good understanding of what Joshua Block is talking
610320	617680	about in each item, especially given that he, he expects the readers of this book to be
618320	624880	quite proficient in Java. So if you're sort of a, in an intermediary level like me, these, these
624880	634320	background articles help. And on Java memory management, a very grokable, easy, easy to
634320	640640	understand video that I watched was by Naveen Automation Labs. I thought he explained it quite
640640	647600	well. He's a great pedagogy, great teacher. It made a lot of sense to me. And then I read
647600	652160	this article about what the meta space is in particular, because since we're talking about
652720	659360	the keyword static. So along with the word static, the other sort of keyword of these methods is
659360	666560	factory. And here's where I said before, it seems a bit similar to the factory method design pattern.
668080	676160	And maybe, maybe it's because it does follow certain aspects of the
676160	680960	creation and design pattern, even though there's no direct relation. In fact, in the book,
683520	691440	it says here, there's, oh yeah, it says here, note that a static factory method is not the same
691440	697920	as the factory method pattern from the design patterns. I feel terrible now when I looked at
697920	704400	the book, I realized that I've highlighted certain things, as you can see, these bits from the book
704400	708240	I wanted to read out and I didn't do it in the beginning of this item. So I'm going to do that
708240	713760	right now. I'm so sorry if this is chaotic and a bit messy. Please forgive me. I'm still
714960	720800	trying to figure out how all of this works and how to expand on these matters. So I'm going to read
721600	726320	this is a mess. I'm so sorry. I'm going to read the introduction to the item now,
726320	730800	which I was supposed to do in the beginning of the video, but I only realized that now.
731520	737440	So here's what Joshua Block says. The traditional way for a class to allow a client to obtain an
737440	743920	instance is to provide a public constructor is another technique that should be a part of every
743920	751360	programmer's toolkit. A class can provide a public static factory method. There we go.
753840	760400	Which is simply a static method that returns an instance of the class. I'm glad I read that
760400	764240	because I should have started with that bit because it's too confusing if not. Anyway,
764240	770160	getting back to the the factory keyword. So what this also does is it allows to encapsulate the
770160	776000	object creation process because if you do notice and we'll get into this again, the constructors are
776000	784320	private. So clients cannot access the constructors and create objects as they wish. In many ways,
784320	790960	is in fact one of the advantages which we'll get to again later of using static factory methods.
791840	799680	The class can decide when to create new instances of the class and it's not that a new object is
799680	807120	created for every invocation when a competition is required. So therefore, I don't know if this
807120	815360	makes sense, but I think it's because it resembles certain creational design pattern.
816640	821280	Let's say elements, the word factory is used to describe them.
823120	829360	So now let's get to the why the advantages. What's the justification? Why is Joshua Block telling us
829360	836880	to use static factory methods instead of constructors? How one would typically do the first one
837120	843120	Joshua Block talked about is that unlike constructors, static factory methods have names. They
843840	849680	tell it to the client or they indicate to the client what this method's doing. The example he's
849680	857840	used is in the big integer class. Now he said here, the constructor, which is this, which I've taken
857840	862080	down here. So in fact, maybe I should go to the code itself without just showing it off notion.
863040	870240	If you go to the big integer class, here we have the, all right, sorry, it's a really big class.
870240	876560	I have to go through the code. The constructor here, which is the constructor for the big integer
876560	881360	class. In fact, on the comments that even says here constructs a randomly generated positive
881360	886160	big integer, there's probably a prime with the specified bit length. But it also says here,
887120	893920	it is recommended that the probable prime method is used in preference to this constructor,
893920	900240	unless there is a compelling need to specify a certainty. Correct. So what this does is it just
901440	908960	returns a big integer, which could be a probable prime. But this is just a constructor. It's just
908960	914240	the name of the class. It doesn't really, to me as a client using this, doesn't tell me what this
914240	921600	does, which is why it's better using the static factory method, the public static big, big integer
921600	930880	probable, probable prime conference. I would right there where when I met me, a client is using it
930880	939440	as I've used it right here. I clearly know what this method is doing. It makes the code clean.
939440	943680	And of course, a class can only have a single constructor with a given signature. You can't
943680	948480	have, at least in Java, I don't know about other programming languages, but I don't think so.
948480	955760	One can't have multiple constructors for a class. I assume maybe I'm wrong there, but that's at
955760	960560	least my understanding. And then a very basic question to ask is, what's the purpose of a
960560	966000	constructor? The purpose of a constructor really is, as the name suggests, to construct a class,
966000	972400	as it's said in the Oracle docs, a constructor is used in the creation of an object that is an
972400	981920	instance of a class. Typically, it performs operations required to initialize the class
981920	988400	before methods are invoked or fields accessed. Constructors are never inherited. So for me,
988400	995920	at least as a client, using the probable prime method makes more sense. He says, because a class
995920	1001120	can only have a single constructor with a given signature, programmers have been known to get
1001120	1007440	around this restriction by providing to constructors whose parameters, whose parameter lists differ
1008160	1013920	only in the order of their parameter types, so method overloading. This is a really bad idea.
1013920	1020000	The use of such an API will never be able to remember which constructor is which and will
1020000	1026880	end up calling the wrong one by mistake. People reading code that uses these constructors will
1026880	1033440	know what the code does without referring to the class documentation. Because they have names,
1033440	1039680	as in static factory methods, we don't have this restriction. And when I was reading this paragraph,
1039680	1045200	I had a bit of a grin because in the project that I'm currently working on, which is a huge
1045200	1052480	enterprise, massive Java project, I think we've got 40 odd microservices. I see this happen all
1052480	1058560	the time. We, you know, a lot of legacy code, we've done a lot of method overloading. And sometimes
1058560	1065360	when as a client, I'm using a certain class, or even if I'm instantiating a class, I'm not even
1065360	1071280	sure which method, which parameters to pass into the method, because it's been overloaded so much
1071280	1078880	that it's hard to work on as a client. Whereas with the big integer class, I exactly know what I'm
1078880	1084160	doing here, just using the problem prime method. So the second justification or advantage is that
1084160	1089760	static factory methods, as I sort of said many times already, do not require object creation
1089760	1093600	each time they're involved. It's one of the biggest advantages, in my opinion,
1093600	1099600	that this allows immutable classes for sure. It's also similar to the fly weight design pattern. Now
1099600	1107680	I put this note here, just because I want to kind of put into the notes everything that's in the book.
1107680	1113440	I have no idea at the moment what the fly weight design pattern is. I haven't done any further study
1113440	1119280	into that. So hopefully, when I do, I'll probably revisit this and leave a comment explaining what
1119280	1127520	it is from my point of view. The example that we can use here is in fact, this little method
1127520	1134320	method that I created, it's an example from the book, which was this method right here. It's this
1134320	1139440	simple method that I created called value off. It's an example from the book. So if I want to
1139440	1144640	use this method, and this method is in this class called manipulate strings, I don't have to create
1144640	1152080	an instance of the class. Let me demonstrate. So for instance, if I go here, and if I want to print
1152080	1166400	out something, let's just say value off, and we go manipulate strings dot value off, I'm going to
1166400	1173280	pass a true there. And then I run that, you will see it'll just print true. Okay, sorry for the
1173280	1179280	useless method. And as you saw there, I didn't use a new keyword. There were no objects being
1179280	1186800	created. I simply accessed the method via the class, because that method's owned by the class,
1186800	1192000	so to speak. Then another advantage of not having to create objects is, and it took me a while to
1192000	1197680	grok this concept, because I had to do a bit of stack overflowing to use a term that we all love
1197680	1203920	as soft engineers. It makes classes instance controlled. So it says here in the book,
1204800	1210720	the ability of static factory methods to return the same object from repeated invocations allow
1210720	1218240	classes to maintain strict control over what instances exist at any time. Let's try to understand
1218240	1226480	this. So firstly, just keep in mind this makes a class singleton and non instantiable. So essentially
1226480	1232640	singleton means it at a given time only one object of that class can exist, whatever the class might
1233120	1242000	be, if we follow that pattern. And I really only understood this thanks to Joshim Sao who posted
1242000	1247920	a really good answer on Stack Overflow. I shall leave a link to this down below of what this
1247920	1254640	concept means and how using static factory methods makes classes singleton and immutable.
1254640	1258480	So to get this concept first, let's see what Joshua Block is saying. He's saying that
1258800	1266960	yeah, it allows immutable value classes as I repeated multiple times already. And then it says
1266960	1276640	to make the guarantee that no two equal instances exist as in A equals B. So class A equals B only
1276640	1284480	if it's equal in this sense as in this equals sign means that the values in the objects are compared
1284480	1290800	the double equal sign is a reference or memory location of objects in the heap. So as I said,
1290800	1300080	thanks to Joshim Sao, I think I got what this meant. It gives complete control to the class as to
1300080	1305520	when instances of this class will be created. Now here's the example that he has used. So I did have
1305520	1312800	it here. I'll zoom into that. One of the methods here is deprecated. So you can't clearly as you
1312880	1317600	can see here in the docs, it says that it's marked for removal because we don't really create new
1317600	1323920	instances of the Boolean class anymore. Now I'm going to comment that out for now. And see here,
1323920	1331280	if I print this, we're getting a true and false despite the first one because we're looking at
1331280	1337600	the value in the object, we're getting a true but here in the reference comparison or in the memory,
1337600	1345920	we're getting a false. Now personally for me, this was okay. I got what he meant conceptually,
1345920	1353440	but really what I did was this. I created another small class called fooba. As you can see, I made
1353440	1361200	the constructor private. So it's inaccessible to any client. And then what I did was I created a
1361200	1367200	static factory method called construct fooba. If you can clearly see here what I'm doing is
1367280	1375520	I'm returning a new instance of the fooba class. But in the method body, I have an F condition.
1375520	1381920	And I say only if the number is greater than five, is it allowed to create a new instance of this
1381920	1387520	class. Now, yes, one could say you could do this in a constructor too, but doing it in a static
1387520	1393920	factory method makes more sense due to the previous advantage we spoke about, the fact that we can
1393920	1399200	use the name in the method. So you probably see here, I'm going to comment this out again.
1401360	1407120	Now I'm using the construct fooba method and I'm passing initially I'm passing the number seven.
1407840	1417680	And then if I run that, it's if I zoom in here, there you go. That's the that's the object that
1417680	1422080	that was passed through. So it returned a new object of the fooba class. But that's because
1422080	1428880	seven is greater than five. But if I like pass two, it's an R. So this is this is what
1429520	1436560	Joshua Block means by it's it's it gives classes complete control as to when instances of that
1436560	1441280	class will be created. On that point, I would also say just to just to keep in mind that enum types
1441280	1447200	provide this guarantee by the way. So if you do this comparison that I did before between different
1447200	1452800	classes or between different types, you'd see it follows a pattern with enum types.
1453840	1460720	The third point is, or the third justification or why so to speak is, unlike constructors, static
1460720	1467200	factory methods can return an object of any subtype of their return type. This again, a bit like the
1467200	1473440	instance control bit, it took a bit of time for me to understand what it meant. So let's see what
1473440	1479200	we mean here. The best example to use is certainly my favorite Java framework, the collections framework
1480160	1486720	is to demonstrate what an interface interface based framework is. So the first thing you'll notice is
1486720	1492000	if you go to the collections framework, I mean the class, sorry, if you go to the public class
1492000	1499440	collections, it's constructed as private. So you can't instantiate it. And then if we take a look at
1499440	1507120	this little bit of code that I put in, I'm creating a array list. I'm creating, in fact,
1507120	1514960	two array lists, a source and target list of string type, and I'm adding values into it.
1514960	1520000	And then in the collections class, I'm using this static factory method right here. And
1520000	1525600	what that does is it returns, let me just read the documentation is much easier because they put it in
1526560	1531840	much better terms with brevity, returns the starting position of the last occurrence of the
1531840	1538720	specified target list within the specified source list or a negative one, if there is no such occurrence.
1538720	1543920	So here we have the source list, here we have the target list. And what I'm trying to see is I'm
1543920	1553120	trying to find the first occurrence of this value of the target list in this case. So as you can see,
1553120	1561040	this CDE, which is the, let's call it the sub list for the old intents and purposes,
1561600	1568560	it starts at the index number two, zero, one, two. And if you print that out, it returns that here.
1569120	1573920	Now, that's, that's besides the point. But the important point here for over here is that
1574720	1582880	the collections class is returning a type of index of integer. It's returning a subtype,
1582880	1589360	as it says here, is that unlike constructors, they can return an object of any subtype of their
1589360	1594800	return type. So it's returning an integer subtype, which is different to the type of the
1594800	1599280	collections class. And then of course, he expounds on the matter, he says, this technique
1599520	1607600	lends itself to interface-based frameworks, where interfaces provide natural return types
1607600	1612080	for static factory methods. And of course, a good example of that is the collections framework. This
1612080	1618960	class itself just going through it would prove that. Then he says, prior to Java 8, interfaces
1618960	1626160	couldn't have static methods. By convention, static factory methods for an interface named type
1626960	1634400	were put in a non-instantiable companion class named types. So these kind of methods
1634400	1640800	had to be moved to a separate class. And then, as I said, he says, for example, the Java
1640800	1648160	collections framework has 45 utility implementations of this, of its interfaces, providing unmodifiable
1648160	1653840	collections, synchronized collections, and the like. Nearly all of these implementations are
1653920	1661680	exported via static factory methods in one non-instantiable class, namely this right here,
1661680	1668160	Java utility collections. Furthermore, using such a static factory method requires the client,
1668160	1673520	which is me in this case, to refer to the return object by interface. That's what I'm doing right
1673520	1681360	here. Interface rather than the implementation class, which is generally good practice. The
1681440	1688480	fourth advantage is that the class of the return object can vary from call to call as a function
1688480	1695280	of the input parameters. And the example he's used in the book is that in the enumset class.
1696960	1704880	So let's take a look at that. What I've done here is, oh, by the way, the example I've used is,
1704880	1711280	thanks to Bill Dung, I know that every Java developer out there uses this website as
1711360	1716240	reference, but I know that all of us struggle to pronounce this word right here. I think it's
1716240	1722320	pronounced Bill Dung. It's the best outside of the Java Oracle docs itself. It's, in my opinion,
1722320	1730800	the best resource out there. So courtesy of Bill Dung for this example. So to get back to this,
1730800	1736720	what does Joshua Block mean by the return object or the class or the type of the return object can
1736720	1742160	vary from call to call, depending on the input of the function. So I'm using the static factor
1742160	1751040	method, none of here, which is a part of the enumset class. And I'm passing a enum into it,
1751040	1754800	which is this enum I created called color, which is contains about a bunch of colors.
1756160	1766240	And then it returns a enumset. Now, what changes here? So what changes here really
1766320	1775040	is this. In this method, you could probably see, it extends to generic. That's fine.
1776240	1779520	Well, not that's fine. It has to be a generic because the types have to differ.
1780640	1787040	So of course, if it's null, it'll throw a class class exception. However, you see this, the
1787040	1792320	returning object, there are two types of objects that are being returned here. If the length of
1792400	1799360	the enum pass, so the enum, but I'm passing colors here, if the length of this is greater than or
1799360	1805760	greater than or equal to, sorry, less than or equal to 64, it'll pass a new instance or a new object
1805760	1814720	of the regular enumset class. So if I run this code now, you'll probably see here, I'm printing
1814720	1821920	out the class name of the return enumset. The class name is regular enumset. It's in fact a
1821920	1827360	subclass, pardon me, or a subtype to be more accurate. If you look here clearly, it's of a
1827360	1835040	different type. It's not the type of enumset. Now, what happens here though is if the past enum is
1835040	1840320	greater than 64, it returns a different type called a jumbo enumset. So it's this flexibility
1840320	1845920	that using a static factory method gives us. So to reiterate, depending on what the input is to
1845920	1852320	this method, a different type can be returned. It'll vary purely based on the input. And then
1852320	1859280	Joshua Bock says that clients need to know, no care about the class of the object, they get back
1859280	1865680	from the factory. They care that only it is some subclass of the enumset. Correct. As far as I'm
1865680	1873920	concerned, when I was using the none of method, all I wanted it to be was of the type enumset.
1873920	1879360	I didn't care what subtype it was or what subclass it was. And that moves to the final
1879360	1885360	justification as to why one should use static factory methods as per recent by Joshua Block.
1885360	1891120	And I got to say, if you can already see from this video, I'm even struggling a bit to explain
1891120	1896880	myself and properly articulate my understanding of these concepts. Perhaps that's my own lack of
1897600	1902880	communication, lack of the ability to articulate myself, but also it's because I'm still dealing
1902880	1908240	with issues and trying to make sense of it in my own mind. This one right here, the fifth point,
1910080	1916320	it took me about a week to write the script. The fifth point, I spent four days on it because
1917280	1923120	it did take a bit of understanding of the JDBC framework to see what Joshua Block is talking
1923120	1928800	about here. The fifth point he tries to make is that the class of the return object need not exist
1928880	1934720	when the class containing the method is written. So let me reread that. The class of the return
1934720	1942560	object, whatever the method invocation returns, need not exist when the class containing the
1942560	1948960	method is written. Now, firstly, he says such flexible static factory methods form the basis
1948960	1954480	of service provider frameworks. I was a bit embarrassed because I've used JDBC quite a lot,
1954480	1958720	but I didn't know that it was a service provider framework. I didn't know that that's what it was
1958800	1964960	called until I read this book. And it's kind of funny how, by the way, I just want to make this
1964960	1970480	point here. The great thing about reading such books is that all these different libraries,
1970480	1976160	like all the frameworks like the collections framework or JDBC API that we use in our day-to-day
1976160	1982560	job that we really don't think too much about, we start really appreciating the engineering and
1982560	1987120	the kind of the craft of them once we understand the reasoning and the principles behind how they
1987120	1997040	were built. So this is a good example of how JDBC is a, sorry, my mind threw a blank there,
1997040	2001840	a service provider framework. So I find it a bit hard to understand the point
2001840	2008960	Joshua was making using the JDBC framework. However, just to get the ideas of what it is,
2008960	2016320	I put together this bit of code here. And as I read before, it's got the provider registration
2016320	2025360	and the service interface. So in the startup code here, the driver manager dot, sorry, the
2025360	2032080	registered driver, this bit here is the provider registration and driver is the service provider
2032080	2036800	interface. And then if we go here to connection again, connection is the service interface
2037440	2043440	and driver manager dot get connection is the service access API. So essentially what I'm
2043440	2052880	trying to demonstrate here is the different components of what the service provider framework
2052880	2058400	encompasses. And as you clearly saw, I had a terrible job at explaining how this relates to
2058400	2064880	our item in using static factory methods, which is why I found a much simpler example
2064880	2073280	on second of a flow where we have this right here. This was by Bruno Reyes and I thought he
2073280	2077360	explained it much better. So he says here, with this code, your library doesn't need to know
2077360	2082800	about the implementations of the service. Users of your library would have to set a system property
2082800	2089040	containing the name of the implementation they want to use, which is if we go down here,
2089040	2095440	this static factor method here, which is stored in this class will just give us a new instance.
2096880	2103040	As in, I don't care if this class was created or if it exists or not, all I'm expecting is because
2104080	2108720	I'm getting it through the through the contract between the interface that I'm getting a
2109760	2116240	instance of the my service class. That's it. Gosh, I think I butchered that. So again, to reiterate,
2116800	2122160	this static factor method for name is going to provide an instance of some class, which is
2122160	2128720	the class right here. In this case, it's the driver class. And that's all I care about. I just wanted
2128720	2134560	to come off this type. I'm doing a typecast here. And that's all I really care about. And that's
2134560	2141520	because of this contract that I have with the interface, essentially. Okay, this is why I said
2141520	2146560	that this isn't a tutorial, because that fifth item is something that I'm still struggling with.
2146560	2153360	And I swear, I try to make sense of it through the JDBC framework, but it's still it was a bit
2153360	2158560	hard for me to really grok. And then I found this answer on Stack Overflow, which I thought was
2158560	2165280	done much better. But look, if any of you know a better way of explaining it, please do leave it
2165280	2170400	down in the comment section, I would be very grateful for that, because that's certainly one
2170480	2174880	advantage from this item that's still I don't I don't still fully get. So having discussed all
2174880	2180640	the advantages or justifications, a proposal, using static factor methods, let's now get to the
2180640	2186160	limitations. The limitations aren't really much. So it makes a lot of sense to use them in most
2186160	2193520	places, unless there's an exception, let's say. The first one is that classes cannot be subclass
2193520	2199680	without public or protected constructors. On the note, just before I get to demonstrating what this
2199680	2205280	means, there's a good resource, sort of, I guess, an answer on Stack Overflow that I found, which
2205280	2211760	discusses why constructors are needed for subclassing. And I thought it was quite good. So I'll leave
2211760	2216720	a link to this in the description down below too, if you want to go give it a read. But simply,
2216720	2225200	it's very easy to show. So here I have a class called main. And then I have one class, which is
2225200	2232640	another another class called animal with constructor. So if I go to that right here,
2233840	2238320	here we have the public class. And we have a public constructor, as you can see here,
2238320	2249360	now I can easily go to the main class and type extends animal.
2254880	2260800	There we go. And it simply extends that class. However, now I have another class without a
2260800	2266400	constructor. In fact, I've made the constructor private. So it's not accessible by the by the
2266480	2273600	subclasses. And if this tries to extend this, and it raised wrong, it says here,
2273600	2280320	there is no default constructor available in the superclass. So and also if I try to create
2280320	2284080	an instance of this, we get the same error. What's funny here, though, is of course,
2285600	2291760	Joshua Block says, and I'll read this out. Arguably, this can be a blessing in disguise,
2291760	2296240	because it encourages programmers to use composition instead of inheritance.
2296960	2302640	Exactly. I don't have to extend that class. I can use one of the most fundamental OOP
2302640	2310320	design principles to try and favor composition over inheritance. The second limitation is that
2310320	2315360	he says, I don't even really know what he means here, that it's hard for programmers to find that
2315360	2321280	these methods are hard to allocate. I'm not sure if that really applies anymore, because with,
2321360	2327280	for instance, I use IntelliJ with really powerful exhaustive ideas like IntelliJ,
2327280	2331920	all I got to do is hit command and click on the method and boom, I'm there. I've got the docs,
2331920	2336080	everything I need. So I wouldn't say it's hard for programmers to find. Nevertheless,
2336080	2342800	he does state that. So I'm sure there's a good reason for it. And then what he says is because
2342800	2346560	some of these static factor methods are hard for them to find that he's going to
2347120	2351360	enumerate a few of them and list down some commonly used static factor methods.
2351360	2355360	So I thought I'd do the same. And once again, all of this code is going to be on get up. So if you
2355360	2360480	want to take a look at some of these methods, just click the link down below and you'll have
2360480	2369120	access to it. So the first one is a from method, which does a, it's essentially a type conversion
2369120	2376080	method. So it's quite easy to understand really what we have here is we have a type of instance,
2376080	2382160	and we pass it to, to, to the date. And from, from that instance, we get a type of date. So
2382160	2390320	it does a type conversion. If I run that code, you'll see that that instance type was converted
2390320	2396480	to a date type. And then it printed it down here. The second one is a aggregation method.
2396480	2402000	What this does is similar to a previous example that I use, is it takes this enum list. So I've
2402000	2411440	got a enum, uh, cold rank here, Jack, Queen, King. And then it just gives us a set, an enum set of,
2411440	2414560	of this enum right here. So if I do print that out,
2417040	2422400	you can see here it's printing that set under face cards. So it makes sense to call it an
2422400	2427760	aggregation method. Cause what it does is it takes all these different items in an enum,
2427760	2434800	enum class, and then aggregates them and returns a type of enum set. And then we have the big integer
2434800	2439680	value of, which again, this is the same thing. It's a type conversion method. Uh, and he says,
2439680	2446160	yeah, it's a verbose alternative to, to from and off. So in this example, you could probably see
2446160	2452080	I'm passing into this method, uh, something of type integer, and it returns something of type
2452080	2457040	big integer. So it does that type conversion there. The next example is, uh, it's sort of like
2457040	2462800	I've created a quasi demo for this get instance methods. Essentially what it does is that it's
2462800	2469280	described, uh, it returns an instance that is described by its parameters, if any, but cannot,
2469280	2475760	but cannot be said to have the same value. So the example here would be, I've got this void method
2475760	2484000	called method three, and this stack walker class here is getting an instance of the, uh, class,
2484000	2490320	this class that invocates this method. So here is, this is in the stack walker demo class.
2490320	2498880	And as you can see, if I go up here, there's an instance, uh, oh, that was a mistake. I should
2498880	2505120	have, I wonder, I should have made that a static method. I don't know why I, let me correct that
2505120	2516800	right now. Public static. That is good because it shouldn't be a, sorry, that was a confusion.
2516800	2522640	The actual static factory method was this in the stack walker class to get instance class.
2522640	2527840	This is what happens when I work on these things way back and I record the video on a separate day.
2527840	2532800	Sometimes even I forget why I did what I did, but just to get back to this. So I've created
2532800	2538800	the stack walker demo class and I've created an instance of it right here, which is boom.
2539680	2543600	And I'm accessing this method through the object or the instance of that class.
2544800	2549200	And what this is really is, it just prints out the caller class. So the stack walker
2549200	2555680	dot get instance, as you can see here, it prints, it gives us a reference to the class that invoked
2555680	2561680	this method. So method three was, method three was invoked by this class here,
2562800	2568240	the common static factory methods class. So if I print this out, you'll see here,
2570320	2576800	it tells us, huh, this was the class that invoked this method and it's using the get instance
2576800	2581760	static factory method. And the next example is quite similar. The new instance method will
2581760	2589520	guarantee that every invocation of it will return a instance of the string dot class here, the class
2589520	2597680	that I've specified here. So I'm passing an array and then I'm also passing the type of the class
2597680	2606000	here. In fact, let me just go to that method. It takes these parameters as shown here, it takes the
2606960	2612880	yes, the component type, the type of the class, it's a generic, and then the length of the array.
2612880	2616640	That's what this does. And if I print that out here, it just prints out the type of the class
2616640	2621040	you can see here. It's just a string class that I've passed through. And then the get type static
2621040	2626560	factory methods are similar to the example, not this example, the previous one with the stack
2626560	2633680	walker demo class that we, with the get instance demo there. What this does is it returns a different
2633680	2638640	type, essentially. So if you look at this here, I'm getting a path, I've got a file that I've
2638640	2648960	created. And if I go to the files class, it's of type files, obviously. And then this get files
2648960	2658160	to static factory method returns a different type. It returns a type of file store, despite being
2658160	2662880	in the class files. And if you look at the method, you'll see, I'll zoom in there again,
2664320	2670400	the get file store, it's in a separate abstract class called get file store. Pardon me, it's in
2670400	2676880	a separate abstract class called file store. So it's not in the files class. And similarly,
2676880	2682320	the buffered reader does the same thing, but instead of getting a new instance, it creates a
2682320	2687520	new instance. So if you go to the buffered reader, which again is in the files class,
2687600	2691920	if you go to the static factory method, it is returning a new instance of,
2694480	2700400	whoa, that's a bit weird. Oh, of course, of buffered reader. There we go. And of course,
2700400	2704720	similarly, the new type, this is the same thing, but instead of getting an instance,
2704720	2711360	it'll return a new instance. So if you go to the new buffered reader static factory method, which is
2711360	2717360	in the files class, by the way, as you can see here, it returns a new instance of buffered reader.
2717520	2722800	Again, it's a different type or to what what files is, or it's in a different class, let's say.
2722800	2728480	And finally, really, all the other stuff won't even that useful because, well, they are useful,
2728480	2734480	but I think most of us use this, the generics, which is in the collections, things like less
2734480	2742640	area lists, which I'm in the collections framework. And what this does is it returns a new vector
2742640	2750880	of a given type. So for instance, I've created this enum called complaint, and I can create a list
2750880	2756720	of that type and add stuff into it, essentially. And if you want to see, it's going to print all
2756720	2763680	that stuff. All these examples that I've used was sort of in the book, and I repurposed them
2764480	2769040	just for me to understand. But really, from all the static factory methods I went through,
2769040	2774000	I think the ones we use mostly are the ones in the Java collections framework. Nevertheless,
2774000	2779520	it's important to enumerate all of them. And in summary, Joshua Block says, static
2779520	2784640	factor methods and public constructors both have their uses, and it pays to understand their
2784640	2791840	relative metrics. Often, static factor methods are preferable. So avoid the reflex to provide
2791840	2794720	public constructors without first considering static factories.
2794960	2802400	That was much harder than I thought. I have to admit, I thought I could sort of go through my
2802400	2807840	thought process, but you know, any programmer would understand that sometimes we don't even
2807840	2811920	know what we do, what we do, we just type and things just happen. That's fascinating, isn't
2811920	2818000	it? In any case, I hope you enjoyed the video. I hope you found it informative. I certainly,
2818000	2823280	as I said in the proviso middle, I'm sure I've made a lot of mistakes, so please do point them out.
2823280	2827840	In some sense, selfishly speaking, for my own learning, but also so that I don't
2831040	2837760	mislead anyone and provide false information. I've already started working on the next item.
2837760	2845040	I'm still rereading that item and starting the different examples. The second item is
2845040	2851760	consider a builder when faced with many constructor parameters. I shall hopefully get to that soon,
2851760	2857360	but at least for now, I hope you enjoyed this item and I'll see you in the next one. Cheers.
