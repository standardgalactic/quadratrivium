WEBVTT

00:00.000 --> 00:07.200
Hey everyone, welcome to yet another episode of my video series on Joshua Block's effective Java

00:07.560 --> 00:09.560
where I cover and

00:09.560 --> 00:15.200
Expound on the items that he has emulated in this book and of course

00:15.840 --> 00:20.160
what I've been trying to do in the previous videos or episodes is to

00:21.120 --> 00:26.480
Flesh out and try and make sense of what he's talking about in the different items in this book and

00:27.160 --> 00:30.300
Hopefully as I try to make sense of them the purpose of me

00:30.720 --> 00:37.320
Sharing this publicly and uploading these videos is that you too can gain some value from it. That's one

00:37.320 --> 00:39.320
I would say that's a primary purpose

00:39.760 --> 00:46.400
But the other is of course that there's that sublime effect where by me trying to teach someone a

00:46.960 --> 00:48.960
concept that I really

00:49.360 --> 00:52.320
Fundamentally don't still properly grok or understand

00:53.240 --> 00:59.800
Paradoxically, I understand it better. So yep, it's it is sublime indeed and it works well

01:00.680 --> 01:04.440
Say all that without further ado, let's get started. So as per usual

01:04.440 --> 01:07.380
I'm gonna repeat the introduction that I've sort of

01:08.080 --> 01:13.200
Repeated in all the other episodes. I just feel like I need to do that kind of due diligence as a sort of ethical duty

01:13.200 --> 01:14.480
Let's say

01:14.480 --> 01:19.320
So if you do want to skip it, of course, please go ahead because I'm just repeating the same old points

01:19.320 --> 01:21.120
I don't want to waste your time

01:21.160 --> 01:26.000
This is not a tutorial. That is the first caveat in this proviso. This is not a tutorial

01:26.000 --> 01:29.000
I am not a teacher and I certainly am non-expert

01:29.560 --> 01:34.320
in fact a point that I've been repeating ad nauseam is that the more I've

01:35.000 --> 01:37.320
Understood Java and the concepts

01:37.880 --> 01:41.680
He's outlining this book Java and OP in general

01:42.400 --> 01:48.080
I'm realizing how much of an expert I'm not so that's really interesting and very humbling indeed

01:48.080 --> 01:51.480
And I don't mean that in a false modest sense. I mean, that's sincerely

01:52.120 --> 01:55.320
An analogy or yeah, probably an algae

01:55.320 --> 02:02.240
I'd like to use to explain what I'm trying to do here is the blind living the blind. I am as naive or perhaps even more

02:02.880 --> 02:04.720
blind and

02:04.720 --> 02:06.720
ignorant and naive and oblivious all of those

02:07.320 --> 02:09.320
things

02:10.040 --> 02:16.600
As as much as you are and yeah, even probably even more. So this is not my tutorial

02:16.600 --> 02:18.600
I'm not trying to teach you anything

02:18.840 --> 02:22.920
So whatever I say, please do take it with a grain of salt. This is a

02:24.080 --> 02:24.880
Exploratory

02:24.880 --> 02:29.320
Disquisition another analogy. I've been using as what one would see in a

02:30.280 --> 02:33.400
University tutorial where we've got a tutor

02:34.720 --> 02:38.280
bunch of students trying to make sense of and understand a

02:39.040 --> 02:44.280
problem statement or some some programming principle, which is why unequivocally I will

02:44.800 --> 02:48.760
Inevitably make mistakes. So please point them out not just for my sake

02:48.760 --> 02:54.360
But even for anyone that's watching these videos if I do make a very fundamental

02:55.200 --> 02:57.200
Crucial mistake

02:57.200 --> 03:00.240
I'll try my best to be rectified by leaving a comment myself

03:00.240 --> 03:05.400
But if you do pick it up, I shall pin those comments just so that I don't mislead anyone

03:06.920 --> 03:08.920
With any

03:10.160 --> 03:12.400
Fake news to use a politically

03:13.400 --> 03:20.640
Overloaded term and of course as this is a programming video series all the code that I've been using for this effective Java series

03:20.640 --> 03:25.160
It's available on my GitHub. I've got a separate repository for each item and

03:26.280 --> 03:29.640
As I go through these all the code will be published here

03:29.920 --> 03:34.280
Anyway, now that we got the proviso out of the way, let's get started with item number six

03:34.840 --> 03:36.840
where Joshua block states

03:37.440 --> 03:39.440
Avoid creating

03:39.440 --> 03:42.640
unnecessary objects and this is quite an interesting one because

03:43.600 --> 03:46.840
I certainly am guilty of doing this of making these mistakes

03:47.600 --> 03:51.120
So it's it's valuable and worth our time. I think that's

03:51.880 --> 03:55.640
Java or generally OOP programmers to

03:56.240 --> 04:01.960
Understand why, you know, just sort of creating objects at a hawk without putting any thought into it

04:02.120 --> 04:05.160
There's a bad idea and perhaps even an anti-pattern

04:05.760 --> 04:09.880
Of course, this we are still in chapter 2 in creating and destroying objects

04:10.280 --> 04:16.200
So before we get to any of the content in the book, I kind of want to get some fundamentals real

04:16.920 --> 04:18.920
OOP basics out of the way

04:19.440 --> 04:21.760
Look, if you don't know what objects are this

04:22.640 --> 04:28.240
Video series really probably is a bit above your level. I'd say go and watch some basic

04:29.040 --> 04:33.720
OOP fundamental videos on YouTube just watch like a basic tutorial, but

04:34.200 --> 04:42.080
The definition we all hear of an object is that it is an instance of a class and the class is what acts as a blueprint

04:42.440 --> 04:44.440
as to how it defines

04:45.360 --> 04:49.000
How an object behaves when it is instantiated

04:49.600 --> 04:55.000
but something a bit more formal is the definition by the oracle docs and

04:55.760 --> 04:57.760
He goes like this

04:58.000 --> 05:03.920
Software objects are conceptually similar to real-world objects. That is true something. I truly

05:04.360 --> 05:09.720
Admire and appreciate about object oriented programming. I think it's brilliant that they've created that connection

05:10.080 --> 05:12.920
In fact, sorry to go off on a tangent here

05:13.600 --> 05:15.600
if you do start

05:16.480 --> 05:21.920
Following some of the design patents a bit more seriously so for instance the 23 patents

05:22.680 --> 05:26.160
popularized by the Gang of Four you'd see a lot of those patents to

05:26.880 --> 05:32.040
Have many deep connections to engineering patents in the world

05:32.800 --> 05:40.360
That's let's say not the conventional. Sorry the the the the conventional world which doesn't invoke which doesn't

05:41.160 --> 05:46.520
Attain to software engineering, but sort of the let's say civil engineering or some other kinds of engineering

05:47.280 --> 05:50.640
Anyway, sorry. Sorry. I'm going off on a tangent back to the definition

05:50.800 --> 05:57.600
Software objects are conceptually similar to real-world objects. They too consist of state and related behavior and

05:58.440 --> 06:01.440
Objects totes so it's state in fields

06:01.600 --> 06:10.240
Which are variables in some languages and exposes its behavior through methods of course and we shall see a few examples of that in this item

06:10.960 --> 06:12.960
Which are called functions in some languages

06:13.800 --> 06:19.120
methods operate on an object's internal state and serves as the primary mechanism

06:19.880 --> 06:21.880
for object-to-object communication

06:22.840 --> 06:30.720
Hiding internal state and requiring all interaction to be performed through an object's methods is known as data

06:31.360 --> 06:35.600
Encapsulation a fundamental principle of OOP or object going to programming

06:35.600 --> 06:41.520
So once again, if you don't know what encapsulation is what inheritance is those really fundamental ideas in OOP

06:41.520 --> 06:44.240
I think this video is a bit above your level

06:45.000 --> 06:48.840
Yeah, so that's probably should be caveat for this item in particular

06:49.560 --> 06:56.280
Okay, so now let's try to understand from a JVM and memory management perspective

06:56.280 --> 07:00.200
Well more from a JVM perspective. We're not gonna go too deeply into memory management

07:00.880 --> 07:04.120
how these objects exist at least

07:05.400 --> 07:13.760
Apropos the Java virtual machine now again, you would know what the JVMS JVM is what allows to execute Java code on

07:14.160 --> 07:17.160
Any any machine, which is what makes Java

07:17.960 --> 07:22.560
Quite popular because it can work on any operating system for instance

07:23.360 --> 07:24.600
so

07:24.600 --> 07:29.680
We have the call stack of course. Here's where we make calls or we give instructions

07:30.160 --> 07:33.520
To call different objects and whatnot our different methods. Sorry

07:34.680 --> 07:42.160
And the JVM primarily divides the memory into two two spaces or two domains now, of course

07:42.160 --> 07:44.480
Oops, I had the microphone now, of course

07:45.480 --> 07:52.440
It's okay. So firstly, it's the stack memory and the heap space now, of course these two high-level

07:55.040 --> 08:02.200
Demarcations also further divided into let's say sub-domains so the heap space for instance would have the dynamic meta space

08:03.000 --> 08:05.720
Which holds static content and we'll get to that too

08:07.520 --> 08:12.000
So the stack memory is used for static memory allocation, that's correct

08:12.000 --> 08:17.640
What static memory allocation sort of means for all intents and purposes is that an object created?

08:18.040 --> 08:23.120
Statically, let's say once it's in memory. It will remain in that state

08:23.640 --> 08:28.960
Throughout the application lifecycle, whereas dynamic objects change state

08:28.960 --> 08:32.560
They can change and they don't live in the stack memory

08:33.440 --> 08:34.640
so

08:34.640 --> 08:36.640
Also the the stack memory

08:37.040 --> 08:40.960
Again pretending to the JVM and Java holds primitive values

08:40.960 --> 08:43.920
So values like int or char

08:44.600 --> 08:46.680
These types live in the static memory

08:47.480 --> 08:50.320
and of course as I said before it

08:50.840 --> 08:53.200
Well, I don't think I did say that before anyway

08:53.640 --> 08:59.800
There are references to dynamic objects that live in the heap space now look all these definitions are fine

09:00.040 --> 09:03.600
For starters, but the best way to make sense of it is of course to an example

09:04.160 --> 09:08.200
So if we take person here this in the person method

09:08.800 --> 09:09.920
this

09:09.960 --> 09:16.360
Int value that you're passing that would live because it's a primitive type and it's a primitive

09:17.320 --> 09:20.680
Variable that would live in the stack memory

09:21.800 --> 09:26.040
Also, I apologize if I did say static memory before I should have said stack memory

09:26.640 --> 09:31.880
And then string which is a class and it's you know a class you can create an instance of that class

09:32.560 --> 09:37.080
What would live in the stack memory in that case wouldn't be the object itself

09:37.080 --> 09:44.520
but rather a memory address or a reference to the actual object which lives in the heap space in the string pool in this instance

09:44.680 --> 09:49.320
So and that's dynamic its state can change unlike some of the

09:50.080 --> 09:51.640
static types

09:51.640 --> 09:53.000
so

09:53.000 --> 09:58.920
Yeah, as I've written down here. There's a few notes. I took just to make sure that I stay on track. It's

10:00.240 --> 10:05.600
It's used for dynamic memory allocation of Java objects and GRE classes at one time

10:05.600 --> 10:08.160
So that means when applications running its state can change

10:09.440 --> 10:17.480
Also new objects which sometimes seem to be short-lived live live in the heap space. I shouldn't just say it outright

10:18.040 --> 10:20.040
Tends to be short-lived. There are

10:20.600 --> 10:23.800
some long-lived objects and here's where you know

10:24.520 --> 10:30.400
The different algorithms in garbage collection so that that's garbage collection is essentially essentially

10:30.880 --> 10:38.440
Memory management here. Here's where different algorithms play a role and allocate objects into you know, like for example the permanent space

10:38.440 --> 10:42.320
I think it used to be called like the nursery different parts of the

10:43.120 --> 10:49.200
The heap space. I'm not gonna go into that. This is this this video is gonna be way too long if you're getting to memory management and Java

10:49.720 --> 10:51.720
but the point is

10:51.720 --> 10:53.720
these objects are dynamic and

10:54.680 --> 10:57.960
They the references for them are stored again in stack memory

10:58.960 --> 11:00.480
And

11:00.480 --> 11:05.560
On that note, of course now that we understood sort of how objects exist at a very very high level

11:06.000 --> 11:08.000
Pertaining against Java and JVM

11:08.200 --> 11:14.520
Let's get to the item and the item essentially is telling us how to reuse objects and why in fact it's better

11:14.960 --> 11:20.280
To reuse objects than creating new ones and how doing so will make the code

11:20.960 --> 11:27.920
Cleaner more stylish more professional if you could use that term and even as we shall see with some examples

11:28.320 --> 11:31.560
Make the code run faster and that definitely is a benefit

11:31.560 --> 11:35.920
So the book starts off with a rather ridiculous example as what not to do

11:35.920 --> 11:42.080
So as Joshua Block has pointed out he has left the comments in an extreme example of what not to do

11:42.080 --> 11:45.480
I've never seen this done by any programmer to be honest, but

11:46.160 --> 11:53.760
This certainly isn't something one has to do where when we already have this string. We create another instance by using a new keyword

11:54.520 --> 11:57.120
This is sort of how most of us do it

11:57.120 --> 11:59.120
So the proper way

11:59.960 --> 12:03.680
The improved version he calls it, but let's just say it's a proper way and

12:04.800 --> 12:06.800
Here's what Joshua Block states

12:07.000 --> 12:15.280
The statement creates a new string instance each time it is executed and none of those objects object creations is necessary because

12:15.480 --> 12:18.000
So bikini can live here and

12:19.080 --> 12:24.160
Then it could just point to that all the all the references one one object can exist in the

12:24.720 --> 12:33.440
Heapspace, but if you have this new keyword every single time it's invoked a new object is created and that is a completely inefficient

12:34.080 --> 12:35.680
and

12:35.680 --> 12:37.680
ridiculous waste of space and time

12:39.120 --> 12:47.040
The argument to sorry I'll show it scroll down the argument to the string constructor bikini is itself a string instance that is correct

12:48.040 --> 12:56.800
Functionally identical to all of the objects created by the constructor if this usage occurs in a loop or in a frequent frequently invoked

12:57.400 --> 12:58.600
method

12:58.600 --> 13:01.760
Millions of string instances can be created needlessly

13:02.160 --> 13:06.400
So here's an example of what he definitely shouldn't do and just like the Bible

13:06.400 --> 13:11.920
We're gonna go from the Old Testament where what the goat says what he shouldn't do and in our case the Java code

13:12.080 --> 13:19.920
Joshua Block tells us don't don't do this. That shall not do this to the New Testament what you should do and what you should consider

13:20.680 --> 13:23.880
on when when writing code as to how

13:24.360 --> 13:27.720
These techniques can allow us to reuse objects

13:28.480 --> 13:31.880
It's interesting how I just converted this into a theology session

13:34.320 --> 13:39.280
So the first way one could easily reuse objects is something we already covered in

13:39.360 --> 13:43.960
In at item one is in fact using static factory methods

13:43.960 --> 13:47.160
I should say as Joshua Block stays here. In fact, I'll just read it out

13:47.160 --> 13:53.160
You can often avoid creating unnecessary objects by using static factory methods in

13:53.840 --> 13:57.520
preference to constructors when immutable classes that provide both

13:58.040 --> 14:05.760
So the example here would be the Boolean class where value of is a static method and that is indeed preferred over

14:06.400 --> 14:07.480
using

14:07.520 --> 14:12.960
The constructor and I think since Java 9. Yes, it does say here

14:13.440 --> 14:18.520
This has been deprecated. We can't even use this constructor because it's been made private. So

14:19.160 --> 14:25.200
The the static factory method doesn't require a creation of objects every time it's invoked

14:26.240 --> 14:31.680
Because static members are common to all instance instances of a class and again the way I think about it

14:31.680 --> 14:36.600
Oh, I guess this is exactly the way one should think about it is it belongs to the class

14:37.440 --> 14:42.400
Therefore, all the instances of that class will will share this

14:43.360 --> 14:44.680
Static member

14:44.680 --> 14:51.680
So that member itself can be shared up amongst all objects whenever that class is instantiated and

14:52.800 --> 14:54.800
As I did mention a bit before

14:54.840 --> 15:01.640
Static variables live in something called the dynamic meta space within heap memory and also an ancillary point

15:01.640 --> 15:05.640
He also adds in addition to reusing immutable objects

15:05.640 --> 15:10.200
You can also reuse immutable objects if you know they won't be modified. So

15:10.800 --> 15:13.760
For reusing objects, they don't have to all be declared

15:14.480 --> 15:15.960
final and

15:15.960 --> 15:21.640
Static and make for them to be mutable rather even if we know a certain object is

15:22.920 --> 15:27.880
Mutable, but still it won't change. We could reuse that using static factory methods

15:28.640 --> 15:34.860
So there could be some operations where it's much more computationally expensive to keep

15:36.080 --> 15:40.680
Invoking a certain function and here's the example Joshua block has used

15:40.680 --> 15:44.920
So before I do get to the example, probably I'll just go through his justification

15:45.160 --> 15:50.400
He says some object creations are much more expensive than others. That's right

15:50.400 --> 15:54.600
If you're going to need such an expensive object repeatedly

15:54.640 --> 15:58.120
It may be advisable to cache it for reuse

15:59.120 --> 16:03.760
Unfortunately, it's not always obvious when you're creating such an object. That is true

16:03.760 --> 16:09.840
However, here we have a solid example where this could be computationally expensive and that is

16:10.600 --> 16:12.600
using regular expressions

16:12.760 --> 16:15.440
So this is a very very simple class

16:16.000 --> 16:20.280
Well, what it does. Well, the class has these static methods

16:20.960 --> 16:22.960
we have well

16:23.960 --> 16:28.680
Practically it should only have one method called is numeral, but just for

16:29.240 --> 16:31.960
Demonstrative purposes we have is numeral slow and

16:32.560 --> 16:36.920
It's numeral fast and we shall see why we have those two methods in a bit

16:38.120 --> 16:43.480
So firstly the slow method what it does. Okay, so let me let me take a step back

16:45.160 --> 16:49.080
What this method does is it returns a true or false and

16:49.160 --> 16:54.440
And what that true or false tells us is if a string we pass on to this

16:55.080 --> 16:57.080
fulfills a certain regular expression

16:57.880 --> 17:04.040
And what that regular expression is looking for really is if the string we pass on to is a Roman Roman numeral

17:05.080 --> 17:06.440
and

17:06.440 --> 17:15.000
Here here though, this is the slow way what happens here is every single time we invoke this method and we pass the string

17:15.680 --> 17:18.600
The the the string class invokes the matches

17:20.080 --> 17:24.360
Method which uses a finite state machine

17:25.240 --> 17:30.160
Which we shall we shall get into what that is a finite state machine to do the matching

17:30.720 --> 17:37.440
And and that is computationally expensive. So every single time a pattern instance has to be created here

17:38.080 --> 17:44.320
A pattern instance really that won't change but for we know that why would we not reuse it

17:44.320 --> 17:46.320
But every single time the method is invoked

17:46.640 --> 17:51.840
We're creating this finite state machine instance and then after it's done

17:51.840 --> 17:57.720
It has to be garbage collected and the JVM has to take care of it. So that is computationally expensive. So this is a slow way

17:58.480 --> 18:03.920
But what he does propose instead is to cash it. So we have the regular expression instance

18:04.000 --> 18:05.560
We call that

18:05.560 --> 18:12.760
Roman here and we use this compile method in the pattern class and we explicitly compile it into an immutable pattern instance

18:12.760 --> 18:18.520
Which we still here and we call it Roman as I said and then we just reuse that in the esnemeral fast method

18:18.840 --> 18:20.760
Simple as that and to put it most succinctly

18:20.760 --> 18:26.560
He states while string dot matches is the easiest way to check if a string matches a regular expression

18:26.600 --> 18:28.800
Which is what we've sort of done here

18:30.480 --> 18:34.920
It's not suitable for repeated use in performance critical situations

18:35.200 --> 18:39.000
He continues creating a pattern instance is expensive

18:39.320 --> 18:40.960
Because it requires

18:40.960 --> 18:44.760
Compiling the regular expression as I said into a finite state machine

18:44.760 --> 18:50.280
So let's get a quick understanding of what a finite state machine encompasses because it pertains to the topic

18:50.520 --> 18:54.280
This is definition. I found from brilliant org by

18:54.840 --> 18:57.480
Kale more and Deshan Gupta is a

18:58.040 --> 19:02.720
system where particular inputs cause particular changes in state can be

19:03.160 --> 19:07.480
represented using a finite state machine or using finite state machines and

19:07.960 --> 19:14.520
This is a really good example. I found it was a 10 minute video by Valhalla data systems and the book here

19:14.520 --> 19:20.880
He not only explains quite simply with brevity what a finite state machine is

19:20.920 --> 19:24.960
But also afterwards shows a solid implementation in Java code

19:25.040 --> 19:29.120
So I'll leave a link to that video down in the description. It's well worth a watch

19:29.120 --> 19:31.560
But this is one snapshot of the video

19:32.160 --> 19:38.000
And here's what happens. So when we pass a string, which is really a an array of characters in Java

19:38.600 --> 19:43.280
It'll take each character and start going through the FSM

19:43.280 --> 19:46.680
I'm just gonna call it FSM because it's finite state machine is a mouthful

19:47.800 --> 19:54.240
So it's gonna start off with with state zero and if it's an at sign it'll go to one

19:54.240 --> 19:56.240
Oh, by the way, this

19:56.680 --> 20:00.600
pattern it's looking for is simply for an at sign or a hashtag. So this has nothing to do with

20:01.120 --> 20:03.640
the reg X given here because this is for

20:04.320 --> 20:08.360
Checking if it's a Roman numeral, but this is a different example. Just so you don't get confused

20:08.960 --> 20:13.560
So all it's looking for is if the string contains an at sign or a hashtag

20:14.000 --> 20:19.440
So it starts as I said with state zero if it contains an at sign goes to state one

20:20.040 --> 20:25.880
If it's a number between or an integer to use proper terminology between zero and nine

20:25.880 --> 20:29.320
It'll go to state two if it's a hashtag. It'll go to state three

20:29.920 --> 20:35.960
And it sort of loops it will remain in that state because so if it's an at sign it'll go back to state one

20:36.240 --> 20:37.400
so

20:37.400 --> 20:39.400
For all the intents and purposes

20:39.720 --> 20:46.480
This state represents at signs this state represents the hashtags and this represents integers

20:47.120 --> 20:51.440
That's really what a FSM is but for our problem

20:51.440 --> 20:55.280
We don't want this computation happening every single time this method is involved

20:55.280 --> 21:02.040
Which is why we create one instance and we store that object with its state in a constant

21:02.160 --> 21:04.160
This is our constant I declared in Java

21:05.120 --> 21:12.200
So let's look at the time differences. Now firstly, I'll invoke the slow method if I run this program

21:14.160 --> 21:19.060
You'll see that's how long it takes. Let me zoom in a bit there. So this is

21:19.560 --> 21:22.440
Millions seconds, isn't it? This is it's always in nanoseconds

21:23.440 --> 21:26.720
Man, I'm not even sure. I think this is a nanoseconds. I

21:27.280 --> 21:29.280
Looked it up, but in fact both my

21:29.800 --> 21:36.920
Options were wrong. It's actually microseconds. There you go. That's my ignorance. So it takes around 115 microseconds

21:37.520 --> 21:41.960
For this function to run and now if we do change it to fast

21:43.760 --> 21:50.560
Now keep in mind what the fastest what this method does is that it doesn't invoke the matches method in

21:51.560 --> 21:53.680
Well, sorry, it doesn't work the matches method

21:53.680 --> 21:58.840
But it isn't compile a new pattern every single time because we just use the cached Roman

21:59.840 --> 22:03.340
Instance here. So if we run that it'll be much faster

22:04.120 --> 22:05.760
There you go

22:05.760 --> 22:07.360
half the time

22:07.360 --> 22:10.760
60 milliseconds 12 milliseconds for the next computation and

22:11.320 --> 22:18.560
Joshua block states in his machine. It was for a eight character input string. It was six six point five times faster

22:18.920 --> 22:27.280
Which is why he says the improved version is of is numeral provides significant performance gains if invoked frequently

22:27.640 --> 22:31.560
Then it continues and that's a really good point. He sort of touched on this in

22:32.600 --> 22:35.800
the in item number one where you could in fact give

22:37.160 --> 22:41.760
Static methods or even static values a name. It's more clearer

22:41.840 --> 22:46.400
It's more. It's it's quite clear that this pattern is a Roman pattern Roman numeral pattern

22:46.880 --> 22:55.120
So not only is the performance improved but arguably so is clarity the clarity because we know what the pattern we're using here

22:56.600 --> 23:00.680
Making a static final field for the otherwise invisible pattern instance

23:00.680 --> 23:04.040
A love allows us to give it a name. It's more explicit and clear

23:04.160 --> 23:07.520
Which is far more readable than the regular expression itself

23:07.520 --> 23:15.000
and then he makes a bit of an ancillary point just to clarify about lazy loading because now as I said when we

23:15.960 --> 23:22.080
Do it this way when we declare it in a private static final field and cash that object

23:22.320 --> 23:26.560
This belongs to this class. So it can be reused all the

23:27.200 --> 23:33.040
Objects of this class all the instances of this class will reuse this but what if we never use this object?

23:33.080 --> 23:35.080
It's just gonna be created

23:35.080 --> 23:41.800
For no reason at all and it's gonna exist in the heap space. Sorry. Yeah in the dynamic meta space in the heap and

23:42.600 --> 23:47.640
Here, you know, he says, oh, look, we could probably lazy load. However, perhaps it's not required

23:47.640 --> 23:50.400
We don't have to over complicate things for

23:51.320 --> 23:56.240
Optimization as don't canoe and I think it was apocryphally attributed to him

23:57.280 --> 23:59.800
premature optimization is the root of all evil and

24:00.600 --> 24:05.200
He continues not only is the performance improved. Oh, sorry. I already read that part

24:05.440 --> 24:12.080
If the class containing the improved version of the is numeral method is initialized, but the method is never invoked

24:12.360 --> 24:17.480
So what if this is numeral fast method is never used and this just exists there?

24:18.760 --> 24:21.600
The field Roman will be initialized needlessly

24:21.720 --> 24:25.120
It would be possible to eliminate the initial initialization

24:26.000 --> 24:32.360
By lazily initializing the field the first time the is numeral method is invoked

24:32.360 --> 24:37.480
But this is not recommended as it's often the case with lazy initial initialization

24:37.680 --> 24:43.640
What can I read the word those two words together lazy initialization? It would

24:44.880 --> 24:50.540
Complicate the implementation with no measurable performance improvement. So it's not required. It's fine

24:51.040 --> 24:54.640
To create an object even though it may potentially not be used

24:55.880 --> 24:57.880
especially with how fast

24:58.320 --> 25:01.520
Jvms of these the JVM and processes out these days

25:01.520 --> 25:05.560
And with that we move to a bit of an interesting problem here

25:05.880 --> 25:13.160
What about less obvious situations for object reusability? I'd say this one seemed quite straightforward

25:13.560 --> 25:16.200
Well, I don't know if it was at least for me

25:16.200 --> 25:21.600
But when I saw the code trust your block has written it came together. I was like, oh that makes complete sense

25:22.000 --> 25:23.160
but I

25:23.160 --> 25:30.960
from being honest, I probably would have done it this way and made the mistake of invoking this pattern instance every single time so

25:31.640 --> 25:37.120
It's probably not so obvious for inexperienced programmers like myself, but nevertheless

25:37.880 --> 25:40.520
Keeping aside aside the self-flagellation

25:41.560 --> 25:47.600
What about when it's less obvious? So he says when an object is immutable like the Roman object here

25:48.120 --> 25:51.160
It is obvious that it can be reused safely

25:51.840 --> 25:56.600
But there are other situations where it is far less obvious even kind of intuitive

25:57.080 --> 26:00.960
Now the example that Joshua block is used for that is adapters

26:01.720 --> 26:04.240
adapters simply are an object

26:04.720 --> 26:10.720
which backs other objects by allowing two incompatible objects to

26:11.120 --> 26:12.360
communicate together

26:12.360 --> 26:15.880
it's used a lot in the adapter pattern and even though

26:16.640 --> 26:18.920
Joshua block doesn't talk about the adapter pattern here

26:18.920 --> 26:23.240
It's I think it's worth going through a few definitions definitions as to what the adapter pattern does

26:23.440 --> 26:25.200
But of course, I'll leave

26:25.200 --> 26:29.200
Some good articles down there in the description. There's a good one by Vile Dung

26:29.600 --> 26:36.040
Where he goes through a few examples as to how the adapter pattern is used and how adapters these objects are used

26:37.040 --> 26:39.920
So the first definition is by refactoring guru

26:40.760 --> 26:46.240
Adapter is a structural design pattern which allows incompatible objects to collaborate

26:46.760 --> 26:49.960
The adapter acts as a wrapper between two objects

26:49.960 --> 26:56.520
It catches calls for one object and transforms them to format an interface recognizable

26:57.280 --> 27:00.640
Recognizable by the second object on the adapter pattern. I would recommend

27:03.640 --> 27:06.120
If you want to get a good understanding of the adapter pattern

27:07.160 --> 27:08.520
This book

27:08.520 --> 27:14.040
Headfirst design patterns goes quite deeply into the adapter pattern with some really good examples

27:14.040 --> 27:17.480
So I'll leave a link to this book down below in the description too

27:17.480 --> 27:21.000
And I'm hoping to cover some parts of this book at least after I'm done with this

27:21.000 --> 27:22.440
It's probably gonna be next year

27:22.440 --> 27:29.280
So the next definition that I found for the adapter pattern is an adapter pattern acts as a connector between two

27:30.120 --> 27:40.160
Incompatible interfaces that otherwise cannot be connected directly could be due to type mismatch whatnot an adapter wraps an existing class with a new interface

27:40.720 --> 27:44.280
So that it becomes compatible with the clients interface

27:44.560 --> 27:49.880
The main motive behind using this pattern is to convert an existing interface

27:50.600 --> 27:53.040
Into another interface that the client expects

27:53.880 --> 27:59.800
It's usually implemented once the application is assigned so one example as to how an adapter is used and

28:00.280 --> 28:05.920
Even though I read some definitions of the adapter pattern. I wouldn't say that the adapter pattern has been used here

28:06.880 --> 28:14.680
Exactly or precisely, but it's worth looking to how the adapter pattern is used and that is in the map interface

28:15.400 --> 28:17.400
so we so of course the map interface

28:17.880 --> 28:19.880
contains a method called a

28:20.320 --> 28:22.320
key key set and

28:22.760 --> 28:27.200
Our hash map, which is a concrete class will implement it which you see here

28:28.120 --> 28:29.560
now what I

28:29.560 --> 28:32.760
Did do so as a client what I would do is I would create a hash map

28:32.760 --> 28:39.200
I would add key value pairs and what the key set does is it returns a bunch of objects all the keys

28:39.200 --> 28:44.240
Which are functionally identical so we can cache that value the key set value

28:44.240 --> 28:50.360
We get can be cached and that's exactly what we see here in the implementation of key set

28:50.520 --> 28:55.520
so this method which is what returns the key set first checks if

28:55.880 --> 29:00.640
the key set is present if this key set value is now which

29:02.760 --> 29:05.640
Wasn't going there. Oh, that's interesting. I

29:08.520 --> 29:10.520
Was clicking the the wrong

29:11.520 --> 29:17.640
Variable look sorry, it's been a long day if this key set variable which is in the abstract map if this isn't available

29:17.640 --> 29:21.760
So if isn't cached then a new instance will be sent if not

29:21.760 --> 29:25.280
There's a requirement that same instance same object can be reused

29:25.480 --> 29:29.600
So here's what where we see that an object is being reused a good

29:30.400 --> 29:32.400
implementation in the JDK

29:32.760 --> 29:35.960
So again to print more formally as to how this example makes sense

29:36.680 --> 29:43.800
Theoretically although the return set instance is typically mutable. So that's the set that's returned here

29:45.880 --> 29:48.680
All of the return objects are functionally identical

29:49.560 --> 29:53.480
When one of the return objects changes so do all the others

29:54.080 --> 29:57.080
Because they're all backed by the same map instance

29:57.720 --> 30:02.440
While it is largely harmless to create multiple instances of the key set view object

30:02.840 --> 30:06.360
It is unnecessary and has no benefits. So the similar point is

30:07.080 --> 30:13.080
Biggest what this method returns is a set view. So of type set of the key set

30:13.880 --> 30:17.640
While this key set the the values in the key set can change

30:18.200 --> 30:19.560
It's

30:19.560 --> 30:26.040
Functionally still the same so the adapter the the outer layer which it returns is still the same and that's a set

30:26.520 --> 30:29.320
So that's why it could be cached another example of

30:29.640 --> 30:34.040
Reusing objects where it's less obvious is of course auto boxing now

30:34.440 --> 30:40.280
What that does is of course it allows programmers to mix primitive and non primitive type

30:40.280 --> 30:46.280
So primitive would be int a non primitive type or a a box type would be

30:47.160 --> 30:53.240
Integer while yes auto boxing does give the object more flexibility and give it more functionality

30:54.120 --> 30:58.360
It's not always a good idea to auto box because what auto box does is create

30:59.160 --> 31:01.400
A new object every time it's involved

31:03.560 --> 31:08.280
So the example we've used or the example that joshua block has given is

31:09.320 --> 31:13.320
In this sum class where in fact, I changed it to the proper way

31:13.560 --> 31:18.360
So this is the bad bit to do it where we have used an auto box type long

31:18.840 --> 31:23.960
And in fact the idea look at that it's even warning us to not to use this but rather to use a primitive type

31:24.520 --> 31:28.440
Now with this if we do run this loop where it's running

31:29.240 --> 31:31.240
2 to the power 31 times

31:32.680 --> 31:38.200
An unnecessary number of objects of long instances are created in this loop. So if we do run it

31:43.400 --> 31:45.000
It takes so long

31:45.000 --> 31:48.840
Look at how long it takes it takes almost 3000 milliseconds and it keeps going

31:50.040 --> 31:51.880
I'll just zoom into that

31:51.880 --> 31:57.000
But simply by just not using an auto box type and rather using a primitive type

31:57.480 --> 32:01.000
We save a lot of time because there's no object creation involved here

32:01.720 --> 32:03.640
If you run it again

32:03.640 --> 32:05.640
It's much slower

32:05.640 --> 32:10.520
That's the advantage of using primitive types over auto box types and

32:11.480 --> 32:16.200
Again, one has to be careful and the good thing is the the way you saw intelligent is beautiful

32:16.200 --> 32:21.880
You got to love it the ide will normally warn you but you know in good programming etiquette

32:22.200 --> 32:27.000
One should be aware of that and that's why he states the lesson is clear prefer primitives

32:27.080 --> 32:30.120
So this here is the proper way to do it using a primitive type

32:31.080 --> 32:37.720
To box primitives and that is a wrong way using a box primitive which the ide warns us against

32:39.240 --> 32:41.240
Oops, uh, come on said

32:42.200 --> 32:48.360
And watch out for unintentional auto boxing and then finally towards the end of the item

32:48.600 --> 32:55.160
He does give some caveats and something I always appreciate about this book every single item has pros and cons

32:55.480 --> 33:01.640
Uh, it it's a well written book because it looks into both sides of the equation. Let's say

33:02.200 --> 33:04.200
And discusses the trade-offs

33:04.440 --> 33:09.400
So the the first caveat is that it's not the case that object creation should be

33:10.360 --> 33:16.120
Avoided at all costs, especially with how fast the processors are and how optimized the jvms

33:16.840 --> 33:19.080
It's not that we should try our best to

33:19.800 --> 33:23.960
Not create objects again do the whole premature optimization thing

33:25.080 --> 33:28.680
That's why he states this item should not be misconstrued

33:29.160 --> 33:37.000
To imply that object creation is expensive and should be avoided on the contrary the creation and reclamation of small objects

33:37.080 --> 33:43.960
Whose constructors do little explicit work is cheap, especially on modern jvm implementations

33:44.760 --> 33:47.560
Creating additional objects to enhance the clarity

33:48.040 --> 33:51.320
Simplicity or power of a program is generally a good thing

33:51.800 --> 33:55.080
And then we go to a classic example the classic example of an object

33:55.960 --> 34:00.680
That does justify an object pool is a database connection, which is why

34:01.400 --> 34:02.600
conversely

34:02.600 --> 34:10.760
Maintaining object pool in this case would be a better idea unless the object is significantly heavy weight a like a database connection

34:11.320 --> 34:15.640
So it depends on what the object we create is as to whether

34:16.280 --> 34:21.720
It makes sense to optimize it and to reuse it or just simply create an object if it's lightweight for instance

34:22.440 --> 34:25.640
The cost of establishing the connection is sufficiently high

34:26.200 --> 34:28.600
That it makes sense to reuse these objects

34:28.680 --> 34:33.800
This is something we see a lot with frameworks for instance a spring with the dependency injection

34:34.360 --> 34:36.760
Something like a database connection could be injected

34:37.560 --> 34:42.600
Into different components in the object pool or the object graph in this case

34:43.800 --> 34:45.800
Generally speaking, however

34:45.880 --> 34:49.240
Maintaining your own object pools clutters your code

34:49.800 --> 34:54.040
increases memory footprint and harms performance. So what he means by

34:54.600 --> 34:59.000
Maintaining your own object pools really is what we saw here

34:59.640 --> 35:01.160
in the

35:01.160 --> 35:03.080
numeral roman numeral example

35:03.080 --> 35:09.080
This is kind of like what an object pool is we we define all these objects in our class and let's say we have 20 of these

35:09.400 --> 35:11.880
That can cloud your code and make things a bit complicated and

35:12.520 --> 35:15.320
Make the code unreadable or more difficult to read

35:17.560 --> 35:19.560
So since

35:19.800 --> 35:28.760
Modern jvm implementations have highly optimized garbage collectors that easily outperform such object pools on lightweight objects

35:29.240 --> 35:31.880
It's not necessarily the case that one should always

35:32.760 --> 35:35.960
avoid object creation and then we get to an interesting

35:36.840 --> 35:38.360
sort of

35:38.360 --> 35:42.520
Conclusive point in this item and that's the concept idea of defensive copying

35:44.680 --> 35:46.680
What defensive copying

35:47.000 --> 35:51.720
The simplest way to think of defensive defensive copying is that it's used to maintain

35:52.360 --> 35:58.600
Immutability of an object and before we take a look at the example which I have here for defensive copying. It's when you get it

35:58.680 --> 36:08.440
It's a rather simple concept, but it's used a lot across frameworks. For instance, um, sorry defensive copying. I'm not sure I confused

36:09.720 --> 36:11.720
Reflections with defensive copying

36:11.960 --> 36:16.120
But regardless it's a known concept in java programming

36:17.000 --> 36:19.000
So what defensive copying is is

36:19.880 --> 36:22.280
Where to maintain immutability

36:22.920 --> 36:29.640
Instead of passing back a reference to the object at hand a reference to a new object is passed with the same values

36:29.960 --> 36:34.440
Making it a copy for all intense for all intents and purposes. What that means is

36:35.000 --> 36:39.080
Uh, you know what without me trying to theorize more. Let's look at the example here

36:39.720 --> 36:42.200
So we have a class called full calendar here, which

36:43.000 --> 36:46.520
Despite ostensibly looking immutable is in fact mutable

36:47.160 --> 36:55.960
And this example is courtesy of courtesy of abc study guide. The link to this blog post article is down below in the description

36:56.440 --> 37:02.120
So as a client when we use full calendar, what we're doing is we are passing this original date

37:02.840 --> 37:09.400
Uh object of date type into the constructor and the constructor assigns that to this private final

37:10.120 --> 37:13.000
Uh date object, which we think is immutable

37:13.880 --> 37:19.320
But what happens is because we are passing this when the class is instantiated. So in line number 30

37:20.680 --> 37:25.240
If for instance, let's say this original date value changes

37:26.360 --> 37:32.600
The value of standard date also changes because they are both pointing to the same location in memory

37:33.000 --> 37:36.280
Therefore, even though we've declared this as private final

37:37.080 --> 37:43.400
And we think it's immutable. It's in fact not and here's where we can easily create a defensive copy

37:43.960 --> 37:45.960
So the right way to do this would be in fact

37:47.400 --> 37:52.200
When the class is invoked uh, or when when the class is instantiated and the construct is invoked

37:52.760 --> 37:57.400
We create a new date object. We we get we get the value of it

37:57.400 --> 38:01.320
So we create a copy of that with the the the date we pass here

38:02.040 --> 38:07.480
And then using that value we create in fact a new object and then pass said that in standard date

38:08.040 --> 38:14.360
That defensive copy ensures immutability of this class and the same thing when we are returning it when you're returning it

38:14.600 --> 38:16.600
We want to return a new instance

38:16.920 --> 38:18.920
and not

38:19.160 --> 38:22.280
The uh, the one that was here because that too could change

38:22.920 --> 38:29.240
And that's why we are we are passing. Um, we're not passing in this case. We're using the new keyword and creating a new

38:29.800 --> 38:36.040
Uh date instance. So yeah, that's sort of my still I'd say high level superficial understanding of defensive copying

38:36.200 --> 38:40.440
But whenever I do think of it, I always connect it to maintaining

38:41.080 --> 38:43.080
uh immutability

38:43.080 --> 38:47.480
But of course, I'll leave the code this code and also the the article that I got this code from

38:48.280 --> 38:50.680
In the description so that you could look a bit more deeply

38:52.280 --> 38:56.760
And to conclude here's what Joshua Bloch says about defensive copying

38:57.000 --> 39:04.360
The counterpoint to this item is item 50, which is on defensive copying. So this item is is about avoid

39:05.000 --> 39:12.600
Creating unnecessary object and here you would think we're creating an unnecessary object where every single time a new object is created

39:13.960 --> 39:15.960
So that's why he says it's a counterpoint

39:17.320 --> 39:22.520
The person item says don't create a new object when you should reuse an existing one

39:23.320 --> 39:29.000
While item 50 says don't reuse an existing object when you should create a new one

39:29.560 --> 39:30.280
like

39:30.280 --> 39:37.480
In the example of defensive copying note that the penalty for reusing an object when defensive copying is called for is far greater

39:38.120 --> 39:41.640
Than the penalty for needlessly creating a duplicate object

39:43.080 --> 39:50.600
Failing to make defensive copies where required can lead to insidious bugs and security holds creating objects

39:50.680 --> 39:52.040
unnecessarily

39:52.040 --> 39:57.240
Merely affects style and performance and of course we need to always at least in my opinion prioritize

39:57.800 --> 40:00.760
security over efficiency and performance, which is why

40:01.240 --> 40:04.840
It's a good sort of way to end this item with the caveat that

40:05.400 --> 40:09.640
This certainly doesn't mean that we should avoid creating objects at all costs

40:09.880 --> 40:14.200
There are costs a cost could be security and that could be detrimental

40:15.320 --> 40:18.520
And that's it. That is item number six on

40:19.480 --> 40:24.200
The avoiding of creating unnecessary objects. I hope you found that insightful

40:24.920 --> 40:26.920
Please do tell me how I can improve

40:27.000 --> 40:29.560
In the way I communicate and articulate these concepts

40:29.880 --> 40:32.280
But also as to how I demo and show the code

40:33.000 --> 40:37.560
I would like to maybe even a bit more be a bit more slow and leave more comments

40:37.720 --> 40:39.720
But perhaps the best thing to do is

40:40.360 --> 40:44.600
Go on to take a look at the code yourself. This video. Think of it as only a prelude

40:44.680 --> 40:50.520
I think that thanks a lot for watching. I really appreciate it. I'll receive the few comments here and there

40:51.560 --> 40:55.000
On on these videos and it means a lot to me. It means a lot to me

40:55.960 --> 41:02.280
And it's always nice to see that there are people actual human beings watching these videos and it's just not me

41:04.440 --> 41:06.440
Rambling like a raconteur

41:07.400 --> 41:12.440
Okay, enough rambling on the on in okay enough rambling on rambling ridiculous

41:12.440 --> 41:14.920
Thanks for watching. Cheers. See you in the next one

