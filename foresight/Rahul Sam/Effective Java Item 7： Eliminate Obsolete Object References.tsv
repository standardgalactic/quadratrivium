start	end	text
0	6160	Hey everyone, welcome to yet another episode of this video series on Joshua Bloch's effective Java
6320	10440	where I try and expound and make sense of the items that he has
11160	13400	Animirated in this book and without further ado
13400	18520	Let's get started with the introduction because I sort of anticipate that this item in particular
18520	24960	It's gonna be a lone one because there are a lot of I'd say ancillary points that we need to discuss to
25240	29120	make sense of the crux of this item and the argument that
29800	31800	Joshua Bloch is putting forward
32200	38140	So as per usual, I'm gonna go through the same introduction that I go through in every single
38760	40480	Video in the series
40480	46160	So if you've been following along, please do skip this bit to save your time the proviso goes like this
46760	50720	Which I'm kind of sick of repeating but I feel like I kind of have to repeat it
51160	55280	For let's say due diligence. So just to be ethical about this whole thing
56040	60800	This is not a tutorial. I certainly am not a teacher. No, I'm an expert
61200	65560	So, you know, take what I say with the grain of salt
65880	71640	Don't think of this as any other tutorial on YouTube where what I say is in some sense
72000	75600	Gospel's truth. I don't think every single tutorial on YouTube is like that
75600	80960	But there are some tutorials where certainly, you know, they could quality they come from an expert in the field
80960	88720	And you can trust what they're saying. Don't trust what I say. I'm pretty sure I'm gonna push a lot of things in this item and
89360	96700	in some sense, hopefully try my best to do it as accurately as possible not spilling the bullshit, but
98240	100440	Getting to the points in the item. There certainly are gonna be
101000	105400	Unintentional mistakes that I make. I'd like to think of this as the blind leading the blind
105400	108200	I am as blind as you are perhaps even more
108680	111600	This is merely or not merely. This is a
112400	115960	Exploratory disposition. I'm trying to make sense of this collectively
116800	122520	You know using different forums like Stack Overflow whenever I come across something that I don't understand
122520	126240	I'd post a question on Stack Overflow and I'd really appreciate it if
126960	131280	You know, if I do make any mistakes, which I think I inevitably will
131680	133800	Please point them out in the comment section down below
134200	140680	Not just for my sake, but even for other people that are watching these videos. I really don't want to mislead people in any way
141320	143320	and given that this is a
144560	150320	Programming video series. It only makes sense to have all the code that I use on get up publicly available
150320	155760	I'll leave a link down below not just to my get up account, but also just your blocks sort of official
157080	161120	Public repository that is published and put put out all the code used in the book
161600	166640	And saying all that let's get started on item number seven
167240	171560	Which states eliminate obsolete object references?
171560	176040	And this again is from chapter two creating and destroying objects
176200	182680	So something I've been trying to do in these videos is before we even get to the content of the item to try and
183080	185080	expand on and try to understand
185800	190400	Basically what the words used in the title itself is itself are
191080	192400	so
192400	198440	object references what in the world are object references this diagram or this
198840	202600	image pretty much puts it quite simply and
203400	210800	Object reference is merely a pointer or not merely. It's probably good to conceptualize it as a pointer
210800	216880	So we have objects in the heap memory. So the memory is subdivided into
217800	222320	Different segments by the JVM. There's a heap. There's a stack
223480	224680	and
224680	230240	Generally leaving aside the stack of the heap what a object references is a a
230840	237680	Memory address the pointer points to a memory address of a particular object in the heap and adding on to that in this image
237680	239680	If we take something like an object array, let's say
240200	245080	An array itself is a reference to a another object
245200	247200	what I mean by that is an
247440	249640	array can exist in the heap and
250440	256480	There's a pointer or a memory address that points to that array, but the items in the array itself are
257240	265320	Pointing to other objects within the heap. So in some sense, you can I guess think of it this way the way they've shown in this diagram where
266120	271680	The array contains references itself and it could also contain it out. So if you're not out an array
272280	277400	Which we're gonna see some nulling out in this item, then it's not gonna point to anything
277680	282720	So in Java what happens when we use the new keyword is we reserve a location in memory
284120	289840	When we instantiate a class the constructor of that class and all classes have a constructor
291520	296160	Creates a reference to an object and the reference I said it's like a pointer
296160	301840	But another way of thinking about it is that it's information regarding the location of the object in memory
301880	306760	So what we see here is an example of that where they're creating this
307440	309600	object array a primitive array and
310160	311760	where
311760	312960	instantiating it
312960	317760	In this case with a primitive type. So just repeating the point items seven states again
318160	320720	eliminate obsolete object references
321360	322800	so
322800	326040	Unlike a language like let's say C++
326960	336200	Java this automatic garbage collection. What is garbage collection? It's simply put memory management when we do allocate resources to a certain object
336560	341520	We make sure that once that object is no longer in use we clear it out
341520	348720	We we let that memory go to free out resources so that that resource can be something else and there are different
349280	355760	Algorithms used in garbage collection. In fact, I'll leave some links down below on some videos by
356640	359520	Gaurav Sen, I believe I think it's his son name, but I you know
359520	365480	He does the system design videos on YouTube really good superlative content and he does do a bit of
366720	368720	Explaining of how these algorithms work
369760	371960	specifically Apple Pro JVM
372800	373960	so
373960	380360	Of course because Java this automatic garbage collection as I said unlike a language like C++
380680	384760	We could make the wrong assumption when I mean we I mean a programmer could make the wrong assumption
385320	392320	That we don't have to think about memory management at all. And that's why in the beginning of this item
392880	394720	Joshua Block states
394720	400720	When it comes to garbage collection, it seems almost like magic when you first experience it and
401320	406680	Therefore it can easily lead to the impression that you don't have to think about memory management
406680	411880	But this isn't quite true. I had to take off my cardigan because it was getting really hot in this room
412280	414280	Summer's coming in Melbourne. Yay
414520	419000	So he keeps going consider the following simple stack implementation
419560	422280	I've got the stack implementation right here
423320	426680	However, before we get to the code and do a deep dive
426680	431640	I cut out again. We want to backtrack a bit and discuss some of the terms. So
432360	434360	We discussed what
435000	438240	Object references are and then I want to discuss
438720	444940	What's a obsolete reference an obsolete reference is a reference that will not be
445680	447680	De-referenced again. It's
447680	450520	unintentionally retaining an object now this term here
451520	458000	De-referencing or dereferenced again, this can be quite confusing because dereference does not mean that you
458400	461080	Get rid of the reference not at all. What?
462160	464160	dereferencing in fact means is
464360	466360	when we do refer to an object
467360	472480	In our code somewhere down the line once we do create the reference we may refer to it again
472480	477720	We may get the value that the reference is pointing to that process is called
478440	483800	De-referencing and if we don't de-reference an object, there's no use of keeping an object in memory
483800	486920	So we are unintentionally just leaving an object there
487560	489560	allocating resources making
490440	496760	Application inefficient that that shouldn't be done. So the solution is quite simple. In fact, it's simply to now
497120	504480	references once they become obsolete and we sometimes have to do this explicitly on our code despite
505480	508520	Java doing memory management or garbage collection
508720	516800	So to have a bit of a more formal and clear definition by my favorite Java programming website by all done
517240	522480	De-referencing means the action of accessing an object's features through a reference
522480	528840	And one way to prevent obsolete object references is by narrow scoping and what's narrow scoping?
528920	537200	That's something what you would see in a for loop in a for loop. We have the int you declared int i for instance
538720	546160	That variable is within the scope of that for loop. So narrow scoping. That's an example another example would be
546640	550600	trying not to declare global variables in a class rather
551520	557480	declare variables within a function within a method and keep it localized to that specific method and
557720	559720	That helps with eliminating
560560	568600	obsolete object references because we sort of know what the scope of a variable is in our code base and then in the item
568600	573040	He keeps going and this is the code base for the stack class
573040	579560	And then he asks can you spot the memory leak saying that before we get to the item and try and visualize
579880	581280	What the memory leak is?
581360	584880	Let's take a look at the code base and the code base of this
585320	592160	Stack implementation a really simple stack implementation that just your block has used here as an example to
592520	596880	Illustrate his point. So I'm pretty much going to go through this code line by line despite it being a bit long
597520	600680	Because I think that's the best way to understand this. We have a
601360	606920	Simple class called stack. We have a object array of elements and another
607840	611360	Private of the object array is also private but also another private
613200	619240	Variable called size of primitive type integer of int. Sorry and then this
620160	622360	constant here is what
623440	625440	initially defines the
625720	627720	Initial stack capacity
628400	633680	So when the stack class is instantiated, of course the constructors called
634200	636200	And in the client over here
636920	638920	I am instantiating the class
639280	641280	line number 57
641480	642680	so
642680	646200	When the constructor is called a new
647560	649840	Object array is initialized. So this
650840	652840	array we defined here
653080	654680	elements
654680	659640	that this this new object is passed to that variable and when the
660000	666800	New object array is initialized. It's default capacity. Yes. I've made a mistake here. It's not 26 at 16
667360	672640	And that's assigned to the variable elements. So this variable in line number 10 will hold a
672640	676000	I'm pointing to the code as if you can see where I'm pointing at. That's so funny
676080	682160	Anyway, this object array will hold a reference or elements will hold a reference to this new object
682400	686240	That was created and that's in the heap and then we have a method called push
686640	692200	and what that does is as you'd expect from a stack you can push new elements on new objects onto the
692560	697840	Stack or in this case the elements array, but but in that method we have another
698640	701680	method that we call call ensure capacity
702520	704520	ensure capacity just ensures that
705160	712440	There's space for at least one more element roughly and if not, it'll just double the capacity each time the
712520	715240	Areas to grow because we want the stack to be dynamic
715240	719000	you can see here it's creating a copy of elements and passing it to elements and
719320	723520	The more we keep adding on to the stack the more the area grows so doubles in size
723520	730520	Let's say now we get to the point this pop method is what's pertinent to our item and where we see
731480	734000	Memory leak take place. So we have this
735440	738120	Object method. Sorry, we have this pop method
738760	745800	And we don't here in this method garbage collection doesn't take place and that's why we need to be aware of that
746320	752480	So firstly if the size is equal to zero, which is going to throw an empty stack exception
752480	756120	And we can't add something to an empty stack and here we see
757240	759680	that when we pop the
760600	762200	object of the
762200	765800	Array or when we return the object that's in the array
766400	773560	Where we reduce the size with this counter. So this was the variable we declared here in line number
774320	780360	11 and when we reduce that. Oh, sorry. I didn't I didn't say that in fact in the push
781600	787640	Method whenever we push a new item onto the array. We also increase the count on that variable
787640	791720	And when we pop it we reduce it kind of makes sense. Well, what happens here though is
792880	798480	Whenever we pop an object from the stack or when we take an object out from this array
799480	801480	An object is still
801960	807360	unintentionally retained here despite the client of this class having no use of those objects and
808280	816240	That's where the memory leak takes place and the proper way to do this and again this bit of code here line number 20 to 33
816240	822640	I will illustrate that in this diagram more visually. It'll make a lot more sense. Whoops. That was a mistake
823360	825000	Getting back to this
825000	829640	But this is not the right way to do it because what's happening here is a memory leak
830640	832880	The proper way to do it would be like this
835520	837840	I'm gonna comment out the wrong way
840200	842640	It would still be where we are checking if the
843360	848040	Stack is empty the stack can't be empty and then we are in fact
849000	851400	Assigning this value onto a new
852200	858080	Variable we're gonna create called result. So whatever the elements array returns after we reduce the size
858320	861480	We're gonna assign that value to result and then
862440	868280	simply we null out that location on the array and that's where the elimination of
868560	872240	The obsolete reference takes place and we return the result afterwards
872240	877440	So we assign it to result and return the result will be ensure that that
878280	881000	Element on the in the array that index
881640	888560	That we return that it's not out because when it's not out what happens is something like what we see here
888880	894960	It's clear that it's not obsolete that it's not pointing at something and taking up memory resources
894960	898160	And really if you run this code there really isn't a use in running the code
898160	901520	But this is kind of what you'd see. I can just print out the
902160	904160	Array or the stack in this case
905000	910160	This you can ignore this empty stack exception. The reason for that is because we are pretty much
910960	912480	pushing
912480	917920	Everything into the stack and then popping everything off the stack and then you would at one point as we go through it
918440	920440	expect this
921360	925440	Exception to be thrown here, which is wait, I just missed it
928040	933640	Right here because what happens is we keep popping the stack at one point the stack gets empty
933640	936720	So this is kind of expected this error here
939720	945600	So now before I read out what Joshua book has explained here, let's take a look at this diagram and visualize it
945800	950840	So here we have that elements array that I spoke about before so that's the array
951400	958440	Right here, but the object array that we define. That's what I've illustrated or represented here
958440	960440	And we let's say the objects
960680	963400	Of our integers and we're adding
965240	969400	One two three four five six, I don't know why I put a zero in front
969400	971720	Let's just think of it as one two three four five six
972360	976280	And then this is being added by the push method here
979080	984840	But then for some reason we also pop some of it and we pop three items from the
985560	991720	Array now what happens here is if you don't null out the references the way we've done here
992600	998200	These things are still gonna exist in the array. However for the purpose of the stack class
999000	1007000	The client will never use these elements these these objects. They'll just exist in memory making them obsolete and
1007560	1009560	more importantly
1009560	1011560	Making it a memory leak because it's taking up
1012360	1016360	Resources that could be used for something else and that's the problem here
1016520	1017560	If you don't know that out
1017560	1024360	So the right way to do it is to treat this array in this way where the way we've done it in the proper pop method
1025160	1027160	every time we return
1027720	1029720	Whatever is in the index of this array
1029960	1037400	We also ensure that it's not out in that way that reference is eliminated. Sorry the obviously reference is eliminated
1037800	1041880	I hope that makes sense. I'm repeating the same point, but you know repetition is important to
1042280	1048760	Make sense of this and on the note of repeating. I'm going to read out what Joshua Bloch has said about this particular class in the book
1050200	1052200	He goes like this
1052760	1055240	There's nothing obviously wrong with this program
1056520	1061000	You could test it exhaustively and it would pass every test with flying colors
1061640	1063640	But there's a problem lurking. Ooh
1063800	1067960	Indeed indeed loosely speaking the program has a memory leak
1068440	1072200	Which can silently manifest as reduced performance due to the
1073000	1076920	increased garbage collectivity or increased memory footprint
1077800	1080680	Footprint what kind of process would um, yeah, so
1081320	1084520	That's that the increased memory footprint is what I explained here
1085160	1091400	That these three, uh, let's say for this example these three indexes create taking up space in the heap
1091640	1094920	He keeps going if a stack grows and then shrinks
1095480	1099080	The objects that were popped off the stack will not be garbage collected
1099240	1103800	Even if the program using the stack has no more references to them
1104280	1107800	So that is what we saw in the other method the
1109000	1111000	When it's wrong
1111400	1113640	The way it shouldn't be done. There's nothing out here
1114360	1118360	This is because the stack maintains obsolete references to these objects
1118840	1124040	An obsolete reference is simply a reference that will never be dereferenced again
1124120	1126600	So never be used by the program again
1127800	1134280	In this case any references outside of the active potion of the element array are obsolete
1134600	1139640	It's important to understand what he means by the active potion the active potion really is the
1140520	1145800	The potion of the array that the client would care about or use the client of this class
1146200	1150520	So in this example, the active portion really is index zero one and two
1150920	1157400	Not this but here, which is why they should be not out the active portion consists of the elements whose index is less than size
1157480	1159800	Yes, so this size here
1160600	1165080	Is what holds the size of the stack and then he sort of concludes that point by stating
1165560	1170920	memory leaks in garbage collected languages like java more properly known as
1171720	1174520	unintentional object retentions iron citys
1175240	1178440	If an object reference is unintentionally retained
1178680	1182200	Not only is that object excluded from garbage collection
1182680	1184680	But so too are any objects
1185160	1191880	Reference by that object and so on it's an interesting point there because I've had a conversation with a c++
1192120	1194120	engineer or developer
1194680	1199640	In my company and he kind of made the point, you know, that's kind of the trade-off we make in programming
1200120	1202120	the more we sort of
1202200	1208840	Give control to the virtual machine in this case the jvm the less we know what's going on
1209880	1210920	kind of
1210920	1212920	Um behind the scenes under the hood
1213320	1221000	Uh, the the more abstractions on abstractions we build the less of an understanding we have as to what's going on in our program
1221640	1225320	Uh, which is why for instance when it comes to using packages
1226040	1230520	Uh, sometimes it can be dangerous and to use Joshua block's term insidious
1231000	1237800	Because we don't have a really good power or deep understanding of what's happening. Let's say at a memory management level
1238280	1240280	so as a good programmer, it's
1241080	1242520	I guess it's it's
1242520	1248760	It's important to be kind of prudent and careful about that and and be judicious as to how we write our code
1249000	1251720	Anyway, before I get carried away, uh, philosophizing about programming
1252040	1257320	Let's get back to the point here, uh, and the item he states then the fix for this sort of problem is simple
1257720	1262520	Null out references once they become obsolete. That's what I've shown here. I already showed the solution
1263080	1267880	In the code itself an added benefit of nulling out obsolete references is that if they are
1268440	1274520	Subsequently dereference by mistake the program will immediately fail with the null point exception
1275160	1277160	Rather than quietly doing the wrong thing
1277320	1281080	It is always beneficial to detect programming errors as quickly as possible
1281320	1284680	Now, I don't know how in this class someone could dereference
1285240	1287240	parts of this array that
1288040	1294760	Theoretically should not be accessed in the stack class, but it's possible if that area was public. Let's say by mistake
1295640	1296840	and
1296840	1299160	theoretic it would be a theoretical mistake if
1299960	1301960	after the size of the
1302040	1307160	Stack changes, let's say the size of the stack was three and we only had zero
1307880	1309400	One two and three
1309400	1314200	And we still get access to the client to uh four and five that would be a mistake
1314360	1316120	But when we now that out
1316120	1320520	The error is explicit and clear because the program will throw a null point exception
1320600	1326840	But interestingly then he also makes the provision that nulling out object references should be the exception
1327320	1329160	Rather than the norm
1329160	1330280	so
1330280	1332520	Technically this thing what you've done here
1333640	1337560	Shouldn't always be done. There are better ways to handle this or eliminate
1338040	1343080	obsolete references than just nulling out elements in this area. Let's say in this example
1343640	1347720	The best way to eliminate an obsolete reference is to let the variable
1348200	1351000	That contain the reference fall out of scope
1351640	1355240	This occurs naturally if you define each variable in the
1355880	1359240	narrowest possible scope and this is kind of what I meant by uh
1359960	1362360	Narrow scoping is one way that allows
1363000	1370360	Eliminating obsolete of references and I did explain what narrow scoping is it's ensuring that when we define a variable and we declare a variable
1370600	1371960	It's in the
1371960	1374680	Narrowest possible scope in our source code
1375000	1379480	But if he says nulling out shouldn't be the norm why in this example is given in the stack class
1379640	1387000	Why are we nulling out uh these references? Why not use narrow scoping as he suggested which he says should be the norm
1387800	1393240	To put it simply he says it's because the stack class manages its own memory. We see that here
1393800	1395800	We see that as to what's what's what's going on here
1396920	1401560	Where we're managing the memory I propose this array here
1404120	1408120	The storage pool consists of the elements of of the elements array
1408600	1412920	That's a bit a bit confusing. I know but the elements inside this array. So each
1413640	1414760	uh
1414760	1422360	Individual element which he's added here are the object references not the objects themselves. So these are references themselves
1423080	1427720	And then the elements in the active portion of the array as defined earlier are allocated
1428040	1430600	And those in the remainder of the array are free
1431320	1435240	So that's the active portion. That's allocated and these are made free
1437880	1441080	The garbage collector has no way of knowing this to the garbage collector
1441240	1447640	All of the object references in the element elements array are equally valid correct because the garbage collector doesn't know
1448040	1452680	What the purpose of this stack class is the garbage collector isn't that intelligent
1452840	1458360	Hopefully in the future it would be only the programmer or get up co-pilot perhaps
1458840	1462200	Knows that the inactive portion of the array is unimportant
1462760	1466840	The programmer effectively communicates this fact to the garbage collector by manually
1467240	1473640	Nulling out array elements as soon as they become part of the inactive portion. That's correct. That's what we've done here
1475240	1478200	And then just to conclude that point joshua block states
1478680	1480200	Generally speaking
1480200	1485560	Whenever a class manages its own memory the programmer should be alert for memory leaks
1485960	1488680	So what are the examples can we think of when it comes to memory leaks?
1489240	1491240	apropos java and jvm
1491880	1497800	Another example that he's given here is memory leaks that we would see and sorry. I shouldn't say apropos java and jvm
1497880	1503000	This is just commonly in programming in let's say op programming in general
1503560	1506280	These examples he's laid out or laid down
1506920	1508920	could lead to potential memory leaks
1509960	1517320	And the first one is given is in caches. It's quite common to see memory leaks in caches because of course what happens a lot in a cache is we
1518280	1521560	Cache data and when we do cache data we cache objects
1522120	1528520	There's a high possibility if we don't do it in a smart port art way that it can it can lead to
1529960	1533480	Obsolete object references because once an object reference is put in a cache
1533880	1536680	It can be left there long after it stops being relevant
1536840	1541400	Toss being obsolete and the solution for this problem of memory leaks and caches that
1541800	1545000	Joshua blocker suggests it is using weak hash maps
1545560	1550520	And when I said in the beginning of the item that there are some ancillary points some concepts
1550520	1555080	We need to understand to really get to the crux of this item
1555960	1559320	This is what I meant. I've never used a weak hash map in my life
1560040	1564200	Therefore I had to do a bit of reading and styling as to what weak hash maps are
1565080	1569640	So just a block states before I get to what a weak hash map is and before I go through the code
1570120	1572440	Which I've got here. I've got a weak hash map demo
1574360	1579560	Joshua block states if you're lucky enough to implement a cache for which an entry is relevant
1579720	1585080	Exactly so long as there are references to its key key outside of the cache
1585800	1588040	Represent the cache as a weak hash map
1588840	1592600	Entries will be removed automatically after they become obsolete
1592680	1597080	So conceptually that sort of makes sense, doesn't it because the reason we have a cache is to
1597400	1600520	for quick access of data of objects and
1601240	1607720	The key in a cache we we got to make sure that whatever data that's in the cache that the keys are
1608280	1610280	relevant outside of
1610520	1613560	The data structure in the cache in this case. It could be a hash map
1614200	1620840	So that ensures that we don't have obsolete object references and he keeps going that remember that
1621240	1623240	Weak hash map is useful
1623240	1630040	Only if the desired lifetime of cache entries is determined by external references to the key not the valley
1631160	1635080	Okay, now let's understand what a weak hash map is
1635720	1642040	Firstly before we get to the code, let's get through some definitions. It's important to get a firstly a theoretical understanding
1642040	1644040	a conceptual understanding of what this is
1644440	1650280	Uh, and one of the best definitions as for you sure that I found is by about dunks blog
1651000	1659000	It's this blog now that's on profile is it's this blog post here a guide to weak hash map in java
1660600	1662600	And he states
1662680	1670040	Simply put the weak hash map is a hash table based implementation of the map interface with keys that are of a
1670680	1676600	Weak reference type and now we have another term here. What are weak references for that will open up
1677240	1680760	The best explanation that I found is this stackover flow answer
1681320	1685240	Uh, and in fact, this user says that it's by ether necklace
1685640	1688120	But the name of this user is michael myers
1689000	1695000	And a weak reference simply put is a reference that isn't strong enough to force an object to remain in memory
1695560	1701720	weak references allow you to leverage the garbage collectors ability to determine the reach ability for you
1702120	1704120	So you don't have to do it yourself
1704360	1709400	But also in this article by bio dung. He's given some pretty good definitions where he
1710360	1716200	Decerns between strong soft and weak references. So a strong reference is what would normally be when we
1716760	1720760	Declare a variable like this. Let's say that's a strong reference
1721320	1726440	And this is the most common type and it's not eligible for garbage collection
1726920	1731400	A soft reference is eligible for garbage collection, but only when
1732120	1737640	Uh, the jvm needs more memory. It absolutely needs more memory. And in fact, he's made that point here
1738280	1741160	It's it's kind of like a last resort kind of thing
1741640	1747160	But a weak reference is not that a weak reference doesn't the garbage collector is given volition
1747800	1753240	Where it can so eagerly garbage collect it won't wait until it needs more memory. It'll just
1754600	1757640	Use it up if required and that's where
1758360	1762360	Using a weak reference in the context of a cache helps us to eliminate
1762840	1764840	obsolete object references
1765080	1769560	So in any case, that's another definition of a weak reference. There's also this article
1770120	1776680	That I read which is quite good. I think it gave a pretty good practical and sort of applicative explanation of what
1777400	1783160	Well, the title of the article is practical uses of weak references by this user
1783800	1785800	philosophical geek or I guess Ben Watson
1786200	1789000	I'll leave a link to this down below too where he goes through
1789560	1791560	Well, he starts off the article by saying that
1792200	1795400	You rarely use weak references, but if you do use them
1796280	1803240	It'll mostly be for framework building or when it comes to something at more of the memory management level and
1803480	1806600	Java programmers at least day-to-day Java programmers like myself
1808040	1810760	Don't don't really do a lot of memory management
1811560	1818040	But this is a good article to read just for learning. So back to the weak hash map definition, which uses weak reference type, by the way
1818840	1820360	file then continues
1820360	1824040	An entry in a weak hash map will automatically be removed
1824760	1831720	When its key is no longer in ordinary use meaning that there is no single reference that point to that key
1833160	1835960	When the garbage so what this bit means here
1837480	1838600	is
1838680	1841560	In the the key value pairs and in the hash map
1842040	1846200	If the key isn't being used anywhere outside of the data structure outside of the cache
1846840	1850680	That means that there's no single reference. Therefore, it just could be removed
1851320	1853560	automatically and and having a weak reference helps
1855080	1861640	When the garbage collection process discards a key its entry is effectively removed from the map
1862040	1867400	So this class behaves somewhat differently from other map implementations because
1867960	1872600	normal map implementations would have a strong reference and you can't just
1874200	1878040	Let the garbage collector just do garbage collection as it wishes eagerly
1879160	1881880	It's a bit more tighter and a bit more stricter
1882680	1885000	I just realized that I didn't go through this
1885640	1893240	Canonicalized a mapping bit that is in fact from the oracle docs that defines what weak references are
1893240	1897400	So the doc state weak reference objects which do not prevent
1898120	1903160	Their reference from being made finalized finalizable finalized and they're reclaimed
1904600	1907400	weak references are most awfully used to implement
1908680	1911640	Canonicalizing mappings. What does that mean?
1912520	1914840	So this is another really good blog post. I read
1918280	1921000	On weak references, sorry I had to find the blog post here
1922840	1927640	And the title of the blog post is itself canonicalized mappings. I'll leave all into that down below
1927800	1930680	I'm not going to go through the whole thing. But the definition is
1932600	1935080	But oh the it's by uh, uh, Tom
1935800	1937320	Tom Roy's own
1937480	1939480	Rosanne and Ian Lowe
1939720	1944360	A canonicalized mapping is where you keep one instance of the object in question in memory
1944840	1948680	And all other lookup that particular instance via pointers
1949400	1951400	Or some such mechanism
1952040	1955880	The short answer is that weak reference objects can be used to create
1956520	1964120	Pointers to objects in your system while still allowing those objects to be reclaimed by the garbage collector once they pass out of scope
1965080	1967560	That kind of makes sense. I mean, I
1969160	1970360	Hmm
1970360	1972360	It makes sense in the sense of
1972920	1974920	I can see why
1975000	1977000	theoretically a weak reference type
1978440	1982200	Can be used in a weak hash map to prevent
1983720	1989000	Memory leaks in a cache. I can I can see the reason I'm going to be honest. I don't think I can
1989560	1991080	sell fully
1991160	1993160	Understand how to implement that in code
1993240	1999320	But at least conceptually I can see the connection there. So now let's take a look at what a weak hash map is
1999320	2004680	So I created this class called the weak hash map demo. I kind of repurposed this example
2005240	2007720	That was used on vile dunks blog
2008680	2014600	And firstly, uh, this part really isn't a part of the weak hash. I just want to show how to create a weak reference
2015080	2018040	That's how you do it. It's a generic type. You pass it
2018760	2020200	of integer
2020280	2023480	And then you create the weak reference easy as that and then when we
2025000	2027400	Made this prime reference null
2028280	2030280	Initially, we declared let me make it null
2030600	2034440	This object will be garbage collected in the next gc cycle
2035000	2038760	Um, as there is no other strong reference pointing to it
2038920	2042760	So when we create the weak reference as you can see here, we are passing that object
2043720	2050280	Into the constructor of the weak reference class and now this new object is a of type weak reference
2050680	2057080	But that's just how I create weak references. Now, let's get to the the cracks of this class. I this is terrible coding
2057080	2061080	I should have put this somewhere else because this in no way is related to this class
2062120	2065320	But in any case, it's just for demonstration purposes
2066200	2070280	Here's how we create a weak hash map. Um, so
2071240	2076520	It's just like creating a normal hash map really. Um, you have to define the key and the value the types of the key and the value
2077480	2079480	and ideally we want a
2079480	2081640	map implementation that allows
2082280	2085160	garbage collection to automatically delete unused objects
2085960	2087560	correct and
2087560	2091320	Because we ideally want that is is the reason that we use a weak hash map
2091800	2097720	When a key of a big image object is not in use and application in any place. So that's
2098520	2103320	Uh, the key for this object here the unique image name in this case would be the key
2104120	2109320	This entry will automatically be deleted from memory. It's pretty cool. In fact, how this happened and I'll show you
2109720	2114760	This and show this to you in code. So we have the weak reference map. Just ignore the other line of code
2114760	2118200	I've used here. It's just a normal hash map. I've used I was just playing around with this
2118280	2122200	But what matters really is the the map I've created here in line number 25
2122520	2126040	So for all intents and purposes this hash map could be our cache
2126760	2128760	And we are putting a new
2128760	2132440	big image object into that cache into our hash map
2134680	2139480	We're also creating key and putting that key too and we're creating the key value pair here
2141240	2144440	And the image name of course is the object reference, which is the key
2145160	2148280	Uh, so if I run this code now what you'll see is
2152920	2154920	Um
2155240	2162280	So what's this log here map this contain does not contain an image name. Um, so
2164440	2166200	That is terribly misleading
2166200	2169720	I just realized that that log can be extremely confusing because
2170440	2174840	The map is supposed to contain image name because they're putting it in line number 31
2175240	2177080	And we aren't nulling out any key here
2177160	2183080	So I I'm gonna run that again because that can be really confusing and kind of ruin the purpose of this demo
2184760	2186760	The map should contain
2188120	2189240	Image name
2189240	2194280	It should contain the key because we haven't nulled it out and I think nothing has happened and of course
2194840	2199240	The map will also contain a big big image the big image object
2201320	2204840	Also, that's confusing I should have prepared for this demo much better
2205240	2209480	I gotta get rid of that line because I'm adding it twice into the hash map. I don't know why I'm doing that
2209800	2212120	Anyway, in any case, I hope I'm trying I'm making sense
2212120	2215160	Yeah, I profusely apologize because this is not a good demo
2215960	2222360	Hey, but uh, as the software engineers, we all know that whenever there's a demo things break. So perhaps it is
2223480	2227960	Ironically a good demo because this is what a demo would actually look like. Uh, so
2228920	2233560	Initially, yes, it does contain the key and it also does contain the value
2234040	2235720	And then what happens is
2235720	2238920	We null out the key. That's all we're doing. We're not clearing anything out
2239240	2245640	And then we just run a garbage collection cycle. We force a jvm to write a gc cycle and then
2246440	2248120	almost magically
2248120	2250120	The bloody hash map is empty
2250440	2255480	And how is that this wouldn't happen if it was a normal hash map with a strong reference
2256440	2259800	The way the hash map is empty in so this is the log here that you see
2260760	2266920	Uh is in fact because this hash map is a weak hash map using weak reference type
2267640	2269640	so when the external
2270600	2272920	Reference to this key was nulled out
2273720	2276280	The object itself or the key value pair
2276920	2282440	Was garbage collected because it's it's it's it's not not used. So that's the perfect
2283480	2285960	implementation of a cache that'll prevent
2286680	2291960	memory leaks and then for this problem of memory leaks and caches and another solution that he's proposed
2292440	2294440	is sort of using a
2294520	2297880	least recently used cache eviction policy, uh
2298680	2304680	But the implementation of it is a bit more different to kind of the conceptual understanding of what that policy is
2305160	2309080	And that can be done using a scheduled thread pool executor
2309560	2313160	And it could be what what this does is in the background on a separate thread
2313240	2319080	You can run tasks scheduled tasks repeatedly such as cache cleansing
2319800	2325080	Uh, and to understand what this is what a scheduled thread pool executor does
2325560	2331160	I came across this article on geeks for geeks by a user called
2333400	2336600	Samu foe and that's the user's uh pseudonym
2337640	2338680	and
2338680	2341960	Here's the implementation of that class. I think it's important to understand what this is doing
2342360	2347080	Even though this isn't fully related to clearing caches the way it'll work is like this
2347720	2350440	So I anyway, but by the way all this code is
2351080	2353400	On the github repository. So please go take a look
2354200	2358680	And this kind of demonstrates how the schedule thread pool executor works
2360600	2363240	Initially we create a object called thread pool
2363480	2366920	We create an instance of the schedule thread pool executor and we pass
2367560	2370600	The the size so how many threads it's two threads in this case
2371240	2376440	And then we create two runable tasks. So these tasks could be anything it could even be something like
2377480	2378440	the main
2378440	2381160	Let's say the main thread that's running the program and then in the background
2382200	2384520	clearing the cache in a given time
2385240	2387240	um, and afterwards
2388440	2392760	The first one will execute in two seconds and the second one in five seconds
2393240	2396680	That's it's simple as that so if if I run this method you'll see
2396760	2398760	The
2400280	2404440	The first one executed in two seconds and the other one executed a bit later and then
2405080	2407080	That a bit later. Sorry
2407640	2412280	That's the current time. I apologize. So that was in the execution. So that was the first task
2413000	2415000	And that was the second task
2415160	2421240	So I shouldn't have said every cache every cache of both tasks because this could be in fact, uh, something else. It could be
2422040	2425560	um, I don't know some some some main task and then the
2426120	2427880	second one
2427880	2431000	Which we scheduled to run in five seconds could be the cache eviction
2432440	2435320	So that's the implementation of of that idea of
2436120	2442120	Cache eviction policy using a scheduled critical executor and to be you know, pretty more formally and clearly
2442760	2449080	Joshua block states most commonly the useful lifetime of cache entry is less well defined
2449480	2452280	With entries becoming less valuable over time
2452840	2459800	Under these circumstances the cache should occasionally be cleansed of entries that have fallen into disuse. So that's where
2460520	2463720	scheduling a task like this using uh, these scheduled
2463800	2466120	Terrapulexecuda could come in handy because
2466760	2471320	We could time it because schedule a cache eviction in a given period of time
2471640	2477800	And then he even states that the linked hash map does this so if you take a look at the docs for the linked hash map
2478120	2480120	there's a protected
2480520	2481720	Boolean
2481720	2488360	method called remove eldest entry and that method what that does is in fact
2492200	2498360	It's an implementation of what Joshua block is described here. It is is clearing the uh, linkless
2499640	2501640	Sorry the link hash map
2501640	2503480	By clearing out the old entries
2503480	2509800	So it says it provides the implement of this class with the opportunity to remove the eldest entry each time a new one is added
2509960	2512520	And then we get to the third way memory leaks could happen
2512840	2516120	So we've discussed, uh, how it could happen if classes
2516520	2522040	Manages their own memory if we discussed how it could happen in caches and the third way is
2522600	2526520	uh, the third common way is it could happen when it comes to, uh
2527480	2529480	listeners and other callbacks when we
2530360	2532360	When a client uses an api
2532920	2536920	With a callback function. So firstly, what's a callback? Um, so
2537640	2539240	Rich, uh
2539240	2545400	Rich of jindal from geeks4geeks states that a callback function is a function that is passed
2545800	2550200	Into another function as an argument and is expected to execute after some kind of event
2551000	2557480	I would also add it's also an example of so the how callbacks are implemented is an example of the observer pattern
2557880	2561240	Where an object should subscribe to another object and listens
2561880	2563880	To changes in events on runtime
2564440	2568840	And that's what a callback is. It's a it's a function. It can pass to be executed
2569800	2571000	you know
2571000	2573560	Contingent on on on an event during runtime
2574920	2579400	Uh, even though I've used callbacks obviously javascript uses well we use promises
2579400	2583240	But then a lot of javascript uses before promises use callbacks
2583960	2589640	And even in java we use callbacks, uh, but I didn't initially get the understanding
2589960	2591960	Oh, I didn't initially understand
2592600	2593960	How it can
2593960	2598680	Work apropos weak references and how the garbage collection works when it comes to callbacks
2598680	2602600	So I did post a cycle of low question and I got a really good answer
2603160	2605160	By this user called, uh
2605400	2607400	Ingo kegel
2607400	2610920	I'll leave a link to this question down below in the description. Go take a look
2611800	2616120	But you think that uses the answer. Let's try and make sense of what
2616120	2618120	Uh
2618440	2624280	Well, in fact before I say that I just want to say, uh, just a block states apropos this point
2624600	2627480	If you implement when I mean apropos this point, that's uh
2628120	2633080	When it comes to memory leaks with listeners and other callbacks, he says he states
2633480	2639240	If you implement an api where clients register callbacks, but don't do register them explicitly
2639640	2643240	They will accumulate unless you take some action
2644200	2647800	So what does that mean? What what's the action we got to take the action?
2647800	2655400	We got to take would be using a weak reference. Um, and what before we get to the code. I I realized I should I should read out
2658040	2659880	Ingo kegel's answer here
2659880	2664200	He says a client of the api has to keep a strong reference to the listener
2664760	2669720	That's how it says without correct. So the we can define the listener here as an interface
2669720	2672440	That's how we would normally do when implementing callbacks in java
2674200	2678120	The api only holds a weak reference to the listener to do that
2679800	2681800	So that it does not prevent that's a
2682840	2687400	Type of that I believe so that it does not prevent the client from being garbage collected
2687960	2689240	So it allows
2689240	2695800	Garbage collection to take place if required when the kind is garbage collected the listener is also garbage collected
2696280	2699080	That's that's a good thing because we want we don't want the
2699320	2705240	Obsolute object the listener object to exist in memory and take up resources and that's why a weak reference would help
2706040	2712760	Now the implementation of that would be seen here. So this is the example's courtesy of ingo kegel as I said
2713160	2716440	This is his code that I've repurposed uh to don't want to write this
2716920	2718040	um
2718040	2724120	So firstly, uh since java doesn't support function pointers, this represents a callback effectively
2724200	2726760	It's a reference to the function which will be called
2727720	2731560	So because we don't use function pointers, we can use callbacks in java
2732040	2737480	Function pointers can be used in c++. I believe I don't quote me on that because I'm not a c++ programmer
2737800	2742600	C++ programmer. Why am I talking so fast and fumbling my words too much of coffee?
2743560	2747720	So this callback demo represents the mock api that a user would use
2748360	2753160	Initially, we have defined the listener here. So this listener is of the type the interface listener
2753320	2760200	Um, and then we've got to initially register this listener. That's what the client would do. So the client of this api
2760920	2767320	Uh would do that a bit later because the observer of this api has to use that method
2767880	2769960	And register itself. This is a bit confusing
2769960	2773080	I should have maybe called it used to separate class and called the client
2773080	2776600	But this callbacks demo class is the client of this api
2777320	2782760	Just keep in keep in mind. Um, so that client would have a strong reference
2782840	2784120	however
2784120	2785800	once the
2785800	2787800	registering is done the
2787800	2789800	api itself
2789960	2796680	Will maintain a weak reference because then what happens is when this client at one point is garbage collected
2798040	2800040	So would the listener
2800760	2803880	That it registers and then we have this file listener method
2804280	2809640	Which checks for the listener which which checks if it's registered and then fires an event which we've defined
2810600	2816840	Yeah, which runs some tasks. So that's kind of how it's used in the context of callbacks and listeners
2818920	2821880	And and that's why using a weak reference would help
2822440	2828040	With ensuring that there aren't any memory leaks when a client uses our api
2829160	2832040	And then to conclude in the final paragraph Joshua Block states
2832840	2835960	Biggest memory leaks typically do not manifest themselves
2836440	2841080	As obvious failures. They may remain present in a system for years
2841560	2846040	They typically discovered only as a result of careful code inspection
2846520	2852680	Or with the aid of a debugging tool known as a heat profiler heat profiler can also be called like a java profiler
2853080	2855640	And that's a tool pretty much that monitors the bytecode
2856120	2862120	Constructs and operations at the jvm level at a very low level using a heat profiler. You could
2863160	2865800	Monitor your code and examine memory usage
2866200	2871320	How garbage collection takes place if resources are being used waste used wastefully
2871960	2876520	If there are memory leaks all these things we discussed could be found through a tool like a
2877800	2879800	Java profiler or heat profiler
2880440	2888600	And again all done is definition here these these code constructs and opera operations include object creation iterative executions
2889160	2894920	Including recursive calls method executions threat executions and garbage collections
2895160	2899560	So it's kind of like a way of instrumenting your application and instrumenting your code. Let's say and really
2900520	2903720	Digging deep into it and examining it at a bytecode level
2904120	2907400	And that's obviously something that you know, I've never done it before in my life
2907720	2911160	Just on your id you can't do that. You need a specific tool for that
2912920	2920120	Therefore to end it he states it is very desirable to learn to anticipate problems like this before
2920440	2924360	They occur and prevent them from happening. So that's why this point is great because
2925400	2929160	Initially just your block points out what the issue is he he kind of
2930280	2935720	Illustrates it, but then he also gives us three areas where this could potentially occur
2935720	2943560	We could kind of anticipate where memory leaks could occur when writing code and the three places it could occur
2945000	2947000	When it comes to having
2948280	2950760	obsolete object references that we should eliminate
2951560	2953320	is in
2953320	2958120	classes that just to reiterate the point in classes that manage its own memory
2959080	2963000	In caches and when it comes to callbacks and listeners
2963720	2965720	When you implement that in your api
2965880	2967880	That's it. That is
2967960	2972280	The item number seven element obsolete object references
2973400	2980520	As I did anticipate it did go for over an hour because I did feel even though the item isn't all that long or all that complicated
2980840	2982840	have a few points like
2983560	2985720	implementation of the listeners and the callbacks and then the
2986360	2991880	Weak references that I felt like we need to dive in a bit more and understand at least I needed to to make sense of it
2992360	2995000	As I said all the code that I used are in
2995560	2998840	On the github repository and the link to that is in the description down below
2999400	3002520	Please go to click at the code. It'll make a lot more sense if you study the code
3003240	3005960	assiduously instead of me kind of explaining it
3006840	3013000	Again, I'm trying my best to to you know articulate myself while I'm also learning as I go
3013160	3017720	It's kind of how it works. You probably can see I'm struggling a lot with some of these concepts
3018520	3024520	But in any case, I sincerely do hope this video brought some value. You learn something from it
3024920	3029960	I shall see you in the next item. It is item number eight. We're still in chapter two
3030840	3034920	And item number eight is avoid finalizers and cleaners
3035800	3041480	And I'll get to that as soon as possible. In fact, I've already started writing the code for it. I'll see you in the next one. Cheers
3043000	3045960	You
