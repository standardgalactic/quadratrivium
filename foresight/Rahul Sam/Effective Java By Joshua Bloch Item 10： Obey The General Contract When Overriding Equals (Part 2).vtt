WEBVTT

00:00.000 --> 00:06.800
Hey, everyone, welcome to part two of item 10, obey the general contract when overriding

00:06.800 --> 00:13.840
equals of Joshua Bloch's effective Java. Needless to say, please do watch part one to

00:13.840 --> 00:18.800
make sense of this item, because it's just a follow on from from part one. And I'll be

00:18.800 --> 00:22.160
working down this item into multiple parts, because it's quite long. But without further

00:22.160 --> 00:26.960
ado, let's get started, because this is quite a long part. So in the previous part, we discussed

00:27.920 --> 00:35.600
when it's appropriate or warranted to not override the equals method. Generally, it's always a good

00:35.600 --> 00:42.720
idea to override the equals method. However, there are certain instances where it's not required.

00:42.720 --> 00:48.000
And we discussed that in part one. And in part two, today, we're primarily going to focus on

00:48.000 --> 00:53.360
when is it appropriate to override the equals method. And afterwards, kind of kind of gonna,

00:53.360 --> 00:58.320
we're gonna go into detail as to what the general contract is. So firstly, I propose when it's

00:58.320 --> 01:05.120
appropriate to override the equals method, Joshua Bloch states, it's appropriate when a class has

01:05.120 --> 01:12.960
a notion of logical equality that differs from mere object identity, and a superclass has not

01:12.960 --> 01:18.560
already overridden equals. So we did discuss what logical equality was in the previous part.

01:19.120 --> 01:24.960
But for all intents and purposes, as a Java programmer, what we care about is

01:26.480 --> 01:31.680
in logical equality, a programmer doesn't care about the memory reference or the

01:31.680 --> 01:37.120
the quality of the object per se, but rather the content or the value of an object.

01:37.120 --> 01:42.080
The easiest way to put that is by looking at classes such as string or integer, where if we

01:42.080 --> 01:51.280
take, in fact, string, string objects are immutable. So there's only one object of this type that exists

01:51.280 --> 01:57.600
in memory and everything else will point to that. So in this context, when it comes to logical

01:57.600 --> 02:03.760
equality, what we care about really isn't the object per se, whatever the data of that object is,

02:03.760 --> 02:10.000
however, the value of the object. So we should only care about this bit here. And that means

02:10.000 --> 02:14.240
it's logical equality. So if you have string s, and then we also have, let's say,

02:17.680 --> 02:18.400
that was a mistake,

02:21.680 --> 02:28.560
a string b, let's say, both these strings, s and b, have logical equality because the content is the

02:28.560 --> 02:35.440
same. So these classes have a notion of logical equality. And then he states, not only is overriding

02:35.440 --> 02:42.480
the equals method necessary to satisfy programmer expectations, it enables instances to serve as

02:42.480 --> 02:49.440
map keys or set elements with predictable, desirable behavior. And then he adds an ancillary point

02:49.440 --> 02:56.000
saying that enums or enum objects are an exception to this value class heuristic,

02:56.000 --> 03:00.160
I coined that term value class heuristic, he doesn't really use that term. But I feel like

03:00.160 --> 03:06.880
to understand the concept of logical equality, apropos Java programming, that is a good heuristic

03:06.880 --> 03:13.280
to keep in mind. So enums, though, are an exception. That's what he states. And just to get some

03:13.280 --> 03:19.360
formalities out of the way, let's say, according to the Java language specifications 8.9,

03:20.320 --> 03:27.760
here's how an enum is defined. An enum type has no instances other than those defined by its enum

03:27.760 --> 03:34.480
constants. It is a compile time error to attempt to explicitly instantiate an enum type. The final

03:34.480 --> 03:40.800
clone method in enum ensures that enum constants can never be cloned. And the special treatment

03:40.800 --> 03:47.440
by the serialization mechanism ensures that duplicate, duplicate instances are never created

03:47.440 --> 03:55.120
as a result of deserialization. Reflective instantiation of so that's from the Java

03:55.200 --> 04:01.680
Reflections API. Reflective instantiation of enum types is prohibited. By the way, what that API,

04:01.680 --> 04:09.840
the Reflections API does is it changes the structure of classes on runtime. It is not something

04:09.840 --> 04:16.720
a normal Java programmer would do. It's mostly used by framework designers. So I've never used

04:16.720 --> 04:21.680
the Reflections API, but it's just good to keep good to keep in mind what it does. Anyway, getting

04:21.680 --> 04:26.960
back to the definition, sorry for interrupting it. Reflective instantiations of enum types is

04:26.960 --> 04:33.200
prohibited. Together, these four things ensure that no instances of an enum type exist beyond

04:33.760 --> 04:43.040
those defined by the enum constants. And again, attending to our point, it's for these classes,

04:43.040 --> 04:49.840
so enums, logical equality is the same as object identity. So objects equals method functions as

04:50.640 --> 04:56.640
logical equals method. What that would mean really is, if let's say this S and B were enums,

04:59.200 --> 05:05.840
if the objects were identical, we could say for all intents and purposes, there's also logical

05:05.840 --> 05:12.720
equality. So here's a small demo. Let's take a look at it that I put together. So I have two enums

05:12.720 --> 05:20.160
here. Day and day two both have days of a week. Now, if I do run this, it's going to print false

05:20.160 --> 05:26.720
because there's no logical equality in this case because there's no object identity. However,

05:26.720 --> 05:38.800
let's say I create two instances of day. Day dot, was it Monday? Yeah. And then I'll also create

05:38.880 --> 05:48.000
another day two with the same thing, with the same day. You'll see here, if I print this out,

05:48.000 --> 05:53.520
if I do compare these two objects, it'll print true because the logical equality here

05:54.160 --> 05:59.520
equates to the object identity. So I'll just go day one,

06:00.080 --> 06:06.560
day two. I'll comment that out. You'll see a true being printed now.

06:10.880 --> 06:16.720
That's it. So the object identity equates to the logical equality. And that makes sense.

06:17.440 --> 06:20.640
So reiterating that point, so the idea really settles in our mind,

06:22.240 --> 06:28.960
overriding the equals method is required or is appropriate when logical equality

06:28.960 --> 06:34.480
differs to object identity. Now, I accept the enums class, of course. Whenever we know that

06:34.480 --> 06:41.520
object identity is not equate to logical equality, override the equals method. And that gets us to

06:41.520 --> 06:47.600
the general contract when overriding the equals method. And that's what we're going to discuss

06:47.600 --> 06:52.640
for the rest of this part. And in fact, the next part too. And there's a lot to get into here.

06:52.640 --> 06:57.120
All right, before we get to the properties that define this general contract, I need to skip ahead

06:57.120 --> 07:02.880
a bit and read a caveat that Joshua Block has put in. Because in fact, I wish you would have put

07:02.880 --> 07:08.080
that bit earlier before getting to the properties because the caveat is a good starting point

07:08.080 --> 07:12.400
in understanding these properties. Because it's really important that we don't ignore them.

07:13.280 --> 07:20.400
They can be a bit overwhelming to understand. Nevertheless, ignoring them isn't the solution.

07:20.400 --> 07:25.440
It's enduring through and assisting and trying to make sense of them and implementing them in our

07:25.440 --> 07:31.840
code. So here's a caveat Joshua Block has put in. Unless you are mathematically inclined,

07:31.840 --> 07:37.600
this might look a bit scary. So what he means by that is the properties that he listed down or

07:37.600 --> 07:45.120
enumerated. But do not ignore it. So don't ignore these properties. If you violate it, you may well

07:45.120 --> 07:52.080
find that your program behaves radically or crashes. It can be very, very difficult to pin down

07:52.080 --> 07:58.560
the source of the failure. To paraphrase John Donne, is that how you pronounce his surname?

07:58.560 --> 08:07.280
D-O-N-N-E. John Donne, probably. No class is an island. Instances of one class are frequently passed

08:07.280 --> 08:15.360
to another. Many classes, including all collections classes, depend on the objects passed to them

08:15.360 --> 08:21.360
obeying the equals contract. Just on that point, there's a really interesting kind of philosophy

08:21.360 --> 08:27.600
in object-oriented programming. And I think even Alan Kay, the inventor of OOP, he makes this idea

08:27.600 --> 08:36.480
that I'm going to get a book. I was reading this book by Sandy Metz, which is a book on

08:36.480 --> 08:43.520
object-oriented design, but using Ruby. And what she states in this book is that it's better to

08:43.520 --> 08:50.960
conceptualize object-oriented programming more as message-oriented programming. And even Alan

08:51.040 --> 08:57.040
Kay, I believe, said in one of his talks that he wished that people emphasize the importance of

08:57.040 --> 09:02.880
messages between objects than objects themselves, which is the point that Joshua Blocks making here,

09:03.520 --> 09:12.240
all these contracts, all these properties that define these contracts that we ought to respect

09:12.240 --> 09:17.760
and take into account when writing code, they're more about the messages and how objects communicate

09:17.760 --> 09:23.440
with each other. Therefore, it requires a bit of a change of mindset. In any case, I don't want to

09:23.440 --> 09:28.880
get too carried away, but I thought that was an important point to add on to what we're discussing

09:28.880 --> 09:35.280
here. So given that we've got that caveat slash warning out of the way, let's get to the specifications

09:35.280 --> 09:42.400
for the contract. The equals method implements an equivalence relation. It has these properties.

09:42.400 --> 09:48.880
So there are six properties, sorry, five properties. And in this part, we're going to discuss three of

09:48.880 --> 09:58.080
them, especially because symmetry, sorry, not symmetry, transitivity is quite a loan property

09:58.080 --> 10:04.320
and there's a lot to discuss there. So, and then in part three, we'll discuss consistency and

10:04.320 --> 10:11.920
non-nullity. However, that's later on. Let's stay on track here. So what is

10:11.920 --> 10:17.440
equivalence relation? And what does it mean to have equivalence relation between two sets?

10:18.080 --> 10:24.240
Look, Joshua Bloch puts it best. Here's what he states. Lucy speaking, so this is pertaining

10:24.240 --> 10:31.680
to equivalence relation, which the equals method implements. It's an operator that partitions a

10:31.680 --> 10:39.600
set of elements into subsets whose elements are deemed equal to one another. These subsets are

10:39.680 --> 10:47.200
known as equivalence classes. For an equals method to be useful, all of the elements in such

10:47.200 --> 10:53.680
equivalence class must be interchangeable from the perspective of the user. Sorry about that

10:53.680 --> 10:58.560
background noise. It gets so annoyed by this because I live in a very quiet neighborhood,

10:58.560 --> 11:05.520
but every time I record a bloody video, there's some noise outside. In any case,

11:05.680 --> 11:12.960
so what he means by for an equals method to be useful, all of the elements in each

11:12.960 --> 11:17.440
equals class must be interchangeable from the perspective of the user means again,

11:17.440 --> 11:22.720
going back to the string, from the perspective of the user, both these objects have logical

11:22.720 --> 11:29.840
equality and that's what necessitates equivalence relation. Saying that, let's get to the first

11:29.840 --> 11:37.360
item or the the first property that pertains to the general contract. Oh gosh, man.

11:38.960 --> 11:44.640
The noise is not ending. Is that a leaf blower or lawn mower? What the hell is it?

11:46.960 --> 11:53.280
Okay, part and parcel of living in a suburb. Hey, look, I look, I'm not complaining though,

11:53.280 --> 11:58.640
it's way better than the city. Ah, it ended. No, it didn't. I'm just gonna wait till it ends.

12:00.080 --> 12:08.880
I think it ended. Back to it. So, reflexivity. Ah, he's starting. Dude, the guy's trolling me.

12:08.880 --> 12:12.640
The guy's trolling me. You know what? I can't, I can't do this. We're just gonna keep going.

12:13.360 --> 12:19.440
I apologize about the background noise. So, starting off with the first property, reflexes.

12:20.800 --> 12:27.680
See, I got distracted. Reflexivity. Okay, what does that mean? What does reflexivity mean? I've

12:27.680 --> 12:33.840
got to be really flexible here right now. So, that means for any non-null reference,

12:33.840 --> 12:41.360
value x should equate to x. So, it's saying that an object x should be equal to itself,

12:41.360 --> 12:47.920
which kind of seems self-evident. So, if we have a x equals x, it must return true.

12:49.760 --> 12:53.840
Which is why, which is why Joshua Bloch states, the first requirement, say, is merely that an

12:53.840 --> 12:59.440
object must be equal to itself. It's hard to imagine violating this one unintentionally.

12:59.440 --> 13:04.320
If you were to violate it and then add an instance of your class to a collection,

13:04.320 --> 13:09.920
the contains method might well say that the collection didn't contain the instance that

13:09.920 --> 13:15.040
you just added. So, let's take a look at a quick demo, because obviously code makes more sense

13:15.040 --> 13:21.040
than theory, even though we are, I personally always like starting with theory, because it

13:21.120 --> 13:28.400
really helps to start high level. Where is this? So, if we go to reflexivity,

13:29.440 --> 13:38.880
it's really simple as this. So, I have a list of strings here, and what we're doing is we're

13:38.880 --> 13:46.640
adding the word Java into that list. So, it's a set, let's say, it's a string, and if you run this,

13:46.640 --> 13:53.040
it'll return true, because we're just checking if this set, this list, contains, using the

13:53.040 --> 13:58.240
contains method that's in the, using the, sorry, I bit my tongue, using the contains method in the

13:58.240 --> 14:04.320
object class. It's checking if Java exists in that list, and obviously it does. That's pretty much

14:04.320 --> 14:10.800
what reflexivity is. So, the next, if I have a hard word for me to pronounce. So, the next one is

14:10.800 --> 14:17.120
symmetry. So, symmetry states, again, for any non-null reference values x and y, so we have

14:17.120 --> 14:25.120
two objects in this case, x equals y must return true, if and only if y equals x returns true.

14:25.120 --> 14:29.680
So, again, going back to, I'm going to demo it in a bit, but going back to this here,

14:30.640 --> 14:36.480
s, s and b, so string s, so string s, if we take this,

14:39.360 --> 14:51.120
equals b. This should return true only if b dot equals s returns true.

14:53.440 --> 14:58.320
So, that's what symmetry is. And before we get to the demo, let's just read out this bit,

14:58.320 --> 15:02.960
just should look at stated. The second requirement says that any two objects

15:02.960 --> 15:08.400
must agree on whether they are equal. Unlike the first requirement, it's not hard to imagine

15:08.400 --> 15:14.320
violating this one unintentionally. So, we have this class here called case and sensitive string,

15:14.320 --> 15:20.960
and it's an attempt to implement a case and sensitive string class. In the class, what we have is we

15:20.960 --> 15:27.840
have a private final string s variable. We have the constructor, which in this case just

15:28.800 --> 15:36.320
checks if the object is non-null, if it is null, it returns a chosen error, and then it sets that

15:36.320 --> 15:42.960
value in our private field here in the class. And then we have the equals method that we have

15:42.960 --> 15:48.640
overridden, which breaks symmetry. So, firstly, I'll show the one, but the problem, I'll show

15:49.600 --> 15:53.360
the wrong way to do it. And then we also have another equals method written

15:54.000 --> 16:00.000
below here, which is the proper way to do it. And that'll fix the issue. So, let's take a look at

16:00.000 --> 16:06.000
this equals method that we've overridden. So, we have two if conditions here in the equals method.

16:06.000 --> 16:12.560
In the first one, what we're checking is if this object v pass is an instance of the case

16:12.560 --> 16:17.360
in sensitive class. So, that's what we're checking here using the instance of method. And if it is,

16:17.360 --> 16:25.520
then it'll just return true if that. So, firstly, we cast that object into case in sensitive string.

16:25.520 --> 16:31.440
If it is an instance of that, let's say a subclass of that, then we cast it to become a

16:31.440 --> 16:37.600
case in sensitive string. And then we compare it to our string field really that we defined here

16:37.600 --> 16:43.920
in line number 15. And if it is equals in that case, we return true. And that's fine. That's

16:43.920 --> 16:50.160
going to work. But then we're trying to go one step further and attempting to make this interoperable

16:50.160 --> 16:56.720
with a string class. So, again, the same way we're checking if this past object is an instance of

16:56.720 --> 17:05.440
the string class. And then we are saying return true if it's equal to a string. And we just cast

17:05.440 --> 17:11.200
it accordingly. And this is what breaks the symmetry. And I'll show you what that means.

17:11.200 --> 17:16.960
And of course, this line here, if it doesn't meet all these conditions, it'll return false.

17:16.960 --> 17:21.120
So, in the public static void main, what I have is I have an instance of

17:21.120 --> 17:28.000
case in sensitive string. And then I have another normal string instance. What we're doing initially

17:28.000 --> 17:34.480
is we're checking if this case in sensitive string is equal to s. And that will return

17:34.480 --> 17:39.520
true as expected because we're passing the word Polish here, the string Polish, and the string

17:39.520 --> 17:46.640
itself has Polish. And even though the first letter is uppercase, and here it's not uppercase,

17:46.640 --> 17:52.080
it's lowercase, it doesn't matter because this equality, what we're doing, the logical equality,

17:52.640 --> 17:57.280
what we care about is for it to be case in sensitive. We don't care about the case.

17:58.160 --> 18:04.960
But here, this is where the symmetry is violated. Because we are attempting in I equals method

18:05.920 --> 18:14.560
for this to be interoperable with normal strings, we're doing the comparison the other way around

18:14.560 --> 18:22.960
instead of comparing sys with s, we're comparing s with sys, and this returns false. Furthermore,

18:22.960 --> 18:30.880
if we add this string, I don't want to call it a string because it's a case in sensitive string,

18:31.840 --> 18:38.160
into a list of type case in sensitive string, it's a bit of a mouthful. And be printed, we

18:38.160 --> 18:43.760
expect this to return true, but it doesn't, it returns false. So that again demonstrates the

18:43.760 --> 18:50.240
violation of symmetry because the contains method uses the concept of logical equality,

18:50.240 --> 18:56.400
and we don't have logical equality here. So if I do run this, you'll see it'll return true false

18:56.880 --> 19:08.400
false. Right there. So this is the problem. Now, before I get to the fix, let me read out

19:08.400 --> 19:13.760
to put it a bit more formally and cleanly what Joshua Bloch has stated. He states,

19:14.640 --> 19:23.120
as expected, so he's referring to this bit here, as expected, sys dot equals s returns true.

19:24.000 --> 19:28.880
The problem is that while the equals method in case in case in sensitive string

19:29.520 --> 19:36.960
knows about ordinary strings, the equals method in string is oblivious to case in sensitive strings.

19:36.960 --> 19:42.960
So that is the equals method that we're going to use here in this slide that we use.

19:42.960 --> 19:53.840
Therefore s dot equals says returns false. So he's referring to that bit here now where it

19:53.840 --> 20:00.240
returns false. A clear violation of symmetry, suppose you put a case in sensitive string into

20:00.240 --> 20:04.640
a collection. So that's where moving on to the next bit here, which we again see that it's

20:04.640 --> 20:09.360
returning false. And this is a bit difficult to understand because here's what Joshua Bloch

20:09.360 --> 20:14.080
states on the contains method. Now, I was under the, well, I guess my assumption is right. My

20:14.080 --> 20:20.240
assumption was that because this violates the equals contract and the idea of logical equality

20:20.880 --> 20:28.560
and the contains method use ensures that objects that it gets respect this contract.

20:29.520 --> 20:34.320
It acts accordingly. Therefore why it's printing false here or it's returning false here.

20:34.320 --> 20:40.160
But here's what Joshua Bloch states. And I think my assumption is at least quasi accurate.

20:41.520 --> 20:47.600
What does list dot contains s return at this point? And then he says, who knows? In the current

20:47.600 --> 20:52.320
open JDK implementation, it happens to return false. So that's what we saw here. The third

20:52.320 --> 20:58.480
false is by this list dot contains. But that's just an implementation artifact. In another

20:58.560 --> 21:04.240
implementation, it could just as easily return true or throw a runtime exception.

21:05.280 --> 21:12.160
Once you violated the equals contract, you simply don't know how other objects will behave

21:12.160 --> 21:18.800
when confronted with your object. To eliminate the problem, merely remove the ill-conceived

21:18.800 --> 21:22.880
attempt to interoperate with string from the equals method. I shouldn't have read that part yet.

21:22.880 --> 21:27.120
I'll read that again, but that's how we fix the problem. So I'm going to read that bit again,

21:27.200 --> 21:33.600
though. Once you violated the equals contract, you simply don't know how other objects will behave

21:34.240 --> 21:40.480
when confronted with your object. This goes back to the idea I touched on a bit before by

21:40.480 --> 21:47.680
Sandy Metz on the book I was referring to, the Ruby book, that it's probably the best way to

21:47.680 --> 21:55.520
think about OOP is in the context of messages and how objects interact with each other over

21:55.600 --> 22:02.480
objects because objects aren't an island as we read from John Dunn. So that's what happens here.

22:02.480 --> 22:08.640
The contains method makes a lot of assumptions and those assumptions are wrong because, well,

22:08.640 --> 22:12.320
the assumptions aren't really wrong, but we've made a mistake in our object.

22:12.320 --> 22:18.160
Therefore, it breaks things. There's no logical equality. Now, getting back to how we fix this,

22:18.160 --> 22:24.160
as I did read that line, which I shall reread, it's simply ensuring that we don't

22:24.160 --> 22:29.680
try and attempt for the case in sensitive string objects to interoperate with string objects.

22:29.680 --> 22:34.880
And the way we do that is, I'm going to comment out this equals method because we can't have

22:34.880 --> 22:39.840
two equals method in the same class equals methods in the same class, unless it's overloaded.

22:42.320 --> 22:47.120
And then I'm going to get the other equals method, which doesn't attempt to override.

22:47.760 --> 22:48.400
Oops.

22:51.440 --> 22:56.960
Doesn't attempt to not override to interoperate with strings. It simply checks if it's an

22:56.960 --> 23:02.080
instance of case in sensitive string and then casts the case in sensitive string and just

23:02.080 --> 23:10.160
the normal equals ignoring the case. So now, if I run this bit here,

23:10.560 --> 23:17.280
you'll see I'm going to comment out these lines because they're, in fact, actually, no, maybe

23:17.280 --> 23:24.800
what I should do is I'm going to go and run the whole thing. And now the first three are printing

23:24.800 --> 23:29.920
faults and we expect it to print faults. We want it to because we don't want any interoperability

23:31.040 --> 23:37.040
with strings. And then in the second one, we're checking if it's equals and we're seeing if sys

23:37.040 --> 23:44.000
equals this new string we've created, again, Polish. And then we're checking if sys equals

23:45.040 --> 23:50.640
the other way around. We're checking for the symmetry. So you can see here in line number 53,

23:50.640 --> 23:57.280
it's uppercase p. And in line number, oh, that's a mistake, actually. That should have been lower case.

23:58.560 --> 24:06.480
Now, we can truly demonstrate the point. So if it's lower case here, line number 37,

24:06.800 --> 24:14.080
it's still ignoring that and printing true in these two lines. So line number 54, 55,

24:14.080 --> 24:20.720
correlate to these second true statements. I hope that made sense. So rereading what

24:20.720 --> 24:26.800
Joshua Bloch wrote, to eliminate the problem, merely remove the ill-conceived attempt to

24:26.800 --> 24:32.240
interoperate with string from the equals method. And now we move to the longest property from

24:32.240 --> 24:37.760
all the ones that Joshua Bloch has enumerated. And I had to take a smaller break just to

24:37.760 --> 24:43.440
refresh myself because this property is four or five pages. So there's a bit to go through.

24:44.800 --> 24:51.520
But let's get started. You know, the only way to get started is to get started. Wow, brilliant,

24:51.520 --> 24:58.720
brilliant. So what does this transitivity property states? Some of these words are a bit

24:58.720 --> 25:06.080
hard to pronounce. It's not going to lie. It states transitivity states, for any non-null reference,

25:06.080 --> 25:15.920
values x, y and z, if x equals y returns true and y equals z returns true, then x equals z

25:17.200 --> 25:25.360
must also return true. Or simply it's that if we have three objects with the content being

25:25.360 --> 25:31.120
same, three string objects, let's say, they should all print true when compared to each other.

25:31.920 --> 25:38.400
Simple as that because we require the logical equality there. Now, before we get to the demos

25:38.400 --> 25:45.280
and we demonstrate how this can go wrong and how to fix it, and even in fact some inherent

25:45.280 --> 25:51.600
flaws with Java and object-oriented programming, we got to get some theory out of the way.

25:52.560 --> 25:59.920
So should I read this out first? Let me think. Okay, I'll first read out a bit of like an

25:59.920 --> 26:04.320
introduction to this property from the book. Here's what Joshua Block states.

26:04.320 --> 26:10.320
Transportation pertaining to transitivity. If one object is equal to a second and the

26:10.320 --> 26:15.520
second object is equal to a third, then the first object must be equal to the third as we

26:15.520 --> 26:19.680
showed here. But as I said before we continue, let's get some theory out of the way. So

26:20.480 --> 26:25.200
something important to understand for this property is the Liskov substitution principle.

26:26.480 --> 26:33.280
The Liskov substitution principle is probably popularized by Robert C. Martin and his solid

26:33.280 --> 26:39.840
design principles. And of course, Barbara Liskov. Is that her name? I believe that's her name.

26:40.080 --> 26:50.080
Barbara Liskov. Yes, she is the scientist who invented this principle and made the contribution

26:50.080 --> 26:55.200
into the field of computer science. Here's how Robert C. Martin summarizes the Liskov

26:55.200 --> 27:00.560
substitution principle. Subtypes must be substitutable for their base types. And of course,

27:00.560 --> 27:10.320
I've got an example here that I use strategy PD to generate, to demo this principle simply. And then

27:10.320 --> 27:16.160
a bit more formally, let's say a bit more mathematical definition, Barbara Liskov defines

27:16.160 --> 27:26.720
it like this, which she did in 1988. If for each object O1 of type S, there's an object O2 of type

27:26.720 --> 27:37.920
T such that for all programs P defined in terms of T, the behavior of P is such of P is unchanged

27:37.920 --> 27:47.120
when O1 is substituted for O2, then S is a subtype of T. So another way of putting it is that if S

27:47.120 --> 27:53.200
is a subtype of T, then the behavior of O1 can be substituted for the behavior of O2, which are two

27:53.200 --> 28:00.080
objects. An example of that would be, again, generated by strategy PD. Thank you. Open AI

28:00.720 --> 28:07.280
and strategy PD, not to anthropomorphize it, but nevertheless, thank you. We have a class animal

28:07.280 --> 28:13.840
with a public void move method, and then we have a subclass. We subclass the animal class by dog,

28:13.840 --> 28:25.840
dog extends animal. And then we define a method that makes the animal move. So the subclass has

28:25.840 --> 28:33.680
a method called make animal move, which takes a object of type animal of the, that's not the sub,

28:33.680 --> 28:39.920
that's a subtype, not the, sorry, that's the supertype. And then this method, in fact, this

28:39.920 --> 28:45.600
method should be inside the, that was, I made it, it's not my fault, it's strategy PD's fault.

28:48.800 --> 28:58.160
If we put it in there, so it probably exists inside the dog class, and we create a new dog object,

28:58.160 --> 29:08.640
and then this method make animal move can take in an animal typed object too, because it respects

29:08.640 --> 29:15.920
the list called substitution principle or it owed to, because dog is a subtype of the supertype

29:15.920 --> 29:21.200
animal. It's quite straightforward, actually. And I think the best way to think about it is how

29:21.200 --> 29:27.200
Robert C. Martin put said subtypes must be substitutable for their base types. So now let's

29:27.200 --> 29:32.960
get to the demo that Joshua Block has used in the book. There are many classes to go through,

29:33.760 --> 29:40.560
but let's start off with the point class. So here's what Joshua Block states. Consider the case

29:40.560 --> 29:47.360
of a subclass that adds a new value component to its superclass. In other words, the subclass

29:47.360 --> 29:53.600
adds a piece of information that affects the equals comparison. What we have here is this

29:54.560 --> 29:58.880
public class. This class is going to be the superclass that we're going to use. It's a concrete

29:58.880 --> 30:06.000
class. Keep that in mind, because the idea or the juxtaposition of a concrete class with a

30:06.000 --> 30:10.640
abstract class, that's something we're going to catch on later on in this part. So we have the

30:10.640 --> 30:17.760
concrete class point, which is simply an immutable two dimensional integer point class. We've got x

30:17.760 --> 30:23.200
and y privately defined, we have constructor, and then you have an equals method, which just the

30:23.200 --> 30:28.400
equality. Similar to what we discussed in the previous example with symmetry, checks if it's

30:28.400 --> 30:34.080
an instance, and then returns true if there's equality. Now let's suppose that we want to

30:34.080 --> 30:39.680
enhance the ability of the point class. Therefore, we subclass it and we have this color point class

30:39.680 --> 30:45.840
that extends the point class, and it attempts to add a value component to point. In this case, it's

30:46.800 --> 30:52.880
the value component of color. We want the points to also have color. Now what would

30:53.680 --> 30:59.600
this class look like? Or more importantly, what would the equals method look like for the color

30:59.600 --> 31:06.640
point class? That is a subclass of point. In this case, we have a normal constructor. We have line

31:06.640 --> 31:11.920
number 14 that invokes the constructor in the superclass. That's what this super keyword does,

31:11.920 --> 31:17.520
and we can do that for x and y, those coordinates. But here, since we're introducing this value

31:17.520 --> 31:22.320
component, we want to initialize the color component to when constructing the object.

31:24.080 --> 31:31.520
But then we come to the equals method that clearly violates the symmetry of the

31:31.520 --> 31:35.600
symmetry principle or the symmetry properties. Well, for starters, of course, we can't use the

31:36.560 --> 31:41.680
equals method from the superclass because the superclass did not even have a color field.

31:42.240 --> 31:47.760
Therefore, it would break the idea of logical equality if we just inherit that method. Therefore,

31:47.760 --> 31:53.600
we need to override the equals method in the subclass color point. But in this equals method,

31:53.600 --> 31:58.240
it violates symmetry because, yes, we're invoking the equals method in the superclass,

31:58.240 --> 32:03.600
and then we're even doing a check for the color point equality here by casting

32:04.320 --> 32:08.560
that object the color point type. Because if it is an instance, in that case,

32:10.080 --> 32:17.520
oh, yes, because if it's not an instance, it'll return false. But it's a one-way comparison. So

32:17.520 --> 32:24.720
if you look at the implementation or a client using it, and if I run this, you'll see the

32:24.720 --> 32:29.920
first comparison will return true because that's fine. We're comparing point and we're passing

32:29.920 --> 32:35.040
the color point object, that's okay. But the second one will return false because in this case,

32:35.040 --> 32:40.640
we are typing or we are passing the supertype object. So it's a clear violation of symmetry.

32:41.280 --> 32:49.040
And that's why Joshua Bloch states, the problem with this method and what he means by this method

32:49.040 --> 32:55.840
is this implementation of the overrides method we have here is that you might get

32:55.840 --> 33:00.480
different results when comparing a point to a color point and vice versa.

33:01.280 --> 33:06.480
The former comparison ignores color while the latter comparison always returns false

33:07.200 --> 33:13.120
because the type of the argument is incorrect. So what he means by the former comparison ignores

33:13.120 --> 33:21.440
color is that in this ampersand, the end statement here, that's the former comparison

33:21.440 --> 33:29.440
where it's simply invoking the equals method in the superclass and it's doing a basic equality test.

33:29.440 --> 33:36.160
But in that equality test, we are ignoring color completely. So it'll return true if it is an object

33:36.160 --> 33:41.600
of proper type. And that, again, doesn't give us what we want. It breaks logical equality.

33:41.600 --> 33:46.720
And in the second one, the problem is it'll never even get to the second one because we check if

33:46.720 --> 33:51.680
this object is an instance of color point. And if it's not, it'll always return false.

33:51.680 --> 33:59.280
Therefore, whenever we pass anything that's not of type color point, it'll return false.

34:00.000 --> 34:04.400
And that also violates not only symmetry, but even the less substitution principle.

34:04.400 --> 34:07.520
So then we're trying to fix this. What we're trying to fix this is we're trying to

34:07.520 --> 34:13.200
resolve this issue with violating symmetry. And that fix also unfortunately doesn't work

34:13.200 --> 34:20.560
because it violates the transitivity property and we shall see what that fix looks like.

34:20.560 --> 34:25.840
So by trying to fix the issue with symmetry, we unfortunately violate transitivity.

34:25.840 --> 34:32.400
In this case, in this new equals method that we overrode, we in fact are considering objects that

34:32.400 --> 34:36.960
are of a different type to color point. We're checking if initially if it's a normal point,

34:36.960 --> 34:42.800
if it's a normal point, we're doing a color blind comparison. Great. And if it's a color

34:42.800 --> 34:47.120
point, then like the previous one, we consider color and then do a comparison. And

34:47.760 --> 34:53.280
absolutely if it's not an instance of either point or color point, it'll just return false.

34:53.920 --> 35:00.000
So in this case, symmetry ticked. However, unfortunately, as we shall see from the

35:00.000 --> 35:10.080
implementation, it does violate transitivity. So in this comparison, we have three objects.

35:10.080 --> 35:17.520
We have two color point objects and a point object. So in the P1 equals P2 comparison,

35:17.520 --> 35:25.600
that's fine. It returns true. Also in the P2 equals P3 comparison, that also returns true.

35:25.600 --> 35:32.240
However, then comes the transitivity issue in the P1 equals P3 comparison, it returns false.

35:34.320 --> 35:38.720
I totally got the wrong. I read that as if that's what was expected. In fact,

35:38.720 --> 35:43.200
that was not what's expected because there's no logical equality there. We're trying to compare

35:44.320 --> 35:51.440
P1 with P2 and it's returning true. It should return false because obviously P1 has that added

35:51.440 --> 35:56.880
value component of color and P2 doesn't have that. So that's wrong. It shouldn't return true.

35:56.880 --> 36:01.520
And it shouldn't in the second comparison, where we compare again, a point and a color point,

36:01.520 --> 36:07.360
it's returning true again, it shouldn't. And okay, the third one's fine because the third one,

36:08.080 --> 36:14.240
it's doing a proper comparison between P1 and P3, which are both type of color point.

36:14.800 --> 36:19.280
And it's returning false, which is expected because the color is different. That's okay,

36:19.280 --> 36:23.840
but these two are a problem. So which is why Joshua Bloch states,

36:25.360 --> 36:33.040
this approach just provides symmetry, but at the expense. So I don't think I read the previous bit.

36:33.040 --> 36:40.000
So just to add on to what he was saying about the override method, he says, this method here,

36:41.200 --> 36:46.640
he says, you might try to fix the problem by having color point or equals ignore color

36:46.640 --> 36:51.600
when doing mixed comparisons. And that's what we're doing in this condition here,

36:51.600 --> 36:56.960
where we're doing a color blind comparison by using the instance of method. So even a point

36:56.960 --> 37:06.000
can be passed on to this object of type point. And then he continues, now, so what we discussed

37:06.000 --> 37:14.400
here before, now P1 equals P2 when P2 equals P3 returns true, where it shouldn't, while P1 equals

37:14.400 --> 37:21.360
P3 returns false, a clear violation of transitivity. The first two comparisons are color blind,

37:21.360 --> 37:26.320
while the third takes color into account, and that shouldn't be the case. So what do we do here?

37:26.320 --> 37:34.320
We've got this huge object oriented predicament, or for us programmers, even a existential crisis,

37:34.320 --> 37:40.240
what are we going to do? What's the solution? He says, it turns out that this is a fundamental

37:40.240 --> 37:44.960
problem of equivalence relations in object oriented languages. This is kind of what I said before.

37:45.680 --> 37:52.960
There's no way to extend an insensiable, insensiable class and add a value component

37:52.960 --> 38:00.080
while preserving the equals contract. The problem again, the big problem is in our design, where

38:00.080 --> 38:07.840
we may point a concrete class. And we shall see why it should have been made a abstract class instead.

38:07.840 --> 38:14.480
But later, sorry, I'm getting a bit carried away. Let's stay on track. Again, re-reading that point

38:14.480 --> 38:21.520
because it's important. There's no way to extend an insensiable class, insensiable class and add

38:21.520 --> 38:27.840
a value component while preserving the equals contract, unless you're willing to forego the

38:27.840 --> 38:33.680
benefits of object oriented abstraction. And then Joshua Block states that we might try to circumvent

38:33.680 --> 38:41.280
this issue in a bit of a sly way by trying to use Java's reflexive API or reflections API. In any

38:41.280 --> 38:47.280
case, it's changing the class on runtime, which is what I tried to demonstrate with the second

38:47.680 --> 38:53.680
equals method, which we think would work. So if I do, whoops, I shouldn't have clicked that.

38:53.680 --> 38:56.720
If I do look at this equals method, I'll comment this out.

38:59.120 --> 39:05.840
We're using the dot get class method from the Reflections API. Okay, before we get to that,

39:05.840 --> 39:12.560
let me quickly read out some theory. What is get class in Java? Again, according to chat GPT,

39:13.520 --> 39:20.000
here's what get class is. In Java, the get class method is a method of the object class that

39:20.000 --> 39:26.400
returns the runtime class of an object. Correct. It returns an object of type class, which is a

39:26.400 --> 39:32.640
class in the Java reflection API that represents a class or interface in the Java programming

39:32.640 --> 39:39.360
language. This in fact is very accurate, which is amazing because if you look at the Oracle docs

39:39.360 --> 39:48.800
and whatnot, chat GPT puts it in a more simpler way to understand. An example would be here,

39:48.800 --> 39:57.920
if we have this employee class or the employee object of type employee, if we go and they have

39:57.920 --> 40:04.800
another class, which we get, we get the class of employee and save it. We don't even really have

40:04.800 --> 40:10.080
to do this. We could just go employee dot get class really. We could just skip this step and go

40:10.080 --> 40:22.880
employee dot get class dot get name. And then return the name of the class. And that's done runtime

40:22.880 --> 40:29.040
by getting the type of the object. So we're trying to circumvent this issue by using the Reflections

40:29.040 --> 40:38.640
API, where we're saying only if it's a type of the implementation of that object. So we're checking

40:38.640 --> 40:45.280
the class of the object we pass on to the equals method, and then we're checking the class of the

40:45.280 --> 40:51.680
current object's runtime. So we're comparing two objects here, the object of this class,

40:52.400 --> 40:56.080
the broader class, and then the object we are passing on to the equals method,

40:56.080 --> 41:00.560
and then we're doing the comparison. Unfortunately, this is not going to work,

41:00.560 --> 41:05.360
because it violates the less-carved substitution principle and breaks logical equality, which is

41:05.360 --> 41:12.880
why Joshua Block states, this effect has the effect of equating objects only if they have

41:12.880 --> 41:17.920
the same implementation class. So which is why we're checking here for the type of the implementation

41:17.920 --> 41:25.520
class. This may not seem so bad, but the consequences are unacceptable. An instance of a subclass

41:25.600 --> 41:33.760
of point is still a point. So an instance of point, for example, like call point is still a point,

41:33.760 --> 41:40.640
and it should work with this equals method, but it doesn't. And it still needs to function as one,

41:40.640 --> 41:45.440
but it fails to do so if you take this approach. Now let's take a look at an example where we're

41:45.440 --> 41:52.960
trying to tell whether a point is on the unit circle. Here's an example. So what this counterpoint

41:52.960 --> 42:00.800
test is trying to do is to see if this is a point. This point class is a point on a unit circle.

42:00.800 --> 42:08.560
We're creating a set of type point, and we're adding some points into it. And then we have this

42:08.560 --> 42:16.160
public static Boolean, which returns a true false, that checks if this point is a point on a circle.

42:17.040 --> 42:23.520
And we're doing that by returning true if whatever point that we pass on to this method

42:24.640 --> 42:31.280
is contained in this set, the unit circle set. Initially here, it'll print true. It'll print

42:31.280 --> 42:38.560
true because it's of type point. But because our point class, we use the reflections API and used

42:39.360 --> 42:48.480
get class. When we pass something, a subtype of kind of point, which again, if it did respect

42:48.480 --> 42:54.480
or follow the less curve substitution principle, it should still print true because it's still

42:54.480 --> 43:01.600
a type of point and it should behave as such. It'll print false, unfortunately. There we go.

43:01.600 --> 43:06.160
In the second one, it's printing false. And this is a clear violation of the principle.

43:06.960 --> 43:12.080
Therefore, using get class and the reflections API is still not the way to circumvent this issue

43:12.080 --> 43:16.800
with object oriented languages. So again, I know we discussed the less curve

43:16.800 --> 43:20.800
substitution principle before, but in the book Joshua Block states the less curve

43:20.800 --> 43:27.680
substitution principle says that any important property of a type should also hold for all its

43:27.680 --> 43:34.880
subtypes so that any method written for the type should work equally well on its subtypes.

43:35.840 --> 43:44.000
And this is the formal statement of our earlier claim that a subclass of point, such as counterpoint,

43:44.960 --> 43:51.440
is still a point and must act as one. Now let's take a look at the problem with this. I mean,

43:51.440 --> 43:56.400
let's take a look at not the problem with the less curve substitution principle, but the problem

43:56.400 --> 44:01.920
with not following this principle. So we have this trivial class here that really does nothing.

44:02.000 --> 44:08.400
It doesn't really add a value component. It simply keeps track of how many instances of,

44:08.400 --> 44:14.160
of, it's called counterpoint, which keeps track of how many instances of point are created. If you

44:14.160 --> 44:20.000
don't know an atomic integer is a thread safe counter, a variable which you can increase.

44:20.800 --> 44:26.560
So simply every time an instance of counterpoint is created, we also we're invoking even the

44:27.520 --> 44:33.760
the super class, the point in this case, and then we can get account of how many instances of

44:33.760 --> 44:40.160
point were created because of this atomic counter. So again, counterpoint is a subtype of point.

44:40.160 --> 44:45.040
Apologies, I demoed this bit a bit earlier before, and I think I used the word color

44:45.040 --> 44:49.680
point by mistake. I think I should have said counterpoint. It's just both counterpoint and

44:49.680 --> 44:57.040
color point are subtypes of point. But as you saw before, it also returned faults,

44:57.760 --> 45:02.480
because we've got a problem with, we haven't got a problem with, sorry, I was going to say we've

45:02.480 --> 45:07.840
got a problem with the, with the contains method. The contains method exactly behaves the way it's

45:07.840 --> 45:12.960
supposed to, but we have a, we have a violation of the less curve substitution principle, which

45:12.960 --> 45:19.200
is why it's training faults. Again, I apologize if I confused you by stating color point, I meant

45:19.200 --> 45:24.400
to say counterpoint, which is this class that this is a, this is a useless class really. It just

45:25.040 --> 45:31.360
invokes the constructor in the superclass point and then keeps track of how many

45:32.240 --> 45:39.920
objects of point have been created. But why, so the question of course is why do we get this

45:39.920 --> 45:46.560
second false here, despite counterpoint being a subtype of point, it is because of this.

45:46.800 --> 45:55.040
Because most collections, so set is a collection here of type point, including the hash set that

45:55.040 --> 46:02.080
we used here by the own unit circle method, use the equals method to test for containment.

46:02.720 --> 46:08.720
And no kind of point instance is equal, equal to any point. And why is that? That is because,

46:08.720 --> 46:16.800
as I said before, we're using get class here. And if, if counterpoint is not of type point,

46:16.800 --> 46:22.560
we aren't gonna, it's going to return faults. So therefore, that's why we get a false here too,

46:23.200 --> 46:28.800
which the, sorry, it's a wrong one. We get a false here too, which the contains method uses the

46:28.800 --> 46:38.160
equals method in the object, in the point object. And that's why Joshua Bloch states, if however,

46:38.160 --> 46:45.120
you use a proper instance of base equals method on point, the same onion cycles circle method

46:45.120 --> 46:49.120
works fine when presented with a counterpoint instance. And let's take a look at that.

46:51.680 --> 47:00.400
So on point, instead of using this equals method that uses get class, if we go back to the previous

47:00.400 --> 47:10.080
one that uses instance of, because instance of does consider even subtypes. And if we run this

47:10.080 --> 47:17.200
again, we'll get two truths. So in that case, it's behaving as expected. So unfortunately,

47:17.200 --> 47:23.440
there's no way getting around this, we should all give up programming. And just quit quit because

47:23.440 --> 47:29.120
life is meaningless. Everything is futile. I'm kidding. I'm kidding. I'm kidding. Life is meaningless

47:29.120 --> 47:36.160
and everything is futile. But in true Nietzschean essence, we ought to create our own meaning,

47:37.360 --> 47:43.920
which is why we're going to use the good old object oriented principle and favor

47:44.720 --> 47:50.560
composition over inheritance to circumvent this issue with which is inherent to object

47:50.560 --> 47:56.720
oriented languages. So let's take a look at this example, a class color point where we don't do

47:56.720 --> 48:03.760
any kind of extension or any kind of inheritance, we're in fact using composition. So in this new

48:03.760 --> 48:08.560
color point, which don't get this confused to the one that we use for inheritance, as you can see

48:08.560 --> 48:14.320
from the package, this is in a separate package called composition. But in this new color point that

48:14.320 --> 48:23.600
uses composition, we have a instance of point defined. And we have an instance of color, which

48:23.600 --> 48:31.280
this is a enum, by the way, that holds some some colors. And we have these two instances defined.

48:31.280 --> 48:38.240
And then in our constructor, we have a new instance of point being created. And we assign that,

48:38.240 --> 48:43.920
of course, to the private private field in our class, we do the same thing with color,

48:44.640 --> 48:51.360
new instance. Sorry, in this case, we don't create a new instance of color, we expect the client to

48:51.360 --> 49:01.600
pass us a proper object of type color. And then we return the point of this color point, just

49:01.600 --> 49:06.160
this again, what the client expects. And then the equals method, because we is in composition,

49:06.160 --> 49:11.520
it's not an issue, we just check if it's an instance of color point. And then we do the

49:11.520 --> 49:16.240
casting accordingly, if it is an instance of color point, the object we pass onto the equals method,

49:16.960 --> 49:22.480
then we do a proper comparison, where we do both the comparison between

49:23.680 --> 49:27.120
between the type point of color point, because this we get from

49:30.000 --> 49:37.200
here. And also a comparison between color. So the color has to be true, and the point has to be

49:37.200 --> 49:44.560
true. And if they both are fulfilled by the double ampersand and operator, it returns true.

49:44.640 --> 49:49.200
And that solves a problem. So if you look at this test class, for instance, I'm going to run this

49:49.200 --> 49:53.680
test class, I've done something really ugly here. In one file, I've defined two classes,

49:53.680 --> 49:59.840
you should never do that. In fact, there's one item where Joshua Block talks about that later on.

50:00.560 --> 50:07.840
It's bad programming etiquette. So in the counterpoint test, again, I've screwed this up,

50:07.840 --> 50:14.160
it should be color point test. This is a bit confusing, I apologize. In the color point test,

50:14.560 --> 50:20.320
we've similarly have a hash set that we've created of type point. And then we're doing

50:20.320 --> 50:25.840
the same thing we did in the previous test, we're checking if the point we pass contains

50:25.840 --> 50:32.240
this object P in this hash set. And then if you run this, the difference here though is firstly,

50:32.240 --> 50:37.840
if I run this, you'll see they both print true. That's because we're using composition.

50:39.040 --> 50:43.600
And what it does is though, when we are adding it, when we're adding a new color point, we do use

50:43.600 --> 50:51.840
this additional method saying add this, however, as a point though. So that changes things because

50:51.840 --> 50:57.200
now we're saying it's still, we're still adding something of type color point, but we're using

50:57.200 --> 51:03.120
this method here, which adds as a point. And it returns that point that we've defined here,

51:03.760 --> 51:08.560
which is what we do in the constructor. And even though we still have this value color

51:09.520 --> 51:16.960
in this private field here, which we can use. So that's how we circumvent the issue.

51:16.960 --> 51:22.480
Interestingly, Joshua Bloch states that there has been historical errors where, for instance,

51:22.480 --> 51:29.840
in the date and the SQL timestamp classes, so in the utilities and the SQL packages,

51:31.200 --> 51:35.600
they've made the mistake of use having implementations of the equals method

51:36.320 --> 51:42.960
that violate symmetry and that this causes erratic behavior. And he says the equals

51:42.960 --> 51:48.160
implementation for timestamp does violate symmetry and can cause erratic behavior if

51:48.160 --> 51:54.960
timestamp and date objects are used in the same collection or otherwise intermixed.

51:54.960 --> 51:59.760
This behavior of the timestamp class was a mistake and should not be emulated. So again,

51:59.760 --> 52:05.280
it's because of the inherent drawback in object oriented languages, these kind of mistakes happen.

52:05.280 --> 52:14.000
However, in many circumstances, using composition over inheritance, the way we

52:14.000 --> 52:18.880
showed in the composition-paste color point class is a way of getting around that.

52:20.000 --> 52:26.560
And then we get to the interesting idea or the interesting notion of using an abstract class

52:26.560 --> 52:32.240
instead of a superclass. And simply, the reason we can add value components to a subclass of an

52:32.240 --> 52:37.360
abstract class is that you can't instantiate an abstract class. So that really solves a lot of

52:37.360 --> 52:44.720
the problems we have with using the concrete point superclass. So in this case, we have an

52:44.720 --> 52:50.080
abstract class shape, which has two protected values, so x and y, and we have a constructor,

52:50.080 --> 52:59.120
and then we have two concrete subclasses that extend the shape class. And we've got circle and

53:00.080 --> 53:07.200
rectangle, where's the other one? Yeah, circle and rectangle, where in the circle one, we are

53:07.200 --> 53:14.160
adding a radius, and in the rectangle one, we are adding length and width. And in the constructor,

53:14.160 --> 53:20.880
of course, we are invoking the constructor of the superclass, which is shape. The issue is

53:20.880 --> 53:26.400
quite straightforward. We can create a concrete object of this concrete class rectangle. However,

53:26.400 --> 53:34.240
if you try to, that's a typo, try to instantiate the shape class, it says you get a compile time

53:34.240 --> 53:40.880
error, say you can't instantiate abstract shape classes, which is why this is a way to get around

53:40.880 --> 53:49.520
this issue, where Joshua Bloch states, when adding a value component, note that you can add a value

53:49.520 --> 53:55.440
component to a subclass of an abstract class without violating the equals contract. This is

53:55.440 --> 54:01.840
important for this sort of class hierarchies that you get by following the advice in item 23,

54:01.840 --> 54:07.280
preferred class hierarchies to tack classes. I'm not going to go into too much detail on that,

54:07.280 --> 54:12.720
because we're going to be covering item 23 next year. And then he says, for example,

54:12.720 --> 54:16.800
he could have an abstract class, so what I pretty much described here, I'll just read it out again.

54:16.800 --> 54:22.720
For example, he could have an abstract class shape with no value components, a subclass circle,

54:22.720 --> 54:30.080
that adds a radius field and a subclass rectangle that adds a length and width fields.

54:31.200 --> 54:38.000
Problem of the sort shown earlier won't occur so long as it is impossible to create a super

54:38.000 --> 54:46.800
class instance directly. That's it. That is the property of transitivity as to how we try and

54:46.800 --> 54:53.520
follow it to ensure that we follow the, or we abide by the general contract of the equals method,

54:54.160 --> 55:02.320
and even discussing the inherent problems with OP languages. But saying that, there are also two

55:02.320 --> 55:10.080
other properties that we need to follow, which is consistency and non-nullity. There are a lot

55:10.080 --> 55:14.960
more shorter than this one, but I'm quite tired. So we're going to cover that in part three.

55:16.800 --> 55:23.920
But I hope this made sense. I was from my best to get this across. I found this quite interesting,

55:23.920 --> 55:30.560
though. I really enjoyed this transitivity bit. So I shall see you in the next one.

55:30.560 --> 55:34.400
Thanks for watching, and I hope you gain some value from it. Cheers.

