1
00:00:00,000 --> 00:00:07,800
Hey everyone, welcome to part 4, the final part of item 10 in Joshua Block's Effective

2
00:00:07,800 --> 00:00:08,800
Java.

3
00:00:08,800 --> 00:00:15,280
Item 10, as if you've been folding along in the previous parts, is obey the general contract

4
00:00:15,280 --> 00:00:17,600
when overriding equals.

5
00:00:17,600 --> 00:00:23,080
And I'm very excited, and so is the dog barking outside when I decided to record a video.

6
00:00:23,080 --> 00:00:26,840
But I'm very excited because finally, man, this was a really long item.

7
00:00:26,840 --> 00:00:32,880
It's taken me a whole month to get across this item, also because I've been procrastinating.

8
00:00:32,880 --> 00:00:38,880
In any case, this is really good because all the stuff that we've learned in this item,

9
00:00:38,880 --> 00:00:44,280
what to do, what not to do, we're going to put it all together in this final item and

10
00:00:44,280 --> 00:00:51,040
create a high-quality equals method, or as Joshua Block would say, it's the recipe for

11
00:00:51,040 --> 00:00:53,600
a high-quality equals method.

12
00:00:53,600 --> 00:00:56,760
So without further ado, let's get started.

13
00:00:56,760 --> 00:01:01,600
There are a few points that he's laid down on what to do when it comes to designing equals

14
00:01:01,600 --> 00:01:02,600
methods.

15
00:01:02,600 --> 00:01:04,600
The first one is quite straightforward.

16
00:01:04,600 --> 00:01:11,440
It is to use the double equals operator to check if the argument is a reference to an

17
00:01:11,440 --> 00:01:12,440
object.

18
00:01:12,440 --> 00:01:17,800
So with the argument or whatever we are passing onto the equals method, if we use a double

19
00:01:17,800 --> 00:01:23,200
equals operator, we can confirm if it's a memory reference.

20
00:01:23,200 --> 00:01:27,160
So if you're passing the same object, let's say, then obviously it's going to return true.

21
00:01:27,160 --> 00:01:33,760
As you can see in this really quite straightforward example, we have two strings and keep in mind

22
00:01:33,760 --> 00:01:38,520
objects of string, of string class, are immutable.

23
00:01:38,520 --> 00:01:47,800
And in this case, the first if condition will return true because both this new string,

24
00:01:47,800 --> 00:01:53,000
I'm sorry, as I was staring into the code there, I realized I explained that wrongly.

25
00:01:53,000 --> 00:01:56,640
Firstly, the caveat is this is a anti-pattern.

26
00:01:56,640 --> 00:02:01,440
You should never declare strings like this because the new keyword creates a new object

27
00:02:01,440 --> 00:02:02,640
in memory.

28
00:02:02,640 --> 00:02:07,120
That's not required because as I said, string is immutable.

29
00:02:07,120 --> 00:02:13,280
So here, when we compare string one to string two using the equals operator, this will in

30
00:02:13,280 --> 00:02:15,200
fact say that they're not equal.

31
00:02:15,200 --> 00:02:18,480
So this will say they're not in the same memory location.

32
00:02:18,480 --> 00:02:23,160
But if you use the equals keyword, it's going to say they're in, sorry, it's going to say

33
00:02:23,160 --> 00:02:28,400
that they have the same content or that there's logical equality as we've discussed throughout

34
00:02:28,400 --> 00:02:29,840
this item.

35
00:02:29,840 --> 00:02:35,920
So but when it comes to designing our own equals method, the reason that we should first check

36
00:02:35,920 --> 00:02:41,160
using the equals operator, if it's referring to the same object is because if it is, we

37
00:02:41,160 --> 00:02:46,360
just save time, we save computation time instantly, we can return true or false.

38
00:02:46,440 --> 00:02:53,320
Not false, but we could certainly return true if it is equal to the, if the memory reference

39
00:02:53,320 --> 00:02:56,320
is equal using the double equals operator.

40
00:02:56,320 --> 00:03:02,960
And Joshua Block states, yeah, so if so returns true, this is just a performance optimization,

41
00:03:02,960 --> 00:03:07,160
but one that is worth doing if the comparison is potentially expensive.

42
00:03:07,160 --> 00:03:11,560
So if it's not equal, there may be a lot more other checks we need to do in order to have

43
00:03:11,560 --> 00:03:16,520
a good quality equals method, but if it's the same memory reference, just return true.

44
00:03:16,520 --> 00:03:17,520
I'm sorry.

45
00:03:17,520 --> 00:03:21,320
I know I kind of exhausted that point, but it's important to understand why we do that

46
00:03:21,320 --> 00:03:23,160
check initially.

47
00:03:23,160 --> 00:03:28,280
The second one is to check if the, if it's an instance of the correct type.

48
00:03:28,280 --> 00:03:32,360
And firstly, if it's not straight away return false, because if they're going to be two

49
00:03:32,360 --> 00:03:37,480
different types, then there's no logical equality to start with, which is why Joshua

50
00:03:37,480 --> 00:03:43,720
Block states in the second part of putting together this recipe, use the instance of

51
00:03:43,720 --> 00:03:48,400
operator to check if the argument has the correct type.

52
00:03:48,400 --> 00:03:49,640
So what does that mean?

53
00:03:49,640 --> 00:03:53,960
What that means is before I read out what he stated, in fact, maybe I should first read

54
00:03:53,960 --> 00:03:54,960
out.

55
00:03:54,960 --> 00:03:56,880
No, no, no, I'll show this example.

56
00:03:56,880 --> 00:04:01,160
And then before we get to the Java collections framework set example, I'll read out what

57
00:04:01,160 --> 00:04:02,160
he stated.

58
00:04:02,160 --> 00:04:06,920
So we've defined a type, we've defined my interface and we have a class that implements

59
00:04:06,920 --> 00:04:07,920
my interface.

60
00:04:07,920 --> 00:04:13,160
So now this class, my class is of type, my interface.

61
00:04:13,160 --> 00:04:18,600
And then in the equals method, the first thing we are checking is we're first checking, yeah,

62
00:04:18,600 --> 00:04:22,480
we're doing the reference equality, so the memory reference equality, which is what we

63
00:04:22,480 --> 00:04:27,600
discussed in the first part here, or the first section, let's say.

64
00:04:27,600 --> 00:04:32,680
And if it is straight away return true, no need to execute the rest of this code.

65
00:04:32,680 --> 00:04:36,320
But if it's not an instance of my interface.

66
00:04:36,320 --> 00:04:43,120
So whatever object we pass, let me just see if this is that's zoom in a little bit.

67
00:04:43,120 --> 00:04:44,680
There we go.

68
00:04:44,680 --> 00:04:50,320
Whatever object that we pass into the equals method, if it's not an instance of that broader

69
00:04:50,320 --> 00:04:56,640
class or of a type, sorry, of that broader class, then return false.

70
00:04:56,640 --> 00:05:01,160
So in that sense, we save time and only if it is, we get on with the rest of the equals

71
00:05:01,160 --> 00:05:04,280
method to check if there's logical equality.

72
00:05:04,280 --> 00:05:08,800
And that's why Joshua Block states typically the correct type is the class in which the

73
00:05:08,800 --> 00:05:10,800
method occurs.

74
00:05:10,800 --> 00:05:13,560
But if there's an interface like you've seen here, you can implement it.

75
00:05:13,560 --> 00:05:18,480
And that's why he says use an interface if the class implements an interface that refines

76
00:05:18,480 --> 00:05:24,840
the equals contract to permit comparisons across classes that implement the interface.

77
00:05:24,840 --> 00:05:31,200
So what we're checking here in this equals method is not if the object be pass is an

78
00:05:31,200 --> 00:05:38,400
instance of my class rather we're using the interface as a type, as you can see here.

79
00:05:38,400 --> 00:05:44,840
So in that way, this equals method theoretically can be used across other classes, or at least

80
00:05:44,840 --> 00:05:50,160
this part of the equals method can be used across other classes that implement the mind

81
00:05:50,160 --> 00:05:51,560
to face type.

82
00:05:51,560 --> 00:05:56,520
And as an example, he's used a the collections framework, the collections interface or the

83
00:05:56,840 --> 00:06:03,520
collection interface, such as set list map and map entry have this property.

84
00:06:03,520 --> 00:06:09,440
So we have this interface that extends the collection generic interface with this is

85
00:06:09,440 --> 00:06:14,320
a generic parameter or a generic type.

86
00:06:14,320 --> 00:06:19,880
And what that does is when we have my set, when we define a new set that implements this

87
00:06:19,880 --> 00:06:26,440
set interface that we've declared here, oops, I will declare here.

88
00:06:26,440 --> 00:06:30,880
In the equals method, as you saw from the previous example, it's the same thing that

89
00:06:30,880 --> 00:06:35,920
checking if it's an instance of that set interface type.

90
00:06:35,920 --> 00:06:40,520
And only if so, we get to the rest of the equals method, if not, we straight away return

91
00:06:40,520 --> 00:06:41,520
faults.

92
00:06:41,520 --> 00:06:46,120
And then the third section of this is, as you've seen in the myriad equals methods that

93
00:06:46,120 --> 00:06:52,560
we've used throughout this item is to cast the argument to the correct type.

94
00:06:52,560 --> 00:06:58,280
So just your block states cast argument to the correct type, because this cast was preceded

95
00:06:58,280 --> 00:07:02,440
by an interface of test, it is guaranteed to succeed.

96
00:07:02,440 --> 00:07:11,040
So we're passing in the equals method, when we do this check here, sorry, when we do the

97
00:07:11,040 --> 00:07:16,680
check here, this ensures that we can do this cast safely without something like a class

98
00:07:16,680 --> 00:07:21,880
cast exception error, because we are checking if it's of the same type, or at least if this

99
00:07:21,880 --> 00:07:25,400
object is of instance of string.

100
00:07:25,400 --> 00:07:31,160
And in this case, in fact, because it's not an instance of string, it will not do the

101
00:07:31,160 --> 00:07:34,200
casting, it'll move on to do something else.

102
00:07:34,200 --> 00:07:42,800
So if we pass some other object apart, other than let's say what we have here, or actually

103
00:07:42,800 --> 00:07:47,200
sorry, in this case, because we've declared this to be an object is this will go through

104
00:07:47,200 --> 00:07:54,120
I apologize, I realized that the type of object is still sorry, the type of OBJ is still off

105
00:07:54,120 --> 00:07:59,560
type object, which is an instance of string, which is a super type to the string class.

106
00:07:59,560 --> 00:08:02,040
So it'll do the casting here safely.

107
00:08:02,040 --> 00:08:05,320
That's what I was trying to say, that was a bad view of explaining it, but you get the

108
00:08:05,320 --> 00:08:11,120
point because we've done this test here, the casting should work fine.

109
00:08:11,120 --> 00:08:17,440
Okay, now we get to the fourth section, the final part of this recipe.

110
00:08:17,440 --> 00:08:23,680
And this really is most of what part four in this video series is about, because it's

111
00:08:23,680 --> 00:08:29,800
really the biggest part when it comes to designing a good high quality equals method.

112
00:08:29,800 --> 00:08:35,920
And that is that for each significant field in the class, check if that field of the argument

113
00:08:35,920 --> 00:08:39,320
matches the corresponding field of this object.

114
00:08:39,320 --> 00:08:45,040
Now before we get to the definitions defined by man, this dog really is annoying me.

115
00:08:45,040 --> 00:08:50,600
I apologize, I tried to reduce background noise when editing the video, but it is quite

116
00:08:50,600 --> 00:08:51,600
distracting.

117
00:08:51,600 --> 00:08:55,760
Anyway, getting back to this, getting back to this.

118
00:08:55,760 --> 00:09:02,800
So before I read the kind of formal definition in the book, let's quickly take a look at

119
00:09:02,800 --> 00:09:04,240
a demo that I put together.

120
00:09:04,240 --> 00:09:11,400
So what we have here, we have here a, I'm quite distracted today, I apologize, it's

121
00:09:11,400 --> 00:09:16,920
like a lot going on despite me living in a very quiet neighborhood.

122
00:09:16,920 --> 00:09:24,120
So what we have here is a class that I've called class person and it's got a private

123
00:09:24,120 --> 00:09:30,360
field string, a private field called string and of type int.

124
00:09:30,360 --> 00:09:33,520
So keep in mind that's a primitive type.

125
00:09:33,520 --> 00:09:39,600
Then we also have the equals method and then you'll first see, so in the equals method,

126
00:09:39,600 --> 00:09:45,080
as we discussed in the previous sections, we're doing first the memory reference check

127
00:09:45,080 --> 00:09:50,520
and then we're doing the instance of check that gets us across many things.

128
00:09:50,520 --> 00:09:55,080
It first tells us that here that these two are in fact two different objects.

129
00:09:55,080 --> 00:10:01,720
If it returns false and here it says, despite them being two different objects or having

130
00:10:01,720 --> 00:10:04,640
two different memory locations, they are of the same type.

131
00:10:04,640 --> 00:10:05,640
That's good.

132
00:10:05,640 --> 00:10:11,680
Now we get to the comparison and here really what this means is, as you can see, so after

133
00:10:11,680 --> 00:10:18,000
doing the casting, so the object that we get, we cast it to of type person, each significant

134
00:10:18,000 --> 00:10:23,560
field and that is, that really is something we need to think of in terms of logic, which

135
00:10:23,560 --> 00:10:30,560
is why initially in this item, we discussed concepts such as logical equality and equivalence

136
00:10:30,560 --> 00:10:36,840
relations because this call here, each significant field or each field that's significant is

137
00:10:36,840 --> 00:10:38,000
compared.

138
00:10:38,000 --> 00:10:42,120
That's a call that we as the designer of the equals method has to make.

139
00:10:42,120 --> 00:10:47,840
So obviously when we're comparing, let's say two people or two persons in this case, we've

140
00:10:47,840 --> 00:10:53,360
made the call that the name and the age are required for logical equality, which is why,

141
00:10:53,360 --> 00:11:00,680
if you look at line number 20, we're checking to see if both name and both age are equal

142
00:11:00,680 --> 00:11:06,400
and only if it's equal do we pass through and you probably can see here also, when it

143
00:11:06,400 --> 00:11:13,840
comes to age, I'm using a double equals operator, not the equals keyword because it's a primitive

144
00:11:13,840 --> 00:11:14,840
type.

145
00:11:14,840 --> 00:11:15,840
It's not an object.

146
00:11:15,840 --> 00:11:20,120
So accordingly, Joshua Block states, if the type in step two, which is the previous one

147
00:11:20,120 --> 00:11:31,560
we discussed, that is, yeah, the instance of check, if the type in step two is an interface,

148
00:11:31,560 --> 00:11:35,520
you must access the arguments fields via interface methods.

149
00:11:35,520 --> 00:11:40,080
If the type is a class, you may be able to access the fields directly depending on their

150
00:11:40,080 --> 00:11:41,840
accessibility.

151
00:11:41,840 --> 00:11:47,800
And then he says, for primitive fields, whose type is not float or double and we'll get

152
00:11:47,800 --> 00:11:54,640
into why that's the case, use the double equals operator for comparisons, which is what I've

153
00:11:54,640 --> 00:11:55,640
done here.

154
00:11:55,640 --> 00:11:57,960
As you can see, I already made that point.

155
00:11:57,960 --> 00:12:02,280
I apologize if I didn't too kind of over repeat points, but I think it's important, you know,

156
00:12:02,280 --> 00:12:08,400
repetition is the key to truly grogging concept.

157
00:12:08,400 --> 00:12:14,600
And we continue, for object reference fields, call the equals method recursively.

158
00:12:14,600 --> 00:12:19,840
For float fields, use the static float.compare method.

159
00:12:19,840 --> 00:12:23,440
And for double fields, use the double.compare method.

160
00:12:23,440 --> 00:12:24,440
So why is that?

161
00:12:24,440 --> 00:12:30,400
Why do we have to, why is there an exception for float or double fields in this case?

162
00:12:30,400 --> 00:12:32,200
The reason is because of auto boxing.

163
00:12:32,200 --> 00:12:37,080
However, before we get to that part, let's first look at a quick example of what all

164
00:12:37,080 --> 00:12:38,080
of this is.

165
00:12:38,080 --> 00:12:44,160
So here, we have a class called bank account, and we have three fields, three significant

166
00:12:44,160 --> 00:12:45,520
fields, keep in mind.

167
00:12:45,520 --> 00:12:47,920
We have the account number, which is a string.

168
00:12:47,920 --> 00:12:51,840
We have balance, which is of type double.

169
00:12:51,840 --> 00:12:54,120
And then we have a Boolean value called is active.

170
00:12:54,120 --> 00:12:56,520
So again, we're doing the checks here and equals method.

171
00:12:56,520 --> 00:13:02,920
We're doing the casting in line number 17, should I zoom in a bit, line number 17.

172
00:13:02,920 --> 00:13:07,760
And then when comparing the Boolean value because it's a primitive type, we're doing

173
00:13:08,440 --> 00:13:09,440
the equals operator.

174
00:13:09,440 --> 00:13:12,560
We're saying, if it's not equals, return false.

175
00:13:12,560 --> 00:13:18,640
And BA is, by the way, the other object that we've got here after the casting.

176
00:13:18,640 --> 00:13:25,520
And then in the account number, we're using the normal equals method that is in the object

177
00:13:25,520 --> 00:13:27,280
superclass.

178
00:13:27,280 --> 00:13:28,280
And that's fine.

179
00:13:28,280 --> 00:13:34,120
But here, as we've been advised by Joshua Block, we're using the double.compare static

180
00:13:34,120 --> 00:13:40,960
method instead of using the equals method, because, well, by the way, what this does

181
00:13:40,960 --> 00:13:42,840
is it returns a true or false.

182
00:13:42,840 --> 00:13:50,320
Sorry, I should put the proviso that it returns a true or false essentially or for all intents

183
00:13:50,320 --> 00:13:53,080
and purposes in our equals method, because it actually doesn't.

184
00:13:53,080 --> 00:13:57,880
It returns an int value if you look at the method, what it checks for if it's greater

185
00:13:57,880 --> 00:13:58,880
or less than.

186
00:13:58,880 --> 00:14:00,640
And accordingly, it'll return something.

187
00:14:00,640 --> 00:14:05,840
However, if it's not equal to zero, that means there's a difference.

188
00:14:05,840 --> 00:14:07,080
Therefore, it'll return false.

189
00:14:07,080 --> 00:14:13,160
But if it's as in the function of the return false, but if it's equal to zero, that means

190
00:14:13,160 --> 00:14:17,760
it's the same value or it's the same double value.

191
00:14:17,760 --> 00:14:21,560
Therefore, it'll just keep going and return true in the equals method.

192
00:14:21,560 --> 00:14:26,040
So what it looks for is a difference in the two parameters or the two values you pass

193
00:14:26,040 --> 00:14:28,560
to the double.compare function.

194
00:14:28,560 --> 00:14:33,880
But then to understand a bit more why it's better using this double.compare static method

195
00:14:33,880 --> 00:14:39,280
instead of using the double equals operator or the equals method, let's say, it's because

196
00:14:39,280 --> 00:14:46,640
of auto boxing, because if we do use the double equals operator for primitive fields that

197
00:14:46,640 --> 00:14:51,280
are float or double, an auto box will take place where the compiler will automatically

198
00:14:51,280 --> 00:14:57,960
convert these primitive types to the corresponding wrapper class types.

199
00:14:57,960 --> 00:14:58,960
And that is costly.

200
00:14:58,960 --> 00:15:06,840
That's very performance heavy or anti-performance to use a software engineering term.

201
00:15:06,840 --> 00:15:11,160
And that's why Joshua Block states, while you could compare float and double fields

202
00:15:11,160 --> 00:15:16,800
with the static methods float dot equals and double dot equals, this would entail auto

203
00:15:16,800 --> 00:15:21,040
boxing on every comparison, which would have poor performance.

204
00:15:21,040 --> 00:15:25,360
But auto boxing generally isn't a good idea, especially if you're using loops, keep away

205
00:15:25,360 --> 00:15:32,520
from auto boxing because it can be very performance heavy because also it just creates new objects

206
00:15:32,520 --> 00:15:33,600
every single time.

207
00:15:33,600 --> 00:15:41,600
So an example we have here is this int value of type, it's a primitive type.

208
00:15:41,600 --> 00:15:47,280
What auto boxing will do here is convert this int to the wrapper class integer and that's

209
00:15:47,280 --> 00:15:53,520
going to now be an object and any instance of that will create new objects in memory.

210
00:15:53,520 --> 00:15:58,200
And the compiler does that automatically for primitive and wrapper classes.

211
00:15:58,200 --> 00:16:05,880
So that's why it's better to use compare instead of using the equals method for float or double.

212
00:16:05,880 --> 00:16:11,320
And then kind of an ancillary point, a shunt's ancillary, it's still important.

213
00:16:11,320 --> 00:16:14,800
For array fields, apply these guidelines to each element.

214
00:16:14,800 --> 00:16:20,640
If every element in an array field is significant, use one of the array dot equals methods.

215
00:16:20,640 --> 00:16:25,040
And as we're deciding this method, one thing that could come into your mind is what if the

216
00:16:25,040 --> 00:16:29,240
object reference contains null, that is a very real possibility.

217
00:16:29,240 --> 00:16:34,120
So we want to avoid a null point of exception if that happens, if the object reference contains

218
00:16:34,120 --> 00:16:39,600
null and to avoid that, avoid the null point of exception, what we want to do for that

219
00:16:39,600 --> 00:16:44,920
is in fact, use the objects dot equals method where we compare two objects, which is in

220
00:16:44,920 --> 00:16:47,200
the Java util objects class.

221
00:16:47,200 --> 00:16:50,760
So if we take a look at another small demo, it's better looking at code than me trying

222
00:16:50,760 --> 00:16:51,760
to explain it.

223
00:16:51,760 --> 00:16:54,240
We have another class called person.

224
00:16:54,240 --> 00:16:59,760
And again, we have a name of type string, and then we have an age of the primitive

225
00:16:59,760 --> 00:17:00,760
type int.

226
00:17:00,760 --> 00:17:03,920
We have the constructor and then the equals method.

227
00:17:03,920 --> 00:17:09,440
So simply again, same thing, and we're doing the casting chain for the instance, the double

228
00:17:09,440 --> 00:17:11,720
equals operation, all of that.

229
00:17:11,720 --> 00:17:18,560
And then afterwards, in the comparison, we're comparing these significant fields.

230
00:17:18,560 --> 00:17:23,360
It could be possible that one of them could have a null, or in this case, what we pass

231
00:17:23,360 --> 00:17:27,400
this object, we pass onto the equals method.

232
00:17:27,400 --> 00:17:32,920
This object dot equals method will ensure that another point of exception is enthroned.

233
00:17:32,920 --> 00:17:36,960
And that's why when it comes to comparing the name, we are using objects dot equals.

234
00:17:36,960 --> 00:17:38,680
Did I say object dot equals?

235
00:17:38,680 --> 00:17:40,680
I meant to say objects dot equals.

236
00:17:40,680 --> 00:17:41,680
That's important.

237
00:17:41,680 --> 00:17:47,480
And the reason for that is instead of me explaining it, let me just use chatGPT to explain it

238
00:17:47,480 --> 00:17:49,760
better than I ever could.

239
00:17:49,760 --> 00:17:55,480
The object dot equals method is a utility method provided by the Java util objects class

240
00:17:55,480 --> 00:17:56,800
in Java.

241
00:17:56,800 --> 00:18:02,040
It can be used to compare the equality of two objects, taking into account that either

242
00:18:02,040 --> 00:18:04,480
or both objects can be null.

243
00:18:04,480 --> 00:18:05,480
And that's important.

244
00:18:05,480 --> 00:18:08,040
Like the null point exception isn't thrown.

245
00:18:08,040 --> 00:18:13,680
The method will return true if both objects are null, or if the objects are not null,

246
00:18:13,680 --> 00:18:18,360
and the equals method of the first object returns true when called with the second object

247
00:18:18,360 --> 00:18:19,360
as the argument.

248
00:18:19,360 --> 00:18:21,040
So the example for that is seen here.

249
00:18:21,040 --> 00:18:29,960
As you can see, we are passing a null value into person p4, and that returns false as

250
00:18:29,960 --> 00:18:34,160
expected because we're comparing p1 to p4.

251
00:18:34,160 --> 00:18:39,400
And in that comparison, it's clear that there is no logical equality here despite the age

252
00:18:39,400 --> 00:18:41,520
being the same.

253
00:18:41,520 --> 00:18:46,360
And there's also, more importantly, I guess, there's no null point exception being thrown.

254
00:18:46,360 --> 00:18:52,840
And then we get to this concept of canonicalization, which is the idea that in some classes a simple

255
00:18:52,840 --> 00:19:00,360
equality test won't do, especially as Joshua Bloch states for classes that are immutable.

256
00:19:00,360 --> 00:19:06,040
Meaning if an object of an immutable class can potentially change, for logical equality

257
00:19:06,040 --> 00:19:10,680
for or equals method to work properly, we still need to keep a canonical form of that

258
00:19:10,680 --> 00:19:14,680
field somewhere in our class, and we need to store it.

259
00:19:14,680 --> 00:19:17,840
So firstly, what is canonicalization?

260
00:19:17,840 --> 00:19:22,400
And a definition I found probably the best one I could find is really of Wikipedia.

261
00:19:22,440 --> 00:19:27,240
It's a computer science principle, and computer science, canonicalization, sometimes standardization

262
00:19:27,240 --> 00:19:34,440
or normalization, something you hear quite often when it comes to a databases, is a process

263
00:19:34,440 --> 00:19:40,160
for converting data that has more than one possible representation into a standard, normal

264
00:19:40,160 --> 00:19:41,640
or canonical form.

265
00:19:41,640 --> 00:19:47,080
You could probably see that itself hints to that idea that we want the data to exist

266
00:19:47,080 --> 00:19:50,440
in a consistent representation when doing the equality.

267
00:19:50,440 --> 00:19:53,640
And that's why we need to exist in a canonical form.

268
00:19:53,640 --> 00:19:58,760
This can be done to compare different representations by equivalence, like the equals method, to

269
00:19:58,760 --> 00:20:04,600
count the number of distinct data structures, to improve the efficiency of various algorithms

270
00:20:04,600 --> 00:20:10,560
by eliminating repeated calculations, or to make it possible to impose a meaningful sorting

271
00:20:10,560 --> 00:20:11,560
order.

272
00:20:11,560 --> 00:20:17,640
So clearly this CS principle of canonicalization has many uses.

273
00:20:17,640 --> 00:20:24,120
So we're going to look at a demo to exemplify this idea of canonicalization on a previous

274
00:20:24,120 --> 00:20:28,440
class that we designed, which was the case and sensitive string class.

275
00:20:28,440 --> 00:20:34,440
So if you recall, I think in part two, part two or three, when we were discussing symmetry,

276
00:20:34,440 --> 00:20:38,560
we created this class called the case and sensitive string class.

277
00:20:38,560 --> 00:20:43,120
And what we're doing here is really we're storing a canonical field.

278
00:20:43,120 --> 00:20:48,520
We're storing data in a canonical field, which is in this string, we have this private

279
00:20:48,520 --> 00:20:49,520
final field.

280
00:20:49,520 --> 00:20:55,560
So it's going to be immutable called canonical S, which is a canonical string.

281
00:20:55,560 --> 00:21:01,640
And then in the constructor, and we instantiate this class, as we normally set the value for

282
00:21:01,640 --> 00:21:07,640
S, we are also setting the value for canonical S, which converts it to a canonical form.

283
00:21:07,640 --> 00:21:09,480
And what does that method do?

284
00:21:09,480 --> 00:21:11,920
It simply converts everything to lower case.

285
00:21:11,920 --> 00:21:22,400
So in that case, if we go to the equals method, you could see that what we're using here is

286
00:21:22,400 --> 00:21:26,280
the canonical string to check for equivalence relation.

287
00:21:26,280 --> 00:21:34,960
We're not using the other value here, which is S, and that ensures that we have consistency

288
00:21:34,960 --> 00:21:39,800
across the equals method because we have this canonical field that we're using.

289
00:21:39,800 --> 00:21:45,680
And that's why we present the data in that way, despite we know that it can take many

290
00:21:45,680 --> 00:21:46,680
forms.

291
00:21:46,680 --> 00:21:52,200
So of course, apart from having a good quality equals method as soft engineers, what we always

292
00:21:52,200 --> 00:21:54,440
look for is a performance application.

293
00:21:54,440 --> 00:21:59,080
So we want that to be good efficiency in the equals method.

294
00:21:59,080 --> 00:22:02,600
And therefore, just a block towards the end of this section discusses a few things we

295
00:22:02,600 --> 00:22:06,600
can do to improve performance apropos of the equals method.

296
00:22:06,600 --> 00:22:12,280
Firstly, it's important to compare the fields that are more likely to differ or less expensive

297
00:22:12,280 --> 00:22:14,000
to compare, ideally both.

298
00:22:14,000 --> 00:22:17,400
By the way, before we get to the second point, we're going to go through all of this in a

299
00:22:17,400 --> 00:22:18,400
demo.

300
00:22:18,400 --> 00:22:20,400
So first, let's get the theory out of the way.

301
00:22:20,400 --> 00:22:26,200
So the second point is do not compare fields that are not a part of a objects logical state

302
00:22:26,200 --> 00:22:28,440
because we are looking for logical equality.

303
00:22:28,440 --> 00:22:29,520
That's important.

304
00:22:29,520 --> 00:22:32,680
And then need not compare the derived fields.

305
00:22:32,680 --> 00:22:37,440
So these are the three main points when it comes to improving performance on the equals

306
00:22:37,440 --> 00:22:38,440
method.

307
00:22:38,440 --> 00:22:42,880
Now, before we get to the demo, I just want to read the formal definition or the formal

308
00:22:42,880 --> 00:22:44,840
elicitation of Joshua Block.

309
00:22:44,840 --> 00:22:49,480
For best performance, you should first compare fields that are more likely to differ, less

310
00:22:49,480 --> 00:22:51,760
expensive to compare or ideally both.

311
00:22:51,760 --> 00:22:53,960
So that's point one.

312
00:22:53,960 --> 00:22:57,600
If only I can click, there we go.

313
00:22:57,600 --> 00:23:02,160
You must not compare fields that are not part of an objects logical state, such as

314
00:23:02,240 --> 00:23:05,560
lock fields that use to synchronize operations.

315
00:23:05,560 --> 00:23:06,880
You need not compare.

316
00:23:06,880 --> 00:23:09,600
So that's part three.

317
00:23:09,600 --> 00:23:14,360
You need not compare derived fields, which can be calculated from significant fields,

318
00:23:14,360 --> 00:23:18,240
but doing so may improve the performance of the equals method.

319
00:23:18,240 --> 00:23:25,400
If a derived field amounts to a summary description of the entire object, comparing this field

320
00:23:25,400 --> 00:23:31,840
will save you expense of comparing the actual data of if the comparison fails.

321
00:23:32,160 --> 00:23:35,280
So let's look at a demo.

322
00:23:35,280 --> 00:23:37,920
What if we have a polygon class?

323
00:23:37,960 --> 00:23:43,560
Now, this firstly, I want to say, I am not saying that this class of design is an accurate

324
00:23:43,800 --> 00:23:47,800
polygon class, especially when it comes to the calculation of the mathematics.

325
00:23:48,160 --> 00:23:52,840
I kind of did a bit of Googling, used a bit of charge APD and put this together, put this

326
00:23:52,840 --> 00:23:54,120
together, pardon me.

327
00:23:54,160 --> 00:23:56,520
So we have the polygon class.

328
00:23:57,120 --> 00:24:03,440
So sorry, the caveat there was the provider was don't take these calculations.

329
00:24:03,440 --> 00:24:04,160
Don't use them.

330
00:24:04,160 --> 00:24:05,000
They're probably wrong.

331
00:24:05,000 --> 00:24:05,840
I'm not sure.

332
00:24:06,320 --> 00:24:11,560
So do double check before using this class if you want to do the polygon class.

333
00:24:12,920 --> 00:24:14,120
So we have a polygon class.

334
00:24:14,120 --> 00:24:16,400
We have edges vertices as a polygon.

335
00:24:16,400 --> 00:24:19,920
This we have this all the fields here are primitive values.

336
00:24:20,240 --> 00:24:24,920
And then we have a double array called sides with array, array cached or cached.

337
00:24:25,240 --> 00:24:28,320
And then we have the constructor, of course, where we are setting all the values and even

338
00:24:28,320 --> 00:24:33,960
setting the value for a Boolean variable or Boolean field, which checks if the array value

339
00:24:33,960 --> 00:24:34,840
has been cached.

340
00:24:35,520 --> 00:24:39,760
And then in the calculations, the calculation itself, we're checking for we're checking for

341
00:24:39,760 --> 00:24:43,120
the area for a initially for a triangle and a rectangle.

342
00:24:43,120 --> 00:24:45,920
And again, as I said, the formula may be wrong.

343
00:24:45,920 --> 00:24:47,640
So I'm not sure if this formula is correct.

344
00:24:48,040 --> 00:24:54,120
And then also, if necessary, we could use it for other polygons, depending on on the

345
00:24:54,120 --> 00:24:56,320
number of sides, the formula will change.

346
00:24:56,840 --> 00:25:03,120
So but the point is the point pertaining to our item is when we're doing the

347
00:25:03,120 --> 00:25:08,000
equality, we aren't the only thing we really because because we're using a derived field

348
00:25:08,000 --> 00:25:09,400
here, which is the area field.

349
00:25:09,800 --> 00:25:13,360
The only thing we're looking for in the quality is the area value.

350
00:25:13,760 --> 00:25:17,880
We're checking if the if the area is the same between the object we pass.

351
00:25:17,880 --> 00:25:22,680
So the polygon object we pass, which, which for all intents and purposes will be a

352
00:25:22,680 --> 00:25:24,160
polygon object we pass.

353
00:25:24,880 --> 00:25:30,920
And we don't we know things such as the vertices, the edges, many things, even the

354
00:25:30,960 --> 00:25:32,600
obviously things like the area cache.

355
00:25:33,080 --> 00:25:37,920
And if we run this method, you'll see it works as expected because we are looking

356
00:25:37,920 --> 00:25:39,000
for logical equality.

357
00:25:40,000 --> 00:25:45,520
You can see here over here, firstly, comparing a triangle to a rectangle, it'll

358
00:25:45,520 --> 00:25:46,400
return false.

359
00:25:46,560 --> 00:25:47,320
That's correct.

360
00:25:47,560 --> 00:25:49,600
We're setting all the sides in the sides area.

361
00:25:50,400 --> 00:25:54,960
But when we compare a triangle to a triangle, so we have the click to

362
00:25:54,960 --> 00:25:59,040
triangles here, triangle and triangle to it'll return true.

363
00:25:59,280 --> 00:26:03,280
That is because the number of edges and vertices are the same.

364
00:26:03,320 --> 00:26:04,440
So are the sides.

365
00:26:04,800 --> 00:26:07,840
And that is because those values are what gives us the area.

366
00:26:08,440 --> 00:26:10,120
So it's a derived field.

367
00:26:10,520 --> 00:26:15,480
And in the quality all we require to create a high performance equals method is

368
00:26:15,480 --> 00:26:17,520
the derived field value.

369
00:26:17,600 --> 00:26:19,120
In this case, the area value.

370
00:26:19,480 --> 00:26:20,640
I hope that made sense.

371
00:26:20,840 --> 00:26:25,640
So just to repeat myself, to really get the take home point here, it is that we

372
00:26:25,640 --> 00:26:27,840
don't have to compare the derived fields.

373
00:26:27,840 --> 00:26:31,320
I may have misspoken and said we have to before, but we don't.

374
00:26:31,400 --> 00:26:36,120
The idea is the significant field in this class in a polygon class is area.

375
00:26:36,480 --> 00:26:41,680
And therefore we know if the area values are equaled for two objects, that the

376
00:26:41,680 --> 00:26:45,120
vertices and the sides and the edges and all the rest of it is going to be equal

377
00:26:45,120 --> 00:26:48,240
to, and in that way we make our equals method more performant.

378
00:26:49,040 --> 00:26:54,200
Because if two polygons have unequal areas, there's no reason to compare the

379
00:26:54,200 --> 00:26:55,720
edges and vertices.

380
00:26:56,600 --> 00:27:00,000
And that gets us to the final caveats, let's say.

381
00:27:00,920 --> 00:27:02,520
Okay, no, not yet, not yet.

382
00:27:02,560 --> 00:27:03,520
I spoke too soon.

383
00:27:04,680 --> 00:27:05,800
There's a bit more to say here.

384
00:27:05,800 --> 00:27:11,920
So Joshua Block, despite me using many other classes to exemplify this, Joshua

385
00:27:11,920 --> 00:27:16,320
Block has his own class called the phone number class that he's built, which I've

386
00:27:16,320 --> 00:27:18,760
used here too, which is really well built.

387
00:27:18,760 --> 00:27:20,640
It's a high quality equals method here.

388
00:27:21,120 --> 00:27:26,560
And he says, when you're finished writing your equals method, ask yourself three

389
00:27:26,560 --> 00:27:27,320
questions.

390
00:27:27,720 --> 00:27:28,720
Is it symmetric?

391
00:27:28,840 --> 00:27:29,800
Is it transitive?

392
00:27:30,000 --> 00:27:30,960
Is it consistent?

393
00:27:31,160 --> 00:27:37,400
If those three questions are fulfilled, that means, or if they're answered to be

394
00:27:37,400 --> 00:27:40,280
yes, that means it's a high quality equals method.

395
00:27:40,440 --> 00:27:44,600
And then he kind of puts this point, of course, your equals method must also

396
00:27:44,600 --> 00:27:49,400
satisfy the other two properties, reflexivity and nonality, which we discussed

397
00:27:49,400 --> 00:27:54,200
in the previous part, but these two usually take care of themselves.

398
00:27:54,320 --> 00:27:57,520
And then we have the phone number class that is designed here, where in the

399
00:27:57,520 --> 00:28:01,280
phone number class, we have the area code prefix and the line num.

400
00:28:01,920 --> 00:28:05,560
They're all private final short values.

401
00:28:08,000 --> 00:28:12,840
I realize he's used the non primitive type short here because it's a phone

402
00:28:12,840 --> 00:28:15,400
number that helps with saving memory.

403
00:28:15,840 --> 00:28:20,160
I've really not ever used a short method ever short type ever.

404
00:28:20,160 --> 00:28:22,880
I've always used just int, but now that's that's that's good.

405
00:28:22,960 --> 00:28:27,160
It shows that it's very punctilious when it comes to design and classes and

406
00:28:27,160 --> 00:28:29,680
writing code, he pays attention to the small things.

407
00:28:30,600 --> 00:28:34,760
So when it comes to the phone number class, yes, we have the constructor

408
00:28:34,760 --> 00:28:36,000
where we set all the values.

409
00:28:36,000 --> 00:28:38,000
We do a range check in this class.

410
00:28:38,000 --> 00:28:42,920
We make sure that it's within the range using this range check method.

411
00:28:44,440 --> 00:28:48,400
And afterwards we come to the crux of the matter, which is the equals method.

412
00:28:48,840 --> 00:28:50,560
So you can see here what he's done.

413
00:28:50,560 --> 00:28:55,960
He's firstly done the memory reference equality or check for memory reference

414
00:28:55,960 --> 00:29:00,600
and then check for the proper type, the type check and then the casting,

415
00:29:01,280 --> 00:29:05,600
which will be fine because we're doing the type check here.

416
00:29:05,600 --> 00:29:08,160
There won't be any class class exception areas.

417
00:29:08,520 --> 00:29:12,000
And then he's comparing all the significant fields.

418
00:29:12,640 --> 00:29:17,880
And for him, or I guess not for him, even for me, for anyone,

419
00:29:18,920 --> 00:29:21,240
this is a high quality equals method.

420
00:29:21,680 --> 00:29:25,480
And now we get to the final caveats when designing an equals method.

421
00:29:25,720 --> 00:29:31,040
So the first one is always override hash code when overriding equals.

422
00:29:32,120 --> 00:29:36,120
We're not going to get too much into that because the next item is in fact

423
00:29:36,120 --> 00:29:38,360
all on the hash code method.

424
00:29:38,920 --> 00:29:44,400
However, that's mostly to ensure that objects of the class work correctly

425
00:29:44,400 --> 00:29:46,600
in hash based collection.

426
00:29:46,600 --> 00:29:51,920
So objects can be put through a hash function and you want any of these

427
00:29:51,920 --> 00:29:55,560
classes or any of these, yes, classes that use hash,

428
00:29:55,880 --> 00:29:58,680
hash based collections to work properly.

429
00:29:59,920 --> 00:30:03,280
And that's why whenever the equals method is overrided,

430
00:30:03,520 --> 00:30:06,720
we need to ensure that the hash code method is also overrided

431
00:30:07,160 --> 00:30:11,800
and updated appropriately, depending on what we do with the equals method

432
00:30:12,120 --> 00:30:15,200
to make sure these collections and other data structures, in fact,

433
00:30:15,320 --> 00:30:17,320
work well with our objects.

434
00:30:17,320 --> 00:30:20,040
The next point is don't try to be too clever.

435
00:30:20,280 --> 00:30:22,840
Perhaps it's good advice for life itself.

436
00:30:23,520 --> 00:30:26,160
And Joshua Block states, don't try to be too clever.

437
00:30:26,160 --> 00:30:31,560
If you simply test fields for equality, it's not hard to adhere to the equals contract.

438
00:30:32,040 --> 00:30:35,600
If you are overly aggressive in searching for equivalence,

439
00:30:35,640 --> 00:30:37,560
it's easy to get into trouble.

440
00:30:37,560 --> 00:30:42,080
And the example he's given is when it comes to equivalence relation or the comparison,

441
00:30:42,680 --> 00:30:46,640
don't take aliases such as symbolic links into account.

442
00:30:46,640 --> 00:30:51,880
Or the example here is, is the file class has symbolic links

443
00:30:51,880 --> 00:30:57,400
and we shouldn't take that kind of alias into account when doing an equality check.

444
00:30:57,560 --> 00:31:01,880
And a few definitions to understand what the relationship between an alias and a symbolic link is.

445
00:31:01,880 --> 00:31:08,160
So firstly, as Biden has put it, a soft or symbolic link is a file pointer.

446
00:31:08,160 --> 00:31:14,960
So in the file class that behaves as a file that is linking to if the target file gets deleted,

447
00:31:15,360 --> 00:31:17,280
then the link is unusable.

448
00:31:17,960 --> 00:31:19,480
So it's mostly a pointer.

449
00:31:19,480 --> 00:31:24,840
And I think, in fact, charge dpd had a much better explanation than even

450
00:31:24,840 --> 00:31:28,120
well done and I really love well done's blog.

451
00:31:28,440 --> 00:31:32,880
In any case, what charge dpd states is an example of a symbolic link.

452
00:31:32,880 --> 00:31:37,360
Imagine you have a folder called original and you have a large number of files in it.

453
00:31:38,040 --> 00:31:42,480
Now, you want to create another copy of the folder, which is identical to the original folder,

454
00:31:42,600 --> 00:31:44,600
but in another location of your file system.

455
00:31:45,200 --> 00:31:48,160
Instead of copying the entire folder and its contents,

456
00:31:48,160 --> 00:31:53,480
you can create a symbolic link to the original folder and place it in the desired location.

457
00:31:54,120 --> 00:31:58,960
I can access the original files to the symbolic link, which acts as an alias.

458
00:31:58,960 --> 00:32:03,280
So it's that's that's the bit that alias bit or the symbolic link we create

459
00:32:03,600 --> 00:32:07,520
shouldn't be taken into consideration when designing the equals method.

460
00:32:07,880 --> 00:32:09,880
That's a field we should ignore.

461
00:32:09,880 --> 00:32:12,480
And then an example of an alias is, let's say you have an object

462
00:32:12,480 --> 00:32:16,200
A with some properties and methods and you create an object B

463
00:32:16,600 --> 00:32:18,680
that is identical to object A.

464
00:32:18,680 --> 00:32:22,400
Now you can access object A's properties and methods through object B,

465
00:32:22,440 --> 00:32:25,280
which acts as a as an alias for object A.

466
00:32:25,360 --> 00:32:27,160
So that kind of makes is what an alias is.

467
00:32:27,160 --> 00:32:28,880
And this is how you define symbolic links.

468
00:32:28,880 --> 00:32:32,840
So in the files method, we have file, stock, create symbolic link.

469
00:32:32,960 --> 00:32:35,640
We have the link we create and then we have the target.

470
00:32:36,000 --> 00:32:39,760
This link we create shouldn't be used when it comes to

471
00:32:40,640 --> 00:32:43,600
a equivalence relation in I equals method.

472
00:32:43,600 --> 00:32:46,400
That should be ignored and it's not a significant field.

473
00:32:46,600 --> 00:32:48,920
So the final caveat is, in fact, quite important.

474
00:32:48,920 --> 00:32:51,880
Now, the other two caveats are I don't think, at least,

475
00:32:51,880 --> 00:32:54,320
that one would be prone to making those mistakes.

476
00:32:54,560 --> 00:32:58,480
Whereas this most certainly I can see myself making this mistake.

477
00:32:58,720 --> 00:33:03,280
It is that you shouldn't substitute another type for object in the equals

478
00:33:03,280 --> 00:33:08,880
declaration. So as you saw in the equals method as defined in the object super

479
00:33:08,880 --> 00:33:12,320
class, it we all actually, this is a bad example.

480
00:33:12,360 --> 00:33:13,680
This is the way not to do it.

481
00:33:13,720 --> 00:33:17,040
But normally what you'd have here is the object we take in the

482
00:33:17,040 --> 00:33:18,800
parameter would be of type object.

483
00:33:19,200 --> 00:33:21,680
But let's say we define it to be some other type.

484
00:33:22,240 --> 00:33:26,600
This will create some problems because firstly, what this does is

485
00:33:26,600 --> 00:33:30,440
it will the compiler will not inherit the problem implementation of the equals

486
00:33:30,440 --> 00:33:34,320
method. And since the method is strongly typed.

487
00:33:34,320 --> 00:33:38,400
So now we've specifically defined what type we want.

488
00:33:38,560 --> 00:33:40,760
And it can't just be the superclass object.

489
00:33:41,400 --> 00:33:45,680
It'll take objects of a specific class, a specific type instead of object,

490
00:33:45,720 --> 00:33:48,560
which can give false positives, certainly.

491
00:33:48,840 --> 00:33:53,240
And one other point there is the problem with defining the equals method like

492
00:33:53,240 --> 00:34:00,120
this is the method does not override the object dot equals because we do inherit

493
00:34:00,120 --> 00:34:01,840
this from the superclass object.

494
00:34:01,840 --> 00:34:04,560
We do it like this instead of overriding.

495
00:34:05,720 --> 00:34:10,120
It will overload it because the method in the object dot equals class,

496
00:34:10,400 --> 00:34:12,080
the type is object.

497
00:34:12,440 --> 00:34:16,000
And now we've changed it where it's going to be overloaded and the equals

498
00:34:16,000 --> 00:34:19,640
method will still exist in our subclass.

499
00:34:20,000 --> 00:34:21,760
So it'll sort of be like this.

500
00:34:21,760 --> 00:34:26,080
It'll be it'll be this and then there'll be another method.

501
00:34:26,960 --> 00:34:31,360
With object, Java disallowed this because the signature of these two methods

502
00:34:31,360 --> 00:34:33,880
are different. They're both, they've both got the same name.

503
00:34:34,000 --> 00:34:37,200
However, they take in different types of parameters.

504
00:34:37,200 --> 00:34:38,840
So overloading takes place.

505
00:34:38,880 --> 00:34:43,080
And this is a problem again, cause it can mislead the client of our class.

506
00:34:43,120 --> 00:34:47,640
Now, in my opinion, it's always a good habit to use annotations in Java.

507
00:34:47,680 --> 00:34:48,880
I think that's a good idea.

508
00:34:49,320 --> 00:34:54,920
And this is a good example of why perhaps using an annotation is good.

509
00:34:54,920 --> 00:34:58,120
Not for the sake of the compiler, let's say, but more for the programmer,

510
00:34:58,120 --> 00:35:03,040
because what happens here is here, because we explicitly stating,

511
00:35:03,720 --> 00:35:07,160
we're going to override the equals method in the superclass.

512
00:35:08,160 --> 00:35:09,320
This won't compile.

513
00:35:09,360 --> 00:35:10,400
It'll give an error.

514
00:35:11,160 --> 00:35:13,560
It's still broken, of course, but at least it won't compile.

515
00:35:13,560 --> 00:35:16,880
So we'll, you know, pick our mistake and we'll recognize some things.

516
00:35:16,880 --> 00:35:20,880
We've done something wrong here by giving it type my class instead of object.

517
00:35:21,720 --> 00:35:25,720
And I think it's good because now we're saying instead of overloading,

518
00:35:25,760 --> 00:35:30,240
we want it to, we're explicitly stating we want it to override and the compiler

519
00:35:30,240 --> 00:35:33,960
is saying, nope, we can't do this, which is what you'll see here.

520
00:35:33,960 --> 00:35:34,800
So this is demo here.

521
00:35:34,800 --> 00:35:37,920
I have a parent class with a equals method.

522
00:35:38,760 --> 00:35:43,320
And if you look at the child class, this is dangerous because we're doing

523
00:35:43,320 --> 00:35:45,120
overloading here unknowingly.

524
00:35:45,360 --> 00:35:48,640
However, if we do put the override annotations in here,

525
00:35:48,640 --> 00:35:52,520
if we do put the override annotation, it'll throw an error, let's say,

526
00:35:52,520 --> 00:35:57,320
or the override can't take place, can't take place, which then we can fix by

527
00:35:57,400 --> 00:36:01,080
doing it the proper way, which is what I've defined here, where now we have a

528
00:36:01,080 --> 00:36:05,800
proper overriding takes place with the type of object.

529
00:36:05,800 --> 00:36:07,320
So we're taking all the objects in here.

530
00:36:08,600 --> 00:36:09,360
That's great.

531
00:36:09,880 --> 00:36:13,320
And then, of course, that's the end of the item, the end of the part,

532
00:36:13,320 --> 00:36:14,120
and the end of the item.

533
00:36:14,120 --> 00:36:16,240
Wow, that was a long, long item.

534
00:36:16,240 --> 00:36:18,080
It was probably 10, 15 pages.

535
00:36:18,080 --> 00:36:20,200
I feel really good for getting through that.

536
00:36:20,200 --> 00:36:26,160
And I learned so much, but, but, but at the end of the item, Josh Schumburg

537
00:36:26,160 --> 00:36:28,800
states, Hey, look, yes.

538
00:36:28,800 --> 00:36:32,240
Now you know how to design or you have the recipe for a high quality equals

539
00:36:32,240 --> 00:36:32,760
method.

540
00:36:33,360 --> 00:36:34,320
And yeah, it's fantastic.

541
00:36:34,320 --> 00:36:35,000
We learned a lot.

542
00:36:35,000 --> 00:36:38,080
We went through a lot of a bit of computer science, a bit of human logic.

543
00:36:38,960 --> 00:36:44,520
However, most of the time it's a good idea to use the IDE or to use something

544
00:36:44,520 --> 00:36:48,840
like the auto value framework, Google's open source auto value framework, when

545
00:36:48,840 --> 00:36:53,800
designing equals methods, because these frameworks were pretty much take care of

546
00:36:53,840 --> 00:36:56,720
all of these things we discussed in this item.

547
00:36:57,080 --> 00:36:58,520
Look at how long the item is.

548
00:36:59,080 --> 00:37:04,880
Everything from, from, from the properties and, and making the equals

549
00:37:04,880 --> 00:37:06,520
method more performant, all of that.

550
00:37:07,280 --> 00:37:14,000
Which is why Josh Schumburg states, an excellent alternative to writing and

551
00:37:14,000 --> 00:37:19,400
testing these methods manually is to use Google's open source auto value

552
00:37:19,400 --> 00:37:24,280
framework, which automatically generates these methods for you triggered by a

553
00:37:24,280 --> 00:37:26,360
single annotation on the class.

554
00:37:26,960 --> 00:37:32,680
And then he also says, having IDEs generate equals and hash code methods

555
00:37:32,680 --> 00:37:37,240
is generally preferable to implementing them manually because IDEs do not

556
00:37:37,240 --> 00:37:38,360
make careless mistakes.

557
00:37:38,360 --> 00:37:39,880
And of course humans do.

558
00:37:40,560 --> 00:37:41,680
That's the end of the item.

559
00:37:41,840 --> 00:37:46,440
And then he states, in summary, don't override the equals method unless you

560
00:37:46,440 --> 00:37:52,120
have to, in many cases, the implementation inherited from object does exactly

561
00:37:52,120 --> 00:37:52,760
what you want.

562
00:37:53,000 --> 00:37:57,880
If you do override equals, make sure to compare all of the classes, significant

563
00:37:57,880 --> 00:38:03,360
fields, and to compare them in a manner that preserves all five provisions of

564
00:38:03,360 --> 00:38:04,480
the equals contract.

565
00:38:05,400 --> 00:38:06,000
Fantastic.

566
00:38:06,280 --> 00:38:10,280
I'm so happy that I got through that, especially because I feel like I learned

567
00:38:10,280 --> 00:38:14,160
a lot when we were going through that item because it touched on so many

568
00:38:14,160 --> 00:38:16,720
different concepts, which was a really fun item to cover.

569
00:38:17,040 --> 00:38:21,440
And the next one is item 11, as I did state a bit before, always override

570
00:38:21,440 --> 00:38:24,840
hash code when you override equals.

571
00:38:25,280 --> 00:38:27,560
And I shall see you in the next one.

572
00:38:27,680 --> 00:38:28,320
Thanks for watching.

573
00:38:28,520 --> 00:38:29,000
Cheers.

