start	end	text
0	6800	Hey everyone, welcome to yet another episode of my video series on Joshua Block's Effective Java,
6800	12160	where I take the items that he has enumerated in this book and expound on them, trying to make
12160	18080	sense of them. And hopefully, as I do that, you can gain some value from it too. You can
18080	23280	hopefully learn something from it. That at least is one reason that I put out these videos
23280	28960	out in the public. Without further ado, let me get started. This is certainly one of the longest
28960	34400	items that I had to go through and probably going to be the longest video of this series as of yet.
35120	40160	In fact, I was thinking if I should break this down into two videos because the video might be
40160	46720	too long. In any case, let's get started with the proviso. I've been doing this proviso slash
46720	51600	instruction in every single video. So if you have been following along, please do skip this bit to
51600	56720	save your time. The first point in the proviso is of course, and it's a very important point,
56720	64080	this is not a tutorial. I'm not a teacher, nor am I an expert. Therefore, don't think of what I say
64080	68720	as gospel's truth. In fact, when I do make mistakes, I'll try and correct them down
68720	74560	during the comment section. And as I've said in the second point, think of this as the blind,
75120	81120	leading the blind. This is purely an exploratory disposition. I'm trying to figure something
81120	90160	out publicly and in a very, let's say, what's what I'm looking for. I'd say thinking out loud,
90160	95200	trying to make sense of these items, not just in the videos itself, but even preparing for them
95200	101680	as I post questions on Stack Overflow, as I try to involve the community. I feel like hopefully,
101680	106240	you know, I'm adding some value into the programming community, the Java community,
106240	111760	by asking certain questions pertaining to this book, as I'm trying to learn, which is why I call
111760	117840	it an exploratory disposition. It's a collective endeavor. And as I did touch on a bit before,
117840	124320	I will inevitably make mistakes. So please point them out, not just for my sake, perhaps even more
124320	132160	for the sake of the viewers, because I certainly don't want to mislead them by sharing any misinformation
132160	138080	to use a politically overloaded term. And of course, as this is a programming video series,
138080	144720	all the code is available on GitHub, not just mine, but even Joshua Bloch's public repository
144720	150880	where he's published the code that he's used for this book. Saying all that, let us get started
150880	156640	with item number eight, which, as I said, is a long one. There are a few concepts that I had to
157440	164560	sort of think about and muse and reflect for a bit to get my head around. But it was a very
164560	169520	interesting item as I found all the items in this book. And especially if you're a Java fan, like
169520	177280	myself, for all, even though I don't program in Java in my day job anymore, Java is my first love
177280	185120	venue. Never forget your first one, isn't it? I'm sorry, that was pathetic, but I can't help myself.
185120	191360	Okay, item number eight, avoid finalizers and cleaners. And we're still in chapter two,
191360	198160	creating and destroying objects. And again, as I said, all the code available on my GitHub repo,
198720	203440	links down below in the description. And I've kind of added like this, another caveat here.
204000	208640	This item does have a lot of theory. So before we get into the code, which of course I have
209360	214720	right here, before we get into any of this code, I think it's important to get through some theory.
216400	223040	Just in general, I prefer doing that to get a conceptual understanding. But specifically this
223040	228800	item, I think has a lot more theory. So as I normally do, let's look at some keywords here.
228800	234240	Avoid finalizers and cleaners. What the hell are finalizers and cleaners? Full disclosure,
234240	240000	I've never used a finalizer nor a cleaner. A cleaner, yes, but I've never used a finalizer
240800	246080	in my day job when I used to do a lot more hands-on Java programming. But here are a few
246080	253360	definitions that I found on finalizers. In fact, they're from Baildang, my favorite Java
254240	261920	learning blog slash website. And then of course, the Oracle docs. So finalizers, the,
264400	268720	sorry, I had to think about that just for a bit. I didn't want to mindlessly read out the definition.
268720	273440	Essentially, I mean, finalizers is simply a method we're talking about, which is in the
273440	279360	object class, which the, in the class hierarchy in Java, the object class is right at the top. So
279360	288240	everything is a subclass of object Java, FII. The finalize method for all intents and purposes
288240	295120	is what we call the finalizer. Even though finalizers is more like a mechanism. And Baildang states
295120	302880	finalizers get involved when JVM figures out that this particular instance should be garbage collected.
303120	311280	So when the JVM understands that a certain object or an instance of a class is ready to be
311280	319200	garbage collected, it can be involved, this finalized method. Such a finalizer may perform
319200	325680	any operations, including bringing the object back to life. That bit, full disclosure, I don't
325680	330960	understand. I didn't really go into detail as to what it means bringing the object back to life.
331920	336560	Perhaps it's referring to the object later again in the code and then, you know,
336560	342400	allocating memory to it. But even in the item, Joshua Block hasn't really got into what that
342400	348720	means. This is just a definition from Baildang. The main purpose of a finalizer is, however,
348720	355920	to release resources used by objects before they're removed from memory. A finalizer can work as a
355920	361600	primary mechanism for cleanup operations or as a safety net when other methods fail.
361600	369280	So at a very high level, just a good bit of start is to think of finalizers being related to
370080	376000	memory management and garbage collection. It's not something particularly done by the JVM.
376000	382800	Programmers could do it too, explicitly. But of course, a caveat is we should in fact avoid
382800	387920	using finalizers and cleaners. That is the caveat here. So even though it's possible,
387920	395360	doesn't mean we should do it. So again, to repeat the point, think of finalizers as something that
395360	402240	relates to memory management and garbage collection and ensuring that any unreferenced
402240	408640	objects are cleaned and that resources are freed up. And then another definition again from the
408640	414880	Oracle docs this time is, as I said, finalize is part of the object class. If you go take a look
414880	422000	at the docs, it'll even state, if only my internet loads, it'll even state the finalize method is
422000	429360	there. As you can see there, it'll say they're called by the garbage collector on an object
429360	434000	when garbage collection determines that there are no more references to the object.
434000	445760	The general contract of finalize is that it is invoked if and when the Java virtual machine
445760	452560	has determined that there's no longer any means by which this object can be accessed by any thread
452560	458640	that has not yet died, except as a result of an action taken by the finalization of some other
458640	465200	object or class which is ready to be finalized. So, okay, effectively this means when the object is
465200	471600	not going to be used, we need to free up that resource and get that memory back to be used
471600	479280	for something else. That's what finalize is. But, again, we shouldn't use them. That's the point
479280	484640	Joshua Book is trying to make. Okay, so the first keyword finalize is we've got a very high level
484640	489200	conceptual understanding of what it is. Let's take a look at what cleaners are, which is kind of like
489200	498400	an evolution of finalizers and is perhaps a bit safer to use, even though that too should try and
498400	509120	be avoided ideally. Once again from the, so cleaner is in fact, let me open it up. It's an interface.
509520	521120	Sorry. Sorry, I meant to say cleaner is a subclass of object. I was thinking of auto-closable,
521120	528640	which is an interface. We'll talk about that later on. And the definitions for the cleaner is,
528640	536720	again, by the Oracle docs. Cleaner manages a set of object references and corresponding cleaning
536720	542400	actions. Cleaning actions are registered to run after the cleaner is notified that the object has
542400	547680	become phantom reachable. So what is phantom reachable? I did discuss this in the previous
549040	554160	item, item number seven. I'm not going to go into too much detail, because you could just
554160	561040	watch that video. But phantom reachable is when an object has no strong soft or weak references,
561600	569600	but at least one phantom reference. So this kind of has to do with how the JVM algorithms,
569600	576240	or how garbage collection algorithms, decide if a certain object has to be, or can be garbage
576240	583760	collected. So basically, strong objects can never be garbage collected. And then it's sort of the,
584800	588960	there's like a cascading effect, not a cascading effect, there's like a triaging process where
588960	593280	it goes from strong, soft, weak, and then the lowest one is a phantom reference.
594000	600880	Read this document by Bialdown, which goes into detail, of course, linked to this in the
600880	605520	description too, for more context. I'm not going to go into detail because it's sort of out of
605520	610720	scope for this item. And as I've said here, these delineate when objects can be garbage
610720	617520	collected. That's what phantom references do. And with cleaners, cleaners are used when an object
617600	623600	has become phantom reachable. That's how it relates. And then another definition from
623600	632320	inside Java by Roger Riggs is, unlike a finalizer, a cleanup function holds the state needed for
632320	637280	cleanup separately from the object because we want the object to be reclaimed as soon as it is
637280	643360	unreachable. When it states, when it states reclaiming an object, what that really means is
643440	649760	freeing up memory. So we can use it for something else. The cleanup function must be able to work
649760	655200	independently from the object. It's correct. It should be able to run on a separate thread for
655200	660080	instance. And that does happen. We shall see an example. If there are any references to the object
660080	663520	from the cleanup function, it would still be reachable and could not be reclaimed.
664080	669440	Any state needed for the cleanup must be encapsulated in the cleanup function.
669920	677680	What does that mean? I believe what this means is, when the cleanup does take place, so a quick
677680	686800	peek in the code, let's say the cleanup happens. Let's say this close method. This is a bit different.
686800	693040	Ignore all this. But the state of an object should be local to the state of an object.
693520	699440	When the cleanup is taking place. I believe that's what it means. It's encapsulated within this
699440	704400	method. Ignore all this, but it's a really sub-art context, but we shall get this code a bit later.
706640	714160	Okay, now we get to the items, what Joshua Block has stated in the item in the book. And the first
714160	720400	thing is, the first thing we need to do is, we need to take a look at the state of an object.
720720	725440	And the first thing is, he's kind of talking to C++ programmers.
727360	736160	And a point he wants to make salient and very clear is that finalizers or cleaners are not
736160	744160	the same as destructors in C++. Now, obviously, because C++, I'm not a C++ programmer in any way,
744720	750080	I've probably written like 10 lines of C++ code in my life, probably a bit more than that.
750080	756320	I did do a unit, a data structure and a patterns unit back in uni, which was a, which was in C++.
757040	763840	And obviously, so because C++ doesn't have automatic memory management or garbage cleaning,
763840	771360	we need to do it ourselves, the programmer. So I believe it's done through destructors.
772240	779120	Take what I say with a great assault. Maybe they'd rather us do it. But one way it is done in C++,
779120	785760	probably the most popular way is using destructors and Joshua Block and once we make it clear
786400	792000	that cleaners and finalizers are not the same as destructors. And here's what he states.
794320	800640	Finalizers are unpredictable, often dangerous and generally unnecessary. I shall also discuss
800640	806400	that bit about them being unpredictable or non-deterministic as to why that's a huge
806400	813600	risk when programming as we go into the item. And then he states, as of Java 9,
813600	819200	this is an important point, finalizers have been deprecated, but they are still being used by the
819200	826800	Java libraries. The Java 9 replacement for finalizers is cleaners. Cleaners are less dangerous
826800	833040	than finalizers, but still unpredictable, slow and generally unnecessary. So this, which is why
833040	839600	we should be avoiding avoiding old finalizers and cleaners. So despite having the caveat that
839600	846080	finalizers and cleaners aren't the same as destructors, he states, or he continues,
846080	854320	C++ destructors are also used to reclaim other non-memory resources. In Java,
854320	860720	a try with resources or try finally block is used for this purpose. And then he continues,
860720	866000	one shortcoming of finalizers and cleaners is that there's no guarantee they'll be executed
866000	869520	promptly. Yes, before I read that, I need to go through the notes that I took down.
871680	875680	So I had to go through the code base a bit and read up again, because I wrote this a while back
875680	881360	and I've forgotten some bits as to how it's all going to come together. In fact,
882320	889040	by my struggle to demo this, to demonstrate this problem, is in many ways the point
889040	893680	Joshua Block is trying to make that it is non-deterministic. I can't exactly show the problem
893680	899040	with finalizers because due to it's, it's not deterministic. And in programming, you'd expect
899040	906320	code to be deterministic and causal. The big problem with using cleaners and finalizers is
906320	912640	firstly that we aren't sure when the garbage collection will take place. We don't, we aren't
912640	922000	sure when the, when GC will run and JVM can do it, which will be anytime it wants. Even though
922000	928400	it is possible, as I will show in a bit, for us to explicitly run a GC or a garbage collection
928400	933520	cycle, it is not, it's ill-advised. One shouldn't, one shouldn't do this. There are many other side
933520	942560	effects that can affect the program. And it's possible that the finalizer thread, so the thread
942640	948800	where the closing of the objects taking place can be of low priority that can lead to an
948800	952640	out-of-memory error. Because some other threads would run, take up all the memory and when this
952640	959120	thread runs, that can throw an out-of-memory error. Even, and then there's again another caveat that
959120	966640	cleaners in fact do run in the background. And the garbage collection is controlled by the class
966640	972720	itself. The class owns that garbage collection. However, there still is a problem of it not
972720	978640	being, of it not running promptly. Sorry, I made a mistake there. The garbage collection doesn't
978640	984960	have, sorry, the class doesn't have control of the garbage collection, but it has control of its
984960	992240	own threads, which we shall see because we use a runnable interface. And nevertheless, it still
992240	1001840	does not guarantee the promptness. And due to the non-determinism in both cleaners and finalizers.
1001840	1008880	Now I'll quickly show what the hell finalizer even is, because there isn't really a proper example
1008880	1015600	given in the book. I found an example courtesy of Byle Dunn. But before I show the code base,
1016160	1023920	let's go through some something a bit more, let's say, clear. And I try to be a bit more
1024880	1029600	explicit as to what Joshua Block has written here, because I think I didn't do a good job at
1029600	1036800	explaining that. Here's what he states. One shortcoming of finalizers and cleaners is that
1036800	1041440	there is no guarantee they'll be executed promptly. It can take arbitrarily a little
1041440	1047120	between the time that an object becomes unreachable and the time its finalizers or cleaners run.
1048640	1054080	This means that you should never do anything time critical in a finalizer or cleaner.
1057040	1063600	The promptness with which finalizes and cleaners executed is primarily a function of the garbage
1063600	1067920	collection algorithm, which varies widely across implementations.
1071680	1079040	So what does that mean? The thing is, even after the finalizer runs, a GC still has to run in the
1079040	1085280	background, clear up resources, clear up memory. But before we get to the idea of the promptness,
1085280	1090640	let's take a look at what the hell a finalizer even is. So I was going through this example,
1091360	1095280	as I said, courtesy of Violet Dung, and let me try to open up that
1097520	1101440	article if I could find it. This one right here.
1103680	1109040	It was this article that he wrote, and he's just given a background as to what finalizers are.
1109680	1115120	Even though in the article S it goes, it does say why you shouldn't use it. It talks about
1116080	1120160	why we should take care of garbage collection, because JVM knows better, in fact.
1122960	1128720	And I have this class called Finalizable, and I have an instance, a buffered read instance.
1130160	1137120	And then the constructor, what I'm doing is reading a file, getting an input stream, and then
1137200	1143760	saving a new buffered read instance in this private variable of declared,
1144880	1152800	class variable of declared here. And it does specify from the specified class part,
1153440	1160720	from some nature quotes. And here we have a method called ReadFirstLine, which reads from the first
1160720	1169280	line. So if this works as expected, it should read without music, life would be a mistake
1169280	1178320	by Mr. Nietzsche, and I very much agree. And then once we have this instance created, we need to
1178320	1184400	clean it. We need to finalize it. And here's where, sorry, we need to close it, apologies.
1184400	1188320	And here's where the problem occurs. Now, once we have this reader, the buffered instance reader,
1188400	1192720	which we declared here, it's used, we do the reading, whatever, and then it's used,
1192720	1197120	and then we're done with it. We need to use a finalized method, which, as you can see,
1197120	1201120	is deprecated. The IntelliJ does specify that, that is deprecated.
1204000	1210960	It needs to be closed, which implies that the method was called, and it has to clean up the
1210960	1220400	resource. So in this finalize method, it'll close the resource. And now when I run the unit test,
1220400	1227840	you will say it'll say closed buffered reader in the finalizer. If not, it'll just throw an error.
1229760	1231440	If I go to the unit test that I wrote,
1231520	1241680	and if I run this, you can see it's printing that line here. I could probably zoom into that
1241680	1248800	a little bit. Closed buffer reader in the finalizer. Really, that's what a finalizer does,
1248800	1254960	even though we shouldn't use it. And yeah, over here, you can go through the code later on.
1254960	1259760	I'm just checking if it's printing the first line. That's not pertinent to the point I'm trying to
1259760	1266640	make. And then this is important, though, because the GC is rather arbitrary. Well, it's not arbitrary,
1266640	1271920	but we don't have really control of when garbage collection will take place. The JVM does that.
1272640	1279840	We're using a system.gc, but it shouldn't be invoked this explicitly. This is not something we should
1279840	1287920	do, again, due to its non-deterministic behavior. So you probably can see it's like a theme that's
1287920	1294560	going to be in this whole item. The big problem with cleaners and finalizers is non-determinism,
1295360	1302320	and it's the fact that it's tardy. It's tardiness that's not prompt, which is why Joshua Block states,
1302320	1310000	as we continue, tardy finalization is not just a theoretical problem. Providing a finalizer
1310000	1315360	for a class can arbitrarily delay reclamation of its instances. And that's a problem.
1316320	1323440	The language specification makes no guarantees, sorry, I'll read that again.
1323440	1329840	The language specification makes no guarantees as to which thread will execute finalizers as there is
1329840	1336640	no portable way to prevent this sort of problem other than to refrain from using finalizers.
1337600	1343120	And then, of course, as I stated, unlike finalizers, we still can use cleaners. Cleaners
1343120	1350320	aren't deprecated yet. And they would give us control of the thread, of the class that's using it.
1351120	1356720	But still, ultimately, the garbage collection, we still have no control. The JVM has control,
1356720	1362160	which is probably why we should avoid using cleaners too. As he states here, as a consequence,
1362160	1368320	you should never depend on a finalizer or cleaner to update persistence state. That's correct if
1368320	1373680	it's like a database connection or something that requires persistence. For example, depending on
1373680	1379920	a finalizer or cleaner to release a persistent lock on a shared resource such as a database is a
1379920	1387120	good way to bring your entire distributed system to a grinding halt. Oh, that is something you
1387680	1395120	certainly don't need. Programming is easy. It's really easy. It only gets complicated once it
1395120	1403920	becomes distributed programming and when concurrency gets involved. And that's why I have a beautiful
1403920	1410160	gift of my favorite actress, Margaret Robbie, probably the most beautiful woman in the world,
1411440	1416560	after a certain other woman that I'm currently in love with. But we shall not talk about that.
1418640	1423600	Don't be seduced. That's the point I'm trying to make. Do not be seduced by Margaret Robbie,
1423600	1433760	nor be seduced by the methods system.gc or system.run finalization. So, which is why,
1433760	1439680	just to go back to the unit as before, I said it here, one shouldn't do this. This is a bad move.
1439680	1446160	This, try and prevent, try and, yeah, try and prevent using system.gc in your code,
1447120	1451600	again, due to its non-determinism, because both of these, the garbage collection and
1452400	1457280	what runs the finalization method makes no guarantee that they'll actually get executed.
1459040	1464240	And in fact, these two methods run finalize their own exit, which are two other methods
1464240	1470400	that can be, that pertains to finalizes have been deprecated because they aren't safe.
1470400	1474880	Another red flag, especially if you're an API designer and aren't all programmers
1474880	1482800	designing APIs these days, is that finalizes ignore uncaught exceptions and doesn't notify the client
1483520	1489680	what the hell is going on if you do use a finalizer and there's a corrupt object. So, for instance,
1491440	1497040	let's say we have an object in corrupt state due to the non-deterministic arbitrary behavior of
1497040	1502080	a finalizer. Let's say we have an object that isn't fully cleaned up or an object that shouldn't be
1502080	1511840	accessed by another thread. When the object crashes, this thread will not be terminated by a finalizer,
1511840	1518080	whereas a JVM would certainly do that. It would make sure that if a thread crashes,
1518080	1523280	if some competition goes wrong somewhere and some error is thrown, it's physically clear and explicit
1524240	1529280	to a user of an API and it would be terminated and cleaned up.
1531200	1541360	This is a problem because if you do use finalizer, it'll allow objects in a corrupt state to be
1541360	1549280	accessed by a client of an API, which is why, again, he states, another problem with finalizes is that
1549280	1556400	an uncaught exception thrown during finalization is ignored and finalization of that object terminates.
1558000	1560800	Uncaught exceptions can leave other objects in a corrupt state,
1561680	1565600	but when an object is left in a corrupt state and an exception is thrown,
1565600	1570160	generally you'd see that exception in the stack trace. With finalizers, there wouldn't be that and,
1570160	1577840	in fact, he says it won't even print a warning. But, however, with cleaners, it's on an issue because
1577840	1584880	with cleaners, the library or a class for all intents and purposes using a cleaner has control
1584880	1590320	of its thread, so the class itself can throw this exception. So it's a bit safer than using finalizers
1590880	1597920	even though the item as a whole states avoid both. The other issue is performance penalty.
1597920	1602480	Finalizers inhibit efficient garbage collection because we are trying to manoeuvre do the
1602480	1608000	garbage collection instead of letting the JVM do it. And even though cleaners are still faster
1608000	1613520	than finalizers, it's still slower than using the auto-closable interface, which we shall get to
1614400	1620080	in the item, later on in the item. So the other problem is, of course, yes, performance penalty,
1620080	1624960	and that's why Dr. Block states there's severe performance penalty for using finalizers and
1624960	1631920	cleaners. It is about 50 times slower to create and destroy objects with finalizers. This is
1631920	1639440	primarily because finalizers inhibit efficient garbage collection. And then we get to probably
1639440	1645760	one of the biggest issues with using finalizers and cleaners, and it's that it does leave our
1645760	1652400	program vulnerable to malicious code and security attacks. This point, despite being an important
1652400	1660000	point, I found it a bit difficult to understand, especially because I couldn't get what he meant
1660000	1667440	by having a malicious subclass. But this is what I meant, but I'm trying to collectively learn here.
1667440	1673920	I did post a question on Stack Overflow, and I got some really good answers. And then finally,
1674480	1682000	Holga, great blog. I'm assuming it's a blog. The person answered the question, and it was,
1682800	1689040	I think it was somewhat clear. It did make sense. So all credit goes to Holga. I'll leave an answer
1689120	1695680	to this question down below in the description, where he explains how finalizers, in fact,
1695680	1701200	do create security problems. And before I read what Dr. Block has stated, let's go through
1702080	1711360	some code and understand what this issue is, practically. So firstly, I've written this
1711360	1717840	class called Finalizer Attack Example, and that also has an inner class. This inner class, in fact,
1717840	1723200	is what is supposed to do the cleaning up. So it's got this check call method, which is kind of
1723200	1728160	like a Boolean, which is just like a security check that verifies where that calls this,
1728160	1734880	has permissions, let's say. That's a bad way of putting it. But just for all the intents and purposes
1734880	1739760	think that all callers are invalid for our demo. And then we have this method, which does some
1739760	1744240	critical action. That's it's really important. So I forgot to mention that since the inner class
1744240	1749360	is static, that won't allow the JVM to garbage collect this resource. And then we have this
1749360	1756880	malicious subclass that extends the resource class. So this is where the issue lies. This resource
1756880	1765280	class, once it was used, should have died on the vine, as Dr. Block would state in this item.
1765280	1769760	It should have got garbage collected, and no one should have access to it to that object.
1769840	1775120	However, because we know that the finalized method can be accessed via the object superclass of resource
1775120	1780800	class. And then the fact that the malicious subclass extends the resource class, all it's
1780800	1785120	got to do is override the finalized method and invoke it. And the moment it's invoked,
1785120	1791200	this object, which is probably a corrupt object now is resurrected. And that gives this malicious
1791200	1798400	subclass access to this critical action method, which probably could do something like access
1799360	1804400	the database or do something that could potentially calm your application and its uses.
1805040	1810080	So which is why when I run this code, you'll see in the public static word main function.
1812080	1817520	Initially, oh, I've added this thread here with the GC. This helps to kind of demonstrate the
1818080	1823920	non-domestic behavior. I'll just show you that too. Initially, in the try statement,
1824000	1831200	it creates a new object. And when it does, it'll say because it ran a couple of times,
1831200	1835760	it would initially say I wouldn't get hands on a resource class. So okay, that's a bit confusing.
1835760	1841200	I can see I shall first get rid of the sleeping of the thread and try running it again.
1845040	1851120	When I don't make the thread sleep, it will throw a security exception.
1852080	1859840	It'll catch that there's an issue here by the check holder and then throw the security exception.
1859840	1866720	But the important point here is finalizes aren't deterministic. It's a problem. So if we do get
1866720	1872480	the thread some few minutes, two seconds to sleep, then what you'll see when you run it is
1873040	1880960	it's printing that look where it's saying, see, I got hands on this object, which is it's printing
1880960	1888560	that from the finalize method, which was a subclass, well, not subclass, which was inherited
1888560	1895440	from the resource class. And then because we got access to this object, you can probably see here
1895920	1902240	you can probably see here what it's printing out is in fact this this object, but then also
1902240	1909120	it has access to the critical action method, which ideally, which not ideally, but which
1909120	1917760	actually the malicious subclass shouldn't have access to because once again, it should have died on
1917760	1925600	the vine. I hope that makes sense. I think I got it. So I was trying to, when I asked a question
1925600	1931280	on Stack Overflow, here's what I said. I'll read out this bit of the chapter, but then I said,
1932160	1940240	in like a very systematic way, my understanding is that finalizes are not deterministic,
1940240	1945120	a malicious subclass can run its finalize method on a particular constructed,
1945120	1951760	corrupted superclass object, which is what we are doing right here by extending the resource
1951760	1960560	class. Moving the corrupt objects reference to a static field doesn't let the GCM garbage collect,
1960560	1967360	not GCM, JVM, I should fix that. So because it's static, it can't be garbage collected.
1967920	1973920	The attacker can use this object that should have died on the vine and do as they will,
1973920	1979680	pass the security flow. So this is the problem with the use of finalizes. I hope that makes sense.
1980640	1985280	I'm asking that question more from myself if I really understood that,
1987120	1991280	but I think I did, but I think I did. At least I'm going to tell myself how to feel better.
1993440	1999280	Now that I've kind of demoed that, even though I admit that was a rather pathetic demo,
2000080	2004880	let's try and get to what Joshua Block has stated here. Please forgive me. I'm trying my best to
2004880	2010240	demo it here, but because he really hasn't given tangible implementations and examples,
2010240	2014800	I'm trying my best to see if I could find code and write code and connect it to what he's trying to
2014800	2020560	say here, given that I haven't really used finalizes before ever in my programming life.
2021760	2025680	But anyway, let's see if what he's stating here makes a bit more sense.
2026560	2034640	Finalizes have a serious security problem. They open your class up to finalize their attacks.
2035200	2041760	The idea behind a finalize attack is simple. If an exception is thrown from a constructor,
2041760	2049440	or it's serialization equivalence, so that would be the constructor, for instance, of let's say this
2049440	2056960	class. The finalize of a malicious subclass can run on the partially constructed object that
2056960	2065360	should have died on the vine. So that was this subclass that extended it. This finalizer can
2065360	2071280	record a reference to the object in a static field, preventing it from being garbage collected.
2071280	2073520	Just a point here. You probably noticed I didn't
2074320	2080800	stole the reference to this resource class anywhere in any static field or didn't really hold the
2080800	2086960	reference in the subclass. The reason for that was because Holger, the answer that I got, said
2086960	2091600	something like this. He said your description is basically correct, but over complicating things.
2092480	2097360	I'm not surprised there. I tend to do that quite a lot. There's no need to store something in a
2097360	2102560	static variable as soon as the finalize method is invoked. The object is already just resurrected
2102560	2107760	as invoking a method on an object implies invoking code with access to the object. That really did
2107760	2111840	make a lot of sense to me because that's exactly what we're doing here in this override method,
2111840	2119040	in the subclass. Storing the object reference in a variable is a way to expand the lifetime
2119040	2124320	beyond the execution of the finalize method. But this is not necessary. But this is not a
2124320	2129680	necessary thing for the attack. Also, instead of using a static variable, the attacker could also
2129680	2135440	make the subclass and inner class and store the reference in the still reachable outer object.
2135440	2139040	So the following program is already enough to demonstrate the issue. So that's the program
2139040	2144080	that I showed to you before, which it's Holger's code. In fact, I just kind of repurposed it and
2144080	2149040	made it a bit more presentable, which is why I haven't done what Joshua Blocker stated here.
2153200	2158480	Once the malinformed object has been recorded, it is a simple matter to invoke arbitrary methods
2158480	2164160	on this object that should have never been allowed to exist in the first place. So that is the
2164160	2168240	arbitrary method, which was critical action that I did invoke.
2170800	2175520	Throwing an exception from a constructor should be sufficient to prevent an object
2175520	2181920	from coming into existence in the presence of finalizes. Unfortunately, it is not. And then he
2181920	2188640	states, which is kind of what I was, I tried to demo here, to protect non-final classes from
2188640	2194960	finalizer attacks, write a final finalize method that does nothing. That's exactly what we can do
2194960	2200800	here. So what you'll see is we have the resource class. And then because the resource class itself
2200800	2207280	obviously has the finalize method, if we create a final protected void finalize, you'll see that
2207360	2213120	it'll throw an error. You can't subclass it because, sorry, you can't override it because
2214080	2220720	this class that inherits that, that subclasses resource class, now can't override it. And that
2220720	2224720	never really solved the problem here. That's one way of protecting ourselves against the finalize
2224720	2228960	method. But the better way is to not use it in the first place. And that, of course, begs the
2228960	2235520	question, given that Joshua Block and the broader Java community, the experts are so adamant as to
2235520	2241280	why one shouldn't use finalizers or cleaners, what is the alternative? What should we use instead?
2242080	2248800	And that's what Joshua Block states here, to use the autoclosable interface. Before I get to
2248800	2254080	what I've written down and taken notes of and kind of try to demo what autoclosable is, let's
2254080	2259280	first go through the definition because that'll set a foundation, let's say.
2259440	2267440	So what should you do instead of writing a finalizer or cleaner for a class whose objects
2267440	2274160	encapsulate resources that require termination, such as files or threads, just have your class
2274160	2279680	implement autoclosable and require its clients to invoke the close method on each instance,
2280320	2286160	when it is no longer needed, typically using try with resources to ensure termination,
2286160	2292720	even in the face of exceptions. So the point on try with resources is in fact the next item.
2292720	2297840	So I shall go into detail as to what try with resources do in the next video.
2297840	2304560	So definition of autoclosable, which enforces encapsulation by Oracle docs is an object that
2304560	2310560	may hold resources such as files or socket handles until it is closed. The close method
2310560	2317200	of an autoclosable object is called automatically when exiting a try with resources block for
2317200	2325360	which the object has been declared in the resource specification header. This construction ensures
2325360	2332560	prompt release avoiding resource exhaustion, avoiding resource exhaustion, exceptions,
2332560	2336720	and errors that may otherwise occur. So let's take a look at a demo. Let's see
2337680	2344160	what at how autoclosable has to be used. Also, there's another caveat he's added here that it's
2344160	2352400	important that when an object has been closed that we should keep track of how if the instance has
2352400	2357760	been closed and we shouldn't rely on the client to do that. It was a bit hard to find a good
2359120	2364480	demo of what this meant. So I did ask a question on Stack Overflow on that too. I asked how to
2364480	2370720	keep track if an instance has been closed with Java autoclosable. I even got a negative
2371360	2376480	download on that question because I realized it's actually quite simple as to how to do that.
2376480	2383280	I just got a thought about it a bit more without being lazy. But nevertheless, I did find an answer
2383280	2390800	and I did post it here. So firstly, the demo, the demo on autoclosable is this. Again, courtesy of
2390800	2396800	Baldang. So we have a demo class which implements autoclosable. And then we have another buffered
2396800	2402480	read instance like the previous one we were going through for the final finalizable class,
2402480	2407680	a similar concept. In fact, the exact class that I've repurposed for this demo.
2409200	2416560	And this here, this Boolean is in fact what does that bit I asked here. It's what keeps track if
2416560	2424320	this instance of, in this case, the demo class has been closed. So when in the constructor,
2424880	2430800	the same way we are accessing a file, reading off the file, creating a new, using a resource reader,
2432560	2438880	and then we're reading the first line, similar thing doing, and we're checking if we can read
2438960	2446240	the first line. And here there's something extra added. We're checking if this resource,
2446240	2453200	so that is reader, has been closed. I think I made a mistake. I said that what this does in line number
2453200	2459200	13 was keep track of if demo class instance has been closed. That is wrong. I apologize.
2459200	2465440	What this keeps track of is if the buffered reader instance has been closed. And that's what we're
2465440	2472000	checking in the read first line method. And if it is closed, we can't access it. So it should
2472000	2478720	throw a illegal state exception. And that's what we're doing here. And then we override the closed
2478720	2489440	method, which is the method in the auto-closable interface. That method right there. And in the
2489440	2494560	class itself, we do the closing. We close that resource. And then, of course, we set the flag
2494560	2500880	to true because now it has been closed. And if not, it'll throw an IO exception, in this case,
2500880	2507520	because it's a buffered reader. So if we go to the unit test, you could see if I'm going to run it,
2511120	2518640	it did pass because all it's going to do is read the line. But of course, if we try to access the
2519200	2524800	resource, read the instance, and it was closed, it would have thrown an error. The test did pass
2524800	2534240	because it's just checking if the line, if this line is this. Oh, I should show the log here, in
2534240	2542400	fact. It's printing this log here, closed buffered reader in the closed method and flag changed to
2542480	2550720	true. So that is this right here. Where is it? I've got so many classes opened up. Oh, yeah.
2550720	2555920	That's printing this bit here, closed buffered read instance, and it's printing the flag, which is
2555920	2561040	true in this case. So that's really, it's quite straightforward, the auto-closable bit and even
2561040	2565920	how it keeps track of how it closes it. I was over-complicating in my head and I was thinking
2565920	2571760	there's some way to do it. In fact, it's tabooly. So despite being told not to use them, and we
2571840	2577280	probably will never have to use them for normal average Java programmers like myself,
2578160	2583680	what really are they useful for? What are they good for? Caviar there, of course, is that as of
2583680	2589280	Java 18 finalizes are in fact deprecated and will be entirely removed in the future. So we'll never
2589280	2595280	use finalizes, but let's say cleaners. What are they really useful for? Firstly, it's for them to
2595280	2603760	act as a safety net. And let's try to understand what that means. One use of Java cleaners,
2603760	2607920	I'm going to stop saying finalizes because it's deprecated, is that one use of that is
2608880	2615040	to act as a safety net in case the owner of a resource neglects to close its, to call its
2615040	2620800	closed method. Well, there's no guarantee that the cleaner or finalizer will run promptly or at all.
2621360	2626640	It is better to free the resource later than never if the client fails to do so. If you're
2626640	2632320	considering writing such a safety net finalizer, think long and hard about whether the protection
2632320	2639520	is worth the cost. So the way I see it, it's just an extra check one adds when writing an API or a
2639520	2646400	class just as a safety net. By overriding that finalize method, we could ensure that any of the
2646400	2652960	resources that should have been closed, sorry, not ensure, we could hope that any of the resources
2652960	2658160	that should have been closed or were closed because of the finalize method, even though
2658160	2662800	it's not a domestic. So that's, it's a trade off one has to make and think about carefully.
2663440	2670320	And then the second use is using it with native peers. What is native peer?
2671280	2676160	As the simplest way to think about it is that native peers are objects that aren't owned by the
2676160	2684000	JVM. They're sort of like a platform specific objects that the JVM runs on, the virtual machine
2684000	2690080	runs on. It could be CEO C++ objects and the JVM can't garbage collect them. And that's why they're
2690080	2694880	called native peers, even though they call peers because the objects still have dependencies on
2694880	2701120	them. But the JVM has no control of these objects in memory. It's quite interesting. I really didn't
2701120	2707120	know much about it. But of course, I found this pretty simple stucco flow answer, which can explain
2707120	2713680	that it said that a native object is not programmed only in Java, but is a, but in a platform specific
2713680	2720240	language, typically CEO assembler, even memory allocated by this code cannot be disposed by the
2720320	2727040	garbage collection by GC. Therefore, you may need to clean it in a finalizer. The native peer is
2727040	2731600	the native part of a Java object. So I'll leave an answer to this question in the description.
2733200	2738720	And that's what I wrote out here by the user Andres on stucco overflow. Thanks for that.
2741040	2747760	And Joshua Block states, a second legitimate use of cleaners concerns objects with native
2747760	2754400	peers. A native peer is a native non Java object. That's an important point to which a normal object
2754400	2761680	delegates via native methods. Because a native peer is not a normal object, the garbage collector
2761680	2766240	doesn't know about it and can't reclaim it when the Java peer is reclaimed.
2768160	2773760	A cleaner or finalizer may be an appropriate vehicle for this task, assuming the performance
2773760	2778400	is acceptable and the native peer holds no critical resources.
2780560	2786560	Saying that finally, we, we in fact get to some actual code in this item, because the other code
2786560	2794320	I showed was code that I wrote and I kind of use from other people. And that is this room class,
2794320	2800960	which demonstrates the concept of it being a safety net by implementing auto closeable. Yeah.
2801120	2808240	So the class is called room. And I do appreciate that pun there because the room must be cleaned
2808240	2814480	before being reclaimed. I like that. I appreciate that. And it implements, as I said, auto closeable.
2815120	2822560	It's got a private static final cleaner, which cleans. And this in a class,
2823440	2832800	which implements runnable is what holds the resources required by cleaner to clean the room.
2834000	2839680	So this in a class is in fact what does the cleaning in a separate thread in the background
2839680	2846480	of this broader class. So what you can see is we're simply registering the cleanable instance
2847440	2853680	with with with the state, which is a variable we hold here in line number 34 and register it.
2853680	2860080	We assign it. And after that, the number of junk piles should be set to zero. And the way that happens
2860080	2869680	is the close method, which is what we override from the auto closeable interface that will invoke
2870480	2875760	the run method, which is inclinable. So once we register it with the with the with the object
2875760	2881360	itself and then the state. So this refers to the current object and then in the state of the room
2882480	2891920	that we pass into the uh, we pass the we invoke the clean method of the of the cleanable instance.
2892560	2898000	And the clean method, what that does is it triggers the run method that sets the number
2898000	2903920	of junk piles to zero. So every time before it's reclaimed, it has to clean all the resources. Now
2903920	2908800	I didn't I think I don't think I did a good job at explaining that. It's a bit difficult to explain
2908800	2917120	because I I lack the verbal visual city and a deep understanding of how cleaner works. Therefore,
2917120	2923120	probably what I'll do is I'll go through Joshua Bloch's description or sorry, his elucidation
2923120	2929520	and then I shall refer to the code as I read them out and kind of learn it live, let's say,
2929520	2935680	which is exactly what I'm doing in this video series. The the room class implements auto close
2935680	2944640	book that I showed here. The fact that it's automatic cleaning safety net uses a cleaner is
2944640	2951600	merely an implementation detail. Unlike finalizes cleaners do not pollute across this public API.
2951600	2957280	That's correct, which is why it's a bit hard to see at first because I'm using it as a client.
2957840	2964240	The static nested state class holds the resources that are required by the cleaner to clean the room.
2964240	2970560	So that is the static nested state class. Also, to understand how nested classes work, just go and
2970560	2977600	read these docs in Oracle. It's pretty simple. It's it's a it's an inner class. I'll leave a link to
2977600	2984000	that in the description. It's got access to all the properties of the outer class in this case.
2987600	2996640	And then and then he continues. And then he continues in this case, it is simply the number of junk
2996640	3001680	piles field, which we need to clean up, which you shall see we're going to be doing this integer value,
3004080	3010480	which represents the amount of mess in the room. Yep. State implements runnable. So you can see
3010480	3015840	here it's going to implement runnable because we need to run this in the background. And its run
3015840	3022960	method is called at most once. So this method, which we're overriding is called at most once and
3022960	3032320	that is this one method is from runnable because we're running a new thread by the cleanable that
3032320	3038320	we get when we register a state instance with our cleaner in the room's constructor. So that that bit
3038320	3043920	here is done right here in the cleanable, which is what I said that we're doing the registering
3043920	3052160	as we create this new state by passing the number of junk files, junk piles, sorry. And that's what
3052160	3057360	we're passing onto this and doing the registering, which is what invokes that run method eventually.
3060160	3066880	The call to the run method will be triggered by one of two things. Usually it is triggered by
3066960	3073440	call to room's close method, calling cleanable's clean method. So that's the close method,
3073440	3079360	which we have overridden here of the out-of-class room. If the client fails to call the close
3079360	3085280	method by the time a room instance is eligible for garbage collection, the cleaner will hopefully
3085280	3092160	call state's run method. So that's what he meant by a safety net because if the client doesn't
3092880	3096880	call the close method and clean up that resource or clear up that resource,
3098720	3101840	then we expect this run method to run, hopefully.
3104000	3109040	It is critical that a state instance does not refer to the room instance. That's important and we
3109040	3113680	shall see why. If it did, it would create a circularity that would prevent the room instance
3113680	3118720	from becoming eligible for garbage collection and from being automatically cleaned. Yes,
3118720	3122480	because for it to be eligible for garbage collection, we have to make sure that there
3122480	3128480	aren't any references to that object in memory. Therefore, state must be a static nested class
3128480	3133520	because non-static nested classes contain references to the end-closing instances,
3133520	3139520	which is why exactly we've declared this static and I said to do some reading on nested classes
3139520	3143520	as to how the difference between non-static and static in the Oracle docs.
3144240	3152720	And then we shall take a look at how this class is used. So if we take a look at, let's say,
3152720	3160000	teenage up, we're doing some garbage collection manually, explicitly, but we should not depend
3160000	3167520	on this behavior. So if I go run this and run this, in fact, first let's take a look at adult,
3167520	3173360	sorry, where we're using a tri-width resource. So the room's cleanest used only as a safety net.
3173360	3180400	If clients surround all room incantations with tri-width resource blocks, automatic
3180400	3186160	cleaning will never be required. So as you can see here, I'm not, or just your block in this
3186160	3192080	case isn't doing any explicit garbage collection because we've used it with a tri-width resource
3192080	3198880	block. And if I run this, you will see it says goodbye, but also says cleaning the room. So the
3198880	3205520	object's created and it prints goodbye. But afterwards, this cleaning the room along comes from
3210160	3215440	this run method here, which we've all written and written. And that also means that the number
3215440	3220560	of chunk passes zero. So in fact, if you want to print out the number of chunk pass just to,
3220560	3222800	just to make sure that we know what's going on
3228880	3232400	and run that again, you will see it's going to print zero.
3236800	3243200	Yeah, there we go. It printed zero. That's what we expected. But then if you go take a look at the
3243200	3248800	teenager's room and if you run it, it will not run it unfortunately. Oh, it did, but it's kind of
3249120	3254560	so I'm going to try it again. I'm going to keep trying it until it does not run it. Oh, actually,
3254560	3259920	sorry. If I comment the garbage collection, because I had that uncommented, it should have
3259920	3265760	been commented out. Now it shouldn't run it. You see that it just printed our piece out,
3265760	3270960	but there was no cleaning done. And then when I do the garbage collection explicitly,
3271760	3277520	now it's going to print cleaning room. And that's what we expect. And that was though,
3277520	3280560	that cleaning room was imprinted from the previous line.
3283920	3288400	Sorry, it was printed off the previous line, of course, because it ran the run method, but
3289680	3294080	because we did do the garbage collection, that doesn't exist anymore. The memory was cleared.
3296000	3303840	And that's virtually it. That's kind of the utilities of using auto-closable and how it's
3303840	3308320	got to be used and why it's preferred over, let's say, using a final asset, for example. And then
3309760	3316400	just to conclude that point and of that demo, Joshua Block states, you might expect it to print
3316400	3323760	piece out, followed by cleaning room. But on my machine, it never prints cleaning room. It just
3323760	3330480	exits, which is kind of, well, that was before we did do the explicit garbage collection.
3331120	3337360	This is the unpredictability we spoke of earlier. The cleaner spec says, the behavior of a cleaner
3337360	3343520	during system.exit is implementation specific. No guarantees are made relating to whether
3343520	3349200	cleaning actions are invoked or not. While the spec does not say it, the same holds true
3349200	3358080	for normal program exit. On my machine, which is what we did here, adding the line system.gc
3358560	3365200	to teenagers main method is enough to make it print cleaning room prior to exiting. The reason we
3365200	3371840	didn't see that log here in line number 30 is because the moment it cleaned the room and cleared
3371840	3377200	out the resources, it exited and it doesn't really exist in memory anymore. So I repeat that point
3377200	3383840	again, on my machine, adding the line system.gc to teenagers main method is enough to make it print
3383840	3388320	cleaning room prior to exit. But there's no guarantee that you'll see the same behavior on
3388320	3394400	your machine, which is exactly why Joshua Bock states here to test the behavior. But note that
3394400	3402560	you must not depend on this behavior. Again, not to be on that horse, but the biggest problem is
3402560	3407600	the non-determinism. And we don't want that in programming. We want things to be logical and
3407600	3414640	deterministic as script programmers. And in summary, he states, don't use cleaners or in
3414640	3422480	releases prior to Java 9 finalizes, except as a safety net or to terminate non-critical native
3422480	3429920	resources. Even then, be aware the indeterminacy and performance consequences. That's it. That
3429920	3437200	was item number eight, avoid finalizes and cleaners. I hope I did a good job at demoing
3437200	3442640	certain parts of it. As you all know with these tutorials, the best way to understand it is to
3443600	3448880	after watching them or while watching them goes through the code base, because that's the best
3448880	3455920	way to grok these concepts. But nevertheless, I hope my efforts were worth it. I will try and
3455920	3461040	keep enduring and getting through this whole book because I'm really enjoying it. I'm learning a lot,
3461040	3465760	but also I want to kind of get into the habit of putting out these videos
3467040	3470720	in a certain schedule, let's say, at least once every two weeks.
3472080	3476080	But thanks a lot for watching. I hope you gained some value from it and learned something.
3476080	3478880	I'll see you in the next item. Cheers.
