1
00:00:00,000 --> 00:00:07,200
Hey everyone, welcome to yet another episode of my video series on Joshua Block's effective Java

2
00:00:07,560 --> 00:00:09,560
where I cover and

3
00:00:09,560 --> 00:00:15,200
Expound on the items that he has emulated in this book and of course

4
00:00:15,840 --> 00:00:20,160
what I've been trying to do in the previous videos or episodes is to

5
00:00:21,120 --> 00:00:26,480
Flesh out and try and make sense of what he's talking about in the different items in this book and

6
00:00:27,160 --> 00:00:30,300
Hopefully as I try to make sense of them the purpose of me

7
00:00:30,720 --> 00:00:37,320
Sharing this publicly and uploading these videos is that you too can gain some value from it. That's one

8
00:00:37,320 --> 00:00:39,320
I would say that's a primary purpose

9
00:00:39,760 --> 00:00:46,400
But the other is of course that there's that sublime effect where by me trying to teach someone a

10
00:00:46,960 --> 00:00:48,960
concept that I really

11
00:00:49,360 --> 00:00:52,320
Fundamentally don't still properly grok or understand

12
00:00:53,240 --> 00:00:59,800
Paradoxically, I understand it better. So yep, it's it is sublime indeed and it works well

13
00:01:00,680 --> 00:01:04,440
Say all that without further ado, let's get started. So as per usual

14
00:01:04,440 --> 00:01:07,380
I'm gonna repeat the introduction that I've sort of

15
00:01:08,080 --> 00:01:13,200
Repeated in all the other episodes. I just feel like I need to do that kind of due diligence as a sort of ethical duty

16
00:01:13,200 --> 00:01:14,480
Let's say

17
00:01:14,480 --> 00:01:19,320
So if you do want to skip it, of course, please go ahead because I'm just repeating the same old points

18
00:01:19,320 --> 00:01:21,120
I don't want to waste your time

19
00:01:21,160 --> 00:01:26,000
This is not a tutorial. That is the first caveat in this proviso. This is not a tutorial

20
00:01:26,000 --> 00:01:29,000
I am not a teacher and I certainly am non-expert

21
00:01:29,560 --> 00:01:34,320
in fact a point that I've been repeating ad nauseam is that the more I've

22
00:01:35,000 --> 00:01:37,320
Understood Java and the concepts

23
00:01:37,880 --> 00:01:41,680
He's outlining this book Java and OP in general

24
00:01:42,400 --> 00:01:48,080
I'm realizing how much of an expert I'm not so that's really interesting and very humbling indeed

25
00:01:48,080 --> 00:01:51,480
And I don't mean that in a false modest sense. I mean, that's sincerely

26
00:01:52,120 --> 00:01:55,320
An analogy or yeah, probably an algae

27
00:01:55,320 --> 00:02:02,240
I'd like to use to explain what I'm trying to do here is the blind living the blind. I am as naive or perhaps even more

28
00:02:02,880 --> 00:02:04,720
blind and

29
00:02:04,720 --> 00:02:06,720
ignorant and naive and oblivious all of those

30
00:02:07,320 --> 00:02:09,320
things

31
00:02:10,040 --> 00:02:16,600
As as much as you are and yeah, even probably even more. So this is not my tutorial

32
00:02:16,600 --> 00:02:18,600
I'm not trying to teach you anything

33
00:02:18,840 --> 00:02:22,920
So whatever I say, please do take it with a grain of salt. This is a

34
00:02:24,080 --> 00:02:24,880
Exploratory

35
00:02:24,880 --> 00:02:29,320
Disquisition another analogy. I've been using as what one would see in a

36
00:02:30,280 --> 00:02:33,400
University tutorial where we've got a tutor

37
00:02:34,720 --> 00:02:38,280
bunch of students trying to make sense of and understand a

38
00:02:39,040 --> 00:02:44,280
problem statement or some some programming principle, which is why unequivocally I will

39
00:02:44,800 --> 00:02:48,760
Inevitably make mistakes. So please point them out not just for my sake

40
00:02:48,760 --> 00:02:54,360
But even for anyone that's watching these videos if I do make a very fundamental

41
00:02:55,200 --> 00:02:57,200
Crucial mistake

42
00:02:57,200 --> 00:03:00,240
I'll try my best to be rectified by leaving a comment myself

43
00:03:00,240 --> 00:03:05,400
But if you do pick it up, I shall pin those comments just so that I don't mislead anyone

44
00:03:06,920 --> 00:03:08,920
With any

45
00:03:10,160 --> 00:03:12,400
Fake news to use a politically

46
00:03:13,400 --> 00:03:20,640
Overloaded term and of course as this is a programming video series all the code that I've been using for this effective Java series

47
00:03:20,640 --> 00:03:25,160
It's available on my GitHub. I've got a separate repository for each item and

48
00:03:26,280 --> 00:03:29,640
As I go through these all the code will be published here

49
00:03:29,920 --> 00:03:34,280
Anyway, now that we got the proviso out of the way, let's get started with item number six

50
00:03:34,840 --> 00:03:36,840
where Joshua block states

51
00:03:37,440 --> 00:03:39,440
Avoid creating

52
00:03:39,440 --> 00:03:42,640
unnecessary objects and this is quite an interesting one because

53
00:03:43,600 --> 00:03:46,840
I certainly am guilty of doing this of making these mistakes

54
00:03:47,600 --> 00:03:51,120
So it's it's valuable and worth our time. I think that's

55
00:03:51,880 --> 00:03:55,640
Java or generally OOP programmers to

56
00:03:56,240 --> 00:04:01,960
Understand why, you know, just sort of creating objects at a hawk without putting any thought into it

57
00:04:02,120 --> 00:04:05,160
There's a bad idea and perhaps even an anti-pattern

58
00:04:05,760 --> 00:04:09,880
Of course, this we are still in chapter 2 in creating and destroying objects

59
00:04:10,280 --> 00:04:16,200
So before we get to any of the content in the book, I kind of want to get some fundamentals real

60
00:04:16,920 --> 00:04:18,920
OOP basics out of the way

61
00:04:19,440 --> 00:04:21,760
Look, if you don't know what objects are this

62
00:04:22,640 --> 00:04:28,240
Video series really probably is a bit above your level. I'd say go and watch some basic

63
00:04:29,040 --> 00:04:33,720
OOP fundamental videos on YouTube just watch like a basic tutorial, but

64
00:04:34,200 --> 00:04:42,080
The definition we all hear of an object is that it is an instance of a class and the class is what acts as a blueprint

65
00:04:42,440 --> 00:04:44,440
as to how it defines

66
00:04:45,360 --> 00:04:49,000
How an object behaves when it is instantiated

67
00:04:49,600 --> 00:04:55,000
but something a bit more formal is the definition by the oracle docs and

68
00:04:55,760 --> 00:04:57,760
He goes like this

69
00:04:58,000 --> 00:05:03,920
Software objects are conceptually similar to real-world objects. That is true something. I truly

70
00:05:04,360 --> 00:05:09,720
Admire and appreciate about object oriented programming. I think it's brilliant that they've created that connection

71
00:05:10,080 --> 00:05:12,920
In fact, sorry to go off on a tangent here

72
00:05:13,600 --> 00:05:15,600
if you do start

73
00:05:16,480 --> 00:05:21,920
Following some of the design patents a bit more seriously so for instance the 23 patents

74
00:05:22,680 --> 00:05:26,160
popularized by the Gang of Four you'd see a lot of those patents to

75
00:05:26,880 --> 00:05:32,040
Have many deep connections to engineering patents in the world

76
00:05:32,800 --> 00:05:40,360
That's let's say not the conventional. Sorry the the the the conventional world which doesn't invoke which doesn't

77
00:05:41,160 --> 00:05:46,520
Attain to software engineering, but sort of the let's say civil engineering or some other kinds of engineering

78
00:05:47,280 --> 00:05:50,640
Anyway, sorry. Sorry. I'm going off on a tangent back to the definition

79
00:05:50,800 --> 00:05:57,600
Software objects are conceptually similar to real-world objects. They too consist of state and related behavior and

80
00:05:58,440 --> 00:06:01,440
Objects totes so it's state in fields

81
00:06:01,600 --> 00:06:10,240
Which are variables in some languages and exposes its behavior through methods of course and we shall see a few examples of that in this item

82
00:06:10,960 --> 00:06:12,960
Which are called functions in some languages

83
00:06:13,800 --> 00:06:19,120
methods operate on an object's internal state and serves as the primary mechanism

84
00:06:19,880 --> 00:06:21,880
for object-to-object communication

85
00:06:22,840 --> 00:06:30,720
Hiding internal state and requiring all interaction to be performed through an object's methods is known as data

86
00:06:31,360 --> 00:06:35,600
Encapsulation a fundamental principle of OOP or object going to programming

87
00:06:35,600 --> 00:06:41,520
So once again, if you don't know what encapsulation is what inheritance is those really fundamental ideas in OOP

88
00:06:41,520 --> 00:06:44,240
I think this video is a bit above your level

89
00:06:45,000 --> 00:06:48,840
Yeah, so that's probably should be caveat for this item in particular

90
00:06:49,560 --> 00:06:56,280
Okay, so now let's try to understand from a JVM and memory management perspective

91
00:06:56,280 --> 00:07:00,200
Well more from a JVM perspective. We're not gonna go too deeply into memory management

92
00:07:00,880 --> 00:07:04,120
how these objects exist at least

93
00:07:05,400 --> 00:07:13,760
Apropos the Java virtual machine now again, you would know what the JVMS JVM is what allows to execute Java code on

94
00:07:14,160 --> 00:07:17,160
Any any machine, which is what makes Java

95
00:07:17,960 --> 00:07:22,560
Quite popular because it can work on any operating system for instance

96
00:07:23,360 --> 00:07:24,600
so

97
00:07:24,600 --> 00:07:29,680
We have the call stack of course. Here's where we make calls or we give instructions

98
00:07:30,160 --> 00:07:33,520
To call different objects and whatnot our different methods. Sorry

99
00:07:34,680 --> 00:07:42,160
And the JVM primarily divides the memory into two two spaces or two domains now, of course

100
00:07:42,160 --> 00:07:44,480
Oops, I had the microphone now, of course

101
00:07:45,480 --> 00:07:52,440
It's okay. So firstly, it's the stack memory and the heap space now, of course these two high-level

102
00:07:55,040 --> 00:08:02,200
Demarcations also further divided into let's say sub-domains so the heap space for instance would have the dynamic meta space

103
00:08:03,000 --> 00:08:05,720
Which holds static content and we'll get to that too

104
00:08:07,520 --> 00:08:12,000
So the stack memory is used for static memory allocation, that's correct

105
00:08:12,000 --> 00:08:17,640
What static memory allocation sort of means for all intents and purposes is that an object created?

106
00:08:18,040 --> 00:08:23,120
Statically, let's say once it's in memory. It will remain in that state

107
00:08:23,640 --> 00:08:28,960
Throughout the application lifecycle, whereas dynamic objects change state

108
00:08:28,960 --> 00:08:32,560
They can change and they don't live in the stack memory

109
00:08:33,440 --> 00:08:34,640
so

110
00:08:34,640 --> 00:08:36,640
Also the the stack memory

111
00:08:37,040 --> 00:08:40,960
Again pretending to the JVM and Java holds primitive values

112
00:08:40,960 --> 00:08:43,920
So values like int or char

113
00:08:44,600 --> 00:08:46,680
These types live in the static memory

114
00:08:47,480 --> 00:08:50,320
and of course as I said before it

115
00:08:50,840 --> 00:08:53,200
Well, I don't think I did say that before anyway

116
00:08:53,640 --> 00:08:59,800
There are references to dynamic objects that live in the heap space now look all these definitions are fine

117
00:09:00,040 --> 00:09:03,600
For starters, but the best way to make sense of it is of course to an example

118
00:09:04,160 --> 00:09:08,200
So if we take person here this in the person method

119
00:09:08,800 --> 00:09:09,920
this

120
00:09:09,960 --> 00:09:16,360
Int value that you're passing that would live because it's a primitive type and it's a primitive

121
00:09:17,320 --> 00:09:20,680
Variable that would live in the stack memory

122
00:09:21,800 --> 00:09:26,040
Also, I apologize if I did say static memory before I should have said stack memory

123
00:09:26,640 --> 00:09:31,880
And then string which is a class and it's you know a class you can create an instance of that class

124
00:09:32,560 --> 00:09:37,080
What would live in the stack memory in that case wouldn't be the object itself

125
00:09:37,080 --> 00:09:44,520
but rather a memory address or a reference to the actual object which lives in the heap space in the string pool in this instance

126
00:09:44,680 --> 00:09:49,320
So and that's dynamic its state can change unlike some of the

127
00:09:50,080 --> 00:09:51,640
static types

128
00:09:51,640 --> 00:09:53,000
so

129
00:09:53,000 --> 00:09:58,920
Yeah, as I've written down here. There's a few notes. I took just to make sure that I stay on track. It's

130
00:10:00,240 --> 00:10:05,600
It's used for dynamic memory allocation of Java objects and GRE classes at one time

131
00:10:05,600 --> 00:10:08,160
So that means when applications running its state can change

132
00:10:09,440 --> 00:10:17,480
Also new objects which sometimes seem to be short-lived live live in the heap space. I shouldn't just say it outright

133
00:10:18,040 --> 00:10:20,040
Tends to be short-lived. There are

134
00:10:20,600 --> 00:10:23,800
some long-lived objects and here's where you know

135
00:10:24,520 --> 00:10:30,400
The different algorithms in garbage collection so that that's garbage collection is essentially essentially

136
00:10:30,880 --> 00:10:38,440
Memory management here. Here's where different algorithms play a role and allocate objects into you know, like for example the permanent space

137
00:10:38,440 --> 00:10:42,320
I think it used to be called like the nursery different parts of the

138
00:10:43,120 --> 00:10:49,200
The heap space. I'm not gonna go into that. This is this this video is gonna be way too long if you're getting to memory management and Java

139
00:10:49,720 --> 00:10:51,720
but the point is

140
00:10:51,720 --> 00:10:53,720
these objects are dynamic and

141
00:10:54,680 --> 00:10:57,960
They the references for them are stored again in stack memory

142
00:10:58,960 --> 00:11:00,480
And

143
00:11:00,480 --> 00:11:05,560
On that note, of course now that we understood sort of how objects exist at a very very high level

144
00:11:06,000 --> 00:11:08,000
Pertaining against Java and JVM

145
00:11:08,200 --> 00:11:14,520
Let's get to the item and the item essentially is telling us how to reuse objects and why in fact it's better

146
00:11:14,960 --> 00:11:20,280
To reuse objects than creating new ones and how doing so will make the code

147
00:11:20,960 --> 00:11:27,920
Cleaner more stylish more professional if you could use that term and even as we shall see with some examples

148
00:11:28,320 --> 00:11:31,560
Make the code run faster and that definitely is a benefit

149
00:11:31,560 --> 00:11:35,920
So the book starts off with a rather ridiculous example as what not to do

150
00:11:35,920 --> 00:11:42,080
So as Joshua Block has pointed out he has left the comments in an extreme example of what not to do

151
00:11:42,080 --> 00:11:45,480
I've never seen this done by any programmer to be honest, but

152
00:11:46,160 --> 00:11:53,760
This certainly isn't something one has to do where when we already have this string. We create another instance by using a new keyword

153
00:11:54,520 --> 00:11:57,120
This is sort of how most of us do it

154
00:11:57,120 --> 00:11:59,120
So the proper way

155
00:11:59,960 --> 00:12:03,680
The improved version he calls it, but let's just say it's a proper way and

156
00:12:04,800 --> 00:12:06,800
Here's what Joshua Block states

157
00:12:07,000 --> 00:12:15,280
The statement creates a new string instance each time it is executed and none of those objects object creations is necessary because

158
00:12:15,480 --> 00:12:18,000
So bikini can live here and

159
00:12:19,080 --> 00:12:24,160
Then it could just point to that all the all the references one one object can exist in the

160
00:12:24,720 --> 00:12:33,440
Heapspace, but if you have this new keyword every single time it's invoked a new object is created and that is a completely inefficient

161
00:12:34,080 --> 00:12:35,680
and

162
00:12:35,680 --> 00:12:37,680
ridiculous waste of space and time

163
00:12:39,120 --> 00:12:47,040
The argument to sorry I'll show it scroll down the argument to the string constructor bikini is itself a string instance that is correct

164
00:12:48,040 --> 00:12:56,800
Functionally identical to all of the objects created by the constructor if this usage occurs in a loop or in a frequent frequently invoked

165
00:12:57,400 --> 00:12:58,600
method

166
00:12:58,600 --> 00:13:01,760
Millions of string instances can be created needlessly

167
00:13:02,160 --> 00:13:06,400
So here's an example of what he definitely shouldn't do and just like the Bible

168
00:13:06,400 --> 00:13:11,920
We're gonna go from the Old Testament where what the goat says what he shouldn't do and in our case the Java code

169
00:13:12,080 --> 00:13:19,920
Joshua Block tells us don't don't do this. That shall not do this to the New Testament what you should do and what you should consider

170
00:13:20,680 --> 00:13:23,880
on when when writing code as to how

171
00:13:24,360 --> 00:13:27,720
These techniques can allow us to reuse objects

172
00:13:28,480 --> 00:13:31,880
It's interesting how I just converted this into a theology session

173
00:13:34,320 --> 00:13:39,280
So the first way one could easily reuse objects is something we already covered in

174
00:13:39,360 --> 00:13:43,960
In at item one is in fact using static factory methods

175
00:13:43,960 --> 00:13:47,160
I should say as Joshua Block stays here. In fact, I'll just read it out

176
00:13:47,160 --> 00:13:53,160
You can often avoid creating unnecessary objects by using static factory methods in

177
00:13:53,840 --> 00:13:57,520
preference to constructors when immutable classes that provide both

178
00:13:58,040 --> 00:14:05,760
So the example here would be the Boolean class where value of is a static method and that is indeed preferred over

179
00:14:06,400 --> 00:14:07,480
using

180
00:14:07,520 --> 00:14:12,960
The constructor and I think since Java 9. Yes, it does say here

181
00:14:13,440 --> 00:14:18,520
This has been deprecated. We can't even use this constructor because it's been made private. So

182
00:14:19,160 --> 00:14:25,200
The the static factory method doesn't require a creation of objects every time it's invoked

183
00:14:26,240 --> 00:14:31,680
Because static members are common to all instance instances of a class and again the way I think about it

184
00:14:31,680 --> 00:14:36,600
Oh, I guess this is exactly the way one should think about it is it belongs to the class

185
00:14:37,440 --> 00:14:42,400
Therefore, all the instances of that class will will share this

186
00:14:43,360 --> 00:14:44,680
Static member

187
00:14:44,680 --> 00:14:51,680
So that member itself can be shared up amongst all objects whenever that class is instantiated and

188
00:14:52,800 --> 00:14:54,800
As I did mention a bit before

189
00:14:54,840 --> 00:15:01,640
Static variables live in something called the dynamic meta space within heap memory and also an ancillary point

190
00:15:01,640 --> 00:15:05,640
He also adds in addition to reusing immutable objects

191
00:15:05,640 --> 00:15:10,200
You can also reuse immutable objects if you know they won't be modified. So

192
00:15:10,800 --> 00:15:13,760
For reusing objects, they don't have to all be declared

193
00:15:14,480 --> 00:15:15,960
final and

194
00:15:15,960 --> 00:15:21,640
Static and make for them to be mutable rather even if we know a certain object is

195
00:15:22,920 --> 00:15:27,880
Mutable, but still it won't change. We could reuse that using static factory methods

196
00:15:28,640 --> 00:15:34,860
So there could be some operations where it's much more computationally expensive to keep

197
00:15:36,080 --> 00:15:40,680
Invoking a certain function and here's the example Joshua block has used

198
00:15:40,680 --> 00:15:44,920
So before I do get to the example, probably I'll just go through his justification

199
00:15:45,160 --> 00:15:50,400
He says some object creations are much more expensive than others. That's right

200
00:15:50,400 --> 00:15:54,600
If you're going to need such an expensive object repeatedly

201
00:15:54,640 --> 00:15:58,120
It may be advisable to cache it for reuse

202
00:15:59,120 --> 00:16:03,760
Unfortunately, it's not always obvious when you're creating such an object. That is true

203
00:16:03,760 --> 00:16:09,840
However, here we have a solid example where this could be computationally expensive and that is

204
00:16:10,600 --> 00:16:12,600
using regular expressions

205
00:16:12,760 --> 00:16:15,440
So this is a very very simple class

206
00:16:16,000 --> 00:16:20,280
Well, what it does. Well, the class has these static methods

207
00:16:20,960 --> 00:16:22,960
we have well

208
00:16:23,960 --> 00:16:28,680
Practically it should only have one method called is numeral, but just for

209
00:16:29,240 --> 00:16:31,960
Demonstrative purposes we have is numeral slow and

210
00:16:32,560 --> 00:16:36,920
It's numeral fast and we shall see why we have those two methods in a bit

211
00:16:38,120 --> 00:16:43,480
So firstly the slow method what it does. Okay, so let me let me take a step back

212
00:16:45,160 --> 00:16:49,080
What this method does is it returns a true or false and

213
00:16:49,160 --> 00:16:54,440
And what that true or false tells us is if a string we pass on to this

214
00:16:55,080 --> 00:16:57,080
fulfills a certain regular expression

215
00:16:57,880 --> 00:17:04,040
And what that regular expression is looking for really is if the string we pass on to is a Roman Roman numeral

216
00:17:05,080 --> 00:17:06,440
and

217
00:17:06,440 --> 00:17:15,000
Here here though, this is the slow way what happens here is every single time we invoke this method and we pass the string

218
00:17:15,680 --> 00:17:18,600
The the the string class invokes the matches

219
00:17:20,080 --> 00:17:24,360
Method which uses a finite state machine

220
00:17:25,240 --> 00:17:30,160
Which we shall we shall get into what that is a finite state machine to do the matching

221
00:17:30,720 --> 00:17:37,440
And and that is computationally expensive. So every single time a pattern instance has to be created here

222
00:17:38,080 --> 00:17:44,320
A pattern instance really that won't change but for we know that why would we not reuse it

223
00:17:44,320 --> 00:17:46,320
But every single time the method is invoked

224
00:17:46,640 --> 00:17:51,840
We're creating this finite state machine instance and then after it's done

225
00:17:51,840 --> 00:17:57,720
It has to be garbage collected and the JVM has to take care of it. So that is computationally expensive. So this is a slow way

226
00:17:58,480 --> 00:18:03,920
But what he does propose instead is to cash it. So we have the regular expression instance

227
00:18:04,000 --> 00:18:05,560
We call that

228
00:18:05,560 --> 00:18:12,760
Roman here and we use this compile method in the pattern class and we explicitly compile it into an immutable pattern instance

229
00:18:12,760 --> 00:18:18,520
Which we still here and we call it Roman as I said and then we just reuse that in the esnemeral fast method

230
00:18:18,840 --> 00:18:20,760
Simple as that and to put it most succinctly

231
00:18:20,760 --> 00:18:26,560
He states while string dot matches is the easiest way to check if a string matches a regular expression

232
00:18:26,600 --> 00:18:28,800
Which is what we've sort of done here

233
00:18:30,480 --> 00:18:34,920
It's not suitable for repeated use in performance critical situations

234
00:18:35,200 --> 00:18:39,000
He continues creating a pattern instance is expensive

235
00:18:39,320 --> 00:18:40,960
Because it requires

236
00:18:40,960 --> 00:18:44,760
Compiling the regular expression as I said into a finite state machine

237
00:18:44,760 --> 00:18:50,280
So let's get a quick understanding of what a finite state machine encompasses because it pertains to the topic

238
00:18:50,520 --> 00:18:54,280
This is definition. I found from brilliant org by

239
00:18:54,840 --> 00:18:57,480
Kale more and Deshan Gupta is a

240
00:18:58,040 --> 00:19:02,720
system where particular inputs cause particular changes in state can be

241
00:19:03,160 --> 00:19:07,480
represented using a finite state machine or using finite state machines and

242
00:19:07,960 --> 00:19:14,520
This is a really good example. I found it was a 10 minute video by Valhalla data systems and the book here

243
00:19:14,520 --> 00:19:20,880
He not only explains quite simply with brevity what a finite state machine is

244
00:19:20,920 --> 00:19:24,960
But also afterwards shows a solid implementation in Java code

245
00:19:25,040 --> 00:19:29,120
So I'll leave a link to that video down in the description. It's well worth a watch

246
00:19:29,120 --> 00:19:31,560
But this is one snapshot of the video

247
00:19:32,160 --> 00:19:38,000
And here's what happens. So when we pass a string, which is really a an array of characters in Java

248
00:19:38,600 --> 00:19:43,280
It'll take each character and start going through the FSM

249
00:19:43,280 --> 00:19:46,680
I'm just gonna call it FSM because it's finite state machine is a mouthful

250
00:19:47,800 --> 00:19:54,240
So it's gonna start off with with state zero and if it's an at sign it'll go to one

251
00:19:54,240 --> 00:19:56,240
Oh, by the way, this

252
00:19:56,680 --> 00:20:00,600
pattern it's looking for is simply for an at sign or a hashtag. So this has nothing to do with

253
00:20:01,120 --> 00:20:03,640
the reg X given here because this is for

254
00:20:04,320 --> 00:20:08,360
Checking if it's a Roman numeral, but this is a different example. Just so you don't get confused

255
00:20:08,960 --> 00:20:13,560
So all it's looking for is if the string contains an at sign or a hashtag

256
00:20:14,000 --> 00:20:19,440
So it starts as I said with state zero if it contains an at sign goes to state one

257
00:20:20,040 --> 00:20:25,880
If it's a number between or an integer to use proper terminology between zero and nine

258
00:20:25,880 --> 00:20:29,320
It'll go to state two if it's a hashtag. It'll go to state three

259
00:20:29,920 --> 00:20:35,960
And it sort of loops it will remain in that state because so if it's an at sign it'll go back to state one

260
00:20:36,240 --> 00:20:37,400
so

261
00:20:37,400 --> 00:20:39,400
For all the intents and purposes

262
00:20:39,720 --> 00:20:46,480
This state represents at signs this state represents the hashtags and this represents integers

263
00:20:47,120 --> 00:20:51,440
That's really what a FSM is but for our problem

264
00:20:51,440 --> 00:20:55,280
We don't want this computation happening every single time this method is involved

265
00:20:55,280 --> 00:21:02,040
Which is why we create one instance and we store that object with its state in a constant

266
00:21:02,160 --> 00:21:04,160
This is our constant I declared in Java

267
00:21:05,120 --> 00:21:12,200
So let's look at the time differences. Now firstly, I'll invoke the slow method if I run this program

268
00:21:14,160 --> 00:21:19,060
You'll see that's how long it takes. Let me zoom in a bit there. So this is

269
00:21:19,560 --> 00:21:22,440
Millions seconds, isn't it? This is it's always in nanoseconds

270
00:21:23,440 --> 00:21:26,720
Man, I'm not even sure. I think this is a nanoseconds. I

271
00:21:27,280 --> 00:21:29,280
Looked it up, but in fact both my

272
00:21:29,800 --> 00:21:36,920
Options were wrong. It's actually microseconds. There you go. That's my ignorance. So it takes around 115 microseconds

273
00:21:37,520 --> 00:21:41,960
For this function to run and now if we do change it to fast

274
00:21:43,760 --> 00:21:50,560
Now keep in mind what the fastest what this method does is that it doesn't invoke the matches method in

275
00:21:51,560 --> 00:21:53,680
Well, sorry, it doesn't work the matches method

276
00:21:53,680 --> 00:21:58,840
But it isn't compile a new pattern every single time because we just use the cached Roman

277
00:21:59,840 --> 00:22:03,340
Instance here. So if we run that it'll be much faster

278
00:22:04,120 --> 00:22:05,760
There you go

279
00:22:05,760 --> 00:22:07,360
half the time

280
00:22:07,360 --> 00:22:10,760
60 milliseconds 12 milliseconds for the next computation and

281
00:22:11,320 --> 00:22:18,560
Joshua block states in his machine. It was for a eight character input string. It was six six point five times faster

282
00:22:18,920 --> 00:22:27,280
Which is why he says the improved version is of is numeral provides significant performance gains if invoked frequently

283
00:22:27,640 --> 00:22:31,560
Then it continues and that's a really good point. He sort of touched on this in

284
00:22:32,600 --> 00:22:35,800
the in item number one where you could in fact give

285
00:22:37,160 --> 00:22:41,760
Static methods or even static values a name. It's more clearer

286
00:22:41,840 --> 00:22:46,400
It's more. It's it's quite clear that this pattern is a Roman pattern Roman numeral pattern

287
00:22:46,880 --> 00:22:55,120
So not only is the performance improved but arguably so is clarity the clarity because we know what the pattern we're using here

288
00:22:56,600 --> 00:23:00,680
Making a static final field for the otherwise invisible pattern instance

289
00:23:00,680 --> 00:23:04,040
A love allows us to give it a name. It's more explicit and clear

290
00:23:04,160 --> 00:23:07,520
Which is far more readable than the regular expression itself

291
00:23:07,520 --> 00:23:15,000
and then he makes a bit of an ancillary point just to clarify about lazy loading because now as I said when we

292
00:23:15,960 --> 00:23:22,080
Do it this way when we declare it in a private static final field and cash that object

293
00:23:22,320 --> 00:23:26,560
This belongs to this class. So it can be reused all the

294
00:23:27,200 --> 00:23:33,040
Objects of this class all the instances of this class will reuse this but what if we never use this object?

295
00:23:33,080 --> 00:23:35,080
It's just gonna be created

296
00:23:35,080 --> 00:23:41,800
For no reason at all and it's gonna exist in the heap space. Sorry. Yeah in the dynamic meta space in the heap and

297
00:23:42,600 --> 00:23:47,640
Here, you know, he says, oh, look, we could probably lazy load. However, perhaps it's not required

298
00:23:47,640 --> 00:23:50,400
We don't have to over complicate things for

299
00:23:51,320 --> 00:23:56,240
Optimization as don't canoe and I think it was apocryphally attributed to him

300
00:23:57,280 --> 00:23:59,800
premature optimization is the root of all evil and

301
00:24:00,600 --> 00:24:05,200
He continues not only is the performance improved. Oh, sorry. I already read that part

302
00:24:05,440 --> 00:24:12,080
If the class containing the improved version of the is numeral method is initialized, but the method is never invoked

303
00:24:12,360 --> 00:24:17,480
So what if this is numeral fast method is never used and this just exists there?

304
00:24:18,760 --> 00:24:21,600
The field Roman will be initialized needlessly

305
00:24:21,720 --> 00:24:25,120
It would be possible to eliminate the initial initialization

306
00:24:26,000 --> 00:24:32,360
By lazily initializing the field the first time the is numeral method is invoked

307
00:24:32,360 --> 00:24:37,480
But this is not recommended as it's often the case with lazy initial initialization

308
00:24:37,680 --> 00:24:43,640
What can I read the word those two words together lazy initialization? It would

309
00:24:44,880 --> 00:24:50,540
Complicate the implementation with no measurable performance improvement. So it's not required. It's fine

310
00:24:51,040 --> 00:24:54,640
To create an object even though it may potentially not be used

311
00:24:55,880 --> 00:24:57,880
especially with how fast

312
00:24:58,320 --> 00:25:01,520
Jvms of these the JVM and processes out these days

313
00:25:01,520 --> 00:25:05,560
And with that we move to a bit of an interesting problem here

314
00:25:05,880 --> 00:25:13,160
What about less obvious situations for object reusability? I'd say this one seemed quite straightforward

315
00:25:13,560 --> 00:25:16,200
Well, I don't know if it was at least for me

316
00:25:16,200 --> 00:25:21,600
But when I saw the code trust your block has written it came together. I was like, oh that makes complete sense

317
00:25:22,000 --> 00:25:23,160
but I

318
00:25:23,160 --> 00:25:30,960
from being honest, I probably would have done it this way and made the mistake of invoking this pattern instance every single time so

319
00:25:31,640 --> 00:25:37,120
It's probably not so obvious for inexperienced programmers like myself, but nevertheless

320
00:25:37,880 --> 00:25:40,520
Keeping aside aside the self-flagellation

321
00:25:41,560 --> 00:25:47,600
What about when it's less obvious? So he says when an object is immutable like the Roman object here

322
00:25:48,120 --> 00:25:51,160
It is obvious that it can be reused safely

323
00:25:51,840 --> 00:25:56,600
But there are other situations where it is far less obvious even kind of intuitive

324
00:25:57,080 --> 00:26:00,960
Now the example that Joshua block is used for that is adapters

325
00:26:01,720 --> 00:26:04,240
adapters simply are an object

326
00:26:04,720 --> 00:26:10,720
which backs other objects by allowing two incompatible objects to

327
00:26:11,120 --> 00:26:12,360
communicate together

328
00:26:12,360 --> 00:26:15,880
it's used a lot in the adapter pattern and even though

329
00:26:16,640 --> 00:26:18,920
Joshua block doesn't talk about the adapter pattern here

330
00:26:18,920 --> 00:26:23,240
It's I think it's worth going through a few definitions definitions as to what the adapter pattern does

331
00:26:23,440 --> 00:26:25,200
But of course, I'll leave

332
00:26:25,200 --> 00:26:29,200
Some good articles down there in the description. There's a good one by Vile Dung

333
00:26:29,600 --> 00:26:36,040
Where he goes through a few examples as to how the adapter pattern is used and how adapters these objects are used

334
00:26:37,040 --> 00:26:39,920
So the first definition is by refactoring guru

335
00:26:40,760 --> 00:26:46,240
Adapter is a structural design pattern which allows incompatible objects to collaborate

336
00:26:46,760 --> 00:26:49,960
The adapter acts as a wrapper between two objects

337
00:26:49,960 --> 00:26:56,520
It catches calls for one object and transforms them to format an interface recognizable

338
00:26:57,280 --> 00:27:00,640
Recognizable by the second object on the adapter pattern. I would recommend

339
00:27:03,640 --> 00:27:06,120
If you want to get a good understanding of the adapter pattern

340
00:27:07,160 --> 00:27:08,520
This book

341
00:27:08,520 --> 00:27:14,040
Headfirst design patterns goes quite deeply into the adapter pattern with some really good examples

342
00:27:14,040 --> 00:27:17,480
So I'll leave a link to this book down below in the description too

343
00:27:17,480 --> 00:27:21,000
And I'm hoping to cover some parts of this book at least after I'm done with this

344
00:27:21,000 --> 00:27:22,440
It's probably gonna be next year

345
00:27:22,440 --> 00:27:29,280
So the next definition that I found for the adapter pattern is an adapter pattern acts as a connector between two

346
00:27:30,120 --> 00:27:40,160
Incompatible interfaces that otherwise cannot be connected directly could be due to type mismatch whatnot an adapter wraps an existing class with a new interface

347
00:27:40,720 --> 00:27:44,280
So that it becomes compatible with the clients interface

348
00:27:44,560 --> 00:27:49,880
The main motive behind using this pattern is to convert an existing interface

349
00:27:50,600 --> 00:27:53,040
Into another interface that the client expects

350
00:27:53,880 --> 00:27:59,800
It's usually implemented once the application is assigned so one example as to how an adapter is used and

351
00:28:00,280 --> 00:28:05,920
Even though I read some definitions of the adapter pattern. I wouldn't say that the adapter pattern has been used here

352
00:28:06,880 --> 00:28:14,680
Exactly or precisely, but it's worth looking to how the adapter pattern is used and that is in the map interface

353
00:28:15,400 --> 00:28:17,400
so we so of course the map interface

354
00:28:17,880 --> 00:28:19,880
contains a method called a

355
00:28:20,320 --> 00:28:22,320
key key set and

356
00:28:22,760 --> 00:28:27,200
Our hash map, which is a concrete class will implement it which you see here

357
00:28:28,120 --> 00:28:29,560
now what I

358
00:28:29,560 --> 00:28:32,760
Did do so as a client what I would do is I would create a hash map

359
00:28:32,760 --> 00:28:39,200
I would add key value pairs and what the key set does is it returns a bunch of objects all the keys

360
00:28:39,200 --> 00:28:44,240
Which are functionally identical so we can cache that value the key set value

361
00:28:44,240 --> 00:28:50,360
We get can be cached and that's exactly what we see here in the implementation of key set

362
00:28:50,520 --> 00:28:55,520
so this method which is what returns the key set first checks if

363
00:28:55,880 --> 00:29:00,640
the key set is present if this key set value is now which

364
00:29:02,760 --> 00:29:05,640
Wasn't going there. Oh, that's interesting. I

365
00:29:08,520 --> 00:29:10,520
Was clicking the the wrong

366
00:29:11,520 --> 00:29:17,640
Variable look sorry, it's been a long day if this key set variable which is in the abstract map if this isn't available

367
00:29:17,640 --> 00:29:21,760
So if isn't cached then a new instance will be sent if not

368
00:29:21,760 --> 00:29:25,280
There's a requirement that same instance same object can be reused

369
00:29:25,480 --> 00:29:29,600
So here's what where we see that an object is being reused a good

370
00:29:30,400 --> 00:29:32,400
implementation in the JDK

371
00:29:32,760 --> 00:29:35,960
So again to print more formally as to how this example makes sense

372
00:29:36,680 --> 00:29:43,800
Theoretically although the return set instance is typically mutable. So that's the set that's returned here

373
00:29:45,880 --> 00:29:48,680
All of the return objects are functionally identical

374
00:29:49,560 --> 00:29:53,480
When one of the return objects changes so do all the others

375
00:29:54,080 --> 00:29:57,080
Because they're all backed by the same map instance

376
00:29:57,720 --> 00:30:02,440
While it is largely harmless to create multiple instances of the key set view object

377
00:30:02,840 --> 00:30:06,360
It is unnecessary and has no benefits. So the similar point is

378
00:30:07,080 --> 00:30:13,080
Biggest what this method returns is a set view. So of type set of the key set

379
00:30:13,880 --> 00:30:17,640
While this key set the the values in the key set can change

380
00:30:18,200 --> 00:30:19,560
It's

381
00:30:19,560 --> 00:30:26,040
Functionally still the same so the adapter the the outer layer which it returns is still the same and that's a set

382
00:30:26,520 --> 00:30:29,320
So that's why it could be cached another example of

383
00:30:29,640 --> 00:30:34,040
Reusing objects where it's less obvious is of course auto boxing now

384
00:30:34,440 --> 00:30:40,280
What that does is of course it allows programmers to mix primitive and non primitive type

385
00:30:40,280 --> 00:30:46,280
So primitive would be int a non primitive type or a a box type would be

386
00:30:47,160 --> 00:30:53,240
Integer while yes auto boxing does give the object more flexibility and give it more functionality

387
00:30:54,120 --> 00:30:58,360
It's not always a good idea to auto box because what auto box does is create

388
00:30:59,160 --> 00:31:01,400
A new object every time it's involved

389
00:31:03,560 --> 00:31:08,280
So the example we've used or the example that joshua block has given is

390
00:31:09,320 --> 00:31:13,320
In this sum class where in fact, I changed it to the proper way

391
00:31:13,560 --> 00:31:18,360
So this is the bad bit to do it where we have used an auto box type long

392
00:31:18,840 --> 00:31:23,960
And in fact the idea look at that it's even warning us to not to use this but rather to use a primitive type

393
00:31:24,520 --> 00:31:28,440
Now with this if we do run this loop where it's running

394
00:31:29,240 --> 00:31:31,240
2 to the power 31 times

395
00:31:32,680 --> 00:31:38,200
An unnecessary number of objects of long instances are created in this loop. So if we do run it

396
00:31:43,400 --> 00:31:45,000
It takes so long

397
00:31:45,000 --> 00:31:48,840
Look at how long it takes it takes almost 3000 milliseconds and it keeps going

398
00:31:50,040 --> 00:31:51,880
I'll just zoom into that

399
00:31:51,880 --> 00:31:57,000
But simply by just not using an auto box type and rather using a primitive type

400
00:31:57,480 --> 00:32:01,000
We save a lot of time because there's no object creation involved here

401
00:32:01,720 --> 00:32:03,640
If you run it again

402
00:32:03,640 --> 00:32:05,640
It's much slower

403
00:32:05,640 --> 00:32:10,520
That's the advantage of using primitive types over auto box types and

404
00:32:11,480 --> 00:32:16,200
Again, one has to be careful and the good thing is the the way you saw intelligent is beautiful

405
00:32:16,200 --> 00:32:21,880
You got to love it the ide will normally warn you but you know in good programming etiquette

406
00:32:22,200 --> 00:32:27,000
One should be aware of that and that's why he states the lesson is clear prefer primitives

407
00:32:27,080 --> 00:32:30,120
So this here is the proper way to do it using a primitive type

408
00:32:31,080 --> 00:32:37,720
To box primitives and that is a wrong way using a box primitive which the ide warns us against

409
00:32:39,240 --> 00:32:41,240
Oops, uh, come on said

410
00:32:42,200 --> 00:32:48,360
And watch out for unintentional auto boxing and then finally towards the end of the item

411
00:32:48,600 --> 00:32:55,160
He does give some caveats and something I always appreciate about this book every single item has pros and cons

412
00:32:55,480 --> 00:33:01,640
Uh, it it's a well written book because it looks into both sides of the equation. Let's say

413
00:33:02,200 --> 00:33:04,200
And discusses the trade-offs

414
00:33:04,440 --> 00:33:09,400
So the the first caveat is that it's not the case that object creation should be

415
00:33:10,360 --> 00:33:16,120
Avoided at all costs, especially with how fast the processors are and how optimized the jvms

416
00:33:16,840 --> 00:33:19,080
It's not that we should try our best to

417
00:33:19,800 --> 00:33:23,960
Not create objects again do the whole premature optimization thing

418
00:33:25,080 --> 00:33:28,680
That's why he states this item should not be misconstrued

419
00:33:29,160 --> 00:33:37,000
To imply that object creation is expensive and should be avoided on the contrary the creation and reclamation of small objects

420
00:33:37,080 --> 00:33:43,960
Whose constructors do little explicit work is cheap, especially on modern jvm implementations

421
00:33:44,760 --> 00:33:47,560
Creating additional objects to enhance the clarity

422
00:33:48,040 --> 00:33:51,320
Simplicity or power of a program is generally a good thing

423
00:33:51,800 --> 00:33:55,080
And then we go to a classic example the classic example of an object

424
00:33:55,960 --> 00:34:00,680
That does justify an object pool is a database connection, which is why

425
00:34:01,400 --> 00:34:02,600
conversely

426
00:34:02,600 --> 00:34:10,760
Maintaining object pool in this case would be a better idea unless the object is significantly heavy weight a like a database connection

427
00:34:11,320 --> 00:34:15,640
So it depends on what the object we create is as to whether

428
00:34:16,280 --> 00:34:21,720
It makes sense to optimize it and to reuse it or just simply create an object if it's lightweight for instance

429
00:34:22,440 --> 00:34:25,640
The cost of establishing the connection is sufficiently high

430
00:34:26,200 --> 00:34:28,600
That it makes sense to reuse these objects

431
00:34:28,680 --> 00:34:33,800
This is something we see a lot with frameworks for instance a spring with the dependency injection

432
00:34:34,360 --> 00:34:36,760
Something like a database connection could be injected

433
00:34:37,560 --> 00:34:42,600
Into different components in the object pool or the object graph in this case

434
00:34:43,800 --> 00:34:45,800
Generally speaking, however

435
00:34:45,880 --> 00:34:49,240
Maintaining your own object pools clutters your code

436
00:34:49,800 --> 00:34:54,040
increases memory footprint and harms performance. So what he means by

437
00:34:54,600 --> 00:34:59,000
Maintaining your own object pools really is what we saw here

438
00:34:59,640 --> 00:35:01,160
in the

439
00:35:01,160 --> 00:35:03,080
numeral roman numeral example

440
00:35:03,080 --> 00:35:09,080
This is kind of like what an object pool is we we define all these objects in our class and let's say we have 20 of these

441
00:35:09,400 --> 00:35:11,880
That can cloud your code and make things a bit complicated and

442
00:35:12,520 --> 00:35:15,320
Make the code unreadable or more difficult to read

443
00:35:17,560 --> 00:35:19,560
So since

444
00:35:19,800 --> 00:35:28,760
Modern jvm implementations have highly optimized garbage collectors that easily outperform such object pools on lightweight objects

445
00:35:29,240 --> 00:35:31,880
It's not necessarily the case that one should always

446
00:35:32,760 --> 00:35:35,960
avoid object creation and then we get to an interesting

447
00:35:36,840 --> 00:35:38,360
sort of

448
00:35:38,360 --> 00:35:42,520
Conclusive point in this item and that's the concept idea of defensive copying

449
00:35:44,680 --> 00:35:46,680
What defensive copying

450
00:35:47,000 --> 00:35:51,720
The simplest way to think of defensive defensive copying is that it's used to maintain

451
00:35:52,360 --> 00:35:58,600
Immutability of an object and before we take a look at the example which I have here for defensive copying. It's when you get it

452
00:35:58,680 --> 00:36:08,440
It's a rather simple concept, but it's used a lot across frameworks. For instance, um, sorry defensive copying. I'm not sure I confused

453
00:36:09,720 --> 00:36:11,720
Reflections with defensive copying

454
00:36:11,960 --> 00:36:16,120
But regardless it's a known concept in java programming

455
00:36:17,000 --> 00:36:19,000
So what defensive copying is is

456
00:36:19,880 --> 00:36:22,280
Where to maintain immutability

457
00:36:22,920 --> 00:36:29,640
Instead of passing back a reference to the object at hand a reference to a new object is passed with the same values

458
00:36:29,960 --> 00:36:34,440
Making it a copy for all intense for all intents and purposes. What that means is

459
00:36:35,000 --> 00:36:39,080
Uh, you know what without me trying to theorize more. Let's look at the example here

460
00:36:39,720 --> 00:36:42,200
So we have a class called full calendar here, which

461
00:36:43,000 --> 00:36:46,520
Despite ostensibly looking immutable is in fact mutable

462
00:36:47,160 --> 00:36:55,960
And this example is courtesy of courtesy of abc study guide. The link to this blog post article is down below in the description

463
00:36:56,440 --> 00:37:02,120
So as a client when we use full calendar, what we're doing is we are passing this original date

464
00:37:02,840 --> 00:37:09,400
Uh object of date type into the constructor and the constructor assigns that to this private final

465
00:37:10,120 --> 00:37:13,000
Uh date object, which we think is immutable

466
00:37:13,880 --> 00:37:19,320
But what happens is because we are passing this when the class is instantiated. So in line number 30

467
00:37:20,680 --> 00:37:25,240
If for instance, let's say this original date value changes

468
00:37:26,360 --> 00:37:32,600
The value of standard date also changes because they are both pointing to the same location in memory

469
00:37:33,000 --> 00:37:36,280
Therefore, even though we've declared this as private final

470
00:37:37,080 --> 00:37:43,400
And we think it's immutable. It's in fact not and here's where we can easily create a defensive copy

471
00:37:43,960 --> 00:37:45,960
So the right way to do this would be in fact

472
00:37:47,400 --> 00:37:52,200
When the class is invoked uh, or when when the class is instantiated and the construct is invoked

473
00:37:52,760 --> 00:37:57,400
We create a new date object. We we get we get the value of it

474
00:37:57,400 --> 00:38:01,320
So we create a copy of that with the the the date we pass here

475
00:38:02,040 --> 00:38:07,480
And then using that value we create in fact a new object and then pass said that in standard date

476
00:38:08,040 --> 00:38:14,360
That defensive copy ensures immutability of this class and the same thing when we are returning it when you're returning it

477
00:38:14,600 --> 00:38:16,600
We want to return a new instance

478
00:38:16,920 --> 00:38:18,920
and not

479
00:38:19,160 --> 00:38:22,280
The uh, the one that was here because that too could change

480
00:38:22,920 --> 00:38:29,240
And that's why we are we are passing. Um, we're not passing in this case. We're using the new keyword and creating a new

481
00:38:29,800 --> 00:38:36,040
Uh date instance. So yeah, that's sort of my still I'd say high level superficial understanding of defensive copying

482
00:38:36,200 --> 00:38:40,440
But whenever I do think of it, I always connect it to maintaining

483
00:38:41,080 --> 00:38:43,080
uh immutability

484
00:38:43,080 --> 00:38:47,480
But of course, I'll leave the code this code and also the the article that I got this code from

485
00:38:48,280 --> 00:38:50,680
In the description so that you could look a bit more deeply

486
00:38:52,280 --> 00:38:56,760
And to conclude here's what Joshua Bloch says about defensive copying

487
00:38:57,000 --> 00:39:04,360
The counterpoint to this item is item 50, which is on defensive copying. So this item is is about avoid

488
00:39:05,000 --> 00:39:12,600
Creating unnecessary object and here you would think we're creating an unnecessary object where every single time a new object is created

489
00:39:13,960 --> 00:39:15,960
So that's why he says it's a counterpoint

490
00:39:17,320 --> 00:39:22,520
The person item says don't create a new object when you should reuse an existing one

491
00:39:23,320 --> 00:39:29,000
While item 50 says don't reuse an existing object when you should create a new one

492
00:39:29,560 --> 00:39:30,280
like

493
00:39:30,280 --> 00:39:37,480
In the example of defensive copying note that the penalty for reusing an object when defensive copying is called for is far greater

494
00:39:38,120 --> 00:39:41,640
Than the penalty for needlessly creating a duplicate object

495
00:39:43,080 --> 00:39:50,600
Failing to make defensive copies where required can lead to insidious bugs and security holds creating objects

496
00:39:50,680 --> 00:39:52,040
unnecessarily

497
00:39:52,040 --> 00:39:57,240
Merely affects style and performance and of course we need to always at least in my opinion prioritize

498
00:39:57,800 --> 00:40:00,760
security over efficiency and performance, which is why

499
00:40:01,240 --> 00:40:04,840
It's a good sort of way to end this item with the caveat that

500
00:40:05,400 --> 00:40:09,640
This certainly doesn't mean that we should avoid creating objects at all costs

501
00:40:09,880 --> 00:40:14,200
There are costs a cost could be security and that could be detrimental

502
00:40:15,320 --> 00:40:18,520
And that's it. That is item number six on

503
00:40:19,480 --> 00:40:24,200
The avoiding of creating unnecessary objects. I hope you found that insightful

504
00:40:24,920 --> 00:40:26,920
Please do tell me how I can improve

505
00:40:27,000 --> 00:40:29,560
In the way I communicate and articulate these concepts

506
00:40:29,880 --> 00:40:32,280
But also as to how I demo and show the code

507
00:40:33,000 --> 00:40:37,560
I would like to maybe even a bit more be a bit more slow and leave more comments

508
00:40:37,720 --> 00:40:39,720
But perhaps the best thing to do is

509
00:40:40,360 --> 00:40:44,600
Go on to take a look at the code yourself. This video. Think of it as only a prelude

510
00:40:44,680 --> 00:40:50,520
I think that thanks a lot for watching. I really appreciate it. I'll receive the few comments here and there

511
00:40:51,560 --> 00:40:55,000
On on these videos and it means a lot to me. It means a lot to me

512
00:40:55,960 --> 00:41:02,280
And it's always nice to see that there are people actual human beings watching these videos and it's just not me

513
00:41:04,440 --> 00:41:06,440
Rambling like a raconteur

514
00:41:07,400 --> 00:41:12,440
Okay, enough rambling on the on in okay enough rambling on rambling ridiculous

515
00:41:12,440 --> 00:41:14,920
Thanks for watching. Cheers. See you in the next one

