1
00:00:00,000 --> 00:00:07,960
Hey, everyone, welcome to yet another episode of my video series on Joshua blocks effective Java where I go through the items that he has

2
00:00:08,800 --> 00:00:12,740
Animated in this book and expand on them and try and make sense of them

3
00:00:12,740 --> 00:00:18,740
And hopefully as I do that you can gain some value from it too and today and forgive me for being

4
00:00:19,860 --> 00:00:25,600
Self-advertising but I am quite happy because I managed to get through the first nine items which is essentially chapter two

5
00:00:25,600 --> 00:00:31,860
So the first part of the book and I am I'm really happy that I didn't do it through. I'm I'm glad that

6
00:00:32,680 --> 00:00:35,400
First of all, I'm really enjoying this. I'm learning a lot, but also

7
00:00:36,400 --> 00:00:38,400
Given that this is something I'm new to

8
00:00:39,640 --> 00:00:44,080
Expanding and elucidating on programming or just any concept in general

9
00:00:44,640 --> 00:00:48,800
It's something that I'm I think it's a skill that I'm developing on learning to

10
00:00:49,320 --> 00:00:54,960
Communicate and articulate myself when discussing programming concepts or software engineering concepts, let's say

11
00:00:55,560 --> 00:00:57,560
and obviously, I

12
00:00:58,200 --> 00:01:01,720
Still don't think I have a really deep understanding of the Java language

13
00:01:02,440 --> 00:01:04,640
therefore, it's a great feeling to get through the

14
00:01:05,240 --> 00:01:08,160
first nine items or the second chapter which

15
00:01:08,720 --> 00:01:12,080
Essentially is the first chapter in this book because the first chapter is the introduction

16
00:01:12,720 --> 00:01:15,360
And today we're gonna move on to chapter three

17
00:01:16,000 --> 00:01:18,440
And as per usual before I do that

18
00:01:19,000 --> 00:01:21,480
This is not gonna change. I've got to always do this

19
00:01:22,200 --> 00:01:24,080
Proviso in the introduction

20
00:01:24,080 --> 00:01:28,240
So if you've been following along in the series, you could skip this bit to save your time

21
00:01:28,960 --> 00:01:33,000
But without further ado, let's get started with the proviso

22
00:01:34,280 --> 00:01:36,280
Firstly as I always state

23
00:01:36,480 --> 00:01:40,640
This is not a tutorial and I certainly am not a teacher or an expert

24
00:01:40,640 --> 00:01:46,840
Which is again one reason I'm really glad that I managed to assist through the first to the first nine items

25
00:01:47,520 --> 00:01:48,880
as

26
00:01:48,880 --> 00:01:52,160
It is not something that naturally comes to me to be able to

27
00:01:52,760 --> 00:01:57,280
As I teach firstly because I too am learning as I go along

28
00:01:58,360 --> 00:02:03,240
Trying to make sense of these items and the concepts in the book. So again, sorry

29
00:02:03,240 --> 00:02:09,560
I'm talking too much the proviso or the caveat is this is not a tutorial. So please don't treat it like one

30
00:02:09,920 --> 00:02:12,200
I'm pretty sure I've in fact

31
00:02:12,200 --> 00:02:18,040
I've already made a few mistakes in the previous items and I've corrected them and tried to rectify them in the comment section

32
00:02:18,360 --> 00:02:24,080
When people have pointed them out and I'm pretty sure in the remaining what 90 odd items

33
00:02:24,080 --> 00:02:27,880
I'm gonna make a lot more mistakes. So firstly, please do point them out

34
00:02:28,640 --> 00:02:29,960
and

35
00:02:29,960 --> 00:02:34,760
Again, don't take what I say as let's say gospel's truth. This is

36
00:02:35,560 --> 00:02:37,560
an analogy that I use is

37
00:02:38,080 --> 00:02:45,800
Blind leading the blind, which is kind of what I feel like I'm doing here. I don't know what the hell I'm doing and I'm trying to

38
00:02:47,040 --> 00:02:48,880
hopefully

39
00:02:48,880 --> 00:02:54,440
Make things a bit more lucid for you the viewer who probably also doesn't know what the hell you're doing

40
00:02:54,440 --> 00:03:00,440
Probably you have a better idea than I do but still I feel equally lost in this world. Isn't that the ultimate verity?

41
00:03:01,160 --> 00:03:02,760
Yeah, I call this a

42
00:03:03,400 --> 00:03:10,040
Disquisition so it's something I'm trying to collectively make sense of using stucco flow using the community that I'm trying to build around

43
00:03:10,640 --> 00:03:12,640
this video series and

44
00:03:12,640 --> 00:03:20,320
Since recently even chat GPT. I've been asking questions for a cup 10 you do this book from chat GPT and it has been

45
00:03:21,360 --> 00:03:26,480
Sublime, it's it's been extremely helpful. That's great. So again, I think I already made this point

46
00:03:26,480 --> 00:03:30,040
I will inevitably make mistakes. So yeah, please point them out and

47
00:03:30,760 --> 00:03:32,760
Given that this is a

48
00:03:33,600 --> 00:03:41,480
Programming video series all the code that I use will be up on get have it'll be published on get have not only on my personal

49
00:03:41,480 --> 00:03:44,920
repository, but also just your blocks. Let's say official

50
00:03:46,240 --> 00:03:49,960
Repository on this book. I'll leave the links down below the description

51
00:03:50,480 --> 00:03:54,440
and saying all that let us get started with item number 10

52
00:03:55,200 --> 00:03:56,680
which is

53
00:03:56,680 --> 00:04:04,280
Obey the general contract when overriding equals and this item since we are now in a new chapter is a part of chapter 3

54
00:04:04,280 --> 00:04:06,600
Which is methods common to all objects

55
00:04:07,960 --> 00:04:09,960
so item 10 is

56
00:04:11,040 --> 00:04:14,760
Undoubtedly the longest item in this book. I think it's

57
00:04:15,760 --> 00:04:16,920
probably

58
00:04:16,920 --> 00:04:22,000
15 20 pages. It's quite long. Therefore. I have no choice but to

59
00:04:22,720 --> 00:04:30,880
Well, I probably could cover the whole item in one really superficial video, but that's not the intent behind this video series

60
00:04:32,880 --> 00:04:39,080
Yeah, it's not really annoying. I live in a very very quiet neighborhood, but the moment that I've got a recorded video

61
00:04:40,200 --> 00:04:44,080
Some son of a bitch doesn't matter. Okay back to this

62
00:04:45,200 --> 00:04:49,440
Where was I say I got distracted. Okay item 10 is quite a long item and

63
00:04:49,840 --> 00:04:50,960
and

64
00:04:50,960 --> 00:04:57,240
And and the intent. Yeah, that's that's where I was the intent behind this video series was always to try and and

65
00:04:57,400 --> 00:05:00,360
Go as deep as possible into these ideas

66
00:05:00,960 --> 00:05:02,960
within what

67
00:05:03,000 --> 00:05:05,000
Within what I can manage

68
00:05:05,040 --> 00:05:12,280
There's a limit as to what my understanding is. I don't think I can go to like the compiler level then explain the JVM algorithm and whatnot

69
00:05:12,280 --> 00:05:16,560
I'm not that knowledgeable on Java O programming in general, but

70
00:05:16,920 --> 00:05:21,880
To my limits to my current limits the goal was always to go as deep as possible

71
00:05:22,400 --> 00:05:28,280
So therefore I'm gonna split up this item into multiple parts for now

72
00:05:28,280 --> 00:05:34,760
I'm thinking three parts because it kind of breaks down the item if you go through where they come has this

73
00:05:35,440 --> 00:05:38,520
Part where it's it's no connected, of course

74
00:05:38,520 --> 00:05:43,200
But then one leads to the other and I think you could break it down into three coherent parts. Let's say

75
00:05:44,200 --> 00:05:50,840
But also apart from its length, I really enjoy this item because it does involve some quite interesting computer science

76
00:05:50,840 --> 00:05:53,880
I mean basic first-year uni computer science

77
00:05:53,880 --> 00:05:59,920
But still it's always a good feeling at least for me to revisit some of those concepts like truth tables

78
00:06:00,640 --> 00:06:04,120
And and logic and all of that that we learned it in uni

79
00:06:05,200 --> 00:06:08,200
So again item 10 states

80
00:06:09,200 --> 00:06:14,000
Obey the general con obey the general contract when overriding equals I

81
00:06:14,640 --> 00:06:17,720
Apologize I just realized that since we are starting a new chapter

82
00:06:17,720 --> 00:06:22,720
I looked at the book and I didn't read out the introduction for chapter 10

83
00:06:22,840 --> 00:06:28,320
Which is methods common to all objects. So before we get to the item itself. Let me read that out

84
00:06:29,480 --> 00:06:31,480
The chapter starts off like this

85
00:06:31,880 --> 00:06:39,000
Although object is a concrete class. It is designed primarily for extension

86
00:06:39,600 --> 00:06:41,600
That's correct. All classes are

87
00:06:42,600 --> 00:06:44,600
subclassed from object

88
00:06:45,480 --> 00:06:51,400
All of its non-final methods equals hash code to string clone and finalize

89
00:06:52,000 --> 00:06:54,000
have explicitly

90
00:06:54,000 --> 00:06:58,840
Sorry have explicit general contracts because they are designed to be overridden

91
00:06:59,520 --> 00:07:05,120
It is the responsibility of any class overriding these methods to obey their general contracts

92
00:07:06,640 --> 00:07:11,000
Failing to do so will prevent other classes that depend on the contracts

93
00:07:11,440 --> 00:07:17,000
Such as hash map and hash set from functioning properly in conjunction with the class

94
00:07:18,080 --> 00:07:20,920
So exactly as the introduction does suggest

95
00:07:21,440 --> 00:07:27,960
Essentially this whole chapter is gonna be about this object concrete class and it's a good segue to this diagram in fact

96
00:07:28,840 --> 00:07:30,480
this is

97
00:07:30,480 --> 00:07:32,480
this is a

98
00:07:33,240 --> 00:07:36,720
Let's let's just call it a skeletal diagram of what

99
00:07:37,320 --> 00:07:43,760
All the classes in Java look like so as you can see the object is a super. Let me zoom in a bit

100
00:07:45,200 --> 00:07:52,200
The object is the super class of all the other classes in Java and they inherit from that so these methods that

101
00:07:53,320 --> 00:07:54,400
Joshua block

102
00:07:54,440 --> 00:07:55,960
Joshua block in

103
00:07:55,960 --> 00:07:59,640
Animated equals hash code to string clone and finalize

104
00:07:59,640 --> 00:08:05,880
They're all methods of the object class that we'll be using across all the other classes and even the classes that we create

105
00:08:06,120 --> 00:08:10,060
On our own it provides a really good blueprint and in this item

106
00:08:10,060 --> 00:08:17,360
We're gonna really focus on the equals method and why we should obey the general contract when overriding this equals method by any of these

107
00:08:17,360 --> 00:08:21,520
other subclasses that do inherited from the superclass object

108
00:08:22,200 --> 00:08:28,680
So firstly just to get some formal definitions out of the way. I always like doing that

109
00:08:28,680 --> 00:08:32,360
I think it's a good way to get a very high level understanding and slowly

110
00:08:32,960 --> 00:08:36,560
Narrow into a to a concept the Oracle doc state

111
00:08:38,120 --> 00:08:41,120
Class object is the root of the class hierarchy

112
00:08:41,880 --> 00:08:48,600
Every class has object as a superclass all objects including areas implement the methods of this class

113
00:08:48,920 --> 00:08:51,480
So, which is why again the the

114
00:08:52,040 --> 00:09:00,560
The advice by Joshua block is to please try and obey the general contract when overriding any of these methods that we inherit

115
00:09:01,920 --> 00:09:08,920
And now pretending more to item 10, let's take a look at the equals method because that's what we're gonna really discuss in this item

116
00:09:11,000 --> 00:09:17,480
Again from the Oracle docs, I really like this definition actually it's it's a very straightforward one and kind of

117
00:09:18,200 --> 00:09:20,200
Puts it quite coherently

118
00:09:21,160 --> 00:09:27,720
The Oracle doc state where the equals method is that's how it's defined in the object class public Boolean equals

119
00:09:27,720 --> 00:09:32,800
So it returns a Boolean and then you can pass an object into it as a parameter. It takes an object

120
00:09:34,000 --> 00:09:37,920
The equals method implements. Sorry. I should say as a parameter. It takes

121
00:09:38,560 --> 00:09:45,680
Something of type object. Okay back back to the definition the equals method implements an equivalence relation or

122
00:09:46,280 --> 00:09:48,280
non-null object references

123
00:09:49,520 --> 00:09:55,040
The equals method for class object implements the most discriminating possible equivalence

124
00:09:55,760 --> 00:09:56,760
relating

125
00:09:56,760 --> 00:09:58,760
Sorry, I'll read that again

126
00:09:59,080 --> 00:10:05,800
The equals method for class object implements the most discriminating possible equivalence relation on objects

127
00:10:06,240 --> 00:10:11,960
That is for any non-null references reference value values X and Y

128
00:10:12,320 --> 00:10:21,560
This method returns true if and only if X and Y refer to the same object or in a bit more logic-based sense

129
00:10:22,120 --> 00:10:24,220
X double equals Y has a value true

130
00:10:26,520 --> 00:10:32,960
So firstly it's important to understand this this double equals operator, I forget if there's a proper word for it, but

131
00:10:33,880 --> 00:10:36,640
We need to firstly explore what

132
00:10:37,640 --> 00:10:39,640
This idea of

133
00:10:39,880 --> 00:10:42,380
equivalence relation means because that

134
00:10:43,000 --> 00:10:45,000
Pertains a lot to this item

135
00:10:45,760 --> 00:10:47,760
But before we get to that, let's

136
00:10:48,400 --> 00:10:49,360
firstly

137
00:10:49,360 --> 00:10:52,600
Try to understand what this double equals operator is

138
00:10:53,120 --> 00:10:55,800
so I got this article from GeeksforGeek and

139
00:10:56,240 --> 00:11:00,120
Firstly, let me read out the definition and once we are done with the definition

140
00:11:00,400 --> 00:11:04,880
Let's try to make a bit more sense as to what how that differs to the

141
00:11:05,320 --> 00:11:07,720
Equals method that's in the object class

142
00:11:09,640 --> 00:11:12,440
So the definition goes in GeeksforGeek geeks

143
00:11:14,000 --> 00:11:23,240
We can use the double equals operators for reference comparison address comparison and dot equals method for content comparison

144
00:11:23,640 --> 00:11:30,080
In simple words, the double equals checks if both objects point to the same memory location

145
00:11:30,480 --> 00:11:35,920
Whereas the equals evaluates to the comparison of values in the objects

146
00:11:36,360 --> 00:11:40,160
So it's a really simple concept. I mean, I could just show it right here

147
00:11:41,400 --> 00:11:48,480
Actually instead of showing it on my notion page. Let me just open up this article and show it here. So this is quite straightforward

148
00:11:50,400 --> 00:11:52,400
We have two variables

149
00:11:52,400 --> 00:11:57,560
S1 and S2 of type string and then S1 and S2

150
00:11:58,560 --> 00:12:00,560
Will will give

151
00:12:01,400 --> 00:12:07,640
What will pass through because this string value? Hello, it's memory address. It's the same

152
00:12:08,480 --> 00:12:10,960
It's it's it's immutable

153
00:12:11,640 --> 00:12:17,000
And it'll it'll be the memory with the same address. So this will really do a memory address comparison

154
00:12:17,600 --> 00:12:25,280
But here with S1 and S3 because we had firstly this is an anti pattern one should never do this because it's a waste of memory

155
00:12:26,280 --> 00:12:33,480
This new object of string we are creating called. Hello. This hello for the variable S3

156
00:12:33,840 --> 00:12:37,040
That gets a separate memory address

157
00:12:37,400 --> 00:12:40,920
So then I'm gonna be the same comparison despite the content being the same

158
00:12:41,120 --> 00:12:44,560
It's gonna return false because the memory address is different

159
00:12:44,880 --> 00:12:48,640
But that's not the case with using the dot equals method. That's in

160
00:12:49,080 --> 00:12:52,480
Dot equals method. That sounds weird the equals method. That's in the object class

161
00:12:52,760 --> 00:12:57,360
So string obviously is an object. It inherits this method from the from the object class and

162
00:12:58,200 --> 00:13:03,580
Here in both these lines. It's a pure content comparison. So despite

163
00:13:04,600 --> 00:13:06,360
S3 and

164
00:13:06,360 --> 00:13:11,440
Either S1 or S2 having a different memory location. The content is for the same

165
00:13:11,440 --> 00:13:14,040
So that's the comparison that the equals method does so

166
00:13:14,560 --> 00:13:21,400
You gotta remember that that's a general contract that we need to respect and we need to follow when if we are to override

167
00:13:21,440 --> 00:13:27,700
This equals method that it's the content that we compare. So going back to the definition from the oracle docs this term here

168
00:13:28,720 --> 00:13:32,720
Equivalence relation. It's actually a mathematical logic concept

169
00:13:33,160 --> 00:13:40,640
So we I don't think we're gonna get get to that really firstly even I myself because I'm not a logician

170
00:13:40,640 --> 00:13:42,640
I haven't got a good understanding of of

171
00:13:43,640 --> 00:13:49,080
everything that entails or everything behind the theory behind equivalence relation, but

172
00:13:50,040 --> 00:13:51,640
Apropos Java

173
00:13:51,640 --> 00:13:58,400
What equivalence relation really means is comparing the content of the of two objects

174
00:13:58,440 --> 00:14:04,920
Which is what we did in this example here. We're comparing the content and not really the reference in in memory

175
00:14:05,400 --> 00:14:12,720
And saying all that let's get to so I should have mentioned this earlier in part one in this video

176
00:14:12,960 --> 00:14:15,240
Which is part one of item 10

177
00:14:16,040 --> 00:14:22,640
We're really gonna focus on this when not to override the equals method and then in the next part

178
00:14:22,640 --> 00:14:27,240
We'll get to the crux of the matter as to when exactly to override it and then

179
00:14:27,920 --> 00:14:32,800
how to to follow the general contract or obey the general contract so

180
00:14:33,720 --> 00:14:34,840
firstly

181
00:14:34,840 --> 00:14:36,920
When not to override the equals method

182
00:14:36,920 --> 00:14:44,320
So if we do inherit this method from the superclass object, when is it okay to not override it despite most times?

183
00:14:44,320 --> 00:14:46,320
We may have to override it

184
00:14:46,600 --> 00:14:49,560
In the item 10 Joshua blocks starts off like this

185
00:14:51,040 --> 00:14:56,080
The easiest way to avoid problems is not to override the equals method

186
00:14:56,440 --> 00:15:01,880
In which case each instance of the class is equal only to itself and then he states

187
00:15:02,040 --> 00:15:07,160
This is the right thing to do if any of the following conditions apply and he's listed down a few of the conditions

188
00:15:07,160 --> 00:15:11,600
So in this item will go through sorry in this part of this item

189
00:15:11,840 --> 00:15:16,120
Getting a bit confusing in this part will go through those reasons

190
00:15:17,240 --> 00:15:24,800
The first one is if an instance of the class is inherently unique now. What does that mean firstly? Let me read out the definition

191
00:15:26,160 --> 00:15:28,160
He states

192
00:15:28,360 --> 00:15:32,800
Don't override the equals method if each instance of the class is inherently unique

193
00:15:33,160 --> 00:15:39,880
This is true for classes such as thread that represent active entities rather than values

194
00:15:40,240 --> 00:15:46,400
The equals implementation provided by object has exactly the right behavior for these classes

195
00:15:47,080 --> 00:15:49,760
So of course the question with asking is what is threat?

196
00:15:49,760 --> 00:15:51,920
What is the threat class the threat class?

197
00:15:51,920 --> 00:15:54,420
You can go through the docs on Oracle

198
00:15:54,480 --> 00:16:01,520
But it's it's used to spin up a new thread a new thread of work simply put according to the Oracle docs a thread is a

199
00:16:01,520 --> 00:16:03,520
Thread of execution in a program

200
00:16:03,520 --> 00:16:09,760
The JVM allows an application to have multiple threads of execution running concurrently

201
00:16:09,760 --> 00:16:12,960
So obviously the threat class is used for a concurrency

202
00:16:13,600 --> 00:16:19,200
And much threading. So why would a instance of a thread be inherently unique?

203
00:16:19,200 --> 00:16:22,840
it it seems rather obvious isn't it because

204
00:16:23,440 --> 00:16:29,680
Whenever a new thread is spun up, even if these two threads are spun up from the same state

205
00:16:30,320 --> 00:16:38,360
We we were pretty sure that they're not gonna act the same way once they're spun up and they start executing in their computation

206
00:16:39,400 --> 00:16:44,760
They the the threads in that sense represent a dynamic computation a dynamic object where

207
00:16:45,560 --> 00:16:51,600
It it throughout its lifetime. It's gonna change. It's gonna it's not gonna be consistent and therefore

208
00:16:52,000 --> 00:16:56,880
Two threads that may again start on with the same state

209
00:16:57,280 --> 00:17:03,080
Will still act completely differently because they're doing completely different work. Therefore, it makes no sense to

210
00:17:04,320 --> 00:17:06,320
To override the equals method

211
00:17:06,520 --> 00:17:14,080
That that only compares the content of of two objects for the threat class because we know that they're gonna be inherently unique

212
00:17:14,360 --> 00:17:19,280
Therefore if you do compare two threat objects, their content is gonna be different

213
00:17:19,880 --> 00:17:24,320
Therefore, it's no use to override it and try and change it because

214
00:17:24,960 --> 00:17:30,440
What the object class has defined in the equals method that does the job

215
00:17:30,440 --> 00:17:34,560
And if we just suppose the threat class with something like the string class

216
00:17:34,840 --> 00:17:40,640
Where we know the content of the string class is gonna be the same as in not the content of the string class

217
00:17:40,640 --> 00:17:46,480
But if you have two objects like this, we can make this object immutable because we know the content is gonna be the same

218
00:17:46,480 --> 00:17:48,960
Therefore, it's no use doing something like this where we

219
00:17:49,840 --> 00:17:55,800
Recreate a new instance of that class and have a new object. That's again, as I said an anti-pattern

220
00:17:56,040 --> 00:18:00,520
So this is a static object in that sense for for all intents and purposes

221
00:18:01,000 --> 00:18:03,320
Whereas that that won't be the case for the threat class

222
00:18:04,080 --> 00:18:06,080
the next reason is

223
00:18:06,280 --> 00:18:09,400
to not override the equals method is if a

224
00:18:10,440 --> 00:18:13,480
Logically quality tests in a class is not required

225
00:18:14,240 --> 00:18:16,120
So a warranted question is

226
00:18:16,120 --> 00:18:19,320
What is a logically quality tests firstly?

227
00:18:19,320 --> 00:18:24,960
Let's understand what logical equivalence is and this kind of what I meant by there's a bit of basic computer science that I find always

228
00:18:24,960 --> 00:18:33,000
Interesting so Khan Academy defines logical equivalence as the idea that more than one expression can have the same meaning

229
00:18:33,320 --> 00:18:38,720
But have a different form often a form that helps make the meaning more clear

230
00:18:39,080 --> 00:18:43,000
so the example on Khan Academy for logical equivalence is as

231
00:18:43,480 --> 00:18:48,520
If you take these three statements, you cannot go to the park if your sister is awake or

232
00:18:49,600 --> 00:18:57,160
Your room is dirty. That's one statement. The other one is you can go to the park if your sister is not awake and

233
00:18:58,560 --> 00:19:01,800
Your room is not dirty or even simpler

234
00:19:02,280 --> 00:19:10,120
You can go to the park if your sister's asleep and your room is clean now these three statements despite having a

235
00:19:11,120 --> 00:19:14,680
Different structure or different let's say content

236
00:19:15,240 --> 00:19:21,160
They are still logically equal in terms of the meaning we derive from them. There is logical equivalence

237
00:19:23,200 --> 00:19:28,200
But but for Java of course, and I just wanted to read that up because I thought it was quite interesting

238
00:19:28,200 --> 00:19:29,800
Oh, by the way

239
00:19:29,800 --> 00:19:35,800
Before we get the Java idea in the context of Java. I mean, let's let's take a look at this is like a

240
00:19:36,720 --> 00:19:44,160
Biconditional truth table. So another way of thinking in a bit more formal sense of logical equivalence is is if we take

241
00:19:44,480 --> 00:19:49,120
logical equivalence if if both P and Q are true, then

242
00:19:49,600 --> 00:19:54,760
The biconditional value is also true if either one of them is false. It's gonna be false

243
00:19:55,160 --> 00:20:01,800
But also if all of both of them are false, they're still they still have this logical equivalence. Therefore, it's gonna be true

244
00:20:02,400 --> 00:20:04,400
so it's it's it's it's like a

245
00:20:05,120 --> 00:20:10,360
One one is one and then zero zero is still one if that makes sense

246
00:20:11,000 --> 00:20:14,560
But you know in the context of Java, it's I just thought that was interesting

247
00:20:14,560 --> 00:20:19,320
And I wanted to go into that and the context of Java of course logical equality compares the content

248
00:20:19,800 --> 00:20:22,280
The the content of the object the data of the object

249
00:20:22,840 --> 00:20:26,440
Instead of the values of the memory reference as we discussed earlier

250
00:20:26,840 --> 00:20:30,240
So let's take a look at a quick demo. Oh before I get to the demo

251
00:20:30,240 --> 00:20:34,280
Let me read out the definition by Joshua block on that point. So again, he says

252
00:20:35,120 --> 00:20:36,520
there's no need to

253
00:20:36,520 --> 00:20:42,720
override the equals method if they if there's no need for the class to provide a

254
00:20:43,160 --> 00:20:45,160
logical equality test

255
00:20:45,760 --> 00:20:47,240
For example

256
00:20:47,240 --> 00:20:49,760
The Java util reg X pattern class

257
00:20:50,400 --> 00:20:57,480
Could have overwritten equals to check whether two pattern instances represent represented exactly the same regular expression

258
00:20:57,720 --> 00:21:00,120
But the designers didn't think

259
00:21:00,760 --> 00:21:07,200
That clients would need or want this functionality. Correct. It's it this very much

260
00:21:07,200 --> 00:21:09,920
This is like the art of object-oriented design

261
00:21:10,680 --> 00:21:12,680
It's important to understand

262
00:21:12,680 --> 00:21:20,720
What what the context of a API we write will be used and and these the designers of this API thought that it's it's not

263
00:21:20,720 --> 00:21:22,720
necessary to override the equals method because

264
00:21:23,440 --> 00:21:25,440
We would never really use the

265
00:21:26,320 --> 00:21:34,840
Equals method to compare to instances of pattern and let's take a look at an example. So a quick demo. I have here is

266
00:21:36,200 --> 00:21:38,200
Let me open that up

267
00:21:39,080 --> 00:21:47,120
So I have this static Boolean method called run regular expression against string which takes a reg X and takes a

268
00:21:48,080 --> 00:21:50,080
text of type string and

269
00:21:50,200 --> 00:21:52,200
really what we're doing is we're creating a

270
00:21:53,160 --> 00:21:56,400
Compile reg X of type pattern a pattern object and

271
00:21:57,240 --> 00:22:05,200
Afterwards, we're using the matcher which interprets this pattern that that's so pattern dot compile returns a pattern a compile pattern and then matcher

272
00:22:05,640 --> 00:22:10,240
Interprets what it returns to look for equivalence. So not for equivalent

273
00:22:10,240 --> 00:22:16,440
Sorry to find that pattern in a given string or a given object of type string

274
00:22:17,160 --> 00:22:19,160
So over here if I run this

275
00:22:22,920 --> 00:22:26,160
You'll see it returns true false false

276
00:22:26,160 --> 00:22:31,440
So the reason for that is because obviously this reg X is a reg X for an email address

277
00:22:31,440 --> 00:22:38,200
And the first one is an email address these two don't fulfill the requirements of this reg X pattern and

278
00:22:39,000 --> 00:22:40,680
Attending to our point

279
00:22:40,680 --> 00:22:44,320
This the designers made it made a call that

280
00:22:44,880 --> 00:22:46,520
Uses of this API

281
00:22:46,520 --> 00:22:51,840
Will never never want to compare instances of the pattern class. There's just no reason for it

282
00:22:51,840 --> 00:22:56,660
Therefore we can leave the this as an order to put it in a bit more

283
00:22:57,440 --> 00:22:59,040
formal sense

284
00:22:59,040 --> 00:23:02,800
The designers made it made a call that the users of this API

285
00:23:03,520 --> 00:23:08,160
Will never require logical equality between instances of the pattern class

286
00:23:09,760 --> 00:23:15,520
Therefore we can leave the equals method as it is they thought and at times like that

287
00:23:15,520 --> 00:23:21,680
there's no requirement to override the equals method and the other reason of course not override is if the class you're

288
00:23:21,680 --> 00:23:25,840
writing and designing already has a superclass and inherits

289
00:23:27,400 --> 00:23:34,640
Methods from the superclass and if that superclass is already overridden the the equals method appropriately to the subclass

290
00:23:35,480 --> 00:23:41,000
Then this wouldn't be an issue. We wouldn't have to again override the overridden equals method

291
00:23:41,000 --> 00:23:47,240
That would be a bit absurd. In fact, we're not gonna get to this in this part, but in the next part

292
00:23:47,240 --> 00:23:49,240
we're gonna discuss the

293
00:23:49,600 --> 00:23:50,960
The

294
00:23:50,960 --> 00:23:52,320
List code

295
00:23:52,320 --> 00:23:57,040
Substitution principle that is something we should follow when in class hierarchies and inheritance

296
00:23:57,360 --> 00:23:59,840
Because of that principle and if we do follow that principle

297
00:24:00,560 --> 00:24:05,760
theoretically, there shouldn't be a reason for or subclass to override a

298
00:24:06,360 --> 00:24:12,380
Equals method of a superclass that's already overridden the equals method of the object class if that makes sense

299
00:24:12,380 --> 00:24:16,860
So for instance before I get to the demo, let's take a look at this

300
00:24:17,260 --> 00:24:25,340
This is the class diagram for and I I'm not sure what the accuracy of this is because the Java collections framework is huge

301
00:24:25,340 --> 00:24:30,520
And it's growing huge sound like trumpet. It's huge and it's growing

302
00:24:31,260 --> 00:24:34,460
quite a lot and and as you can see here

303
00:24:34,460 --> 00:24:41,060
There's a there are there are many that all the class hierarchies their implementations and extensions and inheritance taking place so

304
00:24:42,120 --> 00:24:45,500
the example that Joshua block has given in the item is

305
00:24:47,100 --> 00:24:53,300
So don't override when a superclass has already overridden equals as I did say and the superclass

306
00:24:53,780 --> 00:24:58,180
Behavior is appropriate for this class and if we do follow that principle theoretically

307
00:24:58,180 --> 00:24:59,860
It should be the list curve

308
00:24:59,860 --> 00:25:07,520
Substitution principle for example most set implementations inherit their equals implementation from abstract set

309
00:25:07,860 --> 00:25:15,180
list implementations from abstract lists and map implementations from abstract map, and that's why I wanted to have this

310
00:25:16,060 --> 00:25:20,740
diagram here because so if we take a look at set you can see that the

311
00:25:21,420 --> 00:25:24,540
the set or the hash set in this case is

312
00:25:25,940 --> 00:25:27,940
inheriting

313
00:25:28,780 --> 00:25:35,940
Sorry the set interface is implemented by the abstract set as you can see here

314
00:25:37,060 --> 00:25:40,020
And so yeah, sorry. I gotta be confused there

315
00:25:40,020 --> 00:25:45,740
The set interface is implemented by the abstract set and I've caused in the concrete class

316
00:25:45,740 --> 00:25:48,460
Which is the hash set that is here

317
00:25:49,180 --> 00:25:50,780
extends that

318
00:25:50,780 --> 00:25:53,260
abstract set but also implements the set interface

319
00:25:54,460 --> 00:25:57,260
I'm not sure why that happens, but why would it?

320
00:25:57,860 --> 00:26:05,380
extend the abstract set and again implement the set interface if the abstract set has already

321
00:26:06,500 --> 00:26:08,500
implemented the set interface

322
00:26:08,620 --> 00:26:16,940
I'm not sure but in any case. I'm not gonna get into the Java collections framework here, but the point being if the superclass is appropriately

323
00:26:18,420 --> 00:26:21,780
Done the overriding. There's no requirement for

324
00:26:22,460 --> 00:26:29,860
The subclass to do the overriding again. So in the example that I've used I've just created a few has sets hash sets

325
00:26:30,740 --> 00:26:32,740
I'm just gonna write and show it to you

326
00:26:33,260 --> 00:26:35,260
Whoops

327
00:26:36,260 --> 00:26:38,260
Now you can see here I'm comparing

328
00:26:39,140 --> 00:26:42,380
the first hash set to the second one and the

329
00:26:42,820 --> 00:26:48,220
Again the first one of the third one the first two has set so hash hash set

330
00:26:49,300 --> 00:26:51,300
Has set and has set two

331
00:26:51,300 --> 00:26:55,140
They both have equivalence a in the sense of

332
00:26:55,860 --> 00:27:00,060
Logical equivalence so the content of the objects are the same. They both have effective Java

333
00:27:00,300 --> 00:27:08,740
Where's the third one hash set three has effective type strip a typescript and we compare hash set three to hash set one

334
00:27:08,860 --> 00:27:15,260
It's part. It's returning a false and that's what you expect. So that means a superclass which was the abstract

335
00:27:15,940 --> 00:27:24,300
Set class has done the overriding correctly and it's following the general contract of the object class equals method

336
00:27:25,300 --> 00:27:28,780
Just on the Java collections framework as you saw even I was quite confused

337
00:27:28,780 --> 00:27:36,620
I mean, I really don't know if anyone except probably the designers and you know the the pantheon of the Java legends

338
00:27:37,980 --> 00:27:43,700
Have a tarot understanding of the collections framework. It's it's quite quite large and extensive

339
00:27:44,460 --> 00:27:46,780
But if you do want to read about it

340
00:27:47,620 --> 00:27:50,300
This is in fact not even read about it

341
00:27:50,300 --> 00:27:54,540
But it's just good to that bookmark this page and use use it as a reference or these days you could just ask

342
00:27:54,940 --> 00:27:55,940
Chagapiti

343
00:27:55,940 --> 00:27:57,940
That life is much easier

344
00:27:58,260 --> 00:28:02,260
Okay, before I go for a tangent the the other reason

345
00:28:02,780 --> 00:28:05,620
to not override the equals method is

346
00:28:06,500 --> 00:28:14,860
If you're certain that the equals method will never be invoked quite straightforward that again probably relates to the other point where

347
00:28:15,380 --> 00:28:19,660
as a designer what has to make that call and and and see

348
00:28:19,700 --> 00:28:23,940
If users of this API will ever really invoke the equals method

349
00:28:24,140 --> 00:28:29,060
So Joshua block states that the class so even it will not be invoked if the class is

350
00:28:29,740 --> 00:28:36,580
Private or packaged private and you are certain that it's equals method will never be invoked. That was a confusing way

351
00:28:37,700 --> 00:28:41,980
For me to put it but you get the point and then he states if you extremely risk averse

352
00:28:42,220 --> 00:28:47,340
You can override the equals method to ensure that it isn't invoked accidentally

353
00:28:47,380 --> 00:28:49,380
And I think it's good to be

354
00:28:49,940 --> 00:28:55,740
Risk averse in that sense and I shall show the demo as to why it's probably a good idea to override the equals method

355
00:28:56,340 --> 00:29:03,140
Regardless of it being private regardless of the class being private or packaged private in this demo

356
00:29:03,500 --> 00:29:09,140
So we have this class called demo and then in that class we have a private in a class

357
00:29:09,460 --> 00:29:15,900
So a private in a class now this class would only be used by the demo class because it's private

358
00:29:16,020 --> 00:29:21,620
No one outside can use it. It's well encapsulated and in the private in a class

359
00:29:21,620 --> 00:29:23,620
We have overwritten the equals method

360
00:29:24,060 --> 00:29:29,780
And I shall show this bit a bit later. This is how you be fully risk averse and prevent

361
00:29:30,420 --> 00:29:36,020
Any class from overriding the equals method or any use of this API

362
00:29:36,660 --> 00:29:42,060
So if you go to the this private in a class method, which I know can be a bit confusing

363
00:29:42,060 --> 00:29:46,460
I call it a private in a class method not because it's inside the private in a class

364
00:29:46,660 --> 00:29:53,500
But this method which is a public method can be used to access this private in a class via

365
00:29:53,940 --> 00:29:56,740
The outer demo class. So that's what we're doing here

366
00:29:56,740 --> 00:30:00,820
We're creating a new object of the inner class and we're calling this function call

367
00:30:01,420 --> 00:30:06,580
Display and then we have perhaps a malicious actor who's trying to

368
00:30:07,100 --> 00:30:10,580
Do the same thing access that it private in a class

369
00:30:11,580 --> 00:30:16,180
Via the outer demo class and try to invoke the equals method

370
00:30:16,420 --> 00:30:19,940
So if I do run this code, so here's a client that use that's using it

371
00:30:19,940 --> 00:30:25,660
We've created an object of type demo a new instance of demo class and if I run this

372
00:30:26,580 --> 00:30:33,140
You'll see as expected. It's it's running the private in a class method and it's first printing

373
00:30:34,140 --> 00:30:37,260
this log here and then it's also printing the

374
00:30:38,020 --> 00:30:40,020
log inside

375
00:30:40,060 --> 00:30:46,820
The method display which is inside. Sorry of the method display which is inside the inner class the private in a class

376
00:30:47,340 --> 00:30:51,840
That's fine. That's okay. We probably expect that. However, let's say

377
00:30:52,420 --> 00:30:54,420
This person wants to access

378
00:30:55,260 --> 00:30:57,260
What do I do there? I?

379
00:30:57,300 --> 00:31:03,220
Collapsed my function. Okay, let's say this person wants to access the equals method

380
00:31:03,220 --> 00:31:06,940
That's in the private in a class and we don't want it to be

381
00:31:07,700 --> 00:31:09,700
accessed by anyone

382
00:31:10,020 --> 00:31:14,940
In that case what we can do is we can throw a new assertion error saying keep away

383
00:31:15,740 --> 00:31:20,460
And therefore if a client now tries to access the equals method

384
00:31:20,980 --> 00:31:23,180
By the other class it'll throw an arrow

385
00:31:25,660 --> 00:31:27,100
Just like that

386
00:31:27,100 --> 00:31:32,780
Throw an assertion error saying keep away and that's how you be extra punctilious and careful

387
00:31:33,260 --> 00:31:35,900
And not allow anyone to use the equals method

388
00:31:36,900 --> 00:31:42,700
Especially if that someone's expected by the designer that is that is the end of item

389
00:31:43,380 --> 00:31:48,020
10 part 1 I was gonna say at the end of item 10 most certainly not

390
00:31:48,020 --> 00:31:56,020
We've still got heaps to cover in fact part 2 of this item is gonna be quite long because we need to go through all the reasons

391
00:31:58,180 --> 00:32:01,860
When it is appropriate to override the equals method and that's quite interesting

392
00:32:02,060 --> 00:32:07,480
So and then in part 3 we'll we'll finish it off with kind of summarizing on how

393
00:32:08,140 --> 00:32:13,660
To respect and obey the general contract went over an equals method and again

394
00:32:13,660 --> 00:32:16,580
I know it's quite long, but there's a reason that I'm doing that as I said

395
00:32:16,580 --> 00:32:19,100
I won't the intent of these items is

396
00:32:19,700 --> 00:32:21,700
To go as deep as possible

397
00:32:21,940 --> 00:32:23,940
Within what what I can manage

398
00:32:24,660 --> 00:32:30,380
And I hope you find value in it because what's the reason what's the use of just superficially reading these things?

399
00:32:30,380 --> 00:32:35,140
If we don't really grok the concepts saying all that thank you for watching

400
00:32:35,140 --> 00:32:39,040
I hope you found value in this video. I shall see you in the next one. Cheers

