1
00:00:00,000 --> 00:00:04,480
Hey everyone, welcome to this second episode of the video series that I've very

2
00:00:05,040 --> 00:00:13,960
Incipitally and uncreatively called textbook to code where I take software engineering and computer science principles from textbooks and

3
00:00:14,800 --> 00:00:21,680
Convert them to code and expound on them and try and make sense of them in as much detail as I can manage

4
00:00:22,400 --> 00:00:26,760
and the book I've picked for this well, I guess for the start of this series is

5
00:00:27,480 --> 00:00:34,920
Effective Java by Joshua Block certainly the best programming book I've read so far and the book's got I believe

6
00:00:35,160 --> 00:00:38,920
90 yes 90 items and we're still on item two

7
00:00:39,480 --> 00:00:42,520
So I'm sure it's gonna take me a long time to get through the whole book

8
00:00:42,600 --> 00:00:45,400
But that's what's exciting about this because I I feel like

9
00:00:46,280 --> 00:00:49,480
One item leads to another item and that item leads to another item

10
00:00:49,880 --> 00:00:56,040
And that would point to some design pattern that would point to some concept in Java or you know computer science in general

11
00:00:56,600 --> 00:00:58,600
and I find that really interesting and

12
00:00:59,240 --> 00:01:04,840
Really, I hope a lot of a lot of programming books and especially well written the way this book is written

13
00:01:05,240 --> 00:01:10,280
By Joshua Block saying that though as per usual as I did do in the previous episode

14
00:01:10,920 --> 00:01:13,800
I want to make a few caveats or have a little bit of a proviso

15
00:01:13,960 --> 00:01:17,000
So if you did watch the previous episode you can skip this bit

16
00:01:17,480 --> 00:01:21,320
Because I'll pretty much be repeating the same thing for any new viewers

17
00:01:21,880 --> 00:01:27,640
Uh, the first point of course is this is not a tutorial. So unlike many

18
00:01:28,200 --> 00:01:33,960
Programming videos on youtube. I certainly don't want this to be a tutorial. I'm not a teacher

19
00:01:34,440 --> 00:01:36,440
definitely not an expert

20
00:01:36,440 --> 00:01:38,440
and I'm not trying to

21
00:01:38,840 --> 00:01:42,840
Tell you how something is done really what I'm doing is

22
00:01:43,720 --> 00:01:47,960
Collectively trying to make sense of certain concepts in this book

23
00:01:48,440 --> 00:01:52,760
And trying to understand them it really in many ways is a selfish pursuit in that sense

24
00:01:53,240 --> 00:01:59,160
Because I'm not trying to teach anyone. I'm just trying to make sense of it and you know along the way if you get value from it

25
00:01:59,480 --> 00:02:04,680
Fantastic, that's at least what I hope frankly. I like to think of it as blindly leading the blind

26
00:02:05,320 --> 00:02:10,280
Uh, but in this case really I'm not leading but I guess because you're watching this video in some sense

27
00:02:10,360 --> 00:02:14,200
I am but uh, I am as blind and ignorant as you are

28
00:02:14,760 --> 00:02:16,760
Uh, it's this is simply a

29
00:02:17,320 --> 00:02:24,200
Exploratory disposition. That's it. Uh, and I think what I want this to be is is similar to what

30
00:02:24,840 --> 00:02:26,040
We would do what I mean

31
00:02:26,040 --> 00:02:32,840
We if you've done a computer science or software engineering degree in a university tutorial where you get together

32
00:02:33,320 --> 00:02:34,440
There is a tutorial of course

33
00:02:34,440 --> 00:02:37,320
but generally what happens is you get together with your mates with your

34
00:02:38,040 --> 00:02:42,920
The other students and try to make sense of some assignment problem or some programming problem

35
00:02:43,720 --> 00:02:46,840
And I think there's great learning that happens in that kind of

36
00:02:47,480 --> 00:02:53,400
Collaborative collective thinking and needless to say but I have to say it because this is a proviso for all

37
00:02:53,880 --> 00:02:59,720
I will inevitably make mistakes. So please point them out. Leave them down in the comment section below

38
00:03:00,360 --> 00:03:04,600
Of course for my own learning, but especially because I don't want to mislead anyone

39
00:03:05,080 --> 00:03:08,840
And I think that's why in every single video, even though it's going to get a bit repetitive

40
00:03:09,240 --> 00:03:13,720
I am gonna have this bit where I do say, please don't think of this as a tutorial

41
00:03:14,040 --> 00:03:17,160
I don't think I'm in a place to teach anyone programming at the moment

42
00:03:18,040 --> 00:03:21,960
And on the note of programming, of course, this is a programming video

43
00:03:21,960 --> 00:03:26,200
So, uh, it only makes sense to have all the code that I use on get up

44
00:03:26,600 --> 00:03:29,000
Not only my code, but I'll also link

45
00:03:29,800 --> 00:03:32,040
All the code that Joshua block has

46
00:03:32,920 --> 00:03:35,080
Published on his personal get up repository

47
00:03:35,560 --> 00:03:41,480
For item two of effective java. So on that note without further ado, let's get started

48
00:03:42,200 --> 00:03:48,760
The second item states consider a builder method when faced with many constructor parameters

49
00:03:49,160 --> 00:03:54,600
Personally, I found it much easier to understand this item than the previous one. It made a lot more sense

50
00:03:55,160 --> 00:03:57,960
Probably because I have faced this problem

51
00:03:58,520 --> 00:04:00,520
Day to day working in my team

52
00:04:01,080 --> 00:04:07,080
Where there's mostly a utility class with a whole bunch of parameters for constructors

53
00:04:07,800 --> 00:04:12,440
And it can be a real pain to manage and even using it as a client can be

54
00:04:13,560 --> 00:04:15,720
It's quite chaotic at times and quite a mess

55
00:04:16,440 --> 00:04:18,040
So he states

56
00:04:19,560 --> 00:04:22,760
Static factories and constructors share a limitation

57
00:04:23,160 --> 00:04:27,240
They do not scale well to a large number of optional parameters

58
00:04:27,800 --> 00:04:31,640
So of course, I don't think I need to go into detail on what optional parameters mean

59
00:04:32,040 --> 00:04:34,760
The term itself is self-explanatory

60
00:04:35,400 --> 00:04:40,840
And over here though, this example kind of demonstrates that even though what we've done here is use the

61
00:04:41,480 --> 00:04:43,480
telescope constructor pattern, which

62
00:04:43,560 --> 00:04:47,320
Joshua block says is a bad idea that it probably shouldn't be used even though

63
00:04:48,120 --> 00:04:54,680
This is what traditionally programmers have used and in fact in the codebith that I'm working on right now in my current company

64
00:04:55,000 --> 00:04:57,000
I believe this is what we've done. Oh

65
00:04:57,400 --> 00:05:02,440
Well, I think we did this in a previous version, but we did change it up. So that's that's really good

66
00:05:03,000 --> 00:05:09,640
Um, and this is what this really does is as you can see here. I have two instances of the nutrition facts class, which is

67
00:05:10,520 --> 00:05:13,720
Uh, this class here. It's got a bunch of privately defined

68
00:05:14,280 --> 00:05:16,280
member variables and

69
00:05:16,760 --> 00:05:22,920
This is the bit that sort of implements the telescope constructor, but I'll get to that a bit later the idea being

70
00:05:23,880 --> 00:05:26,760
Both these instances Koch and Bundaberg

71
00:05:27,320 --> 00:05:33,960
They've got different number of parameters have been passed into it because of course some optional. In fact, I think most optional

72
00:05:34,440 --> 00:05:39,960
Uh, and depending on how you want to build it how you want to construct your object. You can define it

73
00:05:40,520 --> 00:05:44,040
So now let's go to the bit where dorsal box says

74
00:05:45,000 --> 00:05:49,640
Traditionally, as I did say before programmers have used a telescoping constructor pattern

75
00:05:50,280 --> 00:05:54,440
In which you provide a constructor with only the required parameters

76
00:05:55,160 --> 00:05:57,880
Another with a single optional parameter

77
00:05:58,280 --> 00:06:00,280
a third with two optional parameters

78
00:06:00,760 --> 00:06:01,960
And so on

79
00:06:01,960 --> 00:06:05,800
culminating in a constructor with all the optional parameters

80
00:06:06,200 --> 00:06:11,720
So these two objects Koch and Bundaberg which both are instances of the nutrition facts class

81
00:06:12,360 --> 00:06:15,880
The Koch object is pretty much using all the parameters

82
00:06:16,680 --> 00:06:19,960
It's using this constructor here. Oh, sorry this constructor here

83
00:06:20,600 --> 00:06:26,200
And then the Bundaberg object, which is just using only three optional parameters. We've said which uses

84
00:06:26,920 --> 00:06:28,920
this constructor here

85
00:06:28,920 --> 00:06:36,280
Regardless, you probably can see what I'm doing now. We've passed a lot of zeros. It's unnecessary and even on the client side

86
00:06:37,160 --> 00:06:43,800
Or on the client that's using this constructor has just passed zeros sometimes when for the value fat

87
00:06:44,520 --> 00:06:50,040
Uh, and you know, it's not that complicated if you look at the code base, you can see that it's firstly

88
00:06:50,120 --> 00:06:54,040
It's very verbose just just the constructors itself in the beginning of the class

89
00:06:54,680 --> 00:07:01,000
You got God knows how many I mean here. There are only six parameters, but imagine if it's a class with 20 30

90
00:07:01,640 --> 00:07:04,200
member variables or whatever you want to you want to set

91
00:07:05,160 --> 00:07:07,160
when you know constructing that class

92
00:07:08,040 --> 00:07:10,040
Constructing that object, sorry

93
00:07:10,440 --> 00:07:15,400
And as Joshua Bock says in short the telescoping constructor pattern works

94
00:07:15,640 --> 00:07:16,840
Of course it does

95
00:07:16,840 --> 00:07:20,520
But it is hard to write client code when there are many parameters and

96
00:07:21,000 --> 00:07:23,000
harder still to read

97
00:07:23,000 --> 00:07:27,000
He also states and this is kind of funny. This is uh, I recently tweeted

98
00:07:27,800 --> 00:07:31,240
That I like to call myself a programmer, but IntelliJ

99
00:07:32,120 --> 00:07:34,200
writes most of my code for me

100
00:07:34,520 --> 00:07:36,520
So I don't really do anything anymore

101
00:07:36,920 --> 00:07:40,680
Than just using autofill and IntelliJ kind of taking care of everything else

102
00:07:41,720 --> 00:07:45,800
The id that the modern ids are so good that this problem doesn't really apply anymore

103
00:07:45,880 --> 00:07:50,440
I think because he says here if the client accidentally accidentally

104
00:07:51,080 --> 00:07:57,080
Reverses two such parameters the compiler won't complain, but the program will misbehave at runtime

105
00:07:57,480 --> 00:08:02,280
So what he means here is you probably can see, uh, let's take this second object

106
00:08:02,920 --> 00:08:04,360
Bundaberg

107
00:08:04,360 --> 00:08:06,360
Bundaburg object

108
00:08:07,240 --> 00:08:13,080
And what we need to pass as the first parameter is the serving size and then it'll get it'll get set properly

109
00:08:13,720 --> 00:08:15,000
in the class

110
00:08:15,000 --> 00:08:15,960
member

111
00:08:15,960 --> 00:08:18,360
And then there's servings and calories. So let's say

112
00:08:19,160 --> 00:08:26,360
You said the serving size is two and servings as 360 that is wrong, but the compiler won't complain

113
00:08:27,080 --> 00:08:32,440
The error will only come up at runtime. Maybe the q18 will pick it up or some unit test. Who knows?

114
00:08:33,080 --> 00:08:35,080
um, but

115
00:08:35,240 --> 00:08:41,640
Of course with i with IntelliJ or most modern ids that problem won't be an issue because when the client is using that constructor

116
00:08:41,800 --> 00:08:47,080
It does exactly say what you're supposed to pass. So it's pretty clear and explicit, but nevertheless

117
00:08:48,040 --> 00:08:52,120
That's one downside of it and we shouldn't always rely on ids

118
00:08:52,680 --> 00:08:53,080
um

119
00:08:53,080 --> 00:08:58,840
The negative of course is the problem is scaling and also just passing these useless zeros into constructors

120
00:08:58,920 --> 00:09:02,680
So and it's fair to say arguably, uh, the telescope constructor is an anti-pattern

121
00:09:03,000 --> 00:09:06,280
Where our class has multiple constructors with different signatures

122
00:09:06,920 --> 00:09:08,920
varying parameters in particular and

123
00:09:09,320 --> 00:09:11,320
I believe if you do just google the word

124
00:09:11,960 --> 00:09:16,840
Constructor pattern, there'll be a lot of blog posts regarding why it is an anti-pattern

125
00:09:17,560 --> 00:09:19,480
um

126
00:09:19,480 --> 00:09:26,200
Look at this just the the top searches are regarding alternatives to the telescope constructor pattern it being an anti-pattern whatnot

127
00:09:26,840 --> 00:09:32,840
um, and even this video here saying avoid telescope telescoping constructors with build a pattern

128
00:09:33,880 --> 00:09:38,840
Makes sense. Uh, probably a lot of these blog posts were inspired by Joshua Bloke himself

129
00:09:39,000 --> 00:09:43,000
That moves us to something probably a bit better than the telescope constructor pattern

130
00:09:43,560 --> 00:09:45,560
The java beans pattern in this pattern

131
00:09:45,880 --> 00:09:46,920
you call a

132
00:09:46,920 --> 00:09:53,800
Parameterless constructor to create the object and then call setter methods to set each required parameter

133
00:09:54,280 --> 00:09:57,960
And each optional parameter of interest. So let's see what that means

134
00:09:58,360 --> 00:10:04,440
But before we get to that, I just realized I should expound on these two points. It'll just make things a bit more easier. Um, now

135
00:10:05,160 --> 00:10:08,760
Java beans, what is java beans? We we hear this term everywhere if you're a java developer

136
00:10:09,400 --> 00:10:11,400
All that is is a standard

137
00:10:11,560 --> 00:10:17,960
It gives a class an empty constructor with getters and setters. Um, a public sorry a public

138
00:10:18,760 --> 00:10:20,760
argumentless argumentless

139
00:10:20,760 --> 00:10:23,240
constructor and it's also serializable

140
00:10:23,960 --> 00:10:30,120
Even though this is what a java beans is the java beans pattern still isn't the most apt

141
00:10:30,840 --> 00:10:32,280
pattern to use

142
00:10:32,280 --> 00:10:35,880
when faced with many constructors and as Joshua Bloke him

143
00:10:37,080 --> 00:10:41,080
I'm going to start calling him JB. It's just easier because Joshua Bloke is a mouthful

144
00:10:41,160 --> 00:10:47,480
So as JB himself states the java beans pattern has serious disadvantages

145
00:10:47,880 --> 00:10:50,440
So I did read out the definition of what this pattern is before

146
00:10:50,840 --> 00:10:55,880
This is really much easier to even understand conceptually than the telescoping constructor pattern

147
00:10:56,680 --> 00:11:01,720
Clearly what you're doing here. So we've got another class. We've got a class called nutrition facts JB

148
00:11:02,200 --> 00:11:04,200
Um, why do I call it JB?

149
00:11:05,640 --> 00:11:09,080
I don't know why it's oh, of course because it's uh java beans

150
00:11:09,400 --> 00:11:16,600
I I wanted to call it JB just to differentiate it. I guess and we've declared or we've defined the

151
00:11:16,760 --> 00:11:18,760
empty public constructor here

152
00:11:19,000 --> 00:11:26,040
And that allows us to create a coca-cola object of this from this class and simply using the setters

153
00:11:26,920 --> 00:11:31,000
I've set all the values. So whatever the members are serving size

154
00:11:32,040 --> 00:11:34,040
calories whatnot

155
00:11:34,360 --> 00:11:41,000
And yeah, it's as simple as that. That's what it does. However, as I said before, this is not a good pattern to use

156
00:11:41,400 --> 00:11:43,960
when one is given a class with a lot of

157
00:11:44,920 --> 00:11:46,920
constructor parameters

158
00:11:46,920 --> 00:11:50,360
Firstly, of course, you know practically speaking as you can say it's a bit verbose

159
00:11:50,600 --> 00:11:52,920
It's it's it's just to create this object

160
00:11:52,920 --> 00:11:56,760
You got to do all these things and use setters and set the values kind of annoying

161
00:11:57,240 --> 00:12:03,880
Uh, and the second one and this is an interesting one. I'm going to first read out the paragraph and explain what JB means by this

162
00:12:05,720 --> 00:12:13,000
The class does not have the option of enforcing consistency merely by checking the validity of the constructor parameters

163
00:12:13,640 --> 00:12:17,960
Attempting to use an object when it's in an inconsistent state may cause failures

164
00:12:18,280 --> 00:12:23,000
That are far removed from the code containing the bug and hence difficult to debug

165
00:12:23,560 --> 00:12:26,520
A related disadvantage is that java bean's pattern

166
00:12:26,840 --> 00:12:29,400
precludes the possibility of making a class immutable

167
00:12:29,800 --> 00:12:35,720
And requires added effort on the part of the programmer to ensure threat safety. What that really means is this it's

168
00:12:36,360 --> 00:12:40,440
and I'm again, I there are all these terms some of these terms are a big technical

169
00:12:41,400 --> 00:12:42,200
and

170
00:12:42,200 --> 00:12:48,440
But I'm quite sure, you know, I'm not a senior java and programmer who's been coding for years and years

171
00:12:48,520 --> 00:12:51,320
I've only really been coding for a couple two or three years

172
00:12:51,720 --> 00:12:53,720
But I've I've still seen things like this

173
00:12:54,520 --> 00:12:56,280
day to day at work

174
00:12:56,280 --> 00:12:57,400
so

175
00:12:57,400 --> 00:12:58,920
over here you

176
00:12:58,920 --> 00:13:03,800
Initially construct the coca-cola object with the empty construct empty constructor

177
00:13:04,360 --> 00:13:10,200
And then you say you set the value using a setup set serving whatever and then you say set servings whatever

178
00:13:10,440 --> 00:13:13,720
Set calories whatever and then let's say while

179
00:13:14,360 --> 00:13:19,720
This object is in the process of being constructed. It's it's it's in a certain state

180
00:13:20,760 --> 00:13:24,680
Someone decides to do some computation here using this object

181
00:13:25,720 --> 00:13:27,880
So decides to do some computation

182
00:13:28,440 --> 00:13:29,800
using

183
00:13:29,800 --> 00:13:31,800
This object coca-cola

184
00:13:32,120 --> 00:13:34,920
Now this can give us a lot of problems because the class

185
00:13:35,480 --> 00:13:36,680
doesn't

186
00:13:36,680 --> 00:13:37,880
mandate

187
00:13:37,880 --> 00:13:41,000
For the object to have a consistent state when it's being created

188
00:13:41,560 --> 00:13:43,240
because let's say

189
00:13:43,240 --> 00:13:49,400
When this computation takes place these two values set sodium and set carbohydrate are necessary

190
00:13:50,760 --> 00:13:53,560
And most of these errors will only be called runtime

191
00:13:53,800 --> 00:13:56,040
It cannot be called compile time clearly

192
00:13:56,360 --> 00:14:01,800
It cannot be called compile time because if I just go and let's say do something here system. I'm just gonna print this out

193
00:14:01,800 --> 00:14:03,800
I know it's really not a computation

194
00:14:04,280 --> 00:14:10,200
But it doesn't throw any errors here the id doesn't indicate that all this this this object is in an inconsistent state

195
00:14:10,920 --> 00:14:14,040
And this is a in my opinion when I did

196
00:14:14,600 --> 00:14:21,400
Understand what this is. I think it can be a serious disadvantage, especially in large enterprise level

197
00:14:21,800 --> 00:14:26,040
Systems, which is mostly what chava is used for, you know, in like distributed systems

198
00:14:26,440 --> 00:14:28,920
And he is just to reiterate the point jebi makes

199
00:14:29,480 --> 00:14:32,840
Attempting to use an object when it's in an inconsistent state. So

200
00:14:33,640 --> 00:14:36,520
Let's just assume for all intents and purposes

201
00:14:37,320 --> 00:14:44,520
At best level this critical object is in an inconsistent state. We don't want it to be in that state and be used by a client

202
00:14:46,920 --> 00:14:51,880
Make us failures that are far removed from the code containing the bug and hence difficult to debug

203
00:14:52,200 --> 00:14:56,760
I don't make sense because they're runtime errors and we all know that runtime errors are quite difficult

204
00:14:57,560 --> 00:14:59,560
to debug

205
00:15:00,520 --> 00:15:05,400
And in my notes, I've stated here with a bit more brevity compared to the long-winded way I explained it

206
00:15:06,120 --> 00:15:11,800
Splitting the construction to multiple parts may put the java being in an inconsistent state

207
00:15:11,960 --> 00:15:16,760
So clearly the construction is being split into multiple parts and there's a high possibility

208
00:15:17,560 --> 00:15:19,560
That it could be in such an inconsistent state

209
00:15:21,000 --> 00:15:22,840
Which is why

210
00:15:22,840 --> 00:15:24,440
JB proposes

211
00:15:24,440 --> 00:15:26,440
Using the builder pattern

212
00:15:26,440 --> 00:15:31,400
Now what is the builder pattern? So let's try to understand firstly. There's a quote that I've got here by

213
00:15:32,040 --> 00:15:35,720
But the great book uh from from the great book design patterns by the gang of four

214
00:15:36,040 --> 00:15:43,080
I haven't read that book yet. I I own a copy. I refer to it, but I'm I'm really hoping to do a similar video with that book too

215
00:15:44,280 --> 00:15:46,600
Probably I'll probably get I'll probably do this

216
00:15:46,840 --> 00:15:49,320
But first the head first design patterns

217
00:15:49,960 --> 00:15:55,240
And then I'll see if it's worth doing one of that book too. I'm just gonna do it. I'm just gonna do it

218
00:15:56,440 --> 00:16:02,360
Because I want to because I'm a I'm a fan. I'm a I'm a connoisseur of great programming books

219
00:16:03,800 --> 00:16:05,880
So here's what the gang of four states

220
00:16:06,600 --> 00:16:10,920
What the builder pattern does is separate the construction of a complex object

221
00:16:11,640 --> 00:16:17,960
From its representation so that the same construction process can create different representations

222
00:16:18,440 --> 00:16:24,440
Okay, what in the world does that mean? Let's take a look at another way the nutrition facts class

223
00:16:25,160 --> 00:16:27,160
Was constructed but in this case

224
00:16:27,720 --> 00:16:32,760
Using the builder pattern on the client side using the builder pattern on the nutrition effects class

225
00:16:33,160 --> 00:16:35,320
Constructing the objects using that pattern

226
00:16:36,280 --> 00:16:43,080
It's done beautifully. It helps us to circumvent some of the disadvantages that we discussed earlier with the previous patterns

227
00:16:43,800 --> 00:16:45,240
But saying that though

228
00:16:45,240 --> 00:16:50,600
Of course, it's a bit harder to understand as to how it works. The first thing to keep in mind is

229
00:16:51,560 --> 00:16:54,360
There's an inner public study class called builder

230
00:16:54,360 --> 00:16:59,480
So the separate builder class in the nutrition facts class and when we do construct this object

231
00:16:59,480 --> 00:17:05,000
There's no way of constructing it without using this builder class the the inner builder class

232
00:17:05,560 --> 00:17:11,000
Let's run go through this line by line. I think that's the best way to understand this when we do construct this object

233
00:17:11,720 --> 00:17:16,680
We don't directly use the nutrition facts class. We instead

234
00:17:17,640 --> 00:17:23,320
Make the desired object using this inner builder class and of course because it's static

235
00:17:23,560 --> 00:17:27,880
You could just access it as it belongs to the nutrition facts class itself

236
00:17:28,680 --> 00:17:32,760
You could access it directly. I mean so simply put the way the client

237
00:17:33,160 --> 00:17:38,920
Really constructs this object is using the builder object and the builder object has some setup methods

238
00:17:39,320 --> 00:17:41,320
How does that work? So let's take a look at this

239
00:17:42,360 --> 00:17:43,400
it's got

240
00:17:43,480 --> 00:17:45,960
nutrition facts our builder and of course

241
00:17:46,440 --> 00:17:52,840
There are some parameters that are mandatory you you need them to even construct this object and those the those two are

242
00:17:53,560 --> 00:17:57,160
In this the builder class is serving size and servings

243
00:17:57,720 --> 00:17:59,720
So that would be defined here

244
00:18:00,440 --> 00:18:02,840
When we do the constructor for the builder class

245
00:18:03,320 --> 00:18:08,040
Have these two values as being mandatory and afterwards, of course, it allows us to

246
00:18:09,000 --> 00:18:13,880
Simply set the other values as per our requirements as for the client's requirements

247
00:18:14,280 --> 00:18:18,440
So in the for coca-cola, we've set the calories the calories are right here

248
00:18:19,720 --> 00:18:21,720
And then we've set

249
00:18:23,160 --> 00:18:27,960
Oh, there's another thing I want to add here. Do we get to that a bit later?

250
00:18:30,280 --> 00:18:34,600
Oh, sorry, there's a bit here about invalid parameters. We shall get to that a bit later

251
00:18:35,080 --> 00:18:37,720
So we are adding the calories and the way we're adding the sodium

252
00:18:38,280 --> 00:18:40,280
carbohydrate, whatever

253
00:18:40,600 --> 00:18:43,480
And those stuff are being passed on to the private

254
00:18:44,280 --> 00:18:49,160
constructor construction Jesus the private constructor of the nutrition facts class

255
00:18:49,960 --> 00:18:52,840
And it's been accessed through this builder object

256
00:18:53,880 --> 00:19:00,280
Then afterwards when the the client is done using or the client is done constructing

257
00:19:00,680 --> 00:19:05,640
The coca-cola object you simply use the build method and build the object

258
00:19:06,520 --> 00:19:08,840
quite straightforward if you think about it and even

259
00:19:09,960 --> 00:19:15,560
Practically or conceptually this makes a lot of no sense. And yeah, I should mention this the client calls a

260
00:19:16,200 --> 00:19:18,200
Parameterless build method, which I did mention

261
00:19:19,000 --> 00:19:24,200
To generate the object which is typically immutable and now I want to get to that bit that I said I'll discuss a bit later

262
00:19:24,920 --> 00:19:29,320
Previously, it's this idea about having valid parameters

263
00:19:29,640 --> 00:19:36,360
Here's a good example of this in the builder class. So the only role for the builder class is to really build objects

264
00:19:36,920 --> 00:19:39,480
therefore in all these methods one could do

265
00:19:40,440 --> 00:19:43,320
checks for invalid parameters and throw

266
00:19:44,120 --> 00:19:51,640
Illegal argument exceptions if for instance when building this class. Sorry when building this object someone passes a

267
00:19:52,920 --> 00:19:57,160
Parameter of a or an argument which is of illegal typo

268
00:19:57,960 --> 00:20:00,360
If it's of illegal quality

269
00:20:01,400 --> 00:20:03,400
I'm just looking for the word here doesn't matter

270
00:20:03,960 --> 00:20:07,720
Sometimes sorry. It's been a long day my mind my mind my mind brains everywhere

271
00:20:08,520 --> 00:20:10,360
Here's here's an example of this

272
00:20:10,360 --> 00:20:16,920
So calories, of course anything can't really have negative calories. At least that's what we're told

273
00:20:17,560 --> 00:20:19,720
And I think that's true. So over here

274
00:20:19,800 --> 00:20:25,800
I've initially I've passed the calories to be 100 when constructing this object and I'm doing a check

275
00:20:27,160 --> 00:20:31,000
On the calories method, which is here in this method

276
00:20:31,880 --> 00:20:33,880
whether the value is

277
00:20:34,440 --> 00:20:38,920
Well, the value should be greater than zero for me to set it into the calories

278
00:20:40,120 --> 00:20:41,480
member variable

279
00:20:41,480 --> 00:20:47,000
If not, I'll throw a illegal argument exception. So if I go

280
00:20:47,960 --> 00:20:49,960
And do minus eight

281
00:20:51,320 --> 00:20:53,320
And then if I try to run it

282
00:20:54,120 --> 00:21:01,880
There we go at runtime, I'll say, you know, it's negative. You can't have negative calories. What are you crazy?

283
00:21:02,200 --> 00:21:04,600
What are you trying to sell one of those?

284
00:21:06,040 --> 00:21:08,040
Fit teas on instagram

285
00:21:09,480 --> 00:21:14,440
I'm just I'm trying to make a joke and be funny, but that was just a terrible joke

286
00:21:15,000 --> 00:21:16,840
pathetic

287
00:21:16,840 --> 00:21:18,840
uh, so Joshua block says

288
00:21:19,640 --> 00:21:22,520
To detect invalid parameters as soon as possible

289
00:21:23,000 --> 00:21:29,320
Check parameter validity in the builders constructor constructor and methods. So that's what I've done here pretty much

290
00:21:30,120 --> 00:21:35,480
Check invariance involving multiple parameters. So this is again, I'm checking this parameter here

291
00:21:36,920 --> 00:21:41,560
Do the checks on object fields after copying parameters from the builder if a check fails

292
00:21:42,120 --> 00:21:44,120
Throw an illegal argument exception

293
00:21:44,440 --> 00:21:47,480
Whose detail message indicates which parameter is invalid

294
00:21:47,800 --> 00:21:53,720
That's that's actually a good point because it even tells us specifically here where it's failing. So we know

295
00:21:54,520 --> 00:22:00,280
Debugging is much easier that that that's a best way of putting it because if you do recall with the

296
00:22:01,320 --> 00:22:02,600
previous two

297
00:22:02,600 --> 00:22:04,600
patents a big issue is

298
00:22:04,840 --> 00:22:10,920
Even if something fails on runtime the debugging can be a lot more harder and much more deeply in the code that is

299
00:22:11,720 --> 00:22:18,360
Not gonna make programming easy and of course if I didn't already state before the code is a lot more neater. It looks prettier

300
00:22:19,160 --> 00:22:25,080
You could use method chaining keeps the code concise and very importantly. We don't run into that problem of having

301
00:22:25,880 --> 00:22:27,880
objects uh in

302
00:22:28,520 --> 00:22:32,040
Inconsistent states like we would do with the java beans pattern

303
00:22:32,440 --> 00:22:37,640
Because that isn't allowed here because you need to chain all the methods when constructing the object

304
00:22:37,720 --> 00:22:41,720
And certainly method chaining is something we see a lot in different jdk libraries

305
00:22:42,280 --> 00:22:44,840
It's most probably because they've used the builder pattern

306
00:22:45,400 --> 00:22:48,440
Which is why for us using them. It's a lot more easier

307
00:22:48,840 --> 00:22:53,800
And then jb states the builder pattern is well suited to class hierarchies

308
00:22:54,760 --> 00:22:59,320
Use a parallel hierarchy of builders each nested in the corresponding class

309
00:22:59,800 --> 00:23:01,800
Abstract classes can have abstract builders

310
00:23:02,280 --> 00:23:06,680
Concrete classes can have concrete builders. This was a bit hard for me to get it

311
00:23:07,160 --> 00:23:11,160
I wouldn't say it was hard for me to get but there's one certain part which I'll get to a bit later

312
00:23:11,560 --> 00:23:13,160
involving generics

313
00:23:13,160 --> 00:23:16,840
Which I had to really struggle to get my head around it

314
00:23:17,560 --> 00:23:22,520
But once again, though it does once you once it does make sense once it once it clicks

315
00:23:23,480 --> 00:23:26,920
You can see the beauty of the builder pattern in it and that's the best part about it

316
00:23:27,000 --> 00:23:32,680
So let's try to understand what he means by the builder pattern is well suited to class hierarchies

317
00:23:33,000 --> 00:23:37,560
Firstly, I'll simply define or explain this class hierarchy. I've built here

318
00:23:38,040 --> 00:23:42,600
We have a simple abstract pizza class which I've defined here as you can see

319
00:23:43,160 --> 00:23:47,320
And then we have two subclasses that inherits this class. We have calzone

320
00:23:47,720 --> 00:23:51,480
Which extends which is a concrete class that extends the abstract pizza class

321
00:23:51,960 --> 00:23:57,400
And then we have we have sorry new york pizza, which is also another concrete class which extends the

322
00:23:57,960 --> 00:24:01,720
abstract pizza class and afterwards if you do go to the client you could see

323
00:24:02,280 --> 00:24:06,600
How it's been implemented and again, I know this is a very high level, but I'll go into the details soon

324
00:24:08,200 --> 00:24:10,200
Similar pattern if you do run it

325
00:24:10,200 --> 00:24:15,720
You'll see both these objects being have been created and I'm getting the superclass

326
00:24:15,800 --> 00:24:20,200
It's both got the same pizza superclass make sense similar pattern

327
00:24:20,680 --> 00:24:23,160
ending with the build method so firstly

328
00:24:23,480 --> 00:24:28,840
Let's take a look at the pizza class the pizza abstract class and see what's going on here

329
00:24:29,480 --> 00:24:33,640
In the similar way because we're using the builder pattern. We have another inner

330
00:24:34,440 --> 00:24:36,440
static builder class

331
00:24:36,920 --> 00:24:39,880
But you probably see it's a bit more different

332
00:24:40,440 --> 00:24:45,240
We need to allow something called a simulated self type now

333
00:24:45,320 --> 00:24:47,160
This was the bit that

334
00:24:47,160 --> 00:24:54,280
Took me a bit to grok and make sense of because it involves using generics and it's doing something called a

335
00:24:55,000 --> 00:24:57,000
simulated self type

336
00:24:57,480 --> 00:24:59,480
What what does that mean?

337
00:24:59,480 --> 00:25:03,160
Let me see if I could explain it. I would say I got it, but

338
00:25:04,040 --> 00:25:06,040
I think I'm I'm still struggling

339
00:25:06,200 --> 00:25:08,200
to articulate it clearly

340
00:25:08,200 --> 00:25:10,600
And and let me let me let me give a shot

341
00:25:11,320 --> 00:25:16,600
So I didn't get what a simulated self type was from effective java. I couldn't understand it

342
00:25:17,080 --> 00:25:19,080
and then I found this great

343
00:25:19,320 --> 00:25:21,320
blog post by

344
00:25:21,800 --> 00:25:24,280
This gentleman's name is nicolai palok

345
00:25:25,000 --> 00:25:27,000
Fantastic article. It was written in 2016

346
00:25:27,480 --> 00:25:29,480
Pretty much goes into everything you need to know about

347
00:25:29,880 --> 00:25:35,000
The idea of java not having a a self method or it doesn't allow us

348
00:25:35,800 --> 00:25:39,640
Self and this those two keywords are a bit different. We will I'll I'll get you that too

349
00:25:40,200 --> 00:25:43,320
Um because java doesn't have that we sort of have to simulate it

350
00:25:43,400 --> 00:25:46,120
And that's what just your block is doing in this example

351
00:25:46,520 --> 00:25:49,640
But also what one would generally do uh to get a self type

352
00:25:49,880 --> 00:25:56,040
And it's important to understand. Oh if we didn't do the simulated self type

353
00:25:56,280 --> 00:26:01,400
We may have to use casting and that is not going to work because it's very important to understand

354
00:26:01,880 --> 00:26:04,680
that for the builder pattern to work with the

355
00:26:05,800 --> 00:26:09,320
Method chaining which I have where where's an example?

356
00:26:11,960 --> 00:26:13,640
Nope

357
00:26:13,640 --> 00:26:17,640
Always when you need an x. Oh, yeah. No, that's not the exact that's telescope construct

358
00:26:17,640 --> 00:26:22,760
Yeah, for this method chaining to happen the proper type or the proper subtype

359
00:26:23,320 --> 00:26:26,120
Have has to be passed. Uh, sorry has to be returned

360
00:26:27,000 --> 00:26:31,880
And in the hierarchical, this is a bad example. I should be using the hierarchical builders one

361
00:26:32,280 --> 00:26:37,080
Yes, over here in the class hierarchies the proper subtype has to be returned

362
00:26:37,560 --> 00:26:42,040
For this method chaining to work. So what a simulated self type does

363
00:26:42,840 --> 00:26:44,840
is these subclasses so

364
00:26:45,800 --> 00:26:48,760
In this instance, it's new york pizza and calzone

365
00:26:50,760 --> 00:26:55,400
They can get an instance of their own type instead of the parent and and again

366
00:26:55,640 --> 00:26:58,120
I know i'm sort of beating on a dead horse here

367
00:26:58,120 --> 00:27:01,720
But it's important to understand that for this method method chaining to work

368
00:27:02,040 --> 00:27:04,040
They have to get a instance

369
00:27:04,600 --> 00:27:08,280
Of their own type not the parent not the abstract class pizza

370
00:27:08,760 --> 00:27:14,120
New york pizza has to get a an instance of new york pizza or of of type of

371
00:27:14,760 --> 00:27:18,600
Subtype the new york pizza and before I do a deep dive in the code

372
00:27:18,840 --> 00:27:24,280
I want to read these excerpts from nickolai palogues a blog post the recent being again

373
00:27:24,360 --> 00:27:27,000
I think it's important to first conceptually understand

374
00:27:27,800 --> 00:27:33,960
What a simulated self type is what's the reason for it and its justifications. Let's say so

375
00:27:34,680 --> 00:27:39,160
Nikolai states a self type refers to the type on which a method is called

376
00:27:39,720 --> 00:27:41,720
more formally the receiver

377
00:27:42,200 --> 00:27:44,360
But java doesn't have this feature. So

378
00:27:45,240 --> 00:27:47,480
In here the self type would be

379
00:27:49,560 --> 00:27:53,320
Why can't I what do I keep losing that that that class or that bit of code?

380
00:27:54,440 --> 00:27:56,440
Bloody annoying

381
00:27:56,840 --> 00:27:58,840
Where is it?

382
00:27:59,560 --> 00:28:01,560
There we go, you son of a bitch

383
00:28:01,720 --> 00:28:05,320
Um, so here this in the method chaining

384
00:28:08,440 --> 00:28:11,000
On which method is called more formally called the receiver

385
00:28:12,280 --> 00:28:14,280
a self type so

386
00:28:14,520 --> 00:28:22,360
The receiver should get new york pizza type, but java unfortunately it doesn't have this particular feature of a self type

387
00:28:24,680 --> 00:28:26,680
If a soft type

388
00:28:27,080 --> 00:28:29,080
Is used in an inherited method

389
00:28:29,400 --> 00:28:34,920
It represents a different type in each class that declares or inherits that method

390
00:28:35,480 --> 00:28:37,480
Namely that specific class

391
00:28:38,040 --> 00:28:41,080
No matter whether it declared or inherited the method

392
00:28:41,800 --> 00:28:47,880
casually speaking it is the compile time equivalent of this dot get class or the type of this

393
00:28:49,640 --> 00:28:50,840
I think

394
00:28:50,840 --> 00:28:56,200
Well, I was gonna say I think that's quite straightforward, but it probably will be quite straightforward once we

395
00:28:57,000 --> 00:29:00,200
Look into the code base. Let's start off with the abstract class

396
00:29:00,200 --> 00:29:05,720
It kind of makes sense because the subclasses are going to inherit this. So we have this pizza constructor method here

397
00:29:05,720 --> 00:29:07,720
Oh, I want to state one thing. Um

398
00:29:08,280 --> 00:29:10,600
I will not go into detail on this bit

399
00:29:10,840 --> 00:29:15,480
But because we will be discussing it in a future video in item 50 to be

400
00:29:16,040 --> 00:29:22,840
Uh specific, but the idea is that over here in line number 33. We are making what one would call a defensive copy

401
00:29:23,480 --> 00:29:25,480
this is just to ensure that

402
00:29:25,640 --> 00:29:30,120
The encaps and encapsulation of this class is in broken that that fundamental

403
00:29:30,680 --> 00:29:34,120
OOP principle isn't infringed upon we

404
00:29:34,680 --> 00:29:37,240
Stick to our principles. So as OOP programmers

405
00:29:37,800 --> 00:29:42,200
So what this does is when the native class changes immutable objects feel

406
00:29:43,080 --> 00:29:48,680
A defensive copy should be made anytime it's passed into a constructor like this or out of the class

407
00:29:49,240 --> 00:29:53,880
When the object of this class will be created this topics member is what's going to change

408
00:29:54,040 --> 00:29:55,800
It's going to be mutable

409
00:29:55,800 --> 00:29:59,960
Because in the add toppings method it's it's being changed essentially

410
00:30:00,680 --> 00:30:03,000
And and that's why we create this defensive copy

411
00:30:03,560 --> 00:30:05,720
again, I'm not going to go into detail firstly because

412
00:30:06,600 --> 00:30:11,640
I think this is a bad example to understand it. It even took me a while. I had to go through some blog posts

413
00:30:12,200 --> 00:30:17,560
But also because we will be discussing that in the future and when we do get to item 50

414
00:30:17,720 --> 00:30:22,440
Which probably is going to be next year. I shall leave a link to that video in the description too

415
00:30:22,680 --> 00:30:25,800
In any case, I don't want to go off on our tangent because I want to focus on the

416
00:30:26,520 --> 00:30:29,000
Simulated self type. So pizza dot builder

417
00:30:29,880 --> 00:30:31,880
Is a generic type that would be

418
00:30:32,920 --> 00:30:34,920
Here when we do

419
00:30:34,920 --> 00:30:37,160
construct the builder object

420
00:30:37,880 --> 00:30:44,440
Uh, it's a generic type with a recursive type parameter. That's a confusing bit because well, it's called a

421
00:30:45,000 --> 00:30:51,320
Recursive type parameter because as you can see pizza dot builder is extending the builder with its own

422
00:30:51,720 --> 00:30:53,720
generic type parameter

423
00:30:54,600 --> 00:31:01,160
And and I've even left a comment here saying that this the the generic type parameter here is necessary for the training to work

424
00:31:02,280 --> 00:31:05,320
And same comment I've left here. It allows to

425
00:31:05,880 --> 00:31:07,880
simulate the self type

426
00:31:07,960 --> 00:31:09,720
And just a box says

427
00:31:09,720 --> 00:31:13,720
this alone with the abstract self method that would be this

428
00:31:14,520 --> 00:31:18,360
And this will be overridden by the subclasses

429
00:31:18,920 --> 00:31:25,240
Because it's in fact, this is probably a bit more easy to understand because it's called self sort of makes sense

430
00:31:25,640 --> 00:31:31,960
This is what gives the subclass an instance of their own type instead of the parent instead of pizza. So

431
00:31:32,760 --> 00:31:38,440
Uh, new york pizza would get an instance of their own type instead of the pizza type

432
00:31:39,560 --> 00:31:43,720
However in combination with this bit here the recursive

433
00:31:44,520 --> 00:31:46,520
Uh, sorry the simulated

434
00:31:46,600 --> 00:31:51,880
Man the recursive self parameter. This is really annoying because it's it's it's really how to get your head around it

435
00:31:53,080 --> 00:31:54,760
and this

436
00:31:54,760 --> 00:31:56,760
abstract self method

437
00:31:57,320 --> 00:31:58,920
It allows us

438
00:31:58,920 --> 00:32:03,880
For method training to work and this is the key point without the need for casts

439
00:32:04,200 --> 00:32:10,600
You probably remember I showed an example before which was this. So let's assume this extends some

440
00:32:11,480 --> 00:32:13,480
Superclass called super person

441
00:32:15,400 --> 00:32:17,960
And here when this does return it

442
00:32:18,760 --> 00:32:22,680
It shouldn't it if you don't put the cast it will return

443
00:32:23,240 --> 00:32:30,040
Uh, a type of super person not person and which is why the cast is required here. However in our case

444
00:32:31,000 --> 00:32:36,280
When we're using the bill of pattern because of this abstract self method, we don't have to do that

445
00:32:36,280 --> 00:32:44,280
We don't have to use the casts and I shall show you now in a subclass. So let's use new york pizza where this happens firstly

446
00:32:45,560 --> 00:32:49,320
We we pass the proper subtype of this class to the generic parameter

447
00:32:49,720 --> 00:32:51,160
That's for sure

448
00:32:51,160 --> 00:32:54,920
And then we have this bit here where the overriding takes place

449
00:32:55,400 --> 00:33:01,880
Of the self method where it returns an instance of the subclass of new york pizza and not pizza

450
00:33:02,440 --> 00:33:04,440
And in that way as we do use the

451
00:33:05,160 --> 00:33:10,040
The method training and finally the build method returns the correct subclass

452
00:33:10,680 --> 00:33:16,920
It will not which it's clearly over here. It's saying return new new york pizza of this instance

453
00:33:17,560 --> 00:33:21,960
So this is what allows it all to beautifully come together when we do use it

454
00:33:23,800 --> 00:33:25,800
Over here with the method chain

455
00:33:27,400 --> 00:33:28,600
I don't know

456
00:33:28,600 --> 00:33:33,800
How well of a job I did at explaining that it is a difficult concept to grasp especially the

457
00:33:34,360 --> 00:33:36,360
the recursive type parameter I

458
00:33:36,440 --> 00:33:39,720
I still I'm struggling to understand that really from something honest, but

459
00:33:40,440 --> 00:33:41,720
um

460
00:33:41,720 --> 00:33:44,360
Maybe in the future videos I should consider

461
00:33:45,480 --> 00:33:46,760
Coming up with

462
00:33:46,760 --> 00:33:49,240
Married examples not just this particular example

463
00:33:49,240 --> 00:33:53,880
But trying to even create because this this this some of this code I got from joshu blocks get up repository

464
00:33:54,440 --> 00:33:58,840
Uh, well most of it in fact, so I should probably try and create some examples on my own

465
00:33:59,320 --> 00:34:01,320
Which it'll make it easy for me to

466
00:34:02,120 --> 00:34:03,400
Expand on

467
00:34:03,400 --> 00:34:05,240
in any case, um

468
00:34:05,240 --> 00:34:11,240
JB states this technique. It's sort of funny. Sometimes I refer to him as JB sometimes as joshu block

469
00:34:11,800 --> 00:34:17,480
What am I doing the perpetual contradictions? I'm just going to stick to joshu block. I changed my mind jb

470
00:34:18,440 --> 00:34:21,960
joshu block sounds better. It's it's it's got a beautiful name. What can I say?

471
00:34:22,440 --> 00:34:23,640
um

472
00:34:23,640 --> 00:34:29,720
This technique wherein a subclass method is declared to return a subtype of the return type

473
00:34:30,040 --> 00:34:34,200
declared in the superclass is known as covariant return typing

474
00:34:34,680 --> 00:34:39,640
It allows clients to use their builders without the need for casting covariant return typing

475
00:34:40,680 --> 00:34:42,680
To be honest, isn't that hard to understand?

476
00:34:42,920 --> 00:34:47,800
Um, and what we're really doing here is covariant covariant return typing by getting

477
00:34:48,920 --> 00:34:50,920
uh

478
00:34:51,320 --> 00:34:53,160
A subtype of the return type

479
00:34:53,160 --> 00:34:59,400
So if you go to simply if you go here, I have two classes. I have the class. I created two classes

480
00:34:59,640 --> 00:35:05,160
Oh, also, uh, thanks to this stack overflow user who helped me understand this

481
00:35:05,640 --> 00:35:09,480
The person's name is the person also gets into something called contra variants

482
00:35:09,560 --> 00:35:15,960
But we shall not get into that because it's not that apt to java. Uh, however, it's just an interesting engineering

483
00:35:16,920 --> 00:35:18,920
uh, opsof opsof programming

484
00:35:19,480 --> 00:35:20,840
concept to

485
00:35:20,840 --> 00:35:22,040
understand

486
00:35:22,040 --> 00:35:26,280
This user hard coded thanks to this user on stack overflow. I shall leave a

487
00:35:27,160 --> 00:35:30,840
Link to the answer down below in the comment section. Sorry in the description

488
00:35:32,440 --> 00:35:34,120
so

489
00:35:34,120 --> 00:35:36,120
Here's simply what covariant

490
00:35:37,400 --> 00:35:38,920
um

491
00:35:38,920 --> 00:35:40,920
What was it covariant return

492
00:35:41,000 --> 00:35:42,200
typing is

493
00:35:42,200 --> 00:35:44,760
We have a class called author, uh, and this author

494
00:35:45,480 --> 00:35:51,080
Has this method. So it's got a private member field called name and then of of type object

495
00:35:51,480 --> 00:35:53,720
And then you have another method called get author name

496
00:35:54,680 --> 00:36:01,400
Simple as that and then we have another subclass uh, distevsky my favorite author who extends the

497
00:36:02,040 --> 00:36:04,920
Superclass author, uh, and here we're setting

498
00:36:05,640 --> 00:36:09,800
Another private member variable with the name field order stavsky

499
00:36:10,680 --> 00:36:14,280
And here we are returning a subtype

500
00:36:15,080 --> 00:36:17,080
because string is a

501
00:36:17,640 --> 00:36:22,920
Subtype of object of the object class because think about it. This is this is covariance because

502
00:36:23,480 --> 00:36:28,520
While they just return a subclass of the return type, which is again object and string as I

503
00:36:29,000 --> 00:36:35,320
Describe before it still fulfills the contract of author dot get author name. This contract here

504
00:36:36,040 --> 00:36:38,040
Is

505
00:36:39,000 --> 00:36:41,000
Fulfilled

506
00:36:41,000 --> 00:36:44,600
This is what covariance is and the same concept of course applies

507
00:36:45,320 --> 00:36:47,320
in the hierarchical classes

508
00:36:47,880 --> 00:36:51,720
With the builder pattern because this returns a subtype of

509
00:36:52,280 --> 00:36:55,320
Sorry, new york pizza. Let's say that class returns a subtype

510
00:36:56,120 --> 00:36:58,120
It is a subtype of

511
00:36:58,120 --> 00:37:02,600
Uh pizza and it does fulfill that contract down the the method chaining

512
00:37:03,080 --> 00:37:05,800
If that makes sense and to conclude just your block states

513
00:37:06,280 --> 00:37:09,400
the minor advantage of builders over constructors is that

514
00:37:10,040 --> 00:37:12,040
Builders can have multiple

515
00:37:12,680 --> 00:37:19,320
Parameters because each parameter is specified in its own method make sense. Um, I think new york pizza

516
00:37:19,960 --> 00:37:22,520
Oh pizza test probably isn't the best example

517
00:37:23,240 --> 00:37:25,240
but a good example would be

518
00:37:25,480 --> 00:37:27,480
The nutrition facts class

519
00:37:27,480 --> 00:37:34,920
We can have as many constructors as we want because all these constructors get their own method and he continues alternatively

520
00:37:35,560 --> 00:37:40,760
Builders can aggregate the parameters passed into multiple calls to a method in a single field

521
00:37:41,240 --> 00:37:46,440
As demonstrated in the at toppings method earlier. So this at toppings method as you can see

522
00:37:46,760 --> 00:37:48,760
We're passing multiple parameters

523
00:37:49,000 --> 00:37:54,440
Into the at toppings method or more accurately making multiple calls and this

524
00:37:55,080 --> 00:38:02,120
Builder class is aggregating it continues a single builder can be used repeatedly to build multiple objects, of course. So

525
00:38:03,400 --> 00:38:05,400
Examples here pizza calzone

526
00:38:06,120 --> 00:38:10,520
Different objects being constructed in different ways using the same builder class

527
00:38:11,320 --> 00:38:13,880
The parameters of the builder can be tweaked between

528
00:38:14,280 --> 00:38:17,640
invocations of the build method to vary the objects that are created

529
00:38:17,960 --> 00:38:20,680
These parameters can be changed as we require

530
00:38:21,240 --> 00:38:23,240
depending on how we write

531
00:38:24,200 --> 00:38:29,400
The different methods in the builder class a builder can fill in some fields automatically

532
00:38:29,960 --> 00:38:31,960
upon object creation

533
00:38:32,120 --> 00:38:33,880
such as serial number

534
00:38:33,880 --> 00:38:38,680
That increases each time an object is created. This is a very astute point

535
00:38:39,160 --> 00:38:42,920
I think a good example of that would be similar to the idea of

536
00:38:43,640 --> 00:38:48,520
You know checking what the proper arguments past time doing type checks and different

537
00:38:48,680 --> 00:38:53,960
Validations on a method because these are methods a lot can be done within the builder class

538
00:38:54,280 --> 00:39:00,040
So if I try to go back to the previous example where I was checking for the

539
00:39:00,680 --> 00:39:02,280
proper argument

540
00:39:02,280 --> 00:39:05,560
The way we've done this check in calories. We could even have

541
00:39:06,200 --> 00:39:09,560
Something which automatically adds a certain value or

542
00:39:10,520 --> 00:39:14,600
Changes an object automatically depending on the way it's called

543
00:39:15,320 --> 00:39:20,760
And it could all be done simply because it's a method and of course like all great programming and engineering books

544
00:39:21,320 --> 00:39:27,000
ineffective java just show bloke does discuss the trade-offs. He explicitly states the

545
00:39:27,800 --> 00:39:31,640
Disadvantages of using the builder pattern for this instance

546
00:39:32,120 --> 00:39:36,120
And one of them is something I already discussed. It's certainly a bit hard to understand

547
00:39:36,440 --> 00:39:41,240
One has to get their head around it, especially with the simulated self typing and whatnot

548
00:39:41,880 --> 00:39:43,880
and understanding how the inner

549
00:39:44,760 --> 00:39:47,720
Class works within the bigger class

550
00:39:49,080 --> 00:39:51,960
And and that can be a bit more verbose and certainly

551
00:39:52,760 --> 00:39:54,760
a bit harder to grasp

552
00:39:55,080 --> 00:39:56,440
initially

553
00:39:56,440 --> 00:39:58,440
and then he also says that

554
00:39:58,920 --> 00:40:00,200
if you

555
00:40:00,200 --> 00:40:06,520
Start out with obsolete constructors and static factories and then you know move the code base to a builder pattern

556
00:40:06,600 --> 00:40:08,600
Which I think is what happens most of the time

557
00:40:08,680 --> 00:40:13,560
So this second point, you know, the first point is you know, it's a matter of practice the more you use it

558
00:40:13,640 --> 00:40:15,640
I believe the more one will become

559
00:40:16,200 --> 00:40:17,720
more

560
00:40:17,720 --> 00:40:19,720
Attuned to using the builder pattern

561
00:40:20,360 --> 00:40:22,360
but the second one is

562
00:40:22,360 --> 00:40:25,160
definitely a trade-off worth considering because

563
00:40:25,960 --> 00:40:29,800
Generally what would happen is we would not use a builder pattern in a large code base

564
00:40:29,880 --> 00:40:33,080
And then we would want to use it as the number of parameters increases

565
00:40:34,040 --> 00:40:36,840
And then making that shift can be quite hard

566
00:40:37,080 --> 00:40:43,400
So if it's a green field project and if you're starting from scratch always better to start with the builder pattern

567
00:40:44,360 --> 00:40:45,560
even if

568
00:40:45,560 --> 00:40:49,080
One has you know a small number of parameters for a certain class

569
00:40:50,040 --> 00:40:54,120
That's it. That is the second item of effective java by Joshua block

570
00:40:54,760 --> 00:40:58,600
Uh, I sincerely do hope that you got some kind of value out of this

571
00:40:58,760 --> 00:41:04,360
And I I really am trying to get better at making these videos and really expanding on these points

572
00:41:04,920 --> 00:41:08,200
It is a bit hard because firstly, I don't think

573
00:41:09,400 --> 00:41:10,920
Programming and

574
00:41:10,920 --> 00:41:16,680
Computational thinking naturally comes to me. I need to really struggle with the problem a lot for it to make sense

575
00:41:17,080 --> 00:41:22,600
And I think that's most people really so this isn't like false modesty or whatever. I think it's it's normal for most people

576
00:41:23,160 --> 00:41:28,680
Uh, and I did realize for instance the part where I was going through the simulated self type

577
00:41:29,240 --> 00:41:31,240
That was a bit harder to understand

578
00:41:31,560 --> 00:41:35,560
But on that note, I want to thank you for watching this video

579
00:41:35,800 --> 00:41:38,440
Our next item is going to be and I have already started

580
00:41:39,160 --> 00:41:41,080
writing the script for it and

581
00:41:41,080 --> 00:41:41,960
You know

582
00:41:41,960 --> 00:41:43,960
putting putting the code base together

583
00:41:44,360 --> 00:41:49,640
The item three is enforced a singleton property with a private constructor or an enum type

584
00:41:49,960 --> 00:41:54,440
This item is a bit easier to understand than the previous two. I can assure you that

585
00:41:55,320 --> 00:42:01,000
In any case, thank you for watching. Uh, I do appreciate it. Uh, I appreciate you allowing me to ramble

586
00:42:01,240 --> 00:42:02,760
and go on

587
00:42:02,760 --> 00:42:04,760
It's good. Cheers. See you in the next one

