start	end	text
0	7200	Hey everyone, welcome to yet another episode of my video series on Joshua Block's effective Java
7560	9560	where I cover and
9560	15200	Expound on the items that he has emulated in this book and of course
15840	20160	what I've been trying to do in the previous videos or episodes is to
21120	26480	Flesh out and try and make sense of what he's talking about in the different items in this book and
27160	30300	Hopefully as I try to make sense of them the purpose of me
30720	37320	Sharing this publicly and uploading these videos is that you too can gain some value from it. That's one
37320	39320	I would say that's a primary purpose
39760	46400	But the other is of course that there's that sublime effect where by me trying to teach someone a
46960	48960	concept that I really
49360	52320	Fundamentally don't still properly grok or understand
53240	59800	Paradoxically, I understand it better. So yep, it's it is sublime indeed and it works well
60680	64440	Say all that without further ado, let's get started. So as per usual
64440	67380	I'm gonna repeat the introduction that I've sort of
68080	73200	Repeated in all the other episodes. I just feel like I need to do that kind of due diligence as a sort of ethical duty
73200	74480	Let's say
74480	79320	So if you do want to skip it, of course, please go ahead because I'm just repeating the same old points
79320	81120	I don't want to waste your time
81160	86000	This is not a tutorial. That is the first caveat in this proviso. This is not a tutorial
86000	89000	I am not a teacher and I certainly am non-expert
89560	94320	in fact a point that I've been repeating ad nauseam is that the more I've
95000	97320	Understood Java and the concepts
97880	101680	He's outlining this book Java and OP in general
102400	108080	I'm realizing how much of an expert I'm not so that's really interesting and very humbling indeed
108080	111480	And I don't mean that in a false modest sense. I mean, that's sincerely
112120	115320	An analogy or yeah, probably an algae
115320	122240	I'd like to use to explain what I'm trying to do here is the blind living the blind. I am as naive or perhaps even more
122880	124720	blind and
124720	126720	ignorant and naive and oblivious all of those
127320	129320	things
130040	136600	As as much as you are and yeah, even probably even more. So this is not my tutorial
136600	138600	I'm not trying to teach you anything
138840	142920	So whatever I say, please do take it with a grain of salt. This is a
144080	144880	Exploratory
144880	149320	Disquisition another analogy. I've been using as what one would see in a
150280	153400	University tutorial where we've got a tutor
154720	158280	bunch of students trying to make sense of and understand a
159040	164280	problem statement or some some programming principle, which is why unequivocally I will
164800	168760	Inevitably make mistakes. So please point them out not just for my sake
168760	174360	But even for anyone that's watching these videos if I do make a very fundamental
175200	177200	Crucial mistake
177200	180240	I'll try my best to be rectified by leaving a comment myself
180240	185400	But if you do pick it up, I shall pin those comments just so that I don't mislead anyone
186920	188920	With any
190160	192400	Fake news to use a politically
193400	200640	Overloaded term and of course as this is a programming video series all the code that I've been using for this effective Java series
200640	205160	It's available on my GitHub. I've got a separate repository for each item and
206280	209640	As I go through these all the code will be published here
209920	214280	Anyway, now that we got the proviso out of the way, let's get started with item number six
214840	216840	where Joshua block states
217440	219440	Avoid creating
219440	222640	unnecessary objects and this is quite an interesting one because
223600	226840	I certainly am guilty of doing this of making these mistakes
227600	231120	So it's it's valuable and worth our time. I think that's
231880	235640	Java or generally OOP programmers to
236240	241960	Understand why, you know, just sort of creating objects at a hawk without putting any thought into it
242120	245160	There's a bad idea and perhaps even an anti-pattern
245760	249880	Of course, this we are still in chapter 2 in creating and destroying objects
250280	256200	So before we get to any of the content in the book, I kind of want to get some fundamentals real
256920	258920	OOP basics out of the way
259440	261760	Look, if you don't know what objects are this
262640	268240	Video series really probably is a bit above your level. I'd say go and watch some basic
269040	273720	OOP fundamental videos on YouTube just watch like a basic tutorial, but
274200	282080	The definition we all hear of an object is that it is an instance of a class and the class is what acts as a blueprint
282440	284440	as to how it defines
285360	289000	How an object behaves when it is instantiated
289600	295000	but something a bit more formal is the definition by the oracle docs and
295760	297760	He goes like this
298000	303920	Software objects are conceptually similar to real-world objects. That is true something. I truly
304360	309720	Admire and appreciate about object oriented programming. I think it's brilliant that they've created that connection
310080	312920	In fact, sorry to go off on a tangent here
313600	315600	if you do start
316480	321920	Following some of the design patents a bit more seriously so for instance the 23 patents
322680	326160	popularized by the Gang of Four you'd see a lot of those patents to
326880	332040	Have many deep connections to engineering patents in the world
332800	340360	That's let's say not the conventional. Sorry the the the the conventional world which doesn't invoke which doesn't
341160	346520	Attain to software engineering, but sort of the let's say civil engineering or some other kinds of engineering
347280	350640	Anyway, sorry. Sorry. I'm going off on a tangent back to the definition
350800	357600	Software objects are conceptually similar to real-world objects. They too consist of state and related behavior and
358440	361440	Objects totes so it's state in fields
361600	370240	Which are variables in some languages and exposes its behavior through methods of course and we shall see a few examples of that in this item
370960	372960	Which are called functions in some languages
373800	379120	methods operate on an object's internal state and serves as the primary mechanism
379880	381880	for object-to-object communication
382840	390720	Hiding internal state and requiring all interaction to be performed through an object's methods is known as data
391360	395600	Encapsulation a fundamental principle of OOP or object going to programming
395600	401520	So once again, if you don't know what encapsulation is what inheritance is those really fundamental ideas in OOP
401520	404240	I think this video is a bit above your level
405000	408840	Yeah, so that's probably should be caveat for this item in particular
409560	416280	Okay, so now let's try to understand from a JVM and memory management perspective
416280	420200	Well more from a JVM perspective. We're not gonna go too deeply into memory management
420880	424120	how these objects exist at least
425400	433760	Apropos the Java virtual machine now again, you would know what the JVMS JVM is what allows to execute Java code on
434160	437160	Any any machine, which is what makes Java
437960	442560	Quite popular because it can work on any operating system for instance
443360	444600	so
444600	449680	We have the call stack of course. Here's where we make calls or we give instructions
450160	453520	To call different objects and whatnot our different methods. Sorry
454680	462160	And the JVM primarily divides the memory into two two spaces or two domains now, of course
462160	464480	Oops, I had the microphone now, of course
465480	472440	It's okay. So firstly, it's the stack memory and the heap space now, of course these two high-level
475040	482200	Demarcations also further divided into let's say sub-domains so the heap space for instance would have the dynamic meta space
483000	485720	Which holds static content and we'll get to that too
487520	492000	So the stack memory is used for static memory allocation, that's correct
492000	497640	What static memory allocation sort of means for all intents and purposes is that an object created?
498040	503120	Statically, let's say once it's in memory. It will remain in that state
503640	508960	Throughout the application lifecycle, whereas dynamic objects change state
508960	512560	They can change and they don't live in the stack memory
513440	514640	so
514640	516640	Also the the stack memory
517040	520960	Again pretending to the JVM and Java holds primitive values
520960	523920	So values like int or char
524600	526680	These types live in the static memory
527480	530320	and of course as I said before it
530840	533200	Well, I don't think I did say that before anyway
533640	539800	There are references to dynamic objects that live in the heap space now look all these definitions are fine
540040	543600	For starters, but the best way to make sense of it is of course to an example
544160	548200	So if we take person here this in the person method
548800	549920	this
549960	556360	Int value that you're passing that would live because it's a primitive type and it's a primitive
557320	560680	Variable that would live in the stack memory
561800	566040	Also, I apologize if I did say static memory before I should have said stack memory
566640	571880	And then string which is a class and it's you know a class you can create an instance of that class
572560	577080	What would live in the stack memory in that case wouldn't be the object itself
577080	584520	but rather a memory address or a reference to the actual object which lives in the heap space in the string pool in this instance
584680	589320	So and that's dynamic its state can change unlike some of the
590080	591640	static types
591640	593000	so
593000	598920	Yeah, as I've written down here. There's a few notes. I took just to make sure that I stay on track. It's
600240	605600	It's used for dynamic memory allocation of Java objects and GRE classes at one time
605600	608160	So that means when applications running its state can change
609440	617480	Also new objects which sometimes seem to be short-lived live live in the heap space. I shouldn't just say it outright
618040	620040	Tends to be short-lived. There are
620600	623800	some long-lived objects and here's where you know
624520	630400	The different algorithms in garbage collection so that that's garbage collection is essentially essentially
630880	638440	Memory management here. Here's where different algorithms play a role and allocate objects into you know, like for example the permanent space
638440	642320	I think it used to be called like the nursery different parts of the
643120	649200	The heap space. I'm not gonna go into that. This is this this video is gonna be way too long if you're getting to memory management and Java
649720	651720	but the point is
651720	653720	these objects are dynamic and
654680	657960	They the references for them are stored again in stack memory
658960	660480	And
660480	665560	On that note, of course now that we understood sort of how objects exist at a very very high level
666000	668000	Pertaining against Java and JVM
668200	674520	Let's get to the item and the item essentially is telling us how to reuse objects and why in fact it's better
674960	680280	To reuse objects than creating new ones and how doing so will make the code
680960	687920	Cleaner more stylish more professional if you could use that term and even as we shall see with some examples
688320	691560	Make the code run faster and that definitely is a benefit
691560	695920	So the book starts off with a rather ridiculous example as what not to do
695920	702080	So as Joshua Block has pointed out he has left the comments in an extreme example of what not to do
702080	705480	I've never seen this done by any programmer to be honest, but
706160	713760	This certainly isn't something one has to do where when we already have this string. We create another instance by using a new keyword
714520	717120	This is sort of how most of us do it
717120	719120	So the proper way
719960	723680	The improved version he calls it, but let's just say it's a proper way and
724800	726800	Here's what Joshua Block states
727000	735280	The statement creates a new string instance each time it is executed and none of those objects object creations is necessary because
735480	738000	So bikini can live here and
739080	744160	Then it could just point to that all the all the references one one object can exist in the
744720	753440	Heapspace, but if you have this new keyword every single time it's invoked a new object is created and that is a completely inefficient
754080	755680	and
755680	757680	ridiculous waste of space and time
759120	767040	The argument to sorry I'll show it scroll down the argument to the string constructor bikini is itself a string instance that is correct
768040	776800	Functionally identical to all of the objects created by the constructor if this usage occurs in a loop or in a frequent frequently invoked
777400	778600	method
778600	781760	Millions of string instances can be created needlessly
782160	786400	So here's an example of what he definitely shouldn't do and just like the Bible
786400	791920	We're gonna go from the Old Testament where what the goat says what he shouldn't do and in our case the Java code
792080	799920	Joshua Block tells us don't don't do this. That shall not do this to the New Testament what you should do and what you should consider
800680	803880	on when when writing code as to how
804360	807720	These techniques can allow us to reuse objects
808480	811880	It's interesting how I just converted this into a theology session
814320	819280	So the first way one could easily reuse objects is something we already covered in
819360	823960	In at item one is in fact using static factory methods
823960	827160	I should say as Joshua Block stays here. In fact, I'll just read it out
827160	833160	You can often avoid creating unnecessary objects by using static factory methods in
833840	837520	preference to constructors when immutable classes that provide both
838040	845760	So the example here would be the Boolean class where value of is a static method and that is indeed preferred over
846400	847480	using
847520	852960	The constructor and I think since Java 9. Yes, it does say here
853440	858520	This has been deprecated. We can't even use this constructor because it's been made private. So
859160	865200	The the static factory method doesn't require a creation of objects every time it's invoked
866240	871680	Because static members are common to all instance instances of a class and again the way I think about it
871680	876600	Oh, I guess this is exactly the way one should think about it is it belongs to the class
877440	882400	Therefore, all the instances of that class will will share this
883360	884680	Static member
884680	891680	So that member itself can be shared up amongst all objects whenever that class is instantiated and
892800	894800	As I did mention a bit before
894840	901640	Static variables live in something called the dynamic meta space within heap memory and also an ancillary point
901640	905640	He also adds in addition to reusing immutable objects
905640	910200	You can also reuse immutable objects if you know they won't be modified. So
910800	913760	For reusing objects, they don't have to all be declared
914480	915960	final and
915960	921640	Static and make for them to be mutable rather even if we know a certain object is
922920	927880	Mutable, but still it won't change. We could reuse that using static factory methods
928640	934860	So there could be some operations where it's much more computationally expensive to keep
936080	940680	Invoking a certain function and here's the example Joshua block has used
940680	944920	So before I do get to the example, probably I'll just go through his justification
945160	950400	He says some object creations are much more expensive than others. That's right
950400	954600	If you're going to need such an expensive object repeatedly
954640	958120	It may be advisable to cache it for reuse
959120	963760	Unfortunately, it's not always obvious when you're creating such an object. That is true
963760	969840	However, here we have a solid example where this could be computationally expensive and that is
970600	972600	using regular expressions
972760	975440	So this is a very very simple class
976000	980280	Well, what it does. Well, the class has these static methods
980960	982960	we have well
983960	988680	Practically it should only have one method called is numeral, but just for
989240	991960	Demonstrative purposes we have is numeral slow and
992560	996920	It's numeral fast and we shall see why we have those two methods in a bit
998120	1003480	So firstly the slow method what it does. Okay, so let me let me take a step back
1005160	1009080	What this method does is it returns a true or false and
1009160	1014440	And what that true or false tells us is if a string we pass on to this
1015080	1017080	fulfills a certain regular expression
1017880	1024040	And what that regular expression is looking for really is if the string we pass on to is a Roman Roman numeral
1025080	1026440	and
1026440	1035000	Here here though, this is the slow way what happens here is every single time we invoke this method and we pass the string
1035680	1038600	The the the string class invokes the matches
1040080	1044360	Method which uses a finite state machine
1045240	1050160	Which we shall we shall get into what that is a finite state machine to do the matching
1050720	1057440	And and that is computationally expensive. So every single time a pattern instance has to be created here
1058080	1064320	A pattern instance really that won't change but for we know that why would we not reuse it
1064320	1066320	But every single time the method is invoked
1066640	1071840	We're creating this finite state machine instance and then after it's done
1071840	1077720	It has to be garbage collected and the JVM has to take care of it. So that is computationally expensive. So this is a slow way
1078480	1083920	But what he does propose instead is to cash it. So we have the regular expression instance
1084000	1085560	We call that
1085560	1092760	Roman here and we use this compile method in the pattern class and we explicitly compile it into an immutable pattern instance
1092760	1098520	Which we still here and we call it Roman as I said and then we just reuse that in the esnemeral fast method
1098840	1100760	Simple as that and to put it most succinctly
1100760	1106560	He states while string dot matches is the easiest way to check if a string matches a regular expression
1106600	1108800	Which is what we've sort of done here
1110480	1114920	It's not suitable for repeated use in performance critical situations
1115200	1119000	He continues creating a pattern instance is expensive
1119320	1120960	Because it requires
1120960	1124760	Compiling the regular expression as I said into a finite state machine
1124760	1130280	So let's get a quick understanding of what a finite state machine encompasses because it pertains to the topic
1130520	1134280	This is definition. I found from brilliant org by
1134840	1137480	Kale more and Deshan Gupta is a
1138040	1142720	system where particular inputs cause particular changes in state can be
1143160	1147480	represented using a finite state machine or using finite state machines and
1147960	1154520	This is a really good example. I found it was a 10 minute video by Valhalla data systems and the book here
1154520	1160880	He not only explains quite simply with brevity what a finite state machine is
1160920	1164960	But also afterwards shows a solid implementation in Java code
1165040	1169120	So I'll leave a link to that video down in the description. It's well worth a watch
1169120	1171560	But this is one snapshot of the video
1172160	1178000	And here's what happens. So when we pass a string, which is really a an array of characters in Java
1178600	1183280	It'll take each character and start going through the FSM
1183280	1186680	I'm just gonna call it FSM because it's finite state machine is a mouthful
1187800	1194240	So it's gonna start off with with state zero and if it's an at sign it'll go to one
1194240	1196240	Oh, by the way, this
1196680	1200600	pattern it's looking for is simply for an at sign or a hashtag. So this has nothing to do with
1201120	1203640	the reg X given here because this is for
1204320	1208360	Checking if it's a Roman numeral, but this is a different example. Just so you don't get confused
1208960	1213560	So all it's looking for is if the string contains an at sign or a hashtag
1214000	1219440	So it starts as I said with state zero if it contains an at sign goes to state one
1220040	1225880	If it's a number between or an integer to use proper terminology between zero and nine
1225880	1229320	It'll go to state two if it's a hashtag. It'll go to state three
1229920	1235960	And it sort of loops it will remain in that state because so if it's an at sign it'll go back to state one
1236240	1237400	so
1237400	1239400	For all the intents and purposes
1239720	1246480	This state represents at signs this state represents the hashtags and this represents integers
1247120	1251440	That's really what a FSM is but for our problem
1251440	1255280	We don't want this computation happening every single time this method is involved
1255280	1262040	Which is why we create one instance and we store that object with its state in a constant
1262160	1264160	This is our constant I declared in Java
1265120	1272200	So let's look at the time differences. Now firstly, I'll invoke the slow method if I run this program
1274160	1279060	You'll see that's how long it takes. Let me zoom in a bit there. So this is
1279560	1282440	Millions seconds, isn't it? This is it's always in nanoseconds
1283440	1286720	Man, I'm not even sure. I think this is a nanoseconds. I
1287280	1289280	Looked it up, but in fact both my
1289800	1296920	Options were wrong. It's actually microseconds. There you go. That's my ignorance. So it takes around 115 microseconds
1297520	1301960	For this function to run and now if we do change it to fast
1303760	1310560	Now keep in mind what the fastest what this method does is that it doesn't invoke the matches method in
1311560	1313680	Well, sorry, it doesn't work the matches method
1313680	1318840	But it isn't compile a new pattern every single time because we just use the cached Roman
1319840	1323340	Instance here. So if we run that it'll be much faster
1324120	1325760	There you go
1325760	1327360	half the time
1327360	1330760	60 milliseconds 12 milliseconds for the next computation and
1331320	1338560	Joshua block states in his machine. It was for a eight character input string. It was six six point five times faster
1338920	1347280	Which is why he says the improved version is of is numeral provides significant performance gains if invoked frequently
1347640	1351560	Then it continues and that's a really good point. He sort of touched on this in
1352600	1355800	the in item number one where you could in fact give
1357160	1361760	Static methods or even static values a name. It's more clearer
1361840	1366400	It's more. It's it's quite clear that this pattern is a Roman pattern Roman numeral pattern
1366880	1375120	So not only is the performance improved but arguably so is clarity the clarity because we know what the pattern we're using here
1376600	1380680	Making a static final field for the otherwise invisible pattern instance
1380680	1384040	A love allows us to give it a name. It's more explicit and clear
1384160	1387520	Which is far more readable than the regular expression itself
1387520	1395000	and then he makes a bit of an ancillary point just to clarify about lazy loading because now as I said when we
1395960	1402080	Do it this way when we declare it in a private static final field and cash that object
1402320	1406560	This belongs to this class. So it can be reused all the
1407200	1413040	Objects of this class all the instances of this class will reuse this but what if we never use this object?
1413080	1415080	It's just gonna be created
1415080	1421800	For no reason at all and it's gonna exist in the heap space. Sorry. Yeah in the dynamic meta space in the heap and
1422600	1427640	Here, you know, he says, oh, look, we could probably lazy load. However, perhaps it's not required
1427640	1430400	We don't have to over complicate things for
1431320	1436240	Optimization as don't canoe and I think it was apocryphally attributed to him
1437280	1439800	premature optimization is the root of all evil and
1440600	1445200	He continues not only is the performance improved. Oh, sorry. I already read that part
1445440	1452080	If the class containing the improved version of the is numeral method is initialized, but the method is never invoked
1452360	1457480	So what if this is numeral fast method is never used and this just exists there?
1458760	1461600	The field Roman will be initialized needlessly
1461720	1465120	It would be possible to eliminate the initial initialization
1466000	1472360	By lazily initializing the field the first time the is numeral method is invoked
1472360	1477480	But this is not recommended as it's often the case with lazy initial initialization
1477680	1483640	What can I read the word those two words together lazy initialization? It would
1484880	1490540	Complicate the implementation with no measurable performance improvement. So it's not required. It's fine
1491040	1494640	To create an object even though it may potentially not be used
1495880	1497880	especially with how fast
1498320	1501520	Jvms of these the JVM and processes out these days
1501520	1505560	And with that we move to a bit of an interesting problem here
1505880	1513160	What about less obvious situations for object reusability? I'd say this one seemed quite straightforward
1513560	1516200	Well, I don't know if it was at least for me
1516200	1521600	But when I saw the code trust your block has written it came together. I was like, oh that makes complete sense
1522000	1523160	but I
1523160	1530960	from being honest, I probably would have done it this way and made the mistake of invoking this pattern instance every single time so
1531640	1537120	It's probably not so obvious for inexperienced programmers like myself, but nevertheless
1537880	1540520	Keeping aside aside the self-flagellation
1541560	1547600	What about when it's less obvious? So he says when an object is immutable like the Roman object here
1548120	1551160	It is obvious that it can be reused safely
1551840	1556600	But there are other situations where it is far less obvious even kind of intuitive
1557080	1560960	Now the example that Joshua block is used for that is adapters
1561720	1564240	adapters simply are an object
1564720	1570720	which backs other objects by allowing two incompatible objects to
1571120	1572360	communicate together
1572360	1575880	it's used a lot in the adapter pattern and even though
1576640	1578920	Joshua block doesn't talk about the adapter pattern here
1578920	1583240	It's I think it's worth going through a few definitions definitions as to what the adapter pattern does
1583440	1585200	But of course, I'll leave
1585200	1589200	Some good articles down there in the description. There's a good one by Vile Dung
1589600	1596040	Where he goes through a few examples as to how the adapter pattern is used and how adapters these objects are used
1597040	1599920	So the first definition is by refactoring guru
1600760	1606240	Adapter is a structural design pattern which allows incompatible objects to collaborate
1606760	1609960	The adapter acts as a wrapper between two objects
1609960	1616520	It catches calls for one object and transforms them to format an interface recognizable
1617280	1620640	Recognizable by the second object on the adapter pattern. I would recommend
1623640	1626120	If you want to get a good understanding of the adapter pattern
1627160	1628520	This book
1628520	1634040	Headfirst design patterns goes quite deeply into the adapter pattern with some really good examples
1634040	1637480	So I'll leave a link to this book down below in the description too
1637480	1641000	And I'm hoping to cover some parts of this book at least after I'm done with this
1641000	1642440	It's probably gonna be next year
1642440	1649280	So the next definition that I found for the adapter pattern is an adapter pattern acts as a connector between two
1650120	1660160	Incompatible interfaces that otherwise cannot be connected directly could be due to type mismatch whatnot an adapter wraps an existing class with a new interface
1660720	1664280	So that it becomes compatible with the clients interface
1664560	1669880	The main motive behind using this pattern is to convert an existing interface
1670600	1673040	Into another interface that the client expects
1673880	1679800	It's usually implemented once the application is assigned so one example as to how an adapter is used and
1680280	1685920	Even though I read some definitions of the adapter pattern. I wouldn't say that the adapter pattern has been used here
1686880	1694680	Exactly or precisely, but it's worth looking to how the adapter pattern is used and that is in the map interface
1695400	1697400	so we so of course the map interface
1697880	1699880	contains a method called a
1700320	1702320	key key set and
1702760	1707200	Our hash map, which is a concrete class will implement it which you see here
1708120	1709560	now what I
1709560	1712760	Did do so as a client what I would do is I would create a hash map
1712760	1719200	I would add key value pairs and what the key set does is it returns a bunch of objects all the keys
1719200	1724240	Which are functionally identical so we can cache that value the key set value
1724240	1730360	We get can be cached and that's exactly what we see here in the implementation of key set
1730520	1735520	so this method which is what returns the key set first checks if
1735880	1740640	the key set is present if this key set value is now which
1742760	1745640	Wasn't going there. Oh, that's interesting. I
1748520	1750520	Was clicking the the wrong
1751520	1757640	Variable look sorry, it's been a long day if this key set variable which is in the abstract map if this isn't available
1757640	1761760	So if isn't cached then a new instance will be sent if not
1761760	1765280	There's a requirement that same instance same object can be reused
1765480	1769600	So here's what where we see that an object is being reused a good
1770400	1772400	implementation in the JDK
1772760	1775960	So again to print more formally as to how this example makes sense
1776680	1783800	Theoretically although the return set instance is typically mutable. So that's the set that's returned here
1785880	1788680	All of the return objects are functionally identical
1789560	1793480	When one of the return objects changes so do all the others
1794080	1797080	Because they're all backed by the same map instance
1797720	1802440	While it is largely harmless to create multiple instances of the key set view object
1802840	1806360	It is unnecessary and has no benefits. So the similar point is
1807080	1813080	Biggest what this method returns is a set view. So of type set of the key set
1813880	1817640	While this key set the the values in the key set can change
1818200	1819560	It's
1819560	1826040	Functionally still the same so the adapter the the outer layer which it returns is still the same and that's a set
1826520	1829320	So that's why it could be cached another example of
1829640	1834040	Reusing objects where it's less obvious is of course auto boxing now
1834440	1840280	What that does is of course it allows programmers to mix primitive and non primitive type
1840280	1846280	So primitive would be int a non primitive type or a a box type would be
1847160	1853240	Integer while yes auto boxing does give the object more flexibility and give it more functionality
1854120	1858360	It's not always a good idea to auto box because what auto box does is create
1859160	1861400	A new object every time it's involved
1863560	1868280	So the example we've used or the example that joshua block has given is
1869320	1873320	In this sum class where in fact, I changed it to the proper way
1873560	1878360	So this is the bad bit to do it where we have used an auto box type long
1878840	1883960	And in fact the idea look at that it's even warning us to not to use this but rather to use a primitive type
1884520	1888440	Now with this if we do run this loop where it's running
1889240	1891240	2 to the power 31 times
1892680	1898200	An unnecessary number of objects of long instances are created in this loop. So if we do run it
1903400	1905000	It takes so long
1905000	1908840	Look at how long it takes it takes almost 3000 milliseconds and it keeps going
1910040	1911880	I'll just zoom into that
1911880	1917000	But simply by just not using an auto box type and rather using a primitive type
1917480	1921000	We save a lot of time because there's no object creation involved here
1921720	1923640	If you run it again
1923640	1925640	It's much slower
1925640	1930520	That's the advantage of using primitive types over auto box types and
1931480	1936200	Again, one has to be careful and the good thing is the the way you saw intelligent is beautiful
1936200	1941880	You got to love it the ide will normally warn you but you know in good programming etiquette
1942200	1947000	One should be aware of that and that's why he states the lesson is clear prefer primitives
1947080	1950120	So this here is the proper way to do it using a primitive type
1951080	1957720	To box primitives and that is a wrong way using a box primitive which the ide warns us against
1959240	1961240	Oops, uh, come on said
1962200	1968360	And watch out for unintentional auto boxing and then finally towards the end of the item
1968600	1975160	He does give some caveats and something I always appreciate about this book every single item has pros and cons
1975480	1981640	Uh, it it's a well written book because it looks into both sides of the equation. Let's say
1982200	1984200	And discusses the trade-offs
1984440	1989400	So the the first caveat is that it's not the case that object creation should be
1990360	1996120	Avoided at all costs, especially with how fast the processors are and how optimized the jvms
1996840	1999080	It's not that we should try our best to
1999800	2003960	Not create objects again do the whole premature optimization thing
2005080	2008680	That's why he states this item should not be misconstrued
2009160	2017000	To imply that object creation is expensive and should be avoided on the contrary the creation and reclamation of small objects
2017080	2023960	Whose constructors do little explicit work is cheap, especially on modern jvm implementations
2024760	2027560	Creating additional objects to enhance the clarity
2028040	2031320	Simplicity or power of a program is generally a good thing
2031800	2035080	And then we go to a classic example the classic example of an object
2035960	2040680	That does justify an object pool is a database connection, which is why
2041400	2042600	conversely
2042600	2050760	Maintaining object pool in this case would be a better idea unless the object is significantly heavy weight a like a database connection
2051320	2055640	So it depends on what the object we create is as to whether
2056280	2061720	It makes sense to optimize it and to reuse it or just simply create an object if it's lightweight for instance
2062440	2065640	The cost of establishing the connection is sufficiently high
2066200	2068600	That it makes sense to reuse these objects
2068680	2073800	This is something we see a lot with frameworks for instance a spring with the dependency injection
2074360	2076760	Something like a database connection could be injected
2077560	2082600	Into different components in the object pool or the object graph in this case
2083800	2085800	Generally speaking, however
2085880	2089240	Maintaining your own object pools clutters your code
2089800	2094040	increases memory footprint and harms performance. So what he means by
2094600	2099000	Maintaining your own object pools really is what we saw here
2099640	2101160	in the
2101160	2103080	numeral roman numeral example
2103080	2109080	This is kind of like what an object pool is we we define all these objects in our class and let's say we have 20 of these
2109400	2111880	That can cloud your code and make things a bit complicated and
2112520	2115320	Make the code unreadable or more difficult to read
2117560	2119560	So since
2119800	2128760	Modern jvm implementations have highly optimized garbage collectors that easily outperform such object pools on lightweight objects
2129240	2131880	It's not necessarily the case that one should always
2132760	2135960	avoid object creation and then we get to an interesting
2136840	2138360	sort of
2138360	2142520	Conclusive point in this item and that's the concept idea of defensive copying
2144680	2146680	What defensive copying
2147000	2151720	The simplest way to think of defensive defensive copying is that it's used to maintain
2152360	2158600	Immutability of an object and before we take a look at the example which I have here for defensive copying. It's when you get it
2158680	2168440	It's a rather simple concept, but it's used a lot across frameworks. For instance, um, sorry defensive copying. I'm not sure I confused
2169720	2171720	Reflections with defensive copying
2171960	2176120	But regardless it's a known concept in java programming
2177000	2179000	So what defensive copying is is
2179880	2182280	Where to maintain immutability
2182920	2189640	Instead of passing back a reference to the object at hand a reference to a new object is passed with the same values
2189960	2194440	Making it a copy for all intense for all intents and purposes. What that means is
2195000	2199080	Uh, you know what without me trying to theorize more. Let's look at the example here
2199720	2202200	So we have a class called full calendar here, which
2203000	2206520	Despite ostensibly looking immutable is in fact mutable
2207160	2215960	And this example is courtesy of courtesy of abc study guide. The link to this blog post article is down below in the description
2216440	2222120	So as a client when we use full calendar, what we're doing is we are passing this original date
2222840	2229400	Uh object of date type into the constructor and the constructor assigns that to this private final
2230120	2233000	Uh date object, which we think is immutable
2233880	2239320	But what happens is because we are passing this when the class is instantiated. So in line number 30
2240680	2245240	If for instance, let's say this original date value changes
2246360	2252600	The value of standard date also changes because they are both pointing to the same location in memory
2253000	2256280	Therefore, even though we've declared this as private final
2257080	2263400	And we think it's immutable. It's in fact not and here's where we can easily create a defensive copy
2263960	2265960	So the right way to do this would be in fact
2267400	2272200	When the class is invoked uh, or when when the class is instantiated and the construct is invoked
2272760	2277400	We create a new date object. We we get we get the value of it
2277400	2281320	So we create a copy of that with the the the date we pass here
2282040	2287480	And then using that value we create in fact a new object and then pass said that in standard date
2288040	2294360	That defensive copy ensures immutability of this class and the same thing when we are returning it when you're returning it
2294600	2296600	We want to return a new instance
2296920	2298920	and not
2299160	2302280	The uh, the one that was here because that too could change
2302920	2309240	And that's why we are we are passing. Um, we're not passing in this case. We're using the new keyword and creating a new
2309800	2316040	Uh date instance. So yeah, that's sort of my still I'd say high level superficial understanding of defensive copying
2316200	2320440	But whenever I do think of it, I always connect it to maintaining
2321080	2323080	uh immutability
2323080	2327480	But of course, I'll leave the code this code and also the the article that I got this code from
2328280	2330680	In the description so that you could look a bit more deeply
2332280	2336760	And to conclude here's what Joshua Bloch says about defensive copying
2337000	2344360	The counterpoint to this item is item 50, which is on defensive copying. So this item is is about avoid
2345000	2352600	Creating unnecessary object and here you would think we're creating an unnecessary object where every single time a new object is created
2353960	2355960	So that's why he says it's a counterpoint
2357320	2362520	The person item says don't create a new object when you should reuse an existing one
2363320	2369000	While item 50 says don't reuse an existing object when you should create a new one
2369560	2370280	like
2370280	2377480	In the example of defensive copying note that the penalty for reusing an object when defensive copying is called for is far greater
2378120	2381640	Than the penalty for needlessly creating a duplicate object
2383080	2390600	Failing to make defensive copies where required can lead to insidious bugs and security holds creating objects
2390680	2392040	unnecessarily
2392040	2397240	Merely affects style and performance and of course we need to always at least in my opinion prioritize
2397800	2400760	security over efficiency and performance, which is why
2401240	2404840	It's a good sort of way to end this item with the caveat that
2405400	2409640	This certainly doesn't mean that we should avoid creating objects at all costs
2409880	2414200	There are costs a cost could be security and that could be detrimental
2415320	2418520	And that's it. That is item number six on
2419480	2424200	The avoiding of creating unnecessary objects. I hope you found that insightful
2424920	2426920	Please do tell me how I can improve
2427000	2429560	In the way I communicate and articulate these concepts
2429880	2432280	But also as to how I demo and show the code
2433000	2437560	I would like to maybe even a bit more be a bit more slow and leave more comments
2437720	2439720	But perhaps the best thing to do is
2440360	2444600	Go on to take a look at the code yourself. This video. Think of it as only a prelude
2444680	2450520	I think that thanks a lot for watching. I really appreciate it. I'll receive the few comments here and there
2451560	2455000	On on these videos and it means a lot to me. It means a lot to me
2455960	2462280	And it's always nice to see that there are people actual human beings watching these videos and it's just not me
2464440	2466440	Rambling like a raconteur
2467400	2472440	Okay, enough rambling on the on in okay enough rambling on rambling ridiculous
2472440	2474920	Thanks for watching. Cheers. See you in the next one
