start	end	text
0	7800	Hey everyone, welcome to part 4, the final part of item 10 in Joshua Block's Effective
7800	8800	Java.
8800	15280	Item 10, as if you've been folding along in the previous parts, is obey the general contract
15280	17600	when overriding equals.
17600	23080	And I'm very excited, and so is the dog barking outside when I decided to record a video.
23080	26840	But I'm very excited because finally, man, this was a really long item.
26840	32880	It's taken me a whole month to get across this item, also because I've been procrastinating.
32880	38880	In any case, this is really good because all the stuff that we've learned in this item,
38880	44280	what to do, what not to do, we're going to put it all together in this final item and
44280	51040	create a high-quality equals method, or as Joshua Block would say, it's the recipe for
51040	53600	a high-quality equals method.
53600	56760	So without further ado, let's get started.
56760	61600	There are a few points that he's laid down on what to do when it comes to designing equals
61600	62600	methods.
62600	64600	The first one is quite straightforward.
64600	71440	It is to use the double equals operator to check if the argument is a reference to an
71440	72440	object.
72440	77800	So with the argument or whatever we are passing onto the equals method, if we use a double
77800	83200	equals operator, we can confirm if it's a memory reference.
83200	87160	So if you're passing the same object, let's say, then obviously it's going to return true.
87160	93760	As you can see in this really quite straightforward example, we have two strings and keep in mind
93760	98520	objects of string, of string class, are immutable.
98520	107800	And in this case, the first if condition will return true because both this new string,
107800	113000	I'm sorry, as I was staring into the code there, I realized I explained that wrongly.
113000	116640	Firstly, the caveat is this is a anti-pattern.
116640	121440	You should never declare strings like this because the new keyword creates a new object
121440	122640	in memory.
122640	127120	That's not required because as I said, string is immutable.
127120	133280	So here, when we compare string one to string two using the equals operator, this will in
133280	135200	fact say that they're not equal.
135200	138480	So this will say they're not in the same memory location.
138480	143160	But if you use the equals keyword, it's going to say they're in, sorry, it's going to say
143160	148400	that they have the same content or that there's logical equality as we've discussed throughout
148400	149840	this item.
149840	155920	So but when it comes to designing our own equals method, the reason that we should first check
155920	161160	using the equals operator, if it's referring to the same object is because if it is, we
161160	166360	just save time, we save computation time instantly, we can return true or false.
166440	173320	Not false, but we could certainly return true if it is equal to the, if the memory reference
173320	176320	is equal using the double equals operator.
176320	182960	And Joshua Block states, yeah, so if so returns true, this is just a performance optimization,
182960	187160	but one that is worth doing if the comparison is potentially expensive.
187160	191560	So if it's not equal, there may be a lot more other checks we need to do in order to have
191560	196520	a good quality equals method, but if it's the same memory reference, just return true.
196520	197520	I'm sorry.
197520	201320	I know I kind of exhausted that point, but it's important to understand why we do that
201320	203160	check initially.
203160	208280	The second one is to check if the, if it's an instance of the correct type.
208280	212360	And firstly, if it's not straight away return false, because if they're going to be two
212360	217480	different types, then there's no logical equality to start with, which is why Joshua
217480	223720	Block states in the second part of putting together this recipe, use the instance of
223720	228400	operator to check if the argument has the correct type.
228400	229640	So what does that mean?
229640	233960	What that means is before I read out what he stated, in fact, maybe I should first read
233960	234960	out.
234960	236880	No, no, no, I'll show this example.
236880	241160	And then before we get to the Java collections framework set example, I'll read out what
241160	242160	he stated.
242160	246920	So we've defined a type, we've defined my interface and we have a class that implements
246920	247920	my interface.
247920	253160	So now this class, my class is of type, my interface.
253160	258600	And then in the equals method, the first thing we are checking is we're first checking, yeah,
258600	262480	we're doing the reference equality, so the memory reference equality, which is what we
262480	267600	discussed in the first part here, or the first section, let's say.
267600	272680	And if it is straight away return true, no need to execute the rest of this code.
272680	276320	But if it's not an instance of my interface.
276320	283120	So whatever object we pass, let me just see if this is that's zoom in a little bit.
283120	284680	There we go.
284680	290320	Whatever object that we pass into the equals method, if it's not an instance of that broader
290320	296640	class or of a type, sorry, of that broader class, then return false.
296640	301160	So in that sense, we save time and only if it is, we get on with the rest of the equals
301160	304280	method to check if there's logical equality.
304280	308800	And that's why Joshua Block states typically the correct type is the class in which the
308800	310800	method occurs.
310800	313560	But if there's an interface like you've seen here, you can implement it.
313560	318480	And that's why he says use an interface if the class implements an interface that refines
318480	324840	the equals contract to permit comparisons across classes that implement the interface.
324840	331200	So what we're checking here in this equals method is not if the object be pass is an
331200	338400	instance of my class rather we're using the interface as a type, as you can see here.
338400	344840	So in that way, this equals method theoretically can be used across other classes, or at least
344840	350160	this part of the equals method can be used across other classes that implement the mind
350160	351560	to face type.
351560	356520	And as an example, he's used a the collections framework, the collections interface or the
356840	363520	collection interface, such as set list map and map entry have this property.
363520	369440	So we have this interface that extends the collection generic interface with this is
369440	374320	a generic parameter or a generic type.
374320	379880	And what that does is when we have my set, when we define a new set that implements this
379880	386440	set interface that we've declared here, oops, I will declare here.
386440	390880	In the equals method, as you saw from the previous example, it's the same thing that
390880	395920	checking if it's an instance of that set interface type.
395920	400520	And only if so, we get to the rest of the equals method, if not, we straight away return
400520	401520	faults.
401520	406120	And then the third section of this is, as you've seen in the myriad equals methods that
406120	412560	we've used throughout this item is to cast the argument to the correct type.
412560	418280	So just your block states cast argument to the correct type, because this cast was preceded
418280	422440	by an interface of test, it is guaranteed to succeed.
422440	431040	So we're passing in the equals method, when we do this check here, sorry, when we do the
431040	436680	check here, this ensures that we can do this cast safely without something like a class
436680	441880	cast exception error, because we are checking if it's of the same type, or at least if this
441880	445400	object is of instance of string.
445400	451160	And in this case, in fact, because it's not an instance of string, it will not do the
451160	454200	casting, it'll move on to do something else.
454200	462800	So if we pass some other object apart, other than let's say what we have here, or actually
462800	467200	sorry, in this case, because we've declared this to be an object is this will go through
467200	474120	I apologize, I realized that the type of object is still sorry, the type of OBJ is still off
474120	479560	type object, which is an instance of string, which is a super type to the string class.
479560	482040	So it'll do the casting here safely.
482040	485320	That's what I was trying to say, that was a bad view of explaining it, but you get the
485320	491120	point because we've done this test here, the casting should work fine.
491120	497440	Okay, now we get to the fourth section, the final part of this recipe.
497440	503680	And this really is most of what part four in this video series is about, because it's
503680	509800	really the biggest part when it comes to designing a good high quality equals method.
509800	515920	And that is that for each significant field in the class, check if that field of the argument
515920	519320	matches the corresponding field of this object.
519320	525040	Now before we get to the definitions defined by man, this dog really is annoying me.
525040	530600	I apologize, I tried to reduce background noise when editing the video, but it is quite
530600	531600	distracting.
531600	535760	Anyway, getting back to this, getting back to this.
535760	542800	So before I read the kind of formal definition in the book, let's quickly take a look at
542800	544240	a demo that I put together.
544240	551400	So what we have here, we have here a, I'm quite distracted today, I apologize, it's
551400	556920	like a lot going on despite me living in a very quiet neighborhood.
556920	564120	So what we have here is a class that I've called class person and it's got a private
564120	570360	field string, a private field called string and of type int.
570360	573520	So keep in mind that's a primitive type.
573520	579600	Then we also have the equals method and then you'll first see, so in the equals method,
579600	585080	as we discussed in the previous sections, we're doing first the memory reference check
585080	590520	and then we're doing the instance of check that gets us across many things.
590520	595080	It first tells us that here that these two are in fact two different objects.
595080	601720	If it returns false and here it says, despite them being two different objects or having
601720	604640	two different memory locations, they are of the same type.
604640	605640	That's good.
605640	611680	Now we get to the comparison and here really what this means is, as you can see, so after
611680	618000	doing the casting, so the object that we get, we cast it to of type person, each significant
618000	623560	field and that is, that really is something we need to think of in terms of logic, which
623560	630560	is why initially in this item, we discussed concepts such as logical equality and equivalence
630560	636840	relations because this call here, each significant field or each field that's significant is
636840	638000	compared.
638000	642120	That's a call that we as the designer of the equals method has to make.
642120	647840	So obviously when we're comparing, let's say two people or two persons in this case, we've
647840	653360	made the call that the name and the age are required for logical equality, which is why,
653360	660680	if you look at line number 20, we're checking to see if both name and both age are equal
660680	666400	and only if it's equal do we pass through and you probably can see here also, when it
666400	673840	comes to age, I'm using a double equals operator, not the equals keyword because it's a primitive
673840	674840	type.
674840	675840	It's not an object.
675840	680120	So accordingly, Joshua Block states, if the type in step two, which is the previous one
680120	691560	we discussed, that is, yeah, the instance of check, if the type in step two is an interface,
691560	695520	you must access the arguments fields via interface methods.
695520	700080	If the type is a class, you may be able to access the fields directly depending on their
700080	701840	accessibility.
701840	707800	And then he says, for primitive fields, whose type is not float or double and we'll get
707800	714640	into why that's the case, use the double equals operator for comparisons, which is what I've
714640	715640	done here.
715640	717960	As you can see, I already made that point.
717960	722280	I apologize if I didn't too kind of over repeat points, but I think it's important, you know,
722280	728400	repetition is the key to truly grogging concept.
728400	734600	And we continue, for object reference fields, call the equals method recursively.
734600	739840	For float fields, use the static float.compare method.
739840	743440	And for double fields, use the double.compare method.
743440	744440	So why is that?
744440	750400	Why do we have to, why is there an exception for float or double fields in this case?
750400	752200	The reason is because of auto boxing.
752200	757080	However, before we get to that part, let's first look at a quick example of what all
757080	758080	of this is.
758080	764160	So here, we have a class called bank account, and we have three fields, three significant
764160	765520	fields, keep in mind.
765520	767920	We have the account number, which is a string.
767920	771840	We have balance, which is of type double.
771840	774120	And then we have a Boolean value called is active.
774120	776520	So again, we're doing the checks here and equals method.
776520	782920	We're doing the casting in line number 17, should I zoom in a bit, line number 17.
782920	787760	And then when comparing the Boolean value because it's a primitive type, we're doing
788440	789440	the equals operator.
789440	792560	We're saying, if it's not equals, return false.
792560	798640	And BA is, by the way, the other object that we've got here after the casting.
798640	805520	And then in the account number, we're using the normal equals method that is in the object
805520	807280	superclass.
807280	808280	And that's fine.
808280	814120	But here, as we've been advised by Joshua Block, we're using the double.compare static
814120	820960	method instead of using the equals method, because, well, by the way, what this does
820960	822840	is it returns a true or false.
822840	830320	Sorry, I should put the proviso that it returns a true or false essentially or for all intents
830320	833080	and purposes in our equals method, because it actually doesn't.
833080	837880	It returns an int value if you look at the method, what it checks for if it's greater
837880	838880	or less than.
838880	840640	And accordingly, it'll return something.
840640	845840	However, if it's not equal to zero, that means there's a difference.
845840	847080	Therefore, it'll return false.
847080	853160	But if it's as in the function of the return false, but if it's equal to zero, that means
853160	857760	it's the same value or it's the same double value.
857760	861560	Therefore, it'll just keep going and return true in the equals method.
861560	866040	So what it looks for is a difference in the two parameters or the two values you pass
866040	868560	to the double.compare function.
868560	873880	But then to understand a bit more why it's better using this double.compare static method
873880	879280	instead of using the double equals operator or the equals method, let's say, it's because
879280	886640	of auto boxing, because if we do use the double equals operator for primitive fields that
886640	891280	are float or double, an auto box will take place where the compiler will automatically
891280	897960	convert these primitive types to the corresponding wrapper class types.
897960	898960	And that is costly.
898960	906840	That's very performance heavy or anti-performance to use a software engineering term.
906840	911160	And that's why Joshua Block states, while you could compare float and double fields
911160	916800	with the static methods float dot equals and double dot equals, this would entail auto
916800	921040	boxing on every comparison, which would have poor performance.
921040	925360	But auto boxing generally isn't a good idea, especially if you're using loops, keep away
925360	932520	from auto boxing because it can be very performance heavy because also it just creates new objects
932520	933600	every single time.
933600	941600	So an example we have here is this int value of type, it's a primitive type.
941600	947280	What auto boxing will do here is convert this int to the wrapper class integer and that's
947280	953520	going to now be an object and any instance of that will create new objects in memory.
953520	958200	And the compiler does that automatically for primitive and wrapper classes.
958200	965880	So that's why it's better to use compare instead of using the equals method for float or double.
965880	971320	And then kind of an ancillary point, a shunt's ancillary, it's still important.
971320	974800	For array fields, apply these guidelines to each element.
974800	980640	If every element in an array field is significant, use one of the array dot equals methods.
980640	985040	And as we're deciding this method, one thing that could come into your mind is what if the
985040	989240	object reference contains null, that is a very real possibility.
989240	994120	So we want to avoid a null point of exception if that happens, if the object reference contains
994120	999600	null and to avoid that, avoid the null point of exception, what we want to do for that
999600	1004920	is in fact, use the objects dot equals method where we compare two objects, which is in
1004920	1007200	the Java util objects class.
1007200	1010760	So if we take a look at another small demo, it's better looking at code than me trying
1010760	1011760	to explain it.
1011760	1014240	We have another class called person.
1014240	1019760	And again, we have a name of type string, and then we have an age of the primitive
1019760	1020760	type int.
1020760	1023920	We have the constructor and then the equals method.
1023920	1029440	So simply again, same thing, and we're doing the casting chain for the instance, the double
1029440	1031720	equals operation, all of that.
1031720	1038560	And then afterwards, in the comparison, we're comparing these significant fields.
1038560	1043360	It could be possible that one of them could have a null, or in this case, what we pass
1043360	1047400	this object, we pass onto the equals method.
1047400	1052920	This object dot equals method will ensure that another point of exception is enthroned.
1052920	1056960	And that's why when it comes to comparing the name, we are using objects dot equals.
1056960	1058680	Did I say object dot equals?
1058680	1060680	I meant to say objects dot equals.
1060680	1061680	That's important.
1061680	1067480	And the reason for that is instead of me explaining it, let me just use chatGPT to explain it
1067480	1069760	better than I ever could.
1069760	1075480	The object dot equals method is a utility method provided by the Java util objects class
1075480	1076800	in Java.
1076800	1082040	It can be used to compare the equality of two objects, taking into account that either
1082040	1084480	or both objects can be null.
1084480	1085480	And that's important.
1085480	1088040	Like the null point exception isn't thrown.
1088040	1093680	The method will return true if both objects are null, or if the objects are not null,
1093680	1098360	and the equals method of the first object returns true when called with the second object
1098360	1099360	as the argument.
1099360	1101040	So the example for that is seen here.
1101040	1109960	As you can see, we are passing a null value into person p4, and that returns false as
1109960	1114160	expected because we're comparing p1 to p4.
1114160	1119400	And in that comparison, it's clear that there is no logical equality here despite the age
1119400	1121520	being the same.
1121520	1126360	And there's also, more importantly, I guess, there's no null point exception being thrown.
1126360	1132840	And then we get to this concept of canonicalization, which is the idea that in some classes a simple
1132840	1140360	equality test won't do, especially as Joshua Bloch states for classes that are immutable.
1140360	1146040	Meaning if an object of an immutable class can potentially change, for logical equality
1146040	1150680	for or equals method to work properly, we still need to keep a canonical form of that
1150680	1154680	field somewhere in our class, and we need to store it.
1154680	1157840	So firstly, what is canonicalization?
1157840	1162400	And a definition I found probably the best one I could find is really of Wikipedia.
1162440	1167240	It's a computer science principle, and computer science, canonicalization, sometimes standardization
1167240	1174440	or normalization, something you hear quite often when it comes to a databases, is a process
1174440	1180160	for converting data that has more than one possible representation into a standard, normal
1180160	1181640	or canonical form.
1181640	1187080	You could probably see that itself hints to that idea that we want the data to exist
1187080	1190440	in a consistent representation when doing the equality.
1190440	1193640	And that's why we need to exist in a canonical form.
1193640	1198760	This can be done to compare different representations by equivalence, like the equals method, to
1198760	1204600	count the number of distinct data structures, to improve the efficiency of various algorithms
1204600	1210560	by eliminating repeated calculations, or to make it possible to impose a meaningful sorting
1210560	1211560	order.
1211560	1217640	So clearly this CS principle of canonicalization has many uses.
1217640	1224120	So we're going to look at a demo to exemplify this idea of canonicalization on a previous
1224120	1228440	class that we designed, which was the case and sensitive string class.
1228440	1234440	So if you recall, I think in part two, part two or three, when we were discussing symmetry,
1234440	1238560	we created this class called the case and sensitive string class.
1238560	1243120	And what we're doing here is really we're storing a canonical field.
1243120	1248520	We're storing data in a canonical field, which is in this string, we have this private
1248520	1249520	final field.
1249520	1255560	So it's going to be immutable called canonical S, which is a canonical string.
1255560	1261640	And then in the constructor, and we instantiate this class, as we normally set the value for
1261640	1267640	S, we are also setting the value for canonical S, which converts it to a canonical form.
1267640	1269480	And what does that method do?
1269480	1271920	It simply converts everything to lower case.
1271920	1282400	So in that case, if we go to the equals method, you could see that what we're using here is
1282400	1286280	the canonical string to check for equivalence relation.
1286280	1294960	We're not using the other value here, which is S, and that ensures that we have consistency
1294960	1299800	across the equals method because we have this canonical field that we're using.
1299800	1305680	And that's why we present the data in that way, despite we know that it can take many
1305680	1306680	forms.
1306680	1312200	So of course, apart from having a good quality equals method as soft engineers, what we always
1312200	1314440	look for is a performance application.
1314440	1319080	So we want that to be good efficiency in the equals method.
1319080	1322600	And therefore, just a block towards the end of this section discusses a few things we
1322600	1326600	can do to improve performance apropos of the equals method.
1326600	1332280	Firstly, it's important to compare the fields that are more likely to differ or less expensive
1332280	1334000	to compare, ideally both.
1334000	1337400	By the way, before we get to the second point, we're going to go through all of this in a
1337400	1338400	demo.
1338400	1340400	So first, let's get the theory out of the way.
1340400	1346200	So the second point is do not compare fields that are not a part of a objects logical state
1346200	1348440	because we are looking for logical equality.
1348440	1349520	That's important.
1349520	1352680	And then need not compare the derived fields.
1352680	1357440	So these are the three main points when it comes to improving performance on the equals
1357440	1358440	method.
1358440	1362880	Now, before we get to the demo, I just want to read the formal definition or the formal
1362880	1364840	elicitation of Joshua Block.
1364840	1369480	For best performance, you should first compare fields that are more likely to differ, less
1369480	1371760	expensive to compare or ideally both.
1371760	1373960	So that's point one.
1373960	1377600	If only I can click, there we go.
1377600	1382160	You must not compare fields that are not part of an objects logical state, such as
1382240	1385560	lock fields that use to synchronize operations.
1385560	1386880	You need not compare.
1386880	1389600	So that's part three.
1389600	1394360	You need not compare derived fields, which can be calculated from significant fields,
1394360	1398240	but doing so may improve the performance of the equals method.
1398240	1405400	If a derived field amounts to a summary description of the entire object, comparing this field
1405400	1411840	will save you expense of comparing the actual data of if the comparison fails.
1412160	1415280	So let's look at a demo.
1415280	1417920	What if we have a polygon class?
1417960	1423560	Now, this firstly, I want to say, I am not saying that this class of design is an accurate
1423800	1427800	polygon class, especially when it comes to the calculation of the mathematics.
1428160	1432840	I kind of did a bit of Googling, used a bit of charge APD and put this together, put this
1432840	1434120	together, pardon me.
1434160	1436520	So we have the polygon class.
1437120	1443440	So sorry, the caveat there was the provider was don't take these calculations.
1443440	1444160	Don't use them.
1444160	1445000	They're probably wrong.
1445000	1445840	I'm not sure.
1446320	1451560	So do double check before using this class if you want to do the polygon class.
1452920	1454120	So we have a polygon class.
1454120	1456400	We have edges vertices as a polygon.
1456400	1459920	This we have this all the fields here are primitive values.
1460240	1464920	And then we have a double array called sides with array, array cached or cached.
1465240	1468320	And then we have the constructor, of course, where we are setting all the values and even
1468320	1473960	setting the value for a Boolean variable or Boolean field, which checks if the array value
1473960	1474840	has been cached.
1475520	1479760	And then in the calculations, the calculation itself, we're checking for we're checking for
1479760	1483120	the area for a initially for a triangle and a rectangle.
1483120	1485920	And again, as I said, the formula may be wrong.
1485920	1487640	So I'm not sure if this formula is correct.
1488040	1494120	And then also, if necessary, we could use it for other polygons, depending on on the
1494120	1496320	number of sides, the formula will change.
1496840	1503120	So but the point is the point pertaining to our item is when we're doing the
1503120	1508000	equality, we aren't the only thing we really because because we're using a derived field
1508000	1509400	here, which is the area field.
1509800	1513360	The only thing we're looking for in the quality is the area value.
1513760	1517880	We're checking if the if the area is the same between the object we pass.
1517880	1522680	So the polygon object we pass, which, which for all intents and purposes will be a
1522680	1524160	polygon object we pass.
1524880	1530920	And we don't we know things such as the vertices, the edges, many things, even the
1530960	1532600	obviously things like the area cache.
1533080	1537920	And if we run this method, you'll see it works as expected because we are looking
1537920	1539000	for logical equality.
1540000	1545520	You can see here over here, firstly, comparing a triangle to a rectangle, it'll
1545520	1546400	return false.
1546560	1547320	That's correct.
1547560	1549600	We're setting all the sides in the sides area.
1550400	1554960	But when we compare a triangle to a triangle, so we have the click to
1554960	1559040	triangles here, triangle and triangle to it'll return true.
1559280	1563280	That is because the number of edges and vertices are the same.
1563320	1564440	So are the sides.
1564800	1567840	And that is because those values are what gives us the area.
1568440	1570120	So it's a derived field.
1570520	1575480	And in the quality all we require to create a high performance equals method is
1575480	1577520	the derived field value.
1577600	1579120	In this case, the area value.
1579480	1580640	I hope that made sense.
1580840	1585640	So just to repeat myself, to really get the take home point here, it is that we
1585640	1587840	don't have to compare the derived fields.
1587840	1591320	I may have misspoken and said we have to before, but we don't.
1591400	1596120	The idea is the significant field in this class in a polygon class is area.
1596480	1601680	And therefore we know if the area values are equaled for two objects, that the
1601680	1605120	vertices and the sides and the edges and all the rest of it is going to be equal
1605120	1608240	to, and in that way we make our equals method more performant.
1609040	1614200	Because if two polygons have unequal areas, there's no reason to compare the
1614200	1615720	edges and vertices.
1616600	1620000	And that gets us to the final caveats, let's say.
1620920	1622520	Okay, no, not yet, not yet.
1622560	1623520	I spoke too soon.
1624680	1625800	There's a bit more to say here.
1625800	1631920	So Joshua Block, despite me using many other classes to exemplify this, Joshua
1631920	1636320	Block has his own class called the phone number class that he's built, which I've
1636320	1638760	used here too, which is really well built.
1638760	1640640	It's a high quality equals method here.
1641120	1646560	And he says, when you're finished writing your equals method, ask yourself three
1646560	1647320	questions.
1647720	1648720	Is it symmetric?
1648840	1649800	Is it transitive?
1650000	1650960	Is it consistent?
1651160	1657400	If those three questions are fulfilled, that means, or if they're answered to be
1657400	1660280	yes, that means it's a high quality equals method.
1660440	1664600	And then he kind of puts this point, of course, your equals method must also
1664600	1669400	satisfy the other two properties, reflexivity and nonality, which we discussed
1669400	1674200	in the previous part, but these two usually take care of themselves.
1674320	1677520	And then we have the phone number class that is designed here, where in the
1677520	1681280	phone number class, we have the area code prefix and the line num.
1681920	1685560	They're all private final short values.
1688000	1692840	I realize he's used the non primitive type short here because it's a phone
1692840	1695400	number that helps with saving memory.
1695840	1700160	I've really not ever used a short method ever short type ever.
1700160	1702880	I've always used just int, but now that's that's that's good.
1702960	1707160	It shows that it's very punctilious when it comes to design and classes and
1707160	1709680	writing code, he pays attention to the small things.
1710600	1714760	So when it comes to the phone number class, yes, we have the constructor
1714760	1716000	where we set all the values.
1716000	1718000	We do a range check in this class.
1718000	1722920	We make sure that it's within the range using this range check method.
1724440	1728400	And afterwards we come to the crux of the matter, which is the equals method.
1728840	1730560	So you can see here what he's done.
1730560	1735960	He's firstly done the memory reference equality or check for memory reference
1735960	1740600	and then check for the proper type, the type check and then the casting,
1741280	1745600	which will be fine because we're doing the type check here.
1745600	1748160	There won't be any class class exception areas.
1748520	1752000	And then he's comparing all the significant fields.
1752640	1757880	And for him, or I guess not for him, even for me, for anyone,
1758920	1761240	this is a high quality equals method.
1761680	1765480	And now we get to the final caveats when designing an equals method.
1765720	1771040	So the first one is always override hash code when overriding equals.
1772120	1776120	We're not going to get too much into that because the next item is in fact
1776120	1778360	all on the hash code method.
1778920	1784400	However, that's mostly to ensure that objects of the class work correctly
1784400	1786600	in hash based collection.
1786600	1791920	So objects can be put through a hash function and you want any of these
1791920	1795560	classes or any of these, yes, classes that use hash,
1795880	1798680	hash based collections to work properly.
1799920	1803280	And that's why whenever the equals method is overrided,
1803520	1806720	we need to ensure that the hash code method is also overrided
1807160	1811800	and updated appropriately, depending on what we do with the equals method
1812120	1815200	to make sure these collections and other data structures, in fact,
1815320	1817320	work well with our objects.
1817320	1820040	The next point is don't try to be too clever.
1820280	1822840	Perhaps it's good advice for life itself.
1823520	1826160	And Joshua Block states, don't try to be too clever.
1826160	1831560	If you simply test fields for equality, it's not hard to adhere to the equals contract.
1832040	1835600	If you are overly aggressive in searching for equivalence,
1835640	1837560	it's easy to get into trouble.
1837560	1842080	And the example he's given is when it comes to equivalence relation or the comparison,
1842680	1846640	don't take aliases such as symbolic links into account.
1846640	1851880	Or the example here is, is the file class has symbolic links
1851880	1857400	and we shouldn't take that kind of alias into account when doing an equality check.
1857560	1861880	And a few definitions to understand what the relationship between an alias and a symbolic link is.
1861880	1868160	So firstly, as Biden has put it, a soft or symbolic link is a file pointer.
1868160	1874960	So in the file class that behaves as a file that is linking to if the target file gets deleted,
1875360	1877280	then the link is unusable.
1877960	1879480	So it's mostly a pointer.
1879480	1884840	And I think, in fact, charge dpd had a much better explanation than even
1884840	1888120	well done and I really love well done's blog.
1888440	1892880	In any case, what charge dpd states is an example of a symbolic link.
1892880	1897360	Imagine you have a folder called original and you have a large number of files in it.
1898040	1902480	Now, you want to create another copy of the folder, which is identical to the original folder,
1902600	1904600	but in another location of your file system.
1905200	1908160	Instead of copying the entire folder and its contents,
1908160	1913480	you can create a symbolic link to the original folder and place it in the desired location.
1914120	1918960	I can access the original files to the symbolic link, which acts as an alias.
1918960	1923280	So it's that's that's the bit that alias bit or the symbolic link we create
1923600	1927520	shouldn't be taken into consideration when designing the equals method.
1927880	1929880	That's a field we should ignore.
1929880	1932480	And then an example of an alias is, let's say you have an object
1932480	1936200	A with some properties and methods and you create an object B
1936600	1938680	that is identical to object A.
1938680	1942400	Now you can access object A's properties and methods through object B,
1942440	1945280	which acts as a as an alias for object A.
1945360	1947160	So that kind of makes is what an alias is.
1947160	1948880	And this is how you define symbolic links.
1948880	1952840	So in the files method, we have file, stock, create symbolic link.
1952960	1955640	We have the link we create and then we have the target.
1956000	1959760	This link we create shouldn't be used when it comes to
1960640	1963600	a equivalence relation in I equals method.
1963600	1966400	That should be ignored and it's not a significant field.
1966600	1968920	So the final caveat is, in fact, quite important.
1968920	1971880	Now, the other two caveats are I don't think, at least,
1971880	1974320	that one would be prone to making those mistakes.
1974560	1978480	Whereas this most certainly I can see myself making this mistake.
1978720	1983280	It is that you shouldn't substitute another type for object in the equals
1983280	1988880	declaration. So as you saw in the equals method as defined in the object super
1988880	1992320	class, it we all actually, this is a bad example.
1992360	1993680	This is the way not to do it.
1993720	1997040	But normally what you'd have here is the object we take in the
1997040	1998800	parameter would be of type object.
1999200	2001680	But let's say we define it to be some other type.
2002240	2006600	This will create some problems because firstly, what this does is
2006600	2010440	it will the compiler will not inherit the problem implementation of the equals
2010440	2014320	method. And since the method is strongly typed.
2014320	2018400	So now we've specifically defined what type we want.
2018560	2020760	And it can't just be the superclass object.
2021400	2025680	It'll take objects of a specific class, a specific type instead of object,
2025720	2028560	which can give false positives, certainly.
2028840	2033240	And one other point there is the problem with defining the equals method like
2033240	2040120	this is the method does not override the object dot equals because we do inherit
2040120	2041840	this from the superclass object.
2041840	2044560	We do it like this instead of overriding.
2045720	2050120	It will overload it because the method in the object dot equals class,
2050400	2052080	the type is object.
2052440	2056000	And now we've changed it where it's going to be overloaded and the equals
2056000	2059640	method will still exist in our subclass.
2060000	2061760	So it'll sort of be like this.
2061760	2066080	It'll be it'll be this and then there'll be another method.
2066960	2071360	With object, Java disallowed this because the signature of these two methods
2071360	2073880	are different. They're both, they've both got the same name.
2074000	2077200	However, they take in different types of parameters.
2077200	2078840	So overloading takes place.
2078880	2083080	And this is a problem again, cause it can mislead the client of our class.
2083120	2087640	Now, in my opinion, it's always a good habit to use annotations in Java.
2087680	2088880	I think that's a good idea.
2089320	2094920	And this is a good example of why perhaps using an annotation is good.
2094920	2098120	Not for the sake of the compiler, let's say, but more for the programmer,
2098120	2103040	because what happens here is here, because we explicitly stating,
2103720	2107160	we're going to override the equals method in the superclass.
2108160	2109320	This won't compile.
2109360	2110400	It'll give an error.
2111160	2113560	It's still broken, of course, but at least it won't compile.
2113560	2116880	So we'll, you know, pick our mistake and we'll recognize some things.
2116880	2120880	We've done something wrong here by giving it type my class instead of object.
2121720	2125720	And I think it's good because now we're saying instead of overloading,
2125760	2130240	we want it to, we're explicitly stating we want it to override and the compiler
2130240	2133960	is saying, nope, we can't do this, which is what you'll see here.
2133960	2134800	So this is demo here.
2134800	2137920	I have a parent class with a equals method.
2138760	2143320	And if you look at the child class, this is dangerous because we're doing
2143320	2145120	overloading here unknowingly.
2145360	2148640	However, if we do put the override annotations in here,
2148640	2152520	if we do put the override annotation, it'll throw an error, let's say,
2152520	2157320	or the override can't take place, can't take place, which then we can fix by
2157400	2161080	doing it the proper way, which is what I've defined here, where now we have a
2161080	2165800	proper overriding takes place with the type of object.
2165800	2167320	So we're taking all the objects in here.
2168600	2169360	That's great.
2169880	2173320	And then, of course, that's the end of the item, the end of the part,
2173320	2174120	and the end of the item.
2174120	2176240	Wow, that was a long, long item.
2176240	2178080	It was probably 10, 15 pages.
2178080	2180200	I feel really good for getting through that.
2180200	2186160	And I learned so much, but, but, but at the end of the item, Josh Schumburg
2186160	2188800	states, Hey, look, yes.
2188800	2192240	Now you know how to design or you have the recipe for a high quality equals
2192240	2192760	method.
2193360	2194320	And yeah, it's fantastic.
2194320	2195000	We learned a lot.
2195000	2198080	We went through a lot of a bit of computer science, a bit of human logic.
2198960	2204520	However, most of the time it's a good idea to use the IDE or to use something
2204520	2208840	like the auto value framework, Google's open source auto value framework, when
2208840	2213800	designing equals methods, because these frameworks were pretty much take care of
2213840	2216720	all of these things we discussed in this item.
2217080	2218520	Look at how long the item is.
2219080	2224880	Everything from, from, from the properties and, and making the equals
2224880	2226520	method more performant, all of that.
2227280	2234000	Which is why Josh Schumburg states, an excellent alternative to writing and
2234000	2239400	testing these methods manually is to use Google's open source auto value
2239400	2244280	framework, which automatically generates these methods for you triggered by a
2244280	2246360	single annotation on the class.
2246960	2252680	And then he also says, having IDEs generate equals and hash code methods
2252680	2257240	is generally preferable to implementing them manually because IDEs do not
2257240	2258360	make careless mistakes.
2258360	2259880	And of course humans do.
2260560	2261680	That's the end of the item.
2261840	2266440	And then he states, in summary, don't override the equals method unless you
2266440	2272120	have to, in many cases, the implementation inherited from object does exactly
2272120	2272760	what you want.
2273000	2277880	If you do override equals, make sure to compare all of the classes, significant
2277880	2283360	fields, and to compare them in a manner that preserves all five provisions of
2283360	2284480	the equals contract.
2285400	2286000	Fantastic.
2286280	2290280	I'm so happy that I got through that, especially because I feel like I learned
2290280	2294160	a lot when we were going through that item because it touched on so many
2294160	2296720	different concepts, which was a really fun item to cover.
2297040	2301440	And the next one is item 11, as I did state a bit before, always override
2301440	2304840	hash code when you override equals.
2305280	2307560	And I shall see you in the next one.
2307680	2308320	Thanks for watching.
2308520	2309000	Cheers.
