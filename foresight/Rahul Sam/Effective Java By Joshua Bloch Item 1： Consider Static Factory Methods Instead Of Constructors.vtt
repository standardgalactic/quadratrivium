WEBVTT

00:00.000 --> 00:05.920
Hey everyone, welcome to this video series called Textbook to Code, where I take computer science

00:05.920 --> 00:12.720
and software engineering textbooks and sort of expand on them and convert them to code and discuss

00:12.720 --> 00:18.720
them, kind of like what one would do in a tutorial in university. Now, if you're new to this channel,

00:18.720 --> 00:25.280
I generally make videos on philosophy, but I realized my other great love, other than philosophy,

00:25.280 --> 00:30.640
is computer science and software engineering. So I was thinking, why not do the same thing with

00:30.640 --> 00:36.400
that field too? And as the title suggests, the first book I'll be covering is Effective Java by

00:36.400 --> 00:44.160
Joshua Block. Certainly the best Java book I've read, even though I'm still trying to grok certain

00:44.160 --> 00:49.360
concepts on it. It was recommended to me by my CTO and my current company, and he's been a Java

00:49.360 --> 00:54.320
programmer for, I don't know, ever since the internet. That was a joke, by the way. I know Java

00:54.320 --> 01:00.640
was created after the internet. He's been a Java programmer for a long time, and he said that this

01:00.640 --> 01:08.080
was a really good book to read, not really for beginners, but more for intermediate Java developers.

01:08.880 --> 01:13.200
I consider myself still a beginner to intermediate. So I don't really know

01:14.800 --> 01:20.960
at what level I should get into this book. However, I do believe really the way it's structured,

01:20.960 --> 01:25.520
anyone can jump into it if you have a basic understanding of programming. So Effective

01:25.520 --> 01:33.440
Java contains about, I believe, 90 items, which means this video series will encompass 90 items.

01:33.440 --> 01:37.440
And afterwards, I'm hoping to get to this book, which probably is going to be next year, because it

01:37.440 --> 01:43.120
takes a long time to make these videos. The Headfirst Design Patterns by O'Reilly, which I've just

01:43.120 --> 01:50.640
started on, and it's brilliant. I'm so grateful for all these authors who just don't take so much

01:50.640 --> 01:57.120
time to educate and help upcoming learning software engineers like myself, who generally

01:57.840 --> 02:04.160
aren't the most intelligent programming wizards out there. Saying that, though, as per usual with

02:04.160 --> 02:09.440
my normal videos, if you do follow this channel, you know that I tend to make a lot of provisos or

02:09.440 --> 02:15.840
caveats. And the first proviso is this is not a tutorial. And that's really important, because

02:15.920 --> 02:22.640
the last thing I want to do is to propagate false information or teach something that's wrong.

02:23.920 --> 02:30.880
And, you know, to make this a video series of misinformation to use a very politically loaded

02:30.880 --> 02:36.480
term. I'm not a teacher, not an expert. I've only been a Java programmer really hands on for about

02:36.480 --> 02:43.040
two years. I'm still learning myself. I'd like to think of this video series and all the videos

02:43.040 --> 02:50.400
in this channel, as a matter of fact, as more of a blind, leading the blind kind of experiment,

02:50.400 --> 02:56.800
let's say, where I am also naive and ignorant about these topics. So it's just more of a

02:58.000 --> 03:04.160
exploratory disquisition, let's say. I'm just trying to see what this particular concept is.

03:04.160 --> 03:11.600
I'm trying to break that down, which means I will inevitably make mistakes. No question about it. So

03:11.600 --> 03:16.240
please point them out. Leave those out in the comment section below. I'm sure there are much

03:16.240 --> 03:22.880
more advanced competent Java programmers who will point out some of my flaws. And when I say a blind

03:22.880 --> 03:27.520
leading the blind, I don't mean I'm leading anyone else in that sense. The point I'm trying to make

03:27.520 --> 03:34.160
is that let's try to collectively work on this. And again, the best example I can use or the best

03:34.160 --> 03:39.600
analogy I can use is what one would typically do in a university tutorial where you work with the

03:39.600 --> 03:44.640
tutor and the other students to solve a particular problem. And of course, since this is a programming

03:44.640 --> 03:51.840
video, engineering video, all the code that I used to expand on the first item, I shall have it on

03:51.840 --> 03:57.600
my GitHub account. I'll leave a link down below. You could go download it and play around with it

03:57.600 --> 04:02.960
yourself. On that note, let's jump into it. We'll start with item one. So this is from

04:04.240 --> 04:08.560
chapter two, creating and destroying objects. I'm not going to cover chapter one because it's

04:08.560 --> 04:13.360
essentially just an introduction. And the same way that I gave caveats in this video,

04:13.360 --> 04:17.600
Joshua Block himself gives a couple of a few caveats on what this book is about.

04:18.400 --> 04:26.800
Just in context, Joshua Block is is brilliant. He he was, I think he created or he was a big part

04:26.800 --> 04:32.240
of the Java collections framework. He's a distinguished engineer at Google, I believe.

04:32.240 --> 04:38.400
So he's been a part of the Java JVM community for a long time. And I suddenly look up to him

04:38.400 --> 04:44.160
and I really enjoy just even watching some of his talks on YouTube. But this book, this book

04:44.160 --> 04:52.240
really opened my mind into the power of the Java language. And in fact, OOP principles in general.

04:53.600 --> 04:59.120
So again, as I said, chapter two is creating and destroying objects. And the first item

04:59.120 --> 05:04.800
we're going to cover is let me zoom in a bit because I don't want this to not be visible.

05:05.360 --> 05:11.200
The first item we're going to cover is consider static factory methods instead of constructors.

05:14.000 --> 05:19.440
So when I read this item, the moment the first time I read this chapter,

05:20.160 --> 05:25.760
oh, sorry, this item, my question was, what is a static factory method?

05:26.000 --> 05:37.680
And and in simple the very textbook answer would be, it's a static method that returns an instance

05:37.680 --> 05:43.920
of a class. Now, don't worry, I've got the code base right here, we're going to jump into all of

05:43.920 --> 05:48.880
these things in much more detail a bit later. But I think it's sort of important at a high level to

05:48.880 --> 05:55.520
get the terms right and get them all in order just to help out thinking. Look, I'm just going to say

05:55.520 --> 06:00.400
my thinking, I'm not going to pretend as if this is a collective thing. It's initially me making a

06:00.400 --> 06:05.520
video. And then eventually, hopefully it can be a collective thing in the comment section down below.

06:07.440 --> 06:12.480
And you know, not a Benet, this is not the same as the factory method design pattern.

06:14.080 --> 06:19.840
Even though I'm not going to lie, it maybe this is my lack of understanding of the design pattern.

06:19.840 --> 06:25.920
I see many similarities between what the static factor method does and then the design pattern.

06:25.920 --> 06:31.600
So perhaps that's why it's called a static factor method. So let's take a look at the keywords,

06:31.600 --> 06:37.840
first of all. So when we say a static factor method, and let me give you a quick example,

06:37.840 --> 06:44.240
in fact. So here we have the big integer class and a static factor method here would be

06:45.200 --> 06:50.800
that right there, public static, big integer, the probable prime method, for instance,

06:50.800 --> 06:57.200
is a static factor method. Which means we got a question that I asked myself was, what is static?

06:58.160 --> 07:03.680
And I took down a few notes. Of course, the word static means a lot in software engineering.

07:06.080 --> 07:12.480
And my notes said that the word static ensures that a member belongs to a specific class. So again,

07:12.480 --> 07:20.560
in the example of this big integer class, this member belongs, this member has in this method

07:20.560 --> 07:30.880
belongs to this specific class. Therefore, only one instance of the member exists, regardless of

07:30.880 --> 07:38.240
the number of objects of the class created. So it doesn't matter how many instances of the big

07:38.320 --> 07:43.600
integer class is created. But there's only going to be one instance of this method,

07:43.600 --> 07:49.360
because this this method, the probable prime method belongs to this big integer class,

07:49.360 --> 07:56.640
there won't be multiple objects of that being created. And a static member is shared amongst

07:56.640 --> 08:05.280
all objects. So because it belongs to a certain class, any any other, let's say, client that

08:05.280 --> 08:10.320
uses this class and creates an instance of this class with the new keyword, just shares

08:11.120 --> 08:15.440
that specific object, pardon me, not all the objects, I think I'm a spoke there,

08:15.440 --> 08:21.840
more the static member, I think it's better to think of it that way. So of course, I'll get into

08:21.840 --> 08:25.520
all of these stuff in detail a bit later. So of course, that means that when you want to use this

08:25.520 --> 08:31.120
method, the probable prime method, one doesn't have to create an object of the class, you know,

08:31.120 --> 08:35.840
use the new keyword, the way it's done in Java, it just makes things easier.

08:37.040 --> 08:45.520
Also, and another caveat here, my understanding of Java memory management is very, very high

08:45.520 --> 08:51.040
level. I know it's a very deep topic. It goes all the way into the depth of what computer science is

08:51.040 --> 08:56.960
and engineering in general. So I have a very, very superficial understanding of it. But my

08:56.960 --> 09:02.480
understanding is that static content, so any, it could be a class, a variable, a method,

09:02.480 --> 09:09.360
doesn't matter, will be stored in a in a place called the dynamic meta space. This is a JVM,

09:09.360 --> 09:15.840
will will store it in a place called the dynamic meta space, which I've learned to replace something

09:15.840 --> 09:24.400
called the permanent generation since Java 8. So all these static members live in the dynamic

09:24.400 --> 09:30.080
meta space. Now, here's, this is an important point that we're going to get to in this video.

09:30.720 --> 09:37.920
I've, I've, I've got a whole bunch of resources and study material that I used as I was creating

09:37.920 --> 09:45.280
this video and studying this book. So for each item, all the, what's the word, supplementary

09:45.280 --> 09:51.600
reading material and studying resources, which I have a whole list here, just articles,

09:51.600 --> 09:57.840
blog posts, videos, whatnot. I shall leave them down below in the description. I really think it's,

09:57.840 --> 10:05.520
it's super useful, along with the book, along with each item, reading those supplementary articles,

10:05.520 --> 10:10.320
it gives, at least for myself, it gave a really good understanding of what Joshua Block is talking

10:10.320 --> 10:17.680
about in each item, especially given that he, he expects the readers of this book to be

10:18.320 --> 10:24.880
quite proficient in Java. So if you're sort of a, in an intermediary level like me, these, these

10:24.880 --> 10:34.320
background articles help. And on Java memory management, a very grokable, easy, easy to

10:34.320 --> 10:40.640
understand video that I watched was by Naveen Automation Labs. I thought he explained it quite

10:40.640 --> 10:47.600
well. He's a great pedagogy, great teacher. It made a lot of sense to me. And then I read

10:47.600 --> 10:52.160
this article about what the meta space is in particular, because since we're talking about

10:52.720 --> 10:59.360
the keyword static. So along with the word static, the other sort of keyword of these methods is

10:59.360 --> 11:06.560
factory. And here's where I said before, it seems a bit similar to the factory method design pattern.

11:08.080 --> 11:16.160
And maybe, maybe it's because it does follow certain aspects of the

11:16.160 --> 11:20.960
creation and design pattern, even though there's no direct relation. In fact, in the book,

11:23.520 --> 11:31.440
it says here, there's, oh yeah, it says here, note that a static factory method is not the same

11:31.440 --> 11:37.920
as the factory method pattern from the design patterns. I feel terrible now when I looked at

11:37.920 --> 11:44.400
the book, I realized that I've highlighted certain things, as you can see, these bits from the book

11:44.400 --> 11:48.240
I wanted to read out and I didn't do it in the beginning of this item. So I'm going to do that

11:48.240 --> 11:53.760
right now. I'm so sorry if this is chaotic and a bit messy. Please forgive me. I'm still

11:54.960 --> 12:00.800
trying to figure out how all of this works and how to expand on these matters. So I'm going to read

12:01.600 --> 12:06.320
this is a mess. I'm so sorry. I'm going to read the introduction to the item now,

12:06.320 --> 12:10.800
which I was supposed to do in the beginning of the video, but I only realized that now.

12:11.520 --> 12:17.440
So here's what Joshua Block says. The traditional way for a class to allow a client to obtain an

12:17.440 --> 12:23.920
instance is to provide a public constructor is another technique that should be a part of every

12:23.920 --> 12:31.360
programmer's toolkit. A class can provide a public static factory method. There we go.

12:33.840 --> 12:40.400
Which is simply a static method that returns an instance of the class. I'm glad I read that

12:40.400 --> 12:44.240
because I should have started with that bit because it's too confusing if not. Anyway,

12:44.240 --> 12:50.160
getting back to the the factory keyword. So what this also does is it allows to encapsulate the

12:50.160 --> 12:56.000
object creation process because if you do notice and we'll get into this again, the constructors are

12:56.000 --> 13:04.320
private. So clients cannot access the constructors and create objects as they wish. In many ways,

13:04.320 --> 13:10.960
is in fact one of the advantages which we'll get to again later of using static factory methods.

13:11.840 --> 13:19.680
The class can decide when to create new instances of the class and it's not that a new object is

13:19.680 --> 13:27.120
created for every invocation when a competition is required. So therefore, I don't know if this

13:27.120 --> 13:35.360
makes sense, but I think it's because it resembles certain creational design pattern.

13:36.640 --> 13:41.280
Let's say elements, the word factory is used to describe them.

13:43.120 --> 13:49.360
So now let's get to the why the advantages. What's the justification? Why is Joshua Block telling us

13:49.360 --> 13:56.880
to use static factory methods instead of constructors? How one would typically do the first one

13:57.120 --> 14:03.120
Joshua Block talked about is that unlike constructors, static factory methods have names. They

14:03.840 --> 14:09.680
tell it to the client or they indicate to the client what this method's doing. The example he's

14:09.680 --> 14:17.840
used is in the big integer class. Now he said here, the constructor, which is this, which I've taken

14:17.840 --> 14:22.080
down here. So in fact, maybe I should go to the code itself without just showing it off notion.

14:23.040 --> 14:30.240
If you go to the big integer class, here we have the, all right, sorry, it's a really big class.

14:30.240 --> 14:36.560
I have to go through the code. The constructor here, which is the constructor for the big integer

14:36.560 --> 14:41.360
class. In fact, on the comments that even says here constructs a randomly generated positive

14:41.360 --> 14:46.160
big integer, there's probably a prime with the specified bit length. But it also says here,

14:47.120 --> 14:53.920
it is recommended that the probable prime method is used in preference to this constructor,

14:53.920 --> 15:00.240
unless there is a compelling need to specify a certainty. Correct. So what this does is it just

15:01.440 --> 15:08.960
returns a big integer, which could be a probable prime. But this is just a constructor. It's just

15:08.960 --> 15:14.240
the name of the class. It doesn't really, to me as a client using this, doesn't tell me what this

15:14.240 --> 15:21.600
does, which is why it's better using the static factory method, the public static big, big integer

15:21.600 --> 15:30.880
probable, probable prime conference. I would right there where when I met me, a client is using it

15:30.880 --> 15:39.440
as I've used it right here. I clearly know what this method is doing. It makes the code clean.

15:39.440 --> 15:43.680
And of course, a class can only have a single constructor with a given signature. You can't

15:43.680 --> 15:48.480
have, at least in Java, I don't know about other programming languages, but I don't think so.

15:48.480 --> 15:55.760
One can't have multiple constructors for a class. I assume maybe I'm wrong there, but that's at

15:55.760 --> 16:00.560
least my understanding. And then a very basic question to ask is, what's the purpose of a

16:00.560 --> 16:06.000
constructor? The purpose of a constructor really is, as the name suggests, to construct a class,

16:06.000 --> 16:12.400
as it's said in the Oracle docs, a constructor is used in the creation of an object that is an

16:12.400 --> 16:21.920
instance of a class. Typically, it performs operations required to initialize the class

16:21.920 --> 16:28.400
before methods are invoked or fields accessed. Constructors are never inherited. So for me,

16:28.400 --> 16:35.920
at least as a client, using the probable prime method makes more sense. He says, because a class

16:35.920 --> 16:41.120
can only have a single constructor with a given signature, programmers have been known to get

16:41.120 --> 16:47.440
around this restriction by providing to constructors whose parameters, whose parameter lists differ

16:48.160 --> 16:53.920
only in the order of their parameter types, so method overloading. This is a really bad idea.

16:53.920 --> 17:00.000
The use of such an API will never be able to remember which constructor is which and will

17:00.000 --> 17:06.880
end up calling the wrong one by mistake. People reading code that uses these constructors will

17:06.880 --> 17:13.440
know what the code does without referring to the class documentation. Because they have names,

17:13.440 --> 17:19.680
as in static factory methods, we don't have this restriction. And when I was reading this paragraph,

17:19.680 --> 17:25.200
I had a bit of a grin because in the project that I'm currently working on, which is a huge

17:25.200 --> 17:32.480
enterprise, massive Java project, I think we've got 40 odd microservices. I see this happen all

17:32.480 --> 17:38.560
the time. We, you know, a lot of legacy code, we've done a lot of method overloading. And sometimes

17:38.560 --> 17:45.360
when as a client, I'm using a certain class, or even if I'm instantiating a class, I'm not even

17:45.360 --> 17:51.280
sure which method, which parameters to pass into the method, because it's been overloaded so much

17:51.280 --> 17:58.880
that it's hard to work on as a client. Whereas with the big integer class, I exactly know what I'm

17:58.880 --> 18:04.160
doing here, just using the problem prime method. So the second justification or advantage is that

18:04.160 --> 18:09.760
static factory methods, as I sort of said many times already, do not require object creation

18:09.760 --> 18:13.600
each time they're involved. It's one of the biggest advantages, in my opinion,

18:13.600 --> 18:19.600
that this allows immutable classes for sure. It's also similar to the fly weight design pattern. Now

18:19.600 --> 18:27.680
I put this note here, just because I want to kind of put into the notes everything that's in the book.

18:27.680 --> 18:33.440
I have no idea at the moment what the fly weight design pattern is. I haven't done any further study

18:33.440 --> 18:39.280
into that. So hopefully, when I do, I'll probably revisit this and leave a comment explaining what

18:39.280 --> 18:47.520
it is from my point of view. The example that we can use here is in fact, this little method

18:47.520 --> 18:54.320
method that I created, it's an example from the book, which was this method right here. It's this

18:54.320 --> 18:59.440
simple method that I created called value off. It's an example from the book. So if I want to

18:59.440 --> 19:04.640
use this method, and this method is in this class called manipulate strings, I don't have to create

19:04.640 --> 19:12.080
an instance of the class. Let me demonstrate. So for instance, if I go here, and if I want to print

19:12.080 --> 19:26.400
out something, let's just say value off, and we go manipulate strings dot value off, I'm going to

19:26.400 --> 19:33.280
pass a true there. And then I run that, you will see it'll just print true. Okay, sorry for the

19:33.280 --> 19:39.280
useless method. And as you saw there, I didn't use a new keyword. There were no objects being

19:39.280 --> 19:46.800
created. I simply accessed the method via the class, because that method's owned by the class,

19:46.800 --> 19:52.000
so to speak. Then another advantage of not having to create objects is, and it took me a while to

19:52.000 --> 19:57.680
grok this concept, because I had to do a bit of stack overflowing to use a term that we all love

19:57.680 --> 20:03.920
as soft engineers. It makes classes instance controlled. So it says here in the book,

20:04.800 --> 20:10.720
the ability of static factory methods to return the same object from repeated invocations allow

20:10.720 --> 20:18.240
classes to maintain strict control over what instances exist at any time. Let's try to understand

20:18.240 --> 20:26.480
this. So firstly, just keep in mind this makes a class singleton and non instantiable. So essentially

20:26.480 --> 20:32.640
singleton means it at a given time only one object of that class can exist, whatever the class might

20:33.120 --> 20:42.000
be, if we follow that pattern. And I really only understood this thanks to Joshim Sao who posted

20:42.000 --> 20:47.920
a really good answer on Stack Overflow. I shall leave a link to this down below of what this

20:47.920 --> 20:54.640
concept means and how using static factory methods makes classes singleton and immutable.

20:54.640 --> 20:58.480
So to get this concept first, let's see what Joshua Block is saying. He's saying that

20:58.800 --> 21:06.960
yeah, it allows immutable value classes as I repeated multiple times already. And then it says

21:06.960 --> 21:16.640
to make the guarantee that no two equal instances exist as in A equals B. So class A equals B only

21:16.640 --> 21:24.480
if it's equal in this sense as in this equals sign means that the values in the objects are compared

21:24.480 --> 21:30.800
the double equal sign is a reference or memory location of objects in the heap. So as I said,

21:30.800 --> 21:40.080
thanks to Joshim Sao, I think I got what this meant. It gives complete control to the class as to

21:40.080 --> 21:45.520
when instances of this class will be created. Now here's the example that he has used. So I did have

21:45.520 --> 21:52.800
it here. I'll zoom into that. One of the methods here is deprecated. So you can't clearly as you

21:52.880 --> 21:57.600
can see here in the docs, it says that it's marked for removal because we don't really create new

21:57.600 --> 22:03.920
instances of the Boolean class anymore. Now I'm going to comment that out for now. And see here,

22:03.920 --> 22:11.280
if I print this, we're getting a true and false despite the first one because we're looking at

22:11.280 --> 22:17.600
the value in the object, we're getting a true but here in the reference comparison or in the memory,

22:17.600 --> 22:25.920
we're getting a false. Now personally for me, this was okay. I got what he meant conceptually,

22:25.920 --> 22:33.440
but really what I did was this. I created another small class called fooba. As you can see, I made

22:33.440 --> 22:41.200
the constructor private. So it's inaccessible to any client. And then what I did was I created a

22:41.200 --> 22:47.200
static factory method called construct fooba. If you can clearly see here what I'm doing is

22:47.280 --> 22:55.520
I'm returning a new instance of the fooba class. But in the method body, I have an F condition.

22:55.520 --> 23:01.920
And I say only if the number is greater than five, is it allowed to create a new instance of this

23:01.920 --> 23:07.520
class. Now, yes, one could say you could do this in a constructor too, but doing it in a static

23:07.520 --> 23:13.920
factory method makes more sense due to the previous advantage we spoke about, the fact that we can

23:13.920 --> 23:19.200
use the name in the method. So you probably see here, I'm going to comment this out again.

23:21.360 --> 23:27.120
Now I'm using the construct fooba method and I'm passing initially I'm passing the number seven.

23:27.840 --> 23:37.680
And then if I run that, it's if I zoom in here, there you go. That's the that's the object that

23:37.680 --> 23:42.080
that was passed through. So it returned a new object of the fooba class. But that's because

23:42.080 --> 23:48.880
seven is greater than five. But if I like pass two, it's an R. So this is this is what

23:49.520 --> 23:56.560
Joshua Block means by it's it's it gives classes complete control as to when instances of that

23:56.560 --> 24:01.280
class will be created. On that point, I would also say just to just to keep in mind that enum types

24:01.280 --> 24:07.200
provide this guarantee by the way. So if you do this comparison that I did before between different

24:07.200 --> 24:12.800
classes or between different types, you'd see it follows a pattern with enum types.

24:13.840 --> 24:20.720
The third point is, or the third justification or why so to speak is, unlike constructors, static

24:20.720 --> 24:27.200
factory methods can return an object of any subtype of their return type. This again, a bit like the

24:27.200 --> 24:33.440
instance control bit, it took a bit of time for me to understand what it meant. So let's see what

24:33.440 --> 24:39.200
we mean here. The best example to use is certainly my favorite Java framework, the collections framework

24:40.160 --> 24:46.720
is to demonstrate what an interface interface based framework is. So the first thing you'll notice is

24:46.720 --> 24:52.000
if you go to the collections framework, I mean the class, sorry, if you go to the public class

24:52.000 --> 24:59.440
collections, it's constructed as private. So you can't instantiate it. And then if we take a look at

24:59.440 --> 25:07.120
this little bit of code that I put in, I'm creating a array list. I'm creating, in fact,

25:07.120 --> 25:14.960
two array lists, a source and target list of string type, and I'm adding values into it.

25:14.960 --> 25:20.000
And then in the collections class, I'm using this static factory method right here. And

25:20.000 --> 25:25.600
what that does is it returns, let me just read the documentation is much easier because they put it in

25:26.560 --> 25:31.840
much better terms with brevity, returns the starting position of the last occurrence of the

25:31.840 --> 25:38.720
specified target list within the specified source list or a negative one, if there is no such occurrence.

25:38.720 --> 25:43.920
So here we have the source list, here we have the target list. And what I'm trying to see is I'm

25:43.920 --> 25:53.120
trying to find the first occurrence of this value of the target list in this case. So as you can see,

25:53.120 --> 26:01.040
this CDE, which is the, let's call it the sub list for the old intents and purposes,

26:01.600 --> 26:08.560
it starts at the index number two, zero, one, two. And if you print that out, it returns that here.

26:09.120 --> 26:13.920
Now, that's, that's besides the point. But the important point here for over here is that

26:14.720 --> 26:22.880
the collections class is returning a type of index of integer. It's returning a subtype,

26:22.880 --> 26:29.360
as it says here, is that unlike constructors, they can return an object of any subtype of their

26:29.360 --> 26:34.800
return type. So it's returning an integer subtype, which is different to the type of the

26:34.800 --> 26:39.280
collections class. And then of course, he expounds on the matter, he says, this technique

26:39.520 --> 26:47.600
lends itself to interface-based frameworks, where interfaces provide natural return types

26:47.600 --> 26:52.080
for static factory methods. And of course, a good example of that is the collections framework. This

26:52.080 --> 26:58.960
class itself just going through it would prove that. Then he says, prior to Java 8, interfaces

26:58.960 --> 27:06.160
couldn't have static methods. By convention, static factory methods for an interface named type

27:06.960 --> 27:14.400
were put in a non-instantiable companion class named types. So these kind of methods

27:14.400 --> 27:20.800
had to be moved to a separate class. And then, as I said, he says, for example, the Java

27:20.800 --> 27:28.160
collections framework has 45 utility implementations of this, of its interfaces, providing unmodifiable

27:28.160 --> 27:33.840
collections, synchronized collections, and the like. Nearly all of these implementations are

27:33.920 --> 27:41.680
exported via static factory methods in one non-instantiable class, namely this right here,

27:41.680 --> 27:48.160
Java utility collections. Furthermore, using such a static factory method requires the client,

27:48.160 --> 27:53.520
which is me in this case, to refer to the return object by interface. That's what I'm doing right

27:53.520 --> 28:01.360
here. Interface rather than the implementation class, which is generally good practice. The

28:01.440 --> 28:08.480
fourth advantage is that the class of the return object can vary from call to call as a function

28:08.480 --> 28:15.280
of the input parameters. And the example he's used in the book is that in the enumset class.

28:16.960 --> 28:24.880
So let's take a look at that. What I've done here is, oh, by the way, the example I've used is,

28:24.880 --> 28:31.280
thanks to Bill Dung, I know that every Java developer out there uses this website as

28:31.360 --> 28:36.240
reference, but I know that all of us struggle to pronounce this word right here. I think it's

28:36.240 --> 28:42.320
pronounced Bill Dung. It's the best outside of the Java Oracle docs itself. It's, in my opinion,

28:42.320 --> 28:50.800
the best resource out there. So courtesy of Bill Dung for this example. So to get back to this,

28:50.800 --> 28:56.720
what does Joshua Block mean by the return object or the class or the type of the return object can

28:56.720 --> 29:02.160
vary from call to call, depending on the input of the function. So I'm using the static factor

29:02.160 --> 29:11.040
method, none of here, which is a part of the enumset class. And I'm passing a enum into it,

29:11.040 --> 29:14.800
which is this enum I created called color, which is contains about a bunch of colors.

29:16.160 --> 29:26.240
And then it returns a enumset. Now, what changes here? So what changes here really

29:26.320 --> 29:35.040
is this. In this method, you could probably see, it extends to generic. That's fine.

29:36.240 --> 29:39.520
Well, not that's fine. It has to be a generic because the types have to differ.

29:40.640 --> 29:47.040
So of course, if it's null, it'll throw a class class exception. However, you see this, the

29:47.040 --> 29:52.320
returning object, there are two types of objects that are being returned here. If the length of

29:52.400 --> 29:59.360
the enum pass, so the enum, but I'm passing colors here, if the length of this is greater than or

29:59.360 --> 30:05.760
greater than or equal to, sorry, less than or equal to 64, it'll pass a new instance or a new object

30:05.760 --> 30:14.720
of the regular enumset class. So if I run this code now, you'll probably see here, I'm printing

30:14.720 --> 30:21.920
out the class name of the return enumset. The class name is regular enumset. It's in fact a

30:21.920 --> 30:27.360
subclass, pardon me, or a subtype to be more accurate. If you look here clearly, it's of a

30:27.360 --> 30:35.040
different type. It's not the type of enumset. Now, what happens here though is if the past enum is

30:35.040 --> 30:40.320
greater than 64, it returns a different type called a jumbo enumset. So it's this flexibility

30:40.320 --> 30:45.920
that using a static factory method gives us. So to reiterate, depending on what the input is to

30:45.920 --> 30:52.320
this method, a different type can be returned. It'll vary purely based on the input. And then

30:52.320 --> 30:59.280
Joshua Bock says that clients need to know, no care about the class of the object, they get back

30:59.280 --> 31:05.680
from the factory. They care that only it is some subclass of the enumset. Correct. As far as I'm

31:05.680 --> 31:13.920
concerned, when I was using the none of method, all I wanted it to be was of the type enumset.

31:13.920 --> 31:19.360
I didn't care what subtype it was or what subclass it was. And that moves to the final

31:19.360 --> 31:25.360
justification as to why one should use static factory methods as per recent by Joshua Block.

31:25.360 --> 31:31.120
And I got to say, if you can already see from this video, I'm even struggling a bit to explain

31:31.120 --> 31:36.880
myself and properly articulate my understanding of these concepts. Perhaps that's my own lack of

31:37.600 --> 31:42.880
communication, lack of the ability to articulate myself, but also it's because I'm still dealing

31:42.880 --> 31:48.240
with issues and trying to make sense of it in my own mind. This one right here, the fifth point,

31:50.080 --> 31:56.320
it took me about a week to write the script. The fifth point, I spent four days on it because

31:57.280 --> 32:03.120
it did take a bit of understanding of the JDBC framework to see what Joshua Block is talking

32:03.120 --> 32:08.800
about here. The fifth point he tries to make is that the class of the return object need not exist

32:08.880 --> 32:14.720
when the class containing the method is written. So let me reread that. The class of the return

32:14.720 --> 32:22.560
object, whatever the method invocation returns, need not exist when the class containing the

32:22.560 --> 32:28.960
method is written. Now, firstly, he says such flexible static factory methods form the basis

32:28.960 --> 32:34.480
of service provider frameworks. I was a bit embarrassed because I've used JDBC quite a lot,

32:34.480 --> 32:38.720
but I didn't know that it was a service provider framework. I didn't know that that's what it was

32:38.800 --> 32:44.960
called until I read this book. And it's kind of funny how, by the way, I just want to make this

32:44.960 --> 32:50.480
point here. The great thing about reading such books is that all these different libraries,

32:50.480 --> 32:56.160
like all the frameworks like the collections framework or JDBC API that we use in our day-to-day

32:56.160 --> 33:02.560
job that we really don't think too much about, we start really appreciating the engineering and

33:02.560 --> 33:07.120
the kind of the craft of them once we understand the reasoning and the principles behind how they

33:07.120 --> 33:17.040
were built. So this is a good example of how JDBC is a, sorry, my mind threw a blank there,

33:17.040 --> 33:21.840
a service provider framework. So I find it a bit hard to understand the point

33:21.840 --> 33:28.960
Joshua was making using the JDBC framework. However, just to get the ideas of what it is,

33:28.960 --> 33:36.320
I put together this bit of code here. And as I read before, it's got the provider registration

33:36.320 --> 33:45.360
and the service interface. So in the startup code here, the driver manager dot, sorry, the

33:45.360 --> 33:52.080
registered driver, this bit here is the provider registration and driver is the service provider

33:52.080 --> 33:56.800
interface. And then if we go here to connection again, connection is the service interface

33:57.440 --> 34:03.440
and driver manager dot get connection is the service access API. So essentially what I'm

34:03.440 --> 34:12.880
trying to demonstrate here is the different components of what the service provider framework

34:12.880 --> 34:18.400
encompasses. And as you clearly saw, I had a terrible job at explaining how this relates to

34:18.400 --> 34:24.880
our item in using static factory methods, which is why I found a much simpler example

34:24.880 --> 34:33.280
on second of a flow where we have this right here. This was by Bruno Reyes and I thought he

34:33.280 --> 34:37.360
explained it much better. So he says here, with this code, your library doesn't need to know

34:37.360 --> 34:42.800
about the implementations of the service. Users of your library would have to set a system property

34:42.800 --> 34:49.040
containing the name of the implementation they want to use, which is if we go down here,

34:49.040 --> 34:55.440
this static factor method here, which is stored in this class will just give us a new instance.

34:56.880 --> 35:03.040
As in, I don't care if this class was created or if it exists or not, all I'm expecting is because

35:04.080 --> 35:08.720
I'm getting it through the through the contract between the interface that I'm getting a

35:09.760 --> 35:16.240
instance of the my service class. That's it. Gosh, I think I butchered that. So again, to reiterate,

35:16.800 --> 35:22.160
this static factor method for name is going to provide an instance of some class, which is

35:22.160 --> 35:28.720
the class right here. In this case, it's the driver class. And that's all I care about. I just wanted

35:28.720 --> 35:34.560
to come off this type. I'm doing a typecast here. And that's all I really care about. And that's

35:34.560 --> 35:41.520
because of this contract that I have with the interface, essentially. Okay, this is why I said

35:41.520 --> 35:46.560
that this isn't a tutorial, because that fifth item is something that I'm still struggling with.

35:46.560 --> 35:53.360
And I swear, I try to make sense of it through the JDBC framework, but it's still it was a bit

35:53.360 --> 35:58.560
hard for me to really grok. And then I found this answer on Stack Overflow, which I thought was

35:58.560 --> 36:05.280
done much better. But look, if any of you know a better way of explaining it, please do leave it

36:05.280 --> 36:10.400
down in the comment section, I would be very grateful for that, because that's certainly one

36:10.480 --> 36:14.880
advantage from this item that's still I don't I don't still fully get. So having discussed all

36:14.880 --> 36:20.640
the advantages or justifications, a proposal, using static factor methods, let's now get to the

36:20.640 --> 36:26.160
limitations. The limitations aren't really much. So it makes a lot of sense to use them in most

36:26.160 --> 36:33.520
places, unless there's an exception, let's say. The first one is that classes cannot be subclass

36:33.520 --> 36:39.680
without public or protected constructors. On the note, just before I get to demonstrating what this

36:39.680 --> 36:45.280
means, there's a good resource, sort of, I guess, an answer on Stack Overflow that I found, which

36:45.280 --> 36:51.760
discusses why constructors are needed for subclassing. And I thought it was quite good. So I'll leave

36:51.760 --> 36:56.720
a link to this in the description down below too, if you want to go give it a read. But simply,

36:56.720 --> 37:05.200
it's very easy to show. So here I have a class called main. And then I have one class, which is

37:05.200 --> 37:12.640
another another class called animal with constructor. So if I go to that right here,

37:13.840 --> 37:18.320
here we have the public class. And we have a public constructor, as you can see here,

37:18.320 --> 37:29.360
now I can easily go to the main class and type extends animal.

37:34.880 --> 37:40.800
There we go. And it simply extends that class. However, now I have another class without a

37:40.800 --> 37:46.400
constructor. In fact, I've made the constructor private. So it's not accessible by the by the

37:46.480 --> 37:53.600
subclasses. And if this tries to extend this, and it raised wrong, it says here,

37:53.600 --> 38:00.320
there is no default constructor available in the superclass. So and also if I try to create

38:00.320 --> 38:04.080
an instance of this, we get the same error. What's funny here, though, is of course,

38:05.600 --> 38:11.760
Joshua Block says, and I'll read this out. Arguably, this can be a blessing in disguise,

38:11.760 --> 38:16.240
because it encourages programmers to use composition instead of inheritance.

38:16.960 --> 38:22.640
Exactly. I don't have to extend that class. I can use one of the most fundamental OOP

38:22.640 --> 38:30.320
design principles to try and favor composition over inheritance. The second limitation is that

38:30.320 --> 38:35.360
he says, I don't even really know what he means here, that it's hard for programmers to find that

38:35.360 --> 38:41.280
these methods are hard to allocate. I'm not sure if that really applies anymore, because with,

38:41.360 --> 38:47.280
for instance, I use IntelliJ with really powerful exhaustive ideas like IntelliJ,

38:47.280 --> 38:51.920
all I got to do is hit command and click on the method and boom, I'm there. I've got the docs,

38:51.920 --> 38:56.080
everything I need. So I wouldn't say it's hard for programmers to find. Nevertheless,

38:56.080 --> 39:02.800
he does state that. So I'm sure there's a good reason for it. And then what he says is because

39:02.800 --> 39:06.560
some of these static factor methods are hard for them to find that he's going to

39:07.120 --> 39:11.360
enumerate a few of them and list down some commonly used static factor methods.

39:11.360 --> 39:15.360
So I thought I'd do the same. And once again, all of this code is going to be on get up. So if you

39:15.360 --> 39:20.480
want to take a look at some of these methods, just click the link down below and you'll have

39:20.480 --> 39:29.120
access to it. So the first one is a from method, which does a, it's essentially a type conversion

39:29.120 --> 39:36.080
method. So it's quite easy to understand really what we have here is we have a type of instance,

39:36.080 --> 39:42.160
and we pass it to, to, to the date. And from, from that instance, we get a type of date. So

39:42.160 --> 39:50.320
it does a type conversion. If I run that code, you'll see that that instance type was converted

39:50.320 --> 39:56.480
to a date type. And then it printed it down here. The second one is a aggregation method.

39:56.480 --> 40:02.000
What this does is similar to a previous example that I use, is it takes this enum list. So I've

40:02.000 --> 40:11.440
got a enum, uh, cold rank here, Jack, Queen, King. And then it just gives us a set, an enum set of,

40:11.440 --> 40:14.560
of this enum right here. So if I do print that out,

40:17.040 --> 40:22.400
you can see here it's printing that set under face cards. So it makes sense to call it an

40:22.400 --> 40:27.760
aggregation method. Cause what it does is it takes all these different items in an enum,

40:27.760 --> 40:34.800
enum class, and then aggregates them and returns a type of enum set. And then we have the big integer

40:34.800 --> 40:39.680
value of, which again, this is the same thing. It's a type conversion method. Uh, and he says,

40:39.680 --> 40:46.160
yeah, it's a verbose alternative to, to from and off. So in this example, you could probably see

40:46.160 --> 40:52.080
I'm passing into this method, uh, something of type integer, and it returns something of type

40:52.080 --> 40:57.040
big integer. So it does that type conversion there. The next example is, uh, it's sort of like

40:57.040 --> 41:02.800
I've created a quasi demo for this get instance methods. Essentially what it does is that it's

41:02.800 --> 41:09.280
described, uh, it returns an instance that is described by its parameters, if any, but cannot,

41:09.280 --> 41:15.760
but cannot be said to have the same value. So the example here would be, I've got this void method

41:15.760 --> 41:24.000
called method three, and this stack walker class here is getting an instance of the, uh, class,

41:24.000 --> 41:30.320
this class that invocates this method. So here is, this is in the stack walker demo class.

41:30.320 --> 41:38.880
And as you can see, if I go up here, there's an instance, uh, oh, that was a mistake. I should

41:38.880 --> 41:45.120
have, I wonder, I should have made that a static method. I don't know why I, let me correct that

41:45.120 --> 41:56.800
right now. Public static. That is good because it shouldn't be a, sorry, that was a confusion.

41:56.800 --> 42:02.640
The actual static factory method was this in the stack walker class to get instance class.

42:02.640 --> 42:07.840
This is what happens when I work on these things way back and I record the video on a separate day.

42:07.840 --> 42:12.800
Sometimes even I forget why I did what I did, but just to get back to this. So I've created

42:12.800 --> 42:18.800
the stack walker demo class and I've created an instance of it right here, which is boom.

42:19.680 --> 42:23.600
And I'm accessing this method through the object or the instance of that class.

42:24.800 --> 42:29.200
And what this is really is, it just prints out the caller class. So the stack walker

42:29.200 --> 42:35.680
dot get instance, as you can see here, it prints, it gives us a reference to the class that invoked

42:35.680 --> 42:41.680
this method. So method three was, method three was invoked by this class here,

42:42.800 --> 42:48.240
the common static factory methods class. So if I print this out, you'll see here,

42:50.320 --> 42:56.800
it tells us, huh, this was the class that invoked this method and it's using the get instance

42:56.800 --> 43:01.760
static factory method. And the next example is quite similar. The new instance method will

43:01.760 --> 43:09.520
guarantee that every invocation of it will return a instance of the string dot class here, the class

43:09.520 --> 43:17.680
that I've specified here. So I'm passing an array and then I'm also passing the type of the class

43:17.680 --> 43:26.000
here. In fact, let me just go to that method. It takes these parameters as shown here, it takes the

43:26.960 --> 43:32.880
yes, the component type, the type of the class, it's a generic, and then the length of the array.

43:32.880 --> 43:36.640
That's what this does. And if I print that out here, it just prints out the type of the class

43:36.640 --> 43:41.040
you can see here. It's just a string class that I've passed through. And then the get type static

43:41.040 --> 43:46.560
factory methods are similar to the example, not this example, the previous one with the stack

43:46.560 --> 43:53.680
walker demo class that we, with the get instance demo there. What this does is it returns a different

43:53.680 --> 43:58.640
type, essentially. So if you look at this here, I'm getting a path, I've got a file that I've

43:58.640 --> 44:08.960
created. And if I go to the files class, it's of type files, obviously. And then this get files

44:08.960 --> 44:18.160
to static factory method returns a different type. It returns a type of file store, despite being

44:18.160 --> 44:22.880
in the class files. And if you look at the method, you'll see, I'll zoom in there again,

44:24.320 --> 44:30.400
the get file store, it's in a separate abstract class called get file store. Pardon me, it's in

44:30.400 --> 44:36.880
a separate abstract class called file store. So it's not in the files class. And similarly,

44:36.880 --> 44:42.320
the buffered reader does the same thing, but instead of getting a new instance, it creates a

44:42.320 --> 44:47.520
new instance. So if you go to the buffered reader, which again is in the files class,

44:47.600 --> 44:51.920
if you go to the static factory method, it is returning a new instance of,

44:54.480 --> 45:00.400
whoa, that's a bit weird. Oh, of course, of buffered reader. There we go. And of course,

45:00.400 --> 45:04.720
similarly, the new type, this is the same thing, but instead of getting an instance,

45:04.720 --> 45:11.360
it'll return a new instance. So if you go to the new buffered reader static factory method, which is

45:11.360 --> 45:17.360
in the files class, by the way, as you can see here, it returns a new instance of buffered reader.

45:17.520 --> 45:22.800
Again, it's a different type or to what what files is, or it's in a different class, let's say.

45:22.800 --> 45:28.480
And finally, really, all the other stuff won't even that useful because, well, they are useful,

45:28.480 --> 45:34.480
but I think most of us use this, the generics, which is in the collections, things like less

45:34.480 --> 45:42.640
area lists, which I'm in the collections framework. And what this does is it returns a new vector

45:42.640 --> 45:50.880
of a given type. So for instance, I've created this enum called complaint, and I can create a list

45:50.880 --> 45:56.720
of that type and add stuff into it, essentially. And if you want to see, it's going to print all

45:56.720 --> 46:03.680
that stuff. All these examples that I've used was sort of in the book, and I repurposed them

46:04.480 --> 46:09.040
just for me to understand. But really, from all the static factory methods I went through,

46:09.040 --> 46:14.000
I think the ones we use mostly are the ones in the Java collections framework. Nevertheless,

46:14.000 --> 46:19.520
it's important to enumerate all of them. And in summary, Joshua Block says, static

46:19.520 --> 46:24.640
factor methods and public constructors both have their uses, and it pays to understand their

46:24.640 --> 46:31.840
relative metrics. Often, static factor methods are preferable. So avoid the reflex to provide

46:31.840 --> 46:34.720
public constructors without first considering static factories.

46:34.960 --> 46:42.400
That was much harder than I thought. I have to admit, I thought I could sort of go through my

46:42.400 --> 46:47.840
thought process, but you know, any programmer would understand that sometimes we don't even

46:47.840 --> 46:51.920
know what we do, what we do, we just type and things just happen. That's fascinating, isn't

46:51.920 --> 46:58.000
it? In any case, I hope you enjoyed the video. I hope you found it informative. I certainly,

46:58.000 --> 47:03.280
as I said in the proviso middle, I'm sure I've made a lot of mistakes, so please do point them out.

47:03.280 --> 47:07.840
In some sense, selfishly speaking, for my own learning, but also so that I don't

47:11.040 --> 47:17.760
mislead anyone and provide false information. I've already started working on the next item.

47:17.760 --> 47:25.040
I'm still rereading that item and starting the different examples. The second item is

47:25.040 --> 47:31.760
consider a builder when faced with many constructor parameters. I shall hopefully get to that soon,

47:31.760 --> 47:37.360
but at least for now, I hope you enjoyed this item and I'll see you in the next one. Cheers.

