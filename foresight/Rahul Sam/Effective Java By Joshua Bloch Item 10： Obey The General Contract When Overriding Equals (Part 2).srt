1
00:00:00,000 --> 00:00:06,800
Hey, everyone, welcome to part two of item 10, obey the general contract when overriding

2
00:00:06,800 --> 00:00:13,840
equals of Joshua Bloch's effective Java. Needless to say, please do watch part one to

3
00:00:13,840 --> 00:00:18,800
make sense of this item, because it's just a follow on from from part one. And I'll be

4
00:00:18,800 --> 00:00:22,160
working down this item into multiple parts, because it's quite long. But without further

5
00:00:22,160 --> 00:00:26,960
ado, let's get started, because this is quite a long part. So in the previous part, we discussed

6
00:00:27,920 --> 00:00:35,600
when it's appropriate or warranted to not override the equals method. Generally, it's always a good

7
00:00:35,600 --> 00:00:42,720
idea to override the equals method. However, there are certain instances where it's not required.

8
00:00:42,720 --> 00:00:48,000
And we discussed that in part one. And in part two, today, we're primarily going to focus on

9
00:00:48,000 --> 00:00:53,360
when is it appropriate to override the equals method. And afterwards, kind of kind of gonna,

10
00:00:53,360 --> 00:00:58,320
we're gonna go into detail as to what the general contract is. So firstly, I propose when it's

11
00:00:58,320 --> 00:01:05,120
appropriate to override the equals method, Joshua Bloch states, it's appropriate when a class has

12
00:01:05,120 --> 00:01:12,960
a notion of logical equality that differs from mere object identity, and a superclass has not

13
00:01:12,960 --> 00:01:18,560
already overridden equals. So we did discuss what logical equality was in the previous part.

14
00:01:19,120 --> 00:01:24,960
But for all intents and purposes, as a Java programmer, what we care about is

15
00:01:26,480 --> 00:01:31,680
in logical equality, a programmer doesn't care about the memory reference or the

16
00:01:31,680 --> 00:01:37,120
the quality of the object per se, but rather the content or the value of an object.

17
00:01:37,120 --> 00:01:42,080
The easiest way to put that is by looking at classes such as string or integer, where if we

18
00:01:42,080 --> 00:01:51,280
take, in fact, string, string objects are immutable. So there's only one object of this type that exists

19
00:01:51,280 --> 00:01:57,600
in memory and everything else will point to that. So in this context, when it comes to logical

20
00:01:57,600 --> 00:02:03,760
equality, what we care about really isn't the object per se, whatever the data of that object is,

21
00:02:03,760 --> 00:02:10,000
however, the value of the object. So we should only care about this bit here. And that means

22
00:02:10,000 --> 00:02:14,240
it's logical equality. So if you have string s, and then we also have, let's say,

23
00:02:17,680 --> 00:02:18,400
that was a mistake,

24
00:02:21,680 --> 00:02:28,560
a string b, let's say, both these strings, s and b, have logical equality because the content is the

25
00:02:28,560 --> 00:02:35,440
same. So these classes have a notion of logical equality. And then he states, not only is overriding

26
00:02:35,440 --> 00:02:42,480
the equals method necessary to satisfy programmer expectations, it enables instances to serve as

27
00:02:42,480 --> 00:02:49,440
map keys or set elements with predictable, desirable behavior. And then he adds an ancillary point

28
00:02:49,440 --> 00:02:56,000
saying that enums or enum objects are an exception to this value class heuristic,

29
00:02:56,000 --> 00:03:00,160
I coined that term value class heuristic, he doesn't really use that term. But I feel like

30
00:03:00,160 --> 00:03:06,880
to understand the concept of logical equality, apropos Java programming, that is a good heuristic

31
00:03:06,880 --> 00:03:13,280
to keep in mind. So enums, though, are an exception. That's what he states. And just to get some

32
00:03:13,280 --> 00:03:19,360
formalities out of the way, let's say, according to the Java language specifications 8.9,

33
00:03:20,320 --> 00:03:27,760
here's how an enum is defined. An enum type has no instances other than those defined by its enum

34
00:03:27,760 --> 00:03:34,480
constants. It is a compile time error to attempt to explicitly instantiate an enum type. The final

35
00:03:34,480 --> 00:03:40,800
clone method in enum ensures that enum constants can never be cloned. And the special treatment

36
00:03:40,800 --> 00:03:47,440
by the serialization mechanism ensures that duplicate, duplicate instances are never created

37
00:03:47,440 --> 00:03:55,120
as a result of deserialization. Reflective instantiation of so that's from the Java

38
00:03:55,200 --> 00:04:01,680
Reflections API. Reflective instantiation of enum types is prohibited. By the way, what that API,

39
00:04:01,680 --> 00:04:09,840
the Reflections API does is it changes the structure of classes on runtime. It is not something

40
00:04:09,840 --> 00:04:16,720
a normal Java programmer would do. It's mostly used by framework designers. So I've never used

41
00:04:16,720 --> 00:04:21,680
the Reflections API, but it's just good to keep good to keep in mind what it does. Anyway, getting

42
00:04:21,680 --> 00:04:26,960
back to the definition, sorry for interrupting it. Reflective instantiations of enum types is

43
00:04:26,960 --> 00:04:33,200
prohibited. Together, these four things ensure that no instances of an enum type exist beyond

44
00:04:33,760 --> 00:04:43,040
those defined by the enum constants. And again, attending to our point, it's for these classes,

45
00:04:43,040 --> 00:04:49,840
so enums, logical equality is the same as object identity. So objects equals method functions as

46
00:04:50,640 --> 00:04:56,640
logical equals method. What that would mean really is, if let's say this S and B were enums,

47
00:04:59,200 --> 00:05:05,840
if the objects were identical, we could say for all intents and purposes, there's also logical

48
00:05:05,840 --> 00:05:12,720
equality. So here's a small demo. Let's take a look at it that I put together. So I have two enums

49
00:05:12,720 --> 00:05:20,160
here. Day and day two both have days of a week. Now, if I do run this, it's going to print false

50
00:05:20,160 --> 00:05:26,720
because there's no logical equality in this case because there's no object identity. However,

51
00:05:26,720 --> 00:05:38,800
let's say I create two instances of day. Day dot, was it Monday? Yeah. And then I'll also create

52
00:05:38,880 --> 00:05:48,000
another day two with the same thing, with the same day. You'll see here, if I print this out,

53
00:05:48,000 --> 00:05:53,520
if I do compare these two objects, it'll print true because the logical equality here

54
00:05:54,160 --> 00:05:59,520
equates to the object identity. So I'll just go day one,

55
00:06:00,080 --> 00:06:06,560
day two. I'll comment that out. You'll see a true being printed now.

56
00:06:10,880 --> 00:06:16,720
That's it. So the object identity equates to the logical equality. And that makes sense.

57
00:06:17,440 --> 00:06:20,640
So reiterating that point, so the idea really settles in our mind,

58
00:06:22,240 --> 00:06:28,960
overriding the equals method is required or is appropriate when logical equality

59
00:06:28,960 --> 00:06:34,480
differs to object identity. Now, I accept the enums class, of course. Whenever we know that

60
00:06:34,480 --> 00:06:41,520
object identity is not equate to logical equality, override the equals method. And that gets us to

61
00:06:41,520 --> 00:06:47,600
the general contract when overriding the equals method. And that's what we're going to discuss

62
00:06:47,600 --> 00:06:52,640
for the rest of this part. And in fact, the next part too. And there's a lot to get into here.

63
00:06:52,640 --> 00:06:57,120
All right, before we get to the properties that define this general contract, I need to skip ahead

64
00:06:57,120 --> 00:07:02,880
a bit and read a caveat that Joshua Block has put in. Because in fact, I wish you would have put

65
00:07:02,880 --> 00:07:08,080
that bit earlier before getting to the properties because the caveat is a good starting point

66
00:07:08,080 --> 00:07:12,400
in understanding these properties. Because it's really important that we don't ignore them.

67
00:07:13,280 --> 00:07:20,400
They can be a bit overwhelming to understand. Nevertheless, ignoring them isn't the solution.

68
00:07:20,400 --> 00:07:25,440
It's enduring through and assisting and trying to make sense of them and implementing them in our

69
00:07:25,440 --> 00:07:31,840
code. So here's a caveat Joshua Block has put in. Unless you are mathematically inclined,

70
00:07:31,840 --> 00:07:37,600
this might look a bit scary. So what he means by that is the properties that he listed down or

71
00:07:37,600 --> 00:07:45,120
enumerated. But do not ignore it. So don't ignore these properties. If you violate it, you may well

72
00:07:45,120 --> 00:07:52,080
find that your program behaves radically or crashes. It can be very, very difficult to pin down

73
00:07:52,080 --> 00:07:58,560
the source of the failure. To paraphrase John Donne, is that how you pronounce his surname?

74
00:07:58,560 --> 00:08:07,280
D-O-N-N-E. John Donne, probably. No class is an island. Instances of one class are frequently passed

75
00:08:07,280 --> 00:08:15,360
to another. Many classes, including all collections classes, depend on the objects passed to them

76
00:08:15,360 --> 00:08:21,360
obeying the equals contract. Just on that point, there's a really interesting kind of philosophy

77
00:08:21,360 --> 00:08:27,600
in object-oriented programming. And I think even Alan Kay, the inventor of OOP, he makes this idea

78
00:08:27,600 --> 00:08:36,480
that I'm going to get a book. I was reading this book by Sandy Metz, which is a book on

79
00:08:36,480 --> 00:08:43,520
object-oriented design, but using Ruby. And what she states in this book is that it's better to

80
00:08:43,520 --> 00:08:50,960
conceptualize object-oriented programming more as message-oriented programming. And even Alan

81
00:08:51,040 --> 00:08:57,040
Kay, I believe, said in one of his talks that he wished that people emphasize the importance of

82
00:08:57,040 --> 00:09:02,880
messages between objects than objects themselves, which is the point that Joshua Blocks making here,

83
00:09:03,520 --> 00:09:12,240
all these contracts, all these properties that define these contracts that we ought to respect

84
00:09:12,240 --> 00:09:17,760
and take into account when writing code, they're more about the messages and how objects communicate

85
00:09:17,760 --> 00:09:23,440
with each other. Therefore, it requires a bit of a change of mindset. In any case, I don't want to

86
00:09:23,440 --> 00:09:28,880
get too carried away, but I thought that was an important point to add on to what we're discussing

87
00:09:28,880 --> 00:09:35,280
here. So given that we've got that caveat slash warning out of the way, let's get to the specifications

88
00:09:35,280 --> 00:09:42,400
for the contract. The equals method implements an equivalence relation. It has these properties.

89
00:09:42,400 --> 00:09:48,880
So there are six properties, sorry, five properties. And in this part, we're going to discuss three of

90
00:09:48,880 --> 00:09:58,080
them, especially because symmetry, sorry, not symmetry, transitivity is quite a loan property

91
00:09:58,080 --> 00:10:04,320
and there's a lot to discuss there. So, and then in part three, we'll discuss consistency and

92
00:10:04,320 --> 00:10:11,920
non-nullity. However, that's later on. Let's stay on track here. So what is

93
00:10:11,920 --> 00:10:17,440
equivalence relation? And what does it mean to have equivalence relation between two sets?

94
00:10:18,080 --> 00:10:24,240
Look, Joshua Bloch puts it best. Here's what he states. Lucy speaking, so this is pertaining

95
00:10:24,240 --> 00:10:31,680
to equivalence relation, which the equals method implements. It's an operator that partitions a

96
00:10:31,680 --> 00:10:39,600
set of elements into subsets whose elements are deemed equal to one another. These subsets are

97
00:10:39,680 --> 00:10:47,200
known as equivalence classes. For an equals method to be useful, all of the elements in such

98
00:10:47,200 --> 00:10:53,680
equivalence class must be interchangeable from the perspective of the user. Sorry about that

99
00:10:53,680 --> 00:10:58,560
background noise. It gets so annoyed by this because I live in a very quiet neighborhood,

100
00:10:58,560 --> 00:11:05,520
but every time I record a bloody video, there's some noise outside. In any case,

101
00:11:05,680 --> 00:11:12,960
so what he means by for an equals method to be useful, all of the elements in each

102
00:11:12,960 --> 00:11:17,440
equals class must be interchangeable from the perspective of the user means again,

103
00:11:17,440 --> 00:11:22,720
going back to the string, from the perspective of the user, both these objects have logical

104
00:11:22,720 --> 00:11:29,840
equality and that's what necessitates equivalence relation. Saying that, let's get to the first

105
00:11:29,840 --> 00:11:37,360
item or the the first property that pertains to the general contract. Oh gosh, man.

106
00:11:38,960 --> 00:11:44,640
The noise is not ending. Is that a leaf blower or lawn mower? What the hell is it?

107
00:11:46,960 --> 00:11:53,280
Okay, part and parcel of living in a suburb. Hey, look, I look, I'm not complaining though,

108
00:11:53,280 --> 00:11:58,640
it's way better than the city. Ah, it ended. No, it didn't. I'm just gonna wait till it ends.

109
00:12:00,080 --> 00:12:08,880
I think it ended. Back to it. So, reflexivity. Ah, he's starting. Dude, the guy's trolling me.

110
00:12:08,880 --> 00:12:12,640
The guy's trolling me. You know what? I can't, I can't do this. We're just gonna keep going.

111
00:12:13,360 --> 00:12:19,440
I apologize about the background noise. So, starting off with the first property, reflexes.

112
00:12:20,800 --> 00:12:27,680
See, I got distracted. Reflexivity. Okay, what does that mean? What does reflexivity mean? I've

113
00:12:27,680 --> 00:12:33,840
got to be really flexible here right now. So, that means for any non-null reference,

114
00:12:33,840 --> 00:12:41,360
value x should equate to x. So, it's saying that an object x should be equal to itself,

115
00:12:41,360 --> 00:12:47,920
which kind of seems self-evident. So, if we have a x equals x, it must return true.

116
00:12:49,760 --> 00:12:53,840
Which is why, which is why Joshua Bloch states, the first requirement, say, is merely that an

117
00:12:53,840 --> 00:12:59,440
object must be equal to itself. It's hard to imagine violating this one unintentionally.

118
00:12:59,440 --> 00:13:04,320
If you were to violate it and then add an instance of your class to a collection,

119
00:13:04,320 --> 00:13:09,920
the contains method might well say that the collection didn't contain the instance that

120
00:13:09,920 --> 00:13:15,040
you just added. So, let's take a look at a quick demo, because obviously code makes more sense

121
00:13:15,040 --> 00:13:21,040
than theory, even though we are, I personally always like starting with theory, because it

122
00:13:21,120 --> 00:13:28,400
really helps to start high level. Where is this? So, if we go to reflexivity,

123
00:13:29,440 --> 00:13:38,880
it's really simple as this. So, I have a list of strings here, and what we're doing is we're

124
00:13:38,880 --> 00:13:46,640
adding the word Java into that list. So, it's a set, let's say, it's a string, and if you run this,

125
00:13:46,640 --> 00:13:53,040
it'll return true, because we're just checking if this set, this list, contains, using the

126
00:13:53,040 --> 00:13:58,240
contains method that's in the, using the, sorry, I bit my tongue, using the contains method in the

127
00:13:58,240 --> 00:14:04,320
object class. It's checking if Java exists in that list, and obviously it does. That's pretty much

128
00:14:04,320 --> 00:14:10,800
what reflexivity is. So, the next, if I have a hard word for me to pronounce. So, the next one is

129
00:14:10,800 --> 00:14:17,120
symmetry. So, symmetry states, again, for any non-null reference values x and y, so we have

130
00:14:17,120 --> 00:14:25,120
two objects in this case, x equals y must return true, if and only if y equals x returns true.

131
00:14:25,120 --> 00:14:29,680
So, again, going back to, I'm going to demo it in a bit, but going back to this here,

132
00:14:30,640 --> 00:14:36,480
s, s and b, so string s, so string s, if we take this,

133
00:14:39,360 --> 00:14:51,120
equals b. This should return true only if b dot equals s returns true.

134
00:14:53,440 --> 00:14:58,320
So, that's what symmetry is. And before we get to the demo, let's just read out this bit,

135
00:14:58,320 --> 00:15:02,960
just should look at stated. The second requirement says that any two objects

136
00:15:02,960 --> 00:15:08,400
must agree on whether they are equal. Unlike the first requirement, it's not hard to imagine

137
00:15:08,400 --> 00:15:14,320
violating this one unintentionally. So, we have this class here called case and sensitive string,

138
00:15:14,320 --> 00:15:20,960
and it's an attempt to implement a case and sensitive string class. In the class, what we have is we

139
00:15:20,960 --> 00:15:27,840
have a private final string s variable. We have the constructor, which in this case just

140
00:15:28,800 --> 00:15:36,320
checks if the object is non-null, if it is null, it returns a chosen error, and then it sets that

141
00:15:36,320 --> 00:15:42,960
value in our private field here in the class. And then we have the equals method that we have

142
00:15:42,960 --> 00:15:48,640
overridden, which breaks symmetry. So, firstly, I'll show the one, but the problem, I'll show

143
00:15:49,600 --> 00:15:53,360
the wrong way to do it. And then we also have another equals method written

144
00:15:54,000 --> 00:16:00,000
below here, which is the proper way to do it. And that'll fix the issue. So, let's take a look at

145
00:16:00,000 --> 00:16:06,000
this equals method that we've overridden. So, we have two if conditions here in the equals method.

146
00:16:06,000 --> 00:16:12,560
In the first one, what we're checking is if this object v pass is an instance of the case

147
00:16:12,560 --> 00:16:17,360
in sensitive class. So, that's what we're checking here using the instance of method. And if it is,

148
00:16:17,360 --> 00:16:25,520
then it'll just return true if that. So, firstly, we cast that object into case in sensitive string.

149
00:16:25,520 --> 00:16:31,440
If it is an instance of that, let's say a subclass of that, then we cast it to become a

150
00:16:31,440 --> 00:16:37,600
case in sensitive string. And then we compare it to our string field really that we defined here

151
00:16:37,600 --> 00:16:43,920
in line number 15. And if it is equals in that case, we return true. And that's fine. That's

152
00:16:43,920 --> 00:16:50,160
going to work. But then we're trying to go one step further and attempting to make this interoperable

153
00:16:50,160 --> 00:16:56,720
with a string class. So, again, the same way we're checking if this past object is an instance of

154
00:16:56,720 --> 00:17:05,440
the string class. And then we are saying return true if it's equal to a string. And we just cast

155
00:17:05,440 --> 00:17:11,200
it accordingly. And this is what breaks the symmetry. And I'll show you what that means.

156
00:17:11,200 --> 00:17:16,960
And of course, this line here, if it doesn't meet all these conditions, it'll return false.

157
00:17:16,960 --> 00:17:21,120
So, in the public static void main, what I have is I have an instance of

158
00:17:21,120 --> 00:17:28,000
case in sensitive string. And then I have another normal string instance. What we're doing initially

159
00:17:28,000 --> 00:17:34,480
is we're checking if this case in sensitive string is equal to s. And that will return

160
00:17:34,480 --> 00:17:39,520
true as expected because we're passing the word Polish here, the string Polish, and the string

161
00:17:39,520 --> 00:17:46,640
itself has Polish. And even though the first letter is uppercase, and here it's not uppercase,

162
00:17:46,640 --> 00:17:52,080
it's lowercase, it doesn't matter because this equality, what we're doing, the logical equality,

163
00:17:52,640 --> 00:17:57,280
what we care about is for it to be case in sensitive. We don't care about the case.

164
00:17:58,160 --> 00:18:04,960
But here, this is where the symmetry is violated. Because we are attempting in I equals method

165
00:18:05,920 --> 00:18:14,560
for this to be interoperable with normal strings, we're doing the comparison the other way around

166
00:18:14,560 --> 00:18:22,960
instead of comparing sys with s, we're comparing s with sys, and this returns false. Furthermore,

167
00:18:22,960 --> 00:18:30,880
if we add this string, I don't want to call it a string because it's a case in sensitive string,

168
00:18:31,840 --> 00:18:38,160
into a list of type case in sensitive string, it's a bit of a mouthful. And be printed, we

169
00:18:38,160 --> 00:18:43,760
expect this to return true, but it doesn't, it returns false. So that again demonstrates the

170
00:18:43,760 --> 00:18:50,240
violation of symmetry because the contains method uses the concept of logical equality,

171
00:18:50,240 --> 00:18:56,400
and we don't have logical equality here. So if I do run this, you'll see it'll return true false

172
00:18:56,880 --> 00:19:08,400
false. Right there. So this is the problem. Now, before I get to the fix, let me read out

173
00:19:08,400 --> 00:19:13,760
to put it a bit more formally and cleanly what Joshua Bloch has stated. He states,

174
00:19:14,640 --> 00:19:23,120
as expected, so he's referring to this bit here, as expected, sys dot equals s returns true.

175
00:19:24,000 --> 00:19:28,880
The problem is that while the equals method in case in case in sensitive string

176
00:19:29,520 --> 00:19:36,960
knows about ordinary strings, the equals method in string is oblivious to case in sensitive strings.

177
00:19:36,960 --> 00:19:42,960
So that is the equals method that we're going to use here in this slide that we use.

178
00:19:42,960 --> 00:19:53,840
Therefore s dot equals says returns false. So he's referring to that bit here now where it

179
00:19:53,840 --> 00:20:00,240
returns false. A clear violation of symmetry, suppose you put a case in sensitive string into

180
00:20:00,240 --> 00:20:04,640
a collection. So that's where moving on to the next bit here, which we again see that it's

181
00:20:04,640 --> 00:20:09,360
returning false. And this is a bit difficult to understand because here's what Joshua Bloch

182
00:20:09,360 --> 00:20:14,080
states on the contains method. Now, I was under the, well, I guess my assumption is right. My

183
00:20:14,080 --> 00:20:20,240
assumption was that because this violates the equals contract and the idea of logical equality

184
00:20:20,880 --> 00:20:28,560
and the contains method use ensures that objects that it gets respect this contract.

185
00:20:29,520 --> 00:20:34,320
It acts accordingly. Therefore why it's printing false here or it's returning false here.

186
00:20:34,320 --> 00:20:40,160
But here's what Joshua Bloch states. And I think my assumption is at least quasi accurate.

187
00:20:41,520 --> 00:20:47,600
What does list dot contains s return at this point? And then he says, who knows? In the current

188
00:20:47,600 --> 00:20:52,320
open JDK implementation, it happens to return false. So that's what we saw here. The third

189
00:20:52,320 --> 00:20:58,480
false is by this list dot contains. But that's just an implementation artifact. In another

190
00:20:58,560 --> 00:21:04,240
implementation, it could just as easily return true or throw a runtime exception.

191
00:21:05,280 --> 00:21:12,160
Once you violated the equals contract, you simply don't know how other objects will behave

192
00:21:12,160 --> 00:21:18,800
when confronted with your object. To eliminate the problem, merely remove the ill-conceived

193
00:21:18,800 --> 00:21:22,880
attempt to interoperate with string from the equals method. I shouldn't have read that part yet.

194
00:21:22,880 --> 00:21:27,120
I'll read that again, but that's how we fix the problem. So I'm going to read that bit again,

195
00:21:27,200 --> 00:21:33,600
though. Once you violated the equals contract, you simply don't know how other objects will behave

196
00:21:34,240 --> 00:21:40,480
when confronted with your object. This goes back to the idea I touched on a bit before by

197
00:21:40,480 --> 00:21:47,680
Sandy Metz on the book I was referring to, the Ruby book, that it's probably the best way to

198
00:21:47,680 --> 00:21:55,520
think about OOP is in the context of messages and how objects interact with each other over

199
00:21:55,600 --> 00:22:02,480
objects because objects aren't an island as we read from John Dunn. So that's what happens here.

200
00:22:02,480 --> 00:22:08,640
The contains method makes a lot of assumptions and those assumptions are wrong because, well,

201
00:22:08,640 --> 00:22:12,320
the assumptions aren't really wrong, but we've made a mistake in our object.

202
00:22:12,320 --> 00:22:18,160
Therefore, it breaks things. There's no logical equality. Now, getting back to how we fix this,

203
00:22:18,160 --> 00:22:24,160
as I did read that line, which I shall reread, it's simply ensuring that we don't

204
00:22:24,160 --> 00:22:29,680
try and attempt for the case in sensitive string objects to interoperate with string objects.

205
00:22:29,680 --> 00:22:34,880
And the way we do that is, I'm going to comment out this equals method because we can't have

206
00:22:34,880 --> 00:22:39,840
two equals method in the same class equals methods in the same class, unless it's overloaded.

207
00:22:42,320 --> 00:22:47,120
And then I'm going to get the other equals method, which doesn't attempt to override.

208
00:22:47,760 --> 00:22:48,400
Oops.

209
00:22:51,440 --> 00:22:56,960
Doesn't attempt to not override to interoperate with strings. It simply checks if it's an

210
00:22:56,960 --> 00:23:02,080
instance of case in sensitive string and then casts the case in sensitive string and just

211
00:23:02,080 --> 00:23:10,160
the normal equals ignoring the case. So now, if I run this bit here,

212
00:23:10,560 --> 00:23:17,280
you'll see I'm going to comment out these lines because they're, in fact, actually, no, maybe

213
00:23:17,280 --> 00:23:24,800
what I should do is I'm going to go and run the whole thing. And now the first three are printing

214
00:23:24,800 --> 00:23:29,920
faults and we expect it to print faults. We want it to because we don't want any interoperability

215
00:23:31,040 --> 00:23:37,040
with strings. And then in the second one, we're checking if it's equals and we're seeing if sys

216
00:23:37,040 --> 00:23:44,000
equals this new string we've created, again, Polish. And then we're checking if sys equals

217
00:23:45,040 --> 00:23:50,640
the other way around. We're checking for the symmetry. So you can see here in line number 53,

218
00:23:50,640 --> 00:23:57,280
it's uppercase p. And in line number, oh, that's a mistake, actually. That should have been lower case.

219
00:23:58,560 --> 00:24:06,480
Now, we can truly demonstrate the point. So if it's lower case here, line number 37,

220
00:24:06,800 --> 00:24:14,080
it's still ignoring that and printing true in these two lines. So line number 54, 55,

221
00:24:14,080 --> 00:24:20,720
correlate to these second true statements. I hope that made sense. So rereading what

222
00:24:20,720 --> 00:24:26,800
Joshua Bloch wrote, to eliminate the problem, merely remove the ill-conceived attempt to

223
00:24:26,800 --> 00:24:32,240
interoperate with string from the equals method. And now we move to the longest property from

224
00:24:32,240 --> 00:24:37,760
all the ones that Joshua Bloch has enumerated. And I had to take a smaller break just to

225
00:24:37,760 --> 00:24:43,440
refresh myself because this property is four or five pages. So there's a bit to go through.

226
00:24:44,800 --> 00:24:51,520
But let's get started. You know, the only way to get started is to get started. Wow, brilliant,

227
00:24:51,520 --> 00:24:58,720
brilliant. So what does this transitivity property states? Some of these words are a bit

228
00:24:58,720 --> 00:25:06,080
hard to pronounce. It's not going to lie. It states transitivity states, for any non-null reference,

229
00:25:06,080 --> 00:25:15,920
values x, y and z, if x equals y returns true and y equals z returns true, then x equals z

230
00:25:17,200 --> 00:25:25,360
must also return true. Or simply it's that if we have three objects with the content being

231
00:25:25,360 --> 00:25:31,120
same, three string objects, let's say, they should all print true when compared to each other.

232
00:25:31,920 --> 00:25:38,400
Simple as that because we require the logical equality there. Now, before we get to the demos

233
00:25:38,400 --> 00:25:45,280
and we demonstrate how this can go wrong and how to fix it, and even in fact some inherent

234
00:25:45,280 --> 00:25:51,600
flaws with Java and object-oriented programming, we got to get some theory out of the way.

235
00:25:52,560 --> 00:25:59,920
So should I read this out first? Let me think. Okay, I'll first read out a bit of like an

236
00:25:59,920 --> 00:26:04,320
introduction to this property from the book. Here's what Joshua Block states.

237
00:26:04,320 --> 00:26:10,320
Transportation pertaining to transitivity. If one object is equal to a second and the

238
00:26:10,320 --> 00:26:15,520
second object is equal to a third, then the first object must be equal to the third as we

239
00:26:15,520 --> 00:26:19,680
showed here. But as I said before we continue, let's get some theory out of the way. So

240
00:26:20,480 --> 00:26:25,200
something important to understand for this property is the Liskov substitution principle.

241
00:26:26,480 --> 00:26:33,280
The Liskov substitution principle is probably popularized by Robert C. Martin and his solid

242
00:26:33,280 --> 00:26:39,840
design principles. And of course, Barbara Liskov. Is that her name? I believe that's her name.

243
00:26:40,080 --> 00:26:50,080
Barbara Liskov. Yes, she is the scientist who invented this principle and made the contribution

244
00:26:50,080 --> 00:26:55,200
into the field of computer science. Here's how Robert C. Martin summarizes the Liskov

245
00:26:55,200 --> 00:27:00,560
substitution principle. Subtypes must be substitutable for their base types. And of course,

246
00:27:00,560 --> 00:27:10,320
I've got an example here that I use strategy PD to generate, to demo this principle simply. And then

247
00:27:10,320 --> 00:27:16,160
a bit more formally, let's say a bit more mathematical definition, Barbara Liskov defines

248
00:27:16,160 --> 00:27:26,720
it like this, which she did in 1988. If for each object O1 of type S, there's an object O2 of type

249
00:27:26,720 --> 00:27:37,920
T such that for all programs P defined in terms of T, the behavior of P is such of P is unchanged

250
00:27:37,920 --> 00:27:47,120
when O1 is substituted for O2, then S is a subtype of T. So another way of putting it is that if S

251
00:27:47,120 --> 00:27:53,200
is a subtype of T, then the behavior of O1 can be substituted for the behavior of O2, which are two

252
00:27:53,200 --> 00:28:00,080
objects. An example of that would be, again, generated by strategy PD. Thank you. Open AI

253
00:28:00,720 --> 00:28:07,280
and strategy PD, not to anthropomorphize it, but nevertheless, thank you. We have a class animal

254
00:28:07,280 --> 00:28:13,840
with a public void move method, and then we have a subclass. We subclass the animal class by dog,

255
00:28:13,840 --> 00:28:25,840
dog extends animal. And then we define a method that makes the animal move. So the subclass has

256
00:28:25,840 --> 00:28:33,680
a method called make animal move, which takes a object of type animal of the, that's not the sub,

257
00:28:33,680 --> 00:28:39,920
that's a subtype, not the, sorry, that's the supertype. And then this method, in fact, this

258
00:28:39,920 --> 00:28:45,600
method should be inside the, that was, I made it, it's not my fault, it's strategy PD's fault.

259
00:28:48,800 --> 00:28:58,160
If we put it in there, so it probably exists inside the dog class, and we create a new dog object,

260
00:28:58,160 --> 00:29:08,640
and then this method make animal move can take in an animal typed object too, because it respects

261
00:29:08,640 --> 00:29:15,920
the list called substitution principle or it owed to, because dog is a subtype of the supertype

262
00:29:15,920 --> 00:29:21,200
animal. It's quite straightforward, actually. And I think the best way to think about it is how

263
00:29:21,200 --> 00:29:27,200
Robert C. Martin put said subtypes must be substitutable for their base types. So now let's

264
00:29:27,200 --> 00:29:32,960
get to the demo that Joshua Block has used in the book. There are many classes to go through,

265
00:29:33,760 --> 00:29:40,560
but let's start off with the point class. So here's what Joshua Block states. Consider the case

266
00:29:40,560 --> 00:29:47,360
of a subclass that adds a new value component to its superclass. In other words, the subclass

267
00:29:47,360 --> 00:29:53,600
adds a piece of information that affects the equals comparison. What we have here is this

268
00:29:54,560 --> 00:29:58,880
public class. This class is going to be the superclass that we're going to use. It's a concrete

269
00:29:58,880 --> 00:30:06,000
class. Keep that in mind, because the idea or the juxtaposition of a concrete class with a

270
00:30:06,000 --> 00:30:10,640
abstract class, that's something we're going to catch on later on in this part. So we have the

271
00:30:10,640 --> 00:30:17,760
concrete class point, which is simply an immutable two dimensional integer point class. We've got x

272
00:30:17,760 --> 00:30:23,200
and y privately defined, we have constructor, and then you have an equals method, which just the

273
00:30:23,200 --> 00:30:28,400
equality. Similar to what we discussed in the previous example with symmetry, checks if it's

274
00:30:28,400 --> 00:30:34,080
an instance, and then returns true if there's equality. Now let's suppose that we want to

275
00:30:34,080 --> 00:30:39,680
enhance the ability of the point class. Therefore, we subclass it and we have this color point class

276
00:30:39,680 --> 00:30:45,840
that extends the point class, and it attempts to add a value component to point. In this case, it's

277
00:30:46,800 --> 00:30:52,880
the value component of color. We want the points to also have color. Now what would

278
00:30:53,680 --> 00:30:59,600
this class look like? Or more importantly, what would the equals method look like for the color

279
00:30:59,600 --> 00:31:06,640
point class? That is a subclass of point. In this case, we have a normal constructor. We have line

280
00:31:06,640 --> 00:31:11,920
number 14 that invokes the constructor in the superclass. That's what this super keyword does,

281
00:31:11,920 --> 00:31:17,520
and we can do that for x and y, those coordinates. But here, since we're introducing this value

282
00:31:17,520 --> 00:31:22,320
component, we want to initialize the color component to when constructing the object.

283
00:31:24,080 --> 00:31:31,520
But then we come to the equals method that clearly violates the symmetry of the

284
00:31:31,520 --> 00:31:35,600
symmetry principle or the symmetry properties. Well, for starters, of course, we can't use the

285
00:31:36,560 --> 00:31:41,680
equals method from the superclass because the superclass did not even have a color field.

286
00:31:42,240 --> 00:31:47,760
Therefore, it would break the idea of logical equality if we just inherit that method. Therefore,

287
00:31:47,760 --> 00:31:53,600
we need to override the equals method in the subclass color point. But in this equals method,

288
00:31:53,600 --> 00:31:58,240
it violates symmetry because, yes, we're invoking the equals method in the superclass,

289
00:31:58,240 --> 00:32:03,600
and then we're even doing a check for the color point equality here by casting

290
00:32:04,320 --> 00:32:08,560
that object the color point type. Because if it is an instance, in that case,

291
00:32:10,080 --> 00:32:17,520
oh, yes, because if it's not an instance, it'll return false. But it's a one-way comparison. So

292
00:32:17,520 --> 00:32:24,720
if you look at the implementation or a client using it, and if I run this, you'll see the

293
00:32:24,720 --> 00:32:29,920
first comparison will return true because that's fine. We're comparing point and we're passing

294
00:32:29,920 --> 00:32:35,040
the color point object, that's okay. But the second one will return false because in this case,

295
00:32:35,040 --> 00:32:40,640
we are typing or we are passing the supertype object. So it's a clear violation of symmetry.

296
00:32:41,280 --> 00:32:49,040
And that's why Joshua Bloch states, the problem with this method and what he means by this method

297
00:32:49,040 --> 00:32:55,840
is this implementation of the overrides method we have here is that you might get

298
00:32:55,840 --> 00:33:00,480
different results when comparing a point to a color point and vice versa.

299
00:33:01,280 --> 00:33:06,480
The former comparison ignores color while the latter comparison always returns false

300
00:33:07,200 --> 00:33:13,120
because the type of the argument is incorrect. So what he means by the former comparison ignores

301
00:33:13,120 --> 00:33:21,440
color is that in this ampersand, the end statement here, that's the former comparison

302
00:33:21,440 --> 00:33:29,440
where it's simply invoking the equals method in the superclass and it's doing a basic equality test.

303
00:33:29,440 --> 00:33:36,160
But in that equality test, we are ignoring color completely. So it'll return true if it is an object

304
00:33:36,160 --> 00:33:41,600
of proper type. And that, again, doesn't give us what we want. It breaks logical equality.

305
00:33:41,600 --> 00:33:46,720
And in the second one, the problem is it'll never even get to the second one because we check if

306
00:33:46,720 --> 00:33:51,680
this object is an instance of color point. And if it's not, it'll always return false.

307
00:33:51,680 --> 00:33:59,280
Therefore, whenever we pass anything that's not of type color point, it'll return false.

308
00:34:00,000 --> 00:34:04,400
And that also violates not only symmetry, but even the less substitution principle.

309
00:34:04,400 --> 00:34:07,520
So then we're trying to fix this. What we're trying to fix this is we're trying to

310
00:34:07,520 --> 00:34:13,200
resolve this issue with violating symmetry. And that fix also unfortunately doesn't work

311
00:34:13,200 --> 00:34:20,560
because it violates the transitivity property and we shall see what that fix looks like.

312
00:34:20,560 --> 00:34:25,840
So by trying to fix the issue with symmetry, we unfortunately violate transitivity.

313
00:34:25,840 --> 00:34:32,400
In this case, in this new equals method that we overrode, we in fact are considering objects that

314
00:34:32,400 --> 00:34:36,960
are of a different type to color point. We're checking if initially if it's a normal point,

315
00:34:36,960 --> 00:34:42,800
if it's a normal point, we're doing a color blind comparison. Great. And if it's a color

316
00:34:42,800 --> 00:34:47,120
point, then like the previous one, we consider color and then do a comparison. And

317
00:34:47,760 --> 00:34:53,280
absolutely if it's not an instance of either point or color point, it'll just return false.

318
00:34:53,920 --> 00:35:00,000
So in this case, symmetry ticked. However, unfortunately, as we shall see from the

319
00:35:00,000 --> 00:35:10,080
implementation, it does violate transitivity. So in this comparison, we have three objects.

320
00:35:10,080 --> 00:35:17,520
We have two color point objects and a point object. So in the P1 equals P2 comparison,

321
00:35:17,520 --> 00:35:25,600
that's fine. It returns true. Also in the P2 equals P3 comparison, that also returns true.

322
00:35:25,600 --> 00:35:32,240
However, then comes the transitivity issue in the P1 equals P3 comparison, it returns false.

323
00:35:34,320 --> 00:35:38,720
I totally got the wrong. I read that as if that's what was expected. In fact,

324
00:35:38,720 --> 00:35:43,200
that was not what's expected because there's no logical equality there. We're trying to compare

325
00:35:44,320 --> 00:35:51,440
P1 with P2 and it's returning true. It should return false because obviously P1 has that added

326
00:35:51,440 --> 00:35:56,880
value component of color and P2 doesn't have that. So that's wrong. It shouldn't return true.

327
00:35:56,880 --> 00:36:01,520
And it shouldn't in the second comparison, where we compare again, a point and a color point,

328
00:36:01,520 --> 00:36:07,360
it's returning true again, it shouldn't. And okay, the third one's fine because the third one,

329
00:36:08,080 --> 00:36:14,240
it's doing a proper comparison between P1 and P3, which are both type of color point.

330
00:36:14,800 --> 00:36:19,280
And it's returning false, which is expected because the color is different. That's okay,

331
00:36:19,280 --> 00:36:23,840
but these two are a problem. So which is why Joshua Bloch states,

332
00:36:25,360 --> 00:36:33,040
this approach just provides symmetry, but at the expense. So I don't think I read the previous bit.

333
00:36:33,040 --> 00:36:40,000
So just to add on to what he was saying about the override method, he says, this method here,

334
00:36:41,200 --> 00:36:46,640
he says, you might try to fix the problem by having color point or equals ignore color

335
00:36:46,640 --> 00:36:51,600
when doing mixed comparisons. And that's what we're doing in this condition here,

336
00:36:51,600 --> 00:36:56,960
where we're doing a color blind comparison by using the instance of method. So even a point

337
00:36:56,960 --> 00:37:06,000
can be passed on to this object of type point. And then he continues, now, so what we discussed

338
00:37:06,000 --> 00:37:14,400
here before, now P1 equals P2 when P2 equals P3 returns true, where it shouldn't, while P1 equals

339
00:37:14,400 --> 00:37:21,360
P3 returns false, a clear violation of transitivity. The first two comparisons are color blind,

340
00:37:21,360 --> 00:37:26,320
while the third takes color into account, and that shouldn't be the case. So what do we do here?

341
00:37:26,320 --> 00:37:34,320
We've got this huge object oriented predicament, or for us programmers, even a existential crisis,

342
00:37:34,320 --> 00:37:40,240
what are we going to do? What's the solution? He says, it turns out that this is a fundamental

343
00:37:40,240 --> 00:37:44,960
problem of equivalence relations in object oriented languages. This is kind of what I said before.

344
00:37:45,680 --> 00:37:52,960
There's no way to extend an insensiable, insensiable class and add a value component

345
00:37:52,960 --> 00:38:00,080
while preserving the equals contract. The problem again, the big problem is in our design, where

346
00:38:00,080 --> 00:38:07,840
we may point a concrete class. And we shall see why it should have been made a abstract class instead.

347
00:38:07,840 --> 00:38:14,480
But later, sorry, I'm getting a bit carried away. Let's stay on track. Again, re-reading that point

348
00:38:14,480 --> 00:38:21,520
because it's important. There's no way to extend an insensiable class, insensiable class and add

349
00:38:21,520 --> 00:38:27,840
a value component while preserving the equals contract, unless you're willing to forego the

350
00:38:27,840 --> 00:38:33,680
benefits of object oriented abstraction. And then Joshua Block states that we might try to circumvent

351
00:38:33,680 --> 00:38:41,280
this issue in a bit of a sly way by trying to use Java's reflexive API or reflections API. In any

352
00:38:41,280 --> 00:38:47,280
case, it's changing the class on runtime, which is what I tried to demonstrate with the second

353
00:38:47,680 --> 00:38:53,680
equals method, which we think would work. So if I do, whoops, I shouldn't have clicked that.

354
00:38:53,680 --> 00:38:56,720
If I do look at this equals method, I'll comment this out.

355
00:38:59,120 --> 00:39:05,840
We're using the dot get class method from the Reflections API. Okay, before we get to that,

356
00:39:05,840 --> 00:39:12,560
let me quickly read out some theory. What is get class in Java? Again, according to chat GPT,

357
00:39:13,520 --> 00:39:20,000
here's what get class is. In Java, the get class method is a method of the object class that

358
00:39:20,000 --> 00:39:26,400
returns the runtime class of an object. Correct. It returns an object of type class, which is a

359
00:39:26,400 --> 00:39:32,640
class in the Java reflection API that represents a class or interface in the Java programming

360
00:39:32,640 --> 00:39:39,360
language. This in fact is very accurate, which is amazing because if you look at the Oracle docs

361
00:39:39,360 --> 00:39:48,800
and whatnot, chat GPT puts it in a more simpler way to understand. An example would be here,

362
00:39:48,800 --> 00:39:57,920
if we have this employee class or the employee object of type employee, if we go and they have

363
00:39:57,920 --> 00:40:04,800
another class, which we get, we get the class of employee and save it. We don't even really have

364
00:40:04,800 --> 00:40:10,080
to do this. We could just go employee dot get class really. We could just skip this step and go

365
00:40:10,080 --> 00:40:22,880
employee dot get class dot get name. And then return the name of the class. And that's done runtime

366
00:40:22,880 --> 00:40:29,040
by getting the type of the object. So we're trying to circumvent this issue by using the Reflections

367
00:40:29,040 --> 00:40:38,640
API, where we're saying only if it's a type of the implementation of that object. So we're checking

368
00:40:38,640 --> 00:40:45,280
the class of the object we pass on to the equals method, and then we're checking the class of the

369
00:40:45,280 --> 00:40:51,680
current object's runtime. So we're comparing two objects here, the object of this class,

370
00:40:52,400 --> 00:40:56,080
the broader class, and then the object we are passing on to the equals method,

371
00:40:56,080 --> 00:41:00,560
and then we're doing the comparison. Unfortunately, this is not going to work,

372
00:41:00,560 --> 00:41:05,360
because it violates the less-carved substitution principle and breaks logical equality, which is

373
00:41:05,360 --> 00:41:12,880
why Joshua Block states, this effect has the effect of equating objects only if they have

374
00:41:12,880 --> 00:41:17,920
the same implementation class. So which is why we're checking here for the type of the implementation

375
00:41:17,920 --> 00:41:25,520
class. This may not seem so bad, but the consequences are unacceptable. An instance of a subclass

376
00:41:25,600 --> 00:41:33,760
of point is still a point. So an instance of point, for example, like call point is still a point,

377
00:41:33,760 --> 00:41:40,640
and it should work with this equals method, but it doesn't. And it still needs to function as one,

378
00:41:40,640 --> 00:41:45,440
but it fails to do so if you take this approach. Now let's take a look at an example where we're

379
00:41:45,440 --> 00:41:52,960
trying to tell whether a point is on the unit circle. Here's an example. So what this counterpoint

380
00:41:52,960 --> 00:42:00,800
test is trying to do is to see if this is a point. This point class is a point on a unit circle.

381
00:42:00,800 --> 00:42:08,560
We're creating a set of type point, and we're adding some points into it. And then we have this

382
00:42:08,560 --> 00:42:16,160
public static Boolean, which returns a true false, that checks if this point is a point on a circle.

383
00:42:17,040 --> 00:42:23,520
And we're doing that by returning true if whatever point that we pass on to this method

384
00:42:24,640 --> 00:42:31,280
is contained in this set, the unit circle set. Initially here, it'll print true. It'll print

385
00:42:31,280 --> 00:42:38,560
true because it's of type point. But because our point class, we use the reflections API and used

386
00:42:39,360 --> 00:42:48,480
get class. When we pass something, a subtype of kind of point, which again, if it did respect

387
00:42:48,480 --> 00:42:54,480
or follow the less curve substitution principle, it should still print true because it's still

388
00:42:54,480 --> 00:43:01,600
a type of point and it should behave as such. It'll print false, unfortunately. There we go.

389
00:43:01,600 --> 00:43:06,160
In the second one, it's printing false. And this is a clear violation of the principle.

390
00:43:06,960 --> 00:43:12,080
Therefore, using get class and the reflections API is still not the way to circumvent this issue

391
00:43:12,080 --> 00:43:16,800
with object oriented languages. So again, I know we discussed the less curve

392
00:43:16,800 --> 00:43:20,800
substitution principle before, but in the book Joshua Block states the less curve

393
00:43:20,800 --> 00:43:27,680
substitution principle says that any important property of a type should also hold for all its

394
00:43:27,680 --> 00:43:34,880
subtypes so that any method written for the type should work equally well on its subtypes.

395
00:43:35,840 --> 00:43:44,000
And this is the formal statement of our earlier claim that a subclass of point, such as counterpoint,

396
00:43:44,960 --> 00:43:51,440
is still a point and must act as one. Now let's take a look at the problem with this. I mean,

397
00:43:51,440 --> 00:43:56,400
let's take a look at not the problem with the less curve substitution principle, but the problem

398
00:43:56,400 --> 00:44:01,920
with not following this principle. So we have this trivial class here that really does nothing.

399
00:44:02,000 --> 00:44:08,400
It doesn't really add a value component. It simply keeps track of how many instances of,

400
00:44:08,400 --> 00:44:14,160
of, it's called counterpoint, which keeps track of how many instances of point are created. If you

401
00:44:14,160 --> 00:44:20,000
don't know an atomic integer is a thread safe counter, a variable which you can increase.

402
00:44:20,800 --> 00:44:26,560
So simply every time an instance of counterpoint is created, we also we're invoking even the

403
00:44:27,520 --> 00:44:33,760
the super class, the point in this case, and then we can get account of how many instances of

404
00:44:33,760 --> 00:44:40,160
point were created because of this atomic counter. So again, counterpoint is a subtype of point.

405
00:44:40,160 --> 00:44:45,040
Apologies, I demoed this bit a bit earlier before, and I think I used the word color

406
00:44:45,040 --> 00:44:49,680
point by mistake. I think I should have said counterpoint. It's just both counterpoint and

407
00:44:49,680 --> 00:44:57,040
color point are subtypes of point. But as you saw before, it also returned faults,

408
00:44:57,760 --> 00:45:02,480
because we've got a problem with, we haven't got a problem with, sorry, I was going to say we've

409
00:45:02,480 --> 00:45:07,840
got a problem with the, with the contains method. The contains method exactly behaves the way it's

410
00:45:07,840 --> 00:45:12,960
supposed to, but we have a, we have a violation of the less curve substitution principle, which

411
00:45:12,960 --> 00:45:19,200
is why it's training faults. Again, I apologize if I confused you by stating color point, I meant

412
00:45:19,200 --> 00:45:24,400
to say counterpoint, which is this class that this is a, this is a useless class really. It just

413
00:45:25,040 --> 00:45:31,360
invokes the constructor in the superclass point and then keeps track of how many

414
00:45:32,240 --> 00:45:39,920
objects of point have been created. But why, so the question of course is why do we get this

415
00:45:39,920 --> 00:45:46,560
second false here, despite counterpoint being a subtype of point, it is because of this.

416
00:45:46,800 --> 00:45:55,040
Because most collections, so set is a collection here of type point, including the hash set that

417
00:45:55,040 --> 00:46:02,080
we used here by the own unit circle method, use the equals method to test for containment.

418
00:46:02,720 --> 00:46:08,720
And no kind of point instance is equal, equal to any point. And why is that? That is because,

419
00:46:08,720 --> 00:46:16,800
as I said before, we're using get class here. And if, if counterpoint is not of type point,

420
00:46:16,800 --> 00:46:22,560
we aren't gonna, it's going to return faults. So therefore, that's why we get a false here too,

421
00:46:23,200 --> 00:46:28,800
which the, sorry, it's a wrong one. We get a false here too, which the contains method uses the

422
00:46:28,800 --> 00:46:38,160
equals method in the object, in the point object. And that's why Joshua Bloch states, if however,

423
00:46:38,160 --> 00:46:45,120
you use a proper instance of base equals method on point, the same onion cycles circle method

424
00:46:45,120 --> 00:46:49,120
works fine when presented with a counterpoint instance. And let's take a look at that.

425
00:46:51,680 --> 00:47:00,400
So on point, instead of using this equals method that uses get class, if we go back to the previous

426
00:47:00,400 --> 00:47:10,080
one that uses instance of, because instance of does consider even subtypes. And if we run this

427
00:47:10,080 --> 00:47:17,200
again, we'll get two truths. So in that case, it's behaving as expected. So unfortunately,

428
00:47:17,200 --> 00:47:23,440
there's no way getting around this, we should all give up programming. And just quit quit because

429
00:47:23,440 --> 00:47:29,120
life is meaningless. Everything is futile. I'm kidding. I'm kidding. I'm kidding. Life is meaningless

430
00:47:29,120 --> 00:47:36,160
and everything is futile. But in true Nietzschean essence, we ought to create our own meaning,

431
00:47:37,360 --> 00:47:43,920
which is why we're going to use the good old object oriented principle and favor

432
00:47:44,720 --> 00:47:50,560
composition over inheritance to circumvent this issue with which is inherent to object

433
00:47:50,560 --> 00:47:56,720
oriented languages. So let's take a look at this example, a class color point where we don't do

434
00:47:56,720 --> 00:48:03,760
any kind of extension or any kind of inheritance, we're in fact using composition. So in this new

435
00:48:03,760 --> 00:48:08,560
color point, which don't get this confused to the one that we use for inheritance, as you can see

436
00:48:08,560 --> 00:48:14,320
from the package, this is in a separate package called composition. But in this new color point that

437
00:48:14,320 --> 00:48:23,600
uses composition, we have a instance of point defined. And we have an instance of color, which

438
00:48:23,600 --> 00:48:31,280
this is a enum, by the way, that holds some some colors. And we have these two instances defined.

439
00:48:31,280 --> 00:48:38,240
And then in our constructor, we have a new instance of point being created. And we assign that,

440
00:48:38,240 --> 00:48:43,920
of course, to the private private field in our class, we do the same thing with color,

441
00:48:44,640 --> 00:48:51,360
new instance. Sorry, in this case, we don't create a new instance of color, we expect the client to

442
00:48:51,360 --> 00:49:01,600
pass us a proper object of type color. And then we return the point of this color point, just

443
00:49:01,600 --> 00:49:06,160
this again, what the client expects. And then the equals method, because we is in composition,

444
00:49:06,160 --> 00:49:11,520
it's not an issue, we just check if it's an instance of color point. And then we do the

445
00:49:11,520 --> 00:49:16,240
casting accordingly, if it is an instance of color point, the object we pass onto the equals method,

446
00:49:16,960 --> 00:49:22,480
then we do a proper comparison, where we do both the comparison between

447
00:49:23,680 --> 00:49:27,120
between the type point of color point, because this we get from

448
00:49:30,000 --> 00:49:37,200
here. And also a comparison between color. So the color has to be true, and the point has to be

449
00:49:37,200 --> 00:49:44,560
true. And if they both are fulfilled by the double ampersand and operator, it returns true.

450
00:49:44,640 --> 00:49:49,200
And that solves a problem. So if you look at this test class, for instance, I'm going to run this

451
00:49:49,200 --> 00:49:53,680
test class, I've done something really ugly here. In one file, I've defined two classes,

452
00:49:53,680 --> 00:49:59,840
you should never do that. In fact, there's one item where Joshua Block talks about that later on.

453
00:50:00,560 --> 00:50:07,840
It's bad programming etiquette. So in the counterpoint test, again, I've screwed this up,

454
00:50:07,840 --> 00:50:14,160
it should be color point test. This is a bit confusing, I apologize. In the color point test,

455
00:50:14,560 --> 00:50:20,320
we've similarly have a hash set that we've created of type point. And then we're doing

456
00:50:20,320 --> 00:50:25,840
the same thing we did in the previous test, we're checking if the point we pass contains

457
00:50:25,840 --> 00:50:32,240
this object P in this hash set. And then if you run this, the difference here though is firstly,

458
00:50:32,240 --> 00:50:37,840
if I run this, you'll see they both print true. That's because we're using composition.

459
00:50:39,040 --> 00:50:43,600
And what it does is though, when we are adding it, when we're adding a new color point, we do use

460
00:50:43,600 --> 00:50:51,840
this additional method saying add this, however, as a point though. So that changes things because

461
00:50:51,840 --> 00:50:57,200
now we're saying it's still, we're still adding something of type color point, but we're using

462
00:50:57,200 --> 00:51:03,120
this method here, which adds as a point. And it returns that point that we've defined here,

463
00:51:03,760 --> 00:51:08,560
which is what we do in the constructor. And even though we still have this value color

464
00:51:09,520 --> 00:51:16,960
in this private field here, which we can use. So that's how we circumvent the issue.

465
00:51:16,960 --> 00:51:22,480
Interestingly, Joshua Bloch states that there has been historical errors where, for instance,

466
00:51:22,480 --> 00:51:29,840
in the date and the SQL timestamp classes, so in the utilities and the SQL packages,

467
00:51:31,200 --> 00:51:35,600
they've made the mistake of use having implementations of the equals method

468
00:51:36,320 --> 00:51:42,960
that violate symmetry and that this causes erratic behavior. And he says the equals

469
00:51:42,960 --> 00:51:48,160
implementation for timestamp does violate symmetry and can cause erratic behavior if

470
00:51:48,160 --> 00:51:54,960
timestamp and date objects are used in the same collection or otherwise intermixed.

471
00:51:54,960 --> 00:51:59,760
This behavior of the timestamp class was a mistake and should not be emulated. So again,

472
00:51:59,760 --> 00:52:05,280
it's because of the inherent drawback in object oriented languages, these kind of mistakes happen.

473
00:52:05,280 --> 00:52:14,000
However, in many circumstances, using composition over inheritance, the way we

474
00:52:14,000 --> 00:52:18,880
showed in the composition-paste color point class is a way of getting around that.

475
00:52:20,000 --> 00:52:26,560
And then we get to the interesting idea or the interesting notion of using an abstract class

476
00:52:26,560 --> 00:52:32,240
instead of a superclass. And simply, the reason we can add value components to a subclass of an

477
00:52:32,240 --> 00:52:37,360
abstract class is that you can't instantiate an abstract class. So that really solves a lot of

478
00:52:37,360 --> 00:52:44,720
the problems we have with using the concrete point superclass. So in this case, we have an

479
00:52:44,720 --> 00:52:50,080
abstract class shape, which has two protected values, so x and y, and we have a constructor,

480
00:52:50,080 --> 00:52:59,120
and then we have two concrete subclasses that extend the shape class. And we've got circle and

481
00:53:00,080 --> 00:53:07,200
rectangle, where's the other one? Yeah, circle and rectangle, where in the circle one, we are

482
00:53:07,200 --> 00:53:14,160
adding a radius, and in the rectangle one, we are adding length and width. And in the constructor,

483
00:53:14,160 --> 00:53:20,880
of course, we are invoking the constructor of the superclass, which is shape. The issue is

484
00:53:20,880 --> 00:53:26,400
quite straightforward. We can create a concrete object of this concrete class rectangle. However,

485
00:53:26,400 --> 00:53:34,240
if you try to, that's a typo, try to instantiate the shape class, it says you get a compile time

486
00:53:34,240 --> 00:53:40,880
error, say you can't instantiate abstract shape classes, which is why this is a way to get around

487
00:53:40,880 --> 00:53:49,520
this issue, where Joshua Bloch states, when adding a value component, note that you can add a value

488
00:53:49,520 --> 00:53:55,440
component to a subclass of an abstract class without violating the equals contract. This is

489
00:53:55,440 --> 00:54:01,840
important for this sort of class hierarchies that you get by following the advice in item 23,

490
00:54:01,840 --> 00:54:07,280
preferred class hierarchies to tack classes. I'm not going to go into too much detail on that,

491
00:54:07,280 --> 00:54:12,720
because we're going to be covering item 23 next year. And then he says, for example,

492
00:54:12,720 --> 00:54:16,800
he could have an abstract class, so what I pretty much described here, I'll just read it out again.

493
00:54:16,800 --> 00:54:22,720
For example, he could have an abstract class shape with no value components, a subclass circle,

494
00:54:22,720 --> 00:54:30,080
that adds a radius field and a subclass rectangle that adds a length and width fields.

495
00:54:31,200 --> 00:54:38,000
Problem of the sort shown earlier won't occur so long as it is impossible to create a super

496
00:54:38,000 --> 00:54:46,800
class instance directly. That's it. That is the property of transitivity as to how we try and

497
00:54:46,800 --> 00:54:53,520
follow it to ensure that we follow the, or we abide by the general contract of the equals method,

498
00:54:54,160 --> 00:55:02,320
and even discussing the inherent problems with OP languages. But saying that, there are also two

499
00:55:02,320 --> 00:55:10,080
other properties that we need to follow, which is consistency and non-nullity. There are a lot

500
00:55:10,080 --> 00:55:14,960
more shorter than this one, but I'm quite tired. So we're going to cover that in part three.

501
00:55:16,800 --> 00:55:23,920
But I hope this made sense. I was from my best to get this across. I found this quite interesting,

502
00:55:23,920 --> 00:55:30,560
though. I really enjoyed this transitivity bit. So I shall see you in the next one.

503
00:55:30,560 --> 00:55:34,400
Thanks for watching, and I hope you gain some value from it. Cheers.

