1
00:00:00,000 --> 00:00:06,880
Hey everyone, welcome to yet another episode of my video series on, as I fixed this microphone,

2
00:00:06,880 --> 00:00:10,400
on Joshua Bloch's Effective Java.

3
00:00:10,400 --> 00:00:15,640
This is a video series where I expound on the concepts that he has delineated in this

4
00:00:15,640 --> 00:00:16,640
book.

5
00:00:16,640 --> 00:00:19,200
Without further ado, let's get started with the proviso.

6
00:00:19,200 --> 00:00:24,880
I'm trying to keep these things quick because I do repeat this in every single video just

7
00:00:24,880 --> 00:00:28,160
to, you know, for some intelligence, let's say.

8
00:00:28,160 --> 00:00:30,520
And the caveats are, this is not a tutorial.

9
00:00:30,520 --> 00:00:33,000
I am not a teacher, nor an expert.

10
00:00:33,000 --> 00:00:36,040
I certainly am not an expert in any of this.

11
00:00:36,040 --> 00:00:44,160
So while I do try my best to be as accurate as possible, obviously, I certainly will make

12
00:00:44,160 --> 00:00:45,160
mistakes.

13
00:00:45,160 --> 00:00:46,760
So please point them out.

14
00:00:46,760 --> 00:00:51,240
And if it's something significant, I'll even rectify the error in the comment section

15
00:00:51,240 --> 00:00:52,240
down below.

16
00:00:52,240 --> 00:00:55,800
I'd like to think of this as the blind, leading the blind.

17
00:00:55,800 --> 00:01:03,280
I am, as I always say, as blind, or perhaps even more blind than you are, you know, really

18
00:01:03,280 --> 00:01:07,120
quite new to the Java world, given that I've, even though I've been programming with Java

19
00:01:07,120 --> 00:01:13,120
for a couple of years, it's still a very mature language and a mature community and ecosystem.

20
00:01:13,120 --> 00:01:18,160
So consider this to be a exploratory disquisition.

21
00:01:18,160 --> 00:01:23,000
The analogy that I've been using the past couple of videos is that it's like a university

22
00:01:23,000 --> 00:01:25,200
tutorial, except I'm not a tutor.

23
00:01:25,200 --> 00:01:29,520
We're just students kind of working through a problem together.

24
00:01:29,520 --> 00:01:34,160
Of course, though, let's not pretend it's a one-way conversation because I'm doing all

25
00:01:34,160 --> 00:01:35,160
the talking.

26
00:01:35,160 --> 00:01:42,000
Regardless, I have been corrected in past videos, and I have added those in the comment

27
00:01:42,000 --> 00:01:43,400
section down below.

28
00:01:43,400 --> 00:01:49,200
Depending on how this goes, maybe I'll even create a, I don't know, a Discord chat or a

29
00:01:49,200 --> 00:01:51,120
Slack, not a Slack.

30
00:01:51,120 --> 00:01:52,120
That's a bit too much.

31
00:01:52,240 --> 00:01:54,240
I can just go and shout out whatever.

32
00:01:54,240 --> 00:01:55,240
Okay.

33
00:01:55,240 --> 00:01:57,240
Already, this is too long.

34
00:01:57,240 --> 00:02:04,600
The code for this, or this, given it's a programming series, of course, it's going to be on GitHub.

35
00:02:04,600 --> 00:02:08,640
For item 13.2, all the code is going to be on GitHub, even though for this item, it's

36
00:02:08,640 --> 00:02:13,360
going to be two videos because it's quite a big item, but the code in the repository

37
00:02:13,360 --> 00:02:15,840
will be just under one directory.

38
00:02:15,840 --> 00:02:16,840
Alrighty.

39
00:02:16,840 --> 00:02:24,600
Let's get started with item 13, which states override clone judiciously.

40
00:02:24,600 --> 00:02:29,720
And since we've been on chapter three, this item itself is a part of methods common to

41
00:02:29,720 --> 00:02:31,480
all objects.

42
00:02:31,480 --> 00:02:39,600
So for starters, the very first two sentences of the item states, the cloneable interface

43
00:02:39,600 --> 00:02:46,120
was intended as a mixing interface for classes to advertise that they permit cloning.

44
00:02:46,120 --> 00:02:49,240
Unfortunately, it fails to serve this purpose.

45
00:02:49,240 --> 00:02:55,960
Its primary flaw is that it lacks a clone method and objects clone method is protected.

46
00:02:55,960 --> 00:03:00,640
So when he means and objects clone method is protected, he's talking about the object

47
00:03:00,640 --> 00:03:02,320
superclass in Java.

48
00:03:02,320 --> 00:03:05,080
So firstly, in what I read, there were some keywords.

49
00:03:05,080 --> 00:03:08,640
So let's get some basic theory out of the way.

50
00:03:08,640 --> 00:03:09,960
What is the cloneable interface?

51
00:03:09,960 --> 00:03:15,640
According to Oracle docs, a class implements the cloneable interface to indicate to the

52
00:03:15,640 --> 00:03:16,920
object dot clone.

53
00:03:16,920 --> 00:03:22,640
So the clone method in the object superclass, as I said, method that it is legal for that

54
00:03:22,640 --> 00:03:27,320
method to make a field for field copy of instances of that class.

55
00:03:27,320 --> 00:03:32,400
And then Ganesh Chaudhary of GeeksforGeeks says, the Java line cloneable interface is

56
00:03:32,400 --> 00:03:35,000
a marker interface.

57
00:03:35,000 --> 00:03:36,200
What is a marker interface?

58
00:03:36,200 --> 00:03:43,320
It's really simply means it's an interface that's primarily to add metadata to a class.

59
00:03:43,320 --> 00:03:49,240
So as the name suggests, it marks the class, it indicates to the compiler and even the

60
00:03:49,240 --> 00:03:55,320
programmer that this class is of a certain sort, a certain type with this metadata.

61
00:03:55,320 --> 00:04:01,640
He continues, it was introduced in JDK 1.0, there's a method clone in the object class.

62
00:04:01,640 --> 00:04:07,280
Cloneable interface is implemented by a class to make object dot clone method valid, thereby

63
00:04:07,280 --> 00:04:09,520
making a field for field copy.

64
00:04:09,520 --> 00:04:13,680
Again, as the name suggests, what that simply means is when a cloning takes place, so we

65
00:04:13,680 --> 00:04:20,760
have class with an object, and there's object A that's cloned to, let's say object B, when

66
00:04:20,760 --> 00:04:25,240
the cloning happens, it's a field, all the fields in that class, string int, whatever,

67
00:04:25,240 --> 00:04:29,160
that'd be a field for field copy taking place when the cloning happens.

68
00:04:29,160 --> 00:04:32,080
That's why it's called a field for field copy, obviously.

69
00:04:32,080 --> 00:04:36,920
This interface allows the implementing class to have its objects to be cloned instead of

70
00:04:36,920 --> 00:04:38,640
using a new operator.

71
00:04:38,640 --> 00:04:43,200
So simply a cloneable interface indicates that a class in hand supports cloning.

72
00:04:43,200 --> 00:04:48,760
Now the other keyword in what I read before from the book was the word mixing.

73
00:04:48,760 --> 00:04:53,040
Mixing for me is quite interesting, in fact, because I kind of shifted from the Java world

74
00:04:53,040 --> 00:04:59,760
recently with my new job to the Ruby world, or the Ruby and the Rails world, and mixings

75
00:04:59,760 --> 00:05:04,280
are quite common, or the mix and pattern is quite common in the Ruby world.

76
00:05:04,280 --> 00:05:08,400
Even though I didn't even come across the word when I was programming in Java in my

77
00:05:08,400 --> 00:05:15,160
job, but in a very high level, according to Wikipedia, before we get to the mix and interface,

78
00:05:15,160 --> 00:05:17,280
let's talk about what mixings are.

79
00:05:17,280 --> 00:05:24,320
So Wikipedia says in object-oriented programming languages, a mixin is a class that contains

80
00:05:24,320 --> 00:05:33,760
methods for use by other classes without having to be the parent class of those other classes.

81
00:05:34,640 --> 00:05:41,040
Mixings are sometimes described as being included rather than inherited.

82
00:05:41,040 --> 00:05:43,560
So this is a concept of very common in Ruby.

83
00:05:43,560 --> 00:05:47,480
We have sort of like modules, and you could include modules in classes.

84
00:05:47,480 --> 00:05:54,240
So that allows whatever methods in that module to be included in another separate class,

85
00:05:54,240 --> 00:05:55,240
let's say.

86
00:05:55,240 --> 00:05:59,120
But in the context of Java, we don't really do this kind of including modules and whatnot.

87
00:05:59,120 --> 00:06:02,880
What they simply do is they allow composite interfaces.

88
00:06:02,880 --> 00:06:06,800
Mixings allow composite interfaces, allowing programmers to build modular and extensible

89
00:06:06,800 --> 00:06:12,000
software systems, which is why, here again, it said here, the clone interface was intended

90
00:06:12,000 --> 00:06:16,520
as a mix and interface for classes to advertise that they permit cloning.

91
00:06:16,520 --> 00:06:20,240
Okay, a bit of a demo to understand the concept of mixin.

92
00:06:20,240 --> 00:06:26,320
Now, given Java doesn't have a mechanism to explicitly understand what mixins are, like

93
00:06:26,320 --> 00:06:33,040
Ruby, as I said, we can't need to play around a little bit with multiple classes to get the

94
00:06:33,040 --> 00:06:35,400
idea of what a mixin is.

95
00:06:35,400 --> 00:06:40,240
So in this demo, what we have initially at first is a, initially at first, gosh, what

96
00:06:40,240 --> 00:06:48,640
we have here is an interface called mixin interface, where there are two methods defined.

97
00:06:48,640 --> 00:06:52,440
There's a do something and do something else, two void methods.

98
00:06:52,440 --> 00:06:58,840
And then we have a mixin class that implements this interface and then gives a solid implementation

99
00:06:58,840 --> 00:07:00,680
of these methods.

100
00:07:00,680 --> 00:07:03,640
So we have mixin class and then we have another mixin class.

101
00:07:03,640 --> 00:07:04,640
This is a bit confusing.

102
00:07:04,640 --> 00:07:07,640
I should have called it like class A and class B, but you get there are two classes that

103
00:07:07,640 --> 00:07:13,680
implements the mixin interface, and they have their own kinds of implementations for these

104
00:07:13,680 --> 00:07:15,680
methods.

105
00:07:15,680 --> 00:07:22,480
And then we have a composite class also that implements the mixin interface.

106
00:07:22,480 --> 00:07:28,200
But this class is what does the composition of the other two classes or what those two

107
00:07:28,200 --> 00:07:32,160
methods can do via the mixin interface.

108
00:07:32,160 --> 00:07:39,800
So what that means is this composite class sort of acts as a pseudo module in Ruby.

109
00:07:39,800 --> 00:07:43,480
I'm sorry to incorporate Ruby into this because if you're not familiar with Ruby, you have

110
00:07:43,480 --> 00:07:44,840
no idea what I'm talking about.

111
00:07:44,840 --> 00:07:52,880
But this class would be, yeah, it's what does the, it combines the functionality from the

112
00:07:52,880 --> 00:07:59,080
other two classes into this single class, because it provides different implementations

113
00:07:59,080 --> 00:08:06,880
of the do something and do something else methods in mixin.

114
00:08:06,880 --> 00:08:12,840
And then because it provides separate implementation of the two methods, it can delegate it to

115
00:08:12,840 --> 00:08:17,840
the corresponding methods of the mixin interface, which is what I said before.

116
00:08:17,840 --> 00:08:18,840
But see how this works.

117
00:08:18,840 --> 00:08:24,320
Let's just look at the demo and see how a client would use this composite class to allow

118
00:08:24,320 --> 00:08:25,720
this composition.

119
00:08:25,720 --> 00:08:32,440
So what this composite class allows us is to combine the functionality of two classes,

120
00:08:32,440 --> 00:08:37,840
but then also simultaneously the individual mixing classes can also be used independently

121
00:08:37,840 --> 00:08:38,840
as well.

122
00:08:38,840 --> 00:08:47,120
So we have a mixin one, mixin two, which is firstly of the both of mixin interface type,

123
00:08:47,120 --> 00:08:52,360
but one is the mixin class, the other one is another mixin class, and we have the composite

124
00:08:52,360 --> 00:08:57,280
classes composite one and composite two, although as you can see in the constructor, oh, sorry,

125
00:08:57,280 --> 00:08:58,280
I didn't mention that bit.

126
00:08:58,280 --> 00:09:05,320
So what allows that composition to take place is really the constructor where we have the

127
00:09:05,800 --> 00:09:09,000
private final instance of the mixin interface.

128
00:09:09,000 --> 00:09:16,240
And then what we pass into this can be either mixin class or another mixin class.

129
00:09:16,240 --> 00:09:18,640
So two different classes.

130
00:09:18,640 --> 00:09:20,200
And that's what we're doing in the composition.

131
00:09:20,200 --> 00:09:25,160
We're passing mixin one and then mixin two.

132
00:09:25,160 --> 00:09:28,320
And then in the composite, we can do something, do something else.

133
00:09:28,320 --> 00:09:34,280
And then depending on what we pass into the constructor, the corresponding method will

134
00:09:34,280 --> 00:09:37,320
be invoked on the corresponding class.

135
00:09:37,320 --> 00:09:43,400
So if I run this, you'll see it does firstly from mixin class, do something to something

136
00:09:43,400 --> 00:09:48,240
else, and then it'll run another mixin class, do something differently, do something else

137
00:09:48,240 --> 00:09:49,240
differently.

138
00:09:49,240 --> 00:09:53,080
That's the basic idea of what a mixin interface does.

139
00:09:53,080 --> 00:10:01,280
Probably a bad example, really, because clearly, it's not explicit in Java, but at a high

140
00:10:01,280 --> 00:10:04,600
level, again, it allows composite interfaces.

141
00:10:04,600 --> 00:10:09,560
And then of course, I mentioned the clone method, needless to say, that's probably one

142
00:10:09,560 --> 00:10:12,400
of the most important methods in this item.

143
00:10:12,400 --> 00:10:17,280
The clone method, of course, is a built-in method in Java that allows objects to create

144
00:10:17,280 --> 00:10:18,280
a copy of themselves.

145
00:10:18,280 --> 00:10:24,840
A few things to keep in mind, the clone method is protected, and this potentially becomes

146
00:10:24,840 --> 00:10:26,640
a problem in the future.

147
00:10:26,640 --> 00:10:30,760
The fact that none of them in the future will discuss, in the future of this item will discuss

148
00:10:30,760 --> 00:10:31,760
it.

149
00:10:31,760 --> 00:10:36,080
The idea that the clone method is protective can be a bit annoying, we'll discuss that

150
00:10:36,080 --> 00:10:37,080
later.

151
00:10:37,080 --> 00:10:43,000
But just to get a formal definition, which I really liked, Chagypti's definition.

152
00:10:43,000 --> 00:10:49,240
By the way, the reason that it becomes a problem, can become a potential problem is because

153
00:10:49,240 --> 00:10:53,640
only subclasses can use this method because it's protected.

154
00:10:53,640 --> 00:10:58,960
So again, a formal definition by Chagypti, which I thought was a good one, by default,

155
00:10:58,960 --> 00:11:05,080
the clone method performs a shallow copy of the object, which means that only the objects

156
00:11:05,080 --> 00:11:10,400
fields are copied, but any object references, any object references by those fields are

157
00:11:10,400 --> 00:11:11,400
not cloned.

158
00:11:11,400 --> 00:11:18,160
So for this line here, but any objects references by those fields, perhaps the quintessential

159
00:11:18,160 --> 00:11:20,080
example would be an array.

160
00:11:20,080 --> 00:11:25,960
An array would be a problem if a class has an array declared, because then a shallow

161
00:11:25,960 --> 00:11:31,000
copy wouldn't work as there'll be two objects pointing to the same memory instance of that

162
00:11:31,000 --> 00:11:35,680
array, and that can create corrupted states and cause a problem.

163
00:11:35,680 --> 00:11:38,880
Anyway, I'll continue and we'll get to that later too.

164
00:11:38,880 --> 00:11:43,440
If you want to perform a deep copy of the object where all the objects referenced by

165
00:11:43,440 --> 00:11:47,800
the fields are also cloned, you will need to override the clone method and implement

166
00:11:47,800 --> 00:11:54,080
your own cloning logic, which is why most times this, the latter bit where we do override

167
00:11:54,080 --> 00:12:03,120
it does take place because most classes will most most most classes, I can't talk because

168
00:12:03,120 --> 00:12:07,760
most times most use cases a shallow copy will not suffice when we're probably cloning some

169
00:12:07,760 --> 00:12:08,760
cloning an object.

170
00:12:08,760 --> 00:12:10,320
We need a deep copy.

171
00:12:10,320 --> 00:12:15,680
So to understand the problem, we need to look at it in a bipartite way in the sense that

172
00:12:15,680 --> 00:12:22,440
the first part is that the objects, which is the superclass, the objects clone method

173
00:12:22,440 --> 00:12:25,560
is protected, as I said it here.

174
00:12:25,560 --> 00:12:32,920
And the second problem is the cloneable interface is only a, what's what we use a marker interface

175
00:12:32,920 --> 00:12:36,240
as in it doesn't have any defined clone methods.

176
00:12:36,240 --> 00:12:42,600
So one solution keep in mind potential solution is that we could invoke reflection in Java.

177
00:12:42,600 --> 00:12:45,440
We could invoke the clone method with Java reflection.

178
00:12:45,440 --> 00:12:53,160
Now just your block would not suggest that given that Java reflection can be a bit tricky.

179
00:12:53,160 --> 00:13:00,280
It can leave a lot of objects in corrupt state and cause problems in application on runtime.

180
00:13:00,280 --> 00:13:04,200
So it's primarily used by framework builders.

181
00:13:04,200 --> 00:13:10,320
But simply we've discussed Java reflection in many items before, what it allows us to

182
00:13:10,320 --> 00:13:15,360
program is to dynamically inspect and manipulate objects, classes, interfaces at runtime.

183
00:13:15,360 --> 00:13:22,320
So using reflections as the name suggests, in runtime when objects are created and in

184
00:13:22,320 --> 00:13:27,280
memory, you could reflect within the objects or introspect and then manipulate it and play

185
00:13:27,280 --> 00:13:28,560
around with it.

186
00:13:28,560 --> 00:13:37,000
So a simple example or a simple demo, just to again reiterate and demonstrate what reflection

187
00:13:37,000 --> 00:13:46,600
does is this my class class, I got to get better naming classes, my class class.

188
00:13:46,600 --> 00:13:49,000
This class implements cloneable.

189
00:13:49,000 --> 00:13:54,320
We have a private infield called value, we have a setup, sorry, we have a constructor,

190
00:13:54,600 --> 00:13:59,360
let me have a setter, a getter and afterwards in the implementation or the client using

191
00:13:59,360 --> 00:14:02,200
it, firstly, this will not work.

192
00:14:02,200 --> 00:14:08,480
So if you look here, it's going to throw an error because the clone method is protected.

193
00:14:08,480 --> 00:14:14,400
So you can't just go my object.clone because in the superclass of my object, the clone

194
00:14:14,400 --> 00:14:15,400
method is protected.

195
00:14:15,400 --> 00:14:17,320
So that will not work.

196
00:14:17,320 --> 00:14:22,920
Therefore what we've got to do is resort to using reflection and obviously in reflections

197
00:14:22,920 --> 00:14:30,000
always use a try catch block because reflections have a high potential of throwing exceptions.

198
00:14:30,000 --> 00:14:40,880
And then if I run it, okay, that took a while for me to understand because I had to go through

199
00:14:40,880 --> 00:14:45,520
how the reflections work and trying to make sense of it once again because I wrote this

200
00:14:45,520 --> 00:14:52,200
quite a while back, which is probably another reason as to why unless you really need it

201
00:14:52,480 --> 00:14:57,680
using Java reflections is not a good idea because there's a lot of unexpected things

202
00:14:57,680 --> 00:15:00,360
that can happen, let's say.

203
00:15:00,360 --> 00:15:06,720
So firstly, I'm not going to override the clone method in my class.

204
00:15:06,720 --> 00:15:10,120
So we're going to try and use the clone method in the object class.

205
00:15:10,120 --> 00:15:17,600
Now what happens then is I'm going to leave that bit commented out but I'll comment it

206
00:15:17,600 --> 00:15:24,920
and comment out this bit here, which is trying to access the clone method of the superclass,

207
00:15:24,920 --> 00:15:29,680
which you can see here, I'm getting the clone method and I'm setting it as accessible.

208
00:15:29,680 --> 00:15:36,360
And then when I run this, it should technically or theoretically give an error because it

209
00:15:36,360 --> 00:15:40,760
can't access that because it's a protected method.

210
00:15:40,760 --> 00:15:48,240
So the only way really to do it is to override it in the subclass and then do it like this,

211
00:15:48,240 --> 00:15:54,920
which involves...

212
00:15:54,920 --> 00:16:00,280
Now here you don't have to use reflections even though I've just used it, but that involves

213
00:16:00,280 --> 00:16:05,440
accessing it via the subclass and then doing the cloning as such, which is going to happen

214
00:16:05,440 --> 00:16:06,440
here.

215
00:16:06,440 --> 00:16:12,760
Now of course here again, as I said, you don't need to really do reflections, but the point

216
00:16:12,760 --> 00:16:17,560
being, the overall point of all of this being, and I'm probably going to edit out a bit of

217
00:16:17,560 --> 00:16:21,320
the middle because I spent a long time going through this and then googling trying to figure

218
00:16:21,320 --> 00:16:30,160
out what I did wrong, is that because this pesky cloneable interface, this piece of shit

219
00:16:30,160 --> 00:16:36,880
is not providing us with an implementation for the clone method, that makes things unnecessarily

220
00:16:36,880 --> 00:16:42,160
complicated, which is why Joshua Block states, so what does a cloneable do, given that it

221
00:16:42,160 --> 00:16:48,520
contains no method, it determines the behavior of objects protected clone implementation.

222
00:16:48,520 --> 00:16:55,480
If a class implements cloneable, objects clone method returns a field by field copy of the

223
00:16:55,480 --> 00:17:02,800
object, otherwise it throws clone not supported exception as a low malware is making noise

224
00:17:02,800 --> 00:17:03,800
again.

225
00:17:03,800 --> 00:17:09,760
Now by the way, as we go on with this point, that latter bit, throwing the clone not supported

226
00:17:09,760 --> 00:17:17,960
exception that also becomes a pain point with this interface, we'll discuss it in this item.

227
00:17:17,960 --> 00:17:23,760
And he continues, though the specification doesn't say it, and this is an important point,

228
00:17:23,760 --> 00:17:31,200
in practice, a class implementing cloneable is expected to provide a properly functioning

229
00:17:31,200 --> 00:17:36,600
public clone method, in order to achieve this, this class and all of its superclasses must

230
00:17:36,600 --> 00:17:43,600
obey a complex, unenforceable, thinly documented protocol.

231
00:17:43,600 --> 00:17:50,080
The resulting mechanism is fragile, dangerous and extra linguistic, it creates objects without

232
00:17:50,080 --> 00:17:51,880
calling a constructor.

233
00:17:51,880 --> 00:17:58,840
That really is what a clone method does, if you think about it, for all intents and purposes.

234
00:17:58,840 --> 00:18:02,440
So this begs the question, how to implement a well behaved clone method?

235
00:18:02,440 --> 00:18:06,760
And before we get to the implementing strategy, a few caveats.

236
00:18:06,760 --> 00:18:12,560
Firstly, the cloneable interface is an atypical interface, as interfaces aren't supposed

237
00:18:12,560 --> 00:18:17,920
to modify the behavior of a superclass, but are blueprint for what a given class can do

238
00:18:17,920 --> 00:18:18,920
for its clients.

239
00:18:18,920 --> 00:18:25,240
So really, when you implement the cloneable method in a class, let's say class A, it's

240
00:18:25,240 --> 00:18:30,560
kind of an interface for the object class, for the superclass, which is atypical.

241
00:18:30,560 --> 00:18:32,280
And that again is a problem.

242
00:18:32,280 --> 00:18:38,480
And then also, I wouldn't say it's a problem, it's kind of an anti-pattern, it's something

243
00:18:38,480 --> 00:18:40,600
particularly shouldn't follow.

244
00:18:40,600 --> 00:18:44,680
But also the general contract for the objects clone method is weak.

245
00:18:44,680 --> 00:18:50,040
This is the general contract defined in the Oracle docs, and you can see what it does.

246
00:18:50,040 --> 00:18:55,560
I'm not going to go through it too facetiously, but essentially, the idea is the clone takes

247
00:18:55,560 --> 00:19:04,400
place and it creates in return a copy of the past object, past of that method with a new

248
00:19:04,400 --> 00:19:05,920
memory location.

249
00:19:05,920 --> 00:19:13,000
Now, it is vaguely similar to constructor chaining, a pattern, a design pattern, which

250
00:19:13,000 --> 00:19:16,440
allows to create less duplicated code.

251
00:19:16,440 --> 00:19:21,080
But more than me explaining it, let's take a look at what constructor chaining entails

252
00:19:21,080 --> 00:19:27,120
if I open up the class customer.

253
00:19:27,120 --> 00:19:28,320
It's quite a straightforward pattern.

254
00:19:28,320 --> 00:19:31,440
You probably have seen it in a lot of code in the Java world.

255
00:19:31,440 --> 00:19:36,080
We have a class customer that extends the superclass person.

256
00:19:36,080 --> 00:19:41,800
So all the customers are people, at least for now.

257
00:19:41,800 --> 00:19:48,000
And then in constructor chaining, we have the customer class being constructed, that

258
00:19:48,000 --> 00:19:49,840
the object being created.

259
00:19:49,840 --> 00:19:55,880
And we will see as some fields are just inherited directly from the superclass, things like

260
00:19:55,880 --> 00:19:59,080
first name, middle name, last name, age.

261
00:19:59,080 --> 00:20:06,440
And then only this field here, the loyalty card ID, is constructed in this constructor

262
00:20:06,440 --> 00:20:09,040
and that field value is set.

263
00:20:09,040 --> 00:20:15,240
So the way this reduces duplication of coders, let's say if we didn't have this kind of constructor

264
00:20:15,240 --> 00:20:21,680
chaining, this same bit of code here will have to be replicated in this constructor

265
00:20:21,680 --> 00:20:23,160
too.

266
00:20:23,160 --> 00:20:26,480
And that would be a waste of space.

267
00:20:26,480 --> 00:20:32,760
And so by invoking the super keyword and then passing it into the superclass constructor,

268
00:20:32,760 --> 00:20:34,400
this allows the supercoded code.

269
00:20:34,400 --> 00:20:39,720
However, the problem is this kind of pseudo constructor chaining isn't enforced in the

270
00:20:39,720 --> 00:20:40,720
clone method.

271
00:20:40,720 --> 00:20:48,160
So if you'd look at our person customer example, if you mess up the construction here in the

272
00:20:48,160 --> 00:20:52,040
constructor, the compiler will throw an error.

273
00:20:52,040 --> 00:20:58,240
But in this example, which I have, which is a class called food that implements cloneable,

274
00:20:58,240 --> 00:21:01,680
it's overriding the clone method.

275
00:21:01,680 --> 00:21:05,560
And then this class bar extends the food class.

276
00:21:05,560 --> 00:21:08,640
So that's a subclass of food.

277
00:21:08,640 --> 00:21:15,600
And it also is trying to override the clone method of food, of the superclass, but what

278
00:21:15,600 --> 00:21:20,640
happens there is in our track catch block when we run it, it's going to throw an error.

279
00:21:20,640 --> 00:21:29,040
The reason is because the superclass, which is food, is not, it doesn't call the super.clone,

280
00:21:29,040 --> 00:21:34,560
so the objects clone method, rather it's just creating a new instance of food and passing

281
00:21:34,560 --> 00:21:35,560
that.

282
00:21:35,560 --> 00:21:40,000
And that creates errors here because it's on a proper clone taking place.

283
00:21:40,000 --> 00:21:43,600
And because now this error is thrown in runtime.

284
00:21:43,600 --> 00:21:47,480
So if it was in foes, we would catch this error in compile time.

285
00:21:47,480 --> 00:21:48,480
And that's a problem.

286
00:21:48,640 --> 00:21:52,400
However, though, of course, final classes don't have to worry about this problem of it being

287
00:21:52,400 --> 00:21:57,520
not in foes because they will not implement cloneable as they won't be cloned.

288
00:21:57,520 --> 00:22:02,440
So to put it a bit more clearly, Joshua Block states, this mechanism is vaguely similar

289
00:22:02,440 --> 00:22:06,080
to constructor chaining, except that it isn't in foes.

290
00:22:06,080 --> 00:22:12,520
If a classes clone method returns an instance that is not obtained by calling superart clone,

291
00:22:12,520 --> 00:22:24,480
like the problem which we see here, where the superclass foo is not calling super.clone,

292
00:22:24,480 --> 00:22:29,880
but by calling a constructor, which the person is doing here, the compiler won't complain.

293
00:22:29,880 --> 00:22:35,200
But if a subclass of that class calls super.clone, the resulting object will have the wrong class

294
00:22:35,200 --> 00:22:42,320
preventing the subclass from clone.

295
00:22:42,320 --> 00:22:45,400
That's a complicated, weird way of putting it in the sentence.

296
00:22:45,400 --> 00:22:50,320
Those resulting objects will have the wrong class preventing the subclass from clone method

297
00:22:50,320 --> 00:22:51,840
from working properly.

298
00:22:51,840 --> 00:22:55,320
That's like a weird way that he's written the sentence.

299
00:22:55,320 --> 00:22:59,960
In any case, the learning strategy, the simplest thing at first to do is to call the super

300
00:22:59,960 --> 00:23:04,400
dot clone method because that will return an object which is a fully functional replica

301
00:23:04,400 --> 00:23:05,400
of the original.

302
00:23:05,400 --> 00:23:10,920
And if all fields of the class, so in the class you're designing, if all the fields contain

303
00:23:10,920 --> 00:23:16,800
primitive values or reference to an immutable object, no further processing is needed.

304
00:23:16,800 --> 00:23:22,160
As Joshua Block states, any field declared in your class will have values identical to

305
00:23:22,160 --> 00:23:23,720
those of the original.

306
00:23:23,720 --> 00:23:28,560
If every field contains a primitive value or a reference to an immutable object, the

307
00:23:28,560 --> 00:23:31,280
return object may be exactly what you need.

308
00:23:31,280 --> 00:23:35,960
So you don't need to play around with it in your clone method, in your overwritten clone

309
00:23:35,960 --> 00:23:39,720
method, in which case no further processing is necessary.

310
00:23:39,720 --> 00:23:45,600
And he also continues, but note that immutable classes should never provide a clone method

311
00:23:45,600 --> 00:23:48,880
because it would merely encourage wasteful copying.

312
00:23:48,880 --> 00:23:52,800
So an immutable class would be classes where the fields are all final and the class itself

313
00:23:52,800 --> 00:23:55,680
is declared with a final keyword.

314
00:23:55,680 --> 00:24:00,840
And a simple example of this idea is this phone number class where in the phone number

315
00:24:00,840 --> 00:24:07,960
class we have a clone method, it's simply invoking, not invoking invoking the super

316
00:24:07,960 --> 00:24:12,120
dot clone method which is the clone method of the object class and of course doing the

317
00:24:12,120 --> 00:24:18,000
casting so that what's returned by this method is something of type phone number.

318
00:24:18,000 --> 00:24:22,720
And the reason we can do this in a straightforward manner with the casting is because Java does

319
00:24:22,720 --> 00:24:30,120
support covariant return types as he states here, it is legal and desirable to do this

320
00:24:30,400 --> 00:24:33,880
because Java supports covariant return types.

321
00:24:33,880 --> 00:24:36,280
So what are covariant return types in Java?

322
00:24:36,280 --> 00:24:41,240
Firstly, let's understand the theory behind the concept of covariance.

323
00:24:41,240 --> 00:24:49,040
According to Baldung, covariance can be considered as a contract for how a subtype is accepted

324
00:24:49,040 --> 00:24:52,120
when only the super type is defined.

325
00:24:52,120 --> 00:24:58,080
And another definition is covariance means we can access specific elements defined by

326
00:24:58,080 --> 00:24:59,080
the super type.

327
00:24:59,080 --> 00:25:03,520
However, we aren't allowed to put elements into a covariant system since the compiler

328
00:25:03,520 --> 00:25:07,360
would fail to determine the actual type of the generic structure.

329
00:25:07,360 --> 00:25:12,360
I know that's a bit too formal and abstract but simply what it means is a subclass can

330
00:25:12,360 --> 00:25:14,320
override the methods of a superclass.

331
00:25:14,320 --> 00:25:19,200
So in our case a phone number, phone number can override the method of the object class

332
00:25:19,200 --> 00:25:27,960
which is the clone method and afterwards when it returns it can return something or an object

333
00:25:27,960 --> 00:25:32,080
not something, an object of type of the subclass.

334
00:25:32,080 --> 00:25:34,240
So it will not return.

335
00:25:34,240 --> 00:25:40,080
So the phone number clone method will not return an object of type object instead it

336
00:25:40,080 --> 00:25:42,520
will return an object of type phone number.

337
00:25:42,520 --> 00:25:48,760
Now if we didn't have the idea of covariance and if Java didn't have covariant return types

338
00:25:48,760 --> 00:25:50,920
this would be the implementation necessary.

339
00:25:50,920 --> 00:25:52,920
We'll have to do the casting as a client.

340
00:25:52,920 --> 00:25:58,480
So when the client uses the phone number class and uses the clone method that we initially

341
00:25:58,480 --> 00:26:04,480
defined we will have to do the casting as a client and because of covariance this is

342
00:26:04,480 --> 00:26:06,040
not required.

343
00:26:06,040 --> 00:26:09,800
Simply that will suffice and work fine.

344
00:26:09,800 --> 00:26:13,000
So to further understand covariance so let's look at this demo.

345
00:26:13,000 --> 00:26:18,600
We have a class vehicle which starts an engine and then we have a class car that extends

346
00:26:18,600 --> 00:26:19,600
vehicle.

347
00:26:19,600 --> 00:26:25,520
We also have a class motorcycle that extends vehicle and these two have their own implementations

348
00:26:25,520 --> 00:26:28,080
of the start engine method.

349
00:26:28,080 --> 00:26:33,040
Now if we run this code what you'll see is we're first starting the vehicles engine,

350
00:26:33,040 --> 00:26:37,520
the superclasses engine and then we're starting the cars engine and the motorcycles engine.

351
00:26:37,520 --> 00:26:44,720
So in starting this engine the objects return even though we're calling the same start method

352
00:26:44,720 --> 00:26:49,320
and the overriding is taking place in the subclasses.

353
00:26:49,320 --> 00:26:56,000
The return type is of type this which means it can return an object of type car or in

354
00:26:56,000 --> 00:27:02,360
this case an object of type motorcycle and over here no casting is necessary.

355
00:27:02,360 --> 00:27:07,840
For example over here if we do this, this would be redundant and the compiler would

356
00:27:07,840 --> 00:27:12,720
say what are you doing mate, it'll in fact throw an error, sorry I wouldn't throw an

357
00:27:12,720 --> 00:27:18,280
error, I'm just being silly, it would show that it's redundant, it's useless.

358
00:27:18,280 --> 00:27:20,880
So remove redundant cast because you don't need to do that casting.

359
00:27:20,880 --> 00:27:25,440
So the next point is the clone not support exception should have been an unchecked runtime

360
00:27:25,440 --> 00:27:26,440
exception.

361
00:27:26,440 --> 00:27:31,640
Now I think I did discuss this in the beginning of the video but here's the problem.

362
00:27:31,640 --> 00:27:34,240
So firstly let me read from the book.

363
00:27:34,240 --> 00:27:38,460
The code to support our clone is contained in a try catch block.

364
00:27:38,460 --> 00:27:46,000
This is because object declares its clone method to throw clone not support exception

365
00:27:46,000 --> 00:27:49,100
which is a checked exception.

366
00:27:49,100 --> 00:27:53,060
Because phone number implements cloneable we know the code to support our clone will

367
00:27:53,060 --> 00:27:54,060
succeed.

368
00:27:54,060 --> 00:27:59,260
The need for this boilerplate code indicates that clone not support exception should have

369
00:27:59,260 --> 00:28:01,780
been unchecked.

370
00:28:01,780 --> 00:28:05,540
So the problem is because we know across that implements a clone method it's going to implement

371
00:28:05,540 --> 00:28:11,060
the cloneable interface the checked exception won't be thrown which makes this code here

372
00:28:11,060 --> 00:28:15,980
the try catch block superfluous redundant code and it's unnecessary.

373
00:28:15,980 --> 00:28:20,020
Okay now what we're going to try and do is look at the stack class so a bit more high

374
00:28:20,020 --> 00:28:25,140
level view at how the clone method is implemented and the stack class is defined well it was

375
00:28:25,140 --> 00:28:32,180
initially defined in item 7 but we've repurposed it to fit to item 13 and this is really important

376
00:28:32,180 --> 00:28:37,500
because here's why really we need to consider this point as to how do we deal with object

377
00:28:37,500 --> 00:28:42,980
fields or class fields that refer to mutable objects because a simple clone implementation

378
00:28:42,980 --> 00:28:49,380
won't work for such cases such as why in our classes we need to override the clone implementation

379
00:28:49,380 --> 00:28:59,220
of object specially for fields that are mutable or fields that refer to mutable fields pardon

380
00:28:59,220 --> 00:29:05,580
me not mutable fields are mutable objects or data structures and in this case the again

381
00:29:05,580 --> 00:29:11,500
that perhaps a quintessential example would be an array for an array we need to recursively

382
00:29:11,500 --> 00:29:16,860
copy all the elements of the mutable field like an array to solve the problem of destroying

383
00:29:16,860 --> 00:29:22,020
or destroy invariants we don't have we don't want to have arrays in two different states

384
00:29:22,020 --> 00:29:26,620
where we have two objects so we have object A and an object B that was copied of object

385
00:29:26,620 --> 00:29:32,460
A both pointed to the same array that could create corrupt states and that's what we see

386
00:29:32,460 --> 00:29:39,260
in this stack class so this is fine this integer size is fine this is fine especially because

387
00:29:39,260 --> 00:29:47,300
it's final however the objects object array called elements this in our clone method

388
00:29:47,300 --> 00:29:52,380
we need to change it up a bit so as you can see here we are firstly doing the normal cloning

389
00:29:52,460 --> 00:29:59,580
in the super dot clone and then we're specifically cloning all the elements recursively in elements

390
00:30:00,620 --> 00:30:06,140
and then setting it to result so the new object dot elements and then returning that so what we

391
00:30:06,140 --> 00:30:12,460
do here is we in fact create two array instances so to reiterate that point I think it's important

392
00:30:12,460 --> 00:30:20,460
because he's in this part of this item this is the take home point is that when we do the cloning

393
00:30:20,460 --> 00:30:28,060
it can't just be a dumb clone of all the fields a field for field clone if there are let's say

394
00:30:28,060 --> 00:30:33,180
things like arrays which point to other immutable objects because what's going to happen then then

395
00:30:33,180 --> 00:30:37,500
is we're going to destroy the invariance of this clone method where both objects are going to point

396
00:30:37,500 --> 00:30:43,420
to the same array and that's going to corrupt that array where as clients use these objects it'll

397
00:30:43,420 --> 00:30:49,100
either throw not point exceptions or give nonsensical results and this situation as

398
00:30:49,180 --> 00:30:53,100
Joshua block I said earlier which I will read will not happen in a constructor clone method in

399
00:30:53,100 --> 00:30:57,740
many ways acts like a constructor because it's really constructing a new object now this thing

400
00:30:57,740 --> 00:31:02,780
we've defined here will not happen in a typical constructor because we aren't copying things across

401
00:31:02,780 --> 00:31:08,620
in a constructor which is why Joshua block states this situation by the way I shouldn't say this

402
00:31:08,620 --> 00:31:14,700
situation here because what we've done here is correct in fact let's say hypothetically we didn't

403
00:31:14,700 --> 00:31:19,580
do this now this would destroy the invariance of this clone method but here this is correct

404
00:31:21,020 --> 00:31:27,500
so this is not bad code anyways continue this situation could never occur as a result of calling

405
00:31:27,500 --> 00:31:34,060
the sole constructor in the stack class in effect the clone method functions as a constructor you

406
00:31:34,060 --> 00:31:40,140
must ensure that it does no harm to the original object and that it properly establishes invariance

407
00:31:40,140 --> 00:31:47,420
on the clone so yes if we didn't do this what will happen is we'll have object a and then object b

408
00:31:47,420 --> 00:31:53,500
cloned off object a and then if someone messes around with object b in the the elements array

409
00:31:53,500 --> 00:31:58,940
then object a will also be affected because they are both pointing to the same array and that's

410
00:31:58,940 --> 00:32:05,340
the problem we're trying to solve here really if if you get this point from this whole video elaborate

411
00:32:05,340 --> 00:32:11,100
video you get this part of what i'm trying to convey here and then to end this part of the item a

412
00:32:11,100 --> 00:32:16,620
few note of bennets the first one is you probably noticed we aren't doing any casting like this

413
00:32:16,620 --> 00:32:22,940
in this clone method it's not required because in fact this is the only time really uh it's

414
00:32:22,940 --> 00:32:29,180
ideal to simply for an array when i mean the only time it's ideal to use uh the clone method directly

415
00:32:29,180 --> 00:32:34,860
in the superclass object the Joshua block states calling clone on an array returns an array whose

416
00:32:34,860 --> 00:32:42,220
runtime and compile time types are identical to those of the array being cloned this is the preferred

417
00:32:42,220 --> 00:32:48,620
idiom to duplicate an array in fact in fact arrays are the sole compelling use of the clone facility

418
00:32:48,620 --> 00:32:54,460
and the other point is recursively calling the clone method will not work for final fields for

419
00:32:54,460 --> 00:33:02,700
example if let's say uh private final object element so if we go here and if we set this to be final

420
00:33:03,180 --> 00:33:08,380
you'll see an array is going to be thrown here because you can't override the values uh in a final

421
00:33:08,380 --> 00:33:15,420
field uh or overwrite all the values the memory instance in a final field and that's because

422
00:33:15,420 --> 00:33:21,580
uh as Chajipiti states in order to create a proper deep clone you must create a new instance of the

423
00:33:21,580 --> 00:33:27,020
mutable object and assign it to the field in the clone object however with a final field you

424
00:33:27,740 --> 00:33:33,420
can't reassign a new value after initialization which can lead to incorrect behavior or shared

425
00:33:33,420 --> 00:33:39,900
state between the original object and it's cloned and then to end this part of the video this is a

426
00:33:39,900 --> 00:33:46,700
fundamental problem like serialization uh in the cloneable architecture because the cloneable

427
00:33:46,700 --> 00:33:51,180
architecture is the is incompatible with normal the use of final fields referring to mutable

428
00:33:51,180 --> 00:33:56,380
objects except in cases where the mutable objects may be safely shared between an object

429
00:33:56,380 --> 00:34:02,540
and its clone in order to make a class cloneable it may be necessary to remove final mortifiers

430
00:34:02,540 --> 00:34:07,980
from some fields so that's a little caveat there okay that is part one uh just want to

431
00:34:07,980 --> 00:34:15,100
I guess kind of apologize if I didn't properly convey the this part here about the reflections

432
00:34:15,100 --> 00:34:20,140
because that was it did complicate me a little bit because at first the way I've written the code

433
00:34:20,140 --> 00:34:26,780
the demo it wasn't really accurate because the idea was to reflect on the object superclass not to

434
00:34:26,780 --> 00:34:35,180
reflect on the object at hand per se but I think it's still the important point there was it's not

435
00:34:35,820 --> 00:34:41,260
recommended to use reflections and try to use the object the superclass objects clone method

436
00:34:41,820 --> 00:34:46,220
best thing to do is to implement the cloneable interface and then just override it and define

437
00:34:46,220 --> 00:34:53,340
your own clone method all righty that's it for part one of item 13 override clone judiciously

438
00:34:53,340 --> 00:35:00,060
judiciously it's a hard word to pronounce um and I hope I was being judicious in expanding and

439
00:35:00,060 --> 00:35:06,220
explaining the concepts in this item but I shall continue on with the rest of this item in part two

440
00:35:07,340 --> 00:35:11,580
uh saying all that yeah thanks for watching and I hope you got some value from it I'll see you in the

441
00:35:11,580 --> 00:35:15,580
next one cheers

