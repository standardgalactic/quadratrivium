{"text": " Hey, everyone, welcome to part two of item 10, obey the general contract when overriding equals of Joshua Bloch's effective Java. Needless to say, please do watch part one to make sense of this item, because it's just a follow on from from part one. And I'll be working down this item into multiple parts, because it's quite long. But without further ado, let's get started, because this is quite a long part. So in the previous part, we discussed when it's appropriate or warranted to not override the equals method. Generally, it's always a good idea to override the equals method. However, there are certain instances where it's not required. And we discussed that in part one. And in part two, today, we're primarily going to focus on when is it appropriate to override the equals method. And afterwards, kind of kind of gonna, we're gonna go into detail as to what the general contract is. So firstly, I propose when it's appropriate to override the equals method, Joshua Bloch states, it's appropriate when a class has a notion of logical equality that differs from mere object identity, and a superclass has not already overridden equals. So we did discuss what logical equality was in the previous part. But for all intents and purposes, as a Java programmer, what we care about is in logical equality, a programmer doesn't care about the memory reference or the the quality of the object per se, but rather the content or the value of an object. The easiest way to put that is by looking at classes such as string or integer, where if we take, in fact, string, string objects are immutable. So there's only one object of this type that exists in memory and everything else will point to that. So in this context, when it comes to logical equality, what we care about really isn't the object per se, whatever the data of that object is, however, the value of the object. So we should only care about this bit here. And that means it's logical equality. So if you have string s, and then we also have, let's say, that was a mistake, a string b, let's say, both these strings, s and b, have logical equality because the content is the same. So these classes have a notion of logical equality. And then he states, not only is overriding the equals method necessary to satisfy programmer expectations, it enables instances to serve as map keys or set elements with predictable, desirable behavior. And then he adds an ancillary point saying that enums or enum objects are an exception to this value class heuristic, I coined that term value class heuristic, he doesn't really use that term. But I feel like to understand the concept of logical equality, apropos Java programming, that is a good heuristic to keep in mind. So enums, though, are an exception. That's what he states. And just to get some formalities out of the way, let's say, according to the Java language specifications 8.9, here's how an enum is defined. An enum type has no instances other than those defined by its enum constants. It is a compile time error to attempt to explicitly instantiate an enum type. The final clone method in enum ensures that enum constants can never be cloned. And the special treatment by the serialization mechanism ensures that duplicate, duplicate instances are never created as a result of deserialization. Reflective instantiation of so that's from the Java Reflections API. Reflective instantiation of enum types is prohibited. By the way, what that API, the Reflections API does is it changes the structure of classes on runtime. It is not something a normal Java programmer would do. It's mostly used by framework designers. So I've never used the Reflections API, but it's just good to keep good to keep in mind what it does. Anyway, getting back to the definition, sorry for interrupting it. Reflective instantiations of enum types is prohibited. Together, these four things ensure that no instances of an enum type exist beyond those defined by the enum constants. And again, attending to our point, it's for these classes, so enums, logical equality is the same as object identity. So objects equals method functions as logical equals method. What that would mean really is, if let's say this S and B were enums, if the objects were identical, we could say for all intents and purposes, there's also logical equality. So here's a small demo. Let's take a look at it that I put together. So I have two enums here. Day and day two both have days of a week. Now, if I do run this, it's going to print false because there's no logical equality in this case because there's no object identity. However, let's say I create two instances of day. Day dot, was it Monday? Yeah. And then I'll also create another day two with the same thing, with the same day. You'll see here, if I print this out, if I do compare these two objects, it'll print true because the logical equality here equates to the object identity. So I'll just go day one, day two. I'll comment that out. You'll see a true being printed now. That's it. So the object identity equates to the logical equality. And that makes sense. So reiterating that point, so the idea really settles in our mind, overriding the equals method is required or is appropriate when logical equality differs to object identity. Now, I accept the enums class, of course. Whenever we know that object identity is not equate to logical equality, override the equals method. And that gets us to the general contract when overriding the equals method. And that's what we're going to discuss for the rest of this part. And in fact, the next part too. And there's a lot to get into here. All right, before we get to the properties that define this general contract, I need to skip ahead a bit and read a caveat that Joshua Block has put in. Because in fact, I wish you would have put that bit earlier before getting to the properties because the caveat is a good starting point in understanding these properties. Because it's really important that we don't ignore them. They can be a bit overwhelming to understand. Nevertheless, ignoring them isn't the solution. It's enduring through and assisting and trying to make sense of them and implementing them in our code. So here's a caveat Joshua Block has put in. Unless you are mathematically inclined, this might look a bit scary. So what he means by that is the properties that he listed down or enumerated. But do not ignore it. So don't ignore these properties. If you violate it, you may well find that your program behaves radically or crashes. It can be very, very difficult to pin down the source of the failure. To paraphrase John Donne, is that how you pronounce his surname? D-O-N-N-E. John Donne, probably. No class is an island. Instances of one class are frequently passed to another. Many classes, including all collections classes, depend on the objects passed to them obeying the equals contract. Just on that point, there's a really interesting kind of philosophy in object-oriented programming. And I think even Alan Kay, the inventor of OOP, he makes this idea that I'm going to get a book. I was reading this book by Sandy Metz, which is a book on object-oriented design, but using Ruby. And what she states in this book is that it's better to conceptualize object-oriented programming more as message-oriented programming. And even Alan Kay, I believe, said in one of his talks that he wished that people emphasize the importance of messages between objects than objects themselves, which is the point that Joshua Blocks making here, all these contracts, all these properties that define these contracts that we ought to respect and take into account when writing code, they're more about the messages and how objects communicate with each other. Therefore, it requires a bit of a change of mindset. In any case, I don't want to get too carried away, but I thought that was an important point to add on to what we're discussing here. So given that we've got that caveat slash warning out of the way, let's get to the specifications for the contract. The equals method implements an equivalence relation. It has these properties. So there are six properties, sorry, five properties. And in this part, we're going to discuss three of them, especially because symmetry, sorry, not symmetry, transitivity is quite a loan property and there's a lot to discuss there. So, and then in part three, we'll discuss consistency and non-nullity. However, that's later on. Let's stay on track here. So what is equivalence relation? And what does it mean to have equivalence relation between two sets? Look, Joshua Bloch puts it best. Here's what he states. Lucy speaking, so this is pertaining to equivalence relation, which the equals method implements. It's an operator that partitions a set of elements into subsets whose elements are deemed equal to one another. These subsets are known as equivalence classes. For an equals method to be useful, all of the elements in such equivalence class must be interchangeable from the perspective of the user. Sorry about that background noise. It gets so annoyed by this because I live in a very quiet neighborhood, but every time I record a bloody video, there's some noise outside. In any case, so what he means by for an equals method to be useful, all of the elements in each equals class must be interchangeable from the perspective of the user means again, going back to the string, from the perspective of the user, both these objects have logical equality and that's what necessitates equivalence relation. Saying that, let's get to the first item or the the first property that pertains to the general contract. Oh gosh, man. The noise is not ending. Is that a leaf blower or lawn mower? What the hell is it? Okay, part and parcel of living in a suburb. Hey, look, I look, I'm not complaining though, it's way better than the city. Ah, it ended. No, it didn't. I'm just gonna wait till it ends. I think it ended. Back to it. So, reflexivity. Ah, he's starting. Dude, the guy's trolling me. The guy's trolling me. You know what? I can't, I can't do this. We're just gonna keep going. I apologize about the background noise. So, starting off with the first property, reflexes. See, I got distracted. Reflexivity. Okay, what does that mean? What does reflexivity mean? I've got to be really flexible here right now. So, that means for any non-null reference, value x should equate to x. So, it's saying that an object x should be equal to itself, which kind of seems self-evident. So, if we have a x equals x, it must return true. Which is why, which is why Joshua Bloch states, the first requirement, say, is merely that an object must be equal to itself. It's hard to imagine violating this one unintentionally. If you were to violate it and then add an instance of your class to a collection, the contains method might well say that the collection didn't contain the instance that you just added. So, let's take a look at a quick demo, because obviously code makes more sense than theory, even though we are, I personally always like starting with theory, because it really helps to start high level. Where is this? So, if we go to reflexivity, it's really simple as this. So, I have a list of strings here, and what we're doing is we're adding the word Java into that list. So, it's a set, let's say, it's a string, and if you run this, it'll return true, because we're just checking if this set, this list, contains, using the contains method that's in the, using the, sorry, I bit my tongue, using the contains method in the object class. It's checking if Java exists in that list, and obviously it does. That's pretty much what reflexivity is. So, the next, if I have a hard word for me to pronounce. So, the next one is symmetry. So, symmetry states, again, for any non-null reference values x and y, so we have two objects in this case, x equals y must return true, if and only if y equals x returns true. So, again, going back to, I'm going to demo it in a bit, but going back to this here, s, s and b, so string s, so string s, if we take this, equals b. This should return true only if b dot equals s returns true. So, that's what symmetry is. And before we get to the demo, let's just read out this bit, just should look at stated. The second requirement says that any two objects must agree on whether they are equal. Unlike the first requirement, it's not hard to imagine violating this one unintentionally. So, we have this class here called case and sensitive string, and it's an attempt to implement a case and sensitive string class. In the class, what we have is we have a private final string s variable. We have the constructor, which in this case just checks if the object is non-null, if it is null, it returns a chosen error, and then it sets that value in our private field here in the class. And then we have the equals method that we have overridden, which breaks symmetry. So, firstly, I'll show the one, but the problem, I'll show the wrong way to do it. And then we also have another equals method written below here, which is the proper way to do it. And that'll fix the issue. So, let's take a look at this equals method that we've overridden. So, we have two if conditions here in the equals method. In the first one, what we're checking is if this object v pass is an instance of the case in sensitive class. So, that's what we're checking here using the instance of method. And if it is, then it'll just return true if that. So, firstly, we cast that object into case in sensitive string. If it is an instance of that, let's say a subclass of that, then we cast it to become a case in sensitive string. And then we compare it to our string field really that we defined here in line number 15. And if it is equals in that case, we return true. And that's fine. That's going to work. But then we're trying to go one step further and attempting to make this interoperable with a string class. So, again, the same way we're checking if this past object is an instance of the string class. And then we are saying return true if it's equal to a string. And we just cast it accordingly. And this is what breaks the symmetry. And I'll show you what that means. And of course, this line here, if it doesn't meet all these conditions, it'll return false. So, in the public static void main, what I have is I have an instance of case in sensitive string. And then I have another normal string instance. What we're doing initially is we're checking if this case in sensitive string is equal to s. And that will return true as expected because we're passing the word Polish here, the string Polish, and the string itself has Polish. And even though the first letter is uppercase, and here it's not uppercase, it's lowercase, it doesn't matter because this equality, what we're doing, the logical equality, what we care about is for it to be case in sensitive. We don't care about the case. But here, this is where the symmetry is violated. Because we are attempting in I equals method for this to be interoperable with normal strings, we're doing the comparison the other way around instead of comparing sys with s, we're comparing s with sys, and this returns false. Furthermore, if we add this string, I don't want to call it a string because it's a case in sensitive string, into a list of type case in sensitive string, it's a bit of a mouthful. And be printed, we expect this to return true, but it doesn't, it returns false. So that again demonstrates the violation of symmetry because the contains method uses the concept of logical equality, and we don't have logical equality here. So if I do run this, you'll see it'll return true false false. Right there. So this is the problem. Now, before I get to the fix, let me read out to put it a bit more formally and cleanly what Joshua Bloch has stated. He states, as expected, so he's referring to this bit here, as expected, sys dot equals s returns true. The problem is that while the equals method in case in case in sensitive string knows about ordinary strings, the equals method in string is oblivious to case in sensitive strings. So that is the equals method that we're going to use here in this slide that we use. Therefore s dot equals says returns false. So he's referring to that bit here now where it returns false. A clear violation of symmetry, suppose you put a case in sensitive string into a collection. So that's where moving on to the next bit here, which we again see that it's returning false. And this is a bit difficult to understand because here's what Joshua Bloch states on the contains method. Now, I was under the, well, I guess my assumption is right. My assumption was that because this violates the equals contract and the idea of logical equality and the contains method use ensures that objects that it gets respect this contract. It acts accordingly. Therefore why it's printing false here or it's returning false here. But here's what Joshua Bloch states. And I think my assumption is at least quasi accurate. What does list dot contains s return at this point? And then he says, who knows? In the current open JDK implementation, it happens to return false. So that's what we saw here. The third false is by this list dot contains. But that's just an implementation artifact. In another implementation, it could just as easily return true or throw a runtime exception. Once you violated the equals contract, you simply don't know how other objects will behave when confronted with your object. To eliminate the problem, merely remove the ill-conceived attempt to interoperate with string from the equals method. I shouldn't have read that part yet. I'll read that again, but that's how we fix the problem. So I'm going to read that bit again, though. Once you violated the equals contract, you simply don't know how other objects will behave when confronted with your object. This goes back to the idea I touched on a bit before by Sandy Metz on the book I was referring to, the Ruby book, that it's probably the best way to think about OOP is in the context of messages and how objects interact with each other over objects because objects aren't an island as we read from John Dunn. So that's what happens here. The contains method makes a lot of assumptions and those assumptions are wrong because, well, the assumptions aren't really wrong, but we've made a mistake in our object. Therefore, it breaks things. There's no logical equality. Now, getting back to how we fix this, as I did read that line, which I shall reread, it's simply ensuring that we don't try and attempt for the case in sensitive string objects to interoperate with string objects. And the way we do that is, I'm going to comment out this equals method because we can't have two equals method in the same class equals methods in the same class, unless it's overloaded. And then I'm going to get the other equals method, which doesn't attempt to override. Oops. Doesn't attempt to not override to interoperate with strings. It simply checks if it's an instance of case in sensitive string and then casts the case in sensitive string and just the normal equals ignoring the case. So now, if I run this bit here, you'll see I'm going to comment out these lines because they're, in fact, actually, no, maybe what I should do is I'm going to go and run the whole thing. And now the first three are printing faults and we expect it to print faults. We want it to because we don't want any interoperability with strings. And then in the second one, we're checking if it's equals and we're seeing if sys equals this new string we've created, again, Polish. And then we're checking if sys equals the other way around. We're checking for the symmetry. So you can see here in line number 53, it's uppercase p. And in line number, oh, that's a mistake, actually. That should have been lower case. Now, we can truly demonstrate the point. So if it's lower case here, line number 37, it's still ignoring that and printing true in these two lines. So line number 54, 55, correlate to these second true statements. I hope that made sense. So rereading what Joshua Bloch wrote, to eliminate the problem, merely remove the ill-conceived attempt to interoperate with string from the equals method. And now we move to the longest property from all the ones that Joshua Bloch has enumerated. And I had to take a smaller break just to refresh myself because this property is four or five pages. So there's a bit to go through. But let's get started. You know, the only way to get started is to get started. Wow, brilliant, brilliant. So what does this transitivity property states? Some of these words are a bit hard to pronounce. It's not going to lie. It states transitivity states, for any non-null reference, values x, y and z, if x equals y returns true and y equals z returns true, then x equals z must also return true. Or simply it's that if we have three objects with the content being same, three string objects, let's say, they should all print true when compared to each other. Simple as that because we require the logical equality there. Now, before we get to the demos and we demonstrate how this can go wrong and how to fix it, and even in fact some inherent flaws with Java and object-oriented programming, we got to get some theory out of the way. So should I read this out first? Let me think. Okay, I'll first read out a bit of like an introduction to this property from the book. Here's what Joshua Block states. Transportation pertaining to transitivity. If one object is equal to a second and the second object is equal to a third, then the first object must be equal to the third as we showed here. But as I said before we continue, let's get some theory out of the way. So something important to understand for this property is the Liskov substitution principle. The Liskov substitution principle is probably popularized by Robert C. Martin and his solid design principles. And of course, Barbara Liskov. Is that her name? I believe that's her name. Barbara Liskov. Yes, she is the scientist who invented this principle and made the contribution into the field of computer science. Here's how Robert C. Martin summarizes the Liskov substitution principle. Subtypes must be substitutable for their base types. And of course, I've got an example here that I use strategy PD to generate, to demo this principle simply. And then a bit more formally, let's say a bit more mathematical definition, Barbara Liskov defines it like this, which she did in 1988. If for each object O1 of type S, there's an object O2 of type T such that for all programs P defined in terms of T, the behavior of P is such of P is unchanged when O1 is substituted for O2, then S is a subtype of T. So another way of putting it is that if S is a subtype of T, then the behavior of O1 can be substituted for the behavior of O2, which are two objects. An example of that would be, again, generated by strategy PD. Thank you. Open AI and strategy PD, not to anthropomorphize it, but nevertheless, thank you. We have a class animal with a public void move method, and then we have a subclass. We subclass the animal class by dog, dog extends animal. And then we define a method that makes the animal move. So the subclass has a method called make animal move, which takes a object of type animal of the, that's not the sub, that's a subtype, not the, sorry, that's the supertype. And then this method, in fact, this method should be inside the, that was, I made it, it's not my fault, it's strategy PD's fault. If we put it in there, so it probably exists inside the dog class, and we create a new dog object, and then this method make animal move can take in an animal typed object too, because it respects the list called substitution principle or it owed to, because dog is a subtype of the supertype animal. It's quite straightforward, actually. And I think the best way to think about it is how Robert C. Martin put said subtypes must be substitutable for their base types. So now let's get to the demo that Joshua Block has used in the book. There are many classes to go through, but let's start off with the point class. So here's what Joshua Block states. Consider the case of a subclass that adds a new value component to its superclass. In other words, the subclass adds a piece of information that affects the equals comparison. What we have here is this public class. This class is going to be the superclass that we're going to use. It's a concrete class. Keep that in mind, because the idea or the juxtaposition of a concrete class with a abstract class, that's something we're going to catch on later on in this part. So we have the concrete class point, which is simply an immutable two dimensional integer point class. We've got x and y privately defined, we have constructor, and then you have an equals method, which just the equality. Similar to what we discussed in the previous example with symmetry, checks if it's an instance, and then returns true if there's equality. Now let's suppose that we want to enhance the ability of the point class. Therefore, we subclass it and we have this color point class that extends the point class, and it attempts to add a value component to point. In this case, it's the value component of color. We want the points to also have color. Now what would this class look like? Or more importantly, what would the equals method look like for the color point class? That is a subclass of point. In this case, we have a normal constructor. We have line number 14 that invokes the constructor in the superclass. That's what this super keyword does, and we can do that for x and y, those coordinates. But here, since we're introducing this value component, we want to initialize the color component to when constructing the object. But then we come to the equals method that clearly violates the symmetry of the symmetry principle or the symmetry properties. Well, for starters, of course, we can't use the equals method from the superclass because the superclass did not even have a color field. Therefore, it would break the idea of logical equality if we just inherit that method. Therefore, we need to override the equals method in the subclass color point. But in this equals method, it violates symmetry because, yes, we're invoking the equals method in the superclass, and then we're even doing a check for the color point equality here by casting that object the color point type. Because if it is an instance, in that case, oh, yes, because if it's not an instance, it'll return false. But it's a one-way comparison. So if you look at the implementation or a client using it, and if I run this, you'll see the first comparison will return true because that's fine. We're comparing point and we're passing the color point object, that's okay. But the second one will return false because in this case, we are typing or we are passing the supertype object. So it's a clear violation of symmetry. And that's why Joshua Bloch states, the problem with this method and what he means by this method is this implementation of the overrides method we have here is that you might get different results when comparing a point to a color point and vice versa. The former comparison ignores color while the latter comparison always returns false because the type of the argument is incorrect. So what he means by the former comparison ignores color is that in this ampersand, the end statement here, that's the former comparison where it's simply invoking the equals method in the superclass and it's doing a basic equality test. But in that equality test, we are ignoring color completely. So it'll return true if it is an object of proper type. And that, again, doesn't give us what we want. It breaks logical equality. And in the second one, the problem is it'll never even get to the second one because we check if this object is an instance of color point. And if it's not, it'll always return false. Therefore, whenever we pass anything that's not of type color point, it'll return false. And that also violates not only symmetry, but even the less substitution principle. So then we're trying to fix this. What we're trying to fix this is we're trying to resolve this issue with violating symmetry. And that fix also unfortunately doesn't work because it violates the transitivity property and we shall see what that fix looks like. So by trying to fix the issue with symmetry, we unfortunately violate transitivity. In this case, in this new equals method that we overrode, we in fact are considering objects that are of a different type to color point. We're checking if initially if it's a normal point, if it's a normal point, we're doing a color blind comparison. Great. And if it's a color point, then like the previous one, we consider color and then do a comparison. And absolutely if it's not an instance of either point or color point, it'll just return false. So in this case, symmetry ticked. However, unfortunately, as we shall see from the implementation, it does violate transitivity. So in this comparison, we have three objects. We have two color point objects and a point object. So in the P1 equals P2 comparison, that's fine. It returns true. Also in the P2 equals P3 comparison, that also returns true. However, then comes the transitivity issue in the P1 equals P3 comparison, it returns false. I totally got the wrong. I read that as if that's what was expected. In fact, that was not what's expected because there's no logical equality there. We're trying to compare P1 with P2 and it's returning true. It should return false because obviously P1 has that added value component of color and P2 doesn't have that. So that's wrong. It shouldn't return true. And it shouldn't in the second comparison, where we compare again, a point and a color point, it's returning true again, it shouldn't. And okay, the third one's fine because the third one, it's doing a proper comparison between P1 and P3, which are both type of color point. And it's returning false, which is expected because the color is different. That's okay, but these two are a problem. So which is why Joshua Bloch states, this approach just provides symmetry, but at the expense. So I don't think I read the previous bit. So just to add on to what he was saying about the override method, he says, this method here, he says, you might try to fix the problem by having color point or equals ignore color when doing mixed comparisons. And that's what we're doing in this condition here, where we're doing a color blind comparison by using the instance of method. So even a point can be passed on to this object of type point. And then he continues, now, so what we discussed here before, now P1 equals P2 when P2 equals P3 returns true, where it shouldn't, while P1 equals P3 returns false, a clear violation of transitivity. The first two comparisons are color blind, while the third takes color into account, and that shouldn't be the case. So what do we do here? We've got this huge object oriented predicament, or for us programmers, even a existential crisis, what are we going to do? What's the solution? He says, it turns out that this is a fundamental problem of equivalence relations in object oriented languages. This is kind of what I said before. There's no way to extend an insensiable, insensiable class and add a value component while preserving the equals contract. The problem again, the big problem is in our design, where we may point a concrete class. And we shall see why it should have been made a abstract class instead. But later, sorry, I'm getting a bit carried away. Let's stay on track. Again, re-reading that point because it's important. There's no way to extend an insensiable class, insensiable class and add a value component while preserving the equals contract, unless you're willing to forego the benefits of object oriented abstraction. And then Joshua Block states that we might try to circumvent this issue in a bit of a sly way by trying to use Java's reflexive API or reflections API. In any case, it's changing the class on runtime, which is what I tried to demonstrate with the second equals method, which we think would work. So if I do, whoops, I shouldn't have clicked that. If I do look at this equals method, I'll comment this out. We're using the dot get class method from the Reflections API. Okay, before we get to that, let me quickly read out some theory. What is get class in Java? Again, according to chat GPT, here's what get class is. In Java, the get class method is a method of the object class that returns the runtime class of an object. Correct. It returns an object of type class, which is a class in the Java reflection API that represents a class or interface in the Java programming language. This in fact is very accurate, which is amazing because if you look at the Oracle docs and whatnot, chat GPT puts it in a more simpler way to understand. An example would be here, if we have this employee class or the employee object of type employee, if we go and they have another class, which we get, we get the class of employee and save it. We don't even really have to do this. We could just go employee dot get class really. We could just skip this step and go employee dot get class dot get name. And then return the name of the class. And that's done runtime by getting the type of the object. So we're trying to circumvent this issue by using the Reflections API, where we're saying only if it's a type of the implementation of that object. So we're checking the class of the object we pass on to the equals method, and then we're checking the class of the current object's runtime. So we're comparing two objects here, the object of this class, the broader class, and then the object we are passing on to the equals method, and then we're doing the comparison. Unfortunately, this is not going to work, because it violates the less-carved substitution principle and breaks logical equality, which is why Joshua Block states, this effect has the effect of equating objects only if they have the same implementation class. So which is why we're checking here for the type of the implementation class. This may not seem so bad, but the consequences are unacceptable. An instance of a subclass of point is still a point. So an instance of point, for example, like call point is still a point, and it should work with this equals method, but it doesn't. And it still needs to function as one, but it fails to do so if you take this approach. Now let's take a look at an example where we're trying to tell whether a point is on the unit circle. Here's an example. So what this counterpoint test is trying to do is to see if this is a point. This point class is a point on a unit circle. We're creating a set of type point, and we're adding some points into it. And then we have this public static Boolean, which returns a true false, that checks if this point is a point on a circle. And we're doing that by returning true if whatever point that we pass on to this method is contained in this set, the unit circle set. Initially here, it'll print true. It'll print true because it's of type point. But because our point class, we use the reflections API and used get class. When we pass something, a subtype of kind of point, which again, if it did respect or follow the less curve substitution principle, it should still print true because it's still a type of point and it should behave as such. It'll print false, unfortunately. There we go. In the second one, it's printing false. And this is a clear violation of the principle. Therefore, using get class and the reflections API is still not the way to circumvent this issue with object oriented languages. So again, I know we discussed the less curve substitution principle before, but in the book Joshua Block states the less curve substitution principle says that any important property of a type should also hold for all its subtypes so that any method written for the type should work equally well on its subtypes. And this is the formal statement of our earlier claim that a subclass of point, such as counterpoint, is still a point and must act as one. Now let's take a look at the problem with this. I mean, let's take a look at not the problem with the less curve substitution principle, but the problem with not following this principle. So we have this trivial class here that really does nothing. It doesn't really add a value component. It simply keeps track of how many instances of, of, it's called counterpoint, which keeps track of how many instances of point are created. If you don't know an atomic integer is a thread safe counter, a variable which you can increase. So simply every time an instance of counterpoint is created, we also we're invoking even the the super class, the point in this case, and then we can get account of how many instances of point were created because of this atomic counter. So again, counterpoint is a subtype of point. Apologies, I demoed this bit a bit earlier before, and I think I used the word color point by mistake. I think I should have said counterpoint. It's just both counterpoint and color point are subtypes of point. But as you saw before, it also returned faults, because we've got a problem with, we haven't got a problem with, sorry, I was going to say we've got a problem with the, with the contains method. The contains method exactly behaves the way it's supposed to, but we have a, we have a violation of the less curve substitution principle, which is why it's training faults. Again, I apologize if I confused you by stating color point, I meant to say counterpoint, which is this class that this is a, this is a useless class really. It just invokes the constructor in the superclass point and then keeps track of how many objects of point have been created. But why, so the question of course is why do we get this second false here, despite counterpoint being a subtype of point, it is because of this. Because most collections, so set is a collection here of type point, including the hash set that we used here by the own unit circle method, use the equals method to test for containment. And no kind of point instance is equal, equal to any point. And why is that? That is because, as I said before, we're using get class here. And if, if counterpoint is not of type point, we aren't gonna, it's going to return faults. So therefore, that's why we get a false here too, which the, sorry, it's a wrong one. We get a false here too, which the contains method uses the equals method in the object, in the point object. And that's why Joshua Bloch states, if however, you use a proper instance of base equals method on point, the same onion cycles circle method works fine when presented with a counterpoint instance. And let's take a look at that. So on point, instead of using this equals method that uses get class, if we go back to the previous one that uses instance of, because instance of does consider even subtypes. And if we run this again, we'll get two truths. So in that case, it's behaving as expected. So unfortunately, there's no way getting around this, we should all give up programming. And just quit quit because life is meaningless. Everything is futile. I'm kidding. I'm kidding. I'm kidding. Life is meaningless and everything is futile. But in true Nietzschean essence, we ought to create our own meaning, which is why we're going to use the good old object oriented principle and favor composition over inheritance to circumvent this issue with which is inherent to object oriented languages. So let's take a look at this example, a class color point where we don't do any kind of extension or any kind of inheritance, we're in fact using composition. So in this new color point, which don't get this confused to the one that we use for inheritance, as you can see from the package, this is in a separate package called composition. But in this new color point that uses composition, we have a instance of point defined. And we have an instance of color, which this is a enum, by the way, that holds some some colors. And we have these two instances defined. And then in our constructor, we have a new instance of point being created. And we assign that, of course, to the private private field in our class, we do the same thing with color, new instance. Sorry, in this case, we don't create a new instance of color, we expect the client to pass us a proper object of type color. And then we return the point of this color point, just this again, what the client expects. And then the equals method, because we is in composition, it's not an issue, we just check if it's an instance of color point. And then we do the casting accordingly, if it is an instance of color point, the object we pass onto the equals method, then we do a proper comparison, where we do both the comparison between between the type point of color point, because this we get from here. And also a comparison between color. So the color has to be true, and the point has to be true. And if they both are fulfilled by the double ampersand and operator, it returns true. And that solves a problem. So if you look at this test class, for instance, I'm going to run this test class, I've done something really ugly here. In one file, I've defined two classes, you should never do that. In fact, there's one item where Joshua Block talks about that later on. It's bad programming etiquette. So in the counterpoint test, again, I've screwed this up, it should be color point test. This is a bit confusing, I apologize. In the color point test, we've similarly have a hash set that we've created of type point. And then we're doing the same thing we did in the previous test, we're checking if the point we pass contains this object P in this hash set. And then if you run this, the difference here though is firstly, if I run this, you'll see they both print true. That's because we're using composition. And what it does is though, when we are adding it, when we're adding a new color point, we do use this additional method saying add this, however, as a point though. So that changes things because now we're saying it's still, we're still adding something of type color point, but we're using this method here, which adds as a point. And it returns that point that we've defined here, which is what we do in the constructor. And even though we still have this value color in this private field here, which we can use. So that's how we circumvent the issue. Interestingly, Joshua Bloch states that there has been historical errors where, for instance, in the date and the SQL timestamp classes, so in the utilities and the SQL packages, they've made the mistake of use having implementations of the equals method that violate symmetry and that this causes erratic behavior. And he says the equals implementation for timestamp does violate symmetry and can cause erratic behavior if timestamp and date objects are used in the same collection or otherwise intermixed. This behavior of the timestamp class was a mistake and should not be emulated. So again, it's because of the inherent drawback in object oriented languages, these kind of mistakes happen. However, in many circumstances, using composition over inheritance, the way we showed in the composition-paste color point class is a way of getting around that. And then we get to the interesting idea or the interesting notion of using an abstract class instead of a superclass. And simply, the reason we can add value components to a subclass of an abstract class is that you can't instantiate an abstract class. So that really solves a lot of the problems we have with using the concrete point superclass. So in this case, we have an abstract class shape, which has two protected values, so x and y, and we have a constructor, and then we have two concrete subclasses that extend the shape class. And we've got circle and rectangle, where's the other one? Yeah, circle and rectangle, where in the circle one, we are adding a radius, and in the rectangle one, we are adding length and width. And in the constructor, of course, we are invoking the constructor of the superclass, which is shape. The issue is quite straightforward. We can create a concrete object of this concrete class rectangle. However, if you try to, that's a typo, try to instantiate the shape class, it says you get a compile time error, say you can't instantiate abstract shape classes, which is why this is a way to get around this issue, where Joshua Bloch states, when adding a value component, note that you can add a value component to a subclass of an abstract class without violating the equals contract. This is important for this sort of class hierarchies that you get by following the advice in item 23, preferred class hierarchies to tack classes. I'm not going to go into too much detail on that, because we're going to be covering item 23 next year. And then he says, for example, he could have an abstract class, so what I pretty much described here, I'll just read it out again. For example, he could have an abstract class shape with no value components, a subclass circle, that adds a radius field and a subclass rectangle that adds a length and width fields. Problem of the sort shown earlier won't occur so long as it is impossible to create a super class instance directly. That's it. That is the property of transitivity as to how we try and follow it to ensure that we follow the, or we abide by the general contract of the equals method, and even discussing the inherent problems with OP languages. But saying that, there are also two other properties that we need to follow, which is consistency and non-nullity. There are a lot more shorter than this one, but I'm quite tired. So we're going to cover that in part three. But I hope this made sense. I was from my best to get this across. I found this quite interesting, though. I really enjoyed this transitivity bit. So I shall see you in the next one. Thanks for watching, and I hope you gain some value from it. Cheers.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 6.8, "text": " Hey, everyone, welcome to part two of item 10, obey the general contract when overriding", "tokens": [50364, 1911, 11, 1518, 11, 2928, 281, 644, 732, 295, 3174, 1266, 11, 19297, 264, 2674, 4364, 562, 670, 81, 2819, 50704], "temperature": 0.0, "avg_logprob": -0.13351785090931675, "compression_ratio": 1.6254545454545455, "no_speech_prob": 0.06921209394931793}, {"id": 1, "seek": 0, "start": 6.8, "end": 13.84, "text": " equals of Joshua Bloch's effective Java. Needless to say, please do watch part one to", "tokens": [50704, 6915, 295, 24005, 9865, 339, 311, 4942, 10745, 13, 16984, 1832, 281, 584, 11, 1767, 360, 1159, 644, 472, 281, 51056], "temperature": 0.0, "avg_logprob": -0.13351785090931675, "compression_ratio": 1.6254545454545455, "no_speech_prob": 0.06921209394931793}, {"id": 2, "seek": 0, "start": 13.84, "end": 18.8, "text": " make sense of this item, because it's just a follow on from from part one. And I'll be", "tokens": [51056, 652, 2020, 295, 341, 3174, 11, 570, 309, 311, 445, 257, 1524, 322, 490, 490, 644, 472, 13, 400, 286, 603, 312, 51304], "temperature": 0.0, "avg_logprob": -0.13351785090931675, "compression_ratio": 1.6254545454545455, "no_speech_prob": 0.06921209394931793}, {"id": 3, "seek": 0, "start": 18.8, "end": 22.16, "text": " working down this item into multiple parts, because it's quite long. But without further", "tokens": [51304, 1364, 760, 341, 3174, 666, 3866, 3166, 11, 570, 309, 311, 1596, 938, 13, 583, 1553, 3052, 51472], "temperature": 0.0, "avg_logprob": -0.13351785090931675, "compression_ratio": 1.6254545454545455, "no_speech_prob": 0.06921209394931793}, {"id": 4, "seek": 0, "start": 22.16, "end": 26.96, "text": " ado, let's get started, because this is quite a long part. So in the previous part, we discussed", "tokens": [51472, 22450, 11, 718, 311, 483, 1409, 11, 570, 341, 307, 1596, 257, 938, 644, 13, 407, 294, 264, 3894, 644, 11, 321, 7152, 51712], "temperature": 0.0, "avg_logprob": -0.13351785090931675, "compression_ratio": 1.6254545454545455, "no_speech_prob": 0.06921209394931793}, {"id": 5, "seek": 2696, "start": 27.92, "end": 35.6, "text": " when it's appropriate or warranted to not override the equals method. Generally, it's always a good", "tokens": [50412, 562, 309, 311, 6854, 420, 16354, 292, 281, 406, 42321, 264, 6915, 3170, 13, 21082, 11, 309, 311, 1009, 257, 665, 50796], "temperature": 0.0, "avg_logprob": -0.10310603760100984, "compression_ratio": 1.8151658767772512, "no_speech_prob": 0.03776634857058525}, {"id": 6, "seek": 2696, "start": 35.6, "end": 42.72, "text": " idea to override the equals method. However, there are certain instances where it's not required.", "tokens": [50796, 1558, 281, 42321, 264, 6915, 3170, 13, 2908, 11, 456, 366, 1629, 14519, 689, 309, 311, 406, 4739, 13, 51152], "temperature": 0.0, "avg_logprob": -0.10310603760100984, "compression_ratio": 1.8151658767772512, "no_speech_prob": 0.03776634857058525}, {"id": 7, "seek": 2696, "start": 42.72, "end": 48.0, "text": " And we discussed that in part one. And in part two, today, we're primarily going to focus on", "tokens": [51152, 400, 321, 7152, 300, 294, 644, 472, 13, 400, 294, 644, 732, 11, 965, 11, 321, 434, 10029, 516, 281, 1879, 322, 51416], "temperature": 0.0, "avg_logprob": -0.10310603760100984, "compression_ratio": 1.8151658767772512, "no_speech_prob": 0.03776634857058525}, {"id": 8, "seek": 2696, "start": 48.0, "end": 53.36, "text": " when is it appropriate to override the equals method. And afterwards, kind of kind of gonna,", "tokens": [51416, 562, 307, 309, 6854, 281, 42321, 264, 6915, 3170, 13, 400, 10543, 11, 733, 295, 733, 295, 799, 11, 51684], "temperature": 0.0, "avg_logprob": -0.10310603760100984, "compression_ratio": 1.8151658767772512, "no_speech_prob": 0.03776634857058525}, {"id": 9, "seek": 5336, "start": 53.36, "end": 58.32, "text": " we're gonna go into detail as to what the general contract is. So firstly, I propose when it's", "tokens": [50364, 321, 434, 799, 352, 666, 2607, 382, 281, 437, 264, 2674, 4364, 307, 13, 407, 27376, 11, 286, 17421, 562, 309, 311, 50612], "temperature": 0.0, "avg_logprob": -0.10019337047230113, "compression_ratio": 1.669603524229075, "no_speech_prob": 0.004197036847472191}, {"id": 10, "seek": 5336, "start": 58.32, "end": 65.12, "text": " appropriate to override the equals method, Joshua Bloch states, it's appropriate when a class has", "tokens": [50612, 6854, 281, 42321, 264, 6915, 3170, 11, 24005, 9865, 339, 4368, 11, 309, 311, 6854, 562, 257, 1508, 575, 50952], "temperature": 0.0, "avg_logprob": -0.10019337047230113, "compression_ratio": 1.669603524229075, "no_speech_prob": 0.004197036847472191}, {"id": 11, "seek": 5336, "start": 65.12, "end": 72.96000000000001, "text": " a notion of logical equality that differs from mere object identity, and a superclass has not", "tokens": [50952, 257, 10710, 295, 14978, 14949, 300, 37761, 490, 8401, 2657, 6575, 11, 293, 257, 1687, 11665, 575, 406, 51344], "temperature": 0.0, "avg_logprob": -0.10019337047230113, "compression_ratio": 1.669603524229075, "no_speech_prob": 0.004197036847472191}, {"id": 12, "seek": 5336, "start": 72.96000000000001, "end": 78.56, "text": " already overridden equals. So we did discuss what logical equality was in the previous part.", "tokens": [51344, 1217, 670, 81, 6171, 6915, 13, 407, 321, 630, 2248, 437, 14978, 14949, 390, 294, 264, 3894, 644, 13, 51624], "temperature": 0.0, "avg_logprob": -0.10019337047230113, "compression_ratio": 1.669603524229075, "no_speech_prob": 0.004197036847472191}, {"id": 13, "seek": 7856, "start": 79.12, "end": 84.96000000000001, "text": " But for all intents and purposes, as a Java programmer, what we care about is", "tokens": [50392, 583, 337, 439, 560, 791, 293, 9932, 11, 382, 257, 10745, 32116, 11, 437, 321, 1127, 466, 307, 50684], "temperature": 0.0, "avg_logprob": -0.08922338485717773, "compression_ratio": 1.6135265700483092, "no_speech_prob": 0.0325724296271801}, {"id": 14, "seek": 7856, "start": 86.48, "end": 91.68, "text": " in logical equality, a programmer doesn't care about the memory reference or the", "tokens": [50760, 294, 14978, 14949, 11, 257, 32116, 1177, 380, 1127, 466, 264, 4675, 6408, 420, 264, 51020], "temperature": 0.0, "avg_logprob": -0.08922338485717773, "compression_ratio": 1.6135265700483092, "no_speech_prob": 0.0325724296271801}, {"id": 15, "seek": 7856, "start": 91.68, "end": 97.12, "text": " the quality of the object per se, but rather the content or the value of an object.", "tokens": [51020, 264, 3125, 295, 264, 2657, 680, 369, 11, 457, 2831, 264, 2701, 420, 264, 2158, 295, 364, 2657, 13, 51292], "temperature": 0.0, "avg_logprob": -0.08922338485717773, "compression_ratio": 1.6135265700483092, "no_speech_prob": 0.0325724296271801}, {"id": 16, "seek": 7856, "start": 97.12, "end": 102.08, "text": " The easiest way to put that is by looking at classes such as string or integer, where if we", "tokens": [51292, 440, 12889, 636, 281, 829, 300, 307, 538, 1237, 412, 5359, 1270, 382, 6798, 420, 24922, 11, 689, 498, 321, 51540], "temperature": 0.0, "avg_logprob": -0.08922338485717773, "compression_ratio": 1.6135265700483092, "no_speech_prob": 0.0325724296271801}, {"id": 17, "seek": 10208, "start": 102.08, "end": 111.28, "text": " take, in fact, string, string objects are immutable. So there's only one object of this type that exists", "tokens": [50364, 747, 11, 294, 1186, 11, 6798, 11, 6798, 6565, 366, 3397, 32148, 13, 407, 456, 311, 787, 472, 2657, 295, 341, 2010, 300, 8198, 50824], "temperature": 0.0, "avg_logprob": -0.08651645896361046, "compression_ratio": 1.6956521739130435, "no_speech_prob": 0.012428605929017067}, {"id": 18, "seek": 10208, "start": 111.28, "end": 117.6, "text": " in memory and everything else will point to that. So in this context, when it comes to logical", "tokens": [50824, 294, 4675, 293, 1203, 1646, 486, 935, 281, 300, 13, 407, 294, 341, 4319, 11, 562, 309, 1487, 281, 14978, 51140], "temperature": 0.0, "avg_logprob": -0.08651645896361046, "compression_ratio": 1.6956521739130435, "no_speech_prob": 0.012428605929017067}, {"id": 19, "seek": 10208, "start": 117.6, "end": 123.75999999999999, "text": " equality, what we care about really isn't the object per se, whatever the data of that object is,", "tokens": [51140, 14949, 11, 437, 321, 1127, 466, 534, 1943, 380, 264, 2657, 680, 369, 11, 2035, 264, 1412, 295, 300, 2657, 307, 11, 51448], "temperature": 0.0, "avg_logprob": -0.08651645896361046, "compression_ratio": 1.6956521739130435, "no_speech_prob": 0.012428605929017067}, {"id": 20, "seek": 10208, "start": 123.75999999999999, "end": 130.0, "text": " however, the value of the object. So we should only care about this bit here. And that means", "tokens": [51448, 4461, 11, 264, 2158, 295, 264, 2657, 13, 407, 321, 820, 787, 1127, 466, 341, 857, 510, 13, 400, 300, 1355, 51760], "temperature": 0.0, "avg_logprob": -0.08651645896361046, "compression_ratio": 1.6956521739130435, "no_speech_prob": 0.012428605929017067}, {"id": 21, "seek": 13000, "start": 130.0, "end": 134.24, "text": " it's logical equality. So if you have string s, and then we also have, let's say,", "tokens": [50364, 309, 311, 14978, 14949, 13, 407, 498, 291, 362, 6798, 262, 11, 293, 550, 321, 611, 362, 11, 718, 311, 584, 11, 50576], "temperature": 0.0, "avg_logprob": -0.168622130439395, "compression_ratio": 1.7719298245614035, "no_speech_prob": 0.0034819303546100855}, {"id": 22, "seek": 13000, "start": 137.68, "end": 138.4, "text": " that was a mistake,", "tokens": [50748, 300, 390, 257, 6146, 11, 50784], "temperature": 0.0, "avg_logprob": -0.168622130439395, "compression_ratio": 1.7719298245614035, "no_speech_prob": 0.0034819303546100855}, {"id": 23, "seek": 13000, "start": 141.68, "end": 148.56, "text": " a string b, let's say, both these strings, s and b, have logical equality because the content is the", "tokens": [50948, 257, 6798, 272, 11, 718, 311, 584, 11, 1293, 613, 13985, 11, 262, 293, 272, 11, 362, 14978, 14949, 570, 264, 2701, 307, 264, 51292], "temperature": 0.0, "avg_logprob": -0.168622130439395, "compression_ratio": 1.7719298245614035, "no_speech_prob": 0.0034819303546100855}, {"id": 24, "seek": 13000, "start": 148.56, "end": 155.44, "text": " same. So these classes have a notion of logical equality. And then he states, not only is overriding", "tokens": [51292, 912, 13, 407, 613, 5359, 362, 257, 10710, 295, 14978, 14949, 13, 400, 550, 415, 4368, 11, 406, 787, 307, 670, 81, 2819, 51636], "temperature": 0.0, "avg_logprob": -0.168622130439395, "compression_ratio": 1.7719298245614035, "no_speech_prob": 0.0034819303546100855}, {"id": 25, "seek": 15544, "start": 155.44, "end": 162.48, "text": " the equals method necessary to satisfy programmer expectations, it enables instances to serve as", "tokens": [50364, 264, 6915, 3170, 4818, 281, 19319, 32116, 9843, 11, 309, 17077, 14519, 281, 4596, 382, 50716], "temperature": 0.0, "avg_logprob": -0.11132605131282362, "compression_ratio": 1.6283185840707965, "no_speech_prob": 0.012617540545761585}, {"id": 26, "seek": 15544, "start": 162.48, "end": 169.44, "text": " map keys or set elements with predictable, desirable behavior. And then he adds an ancillary point", "tokens": [50716, 4471, 9317, 420, 992, 4959, 365, 27737, 11, 30533, 5223, 13, 400, 550, 415, 10860, 364, 364, 7383, 822, 935, 51064], "temperature": 0.0, "avg_logprob": -0.11132605131282362, "compression_ratio": 1.6283185840707965, "no_speech_prob": 0.012617540545761585}, {"id": 27, "seek": 15544, "start": 169.44, "end": 176.0, "text": " saying that enums or enum objects are an exception to this value class heuristic,", "tokens": [51064, 1566, 300, 465, 8099, 420, 465, 449, 6565, 366, 364, 11183, 281, 341, 2158, 1508, 415, 374, 3142, 11, 51392], "temperature": 0.0, "avg_logprob": -0.11132605131282362, "compression_ratio": 1.6283185840707965, "no_speech_prob": 0.012617540545761585}, {"id": 28, "seek": 15544, "start": 176.0, "end": 180.16, "text": " I coined that term value class heuristic, he doesn't really use that term. But I feel like", "tokens": [51392, 286, 45222, 300, 1433, 2158, 1508, 415, 374, 3142, 11, 415, 1177, 380, 534, 764, 300, 1433, 13, 583, 286, 841, 411, 51600], "temperature": 0.0, "avg_logprob": -0.11132605131282362, "compression_ratio": 1.6283185840707965, "no_speech_prob": 0.012617540545761585}, {"id": 29, "seek": 18016, "start": 180.16, "end": 186.88, "text": " to understand the concept of logical equality, apropos Java programming, that is a good heuristic", "tokens": [50364, 281, 1223, 264, 3410, 295, 14978, 14949, 11, 1882, 1513, 329, 10745, 9410, 11, 300, 307, 257, 665, 415, 374, 3142, 50700], "temperature": 0.0, "avg_logprob": -0.10553216934204102, "compression_ratio": 1.5850622406639003, "no_speech_prob": 0.00884293857961893}, {"id": 30, "seek": 18016, "start": 186.88, "end": 193.28, "text": " to keep in mind. So enums, though, are an exception. That's what he states. And just to get some", "tokens": [50700, 281, 1066, 294, 1575, 13, 407, 465, 8099, 11, 1673, 11, 366, 364, 11183, 13, 663, 311, 437, 415, 4368, 13, 400, 445, 281, 483, 512, 51020], "temperature": 0.0, "avg_logprob": -0.10553216934204102, "compression_ratio": 1.5850622406639003, "no_speech_prob": 0.00884293857961893}, {"id": 31, "seek": 18016, "start": 193.28, "end": 199.35999999999999, "text": " formalities out of the way, let's say, according to the Java language specifications 8.9,", "tokens": [51020, 9860, 1088, 484, 295, 264, 636, 11, 718, 311, 584, 11, 4650, 281, 264, 10745, 2856, 29448, 1649, 13, 24, 11, 51324], "temperature": 0.0, "avg_logprob": -0.10553216934204102, "compression_ratio": 1.5850622406639003, "no_speech_prob": 0.00884293857961893}, {"id": 32, "seek": 18016, "start": 200.32, "end": 207.76, "text": " here's how an enum is defined. An enum type has no instances other than those defined by its enum", "tokens": [51372, 510, 311, 577, 364, 465, 449, 307, 7642, 13, 1107, 465, 449, 2010, 575, 572, 14519, 661, 813, 729, 7642, 538, 1080, 465, 449, 51744], "temperature": 0.0, "avg_logprob": -0.10553216934204102, "compression_ratio": 1.5850622406639003, "no_speech_prob": 0.00884293857961893}, {"id": 33, "seek": 20776, "start": 207.76, "end": 214.48, "text": " constants. It is a compile time error to attempt to explicitly instantiate an enum type. The final", "tokens": [50364, 35870, 13, 467, 307, 257, 31413, 565, 6713, 281, 5217, 281, 20803, 9836, 13024, 364, 465, 449, 2010, 13, 440, 2572, 50700], "temperature": 0.0, "avg_logprob": -0.09567729816880337, "compression_ratio": 1.7175925925925926, "no_speech_prob": 0.00723100733011961}, {"id": 34, "seek": 20776, "start": 214.48, "end": 220.79999999999998, "text": " clone method in enum ensures that enum constants can never be cloned. And the special treatment", "tokens": [50700, 26506, 3170, 294, 465, 449, 28111, 300, 465, 449, 35870, 393, 1128, 312, 596, 19009, 13, 400, 264, 2121, 5032, 51016], "temperature": 0.0, "avg_logprob": -0.09567729816880337, "compression_ratio": 1.7175925925925926, "no_speech_prob": 0.00723100733011961}, {"id": 35, "seek": 20776, "start": 220.79999999999998, "end": 227.44, "text": " by the serialization mechanism ensures that duplicate, duplicate instances are never created", "tokens": [51016, 538, 264, 17436, 2144, 7513, 28111, 300, 23976, 11, 23976, 14519, 366, 1128, 2942, 51348], "temperature": 0.0, "avg_logprob": -0.09567729816880337, "compression_ratio": 1.7175925925925926, "no_speech_prob": 0.00723100733011961}, {"id": 36, "seek": 20776, "start": 227.44, "end": 235.12, "text": " as a result of deserialization. Reflective instantiation of so that's from the Java", "tokens": [51348, 382, 257, 1874, 295, 730, 260, 831, 2144, 13, 16957, 1809, 488, 9836, 6642, 295, 370, 300, 311, 490, 264, 10745, 51732], "temperature": 0.0, "avg_logprob": -0.09567729816880337, "compression_ratio": 1.7175925925925926, "no_speech_prob": 0.00723100733011961}, {"id": 37, "seek": 23512, "start": 235.20000000000002, "end": 241.68, "text": " Reflections API. Reflective instantiation of enum types is prohibited. By the way, what that API,", "tokens": [50368, 16957, 1809, 626, 9362, 13, 16957, 1809, 488, 9836, 6642, 295, 465, 449, 3467, 307, 32069, 13, 3146, 264, 636, 11, 437, 300, 9362, 11, 50692], "temperature": 0.0, "avg_logprob": -0.09897719383239746, "compression_ratio": 1.6329113924050633, "no_speech_prob": 0.009854367934167385}, {"id": 38, "seek": 23512, "start": 241.68, "end": 249.84, "text": " the Reflections API does is it changes the structure of classes on runtime. It is not something", "tokens": [50692, 264, 16957, 1809, 626, 9362, 775, 307, 309, 2962, 264, 3877, 295, 5359, 322, 34474, 13, 467, 307, 406, 746, 51100], "temperature": 0.0, "avg_logprob": -0.09897719383239746, "compression_ratio": 1.6329113924050633, "no_speech_prob": 0.009854367934167385}, {"id": 39, "seek": 23512, "start": 249.84, "end": 256.72, "text": " a normal Java programmer would do. It's mostly used by framework designers. So I've never used", "tokens": [51100, 257, 2710, 10745, 32116, 576, 360, 13, 467, 311, 5240, 1143, 538, 8388, 16196, 13, 407, 286, 600, 1128, 1143, 51444], "temperature": 0.0, "avg_logprob": -0.09897719383239746, "compression_ratio": 1.6329113924050633, "no_speech_prob": 0.009854367934167385}, {"id": 40, "seek": 23512, "start": 256.72, "end": 261.68, "text": " the Reflections API, but it's just good to keep good to keep in mind what it does. Anyway, getting", "tokens": [51444, 264, 16957, 1809, 626, 9362, 11, 457, 309, 311, 445, 665, 281, 1066, 665, 281, 1066, 294, 1575, 437, 309, 775, 13, 5684, 11, 1242, 51692], "temperature": 0.0, "avg_logprob": -0.09897719383239746, "compression_ratio": 1.6329113924050633, "no_speech_prob": 0.009854367934167385}, {"id": 41, "seek": 26168, "start": 261.68, "end": 266.96, "text": " back to the definition, sorry for interrupting it. Reflective instantiations of enum types is", "tokens": [50364, 646, 281, 264, 7123, 11, 2597, 337, 49455, 309, 13, 16957, 1809, 488, 9836, 72, 763, 295, 465, 449, 3467, 307, 50628], "temperature": 0.0, "avg_logprob": -0.1323846075269911, "compression_ratio": 1.623931623931624, "no_speech_prob": 0.002251068130135536}, {"id": 42, "seek": 26168, "start": 266.96, "end": 273.2, "text": " prohibited. Together, these four things ensure that no instances of an enum type exist beyond", "tokens": [50628, 32069, 13, 15911, 11, 613, 1451, 721, 5586, 300, 572, 14519, 295, 364, 465, 449, 2010, 2514, 4399, 50940], "temperature": 0.0, "avg_logprob": -0.1323846075269911, "compression_ratio": 1.623931623931624, "no_speech_prob": 0.002251068130135536}, {"id": 43, "seek": 26168, "start": 273.76, "end": 283.04, "text": " those defined by the enum constants. And again, attending to our point, it's for these classes,", "tokens": [50968, 729, 7642, 538, 264, 465, 449, 35870, 13, 400, 797, 11, 15862, 281, 527, 935, 11, 309, 311, 337, 613, 5359, 11, 51432], "temperature": 0.0, "avg_logprob": -0.1323846075269911, "compression_ratio": 1.623931623931624, "no_speech_prob": 0.002251068130135536}, {"id": 44, "seek": 26168, "start": 283.04, "end": 289.84000000000003, "text": " so enums, logical equality is the same as object identity. So objects equals method functions as", "tokens": [51432, 370, 465, 8099, 11, 14978, 14949, 307, 264, 912, 382, 2657, 6575, 13, 407, 6565, 6915, 3170, 6828, 382, 51772], "temperature": 0.0, "avg_logprob": -0.1323846075269911, "compression_ratio": 1.623931623931624, "no_speech_prob": 0.002251068130135536}, {"id": 45, "seek": 28984, "start": 290.64, "end": 296.64, "text": " logical equals method. What that would mean really is, if let's say this S and B were enums,", "tokens": [50404, 14978, 6915, 3170, 13, 708, 300, 576, 914, 534, 307, 11, 498, 718, 311, 584, 341, 318, 293, 363, 645, 465, 8099, 11, 50704], "temperature": 0.0, "avg_logprob": -0.1428215442559658, "compression_ratio": 1.5294117647058822, "no_speech_prob": 0.0008964944863691926}, {"id": 46, "seek": 28984, "start": 299.2, "end": 305.84, "text": " if the objects were identical, we could say for all intents and purposes, there's also logical", "tokens": [50832, 498, 264, 6565, 645, 14800, 11, 321, 727, 584, 337, 439, 560, 791, 293, 9932, 11, 456, 311, 611, 14978, 51164], "temperature": 0.0, "avg_logprob": -0.1428215442559658, "compression_ratio": 1.5294117647058822, "no_speech_prob": 0.0008964944863691926}, {"id": 47, "seek": 28984, "start": 305.84, "end": 312.71999999999997, "text": " equality. So here's a small demo. Let's take a look at it that I put together. So I have two enums", "tokens": [51164, 14949, 13, 407, 510, 311, 257, 1359, 10723, 13, 961, 311, 747, 257, 574, 412, 309, 300, 286, 829, 1214, 13, 407, 286, 362, 732, 465, 8099, 51508], "temperature": 0.0, "avg_logprob": -0.1428215442559658, "compression_ratio": 1.5294117647058822, "no_speech_prob": 0.0008964944863691926}, {"id": 48, "seek": 31272, "start": 312.72, "end": 320.16, "text": " here. Day and day two both have days of a week. Now, if I do run this, it's going to print false", "tokens": [50364, 510, 13, 5226, 293, 786, 732, 1293, 362, 1708, 295, 257, 1243, 13, 823, 11, 498, 286, 360, 1190, 341, 11, 309, 311, 516, 281, 4482, 7908, 50736], "temperature": 0.0, "avg_logprob": -0.14814293690216848, "compression_ratio": 1.5026178010471205, "no_speech_prob": 0.008312704041600227}, {"id": 49, "seek": 31272, "start": 320.16, "end": 326.72, "text": " because there's no logical equality in this case because there's no object identity. However,", "tokens": [50736, 570, 456, 311, 572, 14978, 14949, 294, 341, 1389, 570, 456, 311, 572, 2657, 6575, 13, 2908, 11, 51064], "temperature": 0.0, "avg_logprob": -0.14814293690216848, "compression_ratio": 1.5026178010471205, "no_speech_prob": 0.008312704041600227}, {"id": 50, "seek": 31272, "start": 326.72, "end": 338.8, "text": " let's say I create two instances of day. Day dot, was it Monday? Yeah. And then I'll also create", "tokens": [51064, 718, 311, 584, 286, 1884, 732, 14519, 295, 786, 13, 5226, 5893, 11, 390, 309, 8138, 30, 865, 13, 400, 550, 286, 603, 611, 1884, 51668], "temperature": 0.0, "avg_logprob": -0.14814293690216848, "compression_ratio": 1.5026178010471205, "no_speech_prob": 0.008312704041600227}, {"id": 51, "seek": 33880, "start": 338.88, "end": 348.0, "text": " another day two with the same thing, with the same day. You'll see here, if I print this out,", "tokens": [50368, 1071, 786, 732, 365, 264, 912, 551, 11, 365, 264, 912, 786, 13, 509, 603, 536, 510, 11, 498, 286, 4482, 341, 484, 11, 50824], "temperature": 0.0, "avg_logprob": -0.11798541247844696, "compression_ratio": 1.5526315789473684, "no_speech_prob": 0.00023375166347250342}, {"id": 52, "seek": 33880, "start": 348.0, "end": 353.52000000000004, "text": " if I do compare these two objects, it'll print true because the logical equality here", "tokens": [50824, 498, 286, 360, 6794, 613, 732, 6565, 11, 309, 603, 4482, 2074, 570, 264, 14978, 14949, 510, 51100], "temperature": 0.0, "avg_logprob": -0.11798541247844696, "compression_ratio": 1.5526315789473684, "no_speech_prob": 0.00023375166347250342}, {"id": 53, "seek": 33880, "start": 354.16, "end": 359.52, "text": " equates to the object identity. So I'll just go day one,", "tokens": [51132, 1267, 1024, 281, 264, 2657, 6575, 13, 407, 286, 603, 445, 352, 786, 472, 11, 51400], "temperature": 0.0, "avg_logprob": -0.11798541247844696, "compression_ratio": 1.5526315789473684, "no_speech_prob": 0.00023375166347250342}, {"id": 54, "seek": 35952, "start": 360.08, "end": 366.56, "text": " day two. I'll comment that out. You'll see a true being printed now.", "tokens": [50392, 786, 732, 13, 286, 603, 2871, 300, 484, 13, 509, 603, 536, 257, 2074, 885, 13567, 586, 13, 50716], "temperature": 0.0, "avg_logprob": -0.15935623951447317, "compression_ratio": 1.5721649484536082, "no_speech_prob": 0.0013043384533375502}, {"id": 55, "seek": 35952, "start": 370.88, "end": 376.71999999999997, "text": " That's it. So the object identity equates to the logical equality. And that makes sense.", "tokens": [50932, 663, 311, 309, 13, 407, 264, 2657, 6575, 1267, 1024, 281, 264, 14978, 14949, 13, 400, 300, 1669, 2020, 13, 51224], "temperature": 0.0, "avg_logprob": -0.15935623951447317, "compression_ratio": 1.5721649484536082, "no_speech_prob": 0.0013043384533375502}, {"id": 56, "seek": 35952, "start": 377.44, "end": 380.64, "text": " So reiterating that point, so the idea really settles in our mind,", "tokens": [51260, 407, 25211, 990, 300, 935, 11, 370, 264, 1558, 534, 5584, 904, 294, 527, 1575, 11, 51420], "temperature": 0.0, "avg_logprob": -0.15935623951447317, "compression_ratio": 1.5721649484536082, "no_speech_prob": 0.0013043384533375502}, {"id": 57, "seek": 35952, "start": 382.24, "end": 388.96, "text": " overriding the equals method is required or is appropriate when logical equality", "tokens": [51500, 670, 81, 2819, 264, 6915, 3170, 307, 4739, 420, 307, 6854, 562, 14978, 14949, 51836], "temperature": 0.0, "avg_logprob": -0.15935623951447317, "compression_ratio": 1.5721649484536082, "no_speech_prob": 0.0013043384533375502}, {"id": 58, "seek": 38896, "start": 388.96, "end": 394.47999999999996, "text": " differs to object identity. Now, I accept the enums class, of course. Whenever we know that", "tokens": [50364, 37761, 281, 2657, 6575, 13, 823, 11, 286, 3241, 264, 465, 8099, 1508, 11, 295, 1164, 13, 14159, 321, 458, 300, 50640], "temperature": 0.0, "avg_logprob": -0.11230344531916771, "compression_ratio": 1.8352490421455938, "no_speech_prob": 0.0062886252999305725}, {"id": 59, "seek": 38896, "start": 394.47999999999996, "end": 401.52, "text": " object identity is not equate to logical equality, override the equals method. And that gets us to", "tokens": [50640, 2657, 6575, 307, 406, 1267, 473, 281, 14978, 14949, 11, 42321, 264, 6915, 3170, 13, 400, 300, 2170, 505, 281, 50992], "temperature": 0.0, "avg_logprob": -0.11230344531916771, "compression_ratio": 1.8352490421455938, "no_speech_prob": 0.0062886252999305725}, {"id": 60, "seek": 38896, "start": 401.52, "end": 407.59999999999997, "text": " the general contract when overriding the equals method. And that's what we're going to discuss", "tokens": [50992, 264, 2674, 4364, 562, 670, 81, 2819, 264, 6915, 3170, 13, 400, 300, 311, 437, 321, 434, 516, 281, 2248, 51296], "temperature": 0.0, "avg_logprob": -0.11230344531916771, "compression_ratio": 1.8352490421455938, "no_speech_prob": 0.0062886252999305725}, {"id": 61, "seek": 38896, "start": 407.59999999999997, "end": 412.64, "text": " for the rest of this part. And in fact, the next part too. And there's a lot to get into here.", "tokens": [51296, 337, 264, 1472, 295, 341, 644, 13, 400, 294, 1186, 11, 264, 958, 644, 886, 13, 400, 456, 311, 257, 688, 281, 483, 666, 510, 13, 51548], "temperature": 0.0, "avg_logprob": -0.11230344531916771, "compression_ratio": 1.8352490421455938, "no_speech_prob": 0.0062886252999305725}, {"id": 62, "seek": 38896, "start": 412.64, "end": 417.12, "text": " All right, before we get to the properties that define this general contract, I need to skip ahead", "tokens": [51548, 1057, 558, 11, 949, 321, 483, 281, 264, 7221, 300, 6964, 341, 2674, 4364, 11, 286, 643, 281, 10023, 2286, 51772], "temperature": 0.0, "avg_logprob": -0.11230344531916771, "compression_ratio": 1.8352490421455938, "no_speech_prob": 0.0062886252999305725}, {"id": 63, "seek": 41712, "start": 417.12, "end": 422.88, "text": " a bit and read a caveat that Joshua Block has put in. Because in fact, I wish you would have put", "tokens": [50364, 257, 857, 293, 1401, 257, 43012, 300, 24005, 17500, 575, 829, 294, 13, 1436, 294, 1186, 11, 286, 3172, 291, 576, 362, 829, 50652], "temperature": 0.0, "avg_logprob": -0.10342995937053974, "compression_ratio": 1.7555555555555555, "no_speech_prob": 0.017707744613289833}, {"id": 64, "seek": 41712, "start": 422.88, "end": 428.08, "text": " that bit earlier before getting to the properties because the caveat is a good starting point", "tokens": [50652, 300, 857, 3071, 949, 1242, 281, 264, 7221, 570, 264, 43012, 307, 257, 665, 2891, 935, 50912], "temperature": 0.0, "avg_logprob": -0.10342995937053974, "compression_ratio": 1.7555555555555555, "no_speech_prob": 0.017707744613289833}, {"id": 65, "seek": 41712, "start": 428.08, "end": 432.4, "text": " in understanding these properties. Because it's really important that we don't ignore them.", "tokens": [50912, 294, 3701, 613, 7221, 13, 1436, 309, 311, 534, 1021, 300, 321, 500, 380, 11200, 552, 13, 51128], "temperature": 0.0, "avg_logprob": -0.10342995937053974, "compression_ratio": 1.7555555555555555, "no_speech_prob": 0.017707744613289833}, {"id": 66, "seek": 41712, "start": 433.28000000000003, "end": 440.4, "text": " They can be a bit overwhelming to understand. Nevertheless, ignoring them isn't the solution.", "tokens": [51172, 814, 393, 312, 257, 857, 13373, 281, 1223, 13, 26554, 11, 26258, 552, 1943, 380, 264, 3827, 13, 51528], "temperature": 0.0, "avg_logprob": -0.10342995937053974, "compression_ratio": 1.7555555555555555, "no_speech_prob": 0.017707744613289833}, {"id": 67, "seek": 41712, "start": 440.4, "end": 445.44, "text": " It's enduring through and assisting and trying to make sense of them and implementing them in our", "tokens": [51528, 467, 311, 36562, 807, 293, 40368, 293, 1382, 281, 652, 2020, 295, 552, 293, 18114, 552, 294, 527, 51780], "temperature": 0.0, "avg_logprob": -0.10342995937053974, "compression_ratio": 1.7555555555555555, "no_speech_prob": 0.017707744613289833}, {"id": 68, "seek": 44544, "start": 445.44, "end": 451.84, "text": " code. So here's a caveat Joshua Block has put in. Unless you are mathematically inclined,", "tokens": [50364, 3089, 13, 407, 510, 311, 257, 43012, 24005, 17500, 575, 829, 294, 13, 16581, 291, 366, 44003, 28173, 11, 50684], "temperature": 0.0, "avg_logprob": -0.08547875221739425, "compression_ratio": 1.5833333333333333, "no_speech_prob": 0.00211482890881598}, {"id": 69, "seek": 44544, "start": 451.84, "end": 457.6, "text": " this might look a bit scary. So what he means by that is the properties that he listed down or", "tokens": [50684, 341, 1062, 574, 257, 857, 6958, 13, 407, 437, 415, 1355, 538, 300, 307, 264, 7221, 300, 415, 10052, 760, 420, 50972], "temperature": 0.0, "avg_logprob": -0.08547875221739425, "compression_ratio": 1.5833333333333333, "no_speech_prob": 0.00211482890881598}, {"id": 70, "seek": 44544, "start": 457.6, "end": 465.12, "text": " enumerated. But do not ignore it. So don't ignore these properties. If you violate it, you may well", "tokens": [50972, 465, 15583, 770, 13, 583, 360, 406, 11200, 309, 13, 407, 500, 380, 11200, 613, 7221, 13, 759, 291, 37478, 309, 11, 291, 815, 731, 51348], "temperature": 0.0, "avg_logprob": -0.08547875221739425, "compression_ratio": 1.5833333333333333, "no_speech_prob": 0.00211482890881598}, {"id": 71, "seek": 44544, "start": 465.12, "end": 472.08, "text": " find that your program behaves radically or crashes. It can be very, very difficult to pin down", "tokens": [51348, 915, 300, 428, 1461, 36896, 35508, 420, 28642, 13, 467, 393, 312, 588, 11, 588, 2252, 281, 5447, 760, 51696], "temperature": 0.0, "avg_logprob": -0.08547875221739425, "compression_ratio": 1.5833333333333333, "no_speech_prob": 0.00211482890881598}, {"id": 72, "seek": 47208, "start": 472.08, "end": 478.56, "text": " the source of the failure. To paraphrase John Donne, is that how you pronounce his surname?", "tokens": [50364, 264, 4009, 295, 264, 7763, 13, 1407, 36992, 1703, 651, 2619, 1468, 716, 11, 307, 300, 577, 291, 19567, 702, 50152, 30, 50688], "temperature": 0.0, "avg_logprob": -0.13920853354714133, "compression_ratio": 1.5731707317073171, "no_speech_prob": 0.005637673661112785}, {"id": 73, "seek": 47208, "start": 478.56, "end": 487.28, "text": " D-O-N-N-E. John Donne, probably. No class is an island. Instances of one class are frequently passed", "tokens": [50688, 413, 12, 46, 12, 45, 12, 45, 12, 36, 13, 2619, 1468, 716, 11, 1391, 13, 883, 1508, 307, 364, 6077, 13, 2730, 2676, 295, 472, 1508, 366, 10374, 4678, 51124], "temperature": 0.0, "avg_logprob": -0.13920853354714133, "compression_ratio": 1.5731707317073171, "no_speech_prob": 0.005637673661112785}, {"id": 74, "seek": 47208, "start": 487.28, "end": 495.36, "text": " to another. Many classes, including all collections classes, depend on the objects passed to them", "tokens": [51124, 281, 1071, 13, 5126, 5359, 11, 3009, 439, 16641, 5359, 11, 5672, 322, 264, 6565, 4678, 281, 552, 51528], "temperature": 0.0, "avg_logprob": -0.13920853354714133, "compression_ratio": 1.5731707317073171, "no_speech_prob": 0.005637673661112785}, {"id": 75, "seek": 47208, "start": 495.36, "end": 501.36, "text": " obeying the equals contract. Just on that point, there's a really interesting kind of philosophy", "tokens": [51528, 36346, 1840, 264, 6915, 4364, 13, 1449, 322, 300, 935, 11, 456, 311, 257, 534, 1880, 733, 295, 10675, 51828], "temperature": 0.0, "avg_logprob": -0.13920853354714133, "compression_ratio": 1.5731707317073171, "no_speech_prob": 0.005637673661112785}, {"id": 76, "seek": 50136, "start": 501.36, "end": 507.6, "text": " in object-oriented programming. And I think even Alan Kay, the inventor of OOP, he makes this idea", "tokens": [50364, 294, 2657, 12, 27414, 9410, 13, 400, 286, 519, 754, 16442, 14179, 11, 264, 41593, 295, 422, 12059, 11, 415, 1669, 341, 1558, 50676], "temperature": 0.0, "avg_logprob": -0.09811725616455078, "compression_ratio": 1.7488372093023257, "no_speech_prob": 0.08501578122377396}, {"id": 77, "seek": 50136, "start": 507.6, "end": 516.48, "text": " that I'm going to get a book. I was reading this book by Sandy Metz, which is a book on", "tokens": [50676, 300, 286, 478, 516, 281, 483, 257, 1446, 13, 286, 390, 3760, 341, 1446, 538, 27390, 6377, 89, 11, 597, 307, 257, 1446, 322, 51120], "temperature": 0.0, "avg_logprob": -0.09811725616455078, "compression_ratio": 1.7488372093023257, "no_speech_prob": 0.08501578122377396}, {"id": 78, "seek": 50136, "start": 516.48, "end": 523.52, "text": " object-oriented design, but using Ruby. And what she states in this book is that it's better to", "tokens": [51120, 2657, 12, 27414, 1715, 11, 457, 1228, 19907, 13, 400, 437, 750, 4368, 294, 341, 1446, 307, 300, 309, 311, 1101, 281, 51472], "temperature": 0.0, "avg_logprob": -0.09811725616455078, "compression_ratio": 1.7488372093023257, "no_speech_prob": 0.08501578122377396}, {"id": 79, "seek": 50136, "start": 523.52, "end": 530.96, "text": " conceptualize object-oriented programming more as message-oriented programming. And even Alan", "tokens": [51472, 24106, 1125, 2657, 12, 27414, 9410, 544, 382, 3636, 12, 27414, 9410, 13, 400, 754, 16442, 51844], "temperature": 0.0, "avg_logprob": -0.09811725616455078, "compression_ratio": 1.7488372093023257, "no_speech_prob": 0.08501578122377396}, {"id": 80, "seek": 53096, "start": 531.0400000000001, "end": 537.0400000000001, "text": " Kay, I believe, said in one of his talks that he wished that people emphasize the importance of", "tokens": [50368, 14179, 11, 286, 1697, 11, 848, 294, 472, 295, 702, 6686, 300, 415, 25811, 300, 561, 16078, 264, 7379, 295, 50668], "temperature": 0.0, "avg_logprob": -0.13731042350210795, "compression_ratio": 1.696969696969697, "no_speech_prob": 0.0019558777566999197}, {"id": 81, "seek": 53096, "start": 537.0400000000001, "end": 542.88, "text": " messages between objects than objects themselves, which is the point that Joshua Blocks making here,", "tokens": [50668, 7897, 1296, 6565, 813, 6565, 2969, 11, 597, 307, 264, 935, 300, 24005, 9865, 2761, 1455, 510, 11, 50960], "temperature": 0.0, "avg_logprob": -0.13731042350210795, "compression_ratio": 1.696969696969697, "no_speech_prob": 0.0019558777566999197}, {"id": 82, "seek": 53096, "start": 543.52, "end": 552.24, "text": " all these contracts, all these properties that define these contracts that we ought to respect", "tokens": [50992, 439, 613, 13952, 11, 439, 613, 7221, 300, 6964, 613, 13952, 300, 321, 13416, 281, 3104, 51428], "temperature": 0.0, "avg_logprob": -0.13731042350210795, "compression_ratio": 1.696969696969697, "no_speech_prob": 0.0019558777566999197}, {"id": 83, "seek": 53096, "start": 552.24, "end": 557.76, "text": " and take into account when writing code, they're more about the messages and how objects communicate", "tokens": [51428, 293, 747, 666, 2696, 562, 3579, 3089, 11, 436, 434, 544, 466, 264, 7897, 293, 577, 6565, 7890, 51704], "temperature": 0.0, "avg_logprob": -0.13731042350210795, "compression_ratio": 1.696969696969697, "no_speech_prob": 0.0019558777566999197}, {"id": 84, "seek": 55776, "start": 557.76, "end": 563.4399999999999, "text": " with each other. Therefore, it requires a bit of a change of mindset. In any case, I don't want to", "tokens": [50364, 365, 1184, 661, 13, 7504, 11, 309, 7029, 257, 857, 295, 257, 1319, 295, 12543, 13, 682, 604, 1389, 11, 286, 500, 380, 528, 281, 50648], "temperature": 0.0, "avg_logprob": -0.056333245063314635, "compression_ratio": 1.6311475409836065, "no_speech_prob": 0.012429855763912201}, {"id": 85, "seek": 55776, "start": 563.4399999999999, "end": 568.88, "text": " get too carried away, but I thought that was an important point to add on to what we're discussing", "tokens": [50648, 483, 886, 9094, 1314, 11, 457, 286, 1194, 300, 390, 364, 1021, 935, 281, 909, 322, 281, 437, 321, 434, 10850, 50920], "temperature": 0.0, "avg_logprob": -0.056333245063314635, "compression_ratio": 1.6311475409836065, "no_speech_prob": 0.012429855763912201}, {"id": 86, "seek": 55776, "start": 568.88, "end": 575.28, "text": " here. So given that we've got that caveat slash warning out of the way, let's get to the specifications", "tokens": [50920, 510, 13, 407, 2212, 300, 321, 600, 658, 300, 43012, 17330, 9164, 484, 295, 264, 636, 11, 718, 311, 483, 281, 264, 29448, 51240], "temperature": 0.0, "avg_logprob": -0.056333245063314635, "compression_ratio": 1.6311475409836065, "no_speech_prob": 0.012429855763912201}, {"id": 87, "seek": 55776, "start": 575.28, "end": 582.4, "text": " for the contract. The equals method implements an equivalence relation. It has these properties.", "tokens": [51240, 337, 264, 4364, 13, 440, 6915, 3170, 704, 17988, 364, 9052, 655, 9721, 13, 467, 575, 613, 7221, 13, 51596], "temperature": 0.0, "avg_logprob": -0.056333245063314635, "compression_ratio": 1.6311475409836065, "no_speech_prob": 0.012429855763912201}, {"id": 88, "seek": 58240, "start": 582.4, "end": 588.88, "text": " So there are six properties, sorry, five properties. And in this part, we're going to discuss three of", "tokens": [50364, 407, 456, 366, 2309, 7221, 11, 2597, 11, 1732, 7221, 13, 400, 294, 341, 644, 11, 321, 434, 516, 281, 2248, 1045, 295, 50688], "temperature": 0.0, "avg_logprob": -0.16016017397244772, "compression_ratio": 1.6944444444444444, "no_speech_prob": 0.0018968003569170833}, {"id": 89, "seek": 58240, "start": 588.88, "end": 598.0799999999999, "text": " them, especially because symmetry, sorry, not symmetry, transitivity is quite a loan property", "tokens": [50688, 552, 11, 2318, 570, 25440, 11, 2597, 11, 406, 25440, 11, 17976, 4253, 307, 1596, 257, 10529, 4707, 51148], "temperature": 0.0, "avg_logprob": -0.16016017397244772, "compression_ratio": 1.6944444444444444, "no_speech_prob": 0.0018968003569170833}, {"id": 90, "seek": 58240, "start": 598.0799999999999, "end": 604.3199999999999, "text": " and there's a lot to discuss there. So, and then in part three, we'll discuss consistency and", "tokens": [51148, 293, 456, 311, 257, 688, 281, 2248, 456, 13, 407, 11, 293, 550, 294, 644, 1045, 11, 321, 603, 2248, 14416, 293, 51460], "temperature": 0.0, "avg_logprob": -0.16016017397244772, "compression_ratio": 1.6944444444444444, "no_speech_prob": 0.0018968003569170833}, {"id": 91, "seek": 58240, "start": 604.3199999999999, "end": 611.92, "text": " non-nullity. However, that's later on. Let's stay on track here. So what is", "tokens": [51460, 2107, 12, 77, 858, 507, 13, 2908, 11, 300, 311, 1780, 322, 13, 961, 311, 1754, 322, 2837, 510, 13, 407, 437, 307, 51840], "temperature": 0.0, "avg_logprob": -0.16016017397244772, "compression_ratio": 1.6944444444444444, "no_speech_prob": 0.0018968003569170833}, {"id": 92, "seek": 61192, "start": 611.92, "end": 617.4399999999999, "text": " equivalence relation? And what does it mean to have equivalence relation between two sets?", "tokens": [50364, 9052, 655, 9721, 30, 400, 437, 775, 309, 914, 281, 362, 9052, 655, 9721, 1296, 732, 6352, 30, 50640], "temperature": 0.0, "avg_logprob": -0.10627140088027782, "compression_ratio": 1.6771300448430493, "no_speech_prob": 0.004536282736808062}, {"id": 93, "seek": 61192, "start": 618.0799999999999, "end": 624.24, "text": " Look, Joshua Bloch puts it best. Here's what he states. Lucy speaking, so this is pertaining", "tokens": [50672, 2053, 11, 24005, 9865, 339, 8137, 309, 1151, 13, 1692, 311, 437, 415, 4368, 13, 22698, 4124, 11, 370, 341, 307, 49582, 50980], "temperature": 0.0, "avg_logprob": -0.10627140088027782, "compression_ratio": 1.6771300448430493, "no_speech_prob": 0.004536282736808062}, {"id": 94, "seek": 61192, "start": 624.24, "end": 631.68, "text": " to equivalence relation, which the equals method implements. It's an operator that partitions a", "tokens": [50980, 281, 9052, 655, 9721, 11, 597, 264, 6915, 3170, 704, 17988, 13, 467, 311, 364, 12973, 300, 644, 2451, 257, 51352], "temperature": 0.0, "avg_logprob": -0.10627140088027782, "compression_ratio": 1.6771300448430493, "no_speech_prob": 0.004536282736808062}, {"id": 95, "seek": 61192, "start": 631.68, "end": 639.5999999999999, "text": " set of elements into subsets whose elements are deemed equal to one another. These subsets are", "tokens": [51352, 992, 295, 4959, 666, 2090, 1385, 6104, 4959, 366, 27637, 2681, 281, 472, 1071, 13, 1981, 2090, 1385, 366, 51748], "temperature": 0.0, "avg_logprob": -0.10627140088027782, "compression_ratio": 1.6771300448430493, "no_speech_prob": 0.004536282736808062}, {"id": 96, "seek": 63960, "start": 639.6800000000001, "end": 647.2, "text": " known as equivalence classes. For an equals method to be useful, all of the elements in such", "tokens": [50368, 2570, 382, 9052, 655, 5359, 13, 1171, 364, 6915, 3170, 281, 312, 4420, 11, 439, 295, 264, 4959, 294, 1270, 50744], "temperature": 0.0, "avg_logprob": -0.09414283434549968, "compression_ratio": 1.5892857142857142, "no_speech_prob": 0.011155507527291775}, {"id": 97, "seek": 63960, "start": 647.2, "end": 653.6800000000001, "text": " equivalence class must be interchangeable from the perspective of the user. Sorry about that", "tokens": [50744, 9052, 655, 1508, 1633, 312, 30358, 712, 490, 264, 4585, 295, 264, 4195, 13, 4919, 466, 300, 51068], "temperature": 0.0, "avg_logprob": -0.09414283434549968, "compression_ratio": 1.5892857142857142, "no_speech_prob": 0.011155507527291775}, {"id": 98, "seek": 63960, "start": 653.6800000000001, "end": 658.5600000000001, "text": " background noise. It gets so annoyed by this because I live in a very quiet neighborhood,", "tokens": [51068, 3678, 5658, 13, 467, 2170, 370, 25921, 538, 341, 570, 286, 1621, 294, 257, 588, 5677, 7630, 11, 51312], "temperature": 0.0, "avg_logprob": -0.09414283434549968, "compression_ratio": 1.5892857142857142, "no_speech_prob": 0.011155507527291775}, {"id": 99, "seek": 63960, "start": 658.5600000000001, "end": 665.52, "text": " but every time I record a bloody video, there's some noise outside. In any case,", "tokens": [51312, 457, 633, 565, 286, 2136, 257, 18938, 960, 11, 456, 311, 512, 5658, 2380, 13, 682, 604, 1389, 11, 51660], "temperature": 0.0, "avg_logprob": -0.09414283434549968, "compression_ratio": 1.5892857142857142, "no_speech_prob": 0.011155507527291775}, {"id": 100, "seek": 66552, "start": 665.68, "end": 672.96, "text": " so what he means by for an equals method to be useful, all of the elements in each", "tokens": [50372, 370, 437, 415, 1355, 538, 337, 364, 6915, 3170, 281, 312, 4420, 11, 439, 295, 264, 4959, 294, 1184, 50736], "temperature": 0.0, "avg_logprob": -0.13018045192811548, "compression_ratio": 1.7389162561576355, "no_speech_prob": 0.004904382862150669}, {"id": 101, "seek": 66552, "start": 672.96, "end": 677.4399999999999, "text": " equals class must be interchangeable from the perspective of the user means again,", "tokens": [50736, 6915, 1508, 1633, 312, 30358, 712, 490, 264, 4585, 295, 264, 4195, 1355, 797, 11, 50960], "temperature": 0.0, "avg_logprob": -0.13018045192811548, "compression_ratio": 1.7389162561576355, "no_speech_prob": 0.004904382862150669}, {"id": 102, "seek": 66552, "start": 677.4399999999999, "end": 682.72, "text": " going back to the string, from the perspective of the user, both these objects have logical", "tokens": [50960, 516, 646, 281, 264, 6798, 11, 490, 264, 4585, 295, 264, 4195, 11, 1293, 613, 6565, 362, 14978, 51224], "temperature": 0.0, "avg_logprob": -0.13018045192811548, "compression_ratio": 1.7389162561576355, "no_speech_prob": 0.004904382862150669}, {"id": 103, "seek": 66552, "start": 682.72, "end": 689.84, "text": " equality and that's what necessitates equivalence relation. Saying that, let's get to the first", "tokens": [51224, 14949, 293, 300, 311, 437, 2688, 30035, 9052, 655, 9721, 13, 34087, 300, 11, 718, 311, 483, 281, 264, 700, 51580], "temperature": 0.0, "avg_logprob": -0.13018045192811548, "compression_ratio": 1.7389162561576355, "no_speech_prob": 0.004904382862150669}, {"id": 104, "seek": 68984, "start": 689.84, "end": 697.36, "text": " item or the the first property that pertains to the general contract. Oh gosh, man.", "tokens": [50364, 3174, 420, 264, 264, 700, 4707, 300, 13269, 2315, 281, 264, 2674, 4364, 13, 876, 6502, 11, 587, 13, 50740], "temperature": 0.0, "avg_logprob": -0.2105255677149846, "compression_ratio": 1.5172413793103448, "no_speech_prob": 0.10226258635520935}, {"id": 105, "seek": 68984, "start": 698.96, "end": 704.64, "text": " The noise is not ending. Is that a leaf blower or lawn mower? What the hell is it?", "tokens": [50820, 440, 5658, 307, 406, 8121, 13, 1119, 300, 257, 10871, 888, 968, 420, 19915, 275, 968, 30, 708, 264, 4921, 307, 309, 30, 51104], "temperature": 0.0, "avg_logprob": -0.2105255677149846, "compression_ratio": 1.5172413793103448, "no_speech_prob": 0.10226258635520935}, {"id": 106, "seek": 68984, "start": 706.96, "end": 713.2800000000001, "text": " Okay, part and parcel of living in a suburb. Hey, look, I look, I'm not complaining though,", "tokens": [51220, 1033, 11, 644, 293, 34082, 295, 2647, 294, 257, 1422, 16659, 13, 1911, 11, 574, 11, 286, 574, 11, 286, 478, 406, 20740, 1673, 11, 51536], "temperature": 0.0, "avg_logprob": -0.2105255677149846, "compression_ratio": 1.5172413793103448, "no_speech_prob": 0.10226258635520935}, {"id": 107, "seek": 68984, "start": 713.2800000000001, "end": 718.64, "text": " it's way better than the city. Ah, it ended. No, it didn't. I'm just gonna wait till it ends.", "tokens": [51536, 309, 311, 636, 1101, 813, 264, 2307, 13, 2438, 11, 309, 4590, 13, 883, 11, 309, 994, 380, 13, 286, 478, 445, 799, 1699, 4288, 309, 5314, 13, 51804], "temperature": 0.0, "avg_logprob": -0.2105255677149846, "compression_ratio": 1.5172413793103448, "no_speech_prob": 0.10226258635520935}, {"id": 108, "seek": 71984, "start": 720.08, "end": 728.88, "text": " I think it ended. Back to it. So, reflexivity. Ah, he's starting. Dude, the guy's trolling me.", "tokens": [50376, 286, 519, 309, 4590, 13, 5833, 281, 309, 13, 407, 11, 23802, 4253, 13, 2438, 11, 415, 311, 2891, 13, 12042, 11, 264, 2146, 311, 4495, 2669, 385, 13, 50816], "temperature": 0.0, "avg_logprob": -0.17955046301489477, "compression_ratio": 1.609442060085837, "no_speech_prob": 0.0036493786610662937}, {"id": 109, "seek": 71984, "start": 728.88, "end": 732.64, "text": " The guy's trolling me. You know what? I can't, I can't do this. We're just gonna keep going.", "tokens": [50816, 440, 2146, 311, 4495, 2669, 385, 13, 509, 458, 437, 30, 286, 393, 380, 11, 286, 393, 380, 360, 341, 13, 492, 434, 445, 799, 1066, 516, 13, 51004], "temperature": 0.0, "avg_logprob": -0.17955046301489477, "compression_ratio": 1.609442060085837, "no_speech_prob": 0.0036493786610662937}, {"id": 110, "seek": 71984, "start": 733.36, "end": 739.44, "text": " I apologize about the background noise. So, starting off with the first property, reflexes.", "tokens": [51040, 286, 12328, 466, 264, 3678, 5658, 13, 407, 11, 2891, 766, 365, 264, 700, 4707, 11, 23802, 279, 13, 51344], "temperature": 0.0, "avg_logprob": -0.17955046301489477, "compression_ratio": 1.609442060085837, "no_speech_prob": 0.0036493786610662937}, {"id": 111, "seek": 71984, "start": 740.8000000000001, "end": 747.6800000000001, "text": " See, I got distracted. Reflexivity. Okay, what does that mean? What does reflexivity mean? I've", "tokens": [51412, 3008, 11, 286, 658, 21658, 13, 16957, 2021, 4253, 13, 1033, 11, 437, 775, 300, 914, 30, 708, 775, 23802, 4253, 914, 30, 286, 600, 51756], "temperature": 0.0, "avg_logprob": -0.17955046301489477, "compression_ratio": 1.609442060085837, "no_speech_prob": 0.0036493786610662937}, {"id": 112, "seek": 74768, "start": 747.68, "end": 753.8399999999999, "text": " got to be really flexible here right now. So, that means for any non-null reference,", "tokens": [50364, 658, 281, 312, 534, 11358, 510, 558, 586, 13, 407, 11, 300, 1355, 337, 604, 2107, 12, 77, 858, 6408, 11, 50672], "temperature": 0.0, "avg_logprob": -0.11226280212402344, "compression_ratio": 1.5765765765765767, "no_speech_prob": 0.002590673044323921}, {"id": 113, "seek": 74768, "start": 753.8399999999999, "end": 761.3599999999999, "text": " value x should equate to x. So, it's saying that an object x should be equal to itself,", "tokens": [50672, 2158, 2031, 820, 1267, 473, 281, 2031, 13, 407, 11, 309, 311, 1566, 300, 364, 2657, 2031, 820, 312, 2681, 281, 2564, 11, 51048], "temperature": 0.0, "avg_logprob": -0.11226280212402344, "compression_ratio": 1.5765765765765767, "no_speech_prob": 0.002590673044323921}, {"id": 114, "seek": 74768, "start": 761.3599999999999, "end": 767.92, "text": " which kind of seems self-evident. So, if we have a x equals x, it must return true.", "tokens": [51048, 597, 733, 295, 2544, 2698, 12, 13379, 1078, 13, 407, 11, 498, 321, 362, 257, 2031, 6915, 2031, 11, 309, 1633, 2736, 2074, 13, 51376], "temperature": 0.0, "avg_logprob": -0.11226280212402344, "compression_ratio": 1.5765765765765767, "no_speech_prob": 0.002590673044323921}, {"id": 115, "seek": 74768, "start": 769.76, "end": 773.8399999999999, "text": " Which is why, which is why Joshua Bloch states, the first requirement, say, is merely that an", "tokens": [51468, 3013, 307, 983, 11, 597, 307, 983, 24005, 9865, 339, 4368, 11, 264, 700, 11695, 11, 584, 11, 307, 17003, 300, 364, 51672], "temperature": 0.0, "avg_logprob": -0.11226280212402344, "compression_ratio": 1.5765765765765767, "no_speech_prob": 0.002590673044323921}, {"id": 116, "seek": 77384, "start": 773.84, "end": 779.44, "text": " object must be equal to itself. It's hard to imagine violating this one unintentionally.", "tokens": [50364, 2657, 1633, 312, 2681, 281, 2564, 13, 467, 311, 1152, 281, 3811, 42201, 341, 472, 45514, 379, 13, 50644], "temperature": 0.0, "avg_logprob": -0.08661041444945104, "compression_ratio": 1.7076923076923076, "no_speech_prob": 0.0011512808268889785}, {"id": 117, "seek": 77384, "start": 779.44, "end": 784.32, "text": " If you were to violate it and then add an instance of your class to a collection,", "tokens": [50644, 759, 291, 645, 281, 37478, 309, 293, 550, 909, 364, 5197, 295, 428, 1508, 281, 257, 5765, 11, 50888], "temperature": 0.0, "avg_logprob": -0.08661041444945104, "compression_ratio": 1.7076923076923076, "no_speech_prob": 0.0011512808268889785}, {"id": 118, "seek": 77384, "start": 784.32, "end": 789.9200000000001, "text": " the contains method might well say that the collection didn't contain the instance that", "tokens": [50888, 264, 8306, 3170, 1062, 731, 584, 300, 264, 5765, 994, 380, 5304, 264, 5197, 300, 51168], "temperature": 0.0, "avg_logprob": -0.08661041444945104, "compression_ratio": 1.7076923076923076, "no_speech_prob": 0.0011512808268889785}, {"id": 119, "seek": 77384, "start": 789.9200000000001, "end": 795.0400000000001, "text": " you just added. So, let's take a look at a quick demo, because obviously code makes more sense", "tokens": [51168, 291, 445, 3869, 13, 407, 11, 718, 311, 747, 257, 574, 412, 257, 1702, 10723, 11, 570, 2745, 3089, 1669, 544, 2020, 51424], "temperature": 0.0, "avg_logprob": -0.08661041444945104, "compression_ratio": 1.7076923076923076, "no_speech_prob": 0.0011512808268889785}, {"id": 120, "seek": 77384, "start": 795.0400000000001, "end": 801.0400000000001, "text": " than theory, even though we are, I personally always like starting with theory, because it", "tokens": [51424, 813, 5261, 11, 754, 1673, 321, 366, 11, 286, 5665, 1009, 411, 2891, 365, 5261, 11, 570, 309, 51724], "temperature": 0.0, "avg_logprob": -0.08661041444945104, "compression_ratio": 1.7076923076923076, "no_speech_prob": 0.0011512808268889785}, {"id": 121, "seek": 80104, "start": 801.12, "end": 808.4, "text": " really helps to start high level. Where is this? So, if we go to reflexivity,", "tokens": [50368, 534, 3665, 281, 722, 1090, 1496, 13, 2305, 307, 341, 30, 407, 11, 498, 321, 352, 281, 23802, 4253, 11, 50732], "temperature": 0.0, "avg_logprob": -0.09529812939195748, "compression_ratio": 1.560693641618497, "no_speech_prob": 0.004198411479592323}, {"id": 122, "seek": 80104, "start": 809.4399999999999, "end": 818.88, "text": " it's really simple as this. So, I have a list of strings here, and what we're doing is we're", "tokens": [50784, 309, 311, 534, 2199, 382, 341, 13, 407, 11, 286, 362, 257, 1329, 295, 13985, 510, 11, 293, 437, 321, 434, 884, 307, 321, 434, 51256], "temperature": 0.0, "avg_logprob": -0.09529812939195748, "compression_ratio": 1.560693641618497, "no_speech_prob": 0.004198411479592323}, {"id": 123, "seek": 80104, "start": 818.88, "end": 826.64, "text": " adding the word Java into that list. So, it's a set, let's say, it's a string, and if you run this,", "tokens": [51256, 5127, 264, 1349, 10745, 666, 300, 1329, 13, 407, 11, 309, 311, 257, 992, 11, 718, 311, 584, 11, 309, 311, 257, 6798, 11, 293, 498, 291, 1190, 341, 11, 51644], "temperature": 0.0, "avg_logprob": -0.09529812939195748, "compression_ratio": 1.560693641618497, "no_speech_prob": 0.004198411479592323}, {"id": 124, "seek": 82664, "start": 826.64, "end": 833.04, "text": " it'll return true, because we're just checking if this set, this list, contains, using the", "tokens": [50364, 309, 603, 2736, 2074, 11, 570, 321, 434, 445, 8568, 498, 341, 992, 11, 341, 1329, 11, 8306, 11, 1228, 264, 50684], "temperature": 0.0, "avg_logprob": -0.13326942110524595, "compression_ratio": 1.7387387387387387, "no_speech_prob": 0.006796353030949831}, {"id": 125, "seek": 82664, "start": 833.04, "end": 838.24, "text": " contains method that's in the, using the, sorry, I bit my tongue, using the contains method in the", "tokens": [50684, 8306, 3170, 300, 311, 294, 264, 11, 1228, 264, 11, 2597, 11, 286, 857, 452, 10601, 11, 1228, 264, 8306, 3170, 294, 264, 50944], "temperature": 0.0, "avg_logprob": -0.13326942110524595, "compression_ratio": 1.7387387387387387, "no_speech_prob": 0.006796353030949831}, {"id": 126, "seek": 82664, "start": 838.24, "end": 844.3199999999999, "text": " object class. It's checking if Java exists in that list, and obviously it does. That's pretty much", "tokens": [50944, 2657, 1508, 13, 467, 311, 8568, 498, 10745, 8198, 294, 300, 1329, 11, 293, 2745, 309, 775, 13, 663, 311, 1238, 709, 51248], "temperature": 0.0, "avg_logprob": -0.13326942110524595, "compression_ratio": 1.7387387387387387, "no_speech_prob": 0.006796353030949831}, {"id": 127, "seek": 82664, "start": 844.3199999999999, "end": 850.8, "text": " what reflexivity is. So, the next, if I have a hard word for me to pronounce. So, the next one is", "tokens": [51248, 437, 23802, 4253, 307, 13, 407, 11, 264, 958, 11, 498, 286, 362, 257, 1152, 1349, 337, 385, 281, 19567, 13, 407, 11, 264, 958, 472, 307, 51572], "temperature": 0.0, "avg_logprob": -0.13326942110524595, "compression_ratio": 1.7387387387387387, "no_speech_prob": 0.006796353030949831}, {"id": 128, "seek": 85080, "start": 850.8, "end": 857.12, "text": " symmetry. So, symmetry states, again, for any non-null reference values x and y, so we have", "tokens": [50364, 25440, 13, 407, 11, 25440, 4368, 11, 797, 11, 337, 604, 2107, 12, 77, 858, 6408, 4190, 2031, 293, 288, 11, 370, 321, 362, 50680], "temperature": 0.0, "avg_logprob": -0.11779133081436158, "compression_ratio": 1.590643274853801, "no_speech_prob": 0.03731617331504822}, {"id": 129, "seek": 85080, "start": 857.12, "end": 865.12, "text": " two objects in this case, x equals y must return true, if and only if y equals x returns true.", "tokens": [50680, 732, 6565, 294, 341, 1389, 11, 2031, 6915, 288, 1633, 2736, 2074, 11, 498, 293, 787, 498, 288, 6915, 2031, 11247, 2074, 13, 51080], "temperature": 0.0, "avg_logprob": -0.11779133081436158, "compression_ratio": 1.590643274853801, "no_speech_prob": 0.03731617331504822}, {"id": 130, "seek": 85080, "start": 865.12, "end": 869.68, "text": " So, again, going back to, I'm going to demo it in a bit, but going back to this here,", "tokens": [51080, 407, 11, 797, 11, 516, 646, 281, 11, 286, 478, 516, 281, 10723, 309, 294, 257, 857, 11, 457, 516, 646, 281, 341, 510, 11, 51308], "temperature": 0.0, "avg_logprob": -0.11779133081436158, "compression_ratio": 1.590643274853801, "no_speech_prob": 0.03731617331504822}, {"id": 131, "seek": 86968, "start": 870.64, "end": 876.4799999999999, "text": " s, s and b, so string s, so string s, if we take this,", "tokens": [50412, 262, 11, 262, 293, 272, 11, 370, 6798, 262, 11, 370, 6798, 262, 11, 498, 321, 747, 341, 11, 50704], "temperature": 0.0, "avg_logprob": -0.183964715075137, "compression_ratio": 1.4827586206896552, "no_speech_prob": 0.04145050793886185}, {"id": 132, "seek": 86968, "start": 879.3599999999999, "end": 891.12, "text": " equals b. This should return true only if b dot equals s returns true.", "tokens": [50848, 6915, 272, 13, 639, 820, 2736, 2074, 787, 498, 272, 5893, 6915, 262, 11247, 2074, 13, 51436], "temperature": 0.0, "avg_logprob": -0.183964715075137, "compression_ratio": 1.4827586206896552, "no_speech_prob": 0.04145050793886185}, {"id": 133, "seek": 86968, "start": 893.4399999999999, "end": 898.3199999999999, "text": " So, that's what symmetry is. And before we get to the demo, let's just read out this bit,", "tokens": [51552, 407, 11, 300, 311, 437, 25440, 307, 13, 400, 949, 321, 483, 281, 264, 10723, 11, 718, 311, 445, 1401, 484, 341, 857, 11, 51796], "temperature": 0.0, "avg_logprob": -0.183964715075137, "compression_ratio": 1.4827586206896552, "no_speech_prob": 0.04145050793886185}, {"id": 134, "seek": 89832, "start": 898.32, "end": 902.96, "text": " just should look at stated. The second requirement says that any two objects", "tokens": [50364, 445, 820, 574, 412, 11323, 13, 440, 1150, 11695, 1619, 300, 604, 732, 6565, 50596], "temperature": 0.0, "avg_logprob": -0.11819580302518957, "compression_ratio": 1.688073394495413, "no_speech_prob": 0.004133573267608881}, {"id": 135, "seek": 89832, "start": 902.96, "end": 908.4000000000001, "text": " must agree on whether they are equal. Unlike the first requirement, it's not hard to imagine", "tokens": [50596, 1633, 3986, 322, 1968, 436, 366, 2681, 13, 17657, 264, 700, 11695, 11, 309, 311, 406, 1152, 281, 3811, 50868], "temperature": 0.0, "avg_logprob": -0.11819580302518957, "compression_ratio": 1.688073394495413, "no_speech_prob": 0.004133573267608881}, {"id": 136, "seek": 89832, "start": 908.4000000000001, "end": 914.32, "text": " violating this one unintentionally. So, we have this class here called case and sensitive string,", "tokens": [50868, 42201, 341, 472, 45514, 379, 13, 407, 11, 321, 362, 341, 1508, 510, 1219, 1389, 293, 9477, 6798, 11, 51164], "temperature": 0.0, "avg_logprob": -0.11819580302518957, "compression_ratio": 1.688073394495413, "no_speech_prob": 0.004133573267608881}, {"id": 137, "seek": 89832, "start": 914.32, "end": 920.96, "text": " and it's an attempt to implement a case and sensitive string class. In the class, what we have is we", "tokens": [51164, 293, 309, 311, 364, 5217, 281, 4445, 257, 1389, 293, 9477, 6798, 1508, 13, 682, 264, 1508, 11, 437, 321, 362, 307, 321, 51496], "temperature": 0.0, "avg_logprob": -0.11819580302518957, "compression_ratio": 1.688073394495413, "no_speech_prob": 0.004133573267608881}, {"id": 138, "seek": 92096, "start": 920.96, "end": 927.84, "text": " have a private final string s variable. We have the constructor, which in this case just", "tokens": [50364, 362, 257, 4551, 2572, 6798, 262, 7006, 13, 492, 362, 264, 47479, 11, 597, 294, 341, 1389, 445, 50708], "temperature": 0.0, "avg_logprob": -0.12602787788468178, "compression_ratio": 1.6771300448430493, "no_speech_prob": 0.003172412747517228}, {"id": 139, "seek": 92096, "start": 928.8000000000001, "end": 936.32, "text": " checks if the object is non-null, if it is null, it returns a chosen error, and then it sets that", "tokens": [50756, 13834, 498, 264, 2657, 307, 2107, 12, 77, 858, 11, 498, 309, 307, 18184, 11, 309, 11247, 257, 8614, 6713, 11, 293, 550, 309, 6352, 300, 51132], "temperature": 0.0, "avg_logprob": -0.12602787788468178, "compression_ratio": 1.6771300448430493, "no_speech_prob": 0.003172412747517228}, {"id": 140, "seek": 92096, "start": 936.32, "end": 942.96, "text": " value in our private field here in the class. And then we have the equals method that we have", "tokens": [51132, 2158, 294, 527, 4551, 2519, 510, 294, 264, 1508, 13, 400, 550, 321, 362, 264, 6915, 3170, 300, 321, 362, 51464], "temperature": 0.0, "avg_logprob": -0.12602787788468178, "compression_ratio": 1.6771300448430493, "no_speech_prob": 0.003172412747517228}, {"id": 141, "seek": 92096, "start": 942.96, "end": 948.64, "text": " overridden, which breaks symmetry. So, firstly, I'll show the one, but the problem, I'll show", "tokens": [51464, 670, 81, 6171, 11, 597, 9857, 25440, 13, 407, 11, 27376, 11, 286, 603, 855, 264, 472, 11, 457, 264, 1154, 11, 286, 603, 855, 51748], "temperature": 0.0, "avg_logprob": -0.12602787788468178, "compression_ratio": 1.6771300448430493, "no_speech_prob": 0.003172412747517228}, {"id": 142, "seek": 94864, "start": 949.6, "end": 953.36, "text": " the wrong way to do it. And then we also have another equals method written", "tokens": [50412, 264, 2085, 636, 281, 360, 309, 13, 400, 550, 321, 611, 362, 1071, 6915, 3170, 3720, 50600], "temperature": 0.0, "avg_logprob": -0.09343398489603182, "compression_ratio": 1.8629032258064515, "no_speech_prob": 0.0012447740882635117}, {"id": 143, "seek": 94864, "start": 954.0, "end": 960.0, "text": " below here, which is the proper way to do it. And that'll fix the issue. So, let's take a look at", "tokens": [50632, 2507, 510, 11, 597, 307, 264, 2296, 636, 281, 360, 309, 13, 400, 300, 603, 3191, 264, 2734, 13, 407, 11, 718, 311, 747, 257, 574, 412, 50932], "temperature": 0.0, "avg_logprob": -0.09343398489603182, "compression_ratio": 1.8629032258064515, "no_speech_prob": 0.0012447740882635117}, {"id": 144, "seek": 94864, "start": 960.0, "end": 966.0, "text": " this equals method that we've overridden. So, we have two if conditions here in the equals method.", "tokens": [50932, 341, 6915, 3170, 300, 321, 600, 670, 81, 6171, 13, 407, 11, 321, 362, 732, 498, 4487, 510, 294, 264, 6915, 3170, 13, 51232], "temperature": 0.0, "avg_logprob": -0.09343398489603182, "compression_ratio": 1.8629032258064515, "no_speech_prob": 0.0012447740882635117}, {"id": 145, "seek": 94864, "start": 966.0, "end": 972.56, "text": " In the first one, what we're checking is if this object v pass is an instance of the case", "tokens": [51232, 682, 264, 700, 472, 11, 437, 321, 434, 8568, 307, 498, 341, 2657, 371, 1320, 307, 364, 5197, 295, 264, 1389, 51560], "temperature": 0.0, "avg_logprob": -0.09343398489603182, "compression_ratio": 1.8629032258064515, "no_speech_prob": 0.0012447740882635117}, {"id": 146, "seek": 94864, "start": 972.56, "end": 977.36, "text": " in sensitive class. So, that's what we're checking here using the instance of method. And if it is,", "tokens": [51560, 294, 9477, 1508, 13, 407, 11, 300, 311, 437, 321, 434, 8568, 510, 1228, 264, 5197, 295, 3170, 13, 400, 498, 309, 307, 11, 51800], "temperature": 0.0, "avg_logprob": -0.09343398489603182, "compression_ratio": 1.8629032258064515, "no_speech_prob": 0.0012447740882635117}, {"id": 147, "seek": 97736, "start": 977.36, "end": 985.52, "text": " then it'll just return true if that. So, firstly, we cast that object into case in sensitive string.", "tokens": [50364, 550, 309, 603, 445, 2736, 2074, 498, 300, 13, 407, 11, 27376, 11, 321, 4193, 300, 2657, 666, 1389, 294, 9477, 6798, 13, 50772], "temperature": 0.0, "avg_logprob": -0.10954329991104579, "compression_ratio": 1.7830188679245282, "no_speech_prob": 0.002251680474728346}, {"id": 148, "seek": 97736, "start": 985.52, "end": 991.44, "text": " If it is an instance of that, let's say a subclass of that, then we cast it to become a", "tokens": [50772, 759, 309, 307, 364, 5197, 295, 300, 11, 718, 311, 584, 257, 1422, 11665, 295, 300, 11, 550, 321, 4193, 309, 281, 1813, 257, 51068], "temperature": 0.0, "avg_logprob": -0.10954329991104579, "compression_ratio": 1.7830188679245282, "no_speech_prob": 0.002251680474728346}, {"id": 149, "seek": 97736, "start": 991.44, "end": 997.6, "text": " case in sensitive string. And then we compare it to our string field really that we defined here", "tokens": [51068, 1389, 294, 9477, 6798, 13, 400, 550, 321, 6794, 309, 281, 527, 6798, 2519, 534, 300, 321, 7642, 510, 51376], "temperature": 0.0, "avg_logprob": -0.10954329991104579, "compression_ratio": 1.7830188679245282, "no_speech_prob": 0.002251680474728346}, {"id": 150, "seek": 97736, "start": 997.6, "end": 1003.9200000000001, "text": " in line number 15. And if it is equals in that case, we return true. And that's fine. That's", "tokens": [51376, 294, 1622, 1230, 2119, 13, 400, 498, 309, 307, 6915, 294, 300, 1389, 11, 321, 2736, 2074, 13, 400, 300, 311, 2489, 13, 663, 311, 51692], "temperature": 0.0, "avg_logprob": -0.10954329991104579, "compression_ratio": 1.7830188679245282, "no_speech_prob": 0.002251680474728346}, {"id": 151, "seek": 100392, "start": 1003.92, "end": 1010.16, "text": " going to work. But then we're trying to go one step further and attempting to make this interoperable", "tokens": [50364, 516, 281, 589, 13, 583, 550, 321, 434, 1382, 281, 352, 472, 1823, 3052, 293, 22001, 281, 652, 341, 728, 7192, 712, 50676], "temperature": 0.0, "avg_logprob": -0.08732343206600267, "compression_ratio": 1.6812227074235808, "no_speech_prob": 0.009124843403697014}, {"id": 152, "seek": 100392, "start": 1010.16, "end": 1016.7199999999999, "text": " with a string class. So, again, the same way we're checking if this past object is an instance of", "tokens": [50676, 365, 257, 6798, 1508, 13, 407, 11, 797, 11, 264, 912, 636, 321, 434, 8568, 498, 341, 1791, 2657, 307, 364, 5197, 295, 51004], "temperature": 0.0, "avg_logprob": -0.08732343206600267, "compression_ratio": 1.6812227074235808, "no_speech_prob": 0.009124843403697014}, {"id": 153, "seek": 100392, "start": 1016.7199999999999, "end": 1025.44, "text": " the string class. And then we are saying return true if it's equal to a string. And we just cast", "tokens": [51004, 264, 6798, 1508, 13, 400, 550, 321, 366, 1566, 2736, 2074, 498, 309, 311, 2681, 281, 257, 6798, 13, 400, 321, 445, 4193, 51440], "temperature": 0.0, "avg_logprob": -0.08732343206600267, "compression_ratio": 1.6812227074235808, "no_speech_prob": 0.009124843403697014}, {"id": 154, "seek": 100392, "start": 1025.44, "end": 1031.2, "text": " it accordingly. And this is what breaks the symmetry. And I'll show you what that means.", "tokens": [51440, 309, 19717, 13, 400, 341, 307, 437, 9857, 264, 25440, 13, 400, 286, 603, 855, 291, 437, 300, 1355, 13, 51728], "temperature": 0.0, "avg_logprob": -0.08732343206600267, "compression_ratio": 1.6812227074235808, "no_speech_prob": 0.009124843403697014}, {"id": 155, "seek": 103120, "start": 1031.2, "end": 1036.96, "text": " And of course, this line here, if it doesn't meet all these conditions, it'll return false.", "tokens": [50364, 400, 295, 1164, 11, 341, 1622, 510, 11, 498, 309, 1177, 380, 1677, 439, 613, 4487, 11, 309, 603, 2736, 7908, 13, 50652], "temperature": 0.0, "avg_logprob": -0.09682896815308738, "compression_ratio": 1.8024193548387097, "no_speech_prob": 0.0018100844463333488}, {"id": 156, "seek": 103120, "start": 1036.96, "end": 1041.1200000000001, "text": " So, in the public static void main, what I have is I have an instance of", "tokens": [50652, 407, 11, 294, 264, 1908, 13437, 22009, 2135, 11, 437, 286, 362, 307, 286, 362, 364, 5197, 295, 50860], "temperature": 0.0, "avg_logprob": -0.09682896815308738, "compression_ratio": 1.8024193548387097, "no_speech_prob": 0.0018100844463333488}, {"id": 157, "seek": 103120, "start": 1041.1200000000001, "end": 1048.0, "text": " case in sensitive string. And then I have another normal string instance. What we're doing initially", "tokens": [50860, 1389, 294, 9477, 6798, 13, 400, 550, 286, 362, 1071, 2710, 6798, 5197, 13, 708, 321, 434, 884, 9105, 51204], "temperature": 0.0, "avg_logprob": -0.09682896815308738, "compression_ratio": 1.8024193548387097, "no_speech_prob": 0.0018100844463333488}, {"id": 158, "seek": 103120, "start": 1048.0, "end": 1054.48, "text": " is we're checking if this case in sensitive string is equal to s. And that will return", "tokens": [51204, 307, 321, 434, 8568, 498, 341, 1389, 294, 9477, 6798, 307, 2681, 281, 262, 13, 400, 300, 486, 2736, 51528], "temperature": 0.0, "avg_logprob": -0.09682896815308738, "compression_ratio": 1.8024193548387097, "no_speech_prob": 0.0018100844463333488}, {"id": 159, "seek": 103120, "start": 1054.48, "end": 1059.52, "text": " true as expected because we're passing the word Polish here, the string Polish, and the string", "tokens": [51528, 2074, 382, 5176, 570, 321, 434, 8437, 264, 1349, 18504, 510, 11, 264, 6798, 18504, 11, 293, 264, 6798, 51780], "temperature": 0.0, "avg_logprob": -0.09682896815308738, "compression_ratio": 1.8024193548387097, "no_speech_prob": 0.0018100844463333488}, {"id": 160, "seek": 105952, "start": 1059.52, "end": 1066.6399999999999, "text": " itself has Polish. And even though the first letter is uppercase, and here it's not uppercase,", "tokens": [50364, 2564, 575, 18504, 13, 400, 754, 1673, 264, 700, 5063, 307, 11775, 2869, 651, 11, 293, 510, 309, 311, 406, 11775, 2869, 651, 11, 50720], "temperature": 0.0, "avg_logprob": -0.10764575997988383, "compression_ratio": 1.6818181818181819, "no_speech_prob": 0.003171700518578291}, {"id": 161, "seek": 105952, "start": 1066.6399999999999, "end": 1072.08, "text": " it's lowercase, it doesn't matter because this equality, what we're doing, the logical equality,", "tokens": [50720, 309, 311, 3126, 9765, 11, 309, 1177, 380, 1871, 570, 341, 14949, 11, 437, 321, 434, 884, 11, 264, 14978, 14949, 11, 50992], "temperature": 0.0, "avg_logprob": -0.10764575997988383, "compression_ratio": 1.6818181818181819, "no_speech_prob": 0.003171700518578291}, {"id": 162, "seek": 105952, "start": 1072.6399999999999, "end": 1077.28, "text": " what we care about is for it to be case in sensitive. We don't care about the case.", "tokens": [51020, 437, 321, 1127, 466, 307, 337, 309, 281, 312, 1389, 294, 9477, 13, 492, 500, 380, 1127, 466, 264, 1389, 13, 51252], "temperature": 0.0, "avg_logprob": -0.10764575997988383, "compression_ratio": 1.6818181818181819, "no_speech_prob": 0.003171700518578291}, {"id": 163, "seek": 105952, "start": 1078.16, "end": 1084.96, "text": " But here, this is where the symmetry is violated. Because we are attempting in I equals method", "tokens": [51296, 583, 510, 11, 341, 307, 689, 264, 25440, 307, 33239, 13, 1436, 321, 366, 22001, 294, 286, 6915, 3170, 51636], "temperature": 0.0, "avg_logprob": -0.10764575997988383, "compression_ratio": 1.6818181818181819, "no_speech_prob": 0.003171700518578291}, {"id": 164, "seek": 108496, "start": 1085.92, "end": 1094.56, "text": " for this to be interoperable with normal strings, we're doing the comparison the other way around", "tokens": [50412, 337, 341, 281, 312, 728, 7192, 712, 365, 2710, 13985, 11, 321, 434, 884, 264, 9660, 264, 661, 636, 926, 50844], "temperature": 0.0, "avg_logprob": -0.12551565806070963, "compression_ratio": 1.6404494382022472, "no_speech_prob": 0.0066916244104504585}, {"id": 165, "seek": 108496, "start": 1094.56, "end": 1102.96, "text": " instead of comparing sys with s, we're comparing s with sys, and this returns false. Furthermore,", "tokens": [50844, 2602, 295, 15763, 262, 749, 365, 262, 11, 321, 434, 15763, 262, 365, 262, 749, 11, 293, 341, 11247, 7908, 13, 23999, 11, 51264], "temperature": 0.0, "avg_logprob": -0.12551565806070963, "compression_ratio": 1.6404494382022472, "no_speech_prob": 0.0066916244104504585}, {"id": 166, "seek": 108496, "start": 1102.96, "end": 1110.88, "text": " if we add this string, I don't want to call it a string because it's a case in sensitive string,", "tokens": [51264, 498, 321, 909, 341, 6798, 11, 286, 500, 380, 528, 281, 818, 309, 257, 6798, 570, 309, 311, 257, 1389, 294, 9477, 6798, 11, 51660], "temperature": 0.0, "avg_logprob": -0.12551565806070963, "compression_ratio": 1.6404494382022472, "no_speech_prob": 0.0066916244104504585}, {"id": 167, "seek": 111088, "start": 1111.8400000000001, "end": 1118.16, "text": " into a list of type case in sensitive string, it's a bit of a mouthful. And be printed, we", "tokens": [50412, 666, 257, 1329, 295, 2010, 1389, 294, 9477, 6798, 11, 309, 311, 257, 857, 295, 257, 4525, 906, 13, 400, 312, 13567, 11, 321, 50728], "temperature": 0.0, "avg_logprob": -0.13546493779058041, "compression_ratio": 1.6140350877192982, "no_speech_prob": 0.01639694534242153}, {"id": 168, "seek": 111088, "start": 1118.16, "end": 1123.7600000000002, "text": " expect this to return true, but it doesn't, it returns false. So that again demonstrates the", "tokens": [50728, 2066, 341, 281, 2736, 2074, 11, 457, 309, 1177, 380, 11, 309, 11247, 7908, 13, 407, 300, 797, 31034, 264, 51008], "temperature": 0.0, "avg_logprob": -0.13546493779058041, "compression_ratio": 1.6140350877192982, "no_speech_prob": 0.01639694534242153}, {"id": 169, "seek": 111088, "start": 1123.7600000000002, "end": 1130.24, "text": " violation of symmetry because the contains method uses the concept of logical equality,", "tokens": [51008, 22840, 295, 25440, 570, 264, 8306, 3170, 4960, 264, 3410, 295, 14978, 14949, 11, 51332], "temperature": 0.0, "avg_logprob": -0.13546493779058041, "compression_ratio": 1.6140350877192982, "no_speech_prob": 0.01639694534242153}, {"id": 170, "seek": 111088, "start": 1130.24, "end": 1136.4, "text": " and we don't have logical equality here. So if I do run this, you'll see it'll return true false", "tokens": [51332, 293, 321, 500, 380, 362, 14978, 14949, 510, 13, 407, 498, 286, 360, 1190, 341, 11, 291, 603, 536, 309, 603, 2736, 2074, 7908, 51640], "temperature": 0.0, "avg_logprob": -0.13546493779058041, "compression_ratio": 1.6140350877192982, "no_speech_prob": 0.01639694534242153}, {"id": 171, "seek": 113640, "start": 1136.88, "end": 1148.4, "text": " false. Right there. So this is the problem. Now, before I get to the fix, let me read out", "tokens": [50388, 7908, 13, 1779, 456, 13, 407, 341, 307, 264, 1154, 13, 823, 11, 949, 286, 483, 281, 264, 3191, 11, 718, 385, 1401, 484, 50964], "temperature": 0.0, "avg_logprob": -0.16713555653889975, "compression_ratio": 1.4722222222222223, "no_speech_prob": 0.010011060163378716}, {"id": 172, "seek": 113640, "start": 1148.4, "end": 1153.76, "text": " to put it a bit more formally and cleanly what Joshua Bloch has stated. He states,", "tokens": [50964, 281, 829, 309, 257, 857, 544, 25983, 293, 2541, 356, 437, 24005, 9865, 339, 575, 11323, 13, 634, 4368, 11, 51232], "temperature": 0.0, "avg_logprob": -0.16713555653889975, "compression_ratio": 1.4722222222222223, "no_speech_prob": 0.010011060163378716}, {"id": 173, "seek": 113640, "start": 1154.64, "end": 1163.1200000000001, "text": " as expected, so he's referring to this bit here, as expected, sys dot equals s returns true.", "tokens": [51276, 382, 5176, 11, 370, 415, 311, 13761, 281, 341, 857, 510, 11, 382, 5176, 11, 262, 749, 5893, 6915, 262, 11247, 2074, 13, 51700], "temperature": 0.0, "avg_logprob": -0.16713555653889975, "compression_ratio": 1.4722222222222223, "no_speech_prob": 0.010011060163378716}, {"id": 174, "seek": 116312, "start": 1164.0, "end": 1168.8799999999999, "text": " The problem is that while the equals method in case in case in sensitive string", "tokens": [50408, 440, 1154, 307, 300, 1339, 264, 6915, 3170, 294, 1389, 294, 1389, 294, 9477, 6798, 50652], "temperature": 0.0, "avg_logprob": -0.11524117377496534, "compression_ratio": 1.8402777777777777, "no_speech_prob": 0.004537978675216436}, {"id": 175, "seek": 116312, "start": 1169.52, "end": 1176.9599999999998, "text": " knows about ordinary strings, the equals method in string is oblivious to case in sensitive strings.", "tokens": [50684, 3255, 466, 10547, 13985, 11, 264, 6915, 3170, 294, 6798, 307, 47039, 851, 281, 1389, 294, 9477, 13985, 13, 51056], "temperature": 0.0, "avg_logprob": -0.11524117377496534, "compression_ratio": 1.8402777777777777, "no_speech_prob": 0.004537978675216436}, {"id": 176, "seek": 116312, "start": 1176.9599999999998, "end": 1182.9599999999998, "text": " So that is the equals method that we're going to use here in this slide that we use.", "tokens": [51056, 407, 300, 307, 264, 6915, 3170, 300, 321, 434, 516, 281, 764, 510, 294, 341, 4137, 300, 321, 764, 13, 51356], "temperature": 0.0, "avg_logprob": -0.11524117377496534, "compression_ratio": 1.8402777777777777, "no_speech_prob": 0.004537978675216436}, {"id": 177, "seek": 118296, "start": 1182.96, "end": 1193.8400000000001, "text": " Therefore s dot equals says returns false. So he's referring to that bit here now where it", "tokens": [50364, 7504, 262, 5893, 6915, 1619, 11247, 7908, 13, 407, 415, 311, 13761, 281, 300, 857, 510, 586, 689, 309, 50908], "temperature": 0.0, "avg_logprob": -0.1516718809632049, "compression_ratio": 1.6457399103139014, "no_speech_prob": 0.003272709669545293}, {"id": 178, "seek": 118296, "start": 1193.8400000000001, "end": 1200.24, "text": " returns false. A clear violation of symmetry, suppose you put a case in sensitive string into", "tokens": [50908, 11247, 7908, 13, 316, 1850, 22840, 295, 25440, 11, 7297, 291, 829, 257, 1389, 294, 9477, 6798, 666, 51228], "temperature": 0.0, "avg_logprob": -0.1516718809632049, "compression_ratio": 1.6457399103139014, "no_speech_prob": 0.003272709669545293}, {"id": 179, "seek": 118296, "start": 1200.24, "end": 1204.64, "text": " a collection. So that's where moving on to the next bit here, which we again see that it's", "tokens": [51228, 257, 5765, 13, 407, 300, 311, 689, 2684, 322, 281, 264, 958, 857, 510, 11, 597, 321, 797, 536, 300, 309, 311, 51448], "temperature": 0.0, "avg_logprob": -0.1516718809632049, "compression_ratio": 1.6457399103139014, "no_speech_prob": 0.003272709669545293}, {"id": 180, "seek": 118296, "start": 1204.64, "end": 1209.3600000000001, "text": " returning false. And this is a bit difficult to understand because here's what Joshua Bloch", "tokens": [51448, 12678, 7908, 13, 400, 341, 307, 257, 857, 2252, 281, 1223, 570, 510, 311, 437, 24005, 9865, 339, 51684], "temperature": 0.0, "avg_logprob": -0.1516718809632049, "compression_ratio": 1.6457399103139014, "no_speech_prob": 0.003272709669545293}, {"id": 181, "seek": 120936, "start": 1209.36, "end": 1214.08, "text": " states on the contains method. Now, I was under the, well, I guess my assumption is right. My", "tokens": [50364, 4368, 322, 264, 8306, 3170, 13, 823, 11, 286, 390, 833, 264, 11, 731, 11, 286, 2041, 452, 15302, 307, 558, 13, 1222, 50600], "temperature": 0.0, "avg_logprob": -0.15279976914568646, "compression_ratio": 1.7285714285714286, "no_speech_prob": 0.03787590190768242}, {"id": 182, "seek": 120936, "start": 1214.08, "end": 1220.24, "text": " assumption was that because this violates the equals contract and the idea of logical equality", "tokens": [50600, 15302, 390, 300, 570, 341, 3448, 1024, 264, 6915, 4364, 293, 264, 1558, 295, 14978, 14949, 50908], "temperature": 0.0, "avg_logprob": -0.15279976914568646, "compression_ratio": 1.7285714285714286, "no_speech_prob": 0.03787590190768242}, {"id": 183, "seek": 120936, "start": 1220.8799999999999, "end": 1228.56, "text": " and the contains method use ensures that objects that it gets respect this contract.", "tokens": [50940, 293, 264, 8306, 3170, 764, 28111, 300, 6565, 300, 309, 2170, 3104, 341, 4364, 13, 51324], "temperature": 0.0, "avg_logprob": -0.15279976914568646, "compression_ratio": 1.7285714285714286, "no_speech_prob": 0.03787590190768242}, {"id": 184, "seek": 120936, "start": 1229.52, "end": 1234.32, "text": " It acts accordingly. Therefore why it's printing false here or it's returning false here.", "tokens": [51372, 467, 10672, 19717, 13, 7504, 983, 309, 311, 14699, 7908, 510, 420, 309, 311, 12678, 7908, 510, 13, 51612], "temperature": 0.0, "avg_logprob": -0.15279976914568646, "compression_ratio": 1.7285714285714286, "no_speech_prob": 0.03787590190768242}, {"id": 185, "seek": 123432, "start": 1234.32, "end": 1240.1599999999999, "text": " But here's what Joshua Bloch states. And I think my assumption is at least quasi accurate.", "tokens": [50364, 583, 510, 311, 437, 24005, 9865, 339, 4368, 13, 400, 286, 519, 452, 15302, 307, 412, 1935, 20954, 8559, 13, 50656], "temperature": 0.0, "avg_logprob": -0.14731421837439904, "compression_ratio": 1.6140350877192982, "no_speech_prob": 0.0015977167058736086}, {"id": 186, "seek": 123432, "start": 1241.52, "end": 1247.6, "text": " What does list dot contains s return at this point? And then he says, who knows? In the current", "tokens": [50724, 708, 775, 1329, 5893, 8306, 262, 2736, 412, 341, 935, 30, 400, 550, 415, 1619, 11, 567, 3255, 30, 682, 264, 2190, 51028], "temperature": 0.0, "avg_logprob": -0.14731421837439904, "compression_ratio": 1.6140350877192982, "no_speech_prob": 0.0015977167058736086}, {"id": 187, "seek": 123432, "start": 1247.6, "end": 1252.32, "text": " open JDK implementation, it happens to return false. So that's what we saw here. The third", "tokens": [51028, 1269, 37082, 42, 11420, 11, 309, 2314, 281, 2736, 7908, 13, 407, 300, 311, 437, 321, 1866, 510, 13, 440, 2636, 51264], "temperature": 0.0, "avg_logprob": -0.14731421837439904, "compression_ratio": 1.6140350877192982, "no_speech_prob": 0.0015977167058736086}, {"id": 188, "seek": 123432, "start": 1252.32, "end": 1258.48, "text": " false is by this list dot contains. But that's just an implementation artifact. In another", "tokens": [51264, 7908, 307, 538, 341, 1329, 5893, 8306, 13, 583, 300, 311, 445, 364, 11420, 34806, 13, 682, 1071, 51572], "temperature": 0.0, "avg_logprob": -0.14731421837439904, "compression_ratio": 1.6140350877192982, "no_speech_prob": 0.0015977167058736086}, {"id": 189, "seek": 125848, "start": 1258.56, "end": 1264.24, "text": " implementation, it could just as easily return true or throw a runtime exception.", "tokens": [50368, 11420, 11, 309, 727, 445, 382, 3612, 2736, 2074, 420, 3507, 257, 34474, 11183, 13, 50652], "temperature": 0.0, "avg_logprob": -0.0883638224470506, "compression_ratio": 1.691449814126394, "no_speech_prob": 0.003593350062146783}, {"id": 190, "seek": 125848, "start": 1265.28, "end": 1272.16, "text": " Once you violated the equals contract, you simply don't know how other objects will behave", "tokens": [50704, 3443, 291, 33239, 264, 6915, 4364, 11, 291, 2935, 500, 380, 458, 577, 661, 6565, 486, 15158, 51048], "temperature": 0.0, "avg_logprob": -0.0883638224470506, "compression_ratio": 1.691449814126394, "no_speech_prob": 0.003593350062146783}, {"id": 191, "seek": 125848, "start": 1272.16, "end": 1278.8, "text": " when confronted with your object. To eliminate the problem, merely remove the ill-conceived", "tokens": [51048, 562, 31257, 365, 428, 2657, 13, 1407, 13819, 264, 1154, 11, 17003, 4159, 264, 3171, 12, 1671, 384, 3194, 51380], "temperature": 0.0, "avg_logprob": -0.0883638224470506, "compression_ratio": 1.691449814126394, "no_speech_prob": 0.003593350062146783}, {"id": 192, "seek": 125848, "start": 1278.8, "end": 1282.88, "text": " attempt to interoperate with string from the equals method. I shouldn't have read that part yet.", "tokens": [51380, 5217, 281, 728, 7192, 473, 365, 6798, 490, 264, 6915, 3170, 13, 286, 4659, 380, 362, 1401, 300, 644, 1939, 13, 51584], "temperature": 0.0, "avg_logprob": -0.0883638224470506, "compression_ratio": 1.691449814126394, "no_speech_prob": 0.003593350062146783}, {"id": 193, "seek": 125848, "start": 1282.88, "end": 1287.1200000000001, "text": " I'll read that again, but that's how we fix the problem. So I'm going to read that bit again,", "tokens": [51584, 286, 603, 1401, 300, 797, 11, 457, 300, 311, 577, 321, 3191, 264, 1154, 13, 407, 286, 478, 516, 281, 1401, 300, 857, 797, 11, 51796], "temperature": 0.0, "avg_logprob": -0.0883638224470506, "compression_ratio": 1.691449814126394, "no_speech_prob": 0.003593350062146783}, {"id": 194, "seek": 128712, "start": 1287.1999999999998, "end": 1293.6, "text": " though. Once you violated the equals contract, you simply don't know how other objects will behave", "tokens": [50368, 1673, 13, 3443, 291, 33239, 264, 6915, 4364, 11, 291, 2935, 500, 380, 458, 577, 661, 6565, 486, 15158, 50688], "temperature": 0.0, "avg_logprob": -0.09744570228490937, "compression_ratio": 1.5606694560669456, "no_speech_prob": 0.034596722573041916}, {"id": 195, "seek": 128712, "start": 1294.2399999999998, "end": 1300.4799999999998, "text": " when confronted with your object. This goes back to the idea I touched on a bit before by", "tokens": [50720, 562, 31257, 365, 428, 2657, 13, 639, 1709, 646, 281, 264, 1558, 286, 9828, 322, 257, 857, 949, 538, 51032], "temperature": 0.0, "avg_logprob": -0.09744570228490937, "compression_ratio": 1.5606694560669456, "no_speech_prob": 0.034596722573041916}, {"id": 196, "seek": 128712, "start": 1300.4799999999998, "end": 1307.6799999999998, "text": " Sandy Metz on the book I was referring to, the Ruby book, that it's probably the best way to", "tokens": [51032, 27390, 6377, 89, 322, 264, 1446, 286, 390, 13761, 281, 11, 264, 19907, 1446, 11, 300, 309, 311, 1391, 264, 1151, 636, 281, 51392], "temperature": 0.0, "avg_logprob": -0.09744570228490937, "compression_ratio": 1.5606694560669456, "no_speech_prob": 0.034596722573041916}, {"id": 197, "seek": 128712, "start": 1307.6799999999998, "end": 1315.52, "text": " think about OOP is in the context of messages and how objects interact with each other over", "tokens": [51392, 519, 466, 422, 12059, 307, 294, 264, 4319, 295, 7897, 293, 577, 6565, 4648, 365, 1184, 661, 670, 51784], "temperature": 0.0, "avg_logprob": -0.09744570228490937, "compression_ratio": 1.5606694560669456, "no_speech_prob": 0.034596722573041916}, {"id": 198, "seek": 131552, "start": 1315.6, "end": 1322.48, "text": " objects because objects aren't an island as we read from John Dunn. So that's what happens here.", "tokens": [50368, 6565, 570, 6565, 3212, 380, 364, 6077, 382, 321, 1401, 490, 2619, 11959, 77, 13, 407, 300, 311, 437, 2314, 510, 13, 50712], "temperature": 0.0, "avg_logprob": -0.10997621862737982, "compression_ratio": 1.654275092936803, "no_speech_prob": 0.009122678078711033}, {"id": 199, "seek": 131552, "start": 1322.48, "end": 1328.6399999999999, "text": " The contains method makes a lot of assumptions and those assumptions are wrong because, well,", "tokens": [50712, 440, 8306, 3170, 1669, 257, 688, 295, 17695, 293, 729, 17695, 366, 2085, 570, 11, 731, 11, 51020], "temperature": 0.0, "avg_logprob": -0.10997621862737982, "compression_ratio": 1.654275092936803, "no_speech_prob": 0.009122678078711033}, {"id": 200, "seek": 131552, "start": 1328.6399999999999, "end": 1332.32, "text": " the assumptions aren't really wrong, but we've made a mistake in our object.", "tokens": [51020, 264, 17695, 3212, 380, 534, 2085, 11, 457, 321, 600, 1027, 257, 6146, 294, 527, 2657, 13, 51204], "temperature": 0.0, "avg_logprob": -0.10997621862737982, "compression_ratio": 1.654275092936803, "no_speech_prob": 0.009122678078711033}, {"id": 201, "seek": 131552, "start": 1332.32, "end": 1338.16, "text": " Therefore, it breaks things. There's no logical equality. Now, getting back to how we fix this,", "tokens": [51204, 7504, 11, 309, 9857, 721, 13, 821, 311, 572, 14978, 14949, 13, 823, 11, 1242, 646, 281, 577, 321, 3191, 341, 11, 51496], "temperature": 0.0, "avg_logprob": -0.10997621862737982, "compression_ratio": 1.654275092936803, "no_speech_prob": 0.009122678078711033}, {"id": 202, "seek": 131552, "start": 1338.16, "end": 1344.16, "text": " as I did read that line, which I shall reread, it's simply ensuring that we don't", "tokens": [51496, 382, 286, 630, 1401, 300, 1622, 11, 597, 286, 4393, 46453, 345, 11, 309, 311, 2935, 16882, 300, 321, 500, 380, 51796], "temperature": 0.0, "avg_logprob": -0.10997621862737982, "compression_ratio": 1.654275092936803, "no_speech_prob": 0.009122678078711033}, {"id": 203, "seek": 134416, "start": 1344.16, "end": 1349.68, "text": " try and attempt for the case in sensitive string objects to interoperate with string objects.", "tokens": [50364, 853, 293, 5217, 337, 264, 1389, 294, 9477, 6798, 6565, 281, 728, 7192, 473, 365, 6798, 6565, 13, 50640], "temperature": 0.0, "avg_logprob": -0.138843718539463, "compression_ratio": 1.8391959798994975, "no_speech_prob": 0.003944832365959883}, {"id": 204, "seek": 134416, "start": 1349.68, "end": 1354.88, "text": " And the way we do that is, I'm going to comment out this equals method because we can't have", "tokens": [50640, 400, 264, 636, 321, 360, 300, 307, 11, 286, 478, 516, 281, 2871, 484, 341, 6915, 3170, 570, 321, 393, 380, 362, 50900], "temperature": 0.0, "avg_logprob": -0.138843718539463, "compression_ratio": 1.8391959798994975, "no_speech_prob": 0.003944832365959883}, {"id": 205, "seek": 134416, "start": 1354.88, "end": 1359.8400000000001, "text": " two equals method in the same class equals methods in the same class, unless it's overloaded.", "tokens": [50900, 732, 6915, 3170, 294, 264, 912, 1508, 6915, 7150, 294, 264, 912, 1508, 11, 5969, 309, 311, 28777, 292, 13, 51148], "temperature": 0.0, "avg_logprob": -0.138843718539463, "compression_ratio": 1.8391959798994975, "no_speech_prob": 0.003944832365959883}, {"id": 206, "seek": 134416, "start": 1362.3200000000002, "end": 1367.1200000000001, "text": " And then I'm going to get the other equals method, which doesn't attempt to override.", "tokens": [51272, 400, 550, 286, 478, 516, 281, 483, 264, 661, 6915, 3170, 11, 597, 1177, 380, 5217, 281, 42321, 13, 51512], "temperature": 0.0, "avg_logprob": -0.138843718539463, "compression_ratio": 1.8391959798994975, "no_speech_prob": 0.003944832365959883}, {"id": 207, "seek": 136712, "start": 1367.76, "end": 1368.3999999999999, "text": " Oops.", "tokens": [50396, 21726, 13, 50428], "temperature": 0.0, "avg_logprob": -0.23699029775766225, "compression_ratio": 1.5776397515527951, "no_speech_prob": 0.001206470769830048}, {"id": 208, "seek": 136712, "start": 1371.4399999999998, "end": 1376.9599999999998, "text": " Doesn't attempt to not override to interoperate with strings. It simply checks if it's an", "tokens": [50580, 12955, 380, 5217, 281, 406, 42321, 281, 728, 7192, 473, 365, 13985, 13, 467, 2935, 13834, 498, 309, 311, 364, 50856], "temperature": 0.0, "avg_logprob": -0.23699029775766225, "compression_ratio": 1.5776397515527951, "no_speech_prob": 0.001206470769830048}, {"id": 209, "seek": 136712, "start": 1376.9599999999998, "end": 1382.08, "text": " instance of case in sensitive string and then casts the case in sensitive string and just", "tokens": [50856, 5197, 295, 1389, 294, 9477, 6798, 293, 550, 41921, 264, 1389, 294, 9477, 6798, 293, 445, 51112], "temperature": 0.0, "avg_logprob": -0.23699029775766225, "compression_ratio": 1.5776397515527951, "no_speech_prob": 0.001206470769830048}, {"id": 210, "seek": 136712, "start": 1382.08, "end": 1390.1599999999999, "text": " the normal equals ignoring the case. So now, if I run this bit here,", "tokens": [51112, 264, 2710, 6915, 26258, 264, 1389, 13, 407, 586, 11, 498, 286, 1190, 341, 857, 510, 11, 51516], "temperature": 0.0, "avg_logprob": -0.23699029775766225, "compression_ratio": 1.5776397515527951, "no_speech_prob": 0.001206470769830048}, {"id": 211, "seek": 139016, "start": 1390.5600000000002, "end": 1397.28, "text": " you'll see I'm going to comment out these lines because they're, in fact, actually, no, maybe", "tokens": [50384, 291, 603, 536, 286, 478, 516, 281, 2871, 484, 613, 3876, 570, 436, 434, 11, 294, 1186, 11, 767, 11, 572, 11, 1310, 50720], "temperature": 0.0, "avg_logprob": -0.16079085480933095, "compression_ratio": 1.6452991452991452, "no_speech_prob": 0.0028006923384964466}, {"id": 212, "seek": 139016, "start": 1397.28, "end": 1404.8000000000002, "text": " what I should do is I'm going to go and run the whole thing. And now the first three are printing", "tokens": [50720, 437, 286, 820, 360, 307, 286, 478, 516, 281, 352, 293, 1190, 264, 1379, 551, 13, 400, 586, 264, 700, 1045, 366, 14699, 51096], "temperature": 0.0, "avg_logprob": -0.16079085480933095, "compression_ratio": 1.6452991452991452, "no_speech_prob": 0.0028006923384964466}, {"id": 213, "seek": 139016, "start": 1404.8000000000002, "end": 1409.92, "text": " faults and we expect it to print faults. We want it to because we don't want any interoperability", "tokens": [51096, 36090, 293, 321, 2066, 309, 281, 4482, 36090, 13, 492, 528, 309, 281, 570, 321, 500, 380, 528, 604, 728, 7192, 2310, 51352], "temperature": 0.0, "avg_logprob": -0.16079085480933095, "compression_ratio": 1.6452991452991452, "no_speech_prob": 0.0028006923384964466}, {"id": 214, "seek": 139016, "start": 1411.0400000000002, "end": 1417.0400000000002, "text": " with strings. And then in the second one, we're checking if it's equals and we're seeing if sys", "tokens": [51408, 365, 13985, 13, 400, 550, 294, 264, 1150, 472, 11, 321, 434, 8568, 498, 309, 311, 6915, 293, 321, 434, 2577, 498, 262, 749, 51708], "temperature": 0.0, "avg_logprob": -0.16079085480933095, "compression_ratio": 1.6452991452991452, "no_speech_prob": 0.0028006923384964466}, {"id": 215, "seek": 141704, "start": 1417.04, "end": 1424.0, "text": " equals this new string we've created, again, Polish. And then we're checking if sys equals", "tokens": [50364, 6915, 341, 777, 6798, 321, 600, 2942, 11, 797, 11, 18504, 13, 400, 550, 321, 434, 8568, 498, 262, 749, 6915, 50712], "temperature": 0.0, "avg_logprob": -0.191803165510589, "compression_ratio": 1.6147186147186148, "no_speech_prob": 0.007813365198671818}, {"id": 216, "seek": 141704, "start": 1425.04, "end": 1430.6399999999999, "text": " the other way around. We're checking for the symmetry. So you can see here in line number 53,", "tokens": [50764, 264, 661, 636, 926, 13, 492, 434, 8568, 337, 264, 25440, 13, 407, 291, 393, 536, 510, 294, 1622, 1230, 21860, 11, 51044], "temperature": 0.0, "avg_logprob": -0.191803165510589, "compression_ratio": 1.6147186147186148, "no_speech_prob": 0.007813365198671818}, {"id": 217, "seek": 141704, "start": 1430.6399999999999, "end": 1437.28, "text": " it's uppercase p. And in line number, oh, that's a mistake, actually. That should have been lower case.", "tokens": [51044, 309, 311, 11775, 2869, 651, 280, 13, 400, 294, 1622, 1230, 11, 1954, 11, 300, 311, 257, 6146, 11, 767, 13, 663, 820, 362, 668, 3126, 1389, 13, 51376], "temperature": 0.0, "avg_logprob": -0.191803165510589, "compression_ratio": 1.6147186147186148, "no_speech_prob": 0.007813365198671818}, {"id": 218, "seek": 141704, "start": 1438.56, "end": 1446.48, "text": " Now, we can truly demonstrate the point. So if it's lower case here, line number 37,", "tokens": [51440, 823, 11, 321, 393, 4908, 11698, 264, 935, 13, 407, 498, 309, 311, 3126, 1389, 510, 11, 1622, 1230, 13435, 11, 51836], "temperature": 0.0, "avg_logprob": -0.191803165510589, "compression_ratio": 1.6147186147186148, "no_speech_prob": 0.007813365198671818}, {"id": 219, "seek": 144648, "start": 1446.8, "end": 1454.08, "text": " it's still ignoring that and printing true in these two lines. So line number 54, 55,", "tokens": [50380, 309, 311, 920, 26258, 300, 293, 14699, 2074, 294, 613, 732, 3876, 13, 407, 1622, 1230, 20793, 11, 12330, 11, 50744], "temperature": 0.0, "avg_logprob": -0.15895790277525437, "compression_ratio": 1.5758928571428572, "no_speech_prob": 0.0004373133124317974}, {"id": 220, "seek": 144648, "start": 1454.08, "end": 1460.72, "text": " correlate to these second true statements. I hope that made sense. So rereading what", "tokens": [50744, 48742, 281, 613, 1150, 2074, 12363, 13, 286, 1454, 300, 1027, 2020, 13, 407, 46453, 8166, 437, 51076], "temperature": 0.0, "avg_logprob": -0.15895790277525437, "compression_ratio": 1.5758928571428572, "no_speech_prob": 0.0004373133124317974}, {"id": 221, "seek": 144648, "start": 1460.72, "end": 1466.8, "text": " Joshua Bloch wrote, to eliminate the problem, merely remove the ill-conceived attempt to", "tokens": [51076, 24005, 9865, 339, 4114, 11, 281, 13819, 264, 1154, 11, 17003, 4159, 264, 3171, 12, 1671, 384, 3194, 5217, 281, 51380], "temperature": 0.0, "avg_logprob": -0.15895790277525437, "compression_ratio": 1.5758928571428572, "no_speech_prob": 0.0004373133124317974}, {"id": 222, "seek": 144648, "start": 1466.8, "end": 1472.24, "text": " interoperate with string from the equals method. And now we move to the longest property from", "tokens": [51380, 728, 7192, 473, 365, 6798, 490, 264, 6915, 3170, 13, 400, 586, 321, 1286, 281, 264, 15438, 4707, 490, 51652], "temperature": 0.0, "avg_logprob": -0.15895790277525437, "compression_ratio": 1.5758928571428572, "no_speech_prob": 0.0004373133124317974}, {"id": 223, "seek": 147224, "start": 1472.24, "end": 1477.76, "text": " all the ones that Joshua Bloch has enumerated. And I had to take a smaller break just to", "tokens": [50364, 439, 264, 2306, 300, 24005, 9865, 339, 575, 465, 15583, 770, 13, 400, 286, 632, 281, 747, 257, 4356, 1821, 445, 281, 50640], "temperature": 0.0, "avg_logprob": -0.09125518798828125, "compression_ratio": 1.6222222222222222, "no_speech_prob": 0.007694849278777838}, {"id": 224, "seek": 147224, "start": 1477.76, "end": 1483.44, "text": " refresh myself because this property is four or five pages. So there's a bit to go through.", "tokens": [50640, 15134, 2059, 570, 341, 4707, 307, 1451, 420, 1732, 7183, 13, 407, 456, 311, 257, 857, 281, 352, 807, 13, 50924], "temperature": 0.0, "avg_logprob": -0.09125518798828125, "compression_ratio": 1.6222222222222222, "no_speech_prob": 0.007694849278777838}, {"id": 225, "seek": 147224, "start": 1484.8, "end": 1491.52, "text": " But let's get started. You know, the only way to get started is to get started. Wow, brilliant,", "tokens": [50992, 583, 718, 311, 483, 1409, 13, 509, 458, 11, 264, 787, 636, 281, 483, 1409, 307, 281, 483, 1409, 13, 3153, 11, 10248, 11, 51328], "temperature": 0.0, "avg_logprob": -0.09125518798828125, "compression_ratio": 1.6222222222222222, "no_speech_prob": 0.007694849278777838}, {"id": 226, "seek": 147224, "start": 1491.52, "end": 1498.72, "text": " brilliant. So what does this transitivity property states? Some of these words are a bit", "tokens": [51328, 10248, 13, 407, 437, 775, 341, 17976, 4253, 4707, 4368, 30, 2188, 295, 613, 2283, 366, 257, 857, 51688], "temperature": 0.0, "avg_logprob": -0.09125518798828125, "compression_ratio": 1.6222222222222222, "no_speech_prob": 0.007694849278777838}, {"id": 227, "seek": 149872, "start": 1498.72, "end": 1506.08, "text": " hard to pronounce. It's not going to lie. It states transitivity states, for any non-null reference,", "tokens": [50364, 1152, 281, 19567, 13, 467, 311, 406, 516, 281, 4544, 13, 467, 4368, 17976, 4253, 4368, 11, 337, 604, 2107, 12, 77, 858, 6408, 11, 50732], "temperature": 0.0, "avg_logprob": -0.13953734699048495, "compression_ratio": 1.558011049723757, "no_speech_prob": 0.0046089813113212585}, {"id": 228, "seek": 149872, "start": 1506.08, "end": 1515.92, "text": " values x, y and z, if x equals y returns true and y equals z returns true, then x equals z", "tokens": [50732, 4190, 2031, 11, 288, 293, 710, 11, 498, 2031, 6915, 288, 11247, 2074, 293, 288, 6915, 710, 11247, 2074, 11, 550, 2031, 6915, 710, 51224], "temperature": 0.0, "avg_logprob": -0.13953734699048495, "compression_ratio": 1.558011049723757, "no_speech_prob": 0.0046089813113212585}, {"id": 229, "seek": 149872, "start": 1517.2, "end": 1525.3600000000001, "text": " must also return true. Or simply it's that if we have three objects with the content being", "tokens": [51288, 1633, 611, 2736, 2074, 13, 1610, 2935, 309, 311, 300, 498, 321, 362, 1045, 6565, 365, 264, 2701, 885, 51696], "temperature": 0.0, "avg_logprob": -0.13953734699048495, "compression_ratio": 1.558011049723757, "no_speech_prob": 0.0046089813113212585}, {"id": 230, "seek": 152536, "start": 1525.36, "end": 1531.12, "text": " same, three string objects, let's say, they should all print true when compared to each other.", "tokens": [50364, 912, 11, 1045, 6798, 6565, 11, 718, 311, 584, 11, 436, 820, 439, 4482, 2074, 562, 5347, 281, 1184, 661, 13, 50652], "temperature": 0.0, "avg_logprob": -0.09336646397908528, "compression_ratio": 1.5879828326180256, "no_speech_prob": 0.0032218843698501587}, {"id": 231, "seek": 152536, "start": 1531.9199999999998, "end": 1538.3999999999999, "text": " Simple as that because we require the logical equality there. Now, before we get to the demos", "tokens": [50692, 21532, 382, 300, 570, 321, 3651, 264, 14978, 14949, 456, 13, 823, 11, 949, 321, 483, 281, 264, 33788, 51016], "temperature": 0.0, "avg_logprob": -0.09336646397908528, "compression_ratio": 1.5879828326180256, "no_speech_prob": 0.0032218843698501587}, {"id": 232, "seek": 152536, "start": 1538.3999999999999, "end": 1545.28, "text": " and we demonstrate how this can go wrong and how to fix it, and even in fact some inherent", "tokens": [51016, 293, 321, 11698, 577, 341, 393, 352, 2085, 293, 577, 281, 3191, 309, 11, 293, 754, 294, 1186, 512, 26387, 51360], "temperature": 0.0, "avg_logprob": -0.09336646397908528, "compression_ratio": 1.5879828326180256, "no_speech_prob": 0.0032218843698501587}, {"id": 233, "seek": 152536, "start": 1545.28, "end": 1551.6, "text": " flaws with Java and object-oriented programming, we got to get some theory out of the way.", "tokens": [51360, 27108, 365, 10745, 293, 2657, 12, 27414, 9410, 11, 321, 658, 281, 483, 512, 5261, 484, 295, 264, 636, 13, 51676], "temperature": 0.0, "avg_logprob": -0.09336646397908528, "compression_ratio": 1.5879828326180256, "no_speech_prob": 0.0032218843698501587}, {"id": 234, "seek": 155160, "start": 1552.56, "end": 1559.9199999999998, "text": " So should I read this out first? Let me think. Okay, I'll first read out a bit of like an", "tokens": [50412, 407, 820, 286, 1401, 341, 484, 700, 30, 961, 385, 519, 13, 1033, 11, 286, 603, 700, 1401, 484, 257, 857, 295, 411, 364, 50780], "temperature": 0.0, "avg_logprob": -0.13012647191318896, "compression_ratio": 1.6513409961685823, "no_speech_prob": 0.005640480667352676}, {"id": 235, "seek": 155160, "start": 1559.9199999999998, "end": 1564.32, "text": " introduction to this property from the book. Here's what Joshua Block states.", "tokens": [50780, 9339, 281, 341, 4707, 490, 264, 1446, 13, 1692, 311, 437, 24005, 17500, 4368, 13, 51000], "temperature": 0.0, "avg_logprob": -0.13012647191318896, "compression_ratio": 1.6513409961685823, "no_speech_prob": 0.005640480667352676}, {"id": 236, "seek": 155160, "start": 1564.32, "end": 1570.32, "text": " Transportation pertaining to transitivity. If one object is equal to a second and the", "tokens": [51000, 35095, 49582, 281, 17976, 4253, 13, 759, 472, 2657, 307, 2681, 281, 257, 1150, 293, 264, 51300], "temperature": 0.0, "avg_logprob": -0.13012647191318896, "compression_ratio": 1.6513409961685823, "no_speech_prob": 0.005640480667352676}, {"id": 237, "seek": 155160, "start": 1570.32, "end": 1575.52, "text": " second object is equal to a third, then the first object must be equal to the third as we", "tokens": [51300, 1150, 2657, 307, 2681, 281, 257, 2636, 11, 550, 264, 700, 2657, 1633, 312, 2681, 281, 264, 2636, 382, 321, 51560], "temperature": 0.0, "avg_logprob": -0.13012647191318896, "compression_ratio": 1.6513409961685823, "no_speech_prob": 0.005640480667352676}, {"id": 238, "seek": 155160, "start": 1575.52, "end": 1579.6799999999998, "text": " showed here. But as I said before we continue, let's get some theory out of the way. So", "tokens": [51560, 4712, 510, 13, 583, 382, 286, 848, 949, 321, 2354, 11, 718, 311, 483, 512, 5261, 484, 295, 264, 636, 13, 407, 51768], "temperature": 0.0, "avg_logprob": -0.13012647191318896, "compression_ratio": 1.6513409961685823, "no_speech_prob": 0.005640480667352676}, {"id": 239, "seek": 157968, "start": 1580.48, "end": 1585.2, "text": " something important to understand for this property is the Liskov substitution principle.", "tokens": [50404, 746, 1021, 281, 1223, 337, 341, 4707, 307, 264, 441, 7797, 5179, 35827, 8665, 13, 50640], "temperature": 0.0, "avg_logprob": -0.17783929384671726, "compression_ratio": 1.5593220338983051, "no_speech_prob": 0.00011773542792070657}, {"id": 240, "seek": 157968, "start": 1586.48, "end": 1593.28, "text": " The Liskov substitution principle is probably popularized by Robert C. Martin and his solid", "tokens": [50704, 440, 441, 7797, 5179, 35827, 8665, 307, 1391, 3743, 1602, 538, 7977, 383, 13, 9184, 293, 702, 5100, 51044], "temperature": 0.0, "avg_logprob": -0.17783929384671726, "compression_ratio": 1.5593220338983051, "no_speech_prob": 0.00011773542792070657}, {"id": 241, "seek": 157968, "start": 1593.28, "end": 1599.8400000000001, "text": " design principles. And of course, Barbara Liskov. Is that her name? I believe that's her name.", "tokens": [51044, 1715, 9156, 13, 400, 295, 1164, 11, 19214, 441, 7797, 5179, 13, 1119, 300, 720, 1315, 30, 286, 1697, 300, 311, 720, 1315, 13, 51372], "temperature": 0.0, "avg_logprob": -0.17783929384671726, "compression_ratio": 1.5593220338983051, "no_speech_prob": 0.00011773542792070657}, {"id": 242, "seek": 159984, "start": 1600.08, "end": 1610.08, "text": " Barbara Liskov. Yes, she is the scientist who invented this principle and made the contribution", "tokens": [50376, 19214, 441, 7797, 5179, 13, 1079, 11, 750, 307, 264, 12662, 567, 14479, 341, 8665, 293, 1027, 264, 13150, 50876], "temperature": 0.0, "avg_logprob": -0.11591571027582342, "compression_ratio": 1.483695652173913, "no_speech_prob": 0.0022864548955112696}, {"id": 243, "seek": 159984, "start": 1610.08, "end": 1615.1999999999998, "text": " into the field of computer science. Here's how Robert C. Martin summarizes the Liskov", "tokens": [50876, 666, 264, 2519, 295, 3820, 3497, 13, 1692, 311, 577, 7977, 383, 13, 9184, 14611, 5660, 264, 441, 7797, 5179, 51132], "temperature": 0.0, "avg_logprob": -0.11591571027582342, "compression_ratio": 1.483695652173913, "no_speech_prob": 0.0022864548955112696}, {"id": 244, "seek": 159984, "start": 1615.1999999999998, "end": 1620.56, "text": " substitution principle. Subtypes must be substitutable for their base types. And of course,", "tokens": [51132, 35827, 8665, 13, 8511, 874, 5190, 1633, 312, 26441, 32148, 337, 641, 3096, 3467, 13, 400, 295, 1164, 11, 51400], "temperature": 0.0, "avg_logprob": -0.11591571027582342, "compression_ratio": 1.483695652173913, "no_speech_prob": 0.0022864548955112696}, {"id": 245, "seek": 162056, "start": 1620.56, "end": 1630.32, "text": " I've got an example here that I use strategy PD to generate, to demo this principle simply. And then", "tokens": [50364, 286, 600, 658, 364, 1365, 510, 300, 286, 764, 5206, 10464, 281, 8460, 11, 281, 10723, 341, 8665, 2935, 13, 400, 550, 50852], "temperature": 0.0, "avg_logprob": -0.16464726336590654, "compression_ratio": 1.4236453201970443, "no_speech_prob": 0.0025098449550569057}, {"id": 246, "seek": 162056, "start": 1630.32, "end": 1636.1599999999999, "text": " a bit more formally, let's say a bit more mathematical definition, Barbara Liskov defines", "tokens": [50852, 257, 857, 544, 25983, 11, 718, 311, 584, 257, 857, 544, 18894, 7123, 11, 19214, 441, 7797, 5179, 23122, 51144], "temperature": 0.0, "avg_logprob": -0.16464726336590654, "compression_ratio": 1.4236453201970443, "no_speech_prob": 0.0025098449550569057}, {"id": 247, "seek": 162056, "start": 1636.1599999999999, "end": 1646.72, "text": " it like this, which she did in 1988. If for each object O1 of type S, there's an object O2 of type", "tokens": [51144, 309, 411, 341, 11, 597, 750, 630, 294, 27816, 13, 759, 337, 1184, 2657, 422, 16, 295, 2010, 318, 11, 456, 311, 364, 2657, 422, 17, 295, 2010, 51672], "temperature": 0.0, "avg_logprob": -0.16464726336590654, "compression_ratio": 1.4236453201970443, "no_speech_prob": 0.0025098449550569057}, {"id": 248, "seek": 164672, "start": 1646.72, "end": 1657.92, "text": " T such that for all programs P defined in terms of T, the behavior of P is such of P is unchanged", "tokens": [50364, 314, 1270, 300, 337, 439, 4268, 430, 7642, 294, 2115, 295, 314, 11, 264, 5223, 295, 430, 307, 1270, 295, 430, 307, 44553, 50924], "temperature": 0.0, "avg_logprob": -0.09496708573966191, "compression_ratio": 1.8048780487804879, "no_speech_prob": 0.016395773738622665}, {"id": 249, "seek": 164672, "start": 1657.92, "end": 1667.1200000000001, "text": " when O1 is substituted for O2, then S is a subtype of T. So another way of putting it is that if S", "tokens": [50924, 562, 422, 16, 307, 26441, 4866, 337, 422, 17, 11, 550, 318, 307, 257, 1422, 20467, 295, 314, 13, 407, 1071, 636, 295, 3372, 309, 307, 300, 498, 318, 51384], "temperature": 0.0, "avg_logprob": -0.09496708573966191, "compression_ratio": 1.8048780487804879, "no_speech_prob": 0.016395773738622665}, {"id": 250, "seek": 164672, "start": 1667.1200000000001, "end": 1673.2, "text": " is a subtype of T, then the behavior of O1 can be substituted for the behavior of O2, which are two", "tokens": [51384, 307, 257, 1422, 20467, 295, 314, 11, 550, 264, 5223, 295, 422, 16, 393, 312, 26441, 4866, 337, 264, 5223, 295, 422, 17, 11, 597, 366, 732, 51688], "temperature": 0.0, "avg_logprob": -0.09496708573966191, "compression_ratio": 1.8048780487804879, "no_speech_prob": 0.016395773738622665}, {"id": 251, "seek": 167320, "start": 1673.2, "end": 1680.0800000000002, "text": " objects. An example of that would be, again, generated by strategy PD. Thank you. Open AI", "tokens": [50364, 6565, 13, 1107, 1365, 295, 300, 576, 312, 11, 797, 11, 10833, 538, 5206, 10464, 13, 1044, 291, 13, 7238, 7318, 50708], "temperature": 0.0, "avg_logprob": -0.17313002268473307, "compression_ratio": 1.5106382978723405, "no_speech_prob": 0.027985194697976112}, {"id": 252, "seek": 167320, "start": 1680.72, "end": 1687.28, "text": " and strategy PD, not to anthropomorphize it, but nevertheless, thank you. We have a class animal", "tokens": [50740, 293, 5206, 10464, 11, 406, 281, 22727, 32702, 1125, 309, 11, 457, 26924, 11, 1309, 291, 13, 492, 362, 257, 1508, 5496, 51068], "temperature": 0.0, "avg_logprob": -0.17313002268473307, "compression_ratio": 1.5106382978723405, "no_speech_prob": 0.027985194697976112}, {"id": 253, "seek": 167320, "start": 1687.28, "end": 1693.8400000000001, "text": " with a public void move method, and then we have a subclass. We subclass the animal class by dog,", "tokens": [51068, 365, 257, 1908, 22009, 1286, 3170, 11, 293, 550, 321, 362, 257, 1422, 11665, 13, 492, 1422, 11665, 264, 5496, 1508, 538, 3000, 11, 51396], "temperature": 0.0, "avg_logprob": -0.17313002268473307, "compression_ratio": 1.5106382978723405, "no_speech_prob": 0.027985194697976112}, {"id": 254, "seek": 169384, "start": 1693.84, "end": 1705.84, "text": " dog extends animal. And then we define a method that makes the animal move. So the subclass has", "tokens": [50364, 3000, 26448, 5496, 13, 400, 550, 321, 6964, 257, 3170, 300, 1669, 264, 5496, 1286, 13, 407, 264, 1422, 11665, 575, 50964], "temperature": 0.0, "avg_logprob": -0.1538697022658128, "compression_ratio": 1.8037974683544304, "no_speech_prob": 0.048122961074113846}, {"id": 255, "seek": 169384, "start": 1705.84, "end": 1713.6799999999998, "text": " a method called make animal move, which takes a object of type animal of the, that's not the sub,", "tokens": [50964, 257, 3170, 1219, 652, 5496, 1286, 11, 597, 2516, 257, 2657, 295, 2010, 5496, 295, 264, 11, 300, 311, 406, 264, 1422, 11, 51356], "temperature": 0.0, "avg_logprob": -0.1538697022658128, "compression_ratio": 1.8037974683544304, "no_speech_prob": 0.048122961074113846}, {"id": 256, "seek": 169384, "start": 1713.6799999999998, "end": 1719.9199999999998, "text": " that's a subtype, not the, sorry, that's the supertype. And then this method, in fact, this", "tokens": [51356, 300, 311, 257, 1422, 20467, 11, 406, 264, 11, 2597, 11, 300, 311, 264, 1687, 20467, 13, 400, 550, 341, 3170, 11, 294, 1186, 11, 341, 51668], "temperature": 0.0, "avg_logprob": -0.1538697022658128, "compression_ratio": 1.8037974683544304, "no_speech_prob": 0.048122961074113846}, {"id": 257, "seek": 171992, "start": 1719.92, "end": 1725.6000000000001, "text": " method should be inside the, that was, I made it, it's not my fault, it's strategy PD's fault.", "tokens": [50364, 3170, 820, 312, 1854, 264, 11, 300, 390, 11, 286, 1027, 309, 11, 309, 311, 406, 452, 7441, 11, 309, 311, 5206, 10464, 311, 7441, 13, 50648], "temperature": 0.0, "avg_logprob": -0.14205173393348594, "compression_ratio": 1.5561497326203209, "no_speech_prob": 0.005554055329412222}, {"id": 258, "seek": 171992, "start": 1728.8000000000002, "end": 1738.16, "text": " If we put it in there, so it probably exists inside the dog class, and we create a new dog object,", "tokens": [50808, 759, 321, 829, 309, 294, 456, 11, 370, 309, 1391, 8198, 1854, 264, 3000, 1508, 11, 293, 321, 1884, 257, 777, 3000, 2657, 11, 51276], "temperature": 0.0, "avg_logprob": -0.14205173393348594, "compression_ratio": 1.5561497326203209, "no_speech_prob": 0.005554055329412222}, {"id": 259, "seek": 171992, "start": 1738.16, "end": 1748.64, "text": " and then this method make animal move can take in an animal typed object too, because it respects", "tokens": [51276, 293, 550, 341, 3170, 652, 5496, 1286, 393, 747, 294, 364, 5496, 33941, 2657, 886, 11, 570, 309, 24126, 51800], "temperature": 0.0, "avg_logprob": -0.14205173393348594, "compression_ratio": 1.5561497326203209, "no_speech_prob": 0.005554055329412222}, {"id": 260, "seek": 174864, "start": 1748.64, "end": 1755.92, "text": " the list called substitution principle or it owed to, because dog is a subtype of the supertype", "tokens": [50364, 264, 1329, 1219, 35827, 8665, 420, 309, 41262, 281, 11, 570, 3000, 307, 257, 1422, 20467, 295, 264, 1687, 20467, 50728], "temperature": 0.0, "avg_logprob": -0.10182497349191219, "compression_ratio": 1.532520325203252, "no_speech_prob": 0.005059411749243736}, {"id": 261, "seek": 174864, "start": 1755.92, "end": 1761.2, "text": " animal. It's quite straightforward, actually. And I think the best way to think about it is how", "tokens": [50728, 5496, 13, 467, 311, 1596, 15325, 11, 767, 13, 400, 286, 519, 264, 1151, 636, 281, 519, 466, 309, 307, 577, 50992], "temperature": 0.0, "avg_logprob": -0.10182497349191219, "compression_ratio": 1.532520325203252, "no_speech_prob": 0.005059411749243736}, {"id": 262, "seek": 174864, "start": 1761.2, "end": 1767.2, "text": " Robert C. Martin put said subtypes must be substitutable for their base types. So now let's", "tokens": [50992, 7977, 383, 13, 9184, 829, 848, 1422, 874, 5190, 1633, 312, 26441, 32148, 337, 641, 3096, 3467, 13, 407, 586, 718, 311, 51292], "temperature": 0.0, "avg_logprob": -0.10182497349191219, "compression_ratio": 1.532520325203252, "no_speech_prob": 0.005059411749243736}, {"id": 263, "seek": 174864, "start": 1767.2, "end": 1772.96, "text": " get to the demo that Joshua Block has used in the book. There are many classes to go through,", "tokens": [51292, 483, 281, 264, 10723, 300, 24005, 17500, 575, 1143, 294, 264, 1446, 13, 821, 366, 867, 5359, 281, 352, 807, 11, 51580], "temperature": 0.0, "avg_logprob": -0.10182497349191219, "compression_ratio": 1.532520325203252, "no_speech_prob": 0.005059411749243736}, {"id": 264, "seek": 177296, "start": 1773.76, "end": 1780.56, "text": " but let's start off with the point class. So here's what Joshua Block states. Consider the case", "tokens": [50404, 457, 718, 311, 722, 766, 365, 264, 935, 1508, 13, 407, 510, 311, 437, 24005, 17500, 4368, 13, 17416, 264, 1389, 50744], "temperature": 0.0, "avg_logprob": -0.07775510254726616, "compression_ratio": 1.6741071428571428, "no_speech_prob": 0.005553235299885273}, {"id": 265, "seek": 177296, "start": 1780.56, "end": 1787.3600000000001, "text": " of a subclass that adds a new value component to its superclass. In other words, the subclass", "tokens": [50744, 295, 257, 1422, 11665, 300, 10860, 257, 777, 2158, 6542, 281, 1080, 1687, 11665, 13, 682, 661, 2283, 11, 264, 1422, 11665, 51084], "temperature": 0.0, "avg_logprob": -0.07775510254726616, "compression_ratio": 1.6741071428571428, "no_speech_prob": 0.005553235299885273}, {"id": 266, "seek": 177296, "start": 1787.3600000000001, "end": 1793.6000000000001, "text": " adds a piece of information that affects the equals comparison. What we have here is this", "tokens": [51084, 10860, 257, 2522, 295, 1589, 300, 11807, 264, 6915, 9660, 13, 708, 321, 362, 510, 307, 341, 51396], "temperature": 0.0, "avg_logprob": -0.07775510254726616, "compression_ratio": 1.6741071428571428, "no_speech_prob": 0.005553235299885273}, {"id": 267, "seek": 177296, "start": 1794.56, "end": 1798.88, "text": " public class. This class is going to be the superclass that we're going to use. It's a concrete", "tokens": [51444, 1908, 1508, 13, 639, 1508, 307, 516, 281, 312, 264, 1687, 11665, 300, 321, 434, 516, 281, 764, 13, 467, 311, 257, 9859, 51660], "temperature": 0.0, "avg_logprob": -0.07775510254726616, "compression_ratio": 1.6741071428571428, "no_speech_prob": 0.005553235299885273}, {"id": 268, "seek": 179888, "start": 1798.88, "end": 1806.0, "text": " class. Keep that in mind, because the idea or the juxtaposition of a concrete class with a", "tokens": [50364, 1508, 13, 5527, 300, 294, 1575, 11, 570, 264, 1558, 420, 264, 3649, 734, 569, 5830, 295, 257, 9859, 1508, 365, 257, 50720], "temperature": 0.0, "avg_logprob": -0.11237956107930934, "compression_ratio": 1.6324786324786325, "no_speech_prob": 0.010011070407927036}, {"id": 269, "seek": 179888, "start": 1806.0, "end": 1810.64, "text": " abstract class, that's something we're going to catch on later on in this part. So we have the", "tokens": [50720, 12649, 1508, 11, 300, 311, 746, 321, 434, 516, 281, 3745, 322, 1780, 322, 294, 341, 644, 13, 407, 321, 362, 264, 50952], "temperature": 0.0, "avg_logprob": -0.11237956107930934, "compression_ratio": 1.6324786324786325, "no_speech_prob": 0.010011070407927036}, {"id": 270, "seek": 179888, "start": 1810.64, "end": 1817.7600000000002, "text": " concrete class point, which is simply an immutable two dimensional integer point class. We've got x", "tokens": [50952, 9859, 1508, 935, 11, 597, 307, 2935, 364, 3397, 32148, 732, 18795, 24922, 935, 1508, 13, 492, 600, 658, 2031, 51308], "temperature": 0.0, "avg_logprob": -0.11237956107930934, "compression_ratio": 1.6324786324786325, "no_speech_prob": 0.010011070407927036}, {"id": 271, "seek": 179888, "start": 1817.7600000000002, "end": 1823.2, "text": " and y privately defined, we have constructor, and then you have an equals method, which just the", "tokens": [51308, 293, 288, 31919, 7642, 11, 321, 362, 47479, 11, 293, 550, 291, 362, 364, 6915, 3170, 11, 597, 445, 264, 51580], "temperature": 0.0, "avg_logprob": -0.11237956107930934, "compression_ratio": 1.6324786324786325, "no_speech_prob": 0.010011070407927036}, {"id": 272, "seek": 182320, "start": 1823.2, "end": 1828.4, "text": " equality. Similar to what we discussed in the previous example with symmetry, checks if it's", "tokens": [50364, 14949, 13, 10905, 281, 437, 321, 7152, 294, 264, 3894, 1365, 365, 25440, 11, 13834, 498, 309, 311, 50624], "temperature": 0.0, "avg_logprob": -0.10230736110521399, "compression_ratio": 1.6872246696035242, "no_speech_prob": 0.0037651080638170242}, {"id": 273, "seek": 182320, "start": 1828.4, "end": 1834.0800000000002, "text": " an instance, and then returns true if there's equality. Now let's suppose that we want to", "tokens": [50624, 364, 5197, 11, 293, 550, 11247, 2074, 498, 456, 311, 14949, 13, 823, 718, 311, 7297, 300, 321, 528, 281, 50908], "temperature": 0.0, "avg_logprob": -0.10230736110521399, "compression_ratio": 1.6872246696035242, "no_speech_prob": 0.0037651080638170242}, {"id": 274, "seek": 182320, "start": 1834.0800000000002, "end": 1839.68, "text": " enhance the ability of the point class. Therefore, we subclass it and we have this color point class", "tokens": [50908, 11985, 264, 3485, 295, 264, 935, 1508, 13, 7504, 11, 321, 1422, 11665, 309, 293, 321, 362, 341, 2017, 935, 1508, 51188], "temperature": 0.0, "avg_logprob": -0.10230736110521399, "compression_ratio": 1.6872246696035242, "no_speech_prob": 0.0037651080638170242}, {"id": 275, "seek": 182320, "start": 1839.68, "end": 1845.8400000000001, "text": " that extends the point class, and it attempts to add a value component to point. In this case, it's", "tokens": [51188, 300, 26448, 264, 935, 1508, 11, 293, 309, 15257, 281, 909, 257, 2158, 6542, 281, 935, 13, 682, 341, 1389, 11, 309, 311, 51496], "temperature": 0.0, "avg_logprob": -0.10230736110521399, "compression_ratio": 1.6872246696035242, "no_speech_prob": 0.0037651080638170242}, {"id": 276, "seek": 184584, "start": 1846.8, "end": 1852.8799999999999, "text": " the value component of color. We want the points to also have color. Now what would", "tokens": [50412, 264, 2158, 6542, 295, 2017, 13, 492, 528, 264, 2793, 281, 611, 362, 2017, 13, 823, 437, 576, 50716], "temperature": 0.0, "avg_logprob": -0.10005227812043913, "compression_ratio": 1.7031963470319635, "no_speech_prob": 0.002714703558012843}, {"id": 277, "seek": 184584, "start": 1853.6799999999998, "end": 1859.6, "text": " this class look like? Or more importantly, what would the equals method look like for the color", "tokens": [50756, 341, 1508, 574, 411, 30, 1610, 544, 8906, 11, 437, 576, 264, 6915, 3170, 574, 411, 337, 264, 2017, 51052], "temperature": 0.0, "avg_logprob": -0.10005227812043913, "compression_ratio": 1.7031963470319635, "no_speech_prob": 0.002714703558012843}, {"id": 278, "seek": 184584, "start": 1859.6, "end": 1866.6399999999999, "text": " point class? That is a subclass of point. In this case, we have a normal constructor. We have line", "tokens": [51052, 935, 1508, 30, 663, 307, 257, 1422, 11665, 295, 935, 13, 682, 341, 1389, 11, 321, 362, 257, 2710, 47479, 13, 492, 362, 1622, 51404], "temperature": 0.0, "avg_logprob": -0.10005227812043913, "compression_ratio": 1.7031963470319635, "no_speech_prob": 0.002714703558012843}, {"id": 279, "seek": 184584, "start": 1866.6399999999999, "end": 1871.9199999999998, "text": " number 14 that invokes the constructor in the superclass. That's what this super keyword does,", "tokens": [51404, 1230, 3499, 300, 1048, 8606, 264, 47479, 294, 264, 1687, 11665, 13, 663, 311, 437, 341, 1687, 20428, 775, 11, 51668], "temperature": 0.0, "avg_logprob": -0.10005227812043913, "compression_ratio": 1.7031963470319635, "no_speech_prob": 0.002714703558012843}, {"id": 280, "seek": 187192, "start": 1871.92, "end": 1877.52, "text": " and we can do that for x and y, those coordinates. But here, since we're introducing this value", "tokens": [50364, 293, 321, 393, 360, 300, 337, 2031, 293, 288, 11, 729, 21056, 13, 583, 510, 11, 1670, 321, 434, 15424, 341, 2158, 50644], "temperature": 0.0, "avg_logprob": -0.0900800001053583, "compression_ratio": 1.6872037914691944, "no_speech_prob": 0.0010986396810039878}, {"id": 281, "seek": 187192, "start": 1877.52, "end": 1882.3200000000002, "text": " component, we want to initialize the color component to when constructing the object.", "tokens": [50644, 6542, 11, 321, 528, 281, 5883, 1125, 264, 2017, 6542, 281, 562, 39969, 264, 2657, 13, 50884], "temperature": 0.0, "avg_logprob": -0.0900800001053583, "compression_ratio": 1.6872037914691944, "no_speech_prob": 0.0010986396810039878}, {"id": 282, "seek": 187192, "start": 1884.0800000000002, "end": 1891.52, "text": " But then we come to the equals method that clearly violates the symmetry of the", "tokens": [50972, 583, 550, 321, 808, 281, 264, 6915, 3170, 300, 4448, 3448, 1024, 264, 25440, 295, 264, 51344], "temperature": 0.0, "avg_logprob": -0.0900800001053583, "compression_ratio": 1.6872037914691944, "no_speech_prob": 0.0010986396810039878}, {"id": 283, "seek": 187192, "start": 1891.52, "end": 1895.6000000000001, "text": " symmetry principle or the symmetry properties. Well, for starters, of course, we can't use the", "tokens": [51344, 25440, 8665, 420, 264, 25440, 7221, 13, 1042, 11, 337, 35131, 11, 295, 1164, 11, 321, 393, 380, 764, 264, 51548], "temperature": 0.0, "avg_logprob": -0.0900800001053583, "compression_ratio": 1.6872037914691944, "no_speech_prob": 0.0010986396810039878}, {"id": 284, "seek": 189560, "start": 1896.56, "end": 1901.6799999999998, "text": " equals method from the superclass because the superclass did not even have a color field.", "tokens": [50412, 6915, 3170, 490, 264, 1687, 11665, 570, 264, 1687, 11665, 630, 406, 754, 362, 257, 2017, 2519, 13, 50668], "temperature": 0.0, "avg_logprob": -0.10089268457321894, "compression_ratio": 1.9350649350649352, "no_speech_prob": 0.01132823247462511}, {"id": 285, "seek": 189560, "start": 1902.24, "end": 1907.76, "text": " Therefore, it would break the idea of logical equality if we just inherit that method. Therefore,", "tokens": [50696, 7504, 11, 309, 576, 1821, 264, 1558, 295, 14978, 14949, 498, 321, 445, 21389, 300, 3170, 13, 7504, 11, 50972], "temperature": 0.0, "avg_logprob": -0.10089268457321894, "compression_ratio": 1.9350649350649352, "no_speech_prob": 0.01132823247462511}, {"id": 286, "seek": 189560, "start": 1907.76, "end": 1913.6, "text": " we need to override the equals method in the subclass color point. But in this equals method,", "tokens": [50972, 321, 643, 281, 42321, 264, 6915, 3170, 294, 264, 1422, 11665, 2017, 935, 13, 583, 294, 341, 6915, 3170, 11, 51264], "temperature": 0.0, "avg_logprob": -0.10089268457321894, "compression_ratio": 1.9350649350649352, "no_speech_prob": 0.01132823247462511}, {"id": 287, "seek": 189560, "start": 1913.6, "end": 1918.24, "text": " it violates symmetry because, yes, we're invoking the equals method in the superclass,", "tokens": [51264, 309, 3448, 1024, 25440, 570, 11, 2086, 11, 321, 434, 1048, 5953, 264, 6915, 3170, 294, 264, 1687, 11665, 11, 51496], "temperature": 0.0, "avg_logprob": -0.10089268457321894, "compression_ratio": 1.9350649350649352, "no_speech_prob": 0.01132823247462511}, {"id": 288, "seek": 189560, "start": 1918.24, "end": 1923.6, "text": " and then we're even doing a check for the color point equality here by casting", "tokens": [51496, 293, 550, 321, 434, 754, 884, 257, 1520, 337, 264, 2017, 935, 14949, 510, 538, 17301, 51764], "temperature": 0.0, "avg_logprob": -0.10089268457321894, "compression_ratio": 1.9350649350649352, "no_speech_prob": 0.01132823247462511}, {"id": 289, "seek": 192360, "start": 1924.32, "end": 1928.56, "text": " that object the color point type. Because if it is an instance, in that case,", "tokens": [50400, 300, 2657, 264, 2017, 935, 2010, 13, 1436, 498, 309, 307, 364, 5197, 11, 294, 300, 1389, 11, 50612], "temperature": 0.0, "avg_logprob": -0.1298876912970292, "compression_ratio": 1.6966824644549763, "no_speech_prob": 0.024788914248347282}, {"id": 290, "seek": 192360, "start": 1930.08, "end": 1937.52, "text": " oh, yes, because if it's not an instance, it'll return false. But it's a one-way comparison. So", "tokens": [50688, 1954, 11, 2086, 11, 570, 498, 309, 311, 406, 364, 5197, 11, 309, 603, 2736, 7908, 13, 583, 309, 311, 257, 472, 12, 676, 9660, 13, 407, 51060], "temperature": 0.0, "avg_logprob": -0.1298876912970292, "compression_ratio": 1.6966824644549763, "no_speech_prob": 0.024788914248347282}, {"id": 291, "seek": 192360, "start": 1937.52, "end": 1944.7199999999998, "text": " if you look at the implementation or a client using it, and if I run this, you'll see the", "tokens": [51060, 498, 291, 574, 412, 264, 11420, 420, 257, 6423, 1228, 309, 11, 293, 498, 286, 1190, 341, 11, 291, 603, 536, 264, 51420], "temperature": 0.0, "avg_logprob": -0.1298876912970292, "compression_ratio": 1.6966824644549763, "no_speech_prob": 0.024788914248347282}, {"id": 292, "seek": 192360, "start": 1944.7199999999998, "end": 1949.9199999999998, "text": " first comparison will return true because that's fine. We're comparing point and we're passing", "tokens": [51420, 700, 9660, 486, 2736, 2074, 570, 300, 311, 2489, 13, 492, 434, 15763, 935, 293, 321, 434, 8437, 51680], "temperature": 0.0, "avg_logprob": -0.1298876912970292, "compression_ratio": 1.6966824644549763, "no_speech_prob": 0.024788914248347282}, {"id": 293, "seek": 194992, "start": 1949.92, "end": 1955.04, "text": " the color point object, that's okay. But the second one will return false because in this case,", "tokens": [50364, 264, 2017, 935, 2657, 11, 300, 311, 1392, 13, 583, 264, 1150, 472, 486, 2736, 7908, 570, 294, 341, 1389, 11, 50620], "temperature": 0.0, "avg_logprob": -0.1136084238688151, "compression_ratio": 1.6211453744493391, "no_speech_prob": 0.001754309982061386}, {"id": 294, "seek": 194992, "start": 1955.04, "end": 1960.64, "text": " we are typing or we are passing the supertype object. So it's a clear violation of symmetry.", "tokens": [50620, 321, 366, 18444, 420, 321, 366, 8437, 264, 1687, 20467, 2657, 13, 407, 309, 311, 257, 1850, 22840, 295, 25440, 13, 50900], "temperature": 0.0, "avg_logprob": -0.1136084238688151, "compression_ratio": 1.6211453744493391, "no_speech_prob": 0.001754309982061386}, {"id": 295, "seek": 194992, "start": 1961.28, "end": 1969.04, "text": " And that's why Joshua Bloch states, the problem with this method and what he means by this method", "tokens": [50932, 400, 300, 311, 983, 24005, 9865, 339, 4368, 11, 264, 1154, 365, 341, 3170, 293, 437, 415, 1355, 538, 341, 3170, 51320], "temperature": 0.0, "avg_logprob": -0.1136084238688151, "compression_ratio": 1.6211453744493391, "no_speech_prob": 0.001754309982061386}, {"id": 296, "seek": 194992, "start": 1969.04, "end": 1975.8400000000001, "text": " is this implementation of the overrides method we have here is that you might get", "tokens": [51320, 307, 341, 11420, 295, 264, 670, 81, 1875, 3170, 321, 362, 510, 307, 300, 291, 1062, 483, 51660], "temperature": 0.0, "avg_logprob": -0.1136084238688151, "compression_ratio": 1.6211453744493391, "no_speech_prob": 0.001754309982061386}, {"id": 297, "seek": 197584, "start": 1975.84, "end": 1980.48, "text": " different results when comparing a point to a color point and vice versa.", "tokens": [50364, 819, 3542, 562, 15763, 257, 935, 281, 257, 2017, 935, 293, 11964, 25650, 13, 50596], "temperature": 0.0, "avg_logprob": -0.08557030995686848, "compression_ratio": 1.8042328042328042, "no_speech_prob": 0.0008968725451268256}, {"id": 298, "seek": 197584, "start": 1981.28, "end": 1986.48, "text": " The former comparison ignores color while the latter comparison always returns false", "tokens": [50636, 440, 5819, 9660, 5335, 2706, 2017, 1339, 264, 18481, 9660, 1009, 11247, 7908, 50896], "temperature": 0.0, "avg_logprob": -0.08557030995686848, "compression_ratio": 1.8042328042328042, "no_speech_prob": 0.0008968725451268256}, {"id": 299, "seek": 197584, "start": 1987.1999999999998, "end": 1993.12, "text": " because the type of the argument is incorrect. So what he means by the former comparison ignores", "tokens": [50932, 570, 264, 2010, 295, 264, 6770, 307, 18424, 13, 407, 437, 415, 1355, 538, 264, 5819, 9660, 5335, 2706, 51228], "temperature": 0.0, "avg_logprob": -0.08557030995686848, "compression_ratio": 1.8042328042328042, "no_speech_prob": 0.0008968725451268256}, {"id": 300, "seek": 197584, "start": 1993.12, "end": 2001.4399999999998, "text": " color is that in this ampersand, the end statement here, that's the former comparison", "tokens": [51228, 2017, 307, 300, 294, 341, 18648, 433, 474, 11, 264, 917, 5629, 510, 11, 300, 311, 264, 5819, 9660, 51644], "temperature": 0.0, "avg_logprob": -0.08557030995686848, "compression_ratio": 1.8042328042328042, "no_speech_prob": 0.0008968725451268256}, {"id": 301, "seek": 200144, "start": 2001.44, "end": 2009.44, "text": " where it's simply invoking the equals method in the superclass and it's doing a basic equality test.", "tokens": [50364, 689, 309, 311, 2935, 1048, 5953, 264, 6915, 3170, 294, 264, 1687, 11665, 293, 309, 311, 884, 257, 3875, 14949, 1500, 13, 50764], "temperature": 0.0, "avg_logprob": -0.08792742904351682, "compression_ratio": 1.6695278969957081, "no_speech_prob": 0.005139090120792389}, {"id": 302, "seek": 200144, "start": 2009.44, "end": 2016.16, "text": " But in that equality test, we are ignoring color completely. So it'll return true if it is an object", "tokens": [50764, 583, 294, 300, 14949, 1500, 11, 321, 366, 26258, 2017, 2584, 13, 407, 309, 603, 2736, 2074, 498, 309, 307, 364, 2657, 51100], "temperature": 0.0, "avg_logprob": -0.08792742904351682, "compression_ratio": 1.6695278969957081, "no_speech_prob": 0.005139090120792389}, {"id": 303, "seek": 200144, "start": 2016.16, "end": 2021.6000000000001, "text": " of proper type. And that, again, doesn't give us what we want. It breaks logical equality.", "tokens": [51100, 295, 2296, 2010, 13, 400, 300, 11, 797, 11, 1177, 380, 976, 505, 437, 321, 528, 13, 467, 9857, 14978, 14949, 13, 51372], "temperature": 0.0, "avg_logprob": -0.08792742904351682, "compression_ratio": 1.6695278969957081, "no_speech_prob": 0.005139090120792389}, {"id": 304, "seek": 200144, "start": 2021.6000000000001, "end": 2026.72, "text": " And in the second one, the problem is it'll never even get to the second one because we check if", "tokens": [51372, 400, 294, 264, 1150, 472, 11, 264, 1154, 307, 309, 603, 1128, 754, 483, 281, 264, 1150, 472, 570, 321, 1520, 498, 51628], "temperature": 0.0, "avg_logprob": -0.08792742904351682, "compression_ratio": 1.6695278969957081, "no_speech_prob": 0.005139090120792389}, {"id": 305, "seek": 202672, "start": 2026.72, "end": 2031.68, "text": " this object is an instance of color point. And if it's not, it'll always return false.", "tokens": [50364, 341, 2657, 307, 364, 5197, 295, 2017, 935, 13, 400, 498, 309, 311, 406, 11, 309, 603, 1009, 2736, 7908, 13, 50612], "temperature": 0.0, "avg_logprob": -0.10830331765688382, "compression_ratio": 1.826271186440678, "no_speech_prob": 0.004398826509714127}, {"id": 306, "seek": 202672, "start": 2031.68, "end": 2039.28, "text": " Therefore, whenever we pass anything that's not of type color point, it'll return false.", "tokens": [50612, 7504, 11, 5699, 321, 1320, 1340, 300, 311, 406, 295, 2010, 2017, 935, 11, 309, 603, 2736, 7908, 13, 50992], "temperature": 0.0, "avg_logprob": -0.10830331765688382, "compression_ratio": 1.826271186440678, "no_speech_prob": 0.004398826509714127}, {"id": 307, "seek": 202672, "start": 2040.0, "end": 2044.4, "text": " And that also violates not only symmetry, but even the less substitution principle.", "tokens": [51028, 400, 300, 611, 3448, 1024, 406, 787, 25440, 11, 457, 754, 264, 1570, 35827, 8665, 13, 51248], "temperature": 0.0, "avg_logprob": -0.10830331765688382, "compression_ratio": 1.826271186440678, "no_speech_prob": 0.004398826509714127}, {"id": 308, "seek": 202672, "start": 2044.4, "end": 2047.52, "text": " So then we're trying to fix this. What we're trying to fix this is we're trying to", "tokens": [51248, 407, 550, 321, 434, 1382, 281, 3191, 341, 13, 708, 321, 434, 1382, 281, 3191, 341, 307, 321, 434, 1382, 281, 51404], "temperature": 0.0, "avg_logprob": -0.10830331765688382, "compression_ratio": 1.826271186440678, "no_speech_prob": 0.004398826509714127}, {"id": 309, "seek": 202672, "start": 2047.52, "end": 2053.2, "text": " resolve this issue with violating symmetry. And that fix also unfortunately doesn't work", "tokens": [51404, 14151, 341, 2734, 365, 42201, 25440, 13, 400, 300, 3191, 611, 7015, 1177, 380, 589, 51688], "temperature": 0.0, "avg_logprob": -0.10830331765688382, "compression_ratio": 1.826271186440678, "no_speech_prob": 0.004398826509714127}, {"id": 310, "seek": 205320, "start": 2053.2, "end": 2060.56, "text": " because it violates the transitivity property and we shall see what that fix looks like.", "tokens": [50364, 570, 309, 3448, 1024, 264, 17976, 4253, 4707, 293, 321, 4393, 536, 437, 300, 3191, 1542, 411, 13, 50732], "temperature": 0.0, "avg_logprob": -0.10914798293794904, "compression_ratio": 1.714828897338403, "no_speech_prob": 0.0006461760494858027}, {"id": 311, "seek": 205320, "start": 2060.56, "end": 2065.8399999999997, "text": " So by trying to fix the issue with symmetry, we unfortunately violate transitivity.", "tokens": [50732, 407, 538, 1382, 281, 3191, 264, 2734, 365, 25440, 11, 321, 7015, 37478, 17976, 4253, 13, 50996], "temperature": 0.0, "avg_logprob": -0.10914798293794904, "compression_ratio": 1.714828897338403, "no_speech_prob": 0.0006461760494858027}, {"id": 312, "seek": 205320, "start": 2065.8399999999997, "end": 2072.3999999999996, "text": " In this case, in this new equals method that we overrode, we in fact are considering objects that", "tokens": [50996, 682, 341, 1389, 11, 294, 341, 777, 6915, 3170, 300, 321, 670, 340, 1479, 11, 321, 294, 1186, 366, 8079, 6565, 300, 51324], "temperature": 0.0, "avg_logprob": -0.10914798293794904, "compression_ratio": 1.714828897338403, "no_speech_prob": 0.0006461760494858027}, {"id": 313, "seek": 205320, "start": 2072.3999999999996, "end": 2076.96, "text": " are of a different type to color point. We're checking if initially if it's a normal point,", "tokens": [51324, 366, 295, 257, 819, 2010, 281, 2017, 935, 13, 492, 434, 8568, 498, 9105, 498, 309, 311, 257, 2710, 935, 11, 51552], "temperature": 0.0, "avg_logprob": -0.10914798293794904, "compression_ratio": 1.714828897338403, "no_speech_prob": 0.0006461760494858027}, {"id": 314, "seek": 205320, "start": 2076.96, "end": 2082.7999999999997, "text": " if it's a normal point, we're doing a color blind comparison. Great. And if it's a color", "tokens": [51552, 498, 309, 311, 257, 2710, 935, 11, 321, 434, 884, 257, 2017, 6865, 9660, 13, 3769, 13, 400, 498, 309, 311, 257, 2017, 51844], "temperature": 0.0, "avg_logprob": -0.10914798293794904, "compression_ratio": 1.714828897338403, "no_speech_prob": 0.0006461760494858027}, {"id": 315, "seek": 208280, "start": 2082.8, "end": 2087.1200000000003, "text": " point, then like the previous one, we consider color and then do a comparison. And", "tokens": [50364, 935, 11, 550, 411, 264, 3894, 472, 11, 321, 1949, 2017, 293, 550, 360, 257, 9660, 13, 400, 50580], "temperature": 0.0, "avg_logprob": -0.08388190549962661, "compression_ratio": 1.579185520361991, "no_speech_prob": 0.002631183946505189}, {"id": 316, "seek": 208280, "start": 2087.76, "end": 2093.28, "text": " absolutely if it's not an instance of either point or color point, it'll just return false.", "tokens": [50612, 3122, 498, 309, 311, 406, 364, 5197, 295, 2139, 935, 420, 2017, 935, 11, 309, 603, 445, 2736, 7908, 13, 50888], "temperature": 0.0, "avg_logprob": -0.08388190549962661, "compression_ratio": 1.579185520361991, "no_speech_prob": 0.002631183946505189}, {"id": 317, "seek": 208280, "start": 2093.92, "end": 2100.0, "text": " So in this case, symmetry ticked. However, unfortunately, as we shall see from the", "tokens": [50920, 407, 294, 341, 1389, 11, 25440, 5204, 292, 13, 2908, 11, 7015, 11, 382, 321, 4393, 536, 490, 264, 51224], "temperature": 0.0, "avg_logprob": -0.08388190549962661, "compression_ratio": 1.579185520361991, "no_speech_prob": 0.002631183946505189}, {"id": 318, "seek": 208280, "start": 2100.0, "end": 2110.0800000000004, "text": " implementation, it does violate transitivity. So in this comparison, we have three objects.", "tokens": [51224, 11420, 11, 309, 775, 37478, 17976, 4253, 13, 407, 294, 341, 9660, 11, 321, 362, 1045, 6565, 13, 51728], "temperature": 0.0, "avg_logprob": -0.08388190549962661, "compression_ratio": 1.579185520361991, "no_speech_prob": 0.002631183946505189}, {"id": 319, "seek": 211008, "start": 2110.08, "end": 2117.52, "text": " We have two color point objects and a point object. So in the P1 equals P2 comparison,", "tokens": [50364, 492, 362, 732, 2017, 935, 6565, 293, 257, 935, 2657, 13, 407, 294, 264, 430, 16, 6915, 430, 17, 9660, 11, 50736], "temperature": 0.0, "avg_logprob": -0.08344293895520662, "compression_ratio": 1.7846153846153847, "no_speech_prob": 0.0041329399682581425}, {"id": 320, "seek": 211008, "start": 2117.52, "end": 2125.6, "text": " that's fine. It returns true. Also in the P2 equals P3 comparison, that also returns true.", "tokens": [50736, 300, 311, 2489, 13, 467, 11247, 2074, 13, 2743, 294, 264, 430, 17, 6915, 430, 18, 9660, 11, 300, 611, 11247, 2074, 13, 51140], "temperature": 0.0, "avg_logprob": -0.08344293895520662, "compression_ratio": 1.7846153846153847, "no_speech_prob": 0.0041329399682581425}, {"id": 321, "seek": 211008, "start": 2125.6, "end": 2132.24, "text": " However, then comes the transitivity issue in the P1 equals P3 comparison, it returns false.", "tokens": [51140, 2908, 11, 550, 1487, 264, 17976, 4253, 2734, 294, 264, 430, 16, 6915, 430, 18, 9660, 11, 309, 11247, 7908, 13, 51472], "temperature": 0.0, "avg_logprob": -0.08344293895520662, "compression_ratio": 1.7846153846153847, "no_speech_prob": 0.0041329399682581425}, {"id": 322, "seek": 211008, "start": 2134.3199999999997, "end": 2138.72, "text": " I totally got the wrong. I read that as if that's what was expected. In fact,", "tokens": [51576, 286, 3879, 658, 264, 2085, 13, 286, 1401, 300, 382, 498, 300, 311, 437, 390, 5176, 13, 682, 1186, 11, 51796], "temperature": 0.0, "avg_logprob": -0.08344293895520662, "compression_ratio": 1.7846153846153847, "no_speech_prob": 0.0041329399682581425}, {"id": 323, "seek": 213872, "start": 2138.72, "end": 2143.2, "text": " that was not what's expected because there's no logical equality there. We're trying to compare", "tokens": [50364, 300, 390, 406, 437, 311, 5176, 570, 456, 311, 572, 14978, 14949, 456, 13, 492, 434, 1382, 281, 6794, 50588], "temperature": 0.0, "avg_logprob": -0.10821632544199626, "compression_ratio": 1.8404669260700388, "no_speech_prob": 0.0027572314720600843}, {"id": 324, "seek": 213872, "start": 2144.3199999999997, "end": 2151.4399999999996, "text": " P1 with P2 and it's returning true. It should return false because obviously P1 has that added", "tokens": [50644, 430, 16, 365, 430, 17, 293, 309, 311, 12678, 2074, 13, 467, 820, 2736, 7908, 570, 2745, 430, 16, 575, 300, 3869, 51000], "temperature": 0.0, "avg_logprob": -0.10821632544199626, "compression_ratio": 1.8404669260700388, "no_speech_prob": 0.0027572314720600843}, {"id": 325, "seek": 213872, "start": 2151.4399999999996, "end": 2156.8799999999997, "text": " value component of color and P2 doesn't have that. So that's wrong. It shouldn't return true.", "tokens": [51000, 2158, 6542, 295, 2017, 293, 430, 17, 1177, 380, 362, 300, 13, 407, 300, 311, 2085, 13, 467, 4659, 380, 2736, 2074, 13, 51272], "temperature": 0.0, "avg_logprob": -0.10821632544199626, "compression_ratio": 1.8404669260700388, "no_speech_prob": 0.0027572314720600843}, {"id": 326, "seek": 213872, "start": 2156.8799999999997, "end": 2161.52, "text": " And it shouldn't in the second comparison, where we compare again, a point and a color point,", "tokens": [51272, 400, 309, 4659, 380, 294, 264, 1150, 9660, 11, 689, 321, 6794, 797, 11, 257, 935, 293, 257, 2017, 935, 11, 51504], "temperature": 0.0, "avg_logprob": -0.10821632544199626, "compression_ratio": 1.8404669260700388, "no_speech_prob": 0.0027572314720600843}, {"id": 327, "seek": 213872, "start": 2161.52, "end": 2167.3599999999997, "text": " it's returning true again, it shouldn't. And okay, the third one's fine because the third one,", "tokens": [51504, 309, 311, 12678, 2074, 797, 11, 309, 4659, 380, 13, 400, 1392, 11, 264, 2636, 472, 311, 2489, 570, 264, 2636, 472, 11, 51796], "temperature": 0.0, "avg_logprob": -0.10821632544199626, "compression_ratio": 1.8404669260700388, "no_speech_prob": 0.0027572314720600843}, {"id": 328, "seek": 216736, "start": 2168.08, "end": 2174.2400000000002, "text": " it's doing a proper comparison between P1 and P3, which are both type of color point.", "tokens": [50400, 309, 311, 884, 257, 2296, 9660, 1296, 430, 16, 293, 430, 18, 11, 597, 366, 1293, 2010, 295, 2017, 935, 13, 50708], "temperature": 0.0, "avg_logprob": -0.1174822828986428, "compression_ratio": 1.5246636771300448, "no_speech_prob": 0.002216556342318654}, {"id": 329, "seek": 216736, "start": 2174.8, "end": 2179.28, "text": " And it's returning false, which is expected because the color is different. That's okay,", "tokens": [50736, 400, 309, 311, 12678, 7908, 11, 597, 307, 5176, 570, 264, 2017, 307, 819, 13, 663, 311, 1392, 11, 50960], "temperature": 0.0, "avg_logprob": -0.1174822828986428, "compression_ratio": 1.5246636771300448, "no_speech_prob": 0.002216556342318654}, {"id": 330, "seek": 216736, "start": 2179.28, "end": 2183.84, "text": " but these two are a problem. So which is why Joshua Bloch states,", "tokens": [50960, 457, 613, 732, 366, 257, 1154, 13, 407, 597, 307, 983, 24005, 9865, 339, 4368, 11, 51188], "temperature": 0.0, "avg_logprob": -0.1174822828986428, "compression_ratio": 1.5246636771300448, "no_speech_prob": 0.002216556342318654}, {"id": 331, "seek": 216736, "start": 2185.36, "end": 2193.04, "text": " this approach just provides symmetry, but at the expense. So I don't think I read the previous bit.", "tokens": [51264, 341, 3109, 445, 6417, 25440, 11, 457, 412, 264, 18406, 13, 407, 286, 500, 380, 519, 286, 1401, 264, 3894, 857, 13, 51648], "temperature": 0.0, "avg_logprob": -0.1174822828986428, "compression_ratio": 1.5246636771300448, "no_speech_prob": 0.002216556342318654}, {"id": 332, "seek": 219304, "start": 2193.04, "end": 2200.0, "text": " So just to add on to what he was saying about the override method, he says, this method here,", "tokens": [50364, 407, 445, 281, 909, 322, 281, 437, 415, 390, 1566, 466, 264, 42321, 3170, 11, 415, 1619, 11, 341, 3170, 510, 11, 50712], "temperature": 0.0, "avg_logprob": -0.09378668319347293, "compression_ratio": 1.7019230769230769, "no_speech_prob": 0.00014424865366891026}, {"id": 333, "seek": 219304, "start": 2201.2, "end": 2206.64, "text": " he says, you might try to fix the problem by having color point or equals ignore color", "tokens": [50772, 415, 1619, 11, 291, 1062, 853, 281, 3191, 264, 1154, 538, 1419, 2017, 935, 420, 6915, 11200, 2017, 51044], "temperature": 0.0, "avg_logprob": -0.09378668319347293, "compression_ratio": 1.7019230769230769, "no_speech_prob": 0.00014424865366891026}, {"id": 334, "seek": 219304, "start": 2206.64, "end": 2211.6, "text": " when doing mixed comparisons. And that's what we're doing in this condition here,", "tokens": [51044, 562, 884, 7467, 33157, 13, 400, 300, 311, 437, 321, 434, 884, 294, 341, 4188, 510, 11, 51292], "temperature": 0.0, "avg_logprob": -0.09378668319347293, "compression_ratio": 1.7019230769230769, "no_speech_prob": 0.00014424865366891026}, {"id": 335, "seek": 219304, "start": 2211.6, "end": 2216.96, "text": " where we're doing a color blind comparison by using the instance of method. So even a point", "tokens": [51292, 689, 321, 434, 884, 257, 2017, 6865, 9660, 538, 1228, 264, 5197, 295, 3170, 13, 407, 754, 257, 935, 51560], "temperature": 0.0, "avg_logprob": -0.09378668319347293, "compression_ratio": 1.7019230769230769, "no_speech_prob": 0.00014424865366891026}, {"id": 336, "seek": 221696, "start": 2216.96, "end": 2226.0, "text": " can be passed on to this object of type point. And then he continues, now, so what we discussed", "tokens": [50364, 393, 312, 4678, 322, 281, 341, 2657, 295, 2010, 935, 13, 400, 550, 415, 6515, 11, 586, 11, 370, 437, 321, 7152, 50816], "temperature": 0.0, "avg_logprob": -0.11007130379770316, "compression_ratio": 1.628691983122363, "no_speech_prob": 0.013846423476934433}, {"id": 337, "seek": 221696, "start": 2226.0, "end": 2234.4, "text": " here before, now P1 equals P2 when P2 equals P3 returns true, where it shouldn't, while P1 equals", "tokens": [50816, 510, 949, 11, 586, 430, 16, 6915, 430, 17, 562, 430, 17, 6915, 430, 18, 11247, 2074, 11, 689, 309, 4659, 380, 11, 1339, 430, 16, 6915, 51236], "temperature": 0.0, "avg_logprob": -0.11007130379770316, "compression_ratio": 1.628691983122363, "no_speech_prob": 0.013846423476934433}, {"id": 338, "seek": 221696, "start": 2234.4, "end": 2241.36, "text": " P3 returns false, a clear violation of transitivity. The first two comparisons are color blind,", "tokens": [51236, 430, 18, 11247, 7908, 11, 257, 1850, 22840, 295, 17976, 4253, 13, 440, 700, 732, 33157, 366, 2017, 6865, 11, 51584], "temperature": 0.0, "avg_logprob": -0.11007130379770316, "compression_ratio": 1.628691983122363, "no_speech_prob": 0.013846423476934433}, {"id": 339, "seek": 221696, "start": 2241.36, "end": 2246.32, "text": " while the third takes color into account, and that shouldn't be the case. So what do we do here?", "tokens": [51584, 1339, 264, 2636, 2516, 2017, 666, 2696, 11, 293, 300, 4659, 380, 312, 264, 1389, 13, 407, 437, 360, 321, 360, 510, 30, 51832], "temperature": 0.0, "avg_logprob": -0.11007130379770316, "compression_ratio": 1.628691983122363, "no_speech_prob": 0.013846423476934433}, {"id": 340, "seek": 224632, "start": 2246.32, "end": 2254.32, "text": " We've got this huge object oriented predicament, or for us programmers, even a existential crisis,", "tokens": [50364, 492, 600, 658, 341, 2603, 2657, 21841, 47336, 2466, 11, 420, 337, 505, 41504, 11, 754, 257, 37133, 5869, 11, 50764], "temperature": 0.0, "avg_logprob": -0.10593260889467986, "compression_ratio": 1.6111111111111112, "no_speech_prob": 0.0038835257291793823}, {"id": 341, "seek": 224632, "start": 2254.32, "end": 2260.2400000000002, "text": " what are we going to do? What's the solution? He says, it turns out that this is a fundamental", "tokens": [50764, 437, 366, 321, 516, 281, 360, 30, 708, 311, 264, 3827, 30, 634, 1619, 11, 309, 4523, 484, 300, 341, 307, 257, 8088, 51060], "temperature": 0.0, "avg_logprob": -0.10593260889467986, "compression_ratio": 1.6111111111111112, "no_speech_prob": 0.0038835257291793823}, {"id": 342, "seek": 224632, "start": 2260.2400000000002, "end": 2264.96, "text": " problem of equivalence relations in object oriented languages. This is kind of what I said before.", "tokens": [51060, 1154, 295, 9052, 655, 2299, 294, 2657, 21841, 8650, 13, 639, 307, 733, 295, 437, 286, 848, 949, 13, 51296], "temperature": 0.0, "avg_logprob": -0.10593260889467986, "compression_ratio": 1.6111111111111112, "no_speech_prob": 0.0038835257291793823}, {"id": 343, "seek": 224632, "start": 2265.6800000000003, "end": 2272.96, "text": " There's no way to extend an insensiable, insensiable class and add a value component", "tokens": [51332, 821, 311, 572, 636, 281, 10101, 364, 1028, 694, 9364, 11, 1028, 694, 9364, 1508, 293, 909, 257, 2158, 6542, 51696], "temperature": 0.0, "avg_logprob": -0.10593260889467986, "compression_ratio": 1.6111111111111112, "no_speech_prob": 0.0038835257291793823}, {"id": 344, "seek": 227296, "start": 2272.96, "end": 2280.08, "text": " while preserving the equals contract. The problem again, the big problem is in our design, where", "tokens": [50364, 1339, 33173, 264, 6915, 4364, 13, 440, 1154, 797, 11, 264, 955, 1154, 307, 294, 527, 1715, 11, 689, 50720], "temperature": 0.0, "avg_logprob": -0.12190206527709961, "compression_ratio": 1.6431535269709543, "no_speech_prob": 0.0079368706792593}, {"id": 345, "seek": 227296, "start": 2280.08, "end": 2287.84, "text": " we may point a concrete class. And we shall see why it should have been made a abstract class instead.", "tokens": [50720, 321, 815, 935, 257, 9859, 1508, 13, 400, 321, 4393, 536, 983, 309, 820, 362, 668, 1027, 257, 12649, 1508, 2602, 13, 51108], "temperature": 0.0, "avg_logprob": -0.12190206527709961, "compression_ratio": 1.6431535269709543, "no_speech_prob": 0.0079368706792593}, {"id": 346, "seek": 227296, "start": 2287.84, "end": 2294.48, "text": " But later, sorry, I'm getting a bit carried away. Let's stay on track. Again, re-reading that point", "tokens": [51108, 583, 1780, 11, 2597, 11, 286, 478, 1242, 257, 857, 9094, 1314, 13, 961, 311, 1754, 322, 2837, 13, 3764, 11, 319, 12, 35908, 300, 935, 51440], "temperature": 0.0, "avg_logprob": -0.12190206527709961, "compression_ratio": 1.6431535269709543, "no_speech_prob": 0.0079368706792593}, {"id": 347, "seek": 227296, "start": 2294.48, "end": 2301.52, "text": " because it's important. There's no way to extend an insensiable class, insensiable class and add", "tokens": [51440, 570, 309, 311, 1021, 13, 821, 311, 572, 636, 281, 10101, 364, 1028, 694, 9364, 1508, 11, 1028, 694, 9364, 1508, 293, 909, 51792], "temperature": 0.0, "avg_logprob": -0.12190206527709961, "compression_ratio": 1.6431535269709543, "no_speech_prob": 0.0079368706792593}, {"id": 348, "seek": 230152, "start": 2301.52, "end": 2307.84, "text": " a value component while preserving the equals contract, unless you're willing to forego the", "tokens": [50364, 257, 2158, 6542, 1339, 33173, 264, 6915, 4364, 11, 5969, 291, 434, 4950, 281, 2091, 1571, 264, 50680], "temperature": 0.0, "avg_logprob": -0.11284763548109267, "compression_ratio": 1.544, "no_speech_prob": 0.002672656672075391}, {"id": 349, "seek": 230152, "start": 2307.84, "end": 2313.68, "text": " benefits of object oriented abstraction. And then Joshua Block states that we might try to circumvent", "tokens": [50680, 5311, 295, 2657, 21841, 37765, 13, 400, 550, 24005, 17500, 4368, 300, 321, 1062, 853, 281, 7125, 2475, 50972], "temperature": 0.0, "avg_logprob": -0.11284763548109267, "compression_ratio": 1.544, "no_speech_prob": 0.002672656672075391}, {"id": 350, "seek": 230152, "start": 2313.68, "end": 2321.28, "text": " this issue in a bit of a sly way by trying to use Java's reflexive API or reflections API. In any", "tokens": [50972, 341, 2734, 294, 257, 857, 295, 257, 262, 356, 636, 538, 1382, 281, 764, 10745, 311, 23802, 488, 9362, 420, 30679, 9362, 13, 682, 604, 51352], "temperature": 0.0, "avg_logprob": -0.11284763548109267, "compression_ratio": 1.544, "no_speech_prob": 0.002672656672075391}, {"id": 351, "seek": 230152, "start": 2321.28, "end": 2327.28, "text": " case, it's changing the class on runtime, which is what I tried to demonstrate with the second", "tokens": [51352, 1389, 11, 309, 311, 4473, 264, 1508, 322, 34474, 11, 597, 307, 437, 286, 3031, 281, 11698, 365, 264, 1150, 51652], "temperature": 0.0, "avg_logprob": -0.11284763548109267, "compression_ratio": 1.544, "no_speech_prob": 0.002672656672075391}, {"id": 352, "seek": 232728, "start": 2327.6800000000003, "end": 2333.6800000000003, "text": " equals method, which we think would work. So if I do, whoops, I shouldn't have clicked that.", "tokens": [50384, 6915, 3170, 11, 597, 321, 519, 576, 589, 13, 407, 498, 286, 360, 11, 567, 3370, 11, 286, 4659, 380, 362, 23370, 300, 13, 50684], "temperature": 0.0, "avg_logprob": -0.13563458292107833, "compression_ratio": 1.518018018018018, "no_speech_prob": 0.013016501441597939}, {"id": 353, "seek": 232728, "start": 2333.6800000000003, "end": 2336.7200000000003, "text": " If I do look at this equals method, I'll comment this out.", "tokens": [50684, 759, 286, 360, 574, 412, 341, 6915, 3170, 11, 286, 603, 2871, 341, 484, 13, 50836], "temperature": 0.0, "avg_logprob": -0.13563458292107833, "compression_ratio": 1.518018018018018, "no_speech_prob": 0.013016501441597939}, {"id": 354, "seek": 232728, "start": 2339.1200000000003, "end": 2345.84, "text": " We're using the dot get class method from the Reflections API. Okay, before we get to that,", "tokens": [50956, 492, 434, 1228, 264, 5893, 483, 1508, 3170, 490, 264, 16957, 1809, 626, 9362, 13, 1033, 11, 949, 321, 483, 281, 300, 11, 51292], "temperature": 0.0, "avg_logprob": -0.13563458292107833, "compression_ratio": 1.518018018018018, "no_speech_prob": 0.013016501441597939}, {"id": 355, "seek": 232728, "start": 2345.84, "end": 2352.5600000000004, "text": " let me quickly read out some theory. What is get class in Java? Again, according to chat GPT,", "tokens": [51292, 718, 385, 2661, 1401, 484, 512, 5261, 13, 708, 307, 483, 1508, 294, 10745, 30, 3764, 11, 4650, 281, 5081, 26039, 51, 11, 51628], "temperature": 0.0, "avg_logprob": -0.13563458292107833, "compression_ratio": 1.518018018018018, "no_speech_prob": 0.013016501441597939}, {"id": 356, "seek": 235256, "start": 2353.52, "end": 2360.0, "text": " here's what get class is. In Java, the get class method is a method of the object class that", "tokens": [50412, 510, 311, 437, 483, 1508, 307, 13, 682, 10745, 11, 264, 483, 1508, 3170, 307, 257, 3170, 295, 264, 2657, 1508, 300, 50736], "temperature": 0.0, "avg_logprob": -0.1017434195186315, "compression_ratio": 1.7962085308056872, "no_speech_prob": 0.011328917928040028}, {"id": 357, "seek": 235256, "start": 2360.0, "end": 2366.4, "text": " returns the runtime class of an object. Correct. It returns an object of type class, which is a", "tokens": [50736, 11247, 264, 34474, 1508, 295, 364, 2657, 13, 12753, 13, 467, 11247, 364, 2657, 295, 2010, 1508, 11, 597, 307, 257, 51056], "temperature": 0.0, "avg_logprob": -0.1017434195186315, "compression_ratio": 1.7962085308056872, "no_speech_prob": 0.011328917928040028}, {"id": 358, "seek": 235256, "start": 2366.4, "end": 2372.64, "text": " class in the Java reflection API that represents a class or interface in the Java programming", "tokens": [51056, 1508, 294, 264, 10745, 12914, 9362, 300, 8855, 257, 1508, 420, 9226, 294, 264, 10745, 9410, 51368], "temperature": 0.0, "avg_logprob": -0.1017434195186315, "compression_ratio": 1.7962085308056872, "no_speech_prob": 0.011328917928040028}, {"id": 359, "seek": 235256, "start": 2372.64, "end": 2379.36, "text": " language. This in fact is very accurate, which is amazing because if you look at the Oracle docs", "tokens": [51368, 2856, 13, 639, 294, 1186, 307, 588, 8559, 11, 597, 307, 2243, 570, 498, 291, 574, 412, 264, 25654, 45623, 51704], "temperature": 0.0, "avg_logprob": -0.1017434195186315, "compression_ratio": 1.7962085308056872, "no_speech_prob": 0.011328917928040028}, {"id": 360, "seek": 237936, "start": 2379.36, "end": 2388.8, "text": " and whatnot, chat GPT puts it in a more simpler way to understand. An example would be here,", "tokens": [50364, 293, 25882, 11, 5081, 26039, 51, 8137, 309, 294, 257, 544, 18587, 636, 281, 1223, 13, 1107, 1365, 576, 312, 510, 11, 50836], "temperature": 0.0, "avg_logprob": -0.11651434963696623, "compression_ratio": 1.6136363636363635, "no_speech_prob": 0.0017544577131047845}, {"id": 361, "seek": 237936, "start": 2388.8, "end": 2397.92, "text": " if we have this employee class or the employee object of type employee, if we go and they have", "tokens": [50836, 498, 321, 362, 341, 10738, 1508, 420, 264, 10738, 2657, 295, 2010, 10738, 11, 498, 321, 352, 293, 436, 362, 51292], "temperature": 0.0, "avg_logprob": -0.11651434963696623, "compression_ratio": 1.6136363636363635, "no_speech_prob": 0.0017544577131047845}, {"id": 362, "seek": 237936, "start": 2397.92, "end": 2404.8, "text": " another class, which we get, we get the class of employee and save it. We don't even really have", "tokens": [51292, 1071, 1508, 11, 597, 321, 483, 11, 321, 483, 264, 1508, 295, 10738, 293, 3155, 309, 13, 492, 500, 380, 754, 534, 362, 51636], "temperature": 0.0, "avg_logprob": -0.11651434963696623, "compression_ratio": 1.6136363636363635, "no_speech_prob": 0.0017544577131047845}, {"id": 363, "seek": 240480, "start": 2404.8, "end": 2410.0800000000004, "text": " to do this. We could just go employee dot get class really. We could just skip this step and go", "tokens": [50364, 281, 360, 341, 13, 492, 727, 445, 352, 10738, 5893, 483, 1508, 534, 13, 492, 727, 445, 10023, 341, 1823, 293, 352, 50628], "temperature": 0.0, "avg_logprob": -0.1176089350382487, "compression_ratio": 1.7724550898203593, "no_speech_prob": 0.003764322493225336}, {"id": 364, "seek": 240480, "start": 2410.0800000000004, "end": 2422.88, "text": " employee dot get class dot get name. And then return the name of the class. And that's done runtime", "tokens": [50628, 10738, 5893, 483, 1508, 5893, 483, 1315, 13, 400, 550, 2736, 264, 1315, 295, 264, 1508, 13, 400, 300, 311, 1096, 34474, 51268], "temperature": 0.0, "avg_logprob": -0.1176089350382487, "compression_ratio": 1.7724550898203593, "no_speech_prob": 0.003764322493225336}, {"id": 365, "seek": 240480, "start": 2422.88, "end": 2429.04, "text": " by getting the type of the object. So we're trying to circumvent this issue by using the Reflections", "tokens": [51268, 538, 1242, 264, 2010, 295, 264, 2657, 13, 407, 321, 434, 1382, 281, 7125, 2475, 341, 2734, 538, 1228, 264, 16957, 1809, 626, 51576], "temperature": 0.0, "avg_logprob": -0.1176089350382487, "compression_ratio": 1.7724550898203593, "no_speech_prob": 0.003764322493225336}, {"id": 366, "seek": 242904, "start": 2429.04, "end": 2438.64, "text": " API, where we're saying only if it's a type of the implementation of that object. So we're checking", "tokens": [50364, 9362, 11, 689, 321, 434, 1566, 787, 498, 309, 311, 257, 2010, 295, 264, 11420, 295, 300, 2657, 13, 407, 321, 434, 8568, 50844], "temperature": 0.0, "avg_logprob": -0.13661354190700656, "compression_ratio": 1.994535519125683, "no_speech_prob": 0.006486220750957727}, {"id": 367, "seek": 242904, "start": 2438.64, "end": 2445.2799999999997, "text": " the class of the object we pass on to the equals method, and then we're checking the class of the", "tokens": [50844, 264, 1508, 295, 264, 2657, 321, 1320, 322, 281, 264, 6915, 3170, 11, 293, 550, 321, 434, 8568, 264, 1508, 295, 264, 51176], "temperature": 0.0, "avg_logprob": -0.13661354190700656, "compression_ratio": 1.994535519125683, "no_speech_prob": 0.006486220750957727}, {"id": 368, "seek": 242904, "start": 2445.2799999999997, "end": 2451.68, "text": " current object's runtime. So we're comparing two objects here, the object of this class,", "tokens": [51176, 2190, 2657, 311, 34474, 13, 407, 321, 434, 15763, 732, 6565, 510, 11, 264, 2657, 295, 341, 1508, 11, 51496], "temperature": 0.0, "avg_logprob": -0.13661354190700656, "compression_ratio": 1.994535519125683, "no_speech_prob": 0.006486220750957727}, {"id": 369, "seek": 242904, "start": 2452.4, "end": 2456.08, "text": " the broader class, and then the object we are passing on to the equals method,", "tokens": [51532, 264, 13227, 1508, 11, 293, 550, 264, 2657, 321, 366, 8437, 322, 281, 264, 6915, 3170, 11, 51716], "temperature": 0.0, "avg_logprob": -0.13661354190700656, "compression_ratio": 1.994535519125683, "no_speech_prob": 0.006486220750957727}, {"id": 370, "seek": 245608, "start": 2456.08, "end": 2460.56, "text": " and then we're doing the comparison. Unfortunately, this is not going to work,", "tokens": [50364, 293, 550, 321, 434, 884, 264, 9660, 13, 8590, 11, 341, 307, 406, 516, 281, 589, 11, 50588], "temperature": 0.0, "avg_logprob": -0.1273603711809431, "compression_ratio": 1.684782608695652, "no_speech_prob": 0.0024724211543798447}, {"id": 371, "seek": 245608, "start": 2460.56, "end": 2465.36, "text": " because it violates the less-carved substitution principle and breaks logical equality, which is", "tokens": [50588, 570, 309, 3448, 1024, 264, 1570, 12, 6166, 937, 35827, 8665, 293, 9857, 14978, 14949, 11, 597, 307, 50828], "temperature": 0.0, "avg_logprob": -0.1273603711809431, "compression_ratio": 1.684782608695652, "no_speech_prob": 0.0024724211543798447}, {"id": 372, "seek": 245608, "start": 2465.36, "end": 2472.88, "text": " why Joshua Block states, this effect has the effect of equating objects only if they have", "tokens": [50828, 983, 24005, 17500, 4368, 11, 341, 1802, 575, 264, 1802, 295, 1267, 990, 6565, 787, 498, 436, 362, 51204], "temperature": 0.0, "avg_logprob": -0.1273603711809431, "compression_ratio": 1.684782608695652, "no_speech_prob": 0.0024724211543798447}, {"id": 373, "seek": 245608, "start": 2472.88, "end": 2477.92, "text": " the same implementation class. So which is why we're checking here for the type of the implementation", "tokens": [51204, 264, 912, 11420, 1508, 13, 407, 597, 307, 983, 321, 434, 8568, 510, 337, 264, 2010, 295, 264, 11420, 51456], "temperature": 0.0, "avg_logprob": -0.1273603711809431, "compression_ratio": 1.684782608695652, "no_speech_prob": 0.0024724211543798447}, {"id": 374, "seek": 245608, "start": 2477.92, "end": 2485.52, "text": " class. This may not seem so bad, but the consequences are unacceptable. An instance of a subclass", "tokens": [51456, 1508, 13, 639, 815, 406, 1643, 370, 1578, 11, 457, 264, 10098, 366, 31812, 13, 1107, 5197, 295, 257, 1422, 11665, 51836], "temperature": 0.0, "avg_logprob": -0.1273603711809431, "compression_ratio": 1.684782608695652, "no_speech_prob": 0.0024724211543798447}, {"id": 375, "seek": 248552, "start": 2485.6, "end": 2493.7599999999998, "text": " of point is still a point. So an instance of point, for example, like call point is still a point,", "tokens": [50368, 295, 935, 307, 920, 257, 935, 13, 407, 364, 5197, 295, 935, 11, 337, 1365, 11, 411, 818, 935, 307, 920, 257, 935, 11, 50776], "temperature": 0.0, "avg_logprob": -0.1060963047360911, "compression_ratio": 1.708695652173913, "no_speech_prob": 0.0074598356150090694}, {"id": 376, "seek": 248552, "start": 2493.7599999999998, "end": 2500.64, "text": " and it should work with this equals method, but it doesn't. And it still needs to function as one,", "tokens": [50776, 293, 309, 820, 589, 365, 341, 6915, 3170, 11, 457, 309, 1177, 380, 13, 400, 309, 920, 2203, 281, 2445, 382, 472, 11, 51120], "temperature": 0.0, "avg_logprob": -0.1060963047360911, "compression_ratio": 1.708695652173913, "no_speech_prob": 0.0074598356150090694}, {"id": 377, "seek": 248552, "start": 2500.64, "end": 2505.44, "text": " but it fails to do so if you take this approach. Now let's take a look at an example where we're", "tokens": [51120, 457, 309, 18199, 281, 360, 370, 498, 291, 747, 341, 3109, 13, 823, 718, 311, 747, 257, 574, 412, 364, 1365, 689, 321, 434, 51360], "temperature": 0.0, "avg_logprob": -0.1060963047360911, "compression_ratio": 1.708695652173913, "no_speech_prob": 0.0074598356150090694}, {"id": 378, "seek": 248552, "start": 2505.44, "end": 2512.96, "text": " trying to tell whether a point is on the unit circle. Here's an example. So what this counterpoint", "tokens": [51360, 1382, 281, 980, 1968, 257, 935, 307, 322, 264, 4985, 6329, 13, 1692, 311, 364, 1365, 13, 407, 437, 341, 5682, 6053, 51736], "temperature": 0.0, "avg_logprob": -0.1060963047360911, "compression_ratio": 1.708695652173913, "no_speech_prob": 0.0074598356150090694}, {"id": 379, "seek": 251296, "start": 2512.96, "end": 2520.8, "text": " test is trying to do is to see if this is a point. This point class is a point on a unit circle.", "tokens": [50364, 1500, 307, 1382, 281, 360, 307, 281, 536, 498, 341, 307, 257, 935, 13, 639, 935, 1508, 307, 257, 935, 322, 257, 4985, 6329, 13, 50756], "temperature": 0.0, "avg_logprob": -0.12593626674217515, "compression_ratio": 1.646067415730337, "no_speech_prob": 0.007459838408976793}, {"id": 380, "seek": 251296, "start": 2520.8, "end": 2528.56, "text": " We're creating a set of type point, and we're adding some points into it. And then we have this", "tokens": [50756, 492, 434, 4084, 257, 992, 295, 2010, 935, 11, 293, 321, 434, 5127, 512, 2793, 666, 309, 13, 400, 550, 321, 362, 341, 51144], "temperature": 0.0, "avg_logprob": -0.12593626674217515, "compression_ratio": 1.646067415730337, "no_speech_prob": 0.007459838408976793}, {"id": 381, "seek": 251296, "start": 2528.56, "end": 2536.16, "text": " public static Boolean, which returns a true false, that checks if this point is a point on a circle.", "tokens": [51144, 1908, 13437, 23351, 28499, 11, 597, 11247, 257, 2074, 7908, 11, 300, 13834, 498, 341, 935, 307, 257, 935, 322, 257, 6329, 13, 51524], "temperature": 0.0, "avg_logprob": -0.12593626674217515, "compression_ratio": 1.646067415730337, "no_speech_prob": 0.007459838408976793}, {"id": 382, "seek": 253616, "start": 2537.04, "end": 2543.52, "text": " And we're doing that by returning true if whatever point that we pass on to this method", "tokens": [50408, 400, 321, 434, 884, 300, 538, 12678, 2074, 498, 2035, 935, 300, 321, 1320, 322, 281, 341, 3170, 50732], "temperature": 0.0, "avg_logprob": -0.11661775561346524, "compression_ratio": 1.5706214689265536, "no_speech_prob": 0.00628885580226779}, {"id": 383, "seek": 253616, "start": 2544.64, "end": 2551.2799999999997, "text": " is contained in this set, the unit circle set. Initially here, it'll print true. It'll print", "tokens": [50788, 307, 16212, 294, 341, 992, 11, 264, 4985, 6329, 992, 13, 29446, 510, 11, 309, 603, 4482, 2074, 13, 467, 603, 4482, 51120], "temperature": 0.0, "avg_logprob": -0.11661775561346524, "compression_ratio": 1.5706214689265536, "no_speech_prob": 0.00628885580226779}, {"id": 384, "seek": 253616, "start": 2551.2799999999997, "end": 2558.56, "text": " true because it's of type point. But because our point class, we use the reflections API and used", "tokens": [51120, 2074, 570, 309, 311, 295, 2010, 935, 13, 583, 570, 527, 935, 1508, 11, 321, 764, 264, 30679, 9362, 293, 1143, 51484], "temperature": 0.0, "avg_logprob": -0.11661775561346524, "compression_ratio": 1.5706214689265536, "no_speech_prob": 0.00628885580226779}, {"id": 385, "seek": 255856, "start": 2559.36, "end": 2568.48, "text": " get class. When we pass something, a subtype of kind of point, which again, if it did respect", "tokens": [50404, 483, 1508, 13, 1133, 321, 1320, 746, 11, 257, 1422, 20467, 295, 733, 295, 935, 11, 597, 797, 11, 498, 309, 630, 3104, 50860], "temperature": 0.0, "avg_logprob": -0.14635357649429984, "compression_ratio": 1.611353711790393, "no_speech_prob": 0.011329799890518188}, {"id": 386, "seek": 255856, "start": 2568.48, "end": 2574.48, "text": " or follow the less curve substitution principle, it should still print true because it's still", "tokens": [50860, 420, 1524, 264, 1570, 7605, 35827, 8665, 11, 309, 820, 920, 4482, 2074, 570, 309, 311, 920, 51160], "temperature": 0.0, "avg_logprob": -0.14635357649429984, "compression_ratio": 1.611353711790393, "no_speech_prob": 0.011329799890518188}, {"id": 387, "seek": 255856, "start": 2574.48, "end": 2581.6, "text": " a type of point and it should behave as such. It'll print false, unfortunately. There we go.", "tokens": [51160, 257, 2010, 295, 935, 293, 309, 820, 15158, 382, 1270, 13, 467, 603, 4482, 7908, 11, 7015, 13, 821, 321, 352, 13, 51516], "temperature": 0.0, "avg_logprob": -0.14635357649429984, "compression_ratio": 1.611353711790393, "no_speech_prob": 0.011329799890518188}, {"id": 388, "seek": 255856, "start": 2581.6, "end": 2586.16, "text": " In the second one, it's printing false. And this is a clear violation of the principle.", "tokens": [51516, 682, 264, 1150, 472, 11, 309, 311, 14699, 7908, 13, 400, 341, 307, 257, 1850, 22840, 295, 264, 8665, 13, 51744], "temperature": 0.0, "avg_logprob": -0.14635357649429984, "compression_ratio": 1.611353711790393, "no_speech_prob": 0.011329799890518188}, {"id": 389, "seek": 258616, "start": 2586.96, "end": 2592.08, "text": " Therefore, using get class and the reflections API is still not the way to circumvent this issue", "tokens": [50404, 7504, 11, 1228, 483, 1508, 293, 264, 30679, 9362, 307, 920, 406, 264, 636, 281, 7125, 2475, 341, 2734, 50660], "temperature": 0.0, "avg_logprob": -0.12360668182373047, "compression_ratio": 1.7294117647058824, "no_speech_prob": 0.001926385099068284}, {"id": 390, "seek": 258616, "start": 2592.08, "end": 2596.7999999999997, "text": " with object oriented languages. So again, I know we discussed the less curve", "tokens": [50660, 365, 2657, 21841, 8650, 13, 407, 797, 11, 286, 458, 321, 7152, 264, 1570, 7605, 50896], "temperature": 0.0, "avg_logprob": -0.12360668182373047, "compression_ratio": 1.7294117647058824, "no_speech_prob": 0.001926385099068284}, {"id": 391, "seek": 258616, "start": 2596.7999999999997, "end": 2600.7999999999997, "text": " substitution principle before, but in the book Joshua Block states the less curve", "tokens": [50896, 35827, 8665, 949, 11, 457, 294, 264, 1446, 24005, 17500, 4368, 264, 1570, 7605, 51096], "temperature": 0.0, "avg_logprob": -0.12360668182373047, "compression_ratio": 1.7294117647058824, "no_speech_prob": 0.001926385099068284}, {"id": 392, "seek": 258616, "start": 2600.7999999999997, "end": 2607.68, "text": " substitution principle says that any important property of a type should also hold for all its", "tokens": [51096, 35827, 8665, 1619, 300, 604, 1021, 4707, 295, 257, 2010, 820, 611, 1797, 337, 439, 1080, 51440], "temperature": 0.0, "avg_logprob": -0.12360668182373047, "compression_ratio": 1.7294117647058824, "no_speech_prob": 0.001926385099068284}, {"id": 393, "seek": 258616, "start": 2607.68, "end": 2614.8799999999997, "text": " subtypes so that any method written for the type should work equally well on its subtypes.", "tokens": [51440, 1422, 874, 5190, 370, 300, 604, 3170, 3720, 337, 264, 2010, 820, 589, 12309, 731, 322, 1080, 1422, 874, 5190, 13, 51800], "temperature": 0.0, "avg_logprob": -0.12360668182373047, "compression_ratio": 1.7294117647058824, "no_speech_prob": 0.001926385099068284}, {"id": 394, "seek": 261488, "start": 2615.84, "end": 2624.0, "text": " And this is the formal statement of our earlier claim that a subclass of point, such as counterpoint,", "tokens": [50412, 400, 341, 307, 264, 9860, 5629, 295, 527, 3071, 3932, 300, 257, 1422, 11665, 295, 935, 11, 1270, 382, 5682, 6053, 11, 50820], "temperature": 0.0, "avg_logprob": -0.11844845021024664, "compression_ratio": 1.7636363636363637, "no_speech_prob": 0.002115492010489106}, {"id": 395, "seek": 261488, "start": 2624.96, "end": 2631.44, "text": " is still a point and must act as one. Now let's take a look at the problem with this. I mean,", "tokens": [50868, 307, 920, 257, 935, 293, 1633, 605, 382, 472, 13, 823, 718, 311, 747, 257, 574, 412, 264, 1154, 365, 341, 13, 286, 914, 11, 51192], "temperature": 0.0, "avg_logprob": -0.11844845021024664, "compression_ratio": 1.7636363636363637, "no_speech_prob": 0.002115492010489106}, {"id": 396, "seek": 261488, "start": 2631.44, "end": 2636.4, "text": " let's take a look at not the problem with the less curve substitution principle, but the problem", "tokens": [51192, 718, 311, 747, 257, 574, 412, 406, 264, 1154, 365, 264, 1570, 7605, 35827, 8665, 11, 457, 264, 1154, 51440], "temperature": 0.0, "avg_logprob": -0.11844845021024664, "compression_ratio": 1.7636363636363637, "no_speech_prob": 0.002115492010489106}, {"id": 397, "seek": 261488, "start": 2636.4, "end": 2641.92, "text": " with not following this principle. So we have this trivial class here that really does nothing.", "tokens": [51440, 365, 406, 3480, 341, 8665, 13, 407, 321, 362, 341, 26703, 1508, 510, 300, 534, 775, 1825, 13, 51716], "temperature": 0.0, "avg_logprob": -0.11844845021024664, "compression_ratio": 1.7636363636363637, "no_speech_prob": 0.002115492010489106}, {"id": 398, "seek": 264192, "start": 2642.0, "end": 2648.4, "text": " It doesn't really add a value component. It simply keeps track of how many instances of,", "tokens": [50368, 467, 1177, 380, 534, 909, 257, 2158, 6542, 13, 467, 2935, 5965, 2837, 295, 577, 867, 14519, 295, 11, 50688], "temperature": 0.0, "avg_logprob": -0.21369058820936415, "compression_ratio": 1.7535545023696681, "no_speech_prob": 0.01825907453894615}, {"id": 399, "seek": 264192, "start": 2648.4, "end": 2654.16, "text": " of, it's called counterpoint, which keeps track of how many instances of point are created. If you", "tokens": [50688, 295, 11, 309, 311, 1219, 5682, 6053, 11, 597, 5965, 2837, 295, 577, 867, 14519, 295, 935, 366, 2942, 13, 759, 291, 50976], "temperature": 0.0, "avg_logprob": -0.21369058820936415, "compression_ratio": 1.7535545023696681, "no_speech_prob": 0.01825907453894615}, {"id": 400, "seek": 264192, "start": 2654.16, "end": 2660.0, "text": " don't know an atomic integer is a thread safe counter, a variable which you can increase.", "tokens": [50976, 500, 380, 458, 364, 22275, 24922, 307, 257, 7207, 3273, 5682, 11, 257, 7006, 597, 291, 393, 3488, 13, 51268], "temperature": 0.0, "avg_logprob": -0.21369058820936415, "compression_ratio": 1.7535545023696681, "no_speech_prob": 0.01825907453894615}, {"id": 401, "seek": 264192, "start": 2660.8, "end": 2666.56, "text": " So simply every time an instance of counterpoint is created, we also we're invoking even the", "tokens": [51308, 407, 2935, 633, 565, 364, 5197, 295, 5682, 6053, 307, 2942, 11, 321, 611, 321, 434, 1048, 5953, 754, 264, 51596], "temperature": 0.0, "avg_logprob": -0.21369058820936415, "compression_ratio": 1.7535545023696681, "no_speech_prob": 0.01825907453894615}, {"id": 402, "seek": 266656, "start": 2667.52, "end": 2673.7599999999998, "text": " the super class, the point in this case, and then we can get account of how many instances of", "tokens": [50412, 264, 1687, 1508, 11, 264, 935, 294, 341, 1389, 11, 293, 550, 321, 393, 483, 2696, 295, 577, 867, 14519, 295, 50724], "temperature": 0.0, "avg_logprob": -0.10663280692151798, "compression_ratio": 1.6944444444444444, "no_speech_prob": 0.0054681915789842606}, {"id": 403, "seek": 266656, "start": 2673.7599999999998, "end": 2680.16, "text": " point were created because of this atomic counter. So again, counterpoint is a subtype of point.", "tokens": [50724, 935, 645, 2942, 570, 295, 341, 22275, 5682, 13, 407, 797, 11, 5682, 6053, 307, 257, 1422, 20467, 295, 935, 13, 51044], "temperature": 0.0, "avg_logprob": -0.10663280692151798, "compression_ratio": 1.6944444444444444, "no_speech_prob": 0.0054681915789842606}, {"id": 404, "seek": 266656, "start": 2680.16, "end": 2685.04, "text": " Apologies, I demoed this bit a bit earlier before, and I think I used the word color", "tokens": [51044, 8723, 6204, 11, 286, 10723, 292, 341, 857, 257, 857, 3071, 949, 11, 293, 286, 519, 286, 1143, 264, 1349, 2017, 51288], "temperature": 0.0, "avg_logprob": -0.10663280692151798, "compression_ratio": 1.6944444444444444, "no_speech_prob": 0.0054681915789842606}, {"id": 405, "seek": 266656, "start": 2685.04, "end": 2689.68, "text": " point by mistake. I think I should have said counterpoint. It's just both counterpoint and", "tokens": [51288, 935, 538, 6146, 13, 286, 519, 286, 820, 362, 848, 5682, 6053, 13, 467, 311, 445, 1293, 5682, 6053, 293, 51520], "temperature": 0.0, "avg_logprob": -0.10663280692151798, "compression_ratio": 1.6944444444444444, "no_speech_prob": 0.0054681915789842606}, {"id": 406, "seek": 268968, "start": 2689.68, "end": 2697.04, "text": " color point are subtypes of point. But as you saw before, it also returned faults,", "tokens": [50364, 2017, 935, 366, 1422, 874, 5190, 295, 935, 13, 583, 382, 291, 1866, 949, 11, 309, 611, 8752, 36090, 11, 50732], "temperature": 0.0, "avg_logprob": -0.16125385701155462, "compression_ratio": 1.8084291187739463, "no_speech_prob": 0.04465777426958084}, {"id": 407, "seek": 268968, "start": 2697.7599999999998, "end": 2702.48, "text": " because we've got a problem with, we haven't got a problem with, sorry, I was going to say we've", "tokens": [50768, 570, 321, 600, 658, 257, 1154, 365, 11, 321, 2378, 380, 658, 257, 1154, 365, 11, 2597, 11, 286, 390, 516, 281, 584, 321, 600, 51004], "temperature": 0.0, "avg_logprob": -0.16125385701155462, "compression_ratio": 1.8084291187739463, "no_speech_prob": 0.04465777426958084}, {"id": 408, "seek": 268968, "start": 2702.48, "end": 2707.8399999999997, "text": " got a problem with the, with the contains method. The contains method exactly behaves the way it's", "tokens": [51004, 658, 257, 1154, 365, 264, 11, 365, 264, 8306, 3170, 13, 440, 8306, 3170, 2293, 36896, 264, 636, 309, 311, 51272], "temperature": 0.0, "avg_logprob": -0.16125385701155462, "compression_ratio": 1.8084291187739463, "no_speech_prob": 0.04465777426958084}, {"id": 409, "seek": 268968, "start": 2707.8399999999997, "end": 2712.96, "text": " supposed to, but we have a, we have a violation of the less curve substitution principle, which", "tokens": [51272, 3442, 281, 11, 457, 321, 362, 257, 11, 321, 362, 257, 22840, 295, 264, 1570, 7605, 35827, 8665, 11, 597, 51528], "temperature": 0.0, "avg_logprob": -0.16125385701155462, "compression_ratio": 1.8084291187739463, "no_speech_prob": 0.04465777426958084}, {"id": 410, "seek": 268968, "start": 2712.96, "end": 2719.2, "text": " is why it's training faults. Again, I apologize if I confused you by stating color point, I meant", "tokens": [51528, 307, 983, 309, 311, 3097, 36090, 13, 3764, 11, 286, 12328, 498, 286, 9019, 291, 538, 26688, 2017, 935, 11, 286, 4140, 51840], "temperature": 0.0, "avg_logprob": -0.16125385701155462, "compression_ratio": 1.8084291187739463, "no_speech_prob": 0.04465777426958084}, {"id": 411, "seek": 271920, "start": 2719.2, "end": 2724.3999999999996, "text": " to say counterpoint, which is this class that this is a, this is a useless class really. It just", "tokens": [50364, 281, 584, 5682, 6053, 11, 597, 307, 341, 1508, 300, 341, 307, 257, 11, 341, 307, 257, 14115, 1508, 534, 13, 467, 445, 50624], "temperature": 0.0, "avg_logprob": -0.15992441177368164, "compression_ratio": 1.662037037037037, "no_speech_prob": 0.004537780303508043}, {"id": 412, "seek": 271920, "start": 2725.04, "end": 2731.3599999999997, "text": " invokes the constructor in the superclass point and then keeps track of how many", "tokens": [50656, 1048, 8606, 264, 47479, 294, 264, 1687, 11665, 935, 293, 550, 5965, 2837, 295, 577, 867, 50972], "temperature": 0.0, "avg_logprob": -0.15992441177368164, "compression_ratio": 1.662037037037037, "no_speech_prob": 0.004537780303508043}, {"id": 413, "seek": 271920, "start": 2732.24, "end": 2739.9199999999996, "text": " objects of point have been created. But why, so the question of course is why do we get this", "tokens": [51016, 6565, 295, 935, 362, 668, 2942, 13, 583, 983, 11, 370, 264, 1168, 295, 1164, 307, 983, 360, 321, 483, 341, 51400], "temperature": 0.0, "avg_logprob": -0.15992441177368164, "compression_ratio": 1.662037037037037, "no_speech_prob": 0.004537780303508043}, {"id": 414, "seek": 271920, "start": 2739.9199999999996, "end": 2746.56, "text": " second false here, despite counterpoint being a subtype of point, it is because of this.", "tokens": [51400, 1150, 7908, 510, 11, 7228, 5682, 6053, 885, 257, 1422, 20467, 295, 935, 11, 309, 307, 570, 295, 341, 13, 51732], "temperature": 0.0, "avg_logprob": -0.15992441177368164, "compression_ratio": 1.662037037037037, "no_speech_prob": 0.004537780303508043}, {"id": 415, "seek": 274656, "start": 2746.7999999999997, "end": 2755.04, "text": " Because most collections, so set is a collection here of type point, including the hash set that", "tokens": [50376, 1436, 881, 16641, 11, 370, 992, 307, 257, 5765, 510, 295, 2010, 935, 11, 3009, 264, 22019, 992, 300, 50788], "temperature": 0.0, "avg_logprob": -0.15255538277004077, "compression_ratio": 1.5875706214689265, "no_speech_prob": 0.001454921206459403}, {"id": 416, "seek": 274656, "start": 2755.04, "end": 2762.08, "text": " we used here by the own unit circle method, use the equals method to test for containment.", "tokens": [50788, 321, 1143, 510, 538, 264, 1065, 4985, 6329, 3170, 11, 764, 264, 6915, 3170, 281, 1500, 337, 44058, 13, 51140], "temperature": 0.0, "avg_logprob": -0.15255538277004077, "compression_ratio": 1.5875706214689265, "no_speech_prob": 0.001454921206459403}, {"id": 417, "seek": 274656, "start": 2762.72, "end": 2768.72, "text": " And no kind of point instance is equal, equal to any point. And why is that? That is because,", "tokens": [51172, 400, 572, 733, 295, 935, 5197, 307, 2681, 11, 2681, 281, 604, 935, 13, 400, 983, 307, 300, 30, 663, 307, 570, 11, 51472], "temperature": 0.0, "avg_logprob": -0.15255538277004077, "compression_ratio": 1.5875706214689265, "no_speech_prob": 0.001454921206459403}, {"id": 418, "seek": 276872, "start": 2768.72, "end": 2776.7999999999997, "text": " as I said before, we're using get class here. And if, if counterpoint is not of type point,", "tokens": [50364, 382, 286, 848, 949, 11, 321, 434, 1228, 483, 1508, 510, 13, 400, 498, 11, 498, 5682, 6053, 307, 406, 295, 2010, 935, 11, 50768], "temperature": 0.0, "avg_logprob": -0.14891875464961213, "compression_ratio": 1.7397260273972603, "no_speech_prob": 0.00912333745509386}, {"id": 419, "seek": 276872, "start": 2776.7999999999997, "end": 2782.56, "text": " we aren't gonna, it's going to return faults. So therefore, that's why we get a false here too,", "tokens": [50768, 321, 3212, 380, 799, 11, 309, 311, 516, 281, 2736, 36090, 13, 407, 4412, 11, 300, 311, 983, 321, 483, 257, 7908, 510, 886, 11, 51056], "temperature": 0.0, "avg_logprob": -0.14891875464961213, "compression_ratio": 1.7397260273972603, "no_speech_prob": 0.00912333745509386}, {"id": 420, "seek": 276872, "start": 2783.2, "end": 2788.7999999999997, "text": " which the, sorry, it's a wrong one. We get a false here too, which the contains method uses the", "tokens": [51088, 597, 264, 11, 2597, 11, 309, 311, 257, 2085, 472, 13, 492, 483, 257, 7908, 510, 886, 11, 597, 264, 8306, 3170, 4960, 264, 51368], "temperature": 0.0, "avg_logprob": -0.14891875464961213, "compression_ratio": 1.7397260273972603, "no_speech_prob": 0.00912333745509386}, {"id": 421, "seek": 276872, "start": 2788.7999999999997, "end": 2798.16, "text": " equals method in the object, in the point object. And that's why Joshua Bloch states, if however,", "tokens": [51368, 6915, 3170, 294, 264, 2657, 11, 294, 264, 935, 2657, 13, 400, 300, 311, 983, 24005, 9865, 339, 4368, 11, 498, 4461, 11, 51836], "temperature": 0.0, "avg_logprob": -0.14891875464961213, "compression_ratio": 1.7397260273972603, "no_speech_prob": 0.00912333745509386}, {"id": 422, "seek": 279816, "start": 2798.16, "end": 2805.12, "text": " you use a proper instance of base equals method on point, the same onion cycles circle method", "tokens": [50364, 291, 764, 257, 2296, 5197, 295, 3096, 6915, 3170, 322, 935, 11, 264, 912, 10916, 17796, 6329, 3170, 50712], "temperature": 0.0, "avg_logprob": -0.13863661751818301, "compression_ratio": 1.5642458100558658, "no_speech_prob": 0.0002958927070721984}, {"id": 423, "seek": 279816, "start": 2805.12, "end": 2809.12, "text": " works fine when presented with a counterpoint instance. And let's take a look at that.", "tokens": [50712, 1985, 2489, 562, 8212, 365, 257, 5682, 6053, 5197, 13, 400, 718, 311, 747, 257, 574, 412, 300, 13, 50912], "temperature": 0.0, "avg_logprob": -0.13863661751818301, "compression_ratio": 1.5642458100558658, "no_speech_prob": 0.0002958927070721984}, {"id": 424, "seek": 279816, "start": 2811.68, "end": 2820.3999999999996, "text": " So on point, instead of using this equals method that uses get class, if we go back to the previous", "tokens": [51040, 407, 322, 935, 11, 2602, 295, 1228, 341, 6915, 3170, 300, 4960, 483, 1508, 11, 498, 321, 352, 646, 281, 264, 3894, 51476], "temperature": 0.0, "avg_logprob": -0.13863661751818301, "compression_ratio": 1.5642458100558658, "no_speech_prob": 0.0002958927070721984}, {"id": 425, "seek": 282040, "start": 2820.4, "end": 2830.08, "text": " one that uses instance of, because instance of does consider even subtypes. And if we run this", "tokens": [50364, 472, 300, 4960, 5197, 295, 11, 570, 5197, 295, 775, 1949, 754, 1422, 874, 5190, 13, 400, 498, 321, 1190, 341, 50848], "temperature": 0.0, "avg_logprob": -0.08925549025388108, "compression_ratio": 1.673913043478261, "no_speech_prob": 0.014955414459109306}, {"id": 426, "seek": 282040, "start": 2830.08, "end": 2837.2000000000003, "text": " again, we'll get two truths. So in that case, it's behaving as expected. So unfortunately,", "tokens": [50848, 797, 11, 321, 603, 483, 732, 30079, 13, 407, 294, 300, 1389, 11, 309, 311, 35263, 382, 5176, 13, 407, 7015, 11, 51204], "temperature": 0.0, "avg_logprob": -0.08925549025388108, "compression_ratio": 1.673913043478261, "no_speech_prob": 0.014955414459109306}, {"id": 427, "seek": 282040, "start": 2837.2000000000003, "end": 2843.44, "text": " there's no way getting around this, we should all give up programming. And just quit quit because", "tokens": [51204, 456, 311, 572, 636, 1242, 926, 341, 11, 321, 820, 439, 976, 493, 9410, 13, 400, 445, 10366, 10366, 570, 51516], "temperature": 0.0, "avg_logprob": -0.08925549025388108, "compression_ratio": 1.673913043478261, "no_speech_prob": 0.014955414459109306}, {"id": 428, "seek": 282040, "start": 2843.44, "end": 2849.12, "text": " life is meaningless. Everything is futile. I'm kidding. I'm kidding. I'm kidding. Life is meaningless", "tokens": [51516, 993, 307, 33232, 13, 5471, 307, 1877, 794, 13, 286, 478, 9287, 13, 286, 478, 9287, 13, 286, 478, 9287, 13, 7720, 307, 33232, 51800], "temperature": 0.0, "avg_logprob": -0.08925549025388108, "compression_ratio": 1.673913043478261, "no_speech_prob": 0.014955414459109306}, {"id": 429, "seek": 284912, "start": 2849.12, "end": 2856.16, "text": " and everything is futile. But in true Nietzschean essence, we ought to create our own meaning,", "tokens": [50364, 293, 1203, 307, 1877, 794, 13, 583, 294, 2074, 36583, 89, 12287, 282, 12801, 11, 321, 13416, 281, 1884, 527, 1065, 3620, 11, 50716], "temperature": 0.0, "avg_logprob": -0.13507590574376724, "compression_ratio": 1.5633187772925765, "no_speech_prob": 0.006587933283299208}, {"id": 430, "seek": 284912, "start": 2857.3599999999997, "end": 2863.92, "text": " which is why we're going to use the good old object oriented principle and favor", "tokens": [50776, 597, 307, 983, 321, 434, 516, 281, 764, 264, 665, 1331, 2657, 21841, 8665, 293, 2294, 51104], "temperature": 0.0, "avg_logprob": -0.13507590574376724, "compression_ratio": 1.5633187772925765, "no_speech_prob": 0.006587933283299208}, {"id": 431, "seek": 284912, "start": 2864.72, "end": 2870.56, "text": " composition over inheritance to circumvent this issue with which is inherent to object", "tokens": [51144, 12686, 670, 32122, 281, 7125, 2475, 341, 2734, 365, 597, 307, 26387, 281, 2657, 51436], "temperature": 0.0, "avg_logprob": -0.13507590574376724, "compression_ratio": 1.5633187772925765, "no_speech_prob": 0.006587933283299208}, {"id": 432, "seek": 284912, "start": 2870.56, "end": 2876.72, "text": " oriented languages. So let's take a look at this example, a class color point where we don't do", "tokens": [51436, 21841, 8650, 13, 407, 718, 311, 747, 257, 574, 412, 341, 1365, 11, 257, 1508, 2017, 935, 689, 321, 500, 380, 360, 51744], "temperature": 0.0, "avg_logprob": -0.13507590574376724, "compression_ratio": 1.5633187772925765, "no_speech_prob": 0.006587933283299208}, {"id": 433, "seek": 287672, "start": 2876.72, "end": 2883.7599999999998, "text": " any kind of extension or any kind of inheritance, we're in fact using composition. So in this new", "tokens": [50364, 604, 733, 295, 10320, 420, 604, 733, 295, 32122, 11, 321, 434, 294, 1186, 1228, 12686, 13, 407, 294, 341, 777, 50716], "temperature": 0.0, "avg_logprob": -0.08241584224085655, "compression_ratio": 1.9073170731707316, "no_speech_prob": 0.008060209453105927}, {"id": 434, "seek": 287672, "start": 2883.7599999999998, "end": 2888.56, "text": " color point, which don't get this confused to the one that we use for inheritance, as you can see", "tokens": [50716, 2017, 935, 11, 597, 500, 380, 483, 341, 9019, 281, 264, 472, 300, 321, 764, 337, 32122, 11, 382, 291, 393, 536, 50956], "temperature": 0.0, "avg_logprob": -0.08241584224085655, "compression_ratio": 1.9073170731707316, "no_speech_prob": 0.008060209453105927}, {"id": 435, "seek": 287672, "start": 2888.56, "end": 2894.3199999999997, "text": " from the package, this is in a separate package called composition. But in this new color point that", "tokens": [50956, 490, 264, 7372, 11, 341, 307, 294, 257, 4994, 7372, 1219, 12686, 13, 583, 294, 341, 777, 2017, 935, 300, 51244], "temperature": 0.0, "avg_logprob": -0.08241584224085655, "compression_ratio": 1.9073170731707316, "no_speech_prob": 0.008060209453105927}, {"id": 436, "seek": 287672, "start": 2894.3199999999997, "end": 2903.6, "text": " uses composition, we have a instance of point defined. And we have an instance of color, which", "tokens": [51244, 4960, 12686, 11, 321, 362, 257, 5197, 295, 935, 7642, 13, 400, 321, 362, 364, 5197, 295, 2017, 11, 597, 51708], "temperature": 0.0, "avg_logprob": -0.08241584224085655, "compression_ratio": 1.9073170731707316, "no_speech_prob": 0.008060209453105927}, {"id": 437, "seek": 290360, "start": 2903.6, "end": 2911.2799999999997, "text": " this is a enum, by the way, that holds some some colors. And we have these two instances defined.", "tokens": [50364, 341, 307, 257, 465, 449, 11, 538, 264, 636, 11, 300, 9190, 512, 512, 4577, 13, 400, 321, 362, 613, 732, 14519, 7642, 13, 50748], "temperature": 0.0, "avg_logprob": -0.11959354323570175, "compression_ratio": 1.8181818181818181, "no_speech_prob": 0.0010478160111233592}, {"id": 438, "seek": 290360, "start": 2911.2799999999997, "end": 2918.24, "text": " And then in our constructor, we have a new instance of point being created. And we assign that,", "tokens": [50748, 400, 550, 294, 527, 47479, 11, 321, 362, 257, 777, 5197, 295, 935, 885, 2942, 13, 400, 321, 6269, 300, 11, 51096], "temperature": 0.0, "avg_logprob": -0.11959354323570175, "compression_ratio": 1.8181818181818181, "no_speech_prob": 0.0010478160111233592}, {"id": 439, "seek": 290360, "start": 2918.24, "end": 2923.92, "text": " of course, to the private private field in our class, we do the same thing with color,", "tokens": [51096, 295, 1164, 11, 281, 264, 4551, 4551, 2519, 294, 527, 1508, 11, 321, 360, 264, 912, 551, 365, 2017, 11, 51380], "temperature": 0.0, "avg_logprob": -0.11959354323570175, "compression_ratio": 1.8181818181818181, "no_speech_prob": 0.0010478160111233592}, {"id": 440, "seek": 290360, "start": 2924.64, "end": 2931.36, "text": " new instance. Sorry, in this case, we don't create a new instance of color, we expect the client to", "tokens": [51416, 777, 5197, 13, 4919, 11, 294, 341, 1389, 11, 321, 500, 380, 1884, 257, 777, 5197, 295, 2017, 11, 321, 2066, 264, 6423, 281, 51752], "temperature": 0.0, "avg_logprob": -0.11959354323570175, "compression_ratio": 1.8181818181818181, "no_speech_prob": 0.0010478160111233592}, {"id": 441, "seek": 293136, "start": 2931.36, "end": 2941.6, "text": " pass us a proper object of type color. And then we return the point of this color point, just", "tokens": [50364, 1320, 505, 257, 2296, 2657, 295, 2010, 2017, 13, 400, 550, 321, 2736, 264, 935, 295, 341, 2017, 935, 11, 445, 50876], "temperature": 0.0, "avg_logprob": -0.10366637581273129, "compression_ratio": 1.904040404040404, "no_speech_prob": 0.001866823178716004}, {"id": 442, "seek": 293136, "start": 2941.6, "end": 2946.1600000000003, "text": " this again, what the client expects. And then the equals method, because we is in composition,", "tokens": [50876, 341, 797, 11, 437, 264, 6423, 33280, 13, 400, 550, 264, 6915, 3170, 11, 570, 321, 307, 294, 12686, 11, 51104], "temperature": 0.0, "avg_logprob": -0.10366637581273129, "compression_ratio": 1.904040404040404, "no_speech_prob": 0.001866823178716004}, {"id": 443, "seek": 293136, "start": 2946.1600000000003, "end": 2951.52, "text": " it's not an issue, we just check if it's an instance of color point. And then we do the", "tokens": [51104, 309, 311, 406, 364, 2734, 11, 321, 445, 1520, 498, 309, 311, 364, 5197, 295, 2017, 935, 13, 400, 550, 321, 360, 264, 51372], "temperature": 0.0, "avg_logprob": -0.10366637581273129, "compression_ratio": 1.904040404040404, "no_speech_prob": 0.001866823178716004}, {"id": 444, "seek": 293136, "start": 2951.52, "end": 2956.2400000000002, "text": " casting accordingly, if it is an instance of color point, the object we pass onto the equals method,", "tokens": [51372, 17301, 19717, 11, 498, 309, 307, 364, 5197, 295, 2017, 935, 11, 264, 2657, 321, 1320, 3911, 264, 6915, 3170, 11, 51608], "temperature": 0.0, "avg_logprob": -0.10366637581273129, "compression_ratio": 1.904040404040404, "no_speech_prob": 0.001866823178716004}, {"id": 445, "seek": 295624, "start": 2956.9599999999996, "end": 2962.4799999999996, "text": " then we do a proper comparison, where we do both the comparison between", "tokens": [50400, 550, 321, 360, 257, 2296, 9660, 11, 689, 321, 360, 1293, 264, 9660, 1296, 50676], "temperature": 0.0, "avg_logprob": -0.12650733523898655, "compression_ratio": 1.7747252747252746, "no_speech_prob": 0.004978632554411888}, {"id": 446, "seek": 295624, "start": 2963.68, "end": 2967.12, "text": " between the type point of color point, because this we get from", "tokens": [50736, 1296, 264, 2010, 935, 295, 2017, 935, 11, 570, 341, 321, 483, 490, 50908], "temperature": 0.0, "avg_logprob": -0.12650733523898655, "compression_ratio": 1.7747252747252746, "no_speech_prob": 0.004978632554411888}, {"id": 447, "seek": 295624, "start": 2970.0, "end": 2977.2, "text": " here. And also a comparison between color. So the color has to be true, and the point has to be", "tokens": [51052, 510, 13, 400, 611, 257, 9660, 1296, 2017, 13, 407, 264, 2017, 575, 281, 312, 2074, 11, 293, 264, 935, 575, 281, 312, 51412], "temperature": 0.0, "avg_logprob": -0.12650733523898655, "compression_ratio": 1.7747252747252746, "no_speech_prob": 0.004978632554411888}, {"id": 448, "seek": 295624, "start": 2977.2, "end": 2984.56, "text": " true. And if they both are fulfilled by the double ampersand and operator, it returns true.", "tokens": [51412, 2074, 13, 400, 498, 436, 1293, 366, 21380, 538, 264, 3834, 18648, 433, 474, 293, 12973, 11, 309, 11247, 2074, 13, 51780], "temperature": 0.0, "avg_logprob": -0.12650733523898655, "compression_ratio": 1.7747252747252746, "no_speech_prob": 0.004978632554411888}, {"id": 449, "seek": 298456, "start": 2984.64, "end": 2989.2, "text": " And that solves a problem. So if you look at this test class, for instance, I'm going to run this", "tokens": [50368, 400, 300, 39890, 257, 1154, 13, 407, 498, 291, 574, 412, 341, 1500, 1508, 11, 337, 5197, 11, 286, 478, 516, 281, 1190, 341, 50596], "temperature": 0.0, "avg_logprob": -0.13567940133516906, "compression_ratio": 1.6956521739130435, "no_speech_prob": 0.0034822814632207155}, {"id": 450, "seek": 298456, "start": 2989.2, "end": 2993.68, "text": " test class, I've done something really ugly here. In one file, I've defined two classes,", "tokens": [50596, 1500, 1508, 11, 286, 600, 1096, 746, 534, 12246, 510, 13, 682, 472, 3991, 11, 286, 600, 7642, 732, 5359, 11, 50820], "temperature": 0.0, "avg_logprob": -0.13567940133516906, "compression_ratio": 1.6956521739130435, "no_speech_prob": 0.0034822814632207155}, {"id": 451, "seek": 298456, "start": 2993.68, "end": 2999.84, "text": " you should never do that. In fact, there's one item where Joshua Block talks about that later on.", "tokens": [50820, 291, 820, 1128, 360, 300, 13, 682, 1186, 11, 456, 311, 472, 3174, 689, 24005, 17500, 6686, 466, 300, 1780, 322, 13, 51128], "temperature": 0.0, "avg_logprob": -0.13567940133516906, "compression_ratio": 1.6956521739130435, "no_speech_prob": 0.0034822814632207155}, {"id": 452, "seek": 298456, "start": 3000.56, "end": 3007.84, "text": " It's bad programming etiquette. So in the counterpoint test, again, I've screwed this up,", "tokens": [51164, 467, 311, 1578, 9410, 42177, 3007, 13, 407, 294, 264, 5682, 6053, 1500, 11, 797, 11, 286, 600, 20331, 341, 493, 11, 51528], "temperature": 0.0, "avg_logprob": -0.13567940133516906, "compression_ratio": 1.6956521739130435, "no_speech_prob": 0.0034822814632207155}, {"id": 453, "seek": 298456, "start": 3007.84, "end": 3014.16, "text": " it should be color point test. This is a bit confusing, I apologize. In the color point test,", "tokens": [51528, 309, 820, 312, 2017, 935, 1500, 13, 639, 307, 257, 857, 13181, 11, 286, 12328, 13, 682, 264, 2017, 935, 1500, 11, 51844], "temperature": 0.0, "avg_logprob": -0.13567940133516906, "compression_ratio": 1.6956521739130435, "no_speech_prob": 0.0034822814632207155}, {"id": 454, "seek": 301456, "start": 3014.56, "end": 3020.32, "text": " we've similarly have a hash set that we've created of type point. And then we're doing", "tokens": [50364, 321, 600, 14138, 362, 257, 22019, 992, 300, 321, 600, 2942, 295, 2010, 935, 13, 400, 550, 321, 434, 884, 50652], "temperature": 0.0, "avg_logprob": -0.0981329909893645, "compression_ratio": 1.7683397683397684, "no_speech_prob": 0.0010814935667440295}, {"id": 455, "seek": 301456, "start": 3020.32, "end": 3025.84, "text": " the same thing we did in the previous test, we're checking if the point we pass contains", "tokens": [50652, 264, 912, 551, 321, 630, 294, 264, 3894, 1500, 11, 321, 434, 8568, 498, 264, 935, 321, 1320, 8306, 50928], "temperature": 0.0, "avg_logprob": -0.0981329909893645, "compression_ratio": 1.7683397683397684, "no_speech_prob": 0.0010814935667440295}, {"id": 456, "seek": 301456, "start": 3025.84, "end": 3032.24, "text": " this object P in this hash set. And then if you run this, the difference here though is firstly,", "tokens": [50928, 341, 2657, 430, 294, 341, 22019, 992, 13, 400, 550, 498, 291, 1190, 341, 11, 264, 2649, 510, 1673, 307, 27376, 11, 51248], "temperature": 0.0, "avg_logprob": -0.0981329909893645, "compression_ratio": 1.7683397683397684, "no_speech_prob": 0.0010814935667440295}, {"id": 457, "seek": 301456, "start": 3032.24, "end": 3037.84, "text": " if I run this, you'll see they both print true. That's because we're using composition.", "tokens": [51248, 498, 286, 1190, 341, 11, 291, 603, 536, 436, 1293, 4482, 2074, 13, 663, 311, 570, 321, 434, 1228, 12686, 13, 51528], "temperature": 0.0, "avg_logprob": -0.0981329909893645, "compression_ratio": 1.7683397683397684, "no_speech_prob": 0.0010814935667440295}, {"id": 458, "seek": 301456, "start": 3039.04, "end": 3043.6, "text": " And what it does is though, when we are adding it, when we're adding a new color point, we do use", "tokens": [51588, 400, 437, 309, 775, 307, 1673, 11, 562, 321, 366, 5127, 309, 11, 562, 321, 434, 5127, 257, 777, 2017, 935, 11, 321, 360, 764, 51816], "temperature": 0.0, "avg_logprob": -0.0981329909893645, "compression_ratio": 1.7683397683397684, "no_speech_prob": 0.0010814935667440295}, {"id": 459, "seek": 304360, "start": 3043.6, "end": 3051.8399999999997, "text": " this additional method saying add this, however, as a point though. So that changes things because", "tokens": [50364, 341, 4497, 3170, 1566, 909, 341, 11, 4461, 11, 382, 257, 935, 1673, 13, 407, 300, 2962, 721, 570, 50776], "temperature": 0.0, "avg_logprob": -0.10797452926635742, "compression_ratio": 1.7799043062200957, "no_speech_prob": 0.001648246543481946}, {"id": 460, "seek": 304360, "start": 3051.8399999999997, "end": 3057.2, "text": " now we're saying it's still, we're still adding something of type color point, but we're using", "tokens": [50776, 586, 321, 434, 1566, 309, 311, 920, 11, 321, 434, 920, 5127, 746, 295, 2010, 2017, 935, 11, 457, 321, 434, 1228, 51044], "temperature": 0.0, "avg_logprob": -0.10797452926635742, "compression_ratio": 1.7799043062200957, "no_speech_prob": 0.001648246543481946}, {"id": 461, "seek": 304360, "start": 3057.2, "end": 3063.12, "text": " this method here, which adds as a point. And it returns that point that we've defined here,", "tokens": [51044, 341, 3170, 510, 11, 597, 10860, 382, 257, 935, 13, 400, 309, 11247, 300, 935, 300, 321, 600, 7642, 510, 11, 51340], "temperature": 0.0, "avg_logprob": -0.10797452926635742, "compression_ratio": 1.7799043062200957, "no_speech_prob": 0.001648246543481946}, {"id": 462, "seek": 304360, "start": 3063.7599999999998, "end": 3068.56, "text": " which is what we do in the constructor. And even though we still have this value color", "tokens": [51372, 597, 307, 437, 321, 360, 294, 264, 47479, 13, 400, 754, 1673, 321, 920, 362, 341, 2158, 2017, 51612], "temperature": 0.0, "avg_logprob": -0.10797452926635742, "compression_ratio": 1.7799043062200957, "no_speech_prob": 0.001648246543481946}, {"id": 463, "seek": 306856, "start": 3069.52, "end": 3076.96, "text": " in this private field here, which we can use. So that's how we circumvent the issue.", "tokens": [50412, 294, 341, 4551, 2519, 510, 11, 597, 321, 393, 764, 13, 407, 300, 311, 577, 321, 7125, 2475, 264, 2734, 13, 50784], "temperature": 0.0, "avg_logprob": -0.17783886709330995, "compression_ratio": 1.5622119815668203, "no_speech_prob": 0.0013033899012953043}, {"id": 464, "seek": 306856, "start": 3076.96, "end": 3082.48, "text": " Interestingly, Joshua Bloch states that there has been historical errors where, for instance,", "tokens": [50784, 30564, 11, 24005, 9865, 339, 4368, 300, 456, 575, 668, 8584, 13603, 689, 11, 337, 5197, 11, 51060], "temperature": 0.0, "avg_logprob": -0.17783886709330995, "compression_ratio": 1.5622119815668203, "no_speech_prob": 0.0013033899012953043}, {"id": 465, "seek": 306856, "start": 3082.48, "end": 3089.84, "text": " in the date and the SQL timestamp classes, so in the utilities and the SQL packages,", "tokens": [51060, 294, 264, 4002, 293, 264, 19200, 49108, 1215, 5359, 11, 370, 294, 264, 30482, 293, 264, 19200, 17401, 11, 51428], "temperature": 0.0, "avg_logprob": -0.17783886709330995, "compression_ratio": 1.5622119815668203, "no_speech_prob": 0.0013033899012953043}, {"id": 466, "seek": 306856, "start": 3091.2, "end": 3095.6, "text": " they've made the mistake of use having implementations of the equals method", "tokens": [51496, 436, 600, 1027, 264, 6146, 295, 764, 1419, 4445, 763, 295, 264, 6915, 3170, 51716], "temperature": 0.0, "avg_logprob": -0.17783886709330995, "compression_ratio": 1.5622119815668203, "no_speech_prob": 0.0013033899012953043}, {"id": 467, "seek": 309560, "start": 3096.3199999999997, "end": 3102.96, "text": " that violate symmetry and that this causes erratic behavior. And he says the equals", "tokens": [50400, 300, 37478, 25440, 293, 300, 341, 7700, 1189, 25198, 5223, 13, 400, 415, 1619, 264, 6915, 50732], "temperature": 0.0, "avg_logprob": -0.11252448023581992, "compression_ratio": 1.7813765182186234, "no_speech_prob": 0.019715003669261932}, {"id": 468, "seek": 309560, "start": 3102.96, "end": 3108.16, "text": " implementation for timestamp does violate symmetry and can cause erratic behavior if", "tokens": [50732, 11420, 337, 49108, 1215, 775, 37478, 25440, 293, 393, 3082, 1189, 25198, 5223, 498, 50992], "temperature": 0.0, "avg_logprob": -0.11252448023581992, "compression_ratio": 1.7813765182186234, "no_speech_prob": 0.019715003669261932}, {"id": 469, "seek": 309560, "start": 3108.16, "end": 3114.96, "text": " timestamp and date objects are used in the same collection or otherwise intermixed.", "tokens": [50992, 49108, 1215, 293, 4002, 6565, 366, 1143, 294, 264, 912, 5765, 420, 5911, 728, 76, 40303, 13, 51332], "temperature": 0.0, "avg_logprob": -0.11252448023581992, "compression_ratio": 1.7813765182186234, "no_speech_prob": 0.019715003669261932}, {"id": 470, "seek": 309560, "start": 3114.96, "end": 3119.7599999999998, "text": " This behavior of the timestamp class was a mistake and should not be emulated. So again,", "tokens": [51332, 639, 5223, 295, 264, 49108, 1215, 1508, 390, 257, 6146, 293, 820, 406, 312, 846, 6987, 13, 407, 797, 11, 51572], "temperature": 0.0, "avg_logprob": -0.11252448023581992, "compression_ratio": 1.7813765182186234, "no_speech_prob": 0.019715003669261932}, {"id": 471, "seek": 309560, "start": 3119.7599999999998, "end": 3125.2799999999997, "text": " it's because of the inherent drawback in object oriented languages, these kind of mistakes happen.", "tokens": [51572, 309, 311, 570, 295, 264, 26387, 2642, 3207, 294, 2657, 21841, 8650, 11, 613, 733, 295, 8038, 1051, 13, 51848], "temperature": 0.0, "avg_logprob": -0.11252448023581992, "compression_ratio": 1.7813765182186234, "no_speech_prob": 0.019715003669261932}, {"id": 472, "seek": 312528, "start": 3125.28, "end": 3134.0, "text": " However, in many circumstances, using composition over inheritance, the way we", "tokens": [50364, 2908, 11, 294, 867, 9121, 11, 1228, 12686, 670, 32122, 11, 264, 636, 321, 50800], "temperature": 0.0, "avg_logprob": -0.12379886485912182, "compression_ratio": 1.7587939698492463, "no_speech_prob": 0.0006262078532017767}, {"id": 473, "seek": 312528, "start": 3134.0, "end": 3138.88, "text": " showed in the composition-paste color point class is a way of getting around that.", "tokens": [50800, 4712, 294, 264, 12686, 12, 79, 9079, 2017, 935, 1508, 307, 257, 636, 295, 1242, 926, 300, 13, 51044], "temperature": 0.0, "avg_logprob": -0.12379886485912182, "compression_ratio": 1.7587939698492463, "no_speech_prob": 0.0006262078532017767}, {"id": 474, "seek": 312528, "start": 3140.0, "end": 3146.5600000000004, "text": " And then we get to the interesting idea or the interesting notion of using an abstract class", "tokens": [51100, 400, 550, 321, 483, 281, 264, 1880, 1558, 420, 264, 1880, 10710, 295, 1228, 364, 12649, 1508, 51428], "temperature": 0.0, "avg_logprob": -0.12379886485912182, "compression_ratio": 1.7587939698492463, "no_speech_prob": 0.0006262078532017767}, {"id": 475, "seek": 312528, "start": 3146.5600000000004, "end": 3152.2400000000002, "text": " instead of a superclass. And simply, the reason we can add value components to a subclass of an", "tokens": [51428, 2602, 295, 257, 1687, 11665, 13, 400, 2935, 11, 264, 1778, 321, 393, 909, 2158, 6677, 281, 257, 1422, 11665, 295, 364, 51712], "temperature": 0.0, "avg_logprob": -0.12379886485912182, "compression_ratio": 1.7587939698492463, "no_speech_prob": 0.0006262078532017767}, {"id": 476, "seek": 315224, "start": 3152.24, "end": 3157.3599999999997, "text": " abstract class is that you can't instantiate an abstract class. So that really solves a lot of", "tokens": [50364, 12649, 1508, 307, 300, 291, 393, 380, 9836, 13024, 364, 12649, 1508, 13, 407, 300, 534, 39890, 257, 688, 295, 50620], "temperature": 0.0, "avg_logprob": -0.10083635993625807, "compression_ratio": 1.8019323671497585, "no_speech_prob": 0.003824068931862712}, {"id": 477, "seek": 315224, "start": 3157.3599999999997, "end": 3164.72, "text": " the problems we have with using the concrete point superclass. So in this case, we have an", "tokens": [50620, 264, 2740, 321, 362, 365, 1228, 264, 9859, 935, 1687, 11665, 13, 407, 294, 341, 1389, 11, 321, 362, 364, 50988], "temperature": 0.0, "avg_logprob": -0.10083635993625807, "compression_ratio": 1.8019323671497585, "no_speech_prob": 0.003824068931862712}, {"id": 478, "seek": 315224, "start": 3164.72, "end": 3170.08, "text": " abstract class shape, which has two protected values, so x and y, and we have a constructor,", "tokens": [50988, 12649, 1508, 3909, 11, 597, 575, 732, 10594, 4190, 11, 370, 2031, 293, 288, 11, 293, 321, 362, 257, 47479, 11, 51256], "temperature": 0.0, "avg_logprob": -0.10083635993625807, "compression_ratio": 1.8019323671497585, "no_speech_prob": 0.003824068931862712}, {"id": 479, "seek": 315224, "start": 3170.08, "end": 3179.12, "text": " and then we have two concrete subclasses that extend the shape class. And we've got circle and", "tokens": [51256, 293, 550, 321, 362, 732, 9859, 1422, 11665, 279, 300, 10101, 264, 3909, 1508, 13, 400, 321, 600, 658, 6329, 293, 51708], "temperature": 0.0, "avg_logprob": -0.10083635993625807, "compression_ratio": 1.8019323671497585, "no_speech_prob": 0.003824068931862712}, {"id": 480, "seek": 317912, "start": 3180.08, "end": 3187.2, "text": " rectangle, where's the other one? Yeah, circle and rectangle, where in the circle one, we are", "tokens": [50412, 21930, 11, 689, 311, 264, 661, 472, 30, 865, 11, 6329, 293, 21930, 11, 689, 294, 264, 6329, 472, 11, 321, 366, 50768], "temperature": 0.0, "avg_logprob": -0.13618930526401685, "compression_ratio": 1.8229665071770336, "no_speech_prob": 0.0015245029935613275}, {"id": 481, "seek": 317912, "start": 3187.2, "end": 3194.16, "text": " adding a radius, and in the rectangle one, we are adding length and width. And in the constructor,", "tokens": [50768, 5127, 257, 15845, 11, 293, 294, 264, 21930, 472, 11, 321, 366, 5127, 4641, 293, 11402, 13, 400, 294, 264, 47479, 11, 51116], "temperature": 0.0, "avg_logprob": -0.13618930526401685, "compression_ratio": 1.8229665071770336, "no_speech_prob": 0.0015245029935613275}, {"id": 482, "seek": 317912, "start": 3194.16, "end": 3200.88, "text": " of course, we are invoking the constructor of the superclass, which is shape. The issue is", "tokens": [51116, 295, 1164, 11, 321, 366, 1048, 5953, 264, 47479, 295, 264, 1687, 11665, 11, 597, 307, 3909, 13, 440, 2734, 307, 51452], "temperature": 0.0, "avg_logprob": -0.13618930526401685, "compression_ratio": 1.8229665071770336, "no_speech_prob": 0.0015245029935613275}, {"id": 483, "seek": 317912, "start": 3200.88, "end": 3206.4, "text": " quite straightforward. We can create a concrete object of this concrete class rectangle. However,", "tokens": [51452, 1596, 15325, 13, 492, 393, 1884, 257, 9859, 2657, 295, 341, 9859, 1508, 21930, 13, 2908, 11, 51728], "temperature": 0.0, "avg_logprob": -0.13618930526401685, "compression_ratio": 1.8229665071770336, "no_speech_prob": 0.0015245029935613275}, {"id": 484, "seek": 320640, "start": 3206.4, "end": 3214.2400000000002, "text": " if you try to, that's a typo, try to instantiate the shape class, it says you get a compile time", "tokens": [50364, 498, 291, 853, 281, 11, 300, 311, 257, 2125, 78, 11, 853, 281, 9836, 13024, 264, 3909, 1508, 11, 309, 1619, 291, 483, 257, 31413, 565, 50756], "temperature": 0.0, "avg_logprob": -0.12075024044390806, "compression_ratio": 1.787037037037037, "no_speech_prob": 0.006192303728312254}, {"id": 485, "seek": 320640, "start": 3214.2400000000002, "end": 3220.88, "text": " error, say you can't instantiate abstract shape classes, which is why this is a way to get around", "tokens": [50756, 6713, 11, 584, 291, 393, 380, 9836, 13024, 12649, 3909, 5359, 11, 597, 307, 983, 341, 307, 257, 636, 281, 483, 926, 51088], "temperature": 0.0, "avg_logprob": -0.12075024044390806, "compression_ratio": 1.787037037037037, "no_speech_prob": 0.006192303728312254}, {"id": 486, "seek": 320640, "start": 3220.88, "end": 3229.52, "text": " this issue, where Joshua Bloch states, when adding a value component, note that you can add a value", "tokens": [51088, 341, 2734, 11, 689, 24005, 9865, 339, 4368, 11, 562, 5127, 257, 2158, 6542, 11, 3637, 300, 291, 393, 909, 257, 2158, 51520], "temperature": 0.0, "avg_logprob": -0.12075024044390806, "compression_ratio": 1.787037037037037, "no_speech_prob": 0.006192303728312254}, {"id": 487, "seek": 320640, "start": 3229.52, "end": 3235.44, "text": " component to a subclass of an abstract class without violating the equals contract. This is", "tokens": [51520, 6542, 281, 257, 1422, 11665, 295, 364, 12649, 1508, 1553, 42201, 264, 6915, 4364, 13, 639, 307, 51816], "temperature": 0.0, "avg_logprob": -0.12075024044390806, "compression_ratio": 1.787037037037037, "no_speech_prob": 0.006192303728312254}, {"id": 488, "seek": 323544, "start": 3235.44, "end": 3241.84, "text": " important for this sort of class hierarchies that you get by following the advice in item 23,", "tokens": [50364, 1021, 337, 341, 1333, 295, 1508, 35250, 530, 300, 291, 483, 538, 3480, 264, 5192, 294, 3174, 6673, 11, 50684], "temperature": 0.0, "avg_logprob": -0.09260486105213994, "compression_ratio": 1.756554307116105, "no_speech_prob": 0.0053841546177864075}, {"id": 489, "seek": 323544, "start": 3241.84, "end": 3247.28, "text": " preferred class hierarchies to tack classes. I'm not going to go into too much detail on that,", "tokens": [50684, 16494, 1508, 35250, 530, 281, 9426, 5359, 13, 286, 478, 406, 516, 281, 352, 666, 886, 709, 2607, 322, 300, 11, 50956], "temperature": 0.0, "avg_logprob": -0.09260486105213994, "compression_ratio": 1.756554307116105, "no_speech_prob": 0.0053841546177864075}, {"id": 490, "seek": 323544, "start": 3247.28, "end": 3252.7200000000003, "text": " because we're going to be covering item 23 next year. And then he says, for example,", "tokens": [50956, 570, 321, 434, 516, 281, 312, 10322, 3174, 6673, 958, 1064, 13, 400, 550, 415, 1619, 11, 337, 1365, 11, 51228], "temperature": 0.0, "avg_logprob": -0.09260486105213994, "compression_ratio": 1.756554307116105, "no_speech_prob": 0.0053841546177864075}, {"id": 491, "seek": 323544, "start": 3252.7200000000003, "end": 3256.8, "text": " he could have an abstract class, so what I pretty much described here, I'll just read it out again.", "tokens": [51228, 415, 727, 362, 364, 12649, 1508, 11, 370, 437, 286, 1238, 709, 7619, 510, 11, 286, 603, 445, 1401, 309, 484, 797, 13, 51432], "temperature": 0.0, "avg_logprob": -0.09260486105213994, "compression_ratio": 1.756554307116105, "no_speech_prob": 0.0053841546177864075}, {"id": 492, "seek": 323544, "start": 3256.8, "end": 3262.7200000000003, "text": " For example, he could have an abstract class shape with no value components, a subclass circle,", "tokens": [51432, 1171, 1365, 11, 415, 727, 362, 364, 12649, 1508, 3909, 365, 572, 2158, 6677, 11, 257, 1422, 11665, 6329, 11, 51728], "temperature": 0.0, "avg_logprob": -0.09260486105213994, "compression_ratio": 1.756554307116105, "no_speech_prob": 0.0053841546177864075}, {"id": 493, "seek": 326272, "start": 3262.72, "end": 3270.08, "text": " that adds a radius field and a subclass rectangle that adds a length and width fields.", "tokens": [50364, 300, 10860, 257, 15845, 2519, 293, 257, 1422, 11665, 21930, 300, 10860, 257, 4641, 293, 11402, 7909, 13, 50732], "temperature": 0.0, "avg_logprob": -0.12345270677046342, "compression_ratio": 1.5454545454545454, "no_speech_prob": 0.0015485482290387154}, {"id": 494, "seek": 326272, "start": 3271.2, "end": 3278.0, "text": " Problem of the sort shown earlier won't occur so long as it is impossible to create a super", "tokens": [50788, 11676, 295, 264, 1333, 4898, 3071, 1582, 380, 5160, 370, 938, 382, 309, 307, 6243, 281, 1884, 257, 1687, 51128], "temperature": 0.0, "avg_logprob": -0.12345270677046342, "compression_ratio": 1.5454545454545454, "no_speech_prob": 0.0015485482290387154}, {"id": 495, "seek": 326272, "start": 3278.0, "end": 3286.7999999999997, "text": " class instance directly. That's it. That is the property of transitivity as to how we try and", "tokens": [51128, 1508, 5197, 3838, 13, 663, 311, 309, 13, 663, 307, 264, 4707, 295, 17976, 4253, 382, 281, 577, 321, 853, 293, 51568], "temperature": 0.0, "avg_logprob": -0.12345270677046342, "compression_ratio": 1.5454545454545454, "no_speech_prob": 0.0015485482290387154}, {"id": 496, "seek": 328680, "start": 3286.8, "end": 3293.52, "text": " follow it to ensure that we follow the, or we abide by the general contract of the equals method,", "tokens": [50364, 1524, 309, 281, 5586, 300, 321, 1524, 264, 11, 420, 321, 39663, 538, 264, 2674, 4364, 295, 264, 6915, 3170, 11, 50700], "temperature": 0.0, "avg_logprob": -0.1352099859586326, "compression_ratio": 1.578512396694215, "no_speech_prob": 0.03459501639008522}, {"id": 497, "seek": 328680, "start": 3294.1600000000003, "end": 3302.32, "text": " and even discussing the inherent problems with OP languages. But saying that, there are also two", "tokens": [50732, 293, 754, 10850, 264, 26387, 2740, 365, 23324, 8650, 13, 583, 1566, 300, 11, 456, 366, 611, 732, 51140], "temperature": 0.0, "avg_logprob": -0.1352099859586326, "compression_ratio": 1.578512396694215, "no_speech_prob": 0.03459501639008522}, {"id": 498, "seek": 328680, "start": 3302.32, "end": 3310.0800000000004, "text": " other properties that we need to follow, which is consistency and non-nullity. There are a lot", "tokens": [51140, 661, 7221, 300, 321, 643, 281, 1524, 11, 597, 307, 14416, 293, 2107, 12, 77, 858, 507, 13, 821, 366, 257, 688, 51528], "temperature": 0.0, "avg_logprob": -0.1352099859586326, "compression_ratio": 1.578512396694215, "no_speech_prob": 0.03459501639008522}, {"id": 499, "seek": 328680, "start": 3310.0800000000004, "end": 3314.96, "text": " more shorter than this one, but I'm quite tired. So we're going to cover that in part three.", "tokens": [51528, 544, 11639, 813, 341, 472, 11, 457, 286, 478, 1596, 5868, 13, 407, 321, 434, 516, 281, 2060, 300, 294, 644, 1045, 13, 51772], "temperature": 0.0, "avg_logprob": -0.1352099859586326, "compression_ratio": 1.578512396694215, "no_speech_prob": 0.03459501639008522}, {"id": 500, "seek": 331680, "start": 3316.8, "end": 3323.92, "text": " But I hope this made sense. I was from my best to get this across. I found this quite interesting,", "tokens": [50364, 583, 286, 1454, 341, 1027, 2020, 13, 286, 390, 490, 452, 1151, 281, 483, 341, 2108, 13, 286, 1352, 341, 1596, 1880, 11, 50720], "temperature": 0.0, "avg_logprob": -0.19404931501908737, "compression_ratio": 1.4764705882352942, "no_speech_prob": 0.005383583251386881}, {"id": 501, "seek": 331680, "start": 3323.92, "end": 3330.5600000000004, "text": " though. I really enjoyed this transitivity bit. So I shall see you in the next one.", "tokens": [50720, 1673, 13, 286, 534, 4626, 341, 17976, 4253, 857, 13, 407, 286, 4393, 536, 291, 294, 264, 958, 472, 13, 51052], "temperature": 0.0, "avg_logprob": -0.19404931501908737, "compression_ratio": 1.4764705882352942, "no_speech_prob": 0.005383583251386881}, {"id": 502, "seek": 331680, "start": 3330.5600000000004, "end": 3334.4, "text": " Thanks for watching, and I hope you gain some value from it. Cheers.", "tokens": [51052, 2561, 337, 1976, 11, 293, 286, 1454, 291, 6052, 512, 2158, 490, 309, 13, 13006, 13, 51244], "temperature": 0.0, "avg_logprob": -0.19404931501908737, "compression_ratio": 1.4764705882352942, "no_speech_prob": 0.005383583251386881}], "language": "en"}