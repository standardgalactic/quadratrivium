Hey everyone, welcome to yet another episode of this video series on Joshua Bloch's effective Java
where I try and expound and make sense of the items that he has
Animirated in this book and without further ado
Let's get started with the introduction because I sort of anticipate that this item in particular
It's gonna be a lone one because there are a lot of I'd say ancillary points that we need to discuss to
make sense of the crux of this item and the argument that
Joshua Bloch is putting forward
So as per usual, I'm gonna go through the same introduction that I go through in every single
Video in the series
So if you've been following along, please do skip this bit to save your time the proviso goes like this
Which I'm kind of sick of repeating but I feel like I kind of have to repeat it
For let's say due diligence. So just to be ethical about this whole thing
This is not a tutorial. I certainly am not a teacher. No, I'm an expert
So, you know, take what I say with the grain of salt
Don't think of this as any other tutorial on YouTube where what I say is in some sense
Gospel's truth. I don't think every single tutorial on YouTube is like that
But there are some tutorials where certainly, you know, they could quality they come from an expert in the field
And you can trust what they're saying. Don't trust what I say. I'm pretty sure I'm gonna push a lot of things in this item and
in some sense, hopefully try my best to do it as accurately as possible not spilling the bullshit, but
Getting to the points in the item. There certainly are gonna be
Unintentional mistakes that I make. I'd like to think of this as the blind leading the blind
I am as blind as you are perhaps even more
This is merely or not merely. This is a
Exploratory disposition. I'm trying to make sense of this collectively
You know using different forums like Stack Overflow whenever I come across something that I don't understand
I'd post a question on Stack Overflow and I'd really appreciate it if
You know, if I do make any mistakes, which I think I inevitably will
Please point them out in the comment section down below
Not just for my sake, but even for other people that are watching these videos. I really don't want to mislead people in any way
and given that this is a
Programming video series. It only makes sense to have all the code that I use on get up publicly available
I'll leave a link down below not just to my get up account, but also just your blocks sort of official
Public repository that is published and put put out all the code used in the book
And saying all that let's get started on item number seven
Which states eliminate obsolete object references?
And this again is from chapter two creating and destroying objects
So something I've been trying to do in these videos is before we even get to the content of the item to try and
expand on and try to understand
Basically what the words used in the title itself is itself are
so
object references what in the world are object references this diagram or this
image pretty much puts it quite simply and
Object reference is merely a pointer or not merely. It's probably good to conceptualize it as a pointer
So we have objects in the heap memory. So the memory is subdivided into
Different segments by the JVM. There's a heap. There's a stack
and
Generally leaving aside the stack of the heap what a object references is a a
Memory address the pointer points to a memory address of a particular object in the heap and adding on to that in this image
If we take something like an object array, let's say
An array itself is a reference to a another object
what I mean by that is an
array can exist in the heap and
There's a pointer or a memory address that points to that array, but the items in the array itself are
Pointing to other objects within the heap. So in some sense, you can I guess think of it this way the way they've shown in this diagram where
The array contains references itself and it could also contain it out. So if you're not out an array
Which we're gonna see some nulling out in this item, then it's not gonna point to anything
So in Java what happens when we use the new keyword is we reserve a location in memory
When we instantiate a class the constructor of that class and all classes have a constructor
Creates a reference to an object and the reference I said it's like a pointer
But another way of thinking about it is that it's information regarding the location of the object in memory
So what we see here is an example of that where they're creating this
object array a primitive array and
where
instantiating it
In this case with a primitive type. So just repeating the point items seven states again
eliminate obsolete object references
so
Unlike a language like let's say C++
Java this automatic garbage collection. What is garbage collection? It's simply put memory management when we do allocate resources to a certain object
We make sure that once that object is no longer in use we clear it out
We we let that memory go to free out resources so that that resource can be something else and there are different
Algorithms used in garbage collection. In fact, I'll leave some links down below on some videos by
Gaurav Sen, I believe I think it's his son name, but I you know
He does the system design videos on YouTube really good superlative content and he does do a bit of
Explaining of how these algorithms work
specifically Apple Pro JVM
so
Of course because Java this automatic garbage collection as I said unlike a language like C++
We could make the wrong assumption when I mean we I mean a programmer could make the wrong assumption
That we don't have to think about memory management at all. And that's why in the beginning of this item
Joshua Block states
When it comes to garbage collection, it seems almost like magic when you first experience it and
Therefore it can easily lead to the impression that you don't have to think about memory management
But this isn't quite true. I had to take off my cardigan because it was getting really hot in this room
Summer's coming in Melbourne. Yay
So he keeps going consider the following simple stack implementation
I've got the stack implementation right here
However, before we get to the code and do a deep dive
I cut out again. We want to backtrack a bit and discuss some of the terms. So
We discussed what
Object references are and then I want to discuss
What's a obsolete reference an obsolete reference is a reference that will not be
De-referenced again. It's
unintentionally retaining an object now this term here
De-referencing or dereferenced again, this can be quite confusing because dereference does not mean that you
Get rid of the reference not at all. What?
dereferencing in fact means is
when we do refer to an object
In our code somewhere down the line once we do create the reference we may refer to it again
We may get the value that the reference is pointing to that process is called
De-referencing and if we don't de-reference an object, there's no use of keeping an object in memory
So we are unintentionally just leaving an object there
allocating resources making
Application inefficient that that shouldn't be done. So the solution is quite simple. In fact, it's simply to now
references once they become obsolete and we sometimes have to do this explicitly on our code despite
Java doing memory management or garbage collection
So to have a bit of a more formal and clear definition by my favorite Java programming website by all done
De-referencing means the action of accessing an object's features through a reference
And one way to prevent obsolete object references is by narrow scoping and what's narrow scoping?
That's something what you would see in a for loop in a for loop. We have the int you declared int i for instance
That variable is within the scope of that for loop. So narrow scoping. That's an example another example would be
trying not to declare global variables in a class rather
declare variables within a function within a method and keep it localized to that specific method and
That helps with eliminating
obsolete object references because we sort of know what the scope of a variable is in our code base and then in the item
He keeps going and this is the code base for the stack class
And then he asks can you spot the memory leak saying that before we get to the item and try and visualize
What the memory leak is?
Let's take a look at the code base and the code base of this
Stack implementation a really simple stack implementation that just your block has used here as an example to
Illustrate his point. So I'm pretty much going to go through this code line by line despite it being a bit long
Because I think that's the best way to understand this. We have a
Simple class called stack. We have a object array of elements and another
Private of the object array is also private but also another private
Variable called size of primitive type integer of int. Sorry and then this
constant here is what
initially defines the
Initial stack capacity
So when the stack class is instantiated, of course the constructors called
And in the client over here
I am instantiating the class
line number 57
so
When the constructor is called a new
Object array is initialized. So this
array we defined here
elements
that this this new object is passed to that variable and when the
New object array is initialized. It's default capacity. Yes. I've made a mistake here. It's not 26 at 16
And that's assigned to the variable elements. So this variable in line number 10 will hold a
I'm pointing to the code as if you can see where I'm pointing at. That's so funny
Anyway, this object array will hold a reference or elements will hold a reference to this new object
That was created and that's in the heap and then we have a method called push
and what that does is as you'd expect from a stack you can push new elements on new objects onto the
Stack or in this case the elements array, but but in that method we have another
method that we call call ensure capacity
ensure capacity just ensures that
There's space for at least one more element roughly and if not, it'll just double the capacity each time the
Areas to grow because we want the stack to be dynamic
you can see here it's creating a copy of elements and passing it to elements and
The more we keep adding on to the stack the more the area grows so doubles in size
Let's say now we get to the point this pop method is what's pertinent to our item and where we see
Memory leak take place. So we have this
Object method. Sorry, we have this pop method
And we don't here in this method garbage collection doesn't take place and that's why we need to be aware of that
So firstly if the size is equal to zero, which is going to throw an empty stack exception
And we can't add something to an empty stack and here we see
that when we pop the
object of the
Array or when we return the object that's in the array
Where we reduce the size with this counter. So this was the variable we declared here in line number
11 and when we reduce that. Oh, sorry. I didn't I didn't say that in fact in the push
Method whenever we push a new item onto the array. We also increase the count on that variable
And when we pop it we reduce it kind of makes sense. Well, what happens here though is
Whenever we pop an object from the stack or when we take an object out from this array
An object is still
unintentionally retained here despite the client of this class having no use of those objects and
That's where the memory leak takes place and the proper way to do this and again this bit of code here line number 20 to 33
I will illustrate that in this diagram more visually. It'll make a lot more sense. Whoops. That was a mistake
Getting back to this
But this is not the right way to do it because what's happening here is a memory leak
The proper way to do it would be like this
I'm gonna comment out the wrong way
It would still be where we are checking if the
Stack is empty the stack can't be empty and then we are in fact
Assigning this value onto a new
Variable we're gonna create called result. So whatever the elements array returns after we reduce the size
We're gonna assign that value to result and then
simply we null out that location on the array and that's where the elimination of
The obsolete reference takes place and we return the result afterwards
So we assign it to result and return the result will be ensure that that
Element on the in the array that index
That we return that it's not out because when it's not out what happens is something like what we see here
It's clear that it's not obsolete that it's not pointing at something and taking up memory resources
And really if you run this code there really isn't a use in running the code
But this is kind of what you'd see. I can just print out the
Array or the stack in this case
This you can ignore this empty stack exception. The reason for that is because we are pretty much
pushing
Everything into the stack and then popping everything off the stack and then you would at one point as we go through it
expect this
Exception to be thrown here, which is wait, I just missed it
Right here because what happens is we keep popping the stack at one point the stack gets empty
So this is kind of expected this error here
So now before I read out what Joshua book has explained here, let's take a look at this diagram and visualize it
So here we have that elements array that I spoke about before so that's the array
Right here, but the object array that we define. That's what I've illustrated or represented here
And we let's say the objects
Of our integers and we're adding
One two three four five six, I don't know why I put a zero in front
Let's just think of it as one two three four five six
And then this is being added by the push method here
But then for some reason we also pop some of it and we pop three items from the
Array now what happens here is if you don't null out the references the way we've done here
These things are still gonna exist in the array. However for the purpose of the stack class
The client will never use these elements these these objects. They'll just exist in memory making them obsolete and
more importantly
Making it a memory leak because it's taking up
Resources that could be used for something else and that's the problem here
If you don't know that out
So the right way to do it is to treat this array in this way where the way we've done it in the proper pop method
every time we return
Whatever is in the index of this array
We also ensure that it's not out in that way that reference is eliminated. Sorry the obviously reference is eliminated
I hope that makes sense. I'm repeating the same point, but you know repetition is important to
Make sense of this and on the note of repeating. I'm going to read out what Joshua Bloch has said about this particular class in the book
He goes like this
There's nothing obviously wrong with this program
You could test it exhaustively and it would pass every test with flying colors
But there's a problem lurking. Ooh
Indeed indeed loosely speaking the program has a memory leak
Which can silently manifest as reduced performance due to the
increased garbage collectivity or increased memory footprint
Footprint what kind of process would um, yeah, so
That's that the increased memory footprint is what I explained here
That these three, uh, let's say for this example these three indexes create taking up space in the heap
He keeps going if a stack grows and then shrinks
The objects that were popped off the stack will not be garbage collected
Even if the program using the stack has no more references to them
So that is what we saw in the other method the
When it's wrong
The way it shouldn't be done. There's nothing out here
This is because the stack maintains obsolete references to these objects
An obsolete reference is simply a reference that will never be dereferenced again
So never be used by the program again
In this case any references outside of the active potion of the element array are obsolete
It's important to understand what he means by the active potion the active potion really is the
The potion of the array that the client would care about or use the client of this class
So in this example, the active portion really is index zero one and two
Not this but here, which is why they should be not out the active portion consists of the elements whose index is less than size
Yes, so this size here
Is what holds the size of the stack and then he sort of concludes that point by stating
memory leaks in garbage collected languages like java more properly known as
unintentional object retentions iron citys
If an object reference is unintentionally retained
Not only is that object excluded from garbage collection
But so too are any objects
Reference by that object and so on it's an interesting point there because I've had a conversation with a c++
engineer or developer
In my company and he kind of made the point, you know, that's kind of the trade-off we make in programming
the more we sort of
Give control to the virtual machine in this case the jvm the less we know what's going on
kind of
Um behind the scenes under the hood
Uh, the the more abstractions on abstractions we build the less of an understanding we have as to what's going on in our program
Uh, which is why for instance when it comes to using packages
Uh, sometimes it can be dangerous and to use Joshua block's term insidious
Because we don't have a really good power or deep understanding of what's happening. Let's say at a memory management level
so as a good programmer, it's
I guess it's it's
It's important to be kind of prudent and careful about that and and be judicious as to how we write our code
Anyway, before I get carried away, uh, philosophizing about programming
Let's get back to the point here, uh, and the item he states then the fix for this sort of problem is simple
Null out references once they become obsolete. That's what I've shown here. I already showed the solution
In the code itself an added benefit of nulling out obsolete references is that if they are
Subsequently dereference by mistake the program will immediately fail with the null point exception
Rather than quietly doing the wrong thing
It is always beneficial to detect programming errors as quickly as possible
Now, I don't know how in this class someone could dereference
parts of this array that
Theoretically should not be accessed in the stack class, but it's possible if that area was public. Let's say by mistake
and
theoretic it would be a theoretical mistake if
after the size of the
Stack changes, let's say the size of the stack was three and we only had zero
One two and three
And we still get access to the client to uh four and five that would be a mistake
But when we now that out
The error is explicit and clear because the program will throw a null point exception
But interestingly then he also makes the provision that nulling out object references should be the exception
Rather than the norm
so
Technically this thing what you've done here
Shouldn't always be done. There are better ways to handle this or eliminate
obsolete references than just nulling out elements in this area. Let's say in this example
The best way to eliminate an obsolete reference is to let the variable
That contain the reference fall out of scope
This occurs naturally if you define each variable in the
narrowest possible scope and this is kind of what I meant by uh
Narrow scoping is one way that allows
Eliminating obsolete of references and I did explain what narrow scoping is it's ensuring that when we define a variable and we declare a variable
It's in the
Narrowest possible scope in our source code
But if he says nulling out shouldn't be the norm why in this example is given in the stack class
Why are we nulling out uh these references? Why not use narrow scoping as he suggested which he says should be the norm
To put it simply he says it's because the stack class manages its own memory. We see that here
We see that as to what's what's what's going on here
Where we're managing the memory I propose this array here
The storage pool consists of the elements of of the elements array
That's a bit a bit confusing. I know but the elements inside this array. So each
uh
Individual element which he's added here are the object references not the objects themselves. So these are references themselves
And then the elements in the active portion of the array as defined earlier are allocated
And those in the remainder of the array are free
So that's the active portion. That's allocated and these are made free
The garbage collector has no way of knowing this to the garbage collector
All of the object references in the element elements array are equally valid correct because the garbage collector doesn't know
What the purpose of this stack class is the garbage collector isn't that intelligent
Hopefully in the future it would be only the programmer or get up co-pilot perhaps
Knows that the inactive portion of the array is unimportant
The programmer effectively communicates this fact to the garbage collector by manually
Nulling out array elements as soon as they become part of the inactive portion. That's correct. That's what we've done here
And then just to conclude that point joshua block states
Generally speaking
Whenever a class manages its own memory the programmer should be alert for memory leaks
So what are the examples can we think of when it comes to memory leaks?
apropos java and jvm
Another example that he's given here is memory leaks that we would see and sorry. I shouldn't say apropos java and jvm
This is just commonly in programming in let's say op programming in general
These examples he's laid out or laid down
could lead to potential memory leaks
And the first one is given is in caches. It's quite common to see memory leaks in caches because of course what happens a lot in a cache is we
Cache data and when we do cache data we cache objects
There's a high possibility if we don't do it in a smart port art way that it can it can lead to
Obsolete object references because once an object reference is put in a cache
It can be left there long after it stops being relevant
Toss being obsolete and the solution for this problem of memory leaks and caches that
Joshua blocker suggests it is using weak hash maps
And when I said in the beginning of the item that there are some ancillary points some concepts
We need to understand to really get to the crux of this item
This is what I meant. I've never used a weak hash map in my life
Therefore I had to do a bit of reading and styling as to what weak hash maps are
So just a block states before I get to what a weak hash map is and before I go through the code
Which I've got here. I've got a weak hash map demo
Joshua block states if you're lucky enough to implement a cache for which an entry is relevant
Exactly so long as there are references to its key key outside of the cache
Represent the cache as a weak hash map
Entries will be removed automatically after they become obsolete
So conceptually that sort of makes sense, doesn't it because the reason we have a cache is to
for quick access of data of objects and
The key in a cache we we got to make sure that whatever data that's in the cache that the keys are
relevant outside of
The data structure in the cache in this case. It could be a hash map
So that ensures that we don't have obsolete object references and he keeps going that remember that
Weak hash map is useful
Only if the desired lifetime of cache entries is determined by external references to the key not the valley
Okay, now let's understand what a weak hash map is
Firstly before we get to the code, let's get through some definitions. It's important to get a firstly a theoretical understanding
a conceptual understanding of what this is
Uh, and one of the best definitions as for you sure that I found is by about dunks blog
It's this blog now that's on profile is it's this blog post here a guide to weak hash map in java
And he states
Simply put the weak hash map is a hash table based implementation of the map interface with keys that are of a
Weak reference type and now we have another term here. What are weak references for that will open up
The best explanation that I found is this stackover flow answer
Uh, and in fact, this user says that it's by ether necklace
But the name of this user is michael myers
And a weak reference simply put is a reference that isn't strong enough to force an object to remain in memory
weak references allow you to leverage the garbage collectors ability to determine the reach ability for you
So you don't have to do it yourself
But also in this article by bio dung. He's given some pretty good definitions where he
Decerns between strong soft and weak references. So a strong reference is what would normally be when we
Declare a variable like this. Let's say that's a strong reference
And this is the most common type and it's not eligible for garbage collection
A soft reference is eligible for garbage collection, but only when
Uh, the jvm needs more memory. It absolutely needs more memory. And in fact, he's made that point here
It's it's kind of like a last resort kind of thing
But a weak reference is not that a weak reference doesn't the garbage collector is given volition
Where it can so eagerly garbage collect it won't wait until it needs more memory. It'll just
Use it up if required and that's where
Using a weak reference in the context of a cache helps us to eliminate
obsolete object references
So in any case, that's another definition of a weak reference. There's also this article
That I read which is quite good. I think it gave a pretty good practical and sort of applicative explanation of what
Well, the title of the article is practical uses of weak references by this user
philosophical geek or I guess Ben Watson
I'll leave a link to this down below too where he goes through
Well, he starts off the article by saying that
You rarely use weak references, but if you do use them
It'll mostly be for framework building or when it comes to something at more of the memory management level and
Java programmers at least day-to-day Java programmers like myself
Don't don't really do a lot of memory management
But this is a good article to read just for learning. So back to the weak hash map definition, which uses weak reference type, by the way
file then continues
An entry in a weak hash map will automatically be removed
When its key is no longer in ordinary use meaning that there is no single reference that point to that key
When the garbage so what this bit means here
is
In the the key value pairs and in the hash map
If the key isn't being used anywhere outside of the data structure outside of the cache
That means that there's no single reference. Therefore, it just could be removed
automatically and and having a weak reference helps
When the garbage collection process discards a key its entry is effectively removed from the map
So this class behaves somewhat differently from other map implementations because
normal map implementations would have a strong reference and you can't just
Let the garbage collector just do garbage collection as it wishes eagerly
It's a bit more tighter and a bit more stricter
I just realized that I didn't go through this
Canonicalized a mapping bit that is in fact from the oracle docs that defines what weak references are
So the doc state weak reference objects which do not prevent
Their reference from being made finalized finalizable finalized and they're reclaimed
weak references are most awfully used to implement
Canonicalizing mappings. What does that mean?
So this is another really good blog post. I read
On weak references, sorry I had to find the blog post here
And the title of the blog post is itself canonicalized mappings. I'll leave all into that down below
I'm not going to go through the whole thing. But the definition is
But oh the it's by uh, uh, Tom
Tom Roy's own
Rosanne and Ian Lowe
A canonicalized mapping is where you keep one instance of the object in question in memory
And all other lookup that particular instance via pointers
Or some such mechanism
The short answer is that weak reference objects can be used to create
Pointers to objects in your system while still allowing those objects to be reclaimed by the garbage collector once they pass out of scope
That kind of makes sense. I mean, I
Hmm
It makes sense in the sense of
I can see why
theoretically a weak reference type
Can be used in a weak hash map to prevent
Memory leaks in a cache. I can I can see the reason I'm going to be honest. I don't think I can
sell fully
Understand how to implement that in code
But at least conceptually I can see the connection there. So now let's take a look at what a weak hash map is
So I created this class called the weak hash map demo. I kind of repurposed this example
That was used on vile dunks blog
And firstly, uh, this part really isn't a part of the weak hash. I just want to show how to create a weak reference
That's how you do it. It's a generic type. You pass it
of integer
And then you create the weak reference easy as that and then when we
Made this prime reference null
Initially, we declared let me make it null
This object will be garbage collected in the next gc cycle
Um, as there is no other strong reference pointing to it
So when we create the weak reference as you can see here, we are passing that object
Into the constructor of the weak reference class and now this new object is a of type weak reference
But that's just how I create weak references. Now, let's get to the the cracks of this class. I this is terrible coding
I should have put this somewhere else because this in no way is related to this class
But in any case, it's just for demonstration purposes
Here's how we create a weak hash map. Um, so
It's just like creating a normal hash map really. Um, you have to define the key and the value the types of the key and the value
and ideally we want a
map implementation that allows
garbage collection to automatically delete unused objects
correct and
Because we ideally want that is is the reason that we use a weak hash map
When a key of a big image object is not in use and application in any place. So that's
Uh, the key for this object here the unique image name in this case would be the key
This entry will automatically be deleted from memory. It's pretty cool. In fact, how this happened and I'll show you
This and show this to you in code. So we have the weak reference map. Just ignore the other line of code
I've used here. It's just a normal hash map. I've used I was just playing around with this
But what matters really is the the map I've created here in line number 25
So for all intents and purposes this hash map could be our cache
And we are putting a new
big image object into that cache into our hash map
We're also creating key and putting that key too and we're creating the key value pair here
And the image name of course is the object reference, which is the key
Uh, so if I run this code now what you'll see is
Um
So what's this log here map this contain does not contain an image name. Um, so
That is terribly misleading
I just realized that that log can be extremely confusing because
The map is supposed to contain image name because they're putting it in line number 31
And we aren't nulling out any key here
So I I'm gonna run that again because that can be really confusing and kind of ruin the purpose of this demo
The map should contain
Image name
It should contain the key because we haven't nulled it out and I think nothing has happened and of course
The map will also contain a big big image the big image object
Also, that's confusing I should have prepared for this demo much better
I gotta get rid of that line because I'm adding it twice into the hash map. I don't know why I'm doing that
Anyway, in any case, I hope I'm trying I'm making sense
Yeah, I profusely apologize because this is not a good demo
Hey, but uh, as the software engineers, we all know that whenever there's a demo things break. So perhaps it is
Ironically a good demo because this is what a demo would actually look like. Uh, so
Initially, yes, it does contain the key and it also does contain the value
And then what happens is
We null out the key. That's all we're doing. We're not clearing anything out
And then we just run a garbage collection cycle. We force a jvm to write a gc cycle and then
almost magically
The bloody hash map is empty
And how is that this wouldn't happen if it was a normal hash map with a strong reference
The way the hash map is empty in so this is the log here that you see
Uh is in fact because this hash map is a weak hash map using weak reference type
so when the external
Reference to this key was nulled out
The object itself or the key value pair
Was garbage collected because it's it's it's it's not not used. So that's the perfect
implementation of a cache that'll prevent
memory leaks and then for this problem of memory leaks and caches and another solution that he's proposed
is sort of using a
least recently used cache eviction policy, uh
But the implementation of it is a bit more different to kind of the conceptual understanding of what that policy is
And that can be done using a scheduled thread pool executor
And it could be what what this does is in the background on a separate thread
You can run tasks scheduled tasks repeatedly such as cache cleansing
Uh, and to understand what this is what a scheduled thread pool executor does
I came across this article on geeks for geeks by a user called
Samu foe and that's the user's uh pseudonym
and
Here's the implementation of that class. I think it's important to understand what this is doing
Even though this isn't fully related to clearing caches the way it'll work is like this
So I anyway, but by the way all this code is
On the github repository. So please go take a look
And this kind of demonstrates how the schedule thread pool executor works
Initially we create a object called thread pool
We create an instance of the schedule thread pool executor and we pass
The the size so how many threads it's two threads in this case
And then we create two runable tasks. So these tasks could be anything it could even be something like
the main
Let's say the main thread that's running the program and then in the background
clearing the cache in a given time
um, and afterwards
The first one will execute in two seconds and the second one in five seconds
That's it's simple as that so if if I run this method you'll see
The
The first one executed in two seconds and the other one executed a bit later and then
That a bit later. Sorry
That's the current time. I apologize. So that was in the execution. So that was the first task
And that was the second task
So I shouldn't have said every cache every cache of both tasks because this could be in fact, uh, something else. It could be
um, I don't know some some some main task and then the
second one
Which we scheduled to run in five seconds could be the cache eviction
So that's the implementation of of that idea of
Cache eviction policy using a scheduled critical executor and to be you know, pretty more formally and clearly
Joshua block states most commonly the useful lifetime of cache entry is less well defined
With entries becoming less valuable over time
Under these circumstances the cache should occasionally be cleansed of entries that have fallen into disuse. So that's where
scheduling a task like this using uh, these scheduled
Terrapulexecuda could come in handy because
We could time it because schedule a cache eviction in a given period of time
And then he even states that the linked hash map does this so if you take a look at the docs for the linked hash map
there's a protected
Boolean
method called remove eldest entry and that method what that does is in fact
It's an implementation of what Joshua block is described here. It is is clearing the uh, linkless
Sorry the link hash map
By clearing out the old entries
So it says it provides the implement of this class with the opportunity to remove the eldest entry each time a new one is added
And then we get to the third way memory leaks could happen
So we've discussed, uh, how it could happen if classes
Manages their own memory if we discussed how it could happen in caches and the third way is
uh, the third common way is it could happen when it comes to, uh
listeners and other callbacks when we
When a client uses an api
With a callback function. So firstly, what's a callback? Um, so
Rich, uh
Rich of jindal from geeks4geeks states that a callback function is a function that is passed
Into another function as an argument and is expected to execute after some kind of event
I would also add it's also an example of so the how callbacks are implemented is an example of the observer pattern
Where an object should subscribe to another object and listens
To changes in events on runtime
And that's what a callback is. It's a it's a function. It can pass to be executed
you know
Contingent on on on an event during runtime
Uh, even though I've used callbacks obviously javascript uses well we use promises
But then a lot of javascript uses before promises use callbacks
And even in java we use callbacks, uh, but I didn't initially get the understanding
Oh, I didn't initially understand
How it can
Work apropos weak references and how the garbage collection works when it comes to callbacks
So I did post a cycle of low question and I got a really good answer
By this user called, uh
Ingo kegel
I'll leave a link to this question down below in the description. Go take a look
But you think that uses the answer. Let's try and make sense of what
Uh
Well, in fact before I say that I just want to say, uh, just a block states apropos this point
If you implement when I mean apropos this point, that's uh
When it comes to memory leaks with listeners and other callbacks, he says he states
If you implement an api where clients register callbacks, but don't do register them explicitly
They will accumulate unless you take some action
So what does that mean? What what's the action we got to take the action?
We got to take would be using a weak reference. Um, and what before we get to the code. I I realized I should I should read out
Ingo kegel's answer here
He says a client of the api has to keep a strong reference to the listener
That's how it says without correct. So the we can define the listener here as an interface
That's how we would normally do when implementing callbacks in java
The api only holds a weak reference to the listener to do that
So that it does not prevent that's a
Type of that I believe so that it does not prevent the client from being garbage collected
So it allows
Garbage collection to take place if required when the kind is garbage collected the listener is also garbage collected
That's that's a good thing because we want we don't want the
Obsolute object the listener object to exist in memory and take up resources and that's why a weak reference would help
Now the implementation of that would be seen here. So this is the example's courtesy of ingo kegel as I said
This is his code that I've repurposed uh to don't want to write this
um
So firstly, uh since java doesn't support function pointers, this represents a callback effectively
It's a reference to the function which will be called
So because we don't use function pointers, we can use callbacks in java
Function pointers can be used in c++. I believe I don't quote me on that because I'm not a c++ programmer
C++ programmer. Why am I talking so fast and fumbling my words too much of coffee?
So this callback demo represents the mock api that a user would use
Initially, we have defined the listener here. So this listener is of the type the interface listener
Um, and then we've got to initially register this listener. That's what the client would do. So the client of this api
Uh would do that a bit later because the observer of this api has to use that method
And register itself. This is a bit confusing
I should have maybe called it used to separate class and called the client
But this callbacks demo class is the client of this api
Just keep in keep in mind. Um, so that client would have a strong reference
however
once the
registering is done the
api itself
Will maintain a weak reference because then what happens is when this client at one point is garbage collected
So would the listener
That it registers and then we have this file listener method
Which checks for the listener which which checks if it's registered and then fires an event which we've defined
Yeah, which runs some tasks. So that's kind of how it's used in the context of callbacks and listeners
And and that's why using a weak reference would help
With ensuring that there aren't any memory leaks when a client uses our api
And then to conclude in the final paragraph Joshua Block states
Biggest memory leaks typically do not manifest themselves
As obvious failures. They may remain present in a system for years
They typically discovered only as a result of careful code inspection
Or with the aid of a debugging tool known as a heat profiler heat profiler can also be called like a java profiler
And that's a tool pretty much that monitors the bytecode
Constructs and operations at the jvm level at a very low level using a heat profiler. You could
Monitor your code and examine memory usage
How garbage collection takes place if resources are being used waste used wastefully
If there are memory leaks all these things we discussed could be found through a tool like a
Java profiler or heat profiler
And again all done is definition here these these code constructs and opera operations include object creation iterative executions
Including recursive calls method executions threat executions and garbage collections
So it's kind of like a way of instrumenting your application and instrumenting your code. Let's say and really
Digging deep into it and examining it at a bytecode level
And that's obviously something that you know, I've never done it before in my life
Just on your id you can't do that. You need a specific tool for that
Therefore to end it he states it is very desirable to learn to anticipate problems like this before
They occur and prevent them from happening. So that's why this point is great because
Initially just your block points out what the issue is he he kind of
Illustrates it, but then he also gives us three areas where this could potentially occur
We could kind of anticipate where memory leaks could occur when writing code and the three places it could occur
When it comes to having
obsolete object references that we should eliminate
is in
classes that just to reiterate the point in classes that manage its own memory
In caches and when it comes to callbacks and listeners
When you implement that in your api
That's it. That is
The item number seven element obsolete object references
As I did anticipate it did go for over an hour because I did feel even though the item isn't all that long or all that complicated
have a few points like
implementation of the listeners and the callbacks and then the
Weak references that I felt like we need to dive in a bit more and understand at least I needed to to make sense of it
As I said all the code that I used are in
On the github repository and the link to that is in the description down below
Please go to click at the code. It'll make a lot more sense if you study the code
assiduously instead of me kind of explaining it
Again, I'm trying my best to to you know articulate myself while I'm also learning as I go
It's kind of how it works. You probably can see I'm struggling a lot with some of these concepts
But in any case, I sincerely do hope this video brought some value. You learn something from it
I shall see you in the next item. It is item number eight. We're still in chapter two
And item number eight is avoid finalizers and cleaners
And I'll get to that as soon as possible. In fact, I've already started writing the code for it. I'll see you in the next one. Cheers
You
