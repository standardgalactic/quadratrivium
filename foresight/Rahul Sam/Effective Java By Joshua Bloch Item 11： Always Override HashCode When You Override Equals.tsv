start	end	text
0	6960	Hey everyone, welcome to yet another episode of my video series on Joshua Bloch's effective Java
6960	14640	and today we're going to cover item number 11, always override hash code when you override equals.
15280	20320	But of course, before I get to the item as I usually do in the series, I want to go through
20320	26480	this proviso and make a few points. Starting off, this is not a tutorial. I'm not a teacher.
27040	34560	Nor am I certainly an expert in Java or object oriented programming in general. So please don't
34560	43040	take what I say as gospel truth, always double check, do your own research. This is simply me
43040	49520	sharing my learning experience. That's purely it. So don't treat this video series like a tutorial.
49520	56720	I may spew or give out false information, unfortunately, though I will try not to.
57760	64240	Think of it more as the blind, leading the blind, that's an analogy that I've been using for a while
64240	72560	now. I am as blind or perhaps even more blind than you are. So this is merely a exploratory
72560	77680	disquisition. I'm just figuring this thing out and hopefully we can learn together. In fact,
77680	82560	I've already been corrected in a few of my other videos and I've been trying to rectify those errors.
83680	91520	Therefore, again, not to repeat the same point, I will inevitably make mistakes. So please do
91520	96560	point them out more for the benefit of the videos and myself. But yes, of course, for the benefit
96560	104640	of myself too, selfish speaking. And given this is a, in fact, programming video series,
104640	109920	all the code that I use that I've been using for all the previous items that you can see here,
109920	117040	it's all available on my GitHub repo. I'll leave a link to the code for today's item, item number 11
117040	125280	to my repo, but also to Joshua Block's sort of official repo that he has for this book.
125280	129360	Saying that without further ado, let's get started. So yeah, as I said, item number 11,
130080	137280	which is always override hash code when you override equals and the item starts off like this.
139200	145280	Joshua Block states, you must override hash code in every class that overrides equals.
145280	151920	If you fail to do so, your class will violate the general contract for hash code, which will
151920	158240	prevent it from functioning properly in collections such as hash map and hash set. But before we
158240	163920	continue on with the item, let's get some key phrases or key terms out of the way, get some
163920	170640	definitions out of the way. So what is hash code? And who better to ask than chat GPT? And oh,
170640	177040	I forgot to mention, this item is a part of chapter three methods common to all objects.
177040	184160	So back to it. What is hash code? Chat GPT states, and I think it's accurate here because I did
184160	191840	double check with a few other resources or definitions online. In computing, a hash code
191840	200640	also called a hash value, check sum or simply a hash is a fixed array, sorry, is a fixed size
200640	207360	string of characters that is generated by a one way mathematical function called a hash function.
208080	215120	From an input of any size, often call the message. The resulting hash code is typically
215680	222160	a hexadecimal number that is a unique representation of the input. The main purpose of a hash code
222160	228640	is to take an input and produce a fixed size string of characters that can be used to identify
228640	234880	or verify the input. Hash codes are commonly used in data structures such as hash tables,
234960	241680	OS, just look at stated hash maps and hash sets. And in various algorithms, such as message,
242640	248560	sorry, such as message authentication codes, digital signatures and check sums. Oh,
248560	254400	this is an important point regarding hash functions. Hash functions are designed to be one way and
254400	261120	deterministic, meaning that the same input will always produce, let me zoom in a bit actually,
262080	267280	meaning that the same input will always produce the same output, but it is computationally
267280	273120	infeasible to determine the original input from the output. And then more in the context of Java,
273120	278400	I got this definition from educative.io, when the hash code, which is the hash code method,
278400	284720	is called on two separate objects which are equal according to the equals method. So by the way,
284720	290080	we discussed the equals method in the previous items. If you want to understand, get a, in fact,
290080	294320	a really deep understanding of the equals method, I suggest or recommend you watch
295200	301440	all four parts for item number 10 because it was such a big item. I had to break it down into four
301440	307600	different videos, but in that, I dealt deeply into the equals method. In that case, getting back to
307600	315200	this, which is called on two separate objects, it returns the same hash code value. However,
315280	320800	if it is called on two unequal objects, it will not necessarily return different integer values.
320800	326800	So that's the definition in the context of Java. So to get started, here's a really simple,
326800	333840	straightforward class as to how the hash code is used, example, courtesy of educative.io, of course.
334640	341280	So there's a class called hash, declared two strings, and keep in mind that these strings
341280	349680	are immutable. And if equals b, this function will indicate that object a is equal to object b.
350640	357120	And it's important to keep in mind, if there is logical equality between two objects, if the hash
357120	365280	code wasn't overridden, then unfortunately, we would get two different hash codes for these two
365280	370960	objects that have logical equality. And that, in fact, is a anti-pattern or a violation of the
370960	376480	hash code contract. And that's what we're trying to demonstrate here. So also, if it's not equal,
376480	382800	here, it'll say that it's not equal. So if I run this, you'll see that a is equal to b, and c is
382800	388560	not equal to d. So we have the equal variables. And then we have, let me zoom in a bit.
389280	395280	We have the equal variables and the unequal variables. And you can clearly see, in the equal
395280	402560	variables, because the string class follows the hash code contract, the hash code is the same.
402560	406800	And for unequal variables, there are different hash codes. So that's good. That means the string
406800	412000	class has overridden the hash code method. Speaking of the hash code contract, what does that mean?
412000	417200	What is the hash code contract? As we saw from the demo, if two objects have logical equality,
417920	422400	if there's an invocation of the hash code method, it should always consistently return the same
422400	428240	value, whatever it may be. Although a caveat is it can differ depending on the application state,
428240	433840	but that too should be considered when designing the hash code method. Or to put in a bit more
433840	441520	clear way, let's say, using chargeGPT. For example, if you have an object that has a unique ID
441760	449200	that is generated when the object is created, the hash code method could use this ID as a part
449200	455040	of its calculation. Because the ID is unique to each instance of the object, the hash code method
455040	460560	would return a unique value for each object. However, if the application is run again,
460560	465920	the ID may not be the same. And thus, the hash code method would return a different value.
466880	472720	This is the example that chargeGPT gave me when I asked to give an example, let's say, in the real
472720	478960	world of how the hash code would differ depending on the application state. So that kind of makes
478960	485520	sense because it's kind of depending on this external resource, which is the unique ID in this
485520	491360	case. And of course, this seems like an obvious point, but it has to be stated. If they don't have
491440	499040	logical equality, then it would probably give different hash codes when the hash code method
499040	504800	is indicated. However, that also does not mean or there's no requirement that it should produce
504800	513440	distinct results. Despite two objects not having logical equality, it's possible for it to return
513440	518960	the same hash code. Though the vice versa, the opposite of that would be if they do have logical
518960	522880	equality, then most certainly the hash code should be the same. Or put more succinctly,
522880	528640	logical inequality doesn't necessarily mean objects will have different hash codes. However,
528640	535360	as I've said here, if hash code, the implication of the method hash code, does return distinct
535360	541840	integers for objects, this will improve performance in hash based collections as this will reduce
541840	548720	collisions. Because there could be collisions if while they don't have logical equality,
549280	555520	it still returns the same hash code. So if we can design a good quality hash code method,
555520	562880	that will even try and prevent this, where we know for sure that two logically
562880	567760	unequal objects will always have distinct hash codes, it will reduce these collisions.
567760	573680	And the collection, and so whatever the collection that's using a hash based collection,
573680	578320	won't have to look for logical equality prior to putting an object in a location
578320	582320	or a hash bucket to be more specific. Now what I mean by this latter point,
582320	587200	putting it into a location in a hash based data structure, it'll make more sense as we go through
587200	596320	the demos. But the idea is, in a hash map or hash table or whatever, hash based data structure,
596320	602800	when you give it objects, it'll look for, it will do the calculation and get the hash code,
602800	606640	and then it'll put it in a specific hash bucket depending on the hash code, but also
607760	613520	it'll look for logical equality. It'll look for logical equality because if there is logical
613520	617520	equality, then without doing any more calculations, it could straight away put it in the specific
618560	624800	hash bucket. The thing though is, I believe, and I think it works this way,
625600	635200	it'll also create a kind of a link list if these objects have the same hash bucket. So it'll compare
638640	643840	actually on second thought, I may be talking out of my ass here. So I'm just going to shut up
643840	650000	and keep going and not try and make that point with such certainty. The point being,
650640	658080	generally, considering both logical equality and inequality, it's perhaps a good idea to reduce
658080	666240	collisions. Just take that as a general rule of thumb, let's say. Sorry, man. I've been thinking
666240	671840	out loud here, and I don't know. Sometimes when you think out loud, you clearly do say bullshit,
671840	676400	and I apologize if I did say something false there. Okay, so to clean up my mess and to not
676400	683440	keep digging myself into this hole, I'm just going to go read off the book as that, in fact, is a
683440	688560	good source of truth. On the point that I was trying to articulate here, here's what Joshua
688560	696000	Block states. The key provision that is violated when you fail to override hash code is the second
696000	703040	one. Equal objects must have equal hash codes. That's a really important point. Two distinct
703040	709040	instances may be logically equal, according to a class's equals method, but two objects
709040	715440	hash code method, they're just two objects with nothing much in common. And of course,
715440	721920	therefore, objects hash code method returns to seemingly random numbers instead of two equal
721920	728080	numbers as required by the hash code contract, which we discussed just here. So the idea of
728080	735680	logical equality, giving the same hash code for hash code method invocation can be simply
735680	740720	demoed with this phone number class that Joshua Block, in fact, has used. And this class was also
740720	746880	used in item 10, I believe. We have a class called phone number that represents a phone number with an
746880	754400	area code prefix and a line number. So if we go to the main method in this class,
754800	764080	I've created an instance of, well, I've got a hash map here, sorry. And this hash map has
765280	772160	key values of phone number and then a string, which is a phone number. If I put a new phone number
772160	780320	object with the name Jenny into this hash map, what I'd expect is, as you can see here,
780320	787120	I'm creating a new phone number object and I'm putting it in. Now, this hash map, because it's a
787120	793840	hash based data structure, it's going to use the hash code of this object where to find the
793840	799600	location in the map to put this object, the key and the value. So there's going to be the key
799600	807360	with the hash code and the value is going to be Jenny. And it'll do that based on the hash code
807360	814960	of this object, as I said, like 10 times already. Then in the next line, I'm trying to get that
814960	822480	same value, Jenny, from the hash map. So what I'm doing is I'm saying m.get, so that's the hash map
822480	828480	and I'm saying, hey, here's the key, give me that value. But unfortunately, because we haven't
828480	835440	overwritten the hash code method, when this code is run, it returns a null. Because what happens is
835440	841200	in the get, it'll create a different hash code, a new hash code, and it'll look for it in the
841200	849760	hash map and it can't find it, so it'll return null. Despite both of these objects, this one here
849760	855040	and this one here clearly having logical equality because they've got the same area code, prefix
855040	861360	and line number. Now, simply the way to fix it is to override the hash code, which we've done here.
861360	866480	I'll go through all of this stuff a bit later, much more punctiliously. But at the moment, just
866480	872320	assume it has been overwritten to reflect logical equality. And now what will happen is the same
872320	878640	bit of code that I'm going to run, it'll return Jenny. There you go. Which is good, because that's
878640	884800	what we want. Because that means the hash base collection identified that we're in fact looking
884800	890240	for this the same object. Or as Joshua block states, the phone number classes failure to override
890240	896720	hash code courses the two equal instances to have unequal hash codes, which is why initially
896720	902480	before the overwritten in the retrieval, we got a null in violation of the hash code contract.
903520	908640	Therefore, the get method is likely. So I'll leave it in the code because it makes more sense
908640	914160	than that. That's the get method. The therefore the get method is likely to look for the phone
914160	918800	number in a different hash bracket from the one in which it was stored by the put method.
919520	925120	Even if the two instances happen to hash to the same bucket, the get method will almost
925120	931760	certainly return null because hash map has an optimization that caches the hash code associated
931760	938480	with each entry and doesn't bother checking for object equality if the hash codes don't match.
938480	942880	This kind of relates to the previous point that I tried to terribly articulate using
943440	948240	bloody length list and all that. But the idea is that the idea is that if they do have
949680	954240	hash codes that don't match, it's because the value is cash, it'll just return the cash value
954240	958400	in this case a null. Now fixing the problem would be overriding the hash code method. The
958400	963360	example I showed here is in fact, this is a good way of overriding it. But the worst way,
963360	968960	despite it being legal, would be to simply return the same value returning 42 here.
969440	973760	One should never do this because in this case for every single value, it's going to return
974400	979760	the same hash code and that is that is hell. Or instead of invoking biblical references to
979760	986400	put it the way Josh of Lockwood, it's legal because it ensures that equal objects have the
986400	993760	same hash code. It's atrocious because it ensures that every object in fact has the same hash code
994320	999280	and that shouldn't be the case. Therefore, every object hashes to the same bucket
999280	1004080	and hash tables degenerate to link lists. This was the point I was trying to make before
1004720	1011680	and I kind of confused the two. And then he said it's programs that should run in linear time
1011680	1016960	instead of running quadratic time. So just to get a bit of that computer science out of the way,
1016960	1021440	I wouldn't say out of the way, it's in fact quite interesting. This is quite important to
1021440	1026000	understand when it comes to designing algorithms, the difference between linear time and quadratic
1026000	1033200	time. In linear time, the number of steps required is directly related one to one. So big O of n.
1033200	1038000	So it's a number of elements, let's say in a data structure. So if it's in an array,
1038000	1043360	it's the number of elements in that array. If the array is of size five, it would be big O of five
1043360	1050640	here. In quadratic time, the number of steps is taken to accomplish a task is n squared because
1050640	1057120	each item has to be compared with with each other. Now, because I'm partially retarded,
1058400	1065920	I had to tell Judge GPT to explain this to me like I was Michael Scott from the office,
1065920	1070480	because in many ways I embody that archetype. Yes, Michael Scott is an archetype in fact.
1071440	1080240	And I ask from, sorry about that, a bit of background noise, let the plane pass. It's passing.
1081760	1089360	And it's passed. Excellent. So I told Judge GPT, explain linear time versus quadratic time in
1089360	1095280	computing like Michael Scott from the office. And here's what Judge GPT told me. And in fact,
1095360	1100800	this is really good. This is really good explanation. Sure. Let's imagine you're trying to find a
1100800	1106800	specific paperclip, haha, office reference, because you know, it's a paper company, find a specific
1106800	1114160	paperclip in a huge pile of paperclips. If you use a linear time algorithm, it's like you're checking
1114160	1121440	each paperclip one by one in a line, which is why it's called linear, I guess, until you find the
1121520	1127120	one you're looking for. It takes a little longer with more paperclips, but the time it takes to
1127120	1132720	search for the paperclips grow at a steady pace, just like a straight line. So it's,
1133920	1140240	would it be called exponential? No, it's correlated to the amount of paperclips or simply put big
1140240	1148480	O of N. But if you use quadratic time algorithm or a quadratic time algorithm, it's like you're
1148480	1155440	checking each paperclip against every other paperclip in the pile over and over again,
1155440	1160480	as the number of paperclips grows. The amount of time it takes to search for one,
1160480	1165120	you're looking for grows at an exponential rate. So sorry, just to keep in mind, quadratic time
1165120	1170880	is exponential, like a big square. So linear time is like searching through a line of paperclips,
1170880	1176720	while quadratic time is like searching through a pile of paperclips. The former is faster and
1176720	1182800	more efficient as the number of paperclips grows. So it's because of that reason, a good hash function,
1182800	1189040	leaving aside the legality, so to speak, should produce distinct hash codes for unequal instances
1189040	1195200	to prevent this, this mess of linear time and quadratic quadratic time when putting into a
1195200	1201360	hash based data structure. Or as put in the book, this is exactly what is meant by the third part
1201360	1208000	of the hash code contract. Ideally, a hash function should distribute any reasonable collection
1208000	1212800	of unequal instances uniformly across all int values. And I kind of wanted to
1213520	1218560	a more elaborated definition of this. So of course, I once again asked Judge CPT,
1219520	1224720	and it said, for example, if the hash function returns integers, it should distribute the hash
1224720	1230240	values evenly across the possible integer value. So if the hash function is applied to 10 unequal
1230240	1237520	objects, the hash values produced for those objects should be spread across all the possible
1237520	1245680	integer values, not just a small range of values. This helps to ensure efficient hash based data
1245680	1251920	structures, such as hash tables, where hash collision should be kept to a minimum. Now,
1251920	1257200	all of this explained here, this is, I think it kind of seems not self evident, but after this
1257200	1263360	explanation, it seems to make sense. It's about uniformity. It should be spread across uniformly,
1263360	1268640	depending on the int number of values you give it. But how do we achieve this? Because that's
1268640	1273840	the ideal, and it can be a bit tricky at first glance. But fortunately, Joshua Block has stated
1275040	1280240	there is a recipe for a high quality hash function. So to understand this hash function,
1280240	1287120	firstly, let's go through the theory step by step, and then I'll jump into the demo and it'll
1287200	1291760	obviously make a lot more sense when you see the actual code. Step number one is to declare an
1291760	1299040	int variable called result and simply assign the value of the first significant field into this
1299040	1304960	result variable. And keep in mind, as Joshua Block has stated here, recall from item 10 that a
1304960	1310480	significant field is a field that affects equals comparisons. So whatever it may be, assign that
1310480	1320960	to this variable value. Obviously, I screwed that up. I reread that a couple of times, and I
1320960	1327040	made a blunder, I made a huge error there. It's you don't assign the value of the first significant
1327040	1337520	field, you assign the hash code value of the first significant field. That is a bad mistake,
1337520	1342800	because that can truly scrub the whole recipe. So keep in mind, you whatever the first significant
1342800	1348720	field is, you calculate the hash code and you assign that to the result here. And then step
1348720	1356240	number two, for every other remaining significant field F in your object, do the following compute
1356240	1362480	int the int value hash code C. So all the other fields, if the field is a primitive type, so that
1362480	1369760	could be an int, a char, whatever, use a box primitive and then use that and sort of like
1369760	1375040	what I described here. So there's a primitive field 42 here, primitive int, use the box in
1375040	1380880	and use value off and then use the box primitive hash code method to calculate the hash code value
1380880	1386480	because the primitive type won't have a way to calculate the hash code method. So obviously,
1386480	1392160	each primitive type in Java will have a corresponding box primitive, like here where int has
1392160	1398320	integer. So the second part of that is that it's important to consider how the equals method compares
1398320	1404400	field values. What I mean by that is, if the equals method recursively invokes equals on the
1404400	1410880	object reference fields, then the hash code method should recursively invoke hash code on those fields.
1410880	1420240	So in an object, whatever the fields that the equals method invokes equals to the hash code
1420240	1425360	method should do the same. I will put this way, what I realized when I was going through this
1426480	1433440	item, or more specifically, this recipe for the hash function is that a lot of the things that the
1433440	1439200	equals method does, the hash code method should do too. A lot of the patterns that it follows,
1440160	1445440	that the equals method does or follows, the hash code method should follow too. So the second part
1445440	1451200	of that is, if the equals method requires a more complex comparison for the object reference field,
1451200	1457760	the hash code method should compute a canonical representation for the field and invoke hash
1457760	1463520	code on that representation. So what does this mean? We discussed canonical representation in item 10.
1464480	1471760	As the name suggests, it's a canonical value. So if there's a certain field value in the
1471760	1479520	object that's pro to change, that is rather dynamic, for the sake of comparison, or in this
1479520	1489840	case, for the sake of calculating the hash code, we could assign a sort of static variable value
1489840	1497120	that we consider to be the canonical representation of that field. And that can be used for all the
1497200	1501600	computation and all the calculations of the equals method calculations, but also in the
1501600	1512480	hash code method. That makes it gives our methods a bit more structure for object fields that have
1512480	1517760	rather dynamic and volatile, and I don't mean volatile in the Java sense, I mean volatile just
1517760	1524400	conceptually speaking, significant fields in an object. And the third part is, if the value of
1524400	1529280	the field is null, obviously, the hash code method should use a constant value such as zero
1529280	1534560	to represent the hash code for the field. That seems pretty self-explanatory because given that
1534560	1540880	this result variable that we're using is an integer is of type int, we need something to
1540880	1547920	correspond to a null where zero probably would be the apt value to use. And if the field is an array,
1547920	1552400	with all fields of the array being significant, use arrays or hash code. So we can use this
1553040	1559440	method from the arrays class in the library. Or as Joshua Booker said it here, if the field is an
1559440	1566240	array, compute a hash code for each significant element by applying these rules recursively
1566240	1572480	and combine the values per step to be. So per step to be is the next step.
1573840	1579520	We'll get to that too. If the array has no significant elements, use a constant, preferably
1579520	1584160	not zero. That makes sense because zero would normally be used for something like a null.
1584160	1587920	We don't want to have that kind of conflict or confusion. And then step two be, of course, is
1588480	1594560	to, all the values that we used here, that we computed here, sorry, combine them to get the
1594560	1603600	hash code where we have the result value multiplied by 31 plus C. And what's C? It is the computed
1603600	1608320	hash code value. And then you return result in the hash code function. This will all make sense
1608320	1614160	once we look at the demo. In this demo, I've got a class called person. And this person class
1614160	1621920	has some significant fields, their first name, type string, last name, type string, and address.
1621920	1628640	And the address is a class that I've defined in this file, in fact. And the address essentially
1628640	1635840	has a street, city, state, and zip code. So the addresses of address, as you can see clearly.
1635840	1643760	And then we've got the age, which is of primitive type int. And also we have a string array,
1645440	1650720	which I've called language is spoken. So the language this person speaks. And then we've
1650720	1655760	got the constructor and the equals method also I've overridden. I'm not going to go through that
1655760	1659520	because it's kind of on a scope. And I kind of went through this already in the previous item.
1660080	1668240	And then we've overridden the hash code. So this hash code theoretically should be a high quality
1669040	1672320	hash function or a hash code method, because I've followed the recipe
1672960	1681520	delineated in just a blog's book or in effective Java. Initially, the result as we saw in step one
1681520	1686240	has been arbitrary number 17 has been picked as a constant. This will reduce
1687040	1692720	collisions. Keep in mind, don't pick a number like zero, start off with something like this.
1692720	1701280	And then we've used the significant fields to calculate the result using the hash codes and
1701280	1706800	then adding that to the result value. And again, multiplying by 31, this again is to give it
1707440	1713040	give it more uniqueness or more more distinctiveness and preventing collisions.
1714160	1720720	And then in the address, we've done it a bit differently where we're in fact looking for
1720720	1727600	the hash value of the address object. And if it has been cached, or pardon me, if it's null,
1728160	1734480	then we get economical address value. And if it is null, then we're going to return zero.
1735120	1739680	So we're going to want to make sure that the address is not null and that this person has
1739680	1747440	an object. And so we get canonical, the canonical address, which by the way, this method is defined
1747440	1755760	in the address class. So back to this. And then we are also given that the age is of type int,
1755760	1762560	it's a primitive type, we're using the box primitives. Sorry, yeah, box primitives and using
1762560	1768080	the value often getting the hash code. And then for languages spoken, because the string array,
1768080	1775360	we're using arrays or hash code, again, as stated in the hash function recipe,
1775360	1781760	and then simply we return that result. So here's an example, the client using that class,
1782400	1788240	we use Alha Camus, my one of my favorite essentialist authors, highly recommend you read him,
1788240	1792400	start off probably with the stranger. And then if you're more philosophically inclined,
1792400	1800160	perhaps the myth of Sisyphus, I love the stranger so much that I, in fact, I'm trying to learn French,
1800160	1806240	just because of Camus. It's a beautiful book. So the languages Camus speaks, I found out,
1806240	1811120	in fact, he speaks Arabic too. So it's English, French and Arabic. And then
1812160	1816080	they're giving his address, I just randomly found this online, I'm not even sure if this is accurate,
1816080	1821840	but this is probably where he lived. And unfortunately, he only lived to an age of 46 years
1821840	1826880	because he died in a car crash, which is quite a tragedy, given I would have loved to
1828080	1833520	read more of his work if he did live up to old age. And then when you run this function,
1833520	1839520	it calculates the hash code for the Albert Camus, Albert Camus object. And then Joshua
1839520	1845520	Book states, when you are finished writing the hash code method, ask yourself whether equal
1845520	1853680	instances have equal hash codes, and many states do use unit tests and whatnot to figure that out.
1853680	1858720	Now I haven't written unit tests for this, but clearly the way this client has used it, this
1858720	1864640	can be converted to unit tests and used in a variety of ways. And then obviously, if equal
1864640	1871120	instances have unequal hash codes, figure out why and fix the damn problem. He doesn't say damn,
1871120	1874720	I just put it in there because why not? He's a nice guy.
1877840	1881600	So that makes a question, or perhaps it doesn't, but at least it begs the question for me,
1882160	1888080	what to exclude from the hash code computation? That's the typo that's on hash code, hash code
1888160	1895680	computation. And he states you could in fact exclude so-called derived fields. And let's
1895680	1901360	understand what they are before we get to the demo. Those are values that can be computed from
1901360	1906320	other field values already in the hash code computation. So we did go through this idea
1906320	1916240	of derived fields before in the, in item 10, I believe using a pentagon or some mathematical
1916240	1922720	structure. But let's take a look at another demo. I think it was a polygon we used in item 10. And
1922720	1928000	I didn't want to use that example here because, you know, firstly, my math is shit. I'm quite
1928000	1933920	embarrassed about that. Therefore, I found it a bit hard to explain using the polygon class example.
1934720	1938480	That's something I should work towards. And in fact, teach myself some mathematics,
1938480	1944640	some basic mathematics at least. But this is way more straightforward. So what's the derived field?
1944640	1949760	We have a full name. And obviously a full name can be derived off the first name and the last name.
1950960	1959120	And in the hash code, we don't have to, when calculating the hash code, we don't have to use
1960560	1968560	the full name in the hash code calculation, given that it's already derived from first name and last
1968560	1973920	name. That's it. That's what a derived field is. And that could be excluded in a hash code method.
1973920	1979760	Okay, so this next part, the order of the fields. And the point is the quality of the hash code
1979760	1986880	method is contingent on the order of the fields if a given class has similar fields. Now, to be
1986880	1992480	totally upfront, I found this part quite difficult to understand. So I'm going to try my best to
1992480	1997520	try and explain this. I think I got it, but I think I'm going to struggle a bit to articulate it
1997520	2004080	because it's not, intuitively, it's hard to get it on first glance. It requires a bit of thinking.
2004080	2011360	So the reason for this is because of 2B. That is this calculation we make here. It's this is the
2011360	2020800	reason that makes the ordering contingent for the hash code method. So Joshua book states,
2020800	2025360	for example, if the multiplication were emitted from a string hash function,
2026400	2034560	all anagrams would have identical hash codes. The value 31 was chosen because it is an odd prime.
2035280	2040640	If it were even and the multiplication overflowed, information would be lost because modification
2040640	2047920	by two is equivalent to shifting. Another way to think about that is that this multiplication here,
2047920	2056560	31 times i, that can be replaced by this the shifting of the of the sum or the left shift
2056560	2066560	operator in Java. As far as Java is concerned, that and sorry, that and that are mathematically
2066560	2071920	equivalent. Now we'll get to the definition a bit before a bit later, sorry. But firstly,
2071920	2078320	let's take a look at some demos. So in this example, and this is a bad example where the
2078320	2087520	order hasn't been considered. If you run this, there's a possibility that these two hash codes,
2087520	2093600	so for object A and object B, which are two anagrams, that the hash code could be the same,
2093600	2097760	because all they're doing in the hash code method, if you can see here is we're simply
2098720	2103680	returning the hash code of word of the string value. So we're just using the
2103680	2108560	hash code method in the class string. We aren't really considering anything else apart from that.
2108560	2115600	In fact, I don't even know why they'll be written as second place here. It's like this is a superfluous
2115600	2121840	or unnecessary method. And even though I ran this a couple of times, and this is why I said it
2121840	2126800	depends on the application state, it is possible theoretically for this to return the same hash
2126880	2133440	code despite these two being different. And then here, we are in fact multiplying by 31,
2133440	2140240	and we are even having this arbitrary value initially. The chance of these hash code values
2140240	2145600	being the same is a lot more different in comparison to the previous example that I showed
2146720	2149920	in the other class. Both classes are called anagrams, it's a bit confusing,
2150880	2155840	but they're in different directories, or yeah, the packages are different. So that's because we
2156000	2162240	modified that a bit in hash code. This is a bad example. I only put this in here because it kind
2162240	2168000	of goes along with what Joshua Block had stated in the book. I in fact thought using a separate
2168000	2173040	class called person would be better to understand this. The reason I use anagram is because that's
2173040	2178800	the example that he's used, but frankly, is equally so. I didn't really get it much. So
2178800	2184000	maybe we'll try to understand it with the person class. I put that other part in there just to
2184080	2191760	stick with what's in the book. And I thought that'll help in some way. Given he said if the
2191760	2197680	multiplication were emitted from a string hash function, all anagrams would have identical
2197680	2205440	hash codes. Ah, I now seek my confusion. He did say if the multiplication were emitted from a
2205440	2209920	string hash function. So the reason we're getting different ones here is because in fact in the
2210000	2216320	string hash function, it wasn't emitted. If it wasn't, it was kind of like this,
2216320	2221840	just simply returning it. It could have been the same. But in the string hash function, if you look
2221840	2230640	at the hash function, there is some multiplication being done. There's some work being done here.
2230640	2235600	I'm not going to take a look at it. It's a bit too complicated for me, but it's not just simply
2236560	2241280	taking that value in and passing the hash code. So anagrams themselves would have different
2241280	2246800	hash codes, which is great. Apologies about that. I should have gone through that a bit more carefully
2246800	2250080	beforehand, but it kind of makes sense now what he's trying to say here.
2252080	2256480	And then the part I was trying to explain before about these two statements being
2256480	2263520	mathematically equivalent. Joshua Bock states, a nice property of 31 is that the multiplication
2263520	2270000	can be replaced by a shift and a subtraction for better performance on some architectures,
2270000	2276960	because as I said, these two are equal, mathematically speaking. And modern VMs do
2276960	2281360	this sort of optimization automatically. I perhaps did a terrible job at explaining that,
2281360	2286640	because I too am trying to understand this idea of the shifting operator and all that.
2287600	2292400	So I asked Judge GPT, and I think this is much more clearer than what I could ever say.
2293200	2300640	Here's what Judge GPT states regarding this. The double listed operator is the left shift
2300640	2307360	operator in Java, which shifts the bits of an integer to the left by a specified number of
2307360	2313600	positions, effectively multiplying by 2 to the power n, where n is the number of positions shifted.
2314800	2320480	That's why it's shifting. The minus operator is the subtraction operator, which subtracts the
2320480	2329200	second operand from the first. So the expression i double less than 5 minus i shifts the bits of i
2329200	2335200	to the left by 5 positions, effectively multiplying it by 2 to the power 5 or 32,
2335200	2343440	and then subtracts i from the result. Since 32 minus 1 equals 31, the expression is equivalent
2343440	2352560	to 31 times i. That's what it's this bit that gives this equality that Joshua Bloch speaks of.
2353520	2358400	By using the optimization, the hash function implementation can take advantage of the
2358400	2364160	efficient left shift operation on some architectures potentially leading to improved performance,
2364160	2369360	and also Judge GPT repeats what he stated. Modern virtual machines are designed to automatically
2369360	2374400	perform this kind of optimization, so the hash function implementation can remain unchanged
2374400	2380640	and still benefit from the performance improvement. So a simple example of this would be if I ran this
2380640	2388640	code, j would be equal to k. It'll print true because both these are equal. They both will be 310.
2389440	2393920	And then let's take a look at another demo. I think we already kind of took a look at this.
2393920	2397920	Sorry, by the way, not related to this is separate because Joshua Bloch states,
2398640	2403760	say all that, let's apply this previous recipe to the phone number class. Now I already did apply it
2403760	2410480	and show the demo in my own way, but it's important to take a look at what Joshua Bloch has done too.
2410480	2418960	Here's the demo. As we saw, it returns the hash code of the initial value area code that he set,
2418960	2423840	says he said to take the first significant field and assign the hash code value to result,
2423840	2428800	and then do the calculation accordingly. And that returns the result. And on this method,
2428800	2436000	he states, because this method returns the result of a simple deterministic computation,
2436560	2443280	whose only inputs are the three significant fields in a phone number instance, that is area code,
2443280	2451920	prefix and line number, is clear that that equal phone number instances have equal hash codes.
2452480	2458800	It is simple, is reasonably fast, and does a reasonable job of dispersing unequal numbers
2458800	2465280	into different hash buckets. And of course, a bit of a caveat here, as we saw in item 10,
2465280	2472560	when it comes to equals comparison, even in the hash codes, he stated, if you have a bona fide
2472560	2480960	need for hash functions, less likely to produce collisions, see Guava's co Java library, which
2480960	2486800	is Google's co libraries for Java, and the hashing there does it much better than you and I ever
2486800	2492480	could. And he's continued by giving a much more simpler one line hash function, which you'll see
2492480	2499360	here. Comment out the other one. So these are all hash functions. There's different ways of
2499360	2503120	implementing them. He's given three separate examples. The third one will go through soon.
2503760	2509840	This is a one line hash function using the objects dot hash. The caveat here, despite it being a
2509840	2516800	one line hash function, is that it should only be used if performance isn't critical, because it
2516800	2524080	does return an array. And every time it's invoked, it returns an array and also involves auto boxing
2524080	2529920	if we do pass a primitive type. And that takes us to an interesting part in these
2530560	2540240	hash code implementations, which which is threat safe lazy initialization. So lazy initialization
2540240	2547200	can be used if you believe your class is immutable. And if it considers or not considers it involves
2547760	2552240	the invocation of the hash code involves recalculating the hash code every every time it's
2552240	2559280	requested. And he says if you believe that most objects of this type will be used as hash keys,
2560080	2567120	then you should calculate the hash code when the instance is created. Otherwise, you might
2567120	2572320	choose to lazily initialize the hash code the first time hash code is invoked.
2573440	2578640	Some care is required to ensure that the class remains threat safe in the presence of a
2578640	2584240	lazily initialized field. Now we shall look into that because creating it to be threat safe is in
2584320	2591280	fact an important not even an acillary point here, but it's in fact very much related to this idea of
2591280	2596720	lazy initialization. But before we look at the threat safety example, let's firstly look at the
2596720	2601680	phone number example. And the phone number class doesn't require this kind of threat safety. He's
2601680	2607600	even stated that in the book. And what is lazy initialization? It's quite simple, really. We
2607600	2616240	have a private in hash code method, and we check if the result is zero. If there's no
2616240	2623680	cash result, we directly return that result. So that means every time the hash code method is
2623680	2629200	invoked, it doesn't have to go through this bit and do the computation slash calculation. If it's
2629200	2635360	cached, it could just be it could just be returned. And that's what lazy initialization is. And this
2635360	2642320	is automatically initialized to zero initially. So as I've stated here in the comment, apt for
2642320	2648640	immutable classes with expensive hash code calculation. Okay, now let's get to the threat
2648640	2654480	safety bit, which is in fact, despite it being a bit complicated at first, I found most interesting
2655200	2660640	in this item. I kind of enjoyed it, especially because I kind of do enjoy that part of Java,
2660640	2668000	the whole multi threading bit in shelf. So here's an example of lazy initialization
2669120	2675680	with threat safety. So we have this class called canna. And canna holds it's a it's an
2676320	2682400	this class is atomic as we're using the atomic integer method. So atomic means and competing
2682400	2688880	atomic means the either the change happens, or it doesn't happen. I always understood
2688880	2694240	atomic operations in the context of a database. So a good example is something like a bank
2694240	2699440	transaction. You either want the money to go go through, or you don't want it to go through at all.
2699440	2706640	It's very binary in that sense, no pun intended. And that's what an atomic computation is. There's no
2706640	2713440	there's no murky territory. There's no half of the computation happening. So we're using the count
2713440	2717600	of type atomic integer. And then we have we have another hash code value here,
2718800	2724640	a field value of also atomic integer. We have the constructors whatnot, we're setting the count
2724640	2728800	getting the count forget about all that, not forget about all that ignore all that for this context.
2730400	2736400	And then we have the hash code method. And the hash code method. Remember, all of this is still
2736400	2744640	using the atomic integer. And here, though the hash code is computed lazily, it's still the same
2744640	2749840	thing that we saw in the phone number class, where we're checking if the value is there checking if
2749840	2757440	the value is equal to zero, only if it's equal to zero, where we're setting the value and and passing
2757440	2763680	it, we're setting the value and then returning it. If not, if it's not equal to zero, that means
2763680	2768320	the value has been cached. So we just return that value straight away. So that's the lazy
2768320	2775280	initialization bit. But now we get to the thread safety bit, the multi threading bit. So I've started
2775280	2782480	two threads here, t1, t2. And they're both they both got two counters. So firstly, I've got an
2782480	2788800	instance of counter called count counter, of course, of the constructs, I've initialized that with 10.
2789760	2797600	And then I've created two threads that sets the count that that changes the count concurrently.
2798160	2804640	So two threads are started. So here, since we've used t1 dot join and t2 dot join,
2804640	2810080	because of the use of this join method, only the final state of the counter, that's this one here,
2810080	2815040	this object will be used, in this case, for get count, but for anything else, because the main
2815120	2822800	thread waits for both child threads to finish, finish execution. So there are two threads spun
2822800	2828640	up and there's a main thread, of course, that'll wait until both threads finish execution by using
2828640	2835440	join. And since the atomic integer has been used, the value will either be 15 or 20. It's atomic,
2836080	2842800	because the type for the hash code is atomic. And 15 and 20, of course, comes from this set
2842800	2849360	count that we used here. So depending on which thread finishes first, it'll always be the final
2849360	2854960	state will be reflected. So if I maybe write it a couple of times, this is how it came. Final count
2854960	2864160	and so the final count is, so the final count is 20. And the hash code also comes as 20. But I think
2864160	2872240	that's because the value is cached here. So if I run that a couple of times, let's see if at one
2872320	2879040	point, it's always the second thread that finishes last. So it's passing that value. But
2879760	2887520	let's say I change this, I don't know, I multiply this by 21, for some reason, and I run it again.
2887520	2891840	In this case, the hash code value will change. And then if I run it again, now it's going to keep
2891840	2896640	returning that because that value is cached. And the point being, because we're using
2897520	2901600	type atomic integer, these operations will be atomic. And this is what
2902240	2908800	Joshua Block means by creating lazy initialization to work with thread safety. So
2908800	2913520	in this case, really, this bit doesn't matter too much. What matters is when we declare the
2913520	2922800	hash code value, we use a type of atomic integer that ensures it's thread safe. So a few caveats
2922800	2929440	here, the hash code initialization field value should not be the hash code of a commonly created
2929440	2936960	instance. So that initial value we set for the hash code calculation, this is not a good example.
2936960	2943280	If we go back to the phone number class, this initial value we set, it shouldn't be the hash
2943280	2948640	code of a value that's commonly created, pardon me, not a commonly created value, a commonly
2948640	2953440	created instance or some kind of object that's used quite a lot. So that initialization value,
2953440	2958320	because that would obviously defeat the purpose of caching as it'll constantly be changing.
2958880	2964160	And the other thing, and this is really important, like what Don Knuth stated, oh, it wasn't Don
2964160	2969600	Knuth, wasn't it? It's apocryphally attributed to Don Knuth, but the root of optimization,
2970480	2978960	sorry, I'd push it back. The root of all evil is premature optimization. So always choose
2978960	2987040	accuracy over optimization. And the point is poor quality hash functions that are inaccurate
2987040	2991440	will degrade hash tables to the point of being unusable. It's kind of connected to that previous
2992160	2996880	point where we just set one constant value that legally makes sense, but would make a
2996880	3004480	terrible hash function. So Joshua Bock states, do not be tempted to exclude significant fields
3004480	3011360	from the hash code computation to improve performance. So always pick accuracy of optimization,
3011360	3018000	especially with modern CPUs these days. Like why would you? Well, why would you? It makes more
3018000	3024320	sense to focus on accuracy because there's pretty much infinite compute in the modern world.
3024880	3030160	Or as he's put it here, in particular, the hash function may be confronted with a
3030880	3037280	large collection of instances that differ mainly in regions that you've chosen to ignore. If this
3037280	3043680	happens, the hash function will map all these instances to a few hash codes and programs that
3043920	3055600	run in linear time. Sorry, I'd push it back. If this happens, the hash function will map all
3055600	3063120	these instances to a few hash codes and programs that should run in linear time will instead run
3063120	3069920	in quadratic time. So if we take this class example, this is an example of a poor implementation
3069920	3077360	of the hash code. Last name in this person class, did I say class example? If we take this person
3077360	3082720	class example, last name of this class is a significant field, obviously. But in the hash
3082720	3089680	code, we've ignored it. Now, what that would do is to put it more clearly, I use strategy PD,
3089680	3095680	because I struggled to articulate that. If we create a large collection of person objects,
3095680	3102080	so from this class, that differ mainly in their last name field, so this field that we've ignored.
3104320	3109840	The hash function implemented in the person class will be of poor quality and the hash
3109840	3116000	based data structure, so like a hash map, that use it will experience many collisions. This can
3116000	3121040	lead to poor performance and even course programs that should run in linear time to run in quadratic
3121040	3126720	time as the book suggests. So I'll propose ignoring significant fields like what we've seen here.
3127280	3134560	One example, just like a real world implementation is prior to Java 2, the string hash function
3134560	3143360	in fact used at most 16 evenly spread characters to calculate the hash code. However, unfortunately,
3144000	3150800	any string with more than 16 characters, as he said he has things such as URLs, would give
3151040	3157920	a low quality hash function or a poor hash function essentially, as the name suggests.
3158880	3164880	And that would be bad, that's the point I'm trying to make here. So keep the hash function
3164880	3169840	flexible and open for future change, which is kind of, isn't that one pattern in the
3169840	3176480	solid principles in object oriented programming. So make sure that's flexible and not static in
3176480	3183200	like the string hash function prior to Java 2. And then the other important point is don't provide
3183200	3189520	a detailed specification for the value returned by hash code, so clients can't reasonably depend on
3189520	3196000	it. This gives you the flexibility to change it. Because if you do have a detailed specification,
3196800	3204960	then people might rely on the hashing algorithm when clients use your class and also make it hard
3204960	3210160	to do this open for future change bit, because the hash function isn't flexible. And so an example
3210160	3217120	here is in fact the string class where if you can see here, people will rely on this formula for
3217120	3223120	calculating the hash function. And that makes this hash code method less flexible. So a good example
3223120	3228480	would be to keep the hashing algorithm hidden, like what we've seen here where all you see here is
3228480	3233760	return objects dot hash name and age, we don't know what the hashing algorithm is in the object
3233760	3242720	dot hash. So that's what he means by not not being explicit or specifying how the the hash
3242720	3249680	code is calculated. Because as he states, if you leave the details unspecified, and a flow is found
3249680	3255680	in the hash function, or a better hash function is discovered, you can change it in subsequent in a
3255680	3262960	subsequent release. And then to end, he states, in summary, you must override hash code every time
3263040	3270240	you override equals, or your program will not run correctly. Your hash code method must obey
3270240	3276480	the general contract specified an object, that's the object class, and must do a reasonably,
3277520	3282800	and must do a reasonable job assigning unequal hash codes to unequal instances.
3284160	3290320	That was also a bit of a long item. And I did feel like I can't mess up a few parts in that
3290320	3296720	item. Got feeling. I don't know what I'm probably see when I'm editing the video. If I did, I
3296720	3302480	apologize. Please double check everything I've stated here. And if I made some significant
3302480	3307600	blunders, I'll try and correct them in some way, either in the description or in the video itself.
3308960	3316320	Nonetheless, I'm going to try my best. Because that's all one could do. Appreciate it. I shall see
3316320	3320640	you in the next one. Item number 12, which I've already started on. I don't know why I'm doing
3320640	3325280	this if you can see the book. Okay, there's the evidence that I've started on item number 12,
3325280	3332240	which states always override to string. So in that one, cheers.
