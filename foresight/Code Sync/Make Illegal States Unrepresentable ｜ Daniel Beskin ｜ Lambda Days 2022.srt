1
00:00:00,000 --> 00:00:23,760
We're here to talk about this great quote up there by Jaron Minsky, make legal states

2
00:00:23,760 --> 00:00:30,320
unrepresentable. And although it sounds quite simple, I find that the consequences of it are

3
00:00:30,320 --> 00:00:37,520
quite profound. But before we actually begin and dive in, let's start with kind of a short story

4
00:00:37,520 --> 00:00:42,240
as an introduction. So it's the middle of the night and you're sleeping peacefully.

5
00:00:42,880 --> 00:00:48,560
And suddenly you get a call and you're being informed that the production system is crashing.

6
00:00:49,520 --> 00:00:57,760
And after a few minutes of furious debugging, you find this exception that happens. Someone

7
00:00:57,760 --> 00:01:04,400
accessed an empty optional value. And how can that be? You ask yourself. And so you dig a little

8
00:01:04,400 --> 00:01:11,120
deeper and you find this wonderful code. So someone unwrapped an empty option value. And

9
00:01:11,120 --> 00:01:16,720
you read this comment. This is safe. Registered users always have email. And it's a very nice

10
00:01:16,800 --> 00:01:23,280
comment. And the old caps are stressing the right points. And it's a very reasonable assumption

11
00:01:23,280 --> 00:01:29,440
because registered users should have emails and the product manager also required that as well.

12
00:01:29,440 --> 00:01:37,280
So what went wrong? And basically what happened is that we entered an illegal state of our system

13
00:01:37,280 --> 00:01:42,560
and doesn't really matter how we got there. But these sorts of situations happened all the time.

14
00:01:42,560 --> 00:01:48,400
I'm sure most of you had some experience seeing some error of this kind happening to you.

15
00:01:48,880 --> 00:01:54,640
And those things can be avoided. And I would say they must be avoided because all would like to

16
00:01:54,640 --> 00:02:01,760
have a good night's sleep. But this is what we're here to talk about. How to make these illegal

17
00:02:01,760 --> 00:02:07,680
states unrepresentable. How to make it impossible to create software that enters those illegal states.

18
00:02:08,640 --> 00:02:16,720
So today we're going to discuss this quote. What it actually means. We'll break it down into

19
00:02:16,720 --> 00:02:24,080
smaller parts. Then I'll show some simple techniques to try to achieve this ideal of making

20
00:02:24,080 --> 00:02:28,640
illegal states unrepresentable. And we'll conclude with seeing what are the sort of benefits that

21
00:02:28,640 --> 00:02:35,840
you might expect to reap in case you actually follow this principle. So this is mostly a beginner

22
00:02:35,840 --> 00:02:41,120
friendly talk. So don't expect some mind blowing techniques. But I do hope that the

23
00:02:41,120 --> 00:02:45,680
perspective I am about to show is useful even for more experienced developers.

24
00:02:47,520 --> 00:02:53,520
So as far as I know this quote was created in the context of working on a financial system.

25
00:02:53,520 --> 00:03:01,520
So Jaron Minsky is, was working on Jane Street. And I can imagine that making illegal states

26
00:03:01,520 --> 00:03:05,680
unrepresentable in the financial system is very, very important because you probably don't want

27
00:03:06,720 --> 00:03:12,960
to lose transactions or money or whatever. So let's dive in and figure out what it means to

28
00:03:12,960 --> 00:03:20,080
that an illegal state is unrepresentable and how do we define it. So we start with the state.

29
00:03:20,080 --> 00:03:26,400
So what is the state of a program? So imagine your whole application running and take like a

30
00:03:26,400 --> 00:03:31,920
single, single snapshot in time with all the variables and all your variables, threads,

31
00:03:31,920 --> 00:03:37,280
function calls, whatever. So single snapshot of your program. So this is an example of such

32
00:03:37,840 --> 00:03:42,000
states. So you have some variable assignments. You have maybe registers,

33
00:03:42,000 --> 00:03:45,840
heap allocations, whatever. Threads are running. Functions are about to be called.

34
00:03:46,960 --> 00:03:52,080
So this is a single state of the system. So obviously a real system will have many, many,

35
00:03:52,080 --> 00:03:59,200
many states. But for the purposes of this talk, we're going to kind of zoom out and from the

36
00:03:59,200 --> 00:04:06,160
details of registers and threads and like, and just have like a conceptual picture of the different

37
00:04:06,160 --> 00:04:12,800
states of the system. So this is our program's state space. All the different states, it can find

38
00:04:12,800 --> 00:04:19,040
itself in. So, but some states are illegal. That means that if you enter that state, something

39
00:04:19,040 --> 00:04:23,440
bad will happen. The program will crash. An exception will be thrown. Maybe a business rule

40
00:04:23,440 --> 00:04:28,320
will be violated. But something, whatever it is, it's something that's bad for your system and

41
00:04:28,320 --> 00:04:34,480
something that you would like to avoid. So of course, what's considered illegal is very context

42
00:04:34,480 --> 00:04:40,080
dependent and it depends on what you care about at the moment and the various tradeoffs. But let's

43
00:04:40,080 --> 00:04:48,000
assume that we can recognize an illegal state once we see it. And so the picture I'm showing here

44
00:04:48,080 --> 00:04:52,560
is that we have like a huge state space and have a few legal states. But usually the reality is much

45
00:04:52,560 --> 00:04:58,480
worse. Usually you have a lot, a lot of states that are actually illegal. And so hitting them

46
00:04:58,480 --> 00:05:03,280
and usually by accident is just a matter of time. You walk around your kind of state space and,

47
00:05:03,280 --> 00:05:07,920
and just accidentally stumble on something illegal. And that's, that's quite likely to happen just

48
00:05:08,000 --> 00:05:18,720
like the registered user in the previous example. So let's zoom in a bit and enter this diagram. So

49
00:05:19,440 --> 00:05:24,800
a typical program will probably be moving between lots of states. Hopefully, and, and we can assume

50
00:05:24,800 --> 00:05:30,880
usually between legal states, which are okay for a system. But sometimes you'll probably by accident

51
00:05:31,520 --> 00:05:37,200
hit an illegal state and your system might crash or violate some rule or do something bad. And

52
00:05:37,200 --> 00:05:41,440
usually if you got one illegal state, you probably will get another illegal state.

53
00:05:42,880 --> 00:05:46,640
And this is not good. And this is what the sort of things that we would like to avoid

54
00:05:46,640 --> 00:05:52,640
in the context of this quote and probably just in general in programming. So let's zoom in a little

55
00:05:52,640 --> 00:05:58,720
more. So, so as high level programmers, we typically don't think about registers and threads and,

56
00:05:58,720 --> 00:06:04,480
and, and the heap and the like. And as functional programmers, we typically want to represent as

57
00:06:04,480 --> 00:06:10,640
much as possible of our application as functions. So imagine that this is this function signature

58
00:06:10,640 --> 00:06:16,640
here is some part of your system. You have some inputs, you have some output, and, and, and you,

59
00:06:16,640 --> 00:06:21,120
you would like to analyze what's possible and impossible here. So what do I mean that an illegal

60
00:06:21,120 --> 00:06:27,520
state is representable? It's that there is some combination of the inputs ABC that would, that

61
00:06:27,520 --> 00:06:31,600
would get you into an illegal state. Okay, that would mean that the state is representable. You

62
00:06:31,600 --> 00:06:37,440
can find such inputs and you'll, and you'll get an illegal state directly in your system.

63
00:06:38,080 --> 00:06:42,800
And what we want, what we strive to achieve is to make it impossible for to find such inputs

64
00:06:42,800 --> 00:06:48,720
that would get us into this illegal state. So imagine that it's, it's literally impossible

65
00:06:48,720 --> 00:06:53,920
to write down such inputs that would get you into a legal state that you cannot get there at all.

66
00:06:55,120 --> 00:06:59,120
And all you can do is kind of walk around the legal states and just never worry about

67
00:06:59,120 --> 00:07:05,600
entering the illegal, the illegal red dots here. And so this should be possible not because you

68
00:07:05,600 --> 00:07:08,880
checked and double-checked your inputs and not because you covered everything with tests, but

69
00:07:08,880 --> 00:07:14,320
because you make it strictly impossible to write down those inputs that would, would get you into

70
00:07:14,320 --> 00:07:21,840
an illegal state. So that's at least the ideal that we want to, want to reach. And question is

71
00:07:21,840 --> 00:07:26,080
whether it's a reachable idea, ideal, can you, can you actually do that? And probably the answer

72
00:07:26,080 --> 00:07:30,640
is generally no. You probably can't avoid all illegal states, but I would claim that every step

73
00:07:30,640 --> 00:07:34,720
you make in that direction is, is a good step and probably is improving your software in some,

74
00:07:34,720 --> 00:07:40,240
in some way or dimension. Also, question is whether it's worth it. I'm going to show you some,

75
00:07:40,240 --> 00:07:44,720
some techniques that you have to apply to your code and then maybe there's some, some costs and

76
00:07:44,720 --> 00:07:50,080
it might, might not be worth it. And that's, again, can be, can be true that's maybe too

77
00:07:50,080 --> 00:07:55,520
expensive, but the, the sort of techniques I'm about to show you now are quite, quite lightweight

78
00:07:55,600 --> 00:08:02,320
and hopefully the cost-benefit ratio is, may, would make them worth it. And although it's

79
00:08:02,320 --> 00:08:08,240
possible to, to avoid illegal states in pretty much every paradigm and language, but strongly,

80
00:08:08,240 --> 00:08:13,760
strongly typed functional programming is, is very good at it. So because types makes it easier to

81
00:08:13,760 --> 00:08:19,760
define, define our state, state space and, and functional techniques make, makes it, once you

82
00:08:19,760 --> 00:08:25,520
define and recognize an illegal state, they, they, they make it easier to avoid various illegal

83
00:08:25,520 --> 00:08:39,200
states. Okay, so now that we, we know what are illegal states, so slide, slide the gray,

84
00:08:39,200 --> 00:08:47,280
digression into something else. So I'm not sure what is or so, but empirical evidence shows that,

85
00:08:47,440 --> 00:08:53,600
that people really, really like coffee. I myself don't drink coffee, so I can't really relate,

86
00:08:54,160 --> 00:09:00,080
but apparently making coffee is very, very complicated. And here's a, a diagram that's,

87
00:09:00,080 --> 00:09:05,520
that's obviously has lots of different states and I'm sure some of them are illegal. And since I

88
00:09:05,520 --> 00:09:09,600
don't know much about coffee, I thought maybe it will be a good idea to use it as kind of an example

89
00:09:09,600 --> 00:09:16,560
domain to, to, for, for this talk that we can explore and try to kind of make more, more legible

90
00:09:16,560 --> 00:09:24,480
for, for our purposes. So, so imagine that you're tasked with programming this, this coffee making

91
00:09:24,480 --> 00:09:30,800
robot. So lots of things can go wrong when you program a robot, I imagine, especially one that

92
00:09:30,800 --> 00:09:36,400
does something as complicated as creating coffee, because coffee drinkers are, are very, very specific

93
00:09:36,400 --> 00:09:41,520
about what and how they are willing to drink. So there's a huge state space here and lots of

94
00:09:41,520 --> 00:09:46,160
things that can, can go wrong. And we'll just try to tackle like small sub-problems from this

95
00:09:46,160 --> 00:09:51,920
domain and see, see how we can improve what we see. So we start with, with the simplest part I,

96
00:09:51,920 --> 00:09:58,320
I could possibly imagine here, ordering coffee. So again, imagine that you are, you are doing

97
00:09:58,320 --> 00:10:02,160
this kind of proof of concept of your, of your robot. You want to show that it can actually do

98
00:10:02,160 --> 00:10:07,840
something useful. So you want to specify the, how to order a cappuccino, which is, so I hear a popular

99
00:10:07,840 --> 00:10:13,600
drink. So your users have to specify what kind of milk they want in the cappuccino. And apparently

100
00:10:14,560 --> 00:10:19,520
milk choice is also a complicated topic. So milk is not some trivial type, but, but in the

101
00:10:19,520 --> 00:10:25,520
enumeration of various, various, various options. So after successfully making cappuccino, you think,

102
00:10:25,520 --> 00:10:30,800
okay, let's, let's see. It kind of works. Let's, let's do something more, add something to, to a

103
00:10:30,800 --> 00:10:35,360
repertoire to make it more interesting. So since you already know how to do cappuccino espresso,

104
00:10:35,360 --> 00:10:40,480
apparently according to this picture there is, is pretty much the same thing, but minus the milk.

105
00:10:40,480 --> 00:10:44,720
So you make your milk an optional, optional argument in this case. So, so that you don't

106
00:10:44,720 --> 00:10:49,520
require it anymore. And now if you don't have milk, you make an espresso espresso. If you have milk,

107
00:10:49,520 --> 00:10:56,400
you, you do cappuccino. And now let's set another one, latte. So latte is basically, apparently

108
00:10:56,400 --> 00:11:01,840
again, by this diagram is just the same as cappuccino, but with more milk. And so we have a

109
00:11:01,840 --> 00:11:07,760
problem. We have an ambiguity. Both cappuccino and latte require, require milk. So we have to

110
00:11:07,760 --> 00:11:13,600
somehow tell them apart which, which order are we talking about. So in order to make it easier

111
00:11:13,600 --> 00:11:18,160
to figure out what's going on, we were going to add another enumeration, the drink type,

112
00:11:18,160 --> 00:11:22,960
which will actually tell us what kind of order are we dealing with here. And so we have kind of

113
00:11:23,040 --> 00:11:28,480
three cases for cappuccino espresso and latte. And that's a nice way to kind of future proof

114
00:11:28,480 --> 00:11:33,280
ourselves from future, future drinks that we might want to add, because now we could easily add them

115
00:11:33,280 --> 00:11:39,840
to our enumeration. So, so that's, that's a nice, nice bonus. And so now that you, you have some

116
00:11:39,840 --> 00:11:44,160
basic drinks and, and you know how to make them, you want to show off how your robot can actually do

117
00:11:44,160 --> 00:11:48,560
cause something more complicated. So you want to do two fancy drinks in this case. So want to

118
00:11:48,560 --> 00:11:53,920
try and do affogato and Irish coffee. Fortunately, botanary require more, more ingredients. So we

119
00:11:53,920 --> 00:12:00,240
need to add gelato and, for the affogato and the cream and whiskey for, for Irish coffee. And that's

120
00:12:00,240 --> 00:12:06,000
a good place to stop for a moment and take a look at what we have. So we support, support five different,

121
00:12:06,000 --> 00:12:11,120
different types of drinks, which is nice, but we have lots of various optional values. It's

122
00:12:11,120 --> 00:12:16,960
completely non-obvious, which, which combinations are actually legal here. So can, can I mix milk

123
00:12:17,040 --> 00:12:20,960
into my Irish coffee or some, some such. It's not obvious from the type sense.

124
00:12:23,600 --> 00:12:28,160
And it's easy to get confused. So let's, let's try to step back for a moment. So what is the

125
00:12:28,160 --> 00:12:32,960
issue here? So this is again kind of a simplified state diagram of what, what we want to achieve. So

126
00:12:33,600 --> 00:12:38,800
we have five legal states, five states that we actually want, want to support. So which one

127
00:12:38,800 --> 00:12:43,680
corresponding to some drink that we have in our system. But we also have various combinations

128
00:12:43,760 --> 00:12:48,640
that, that are illegal in some sense. So for example, espresso, espresso with gelato is just

129
00:12:48,640 --> 00:12:53,840
redundant because we're just rediscovered affogato, but though some drinkers might be offended.

130
00:12:55,200 --> 00:13:00,880
But Irish coffee without whiskey is obviously an illegal state if I ever seen one. So it makes no

131
00:13:00,880 --> 00:13:06,560
sense at all. And there are many other states here that, that many combinations of various

132
00:13:06,560 --> 00:13:12,240
inputs that we can get here that are completely illegal and make no sense. So let's, let's think

133
00:13:12,240 --> 00:13:16,880
more concretely why, why this is a problem. So suppose we have some low level function that

134
00:13:16,880 --> 00:13:21,600
actually tells the robot how to prepare the Irish coffee. And it has to take two arguments,

135
00:13:21,600 --> 00:13:26,080
cream and whiskey, because that's, that those are the parameters that we need to specify for,

136
00:13:26,080 --> 00:13:30,160
for this drink. And imagine that you were trying to actually take an order and prepare the Irish

137
00:13:30,160 --> 00:13:38,320
coffee. So in case you are in the Irish coffee, Irish coffee order, you access the cream and whiskey

138
00:13:38,320 --> 00:13:44,080
and then, and then prepare Irish coffee. Now notice that we are accessing optional values

139
00:13:44,080 --> 00:13:50,240
and we are very careful here. We have a comment that says this is safe. That's probably okay,

140
00:13:50,240 --> 00:13:56,000
right? I mean, what, what could possibly go wrong? So, because it makes no sense to have empty

141
00:13:56,000 --> 00:14:01,840
values on, of cream and whiskey in case someone ordered an Irish coffee. So maybe just in case,

142
00:14:01,840 --> 00:14:05,760
because we don't want to be too troubled with debugging late at night, we will make it even

143
00:14:05,760 --> 00:14:10,240
more explicit. So we will throw a nice exception that has more, more information. So it might,

144
00:14:10,240 --> 00:14:14,720
might be nicer to debug, but it's really, really isn't possible. I mean, you can't have Irish coffee

145
00:14:14,720 --> 00:14:23,680
without cream and whiskey. And, and, and this is sort of an invariant that we're assuming over

146
00:14:23,680 --> 00:14:28,320
our code. In this case, the invariant is quite simple. Irish coffee always has cream and whiskey,

147
00:14:28,320 --> 00:14:32,720
but nothing is enforcing this invariant. We're kind of writing comment and have,

148
00:14:33,280 --> 00:14:37,520
have suffered from a wishful thinking that may, hopefully nobody will ever break this,

149
00:14:37,520 --> 00:14:42,560
this thing apart. But imagine that in the future, you're supporting reading orders from JSON files

150
00:14:42,560 --> 00:14:47,120
and someone messed up the format and then something is missing. Who knows? Something can

151
00:14:47,120 --> 00:14:52,000
happen and you can't write tests, tests to cover all of your flows in your system probably. And

152
00:14:52,000 --> 00:14:56,400
even less so, you can't write tests for future flows that someone might define, that are not

153
00:14:56,400 --> 00:15:00,240
defined right now. How, how can you protect against something that you don't even know that will

154
00:15:00,240 --> 00:15:06,480
exist in your system? And so, so, and you might be actually thinking that, okay, I'm very bad at

155
00:15:06,480 --> 00:15:13,920
designing data types and that's why I have this kind of bad, bad definition of, of an order. But

156
00:15:13,920 --> 00:15:18,720
that may be so. But the thing I'm trying to assert here is not something that happens in a single,

157
00:15:19,440 --> 00:15:23,040
in a single step. Usually, it kind of creeps up on you. You start with something small and

158
00:15:23,040 --> 00:15:27,920
gradually it increases, grows, and then becomes this huge thing full of illegal states that you

159
00:15:27,920 --> 00:15:33,040
can, you're really dependent on and can't, can't really disentangle from, from your system. And,

160
00:15:33,040 --> 00:15:37,520
and then you again enter this, this space where you have lots of illegal states and nothing to do

161
00:15:37,520 --> 00:15:50,640
about it. But we can, can do better, a lot better. So, sorry. So, so our problem here is that our

162
00:15:50,640 --> 00:15:56,560
type is in a sense too big for a problem. We have, we define some schema for possible, possible

163
00:15:56,560 --> 00:16:00,800
combinations of inputs and it's too big. Our state space contains lots of things that shouldn't

164
00:16:00,800 --> 00:16:08,320
be there. And algebraic data types are a really good way and methodology to, to create types of,

165
00:16:08,320 --> 00:16:13,840
of the right size, types that can actually fit our domain in a way that, that really is exactly

166
00:16:13,840 --> 00:16:20,080
what we want and nothing else. So, let's rewrite our data type as, as an algebraic data type in

167
00:16:20,160 --> 00:16:28,720
this case and some type or in enumeration in Scala syntax now. So, we're going, instead of writing

168
00:16:28,720 --> 00:16:32,720
coffee order where everything is placed to kind of in the top level with all the options, everything

169
00:16:32,720 --> 00:16:37,280
possible, we're going to split, split it up into various cases. So, we have a first case with

170
00:16:37,280 --> 00:16:42,560
Cappuccino. Cappuccino requires milk, so it's no longer optional. We have a case for espresso,

171
00:16:42,560 --> 00:16:47,520
which doesn't have any, any requirements. So, this, so it's just espresso. We have the case of

172
00:16:47,520 --> 00:16:51,440
Latte, which also requires milk, but there's no ambiguity anymore because now it's a separate

173
00:16:51,440 --> 00:16:56,560
case and there's no way to confuse one Cappuccino with the other. So, so, and again, the argument is

174
00:16:56,560 --> 00:17:01,840
no longer, no, no longer optional. And Afogato requires Gelato. So, this is again a required

175
00:17:01,840 --> 00:17:07,760
dependency and we cannot avoid it. And Irish and coffee, which is the, which was our stumbling block

176
00:17:07,760 --> 00:17:11,440
now has a required dependency on cream and whiskey and there's no ambiguity anymore.

177
00:17:12,320 --> 00:17:18,320
So, not only that it's now much, much clearer what is going on and what, what, what sort of states

178
00:17:18,320 --> 00:17:23,680
are legal here and what, what is the actionable data that we have and how to access it. It's

179
00:17:23,680 --> 00:17:28,480
literally now impossible to express the legal state I, I, I just described previously. So,

180
00:17:28,480 --> 00:17:32,480
the legal states in the previous slide are, are literally unrepresentable. You can't write down

181
00:17:32,480 --> 00:17:39,040
the code that, that actually enters those states. So, now we can, for example, in the,

182
00:17:39,120 --> 00:17:43,280
when preparing the Irish coffee, we can now safely better match our, on our order. And, and if it's

183
00:17:43,280 --> 00:17:48,160
Irish coffee, we know and the compiler provides us with access to both cream and whiskey. And

184
00:17:48,160 --> 00:17:53,680
it's definitely there and can be gone and, and can be missing. So, we don't need to assume any

185
00:17:53,680 --> 00:17:59,120
invariant about a call or code. Don't have to lie about it in comments. And no, no exceptions can

186
00:17:59,120 --> 00:18:04,960
be, can be thrown here or, or any other illegal states. And if we got to this point where it

187
00:18:05,040 --> 00:18:09,200
better matched than we have Irish coffee, we know for a fact that all requirements were met

188
00:18:09,200 --> 00:18:13,760
and nothing can go wrong in this, in this respect. And this is enforced by the compiler

189
00:18:15,040 --> 00:18:20,560
for every possible floor of our program. So, we don't have to try to cover, cover everything

190
00:18:20,560 --> 00:18:26,160
with tests. And it's also there, enforced there for the future as well, because the compiler does

191
00:18:26,160 --> 00:18:30,000
the same thing for all future flows as well. So, we don't have to worry about it again with tests

192
00:18:30,000 --> 00:18:37,600
that we cannot write even. So, the illegal state that I showed before is truly unrepresentable

193
00:18:37,600 --> 00:18:44,240
now. You cannot write it down. It cannot exist in the system. So, algebraic data types are, are a

194
00:18:44,240 --> 00:18:50,720
great, a great tool you can use to reduce the state space of your, of your problem domain. So,

195
00:18:50,720 --> 00:18:56,640
leading to fewer legal states and making the code generally more, more comprehensible. And this is

196
00:18:56,720 --> 00:19:01,920
done by making every assumption about your inputs completely explicit. So, in our case, we made

197
00:19:01,920 --> 00:19:07,760
every case to correspond to the assumptions about coffee orders that we have at the moment. And

198
00:19:07,760 --> 00:19:12,560
the values are now correct by construction. So, you cannot build an illegal order anymore because,

199
00:19:12,560 --> 00:19:17,520
because you made it impossible in the type to represent what, what is not supposed to be there.

200
00:19:19,120 --> 00:19:24,880
And so, once you do that, you're basically turning your flow into data. So, notice how we no longer

201
00:19:24,960 --> 00:19:30,000
have any conditionals. After, after pattern matching and figuring out that we are in the Irish

202
00:19:30,000 --> 00:19:34,320
coffee case, that's it. We don't have to do anything else. We don't have to ask, ask and be

203
00:19:34,320 --> 00:19:42,400
hopeful that the cream whiskey are present. It's there. It's accessible. And, and so, and so you,

204
00:19:42,400 --> 00:19:48,800
you don't have to worry about defensively programming against it. And, and nice bonus in

205
00:19:48,880 --> 00:19:53,600
statically type of programming language is where you, for pattern matches, you also have

206
00:19:53,600 --> 00:19:58,160
exhaustivity checking. So, in case someone adds another case or something else is changing,

207
00:19:58,160 --> 00:20:03,360
changing the compiler will have your back and help you figure out what's missing and what,

208
00:20:03,360 --> 00:20:08,320
what you have to add there to be able to handle everything correctly. So, you can't forget anything

209
00:20:08,320 --> 00:20:12,960
that you need and don't, can't forget to handle everything. And what's important, the compiler

210
00:20:12,960 --> 00:20:16,880
is not providing you with safe access to all the data that you need. You don't have to assume

211
00:20:16,960 --> 00:20:21,520
that it will be present when it might be not. It will definitely be there and you can't work

212
00:20:21,520 --> 00:20:28,560
around it. So, now that you, and you're basically free from thinking about illegal states and you

213
00:20:28,560 --> 00:20:33,600
don't have to engage in defensive programming all throughout your application. It's not a

214
00:20:33,600 --> 00:20:37,920
magical solution. You still have to kind of get the, the, the size of your algebraic data type,

215
00:20:37,920 --> 00:20:41,600
right? Because my initial example, the first coffee order is also an algebraic data type,

216
00:20:41,600 --> 00:20:47,520
but that one was too big for our state space. So, you still have to think, nobody is, is

217
00:20:47,520 --> 00:20:52,000
getting away from, from thinking, but still having this perspective and having algebraic

218
00:20:52,000 --> 00:20:57,280
data types as, as a tool that you can use to shape your state space is, is very, very useful.

219
00:20:58,880 --> 00:21:03,600
And so, this is, I think that algebraic data type, data types of all the features of functional

220
00:21:03,600 --> 00:21:10,240
programming are, is probably the, the best cost, cost benefit ratio out there. And if you're using

221
00:21:10,320 --> 00:21:15,440
them consistently all over your system, I think that, that will be a great improvement to, to the

222
00:21:15,440 --> 00:21:20,640
possible illegal states that you can or cannot represent. And if I were to start on, start on

223
00:21:20,640 --> 00:21:25,280
a deserted island or something or programming Java, that probably would be the one feature that I,

224
00:21:25,280 --> 00:21:29,440
I would like to have from functional programming. They're that, that useful.

225
00:21:30,080 --> 00:21:40,560
So, now we're back to our robot. So, let's try to tackle another scenario. So, successfully

226
00:21:40,560 --> 00:21:46,960
defeated the issue of coffee ordering. So, again, apparently that coffee drinkers have lots and

227
00:21:46,960 --> 00:21:51,680
lots of neat picks. For example, you can't just pour any amount of water on any amount of coffee,

228
00:21:52,480 --> 00:21:57,200
apparently. I don't know why. That would be wrong. So, imagine you have some, some function that

229
00:21:57,200 --> 00:22:01,680
does the pouring. So, take some waters, take some grounds and, and does, and pours water over the

230
00:22:01,680 --> 00:22:06,320
grounds. So, this function can easily lead us to an illegal state. So, you can just choose the wrong

231
00:22:06,320 --> 00:22:11,040
ratio of water and grounds. And there you go. You have a wrong, a wrong state and a coffee that was,

232
00:22:11,040 --> 00:22:16,400
that was spoiled by too much water or too little water or whatever. And so, we can do something

233
00:22:16,400 --> 00:22:23,600
like this. So, we define a new type called tasty ratio. And we only want to allow tasty ratios

234
00:22:23,600 --> 00:22:28,640
in our, in our function. And this seems that, like, that would be kind of better, because

235
00:22:28,640 --> 00:22:32,800
here we're explicit about what, what we actually want to achieve. But not really, because the

236
00:22:32,800 --> 00:22:37,360
definition of tasty ratio is pretty much the same thing. You just moved, sorry, you just shuffled

237
00:22:37,360 --> 00:22:43,840
around your problem into another place. You still can create tasty ratio instances with the wrong

238
00:22:43,840 --> 00:22:50,320
proportion of water and grounds. And so, although we claim that tasty ratio is a valid input,

239
00:22:50,320 --> 00:22:55,440
we do not enforce it in any way. So, it's, again, another illegal state that's waiting to happen.

240
00:22:56,320 --> 00:23:01,280
And since it can be represented in our system, most likely someone at some point will create an

241
00:23:01,280 --> 00:23:08,800
illegal instance of tasty ratio and something will be broken. And, and so, in this case, though,

242
00:23:08,800 --> 00:23:13,440
we have so many illegal states, because most, most combinations of water and grounds will

243
00:23:13,440 --> 00:23:20,000
probably be illegal. So, our state space is just full of illegal, illegal, illegal states. And just

244
00:23:20,000 --> 00:23:26,000
a few small number of possible, comparatively small number of, of combinations of, of water and

245
00:23:26,000 --> 00:23:30,960
grounds are actually legal. And what we want to achieve is to only be able to write down the

246
00:23:30,960 --> 00:23:35,840
legal combinations and making, writing all other combinations completely impossible. That's, that's

247
00:23:35,840 --> 00:23:43,040
our goal. So, so basically what we want is some kind of invariant on tasty ratio and invariant

248
00:23:43,040 --> 00:23:47,840
that, that tells us that water and grounds are in the right proportion, proportion. And we don't

249
00:23:47,840 --> 00:23:52,160
want to be checking it all over, over the place. We don't want to do defensive programming and

250
00:23:52,160 --> 00:23:57,760
kind of sprinkle our code with e-falses and exceptions and the like. So, so ideally, so

251
00:23:57,760 --> 00:24:02,720
whenever we have an instance of tasty ratio, it has to be, has to be correct and nothing else

252
00:24:02,720 --> 00:24:07,200
should be impossible. But unlike the invariant of coffee, of the coffee order, which was kind of

253
00:24:07,200 --> 00:24:11,600
simple, is that Irish, Irish coffee must have cream and whiskey. This invariant is, is a bit

254
00:24:11,600 --> 00:24:16,960
trickier to get right. And just using algebraic data types, you probably won't be able to easily

255
00:24:17,520 --> 00:24:22,000
enforce it in the types. Correct me if I'm wrong if you have a way of doing that, but probably

256
00:24:22,000 --> 00:24:26,640
not likely and won't be worth it. So instead we're going to use smart constructor. So smart

257
00:24:26,640 --> 00:24:32,720
constructor basically limits the way we can, we can build instances of our, of our values. So this

258
00:24:32,720 --> 00:24:37,200
is just called a specific way, but most languages have some equivalent of this. So first of all,

259
00:24:37,280 --> 00:24:42,960
we, we mark our constructor as private. So we can no longer instantiate instances of tasty

260
00:24:42,960 --> 00:24:50,000
ratio without directly from the constructor. And then we create our own legal, our own smart

261
00:24:50,000 --> 00:24:55,520
constructor that, that requires that everything is legal. So the contract of the make function is

262
00:24:55,520 --> 00:25:00,640
that it can take any inputs, but it will only produce a tasty ratio only if the inputs are

263
00:25:00,640 --> 00:25:04,800
actually valid. And nothing else is possible. And this will be the only way to construct tasty

264
00:25:04,800 --> 00:25:12,400
ratios in our, in our program. And so the logic itself is probably not that complicated. So we

265
00:25:12,400 --> 00:25:17,840
just verify the, verify the right amounts. But it is crucial to get this right. So this is kind of

266
00:25:17,840 --> 00:25:23,040
the safe kernel that you have in your program that users will now assume is correct and can

267
00:25:23,040 --> 00:25:31,040
rely on in all other places. So if you got this right, people can, can rely on this invariant

268
00:25:31,040 --> 00:25:36,160
now for every place where they stumble upon tasty ratio. So now after, after making the smart

269
00:25:36,160 --> 00:25:41,360
constructor and, and forbidding the creation of tasty ratio without, without calling the smart

270
00:25:41,360 --> 00:25:46,400
constructor, now the, the, this function is, is safe. It actually does what, what it promises.

271
00:25:46,400 --> 00:25:50,640
You cannot call it with an illegal tasty ratio because there are no tasty ratios that are

272
00:25:50,640 --> 00:25:57,760
illegal in our system. It's just not possible anymore. So more generally, generally smart

273
00:25:57,760 --> 00:26:03,920
constructors are a great way of enforcing diverse invariants. So we can find many examples. So in

274
00:26:03,920 --> 00:26:08,480
this case, our signature is, is kind of, again, we have a wishful comment about something about age

275
00:26:08,480 --> 00:26:12,880
and, and, and alcohol restrictions, but, but it's not really an invariant that's enforced

276
00:26:12,880 --> 00:26:17,920
anywhere. Just wishful thinking. But if you apply the correct smart constructor, you can probably

277
00:26:17,920 --> 00:26:22,800
get it, get this, this type that will enforce it. It's not possible anymore to, to do the illegal

278
00:26:22,800 --> 00:26:27,920
action of, in this case, pouring whiskey into Irish coffee. And you can have more examples. So again,

279
00:26:27,920 --> 00:26:32,720
the first, the, the first, the top signature is always some wishful thinking and a type that

280
00:26:32,720 --> 00:26:37,600
doesn't really, really represent well what, what we want. And the second is, is a corrected version

281
00:26:37,600 --> 00:26:43,120
where we enforce something in our, on our type and, and usually we close it off with a smart

282
00:26:43,120 --> 00:26:48,000
constructor so that nobody can access the, the illegal states. And notice that we didn't make

283
00:26:48,080 --> 00:26:55,040
tasty ratio any smaller by, by creating the, the, the smart constructor. But we can, we have an

284
00:26:55,040 --> 00:26:59,280
illusion that tasty ratio is now a smaller value that doesn't have illegal states just because we

285
00:26:59,280 --> 00:27:04,400
made it impossible to create them. So we can program as if the state space really is now smaller and

286
00:27:04,400 --> 00:27:09,200
illegal states are unrepresentable. And again, it's very important to get the smart constructors

287
00:27:09,200 --> 00:27:14,400
right. So it's a one-time effort, which is probably worth it because you just cover it in one space,

288
00:27:15,040 --> 00:27:20,960
and then all of your flows can, can rely on the fact that the invariant, all the invariance you

289
00:27:20,960 --> 00:27:27,760
want are actually enforced. So smart constructors are a great way to enforce diverse invariance

290
00:27:27,760 --> 00:27:32,800
and with compiler assistance. So, assistance. So the moment you got it right from there on,

291
00:27:32,800 --> 00:27:37,840
you know that the compiler won't let anyone bypass this invariant that you're trying to enforce.

292
00:27:38,880 --> 00:27:43,040
And as a bonus, our type signatures are becoming, becoming kind of self-documenting because our

293
00:27:43,040 --> 00:27:47,280
types are now representing actual invariance that we care directly, directly in our code. And it's

294
00:27:47,280 --> 00:27:51,680
better than comments because they will never go out of date. The compiler is there to keep everything

295
00:27:51,680 --> 00:27:57,440
in check. But we do have to be careful when defining smart constructors because, as I said,

296
00:27:57,440 --> 00:28:02,480
you have to get that function right. And so unlike algebraic data types where you are kind of correct

297
00:28:02,480 --> 00:28:08,240
by construction, smart, smart constructors are usually have to do some unsafe work to make

298
00:28:08,240 --> 00:28:13,120
sure that everything else is safe. And so when possible, if you can represent something with

299
00:28:13,120 --> 00:28:18,560
an algebraic data type, that's probably the preferred way. But when, when they work, smart

300
00:28:18,560 --> 00:28:28,080
constructors are a great tool for excluding illegal states. So one, one last, last problem to

301
00:28:28,080 --> 00:28:35,920
tackle with a robot. So brewing coffee is, again, no surprise, a complicated process as well.

302
00:28:36,480 --> 00:28:42,080
And let's try to model a small part of brewing coffee. So here's one, one way to kind of

303
00:28:42,080 --> 00:28:46,960
model this, this process. So we have this, this kind of imperative interface that you might,

304
00:28:46,960 --> 00:28:53,520
you might expect for operating a robot with a bunch of kind of low-level commands that,

305
00:28:53,520 --> 00:28:57,760
that can be used for, for the brewing stage. And assuming that someone actually implemented

306
00:28:57,760 --> 00:29:02,800
this at the robot level, we can write the code for, for preparing for brewing, not the actual

307
00:29:02,880 --> 00:29:06,960
brewing, but just the preparation. And so this looks pretty informative. We just call, call the

308
00:29:06,960 --> 00:29:15,600
various actions in order. Anyone sees a bug here? So, disgustingly, we forgot to rinse the filter,

309
00:29:15,600 --> 00:29:20,400
and now our users are going to drink this paper-tasting coffee, and, and probably we'll just

310
00:29:20,400 --> 00:29:26,720
throw our, quit our robot and, and, and we will lose customers. So, so the reputation of the

311
00:29:26,800 --> 00:29:32,400
robot depends on it, and we'll, we just messed up a good cup of coffee. But, but more seriously,

312
00:29:33,120 --> 00:29:38,400
this, this code is very, very open to, to potential bugs, bugs that, that is illegal states.

313
00:29:39,360 --> 00:29:44,240
So you can, you can forget action just like, just like I did right now with the filter answering.

314
00:29:44,240 --> 00:29:48,320
You can mix up the order. You can, you can duplicate actions. Everything can happen here. It's,

315
00:29:48,320 --> 00:29:53,600
it's full of possible legal states. And if it's, if it's possible, we're most likely to hit it at

316
00:29:53,600 --> 00:30:00,640
some point. Maybe a refactoring gone, gone wrong or something, something else will can go wrong.

317
00:30:00,640 --> 00:30:06,480
And the problem is here that even if, if we do, do mix something up, the compiler won't help us.

318
00:30:06,480 --> 00:30:11,680
It doesn't know anything about it. So just compile fine and, and just be wrong. So again,

319
00:30:11,680 --> 00:30:15,680
this is our desired state space. It's quite simple. It doesn't really have many, many things that,

320
00:30:15,680 --> 00:30:22,400
that it has to do. But again, our actual code is open to various illegal state transitions that

321
00:30:22,400 --> 00:30:27,920
we can, we can make that we would like to avoid and make them compile time and possible to actually

322
00:30:27,920 --> 00:30:35,840
write down. So we can improve as well. So a big part of the problem here of the issue is that,

323
00:30:35,840 --> 00:30:40,560
is the imperative interface. It's, it's, it just tells us the actions we, we want to perform.

324
00:30:40,560 --> 00:30:44,640
It doesn't have any information, very little information about the intent of this action

325
00:30:44,640 --> 00:30:49,920
and the consequences of it. So, so if, if we have a unit return time of something, it doesn't

326
00:30:49,920 --> 00:30:54,480
really tell us much about what did we want to achieve or what actually happened. So, and so,

327
00:30:54,480 --> 00:30:59,840
since so little is reflected in the types, it's, it's not, it's not a surprise that the compiler

328
00:30:59,840 --> 00:31:04,080
can't really help us because the compiler works usually with types and that's, that's its way to

329
00:31:04,080 --> 00:31:08,560
support us. And so the solution will be to become more declarative. So we're leaving the

330
00:31:08,560 --> 00:31:12,880
imperative, imperative interface behind and, and trying to make it more declarative. So we start

331
00:31:12,880 --> 00:31:18,000
by just adding, adding expectations. So what, what, what we aim to achieve on every action. So,

332
00:31:18,000 --> 00:31:23,680
for example, the place filter function now, once invoked, will return a filter placed value,

333
00:31:23,680 --> 00:31:29,200
which will correspond to the fact that the filter was indeed placed. And so on for all the other

334
00:31:29,200 --> 00:31:34,400
functions. And we're not done yet. So we have another, we do have some various prerequisites. So

335
00:31:34,400 --> 00:31:39,680
we, there's some ordering that, that has to go on here that, that is otherwise illegal. And so

336
00:31:39,680 --> 00:31:44,640
we're going to define prerequisites as function arguments. So placing a filter cannot occur

337
00:31:44,720 --> 00:31:49,760
unless the filter was folded before. So we make the explicit in our function by requiring an

338
00:31:49,760 --> 00:31:54,080
argument that the filter was actually folded. And the same thing goes for rinsing the filter,

339
00:31:54,080 --> 00:31:58,560
which can't happen unless the filter was placed and the water was heated. And the same thing for

340
00:31:58,560 --> 00:32:03,120
grounds that you, if you want to add them, they must be actually ground. And the filter must be

341
00:32:03,120 --> 00:32:08,880
rinsed to prevent the bug from, from before. And so basically what we were doing here is we're

342
00:32:08,880 --> 00:32:15,360
encoding kind of business rules directly in our signatures. And once we do that, in turn, it

343
00:32:15,360 --> 00:32:24,080
means that code that violates those rules won't even compile. It becomes literally unrepresentable.

344
00:32:24,080 --> 00:32:29,360
And so we can now implement our prep flow from before. So instead of having our implementation

345
00:32:29,360 --> 00:32:34,240
returning unit, we now have a more informative, more informative signature that tells us what

346
00:32:34,240 --> 00:32:38,960
actually was achieved during that process. So after we finished the prep, water was heated

347
00:32:38,960 --> 00:32:44,240
and grounds were actually added. So there's no avoiding that now. Every implementation of this

348
00:32:44,240 --> 00:32:52,560
code has to, to do something about it. And so since our types are so, so descriptive, now again,

349
00:32:52,560 --> 00:32:57,680
again, this ability to kind of follow the types to implement our flow. So this is very similar to

350
00:32:57,760 --> 00:33:05,040
the code that we had before. But now we have to press around various outputs from our actions. So

351
00:33:05,040 --> 00:33:09,360
this code is still incomplete. But the nice thing here is that the compiler now helps us. It tells

352
00:33:09,360 --> 00:33:16,000
us, well, you forgot to make sure that you followed the filter before you placed it. And so we can

353
00:33:16,000 --> 00:33:19,920
fix that. And now the compiler tells us, okay, but if you want to add grounds, you have to, you

354
00:33:19,920 --> 00:33:24,320
have some prerequisites. So let's fix that. We have to have the coffee ground and the coffee

355
00:33:24,320 --> 00:33:29,680
ground and filter placed. And now we still have the same bug from before. We still, we forgot to

356
00:33:29,680 --> 00:33:34,480
rinse the filter. But this time, the compiler will tell us, you forgot to rinse the filter. So you

357
00:33:34,480 --> 00:33:40,720
have to do that before you can actually add your grounds. And so we fix that. And now the compiler

358
00:33:40,720 --> 00:33:48,080
is happy. And we are happy because our clients are happy. So because we shared our business rules,

359
00:33:48,160 --> 00:33:55,680
business knowledge with the compiler, the compiler was very helpful in actually enforcing this

360
00:33:55,680 --> 00:34:05,680
for us and making it impossible to stray from the right path. Also notice, so by making everything

361
00:34:05,680 --> 00:34:11,040
more declarative, it's now much easier to figure out what flows where and what goes in which way.

362
00:34:11,040 --> 00:34:18,640
And so in essence, our function dependencies are defining requirements and making the flow much

363
00:34:18,640 --> 00:34:23,520
more limited in what can or can't happen. And so this, for example, opens up opportunities for

364
00:34:23,520 --> 00:34:27,680
parallelization. So if you see that two functions are independent, you might be able to parallelize

365
00:34:27,680 --> 00:34:32,560
them. And the nice thing here is that the compiler will help you get it right because it knows what

366
00:34:32,560 --> 00:34:39,520
can or cannot be parallelized. But there is something that I didn't specify for the moment. And

367
00:34:39,520 --> 00:34:45,200
what are those types? The water heated and grounds added types and all the rest I just used here.

368
00:34:45,920 --> 00:34:50,560
So I just assumed that they are there, but I didn't actually specify them. And the answer is I don't

369
00:34:50,560 --> 00:34:56,640
care. I literally don't care about those types. So much so that I can actually represent it in our

370
00:34:56,640 --> 00:35:02,160
type signature. So brewing prep doesn't really depend on the specific values of all the types of

371
00:35:02,160 --> 00:35:06,000
coffee ground, water heated, and the like. Why? Because it just passes them around. It doesn't

372
00:35:06,000 --> 00:35:10,560
inspect them in any way. It just passes them around as kind of tokens of security, but it

373
00:35:10,560 --> 00:35:15,680
doesn't do anything else with them. And to make this explicit, we made our brewing prep function

374
00:35:15,680 --> 00:35:22,640
parametric. So now it takes six type arguments, although sounds scary. But since we don't care

375
00:35:22,640 --> 00:35:27,680
about the actual values, we can do that. And everything will just work the same way as before.

376
00:35:27,680 --> 00:35:35,280
So we explicitly declare the fact that we are invariant and don't care about how those types

377
00:35:35,280 --> 00:35:42,320
are specified. Now, in order for this to work out, the brewing actions interface has to be

378
00:35:42,320 --> 00:35:47,600
adapted as well. It has to be parametric in the same way. But because slide space is kind of

379
00:35:47,600 --> 00:35:52,560
limited, I'll abbreviate for a moment. And so now brewing actions is going to take the same

380
00:35:52,560 --> 00:35:58,880
six type parameters. And so now we are kind of consistently, the code looks exactly the same,

381
00:35:58,880 --> 00:36:04,480
but now we have type parameters. You might ask, why would you do that? And the answer is if you

382
00:36:04,480 --> 00:36:08,800
don't care about the inputs and outputs, if you make them parametric, it leaves you very little

383
00:36:08,800 --> 00:36:14,000
space to actually cheat. So in case I want to pass the water-heated value and have to return it

384
00:36:14,000 --> 00:36:18,960
for my signature, there's no way to obtain a water-heated value because from anywhere else,

385
00:36:18,960 --> 00:36:23,440
other than calling heat to water, because I have no idea what the type really is. It's parametric,

386
00:36:23,440 --> 00:36:28,880
so I have no information on how to obtain it. I don't know what it is, so it's just impossible.

387
00:36:29,440 --> 00:36:35,440
And so in this case, we're just forced to do the right thing because there's no way to cheat. If

388
00:36:35,440 --> 00:36:40,080
it was a unit or some other kind of simple value, we just could return that. But in this case,

389
00:36:40,080 --> 00:36:46,320
we can't because it's type parameter. And as a nice bonus, this approach actually gives us,

390
00:36:46,320 --> 00:36:49,120
although it limits the implementation, which is a good thing, it does give us

391
00:36:49,840 --> 00:36:55,040
various flexibility degrees of freedom when creating brewing actions because the type

392
00:36:55,040 --> 00:36:59,520
parameters can be set to whatever we actually want in brewing actions and still use unit, and

393
00:36:59,520 --> 00:37:04,400
maybe we can use something more informative in tests. And so this gives us actual, the limitation

394
00:37:04,400 --> 00:37:09,280
on this side actually gives us more flexibility in other places, which is a nice bonus, but

395
00:37:09,920 --> 00:37:16,800
it's not directly related to what we're doing here. But the point is that the brewing prep

396
00:37:16,800 --> 00:37:22,320
doesn't care about how those inputs work, and so we can limit it completely to using them correctly.

397
00:37:23,120 --> 00:37:28,960
And so I will point out that this code doesn't prevent every legal state possible. So for example,

398
00:37:28,960 --> 00:37:34,560
nothing stops us from calling fold filter twice. That might be, might be illegal. And in general,

399
00:37:34,560 --> 00:37:39,440
it's not always possible to limit every possible, every possible illegal state, but it's better to

400
00:37:39,440 --> 00:37:48,240
get something right than nothing. So I do think it's an improvement. So being declarative is a

401
00:37:48,240 --> 00:37:53,040
great way to encode your business rules directly in your types. That way the compiler can help you

402
00:37:53,840 --> 00:37:59,920
enforce those rules and making every breakage of the encoded rules impossible at compile time,

403
00:37:59,920 --> 00:38:04,800
and thus it's unrepresentable. And the good first step when trying to do things more declaratively

404
00:38:04,800 --> 00:38:09,280
is figure out where you have those redundant units that don't communicate any information

405
00:38:09,920 --> 00:38:15,760
about what the function does, and then try to see how you can solve it. And by making everything

406
00:38:15,760 --> 00:38:21,680
parametric, our code is becoming ignorant of the actual types that we use, which limits the

407
00:38:21,680 --> 00:38:26,960
number of possible illegal states that we can enter. So the less the code can do, the more we

408
00:38:26,960 --> 00:38:40,960
know about what it actually does. So ignorance is strength, like the famous quote. Okay, so we're

409
00:38:40,960 --> 00:38:46,720
done with the various techniques. It might not be obvious from those two examples, like why would

410
00:38:46,720 --> 00:38:52,560
that be useful? Because they're all small examples and kind of hard to see how they work out in a

411
00:38:52,560 --> 00:38:59,520
large code base that you have to maintain for a long time. My point is that all of this kind of

412
00:38:59,520 --> 00:39:07,040
adds up, and eventually it does make your code better in the long run, even if it's not obvious

413
00:39:07,120 --> 00:39:12,560
from the first small steps. But in this section we'll just kind of quickly review what sort of

414
00:39:12,560 --> 00:39:18,400
benefits you can expect to reap from being consistent and making illegal states as

415
00:39:18,400 --> 00:39:23,680
unrepresentable as you can in your code base. So the first point is that code becomes easier to

416
00:39:23,680 --> 00:39:32,480
comprehend. So as I just mentioned, the fewer things the code can do, the easier it is to

417
00:39:32,480 --> 00:39:37,200
understand what it actually does. But more concretely, for example, if you use algebraic

418
00:39:37,200 --> 00:39:42,160
data types consistently across your code base, the compiler can help you figure out what's

419
00:39:42,160 --> 00:39:46,960
happening now. You do a better match. Some editors would actually autocomplete all the cases, and

420
00:39:46,960 --> 00:39:51,120
you can now figure out what's going on, what information you have, what can you use and

421
00:39:51,120 --> 00:39:56,560
the like, and the compiler got your back. Not only that, it can also, as I mentioned,

422
00:39:56,640 --> 00:40:02,080
automatically do accessibility checking, so you're sure to not forget anything in case anything

423
00:40:02,080 --> 00:40:10,160
changes. And so this is definitely an improvement on your ability to figure out what's going on.

424
00:40:10,160 --> 00:40:14,640
And also a common theme throughout the examples is that our type signatures are becoming more

425
00:40:14,640 --> 00:40:18,960
informative. They encode more and more information about what's going on. So just by reading the

426
00:40:18,960 --> 00:40:25,600
signatures, it becomes easier to figure out what are the limitations, what is allowed, what is

427
00:40:25,600 --> 00:40:34,000
disallowed, and the like. Fewer bugs. So every legal state that you precluded and made unrepresentable

428
00:40:34,000 --> 00:40:38,640
is a potential bug that you avoided. So, for example, creating an Irish coffee order without

429
00:40:38,640 --> 00:40:43,040
whiskey is no longer possible. It's not a state that you can write. This is a compilation error.

430
00:40:44,240 --> 00:40:48,720
Nor this, like serving coffee and to an empty list of cups. Again, this is no longer possible

431
00:40:48,720 --> 00:40:53,440
because you enforced it at compile time, and this is a bug again that cannot happen anymore.

432
00:40:54,400 --> 00:40:59,040
And since they are unrepresentable, you don't have to test for them a lot. So this is our next

433
00:40:59,040 --> 00:41:04,800
point, is that you can do fewer, if you make as many legal states unrepresentable as possible,

434
00:41:04,800 --> 00:41:10,320
this leads to fewer tests that you actually have to write. For example, this test can't be

435
00:41:10,320 --> 00:41:17,280
expressed. Again, testing whether Irish coffee order has whiskey is no longer relevant because,

436
00:41:17,280 --> 00:41:22,800
again, even the test can't even compile. So that's a test that you don't have to write,

437
00:41:22,800 --> 00:41:26,960
and some tests, for example, are still possible to write but maybe more redundant because you

438
00:41:26,960 --> 00:41:32,560
don't really need, if your interface is sufficiently declarative, it might be kind of obvious on

439
00:41:32,560 --> 00:41:37,680
its own that you don't have to check whether water was heated or not when you done the brewing

440
00:41:37,680 --> 00:41:44,320
prep because the types are requiring that. And the last point is safer refactoring. So your

441
00:41:44,320 --> 00:41:49,040
code becomes much easier to refactor. For example, this code, the get calls on the optional values

442
00:41:49,040 --> 00:41:55,280
are only safe somewhat in the case that you're ordering Irish coffee. But imagine that you're

443
00:41:55,280 --> 00:41:59,680
doing refactor and now the prepare Irish coffee call moves to another place. Now it's in some

444
00:41:59,680 --> 00:42:04,240
other place and nothing is actually checking whether we're in the right case. So this is no

445
00:42:04,240 --> 00:42:10,320
longer safe. On the other hand, this code with the pattern match is safe by construction. If you

446
00:42:10,320 --> 00:42:14,640
try to move the call to prepare Irish coffee, the code will fail to compile because it will no

447
00:42:14,640 --> 00:42:22,880
longer have the references to the right information that it needs. And another refactoring is if you

448
00:42:22,880 --> 00:42:27,840
add something, for example, again, the compiler will verify that you matched all the various

449
00:42:27,840 --> 00:42:33,440
types, all the various cases that you have and will enforce again that you don't forget anything.

450
00:42:33,440 --> 00:42:39,680
Another example of refactoring is I mentioned in the previous section that we can paralyze

451
00:42:39,760 --> 00:42:46,160
some actions here. So we can, for example, heat water, grind coffee, and the rest can be

452
00:42:46,160 --> 00:42:50,160
paralyzed because they have no dependencies. So this is a refactoring that's easy to get wrong

453
00:42:50,160 --> 00:42:55,680
because if you mess something up, things will run in parallel when they shouldn't. And in the

454
00:42:55,680 --> 00:43:00,080
bad example, that would be just broken. But here we can write this code. And if we mess something

455
00:43:00,080 --> 00:43:04,800
up, the compiler will tell us you're missing some dependencies. You can't run this in parallel.

456
00:43:05,120 --> 00:43:15,600
So as people work and maintain large code bases, I think those benefits kind of add up and investment

457
00:43:15,600 --> 00:43:19,600
that you're making on making legal states unrepresentable is definitely, definitely worth

458
00:43:20,480 --> 00:43:31,120
the effort. So to conclude, almost done. So whenever you tackle a new domain, try to think

459
00:43:31,120 --> 00:43:37,040
about the state space of your problem, the various states that the system can arrive at and what

460
00:43:37,040 --> 00:43:45,280
can happen. Find the legal states in your system and define them to match your requirements or

461
00:43:45,280 --> 00:43:50,400
whatever other error conditions that you might care about. And all the other states are illegal.

462
00:43:50,400 --> 00:43:56,080
Now, if all you do is just think, just sit there and think about your state space in the legal

463
00:43:56,080 --> 00:43:59,360
and illegal state, that's already a great first step. You don't have to do anything else.

464
00:43:59,360 --> 00:44:02,960
That's already a good way of getting your code to be better just by knowing

465
00:44:02,960 --> 00:44:07,440
what's possible and impossible. But if you actually want to reap the benefits from this

466
00:44:07,440 --> 00:44:13,200
talk, make those states unrepresentable. And the benefits are fewer bugs, fewer tests,

467
00:44:13,200 --> 00:44:19,440
easier to comprehend code. And you don't have to worry anymore about states that are illegal

468
00:44:19,440 --> 00:44:23,040
because you made them unrepresentable. So you don't have to think about them anymore. That's

469
00:44:23,040 --> 00:44:27,360
a great thing to do. When you don't have to think about something, you can think about something

470
00:44:27,360 --> 00:44:34,560
else, which might be useful. And so we saw a number of techniques to achieve this goal.

471
00:44:34,560 --> 00:44:39,280
So algebraic data types help us reduce the state space into something smaller and more

472
00:44:39,280 --> 00:44:44,880
manageable. Smart constructors let us enforce various invariants and declarative signatures

473
00:44:44,880 --> 00:44:50,160
make various business rules kind of apparent in our code. And parametric polyphysm is like a nice

474
00:44:50,160 --> 00:44:56,480
cherry on top if you want to really kind of go at it even more limited. So there's a slide about

475
00:44:56,480 --> 00:45:01,440
where to go next. So I covered some very basic techniques. There are other approaches that

476
00:45:01,440 --> 00:45:08,000
you can take, which probably have a steeper cost-benefit ratio. So it might be not worth it.

477
00:45:08,000 --> 00:45:13,360
But these are some ideas of what you can think of, especially various type systems. So a lot of the

478
00:45:13,360 --> 00:45:18,800
things we've done are kind of bound by the type system that we're using. And so maybe trying

479
00:45:18,800 --> 00:45:26,080
other more advanced type systems or type system features can help you make things easier.

480
00:45:26,480 --> 00:45:31,280
If you're taking a photo, you can do that. I'll post the link to the slide so everything is there.

481
00:45:31,280 --> 00:45:37,120
And there's some inspiration for various resources that I think are kind of useful in thinking about

482
00:45:37,120 --> 00:45:44,000
problems. And again, I'll post the link for the presentation. All the links will be available.

483
00:45:44,000 --> 00:45:50,400
So it's my time to wrap up. So remember our poor little user that was trying to register and didn't

484
00:45:50,480 --> 00:45:57,200
have an email. So somewhere someone is trying to introduce another bug in our system. But luckily

485
00:45:57,200 --> 00:46:04,240
we applied all the techniques that we studied right now. And it no longer compiles. The illegal

486
00:46:04,240 --> 00:46:11,680
states is unrepresentable. The compiler tells us that and we can sleep quietly tonight. So hopefully

487
00:46:11,680 --> 00:46:18,400
I managed to convince you that making illegal states unrepresentable is actually worth the effort.

488
00:46:18,400 --> 00:46:23,520
And this is linked to the presentation. And if I have time for questions, I'm not sure.

489
00:46:24,240 --> 00:46:27,840
Yes, we can try to take one online question first, maybe.

490
00:46:32,800 --> 00:46:37,280
Can you please read it out for our audience? I guess you're in favor of using something like

491
00:46:37,280 --> 00:46:42,080
refined to express even more constraints in types instead of custom smart constructors. Yes,

492
00:46:42,480 --> 00:46:51,760
the one of the last slides, I used refined as there's a link to the refined library here in

493
00:46:51,760 --> 00:46:57,360
the end. So yes, refined is a nice library that can help you automate the process of creating

494
00:46:57,360 --> 00:47:02,240
smart constructors. Instead of writing them manually by hand, you can use a library that

495
00:47:02,240 --> 00:47:07,600
helps with that. All right. Thank you. We have also one question here on site.

496
00:47:08,320 --> 00:47:15,680
Hi. So thanks for the great talk. In the example about algebraic data types.

497
00:47:21,520 --> 00:47:28,000
It was the example of ordering different types of coffee. But what happens if the coffee shop

498
00:47:28,000 --> 00:47:34,400
owners have a business requirement that at any point of time, she wants to be able to add a

499
00:47:34,400 --> 00:47:39,280
new type of the coffee? So what happens to our algebraic data types with such a requirement?

500
00:47:39,280 --> 00:47:45,360
So there's often kind of people debating whether types are useful or not, or kind of this conception

501
00:47:45,360 --> 00:47:50,320
that you have to go all in or nothing. So either you specify everything and everything is fixed

502
00:47:50,320 --> 00:47:55,760
in types or not. This is not the case. If you want some flexibility, you can live that measure

503
00:47:55,760 --> 00:48:00,960
of flexibility as your requirements desire. So in the case of maybe having another case which is

504
00:48:01,040 --> 00:48:05,200
more dynamically defined, maybe have another case which is dynamic. And then you'll be extra

505
00:48:05,200 --> 00:48:10,480
careful around that case. But still, you now have a small island of sanity where you know what's

506
00:48:10,480 --> 00:48:15,360
going on and another section of the code which is not as pleasant and safe. But still, you can

507
00:48:15,360 --> 00:48:20,080
separate the parts. What you know, you can encode. What you don't, leave it as an unknown and handle

508
00:48:20,080 --> 00:48:25,840
it appropriately. Okay. Thank you. We have one more online question. If you could again, please read

509
00:48:25,920 --> 00:48:33,680
it out. So only recently I started learning Haskell and Idris from the perspective of making

510
00:48:33,680 --> 00:48:37,600
illegal states not representable. It seems to me that type-driven development

511
00:48:37,600 --> 00:48:44,320
advocated by Idris is more suitable. Then again, I'm a beginner. So yes, Haskell and Idris both

512
00:48:44,320 --> 00:48:51,600
have various advanced type-level features and things you can do that make it possible to exclude

513
00:48:51,680 --> 00:48:57,760
even more illegal states. And as I mentioned, using more advanced type systems is a good way

514
00:48:58,640 --> 00:49:04,960
to enforce more invariance. But the question is kind of the cost, whether it's worth it,

515
00:49:04,960 --> 00:49:09,840
especially as a beginner, because if you play something very, very kind of a heavy tool that

516
00:49:09,840 --> 00:49:14,720
does something very sophisticated, it might be more difficult to maintain. So I think you

517
00:49:14,720 --> 00:49:19,440
should kind of gradually ramp up there and eventually maybe use it, but have a good way

518
00:49:19,440 --> 00:49:23,360
to judge whether it's worth it or not. So start simple and then gradually improve.

519
00:49:24,160 --> 00:49:28,160
All the things I did mention now are available in both Haskell and Idris. So that's not

520
00:49:28,160 --> 00:49:33,200
actually a problem. And you can start there and move on to something more advanced. Okay. We

521
00:49:33,200 --> 00:49:40,880
have time for one last onsite question here. Thanks for a great talk. I'm wondering if any

522
00:49:40,880 --> 00:49:45,360
of the techniques that you mentioned are applicable in dynamically checked languages?

523
00:49:45,360 --> 00:49:52,720
And if you have an experience in doing so, maybe? So in dynamically typed languages, everything's

524
00:49:52,720 --> 00:49:57,360
applicable. You can write anything. The question is whether who enforces things for you. So in

525
00:49:57,360 --> 00:50:02,480
a statically typed language, the compiler is much more your friend than people usually think.

526
00:50:03,600 --> 00:50:07,360
And then in dynamically typed language, first of all, just thinking about the state space,

527
00:50:07,360 --> 00:50:10,720
you can do it in any language on a piece of paper. It doesn't really matter. And it's already an

528
00:50:10,720 --> 00:50:16,640
improvement. And then if you are explicit about what's illegal, at least you can force your

529
00:50:16,640 --> 00:50:22,160
invariance even in a dynamic context. For example, your smart constructor won't return an optional

530
00:50:22,160 --> 00:50:27,680
value, but will throw an exception. But at least you limited the scope of where things can go

531
00:50:27,680 --> 00:50:32,560
wrong, for example. And pattern matching is available in various languages. Although there are no,

532
00:50:32,560 --> 00:50:37,760
the guarantees might be somewhat looser, but still it's better than nothing. So those approaches

533
00:50:37,760 --> 00:50:43,440
can help you, but they won't gain you as much benefit as they are in a statically typed language,

534
00:50:43,440 --> 00:50:53,680
I think. All right. Thank you very much, Daniel. Please help me thank him.

