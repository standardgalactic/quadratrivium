WEBVTT

00:00.000 --> 00:23.760
We're here to talk about this great quote up there by Jaron Minsky, make legal states

00:23.760 --> 00:30.320
unrepresentable. And although it sounds quite simple, I find that the consequences of it are

00:30.320 --> 00:37.520
quite profound. But before we actually begin and dive in, let's start with kind of a short story

00:37.520 --> 00:42.240
as an introduction. So it's the middle of the night and you're sleeping peacefully.

00:42.880 --> 00:48.560
And suddenly you get a call and you're being informed that the production system is crashing.

00:49.520 --> 00:57.760
And after a few minutes of furious debugging, you find this exception that happens. Someone

00:57.760 --> 01:04.400
accessed an empty optional value. And how can that be? You ask yourself. And so you dig a little

01:04.400 --> 01:11.120
deeper and you find this wonderful code. So someone unwrapped an empty option value. And

01:11.120 --> 01:16.720
you read this comment. This is safe. Registered users always have email. And it's a very nice

01:16.800 --> 01:23.280
comment. And the old caps are stressing the right points. And it's a very reasonable assumption

01:23.280 --> 01:29.440
because registered users should have emails and the product manager also required that as well.

01:29.440 --> 01:37.280
So what went wrong? And basically what happened is that we entered an illegal state of our system

01:37.280 --> 01:42.560
and doesn't really matter how we got there. But these sorts of situations happened all the time.

01:42.560 --> 01:48.400
I'm sure most of you had some experience seeing some error of this kind happening to you.

01:48.880 --> 01:54.640
And those things can be avoided. And I would say they must be avoided because all would like to

01:54.640 --> 02:01.760
have a good night's sleep. But this is what we're here to talk about. How to make these illegal

02:01.760 --> 02:07.680
states unrepresentable. How to make it impossible to create software that enters those illegal states.

02:08.640 --> 02:16.720
So today we're going to discuss this quote. What it actually means. We'll break it down into

02:16.720 --> 02:24.080
smaller parts. Then I'll show some simple techniques to try to achieve this ideal of making

02:24.080 --> 02:28.640
illegal states unrepresentable. And we'll conclude with seeing what are the sort of benefits that

02:28.640 --> 02:35.840
you might expect to reap in case you actually follow this principle. So this is mostly a beginner

02:35.840 --> 02:41.120
friendly talk. So don't expect some mind blowing techniques. But I do hope that the

02:41.120 --> 02:45.680
perspective I am about to show is useful even for more experienced developers.

02:47.520 --> 02:53.520
So as far as I know this quote was created in the context of working on a financial system.

02:53.520 --> 03:01.520
So Jaron Minsky is, was working on Jane Street. And I can imagine that making illegal states

03:01.520 --> 03:05.680
unrepresentable in the financial system is very, very important because you probably don't want

03:06.720 --> 03:12.960
to lose transactions or money or whatever. So let's dive in and figure out what it means to

03:12.960 --> 03:20.080
that an illegal state is unrepresentable and how do we define it. So we start with the state.

03:20.080 --> 03:26.400
So what is the state of a program? So imagine your whole application running and take like a

03:26.400 --> 03:31.920
single, single snapshot in time with all the variables and all your variables, threads,

03:31.920 --> 03:37.280
function calls, whatever. So single snapshot of your program. So this is an example of such

03:37.840 --> 03:42.000
states. So you have some variable assignments. You have maybe registers,

03:42.000 --> 03:45.840
heap allocations, whatever. Threads are running. Functions are about to be called.

03:46.960 --> 03:52.080
So this is a single state of the system. So obviously a real system will have many, many,

03:52.080 --> 03:59.200
many states. But for the purposes of this talk, we're going to kind of zoom out and from the

03:59.200 --> 04:06.160
details of registers and threads and like, and just have like a conceptual picture of the different

04:06.160 --> 04:12.800
states of the system. So this is our program's state space. All the different states, it can find

04:12.800 --> 04:19.040
itself in. So, but some states are illegal. That means that if you enter that state, something

04:19.040 --> 04:23.440
bad will happen. The program will crash. An exception will be thrown. Maybe a business rule

04:23.440 --> 04:28.320
will be violated. But something, whatever it is, it's something that's bad for your system and

04:28.320 --> 04:34.480
something that you would like to avoid. So of course, what's considered illegal is very context

04:34.480 --> 04:40.080
dependent and it depends on what you care about at the moment and the various tradeoffs. But let's

04:40.080 --> 04:48.000
assume that we can recognize an illegal state once we see it. And so the picture I'm showing here

04:48.080 --> 04:52.560
is that we have like a huge state space and have a few legal states. But usually the reality is much

04:52.560 --> 04:58.480
worse. Usually you have a lot, a lot of states that are actually illegal. And so hitting them

04:58.480 --> 05:03.280
and usually by accident is just a matter of time. You walk around your kind of state space and,

05:03.280 --> 05:07.920
and just accidentally stumble on something illegal. And that's, that's quite likely to happen just

05:08.000 --> 05:18.720
like the registered user in the previous example. So let's zoom in a bit and enter this diagram. So

05:19.440 --> 05:24.800
a typical program will probably be moving between lots of states. Hopefully, and, and we can assume

05:24.800 --> 05:30.880
usually between legal states, which are okay for a system. But sometimes you'll probably by accident

05:31.520 --> 05:37.200
hit an illegal state and your system might crash or violate some rule or do something bad. And

05:37.200 --> 05:41.440
usually if you got one illegal state, you probably will get another illegal state.

05:42.880 --> 05:46.640
And this is not good. And this is what the sort of things that we would like to avoid

05:46.640 --> 05:52.640
in the context of this quote and probably just in general in programming. So let's zoom in a little

05:52.640 --> 05:58.720
more. So, so as high level programmers, we typically don't think about registers and threads and,

05:58.720 --> 06:04.480
and, and the heap and the like. And as functional programmers, we typically want to represent as

06:04.480 --> 06:10.640
much as possible of our application as functions. So imagine that this is this function signature

06:10.640 --> 06:16.640
here is some part of your system. You have some inputs, you have some output, and, and, and you,

06:16.640 --> 06:21.120
you would like to analyze what's possible and impossible here. So what do I mean that an illegal

06:21.120 --> 06:27.520
state is representable? It's that there is some combination of the inputs ABC that would, that

06:27.520 --> 06:31.600
would get you into an illegal state. Okay, that would mean that the state is representable. You

06:31.600 --> 06:37.440
can find such inputs and you'll, and you'll get an illegal state directly in your system.

06:38.080 --> 06:42.800
And what we want, what we strive to achieve is to make it impossible for to find such inputs

06:42.800 --> 06:48.720
that would get us into this illegal state. So imagine that it's, it's literally impossible

06:48.720 --> 06:53.920
to write down such inputs that would get you into a legal state that you cannot get there at all.

06:55.120 --> 06:59.120
And all you can do is kind of walk around the legal states and just never worry about

06:59.120 --> 07:05.600
entering the illegal, the illegal red dots here. And so this should be possible not because you

07:05.600 --> 07:08.880
checked and double-checked your inputs and not because you covered everything with tests, but

07:08.880 --> 07:14.320
because you make it strictly impossible to write down those inputs that would, would get you into

07:14.320 --> 07:21.840
an illegal state. So that's at least the ideal that we want to, want to reach. And question is

07:21.840 --> 07:26.080
whether it's a reachable idea, ideal, can you, can you actually do that? And probably the answer

07:26.080 --> 07:30.640
is generally no. You probably can't avoid all illegal states, but I would claim that every step

07:30.640 --> 07:34.720
you make in that direction is, is a good step and probably is improving your software in some,

07:34.720 --> 07:40.240
in some way or dimension. Also, question is whether it's worth it. I'm going to show you some,

07:40.240 --> 07:44.720
some techniques that you have to apply to your code and then maybe there's some, some costs and

07:44.720 --> 07:50.080
it might, might not be worth it. And that's, again, can be, can be true that's maybe too

07:50.080 --> 07:55.520
expensive, but the, the sort of techniques I'm about to show you now are quite, quite lightweight

07:55.600 --> 08:02.320
and hopefully the cost-benefit ratio is, may, would make them worth it. And although it's

08:02.320 --> 08:08.240
possible to, to avoid illegal states in pretty much every paradigm and language, but strongly,

08:08.240 --> 08:13.760
strongly typed functional programming is, is very good at it. So because types makes it easier to

08:13.760 --> 08:19.760
define, define our state, state space and, and functional techniques make, makes it, once you

08:19.760 --> 08:25.520
define and recognize an illegal state, they, they, they make it easier to avoid various illegal

08:25.520 --> 08:39.200
states. Okay, so now that we, we know what are illegal states, so slide, slide the gray,

08:39.200 --> 08:47.280
digression into something else. So I'm not sure what is or so, but empirical evidence shows that,

08:47.440 --> 08:53.600
that people really, really like coffee. I myself don't drink coffee, so I can't really relate,

08:54.160 --> 09:00.080
but apparently making coffee is very, very complicated. And here's a, a diagram that's,

09:00.080 --> 09:05.520
that's obviously has lots of different states and I'm sure some of them are illegal. And since I

09:05.520 --> 09:09.600
don't know much about coffee, I thought maybe it will be a good idea to use it as kind of an example

09:09.600 --> 09:16.560
domain to, to, for, for this talk that we can explore and try to kind of make more, more legible

09:16.560 --> 09:24.480
for, for our purposes. So, so imagine that you're tasked with programming this, this coffee making

09:24.480 --> 09:30.800
robot. So lots of things can go wrong when you program a robot, I imagine, especially one that

09:30.800 --> 09:36.400
does something as complicated as creating coffee, because coffee drinkers are, are very, very specific

09:36.400 --> 09:41.520
about what and how they are willing to drink. So there's a huge state space here and lots of

09:41.520 --> 09:46.160
things that can, can go wrong. And we'll just try to tackle like small sub-problems from this

09:46.160 --> 09:51.920
domain and see, see how we can improve what we see. So we start with, with the simplest part I,

09:51.920 --> 09:58.320
I could possibly imagine here, ordering coffee. So again, imagine that you are, you are doing

09:58.320 --> 10:02.160
this kind of proof of concept of your, of your robot. You want to show that it can actually do

10:02.160 --> 10:07.840
something useful. So you want to specify the, how to order a cappuccino, which is, so I hear a popular

10:07.840 --> 10:13.600
drink. So your users have to specify what kind of milk they want in the cappuccino. And apparently

10:14.560 --> 10:19.520
milk choice is also a complicated topic. So milk is not some trivial type, but, but in the

10:19.520 --> 10:25.520
enumeration of various, various, various options. So after successfully making cappuccino, you think,

10:25.520 --> 10:30.800
okay, let's, let's see. It kind of works. Let's, let's do something more, add something to, to a

10:30.800 --> 10:35.360
repertoire to make it more interesting. So since you already know how to do cappuccino espresso,

10:35.360 --> 10:40.480
apparently according to this picture there is, is pretty much the same thing, but minus the milk.

10:40.480 --> 10:44.720
So you make your milk an optional, optional argument in this case. So, so that you don't

10:44.720 --> 10:49.520
require it anymore. And now if you don't have milk, you make an espresso espresso. If you have milk,

10:49.520 --> 10:56.400
you, you do cappuccino. And now let's set another one, latte. So latte is basically, apparently

10:56.400 --> 11:01.840
again, by this diagram is just the same as cappuccino, but with more milk. And so we have a

11:01.840 --> 11:07.760
problem. We have an ambiguity. Both cappuccino and latte require, require milk. So we have to

11:07.760 --> 11:13.600
somehow tell them apart which, which order are we talking about. So in order to make it easier

11:13.600 --> 11:18.160
to figure out what's going on, we were going to add another enumeration, the drink type,

11:18.160 --> 11:22.960
which will actually tell us what kind of order are we dealing with here. And so we have kind of

11:23.040 --> 11:28.480
three cases for cappuccino espresso and latte. And that's a nice way to kind of future proof

11:28.480 --> 11:33.280
ourselves from future, future drinks that we might want to add, because now we could easily add them

11:33.280 --> 11:39.840
to our enumeration. So, so that's, that's a nice, nice bonus. And so now that you, you have some

11:39.840 --> 11:44.160
basic drinks and, and you know how to make them, you want to show off how your robot can actually do

11:44.160 --> 11:48.560
cause something more complicated. So you want to do two fancy drinks in this case. So want to

11:48.560 --> 11:53.920
try and do affogato and Irish coffee. Fortunately, botanary require more, more ingredients. So we

11:53.920 --> 12:00.240
need to add gelato and, for the affogato and the cream and whiskey for, for Irish coffee. And that's

12:00.240 --> 12:06.000
a good place to stop for a moment and take a look at what we have. So we support, support five different,

12:06.000 --> 12:11.120
different types of drinks, which is nice, but we have lots of various optional values. It's

12:11.120 --> 12:16.960
completely non-obvious, which, which combinations are actually legal here. So can, can I mix milk

12:17.040 --> 12:20.960
into my Irish coffee or some, some such. It's not obvious from the type sense.

12:23.600 --> 12:28.160
And it's easy to get confused. So let's, let's try to step back for a moment. So what is the

12:28.160 --> 12:32.960
issue here? So this is again kind of a simplified state diagram of what, what we want to achieve. So

12:33.600 --> 12:38.800
we have five legal states, five states that we actually want, want to support. So which one

12:38.800 --> 12:43.680
corresponding to some drink that we have in our system. But we also have various combinations

12:43.760 --> 12:48.640
that, that are illegal in some sense. So for example, espresso, espresso with gelato is just

12:48.640 --> 12:53.840
redundant because we're just rediscovered affogato, but though some drinkers might be offended.

12:55.200 --> 13:00.880
But Irish coffee without whiskey is obviously an illegal state if I ever seen one. So it makes no

13:00.880 --> 13:06.560
sense at all. And there are many other states here that, that many combinations of various

13:06.560 --> 13:12.240
inputs that we can get here that are completely illegal and make no sense. So let's, let's think

13:12.240 --> 13:16.880
more concretely why, why this is a problem. So suppose we have some low level function that

13:16.880 --> 13:21.600
actually tells the robot how to prepare the Irish coffee. And it has to take two arguments,

13:21.600 --> 13:26.080
cream and whiskey, because that's, that those are the parameters that we need to specify for,

13:26.080 --> 13:30.160
for this drink. And imagine that you were trying to actually take an order and prepare the Irish

13:30.160 --> 13:38.320
coffee. So in case you are in the Irish coffee, Irish coffee order, you access the cream and whiskey

13:38.320 --> 13:44.080
and then, and then prepare Irish coffee. Now notice that we are accessing optional values

13:44.080 --> 13:50.240
and we are very careful here. We have a comment that says this is safe. That's probably okay,

13:50.240 --> 13:56.000
right? I mean, what, what could possibly go wrong? So, because it makes no sense to have empty

13:56.000 --> 14:01.840
values on, of cream and whiskey in case someone ordered an Irish coffee. So maybe just in case,

14:01.840 --> 14:05.760
because we don't want to be too troubled with debugging late at night, we will make it even

14:05.760 --> 14:10.240
more explicit. So we will throw a nice exception that has more, more information. So it might,

14:10.240 --> 14:14.720
might be nicer to debug, but it's really, really isn't possible. I mean, you can't have Irish coffee

14:14.720 --> 14:23.680
without cream and whiskey. And, and, and this is sort of an invariant that we're assuming over

14:23.680 --> 14:28.320
our code. In this case, the invariant is quite simple. Irish coffee always has cream and whiskey,

14:28.320 --> 14:32.720
but nothing is enforcing this invariant. We're kind of writing comment and have,

14:33.280 --> 14:37.520
have suffered from a wishful thinking that may, hopefully nobody will ever break this,

14:37.520 --> 14:42.560
this thing apart. But imagine that in the future, you're supporting reading orders from JSON files

14:42.560 --> 14:47.120
and someone messed up the format and then something is missing. Who knows? Something can

14:47.120 --> 14:52.000
happen and you can't write tests, tests to cover all of your flows in your system probably. And

14:52.000 --> 14:56.400
even less so, you can't write tests for future flows that someone might define, that are not

14:56.400 --> 15:00.240
defined right now. How, how can you protect against something that you don't even know that will

15:00.240 --> 15:06.480
exist in your system? And so, so, and you might be actually thinking that, okay, I'm very bad at

15:06.480 --> 15:13.920
designing data types and that's why I have this kind of bad, bad definition of, of an order. But

15:13.920 --> 15:18.720
that may be so. But the thing I'm trying to assert here is not something that happens in a single,

15:19.440 --> 15:23.040
in a single step. Usually, it kind of creeps up on you. You start with something small and

15:23.040 --> 15:27.920
gradually it increases, grows, and then becomes this huge thing full of illegal states that you

15:27.920 --> 15:33.040
can, you're really dependent on and can't, can't really disentangle from, from your system. And,

15:33.040 --> 15:37.520
and then you again enter this, this space where you have lots of illegal states and nothing to do

15:37.520 --> 15:50.640
about it. But we can, can do better, a lot better. So, sorry. So, so our problem here is that our

15:50.640 --> 15:56.560
type is in a sense too big for a problem. We have, we define some schema for possible, possible

15:56.560 --> 16:00.800
combinations of inputs and it's too big. Our state space contains lots of things that shouldn't

16:00.800 --> 16:08.320
be there. And algebraic data types are a really good way and methodology to, to create types of,

16:08.320 --> 16:13.840
of the right size, types that can actually fit our domain in a way that, that really is exactly

16:13.840 --> 16:20.080
what we want and nothing else. So, let's rewrite our data type as, as an algebraic data type in

16:20.160 --> 16:28.720
this case and some type or in enumeration in Scala syntax now. So, we're going, instead of writing

16:28.720 --> 16:32.720
coffee order where everything is placed to kind of in the top level with all the options, everything

16:32.720 --> 16:37.280
possible, we're going to split, split it up into various cases. So, we have a first case with

16:37.280 --> 16:42.560
Cappuccino. Cappuccino requires milk, so it's no longer optional. We have a case for espresso,

16:42.560 --> 16:47.520
which doesn't have any, any requirements. So, this, so it's just espresso. We have the case of

16:47.520 --> 16:51.440
Latte, which also requires milk, but there's no ambiguity anymore because now it's a separate

16:51.440 --> 16:56.560
case and there's no way to confuse one Cappuccino with the other. So, so, and again, the argument is

16:56.560 --> 17:01.840
no longer, no, no longer optional. And Afogato requires Gelato. So, this is again a required

17:01.840 --> 17:07.760
dependency and we cannot avoid it. And Irish and coffee, which is the, which was our stumbling block

17:07.760 --> 17:11.440
now has a required dependency on cream and whiskey and there's no ambiguity anymore.

17:12.320 --> 17:18.320
So, not only that it's now much, much clearer what is going on and what, what, what sort of states

17:18.320 --> 17:23.680
are legal here and what, what is the actionable data that we have and how to access it. It's

17:23.680 --> 17:28.480
literally now impossible to express the legal state I, I, I just described previously. So,

17:28.480 --> 17:32.480
the legal states in the previous slide are, are literally unrepresentable. You can't write down

17:32.480 --> 17:39.040
the code that, that actually enters those states. So, now we can, for example, in the,

17:39.120 --> 17:43.280
when preparing the Irish coffee, we can now safely better match our, on our order. And, and if it's

17:43.280 --> 17:48.160
Irish coffee, we know and the compiler provides us with access to both cream and whiskey. And

17:48.160 --> 17:53.680
it's definitely there and can be gone and, and can be missing. So, we don't need to assume any

17:53.680 --> 17:59.120
invariant about a call or code. Don't have to lie about it in comments. And no, no exceptions can

17:59.120 --> 18:04.960
be, can be thrown here or, or any other illegal states. And if we got to this point where it

18:05.040 --> 18:09.200
better matched than we have Irish coffee, we know for a fact that all requirements were met

18:09.200 --> 18:13.760
and nothing can go wrong in this, in this respect. And this is enforced by the compiler

18:15.040 --> 18:20.560
for every possible floor of our program. So, we don't have to try to cover, cover everything

18:20.560 --> 18:26.160
with tests. And it's also there, enforced there for the future as well, because the compiler does

18:26.160 --> 18:30.000
the same thing for all future flows as well. So, we don't have to worry about it again with tests

18:30.000 --> 18:37.600
that we cannot write even. So, the illegal state that I showed before is truly unrepresentable

18:37.600 --> 18:44.240
now. You cannot write it down. It cannot exist in the system. So, algebraic data types are, are a

18:44.240 --> 18:50.720
great, a great tool you can use to reduce the state space of your, of your problem domain. So,

18:50.720 --> 18:56.640
leading to fewer legal states and making the code generally more, more comprehensible. And this is

18:56.720 --> 19:01.920
done by making every assumption about your inputs completely explicit. So, in our case, we made

19:01.920 --> 19:07.760
every case to correspond to the assumptions about coffee orders that we have at the moment. And

19:07.760 --> 19:12.560
the values are now correct by construction. So, you cannot build an illegal order anymore because,

19:12.560 --> 19:17.520
because you made it impossible in the type to represent what, what is not supposed to be there.

19:19.120 --> 19:24.880
And so, once you do that, you're basically turning your flow into data. So, notice how we no longer

19:24.960 --> 19:30.000
have any conditionals. After, after pattern matching and figuring out that we are in the Irish

19:30.000 --> 19:34.320
coffee case, that's it. We don't have to do anything else. We don't have to ask, ask and be

19:34.320 --> 19:42.400
hopeful that the cream whiskey are present. It's there. It's accessible. And, and so, and so you,

19:42.400 --> 19:48.800
you don't have to worry about defensively programming against it. And, and nice bonus in

19:48.880 --> 19:53.600
statically type of programming language is where you, for pattern matches, you also have

19:53.600 --> 19:58.160
exhaustivity checking. So, in case someone adds another case or something else is changing,

19:58.160 --> 20:03.360
changing the compiler will have your back and help you figure out what's missing and what,

20:03.360 --> 20:08.320
what you have to add there to be able to handle everything correctly. So, you can't forget anything

20:08.320 --> 20:12.960
that you need and don't, can't forget to handle everything. And what's important, the compiler

20:12.960 --> 20:16.880
is not providing you with safe access to all the data that you need. You don't have to assume

20:16.960 --> 20:21.520
that it will be present when it might be not. It will definitely be there and you can't work

20:21.520 --> 20:28.560
around it. So, now that you, and you're basically free from thinking about illegal states and you

20:28.560 --> 20:33.600
don't have to engage in defensive programming all throughout your application. It's not a

20:33.600 --> 20:37.920
magical solution. You still have to kind of get the, the, the size of your algebraic data type,

20:37.920 --> 20:41.600
right? Because my initial example, the first coffee order is also an algebraic data type,

20:41.600 --> 20:47.520
but that one was too big for our state space. So, you still have to think, nobody is, is

20:47.520 --> 20:52.000
getting away from, from thinking, but still having this perspective and having algebraic

20:52.000 --> 20:57.280
data types as, as a tool that you can use to shape your state space is, is very, very useful.

20:58.880 --> 21:03.600
And so, this is, I think that algebraic data type, data types of all the features of functional

21:03.600 --> 21:10.240
programming are, is probably the, the best cost, cost benefit ratio out there. And if you're using

21:10.320 --> 21:15.440
them consistently all over your system, I think that, that will be a great improvement to, to the

21:15.440 --> 21:20.640
possible illegal states that you can or cannot represent. And if I were to start on, start on

21:20.640 --> 21:25.280
a deserted island or something or programming Java, that probably would be the one feature that I,

21:25.280 --> 21:29.440
I would like to have from functional programming. They're that, that useful.

21:30.080 --> 21:40.560
So, now we're back to our robot. So, let's try to tackle another scenario. So, successfully

21:40.560 --> 21:46.960
defeated the issue of coffee ordering. So, again, apparently that coffee drinkers have lots and

21:46.960 --> 21:51.680
lots of neat picks. For example, you can't just pour any amount of water on any amount of coffee,

21:52.480 --> 21:57.200
apparently. I don't know why. That would be wrong. So, imagine you have some, some function that

21:57.200 --> 22:01.680
does the pouring. So, take some waters, take some grounds and, and does, and pours water over the

22:01.680 --> 22:06.320
grounds. So, this function can easily lead us to an illegal state. So, you can just choose the wrong

22:06.320 --> 22:11.040
ratio of water and grounds. And there you go. You have a wrong, a wrong state and a coffee that was,

22:11.040 --> 22:16.400
that was spoiled by too much water or too little water or whatever. And so, we can do something

22:16.400 --> 22:23.600
like this. So, we define a new type called tasty ratio. And we only want to allow tasty ratios

22:23.600 --> 22:28.640
in our, in our function. And this seems that, like, that would be kind of better, because

22:28.640 --> 22:32.800
here we're explicit about what, what we actually want to achieve. But not really, because the

22:32.800 --> 22:37.360
definition of tasty ratio is pretty much the same thing. You just moved, sorry, you just shuffled

22:37.360 --> 22:43.840
around your problem into another place. You still can create tasty ratio instances with the wrong

22:43.840 --> 22:50.320
proportion of water and grounds. And so, although we claim that tasty ratio is a valid input,

22:50.320 --> 22:55.440
we do not enforce it in any way. So, it's, again, another illegal state that's waiting to happen.

22:56.320 --> 23:01.280
And since it can be represented in our system, most likely someone at some point will create an

23:01.280 --> 23:08.800
illegal instance of tasty ratio and something will be broken. And, and so, in this case, though,

23:08.800 --> 23:13.440
we have so many illegal states, because most, most combinations of water and grounds will

23:13.440 --> 23:20.000
probably be illegal. So, our state space is just full of illegal, illegal, illegal states. And just

23:20.000 --> 23:26.000
a few small number of possible, comparatively small number of, of combinations of, of water and

23:26.000 --> 23:30.960
grounds are actually legal. And what we want to achieve is to only be able to write down the

23:30.960 --> 23:35.840
legal combinations and making, writing all other combinations completely impossible. That's, that's

23:35.840 --> 23:43.040
our goal. So, so basically what we want is some kind of invariant on tasty ratio and invariant

23:43.040 --> 23:47.840
that, that tells us that water and grounds are in the right proportion, proportion. And we don't

23:47.840 --> 23:52.160
want to be checking it all over, over the place. We don't want to do defensive programming and

23:52.160 --> 23:57.760
kind of sprinkle our code with e-falses and exceptions and the like. So, so ideally, so

23:57.760 --> 24:02.720
whenever we have an instance of tasty ratio, it has to be, has to be correct and nothing else

24:02.720 --> 24:07.200
should be impossible. But unlike the invariant of coffee, of the coffee order, which was kind of

24:07.200 --> 24:11.600
simple, is that Irish, Irish coffee must have cream and whiskey. This invariant is, is a bit

24:11.600 --> 24:16.960
trickier to get right. And just using algebraic data types, you probably won't be able to easily

24:17.520 --> 24:22.000
enforce it in the types. Correct me if I'm wrong if you have a way of doing that, but probably

24:22.000 --> 24:26.640
not likely and won't be worth it. So instead we're going to use smart constructor. So smart

24:26.640 --> 24:32.720
constructor basically limits the way we can, we can build instances of our, of our values. So this

24:32.720 --> 24:37.200
is just called a specific way, but most languages have some equivalent of this. So first of all,

24:37.280 --> 24:42.960
we, we mark our constructor as private. So we can no longer instantiate instances of tasty

24:42.960 --> 24:50.000
ratio without directly from the constructor. And then we create our own legal, our own smart

24:50.000 --> 24:55.520
constructor that, that requires that everything is legal. So the contract of the make function is

24:55.520 --> 25:00.640
that it can take any inputs, but it will only produce a tasty ratio only if the inputs are

25:00.640 --> 25:04.800
actually valid. And nothing else is possible. And this will be the only way to construct tasty

25:04.800 --> 25:12.400
ratios in our, in our program. And so the logic itself is probably not that complicated. So we

25:12.400 --> 25:17.840
just verify the, verify the right amounts. But it is crucial to get this right. So this is kind of

25:17.840 --> 25:23.040
the safe kernel that you have in your program that users will now assume is correct and can

25:23.040 --> 25:31.040
rely on in all other places. So if you got this right, people can, can rely on this invariant

25:31.040 --> 25:36.160
now for every place where they stumble upon tasty ratio. So now after, after making the smart

25:36.160 --> 25:41.360
constructor and, and forbidding the creation of tasty ratio without, without calling the smart

25:41.360 --> 25:46.400
constructor, now the, the, this function is, is safe. It actually does what, what it promises.

25:46.400 --> 25:50.640
You cannot call it with an illegal tasty ratio because there are no tasty ratios that are

25:50.640 --> 25:57.760
illegal in our system. It's just not possible anymore. So more generally, generally smart

25:57.760 --> 26:03.920
constructors are a great way of enforcing diverse invariants. So we can find many examples. So in

26:03.920 --> 26:08.480
this case, our signature is, is kind of, again, we have a wishful comment about something about age

26:08.480 --> 26:12.880
and, and, and alcohol restrictions, but, but it's not really an invariant that's enforced

26:12.880 --> 26:17.920
anywhere. Just wishful thinking. But if you apply the correct smart constructor, you can probably

26:17.920 --> 26:22.800
get it, get this, this type that will enforce it. It's not possible anymore to, to do the illegal

26:22.800 --> 26:27.920
action of, in this case, pouring whiskey into Irish coffee. And you can have more examples. So again,

26:27.920 --> 26:32.720
the first, the, the first, the top signature is always some wishful thinking and a type that

26:32.720 --> 26:37.600
doesn't really, really represent well what, what we want. And the second is, is a corrected version

26:37.600 --> 26:43.120
where we enforce something in our, on our type and, and usually we close it off with a smart

26:43.120 --> 26:48.000
constructor so that nobody can access the, the illegal states. And notice that we didn't make

26:48.080 --> 26:55.040
tasty ratio any smaller by, by creating the, the, the smart constructor. But we can, we have an

26:55.040 --> 26:59.280
illusion that tasty ratio is now a smaller value that doesn't have illegal states just because we

26:59.280 --> 27:04.400
made it impossible to create them. So we can program as if the state space really is now smaller and

27:04.400 --> 27:09.200
illegal states are unrepresentable. And again, it's very important to get the smart constructors

27:09.200 --> 27:14.400
right. So it's a one-time effort, which is probably worth it because you just cover it in one space,

27:15.040 --> 27:20.960
and then all of your flows can, can rely on the fact that the invariant, all the invariance you

27:20.960 --> 27:27.760
want are actually enforced. So smart constructors are a great way to enforce diverse invariance

27:27.760 --> 27:32.800
and with compiler assistance. So, assistance. So the moment you got it right from there on,

27:32.800 --> 27:37.840
you know that the compiler won't let anyone bypass this invariant that you're trying to enforce.

27:38.880 --> 27:43.040
And as a bonus, our type signatures are becoming, becoming kind of self-documenting because our

27:43.040 --> 27:47.280
types are now representing actual invariance that we care directly, directly in our code. And it's

27:47.280 --> 27:51.680
better than comments because they will never go out of date. The compiler is there to keep everything

27:51.680 --> 27:57.440
in check. But we do have to be careful when defining smart constructors because, as I said,

27:57.440 --> 28:02.480
you have to get that function right. And so unlike algebraic data types where you are kind of correct

28:02.480 --> 28:08.240
by construction, smart, smart constructors are usually have to do some unsafe work to make

28:08.240 --> 28:13.120
sure that everything else is safe. And so when possible, if you can represent something with

28:13.120 --> 28:18.560
an algebraic data type, that's probably the preferred way. But when, when they work, smart

28:18.560 --> 28:28.080
constructors are a great tool for excluding illegal states. So one, one last, last problem to

28:28.080 --> 28:35.920
tackle with a robot. So brewing coffee is, again, no surprise, a complicated process as well.

28:36.480 --> 28:42.080
And let's try to model a small part of brewing coffee. So here's one, one way to kind of

28:42.080 --> 28:46.960
model this, this process. So we have this, this kind of imperative interface that you might,

28:46.960 --> 28:53.520
you might expect for operating a robot with a bunch of kind of low-level commands that,

28:53.520 --> 28:57.760
that can be used for, for the brewing stage. And assuming that someone actually implemented

28:57.760 --> 29:02.800
this at the robot level, we can write the code for, for preparing for brewing, not the actual

29:02.880 --> 29:06.960
brewing, but just the preparation. And so this looks pretty informative. We just call, call the

29:06.960 --> 29:15.600
various actions in order. Anyone sees a bug here? So, disgustingly, we forgot to rinse the filter,

29:15.600 --> 29:20.400
and now our users are going to drink this paper-tasting coffee, and, and probably we'll just

29:20.400 --> 29:26.720
throw our, quit our robot and, and, and we will lose customers. So, so the reputation of the

29:26.800 --> 29:32.400
robot depends on it, and we'll, we just messed up a good cup of coffee. But, but more seriously,

29:33.120 --> 29:38.400
this, this code is very, very open to, to potential bugs, bugs that, that is illegal states.

29:39.360 --> 29:44.240
So you can, you can forget action just like, just like I did right now with the filter answering.

29:44.240 --> 29:48.320
You can mix up the order. You can, you can duplicate actions. Everything can happen here. It's,

29:48.320 --> 29:53.600
it's full of possible legal states. And if it's, if it's possible, we're most likely to hit it at

29:53.600 --> 30:00.640
some point. Maybe a refactoring gone, gone wrong or something, something else will can go wrong.

30:00.640 --> 30:06.480
And the problem is here that even if, if we do, do mix something up, the compiler won't help us.

30:06.480 --> 30:11.680
It doesn't know anything about it. So just compile fine and, and just be wrong. So again,

30:11.680 --> 30:15.680
this is our desired state space. It's quite simple. It doesn't really have many, many things that,

30:15.680 --> 30:22.400
that it has to do. But again, our actual code is open to various illegal state transitions that

30:22.400 --> 30:27.920
we can, we can make that we would like to avoid and make them compile time and possible to actually

30:27.920 --> 30:35.840
write down. So we can improve as well. So a big part of the problem here of the issue is that,

30:35.840 --> 30:40.560
is the imperative interface. It's, it's, it just tells us the actions we, we want to perform.

30:40.560 --> 30:44.640
It doesn't have any information, very little information about the intent of this action

30:44.640 --> 30:49.920
and the consequences of it. So, so if, if we have a unit return time of something, it doesn't

30:49.920 --> 30:54.480
really tell us much about what did we want to achieve or what actually happened. So, and so,

30:54.480 --> 30:59.840
since so little is reflected in the types, it's, it's not, it's not a surprise that the compiler

30:59.840 --> 31:04.080
can't really help us because the compiler works usually with types and that's, that's its way to

31:04.080 --> 31:08.560
support us. And so the solution will be to become more declarative. So we're leaving the

31:08.560 --> 31:12.880
imperative, imperative interface behind and, and trying to make it more declarative. So we start

31:12.880 --> 31:18.000
by just adding, adding expectations. So what, what, what we aim to achieve on every action. So,

31:18.000 --> 31:23.680
for example, the place filter function now, once invoked, will return a filter placed value,

31:23.680 --> 31:29.200
which will correspond to the fact that the filter was indeed placed. And so on for all the other

31:29.200 --> 31:34.400
functions. And we're not done yet. So we have another, we do have some various prerequisites. So

31:34.400 --> 31:39.680
we, there's some ordering that, that has to go on here that, that is otherwise illegal. And so

31:39.680 --> 31:44.640
we're going to define prerequisites as function arguments. So placing a filter cannot occur

31:44.720 --> 31:49.760
unless the filter was folded before. So we make the explicit in our function by requiring an

31:49.760 --> 31:54.080
argument that the filter was actually folded. And the same thing goes for rinsing the filter,

31:54.080 --> 31:58.560
which can't happen unless the filter was placed and the water was heated. And the same thing for

31:58.560 --> 32:03.120
grounds that you, if you want to add them, they must be actually ground. And the filter must be

32:03.120 --> 32:08.880
rinsed to prevent the bug from, from before. And so basically what we were doing here is we're

32:08.880 --> 32:15.360
encoding kind of business rules directly in our signatures. And once we do that, in turn, it

32:15.360 --> 32:24.080
means that code that violates those rules won't even compile. It becomes literally unrepresentable.

32:24.080 --> 32:29.360
And so we can now implement our prep flow from before. So instead of having our implementation

32:29.360 --> 32:34.240
returning unit, we now have a more informative, more informative signature that tells us what

32:34.240 --> 32:38.960
actually was achieved during that process. So after we finished the prep, water was heated

32:38.960 --> 32:44.240
and grounds were actually added. So there's no avoiding that now. Every implementation of this

32:44.240 --> 32:52.560
code has to, to do something about it. And so since our types are so, so descriptive, now again,

32:52.560 --> 32:57.680
again, this ability to kind of follow the types to implement our flow. So this is very similar to

32:57.760 --> 33:05.040
the code that we had before. But now we have to press around various outputs from our actions. So

33:05.040 --> 33:09.360
this code is still incomplete. But the nice thing here is that the compiler now helps us. It tells

33:09.360 --> 33:16.000
us, well, you forgot to make sure that you followed the filter before you placed it. And so we can

33:16.000 --> 33:19.920
fix that. And now the compiler tells us, okay, but if you want to add grounds, you have to, you

33:19.920 --> 33:24.320
have some prerequisites. So let's fix that. We have to have the coffee ground and the coffee

33:24.320 --> 33:29.680
ground and filter placed. And now we still have the same bug from before. We still, we forgot to

33:29.680 --> 33:34.480
rinse the filter. But this time, the compiler will tell us, you forgot to rinse the filter. So you

33:34.480 --> 33:40.720
have to do that before you can actually add your grounds. And so we fix that. And now the compiler

33:40.720 --> 33:48.080
is happy. And we are happy because our clients are happy. So because we shared our business rules,

33:48.160 --> 33:55.680
business knowledge with the compiler, the compiler was very helpful in actually enforcing this

33:55.680 --> 34:05.680
for us and making it impossible to stray from the right path. Also notice, so by making everything

34:05.680 --> 34:11.040
more declarative, it's now much easier to figure out what flows where and what goes in which way.

34:11.040 --> 34:18.640
And so in essence, our function dependencies are defining requirements and making the flow much

34:18.640 --> 34:23.520
more limited in what can or can't happen. And so this, for example, opens up opportunities for

34:23.520 --> 34:27.680
parallelization. So if you see that two functions are independent, you might be able to parallelize

34:27.680 --> 34:32.560
them. And the nice thing here is that the compiler will help you get it right because it knows what

34:32.560 --> 34:39.520
can or cannot be parallelized. But there is something that I didn't specify for the moment. And

34:39.520 --> 34:45.200
what are those types? The water heated and grounds added types and all the rest I just used here.

34:45.920 --> 34:50.560
So I just assumed that they are there, but I didn't actually specify them. And the answer is I don't

34:50.560 --> 34:56.640
care. I literally don't care about those types. So much so that I can actually represent it in our

34:56.640 --> 35:02.160
type signature. So brewing prep doesn't really depend on the specific values of all the types of

35:02.160 --> 35:06.000
coffee ground, water heated, and the like. Why? Because it just passes them around. It doesn't

35:06.000 --> 35:10.560
inspect them in any way. It just passes them around as kind of tokens of security, but it

35:10.560 --> 35:15.680
doesn't do anything else with them. And to make this explicit, we made our brewing prep function

35:15.680 --> 35:22.640
parametric. So now it takes six type arguments, although sounds scary. But since we don't care

35:22.640 --> 35:27.680
about the actual values, we can do that. And everything will just work the same way as before.

35:27.680 --> 35:35.280
So we explicitly declare the fact that we are invariant and don't care about how those types

35:35.280 --> 35:42.320
are specified. Now, in order for this to work out, the brewing actions interface has to be

35:42.320 --> 35:47.600
adapted as well. It has to be parametric in the same way. But because slide space is kind of

35:47.600 --> 35:52.560
limited, I'll abbreviate for a moment. And so now brewing actions is going to take the same

35:52.560 --> 35:58.880
six type parameters. And so now we are kind of consistently, the code looks exactly the same,

35:58.880 --> 36:04.480
but now we have type parameters. You might ask, why would you do that? And the answer is if you

36:04.480 --> 36:08.800
don't care about the inputs and outputs, if you make them parametric, it leaves you very little

36:08.800 --> 36:14.000
space to actually cheat. So in case I want to pass the water-heated value and have to return it

36:14.000 --> 36:18.960
for my signature, there's no way to obtain a water-heated value because from anywhere else,

36:18.960 --> 36:23.440
other than calling heat to water, because I have no idea what the type really is. It's parametric,

36:23.440 --> 36:28.880
so I have no information on how to obtain it. I don't know what it is, so it's just impossible.

36:29.440 --> 36:35.440
And so in this case, we're just forced to do the right thing because there's no way to cheat. If

36:35.440 --> 36:40.080
it was a unit or some other kind of simple value, we just could return that. But in this case,

36:40.080 --> 36:46.320
we can't because it's type parameter. And as a nice bonus, this approach actually gives us,

36:46.320 --> 36:49.120
although it limits the implementation, which is a good thing, it does give us

36:49.840 --> 36:55.040
various flexibility degrees of freedom when creating brewing actions because the type

36:55.040 --> 36:59.520
parameters can be set to whatever we actually want in brewing actions and still use unit, and

36:59.520 --> 37:04.400
maybe we can use something more informative in tests. And so this gives us actual, the limitation

37:04.400 --> 37:09.280
on this side actually gives us more flexibility in other places, which is a nice bonus, but

37:09.920 --> 37:16.800
it's not directly related to what we're doing here. But the point is that the brewing prep

37:16.800 --> 37:22.320
doesn't care about how those inputs work, and so we can limit it completely to using them correctly.

37:23.120 --> 37:28.960
And so I will point out that this code doesn't prevent every legal state possible. So for example,

37:28.960 --> 37:34.560
nothing stops us from calling fold filter twice. That might be, might be illegal. And in general,

37:34.560 --> 37:39.440
it's not always possible to limit every possible, every possible illegal state, but it's better to

37:39.440 --> 37:48.240
get something right than nothing. So I do think it's an improvement. So being declarative is a

37:48.240 --> 37:53.040
great way to encode your business rules directly in your types. That way the compiler can help you

37:53.840 --> 37:59.920
enforce those rules and making every breakage of the encoded rules impossible at compile time,

37:59.920 --> 38:04.800
and thus it's unrepresentable. And the good first step when trying to do things more declaratively

38:04.800 --> 38:09.280
is figure out where you have those redundant units that don't communicate any information

38:09.920 --> 38:15.760
about what the function does, and then try to see how you can solve it. And by making everything

38:15.760 --> 38:21.680
parametric, our code is becoming ignorant of the actual types that we use, which limits the

38:21.680 --> 38:26.960
number of possible illegal states that we can enter. So the less the code can do, the more we

38:26.960 --> 38:40.960
know about what it actually does. So ignorance is strength, like the famous quote. Okay, so we're

38:40.960 --> 38:46.720
done with the various techniques. It might not be obvious from those two examples, like why would

38:46.720 --> 38:52.560
that be useful? Because they're all small examples and kind of hard to see how they work out in a

38:52.560 --> 38:59.520
large code base that you have to maintain for a long time. My point is that all of this kind of

38:59.520 --> 39:07.040
adds up, and eventually it does make your code better in the long run, even if it's not obvious

39:07.120 --> 39:12.560
from the first small steps. But in this section we'll just kind of quickly review what sort of

39:12.560 --> 39:18.400
benefits you can expect to reap from being consistent and making illegal states as

39:18.400 --> 39:23.680
unrepresentable as you can in your code base. So the first point is that code becomes easier to

39:23.680 --> 39:32.480
comprehend. So as I just mentioned, the fewer things the code can do, the easier it is to

39:32.480 --> 39:37.200
understand what it actually does. But more concretely, for example, if you use algebraic

39:37.200 --> 39:42.160
data types consistently across your code base, the compiler can help you figure out what's

39:42.160 --> 39:46.960
happening now. You do a better match. Some editors would actually autocomplete all the cases, and

39:46.960 --> 39:51.120
you can now figure out what's going on, what information you have, what can you use and

39:51.120 --> 39:56.560
the like, and the compiler got your back. Not only that, it can also, as I mentioned,

39:56.640 --> 40:02.080
automatically do accessibility checking, so you're sure to not forget anything in case anything

40:02.080 --> 40:10.160
changes. And so this is definitely an improvement on your ability to figure out what's going on.

40:10.160 --> 40:14.640
And also a common theme throughout the examples is that our type signatures are becoming more

40:14.640 --> 40:18.960
informative. They encode more and more information about what's going on. So just by reading the

40:18.960 --> 40:25.600
signatures, it becomes easier to figure out what are the limitations, what is allowed, what is

40:25.600 --> 40:34.000
disallowed, and the like. Fewer bugs. So every legal state that you precluded and made unrepresentable

40:34.000 --> 40:38.640
is a potential bug that you avoided. So, for example, creating an Irish coffee order without

40:38.640 --> 40:43.040
whiskey is no longer possible. It's not a state that you can write. This is a compilation error.

40:44.240 --> 40:48.720
Nor this, like serving coffee and to an empty list of cups. Again, this is no longer possible

40:48.720 --> 40:53.440
because you enforced it at compile time, and this is a bug again that cannot happen anymore.

40:54.400 --> 40:59.040
And since they are unrepresentable, you don't have to test for them a lot. So this is our next

40:59.040 --> 41:04.800
point, is that you can do fewer, if you make as many legal states unrepresentable as possible,

41:04.800 --> 41:10.320
this leads to fewer tests that you actually have to write. For example, this test can't be

41:10.320 --> 41:17.280
expressed. Again, testing whether Irish coffee order has whiskey is no longer relevant because,

41:17.280 --> 41:22.800
again, even the test can't even compile. So that's a test that you don't have to write,

41:22.800 --> 41:26.960
and some tests, for example, are still possible to write but maybe more redundant because you

41:26.960 --> 41:32.560
don't really need, if your interface is sufficiently declarative, it might be kind of obvious on

41:32.560 --> 41:37.680
its own that you don't have to check whether water was heated or not when you done the brewing

41:37.680 --> 41:44.320
prep because the types are requiring that. And the last point is safer refactoring. So your

41:44.320 --> 41:49.040
code becomes much easier to refactor. For example, this code, the get calls on the optional values

41:49.040 --> 41:55.280
are only safe somewhat in the case that you're ordering Irish coffee. But imagine that you're

41:55.280 --> 41:59.680
doing refactor and now the prepare Irish coffee call moves to another place. Now it's in some

41:59.680 --> 42:04.240
other place and nothing is actually checking whether we're in the right case. So this is no

42:04.240 --> 42:10.320
longer safe. On the other hand, this code with the pattern match is safe by construction. If you

42:10.320 --> 42:14.640
try to move the call to prepare Irish coffee, the code will fail to compile because it will no

42:14.640 --> 42:22.880
longer have the references to the right information that it needs. And another refactoring is if you

42:22.880 --> 42:27.840
add something, for example, again, the compiler will verify that you matched all the various

42:27.840 --> 42:33.440
types, all the various cases that you have and will enforce again that you don't forget anything.

42:33.440 --> 42:39.680
Another example of refactoring is I mentioned in the previous section that we can paralyze

42:39.760 --> 42:46.160
some actions here. So we can, for example, heat water, grind coffee, and the rest can be

42:46.160 --> 42:50.160
paralyzed because they have no dependencies. So this is a refactoring that's easy to get wrong

42:50.160 --> 42:55.680
because if you mess something up, things will run in parallel when they shouldn't. And in the

42:55.680 --> 43:00.080
bad example, that would be just broken. But here we can write this code. And if we mess something

43:00.080 --> 43:04.800
up, the compiler will tell us you're missing some dependencies. You can't run this in parallel.

43:05.120 --> 43:15.600
So as people work and maintain large code bases, I think those benefits kind of add up and investment

43:15.600 --> 43:19.600
that you're making on making legal states unrepresentable is definitely, definitely worth

43:20.480 --> 43:31.120
the effort. So to conclude, almost done. So whenever you tackle a new domain, try to think

43:31.120 --> 43:37.040
about the state space of your problem, the various states that the system can arrive at and what

43:37.040 --> 43:45.280
can happen. Find the legal states in your system and define them to match your requirements or

43:45.280 --> 43:50.400
whatever other error conditions that you might care about. And all the other states are illegal.

43:50.400 --> 43:56.080
Now, if all you do is just think, just sit there and think about your state space in the legal

43:56.080 --> 43:59.360
and illegal state, that's already a great first step. You don't have to do anything else.

43:59.360 --> 44:02.960
That's already a good way of getting your code to be better just by knowing

44:02.960 --> 44:07.440
what's possible and impossible. But if you actually want to reap the benefits from this

44:07.440 --> 44:13.200
talk, make those states unrepresentable. And the benefits are fewer bugs, fewer tests,

44:13.200 --> 44:19.440
easier to comprehend code. And you don't have to worry anymore about states that are illegal

44:19.440 --> 44:23.040
because you made them unrepresentable. So you don't have to think about them anymore. That's

44:23.040 --> 44:27.360
a great thing to do. When you don't have to think about something, you can think about something

44:27.360 --> 44:34.560
else, which might be useful. And so we saw a number of techniques to achieve this goal.

44:34.560 --> 44:39.280
So algebraic data types help us reduce the state space into something smaller and more

44:39.280 --> 44:44.880
manageable. Smart constructors let us enforce various invariants and declarative signatures

44:44.880 --> 44:50.160
make various business rules kind of apparent in our code. And parametric polyphysm is like a nice

44:50.160 --> 44:56.480
cherry on top if you want to really kind of go at it even more limited. So there's a slide about

44:56.480 --> 45:01.440
where to go next. So I covered some very basic techniques. There are other approaches that

45:01.440 --> 45:08.000
you can take, which probably have a steeper cost-benefit ratio. So it might be not worth it.

45:08.000 --> 45:13.360
But these are some ideas of what you can think of, especially various type systems. So a lot of the

45:13.360 --> 45:18.800
things we've done are kind of bound by the type system that we're using. And so maybe trying

45:18.800 --> 45:26.080
other more advanced type systems or type system features can help you make things easier.

45:26.480 --> 45:31.280
If you're taking a photo, you can do that. I'll post the link to the slide so everything is there.

45:31.280 --> 45:37.120
And there's some inspiration for various resources that I think are kind of useful in thinking about

45:37.120 --> 45:44.000
problems. And again, I'll post the link for the presentation. All the links will be available.

45:44.000 --> 45:50.400
So it's my time to wrap up. So remember our poor little user that was trying to register and didn't

45:50.480 --> 45:57.200
have an email. So somewhere someone is trying to introduce another bug in our system. But luckily

45:57.200 --> 46:04.240
we applied all the techniques that we studied right now. And it no longer compiles. The illegal

46:04.240 --> 46:11.680
states is unrepresentable. The compiler tells us that and we can sleep quietly tonight. So hopefully

46:11.680 --> 46:18.400
I managed to convince you that making illegal states unrepresentable is actually worth the effort.

46:18.400 --> 46:23.520
And this is linked to the presentation. And if I have time for questions, I'm not sure.

46:24.240 --> 46:27.840
Yes, we can try to take one online question first, maybe.

46:32.800 --> 46:37.280
Can you please read it out for our audience? I guess you're in favor of using something like

46:37.280 --> 46:42.080
refined to express even more constraints in types instead of custom smart constructors. Yes,

46:42.480 --> 46:51.760
the one of the last slides, I used refined as there's a link to the refined library here in

46:51.760 --> 46:57.360
the end. So yes, refined is a nice library that can help you automate the process of creating

46:57.360 --> 47:02.240
smart constructors. Instead of writing them manually by hand, you can use a library that

47:02.240 --> 47:07.600
helps with that. All right. Thank you. We have also one question here on site.

47:08.320 --> 47:15.680
Hi. So thanks for the great talk. In the example about algebraic data types.

47:21.520 --> 47:28.000
It was the example of ordering different types of coffee. But what happens if the coffee shop

47:28.000 --> 47:34.400
owners have a business requirement that at any point of time, she wants to be able to add a

47:34.400 --> 47:39.280
new type of the coffee? So what happens to our algebraic data types with such a requirement?

47:39.280 --> 47:45.360
So there's often kind of people debating whether types are useful or not, or kind of this conception

47:45.360 --> 47:50.320
that you have to go all in or nothing. So either you specify everything and everything is fixed

47:50.320 --> 47:55.760
in types or not. This is not the case. If you want some flexibility, you can live that measure

47:55.760 --> 48:00.960
of flexibility as your requirements desire. So in the case of maybe having another case which is

48:01.040 --> 48:05.200
more dynamically defined, maybe have another case which is dynamic. And then you'll be extra

48:05.200 --> 48:10.480
careful around that case. But still, you now have a small island of sanity where you know what's

48:10.480 --> 48:15.360
going on and another section of the code which is not as pleasant and safe. But still, you can

48:15.360 --> 48:20.080
separate the parts. What you know, you can encode. What you don't, leave it as an unknown and handle

48:20.080 --> 48:25.840
it appropriately. Okay. Thank you. We have one more online question. If you could again, please read

48:25.920 --> 48:33.680
it out. So only recently I started learning Haskell and Idris from the perspective of making

48:33.680 --> 48:37.600
illegal states not representable. It seems to me that type-driven development

48:37.600 --> 48:44.320
advocated by Idris is more suitable. Then again, I'm a beginner. So yes, Haskell and Idris both

48:44.320 --> 48:51.600
have various advanced type-level features and things you can do that make it possible to exclude

48:51.680 --> 48:57.760
even more illegal states. And as I mentioned, using more advanced type systems is a good way

48:58.640 --> 49:04.960
to enforce more invariance. But the question is kind of the cost, whether it's worth it,

49:04.960 --> 49:09.840
especially as a beginner, because if you play something very, very kind of a heavy tool that

49:09.840 --> 49:14.720
does something very sophisticated, it might be more difficult to maintain. So I think you

49:14.720 --> 49:19.440
should kind of gradually ramp up there and eventually maybe use it, but have a good way

49:19.440 --> 49:23.360
to judge whether it's worth it or not. So start simple and then gradually improve.

49:24.160 --> 49:28.160
All the things I did mention now are available in both Haskell and Idris. So that's not

49:28.160 --> 49:33.200
actually a problem. And you can start there and move on to something more advanced. Okay. We

49:33.200 --> 49:40.880
have time for one last onsite question here. Thanks for a great talk. I'm wondering if any

49:40.880 --> 49:45.360
of the techniques that you mentioned are applicable in dynamically checked languages?

49:45.360 --> 49:52.720
And if you have an experience in doing so, maybe? So in dynamically typed languages, everything's

49:52.720 --> 49:57.360
applicable. You can write anything. The question is whether who enforces things for you. So in

49:57.360 --> 50:02.480
a statically typed language, the compiler is much more your friend than people usually think.

50:03.600 --> 50:07.360
And then in dynamically typed language, first of all, just thinking about the state space,

50:07.360 --> 50:10.720
you can do it in any language on a piece of paper. It doesn't really matter. And it's already an

50:10.720 --> 50:16.640
improvement. And then if you are explicit about what's illegal, at least you can force your

50:16.640 --> 50:22.160
invariance even in a dynamic context. For example, your smart constructor won't return an optional

50:22.160 --> 50:27.680
value, but will throw an exception. But at least you limited the scope of where things can go

50:27.680 --> 50:32.560
wrong, for example. And pattern matching is available in various languages. Although there are no,

50:32.560 --> 50:37.760
the guarantees might be somewhat looser, but still it's better than nothing. So those approaches

50:37.760 --> 50:43.440
can help you, but they won't gain you as much benefit as they are in a statically typed language,

50:43.440 --> 50:53.680
I think. All right. Thank you very much, Daniel. Please help me thank him.

