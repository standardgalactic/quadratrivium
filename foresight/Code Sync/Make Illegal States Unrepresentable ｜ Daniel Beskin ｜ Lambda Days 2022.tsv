start	end	text
0	23760	We're here to talk about this great quote up there by Jaron Minsky, make legal states
23760	30320	unrepresentable. And although it sounds quite simple, I find that the consequences of it are
30320	37520	quite profound. But before we actually begin and dive in, let's start with kind of a short story
37520	42240	as an introduction. So it's the middle of the night and you're sleeping peacefully.
42880	48560	And suddenly you get a call and you're being informed that the production system is crashing.
49520	57760	And after a few minutes of furious debugging, you find this exception that happens. Someone
57760	64400	accessed an empty optional value. And how can that be? You ask yourself. And so you dig a little
64400	71120	deeper and you find this wonderful code. So someone unwrapped an empty option value. And
71120	76720	you read this comment. This is safe. Registered users always have email. And it's a very nice
76800	83280	comment. And the old caps are stressing the right points. And it's a very reasonable assumption
83280	89440	because registered users should have emails and the product manager also required that as well.
89440	97280	So what went wrong? And basically what happened is that we entered an illegal state of our system
97280	102560	and doesn't really matter how we got there. But these sorts of situations happened all the time.
102560	108400	I'm sure most of you had some experience seeing some error of this kind happening to you.
108880	114640	And those things can be avoided. And I would say they must be avoided because all would like to
114640	121760	have a good night's sleep. But this is what we're here to talk about. How to make these illegal
121760	127680	states unrepresentable. How to make it impossible to create software that enters those illegal states.
128640	136720	So today we're going to discuss this quote. What it actually means. We'll break it down into
136720	144080	smaller parts. Then I'll show some simple techniques to try to achieve this ideal of making
144080	148640	illegal states unrepresentable. And we'll conclude with seeing what are the sort of benefits that
148640	155840	you might expect to reap in case you actually follow this principle. So this is mostly a beginner
155840	161120	friendly talk. So don't expect some mind blowing techniques. But I do hope that the
161120	165680	perspective I am about to show is useful even for more experienced developers.
167520	173520	So as far as I know this quote was created in the context of working on a financial system.
173520	181520	So Jaron Minsky is, was working on Jane Street. And I can imagine that making illegal states
181520	185680	unrepresentable in the financial system is very, very important because you probably don't want
186720	192960	to lose transactions or money or whatever. So let's dive in and figure out what it means to
192960	200080	that an illegal state is unrepresentable and how do we define it. So we start with the state.
200080	206400	So what is the state of a program? So imagine your whole application running and take like a
206400	211920	single, single snapshot in time with all the variables and all your variables, threads,
211920	217280	function calls, whatever. So single snapshot of your program. So this is an example of such
217840	222000	states. So you have some variable assignments. You have maybe registers,
222000	225840	heap allocations, whatever. Threads are running. Functions are about to be called.
226960	232080	So this is a single state of the system. So obviously a real system will have many, many,
232080	239200	many states. But for the purposes of this talk, we're going to kind of zoom out and from the
239200	246160	details of registers and threads and like, and just have like a conceptual picture of the different
246160	252800	states of the system. So this is our program's state space. All the different states, it can find
252800	259040	itself in. So, but some states are illegal. That means that if you enter that state, something
259040	263440	bad will happen. The program will crash. An exception will be thrown. Maybe a business rule
263440	268320	will be violated. But something, whatever it is, it's something that's bad for your system and
268320	274480	something that you would like to avoid. So of course, what's considered illegal is very context
274480	280080	dependent and it depends on what you care about at the moment and the various tradeoffs. But let's
280080	288000	assume that we can recognize an illegal state once we see it. And so the picture I'm showing here
288080	292560	is that we have like a huge state space and have a few legal states. But usually the reality is much
292560	298480	worse. Usually you have a lot, a lot of states that are actually illegal. And so hitting them
298480	303280	and usually by accident is just a matter of time. You walk around your kind of state space and,
303280	307920	and just accidentally stumble on something illegal. And that's, that's quite likely to happen just
308000	318720	like the registered user in the previous example. So let's zoom in a bit and enter this diagram. So
319440	324800	a typical program will probably be moving between lots of states. Hopefully, and, and we can assume
324800	330880	usually between legal states, which are okay for a system. But sometimes you'll probably by accident
331520	337200	hit an illegal state and your system might crash or violate some rule or do something bad. And
337200	341440	usually if you got one illegal state, you probably will get another illegal state.
342880	346640	And this is not good. And this is what the sort of things that we would like to avoid
346640	352640	in the context of this quote and probably just in general in programming. So let's zoom in a little
352640	358720	more. So, so as high level programmers, we typically don't think about registers and threads and,
358720	364480	and, and the heap and the like. And as functional programmers, we typically want to represent as
364480	370640	much as possible of our application as functions. So imagine that this is this function signature
370640	376640	here is some part of your system. You have some inputs, you have some output, and, and, and you,
376640	381120	you would like to analyze what's possible and impossible here. So what do I mean that an illegal
381120	387520	state is representable? It's that there is some combination of the inputs ABC that would, that
387520	391600	would get you into an illegal state. Okay, that would mean that the state is representable. You
391600	397440	can find such inputs and you'll, and you'll get an illegal state directly in your system.
398080	402800	And what we want, what we strive to achieve is to make it impossible for to find such inputs
402800	408720	that would get us into this illegal state. So imagine that it's, it's literally impossible
408720	413920	to write down such inputs that would get you into a legal state that you cannot get there at all.
415120	419120	And all you can do is kind of walk around the legal states and just never worry about
419120	425600	entering the illegal, the illegal red dots here. And so this should be possible not because you
425600	428880	checked and double-checked your inputs and not because you covered everything with tests, but
428880	434320	because you make it strictly impossible to write down those inputs that would, would get you into
434320	441840	an illegal state. So that's at least the ideal that we want to, want to reach. And question is
441840	446080	whether it's a reachable idea, ideal, can you, can you actually do that? And probably the answer
446080	450640	is generally no. You probably can't avoid all illegal states, but I would claim that every step
450640	454720	you make in that direction is, is a good step and probably is improving your software in some,
454720	460240	in some way or dimension. Also, question is whether it's worth it. I'm going to show you some,
460240	464720	some techniques that you have to apply to your code and then maybe there's some, some costs and
464720	470080	it might, might not be worth it. And that's, again, can be, can be true that's maybe too
470080	475520	expensive, but the, the sort of techniques I'm about to show you now are quite, quite lightweight
475600	482320	and hopefully the cost-benefit ratio is, may, would make them worth it. And although it's
482320	488240	possible to, to avoid illegal states in pretty much every paradigm and language, but strongly,
488240	493760	strongly typed functional programming is, is very good at it. So because types makes it easier to
493760	499760	define, define our state, state space and, and functional techniques make, makes it, once you
499760	505520	define and recognize an illegal state, they, they, they make it easier to avoid various illegal
505520	519200	states. Okay, so now that we, we know what are illegal states, so slide, slide the gray,
519200	527280	digression into something else. So I'm not sure what is or so, but empirical evidence shows that,
527440	533600	that people really, really like coffee. I myself don't drink coffee, so I can't really relate,
534160	540080	but apparently making coffee is very, very complicated. And here's a, a diagram that's,
540080	545520	that's obviously has lots of different states and I'm sure some of them are illegal. And since I
545520	549600	don't know much about coffee, I thought maybe it will be a good idea to use it as kind of an example
549600	556560	domain to, to, for, for this talk that we can explore and try to kind of make more, more legible
556560	564480	for, for our purposes. So, so imagine that you're tasked with programming this, this coffee making
564480	570800	robot. So lots of things can go wrong when you program a robot, I imagine, especially one that
570800	576400	does something as complicated as creating coffee, because coffee drinkers are, are very, very specific
576400	581520	about what and how they are willing to drink. So there's a huge state space here and lots of
581520	586160	things that can, can go wrong. And we'll just try to tackle like small sub-problems from this
586160	591920	domain and see, see how we can improve what we see. So we start with, with the simplest part I,
591920	598320	I could possibly imagine here, ordering coffee. So again, imagine that you are, you are doing
598320	602160	this kind of proof of concept of your, of your robot. You want to show that it can actually do
602160	607840	something useful. So you want to specify the, how to order a cappuccino, which is, so I hear a popular
607840	613600	drink. So your users have to specify what kind of milk they want in the cappuccino. And apparently
614560	619520	milk choice is also a complicated topic. So milk is not some trivial type, but, but in the
619520	625520	enumeration of various, various, various options. So after successfully making cappuccino, you think,
625520	630800	okay, let's, let's see. It kind of works. Let's, let's do something more, add something to, to a
630800	635360	repertoire to make it more interesting. So since you already know how to do cappuccino espresso,
635360	640480	apparently according to this picture there is, is pretty much the same thing, but minus the milk.
640480	644720	So you make your milk an optional, optional argument in this case. So, so that you don't
644720	649520	require it anymore. And now if you don't have milk, you make an espresso espresso. If you have milk,
649520	656400	you, you do cappuccino. And now let's set another one, latte. So latte is basically, apparently
656400	661840	again, by this diagram is just the same as cappuccino, but with more milk. And so we have a
661840	667760	problem. We have an ambiguity. Both cappuccino and latte require, require milk. So we have to
667760	673600	somehow tell them apart which, which order are we talking about. So in order to make it easier
673600	678160	to figure out what's going on, we were going to add another enumeration, the drink type,
678160	682960	which will actually tell us what kind of order are we dealing with here. And so we have kind of
683040	688480	three cases for cappuccino espresso and latte. And that's a nice way to kind of future proof
688480	693280	ourselves from future, future drinks that we might want to add, because now we could easily add them
693280	699840	to our enumeration. So, so that's, that's a nice, nice bonus. And so now that you, you have some
699840	704160	basic drinks and, and you know how to make them, you want to show off how your robot can actually do
704160	708560	cause something more complicated. So you want to do two fancy drinks in this case. So want to
708560	713920	try and do affogato and Irish coffee. Fortunately, botanary require more, more ingredients. So we
713920	720240	need to add gelato and, for the affogato and the cream and whiskey for, for Irish coffee. And that's
720240	726000	a good place to stop for a moment and take a look at what we have. So we support, support five different,
726000	731120	different types of drinks, which is nice, but we have lots of various optional values. It's
731120	736960	completely non-obvious, which, which combinations are actually legal here. So can, can I mix milk
737040	740960	into my Irish coffee or some, some such. It's not obvious from the type sense.
743600	748160	And it's easy to get confused. So let's, let's try to step back for a moment. So what is the
748160	752960	issue here? So this is again kind of a simplified state diagram of what, what we want to achieve. So
753600	758800	we have five legal states, five states that we actually want, want to support. So which one
758800	763680	corresponding to some drink that we have in our system. But we also have various combinations
763760	768640	that, that are illegal in some sense. So for example, espresso, espresso with gelato is just
768640	773840	redundant because we're just rediscovered affogato, but though some drinkers might be offended.
775200	780880	But Irish coffee without whiskey is obviously an illegal state if I ever seen one. So it makes no
780880	786560	sense at all. And there are many other states here that, that many combinations of various
786560	792240	inputs that we can get here that are completely illegal and make no sense. So let's, let's think
792240	796880	more concretely why, why this is a problem. So suppose we have some low level function that
796880	801600	actually tells the robot how to prepare the Irish coffee. And it has to take two arguments,
801600	806080	cream and whiskey, because that's, that those are the parameters that we need to specify for,
806080	810160	for this drink. And imagine that you were trying to actually take an order and prepare the Irish
810160	818320	coffee. So in case you are in the Irish coffee, Irish coffee order, you access the cream and whiskey
818320	824080	and then, and then prepare Irish coffee. Now notice that we are accessing optional values
824080	830240	and we are very careful here. We have a comment that says this is safe. That's probably okay,
830240	836000	right? I mean, what, what could possibly go wrong? So, because it makes no sense to have empty
836000	841840	values on, of cream and whiskey in case someone ordered an Irish coffee. So maybe just in case,
841840	845760	because we don't want to be too troubled with debugging late at night, we will make it even
845760	850240	more explicit. So we will throw a nice exception that has more, more information. So it might,
850240	854720	might be nicer to debug, but it's really, really isn't possible. I mean, you can't have Irish coffee
854720	863680	without cream and whiskey. And, and, and this is sort of an invariant that we're assuming over
863680	868320	our code. In this case, the invariant is quite simple. Irish coffee always has cream and whiskey,
868320	872720	but nothing is enforcing this invariant. We're kind of writing comment and have,
873280	877520	have suffered from a wishful thinking that may, hopefully nobody will ever break this,
877520	882560	this thing apart. But imagine that in the future, you're supporting reading orders from JSON files
882560	887120	and someone messed up the format and then something is missing. Who knows? Something can
887120	892000	happen and you can't write tests, tests to cover all of your flows in your system probably. And
892000	896400	even less so, you can't write tests for future flows that someone might define, that are not
896400	900240	defined right now. How, how can you protect against something that you don't even know that will
900240	906480	exist in your system? And so, so, and you might be actually thinking that, okay, I'm very bad at
906480	913920	designing data types and that's why I have this kind of bad, bad definition of, of an order. But
913920	918720	that may be so. But the thing I'm trying to assert here is not something that happens in a single,
919440	923040	in a single step. Usually, it kind of creeps up on you. You start with something small and
923040	927920	gradually it increases, grows, and then becomes this huge thing full of illegal states that you
927920	933040	can, you're really dependent on and can't, can't really disentangle from, from your system. And,
933040	937520	and then you again enter this, this space where you have lots of illegal states and nothing to do
937520	950640	about it. But we can, can do better, a lot better. So, sorry. So, so our problem here is that our
950640	956560	type is in a sense too big for a problem. We have, we define some schema for possible, possible
956560	960800	combinations of inputs and it's too big. Our state space contains lots of things that shouldn't
960800	968320	be there. And algebraic data types are a really good way and methodology to, to create types of,
968320	973840	of the right size, types that can actually fit our domain in a way that, that really is exactly
973840	980080	what we want and nothing else. So, let's rewrite our data type as, as an algebraic data type in
980160	988720	this case and some type or in enumeration in Scala syntax now. So, we're going, instead of writing
988720	992720	coffee order where everything is placed to kind of in the top level with all the options, everything
992720	997280	possible, we're going to split, split it up into various cases. So, we have a first case with
997280	1002560	Cappuccino. Cappuccino requires milk, so it's no longer optional. We have a case for espresso,
1002560	1007520	which doesn't have any, any requirements. So, this, so it's just espresso. We have the case of
1007520	1011440	Latte, which also requires milk, but there's no ambiguity anymore because now it's a separate
1011440	1016560	case and there's no way to confuse one Cappuccino with the other. So, so, and again, the argument is
1016560	1021840	no longer, no, no longer optional. And Afogato requires Gelato. So, this is again a required
1021840	1027760	dependency and we cannot avoid it. And Irish and coffee, which is the, which was our stumbling block
1027760	1031440	now has a required dependency on cream and whiskey and there's no ambiguity anymore.
1032320	1038320	So, not only that it's now much, much clearer what is going on and what, what, what sort of states
1038320	1043680	are legal here and what, what is the actionable data that we have and how to access it. It's
1043680	1048480	literally now impossible to express the legal state I, I, I just described previously. So,
1048480	1052480	the legal states in the previous slide are, are literally unrepresentable. You can't write down
1052480	1059040	the code that, that actually enters those states. So, now we can, for example, in the,
1059120	1063280	when preparing the Irish coffee, we can now safely better match our, on our order. And, and if it's
1063280	1068160	Irish coffee, we know and the compiler provides us with access to both cream and whiskey. And
1068160	1073680	it's definitely there and can be gone and, and can be missing. So, we don't need to assume any
1073680	1079120	invariant about a call or code. Don't have to lie about it in comments. And no, no exceptions can
1079120	1084960	be, can be thrown here or, or any other illegal states. And if we got to this point where it
1085040	1089200	better matched than we have Irish coffee, we know for a fact that all requirements were met
1089200	1093760	and nothing can go wrong in this, in this respect. And this is enforced by the compiler
1095040	1100560	for every possible floor of our program. So, we don't have to try to cover, cover everything
1100560	1106160	with tests. And it's also there, enforced there for the future as well, because the compiler does
1106160	1110000	the same thing for all future flows as well. So, we don't have to worry about it again with tests
1110000	1117600	that we cannot write even. So, the illegal state that I showed before is truly unrepresentable
1117600	1124240	now. You cannot write it down. It cannot exist in the system. So, algebraic data types are, are a
1124240	1130720	great, a great tool you can use to reduce the state space of your, of your problem domain. So,
1130720	1136640	leading to fewer legal states and making the code generally more, more comprehensible. And this is
1136720	1141920	done by making every assumption about your inputs completely explicit. So, in our case, we made
1141920	1147760	every case to correspond to the assumptions about coffee orders that we have at the moment. And
1147760	1152560	the values are now correct by construction. So, you cannot build an illegal order anymore because,
1152560	1157520	because you made it impossible in the type to represent what, what is not supposed to be there.
1159120	1164880	And so, once you do that, you're basically turning your flow into data. So, notice how we no longer
1164960	1170000	have any conditionals. After, after pattern matching and figuring out that we are in the Irish
1170000	1174320	coffee case, that's it. We don't have to do anything else. We don't have to ask, ask and be
1174320	1182400	hopeful that the cream whiskey are present. It's there. It's accessible. And, and so, and so you,
1182400	1188800	you don't have to worry about defensively programming against it. And, and nice bonus in
1188880	1193600	statically type of programming language is where you, for pattern matches, you also have
1193600	1198160	exhaustivity checking. So, in case someone adds another case or something else is changing,
1198160	1203360	changing the compiler will have your back and help you figure out what's missing and what,
1203360	1208320	what you have to add there to be able to handle everything correctly. So, you can't forget anything
1208320	1212960	that you need and don't, can't forget to handle everything. And what's important, the compiler
1212960	1216880	is not providing you with safe access to all the data that you need. You don't have to assume
1216960	1221520	that it will be present when it might be not. It will definitely be there and you can't work
1221520	1228560	around it. So, now that you, and you're basically free from thinking about illegal states and you
1228560	1233600	don't have to engage in defensive programming all throughout your application. It's not a
1233600	1237920	magical solution. You still have to kind of get the, the, the size of your algebraic data type,
1237920	1241600	right? Because my initial example, the first coffee order is also an algebraic data type,
1241600	1247520	but that one was too big for our state space. So, you still have to think, nobody is, is
1247520	1252000	getting away from, from thinking, but still having this perspective and having algebraic
1252000	1257280	data types as, as a tool that you can use to shape your state space is, is very, very useful.
1258880	1263600	And so, this is, I think that algebraic data type, data types of all the features of functional
1263600	1270240	programming are, is probably the, the best cost, cost benefit ratio out there. And if you're using
1270320	1275440	them consistently all over your system, I think that, that will be a great improvement to, to the
1275440	1280640	possible illegal states that you can or cannot represent. And if I were to start on, start on
1280640	1285280	a deserted island or something or programming Java, that probably would be the one feature that I,
1285280	1289440	I would like to have from functional programming. They're that, that useful.
1290080	1300560	So, now we're back to our robot. So, let's try to tackle another scenario. So, successfully
1300560	1306960	defeated the issue of coffee ordering. So, again, apparently that coffee drinkers have lots and
1306960	1311680	lots of neat picks. For example, you can't just pour any amount of water on any amount of coffee,
1312480	1317200	apparently. I don't know why. That would be wrong. So, imagine you have some, some function that
1317200	1321680	does the pouring. So, take some waters, take some grounds and, and does, and pours water over the
1321680	1326320	grounds. So, this function can easily lead us to an illegal state. So, you can just choose the wrong
1326320	1331040	ratio of water and grounds. And there you go. You have a wrong, a wrong state and a coffee that was,
1331040	1336400	that was spoiled by too much water or too little water or whatever. And so, we can do something
1336400	1343600	like this. So, we define a new type called tasty ratio. And we only want to allow tasty ratios
1343600	1348640	in our, in our function. And this seems that, like, that would be kind of better, because
1348640	1352800	here we're explicit about what, what we actually want to achieve. But not really, because the
1352800	1357360	definition of tasty ratio is pretty much the same thing. You just moved, sorry, you just shuffled
1357360	1363840	around your problem into another place. You still can create tasty ratio instances with the wrong
1363840	1370320	proportion of water and grounds. And so, although we claim that tasty ratio is a valid input,
1370320	1375440	we do not enforce it in any way. So, it's, again, another illegal state that's waiting to happen.
1376320	1381280	And since it can be represented in our system, most likely someone at some point will create an
1381280	1388800	illegal instance of tasty ratio and something will be broken. And, and so, in this case, though,
1388800	1393440	we have so many illegal states, because most, most combinations of water and grounds will
1393440	1400000	probably be illegal. So, our state space is just full of illegal, illegal, illegal states. And just
1400000	1406000	a few small number of possible, comparatively small number of, of combinations of, of water and
1406000	1410960	grounds are actually legal. And what we want to achieve is to only be able to write down the
1410960	1415840	legal combinations and making, writing all other combinations completely impossible. That's, that's
1415840	1423040	our goal. So, so basically what we want is some kind of invariant on tasty ratio and invariant
1423040	1427840	that, that tells us that water and grounds are in the right proportion, proportion. And we don't
1427840	1432160	want to be checking it all over, over the place. We don't want to do defensive programming and
1432160	1437760	kind of sprinkle our code with e-falses and exceptions and the like. So, so ideally, so
1437760	1442720	whenever we have an instance of tasty ratio, it has to be, has to be correct and nothing else
1442720	1447200	should be impossible. But unlike the invariant of coffee, of the coffee order, which was kind of
1447200	1451600	simple, is that Irish, Irish coffee must have cream and whiskey. This invariant is, is a bit
1451600	1456960	trickier to get right. And just using algebraic data types, you probably won't be able to easily
1457520	1462000	enforce it in the types. Correct me if I'm wrong if you have a way of doing that, but probably
1462000	1466640	not likely and won't be worth it. So instead we're going to use smart constructor. So smart
1466640	1472720	constructor basically limits the way we can, we can build instances of our, of our values. So this
1472720	1477200	is just called a specific way, but most languages have some equivalent of this. So first of all,
1477280	1482960	we, we mark our constructor as private. So we can no longer instantiate instances of tasty
1482960	1490000	ratio without directly from the constructor. And then we create our own legal, our own smart
1490000	1495520	constructor that, that requires that everything is legal. So the contract of the make function is
1495520	1500640	that it can take any inputs, but it will only produce a tasty ratio only if the inputs are
1500640	1504800	actually valid. And nothing else is possible. And this will be the only way to construct tasty
1504800	1512400	ratios in our, in our program. And so the logic itself is probably not that complicated. So we
1512400	1517840	just verify the, verify the right amounts. But it is crucial to get this right. So this is kind of
1517840	1523040	the safe kernel that you have in your program that users will now assume is correct and can
1523040	1531040	rely on in all other places. So if you got this right, people can, can rely on this invariant
1531040	1536160	now for every place where they stumble upon tasty ratio. So now after, after making the smart
1536160	1541360	constructor and, and forbidding the creation of tasty ratio without, without calling the smart
1541360	1546400	constructor, now the, the, this function is, is safe. It actually does what, what it promises.
1546400	1550640	You cannot call it with an illegal tasty ratio because there are no tasty ratios that are
1550640	1557760	illegal in our system. It's just not possible anymore. So more generally, generally smart
1557760	1563920	constructors are a great way of enforcing diverse invariants. So we can find many examples. So in
1563920	1568480	this case, our signature is, is kind of, again, we have a wishful comment about something about age
1568480	1572880	and, and, and alcohol restrictions, but, but it's not really an invariant that's enforced
1572880	1577920	anywhere. Just wishful thinking. But if you apply the correct smart constructor, you can probably
1577920	1582800	get it, get this, this type that will enforce it. It's not possible anymore to, to do the illegal
1582800	1587920	action of, in this case, pouring whiskey into Irish coffee. And you can have more examples. So again,
1587920	1592720	the first, the, the first, the top signature is always some wishful thinking and a type that
1592720	1597600	doesn't really, really represent well what, what we want. And the second is, is a corrected version
1597600	1603120	where we enforce something in our, on our type and, and usually we close it off with a smart
1603120	1608000	constructor so that nobody can access the, the illegal states. And notice that we didn't make
1608080	1615040	tasty ratio any smaller by, by creating the, the, the smart constructor. But we can, we have an
1615040	1619280	illusion that tasty ratio is now a smaller value that doesn't have illegal states just because we
1619280	1624400	made it impossible to create them. So we can program as if the state space really is now smaller and
1624400	1629200	illegal states are unrepresentable. And again, it's very important to get the smart constructors
1629200	1634400	right. So it's a one-time effort, which is probably worth it because you just cover it in one space,
1635040	1640960	and then all of your flows can, can rely on the fact that the invariant, all the invariance you
1640960	1647760	want are actually enforced. So smart constructors are a great way to enforce diverse invariance
1647760	1652800	and with compiler assistance. So, assistance. So the moment you got it right from there on,
1652800	1657840	you know that the compiler won't let anyone bypass this invariant that you're trying to enforce.
1658880	1663040	And as a bonus, our type signatures are becoming, becoming kind of self-documenting because our
1663040	1667280	types are now representing actual invariance that we care directly, directly in our code. And it's
1667280	1671680	better than comments because they will never go out of date. The compiler is there to keep everything
1671680	1677440	in check. But we do have to be careful when defining smart constructors because, as I said,
1677440	1682480	you have to get that function right. And so unlike algebraic data types where you are kind of correct
1682480	1688240	by construction, smart, smart constructors are usually have to do some unsafe work to make
1688240	1693120	sure that everything else is safe. And so when possible, if you can represent something with
1693120	1698560	an algebraic data type, that's probably the preferred way. But when, when they work, smart
1698560	1708080	constructors are a great tool for excluding illegal states. So one, one last, last problem to
1708080	1715920	tackle with a robot. So brewing coffee is, again, no surprise, a complicated process as well.
1716480	1722080	And let's try to model a small part of brewing coffee. So here's one, one way to kind of
1722080	1726960	model this, this process. So we have this, this kind of imperative interface that you might,
1726960	1733520	you might expect for operating a robot with a bunch of kind of low-level commands that,
1733520	1737760	that can be used for, for the brewing stage. And assuming that someone actually implemented
1737760	1742800	this at the robot level, we can write the code for, for preparing for brewing, not the actual
1742880	1746960	brewing, but just the preparation. And so this looks pretty informative. We just call, call the
1746960	1755600	various actions in order. Anyone sees a bug here? So, disgustingly, we forgot to rinse the filter,
1755600	1760400	and now our users are going to drink this paper-tasting coffee, and, and probably we'll just
1760400	1766720	throw our, quit our robot and, and, and we will lose customers. So, so the reputation of the
1766800	1772400	robot depends on it, and we'll, we just messed up a good cup of coffee. But, but more seriously,
1773120	1778400	this, this code is very, very open to, to potential bugs, bugs that, that is illegal states.
1779360	1784240	So you can, you can forget action just like, just like I did right now with the filter answering.
1784240	1788320	You can mix up the order. You can, you can duplicate actions. Everything can happen here. It's,
1788320	1793600	it's full of possible legal states. And if it's, if it's possible, we're most likely to hit it at
1793600	1800640	some point. Maybe a refactoring gone, gone wrong or something, something else will can go wrong.
1800640	1806480	And the problem is here that even if, if we do, do mix something up, the compiler won't help us.
1806480	1811680	It doesn't know anything about it. So just compile fine and, and just be wrong. So again,
1811680	1815680	this is our desired state space. It's quite simple. It doesn't really have many, many things that,
1815680	1822400	that it has to do. But again, our actual code is open to various illegal state transitions that
1822400	1827920	we can, we can make that we would like to avoid and make them compile time and possible to actually
1827920	1835840	write down. So we can improve as well. So a big part of the problem here of the issue is that,
1835840	1840560	is the imperative interface. It's, it's, it just tells us the actions we, we want to perform.
1840560	1844640	It doesn't have any information, very little information about the intent of this action
1844640	1849920	and the consequences of it. So, so if, if we have a unit return time of something, it doesn't
1849920	1854480	really tell us much about what did we want to achieve or what actually happened. So, and so,
1854480	1859840	since so little is reflected in the types, it's, it's not, it's not a surprise that the compiler
1859840	1864080	can't really help us because the compiler works usually with types and that's, that's its way to
1864080	1868560	support us. And so the solution will be to become more declarative. So we're leaving the
1868560	1872880	imperative, imperative interface behind and, and trying to make it more declarative. So we start
1872880	1878000	by just adding, adding expectations. So what, what, what we aim to achieve on every action. So,
1878000	1883680	for example, the place filter function now, once invoked, will return a filter placed value,
1883680	1889200	which will correspond to the fact that the filter was indeed placed. And so on for all the other
1889200	1894400	functions. And we're not done yet. So we have another, we do have some various prerequisites. So
1894400	1899680	we, there's some ordering that, that has to go on here that, that is otherwise illegal. And so
1899680	1904640	we're going to define prerequisites as function arguments. So placing a filter cannot occur
1904720	1909760	unless the filter was folded before. So we make the explicit in our function by requiring an
1909760	1914080	argument that the filter was actually folded. And the same thing goes for rinsing the filter,
1914080	1918560	which can't happen unless the filter was placed and the water was heated. And the same thing for
1918560	1923120	grounds that you, if you want to add them, they must be actually ground. And the filter must be
1923120	1928880	rinsed to prevent the bug from, from before. And so basically what we were doing here is we're
1928880	1935360	encoding kind of business rules directly in our signatures. And once we do that, in turn, it
1935360	1944080	means that code that violates those rules won't even compile. It becomes literally unrepresentable.
1944080	1949360	And so we can now implement our prep flow from before. So instead of having our implementation
1949360	1954240	returning unit, we now have a more informative, more informative signature that tells us what
1954240	1958960	actually was achieved during that process. So after we finished the prep, water was heated
1958960	1964240	and grounds were actually added. So there's no avoiding that now. Every implementation of this
1964240	1972560	code has to, to do something about it. And so since our types are so, so descriptive, now again,
1972560	1977680	again, this ability to kind of follow the types to implement our flow. So this is very similar to
1977760	1985040	the code that we had before. But now we have to press around various outputs from our actions. So
1985040	1989360	this code is still incomplete. But the nice thing here is that the compiler now helps us. It tells
1989360	1996000	us, well, you forgot to make sure that you followed the filter before you placed it. And so we can
1996000	1999920	fix that. And now the compiler tells us, okay, but if you want to add grounds, you have to, you
1999920	2004320	have some prerequisites. So let's fix that. We have to have the coffee ground and the coffee
2004320	2009680	ground and filter placed. And now we still have the same bug from before. We still, we forgot to
2009680	2014480	rinse the filter. But this time, the compiler will tell us, you forgot to rinse the filter. So you
2014480	2020720	have to do that before you can actually add your grounds. And so we fix that. And now the compiler
2020720	2028080	is happy. And we are happy because our clients are happy. So because we shared our business rules,
2028160	2035680	business knowledge with the compiler, the compiler was very helpful in actually enforcing this
2035680	2045680	for us and making it impossible to stray from the right path. Also notice, so by making everything
2045680	2051040	more declarative, it's now much easier to figure out what flows where and what goes in which way.
2051040	2058640	And so in essence, our function dependencies are defining requirements and making the flow much
2058640	2063520	more limited in what can or can't happen. And so this, for example, opens up opportunities for
2063520	2067680	parallelization. So if you see that two functions are independent, you might be able to parallelize
2067680	2072560	them. And the nice thing here is that the compiler will help you get it right because it knows what
2072560	2079520	can or cannot be parallelized. But there is something that I didn't specify for the moment. And
2079520	2085200	what are those types? The water heated and grounds added types and all the rest I just used here.
2085920	2090560	So I just assumed that they are there, but I didn't actually specify them. And the answer is I don't
2090560	2096640	care. I literally don't care about those types. So much so that I can actually represent it in our
2096640	2102160	type signature. So brewing prep doesn't really depend on the specific values of all the types of
2102160	2106000	coffee ground, water heated, and the like. Why? Because it just passes them around. It doesn't
2106000	2110560	inspect them in any way. It just passes them around as kind of tokens of security, but it
2110560	2115680	doesn't do anything else with them. And to make this explicit, we made our brewing prep function
2115680	2122640	parametric. So now it takes six type arguments, although sounds scary. But since we don't care
2122640	2127680	about the actual values, we can do that. And everything will just work the same way as before.
2127680	2135280	So we explicitly declare the fact that we are invariant and don't care about how those types
2135280	2142320	are specified. Now, in order for this to work out, the brewing actions interface has to be
2142320	2147600	adapted as well. It has to be parametric in the same way. But because slide space is kind of
2147600	2152560	limited, I'll abbreviate for a moment. And so now brewing actions is going to take the same
2152560	2158880	six type parameters. And so now we are kind of consistently, the code looks exactly the same,
2158880	2164480	but now we have type parameters. You might ask, why would you do that? And the answer is if you
2164480	2168800	don't care about the inputs and outputs, if you make them parametric, it leaves you very little
2168800	2174000	space to actually cheat. So in case I want to pass the water-heated value and have to return it
2174000	2178960	for my signature, there's no way to obtain a water-heated value because from anywhere else,
2178960	2183440	other than calling heat to water, because I have no idea what the type really is. It's parametric,
2183440	2188880	so I have no information on how to obtain it. I don't know what it is, so it's just impossible.
2189440	2195440	And so in this case, we're just forced to do the right thing because there's no way to cheat. If
2195440	2200080	it was a unit or some other kind of simple value, we just could return that. But in this case,
2200080	2206320	we can't because it's type parameter. And as a nice bonus, this approach actually gives us,
2206320	2209120	although it limits the implementation, which is a good thing, it does give us
2209840	2215040	various flexibility degrees of freedom when creating brewing actions because the type
2215040	2219520	parameters can be set to whatever we actually want in brewing actions and still use unit, and
2219520	2224400	maybe we can use something more informative in tests. And so this gives us actual, the limitation
2224400	2229280	on this side actually gives us more flexibility in other places, which is a nice bonus, but
2229920	2236800	it's not directly related to what we're doing here. But the point is that the brewing prep
2236800	2242320	doesn't care about how those inputs work, and so we can limit it completely to using them correctly.
2243120	2248960	And so I will point out that this code doesn't prevent every legal state possible. So for example,
2248960	2254560	nothing stops us from calling fold filter twice. That might be, might be illegal. And in general,
2254560	2259440	it's not always possible to limit every possible, every possible illegal state, but it's better to
2259440	2268240	get something right than nothing. So I do think it's an improvement. So being declarative is a
2268240	2273040	great way to encode your business rules directly in your types. That way the compiler can help you
2273840	2279920	enforce those rules and making every breakage of the encoded rules impossible at compile time,
2279920	2284800	and thus it's unrepresentable. And the good first step when trying to do things more declaratively
2284800	2289280	is figure out where you have those redundant units that don't communicate any information
2289920	2295760	about what the function does, and then try to see how you can solve it. And by making everything
2295760	2301680	parametric, our code is becoming ignorant of the actual types that we use, which limits the
2301680	2306960	number of possible illegal states that we can enter. So the less the code can do, the more we
2306960	2320960	know about what it actually does. So ignorance is strength, like the famous quote. Okay, so we're
2320960	2326720	done with the various techniques. It might not be obvious from those two examples, like why would
2326720	2332560	that be useful? Because they're all small examples and kind of hard to see how they work out in a
2332560	2339520	large code base that you have to maintain for a long time. My point is that all of this kind of
2339520	2347040	adds up, and eventually it does make your code better in the long run, even if it's not obvious
2347120	2352560	from the first small steps. But in this section we'll just kind of quickly review what sort of
2352560	2358400	benefits you can expect to reap from being consistent and making illegal states as
2358400	2363680	unrepresentable as you can in your code base. So the first point is that code becomes easier to
2363680	2372480	comprehend. So as I just mentioned, the fewer things the code can do, the easier it is to
2372480	2377200	understand what it actually does. But more concretely, for example, if you use algebraic
2377200	2382160	data types consistently across your code base, the compiler can help you figure out what's
2382160	2386960	happening now. You do a better match. Some editors would actually autocomplete all the cases, and
2386960	2391120	you can now figure out what's going on, what information you have, what can you use and
2391120	2396560	the like, and the compiler got your back. Not only that, it can also, as I mentioned,
2396640	2402080	automatically do accessibility checking, so you're sure to not forget anything in case anything
2402080	2410160	changes. And so this is definitely an improvement on your ability to figure out what's going on.
2410160	2414640	And also a common theme throughout the examples is that our type signatures are becoming more
2414640	2418960	informative. They encode more and more information about what's going on. So just by reading the
2418960	2425600	signatures, it becomes easier to figure out what are the limitations, what is allowed, what is
2425600	2434000	disallowed, and the like. Fewer bugs. So every legal state that you precluded and made unrepresentable
2434000	2438640	is a potential bug that you avoided. So, for example, creating an Irish coffee order without
2438640	2443040	whiskey is no longer possible. It's not a state that you can write. This is a compilation error.
2444240	2448720	Nor this, like serving coffee and to an empty list of cups. Again, this is no longer possible
2448720	2453440	because you enforced it at compile time, and this is a bug again that cannot happen anymore.
2454400	2459040	And since they are unrepresentable, you don't have to test for them a lot. So this is our next
2459040	2464800	point, is that you can do fewer, if you make as many legal states unrepresentable as possible,
2464800	2470320	this leads to fewer tests that you actually have to write. For example, this test can't be
2470320	2477280	expressed. Again, testing whether Irish coffee order has whiskey is no longer relevant because,
2477280	2482800	again, even the test can't even compile. So that's a test that you don't have to write,
2482800	2486960	and some tests, for example, are still possible to write but maybe more redundant because you
2486960	2492560	don't really need, if your interface is sufficiently declarative, it might be kind of obvious on
2492560	2497680	its own that you don't have to check whether water was heated or not when you done the brewing
2497680	2504320	prep because the types are requiring that. And the last point is safer refactoring. So your
2504320	2509040	code becomes much easier to refactor. For example, this code, the get calls on the optional values
2509040	2515280	are only safe somewhat in the case that you're ordering Irish coffee. But imagine that you're
2515280	2519680	doing refactor and now the prepare Irish coffee call moves to another place. Now it's in some
2519680	2524240	other place and nothing is actually checking whether we're in the right case. So this is no
2524240	2530320	longer safe. On the other hand, this code with the pattern match is safe by construction. If you
2530320	2534640	try to move the call to prepare Irish coffee, the code will fail to compile because it will no
2534640	2542880	longer have the references to the right information that it needs. And another refactoring is if you
2542880	2547840	add something, for example, again, the compiler will verify that you matched all the various
2547840	2553440	types, all the various cases that you have and will enforce again that you don't forget anything.
2553440	2559680	Another example of refactoring is I mentioned in the previous section that we can paralyze
2559760	2566160	some actions here. So we can, for example, heat water, grind coffee, and the rest can be
2566160	2570160	paralyzed because they have no dependencies. So this is a refactoring that's easy to get wrong
2570160	2575680	because if you mess something up, things will run in parallel when they shouldn't. And in the
2575680	2580080	bad example, that would be just broken. But here we can write this code. And if we mess something
2580080	2584800	up, the compiler will tell us you're missing some dependencies. You can't run this in parallel.
2585120	2595600	So as people work and maintain large code bases, I think those benefits kind of add up and investment
2595600	2599600	that you're making on making legal states unrepresentable is definitely, definitely worth
2600480	2611120	the effort. So to conclude, almost done. So whenever you tackle a new domain, try to think
2611120	2617040	about the state space of your problem, the various states that the system can arrive at and what
2617040	2625280	can happen. Find the legal states in your system and define them to match your requirements or
2625280	2630400	whatever other error conditions that you might care about. And all the other states are illegal.
2630400	2636080	Now, if all you do is just think, just sit there and think about your state space in the legal
2636080	2639360	and illegal state, that's already a great first step. You don't have to do anything else.
2639360	2642960	That's already a good way of getting your code to be better just by knowing
2642960	2647440	what's possible and impossible. But if you actually want to reap the benefits from this
2647440	2653200	talk, make those states unrepresentable. And the benefits are fewer bugs, fewer tests,
2653200	2659440	easier to comprehend code. And you don't have to worry anymore about states that are illegal
2659440	2663040	because you made them unrepresentable. So you don't have to think about them anymore. That's
2663040	2667360	a great thing to do. When you don't have to think about something, you can think about something
2667360	2674560	else, which might be useful. And so we saw a number of techniques to achieve this goal.
2674560	2679280	So algebraic data types help us reduce the state space into something smaller and more
2679280	2684880	manageable. Smart constructors let us enforce various invariants and declarative signatures
2684880	2690160	make various business rules kind of apparent in our code. And parametric polyphysm is like a nice
2690160	2696480	cherry on top if you want to really kind of go at it even more limited. So there's a slide about
2696480	2701440	where to go next. So I covered some very basic techniques. There are other approaches that
2701440	2708000	you can take, which probably have a steeper cost-benefit ratio. So it might be not worth it.
2708000	2713360	But these are some ideas of what you can think of, especially various type systems. So a lot of the
2713360	2718800	things we've done are kind of bound by the type system that we're using. And so maybe trying
2718800	2726080	other more advanced type systems or type system features can help you make things easier.
2726480	2731280	If you're taking a photo, you can do that. I'll post the link to the slide so everything is there.
2731280	2737120	And there's some inspiration for various resources that I think are kind of useful in thinking about
2737120	2744000	problems. And again, I'll post the link for the presentation. All the links will be available.
2744000	2750400	So it's my time to wrap up. So remember our poor little user that was trying to register and didn't
2750480	2757200	have an email. So somewhere someone is trying to introduce another bug in our system. But luckily
2757200	2764240	we applied all the techniques that we studied right now. And it no longer compiles. The illegal
2764240	2771680	states is unrepresentable. The compiler tells us that and we can sleep quietly tonight. So hopefully
2771680	2778400	I managed to convince you that making illegal states unrepresentable is actually worth the effort.
2778400	2783520	And this is linked to the presentation. And if I have time for questions, I'm not sure.
2784240	2787840	Yes, we can try to take one online question first, maybe.
2792800	2797280	Can you please read it out for our audience? I guess you're in favor of using something like
2797280	2802080	refined to express even more constraints in types instead of custom smart constructors. Yes,
2802480	2811760	the one of the last slides, I used refined as there's a link to the refined library here in
2811760	2817360	the end. So yes, refined is a nice library that can help you automate the process of creating
2817360	2822240	smart constructors. Instead of writing them manually by hand, you can use a library that
2822240	2827600	helps with that. All right. Thank you. We have also one question here on site.
2828320	2835680	Hi. So thanks for the great talk. In the example about algebraic data types.
2841520	2848000	It was the example of ordering different types of coffee. But what happens if the coffee shop
2848000	2854400	owners have a business requirement that at any point of time, she wants to be able to add a
2854400	2859280	new type of the coffee? So what happens to our algebraic data types with such a requirement?
2859280	2865360	So there's often kind of people debating whether types are useful or not, or kind of this conception
2865360	2870320	that you have to go all in or nothing. So either you specify everything and everything is fixed
2870320	2875760	in types or not. This is not the case. If you want some flexibility, you can live that measure
2875760	2880960	of flexibility as your requirements desire. So in the case of maybe having another case which is
2881040	2885200	more dynamically defined, maybe have another case which is dynamic. And then you'll be extra
2885200	2890480	careful around that case. But still, you now have a small island of sanity where you know what's
2890480	2895360	going on and another section of the code which is not as pleasant and safe. But still, you can
2895360	2900080	separate the parts. What you know, you can encode. What you don't, leave it as an unknown and handle
2900080	2905840	it appropriately. Okay. Thank you. We have one more online question. If you could again, please read
2905920	2913680	it out. So only recently I started learning Haskell and Idris from the perspective of making
2913680	2917600	illegal states not representable. It seems to me that type-driven development
2917600	2924320	advocated by Idris is more suitable. Then again, I'm a beginner. So yes, Haskell and Idris both
2924320	2931600	have various advanced type-level features and things you can do that make it possible to exclude
2931680	2937760	even more illegal states. And as I mentioned, using more advanced type systems is a good way
2938640	2944960	to enforce more invariance. But the question is kind of the cost, whether it's worth it,
2944960	2949840	especially as a beginner, because if you play something very, very kind of a heavy tool that
2949840	2954720	does something very sophisticated, it might be more difficult to maintain. So I think you
2954720	2959440	should kind of gradually ramp up there and eventually maybe use it, but have a good way
2959440	2963360	to judge whether it's worth it or not. So start simple and then gradually improve.
2964160	2968160	All the things I did mention now are available in both Haskell and Idris. So that's not
2968160	2973200	actually a problem. And you can start there and move on to something more advanced. Okay. We
2973200	2980880	have time for one last onsite question here. Thanks for a great talk. I'm wondering if any
2980880	2985360	of the techniques that you mentioned are applicable in dynamically checked languages?
2985360	2992720	And if you have an experience in doing so, maybe? So in dynamically typed languages, everything's
2992720	2997360	applicable. You can write anything. The question is whether who enforces things for you. So in
2997360	3002480	a statically typed language, the compiler is much more your friend than people usually think.
3003600	3007360	And then in dynamically typed language, first of all, just thinking about the state space,
3007360	3010720	you can do it in any language on a piece of paper. It doesn't really matter. And it's already an
3010720	3016640	improvement. And then if you are explicit about what's illegal, at least you can force your
3016640	3022160	invariance even in a dynamic context. For example, your smart constructor won't return an optional
3022160	3027680	value, but will throw an exception. But at least you limited the scope of where things can go
3027680	3032560	wrong, for example. And pattern matching is available in various languages. Although there are no,
3032560	3037760	the guarantees might be somewhat looser, but still it's better than nothing. So those approaches
3037760	3043440	can help you, but they won't gain you as much benefit as they are in a statically typed language,
3043440	3053680	I think. All right. Thank you very much, Daniel. Please help me thank him.
