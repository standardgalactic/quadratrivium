{"text": " Learning a new programming language is hard. There's so much syntax to learn and even then you have to understand how the language computes to go from this syntax to a meaningful program. But what if I told you that there is a language that can do absolutely anything any other programming language can and will ever do until the end of time, that consists of only three pieces of syntax and a singular rule of computation. Introducing the Lambda Calculus The Lambda Calculus is, at its core, a theory of functions. Why functions? I don't mean complicated blocks of code. Rather, a mapping of inputs to outputs. For example, we could have a function that maps a number to its square, so the function maps the input 2 to the output 4 and so on. Writing the mapping from every possible input to its output is tedious at best, so let's abstract away the specific inputs and just say that for some arbitrary input x, we map it to x squared. We call x a variable. We could have used any symbol in place of x. Mapping y to y squared or star to star squared doesn't change which inputs are mapped to which outputs. As some fancy terminology, we say that these functions are alpha equivalent and the process of renaming the input variable and all instances of that variable in the function to a different variable is called alpha conversion. To avoid having to use arrows to denote functions, let's introduce some new notation. For a function that maps an arbitrary input x to the output m, we'll write it as follows. We'll first write a Greek letter lambda to indicate that we're writing a function. There's really nothing special about this letter, it's simply a visual marker that we're defining a function. Then we'll write the input variable. In this case x next to the lambda. We'll then write a dot and finally m, the output of our function. The dot is simply there to separate the input from the output. We often call functions written like this lambda abstractions. Okay, so now we have a concise notation to write functions, but on their own they don't exactly do very much. That's where function application comes in. Let's suppose I have the function that maps the input x to the output x plus one. If Alice wanted to find what a specific number, say three, is mapped to, we can substitute in three for our input variable. So we would replace any x's we see in the output with a three, giving us three plus one or four. We call this process of substituting a term for the input variable of a function, beta reduction, and we write this as an arrow with a little beta next to it to show that a reduction has taken place. In general, if we have a lambda abstraction, lambda x dot m, apply to an input n, denoted by writing the input on the right of our function. We can perform a beta reduction by going through m and substituting our input n for the variable x. We'll shorten this by writing a slash to mean substituted for. So we've now understood variables, lambda abstractions, and applications of functions via beta reduction. This looks very much like a start to an extremely primitive programming language. To finish it off, we would just need to add support for multiple inputs, loops, booleans, some data structures, a few more rules of computation. As it turns out, we actually don't need anything more. If we only allow the programmer to write variables, lambda abstractions, and applications, and simply compute these terms using beta reduction, we can make anything that a computer will ever do, ever. This amazing result was documented in the Church-Turing thesis. Two names we'll come across later on. We call this tiny programming language the lambda calculus. This result seems impossible, but the key to seeing how this is achieved is by noticing that our functions here are higher order. This means that functions can be passed as inputs to other functions, and equally functions can return functions as an output. This small subtlety is what gives the lambda calculus its punch, which I'll demonstrate by replicating a standard feature of more complicated programming languages in the lambda calculus. You might have noticed that lambda abstractions only have a singular input variable, which seems rather limiting. What if Bob wants to make a function that, say, takes two numbers as inputs, and then outputs their sum? He can actually achieve this with a little trick. Consider the function that takes an input x and returns another function. This outputted function takes an input y and outputs x plus y. Okay, that's a little confusing, but let's see what happens when we apply this function to an input, say 1. Replacing all x's with 1's gives the function lambda y dot 1 plus y. That is, a function that takes an input and returns 1 plus that input. So if we apply this function to the number 2, we replace the occurrence of y in our lambda abstraction with 2, and we get 1 plus 2, or 3. We've effectively given this function one input after another, and it has returned their sum. To generalise this, the arbitrary lambda abstraction lambda x dot lambda y dot l can be applied to two inputs, m and n. By first beta reducing with the first input m to the function lambda y dot l with m substituted for x, which is yet to be applied to the input n. We can then perform a second beta reduction with the input n, to finally get the term l with m substituted for x and n substituted for y. So our output is a term with a substitution for x and a substitution for y, exactly as we'd expect from a function that takes two inputs. This method of functions returning functions to sequentially apply to multiple inputs is called currying, named after the logician Haskell-curry. If you have experienced programming, why not try to make some curried functions yourself? This Python program here, for example, uses the built-in lambda syntax to add two numbers together using currying. This way of thinking can take a while to get used to, but hopefully I'm starting to convince you that the higher-order lambda abstractions have more nuance than you might have expected. To continue building the primitive calculus into a more practical programming language, we can encode some more common programming concepts into the calculus. As a quick example, to use Booleans and conditionals, we can represent true as the term lambda x dot lambda y dot x, the function that takes two inputs and returns the first, and represent false as the term lambda x dot lambda y dot y, the function that takes two inputs and returns the second. This seems completely arbitrary, but look what happens when we encode an if statement as lambda b dot lambda x dot lambda y dot b apply to x and then y. This lambda abstraction just takes three inputs, b, x and y, and outputs the result of applying b to the inputs x and y. This looks pretty random, but if we input a Boolean as the first argument, and then any two terms as the inputs x and y, this function will behave just like an if statement. It will return the first term if the Boolean is true, and the second if it's not. In Python, this lambda abstraction would be the program if b then return x, else return y. Let's test that out. Applying our if statement to the inputs true m, n, where m and n are some terms in the lambda calculus, should return m. Let's plug true in for b first, giving lambda x dot lambda y dot true x, y, apply to m, then n. Plugging in m for x gives lambda y dot true m, y, apply to n. Then finally substituting n for y gives true m, n. Now we can turn the term true back into its definition in the lambda calculus, the function that takes two arguments and returns the first. So let's first substitute m for x, giving lambda y dot m, apply to n. Finally substituting n for y just returns m, since there aren't any y's in this lambda abstraction at all. So after all that, we've ended up with our if statement with the Boolean input true, and the inputted terms m and n, outputting the first term m, exactly as we expected it to do. Try plugging in false to our if statement, and verify that it returns n this time. You may be starting to feel slightly short change. The introduction to this video suggested that the lambda calculus would be the solution to the problem of complicated programming languages. However, as you saw from the tedious method by which we encode relatively standard features into the calculus, the lambda calculus is certainly not suited for any real world programming. So what was the point in all of this? Well, for starters, once we've tediously encoded concepts into the calculus, we can actually just ignore the low level implementation, and just deal with the objects themselves. For example, we now know that Booleans in conditionals can be simulated, so we can just deal with Boolean terms and if statements without worrying about unfolding their definitions. This makes programming in the lambda calculus somewhat reasonable. As an example, we can write the not function as lambda b dot if b then false, else true. And of this absolute mess if we unfold all of the definitions. Given that we can also encode numbers, recursion, and data types like pairs, I hope you can start to see the power of this miniature programming language. I implore you to study how these concepts can be encoded, but instead, I'd really like to focus on the implications of our newfound mathematical programming language. We set out trying to find a simple and easy programming language that we can learn instead of more verbose and intricate languages. But instead, we've stumbled across something far more profound. The lambda calculus gives us a tiny definition of what it means to compute, and because of this, allows us to study programming and computation mathematically. My favourite example of this is introducing a simple type system to the lambda calculus. As some motivation, consider our not function from earlier. Lambda b dot if b then false, else true. This function maps the input true to the output false, and the input false to the output true, essentially just swapping true and false. But there is a slight subtlety here. There is no actual requirement for our input to be a boolean. Our not function apply to an input of, say, 1, beta reduces to if 1 then false, else true. This is nonsensical. If 1 makes no sense because 1 isn't a boolean. So trying to use our encodings of these concepts to reduce this further will result in a term with no real meaning. To avoid this, we can add some rules to our lambda calculus. We'll assign a label, called a type, to terms in the lambda calculus that make sense, which in our case is going to be built from the types bool for boolean values and num for numeric values. We'll indicate the type of a term by writing the type after a colon. So we'd write true colon bool to say that true is of type boolean. Lambda abstractions have the type a arrow b, normally said as type a to b, where a is the type of its input, and b is the type of its output. We'll specify the type of the input by putting it next to the input variable when writing lambda abstractions. So to finally solve our problem of nonsense terms, we'll now say that we can only apply a lambda abstraction to a term that has the same type as the one specified by its input variable. As an example, we'd now write our not function like this, specifying that our input b is a boolean. Since this abstraction takes a boolean and then outputs a boolean, it will have type bool to boole. This means that we are simply not allowed to apply this function to the term one, as this has type num and not boole. Whilst this does limit what the calculus can do, it does stop a lot of nonsense terms from arising. The version of lambda calculus with this typing system attached to it is called the simply typed lambda calculus, and is very reminiscent of statically typed languages like C or Java. But despite this similarity, the lambda calculus and its simply typed version was invented by Alonso Church between the 1930s and 40s, before programming and even computer science itself was being formally studied. As a side note, Alonso Church was actually the doctoral advisor of the father of computer science, Alon Turing, whose achievements have rightly earned him the status of a household name. Whilst the lambda calculus has played a pivotal role in the study of programming, it has been equally as important in the field of mathematical logic, as we can define systems of logic using the calculus. In fact, our simply typed lambda calculus has a particularly interesting interpretation in terms of logic. Let's say that the types in our calculus should be interpreted as propositions, that being statements which are either true or false. Then we'll say that each term in the lambda calculus should be seen as a proof that the proposition corresponding to that term's type is true. As an example, suppose we have an arbitrary type A. We can interpret this as corresponding to a particular proposition. Then we'll think of a term of type A as a proof that A is true. If no such term exists, then A is false. This seems rather strange, but bear with me. If we use this interpretation of our simply typed lambda calculus, then we find that the type of lambda abstractions, that being A to B for some arbitrary types A and B, corresponds to the proposition A implies B. The proposition A implies B is simply stating that if I can prove A is true, then I know that B must be true as well. For example, if A was the proposition that it's raining, and B was the proposition that the ground is wet, then the proposition A implies B would be, if it is raining, then the ground is wet. If we assume that this implication is true, then if I could prove that it was raining, I would also know that the ground is wet. So how does this play out in our calculus? Let's take two types, A and B, then the proposition A implies B is equivalent to the type A to B. Let's suppose that A was true, that is, there exists some term N of type A. If we also suppose that A implies B was true, then there must exist some term of type A to B. This must be a lambda abstraction of the form lambda x dot m, where the input x is of type A and the output m is of type B. Now, A implies B is true, and we know that A is true, so we know that logically, B must be true as well. We'll separate the propositions we're assuming to be true, and the logical conclusions to these assumptions with a line. For our correspondence to work, then, we need to be able to use this lambda abstraction and our term N to create a term of type B. The key here is noticing that we can apply our lambda abstraction to N, because N is of type A. Crucially, we know that this has type B as the lambda abstraction outputs terms of type B. As we can find a term of type B, we know that the proposition corresponding to B is true, just as we expected it to be. This astounding relationship between propositions and types is called the Curry-Howard correspondence and has some fascinating implications. If we build a programming language with this in mind, we can actually use this correspondence to explicitly write mathematical proofs using computer code. These languages are called proof assistants, and popular ones include Lean and Agda. This Lean program here, for example, is a proof that there are infinitely many prime numbers and we know that it's correct since it type checks. As this area of research develops, who knows, in the future mathematics might not be taught with pen and paper, but rather with a keyboard and mouse. Well, that was quite the journey. We started out by exploring the essence of functions, and whilst it certainly isn't a serious contender for modern programming languages, it has allowed us to explore a rich theory of theoretical computer science and mathematical logic, whilst giving us the ability to reason about computer programs and code rigorously. Who knew that a tiny little system of formal logic would have so many implications even a century after its creation. If this topic interests you, I would encourage you to subscribe, leave a like, and browse other videos on this channel for similar explorations of mathematics and theoretical computer science. But until then, goodbye.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 10.44, "text": " Learning a new programming language is hard. There's so much syntax to learn and even", "tokens": [50364, 15205, 257, 777, 9410, 2856, 307, 1152, 13, 821, 311, 370, 709, 28431, 281, 1466, 293, 754, 50886], "temperature": 0.0, "avg_logprob": -0.19698436443622297, "compression_ratio": 1.5649717514124293, "no_speech_prob": 0.06644754111766815}, {"id": 1, "seek": 0, "start": 10.44, "end": 15.280000000000001, "text": " then you have to understand how the language computes to go from this syntax to a meaningful", "tokens": [50886, 550, 291, 362, 281, 1223, 577, 264, 2856, 715, 1819, 281, 352, 490, 341, 28431, 281, 257, 10995, 51128], "temperature": 0.0, "avg_logprob": -0.19698436443622297, "compression_ratio": 1.5649717514124293, "no_speech_prob": 0.06644754111766815}, {"id": 2, "seek": 0, "start": 15.280000000000001, "end": 16.28, "text": " program.", "tokens": [51128, 1461, 13, 51178], "temperature": 0.0, "avg_logprob": -0.19698436443622297, "compression_ratio": 1.5649717514124293, "no_speech_prob": 0.06644754111766815}, {"id": 3, "seek": 0, "start": 16.28, "end": 26.52, "text": " But what if I told you that there is a language that can do absolutely anything any other", "tokens": [51178, 583, 437, 498, 286, 1907, 291, 300, 456, 307, 257, 2856, 300, 393, 360, 3122, 1340, 604, 661, 51690], "temperature": 0.0, "avg_logprob": -0.19698436443622297, "compression_ratio": 1.5649717514124293, "no_speech_prob": 0.06644754111766815}, {"id": 4, "seek": 2652, "start": 26.52, "end": 31.759999999999998, "text": " programming language can and will ever do until the end of time, that consists of only", "tokens": [50364, 9410, 2856, 393, 293, 486, 1562, 360, 1826, 264, 917, 295, 565, 11, 300, 14689, 295, 787, 50626], "temperature": 0.0, "avg_logprob": -0.2507315596489057, "compression_ratio": 1.5181347150259068, "no_speech_prob": 0.018822994083166122}, {"id": 5, "seek": 2652, "start": 31.759999999999998, "end": 37.96, "text": " three pieces of syntax and a singular rule of computation.", "tokens": [50626, 1045, 3755, 295, 28431, 293, 257, 20010, 4978, 295, 24903, 13, 50936], "temperature": 0.0, "avg_logprob": -0.2507315596489057, "compression_ratio": 1.5181347150259068, "no_speech_prob": 0.018822994083166122}, {"id": 6, "seek": 2652, "start": 37.96, "end": 42.92, "text": " Introducing the Lambda Calculus", "tokens": [50936, 27193, 2175, 264, 45691, 3511, 36002, 51184], "temperature": 0.0, "avg_logprob": -0.2507315596489057, "compression_ratio": 1.5181347150259068, "no_speech_prob": 0.018822994083166122}, {"id": 7, "seek": 2652, "start": 42.92, "end": 46.760000000000005, "text": " The Lambda Calculus is, at its core, a theory of functions.", "tokens": [51184, 440, 45691, 3511, 36002, 307, 11, 412, 1080, 4965, 11, 257, 5261, 295, 6828, 13, 51376], "temperature": 0.0, "avg_logprob": -0.2507315596489057, "compression_ratio": 1.5181347150259068, "no_speech_prob": 0.018822994083166122}, {"id": 8, "seek": 2652, "start": 46.760000000000005, "end": 54.84, "text": " Why functions? I don't mean complicated blocks of code.", "tokens": [51376, 1545, 6828, 30, 286, 500, 380, 914, 6179, 8474, 295, 3089, 13, 51780], "temperature": 0.0, "avg_logprob": -0.2507315596489057, "compression_ratio": 1.5181347150259068, "no_speech_prob": 0.018822994083166122}, {"id": 9, "seek": 5484, "start": 55.56, "end": 60.32000000000001, "text": " Rather, a mapping of inputs to outputs.", "tokens": [50400, 16571, 11, 257, 18350, 295, 15743, 281, 23930, 13, 50638], "temperature": 0.0, "avg_logprob": -0.15870937387993994, "compression_ratio": 1.6470588235294117, "no_speech_prob": 0.008839882910251617}, {"id": 10, "seek": 5484, "start": 60.32000000000001, "end": 64.80000000000001, "text": " For example, we could have a function that maps a number to its square, so the function", "tokens": [50638, 1171, 1365, 11, 321, 727, 362, 257, 2445, 300, 11317, 257, 1230, 281, 1080, 3732, 11, 370, 264, 2445, 50862], "temperature": 0.0, "avg_logprob": -0.15870937387993994, "compression_ratio": 1.6470588235294117, "no_speech_prob": 0.008839882910251617}, {"id": 11, "seek": 5484, "start": 64.80000000000001, "end": 69.88000000000001, "text": " maps the input 2 to the output 4 and so on.", "tokens": [50862, 11317, 264, 4846, 568, 281, 264, 5598, 1017, 293, 370, 322, 13, 51116], "temperature": 0.0, "avg_logprob": -0.15870937387993994, "compression_ratio": 1.6470588235294117, "no_speech_prob": 0.008839882910251617}, {"id": 12, "seek": 5484, "start": 69.88000000000001, "end": 74.52000000000001, "text": " Writing the mapping from every possible input to its output is tedious at best, so let's", "tokens": [51116, 32774, 264, 18350, 490, 633, 1944, 4846, 281, 1080, 5598, 307, 38284, 412, 1151, 11, 370, 718, 311, 51348], "temperature": 0.0, "avg_logprob": -0.15870937387993994, "compression_ratio": 1.6470588235294117, "no_speech_prob": 0.008839882910251617}, {"id": 13, "seek": 5484, "start": 74.52000000000001, "end": 79.96000000000001, "text": " abstract away the specific inputs and just say that for some arbitrary input x, we map", "tokens": [51348, 12649, 1314, 264, 2685, 15743, 293, 445, 584, 300, 337, 512, 23211, 4846, 2031, 11, 321, 4471, 51620], "temperature": 0.0, "avg_logprob": -0.15870937387993994, "compression_ratio": 1.6470588235294117, "no_speech_prob": 0.008839882910251617}, {"id": 14, "seek": 5484, "start": 79.96000000000001, "end": 82.76, "text": " it to x squared.", "tokens": [51620, 309, 281, 2031, 8889, 13, 51760], "temperature": 0.0, "avg_logprob": -0.15870937387993994, "compression_ratio": 1.6470588235294117, "no_speech_prob": 0.008839882910251617}, {"id": 15, "seek": 8276, "start": 82.76, "end": 85.44000000000001, "text": " We call x a variable.", "tokens": [50364, 492, 818, 2031, 257, 7006, 13, 50498], "temperature": 0.0, "avg_logprob": -0.10045445090846011, "compression_ratio": 1.6851063829787234, "no_speech_prob": 0.00017399895295966417}, {"id": 16, "seek": 8276, "start": 85.44000000000001, "end": 88.28, "text": " We could have used any symbol in place of x.", "tokens": [50498, 492, 727, 362, 1143, 604, 5986, 294, 1081, 295, 2031, 13, 50640], "temperature": 0.0, "avg_logprob": -0.10045445090846011, "compression_ratio": 1.6851063829787234, "no_speech_prob": 0.00017399895295966417}, {"id": 17, "seek": 8276, "start": 88.28, "end": 93.92, "text": " Mapping y to y squared or star to star squared doesn't change which inputs are mapped to", "tokens": [50640, 376, 10534, 288, 281, 288, 8889, 420, 3543, 281, 3543, 8889, 1177, 380, 1319, 597, 15743, 366, 33318, 281, 50922], "temperature": 0.0, "avg_logprob": -0.10045445090846011, "compression_ratio": 1.6851063829787234, "no_speech_prob": 0.00017399895295966417}, {"id": 18, "seek": 8276, "start": 93.92, "end": 96.04, "text": " which outputs.", "tokens": [50922, 597, 23930, 13, 51028], "temperature": 0.0, "avg_logprob": -0.10045445090846011, "compression_ratio": 1.6851063829787234, "no_speech_prob": 0.00017399895295966417}, {"id": 19, "seek": 8276, "start": 96.04, "end": 101.24000000000001, "text": " As some fancy terminology, we say that these functions are alpha equivalent and the process", "tokens": [51028, 1018, 512, 10247, 27575, 11, 321, 584, 300, 613, 6828, 366, 8961, 10344, 293, 264, 1399, 51288], "temperature": 0.0, "avg_logprob": -0.10045445090846011, "compression_ratio": 1.6851063829787234, "no_speech_prob": 0.00017399895295966417}, {"id": 20, "seek": 8276, "start": 101.24000000000001, "end": 106.44, "text": " of renaming the input variable and all instances of that variable in the function to a different", "tokens": [51288, 295, 8124, 5184, 264, 4846, 7006, 293, 439, 14519, 295, 300, 7006, 294, 264, 2445, 281, 257, 819, 51548], "temperature": 0.0, "avg_logprob": -0.10045445090846011, "compression_ratio": 1.6851063829787234, "no_speech_prob": 0.00017399895295966417}, {"id": 21, "seek": 8276, "start": 106.44, "end": 111.24000000000001, "text": " variable is called alpha conversion.", "tokens": [51548, 7006, 307, 1219, 8961, 14298, 13, 51788], "temperature": 0.0, "avg_logprob": -0.10045445090846011, "compression_ratio": 1.6851063829787234, "no_speech_prob": 0.00017399895295966417}, {"id": 22, "seek": 11124, "start": 111.24, "end": 118.36, "text": " To avoid having to use arrows to denote functions, let's introduce some new notation.", "tokens": [50364, 1407, 5042, 1419, 281, 764, 19669, 281, 45708, 6828, 11, 718, 311, 5366, 512, 777, 24657, 13, 50720], "temperature": 0.0, "avg_logprob": -0.13836786482069227, "compression_ratio": 1.7161016949152543, "no_speech_prob": 2.178233626182191e-05}, {"id": 23, "seek": 11124, "start": 118.36, "end": 125.91999999999999, "text": " For a function that maps an arbitrary input x to the output m, we'll write it as follows.", "tokens": [50720, 1171, 257, 2445, 300, 11317, 364, 23211, 4846, 2031, 281, 264, 5598, 275, 11, 321, 603, 2464, 309, 382, 10002, 13, 51098], "temperature": 0.0, "avg_logprob": -0.13836786482069227, "compression_ratio": 1.7161016949152543, "no_speech_prob": 2.178233626182191e-05}, {"id": 24, "seek": 11124, "start": 125.91999999999999, "end": 130.35999999999999, "text": " We'll first write a Greek letter lambda to indicate that we're writing a function.", "tokens": [51098, 492, 603, 700, 2464, 257, 10281, 5063, 13607, 281, 13330, 300, 321, 434, 3579, 257, 2445, 13, 51320], "temperature": 0.0, "avg_logprob": -0.13836786482069227, "compression_ratio": 1.7161016949152543, "no_speech_prob": 2.178233626182191e-05}, {"id": 25, "seek": 11124, "start": 130.35999999999999, "end": 135.16, "text": " There's really nothing special about this letter, it's simply a visual marker that", "tokens": [51320, 821, 311, 534, 1825, 2121, 466, 341, 5063, 11, 309, 311, 2935, 257, 5056, 15247, 300, 51560], "temperature": 0.0, "avg_logprob": -0.13836786482069227, "compression_ratio": 1.7161016949152543, "no_speech_prob": 2.178233626182191e-05}, {"id": 26, "seek": 11124, "start": 135.16, "end": 137.76, "text": " we're defining a function.", "tokens": [51560, 321, 434, 17827, 257, 2445, 13, 51690], "temperature": 0.0, "avg_logprob": -0.13836786482069227, "compression_ratio": 1.7161016949152543, "no_speech_prob": 2.178233626182191e-05}, {"id": 27, "seek": 11124, "start": 137.76, "end": 140.0, "text": " Then we'll write the input variable.", "tokens": [51690, 1396, 321, 603, 2464, 264, 4846, 7006, 13, 51802], "temperature": 0.0, "avg_logprob": -0.13836786482069227, "compression_ratio": 1.7161016949152543, "no_speech_prob": 2.178233626182191e-05}, {"id": 28, "seek": 14000, "start": 140.0, "end": 143.84, "text": " In this case x next to the lambda.", "tokens": [50364, 682, 341, 1389, 2031, 958, 281, 264, 13607, 13, 50556], "temperature": 0.0, "avg_logprob": -0.1582009575583718, "compression_ratio": 1.6390243902439023, "no_speech_prob": 0.0003682920942083001}, {"id": 29, "seek": 14000, "start": 143.84, "end": 149.12, "text": " We'll then write a dot and finally m, the output of our function.", "tokens": [50556, 492, 603, 550, 2464, 257, 5893, 293, 2721, 275, 11, 264, 5598, 295, 527, 2445, 13, 50820], "temperature": 0.0, "avg_logprob": -0.1582009575583718, "compression_ratio": 1.6390243902439023, "no_speech_prob": 0.0003682920942083001}, {"id": 30, "seek": 14000, "start": 149.12, "end": 154.16, "text": " The dot is simply there to separate the input from the output.", "tokens": [50820, 440, 5893, 307, 2935, 456, 281, 4994, 264, 4846, 490, 264, 5598, 13, 51072], "temperature": 0.0, "avg_logprob": -0.1582009575583718, "compression_ratio": 1.6390243902439023, "no_speech_prob": 0.0003682920942083001}, {"id": 31, "seek": 14000, "start": 154.16, "end": 158.92000000000002, "text": " We often call functions written like this lambda abstractions.", "tokens": [51072, 492, 2049, 818, 6828, 3720, 411, 341, 13607, 12649, 626, 13, 51310], "temperature": 0.0, "avg_logprob": -0.1582009575583718, "compression_ratio": 1.6390243902439023, "no_speech_prob": 0.0003682920942083001}, {"id": 32, "seek": 14000, "start": 158.92000000000002, "end": 165.64, "text": " Okay, so now we have a concise notation to write functions, but on their own they don't", "tokens": [51310, 1033, 11, 370, 586, 321, 362, 257, 44882, 24657, 281, 2464, 6828, 11, 457, 322, 641, 1065, 436, 500, 380, 51646], "temperature": 0.0, "avg_logprob": -0.1582009575583718, "compression_ratio": 1.6390243902439023, "no_speech_prob": 0.0003682920942083001}, {"id": 33, "seek": 14000, "start": 165.64, "end": 169.6, "text": " exactly do very much.", "tokens": [51646, 2293, 360, 588, 709, 13, 51844], "temperature": 0.0, "avg_logprob": -0.1582009575583718, "compression_ratio": 1.6390243902439023, "no_speech_prob": 0.0003682920942083001}, {"id": 34, "seek": 16960, "start": 169.6, "end": 172.32, "text": " That's where function application comes in.", "tokens": [50364, 663, 311, 689, 2445, 3861, 1487, 294, 13, 50500], "temperature": 0.0, "avg_logprob": -0.13169852547023608, "compression_ratio": 1.6093023255813954, "no_speech_prob": 0.0014549866318702698}, {"id": 35, "seek": 16960, "start": 172.32, "end": 179.51999999999998, "text": " Let's suppose I have the function that maps the input x to the output x plus one.", "tokens": [50500, 961, 311, 7297, 286, 362, 264, 2445, 300, 11317, 264, 4846, 2031, 281, 264, 5598, 2031, 1804, 472, 13, 50860], "temperature": 0.0, "avg_logprob": -0.13169852547023608, "compression_ratio": 1.6093023255813954, "no_speech_prob": 0.0014549866318702698}, {"id": 36, "seek": 16960, "start": 179.51999999999998, "end": 185.62, "text": " If Alice wanted to find what a specific number, say three, is mapped to, we can substitute", "tokens": [50860, 759, 16004, 1415, 281, 915, 437, 257, 2685, 1230, 11, 584, 1045, 11, 307, 33318, 281, 11, 321, 393, 15802, 51165], "temperature": 0.0, "avg_logprob": -0.13169852547023608, "compression_ratio": 1.6093023255813954, "no_speech_prob": 0.0014549866318702698}, {"id": 37, "seek": 16960, "start": 185.62, "end": 188.78, "text": " in three for our input variable.", "tokens": [51165, 294, 1045, 337, 527, 4846, 7006, 13, 51323], "temperature": 0.0, "avg_logprob": -0.13169852547023608, "compression_ratio": 1.6093023255813954, "no_speech_prob": 0.0014549866318702698}, {"id": 38, "seek": 16960, "start": 188.78, "end": 194.07999999999998, "text": " So we would replace any x's we see in the output with a three, giving us three plus", "tokens": [51323, 407, 321, 576, 7406, 604, 2031, 311, 321, 536, 294, 264, 5598, 365, 257, 1045, 11, 2902, 505, 1045, 1804, 51588], "temperature": 0.0, "avg_logprob": -0.13169852547023608, "compression_ratio": 1.6093023255813954, "no_speech_prob": 0.0014549866318702698}, {"id": 39, "seek": 16960, "start": 194.07999999999998, "end": 196.68, "text": " one or four.", "tokens": [51588, 472, 420, 1451, 13, 51718], "temperature": 0.0, "avg_logprob": -0.13169852547023608, "compression_ratio": 1.6093023255813954, "no_speech_prob": 0.0014549866318702698}, {"id": 40, "seek": 19668, "start": 196.68, "end": 201.42000000000002, "text": " We call this process of substituting a term for the input variable of a function, beta", "tokens": [50364, 492, 818, 341, 1399, 295, 26441, 10861, 257, 1433, 337, 264, 4846, 7006, 295, 257, 2445, 11, 9861, 50601], "temperature": 0.0, "avg_logprob": -0.10846806439486417, "compression_ratio": 1.8132780082987552, "no_speech_prob": 6.204940291354433e-05}, {"id": 41, "seek": 19668, "start": 201.42000000000002, "end": 206.82, "text": " reduction, and we write this as an arrow with a little beta next to it to show that a reduction", "tokens": [50601, 11004, 11, 293, 321, 2464, 341, 382, 364, 11610, 365, 257, 707, 9861, 958, 281, 309, 281, 855, 300, 257, 11004, 50871], "temperature": 0.0, "avg_logprob": -0.10846806439486417, "compression_ratio": 1.8132780082987552, "no_speech_prob": 6.204940291354433e-05}, {"id": 42, "seek": 19668, "start": 206.82, "end": 209.4, "text": " has taken place.", "tokens": [50871, 575, 2726, 1081, 13, 51000], "temperature": 0.0, "avg_logprob": -0.10846806439486417, "compression_ratio": 1.8132780082987552, "no_speech_prob": 6.204940291354433e-05}, {"id": 43, "seek": 19668, "start": 209.4, "end": 215.84, "text": " In general, if we have a lambda abstraction, lambda x dot m, apply to an input n, denoted", "tokens": [51000, 682, 2674, 11, 498, 321, 362, 257, 13607, 37765, 11, 13607, 2031, 5893, 275, 11, 3079, 281, 364, 4846, 297, 11, 1441, 23325, 51322], "temperature": 0.0, "avg_logprob": -0.10846806439486417, "compression_ratio": 1.8132780082987552, "no_speech_prob": 6.204940291354433e-05}, {"id": 44, "seek": 19668, "start": 215.84, "end": 219.08, "text": " by writing the input on the right of our function.", "tokens": [51322, 538, 3579, 264, 4846, 322, 264, 558, 295, 527, 2445, 13, 51484], "temperature": 0.0, "avg_logprob": -0.10846806439486417, "compression_ratio": 1.8132780082987552, "no_speech_prob": 6.204940291354433e-05}, {"id": 45, "seek": 19668, "start": 219.08, "end": 225.04000000000002, "text": " We can perform a beta reduction by going through m and substituting our input n for the variable", "tokens": [51484, 492, 393, 2042, 257, 9861, 11004, 538, 516, 807, 275, 293, 26441, 10861, 527, 4846, 297, 337, 264, 7006, 51782], "temperature": 0.0, "avg_logprob": -0.10846806439486417, "compression_ratio": 1.8132780082987552, "no_speech_prob": 6.204940291354433e-05}, {"id": 46, "seek": 22504, "start": 225.04, "end": 226.04, "text": " x.", "tokens": [50364, 2031, 13, 50414], "temperature": 0.0, "avg_logprob": -0.15252282189541175, "compression_ratio": 1.4213483146067416, "no_speech_prob": 0.0013884708750993013}, {"id": 47, "seek": 22504, "start": 226.04, "end": 235.04, "text": " We'll shorten this by writing a slash to mean substituted for.", "tokens": [50414, 492, 603, 39632, 341, 538, 3579, 257, 17330, 281, 914, 26441, 4866, 337, 13, 50864], "temperature": 0.0, "avg_logprob": -0.15252282189541175, "compression_ratio": 1.4213483146067416, "no_speech_prob": 0.0013884708750993013}, {"id": 48, "seek": 22504, "start": 235.04, "end": 240.98, "text": " So we've now understood variables, lambda abstractions, and applications of functions", "tokens": [50864, 407, 321, 600, 586, 7320, 9102, 11, 13607, 12649, 626, 11, 293, 5821, 295, 6828, 51161], "temperature": 0.0, "avg_logprob": -0.15252282189541175, "compression_ratio": 1.4213483146067416, "no_speech_prob": 0.0013884708750993013}, {"id": 49, "seek": 22504, "start": 240.98, "end": 246.68, "text": " via beta reduction.", "tokens": [51161, 5766, 9861, 11004, 13, 51446], "temperature": 0.0, "avg_logprob": -0.15252282189541175, "compression_ratio": 1.4213483146067416, "no_speech_prob": 0.0013884708750993013}, {"id": 50, "seek": 22504, "start": 246.68, "end": 251.12, "text": " This looks very much like a start to an extremely primitive programming language.", "tokens": [51446, 639, 1542, 588, 709, 411, 257, 722, 281, 364, 4664, 28540, 9410, 2856, 13, 51668], "temperature": 0.0, "avg_logprob": -0.15252282189541175, "compression_ratio": 1.4213483146067416, "no_speech_prob": 0.0013884708750993013}, {"id": 51, "seek": 25112, "start": 251.12, "end": 256.24, "text": " To finish it off, we would just need to add support for multiple inputs, loops, booleans,", "tokens": [50364, 1407, 2413, 309, 766, 11, 321, 576, 445, 643, 281, 909, 1406, 337, 3866, 15743, 11, 16121, 11, 748, 4812, 599, 11, 50620], "temperature": 0.0, "avg_logprob": -0.09575038486056858, "compression_ratio": 1.6194331983805668, "no_speech_prob": 0.023687083274126053}, {"id": 52, "seek": 25112, "start": 256.24, "end": 260.56, "text": " some data structures, a few more rules of computation.", "tokens": [50620, 512, 1412, 9227, 11, 257, 1326, 544, 4474, 295, 24903, 13, 50836], "temperature": 0.0, "avg_logprob": -0.09575038486056858, "compression_ratio": 1.6194331983805668, "no_speech_prob": 0.023687083274126053}, {"id": 53, "seek": 25112, "start": 260.56, "end": 264.72, "text": " As it turns out, we actually don't need anything more.", "tokens": [50836, 1018, 309, 4523, 484, 11, 321, 767, 500, 380, 643, 1340, 544, 13, 51044], "temperature": 0.0, "avg_logprob": -0.09575038486056858, "compression_ratio": 1.6194331983805668, "no_speech_prob": 0.023687083274126053}, {"id": 54, "seek": 25112, "start": 264.72, "end": 271.04, "text": " If we only allow the programmer to write variables, lambda abstractions, and applications, and", "tokens": [51044, 759, 321, 787, 2089, 264, 32116, 281, 2464, 9102, 11, 13607, 12649, 626, 11, 293, 5821, 11, 293, 51360], "temperature": 0.0, "avg_logprob": -0.09575038486056858, "compression_ratio": 1.6194331983805668, "no_speech_prob": 0.023687083274126053}, {"id": 55, "seek": 25112, "start": 271.04, "end": 277.0, "text": " simply compute these terms using beta reduction, we can make anything that a computer will", "tokens": [51360, 2935, 14722, 613, 2115, 1228, 9861, 11004, 11, 321, 393, 652, 1340, 300, 257, 3820, 486, 51658], "temperature": 0.0, "avg_logprob": -0.09575038486056858, "compression_ratio": 1.6194331983805668, "no_speech_prob": 0.023687083274126053}, {"id": 56, "seek": 25112, "start": 277.0, "end": 280.2, "text": " ever do, ever.", "tokens": [51658, 1562, 360, 11, 1562, 13, 51818], "temperature": 0.0, "avg_logprob": -0.09575038486056858, "compression_ratio": 1.6194331983805668, "no_speech_prob": 0.023687083274126053}, {"id": 57, "seek": 28020, "start": 280.2, "end": 284.47999999999996, "text": " This amazing result was documented in the Church-Turing thesis.", "tokens": [50364, 639, 2243, 1874, 390, 23007, 294, 264, 7882, 12, 51, 1345, 22288, 13, 50578], "temperature": 0.0, "avg_logprob": -0.12679061336793762, "compression_ratio": 1.4846938775510203, "no_speech_prob": 0.00011235123383812606}, {"id": 58, "seek": 28020, "start": 284.47999999999996, "end": 289.58, "text": " Two names we'll come across later on.", "tokens": [50578, 4453, 5288, 321, 603, 808, 2108, 1780, 322, 13, 50833], "temperature": 0.0, "avg_logprob": -0.12679061336793762, "compression_ratio": 1.4846938775510203, "no_speech_prob": 0.00011235123383812606}, {"id": 59, "seek": 28020, "start": 289.58, "end": 297.36, "text": " We call this tiny programming language the lambda calculus.", "tokens": [50833, 492, 818, 341, 5870, 9410, 2856, 264, 13607, 33400, 13, 51222], "temperature": 0.0, "avg_logprob": -0.12679061336793762, "compression_ratio": 1.4846938775510203, "no_speech_prob": 0.00011235123383812606}, {"id": 60, "seek": 28020, "start": 297.36, "end": 302.71999999999997, "text": " This result seems impossible, but the key to seeing how this is achieved is by noticing", "tokens": [51222, 639, 1874, 2544, 6243, 11, 457, 264, 2141, 281, 2577, 577, 341, 307, 11042, 307, 538, 21814, 51490], "temperature": 0.0, "avg_logprob": -0.12679061336793762, "compression_ratio": 1.4846938775510203, "no_speech_prob": 0.00011235123383812606}, {"id": 61, "seek": 28020, "start": 302.71999999999997, "end": 309.12, "text": " that our functions here are higher order.", "tokens": [51490, 300, 527, 6828, 510, 366, 2946, 1668, 13, 51810], "temperature": 0.0, "avg_logprob": -0.12679061336793762, "compression_ratio": 1.4846938775510203, "no_speech_prob": 0.00011235123383812606}, {"id": 62, "seek": 30912, "start": 309.12, "end": 313.92, "text": " This means that functions can be passed as inputs to other functions, and equally functions", "tokens": [50364, 639, 1355, 300, 6828, 393, 312, 4678, 382, 15743, 281, 661, 6828, 11, 293, 12309, 6828, 50604], "temperature": 0.0, "avg_logprob": -0.0976242660194315, "compression_ratio": 1.7188755020080322, "no_speech_prob": 0.011329307220876217}, {"id": 63, "seek": 30912, "start": 313.92, "end": 317.82, "text": " can return functions as an output.", "tokens": [50604, 393, 2736, 6828, 382, 364, 5598, 13, 50799], "temperature": 0.0, "avg_logprob": -0.0976242660194315, "compression_ratio": 1.7188755020080322, "no_speech_prob": 0.011329307220876217}, {"id": 64, "seek": 30912, "start": 317.82, "end": 322.64, "text": " This small subtlety is what gives the lambda calculus its punch, which I'll demonstrate", "tokens": [50799, 639, 1359, 7257, 75, 2210, 307, 437, 2709, 264, 13607, 33400, 1080, 8135, 11, 597, 286, 603, 11698, 51040], "temperature": 0.0, "avg_logprob": -0.0976242660194315, "compression_ratio": 1.7188755020080322, "no_speech_prob": 0.011329307220876217}, {"id": 65, "seek": 30912, "start": 322.64, "end": 327.8, "text": " by replicating a standard feature of more complicated programming languages in the lambda", "tokens": [51040, 538, 3248, 30541, 257, 3832, 4111, 295, 544, 6179, 9410, 8650, 294, 264, 13607, 51298], "temperature": 0.0, "avg_logprob": -0.0976242660194315, "compression_ratio": 1.7188755020080322, "no_speech_prob": 0.011329307220876217}, {"id": 66, "seek": 30912, "start": 327.8, "end": 331.3, "text": " calculus.", "tokens": [51298, 33400, 13, 51473], "temperature": 0.0, "avg_logprob": -0.0976242660194315, "compression_ratio": 1.7188755020080322, "no_speech_prob": 0.011329307220876217}, {"id": 67, "seek": 30912, "start": 331.3, "end": 336.28000000000003, "text": " You might have noticed that lambda abstractions only have a singular input variable, which", "tokens": [51473, 509, 1062, 362, 5694, 300, 13607, 12649, 626, 787, 362, 257, 20010, 4846, 7006, 11, 597, 51722], "temperature": 0.0, "avg_logprob": -0.0976242660194315, "compression_ratio": 1.7188755020080322, "no_speech_prob": 0.011329307220876217}, {"id": 68, "seek": 30912, "start": 336.28000000000003, "end": 338.9, "text": " seems rather limiting.", "tokens": [51722, 2544, 2831, 22083, 13, 51853], "temperature": 0.0, "avg_logprob": -0.0976242660194315, "compression_ratio": 1.7188755020080322, "no_speech_prob": 0.011329307220876217}, {"id": 69, "seek": 33890, "start": 338.9, "end": 343.53999999999996, "text": " What if Bob wants to make a function that, say, takes two numbers as inputs, and then", "tokens": [50364, 708, 498, 6085, 2738, 281, 652, 257, 2445, 300, 11, 584, 11, 2516, 732, 3547, 382, 15743, 11, 293, 550, 50596], "temperature": 0.0, "avg_logprob": -0.18020871345033038, "compression_ratio": 1.6919642857142858, "no_speech_prob": 0.0018674005987122655}, {"id": 70, "seek": 33890, "start": 343.53999999999996, "end": 346.91999999999996, "text": " outputs their sum?", "tokens": [50596, 23930, 641, 2408, 30, 50765], "temperature": 0.0, "avg_logprob": -0.18020871345033038, "compression_ratio": 1.6919642857142858, "no_speech_prob": 0.0018674005987122655}, {"id": 71, "seek": 33890, "start": 346.91999999999996, "end": 350.34, "text": " He can actually achieve this with a little trick.", "tokens": [50765, 634, 393, 767, 4584, 341, 365, 257, 707, 4282, 13, 50936], "temperature": 0.0, "avg_logprob": -0.18020871345033038, "compression_ratio": 1.6919642857142858, "no_speech_prob": 0.0018674005987122655}, {"id": 72, "seek": 33890, "start": 350.34, "end": 355.71999999999997, "text": " Consider the function that takes an input x and returns another function.", "tokens": [50936, 17416, 264, 2445, 300, 2516, 364, 4846, 2031, 293, 11247, 1071, 2445, 13, 51205], "temperature": 0.0, "avg_logprob": -0.18020871345033038, "compression_ratio": 1.6919642857142858, "no_speech_prob": 0.0018674005987122655}, {"id": 73, "seek": 33890, "start": 355.71999999999997, "end": 361.41999999999996, "text": " This outputted function takes an input y and outputs x plus y.", "tokens": [51205, 639, 5598, 14727, 2445, 2516, 364, 4846, 288, 293, 23930, 2031, 1804, 288, 13, 51490], "temperature": 0.0, "avg_logprob": -0.18020871345033038, "compression_ratio": 1.6919642857142858, "no_speech_prob": 0.0018674005987122655}, {"id": 74, "seek": 33890, "start": 361.41999999999996, "end": 366.84, "text": " Okay, that's a little confusing, but let's see what happens when we apply this function", "tokens": [51490, 1033, 11, 300, 311, 257, 707, 13181, 11, 457, 718, 311, 536, 437, 2314, 562, 321, 3079, 341, 2445, 51761], "temperature": 0.0, "avg_logprob": -0.18020871345033038, "compression_ratio": 1.6919642857142858, "no_speech_prob": 0.0018674005987122655}, {"id": 75, "seek": 36684, "start": 366.84, "end": 371.34, "text": " to an input, say 1.", "tokens": [50364, 281, 364, 4846, 11, 584, 502, 13, 50589], "temperature": 0.0, "avg_logprob": -0.1625802599150559, "compression_ratio": 1.596774193548387, "no_speech_prob": 0.0015011380892246962}, {"id": 76, "seek": 36684, "start": 371.34, "end": 377.61999999999995, "text": " Replacing all x's with 1's gives the function lambda y dot 1 plus y.", "tokens": [50589, 47762, 5615, 439, 2031, 311, 365, 502, 311, 2709, 264, 2445, 13607, 288, 5893, 502, 1804, 288, 13, 50903], "temperature": 0.0, "avg_logprob": -0.1625802599150559, "compression_ratio": 1.596774193548387, "no_speech_prob": 0.0015011380892246962}, {"id": 77, "seek": 36684, "start": 377.61999999999995, "end": 383.82, "text": " That is, a function that takes an input and returns 1 plus that input.", "tokens": [50903, 663, 307, 11, 257, 2445, 300, 2516, 364, 4846, 293, 11247, 502, 1804, 300, 4846, 13, 51213], "temperature": 0.0, "avg_logprob": -0.1625802599150559, "compression_ratio": 1.596774193548387, "no_speech_prob": 0.0015011380892246962}, {"id": 78, "seek": 36684, "start": 383.82, "end": 389.26, "text": " So if we apply this function to the number 2, we replace the occurrence of y in our lambda", "tokens": [51213, 407, 498, 321, 3079, 341, 2445, 281, 264, 1230, 568, 11, 321, 7406, 264, 36122, 295, 288, 294, 527, 13607, 51485], "temperature": 0.0, "avg_logprob": -0.1625802599150559, "compression_ratio": 1.596774193548387, "no_speech_prob": 0.0015011380892246962}, {"id": 79, "seek": 36684, "start": 389.26, "end": 396.09999999999997, "text": " abstraction with 2, and we get 1 plus 2, or 3.", "tokens": [51485, 37765, 365, 568, 11, 293, 321, 483, 502, 1804, 568, 11, 420, 805, 13, 51827], "temperature": 0.0, "avg_logprob": -0.1625802599150559, "compression_ratio": 1.596774193548387, "no_speech_prob": 0.0015011380892246962}, {"id": 80, "seek": 39610, "start": 396.1, "end": 400.96000000000004, "text": " We've effectively given this function one input after another, and it has returned their", "tokens": [50364, 492, 600, 8659, 2212, 341, 2445, 472, 4846, 934, 1071, 11, 293, 309, 575, 8752, 641, 50607], "temperature": 0.0, "avg_logprob": -0.13906824433958376, "compression_ratio": 1.6436170212765957, "no_speech_prob": 0.0023965134751051664}, {"id": 81, "seek": 39610, "start": 400.96000000000004, "end": 402.84000000000003, "text": " sum.", "tokens": [50607, 2408, 13, 50701], "temperature": 0.0, "avg_logprob": -0.13906824433958376, "compression_ratio": 1.6436170212765957, "no_speech_prob": 0.0023965134751051664}, {"id": 82, "seek": 39610, "start": 402.84000000000003, "end": 409.56, "text": " To generalise this, the arbitrary lambda abstraction lambda x dot lambda y dot l can", "tokens": [50701, 1407, 2674, 908, 341, 11, 264, 23211, 13607, 37765, 13607, 2031, 5893, 13607, 288, 5893, 287, 393, 51037], "temperature": 0.0, "avg_logprob": -0.13906824433958376, "compression_ratio": 1.6436170212765957, "no_speech_prob": 0.0023965134751051664}, {"id": 83, "seek": 39610, "start": 409.56, "end": 413.24, "text": " be applied to two inputs, m and n.", "tokens": [51037, 312, 6456, 281, 732, 15743, 11, 275, 293, 297, 13, 51221], "temperature": 0.0, "avg_logprob": -0.13906824433958376, "compression_ratio": 1.6436170212765957, "no_speech_prob": 0.0023965134751051664}, {"id": 84, "seek": 39610, "start": 413.24, "end": 421.08000000000004, "text": " By first beta reducing with the first input m to the function lambda y dot l with m substituted", "tokens": [51221, 3146, 700, 9861, 12245, 365, 264, 700, 4846, 275, 281, 264, 2445, 13607, 288, 5893, 287, 365, 275, 26441, 4866, 51613], "temperature": 0.0, "avg_logprob": -0.13906824433958376, "compression_ratio": 1.6436170212765957, "no_speech_prob": 0.0023965134751051664}, {"id": 85, "seek": 42108, "start": 421.08, "end": 426.38, "text": " for x, which is yet to be applied to the input n.", "tokens": [50364, 337, 2031, 11, 597, 307, 1939, 281, 312, 6456, 281, 264, 4846, 297, 13, 50629], "temperature": 0.0, "avg_logprob": -0.10675652460618452, "compression_ratio": 1.7567567567567568, "no_speech_prob": 0.02930980548262596}, {"id": 86, "seek": 42108, "start": 426.38, "end": 431.94, "text": " We can then perform a second beta reduction with the input n, to finally get the term", "tokens": [50629, 492, 393, 550, 2042, 257, 1150, 9861, 11004, 365, 264, 4846, 297, 11, 281, 2721, 483, 264, 1433, 50907], "temperature": 0.0, "avg_logprob": -0.10675652460618452, "compression_ratio": 1.7567567567567568, "no_speech_prob": 0.02930980548262596}, {"id": 87, "seek": 42108, "start": 431.94, "end": 439.26, "text": " l with m substituted for x and n substituted for y.", "tokens": [50907, 287, 365, 275, 26441, 4866, 337, 2031, 293, 297, 26441, 4866, 337, 288, 13, 51273], "temperature": 0.0, "avg_logprob": -0.10675652460618452, "compression_ratio": 1.7567567567567568, "no_speech_prob": 0.02930980548262596}, {"id": 88, "seek": 42108, "start": 439.26, "end": 445.18, "text": " So our output is a term with a substitution for x and a substitution for y, exactly as", "tokens": [51273, 407, 527, 5598, 307, 257, 1433, 365, 257, 35827, 337, 2031, 293, 257, 35827, 337, 288, 11, 2293, 382, 51569], "temperature": 0.0, "avg_logprob": -0.10675652460618452, "compression_ratio": 1.7567567567567568, "no_speech_prob": 0.02930980548262596}, {"id": 89, "seek": 42108, "start": 445.18, "end": 450.29999999999995, "text": " we'd expect from a function that takes two inputs.", "tokens": [51569, 321, 1116, 2066, 490, 257, 2445, 300, 2516, 732, 15743, 13, 51825], "temperature": 0.0, "avg_logprob": -0.10675652460618452, "compression_ratio": 1.7567567567567568, "no_speech_prob": 0.02930980548262596}, {"id": 90, "seek": 45030, "start": 450.3, "end": 455.32, "text": " This method of functions returning functions to sequentially apply to multiple inputs is", "tokens": [50364, 639, 3170, 295, 6828, 12678, 6828, 281, 5123, 3137, 3079, 281, 3866, 15743, 307, 50615], "temperature": 0.0, "avg_logprob": -0.17323848724365234, "compression_ratio": 1.5046296296296295, "no_speech_prob": 0.00015597222954966128}, {"id": 91, "seek": 45030, "start": 455.32, "end": 463.54, "text": " called currying, named after the logician Haskell-curry.", "tokens": [50615, 1219, 1262, 19076, 11, 4926, 934, 264, 3565, 9027, 8646, 43723, 12, 14112, 627, 13, 51026], "temperature": 0.0, "avg_logprob": -0.17323848724365234, "compression_ratio": 1.5046296296296295, "no_speech_prob": 0.00015597222954966128}, {"id": 92, "seek": 45030, "start": 463.54, "end": 470.12, "text": " If you have experienced programming, why not try to make some curried functions yourself?", "tokens": [51026, 759, 291, 362, 6751, 9410, 11, 983, 406, 853, 281, 652, 512, 1262, 2428, 6828, 1803, 30, 51355], "temperature": 0.0, "avg_logprob": -0.17323848724365234, "compression_ratio": 1.5046296296296295, "no_speech_prob": 0.00015597222954966128}, {"id": 93, "seek": 45030, "start": 470.12, "end": 475.72, "text": " This Python program here, for example, uses the built-in lambda syntax to add two numbers", "tokens": [51355, 639, 15329, 1461, 510, 11, 337, 1365, 11, 4960, 264, 3094, 12, 259, 13607, 28431, 281, 909, 732, 3547, 51635], "temperature": 0.0, "avg_logprob": -0.17323848724365234, "compression_ratio": 1.5046296296296295, "no_speech_prob": 0.00015597222954966128}, {"id": 94, "seek": 47572, "start": 475.72, "end": 481.46000000000004, "text": " together using currying.", "tokens": [50364, 1214, 1228, 1262, 19076, 13, 50651], "temperature": 0.0, "avg_logprob": -0.10665005813410253, "compression_ratio": 1.6327433628318584, "no_speech_prob": 0.008060766384005547}, {"id": 95, "seek": 47572, "start": 481.46000000000004, "end": 485.70000000000005, "text": " This way of thinking can take a while to get used to, but hopefully I'm starting to convince", "tokens": [50651, 639, 636, 295, 1953, 393, 747, 257, 1339, 281, 483, 1143, 281, 11, 457, 4696, 286, 478, 2891, 281, 13447, 50863], "temperature": 0.0, "avg_logprob": -0.10665005813410253, "compression_ratio": 1.6327433628318584, "no_speech_prob": 0.008060766384005547}, {"id": 96, "seek": 47572, "start": 485.70000000000005, "end": 492.26000000000005, "text": " you that the higher-order lambda abstractions have more nuance than you might have expected.", "tokens": [50863, 291, 300, 264, 2946, 12, 4687, 13607, 12649, 626, 362, 544, 42625, 813, 291, 1062, 362, 5176, 13, 51191], "temperature": 0.0, "avg_logprob": -0.10665005813410253, "compression_ratio": 1.6327433628318584, "no_speech_prob": 0.008060766384005547}, {"id": 97, "seek": 47572, "start": 492.26000000000005, "end": 497.16, "text": " To continue building the primitive calculus into a more practical programming language,", "tokens": [51191, 1407, 2354, 2390, 264, 28540, 33400, 666, 257, 544, 8496, 9410, 2856, 11, 51436], "temperature": 0.0, "avg_logprob": -0.10665005813410253, "compression_ratio": 1.6327433628318584, "no_speech_prob": 0.008060766384005547}, {"id": 98, "seek": 47572, "start": 497.16, "end": 502.84000000000003, "text": " we can encode some more common programming concepts into the calculus.", "tokens": [51436, 321, 393, 2058, 1429, 512, 544, 2689, 9410, 10392, 666, 264, 33400, 13, 51720], "temperature": 0.0, "avg_logprob": -0.10665005813410253, "compression_ratio": 1.6327433628318584, "no_speech_prob": 0.008060766384005547}, {"id": 99, "seek": 50284, "start": 502.84, "end": 509.35999999999996, "text": " As a quick example, to use Booleans and conditionals, we can represent true as the term lambda", "tokens": [50364, 1018, 257, 1702, 1365, 11, 281, 764, 23351, 24008, 293, 4188, 1124, 11, 321, 393, 2906, 2074, 382, 264, 1433, 13607, 50690], "temperature": 0.0, "avg_logprob": -0.11683148306769293, "compression_ratio": 2.0416666666666665, "no_speech_prob": 0.010327274911105633}, {"id": 100, "seek": 50284, "start": 509.35999999999996, "end": 518.5799999999999, "text": " x dot lambda y dot x, the function that takes two inputs and returns the first, and represent", "tokens": [50690, 2031, 5893, 13607, 288, 5893, 2031, 11, 264, 2445, 300, 2516, 732, 15743, 293, 11247, 264, 700, 11, 293, 2906, 51151], "temperature": 0.0, "avg_logprob": -0.11683148306769293, "compression_ratio": 2.0416666666666665, "no_speech_prob": 0.010327274911105633}, {"id": 101, "seek": 50284, "start": 518.5799999999999, "end": 525.76, "text": " false as the term lambda x dot lambda y dot y, the function that takes two inputs and returns", "tokens": [51151, 7908, 382, 264, 1433, 13607, 2031, 5893, 13607, 288, 5893, 288, 11, 264, 2445, 300, 2516, 732, 15743, 293, 11247, 51510], "temperature": 0.0, "avg_logprob": -0.11683148306769293, "compression_ratio": 2.0416666666666665, "no_speech_prob": 0.010327274911105633}, {"id": 102, "seek": 50284, "start": 525.76, "end": 528.28, "text": " the second.", "tokens": [51510, 264, 1150, 13, 51636], "temperature": 0.0, "avg_logprob": -0.11683148306769293, "compression_ratio": 2.0416666666666665, "no_speech_prob": 0.010327274911105633}, {"id": 103, "seek": 52828, "start": 528.28, "end": 533.5, "text": " This seems completely arbitrary, but look what happens when we encode an if statement", "tokens": [50364, 639, 2544, 2584, 23211, 11, 457, 574, 437, 2314, 562, 321, 2058, 1429, 364, 498, 5629, 50625], "temperature": 0.0, "avg_logprob": -0.10625025021132603, "compression_ratio": 1.7163461538461537, "no_speech_prob": 0.002115601906552911}, {"id": 104, "seek": 52828, "start": 533.5, "end": 542.12, "text": " as lambda b dot lambda x dot lambda y dot b apply to x and then y.", "tokens": [50625, 382, 13607, 272, 5893, 13607, 2031, 5893, 13607, 288, 5893, 272, 3079, 281, 2031, 293, 550, 288, 13, 51056], "temperature": 0.0, "avg_logprob": -0.10625025021132603, "compression_ratio": 1.7163461538461537, "no_speech_prob": 0.002115601906552911}, {"id": 105, "seek": 52828, "start": 542.12, "end": 547.88, "text": " This lambda abstraction just takes three inputs, b, x and y, and outputs the result", "tokens": [51056, 639, 13607, 37765, 445, 2516, 1045, 15743, 11, 272, 11, 2031, 293, 288, 11, 293, 23930, 264, 1874, 51344], "temperature": 0.0, "avg_logprob": -0.10625025021132603, "compression_ratio": 1.7163461538461537, "no_speech_prob": 0.002115601906552911}, {"id": 106, "seek": 52828, "start": 547.88, "end": 552.4, "text": " of applying b to the inputs x and y.", "tokens": [51344, 295, 9275, 272, 281, 264, 15743, 2031, 293, 288, 13, 51570], "temperature": 0.0, "avg_logprob": -0.10625025021132603, "compression_ratio": 1.7163461538461537, "no_speech_prob": 0.002115601906552911}, {"id": 107, "seek": 52828, "start": 552.4, "end": 556.9599999999999, "text": " This looks pretty random, but if we input a Boolean as the first argument, and then", "tokens": [51570, 639, 1542, 1238, 4974, 11, 457, 498, 321, 4846, 257, 23351, 28499, 382, 264, 700, 6770, 11, 293, 550, 51798], "temperature": 0.0, "avg_logprob": -0.10625025021132603, "compression_ratio": 1.7163461538461537, "no_speech_prob": 0.002115601906552911}, {"id": 108, "seek": 55696, "start": 556.96, "end": 563.74, "text": " any two terms as the inputs x and y, this function will behave just like an if statement.", "tokens": [50364, 604, 732, 2115, 382, 264, 15743, 2031, 293, 288, 11, 341, 2445, 486, 15158, 445, 411, 364, 498, 5629, 13, 50703], "temperature": 0.0, "avg_logprob": -0.2052837694194955, "compression_ratio": 1.5502958579881656, "no_speech_prob": 0.0013669312465935946}, {"id": 109, "seek": 55696, "start": 563.74, "end": 572.8000000000001, "text": " It will return the first term if the Boolean is true, and the second if it's not.", "tokens": [50703, 467, 486, 2736, 264, 700, 1433, 498, 264, 23351, 28499, 307, 2074, 11, 293, 264, 1150, 498, 309, 311, 406, 13, 51156], "temperature": 0.0, "avg_logprob": -0.2052837694194955, "compression_ratio": 1.5502958579881656, "no_speech_prob": 0.0013669312465935946}, {"id": 110, "seek": 55696, "start": 572.8000000000001, "end": 579.88, "text": " In Python, this lambda abstraction would be the program if b then return x, else return", "tokens": [51156, 682, 15329, 11, 341, 13607, 37765, 576, 312, 264, 1461, 498, 272, 550, 2736, 2031, 11, 1646, 2736, 51510], "temperature": 0.0, "avg_logprob": -0.2052837694194955, "compression_ratio": 1.5502958579881656, "no_speech_prob": 0.0013669312465935946}, {"id": 111, "seek": 55696, "start": 579.88, "end": 583.4000000000001, "text": " y.", "tokens": [51510, 288, 13, 51686], "temperature": 0.0, "avg_logprob": -0.2052837694194955, "compression_ratio": 1.5502958579881656, "no_speech_prob": 0.0013669312465935946}, {"id": 112, "seek": 58340, "start": 583.4, "end": 585.28, "text": " Let's test that out.", "tokens": [50364, 961, 311, 1500, 300, 484, 13, 50458], "temperature": 0.0, "avg_logprob": -0.2135761260986328, "compression_ratio": 1.4720496894409938, "no_speech_prob": 0.01971597410738468}, {"id": 113, "seek": 58340, "start": 585.28, "end": 590.4399999999999, "text": " Applying our if statement to the inputs true m, n, where m and n are some terms in the", "tokens": [50458, 3132, 7310, 527, 498, 5629, 281, 264, 15743, 2074, 275, 11, 297, 11, 689, 275, 293, 297, 366, 512, 2115, 294, 264, 50716], "temperature": 0.0, "avg_logprob": -0.2135761260986328, "compression_ratio": 1.4720496894409938, "no_speech_prob": 0.01971597410738468}, {"id": 114, "seek": 58340, "start": 590.4399999999999, "end": 594.1999999999999, "text": " lambda calculus, should return m.", "tokens": [50716, 13607, 33400, 11, 820, 2736, 275, 13, 50904], "temperature": 0.0, "avg_logprob": -0.2135761260986328, "compression_ratio": 1.4720496894409938, "no_speech_prob": 0.01971597410738468}, {"id": 115, "seek": 58340, "start": 594.1999999999999, "end": 602.36, "text": " Let's plug true in for b first, giving lambda x dot lambda y dot true x, y, apply to m,", "tokens": [50904, 961, 311, 5452, 2074, 294, 337, 272, 700, 11, 2902, 13607, 2031, 5893, 13607, 288, 5893, 2074, 2031, 11, 288, 11, 3079, 281, 275, 11, 51312], "temperature": 0.0, "avg_logprob": -0.2135761260986328, "compression_ratio": 1.4720496894409938, "no_speech_prob": 0.01971597410738468}, {"id": 116, "seek": 58340, "start": 602.36, "end": 605.68, "text": " then n.", "tokens": [51312, 550, 297, 13, 51478], "temperature": 0.0, "avg_logprob": -0.2135761260986328, "compression_ratio": 1.4720496894409938, "no_speech_prob": 0.01971597410738468}, {"id": 117, "seek": 60568, "start": 605.68, "end": 614.28, "text": " Plugging in m for x gives lambda y dot true m, y, apply to n.", "tokens": [50364, 40740, 3249, 294, 275, 337, 2031, 2709, 13607, 288, 5893, 2074, 275, 11, 288, 11, 3079, 281, 297, 13, 50794], "temperature": 0.0, "avg_logprob": -0.13575983738553696, "compression_ratio": 1.5089820359281436, "no_speech_prob": 0.0004955288022756577}, {"id": 118, "seek": 60568, "start": 614.28, "end": 622.4, "text": " Then finally substituting n for y gives true m, n.", "tokens": [50794, 1396, 2721, 26441, 10861, 297, 337, 288, 2709, 2074, 275, 11, 297, 13, 51200], "temperature": 0.0, "avg_logprob": -0.13575983738553696, "compression_ratio": 1.5089820359281436, "no_speech_prob": 0.0004955288022756577}, {"id": 119, "seek": 60568, "start": 622.4, "end": 627.2399999999999, "text": " Now we can turn the term true back into its definition in the lambda calculus, the function", "tokens": [51200, 823, 321, 393, 1261, 264, 1433, 2074, 646, 666, 1080, 7123, 294, 264, 13607, 33400, 11, 264, 2445, 51442], "temperature": 0.0, "avg_logprob": -0.13575983738553696, "compression_ratio": 1.5089820359281436, "no_speech_prob": 0.0004955288022756577}, {"id": 120, "seek": 60568, "start": 627.2399999999999, "end": 632.3599999999999, "text": " that takes two arguments and returns the first.", "tokens": [51442, 300, 2516, 732, 12869, 293, 11247, 264, 700, 13, 51698], "temperature": 0.0, "avg_logprob": -0.13575983738553696, "compression_ratio": 1.5089820359281436, "no_speech_prob": 0.0004955288022756577}, {"id": 121, "seek": 63236, "start": 632.36, "end": 641.6, "text": " So let's first substitute m for x, giving lambda y dot m, apply to n.", "tokens": [50364, 407, 718, 311, 700, 15802, 275, 337, 2031, 11, 2902, 13607, 288, 5893, 275, 11, 3079, 281, 297, 13, 50826], "temperature": 0.0, "avg_logprob": -0.13544592138839096, "compression_ratio": 1.4662921348314606, "no_speech_prob": 8.480977703584358e-05}, {"id": 122, "seek": 63236, "start": 641.6, "end": 647.24, "text": " Finally substituting n for y just returns m, since there aren't any y's in this lambda", "tokens": [50826, 6288, 26441, 10861, 297, 337, 288, 445, 11247, 275, 11, 1670, 456, 3212, 380, 604, 288, 311, 294, 341, 13607, 51108], "temperature": 0.0, "avg_logprob": -0.13544592138839096, "compression_ratio": 1.4662921348314606, "no_speech_prob": 8.480977703584358e-05}, {"id": 123, "seek": 63236, "start": 647.24, "end": 649.72, "text": " abstraction at all.", "tokens": [51108, 37765, 412, 439, 13, 51232], "temperature": 0.0, "avg_logprob": -0.13544592138839096, "compression_ratio": 1.4662921348314606, "no_speech_prob": 8.480977703584358e-05}, {"id": 124, "seek": 63236, "start": 649.72, "end": 654.76, "text": " So after all that, we've ended up with our if statement with the Boolean input true,", "tokens": [51232, 407, 934, 439, 300, 11, 321, 600, 4590, 493, 365, 527, 498, 5629, 365, 264, 23351, 28499, 4846, 2074, 11, 51484], "temperature": 0.0, "avg_logprob": -0.13544592138839096, "compression_ratio": 1.4662921348314606, "no_speech_prob": 8.480977703584358e-05}, {"id": 125, "seek": 65476, "start": 654.76, "end": 661.48, "text": " and the inputted terms m and n, outputting the first term m, exactly as we expected it", "tokens": [50364, 293, 264, 4846, 14727, 2115, 275, 293, 297, 11, 5598, 783, 264, 700, 1433, 275, 11, 2293, 382, 321, 5176, 309, 50700], "temperature": 0.0, "avg_logprob": -0.13264405727386475, "compression_ratio": 1.6428571428571428, "no_speech_prob": 0.0675305724143982}, {"id": 126, "seek": 65476, "start": 661.48, "end": 663.4, "text": " to do.", "tokens": [50700, 281, 360, 13, 50796], "temperature": 0.0, "avg_logprob": -0.13264405727386475, "compression_ratio": 1.6428571428571428, "no_speech_prob": 0.0675305724143982}, {"id": 127, "seek": 65476, "start": 663.4, "end": 674.0, "text": " Try plugging in false to our if statement, and verify that it returns n this time.", "tokens": [50796, 6526, 42975, 294, 7908, 281, 527, 498, 5629, 11, 293, 16888, 300, 309, 11247, 297, 341, 565, 13, 51326], "temperature": 0.0, "avg_logprob": -0.13264405727386475, "compression_ratio": 1.6428571428571428, "no_speech_prob": 0.0675305724143982}, {"id": 128, "seek": 65476, "start": 674.0, "end": 677.0, "text": " You may be starting to feel slightly short change.", "tokens": [51326, 509, 815, 312, 2891, 281, 841, 4748, 2099, 1319, 13, 51476], "temperature": 0.0, "avg_logprob": -0.13264405727386475, "compression_ratio": 1.6428571428571428, "no_speech_prob": 0.0675305724143982}, {"id": 129, "seek": 65476, "start": 677.0, "end": 680.88, "text": " The introduction to this video suggested that the lambda calculus would be the solution", "tokens": [51476, 440, 9339, 281, 341, 960, 10945, 300, 264, 13607, 33400, 576, 312, 264, 3827, 51670], "temperature": 0.0, "avg_logprob": -0.13264405727386475, "compression_ratio": 1.6428571428571428, "no_speech_prob": 0.0675305724143982}, {"id": 130, "seek": 65476, "start": 680.88, "end": 684.04, "text": " to the problem of complicated programming languages.", "tokens": [51670, 281, 264, 1154, 295, 6179, 9410, 8650, 13, 51828], "temperature": 0.0, "avg_logprob": -0.13264405727386475, "compression_ratio": 1.6428571428571428, "no_speech_prob": 0.0675305724143982}, {"id": 131, "seek": 68404, "start": 684.3199999999999, "end": 689.24, "text": " However, as you saw from the tedious method by which we encode relatively standard features", "tokens": [50378, 2908, 11, 382, 291, 1866, 490, 264, 38284, 3170, 538, 597, 321, 2058, 1429, 7226, 3832, 4122, 50624], "temperature": 0.0, "avg_logprob": -0.1526746645078554, "compression_ratio": 1.6408163265306122, "no_speech_prob": 0.0029806692618876696}, {"id": 132, "seek": 68404, "start": 689.24, "end": 697.16, "text": " into the calculus, the lambda calculus is certainly not suited for any real world programming.", "tokens": [50624, 666, 264, 33400, 11, 264, 13607, 33400, 307, 3297, 406, 24736, 337, 604, 957, 1002, 9410, 13, 51020], "temperature": 0.0, "avg_logprob": -0.1526746645078554, "compression_ratio": 1.6408163265306122, "no_speech_prob": 0.0029806692618876696}, {"id": 133, "seek": 68404, "start": 697.16, "end": 700.0799999999999, "text": " So what was the point in all of this?", "tokens": [51020, 407, 437, 390, 264, 935, 294, 439, 295, 341, 30, 51166], "temperature": 0.0, "avg_logprob": -0.1526746645078554, "compression_ratio": 1.6408163265306122, "no_speech_prob": 0.0029806692618876696}, {"id": 134, "seek": 68404, "start": 700.0799999999999, "end": 705.52, "text": " Well, for starters, once we've tediously encoded concepts into the calculus, we can", "tokens": [51166, 1042, 11, 337, 35131, 11, 1564, 321, 600, 22337, 8994, 2058, 12340, 10392, 666, 264, 33400, 11, 321, 393, 51438], "temperature": 0.0, "avg_logprob": -0.1526746645078554, "compression_ratio": 1.6408163265306122, "no_speech_prob": 0.0029806692618876696}, {"id": 135, "seek": 68404, "start": 705.52, "end": 712.64, "text": " actually just ignore the low level implementation, and just deal with the objects themselves.", "tokens": [51438, 767, 445, 11200, 264, 2295, 1496, 11420, 11, 293, 445, 2028, 365, 264, 6565, 2969, 13, 51794], "temperature": 0.0, "avg_logprob": -0.1526746645078554, "compression_ratio": 1.6408163265306122, "no_speech_prob": 0.0029806692618876696}, {"id": 136, "seek": 71264, "start": 712.64, "end": 717.6, "text": " For example, we now know that Booleans in conditionals can be simulated, so we can just", "tokens": [50364, 1171, 1365, 11, 321, 586, 458, 300, 23351, 24008, 294, 4188, 1124, 393, 312, 41713, 11, 370, 321, 393, 445, 50612], "temperature": 0.0, "avg_logprob": -0.12137091005003298, "compression_ratio": 1.5674418604651164, "no_speech_prob": 0.00012730964226648211}, {"id": 137, "seek": 71264, "start": 717.6, "end": 725.16, "text": " deal with Boolean terms and if statements without worrying about unfolding their definitions.", "tokens": [50612, 2028, 365, 23351, 28499, 2115, 293, 498, 12363, 1553, 18788, 466, 44586, 641, 21988, 13, 50990], "temperature": 0.0, "avg_logprob": -0.12137091005003298, "compression_ratio": 1.5674418604651164, "no_speech_prob": 0.00012730964226648211}, {"id": 138, "seek": 71264, "start": 725.16, "end": 729.4399999999999, "text": " This makes programming in the lambda calculus somewhat reasonable.", "tokens": [50990, 639, 1669, 9410, 294, 264, 13607, 33400, 8344, 10585, 13, 51204], "temperature": 0.0, "avg_logprob": -0.12137091005003298, "compression_ratio": 1.5674418604651164, "no_speech_prob": 0.00012730964226648211}, {"id": 139, "seek": 71264, "start": 729.4399999999999, "end": 737.68, "text": " As an example, we can write the not function as lambda b dot if b then false, else true.", "tokens": [51204, 1018, 364, 1365, 11, 321, 393, 2464, 264, 406, 2445, 382, 13607, 272, 5893, 498, 272, 550, 7908, 11, 1646, 2074, 13, 51616], "temperature": 0.0, "avg_logprob": -0.12137091005003298, "compression_ratio": 1.5674418604651164, "no_speech_prob": 0.00012730964226648211}, {"id": 140, "seek": 73768, "start": 737.68, "end": 744.4399999999999, "text": " And of this absolute mess if we unfold all of the definitions.", "tokens": [50364, 400, 295, 341, 8236, 2082, 498, 321, 17980, 439, 295, 264, 21988, 13, 50702], "temperature": 0.0, "avg_logprob": -0.12207810290448078, "compression_ratio": 1.5276381909547738, "no_speech_prob": 0.0006986580556258559}, {"id": 141, "seek": 73768, "start": 744.4399999999999, "end": 754.1999999999999, "text": " Given that we can also encode numbers, recursion, and data types like pairs, I hope you can", "tokens": [50702, 18600, 300, 321, 393, 611, 2058, 1429, 3547, 11, 20560, 313, 11, 293, 1412, 3467, 411, 15494, 11, 286, 1454, 291, 393, 51190], "temperature": 0.0, "avg_logprob": -0.12207810290448078, "compression_ratio": 1.5276381909547738, "no_speech_prob": 0.0006986580556258559}, {"id": 142, "seek": 73768, "start": 754.1999999999999, "end": 758.8, "text": " start to see the power of this miniature programming language.", "tokens": [51190, 722, 281, 536, 264, 1347, 295, 341, 34674, 9410, 2856, 13, 51420], "temperature": 0.0, "avg_logprob": -0.12207810290448078, "compression_ratio": 1.5276381909547738, "no_speech_prob": 0.0006986580556258559}, {"id": 143, "seek": 73768, "start": 758.8, "end": 763.5999999999999, "text": " I implore you to study how these concepts can be encoded, but instead, I'd really like", "tokens": [51420, 286, 8484, 418, 291, 281, 2979, 577, 613, 10392, 393, 312, 2058, 12340, 11, 457, 2602, 11, 286, 1116, 534, 411, 51660], "temperature": 0.0, "avg_logprob": -0.12207810290448078, "compression_ratio": 1.5276381909547738, "no_speech_prob": 0.0006986580556258559}, {"id": 144, "seek": 76360, "start": 763.6, "end": 769.0, "text": " to focus on the implications of our newfound mathematical programming language.", "tokens": [50364, 281, 1879, 322, 264, 16602, 295, 527, 777, 17493, 18894, 9410, 2856, 13, 50634], "temperature": 0.0, "avg_logprob": -0.10750379870014806, "compression_ratio": 1.7261904761904763, "no_speech_prob": 0.12585197389125824}, {"id": 145, "seek": 76360, "start": 769.0, "end": 773.64, "text": " We set out trying to find a simple and easy programming language that we can learn instead", "tokens": [50634, 492, 992, 484, 1382, 281, 915, 257, 2199, 293, 1858, 9410, 2856, 300, 321, 393, 1466, 2602, 50866], "temperature": 0.0, "avg_logprob": -0.10750379870014806, "compression_ratio": 1.7261904761904763, "no_speech_prob": 0.12585197389125824}, {"id": 146, "seek": 76360, "start": 773.64, "end": 776.52, "text": " of more verbose and intricate languages.", "tokens": [50866, 295, 544, 9595, 541, 293, 38015, 8650, 13, 51010], "temperature": 0.0, "avg_logprob": -0.10750379870014806, "compression_ratio": 1.7261904761904763, "no_speech_prob": 0.12585197389125824}, {"id": 147, "seek": 76360, "start": 776.52, "end": 780.9200000000001, "text": " But instead, we've stumbled across something far more profound.", "tokens": [51010, 583, 2602, 11, 321, 600, 36668, 2108, 746, 1400, 544, 14382, 13, 51230], "temperature": 0.0, "avg_logprob": -0.10750379870014806, "compression_ratio": 1.7261904761904763, "no_speech_prob": 0.12585197389125824}, {"id": 148, "seek": 76360, "start": 780.9200000000001, "end": 786.12, "text": " The lambda calculus gives us a tiny definition of what it means to compute, and because of", "tokens": [51230, 440, 13607, 33400, 2709, 505, 257, 5870, 7123, 295, 437, 309, 1355, 281, 14722, 11, 293, 570, 295, 51490], "temperature": 0.0, "avg_logprob": -0.10750379870014806, "compression_ratio": 1.7261904761904763, "no_speech_prob": 0.12585197389125824}, {"id": 149, "seek": 76360, "start": 786.12, "end": 791.88, "text": " this, allows us to study programming and computation mathematically.", "tokens": [51490, 341, 11, 4045, 505, 281, 2979, 9410, 293, 24903, 44003, 13, 51778], "temperature": 0.0, "avg_logprob": -0.10750379870014806, "compression_ratio": 1.7261904761904763, "no_speech_prob": 0.12585197389125824}, {"id": 150, "seek": 79188, "start": 791.88, "end": 797.84, "text": " My favourite example of this is introducing a simple type system to the lambda calculus.", "tokens": [50364, 1222, 10696, 1365, 295, 341, 307, 15424, 257, 2199, 2010, 1185, 281, 264, 13607, 33400, 13, 50662], "temperature": 0.0, "avg_logprob": -0.15044897927178277, "compression_ratio": 1.65, "no_speech_prob": 0.01495440024882555}, {"id": 151, "seek": 79188, "start": 797.84, "end": 801.48, "text": " As some motivation, consider our not function from earlier.", "tokens": [50662, 1018, 512, 12335, 11, 1949, 527, 406, 2445, 490, 3071, 13, 50844], "temperature": 0.0, "avg_logprob": -0.15044897927178277, "compression_ratio": 1.65, "no_speech_prob": 0.01495440024882555}, {"id": 152, "seek": 79188, "start": 801.48, "end": 808.36, "text": " Lambda b dot if b then false, else true.", "tokens": [50844, 45691, 272, 5893, 498, 272, 550, 7908, 11, 1646, 2074, 13, 51188], "temperature": 0.0, "avg_logprob": -0.15044897927178277, "compression_ratio": 1.65, "no_speech_prob": 0.01495440024882555}, {"id": 153, "seek": 79188, "start": 808.36, "end": 814.72, "text": " This function maps the input true to the output false, and the input false to the output true,", "tokens": [51188, 639, 2445, 11317, 264, 4846, 2074, 281, 264, 5598, 7908, 11, 293, 264, 4846, 7908, 281, 264, 5598, 2074, 11, 51506], "temperature": 0.0, "avg_logprob": -0.15044897927178277, "compression_ratio": 1.65, "no_speech_prob": 0.01495440024882555}, {"id": 154, "seek": 79188, "start": 814.72, "end": 818.04, "text": " essentially just swapping true and false.", "tokens": [51506, 4476, 445, 1693, 10534, 2074, 293, 7908, 13, 51672], "temperature": 0.0, "avg_logprob": -0.15044897927178277, "compression_ratio": 1.65, "no_speech_prob": 0.01495440024882555}, {"id": 155, "seek": 79188, "start": 818.04, "end": 820.76, "text": " But there is a slight subtlety here.", "tokens": [51672, 583, 456, 307, 257, 4036, 7257, 75, 2210, 510, 13, 51808], "temperature": 0.0, "avg_logprob": -0.15044897927178277, "compression_ratio": 1.65, "no_speech_prob": 0.01495440024882555}, {"id": 156, "seek": 82076, "start": 820.76, "end": 825.84, "text": " There is no actual requirement for our input to be a boolean.", "tokens": [50364, 821, 307, 572, 3539, 11695, 337, 527, 4846, 281, 312, 257, 748, 4812, 282, 13, 50618], "temperature": 0.0, "avg_logprob": -0.13115316448789655, "compression_ratio": 1.5412844036697249, "no_speech_prob": 0.00047283750609494746}, {"id": 157, "seek": 82076, "start": 825.84, "end": 834.24, "text": " Our not function apply to an input of, say, 1, beta reduces to if 1 then false, else true.", "tokens": [50618, 2621, 406, 2445, 3079, 281, 364, 4846, 295, 11, 584, 11, 502, 11, 9861, 18081, 281, 498, 502, 550, 7908, 11, 1646, 2074, 13, 51038], "temperature": 0.0, "avg_logprob": -0.13115316448789655, "compression_ratio": 1.5412844036697249, "no_speech_prob": 0.00047283750609494746}, {"id": 158, "seek": 82076, "start": 834.24, "end": 835.96, "text": " This is nonsensical.", "tokens": [51038, 639, 307, 297, 892, 694, 804, 13, 51124], "temperature": 0.0, "avg_logprob": -0.13115316448789655, "compression_ratio": 1.5412844036697249, "no_speech_prob": 0.00047283750609494746}, {"id": 159, "seek": 82076, "start": 835.96, "end": 839.88, "text": " If 1 makes no sense because 1 isn't a boolean.", "tokens": [51124, 759, 502, 1669, 572, 2020, 570, 502, 1943, 380, 257, 748, 4812, 282, 13, 51320], "temperature": 0.0, "avg_logprob": -0.13115316448789655, "compression_ratio": 1.5412844036697249, "no_speech_prob": 0.00047283750609494746}, {"id": 160, "seek": 82076, "start": 839.88, "end": 844.76, "text": " So trying to use our encodings of these concepts to reduce this further will result in a term", "tokens": [51320, 407, 1382, 281, 764, 527, 2058, 378, 1109, 295, 613, 10392, 281, 5407, 341, 3052, 486, 1874, 294, 257, 1433, 51564], "temperature": 0.0, "avg_logprob": -0.13115316448789655, "compression_ratio": 1.5412844036697249, "no_speech_prob": 0.00047283750609494746}, {"id": 161, "seek": 82076, "start": 844.76, "end": 849.3199999999999, "text": " with no real meaning.", "tokens": [51564, 365, 572, 957, 3620, 13, 51792], "temperature": 0.0, "avg_logprob": -0.13115316448789655, "compression_ratio": 1.5412844036697249, "no_speech_prob": 0.00047283750609494746}, {"id": 162, "seek": 84932, "start": 849.32, "end": 856.48, "text": " To avoid this, we can add some rules to our lambda calculus.", "tokens": [50364, 1407, 5042, 341, 11, 321, 393, 909, 512, 4474, 281, 527, 13607, 33400, 13, 50722], "temperature": 0.0, "avg_logprob": -0.13676945729689163, "compression_ratio": 1.6377551020408163, "no_speech_prob": 0.000356960081262514}, {"id": 163, "seek": 84932, "start": 856.48, "end": 862.32, "text": " We'll assign a label, called a type, to terms in the lambda calculus that make sense, which", "tokens": [50722, 492, 603, 6269, 257, 7645, 11, 1219, 257, 2010, 11, 281, 2115, 294, 264, 13607, 33400, 300, 652, 2020, 11, 597, 51014], "temperature": 0.0, "avg_logprob": -0.13676945729689163, "compression_ratio": 1.6377551020408163, "no_speech_prob": 0.000356960081262514}, {"id": 164, "seek": 84932, "start": 862.32, "end": 867.48, "text": " in our case is going to be built from the types bool for boolean values and num for", "tokens": [51014, 294, 527, 1389, 307, 516, 281, 312, 3094, 490, 264, 3467, 748, 401, 337, 748, 4812, 282, 4190, 293, 1031, 337, 51272], "temperature": 0.0, "avg_logprob": -0.13676945729689163, "compression_ratio": 1.6377551020408163, "no_speech_prob": 0.000356960081262514}, {"id": 165, "seek": 84932, "start": 867.48, "end": 869.96, "text": " numeric values.", "tokens": [51272, 7866, 299, 4190, 13, 51396], "temperature": 0.0, "avg_logprob": -0.13676945729689163, "compression_ratio": 1.6377551020408163, "no_speech_prob": 0.000356960081262514}, {"id": 166, "seek": 84932, "start": 869.96, "end": 874.6400000000001, "text": " We'll indicate the type of a term by writing the type after a colon.", "tokens": [51396, 492, 603, 13330, 264, 2010, 295, 257, 1433, 538, 3579, 264, 2010, 934, 257, 8255, 13, 51630], "temperature": 0.0, "avg_logprob": -0.13676945729689163, "compression_ratio": 1.6377551020408163, "no_speech_prob": 0.000356960081262514}, {"id": 167, "seek": 87464, "start": 874.64, "end": 882.1999999999999, "text": " So we'd write true colon bool to say that true is of type boolean.", "tokens": [50364, 407, 321, 1116, 2464, 2074, 8255, 748, 401, 281, 584, 300, 2074, 307, 295, 2010, 748, 4812, 282, 13, 50742], "temperature": 0.0, "avg_logprob": -0.11610404025302844, "compression_ratio": 1.733695652173913, "no_speech_prob": 0.0023230700753629208}, {"id": 168, "seek": 87464, "start": 882.1999999999999, "end": 888.36, "text": " Lambda abstractions have the type a arrow b, normally said as type a to b, where a is", "tokens": [50742, 45691, 12649, 626, 362, 264, 2010, 257, 11610, 272, 11, 5646, 848, 382, 2010, 257, 281, 272, 11, 689, 257, 307, 51050], "temperature": 0.0, "avg_logprob": -0.11610404025302844, "compression_ratio": 1.733695652173913, "no_speech_prob": 0.0023230700753629208}, {"id": 169, "seek": 87464, "start": 888.36, "end": 894.76, "text": " the type of its input, and b is the type of its output.", "tokens": [51050, 264, 2010, 295, 1080, 4846, 11, 293, 272, 307, 264, 2010, 295, 1080, 5598, 13, 51370], "temperature": 0.0, "avg_logprob": -0.11610404025302844, "compression_ratio": 1.733695652173913, "no_speech_prob": 0.0023230700753629208}, {"id": 170, "seek": 87464, "start": 894.76, "end": 899.56, "text": " We'll specify the type of the input by putting it next to the input variable when writing", "tokens": [51370, 492, 603, 16500, 264, 2010, 295, 264, 4846, 538, 3372, 309, 958, 281, 264, 4846, 7006, 562, 3579, 51610], "temperature": 0.0, "avg_logprob": -0.11610404025302844, "compression_ratio": 1.733695652173913, "no_speech_prob": 0.0023230700753629208}, {"id": 171, "seek": 87464, "start": 899.56, "end": 902.76, "text": " lambda abstractions.", "tokens": [51610, 13607, 12649, 626, 13, 51770], "temperature": 0.0, "avg_logprob": -0.11610404025302844, "compression_ratio": 1.733695652173913, "no_speech_prob": 0.0023230700753629208}, {"id": 172, "seek": 90276, "start": 902.76, "end": 908.12, "text": " So to finally solve our problem of nonsense terms, we'll now say that we can only apply", "tokens": [50364, 407, 281, 2721, 5039, 527, 1154, 295, 14925, 2115, 11, 321, 603, 586, 584, 300, 321, 393, 787, 3079, 50632], "temperature": 0.0, "avg_logprob": -0.11797114092894274, "compression_ratio": 1.6894977168949772, "no_speech_prob": 3.48075082001742e-05}, {"id": 173, "seek": 90276, "start": 908.12, "end": 913.76, "text": " a lambda abstraction to a term that has the same type as the one specified by its input", "tokens": [50632, 257, 13607, 37765, 281, 257, 1433, 300, 575, 264, 912, 2010, 382, 264, 472, 22206, 538, 1080, 4846, 50914], "temperature": 0.0, "avg_logprob": -0.11797114092894274, "compression_ratio": 1.6894977168949772, "no_speech_prob": 3.48075082001742e-05}, {"id": 174, "seek": 90276, "start": 913.76, "end": 918.52, "text": " variable.", "tokens": [50914, 7006, 13, 51152], "temperature": 0.0, "avg_logprob": -0.11797114092894274, "compression_ratio": 1.6894977168949772, "no_speech_prob": 3.48075082001742e-05}, {"id": 175, "seek": 90276, "start": 918.52, "end": 924.6, "text": " As an example, we'd now write our not function like this, specifying that our input b is", "tokens": [51152, 1018, 364, 1365, 11, 321, 1116, 586, 2464, 527, 406, 2445, 411, 341, 11, 1608, 5489, 300, 527, 4846, 272, 307, 51456], "temperature": 0.0, "avg_logprob": -0.11797114092894274, "compression_ratio": 1.6894977168949772, "no_speech_prob": 3.48075082001742e-05}, {"id": 176, "seek": 90276, "start": 924.6, "end": 927.04, "text": " a boolean.", "tokens": [51456, 257, 748, 4812, 282, 13, 51578], "temperature": 0.0, "avg_logprob": -0.11797114092894274, "compression_ratio": 1.6894977168949772, "no_speech_prob": 3.48075082001742e-05}, {"id": 177, "seek": 90276, "start": 927.04, "end": 932.04, "text": " Since this abstraction takes a boolean and then outputs a boolean, it will have type", "tokens": [51578, 4162, 341, 37765, 2516, 257, 748, 4812, 282, 293, 550, 23930, 257, 748, 4812, 282, 11, 309, 486, 362, 2010, 51828], "temperature": 0.0, "avg_logprob": -0.11797114092894274, "compression_ratio": 1.6894977168949772, "no_speech_prob": 3.48075082001742e-05}, {"id": 178, "seek": 93204, "start": 932.04, "end": 935.4, "text": " bool to boole.", "tokens": [50364, 748, 401, 281, 748, 4812, 13, 50532], "temperature": 0.0, "avg_logprob": -0.142692316146124, "compression_ratio": 1.6564102564102565, "no_speech_prob": 0.00044420096674002707}, {"id": 179, "seek": 93204, "start": 935.4, "end": 939.76, "text": " This means that we are simply not allowed to apply this function to the term one, as", "tokens": [50532, 639, 1355, 300, 321, 366, 2935, 406, 4350, 281, 3079, 341, 2445, 281, 264, 1433, 472, 11, 382, 50750], "temperature": 0.0, "avg_logprob": -0.142692316146124, "compression_ratio": 1.6564102564102565, "no_speech_prob": 0.00044420096674002707}, {"id": 180, "seek": 93204, "start": 939.76, "end": 944.36, "text": " this has type num and not boole.", "tokens": [50750, 341, 575, 2010, 1031, 293, 406, 748, 4812, 13, 50980], "temperature": 0.0, "avg_logprob": -0.142692316146124, "compression_ratio": 1.6564102564102565, "no_speech_prob": 0.00044420096674002707}, {"id": 181, "seek": 93204, "start": 944.36, "end": 948.68, "text": " Whilst this does limit what the calculus can do, it does stop a lot of nonsense terms", "tokens": [50980, 45790, 341, 775, 4948, 437, 264, 33400, 393, 360, 11, 309, 775, 1590, 257, 688, 295, 14925, 2115, 51196], "temperature": 0.0, "avg_logprob": -0.142692316146124, "compression_ratio": 1.6564102564102565, "no_speech_prob": 0.00044420096674002707}, {"id": 182, "seek": 93204, "start": 948.68, "end": 954.0799999999999, "text": " from arising.", "tokens": [51196, 490, 44900, 13, 51466], "temperature": 0.0, "avg_logprob": -0.142692316146124, "compression_ratio": 1.6564102564102565, "no_speech_prob": 0.00044420096674002707}, {"id": 183, "seek": 93204, "start": 954.0799999999999, "end": 958.42, "text": " The version of lambda calculus with this typing system attached to it is called the simply", "tokens": [51466, 440, 3037, 295, 13607, 33400, 365, 341, 18444, 1185, 8570, 281, 309, 307, 1219, 264, 2935, 51683], "temperature": 0.0, "avg_logprob": -0.142692316146124, "compression_ratio": 1.6564102564102565, "no_speech_prob": 0.00044420096674002707}, {"id": 184, "seek": 95842, "start": 958.42, "end": 965.5, "text": " typed lambda calculus, and is very reminiscent of statically typed languages like C or Java.", "tokens": [50364, 33941, 13607, 33400, 11, 293, 307, 588, 44304, 295, 2219, 984, 33941, 8650, 411, 383, 420, 10745, 13, 50718], "temperature": 0.0, "avg_logprob": -0.128334409735176, "compression_ratio": 1.640495867768595, "no_speech_prob": 0.002472416264936328}, {"id": 185, "seek": 95842, "start": 965.5, "end": 970.42, "text": " But despite this similarity, the lambda calculus and its simply typed version was invented", "tokens": [50718, 583, 7228, 341, 32194, 11, 264, 13607, 33400, 293, 1080, 2935, 33941, 3037, 390, 14479, 50964], "temperature": 0.0, "avg_logprob": -0.128334409735176, "compression_ratio": 1.640495867768595, "no_speech_prob": 0.002472416264936328}, {"id": 186, "seek": 95842, "start": 970.42, "end": 976.5799999999999, "text": " by Alonso Church between the 1930s and 40s, before programming and even computer science", "tokens": [50964, 538, 967, 266, 539, 7882, 1296, 264, 22350, 82, 293, 3356, 82, 11, 949, 9410, 293, 754, 3820, 3497, 51272], "temperature": 0.0, "avg_logprob": -0.128334409735176, "compression_ratio": 1.640495867768595, "no_speech_prob": 0.002472416264936328}, {"id": 187, "seek": 95842, "start": 976.5799999999999, "end": 981.18, "text": " itself was being formally studied.", "tokens": [51272, 2564, 390, 885, 25983, 9454, 13, 51502], "temperature": 0.0, "avg_logprob": -0.128334409735176, "compression_ratio": 1.640495867768595, "no_speech_prob": 0.002472416264936328}, {"id": 188, "seek": 95842, "start": 981.18, "end": 986.16, "text": " As a side note, Alonso Church was actually the doctoral advisor of the father of computer", "tokens": [51502, 1018, 257, 1252, 3637, 11, 967, 266, 539, 7882, 390, 767, 264, 41419, 19161, 295, 264, 3086, 295, 3820, 51751], "temperature": 0.0, "avg_logprob": -0.128334409735176, "compression_ratio": 1.640495867768595, "no_speech_prob": 0.002472416264936328}, {"id": 189, "seek": 98616, "start": 986.16, "end": 991.04, "text": " science, Alon Turing, whose achievements have rightly earned him the status of a household", "tokens": [50364, 3497, 11, 967, 266, 314, 1345, 11, 6104, 21420, 362, 32879, 12283, 796, 264, 6558, 295, 257, 9888, 50608], "temperature": 0.0, "avg_logprob": -0.15595873012099154, "compression_ratio": 1.634453781512605, "no_speech_prob": 0.0003250297741033137}, {"id": 190, "seek": 98616, "start": 991.04, "end": 993.8, "text": " name.", "tokens": [50608, 1315, 13, 50746], "temperature": 0.0, "avg_logprob": -0.15595873012099154, "compression_ratio": 1.634453781512605, "no_speech_prob": 0.0003250297741033137}, {"id": 191, "seek": 98616, "start": 993.8, "end": 998.8399999999999, "text": " Whilst the lambda calculus has played a pivotal role in the study of programming, it has been", "tokens": [50746, 45790, 264, 13607, 33400, 575, 3737, 257, 39078, 3090, 294, 264, 2979, 295, 9410, 11, 309, 575, 668, 50998], "temperature": 0.0, "avg_logprob": -0.15595873012099154, "compression_ratio": 1.634453781512605, "no_speech_prob": 0.0003250297741033137}, {"id": 192, "seek": 98616, "start": 998.8399999999999, "end": 1005.1999999999999, "text": " equally as important in the field of mathematical logic, as we can define systems of logic using", "tokens": [50998, 12309, 382, 1021, 294, 264, 2519, 295, 18894, 9952, 11, 382, 321, 393, 6964, 3652, 295, 9952, 1228, 51316], "temperature": 0.0, "avg_logprob": -0.15595873012099154, "compression_ratio": 1.634453781512605, "no_speech_prob": 0.0003250297741033137}, {"id": 193, "seek": 98616, "start": 1005.1999999999999, "end": 1007.1999999999999, "text": " the calculus.", "tokens": [51316, 264, 33400, 13, 51416], "temperature": 0.0, "avg_logprob": -0.15595873012099154, "compression_ratio": 1.634453781512605, "no_speech_prob": 0.0003250297741033137}, {"id": 194, "seek": 98616, "start": 1007.1999999999999, "end": 1013.8, "text": " In fact, our simply typed lambda calculus has a particularly interesting interpretation", "tokens": [51416, 682, 1186, 11, 527, 2935, 33941, 13607, 33400, 575, 257, 4098, 1880, 14174, 51746], "temperature": 0.0, "avg_logprob": -0.15595873012099154, "compression_ratio": 1.634453781512605, "no_speech_prob": 0.0003250297741033137}, {"id": 195, "seek": 101380, "start": 1013.8, "end": 1016.88, "text": " in terms of logic.", "tokens": [50364, 294, 2115, 295, 9952, 13, 50518], "temperature": 0.0, "avg_logprob": -0.1485104006390239, "compression_ratio": 1.6445497630331753, "no_speech_prob": 0.007815276272594929}, {"id": 196, "seek": 101380, "start": 1016.88, "end": 1021.8399999999999, "text": " Let's say that the types in our calculus should be interpreted as propositions, that", "tokens": [50518, 961, 311, 584, 300, 264, 3467, 294, 527, 33400, 820, 312, 26749, 382, 7532, 2451, 11, 300, 50766], "temperature": 0.0, "avg_logprob": -0.1485104006390239, "compression_ratio": 1.6445497630331753, "no_speech_prob": 0.007815276272594929}, {"id": 197, "seek": 101380, "start": 1021.8399999999999, "end": 1026.84, "text": " being statements which are either true or false.", "tokens": [50766, 885, 12363, 597, 366, 2139, 2074, 420, 7908, 13, 51016], "temperature": 0.0, "avg_logprob": -0.1485104006390239, "compression_ratio": 1.6445497630331753, "no_speech_prob": 0.007815276272594929}, {"id": 198, "seek": 101380, "start": 1026.84, "end": 1031.3999999999999, "text": " Then we'll say that each term in the lambda calculus should be seen as a proof that the", "tokens": [51016, 1396, 321, 603, 584, 300, 1184, 1433, 294, 264, 13607, 33400, 820, 312, 1612, 382, 257, 8177, 300, 264, 51244], "temperature": 0.0, "avg_logprob": -0.1485104006390239, "compression_ratio": 1.6445497630331753, "no_speech_prob": 0.007815276272594929}, {"id": 199, "seek": 101380, "start": 1031.3999999999999, "end": 1037.4199999999998, "text": " proposition corresponding to that term's type is true.", "tokens": [51244, 24830, 11760, 281, 300, 1433, 311, 2010, 307, 2074, 13, 51545], "temperature": 0.0, "avg_logprob": -0.1485104006390239, "compression_ratio": 1.6445497630331753, "no_speech_prob": 0.007815276272594929}, {"id": 200, "seek": 101380, "start": 1037.4199999999998, "end": 1042.0, "text": " As an example, suppose we have an arbitrary type A.", "tokens": [51545, 1018, 364, 1365, 11, 7297, 321, 362, 364, 23211, 2010, 316, 13, 51774], "temperature": 0.0, "avg_logprob": -0.1485104006390239, "compression_ratio": 1.6445497630331753, "no_speech_prob": 0.007815276272594929}, {"id": 201, "seek": 104200, "start": 1042.0, "end": 1047.76, "text": " We can interpret this as corresponding to a particular proposition.", "tokens": [50364, 492, 393, 7302, 341, 382, 11760, 281, 257, 1729, 24830, 13, 50652], "temperature": 0.0, "avg_logprob": -0.09886970886817345, "compression_ratio": 1.532994923857868, "no_speech_prob": 1.4510402252199128e-05}, {"id": 202, "seek": 104200, "start": 1047.76, "end": 1053.52, "text": " Then we'll think of a term of type A as a proof that A is true.", "tokens": [50652, 1396, 321, 603, 519, 295, 257, 1433, 295, 2010, 316, 382, 257, 8177, 300, 316, 307, 2074, 13, 50940], "temperature": 0.0, "avg_logprob": -0.09886970886817345, "compression_ratio": 1.532994923857868, "no_speech_prob": 1.4510402252199128e-05}, {"id": 203, "seek": 104200, "start": 1053.52, "end": 1059.96, "text": " If no such term exists, then A is false.", "tokens": [50940, 759, 572, 1270, 1433, 8198, 11, 550, 316, 307, 7908, 13, 51262], "temperature": 0.0, "avg_logprob": -0.09886970886817345, "compression_ratio": 1.532994923857868, "no_speech_prob": 1.4510402252199128e-05}, {"id": 204, "seek": 104200, "start": 1059.96, "end": 1063.38, "text": " This seems rather strange, but bear with me.", "tokens": [51262, 639, 2544, 2831, 5861, 11, 457, 6155, 365, 385, 13, 51433], "temperature": 0.0, "avg_logprob": -0.09886970886817345, "compression_ratio": 1.532994923857868, "no_speech_prob": 1.4510402252199128e-05}, {"id": 205, "seek": 104200, "start": 1063.38, "end": 1068.2, "text": " If we use this interpretation of our simply typed lambda calculus, then we find that", "tokens": [51433, 759, 321, 764, 341, 14174, 295, 527, 2935, 33941, 13607, 33400, 11, 550, 321, 915, 300, 51674], "temperature": 0.0, "avg_logprob": -0.09886970886817345, "compression_ratio": 1.532994923857868, "no_speech_prob": 1.4510402252199128e-05}, {"id": 206, "seek": 106820, "start": 1068.28, "end": 1075.04, "text": " the type of lambda abstractions, that being A to B for some arbitrary types A and B, corresponds", "tokens": [50368, 264, 2010, 295, 13607, 12649, 626, 11, 300, 885, 316, 281, 363, 337, 512, 23211, 3467, 316, 293, 363, 11, 23249, 50706], "temperature": 0.0, "avg_logprob": -0.10644943412693067, "compression_ratio": 1.7671957671957672, "no_speech_prob": 0.004198567010462284}, {"id": 207, "seek": 106820, "start": 1075.04, "end": 1079.04, "text": " to the proposition A implies B.", "tokens": [50706, 281, 264, 24830, 316, 18779, 363, 13, 50906], "temperature": 0.0, "avg_logprob": -0.10644943412693067, "compression_ratio": 1.7671957671957672, "no_speech_prob": 0.004198567010462284}, {"id": 208, "seek": 106820, "start": 1079.04, "end": 1085.04, "text": " The proposition A implies B is simply stating that if I can prove A is true, then I know", "tokens": [50906, 440, 24830, 316, 18779, 363, 307, 2935, 26688, 300, 498, 286, 393, 7081, 316, 307, 2074, 11, 550, 286, 458, 51206], "temperature": 0.0, "avg_logprob": -0.10644943412693067, "compression_ratio": 1.7671957671957672, "no_speech_prob": 0.004198567010462284}, {"id": 209, "seek": 106820, "start": 1085.04, "end": 1089.1200000000001, "text": " that B must be true as well.", "tokens": [51206, 300, 363, 1633, 312, 2074, 382, 731, 13, 51410], "temperature": 0.0, "avg_logprob": -0.10644943412693067, "compression_ratio": 1.7671957671957672, "no_speech_prob": 0.004198567010462284}, {"id": 210, "seek": 106820, "start": 1089.1200000000001, "end": 1094.1200000000001, "text": " For example, if A was the proposition that it's raining, and B was the proposition that", "tokens": [51410, 1171, 1365, 11, 498, 316, 390, 264, 24830, 300, 309, 311, 18441, 11, 293, 363, 390, 264, 24830, 300, 51660], "temperature": 0.0, "avg_logprob": -0.10644943412693067, "compression_ratio": 1.7671957671957672, "no_speech_prob": 0.004198567010462284}, {"id": 211, "seek": 109412, "start": 1094.12, "end": 1100.7199999999998, "text": " the ground is wet, then the proposition A implies B would be, if it is raining, then", "tokens": [50364, 264, 2727, 307, 6630, 11, 550, 264, 24830, 316, 18779, 363, 576, 312, 11, 498, 309, 307, 18441, 11, 550, 50694], "temperature": 0.0, "avg_logprob": -0.12678089920355348, "compression_ratio": 1.791044776119403, "no_speech_prob": 0.0007553814211860299}, {"id": 212, "seek": 109412, "start": 1100.7199999999998, "end": 1103.76, "text": " the ground is wet.", "tokens": [50694, 264, 2727, 307, 6630, 13, 50846], "temperature": 0.0, "avg_logprob": -0.12678089920355348, "compression_ratio": 1.791044776119403, "no_speech_prob": 0.0007553814211860299}, {"id": 213, "seek": 109412, "start": 1103.76, "end": 1109.1999999999998, "text": " If we assume that this implication is true, then if I could prove that it was raining,", "tokens": [50846, 759, 321, 6552, 300, 341, 37814, 307, 2074, 11, 550, 498, 286, 727, 7081, 300, 309, 390, 18441, 11, 51118], "temperature": 0.0, "avg_logprob": -0.12678089920355348, "compression_ratio": 1.791044776119403, "no_speech_prob": 0.0007553814211860299}, {"id": 214, "seek": 109412, "start": 1109.1999999999998, "end": 1114.6, "text": " I would also know that the ground is wet.", "tokens": [51118, 286, 576, 611, 458, 300, 264, 2727, 307, 6630, 13, 51388], "temperature": 0.0, "avg_logprob": -0.12678089920355348, "compression_ratio": 1.791044776119403, "no_speech_prob": 0.0007553814211860299}, {"id": 215, "seek": 109412, "start": 1114.6, "end": 1117.6399999999999, "text": " So how does this play out in our calculus?", "tokens": [51388, 407, 577, 775, 341, 862, 484, 294, 527, 33400, 30, 51540], "temperature": 0.0, "avg_logprob": -0.12678089920355348, "compression_ratio": 1.791044776119403, "no_speech_prob": 0.0007553814211860299}, {"id": 216, "seek": 109412, "start": 1117.6399999999999, "end": 1124.04, "text": " Let's take two types, A and B, then the proposition A implies B is equivalent to the", "tokens": [51540, 961, 311, 747, 732, 3467, 11, 316, 293, 363, 11, 550, 264, 24830, 316, 18779, 363, 307, 10344, 281, 264, 51860], "temperature": 0.0, "avg_logprob": -0.12678089920355348, "compression_ratio": 1.791044776119403, "no_speech_prob": 0.0007553814211860299}, {"id": 217, "seek": 112404, "start": 1124.04, "end": 1127.48, "text": " type A to B.", "tokens": [50364, 2010, 316, 281, 363, 13, 50536], "temperature": 0.0, "avg_logprob": -0.1504924178123474, "compression_ratio": 1.675, "no_speech_prob": 0.0010986648267135024}, {"id": 218, "seek": 112404, "start": 1127.48, "end": 1135.68, "text": " Let's suppose that A was true, that is, there exists some term N of type A.", "tokens": [50536, 961, 311, 7297, 300, 316, 390, 2074, 11, 300, 307, 11, 456, 8198, 512, 1433, 426, 295, 2010, 316, 13, 50946], "temperature": 0.0, "avg_logprob": -0.1504924178123474, "compression_ratio": 1.675, "no_speech_prob": 0.0010986648267135024}, {"id": 219, "seek": 112404, "start": 1135.68, "end": 1141.56, "text": " If we also suppose that A implies B was true, then there must exist some term of type A", "tokens": [50946, 759, 321, 611, 7297, 300, 316, 18779, 363, 390, 2074, 11, 550, 456, 1633, 2514, 512, 1433, 295, 2010, 316, 51240], "temperature": 0.0, "avg_logprob": -0.1504924178123474, "compression_ratio": 1.675, "no_speech_prob": 0.0010986648267135024}, {"id": 220, "seek": 112404, "start": 1141.56, "end": 1144.12, "text": " to B.", "tokens": [51240, 281, 363, 13, 51368], "temperature": 0.0, "avg_logprob": -0.1504924178123474, "compression_ratio": 1.675, "no_speech_prob": 0.0010986648267135024}, {"id": 221, "seek": 112404, "start": 1144.12, "end": 1150.12, "text": " This must be a lambda abstraction of the form lambda x dot m, where the input x is of", "tokens": [51368, 639, 1633, 312, 257, 13607, 37765, 295, 264, 1254, 13607, 2031, 5893, 275, 11, 689, 264, 4846, 2031, 307, 295, 51668], "temperature": 0.0, "avg_logprob": -0.1504924178123474, "compression_ratio": 1.675, "no_speech_prob": 0.0010986648267135024}, {"id": 222, "seek": 115012, "start": 1150.12, "end": 1154.52, "text": " type A and the output m is of type B.", "tokens": [50364, 2010, 316, 293, 264, 5598, 275, 307, 295, 2010, 363, 13, 50584], "temperature": 0.0, "avg_logprob": -0.14383401473363241, "compression_ratio": 1.6794258373205742, "no_speech_prob": 0.0047549600712955}, {"id": 223, "seek": 115012, "start": 1154.52, "end": 1162.6399999999999, "text": " Now, A implies B is true, and we know that A is true, so we know that logically, B must", "tokens": [50584, 823, 11, 316, 18779, 363, 307, 2074, 11, 293, 321, 458, 300, 316, 307, 2074, 11, 370, 321, 458, 300, 38887, 11, 363, 1633, 50990], "temperature": 0.0, "avg_logprob": -0.14383401473363241, "compression_ratio": 1.6794258373205742, "no_speech_prob": 0.0047549600712955}, {"id": 224, "seek": 115012, "start": 1162.6399999999999, "end": 1164.04, "text": " be true as well.", "tokens": [50990, 312, 2074, 382, 731, 13, 51060], "temperature": 0.0, "avg_logprob": -0.14383401473363241, "compression_ratio": 1.6794258373205742, "no_speech_prob": 0.0047549600712955}, {"id": 225, "seek": 115012, "start": 1164.04, "end": 1169.1599999999999, "text": " We'll separate the propositions we're assuming to be true, and the logical conclusions", "tokens": [51060, 492, 603, 4994, 264, 7532, 2451, 321, 434, 11926, 281, 312, 2074, 11, 293, 264, 14978, 22865, 51316], "temperature": 0.0, "avg_logprob": -0.14383401473363241, "compression_ratio": 1.6794258373205742, "no_speech_prob": 0.0047549600712955}, {"id": 226, "seek": 115012, "start": 1169.1599999999999, "end": 1172.8, "text": " to these assumptions with a line.", "tokens": [51316, 281, 613, 17695, 365, 257, 1622, 13, 51498], "temperature": 0.0, "avg_logprob": -0.14383401473363241, "compression_ratio": 1.6794258373205742, "no_speech_prob": 0.0047549600712955}, {"id": 227, "seek": 115012, "start": 1172.8, "end": 1177.4799999999998, "text": " For our correspondence to work, then, we need to be able to use this lambda abstraction", "tokens": [51498, 1171, 527, 38135, 281, 589, 11, 550, 11, 321, 643, 281, 312, 1075, 281, 764, 341, 13607, 37765, 51732], "temperature": 0.0, "avg_logprob": -0.14383401473363241, "compression_ratio": 1.6794258373205742, "no_speech_prob": 0.0047549600712955}, {"id": 228, "seek": 117748, "start": 1177.48, "end": 1183.04, "text": " and our term N to create a term of type B.", "tokens": [50364, 293, 527, 1433, 426, 281, 1884, 257, 1433, 295, 2010, 363, 13, 50642], "temperature": 0.0, "avg_logprob": -0.15013250072350662, "compression_ratio": 1.7624309392265194, "no_speech_prob": 0.0005702967755496502}, {"id": 229, "seek": 117748, "start": 1183.04, "end": 1188.28, "text": " The key here is noticing that we can apply our lambda abstraction to N, because N is", "tokens": [50642, 440, 2141, 510, 307, 21814, 300, 321, 393, 3079, 527, 13607, 37765, 281, 426, 11, 570, 426, 307, 50904], "temperature": 0.0, "avg_logprob": -0.15013250072350662, "compression_ratio": 1.7624309392265194, "no_speech_prob": 0.0005702967755496502}, {"id": 230, "seek": 117748, "start": 1188.28, "end": 1190.3600000000001, "text": " of type A.", "tokens": [50904, 295, 2010, 316, 13, 51008], "temperature": 0.0, "avg_logprob": -0.15013250072350662, "compression_ratio": 1.7624309392265194, "no_speech_prob": 0.0005702967755496502}, {"id": 231, "seek": 117748, "start": 1190.3600000000001, "end": 1196.56, "text": " Crucially, we know that this has type B as the lambda abstraction outputs terms of type", "tokens": [51008, 13586, 1909, 11, 321, 458, 300, 341, 575, 2010, 363, 382, 264, 13607, 37765, 23930, 2115, 295, 2010, 51318], "temperature": 0.0, "avg_logprob": -0.15013250072350662, "compression_ratio": 1.7624309392265194, "no_speech_prob": 0.0005702967755496502}, {"id": 232, "seek": 117748, "start": 1196.56, "end": 1198.76, "text": " B.", "tokens": [51318, 363, 13, 51428], "temperature": 0.0, "avg_logprob": -0.15013250072350662, "compression_ratio": 1.7624309392265194, "no_speech_prob": 0.0005702967755496502}, {"id": 233, "seek": 117748, "start": 1198.76, "end": 1204.84, "text": " As we can find a term of type B, we know that the proposition corresponding to B is true,", "tokens": [51428, 1018, 321, 393, 915, 257, 1433, 295, 2010, 363, 11, 321, 458, 300, 264, 24830, 11760, 281, 363, 307, 2074, 11, 51732], "temperature": 0.0, "avg_logprob": -0.15013250072350662, "compression_ratio": 1.7624309392265194, "no_speech_prob": 0.0005702967755496502}, {"id": 234, "seek": 120484, "start": 1205.0, "end": 1209.0, "text": " just as we expected it to be.", "tokens": [50372, 445, 382, 321, 5176, 309, 281, 312, 13, 50572], "temperature": 0.0, "avg_logprob": -0.1121077333177839, "compression_ratio": 1.5402843601895735, "no_speech_prob": 0.009266754612326622}, {"id": 235, "seek": 120484, "start": 1209.0, "end": 1215.1999999999998, "text": " This astounding relationship between propositions and types is called the Curry-Howard correspondence", "tokens": [50572, 639, 5357, 24625, 2480, 1296, 7532, 2451, 293, 3467, 307, 1219, 264, 34789, 12, 6462, 515, 38135, 50882], "temperature": 0.0, "avg_logprob": -0.1121077333177839, "compression_ratio": 1.5402843601895735, "no_speech_prob": 0.009266754612326622}, {"id": 236, "seek": 120484, "start": 1215.1999999999998, "end": 1219.48, "text": " and has some fascinating implications.", "tokens": [50882, 293, 575, 512, 10343, 16602, 13, 51096], "temperature": 0.0, "avg_logprob": -0.1121077333177839, "compression_ratio": 1.5402843601895735, "no_speech_prob": 0.009266754612326622}, {"id": 237, "seek": 120484, "start": 1219.48, "end": 1224.1599999999999, "text": " If we build a programming language with this in mind, we can actually use this correspondence", "tokens": [51096, 759, 321, 1322, 257, 9410, 2856, 365, 341, 294, 1575, 11, 321, 393, 767, 764, 341, 38135, 51330], "temperature": 0.0, "avg_logprob": -0.1121077333177839, "compression_ratio": 1.5402843601895735, "no_speech_prob": 0.009266754612326622}, {"id": 238, "seek": 120484, "start": 1224.1599999999999, "end": 1230.08, "text": " to explicitly write mathematical proofs using computer code.", "tokens": [51330, 281, 20803, 2464, 18894, 8177, 82, 1228, 3820, 3089, 13, 51626], "temperature": 0.0, "avg_logprob": -0.1121077333177839, "compression_ratio": 1.5402843601895735, "no_speech_prob": 0.009266754612326622}, {"id": 239, "seek": 123008, "start": 1230.08, "end": 1237.08, "text": " These languages are called proof assistants, and popular ones include Lean and Agda.", "tokens": [50364, 1981, 8650, 366, 1219, 8177, 34949, 11, 293, 3743, 2306, 4090, 49303, 293, 2725, 2675, 13, 50714], "temperature": 0.0, "avg_logprob": -0.1704233255279198, "compression_ratio": 1.5924369747899159, "no_speech_prob": 0.000720813637599349}, {"id": 240, "seek": 123008, "start": 1238.0, "end": 1242.6399999999999, "text": " This Lean program here, for example, is a proof that there are infinitely many prime", "tokens": [50760, 639, 49303, 1461, 510, 11, 337, 1365, 11, 307, 257, 8177, 300, 456, 366, 36227, 867, 5835, 50992], "temperature": 0.0, "avg_logprob": -0.1704233255279198, "compression_ratio": 1.5924369747899159, "no_speech_prob": 0.000720813637599349}, {"id": 241, "seek": 123008, "start": 1242.6399999999999, "end": 1247.52, "text": " numbers and we know that it's correct since it type checks.", "tokens": [50992, 3547, 293, 321, 458, 300, 309, 311, 3006, 1670, 309, 2010, 13834, 13, 51236], "temperature": 0.0, "avg_logprob": -0.1704233255279198, "compression_ratio": 1.5924369747899159, "no_speech_prob": 0.000720813637599349}, {"id": 242, "seek": 123008, "start": 1247.52, "end": 1252.6399999999999, "text": " As this area of research develops, who knows, in the future mathematics might not be taught", "tokens": [51236, 1018, 341, 1859, 295, 2132, 25453, 11, 567, 3255, 11, 294, 264, 2027, 18666, 1062, 406, 312, 5928, 51492], "temperature": 0.0, "avg_logprob": -0.1704233255279198, "compression_ratio": 1.5924369747899159, "no_speech_prob": 0.000720813637599349}, {"id": 243, "seek": 123008, "start": 1252.6399999999999, "end": 1258.04, "text": " with pen and paper, but rather with a keyboard and mouse.", "tokens": [51492, 365, 3435, 293, 3035, 11, 457, 2831, 365, 257, 10186, 293, 9719, 13, 51762], "temperature": 0.0, "avg_logprob": -0.1704233255279198, "compression_ratio": 1.5924369747899159, "no_speech_prob": 0.000720813637599349}, {"id": 244, "seek": 125804, "start": 1259.0, "end": 1261.36, "text": " Well, that was quite the journey.", "tokens": [50412, 1042, 11, 300, 390, 1596, 264, 4671, 13, 50530], "temperature": 0.0, "avg_logprob": -0.11011161804199218, "compression_ratio": 1.6679245283018869, "no_speech_prob": 0.0001233916700584814}, {"id": 245, "seek": 125804, "start": 1261.36, "end": 1265.8799999999999, "text": " We started out by exploring the essence of functions, and whilst it certainly isn't", "tokens": [50530, 492, 1409, 484, 538, 12736, 264, 12801, 295, 6828, 11, 293, 18534, 309, 3297, 1943, 380, 50756], "temperature": 0.0, "avg_logprob": -0.11011161804199218, "compression_ratio": 1.6679245283018869, "no_speech_prob": 0.0001233916700584814}, {"id": 246, "seek": 125804, "start": 1265.8799999999999, "end": 1270.6399999999999, "text": " a serious contender for modern programming languages, it has allowed us to explore a", "tokens": [50756, 257, 3156, 660, 3216, 337, 4363, 9410, 8650, 11, 309, 575, 4350, 505, 281, 6839, 257, 50994], "temperature": 0.0, "avg_logprob": -0.11011161804199218, "compression_ratio": 1.6679245283018869, "no_speech_prob": 0.0001233916700584814}, {"id": 247, "seek": 125804, "start": 1270.6399999999999, "end": 1275.92, "text": " rich theory of theoretical computer science and mathematical logic, whilst giving us the", "tokens": [50994, 4593, 5261, 295, 20864, 3820, 3497, 293, 18894, 9952, 11, 18534, 2902, 505, 264, 51258], "temperature": 0.0, "avg_logprob": -0.11011161804199218, "compression_ratio": 1.6679245283018869, "no_speech_prob": 0.0001233916700584814}, {"id": 248, "seek": 125804, "start": 1275.92, "end": 1281.48, "text": " ability to reason about computer programs and code rigorously.", "tokens": [51258, 3485, 281, 1778, 466, 3820, 4268, 293, 3089, 42191, 5098, 13, 51536], "temperature": 0.0, "avg_logprob": -0.11011161804199218, "compression_ratio": 1.6679245283018869, "no_speech_prob": 0.0001233916700584814}, {"id": 249, "seek": 125804, "start": 1281.48, "end": 1286.6, "text": " Who knew that a tiny little system of formal logic would have so many implications even", "tokens": [51536, 2102, 2586, 300, 257, 5870, 707, 1185, 295, 9860, 9952, 576, 362, 370, 867, 16602, 754, 51792], "temperature": 0.0, "avg_logprob": -0.11011161804199218, "compression_ratio": 1.6679245283018869, "no_speech_prob": 0.0001233916700584814}, {"id": 250, "seek": 128660, "start": 1286.6399999999999, "end": 1292.8799999999999, "text": " a century after its creation.", "tokens": [50366, 257, 4901, 934, 1080, 8016, 13, 50678], "temperature": 0.0, "avg_logprob": -0.21496670586722239, "compression_ratio": 1.436046511627907, "no_speech_prob": 0.13094699382781982}, {"id": 251, "seek": 128660, "start": 1292.8799999999999, "end": 1297.6399999999999, "text": " If this topic interests you, I would encourage you to subscribe, leave a like, and browse", "tokens": [50678, 759, 341, 4829, 8847, 291, 11, 286, 576, 5373, 291, 281, 3022, 11, 1856, 257, 411, 11, 293, 31442, 50916], "temperature": 0.0, "avg_logprob": -0.21496670586722239, "compression_ratio": 1.436046511627907, "no_speech_prob": 0.13094699382781982}, {"id": 252, "seek": 128660, "start": 1297.6399999999999, "end": 1303.6, "text": " other videos on this channel for similar explorations of mathematics and theoretical computer science.", "tokens": [50916, 661, 2145, 322, 341, 2269, 337, 2531, 24765, 763, 295, 18666, 293, 20864, 3820, 3497, 13, 51214], "temperature": 0.0, "avg_logprob": -0.21496670586722239, "compression_ratio": 1.436046511627907, "no_speech_prob": 0.13094699382781982}, {"id": 253, "seek": 128660, "start": 1303.6, "end": 1305.0, "text": " But until then, goodbye.", "tokens": [51214, 583, 1826, 550, 11, 12084, 13, 51284], "temperature": 0.0, "avg_logprob": -0.21496670586722239, "compression_ratio": 1.436046511627907, "no_speech_prob": 0.13094699382781982}], "language": "en"}