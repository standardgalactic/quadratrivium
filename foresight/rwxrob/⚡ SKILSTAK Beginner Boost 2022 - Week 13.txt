Start recording. All right, we're recording for the beginner boost today. As you can tell, I am very casual today
I am supposed to clean my room and I've been playing all weekend and went out and had sushi and watched jazz last night and
Before that went to the art show and stuff. So that's on the VODs
What are we doing today though? What do you hear? What are you here?
You're here because you want to know how to configure your dot files and that is what we're gonna do week 13
What an appropriate number
To do your Linux dot files. And so we're gonna talk about well, what what is the dot file?
Where's the name come from what it what which ones do I care about how many of them are there?
What's the standard and this is an essential part of understanding Linux?
Or Unix, you know
The Unix standard does sometimes apply but not not always and so we're gonna we're gonna go over all that
So the first thing I'm gonna do and we already did this like four or five weeks ago, right?
We we went through kind of like a speed pace
We went through all the configuration files just to kind of talk about the file system
We were talking about the organization of the overall file system of Linux and we really don't have other than that
Dave or we kind of went through that. We really don't want to spend a lot of time explaining to you
What every directory in all of Linux is for?
That wouldn't be a boost that would be you know a full whatever, you know
Comprehensive coverage of the whole thing. So we're not gonna do that
But we are gonna talk about everything in your home directory and that's super important
We did finish bash coding scripting yesterday or last not yesterday, but last time
so
And that was a prerequisite you really can't do any configuration until you know how to write the code
So one of the best ways to get practice with with bash is to actually write the bash
Configuration file, which is also written in bash and so we're gonna jump right in and talk about all that
We are gonna go for four hours today. So we'll be taking breaks as we go, but but beyond bash. So
Let's talk about the specific files. We're gonna cover. Okay, so we're gonna say we're gonna do
shell
bash
Shell configuration and we will talk about how to configure other shells a little bit
Just so you can know if you like around a Mac you see stuff
It's different, you know why which defaults to Z shell we've already, you know talked about that
We've already bashed Z shell enough
And we already know how to use them we did that we covered that y'all should know that so we're gonna talk about
them configuration and
We're gonna talk about
Actually, we're gonna do X
slash
Vi
Slash
Vim
Configuration we are not gonna do anything besides that
We are gonna do T-Mux configuration. So we covered T-Mux utilization
But we didn't cover T-Mux configuration very much and
And
So these are the things that kind of go together bash vi T-Mux and
We will configure a few other things
So like your scripts directory
right and
So you can start writing scripts and you know use them and thing and what else we need to do
We probably will do links and or w3m
So you can use those
And
We already talked about that but we're gonna talk about after that and
I mean once you have those things you're pretty much gonna have everything on the terminal that you need and
The real important ones are these three the bash vi and T-Mux
Because those are gonna give you files that you can transfer as a single file each one a single file
into
Any system that you're ever using so if you get on a container, and I'll show you how to do that using SSH
We did do some SSH configurations. So we should probably put that in there
I
Mean I think you already have that but we should refer to that. So it's really important that we talk about that one for security purposes
We're not gonna be doing GPG today. Okay. I
Mean I don't I don't know maybe we should do GPG today
Because we have to do get up eventually, you know, we'll save GPG from when we do get up which will probably be next week
But I would I really want to get through all this today if we can because I just want all the configuration settings in here
kind of kind of talked about in one day and then
Y'all can go use it and configure your own VM. Let me just remind you
That the VM that I'm using that has all of my own configurations in it that we're going to be going over today is
in github.com
rvx-rob
boost
VM and you can install VMware player or VMware workstation pro if you want to buy it and
You can put that VM that I'm using you can use this exact same one. We've covered that already in earlier days of the boost
So but that's I'm saying that because you're gonna want to know where to get all that stuff and that's where it's at
So again, these are the things like when I when I install a system
They're the first things I put on so that everything just works, right? And
I'm we should probably talk about I
Mean there's we're not gonna talk about it. I
Want to talk about git I want to talk about github. I want to talk about a bunch of us
But we're gonna save those conversations for when we talk about those tools
I have a question for the for the group here
Should we cover and this is my style. I would do this if I were teaching in person
should we cover
Get and github before we do go programming or after
Because if we do it before
Then we can use it to do our commits to our go code as we are working through it if we do it after then
We can kind of retroactively do it
But we there's a there's a chance we're gonna lose our our code along the way. I
Think we should probably do it before but it's so it's not fun people don't like it
They you know, they just want to get coding, right?
Before would be helpful for go commits. You think before all right
Well, we'll go ahead and and and do it before I think you're right. I think we do need to do it before
All right, so that's at least you know another week of stuff that we have to do before
It's definitely not fun though. And that's why I don't I mean, you know, I
I'm gonna tell you right now being a boost and all we are not going to do. Yeah. Oh, it's absolutely safe your butt
Oh my god, it's saved me so many times. All right, so we will do that
Next week. All right, so so next week. We'll put that down here
Next week
We're gonna do I want to put these all here we're gonna do that means we're gonna have to do GPG
Let's actually save SSH for that same day and that I'll get us through this nice and fun
We'll have a fun day today and then we'll do SSH and GPG config, right?
and then we'll do get
We'll do the GH tool and
We'll do get hub and
We'll talk about we'll talk about all that that that's gonna take a full, you know, a four-hour day all by itself
So that I think that's good. Let's do that and then and then the week after that
I
Think we're pretty set to start coding after that and go
Again, the whole this is very loosey-goosey because I like to
Work with a group and see where they where they want to be and what they want to do
I've changed entire classes from from Java to go on the whims of the people in the class
That's six weeks to set up emacs. No, we're not we're not touching emacs
If you want to touch emacs or VS code or any of that you're gonna have to learn that on your own
Because I mean, you know, that's not hard to pick up that none of this is really hard to pick up if you spend time with it
But but but yeah, all right, so that's a that's kind of our goal for today
I'm gonna put this is the read me and
We're talking about configuration today not necessarily usage but
As we go we're gonna cover that as well
All right, so the first file that we need to talk about is the bash receive us
Let's talk about the home directory. So let's cd enter which takes you into your home directory
And what does the tilde mean? It's just a little bit of a review
What does the tilde mean the tilde means are in your home directory, right?
The review of the prompt this is the active username
This is the machine. I'm on
This stuff is all represented in an environment variable called ps is a ps or ps one
There's my ps one. This tells me everything. We're gonna go through these really quickly
as usual if you want a full
Explanation of bash the best place to go is the man bash and I strongly strongly encourage everybody listening to this
Including the veterans to go through all of the bash man page beginning to end at least once
Right because there's stuff in there that you may not even know exists like for example completion
You can do completion with one command instead of writing a separate shell script and people don't know this because I haven't read it
So it's not covered in any books or anything
So so there you go. You can go look at that and and know where to go to look for stuff
All right, so I am in my home directory. So if I type tree you're gonna get a lot of stuff
I don't want you to see all of that stuff. That's like all my get commits and stuff
And as you I mean, let's just do find dot
depth one
Whoops
Past must be presided. Oh
By what did I do that right is it depth I thought was depth I
Have to look at my thing you guys know about this so if you don't want to list everything. Hey, thank you for the fall
I don't remember my depth command again go look at max depth
Yeah max depth, I think it is
Max depth one. Yeah
All right, so this tells you everything that's in the current directory. Okay, so let's let's just do directories though
Let's do find dash type TD find as your friend my friends
Uh
Warning you have a global max to find the arguments type bookable options are not positional max of effects test specific specified before it as well
Okay
All right. Well, maybe I should do it like this then instead that make the warning go away. Okay, so here's everything in there
If we do a max depth of two
You can see like two layers
So, I mean, there's lots of stuff in here and we're gonna talk about what's in here, but the reason it's called dot files is
So we'll say covered
Covered
Why are they called dot files
Pipes, yeah, we did that we did pipes
Yeah, we did pipes and filters and stuff
I'm pretty sure we did that didn't we we did that last week
How to read use reading we did read IFS and all that stuff
We didn't do different the pipe file type we didn't do five-folds or anything
So why are they called dot files?
They're called off I was gonna be without and what does a dot do?
What is the dot use use initial
dot to
hide a
file or directory
So that's why we use the dot to hide things. Okay, so so normally when you're listening in here
You don't see all that stuff right if you do want to see them. What do you use?
L s dash L a
to see all hidden
Right, you could also use find and I just did that right so you could do L s dash L a
You see all your files there and you see some of them are redirects and we're gonna talk about that and that's a that's a
Way to manage your dot files. I mean we don't we're not gonna don't worry. We'll get there
But just so you know dot files means
Hidden right so that it's not shown. It's not in your face all the time
L s dash L will give you the long version L s dash a will give you just others all the files
so there's lots of them there and
The colors represent different, you know, whether they're a symbolic link or their directory or just a file
I have to be careful here because I mean I haven't put anything in there that I need to be careful of except for the SSH directory
Which we'll talk about next week
But the thing to note here is be careful
Who you know who you show
Your dot files
to
It really depends on the dot file most of the time it doesn't matter and I all of my dot files
By the way, if you want to see any of mine are in my dot directory
Which is on github so you can go in there and you can study it offline if you want to
Art of X-Rob slash dot and that includes my scripts and stuff like that. So I
Mean so how let's talk about how should I manage?
Manage my
Dodd files
So there's lots of ways to do this
I've seen streamers talk about tools that they install to help manage your dot files better and everything
I don't like any of those techniques. So my favorite technique is to
Put your dot file
Into a git repo
Which we will do next week. Okay, we're gonna create the dot file directory today
And we're gonna put our stuff in there, but and we're gonna symbolic link it and all that but we are not going
To you know, we're not we're not gonna make a git a repo for you not this week. Okay, so
See see here. I have like all my dot files and and you can choose how you want to organize them and we're gonna go through all that right now
All right, so
And I'm gonna show you how I do it
But of course you can do it however you want I've had you know
There's streamers who take strong exception to the idea of writing your own setup scripts to do your dot files
I'm like, why would you need a tool for that?
That's what shell scripting is for so I want control of it. And so I do it that way
I
Mean any there's a couple of things about the dot file organization that we need to cover before we leave this
So
Let's let's talk about that a standard
Expected right
Content I guess files and directories
And this is kind of gonna be I
Don't know how to do this
Let's make it its own section. Okay, so there
So let's let's just start start right off the bat
I'm gonna give you an overview and then we'll go in and then we'll start looking at them. Okay, so profile profile
What is profile?
right
profile is
Used this is the boost. Yep. This is a boost episode even though I'm being like chill
so
So boost I'm actually live in case you're wondering so profile is like
original
login
Script so
What is the dot profile file? Let's see how they say it
What is the stream title saying right now?
Well, yeah, let me change the stream title. I'm sorry
Yeah, let me change it. You know what I've gotten used to not doing that because these days
I don't need to change the stream title
because
I'm just recording it. So thank you for the reminder
We are week 13
Thank you for the reminder
Let me change it really quick
We're still in just chatting to you
We should go in software and where's the science and tech
We're in science and tech. This isn't software
Linux
MA. Yeah
done
How's that?
Sorry about that everybody as I said, I'm very informal I
Said a dash a for what?
For listing
What are you talking about
No, no such else fine
Does it I mean I've never used it is that is that a positive thing as well I
Mean let's test it
This is why we have a team of people here are watching me so we can check it
Let's go to busybox to see if it supports actually that was the alpine
Run
RM we'll do is whatever alpine has hey
Alpine
Alpine is a container that has a minimal unit distribution in it and
So LS dash capital L. Okay, cool
Never used it not not a thing that I ever used really
Let's see go back home LS dash
L L L nothing there
Interesting
Yeah, I I don't know I've never used it. So but yeah, it's cool. Sounds like a good option to use
Okay, what is profile so profile and in Linux is I mean I when I list I want to see everything so it's probably why
Um
Profile extension issues for files in the terminal programs show profiles by Linux and macOS terminal program contains definition for shell environments
Such as environment variables. This is a horrible answer
And how do I open it?
No
So I know what I want to say, but I want to see what other people are saying about it
So I'm gonna go ahead and say it so the profile is
What controls you logging in right it's for logging in and there's something we probably need to talk about here really quick
So there is
Difference between
Login
And
Login let's see
Login shell
All right, so what is the login show we're gonna have to talk about this so
There are log in slash interactive, right?
Now who does anybody want to take a stab at talking about the difference here
In order we have the knowledge to cover this because we've already talked about
Sub shells and sub process anybody remember what those are?
So this isn't this is gonna be important because it's the first thing in the bash RC file when we get into it
So when I run a shell, so when I start a new bash program
It runs a new interactive shell because it knows it's got a terminal and everything right
But when I run something in the background and we haven't talked about backgrounding processes or anything like that yet and bash
And we probably should have talked about that
I
Don't know if that's a boost topic or not. All right
Suffice it to say that when you like run ps3 you might have to install it, right?
If you have to sudo app install ps3, right?
So this shows you everything that's running on the machine as you can see we got system D
There's running as a top and and then we have all the the the the programs that run under that these programs are all executed
using a syscall called exec and
Ultimately, they create this parent child hierarchy relationship, right?
That's kind of thing exists all over in in you know
In this and you can see there's my tmux server and I have bash and bash is running links and stuff, right?
And there's my bash process running ps3. Okay
Well, what happens when you have a bash?
That's running another bash
right
Then you have a situation where we talked about exporting variables and all that. I don't want to cover that again
but
The difference between interactive shell
and a login shell
Or I mean a non login shell login or interactive. I guess of the kind of the same or technically not. I mean there
There's yet another situation where you remotely connect into the shell into the machine and that is yet another thing
Um, that will that will run if you make a remote connection into the machine
so you have these sort of three states of
Bash or frankly anything running on the system you have
Some a shell where someone has interactively like connected and and that's going to show you like
Look at all those tmux processes that are still running
Um, so like you remember I I I'm I'm ssh'd into this so technically I'm remote
Uh, would be who?
Yeah, so here's all my tmux sessions and it shows that I came from that machine and the ssh'd in or whatever
And and then you have just an interactive shell that maybe was started by another login shell
Uh, I think yeah, you have remote shell non login and login. That's a good way to put it. Thank you and
Interactive just means that you can type you can like interact with the shell, right? It's not
Running behind something it's not running because some other programs started it or something and
This becomes important when you're doing things like like in my my my bonsai command
Which we're going to write we're going to write some bonsai and go
And I you can see how the colors are all here and everything, right?
That's because the program that can detect that it's in an interactive shell
That the that the output the standard output is to a terminal
That's how you detect this by the way the way to detect that you are using an interactive
Uh slash login shell is that the standard output is going to
Uh a terminal if it's not going to a terminal. It's going to a program or something
And and the that's so you can do things like this
I can see that the colors are not there now, right because why I I sent the same exact output
Uh to a program to a pager more which is alias to less
And and now the colors are taken away and the reason for that is so that if I wanted to output
That the output of that command to a file
I wouldn't have all those ugly, you know color escapes for the for that in there
And that's a that's an important technique that's used all the time
But I'm I'm showing it right now to illustrate that an interactive shell or an interactive terminal or a login terminal
Which are kind of the same
Is you know one that the the output
Is going to a terminal and that's the best way programmatically to determine that
I believe that dot profile is the one that runs all the time no matter what it always runs, right?
So you kind of have to have a dot profile even if
In fact, let me try it without it
Let me let me try it. Let's do some experimentation
Let's go back into here and let's actually move my dot profile out of the way, right?
Let's move it to dot old profile
And so now I have no profile, right now. Let's actually log in
Uh from Anton again. I'm going to have to go out here
And make a a new screen
So so this this is robbit tv. This is this is my git bash terminal running on windows
Not wsl windows. This is git bash running on windows
So I can ssh
If you want a bash like environment, your bash is by far the best and you ssh into Anton
Which is the name of my system and it gives me normal stuff
And it says
Well, it's kind of filled the screen there. What's up with that?
All right, so so as you can see
That still worked and the reason it worked is because my shell is bash
Right, so
It knows to run another file in here, which is called
Dot bash, right
That dot bash, uh, I think profile or bash rc
So bash profile, uh, is let's go actually take a
Let's go. Let's take a look at
Um
Another account here
I want to take a look at a brand new account. Actually, let's do that. Let's use a brand. Let's don't use mine. Let's use a brand new one
All right, so so now well
I think we already configured this one, didn't we?
No, I did ssh. That's why so it should be fine
So if I look at dot profile, what's in there?
All right, so this is what becomes in your dot profile file
And it's usually really bad
The profile executed by the command interpreter for login shills
So
The file is not
Read by bash if bash profile bash login exists. Okay, so bash is unique
Um, if you're on older unique systems that we won't get into
uh profile becomes important because
Uh, particularly if you're like running on mac
I'm pretty sure if you're running mac
If unless you're running your back even if you're running bash is you're making sure they're still needed. Um
And
Is it good to have this file around?
Yeah, it's probably good to keep it in your collection
I've never had it had to need it when I go work on a remote system
I just copy over my bash rc file
And so one of the the goals that we're going to talk about is how to make all your stuff in a single file
Instead of having it in bash profile and bash login and all over the place
um
And so bash rc so
Bash rc is meant to run anytime you have any bash program execute whatsoever login remote or anything, right?
um
Bash profile and bash login
Are supposed to be only for login shills, right? And uh the default mask is an etsy profile
By the way, if you want to change where this comes from you can go look at that, right?
Uh etsy profile is where all this stuff comes from for the whole system
Right, this is this is where it copies this over for everybody
um
and
So I I don't want to go too far down that horrible. It's a pretty big rabbit hole
It suffices to say it's annoying as hell to have to manage multiple files
So the region so what I would suggest is that
You just put everything in bash rc and I'm going to show you how to do that. Okay, so
Like right now if we log we log in actually, let's do this. Let's let's actually log in
So you can actually log in from the command line to another account as if you had remotely logged in using the login command
Uh su uh su dash does the same thing essentially
um, but so we're going to do login. Let's log in as the boost account
and
Cannot work without effective root
all right fine
su do login
uh
Called by bash rc and can keep bash is clean. I don't I don't agree with that at all
I hate that approach. I I've read that so many times and I hate it
Bash aliases is supposed to be for bash aliases people who put a full blown bash rc and our bash aliases
Are not doing what I would do
Uh, I don't agree with that, but if you want to do that, that's fine
People think it's fine and they'll leave there the only time that would make sense to put anything in your bash aliases file
would be if you wanted to keep the
uh dot bash rc file
Unmodified and you or for some reason your multi user system has locked down that file
Uh, I don't encounter that situation very often. So that's that's not something I recommend
That it made a lot of people recommend it all the time
So I just want to say I find that really annoying mostly because it's a misnomer. It's not a bash aliases file
It's like everything right so my preference
By the way, when you're doing this you got to be careful to do it with this with an extra account
Because or to keep the other file around because you can keep yourself from logging in
Uh, if if you're not careful, so
You know, but you have a vm. By the way, how do you go take a so we take a snapshot of our vm?
You can go take a snapshot of your vm if you if you're scared
Right, that's why we're doing vms. Let's do it
Let's go into
um
Maybe in our workstation pro or whatever yours is
And where are you my friend? Okay, here we go. And so we're not on the ssh endpoint. We're going to go find
Our other one. We're going to go to anton
And I am going to take a snapshot
File where is it? It's vm snap snapshot take snapshot
All right, and we're going to do take snapshot snapshot one
Boom. Okay. Now you can always go back to that later if you need to
Uh, we are running right now. So this might make us a little bit slower for a second
It's really lagging. Oh my god
It's a pretty big image, so I don't know we might crash. I hope I don't
Uh
Yeah, you know what, you know, I forgot to pause it. I forgot to pause Anton to take a snapshot
You should generally pause it before you do that
I'm kind of curious to see if it's even going to be able to do it
My uh, my fan is sure moving fast
Yeah, I did a lot of around there
I hope I didn't break it
I was at a grub arg
Because we finished. Oh
When is command jake command no, I'm not doing that
Um
In it bin bash interesting. Yeah
Yeah, I we don't play with grub because we're using VMs right now, but you could do that if you wanted to
Um, yeah, that would be more for like if you want to which I want to do by the way
If we have time not in this booth, but later on I make it so
We can talk about how to make your own Linux machine
If that's what you want to do, uh, I'm not I've done something that I do anymore
I am going to be installing Linux on a bunch of other stuff. We're getting kind of foggy here
Yeah
Get back into a VM
Yeah, I feel like I might have broke this
I might have broke this by taking a snapshot. It usually doesn't do that
Well
I should have I should have stopped the image engine before it's taken a snapshot
It's trying really hard to do it with all this processing power going on and it's kind of lagging my community up if you're up
Yeah
We are definitely breaking I know we're breaking because I this is a huge VM
Yeah, it it's a huge the machine doesn't have enough memory is the problem
Uh, I don't have to stop it
Okay
Shut down
Client loop. We got a client loop. Yeah. Power off.
Are you still there?
Taking a snapshot is supposed to take a snapshot of the VM, but you need to have the VM paused or stopped to do it. I can't believe it. Let me do it. I made a mistake.
Yeah.
Yeah, I broke it. And then my host OS is having all kinds of problems because it's running out of RAM.
So because I turned up the RAM on my VM and it's trying to swap it all out, which is really bad.
And I think about bash OSes.
Yeah, it didn't have enough RAM. I had to free up some apps to give it the RAM. That's why it was failing.
Now it's fine. It's fine now. I had to free up some RAM.
Yep. All right. So we're back. We should be back now. Sorry about that.
The reason for that, in case you're wondering, I know exactly why that happened. I just forgot. First of all, number one, I forgot to pause the VM, which makes the saving faster.
And number two, I've allocated eight gigabytes of RAM to Anton because I want a nice smooth experience.
So taking a snapshot of an eight gigabyte memory image on a 16 gigabyte system that's running other things at all causes lots of like pain and suffering on the part of windows.
Or any computer, frankly, because it didn't have it and it didn't swap it very well. So as soon as I cleaned up some of that memory and got rid of those other applications,
both of them electron applications, by the way, Discord and Spotify, which take enormous amounts of RAM.
And as soon as I cleared it, cleared up that RAM, I had enough RAM for VMware to finish the snapshot, which probably would have done even without me turning it off.
But I'm going to go ahead and turn it back on. I actually have a command for that. We already have a snapshot now taken so we can do that.
So if I want to turn it back on, I have a command here called VM run Anton.
And that's a script I have. And that will start up Anton and then we can ssh back into Anton as soon as it comes back up.
And that does it headlessly. And we've covered about how to do this stuff in other booths. So I don't want to go back to it, but that's kind of a fun.
You have to write your own VM run command. It's waiting for it to come on. You guys want to see which one it is.
So this is what's in there. Oh, whoops.
Oh, it's just a, okay, there we go. So VM run is just a, is just a function that I added to my bash RC file in on my Windows machine.
And so it runs VM run and runs the headless no GUI for this. This is actually a really good thing to have.
I did, I think we cut and paste that into other, other stuff, but I kind of want to put it in the notes as well.
Again, once we get there, so ssh Anton, Anton should be up now. And that's because we set up our ssh config, which we did a while ago.
And so now we are in here again, we're in the home directory, and we'll just run the Tmux from here.
And we should be good. All right, so let's see here though, I do want to go to the boost again really quick and go to the 13 read me.
I want to put that a little bit of code in there.
VM, actually, let's, let's put it a separate file, because I want to cut and paste that into the, to the docs.
Tmux, actually, no, because it's a, it's a function.
So, so yeah, that's a windows thing. Now, I do kind of want this, in fact, in fact, I'm probably going to add this to my bash RC file because, and this is leading into another thing I want to talk about, which is conditional evaluation of stuff in your bash RC.
So, even if you can always use init equals bin bash to get back into Linux without a snapshot.
Yeah, but I wanted to save the changes up to that point. So, okay, so we've got, we'll call this and read me again.
And we'll go back here. And we're in the home directory. All right, so dot profile.
By default, if you want to look, and the master makes a good point, if you, if you want to use all the defaults, you can do that if you want.
Right. And you can just put everything in the bash aliases file. I don't particularly like to do that myself. But if you want to do that, you could with bash.
Okay. If you want it. Now, the way that I've configured mine is that it works at one point. I think I actually have broken it since then.
At one point, my bash RC would work with politics shell and bash and a bunch of other stuff. But I've since changed it. So it's pretty bash, bashified.
It's also no longer generic. And so let's talk about, let's talk about organization of files again for a second.
So, so you have, you have this profile, we talked about the interactive thing, right? And you have the login or slash interactive, and then you have remote, which means you came from outside from someplace else.
And those are the main ways. And then you have non interactive, which means stuff is running, but there's no interactive terminal and that includes scripts that are being called from, from other things.
Okay. And we're going to, we're going to jump right into the bash RC file right away on that. And you can decide whether you want to do the, but let's talk about the organization a bit.
So you have the dot profile, which is just kind of there, you have the bash profile, which executed if you have bash, the bash history file, which is created.
That's the thing that, you know, when you do your set dash OVI, which we're going to talk about, you can navigate through here and check the lines out, you can even go to a line.
If you, well, no, I guess you can't. That was, I guess you can't. I thought you could. Anyway, so bash profile bash RC. And then we have some standard directories and I want to put these in the read me.
Okay. So we have, I'm just going to put these out here first. So we have dot config, standard, say, user slash local, local means, usually just for the user configurations for different applications.
And go, by the way, this is called the US OS. I think it's user. It's not user. It's user config. I think it is. I guess user configure.
Let people know this. So I'm going to show you how to get to it. There we go. User caster, user configure and user home. Those are the, those are the main ones. So user configure.
So this is a standard across, it's set by the, the open desktop. And we have cash, okay, is your local cash. Now what is cash?
Cash is cash is where you write things temporarily that are meant to be to go away. So like your browser cash or, you know, things that are that a program wants to use and have it be there for next time, but might throw it away.
And that contains sensitive data like tokens and things like that. So you don't want to make that public. There's another one couple here that are that don't have, they're not part of an official standard.
And this localized is just a localized tree similar to slash. So this is something that has kind of taken off recently, which recently being like five, six years or so, which is, which I find very, very nice.
So if you want to, instead of putting something in like user bin, which is, you know, you guys know user bin is right. User bin is where we have all the programs and stuff, right. So let's say you compile some code, you know, you could, at one point we used to put this in, you know, bin, right.
And at one point we used to have, you know, TMP and, and that kind of thing and we would put them, you know, as a old, old school place to put localized biners.
But this has since changed to be like, like this is your local bin, modern place to put localized binary executables.
So, you know, I used to put them in bin. It's like, you know, this is like the old school place to put, to put TMP files. And, and these, these things, you know, are related to the stuff that's on the system.
What else we got? So, so we have cash, which we talked about. And if you look at the cash, LSDOT cash, you'll see we have, you know, different programs in here, I put my Z program cash in here, go Java, go build, I mean, stuff does this.
Now, the problem we're going to have is that there's kind of modernized applications and there's the old stuff. And the old stuff still does dot files at the root.
And as you can see, it's rather messy. And this has been a problem now that Linux has kind of become more prominent, because there's so many people that wanted a configuration that the dot files, I mean, this is a relatively clean new system.
I've only been working on the ads on here for kind of a couple months. And, but, but as you get going, and depending on how old the applications are, the more messy everything gets. And one of the things that NeoVim claims to fame is that they put their stuff in the right location.
Right, because they, NeoVim will put everything under dot config cat dot cash and dot local, as opposed to VIM, which uses dot VIM info dot VIM and dot VIM RC at the top level.
Right. And in GNU PG, for example, GPG, that's, that's another thing that doesn't observe, you know, these old conventions that SSH is one of the older applications. So when you are looking around in here, just know that there are kind of modern approaches to this and then there's the old approach to it.
Right. Tmux by default looks here as well.
And this is my own stuff, but, but the Tmux. So that's just something to keep in mind as, as we go through it. So those are the, the, the main directories.
So, yeah, I, we want to put here something about old school, Holmder organization versus, that's about right, versus, versus modern standards.
And it's, it's called, and if you want to know where the standard is, you can go look it up. I think it's x 386.
A desktop standard. This has become the, the place to go get the documentation.
If you want to look it up, the, they're the ones who, who kind of championed it, even though X is a, you know, is it the terminal, not a nonterm, I mean, I want to say a window technology.
So you can actually do a desktop standard directory organization.
All right. Let's go look at that x 36 directory, FSF free software directory x 36 implementation. No, I don't know what it is.
Linux directory. I'm trying to, I thought it was free desktop foundation.
Actually, there we go. It's specifications free desktop.org based or x DG cash home x DG, whatever. So these environment variables, which we'll talk about are also where you should go if you're writing scripts instead of, you know, but go has encapsulated that.
And it's looking for that base directory. If you're making new code, if you're making new scripts that are meant to be run by users, or if you're making new applications, I strongly encourage you to get up to speed on the specification for that.
And again, and on Windows, it's local app data, which is low cash, and it varies right so it's home dash cash on Linux and Unix. And this is again one of the advantages of go is that, you know, you write it and go you do it right.
It will cross compile and work anywhere and it will use appropriate locations for things. That's why I like it so much.
And so, so there we go. Well, old school home to organization versus modern standards. So just make sure you got that down.
And I think that's enough conversation about how this thing is organized. And now we're going to dive into the individual programs to and how to organize them.
So the, the first one is going to be all the stuff to log in. And we talked about this. So the bash profile, the bash RC is the most important, in my opinion, unless they don't have a bash aliases file, if you look at the standard bash aliases, or bash profile, which I should be able to look at here.
Oh, no, Etsy scale Etsy scale contains a Etsy scale is an exact duplicate of a new user's home directory. So if you put anything in Etsy scale, adding to Etsy scale for all new users.
If you add anything in Etsy scale will automatically be added to everybody else. So it's also a good way to go back and see the defaults.
So let's say you screw something up and you want to revert. Yeah, you can go back to the skill. And, and you can go check it out.
So this is one of the reasons I don't mind just using my bash RC because if I needed to revert, I can go back in here and see it.
Bash RC. So this is a default bash RC for the system.
And again, so this is the first program that runs when you log in. And we talked about this before, but I want to show it to you again.
So Etsy password is the file that contains all the users on the system.
The X stands for where the password used to be in flat text, by the way, and, and it's now in secret.
And then we have the user ID and the user group ID, which are almost always the same.
There's usually always a group made for a given user.
And then we have just a generic like comment field, people put all kinds of things in here.
There's a standard like common notation for like that.
It's a really old script from for dealing with like multi-user student systems when you do add password that does that.
And then we have over here, we have the actual home directory.
This is the directory that they'll be put into when they start their login or if they start a new process.
And over here, then we have their shell and the shell, the shell can be used.
I mean, this is our login shell or your login application.
And you can do all kinds of fancy things with this.
I mean, you see route has been bashed.
You could actually make your login shell Python if you wanted to.
You can, when I worked at teleport, we made the login shell of a particular account and application that showed transit times.
And it was actually a way to start it.
If you wanted to create a mud multi-user dungeon or some sort of interactive text adventure,
as long as you're careful so they can't break out, right?
You can, you can set that to be the shell.
And then people get, there's actually the Star Wars.
You can, you can SSH to a particular account someplace and you can watch and ask the animation of Star Wars.
And that's because they set as the shell the program to run when they log in.
So we covered this already, but it's important that we go over it again because it does kind of, I mean, bin false means, hey,
you know, nobody should be logging into that account.
Period. Right.
And bin bashed and Berry is another one.
So I've been bashed on Berry too.
And that, that's going to cover it.
Yeah.
I'm sure I'm thinking about something here.
Yeah, that's it. No, that's right. That's right. I got it. Okay.
What's the difference between user bin no login and false bin false is a program that just returns one, I mean, zero, one or negative one or something.
Let's say it's an actual program that predates everything.
No login is a fancier version of that.
I don't, I don't know.
Man, no login.
Politely refuse a login.
Oh, apparently it's more polite than it's a BSD thing.
I'm not, I don't use the login.
I use false.
I've been using false forever.
So, yeah.
I don't think that's why I didn't log into the login.
Yeah. Interesting.
It gives less, less exciting.
Yeah, it doesn't give any.
Info at all.
So they don't know what to use or anything.
They just connect and it just drops it.
That's why I like false.
I couldn't remember why, but I think that's probably the reason.
So, so again, here is the standard bash RC file.
So this, this is the, I mean, technically speaking,
if you're running from a remote login shell bash profile,
I think runs first, but it's empty, right?
Let's look, let's, let's see what's in XT scale, by the way.
So, so dot profile is like any remote thing.
So let's look at that one.
So this on a standard system executes command interpreter
for login shells.
This file is not read by bash.
If bash profile bash login exists.
And then I'm asking myself, why do I even have one?
The only reason I do have one is there are occasions
I think Mac is one of them.
We're having it night.
It works nicely.
So this just says, Hey, if I'm going to, for some reason,
I ran dot profile instead of everything else,
go ahead and execute it.
In fact, I wonder, I'm going to experiment with something.
I'm going to get rid of mine.
Did we already do that?
Did we already do that?
No, it's not there.
So apparently profiles like really not used.
I might even be able to delete it from my system.
Let me try something else.
Bash dash.
Nope.
They got it.
So kind of useless.
I mean, I hate to say it, but it is the profile is kind of useless.
You may find that you need it on another system.
If you want to run bashing for some reason,
you can't change your login show.
I mean, I don't know.
I can't remember why I have it.
This one, I'm considering getting rid of it.
I mean, I do have one,
but mine is all it does is just run my bash RC.
It's basically a short version.
It was anyway until I moved it.
It's just a, do I have a bash profession in this?
Oh, and you notice how this is written in old school shell as well.
It's like the headaches.
Yeah.
So if we have bash,
then include bash RC and just run it.
Yeah.
It's interesting because this is using,
this is using politics notation for the shell stuff as if,
because dot profile, this is the one thing I know about profile dot
profile is spans all shell types.
So like if you're on a unique system reacts,
which I haven't been on in a long time,
or BST even on a Mac,
you might have issues with dot profile.
So dot profile might be the first thing that runs.
Just know that.
But more importantly is dot bash RC, right?
This is the most important file
and you're the main bash configuration file.
And I prefer to do everything in bash RC
so that I can SCP that bash RC file to anything
and I get the exactly the same environment.
So, so let me give you,
let's actually do an example of that.
Okay.
So if I, let's say I want to work on a container for some reason
and I want to Docker, we haven't done Docker yet,
but in fact, when are we going to put Docker on there?
And we need to put that on there somewhere,
probably after the ghost stuff,
because we can do from scratch containers.
All right.
So Docker dot it dash dash RM, let's run Ubuntu,
which will run Ubuntu server.
It's a lightweight image.
And let's just go run that.
Oh, I didn't do run.
And so now I'm on Ubuntu.
Okay.
And let's actually see.
Do we have a user over here?
Let's add a user, add user.
RxRob and new password.
By the way, these,
see how it's copying files?
That's what you want to try again.
Oopsie.
Yes, please.
My super secret password.
And I'm going to leave them.
I told you the commas.
So this stuff all goes in the common.
There is a user ad as well.
Ad user is a pearl script that comes on all Ubuntu.
Makes it kind of nice to do it.
It's just a convenience.
You can do all the same things with user ad,
which you should probably memorize as well.
I haven't, I mean, I look for it all the time
because I always do this.
So, and now I can actually change over to that user.
And now I'm running as me.
Now I don't have my profile, right?
So this is me with an absolute bare bones
of my Linux profile.
And I have all the stuff we just looked at.
We have a profile that there's no VI on here.
Oh, that's right.
I have to use Vim.
It's probably Vim Tiny too.
What the hell?
Ubuntu server doesn't have Vim installed by default anymore?
Since when?
Since when?
Sudo app update.
I should have pushed.
Oh, I guess I don't need that.
There's no, there's no Sudo either.
What?
There's no Vim.
I have to install Vim.
You don't want, you want Vim instead of Vim Tiny.
Vim Tiny is usually the one on by default.
I mean, I don't know why you would do this, but, you know.
All right.
Let's do that.
Okay.
Hey, we can see stuff now.
So let's do our XROM.
Vim.profile.
So here is the file as we just saw.
And the default Vim's gotten better, by the way.
The syntax highlighting's gotten a lot better.
So now we have a Vim info because I actually did something with Vim.
So we have a bash history because that shows
all this stuff that I did.
There's all my commands.
My skill bot actually would query interactively the history file,
which you can make update in real time.
And it would tell you if you did it right by looking at your commands.
And that's why I, be careful.
I mean, if you type a password wrong or something like that
and you go splash your, your history file on this live stream.
Yeah.
I've seen passwords in history files before
because people don't know where they are and they type in the wrong place
or something or worse.
They're in a program that takes the password on the command line,
which is totally stupid.
Bash logout executed by bash when login script exists.
So this is kind of a way with bash logout file.
I don't ever use it.
I don't even think I have one actually.
Do I have one?
I do have one, but I don't use it.
Oh, it just clears your console.
So it increases your privacy.
That's cool.
Now I don't use that though.
You have an alias to delete the last history line for that.
Just to delete the last one.
Yeah, that's probably a good idea.
Yeah.
And everybody knows like if you, if you're,
I'm going to show you something.
I mean, I think people know this already.
We already covered it, but let me show you again.
My thing.
I'm a bad streamer, bad streamer.
I did.
I killed my thing.
Where's my Docker line?
All right, let's get back in a bunch again.
I got to do it over again now.
So it's good exercise.
I'm not going to have them on here again though,
because I threw it away because ephemeral containers don't stay around.
They don't remember their state.
So I got to put container.
How about that?
Sudo.
No.
Update.
That's why.
And that's why it is taken by apt update.
By the way, people said it's not.
It is.
So we do apt install them.
That's why them.
I'm rooted.
So I don't need a sudo there.
Alrighty.
So what I wanted to show you.
So we were, we were talking about add user to the X-Rub.
Password, password.
All right.
Now that's the same as saying login if I had, right?
So you see my stuff sell the same.
I hate fuzzy finders and I absolutely detest control R.
I do not ever use control R.
I use set dash OVI and we're going to talk about that.
Don't let me forget.
If you're not using set dash OVI, you're doing it wrong in my opinion.
Because you're using VI for everything else.
And I have strong opinion on that.
So we'll talk about that.
People tell me all the time use control L the clear the screen.
I'm like, get bent.
You have no idea what you're talking about.
Okay.
So LS, LS dash A.
So there's all our files, right?
And let's go edit a profile and we'll get our VIM stuff all automatically initialized.
And we do that.
So there's our VIM info.
Yeah.
Look, if you want to do it, that's fine.
You know, I don't really hate you when I say that, right?
I'm just, I'll just laugh at you.
And then I'll buy you a beer.
Okay.
So if you want to do that, that's fine.
HL search, uh, file marks.
It tells you this remembers.
So this file like remembers all the information about your stuff while you're doing your VIM editing.
And you really shouldn't depend on it.
It is nice.
It does remember where your lines are.
And we're going to go through that later.
But, uh, and the bash log out, you don't need mess with.
But what I wanted to show you is that the only file that matters here is bash RC.
But I do want to show you what Mossy was talking about, which is if you'd rather not mess with the file,
even says it in the recommendations in the comments down here.
And, but I just don't trust them.
Alias definitions.
You may want to put all your additions into a separate file like bash, like bash aliases instead of adding them here directly.
And my question is why?
Why have yet another file that you have to manage that's just sitting around there?
I don't, I don't ever do this because I want to clean directory and I want to control what goes into the directory.
I want total control.
I don't want to trust some really bad shell code, by the way.
Uh, this, this new bun two default bash RC is really bad.
It's just so bad.
And, and I don't want to go, for example, the history file size massively broken.
And we can get into this when we get into it.
Um, it does set some other history settings.
So the main reason that I don't want to use a bash aliases thing is because I want to throw this crap out as soon as possible.
It's absolute crap.
It's a good start.
If you want to like go from there, but it does things that I would never do.
Plus it's using single.
I mean, I don't, I just don't want to talk about because I'll get angry.
Okay.
It's horrible.
It's just really bad.
And I mean, God, look at this.
I cannot.
Okay.
Plus it says you're really horrible color prompt, which is completely bad.
And it's inefficient.
It's totally inefficient because now you're, you're starting this really horrible thing to start another thing, which also has to run another script.
It's inefficient.
It slows down your, it slows down your logins and everything.
Okay.
And, and I don't want to do that.
It tries to give you some aliases.
Uh, it's just, it's just bad.
I mean, why would they put the aliases in dirt colors if dirt colors doesn't exist?
Right.
Why would they, you know, they only activate color if there's only dirt colors.
No, you can use grep with color without dirt colors being enabled.
There's just like so many stupid assumptions based in here that I just, I can't talk about it and not get upset.
I do want to say though that this is where a number of misconceptions come from.
For example, people log into Ubuntu or Kali Linux or something and they tell me, oh, you should use LL for everything.
And I'm talking about, you mean LS-L, right?
And, or they make a command called L that does this, right?
And the answer is that's an alias and they don't know it because they don't know what an alias is.
Now you do.
Um, and you know, they, they set up alerting, which I don't really like alert.
I mean, look at how horrible this line is.
This is, this is objective proof.
These people have no idea how to code or script.
This script is so stinking bad.
I don't have words.
And, and you do, you understand why all these sub-shells are unnecessary.
Uh, the reason they had to do that is because they made it into an alert instead of making it another script or a function.
They could have done this whole thing as a function and saved all of that crap, but they didn't.
And they decided to make an alias.
And by the way, why are alias is bad because it can't be used as Unix filters.
I could go on and on and on.
This was written by whoever manages, somebody at Canonical, whoever manages the, the main login for Ubuntu.
And I'm glad I opened it up because it was a really good reminder why I'm never using it.
Okay.
And you don't have to use it either.
And here's how you change it.
Okay.
So, so I'm going to go back over to my other script over here and I'm going to show you why I think you should put everything in a single Bash RC.
Because when it's in a single Bash RC, all I have to do, uh, is copy it over.
Right.
And, uh, I don't remember how to, how to SSH into containers.
Does anybody else know how to do that?
What's the Docker command for that?
What's the command for it?
I don't remember it.
Does anybody remember?
What is the Docker?
I know there's an SCP command for Docker that will SCP into a running instance.
And I can't remember it.
And I didn't mount the directory because they don't normally do this.
Normally I would, you know, but if I wanted to, I'm trying to figure out how, how I could do that.
I mean, let me think.
Let me think.
Let me think.
Let me think.
We can actually SSH.
Sometimes I go to the machine and SCP it from the target machine and sometimes I do the
reverse.
Is it just Docker copy?
Really?
God, am I that?
But don't have to do it to the running container.
God, I'm so out of shape.
I am so out of shape when it comes to this stuff.
So we are running one.
Okay.
So there, what is this name?
And container ID.
Okay.
Okay.
Okay.
So, uh, Docker copy, uh, dot Bash RC.
To, I mean, this is one example.
I mean, pretend like this Docker copy is like an SCP to another VM or something.
Right.
Um, I'm not the feeling that containers going to come first.
Uh, dot Bash RC.
And I mean, I didn't put the user.
I should probably do that.
I must specify at least one container source.
I think it did.
I don't, I don't know how to do this.
I don't have to look it up.
I'm sorry.
I don't know everything.
Sue me.
Uh, Docker copy.
Oh, really?
Is it?
That's all.
All right.
Well, colon, uh, no, no, no, no, no, no.
We want to dot Bash RC into, and yes, I use my mouse again.
Sue me.
Um, slash 10.
Yay.
All right.
So we should be able to go back to the Docker container and do LL slash temp and see nothing
because it's hidden.
All right.
So now we have a bash.
Oh, you know what?
It's a sim link.
Yeah.
Watch.
I copied the sim link and not the file it points to, which, you know, you wouldn't do.
Okay, let me resolve the sim link there.
I can fix this.
I can fix it.
All right, so we're going to say, what's the thing that resolves symbolic links automatically?
I should probably learn that again.
There's a switch.
There's a flag you can put on copy and the other one that will actually copy the destination
file instead of the actual symbolic link because I, what I want to do is this.
I want to do, I think, is it dash F?
I don't use it very much.
This is for me too.
So we want to follow some links.
Hard links are going to dereference.
There we go.
Dash L. So you might want to do a dash L. I wonder if the Docker has a dash L. Wouldn't
that be cool?
It might.
It might have it.
Oh, damn.
It does.
It does have it.
That makes me very happy.
Okay, so the Docker CP command has a dash capital L as well as the capital.
All right, I'm going to put that on my list because I need to remember that one.
I don't use that ever.
I need to.
C dash L. Follow symbolic links.
We haven't.
Do we do symbolic links?
I don't think we've done symbolic links yet.
Do we need to talk about that?
I think we, no, we're going to, you know what?
We're going to talk about it because we're going to put all that stuff in a Git repo
and then we're going to link it in.
And people, people complain about that all the time and they say it's messy.
There's streamers who complain about that because then they want to use some fancy tool
for it.
And I think learning how to do the symbolic links properly is better personally because
it works everywhere.
And you don't have to install some extra tool that you don't have access to.
It just works.
It's spelled out flag when I don't remember.
Can you do dash dash flag?
I wasn't sure of that.
Okay.
So, so anyway, we've got this new bash rc here, right?
And I want to take it over.
So all I have to do, I mean, I could have copied it right to the directory if I wanted to,
but I kind of want the option of having, you know, remember, I can go get the, this
one from Etsy scale if I need to, right?
So let's just do that.
Let's just copy temp.bashrc and we'll copy it to here if we can.
And now I do ls-l, a, we should see that the file has changed.
It's still readable and everything.
It's bigger though.
And we're going to go look at it.
And now we have, this is my shell check enabled bash rc file, which we are now going to go
through.
All right.
But now the other piece of this is when you copy a bash rc file over, you're like, but
it doesn't look like it's using it.
And people log out of the terminal all the time and log all the way back in, you know,
reboot their computer to get the fresh colors on their terminal.
You know, you don't need to do any of that.
You need to remember this command.
ssec bash dash l for login shell.
And what this does, oh, do you reference this one?
Okay.
What this does is it replaces the running program with a new program, keeping all of its associated
connections and pipes and resources and everything.
And it's a way to re-initialize your shell with a new one.
So after I execute that, it executes bash really quickly.
And you see now I get my fancy ps prompt from, you know, the one that I've been maintaining.
And you can't even tell other than the host name that I'm not on my own system, right?
All I had to do was copy one file and I copied it to temp, but I didn't have to.
I could have copied it right over the top of the other one.
It would have worked.
And that is all I would have had to do to get my bash to work properly.
So you'll hear me when I argue against these shell and fish and other things like that.
One of my main arguments against them is all of the individual files that have to be copied
over to a target environment to get it to work.
So hypothetically, you're working for a new company.
You come on and they have like really old login jump machines that you have to use.
You don't get the choice.
You have to use them.
But you do get the ability to manage your own home directory, hopefully, including your
RC file.
Some places that won't let you even change your own RC file, which is just stupid.
But if they do, then you just copy that file over.
You log in your exec bash shell and you're good to go.
And now you've got all your favorite things.
You got your, you got your, you know, you got your aliases, but actually I don't, right?
And this is actually one of the problems I've had in the past.
At one point I'm going to, I'm going to just confess here.
At one point I put all of the stuff that I have in my scripts directory, I put all of
it as functions inside of my bash or C file, and it was huge.
And it was kind of stupid because every time anything ran, it had to initialize all that
stuff over again.
And that's actually one of the advantages of Z shell.
If you're on the same environment is it has lazy loading of functions when they're used.
And so you, the functions are not stored in the file.
They're stored in a separate directory.
And that you have to copy the whole directory over if you want to use any of the functions.
And since my, and by the way, if you use functions like that, those functions are still not usable
as, as UNIX filters.
So you can't use them as, you know, from, you know, magic wand commands inside of them
or anything like that.
So you still have to have a collection of scripts and we're going to get to that.
But you only need to bring over the scripts that you've come to love.
But as we go through the bash or C file, one of the topics we're going to talk about is
when to use, when to use an alias, an alias function or a script.
Okay.
And that, that is, that is a big question.
Every time a script runs bash or C runs, yes, it's absolutely right.
And that, that is why I'm glad you answered the question because, because, because we're
going to watch the, the reason it's, okay, so let's get into the bash or C file itself.
Let's start going through it.
Okay.
And just like anything else, you can actually put shell check in here.
We can guarantee the correct, the correct task with the script of copy process, correct
task of the script.
I don't know about that.
Yeah.
I don't know.
Let's go through this.
Okay.
So I'm going to go through this.
Really.
I know we haven't taken any breaks.
Do we need a break before we keep going?
What time is it?
Is everybody, does anybody need a break?
Otherwise I just, I feel the need to keep going.
Shaw, you can, but you don't need to.
You could just read it.
Right.
You could do that, but in this case, we're just reading it, it's just copying locally.
You know.
All right, I'm just going to keep going.
If you need to pause the video or whatever, let me know.
So here we go.
You could do it, Sean.
So Ping and Masi are talking about validating the file that you just copied over, right?
If you're using SCP, you don't need to do that, you just don't.
If you want to be extremely paranoid for no reason, you could, but you really don't need
to do that.
You don't want to do that, you could, right?
And what that's, checking an SHJ is a way to validate that the file has not been modified
in any way.
And it usually works.
It didn't.
One of the biggest hacks in history in the 90s, they hacked the WFTP server and they
successfully hacked the source and created a file that had Trojan in it malware that
passed the checksum validation because they made sure to avoid the sections of the file
that were used in calculating the mathematical checksum of the file.
So the checksums have gotten way better since then, and you know, you're usually safe to
do that checksum validation, but it can still be defeated if you're using the bad one.
So I don't know if that's the reason I don't, I think you should do it, but if you're doing
encrypted tunneling, so which is SCP or HTTPS, TLS, then it's not as big a deal.
You should probably still do it for fun, but particularly if it's a script that you're
going to be reading, right?
If you're going to be reading through the script, but if it makes you feel better, you
should do checksum validation on the thing.
If there's any possible reason to do that.
We are doing the boost, my friend, so welcome to the stream.
We are recording this for YouTube.
So just know this, every Sunday we record videos for YouTube.
Okay, so I'm going to go through this file line by line, and we got a lot of coverage.
So, and I'm going to give very brief summaries of what it's doing.
If anybody has questions, please ask the questions now because I'm not going through it again,
all right?
And this is based on the assumption that as any beginner would, you're going to find
a veteran out there or somebody that you trust, and you're going to say, I don't really understand
Bash yet, or I don't understand Vim or T-Mux.
I kind of use your files.
And so it's a part of the culture of Linux and Unix to pass down or to share .files.
In fact, if you go to GitHub, and you just search on GitHub for .files, you will find
literally thousands of repos that have different people's .files, right?
Because everybody is proud of their .files.
It's like the customization on their car, and they want to show you their version.
There's Jess Razzles .files.
So she's container girl.
She was.
She's over at Oxide with Brian Ketchel now.
Everybody puts in .files.
My .files are there.
Everybody puts in .files.
In fact, having a significant .files repo that is well-organized is a really great way
to improve trust with a potential employer, because they can go in there, and they can
see that you know you're talking about.
Right away, I know this person is not someone I would ever talk to, because they're using
crappy ZShell shit on a Mac.
I'm just kidding.
It's a joke.
Oh, my God.
All right.
So, and look at what they're doing, too.
He's making his entire Git repo.
This just shows he doesn't know what he's doing.
This person doesn't know what he's doing.
He's cloning.
He's making a .files, and then he's going into there, and he's doing script bootstrap
for the whole thing.
Okay.
So, I'm kind of jumping ahead, but is there not having public .files?
Because a lot of the things that are going to go in your .files are going to be login
tokens, organization of mostly login tokens, your secure shell configuration files.
By the way, people commit, all the time, they commit their private keys.
People constantly commit their private keys to GitHub, because they don't have any, they
just, I'm going to put my whole home directory in there, and they just commit their home.
Please don't do that.
There's nothing that says, don't ever hire me more than some shit like that.
By the way, we have that, there's a company that I know of that shall not be named, that
is doing that in production.
And they're saying, well, the repos are private, and I'm like, oh my God.
You know, and then what is it?
Last month, all of GitHub's private repos were compromised.
Okay.
Well, it's more fun for the hackers out there.
I'll put it that way.
So anyway, you can go through the dot files.
It's don't feel bad or don't feel guilty or dirty.
Just set as a goal that you're going to go make your own dot files.
You're going to seek to understand your own dot files, but for right now, there's no reason
not to steal somebody else.
And as I mentioned, if you want to go steal mine, which could always use improvement because,
you know, you can go out to slash dot and you can see my stuff.
Now, one of the things I'm going to show you right away, I'll show you from here actually,
it's the organization of it.
So my bash or C, and this, by the way, I noticed the other day when I was going through this
that a couple of specific things to me referring to my name are in here.
My goal in creating a dot files is creating something that you can copy and paste as is
for you, right?
So see this whole who am I thing?
This is so that I can create a user.
We're going to come back to that.
But you know, I get busy and sometimes I'll make a mistake and I'll commit something that
refers to me.
In fact, I think I have something in here.
I don't know where it is, but if you do that kind of thing, now, see the better option
instead of doing a dot files that is this, right?
So this is something I use, I source, I wrote a function called source if, and then I have
added dot bash personal dot bash private and dot bash work.
And this allows me to use the same bash or C file everywhere I am.
And I have a bunch of stuff in dot bash work, for example, that deals with our VPN and logging
around it and, you know, sets a SOX proxy and all this stuff that you'll get into if
you get into the IT profession.
And you know, so you can you can do that that way if you want to my dot bash private is
actually mounted as a USB stick, which is another reason to use a VM instead of Docker.
I'm sorry, instead of, instead of WSL2, WSL2 does not allow you to mount USB sticks, period,
which is really horrible.
So I happen to keep, I mean, I'm not doxing anything here, I keep my private data, my
private stuff on a USB stick, and then I mount that USB stick, and then this gets symbolically
linked to what's called a raw Git repo that never touches the internet, ever.
And that's got, you know, my private keys, my GPG stuff in it and stuff like that.
And that's one of the reasons I'm using a VM container here, because I don't want to
show you that stuff.
But I do want to show you how you could do that if you wanted to.
And then you can you can break these out, okay.
So in terms of references, if you want to follow along in this thing, and you can just
go click on the dot file here, and I'll send you the link here so you can go look at it.
And I'm always, you know, pilfering other people's good ideas as well, I'm constantly
going through it.
All right, so let's let's jam through this thing really fast.
I'd like to read about dot files.
Oh, yeah, it's so much fun.
Yeah, I've made so many friends just through my dot files.
Seriously, because I've like reached out to other people's dot files, I'm like, man, I
really love what you did here.
Blah, blah, blah, say thank you, or you open an issue on the dot files thing just to be
nice or, you know, comment or something.
And I've had people, Q-Macro found me through my dot files on Twitter, and then saw some
stuff in there and started talking about it to his to his pair of group, and it's a part
of the culture, right.
So, you know, drink a beer or whatever, non beer, coffee, whatever you want to whatever
beverage you want, and then talk about making a better dot files.
People at night, like when I'm like putting the music on, I'm all I'm doing is cleaning
my dot files up, and it's fun.
Cleaning your dot files, your dot files up is really, really fun.
You just put music on and, you know, shoot the breeze of your friends on Twitch and just
clean up your dot files.
In fact, it's addicting.
It's really addicting.
You want to like creating new ways to doing things.
In fact, because of this, I ended up making Banzai, which is a monolith that has all of
my commands in it that I can compile for another system.
Let me show you that.
So this, I'm going to give you a little snapshot of Banzai.
So where's my CP command?
All right, wait, wait, wait, wait, so it's over here, there we do it, okay.
So I can do capi dash l, I can do which is Z, right.
You remember my Z command that's got the POMO timer and everything?
Yeah, I can copy my Z command, and I can copy that.
Oh, let's make a new directory.
So while we're at it, where am I?
All right, so I want to be careful because if I close this window, we're dead.
My whole thing will get reset.
So we're going to make a directory called .local.bin, notice file directory, oh, what's the fix
for that?
What's the fix for that?
It's a non-posix fix, but what's the fix for that?
What just happened?
We have a quiz here, we cover this, I just want to see who knows.
I tried to create a directory that doesn't have a parent directory, how do I fix that?
Dash P, well, that's a good job, okay, so dash P, it says make all parent directories
as well, right.
That's all in it, yep, dash P.
That does not work on BSD Unix, by the way.
It is a bash, I'm sorry, it's a, I don't know, it's a bashism, it's a linuxism.
All right, so anyway, so now I have a bin directory, right, and I'm going to go over
here and I'm going to copy my Z program, which is, you guys are going to make one too if
you want to, it's a bunch of only, a bunch of only, a lot of people do that, yeah.
A lot of people do that, but I don't, like, sometimes I like doing it explicitly, but,
so let's actually copy this into the home directory, but to do this, we might have to
do it as a specific user.
I think it's just going to copy it over as root, does it dash U, already make sure of?
Actually, no, let's just put it in slash temp, and I'll copy it over, it doesn't matter.
Either way, it's fine.
All right, so now I can do this, I can say copy slash temp Z into .local, and because
it's Unix, already, right, which is Z, exec bash dash L, and which is Z, and the reason
that it didn't see it in the path is some cool magic that I'm doing with the path, building
up my path on login, and I want to show you that in a second.
So now I have a Z program, right?
Well, it's not, you know, schmox, which is Z.
All right, so now we can do Z, and that's my Z program.
Pretty cool, huh?
I could have done that on PowerShell, I could have done that on Plan 9, I could have done
that on BSD Unix, I could have done that on AIX, I could have done it on anything.
So this is the moment where I'm going to tell you that I am in the middle of porting all
of my scripts, why use a bonsai monolith instead of scripts.
So I'm moving on to the next phase of evolution, and I am getting rid of my scripts, and I'm
putting the ones that I use all the time and do a single bonsai monolith, because why?
Because I was able to copy every single script and every single thing I ever want to use
by using one copy command for all of that stuff, and it fulfills everything I need as
a, look at that, ZPOMO start.
My Tmux over here isn't set up yet, so that's why it's not doing it.
But if I do ZPOMO, you'll see it's there.
Oh, I haven't set it yet, ZPOMO in it.
All right, now let's try ZPOMO.
There we go.
So my POMO is running in my new container, and I didn't have to do anything, I just
copied it to binary over, one binary.
So and look at all the commands I get for free.
You see that?
I get all of those commands for free.
I want to do epic, and I want to do iso-nan.
I can do that, I can do, I can run, I mean anything, I've got my ENV thing, I don't know
how to get all of my environment variables, I can get, whatever, and that would work on
Windows, it doesn't even have Linux if I did it.
It's one of the reasons I like it so much.
So I'm, as I said, it's got, it's got my YAML parser built into it, so I don't have
to install that.
It's got my, you know, it's got a way to set localized variables.
It's got a way to talk to Twitch if I wanted to do that, and I can adjust it to have anything
else off of that that I might not want.
What does AFK do?
Oh, there's no chat command.
Oh, my chat command talks to WeChat.
That's the problem.
Hello.
Well, I'm just going to try to chat, talk to WeChat, and there's no WeChat.
Yeah, so it can't do it, and now it's not happy.
Why isn't it happy?
What did I do to it?
I broke it.
It's waiting on my, it's waiting on terminal input, and it's trying to talk to WeChat,
and WeChat's not there.
I found a bug.
I definitely found a bug.
All right.
Let me, let me go log in or something, so I can fix that one.
All right.
So Docker, when does it connect?
No, it's attached, right?
Docker attached.
I know.
That's embarrassing.
That's what I do.
My program is trying to talk to WeChat, and it's all hung, and it's not doing control
D because control D is getting intercepted by stuff before.
A monolithic function is only file.
I would love that.
Wouldn't that be great, Masi?
Yeah.
I mean, we'd have to be scripts though.
So I mean, you could just do a tar ball and untar it.
That's what everybody else does, right?
Another way to do this is just make a tar ball of your scripts, and then just untar
your scripts, and then you're good to go, right?
Some people do that with their entire home directory.
They just tar, they have a set up script that just tars their home directory, and they
just go over there, and they just run it, and untars it, and does it.
It's kind of a fun script to write if you want to do that.
So oops, I don't know.
What is the name of our Docker thing?
I know this is taking a long time.
I'm sorry.
Docker attached.
Did I do that right, or did I do exec?
I can't remember my Docker commands.
I'm sorry.
There we go.
su-rvxrub.
Phew.
ps-efgrapvxrub.
Oh, there's no pcrgrapv.
I forgot about that.
You guys know about that, right?
Any time.
Okay, I'm going to show you this.
Use to disable aliases, aliases and functions.
So do you see what I did?
It's like, I forgot I don't have pcrgrep installed, so I want to use the actual grip
from the system, so I put a slash in front of grip, and then that finds the actual grip
and it works, right?
So now I need to kill zchat.
So the other thing that I like about using the zchat compile thing is I can see it.
It's not like bash something, right?
So I need to do this.
I need to do pkill756, we'll try to kill it nicely and see if it dies, and I'll see.
Is it still there?
No, I'm not having it.
Okay, fine.
That's nine.
No, we need to kill sophysics.
One more time.
Okay, it's gone.
I could also have done pkillz and that would have got it, but that's a little bit scarier.
And now we should have two containers.
Yeah, we should have two container processes.
There we go.
So, by the way, has anybody had to do that on assistive before?
Did you like login on the outside and then go kill the process and went crazy?
So it's a thing that people do to survive.
I've done that with X before.
I've had my, it's happened with, what's it called?
Popoos.
Popoos was blacking out my screen and I had to SSH in, kill all the processes surgically
and then reboot it because it was so screwed up.
That's why I got rid of Popoos, by the way.
It's crap.
Absolute crap.
We've read an install script for every dependency like use for curl, etc.
I do.
I do have an install script and we're going to talk about that.
We're going to talk about how to write installers.
I don't know if we're going to get to that today.
Maybe we should do that next week.
Let's talk about that.
Do we have time?
I don't know if we're going to have time.
We still have to get through the other configuration files and it's, oops, wrong system.
Date.
It's four o'clock and we're supposed to, we're going until six though, right?
We're going until six.
I get that right.
We just changed the time recently, that's why I'm wondering.
So yeah, we're going until six.
Okay.
So we have time.
We have a lot of things to configure.
So let me, let me, let me put that on the list.
We need to put linking, we're going to put git, we're going to put gh, we're going to
put github, we're going to put linking, uh, ln, and we need to do, uh, installers, uh,
custom installers if you want them.
And we will justify why.
I don't want to get into that right now.
Let's finish going through the bash recipe file.
But yes, I have custom installers for everything because there's no less than six ways to install
most Kubernetes things and you have to pick the way you want to, you know, do that.
Sometimes it's just adding it to an app, you know, a list of stuff to app get, um, and
other times it's snot.
So I, this has been a problem.
I'm, I'm repeating, I'm going to repeat myself tomorrow the next week.
But this is, um, this is one of my, my, my main concerns is, is I want to be in charge
of how something gets installed on my system.
And I like the package matters and stuff, but let's take go for example, right?
Depending on where you install it, you're going to get version 16 or 17.
You're not going to get version 1.18.
So in order to get a 1.18, you got to do some extra things to make sure you get the right
one.
You can try to customize an extra, you know, get repo, uh, an extra, you know, app repository
in order to get the latest one to do apt install, or you can just write a minimal script that
curls down the right tar ball and, and untars it to the right location.
And so the ability, this is why we did bash scripting my friends before I wanted to do
anything with configuration because you know, if you don't know how to do basic bash scripting,
you're really going to be lost when it comes to automating yourself, you know, and configuring
your life in Linux and, and, and that includes writing those installers.
So we covered that over three weeks.
So hopefully you've got at least enough bash behind you to understand what we're going
to be reading.
All right.
So let's go back to the container and read the default bash RC, which I just copied over
here.
Um, and let's break this down line by line as we were going.
All right.
So the first thing you see is a shebang line that has just the word bash in it.
And this is for one purpose only.
This is to tell, uh, my VIM or any VIM, whether or not VIM has been configured yet, which
is kind of the point that it's a bash file, right?
Uh, dot bash RC is not by default recognized as a bash, uh, thing.
And of course you could always do set, you know, FT equals bash here.
And that'll do the same thing.
But that's just a nice convenience.
It works everywhere.
It does not actually evaluate it at all.
It's just a thing.
You'll see people, pearl people doing that too, sometimes Python people will do that.
Um, this next line is the default line that's read by shell check to disable certain checks
that I think are dumb or stupid or overzealous.
And I turned that off.
And I haven't run shell check on my, I'm kind of embarrassed to run.
I don't want to do it.
I haven't run shell check on my, on my bash RC in a long time.
I am regularly changing my bash RC and not running shell check on.
I probably should.
Um, so anyway, and, and then we're onto the most important piece of the beginning of this.
Okay.
And this is what allows you to have a single file instead of all those other files.
Remember all that talk we said about login and interactive shells and all that stuff.
Well, here you go.
This is one of the most cryptic things any beginner will ever see.
And I, to this day, still have trouble understanding what it is.
So we're going to unpack it, but I want you to know that all it's really doing is it's
detecting whether this bash RC is running from a login shell or is it running under
an interactive shell?
Okay.
And, um, if it's running, uh, interactively, then it continues to work.
If it's not running interactively, and this is, we were talking about this before, we're
kind of bouncing around the topic.
Sometimes you don't want all of this to run, right?
So if it's running interactively, I want this bash RC to run.
If it's not running interactively, I want it to end immediately.
I want it to stop working and I want it to return, right?
And if you don't do that, then every shell script under that is going to run the bash
RC file.
And I forgot about the nuances of this, but that's what this is doing.
This is ensuring that, um, and I, if I think, if I remember right, I think, um, I think
no matter what dot pro, well, no, that's not right, never mind, uh, prefer version that
might not be a part of the package measure repo.
Yes.
That is part of it.
Problem.
Yes.
That is very true too.
And you stick a list of packages and you have an app.
No, you can't actually, um, yes.
Animation first approach.
Yes.
Uh, if we're just doing not manual action, yeah.
And another thing too about writing install scripts and we're going to talk about that
at length next week is I, I regularly take those install scripts and copy an install
script over to a system.
I want to put that on or I copy that in skull script and I put that code into a Docker file
to create a new Docker image.
Um, so there's lots of reasons to isolate your stuff.
I've tried to make my own package management systems before and stuff in a bottom line.
I just broke down and make individual scripts and make somewhat logical break up here.
So all you need to know about this is that this says return right away unless this is
an interactive login show.
Okay.
And you can actually look at, um, I don't know if this is going to be covered here.
We're going to have to go look for that.
Oh, whoops.
Uh, let's go see that actually dollar that actually does say what does dollar, uh, do
in Linux.
Yeah, I don't, but the, the things change too much.
It changes too much for you to modify your VM that often.
It's way too tedious in my opinion.
Uh, so anyway, Linux terminal.
So they got all these special things, right?
Um, these are all the arguments, like what the argument numbers are actually, I'm this
I'm trying to look, I'm trying to look for the actual explanation of that thing.
I know you can just echo it by the way, it'll tell you all the things in it, but I've never,
these are all of the commands that have been set for the current shell.
Yeah.
So, yeah.
So you could do, I'm trying to find, I think it's options.
I should know this, but I don't know this dollar, it's preceded by dollars per understand
what dollar dash, I think we have to escape it.
There it is.
PS one is set and dollar dash includes I, oh, there we go.
Here we go.
Oh, look, look, a login shell and the good reason I read, read the bash man page.
A login shell is one of the first characters of argument zero, uh, is dash or when it started
with dash dash login option and interactive shell is one started without non-option arguments
unless dash s is specified and without dash c option, blah, blah, blah.
So PS one is set and so you don't even get a PS one unless dollar I includes, unless
dollar dash includes I, if bash is interactive.
So this is how you can tell if it's interactive and let's go see if we can find the next one.
The current set of options, there we go.
Here we go.
Here we go.
Here we go.
Here we go.
Here we go.
Here we go.
So signal the end of options.
Okay.
Cause all R extra to be assigned.
So here's all of the options, right?
So we have H set, location of commands that are set.
So I guess that's all the commands that, all the options that were passed the bash.
I've never really looked.
The options are off by default unless otherwise noted using plus rather than dash causes the
options to be turned off.
The options can be, can, can also be specified as arguments to the indication of the shell.
The current set of options may be found in dollar dash.
The return status is always true.
Interesting.
So dollar dash tells you all your options.
Yeah.
So that, that's interesting because some of them are just indicated by a dash, you know?
So, so yeah.
Very cool.
Anyway, so this is how you check if it's interactive and this is pretty much code.
Hi Matt.
How you doing?
So this is code you're pretty much going to need to write no matter what, right?
This always to be there.
All right.
Let's go on.
So a district detection.
So this is something, I actually had a very exhaustive district detection section at
one point.
I was checking the U names for Mac and, and all these different versions and I deleted
it all.
If you go back in my files and look at the history of that, you can find that this is
actually dead.
I don't do WSL2 at all anymore, so I would take that out.
But if you want to set a variable, we're, you know, back to, this is why you know bash,
right?
If you want to set an environment variable that contains your distro, you can do a little
bit of detection and then you can have a single bash RC that has conditional logic in it for
the different distros.
I am so regularly on the one-two server and potentially in the future, Fedora or, you
know, Rocky or something that I really don't care.
But I also have a bash RC that's, that I run on my Mac, but I stopped caring about that
as well because I started running VMs and just using Linux everywhere.
So in order to simplify my shell, I added this U name, let's look at U name.
So let's see, use U name to see, to see info about the system.
So U name and there's LS, LF or whatever, not LF, there's no one.
U name is pretty common though.
So U name, U name dash A, this gives you basic information about your system.
And we'll just, I'll let you read about that on your own.
So U name dash R gives you, I think the, what is it, the distro?
Oh, it gives you the actual version.
Interesting.
And I noticed the WSL, if you do that, you get Microsoft.
It's so weird.
I would put that, that doesn't make any sense.
Okay.
So at one point I had all the rest in there, I deleted them all.
Yeah.
Because Darwin, if you're on a Mac, it gives you Darwin, if you're on, you know, whatever.
Local utility functions.
So these are some functions that I wrote.
By the way, if you're going to do an inline function in Bash, you're supposed to do Bash
already.
We just spent three weeks on it.
Okay.
So if you, I put underscores in front of things that I want to be private, I just do that
no matter what, just to remind me visually.
So this, by the way, we didn't talk about this before.
This redirects both standard error and output at the same time.
It's a Bash four plus ism.
And you can do one liner's functions if you put a semicolon in there.
You got to make sure to put a semicolon in there because that serves as a line return,
right?
So this is probably not the best, I probably use command dash v here, but that would be
only if I wanted to command.
So type says, this is, I just have this to check whether I either have a function, alias
or script, right?
If I have any of those three script in the path, if I have any of those three that will
come back as positive, source if.
So source if says, if the first argument exists, if it's readable, if it's a readable file,
then source it.
And what does sourcing do?
So we haven't talked about this in Bash before, but I'm going to go through it.
So sourcing, which is either the word source or a dot by itself, literally, this does the
same thing as if you typed every line of the file at that location.
So it's not like import in Python or something like that.
It's the same thing as if you had actually typed those lines at that location, as is.
And it's very essential in your Bash or C file.
Also, I really make sources of security flaws because somebody who makes some stupid app
out there is going to say, just source this and you'll be good.
And they don't even have you look at the code.
Cobra is one of these dumb things that does this.
And we'll get into that a little bit later.
So environment variables also see NVX.
NVX is a command of mine that helps me manage environment variables without having them be
hard coded.
Hey, how are you?
What's that?
I remember to test for interactive to use the test command itself.
That's another way.
Yeah.
That's another way to do that.
You could also do that for sure.
Yeah.
And that's actually how I test for interactivity in other applications.
I think that the way of using dash T, of using, I don't use single brackets, but if it's
just, you know, I think you can use that as well.
If you are, I think you could do that on any shell, not just bash.
So I've seen both of these.
I actually do that very thing in my bash code too.
So they're both work.
The reason this one is here is I'm pretty sure this one works in shells that are not
bash.
Did I get that right?
I think it works in POSIX as well, but I don't remember.
I've had this this way for God, since the 90s.
So what this does, by the way, everybody, Klondike is repeating something we talked
about earlier.
This checks to see if the terminal to which the running shell program is connected.
If the standard output, which is zero, is going to standard output, I mean, if the program's
output is being sent to zero, which is standard output, if it's not, then you know that it's
embedded inside of something else.
C shell as well.
Does it?
Yeah.
Yeah.
So I think this might be a better answer saying you say that.
Thank you for bringing that up.
Yeah.
I'm going to put that in the notes.
When to use dash t zero versus case dot dot.
So yeah, that's a good thing.
I don't think I really, I mean, I honestly didn't know that until today.
I mean, I knew that it worked on bash, but I, and I suspected it worked on AT&T and other
stuff, but that it's hard because I've been around for a while.
So I don't always remember whether it works on AIX or whatever.
And this, my original bash RC was created to run or it wasn't even a bash RC originally.
And it was just, you know, whatever.
And it was originally designed to run, to run on anything.
It's very much of just bash now though.
All right.
So here we have a number of environment variables.
Let's go through these.
What time we got?
So I'm just going to power through my friends.
So this is using the default sort of thing.
It's a little bit redundant because, you know, I could have just done this, but this says
set the user to the user, uh, it will go until six map.
So and then it's just me at home eating food.
I'm not going to do anything fancy today.
I got, I'm, I'm, I got my jammies on, I'm making YouTube videos with my jammies on.
That's how shelly I'm doing.
Um, so user equals user, whatever.
And then who am I?
So this actually runs the command, who am I?
And gives you the current, um, effective user ID.
And you can read all about it here.
Uh, what's the difference between effective user ID and user ID?
Right.
And there, I think I could have used an environment variable for that, but that's a reliable way
to do it.
The reason I want this is so that I can set these things up and, and if I'm running as
a different user, uh, my, my brush are still work, right?
These are all exported.
Why?
Why am I exporting these?
Somebody, somebody give us a quick and dirty answer.
Why am I exporting these variables instead of just setting them for this file?
I mean, we cover this as a bit of review.
Why not just do whatever, right?
We're exporting them because we want any program that uses this shell, which is every
single program after the shell starts to use them as well.
So that means when I run any program at all, uh, that starts from the shell as the parent,
it gets it.
So that's what exports about, um, we're putting double quotes around everything for safety
because she'll check told us to write.
We don't want people doing crazy things there.
Uh, I'm setting a repost directory.
I, I personally think it's good to have your get it.
We'll talk about the get up stuff next week, but I personally use a repost directory and
put everything in there and we'll talk about that a lot.
I have a dot files repo, which links to my GitHub repos.
And then, um, I can use that as a variable as well.
Uh, I've added some other ones, some snippets and scripts, my help browser, you know, these
things keep growing.
Um, I have documents downloads and templates and things because not everybody wants to
name them the same.
And I have those pointing to other things, uh, public and private, my pictures, music
videos, PDFs, virtual machines, um, all stuff that I've just come to use for my other scripts
and stuff.
Uh, is that directory?
This is a big thing.
This is, you know, for my notes and stuff, my Zettle cast back when I was doing videos
to go with my Zettle cast entries.
I don't do that anymore.
Um, my clips directory, which makes me very sad because I can't run my clips now that I'm
doing terminal only.
I need to figure that out.
I'm going to do that.
And then command clip, this stuff is all old, I need to get rid of it.
So here's a very controversial one.
I'm setting, I'm explicitly setting the term to X term, two to six color.
And this, this is highly controversial because it's not necessarily a two to six color terminal.
And I don't want to go down the rabbit hole of terminal color right now, uh, when we do
some of our coding and go, we're going to be talking about escape sequences and terminal
colors and, and, and dealing with all of the ANSI terminal, you know, standards and everything.
So we're going to talk about that.
But if you want your 256 colors to work, you have to do this.
So if you're going to run things like sunrise, which, uh, I know it's like, you see how it's
kind of the colors are not completely on.
It's kind of because there's, there's a millions of colors set, right?
So we'll get to that HR rule is my own rule with, uh, 73 total, uh, editor of EI visual
VI. This is your editor, uh, editor prefix VI, uh, my, my private binary key that we'll
talk about in the go environment variables later.
Uh, these are really important, but they're not, we're talking about it all right now.
Uh, Python don't write by who I used to have a really derogatory comment right by the
century.
If you go through my history, you can go find it because I hate it.
Who made this, who picked this name, some stupid Python programmer.
Um, so anyway, LC collate, this makes all of your sorting, uh, use the C method for,
for, for sorting and you're going to want to set that for everything.
Um, the C flags, this is just for C compilation, um, by standard flags, it just uses them.
We're not going to do any of that until maybe Christmas, we'll go through the C book pop
possibly again.
Um, and then here's some fun stuff.
Okay.
A lot of people don't know this.
This, this is something I didn't find until my forties.
And this is, this is based on, this is how I get terminal color, right?
So when I'm doing, when I do man LS, I get colors in my LS, right?
And people will tell you to use some other form of man or, you know, they'll install
this or that program.
All you really need to do is use the historical support for term cap, which is a way of communicating
what type of terminal you have to everything.
Now that's terminals have been really, really standardized at this point.
Um, so these settings are not as significant, but you can go in here and we're actually
putting in, uh, the codes for the colors, which again, we'll get into when we do go programming
and you can set them.
You can set them.
And once you set them, uh, anytime you do anything that uses, uh, less or more or anything
that, that, that uses, you know, trough and rough, all the stuff that does that rendering,
you'll get color.
So if you want color, that's how to do it.
Uh, Ansible inventory, uh, this is something left over from Ansible that I don't even know
about.
There's my good old Docker UNIX host, which I hate.
We're not going to talk about that right now.
VIM spell, um, we'll talk about that when we talk about VIM configuration after this.
Uh, it's, this is pointing to your spelling, your spelling dictionary.
Uh, GPG, GPG, TTY, I don't know about that one.
We'll have to go look back at that one when we do GPG.
So pager, this is important, um, this checks to see if you have less pipe enabled.
Um, if you do, it makes it so your pager acts better.
Uh, that's all I can say about that.
Uh, let's keep going.
Door colors.
Okay.
This is super important.
Right.
If you're in your terminal on the LS command, you have to set up your drawer colors.
All right.
So, um, let's do that.
Let's look at that.
So drawer color.
And do you, if you think that I typed this by myself, you would be vastly mistaken.
So I have taken somebody, I love that this, this is such an old file.
It actually has something that shows you the colors when you set them, isn't that cool?
So this is an ancient, ancient file, a dot dir colors file that you need to go in and
set.
I, I don't even know where I got mine.
I, I ripped it off from somebody years ago and I have been tweaking on it ever since.
Um, but this allows you to set the colors for the different type of files depending
on your, on your, you know, your, your terminal color.
And if you want my terminal cause, I already told you, you can go get those in my dot files.
Um, but this is how come that when I, unless I get files that look a particular way, I
go in slash proc L S S L you see some of those files.
They look a little bit different.
Uh, I don't see any FIFOs though, where would they be?
Maybe in slash, um, yeah, look at all those weird, different colors.
See, I might actually want to change the, the TTY, uh, color scheme now that I'm looking
at it.
I haven't ever invested a lot of time into it, um, but, but yeah, that's, that's where
you would go do all that stuff, uh, is in your adult dirt colors.
This says dash R says, if I have a readable dirt colors file in my home directory, then
evaluate dirt colors dash B home home colors.
And that means evaluate, you have to be very, very careful with evaluate says take run this
command.
See how it's in quotes.
It actually runs that command at that location.
All right.
It's not the same as an import.
It actually runs the command and you build up the command as a string and then you run
evaluate the string.
Eval is generally considered to be really, really, really bad and you don't really need
it in bash.
There's another way to do this, uh, using a here variable, um, I mean, uh, not a here
variable file descriptor replacement and I probably should update that, but this works
any on any shell, um, and line text backgrounds.
Yeah.
You can use any kinds that you want.
Um, I've left this as an eval because this, this particular code right here works on any
Unix or Linux system.
Uh, and if I were to do some of the other fancy batches and there, it would not work.
So I left it that way.
Uh, uh, it's just that that makes it, I love color.
Yeah.
So this is some pretty amazing magic that I discovered on the internet, um, two years
ago actually, and I will never, ever go back and I cannot tell you how cool this is.
Uh, I'm running out of steam.
I've been talking straight for 43 hours.
How much time we got?
Are we, are we, this one's going to take a while to talk through, uh, date 427.
Man.
I haven't, I've been, I haven't been taking any breaks.
I'm just going to keep going.
I want to get through these configs today.
All right.
So, I mean, you got, you all can stop the video, right?
So if you need to stop it, uh, so a couple of things here.
This thing, I want you to see how the functions have the pattern of a function definition
body and then at an, an export.
I know I need a coffee break, but I'm not going to take it right now.
I'm actually really hungry, but I'm, I'm going to go through the six.
So maybe after this bash RC and then we'll do the MRC after this.
Okay.
I want to get through this file.
It's going to take a long time.
This is like 800 lines long.
So, um, so here we have where this, I don't want the, the, the, the, the, the, the, the
convention I want you to see here is we will soon.
Yeah.
See here it says and export path append.
If you don't do that, then this says conditionally, if, if there's nothing wrong with the syntax
of this function, then export it so that sub bash shells can use it.
Okay.
That's what this is about.
That's what that convention is about.
And this is the way you should do it.
And this is a bash only thing.
You cannot export functions from Z shell and, um, exporting functions in bash was the, the
cause of shell shock, uh, or bash door.
If you want to go do the research on it as the biggest, is the biggest Linux bug in history
some say they refer to it in Mr. Robot actually, uh, shell shock was called.
And what it did is it allowed people to define functions, uh, just by setting, setting variables
because they, they had a problem and that, that's been fixed for more than a decade.
And so that's not a problem, but the ability to export functions in bash is one of its most
powerful and most controversial things.
Um, but that's, that's, that's a function that's doing that.
So this says for all the arguments that we've talked about that, go ahead and check them.
And I'm going to go through this logic and then, um, we're, we'll take a break of this.
Um, so path equals.
So again, the path is a variable, an environment variable path, right?
Echo path.
Here's the, here's the short, here's the actual version.
The path is a variable that contains in order every directory to look in to run a program.
So when I do which LS, it tells me, Oh, it's user bin LS.
Well, we see here user bin LS, oops, user bin LS is one of the directories, right?
If I were to put a program called LS up higher in the directory path, that one would resolve
first, which is one of the reasons I don't like using user bin ENV Python or bash or
things like that, because user bin ENV, uh, can be defeated by messing with the path locations
of things.
If you, if you want to own somebody, uh, put something that they use all the time.
And if you get access, put something in a path above that, uh, and watch them get very
confused because, you know, it'll run that instead of what they think.
So and you'll do that to yourself a lot too.
Um, so what this script does, what this function does is it adds something to the end of the
path if and only if that thing exists, right?
That thing, that thing is not already in the path.
That's what this is, uh, that thing doesn't already exist in the path and it also actually
exists as a file.
So the test that she says, if it doesn't exist, we're going to skip it, right?
And this is why when I added that new Z bin and I tried to look for it, I couldn't find
it and it had to rerun the shell because you don't want to unnecessarily clutter your
path with a bunch of paths to things.
So I am a huge fan of this approach because it only updates your path with stuff that
exists and because if, if you have something in your path and somebody sees you have something
in your path and there's a directory there and they can access, they can just go put
everything one in that directory.
I mean, they have to get, you know, they have to escalate privileges to do that, but still
it's just not wise to do that, right?
You shouldn't be putting anything in your path that, and, and you can actually append to
the back.
The other thing that's really great about this is let's say you have a script and you
want to add a new path just for the, the sake of testing, you can run this from the
command line, right?
So I can go over here and I can say so path, right?
And it gives me my path and I can say, well, what's my current directory?
Okay.
Well, that's not in the path.
Let's temporarily add it.
So I can say path prepend, path prepend dot, right?
And now when I run my path, I can say, okay, so let's say that I'm running a bunch of stuff
in this directory, right?
So, you know, like echo, echo, hello, hello world, do, hello, schmox, hello.
And now I can run hello and it will see it, at least it should see it.
Why did I not do it right?
Oh, whoops.
I had an infinite loop.
So there you go.
See how it ran it without me doing the dot slash, but, but, uh, exec bash, I think it
actually is going to remember it.
Yeah, it still did see that, but it put the other stuff in front of it.
That's interesting.
Hmm.
That's really interesting.
So yeah, but you can go ahead and remove it out of there if you want.
Um, so anyway, if you temporarily want to add something to your path, you can just type
that and add it.
It also prevents you from adding, a lot of people who are in their scripts, what they
will do is they will add to the end of the path and they'll just keep adding to the end.
And so you'll end up with a path.
Every time you rerun your shell, you end up with a path that's got the same path in it
like 40 times, right?
So, so this fixes that.
And I encourage you to study it and look at it.
Um, another cool thing about this is that, I don't care if you can see this here, but
this adds any command, uh, that I have so I can actually make a GitHub repo and it will
look inside of the repos.
And if it sees anything in there, it will add that directory to the path automatically.
So this allows me to, some of my bigger commands, I can put them in their own get repo and then
they get added to the path automatically as long as I put them in the right place.
Um, and then we have all the, all the regular things here, open gdk bin and my script directory
is last.
Um, and again, we have the path append here.
So this is my append path.
I put all my stuff.
And this is relatively new additions.
I put some of the virtual box stuff up there, uh, because again, I can run this on git bash
or the Bissell too, or whatever, right?
So I can, I can do some of that stuff ahead CD path.
Okay.
So this is the last thing we're going to cover for a bit before I go get some coffee or something.
So the CD path is by far the most misunderstood, not known thing in bash.
Anybody who comes at you with, I want, I want to be able to do, I want to do fuzzy finding
and tab completion on my paths and, and I just love how all my Zshell just reads my mind
when I want to change directories.
They don't know about CD path.
It's very poorly documented, even in the bash man page.
And it's considered unsafe by some people.
And I want to talk about it fully before we get into it, um, because of that.
So CD path is a special environment variable, which for some reason doesn't even show when
you try to echo it.
It doesn't even display.
I think it's a bug.
And I mean, you can't do this.
You can't echo CD path.
It doesn't work.
I don't know why it, wait, that worked that time.
I must have lied.
Oh well.
I lied.
I didn't work before.
I was wrong.
I must have been doing something wrong.
So the search for path for CD, this is a column separate list of directories that the shell
looks for destination directory specified by the CD command.
A sample value is dot.
And okay, this is the part where it gets controversial, right?
There's like that.
Never, never, never put dot in your path.
Right?
Why?
Because you don't want people running stuff in your current path.
They want to make sure you put it in a safe place or make them type dot slash, right?
But when you're talking about seeding around to different things, you always want to include
dot colon as the first.
And if you don't, it's really funny.
If you don't do that, if you, if you add a CD path and you don't put that, you'll type
CD to go into something that's in the current directory and it will take you someplace completely
different based on the rest of the path.
Because it won't let you change directories into anything in the current directories.
Very, very, the first time you do it and I did it, it was, it's pretty freaky trick,
triggers it out, you know, freaks you out.
So, so yeah, this says, this says I want to look in my current directory.
I want to look into my home directory or I want to look into the user directory.
And if you look at my CD path, it's pretty complicated.
I actually build up a CD path, CD path, I build up a CD path that contains my dot files,
my common directories.
And this is how I can get away with this.
So I can do CD scripts, right?
Look what it took me to.
I was in my home directory and it took me right into the scripts directory.
And yes, but it does add to the length of letters to type different, differential out
of directories.
I don't know.
It depends on the directories.
I don't have that many places I go.
No.
I mean, yeah, I mean, what would you do?
You could just do CD scripts tab, tab, and I can just do that.
It does tab completion.
So I don't know.
I like it because I don't have to install anything.
And people that like to install extra fuzzy finders and tools and stuff like that just
exhaust me.
I only want to install one RC file and one monolith script.
I mean, command from now on, I don't want to have to install scripts or untar a whole
bunch of stuff.
I want to minimize the amount of time it takes me to set up on a remote system or any system.
And that's my priority.
So people have different priorities and that's fine.
So I would encourage you to look at CD path before reaching for Z shell, which is a horribly
flawed shell on several counts.
And we'll just burn into your muscle memory things that I think are bad for you.
Seriously, a lot of my best friends strongly disagree with that statement, but I'm telling
you what I think.
Having any friction using CD path, yeah, particularly because it's for an interactive process.
Putting is setting up a CD path in an actual script would be interesting.
You'd only be able to CD into that thing.
You could actually export CD path into a runnable script and force it so that directory could
never go in any of those, but those paths, which is a nice security mechanism that's
consistent with what we used to do with path by explicitly defining path at the beginning
of any script, particularly in system scripts that are shell scripts that run at log in
or the running is rude or something like that.
And we talked about that a lot during the show programming days.
I don't want to get rehashed, but people that write shell scripts these days are just like
totally lazy when it comes to security.
They use use of an ENV, they don't care where they are, sometimes they'll put dot slash
in their path.
I mean, they're just lame and it drives me nuts because there was a time when we actually
cared about security for these things and you just don't see that that much these days.
So yeah, a good old days, right?
You've tab complete a lot of directories, so CD path can give you unexpected completions.
I don't think it is ever giving you an unexpected completion.
No, it gives me because I know where my directories are.
Yeah, there has been a time or two where something resolves ahead in priority from another thing.
And in those cases, I just CD into one of the top level things that I'm fine.
So for example, one of my favorite commands is this CD GitHub.com is like, OK, well, now,
now what do I do?
Tab, tab, right?
CD, tab, tab, and I can get, I can do my old, all my other stuff.
So I don't I think the reason I like it is because I'm no less fast than people who use
any other type of tool, and I'm 100 percent compliant with bash on any system.
So, you know, I if you I don't believe in adding a dependency to your muscle memory
or that has to be installed without there being a good reason.
And if there's something that's good enough, I'm going to give it more weight than
some extra shit written in Rust by somebody who wants to replace, you know, whatever.
And that's why I use VI, you know, instead of I use Vim, but that's why I don't use any of them.
So anyway, so here's a check.
Here's the options.
The options are going to take a while for us to talk about.
And so is history.
So how much how much more we got?
We got a line of 150.
OK, so we're halfway through.
I am going to take a break, though, because I am stop.
I'm going to stop talking here.
Simplicity is undervalued.
I do think simplicity is undervalued.
And I, you know, I'll end with this.
But the thing that annoys me is that so many people.
I don't know if it's an age thing, but I think when you've been around longer,
you start to value the simplicity more than you do your ability to show off something.
I don't know if it's an age thing.
I don't know what it is, but but I find it unfortunate that that sometimes people who
choose simplicity who are very capable of using a very highly complex method,
they've just chosen the simple one are judged as being simple themselves.
And, you know, I don't have any specific cases to talk about here,
but I do feel I feel like that's a thing.
Yeah, we're going to take a break.
We're we're not going anywhere, though.
We're going to be here until six tonight.
And I don't know.
Maybe I might catch the sunset.
We'll see. So I'm going to put the timer on.
I'm going to take eight minutes.
I'm going to go make a smoothie and we'll be back.
I can't turn music on for you, though, unfortunately,
because the music will be recorded.
And I can't I can't do that.
Can I do stock?
Can I go pause recording?
I can do pause recording.
Oh, my gosh, I'm going to do that.
All right.
So on pause.
Pause recording. OK.
So it looks like we're recording again.
All right. So.
It's auto-tenera and now it's auto-tenera.
We're just talking about music, my friends.
We were we were just going we were just we were listening to the killers
and and, you know, different people.
There's a playlist called She's Still Preoccupied with 2005.
It's kind of a play on the 1985 thing, right?
And, you know, it's just crazy to me how an entire decade
has gone by, a decade and a half since this music.
I know it's making me feel old.
But it's time to finish up our configuration
and have some fun tonight later on.
I'm not going anywhere.
I'm just getting wondering.
Not even the sunset tonight.
OK, maybe the sunset looks pretty.
We'll see. American hip hop.
Yeah. OK, we can talk about music forever.
Come back if you're on the YouTube watching this right now.
Come back some other time and have fun with us.
We we have a lot of fun over on Twitch.
But you don't want to hear about that now.
You want to skip over. OK.
What are all these show check options and where do I read about them?
I'm going to confess something right now.
I only know what two or three of these actually mean.
And I have to go look them up every time.
And. And no, I remember finding this problem.
We want to cover. We want to cover no clover, though.
I think no cover is an important one to cover.
So. So. So. First of all, how can you even look these up?
I don't recall. So let's go look shopped.
Help shopped.
So shopped is said an unset shell options,
changing the setting of each shell option, which takes the name dash.
Oh. Well, how is this different than set?
What is set about?
Because I use set all the time.
How is set different than shopped?
I know my club service. Yeah, we'll talk about those ones.
Is it for a project of work?
Really? Oh, that's so kind.
Thank you for saying so. That makes me very happy.
I'm going to make it better.
I'm going to make it better.
We're going to make it so you can do pipes within it, if you want.
Anyway, stay tuned for bonsai programming.
I may do some of that tonight, but I'm not promising anything.
All right. So what is the difference between set and shopped?
I have wanted to know this since I mean, I've been doing this for years
and I still don't know the difference.
So what is it?
So set that show V I, which we'll get to is a thing, right?
And set our unset values of shell options and positional parameters.
Change the value of shell attributes or positional parameters
or display the names of them.
I mean, seriously, I still don't get the difference.
I want help here.
What is the difference between set and shopped?
I have never known.
They're both in there.
Change the setting of each shell option op name.
Set an unset shell option.
Should we try it?
Should we try it?
Let's try it.
Let's do, let's do a, well, let's see.
It doesn't be a bash.
Let's, let's run a new shell.
I'm, I'm going to try something here.
Let's, let's see if we can actually set the VI as a default shell command
editor with this.
I mean, X, right?
Experiment.
Let's experiment.
So run it.
What are we going to run?
We're going to run it and remove it.
We're going to run it one, two server and see what we get.
So, so there.
So shopped dash O. Yeah.
It shows you what the value is.
What?
Set that show.
Yeah.
Oh, look at that.
So set changed it and shopped just told me what the value is.
At least dash O shows you what the value is.
That's interesting.
I did not know that.
I did not know that.
All right.
So, so, so, so I'll put that in here in the notes.
Use shopped dash O to see the value of a shell option and use set dash O
to change the value of a shell option.
Kind of cool.
Are you found a stack exchange thing?
What were your search terms?
Because I refuse to use a graphic browser.
It's against my religion.
So set and shopped Y2.
You know, I hate it when I have to admit that stack exchange is useful sometimes.
I really hate it.
Good old Google.
No, I used duck duck O.
So there.
I at least I didn't use Google.
Okay.
So what are we reading here?
A set and shopped are both shell built-ins that control various options.
I often forget which ones as well.
That's the question.
Okay.
I tried looking at the second line of help set and help shop.
If I did that, we just did that.
Don't tell me what I already know.
Don't tell me to RTFM.
In bash release, it says set or unset values of shell options, personal values and set
and unset shell options.
This is not helping me.
As usual, the first answer is wrong.
As far as I know, the set that show options are the ones that are
inherited from born self shell.
Ooh, now that would make sense.
That would make sense.
You might know where the comments is strictly speaking.
Yes.
And the shopped options are the ones that are specific to bash.
That makes a lot of sense to me.
It seems intuitive, even though I don't see enough proof that that's true.
There's no logic that I know of.
Any documentation are shopped.
Well, there are set to show options like blah, blah, blah.
It's probably the idea.
I don't want to hear probably.
I want to hear what it is.
The difference is it changed environment variables.
The difference is in the changed environment variable used by bash
setting with a set command results in shell ops while shopped results in bash ops.
And there it is.
And that is worth quoting.
That is indeed worth quoting.
Yeah.
I don't know.
We'll figure it.
Okay.
Okay.
Grock the difference between shopped and set,
which boils down to set being legacy and shopping bash.
I learned something today.
Did not know that.
Did not know that.
So yeah.
Okay.
So anyway, all right, we're done.
We're done with that part anyway.
Next.
Okay.
So what is check wind size?
I don't even know how to look these things up.
I think we can do it in the man page though.
Let's do that.
Can we do it in the man page?
I think we can.
I think we can.
I think we can.
Um, help shopped.
All right.
So scoop it up.
I'm the scat man.
Who played that the other day?
It was so funny.
Because I'm always doing that too.
I'm like, cool story too for the scat man.
Did you know the scat man actually had problems speaking?
And then he'd made the scat man stuff.
Now he's famous because he's a scat man.
That's what happened.
That's the story.
A little, a little, that's the coffee.
That's why I'm getting like this.
Okay.
So shopped.
I have no idea how to look it up.
Man bash.
When in doubt, man it out.
Man up.
Check wind size.
Columns.
Columns used by the select compound.
So columns is a variable.
Automatically said, if the check wind size option is enabled,
are you telling me that we don't get columns and rows without the check wind size option?
Oh, I'm going to actually put this in here.
Wait, no, I'm not.
That's a container.
That would be, that would be non-productive.
I'm going to put this in my own bash receive because reasons.
I, I like, I like making my bash receive into like an instructive assistant sort of thing.
So even though it's an extra line that parts shopped is for bash ops set is for shell ops.
I think shell is actually a dollar dash as well.
So check, check wind size enables columns and rows.
I'm going to check this.
I'm going to check this.
I, I, I know that we're going over time, but I don't care.
I mean, we're not really, but I want to check this.
I'm going to check it right now.
So there, docker run dash it anything really that has to be, it has to be bashy.
So let's do one, one, two dash, dash or one, two.
This is why I do like having Docker around because I can try different distros that really quickly.
I could have done with Cali if I wanted.
So echo columns.
Oh, look, we have columns.
Yeah.
I wonder if we have, let's see, echo bash ops.
We have check wind size set by default.
Interesting.
So I, I didn't really need to put to set it.
It's kind of a built in, right?
How do I turn it off?
Shopped.
I mean, shopped.
What?
What's the opposite of dash s?
I don't know shopped.
I'm learning it.
So there.
Enable, set each up name, disable.
Okay.
Set that show.
We know that one.
I know.
Unset's for variables, right?
So, so let's try.
I mean, shopped dash.
I've never done this before.
U for unset.
Check wind size.
I want to know.
I want to know.
Shopped dash.
Oh, check wind size.
Gosh, dang it.
What the heck?
All right.
Shopped dash you.
Check wind size.
Uh-huh.
I want to do echo bash ops.
It's off now.
Echo columns.
I bet it's already there though,
because it was already set when it logged in.
I see it told you.
I told you.
So, so how do I not have that?
Exec bash to show.
No, because it's going to log in
and it's going to set it again,
because it's going to run through the bash or C.
Uh-huh.
I mean, what, what have I did this?
What if I said bash or C?
No, Vim.
Oh my God.
Oh my God.
I don't know why I'm doing this.
Set emacs.
That would be a no.
I can't believe they don't ship with Vim anymore.
They want that thing tiny, I guess.
Okay, Vim.
That's Vim, I promise.
Bash or C.
Where's all the, the stuff?
You know?
All right, all right, all right, all right.
Hissapen, there it is.
Shopped dash U.
Check.
This is a bunch of server container.
Check win size.
Now what?
Exec bash dash U.
L.
Now what?
Uh, shopped, um, oh, check win size.
I, that's it.
Echo bash ops.
Damn it.
What's, what's happening, people?
All right, so let's say.
Shopped, no.
I'm staring at you.
And why are you saying that it don't exist?
Because I am staring right at you.
Oh, I know.
Wait, I know an option name.
But does this only do that with like a VI?
Oh my goodness.
What do we have here?
What do we have here?
Shopped is, uh, fine.
Man, shopped.
Uh, help shopped.
Oh my God.
Uh, oh, restrict op name.
Oh, look at that.
I thought I was just going to print it.
Print HSO option with an indication of a status.
Ooh, that's what I should have done.
I should have done that one.
Let's do that.
All right.
Ready?
Ready?
Shopped dash P.
Wow.
My goodness.
I did not know that was the thing until today.
I like it.
Look at all those things.
Look at all those thingamabobs.
Yeah.
All those great options that are set on the shell.
Last pipe.
I mean, some of these you actually want to,
you want to set, but I think most of them you do with,
with, with, with the set dash.
Oh, I think.
I think, I think shopped is like set on steroids.
That's what I think it is.
I think shopped is set on steroids,
but I can't say that for sure.
That's enough for my curiosity to be satisfied.
All right.
So let's move on.
Shopped is a thing that sets options.
There's probably a shopped variation for no clover.
I probably could put no clover here
without using set dash O.
I know that set dash O works on any system though.
You know what I mean?
Or unsaid.
Yes, they're unsaid.
But did it say, did it wait?
Shopped dash P.
Was there like a no clover there?
No, there's not.
No.
What?
No, that's freaking me out.
So, okay.
So apparently.
All right.
All right.
All right.
Set dash P.
Man set.
Help set.
Turns on whatever the real effective user needs to do to the match.
Look at all that stuff.
Oh, this is the one where it's like all smashed into each other.
Same as dash C.
This is weird.
See if I can run it like this or not.
I think these are the things that are in the opt variable.
That's what I think.
Set of the value of the variable.
All assignments, job controls, enable, recommands.
Set dash O.
This is what I use all the time.
This is how you turn VI mode on.
And we'll talk about that in a bit.
In fact, I don't.
Why has the VI mode on here?
Oh, I think I put it under VI.
That's a history thing.
That's why.
All right.
We got keywords.
What else?
I want to see all the options.
How do I do that?
How do I do that?
How do I run it to see all of the options?
I want to see all the stuff that's on.
Oh, there we go.
The current set of flags may be found in dollar dash.
Oh, look at this.
Oh my God.
That's so freaking cryptic.
Does that mean, watch, echo.
I now, well, I finally understand dollar dash.
Because it has like a one line equal.
Look, watch.
Set that show no clover and watch.
Big C is going to go on.
Yep.
See.
I made a joke.
I'm writing some code in the goal.
They allow me to create and manage my virtual machines.
Nice.
Using the vert.
Super cool.
All right.
So, so, so this is interesting.
So apparently there are two sets.
I'm going to summarize their phrase.
You don't have to pay attention.
Okay.
Apparently there are two sets of settings.
For bash, there are the bash only settings,
which are set with shopped SHOPT.
And there are the kind of legacy settings,
which have always been set as,
as with just the set command that go back to politics,
both of which are, are, are,
are contained in different environment variables.
So we have bash opt,
which will give you all of these.
And then we have shell ops,
which is the long form of, oh, wow.
Are you seeing this?
Okay.
So shell opt is the long form of bash opt
that gives you the names.
And that's very interesting.
Because we had a no club.
But, but, but there's also this other old school
environment variable,
which just has the letters that go with the names.
So I want to see if this works here.
So up here we have an H and H is what,
as an H is what it said.
I've always wanted to know this.
So I'm taking some time to figure it out.
So the H hash all.
All right.
So there's hash all, right?
Did I am positive recording?
Yeah.
Yeah.
I think I did.
I mean, I think it says it's some pause.
Should I check the file and see if it's,
see if it's getting bigger?
I know.
Now you got me scared.
I mean, yeah.
Properties.
1.18 gigabytes.
What the hell?
That's huge.
That's gonna take forever to load then.
Oh, well.
Um, yeah, we're, I'm pretty sure I did.
If I didn't, I'll just publish the volume.
We'll call it a day.
Now I'll go cut out the music and stuff.
All right.
So never you fear.
Anyway.
So I, what does the I do?
So I, I don't know.
Emux, I'll screw that.
No.
Here we go.
Help, help set.
I think I is interactive.
Set that shy.
Oh, we know that one because we already went through.
Yeah.
Okay.
So that is, but is it interactive dash comments?
What the hell is interactive dash comments?
I do not know.
Um, you know what I'm saying?
Mark variables, blah, blah, blah, blah, blah.
Option name, set is that she all export.
I mean, interactive comment.
Allow comments to appear in interactive commands.
Could I indeed be checking for,
I don't, it doesn't look like I have interactive mode set to me,
which is like freaking me out.
Look at this too.
We have like an interactive comments here
and then we have an interactive comments here.
It's totally different.
Login shell, that's set over there.
Wait, wait, wait.
I have a feeling that this is actually this one
and not this one.
That's what I think.
I think that this is, I think this is goes with bash.
That's what I think.
Yeah.
Because watch, if we do no clover, we already have no clover is set.
We know we have, we already set that one, right?
So, yeah.
So no clover was correct, right?
That one matches.
It was capital C. That was the one I checked.
So there's capital C, right?
Um, vi mode should be here.
Uh-huh.
Vi mode is the one I set all the time.
So let's go check that one.
Exit error set dash E,
which is something we should set in our shell scripts.
We talked about last week.
Um, emacs style.
I don't have emacs style.
So what does that go?
There's like no equivalent for that one.
What the hell?
If I fail, pause, I pretty much vi.
Oh, use the vi line editing interface.
But it doesn't look like I can grab it from here.
So there's only like special things that get written here.
This is kind of frustrating.
I mean, what's the criteria, right?
Like what's I?
I is interactive commands.
I'm guessing there's no proof of that.
M is what?
What is M?
M is monitor, which is on.
Okay.
Sometimes I have short flags.
Capital B.
Is that one covered?
No.
What is capital B?
Oh, there it is.
Brace expand.
Okay.
Brace expand.
Okay.
Then we got that one.
C we know that one's no clover.
H.
Do you have to get it to show up?
Is that a thing?
Manic, that's it.
That looks very interesting.
We'll try that next.
Let me give you a second though.
So we got B for brace expanded.
C for no clover.
H is his expand, which we have.
And S.
S has got to be VI mode.
S has got to be VI mode, but I don't see how.
You know what I mean?
I was not listed here.
And it's like V.
Let's set brace expand and see if it'll be, yeah.
I actually think it will do that, yeah.
All right, that's that.
All right.
So we set, it's not unset.
Unset is for variables.
What is it?
Set dash?
What is it?
Set dash something?
How's it going?
Job?
Job's value.
Pprivilege VI verbose mode.
Is it dash U?
Same as the other one?
Okay.
So set dash U brace expand.
What is brace expand?
Can I use like the, yeah, you can.
I mean, I remember reading that.
So I'll get that.
It's gone.
It's gone.
It did it.
So VI is just not covered.
I mean, it's not covered.
I don't know why it's just not.
VI print shell input lines as they're read.
No.
Turn on whatever the real thing is.
Same as X.
Emax mode.
It's almost like the person who wrote this
didn't want to do the other one.
Either we are truncating our help file or something.
Emax.
There's no Emax.
There's only VI because I set dash VI.
I think it's probably like a flip on or off kind of thing.
That's why it doesn't have its own value.
But I don't know.
I don't know.
I just know that that's a way.
There's no way to know.
I mean, what's S?
What is S?
All right.
I'm going to change it.
I'm going to change it to Emax mode.
Uh-huh.
Set that show.
Emax.
And then we're going to echo.
I can't even use my counter cursor anymore.
And it's still S.
It's still S, people.
Why?
No unset.
What the hell does that mean?
And why isn't there Emax mode there anymore?
Is Emax not a thing?
Maybe Emax is a default.
Oh, there it is.
Never mind.
There it is.
There's it right there.
All right.
So, so, I think the dash, the S is whatever.
No, it's not.
No, Emax.
No, it's stash OVI.
Stash OVI.
That's, I've been doing that for literally three days.
Literally three decades.
So, there you go.
So, it's interesting because it does not have a letter equivalent.
You cannot look it up in the show-up.
I mean, not in the small ones anyway.
The short ones.
It's not there.
It's not there.
We noticed that because we saw that it didn't change at all when we were changing.
So, it's one of those options.
It's interesting because I have a feeling that
that it's kind of in between, historically, the single letter sort of operate,
settings, and then the full shop stuff that came later.
Editor is different.
No, this is not editor, right?
This is your command line, read line.
Yeah, it's your history.
It's your history editor.
It's your history mode.
So, I mean, we're getting ahead of ourselves.
But the history uses something called the read line C package and the read line,
anything that uses read line, including, I mean, anything, you know, whether it be
Pine or Nano or WeChat or any application that uses the read line library,
allows you to, will recognize VI mode or Emacs mode.
And that means you just navigate the history using VI or Emacs.
And the default, by the way, is Emacs because the people that wrote Bash and all this stuff
are big Emacs users, even though the standard should have been VI because VI is the standard
Unix editor because VI is the visual mode of X and X is the modern version of Ed.
And Ed is the standard Unix editor.
Emacs is a bloated piece of crap that a lot of amazing people use to make great software.
It has, so, so, yeah.
Anyway, I mean, that was a, that was a fun rabbit hole.
I mean, that was a big X on the RWX, right?
Explorant rotation.
But I feel like I know more about set and shopped.
I've been wanting to know about them for a long time.
So that was kind of fun to look at.
So as you can see, you can go read about these anywhere you want to.
Check when size is by default.
A lot of these are on by default.
But I go ahead and set them anyway.
I need columns or rows if I want to do anything fancy with like resizing my window or anything.
Like Tim, I use those in Timx all the time.
And expand aliases.
This is, so like if you have, if you have an alias, do I have an alias?
What do I have an alias?
What kind of alias do I have?
Do I have any alias?
Alias dashed out.
Is that a thing?
I don't know.
I've never done it.
There we go, alias.
Oh, coin flip.
Yeah, we don't have that.
So, so you can do diff tab, tab.
I think, I don't know, it's not working right now,
but that will expand aliases in the command line.
Globstar is the thing that gets you extended Globstar.
Globstar gets you your star expansion from the command line,
which we talked about at length in the bash the other day.
Dot glob includes the dot files in your glob.
If you don't have that, when you do commands and stuff, they won't get included.
So, so yeah, an extended glob allows you to use star star.
If you don't have that, you actually need to put that.
If you want to use the like 10 line shell script to write your own static site generator
with Pandoc and bash, you need to have that enabled
because otherwise it won't descend and won't use the two star thing.
That's not on by default.
You know, the VIMO though.
Yeah, I don't, I don't, I don't know what VIMO does.
It will get to the VI stuff in a bit here and shop no glob.
So, I don't remember why no glob killed something.
I think no glob will actually
glob even if you don't have anything typed at all.
Let's go look.
So we could do man, no.
I mean, we could do man bash, no glob.
Go back to the source.
The little glob option is set.
Let's see if, if no matching file names are found and the shell option no glob is not
enabled, the word is left unchanged.
If the null glob option is set and no matches are found,
the word is removed.
If the fail glob is set, no matches.
I don't want to do that.
At the start of the name or immediately following a slash must be matched explicitly
unless the shell option dot glob is set.
The file names dot and dot dot must always be matched explicitly,
even if dot glob is unset.
So all of this stuff has to do with globbing from the command line.
And we talked about that a couple of weeks ago.
So like L is splat, right?
If I do splat splat, it does everything all the way down, right?
I do like that.
It's going to do everything.
In fact, there's too much stuff, like way too much stuff.
So let's go over here.
So let's do this.
Let's say ls, wait, am I on Anton?
We need to get off Anton.
All right.
So let's do ls-l star.
And it will give you all the directories.
I use star star.
It will give me all the directories and the sub directories.
And it includes dot.
And I think if I turn the other stuff off,
it wouldn't even give me the dot file.
So they would be kept out of that.
I should note, by the way, that you can set these things.
These options for the course of a script,
if you want to have your script not go through the hidden files
or something, you can explicitly set it at the top of your script.
And people did it a lot.
Or if you need to turn on double star expanded globs,
like if you're making a static site generator with Pandoc,
that's something you could do for that as well.
So yeah, did I just close my container?
Damn, I'm going to have another one open.
I've been trying not to do that.
Oh, shit.
I think I closed this one too.
I think my container is no more.
Oh, well.
Hey, Doug.
Whatever.
You know, I'm getting sloppy because I'm tired.
Here we go.
So back to where we were.
STTY annoyances.
So STTY, so this is a really, really big one.
And let's talk about this.
So just Disables, Control, S, Accidental, Thermal Stop.
Somebody told me about this two years ago,
a year ago, a year and a half ago on Twitch.
I love Twitch.
God bless you, Twitch.
Thank you for existing.
If we have any Twitch admins watching right now,
thank you for existing because I have learned so much through Twitch
just from people telling me, why are you doing that?
You're dumb.
And I've fixed some things.
And this is something I've never known about.
So let's take a moment to show you about this.
This is really, really important.
In fact, it's so important.
I'm going to give it its own bullet point in the
in the video, right?
So yeah, this is so use STTY.
We talked about TTYs and what they were.
We're going to talk about them a lot more
when we talk about the colors.
But we've already gone through that it stands for teletype
and it's left over from the days of terminals stuff.
It's a disabled, dental terminal suspend.
All right.
So in order for me to explain this one to you,
and I've talked about this before.
So back in the day, teletype machines,
you don't know what a teletype machine is.
I know for visual interest,
I will show you what a teletype machine looks like.
If you haven't seen it,
you can think about the teletype machine while I'm talking.
And so all terminals are have as origins,
these teletype things, right?
And that's what TTY means, right?
So and, you know, their line return,
line feed, carriage return, line feed,
that whole thing was all, you know,
advanced backspace, bell.
And so all of these special, you know,
escape sequences that don't print anything
were designed to control the teletype machine.
And to this day, they still exist, right?
Well, one of the commands was for when
the teletype machine got too slow.
If the teletype machine was too slow
and it was getting too much data,
there was a special escape sequence that it could use
to say, I want to suspend, right?
And what it would do is the data would still come in,
but it would suspend the data for a while
and it would stop printing,
even though it was still receiving data from whatever,
being typed in or whatever.
And it would be some sort of buffer
that would capture all that stuff.
And then when it unsuspended,
it would go back and get the new stuff and write it out.
Well, let me show you that exact thing happening
on the command line to an unsuspecting person
who just started using the terminal.
It's the most annoying thing beginners
have to deal with all the time.
And I didn't know until two years ago
how to escape this without exiting my terminal, right?
So I'm going to try to recreate it for you.
In fact, I'm going to start a brand.
I don't know if I think I've got too many fixes in place for it.
So I'm actually going to start a new terminal to Anton as Boost.
Let's do it.
No, let's see.
I'm wondering who I could attach to.
So we need to Boost at Anton.
Okay, fine.
Let me go back on Anton and then we'll SU.
I think we can probably, I don't know.
You know, I think I'm going to be fine over here.
I think so.
I think if I just, here, su-boost.
Oh no, I got too much configuration going on.
So we can't have that.
Let's do, I mean, I, okay.
So the reason I'm concerned is because we have Tmux
and a bunch of other things that might fix it for us.
Okay, but I'm going to try it anyway.
Okay, so normally if you, if you type this and be careful
if you do this case, because you're, when you do it,
you might have trouble recovering.
So make an extra terminal or whatever you want to do.
But you'll be typing along and then you hit control S, right?
Now, mine goes into searching mode, right?
Which is a totally different thing.
And the reason for that is because I have this safeguard
put in place now.
And I didn't have this, this before, right?
And I'm trying to create a situation where that's true.
And let me see if I can, I'm going to break.
All right, so, so root doesn't have it.
Okay, so root doesn't have it.
I'm not taking it in my head.
I'm not right now anyway.
So root doesn't have it.
And let's see if root has trolls.
So I'm typing LS, I'm taking me PWD.
Maybe I'm working on a file temp foo.
I'm like, and I'm really going fast or something.
And I hit control S.
Well, that one doesn't do it either.
Damn it.
All right, control S.
No, this has been fixed too.
Damn.
I can't, this isn't work.
I knew this was going to happen.
I can't break it now.
It's only, you know what?
Wait, wait, wait, wait.
I might have an idea.
I've totally fixed myself.
So I fixed myself so good that now I'm broke
because I can't show you how to break it.
All right, so, so yeah, so control S.
No, damn.
I mean, maybe a container, maybe a container.
SSH, no, because the whole thing's getting,
you know what?
It's all because of the host terminal.
Yeah.
And my git bash has it in as well.
So it's really hard for me to break it again.
You know what?
You know what?
I think I figured it out.
I'll go use Anton from the command line.
Yeah.
Because I mean, watch, I mean, even here,
see, it's even fixed here because my bash
grandline's about to fix it.
I can't break it, my friends.
All right.
So I know, well, what does that do?
Resets everything?
Is that the one that turns them all off?
Is that the one that lists them all?
I can't remember.
So anyway, the STTY command controls the TTY.
It's a great way to look up how many rows and stuff you have
like that, if you don't have the environment variable.
It can do all kinds of fancy stuff from here.
Oh, it is the one.
That is the printer.
Yeah.
All right.
So let me check it.
Here's your BOD speed.
I mean, all this stuff from the old school terminal
that mattered, right?
We don't do any of that now.
Suspend is Control-Z.
See, this is what I find interesting,
is that it's not doing it anymore.
That's like, oh, stop.
See, look, stop, spend, undeft.
And actually, it wasn't suspend.
It was, was it, did I do it wrong?
Control-Z.
No, my Control-Z is off too.
It's, it must have been stop.
I think I got it wrong.
I think I've been saying it wrong all this time.
It was doing stop instead of suspend.
It was, I mean, it felt like a suspend,
but it was stopping the stuff.
So we have to get it so that that's not undeft.
We need to define it to be, I know.
I know.
I think we can do this.
I mean, how can we tell it here?
STTY, I've never done this.
STTY, stop.
I don't know.
I don't know what I'm doing.
I want to know though.
I promise it'll be worth it,
because every one of you who doesn't have this set right now
has encountered this as soon as you see it,
you're like, oh my gosh, that's what's going on.
It's so annoying.
Echo, so turning off Echo, by the way,
if you want to make a script that doesn't echo to the screen
when you're typing in passwords and stuff,
that's how you do it.
Is it just S?
Yeah, yours does S, right?
I don't know how to have it type it though.
Yeah, I'm trying to figure it out.
Input settings.
It's definitely stop.
This is way more than I normally would look up.
I don't care.
There is stop, char, but I have to type the character.
Yeah, and it's going to try to do something when I type it.
Yeah, but I don't think I can type.
Yeah, I think I have to do the dollar sign for that.
Yeah, let's try this.
STTY, I'm just taking it on my Bashar scene and reload.
You know, stop.
I can't just do that.
That's not going to, I don't think it's going to work.
I don't think it's going to work.
Let's go check.
Hey.
Oh, wow.
Maybe it did work.
Maybe it did work.
All right, here we go.
So we're doing our thing.
And I accidentally hit Control S.
Oh, it worked.
Yay.
So it is, it is a carrot.
Okay.
So now I'm like typing like, oh, what happened?
Anybody ever had this happen, by the way?
Has anybody, I call this a suspend, but actually that's wrong.
The name is stop.
Has anybody ever stopped their terminal?
Anybody ever done it?
I know it's control, but normally when you see a carrot,
it means that the actual control character has to be typed.
So in, at least in Bash.
So anyway, I just typed a whole bunch of stuff.
Watch what happens when I do start, which is control Q.
Boom.
It types them all out because it just bring the buffer
was all filling on and all that stuff.
Control Z is suspend and the suspend will work.
Like if you're doing sunrise, right?
You can do sunrise and you can do control Z and it will stop it,
but it's still running.
And that sends it, it sends it a suspend, right?
And you can foreground that and it will bring it back.
Control Z is suspend.
By the way, this is a reason I hate nano for beginners
because nano encourages beginners to try to use control commands
to do things they shouldn't.
Like they want to get out of something so they do control S for stop or something
and then they, then they get getting screwed up.
And if they don't have that configuration,
which is what set us off on this conversation, they don't have this thing.
So while we're at it since time, and we haven't really talked to it before,
let's under this, but here, grok backgrounding, suspending processes.
So a process is a running program.
And any program that you have at all, it can be backgrounded, right?
So I can do like right now, I could probably try it.
Let's try, I'm gonna save my stuff so I don't lose it.
So control Z there.
So that stopped my Vim program, but it's still there, right?
By the way, how do I show all the running programs in the background?
Jobs, jobs shows all the stuff that I have running, right?
And if I go on it back, I just do foreground.
And if you have to pick one, you can do foreground and then percent
and then the number and that'll get it.
I don't want to overly dwell on jobs.
But it is the way you can like suspend a thing or put it in the background.
So if you're doing something, yeah, you wouldn't want to do kill,
that's one that would kill that process, right?
But you can refer to any job with a percent in front of it.
And that will do it.
So, but sometimes, for example, if you're like running a Minecraft server, right?
If you accidentally run Minecraft, you don't have Tmux running
and you just have backgrounding and that's all you have.
And you got to get to the shell and then come back to it.
You can like leave the Minecraft server running
and you can do control Z and suspend it and do whatever.
And then you can just foreground or whatever and you go back to your process.
Okay.
So it's kind of like a poor person's poor man's screen or poor man's Tmux, right?
Tmux and screen are way better for that kind of stuff.
But it is, it is possible.
Now, the problem, though, is that if you do control S,
which is not currently enabled on this one,
we got to, we got to put that in a terminal where it's enabled,
it's enabled in a stty-shay.
Let's go look.
So it's undefined again.
So stty, we used to have to do this with,
anybody remember having backspace problems?
We used to have to do, we used to have to set a race
and EOL, we used to have to set a race all the time.
Otherwise, if you push the delete key,
it would just keep pushing control characters.
Anybody remember this?
I mean, it was a long time ago, but in the 90s,
in order to get delete, the delete key to work,
you'd have to do that, right?
So you can also do,
you can also suspend a process using the PID, right?
Absolutely.
Yeah, you can.
You can do kill, whatever, and then the PID.
And then that'll stop, that'll suspend the process as well.
So, so yeah, let's try the other stty.
So stty, stop, we're going to make it the same as normal S.
And, and now when we, we type control S, we get frozen and like,
oh no, I need to close my terminal.
No, you don't really.
You just need to do control Q and that'll restart it.
Now, granted, a lot of people do this,
and then they try all kinds of crap.
They're like exit and all sorts of things.
Remember that everything, when you,
when you actually find the right keystrokes,
all that random stuff that you type to try to get the right thing,
will execute because it's just been, you know,
so sometimes it is better to just kill the screen.
I mean, if that were to ever happen to you too,
you can only just do, you know, Tmux,
which is control a ampersand, you know, and sign,
and that puts you, it just kills your whole terminal window.
And I, that's my go-to for everything.
It just shuts my entire window instantly,
and it's just as easy to type.
But I don't always have Tmux available,
so it's good to know how to do that.
And, and so, it's so back to our, our exercise.
Yeah, there's all the other stuff.
Looks like we got a lot of random crap running right now, so.
All right, so here is our vashrc file.
Yeah, I'm not using control alt.
I need a TTY.
No.
No, I'm not, not a fan of that.
I guess you could do that, but I'm not a fan.
So stdty noise is disabled control s accidental terminal stops.
So if you don't do that,
then it will actually send control s to this,
to the, the, the program.
And in the case of bash,
that makes an interactive backwards search,
which is something I don't normally do, but, but,
and frankly, I didn't do probably
because this was never a set in my vashrc before.
So that's a, quite a bit on that one, but that'll help you out.
We're halfway through.
We're going to go through this fast history control.
So it's super important, my friends,
that you increase your history file size.
And for lots of reasons, we'll get into history and his depend.
The shot of history pen, what this does
is it causes your history to constantly get added to
instead of resetting it every time you log in.
Set that show causes your history to be editable
as if it's a big VI file.
So my, I escape and then I'm pushing up and down J and K.
I'm going up and down.
I can look through anything in my entire shell history with a slash.
So I don't need to have completion for this.
And if I wanted to, I could do it.
I, I prefer this because my,
it turns my history into,
in a huge VI file to which I have one line of visibility.
And since my go to is using slash for things,
anyway, and then I can just N, N, N, N, N,
and find all the Docker things or capital N, N, N, N, N,
or dot and then go to the right thing.
I use it constantly.
I use, I use that constantly.
I don't use anything else.
I think it's kind of silly to,
to use some of the other options that are out there.
I'm able to pull up stuff from months ago
by just typing slash whatever and it'll pull it up.
And I like it more because it's explicit.
It does take a few more keystrokes.
I really, really don't like command line history,
things like, like all my z-show
that try to guess what you want to do.
And they're constantly trying to help you out by hitting tab.
Drives me insane.
I, I don't like that.
I'm a more of a precise guy.
I want to put slash and I want to know exactly
what I'm looking for so that I can find it.
So if I did something as rude, I can go look it up.
By the way, this is another reason
that I use command line links searching
because my command line history becomes my search history.
Let me say that again.
If you learn how to do command line text searches,
your command line search history becomes your web search history.
At least when it comes to research
that you don't really care about, you know,
even if I need pictures or something,
I will do the initial like location of those pictures from here.
And then I'll go to the URL with the dot or whatever.
And I'll open a graphic web browser and look at the image.
Much more efficient.
We'll talk about that more when we did links.
We already did links a little bit.
We'll come back to it.
So, but that's another reason I did that.
I also do, you know, my Zettle Castings when I create them,
I use the term.
So I use my history for everything.
And I don't use, you know, dollar, dollar, I mean,
or bang, bang or whatever people use.
I don't need it because I can just go up into history.
It's like faster.
So, so that's my take on that.
You can go look at them.
There is another option here that you can set that
is a little more complicated,
but you can put a command inside of your dynamically evaluated prompt
that will cause your history to update
as each time your prompt displays,
it will update the last history.
And that's more efficient.
It confuses you though if you have multiple terminals on,
right, because you'll maybe have another terminal
and then now your history and you go up in the other terminal.
And logically you're thinking you're going to go get
to that last command you were at
and you ended up going to the last command
that was entered in another terminal.
So I don't like that, but that's the trick a lot of people do.
You can set, this is me building my prompt.
I am not going to explain this.
This is me proving to myself into the world
that you don't need fancy prompts.
This gives you a prompt that will automatically
wrap to two lines.
History dash A, yeah,
if you want to put history dash A in there, you can do that.
I don't particularly like that,
but if you want to do that,
it just makes your history update
no matter what terminal you're on.
And I, again, I like having,
so my history doesn't update until,
for everything until the terminal dies.
If that terminal dies,
it writes everything that that terminal ever did
to my master history file.
Otherwise it's just available to that terminal only.
I'm talking about Tmux window.
And then, but if I, if I want all that stuff to be available,
I just have to close that pane and then boom,
it gets all written to the history file and go get it.
And I prefer that myself.
I don't like being surprised
by having edited something like,
usually when I'm opening a new window,
it's because I want to do something really temporarily.
I want to go look at something.
I don't want it to screw up the history of my other pane.
And so I don't like history dash A in the prompt command,
personally. A lot of people do it though.
All right, so down here I have my prompt command.
Again, as I said, the prompt command is,
does one, you don't need to export this, by the way,
because it's not used by anything else.
The prompt command environment variable is very special,
and it will execute or eval whatever the string is
every time you enter a command.
And it can slow things down, but by doing that,
I've written this kind of fun little script
that rebuilds my prompt, depending on the size and where I am.
So if I have a short name like this,
it puts it all on the same.
If I get kind of down low into the middle,
user local bin.
It's just usually still using bin.
I think only if I get,
I probably need to get into GitHub directory.
If the, there we go.
So if I want to show my GitHub,
or I want to show what branch I'm in,
I was going to detect on CD.
Did I remove that?
I hope I didn't.
Yeah, I'm still in main right now, so it's not showing it.
At one point I had it showing like,
what my current directory was,
and I, that's not there anymore for some reason.
I'll have to go fix that.
But it was, you know,
I'll show you what branch you're on and that kind of thing.
And it wraps automatically if this number count
is past a certain point and it does the double line.
So you can have fun with your own prompt.
I'm not going to go there.
Yeah, but my B is not working for some reason.
Oh, maybe it's because I'm a master.
Yeah, if I'm a master, it doesn't look like it.
Well, maybe not me.
It doesn't look like it's working right now at all.
Should I take it out?
I might have taken it out.
Double, short, where's B?
B is there.
B equals master.
If B equals master or B equals main,
that, that is incorrect, I think.
I have a bug.
I do have a bug.
I'll have to go figure it out.
Anyway,
I don't know where my B is not showing up.
Nope, it's not.
I'll have to fix it another day.
I don't know where it went.
I actually didn't notice that that was broken.
It used to show main and blah, blah, blah, blah, blah, blah,
but somehow I broke it and I'll go figure it out.
It's kind of fun though.
This is the kind of thing, you know,
you blow like an evening on just having fun with.
These are all the colors, by the way.
And stuff.
I'm going to skip this though.
I'm spending too much time on it.
All right, so keyboard.
This is where I map my keyboard.
This only works on a system where I can actually map it.
It says 6K, XK, B map.
This doesn't work on a virtual machine.
So, I mean, I don't think it does anyway.
Let me try.
Yeah, it's not working right now.
It only works if you have a hardware.
Oh boy.
Yeah, I see what I did.
So, that was me remapping Caps Lock.
It only works if you don't, if you have access to the hardware.
And I don't in my virtual machine.
It would be interesting to find out a good way to get this to work.
Oh, it's looking for the display variable, that's why.
This only works if it's an X thing.
So, it probably wouldn't work with Wayland either, I don't know.
But if you had, it's because it's a hardware OS mapping.
You know, I don't know.
And I don't think I even have a display variable set, actually.
Let me go check.
Display is the thing that X uses to display stuff.
Yeah, my display's empty.
If I turn on, so I'm not even using X.
So, this doesn't work unless you have like a window manager.
And I don't, I'm just a terminal.
So, you can't remap it.
You can't remap Caps Lock.
There's probably some other way.
But that's, I added that when I was doing
Papa Weston Min on the desktop when I stopped.
So, I mean, I'd be interested to see if this actually works
all by itself.
Let's try.
I can run this command from here.
No, we need to export that though.
Let's go grab it.
Oopsie.
I'm kind of curious to see if it'll even work.
X and RWX break things.
I don't think it's going to work.
Load keys could do it.
Yeah, there's, yeah, I could get something from windows
that they would take it over.
You know what I mean?
Yeah, I'm pretty sure I could do something.
Now, it doesn't work because it's a hardware thing, right?
It's a hardware interface.
It just messes me up.
I have mixed feelings about that anyway.
I've gone back, just so you know, I've gone back
to using control of bracket for everything
because every fucking, every keyboard works that has it.
So, I don't mess with this at all.
In fact, I should probably disable this.
There's something like only works if you have X
and are using graphics, graphic Linux terminal.
And I don't.
I use the terminal.
So, I'm not a fan.
Control left bracket is exactly the same as escape.
It's easier to hit than escape.
And it doesn't require any modifications
that are messing around.
When we get to the VI stuff, there's a lot of people
who remap VI keys.
I hate doing that.
I tried it for a while.
I tried to use FG as a thing.
I think I still have it mapped here.
No, I turned it off.
I turned it off.
If you type two letters really fast,
it'll operate the same as escape,
but it really messes your muscle memory up.
Control left bracket does not.
So, we'll talk about that when we get to VI later.
So, here's all my aliases.
We're about, we're almost done here, I promise.
We're not going to talk about any of the command line
search aliases until we start talking about links.
And we will cover that probably next week, it looks like.
But this is how I do all my command line searching.
I call program well duck.
And that opens up a text based web browser
that opens up a search over the web, et cetera.
The unalias dash A, that clears out any aliases
that may have been previously said.
And then I reset all my new ones.
As I said before, aliases are generally a bad idea
if you want the output of the thing that comes from the alias.
Because you can't use them.
So, see here, free dash H, right?
Let me give you an example.
So, free dash H, I'm going to put this in my thing here.
No, no one to use aliases and when to not.
All right, so, okay, so free dash H, right?
That's a thing that, yeah, I want to use that.
Free, it gives me human readable, right?
If I, the real free with the slash in front, right?
It gives me this thing I can't read.
And so that's nice, right?
I want that.
Now, if I go edit a file and I want the same thing.
So, I'm going to use my handy dandy, you know,
bang bang, which you now know, right?
And I type free, what am I going to get?
I get the non-aliased version.
And that, my friends, is why aliases are not the best option
for certain things.
Now, if I, so, you know, let's go back here.
I want to use aliases, functions, or scripts.
Oh, I already have that up here.
I want to use an alias function or a script.
I already have it up there, okay.
So, but I must be, I must like this.
So, let me show you another option here.
So, if I comment this guy out, or if I un-set that or whatever,
let's just for grins, let's make this into a function.
Okay, so we're going to say free, and we're going to take over,
you know, whatever it is, and export-f free, right?
And then we're going to say free-h, and we'll pass it any
potential arguments that are there, okay.
So, I now want to use that.
I can do that up here.
So, I can say that I want to use this.
I'm going to say exec bash-l to reload.
Let's see what my free is.
So, my free is a function now, and this is a recap of what's the difference, right?
So, if I go into temp foo now, so what do you think is going to happen?
Actually, I'm already in temp foo, I thought I was so myself.
What happens, what do you think is going to happen when I do bang bang free?
Is it going to print it or not?
Anybody?
Well, let's see if you can guess right now what you think is going to happen.
I don't use tilde for anything, because I just use cd.
Yeah, so, well, that was bad.
That was really bad.
Why isn't that working?
I must have my free waiting on input somehow.
Oh, you know why?
Yeah, free is a function.
Here, I think it's because I think it's calling itself, actually.
Yeah, let me, oh, right, right, right, right, right, right, right, never mind.
Dash free, dash eight, oh, I did it wrong.
Okay, here we go.
There we go.
I did it wrong, I'm sorry.
Isn't slash nice?
So, type free, free is make sure it works.
It's not working, god damn it.
I think, you know what, it's doing an infinite thing and my computer's going to crash here.
I'm so bad, I'm so stupid.
Okay, there's a couple of ways you can do this.
I thought slash worked.
I've used that before, I swear I have.
Anyway, so let's do this instead.
Let's do command dash v free, which I know will work.
Better, damn well, work.
You better damn well work.
All right, so let's try this one now.
So let's try that one free.
I might, you know what, I might have to do witch free, actually.
Yeah, I think I do have the witch.
Or I don't, maybe the problem is I'm trying to name it the same thing, which is dumb.
Vash, at least it's Vubar.
Yeah, I could do that, but I want to break things.
No, it's not doing it.
It has to be witch.
It has to be witch because that's the one that's in the path.
Yeah.
So,
do, do, do, do, do, do, I'll get it, I promise.
Time free.
That's because it's the same name.
There we go.
Okay, that's what I wanted to show you.
Well, you learned something.
You learned three ways not to do it.
Okay, so is that inside a script?
Possibly, yeah.
But I don't want, I wouldn't, I wouldn't want to do it that way.
That's like way too much hassle.
No, I mean, the whole point of this, of using bash command line stuff,
is I don't want to think about it, right?
I want to type bang bang free, and I want it to be what I want, and now it is.
Why did the function work, and why did the alias not work?
I want you to take a moment to think about that.
Why did the alias not work?
And I think, Mosse, I think you were the one who actually tracked this down for us,
and we figured out a way to export aliases so they actually work in sub-processes,
sub-shells specifically, not sub-processes, sub-shells.
And there is another reason for this too, okay?
So there is yet another situation that we're not going to hit until we use go.
But this method that I use will not work if the program that wants to run it
is going to use an exec syscall, because this only works with bash shells.
And I actually ran into that while I was like importing some code over to go.
So the moral of the story is, if you ever are going to use it in vi,
you're more likely to be able to use a function.
But in general, it might be better for you to make it as a bonsai subtree command or as a script.
And the reason for that is because you're going to want to use these things from other executables,
and sometimes they're not always going to be bash scripts.
Sometimes they're going to be other things.
You're going to just want to use that little thing,
and you're going to want to leverage the whole unix-ness of the whole thing.
And you can't do that with a bash function, because a bash function can only be executed from bash.
And if you're running from another executable, it has no idea about bash functions.
So this kind of thing is the kind of thing that's a small thing,
but it would actually end up in my bonsai command.
And I'll show you how I would do that.
I would go to my main here, and I would add myself another command in here,
some sort of simple command to do this kind of thing.
And I mean, I could just do a standard executable.
I don't know if you want to see that right now or not.
But I mean, here's the env one that I wrote.
So this is just a basic command, and it runs the same thing, right?
And then we could have it call-free and look up the free executable and run it that way.
And then when I compile that in, then I can just do zenv, path, or whatever,
and it'll go do this stuff, just like it was in a shell script already.
Expand aliases, aliases, alias free.
That doesn't work. I wish it did.
I wish it did. I've tried that before.
I have expanded aliases on right now.
Yeah, it doesn't work because I'm calling it from within a script,
and it doesn't expand it, unfortunately, at least not consistently.
And it certainly doesn't do it from an executable.
So it's not unixi to do this.
In fact, I have stopped using functions altogether.
The only time to use a function, I've covered this before,
but I'm going to cover it again. It's so important.
The only time I ever use a function, the only time,
is when I want to do something complex that modifies the existing environment.
And usually, that means changing the current directory,
which you cannot do from a sub-shell.
You can't do it because you need to modify the properties of the existing shell.
Everything else that is just saving me typing,
that I really don't care to use in Bash or anything like that,
turning colors on, changing view, these kind of things,
this faster versions of clear the screen.
These are all things that I prefer to do from aliases.
And that's not a very big list.
If you say, I'll re-grab Bash Top, whatever.
And I never, ever depend on an alias to be out of M
because my fingers remember it.
So here are some functions, turn less color off.
I haven't used ENVX in a long time.
ENVX is kind of nice.
What it does is it takes a file, parses it up,
and then sets it in the current environment.
So if you have a script, it's very dockery,
but if you have a script or something that
wants to do significant changes to the current environment
and then throw them all away, you can use this.
And I used to put a number of...
I would have a private .env file that had all my local environment variable sets.
How's it going?
And so new from another shell script, another function.
Again, why do I have it here?
Because it ends by changing the current directory.
So I have one like this.
I have a clone structs, and that what it does is it clones
my GitHub repo and changes into it.
So it takes care of a number of things at once.
That's the kind of thing new from.
This actually will make a new GitHub repo and change into it.
This will make me a new Bonsai command and change into it.
CDZ, this just changes my directory into my Zettlecast
and then it matches whatever I'm searching for.
And then I export all those functions kind of on their own.
Clone is the one I just showed you.
So clone will clone any GitHub repo by default.
It assumes you as the user.
Otherwise it will, if it doesn't have a slash in it,
it will just, it will take the user so I can clone.
I do this all the time to like look at stuff, right?
So who has a GitHub repo?
You want me to look at?
Someone give me a GitHub repo to look at.
And I'll give you a sense of how that works.
I really love this function.
This function saves me so much time.
Of all the functions I have,
I'd say this is probably my favorite besides the path append.
And this is original.
I wrote this one.
It also grabs all the recursive submodules,
which is super cool.
So let's say, and you'll see me use this all the time
while I'm doing streaming.
So I say, let's go evaluate that code, right?
So who wants their code evaluated?
No one?
No one brave enough to get their code evaluated right now.
Okay, so we'll go to GitHub.com.
Let's go find somebody's random code.
How about Neo?
I think we need to find Neo.
I do.
I don't even have Neo here right now.
A while ago, we're wrapping up a YouTube video here,
but you're welcome to hang tight.
So the Neo project, Neo smart economy,
command Neo, Neo Vim, no.
Neo for J, no.
Oh my God.
Neo matrix.
I think this is the one.
Yeah.
So is that the one?
No, this is it.
STW3.
Can the function take in a path to CDN2?
No, because I have the standard path for all that.
You could set that if you wanted to,
but I don't have that.
So let's say ST3W.
I want this, right?
So copy.
I'm going to go grab this.
So I'm going to go clone, paste,
and that downloaded it.
I already had it.
So let's delete it.
I already had it, I realized.
So now let's do it.
So clone, ST3W, it goes and grabs it,
grabs all the other crystal sub modules,
puts me right in there,
and I can get to work looking right at the code right away.
And I don't have to deal with the command line at all.
I don't have to go to the web.
I don't have to do anything.
Working Vim.
Well, because it's a sub shell.
The sub shell is the only run executable things.
You can get functions to work.
I showed that just now.
If you wanted to make it so that it took a path
into where to the thing,
yeah, you can modify that one.
I don't though.
So if repo equals whatever,
yeah, user repo equals the HTTPS.
Oh, look, it looks like,
oh yeah, takes a repo.
I don't know.
I don't think so.
I think you can actually cause it.
I think there is a way to make aliases
propagate to sub shells.
I know that.
I just, I don't think it's a good idea
because it's first of all, it's a bash shell.
As I said, the executables are always
going to be the way to go.
That's why I'm more, you know,
akin to using a bonsai thing.
Anyway, so there's that function.
Okay, so let's talk about completion.
We're going to go kind of longer tonight,
but that's okay.
So this is one of the most important
topics to cover today.
And tab completion, you know,
people laugh at me because,
because I'm not really a fan of
completion inside code.
I could be convinced to use it.
But, you know, when it comes to,
how was it, does not exist.
Did I, did I, mine, mine worked.
You might need to set some of your
other environment variables to get it to work.
Yeah, because it has some other dependencies.
You know, yeah, mine's there.
Yeah, you might have to go look at some
of the other stuff that it has in there.
So let's talk about completion.
So what is completion?
Completion is what allows you to work really fast.
So, so when I CD into questions,
I hit tab and I don't have to type all that.
Can you imagine if that's type that every time?
And in fact, completion is,
is to blame for so many like really long names
because they're just so easy to type, you know,
and you just hit tab and do whatever.
Completion is a popular thing in VS Code
and in other code editors
and it's been around for a long time.
But it's also going on the command line.
And if you have CD path set,
it will also work for that.
And so there's, there's a bunch of,
the way completion works is that the
bashell and any show really,
they have something called completion context.
And when you hit tab, it says,
okay, let's look at this line
and let's evaluate what, what the person thinks they want.
I happen to think completion
is one of the most effective ways of doing anything.
I mean, I'm more likely to go ZZ tab, tab
to see what I can use here
or go YouTube CTO tab, tab, right?
Tab, tab to see what,
ooh, look at all those commands.
I don't have to read them at all.
If I don't remember them,
I can just tab, tab, complete them.
And people who like tab completion for code,
coding, coding argue the same point.
And which is why I think I could be convinced,
eventually to use, you know,
COC or some sort of tab completion within my VIM
or my IDE or something like that.
In fact, you can type an entire web page
with like HTML tab in VS code
and pick from the one you want.
And this is where people are going with the whole,
what is this, you know, that AI
that's doing all the completion,
which is a different issue,
which we talked about in questions and conversations
the other night regarding legality,
because it's including code that's proprietary
and could be tainting your code.
But the concept of completion is a really strong one.
I think it's really solid, copilot, yeah.
And then people should learn to use it.
And unfortunately, a lot of people don't understand
that you don't have to write a separate script
to do completion.
You can actually just enable a program to do completion
by typing complete-c, you know, build, build or something.
And you can have the program do its own completion.
And if you want to get into that stuff
and you really want to see any of that,
I've prepared some examples for you.
You can go read that.
I don't really want to get into right now,
but if you go to ArtifactsRob.CMD, is this CMD?
I mean, it might be Bash example.
There it is. Bash command example.
So this has my example in here.
And it uses Bash completion,
and then Bonsai uses the same technique for completion using.
So this also includes documentation generation
and completion that automatically is detected
based on any function that begins with x dot.
If the function begins with x dot,
it gets completed automatically.
And a simple version of that is I did with the Ops API recently.
Oops, Ops API.
In our dev script here.
And I took out all the other doc stuff,
and I just put this here.
So this is, if you, we talked about this
in the Bash scripting the other day,
if you kind of decompile this and understand what it's doing,
you'll understand a lot about Bash.
But what it's doing is it's just making it so that this program,
anything that begins with x dot is automatically tab-tabable.
And you can type check, tab,
and get all the stuff that has check with the end, etc.
So that's completion.
But in order to enable completion,
you have to put that in your Bash receive file.
And up here I have own comp, and this is an array.
And it's like, these are all of the things
that provide their own completion.
So they would be evaluated,
they would be set up using complete dash capital C,
which is very minimally documented in the Bash thing.
So you have to look for programmable completion.
That's the secret word that will get you to the line
where you need to be.
And this will talk to you all about completion ad nauseam.
Most people check out when they talk about completion
because there's these, lots of these functions
that have been created to help you,
but they actually hinder you in a lot of ways.
But you see them used extensively in all of these other programs.
This is my single biggest complaint about Cobra,
which is a Go library that creates extensive completion
code scripts that need to be sourced and used.
And the reason to do this is because ZShell doesn't support
commands with their own completion,
which is really unfortunate.
That is a reason all by itself for me to never use KShell,
or ZShell or KShell or any variation on it.
They don't support basic internal completion.
What would you rather do completion with?
Some shell script that has to be created to reflect
the same logic that's already written in Go,
or something that already can use the Go code
that you already wrote.
So the entire reason raison d'être for Balzai,
I'm going to make a plug for it right now,
is because of completion and internal documentation
and all the things that come from that.
And so you can go look at that,
but let me give you a sense of this.
That's what this is doing.
So this is saying, for all the ones that I already have,
just do complete-c, because those are the easy ones.
Those are the cool ones.
Those are the good ones.
But the rest of them, we've got to go use its own clunky
completion type mechanism.
And most of them have something completion bash.
That's how you know you're using a Cobra piece of crap,
because it always has the same thing, at least it's consistent.
But let me tell you why I think this is crap,
because if you look at, let's do CubeCTL, right?
CubeCTL completion, okay?
Oops, we have to tell it what shell we want, bash.
All right, so that might not look like much of a big deal,
right, until you count it.
All right, so that's 302 lines.
It's gotten smaller, actually.
It has gotten smaller, thank God.
It was much bigger than that before.
It's 302 lines that have to be evaluated
every time you run an interactive shell.
Every time you run an interactive shell.
And if you want your completion to just be there,
let's do kind.
Kind, WC, dash L.
Oh, whoops, bash.
1,174 lines.
Yeah, I mean, they've taken it down a notch
CubeCTL used to be thousands of lines long.
It used to be 32,000 lines long.
32,000, I mean, 320, 321.
They've fixed it.
They've dabbed, they've taken it down a notch.
That's good.
Probably because everybody was complaining about it.
Seriously, last time I did this,
I actually wrote a big thing on Banzai about it.
I did.
I wrote a big thing, like reaming him for it.
And I think they might have fixed it.
That's actually really good news.
So here's Banzai.
There we go.
So CubeCTL was 12,637 lines last time I checked.
And now we just checked it.
It's only 302 now.
That's really good.
Pandoc's actually pretty good.
Yeah, Pandoc does a pretty good job.
Pandoc has its own thing though.
Let's check the other ones.
Let's check Minicube.
Minicube has, oops, Minitube.
I don't know how Minicube installed.
That's why I have the check it out if you haven't.
Spotify, Kind, Compose, Helm.
Let's do Helm.
Helm is trash.
So the source code is absolute trash.
I don't have that installed either.
Damn it.
Yeah, the rest of them I don't have any of these installed.
What's Docker like?
Oh, so Docker, okay.
So Docker and these other ones are kind of weird.
You have to actually use their independent completion file
and then source it if you want to create shortcuts.
And that's what this is doing.
This is creating a shortcut.
Let's do Pandoc.
So Pandoc is, what did they say?
Pandoc, I dash dash bash completion.
83, that's not bad.
I'm really happy to hear that the QPCTL has come down.
It was 12,000 lines.
Imagine forcing every single person who ever used your command
to get to source 12,000 lines of code.
I mean, my entire bash RC file is only 500 lines.
So in order for it to run completion for just QPCTL up until recently,
I had to, as I told you, it's sourcing it.
So it's essentially the same typing right there.
And that effectively increased the size of my bash RC file
to something on the order of like 15,000 lines
every time I run an interactive thing.
And if you want to hear people complain,
there was somebody who wandered into my Twitch year and a half back
and they were like, oh my God, I wish they would just stop
because all the cloud native people have been complaining about this
because they're all using the same thing.
So you combine, you put all those things in there
and they're all just blowing up everybody's bash RC files.
And so the startup on their interactive shells
is the slowest VS code.
There was no error in it at all.
I don't know.
So yeah, I don't know.
That seems interesting that it's like working out.
This is some stuff for swagger completion.
So this is kind of stupid because it actually had to,
the number one complaint I have,
and this is why I forever hate Anaconda.
Anaconda is kind of a, I don't know what it is.
What is Anaconda?
Anaconda is like a really bad CPAN for Python,
specifically for machine learning kind of things.
And it's absolutely horrible.
I mean, it's just so bad on so many levels.
And I don't have time to go through every one of those things.
I don't like just saying things are bad without telling you why,
but it is, it's just terrible.
And the first way, and the first reason I know it's horrible
is because it screwed with my bash RC file.
When I went to go install it, now it warned me,
it warned me it was doing it,
but then it proceeded to go in and screw up my bash RC file
and write whatever it wanted to to the end of it.
And if you write a program that willingly,
I don't care if you put markers around it or something,
if you're willingly screwing with somebody's bash RC file,
you're a bad person and you should be fired.
I'm only kind of kidding.
Seriously, there is nothing that makes me more angry
than some dome developer full of hubris
who thinks they have the right to screw with my dot files.
Who gave you permission to screw with my RC files?
In this case, it would be me because they asked me,
they said, do you want to say all this is required
stuff to your bash RC for you?
Well, we're helping you out here.
I'm like, okay, fine.
Somebody reminded me after that, after a rant,
I was ranting like, you know, you don't have to do that.
You could have said, no.
And I'm like, oh, okay.
But still, I mean, I can't tell you how many times
I have had stuff royally screw up.
And by the way, every time you do a new install
or something like that, it never remembers.
So it's just screwing up your,
and if you're storing your dot files and get repos,
which we will do at the end of all of this,
you know, you're even more screwed up
because now you're making changes
that you didn't have any control over.
And this is what swagger is.
So swagger is one of the hands down worst projects
I have ever seen.
It is so totally bad.
The open API YAML specification is the only good thing about it.
Everything else, all of the software, the crappy Java,
the horrendous, you know, necessity
to like change my bash rc file
and all of the other novice crap is just terrible.
In fact, I'm deleting this right now.
I'm deleting this right now.
I added that because swagger told me to add that
and swagger is not even a thing now.
The core people on the project left the project
and created open API, which is only minimally better now.
And we're going to rewrite all of that.
Don't get mad, get busy.
In the open source world, you can rewrite it and make your own.
And that's probably a good note to end on.
So this stuff down here is for all of that customization that you want.
So you may be saying, Mr. Rob,
I want to be able to show off my .files with the rest of the world
and how awesome my .files are.
And I want to help all those beginners out there.
And I want to show that I'm not a noob.
And I'm going to put snarky comments and fun jokes in there
and all the other things that people do in the .files world, right?
But I want to be able to have like sub tokens.
And I want to add a Twitch token so I can do a lot of the WeChat.
And I want to be able to add tokens that talk to Twitch with my scripts.
And I don't want to necessarily like even knowing where the files are.
I don't want to give up that information.
Plus I want them to be able to use my file,
my thing without forcing them to use my exact directory structure, blah, blah, blah, blah, blah.
Well, one of the things you can do is you can add a source if at the end
for the different files that you might want to maintain.
So I actually maintain a bash work.
As I said before, I maintain a bash work at work.
It's an enterprise GitHub.
Nobody sees it except for here.
And it overrides everything above here, right?
So it takes over my GitHub information and whether to go out to githubthis.com
or to go out to the internal one.
And then the private one is only loaded for my local machine when I have it connected.
And that's got GPG keys and stuff like that that I would never want to commit.
So that's what those are about.
We talked about them already, but I'll talk about them here.
The Terraform stuff is just left over from completion.
For some reason, the Terraform completion stuff does not work up here.
I couldn't figure that out for the life of me.
I don't remember why that was actually.
So I'll just leave that one there.
And that's the end of today.
I know it's been a long day and some of you probably had to take several breaks along the way.
No worries.
We made it through the BashRC file.
You're going to be spending the rest of your life,
Lennox life, playing around with your BashRC file for fun and profit.
And grab a beer and come mess with your .files and listen to good music with us.
It's a never-ending thing.
I'm constantly redoing my .files and my shell scripts.
By the way, just as kind of a summary here, and I'll zoom in for this story.
When I was first starting, I didn't know shell very well, but I knew Perl really, really well.
And so I wrote all of my scripts directories and everything in Perl.
And then in a 2000 someplace along there, I was like,
man, I should get up with speed with Python.
So I rewrote everything all in Python.
And then a lot of them are the same things, the same things that I rewritten over and over again.
And I've always had Bash as my shell.
So I did for an entire weekend, I tried to do ZShell with people on Twitch helping me
and just to do a fair comparison of the two.
And that's when I determined that in a friendly way, I don't want anything to do with it ever.
And then the latest incarnation of this is, you know, I'm tired of maintaining all of these
scripts in all of these different places.
I just want one executable.
And so that's where Banzai is coming from.
And we're kind of at permission to do that because everybody's doing that now.
I get GH, Twitch, Twirl.
I mean, they're all these like monolith UNIXE monoliths,
which means that it's a monolith that's got broken up into multiple subcommands.
And so that's been my current take on that.
I've been really enjoying it too much, actually.
There's actually a really interesting blog out there somewhere.
I wish I knew the name.
And it was written by a guy who was like, he's basically like, just stop configuring.
And he was basically capturing the dilemma of spending your entire...
I mean, the whole idea of optimizing your configuration for your workflow
is to make you more efficient.
But if you count the amount of time that I have total number of hours
that I've spent optimizing my workstation and my top files and everything,
there's probably not enough time ever for me to ever recoup that time
in terms of efficiency.
But every once in a while, you do add something that adds tremendous value
to your entire workflow, such as my clone command or the Banzai command
or that kind of thing.
And so I think it's worth it to do it.
Plus, it's fun.
And it keeps your skills fresh, keeps your shell scripting or go coding fresh.
So don't take it too much of that to heart.
It's fun.
And personally, I think it's very addicting.
And I think there's probably more than one person in this room right now
who is very addicted to configuring their stuff.
So it's time for me to end the stream and pick my socks up and stuff.
And be a good citizen.
It is Sunday, though.
Give me a break.
And we are going to call it at that point.
So if you want to hang around at ranting,
ranting time is greater than improving work full of time.
I don't know if it is.
I don't know about that.
I mean, it is fun to rant.
It's probably not good for my blood pressure, but it's really fun.
I thank you, everybody.
I'm just going to say it again.
I appreciate everybody being here.
Don't get angry.
Get busy.
Yes.
Reconfigure or write your own editor if you have to.
People have.
I mean, that's good.
I want to encourage people to do that.
Even if they get it wrong, at least, you know, they have the courage to do it.
So we're done here.
And the next thing you're going to see on this channel is probably me playing games
or eating or something.
So I'm going to go ahead and just stop the recording.
Again, thank you for being here.
We'll see you next Sunday at two.
We'll be two to six.
And it looks like we'll be covering the rest of the configuration.
So we only got to the bash configuration today.
I think all we got through that.
I have a feeling it's going to take us a whole day to get through VimConfig.
But I'm going to hope not.
So we're going to put that down here.
Wait, why does it keep doing that?
Wait, you can't see my screen here.
Here you go.
So I'm moving.
I'm moving these topics to the next time.
So we just did configure as a bash configuration day.
Let's say that bash configuration day.
I mean, but for no other reason, then, uh-oh, uh-oh, uh-oh, I screwed up somewhere.
What else is new?
I want to use what?
Oh my god, it got rid of it.
That's weird.
Yeah, it did.
It got rid of it.
Okie dokie.
All right.
All right, peoples.
Uh, bye-bye.
Thank you for the follows.
