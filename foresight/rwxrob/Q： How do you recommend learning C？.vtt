WEBVTT

00:00.000 --> 00:03.440
Alright, so another quick question and answer video. How do you recommend learning C?

00:05.440 --> 00:11.440
My current recommendation is by getting a book called Head for C. I'll go see if I can show it to

00:11.440 --> 00:21.200
you. And we've had people that know C really well kind of evaluate this book. We went through it last

00:21.200 --> 00:32.000
year at $0 for the paperback. I don't believe that for a second. It's a fun book. It has a few

00:32.000 --> 00:37.200
problems in it, but people who do C coding have confirmed that it's actually pretty good for absolute

00:37.200 --> 00:45.200
beginners. I prefer the mnemonic brain-friendly, silly approach to C coding than the really dry

00:45.920 --> 00:52.240
K&R C book. So that is my recommendation. Just get that book and work through it.

00:53.280 --> 00:58.880
It doesn't come with a lot of answers. If you want to do that, in fact, I should probably

00:58.880 --> 01:06.080
put it on the calendar. We will be doing C in December. So it's kind of a Christmas tradition,

01:06.080 --> 01:24.480
C for Christmas. And I want to say December, we're out the week of Christmas. So this will be the

01:24.480 --> 01:33.680
week of C. So this is going to be C coding. I don't know if we're going to do it all on one day.

01:34.560 --> 01:42.080
We'll probably do it a little bit every day. And I'll just put it here. So head first, C.

01:44.320 --> 01:48.560
I talked about, I promised that I was going to do Haskell on Christmas and I actually think it's

01:48.560 --> 01:56.000
more important that we learn C because it's just so much more important than Haskell, honestly.

01:56.000 --> 01:58.720
Haskell School, Erlang is really cool. I wanted to learn Erlang. That was the one.

01:58.960 --> 02:06.640
But every year, I feel like it's really important that you go back to C and you review it and you

02:06.640 --> 02:12.080
learn about it because it informs everything else that you do related to the computer. So that's

02:12.080 --> 02:20.800
my recommendation. Get it and start writing C in it. If you want another book, there's another book

02:20.800 --> 02:26.640
called Mastering Algorithms in C, which I've started to work through. And I just really,

02:26.640 --> 02:36.880
really love the style of it. It's not really dense. It is dated, but it's C, so it's still

02:36.880 --> 02:43.040
really relevant. I just absolutely love Kyle Lodone's style. I recommended this to other people

02:43.040 --> 02:48.640
and they've come back saying, oh my God, this book is so amazing. Kyle was an astronomer and a coder

02:48.640 --> 02:57.520
for a very practical experience and approaches this whole thing from a very, very practical

02:57.520 --> 03:03.520
perspective and pretty much throws out all of the bombastic verbose extra stuff you find in the

03:03.520 --> 03:11.680
textbook. So those are my two favorites. I do not pretend to be a C master at any level. Last

03:11.680 --> 03:16.320
year when I did the C, I had people that were C masters here, particularly VMT. Thank you for that.

03:16.560 --> 03:23.360
But showing me how C actually works and the gotchas and things and you may be asking, well,

03:23.360 --> 03:30.640
why learn C? So the answer to that is so that you can understand all the other things, particularly

03:30.640 --> 03:36.960
if you think you want to learn Rust. C and Rust to go very good together. C and go go very good

03:36.960 --> 03:43.280
together. In fact, I've heard go describe by Rob Pike as an easier C. I've heard the same thing

03:43.280 --> 03:49.040
about Rust that was a safer C. Well, if you don't know C, then you don't know how to contrast it

03:49.040 --> 03:52.720
with these other languages. So learning C, even if you never code anything professionally in it,

03:52.720 --> 03:59.520
it's still valuable no matter what. C was invented to write Unix. That's right. The first version

03:59.520 --> 04:10.160
of Unix was written in assembly and like, man, this is too crazy. We got to do something better

04:10.240 --> 04:14.480
and they did it really low level and really close to the hardware, had ultimate control of every

04:14.480 --> 04:20.080
bit and everything. And so they made C. They made C. Dennis Richie and the gang, they made C.

04:20.080 --> 04:24.640
Ken Thompson. And I still, I was just talking about this the other night, I think Dennis Richie is one

04:24.640 --> 04:31.200
of the most famous yet unsung heroes of our time died the same week as Steve Jobs, nobody knew.

04:32.320 --> 04:35.760
But everything you're using right now is written in C, literally everything

04:36.320 --> 04:48.080
at some level, including JavaScript. So anyway, it is frustrating. Rust can be frustrating if

04:48.080 --> 04:51.360
you have to fight with a barrel checker, but at least if you learn C, you'll understand it. Do

04:51.360 --> 04:56.400
I think you should learn Rust? Yes, that's a different question. But honestly, I really,

04:56.400 --> 05:04.320
really do think that you should learn C first, so that when you learn Rust, you'll see how awesome

05:04.400 --> 05:11.600
it is or where it lacks in other areas, you know, the pros and the cons. And there are,

05:11.600 --> 05:15.360
and you won't understand those until you understand C. So the best way to pick it up if you're an

05:15.360 --> 05:20.080
absolute noob and you just don't, you don't want academics speak too much of it is head first C,

05:20.080 --> 05:23.520
in my opinion, it's kind of fun. You write a game in there, you write an old school Asteroids game

05:23.520 --> 05:30.880
in there. Yeah, in C. And we never got to it last year, but, you know, and then eventually,

05:31.040 --> 05:38.240
you know, you're going to want to do something a little bit more probably, and maybe you want to do

05:38.960 --> 05:44.000
algorithms, mastering algorithms to see now, why, why would I do algorithms in C?

05:45.120 --> 05:48.400
People like, do I need to spend time learning data structures and algorithms? The answer is yes.

05:49.440 --> 05:55.680
Maybe not early on in your programming, you know, path. I never did. I didn't go to computer science,

05:55.680 --> 05:59.840
and maybe I'm a worse person for it. But I did eventually learn a lot of amazing things from

05:59.840 --> 06:03.600
the data structures and algorithms book, but I learned them on my own when I needed them.

06:04.160 --> 06:07.680
And you're going to see me coding a lot of that today, actually, later on. I'm kind of a thing.

06:07.680 --> 06:14.640
I'm going to be coding a parser and a compiler for a language called Kegamel using my other

06:14.640 --> 06:19.280
language that I wrote called Pagan. And I had to learn things like graph theory, and, and, you know,

06:19.280 --> 06:24.000
stacks and cues and all of these things. And I had to teach myself those things in order to do

06:24.000 --> 06:28.800
those things, those very fundamental computer science concepts. So but mastering algorithms in

06:28.800 --> 06:37.680
C, you know, Kyle at the beginning of the book, makes a case for having to have that and, and

06:37.680 --> 06:42.000
needing to know those things like it'll just make you, it'll just inform all of your other approaches

06:42.000 --> 06:45.920
to coding, even though you don't have to be able to spit it out in an elite code interview exam or

06:45.920 --> 06:51.440
something. It's more important that you know how these patterns can be applied at a macro level.

06:51.440 --> 06:54.560
And one of the reasons I think that mastering algorithms in C is such a good thing that C

06:54.560 --> 06:58.560
is a great language for this is because C by default doesn't come with those things.

06:58.560 --> 07:02.000
And the last time I said that, I had a lot of C coders say, Oh yeah, sure it does. And it does

07:02.000 --> 07:07.680
if you have the right library, for example, a map and associate of array, right? Or even an array,

07:07.680 --> 07:14.080
period. They're totally different. There's no, there's not even strings, technically speaking,

07:14.080 --> 07:20.400
technically speaking, C does not have strings, string has character arrays. So these things

07:20.400 --> 07:24.480
that we take for granted in these higher level languages don't exist in C, which makes C

07:24.560 --> 07:30.640
a really great language, in my opinion, for, you know, creating something that you actually

07:30.640 --> 07:35.920
have a chance of like maybe if you're writing your own bubble sort, and any official capacity,

07:35.920 --> 07:39.920
you're probably doing it wrong because it's been written safer and better in another library.

07:39.920 --> 07:42.880
But it doesn't hurt for you to write it and see because you can understand why,

07:43.520 --> 07:49.120
you know, why, why it doesn't have it. So I actually do think learning algorithms and data

07:49.120 --> 07:53.760
structures in C is a good thing. I think go is probably the next best thing to learn those

07:53.760 --> 08:02.160
kind of things. Imagine this array of characters being a string, exactly. And so anyway, that's

08:02.160 --> 08:07.360
all I have to say about C. If you want to learn more about C with me and struggle and suffer and

08:07.360 --> 08:11.200
understand what the stack and the heap and the constant section are and why they're there.

08:12.000 --> 08:18.080
But by the way, the head first book is phenomenally good at illustrating that entire thing. I never

08:18.080 --> 08:23.200
fully understood that until I read that book. And I still, I still feel like I'm missing things.

08:23.200 --> 08:27.440
But mostly because, you know, I have to go through it again every year because I forget. So that's

08:27.440 --> 08:28.000
what I think of C.

