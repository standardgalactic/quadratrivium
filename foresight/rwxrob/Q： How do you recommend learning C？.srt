1
00:00:00,000 --> 00:00:03,440
Alright, so another quick question and answer video. How do you recommend learning C?

2
00:00:05,440 --> 00:00:11,440
My current recommendation is by getting a book called Head for C. I'll go see if I can show it to

3
00:00:11,440 --> 00:00:21,200
you. And we've had people that know C really well kind of evaluate this book. We went through it last

4
00:00:21,200 --> 00:00:32,000
year at $0 for the paperback. I don't believe that for a second. It's a fun book. It has a few

5
00:00:32,000 --> 00:00:37,200
problems in it, but people who do C coding have confirmed that it's actually pretty good for absolute

6
00:00:37,200 --> 00:00:45,200
beginners. I prefer the mnemonic brain-friendly, silly approach to C coding than the really dry

7
00:00:45,920 --> 00:00:52,240
K&R C book. So that is my recommendation. Just get that book and work through it.

8
00:00:53,280 --> 00:00:58,880
It doesn't come with a lot of answers. If you want to do that, in fact, I should probably

9
00:00:58,880 --> 00:01:06,080
put it on the calendar. We will be doing C in December. So it's kind of a Christmas tradition,

10
00:01:06,080 --> 00:01:24,480
C for Christmas. And I want to say December, we're out the week of Christmas. So this will be the

11
00:01:24,480 --> 00:01:33,680
week of C. So this is going to be C coding. I don't know if we're going to do it all on one day.

12
00:01:34,560 --> 00:01:42,080
We'll probably do it a little bit every day. And I'll just put it here. So head first, C.

13
00:01:44,320 --> 00:01:48,560
I talked about, I promised that I was going to do Haskell on Christmas and I actually think it's

14
00:01:48,560 --> 00:01:56,000
more important that we learn C because it's just so much more important than Haskell, honestly.

15
00:01:56,000 --> 00:01:58,720
Haskell School, Erlang is really cool. I wanted to learn Erlang. That was the one.

16
00:01:58,960 --> 00:02:06,640
But every year, I feel like it's really important that you go back to C and you review it and you

17
00:02:06,640 --> 00:02:12,080
learn about it because it informs everything else that you do related to the computer. So that's

18
00:02:12,080 --> 00:02:20,800
my recommendation. Get it and start writing C in it. If you want another book, there's another book

19
00:02:20,800 --> 00:02:26,640
called Mastering Algorithms in C, which I've started to work through. And I just really,

20
00:02:26,640 --> 00:02:36,880
really love the style of it. It's not really dense. It is dated, but it's C, so it's still

21
00:02:36,880 --> 00:02:43,040
really relevant. I just absolutely love Kyle Lodone's style. I recommended this to other people

22
00:02:43,040 --> 00:02:48,640
and they've come back saying, oh my God, this book is so amazing. Kyle was an astronomer and a coder

23
00:02:48,640 --> 00:02:57,520
for a very practical experience and approaches this whole thing from a very, very practical

24
00:02:57,520 --> 00:03:03,520
perspective and pretty much throws out all of the bombastic verbose extra stuff you find in the

25
00:03:03,520 --> 00:03:11,680
textbook. So those are my two favorites. I do not pretend to be a C master at any level. Last

26
00:03:11,680 --> 00:03:16,320
year when I did the C, I had people that were C masters here, particularly VMT. Thank you for that.

27
00:03:16,560 --> 00:03:23,360
But showing me how C actually works and the gotchas and things and you may be asking, well,

28
00:03:23,360 --> 00:03:30,640
why learn C? So the answer to that is so that you can understand all the other things, particularly

29
00:03:30,640 --> 00:03:36,960
if you think you want to learn Rust. C and Rust to go very good together. C and go go very good

30
00:03:36,960 --> 00:03:43,280
together. In fact, I've heard go describe by Rob Pike as an easier C. I've heard the same thing

31
00:03:43,280 --> 00:03:49,040
about Rust that was a safer C. Well, if you don't know C, then you don't know how to contrast it

32
00:03:49,040 --> 00:03:52,720
with these other languages. So learning C, even if you never code anything professionally in it,

33
00:03:52,720 --> 00:03:59,520
it's still valuable no matter what. C was invented to write Unix. That's right. The first version

34
00:03:59,520 --> 00:04:10,160
of Unix was written in assembly and like, man, this is too crazy. We got to do something better

35
00:04:10,240 --> 00:04:14,480
and they did it really low level and really close to the hardware, had ultimate control of every

36
00:04:14,480 --> 00:04:20,080
bit and everything. And so they made C. They made C. Dennis Richie and the gang, they made C.

37
00:04:20,080 --> 00:04:24,640
Ken Thompson. And I still, I was just talking about this the other night, I think Dennis Richie is one

38
00:04:24,640 --> 00:04:31,200
of the most famous yet unsung heroes of our time died the same week as Steve Jobs, nobody knew.

39
00:04:32,320 --> 00:04:35,760
But everything you're using right now is written in C, literally everything

40
00:04:36,320 --> 00:04:48,080
at some level, including JavaScript. So anyway, it is frustrating. Rust can be frustrating if

41
00:04:48,080 --> 00:04:51,360
you have to fight with a barrel checker, but at least if you learn C, you'll understand it. Do

42
00:04:51,360 --> 00:04:56,400
I think you should learn Rust? Yes, that's a different question. But honestly, I really,

43
00:04:56,400 --> 00:05:04,320
really do think that you should learn C first, so that when you learn Rust, you'll see how awesome

44
00:05:04,400 --> 00:05:11,600
it is or where it lacks in other areas, you know, the pros and the cons. And there are,

45
00:05:11,600 --> 00:05:15,360
and you won't understand those until you understand C. So the best way to pick it up if you're an

46
00:05:15,360 --> 00:05:20,080
absolute noob and you just don't, you don't want academics speak too much of it is head first C,

47
00:05:20,080 --> 00:05:23,520
in my opinion, it's kind of fun. You write a game in there, you write an old school Asteroids game

48
00:05:23,520 --> 00:05:30,880
in there. Yeah, in C. And we never got to it last year, but, you know, and then eventually,

49
00:05:31,040 --> 00:05:38,240
you know, you're going to want to do something a little bit more probably, and maybe you want to do

50
00:05:38,960 --> 00:05:44,000
algorithms, mastering algorithms to see now, why, why would I do algorithms in C?

51
00:05:45,120 --> 00:05:48,400
People like, do I need to spend time learning data structures and algorithms? The answer is yes.

52
00:05:49,440 --> 00:05:55,680
Maybe not early on in your programming, you know, path. I never did. I didn't go to computer science,

53
00:05:55,680 --> 00:05:59,840
and maybe I'm a worse person for it. But I did eventually learn a lot of amazing things from

54
00:05:59,840 --> 00:06:03,600
the data structures and algorithms book, but I learned them on my own when I needed them.

55
00:06:04,160 --> 00:06:07,680
And you're going to see me coding a lot of that today, actually, later on. I'm kind of a thing.

56
00:06:07,680 --> 00:06:14,640
I'm going to be coding a parser and a compiler for a language called Kegamel using my other

57
00:06:14,640 --> 00:06:19,280
language that I wrote called Pagan. And I had to learn things like graph theory, and, and, you know,

58
00:06:19,280 --> 00:06:24,000
stacks and cues and all of these things. And I had to teach myself those things in order to do

59
00:06:24,000 --> 00:06:28,800
those things, those very fundamental computer science concepts. So but mastering algorithms in

60
00:06:28,800 --> 00:06:37,680
C, you know, Kyle at the beginning of the book, makes a case for having to have that and, and

61
00:06:37,680 --> 00:06:42,000
needing to know those things like it'll just make you, it'll just inform all of your other approaches

62
00:06:42,000 --> 00:06:45,920
to coding, even though you don't have to be able to spit it out in an elite code interview exam or

63
00:06:45,920 --> 00:06:51,440
something. It's more important that you know how these patterns can be applied at a macro level.

64
00:06:51,440 --> 00:06:54,560
And one of the reasons I think that mastering algorithms in C is such a good thing that C

65
00:06:54,560 --> 00:06:58,560
is a great language for this is because C by default doesn't come with those things.

66
00:06:58,560 --> 00:07:02,000
And the last time I said that, I had a lot of C coders say, Oh yeah, sure it does. And it does

67
00:07:02,000 --> 00:07:07,680
if you have the right library, for example, a map and associate of array, right? Or even an array,

68
00:07:07,680 --> 00:07:14,080
period. They're totally different. There's no, there's not even strings, technically speaking,

69
00:07:14,080 --> 00:07:20,400
technically speaking, C does not have strings, string has character arrays. So these things

70
00:07:20,400 --> 00:07:24,480
that we take for granted in these higher level languages don't exist in C, which makes C

71
00:07:24,560 --> 00:07:30,640
a really great language, in my opinion, for, you know, creating something that you actually

72
00:07:30,640 --> 00:07:35,920
have a chance of like maybe if you're writing your own bubble sort, and any official capacity,

73
00:07:35,920 --> 00:07:39,920
you're probably doing it wrong because it's been written safer and better in another library.

74
00:07:39,920 --> 00:07:42,880
But it doesn't hurt for you to write it and see because you can understand why,

75
00:07:43,520 --> 00:07:49,120
you know, why, why it doesn't have it. So I actually do think learning algorithms and data

76
00:07:49,120 --> 00:07:53,760
structures in C is a good thing. I think go is probably the next best thing to learn those

77
00:07:53,760 --> 00:08:02,160
kind of things. Imagine this array of characters being a string, exactly. And so anyway, that's

78
00:08:02,160 --> 00:08:07,360
all I have to say about C. If you want to learn more about C with me and struggle and suffer and

79
00:08:07,360 --> 00:08:11,200
understand what the stack and the heap and the constant section are and why they're there.

80
00:08:12,000 --> 00:08:18,080
But by the way, the head first book is phenomenally good at illustrating that entire thing. I never

81
00:08:18,080 --> 00:08:23,200
fully understood that until I read that book. And I still, I still feel like I'm missing things.

82
00:08:23,200 --> 00:08:27,440
But mostly because, you know, I have to go through it again every year because I forget. So that's

83
00:08:27,440 --> 00:08:28,000
what I think of C.

