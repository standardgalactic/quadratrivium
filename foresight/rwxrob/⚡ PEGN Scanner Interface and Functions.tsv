start	end	text
0	6960	Go. So, lots of changes if you've been following the keg and the peg and stuff I've been doing over
6960	14000	the years. I went to bed last night with my head working on a bunch of problems. I woke up and I
14000	20720	just had an idea I had to finish and I've been working on it straight since, God, I don't know,
20720	25520	like eight o'clock this morning. It's somewhat related to work. Don't worry, I'll make up the
25520	32400	work time tomorrow and the next day and the next day, but this is really important because it's
32400	39840	so key to everything else that I'm doing. So, let me try to stick with the highlights
41280	49360	and hell, why don't I actually make a, use my YouTube thing. We're going to make a directory
49360	60480	for this. We'll call it updates on peg. Actually, let's call it something more specific than let's say
60480	86480	a peg in scanner interface and functions. So, what I've done
90880	97920	so I mentioned, I mentioned the other day that interface
100880	108320	and functions. Is that right? Peg and scanner interface and functions. Yeah, I mean,
108320	116560	and she'll have a tool to do all that. So, okay, so
116560	127120	so my my peg in scanner implementation now conforms
130880	145280	now conforms to a common peg in not scanner interface so that other scanners can be implemented.
147520	151520	My people that conform to it.
157280	162000	So, the reason that I made an interface, why an interface
165280	170080	so that the library of scanner functions of scan functions
170800	176640	can be interchangeable
179520	188880	with different scanner implementations. And if that's, that is the main reason.
190000	196240	And let me show you what I mean by that. So, if you go to, so this is all, by the way,
196240	204560	this is all I actually put in the thing related in here. So, here's the pages that
204560	214960	we're going to. We're going to HTTP, github.com, rdxrub, peg in, peg in dash spec.
217040	219760	And that's pretty much it. If you go there, you'll find everything.
220720	223600	It used to be that I had it all over the place. And I used to have, there's this,
223600	228400	there's peg in dot dev, but that's kind of, it's kind of older,
232560	240400	but a little older and out of date. So, it's still there. I'm reforming the spec as we go.
243360	251840	So, we want, okay, so let me, let me show you why. So, if we go to the peg in scanner itself here,
251840	258720	right? So, I mean, what is the end goal? The end goal is for us to be able to parse any kind
258720	264960	of language. And we started with base ML, or base MD. Now, you'll remember I was basic MD.
264960	273040	I was writing a basic MD scanner. And here is the, the, the, so this was all brought about because
273040	292640	of this. So, I'm just going to put all of this precipitated by the basic, basic MD, parser,
292640	300880	that I was right. I mean, a scanner, parser, AST. So, I started writing that last night.
300880	306720	And that was all good and everything. But it became clear to me that there, I mean,
306720	310320	some of these functions, I'm going to show you one, some of these functions that I have written,
310320	317680	I have written them so many times. I swear, I have written, so like, I don't know how many,
317680	320480	so I didn't, thank God I didn't post it to YouTube. I'm not going to force it on you.
321040	328400	But I did, I must have written a, you know, a white space or an end of line parser,
328400	335040	probably a dozen times, different ways. Because I don't have, I haven't had a standardized way
337840	345200	to abstract the scanner stuff in a way that didn't require rewriting a scanner. I mean,
345200	350080	I've written probably, including an extremely complicated one. If you go back in my YouTube
350080	357840	videos, there's something I was writing, it was called go, was it go, go compatible,
357840	363760	peg in expressions? And it was actually go code that could be passed into symbols,
363760	367520	that could be passed into another function that would parse it, and then it would, you know,
367520	371840	it would do its thing. It was pretty cool. But every time I've written one, and then the most
371840	378400	recent iteration of my scanner that I wrote, I just ripped all that crap out. I was like,
378400	383840	I want the ultimate and minimal. And thank God I did that because I actually ended up
384800	387840	coming up with, so here's an implementation of the new scanner interface
391120	397440	that anybody can write. And all it has is, I mean, some of this stuff is internal,
398160	403520	but you know, this, let me show you the interface first, actually. So let's start with the interface.
403760	413440	So the scanner interface is in my types. The scanner interface is just a scanner. It's a
413440	419840	rune scanner that is aware of the beginning and ending of each rune that it scans, which can
419840	424000	be more than one byte, right? So people know this. So you can imagine a cursor going, you know,
424000	428080	through the, through the screen like this, like with an emoji on there. And sometimes it's a thing.
428080	434240	So in fact, the scanner has this idea of a rune cursor. And I used, I mean, I thought with
434240	438080	myself about whether to call it cursor or not, I didn't end up keeping a concept of cursor here,
438080	441360	but I might find I had it embedded and everything. I don't want to get into it.
441360	446000	So ultimately, a scanner is, it's a bytes buffer. And this is another reason I put this in the
446000	450560	peg. So this thing, all of this used to be under rtbx-rob slash scan. I had my own rune scanner
450560	460800	in there. But I realized, and I'm going to put this in my conclusions. So I realized that,
460800	473280	that my rtbx-rob scan was actually very peg specific. And what I mean by that is that
474000	480160	so a couple of really important specific assumptions are made by peg. Peg assumes
480160	484400	that you have infinite memory, which is, you know, the polar opposite of parsing when you're
484400	488400	using anything that you would get out of the Dragon Booker and computer science class.
489920	493280	And so, I mean, that's a huge thing. So if someone comes across my scanner, they're going to say,
493280	497040	oh, a scanner, cool, you know, they'll make think it's a finite automata, you know,
497040	500480	single look ahead kind of scanner. And they, they're like, what the hell is this thing?
500480	507600	It just flipped my whole data source, you know, byte, byte buffer and into memory. I mean, that's,
507600	513280	that's like, that's like an unorthodox thing to do. That's a sacrilege in this. You know,
513280	520080	that's what peg does. So, so I realized that the scanner that I have built and been using the most
520080	522960	recent one, which I've used all over the place, I'm using it all over the place. I'm using it in
522960	531680	Bonsai and everything is actually, in fact, I think I just broke Bonsai by, no, I didn't.
531680	540080	Bonsai's got its own scanner, never mind. Anyway, so I went ahead and, and implemented,
540080	544960	and I actually also deprecated the other one by, because I moved the entire scanner
545600	551520	into the Pagan package or the Pagan, Pagan module, because why? Because it's Pagan centric.
551520	556640	It's Pagan centric because a Pagan centric scanner, you can't even use it unless you load up a buffer.
557200	563200	And, you know, that's completely unheard of in other circles. So, so that was the first major
563200	568160	thing. That did mean, however, though, that the, the other one that I have, which I'm leaving out
568160	572160	there, because I'm pretty sure I have some dependencies on this scanner. And it's also
572160	577440	listed in my awesome go list and things. And I have some pretty intense breaking changes that I
577440	583360	added to this since version 10, because I changed some of the internal references and everything.
583360	588640	And the more I got changing it, the more I, see right here, it says fulfills Pagan scanner face.
588640	595040	It actually doesn't do that anymore. I broke that when I was doing the move. And then this is the
595040	603120	most accurate thing. So I've moved this entire scanner over to RTX ROM Pagan. And it is, you know,
603120	610560	implemented as, under the types. Good night. So it's implemented in the type here,
611280	616880	under types, you can see the scanner is here. It gives you the cursor type and a scanner type.
617440	620880	And you can look it up and it has a mark going to go to and scan and to finish.
621440	626480	I mean, nothing fancy there, right? And then I implemented, they included, you know,
626480	630960	reference implementation of the scanner that I use for the Pagan stuff. And this gets me to
630960	639520	where I was going with base, basic marked, my basic markdown parser. So, so here we have Pagan,
639520	645840	we have, so this is, this is the exact code that was in this other place. That's just been moved
645840	652560	and cleaned up. And I mean, really cleaned up and had some, some other things added to it.
652560	657760	For example, the fulfillment of the interface so that it can be replaced with something else at
657760	664320	any time. And let me, let me talk to you about why I decided to make it an interface again.
664320	669280	I mean, I started talking about that. But if you go to, so here's the interface, but as I was working
669280	676960	on basic MD, I started realizing that parsing end of line and end of block and paragraphs and,
676960	682560	you know, all of these things that are listed in Pagan are things that I need to do all the time.
682560	687120	In fact, I just add it in paragraph, right? These are things that I already need all the time.
688000	693280	And I'm like, I've always have intended to write, I mean, I've been really kind of hung up on
693280	698720	creating a code generator for all of stuff that, so you write Pagan and you end up with different
698720	706240	types of code, right? But to be more practical, I've started realizing all I really need to do
706240	711760	is write a scanner function for each of these and then reuse them. And then the ones that I,
712880	718080	that aren't in Pagan, that are specific to basic markdown or whatever, I'm writing Keg or whatever,
718080	726080	I can actually write those using exactly the same function signature. And I could even put them in
726800	731840	packages, you know, as a collection of first class functions, because they all accept the scanner
731840	739760	interface. And that is, you know, that is go interfaces shining the brightest, right? Because
739760	746880	that's what's exactly what you want to do with it. So what does that mean? So I have the scanner
746880	755760	implementation here, and I can, I actually chose to make this implementation fast and abstract,
755760	761280	so that if somebody chose to use it, they could use the direct references to the byte buffers
761280	766400	and stuff like that, so they can bypass the indirection from the interface method calls,
766400	771200	which is the reason I didn't do it originally, right? If you look at the highest performance
771200	775440	parsers out there, they do not have a lot of functional indirection, right? It's actually
775440	780880	one of the biggest complaints I have about the current code generator for Pagan that Quint
780880	787280	mostly made, and I last two years ago, is it has a ton of function indirection in it. And that's
787280	793920	been something I've been kind of like, irrationally hung up on. And I think I finally hit the middle,
793920	798560	the middle of the road here. So this particular reference implementation, which is a part of
798560	806160	Pagan, comes with a struct that you can use directly if you want to, which I probably will
806160	809920	do and really quick and dirty, you know, I mean, not the quick and the quick and dirty stuff,
810000	812960	I'll probably will use the abstractions because they're easier to remember and you can just,
812960	817440	you know, you can just swap them in and out. I don't need performance, right? But if I'm like,
817440	823120	really want to make a low level, really intensely often, you know, parsed grammar, then I can go
823120	834400	ahead and bypass the use of those things as long as I don't want to reuse any of the stuff I've
834400	839040	already write in Pagan, which brought me to think, oh, damn, you know, let's say I make a,
840000	844720	here's, here's my work, my workflow. Okay, so my, I imagine the workflow of making a grammar
844720	848720	or something like this, right? So in fact, this is even in a slide at Brian Ford, Brian, I was
848720	852320	looking at Brian Ford's peg stuff, and he has this in a slide about, you know, traditional
852320	857200	thing, use Lex and Yak and blah, blah, blah, and, and then, but, you know, the pragmatic way
857200	863200	approach to doing parsing these days is to write, you know, a generic kind of specification and
863200	868160	then to write a recursive descent parser. It's the standard way, the practical way to do parsing.
868720	872720	And let's say I want to do that, right? So I want to write a grammar, but I want to write it
872720	879360	quickly. Now, the quickest way to do it would be to do cogeneration with, you know, from Pagan
879360	884240	notation, which is something I still want to do. That's nothing that Pagan, that Brian Ford ever
884240	887920	wanted to do. You kind of wanted to get away from it because he realized it was just, it's just as
887920	892800	fast to just write your own recursive descent functional parser and, and then be done with it.
892800	896480	You don't have to deal with all the intricacies of cogeneration, not being exactly what you want.
896480	901680	You just write it, right? And, and I'm kind of on board with that idea because, you know,
902400	905920	it's, it's quite a bit of work to get it to generate just the way you want to. And then
905920	911600	which, which cogeneration method do you want? Do you want it to be highly efficient? Do you want
911600	914960	it to be used functional so it can be easily maintained? Are you going to rerun the generator
914960	919760	every time? Is it just giving you the first version? And, and so at a certain point,
919760	924880	you kind of come to the conclusion that probably the fastest way to create a parser is to just
924880	930560	write the thing because then, you know, you're going to, you're, you're going to be done. You're
930560	935280	going to be done with it and you're going to be able to move on to other things. So, um, and,
935280	945680	and that's kind of where I am. So, uh, also realized, uh, fastest way to develop, uh,
946640	953360	parser is to write Pagan and then function and then scanners
956480	961840	functions for recursive descent. Uh,
963920	968480	I mean, it really is. So by the time, you know, you get all the thing, just writing the Pagan
968480	974000	itself is good. I mean, that kind of gets you thinking about how it's supposed to be implemented,
974080	979680	but you're also not wrestling with Pagan syntax and stuff, uh, in case you get it wrong. Now,
979680	984080	you should probably do that, but let's say you don't represent it perfectly and Pagan,
984080	989440	who cares? The Pagan is just there to help you understand what the parser is going to,
989440	993520	how it's going to behave. Um, and then you can, you know, compare it to that, you know, just,
993520	997520	just, you know, visually and get to your, get to your point, but you can get busy kind of writing
997520	1003040	your parser. So, so, but, you know, along those, those lines, assuming that you're going to write
1003040	1006640	a parser, right? You're going to go ahead and write a parser. What are the obvious building
1006640	1010480	blocks? I mean, code generation is awesome and everything, but, but what, what would be the
1010480	1015680	other way to do this if you didn't have code generation? Well, it gets pretty obvious that
1015680	1023760	it would be a standardized library of scan functions, uh, that, that you regularly reuse,
1024720	1029600	right? And if you, as long as you make those export in your public, make those public, you can,
1029600	1033120	you can pull them in and you can tweak them and make them more efficient and other people can
1033120	1037840	contribute their own. And, and you have, you know, you ended up getting this ecosystem of scanners,
1038400	1043280	uh, of, you know, because that's really, the scanners are really the secret because if you
1043280	1048400	have a scanner, you can scan it and if it scans successfully and you would get a true at the
1048400	1053040	end of that. I mean, and this is very hastily, right? If at the end, if you get a true after that,
1053040	1058080	you're done. You're under the next thing. If you don't get a true, then you're guaranteed that
1058080	1062560	the scanner didn't do any advancement because it snapped back. And you're going to see this all
1062560	1066960	over in, in my implementation of functions, which we'll show you in a second, because that is how
1067840	1073840	you do this. And, and that is exactly how Brian Ford talks about it in his paper. It's like the
1073840	1079520	difference between, you know, the traditional scanner and, you know, parser kind of approach.
1079520	1084960	And this is that you can scan ahead as far as you want and you can keep track of how many
1084960	1090800	matches you have. So you can be very greedy if you want and say, okay, so did I find anything?
1090800	1094640	Yes, I found like 10 of them. And then I keep scanning and like, oh, hey, well, like, okay,
1094640	1099600	I stopped. So then I like roll back to the last one that was successful. Or if there were none
1099600	1105440	that were successful, I roll back the scanner all the way to the beginning. So, so this idea of
1105440	1111840	snapping the scanner back and moving it and around a thing, that's a very fundamental part of the PEG
1111920	1117680	architectural approach. Because you have memory, you have memory that you can fly around in. And
1117680	1122320	very quickly, by the way, I mean, you know, moving pointers around in memory is crazy, crazy fast.
1123040	1126640	And you've only had to do the one load. And so, you know, all these things that are doing like
1126640	1131840	single byte loads, in order to do that, you've already had to buffer your data at some point. So
1131840	1135840	you've already had to do the buffering. So, so the thing is cool about PEG is it assumes that
1135840	1139520	you're just going to buffer all of that upfront. And then you're going to break up your content
1139520	1142880	into manageable chunks that fit within, you know, reasonable amount of memory that you're
1142880	1147520	going to be parsing. You should put limitations in there and stuff. And that's a part of the grammar
1147520	1153200	design, which is another reason that PEG is a fail, because as wonderful as it is, it does not allow
1153200	1158720	you to put limitations and constraints on this size, which is why I made PEG in. So when I say
1159280	1167600	things like, I only want, you know, two end of lines here, I can specify two end of lines. There's
1167600	1176240	no way in the original PEG specification example to indicate amount, which I just think is crazy,
1176240	1181760	given the fact of, that regular expressions in ABNF have been doing it forever, and ABNF, but
1181760	1186160	PEG decided not to do that. So that's one of the reasons I made PEG in, because we clearly want
1186160	1191040	the combination of those things. All right, so let me go back to here. So I went ahead and I
1191040	1195120	implemented a white space function right now. I could have probably automated this, but let's
1195120	1200880	look at what it looks like. So if we go into the PEG and scan, and you're probably wondering, well,
1200880	1206080	why did you name it scan? Because I wanted it to read well. So let me show you the, the examples
1206080	1212560	here. These are go testable examples, and they are public. You'll remember maybe when I did basic
1212560	1219520	MD that I kept a bunch of my scanning, not public. I was like, because I didn't want people to become
1219520	1226480	dependent on my scanner functions, right? I mean, I'm just making a basic markdown part. So I don't
1226480	1231440	want people to be, you know, including my thing, because they want my specific implementations
1231440	1235920	of these. And that's one of the reasons I started thinking, hmm, I should probably think more deeply
1235920	1241760	about some of these scan functions that are going to be reusable. And I should probably put them
1241760	1247680	somewhere where they could easily be reused by me and others. And that's what got me to do this.
1247760	1252640	So I've created a convention called sum, which is just a nice happy way. It's like, you know,
1252640	1256800	go, they like have must and compile and things like that. So I created a convention where you
1256800	1260800	put sum in front. These are all documenting the design considerations on the read me page, by the
1260800	1268720	way. But sum means, you know, zero or more white space or one or more white space. So if I have
1268720	1273440	example sum WS, so, and then I the reason I named this sub package scan is so that we would get
1273440	1279360	these wonderful readable lines here scan dot sum white space and then pass in the scanner.
1279360	1284160	Now you might be asking as many, many people will tell you that have done scanners that
1284160	1290720	they implement the scanner as a class, which I think is disastrously bad architectural decision,
1290720	1297840	because you cannot do anything with it at all. And tell you expand the class,
1297840	1303520	that is the primary reason that people like Jim Copeland and others hate class based object
1303520	1310160	oriented programming. It is so concrete, you can never extend it, not without re implementing the
1310160	1315600	class or subclassing it by doing it this way. I can use first class functions is a very functional
1315600	1319840	approach. I can use first class functions if I want, I can use it from a package, whatever,
1319840	1327040	because the scanner is an argument to the function. And so as long as the scanner fulfills the
1327120	1331840	interface, this is why interfaces are king. This is why interfaces are part of solid,
1331840	1336960	even in modern Java development. If you're not doing this, if you're writing a scanner,
1336960	1341840	writing a class and extending the class with all of the different types and then having to do that
1341840	1345120	every time you're doing it wrong, in my opinion, because you're never going to be able to extend
1345120	1349200	that in any way that's going to be reusable for anybody. And maybe you don't care about that.
1349200	1354000	I do. I want it to be reusable. I want to, I want to create, ultimately, I want to build up,
1354000	1360880	you know, hundreds or more scan functions that can be used with anything whatsoever
1360880	1365440	that implements the scanner interface. And that's why interfaces are so amazing.
1365440	1370880	So I pass a scanner interface, I say scan some WS and I get a true or false. So this prints out
1370880	1378000	false because the first number is a one. Now I added a constructor. There's really not constructors
1378000	1382800	and go, but it's the closest word for it. And this takes an optional argument. Now constructors are
1382800	1386960	very, very high level. So they don't have to be performant, right? Especially since you're not
1386960	1393520	going to be buffering a lot. So I put an optional parameter to on the constructor. If you pass in
1393520	1401760	a string or a reader or a bytes buffer, any of those things, it will work. And it will just
1402480	1408240	slurp all of the thing into memory. And then it will allow the scanner to work on that, that bytes
1408240	1413520	buffer. And so then we do this to say, so, so you can see here, we, we, it's, you see, it was false
1413520	1420240	that it's not currently the scan WS failed here. Because why? And you'll notice too that it didn't
1420240	1426800	advance the, it didn't advance the, it's not supposed to. That actually looks like a mistake.
1428160	1432480	That might be a mistake. Let me check here. Oh, no, no, no, no. Okay, let's do this.
1433200	1439280	Wait, what? Advance to nothing at all output.
1440960	1446160	Example sum WS. I think I might have a problem with this one. Anyway, it's supposed to,
1446800	1449600	I just barely fixed these. That's why I want to make sure it's okay.
1450640	1456400	Sum WS. Is it not, isn't that working? I'm going to go try something. Go test,
1456400	1467120	run sum WS. Well, let's turn a trace on. Oh, this is cool. I finally got traced to working again.
1468080	1475360	So trace, that'll turn trace on. And when we run it, we should be able to see every step of the way.
1476640	1484000	So the first call to scan, got it. That's what with the first, that's every time,
1484000	1488720	every time scan gets called, it prints it. So scan, scan the one in, and that shows us the,
1488720	1491920	from between zero and one, and then what's left in the buffer and there's a space.
1491920	1496560	And then it shows we scanned a, a space and that was between one and two. It could be one and three,
1496560	1502400	depending on the size of the rune. And then as the buffer is empty. So, so that shows it's doing
1502400	1510880	what we wanted to, I just was, oh, I know why. It's doing that because it's actually, because
1510880	1516320	this actually did do some scanning and it did not reset. Actually, that's a, that's a, that's a
1516320	1522320	mistake. That's a mistake. I need to fix this. This, because it didn't scan, it should not have
1522320	1525760	advanced the buffer at all. It should have been, I've got to do this. This is a nice catch.
1527360	1531920	And again, this is just, this is the bug in this, in the scanner function only not the scanner itself.
1533280	1538080	Trace is internal. Trace is, Trace is a part of this scanner implementation. It's not part of
1538080	1544560	the forced interface. No, it's not. You don't have to have a scanner in there. It's, that's part
1544560	1549520	of this scanner implementation. So, you know, I don't want to burden people with those kind of
1549520	1556800	details that they, they want to do their own, they can, right? So, I mean, but yeah, you could
1556800	1561200	extend that and do what you want with it. So this is, this is actually wrong. This should have been
1561200	1564400	x00 and it should have been
1566400	1572320	zero to zero and then it should have been a one here. That's what it should be. And then when
1572320	1579120	you do the scan, it should go through and then it should have been a one and a zero to one.
1581120	1587840	And then, and then that should have left us with a space and it should have been false and then
1587840	1597520	it should have been true. This one should have probably printed true. Yeah. Something might
1597520	1604000	be wrong with that today. All right. So that, that's how it should look. So let's, that means
1604000	1608480	there's a problem with my function, my scan function, which is what I was debugging before,
1608480	1612480	but let me show you how to do this. So there may actually be a problem with my mark and I'm,
1612480	1616080	I'm hoping not to, I think, I think that might be, there might be something wrong with my mark,
1616080	1619680	which is relatively new. But the point is, I don't know if you saw the functions I was writing
1619680	1627680	yesterday, but these are way, way simpler, right? They just have to scan and check what the runes are
1628320	1634960	and scan again and the, the idiom is the same no matter what. You take a, you take a bookmark to
1634960	1640000	it at the beginning and you revert back to the bookmark if you're, if you didn't find anything,
1640000	1645200	right? And you leave things as they are. Otherwise you let the scanner happily proceed along
1645760	1649440	and it's not like there's a lot of cash in there so that you, you know, you'd have problems there.
1652080	1655120	But yeah, I have, I have a problem with this one. I got to come back to that. I can't see it right
1655120	1661040	out hand, but so this is actually, you know, this, this is supposed to scan as much white
1661040	1669600	space as possible. I think the problem is, I don't know, we might be getting ruined. I don't
1669600	1673200	know, I'll have to go debug this one. But if, if I wanted to just debug this one too, I could
1673200	1679920	also just do this. I could just do s.trace and turn on the tracing in here while I'm doing this
1679920	1687440	debugging. I can put it there in the test either way. Oh, it's not, that's right. I forgot about
1687440	1692000	that. Man, this is going to be interesting. Yeah. Cause you just said, is that in the, is that in the
1692000	1702080	debug output? Interesting. Yeah, I just realized I'm saying, because I locked down the interface
1702080	1704800	and I'm going to keep a bunch of stuff out of here. I'm not going to be able to do because,
1704800	1708960	because this is, expects a scanner interface and that means only things that are, are defined in
1708960	1713520	the scanner interface can, can turn on. I wonder if we should make trace into the part of the
1713520	1718240	interface. We should say you need to implement some form of activating trace. I don't think we
1718240	1723680	should. I mean, I think, I think we should leave that in the tests stuff because people can set up
1723680	1727920	their own test cases and then, and then call it that way. I, I, I don't know. I thought about it
1727920	1734160	for a second though. This is just as good, right? Having the trace appear. Because this is, is, is
1734160	1741120	using a specific scanner that fulfills the, the interface and therefore it can have extra things
1741120	1744560	in it like trace. The other one doesn't have anything, any knowledge of it at all. And it
1744560	1749120	shouldn't, right? We don't, that's again, I want to, I want to double check that everybody understands
1749200	1755680	this. So we do not want people writing, you know, Pagan or any
1758880	1765040	scanners functions that are going to be doing fancy things that are not defined by the interface.
1765600	1770560	Because if you do, then they won't work with interchangeably with other scanners.
1771680	1775840	And that, that's not ideal, right? We want to be able to have people write
1775840	1780000	very highly optimized scanners however they want. I mean, all of them obviously are going to have the,
1780000	1783520	the downside of having to call out to a function to do their thing. But that's,
1783520	1787200	it's not too bad. But that way people can supplement the scanner that I've made or make
1787200	1791680	their own or something like that. And they can, they can share all of these scan functions with
1791680	1796400	each other. And we can make libraries of scan functions that do different amazing things. So
1796400	1800480	it's basically like creating a library of regular expressions. And if you look at
1801040	1808400	the Pagan stuff that I've been doing, you can see that we've got a lot of functions to write.
1808400	1814160	So over the next year or two, I'll be implementing individual scan functions
1814720	1822400	for the different types of stuff that is included here and in our tokens. And yes, we're going to
1822400	1828640	have, we're going to have functions for things that are strictly static. And the reason is that
1828640	1833200	is to keep everything functional because we need to be able to pass the scanner to it, right?
1834960	1838640	We don't, if we didn't do that, we would have different kinds of dependencies. We would have
1838640	1845600	dependencies on the Pagan like implementation to some degree, I think. And so that, I mean,
1845600	1850640	it's not that much extra. Before I was like calling out to a function just to parse the
1850640	1854240	references to the other functions. So there is, it's not going to be any less performant than
1854240	1857920	any of the other stuff. And that's really premature optimization. If somebody really,
1857920	1863120	really, really wants that level of performance, they probably should write their own scanner and,
1863120	1868160	and, you know, maybe just use some of the scan functions without, without it and not, and not
1868160	1874880	bibbed. So, but I will be writing like, I'll probably be auto generating a bunch of go code to,
1875600	1881360	to, you know, to, to, to, to stand for each one of these, these scan functions. And then they'll
1881360	1886080	all be under scan dot whatever. So I'll be able to just on any project, just be able to import
1886080	1892480	artifacts, Rob slash Pagan slash scan, and I can get any and all of these that I want.
1894080	1899120	And it's not that big, actually, because it's just text parsing, right? It, it seems big because
1899120	1902800	it's a lot of code for us to write, but it, but it's most of it's going to get inlined and the
1902800	1907120	size of the package isn't going to be too big. And, and then we can, we get kind of like this
1907120	1912800	regular expression engine that's on steroids, because now we can just write our own recursive
1912800	1917680	descent parsers as easily or if not easier than we could write regex, you know, complex
1917680	1921680	regex expressions. And that, that to me is kind of the Holy Grail, because that's what I want to do.
1921680	1925520	I, I have like four or five grammars that I want to finish that I'm kind of waiting on.
1925520	1932560	And this is, that's, that's where, that's where it leaves us. All right. So I need to come back
1932560	1936160	and fix this white space one. Let's go back and look at one that maybe works better. So
1936880	1942480	here we have, and I put the pagan line up here. So an end of the line is, you know,
1942480	1949280	we scan the found Boolean stuff. We don't really need that. I could have just done a return right
1949280	1958880	here and call it a day and not gotten all the way down here. And the reason I didn't do that
1958880	1965840	initially is because I wanted to think about how this code could be auto generated. But
1965920	1973840	now that I'm looking at it, I am totally okay doing that. So, so we can just do a return true there.
1975520	1981680	Here we can just do a return true. Yeah. And if we make it down this far,
1982560	1987680	that means we didn't find it. And we need to do that. So that this is, this is not hungry.
1988320	1992960	If you're using something that's hungry. Yeah, you might, you might have a different problem,
1992960	2002080	right? Because, you know, you need to, yeah, you need to, if you're having something that's like
2002080	2006720	hungry and greedy, you need to like count all the fines and you'll see that, you'll see that kind
2006720	2017360	of thing happening over time. Oopsie, did I refer to found in here? Return false. So I mean,
2017360	2021760	that's a simplification we can do. Again, these are, I want these to be highly optimized. Another
2021760	2027840	reason, by the way, that I think code generation is probably the wrong way to go. And the more I
2027840	2033520	keep coming back to this, the more I think that hand crafting a recursive descent parser from a huge
2033520	2039920	library of existing scanners, scan scan functions is a better idea. Because of this problem that you
2039920	2047120	just saw, the optimization I just made is the kind of thing that would take an extreme amount of
2047680	2052400	intelligence in the code to be able to write it in a code generator. Whereas if I'm just writing
2052400	2058000	the parser, I can take, I can do tricks and stuff inside of my functional parser to make it really,
2058000	2064720	really optimized for this particular scenario, you know, and, and I can do things that couldn't be
2064720	2070480	done if I were to just to generalize the generation of this code from the syntax. So what I'm saying,
2071120	2078000	and I'm going to put this in here is that I am, I'm kind of souring on the idea of code generation.
2079920	2093280	So I'm souring on the idea of Pagan to code generation, because it's removing, you know,
2093840	2104080	it, it, it prevents, it precludes optimizations that only, that only a person could do.
2105200	2109600	And, you know, people definitely do this. And if you're going to, I mean, at the end of the day,
2109600	2115200	we're writing a compiler when we do that kind of thing. And, you know, there are people that have
2115200	2120560	spent their entire lives dedicated to compiler optimizations. Well, one of the reasons that
2120560	2125840	having a human write a scan function is better is because depending on the language they're writing
2125840	2134240	it for, they might already know how the compiler is going to inline that code. So, so, you know,
2134240	2139200	having some generic size rendering of the code may not be able to take advantage of those things.
2139200	2144320	And, you know, premature optimization, yes, right, we want to avoid premature optimization, but,
2144320	2149920	but at the same time, we don't want to be forced into doing things that, that we could do
2150960	2155120	because we know about them later on. We could come back to the code
2155120	2158880	and we could actually say, well, okay, let's optimize this one, because this is that my
2158880	2164240	pagan function for parsing, you know, wide space, the most important thing that I'm ever going to
2164240	2168080	write, it's going to be used by millions of people or whatever. And, and I should really,
2168080	2173120	really optimize that one function. And then everybody can spend their time optimizing the
2173120	2179520	functions that we have for parsing those specific things. And we can maintain a community library
2179520	2183600	of this, rather than having everybody write the best, you know, their own wide space parser,
2184560	2189360	right? So we can actually have a collective community of contributions that from people
2189360	2194640	who know about parsing, or really, you know, amazing Go specialists who have, have, you know,
2194640	2199600	know how to optimize code based on what they're, what they know about inlining. So, so yeah,
2199600	2206560	no more code generation, just a lot of pre-generated libraries that are immediately importable.
2206560	2211280	And then we can just write, you know, in if statements and switch statements, and you can
2211280	2215360	write your own thing really quickly. And I think that's really going to be the new normal
2217120	2225920	useful form overlooks. Yeah. And so, so, so yeah, I think, I think, I think that that's,
2225920	2234320	that's kind of how I am with this. That is why you're developing anything. Yeah. I, I, I think
2234400	2238640	that the code generation thing, I mean, this doesn't mean we're not going to do some code
2238640	2244880	generation, right? But we're going to statefully code generate like all the functions for the,
2244880	2252160	the 200 or so Unicode classes, which by the way, already have functions. Yeah. So for those kind
2252160	2256320	of things, we're just, that's exactly how Go does it, by the way. Go takes that document,
2256320	2261680	and it generates the Go code from straight up from the, from the Unicode specification document.
2261680	2267440	And it has a, you know, a whole library of, of, you know, true or false kind of things, right?
2269200	2275280	But it's not a scanner. And so the only thing we're going to have to do in the Go one is
2275280	2280800	basically the same idea, but we're going to say, okay, is this thing a thing? And then,
2280800	2286720	and then we'll make a sum variation as well, so that it'll be like one or more of those things,
2286720	2292800	right? And, and all that code will get auto generated. So we'll have a pretty big library
2292800	2297360	of scanners that'll be developed that you can then make your recursive descent
2297360	2303040	parsers from. And maybe we can get somebody else to actually think it's a good idea besides me.
2306880	2310240	Optimizing a lot first is that you can find you don't need the functions you're optimizing. No,
2310240	2315120	that's right. So I'm saying, so a lot of them, yeah, you could combine the two things together
2315120	2322320	or something, right? Yeah. So, so I think, I think I'm kind of happy with this where we're
2322320	2329920	going with this now. Now I still have this, this bug here, my white space bug. But the other one
2329920	2340240	is fine. Let's, let's try to run that one. Let's do run. What was it the end of line? End of line,
2340240	2347360	I think, right? Oops, we need to let's turn scanning on end of line. So you can see it
2349280	2358560	end line. Then there's lots of in lines. So she was the carriage feed one. Actually,
2358560	2365280	let's just turn it on for the whole, the whole scanner. Yeah, scanner scanner has a trace for
2365280	2369200	the whole entire package if you want to turn tracing on on everything.
2371840	2380560	Yeah. Trace equals, I'm probably have to do an init here. Trace equals one.
2381440	2385360	Yeah, that's going to say you need to put that in an init. All right, fine.
2387360	2392720	This is just for now. There's other testing ways to do this, but I'll just do that for now.
2392800	2399680	So we could go test. So actually, this is going to show every single parts that we did.
2400320	2406400	I'm so happy with this. So when you turn the trace on, when you turn it on this way,
2406400	2412400	it'll actually give you like the full thing. So here it was, it was, it, it read the first
2412400	2417600	carriage return and then a line return and then another line return. So that, that was that one
2417600	2420560	that we did. And there's another one. So these are all the different ones. There's no other printing
2420560	2424880	statements going on in there, but you can kind of watch what's getting parsed as you go
2426560	2429840	and check on it. And you can go, go look at that and see if you like it.
2431440	2434240	But yeah, I mean, it's working without that portal pass. I just got that white space one
2434240	2438800	I have to figure out. So I think that's enough for this video. I just, I just wanted to show
2439360	2445680	where I was. Some of the, I mean, I don't got the, the, the end paragraph turns out to be end block.
2446400	2450880	So remember yesterday I was doing basic markdown and I was like, hmm, we need to
2450880	2455280	delineate our blocks. Well, what is, what do we have? We have any number of spaces
2456800	2464240	and then a greedy include of, of white space and line returns, you know, and that's what this is.
2464240	2468720	So I had to actually re, I had to rewrite it and say, do I have the end of,
2468720	2474320	do I have the end of the data? Do I have an end of line and then the end of the data?
2474320	2478960	Or do I have two end of lines, which are, you know, the greedy thing and then the white space
2478960	2484640	splat and, you know, peg, uh, repeat operators are greedy by default. So that says, grab as
2484640	2488720	much white space as you can. As far as I know, I might have that wrong, but grab as much white
2488720	2496000	space as you can and then make sure you have this at the end, right? Now it may be that I have to,
2497280	2504240	uh, uh, if I were to put this up here in the front, then it would be non greedy. So it would
2504720	2510160	it would get, you know, it would, it would get the first one. So the first match of,
2510160	2514640	I had that happening before I had the first match of, of a line of double line returns
2514640	2519200	and it got the first one. So that's how you, you do non greedy is you put that stuff up in front
2519200	2522880	here, but you have to kind of look at the peg and syntax, the peg syntax to get that. That's,
2522880	2528560	that's from Brian Ford. That's not for me. Uh, but, and I still have to go look it up here as well.
2528560	2531520	But it's, I, once you get it, it's much easier than regular expressions. It's not,
2531680	2534320	actually it has positive negative look ahead and all that kind of thing,
2534320	2537680	which regular expressions, depending on which engine you're using, don't really do well.
2538880	2542640	Not to mention, you know, the ability to capture thing. So, and, and I use the,
2542640	2548960	I use the block here and go to, uh, which I actually prefer to for loops because
2549920	2555680	they just are so much cleaner. Um, because you just know you're going to go up to the top again
2555680	2561040	and you know, you know, the thing I like about it's much easier. I mean, it's much harder to
2561040	2567520	write an infinite loop with a labeled block than it is with an infinite forever loop,
2567520	2573040	which is just for, and I used to do them that way. Um, because, I mean, you definitely can,
2573040	2578560	but you have to explicitly create an infinite loop that keeps going to the top again, right? So,
2578560	2585120	it's kind of like a do while. Um, and you see this all the time in parsers. This is in go, it's in,
2585120	2592080	and goes compiler for the language that go to is a very real, uh, solid thing to use for,
2592880	2597920	uh, for compilers and for parsers and scanners. And it saves you from any kind of functional
2597920	2602480	recursion, which is the devil when it comes to performance and parsers because you hit, you hit,
2602480	2607440	um, you hit, you know, you hit, uh, indirection functional loops, uh, functional recursion loops
2607440	2612000	and stuff like that. Some languages is the preferred way to do it, but, but, but most
2612080	2616320	of the languages or not, most of them want you to just stay within there and kind of
2616320	2620320	figure out a way to short circuit and go back up to the top. And it's more performant that way too.
2620960	2627840	So this one has to have the whole notion of a found Boolean in it because even if I find one,
2627840	2632160	I still want to look for more. I still keep wanting to look for more until I get,
2632160	2637200	I'm greedily get the, the last one, right? And I, before I added a notion of a, of a found loop in
2637200	2642000	that I, I wasn't getting everything. And so what it does is it keeps getting stuff until it hits
2642000	2648320	something that is not valid. And it's like, okay, I finally run out, but did I ever find anything
2648320	2654160	along the way? I was like, Oh yeah. Okay. Well, what was the last one that I did find? And, and then,
2654160	2660960	you know, it can, it can tell you that thing. Um, and, and that's what the go to is. Um, this is
2660960	2666400	actually wrong. I'm just realizing I have some problems with this. Yeah. It's funny because
2666400	2670720	now that it's cleaner and I've got to spend my whole day fixing up all of this syntax, I can see
2670720	2677280	that this is probably wrong because this is, this is going to, uh, this is, if it, if, oh no, no,
2677280	2683040	I'm sorry. No, I'm, I'm sorry. This is only if it's not found. Yeah. This is only if it's not
2683040	2688240	found. Yeah. So scanners do not advance. So the rule, this is a kind of a hard thing to,
2688240	2692240	to come up with when you're trying to figure out how to make your parsers and functions and stuff.
2692240	2700960	But the easiest rule is for a scanner is if it scans, it returns true and it advances the scanner.
2701520	2705680	If it doesn't to the next thing, right to the beginning of the next thing, it doesn't scan
2705680	2711040	that thing. It puts it right to the beginning of it. If it doesn't, if it doesn't scan anything,
2711040	2717680	it needs to leave the scanner exactly how it was before it was called. And in order to accomplish
2717680	2724720	that, you need to take a bookmark so that you can snap back to it, right? And I put go to here,
2724720	2729200	I could probably do snap, but that would people think I would snap the shouting or whatever,
2729200	2732640	go to use the one I'm going to use there. So, so that actually sets it to the cursor and the
2732640	2739840	cursor is three things. It's the byte index in the buffer by buffer array of the, uh, you know,
2739840	2745840	of, of the first item in, in the room, the first bite of the room. Uh, it is the room itself,
2745840	2749120	a copy of the room. That's what, that's what we get when we set, when we get, when we get,
2749120	2762080	go get dot rune. Um, and, and it is, um, it's also the, uh, uh, the, the, the, uh, end, the end of
2762080	2769440	the room. So the, the byte pointing to the byte array to the beginning of the next thing, which is
2769440	2773600	like maybe one or two, three things away. And that's, that's, that's where we got this thing.
2773600	2781520	So we get like a three to four. If, if I were to scan like, uh, uh, tomato emoji, um, and I
2781520	2785920	don't know where to go back to mark point, if it found the end of paragraph, it considers it advanced
2785920	2791520	and no more go back to mark the point. You don't need to mark the point because the scan automatically
2791520	2798160	advanced it. Yeah. Because any of the scans that fail, I'm pretty sure I'm gonna have to go back
2798560	2805120	but there, there are cases, uh, uh, yeah, I read that. I have that book. I wrote that years ago,
2805120	2812240	a couple of years ago. I have the PDF somewhere. Yeah, actually bought it. Uh, it's, there's that,
2812240	2818720	there's that one. There's two or three go scanners in the go code base. And then there's a website
2818720	2822560	that has right your own, uh, scanner and go. There's like, those are the three main things
2822560	2827600	that I'd recommend if you want to start doing this kind of fun stuff. Um, but yeah, they're,
2827600	2833520	they're pretty cool. Um, and you know, I'm obsessed with parsing. I'm not very good at it,
2833520	2839440	but I'm obsessed with it. So, so anyway, um, mostly I'm obsessed with language and so
2840240	2846320	grammars are a part of language and that's why I like it so much. Um, this is something I don't
2846320	2850800	understand. What I want to do is I want to be able to specify my bonsai command lines from a pagan.
2850800	2857200	Wouldn't that be cool? Uh, there, there, there is a writing compilers. Oh really?
2857760	2864720	Yeah. I have to go look at that one. Um, so, so yeah, I mean a compiler is the next step,
2864720	2867840	right? It's like bringing it all together and doing something with the thing you get out of it.
2867840	2872880	And we, we don't have any AST, any notions of AST going on yet. That is coming. Uh, I already
2872880	2878160	have all the data structures for that developed that I'm going to use for my AST. Um, and,
2879040	2884000	but yeah. So, you know, you got to have push and pop for ASTs. It's like crazy. Um,
2884320	2890160	yeah. I mean the hardest part, the hardest part with the AST, and we're going to get into this,
2890160	2899200	is how to throw away, uh, elements of the tree that you, you can't just pop back and kind of,
2899200	2903840	you know, you can't just pop back to the latest bookmark when you're doing parsing because you
2903840	2909440	have all this data that you parse that you can't throw away. And it's very complicated. You can't
2909440	2914400	throw it away because you don't know how much of it to throw away. And, and that's, that's going to
2914400	2920400	be a big piece of this that might, that might, you know, I still have other things to do. This
2920400	2927280	isn't my main, my main thing. So, uh, but I, I am interested in this. Um, so far the test case on
2927280	2930320	this is so good, so important that you have lots of test cases on this. I'm pretty sure this one
2930320	2937200	is good. Um, but I don't know, we'll go take a look at it later. And, and, and you know, that,
2937200	2942400	but I, here's the thing, I don't want to have to keep revising all of my parsers. I wrote,
2943200	2948880	I mean, I, I, I'm going to go back and open up my old pagan, uh, dev, uh,
2949680	2955520	you know, I wrote an entire recursive descent parser for the pagan language itself, if I have them.
2956560	2964880	Uh, and so that's going to be something that we're going to come up with later, but, um,
2965680	2968640	but, but so I don't, I don't, I don't know, I don't know how that's going to,
2968640	2972960	that's going to end up going down. Uh, because I, I want to be able to pull out some of that
2972960	2976400	stuff from here and just reuse it because I, I've already got all the algorithms there and I can
2976400	2982080	just reuse those algorithms. So that's pretty much it for YouTube. So if you want to stay tuned and
2982080	2985920	to watch stuff about the pagan and keg stuff, uh, I'm probably not going to be working on much of
2985920	2991200	this. I hopefully not the rest of this week. I have got a ton of work to catch up on, uh, that
2991200	2997600	I'll be doing like for the rest of tonight and tomorrow morning early and, um, and we'll be,
2997600	3004320	yeah, I'm going to be doing, you know, a lot of that stuff. Um, but this is sort of related to
3004320	3008000	stuff we want to do at work in terms of like documentation validation. That's where it
3008000	3011760	came from originally. And that's, if you want to stay tuned, we, we'll do some more of that. I,
3011760	3018480	I am going to implement basic and D M D is, uh, as a, as a grammar and I'm going to be using this
3018480	3023760	and we should get pretty high performance on it actually. Uh, we should have performance that
3023760	3030080	rivals gold mark, uh, which because it doesn't have as much to do. Uh, so we should have performance
3030080	3035200	that rivals gold mark, which is pretty much the go to standard for, uh, markdown parsing and go
3035200	3039360	right now. And we'll be able to compare and do some benchmarks on that a little bit later.
3039360	3051200	Um, so have fun parsing and come on by sometime. Talk to you later.
