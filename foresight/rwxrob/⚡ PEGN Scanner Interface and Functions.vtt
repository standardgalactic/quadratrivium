WEBVTT

00:00.000 --> 00:06.960
Go. So, lots of changes if you've been following the keg and the peg and stuff I've been doing over

00:06.960 --> 00:14.000
the years. I went to bed last night with my head working on a bunch of problems. I woke up and I

00:14.000 --> 00:20.720
just had an idea I had to finish and I've been working on it straight since, God, I don't know,

00:20.720 --> 00:25.520
like eight o'clock this morning. It's somewhat related to work. Don't worry, I'll make up the

00:25.520 --> 00:32.400
work time tomorrow and the next day and the next day, but this is really important because it's

00:32.400 --> 00:39.840
so key to everything else that I'm doing. So, let me try to stick with the highlights

00:41.280 --> 00:49.360
and hell, why don't I actually make a, use my YouTube thing. We're going to make a directory

00:49.360 --> 01:00.480
for this. We'll call it updates on peg. Actually, let's call it something more specific than let's say

01:00.480 --> 01:26.480
a peg in scanner interface and functions. So, what I've done

01:30.880 --> 01:37.920
so I mentioned, I mentioned the other day that interface

01:40.880 --> 01:48.320
and functions. Is that right? Peg and scanner interface and functions. Yeah, I mean,

01:48.320 --> 01:56.560
and she'll have a tool to do all that. So, okay, so

01:56.560 --> 02:07.120
so my my peg in scanner implementation now conforms

02:10.880 --> 02:25.280
now conforms to a common peg in not scanner interface so that other scanners can be implemented.

02:27.520 --> 02:31.520
My people that conform to it.

02:37.280 --> 02:42.000
So, the reason that I made an interface, why an interface

02:45.280 --> 02:50.080
so that the library of scanner functions of scan functions

02:50.800 --> 02:56.640
can be interchangeable

02:59.520 --> 03:08.880
with different scanner implementations. And if that's, that is the main reason.

03:10.000 --> 03:16.240
And let me show you what I mean by that. So, if you go to, so this is all, by the way,

03:16.240 --> 03:24.560
this is all I actually put in the thing related in here. So, here's the pages that

03:24.560 --> 03:34.960
we're going to. We're going to HTTP, github.com, rdxrub, peg in, peg in dash spec.

03:37.040 --> 03:39.760
And that's pretty much it. If you go there, you'll find everything.

03:40.720 --> 03:43.600
It used to be that I had it all over the place. And I used to have, there's this,

03:43.600 --> 03:48.400
there's peg in dot dev, but that's kind of, it's kind of older,

03:52.560 --> 04:00.400
but a little older and out of date. So, it's still there. I'm reforming the spec as we go.

04:03.360 --> 04:11.840
So, we want, okay, so let me, let me show you why. So, if we go to the peg in scanner itself here,

04:11.840 --> 04:18.720
right? So, I mean, what is the end goal? The end goal is for us to be able to parse any kind

04:18.720 --> 04:24.960
of language. And we started with base ML, or base MD. Now, you'll remember I was basic MD.

04:24.960 --> 04:33.040
I was writing a basic MD scanner. And here is the, the, the, so this was all brought about because

04:33.040 --> 04:52.640
of this. So, I'm just going to put all of this precipitated by the basic, basic MD, parser,

04:52.640 --> 05:00.880
that I was right. I mean, a scanner, parser, AST. So, I started writing that last night.

05:00.880 --> 05:06.720
And that was all good and everything. But it became clear to me that there, I mean,

05:06.720 --> 05:10.320
some of these functions, I'm going to show you one, some of these functions that I have written,

05:10.320 --> 05:17.680
I have written them so many times. I swear, I have written, so like, I don't know how many,

05:17.680 --> 05:20.480
so I didn't, thank God I didn't post it to YouTube. I'm not going to force it on you.

05:21.040 --> 05:28.400
But I did, I must have written a, you know, a white space or an end of line parser,

05:28.400 --> 05:35.040
probably a dozen times, different ways. Because I don't have, I haven't had a standardized way

05:37.840 --> 05:45.200
to abstract the scanner stuff in a way that didn't require rewriting a scanner. I mean,

05:45.200 --> 05:50.080
I've written probably, including an extremely complicated one. If you go back in my YouTube

05:50.080 --> 05:57.840
videos, there's something I was writing, it was called go, was it go, go compatible,

05:57.840 --> 06:03.760
peg in expressions? And it was actually go code that could be passed into symbols,

06:03.760 --> 06:07.520
that could be passed into another function that would parse it, and then it would, you know,

06:07.520 --> 06:11.840
it would do its thing. It was pretty cool. But every time I've written one, and then the most

06:11.840 --> 06:18.400
recent iteration of my scanner that I wrote, I just ripped all that crap out. I was like,

06:18.400 --> 06:23.840
I want the ultimate and minimal. And thank God I did that because I actually ended up

06:24.800 --> 06:27.840
coming up with, so here's an implementation of the new scanner interface

06:31.120 --> 06:37.440
that anybody can write. And all it has is, I mean, some of this stuff is internal,

06:38.160 --> 06:43.520
but you know, this, let me show you the interface first, actually. So let's start with the interface.

06:43.760 --> 06:53.440
So the scanner interface is in my types. The scanner interface is just a scanner. It's a

06:53.440 --> 06:59.840
rune scanner that is aware of the beginning and ending of each rune that it scans, which can

06:59.840 --> 07:04.000
be more than one byte, right? So people know this. So you can imagine a cursor going, you know,

07:04.000 --> 07:08.080
through the, through the screen like this, like with an emoji on there. And sometimes it's a thing.

07:08.080 --> 07:14.240
So in fact, the scanner has this idea of a rune cursor. And I used, I mean, I thought with

07:14.240 --> 07:18.080
myself about whether to call it cursor or not, I didn't end up keeping a concept of cursor here,

07:18.080 --> 07:21.360
but I might find I had it embedded and everything. I don't want to get into it.

07:21.360 --> 07:26.000
So ultimately, a scanner is, it's a bytes buffer. And this is another reason I put this in the

07:26.000 --> 07:30.560
peg. So this thing, all of this used to be under rtbx-rob slash scan. I had my own rune scanner

07:30.560 --> 07:40.800
in there. But I realized, and I'm going to put this in my conclusions. So I realized that,

07:40.800 --> 07:53.280
that my rtbx-rob scan was actually very peg specific. And what I mean by that is that

07:54.000 --> 08:00.160
so a couple of really important specific assumptions are made by peg. Peg assumes

08:00.160 --> 08:04.400
that you have infinite memory, which is, you know, the polar opposite of parsing when you're

08:04.400 --> 08:08.400
using anything that you would get out of the Dragon Booker and computer science class.

08:09.920 --> 08:13.280
And so, I mean, that's a huge thing. So if someone comes across my scanner, they're going to say,

08:13.280 --> 08:17.040
oh, a scanner, cool, you know, they'll make think it's a finite automata, you know,

08:17.040 --> 08:20.480
single look ahead kind of scanner. And they, they're like, what the hell is this thing?

08:20.480 --> 08:27.600
It just flipped my whole data source, you know, byte, byte buffer and into memory. I mean, that's,

08:27.600 --> 08:33.280
that's like, that's like an unorthodox thing to do. That's a sacrilege in this. You know,

08:33.280 --> 08:40.080
that's what peg does. So, so I realized that the scanner that I have built and been using the most

08:40.080 --> 08:42.960
recent one, which I've used all over the place, I'm using it all over the place. I'm using it in

08:42.960 --> 08:51.680
Bonsai and everything is actually, in fact, I think I just broke Bonsai by, no, I didn't.

08:51.680 --> 09:00.080
Bonsai's got its own scanner, never mind. Anyway, so I went ahead and, and implemented,

09:00.080 --> 09:04.960
and I actually also deprecated the other one by, because I moved the entire scanner

09:05.600 --> 09:11.520
into the Pagan package or the Pagan, Pagan module, because why? Because it's Pagan centric.

09:11.520 --> 09:16.640
It's Pagan centric because a Pagan centric scanner, you can't even use it unless you load up a buffer.

09:17.200 --> 09:23.200
And, you know, that's completely unheard of in other circles. So, so that was the first major

09:23.200 --> 09:28.160
thing. That did mean, however, though, that the, the other one that I have, which I'm leaving out

09:28.160 --> 09:32.160
there, because I'm pretty sure I have some dependencies on this scanner. And it's also

09:32.160 --> 09:37.440
listed in my awesome go list and things. And I have some pretty intense breaking changes that I

09:37.440 --> 09:43.360
added to this since version 10, because I changed some of the internal references and everything.

09:43.360 --> 09:48.640
And the more I got changing it, the more I, see right here, it says fulfills Pagan scanner face.

09:48.640 --> 09:55.040
It actually doesn't do that anymore. I broke that when I was doing the move. And then this is the

09:55.040 --> 10:03.120
most accurate thing. So I've moved this entire scanner over to RTX ROM Pagan. And it is, you know,

10:03.120 --> 10:10.560
implemented as, under the types. Good night. So it's implemented in the type here,

10:11.280 --> 10:16.880
under types, you can see the scanner is here. It gives you the cursor type and a scanner type.

10:17.440 --> 10:20.880
And you can look it up and it has a mark going to go to and scan and to finish.

10:21.440 --> 10:26.480
I mean, nothing fancy there, right? And then I implemented, they included, you know,

10:26.480 --> 10:30.960
reference implementation of the scanner that I use for the Pagan stuff. And this gets me to

10:30.960 --> 10:39.520
where I was going with base, basic marked, my basic markdown parser. So, so here we have Pagan,

10:39.520 --> 10:45.840
we have, so this is, this is the exact code that was in this other place. That's just been moved

10:45.840 --> 10:52.560
and cleaned up. And I mean, really cleaned up and had some, some other things added to it.

10:52.560 --> 10:57.760
For example, the fulfillment of the interface so that it can be replaced with something else at

10:57.760 --> 11:04.320
any time. And let me, let me talk to you about why I decided to make it an interface again.

11:04.320 --> 11:09.280
I mean, I started talking about that. But if you go to, so here's the interface, but as I was working

11:09.280 --> 11:16.960
on basic MD, I started realizing that parsing end of line and end of block and paragraphs and,

11:16.960 --> 11:22.560
you know, all of these things that are listed in Pagan are things that I need to do all the time.

11:22.560 --> 11:27.120
In fact, I just add it in paragraph, right? These are things that I already need all the time.

11:28.000 --> 11:33.280
And I'm like, I've always have intended to write, I mean, I've been really kind of hung up on

11:33.280 --> 11:38.720
creating a code generator for all of stuff that, so you write Pagan and you end up with different

11:38.720 --> 11:46.240
types of code, right? But to be more practical, I've started realizing all I really need to do

11:46.240 --> 11:51.760
is write a scanner function for each of these and then reuse them. And then the ones that I,

11:52.880 --> 11:58.080
that aren't in Pagan, that are specific to basic markdown or whatever, I'm writing Keg or whatever,

11:58.080 --> 12:06.080
I can actually write those using exactly the same function signature. And I could even put them in

12:06.800 --> 12:11.840
packages, you know, as a collection of first class functions, because they all accept the scanner

12:11.840 --> 12:19.760
interface. And that is, you know, that is go interfaces shining the brightest, right? Because

12:19.760 --> 12:26.880
that's what's exactly what you want to do with it. So what does that mean? So I have the scanner

12:26.880 --> 12:35.760
implementation here, and I can, I actually chose to make this implementation fast and abstract,

12:35.760 --> 12:41.280
so that if somebody chose to use it, they could use the direct references to the byte buffers

12:41.280 --> 12:46.400
and stuff like that, so they can bypass the indirection from the interface method calls,

12:46.400 --> 12:51.200
which is the reason I didn't do it originally, right? If you look at the highest performance

12:51.200 --> 12:55.440
parsers out there, they do not have a lot of functional indirection, right? It's actually

12:55.440 --> 13:00.880
one of the biggest complaints I have about the current code generator for Pagan that Quint

13:00.880 --> 13:07.280
mostly made, and I last two years ago, is it has a ton of function indirection in it. And that's

13:07.280 --> 13:13.920
been something I've been kind of like, irrationally hung up on. And I think I finally hit the middle,

13:13.920 --> 13:18.560
the middle of the road here. So this particular reference implementation, which is a part of

13:18.560 --> 13:26.160
Pagan, comes with a struct that you can use directly if you want to, which I probably will

13:26.160 --> 13:29.920
do and really quick and dirty, you know, I mean, not the quick and the quick and dirty stuff,

13:30.000 --> 13:32.960
I'll probably will use the abstractions because they're easier to remember and you can just,

13:32.960 --> 13:37.440
you know, you can just swap them in and out. I don't need performance, right? But if I'm like,

13:37.440 --> 13:43.120
really want to make a low level, really intensely often, you know, parsed grammar, then I can go

13:43.120 --> 13:54.400
ahead and bypass the use of those things as long as I don't want to reuse any of the stuff I've

13:54.400 --> 13:59.040
already write in Pagan, which brought me to think, oh, damn, you know, let's say I make a,

14:00.000 --> 14:04.720
here's, here's my work, my workflow. Okay, so my, I imagine the workflow of making a grammar

14:04.720 --> 14:08.720
or something like this, right? So in fact, this is even in a slide at Brian Ford, Brian, I was

14:08.720 --> 14:12.320
looking at Brian Ford's peg stuff, and he has this in a slide about, you know, traditional

14:12.320 --> 14:17.200
thing, use Lex and Yak and blah, blah, blah, and, and then, but, you know, the pragmatic way

14:17.200 --> 14:23.200
approach to doing parsing these days is to write, you know, a generic kind of specification and

14:23.200 --> 14:28.160
then to write a recursive descent parser. It's the standard way, the practical way to do parsing.

14:28.720 --> 14:32.720
And let's say I want to do that, right? So I want to write a grammar, but I want to write it

14:32.720 --> 14:39.360
quickly. Now, the quickest way to do it would be to do cogeneration with, you know, from Pagan

14:39.360 --> 14:44.240
notation, which is something I still want to do. That's nothing that Pagan, that Brian Ford ever

14:44.240 --> 14:47.920
wanted to do. You kind of wanted to get away from it because he realized it was just, it's just as

14:47.920 --> 14:52.800
fast to just write your own recursive descent functional parser and, and then be done with it.

14:52.800 --> 14:56.480
You don't have to deal with all the intricacies of cogeneration, not being exactly what you want.

14:56.480 --> 15:01.680
You just write it, right? And, and I'm kind of on board with that idea because, you know,

15:02.400 --> 15:05.920
it's, it's quite a bit of work to get it to generate just the way you want to. And then

15:05.920 --> 15:11.600
which, which cogeneration method do you want? Do you want it to be highly efficient? Do you want

15:11.600 --> 15:14.960
it to be used functional so it can be easily maintained? Are you going to rerun the generator

15:14.960 --> 15:19.760
every time? Is it just giving you the first version? And, and so at a certain point,

15:19.760 --> 15:24.880
you kind of come to the conclusion that probably the fastest way to create a parser is to just

15:24.880 --> 15:30.560
write the thing because then, you know, you're going to, you're, you're going to be done. You're

15:30.560 --> 15:35.280
going to be done with it and you're going to be able to move on to other things. So, um, and,

15:35.280 --> 15:45.680
and that's kind of where I am. So, uh, also realized, uh, fastest way to develop, uh,

15:46.640 --> 15:53.360
parser is to write Pagan and then function and then scanners

15:56.480 --> 16:01.840
functions for recursive descent. Uh,

16:03.920 --> 16:08.480
I mean, it really is. So by the time, you know, you get all the thing, just writing the Pagan

16:08.480 --> 16:14.000
itself is good. I mean, that kind of gets you thinking about how it's supposed to be implemented,

16:14.080 --> 16:19.680
but you're also not wrestling with Pagan syntax and stuff, uh, in case you get it wrong. Now,

16:19.680 --> 16:24.080
you should probably do that, but let's say you don't represent it perfectly and Pagan,

16:24.080 --> 16:29.440
who cares? The Pagan is just there to help you understand what the parser is going to,

16:29.440 --> 16:33.520
how it's going to behave. Um, and then you can, you know, compare it to that, you know, just,

16:33.520 --> 16:37.520
just, you know, visually and get to your, get to your point, but you can get busy kind of writing

16:37.520 --> 16:43.040
your parser. So, so, but, you know, along those, those lines, assuming that you're going to write

16:43.040 --> 16:46.640
a parser, right? You're going to go ahead and write a parser. What are the obvious building

16:46.640 --> 16:50.480
blocks? I mean, code generation is awesome and everything, but, but what, what would be the

16:50.480 --> 16:55.680
other way to do this if you didn't have code generation? Well, it gets pretty obvious that

16:55.680 --> 17:03.760
it would be a standardized library of scan functions, uh, that, that you regularly reuse,

17:04.720 --> 17:09.600
right? And if you, as long as you make those export in your public, make those public, you can,

17:09.600 --> 17:13.120
you can pull them in and you can tweak them and make them more efficient and other people can

17:13.120 --> 17:17.840
contribute their own. And, and you have, you know, you ended up getting this ecosystem of scanners,

17:18.400 --> 17:23.280
uh, of, you know, because that's really, the scanners are really the secret because if you

17:23.280 --> 17:28.400
have a scanner, you can scan it and if it scans successfully and you would get a true at the

17:28.400 --> 17:33.040
end of that. I mean, and this is very hastily, right? If at the end, if you get a true after that,

17:33.040 --> 17:38.080
you're done. You're under the next thing. If you don't get a true, then you're guaranteed that

17:38.080 --> 17:42.560
the scanner didn't do any advancement because it snapped back. And you're going to see this all

17:42.560 --> 17:46.960
over in, in my implementation of functions, which we'll show you in a second, because that is how

17:47.840 --> 17:53.840
you do this. And, and that is exactly how Brian Ford talks about it in his paper. It's like the

17:53.840 --> 17:59.520
difference between, you know, the traditional scanner and, you know, parser kind of approach.

17:59.520 --> 18:04.960
And this is that you can scan ahead as far as you want and you can keep track of how many

18:04.960 --> 18:10.800
matches you have. So you can be very greedy if you want and say, okay, so did I find anything?

18:10.800 --> 18:14.640
Yes, I found like 10 of them. And then I keep scanning and like, oh, hey, well, like, okay,

18:14.640 --> 18:19.600
I stopped. So then I like roll back to the last one that was successful. Or if there were none

18:19.600 --> 18:25.440
that were successful, I roll back the scanner all the way to the beginning. So, so this idea of

18:25.440 --> 18:31.840
snapping the scanner back and moving it and around a thing, that's a very fundamental part of the PEG

18:31.920 --> 18:37.680
architectural approach. Because you have memory, you have memory that you can fly around in. And

18:37.680 --> 18:42.320
very quickly, by the way, I mean, you know, moving pointers around in memory is crazy, crazy fast.

18:43.040 --> 18:46.640
And you've only had to do the one load. And so, you know, all these things that are doing like

18:46.640 --> 18:51.840
single byte loads, in order to do that, you've already had to buffer your data at some point. So

18:51.840 --> 18:55.840
you've already had to do the buffering. So, so the thing is cool about PEG is it assumes that

18:55.840 --> 18:59.520
you're just going to buffer all of that upfront. And then you're going to break up your content

18:59.520 --> 19:02.880
into manageable chunks that fit within, you know, reasonable amount of memory that you're

19:02.880 --> 19:07.520
going to be parsing. You should put limitations in there and stuff. And that's a part of the grammar

19:07.520 --> 19:13.200
design, which is another reason that PEG is a fail, because as wonderful as it is, it does not allow

19:13.200 --> 19:18.720
you to put limitations and constraints on this size, which is why I made PEG in. So when I say

19:19.280 --> 19:27.600
things like, I only want, you know, two end of lines here, I can specify two end of lines. There's

19:27.600 --> 19:36.240
no way in the original PEG specification example to indicate amount, which I just think is crazy,

19:36.240 --> 19:41.760
given the fact of, that regular expressions in ABNF have been doing it forever, and ABNF, but

19:41.760 --> 19:46.160
PEG decided not to do that. So that's one of the reasons I made PEG in, because we clearly want

19:46.160 --> 19:51.040
the combination of those things. All right, so let me go back to here. So I went ahead and I

19:51.040 --> 19:55.120
implemented a white space function right now. I could have probably automated this, but let's

19:55.120 --> 20:00.880
look at what it looks like. So if we go into the PEG and scan, and you're probably wondering, well,

20:00.880 --> 20:06.080
why did you name it scan? Because I wanted it to read well. So let me show you the, the examples

20:06.080 --> 20:12.560
here. These are go testable examples, and they are public. You'll remember maybe when I did basic

20:12.560 --> 20:19.520
MD that I kept a bunch of my scanning, not public. I was like, because I didn't want people to become

20:19.520 --> 20:26.480
dependent on my scanner functions, right? I mean, I'm just making a basic markdown part. So I don't

20:26.480 --> 20:31.440
want people to be, you know, including my thing, because they want my specific implementations

20:31.440 --> 20:35.920
of these. And that's one of the reasons I started thinking, hmm, I should probably think more deeply

20:35.920 --> 20:41.760
about some of these scan functions that are going to be reusable. And I should probably put them

20:41.760 --> 20:47.680
somewhere where they could easily be reused by me and others. And that's what got me to do this.

20:47.760 --> 20:52.640
So I've created a convention called sum, which is just a nice happy way. It's like, you know,

20:52.640 --> 20:56.800
go, they like have must and compile and things like that. So I created a convention where you

20:56.800 --> 21:00.800
put sum in front. These are all documenting the design considerations on the read me page, by the

21:00.800 --> 21:08.720
way. But sum means, you know, zero or more white space or one or more white space. So if I have

21:08.720 --> 21:13.440
example sum WS, so, and then I the reason I named this sub package scan is so that we would get

21:13.440 --> 21:19.360
these wonderful readable lines here scan dot sum white space and then pass in the scanner.

21:19.360 --> 21:24.160
Now you might be asking as many, many people will tell you that have done scanners that

21:24.160 --> 21:30.720
they implement the scanner as a class, which I think is disastrously bad architectural decision,

21:30.720 --> 21:37.840
because you cannot do anything with it at all. And tell you expand the class,

21:37.840 --> 21:43.520
that is the primary reason that people like Jim Copeland and others hate class based object

21:43.520 --> 21:50.160
oriented programming. It is so concrete, you can never extend it, not without re implementing the

21:50.160 --> 21:55.600
class or subclassing it by doing it this way. I can use first class functions is a very functional

21:55.600 --> 21:59.840
approach. I can use first class functions if I want, I can use it from a package, whatever,

21:59.840 --> 22:07.040
because the scanner is an argument to the function. And so as long as the scanner fulfills the

22:07.120 --> 22:11.840
interface, this is why interfaces are king. This is why interfaces are part of solid,

22:11.840 --> 22:16.960
even in modern Java development. If you're not doing this, if you're writing a scanner,

22:16.960 --> 22:21.840
writing a class and extending the class with all of the different types and then having to do that

22:21.840 --> 22:25.120
every time you're doing it wrong, in my opinion, because you're never going to be able to extend

22:25.120 --> 22:29.200
that in any way that's going to be reusable for anybody. And maybe you don't care about that.

22:29.200 --> 22:34.000
I do. I want it to be reusable. I want to, I want to create, ultimately, I want to build up,

22:34.000 --> 22:40.880
you know, hundreds or more scan functions that can be used with anything whatsoever

22:40.880 --> 22:45.440
that implements the scanner interface. And that's why interfaces are so amazing.

22:45.440 --> 22:50.880
So I pass a scanner interface, I say scan some WS and I get a true or false. So this prints out

22:50.880 --> 22:58.000
false because the first number is a one. Now I added a constructor. There's really not constructors

22:58.000 --> 23:02.800
and go, but it's the closest word for it. And this takes an optional argument. Now constructors are

23:02.800 --> 23:06.960
very, very high level. So they don't have to be performant, right? Especially since you're not

23:06.960 --> 23:13.520
going to be buffering a lot. So I put an optional parameter to on the constructor. If you pass in

23:13.520 --> 23:21.760
a string or a reader or a bytes buffer, any of those things, it will work. And it will just

23:22.480 --> 23:28.240
slurp all of the thing into memory. And then it will allow the scanner to work on that, that bytes

23:28.240 --> 23:33.520
buffer. And so then we do this to say, so, so you can see here, we, we, it's, you see, it was false

23:33.520 --> 23:40.240
that it's not currently the scan WS failed here. Because why? And you'll notice too that it didn't

23:40.240 --> 23:46.800
advance the, it didn't advance the, it's not supposed to. That actually looks like a mistake.

23:48.160 --> 23:52.480
That might be a mistake. Let me check here. Oh, no, no, no, no. Okay, let's do this.

23:53.200 --> 23:59.280
Wait, what? Advance to nothing at all output.

24:00.960 --> 24:06.160
Example sum WS. I think I might have a problem with this one. Anyway, it's supposed to,

24:06.800 --> 24:09.600
I just barely fixed these. That's why I want to make sure it's okay.

24:10.640 --> 24:16.400
Sum WS. Is it not, isn't that working? I'm going to go try something. Go test,

24:16.400 --> 24:27.120
run sum WS. Well, let's turn a trace on. Oh, this is cool. I finally got traced to working again.

24:28.080 --> 24:35.360
So trace, that'll turn trace on. And when we run it, we should be able to see every step of the way.

24:36.640 --> 24:44.000
So the first call to scan, got it. That's what with the first, that's every time,

24:44.000 --> 24:48.720
every time scan gets called, it prints it. So scan, scan the one in, and that shows us the,

24:48.720 --> 24:51.920
from between zero and one, and then what's left in the buffer and there's a space.

24:51.920 --> 24:56.560
And then it shows we scanned a, a space and that was between one and two. It could be one and three,

24:56.560 --> 25:02.400
depending on the size of the rune. And then as the buffer is empty. So, so that shows it's doing

25:02.400 --> 25:10.880
what we wanted to, I just was, oh, I know why. It's doing that because it's actually, because

25:10.880 --> 25:16.320
this actually did do some scanning and it did not reset. Actually, that's a, that's a, that's a

25:16.320 --> 25:22.320
mistake. That's a mistake. I need to fix this. This, because it didn't scan, it should not have

25:22.320 --> 25:25.760
advanced the buffer at all. It should have been, I've got to do this. This is a nice catch.

25:27.360 --> 25:31.920
And again, this is just, this is the bug in this, in the scanner function only not the scanner itself.

25:33.280 --> 25:38.080
Trace is internal. Trace is, Trace is a part of this scanner implementation. It's not part of

25:38.080 --> 25:44.560
the forced interface. No, it's not. You don't have to have a scanner in there. It's, that's part

25:44.560 --> 25:49.520
of this scanner implementation. So, you know, I don't want to burden people with those kind of

25:49.520 --> 25:56.800
details that they, they want to do their own, they can, right? So, I mean, but yeah, you could

25:56.800 --> 26:01.200
extend that and do what you want with it. So this is, this is actually wrong. This should have been

26:01.200 --> 26:04.400
x00 and it should have been

26:06.400 --> 26:12.320
zero to zero and then it should have been a one here. That's what it should be. And then when

26:12.320 --> 26:19.120
you do the scan, it should go through and then it should have been a one and a zero to one.

26:21.120 --> 26:27.840
And then, and then that should have left us with a space and it should have been false and then

26:27.840 --> 26:37.520
it should have been true. This one should have probably printed true. Yeah. Something might

26:37.520 --> 26:44.000
be wrong with that today. All right. So that, that's how it should look. So let's, that means

26:44.000 --> 26:48.480
there's a problem with my function, my scan function, which is what I was debugging before,

26:48.480 --> 26:52.480
but let me show you how to do this. So there may actually be a problem with my mark and I'm,

26:52.480 --> 26:56.080
I'm hoping not to, I think, I think that might be, there might be something wrong with my mark,

26:56.080 --> 26:59.680
which is relatively new. But the point is, I don't know if you saw the functions I was writing

26:59.680 --> 27:07.680
yesterday, but these are way, way simpler, right? They just have to scan and check what the runes are

27:08.320 --> 27:14.960
and scan again and the, the idiom is the same no matter what. You take a, you take a bookmark to

27:14.960 --> 27:20.000
it at the beginning and you revert back to the bookmark if you're, if you didn't find anything,

27:20.000 --> 27:25.200
right? And you leave things as they are. Otherwise you let the scanner happily proceed along

27:25.760 --> 27:29.440
and it's not like there's a lot of cash in there so that you, you know, you'd have problems there.

27:32.080 --> 27:35.120
But yeah, I have, I have a problem with this one. I got to come back to that. I can't see it right

27:35.120 --> 27:41.040
out hand, but so this is actually, you know, this, this is supposed to scan as much white

27:41.040 --> 27:49.600
space as possible. I think the problem is, I don't know, we might be getting ruined. I don't

27:49.600 --> 27:53.200
know, I'll have to go debug this one. But if, if I wanted to just debug this one too, I could

27:53.200 --> 27:59.920
also just do this. I could just do s.trace and turn on the tracing in here while I'm doing this

27:59.920 --> 28:07.440
debugging. I can put it there in the test either way. Oh, it's not, that's right. I forgot about

28:07.440 --> 28:12.000
that. Man, this is going to be interesting. Yeah. Cause you just said, is that in the, is that in the

28:12.000 --> 28:22.080
debug output? Interesting. Yeah, I just realized I'm saying, because I locked down the interface

28:22.080 --> 28:24.800
and I'm going to keep a bunch of stuff out of here. I'm not going to be able to do because,

28:24.800 --> 28:28.960
because this is, expects a scanner interface and that means only things that are, are defined in

28:28.960 --> 28:33.520
the scanner interface can, can turn on. I wonder if we should make trace into the part of the

28:33.520 --> 28:38.240
interface. We should say you need to implement some form of activating trace. I don't think we

28:38.240 --> 28:43.680
should. I mean, I think, I think we should leave that in the tests stuff because people can set up

28:43.680 --> 28:47.920
their own test cases and then, and then call it that way. I, I, I don't know. I thought about it

28:47.920 --> 28:54.160
for a second though. This is just as good, right? Having the trace appear. Because this is, is, is

28:54.160 --> 29:01.120
using a specific scanner that fulfills the, the interface and therefore it can have extra things

29:01.120 --> 29:04.560
in it like trace. The other one doesn't have anything, any knowledge of it at all. And it

29:04.560 --> 29:09.120
shouldn't, right? We don't, that's again, I want to, I want to double check that everybody understands

29:09.200 --> 29:15.680
this. So we do not want people writing, you know, Pagan or any

29:18.880 --> 29:25.040
scanners functions that are going to be doing fancy things that are not defined by the interface.

29:25.600 --> 29:30.560
Because if you do, then they won't work with interchangeably with other scanners.

29:31.680 --> 29:35.840
And that, that's not ideal, right? We want to be able to have people write

29:35.840 --> 29:40.000
very highly optimized scanners however they want. I mean, all of them obviously are going to have the,

29:40.000 --> 29:43.520
the downside of having to call out to a function to do their thing. But that's,

29:43.520 --> 29:47.200
it's not too bad. But that way people can supplement the scanner that I've made or make

29:47.200 --> 29:51.680
their own or something like that. And they can, they can share all of these scan functions with

29:51.680 --> 29:56.400
each other. And we can make libraries of scan functions that do different amazing things. So

29:56.400 --> 30:00.480
it's basically like creating a library of regular expressions. And if you look at

30:01.040 --> 30:08.400
the Pagan stuff that I've been doing, you can see that we've got a lot of functions to write.

30:08.400 --> 30:14.160
So over the next year or two, I'll be implementing individual scan functions

30:14.720 --> 30:22.400
for the different types of stuff that is included here and in our tokens. And yes, we're going to

30:22.400 --> 30:28.640
have, we're going to have functions for things that are strictly static. And the reason is that

30:28.640 --> 30:33.200
is to keep everything functional because we need to be able to pass the scanner to it, right?

30:34.960 --> 30:38.640
We don't, if we didn't do that, we would have different kinds of dependencies. We would have

30:38.640 --> 30:45.600
dependencies on the Pagan like implementation to some degree, I think. And so that, I mean,

30:45.600 --> 30:50.640
it's not that much extra. Before I was like calling out to a function just to parse the

30:50.640 --> 30:54.240
references to the other functions. So there is, it's not going to be any less performant than

30:54.240 --> 30:57.920
any of the other stuff. And that's really premature optimization. If somebody really,

30:57.920 --> 31:03.120
really, really wants that level of performance, they probably should write their own scanner and,

31:03.120 --> 31:08.160
and, you know, maybe just use some of the scan functions without, without it and not, and not

31:08.160 --> 31:14.880
bibbed. So, but I will be writing like, I'll probably be auto generating a bunch of go code to,

31:15.600 --> 31:21.360
to, you know, to, to, to, to stand for each one of these, these scan functions. And then they'll

31:21.360 --> 31:26.080
all be under scan dot whatever. So I'll be able to just on any project, just be able to import

31:26.080 --> 31:32.480
artifacts, Rob slash Pagan slash scan, and I can get any and all of these that I want.

31:34.080 --> 31:39.120
And it's not that big, actually, because it's just text parsing, right? It, it seems big because

31:39.120 --> 31:42.800
it's a lot of code for us to write, but it, but it's most of it's going to get inlined and the

31:42.800 --> 31:47.120
size of the package isn't going to be too big. And, and then we can, we get kind of like this

31:47.120 --> 31:52.800
regular expression engine that's on steroids, because now we can just write our own recursive

31:52.800 --> 31:57.680
descent parsers as easily or if not easier than we could write regex, you know, complex

31:57.680 --> 32:01.680
regex expressions. And that, that to me is kind of the Holy Grail, because that's what I want to do.

32:01.680 --> 32:05.520
I, I have like four or five grammars that I want to finish that I'm kind of waiting on.

32:05.520 --> 32:12.560
And this is, that's, that's where, that's where it leaves us. All right. So I need to come back

32:12.560 --> 32:16.160
and fix this white space one. Let's go back and look at one that maybe works better. So

32:16.880 --> 32:22.480
here we have, and I put the pagan line up here. So an end of the line is, you know,

32:22.480 --> 32:29.280
we scan the found Boolean stuff. We don't really need that. I could have just done a return right

32:29.280 --> 32:38.880
here and call it a day and not gotten all the way down here. And the reason I didn't do that

32:38.880 --> 32:45.840
initially is because I wanted to think about how this code could be auto generated. But

32:45.920 --> 32:53.840
now that I'm looking at it, I am totally okay doing that. So, so we can just do a return true there.

32:55.520 --> 33:01.680
Here we can just do a return true. Yeah. And if we make it down this far,

33:02.560 --> 33:07.680
that means we didn't find it. And we need to do that. So that this is, this is not hungry.

33:08.320 --> 33:12.960
If you're using something that's hungry. Yeah, you might, you might have a different problem,

33:12.960 --> 33:22.080
right? Because, you know, you need to, yeah, you need to, if you're having something that's like

33:22.080 --> 33:26.720
hungry and greedy, you need to like count all the fines and you'll see that, you'll see that kind

33:26.720 --> 33:37.360
of thing happening over time. Oopsie, did I refer to found in here? Return false. So I mean,

33:37.360 --> 33:41.760
that's a simplification we can do. Again, these are, I want these to be highly optimized. Another

33:41.760 --> 33:47.840
reason, by the way, that I think code generation is probably the wrong way to go. And the more I

33:47.840 --> 33:53.520
keep coming back to this, the more I think that hand crafting a recursive descent parser from a huge

33:53.520 --> 33:59.920
library of existing scanners, scan scan functions is a better idea. Because of this problem that you

33:59.920 --> 34:07.120
just saw, the optimization I just made is the kind of thing that would take an extreme amount of

34:07.680 --> 34:12.400
intelligence in the code to be able to write it in a code generator. Whereas if I'm just writing

34:12.400 --> 34:18.000
the parser, I can take, I can do tricks and stuff inside of my functional parser to make it really,

34:18.000 --> 34:24.720
really optimized for this particular scenario, you know, and, and I can do things that couldn't be

34:24.720 --> 34:30.480
done if I were to just to generalize the generation of this code from the syntax. So what I'm saying,

34:31.120 --> 34:38.000
and I'm going to put this in here is that I am, I'm kind of souring on the idea of code generation.

34:39.920 --> 34:53.280
So I'm souring on the idea of Pagan to code generation, because it's removing, you know,

34:53.840 --> 35:04.080
it, it, it prevents, it precludes optimizations that only, that only a person could do.

35:05.200 --> 35:09.600
And, you know, people definitely do this. And if you're going to, I mean, at the end of the day,

35:09.600 --> 35:15.200
we're writing a compiler when we do that kind of thing. And, you know, there are people that have

35:15.200 --> 35:20.560
spent their entire lives dedicated to compiler optimizations. Well, one of the reasons that

35:20.560 --> 35:25.840
having a human write a scan function is better is because depending on the language they're writing

35:25.840 --> 35:34.240
it for, they might already know how the compiler is going to inline that code. So, so, you know,

35:34.240 --> 35:39.200
having some generic size rendering of the code may not be able to take advantage of those things.

35:39.200 --> 35:44.320
And, you know, premature optimization, yes, right, we want to avoid premature optimization, but,

35:44.320 --> 35:49.920
but at the same time, we don't want to be forced into doing things that, that we could do

35:50.960 --> 35:55.120
because we know about them later on. We could come back to the code

35:55.120 --> 35:58.880
and we could actually say, well, okay, let's optimize this one, because this is that my

35:58.880 --> 36:04.240
pagan function for parsing, you know, wide space, the most important thing that I'm ever going to

36:04.240 --> 36:08.080
write, it's going to be used by millions of people or whatever. And, and I should really,

36:08.080 --> 36:13.120
really optimize that one function. And then everybody can spend their time optimizing the

36:13.120 --> 36:19.520
functions that we have for parsing those specific things. And we can maintain a community library

36:19.520 --> 36:23.600
of this, rather than having everybody write the best, you know, their own wide space parser,

36:24.560 --> 36:29.360
right? So we can actually have a collective community of contributions that from people

36:29.360 --> 36:34.640
who know about parsing, or really, you know, amazing Go specialists who have, have, you know,

36:34.640 --> 36:39.600
know how to optimize code based on what they're, what they know about inlining. So, so yeah,

36:39.600 --> 36:46.560
no more code generation, just a lot of pre-generated libraries that are immediately importable.

36:46.560 --> 36:51.280
And then we can just write, you know, in if statements and switch statements, and you can

36:51.280 --> 36:55.360
write your own thing really quickly. And I think that's really going to be the new normal

36:57.120 --> 37:05.920
useful form overlooks. Yeah. And so, so, so yeah, I think, I think, I think that that's,

37:05.920 --> 37:14.320
that's kind of how I am with this. That is why you're developing anything. Yeah. I, I, I think

37:14.400 --> 37:18.640
that the code generation thing, I mean, this doesn't mean we're not going to do some code

37:18.640 --> 37:24.880
generation, right? But we're going to statefully code generate like all the functions for the,

37:24.880 --> 37:32.160
the 200 or so Unicode classes, which by the way, already have functions. Yeah. So for those kind

37:32.160 --> 37:36.320
of things, we're just, that's exactly how Go does it, by the way. Go takes that document,

37:36.320 --> 37:41.680
and it generates the Go code from straight up from the, from the Unicode specification document.

37:41.680 --> 37:47.440
And it has a, you know, a whole library of, of, you know, true or false kind of things, right?

37:49.200 --> 37:55.280
But it's not a scanner. And so the only thing we're going to have to do in the Go one is

37:55.280 --> 38:00.800
basically the same idea, but we're going to say, okay, is this thing a thing? And then,

38:00.800 --> 38:06.720
and then we'll make a sum variation as well, so that it'll be like one or more of those things,

38:06.720 --> 38:12.800
right? And, and all that code will get auto generated. So we'll have a pretty big library

38:12.800 --> 38:17.360
of scanners that'll be developed that you can then make your recursive descent

38:17.360 --> 38:23.040
parsers from. And maybe we can get somebody else to actually think it's a good idea besides me.

38:26.880 --> 38:30.240
Optimizing a lot first is that you can find you don't need the functions you're optimizing. No,

38:30.240 --> 38:35.120
that's right. So I'm saying, so a lot of them, yeah, you could combine the two things together

38:35.120 --> 38:42.320
or something, right? Yeah. So, so I think, I think I'm kind of happy with this where we're

38:42.320 --> 38:49.920
going with this now. Now I still have this, this bug here, my white space bug. But the other one

38:49.920 --> 39:00.240
is fine. Let's, let's try to run that one. Let's do run. What was it the end of line? End of line,

39:00.240 --> 39:07.360
I think, right? Oops, we need to let's turn scanning on end of line. So you can see it

39:09.280 --> 39:18.560
end line. Then there's lots of in lines. So she was the carriage feed one. Actually,

39:18.560 --> 39:25.280
let's just turn it on for the whole, the whole scanner. Yeah, scanner scanner has a trace for

39:25.280 --> 39:29.200
the whole entire package if you want to turn tracing on on everything.

39:31.840 --> 39:40.560
Yeah. Trace equals, I'm probably have to do an init here. Trace equals one.

39:41.440 --> 39:45.360
Yeah, that's going to say you need to put that in an init. All right, fine.

39:47.360 --> 39:52.720
This is just for now. There's other testing ways to do this, but I'll just do that for now.

39:52.800 --> 39:59.680
So we could go test. So actually, this is going to show every single parts that we did.

40:00.320 --> 40:06.400
I'm so happy with this. So when you turn the trace on, when you turn it on this way,

40:06.400 --> 40:12.400
it'll actually give you like the full thing. So here it was, it was, it, it read the first

40:12.400 --> 40:17.600
carriage return and then a line return and then another line return. So that, that was that one

40:17.600 --> 40:20.560
that we did. And there's another one. So these are all the different ones. There's no other printing

40:20.560 --> 40:24.880
statements going on in there, but you can kind of watch what's getting parsed as you go

40:26.560 --> 40:29.840
and check on it. And you can go, go look at that and see if you like it.

40:31.440 --> 40:34.240
But yeah, I mean, it's working without that portal pass. I just got that white space one

40:34.240 --> 40:38.800
I have to figure out. So I think that's enough for this video. I just, I just wanted to show

40:39.360 --> 40:45.680
where I was. Some of the, I mean, I don't got the, the, the end paragraph turns out to be end block.

40:46.400 --> 40:50.880
So remember yesterday I was doing basic markdown and I was like, hmm, we need to

40:50.880 --> 40:55.280
delineate our blocks. Well, what is, what do we have? We have any number of spaces

40:56.800 --> 41:04.240
and then a greedy include of, of white space and line returns, you know, and that's what this is.

41:04.240 --> 41:08.720
So I had to actually re, I had to rewrite it and say, do I have the end of,

41:08.720 --> 41:14.320
do I have the end of the data? Do I have an end of line and then the end of the data?

41:14.320 --> 41:18.960
Or do I have two end of lines, which are, you know, the greedy thing and then the white space

41:18.960 --> 41:24.640
splat and, you know, peg, uh, repeat operators are greedy by default. So that says, grab as

41:24.640 --> 41:28.720
much white space as you can. As far as I know, I might have that wrong, but grab as much white

41:28.720 --> 41:36.000
space as you can and then make sure you have this at the end, right? Now it may be that I have to,

41:37.280 --> 41:44.240
uh, uh, if I were to put this up here in the front, then it would be non greedy. So it would

41:44.720 --> 41:50.160
it would get, you know, it would, it would get the first one. So the first match of,

41:50.160 --> 41:54.640
I had that happening before I had the first match of, of a line of double line returns

41:54.640 --> 41:59.200
and it got the first one. So that's how you, you do non greedy is you put that stuff up in front

41:59.200 --> 42:02.880
here, but you have to kind of look at the peg and syntax, the peg syntax to get that. That's,

42:02.880 --> 42:08.560
that's from Brian Ford. That's not for me. Uh, but, and I still have to go look it up here as well.

42:08.560 --> 42:11.520
But it's, I, once you get it, it's much easier than regular expressions. It's not,

42:11.680 --> 42:14.320
actually it has positive negative look ahead and all that kind of thing,

42:14.320 --> 42:17.680
which regular expressions, depending on which engine you're using, don't really do well.

42:18.880 --> 42:22.640
Not to mention, you know, the ability to capture thing. So, and, and I use the,

42:22.640 --> 42:28.960
I use the block here and go to, uh, which I actually prefer to for loops because

42:29.920 --> 42:35.680
they just are so much cleaner. Um, because you just know you're going to go up to the top again

42:35.680 --> 42:41.040
and you know, you know, the thing I like about it's much easier. I mean, it's much harder to

42:41.040 --> 42:47.520
write an infinite loop with a labeled block than it is with an infinite forever loop,

42:47.520 --> 42:53.040
which is just for, and I used to do them that way. Um, because, I mean, you definitely can,

42:53.040 --> 42:58.560
but you have to explicitly create an infinite loop that keeps going to the top again, right? So,

42:58.560 --> 43:05.120
it's kind of like a do while. Um, and you see this all the time in parsers. This is in go, it's in,

43:05.120 --> 43:12.080
and goes compiler for the language that go to is a very real, uh, solid thing to use for,

43:12.880 --> 43:17.920
uh, for compilers and for parsers and scanners. And it saves you from any kind of functional

43:17.920 --> 43:22.480
recursion, which is the devil when it comes to performance and parsers because you hit, you hit,

43:22.480 --> 43:27.440
um, you hit, you know, you hit, uh, indirection functional loops, uh, functional recursion loops

43:27.440 --> 43:32.000
and stuff like that. Some languages is the preferred way to do it, but, but, but most

43:32.080 --> 43:36.320
of the languages or not, most of them want you to just stay within there and kind of

43:36.320 --> 43:40.320
figure out a way to short circuit and go back up to the top. And it's more performant that way too.

43:40.960 --> 43:47.840
So this one has to have the whole notion of a found Boolean in it because even if I find one,

43:47.840 --> 43:52.160
I still want to look for more. I still keep wanting to look for more until I get,

43:52.160 --> 43:57.200
I'm greedily get the, the last one, right? And I, before I added a notion of a, of a found loop in

43:57.200 --> 44:02.000
that I, I wasn't getting everything. And so what it does is it keeps getting stuff until it hits

44:02.000 --> 44:08.320
something that is not valid. And it's like, okay, I finally run out, but did I ever find anything

44:08.320 --> 44:14.160
along the way? I was like, Oh yeah. Okay. Well, what was the last one that I did find? And, and then,

44:14.160 --> 44:20.960
you know, it can, it can tell you that thing. Um, and, and that's what the go to is. Um, this is

44:20.960 --> 44:26.400
actually wrong. I'm just realizing I have some problems with this. Yeah. It's funny because

44:26.400 --> 44:30.720
now that it's cleaner and I've got to spend my whole day fixing up all of this syntax, I can see

44:30.720 --> 44:37.280
that this is probably wrong because this is, this is going to, uh, this is, if it, if, oh no, no,

44:37.280 --> 44:43.040
I'm sorry. No, I'm, I'm sorry. This is only if it's not found. Yeah. This is only if it's not

44:43.040 --> 44:48.240
found. Yeah. So scanners do not advance. So the rule, this is a kind of a hard thing to,

44:48.240 --> 44:52.240
to come up with when you're trying to figure out how to make your parsers and functions and stuff.

44:52.240 --> 45:00.960
But the easiest rule is for a scanner is if it scans, it returns true and it advances the scanner.

45:01.520 --> 45:05.680
If it doesn't to the next thing, right to the beginning of the next thing, it doesn't scan

45:05.680 --> 45:11.040
that thing. It puts it right to the beginning of it. If it doesn't, if it doesn't scan anything,

45:11.040 --> 45:17.680
it needs to leave the scanner exactly how it was before it was called. And in order to accomplish

45:17.680 --> 45:24.720
that, you need to take a bookmark so that you can snap back to it, right? And I put go to here,

45:24.720 --> 45:29.200
I could probably do snap, but that would people think I would snap the shouting or whatever,

45:29.200 --> 45:32.640
go to use the one I'm going to use there. So, so that actually sets it to the cursor and the

45:32.640 --> 45:39.840
cursor is three things. It's the byte index in the buffer by buffer array of the, uh, you know,

45:39.840 --> 45:45.840
of, of the first item in, in the room, the first bite of the room. Uh, it is the room itself,

45:45.840 --> 45:49.120
a copy of the room. That's what, that's what we get when we set, when we get, when we get,

45:49.120 --> 46:02.080
go get dot rune. Um, and, and it is, um, it's also the, uh, uh, the, the, the, uh, end, the end of

46:02.080 --> 46:09.440
the room. So the, the byte pointing to the byte array to the beginning of the next thing, which is

46:09.440 --> 46:13.600
like maybe one or two, three things away. And that's, that's, that's where we got this thing.

46:13.600 --> 46:21.520
So we get like a three to four. If, if I were to scan like, uh, uh, tomato emoji, um, and I

46:21.520 --> 46:25.920
don't know where to go back to mark point, if it found the end of paragraph, it considers it advanced

46:25.920 --> 46:31.520
and no more go back to mark the point. You don't need to mark the point because the scan automatically

46:31.520 --> 46:38.160
advanced it. Yeah. Because any of the scans that fail, I'm pretty sure I'm gonna have to go back

46:38.560 --> 46:45.120
but there, there are cases, uh, uh, yeah, I read that. I have that book. I wrote that years ago,

46:45.120 --> 46:52.240
a couple of years ago. I have the PDF somewhere. Yeah, actually bought it. Uh, it's, there's that,

46:52.240 --> 46:58.720
there's that one. There's two or three go scanners in the go code base. And then there's a website

46:58.720 --> 47:02.560
that has right your own, uh, scanner and go. There's like, those are the three main things

47:02.560 --> 47:07.600
that I'd recommend if you want to start doing this kind of fun stuff. Um, but yeah, they're,

47:07.600 --> 47:13.520
they're pretty cool. Um, and you know, I'm obsessed with parsing. I'm not very good at it,

47:13.520 --> 47:19.440
but I'm obsessed with it. So, so anyway, um, mostly I'm obsessed with language and so

47:20.240 --> 47:26.320
grammars are a part of language and that's why I like it so much. Um, this is something I don't

47:26.320 --> 47:30.800
understand. What I want to do is I want to be able to specify my bonsai command lines from a pagan.

47:30.800 --> 47:37.200
Wouldn't that be cool? Uh, there, there, there is a writing compilers. Oh really?

47:37.760 --> 47:44.720
Yeah. I have to go look at that one. Um, so, so yeah, I mean a compiler is the next step,

47:44.720 --> 47:47.840
right? It's like bringing it all together and doing something with the thing you get out of it.

47:47.840 --> 47:52.880
And we, we don't have any AST, any notions of AST going on yet. That is coming. Uh, I already

47:52.880 --> 47:58.160
have all the data structures for that developed that I'm going to use for my AST. Um, and,

47:59.040 --> 48:04.000
but yeah. So, you know, you got to have push and pop for ASTs. It's like crazy. Um,

48:04.320 --> 48:10.160
yeah. I mean the hardest part, the hardest part with the AST, and we're going to get into this,

48:10.160 --> 48:19.200
is how to throw away, uh, elements of the tree that you, you can't just pop back and kind of,

48:19.200 --> 48:23.840
you know, you can't just pop back to the latest bookmark when you're doing parsing because you

48:23.840 --> 48:29.440
have all this data that you parse that you can't throw away. And it's very complicated. You can't

48:29.440 --> 48:34.400
throw it away because you don't know how much of it to throw away. And, and that's, that's going to

48:34.400 --> 48:40.400
be a big piece of this that might, that might, you know, I still have other things to do. This

48:40.400 --> 48:47.280
isn't my main, my main thing. So, uh, but I, I am interested in this. Um, so far the test case on

48:47.280 --> 48:50.320
this is so good, so important that you have lots of test cases on this. I'm pretty sure this one

48:50.320 --> 48:57.200
is good. Um, but I don't know, we'll go take a look at it later. And, and, and you know, that,

48:57.200 --> 49:02.400
but I, here's the thing, I don't want to have to keep revising all of my parsers. I wrote,

49:03.200 --> 49:08.880
I mean, I, I, I'm going to go back and open up my old pagan, uh, dev, uh,

49:09.680 --> 49:15.520
you know, I wrote an entire recursive descent parser for the pagan language itself, if I have them.

49:16.560 --> 49:24.880
Uh, and so that's going to be something that we're going to come up with later, but, um,

49:25.680 --> 49:28.640
but, but so I don't, I don't, I don't know, I don't know how that's going to,

49:28.640 --> 49:32.960
that's going to end up going down. Uh, because I, I want to be able to pull out some of that

49:32.960 --> 49:36.400
stuff from here and just reuse it because I, I've already got all the algorithms there and I can

49:36.400 --> 49:42.080
just reuse those algorithms. So that's pretty much it for YouTube. So if you want to stay tuned and

49:42.080 --> 49:45.920
to watch stuff about the pagan and keg stuff, uh, I'm probably not going to be working on much of

49:45.920 --> 49:51.200
this. I hopefully not the rest of this week. I have got a ton of work to catch up on, uh, that

49:51.200 --> 49:57.600
I'll be doing like for the rest of tonight and tomorrow morning early and, um, and we'll be,

49:57.600 --> 50:04.320
yeah, I'm going to be doing, you know, a lot of that stuff. Um, but this is sort of related to

50:04.320 --> 50:08.000
stuff we want to do at work in terms of like documentation validation. That's where it

50:08.000 --> 50:11.760
came from originally. And that's, if you want to stay tuned, we, we'll do some more of that. I,

50:11.760 --> 50:18.480
I am going to implement basic and D M D is, uh, as a, as a grammar and I'm going to be using this

50:18.480 --> 50:23.760
and we should get pretty high performance on it actually. Uh, we should have performance that

50:23.760 --> 50:30.080
rivals gold mark, uh, which because it doesn't have as much to do. Uh, so we should have performance

50:30.080 --> 50:35.200
that rivals gold mark, which is pretty much the go to standard for, uh, markdown parsing and go

50:35.200 --> 50:39.360
right now. And we'll be able to compare and do some benchmarks on that a little bit later.

50:39.360 --> 50:51.200
Um, so have fun parsing and come on by sometime. Talk to you later.

