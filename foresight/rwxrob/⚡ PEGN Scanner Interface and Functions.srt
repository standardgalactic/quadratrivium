1
00:00:00,000 --> 00:00:06,960
Go. So, lots of changes if you've been following the keg and the peg and stuff I've been doing over

2
00:00:06,960 --> 00:00:14,000
the years. I went to bed last night with my head working on a bunch of problems. I woke up and I

3
00:00:14,000 --> 00:00:20,720
just had an idea I had to finish and I've been working on it straight since, God, I don't know,

4
00:00:20,720 --> 00:00:25,520
like eight o'clock this morning. It's somewhat related to work. Don't worry, I'll make up the

5
00:00:25,520 --> 00:00:32,400
work time tomorrow and the next day and the next day, but this is really important because it's

6
00:00:32,400 --> 00:00:39,840
so key to everything else that I'm doing. So, let me try to stick with the highlights

7
00:00:41,280 --> 00:00:49,360
and hell, why don't I actually make a, use my YouTube thing. We're going to make a directory

8
00:00:49,360 --> 00:01:00,480
for this. We'll call it updates on peg. Actually, let's call it something more specific than let's say

9
00:01:00,480 --> 00:01:26,480
a peg in scanner interface and functions. So, what I've done

10
00:01:30,880 --> 00:01:37,920
so I mentioned, I mentioned the other day that interface

11
00:01:40,880 --> 00:01:48,320
and functions. Is that right? Peg and scanner interface and functions. Yeah, I mean,

12
00:01:48,320 --> 00:01:56,560
and she'll have a tool to do all that. So, okay, so

13
00:01:56,560 --> 00:02:07,120
so my my peg in scanner implementation now conforms

14
00:02:10,880 --> 00:02:25,280
now conforms to a common peg in not scanner interface so that other scanners can be implemented.

15
00:02:27,520 --> 00:02:31,520
My people that conform to it.

16
00:02:37,280 --> 00:02:42,000
So, the reason that I made an interface, why an interface

17
00:02:45,280 --> 00:02:50,080
so that the library of scanner functions of scan functions

18
00:02:50,800 --> 00:02:56,640
can be interchangeable

19
00:02:59,520 --> 00:03:08,880
with different scanner implementations. And if that's, that is the main reason.

20
00:03:10,000 --> 00:03:16,240
And let me show you what I mean by that. So, if you go to, so this is all, by the way,

21
00:03:16,240 --> 00:03:24,560
this is all I actually put in the thing related in here. So, here's the pages that

22
00:03:24,560 --> 00:03:34,960
we're going to. We're going to HTTP, github.com, rdxrub, peg in, peg in dash spec.

23
00:03:37,040 --> 00:03:39,760
And that's pretty much it. If you go there, you'll find everything.

24
00:03:40,720 --> 00:03:43,600
It used to be that I had it all over the place. And I used to have, there's this,

25
00:03:43,600 --> 00:03:48,400
there's peg in dot dev, but that's kind of, it's kind of older,

26
00:03:52,560 --> 00:04:00,400
but a little older and out of date. So, it's still there. I'm reforming the spec as we go.

27
00:04:03,360 --> 00:04:11,840
So, we want, okay, so let me, let me show you why. So, if we go to the peg in scanner itself here,

28
00:04:11,840 --> 00:04:18,720
right? So, I mean, what is the end goal? The end goal is for us to be able to parse any kind

29
00:04:18,720 --> 00:04:24,960
of language. And we started with base ML, or base MD. Now, you'll remember I was basic MD.

30
00:04:24,960 --> 00:04:33,040
I was writing a basic MD scanner. And here is the, the, the, so this was all brought about because

31
00:04:33,040 --> 00:04:52,640
of this. So, I'm just going to put all of this precipitated by the basic, basic MD, parser,

32
00:04:52,640 --> 00:05:00,880
that I was right. I mean, a scanner, parser, AST. So, I started writing that last night.

33
00:05:00,880 --> 00:05:06,720
And that was all good and everything. But it became clear to me that there, I mean,

34
00:05:06,720 --> 00:05:10,320
some of these functions, I'm going to show you one, some of these functions that I have written,

35
00:05:10,320 --> 00:05:17,680
I have written them so many times. I swear, I have written, so like, I don't know how many,

36
00:05:17,680 --> 00:05:20,480
so I didn't, thank God I didn't post it to YouTube. I'm not going to force it on you.

37
00:05:21,040 --> 00:05:28,400
But I did, I must have written a, you know, a white space or an end of line parser,

38
00:05:28,400 --> 00:05:35,040
probably a dozen times, different ways. Because I don't have, I haven't had a standardized way

39
00:05:37,840 --> 00:05:45,200
to abstract the scanner stuff in a way that didn't require rewriting a scanner. I mean,

40
00:05:45,200 --> 00:05:50,080
I've written probably, including an extremely complicated one. If you go back in my YouTube

41
00:05:50,080 --> 00:05:57,840
videos, there's something I was writing, it was called go, was it go, go compatible,

42
00:05:57,840 --> 00:06:03,760
peg in expressions? And it was actually go code that could be passed into symbols,

43
00:06:03,760 --> 00:06:07,520
that could be passed into another function that would parse it, and then it would, you know,

44
00:06:07,520 --> 00:06:11,840
it would do its thing. It was pretty cool. But every time I've written one, and then the most

45
00:06:11,840 --> 00:06:18,400
recent iteration of my scanner that I wrote, I just ripped all that crap out. I was like,

46
00:06:18,400 --> 00:06:23,840
I want the ultimate and minimal. And thank God I did that because I actually ended up

47
00:06:24,800 --> 00:06:27,840
coming up with, so here's an implementation of the new scanner interface

48
00:06:31,120 --> 00:06:37,440
that anybody can write. And all it has is, I mean, some of this stuff is internal,

49
00:06:38,160 --> 00:06:43,520
but you know, this, let me show you the interface first, actually. So let's start with the interface.

50
00:06:43,760 --> 00:06:53,440
So the scanner interface is in my types. The scanner interface is just a scanner. It's a

51
00:06:53,440 --> 00:06:59,840
rune scanner that is aware of the beginning and ending of each rune that it scans, which can

52
00:06:59,840 --> 00:07:04,000
be more than one byte, right? So people know this. So you can imagine a cursor going, you know,

53
00:07:04,000 --> 00:07:08,080
through the, through the screen like this, like with an emoji on there. And sometimes it's a thing.

54
00:07:08,080 --> 00:07:14,240
So in fact, the scanner has this idea of a rune cursor. And I used, I mean, I thought with

55
00:07:14,240 --> 00:07:18,080
myself about whether to call it cursor or not, I didn't end up keeping a concept of cursor here,

56
00:07:18,080 --> 00:07:21,360
but I might find I had it embedded and everything. I don't want to get into it.

57
00:07:21,360 --> 00:07:26,000
So ultimately, a scanner is, it's a bytes buffer. And this is another reason I put this in the

58
00:07:26,000 --> 00:07:30,560
peg. So this thing, all of this used to be under rtbx-rob slash scan. I had my own rune scanner

59
00:07:30,560 --> 00:07:40,800
in there. But I realized, and I'm going to put this in my conclusions. So I realized that,

60
00:07:40,800 --> 00:07:53,280
that my rtbx-rob scan was actually very peg specific. And what I mean by that is that

61
00:07:54,000 --> 00:08:00,160
so a couple of really important specific assumptions are made by peg. Peg assumes

62
00:08:00,160 --> 00:08:04,400
that you have infinite memory, which is, you know, the polar opposite of parsing when you're

63
00:08:04,400 --> 00:08:08,400
using anything that you would get out of the Dragon Booker and computer science class.

64
00:08:09,920 --> 00:08:13,280
And so, I mean, that's a huge thing. So if someone comes across my scanner, they're going to say,

65
00:08:13,280 --> 00:08:17,040
oh, a scanner, cool, you know, they'll make think it's a finite automata, you know,

66
00:08:17,040 --> 00:08:20,480
single look ahead kind of scanner. And they, they're like, what the hell is this thing?

67
00:08:20,480 --> 00:08:27,600
It just flipped my whole data source, you know, byte, byte buffer and into memory. I mean, that's,

68
00:08:27,600 --> 00:08:33,280
that's like, that's like an unorthodox thing to do. That's a sacrilege in this. You know,

69
00:08:33,280 --> 00:08:40,080
that's what peg does. So, so I realized that the scanner that I have built and been using the most

70
00:08:40,080 --> 00:08:42,960
recent one, which I've used all over the place, I'm using it all over the place. I'm using it in

71
00:08:42,960 --> 00:08:51,680
Bonsai and everything is actually, in fact, I think I just broke Bonsai by, no, I didn't.

72
00:08:51,680 --> 00:09:00,080
Bonsai's got its own scanner, never mind. Anyway, so I went ahead and, and implemented,

73
00:09:00,080 --> 00:09:04,960
and I actually also deprecated the other one by, because I moved the entire scanner

74
00:09:05,600 --> 00:09:11,520
into the Pagan package or the Pagan, Pagan module, because why? Because it's Pagan centric.

75
00:09:11,520 --> 00:09:16,640
It's Pagan centric because a Pagan centric scanner, you can't even use it unless you load up a buffer.

76
00:09:17,200 --> 00:09:23,200
And, you know, that's completely unheard of in other circles. So, so that was the first major

77
00:09:23,200 --> 00:09:28,160
thing. That did mean, however, though, that the, the other one that I have, which I'm leaving out

78
00:09:28,160 --> 00:09:32,160
there, because I'm pretty sure I have some dependencies on this scanner. And it's also

79
00:09:32,160 --> 00:09:37,440
listed in my awesome go list and things. And I have some pretty intense breaking changes that I

80
00:09:37,440 --> 00:09:43,360
added to this since version 10, because I changed some of the internal references and everything.

81
00:09:43,360 --> 00:09:48,640
And the more I got changing it, the more I, see right here, it says fulfills Pagan scanner face.

82
00:09:48,640 --> 00:09:55,040
It actually doesn't do that anymore. I broke that when I was doing the move. And then this is the

83
00:09:55,040 --> 00:10:03,120
most accurate thing. So I've moved this entire scanner over to RTX ROM Pagan. And it is, you know,

84
00:10:03,120 --> 00:10:10,560
implemented as, under the types. Good night. So it's implemented in the type here,

85
00:10:11,280 --> 00:10:16,880
under types, you can see the scanner is here. It gives you the cursor type and a scanner type.

86
00:10:17,440 --> 00:10:20,880
And you can look it up and it has a mark going to go to and scan and to finish.

87
00:10:21,440 --> 00:10:26,480
I mean, nothing fancy there, right? And then I implemented, they included, you know,

88
00:10:26,480 --> 00:10:30,960
reference implementation of the scanner that I use for the Pagan stuff. And this gets me to

89
00:10:30,960 --> 00:10:39,520
where I was going with base, basic marked, my basic markdown parser. So, so here we have Pagan,

90
00:10:39,520 --> 00:10:45,840
we have, so this is, this is the exact code that was in this other place. That's just been moved

91
00:10:45,840 --> 00:10:52,560
and cleaned up. And I mean, really cleaned up and had some, some other things added to it.

92
00:10:52,560 --> 00:10:57,760
For example, the fulfillment of the interface so that it can be replaced with something else at

93
00:10:57,760 --> 00:11:04,320
any time. And let me, let me talk to you about why I decided to make it an interface again.

94
00:11:04,320 --> 00:11:09,280
I mean, I started talking about that. But if you go to, so here's the interface, but as I was working

95
00:11:09,280 --> 00:11:16,960
on basic MD, I started realizing that parsing end of line and end of block and paragraphs and,

96
00:11:16,960 --> 00:11:22,560
you know, all of these things that are listed in Pagan are things that I need to do all the time.

97
00:11:22,560 --> 00:11:27,120
In fact, I just add it in paragraph, right? These are things that I already need all the time.

98
00:11:28,000 --> 00:11:33,280
And I'm like, I've always have intended to write, I mean, I've been really kind of hung up on

99
00:11:33,280 --> 00:11:38,720
creating a code generator for all of stuff that, so you write Pagan and you end up with different

100
00:11:38,720 --> 00:11:46,240
types of code, right? But to be more practical, I've started realizing all I really need to do

101
00:11:46,240 --> 00:11:51,760
is write a scanner function for each of these and then reuse them. And then the ones that I,

102
00:11:52,880 --> 00:11:58,080
that aren't in Pagan, that are specific to basic markdown or whatever, I'm writing Keg or whatever,

103
00:11:58,080 --> 00:12:06,080
I can actually write those using exactly the same function signature. And I could even put them in

104
00:12:06,800 --> 00:12:11,840
packages, you know, as a collection of first class functions, because they all accept the scanner

105
00:12:11,840 --> 00:12:19,760
interface. And that is, you know, that is go interfaces shining the brightest, right? Because

106
00:12:19,760 --> 00:12:26,880
that's what's exactly what you want to do with it. So what does that mean? So I have the scanner

107
00:12:26,880 --> 00:12:35,760
implementation here, and I can, I actually chose to make this implementation fast and abstract,

108
00:12:35,760 --> 00:12:41,280
so that if somebody chose to use it, they could use the direct references to the byte buffers

109
00:12:41,280 --> 00:12:46,400
and stuff like that, so they can bypass the indirection from the interface method calls,

110
00:12:46,400 --> 00:12:51,200
which is the reason I didn't do it originally, right? If you look at the highest performance

111
00:12:51,200 --> 00:12:55,440
parsers out there, they do not have a lot of functional indirection, right? It's actually

112
00:12:55,440 --> 00:13:00,880
one of the biggest complaints I have about the current code generator for Pagan that Quint

113
00:13:00,880 --> 00:13:07,280
mostly made, and I last two years ago, is it has a ton of function indirection in it. And that's

114
00:13:07,280 --> 00:13:13,920
been something I've been kind of like, irrationally hung up on. And I think I finally hit the middle,

115
00:13:13,920 --> 00:13:18,560
the middle of the road here. So this particular reference implementation, which is a part of

116
00:13:18,560 --> 00:13:26,160
Pagan, comes with a struct that you can use directly if you want to, which I probably will

117
00:13:26,160 --> 00:13:29,920
do and really quick and dirty, you know, I mean, not the quick and the quick and dirty stuff,

118
00:13:30,000 --> 00:13:32,960
I'll probably will use the abstractions because they're easier to remember and you can just,

119
00:13:32,960 --> 00:13:37,440
you know, you can just swap them in and out. I don't need performance, right? But if I'm like,

120
00:13:37,440 --> 00:13:43,120
really want to make a low level, really intensely often, you know, parsed grammar, then I can go

121
00:13:43,120 --> 00:13:54,400
ahead and bypass the use of those things as long as I don't want to reuse any of the stuff I've

122
00:13:54,400 --> 00:13:59,040
already write in Pagan, which brought me to think, oh, damn, you know, let's say I make a,

123
00:14:00,000 --> 00:14:04,720
here's, here's my work, my workflow. Okay, so my, I imagine the workflow of making a grammar

124
00:14:04,720 --> 00:14:08,720
or something like this, right? So in fact, this is even in a slide at Brian Ford, Brian, I was

125
00:14:08,720 --> 00:14:12,320
looking at Brian Ford's peg stuff, and he has this in a slide about, you know, traditional

126
00:14:12,320 --> 00:14:17,200
thing, use Lex and Yak and blah, blah, blah, and, and then, but, you know, the pragmatic way

127
00:14:17,200 --> 00:14:23,200
approach to doing parsing these days is to write, you know, a generic kind of specification and

128
00:14:23,200 --> 00:14:28,160
then to write a recursive descent parser. It's the standard way, the practical way to do parsing.

129
00:14:28,720 --> 00:14:32,720
And let's say I want to do that, right? So I want to write a grammar, but I want to write it

130
00:14:32,720 --> 00:14:39,360
quickly. Now, the quickest way to do it would be to do cogeneration with, you know, from Pagan

131
00:14:39,360 --> 00:14:44,240
notation, which is something I still want to do. That's nothing that Pagan, that Brian Ford ever

132
00:14:44,240 --> 00:14:47,920
wanted to do. You kind of wanted to get away from it because he realized it was just, it's just as

133
00:14:47,920 --> 00:14:52,800
fast to just write your own recursive descent functional parser and, and then be done with it.

134
00:14:52,800 --> 00:14:56,480
You don't have to deal with all the intricacies of cogeneration, not being exactly what you want.

135
00:14:56,480 --> 00:15:01,680
You just write it, right? And, and I'm kind of on board with that idea because, you know,

136
00:15:02,400 --> 00:15:05,920
it's, it's quite a bit of work to get it to generate just the way you want to. And then

137
00:15:05,920 --> 00:15:11,600
which, which cogeneration method do you want? Do you want it to be highly efficient? Do you want

138
00:15:11,600 --> 00:15:14,960
it to be used functional so it can be easily maintained? Are you going to rerun the generator

139
00:15:14,960 --> 00:15:19,760
every time? Is it just giving you the first version? And, and so at a certain point,

140
00:15:19,760 --> 00:15:24,880
you kind of come to the conclusion that probably the fastest way to create a parser is to just

141
00:15:24,880 --> 00:15:30,560
write the thing because then, you know, you're going to, you're, you're going to be done. You're

142
00:15:30,560 --> 00:15:35,280
going to be done with it and you're going to be able to move on to other things. So, um, and,

143
00:15:35,280 --> 00:15:45,680
and that's kind of where I am. So, uh, also realized, uh, fastest way to develop, uh,

144
00:15:46,640 --> 00:15:53,360
parser is to write Pagan and then function and then scanners

145
00:15:56,480 --> 00:16:01,840
functions for recursive descent. Uh,

146
00:16:03,920 --> 00:16:08,480
I mean, it really is. So by the time, you know, you get all the thing, just writing the Pagan

147
00:16:08,480 --> 00:16:14,000
itself is good. I mean, that kind of gets you thinking about how it's supposed to be implemented,

148
00:16:14,080 --> 00:16:19,680
but you're also not wrestling with Pagan syntax and stuff, uh, in case you get it wrong. Now,

149
00:16:19,680 --> 00:16:24,080
you should probably do that, but let's say you don't represent it perfectly and Pagan,

150
00:16:24,080 --> 00:16:29,440
who cares? The Pagan is just there to help you understand what the parser is going to,

151
00:16:29,440 --> 00:16:33,520
how it's going to behave. Um, and then you can, you know, compare it to that, you know, just,

152
00:16:33,520 --> 00:16:37,520
just, you know, visually and get to your, get to your point, but you can get busy kind of writing

153
00:16:37,520 --> 00:16:43,040
your parser. So, so, but, you know, along those, those lines, assuming that you're going to write

154
00:16:43,040 --> 00:16:46,640
a parser, right? You're going to go ahead and write a parser. What are the obvious building

155
00:16:46,640 --> 00:16:50,480
blocks? I mean, code generation is awesome and everything, but, but what, what would be the

156
00:16:50,480 --> 00:16:55,680
other way to do this if you didn't have code generation? Well, it gets pretty obvious that

157
00:16:55,680 --> 00:17:03,760
it would be a standardized library of scan functions, uh, that, that you regularly reuse,

158
00:17:04,720 --> 00:17:09,600
right? And if you, as long as you make those export in your public, make those public, you can,

159
00:17:09,600 --> 00:17:13,120
you can pull them in and you can tweak them and make them more efficient and other people can

160
00:17:13,120 --> 00:17:17,840
contribute their own. And, and you have, you know, you ended up getting this ecosystem of scanners,

161
00:17:18,400 --> 00:17:23,280
uh, of, you know, because that's really, the scanners are really the secret because if you

162
00:17:23,280 --> 00:17:28,400
have a scanner, you can scan it and if it scans successfully and you would get a true at the

163
00:17:28,400 --> 00:17:33,040
end of that. I mean, and this is very hastily, right? If at the end, if you get a true after that,

164
00:17:33,040 --> 00:17:38,080
you're done. You're under the next thing. If you don't get a true, then you're guaranteed that

165
00:17:38,080 --> 00:17:42,560
the scanner didn't do any advancement because it snapped back. And you're going to see this all

166
00:17:42,560 --> 00:17:46,960
over in, in my implementation of functions, which we'll show you in a second, because that is how

167
00:17:47,840 --> 00:17:53,840
you do this. And, and that is exactly how Brian Ford talks about it in his paper. It's like the

168
00:17:53,840 --> 00:17:59,520
difference between, you know, the traditional scanner and, you know, parser kind of approach.

169
00:17:59,520 --> 00:18:04,960
And this is that you can scan ahead as far as you want and you can keep track of how many

170
00:18:04,960 --> 00:18:10,800
matches you have. So you can be very greedy if you want and say, okay, so did I find anything?

171
00:18:10,800 --> 00:18:14,640
Yes, I found like 10 of them. And then I keep scanning and like, oh, hey, well, like, okay,

172
00:18:14,640 --> 00:18:19,600
I stopped. So then I like roll back to the last one that was successful. Or if there were none

173
00:18:19,600 --> 00:18:25,440
that were successful, I roll back the scanner all the way to the beginning. So, so this idea of

174
00:18:25,440 --> 00:18:31,840
snapping the scanner back and moving it and around a thing, that's a very fundamental part of the PEG

175
00:18:31,920 --> 00:18:37,680
architectural approach. Because you have memory, you have memory that you can fly around in. And

176
00:18:37,680 --> 00:18:42,320
very quickly, by the way, I mean, you know, moving pointers around in memory is crazy, crazy fast.

177
00:18:43,040 --> 00:18:46,640
And you've only had to do the one load. And so, you know, all these things that are doing like

178
00:18:46,640 --> 00:18:51,840
single byte loads, in order to do that, you've already had to buffer your data at some point. So

179
00:18:51,840 --> 00:18:55,840
you've already had to do the buffering. So, so the thing is cool about PEG is it assumes that

180
00:18:55,840 --> 00:18:59,520
you're just going to buffer all of that upfront. And then you're going to break up your content

181
00:18:59,520 --> 00:19:02,880
into manageable chunks that fit within, you know, reasonable amount of memory that you're

182
00:19:02,880 --> 00:19:07,520
going to be parsing. You should put limitations in there and stuff. And that's a part of the grammar

183
00:19:07,520 --> 00:19:13,200
design, which is another reason that PEG is a fail, because as wonderful as it is, it does not allow

184
00:19:13,200 --> 00:19:18,720
you to put limitations and constraints on this size, which is why I made PEG in. So when I say

185
00:19:19,280 --> 00:19:27,600
things like, I only want, you know, two end of lines here, I can specify two end of lines. There's

186
00:19:27,600 --> 00:19:36,240
no way in the original PEG specification example to indicate amount, which I just think is crazy,

187
00:19:36,240 --> 00:19:41,760
given the fact of, that regular expressions in ABNF have been doing it forever, and ABNF, but

188
00:19:41,760 --> 00:19:46,160
PEG decided not to do that. So that's one of the reasons I made PEG in, because we clearly want

189
00:19:46,160 --> 00:19:51,040
the combination of those things. All right, so let me go back to here. So I went ahead and I

190
00:19:51,040 --> 00:19:55,120
implemented a white space function right now. I could have probably automated this, but let's

191
00:19:55,120 --> 00:20:00,880
look at what it looks like. So if we go into the PEG and scan, and you're probably wondering, well,

192
00:20:00,880 --> 00:20:06,080
why did you name it scan? Because I wanted it to read well. So let me show you the, the examples

193
00:20:06,080 --> 00:20:12,560
here. These are go testable examples, and they are public. You'll remember maybe when I did basic

194
00:20:12,560 --> 00:20:19,520
MD that I kept a bunch of my scanning, not public. I was like, because I didn't want people to become

195
00:20:19,520 --> 00:20:26,480
dependent on my scanner functions, right? I mean, I'm just making a basic markdown part. So I don't

196
00:20:26,480 --> 00:20:31,440
want people to be, you know, including my thing, because they want my specific implementations

197
00:20:31,440 --> 00:20:35,920
of these. And that's one of the reasons I started thinking, hmm, I should probably think more deeply

198
00:20:35,920 --> 00:20:41,760
about some of these scan functions that are going to be reusable. And I should probably put them

199
00:20:41,760 --> 00:20:47,680
somewhere where they could easily be reused by me and others. And that's what got me to do this.

200
00:20:47,760 --> 00:20:52,640
So I've created a convention called sum, which is just a nice happy way. It's like, you know,

201
00:20:52,640 --> 00:20:56,800
go, they like have must and compile and things like that. So I created a convention where you

202
00:20:56,800 --> 00:21:00,800
put sum in front. These are all documenting the design considerations on the read me page, by the

203
00:21:00,800 --> 00:21:08,720
way. But sum means, you know, zero or more white space or one or more white space. So if I have

204
00:21:08,720 --> 00:21:13,440
example sum WS, so, and then I the reason I named this sub package scan is so that we would get

205
00:21:13,440 --> 00:21:19,360
these wonderful readable lines here scan dot sum white space and then pass in the scanner.

206
00:21:19,360 --> 00:21:24,160
Now you might be asking as many, many people will tell you that have done scanners that

207
00:21:24,160 --> 00:21:30,720
they implement the scanner as a class, which I think is disastrously bad architectural decision,

208
00:21:30,720 --> 00:21:37,840
because you cannot do anything with it at all. And tell you expand the class,

209
00:21:37,840 --> 00:21:43,520
that is the primary reason that people like Jim Copeland and others hate class based object

210
00:21:43,520 --> 00:21:50,160
oriented programming. It is so concrete, you can never extend it, not without re implementing the

211
00:21:50,160 --> 00:21:55,600
class or subclassing it by doing it this way. I can use first class functions is a very functional

212
00:21:55,600 --> 00:21:59,840
approach. I can use first class functions if I want, I can use it from a package, whatever,

213
00:21:59,840 --> 00:22:07,040
because the scanner is an argument to the function. And so as long as the scanner fulfills the

214
00:22:07,120 --> 00:22:11,840
interface, this is why interfaces are king. This is why interfaces are part of solid,

215
00:22:11,840 --> 00:22:16,960
even in modern Java development. If you're not doing this, if you're writing a scanner,

216
00:22:16,960 --> 00:22:21,840
writing a class and extending the class with all of the different types and then having to do that

217
00:22:21,840 --> 00:22:25,120
every time you're doing it wrong, in my opinion, because you're never going to be able to extend

218
00:22:25,120 --> 00:22:29,200
that in any way that's going to be reusable for anybody. And maybe you don't care about that.

219
00:22:29,200 --> 00:22:34,000
I do. I want it to be reusable. I want to, I want to create, ultimately, I want to build up,

220
00:22:34,000 --> 00:22:40,880
you know, hundreds or more scan functions that can be used with anything whatsoever

221
00:22:40,880 --> 00:22:45,440
that implements the scanner interface. And that's why interfaces are so amazing.

222
00:22:45,440 --> 00:22:50,880
So I pass a scanner interface, I say scan some WS and I get a true or false. So this prints out

223
00:22:50,880 --> 00:22:58,000
false because the first number is a one. Now I added a constructor. There's really not constructors

224
00:22:58,000 --> 00:23:02,800
and go, but it's the closest word for it. And this takes an optional argument. Now constructors are

225
00:23:02,800 --> 00:23:06,960
very, very high level. So they don't have to be performant, right? Especially since you're not

226
00:23:06,960 --> 00:23:13,520
going to be buffering a lot. So I put an optional parameter to on the constructor. If you pass in

227
00:23:13,520 --> 00:23:21,760
a string or a reader or a bytes buffer, any of those things, it will work. And it will just

228
00:23:22,480 --> 00:23:28,240
slurp all of the thing into memory. And then it will allow the scanner to work on that, that bytes

229
00:23:28,240 --> 00:23:33,520
buffer. And so then we do this to say, so, so you can see here, we, we, it's, you see, it was false

230
00:23:33,520 --> 00:23:40,240
that it's not currently the scan WS failed here. Because why? And you'll notice too that it didn't

231
00:23:40,240 --> 00:23:46,800
advance the, it didn't advance the, it's not supposed to. That actually looks like a mistake.

232
00:23:48,160 --> 00:23:52,480
That might be a mistake. Let me check here. Oh, no, no, no, no. Okay, let's do this.

233
00:23:53,200 --> 00:23:59,280
Wait, what? Advance to nothing at all output.

234
00:24:00,960 --> 00:24:06,160
Example sum WS. I think I might have a problem with this one. Anyway, it's supposed to,

235
00:24:06,800 --> 00:24:09,600
I just barely fixed these. That's why I want to make sure it's okay.

236
00:24:10,640 --> 00:24:16,400
Sum WS. Is it not, isn't that working? I'm going to go try something. Go test,

237
00:24:16,400 --> 00:24:27,120
run sum WS. Well, let's turn a trace on. Oh, this is cool. I finally got traced to working again.

238
00:24:28,080 --> 00:24:35,360
So trace, that'll turn trace on. And when we run it, we should be able to see every step of the way.

239
00:24:36,640 --> 00:24:44,000
So the first call to scan, got it. That's what with the first, that's every time,

240
00:24:44,000 --> 00:24:48,720
every time scan gets called, it prints it. So scan, scan the one in, and that shows us the,

241
00:24:48,720 --> 00:24:51,920
from between zero and one, and then what's left in the buffer and there's a space.

242
00:24:51,920 --> 00:24:56,560
And then it shows we scanned a, a space and that was between one and two. It could be one and three,

243
00:24:56,560 --> 00:25:02,400
depending on the size of the rune. And then as the buffer is empty. So, so that shows it's doing

244
00:25:02,400 --> 00:25:10,880
what we wanted to, I just was, oh, I know why. It's doing that because it's actually, because

245
00:25:10,880 --> 00:25:16,320
this actually did do some scanning and it did not reset. Actually, that's a, that's a, that's a

246
00:25:16,320 --> 00:25:22,320
mistake. That's a mistake. I need to fix this. This, because it didn't scan, it should not have

247
00:25:22,320 --> 00:25:25,760
advanced the buffer at all. It should have been, I've got to do this. This is a nice catch.

248
00:25:27,360 --> 00:25:31,920
And again, this is just, this is the bug in this, in the scanner function only not the scanner itself.

249
00:25:33,280 --> 00:25:38,080
Trace is internal. Trace is, Trace is a part of this scanner implementation. It's not part of

250
00:25:38,080 --> 00:25:44,560
the forced interface. No, it's not. You don't have to have a scanner in there. It's, that's part

251
00:25:44,560 --> 00:25:49,520
of this scanner implementation. So, you know, I don't want to burden people with those kind of

252
00:25:49,520 --> 00:25:56,800
details that they, they want to do their own, they can, right? So, I mean, but yeah, you could

253
00:25:56,800 --> 00:26:01,200
extend that and do what you want with it. So this is, this is actually wrong. This should have been

254
00:26:01,200 --> 00:26:04,400
x00 and it should have been

255
00:26:06,400 --> 00:26:12,320
zero to zero and then it should have been a one here. That's what it should be. And then when

256
00:26:12,320 --> 00:26:19,120
you do the scan, it should go through and then it should have been a one and a zero to one.

257
00:26:21,120 --> 00:26:27,840
And then, and then that should have left us with a space and it should have been false and then

258
00:26:27,840 --> 00:26:37,520
it should have been true. This one should have probably printed true. Yeah. Something might

259
00:26:37,520 --> 00:26:44,000
be wrong with that today. All right. So that, that's how it should look. So let's, that means

260
00:26:44,000 --> 00:26:48,480
there's a problem with my function, my scan function, which is what I was debugging before,

261
00:26:48,480 --> 00:26:52,480
but let me show you how to do this. So there may actually be a problem with my mark and I'm,

262
00:26:52,480 --> 00:26:56,080
I'm hoping not to, I think, I think that might be, there might be something wrong with my mark,

263
00:26:56,080 --> 00:26:59,680
which is relatively new. But the point is, I don't know if you saw the functions I was writing

264
00:26:59,680 --> 00:27:07,680
yesterday, but these are way, way simpler, right? They just have to scan and check what the runes are

265
00:27:08,320 --> 00:27:14,960
and scan again and the, the idiom is the same no matter what. You take a, you take a bookmark to

266
00:27:14,960 --> 00:27:20,000
it at the beginning and you revert back to the bookmark if you're, if you didn't find anything,

267
00:27:20,000 --> 00:27:25,200
right? And you leave things as they are. Otherwise you let the scanner happily proceed along

268
00:27:25,760 --> 00:27:29,440
and it's not like there's a lot of cash in there so that you, you know, you'd have problems there.

269
00:27:32,080 --> 00:27:35,120
But yeah, I have, I have a problem with this one. I got to come back to that. I can't see it right

270
00:27:35,120 --> 00:27:41,040
out hand, but so this is actually, you know, this, this is supposed to scan as much white

271
00:27:41,040 --> 00:27:49,600
space as possible. I think the problem is, I don't know, we might be getting ruined. I don't

272
00:27:49,600 --> 00:27:53,200
know, I'll have to go debug this one. But if, if I wanted to just debug this one too, I could

273
00:27:53,200 --> 00:27:59,920
also just do this. I could just do s.trace and turn on the tracing in here while I'm doing this

274
00:27:59,920 --> 00:28:07,440
debugging. I can put it there in the test either way. Oh, it's not, that's right. I forgot about

275
00:28:07,440 --> 00:28:12,000
that. Man, this is going to be interesting. Yeah. Cause you just said, is that in the, is that in the

276
00:28:12,000 --> 00:28:22,080
debug output? Interesting. Yeah, I just realized I'm saying, because I locked down the interface

277
00:28:22,080 --> 00:28:24,800
and I'm going to keep a bunch of stuff out of here. I'm not going to be able to do because,

278
00:28:24,800 --> 00:28:28,960
because this is, expects a scanner interface and that means only things that are, are defined in

279
00:28:28,960 --> 00:28:33,520
the scanner interface can, can turn on. I wonder if we should make trace into the part of the

280
00:28:33,520 --> 00:28:38,240
interface. We should say you need to implement some form of activating trace. I don't think we

281
00:28:38,240 --> 00:28:43,680
should. I mean, I think, I think we should leave that in the tests stuff because people can set up

282
00:28:43,680 --> 00:28:47,920
their own test cases and then, and then call it that way. I, I, I don't know. I thought about it

283
00:28:47,920 --> 00:28:54,160
for a second though. This is just as good, right? Having the trace appear. Because this is, is, is

284
00:28:54,160 --> 00:29:01,120
using a specific scanner that fulfills the, the interface and therefore it can have extra things

285
00:29:01,120 --> 00:29:04,560
in it like trace. The other one doesn't have anything, any knowledge of it at all. And it

286
00:29:04,560 --> 00:29:09,120
shouldn't, right? We don't, that's again, I want to, I want to double check that everybody understands

287
00:29:09,200 --> 00:29:15,680
this. So we do not want people writing, you know, Pagan or any

288
00:29:18,880 --> 00:29:25,040
scanners functions that are going to be doing fancy things that are not defined by the interface.

289
00:29:25,600 --> 00:29:30,560
Because if you do, then they won't work with interchangeably with other scanners.

290
00:29:31,680 --> 00:29:35,840
And that, that's not ideal, right? We want to be able to have people write

291
00:29:35,840 --> 00:29:40,000
very highly optimized scanners however they want. I mean, all of them obviously are going to have the,

292
00:29:40,000 --> 00:29:43,520
the downside of having to call out to a function to do their thing. But that's,

293
00:29:43,520 --> 00:29:47,200
it's not too bad. But that way people can supplement the scanner that I've made or make

294
00:29:47,200 --> 00:29:51,680
their own or something like that. And they can, they can share all of these scan functions with

295
00:29:51,680 --> 00:29:56,400
each other. And we can make libraries of scan functions that do different amazing things. So

296
00:29:56,400 --> 00:30:00,480
it's basically like creating a library of regular expressions. And if you look at

297
00:30:01,040 --> 00:30:08,400
the Pagan stuff that I've been doing, you can see that we've got a lot of functions to write.

298
00:30:08,400 --> 00:30:14,160
So over the next year or two, I'll be implementing individual scan functions

299
00:30:14,720 --> 00:30:22,400
for the different types of stuff that is included here and in our tokens. And yes, we're going to

300
00:30:22,400 --> 00:30:28,640
have, we're going to have functions for things that are strictly static. And the reason is that

301
00:30:28,640 --> 00:30:33,200
is to keep everything functional because we need to be able to pass the scanner to it, right?

302
00:30:34,960 --> 00:30:38,640
We don't, if we didn't do that, we would have different kinds of dependencies. We would have

303
00:30:38,640 --> 00:30:45,600
dependencies on the Pagan like implementation to some degree, I think. And so that, I mean,

304
00:30:45,600 --> 00:30:50,640
it's not that much extra. Before I was like calling out to a function just to parse the

305
00:30:50,640 --> 00:30:54,240
references to the other functions. So there is, it's not going to be any less performant than

306
00:30:54,240 --> 00:30:57,920
any of the other stuff. And that's really premature optimization. If somebody really,

307
00:30:57,920 --> 00:31:03,120
really, really wants that level of performance, they probably should write their own scanner and,

308
00:31:03,120 --> 00:31:08,160
and, you know, maybe just use some of the scan functions without, without it and not, and not

309
00:31:08,160 --> 00:31:14,880
bibbed. So, but I will be writing like, I'll probably be auto generating a bunch of go code to,

310
00:31:15,600 --> 00:31:21,360
to, you know, to, to, to, to stand for each one of these, these scan functions. And then they'll

311
00:31:21,360 --> 00:31:26,080
all be under scan dot whatever. So I'll be able to just on any project, just be able to import

312
00:31:26,080 --> 00:31:32,480
artifacts, Rob slash Pagan slash scan, and I can get any and all of these that I want.

313
00:31:34,080 --> 00:31:39,120
And it's not that big, actually, because it's just text parsing, right? It, it seems big because

314
00:31:39,120 --> 00:31:42,800
it's a lot of code for us to write, but it, but it's most of it's going to get inlined and the

315
00:31:42,800 --> 00:31:47,120
size of the package isn't going to be too big. And, and then we can, we get kind of like this

316
00:31:47,120 --> 00:31:52,800
regular expression engine that's on steroids, because now we can just write our own recursive

317
00:31:52,800 --> 00:31:57,680
descent parsers as easily or if not easier than we could write regex, you know, complex

318
00:31:57,680 --> 00:32:01,680
regex expressions. And that, that to me is kind of the Holy Grail, because that's what I want to do.

319
00:32:01,680 --> 00:32:05,520
I, I have like four or five grammars that I want to finish that I'm kind of waiting on.

320
00:32:05,520 --> 00:32:12,560
And this is, that's, that's where, that's where it leaves us. All right. So I need to come back

321
00:32:12,560 --> 00:32:16,160
and fix this white space one. Let's go back and look at one that maybe works better. So

322
00:32:16,880 --> 00:32:22,480
here we have, and I put the pagan line up here. So an end of the line is, you know,

323
00:32:22,480 --> 00:32:29,280
we scan the found Boolean stuff. We don't really need that. I could have just done a return right

324
00:32:29,280 --> 00:32:38,880
here and call it a day and not gotten all the way down here. And the reason I didn't do that

325
00:32:38,880 --> 00:32:45,840
initially is because I wanted to think about how this code could be auto generated. But

326
00:32:45,920 --> 00:32:53,840
now that I'm looking at it, I am totally okay doing that. So, so we can just do a return true there.

327
00:32:55,520 --> 00:33:01,680
Here we can just do a return true. Yeah. And if we make it down this far,

328
00:33:02,560 --> 00:33:07,680
that means we didn't find it. And we need to do that. So that this is, this is not hungry.

329
00:33:08,320 --> 00:33:12,960
If you're using something that's hungry. Yeah, you might, you might have a different problem,

330
00:33:12,960 --> 00:33:22,080
right? Because, you know, you need to, yeah, you need to, if you're having something that's like

331
00:33:22,080 --> 00:33:26,720
hungry and greedy, you need to like count all the fines and you'll see that, you'll see that kind

332
00:33:26,720 --> 00:33:37,360
of thing happening over time. Oopsie, did I refer to found in here? Return false. So I mean,

333
00:33:37,360 --> 00:33:41,760
that's a simplification we can do. Again, these are, I want these to be highly optimized. Another

334
00:33:41,760 --> 00:33:47,840
reason, by the way, that I think code generation is probably the wrong way to go. And the more I

335
00:33:47,840 --> 00:33:53,520
keep coming back to this, the more I think that hand crafting a recursive descent parser from a huge

336
00:33:53,520 --> 00:33:59,920
library of existing scanners, scan scan functions is a better idea. Because of this problem that you

337
00:33:59,920 --> 00:34:07,120
just saw, the optimization I just made is the kind of thing that would take an extreme amount of

338
00:34:07,680 --> 00:34:12,400
intelligence in the code to be able to write it in a code generator. Whereas if I'm just writing

339
00:34:12,400 --> 00:34:18,000
the parser, I can take, I can do tricks and stuff inside of my functional parser to make it really,

340
00:34:18,000 --> 00:34:24,720
really optimized for this particular scenario, you know, and, and I can do things that couldn't be

341
00:34:24,720 --> 00:34:30,480
done if I were to just to generalize the generation of this code from the syntax. So what I'm saying,

342
00:34:31,120 --> 00:34:38,000
and I'm going to put this in here is that I am, I'm kind of souring on the idea of code generation.

343
00:34:39,920 --> 00:34:53,280
So I'm souring on the idea of Pagan to code generation, because it's removing, you know,

344
00:34:53,840 --> 00:35:04,080
it, it, it prevents, it precludes optimizations that only, that only a person could do.

345
00:35:05,200 --> 00:35:09,600
And, you know, people definitely do this. And if you're going to, I mean, at the end of the day,

346
00:35:09,600 --> 00:35:15,200
we're writing a compiler when we do that kind of thing. And, you know, there are people that have

347
00:35:15,200 --> 00:35:20,560
spent their entire lives dedicated to compiler optimizations. Well, one of the reasons that

348
00:35:20,560 --> 00:35:25,840
having a human write a scan function is better is because depending on the language they're writing

349
00:35:25,840 --> 00:35:34,240
it for, they might already know how the compiler is going to inline that code. So, so, you know,

350
00:35:34,240 --> 00:35:39,200
having some generic size rendering of the code may not be able to take advantage of those things.

351
00:35:39,200 --> 00:35:44,320
And, you know, premature optimization, yes, right, we want to avoid premature optimization, but,

352
00:35:44,320 --> 00:35:49,920
but at the same time, we don't want to be forced into doing things that, that we could do

353
00:35:50,960 --> 00:35:55,120
because we know about them later on. We could come back to the code

354
00:35:55,120 --> 00:35:58,880
and we could actually say, well, okay, let's optimize this one, because this is that my

355
00:35:58,880 --> 00:36:04,240
pagan function for parsing, you know, wide space, the most important thing that I'm ever going to

356
00:36:04,240 --> 00:36:08,080
write, it's going to be used by millions of people or whatever. And, and I should really,

357
00:36:08,080 --> 00:36:13,120
really optimize that one function. And then everybody can spend their time optimizing the

358
00:36:13,120 --> 00:36:19,520
functions that we have for parsing those specific things. And we can maintain a community library

359
00:36:19,520 --> 00:36:23,600
of this, rather than having everybody write the best, you know, their own wide space parser,

360
00:36:24,560 --> 00:36:29,360
right? So we can actually have a collective community of contributions that from people

361
00:36:29,360 --> 00:36:34,640
who know about parsing, or really, you know, amazing Go specialists who have, have, you know,

362
00:36:34,640 --> 00:36:39,600
know how to optimize code based on what they're, what they know about inlining. So, so yeah,

363
00:36:39,600 --> 00:36:46,560
no more code generation, just a lot of pre-generated libraries that are immediately importable.

364
00:36:46,560 --> 00:36:51,280
And then we can just write, you know, in if statements and switch statements, and you can

365
00:36:51,280 --> 00:36:55,360
write your own thing really quickly. And I think that's really going to be the new normal

366
00:36:57,120 --> 00:37:05,920
useful form overlooks. Yeah. And so, so, so yeah, I think, I think, I think that that's,

367
00:37:05,920 --> 00:37:14,320
that's kind of how I am with this. That is why you're developing anything. Yeah. I, I, I think

368
00:37:14,400 --> 00:37:18,640
that the code generation thing, I mean, this doesn't mean we're not going to do some code

369
00:37:18,640 --> 00:37:24,880
generation, right? But we're going to statefully code generate like all the functions for the,

370
00:37:24,880 --> 00:37:32,160
the 200 or so Unicode classes, which by the way, already have functions. Yeah. So for those kind

371
00:37:32,160 --> 00:37:36,320
of things, we're just, that's exactly how Go does it, by the way. Go takes that document,

372
00:37:36,320 --> 00:37:41,680
and it generates the Go code from straight up from the, from the Unicode specification document.

373
00:37:41,680 --> 00:37:47,440
And it has a, you know, a whole library of, of, you know, true or false kind of things, right?

374
00:37:49,200 --> 00:37:55,280
But it's not a scanner. And so the only thing we're going to have to do in the Go one is

375
00:37:55,280 --> 00:38:00,800
basically the same idea, but we're going to say, okay, is this thing a thing? And then,

376
00:38:00,800 --> 00:38:06,720
and then we'll make a sum variation as well, so that it'll be like one or more of those things,

377
00:38:06,720 --> 00:38:12,800
right? And, and all that code will get auto generated. So we'll have a pretty big library

378
00:38:12,800 --> 00:38:17,360
of scanners that'll be developed that you can then make your recursive descent

379
00:38:17,360 --> 00:38:23,040
parsers from. And maybe we can get somebody else to actually think it's a good idea besides me.

380
00:38:26,880 --> 00:38:30,240
Optimizing a lot first is that you can find you don't need the functions you're optimizing. No,

381
00:38:30,240 --> 00:38:35,120
that's right. So I'm saying, so a lot of them, yeah, you could combine the two things together

382
00:38:35,120 --> 00:38:42,320
or something, right? Yeah. So, so I think, I think I'm kind of happy with this where we're

383
00:38:42,320 --> 00:38:49,920
going with this now. Now I still have this, this bug here, my white space bug. But the other one

384
00:38:49,920 --> 00:39:00,240
is fine. Let's, let's try to run that one. Let's do run. What was it the end of line? End of line,

385
00:39:00,240 --> 00:39:07,360
I think, right? Oops, we need to let's turn scanning on end of line. So you can see it

386
00:39:09,280 --> 00:39:18,560
end line. Then there's lots of in lines. So she was the carriage feed one. Actually,

387
00:39:18,560 --> 00:39:25,280
let's just turn it on for the whole, the whole scanner. Yeah, scanner scanner has a trace for

388
00:39:25,280 --> 00:39:29,200
the whole entire package if you want to turn tracing on on everything.

389
00:39:31,840 --> 00:39:40,560
Yeah. Trace equals, I'm probably have to do an init here. Trace equals one.

390
00:39:41,440 --> 00:39:45,360
Yeah, that's going to say you need to put that in an init. All right, fine.

391
00:39:47,360 --> 00:39:52,720
This is just for now. There's other testing ways to do this, but I'll just do that for now.

392
00:39:52,800 --> 00:39:59,680
So we could go test. So actually, this is going to show every single parts that we did.

393
00:40:00,320 --> 00:40:06,400
I'm so happy with this. So when you turn the trace on, when you turn it on this way,

394
00:40:06,400 --> 00:40:12,400
it'll actually give you like the full thing. So here it was, it was, it, it read the first

395
00:40:12,400 --> 00:40:17,600
carriage return and then a line return and then another line return. So that, that was that one

396
00:40:17,600 --> 00:40:20,560
that we did. And there's another one. So these are all the different ones. There's no other printing

397
00:40:20,560 --> 00:40:24,880
statements going on in there, but you can kind of watch what's getting parsed as you go

398
00:40:26,560 --> 00:40:29,840
and check on it. And you can go, go look at that and see if you like it.

399
00:40:31,440 --> 00:40:34,240
But yeah, I mean, it's working without that portal pass. I just got that white space one

400
00:40:34,240 --> 00:40:38,800
I have to figure out. So I think that's enough for this video. I just, I just wanted to show

401
00:40:39,360 --> 00:40:45,680
where I was. Some of the, I mean, I don't got the, the, the end paragraph turns out to be end block.

402
00:40:46,400 --> 00:40:50,880
So remember yesterday I was doing basic markdown and I was like, hmm, we need to

403
00:40:50,880 --> 00:40:55,280
delineate our blocks. Well, what is, what do we have? We have any number of spaces

404
00:40:56,800 --> 00:41:04,240
and then a greedy include of, of white space and line returns, you know, and that's what this is.

405
00:41:04,240 --> 00:41:08,720
So I had to actually re, I had to rewrite it and say, do I have the end of,

406
00:41:08,720 --> 00:41:14,320
do I have the end of the data? Do I have an end of line and then the end of the data?

407
00:41:14,320 --> 00:41:18,960
Or do I have two end of lines, which are, you know, the greedy thing and then the white space

408
00:41:18,960 --> 00:41:24,640
splat and, you know, peg, uh, repeat operators are greedy by default. So that says, grab as

409
00:41:24,640 --> 00:41:28,720
much white space as you can. As far as I know, I might have that wrong, but grab as much white

410
00:41:28,720 --> 00:41:36,000
space as you can and then make sure you have this at the end, right? Now it may be that I have to,

411
00:41:37,280 --> 00:41:44,240
uh, uh, if I were to put this up here in the front, then it would be non greedy. So it would

412
00:41:44,720 --> 00:41:50,160
it would get, you know, it would, it would get the first one. So the first match of,

413
00:41:50,160 --> 00:41:54,640
I had that happening before I had the first match of, of a line of double line returns

414
00:41:54,640 --> 00:41:59,200
and it got the first one. So that's how you, you do non greedy is you put that stuff up in front

415
00:41:59,200 --> 00:42:02,880
here, but you have to kind of look at the peg and syntax, the peg syntax to get that. That's,

416
00:42:02,880 --> 00:42:08,560
that's from Brian Ford. That's not for me. Uh, but, and I still have to go look it up here as well.

417
00:42:08,560 --> 00:42:11,520
But it's, I, once you get it, it's much easier than regular expressions. It's not,

418
00:42:11,680 --> 00:42:14,320
actually it has positive negative look ahead and all that kind of thing,

419
00:42:14,320 --> 00:42:17,680
which regular expressions, depending on which engine you're using, don't really do well.

420
00:42:18,880 --> 00:42:22,640
Not to mention, you know, the ability to capture thing. So, and, and I use the,

421
00:42:22,640 --> 00:42:28,960
I use the block here and go to, uh, which I actually prefer to for loops because

422
00:42:29,920 --> 00:42:35,680
they just are so much cleaner. Um, because you just know you're going to go up to the top again

423
00:42:35,680 --> 00:42:41,040
and you know, you know, the thing I like about it's much easier. I mean, it's much harder to

424
00:42:41,040 --> 00:42:47,520
write an infinite loop with a labeled block than it is with an infinite forever loop,

425
00:42:47,520 --> 00:42:53,040
which is just for, and I used to do them that way. Um, because, I mean, you definitely can,

426
00:42:53,040 --> 00:42:58,560
but you have to explicitly create an infinite loop that keeps going to the top again, right? So,

427
00:42:58,560 --> 00:43:05,120
it's kind of like a do while. Um, and you see this all the time in parsers. This is in go, it's in,

428
00:43:05,120 --> 00:43:12,080
and goes compiler for the language that go to is a very real, uh, solid thing to use for,

429
00:43:12,880 --> 00:43:17,920
uh, for compilers and for parsers and scanners. And it saves you from any kind of functional

430
00:43:17,920 --> 00:43:22,480
recursion, which is the devil when it comes to performance and parsers because you hit, you hit,

431
00:43:22,480 --> 00:43:27,440
um, you hit, you know, you hit, uh, indirection functional loops, uh, functional recursion loops

432
00:43:27,440 --> 00:43:32,000
and stuff like that. Some languages is the preferred way to do it, but, but, but most

433
00:43:32,080 --> 00:43:36,320
of the languages or not, most of them want you to just stay within there and kind of

434
00:43:36,320 --> 00:43:40,320
figure out a way to short circuit and go back up to the top. And it's more performant that way too.

435
00:43:40,960 --> 00:43:47,840
So this one has to have the whole notion of a found Boolean in it because even if I find one,

436
00:43:47,840 --> 00:43:52,160
I still want to look for more. I still keep wanting to look for more until I get,

437
00:43:52,160 --> 00:43:57,200
I'm greedily get the, the last one, right? And I, before I added a notion of a, of a found loop in

438
00:43:57,200 --> 00:44:02,000
that I, I wasn't getting everything. And so what it does is it keeps getting stuff until it hits

439
00:44:02,000 --> 00:44:08,320
something that is not valid. And it's like, okay, I finally run out, but did I ever find anything

440
00:44:08,320 --> 00:44:14,160
along the way? I was like, Oh yeah. Okay. Well, what was the last one that I did find? And, and then,

441
00:44:14,160 --> 00:44:20,960
you know, it can, it can tell you that thing. Um, and, and that's what the go to is. Um, this is

442
00:44:20,960 --> 00:44:26,400
actually wrong. I'm just realizing I have some problems with this. Yeah. It's funny because

443
00:44:26,400 --> 00:44:30,720
now that it's cleaner and I've got to spend my whole day fixing up all of this syntax, I can see

444
00:44:30,720 --> 00:44:37,280
that this is probably wrong because this is, this is going to, uh, this is, if it, if, oh no, no,

445
00:44:37,280 --> 00:44:43,040
I'm sorry. No, I'm, I'm sorry. This is only if it's not found. Yeah. This is only if it's not

446
00:44:43,040 --> 00:44:48,240
found. Yeah. So scanners do not advance. So the rule, this is a kind of a hard thing to,

447
00:44:48,240 --> 00:44:52,240
to come up with when you're trying to figure out how to make your parsers and functions and stuff.

448
00:44:52,240 --> 00:45:00,960
But the easiest rule is for a scanner is if it scans, it returns true and it advances the scanner.

449
00:45:01,520 --> 00:45:05,680
If it doesn't to the next thing, right to the beginning of the next thing, it doesn't scan

450
00:45:05,680 --> 00:45:11,040
that thing. It puts it right to the beginning of it. If it doesn't, if it doesn't scan anything,

451
00:45:11,040 --> 00:45:17,680
it needs to leave the scanner exactly how it was before it was called. And in order to accomplish

452
00:45:17,680 --> 00:45:24,720
that, you need to take a bookmark so that you can snap back to it, right? And I put go to here,

453
00:45:24,720 --> 00:45:29,200
I could probably do snap, but that would people think I would snap the shouting or whatever,

454
00:45:29,200 --> 00:45:32,640
go to use the one I'm going to use there. So, so that actually sets it to the cursor and the

455
00:45:32,640 --> 00:45:39,840
cursor is three things. It's the byte index in the buffer by buffer array of the, uh, you know,

456
00:45:39,840 --> 00:45:45,840
of, of the first item in, in the room, the first bite of the room. Uh, it is the room itself,

457
00:45:45,840 --> 00:45:49,120
a copy of the room. That's what, that's what we get when we set, when we get, when we get,

458
00:45:49,120 --> 00:46:02,080
go get dot rune. Um, and, and it is, um, it's also the, uh, uh, the, the, the, uh, end, the end of

459
00:46:02,080 --> 00:46:09,440
the room. So the, the byte pointing to the byte array to the beginning of the next thing, which is

460
00:46:09,440 --> 00:46:13,600
like maybe one or two, three things away. And that's, that's, that's where we got this thing.

461
00:46:13,600 --> 00:46:21,520
So we get like a three to four. If, if I were to scan like, uh, uh, tomato emoji, um, and I

462
00:46:21,520 --> 00:46:25,920
don't know where to go back to mark point, if it found the end of paragraph, it considers it advanced

463
00:46:25,920 --> 00:46:31,520
and no more go back to mark the point. You don't need to mark the point because the scan automatically

464
00:46:31,520 --> 00:46:38,160
advanced it. Yeah. Because any of the scans that fail, I'm pretty sure I'm gonna have to go back

465
00:46:38,560 --> 00:46:45,120
but there, there are cases, uh, uh, yeah, I read that. I have that book. I wrote that years ago,

466
00:46:45,120 --> 00:46:52,240
a couple of years ago. I have the PDF somewhere. Yeah, actually bought it. Uh, it's, there's that,

467
00:46:52,240 --> 00:46:58,720
there's that one. There's two or three go scanners in the go code base. And then there's a website

468
00:46:58,720 --> 00:47:02,560
that has right your own, uh, scanner and go. There's like, those are the three main things

469
00:47:02,560 --> 00:47:07,600
that I'd recommend if you want to start doing this kind of fun stuff. Um, but yeah, they're,

470
00:47:07,600 --> 00:47:13,520
they're pretty cool. Um, and you know, I'm obsessed with parsing. I'm not very good at it,

471
00:47:13,520 --> 00:47:19,440
but I'm obsessed with it. So, so anyway, um, mostly I'm obsessed with language and so

472
00:47:20,240 --> 00:47:26,320
grammars are a part of language and that's why I like it so much. Um, this is something I don't

473
00:47:26,320 --> 00:47:30,800
understand. What I want to do is I want to be able to specify my bonsai command lines from a pagan.

474
00:47:30,800 --> 00:47:37,200
Wouldn't that be cool? Uh, there, there, there is a writing compilers. Oh really?

475
00:47:37,760 --> 00:47:44,720
Yeah. I have to go look at that one. Um, so, so yeah, I mean a compiler is the next step,

476
00:47:44,720 --> 00:47:47,840
right? It's like bringing it all together and doing something with the thing you get out of it.

477
00:47:47,840 --> 00:47:52,880
And we, we don't have any AST, any notions of AST going on yet. That is coming. Uh, I already

478
00:47:52,880 --> 00:47:58,160
have all the data structures for that developed that I'm going to use for my AST. Um, and,

479
00:47:59,040 --> 00:48:04,000
but yeah. So, you know, you got to have push and pop for ASTs. It's like crazy. Um,

480
00:48:04,320 --> 00:48:10,160
yeah. I mean the hardest part, the hardest part with the AST, and we're going to get into this,

481
00:48:10,160 --> 00:48:19,200
is how to throw away, uh, elements of the tree that you, you can't just pop back and kind of,

482
00:48:19,200 --> 00:48:23,840
you know, you can't just pop back to the latest bookmark when you're doing parsing because you

483
00:48:23,840 --> 00:48:29,440
have all this data that you parse that you can't throw away. And it's very complicated. You can't

484
00:48:29,440 --> 00:48:34,400
throw it away because you don't know how much of it to throw away. And, and that's, that's going to

485
00:48:34,400 --> 00:48:40,400
be a big piece of this that might, that might, you know, I still have other things to do. This

486
00:48:40,400 --> 00:48:47,280
isn't my main, my main thing. So, uh, but I, I am interested in this. Um, so far the test case on

487
00:48:47,280 --> 00:48:50,320
this is so good, so important that you have lots of test cases on this. I'm pretty sure this one

488
00:48:50,320 --> 00:48:57,200
is good. Um, but I don't know, we'll go take a look at it later. And, and, and you know, that,

489
00:48:57,200 --> 00:49:02,400
but I, here's the thing, I don't want to have to keep revising all of my parsers. I wrote,

490
00:49:03,200 --> 00:49:08,880
I mean, I, I, I'm going to go back and open up my old pagan, uh, dev, uh,

491
00:49:09,680 --> 00:49:15,520
you know, I wrote an entire recursive descent parser for the pagan language itself, if I have them.

492
00:49:16,560 --> 00:49:24,880
Uh, and so that's going to be something that we're going to come up with later, but, um,

493
00:49:25,680 --> 00:49:28,640
but, but so I don't, I don't, I don't know, I don't know how that's going to,

494
00:49:28,640 --> 00:49:32,960
that's going to end up going down. Uh, because I, I want to be able to pull out some of that

495
00:49:32,960 --> 00:49:36,400
stuff from here and just reuse it because I, I've already got all the algorithms there and I can

496
00:49:36,400 --> 00:49:42,080
just reuse those algorithms. So that's pretty much it for YouTube. So if you want to stay tuned and

497
00:49:42,080 --> 00:49:45,920
to watch stuff about the pagan and keg stuff, uh, I'm probably not going to be working on much of

498
00:49:45,920 --> 00:49:51,200
this. I hopefully not the rest of this week. I have got a ton of work to catch up on, uh, that

499
00:49:51,200 --> 00:49:57,600
I'll be doing like for the rest of tonight and tomorrow morning early and, um, and we'll be,

500
00:49:57,600 --> 00:50:04,320
yeah, I'm going to be doing, you know, a lot of that stuff. Um, but this is sort of related to

501
00:50:04,320 --> 00:50:08,000
stuff we want to do at work in terms of like documentation validation. That's where it

502
00:50:08,000 --> 00:50:11,760
came from originally. And that's, if you want to stay tuned, we, we'll do some more of that. I,

503
00:50:11,760 --> 00:50:18,480
I am going to implement basic and D M D is, uh, as a, as a grammar and I'm going to be using this

504
00:50:18,480 --> 00:50:23,760
and we should get pretty high performance on it actually. Uh, we should have performance that

505
00:50:23,760 --> 00:50:30,080
rivals gold mark, uh, which because it doesn't have as much to do. Uh, so we should have performance

506
00:50:30,080 --> 00:50:35,200
that rivals gold mark, which is pretty much the go to standard for, uh, markdown parsing and go

507
00:50:35,200 --> 00:50:39,360
right now. And we'll be able to compare and do some benchmarks on that a little bit later.

508
00:50:39,360 --> 00:50:51,200
Um, so have fun parsing and come on by sometime. Talk to you later.

