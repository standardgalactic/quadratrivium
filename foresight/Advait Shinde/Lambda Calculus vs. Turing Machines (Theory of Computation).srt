1
00:00:01,000 --> 00:00:02,760
All right, let's jump in.

2
00:00:02,760 --> 00:00:07,320
Cool, introduction to the theory of computation.

3
00:00:07,320 --> 00:00:10,080
I have been more excited about this talk

4
00:00:10,080 --> 00:00:13,520
than any other talk that I've given in my entire life.

5
00:00:13,520 --> 00:00:14,880
So forget about the company vision.

6
00:00:14,880 --> 00:00:17,120
We're talking about the theory of computing.

7
00:00:19,000 --> 00:00:21,980
I learned, I was introduced to some of this stuff

8
00:00:21,980 --> 00:00:26,680
when I was an undergrad at UCLA about 10 years ago

9
00:00:26,680 --> 00:00:29,480
and I didn't understand it.

10
00:00:29,480 --> 00:00:32,020
And it was kind of presented as like,

11
00:00:33,040 --> 00:00:36,520
here's the sort of tablets from the mountain

12
00:00:36,520 --> 00:00:40,560
and learn and memorize them and this is why computing is.

13
00:00:40,560 --> 00:00:43,440
And it took me 10 years and I finally understand it.

14
00:00:43,440 --> 00:00:45,640
And it's so mind blowing that I wanted to talk

15
00:00:45,640 --> 00:00:46,480
to you guys about it.

16
00:00:46,480 --> 00:00:48,400
So this is what it's about.

17
00:00:48,400 --> 00:00:50,800
The subtext of this is it's a tale of two towers

18
00:00:50,800 --> 00:00:52,840
and this will make sense as we get into it.

19
00:00:52,840 --> 00:00:56,980
But the preface is an intro to axiomatic thinking.

20
00:00:56,980 --> 00:00:59,200
This is a kind of strange way of thinking

21
00:00:59,240 --> 00:01:02,280
if you guys haven't been introduced to formal math.

22
00:01:03,840 --> 00:01:05,480
It's not, it's strange.

23
00:01:05,480 --> 00:01:06,460
Let's just jump in.

24
00:01:06,460 --> 00:01:11,460
So two plus three times seven, this is I think 23.

25
00:01:14,240 --> 00:01:16,680
Why do we know the answer to this?

26
00:01:16,680 --> 00:01:19,760
And I asked this question and I encourage you guys

27
00:01:19,760 --> 00:01:23,040
to take the perspective as if you were like an alien

28
00:01:23,040 --> 00:01:27,000
who has never really seen symbols like this.

29
00:01:27,000 --> 00:01:28,560
Or perhaps you didn't even understand

30
00:01:28,600 --> 00:01:30,920
the concept of multiplication or addition.

31
00:01:30,920 --> 00:01:32,840
How do you know what to do over here?

32
00:01:32,840 --> 00:01:34,600
So let's just step through it.

33
00:01:34,600 --> 00:01:37,400
The first thing that you would do is three times seven is 21

34
00:01:37,400 --> 00:01:39,320
and two plus 21 is 23.

35
00:01:39,320 --> 00:01:40,880
So what do we have over here?

36
00:01:40,880 --> 00:01:44,280
We have these symbols called numbers.

37
00:01:44,280 --> 00:01:46,800
We have these things called operators.

38
00:01:46,800 --> 00:01:48,800
And then we have this interesting thing over here

39
00:01:48,800 --> 00:01:53,800
where we can substitute an operator for its equivalent form.

40
00:01:54,320 --> 00:01:57,400
So three times seven is the same thing as 21.

41
00:01:57,400 --> 00:02:00,080
Here we've kind of made that substitution.

42
00:02:00,080 --> 00:02:02,520
And then these operators also have precedents.

43
00:02:02,520 --> 00:02:05,320
Like we knew to do three times seven first

44
00:02:05,320 --> 00:02:07,600
because of all of the middle school math homework

45
00:02:07,600 --> 00:02:08,760
that we did.

46
00:02:08,760 --> 00:02:11,960
And then we have this final reduced form.

47
00:02:11,960 --> 00:02:16,440
So in theory, each of these levels are equal to each other

48
00:02:16,440 --> 00:02:18,960
because we've just kind of made substitutions along the way.

49
00:02:18,960 --> 00:02:21,880
And what I'm trying to get at is we have these collections

50
00:02:21,880 --> 00:02:23,840
of rules that we kind of take for granted

51
00:02:23,840 --> 00:02:25,920
that we never really thought too much about.

52
00:02:25,960 --> 00:02:30,960
That if you really examine like across representing

53
00:02:32,000 --> 00:02:36,080
an operation or this little like two and one

54
00:02:36,080 --> 00:02:38,720
like right next to each other represent 21

55
00:02:38,720 --> 00:02:41,760
these are really kind of non-trivial concepts.

56
00:02:41,760 --> 00:02:43,800
So let's dig into some of these.

57
00:02:43,800 --> 00:02:47,760
The first idea is that three times seven

58
00:02:47,760 --> 00:02:50,440
is actually seven plus seven plus seven.

59
00:02:50,440 --> 00:02:53,400
And so this is to say that the rule of multiplication

60
00:02:53,400 --> 00:02:55,560
is actually defined in terms of addition.

61
00:02:58,120 --> 00:02:59,240
So this is interesting.

62
00:03:01,280 --> 00:03:04,000
If some rules are defined in terms of each other

63
00:03:04,000 --> 00:03:07,040
we can say that the rule is kind of redundant.

64
00:03:07,040 --> 00:03:10,480
So in theory, like we don't really need multiplication

65
00:03:10,480 --> 00:03:12,680
in math because every time we multiply

66
00:03:12,680 --> 00:03:14,520
we can just add instead.

67
00:03:14,520 --> 00:03:16,720
And therefore multiplication hasn't really given us

68
00:03:16,720 --> 00:03:20,080
any more expressive power than addition already provides

69
00:03:20,080 --> 00:03:21,200
for us, right?

70
00:03:21,200 --> 00:03:24,520
So if some rules are redundant

71
00:03:24,520 --> 00:03:26,960
then maybe we can ask the question of like

72
00:03:26,960 --> 00:03:29,360
what rules are non-redundant?

73
00:03:30,480 --> 00:03:32,360
Or really what is the minimum subset of rules

74
00:03:32,360 --> 00:03:34,280
necessary to describe all of math?

75
00:03:35,280 --> 00:03:38,440
And so we can call this minimum subset of rules axioms

76
00:03:38,440 --> 00:03:41,360
and this comes from the word Greek axioma

77
00:03:41,360 --> 00:03:43,200
that which is self-evident.

78
00:03:43,200 --> 00:03:46,800
And then we can call all of the other derived rules theorems

79
00:03:48,280 --> 00:03:51,000
which is like a proposition to be proved.

80
00:03:51,000 --> 00:03:53,480
And so the question is what are the axioms for math?

81
00:03:53,480 --> 00:03:56,080
The minimum non-redundant set of rules

82
00:03:56,080 --> 00:03:57,880
to define all of math.

83
00:03:59,680 --> 00:04:02,920
This is a question that nobody really thought about

84
00:04:04,400 --> 00:04:06,400
or nobody had a really compelling answer to

85
00:04:06,400 --> 00:04:07,560
until this guy came around.

86
00:04:07,560 --> 00:04:09,640
His name is Giuseppe Piano.

87
00:04:09,640 --> 00:04:11,760
He was an Italian mathematician.

88
00:04:11,760 --> 00:04:15,760
And in 1889, so a little over 100 years ago

89
00:04:17,080 --> 00:04:18,320
he put forth these axioms.

90
00:04:18,320 --> 00:04:19,360
There's nine of them.

91
00:04:20,200 --> 00:04:21,880
Only three of them are interesting.

92
00:04:21,880 --> 00:04:23,960
So bear with me for a moment and keep in mind

93
00:04:23,960 --> 00:04:26,480
like we're starting with a blank slate.

94
00:04:26,480 --> 00:04:28,120
So there's no numbers yet

95
00:04:28,120 --> 00:04:30,080
and we have to define what numbers are.

96
00:04:30,080 --> 00:04:35,080
So first we define the first number, which is zero.

97
00:04:35,080 --> 00:04:37,640
And so Piano says zero is a natural number.

98
00:04:39,000 --> 00:04:41,440
The next thing he does is define what equality is

99
00:04:41,440 --> 00:04:42,640
because we don't have that either, right?

100
00:04:42,640 --> 00:04:45,520
So for a thing x, x is equal to x.

101
00:04:45,520 --> 00:04:47,320
This is what equality is.

102
00:04:47,320 --> 00:04:48,800
This one is not very interesting either.

103
00:04:48,800 --> 00:04:51,080
If x equals y, y also equals x.

104
00:04:51,080 --> 00:04:54,080
If x equals y and y equals z, then x equals z.

105
00:04:54,080 --> 00:04:55,520
This is the transit property.

106
00:04:57,440 --> 00:05:00,120
If b is a natural number and a equals b,

107
00:05:00,120 --> 00:05:02,200
then a is also a natural number.

108
00:05:02,200 --> 00:05:04,640
So this is sort of saying we have this collection

109
00:05:04,640 --> 00:05:05,880
of things called natural numbers.

110
00:05:05,880 --> 00:05:08,760
Right now we only have one of them, zero.

111
00:05:08,760 --> 00:05:12,280
And if b is a natural number and a equals b,

112
00:05:12,280 --> 00:05:14,240
then a is also a natural number.

113
00:05:14,240 --> 00:05:16,040
So you have this like glue-like property

114
00:05:16,040 --> 00:05:17,200
of natural numbers.

115
00:05:19,480 --> 00:05:20,960
This is an interesting one.

116
00:05:20,960 --> 00:05:24,240
We define this function s such that s of n

117
00:05:24,240 --> 00:05:25,120
is a natural number.

118
00:05:25,120 --> 00:05:27,240
s is like a successor function.

119
00:05:27,240 --> 00:05:28,840
It's what it literally stands for.

120
00:05:28,840 --> 00:05:32,240
And so now we have a way of going from zero

121
00:05:32,240 --> 00:05:35,520
to producing the successor of zero with this function.

122
00:05:35,520 --> 00:05:38,760
So s of zero is the successor of zero

123
00:05:38,760 --> 00:05:41,120
and s of zero is also a natural number.

124
00:05:41,120 --> 00:05:42,280
Is everyone following?

125
00:05:43,320 --> 00:05:45,360
And I think the best way to go about this

126
00:05:45,360 --> 00:05:46,960
is to just immediately stop me

127
00:05:46,960 --> 00:05:48,080
if you guys have any questions

128
00:05:48,200 --> 00:05:50,640
because this is gonna get more and more complex.

129
00:05:50,640 --> 00:05:52,200
Sounds good?

130
00:05:52,200 --> 00:05:53,040
Great.

131
00:05:54,640 --> 00:05:56,480
m and n are equal to each other

132
00:05:56,480 --> 00:05:59,400
if and only if their successors are equal to each other.

133
00:06:01,240 --> 00:06:05,280
There's no n such that the successor of n equals zero.

134
00:06:05,280 --> 00:06:07,800
So here we're not going into negative numbers.

135
00:06:07,800 --> 00:06:09,800
We're just defining the natural numbers.

136
00:06:10,920 --> 00:06:12,920
So there's no successor for zero.

137
00:06:12,920 --> 00:06:14,960
Or zero is not the successor of anything.

138
00:06:14,960 --> 00:06:16,840
That's what this is saying.

139
00:06:16,840 --> 00:06:18,880
And then finally, the very last one,

140
00:06:18,880 --> 00:06:22,760
if k is a set such that zero is in k

141
00:06:24,120 --> 00:06:28,440
and if n is in k, it means that s and n is in k,

142
00:06:30,160 --> 00:06:32,320
then k contains every natural number.

143
00:06:33,620 --> 00:06:36,840
This is like the base case, zero is in k,

144
00:06:36,840 --> 00:06:38,840
then the inductive case, if n is in k,

145
00:06:38,840 --> 00:06:40,760
it means that s of n is in k

146
00:06:40,760 --> 00:06:43,640
and then therefore k contains all the natural numbers.

147
00:06:43,640 --> 00:06:46,440
So here they're saying there's no like loops.

148
00:06:46,920 --> 00:06:48,720
It's just like this directed graph

149
00:06:48,720 --> 00:06:51,120
that goes all the way out to infinity.

150
00:06:51,120 --> 00:06:51,960
Sound good?

151
00:06:53,080 --> 00:06:53,920
This is it.

152
00:06:55,000 --> 00:06:57,160
This is all you need to define all of math.

153
00:06:58,800 --> 00:07:03,800
So you'll notice we never define numbers besides zero.

154
00:07:03,840 --> 00:07:05,840
We just define the concept of zero, right?

155
00:07:05,840 --> 00:07:08,080
And yet we use these symbols like one and two

156
00:07:08,080 --> 00:07:10,400
and three and four and so on.

157
00:07:10,400 --> 00:07:12,000
And here I'm proposing the concept

158
00:07:12,000 --> 00:07:16,340
that one is actually just syntactic sugar for s of zero.

159
00:07:16,760 --> 00:07:19,560
Which is to say that these two forms are equal to each other

160
00:07:19,560 --> 00:07:20,760
and if we were more precise,

161
00:07:20,760 --> 00:07:23,120
we would actually prefer the form on the right,

162
00:07:23,120 --> 00:07:24,960
but it would be kind of annoying.

163
00:07:24,960 --> 00:07:26,880
And so we have this concept of one

164
00:07:26,880 --> 00:07:30,840
and then two is the successor of one and so on.

165
00:07:31,840 --> 00:07:34,400
Seven is actually s of s of s of zero.

166
00:07:34,400 --> 00:07:36,240
I think you guys get the idea, right?

167
00:07:37,680 --> 00:07:40,000
We haven't added any new information here, right?

168
00:07:40,000 --> 00:07:43,000
And in theory, when we do our math,

169
00:07:44,000 --> 00:07:48,760
we should prefer to reduce, if we were a piano,

170
00:07:48,760 --> 00:07:51,640
we would prefer to reduce the form all the way down

171
00:07:51,640 --> 00:07:53,560
into like this thing over here,

172
00:07:53,560 --> 00:07:54,840
but that's just too confusing.

173
00:07:54,840 --> 00:07:57,280
So we're okay with the syntactic sugar representation

174
00:07:57,280 --> 00:07:58,760
on the left.

175
00:07:58,760 --> 00:07:59,600
Sound good?

176
00:08:01,560 --> 00:08:05,280
Okay, so syntactic sugar is sort of convenience rules

177
00:08:05,280 --> 00:08:08,760
or symbols that we don't need to further reduce down

178
00:08:08,760 --> 00:08:11,080
into the primitive forms.

179
00:08:11,080 --> 00:08:14,480
So let's now define addition.

180
00:08:15,480 --> 00:08:17,160
So addition can be thought of as an operation

181
00:08:17,160 --> 00:08:20,520
that maps two natural numbers to another natural number,

182
00:08:20,520 --> 00:08:21,360
right?

183
00:08:21,360 --> 00:08:23,800
And the syntax is a plus b, so you guys know.

184
00:08:24,760 --> 00:08:27,020
And we just need two rules.

185
00:08:27,020 --> 00:08:28,800
The first is sort of the base case.

186
00:08:28,800 --> 00:08:31,400
a plus zero equals a, sort of obvious.

187
00:08:32,720 --> 00:08:33,880
This one you might have to pause

188
00:08:33,880 --> 00:08:35,680
and think about it a little bit.

189
00:08:35,680 --> 00:08:38,600
a plus the successor of b

190
00:08:38,600 --> 00:08:40,520
is equal to the successor of a plus b.

191
00:08:41,680 --> 00:08:44,880
So what we're doing over here is b

192
00:08:44,880 --> 00:08:47,960
without this little s in the wrapping, right?

193
00:08:47,960 --> 00:08:49,400
We're just kind of taking this s

194
00:08:49,400 --> 00:08:52,480
and wrapping it around the whole thing, right?

195
00:08:52,480 --> 00:08:54,880
And so the term on the right, b,

196
00:08:54,880 --> 00:08:57,900
is actually one less than the term of successor of b.

197
00:08:57,900 --> 00:08:59,840
So we're kind of going down.

198
00:08:59,840 --> 00:09:01,480
This will make sense in just a moment.

199
00:09:01,480 --> 00:09:02,560
I think let's go through an example.

200
00:09:02,560 --> 00:09:05,360
So three plus two, the rules up there are on the right.

201
00:09:06,520 --> 00:09:09,720
The first thing that we do is expand out our syntactic sugar.

202
00:09:09,720 --> 00:09:14,200
So we have s of s of s of zero plus s of s of zero, right?

203
00:09:14,200 --> 00:09:16,320
And now we need to apply one of our rules.

204
00:09:16,320 --> 00:09:18,840
Obviously, we can't apply this rule

205
00:09:18,840 --> 00:09:19,760
because it doesn't match.

206
00:09:19,760 --> 00:09:21,640
So we have to apply this rule, right?

207
00:09:21,640 --> 00:09:25,080
So a is in purple on the left or pink.

208
00:09:25,080 --> 00:09:29,640
And then we have s of b, b is this purple thing over here,

209
00:09:29,640 --> 00:09:32,780
equals s of a plus b, right?

210
00:09:32,780 --> 00:09:34,560
So s of a plus b.

211
00:09:35,500 --> 00:09:37,200
Do you guys see that substitution?

212
00:09:40,080 --> 00:09:42,320
And then we do that again.

213
00:09:42,320 --> 00:09:43,960
And then now we're in a form

214
00:09:43,960 --> 00:09:45,560
where we can apply rule number one,

215
00:09:45,560 --> 00:09:50,060
a plus zero equals just a by itself, right?

216
00:09:51,000 --> 00:09:53,400
And that's five.

217
00:09:53,400 --> 00:09:54,440
And now we can add.

218
00:09:57,040 --> 00:10:00,020
All right, so basically this is compelling

219
00:10:00,020 --> 00:10:03,400
because we didn't have the concept of addition

220
00:10:03,400 --> 00:10:05,480
in terms of the axioms.

221
00:10:05,480 --> 00:10:07,640
And we define the concept of addition

222
00:10:07,640 --> 00:10:10,480
as recursive incrementing, essentially.

223
00:10:10,480 --> 00:10:13,880
And now we have this property of addition,

224
00:10:13,880 --> 00:10:15,960
which we can use to define some other things.

225
00:10:15,960 --> 00:10:18,320
For example, we can define multiplication.

226
00:10:18,320 --> 00:10:20,440
a times zero equals zero,

227
00:10:20,440 --> 00:10:24,460
a times s of b equals a plus a times b.

228
00:10:24,460 --> 00:10:27,720
And it can work out that obviously intuitively

229
00:10:27,720 --> 00:10:29,520
that addition and multiplication

230
00:10:29,520 --> 00:10:32,800
are kinds of intrinsically related to each other.

231
00:10:32,800 --> 00:10:34,560
So we have the piano axioms,

232
00:10:34,560 --> 00:10:35,680
so then we built addition

233
00:10:35,680 --> 00:10:38,600
and then we built multiplication on top, right?

234
00:10:38,600 --> 00:10:41,080
And it's this type of thinking

235
00:10:41,080 --> 00:10:44,400
that I wanna really imprint in your minds.

236
00:10:44,400 --> 00:10:48,080
And here I'm inventing this new concept called axiom towers.

237
00:10:48,080 --> 00:10:50,120
And you can think of axiom towers

238
00:10:50,120 --> 00:10:52,600
as having a foundation, which is the axioms themselves.

239
00:10:52,600 --> 00:10:54,340
So in this case, the piano axioms.

240
00:10:54,340 --> 00:10:56,560
And then on top of that, we built addition.

241
00:10:56,560 --> 00:10:58,840
And then on top of that, we built multiplication.

242
00:10:58,840 --> 00:11:01,920
And then maybe we can build more stuff on top.

243
00:11:01,920 --> 00:11:04,120
And it turns out that the piano axioms

244
00:11:04,120 --> 00:11:07,280
are sufficient to basically describe like most of math.

245
00:11:08,800 --> 00:11:11,480
So from multiplication, you can kind of imagine

246
00:11:11,480 --> 00:11:14,640
that you can build division and from division

247
00:11:14,640 --> 00:11:15,920
or not from division necessarily,

248
00:11:15,920 --> 00:11:19,160
but you can imagine also you can represent the integers

249
00:11:19,160 --> 00:11:22,960
which are negative numbers from just the real numbers.

250
00:11:22,960 --> 00:11:24,160
We won't get into the proofs,

251
00:11:24,160 --> 00:11:26,240
but I'm sure you guys can kind of envision

252
00:11:26,240 --> 00:11:28,200
how this might be the case.

253
00:11:28,200 --> 00:11:30,280
And then once you have negative numbers,

254
00:11:30,280 --> 00:11:32,960
you can imagine defining rational numbers,

255
00:11:32,960 --> 00:11:36,920
which are just kind of, in the context of division,

256
00:11:36,920 --> 00:11:39,880
a rational number is just a numerator and a denominator.

257
00:11:41,760 --> 00:11:43,040
And then from rational numbers,

258
00:11:43,040 --> 00:11:44,920
you can maybe get to exponentials,

259
00:11:44,920 --> 00:11:48,520
which is just sort of repeated multiplication.

260
00:11:48,520 --> 00:11:49,680
And then from exponentials,

261
00:11:49,680 --> 00:11:51,440
you can get to irrational numbers,

262
00:11:51,440 --> 00:11:55,440
like the exponent of a fraction gets you irrational numbers.

263
00:11:55,440 --> 00:11:58,880
And then maybe you can build imaginary numbers

264
00:11:58,880 --> 00:12:00,160
and so on and so forth.

265
00:12:01,160 --> 00:12:03,680
And all of it is kind of stacked on top

266
00:12:03,680 --> 00:12:06,240
of just these core axioms at the very bottom.

267
00:12:07,360 --> 00:12:08,200
Sound good?

268
00:12:09,520 --> 00:12:10,360
Cool.

269
00:12:11,720 --> 00:12:13,720
This is gonna get interesting, I promise.

270
00:12:13,720 --> 00:12:15,360
All right, so the first idea is

271
00:12:15,360 --> 00:12:17,520
that the axioms are not divine, right?

272
00:12:17,520 --> 00:12:18,720
There's nothing special about them.

273
00:12:18,720 --> 00:12:21,960
In fact, when Piano first wrote his papers,

274
00:12:21,960 --> 00:12:25,000
he started off with one as like the root.

275
00:12:25,000 --> 00:12:26,360
He didn't start off with zero,

276
00:12:26,360 --> 00:12:28,400
but then mathematicians later said like,

277
00:12:28,440 --> 00:12:30,920
no, no, let's start with zero, it's better.

278
00:12:30,920 --> 00:12:32,640
So you can imagine starting off with one and say,

279
00:12:32,640 --> 00:12:36,000
you can imagine using like a predecessor function

280
00:12:36,000 --> 00:12:37,840
instead of like a successor function.

281
00:12:39,720 --> 00:12:42,280
But here I'm making a claim that some axiom towers

282
00:12:42,280 --> 00:12:44,680
are better than other axiom towers.

283
00:12:44,680 --> 00:12:46,720
Let's say more useful than other axiom towers.

284
00:12:46,720 --> 00:12:50,160
Like for example, Roman numerals are just horribly inconvenient

285
00:12:50,160 --> 00:12:53,680
at doing anything useful, like multiplication.

286
00:12:53,680 --> 00:12:56,760
And yet everything that you can do in regular numbers,

287
00:12:56,760 --> 00:12:58,800
you can also do in terms of Roman numerals.

288
00:12:58,800 --> 00:13:00,640
And so Roman numerals aren't like,

289
00:13:00,640 --> 00:13:02,040
they're just a different set of axioms

290
00:13:02,040 --> 00:13:04,320
that are somehow slightly less useful.

291
00:13:06,800 --> 00:13:10,220
All right, axiom towers don't have to correspond to reality.

292
00:13:11,480 --> 00:13:14,960
So Euclid was a Greek philosopher

293
00:13:14,960 --> 00:13:17,920
and he's sort of like the father of geometry.

294
00:13:17,920 --> 00:13:22,480
And way before Piano, he put forth the axioms for geometry

295
00:13:22,480 --> 00:13:26,580
and we call his flavor of geometry Euclidean geometry.

296
00:13:26,580 --> 00:13:29,900
And one of the axioms that he kind of put forth

297
00:13:29,900 --> 00:13:32,460
was that if you have two parallel lines,

298
00:13:32,460 --> 00:13:34,900
let's say like this Y right here,

299
00:13:34,900 --> 00:13:38,660
as well as like the Y axis, these are parallel to each other.

300
00:13:38,660 --> 00:13:40,220
So if two lines are parallel,

301
00:13:40,220 --> 00:13:42,220
then they stay parallel forever.

302
00:13:42,220 --> 00:13:43,620
They never intersect.

303
00:13:43,620 --> 00:13:45,100
That was one of his axioms.

304
00:13:46,140 --> 00:13:48,660
But it turns out that you can have these things

305
00:13:48,660 --> 00:13:50,660
called non-Euclidean geometries,

306
00:13:50,660 --> 00:13:53,060
which essentially forego that axiom.

307
00:13:53,060 --> 00:13:55,020
And the example is sort of like a globe

308
00:13:55,020 --> 00:13:59,860
where you have these vertical longitude lines or meridians.

309
00:13:59,860 --> 00:14:02,380
And the meridians are all parallel to each other.

310
00:14:03,540 --> 00:14:07,020
But as you see at the poles, they all kind of intersect.

311
00:14:07,020 --> 00:14:11,420
So a non-Euclidean geometry is one that foregoes

312
00:14:11,420 --> 00:14:14,260
this notion of like parallel lines don't intersect.

313
00:14:14,260 --> 00:14:15,620
And it turns out that there's all sorts

314
00:14:15,620 --> 00:14:18,460
of really interesting non-Euclidean spaces

315
00:14:18,460 --> 00:14:21,700
that you can imagine that don't at all correspond to reality.

316
00:14:21,700 --> 00:14:26,060
And so there's this whole sets of branches of mathematics

317
00:14:26,060 --> 00:14:29,540
that kind of conceptualize all sorts of different axioms

318
00:14:29,540 --> 00:14:31,420
that are unique and interesting

319
00:14:31,420 --> 00:14:34,260
and form this sort of logically coherent axiom tower

320
00:14:34,260 --> 00:14:36,060
on the basis of those axioms.

321
00:14:36,060 --> 00:14:38,980
And in many ways, those towers don't correspond

322
00:14:38,980 --> 00:14:40,420
at all to reality.

323
00:14:40,420 --> 00:14:42,860
And it's just sort of mathematicians having fun.

324
00:14:44,060 --> 00:14:45,820
Interesting idea.

325
00:14:45,820 --> 00:14:48,020
Okay, symbols.

326
00:14:48,020 --> 00:14:50,220
So we talked a bunch about symbols.

327
00:14:50,220 --> 00:14:52,260
It might be interesting to think of the symbols

328
00:14:52,260 --> 00:14:54,980
as sort of separate from the rules.

329
00:14:54,980 --> 00:14:58,820
But it turns out that if you really examine the situation,

330
00:14:58,820 --> 00:15:02,180
the symbols don't really make sense without the rules.

331
00:15:02,180 --> 00:15:05,780
And the rules can't really be expressed without symbols.

332
00:15:05,780 --> 00:15:07,380
And so symbols here are making the claim

333
00:15:07,380 --> 00:15:10,100
that they're kind of intrinsically related to each other,

334
00:15:10,100 --> 00:15:11,780
really two sides of the same coin.

335
00:15:11,780 --> 00:15:15,820
So this symbol, if you've done any sort of computing,

336
00:15:15,820 --> 00:15:20,620
0x20 is the hexadecimal number 32, right?

337
00:15:22,820 --> 00:15:24,300
But it's also like, sorry,

338
00:15:24,300 --> 00:15:29,300
it's also the ASCII symbol for space, the space character.

339
00:15:29,460 --> 00:15:31,780
So whether you're interpreting the symbol

340
00:15:31,780 --> 00:15:33,700
in the context of hexadecimal math

341
00:15:33,700 --> 00:15:37,740
or this axiom tower of ASCII or Unicode,

342
00:15:37,740 --> 00:15:40,980
like the symbol has meaning only in the context

343
00:15:40,980 --> 00:15:43,260
of a particular like frame of reference,

344
00:15:43,260 --> 00:15:44,740
which is the axiom tower

345
00:15:44,740 --> 00:15:46,740
that you're interpreting the symbol in.

346
00:15:46,740 --> 00:15:47,700
And they're one and the same.

347
00:15:47,700 --> 00:15:50,780
You can't separate out these ideas.

348
00:15:50,780 --> 00:15:52,780
Another interesting example is DNA.

349
00:15:52,780 --> 00:15:55,260
So there's this like funny concept

350
00:15:55,260 --> 00:15:57,980
that DNA consists of these base pairs

351
00:15:57,980 --> 00:16:00,020
and that all of the human genome

352
00:16:00,020 --> 00:16:03,220
is sort of some ridiculously small amount of data.

353
00:16:03,220 --> 00:16:05,980
And it's just like claim that,

354
00:16:05,980 --> 00:16:09,060
therefore like life is not really that complex

355
00:16:09,060 --> 00:16:11,820
because there's really not much information in DNA.

356
00:16:11,820 --> 00:16:13,860
But if you really examine this question,

357
00:16:13,860 --> 00:16:17,660
DNA by itself is completely meaningless and useless

358
00:16:17,660 --> 00:16:20,260
without the corresponding like cellular machinery

359
00:16:20,260 --> 00:16:22,220
that's able to actually unpack it and read it

360
00:16:22,220 --> 00:16:24,560
and build actual life from it.

361
00:16:24,560 --> 00:16:27,260
So DNA and the thing that reads the DNA,

362
00:16:27,260 --> 00:16:30,180
they're intrinsically linked to each other.

363
00:16:30,180 --> 00:16:32,700
The symbols and the rules are one and the same.

364
00:16:36,220 --> 00:16:37,860
Here's an interesting philosophical claim.

365
00:16:37,860 --> 00:16:41,580
I think that math is actually discovered and not invented.

366
00:16:41,580 --> 00:16:43,060
And the analogy that I have

367
00:16:43,060 --> 00:16:46,220
is sort of a visualization of this axiom tower

368
00:16:46,220 --> 00:16:49,820
and the top levels of this axiom tower are kind of obscured.

369
00:16:49,820 --> 00:16:52,340
It's not exactly clear what they should be.

370
00:16:53,300 --> 00:16:54,860
And what you're doing as a mathematician

371
00:16:54,860 --> 00:16:57,460
is kind of like discovering consequences

372
00:16:57,460 --> 00:16:59,660
of having initial axioms.

373
00:17:01,660 --> 00:17:02,500
Sound good?

374
00:17:02,500 --> 00:17:03,340
Questions?

375
00:17:06,620 --> 00:17:07,980
All right.

376
00:17:07,980 --> 00:17:09,740
So recap, axioms are self-evident.

377
00:17:09,740 --> 00:17:11,540
They're taken as given.

378
00:17:12,540 --> 00:17:15,180
Theorems are derived from redundant rules.

379
00:17:15,180 --> 00:17:16,940
Axioms and theorems stack up together

380
00:17:16,940 --> 00:17:19,660
to build these things called axiom towers.

381
00:17:19,660 --> 00:17:23,060
And some symbols are actually just syntactic sugar.

382
00:17:23,060 --> 00:17:26,620
Symbols and rules are intrinsically related.

383
00:17:26,620 --> 00:17:29,200
And math is a discovery of the consequences

384
00:17:29,200 --> 00:17:30,700
of foundational axioms.

385
00:17:32,620 --> 00:17:34,020
And the axioms are arbitrary,

386
00:17:34,020 --> 00:17:36,620
but some axiom towers are more useful than others.

387
00:17:37,740 --> 00:17:39,380
All right.

388
00:17:39,380 --> 00:17:40,220
You guys are comfortable.

389
00:17:40,220 --> 00:17:42,100
We're gonna get to the exciting part.

390
00:17:43,260 --> 00:17:44,100
Computation.

391
00:17:47,300 --> 00:17:49,540
This is a graph of certain things

392
00:17:49,540 --> 00:17:51,060
that we kind of take for granted today,

393
00:17:51,060 --> 00:17:54,420
like running water and electric power over time.

394
00:17:54,420 --> 00:17:58,020
And here I wanna point out that in the 1930s,

395
00:17:59,540 --> 00:18:02,500
more people had electric power than running water.

396
00:18:02,500 --> 00:18:06,300
And that number was around 65, 70%.

397
00:18:06,300 --> 00:18:09,140
So you can imagine being in the 1930s, right?

398
00:18:11,020 --> 00:18:15,340
And at this point, algorithms had already existed, right?

399
00:18:15,340 --> 00:18:17,780
So way back in 2000 BC,

400
00:18:17,780 --> 00:18:20,420
Egyptians figured out how to multiply two numbers together.

401
00:18:20,420 --> 00:18:22,900
Babylonians figured out how to factorize things

402
00:18:22,900 --> 00:18:24,700
and find square roots.

403
00:18:24,700 --> 00:18:26,580
Euclid's algorithm, which is really cool,

404
00:18:26,580 --> 00:18:28,700
the same Euclid as geometry.

405
00:18:28,700 --> 00:18:31,920
He figured out how to get the greatest common factor

406
00:18:31,920 --> 00:18:33,500
between two numbers.

407
00:18:33,500 --> 00:18:35,820
And this algorithm is actually really beautiful

408
00:18:35,820 --> 00:18:36,740
if you've never seen it.

409
00:18:36,740 --> 00:18:39,500
It's called, I've actually never pronounced it,

410
00:18:39,500 --> 00:18:43,180
but I've read it, it's sieve or aerotostinese.

411
00:18:43,180 --> 00:18:46,280
It's a way to generate prime numbers.

412
00:18:47,760 --> 00:18:51,180
And Al-Quarizmi figured out how to solve linear equations

413
00:18:51,180 --> 00:18:52,360
and quadratic equations.

414
00:18:52,360 --> 00:18:53,860
And it turns out that the word algorithm

415
00:18:53,860 --> 00:18:55,340
actually comes from his name.

416
00:18:56,900 --> 00:18:59,700
So we have like hundreds or thousands of years

417
00:18:59,700 --> 00:19:02,980
of understanding of these things called algorithms,

418
00:19:02,980 --> 00:19:05,660
which really were kind of informal at the time.

419
00:19:05,660 --> 00:19:08,420
And you can kind of consider them as like sequences

420
00:19:08,460 --> 00:19:11,980
of instructions to follow to do something, right?

421
00:19:11,980 --> 00:19:15,580
But we didn't have like a precise axiomatic definition

422
00:19:15,580 --> 00:19:18,820
of computing in the way that Piano defined

423
00:19:18,820 --> 00:19:22,180
the axiomatic definition of mass, right?

424
00:19:22,180 --> 00:19:23,340
In the 30s.

425
00:19:23,340 --> 00:19:28,340
And so these guys pretty much at exactly the same time

426
00:19:30,760 --> 00:19:33,220
did that independently.

427
00:19:34,520 --> 00:19:37,740
Alan Turing created these things called Turing Machines.

428
00:19:38,420 --> 00:19:40,460
Alonzo Church created these things,

429
00:19:40,460 --> 00:19:42,260
this thing called Lambda Calculus.

430
00:19:43,220 --> 00:19:45,020
And Kurt Godel created these things

431
00:19:45,020 --> 00:19:47,460
called general recursive functions.

432
00:19:47,460 --> 00:19:49,020
So we're gonna ignore the last one

433
00:19:49,020 --> 00:19:51,180
and actually drill into these two,

434
00:19:51,180 --> 00:19:53,620
Turing Machines and Lambda Calculus.

435
00:19:53,620 --> 00:19:56,100
And the really, really cool thing is that

436
00:19:56,100 --> 00:20:00,740
these axiomatic systems are both reasonable

437
00:20:00,740 --> 00:20:02,620
and good definitions for computing,

438
00:20:02,620 --> 00:20:05,100
but they look very, very different from each other.

439
00:20:05,100 --> 00:20:07,540
So we're gonna talk about what they are.

440
00:20:08,420 --> 00:20:09,620
So Turing Machines.

441
00:20:11,180 --> 00:20:12,900
You can envision a Turing machine.

442
00:20:12,900 --> 00:20:15,180
So Alan Turing was thinking about,

443
00:20:15,180 --> 00:20:18,340
like you can kind of empathize with what he was doing.

444
00:20:18,340 --> 00:20:21,460
He was looking at all these algorithms that we have

445
00:20:21,460 --> 00:20:25,180
and he was trying to reduce like all of the algorithms down

446
00:20:25,180 --> 00:20:29,180
into their most principle like reduced forms, right?

447
00:20:29,180 --> 00:20:32,340
And then essentially use that as the base of an axiom tower

448
00:20:32,340 --> 00:20:35,180
and build higher level constructs on top of that, right?

449
00:20:35,180 --> 00:20:36,340
This was his goal.

450
00:20:36,380 --> 00:20:39,860
And so he envisioned this concept called a Turing machine.

451
00:20:39,860 --> 00:20:43,020
And a Turing machine starts off with this thing,

452
00:20:43,020 --> 00:20:45,380
which is like an infinitely long tape.

453
00:20:46,820 --> 00:20:48,660
And the tape is actually broken up

454
00:20:48,660 --> 00:20:50,580
into these things called cells.

455
00:20:50,580 --> 00:20:53,660
And in the cells, you can actually,

456
00:20:54,620 --> 00:20:57,180
like each cell can either be marked or unmarked.

457
00:20:57,180 --> 00:20:58,820
So here we have empty cells

458
00:20:58,820 --> 00:21:01,300
and the X's correspond to marked cells, right?

459
00:21:02,140 --> 00:21:03,140
And this is infinitely long.

460
00:21:03,140 --> 00:21:04,820
It goes on in both directions.

461
00:21:04,820 --> 00:21:07,540
And you have this thing called the head

462
00:21:07,540 --> 00:21:10,760
and the head can do some stuff.

463
00:21:10,760 --> 00:21:12,100
You can move it to the right.

464
00:21:12,100 --> 00:21:15,060
In every case, it's always pointing to a particular cell.

465
00:21:15,060 --> 00:21:16,500
You can move it to the left.

466
00:21:18,020 --> 00:21:21,620
You can mark the box that the head is pointing at.

467
00:21:21,620 --> 00:21:23,500
You can unmark the box.

468
00:21:23,500 --> 00:21:26,300
And if the box is marked, you go to end.

469
00:21:26,300 --> 00:21:28,180
We'll talk about go to end in just a moment.

470
00:21:28,180 --> 00:21:30,780
And if the box is unmarked, also go to end.

471
00:21:30,780 --> 00:21:32,740
These are all different instructions

472
00:21:32,740 --> 00:21:35,540
that you can provide to this like turning machine.

473
00:21:36,980 --> 00:21:39,340
And the execution of the turning machine,

474
00:21:39,340 --> 00:21:43,580
essentially, you start off with a blank tape

475
00:21:43,580 --> 00:21:45,140
and a list of instructions

476
00:21:45,140 --> 00:21:46,980
that you want this turning machine to execute.

477
00:21:46,980 --> 00:21:48,500
And the list of instructions are ordered

478
00:21:48,500 --> 00:21:49,780
from zero through N.

479
00:21:50,800 --> 00:21:53,940
And you execute the first instruction.

480
00:21:53,940 --> 00:21:55,220
And if it's an ordinary instruction,

481
00:21:55,220 --> 00:21:57,540
you execute the next instruction.

482
00:21:57,540 --> 00:22:00,180
And if it's one of these like jump instructions

483
00:22:00,180 --> 00:22:03,260
at the bottom, then if it tells you to jump,

484
00:22:03,260 --> 00:22:04,820
you go to the Nth instruction.

485
00:22:05,940 --> 00:22:06,780
Sound good?

486
00:22:08,460 --> 00:22:12,500
And basically Alan Turing showed that this model

487
00:22:12,500 --> 00:22:14,660
is sufficient for all of computation.

488
00:22:15,660 --> 00:22:17,940
Anything that can be computed

489
00:22:17,940 --> 00:22:20,300
can be computed with just these primitives.

490
00:22:22,100 --> 00:22:23,100
That's all it takes.

491
00:22:25,500 --> 00:22:28,940
Okay, so there is an actual virtual implementation

492
00:22:28,940 --> 00:22:31,500
of a Turing machine called brain flap.

493
00:22:31,500 --> 00:22:32,940
It's a technical term.

494
00:22:32,940 --> 00:22:36,220
And basically there's a few instructions.

495
00:22:36,220 --> 00:22:38,860
And it essentially you can imagine it

496
00:22:38,860 --> 00:22:40,980
as like a virtual Turing machine.

497
00:22:40,980 --> 00:22:43,060
And it has these instructions.

498
00:22:43,060 --> 00:22:44,540
You can move the head to the right.

499
00:22:44,540 --> 00:22:46,340
You can move the head to the left.

500
00:22:46,340 --> 00:22:48,220
This is slightly different than a Turing machine

501
00:22:48,220 --> 00:22:52,180
because the cells don't contain just like binary values

502
00:22:52,180 --> 00:22:53,500
of marked and unmarked.

503
00:22:53,500 --> 00:22:55,020
Instead, they contain numbers.

504
00:22:55,020 --> 00:22:57,100
And you can increment numbers and decrement numbers.

505
00:22:57,100 --> 00:22:58,700
And just integers, right?

506
00:22:59,740 --> 00:23:04,740
And then these characters, so the open bracket,

507
00:23:04,740 --> 00:23:07,020
like if the value at the head is zero,

508
00:23:07,020 --> 00:23:10,940
jump forward to the matching like closed bracket.

509
00:23:10,940 --> 00:23:13,420
And then the closed bracket is if the value at the head

510
00:23:13,420 --> 00:23:17,380
is non-zero, jump back to the matching open bracket.

511
00:23:17,380 --> 00:23:22,380
So here we've kind of defined our jumping behavior.

512
00:23:23,060 --> 00:23:26,500
And then this language also provides like functionality

513
00:23:26,500 --> 00:23:28,300
for input and output, which is something

514
00:23:28,300 --> 00:23:31,060
that Turing didn't necessarily require.

515
00:23:31,060 --> 00:23:33,620
But this makes the language a little bit more useful

516
00:23:33,620 --> 00:23:37,140
because you can have it do stuff like print out output.

517
00:23:38,980 --> 00:23:41,140
And every other character is ignored.

518
00:23:41,140 --> 00:23:43,900
So anything that's not this magenta color

519
00:23:43,900 --> 00:23:46,340
is basically ignored in this language.

520
00:23:46,340 --> 00:23:51,340
So this is the implementation of adding two numbers together.

521
00:23:52,340 --> 00:23:57,340
And if you squint, you can kind of see the recursive definition

522
00:23:57,820 --> 00:24:01,140
that Piano kind of described earlier, right?

523
00:24:01,140 --> 00:24:04,820
We'll actually go to a much clearer example.

524
00:24:04,820 --> 00:24:07,580
So in the beginning, you can imagine the head

525
00:24:07,580 --> 00:24:10,740
is pointing at cell C0 and we increment it twice.

526
00:24:10,740 --> 00:24:12,980
So now C0 has a value two.

527
00:24:12,980 --> 00:24:15,020
And then you move to the right to cell C1

528
00:24:15,020 --> 00:24:16,540
and you increment it five times.

529
00:24:16,540 --> 00:24:18,980
So C1 has a value five, right?

530
00:24:19,660 --> 00:24:23,340
And then you start your loop.

531
00:24:23,340 --> 00:24:25,940
The first thing that you do is you go back to C0

532
00:24:25,940 --> 00:24:27,980
and you add one to it.

533
00:24:27,980 --> 00:24:30,100
And then you go right to C1

534
00:24:30,100 --> 00:24:33,500
and then you subtract one from it and you keep looping.

535
00:24:33,500 --> 00:24:35,940
And your loop will basically end.

536
00:24:37,540 --> 00:24:38,900
I can't think properly right now,

537
00:24:38,900 --> 00:24:43,300
but once C1 essentially reaches zero,

538
00:24:43,300 --> 00:24:45,540
then the loop will end and your program will terminate.

539
00:24:45,540 --> 00:24:47,820
And now you have this ability to add two numbers,

540
00:24:47,820 --> 00:24:49,620
C0 and C1, right?

541
00:24:53,460 --> 00:24:56,460
This is an algorithm for computing

542
00:24:56,460 --> 00:24:59,740
the Mandelbrot fractal set.

543
00:24:59,740 --> 00:25:01,580
If you guys haven't heard of this,

544
00:25:01,580 --> 00:25:06,580
it's just a really cool like fractal,

545
00:25:06,780 --> 00:25:07,700
I won't get into fractals,

546
00:25:07,700 --> 00:25:10,980
but basically this is a program, it prints out this, right?

547
00:25:11,940 --> 00:25:13,860
So just using our turning machine,

548
00:25:13,860 --> 00:25:17,420
we were able to now output like this fractal.

549
00:25:23,060 --> 00:25:23,900
Cool.

550
00:25:23,900 --> 00:25:26,060
So basically turning created an axiom tower for computing

551
00:25:26,060 --> 00:25:28,540
and an algorithm is computable

552
00:25:28,540 --> 00:25:31,260
if and only if it can be encoded as a turning machine.

553
00:25:32,260 --> 00:25:34,140
And Turing showed this before the existence

554
00:25:34,140 --> 00:25:35,700
of electrical computers.

555
00:25:35,700 --> 00:25:38,300
And he also showed this when he was 24 years old.

556
00:25:40,980 --> 00:25:42,620
If you guys have heard of the Turing Award,

557
00:25:42,620 --> 00:25:47,340
it's basically like the Nobel Prize for computer science

558
00:25:47,340 --> 00:25:49,020
and it's named after Alan Turing.

559
00:25:50,180 --> 00:25:54,260
So some observations, you need an infinite tape

560
00:25:54,260 --> 00:25:55,820
and you need a program,

561
00:25:55,820 --> 00:25:58,100
like which is a sequence of instructions to follow

562
00:25:59,140 --> 00:26:01,940
and you're constantly modifying the tape.

563
00:26:01,940 --> 00:26:03,460
So you can think of the tape

564
00:26:03,460 --> 00:26:05,780
as sort of like the state of your program

565
00:26:05,780 --> 00:26:08,020
and every instruction that you execute

566
00:26:08,020 --> 00:26:11,260
that modifies the tape is in theory

567
00:26:11,260 --> 00:26:15,860
kind of modifying the way that the program

568
00:26:15,860 --> 00:26:17,860
kind of unfolds itself, right?

569
00:26:18,860 --> 00:26:21,380
And the behavior of the program

570
00:26:21,380 --> 00:26:23,260
is changed with every single tape modification.

571
00:26:23,260 --> 00:26:25,060
And so therefore reasoning about the behavior

572
00:26:25,060 --> 00:26:27,820
of the program requires understanding the state of the tape

573
00:26:27,820 --> 00:26:30,060
at every moment of modification.

574
00:26:30,060 --> 00:26:32,740
And so you can imagine sort of debugging

575
00:26:32,740 --> 00:26:35,580
or turning machine as perhaps similar

576
00:26:35,580 --> 00:26:38,060
to debugging like an application

577
00:26:38,060 --> 00:26:40,980
where you kind of think about how the application's

578
00:26:40,980 --> 00:26:42,700
memory state changed over time

579
00:26:42,700 --> 00:26:47,580
and all of a sudden your ideal understanding

580
00:26:47,580 --> 00:26:49,540
of how it's supposed to change like differs

581
00:26:49,540 --> 00:26:51,940
from the way it actually changed and there's your bug.

582
00:26:54,460 --> 00:26:56,340
From here, Turing defined this concept

583
00:26:56,340 --> 00:26:57,540
called Turing completeness

584
00:26:57,540 --> 00:27:01,580
because you said that you can have other forms of computing.

585
00:27:01,580 --> 00:27:05,980
For example, you can imagine like different instruction sets

586
00:27:05,980 --> 00:27:07,940
for this Turing machine, right?

587
00:27:08,940 --> 00:27:12,660
And he basically said that an axiom tower

588
00:27:12,660 --> 00:27:14,860
that's sort of different than a Turing machine

589
00:27:14,860 --> 00:27:17,660
is called Turing complete if and only if

590
00:27:17,660 --> 00:27:21,060
it can be used to emulate a Turing machine.

591
00:27:21,060 --> 00:27:23,500
And if it can emulate a Turing machine,

592
00:27:23,500 --> 00:27:25,940
then it can compute anything that's computable.

593
00:27:26,940 --> 00:27:27,860
That sounds good.

594
00:27:27,860 --> 00:27:30,460
This concept of Turing completeness has now popped up.

595
00:27:32,060 --> 00:27:33,940
So it turns out that there's some interesting things

596
00:27:33,940 --> 00:27:35,060
that are Turing complete.

597
00:27:36,060 --> 00:27:39,580
If you guys have heard of Conway's Game of Life,

598
00:27:39,580 --> 00:27:44,580
it's this basically life simulator, emulator, I guess.

599
00:27:45,700 --> 00:27:46,820
And it's very simple.

600
00:27:46,820 --> 00:27:48,740
You have this grid of squares

601
00:27:48,740 --> 00:27:53,740
and each square corresponds to a living thing

602
00:27:53,980 --> 00:27:55,860
and it's either alive or dead.

603
00:27:55,860 --> 00:27:57,900
And at every step in time,

604
00:27:57,900 --> 00:28:02,340
there's some certain rules for allowing

605
00:28:02,340 --> 00:28:06,460
like whether in the next time step,

606
00:28:06,460 --> 00:28:08,180
the cell is alive or dead.

607
00:28:08,180 --> 00:28:10,580
And so it essentially, oops,

608
00:28:12,900 --> 00:28:15,380
let's see if we can get this to play.

609
00:28:15,380 --> 00:28:16,300
I won't get into the rules

610
00:28:16,300 --> 00:28:18,540
because they're not really relevant,

611
00:28:18,540 --> 00:28:21,740
but every kind of step in this animation

612
00:28:21,740 --> 00:28:23,780
is like the universe kind of unfolding

613
00:28:23,780 --> 00:28:26,060
according to the rules of Conway's Game of Life.

614
00:28:26,060 --> 00:28:28,540
And it turns out that the basic rules

615
00:28:28,540 --> 00:28:31,900
are sufficient to represent a Turing machine.

616
00:28:31,900 --> 00:28:34,140
And so Conway's Game of Life is Turing complete.

617
00:28:34,140 --> 00:28:37,140
And so any algorithm that's computable

618
00:28:37,140 --> 00:28:39,300
can be represented in Conway's Game of Life.

619
00:28:42,140 --> 00:28:44,620
Magic the Gathering is also Turing complete.

620
00:28:44,620 --> 00:28:46,780
So some researchers got together

621
00:28:46,780 --> 00:28:51,660
and they looked at some specific cards

622
00:28:51,660 --> 00:28:53,740
that allow you to place these like counters

623
00:28:53,740 --> 00:28:55,500
and they use the counters as a way

624
00:28:55,500 --> 00:28:58,940
to represent an actual Turing tape.

625
00:28:58,940 --> 00:29:02,700
And so just following the rules of Magic the Gathering,

626
00:29:02,700 --> 00:29:04,180
they're sufficiently complex enough

627
00:29:04,180 --> 00:29:07,340
that you can compute all of the prime numbers in the game.

628
00:29:10,100 --> 00:29:12,140
Microsoft PowerPoint is Turing complete.

629
00:29:13,180 --> 00:29:15,260
Obviously it has like macros and stuff,

630
00:29:15,260 --> 00:29:19,000
but here using only auto shape, hyperlink and transition.

631
00:29:19,000 --> 00:29:20,820
And this paper is hilarious.

632
00:29:20,820 --> 00:29:22,300
Given PowerPoint's versatility

633
00:29:22,300 --> 00:29:24,340
and cross-platform compatibility,

634
00:29:24,340 --> 00:29:26,540
some have asked whether any other applications

635
00:29:26,540 --> 00:29:27,980
are necessary at all,

636
00:29:27,980 --> 00:29:29,980
or if all computational tasks

637
00:29:29,980 --> 00:29:32,220
can be accomplished through PowerPoint.

638
00:29:32,220 --> 00:29:35,020
This research aims to definitively answer these questions

639
00:29:35,020 --> 00:29:36,860
in the affirmative through the creation

640
00:29:36,860 --> 00:29:38,300
of a PowerPoint Turing machine.

641
00:29:41,420 --> 00:29:43,940
Okay, we've talked about Turing machines.

642
00:29:43,940 --> 00:29:45,820
Now let's talk about Lambda calculus.

643
00:29:45,820 --> 00:29:48,020
So to me, when I first learned about Turing machines,

644
00:29:48,020 --> 00:29:51,100
I thought it was really kind of unintuitive

645
00:29:51,100 --> 00:29:53,860
that such a simple thing can be used

646
00:29:53,860 --> 00:29:55,660
to represent so much complexity.

647
00:29:55,660 --> 00:29:57,060
But then after really thinking about it,

648
00:29:57,060 --> 00:30:00,260
I realized that wait, the piano axioms are also very simple

649
00:30:00,260 --> 00:30:01,860
and we can get all of math from it.

650
00:30:01,860 --> 00:30:03,740
So it must follow that you can have

651
00:30:03,740 --> 00:30:06,100
simple computing axioms and that's the case.

652
00:30:06,100 --> 00:30:09,540
And I think for computer scientists and software engineers,

653
00:30:09,540 --> 00:30:12,020
this is sort of what we're in the business of doing.

654
00:30:12,020 --> 00:30:15,380
Like we take like simple building blocks

655
00:30:15,380 --> 00:30:17,980
and we compose them together to build complexity.

656
00:30:17,980 --> 00:30:19,700
And we have ways of reasoning about

657
00:30:19,700 --> 00:30:22,940
how these things combine together to build complexity.

658
00:30:22,940 --> 00:30:26,340
And we, it's sort of our job to make sure

659
00:30:26,340 --> 00:30:29,060
that the complexity that we build

660
00:30:29,060 --> 00:30:32,140
is actually founded and not buggy, let's say.

661
00:30:33,460 --> 00:30:36,660
So it turns out that there's another flavor

662
00:30:36,660 --> 00:30:38,280
or another axiom tower for computing

663
00:30:38,280 --> 00:30:39,860
that was invented basically

664
00:30:39,860 --> 00:30:42,940
or discovered exactly around the same time.

665
00:30:42,940 --> 00:30:46,300
And it was discovered by Alonzo Church

666
00:30:46,300 --> 00:30:49,780
and it's a thing called Lambda calculus.

667
00:30:49,780 --> 00:30:54,660
And the way, basically in Alonzo Church's original paper,

668
00:30:54,660 --> 00:30:59,540
he has a particular syntax for how he denotes Lambda calculus.

669
00:30:59,540 --> 00:31:02,980
And JavaScript also has its own syntax

670
00:31:02,980 --> 00:31:04,760
for declaring anonymous functions.

671
00:31:04,760 --> 00:31:06,900
And because most of us are more familiar with JavaScript,

672
00:31:06,900 --> 00:31:09,380
I'm gonna write both Alonzo Church's notation

673
00:31:09,380 --> 00:31:11,020
as well as the JavaScript notation

674
00:31:11,020 --> 00:31:12,680
to represent the same ideas.

675
00:31:12,680 --> 00:31:16,180
So the first idea that he introduced was,

676
00:31:16,180 --> 00:31:17,760
you can have variables.

677
00:31:17,760 --> 00:31:19,460
So here X is a variable.

678
00:31:19,460 --> 00:31:21,100
It's like a placeholder for a value.

679
00:31:22,100 --> 00:31:26,220
Second idea is you can have functions.

680
00:31:26,220 --> 00:31:29,100
And a function, this is on the left,

681
00:31:29,100 --> 00:31:32,180
Alonzo Church's definition or notation.

682
00:31:32,180 --> 00:31:34,940
And on the right, you have the ES6 equivalent syntax.

683
00:31:34,940 --> 00:31:37,740
This is just a function that takes in one parameter Y

684
00:31:37,740 --> 00:31:40,700
and has somebody M and M itself,

685
00:31:40,700 --> 00:31:42,540
itself another Lambda expression.

686
00:31:43,460 --> 00:31:45,100
So you have function definition.

687
00:31:46,060 --> 00:31:48,540
And then finally you have function application.

688
00:31:48,540 --> 00:31:50,140
So F of M, right?

689
00:31:50,140 --> 00:31:52,380
So calling function F with a particular M.

690
00:31:52,380 --> 00:31:57,380
So if in this case we call Y with some value,

691
00:31:58,220 --> 00:32:00,460
like everything inside the body of M

692
00:32:00,460 --> 00:32:03,460
gets replaced with whatever value we call it.

693
00:32:03,460 --> 00:32:07,060
You guys should be really familiar with this concept.

694
00:32:07,060 --> 00:32:10,780
And it turns out that this is all you need.

695
00:32:10,780 --> 00:32:13,460
And with just these three concepts,

696
00:32:13,460 --> 00:32:15,980
you can get something that's turned complete.

697
00:32:16,980 --> 00:32:20,140
And so this is really, really unintuitive.

698
00:32:20,140 --> 00:32:23,500
For me, it was way more unintuitive than the turning machine

699
00:32:23,500 --> 00:32:25,120
which felt like this mechanical thing.

700
00:32:25,120 --> 00:32:27,420
And therefore because you can operate it mechanically,

701
00:32:27,420 --> 00:32:29,180
perhaps it can do some computation.

702
00:32:29,180 --> 00:32:32,740
Here there's no notion of mechanics.

703
00:32:32,740 --> 00:32:35,300
I mean, maybe you have function application.

704
00:32:35,300 --> 00:32:36,460
And so we'll get into like,

705
00:32:36,460 --> 00:32:39,400
how can this possibly do stuff?

706
00:32:41,980 --> 00:32:44,140
So the first thing is you have in Lambda calculus

707
00:32:44,140 --> 00:32:45,940
this concept called identity function.

708
00:32:45,940 --> 00:32:48,160
This is the Lambda definition on the left

709
00:32:48,160 --> 00:32:50,760
and the JavaScript definition on the right.

710
00:32:50,760 --> 00:32:53,220
Obviously a very simple construct.

711
00:32:53,220 --> 00:32:57,120
In JavaScript we can have optional braces

712
00:32:57,120 --> 00:32:58,480
for the input parameter, right?

713
00:32:58,480 --> 00:33:00,180
So these two forms are equivalent.

714
00:33:00,180 --> 00:33:01,620
So I'm gonna drop the braces.

715
00:33:03,640 --> 00:33:05,320
And the names are just placeholders, right?

716
00:33:05,320 --> 00:33:09,260
So X and X and Z and Q that are,

717
00:33:09,260 --> 00:33:12,260
all of these constructs mean the same thing, right?

718
00:33:12,260 --> 00:33:14,760
So there's nothing special about X.

719
00:33:16,420 --> 00:33:17,740
So in Lambda calculus,

720
00:33:17,740 --> 00:33:19,540
you can call the identity function on itself.

721
00:33:19,540 --> 00:33:21,740
And basically what this is doing is,

722
00:33:21,740 --> 00:33:23,860
this is the function, right?

723
00:33:23,860 --> 00:33:26,840
And this is the thing that you're calling it with, right?

724
00:33:26,840 --> 00:33:29,020
This is a JavaScript equivalent, right?

725
00:33:29,020 --> 00:33:32,060
So what you do is for,

726
00:33:32,060 --> 00:33:33,980
this is the input variable X

727
00:33:33,980 --> 00:33:36,580
and this is the body of the function M.

728
00:33:36,580 --> 00:33:38,480
And inside the body,

729
00:33:38,480 --> 00:33:39,540
whenever you call this function,

730
00:33:39,540 --> 00:33:42,220
you replace every occurrence of X

731
00:33:42,220 --> 00:33:44,140
with whatever you call it with.

732
00:33:44,140 --> 00:33:46,820
So here every occurrence of X is replaced

733
00:33:46,820 --> 00:33:49,260
with this Lambda function with the purple Xs

734
00:33:49,260 --> 00:33:50,460
and you get this output.

735
00:33:51,620 --> 00:33:52,700
Not very interesting.

736
00:33:55,860 --> 00:33:57,720
Next you have this concept called curing.

737
00:33:57,720 --> 00:34:00,060
So in modern programming languages,

738
00:34:00,060 --> 00:34:03,700
most of them have this notion of having functions

739
00:34:03,700 --> 00:34:07,000
that accept multiple input parameters.

740
00:34:07,000 --> 00:34:10,140
But it turns out that you don't actually need this.

741
00:34:10,140 --> 00:34:14,700
And the way Alonzo church got around this idea

742
00:34:14,700 --> 00:34:16,380
is that instead of a function taking in

743
00:34:16,380 --> 00:34:18,100
two input parameters like this,

744
00:34:18,100 --> 00:34:22,100
we just have a function which returns another function

745
00:34:22,100 --> 00:34:24,620
which takes in an input parameter.

746
00:34:24,620 --> 00:34:25,460
That make sense?

747
00:34:26,940 --> 00:34:30,300
So this construct and this construct are equivalent.

748
00:34:31,360 --> 00:34:33,300
And Alonzo church said,

749
00:34:33,300 --> 00:34:35,860
instead of kind of being verbose like this,

750
00:34:36,460 --> 00:34:40,500
I'm gonna denote Lambda XY.M as equivalent to this.

751
00:34:42,260 --> 00:34:44,220
So it's not equivalent to this thing on the right

752
00:34:44,220 --> 00:34:45,220
because here in JavaScript,

753
00:34:45,220 --> 00:34:47,660
we have a function that takes in two input parameters.

754
00:34:47,660 --> 00:34:50,380
It's instead equivalent to this thing on the top right.

755
00:34:50,380 --> 00:34:52,020
Sorry for that's a little confusing.

756
00:34:52,020 --> 00:34:53,620
This concept is called curing.

757
00:34:58,140 --> 00:35:00,700
Next we're gonna define some true and false symbols.

758
00:35:00,700 --> 00:35:04,540
So you'll notice we didn't have any definition of numbers.

759
00:35:05,540 --> 00:35:08,300
And we didn't really have any definition of types

760
00:35:08,300 --> 00:35:09,500
or booleans or anything like that.

761
00:35:09,500 --> 00:35:12,100
We just had variables, function definition

762
00:35:12,100 --> 00:35:13,500
and function application.

763
00:35:13,500 --> 00:35:16,780
And so now we're adding more semantics to our language

764
00:35:17,940 --> 00:35:21,300
by defining these symbols called true and false.

765
00:35:21,300 --> 00:35:25,100
So very similar to how the number seven as a symbol

766
00:35:25,100 --> 00:35:27,540
is defined in terms of the successor function.

767
00:35:27,540 --> 00:35:32,140
Here the symbol T is defined as this function over here.

768
00:35:32,300 --> 00:35:33,420
And what this function is,

769
00:35:33,420 --> 00:35:35,900
is it's function that takes in two parameters

770
00:35:35,900 --> 00:35:38,940
and returns the first parameter.

771
00:35:40,300 --> 00:35:42,180
And the false symbol is the function

772
00:35:42,180 --> 00:35:43,660
that also takes in two parameters,

773
00:35:43,660 --> 00:35:46,540
but it returns the second symbol or second parameter.

774
00:35:47,780 --> 00:35:48,620
Is it following?

775
00:35:50,820 --> 00:35:51,900
Cool.

776
00:35:51,900 --> 00:35:54,340
So this is similar to our definition of seven.

777
00:35:57,060 --> 00:36:00,620
And from here, now we can sort of build an end function

778
00:36:00,620 --> 00:36:01,780
because we have boolean values.

779
00:36:01,780 --> 00:36:04,180
Let's see how we can build and.

780
00:36:04,180 --> 00:36:06,940
So this is actually the definition of and

781
00:36:06,940 --> 00:36:08,980
and we can kind of try it together.

782
00:36:08,980 --> 00:36:11,860
So and apply to true and false.

783
00:36:11,860 --> 00:36:15,220
Like logically we know that this should be false.

784
00:36:15,220 --> 00:36:16,500
So if we step through it,

785
00:36:16,500 --> 00:36:18,980
the first thing that we do is we replace and

786
00:36:18,980 --> 00:36:21,300
with this body over here.

787
00:36:21,300 --> 00:36:24,460
So lambda x, y, x, y, f, T and f, right?

788
00:36:24,460 --> 00:36:27,460
So here we have some lambda function

789
00:36:27,460 --> 00:36:30,380
and here we're denoting that we want to apply

790
00:36:30,380 --> 00:36:32,580
T to this function.

791
00:36:32,580 --> 00:36:35,500
So what we do is the first parameter is x.

792
00:36:35,500 --> 00:36:37,380
And so it's in this body.

793
00:36:37,380 --> 00:36:40,380
Every single time this x appears,

794
00:36:40,380 --> 00:36:41,940
we want to replace it with a T.

795
00:36:44,100 --> 00:36:46,460
And so what we're left with is lambda y, T, y, f.

796
00:36:46,460 --> 00:36:48,300
So this x has now become a T

797
00:36:48,300 --> 00:36:50,540
and we have one more input parameter

798
00:36:50,540 --> 00:36:51,860
that we need to resolve.

799
00:36:52,740 --> 00:36:55,860
And then same sort of deal, every occurrence of y.

800
00:36:56,100 --> 00:36:57,820
Now we're calling this function with f.

801
00:36:57,820 --> 00:37:01,580
Every occurrence of y, we want to replace with an f.

802
00:37:02,980 --> 00:37:06,100
And so we get T, f, f, okay?

803
00:37:06,100 --> 00:37:08,700
And so as you guys remember,

804
00:37:08,700 --> 00:37:12,060
true is actually defined as a function

805
00:37:12,060 --> 00:37:14,060
that takes in two input parameters

806
00:37:14,060 --> 00:37:15,420
and returns the first one.

807
00:37:15,420 --> 00:37:17,620
So in this case, it takes in two input parameters

808
00:37:17,620 --> 00:37:20,460
and then just returns the first one, which is f.

809
00:37:20,460 --> 00:37:23,700
So now we have some way of doing the and function.

810
00:37:24,700 --> 00:37:28,300
All right, let's try another example and T and T.

811
00:37:28,300 --> 00:37:31,580
Similarly, we expand and out to this thing

812
00:37:31,580 --> 00:37:32,980
and then we apply T to this thing,

813
00:37:32,980 --> 00:37:36,540
replace all the x's with T's and we get T, y, f.

814
00:37:36,540 --> 00:37:38,260
And then replace all the y's with T's

815
00:37:38,260 --> 00:37:40,580
and then we get T, T, f.

816
00:37:40,580 --> 00:37:43,260
And very similarly, T resolves

817
00:37:43,260 --> 00:37:46,420
to picking the first parameter and then we get T.

818
00:37:47,380 --> 00:37:51,980
So with just variables, functions and function application,

819
00:37:51,980 --> 00:37:54,940
all of a sudden now we have like Boolean logic.

820
00:37:54,940 --> 00:37:56,740
You can imagine how we can implement

821
00:37:57,820 --> 00:38:00,060
or an XOR and so on, right?

822
00:38:01,060 --> 00:38:03,260
So this is super unintuitive to me.

823
00:38:03,260 --> 00:38:08,260
Like the concept of defining true and false

824
00:38:08,300 --> 00:38:11,460
as these functions, like a true is actually a function

825
00:38:11,460 --> 00:38:12,740
which takes in two parameters

826
00:38:12,740 --> 00:38:14,060
and false is also a function

827
00:38:14,060 --> 00:38:16,060
which takes in two other parameters.

828
00:38:16,060 --> 00:38:20,180
And from there, building other functions like and,

829
00:38:20,180 --> 00:38:25,180
we can now do logical, like all of Boolean logic, right?

830
00:38:28,100 --> 00:38:28,940
Cool.

831
00:38:30,460 --> 00:38:33,740
This is the hardest slide, so you'll have to deal with me.

832
00:38:35,340 --> 00:38:36,660
I'm gonna talk about the y-combinator.

833
00:38:36,660 --> 00:38:40,300
So it turns out that many of you guys know about yc

834
00:38:40,300 --> 00:38:44,620
up in the Bay and it was essentially founded

835
00:38:44,620 --> 00:38:48,580
by a computer scientist who got the name

836
00:38:48,580 --> 00:38:49,420
from this principle.

837
00:38:49,420 --> 00:38:52,540
It's actually a Lambda calculus construct

838
00:38:52,540 --> 00:38:53,980
and it looks like this.

839
00:38:53,980 --> 00:38:55,220
And we're gonna go really slow

840
00:38:55,220 --> 00:38:57,660
and we'll go through it together, right?

841
00:38:57,660 --> 00:39:00,820
The first thing to notice is that y is just a function

842
00:39:00,820 --> 00:39:03,780
that takes in some input parameter y

843
00:39:03,780 --> 00:39:06,060
and it returns something, right?

844
00:39:06,060 --> 00:39:07,500
So nothing too crazy.

845
00:39:08,740 --> 00:39:11,420
What we can do is apply y,

846
00:39:11,420 --> 00:39:14,020
so let's say we have this function r, right?

847
00:39:14,020 --> 00:39:17,640
We wanna apply y to r, right?

848
00:39:17,640 --> 00:39:19,640
So in order to apply y to r,

849
00:39:19,640 --> 00:39:23,760
what we need to do is every occurrence of this yellow y

850
00:39:23,760 --> 00:39:26,520
inside this body, we need to replace

851
00:39:26,520 --> 00:39:30,120
with our input parameter r, okay?

852
00:39:30,120 --> 00:39:33,640
So all the yellow y's have now just become blue r's.

853
00:39:35,080 --> 00:39:36,760
Sound good?

854
00:39:36,760 --> 00:39:39,280
Okay, now if you look at this body,

855
00:39:39,280 --> 00:39:41,000
we can actually reduce it further.

856
00:39:41,000 --> 00:39:43,240
This first piece over here is a function

857
00:39:44,200 --> 00:39:48,920
and the second piece over here is a value

858
00:39:48,920 --> 00:39:50,760
that we can bind to this function

859
00:39:50,760 --> 00:39:54,200
or we can call this function with this value on the right.

860
00:39:54,200 --> 00:39:55,120
Okay?

861
00:39:55,120 --> 00:39:58,080
So what we're gonna do is this is the value on the right

862
00:39:58,080 --> 00:40:01,520
and if you look at this body, r, open print, x, x,

863
00:40:01,520 --> 00:40:05,520
close print, every occurrence of this magenta x,

864
00:40:05,520 --> 00:40:09,640
we're gonna replace with this body over here, okay?

865
00:40:10,520 --> 00:40:14,640
So r, x, x, has now been replaced with r,

866
00:40:14,640 --> 00:40:18,320
this body, this body, okay?

867
00:40:18,320 --> 00:40:20,640
We haven't done anything like too crazy

868
00:40:21,640 --> 00:40:25,200
and now if you'll notice like this line over here

869
00:40:25,200 --> 00:40:29,200
and the thing inside the parentheses of this r,

870
00:40:29,200 --> 00:40:31,040
they're actually the same thing.

871
00:40:32,040 --> 00:40:33,360
You guys see it?

872
00:40:33,360 --> 00:40:35,800
Here you have magenta values

873
00:40:35,800 --> 00:40:37,640
and here you have purple values.

874
00:40:38,560 --> 00:40:42,240
And the only difference is that this row

875
00:40:42,240 --> 00:40:45,600
has like an enclosed r, do you guys see that?

876
00:40:46,960 --> 00:40:50,600
Okay, so what we can do is take this yr

877
00:40:50,600 --> 00:40:53,120
because these yr and this thing on the right

878
00:40:53,120 --> 00:40:55,400
are equal to each other, so we can say

879
00:40:56,600 --> 00:41:01,600
yr is r of yr and it's not readily clear

880
00:41:03,880 --> 00:41:05,760
like why this is actually interesting

881
00:41:06,760 --> 00:41:11,520
or useful, but if you kind of sit down

882
00:41:11,520 --> 00:41:13,920
and think about it, what we've really done

883
00:41:13,920 --> 00:41:17,920
is define yr in terms of itself.

884
00:41:18,840 --> 00:41:23,080
So we've created like a recursive definition right here.

885
00:41:23,080 --> 00:41:26,400
And so what's actually happened is that this y-combinator

886
00:41:26,400 --> 00:41:29,400
is this thing over here allows you to take

887
00:41:29,400 --> 00:41:34,400
like a non-recursive concept and create recursion from nothing.

888
00:41:34,400 --> 00:41:37,080
So we just have variables, function definitions

889
00:41:37,080 --> 00:41:38,760
and function application

890
00:41:38,760 --> 00:41:41,480
and from those things we're able to create recursion.

891
00:41:43,040 --> 00:41:46,160
So this is like a crazy construct to me.

892
00:41:46,160 --> 00:41:47,800
Like we've created booleans

893
00:41:47,800 --> 00:41:49,320
and therefore we've created conditionals

894
00:41:49,320 --> 00:41:53,920
and from the same sort of raw axioms

895
00:41:53,920 --> 00:41:55,280
we've created recursion.

896
00:41:56,360 --> 00:41:58,880
Now, I encourage you guys to spend some time

897
00:41:58,880 --> 00:42:00,800
if you're interested like really examining this

898
00:42:00,800 --> 00:42:03,080
and coming to an understanding

899
00:42:03,080 --> 00:42:05,080
of why it's actually interesting and profound.

900
00:42:05,080 --> 00:42:07,480
But for now just take it on faith

901
00:42:07,480 --> 00:42:10,120
that we're able to create recursion from nothing

902
00:42:10,120 --> 00:42:11,880
and that's what the compelling aspect

903
00:42:11,880 --> 00:42:13,280
of the y-combinator is.

904
00:42:15,680 --> 00:42:19,280
Okay, the church Turing thesis.

905
00:42:19,280 --> 00:42:23,040
So we have these two independent models of computation

906
00:42:23,040 --> 00:42:24,720
the Turing machine and Lambda calculus

907
00:42:24,720 --> 00:42:26,720
invented at exactly the same time.

908
00:42:26,720 --> 00:42:30,160
And eventually these guys got together

909
00:42:30,160 --> 00:42:32,560
and they realized that their models of computation

910
00:42:32,560 --> 00:42:34,040
were actually equivalent.

911
00:42:34,040 --> 00:42:37,040
So originally when church was defining Lambda calculus

912
00:42:37,040 --> 00:42:40,160
he didn't define it in terms of turning machines

913
00:42:40,160 --> 00:42:42,240
and Turing when he was defining turning machines

914
00:42:42,240 --> 00:42:44,440
he didn't define it in terms of Lambda calculus

915
00:42:44,440 --> 00:42:46,760
they were sort of separate axiom towers.

916
00:42:46,760 --> 00:42:48,720
And so these guys got together and they said,

917
00:42:48,720 --> 00:42:53,440
wait, we have two different models of computation

918
00:42:53,440 --> 00:42:56,640
that we've proven independently to be sufficient

919
00:42:56,640 --> 00:42:59,600
to be able to compute anything that's computable.

920
00:42:59,680 --> 00:43:03,360
Is it true that our models are equivalent to each other?

921
00:43:03,360 --> 00:43:04,320
Was the question.

922
00:43:04,320 --> 00:43:05,640
And so they published this paper

923
00:43:05,640 --> 00:43:07,440
called the church Turing thesis.

924
00:43:07,440 --> 00:43:09,960
And it turns out that all Turing machines

925
00:43:09,960 --> 00:43:12,240
can be rewritten as Lambda expressions

926
00:43:12,240 --> 00:43:14,280
and all Lambda expressions can be rewritten

927
00:43:14,280 --> 00:43:15,840
as Turing machines.

928
00:43:15,840 --> 00:43:17,240
And we didn't really talk about

929
00:43:17,240 --> 00:43:18,760
Godel's recursive functions

930
00:43:18,760 --> 00:43:22,000
but it turns out that those are also equivalent.

931
00:43:22,000 --> 00:43:24,280
And so the conclusion here is that Lambda calculus

932
00:43:24,280 --> 00:43:25,160
is turning complete.

933
00:43:27,200 --> 00:43:29,080
Without any notions of explicit recursion,

934
00:43:29,080 --> 00:43:30,560
conditional state, et cetera.

935
00:43:32,200 --> 00:43:33,840
So all we need is variables, functions

936
00:43:33,840 --> 00:43:35,040
and function application.

937
00:43:35,040 --> 00:43:37,760
So let's go into the peculiarities of Lambda calculus

938
00:43:37,760 --> 00:43:40,480
because as software engineers we're sort of,

939
00:43:42,480 --> 00:43:45,040
we can think of the Turing machine as this thing

940
00:43:45,040 --> 00:43:46,520
that's very similar to a computer.

941
00:43:46,520 --> 00:43:48,320
And I'm gonna get to that in a moment

942
00:43:48,320 --> 00:43:52,440
but it's not really clear what this Lambda calculus thing is

943
00:43:52,440 --> 00:43:54,200
and how to do computation with it.

944
00:43:55,100 --> 00:43:58,600
So the first idea is that there's no notion of global state.

945
00:43:58,600 --> 00:43:59,520
There's no tape.

946
00:44:01,400 --> 00:44:04,400
All you have is the input arguments to your functions.

947
00:44:04,400 --> 00:44:07,560
That's the only semblance of state that you have.

948
00:44:07,560 --> 00:44:10,000
The second idea is all functions are pure.

949
00:44:10,000 --> 00:44:14,400
So purity is sort of this mathematical concept

950
00:44:14,400 --> 00:44:16,360
which is to say that it's a math function

951
00:44:16,360 --> 00:44:18,480
in that for any given input,

952
00:44:18,480 --> 00:44:21,740
it always, a function always returns the same output.

953
00:44:21,740 --> 00:44:24,040
So if you have a function for example,

954
00:44:24,040 --> 00:44:27,280
f of x equals x squared for an input three,

955
00:44:27,280 --> 00:44:28,840
call it this function with three,

956
00:44:28,840 --> 00:44:31,720
it's always gonna return nine no matter what.

957
00:44:31,720 --> 00:44:34,640
So all functions in Lambda calculus are pure.

958
00:44:36,480 --> 00:44:37,960
All values are immutable.

959
00:44:37,960 --> 00:44:42,220
So you can't modify an input parameter.

960
00:44:45,340 --> 00:44:47,200
But what you can do is generate a new value

961
00:44:47,200 --> 00:44:48,280
from an existing one.

962
00:44:49,920 --> 00:44:51,880
And there's also no loops.

963
00:44:51,880 --> 00:44:53,640
So you can't really iterate on things

964
00:44:53,640 --> 00:44:55,360
but the way we actually handle iteration

965
00:44:55,400 --> 00:44:59,760
in Lambda calculus like structures is through recursion.

966
00:45:01,720 --> 00:45:04,600
And then functions are your unit of composition.

967
00:45:04,600 --> 00:45:07,300
And the way you compose functions

968
00:45:07,300 --> 00:45:10,740
is sort of passing them as parameters to each other.

969
00:45:10,740 --> 00:45:14,640
And because of the nature of Lambda calculus,

970
00:45:14,640 --> 00:45:17,640
you don't have to reason about this global state.

971
00:45:17,640 --> 00:45:20,360
So when you're combining two simple functions together,

972
00:45:20,360 --> 00:45:25,280
all you need to know is what the consuming function does

973
00:45:25,320 --> 00:45:26,440
with the input.

974
00:45:26,440 --> 00:45:28,360
You don't have to reason about side effects

975
00:45:28,360 --> 00:45:29,880
or any other properties.

976
00:45:29,880 --> 00:45:33,480
So my claim over here is that because there's no global state,

977
00:45:33,480 --> 00:45:35,520
when you compose two things together,

978
00:45:35,520 --> 00:45:37,240
you can be sure that that composition

979
00:45:37,240 --> 00:45:38,480
is like really, really solid

980
00:45:38,480 --> 00:45:40,200
and it's not gonna result in bugs.

981
00:45:42,880 --> 00:45:44,680
Okay, the two towers.

982
00:45:45,920 --> 00:45:48,280
So we have turning machines on one hand

983
00:45:48,280 --> 00:45:50,120
and Lambda calculus on the other hand.

984
00:45:51,080 --> 00:45:52,360
And I've not so subtly drawn

985
00:45:52,360 --> 00:45:54,320
this Lambda calculus tower is perfect.

986
00:45:56,280 --> 00:45:59,120
But first we need to make a brief aside.

987
00:46:00,440 --> 00:46:02,960
In the 1940s, so less than a decade

988
00:46:02,960 --> 00:46:05,600
after turning machines came out,

989
00:46:06,680 --> 00:46:09,520
people started to ask the question of,

990
00:46:09,520 --> 00:46:12,100
okay, wait, this is great as a mathematical construct,

991
00:46:12,100 --> 00:46:16,400
but ultimately like I need to compute real stuff for my job.

992
00:46:16,400 --> 00:46:19,180
And so can we actually build a physical machine

993
00:46:19,180 --> 00:46:21,040
that does computation?

994
00:46:21,040 --> 00:46:24,080
And one of the core people involved in this work

995
00:46:24,080 --> 00:46:25,800
was this guy named John Von Neumann.

996
00:46:25,800 --> 00:46:27,800
He was a computer scientist.

997
00:46:27,800 --> 00:46:29,440
And he proposed this model

998
00:46:29,440 --> 00:46:31,720
for how we should build computing machines.

999
00:46:31,720 --> 00:46:35,160
And what he started with was this concept of memory,

1000
00:46:35,160 --> 00:46:38,680
the RAM, and memory is basically just like a Turing tape

1001
00:46:38,680 --> 00:46:41,080
in that it's put up into these cells

1002
00:46:41,080 --> 00:46:42,820
and the cells can contain values.

1003
00:46:43,960 --> 00:46:47,000
And then he proposed this thing called a CPU,

1004
00:46:47,000 --> 00:46:49,360
which is composed of two components essentially,

1005
00:46:49,360 --> 00:46:51,840
a control unit and a logic unit.

1006
00:46:52,120 --> 00:46:54,180
And the CPU interacts with the memory

1007
00:46:54,180 --> 00:46:57,040
by reading stuff from it and writing stuff to it.

1008
00:46:58,080 --> 00:47:02,000
And Von Neumann proposed like a small set of instructions.

1009
00:47:02,000 --> 00:47:05,400
You can load a value X from the memory cell

1010
00:47:05,400 --> 00:47:07,320
at the location P.

1011
00:47:07,320 --> 00:47:12,160
You can store a value X into the memory cell location P.

1012
00:47:13,200 --> 00:47:15,400
You can add, subtract, and multiply.

1013
00:47:15,400 --> 00:47:17,720
And so here's sort of like a minor deviation

1014
00:47:17,720 --> 00:47:19,080
from Turing's model.

1015
00:47:19,080 --> 00:47:21,600
Turing had no notion of numbers or addition

1016
00:47:21,600 --> 00:47:25,000
or so on and Turing as a mathematician just basically said,

1017
00:47:25,000 --> 00:47:27,240
those are levels of the axiom tower

1018
00:47:27,240 --> 00:47:29,320
that you can obviously derive for yourself.

1019
00:47:29,320 --> 00:47:32,160
Like I don't need to embed those in my axioms.

1020
00:47:32,160 --> 00:47:34,120
But Von Neumann wanted to build something

1021
00:47:34,120 --> 00:47:35,600
that actually computed stuff.

1022
00:47:35,600 --> 00:47:37,520
So did the addition and so on.

1023
00:47:37,520 --> 00:47:41,680
And so rather than having to do addition manually

1024
00:47:41,680 --> 00:47:43,880
in the form of like incrementing

1025
00:47:43,880 --> 00:47:46,120
or marking and unmarking cells,

1026
00:47:46,120 --> 00:47:49,560
Von Neumann said, why don't we just build like circuitry

1027
00:47:49,600 --> 00:47:51,840
that does the addition of two numbers

1028
00:47:53,000 --> 00:47:54,400
and embed that into the CPU.

1029
00:47:54,400 --> 00:47:56,800
So if I wanna take a value from cell A

1030
00:47:56,800 --> 00:47:58,760
and a value from cell B and add them together

1031
00:47:58,760 --> 00:48:00,880
and store them into cell C,

1032
00:48:00,880 --> 00:48:03,920
instead of manually doing that computation

1033
00:48:03,920 --> 00:48:05,840
like incrementing and decrementing,

1034
00:48:05,840 --> 00:48:07,880
let's create circuitry that does the addition

1035
00:48:07,880 --> 00:48:09,960
so that it's faster, okay?

1036
00:48:11,960 --> 00:48:13,120
And that's what the logic unit

1037
00:48:13,120 --> 00:48:15,240
is essentially responsible for.

1038
00:48:15,240 --> 00:48:18,520
Then you also have these instructions called branches

1039
00:48:18,560 --> 00:48:19,480
or jumps.

1040
00:48:19,480 --> 00:48:24,480
So if the memory cell at location P contains zero,

1041
00:48:24,720 --> 00:48:25,760
go to N.

1042
00:48:25,760 --> 00:48:27,320
And if it doesn't contain zero,

1043
00:48:27,320 --> 00:48:29,200
go to N, it's another instruction.

1044
00:48:29,200 --> 00:48:30,520
And what I'm trying to get at

1045
00:48:30,520 --> 00:48:33,360
is that this looks very much like a Turing machine.

1046
00:48:33,360 --> 00:48:36,840
And Von Neumann proposed the actual physical circuitry

1047
00:48:36,840 --> 00:48:39,600
that could implement something like this.

1048
00:48:39,600 --> 00:48:41,080
And the first computers,

1049
00:48:42,200 --> 00:48:43,720
the very first general computer

1050
00:48:43,720 --> 00:48:45,560
was this thing called ENIAC.

1051
00:48:45,560 --> 00:48:47,440
And I think it popped up in the 40s,

1052
00:48:47,440 --> 00:48:49,800
like 47 or something like that.

1053
00:48:49,800 --> 00:48:53,520
And basically it was like a room almost this size

1054
00:48:53,520 --> 00:48:57,320
and there was no notion of like a program

1055
00:48:57,320 --> 00:48:58,360
that you give to it.

1056
00:48:58,360 --> 00:49:00,520
All it had was like circuitry

1057
00:49:00,520 --> 00:49:03,080
and you had these like engineers that would go up

1058
00:49:03,080 --> 00:49:07,240
and unplug and replug stuff to program the ENIAC

1059
00:49:07,240 --> 00:49:08,680
and then it would operate

1060
00:49:08,680 --> 00:49:10,720
and turn through the computation, right?

1061
00:49:10,720 --> 00:49:12,400
But ultimately it looked exactly like this.

1062
00:49:12,400 --> 00:49:16,240
It had some mechanism to store values in memory

1063
00:49:16,240 --> 00:49:18,840
and then it had some mechanism to read

1064
00:49:18,840 --> 00:49:19,880
those values from memory,

1065
00:49:19,880 --> 00:49:22,200
combine them together in useful mathematical ways

1066
00:49:22,200 --> 00:49:23,600
and store the results back.

1067
00:49:27,360 --> 00:49:30,960
Cool, so the Turing machine tower.

1068
00:49:30,960 --> 00:49:32,040
Start off with Turing machines

1069
00:49:32,040 --> 00:49:33,840
and then we have this Von Neumann model.

1070
00:49:33,840 --> 00:49:35,280
And the compelling aspect of this

1071
00:49:35,280 --> 00:49:37,680
is sort of like a deviation from Turing machines

1072
00:49:37,680 --> 00:49:40,840
in that it can be actually physically implemented.

1073
00:49:40,840 --> 00:49:41,960
And one limitation here

1074
00:49:41,960 --> 00:49:43,600
is that you don't have an infinite tape,

1075
00:49:43,600 --> 00:49:46,640
you just have a finite amount of memory, right?

1076
00:49:46,640 --> 00:49:48,760
But if you embrace that constraint,

1077
00:49:48,760 --> 00:49:51,440
now all of a sudden you can actually compute things

1078
00:49:51,440 --> 00:49:55,600
instead of just leaving it up to a mathematician, okay?

1079
00:49:58,240 --> 00:50:03,160
In 1949, people got tired of manually plugging

1080
00:50:03,160 --> 00:50:04,760
and replugging in wires

1081
00:50:04,760 --> 00:50:08,920
and they wanted like a human level way

1082
00:50:08,920 --> 00:50:11,640
to reason about what the instructions were.

1083
00:50:11,640 --> 00:50:14,520
So they gave each of these instructions names,

1084
00:50:14,520 --> 00:50:17,600
like small names like add, store, mold, divide,

1085
00:50:17,600 --> 00:50:18,680
things like that.

1086
00:50:18,680 --> 00:50:23,080
And programs were written like by hand first

1087
00:50:23,080 --> 00:50:26,240
in this sort of ways that humans could reason about.

1088
00:50:26,240 --> 00:50:28,480
And then later they were assembled down

1089
00:50:28,480 --> 00:50:32,600
to the actual programming of the computer,

1090
00:50:32,600 --> 00:50:34,480
like programming the instructions into the computer.

1091
00:50:34,480 --> 00:50:37,880
And so what we've done is created a higher level construct

1092
00:50:37,920 --> 00:50:40,000
called assembly that humans are able to reason about

1093
00:50:40,000 --> 00:50:44,440
more easily, which maps down to the Von Neumann model

1094
00:50:44,440 --> 00:50:47,040
in terms of actually programming the computer.

1095
00:50:47,040 --> 00:50:48,480
Does that make sense?

1096
00:50:48,480 --> 00:50:51,000
Ultimately, it's sort of like syntactic sugar

1097
00:50:51,000 --> 00:50:55,360
or addition in that assembly doesn't add any more constructs.

1098
00:50:55,360 --> 00:50:57,960
Like there, all of the rules of assembly are defined

1099
00:50:57,960 --> 00:51:00,480
in terms of the Von Neumann axioms.

1100
00:51:03,360 --> 00:51:05,400
And then we have Fortran.

1101
00:51:05,400 --> 00:51:07,760
So Fortran is even higher level

1102
00:51:07,760 --> 00:51:11,480
and here it adds constructs like if statements and loops.

1103
00:51:11,480 --> 00:51:14,360
And you can imagine in 1957,

1104
00:51:14,360 --> 00:51:17,960
there really wasn't anyone who had conceived

1105
00:51:17,960 --> 00:51:21,400
of like a general notion of loops

1106
00:51:21,400 --> 00:51:22,960
or even like conditionals, right?

1107
00:51:22,960 --> 00:51:25,920
All we had were these like branch instructions

1108
00:51:25,920 --> 00:51:27,760
and maybe it was sort of implicitly defined

1109
00:51:27,760 --> 00:51:30,040
that you could make looping constructs from it.

1110
00:51:30,040 --> 00:51:31,440
But then people were like, wait,

1111
00:51:31,440 --> 00:51:34,280
why don't we just embrace this high level notion

1112
00:51:34,280 --> 00:51:39,080
of a looping construct and embedded in our language?

1113
00:51:39,080 --> 00:51:40,280
But just like assembly,

1114
00:51:40,280 --> 00:51:43,480
looping doesn't actually give you any more expressivity.

1115
00:51:43,480 --> 00:51:45,120
Every single loop can be defined

1116
00:51:45,120 --> 00:51:47,720
in terms of the lower level constructs.

1117
00:51:49,160 --> 00:51:50,320
Then we have C.

1118
00:51:51,440 --> 00:51:53,320
C introduces these things called functions

1119
00:51:53,320 --> 00:51:56,880
and then we have the ability to create more complex

1120
00:51:56,880 --> 00:51:59,080
structures of data called structs.

1121
00:51:59,080 --> 00:52:02,000
And then we have the ability to dynamically allocate

1122
00:52:02,000 --> 00:52:06,360
in free memory as opposed to just using,

1123
00:52:06,360 --> 00:52:09,640
you can imagine kind of manually dealing with

1124
00:52:09,640 --> 00:52:11,560
all of the memory on your physical hardware

1125
00:52:11,560 --> 00:52:14,920
as opposed to some other memory manager, right?

1126
00:52:17,040 --> 00:52:20,240
And then finally, we have C++ in 1985,

1127
00:52:20,240 --> 00:52:23,280
introduces this concept called classes and objects.

1128
00:52:23,280 --> 00:52:26,320
I'm not sure if like these concepts on the right

1129
00:52:26,320 --> 00:52:29,040
were introduced solely by the languages.

1130
00:52:29,040 --> 00:52:30,800
I probably not, they probably came

1131
00:52:30,800 --> 00:52:33,560
in some other flavor,

1132
00:52:33,560 --> 00:52:35,680
but I think these languages over here

1133
00:52:35,680 --> 00:52:39,200
are the most significant in terms of widespread use.

1134
00:52:39,200 --> 00:52:40,560
So that's really what I'm trying to get at.

1135
00:52:40,560 --> 00:52:43,040
It's not as much attribution as it much

1136
00:52:43,040 --> 00:52:45,520
as it is sort of relatively speaking

1137
00:52:45,520 --> 00:52:48,400
when these ideas popped up into existence.

1138
00:52:48,400 --> 00:52:51,800
But just like pianos axiom towers,

1139
00:52:51,800 --> 00:52:53,460
where you have kind of irrational numbers

1140
00:52:53,460 --> 00:52:56,320
like up at the top, classes and objects

1141
00:52:56,320 --> 00:52:59,280
are really just defined in relation

1142
00:52:59,280 --> 00:53:01,960
to von Neumann instructions.

1143
00:53:01,960 --> 00:53:03,800
Everything boils down to those things.

1144
00:53:06,400 --> 00:53:08,800
So we can think of the von Neumann machine instructions

1145
00:53:08,800 --> 00:53:12,240
almost like the axioms for computing,

1146
00:53:12,240 --> 00:53:13,680
for modern computing really.

1147
00:53:14,800 --> 00:53:18,040
And the Turing, so this claim is my own.

1148
00:53:18,040 --> 00:53:21,800
Like after studying like the history of this,

1149
00:53:21,800 --> 00:53:25,580
I asked myself the question, like, why is this tower,

1150
00:53:25,620 --> 00:53:28,740
like these languages specifically so much more popular

1151
00:53:28,740 --> 00:53:31,060
compared to the corresponding languages

1152
00:53:31,060 --> 00:53:33,840
and ideas in the Lambda calculus tower.

1153
00:53:33,840 --> 00:53:38,220
And my belief is that the Turing machine axiom tower

1154
00:53:38,220 --> 00:53:40,620
is actually easily implementable in hardware

1155
00:53:40,620 --> 00:53:43,020
because it's sort of like a physical device.

1156
00:53:43,020 --> 00:53:44,580
And because you can implement it in hardware,

1157
00:53:44,580 --> 00:53:47,260
you can actually compute stuff with it

1158
00:53:47,260 --> 00:53:49,980
as opposed to it being relegated to pure math, right?

1159
00:53:51,300 --> 00:53:53,660
The final idea is that a compiler

1160
00:53:53,660 --> 00:53:57,020
is just something that takes like a higher level construct

1161
00:53:57,020 --> 00:54:01,500
and reduces it down to its axiomatic von Neumann definition.

1162
00:54:01,500 --> 00:54:03,180
That's all what a compiler is.

1163
00:54:05,700 --> 00:54:06,540
Sound good?

1164
00:54:09,940 --> 00:54:12,140
Okay, the Lambda calculus tower.

1165
00:54:12,140 --> 00:54:13,980
So this one looks very different

1166
00:54:13,980 --> 00:54:16,900
because the first thing that we have

1167
00:54:16,900 --> 00:54:20,420
is just variables, functions and function application.

1168
00:54:20,420 --> 00:54:22,140
And we've already kind of seen some constructs

1169
00:54:22,140 --> 00:54:24,100
that you can build on top of that.

1170
00:54:24,100 --> 00:54:25,860
But one of the most interesting ones

1171
00:54:25,860 --> 00:54:28,100
is this idea called Lisp,

1172
00:54:28,100 --> 00:54:31,660
which came about in the 1950s.

1173
00:54:31,660 --> 00:54:34,580
And it came about also by a mathematician,

1174
00:54:34,580 --> 00:54:36,460
his name was John McCarthy.

1175
00:54:36,460 --> 00:54:39,980
And what McCarthy did was,

1176
00:54:39,980 --> 00:54:42,780
if you look at piano's axioms,

1177
00:54:42,780 --> 00:54:45,740
the definitions of those axioms were sort of defined

1178
00:54:45,740 --> 00:54:49,300
in terms of English and mathematical notation, right?

1179
00:54:49,300 --> 00:54:53,500
McCarthy said, what if we could take Lambda calculus

1180
00:54:53,500 --> 00:54:55,500
or structures like that

1181
00:54:55,500 --> 00:55:00,500
and define those axioms in the language itself?

1182
00:55:01,980 --> 00:55:04,820
And he created this language called Lisp.

1183
00:55:04,820 --> 00:55:09,820
And basically the implementation of Lisp is in Lisp itself.

1184
00:55:10,500 --> 00:55:12,700
And because he was a mathematician,

1185
00:55:12,700 --> 00:55:15,940
he had no need to actually implement it on a real computer.

1186
00:55:15,940 --> 00:55:18,660
And so this was sort of the first example

1187
00:55:18,820 --> 00:55:21,020
of what we call like a meta-circular construct.

1188
00:55:21,020 --> 00:55:23,620
So the construct is defined in terms of itself

1189
00:55:23,620 --> 00:55:25,380
and it's fully self-containing.

1190
00:55:25,380 --> 00:55:26,860
And I think a rite of passage

1191
00:55:26,860 --> 00:55:29,100
for like every single computer scientist

1192
00:55:29,100 --> 00:55:32,180
is to build your own Lisp interpreter.

1193
00:55:32,180 --> 00:55:36,940
And so McCarthy kind of proposed this idea in 1958

1194
00:55:36,940 --> 00:55:38,940
and then his students went along

1195
00:55:38,940 --> 00:55:41,140
and actually implemented Lisp

1196
00:55:41,140 --> 00:55:46,140
as on top of one Neumann machine to actually compute stuff.

1197
00:55:46,820 --> 00:55:49,940
The next idea is System F.

1198
00:55:49,940 --> 00:55:52,780
So this popped up in 1972

1199
00:55:52,780 --> 00:55:55,740
and you can think of System F as like Lambda calculus

1200
00:55:55,740 --> 00:55:58,020
except it has support for types.

1201
00:55:58,020 --> 00:56:01,940
So the Lambda calculus that I kind of showed you before

1202
00:56:01,940 --> 00:56:03,020
didn't really have any types.

1203
00:56:03,020 --> 00:56:04,620
So it's kind of like JavaScript.

1204
00:56:04,620 --> 00:56:08,220
System F is kind of the typescript equivalent

1205
00:56:08,220 --> 00:56:09,500
of Lambda calculus.

1206
00:56:10,820 --> 00:56:12,900
But a lot more sophisticated for reasons

1207
00:56:12,900 --> 00:56:14,140
that I don't want to get into.

1208
00:56:14,140 --> 00:56:17,340
But really every single System F construct

1209
00:56:17,340 --> 00:56:18,780
can be boiled down

1210
00:56:18,780 --> 00:56:21,420
into its corresponding Lambda calculus construct.

1211
00:56:21,420 --> 00:56:25,060
So very similar to how Fortran didn't add any expressivity.

1212
00:56:25,060 --> 00:56:27,740
System F didn't really add any expressivity either.

1213
00:56:29,020 --> 00:56:33,180
Then on top of this, we have these languages called ML.

1214
00:56:33,180 --> 00:56:36,220
I think ML stands for meta language and OCaml

1215
00:56:36,220 --> 00:56:40,420
which is the sort of most widely used flavor of ML.

1216
00:56:41,300 --> 00:56:43,980
And it introduced like higher level constructs

1217
00:56:43,980 --> 00:56:45,180
like pattern matching.

1218
00:56:45,180 --> 00:56:47,580
You guys haven't spent much time in functional programming.

1219
00:56:47,580 --> 00:56:50,740
Like it's, this whole tower is super weird

1220
00:56:50,740 --> 00:56:54,660
because these constructs don't actually carry over cleanly

1221
00:56:54,660 --> 00:56:58,380
to the imperative tower.

1222
00:56:58,380 --> 00:57:01,060
Sorry, the Von Neumann tower, the Turing tower.

1223
00:57:02,060 --> 00:57:06,020
On top of this, we have this language called Haskell

1224
00:57:06,020 --> 00:57:09,180
which earliest roots of it popped up in 1985.

1225
00:57:10,460 --> 00:57:13,220
Basically the same year that C++ came about

1226
00:57:13,220 --> 00:57:15,300
was when Haskell came about

1227
00:57:15,300 --> 00:57:18,140
or the predecessor to Haskell came about.

1228
00:57:18,140 --> 00:57:19,820
And the cool thing about Haskell

1229
00:57:19,820 --> 00:57:22,860
is that it is a general purpose programming language

1230
00:57:22,860 --> 00:57:25,540
that can do IO and things like that.

1231
00:57:25,540 --> 00:57:29,140
But its constructs are still pure.

1232
00:57:29,140 --> 00:57:32,580
So it still has pure math functions like everywhere.

1233
00:57:32,580 --> 00:57:34,820
And today Haskell is sort of like the king

1234
00:57:34,820 --> 00:57:37,620
of statically typed functional programming languages.

1235
00:57:39,500 --> 00:57:40,820
But now we get into some stuff

1236
00:57:40,820 --> 00:57:44,700
which might be more relevant to your guys' experience.

1237
00:57:44,700 --> 00:57:47,260
In 2012, Elm kind of popped up

1238
00:57:47,260 --> 00:57:50,140
and Elm is very much a functional programming language

1239
00:57:50,140 --> 00:57:52,580
even though it compiles down into JavaScript.

1240
00:57:52,580 --> 00:57:57,140
And the Elm people essentially pioneered

1241
00:57:57,140 --> 00:57:59,420
the flux-redex pattern.

1242
00:57:59,420 --> 00:58:02,780
So this idea that actions result in

1243
00:58:03,980 --> 00:58:05,740
essentially the production of a new state

1244
00:58:05,740 --> 00:58:08,220
and that new state can be used to render a new view

1245
00:58:08,220 --> 00:58:10,420
and there's a sort of like one-way data flow.

1246
00:58:10,460 --> 00:58:13,300
This idea popped up in 2012.

1247
00:58:13,300 --> 00:58:15,660
But if you're kind of thinking about the world

1248
00:58:15,660 --> 00:58:17,660
in terms of the Lambda calculus tower,

1249
00:58:17,660 --> 00:58:20,260
this idea is actually not that novel.

1250
00:58:20,260 --> 00:58:23,420
It's sort of a very obvious outcome

1251
00:58:23,420 --> 00:58:25,820
of dealing with the constraints of the Lambda tower.

1252
00:58:27,580 --> 00:58:30,900
Then from here in 2013, we have React.

1253
00:58:30,900 --> 00:58:33,740
React kind of makes a claim that the view

1254
00:58:33,740 --> 00:58:37,540
needs to be a pure function of the state or your props.

1255
00:58:38,580 --> 00:58:39,780
But really it's kind of just the same.

1256
00:58:39,780 --> 00:58:43,300
So given a state, we can always render the same view

1257
00:58:43,300 --> 00:58:45,820
like deterministically as a pure function.

1258
00:58:45,820 --> 00:58:48,940
And at first, like if you're coming from jQuery,

1259
00:58:48,940 --> 00:58:50,860
adopting the React pattern was probably

1260
00:58:50,860 --> 00:58:53,300
like extremely frustrating.

1261
00:58:53,300 --> 00:58:56,980
And for those of you, if you kind of recall back

1262
00:58:56,980 --> 00:58:58,900
to your first experiences with React,

1263
00:58:59,900 --> 00:59:02,380
you kind of felt like there was these artificial constraints

1264
00:59:02,380 --> 00:59:03,460
being imposed upon you.

1265
00:59:03,460 --> 00:59:05,620
Like I just want to hide the modal.

1266
00:59:05,620 --> 00:59:07,180
Why can't I do that?

1267
00:59:07,380 --> 00:59:08,220
Right?

1268
00:59:09,620 --> 00:59:11,100
But then eventually as you start to build

1269
00:59:11,100 --> 00:59:14,260
larger and larger apps, you realize

1270
00:59:14,260 --> 00:59:17,020
that like this sort of one-way data flow constraint

1271
00:59:17,020 --> 00:59:19,700
makes it way more easy to reason about

1272
00:59:19,700 --> 00:59:22,500
what your view is going to look like given a state.

1273
00:59:22,500 --> 00:59:25,020
And the point I'm trying to make over here

1274
00:59:25,020 --> 00:59:29,260
is that one, these ideas are not new.

1275
00:59:30,140 --> 00:59:33,180
Like Lambda calculus kind of forces us

1276
00:59:33,180 --> 00:59:36,260
to embody this perspective that the output of a function

1277
00:59:36,300 --> 00:59:40,260
is a pure outcome of its inputs, right?

1278
00:59:40,260 --> 00:59:43,780
And it's just now in like 2012, 2013

1279
00:59:43,780 --> 00:59:46,500
that we're starting to re-embrace these ideas.

1280
00:59:46,500 --> 00:59:49,260
And I guess most of us believe

1281
00:59:49,260 --> 00:59:52,340
that I can't even imagine building a UI

1282
00:59:52,340 --> 00:59:54,460
in a non-reactive way.

1283
00:59:54,460 --> 00:59:56,060
It's sort of like taken as given.

1284
00:59:56,060 --> 00:59:59,700
And so I think that if more engineers spend time

1285
00:59:59,700 --> 01:00:03,180
kind of thinking about the history of this thing,

1286
01:00:03,220 --> 01:00:05,100
it becomes a lot more like,

1287
01:00:06,220 --> 01:00:09,860
you can understand more like why React looks the way it does

1288
01:00:09,860 --> 01:00:11,980
or why Elm looks the way it does.

1289
01:00:11,980 --> 01:00:16,180
And rather than trying to apply your like Turing machine

1290
01:00:16,180 --> 01:00:19,180
imperative programming mindset to functional programming,

1291
01:00:19,180 --> 01:00:21,420
you can kind of build your way up

1292
01:00:21,420 --> 01:00:23,220
starting with Lambda calculus going up.

1293
01:00:23,220 --> 01:00:26,700
And I think that path actually makes it much more easy

1294
01:00:26,700 --> 01:00:28,540
to reason about functional programming.

1295
01:00:28,660 --> 01:00:33,660
As a fun side effect or a fun anecdote,

1296
01:00:37,940 --> 01:00:40,180
the original compiler for React

1297
01:00:40,180 --> 01:00:43,860
when it was still like an experimental project at Facebook

1298
01:00:43,860 --> 01:00:45,140
was written in OCaml.

1299
01:00:48,060 --> 01:00:50,740
All right, so the final like concession that I'll make

1300
01:00:50,740 --> 01:00:53,740
is that Lambda calculus is really hard

1301
01:00:53,740 --> 01:00:55,900
to implement in hardware.

1302
01:00:55,900 --> 01:00:59,700
And whereas the Turing machine von Neumann model

1303
01:00:59,700 --> 01:01:01,980
is obviously very easy to implement in hardware.

1304
01:01:05,420 --> 01:01:07,860
Okay, final slide.

1305
01:01:07,860 --> 01:01:09,780
React is to jQuery as Lambda calculus

1306
01:01:09,780 --> 01:01:10,980
is to the Turing machine.

1307
01:01:12,140 --> 01:01:15,300
So in jQuery, you have this concept called

1308
01:01:15,300 --> 01:01:17,300
like the DOM is your state.

1309
01:01:17,300 --> 01:01:21,060
So all of the HTML elements that are there is your state.

1310
01:01:21,060 --> 01:01:24,380
You've probably written jQuery code that looks like this.

1311
01:01:24,380 --> 01:01:27,300
jQuery.model.show and shows the modal.

1312
01:01:27,300 --> 01:01:29,100
And basically what I'm trying to get at here

1313
01:01:29,100 --> 01:01:32,220
is that whether the modal is being shown

1314
01:01:33,100 --> 01:01:37,300
is encoded in the DOM itself.

1315
01:01:39,260 --> 01:01:41,580
Anything can make modifications to the DOM

1316
01:01:41,580 --> 01:01:44,380
and the DOM as a result ends up

1317
01:01:44,380 --> 01:01:46,660
in these weird unexpected states

1318
01:01:46,660 --> 01:01:48,980
because you didn't precisely reason

1319
01:01:48,980 --> 01:01:50,820
about state modifications,

1320
01:01:50,820 --> 01:01:54,080
kind of just wrote code like this over and over again

1321
01:01:54,080 --> 01:01:56,520
until it essentially resulted

1322
01:01:56,520 --> 01:01:58,880
in a Turing machine like construct

1323
01:01:58,880 --> 01:02:03,440
where it's difficult to reason about the tape.

1324
01:02:03,440 --> 01:02:07,520
And so in React, the state is explicitly defined, right?

1325
01:02:07,520 --> 01:02:11,100
It's an input to your render function kind of implicitly

1326
01:02:11,100 --> 01:02:13,400
and your view is a pure function of the state.

1327
01:02:14,320 --> 01:02:17,940
And you don't modify the state, you produce a new state.

1328
01:02:19,240 --> 01:02:21,960
And so React's constraints actually make it easier

1329
01:02:22,000 --> 01:02:24,880
to reason about the state and the DOM.

1330
01:02:24,880 --> 01:02:28,240
And by analogy, functional programming's constraints

1331
01:02:28,240 --> 01:02:30,600
make it easier to reason about programs.

1332
01:02:32,640 --> 01:02:34,320
And so if you're intrigued

1333
01:02:36,440 --> 01:02:38,640
and wanna learn more about the Lambda Tower,

1334
01:02:38,640 --> 01:02:41,740
I highly recommend taking this approach.

1335
01:02:41,740 --> 01:02:43,240
If you guys haven't done Advent of Code,

1336
01:02:43,240 --> 01:02:45,980
it's essentially this wonderful set of problems

1337
01:02:45,980 --> 01:02:47,960
that show up every December.

1338
01:02:47,960 --> 01:02:49,720
Solve those problems in Elm.

1339
01:02:50,400 --> 01:02:52,960
Elm is a really good intro to functional programming

1340
01:02:52,960 --> 01:02:57,960
because the compiler messages were meant for humans

1341
01:02:59,720 --> 01:03:01,880
and the whole ecosystem is built

1342
01:03:01,880 --> 01:03:03,920
so that it's easy to pick up and learn.

1343
01:03:04,940 --> 01:03:07,880
And if you're familiar with the React-Redux pattern,

1344
01:03:07,880 --> 01:03:11,840
that kind of came from Elm and it becomes like,

1345
01:03:11,840 --> 01:03:14,720
you can build some cool stuff right out of the get-go.

1346
01:03:16,960 --> 01:03:18,960
All right, that's all I got.

1347
01:03:18,980 --> 01:03:20,320
Thanks.

1348
01:03:20,320 --> 01:03:21,160
Thank you.

1349
01:03:21,160 --> 01:03:22,000
Thank you.

1350
01:03:22,000 --> 01:03:22,840
Thanks.

1351
01:03:26,840 --> 01:03:27,680
Yes.

1352
01:03:41,880 --> 01:03:45,440
It's tough for me to say it because I wasn't there.

1353
01:03:45,440 --> 01:03:48,960
But I think it's sort of like a chicken and egg situation,

1354
01:03:48,960 --> 01:03:52,000
because we didn't have machines that could compute stuff.

1355
01:03:52,000 --> 01:03:54,880
We didn't rely on those machines to compute the stuff.

1356
01:03:54,880 --> 01:03:55,840
But then all of a sudden,

1357
01:03:55,840 --> 01:03:57,800
the machine to compute stuff popped up

1358
01:03:57,800 --> 01:04:00,120
and I got to imagine the first sets of calculations

1359
01:04:00,120 --> 01:04:03,440
were just silly, solving linear equations.

1360
01:04:03,440 --> 01:04:05,400
But then eventually people started to realize

1361
01:04:05,400 --> 01:04:07,520
we could do compelling things with this.

1362
01:04:07,520 --> 01:04:11,120
I'm sure the military was one of the first users of it.

1363
01:04:11,120 --> 01:04:13,440
We can do ballistic missile trajectory calculations

1364
01:04:13,440 --> 01:04:14,480
very easily.

1365
01:04:14,480 --> 01:04:17,080
And then, obviously, computing is now universal.

1366
01:04:36,920 --> 01:04:38,440
Questions, questions.

1367
01:04:38,440 --> 01:04:39,280
Yeah.

1368
01:04:45,480 --> 01:04:48,480
Have you heard of ReasonML?

1369
01:04:48,480 --> 01:04:52,480
Okay, so ReasonML is a rewrite of the OCaml syntax

1370
01:04:52,480 --> 01:04:57,480
to make it more comfortable for JavaScript developers.

1371
01:04:57,480 --> 01:05:00,480
Because the OCaml syntax is kind of stodgy

1372
01:05:00,480 --> 01:05:02,480
if you first look at it.

1373
01:05:02,480 --> 01:05:04,480
Whereas ReasonML, if you're coming from JavaScript,

1374
01:05:04,480 --> 01:05:05,480
it looks very similar.

1375
01:05:05,480 --> 01:05:10,480
But ReasonML is not a new language.

1376
01:05:10,480 --> 01:05:12,480
All it does is transpile down to OCaml.

1377
01:05:13,480 --> 01:05:16,480
And so if you want to get started with OCaml,

1378
01:05:16,480 --> 01:05:18,480
I wouldn't necessarily recommend it.

1379
01:05:18,480 --> 01:05:20,480
I would recommend starting with Elm first.

1380
01:05:20,480 --> 01:05:24,480
But then from there, if you want to build programs

1381
01:05:24,480 --> 01:05:27,480
that can interoperate with JavaScript really easily,

1382
01:05:27,480 --> 01:05:31,480
I think ReasonML is the best way to go.

1383
01:05:31,480 --> 01:05:32,480
Yeah.

1384
01:05:32,480 --> 01:05:33,480
Yeah.

1385
01:05:49,480 --> 01:05:52,480
Yeah, there was a lot of researchers in the 1980s

1386
01:05:52,480 --> 01:05:54,480
that actually tried this.

1387
01:05:54,480 --> 01:05:56,480
I think they built some prototypes.

1388
01:05:56,480 --> 01:06:00,480
The problem is that you have these sort of positive feedback

1389
01:06:00,480 --> 01:06:01,480
loops in ecosystems.

1390
01:06:01,480 --> 01:06:04,480
And so the Turing model and the Von Neumann model

1391
01:06:04,480 --> 01:06:11,480
essentially caught on so well that even though in theory

1392
01:06:11,480 --> 01:06:14,480
the Lambda Tower might allow for more expressivity,

1393
01:06:14,480 --> 01:06:18,480
practically speaking, the best computers are in the Turing model.

1394
01:06:18,480 --> 01:06:21,480
And therefore, more attention kind of gravitates towards there.

1395
01:06:21,480 --> 01:06:23,480
People build more stuff for it.

1396
01:06:23,480 --> 01:06:26,480
And now, I don't know, 90% plus of all languages

1397
01:06:26,480 --> 01:06:28,480
are kind of all Turing-based.

1398
01:06:28,480 --> 01:06:32,480
So in the 80s, they did build functional programming computers.

1399
01:06:32,480 --> 01:06:37,480
But because most of investment into these technologies

1400
01:06:37,480 --> 01:06:41,480
comes as a function of industry, like businesses,

1401
01:06:41,480 --> 01:06:43,480
like needing to solve business problems,

1402
01:06:43,480 --> 01:06:48,480
then the positive feedback loop of the Turing Tower

1403
01:06:48,480 --> 01:06:52,480
kind of diminished the Lambda Tower.

1404
01:06:52,480 --> 01:07:11,480
Yeah, so I would probably boil it down to just the three

1405
01:07:11,480 --> 01:07:12,480
constructs, right?

1406
01:07:12,480 --> 01:07:14,480
You have variables.

1407
01:07:14,480 --> 01:07:17,480
You have functions and function applications.

1408
01:07:17,480 --> 01:07:21,480
So is there a way to represent a variable in some sort

1409
01:07:21,480 --> 01:07:22,480
of circuitry?

1410
01:07:22,480 --> 01:07:25,480
Is there a way to represent a function in circuitry

1411
01:07:25,480 --> 01:07:27,480
as well as function application?

1412
01:07:27,480 --> 01:07:29,480
I think the answer to all those is you probably

1413
01:07:29,480 --> 01:07:30,480
conceive of some way.

1414
01:07:30,480 --> 01:07:35,480
I don't know the details of how the actual Lambda computers

1415
01:07:35,480 --> 01:07:38,480
were built, but it might be an interesting thing to look into.

1416
01:07:38,480 --> 01:07:40,480
But they obviously fizzled out.

1417
01:07:40,480 --> 01:07:43,480
The nature of the Von Neumann model in Turing machines

1418
01:07:43,480 --> 01:07:47,480
is that it maps so cleanly to binary circuitry

1419
01:07:47,480 --> 01:07:51,480
and originally vacuum tubes, but now transistors

1420
01:07:51,480 --> 01:07:54,480
map so perfectly down to that model,

1421
01:07:54,480 --> 01:07:56,480
whereas the concept of a function doesn't

1422
01:07:56,480 --> 01:08:12,480
map to logic gates cleanly.

1423
01:08:12,480 --> 01:08:14,480
All right.

1424
01:08:14,480 --> 01:08:16,480
Well, I guess with that we'll wrap up.

1425
01:08:16,480 --> 01:08:17,480
Thank you everyone.

