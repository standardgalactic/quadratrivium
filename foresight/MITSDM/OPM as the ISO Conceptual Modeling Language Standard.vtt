WEBVTT

00:00.000 --> 00:12.120
Hello, and welcome to the MIT System Design and Management

00:12.120 --> 00:13.120
Program.

00:13.120 --> 00:14.120
Oh, shoot.

00:14.120 --> 00:15.120
I didn't even meet myself.

00:15.120 --> 00:16.120
Hi.

00:16.120 --> 00:17.120
Hi.

00:17.120 --> 00:18.120
Hi again.

00:18.120 --> 00:25.160
Good morning, afternoon, or evening, whatever the case may be.

00:25.160 --> 00:28.840
Welcome to the MIT System Design and Management Program.

00:29.720 --> 00:33.240
System Thinking Webinar Series, my name is Lois Slavin.

00:33.240 --> 00:37.640
I'm the communications director and the host for this session.

00:37.640 --> 00:46.400
It gives us great pleasure to host Doug Dory today, and with that, I will turn it over

00:46.400 --> 00:48.600
to him with just one note.

00:48.600 --> 00:52.640
There will be time for Q&A within this hour.

00:52.640 --> 00:57.440
If you have any questions, please enter them directly into the chat window and address

00:57.440 --> 00:59.160
them to everyone.

00:59.160 --> 01:06.120
I will read them aloud, and Professor Dory will then answer them.

01:06.120 --> 01:13.840
Also, you will be sent a link to the recording of the webinar and to the presentation slides,

01:13.840 --> 01:17.920
and with that, Professor Doug Dory.

01:17.920 --> 01:18.920
Hello, everybody.

01:19.920 --> 01:26.680
I'm going to talk about the maturation of model-based systems engineering and the focus

01:26.680 --> 01:28.680
on OPM and C-SML.

01:28.680 --> 01:36.280
OPM is going to be the ESO Conceptual Modeling Language Standard, and the C-SML is already

01:36.280 --> 01:37.280
a standard.

01:37.280 --> 01:47.440
As engineers, we know that any engineering discipline has their own language which they

01:47.440 --> 01:48.440
express themselves.

01:48.440 --> 01:55.800
For example, mechanical engineers have machine drawings, civil engineers have floor maps,

01:55.800 --> 02:04.640
electronics engineers have their own set of drawings, and software engineers have models

02:04.640 --> 02:08.400
such as UML.

02:08.400 --> 02:11.480
How about and what about systems engineers?

02:11.480 --> 02:15.120
What language do they speak?

02:15.120 --> 02:24.360
It turns out that what is required is a graphical, maybe also textual, formal language for conveying

02:24.360 --> 02:31.680
systems, architectures, and designs in a conceptual, straightforward, and clear, and unambiguous

02:31.680 --> 02:32.680
way.

02:32.680 --> 02:40.920
It turns out that systems engineers, as of a few years back, do have a couple of languages.

02:40.920 --> 02:48.600
One of them is C-SML, Systems Modeling Language, which has been the standard of OMG Object Management

02:48.600 --> 02:51.800
Group since 2007.

02:51.800 --> 02:58.960
There is also Object Process Methodology, OPM, which is in the process of becoming ISO standard

02:58.960 --> 03:01.240
since 2009.

03:01.240 --> 03:09.000
There is also a book that was published in 2002, previous publications date back to 1995.

03:09.440 --> 03:14.920
Why do we need conceptual modeling to begin with?

03:14.920 --> 03:18.080
There are several good reasons.

03:18.080 --> 03:25.880
One is that we want to construct a mental picture of the system we are aiming to build,

03:25.880 --> 03:27.640
design, architect.

03:27.640 --> 03:35.800
We want to anchor one's understanding in formalisms that can be visual and or textual.

03:35.800 --> 03:39.720
There are two things that are required for dual channel processing, that is, the brain

03:39.720 --> 03:47.600
processes information both visually and verbally, and if we can do it in parallel, that is even

03:47.600 --> 03:48.600
better.

03:48.600 --> 03:56.280
We want to design systems using nonverbal means, graphical, visual, convert acid knowledge

03:56.280 --> 04:02.480
to explicit one, because many people have their knowledge, but they don't express it

04:02.480 --> 04:03.480
explicitly.

04:04.160 --> 04:10.160
Of course, we want to communicate the concepts that we have in mind to others very clearly

04:10.160 --> 04:13.280
and unambiguously.

04:13.280 --> 04:19.760
One key concept or term for our discussion is ontology.

04:19.760 --> 04:27.560
So ontology, for our purpose, let's define it as a set of concepts for describing a domain.

04:27.560 --> 04:34.680
Domain can be industry, banking, military, healthcare, and systems within this domain.

04:34.680 --> 04:39.760
This has been in use for quite a long time.

04:39.760 --> 04:45.080
We define a universal ontology as a set of concepts for describing the universal systems

04:45.080 --> 04:47.880
within it, which is domain-independent.

04:47.880 --> 04:51.840
It is not geared towards any specific domain.

04:51.840 --> 04:56.440
Therefore, it is called universal.

04:56.440 --> 05:02.440
What we want to really do is have ontological grounding of model-based systems engineering.

05:02.440 --> 05:10.440
That is, we want to have a justification of what building blocks we are going to use in

05:10.440 --> 05:16.760
our modeling language, not just start using anything.

05:16.760 --> 05:23.680
To this end, we will try to determine the minimal set of concepts, which is required

05:23.680 --> 05:26.440
to model the universe and systems in it.

05:26.440 --> 05:32.880
This will be our ontology, a minimal ontology that is required and sufficient to describe

05:32.880 --> 05:35.360
the universe and systems in it.

05:35.360 --> 05:42.920
In order to do it in an appealing and engaging way, what I'm going to do is start with a series

05:42.920 --> 05:53.000
of questions as Socrates used to do 2,500 years ago, but since it's a webinar and unfortunately

05:53.000 --> 06:00.800
I can't get your immediate answers, I will just wait a while and then give the answer

06:00.800 --> 06:01.800
myself.

06:01.800 --> 06:04.480
Of course, you will be able to ask questions later on.

06:04.480 --> 06:13.280
The first fundamental question is, what are the things that exist in the universe?

06:13.280 --> 06:17.040
What do we call them?

06:17.040 --> 06:21.880
The answer is objects are the things that exist or might exist.

06:21.880 --> 06:30.520
We can think of them as things that might exist or exist in fact.

06:30.520 --> 06:38.240
The next one is, what are the things that happen in the universe?

06:38.240 --> 06:44.520
The answer is that processes happen or might happen, but we have to also remember that

06:44.520 --> 06:51.520
processes cannot happen in vacuum, they happen to something.

06:51.520 --> 06:59.320
The follow-up question is, what are the things to which processes happen?

06:59.320 --> 07:03.160
The answer is that processes happen to objects.

07:03.160 --> 07:06.480
The things that happen happen to the things that exist.

07:06.480 --> 07:15.480
If this is so, what do processes do to objects?

07:15.480 --> 07:21.480
The answer is that they transform, processes transform objects.

07:21.480 --> 07:23.880
Next we can ask, what does it mean to transform?

07:23.880 --> 07:29.360
What does it mean for a process to transform an object?

07:29.360 --> 07:35.440
Transforming of an object by a process means one of three possible things.

07:35.440 --> 07:41.160
The process can create an object, the process can destroy or consume an object, and the

07:41.160 --> 07:44.720
process can affect an object.

07:44.720 --> 07:50.080
Creating, which is equivalent to generating and destroying, are quite straightforward,

07:50.080 --> 07:52.040
but what does affecting mean?

07:52.040 --> 07:56.400
What does it mean for a process to affect an object?

07:56.400 --> 08:03.040
A process affects an object by changing its state.

08:03.040 --> 08:10.240
Here we introduce, in addition to objects and processes, a third term, which is state,

08:10.240 --> 08:12.880
and objects therefore must be stateful.

08:12.880 --> 08:14.960
In other words, they must have states.

08:14.960 --> 08:22.240
We are talking about not just objects, but stateful objects and processes that transform

08:22.240 --> 08:23.240
them.

08:23.240 --> 08:31.280
Let's shift gears for a while and ask another key question that we will need to use later

08:31.280 --> 08:32.280
on.

08:32.280 --> 08:39.160
What are the two complementary aspects from which any system can be viewed?

08:39.160 --> 08:44.400
Two important, two key aspects.

08:44.400 --> 08:47.320
The two key aspects are structure and behavior.

08:47.320 --> 08:49.080
Structure is a static aspect.

08:49.080 --> 08:52.280
It answers the question, what is the system made of?

08:52.280 --> 08:53.280
What are the parts?

08:53.280 --> 08:55.680
How are they related?

08:55.680 --> 08:59.800
The second aspect, the complementary aspect, is the behavior.

08:59.800 --> 09:01.560
It's the dynamic aspect.

09:01.560 --> 09:06.720
It answers the question, how does the system change over time?

09:06.720 --> 09:14.520
What happens to the system and to the objects in it?

09:14.520 --> 09:21.920
In addition, there is a third aspect that is only relevant to a man-made system.

09:21.920 --> 09:23.440
What is it?

09:23.440 --> 09:31.560
Well, the function, or the utilitarian, the subjective aspect, answers the question, why

09:31.560 --> 09:33.000
is the system built?

09:33.000 --> 09:34.000
For whom?

09:34.000 --> 09:35.000
Who is the beneficiary?

09:35.000 --> 09:38.840
Who benefits from operating the system?

09:38.840 --> 09:46.720
This question has meaning only in the context of man-made systems, but much less so in natural

09:46.720 --> 09:48.400
occurring systems.

09:48.400 --> 09:53.600
What is the basic idea behind conceptual modeling?

09:53.600 --> 09:57.240
We have the conceived reality as we sense it.

09:57.240 --> 10:06.200
We engage with the world through our senses, and we conceive some view of the reality.

10:06.200 --> 10:09.400
We see things, we hear things.

10:09.400 --> 10:17.840
Here is an aircraft, airplane, a bus, here is a person feeling gas.

10:17.840 --> 10:25.760
The airplane is modeled by a symbol, a rectangle in which aircraft is written, a bus similarly

10:25.760 --> 10:30.480
is modeled by a symbol for the bus, an object.

10:30.480 --> 10:32.680
These are two objects.

10:32.680 --> 10:34.840
The third one, however, is different.

10:34.840 --> 10:43.160
We see something happening, not just an object existing, but we see a process.

10:43.160 --> 10:47.720
Before this, let us see what the common between aircraft and buses.

10:47.720 --> 10:55.680
Aircraft is a vehicle and bus is also a vehicle, so we see that we can start, see how we can

10:55.680 --> 11:03.600
generalize things which is part of the conceptual modeling, generalization, specialization is

11:03.600 --> 11:12.120
an important relation, structural relation between things, be they objects or processes.

11:12.120 --> 11:20.560
Now looking at this process, this thing, this process is modeled by an ellipse because

11:20.560 --> 11:22.960
it's a process and not an object.

11:22.960 --> 11:32.480
We call it gas feeling, and it's a process, and it affects, as you should recall, an object.

11:32.480 --> 11:36.560
Any process must transform an object.

11:36.560 --> 11:42.440
In our case, the transformation is effect, and the gas feeling affects the car.

11:42.440 --> 11:44.200
How does it affect the car?

11:44.200 --> 11:54.280
It changes its state from being empty of gasoline to being full with gasoline.

11:54.280 --> 12:02.120
And just as we did with the objects, we can generalize gas feeling as being a special

12:02.120 --> 12:05.640
case of energy replenishing process.

12:05.640 --> 12:13.400
If this was an electric car, we would charge it with electricity rather than feeling gas,

12:13.400 --> 12:19.040
and that would be another kind or type of energy replenishing.

12:19.040 --> 12:23.040
So we see that there is quite an analogy between objects and processes.

12:23.040 --> 12:30.880
So just as objects can be generalized, so can processes be generalized.

12:30.880 --> 12:37.040
So using graphical symbols, the model expresses relations between things that are objects and

12:37.040 --> 12:38.040
processes.

12:38.040 --> 12:41.960
These are things in our model, and the relations among them.

12:41.960 --> 12:47.880
Currently, the relations are simply written along the arrows, but they have, as we will

12:47.880 --> 12:52.800
see, certain better symbols.

12:52.800 --> 13:00.600
So I'm now going to introduce something new, which I call the object process theorem.

13:00.600 --> 13:04.320
This theorem states the following.

13:04.320 --> 13:10.920
Stateful objects, processes, and relations among them constitute a necessary and sufficient

13:10.920 --> 13:13.560
universal ontology.

13:13.560 --> 13:18.520
In other words, or a corollary to this, is that using stateful objects, processes, and

13:18.520 --> 13:25.160
relations among them, it is possible to model systems in various domains and at any level

13:25.160 --> 13:26.160
of complexity.

13:26.840 --> 13:35.800
So it's a pretty ambitious statement or theorem, and I want to try to prove it now with you.

13:35.800 --> 13:38.000
So there are two parts.

13:38.000 --> 13:40.240
We say that it's necessary and sufficient.

13:40.240 --> 13:46.600
So we have to show that stateful objects and processes, first, are necessary to specify

13:46.600 --> 13:53.040
the two system aspects, because as we said, these are the two aspects, the structural

13:53.040 --> 13:57.480
and the procedural aspect, we need to be able to specify them.

13:57.480 --> 14:03.680
So specifying the structural static system aspect requires stateful objects and relations

14:03.680 --> 14:09.480
among them, because we want to show what is out there, what the system is made of.

14:09.480 --> 14:15.880
In order to specify the procedural or dynamic system aspect, we need processes and relations

14:15.880 --> 14:19.720
between them and the objects that they transform.

14:19.720 --> 14:26.800
So it's necessary to have both stateful objects and processes as well as relations among them.

14:26.800 --> 14:29.880
So we have the proof of the necessity.

14:29.880 --> 14:32.200
Now we want to prove that they are sufficient.

14:32.200 --> 14:37.760
So stateful objects and processes are sufficient to specify anything in any system.

14:37.760 --> 14:39.880
Why is that correct?

14:39.880 --> 14:48.320
Anything that exists can be specified in terms of stateful objects and relations among them.

14:48.320 --> 14:54.080
Anything that happens to an object can be specified in terms of processes and relations

14:54.080 --> 14:58.440
between these processes and the objects that they transform.

14:58.440 --> 15:06.080
So sufficiency is also proven and this is actually the end of the proof.

15:06.080 --> 15:15.080
So what we take of this is that it is enough to model any system at any level of complexity

15:15.080 --> 15:22.440
and in any domain using stateful objects and processes that transform them along with relations

15:22.440 --> 15:25.400
among them.

15:25.400 --> 15:28.320
So what are the keys to good conceptual modeling?

15:28.320 --> 15:33.360
First of all, because objects and processes are key to modeling, we have to be able to

15:33.360 --> 15:34.880
tell them apart.

15:34.880 --> 15:43.720
Telling processes and objects apart is the first key to good conceptual modeling.

15:43.720 --> 15:50.880
Then we want to model the objects and processes concurrently because the world is really such

15:50.880 --> 15:56.440
that or systems are such that structure and behavior are tightly intertwined and trying

15:56.440 --> 16:02.960
to separate that does not make a lot of sense, at least not in the beginning.

16:02.960 --> 16:10.240
We want to see how the structure and behavior are connected to each other.

16:10.240 --> 16:13.280
Then we want to be able to manage the complexity of systems.

16:13.280 --> 16:20.200
Systems are inherently complex and we do this through abstraction and refinement mechanisms.

16:20.200 --> 16:31.240
Finally, if possible, we want to utilize dual channel processing in order to take advantage

16:31.240 --> 16:37.480
of our brain processing capabilities of both graphics and text concurrently.

16:38.480 --> 16:48.760
Several years ago, Jeff Estefan, in 2008, published as part of the INCOSSE task force,

16:48.760 --> 16:55.320
a survey of the leading model-based systems engineering methodologies and there were six

16:55.320 --> 16:56.320
of them.

16:56.320 --> 17:02.320
You can see the list here, two of them are from IBM, telelogic, rational, there is INCOSSE

17:02.320 --> 17:10.040
object-oriented systems engineering method, Vitec, JPL state analysis and OPM was also

17:10.040 --> 17:11.040
one of them.

17:11.040 --> 17:17.680
Some of you might wonder why system L was not surveyed and the answer is that system

17:17.680 --> 17:27.800
L is a language but it is not a methodology so it is not included in this survey.

17:27.800 --> 17:33.960
In OPM, in object process methodology, we talk about things which are categorized into

17:33.960 --> 17:38.280
objects, stateful objects and processes that transform the objects.

17:38.280 --> 17:41.440
These are the symbols as we have seen them.

17:41.440 --> 17:48.280
An object is defined as a thing that exists or might exist physically or informatically

17:48.280 --> 17:52.640
and the process is a thing that transforms one or more objects.

17:52.640 --> 17:59.120
Processes transform means either generates or consumes or affects, changes the state

17:59.120 --> 18:02.360
of an object.

18:02.360 --> 18:09.120
Here is how this is expressed both graphically and textually.

18:09.120 --> 18:13.120
Processes transform objects by one option is consuming them.

18:13.120 --> 18:20.520
Here is an example of a process manufacturing which consumes raw material as it operates

18:20.520 --> 18:25.880
and the sentence that we see at the bottom is automatically generated by software called

18:25.880 --> 18:29.400
OPCAT which anyone can download for free.

18:29.400 --> 18:31.360
I am going to give you the link soon.

18:31.360 --> 18:40.040
Sure, they call it VR out, it's clear in items, that type of thing, what floor do they use your

18:40.040 --> 18:41.040
want?

18:41.040 --> 18:42.040
Okay.

18:42.040 --> 18:43.040
The second way.

18:43.040 --> 18:44.040
Yes, VR out items.

18:44.040 --> 18:54.040
If I look at the rack, yes, we don't have this kind of work theory, what's good?

18:54.040 --> 19:02.040
Every floor has it, because they told me when I was a kid, we had some VR out items that

19:02.040 --> 19:04.040
were interlocking.

19:04.040 --> 19:10.040
Excuse me, please make sure you're muting yourselves, we hear a woman say hello.

19:10.040 --> 19:13.040
Okay, so that's what we know.

19:13.040 --> 19:23.040
I remember when the back of the window was like, I wouldn't say between a two-year-old

19:23.040 --> 19:24.040
lady, whatever.

19:24.040 --> 19:25.040
Sorry about that.

19:25.040 --> 19:30.040
They were near the window, with the back of the door, with windows.

19:30.040 --> 19:41.040
And I remember, so what's on the 8th floor then, what are the labels in 8th floor?

19:41.040 --> 19:42.040
Power?

19:42.040 --> 19:43.040
What does that mean?

19:43.040 --> 19:44.040
What does that mean?

19:44.040 --> 19:45.040
Okay, I'll try to continue.

19:45.040 --> 19:46.040
Okay, thank you, honey.

19:46.040 --> 19:47.040
Right here.

19:47.040 --> 19:58.040
Okay, hopefully this will not happen again.

19:58.040 --> 20:09.040
So second way of transforming processes by objects is creating them.

20:09.040 --> 20:14.040
So here we see manufacturing creating the product.

20:14.040 --> 20:20.040
So you see another sentence was added here, manufacturing yields product, and that's the

20:20.040 --> 20:27.040
same error except it goes from the process to the object, whereas the previous one went

20:27.040 --> 20:37.040
from the object to the process.

20:37.040 --> 20:43.040
And the third option for processes to transform objects is by changing the state.

20:43.040 --> 20:52.040
So in this example, we have a process testing which changes products from a state of being

20:52.040 --> 21:00.040
pre-tested to a state of being tested, and that translates to a couple of sentences.

21:00.040 --> 21:06.040
Product can be pre-tested or tested, and testing the process changes products.

21:06.040 --> 21:09.040
The object from pre-tested to tested.

21:09.040 --> 21:15.040
Again, all of these sentences are generated automatically on the fly in response to the

21:15.040 --> 21:25.040
input by the modeler, by the system architect or designer.

21:25.040 --> 21:34.040
So again, the two things that OPM has or deals or uses for modeling are objects and processes

21:34.040 --> 21:37.040
and all the rest are relations between things.

21:37.040 --> 21:44.040
For example, these pair of arrows are called input output link pair from the input state

21:44.040 --> 21:49.040
pre-tested in this case to the output state testing.

21:49.040 --> 21:55.040
So I want to show you a more realistic system.

21:55.040 --> 22:01.040
We all have experience with baggage handling and sometimes it also gets lost.

22:01.040 --> 22:12.040
So here is a model of baggage handling, which is the main process that you see in this diagram.

22:12.040 --> 22:19.040
And we see the objects revolving around it, which are the passenger, the baggage, the baggage

22:19.040 --> 22:23.040
location, which is an attribute of the baggage, the airport, and the airline.

22:23.040 --> 22:29.040
These are the major objects that are involved in this process.

22:29.040 --> 22:34.040
So the system's function is really this main process in the system diagram, the top level

22:34.040 --> 22:37.040
diagram, which is this one.

22:37.040 --> 22:42.040
This, by the way, is the graphic user interface of OPCA, the software that I mentioned.

22:42.040 --> 22:54.040
And one of the guidelines in the OPM methodology is to start the modeling with depicting the

22:54.040 --> 23:02.040
function of the system, what the system does to benefit one or more users, beneficiaries.

23:02.040 --> 23:04.040
So in this case, it's baggage handling.

23:04.040 --> 23:11.040
Processes should end with ING to give the feeling of something happening.

23:11.040 --> 23:17.040
The beneficiary in this case is the passenger and the operand, the thing that the baggage

23:17.040 --> 23:20.040
handling operates on is the baggage.

23:20.040 --> 23:28.040
The attribute of the baggage is the location, which needs to be changed from origin, the

23:28.040 --> 23:33.040
original, the initial state, to the destination, the final state.

23:33.040 --> 23:40.040
All this is expressed textually here at the bottom with what we call object process language,

23:40.040 --> 23:42.040
or OPL for short.

23:42.040 --> 23:45.040
These are the attribute values, origin and destination.

23:45.040 --> 23:50.040
This whole thing is called the object process diagram, or OPD for short.

23:50.040 --> 23:57.040
And the text at the bottom is object process language, or OPL, which, as I said, is generated

23:57.040 --> 24:05.040
automatically on the fly to interpret textually what is expressed by the model graphically

24:05.040 --> 24:06.040
at the top.

24:06.040 --> 24:14.040
On the left, you can see a hierarchy of object process diagrams because now that we have

24:14.040 --> 24:20.040
modeled the top level and we see what the system is all about and what its main function

24:20.040 --> 24:32.040
is, we can elaborate by zooming into the baggage handling and show that it is comprised of lower

24:32.040 --> 24:33.040
level processes.

24:33.040 --> 24:39.040
I can show it to you later on as we go if we have time.

24:40.040 --> 24:48.040
One thing that OPN does is to unify the three aspects that we mentioned, the functional

24:48.040 --> 24:55.040
aspect, why the system is built, what is the utility who benefits from it, the structure

24:55.040 --> 25:00.040
of the system, what is the system made of, and the behavior of the system, the dynamic

25:00.040 --> 25:06.040
aspect talking about how the system changes over time.

25:06.040 --> 25:12.040
These three aspects are expressed b-modally, that is, both in graphics and equivalent text,

25:12.040 --> 25:16.040
that is generated automatically, all in a single model.

25:16.040 --> 25:20.040
We don't need to have several types of diagrams.

25:20.040 --> 25:27.040
It's always object process diagrams at different levels of depth.

25:28.040 --> 25:37.040
We zoom into the baggage handling which was only a single ellipse in the previous top

25:37.040 --> 25:38.040
level diagram.

25:38.040 --> 25:44.040
Here we see sub-processes of these baggage handling processes which are origin, baggage

25:44.040 --> 25:49.040
handling, destination, baggage handling, baggage claiming, and lost and found baggage handling.

25:49.040 --> 25:56.040
They are arranged from top to bottom vertically in the order that they happen.

25:56.040 --> 26:06.040
This is the timeline which goes from the top of the in-zoom process ellipse to its bottom.

26:06.040 --> 26:15.040
This is how time can be managed in an OPN model.

26:15.040 --> 26:18.040
Again, around we see the objects that are involved.

26:18.040 --> 26:22.040
Airports specializes into origin airport and destination airport.

26:23.040 --> 26:29.040
The airline is comprised, among other things, of lost and found desk which is engaged in

26:29.040 --> 26:32.040
the lost and found baggage handling.

26:32.040 --> 26:39.040
The baggage has a location which, in addition to having the states of origin and destination,

26:39.040 --> 26:46.040
now we can see that it also can be aboard the aircraft or someplace else which we don't

26:46.040 --> 26:48.040
want to have, but this happened.

26:48.040 --> 26:55.040
This is, for example, a condition for having the lost and found baggage handling sub-process

26:55.040 --> 26:58.040
execute.

27:04.040 --> 27:10.040
We've talked about the universality of the object process ontology or, in other words,

27:10.040 --> 27:20.040
the claim which I hope proved that stateful objects and processes are sufficient for

27:20.040 --> 27:27.040
modeling complex systems in any domain and at any level of complexity.

27:27.040 --> 27:33.040
In order to support this empirically, I want to show you something from a totally different

27:33.040 --> 27:36.040
domain which is molecular biology.

27:36.040 --> 27:42.040
Baggage handling and molecular biology have in common the fact that they can both be

27:42.040 --> 27:45.040
modeled using stateful objects and processes.

27:48.040 --> 27:55.040
A little digression to molecular biology, we all know that biological systems, organisms

27:55.040 --> 27:57.040
are highly complex.

27:57.040 --> 28:04.040
They have organs that are made of cells and each cell has many, many thousands of biological

28:04.040 --> 28:10.040
pathways, each comprised of many hundreds or thousands of biological reactions and all

28:10.040 --> 28:17.040
this is happening in a tiny cell which is a whole world in its own.

28:17.040 --> 28:27.040
In order to, and many, many thousands of researchers in biology are trying to unravel these

28:27.040 --> 28:33.040
mechanisms and this is what molecular biology is all about.

28:34.040 --> 28:41.040
We have, a couple of years ago, actually more than that, some five years ago we started with

28:41.040 --> 28:48.040
the idea that OPM can be very effective in modeling biological systems and collaborating

28:48.040 --> 28:57.040
with Professor Mordechai Hoder from the Faculty of Medicine and Judith Somek who just finished

28:57.040 --> 29:01.040
graduating and has a PhD around this subject.

29:02.040 --> 29:08.040
We have developed conceptual model-based systems biology approach in which we use OPM to model

29:08.040 --> 29:15.040
complex biological systems and what we did in this particular work is to look at a set

29:15.040 --> 29:23.040
of about 40 papers related to the messenger RNA transcription cycle and we modeled it

29:23.040 --> 29:28.040
in a very detailed level.

29:54.040 --> 29:57.040
Excuse me.

29:58.040 --> 30:01.040
Okay.

30:14.040 --> 30:21.040
Oh, maybe I think I, by mistake I clicked, I clicked and I got to,

30:22.040 --> 30:27.040
yeah, this is the link that I get.

30:27.040 --> 30:30.040
Okay, I think I'm okay now.

30:33.040 --> 30:37.040
Actually, click, okay, I know what I need to do.

30:37.040 --> 30:50.040
OK, so in conceptual model-based systems biology, we start with research papers and

30:50.040 --> 30:57.040
papers, and experimental findings that we can find in the literature, which most of all

30:57.040 --> 31:06.120
of it is actually currently online, and we construct a conceptual model which looks something

31:06.120 --> 31:07.120
like this.

31:07.120 --> 31:16.320
This is one of many, could be tens or hundreds of object process diagrams that are interrelated

31:16.320 --> 31:23.240
and have the object which are molecules of various types and sizes and molecular complexes

31:23.240 --> 31:32.960
such as genes and all kinds of hormones, and anything that is involved in these processes.

31:32.960 --> 31:40.120
And because the in silico computational model which represents the experimental knowledge

31:40.120 --> 31:48.640
which is gathered from natural language papers that are available online.

31:48.640 --> 31:53.600
We have the ability, which I haven't mentioned yet, to execute to stimulate the model, so

31:53.600 --> 31:59.760
we don't only look at a static model of objects and processes and relations among them.

31:59.760 --> 32:06.520
We have the ability, and this is a screenshot of the simulation of this particular object

32:06.520 --> 32:07.880
process diagram.

32:07.880 --> 32:14.000
What we see here is that the process called via denulation, the one at the top, is currently

32:14.000 --> 32:22.360
executing and is changing the states, which are the brown ones, of particular objects

32:22.360 --> 32:24.360
from one state to another.

32:24.360 --> 32:30.000
The next process to be executed will be this one and then this one, and then we will move

32:30.000 --> 32:31.000
to another.

32:31.000 --> 32:35.960
On the left you can see some small part of the hierarchy of the object process diagrams

32:35.960 --> 32:38.880
that are part of this system.

32:38.880 --> 32:46.800
And then, having done the simulation, executing the simulation, we can compare the outcomes

32:46.800 --> 32:51.960
of this simulation with the experimental findings that we can find in the literature.

32:51.960 --> 32:58.560
Obviously, there will be knowledge gaps because not everything is known, at least in the system

32:58.560 --> 33:01.040
that we have been working on.

33:01.040 --> 33:07.920
And so by modeling, we stumble upon knowledge gaps that we can at least determine what they

33:07.920 --> 33:08.920
are.

33:08.920 --> 33:16.920
And so we verify that the in-silical computer simulations are compatible with the experimental

33:16.920 --> 33:24.160
results, and when they are not, we define knowledge gaps and what needs to be done in

33:24.160 --> 33:25.960
order to close these gaps.

33:26.560 --> 33:29.480
So this is a research cycle that goes on.

33:29.480 --> 33:37.040
And the next stage is that we add new biological conjecture, one or more.

33:37.040 --> 33:39.600
Maybe one at a time is a better approach.

33:39.600 --> 33:50.840
And so we do some perturbation of the model according to what we think might be the case.

33:50.840 --> 34:03.200
And again, execute the model and check the results experimentally in vivo, in vitro,

34:03.200 --> 34:04.200
wet lab experiments.

34:04.200 --> 34:12.440
This is the part of the biologists in order to verify that the results, according to the

34:12.440 --> 34:18.520
conjecture, really is in line with the findings in the lab.

34:18.520 --> 34:25.360
And so that is a very good indication that our conjecture is indeed true.

34:25.360 --> 34:31.400
In reality, what our experience has been that it is not enough to have just one, it's a

34:31.400 --> 34:37.320
very long iterative process of refining the model further and further in order for it

34:37.320 --> 34:42.440
to meet when executed the biological findings.

34:42.520 --> 34:50.240
So it's an interplay between the in-cylical and the in-vivo, in-vitro experimentation

34:50.240 --> 34:53.680
in order to get them all in sync.

34:53.680 --> 35:00.040
So we evaluate the conjecture, we find knowledge gaps, we design and do new wet lab experiments

35:00.040 --> 35:09.440
and we iterate this until we have all of the facts in line.

35:09.440 --> 35:16.240
And that's what there is another paper that has been accepted, will be published soon,

35:16.240 --> 35:19.640
which is a follow-up on the paper that I showed you.

35:19.640 --> 35:32.320
So as I mentioned already, OPM has since 2009 been in the process of becoming an ISO standard.

35:32.320 --> 35:44.280
So Paris, France in 2009 was the first meeting of the ISO group that in which the study group

35:44.280 --> 35:48.400
was established to explore OPM for modeling standards.

35:48.400 --> 35:57.720
And then there was a meeting in Tokyo and in Florida in 2012 and in Israel in 2012 in

35:57.720 --> 36:05.120
Haifa, Frankfurt, Germany last year and this year, just last month, in Beijing, China,

36:05.120 --> 36:17.080
the resolution was to submit the draft as a PIS, publicly available specification.

36:17.080 --> 36:24.400
And this is a major step toward becoming an ISO standard.

36:24.400 --> 36:30.000
So it's now being voted.

36:30.000 --> 36:43.640
Okay, I have mentioned C-SML as the current standard of OMG and indeed the comparison of

36:43.640 --> 36:48.240
the key features of C-SML and OPM is in order.

36:48.240 --> 36:51.560
So one prominent difference is the number of diagram times.

36:51.800 --> 36:58.000
I already mentioned that OPM has just one kind of diagram, which is object process diagram.

36:58.000 --> 37:01.200
C-SML has nine types of diagrams.

37:01.200 --> 37:06.640
About half of them are structural and the other half is procedural.

37:06.640 --> 37:10.560
C-SML is graphical, so the modality is graphics.

37:10.560 --> 37:17.200
OPM, as I have shown, has graphics and text modalities, so it's bimodal.

37:17.200 --> 37:20.400
The theoretical foundation of C-SML is UML.

37:20.400 --> 37:29.760
In fact, C-SML is defined as a profile of UML with some extensions and OPM is built on

37:29.760 --> 37:35.480
the foundations that I discussed earlier, which is a minimal universal ontology of stateful

37:35.480 --> 37:39.520
objects and processes that transform them.

37:39.520 --> 37:49.160
However, we have felt that it might be valuable to look for synergies and value of combining

37:49.160 --> 37:52.760
OPM and C-SML.

37:52.760 --> 38:03.120
So in a work done and published in 2011 in Systems Engineering Journal, we developed an

38:03.120 --> 38:11.120
algorithm in supporting software to implement conversion or generation of C-SML views of

38:11.120 --> 38:15.920
the different diagram types from the single OPM model.

38:15.920 --> 38:22.720
And we evaluated the results through an experiment with students, 78 students, to test the quality

38:22.720 --> 38:29.640
of the automatically generated diagrams, the C-SML diagrams, and how they impact the comprehension

38:29.640 --> 38:33.720
of the systems that are modeled with them.

38:33.720 --> 38:40.480
So the result, which I will elaborate soon, is that the addition of certain auto-generated

38:40.480 --> 38:48.320
C-SML views to the OPM system model increased the compilation of the system by the students.

38:48.320 --> 38:54.320
There is a challenge of mapping OPM to C-SML because the mapping is one to many.

38:54.480 --> 39:01.160
So as a prominent example, a process in OPM can be mapped in C-SML to a use case, in a

39:01.160 --> 39:06.240
use case diagram to an operation of a block, in a block definition diagram to action in

39:06.240 --> 39:12.400
an activity diagram to state transition trigger or activity inside the state in state machine

39:12.400 --> 39:15.840
diagram or as a message in a sequence diagram.

39:15.840 --> 39:25.120
So all these concepts are actually some variation of a process with nuances and indeed the challenge

39:25.120 --> 39:31.640
is to make this transition to make sense as much as possible.

39:31.640 --> 39:35.240
So we did this and here is a couple of examples.

39:35.240 --> 39:43.400
This is an object process diagram of some level at the ABS braking system, which is in zoomed

39:43.400 --> 39:47.360
and we want to show a use case example.

39:47.360 --> 39:52.240
So this is what we get from the conversion.

39:52.240 --> 40:00.200
Here is the driver, which is here too, and there is an ABS braking use case, which includes

40:00.200 --> 40:04.400
the braking, which you can see here.

40:04.400 --> 40:12.800
Here is an example of converting another object process diagram from the same system

40:12.800 --> 40:15.000
to an activity diagram.

40:15.000 --> 40:16.920
This is the resulting activity diagram.

40:16.920 --> 40:22.960
Again, you can see signal converting is the sub-process here, it is here and signal processing

40:22.960 --> 40:25.080
is here and so on.

40:25.080 --> 40:31.480
Here you have a decision point, which is equivalent to what is happening here.

40:31.480 --> 40:37.360
Next finally, an example of a state machine from another OPD.

40:37.360 --> 40:42.720
We have states of an order, which is ordered, paid and supplied, and you can see here the

40:42.720 --> 40:46.320
order is ordered, paid and supplied.

40:46.320 --> 40:53.600
So this is the focus on states, so obviously it has only states and some processes on the

40:53.600 --> 40:56.320
transitions.

40:56.320 --> 41:02.680
So the evaluation of our experiment with the 78 students, what we examined is the comprehension

41:02.680 --> 41:08.720
of the system modeled in OPM, with and without the addition of the automatically generated

41:08.720 --> 41:14.440
system and diagrams, and we also wanted to find whether there were any errors and inconsistency,

41:14.440 --> 41:21.160
because this was the first time that we used this conversion system.

41:21.160 --> 41:25.880
So we used two systems, divided the students into two groups.

41:25.880 --> 41:32.720
There was a dishwasher system and a city scanner, and you can see how the layout of the experiment

41:32.720 --> 41:33.720
was.

41:33.720 --> 41:43.880
One group got OPM only of the dishwasher and OPM plus system of the city scanner and vice-versa,

41:43.880 --> 41:52.480
and this cancelled any possible biases and learning that might interfere with the results.

41:52.480 --> 41:57.280
We asked them eight comprehension questions, and we also asked them to find errors and

41:57.280 --> 42:01.440
inconsistencies among the different diagrams.

42:01.440 --> 42:07.600
And here you can see the results, which clearly and unambiguously in a significant way show

42:07.600 --> 42:15.320
that there is an improvement between the scores for those who use the OPM only model and those

42:15.320 --> 42:23.400
who got the enhancement with the C-SML model, the C-SML views that were automatically generated

42:23.400 --> 42:25.200
from the OPM.

42:25.200 --> 42:29.480
So no human added information to the C-SML models.

42:30.480 --> 42:39.320
Still you see that there is a very significant improvement in the scores of the students

42:39.320 --> 42:50.800
who had the opportunity or were provided with the C-SML interpretation of the OPM model.

42:50.800 --> 42:59.160
The conversion was good because we didn't find true positive errors or inconsistencies

42:59.160 --> 43:03.680
between the OPM model and the C-SML models.

43:03.680 --> 43:11.480
Moreover, we asked the students to say whether the C-SML diagrams helped them, and indeed

43:11.480 --> 43:19.400
the 74%, 58 of those 78, indicated that it did help them, and we even have a breakdown

43:19.400 --> 43:21.080
by the types of diagrams.

43:21.080 --> 43:28.000
So block definition diagram was the most helpful, 46, 47% and state machine and activity almost

43:28.000 --> 43:33.400
the same because it makes sense because they're really pretty similar and the news case was

43:33.400 --> 43:35.120
the least helpful.

43:35.120 --> 43:44.480
So to summarize the comparison, in this study we have seen that OPM and C-SML take different

43:44.480 --> 43:49.880
approaches in realizing the goal of general purpose system conceptual modeling.

43:49.880 --> 43:57.320
OPM was especially good for idea generation and rapid prototyping at the early architecting

43:57.320 --> 44:03.440
and design stages whereas C-SML is more appropriate when detailed views are required and this

44:03.440 --> 44:08.600
happens usually during later stages of the detailed design.

44:08.600 --> 44:14.000
So we see that each language has benefits and drawbacks and neither is by all means better

44:14.000 --> 44:15.000
than the other.

44:15.000 --> 44:23.240
So there is a large potential for synergy in using both a language in some combination

44:23.240 --> 44:31.680
and this study can give hints or directions as to how this should be done.

44:31.680 --> 44:41.920
Okay, so I'd like to go to the more general summary before we have the Q&A session and

44:41.920 --> 44:49.080
so the takeouts that I would really be happy if you could take with you, first of all,

44:49.080 --> 44:56.480
the stateful objects, processes that transform them and relations among them.

44:56.480 --> 45:03.640
These three things constitute the universal ontology and that means that we can use them

45:03.640 --> 45:11.560
to model systems in a variety of domains, maybe even in any domain.

45:11.560 --> 45:18.080
And OPM uses exactly this ontology and therefore it is fit for modeling complex systems in

45:18.080 --> 45:25.440
a large variety of domains and at any level of complexity.

45:25.440 --> 45:32.000
Also using both graphics and text, the B model presentation appeals to what we call quote

45:32.000 --> 45:34.320
unquote both sides of the brain.

45:34.320 --> 45:43.240
The visual channel and the verbal auditory channel, they complement each other.

45:43.240 --> 45:48.840
Some people are better than others in one and others are better in the other.

45:48.840 --> 45:56.480
So each one can find whatever is best for him and complement with the other modality.

45:56.480 --> 46:03.440
OPM is in the process of becoming ISO standard, it's got a number, 19-450.

46:03.440 --> 46:12.040
CML has been the OMG standard for systems engineering since 2007 and what we saw an indication

46:12.040 --> 46:18.160
of in the experiment is that using OPM in the early system architecting stages and system

46:18.160 --> 46:25.640
L at later stages can in a synergistic manner improve modeling quality and the comprehension

46:25.640 --> 46:35.600
of systems and therefore this is something that should really be looked in very seriously.

46:35.600 --> 46:42.360
Some resources, there is this book with a link to it and there is also a website of

46:42.360 --> 46:50.280
our enterprise systems modeling laboratory where you can find papers, software to download,

46:50.280 --> 46:57.120
presentations, projects and many other things that are related to OPM.

46:57.120 --> 46:58.120
Okay.

46:58.120 --> 47:01.440
Thank you very much.

47:01.440 --> 47:03.720
We have a number of questions here.

47:03.720 --> 47:15.440
The first is two part and it is by Sebastian Herzig and the first part is you mentioned

47:15.440 --> 47:23.120
that stateful objects, processes and relations are sufficient and necessary to describe systems.

47:23.120 --> 47:31.280
Is there a base set of relationships such as some sort of a base vocabulary or are these

47:31.280 --> 47:33.440
very much domain specific?

47:33.440 --> 47:34.440
Okay.

47:34.440 --> 47:35.440
Thank you.

47:35.440 --> 47:36.920
This is an excellent question.

47:36.920 --> 47:44.120
So yes, there is a basic set of what we call fundamental structural relations and procedural

47:44.120 --> 47:45.120
relations.

47:45.120 --> 47:50.520
The structural relations that are deemed fundamental and this is also part of the standard and

47:50.520 --> 47:58.560
is found in the book, aggregation participation or in simpler words, whole part relation.

47:58.560 --> 48:05.400
Then there is a generalization specialization or the either relation as it is perhaps more

48:05.400 --> 48:12.400
known for which is a relation between a general thing and a specific thing that inherits from

48:12.400 --> 48:21.240
it and then there is a classification instantiation relation, the relation between a class of things

48:21.240 --> 48:28.160
which can be an object or a process and instances of that thing and exhibition characterization

48:28.160 --> 48:34.920
relation which is a relation between a thing and its features and features are attributes

48:34.920 --> 48:40.280
and operations that characterize that thing.

48:40.280 --> 48:42.960
So these are structural relations.

48:42.960 --> 48:46.440
We also have a general relation which can be user defined.

48:46.440 --> 48:52.680
As far as procedural relations go, we have as you saw already, we have seen generation

48:52.680 --> 49:01.160
or result link which is the graphical expression of the result relation, the consumption relation

49:01.160 --> 49:05.840
between an object and a process and there is a state transition relation.

49:05.840 --> 49:07.520
These are the main ones.

49:07.520 --> 49:12.640
We have also conditional and event relations but these are more advanced concepts that

49:12.640 --> 49:18.360
I didn't have time to even mention here.

49:18.360 --> 49:26.480
The next question from Sebastian is, can and if so, how are constraints or generally requirements

49:26.480 --> 49:27.880
captured in OPM?

49:27.880 --> 49:28.880
Yes.

49:28.880 --> 49:29.880
Okay.

49:29.880 --> 49:32.040
Again, a very good question.

49:32.040 --> 49:40.720
One of the really nice features about OPM is that using this approach in methodology,

49:40.720 --> 49:48.400
you can start with a requirements model that is not just a bunch of textual requirements

49:48.400 --> 49:56.360
that have number and title and text but you can using either the requirement, textual

49:56.360 --> 50:03.560
requirement document or starting right away by modeling hand with hand or shoulder to

50:03.560 --> 50:12.640
shoulder width between the customer and the provider to have a solution neutral requirements

50:12.640 --> 50:20.120
model of what the system is supposed to be doing and then that will be the basis for

50:20.120 --> 50:28.600
elaborating it by one or more options which will be solution specific and then you can

50:28.600 --> 50:37.200
also compare the alternatives by various means and select the best alternative and continue

50:37.200 --> 50:43.360
with detailed modeling with that alternative.

50:43.360 --> 50:47.960
The next questions are from John Clark.

50:47.960 --> 50:53.480
First is a statement, function and behavior are the same thing.

50:53.480 --> 50:59.720
Second is the Baptist would enter the originating airport and arrive at the destination airport

50:59.720 --> 51:05.960
correct and third, a human body is a non-man-made system.

51:05.960 --> 51:06.960
Right?

51:06.960 --> 51:07.960
Right.

51:07.960 --> 51:08.960
Okay.

51:08.960 --> 51:15.600
So even though the first statement is declared as a statement, I want to argue with it.

51:15.600 --> 51:21.680
I know that many people confuse or mix behavior with function.

51:21.680 --> 51:25.200
Function is and behavior are not exactly the same.

51:25.200 --> 51:32.080
They are similar because most of the time function is associated with behavior but function at

51:32.080 --> 51:39.080
least the way I view it and I define it is something that brings value to some user to

51:39.080 --> 51:45.760
some beneficiary whereas behavior is just a neutral concept of something changes being

51:45.760 --> 51:51.520
generated or consumed and this is how we define the difference between function and behavior.

51:52.280 --> 51:58.920
Indeed, most of the functions entail some behavior of the system but not any behavior

51:58.920 --> 52:00.520
as a functional objective.

52:00.520 --> 52:04.640
So what was the second one?

52:04.640 --> 52:09.240
Okay, there was, sorry, I move on to the next question.

52:09.240 --> 52:15.400
The baggage would enter the originating airport and arrive at the destination airport correct

52:15.400 --> 52:23.920
and then the- Yeah, well, the origin, the objective is to change the state of the location

52:23.920 --> 52:28.520
of the baggage from the origin airport to the destination airport but what we really

52:28.520 --> 52:34.520
are interested here is not just the sunny day scenario but mostly what happens when

52:34.520 --> 52:39.960
things go wrong for some reason and we have a very detailed model of what happens to the

52:39.960 --> 52:45.080
baggage when it is not routed the way it should be.

52:45.080 --> 52:46.080
Sir?

52:46.080 --> 52:50.160
A human body is a non-man-made system, correct?

52:50.160 --> 52:51.160
Correct.

52:51.160 --> 52:52.160
Yeah.

52:52.160 --> 52:53.160
Okay.

52:53.160 --> 52:54.160
The argument about it.

52:54.160 --> 52:55.160
Is that a question or?

52:55.160 --> 52:56.680
Okay, what is the next one?

52:56.680 --> 53:05.080
Okay, from Mark Houllier, how would you handle the time aspect in description of concurrent,

53:05.080 --> 53:08.120
i.e. non-sequential processes?

53:08.120 --> 53:14.640
So as I mentioned, the timeline in an OPM diagram goes from the top of the diagram to

53:14.640 --> 53:21.600
the bottom when you look inside an in-zoom process and so if you want to express two

53:21.600 --> 53:29.760
or more processes or sub-processes that have to start concurrently, you simply draw them

53:29.760 --> 53:35.720
more or less at the same height and the system, the software understands even with some leeway

53:35.720 --> 53:39.160
that they should start concurrently.

53:39.160 --> 53:40.160
Okay.

53:40.160 --> 53:50.320
Next question from John Clark again, OPM is an abstraction of CIS ML, correct?

53:50.320 --> 53:53.800
Not quite.

53:53.800 --> 54:00.320
What I've shown is that OPM has been, first of all, the origins of OPM as I mentioned

54:00.320 --> 54:08.120
in 1993 and the first paper was published in 1995, that is at least a decade or more

54:08.120 --> 54:20.480
before CIS ML or even UML were conceived and an OPM is founded on ontological notions

54:20.480 --> 54:24.920
of stateful objects and processes that transform them.

54:24.920 --> 54:30.720
It comes from a different angle or a train of thought than CIS ML.

54:30.720 --> 54:39.000
CIS ML is the way that CIS ML was conceived is to build upon the achievement of UML as

54:39.000 --> 54:46.320
a software modeling language and tweaking it and converting it into a language that would

54:46.320 --> 54:51.920
be applicable and usable for general systems rather than software systems.

54:51.920 --> 54:56.920
So it's a totally different approach.

54:56.920 --> 54:57.920
Okay.

54:57.920 --> 55:06.480
From Daniel Yao, did you also test the students on CIS ML diagrams with no OPM model?

55:06.480 --> 55:09.840
Oh, that's exactly what my wife told me yesterday.

55:09.840 --> 55:12.840
What they should have done in this experiment.

55:12.840 --> 55:13.840
We didn't do this.

55:13.840 --> 55:17.840
This is something left to be done.

55:17.840 --> 55:19.840
Okay.

55:19.840 --> 55:28.000
From John Clark again, is this ML, is CIS ML helps the understanding of OPM?

55:28.000 --> 55:29.640
Why do we need OPM?

55:29.640 --> 55:31.640
What does OPM add?

55:31.640 --> 55:32.640
Okay.

55:32.640 --> 55:40.680
So OPM, like I said, is very easy to learn, is very easy to understand.

55:40.680 --> 55:46.680
You can start modeling within 30 minutes of being exposed to it.

55:46.680 --> 55:52.720
Whereas in CIS ML and UML, for that matter, you have to really spend a lot of time and

55:52.720 --> 56:01.080
the learning curve is long and much more tedious in order to start being able to produce a

56:01.080 --> 56:02.080
meaningful model.

56:02.080 --> 56:12.520
Moreover, there are very little, if any, guidelines with CIS ML and UML of what diagram to start

56:12.520 --> 56:16.600
with when to move to another type of diagram, when to return to this.

56:16.600 --> 56:20.960
What types of diagram to use for what purposes and how they are interconnected.

56:20.960 --> 56:30.720
It's a much more heavy overload on the modeler's mind to be able to keep, to juggle with the

56:30.720 --> 56:43.240
different types of diagrams and get a clear and intact, complete picture, coherent picture

56:43.240 --> 56:46.560
of the system with these many types of diagrams.

56:46.560 --> 56:50.360
With OPM, it is much easier.

56:50.360 --> 56:58.320
From Lars Olaf Kilstrom, having spent a significant amount of time both using CIS ML as well as

56:58.320 --> 57:04.960
ontology development, I feel that this approach has benefits based on works with ontology.

57:04.960 --> 57:14.480
I was wondering if you have looked at the Ideas Foundation ontology.

57:14.480 --> 57:20.040
The reason for the Ideas question is that several concepts discussed in this presentation

57:20.040 --> 57:22.840
also appear as part of the Ideas Foundation.

57:22.840 --> 57:26.640
I'm not familiar with the Ideas Foundation.

57:26.640 --> 57:30.560
I'll be happy to look at it.

57:30.560 --> 57:37.120
As you indicated, there are synergies or commonalities, and I guess that would be beneficial.

57:37.120 --> 57:41.880
From Jose Luis Fernandez, what about constraints?

57:41.880 --> 57:48.000
How do you deal with something similar to CIS ML parametric diagram?

57:48.000 --> 57:55.240
I didn't have time to mention it, but you can specify quantities and constraints again

57:55.240 --> 58:03.480
by using objects with values, objects which are attributes of other objects or processes

58:03.480 --> 58:12.120
with values, and constrain the behavior such that only if some parameter is within certain

58:12.120 --> 58:15.520
values, a process will happen.

58:15.520 --> 58:23.520
That is all done using objects and stateful objects and processes and links between them.

58:23.520 --> 58:35.040
Is the converter from OPM to CIS ML available in OpCat?

58:35.040 --> 58:39.280
It's a separate module, but we can try to make it available.

58:39.280 --> 58:42.920
Yes, it was part of a research project.

58:42.920 --> 58:46.440
This would be the last question.

58:46.440 --> 58:52.080
There are several more, and I'd like to inform the audience that there will be a follow-up

58:52.160 --> 58:58.640
email with links to the webinar recording and the slides, as well as to Professor Dorey's

58:58.640 --> 59:05.720
email, so you can feel free to contact him directly if you'd like to discuss anything

59:05.720 --> 59:07.800
you've heard here.

59:07.800 --> 59:11.520
The last question is from Oswaldo Arias.

59:11.520 --> 59:16.920
Is the OPM book available in digital format, if so, on which websites?

59:16.920 --> 59:19.360
Thanks for the question.

59:19.360 --> 59:24.360
This particular book, although I asked for it, at that time, a decade ago, it wasn't

59:24.360 --> 59:29.360
very customary, but there is hopefully the next book.

59:29.360 --> 59:30.360
Well, not hopefully.

59:30.360 --> 59:35.360
I know that the next book includes a digital form.

59:35.360 --> 59:38.360
When will that be coming out?

59:38.360 --> 59:40.360
Hopefully in six months.

59:40.360 --> 59:41.360
Excellent.

59:41.360 --> 59:48.360
We'll be happy to send you a link to the website where you can get a digital version after

59:48.360 --> 59:50.360
the book is available.

59:50.360 --> 59:53.360
I'd like to thank everyone for attending.

59:53.360 --> 59:57.360
I'd like to thank Professor Dorey as well.

59:57.360 --> 01:00:04.360
I have to say this has been one of the more popular webinars in terms of questions from

01:00:04.360 --> 01:00:05.360
the audience.

01:00:05.360 --> 01:00:08.360
It's wonderful to see people so engaged.

01:00:08.360 --> 01:00:11.360
Our next webinar will be two weeks from today.

01:00:12.360 --> 01:00:18.360
We have Mona Vernon, an SDM alum who works at Thompson Reuters, who will be speaking.

01:00:18.360 --> 01:00:22.360
The topic will be announced later this week.

01:00:22.360 --> 01:00:27.360
With that, thank you again for attending and thank you again, Professor Dorey.

01:00:27.360 --> 01:00:31.360
Thank you very much for your attention and interest.

01:00:31.360 --> 01:00:34.360
I look forward to interacting with you.

01:00:34.360 --> 01:00:35.360
Bye-bye.

01:00:35.360 --> 01:00:36.360
Thank you.

01:00:41.360 --> 01:00:46.360
I can't get it to stop.

