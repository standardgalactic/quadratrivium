start	end	text
0	8080	start recording. Hello everybody and welcome to the Public Invention Inventors Gathering which
8080	13280	happens the third Thursday of every month. This is July. My name is Robert L. Reed. I'm the president
13280	18320	and founder of Public Invention and today I'm going to be speaking on the topic of the mind-blowing
18320	27440	beauty of computer programming.
35360	37440	Can everybody see my screen?
40320	45680	Yes. Okay, thank you. We have a small audience today so y'all feel free to interrupt me.
46320	51200	I kind of have mixed feelings about this talk because although it's really close to my heart,
51200	57040	I know there's no way I can do justice to it. I could spend a year preparing this talk and I
57040	64800	wouldn't do justice to it. What I'm going to try to explain to you is magic and then even deeper
64800	73120	magic and it's actually very important to me. Computer science is a new art from
74080	80800	really the 1930s. Lady Babbage did a little bit of work before that but it really wasn't until
80800	90240	the 1930s that it became a mathematical art so to speak. That was before the majority of
90240	97200	electronic computers. There were still mechanical computers at that time and although it wasn't
97280	103440	entirely obvious at that time, we now know that computer science sits at the intersection of
103440	110560	physics and math. It also touches upon philosophy and epistemology, the study of what can be known
110560	120160	and in a sense computer science is an extension of what is knowable. Now the fact that computer
120160	128000	science could be considered a branch of physics is really, really deep and relates to things like
128880	135760	astrophysics and quantum mechanics and certain other important aspects of physics.
136640	142960	For a while it was considered sort of an extension of math and it's also that but it has its own
143520	151280	character so it's not really considered exactly math. Unfortunately I have no hope of doing this
151280	157440	talk justice. This is something that's really, really beautiful and I doubt I'm going to be able
157440	165200	to convey it to you in this talk. There are no pretty pictures in this talk except one maybe
165760	171440	and there will be a lot of oversimplifications but I am going to be talking about what I consider to
171440	181520	be magic even deeper magic and joy. So programming and theoretical computer science are different
181520	188720	but the same. To use modern slang theoretical computer science is the god mode version of programming
190080	197840	but programming humble simple programming is the basis of the theoretical computer science
197840	204960	and it's the most general tool ever that's why it's important. Of all the things that humanity
204960	210320	has invented computer programming is not necessarily the most important or the best
210320	217120	but it is the most general. You can use it for almost everything. Today it's needed in all the
217120	224400	sciences all engineering and many arts and therefore I think all young people need to understand
225360	229840	at least a little computer programming in the same way that all people need to understand a little
229840	240160	bit of algebra. So I'd like to ask the question what is a computer? So to me a computer is a
240160	248640	mindless machine that can only do very simple mechanical things. Now technically the word
248640	254160	machine to a mechanical engineer means the application of force I don't mean that. I use
254160	261440	the term to emphasize it has no creativity no slop and each step is completely predictable from the
261440	270240	last. Now it's it's quite an extraordinary fact that a computer can really only do five things
270960	276000	and you could you could organize these a little differently but this is the way I organized it
276000	282320	back when I was 16 years old and I still think it's correct. It can input a number, it can store a
282320	289840	number, it can do arithmetic on numbers, it can output a number and it can make a decision based
289840	297760	on a number. But those numbers can be used to represent a lot of things and on the basis of
297760	307760	these very very simple actions by building them up into an edifice of structure of the way things
307760	323120	are organized we can do extraordinary things. So we can ask what is a program? So a program is a set
323120	330640	or sequence of instructions for a computer which is just a machine which are executed in a particular
330640	338000	order that can change based on what's in storage. This is also sometimes called an algorithm because
338000	344320	it doesn't actually require a computer humanity developed algorithms for mathematics which were
344320	351200	step-by-step procedures before computers existed. Nonetheless the nature of a program is that it's
351280	358160	a set of instructions that are executed in a certain order that tell a computer what to do
358160	368400	in the next step. So the first magic that this produces is that complexity and really quite a
368400	375120	lot of complexity emerges from simplicity with the basic five things that I said even a beginner
375120	380720	programmer can compute the factorial of a number and we're going to see that later on in this talk.
382000	387920	Do an extraordinary thing called Conway's game of life which I'm going to show you a demonstration
387920	395680	of which is kind of the best example of complexity rising up out of simplicity and you can also
395680	403120	simulate a role-playing game that feels real even though it isn't real. You can create a character
403120	410720	you say my fighter takes out his sword and wax the wizard and it feels like the wizard's really
410720	417280	there in your fighting even though you programmed it. You know the wizard in the end is just a set
417280	424400	of numbers and the fighter is just a set of numbers so there's almost no creativity in it.
425040	432000	Now I have never been an educator but when I teach beginning courses in computer programming to
432000	437760	teenagers which I've done a few times these are the three programs that I teach first.
438400	445680	The second aspect of magic that computers allow is that they allow you to simulate physics obviously
445680	453360	via mathematics. Mathematics is the language of physics without mathematics we can only do a little
453360	460880	bit of physics. Now what is it that we do when we talk about physics? Well Leonard Suskin has said
461200	467920	Leonard Suskin has said the purpose of physics is to compute is to predict the future so for
467920	474400	example you predict the future of where a ball is going to fall if you throw it up in the air
475200	480160	you know it's going to come down and if you're a good physicist and you know exactly how fast
480160	487920	you threw it up you know exactly where it's going to land. These sorts of simulations
487920	497120	can be done by a computer and in very important circumstances they succeed when math fails that
497120	505440	is there are situations which we as a human society do not know how to solve with math
507280	513040	very well but we can still solve them with a computer by simulating things over time.
513120	518560	Now there are limits to that so there are problems that a computer can solve
519200	524720	that are hard to solve any other way so the famous three-body problem which is considered to be
525280	531600	unsolvable in math recently there was a Netflix show about it can be solved by a computer
532480	539680	in a limited way it can simulate the position of three stars or planets or meteors in space
540240	547520	orbiting each other over time and it can do that one millisecond at a time
547520	552800	and it can do that for billions of milliseconds and it will be fairly accurate let's say a hundred
552800	559200	years from now. Now some people would say that's not a solution to the problem in the sense that
559200	564560	it's not a formula that you can write down that tells you where the planets are nonetheless it's
565280	570560	better than any other solution that we have in the same way we can't write down a formula
570560	577360	that describes the flow of air around an airplane but we can simulate now there's a great
577360	585920	philosophical debate as to whether an individual neuron can be described mathematically it's
585920	592160	unclear if neurons are actually extraordinarily complex or extraordinarily simple you can find
592160	597600	people who will tell you either either one um but it's possible that we can simulate the action
597600	604000	of neurons and therefore we can simulate the action of brains we can also simulate the action of
604000	610880	waves and biological tissues and that is the reason that we have MRIs CAT scans and PET scans
610880	618080	without those we would not be able to address the diseases that we address that way so the third
618080	623680	magic is something that we're all familiar with you're using it right now you're seeing a picture
623680	631040	of me and you're hearing my voice but inside a computer those are represented as little bitty
631040	637280	numbers which are transmitted through a network and come to your computer and then are translated
637280	643600	back into little blips of light on your screen and voltage levels on your speakers this does not
643680	650400	take a lot of theoretical computer science but most of us enjoy computers because they can
650400	657440	store and transmit representations of light and sound in the form of sounds and movies now coincidentally
658400	663840	they can store every word ever written by human beings which is the basis for large language
663840	671360	models in modern artificial intelligence so we're going to talk a little bit about
671360	675680	programming later but I want to talk about theoretical computer science which I consider
675680	685440	to be deeper magic so the deeper magic number one is that you can prove there are things computers
685440	694160	can't do and can't ever do this is the basis of cryptography we've now proved there are problems
694160	701040	that can't be solved by computers some of the cryptographic problems are simply because we
701040	706080	don't have fast enough computers but there are other problems which can never be solved by any
706080	712880	computer they can never be solved by any sequence of instructions no matter how fast the computer is
714160	722480	and and that's really a mind-boggling sort of concept in my opinion so this leads to a thing
722480	728160	called church's thesis Alonzo church was an american logician who worked in the 30s
728720	736240	um the computation done by modern computers are probably the only kind of computations
736240	743920	that can ever be done now this is called church's thesis because it cannot really be proved um so
743920	754640	it's a thesis rather than a a proof so we have several different models of computation one is
754640	761280	the von Neumann machine which is um very similar to the electronic machines that we have so my
761280	768000	macintosh computer would be closest to a von Neumann machine there's the Turing machine which
768000	772720	has been made famous by movies which was invented a little earlier than the von Neumann machine
773840	779840	our computers today are not shaped like Turing machines uh but they're uh similar and then
779840	786000	there's a very unappreciated form of computation called the lambda calculus and the interesting
786000	793920	thing is that you can simulate each of these computers with the other so the lambda calculus
793920	798800	is powerful enough to simulate a Turing machine a Turing machine can simulate a von Neumann
798800	805680	machine and a von Neumann machine can simulate the lambda calculus so you get uh what can be
805680	812320	described as a trippy loop in that everything is powerful enough to simulate the other so none
812320	820560	can be more powerful than the other now is that the only kind of computation that can exist in the
820560	827840	world well we don't really know but that's very strong evidence that there is no other
827840	835440	form of computation that there is no other way to do it now some people would argue that biological
835520	842160	brains and analog computation are a little asterisk to this and that quantum computing
842160	848880	kind of nibbles at the edges of this a little bit but fundamentally this is accepted by most people
849920	855680	so the deeper magic of theoretical computer science is what i call the dismal deep magic
856400	866880	so it may be that thought and computation are the same it may be that human brains cannot
866880	872640	think anything that can't be thought by a computer and it may be that the sex success
872640	879040	of artificial intelligence proves not that machines are intelligent but that humans are dumb
880000	888800	right it may not be that artificial intelligence is somehow coming alive or getting a soul spark
888800	894560	or having consciousness it may be that that we're learning that our own brains are actually not
894560	901120	capable of very much now i hope that's not the case but uh it's it's certainly an interesting
901120	907120	philosophical point so there's an even deeper magic and there's there's no way i can really
907840	913840	explain it in this uh talk if you don't understand it but there's a problem in computer science
913840	922240	called p is equal to np which is a question is p equal to np p is the set of problems that can
922240	928400	be solved in polynomial time np is the set of problems that can be solved in what's called
928400	933680	nondeterministic polynomial time if you're a beginner there's no way i can explain this in
933680	941600	this talk but uh i want what i want to point out is that p equal np is the most important
941600	947840	problem known to humanity today in movies and so forth you sometimes hear about the remand
947840	956080	hypothesis remand hypothesis is chump change compared to p equal np if humanity could show
956080	962000	that p is equal to np which is not obvious that it is most people think it isn't then the world
962000	967520	would change because in practice we could compute things efficiently which we could never compute
967520	976240	before some things would still remain out of reach however and fundamentally this asks the question
976240	982800	if you can verify something efficiently is there always a way to compute it efficiently
983920	991200	and the answer is not obvious the greatest mathematician computer scientist and even
991200	998320	physicist in the world have been working on this problem for 40 years and uh in fact i would argue
998320	1006560	they haven't actually made very much headway on it now the final really deep magic is information
1006560	1014240	theory information theory is where theoretical computer science overlaps with physics and everything
1014240	1020480	i say here has to be an oversimplification has to be taken with a grain of salt but nonetheless
1021680	1028560	it's very important to understand information theory is closely related to the idea of entropy
1028560	1034320	and that is the laws of thermodynamics and conservation of energy and the fact that
1036080	1044320	the universe in a sense is running down that we're moving towards a less interesting less
1044320	1051360	concentrated state of energy that everything is always smoothing out and becoming more boring
1051360	1058720	so to speak information theory is independent of computers although we didn't know that
1059840	1067600	50 years ago and it applies to many physical processes for example the nyquist limit of
1067600	1075760	the foyer transform but also really fundamental things like how black holes work are related to
1075760	1084000	information theory in a way which i only partially understand i partially understand this so it's
1084000	1092400	kind of true that energy is equal to information and it's kind of true that information is equal
1092400	1100080	to entropy now obviously this is an oversimplification because entropy is not energy entropy is the
1100080	1107600	opposite of energy nonetheless in very special circumstances information is similar to energy
1107600	1115360	and in different circumstances information is similar to entropy so now we can ask the really
1115360	1120400	fundamental question which which i want everyone especially if you're a beginner here to understand
1120480	1128960	and be intrigued by it what does a programmer do i've believed for a long time that the job of a
1128960	1138880	programmer is to create order out of chaos so from uh long before the birth of christ uh there was a
1138880	1146640	famous hymn to Zeus by cliente's and it begins chaos to be his order and in the middle of it in
1146640	1151120	one translation obviously it was written in greek you can say but you know how to make the
1151120	1156400	crooked straight and to bring order to the disorderly even the unloved is loved by you
1157120	1163920	the poet is speaking to Zeus for you have so joined all things into one the good and the bad
1163920	1171280	that they all share in a single unified everlasting reason and of course the christian and judaic
1171280	1177680	bible begins let there be light that's what a programmer does they bring light out of darkness
1177680	1186320	in order out of chaos so fundamentally a program systemizes that which was not
1187200	1196080	systemized previously so the main tool of computer programming is could be called abstraction
1197040	1204320	it's not that easy to understand what it means in this this context programs have subroutines
1204320	1212320	or functions which can be reused the reuse of a subroutine always cost a tiny amount of time
1212320	1220480	and also a tiny amount of electricity but once a subroutine is written it can be used over and
1220480	1230480	over again and it never wears out just like the number 37 never wears out in a sense subroutines
1230480	1236800	and mathematics are stronger than steel and diamonds steel and diamonds and granite
1236800	1244480	eventually wear out but math and subroutines don't abstraction is the main tool for making
1244480	1250240	long programs short and is thus closely connected with bringing order out of chaos
1251120	1256880	factorial the first program that programmers should learn teaches abstraction through recursion
1257600	1263920	now there's a thing called lambda lifting that i recommend um an interested student
1263920	1271280	read the wikipedia article on lambda lifting which is sort of the formal way in which abstraction
1271280	1277760	enters computer programming but most programmers will will not understand lambda lifting they
1277760	1286240	will instead think of when i create a subroutine i am creating abstraction which i can reuse again
1286240	1295040	and again so my own personal style of programming is based on something that paul graham said he
1295040	1301760	wrote an essay called concision is power and i view the act of programming as being almost
1301760	1308160	their exceptions the same as trying to create the shortest most compact representation of something
1308800	1315360	and thus in a way creating the most abstract version of a sequence of instructions to accomplish
1315360	1322960	something now functional programming is a style in which subroutines are side effect free this
1322960	1328560	helps to bring order out of chaos because of something technical called referential transparency
1329200	1334960	and it's the most abstract way of working because it means that a function can be used in any
1334960	1341200	context and always means the same thing now this is debatable we don't have time to go into it uh
1341200	1348160	some people don't like functional programming as much as i do another way of expressing this is
1348160	1358320	a principle called dry or do not repeat yourself in a computer program there should never really be
1359440	1366080	two lines that are the same there should never be two subroutines that are the same if you find
1366080	1373920	yourself writing the same code it should become a subroutine and this principle can be applied to
1373920	1380560	enormous aspects of computer programming you should not have duplication in your data just as
1380560	1388800	you should not have duplication in your instructions and in many many circumstances what people do is
1388800	1394320	they copy and paste code from somewhere and in so doing they're violating the dry principle
1394320	1401440	and after years programs become big fluffy disorderly things where things are almost the
1401440	1406960	same but not quite in different places and so forth and that's very poor software engineering
1408400	1415680	but it takes beginners years to fully understand this and to fully understand how to avoid it
1417440	1422880	so now i'd like to talk about the very first program that i think everyone should write
1423920	1429840	the first program is called factorial and it's written with an exclamation point
1430720	1436800	when i was in in college there was a young man who didn't know was called factorial so when he saw
1436800	1444160	in factorial he said called it in as if as if it's very emphatically the way you you say in
1445200	1454400	in fact in bang sometimes pronounced bang or in factorial or in exclamation point
1455280	1463760	is used in the famous formula from probability that's sometimes pronounced in choose k it gives
1463760	1471120	you the ways to choose k element the number of ways to choose k elements from a set of in objects
1471120	1478320	this is all important to poker players and all kinds of probability and all kinds of
1478400	1484960	mathematics but the definition of factorial itself is really really simple and this is it
1486720	1491920	right here this is actually in javascript we could take this and we could run it okay now
1492960	1501360	um i learned this so long ago it no longer seems weird to me but some of you reading it
1502240	1507600	may not have learned this and i remember how hard it was for me to understand when i was about
1508400	1515680	18 or 19 and i was first introduced to this this concept so what this code says is that
1515680	1524000	the function that we call factorial which is in bang so to speak has a mathematical definition
1524640	1535520	if n is equal to zero the answer is one if n is not equal to zero the answer is in times
1535520	1548240	the factorial of n minus one now this is a trippy loop factorial is being defined in
1548960	1556080	terms of itself how can the computer know what factorial means when we're telling it what factorial
1556080	1564080	means right now it's not obvious now to many people in this audience it may be obvious but
1564080	1570480	when i was a boy this was not obvious to me okay you you might ask the question well how on earth
1570480	1578400	can the computer ever know how to do factorial of n minus one when we're defining it in terms of
1578400	1585760	itself it looks like a trick okay and it takes a while to understand it and in fact the answer is
1586400	1593760	this only works if you call factorial with a smaller number in the body of the function
1594720	1600320	so that the problem is always somehow getting simpler and eventually it gets down to zero
1600320	1607280	if that is not true you create an infinite loop infinite loops are much worse than trippy loops
1608080	1613920	so in fact you could say that this function has a bug if you called this was minus one
1614640	1620320	it would run forever because it would multiply minus one by the factorial of minus two
1621120	1626880	which would be minus two times the factorial of minus three which would be minus three times
1626880	1632720	the factorial of minus four and that number would never become equal to zero and it would never stop
1633680	1644400	the second program is a program called conways game of life and it was specifically designed
1644960	1655760	to show how complexity arises out of simplicity okay and it at one kind of artificial level
1655760	1662560	it's a simulation of biological processes these four rules are the only rules it has
1663120	1666960	and I believe this is the second computer program which every beginner should write
1667840	1674480	okay it's played on a grid like a chessboard but the chessboard is considered not to be eight
1674480	1680400	by eight but to extend as far as you want it to so it's played on a square grid and each grid is called
1680480	1686640	grid cell square is called a cell okay and a cell is either live or dead
1687760	1693600	and there's a clock that ticks and one generation leads to the next generation
1693600	1699520	so you start with some pattern and then you start generations and the rule for each cell
1699520	1707840	is simply these four rules in a live cell with fewer than two live neighbors that's the cells
1708320	1715840	the eight cells around it that touch it dies as if by underpopulation I prefer to think of it as
1715840	1722320	loneliness it dies of loneliness any live cell with two or three live neighbors lives on to the
1722320	1730880	next generation it's happy any live cell with more than three live neighbors dies by overpopulation
1730880	1738960	or crowding and then here is a bit of magic any dead cell with exactly three live neighbors
1738960	1750800	becomes a live cell as if by reproduction okay simple rules that produce almost unbounded complexity
1751360	1759440	so now I'd like to show you an example of this is Conway's game of life you guys can do this
1759440	1764320	I'm randomly putting this here I don't know what I'm doing I'm just clicking on some numbers so
1764320	1774320	you see this consists of a grid of squares and each square is considered a cell yellow means it's alive
1777280	1782320	gray means it's dead now when I click next it's going to do a generation
1782960	1791200	so some cells will died and a few cells came into existence and the pattern changed
1792000	1800880	and now the pattern is going to change again and again and again and again and now I can simply
1800880	1803120	start running it and we'll see what happens
1813280	1816400	not done yet
1818240	1824880	it's not done yet it's not done yet it's not done yet now it's done
1827920	1837040	so how could that complexity that you just saw arise out of those four rules
1838000	1845280	that is the thing which is of sort of paramount importance to mathematicians and related to
1845280	1858400	what I'm talking about the the Iraq the ability of simplicity to give birth to complexity okay and
1858400	1864400	then finally an exercise that I think all beginning computer programmers should do is to write a very
1864640	1872800	simple sort of fantasy role-playing game that has characters in it and you can have the characters
1872800	1878800	fight like you do in Dungeons and Dragons so that a fighter can whip out a sword and say I attack
1878800	1883840	the wizard and I strike the wizard with my sword and the wizard's health goes down and then the
1883840	1892080	health the wizard cast a magic spell uh perhaps to catch the um fighter in a web which decreases
1892080	1899200	their ability to strike in the future now um the thing about this is you play it it's simple
1900400	1911120	it's fun and it feels alive but you programmed it you know very well the wizard is not alive the
1911120	1918880	wizard is just a subroutine the wizard is literally 10 or 15 lines of code that you yourself programmed
1919680	1926320	representing only with numbers now if you don't want to do that you can think of a
1926320	1931360	complicated game uh an expensive game like Minecraft or something like that accomplishing
1931360	1940960	the same thing it feels real even though we know in the end it is nothing more than a complicated
1940960	1950720	series of the five operations I began this talk with so programming is almost reason
1952480	1959280	but not quite it is almost human reason but it isn't exactly programming does not tell the poet
1959280	1965120	what word to select or the musician how to play the note perfectly or the painter how the brush
1965120	1971200	stroke should go but nonetheless the act of programming is very close to the act of human
1971200	1979680	reasoning for 100 years coming up on 100 years now literally we've been making programming tools
1979680	1987440	more powerful so for example john von Neumann did not believe in compilers he believed it was a
1987440	1993040	sign of mental weakness if people had to use compiled computer languages he thought you should
1993040	2000400	program them sort of only with the the most minimal set of instructions um he was weird
2002240	2008880	each increase in the strength of the programming tools has not made programming obsolete it has
2008880	2015280	not decreased the number of people making gainful living by being programmer it has made programming
2015280	2022000	more important and given gainful employment to more people so I personally do not believe anyone
2022000	2028160	should fear that AI will replace programming that it's the same as saying AI will replace human
2028160	2037200	reasoning AI will become a tool used by programmers now I have not used it I don't use co-pilot or
2037200	2043760	any AI tools for that but at some point I may have to learn how to do that on the other hand I do
2043760	2050960	think we should fear killer robots I'm much more worried about killer robots than I am uh my ability
2050960	2059760	to think being replaced by an artificial intelligence so there are a lot of joys associated with
2059760	2067440	computer programming and um I got to experience these when I was a child almost I started programming
2067440	2072400	when I was 13 not very well it took me a long time to learn a lot I didn't have anyone to learn from
2072960	2078560	um I wish every child could experience this joy I wish everyone could it could do these
2079280	2083280	now there are other ways to learn these joys but computer programming is a darn good way to
2083840	2089680	to do it as Lee and Nardo Da Vinci said the joy of understanding is one of the greatest pleasures
2089680	2100480	that humanity can have and computer programming is all about understanding often you begin in
2100480	2107040	confusion and you move towards understanding because you bring order out of chaos you bring
2107040	2115120	light out of darkness you start from a situation of not understanding a problem and then you understand
2115120	2121920	it there's the joy of discovery which I think is quite different that's where you learn something
2121920	2128960	surprising um sometimes you discover surprising problems sometimes you discover surprising
2128960	2135680	solutions sometimes like in the case of Conway's game of life you discover surprising things which
2135680	2139920	are neither problems nor solutions they're just surprising things about the mathematical world
2139920	2147840	in which we live and then perhaps the greatest joy is the joy of creation you can write a program
2147840	2153920	you can create something out of nothing which did not exist before and something important
2153920	2161040	as well of course you can do that by knitting a sweater but one form of creation is writing a
2161040	2168800	computer program and then you can experience the joy of mastery the joy of moving from a state of
2168800	2174880	not being very good at something to being pretty good at it um I do not consider myself to have
2174880	2182080	mastered computer programming uh I'm still learning I I wish I had time to learn more I I'm
2182080	2189360	considering myself a journeyman programmer so to speak um my one of my heroes Kent Beck said
2189360	2195440	that confusion should be cherished because it precedes enlightenment and computer program
2195440	2201760	it is all about moving from a state of confusion to a state of enlightenment and then finally
2201760	2204720	there's the joy of sharing um
2209680	2215840	in a way there are not many programs in the world there is only one universal program
2216560	2221840	it is splintered between my computer and Lawrence's computer and Christina's computer
2221840	2228160	and Morena's computer but in a way there's really only one computer program in the whole world and
2228160	2234400	we are all writing parts of it we are writing little bitty parts of it so we are all sharing
2234400	2240880	in a given enterprise for many people a great joy that they get to experience in college
2240880	2247520	and I and I wish everyone got to go to college I know some people don't is to um share their
2247520	2253360	programs with other people sometimes in a classroom setting sometimes not I remember uh one time I
2253360	2257600	was in a graphics class at the University of Texas when I was in graduate school and my friend
2257600	2264320	Steve Benz uh put up on his screen a graphic programming and he programmed a little airplane
2264320	2271520	to fly around the tower of a representation of a tower of an airport and it was it was an
2271520	2278080	astonishing thing to to have accomplished quite quite beautiful uh I really enjoyed that when I
2278080	2286240	was at Rice University uh there was there was a student there uh who was quite unusual and I would
2286240	2292800	walk by his terminal and on it there was a weird glyph and I couldn't figure out what it was so
2292800	2300400	you know I asked the guy and he said well it's elvish he had created an ascii art representation
2300400	2307040	of the letter the elvish characters that Tolkien had created which are called tingwar um an example
2307040	2315040	of nerdy stuff uh but it was more fun because it was shared and then finally and my talk is closing
2315040	2323520	now um there's the joy of meaning and this is the deepest thing to me public convention gives
2323520	2329440	everything it does to the whole world we don't keep anything secret everything we do is shared
2329440	2336880	through open source licensing uh we've been trying to save people's lives for a while now
2336880	2343040	through global medical stuff I doubt anyone's life has ever been saved by one of our inventions
2343040	2350160	although it is our goal and we're working towards it things take time to ripen uh I I have faith that
2350160	2357440	it will eventually happening programming is an important part of our work almost everything
2357440	2362800	now requires computer programming programming is part of our work and our work is meaningful
2363360	2368240	and therefore the programming of meaning so thank you for your support of public
2368320	2375360	convention thank you for listening I've got a few references here which people can look up
2377280	2382560	on google if they want and I will now open the floor to questions
2389360	2393440	well I should have been here at 8 and for some reason I thought it started at 8 30
2393440	2398080	oh okay Victoria Christina's raised your hand go ahead Christina
2399360	2406560	that was an excellent presentation um I've never actually kind of thought about that all laid out
2406560	2411120	in such a way uh I feel like it's it's one of those programming in general is one of those
2411120	2415600	things that I've I've been around for a long time and have a very very very tiny bit of
2415600	2422000	experience with myself but if you're around it so much you often don't necessarily think of the
2422000	2427840	origins of it um but I did have a question that came up and it's something that I never
2428560	2435920	thought of much myself um and it's I love the slide on factorials by the way so in calculating
2436480	2445360	um factorials you the two things that come to mind are recursive function versus iterative
2445360	2452240	so I was wondering if um like from a programming standpoint like different characteristics or
2452240	2458720	use cases specific to either using a recursive or iterative approach um in programming
2461680	2468720	yeah it's a good it's a good question it's a really good question because um in fact
2469600	2478560	you can prove in a sense that you you don't have to do this recursively so what Christina's
2478560	2485040	saying is this self-reference the fact that factorial is defined in terms of factorial is called
2485520	2494720	um recursion you could write um factorial as what's called a loop and you would count down
2495280	2502000	and you would examine the value in and you you would count across in and and and do it that way
2502720	2514320	um so you don't have to do it this way except there are things over time which become so
2514320	2522480	complicated it would be almost impossible to do all of them um iteratively for example you could
2522480	2528720	be working on a solving a differential equation you know or some very very big thing and you're in
2528720	2534640	the middle of it and you're down in the middle of a computation and now you have to do another
2534640	2543920	factorial right you you have to have subroutines and you have to have abstraction in um in doing
2543920	2552560	those things and there there are some things which um in order to not define them recursively
2552560	2558480	you would almost have to stand on your head like like you could do it there's a mathematical proof
2558480	2564960	that you don't have to have this because after all this programming language is being compiled
2564960	2570960	into something which is just a set of numbers which is doing the same thing but it would become
2571040	2578400	unnatural it would become so complicated that you almost couldn't think about it and it would get in
2578400	2586400	the way of your thinking about it and and a proof of that is the formula on the right hand side of
2586400	2595120	this page right here we have n bang and it's expressed in terms of k bang and n minus k bang
2595120	2604880	mathematicians are using this you know using this sort of thing uh referentially as a subroutine in
2604880	2610960	the same way and if you go to the wikipedia page you will see it defined both iteratively and
2610960	2619520	recursively i don't know if that answers your question or not yes it does um and kind of as a
2619520	2627360	follow-up to that i don't want to i don't want to hog all the question time but um are there so
2627360	2634960	from a computer programming standpoint are there more resource constraints with one versus the other
2634960	2641760	so if so taking an iterative approach versus recursive like what does that what does it mean
2641760	2650640	for the programmer when you're coming to choose between the two okay so there are people who will
2650640	2663920	tell you that an iterative approach is more efficient because a um recursive approach appears on the
2663920	2673200	surface to use more memory okay and so there are times when an iterative approach would be better
2673840	2679920	and let me let me return to this and try to explain this in the in the deepest possible way
2679920	2688640	okay so for example the way this is implemented in a computer in a in as the languages compile
2689360	2696800	it's turned from this representation into a different representation and you almost can't
2696800	2703920	discuss it without talking about what's called a stack frame and whenever you make a call you push
2703920	2710960	onto the stack which is called because it's like a cafeteria tray uh in a cafeteria you know you have
2710960	2717200	a spring-loaded stack of trays sometimes you you push things onto the stack and you and you build
2717280	2724000	things up and then you take things off the stack okay you push the variables here onto this the
2724000	2733920	stack well however many calls you make uh each one of those has to have a memory representation
2734720	2743920	you can run out of memory okay now you can do it it appears on the surface that you can do it more
2743920	2752480	efficiently iteratively because you wouldn't have that extra space however this program the way it's
2752480	2759840	written is what's called tail recursive in the sense that the the use of factorial is the last
2759840	2767120	thing in what's being done here so the compiler knows that and can automatically implement an
2767120	2777520	efficient way of doing it so in practice it doesn't matter okay now another way that i if i wanted to
2777520	2784000	i could attack what you're saying is i could say yes it might be more efficient in terms of computer
2784000	2793520	instructions but computer instructions are cheap what's hard is the clarity of the program to make
2793520	2800720	it in an ordered fashion and so i would be very low to write it in a more efficient way
2800720	2805360	if it decreased the clarity of the program from a human understanding point of view
2805360	2808320	there's another saying in computer science which is that
2812640	2817440	premature optimization is the root of all evil that was that's famously said by
2817600	2825040	Donald Knuth a very important computer scientist so let me let me just show you here what happens
2826560	2833760	so over here on the right this is actually a the development tools which are built into
2833760	2842480	the chrome browser and it runs javascript and so i can paste this pro oops i could paste this program
2842480	2853040	in here but it's apparently please type allow posting in here so it's got a nice security feature
2853040	2863760	won't let me post it in oh allow pasting okay that
2866880	2869200	well i'll do it the old-fashioned way i'll type it
2872480	2880640	so i already typed this in okay so this is javascript this is completely legal javascript
2881360	2892480	okay and i can call factorial of zero and it's one and i can call factorial of 10 and it'll be a big
2892480	2900880	number and i can call factorial of 20 and i can call factorial
2906240	2913200	let's say 100 this may not work okay and it kind of works and it's a very very very very large
2913200	2923280	number right um now eventually we'll run out there's a bug in this program in a sense factorial is
2923280	2929440	not actually defined on negative numbers but if i run this on a negative number as i said before
2930240	2934640	it will go into an infinite loop so we're going to see what happens when it does that
2935600	2945440	so what it actually says is maximum call stacked size exceeded what it did is it kept going until
2945440	2952000	it ran out of its own memory now it's smart so before it crashed my computer it caught it
2952560	2955280	and it said oh i'm not going to let you make that call again
2955280	2966240	that may be more than you wanted to know about that no no and then sorry so one last thing
2966240	2973040	would be so would you say that recursion then is more suitable for problems that could be broken
2973040	2978160	down into similar sub problems and the thing that first comes to mind for me is like some
2978160	2984720	of the sorting algorithms whereas when i think of iteration i think of more suitable program uses for
2985360	2991280	problems that would require repeated execution of a block code linear searches things like that
2991920	2998880	yes okay so i would say yes and the best example of that if you want to google it right now is um
2998880	3008000	google quicksort okay quicksort is a very simple um program here let me create a new slide um it's
3008000	3013680	not necessarily the best the best sort in the world but it's it's extraordinarily simple and
3013760	3018400	that's why it's done it was created by another famous computer scientist i had the pleasure of
3018400	3027280	meeting uh Charles anthony robert pour who for some reason was called tony uh so more created
3027280	3033680	quicksort and quicksort looks like this and i can't this is not going to be correct JavaScript
3034320	3037520	quicksort of and i'll call it s is a sequence
3038480	3050400	okay and what i do is i is i'll say let a be first half of s that is the first if s has 100
3050400	3056480	members to be the first 50 okay and exactly how i'd do that i would depend on the exact language
3056480	3069200	i'm in but let you know let b be the second half of s okay um uh now i'm forgetting it okay and so
3069200	3081200	then what you do is you do a quicksort of a and then you do a quicksort of b so that those two are
3081280	3091760	sorted and that that gives you back two list of 50 numbers which are each sorted and then
3091760	3097040	you you merge them very simply and i maybe i'm forgetting because that would be called a merge
3097040	3104240	sort instead of instead of a quicksort i think maybe quicksort finds the median uh value and
3104240	3108720	takes all the lower ones and then all the upper ones and it sorts those two and then merges it
3108720	3114720	back but it's fundamentally recursive in the way that you just described because you're taking a
3114720	3120960	list of 100 elements breaking it into two list of 50 sorting the two list of 50 and then doing
3120960	3130720	something very simple to put it back together now it can be done iteratively as well but it
3131680	3137600	is probably harder to understand it than by doing it recursively so why do it
3139680	3145120	that makes sense that's really cool so i i don't know you know a lot of applications i you know
3145120	3152000	because i don't don't do computer programming but i do know that a lot of what's behind some of these
3152000	3157760	companies that are doing really extensive gene analysis so analyzing genetic combinations
3157760	3163760	and permutations they're using programs with a lot of factorial calculations involved so that's
3163760	3168720	how they're discovering like different gene combinations correlate with certain syndromes or
3170080	3176000	you know genetic mutations that's that's like the the first real-world case that comes from my mind
3177200	3184800	well right okay so so here's something mind-blowing even the act of so to us the act of multiplying
3184800	3191680	two numbers is simple and in java script it's simple you just write a star b and that multiplies
3191680	3198720	two numbers together okay but as a becomes gigantic and b becomes gigantic it starts to be
3198720	3206720	inefficient to multiply it the way humans multiply numbers okay of course you would never think of
3206720	3212320	worrying about this until it's more than like a thousand digits on each side but the numbers you
3212320	3218480	deal with in genomic combinations can can get really big there's an entire science of computer
3218480	3224160	science that deals with asymptotic complexity where you try to create the most efficient algorithms
3224160	3232080	you can i do not fully understand this but the most efficient way to multiply numbers is actually
3232080	3240000	with the Fourier transform okay so that algorithm for multiplying very very very very large numbers
3240000	3248400	is quite unnatural compared to what we as school children learn to do in our multiplication
3248400	3253680	and if you were trying to compute factorial you might do the same thing and you might use
3253680	3258880	approximations and then there are all kinds of all kinds of tricks to make that go faster and
3258880	3267360	there's an entire science behind that which is usually not done usually computer programmers
3267360	3278320	don't worry about that until they're at least out of college
3287920	3294400	oh do we have any other questions i'll let other people ask questions otherwise we will be here
3294400	3299920	all night with me being like what about this what about that i am always at your service christina
3300960	3304800	all right i'm sure others have have questions so i'll i will let others ask them
3315600	3319600	another thing i learned in graduate school is that silence is golden
3320320	3324800	and often if you just wait long enough people will ask a question even though they're shy
3332080	3334400	i don't really have a question but i did you have a comment though
3335840	3340480	in your description of one of the things i think that i think is kind of overlooked
3341200	3348400	is the root word of analog computing is i think it's shared with analogy and i like thinking of
3348640	3356000	computing as an analogy that is running on base level physics or basic level reality
3356800	3363840	and that that level of and what we're basically doing is creating a story that is playing out
3363840	3370480	in front of us in the world around us and the story is and we we are consistent with our story
3370480	3378000	and the consistency of our story reinforces our understanding and in our logic in a way that
3378000	3383280	gives us belief in understanding of the things that we're doing and the answers that we're getting
3384640	3392640	it's a little poetic but the but it allows you to start thinking that like water can be used in
3392640	3399920	computing gravity can be used in computing mechanical structures can be used in computing
3399920	3405200	DNA can be used in computing like computing is all around us and it's it's really the the
3405200	3410960	analogy the stories that we use to construct um and the mathematical themes and theories behind
3410960	3416640	this those those properties that kind of really make it happen so
3423520	3425680	yeah that's all true
3426400	3427280	um
3431200	3441840	you can make a computer out of pneumatic vows or water vows and people did before electronics
3441840	3451440	were available but the computing that is all around us doesn't do what i would call general
3451520	3462480	purpose computing in general physical properties tend to be smooth and continuous and in that sense
3462480	3469120	they're a very limited form of computation for example a slide rule or a caliper you can be
3469120	3476160	used to multiply numbers but only in it only in a very very limited way making a turing machine
3476160	3481680	or a turing complete machine or von Neumann machine or land to calculate machine out of a
3481680	3491280	slide rule would be very hard um and so the electronic computer and the the attempts to
3491280	3503120	make mechanical computers which famously Lady Ada Babbage did um created a new era of uh computation
3506320	3513040	i agree with that there's there's still a open question of can you build an
3513040	3519840	a general purpose analog computer um and then the the corollary v can you build a general
3519840	3527280	purpose uh neural network um with the drill with the neural fabric um and which is currently a very
3527280	3535840	hot topic right now in AI research um i agree but that question is bigger than i can address
3536160	3546080	in this talk one thing i think it's under appreciated i would also want to bring up
3546080	3552000	is that um the advances in computing that we're currently seeing have allowed us to tackle
3552720	3560320	problems that were previously on we were unable to really address um i think that's i think that's
3560320	3568960	going to open up new areas in biology in physics and in uh and i'm just any of like the the big
3568960	3574160	the bigger world out there and the small world out there so i think that's i think it's under
3574160	3581600	appreciated because um ten years ago we couldn't model um with the fidelity that we had uh that
3581600	3586160	we can today with a number of variables and the number of um factors
3589120	3591440	yep that's correct
3595040	3596560	does anyone else have a comment
3603120	3609040	um i just i think it's really cool to think about and uh lauren says first comment made me think of
3609040	3614880	this it's really cool to think about the fact that all of these well most of these equations or
3614880	3621120	calculations that are you know given examples here they have been around since ancient times like
3621120	3629360	these were you know the the end notation wasn't really developed until later but the the like
3629360	3638480	core idea can be traced back to you know we're talking like you know bc yeah and it's how how
3638480	3646400	we've kind of evolved the use cases of these equations to for computational purposes so instead
3646400	3652720	of us using these equations ourselves we have machines now that do it for us um but a lot of the
3652720	3661680	earlier uses of them were just you know obviously we think of like physics and astronomy um but even
3661680	3668480	before then it was kind of just this almost like pondering of what if so what if i take
3668480	3675200	these numbers and do this what happens um so these very very ancient ancient calculations that
3675840	3681200	are very much a part of our modern life in a big way we wouldn't we wouldn't have modern life today
3681200	3689760	without them yes i mean just just think of how humanity's power was expanded by the development
3689760	3699040	of those mathematical algorithms before there were computers right i mean you know before that you
3699040	3707920	had uh questions that that we would think well that's a computable answerable question and people
3707920	3714320	might not know how to answer the question right they might not know how what's the area of a sphere
3714960	3720560	right they might not know what's the area of a cone they might not know that if you have a right
3720560	3726480	triangle the square of the length of the hypotenuse is equal to the sum of squares of the two sides
3726480	3731680	although that's been known for a long time presumably there was some time in the past when
3731680	3740640	it wasn't known right um and so that gets back to my point computer programming is a form of
3740640	3751280	mathematics that brings order out of chaos and it it expands our power and to me the computer
3751280	3757440	is an extension of the human brain it's not a replacement it's an exo brain if you will just
3757440	3766960	the way tony stark's iron suit is a exoskeleton wikipedia is a part of my exo brain and i can
3766960	3773200	use a computer to perform calculations which would be very awkward or impossible for me to
3773200	3785920	perform in in other circumstances um so um in a very real sense it's in it both the act of
3785920	3792800	systematizing things which weren't systematic before extends human power and the electronic
3792880	3798640	computer which can do these things very rapidly also extends human power
3811840	3813680	do we have any other questions or comments
3815600	3818480	fast what's your favorite equation
3818480	3825200	me yes favorite equation and why
3835120	3843600	well um force equal mass times acceleration because it's a um it's a it's a second order
3843680	3850720	differential equation which happens to be easily solvable and from which we can derive
3852160	3854240	an extraordinary number of effects
3864720	3870880	i have another question maybe more um kind of philosophical you started with a definition
3870880	3879680	of what a computer is and kind of explaining it can only basically input and output numbers but with
3880800	3888720	programming and now um AI or machine learning is there are we getting to the point where
3889520	3896160	basically these programs or these computers can think much faster than we do i know they can
3896160	3902000	solve equations but are is it getting to the point where they can quote unquote learn faster than us
3902000	3908640	and how do we keep up the understanding of like you're saying a computer can only do something
3908640	3918560	that's traceable um is there a point where maybe like in comparative to to our human reasoning
3919520	3927440	um is there a point where we're too slow to kind of understand um these programs and machines
3929120	3934880	well it's a really good question let me give you the answer that pro AI people give and then
3934880	3943120	i'll tell you what i think okay pro AI people point out that although large language of models
3943120	3949680	which is one aspect of artificial intelligence are relatively in their infancy they already
3950320	3960480	beat human beings at standardized tests such as the graduate G the GRE and SAT and the ACT and
3960480	3967360	they can do well on tests of biology and physics and so as my friend David Jesky has pointed out
3968320	3974160	every time humanity has said well computers aren't really intelligent because they can't play chess
3974160	3982080	or they can't play go or they can't um write poetry uh you know those have all fallen right like
3982080	3988160	they didn't they do those things right and um curmudgeons like me keep saying oh well they
3988160	3992560	aren't really intelligent even though they can answer a bunch of questions that i can't possibly
3992560	3999600	answer okay but then i'll tell you what i think um just because it's i think the honesty is worthwhile
3999600	4008160	i mean sure an AI could beat me at a biology test but an AI has had an infinite amount of time to
4008160	4019200	learn and to it it's an open book test and AI can't compete with me at all in any real problem
4019200	4026400	that it hasn't had a bajillion cycles of 50 gigawatts of power to study ahead of time
4027360	4031760	yeah you know um so
4034960	4045680	i don't accept artificial intelligence as thinking and being able to learn things at all
4046000	4053120	now obviously you can build a classifier right like you could classify leaves and it'll tell
4053120	4058080	you what kind of tree it came from better than i can personally remember the shape of leaves
4058080	4066400	you know to do it it would beat me at that task right um it would beat me at translating french
4066400	4074880	into english but it doesn't beat me at understanding even though it can translate french into english
4075120	4077120	better than i can
4080080	4089280	i think the question comes down to what is what does it mean to be humans creativity
4089840	4092080	you know novel ideas i guess
4092400	4106160	yeah i'm i'm you know i can't claim to be more creative than an AI
4108560	4115520	but still i i feel that all human beings have something in them which i have not yet seen in an
4115520	4123120	AI maybe five years from now the little child that is artificial intelligence will have grown
4123120	4133200	into something um worthy of respect you know uh and then are we gonna say switching the machine
4133200	4144720	off as murder you know did we kill an AI when you know the power failed i i don't know i
4145680	4156240	but at the moment i remain skeptical of these these things
4156480	4156960	you
4173120	4181760	thanks for your perspective and the talk is very uh interesting and informative you're welcome any other questions
4186720	4187220	you
4196880	4201760	okay here in none i think we'll stop the recording here
