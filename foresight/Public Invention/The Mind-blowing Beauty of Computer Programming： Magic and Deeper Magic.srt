1
00:00:00,000 --> 00:00:08,080
start recording. Hello everybody and welcome to the Public Invention Inventors Gathering which

2
00:00:08,080 --> 00:00:13,280
happens the third Thursday of every month. This is July. My name is Robert L. Reed. I'm the president

3
00:00:13,280 --> 00:00:18,320
and founder of Public Invention and today I'm going to be speaking on the topic of the mind-blowing

4
00:00:18,320 --> 00:00:27,440
beauty of computer programming.

5
00:00:35,360 --> 00:00:37,440
Can everybody see my screen?

6
00:00:40,320 --> 00:00:45,680
Yes. Okay, thank you. We have a small audience today so y'all feel free to interrupt me.

7
00:00:46,320 --> 00:00:51,200
I kind of have mixed feelings about this talk because although it's really close to my heart,

8
00:00:51,200 --> 00:00:57,040
I know there's no way I can do justice to it. I could spend a year preparing this talk and I

9
00:00:57,040 --> 00:01:04,800
wouldn't do justice to it. What I'm going to try to explain to you is magic and then even deeper

10
00:01:04,800 --> 00:01:13,120
magic and it's actually very important to me. Computer science is a new art from

11
00:01:14,080 --> 00:01:20,800
really the 1930s. Lady Babbage did a little bit of work before that but it really wasn't until

12
00:01:20,800 --> 00:01:30,240
the 1930s that it became a mathematical art so to speak. That was before the majority of

13
00:01:30,240 --> 00:01:37,200
electronic computers. There were still mechanical computers at that time and although it wasn't

14
00:01:37,280 --> 00:01:43,440
entirely obvious at that time, we now know that computer science sits at the intersection of

15
00:01:43,440 --> 00:01:50,560
physics and math. It also touches upon philosophy and epistemology, the study of what can be known

16
00:01:50,560 --> 00:02:00,160
and in a sense computer science is an extension of what is knowable. Now the fact that computer

17
00:02:00,160 --> 00:02:08,000
science could be considered a branch of physics is really, really deep and relates to things like

18
00:02:08,880 --> 00:02:15,760
astrophysics and quantum mechanics and certain other important aspects of physics.

19
00:02:16,640 --> 00:02:22,960
For a while it was considered sort of an extension of math and it's also that but it has its own

20
00:02:23,520 --> 00:02:31,280
character so it's not really considered exactly math. Unfortunately I have no hope of doing this

21
00:02:31,280 --> 00:02:37,440
talk justice. This is something that's really, really beautiful and I doubt I'm going to be able

22
00:02:37,440 --> 00:02:45,200
to convey it to you in this talk. There are no pretty pictures in this talk except one maybe

23
00:02:45,760 --> 00:02:51,440
and there will be a lot of oversimplifications but I am going to be talking about what I consider to

24
00:02:51,440 --> 00:03:01,520
be magic even deeper magic and joy. So programming and theoretical computer science are different

25
00:03:01,520 --> 00:03:08,720
but the same. To use modern slang theoretical computer science is the god mode version of programming

26
00:03:10,080 --> 00:03:17,840
but programming humble simple programming is the basis of the theoretical computer science

27
00:03:17,840 --> 00:03:24,960
and it's the most general tool ever that's why it's important. Of all the things that humanity

28
00:03:24,960 --> 00:03:30,320
has invented computer programming is not necessarily the most important or the best

29
00:03:30,320 --> 00:03:37,120
but it is the most general. You can use it for almost everything. Today it's needed in all the

30
00:03:37,120 --> 00:03:44,400
sciences all engineering and many arts and therefore I think all young people need to understand

31
00:03:45,360 --> 00:03:49,840
at least a little computer programming in the same way that all people need to understand a little

32
00:03:49,840 --> 00:04:00,160
bit of algebra. So I'd like to ask the question what is a computer? So to me a computer is a

33
00:04:00,160 --> 00:04:08,640
mindless machine that can only do very simple mechanical things. Now technically the word

34
00:04:08,640 --> 00:04:14,160
machine to a mechanical engineer means the application of force I don't mean that. I use

35
00:04:14,160 --> 00:04:21,440
the term to emphasize it has no creativity no slop and each step is completely predictable from the

36
00:04:21,440 --> 00:04:30,240
last. Now it's it's quite an extraordinary fact that a computer can really only do five things

37
00:04:30,960 --> 00:04:36,000
and you could you could organize these a little differently but this is the way I organized it

38
00:04:36,000 --> 00:04:42,320
back when I was 16 years old and I still think it's correct. It can input a number, it can store a

39
00:04:42,320 --> 00:04:49,840
number, it can do arithmetic on numbers, it can output a number and it can make a decision based

40
00:04:49,840 --> 00:04:57,760
on a number. But those numbers can be used to represent a lot of things and on the basis of

41
00:04:57,760 --> 00:05:07,760
these very very simple actions by building them up into an edifice of structure of the way things

42
00:05:07,760 --> 00:05:23,120
are organized we can do extraordinary things. So we can ask what is a program? So a program is a set

43
00:05:23,120 --> 00:05:30,640
or sequence of instructions for a computer which is just a machine which are executed in a particular

44
00:05:30,640 --> 00:05:38,000
order that can change based on what's in storage. This is also sometimes called an algorithm because

45
00:05:38,000 --> 00:05:44,320
it doesn't actually require a computer humanity developed algorithms for mathematics which were

46
00:05:44,320 --> 00:05:51,200
step-by-step procedures before computers existed. Nonetheless the nature of a program is that it's

47
00:05:51,280 --> 00:05:58,160
a set of instructions that are executed in a certain order that tell a computer what to do

48
00:05:58,160 --> 00:06:08,400
in the next step. So the first magic that this produces is that complexity and really quite a

49
00:06:08,400 --> 00:06:15,120
lot of complexity emerges from simplicity with the basic five things that I said even a beginner

50
00:06:15,120 --> 00:06:20,720
programmer can compute the factorial of a number and we're going to see that later on in this talk.

51
00:06:22,000 --> 00:06:27,920
Do an extraordinary thing called Conway's game of life which I'm going to show you a demonstration

52
00:06:27,920 --> 00:06:35,680
of which is kind of the best example of complexity rising up out of simplicity and you can also

53
00:06:35,680 --> 00:06:43,120
simulate a role-playing game that feels real even though it isn't real. You can create a character

54
00:06:43,120 --> 00:06:50,720
you say my fighter takes out his sword and wax the wizard and it feels like the wizard's really

55
00:06:50,720 --> 00:06:57,280
there in your fighting even though you programmed it. You know the wizard in the end is just a set

56
00:06:57,280 --> 00:07:04,400
of numbers and the fighter is just a set of numbers so there's almost no creativity in it.

57
00:07:05,040 --> 00:07:12,000
Now I have never been an educator but when I teach beginning courses in computer programming to

58
00:07:12,000 --> 00:07:17,760
teenagers which I've done a few times these are the three programs that I teach first.

59
00:07:18,400 --> 00:07:25,680
The second aspect of magic that computers allow is that they allow you to simulate physics obviously

60
00:07:25,680 --> 00:07:33,360
via mathematics. Mathematics is the language of physics without mathematics we can only do a little

61
00:07:33,360 --> 00:07:40,880
bit of physics. Now what is it that we do when we talk about physics? Well Leonard Suskin has said

62
00:07:41,200 --> 00:07:47,920
Leonard Suskin has said the purpose of physics is to compute is to predict the future so for

63
00:07:47,920 --> 00:07:54,400
example you predict the future of where a ball is going to fall if you throw it up in the air

64
00:07:55,200 --> 00:08:00,160
you know it's going to come down and if you're a good physicist and you know exactly how fast

65
00:08:00,160 --> 00:08:07,920
you threw it up you know exactly where it's going to land. These sorts of simulations

66
00:08:07,920 --> 00:08:17,120
can be done by a computer and in very important circumstances they succeed when math fails that

67
00:08:17,120 --> 00:08:25,440
is there are situations which we as a human society do not know how to solve with math

68
00:08:27,280 --> 00:08:33,040
very well but we can still solve them with a computer by simulating things over time.

69
00:08:33,120 --> 00:08:38,560
Now there are limits to that so there are problems that a computer can solve

70
00:08:39,200 --> 00:08:44,720
that are hard to solve any other way so the famous three-body problem which is considered to be

71
00:08:45,280 --> 00:08:51,600
unsolvable in math recently there was a Netflix show about it can be solved by a computer

72
00:08:52,480 --> 00:08:59,680
in a limited way it can simulate the position of three stars or planets or meteors in space

73
00:09:00,240 --> 00:09:07,520
orbiting each other over time and it can do that one millisecond at a time

74
00:09:07,520 --> 00:09:12,800
and it can do that for billions of milliseconds and it will be fairly accurate let's say a hundred

75
00:09:12,800 --> 00:09:19,200
years from now. Now some people would say that's not a solution to the problem in the sense that

76
00:09:19,200 --> 00:09:24,560
it's not a formula that you can write down that tells you where the planets are nonetheless it's

77
00:09:25,280 --> 00:09:30,560
better than any other solution that we have in the same way we can't write down a formula

78
00:09:30,560 --> 00:09:37,360
that describes the flow of air around an airplane but we can simulate now there's a great

79
00:09:37,360 --> 00:09:45,920
philosophical debate as to whether an individual neuron can be described mathematically it's

80
00:09:45,920 --> 00:09:52,160
unclear if neurons are actually extraordinarily complex or extraordinarily simple you can find

81
00:09:52,160 --> 00:09:57,600
people who will tell you either either one um but it's possible that we can simulate the action

82
00:09:57,600 --> 00:10:04,000
of neurons and therefore we can simulate the action of brains we can also simulate the action of

83
00:10:04,000 --> 00:10:10,880
waves and biological tissues and that is the reason that we have MRIs CAT scans and PET scans

84
00:10:10,880 --> 00:10:18,080
without those we would not be able to address the diseases that we address that way so the third

85
00:10:18,080 --> 00:10:23,680
magic is something that we're all familiar with you're using it right now you're seeing a picture

86
00:10:23,680 --> 00:10:31,040
of me and you're hearing my voice but inside a computer those are represented as little bitty

87
00:10:31,040 --> 00:10:37,280
numbers which are transmitted through a network and come to your computer and then are translated

88
00:10:37,280 --> 00:10:43,600
back into little blips of light on your screen and voltage levels on your speakers this does not

89
00:10:43,680 --> 00:10:50,400
take a lot of theoretical computer science but most of us enjoy computers because they can

90
00:10:50,400 --> 00:10:57,440
store and transmit representations of light and sound in the form of sounds and movies now coincidentally

91
00:10:58,400 --> 00:11:03,840
they can store every word ever written by human beings which is the basis for large language

92
00:11:03,840 --> 00:11:11,360
models in modern artificial intelligence so we're going to talk a little bit about

93
00:11:11,360 --> 00:11:15,680
programming later but I want to talk about theoretical computer science which I consider

94
00:11:15,680 --> 00:11:25,440
to be deeper magic so the deeper magic number one is that you can prove there are things computers

95
00:11:25,440 --> 00:11:34,160
can't do and can't ever do this is the basis of cryptography we've now proved there are problems

96
00:11:34,160 --> 00:11:41,040
that can't be solved by computers some of the cryptographic problems are simply because we

97
00:11:41,040 --> 00:11:46,080
don't have fast enough computers but there are other problems which can never be solved by any

98
00:11:46,080 --> 00:11:52,880
computer they can never be solved by any sequence of instructions no matter how fast the computer is

99
00:11:54,160 --> 00:12:02,480
and and that's really a mind-boggling sort of concept in my opinion so this leads to a thing

100
00:12:02,480 --> 00:12:08,160
called church's thesis Alonzo church was an american logician who worked in the 30s

101
00:12:08,720 --> 00:12:16,240
um the computation done by modern computers are probably the only kind of computations

102
00:12:16,240 --> 00:12:23,920
that can ever be done now this is called church's thesis because it cannot really be proved um so

103
00:12:23,920 --> 00:12:34,640
it's a thesis rather than a a proof so we have several different models of computation one is

104
00:12:34,640 --> 00:12:41,280
the von Neumann machine which is um very similar to the electronic machines that we have so my

105
00:12:41,280 --> 00:12:48,000
macintosh computer would be closest to a von Neumann machine there's the Turing machine which

106
00:12:48,000 --> 00:12:52,720
has been made famous by movies which was invented a little earlier than the von Neumann machine

107
00:12:53,840 --> 00:12:59,840
our computers today are not shaped like Turing machines uh but they're uh similar and then

108
00:12:59,840 --> 00:13:06,000
there's a very unappreciated form of computation called the lambda calculus and the interesting

109
00:13:06,000 --> 00:13:13,920
thing is that you can simulate each of these computers with the other so the lambda calculus

110
00:13:13,920 --> 00:13:18,800
is powerful enough to simulate a Turing machine a Turing machine can simulate a von Neumann

111
00:13:18,800 --> 00:13:25,680
machine and a von Neumann machine can simulate the lambda calculus so you get uh what can be

112
00:13:25,680 --> 00:13:32,320
described as a trippy loop in that everything is powerful enough to simulate the other so none

113
00:13:32,320 --> 00:13:40,560
can be more powerful than the other now is that the only kind of computation that can exist in the

114
00:13:40,560 --> 00:13:47,840
world well we don't really know but that's very strong evidence that there is no other

115
00:13:47,840 --> 00:13:55,440
form of computation that there is no other way to do it now some people would argue that biological

116
00:13:55,520 --> 00:14:02,160
brains and analog computation are a little asterisk to this and that quantum computing

117
00:14:02,160 --> 00:14:08,880
kind of nibbles at the edges of this a little bit but fundamentally this is accepted by most people

118
00:14:09,920 --> 00:14:15,680
so the deeper magic of theoretical computer science is what i call the dismal deep magic

119
00:14:16,400 --> 00:14:26,880
so it may be that thought and computation are the same it may be that human brains cannot

120
00:14:26,880 --> 00:14:32,640
think anything that can't be thought by a computer and it may be that the sex success

121
00:14:32,640 --> 00:14:39,040
of artificial intelligence proves not that machines are intelligent but that humans are dumb

122
00:14:40,000 --> 00:14:48,800
right it may not be that artificial intelligence is somehow coming alive or getting a soul spark

123
00:14:48,800 --> 00:14:54,560
or having consciousness it may be that that we're learning that our own brains are actually not

124
00:14:54,560 --> 00:15:01,120
capable of very much now i hope that's not the case but uh it's it's certainly an interesting

125
00:15:01,120 --> 00:15:07,120
philosophical point so there's an even deeper magic and there's there's no way i can really

126
00:15:07,840 --> 00:15:13,840
explain it in this uh talk if you don't understand it but there's a problem in computer science

127
00:15:13,840 --> 00:15:22,240
called p is equal to np which is a question is p equal to np p is the set of problems that can

128
00:15:22,240 --> 00:15:28,400
be solved in polynomial time np is the set of problems that can be solved in what's called

129
00:15:28,400 --> 00:15:33,680
nondeterministic polynomial time if you're a beginner there's no way i can explain this in

130
00:15:33,680 --> 00:15:41,600
this talk but uh i want what i want to point out is that p equal np is the most important

131
00:15:41,600 --> 00:15:47,840
problem known to humanity today in movies and so forth you sometimes hear about the remand

132
00:15:47,840 --> 00:15:56,080
hypothesis remand hypothesis is chump change compared to p equal np if humanity could show

133
00:15:56,080 --> 00:16:02,000
that p is equal to np which is not obvious that it is most people think it isn't then the world

134
00:16:02,000 --> 00:16:07,520
would change because in practice we could compute things efficiently which we could never compute

135
00:16:07,520 --> 00:16:16,240
before some things would still remain out of reach however and fundamentally this asks the question

136
00:16:16,240 --> 00:16:22,800
if you can verify something efficiently is there always a way to compute it efficiently

137
00:16:23,920 --> 00:16:31,200
and the answer is not obvious the greatest mathematician computer scientist and even

138
00:16:31,200 --> 00:16:38,320
physicist in the world have been working on this problem for 40 years and uh in fact i would argue

139
00:16:38,320 --> 00:16:46,560
they haven't actually made very much headway on it now the final really deep magic is information

140
00:16:46,560 --> 00:16:54,240
theory information theory is where theoretical computer science overlaps with physics and everything

141
00:16:54,240 --> 00:17:00,480
i say here has to be an oversimplification has to be taken with a grain of salt but nonetheless

142
00:17:01,680 --> 00:17:08,560
it's very important to understand information theory is closely related to the idea of entropy

143
00:17:08,560 --> 00:17:14,320
and that is the laws of thermodynamics and conservation of energy and the fact that

144
00:17:16,080 --> 00:17:24,320
the universe in a sense is running down that we're moving towards a less interesting less

145
00:17:24,320 --> 00:17:31,360
concentrated state of energy that everything is always smoothing out and becoming more boring

146
00:17:31,360 --> 00:17:38,720
so to speak information theory is independent of computers although we didn't know that

147
00:17:39,840 --> 00:17:47,600
50 years ago and it applies to many physical processes for example the nyquist limit of

148
00:17:47,600 --> 00:17:55,760
the foyer transform but also really fundamental things like how black holes work are related to

149
00:17:55,760 --> 00:18:04,000
information theory in a way which i only partially understand i partially understand this so it's

150
00:18:04,000 --> 00:18:12,400
kind of true that energy is equal to information and it's kind of true that information is equal

151
00:18:12,400 --> 00:18:20,080
to entropy now obviously this is an oversimplification because entropy is not energy entropy is the

152
00:18:20,080 --> 00:18:27,600
opposite of energy nonetheless in very special circumstances information is similar to energy

153
00:18:27,600 --> 00:18:35,360
and in different circumstances information is similar to entropy so now we can ask the really

154
00:18:35,360 --> 00:18:40,400
fundamental question which which i want everyone especially if you're a beginner here to understand

155
00:18:40,480 --> 00:18:48,960
and be intrigued by it what does a programmer do i've believed for a long time that the job of a

156
00:18:48,960 --> 00:18:58,880
programmer is to create order out of chaos so from uh long before the birth of christ uh there was a

157
00:18:58,880 --> 00:19:06,640
famous hymn to Zeus by cliente's and it begins chaos to be his order and in the middle of it in

158
00:19:06,640 --> 00:19:11,120
one translation obviously it was written in greek you can say but you know how to make the

159
00:19:11,120 --> 00:19:16,400
crooked straight and to bring order to the disorderly even the unloved is loved by you

160
00:19:17,120 --> 00:19:23,920
the poet is speaking to Zeus for you have so joined all things into one the good and the bad

161
00:19:23,920 --> 00:19:31,280
that they all share in a single unified everlasting reason and of course the christian and judaic

162
00:19:31,280 --> 00:19:37,680
bible begins let there be light that's what a programmer does they bring light out of darkness

163
00:19:37,680 --> 00:19:46,320
in order out of chaos so fundamentally a program systemizes that which was not

164
00:19:47,200 --> 00:19:56,080
systemized previously so the main tool of computer programming is could be called abstraction

165
00:19:57,040 --> 00:20:04,320
it's not that easy to understand what it means in this this context programs have subroutines

166
00:20:04,320 --> 00:20:12,320
or functions which can be reused the reuse of a subroutine always cost a tiny amount of time

167
00:20:12,320 --> 00:20:20,480
and also a tiny amount of electricity but once a subroutine is written it can be used over and

168
00:20:20,480 --> 00:20:30,480
over again and it never wears out just like the number 37 never wears out in a sense subroutines

169
00:20:30,480 --> 00:20:36,800
and mathematics are stronger than steel and diamonds steel and diamonds and granite

170
00:20:36,800 --> 00:20:44,480
eventually wear out but math and subroutines don't abstraction is the main tool for making

171
00:20:44,480 --> 00:20:50,240
long programs short and is thus closely connected with bringing order out of chaos

172
00:20:51,120 --> 00:20:56,880
factorial the first program that programmers should learn teaches abstraction through recursion

173
00:20:57,600 --> 00:21:03,920
now there's a thing called lambda lifting that i recommend um an interested student

174
00:21:03,920 --> 00:21:11,280
read the wikipedia article on lambda lifting which is sort of the formal way in which abstraction

175
00:21:11,280 --> 00:21:17,760
enters computer programming but most programmers will will not understand lambda lifting they

176
00:21:17,760 --> 00:21:26,240
will instead think of when i create a subroutine i am creating abstraction which i can reuse again

177
00:21:26,240 --> 00:21:35,040
and again so my own personal style of programming is based on something that paul graham said he

178
00:21:35,040 --> 00:21:41,760
wrote an essay called concision is power and i view the act of programming as being almost

179
00:21:41,760 --> 00:21:48,160
their exceptions the same as trying to create the shortest most compact representation of something

180
00:21:48,800 --> 00:21:55,360
and thus in a way creating the most abstract version of a sequence of instructions to accomplish

181
00:21:55,360 --> 00:22:02,960
something now functional programming is a style in which subroutines are side effect free this

182
00:22:02,960 --> 00:22:08,560
helps to bring order out of chaos because of something technical called referential transparency

183
00:22:09,200 --> 00:22:14,960
and it's the most abstract way of working because it means that a function can be used in any

184
00:22:14,960 --> 00:22:21,200
context and always means the same thing now this is debatable we don't have time to go into it uh

185
00:22:21,200 --> 00:22:28,160
some people don't like functional programming as much as i do another way of expressing this is

186
00:22:28,160 --> 00:22:38,320
a principle called dry or do not repeat yourself in a computer program there should never really be

187
00:22:39,440 --> 00:22:46,080
two lines that are the same there should never be two subroutines that are the same if you find

188
00:22:46,080 --> 00:22:53,920
yourself writing the same code it should become a subroutine and this principle can be applied to

189
00:22:53,920 --> 00:23:00,560
enormous aspects of computer programming you should not have duplication in your data just as

190
00:23:00,560 --> 00:23:08,800
you should not have duplication in your instructions and in many many circumstances what people do is

191
00:23:08,800 --> 00:23:14,320
they copy and paste code from somewhere and in so doing they're violating the dry principle

192
00:23:14,320 --> 00:23:21,440
and after years programs become big fluffy disorderly things where things are almost the

193
00:23:21,440 --> 00:23:26,960
same but not quite in different places and so forth and that's very poor software engineering

194
00:23:28,400 --> 00:23:35,680
but it takes beginners years to fully understand this and to fully understand how to avoid it

195
00:23:37,440 --> 00:23:42,880
so now i'd like to talk about the very first program that i think everyone should write

196
00:23:43,920 --> 00:23:49,840
the first program is called factorial and it's written with an exclamation point

197
00:23:50,720 --> 00:23:56,800
when i was in in college there was a young man who didn't know was called factorial so when he saw

198
00:23:56,800 --> 00:24:04,160
in factorial he said called it in as if as if it's very emphatically the way you you say in

199
00:24:05,200 --> 00:24:14,400
in fact in bang sometimes pronounced bang or in factorial or in exclamation point

200
00:24:15,280 --> 00:24:23,760
is used in the famous formula from probability that's sometimes pronounced in choose k it gives

201
00:24:23,760 --> 00:24:31,120
you the ways to choose k element the number of ways to choose k elements from a set of in objects

202
00:24:31,120 --> 00:24:38,320
this is all important to poker players and all kinds of probability and all kinds of

203
00:24:38,400 --> 00:24:44,960
mathematics but the definition of factorial itself is really really simple and this is it

204
00:24:46,720 --> 00:24:51,920
right here this is actually in javascript we could take this and we could run it okay now

205
00:24:52,960 --> 00:25:01,360
um i learned this so long ago it no longer seems weird to me but some of you reading it

206
00:25:02,240 --> 00:25:07,600
may not have learned this and i remember how hard it was for me to understand when i was about

207
00:25:08,400 --> 00:25:15,680
18 or 19 and i was first introduced to this this concept so what this code says is that

208
00:25:15,680 --> 00:25:24,000
the function that we call factorial which is in bang so to speak has a mathematical definition

209
00:25:24,640 --> 00:25:35,520
if n is equal to zero the answer is one if n is not equal to zero the answer is in times

210
00:25:35,520 --> 00:25:48,240
the factorial of n minus one now this is a trippy loop factorial is being defined in

211
00:25:48,960 --> 00:25:56,080
terms of itself how can the computer know what factorial means when we're telling it what factorial

212
00:25:56,080 --> 00:26:04,080
means right now it's not obvious now to many people in this audience it may be obvious but

213
00:26:04,080 --> 00:26:10,480
when i was a boy this was not obvious to me okay you you might ask the question well how on earth

214
00:26:10,480 --> 00:26:18,400
can the computer ever know how to do factorial of n minus one when we're defining it in terms of

215
00:26:18,400 --> 00:26:25,760
itself it looks like a trick okay and it takes a while to understand it and in fact the answer is

216
00:26:26,400 --> 00:26:33,760
this only works if you call factorial with a smaller number in the body of the function

217
00:26:34,720 --> 00:26:40,320
so that the problem is always somehow getting simpler and eventually it gets down to zero

218
00:26:40,320 --> 00:26:47,280
if that is not true you create an infinite loop infinite loops are much worse than trippy loops

219
00:26:48,080 --> 00:26:53,920
so in fact you could say that this function has a bug if you called this was minus one

220
00:26:54,640 --> 00:27:00,320
it would run forever because it would multiply minus one by the factorial of minus two

221
00:27:01,120 --> 00:27:06,880
which would be minus two times the factorial of minus three which would be minus three times

222
00:27:06,880 --> 00:27:12,720
the factorial of minus four and that number would never become equal to zero and it would never stop

223
00:27:13,680 --> 00:27:24,400
the second program is a program called conways game of life and it was specifically designed

224
00:27:24,960 --> 00:27:35,760
to show how complexity arises out of simplicity okay and it at one kind of artificial level

225
00:27:35,760 --> 00:27:42,560
it's a simulation of biological processes these four rules are the only rules it has

226
00:27:43,120 --> 00:27:46,960
and I believe this is the second computer program which every beginner should write

227
00:27:47,840 --> 00:27:54,480
okay it's played on a grid like a chessboard but the chessboard is considered not to be eight

228
00:27:54,480 --> 00:28:00,400
by eight but to extend as far as you want it to so it's played on a square grid and each grid is called

229
00:28:00,480 --> 00:28:06,640
grid cell square is called a cell okay and a cell is either live or dead

230
00:28:07,760 --> 00:28:13,600
and there's a clock that ticks and one generation leads to the next generation

231
00:28:13,600 --> 00:28:19,520
so you start with some pattern and then you start generations and the rule for each cell

232
00:28:19,520 --> 00:28:27,840
is simply these four rules in a live cell with fewer than two live neighbors that's the cells

233
00:28:28,320 --> 00:28:35,840
the eight cells around it that touch it dies as if by underpopulation I prefer to think of it as

234
00:28:35,840 --> 00:28:42,320
loneliness it dies of loneliness any live cell with two or three live neighbors lives on to the

235
00:28:42,320 --> 00:28:50,880
next generation it's happy any live cell with more than three live neighbors dies by overpopulation

236
00:28:50,880 --> 00:28:58,960
or crowding and then here is a bit of magic any dead cell with exactly three live neighbors

237
00:28:58,960 --> 00:29:10,800
becomes a live cell as if by reproduction okay simple rules that produce almost unbounded complexity

238
00:29:11,360 --> 00:29:19,440
so now I'd like to show you an example of this is Conway's game of life you guys can do this

239
00:29:19,440 --> 00:29:24,320
I'm randomly putting this here I don't know what I'm doing I'm just clicking on some numbers so

240
00:29:24,320 --> 00:29:34,320
you see this consists of a grid of squares and each square is considered a cell yellow means it's alive

241
00:29:37,280 --> 00:29:42,320
gray means it's dead now when I click next it's going to do a generation

242
00:29:42,960 --> 00:29:51,200
so some cells will died and a few cells came into existence and the pattern changed

243
00:29:52,000 --> 00:30:00,880
and now the pattern is going to change again and again and again and again and now I can simply

244
00:30:00,880 --> 00:30:03,120
start running it and we'll see what happens

245
00:30:13,280 --> 00:30:16,400
not done yet

246
00:30:18,240 --> 00:30:24,880
it's not done yet it's not done yet it's not done yet now it's done

247
00:30:27,920 --> 00:30:37,040
so how could that complexity that you just saw arise out of those four rules

248
00:30:38,000 --> 00:30:45,280
that is the thing which is of sort of paramount importance to mathematicians and related to

249
00:30:45,280 --> 00:30:58,400
what I'm talking about the the Iraq the ability of simplicity to give birth to complexity okay and

250
00:30:58,400 --> 00:31:04,400
then finally an exercise that I think all beginning computer programmers should do is to write a very

251
00:31:04,640 --> 00:31:12,800
simple sort of fantasy role-playing game that has characters in it and you can have the characters

252
00:31:12,800 --> 00:31:18,800
fight like you do in Dungeons and Dragons so that a fighter can whip out a sword and say I attack

253
00:31:18,800 --> 00:31:23,840
the wizard and I strike the wizard with my sword and the wizard's health goes down and then the

254
00:31:23,840 --> 00:31:32,080
health the wizard cast a magic spell uh perhaps to catch the um fighter in a web which decreases

255
00:31:32,080 --> 00:31:39,200
their ability to strike in the future now um the thing about this is you play it it's simple

256
00:31:40,400 --> 00:31:51,120
it's fun and it feels alive but you programmed it you know very well the wizard is not alive the

257
00:31:51,120 --> 00:31:58,880
wizard is just a subroutine the wizard is literally 10 or 15 lines of code that you yourself programmed

258
00:31:59,680 --> 00:32:06,320
representing only with numbers now if you don't want to do that you can think of a

259
00:32:06,320 --> 00:32:11,360
complicated game uh an expensive game like Minecraft or something like that accomplishing

260
00:32:11,360 --> 00:32:20,960
the same thing it feels real even though we know in the end it is nothing more than a complicated

261
00:32:20,960 --> 00:32:30,720
series of the five operations I began this talk with so programming is almost reason

262
00:32:32,480 --> 00:32:39,280
but not quite it is almost human reason but it isn't exactly programming does not tell the poet

263
00:32:39,280 --> 00:32:45,120
what word to select or the musician how to play the note perfectly or the painter how the brush

264
00:32:45,120 --> 00:32:51,200
stroke should go but nonetheless the act of programming is very close to the act of human

265
00:32:51,200 --> 00:32:59,680
reasoning for 100 years coming up on 100 years now literally we've been making programming tools

266
00:32:59,680 --> 00:33:07,440
more powerful so for example john von Neumann did not believe in compilers he believed it was a

267
00:33:07,440 --> 00:33:13,040
sign of mental weakness if people had to use compiled computer languages he thought you should

268
00:33:13,040 --> 00:33:20,400
program them sort of only with the the most minimal set of instructions um he was weird

269
00:33:22,240 --> 00:33:28,880
each increase in the strength of the programming tools has not made programming obsolete it has

270
00:33:28,880 --> 00:33:35,280
not decreased the number of people making gainful living by being programmer it has made programming

271
00:33:35,280 --> 00:33:42,000
more important and given gainful employment to more people so I personally do not believe anyone

272
00:33:42,000 --> 00:33:48,160
should fear that AI will replace programming that it's the same as saying AI will replace human

273
00:33:48,160 --> 00:33:57,200
reasoning AI will become a tool used by programmers now I have not used it I don't use co-pilot or

274
00:33:57,200 --> 00:34:03,760
any AI tools for that but at some point I may have to learn how to do that on the other hand I do

275
00:34:03,760 --> 00:34:10,960
think we should fear killer robots I'm much more worried about killer robots than I am uh my ability

276
00:34:10,960 --> 00:34:19,760
to think being replaced by an artificial intelligence so there are a lot of joys associated with

277
00:34:19,760 --> 00:34:27,440
computer programming and um I got to experience these when I was a child almost I started programming

278
00:34:27,440 --> 00:34:32,400
when I was 13 not very well it took me a long time to learn a lot I didn't have anyone to learn from

279
00:34:32,960 --> 00:34:38,560
um I wish every child could experience this joy I wish everyone could it could do these

280
00:34:39,280 --> 00:34:43,280
now there are other ways to learn these joys but computer programming is a darn good way to

281
00:34:43,840 --> 00:34:49,680
to do it as Lee and Nardo Da Vinci said the joy of understanding is one of the greatest pleasures

282
00:34:49,680 --> 00:35:00,480
that humanity can have and computer programming is all about understanding often you begin in

283
00:35:00,480 --> 00:35:07,040
confusion and you move towards understanding because you bring order out of chaos you bring

284
00:35:07,040 --> 00:35:15,120
light out of darkness you start from a situation of not understanding a problem and then you understand

285
00:35:15,120 --> 00:35:21,920
it there's the joy of discovery which I think is quite different that's where you learn something

286
00:35:21,920 --> 00:35:28,960
surprising um sometimes you discover surprising problems sometimes you discover surprising

287
00:35:28,960 --> 00:35:35,680
solutions sometimes like in the case of Conway's game of life you discover surprising things which

288
00:35:35,680 --> 00:35:39,920
are neither problems nor solutions they're just surprising things about the mathematical world

289
00:35:39,920 --> 00:35:47,840
in which we live and then perhaps the greatest joy is the joy of creation you can write a program

290
00:35:47,840 --> 00:35:53,920
you can create something out of nothing which did not exist before and something important

291
00:35:53,920 --> 00:36:01,040
as well of course you can do that by knitting a sweater but one form of creation is writing a

292
00:36:01,040 --> 00:36:08,800
computer program and then you can experience the joy of mastery the joy of moving from a state of

293
00:36:08,800 --> 00:36:14,880
not being very good at something to being pretty good at it um I do not consider myself to have

294
00:36:14,880 --> 00:36:22,080
mastered computer programming uh I'm still learning I I wish I had time to learn more I I'm

295
00:36:22,080 --> 00:36:29,360
considering myself a journeyman programmer so to speak um my one of my heroes Kent Beck said

296
00:36:29,360 --> 00:36:35,440
that confusion should be cherished because it precedes enlightenment and computer program

297
00:36:35,440 --> 00:36:41,760
it is all about moving from a state of confusion to a state of enlightenment and then finally

298
00:36:41,760 --> 00:36:44,720
there's the joy of sharing um

299
00:36:49,680 --> 00:36:55,840
in a way there are not many programs in the world there is only one universal program

300
00:36:56,560 --> 00:37:01,840
it is splintered between my computer and Lawrence's computer and Christina's computer

301
00:37:01,840 --> 00:37:08,160
and Morena's computer but in a way there's really only one computer program in the whole world and

302
00:37:08,160 --> 00:37:14,400
we are all writing parts of it we are writing little bitty parts of it so we are all sharing

303
00:37:14,400 --> 00:37:20,880
in a given enterprise for many people a great joy that they get to experience in college

304
00:37:20,880 --> 00:37:27,520
and I and I wish everyone got to go to college I know some people don't is to um share their

305
00:37:27,520 --> 00:37:33,360
programs with other people sometimes in a classroom setting sometimes not I remember uh one time I

306
00:37:33,360 --> 00:37:37,600
was in a graphics class at the University of Texas when I was in graduate school and my friend

307
00:37:37,600 --> 00:37:44,320
Steve Benz uh put up on his screen a graphic programming and he programmed a little airplane

308
00:37:44,320 --> 00:37:51,520
to fly around the tower of a representation of a tower of an airport and it was it was an

309
00:37:51,520 --> 00:37:58,080
astonishing thing to to have accomplished quite quite beautiful uh I really enjoyed that when I

310
00:37:58,080 --> 00:38:06,240
was at Rice University uh there was there was a student there uh who was quite unusual and I would

311
00:38:06,240 --> 00:38:12,800
walk by his terminal and on it there was a weird glyph and I couldn't figure out what it was so

312
00:38:12,800 --> 00:38:20,400
you know I asked the guy and he said well it's elvish he had created an ascii art representation

313
00:38:20,400 --> 00:38:27,040
of the letter the elvish characters that Tolkien had created which are called tingwar um an example

314
00:38:27,040 --> 00:38:35,040
of nerdy stuff uh but it was more fun because it was shared and then finally and my talk is closing

315
00:38:35,040 --> 00:38:43,520
now um there's the joy of meaning and this is the deepest thing to me public convention gives

316
00:38:43,520 --> 00:38:49,440
everything it does to the whole world we don't keep anything secret everything we do is shared

317
00:38:49,440 --> 00:38:56,880
through open source licensing uh we've been trying to save people's lives for a while now

318
00:38:56,880 --> 00:39:03,040
through global medical stuff I doubt anyone's life has ever been saved by one of our inventions

319
00:39:03,040 --> 00:39:10,160
although it is our goal and we're working towards it things take time to ripen uh I I have faith that

320
00:39:10,160 --> 00:39:17,440
it will eventually happening programming is an important part of our work almost everything

321
00:39:17,440 --> 00:39:22,800
now requires computer programming programming is part of our work and our work is meaningful

322
00:39:23,360 --> 00:39:28,240
and therefore the programming of meaning so thank you for your support of public

323
00:39:28,320 --> 00:39:35,360
convention thank you for listening I've got a few references here which people can look up

324
00:39:37,280 --> 00:39:42,560
on google if they want and I will now open the floor to questions

325
00:39:49,360 --> 00:39:53,440
well I should have been here at 8 and for some reason I thought it started at 8 30

326
00:39:53,440 --> 00:39:58,080
oh okay Victoria Christina's raised your hand go ahead Christina

327
00:39:59,360 --> 00:40:06,560
that was an excellent presentation um I've never actually kind of thought about that all laid out

328
00:40:06,560 --> 00:40:11,120
in such a way uh I feel like it's it's one of those programming in general is one of those

329
00:40:11,120 --> 00:40:15,600
things that I've I've been around for a long time and have a very very very tiny bit of

330
00:40:15,600 --> 00:40:22,000
experience with myself but if you're around it so much you often don't necessarily think of the

331
00:40:22,000 --> 00:40:27,840
origins of it um but I did have a question that came up and it's something that I never

332
00:40:28,560 --> 00:40:35,920
thought of much myself um and it's I love the slide on factorials by the way so in calculating

333
00:40:36,480 --> 00:40:45,360
um factorials you the two things that come to mind are recursive function versus iterative

334
00:40:45,360 --> 00:40:52,240
so I was wondering if um like from a programming standpoint like different characteristics or

335
00:40:52,240 --> 00:40:58,720
use cases specific to either using a recursive or iterative approach um in programming

336
00:41:01,680 --> 00:41:08,720
yeah it's a good it's a good question it's a really good question because um in fact

337
00:41:09,600 --> 00:41:18,560
you can prove in a sense that you you don't have to do this recursively so what Christina's

338
00:41:18,560 --> 00:41:25,040
saying is this self-reference the fact that factorial is defined in terms of factorial is called

339
00:41:25,520 --> 00:41:34,720
um recursion you could write um factorial as what's called a loop and you would count down

340
00:41:35,280 --> 00:41:42,000
and you would examine the value in and you you would count across in and and and do it that way

341
00:41:42,720 --> 00:41:54,320
um so you don't have to do it this way except there are things over time which become so

342
00:41:54,320 --> 00:42:02,480
complicated it would be almost impossible to do all of them um iteratively for example you could

343
00:42:02,480 --> 00:42:08,720
be working on a solving a differential equation you know or some very very big thing and you're in

344
00:42:08,720 --> 00:42:14,640
the middle of it and you're down in the middle of a computation and now you have to do another

345
00:42:14,640 --> 00:42:23,920
factorial right you you have to have subroutines and you have to have abstraction in um in doing

346
00:42:23,920 --> 00:42:32,560
those things and there there are some things which um in order to not define them recursively

347
00:42:32,560 --> 00:42:38,480
you would almost have to stand on your head like like you could do it there's a mathematical proof

348
00:42:38,480 --> 00:42:44,960
that you don't have to have this because after all this programming language is being compiled

349
00:42:44,960 --> 00:42:50,960
into something which is just a set of numbers which is doing the same thing but it would become

350
00:42:51,040 --> 00:42:58,400
unnatural it would become so complicated that you almost couldn't think about it and it would get in

351
00:42:58,400 --> 00:43:06,400
the way of your thinking about it and and a proof of that is the formula on the right hand side of

352
00:43:06,400 --> 00:43:15,120
this page right here we have n bang and it's expressed in terms of k bang and n minus k bang

353
00:43:15,120 --> 00:43:24,880
mathematicians are using this you know using this sort of thing uh referentially as a subroutine in

354
00:43:24,880 --> 00:43:30,960
the same way and if you go to the wikipedia page you will see it defined both iteratively and

355
00:43:30,960 --> 00:43:39,520
recursively i don't know if that answers your question or not yes it does um and kind of as a

356
00:43:39,520 --> 00:43:47,360
follow-up to that i don't want to i don't want to hog all the question time but um are there so

357
00:43:47,360 --> 00:43:54,960
from a computer programming standpoint are there more resource constraints with one versus the other

358
00:43:54,960 --> 00:44:01,760
so if so taking an iterative approach versus recursive like what does that what does it mean

359
00:44:01,760 --> 00:44:10,640
for the programmer when you're coming to choose between the two okay so there are people who will

360
00:44:10,640 --> 00:44:23,920
tell you that an iterative approach is more efficient because a um recursive approach appears on the

361
00:44:23,920 --> 00:44:33,200
surface to use more memory okay and so there are times when an iterative approach would be better

362
00:44:33,840 --> 00:44:39,920
and let me let me return to this and try to explain this in the in the deepest possible way

363
00:44:39,920 --> 00:44:48,640
okay so for example the way this is implemented in a computer in a in as the languages compile

364
00:44:49,360 --> 00:44:56,800
it's turned from this representation into a different representation and you almost can't

365
00:44:56,800 --> 00:45:03,920
discuss it without talking about what's called a stack frame and whenever you make a call you push

366
00:45:03,920 --> 00:45:10,960
onto the stack which is called because it's like a cafeteria tray uh in a cafeteria you know you have

367
00:45:10,960 --> 00:45:17,200
a spring-loaded stack of trays sometimes you you push things onto the stack and you and you build

368
00:45:17,280 --> 00:45:24,000
things up and then you take things off the stack okay you push the variables here onto this the

369
00:45:24,000 --> 00:45:33,920
stack well however many calls you make uh each one of those has to have a memory representation

370
00:45:34,720 --> 00:45:43,920
you can run out of memory okay now you can do it it appears on the surface that you can do it more

371
00:45:43,920 --> 00:45:52,480
efficiently iteratively because you wouldn't have that extra space however this program the way it's

372
00:45:52,480 --> 00:45:59,840
written is what's called tail recursive in the sense that the the use of factorial is the last

373
00:45:59,840 --> 00:46:07,120
thing in what's being done here so the compiler knows that and can automatically implement an

374
00:46:07,120 --> 00:46:17,520
efficient way of doing it so in practice it doesn't matter okay now another way that i if i wanted to

375
00:46:17,520 --> 00:46:24,000
i could attack what you're saying is i could say yes it might be more efficient in terms of computer

376
00:46:24,000 --> 00:46:33,520
instructions but computer instructions are cheap what's hard is the clarity of the program to make

377
00:46:33,520 --> 00:46:40,720
it in an ordered fashion and so i would be very low to write it in a more efficient way

378
00:46:40,720 --> 00:46:45,360
if it decreased the clarity of the program from a human understanding point of view

379
00:46:45,360 --> 00:46:48,320
there's another saying in computer science which is that

380
00:46:52,640 --> 00:46:57,440
premature optimization is the root of all evil that was that's famously said by

381
00:46:57,600 --> 00:47:05,040
Donald Knuth a very important computer scientist so let me let me just show you here what happens

382
00:47:06,560 --> 00:47:13,760
so over here on the right this is actually a the development tools which are built into

383
00:47:13,760 --> 00:47:22,480
the chrome browser and it runs javascript and so i can paste this pro oops i could paste this program

384
00:47:22,480 --> 00:47:33,040
in here but it's apparently please type allow posting in here so it's got a nice security feature

385
00:47:33,040 --> 00:47:43,760
won't let me post it in oh allow pasting okay that

386
00:47:46,880 --> 00:47:49,200
well i'll do it the old-fashioned way i'll type it

387
00:47:52,480 --> 00:48:00,640
so i already typed this in okay so this is javascript this is completely legal javascript

388
00:48:01,360 --> 00:48:12,480
okay and i can call factorial of zero and it's one and i can call factorial of 10 and it'll be a big

389
00:48:12,480 --> 00:48:20,880
number and i can call factorial of 20 and i can call factorial

390
00:48:26,240 --> 00:48:33,200
let's say 100 this may not work okay and it kind of works and it's a very very very very large

391
00:48:33,200 --> 00:48:43,280
number right um now eventually we'll run out there's a bug in this program in a sense factorial is

392
00:48:43,280 --> 00:48:49,440
not actually defined on negative numbers but if i run this on a negative number as i said before

393
00:48:50,240 --> 00:48:54,640
it will go into an infinite loop so we're going to see what happens when it does that

394
00:48:55,600 --> 00:49:05,440
so what it actually says is maximum call stacked size exceeded what it did is it kept going until

395
00:49:05,440 --> 00:49:12,000
it ran out of its own memory now it's smart so before it crashed my computer it caught it

396
00:49:12,560 --> 00:49:15,280
and it said oh i'm not going to let you make that call again

397
00:49:15,280 --> 00:49:26,240
that may be more than you wanted to know about that no no and then sorry so one last thing

398
00:49:26,240 --> 00:49:33,040
would be so would you say that recursion then is more suitable for problems that could be broken

399
00:49:33,040 --> 00:49:38,160
down into similar sub problems and the thing that first comes to mind for me is like some

400
00:49:38,160 --> 00:49:44,720
of the sorting algorithms whereas when i think of iteration i think of more suitable program uses for

401
00:49:45,360 --> 00:49:51,280
problems that would require repeated execution of a block code linear searches things like that

402
00:49:51,920 --> 00:49:58,880
yes okay so i would say yes and the best example of that if you want to google it right now is um

403
00:49:58,880 --> 00:50:08,000
google quicksort okay quicksort is a very simple um program here let me create a new slide um it's

404
00:50:08,000 --> 00:50:13,680
not necessarily the best the best sort in the world but it's it's extraordinarily simple and

405
00:50:13,760 --> 00:50:18,400
that's why it's done it was created by another famous computer scientist i had the pleasure of

406
00:50:18,400 --> 00:50:27,280
meeting uh Charles anthony robert pour who for some reason was called tony uh so more created

407
00:50:27,280 --> 00:50:33,680
quicksort and quicksort looks like this and i can't this is not going to be correct JavaScript

408
00:50:34,320 --> 00:50:37,520
quicksort of and i'll call it s is a sequence

409
00:50:38,480 --> 00:50:50,400
okay and what i do is i is i'll say let a be first half of s that is the first if s has 100

410
00:50:50,400 --> 00:50:56,480
members to be the first 50 okay and exactly how i'd do that i would depend on the exact language

411
00:50:56,480 --> 00:51:09,200
i'm in but let you know let b be the second half of s okay um uh now i'm forgetting it okay and so

412
00:51:09,200 --> 00:51:21,200
then what you do is you do a quicksort of a and then you do a quicksort of b so that those two are

413
00:51:21,280 --> 00:51:31,760
sorted and that that gives you back two list of 50 numbers which are each sorted and then

414
00:51:31,760 --> 00:51:37,040
you you merge them very simply and i maybe i'm forgetting because that would be called a merge

415
00:51:37,040 --> 00:51:44,240
sort instead of instead of a quicksort i think maybe quicksort finds the median uh value and

416
00:51:44,240 --> 00:51:48,720
takes all the lower ones and then all the upper ones and it sorts those two and then merges it

417
00:51:48,720 --> 00:51:54,720
back but it's fundamentally recursive in the way that you just described because you're taking a

418
00:51:54,720 --> 00:52:00,960
list of 100 elements breaking it into two list of 50 sorting the two list of 50 and then doing

419
00:52:00,960 --> 00:52:10,720
something very simple to put it back together now it can be done iteratively as well but it

420
00:52:11,680 --> 00:52:17,600
is probably harder to understand it than by doing it recursively so why do it

421
00:52:19,680 --> 00:52:25,120
that makes sense that's really cool so i i don't know you know a lot of applications i you know

422
00:52:25,120 --> 00:52:32,000
because i don't don't do computer programming but i do know that a lot of what's behind some of these

423
00:52:32,000 --> 00:52:37,760
companies that are doing really extensive gene analysis so analyzing genetic combinations

424
00:52:37,760 --> 00:52:43,760
and permutations they're using programs with a lot of factorial calculations involved so that's

425
00:52:43,760 --> 00:52:48,720
how they're discovering like different gene combinations correlate with certain syndromes or

426
00:52:50,080 --> 00:52:56,000
you know genetic mutations that's that's like the the first real-world case that comes from my mind

427
00:52:57,200 --> 00:53:04,800
well right okay so so here's something mind-blowing even the act of so to us the act of multiplying

428
00:53:04,800 --> 00:53:11,680
two numbers is simple and in java script it's simple you just write a star b and that multiplies

429
00:53:11,680 --> 00:53:18,720
two numbers together okay but as a becomes gigantic and b becomes gigantic it starts to be

430
00:53:18,720 --> 00:53:26,720
inefficient to multiply it the way humans multiply numbers okay of course you would never think of

431
00:53:26,720 --> 00:53:32,320
worrying about this until it's more than like a thousand digits on each side but the numbers you

432
00:53:32,320 --> 00:53:38,480
deal with in genomic combinations can can get really big there's an entire science of computer

433
00:53:38,480 --> 00:53:44,160
science that deals with asymptotic complexity where you try to create the most efficient algorithms

434
00:53:44,160 --> 00:53:52,080
you can i do not fully understand this but the most efficient way to multiply numbers is actually

435
00:53:52,080 --> 00:54:00,000
with the Fourier transform okay so that algorithm for multiplying very very very very large numbers

436
00:54:00,000 --> 00:54:08,400
is quite unnatural compared to what we as school children learn to do in our multiplication

437
00:54:08,400 --> 00:54:13,680
and if you were trying to compute factorial you might do the same thing and you might use

438
00:54:13,680 --> 00:54:18,880
approximations and then there are all kinds of all kinds of tricks to make that go faster and

439
00:54:18,880 --> 00:54:27,360
there's an entire science behind that which is usually not done usually computer programmers

440
00:54:27,360 --> 00:54:38,320
don't worry about that until they're at least out of college

441
00:54:47,920 --> 00:54:54,400
oh do we have any other questions i'll let other people ask questions otherwise we will be here

442
00:54:54,400 --> 00:54:59,920
all night with me being like what about this what about that i am always at your service christina

443
00:55:00,960 --> 00:55:04,800
all right i'm sure others have have questions so i'll i will let others ask them

444
00:55:15,600 --> 00:55:19,600
another thing i learned in graduate school is that silence is golden

445
00:55:20,320 --> 00:55:24,800
and often if you just wait long enough people will ask a question even though they're shy

446
00:55:32,080 --> 00:55:34,400
i don't really have a question but i did you have a comment though

447
00:55:35,840 --> 00:55:40,480
in your description of one of the things i think that i think is kind of overlooked

448
00:55:41,200 --> 00:55:48,400
is the root word of analog computing is i think it's shared with analogy and i like thinking of

449
00:55:48,640 --> 00:55:56,000
computing as an analogy that is running on base level physics or basic level reality

450
00:55:56,800 --> 00:56:03,840
and that that level of and what we're basically doing is creating a story that is playing out

451
00:56:03,840 --> 00:56:10,480
in front of us in the world around us and the story is and we we are consistent with our story

452
00:56:10,480 --> 00:56:18,000
and the consistency of our story reinforces our understanding and in our logic in a way that

453
00:56:18,000 --> 00:56:23,280
gives us belief in understanding of the things that we're doing and the answers that we're getting

454
00:56:24,640 --> 00:56:32,640
it's a little poetic but the but it allows you to start thinking that like water can be used in

455
00:56:32,640 --> 00:56:39,920
computing gravity can be used in computing mechanical structures can be used in computing

456
00:56:39,920 --> 00:56:45,200
DNA can be used in computing like computing is all around us and it's it's really the the

457
00:56:45,200 --> 00:56:50,960
analogy the stories that we use to construct um and the mathematical themes and theories behind

458
00:56:50,960 --> 00:56:56,640
this those those properties that kind of really make it happen so

459
00:57:03,520 --> 00:57:05,680
yeah that's all true

460
00:57:06,400 --> 00:57:07,280
um

461
00:57:11,200 --> 00:57:21,840
you can make a computer out of pneumatic vows or water vows and people did before electronics

462
00:57:21,840 --> 00:57:31,440
were available but the computing that is all around us doesn't do what i would call general

463
00:57:31,520 --> 00:57:42,480
purpose computing in general physical properties tend to be smooth and continuous and in that sense

464
00:57:42,480 --> 00:57:49,120
they're a very limited form of computation for example a slide rule or a caliper you can be

465
00:57:49,120 --> 00:57:56,160
used to multiply numbers but only in it only in a very very limited way making a turing machine

466
00:57:56,160 --> 00:58:01,680
or a turing complete machine or von Neumann machine or land to calculate machine out of a

467
00:58:01,680 --> 00:58:11,280
slide rule would be very hard um and so the electronic computer and the the attempts to

468
00:58:11,280 --> 00:58:23,120
make mechanical computers which famously Lady Ada Babbage did um created a new era of uh computation

469
00:58:26,320 --> 00:58:33,040
i agree with that there's there's still a open question of can you build an

470
00:58:33,040 --> 00:58:39,840
a general purpose analog computer um and then the the corollary v can you build a general

471
00:58:39,840 --> 00:58:47,280
purpose uh neural network um with the drill with the neural fabric um and which is currently a very

472
00:58:47,280 --> 00:58:55,840
hot topic right now in AI research um i agree but that question is bigger than i can address

473
00:58:56,160 --> 00:59:06,080
in this talk one thing i think it's under appreciated i would also want to bring up

474
00:59:06,080 --> 00:59:12,000
is that um the advances in computing that we're currently seeing have allowed us to tackle

475
00:59:12,720 --> 00:59:20,320
problems that were previously on we were unable to really address um i think that's i think that's

476
00:59:20,320 --> 00:59:28,960
going to open up new areas in biology in physics and in uh and i'm just any of like the the big

477
00:59:28,960 --> 00:59:34,160
the bigger world out there and the small world out there so i think that's i think it's under

478
00:59:34,160 --> 00:59:41,600
appreciated because um ten years ago we couldn't model um with the fidelity that we had uh that

479
00:59:41,600 --> 00:59:46,160
we can today with a number of variables and the number of um factors

480
00:59:49,120 --> 00:59:51,440
yep that's correct

481
00:59:55,040 --> 00:59:56,560
does anyone else have a comment

482
01:00:03,120 --> 01:00:09,040
um i just i think it's really cool to think about and uh lauren says first comment made me think of

483
01:00:09,040 --> 01:00:14,880
this it's really cool to think about the fact that all of these well most of these equations or

484
01:00:14,880 --> 01:00:21,120
calculations that are you know given examples here they have been around since ancient times like

485
01:00:21,120 --> 01:00:29,360
these were you know the the end notation wasn't really developed until later but the the like

486
01:00:29,360 --> 01:00:38,480
core idea can be traced back to you know we're talking like you know bc yeah and it's how how

487
01:00:38,480 --> 01:00:46,400
we've kind of evolved the use cases of these equations to for computational purposes so instead

488
01:00:46,400 --> 01:00:52,720
of us using these equations ourselves we have machines now that do it for us um but a lot of the

489
01:00:52,720 --> 01:01:01,680
earlier uses of them were just you know obviously we think of like physics and astronomy um but even

490
01:01:01,680 --> 01:01:08,480
before then it was kind of just this almost like pondering of what if so what if i take

491
01:01:08,480 --> 01:01:15,200
these numbers and do this what happens um so these very very ancient ancient calculations that

492
01:01:15,840 --> 01:01:21,200
are very much a part of our modern life in a big way we wouldn't we wouldn't have modern life today

493
01:01:21,200 --> 01:01:29,760
without them yes i mean just just think of how humanity's power was expanded by the development

494
01:01:29,760 --> 01:01:39,040
of those mathematical algorithms before there were computers right i mean you know before that you

495
01:01:39,040 --> 01:01:47,920
had uh questions that that we would think well that's a computable answerable question and people

496
01:01:47,920 --> 01:01:54,320
might not know how to answer the question right they might not know how what's the area of a sphere

497
01:01:54,960 --> 01:02:00,560
right they might not know what's the area of a cone they might not know that if you have a right

498
01:02:00,560 --> 01:02:06,480
triangle the square of the length of the hypotenuse is equal to the sum of squares of the two sides

499
01:02:06,480 --> 01:02:11,680
although that's been known for a long time presumably there was some time in the past when

500
01:02:11,680 --> 01:02:20,640
it wasn't known right um and so that gets back to my point computer programming is a form of

501
01:02:20,640 --> 01:02:31,280
mathematics that brings order out of chaos and it it expands our power and to me the computer

502
01:02:31,280 --> 01:02:37,440
is an extension of the human brain it's not a replacement it's an exo brain if you will just

503
01:02:37,440 --> 01:02:46,960
the way tony stark's iron suit is a exoskeleton wikipedia is a part of my exo brain and i can

504
01:02:46,960 --> 01:02:53,200
use a computer to perform calculations which would be very awkward or impossible for me to

505
01:02:53,200 --> 01:03:05,920
perform in in other circumstances um so um in a very real sense it's in it both the act of

506
01:03:05,920 --> 01:03:12,800
systematizing things which weren't systematic before extends human power and the electronic

507
01:03:12,880 --> 01:03:18,640
computer which can do these things very rapidly also extends human power

508
01:03:31,840 --> 01:03:33,680
do we have any other questions or comments

509
01:03:35,600 --> 01:03:38,480
fast what's your favorite equation

510
01:03:38,480 --> 01:03:45,200
me yes favorite equation and why

511
01:03:55,120 --> 01:04:03,600
well um force equal mass times acceleration because it's a um it's a it's a second order

512
01:04:03,680 --> 01:04:10,720
differential equation which happens to be easily solvable and from which we can derive

513
01:04:12,160 --> 01:04:14,240
an extraordinary number of effects

514
01:04:24,720 --> 01:04:30,880
i have another question maybe more um kind of philosophical you started with a definition

515
01:04:30,880 --> 01:04:39,680
of what a computer is and kind of explaining it can only basically input and output numbers but with

516
01:04:40,800 --> 01:04:48,720
programming and now um AI or machine learning is there are we getting to the point where

517
01:04:49,520 --> 01:04:56,160
basically these programs or these computers can think much faster than we do i know they can

518
01:04:56,160 --> 01:05:02,000
solve equations but are is it getting to the point where they can quote unquote learn faster than us

519
01:05:02,000 --> 01:05:08,640
and how do we keep up the understanding of like you're saying a computer can only do something

520
01:05:08,640 --> 01:05:18,560
that's traceable um is there a point where maybe like in comparative to to our human reasoning

521
01:05:19,520 --> 01:05:27,440
um is there a point where we're too slow to kind of understand um these programs and machines

522
01:05:29,120 --> 01:05:34,880
well it's a really good question let me give you the answer that pro AI people give and then

523
01:05:34,880 --> 01:05:43,120
i'll tell you what i think okay pro AI people point out that although large language of models

524
01:05:43,120 --> 01:05:49,680
which is one aspect of artificial intelligence are relatively in their infancy they already

525
01:05:50,320 --> 01:06:00,480
beat human beings at standardized tests such as the graduate G the GRE and SAT and the ACT and

526
01:06:00,480 --> 01:06:07,360
they can do well on tests of biology and physics and so as my friend David Jesky has pointed out

527
01:06:08,320 --> 01:06:14,160
every time humanity has said well computers aren't really intelligent because they can't play chess

528
01:06:14,160 --> 01:06:22,080
or they can't play go or they can't um write poetry uh you know those have all fallen right like

529
01:06:22,080 --> 01:06:28,160
they didn't they do those things right and um curmudgeons like me keep saying oh well they

530
01:06:28,160 --> 01:06:32,560
aren't really intelligent even though they can answer a bunch of questions that i can't possibly

531
01:06:32,560 --> 01:06:39,600
answer okay but then i'll tell you what i think um just because it's i think the honesty is worthwhile

532
01:06:39,600 --> 01:06:48,160
i mean sure an AI could beat me at a biology test but an AI has had an infinite amount of time to

533
01:06:48,160 --> 01:06:59,200
learn and to it it's an open book test and AI can't compete with me at all in any real problem

534
01:06:59,200 --> 01:07:06,400
that it hasn't had a bajillion cycles of 50 gigawatts of power to study ahead of time

535
01:07:07,360 --> 01:07:11,760
yeah you know um so

536
01:07:14,960 --> 01:07:25,680
i don't accept artificial intelligence as thinking and being able to learn things at all

537
01:07:26,000 --> 01:07:33,120
now obviously you can build a classifier right like you could classify leaves and it'll tell

538
01:07:33,120 --> 01:07:38,080
you what kind of tree it came from better than i can personally remember the shape of leaves

539
01:07:38,080 --> 01:07:46,400
you know to do it it would beat me at that task right um it would beat me at translating french

540
01:07:46,400 --> 01:07:54,880
into english but it doesn't beat me at understanding even though it can translate french into english

541
01:07:55,120 --> 01:07:57,120
better than i can

542
01:08:00,080 --> 01:08:09,280
i think the question comes down to what is what does it mean to be humans creativity

543
01:08:09,840 --> 01:08:12,080
you know novel ideas i guess

544
01:08:12,400 --> 01:08:26,160
yeah i'm i'm you know i can't claim to be more creative than an AI

545
01:08:28,560 --> 01:08:35,520
but still i i feel that all human beings have something in them which i have not yet seen in an

546
01:08:35,520 --> 01:08:43,120
AI maybe five years from now the little child that is artificial intelligence will have grown

547
01:08:43,120 --> 01:08:53,200
into something um worthy of respect you know uh and then are we gonna say switching the machine

548
01:08:53,200 --> 01:09:04,720
off as murder you know did we kill an AI when you know the power failed i i don't know i

549
01:09:05,680 --> 01:09:16,240
but at the moment i remain skeptical of these these things

550
01:09:16,480 --> 01:09:16,960
you

551
01:09:33,120 --> 01:09:41,760
thanks for your perspective and the talk is very uh interesting and informative you're welcome any other questions

552
01:09:46,720 --> 01:09:47,220
you

553
01:09:56,880 --> 01:10:01,760
okay here in none i think we'll stop the recording here

