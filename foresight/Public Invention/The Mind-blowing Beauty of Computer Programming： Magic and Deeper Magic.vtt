WEBVTT

00:00.000 --> 00:08.080
start recording. Hello everybody and welcome to the Public Invention Inventors Gathering which

00:08.080 --> 00:13.280
happens the third Thursday of every month. This is July. My name is Robert L. Reed. I'm the president

00:13.280 --> 00:18.320
and founder of Public Invention and today I'm going to be speaking on the topic of the mind-blowing

00:18.320 --> 00:27.440
beauty of computer programming.

00:35.360 --> 00:37.440
Can everybody see my screen?

00:40.320 --> 00:45.680
Yes. Okay, thank you. We have a small audience today so y'all feel free to interrupt me.

00:46.320 --> 00:51.200
I kind of have mixed feelings about this talk because although it's really close to my heart,

00:51.200 --> 00:57.040
I know there's no way I can do justice to it. I could spend a year preparing this talk and I

00:57.040 --> 01:04.800
wouldn't do justice to it. What I'm going to try to explain to you is magic and then even deeper

01:04.800 --> 01:13.120
magic and it's actually very important to me. Computer science is a new art from

01:14.080 --> 01:20.800
really the 1930s. Lady Babbage did a little bit of work before that but it really wasn't until

01:20.800 --> 01:30.240
the 1930s that it became a mathematical art so to speak. That was before the majority of

01:30.240 --> 01:37.200
electronic computers. There were still mechanical computers at that time and although it wasn't

01:37.280 --> 01:43.440
entirely obvious at that time, we now know that computer science sits at the intersection of

01:43.440 --> 01:50.560
physics and math. It also touches upon philosophy and epistemology, the study of what can be known

01:50.560 --> 02:00.160
and in a sense computer science is an extension of what is knowable. Now the fact that computer

02:00.160 --> 02:08.000
science could be considered a branch of physics is really, really deep and relates to things like

02:08.880 --> 02:15.760
astrophysics and quantum mechanics and certain other important aspects of physics.

02:16.640 --> 02:22.960
For a while it was considered sort of an extension of math and it's also that but it has its own

02:23.520 --> 02:31.280
character so it's not really considered exactly math. Unfortunately I have no hope of doing this

02:31.280 --> 02:37.440
talk justice. This is something that's really, really beautiful and I doubt I'm going to be able

02:37.440 --> 02:45.200
to convey it to you in this talk. There are no pretty pictures in this talk except one maybe

02:45.760 --> 02:51.440
and there will be a lot of oversimplifications but I am going to be talking about what I consider to

02:51.440 --> 03:01.520
be magic even deeper magic and joy. So programming and theoretical computer science are different

03:01.520 --> 03:08.720
but the same. To use modern slang theoretical computer science is the god mode version of programming

03:10.080 --> 03:17.840
but programming humble simple programming is the basis of the theoretical computer science

03:17.840 --> 03:24.960
and it's the most general tool ever that's why it's important. Of all the things that humanity

03:24.960 --> 03:30.320
has invented computer programming is not necessarily the most important or the best

03:30.320 --> 03:37.120
but it is the most general. You can use it for almost everything. Today it's needed in all the

03:37.120 --> 03:44.400
sciences all engineering and many arts and therefore I think all young people need to understand

03:45.360 --> 03:49.840
at least a little computer programming in the same way that all people need to understand a little

03:49.840 --> 04:00.160
bit of algebra. So I'd like to ask the question what is a computer? So to me a computer is a

04:00.160 --> 04:08.640
mindless machine that can only do very simple mechanical things. Now technically the word

04:08.640 --> 04:14.160
machine to a mechanical engineer means the application of force I don't mean that. I use

04:14.160 --> 04:21.440
the term to emphasize it has no creativity no slop and each step is completely predictable from the

04:21.440 --> 04:30.240
last. Now it's it's quite an extraordinary fact that a computer can really only do five things

04:30.960 --> 04:36.000
and you could you could organize these a little differently but this is the way I organized it

04:36.000 --> 04:42.320
back when I was 16 years old and I still think it's correct. It can input a number, it can store a

04:42.320 --> 04:49.840
number, it can do arithmetic on numbers, it can output a number and it can make a decision based

04:49.840 --> 04:57.760
on a number. But those numbers can be used to represent a lot of things and on the basis of

04:57.760 --> 05:07.760
these very very simple actions by building them up into an edifice of structure of the way things

05:07.760 --> 05:23.120
are organized we can do extraordinary things. So we can ask what is a program? So a program is a set

05:23.120 --> 05:30.640
or sequence of instructions for a computer which is just a machine which are executed in a particular

05:30.640 --> 05:38.000
order that can change based on what's in storage. This is also sometimes called an algorithm because

05:38.000 --> 05:44.320
it doesn't actually require a computer humanity developed algorithms for mathematics which were

05:44.320 --> 05:51.200
step-by-step procedures before computers existed. Nonetheless the nature of a program is that it's

05:51.280 --> 05:58.160
a set of instructions that are executed in a certain order that tell a computer what to do

05:58.160 --> 06:08.400
in the next step. So the first magic that this produces is that complexity and really quite a

06:08.400 --> 06:15.120
lot of complexity emerges from simplicity with the basic five things that I said even a beginner

06:15.120 --> 06:20.720
programmer can compute the factorial of a number and we're going to see that later on in this talk.

06:22.000 --> 06:27.920
Do an extraordinary thing called Conway's game of life which I'm going to show you a demonstration

06:27.920 --> 06:35.680
of which is kind of the best example of complexity rising up out of simplicity and you can also

06:35.680 --> 06:43.120
simulate a role-playing game that feels real even though it isn't real. You can create a character

06:43.120 --> 06:50.720
you say my fighter takes out his sword and wax the wizard and it feels like the wizard's really

06:50.720 --> 06:57.280
there in your fighting even though you programmed it. You know the wizard in the end is just a set

06:57.280 --> 07:04.400
of numbers and the fighter is just a set of numbers so there's almost no creativity in it.

07:05.040 --> 07:12.000
Now I have never been an educator but when I teach beginning courses in computer programming to

07:12.000 --> 07:17.760
teenagers which I've done a few times these are the three programs that I teach first.

07:18.400 --> 07:25.680
The second aspect of magic that computers allow is that they allow you to simulate physics obviously

07:25.680 --> 07:33.360
via mathematics. Mathematics is the language of physics without mathematics we can only do a little

07:33.360 --> 07:40.880
bit of physics. Now what is it that we do when we talk about physics? Well Leonard Suskin has said

07:41.200 --> 07:47.920
Leonard Suskin has said the purpose of physics is to compute is to predict the future so for

07:47.920 --> 07:54.400
example you predict the future of where a ball is going to fall if you throw it up in the air

07:55.200 --> 08:00.160
you know it's going to come down and if you're a good physicist and you know exactly how fast

08:00.160 --> 08:07.920
you threw it up you know exactly where it's going to land. These sorts of simulations

08:07.920 --> 08:17.120
can be done by a computer and in very important circumstances they succeed when math fails that

08:17.120 --> 08:25.440
is there are situations which we as a human society do not know how to solve with math

08:27.280 --> 08:33.040
very well but we can still solve them with a computer by simulating things over time.

08:33.120 --> 08:38.560
Now there are limits to that so there are problems that a computer can solve

08:39.200 --> 08:44.720
that are hard to solve any other way so the famous three-body problem which is considered to be

08:45.280 --> 08:51.600
unsolvable in math recently there was a Netflix show about it can be solved by a computer

08:52.480 --> 08:59.680
in a limited way it can simulate the position of three stars or planets or meteors in space

09:00.240 --> 09:07.520
orbiting each other over time and it can do that one millisecond at a time

09:07.520 --> 09:12.800
and it can do that for billions of milliseconds and it will be fairly accurate let's say a hundred

09:12.800 --> 09:19.200
years from now. Now some people would say that's not a solution to the problem in the sense that

09:19.200 --> 09:24.560
it's not a formula that you can write down that tells you where the planets are nonetheless it's

09:25.280 --> 09:30.560
better than any other solution that we have in the same way we can't write down a formula

09:30.560 --> 09:37.360
that describes the flow of air around an airplane but we can simulate now there's a great

09:37.360 --> 09:45.920
philosophical debate as to whether an individual neuron can be described mathematically it's

09:45.920 --> 09:52.160
unclear if neurons are actually extraordinarily complex or extraordinarily simple you can find

09:52.160 --> 09:57.600
people who will tell you either either one um but it's possible that we can simulate the action

09:57.600 --> 10:04.000
of neurons and therefore we can simulate the action of brains we can also simulate the action of

10:04.000 --> 10:10.880
waves and biological tissues and that is the reason that we have MRIs CAT scans and PET scans

10:10.880 --> 10:18.080
without those we would not be able to address the diseases that we address that way so the third

10:18.080 --> 10:23.680
magic is something that we're all familiar with you're using it right now you're seeing a picture

10:23.680 --> 10:31.040
of me and you're hearing my voice but inside a computer those are represented as little bitty

10:31.040 --> 10:37.280
numbers which are transmitted through a network and come to your computer and then are translated

10:37.280 --> 10:43.600
back into little blips of light on your screen and voltage levels on your speakers this does not

10:43.680 --> 10:50.400
take a lot of theoretical computer science but most of us enjoy computers because they can

10:50.400 --> 10:57.440
store and transmit representations of light and sound in the form of sounds and movies now coincidentally

10:58.400 --> 11:03.840
they can store every word ever written by human beings which is the basis for large language

11:03.840 --> 11:11.360
models in modern artificial intelligence so we're going to talk a little bit about

11:11.360 --> 11:15.680
programming later but I want to talk about theoretical computer science which I consider

11:15.680 --> 11:25.440
to be deeper magic so the deeper magic number one is that you can prove there are things computers

11:25.440 --> 11:34.160
can't do and can't ever do this is the basis of cryptography we've now proved there are problems

11:34.160 --> 11:41.040
that can't be solved by computers some of the cryptographic problems are simply because we

11:41.040 --> 11:46.080
don't have fast enough computers but there are other problems which can never be solved by any

11:46.080 --> 11:52.880
computer they can never be solved by any sequence of instructions no matter how fast the computer is

11:54.160 --> 12:02.480
and and that's really a mind-boggling sort of concept in my opinion so this leads to a thing

12:02.480 --> 12:08.160
called church's thesis Alonzo church was an american logician who worked in the 30s

12:08.720 --> 12:16.240
um the computation done by modern computers are probably the only kind of computations

12:16.240 --> 12:23.920
that can ever be done now this is called church's thesis because it cannot really be proved um so

12:23.920 --> 12:34.640
it's a thesis rather than a a proof so we have several different models of computation one is

12:34.640 --> 12:41.280
the von Neumann machine which is um very similar to the electronic machines that we have so my

12:41.280 --> 12:48.000
macintosh computer would be closest to a von Neumann machine there's the Turing machine which

12:48.000 --> 12:52.720
has been made famous by movies which was invented a little earlier than the von Neumann machine

12:53.840 --> 12:59.840
our computers today are not shaped like Turing machines uh but they're uh similar and then

12:59.840 --> 13:06.000
there's a very unappreciated form of computation called the lambda calculus and the interesting

13:06.000 --> 13:13.920
thing is that you can simulate each of these computers with the other so the lambda calculus

13:13.920 --> 13:18.800
is powerful enough to simulate a Turing machine a Turing machine can simulate a von Neumann

13:18.800 --> 13:25.680
machine and a von Neumann machine can simulate the lambda calculus so you get uh what can be

13:25.680 --> 13:32.320
described as a trippy loop in that everything is powerful enough to simulate the other so none

13:32.320 --> 13:40.560
can be more powerful than the other now is that the only kind of computation that can exist in the

13:40.560 --> 13:47.840
world well we don't really know but that's very strong evidence that there is no other

13:47.840 --> 13:55.440
form of computation that there is no other way to do it now some people would argue that biological

13:55.520 --> 14:02.160
brains and analog computation are a little asterisk to this and that quantum computing

14:02.160 --> 14:08.880
kind of nibbles at the edges of this a little bit but fundamentally this is accepted by most people

14:09.920 --> 14:15.680
so the deeper magic of theoretical computer science is what i call the dismal deep magic

14:16.400 --> 14:26.880
so it may be that thought and computation are the same it may be that human brains cannot

14:26.880 --> 14:32.640
think anything that can't be thought by a computer and it may be that the sex success

14:32.640 --> 14:39.040
of artificial intelligence proves not that machines are intelligent but that humans are dumb

14:40.000 --> 14:48.800
right it may not be that artificial intelligence is somehow coming alive or getting a soul spark

14:48.800 --> 14:54.560
or having consciousness it may be that that we're learning that our own brains are actually not

14:54.560 --> 15:01.120
capable of very much now i hope that's not the case but uh it's it's certainly an interesting

15:01.120 --> 15:07.120
philosophical point so there's an even deeper magic and there's there's no way i can really

15:07.840 --> 15:13.840
explain it in this uh talk if you don't understand it but there's a problem in computer science

15:13.840 --> 15:22.240
called p is equal to np which is a question is p equal to np p is the set of problems that can

15:22.240 --> 15:28.400
be solved in polynomial time np is the set of problems that can be solved in what's called

15:28.400 --> 15:33.680
nondeterministic polynomial time if you're a beginner there's no way i can explain this in

15:33.680 --> 15:41.600
this talk but uh i want what i want to point out is that p equal np is the most important

15:41.600 --> 15:47.840
problem known to humanity today in movies and so forth you sometimes hear about the remand

15:47.840 --> 15:56.080
hypothesis remand hypothesis is chump change compared to p equal np if humanity could show

15:56.080 --> 16:02.000
that p is equal to np which is not obvious that it is most people think it isn't then the world

16:02.000 --> 16:07.520
would change because in practice we could compute things efficiently which we could never compute

16:07.520 --> 16:16.240
before some things would still remain out of reach however and fundamentally this asks the question

16:16.240 --> 16:22.800
if you can verify something efficiently is there always a way to compute it efficiently

16:23.920 --> 16:31.200
and the answer is not obvious the greatest mathematician computer scientist and even

16:31.200 --> 16:38.320
physicist in the world have been working on this problem for 40 years and uh in fact i would argue

16:38.320 --> 16:46.560
they haven't actually made very much headway on it now the final really deep magic is information

16:46.560 --> 16:54.240
theory information theory is where theoretical computer science overlaps with physics and everything

16:54.240 --> 17:00.480
i say here has to be an oversimplification has to be taken with a grain of salt but nonetheless

17:01.680 --> 17:08.560
it's very important to understand information theory is closely related to the idea of entropy

17:08.560 --> 17:14.320
and that is the laws of thermodynamics and conservation of energy and the fact that

17:16.080 --> 17:24.320
the universe in a sense is running down that we're moving towards a less interesting less

17:24.320 --> 17:31.360
concentrated state of energy that everything is always smoothing out and becoming more boring

17:31.360 --> 17:38.720
so to speak information theory is independent of computers although we didn't know that

17:39.840 --> 17:47.600
50 years ago and it applies to many physical processes for example the nyquist limit of

17:47.600 --> 17:55.760
the foyer transform but also really fundamental things like how black holes work are related to

17:55.760 --> 18:04.000
information theory in a way which i only partially understand i partially understand this so it's

18:04.000 --> 18:12.400
kind of true that energy is equal to information and it's kind of true that information is equal

18:12.400 --> 18:20.080
to entropy now obviously this is an oversimplification because entropy is not energy entropy is the

18:20.080 --> 18:27.600
opposite of energy nonetheless in very special circumstances information is similar to energy

18:27.600 --> 18:35.360
and in different circumstances information is similar to entropy so now we can ask the really

18:35.360 --> 18:40.400
fundamental question which which i want everyone especially if you're a beginner here to understand

18:40.480 --> 18:48.960
and be intrigued by it what does a programmer do i've believed for a long time that the job of a

18:48.960 --> 18:58.880
programmer is to create order out of chaos so from uh long before the birth of christ uh there was a

18:58.880 --> 19:06.640
famous hymn to Zeus by cliente's and it begins chaos to be his order and in the middle of it in

19:06.640 --> 19:11.120
one translation obviously it was written in greek you can say but you know how to make the

19:11.120 --> 19:16.400
crooked straight and to bring order to the disorderly even the unloved is loved by you

19:17.120 --> 19:23.920
the poet is speaking to Zeus for you have so joined all things into one the good and the bad

19:23.920 --> 19:31.280
that they all share in a single unified everlasting reason and of course the christian and judaic

19:31.280 --> 19:37.680
bible begins let there be light that's what a programmer does they bring light out of darkness

19:37.680 --> 19:46.320
in order out of chaos so fundamentally a program systemizes that which was not

19:47.200 --> 19:56.080
systemized previously so the main tool of computer programming is could be called abstraction

19:57.040 --> 20:04.320
it's not that easy to understand what it means in this this context programs have subroutines

20:04.320 --> 20:12.320
or functions which can be reused the reuse of a subroutine always cost a tiny amount of time

20:12.320 --> 20:20.480
and also a tiny amount of electricity but once a subroutine is written it can be used over and

20:20.480 --> 20:30.480
over again and it never wears out just like the number 37 never wears out in a sense subroutines

20:30.480 --> 20:36.800
and mathematics are stronger than steel and diamonds steel and diamonds and granite

20:36.800 --> 20:44.480
eventually wear out but math and subroutines don't abstraction is the main tool for making

20:44.480 --> 20:50.240
long programs short and is thus closely connected with bringing order out of chaos

20:51.120 --> 20:56.880
factorial the first program that programmers should learn teaches abstraction through recursion

20:57.600 --> 21:03.920
now there's a thing called lambda lifting that i recommend um an interested student

21:03.920 --> 21:11.280
read the wikipedia article on lambda lifting which is sort of the formal way in which abstraction

21:11.280 --> 21:17.760
enters computer programming but most programmers will will not understand lambda lifting they

21:17.760 --> 21:26.240
will instead think of when i create a subroutine i am creating abstraction which i can reuse again

21:26.240 --> 21:35.040
and again so my own personal style of programming is based on something that paul graham said he

21:35.040 --> 21:41.760
wrote an essay called concision is power and i view the act of programming as being almost

21:41.760 --> 21:48.160
their exceptions the same as trying to create the shortest most compact representation of something

21:48.800 --> 21:55.360
and thus in a way creating the most abstract version of a sequence of instructions to accomplish

21:55.360 --> 22:02.960
something now functional programming is a style in which subroutines are side effect free this

22:02.960 --> 22:08.560
helps to bring order out of chaos because of something technical called referential transparency

22:09.200 --> 22:14.960
and it's the most abstract way of working because it means that a function can be used in any

22:14.960 --> 22:21.200
context and always means the same thing now this is debatable we don't have time to go into it uh

22:21.200 --> 22:28.160
some people don't like functional programming as much as i do another way of expressing this is

22:28.160 --> 22:38.320
a principle called dry or do not repeat yourself in a computer program there should never really be

22:39.440 --> 22:46.080
two lines that are the same there should never be two subroutines that are the same if you find

22:46.080 --> 22:53.920
yourself writing the same code it should become a subroutine and this principle can be applied to

22:53.920 --> 23:00.560
enormous aspects of computer programming you should not have duplication in your data just as

23:00.560 --> 23:08.800
you should not have duplication in your instructions and in many many circumstances what people do is

23:08.800 --> 23:14.320
they copy and paste code from somewhere and in so doing they're violating the dry principle

23:14.320 --> 23:21.440
and after years programs become big fluffy disorderly things where things are almost the

23:21.440 --> 23:26.960
same but not quite in different places and so forth and that's very poor software engineering

23:28.400 --> 23:35.680
but it takes beginners years to fully understand this and to fully understand how to avoid it

23:37.440 --> 23:42.880
so now i'd like to talk about the very first program that i think everyone should write

23:43.920 --> 23:49.840
the first program is called factorial and it's written with an exclamation point

23:50.720 --> 23:56.800
when i was in in college there was a young man who didn't know was called factorial so when he saw

23:56.800 --> 24:04.160
in factorial he said called it in as if as if it's very emphatically the way you you say in

24:05.200 --> 24:14.400
in fact in bang sometimes pronounced bang or in factorial or in exclamation point

24:15.280 --> 24:23.760
is used in the famous formula from probability that's sometimes pronounced in choose k it gives

24:23.760 --> 24:31.120
you the ways to choose k element the number of ways to choose k elements from a set of in objects

24:31.120 --> 24:38.320
this is all important to poker players and all kinds of probability and all kinds of

24:38.400 --> 24:44.960
mathematics but the definition of factorial itself is really really simple and this is it

24:46.720 --> 24:51.920
right here this is actually in javascript we could take this and we could run it okay now

24:52.960 --> 25:01.360
um i learned this so long ago it no longer seems weird to me but some of you reading it

25:02.240 --> 25:07.600
may not have learned this and i remember how hard it was for me to understand when i was about

25:08.400 --> 25:15.680
18 or 19 and i was first introduced to this this concept so what this code says is that

25:15.680 --> 25:24.000
the function that we call factorial which is in bang so to speak has a mathematical definition

25:24.640 --> 25:35.520
if n is equal to zero the answer is one if n is not equal to zero the answer is in times

25:35.520 --> 25:48.240
the factorial of n minus one now this is a trippy loop factorial is being defined in

25:48.960 --> 25:56.080
terms of itself how can the computer know what factorial means when we're telling it what factorial

25:56.080 --> 26:04.080
means right now it's not obvious now to many people in this audience it may be obvious but

26:04.080 --> 26:10.480
when i was a boy this was not obvious to me okay you you might ask the question well how on earth

26:10.480 --> 26:18.400
can the computer ever know how to do factorial of n minus one when we're defining it in terms of

26:18.400 --> 26:25.760
itself it looks like a trick okay and it takes a while to understand it and in fact the answer is

26:26.400 --> 26:33.760
this only works if you call factorial with a smaller number in the body of the function

26:34.720 --> 26:40.320
so that the problem is always somehow getting simpler and eventually it gets down to zero

26:40.320 --> 26:47.280
if that is not true you create an infinite loop infinite loops are much worse than trippy loops

26:48.080 --> 26:53.920
so in fact you could say that this function has a bug if you called this was minus one

26:54.640 --> 27:00.320
it would run forever because it would multiply minus one by the factorial of minus two

27:01.120 --> 27:06.880
which would be minus two times the factorial of minus three which would be minus three times

27:06.880 --> 27:12.720
the factorial of minus four and that number would never become equal to zero and it would never stop

27:13.680 --> 27:24.400
the second program is a program called conways game of life and it was specifically designed

27:24.960 --> 27:35.760
to show how complexity arises out of simplicity okay and it at one kind of artificial level

27:35.760 --> 27:42.560
it's a simulation of biological processes these four rules are the only rules it has

27:43.120 --> 27:46.960
and I believe this is the second computer program which every beginner should write

27:47.840 --> 27:54.480
okay it's played on a grid like a chessboard but the chessboard is considered not to be eight

27:54.480 --> 28:00.400
by eight but to extend as far as you want it to so it's played on a square grid and each grid is called

28:00.480 --> 28:06.640
grid cell square is called a cell okay and a cell is either live or dead

28:07.760 --> 28:13.600
and there's a clock that ticks and one generation leads to the next generation

28:13.600 --> 28:19.520
so you start with some pattern and then you start generations and the rule for each cell

28:19.520 --> 28:27.840
is simply these four rules in a live cell with fewer than two live neighbors that's the cells

28:28.320 --> 28:35.840
the eight cells around it that touch it dies as if by underpopulation I prefer to think of it as

28:35.840 --> 28:42.320
loneliness it dies of loneliness any live cell with two or three live neighbors lives on to the

28:42.320 --> 28:50.880
next generation it's happy any live cell with more than three live neighbors dies by overpopulation

28:50.880 --> 28:58.960
or crowding and then here is a bit of magic any dead cell with exactly three live neighbors

28:58.960 --> 29:10.800
becomes a live cell as if by reproduction okay simple rules that produce almost unbounded complexity

29:11.360 --> 29:19.440
so now I'd like to show you an example of this is Conway's game of life you guys can do this

29:19.440 --> 29:24.320
I'm randomly putting this here I don't know what I'm doing I'm just clicking on some numbers so

29:24.320 --> 29:34.320
you see this consists of a grid of squares and each square is considered a cell yellow means it's alive

29:37.280 --> 29:42.320
gray means it's dead now when I click next it's going to do a generation

29:42.960 --> 29:51.200
so some cells will died and a few cells came into existence and the pattern changed

29:52.000 --> 30:00.880
and now the pattern is going to change again and again and again and again and now I can simply

30:00.880 --> 30:03.120
start running it and we'll see what happens

30:13.280 --> 30:16.400
not done yet

30:18.240 --> 30:24.880
it's not done yet it's not done yet it's not done yet now it's done

30:27.920 --> 30:37.040
so how could that complexity that you just saw arise out of those four rules

30:38.000 --> 30:45.280
that is the thing which is of sort of paramount importance to mathematicians and related to

30:45.280 --> 30:58.400
what I'm talking about the the Iraq the ability of simplicity to give birth to complexity okay and

30:58.400 --> 31:04.400
then finally an exercise that I think all beginning computer programmers should do is to write a very

31:04.640 --> 31:12.800
simple sort of fantasy role-playing game that has characters in it and you can have the characters

31:12.800 --> 31:18.800
fight like you do in Dungeons and Dragons so that a fighter can whip out a sword and say I attack

31:18.800 --> 31:23.840
the wizard and I strike the wizard with my sword and the wizard's health goes down and then the

31:23.840 --> 31:32.080
health the wizard cast a magic spell uh perhaps to catch the um fighter in a web which decreases

31:32.080 --> 31:39.200
their ability to strike in the future now um the thing about this is you play it it's simple

31:40.400 --> 31:51.120
it's fun and it feels alive but you programmed it you know very well the wizard is not alive the

31:51.120 --> 31:58.880
wizard is just a subroutine the wizard is literally 10 or 15 lines of code that you yourself programmed

31:59.680 --> 32:06.320
representing only with numbers now if you don't want to do that you can think of a

32:06.320 --> 32:11.360
complicated game uh an expensive game like Minecraft or something like that accomplishing

32:11.360 --> 32:20.960
the same thing it feels real even though we know in the end it is nothing more than a complicated

32:20.960 --> 32:30.720
series of the five operations I began this talk with so programming is almost reason

32:32.480 --> 32:39.280
but not quite it is almost human reason but it isn't exactly programming does not tell the poet

32:39.280 --> 32:45.120
what word to select or the musician how to play the note perfectly or the painter how the brush

32:45.120 --> 32:51.200
stroke should go but nonetheless the act of programming is very close to the act of human

32:51.200 --> 32:59.680
reasoning for 100 years coming up on 100 years now literally we've been making programming tools

32:59.680 --> 33:07.440
more powerful so for example john von Neumann did not believe in compilers he believed it was a

33:07.440 --> 33:13.040
sign of mental weakness if people had to use compiled computer languages he thought you should

33:13.040 --> 33:20.400
program them sort of only with the the most minimal set of instructions um he was weird

33:22.240 --> 33:28.880
each increase in the strength of the programming tools has not made programming obsolete it has

33:28.880 --> 33:35.280
not decreased the number of people making gainful living by being programmer it has made programming

33:35.280 --> 33:42.000
more important and given gainful employment to more people so I personally do not believe anyone

33:42.000 --> 33:48.160
should fear that AI will replace programming that it's the same as saying AI will replace human

33:48.160 --> 33:57.200
reasoning AI will become a tool used by programmers now I have not used it I don't use co-pilot or

33:57.200 --> 34:03.760
any AI tools for that but at some point I may have to learn how to do that on the other hand I do

34:03.760 --> 34:10.960
think we should fear killer robots I'm much more worried about killer robots than I am uh my ability

34:10.960 --> 34:19.760
to think being replaced by an artificial intelligence so there are a lot of joys associated with

34:19.760 --> 34:27.440
computer programming and um I got to experience these when I was a child almost I started programming

34:27.440 --> 34:32.400
when I was 13 not very well it took me a long time to learn a lot I didn't have anyone to learn from

34:32.960 --> 34:38.560
um I wish every child could experience this joy I wish everyone could it could do these

34:39.280 --> 34:43.280
now there are other ways to learn these joys but computer programming is a darn good way to

34:43.840 --> 34:49.680
to do it as Lee and Nardo Da Vinci said the joy of understanding is one of the greatest pleasures

34:49.680 --> 35:00.480
that humanity can have and computer programming is all about understanding often you begin in

35:00.480 --> 35:07.040
confusion and you move towards understanding because you bring order out of chaos you bring

35:07.040 --> 35:15.120
light out of darkness you start from a situation of not understanding a problem and then you understand

35:15.120 --> 35:21.920
it there's the joy of discovery which I think is quite different that's where you learn something

35:21.920 --> 35:28.960
surprising um sometimes you discover surprising problems sometimes you discover surprising

35:28.960 --> 35:35.680
solutions sometimes like in the case of Conway's game of life you discover surprising things which

35:35.680 --> 35:39.920
are neither problems nor solutions they're just surprising things about the mathematical world

35:39.920 --> 35:47.840
in which we live and then perhaps the greatest joy is the joy of creation you can write a program

35:47.840 --> 35:53.920
you can create something out of nothing which did not exist before and something important

35:53.920 --> 36:01.040
as well of course you can do that by knitting a sweater but one form of creation is writing a

36:01.040 --> 36:08.800
computer program and then you can experience the joy of mastery the joy of moving from a state of

36:08.800 --> 36:14.880
not being very good at something to being pretty good at it um I do not consider myself to have

36:14.880 --> 36:22.080
mastered computer programming uh I'm still learning I I wish I had time to learn more I I'm

36:22.080 --> 36:29.360
considering myself a journeyman programmer so to speak um my one of my heroes Kent Beck said

36:29.360 --> 36:35.440
that confusion should be cherished because it precedes enlightenment and computer program

36:35.440 --> 36:41.760
it is all about moving from a state of confusion to a state of enlightenment and then finally

36:41.760 --> 36:44.720
there's the joy of sharing um

36:49.680 --> 36:55.840
in a way there are not many programs in the world there is only one universal program

36:56.560 --> 37:01.840
it is splintered between my computer and Lawrence's computer and Christina's computer

37:01.840 --> 37:08.160
and Morena's computer but in a way there's really only one computer program in the whole world and

37:08.160 --> 37:14.400
we are all writing parts of it we are writing little bitty parts of it so we are all sharing

37:14.400 --> 37:20.880
in a given enterprise for many people a great joy that they get to experience in college

37:20.880 --> 37:27.520
and I and I wish everyone got to go to college I know some people don't is to um share their

37:27.520 --> 37:33.360
programs with other people sometimes in a classroom setting sometimes not I remember uh one time I

37:33.360 --> 37:37.600
was in a graphics class at the University of Texas when I was in graduate school and my friend

37:37.600 --> 37:44.320
Steve Benz uh put up on his screen a graphic programming and he programmed a little airplane

37:44.320 --> 37:51.520
to fly around the tower of a representation of a tower of an airport and it was it was an

37:51.520 --> 37:58.080
astonishing thing to to have accomplished quite quite beautiful uh I really enjoyed that when I

37:58.080 --> 38:06.240
was at Rice University uh there was there was a student there uh who was quite unusual and I would

38:06.240 --> 38:12.800
walk by his terminal and on it there was a weird glyph and I couldn't figure out what it was so

38:12.800 --> 38:20.400
you know I asked the guy and he said well it's elvish he had created an ascii art representation

38:20.400 --> 38:27.040
of the letter the elvish characters that Tolkien had created which are called tingwar um an example

38:27.040 --> 38:35.040
of nerdy stuff uh but it was more fun because it was shared and then finally and my talk is closing

38:35.040 --> 38:43.520
now um there's the joy of meaning and this is the deepest thing to me public convention gives

38:43.520 --> 38:49.440
everything it does to the whole world we don't keep anything secret everything we do is shared

38:49.440 --> 38:56.880
through open source licensing uh we've been trying to save people's lives for a while now

38:56.880 --> 39:03.040
through global medical stuff I doubt anyone's life has ever been saved by one of our inventions

39:03.040 --> 39:10.160
although it is our goal and we're working towards it things take time to ripen uh I I have faith that

39:10.160 --> 39:17.440
it will eventually happening programming is an important part of our work almost everything

39:17.440 --> 39:22.800
now requires computer programming programming is part of our work and our work is meaningful

39:23.360 --> 39:28.240
and therefore the programming of meaning so thank you for your support of public

39:28.320 --> 39:35.360
convention thank you for listening I've got a few references here which people can look up

39:37.280 --> 39:42.560
on google if they want and I will now open the floor to questions

39:49.360 --> 39:53.440
well I should have been here at 8 and for some reason I thought it started at 8 30

39:53.440 --> 39:58.080
oh okay Victoria Christina's raised your hand go ahead Christina

39:59.360 --> 40:06.560
that was an excellent presentation um I've never actually kind of thought about that all laid out

40:06.560 --> 40:11.120
in such a way uh I feel like it's it's one of those programming in general is one of those

40:11.120 --> 40:15.600
things that I've I've been around for a long time and have a very very very tiny bit of

40:15.600 --> 40:22.000
experience with myself but if you're around it so much you often don't necessarily think of the

40:22.000 --> 40:27.840
origins of it um but I did have a question that came up and it's something that I never

40:28.560 --> 40:35.920
thought of much myself um and it's I love the slide on factorials by the way so in calculating

40:36.480 --> 40:45.360
um factorials you the two things that come to mind are recursive function versus iterative

40:45.360 --> 40:52.240
so I was wondering if um like from a programming standpoint like different characteristics or

40:52.240 --> 40:58.720
use cases specific to either using a recursive or iterative approach um in programming

41:01.680 --> 41:08.720
yeah it's a good it's a good question it's a really good question because um in fact

41:09.600 --> 41:18.560
you can prove in a sense that you you don't have to do this recursively so what Christina's

41:18.560 --> 41:25.040
saying is this self-reference the fact that factorial is defined in terms of factorial is called

41:25.520 --> 41:34.720
um recursion you could write um factorial as what's called a loop and you would count down

41:35.280 --> 41:42.000
and you would examine the value in and you you would count across in and and and do it that way

41:42.720 --> 41:54.320
um so you don't have to do it this way except there are things over time which become so

41:54.320 --> 42:02.480
complicated it would be almost impossible to do all of them um iteratively for example you could

42:02.480 --> 42:08.720
be working on a solving a differential equation you know or some very very big thing and you're in

42:08.720 --> 42:14.640
the middle of it and you're down in the middle of a computation and now you have to do another

42:14.640 --> 42:23.920
factorial right you you have to have subroutines and you have to have abstraction in um in doing

42:23.920 --> 42:32.560
those things and there there are some things which um in order to not define them recursively

42:32.560 --> 42:38.480
you would almost have to stand on your head like like you could do it there's a mathematical proof

42:38.480 --> 42:44.960
that you don't have to have this because after all this programming language is being compiled

42:44.960 --> 42:50.960
into something which is just a set of numbers which is doing the same thing but it would become

42:51.040 --> 42:58.400
unnatural it would become so complicated that you almost couldn't think about it and it would get in

42:58.400 --> 43:06.400
the way of your thinking about it and and a proof of that is the formula on the right hand side of

43:06.400 --> 43:15.120
this page right here we have n bang and it's expressed in terms of k bang and n minus k bang

43:15.120 --> 43:24.880
mathematicians are using this you know using this sort of thing uh referentially as a subroutine in

43:24.880 --> 43:30.960
the same way and if you go to the wikipedia page you will see it defined both iteratively and

43:30.960 --> 43:39.520
recursively i don't know if that answers your question or not yes it does um and kind of as a

43:39.520 --> 43:47.360
follow-up to that i don't want to i don't want to hog all the question time but um are there so

43:47.360 --> 43:54.960
from a computer programming standpoint are there more resource constraints with one versus the other

43:54.960 --> 44:01.760
so if so taking an iterative approach versus recursive like what does that what does it mean

44:01.760 --> 44:10.640
for the programmer when you're coming to choose between the two okay so there are people who will

44:10.640 --> 44:23.920
tell you that an iterative approach is more efficient because a um recursive approach appears on the

44:23.920 --> 44:33.200
surface to use more memory okay and so there are times when an iterative approach would be better

44:33.840 --> 44:39.920
and let me let me return to this and try to explain this in the in the deepest possible way

44:39.920 --> 44:48.640
okay so for example the way this is implemented in a computer in a in as the languages compile

44:49.360 --> 44:56.800
it's turned from this representation into a different representation and you almost can't

44:56.800 --> 45:03.920
discuss it without talking about what's called a stack frame and whenever you make a call you push

45:03.920 --> 45:10.960
onto the stack which is called because it's like a cafeteria tray uh in a cafeteria you know you have

45:10.960 --> 45:17.200
a spring-loaded stack of trays sometimes you you push things onto the stack and you and you build

45:17.280 --> 45:24.000
things up and then you take things off the stack okay you push the variables here onto this the

45:24.000 --> 45:33.920
stack well however many calls you make uh each one of those has to have a memory representation

45:34.720 --> 45:43.920
you can run out of memory okay now you can do it it appears on the surface that you can do it more

45:43.920 --> 45:52.480
efficiently iteratively because you wouldn't have that extra space however this program the way it's

45:52.480 --> 45:59.840
written is what's called tail recursive in the sense that the the use of factorial is the last

45:59.840 --> 46:07.120
thing in what's being done here so the compiler knows that and can automatically implement an

46:07.120 --> 46:17.520
efficient way of doing it so in practice it doesn't matter okay now another way that i if i wanted to

46:17.520 --> 46:24.000
i could attack what you're saying is i could say yes it might be more efficient in terms of computer

46:24.000 --> 46:33.520
instructions but computer instructions are cheap what's hard is the clarity of the program to make

46:33.520 --> 46:40.720
it in an ordered fashion and so i would be very low to write it in a more efficient way

46:40.720 --> 46:45.360
if it decreased the clarity of the program from a human understanding point of view

46:45.360 --> 46:48.320
there's another saying in computer science which is that

46:52.640 --> 46:57.440
premature optimization is the root of all evil that was that's famously said by

46:57.600 --> 47:05.040
Donald Knuth a very important computer scientist so let me let me just show you here what happens

47:06.560 --> 47:13.760
so over here on the right this is actually a the development tools which are built into

47:13.760 --> 47:22.480
the chrome browser and it runs javascript and so i can paste this pro oops i could paste this program

47:22.480 --> 47:33.040
in here but it's apparently please type allow posting in here so it's got a nice security feature

47:33.040 --> 47:43.760
won't let me post it in oh allow pasting okay that

47:46.880 --> 47:49.200
well i'll do it the old-fashioned way i'll type it

47:52.480 --> 48:00.640
so i already typed this in okay so this is javascript this is completely legal javascript

48:01.360 --> 48:12.480
okay and i can call factorial of zero and it's one and i can call factorial of 10 and it'll be a big

48:12.480 --> 48:20.880
number and i can call factorial of 20 and i can call factorial

48:26.240 --> 48:33.200
let's say 100 this may not work okay and it kind of works and it's a very very very very large

48:33.200 --> 48:43.280
number right um now eventually we'll run out there's a bug in this program in a sense factorial is

48:43.280 --> 48:49.440
not actually defined on negative numbers but if i run this on a negative number as i said before

48:50.240 --> 48:54.640
it will go into an infinite loop so we're going to see what happens when it does that

48:55.600 --> 49:05.440
so what it actually says is maximum call stacked size exceeded what it did is it kept going until

49:05.440 --> 49:12.000
it ran out of its own memory now it's smart so before it crashed my computer it caught it

49:12.560 --> 49:15.280
and it said oh i'm not going to let you make that call again

49:15.280 --> 49:26.240
that may be more than you wanted to know about that no no and then sorry so one last thing

49:26.240 --> 49:33.040
would be so would you say that recursion then is more suitable for problems that could be broken

49:33.040 --> 49:38.160
down into similar sub problems and the thing that first comes to mind for me is like some

49:38.160 --> 49:44.720
of the sorting algorithms whereas when i think of iteration i think of more suitable program uses for

49:45.360 --> 49:51.280
problems that would require repeated execution of a block code linear searches things like that

49:51.920 --> 49:58.880
yes okay so i would say yes and the best example of that if you want to google it right now is um

49:58.880 --> 50:08.000
google quicksort okay quicksort is a very simple um program here let me create a new slide um it's

50:08.000 --> 50:13.680
not necessarily the best the best sort in the world but it's it's extraordinarily simple and

50:13.760 --> 50:18.400
that's why it's done it was created by another famous computer scientist i had the pleasure of

50:18.400 --> 50:27.280
meeting uh Charles anthony robert pour who for some reason was called tony uh so more created

50:27.280 --> 50:33.680
quicksort and quicksort looks like this and i can't this is not going to be correct JavaScript

50:34.320 --> 50:37.520
quicksort of and i'll call it s is a sequence

50:38.480 --> 50:50.400
okay and what i do is i is i'll say let a be first half of s that is the first if s has 100

50:50.400 --> 50:56.480
members to be the first 50 okay and exactly how i'd do that i would depend on the exact language

50:56.480 --> 51:09.200
i'm in but let you know let b be the second half of s okay um uh now i'm forgetting it okay and so

51:09.200 --> 51:21.200
then what you do is you do a quicksort of a and then you do a quicksort of b so that those two are

51:21.280 --> 51:31.760
sorted and that that gives you back two list of 50 numbers which are each sorted and then

51:31.760 --> 51:37.040
you you merge them very simply and i maybe i'm forgetting because that would be called a merge

51:37.040 --> 51:44.240
sort instead of instead of a quicksort i think maybe quicksort finds the median uh value and

51:44.240 --> 51:48.720
takes all the lower ones and then all the upper ones and it sorts those two and then merges it

51:48.720 --> 51:54.720
back but it's fundamentally recursive in the way that you just described because you're taking a

51:54.720 --> 52:00.960
list of 100 elements breaking it into two list of 50 sorting the two list of 50 and then doing

52:00.960 --> 52:10.720
something very simple to put it back together now it can be done iteratively as well but it

52:11.680 --> 52:17.600
is probably harder to understand it than by doing it recursively so why do it

52:19.680 --> 52:25.120
that makes sense that's really cool so i i don't know you know a lot of applications i you know

52:25.120 --> 52:32.000
because i don't don't do computer programming but i do know that a lot of what's behind some of these

52:32.000 --> 52:37.760
companies that are doing really extensive gene analysis so analyzing genetic combinations

52:37.760 --> 52:43.760
and permutations they're using programs with a lot of factorial calculations involved so that's

52:43.760 --> 52:48.720
how they're discovering like different gene combinations correlate with certain syndromes or

52:50.080 --> 52:56.000
you know genetic mutations that's that's like the the first real-world case that comes from my mind

52:57.200 --> 53:04.800
well right okay so so here's something mind-blowing even the act of so to us the act of multiplying

53:04.800 --> 53:11.680
two numbers is simple and in java script it's simple you just write a star b and that multiplies

53:11.680 --> 53:18.720
two numbers together okay but as a becomes gigantic and b becomes gigantic it starts to be

53:18.720 --> 53:26.720
inefficient to multiply it the way humans multiply numbers okay of course you would never think of

53:26.720 --> 53:32.320
worrying about this until it's more than like a thousand digits on each side but the numbers you

53:32.320 --> 53:38.480
deal with in genomic combinations can can get really big there's an entire science of computer

53:38.480 --> 53:44.160
science that deals with asymptotic complexity where you try to create the most efficient algorithms

53:44.160 --> 53:52.080
you can i do not fully understand this but the most efficient way to multiply numbers is actually

53:52.080 --> 54:00.000
with the Fourier transform okay so that algorithm for multiplying very very very very large numbers

54:00.000 --> 54:08.400
is quite unnatural compared to what we as school children learn to do in our multiplication

54:08.400 --> 54:13.680
and if you were trying to compute factorial you might do the same thing and you might use

54:13.680 --> 54:18.880
approximations and then there are all kinds of all kinds of tricks to make that go faster and

54:18.880 --> 54:27.360
there's an entire science behind that which is usually not done usually computer programmers

54:27.360 --> 54:38.320
don't worry about that until they're at least out of college

54:47.920 --> 54:54.400
oh do we have any other questions i'll let other people ask questions otherwise we will be here

54:54.400 --> 54:59.920
all night with me being like what about this what about that i am always at your service christina

55:00.960 --> 55:04.800
all right i'm sure others have have questions so i'll i will let others ask them

55:15.600 --> 55:19.600
another thing i learned in graduate school is that silence is golden

55:20.320 --> 55:24.800
and often if you just wait long enough people will ask a question even though they're shy

55:32.080 --> 55:34.400
i don't really have a question but i did you have a comment though

55:35.840 --> 55:40.480
in your description of one of the things i think that i think is kind of overlooked

55:41.200 --> 55:48.400
is the root word of analog computing is i think it's shared with analogy and i like thinking of

55:48.640 --> 55:56.000
computing as an analogy that is running on base level physics or basic level reality

55:56.800 --> 56:03.840
and that that level of and what we're basically doing is creating a story that is playing out

56:03.840 --> 56:10.480
in front of us in the world around us and the story is and we we are consistent with our story

56:10.480 --> 56:18.000
and the consistency of our story reinforces our understanding and in our logic in a way that

56:18.000 --> 56:23.280
gives us belief in understanding of the things that we're doing and the answers that we're getting

56:24.640 --> 56:32.640
it's a little poetic but the but it allows you to start thinking that like water can be used in

56:32.640 --> 56:39.920
computing gravity can be used in computing mechanical structures can be used in computing

56:39.920 --> 56:45.200
DNA can be used in computing like computing is all around us and it's it's really the the

56:45.200 --> 56:50.960
analogy the stories that we use to construct um and the mathematical themes and theories behind

56:50.960 --> 56:56.640
this those those properties that kind of really make it happen so

57:03.520 --> 57:05.680
yeah that's all true

57:06.400 --> 57:07.280
um

57:11.200 --> 57:21.840
you can make a computer out of pneumatic vows or water vows and people did before electronics

57:21.840 --> 57:31.440
were available but the computing that is all around us doesn't do what i would call general

57:31.520 --> 57:42.480
purpose computing in general physical properties tend to be smooth and continuous and in that sense

57:42.480 --> 57:49.120
they're a very limited form of computation for example a slide rule or a caliper you can be

57:49.120 --> 57:56.160
used to multiply numbers but only in it only in a very very limited way making a turing machine

57:56.160 --> 58:01.680
or a turing complete machine or von Neumann machine or land to calculate machine out of a

58:01.680 --> 58:11.280
slide rule would be very hard um and so the electronic computer and the the attempts to

58:11.280 --> 58:23.120
make mechanical computers which famously Lady Ada Babbage did um created a new era of uh computation

58:26.320 --> 58:33.040
i agree with that there's there's still a open question of can you build an

58:33.040 --> 58:39.840
a general purpose analog computer um and then the the corollary v can you build a general

58:39.840 --> 58:47.280
purpose uh neural network um with the drill with the neural fabric um and which is currently a very

58:47.280 --> 58:55.840
hot topic right now in AI research um i agree but that question is bigger than i can address

58:56.160 --> 59:06.080
in this talk one thing i think it's under appreciated i would also want to bring up

59:06.080 --> 59:12.000
is that um the advances in computing that we're currently seeing have allowed us to tackle

59:12.720 --> 59:20.320
problems that were previously on we were unable to really address um i think that's i think that's

59:20.320 --> 59:28.960
going to open up new areas in biology in physics and in uh and i'm just any of like the the big

59:28.960 --> 59:34.160
the bigger world out there and the small world out there so i think that's i think it's under

59:34.160 --> 59:41.600
appreciated because um ten years ago we couldn't model um with the fidelity that we had uh that

59:41.600 --> 59:46.160
we can today with a number of variables and the number of um factors

59:49.120 --> 59:51.440
yep that's correct

59:55.040 --> 59:56.560
does anyone else have a comment

01:00:03.120 --> 01:00:09.040
um i just i think it's really cool to think about and uh lauren says first comment made me think of

01:00:09.040 --> 01:00:14.880
this it's really cool to think about the fact that all of these well most of these equations or

01:00:14.880 --> 01:00:21.120
calculations that are you know given examples here they have been around since ancient times like

01:00:21.120 --> 01:00:29.360
these were you know the the end notation wasn't really developed until later but the the like

01:00:29.360 --> 01:00:38.480
core idea can be traced back to you know we're talking like you know bc yeah and it's how how

01:00:38.480 --> 01:00:46.400
we've kind of evolved the use cases of these equations to for computational purposes so instead

01:00:46.400 --> 01:00:52.720
of us using these equations ourselves we have machines now that do it for us um but a lot of the

01:00:52.720 --> 01:01:01.680
earlier uses of them were just you know obviously we think of like physics and astronomy um but even

01:01:01.680 --> 01:01:08.480
before then it was kind of just this almost like pondering of what if so what if i take

01:01:08.480 --> 01:01:15.200
these numbers and do this what happens um so these very very ancient ancient calculations that

01:01:15.840 --> 01:01:21.200
are very much a part of our modern life in a big way we wouldn't we wouldn't have modern life today

01:01:21.200 --> 01:01:29.760
without them yes i mean just just think of how humanity's power was expanded by the development

01:01:29.760 --> 01:01:39.040
of those mathematical algorithms before there were computers right i mean you know before that you

01:01:39.040 --> 01:01:47.920
had uh questions that that we would think well that's a computable answerable question and people

01:01:47.920 --> 01:01:54.320
might not know how to answer the question right they might not know how what's the area of a sphere

01:01:54.960 --> 01:02:00.560
right they might not know what's the area of a cone they might not know that if you have a right

01:02:00.560 --> 01:02:06.480
triangle the square of the length of the hypotenuse is equal to the sum of squares of the two sides

01:02:06.480 --> 01:02:11.680
although that's been known for a long time presumably there was some time in the past when

01:02:11.680 --> 01:02:20.640
it wasn't known right um and so that gets back to my point computer programming is a form of

01:02:20.640 --> 01:02:31.280
mathematics that brings order out of chaos and it it expands our power and to me the computer

01:02:31.280 --> 01:02:37.440
is an extension of the human brain it's not a replacement it's an exo brain if you will just

01:02:37.440 --> 01:02:46.960
the way tony stark's iron suit is a exoskeleton wikipedia is a part of my exo brain and i can

01:02:46.960 --> 01:02:53.200
use a computer to perform calculations which would be very awkward or impossible for me to

01:02:53.200 --> 01:03:05.920
perform in in other circumstances um so um in a very real sense it's in it both the act of

01:03:05.920 --> 01:03:12.800
systematizing things which weren't systematic before extends human power and the electronic

01:03:12.880 --> 01:03:18.640
computer which can do these things very rapidly also extends human power

01:03:31.840 --> 01:03:33.680
do we have any other questions or comments

01:03:35.600 --> 01:03:38.480
fast what's your favorite equation

01:03:38.480 --> 01:03:45.200
me yes favorite equation and why

01:03:55.120 --> 01:04:03.600
well um force equal mass times acceleration because it's a um it's a it's a second order

01:04:03.680 --> 01:04:10.720
differential equation which happens to be easily solvable and from which we can derive

01:04:12.160 --> 01:04:14.240
an extraordinary number of effects

01:04:24.720 --> 01:04:30.880
i have another question maybe more um kind of philosophical you started with a definition

01:04:30.880 --> 01:04:39.680
of what a computer is and kind of explaining it can only basically input and output numbers but with

01:04:40.800 --> 01:04:48.720
programming and now um AI or machine learning is there are we getting to the point where

01:04:49.520 --> 01:04:56.160
basically these programs or these computers can think much faster than we do i know they can

01:04:56.160 --> 01:05:02.000
solve equations but are is it getting to the point where they can quote unquote learn faster than us

01:05:02.000 --> 01:05:08.640
and how do we keep up the understanding of like you're saying a computer can only do something

01:05:08.640 --> 01:05:18.560
that's traceable um is there a point where maybe like in comparative to to our human reasoning

01:05:19.520 --> 01:05:27.440
um is there a point where we're too slow to kind of understand um these programs and machines

01:05:29.120 --> 01:05:34.880
well it's a really good question let me give you the answer that pro AI people give and then

01:05:34.880 --> 01:05:43.120
i'll tell you what i think okay pro AI people point out that although large language of models

01:05:43.120 --> 01:05:49.680
which is one aspect of artificial intelligence are relatively in their infancy they already

01:05:50.320 --> 01:06:00.480
beat human beings at standardized tests such as the graduate G the GRE and SAT and the ACT and

01:06:00.480 --> 01:06:07.360
they can do well on tests of biology and physics and so as my friend David Jesky has pointed out

01:06:08.320 --> 01:06:14.160
every time humanity has said well computers aren't really intelligent because they can't play chess

01:06:14.160 --> 01:06:22.080
or they can't play go or they can't um write poetry uh you know those have all fallen right like

01:06:22.080 --> 01:06:28.160
they didn't they do those things right and um curmudgeons like me keep saying oh well they

01:06:28.160 --> 01:06:32.560
aren't really intelligent even though they can answer a bunch of questions that i can't possibly

01:06:32.560 --> 01:06:39.600
answer okay but then i'll tell you what i think um just because it's i think the honesty is worthwhile

01:06:39.600 --> 01:06:48.160
i mean sure an AI could beat me at a biology test but an AI has had an infinite amount of time to

01:06:48.160 --> 01:06:59.200
learn and to it it's an open book test and AI can't compete with me at all in any real problem

01:06:59.200 --> 01:07:06.400
that it hasn't had a bajillion cycles of 50 gigawatts of power to study ahead of time

01:07:07.360 --> 01:07:11.760
yeah you know um so

01:07:14.960 --> 01:07:25.680
i don't accept artificial intelligence as thinking and being able to learn things at all

01:07:26.000 --> 01:07:33.120
now obviously you can build a classifier right like you could classify leaves and it'll tell

01:07:33.120 --> 01:07:38.080
you what kind of tree it came from better than i can personally remember the shape of leaves

01:07:38.080 --> 01:07:46.400
you know to do it it would beat me at that task right um it would beat me at translating french

01:07:46.400 --> 01:07:54.880
into english but it doesn't beat me at understanding even though it can translate french into english

01:07:55.120 --> 01:07:57.120
better than i can

01:08:00.080 --> 01:08:09.280
i think the question comes down to what is what does it mean to be humans creativity

01:08:09.840 --> 01:08:12.080
you know novel ideas i guess

01:08:12.400 --> 01:08:26.160
yeah i'm i'm you know i can't claim to be more creative than an AI

01:08:28.560 --> 01:08:35.520
but still i i feel that all human beings have something in them which i have not yet seen in an

01:08:35.520 --> 01:08:43.120
AI maybe five years from now the little child that is artificial intelligence will have grown

01:08:43.120 --> 01:08:53.200
into something um worthy of respect you know uh and then are we gonna say switching the machine

01:08:53.200 --> 01:09:04.720
off as murder you know did we kill an AI when you know the power failed i i don't know i

01:09:05.680 --> 01:09:16.240
but at the moment i remain skeptical of these these things

01:09:16.480 --> 01:09:16.960
you

01:09:33.120 --> 01:09:41.760
thanks for your perspective and the talk is very uh interesting and informative you're welcome any other questions

01:09:46.720 --> 01:09:47.220
you

01:09:56.880 --> 01:10:01.760
okay here in none i think we'll stop the recording here

