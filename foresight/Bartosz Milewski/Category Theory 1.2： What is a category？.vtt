WEBVTT

00:00.000 --> 00:19.600
So that was the philosophical part of my talk, and I will be slowly moving towards really

00:19.600 --> 00:30.200
more practical, I mean, practically in the sense of mathematical stuff, not so much philosophy.

00:30.200 --> 00:45.040
But from all this talk about how our brains work, the important part is that we want to

00:45.040 --> 01:07.160
be able to, the major tools in our arsenal are abstraction, composition, and I'm going

01:07.160 --> 01:21.960
to add one more thing to this identity. So as I said, abstraction means we want to get

01:21.960 --> 01:30.880
rid of the details, we want to forget about the assembly language or machine language

01:30.880 --> 01:38.520
of what we are doing, and that's not only in programming, it's also in mathematics or

01:38.520 --> 01:49.920
in physics, we want to get rid of unnecessary details. So once we get rid of unnecessary

01:49.920 --> 01:57.800
details, then suddenly what happens is that things that were different, but they were

01:58.240 --> 02:06.120
different because of unnecessary details, they suddenly become identical. Like if you

02:06.120 --> 02:15.080
have, let's say, two billion balls of the same color, they are not really identical

02:15.080 --> 02:20.880
if you look under the microscope, they have different maybe scratches, maybe they have

02:20.960 --> 02:28.040
different configuration of atoms, but you can replace one with another when you are

02:28.040 --> 02:40.160
playing billiards. So once you abstract, things that used to be different now become identical.

02:40.160 --> 02:46.080
This is why we have this notion of identity, and this notion of identity because of abstraction

02:46.080 --> 02:53.960
is always non-trivial. So there are things that are strictly identical, so you can replace

02:53.960 --> 02:59.320
one with another and you won't notice any difference, but then there are things that

02:59.320 --> 03:09.360
are identical for all intents and purposes. And in mathematics, this is a very, very important

03:09.440 --> 03:17.200
thing, that there is this distinction between, it's really the same, or it's not really

03:17.200 --> 03:27.200
the same, but we will look at it as if it were the same. And there is even a whole foundation

03:27.200 --> 03:33.200
theory that's being now developed that's based on like distinguishing between what's

03:34.040 --> 03:41.040
not identical, it's called homotopy type theory. It's a very hot topic right now in mathematics

03:41.600 --> 03:48.600
that just tries to solve this one problem of what are things that are equal and what

03:48.600 --> 03:58.600
are things that are almost equal, or as they say, isomorphic. Isomorphism and equality the

03:58.600 --> 04:12.840
same, or not, should be treated the same way, or not, and so on. So composition and identity,

04:12.840 --> 04:23.840
these two things, they just define category theory. This is all there is in category theory,

04:24.440 --> 04:35.440
it just encompasses composition and identity. So you are now ready for the first definition,

04:36.080 --> 04:43.080
definition of category. And I wish I could define category, what a category is, very

04:44.080 --> 04:51.080
precisely, but I can't. So I will be using terms like a bunch. A category is a bunch of objects.

05:02.240 --> 05:09.240
You would want me to say it's a set of objects, because a set has a precise mathematical meaning,

05:10.240 --> 05:20.240
but it's not. So you have categories that have sets of objects and it's fine, but not

05:20.240 --> 05:26.240
all categories have sets of objects. It turns out that there are things that are bigger than

05:26.240 --> 05:33.240
sets. And you might think, what can be bigger than a set? What's a set? A set is something

05:34.000 --> 05:41.000
that has a bunch of elements. A set is defined by membership. Is this element a member of

05:44.600 --> 05:51.600
the set or not? But then you can build sets with sets. You can say, I have a set of sets

05:54.240 --> 06:01.240
that are two element sets. And I have a set of all sets that are of this particular shape.

06:04.120 --> 06:10.240
So elements of a set can also be sets. From a set theory point of view, everything is

06:10.240 --> 06:17.240
a set. They have the set hammer and everything is a set nail for that. So sets are built

06:19.800 --> 06:26.800
from sets and so on. And then you can say, how do I define a set? I will specify what

06:27.760 --> 06:34.760
kind of elements it has. So I can say, I have a set of sets. There are some sets that are

06:37.080 --> 06:44.080
members of themselves and there are sets that are not. A set of dogs is not a dog. So that's

06:47.120 --> 06:54.120
one. But a set of... Well, it was a good example of a set that is a member of itself.

06:56.800 --> 07:03.800
A set that contains only itself. A set that contains only itself. Okay.

07:08.680 --> 07:15.680
So now if you can define a set that... So you can also define a set that's a set of

07:15.720 --> 07:22.720
sets that are not members of itself. And then you can ask, does this set... Is this set

07:26.960 --> 07:33.960
a member of itself or not? If it is a member of itself, then it should not belong to the

07:34.240 --> 07:41.240
set. And if it's not, it should belong. It's like with the barber's paradox. If he shapes

07:41.480 --> 07:46.640
himself, then he should not shape himself. If he doesn't shape himself. So you get into

07:46.640 --> 07:53.640
these paradoxes in set theory. So if I say, okay, a category is a set of objects, then

07:56.880 --> 08:03.880
I immediately get into this problem. And in particular, you cannot define a set of all

08:03.880 --> 08:10.880
sets for some other reason, right? Because it's too big. It's like a power set of... It

08:11.680 --> 08:16.640
would have to contain all its subsets as well. So it's a set that contains all sets, including

08:16.640 --> 08:23.640
its subsets and so on. So these are the mind-blowing things that set theories that are thinking

08:23.920 --> 08:30.920
about and they cannot sleep at night. So a category says... A category theory says, let's

08:32.640 --> 08:39.640
not worry about it, right? Well, they do worry about it, but they have ways of doing this.

08:39.820 --> 08:46.820
So I will say it's a bunch of objects, okay? So a category consists of objects. And then

08:54.400 --> 09:01.400
without specifying further whether they form a set or a bunch or a class, sometimes it's

09:01.400 --> 09:08.400
called a class, which is like less precise than the set. And these objects, I would just

09:11.480 --> 09:18.480
draw as dots, you know? And arrows. And these arrows are called also morphisms.

09:23.760 --> 09:30.760
I'll be sometimes saying morphisms, sometimes I'll be saying arrows. So a morphism or an

09:33.200 --> 09:40.200
arrow is something that goes between two objects. So you have an object A and you have an object

09:40.720 --> 09:47.720
B and you have an arrow between them and you call it F, okay? And now you might want

09:48.720 --> 09:55.720
to ask, you know, but what's an object? Right? And I can't tell you, okay? An object is primitive

10:04.520 --> 10:11.520
in this theory. It has no properties. It has no structure, internal structure. It's nothing.

10:12.520 --> 10:19.520
It's like the atom. It's a point. It has no properties, okay? What's a morphism? Well,

10:26.880 --> 10:33.880
a morphism is also a primitive. It has no properties, well, except that every arrow has

10:33.880 --> 10:40.880
a beginning and an end, okay? So that's the important thing. So in fact, the reason for

10:46.600 --> 10:53.600
having objects is so that you can mark the ends of arrows, okay? They don't serve any

10:54.480 --> 11:01.480
other purpose as just being names for the ends of arrows or identifying the ends of

11:02.480 --> 11:09.480
arrows, okay? And notice that this is like, this is really funny that we are using arrows

11:16.040 --> 11:23.040
here. It's like going back to this, what I talked about, the primitive human beings hunting

11:24.040 --> 11:31.040
mammoths with bows and arrows, right? This is really a very interesting thing that we

11:35.960 --> 11:42.960
perceive the universe through these notions that were developed by hunter-gatherers, right?

11:45.000 --> 11:52.000
They had, they described the world in terms of, you know, the sense of, you know, the

11:53.040 --> 12:00.040
spatial relationships, right? For instance. So they, they, like when I'm talking about

12:00.480 --> 12:07.480
category theory and when mathematicians talk about it, they will put things in space, maybe

12:08.160 --> 12:14.320
with their hands, manipulate. So we know how to manipulate things, right? We know how to

12:14.320 --> 12:20.600
position things in space. We talk about spatial relationships. Something is above, something

12:20.600 --> 12:27.600
is below, higher level of abstraction, lower level of abstraction. These are all spatial

12:27.720 --> 12:34.720
relationships, right? Now hunter-gatherers also understand movement. It comes from here,

12:36.320 --> 12:43.320
goes here. This is movement. This is from arrow, from A to B, right? It has this little

12:43.600 --> 12:50.040
thing here with barbs, right? So when you, when you hit the animal, it can't just pull

12:50.120 --> 12:57.120
it because it's, okay? So, and of course we have social language. We, we, hunter-gatherers

13:04.520 --> 13:11.520
are, we're social animals. So, so they talk about, you know, relationships between things

13:12.320 --> 13:19.320
in terms of this guy, points at this guy and, and, and by movement, kind of, you know,

13:20.040 --> 13:25.320
going from this place to that place, through this place and so on. So we'll be using this

13:25.320 --> 13:32.320
language all the time and I want you to, like, realize what kind of language we are using

13:32.800 --> 13:39.800
and how it actually constrains us, okay? But anyway, so we have objects and objects we

13:43.560 --> 13:48.640
draw in some kind of spatial relationship usually because we are using the spatial part

13:48.640 --> 13:54.800
of our brain. We have morphisms which are arrows, so they suggest some kind of movement

13:54.800 --> 14:01.800
and relationship between people. So what kind of things can happen? I mean, we can have,

14:01.800 --> 14:08.800
let's say, you know, multiple arrows going between objects. So if you have object A

14:21.280 --> 14:28.280
and B, you can have zero or more arrows going between them. So every time you define a category

14:29.280 --> 14:36.280
you specify, you know, what is the, what are the objects of this category and for each

14:36.440 --> 14:43.440
pair of objects, right, you specify the arrows that go between these objects. Some objects

14:44.080 --> 14:49.320
are not connected with arrows, other objects are connected with one arrow, other objects

14:49.320 --> 14:56.320
are connected with infinitely many arrows, could be uncountable number of arrows going

14:56.840 --> 15:02.280
between two objects, okay? So, like, if you have an idea that the category is sort of

15:02.280 --> 15:09.280
like a graph, that's a good idea, right, except that you have to be open-minded about what

15:11.400 --> 15:18.400
the graph is. It might have infinitely many nodes and it can have infinitely many arrows

15:18.520 --> 15:25.520
between, between two nodes or it could have zero or, you know. But you have to expand

15:26.320 --> 15:33.320
your mind around this. And of course you can have arrows going from B to A as well, right?

15:37.440 --> 15:43.740
And you can have arrows going from B back to B or from A back to A. You can have multiple

15:43.740 --> 15:49.960
arrows going from A to A, right? And so on. So all these are possibilities. Sometimes people

15:49.960 --> 15:56.540
get stuck and I get questions, you know, like, how is it possible that you can have more

15:56.540 --> 16:01.960
than one arrow? Aren't they all the same? No, they are different, you know. It's like,

16:01.960 --> 16:07.960
you can have infinitely many or uncountable number of arrows going from A back to A, you

16:07.960 --> 16:14.960
know, and it's okay. You just give them different names, you know, okay, this is F, this is G,

16:14.960 --> 16:21.960
this is H, right? So this is what a category is, okay? Now that's not all. That's not all

16:25.400 --> 16:32.400
because that doesn't, that just tells us about what are the elements of category. We haven't

16:33.600 --> 16:40.600
talked about these two things. Composition. So composition is a property, very simple

16:40.600 --> 16:47.600
property that if you have an arrow from A to B and you have another arrow from B to

16:51.040 --> 16:58.040
C, so you have object A, object B and object C and you have these two arrows, then there

16:58.480 --> 17:05.480
always must exist an arrow that's a composition of these. So if I call this one F and call

17:05.880 --> 17:12.880
this one G, I'm using these names F and G that suggest functions, right? Because at

17:13.120 --> 17:20.120
some point this will be one of our models for a category. So this is called G after F,

17:24.160 --> 17:31.160
after is this little circle. So this arrow is called G after F. And here we have this

17:32.120 --> 17:39.120
idea that going from A to B using F and going from B to C using G is identical to going

17:48.600 --> 17:55.600
from A to C using this path called G after F, okay? So this arrow is identical to the

17:56.600 --> 18:03.600
composition of these arrows, okay? It's very important to understand that there might be

18:04.080 --> 18:11.080
multiple arrows going from A to C, right? But this one is a composition of these two

18:12.120 --> 18:19.120
and it must exist, okay? So for every composable pair of arrows, composable means the end of

18:20.120 --> 18:26.120
one is the same as the beginning of the other. And here it's important that we have these

18:26.120 --> 18:33.120
objects to identify the ends and the beginnings, right? So the end of this is B, the beginning

18:34.600 --> 18:41.600
of this is B. So they are composable, right? And if they are composable then there must

18:41.760 --> 18:48.760
be a composition, there must be an arrow going from here to here. So this is called composition

18:49.880 --> 18:56.880
check. Now when we are defining a category, the category is defined by giving us objects,

19:06.640 --> 19:13.640
saying what the objects are and arrows. And then defining composition, which is sort of

19:14.640 --> 19:21.640
like a multiplication table for arrows. So for every two arrows you have to define what

19:22.080 --> 19:28.200
is their composition. It's a humongous multi-dimensional multiplication table, you know, or infinitely

19:28.200 --> 19:34.200
dimensional multiplication table, right? For every three objects you have to define all

19:34.200 --> 19:40.700
possible combinations in which you can compose arrows going between these objects and so

19:40.780 --> 19:47.780
on, right? So it's a humongous multiplication table. And the whole information about the

19:48.300 --> 19:55.300
category is in this multiplication table, okay? So remember, this is the multiplication

19:55.900 --> 20:02.900
table for a category, it's a composition table, how you compose morphisms. And different

20:03.900 --> 20:10.900
composition tables will give you different categories. Because since objects don't have

20:16.380 --> 20:21.620
structures, since arrows don't have structure, they don't contain any information. But the

20:21.620 --> 20:27.580
composition contains the information. And we just like want to encode everything, everything

20:27.580 --> 20:34.580
absolutely in this composition, okay? Now, identity for every object, it's called A,

20:45.540 --> 20:52.540
there is an identity arrow. We will call it ID. Sometimes ID with a subscript A. This

20:52.540 --> 20:59.540
is identity for the object A. So there is this arrow that we call identity. There's

21:01.660 --> 21:08.660
one per object. For every object in a category, there is an identity for this object. Now,

21:08.700 --> 21:15.700
why am I calling it this identity? Because of composition. So, if I have an arrow going

21:22.540 --> 21:29.540
from, well, let's call it A, let's call it B, IDB, okay? If I compose this arrow F with

21:32.940 --> 21:39.940
IDB, I get back arrow F. In this sense, this is an identity, right? If you think of this

21:41.700 --> 21:48.700
as multiplication table, you know, F times ID is again F, right? So this is like a one

21:49.700 --> 21:56.700
in terms of composition. So I can write it using this notation that IDB after F, right?

22:03.980 --> 22:10.980
So first I go F and I go IDB. It's the same as this. Equal, okay? This is one morphism,

22:10.980 --> 22:17.980
this is another morphism. They are equal. It's the same morphism, okay? And of course

22:24.420 --> 22:31.420
there is this symmetric thing when I have IDA and I have some, let's call it G from

22:32.420 --> 22:39.420
A to B, right? So if I start with an ID, IDA, and follow it with G, I will get G, okay?

22:52.780 --> 22:59.780
So these two things, they are not the same, right? I mean, this is like left identity,

22:59.860 --> 23:06.780
this is the right identity. Sometimes they are this, well, maybe I shouldn't say it, sometimes

23:06.780 --> 23:10.620
they are the same, but it's just like you have to have left identity and you have to

23:10.620 --> 23:17.620
have right identity, okay? So this is one of the axioms of a category or laws of the category

23:20.220 --> 23:26.740
that in every category, so if you think of a category as a graph, this graph has to

23:26.780 --> 23:33.780
have some special properties. For instance, it has to have an arrow going back to the

23:33.780 --> 23:40.780
object. For every object, it has to be this little loop, okay? Must. So that's one law

23:43.100 --> 23:48.660
or actually two laws, left identity, right? And then identity. And there is the third

23:48.660 --> 23:55.660
law and that's associativity. So if you have three objects, well, here you have three objects,

23:57.740 --> 24:04.740
let's say three arrows, okay? So we have object A, an arrow F to object B, then an arrow

24:06.940 --> 24:13.940
G to object C, right? You can combine these to have G after F, but if you have another

24:19.380 --> 24:26.380
one going to D, right, then you have to have G after F, right? And then you have to have

24:26.740 --> 24:33.740
you can combine these and have, so F, G, H, right? You have three arrows. Three arrows

24:37.140 --> 24:44.140
can be composed in two different ways. So this one composition, I compose GF with G

24:44.740 --> 24:51.740
first, G after F, and then I compose this with H. So I have H after G after F, okay?

24:57.460 --> 25:04.460
Now I can also compose G with H first, right? So I'll have H after G, H after G, okay? Now

25:10.180 --> 25:17.180
I can compose this arrow with this arrow, right? And I will get H after G after F, okay?

25:18.180 --> 25:25.180
H after G after F, okay? The difference between these two is where I put the parentheses. Now

25:33.220 --> 25:40.220
if I had to remember where to put parentheses, every time I draw a diagram, it will become

25:41.220 --> 25:48.220
extremely complex and probably my brain would just give up, okay? Therefore, the

25:55.180 --> 26:02.180
axiom of the category is that this and this is the same, okay? So H after G after F must

26:02.180 --> 26:09.180
always be equal H after G after F. So this is called associativity, right? Normal thing,

26:18.660 --> 26:24.100
associativity. You can associate it this way or this way and you get the same result.

26:24.100 --> 26:31.100
And that's extremely important in order to make this manageable for us humans, okay?

26:33.180 --> 26:40.180
Now you might think, okay, what if we didn't do this? Is it possible still to have a theory

26:40.180 --> 26:47.180
in which this is not true? Well, it is possible and of course there are mathematicians who

26:47.540 --> 26:54.540
are working with stuff that maybe not completely falls, the associativity is not completely

26:55.540 --> 27:02.540
false, but they make associativity weak, meaning that these two ways of combining things are

27:05.260 --> 27:10.260
not really identical, but they are isomorphic, okay? Yes?

27:10.260 --> 27:17.260
What about real-world stuff like finite precision arithmetic? Is that the kind of thing you're

27:17.260 --> 27:23.260
leading to, like you're multiplying flows and the order in which you multiply them,

27:23.260 --> 27:29.260
you may end up with a slightly different result? Well, then they would not form a category

27:29.260 --> 27:36.260
in the sense, okay, yeah. The category has to have associativity, yes?

27:40.260 --> 27:45.260
So what do you mean by the two ways of the composition of isomorphic?

27:46.260 --> 27:53.260
It means that there is a transformation that transforms this into this that is not an identity.

28:03.260 --> 28:10.260
So morphisms can also, okay, this is a separate thing. You can have identity between morphisms

28:15.260 --> 28:22.260
that is not identity, it's weak identity, right? Here I'm assuming, well, okay, so let me

28:23.760 --> 28:30.760
for full disclosure right now, okay? I said objects don't form a set in general. If they

28:33.260 --> 28:40.260
form a set, then this category is called small, okay, if they can form a set. If they don't

28:41.260 --> 28:48.260
form a set, it's a large category, okay? Morphisms, on the other hand, between any two objects,

28:51.260 --> 28:58.260
they form a set. So that's okay, right? Now is there a category here in which they don't

29:00.260 --> 29:06.260
form a set? Of course there is, right? These are the higher-order categories in which

29:07.260 --> 29:14.260
arrows don't form sets, they form objects in a category. But we are not going to talk about

29:18.260 --> 29:24.260
them. So that's it, that's all, that's the category. That's the definition of category,

29:25.260 --> 29:30.260
yes? In terms of definition, when you say the two eras are isomorphic, if they have

29:31.260 --> 29:38.260
the same beginning and ending? What is isomorphic? Two eras, would they be isomorphic if they

29:41.260 --> 29:48.260
have the same beginning and ending? No, no, they are different. No. Yes? Is this so much

29:48.260 --> 29:55.260
different from a group in the other way? It's, okay, so the question is, is that different

30:05.260 --> 30:12.260
from a group? And it has some similarities to a group, actually it has similarities to

30:13.260 --> 30:20.260
something that's called a monoid, right? Because a group is a monoid that also has an inverse,

30:24.260 --> 30:30.260
right? So there are two ways in which you can impose further conditions on this and you

30:32.260 --> 30:38.260
can say, what if every arrow has an inverse, right? You can define an inverse to say, if

30:38.260 --> 30:44.260
the arrow f and g, if they combine, compose to an identity, then one is an inverse of

30:45.260 --> 30:50.260
an other. That's the definition of an inverse, right? So if you do this, then you end up

30:51.260 --> 30:55.260
with something that's called a groupoid. A groupoid is the category in which every arrow

30:56.260 --> 31:02.260
has an inverse, okay? It's still not a group. It's more than a group because a group is

31:03.260 --> 31:10.260
really a category in which there is only one object and arrows between them. We'll be talking

31:11.260 --> 31:17.260
about a monoid as a category and in particular a group. But this is more because now you

31:21.260 --> 31:26.260
have transformations going between objects, so you cannot, in a group you can compose

31:27.260 --> 31:34.260
anything with anything, right? Here you can't. They have to be composable. The end of one

31:35.260 --> 31:39.260
has to be the beginning of another, right? You cannot compose anything with anything,

31:40.260 --> 31:47.260
right? That's the biggest distinction. Okay, now, notice that a group is a group

31:56.260 --> 32:03.260
of objects. So let me give you an example, okay? And this is the example that we'll be

32:04.260 --> 32:11.260
studying a lot because this is an example from programming, right? We have a basic useful

32:15.260 --> 32:22.260
category that we use in programming. And this is the category in which objects are

32:22.260 --> 32:35.260
types and arrows are functions, right? Like if any single argument function takes an argument

32:36.260 --> 32:49.260
of a type A and returns a result of type B, right? So in the sense a function is an arrow,

32:50.260 --> 32:58.260
or a morphism between two types. So that's the category in which this is actually in

32:59.260 --> 33:06.260
Haskell, it's almost exactly, well, maybe in ML, this is almost exactly the category

33:07.260 --> 33:16.260
which you are working, right? Types are your objects, functions are your morphisms, right?

33:16.260 --> 33:27.260
In Haskell, it's a little bit more complicated because of laziness of Haskell, okay? Haskell

33:28.260 --> 33:39.260
is a lazy language. So the trick is that in Haskell, every type also contains this

33:39.260 --> 33:46.260
undefined value, the bottom value, which means like if you try to evaluate it, you will get

33:47.260 --> 33:53.260
into an infinite loop, it will take you forever. Because categories don't really take into

33:54.260 --> 34:02.260
account time. It's like time really is really hard to describe in mathematics, right? Whereas

34:02.260 --> 34:09.260
in computation, we worry about time, right? I mean if something takes too long to calculate,

34:10.260 --> 34:18.260
that's useless for us, right? And in particular, if it takes infinite time to calculate, which

34:19.260 --> 34:25.260
means it never terminates, okay? It's a calculation. So if you have a function that goes forever,

34:25.260 --> 34:31.260
what's the return type for this function? It's a function that's supposed to return an

34:32.260 --> 34:38.260
integer, but it never does because it goes into an infinite loop. So in this case, in

34:39.260 --> 34:44.260
Haskell, we say it returns an int type, but int type contains this special value called

34:45.260 --> 34:53.260
bottom, which means it never terminates, okay? And that's the digression I make once, and

34:53.260 --> 34:58.260
maybe from time to time, I will say, well, of course, except for bottoms, and we are

34:59.260 --> 35:05.260
ignoring bottoms, or we are ignoring never ending calculations and so on, right? So there's

35:06.260 --> 35:11.260
this caveat. There's lots of caveats here in the beginning, and I just want to get rid of

35:11.260 --> 35:24.260
them, and later we can think in simpler terms, okay? But of course you might ask, but what

35:25.260 --> 35:31.260
are types, right? Okay, types in the programming language, what are they?

35:31.260 --> 35:46.260
Sets of values, okay. So there is a model, a kind of simplistic model, maybe this works

35:47.260 --> 35:52.260
in ML, it won't work in Haskell because of the bottoms, right? But the simplest model

35:52.260 --> 36:02.260
for types is that they are just sets, sets of values, right? And so we can model programming

36:03.260 --> 36:09.260
as in a category of sets, we can say, okay, so instead of types, we will be saying sets

36:10.260 --> 36:17.260
of values, right? And functions are just functions between sets, okay? You can define

36:17.260 --> 36:25.260
functions on sets, function from one set to another set, right? And that's a good model too.

36:26.260 --> 36:30.260
So sometimes I'll be talking about sets and functions, sometimes I'll be talking about types

36:31.260 --> 36:38.260
and functions, and of course when I say functions, I'm talking about mathematical

36:39.260 --> 36:45.260
functions, right? So mathematical function is defined between sets. So a function is just,

36:45.260 --> 36:52.260
you know, you take a value from one set and it gives you a value from another set, right?

36:53.260 --> 37:06.260
So I can even draw a picture of what might mean by a function in a set. So I hope you

37:06.260 --> 37:16.260
can memorize the definition of a category, right? I mean, it's so simple, so very elementary.

37:17.260 --> 37:22.260
So I can erase this now. So it's like you have one set, you have another set, here you have

37:23.260 --> 37:29.260
elements of this set, elements of this set, and the function sort of, you know, takes

37:29.260 --> 37:35.260
elements of this set into elements of this set, and again I'm using the arrows, but these are

37:36.260 --> 37:43.260
different arrows, these are not morphisms, right? So one function corresponds to one morphism,

37:44.260 --> 37:51.260
right? But we can like, so this is another thing that you have to be very careful with,

37:52.260 --> 37:59.260
this schizophrenic view of a category, right? That every category, well not every category,

38:00.260 --> 38:12.260
okay? But a lot of categories come from some model. For instance, you take sets, set field,

38:12.260 --> 38:21.260
right? So and you say, I'm going to represent these sets as objects in my category. This

38:22.260 --> 38:32.260
category, by the way, is called set. This is a category of sets and functions, right?

38:32.260 --> 38:43.260
We'll be using it quite often. So I'll be talking about the category of sets and the origin of

38:44.260 --> 38:52.260
this category is that I started with sets, right? And I know what sets are. They have structure,

38:53.260 --> 39:00.260
right? Every set has elements and there are functions and functions in sets, they just map

39:01.260 --> 39:07.260
elements to elements, okay? So I know all the stuff. I'm looking under a microscope and I said I know

39:08.260 --> 39:14.260
it has elements. I know that the functions are actually a bunch of mapping. It's a mapping from

39:15.260 --> 39:26.260
one set to another, right? Now when I build a category on top of this, I have to forget about

39:26.260 --> 39:36.260
the structure, okay? I get amnesia and I say this is set A. What's inside of the set? I have no idea.

39:37.260 --> 39:45.260
It's an atom. It has no structure because now I'm putting my category glasses, right? No

39:45.260 --> 39:57.260
structure. What are the arrows between these sets? Well, I look at what kind of sets these are, right?

39:58.260 --> 40:04.260
I know elements of the sets. I know what kind of functions are possible, right? So I know how many

40:05.260 --> 40:12.260
arrows, how many functions are from this set to this set and I build my category based on this.

40:12.260 --> 40:21.260
I say, okay, this set corresponds to an object A, this set corresponds to an object B and there are

40:22.260 --> 40:30.260
ten arrows between these objects. Fine. What are these arrows? I don't know. I forgot. I just know there

40:31.260 --> 40:41.260
are ten of them, okay? And I call them ABCD or FGH, okay? And the next thing is, okay, so if I have

40:42.260 --> 40:47.260
arrows from this set to this, I mean functions from this set, another function from this set to this set.

40:48.260 --> 40:55.260
Oh, I can compose them, right? What does it mean to compose functions? Well, you apply a function to

40:56.260 --> 41:01.260
an argument, right? You get a result. You take this result, you apply the second function to this result

41:02.260 --> 41:08.260
and you get another result, right? So if you combine this, you start it here, you end it up here.

41:08.260 --> 41:27.260
You get a function that goes, right? Okay? So starting some x here, it produces a y here and y goes into z here

41:28.260 --> 41:35.260
and there is a function that just takes x directly into z and that's the composition of these two functions.

41:35.260 --> 41:49.260
Okay? So I know how to compose functions on sets using this, right? So I use this information to create my big

41:50.260 --> 41:59.260
infinite dimensional multiplication table, composition table for my category set and then I forget.

41:59.260 --> 42:08.260
And of course there is an identity function, right? That just takes an x into x, takes another x into x.

42:09.260 --> 42:16.260
This is an identity function, right? So every set has an identity function that just doesn't move the set.

42:17.260 --> 42:24.260
It just maps the set into itself by mapping every element to itself. It's like a trivial function, right?

42:24.260 --> 42:32.260
So, like, id of x equals x. That's what it has.

42:34.260 --> 42:35.260
Yes?

42:36.260 --> 42:41.260
It doesn't have to map every element itself though, right? It just needs to map the set to itself.

42:42.260 --> 42:50.260
No, because you can map the set to itself in many different ways, right? You can interchange element if you want.

42:50.260 --> 42:53.260
That's also a map, you know, the set into itself, right?

42:54.260 --> 42:57.260
From a category point of view it's still...

42:58.260 --> 43:08.260
Okay, so what we are doing here is we are studying the set and we find out that there are many functions going from the set to itself, right?

43:09.260 --> 43:18.260
One of them is the identity function. This would become our identity morphism, right?

43:18.260 --> 43:26.260
And, by the way, identity function when it's composed with any other function will give them back this function, right?

43:27.260 --> 43:31.260
So it's a good identity function, I know, from set table, right?

43:32.260 --> 43:41.260
So I know that I will get that my multiplication table that I'm building when I pick this function as my identity morphism,

43:42.260 --> 43:47.260
it will be an identity in my big multiplication table, right?

43:48.260 --> 43:54.260
So I'm abstracting, I'm just slashing information left and right.

43:55.260 --> 44:05.260
I'm forgetting about what's inside the objects, what these functions do, and I end up with this category set.

44:06.260 --> 44:14.260
And in this category set I have these objects that now I forgot where they came from.

44:14.260 --> 44:22.260
I have these arrows, I forgot where they came from, but I have the multiplication table, the composition table for them, right?

44:23.260 --> 44:28.260
And this composition table fulfills my axioms of category theory, right?

44:29.260 --> 44:36.260
I mean, this composition is obviously associative, right?

44:37.260 --> 44:41.260
The composition of functions is associative, so I get a good category.

44:41.260 --> 44:45.260
I have identity, I have associativity, I have everything.

44:46.260 --> 44:52.260
So I got this huge multiplication table, now I can forget about where it came from, and now I have a category set.

44:53.260 --> 45:04.260
And in this category set, you know, I don't care about the structure of my objects or the structure of my functions or my morphisms.

45:05.260 --> 45:08.260
I forget that my morphisms are really functions. I forgot all this.

45:08.260 --> 45:18.260
And now I can start thinking about, you know, what can I say about these objects just by looking at morphisms?

45:19.260 --> 45:22.260
And it turns out I can say a lot of things.

45:23.260 --> 45:35.260
And we'll see later how you can identify, just by looking at morphisms, how you can identify, oh, this set is actually empty, right?

45:35.260 --> 45:38.260
How do you know it's empty, right?

45:39.260 --> 45:44.260
I mean, if you forgot the information, then it has no elements, right?

45:45.260 --> 45:47.260
You only have morphisms.

45:48.260 --> 45:59.260
Well, it turns out that an empty set has this property that can be expressed just in terms of morphisms, nothing else.

46:00.260 --> 46:09.260
And I can identify an empty set. I can identify a single element set using just morphisms, nothing else.

46:10.260 --> 46:13.260
It's not easy, but it's possible.

46:14.260 --> 46:22.260
So the thing is that you can identify a lot of properties of sets just by looking at the multiplication table.

46:23.260 --> 46:27.260
You don't really have to know what's inside these sets.

46:28.260 --> 46:36.260
And that gives you a completely new way of looking at things, more abstract way of looking at things.

46:37.260 --> 46:45.260
It's like if you think about what's inside a set, you're thinking assembly language of sets.

46:46.260 --> 46:52.260
Thinking about elements, how they are mapped, you know, that's the assembly language.

46:53.260 --> 46:59.260
Category theory gives you this higher level language in which you don't have to look inside the set.

47:00.260 --> 47:03.260
You just look at how they are connected with arrows.

47:04.260 --> 47:08.260
And this is like the ultimate in data hiding, right?

47:09.260 --> 47:18.260
You have an object, it's a data type, it's a set, but you cannot look inside of it.

47:18.260 --> 47:25.260
It shrunk to a point. All you have is its interface.

47:26.260 --> 47:30.260
Its interface is how it connects to other objects.

47:31.260 --> 47:34.260
All these arrows coming out of this object and into this object.

47:35.260 --> 47:37.260
They define the interface.

47:38.260 --> 47:48.260
So like if you take this idea of data hiding and abstraction, this is where it leads you, eventually.

47:49.260 --> 47:53.260
This is the end of the road for abstraction, right?

47:54.260 --> 47:56.260
This is the end of the road for data hiding.

47:58.260 --> 48:03.260
This is it. You get like the most abstract language that you can think of.

48:07.260 --> 48:12.260
And we can stop now. Next time. Two more. Thank you.

