WEBVTT

00:00.000 --> 00:03.000
Привет, мир!

00:03.000 --> 00:15.000
В 1974 году, венгерский архитектор Рубика изобретает игрушку-головоломку, которая становится всемирно известной под названием «Кубик Рубика».

00:15.000 --> 00:19.000
Эта головоломка стала наиболее продаваемой игрушкой на планете.

00:19.000 --> 00:24.000
И с момента изобретения разошлась по миру почти в полмиллиарда единиц.

00:24.000 --> 00:29.000
И сегодня мы рассмотрим основные моменты по созданию этой головоломки,

00:29.000 --> 00:34.000
а также разберем как создать Кубик Рубика при помощи языка Python,

00:34.000 --> 00:38.000
и для этого главным инструментом станет функционал и возможности.

00:38.000 --> 00:41.000
Очень простого 3D-движка – Урсина.

00:44.000 --> 00:45.000
Итак, приступим.

00:45.000 --> 00:52.000
И чтобы установить движок Урсина, то в терминале запустим команду, представленную на экране.

00:53.000 --> 00:58.000
После установки импортируем этот движок и напишем класс основного приложения,

00:58.000 --> 01:03.000
точно так же как делали в сюжете про создание змейки на движке Урсина.

01:03.000 --> 01:09.000
И пока что сделаем два метода для загрузки игры и для обработки событий нажатия клавиш,

01:09.000 --> 01:15.000
ну и конечно же создадим экземпляр приложения, запуск которого активируем через мететран.

01:15.000 --> 01:20.000
А для лучшего восприятия информации, создадим объекты окружения,

01:20.000 --> 01:26.000
сделаем плоскость которая будет расположена на 5 единиц ниже начала мировой системы координат,

01:26.000 --> 01:31.000
а на эту плоскость наложим текстуру которая идет в комплекте движка.

01:31.000 --> 01:35.000
Также в начале координат поместим большого размера сферу,

01:35.000 --> 01:38.000
на которую наложим подобранную текстуру неба,

01:38.000 --> 01:42.000
то есть мы будем находиться внутри сферы наблюдая небесный купол.

01:42.000 --> 01:49.000
И для лучшей наглядности, поместим трехмерную модель левосторонней системы координат на то место,

01:49.000 --> 01:53.000
где начинается мировая система счета для этого движка.

01:53.000 --> 02:00.000
Ну и для полной свободы действий, задействуем камеру которая управляется при помощи мышки.

02:00.000 --> 02:08.000
И если посмотреть на то что у нас вышло, то мы видим что получился достаточно оживленный каркас приложения,

02:08.000 --> 02:13.000
в котором при приятном окружении можем наблюдать начало мировой системы координат,

02:13.000 --> 02:18.000
что в свою очередь поможет более лучше понять работу с трехмерным пространством.

02:18.000 --> 02:24.000
Но чтобы двигаться дальше, то необходимо создать модель одного маленького кубика,

02:24.000 --> 02:26.000
так сказать структурной единицы.

02:26.000 --> 02:31.000
И проще всего будет работать с кубом, размеры сторон которого равны одному,

02:31.000 --> 02:36.000
а его центр должен находиться в начале локальной системы координат.

02:36.000 --> 02:39.000
Также нам важна карта текстура такого кубика,

02:39.000 --> 02:45.000
которую мы самостоятельно разукрасим при помощи любого растрового редактора.

02:45.000 --> 02:51.000
И при этом будем придерживаться классической раскраски грани для нашего кубика.

02:51.000 --> 02:57.000
И тогда, отдельными атрибутами сделаем пути для новой модели куба его текстуры,

02:57.000 --> 03:02.000
и чтобы проверить его отображение, то создадим один экземпляр объекта

03:02.000 --> 03:05.000
используя созданную модель текстуру.

03:05.000 --> 03:10.000
И как можно видеть, у нас появилась рукотворная структурная единица,

03:10.000 --> 03:13.000
при помощи которой сделаем целый кубик рубика.

03:13.000 --> 03:17.000
Но в начале координат мы поместим совершенно другой объект,

03:17.000 --> 03:19.000
это будет так называемый родитель.

03:19.000 --> 03:26.000
Он будет самым главным кубиком при помощи которого будет работать весь механизм кубика рубика.

03:26.000 --> 03:32.000
Так вот, и нашему объекту укажем, что он будет потомком родительского кубика,

03:32.000 --> 03:34.000
и расположим его слева от родителя.

03:34.000 --> 03:38.000
А для более очевидной работы механизма наследования,

03:38.000 --> 03:42.000
сделаем вращение родителя на 90 градусов вокруг оси Х,

03:42.000 --> 03:46.000
и вращаться родитель будет по нажатию левой клавиши мыши.

03:46.000 --> 03:49.000
Теперь посмотрим как это работает.

03:49.000 --> 03:53.000
И перед нами в центре мировой системы отчета находится родитель,

03:53.000 --> 03:58.000
у него шахматная текстура, а сбоку от него, его потомок.

03:58.000 --> 04:02.000
И при нажатии левой клавиши мыши происходит вращение родителя,

04:02.000 --> 04:08.000
а если посмотреть на движение потомка, он полностью повторяет те же движения,

04:08.000 --> 04:11.000
то есть так же вращается вокруг оси Х,

04:11.000 --> 04:16.000
и думает тут становится очевиден весь принцип работы механизма кубика рубика,

04:16.000 --> 04:20.000
и этим механизмом будет управлять только один кубик родитель.

04:20.000 --> 04:26.000
Но не все так просто как кажется, нам же надо крутить только определенную сторону кубика рубика,

04:26.000 --> 04:31.000
и поэтому в зависимости от стороны вращения необходимо перекреплять потомков.

04:31.000 --> 04:36.000
И давайте на этом же примере посмотрим что происходит во время смена родителя.

04:36.000 --> 04:42.000
На клавишу W будем обкреплять родителя, то есть родителем будет мировая сцена,

04:42.000 --> 04:47.000
а на клавишу S, заново сделаем родителем центральный куб.

04:47.000 --> 04:53.000
И если посмотреть на эту ситуацию, то вначале потомок вращается как и положено,

04:53.000 --> 04:59.000
но когда производим смену родителя, то потомок возвращается в то место где был изначально.

04:59.000 --> 05:05.000
А при назначении родителем снова центральный куб, то он перемещается в то место,

05:05.000 --> 05:09.000
если бы он вращался все это время с прежним родителем.

05:09.000 --> 05:16.000
Это неприятная вещь происходит потому, что координаты куба потомка относительно родителя не меняются,

05:16.000 --> 05:21.000
а остаются всегда прежними, и поэтому при смене родителей он возвращается обратно.

05:21.000 --> 05:26.000
И чтобы решить эту головоломку, то необходимо перед сменой родителя

05:26.000 --> 05:34.000
забрать мировые координаты потомка в отдельные переменные, а после смены, назначить эти координаты позиции потомка.

05:34.000 --> 05:39.000
Но и в то же время нужно обнулить значение вращения центрального куба,

05:39.000 --> 05:43.000
чтобы потомок начинал вращаться с ним с того же положения.

05:43.000 --> 05:51.000
И теперь если посмотрим на процесс смена родителей, то видим что потомок остается в том же положении куда и пришел,

05:51.000 --> 05:58.000
а также впоследствии новой смена родителя, он продолжает свое вращение как и предполагалось для него.

05:58.000 --> 06:06.000
Итак, теперь можно продолжать создание кубика-рубика, и создадим для начала его левую и нижнюю стороны.

06:06.000 --> 06:13.000
Для этого уберем лишние элементы управления и создадим метод, в котором определим позиции выбранных сторон.

06:13.000 --> 06:18.000
Позиции кубиков в каждой стороне очень легко создать при помощи циклов,

06:18.000 --> 06:24.000
и наряду с этим координаты кубиков будут находиться в такой структуре данных как множество.

06:24.000 --> 06:29.000
Вызвав этот метод, то вычислиться позиции кубиков для каждой из сторон,

06:29.000 --> 06:34.000
и теперь можно пройтись по этим координатам и создать нужные нам объекты.

06:34.000 --> 06:38.000
Ну и посмотрим, и сейчас можем наблюдать всего треть кубика,

06:38.000 --> 06:44.000
но пока что оставим его в таком виде для лучшего понимания происходящего.

06:44.000 --> 06:50.000
А для дальнейшей реализации понадобится словарь, ключами которого будут названия сторон куба,

06:50.000 --> 06:55.000
а значениями станут очевидные оси вращения для каждой стороны.

06:55.000 --> 07:01.000
Также нужен будет словарь для определения всех позиций кубиков по каждой стороне,

07:01.000 --> 07:06.000
и в добавок введем переменные для обозначения времени анимации поворота сторон.

07:07.000 --> 07:10.000
Далее напишем отдельный метод для смена родителя,

07:10.000 --> 07:13.000
от центрального кубика к мировой сцене.

07:13.000 --> 07:18.000
Здесь пройдемся по всем потомкам, и у кого родитель является центральным кубиком,

07:18.000 --> 07:21.000
запишем их мировые координаты,

07:21.000 --> 07:26.000
сменим родители на мировую сцену и присвоим позиции потомка его мировые координаты,

07:26.000 --> 07:31.000
а в конце приравняем к нулю значения вращения центрального кубика.

07:31.000 --> 07:37.000
А при помощи следующего метода будем осуществлять поворот необходимой стороны кубика-рубика,

07:37.000 --> 07:41.000
в этом методе по передаваемому названию стороны,

07:41.000 --> 07:44.000
определим координаты всех кубиков для данной стороны,

07:44.000 --> 07:49.000
также получим значение оси вокруг которой надо сделать поворот.

07:49.000 --> 07:53.000
Здесь же и будем вызывать метод по сменю предка на мировую сцену.

07:53.000 --> 07:58.000
И проходясь по всем кубикам, нам нужны будут кубики для текущей стороны,

07:58.000 --> 08:03.000
где назначим родителям центральный кубик и при помощи удобной функции,

08:03.000 --> 08:09.000
явал, вызовем код внутри себя по запуску анимации поворота вокруг нужной оси.

08:09.000 --> 08:13.000
И добавим управление при котором при нажатии клавиши А,

08:13.000 --> 08:19.000
будем поворачивать левую сторону, а при нажатии на С, повернем нижнюю.

08:19.000 --> 08:23.000
Если мы посмотрим как в текущей ситуации работает механизм,

08:23.000 --> 08:28.000
то очевидно что никаких проблем с правильной реализацией его работы нет.

08:28.000 --> 08:33.000
И в данный момент это достаточно любопытный вид внутренности кубика-рубика,

08:33.000 --> 08:38.000
при котором можем наблюдать, как при каждом повороте центральный кубик

08:38.000 --> 08:41.000
моментально принимает начальное положение без вращения,

08:41.000 --> 08:47.000
а также видно как составляющие кубики перемещаются по этим двум сторонам.

08:47.000 --> 08:50.000
И теперь можно собрать полный кубик-рубика,

08:50.000 --> 08:55.000
для этого добавим недостающие координаты кубиков для оставших со сторон.

08:55.000 --> 08:58.000
При этом объединение множеств таких координат,

08:58.000 --> 09:03.000
позволит избавиться от дублирующих позиций для маленьких кубиков.

09:03.000 --> 09:07.000
А далее добавим, пока что экспериментальное управление,

09:07.000 --> 09:12.000
для вращения всех сторон кубика при помощи шести клавиш.

09:12.000 --> 09:16.000
Также больше не понадобится модель системы координат,

09:16.000 --> 09:19.000
а родителям будет пустый объект без модели,

09:19.000 --> 09:22.000
так как он будет находиться в центре и не будет виден.

09:22.000 --> 09:25.000
К тому же добавим недостающие стороны в словарь

09:25.000 --> 09:29.000
для определения координат кубиков для нужной стороны.

09:29.000 --> 09:32.000
И в результате получаем кубик-рубика,

09:32.000 --> 09:35.000
в котором можно вращать любую сторону,

09:35.000 --> 09:37.000
и выглядит все вполне достойно,

09:37.000 --> 09:40.000
но есть один существенный недостаток.

09:40.000 --> 09:43.000
Если мы будем нажимать на клавишу быстрее,

09:43.000 --> 09:46.000
чем происходит анимация вращения стороны,

09:46.000 --> 09:49.000
то кубик просто-напросто весь сломается.

09:51.000 --> 09:54.000
Чтобы исправить такое недоразумение,

09:54.000 --> 09:58.000
то создадим триггер для разрешения очередного поворота стороны.

09:58.000 --> 10:03.000
Напишем метод при помощи которого будем менять логическое значение триггера.

10:03.000 --> 10:07.000
И как только начинает вращаться какая-нибудь сторона,

10:07.000 --> 10:10.000
то присваиваем ему ложное значение,

10:10.000 --> 10:13.000
и это значение станет истинным только в том случае,

10:13.000 --> 10:16.000
когда закончится вся анимация поворота.

10:16.000 --> 10:19.000
Ну и конечно же, состояние этого триггера

10:19.000 --> 10:22.000
будем проверять при нажатии очередной клавиши.

10:23.000 --> 10:25.000
И вот при таком раскладе,

10:25.000 --> 10:28.000
можно нажимать на клавиша с любой частоту

10:28.000 --> 10:31.000
и при этом с кубиком ничего странного не происходит.

10:31.000 --> 10:35.000
И казалось бы на таком шаге можно завершать этот сюжет,

10:35.000 --> 10:38.000
но то управление которое реализовано в данный момент

10:38.000 --> 10:40.000
мне крайне не нравится,

10:40.000 --> 10:42.000
потому что при поворотах камеры

10:42.000 --> 10:45.000
полностью теряешься в расположении сторон куба.

10:45.000 --> 10:48.000
Поэтому сделаем более интуитивное управление

10:48.000 --> 10:52.000
и управлять поворотами будем только при помощи мышки.

10:54.000 --> 10:56.000
Сделаем два режима.

10:56.000 --> 10:58.000
Режим обзор и режим взаимодействия,

10:58.000 --> 11:02.000
а переключение между ними будет нажать и на колесика мыши.

11:02.000 --> 11:05.000
Для этого создаем логическую перемену,

11:05.000 --> 11:08.000
а также объект вывода текста на экран о том,

11:08.000 --> 11:10.000
какой сейчас режим,

11:10.000 --> 11:12.000
и понадобится отдельный метод,

11:12.000 --> 11:16.000
в котором меняем логическое состояние переменной режима игры,

11:16.000 --> 11:20.000
и на основании этого значения выводим сообщение.

11:20.000 --> 11:22.000
Исследовательно в управлении,

11:22.000 --> 11:26.000
вызываем этот метод при нажатии средней клавиши мыши.

11:28.000 --> 11:30.000
И как можете видеть внизу экрана,

11:30.000 --> 11:32.000
отображаемый текст изменяется

11:32.000 --> 11:35.000
при каждом нажатии на колесика мыши,

11:35.000 --> 11:39.000
а теперь можно и переходить к дальнейшей разработке управления.

11:40.000 --> 11:43.000
Итак, сделаем метод при помощи которого создадим

11:43.000 --> 11:45.000
так называемые сенсоры,

11:45.000 --> 11:47.000
это будут трехмерные модели,

11:47.000 --> 11:50.000
покрывающие каждую сторону кубика-рубика.

11:50.000 --> 11:53.000
Отличительной особенностью станет то,

11:53.000 --> 11:55.000
что у них будет активирован коллайдер,

11:55.000 --> 11:58.000
то есть движок будет их брать в расчет

11:58.000 --> 12:01.000
для вычисления столкновений по их форме,

12:01.000 --> 12:04.000
а также у них будет задан параметры имени.

12:04.000 --> 12:08.000
В нашем случае он будет обозначать каждую сторону кубика-рубика,

12:08.000 --> 12:13.000
и для примера, посмотрим как будет выглядеть сенсор для левой стороны.

12:13.000 --> 12:16.000
Но такие сенсоры не будем отображать,

12:16.000 --> 12:19.000
так как у объектов есть такой параметр как видимость,

12:19.000 --> 12:23.000
то есть движок производит все и расчеты с объектом,

12:23.000 --> 12:26.000
но в то же время объект не выводится на экран.

12:26.000 --> 12:29.000
И чтобы создать адекватное управление,

12:29.000 --> 12:32.000
то такие объекты должны располагаться таким образом,

12:32.000 --> 12:35.000
чтобы они не накладывались друг на друга,

12:35.000 --> 12:38.000
то есть надо сделать небольшой зазор в их расположении.

12:38.000 --> 12:42.000
И важным шагом остается переделать управление.

12:42.000 --> 12:46.000
Мы проверим что происходит нажатие левой или правой клавиш мыши,

12:46.000 --> 12:49.000
при этом переменные режима игры.

12:49.000 --> 12:52.000
Тригеры действий должны быть истинными.

12:52.000 --> 12:55.000
Далее мы получим название у всех объектов,

12:55.000 --> 12:58.000
которых задан параметр обработки коллизий,

12:58.000 --> 13:02.000
и те названия которые совпадают с названиями сторон куба.

13:02.000 --> 13:05.000
Будем передавать метод вращения сторон.

13:05.000 --> 13:10.000
Для текущего случая боковые стороны будут поворачиваться по нажатию левой кнопки,

13:10.000 --> 13:15.000
а верхняя или нижняя сторона, по нажатию правой кнопки мыши.

13:15.000 --> 13:18.000
И теперь можно сказать что все готово.

13:18.000 --> 13:22.000
Получили кубик рубика который можно управлять при помощи одной мышки,

13:22.000 --> 13:24.000
переключаясь между режимами.

13:24.000 --> 13:29.000
Получили возможность вращаться стороны куба из нужного положения обзора,

13:29.000 --> 13:33.000
а на самом деле управление, это выбор вкуса.

13:33.000 --> 13:37.000
Так что реализовать свое видение управления не составит особого труда.

13:37.000 --> 13:39.000
Но это еще не все.

13:39.000 --> 13:42.000
Мне захотелось добавить немного интерактива,

13:42.000 --> 13:48.000
и давайте сделаем так, чтобы изначально кубик рубика находился в другом исходном состоянии.

13:48.000 --> 13:51.000
А для выполнения такой задачи,

13:51.000 --> 13:54.000
нам понадобится второй метод для вращения сторон,

13:54.000 --> 13:59.000
но только в нем не будет анимации, и в котором для исполнения команды,

13:59.000 --> 14:03.000
воспользуемся не менее удобной функцией, экзекют,

14:03.000 --> 14:06.000
и будет метод случайного исходного состояния,

14:06.000 --> 14:10.000
в котором надо задать количество и случайных вращений нашему кубу,

14:10.000 --> 14:13.000
а стороны вращений будем случайно выбирать,

14:13.000 --> 14:18.000
из имеющихся ключей словаря для осей вращения.

14:18.000 --> 14:21.000
И таким образом, получаем кубик рубика,

14:21.000 --> 14:24.000
в котором стороны повернуты на указанное количество раз.

14:24.000 --> 14:27.000
Так что кто увлекает с этой головоломкой,

14:27.000 --> 14:31.000
то можете усложнять себе задачу увеличивая такой параметр.

14:31.000 --> 14:33.000
И в целом хочется отметить,

14:33.000 --> 14:37.000
что примененные здесь принцип родителя и потомка,

14:37.000 --> 14:41.000
можно использовать в любом движке для работы с трехмерной графикой.

14:41.000 --> 14:44.000
В общем пишите свои комментарии,

14:44.000 --> 14:47.000
и бейте в колокол, чтобы не пропустить следующий выпуск.

14:47.000 --> 14:50.000
А ваш палец вверх, как всегда,

14:50.000 --> 14:53.000
будет мотиваций на создание нового сюжета.

14:53.000 --> 14:56.000
И всем успехов, всем пока!

