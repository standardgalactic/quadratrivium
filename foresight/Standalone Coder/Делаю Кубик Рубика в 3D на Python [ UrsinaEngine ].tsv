start	end	text
0	3000	Привет, мир!
3000	15000	В 1974 году, венгерский архитектор Рубика изобретает игрушку-головоломку, которая становится всемирно известной под названием «Кубик Рубика».
15000	19000	Эта головоломка стала наиболее продаваемой игрушкой на планете.
19000	24000	И с момента изобретения разошлась по миру почти в полмиллиарда единиц.
24000	29000	И сегодня мы рассмотрим основные моменты по созданию этой головоломки,
29000	34000	а также разберем как создать Кубик Рубика при помощи языка Python,
34000	38000	и для этого главным инструментом станет функционал и возможности.
38000	41000	Очень простого 3D-движка – Урсина.
44000	45000	Итак, приступим.
45000	52000	И чтобы установить движок Урсина, то в терминале запустим команду, представленную на экране.
53000	58000	После установки импортируем этот движок и напишем класс основного приложения,
58000	63000	точно так же как делали в сюжете про создание змейки на движке Урсина.
63000	69000	И пока что сделаем два метода для загрузки игры и для обработки событий нажатия клавиш,
69000	75000	ну и конечно же создадим экземпляр приложения, запуск которого активируем через мететран.
75000	80000	А для лучшего восприятия информации, создадим объекты окружения,
80000	86000	сделаем плоскость которая будет расположена на 5 единиц ниже начала мировой системы координат,
86000	91000	а на эту плоскость наложим текстуру которая идет в комплекте движка.
91000	95000	Также в начале координат поместим большого размера сферу,
95000	98000	на которую наложим подобранную текстуру неба,
98000	102000	то есть мы будем находиться внутри сферы наблюдая небесный купол.
102000	109000	И для лучшей наглядности, поместим трехмерную модель левосторонней системы координат на то место,
109000	113000	где начинается мировая система счета для этого движка.
113000	120000	Ну и для полной свободы действий, задействуем камеру которая управляется при помощи мышки.
120000	128000	И если посмотреть на то что у нас вышло, то мы видим что получился достаточно оживленный каркас приложения,
128000	133000	в котором при приятном окружении можем наблюдать начало мировой системы координат,
133000	138000	что в свою очередь поможет более лучше понять работу с трехмерным пространством.
138000	144000	Но чтобы двигаться дальше, то необходимо создать модель одного маленького кубика,
144000	146000	так сказать структурной единицы.
146000	151000	И проще всего будет работать с кубом, размеры сторон которого равны одному,
151000	156000	а его центр должен находиться в начале локальной системы координат.
156000	159000	Также нам важна карта текстура такого кубика,
159000	165000	которую мы самостоятельно разукрасим при помощи любого растрового редактора.
165000	171000	И при этом будем придерживаться классической раскраски грани для нашего кубика.
171000	177000	И тогда, отдельными атрибутами сделаем пути для новой модели куба его текстуры,
177000	182000	и чтобы проверить его отображение, то создадим один экземпляр объекта
182000	185000	используя созданную модель текстуру.
185000	190000	И как можно видеть, у нас появилась рукотворная структурная единица,
190000	193000	при помощи которой сделаем целый кубик рубика.
193000	197000	Но в начале координат мы поместим совершенно другой объект,
197000	199000	это будет так называемый родитель.
199000	206000	Он будет самым главным кубиком при помощи которого будет работать весь механизм кубика рубика.
206000	212000	Так вот, и нашему объекту укажем, что он будет потомком родительского кубика,
212000	214000	и расположим его слева от родителя.
214000	218000	А для более очевидной работы механизма наследования,
218000	222000	сделаем вращение родителя на 90 градусов вокруг оси Х,
222000	226000	и вращаться родитель будет по нажатию левой клавиши мыши.
226000	229000	Теперь посмотрим как это работает.
229000	233000	И перед нами в центре мировой системы отчета находится родитель,
233000	238000	у него шахматная текстура, а сбоку от него, его потомок.
238000	242000	И при нажатии левой клавиши мыши происходит вращение родителя,
242000	248000	а если посмотреть на движение потомка, он полностью повторяет те же движения,
248000	251000	то есть так же вращается вокруг оси Х,
251000	256000	и думает тут становится очевиден весь принцип работы механизма кубика рубика,
256000	260000	и этим механизмом будет управлять только один кубик родитель.
260000	266000	Но не все так просто как кажется, нам же надо крутить только определенную сторону кубика рубика,
266000	271000	и поэтому в зависимости от стороны вращения необходимо перекреплять потомков.
271000	276000	И давайте на этом же примере посмотрим что происходит во время смена родителя.
276000	282000	На клавишу W будем обкреплять родителя, то есть родителем будет мировая сцена,
282000	287000	а на клавишу S, заново сделаем родителем центральный куб.
287000	293000	И если посмотреть на эту ситуацию, то вначале потомок вращается как и положено,
293000	299000	но когда производим смену родителя, то потомок возвращается в то место где был изначально.
299000	305000	А при назначении родителем снова центральный куб, то он перемещается в то место,
305000	309000	если бы он вращался все это время с прежним родителем.
309000	316000	Это неприятная вещь происходит потому, что координаты куба потомка относительно родителя не меняются,
316000	321000	а остаются всегда прежними, и поэтому при смене родителей он возвращается обратно.
321000	326000	И чтобы решить эту головоломку, то необходимо перед сменой родителя
326000	334000	забрать мировые координаты потомка в отдельные переменные, а после смены, назначить эти координаты позиции потомка.
334000	339000	Но и в то же время нужно обнулить значение вращения центрального куба,
339000	343000	чтобы потомок начинал вращаться с ним с того же положения.
343000	351000	И теперь если посмотрим на процесс смена родителей, то видим что потомок остается в том же положении куда и пришел,
351000	358000	а также впоследствии новой смена родителя, он продолжает свое вращение как и предполагалось для него.
358000	366000	Итак, теперь можно продолжать создание кубика-рубика, и создадим для начала его левую и нижнюю стороны.
366000	373000	Для этого уберем лишние элементы управления и создадим метод, в котором определим позиции выбранных сторон.
373000	378000	Позиции кубиков в каждой стороне очень легко создать при помощи циклов,
378000	384000	и наряду с этим координаты кубиков будут находиться в такой структуре данных как множество.
384000	389000	Вызвав этот метод, то вычислиться позиции кубиков для каждой из сторон,
389000	394000	и теперь можно пройтись по этим координатам и создать нужные нам объекты.
394000	398000	Ну и посмотрим, и сейчас можем наблюдать всего треть кубика,
398000	404000	но пока что оставим его в таком виде для лучшего понимания происходящего.
404000	410000	А для дальнейшей реализации понадобится словарь, ключами которого будут названия сторон куба,
410000	415000	а значениями станут очевидные оси вращения для каждой стороны.
415000	421000	Также нужен будет словарь для определения всех позиций кубиков по каждой стороне,
421000	426000	и в добавок введем переменные для обозначения времени анимации поворота сторон.
427000	430000	Далее напишем отдельный метод для смена родителя,
430000	433000	от центрального кубика к мировой сцене.
433000	438000	Здесь пройдемся по всем потомкам, и у кого родитель является центральным кубиком,
438000	441000	запишем их мировые координаты,
441000	446000	сменим родители на мировую сцену и присвоим позиции потомка его мировые координаты,
446000	451000	а в конце приравняем к нулю значения вращения центрального кубика.
451000	457000	А при помощи следующего метода будем осуществлять поворот необходимой стороны кубика-рубика,
457000	461000	в этом методе по передаваемому названию стороны,
461000	464000	определим координаты всех кубиков для данной стороны,
464000	469000	также получим значение оси вокруг которой надо сделать поворот.
469000	473000	Здесь же и будем вызывать метод по сменю предка на мировую сцену.
473000	478000	И проходясь по всем кубикам, нам нужны будут кубики для текущей стороны,
478000	483000	где назначим родителям центральный кубик и при помощи удобной функции,
483000	489000	явал, вызовем код внутри себя по запуску анимации поворота вокруг нужной оси.
489000	493000	И добавим управление при котором при нажатии клавиши А,
493000	499000	будем поворачивать левую сторону, а при нажатии на С, повернем нижнюю.
499000	503000	Если мы посмотрим как в текущей ситуации работает механизм,
503000	508000	то очевидно что никаких проблем с правильной реализацией его работы нет.
508000	513000	И в данный момент это достаточно любопытный вид внутренности кубика-рубика,
513000	518000	при котором можем наблюдать, как при каждом повороте центральный кубик
518000	521000	моментально принимает начальное положение без вращения,
521000	527000	а также видно как составляющие кубики перемещаются по этим двум сторонам.
527000	530000	И теперь можно собрать полный кубик-рубика,
530000	535000	для этого добавим недостающие координаты кубиков для оставших со сторон.
535000	538000	При этом объединение множеств таких координат,
538000	543000	позволит избавиться от дублирующих позиций для маленьких кубиков.
543000	547000	А далее добавим, пока что экспериментальное управление,
547000	552000	для вращения всех сторон кубика при помощи шести клавиш.
552000	556000	Также больше не понадобится модель системы координат,
556000	559000	а родителям будет пустый объект без модели,
559000	562000	так как он будет находиться в центре и не будет виден.
562000	565000	К тому же добавим недостающие стороны в словарь
565000	569000	для определения координат кубиков для нужной стороны.
569000	572000	И в результате получаем кубик-рубика,
572000	575000	в котором можно вращать любую сторону,
575000	577000	и выглядит все вполне достойно,
577000	580000	но есть один существенный недостаток.
580000	583000	Если мы будем нажимать на клавишу быстрее,
583000	586000	чем происходит анимация вращения стороны,
586000	589000	то кубик просто-напросто весь сломается.
591000	594000	Чтобы исправить такое недоразумение,
594000	598000	то создадим триггер для разрешения очередного поворота стороны.
598000	603000	Напишем метод при помощи которого будем менять логическое значение триггера.
603000	607000	И как только начинает вращаться какая-нибудь сторона,
607000	610000	то присваиваем ему ложное значение,
610000	613000	и это значение станет истинным только в том случае,
613000	616000	когда закончится вся анимация поворота.
616000	619000	Ну и конечно же, состояние этого триггера
619000	622000	будем проверять при нажатии очередной клавиши.
623000	625000	И вот при таком раскладе,
625000	628000	можно нажимать на клавиша с любой частоту
628000	631000	и при этом с кубиком ничего странного не происходит.
631000	635000	И казалось бы на таком шаге можно завершать этот сюжет,
635000	638000	но то управление которое реализовано в данный момент
638000	640000	мне крайне не нравится,
640000	642000	потому что при поворотах камеры
642000	645000	полностью теряешься в расположении сторон куба.
645000	648000	Поэтому сделаем более интуитивное управление
648000	652000	и управлять поворотами будем только при помощи мышки.
654000	656000	Сделаем два режима.
656000	658000	Режим обзор и режим взаимодействия,
658000	662000	а переключение между ними будет нажать и на колесика мыши.
662000	665000	Для этого создаем логическую перемену,
665000	668000	а также объект вывода текста на экран о том,
668000	670000	какой сейчас режим,
670000	672000	и понадобится отдельный метод,
672000	676000	в котором меняем логическое состояние переменной режима игры,
676000	680000	и на основании этого значения выводим сообщение.
680000	682000	Исследовательно в управлении,
682000	686000	вызываем этот метод при нажатии средней клавиши мыши.
688000	690000	И как можете видеть внизу экрана,
690000	692000	отображаемый текст изменяется
692000	695000	при каждом нажатии на колесика мыши,
695000	699000	а теперь можно и переходить к дальнейшей разработке управления.
700000	703000	Итак, сделаем метод при помощи которого создадим
703000	705000	так называемые сенсоры,
705000	707000	это будут трехмерные модели,
707000	710000	покрывающие каждую сторону кубика-рубика.
710000	713000	Отличительной особенностью станет то,
713000	715000	что у них будет активирован коллайдер,
715000	718000	то есть движок будет их брать в расчет
718000	721000	для вычисления столкновений по их форме,
721000	724000	а также у них будет задан параметры имени.
724000	728000	В нашем случае он будет обозначать каждую сторону кубика-рубика,
728000	733000	и для примера, посмотрим как будет выглядеть сенсор для левой стороны.
733000	736000	Но такие сенсоры не будем отображать,
736000	739000	так как у объектов есть такой параметр как видимость,
739000	743000	то есть движок производит все и расчеты с объектом,
743000	746000	но в то же время объект не выводится на экран.
746000	749000	И чтобы создать адекватное управление,
749000	752000	то такие объекты должны располагаться таким образом,
752000	755000	чтобы они не накладывались друг на друга,
755000	758000	то есть надо сделать небольшой зазор в их расположении.
758000	762000	И важным шагом остается переделать управление.
762000	766000	Мы проверим что происходит нажатие левой или правой клавиш мыши,
766000	769000	при этом переменные режима игры.
769000	772000	Тригеры действий должны быть истинными.
772000	775000	Далее мы получим название у всех объектов,
775000	778000	которых задан параметр обработки коллизий,
778000	782000	и те названия которые совпадают с названиями сторон куба.
782000	785000	Будем передавать метод вращения сторон.
785000	790000	Для текущего случая боковые стороны будут поворачиваться по нажатию левой кнопки,
790000	795000	а верхняя или нижняя сторона, по нажатию правой кнопки мыши.
795000	798000	И теперь можно сказать что все готово.
798000	802000	Получили кубик рубика который можно управлять при помощи одной мышки,
802000	804000	переключаясь между режимами.
804000	809000	Получили возможность вращаться стороны куба из нужного положения обзора,
809000	813000	а на самом деле управление, это выбор вкуса.
813000	817000	Так что реализовать свое видение управления не составит особого труда.
817000	819000	Но это еще не все.
819000	822000	Мне захотелось добавить немного интерактива,
822000	828000	и давайте сделаем так, чтобы изначально кубик рубика находился в другом исходном состоянии.
828000	831000	А для выполнения такой задачи,
831000	834000	нам понадобится второй метод для вращения сторон,
834000	839000	но только в нем не будет анимации, и в котором для исполнения команды,
839000	843000	воспользуемся не менее удобной функцией, экзекют,
843000	846000	и будет метод случайного исходного состояния,
846000	850000	в котором надо задать количество и случайных вращений нашему кубу,
850000	853000	а стороны вращений будем случайно выбирать,
853000	858000	из имеющихся ключей словаря для осей вращения.
858000	861000	И таким образом, получаем кубик рубика,
861000	864000	в котором стороны повернуты на указанное количество раз.
864000	867000	Так что кто увлекает с этой головоломкой,
867000	871000	то можете усложнять себе задачу увеличивая такой параметр.
871000	873000	И в целом хочется отметить,
873000	877000	что примененные здесь принцип родителя и потомка,
877000	881000	можно использовать в любом движке для работы с трехмерной графикой.
881000	884000	В общем пишите свои комментарии,
884000	887000	и бейте в колокол, чтобы не пропустить следующий выпуск.
887000	890000	А ваш палец вверх, как всегда,
890000	893000	будет мотиваций на создание нового сюжета.
893000	896000	И всем успехов, всем пока!
