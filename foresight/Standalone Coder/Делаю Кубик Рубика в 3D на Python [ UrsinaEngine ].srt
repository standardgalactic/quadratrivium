1
00:00:00,000 --> 00:00:03,000
Привет, мир!

2
00:00:03,000 --> 00:00:15,000
В 1974 году, венгерский архитектор Рубика изобретает игрушку-головоломку, которая становится всемирно известной под названием «Кубик Рубика».

3
00:00:15,000 --> 00:00:19,000
Эта головоломка стала наиболее продаваемой игрушкой на планете.

4
00:00:19,000 --> 00:00:24,000
И с момента изобретения разошлась по миру почти в полмиллиарда единиц.

5
00:00:24,000 --> 00:00:29,000
И сегодня мы рассмотрим основные моменты по созданию этой головоломки,

6
00:00:29,000 --> 00:00:34,000
а также разберем как создать Кубик Рубика при помощи языка Python,

7
00:00:34,000 --> 00:00:38,000
и для этого главным инструментом станет функционал и возможности.

8
00:00:38,000 --> 00:00:41,000
Очень простого 3D-движка – Урсина.

9
00:00:44,000 --> 00:00:45,000
Итак, приступим.

10
00:00:45,000 --> 00:00:52,000
И чтобы установить движок Урсина, то в терминале запустим команду, представленную на экране.

11
00:00:53,000 --> 00:00:58,000
После установки импортируем этот движок и напишем класс основного приложения,

12
00:00:58,000 --> 00:01:03,000
точно так же как делали в сюжете про создание змейки на движке Урсина.

13
00:01:03,000 --> 00:01:09,000
И пока что сделаем два метода для загрузки игры и для обработки событий нажатия клавиш,

14
00:01:09,000 --> 00:01:15,000
ну и конечно же создадим экземпляр приложения, запуск которого активируем через мететран.

15
00:01:15,000 --> 00:01:20,000
А для лучшего восприятия информации, создадим объекты окружения,

16
00:01:20,000 --> 00:01:26,000
сделаем плоскость которая будет расположена на 5 единиц ниже начала мировой системы координат,

17
00:01:26,000 --> 00:01:31,000
а на эту плоскость наложим текстуру которая идет в комплекте движка.

18
00:01:31,000 --> 00:01:35,000
Также в начале координат поместим большого размера сферу,

19
00:01:35,000 --> 00:01:38,000
на которую наложим подобранную текстуру неба,

20
00:01:38,000 --> 00:01:42,000
то есть мы будем находиться внутри сферы наблюдая небесный купол.

21
00:01:42,000 --> 00:01:49,000
И для лучшей наглядности, поместим трехмерную модель левосторонней системы координат на то место,

22
00:01:49,000 --> 00:01:53,000
где начинается мировая система счета для этого движка.

23
00:01:53,000 --> 00:02:00,000
Ну и для полной свободы действий, задействуем камеру которая управляется при помощи мышки.

24
00:02:00,000 --> 00:02:08,000
И если посмотреть на то что у нас вышло, то мы видим что получился достаточно оживленный каркас приложения,

25
00:02:08,000 --> 00:02:13,000
в котором при приятном окружении можем наблюдать начало мировой системы координат,

26
00:02:13,000 --> 00:02:18,000
что в свою очередь поможет более лучше понять работу с трехмерным пространством.

27
00:02:18,000 --> 00:02:24,000
Но чтобы двигаться дальше, то необходимо создать модель одного маленького кубика,

28
00:02:24,000 --> 00:02:26,000
так сказать структурной единицы.

29
00:02:26,000 --> 00:02:31,000
И проще всего будет работать с кубом, размеры сторон которого равны одному,

30
00:02:31,000 --> 00:02:36,000
а его центр должен находиться в начале локальной системы координат.

31
00:02:36,000 --> 00:02:39,000
Также нам важна карта текстура такого кубика,

32
00:02:39,000 --> 00:02:45,000
которую мы самостоятельно разукрасим при помощи любого растрового редактора.

33
00:02:45,000 --> 00:02:51,000
И при этом будем придерживаться классической раскраски грани для нашего кубика.

34
00:02:51,000 --> 00:02:57,000
И тогда, отдельными атрибутами сделаем пути для новой модели куба его текстуры,

35
00:02:57,000 --> 00:03:02,000
и чтобы проверить его отображение, то создадим один экземпляр объекта

36
00:03:02,000 --> 00:03:05,000
используя созданную модель текстуру.

37
00:03:05,000 --> 00:03:10,000
И как можно видеть, у нас появилась рукотворная структурная единица,

38
00:03:10,000 --> 00:03:13,000
при помощи которой сделаем целый кубик рубика.

39
00:03:13,000 --> 00:03:17,000
Но в начале координат мы поместим совершенно другой объект,

40
00:03:17,000 --> 00:03:19,000
это будет так называемый родитель.

41
00:03:19,000 --> 00:03:26,000
Он будет самым главным кубиком при помощи которого будет работать весь механизм кубика рубика.

42
00:03:26,000 --> 00:03:32,000
Так вот, и нашему объекту укажем, что он будет потомком родительского кубика,

43
00:03:32,000 --> 00:03:34,000
и расположим его слева от родителя.

44
00:03:34,000 --> 00:03:38,000
А для более очевидной работы механизма наследования,

45
00:03:38,000 --> 00:03:42,000
сделаем вращение родителя на 90 градусов вокруг оси Х,

46
00:03:42,000 --> 00:03:46,000
и вращаться родитель будет по нажатию левой клавиши мыши.

47
00:03:46,000 --> 00:03:49,000
Теперь посмотрим как это работает.

48
00:03:49,000 --> 00:03:53,000
И перед нами в центре мировой системы отчета находится родитель,

49
00:03:53,000 --> 00:03:58,000
у него шахматная текстура, а сбоку от него, его потомок.

50
00:03:58,000 --> 00:04:02,000
И при нажатии левой клавиши мыши происходит вращение родителя,

51
00:04:02,000 --> 00:04:08,000
а если посмотреть на движение потомка, он полностью повторяет те же движения,

52
00:04:08,000 --> 00:04:11,000
то есть так же вращается вокруг оси Х,

53
00:04:11,000 --> 00:04:16,000
и думает тут становится очевиден весь принцип работы механизма кубика рубика,

54
00:04:16,000 --> 00:04:20,000
и этим механизмом будет управлять только один кубик родитель.

55
00:04:20,000 --> 00:04:26,000
Но не все так просто как кажется, нам же надо крутить только определенную сторону кубика рубика,

56
00:04:26,000 --> 00:04:31,000
и поэтому в зависимости от стороны вращения необходимо перекреплять потомков.

57
00:04:31,000 --> 00:04:36,000
И давайте на этом же примере посмотрим что происходит во время смена родителя.

58
00:04:36,000 --> 00:04:42,000
На клавишу W будем обкреплять родителя, то есть родителем будет мировая сцена,

59
00:04:42,000 --> 00:04:47,000
а на клавишу S, заново сделаем родителем центральный куб.

60
00:04:47,000 --> 00:04:53,000
И если посмотреть на эту ситуацию, то вначале потомок вращается как и положено,

61
00:04:53,000 --> 00:04:59,000
но когда производим смену родителя, то потомок возвращается в то место где был изначально.

62
00:04:59,000 --> 00:05:05,000
А при назначении родителем снова центральный куб, то он перемещается в то место,

63
00:05:05,000 --> 00:05:09,000
если бы он вращался все это время с прежним родителем.

64
00:05:09,000 --> 00:05:16,000
Это неприятная вещь происходит потому, что координаты куба потомка относительно родителя не меняются,

65
00:05:16,000 --> 00:05:21,000
а остаются всегда прежними, и поэтому при смене родителей он возвращается обратно.

66
00:05:21,000 --> 00:05:26,000
И чтобы решить эту головоломку, то необходимо перед сменой родителя

67
00:05:26,000 --> 00:05:34,000
забрать мировые координаты потомка в отдельные переменные, а после смены, назначить эти координаты позиции потомка.

68
00:05:34,000 --> 00:05:39,000
Но и в то же время нужно обнулить значение вращения центрального куба,

69
00:05:39,000 --> 00:05:43,000
чтобы потомок начинал вращаться с ним с того же положения.

70
00:05:43,000 --> 00:05:51,000
И теперь если посмотрим на процесс смена родителей, то видим что потомок остается в том же положении куда и пришел,

71
00:05:51,000 --> 00:05:58,000
а также впоследствии новой смена родителя, он продолжает свое вращение как и предполагалось для него.

72
00:05:58,000 --> 00:06:06,000
Итак, теперь можно продолжать создание кубика-рубика, и создадим для начала его левую и нижнюю стороны.

73
00:06:06,000 --> 00:06:13,000
Для этого уберем лишние элементы управления и создадим метод, в котором определим позиции выбранных сторон.

74
00:06:13,000 --> 00:06:18,000
Позиции кубиков в каждой стороне очень легко создать при помощи циклов,

75
00:06:18,000 --> 00:06:24,000
и наряду с этим координаты кубиков будут находиться в такой структуре данных как множество.

76
00:06:24,000 --> 00:06:29,000
Вызвав этот метод, то вычислиться позиции кубиков для каждой из сторон,

77
00:06:29,000 --> 00:06:34,000
и теперь можно пройтись по этим координатам и создать нужные нам объекты.

78
00:06:34,000 --> 00:06:38,000
Ну и посмотрим, и сейчас можем наблюдать всего треть кубика,

79
00:06:38,000 --> 00:06:44,000
но пока что оставим его в таком виде для лучшего понимания происходящего.

80
00:06:44,000 --> 00:06:50,000
А для дальнейшей реализации понадобится словарь, ключами которого будут названия сторон куба,

81
00:06:50,000 --> 00:06:55,000
а значениями станут очевидные оси вращения для каждой стороны.

82
00:06:55,000 --> 00:07:01,000
Также нужен будет словарь для определения всех позиций кубиков по каждой стороне,

83
00:07:01,000 --> 00:07:06,000
и в добавок введем переменные для обозначения времени анимации поворота сторон.

84
00:07:07,000 --> 00:07:10,000
Далее напишем отдельный метод для смена родителя,

85
00:07:10,000 --> 00:07:13,000
от центрального кубика к мировой сцене.

86
00:07:13,000 --> 00:07:18,000
Здесь пройдемся по всем потомкам, и у кого родитель является центральным кубиком,

87
00:07:18,000 --> 00:07:21,000
запишем их мировые координаты,

88
00:07:21,000 --> 00:07:26,000
сменим родители на мировую сцену и присвоим позиции потомка его мировые координаты,

89
00:07:26,000 --> 00:07:31,000
а в конце приравняем к нулю значения вращения центрального кубика.

90
00:07:31,000 --> 00:07:37,000
А при помощи следующего метода будем осуществлять поворот необходимой стороны кубика-рубика,

91
00:07:37,000 --> 00:07:41,000
в этом методе по передаваемому названию стороны,

92
00:07:41,000 --> 00:07:44,000
определим координаты всех кубиков для данной стороны,

93
00:07:44,000 --> 00:07:49,000
также получим значение оси вокруг которой надо сделать поворот.

94
00:07:49,000 --> 00:07:53,000
Здесь же и будем вызывать метод по сменю предка на мировую сцену.

95
00:07:53,000 --> 00:07:58,000
И проходясь по всем кубикам, нам нужны будут кубики для текущей стороны,

96
00:07:58,000 --> 00:08:03,000
где назначим родителям центральный кубик и при помощи удобной функции,

97
00:08:03,000 --> 00:08:09,000
явал, вызовем код внутри себя по запуску анимации поворота вокруг нужной оси.

98
00:08:09,000 --> 00:08:13,000
И добавим управление при котором при нажатии клавиши А,

99
00:08:13,000 --> 00:08:19,000
будем поворачивать левую сторону, а при нажатии на С, повернем нижнюю.

100
00:08:19,000 --> 00:08:23,000
Если мы посмотрим как в текущей ситуации работает механизм,

101
00:08:23,000 --> 00:08:28,000
то очевидно что никаких проблем с правильной реализацией его работы нет.

102
00:08:28,000 --> 00:08:33,000
И в данный момент это достаточно любопытный вид внутренности кубика-рубика,

103
00:08:33,000 --> 00:08:38,000
при котором можем наблюдать, как при каждом повороте центральный кубик

104
00:08:38,000 --> 00:08:41,000
моментально принимает начальное положение без вращения,

105
00:08:41,000 --> 00:08:47,000
а также видно как составляющие кубики перемещаются по этим двум сторонам.

106
00:08:47,000 --> 00:08:50,000
И теперь можно собрать полный кубик-рубика,

107
00:08:50,000 --> 00:08:55,000
для этого добавим недостающие координаты кубиков для оставших со сторон.

108
00:08:55,000 --> 00:08:58,000
При этом объединение множеств таких координат,

109
00:08:58,000 --> 00:09:03,000
позволит избавиться от дублирующих позиций для маленьких кубиков.

110
00:09:03,000 --> 00:09:07,000
А далее добавим, пока что экспериментальное управление,

111
00:09:07,000 --> 00:09:12,000
для вращения всех сторон кубика при помощи шести клавиш.

112
00:09:12,000 --> 00:09:16,000
Также больше не понадобится модель системы координат,

113
00:09:16,000 --> 00:09:19,000
а родителям будет пустый объект без модели,

114
00:09:19,000 --> 00:09:22,000
так как он будет находиться в центре и не будет виден.

115
00:09:22,000 --> 00:09:25,000
К тому же добавим недостающие стороны в словарь

116
00:09:25,000 --> 00:09:29,000
для определения координат кубиков для нужной стороны.

117
00:09:29,000 --> 00:09:32,000
И в результате получаем кубик-рубика,

118
00:09:32,000 --> 00:09:35,000
в котором можно вращать любую сторону,

119
00:09:35,000 --> 00:09:37,000
и выглядит все вполне достойно,

120
00:09:37,000 --> 00:09:40,000
но есть один существенный недостаток.

121
00:09:40,000 --> 00:09:43,000
Если мы будем нажимать на клавишу быстрее,

122
00:09:43,000 --> 00:09:46,000
чем происходит анимация вращения стороны,

123
00:09:46,000 --> 00:09:49,000
то кубик просто-напросто весь сломается.

124
00:09:51,000 --> 00:09:54,000
Чтобы исправить такое недоразумение,

125
00:09:54,000 --> 00:09:58,000
то создадим триггер для разрешения очередного поворота стороны.

126
00:09:58,000 --> 00:10:03,000
Напишем метод при помощи которого будем менять логическое значение триггера.

127
00:10:03,000 --> 00:10:07,000
И как только начинает вращаться какая-нибудь сторона,

128
00:10:07,000 --> 00:10:10,000
то присваиваем ему ложное значение,

129
00:10:10,000 --> 00:10:13,000
и это значение станет истинным только в том случае,

130
00:10:13,000 --> 00:10:16,000
когда закончится вся анимация поворота.

131
00:10:16,000 --> 00:10:19,000
Ну и конечно же, состояние этого триггера

132
00:10:19,000 --> 00:10:22,000
будем проверять при нажатии очередной клавиши.

133
00:10:23,000 --> 00:10:25,000
И вот при таком раскладе,

134
00:10:25,000 --> 00:10:28,000
можно нажимать на клавиша с любой частоту

135
00:10:28,000 --> 00:10:31,000
и при этом с кубиком ничего странного не происходит.

136
00:10:31,000 --> 00:10:35,000
И казалось бы на таком шаге можно завершать этот сюжет,

137
00:10:35,000 --> 00:10:38,000
но то управление которое реализовано в данный момент

138
00:10:38,000 --> 00:10:40,000
мне крайне не нравится,

139
00:10:40,000 --> 00:10:42,000
потому что при поворотах камеры

140
00:10:42,000 --> 00:10:45,000
полностью теряешься в расположении сторон куба.

141
00:10:45,000 --> 00:10:48,000
Поэтому сделаем более интуитивное управление

142
00:10:48,000 --> 00:10:52,000
и управлять поворотами будем только при помощи мышки.

143
00:10:54,000 --> 00:10:56,000
Сделаем два режима.

144
00:10:56,000 --> 00:10:58,000
Режим обзор и режим взаимодействия,

145
00:10:58,000 --> 00:11:02,000
а переключение между ними будет нажать и на колесика мыши.

146
00:11:02,000 --> 00:11:05,000
Для этого создаем логическую перемену,

147
00:11:05,000 --> 00:11:08,000
а также объект вывода текста на экран о том,

148
00:11:08,000 --> 00:11:10,000
какой сейчас режим,

149
00:11:10,000 --> 00:11:12,000
и понадобится отдельный метод,

150
00:11:12,000 --> 00:11:16,000
в котором меняем логическое состояние переменной режима игры,

151
00:11:16,000 --> 00:11:20,000
и на основании этого значения выводим сообщение.

152
00:11:20,000 --> 00:11:22,000
Исследовательно в управлении,

153
00:11:22,000 --> 00:11:26,000
вызываем этот метод при нажатии средней клавиши мыши.

154
00:11:28,000 --> 00:11:30,000
И как можете видеть внизу экрана,

155
00:11:30,000 --> 00:11:32,000
отображаемый текст изменяется

156
00:11:32,000 --> 00:11:35,000
при каждом нажатии на колесика мыши,

157
00:11:35,000 --> 00:11:39,000
а теперь можно и переходить к дальнейшей разработке управления.

158
00:11:40,000 --> 00:11:43,000
Итак, сделаем метод при помощи которого создадим

159
00:11:43,000 --> 00:11:45,000
так называемые сенсоры,

160
00:11:45,000 --> 00:11:47,000
это будут трехмерные модели,

161
00:11:47,000 --> 00:11:50,000
покрывающие каждую сторону кубика-рубика.

162
00:11:50,000 --> 00:11:53,000
Отличительной особенностью станет то,

163
00:11:53,000 --> 00:11:55,000
что у них будет активирован коллайдер,

164
00:11:55,000 --> 00:11:58,000
то есть движок будет их брать в расчет

165
00:11:58,000 --> 00:12:01,000
для вычисления столкновений по их форме,

166
00:12:01,000 --> 00:12:04,000
а также у них будет задан параметры имени.

167
00:12:04,000 --> 00:12:08,000
В нашем случае он будет обозначать каждую сторону кубика-рубика,

168
00:12:08,000 --> 00:12:13,000
и для примера, посмотрим как будет выглядеть сенсор для левой стороны.

169
00:12:13,000 --> 00:12:16,000
Но такие сенсоры не будем отображать,

170
00:12:16,000 --> 00:12:19,000
так как у объектов есть такой параметр как видимость,

171
00:12:19,000 --> 00:12:23,000
то есть движок производит все и расчеты с объектом,

172
00:12:23,000 --> 00:12:26,000
но в то же время объект не выводится на экран.

173
00:12:26,000 --> 00:12:29,000
И чтобы создать адекватное управление,

174
00:12:29,000 --> 00:12:32,000
то такие объекты должны располагаться таким образом,

175
00:12:32,000 --> 00:12:35,000
чтобы они не накладывались друг на друга,

176
00:12:35,000 --> 00:12:38,000
то есть надо сделать небольшой зазор в их расположении.

177
00:12:38,000 --> 00:12:42,000
И важным шагом остается переделать управление.

178
00:12:42,000 --> 00:12:46,000
Мы проверим что происходит нажатие левой или правой клавиш мыши,

179
00:12:46,000 --> 00:12:49,000
при этом переменные режима игры.

180
00:12:49,000 --> 00:12:52,000
Тригеры действий должны быть истинными.

181
00:12:52,000 --> 00:12:55,000
Далее мы получим название у всех объектов,

182
00:12:55,000 --> 00:12:58,000
которых задан параметр обработки коллизий,

183
00:12:58,000 --> 00:13:02,000
и те названия которые совпадают с названиями сторон куба.

184
00:13:02,000 --> 00:13:05,000
Будем передавать метод вращения сторон.

185
00:13:05,000 --> 00:13:10,000
Для текущего случая боковые стороны будут поворачиваться по нажатию левой кнопки,

186
00:13:10,000 --> 00:13:15,000
а верхняя или нижняя сторона, по нажатию правой кнопки мыши.

187
00:13:15,000 --> 00:13:18,000
И теперь можно сказать что все готово.

188
00:13:18,000 --> 00:13:22,000
Получили кубик рубика который можно управлять при помощи одной мышки,

189
00:13:22,000 --> 00:13:24,000
переключаясь между режимами.

190
00:13:24,000 --> 00:13:29,000
Получили возможность вращаться стороны куба из нужного положения обзора,

191
00:13:29,000 --> 00:13:33,000
а на самом деле управление, это выбор вкуса.

192
00:13:33,000 --> 00:13:37,000
Так что реализовать свое видение управления не составит особого труда.

193
00:13:37,000 --> 00:13:39,000
Но это еще не все.

194
00:13:39,000 --> 00:13:42,000
Мне захотелось добавить немного интерактива,

195
00:13:42,000 --> 00:13:48,000
и давайте сделаем так, чтобы изначально кубик рубика находился в другом исходном состоянии.

196
00:13:48,000 --> 00:13:51,000
А для выполнения такой задачи,

197
00:13:51,000 --> 00:13:54,000
нам понадобится второй метод для вращения сторон,

198
00:13:54,000 --> 00:13:59,000
но только в нем не будет анимации, и в котором для исполнения команды,

199
00:13:59,000 --> 00:14:03,000
воспользуемся не менее удобной функцией, экзекют,

200
00:14:03,000 --> 00:14:06,000
и будет метод случайного исходного состояния,

201
00:14:06,000 --> 00:14:10,000
в котором надо задать количество и случайных вращений нашему кубу,

202
00:14:10,000 --> 00:14:13,000
а стороны вращений будем случайно выбирать,

203
00:14:13,000 --> 00:14:18,000
из имеющихся ключей словаря для осей вращения.

204
00:14:18,000 --> 00:14:21,000
И таким образом, получаем кубик рубика,

205
00:14:21,000 --> 00:14:24,000
в котором стороны повернуты на указанное количество раз.

206
00:14:24,000 --> 00:14:27,000
Так что кто увлекает с этой головоломкой,

207
00:14:27,000 --> 00:14:31,000
то можете усложнять себе задачу увеличивая такой параметр.

208
00:14:31,000 --> 00:14:33,000
И в целом хочется отметить,

209
00:14:33,000 --> 00:14:37,000
что примененные здесь принцип родителя и потомка,

210
00:14:37,000 --> 00:14:41,000
можно использовать в любом движке для работы с трехмерной графикой.

211
00:14:41,000 --> 00:14:44,000
В общем пишите свои комментарии,

212
00:14:44,000 --> 00:14:47,000
и бейте в колокол, чтобы не пропустить следующий выпуск.

213
00:14:47,000 --> 00:14:50,000
А ваш палец вверх, как всегда,

214
00:14:50,000 --> 00:14:53,000
будет мотиваций на создание нового сюжета.

215
00:14:53,000 --> 00:14:56,000
И всем успехов, всем пока!

