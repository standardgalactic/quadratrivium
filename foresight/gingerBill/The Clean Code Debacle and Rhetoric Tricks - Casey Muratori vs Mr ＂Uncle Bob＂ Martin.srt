1
00:00:00,000 --> 00:00:06,720
Hello and welcome, I am Gingerbell and today I'll be talking about the fiasco that has

2
00:00:06,720 --> 00:00:12,840
happened between Casey Muratori and Mr. Robert C. Martin. But before that I'm going to explain

3
00:00:12,840 --> 00:00:16,240
why the history got here and I'm going to also explain some stuff. I'm not going to

4
00:00:16,240 --> 00:00:23,600
try and criticise clean code itself. Casey Muratori has been trying to do this in the

5
00:00:23,600 --> 00:00:29,640
long discussions he's had with Mr. Robert C. Martin already. But it's one of those things

6
00:00:29,640 --> 00:00:33,880
where I just want to kind of show the rhetoric tricks of Mr. Robert C. Martin himself. So

7
00:00:33,880 --> 00:00:39,800
before we get to that start off, let's begin with the thing that started it all, which

8
00:00:39,800 --> 00:00:46,960
was this video that Casey made public from his thing. It's called clean code, horrible

9
00:00:46,960 --> 00:00:52,680
performance, where they say 22 minutes long video, him showing the examples of what clean

10
00:00:52,680 --> 00:00:57,400
code is and going into a more, let's say more like simplified code, which is more optimised

11
00:00:57,400 --> 00:01:00,720
performance and showing the cost. Hey, if you do it the clean code where you're going

12
00:01:00,720 --> 00:01:06,280
to be 15 to 25 times slower as your performance, do you want to take that hit? Understand what

13
00:01:06,280 --> 00:01:11,160
the costs are kind of you. And again, this is this view has also taken our context is

14
00:01:11,160 --> 00:01:16,200
blown up by mad. It's nearly half a million views so far at the moment at the time of

15
00:01:16,200 --> 00:01:22,440
recording. And so it's clearly gone viral across the programming world. Unfortunately,

16
00:01:22,440 --> 00:01:31,000
because it went viral, a lot of the context got lost. And because the context got lost.

17
00:01:31,000 --> 00:01:35,080
People just adding their own context into it without even bothering to learn it. So the

18
00:01:35,080 --> 00:01:41,280
context was this comes from a series that Casey's been doing on computer hands.com,

19
00:01:41,280 --> 00:01:46,280
where it's a performance awareness course. So specifically the this is the programming

20
00:01:46,280 --> 00:01:50,640
course he's been doing to performance awareness stuff. And this is a subscribed based thing

21
00:01:50,680 --> 00:01:56,240
on the on the on here. And he's been doing many different topics on here as I was able

22
00:01:56,240 --> 00:02:01,120
to learn how to performance awareness. Specifically, this was the blog post and he made completely

23
00:02:01,120 --> 00:02:04,920
public for everybody showing all the code showing all this stuff. So then you can see

24
00:02:04,920 --> 00:02:09,320
a whole video is all kind of transcribed down. And it's part of a series. It's not the beginning

25
00:02:09,320 --> 00:02:13,240
of the fifth series is quite in the middle. So it's kind of like, Oh, okay, we're not

26
00:02:13,240 --> 00:02:18,720
starting from a random place. So and also when people say and talk about the context

27
00:02:18,720 --> 00:02:22,600
of this Casey understands this like, look, reminder, I don't think clean code is bad

28
00:02:22,600 --> 00:02:26,600
just because of performance. My recent video is about poor performance, because it's part

29
00:02:26,600 --> 00:02:31,000
of a course on performance. This is the context many people lost. And he's been doing this

30
00:02:31,000 --> 00:02:34,560
for decades is saying so I recommend reading these tweets, I will try and provide all of

31
00:02:34,560 --> 00:02:39,120
the links to everything I'm showing today in the description or the do blue do whatever

32
00:02:39,120 --> 00:02:45,680
you want to do down below on YouTube. So be here. So yeah, hello. Good. So give a background.

33
00:02:45,680 --> 00:02:51,320
He's picked up the attention of Robert, Mr. Robert C Martin, which he colloquially calls

34
00:02:51,320 --> 00:02:56,400
himself Uncle Bob. For this talk, I'm just going to call him Mr. Martin, because I just

35
00:02:56,400 --> 00:03:02,920
prefer saying Mr. Martin, insert your guesses as to why. But yeah, he is very well known

36
00:03:02,920 --> 00:03:09,080
for my mainly three things, which is the agile manifesto, he helped develop that solid the

37
00:03:09,080 --> 00:03:15,120
solid principles. So the agile manifesto and solid principles, which again, many people

38
00:03:15,160 --> 00:03:19,000
know from the world, especially that he wrote it in his in his book, which is first in design

39
00:03:19,000 --> 00:03:24,640
as principles and design patterns, as it says on here. And he's also in this thing known

40
00:03:24,640 --> 00:03:31,280
for clean code. So clean with capital C code with capital C trademarked. This is his particular

41
00:03:31,280 --> 00:03:37,600
thing, the capital C clean code thing. Okay. And this is what he kind of tries to describe.

42
00:03:37,600 --> 00:03:45,080
So to get to show my biases and my background, I am the creator of the program language here.

43
00:03:45,080 --> 00:03:48,200
And the only program language is the general purpose program language with the distinct

44
00:03:48,200 --> 00:03:53,240
typing built for high performance modern systems and data order programming. So clearly, I'm

45
00:03:53,240 --> 00:03:57,560
showing my biases, and I'm cleaning on more like case and oratory side when it comes to

46
00:03:57,560 --> 00:04:03,240
this discussion. And also, I work at Django effects on emogen and liquid gen and geo gen,

47
00:04:03,240 --> 00:04:07,320
which are all high performance real time pieces software like simulations, again, engines

48
00:04:07,320 --> 00:04:11,400
for fire, smoke and explosions in real time. So clearly, I work in an industry where we

49
00:04:11,400 --> 00:04:15,160
really care about high performance real time stuff. So clearly, I'm showing my biases straight

50
00:04:15,160 --> 00:04:21,720
away. So people understand what's going on. Okay, so now you know, that's on the way. Can

51
00:04:21,720 --> 00:04:26,760
we explain what clean code is before we get into this? So sure. So there is this kind of

52
00:04:26,760 --> 00:04:31,320
little document I found the other day, and it's been well actively updated by looks only eight

53
00:04:31,320 --> 00:04:38,440
hours ago at this time of recording. And today's date is the March the 30th, I believe. Yes, March

54
00:04:38,440 --> 00:04:43,000
the 30th. So it's very active or someone's updated there's probably some typos and such

55
00:04:43,000 --> 00:04:47,960
we can even see the revisions. And yeah, it's just some, hey, just capitalizing some straw.

56
00:04:47,960 --> 00:04:52,920
That was all it was. Now, many people have seen to have liked this clearly over 5000 stars and

57
00:04:52,920 --> 00:04:58,280
over 1000 forks of this gist, as well gist or I don't know we pronounce it on GitHub,

58
00:04:59,080 --> 00:05:05,240
and explained some of the began your principles or points about clean code. Now there's many

59
00:05:05,320 --> 00:05:09,400
of this. This is the thing about which is why clean code capital C thing trademarked by Mr

60
00:05:09,400 --> 00:05:14,200
Martin is very popular because there's many of these rules, which no one would disagree with,

61
00:05:14,200 --> 00:05:17,800
like follow standard conventions. Yeah, because conventions are a good thing because then you're

62
00:05:17,800 --> 00:05:22,680
working on the same sun, only break them when you need to keep it simple, stupid, you're fine,

63
00:05:22,680 --> 00:05:27,000
whatever. Boy Scott rule, leave the camp around cleaner than you found it, always find the root

64
00:05:27,000 --> 00:05:32,520
cause you're no problem like this, yada, yada. Now some of these are things, okay, some of these are

65
00:05:32,760 --> 00:05:37,240
not essential. These are accidental. Like, again, follow standard conventions. That's not

66
00:05:37,960 --> 00:05:42,920
a unique to clean code, is it? You can do that in any philosophy out there. It's not a unique

67
00:05:42,920 --> 00:05:48,280
principle to clean code itself. But some things like, for instance, I would say more essential

68
00:05:48,280 --> 00:05:54,520
to clean code or prefer polymorphism to if or else cases. And separate multi floating code.

69
00:05:54,520 --> 00:06:00,200
I'm not even sure what that means. Use dependency injection. Follow the law of Demeter or many

70
00:06:00,200 --> 00:06:04,040
other things, many other things like here, like, Oh, use small functions functions, they only do

71
00:06:04,040 --> 00:06:07,960
one thing use descriptive names, like getting that descriptive names, everyone agrees to that to a

72
00:06:07,960 --> 00:06:13,000
certain extent, prefer fewer arguments have no side effects. So be more functional, it means more

73
00:06:13,000 --> 00:06:17,560
and more rather than be like, have side effects itself, like be more imperative relying on like

74
00:06:17,560 --> 00:06:21,880
global state or modifying state or whatever, don't use flag arguments, yada, yada, like, okay,

75
00:06:22,680 --> 00:06:27,480
some of these people will agree with some people will disagree with them. But here's where the

76
00:06:27,800 --> 00:06:34,680
the problem is with some of this is that for the most part, some of these rules,

77
00:06:34,680 --> 00:06:38,360
people will agree with some of them don't. One of the particular is like small rules for me,

78
00:06:38,360 --> 00:06:42,680
I actually disagree with this particular thing. There was a post here, this is on Jonathan

79
00:06:42,680 --> 00:06:46,920
blows blog old, very old blog, actually, this one 2016. But he's actually even older than that,

80
00:06:46,920 --> 00:06:54,280
because it's an old email response between him and john Carmack. So this is john Carmack explaining

81
00:06:54,360 --> 00:06:59,880
effectively, what he preferred for the things is not the clean code up. This is what I wanted

82
00:06:59,880 --> 00:07:05,720
was the wrong one. Whoops. Let's go to the blog post again. And it's this one here. So I accidentally

83
00:07:05,720 --> 00:07:09,880
clicked the wrong button then. So this is john inline code. And john Carmack in the email is

84
00:07:09,880 --> 00:07:14,120
explained, actually, he doesn't like the separate single functions here. It's better just have

85
00:07:14,120 --> 00:07:18,040
one big function and then comment them. Now, some people might say be a bit easier to manage

86
00:07:18,040 --> 00:07:22,280
looking at re things. Yeah, for code reviews, in a big corporate setting, it might be easier

87
00:07:22,280 --> 00:07:26,200
looking a single function. But there's a few things you have to understand functions have

88
00:07:26,200 --> 00:07:30,360
costs. If you split these things into multiple functions, this is a one is an extra cost. Yes,

89
00:07:30,360 --> 00:07:34,760
is a minor cost when calling a function. But like that most people don't care about that cost,

90
00:07:35,480 --> 00:07:39,320
unless you're doing particular things like you're worried about stack stacks or anything like that.

91
00:07:39,320 --> 00:07:43,560
Like, okay, most things don't care. One thing it does do is it does actually doesn't mean it's

92
00:07:43,560 --> 00:07:47,800
very easy to optimize for the optimizer. And I know how compilers work because I work on them for

93
00:07:47,800 --> 00:07:53,000
kind of a living. And if you have things in line, one, it's not hard to read by just using

94
00:07:53,000 --> 00:07:56,920
comments everywhere or block codes or anything like that. I think it's just as easy. And if you've

95
00:07:56,920 --> 00:08:03,400
got text editors, which are use collapsible things, that's great. That's okay, no problems, just deal

96
00:08:03,400 --> 00:08:07,400
with it that way. But then it's like, okay, but the optimizer can be ready, doesn't have to worry

97
00:08:07,400 --> 00:08:11,240
about trying to inline that function. And then now optimize the new inline function that's been

98
00:08:11,240 --> 00:08:17,000
got in line is out of another function. So there's that. And also you can usually start to see easy

99
00:08:17,000 --> 00:08:21,800
patterns as well. If you start manually inlining things, it's not hard to read. Yes, okay, you've

100
00:08:21,800 --> 00:08:26,920
got 10,000 lines, but most people's IDs and text editors are very easy for code folding, code

101
00:08:26,920 --> 00:08:33,160
searching, code and organization. We're not living in the 80s anymore, or even the 70s,

102
00:08:33,160 --> 00:08:36,440
to be honest, because even small talk had better options than this. I'm not saying I'm a big fan

103
00:08:36,440 --> 00:08:41,640
of small talk. But again, the tooling is the argument going small function is more of a, hey,

104
00:08:41,640 --> 00:08:48,840
it's our code review practices, big corporations, testing practices, and also maybe just tooling

105
00:08:48,840 --> 00:08:53,320
practices. So that's one thing. But it's going to recommend highly reading this article, I really

106
00:08:53,320 --> 00:08:59,720
do from 2014, again, it's from 2007, as it says here, I recommend it. But what I'm trying to get

107
00:08:59,720 --> 00:09:02,600
out here about the word clean code, and I'm not even talking about the actual discussion that

108
00:09:02,600 --> 00:09:06,600
Casey Motoria, they've been having yet, because I want to try to build up a picture here, as you

109
00:09:06,600 --> 00:09:10,360
can probably tell, trying to be a storyteller, not very good at it, but let's carry on with it,

110
00:09:10,360 --> 00:09:14,040
is that the concept of clean code is what I want to the term it capital C, capital

111
00:09:14,680 --> 00:09:19,720
C on both of them, trademarked for Mr. Martin, is what I'm going to dub a pork barrel name.

112
00:09:20,600 --> 00:09:25,480
So a pork barrel is a thing that America, American English, but it's kind of a

113
00:09:27,400 --> 00:09:31,240
you have this bill, and it has a particular thing like citizens against government waste.

114
00:09:31,240 --> 00:09:35,320
But it also has all of these things that are nothing even related to the actual name of the

115
00:09:35,320 --> 00:09:39,640
bill. And to keep it in American context, because I know most people watching going to be Americans,

116
00:09:41,160 --> 00:09:44,520
so I'm not going to use an English example, or another European example, like

117
00:09:44,520 --> 00:09:47,080
Germans, I'm just going to use American example, I've run recent one as well,

118
00:09:47,720 --> 00:09:53,240
is the Inflation Reduction Act of 2022. The name of it, the Inflation Reduction Act.

119
00:09:54,520 --> 00:09:58,680
Okay, now I'm trying to be again, I'm not an American, don't really care politics, but I think

120
00:09:58,680 --> 00:10:03,560
most people would agree, this act did not reduce inflation, in fact, it printed more money,

121
00:10:04,520 --> 00:10:07,720
and more excess money, that money was not being in high demand.

122
00:10:08,680 --> 00:10:12,360
So it increased inflation, in fact, it had loads of other things in there to do with

123
00:10:12,360 --> 00:10:18,200
not to do with inflation. But a really clever political rhetoric trick is to say, oh, you

124
00:10:18,200 --> 00:10:22,040
don't like this bill, we must like inflation, you're bad, everyone dislikes inflation.

125
00:10:22,680 --> 00:10:26,840
So you must be, oh, you can't be against this bill, can you? It's like, but this doesn't,

126
00:10:26,840 --> 00:10:30,920
ah, no, no, it doesn't inflation. How dare you don't want to, like, you can do this trick. And

127
00:10:30,920 --> 00:10:34,200
again, it's not a political side either, literally all political parties or politicians,

128
00:10:34,920 --> 00:10:40,440
I do this trick. Some countries like to do, like, oh, we're just getting names from bills.

129
00:10:40,440 --> 00:10:43,800
But then they'll give them a name anyway, like a colloquial one to refer to it rather than giving

130
00:10:43,800 --> 00:10:47,640
it like a letter or a number or some random numbers or something like that bill. And they'll

131
00:10:47,640 --> 00:10:50,840
just say, look, no, this is what we're going to call it. Because technically internally,

132
00:10:51,480 --> 00:10:55,560
the Americans do, but they give them a proper name and also a very long title. Again, this is

133
00:10:55,560 --> 00:11:01,960
to provide for the reconciliation pursuant to Title II of the S Con Rez 14, I'm just reading it

134
00:11:02,040 --> 00:11:06,360
as it says on here. And it's like, okay, but that's a good example from a political standpoint.

135
00:11:06,360 --> 00:11:09,000
I'm just keeping it here, trying to keep it politically neutral. I don't really care about

136
00:11:09,000 --> 00:11:12,520
the old politics, but it's just one of those funny things that show, hey, this is a trick,

137
00:11:13,480 --> 00:11:18,440
because Mr. Martin will actually continually do this throughout. And it will trick, do a lot of

138
00:11:18,440 --> 00:11:23,320
pivoting and a lot of these poor barrel names. Okay. So let's just say this is a good example

139
00:11:23,320 --> 00:11:28,600
of this bad code. Just say no. And it's like, okay, so what's good code then? Because then it's,

140
00:11:29,400 --> 00:11:33,160
phrases in the, oh, it's clean code, obviously. Now there was another tweet, I tried to find,

141
00:11:33,160 --> 00:11:38,120
but I couldn't find it's probably been lost to the Twitter search, or it's just been deleted,

142
00:11:38,120 --> 00:11:43,160
whatever. But he will commonly do this, Mr. Martin go like, oh, the opposite of bad code is clean

143
00:11:43,160 --> 00:11:48,280
code with a capital C trademarked, which is interesting. Because that means anything that's

144
00:11:48,280 --> 00:11:56,520
not clean code is a bad code. Yeah, let's not get there. But again, very clear, careful on this,

145
00:11:56,520 --> 00:12:01,080
I'm not going to criticize him. I'm actually like, in admiration of his rhetoric, he's

146
00:12:01,080 --> 00:12:06,360
a politician level when it comes to rhetoric, I mean this. And it's like, this is really good.

147
00:12:06,360 --> 00:12:11,400
Like he's really good at it. But again, he's been doing it for nearly 50 years. He is what 70 years

148
00:12:11,400 --> 00:12:18,280
old. He's been doing this sort of job since what, God, even the early 90s. So it, okay,

149
00:12:19,640 --> 00:12:25,400
worst, like, it's 30 years, he's been doing this, he's probably been doing it for 40. Okay,

150
00:12:25,400 --> 00:12:29,240
that's what he does for a living. He's very good at this rhetoric. So that's why I'm like,

151
00:12:29,240 --> 00:12:33,320
I'm kind of admiring it into a certain extent, in a weird Machiavellian sense.

152
00:12:34,120 --> 00:12:37,400
But sure, let's carry on with this, shall we? I've got some more things. Another thing in here,

153
00:12:37,400 --> 00:12:40,760
he says, when this whole thing happened when he was talking about it, oh, no,

154
00:12:42,120 --> 00:12:44,600
people don't like this code. But then he says, some people do this. And again,

155
00:12:44,600 --> 00:12:47,480
I've shown you, he's very good, he's very good at knowing memes. He's not an old man, he's an old

156
00:12:47,480 --> 00:12:51,720
man, but he's up to date with a lot of the stuff. And it sounds like silly, but it's not a book,

157
00:12:51,720 --> 00:12:55,800
or the concept, it's a Cartesian pandering immature behavior. The author batches everyone,

158
00:12:55,800 --> 00:12:58,520
and then he just shows this claim like, hey, I know how to play your joke.

159
00:12:59,240 --> 00:13:03,240
Like, and he does, he's not that bad. But then there's other things. So here's like,

160
00:13:03,240 --> 00:13:08,520
Casey Motori comes up with, I mean, he's talking about people criticising, and then he replies to

161
00:13:08,520 --> 00:13:12,760
this, this is where kind of the start of the conversation is happening. So Casey has says

162
00:13:12,760 --> 00:13:17,640
in this, even if true, to what extent would you tolerate the, yes, clean code is much slower,

163
00:13:17,640 --> 00:13:22,200
but it's about programmer productivity for other products. Would you want a car that went only

164
00:13:22,200 --> 00:13:26,680
five miles per hour, because the designers could do less work to make that car? Now,

165
00:13:27,400 --> 00:13:32,760
Mr. Martin replies to what the auto owners notice he does a pivot. This is a pivot. And also,

166
00:13:32,760 --> 00:13:38,120
it doesn't answer the question. He says, the automated mobile industry takes advantage of

167
00:13:38,120 --> 00:13:42,840
every productivity tool they can reduce their enormous manpower cost of designing and manufacturing

168
00:13:42,840 --> 00:13:47,160
cars. As a result, cars have gotten exponentially better over the decades, because the extra productivity

169
00:13:47,160 --> 00:13:54,440
translates to better designs. Yes. But do you think they for their programming, they're using

170
00:13:54,440 --> 00:14:00,920
clean code? Principles. In fact, we know they don't, especially after he's Mercer and stuff like that,

171
00:14:00,920 --> 00:14:04,520
but they have to adhere to certain other things. And like, they're probably not doing clean,

172
00:14:04,520 --> 00:14:08,840
clean code stuff. Now, I know the most things have started to relax, especially when it comes to,

173
00:14:08,840 --> 00:14:14,920
like, Android Auto and I'm like, Apple Car play and stuff like that, it's, they're stuff a buggy.

174
00:14:14,920 --> 00:14:18,200
But that's kind of like, Oh, it's your phone. That's a different thing. It's just we're interfacing

175
00:14:18,200 --> 00:14:22,520
with it and whatever. And it's interesting. He does this because he does it again, when someone

176
00:14:23,240 --> 00:14:28,200
replies to it and anything here. But he's kind of a, he knows what he's doing when he says these

177
00:14:28,200 --> 00:14:34,920
arguments. That's not answering the question. All I'm going to say is that just watch that. Okay.

178
00:14:34,920 --> 00:14:38,040
Another thing is this is when it starts, this was the beginning of his, I wash your thoughts and

179
00:14:38,040 --> 00:14:42,360
he says, Oh, I've commented on this before clean code is made for programmer performance,

180
00:14:42,360 --> 00:14:48,120
not algorithmic performance. If you need the latter, then write in C or assemble and live with

181
00:14:48,120 --> 00:14:54,360
the high cost of development. So few things there already, PI programmer performance and

182
00:14:54,360 --> 00:14:59,560
algorithmic performance. Okay, so program performance, it's the, in the contrast, how do you measure

183
00:14:59,560 --> 00:15:03,640
that thing? How would you know if that your approach is better than another approach? And if

184
00:15:03,640 --> 00:15:07,000
you need the latter, write in C and assemble, okay, it's assembly, I would call this, but yeah,

185
00:15:07,000 --> 00:15:10,360
and then high cost of, so he's already implying that writing in C

186
00:15:11,160 --> 00:15:14,680
is going to be a much higher cost of development than writing in another language.

187
00:15:14,680 --> 00:15:18,600
It might be, but you should only write it in because you need the performance. And it's like,

188
00:15:19,400 --> 00:15:25,720
okay, what? Look at the framing. He knows what he's doing. I'm not saying he's an idiot. He's

189
00:15:25,720 --> 00:15:29,960
very smart. Okay, I'm sorry. I'm picturing it. I can already see which side I'm in, but I'm just

190
00:15:29,960 --> 00:15:33,800
trying to explain the rhetoric tricks. So this is another thing is like the clean code to reply

191
00:15:33,800 --> 00:15:37,240
to later with the automatic ability. I've got these switching around. It doesn't matter. People

192
00:15:37,320 --> 00:15:42,600
says, how do you measure readability of the code by reading it? So obvious. But it's like,

193
00:15:42,600 --> 00:15:47,880
when people say measure, they usually mean a quantifiable thing rather than a qualifying thing.

194
00:15:47,880 --> 00:15:54,120
So this equality and a quantity are two distinct ontological categories, okay, or

195
00:15:54,120 --> 00:15:57,080
epistemological, the many different things, which is not going to philosophy too much, but

196
00:15:57,080 --> 00:16:02,040
you cannot quantify a quality and never qualify a quantity in a sense. They're different things

197
00:16:02,120 --> 00:16:10,920
like, Hey, I have a tape measure here. Yeah, I can say it's got the, I say it's quality of being good

198
00:16:10,920 --> 00:16:15,160
and round and green and stuff like that. And these aren't even very good qualities, to be

199
00:16:15,160 --> 00:16:21,400
honest with you, but it has quantities. I know it's mass just by dropping it. That's what you need to

200
00:16:21,400 --> 00:16:25,000
do. That's absolutely fine. And it masters. I'm just trying to explain the gravity thing. So

201
00:16:25,000 --> 00:16:28,280
clearly it's got mass and we can measure that relative to other things that weigh things. So

202
00:16:28,280 --> 00:16:34,520
we know how much this is weighs. This is probably weighs about, I don't know, eight ounces. So 225

203
00:16:34,520 --> 00:16:41,720
grams ish. That's quite heavy, actually, surprisingly, it's not even a good one. But there's kind of

204
00:16:41,720 --> 00:16:45,320
the thing. So you can actually think you can sort of say, Oh, how, how green is where we can measure

205
00:16:45,320 --> 00:16:48,760
the reflectings of it and then see how much it reflects back a certain light and some wavelengths

206
00:16:48,760 --> 00:16:52,760
and such like this. You can say all these quantities and you're, these are quantities,

207
00:16:52,760 --> 00:16:56,440
okay, but I want to go into too much clearly. I used to be a quantum metrologist. So I know

208
00:16:56,440 --> 00:17:00,920
a lot of you may excuse measurements and all this stuff. But this is a clever trick by reading it.

209
00:17:01,880 --> 00:17:06,040
That is not a quantity. And people are wanting to question how do you measure when we want an

210
00:17:06,040 --> 00:17:12,200
objective measurement? What do you mean is they want a quantity? But he goes out by doing this.

211
00:17:12,200 --> 00:17:16,280
So this was a big long twist post I've been here, where Lawrence Crow again,

212
00:17:17,080 --> 00:17:20,840
the community anyway says people on hand made hating on Casey's videos about performance,

213
00:17:20,840 --> 00:17:24,520
while their company is spending double digits of percentages of their revenue on

214
00:17:24,600 --> 00:17:28,600
Amazon web server bills to serve three forms and a database view. And it's like, okay,

215
00:17:28,600 --> 00:17:33,320
this is great nightlight discussion. Talking about this. And then Mr. Martin says here is his,

216
00:17:33,320 --> 00:17:37,400
his analysis was correct. His rhetoric is abyssin, disingenuous. And the overall point was

217
00:17:37,400 --> 00:17:41,320
extraordinary narrow. Clean code is about increasing programmer performance. He keeps

218
00:17:41,320 --> 00:17:46,520
it straight this not computer performance. What are some real life life non-trial view

219
00:17:46,520 --> 00:17:50,440
code bases support the hypothesis that strict clean code increases program performance

220
00:17:51,080 --> 00:17:51,960
replies with a mean.

221
00:17:55,560 --> 00:18:00,360
Again, he knows what he's doing. I'm not like, this is really cool. Like he knows what he's doing.

222
00:18:00,360 --> 00:18:03,560
But yeah, so you don't have any of his tools that some says it. So the Vittorio

223
00:18:03,560 --> 00:18:07,080
reminded me of a thing for the people I got into a discussion with him around about this time.

224
00:18:07,080 --> 00:18:12,520
And I kind of partially convinced him about like, well, you need you've not go evidence for why one's

225
00:18:12,520 --> 00:18:16,200
better than the other. Like show why how do you know one's better than the other? It's kind of

226
00:18:16,280 --> 00:18:20,120
that question. Like how do you know what measurements are using what quantifiable or even

227
00:18:20,120 --> 00:18:23,880
qualifiable things are you showing? Like, can you just show me the evidence? And then he goes,

228
00:18:23,880 --> 00:18:28,200
he knows this for a fact, he says, the problem with scientific data is it's controlled in

229
00:18:28,200 --> 00:18:31,640
controlled experiments and realistic software environments are economically feasible. You're

230
00:18:31,640 --> 00:18:36,440
asking for something you'll never get. And yet you still decide. So look around and that's just

231
00:18:36,440 --> 00:18:39,880
so it's especially your seniors. So first of all, it's just the first part of this thing here is

232
00:18:40,520 --> 00:18:46,120
we have no evidence for our claims. But it's okay, because your associate seniors may agree

233
00:18:46,120 --> 00:18:55,480
with me already. Nice little pairing here doesn't do the same thing. Okay. That's the first thing.

234
00:18:56,600 --> 00:19:00,600
But then someone said like they said they use over the 10 lines of code sometimes wrong seniors,

235
00:19:00,600 --> 00:19:04,600
I guess, and someone saying like, well, we've got my seniors don't agree with you. So sometimes,

236
00:19:04,600 --> 00:19:09,160
of course, your seniors were correct. I presume they also told you that or else be your smaller

237
00:19:09,160 --> 00:19:13,880
well named functions are better than really badly named functions is like, okay, notice the bad

238
00:19:13,880 --> 00:19:18,120
pairing there already. A well named function is better than a badly named function. Agreed.

239
00:19:18,760 --> 00:19:23,160
Smaller function may not be better than a long function. But notice is smaller well named

240
00:19:23,160 --> 00:19:26,840
functions are better than really badly named functions. Never talked about the length of it.

241
00:19:29,000 --> 00:19:33,640
I know it's like a minor word difference. But he knows what he's doing. And also he just changed

242
00:19:33,640 --> 00:19:37,480
the topic and it's a pivot. He's gone from being the scientific data to now to well, trust your

243
00:19:37,480 --> 00:19:43,000
the trust the authorities of your seniors or elders or whatever, like, that's going to authority

244
00:19:43,080 --> 00:19:48,760
rather than going to like empirical data. Nice little pivot. He knows exactly what he's doing.

245
00:19:49,960 --> 00:19:54,680
So another one here is always remember that computers operate on f in character one f in

246
00:19:54,680 --> 00:19:59,000
character to times he's trying not to swear here. No matter what lovely subroutines you might be

247
00:19:59,000 --> 00:20:03,160
using some replies, what about Sunday? Well, the context of the problem was JavaScript in a browser.

248
00:20:03,160 --> 00:20:09,000
I'm like, what context I even tried to search through the other tweets. There was no context.

249
00:20:09,720 --> 00:20:20,760
So, yeah. Okay, carry on. Another one. Someone has recently equated clean code

250
00:20:20,760 --> 00:20:26,840
over engineering. That is, of course, an oxymoron. An over engine code is by definition not clean

251
00:20:26,840 --> 00:20:30,120
and makes me wonder if those who complain so loudly have actually stood at the target of

252
00:20:30,120 --> 00:20:38,120
their complaints. It's like, see the see the problem. So if he's over engineered, it can't be

253
00:20:38,120 --> 00:20:42,600
clean code. Even though I've seen many clean code, which I've classes over and engineered. In fact,

254
00:20:42,600 --> 00:20:47,720
I think clean code by default is kind of open engineered like it doesn't it's assuming this

255
00:20:47,720 --> 00:20:53,160
could be open to change even though it's a close set of problems, which I'll get onto a bit later.

256
00:20:54,760 --> 00:20:58,200
So then talking about this for tour of Rome, a shot we had earlier, I was discussing with him

257
00:20:58,200 --> 00:21:02,440
previously. And he was kind of like, Oh, well, I can make it even faster. If you just change the

258
00:21:02,440 --> 00:21:06,280
entire style of it and just have a raise of separate types. And I was just like, you being honest,

259
00:21:06,280 --> 00:21:10,440
but this was the conversation I had even trying to confuse it like to not, he was kind of being

260
00:21:10,440 --> 00:21:13,080
a bit confused, but also trying to be like explaining. And we kind of got to a point where

261
00:21:13,080 --> 00:21:17,800
like, Oh, okay, like, first off, you've been a bit disingenuous here, man, with the argument,

262
00:21:17,800 --> 00:21:21,560
but fine. This is not Mr. Martin anymore. This is just me explaining like there are people who are

263
00:21:21,560 --> 00:21:25,960
trying not saying to defend him, but not understanding like Casey's point in this

264
00:21:25,960 --> 00:21:31,000
discussion. So again, before I'm going to read this article, I recommend reading this clean

265
00:21:31,000 --> 00:21:36,120
code, horror performance, YouTube video, again, links are in the description for all of these

266
00:21:36,120 --> 00:21:40,600
links. So don't worry, they'll be there. So now I've done the 20 minutes spiel at the beginning

267
00:21:40,600 --> 00:21:46,760
of this video. Let's get to the meat and potatoes of this entire thing, which is the written down

268
00:21:47,880 --> 00:21:55,400
talk. Now this is quite interesting. And this written down talk is effectively a written

269
00:21:55,400 --> 00:22:00,760
discussion between Casey Meritori and Mr. Martin. And they are both discussing with it,

270
00:22:00,760 --> 00:22:05,000
and it's been split into different things. And I'll explain some points as I come along.

271
00:22:05,000 --> 00:22:08,360
And so other little tricks. So first off, I'm just going to try and read it. I recommend

272
00:22:08,360 --> 00:22:12,440
reading this again, links in the description below for everything. So Casey starts off with

273
00:22:12,440 --> 00:22:17,000
thank you taking the time. And he's just kind of asking questions like so most explanations

274
00:22:17,000 --> 00:22:21,320
on clean code, I've seen that you include all things I mentioned in the video, like

275
00:22:21,320 --> 00:22:26,040
preferring inheritance hierarchies to ifstapes, which means like I remember if we look back

276
00:22:26,760 --> 00:22:31,240
to the the where was the guest I found completely lost it already now.

277
00:22:33,320 --> 00:22:38,440
It was here, right? Here it was here. Yeah, here's the design rules.

278
00:22:40,200 --> 00:22:44,440
Like that some some size, that's not Mr. Martin's himself. But yeah, but it sounds like

279
00:22:44,440 --> 00:22:47,640
you were surprised to hear me say that like all these different things he said is I look

280
00:22:48,600 --> 00:22:54,200
Martin's going to disconnect. I'm not sure there is one. And interesting, he just says there is no

281
00:22:54,200 --> 00:22:58,840
like disconnect. And Casey just asking questions about this. So Casey is asking a basic question

282
00:22:58,840 --> 00:23:02,440
here like look, we're both familiar with Visual Studio and Clang, and it would be a reason more

283
00:23:02,440 --> 00:23:06,920
that you're calling the back and uses it every day. I use these every day. I use LLVM and Visual

284
00:23:06,920 --> 00:23:10,600
Studio every day. Are you calling these a vast majority of software that require less than

285
00:23:10,600 --> 00:23:15,240
one things? And then he would go like, Oh, these are very specialized software, the only few in

286
00:23:15,240 --> 00:23:19,560
existence, and only a few that have actually become popular. And then talks about why this case

287
00:23:19,560 --> 00:23:23,720
and like actually talks about all these different things here, like, okay, speed is not necessarily

288
00:23:23,720 --> 00:23:28,440
an issue. But you can summarize, I'm trying to summarize it. But then the first trick he does,

289
00:23:29,480 --> 00:23:34,440
this is going to be consistent throughout here, is the nanoseconds, microseconds and milliseconds

290
00:23:34,440 --> 00:23:43,000
framing. I will tell you this. So what it will do here is making sure that passing code preserves

291
00:23:43,080 --> 00:23:49,400
nanoseconds can have a big effect. Or he says, I assiduously counted microseconds when it mattered.

292
00:23:49,400 --> 00:23:56,280
Nanoseconds were way beyond anything I could imagine. And so then Casey kind of questions,

293
00:23:56,280 --> 00:24:01,320
is a case of like, it sounds like most software that Casey actually uses and so with myself would

294
00:24:01,320 --> 00:24:05,640
when nanoseconds actually matter. In other words, Visual Studio, LLVM, GCC, Microsoft Word,

295
00:24:05,640 --> 00:24:10,120
PowerPoint, Excel, Firefox, Chrome, FFMPEG, there's a type of that, but TensorFlow, Linux,

296
00:24:10,200 --> 00:24:16,440
Windows, macOS, all of these. And Martin goes again, Mr. Martin goes like, oh, not exactly,

297
00:24:16,440 --> 00:24:20,600
rather my experience abroad, and does all the stuff. And then talks about this other applications

298
00:24:20,600 --> 00:24:23,800
we have modules in the millisecond range. And he says, sort of these time ranges.

299
00:24:24,760 --> 00:24:29,960
It's very like, he's trying to get the reader, because he knows people reading this, to think

300
00:24:29,960 --> 00:24:33,640
about it, well, most problems are in there at ranges of milliseconds. So we can worry about

301
00:24:33,640 --> 00:24:37,480
nanoseconds. Most people aren't have to worry about the automizer nanoseconds. But it's like,

302
00:24:38,120 --> 00:24:43,480
you know, death by 1000 cuts, and 1000 milliseconds is a microsecond, 1000 microseconds is a

303
00:24:43,480 --> 00:24:49,880
millisecond. So if you do things 1000 times badly, and you can, you've now gotten to the other

304
00:24:49,880 --> 00:24:57,240
domain into the other module, as he was calling this, the time module. Okay, fine by me, not

305
00:24:57,240 --> 00:25:02,360
necessarily criticizing that way of thinking, but it's a very weird framing, which,

306
00:25:02,920 --> 00:25:08,200
like, even if I read here, so for example, I'm currently working on an application in which

307
00:25:08,200 --> 00:25:12,680
the vast majority of modules work well at the millisecond level, but a require a 20 x per

308
00:25:12,680 --> 00:25:16,600
better performance. My strategy has been to write the millisecond modules in closure,

309
00:25:16,600 --> 00:25:20,440
because while slow, which is very convenient language, the microsecond modules I wrote in

310
00:25:20,440 --> 00:25:24,520
Java, which were much more faster, more convenient, far less convenient. So it's like, okay, so if

311
00:25:24,520 --> 00:25:29,240
I use them all like Java, it's easier, it's much less convenient, but I can write faster code,

312
00:25:29,800 --> 00:25:33,720
compared to closure, which is, I write code quicker, but it's not going to be as

313
00:25:33,720 --> 00:25:37,240
powerful as that. And those bits, these mergers again, because closure and Java both work on the

314
00:25:37,240 --> 00:25:43,240
JVM, so they can interact with each other pretty easily, ish. But he's just talking about the other

315
00:25:43,240 --> 00:25:50,600
things here. Now, one thing I found interesting is this slash here. You'll see in a minute,

316
00:25:51,560 --> 00:25:55,080
right, he only wrote a book, and he said, oh, I wrote a book on clean code, don't you know?

317
00:25:55,640 --> 00:25:59,960
I've only focused on the millisecond side of the problem, not the nanosecond. It's like,

318
00:25:59,960 --> 00:26:05,320
well, I'm not walking about the performance of the code anymore. But like Casey just goes

319
00:26:05,320 --> 00:26:09,560
town on the question. So Bob answers a very short question, milliseconds, of course.

320
00:26:11,480 --> 00:26:16,520
And then he answers again. Now, he might be asking, wait, why is he answered twice?

321
00:26:16,520 --> 00:26:21,960
Well, he went back in history and added some code text. He rewrote history. Yeah.

322
00:26:22,280 --> 00:26:28,440
I'll say no more. But yeah, he keeps going on about this, and it's very interesting. So now

323
00:26:28,440 --> 00:26:32,680
here's another problem he kind of talks about. And he talks about the actual he says he's now

324
00:26:32,680 --> 00:26:36,600
actually finished watching the video, because he didn't actually watch the video when he started

325
00:26:36,600 --> 00:26:40,200
discussing with the only watch the first bit of it until I've got enough of this. It's like,

326
00:26:40,200 --> 00:26:44,840
you're not going to have discussion with someone you've not even watched the entirety of but you

327
00:26:44,840 --> 00:26:49,480
think you're confident, you know, you can talk about it. I'm like, interesting. If you're that

328
00:26:49,480 --> 00:26:55,160
confident, it usually means you're not actually talking about the thing itself.

329
00:26:58,280 --> 00:27:03,400
Yeah. Yeah. But he says, you notice a nice little pattern. I love that basic form of

330
00:27:03,400 --> 00:27:07,240
the like some coefficient times the length times the width. And in those moments, I only think

331
00:27:07,240 --> 00:27:11,560
programs and mathematicians mathematicians can truly appreciate. It's like, oh, yeah, yeah,

332
00:27:11,560 --> 00:27:17,640
like that was fine. Isn't that lovely? And that's fine, whatever. But Casey comes up,

333
00:27:17,640 --> 00:27:20,760
okay, that sounds great. I think we've gotten to the same page because he was actually talking about

334
00:27:21,480 --> 00:27:26,600
this, not this. Because he says, I've just finished watching it. So I'm going to add this bit back

335
00:27:26,600 --> 00:27:33,640
in to make it split it up. Again, take it as you wish. What I'm trying to say is above paragraphs,

336
00:27:33,640 --> 00:27:37,320
above the box, and there's just like, look, Casey has read and looked a lot of it. Like,

337
00:27:37,320 --> 00:27:41,000
what you're talking about, he seems like these nanoseconds even matter, like everything seems

338
00:27:41,000 --> 00:27:45,960
to be nanoseconds modules, which he says, like, all this makes no sense. And then he again,

339
00:27:45,960 --> 00:27:49,560
he replies with, well, I'm one of the signatories of the agile manifesto who still believes to be

340
00:27:49,560 --> 00:27:57,880
a bit up front of architecture design. Okay, why bring that up? Sure, but fine. This is the

341
00:27:57,880 --> 00:28:01,480
bottom line, of course, is that single factor analysis is always suboptimal. There's no one

342
00:28:01,480 --> 00:28:04,920
true way point. I've always made several times in clean code. And it's like,

343
00:28:06,600 --> 00:28:10,280
but they may not be one true way, but you do kind of suggest there's a default you should go to.

344
00:28:10,360 --> 00:28:21,240
And there are arguments for that. Okay. Casey has a lot of questions to ask already,

345
00:28:21,240 --> 00:28:24,920
all of this. Again, I recommend watching this. Now, Casey says here is like, I watched a multi

346
00:28:24,920 --> 00:28:30,120
part series at six parts six, and it's like nine hours he watched, not once in that one second

347
00:28:30,120 --> 00:28:34,520
of it of that nine hours was in to go to get towards performance. And again, Mr. Martin says

348
00:28:34,520 --> 00:28:38,760
it's fair criticism, absolutely fine, no problems. But again, I'm just going to show you here,

349
00:28:38,760 --> 00:28:42,440
it's like, yeah, so thank you for the nudge kind of thing. Like, oh, next time I'll do,

350
00:28:42,440 --> 00:28:46,760
I'll put a nudge in towards performance. It's like, been doing this for decades.

351
00:28:49,800 --> 00:28:52,920
Hmm. Okay, so clearly you don't see, like, but like,

352
00:28:54,360 --> 00:28:57,240
he's kind of butchering up trying to be polite or like, as you would, like you're trying to be a

353
00:28:57,240 --> 00:29:00,520
conversation light always be polite someone as well and try and be nice and kind to a certain

354
00:29:00,520 --> 00:29:06,520
extent, maybe always nice, but kind at least kind. But yeah, it's always kind of those kind of things

355
00:29:06,520 --> 00:29:12,440
and after some reflection, blah, blah, blah. I'm just trying to go through over this again.

356
00:29:13,320 --> 00:29:16,120
This is like, it's fine, not just all the conversation again, it's a lovely conversation

357
00:29:16,120 --> 00:29:18,920
between two people trying to be just being honest between each other, not being horrible.

358
00:29:20,760 --> 00:29:24,840
Casey was also showing off this video, which if I believe it's correct, he was just kind of

359
00:29:24,840 --> 00:29:29,080
they were just joking about how slow is right GitHub, literally intent of just slowing down

360
00:29:29,080 --> 00:29:33,960
along with the paragraph God. And they actually found after a while, why this was the case.

361
00:29:34,840 --> 00:29:40,120
The thing they found out was that it was the code was looking back to the beginning of the

362
00:29:40,120 --> 00:29:43,720
paragraph, looking for a colon, if it found a colon, and it was near the beginning,

363
00:29:44,360 --> 00:29:51,240
it was going to then expand this to be a emoji. That was what the bug that think the slowness was.

364
00:29:51,240 --> 00:29:55,560
So if you just, as Bob made his joke, like, oh, if I just replace everything, the spaces with

365
00:29:55,560 --> 00:29:59,880
the colons is instant, there's no slowdown because it's found the colon, found it's not an emoji

366
00:29:59,880 --> 00:30:04,200
and doesn't do the search anymore. And that's how slow, like, even though they were talking

367
00:30:04,200 --> 00:30:07,960
about the complaining like slow codes, like, look how dumb this algorithm was in the web

368
00:30:07,960 --> 00:30:11,560
browser. And it's just trying to do this. Now, one little thing I found a bit weird,

369
00:30:11,560 --> 00:30:15,960
he says, I created this using going vi and I use this like replacement thing, because really,

370
00:30:15,960 --> 00:30:23,560
I'm an old C hacker at heart. I'm like, what? What does that even mean? This just seems like a,

371
00:30:23,560 --> 00:30:29,640
I'm an old C hacker at heart. I'm like, this has this is one, this is just, you're like vi or

372
00:30:29,720 --> 00:30:34,920
vim or whatever you want to stuff. And then you've just done a regex for text replacement. And

373
00:30:37,160 --> 00:30:41,160
this has nothing to do with C. I know what he's trying to say. Oh, it's just really low level

374
00:30:41,160 --> 00:30:46,840
I'm doing all this. I'm like, what? Sorry, we just need one of those things like the what?

375
00:30:47,800 --> 00:30:51,400
Right, kind of bit interesting here. So then there's the again, recommend if you want to

376
00:30:51,400 --> 00:30:53,800
read the links in the bar for all this. So you don't I'm not trying to read the

377
00:30:53,800 --> 00:30:58,600
descriptions here. I'm just trying to go over it. So now they figured out the things,

378
00:30:58,680 --> 00:31:02,200
the slowness of GitHub, they've gone gone back pivoting up back to this talking about the stuff

379
00:31:02,200 --> 00:31:08,120
about clean code again, capital C, capital trademarked, and explaining all that. And

380
00:31:09,000 --> 00:31:12,680
some of the weird things like for instance, the descriptive names things, like,

381
00:31:13,640 --> 00:31:17,960
I think everybody agrees with the descriptive names. This is not clean code exclusive to clean

382
00:31:17,960 --> 00:31:26,040
code tests. This is one where he's more of a test driven development, while cases more of a,

383
00:31:26,040 --> 00:31:30,600
it's more of a how they do frame it later on. In fact, I think Mr. Martin rephrases this quite

384
00:31:30,600 --> 00:31:36,360
well, that he prefers like why you should write a test if you don't see a reason not to. And cases

385
00:31:36,360 --> 00:31:40,280
more in the camp, I write a test when I need a reason to kind of thing. And they're just

386
00:31:40,280 --> 00:31:44,200
they're not bad. One's more test driven. One's more of a, like a more of a base of regression

387
00:31:44,200 --> 00:31:48,440
kind of thing or like other testing is more of a, I'll write tests when I need to because

388
00:31:48,440 --> 00:31:53,800
I do have tests in general, it's just not a like unit tests or general tests of everything

389
00:31:53,800 --> 00:31:58,840
code coverage and all that lot. It's a different thing. I'm not going to criticize test driven

390
00:31:58,840 --> 00:32:02,200
development because it's not necessarily bad in certain domains, but in certain other domains,

391
00:32:02,200 --> 00:32:08,200
it's kind of like not it seems like you're writing more tests than the actual code,

392
00:32:08,200 --> 00:32:13,960
which is not necessarily productive. But whatever, or useful and as many things in here,

393
00:32:15,000 --> 00:32:18,600
yes, it says like, look, cases, I do test as well. But then again, here's the difference he

394
00:32:18,600 --> 00:32:21,800
writes. So Mr. Martin says, I appreciate tests, unless there's a good reason to this and Mr.

395
00:32:21,800 --> 00:32:26,120
Martin and Casey write tests when there is no good reason to when there's a good reason to.

396
00:32:26,120 --> 00:32:31,160
So it's kind of a different distinction here. Now he actually starts quoting again from his

397
00:32:31,160 --> 00:32:36,840
book talking about this and he and he kind of distinguishes between the operand primal and

398
00:32:38,360 --> 00:32:42,920
operation primal he's calling here. So it's kind of the difference between I'm going to call operands

399
00:32:44,040 --> 00:32:48,920
operands variance in this case, because it's a variance and operation. So they're not using

400
00:32:48,920 --> 00:32:52,520
the same hoe gets a little confusing for me. So now they're kind of talking about the different

401
00:32:52,520 --> 00:32:57,640
benefits of using one of these two things. And great stuff here. But then there's one other

402
00:32:57,640 --> 00:33:02,920
term that he brings up in here, which is dependencies. And he's using this in a very,

403
00:33:04,600 --> 00:33:10,760
not the way that most people would use the term dependencies. So a good example of this would

404
00:33:10,760 --> 00:33:15,800
be is calling dependency inversion. So I'm just going to read right, I'm going to say what he's

405
00:33:15,800 --> 00:33:21,720
written because it's, I'm not going to paraphrase it very well if I don't, it says here, that would

406
00:33:21,720 --> 00:33:27,400
be the bottom line if there was one other thing, okay, about dependencies, the cases of switch

407
00:33:27,400 --> 00:33:33,080
statements create an outbound network of dependencies towards lower level modules and

408
00:33:33,080 --> 00:33:37,160
modules in this case, he's talking about like timing and such like that, that kind of module

409
00:33:37,160 --> 00:33:42,760
in this context. Yeah, each case may call to out to these other modules making the fan out of the

410
00:33:42,840 --> 00:33:47,480
switch statement very high. So he's trying to argue against switch statements and trying to say, look,

411
00:33:48,120 --> 00:33:51,800
if you go for the more polymorphic approach, like the inheritance base approach, we have like a v

412
00:33:51,800 --> 00:33:56,360
table with sub typing, which is what I would class is inheritance to begin with any of the emergent

413
00:33:56,360 --> 00:34:01,400
concept of those two things joined together. And he's saying this is going to be making it the fan

414
00:34:01,400 --> 00:34:07,880
out of the switch and very high that this is going to be much bigger. Because it was caramel says

415
00:34:07,880 --> 00:34:12,360
any change to one of these lower level modules can force the switch statement cases, which

416
00:34:12,360 --> 00:34:18,280
statement the video, he's usually prefers the inheritance style not always, you'll get into

417
00:34:18,280 --> 00:34:23,320
that can force switch statement and all higher level modules to depend on on that switch statement

418
00:34:23,320 --> 00:34:29,000
to recompile and deploy it. That can be a very large cost. On the other hand, if one uses dynamic

419
00:34:29,000 --> 00:34:33,480
polymorphism, object oriented, instead of a switch statement, then those compile time

420
00:34:33,480 --> 00:34:38,520
dependencies are inverted. The lower level modules become sub types that depends on the

421
00:34:38,520 --> 00:34:42,920
high level base type. And the source code depends is then point in the opposite direction of the

422
00:34:42,920 --> 00:34:49,320
control flow. This is dependency inversion. It prevents changes at the low level modules from

423
00:34:49,320 --> 00:34:54,040
forcing a wave of recompilation redeployment from sweeping through the system towards high level

424
00:34:54,040 --> 00:35:00,600
modules. So this is just a really weird confusing terminology is just made up in a weird way. I'm

425
00:35:00,600 --> 00:35:05,560
saying who has made it like no, he kind of actually has. I tried searching for this and it's like,

426
00:35:05,640 --> 00:35:09,720
it's not consistent what people mean by that term. And also, when people talk about dependencies,

427
00:35:09,720 --> 00:35:14,520
they usually mean like third party code, usually, or sometimes they talk about dependencies like,

428
00:35:14,520 --> 00:35:17,640
Hey, what does it very dependent on the things like all the bits in the thing like he's talking

429
00:35:17,640 --> 00:35:25,080
about modules, but that these concept of a module is much more like a class than a library. So it's

430
00:35:25,080 --> 00:35:31,400
kind of a very more old fashioned approach before like libraries and packages and modules were more

431
00:35:31,400 --> 00:35:37,240
like standardized in other languages, obviously, but whatever. This is why I'm going to confuse

432
00:35:37,240 --> 00:35:41,880
because the argument he's trying to make. And this is the thing I would personally try to understand

433
00:35:41,880 --> 00:35:49,400
as well is that between the the variance and the operations, the switch statement is closed to the

434
00:35:49,400 --> 00:35:54,040
number of variants. But it's open to the number of operations. Like for instance, you can always

435
00:35:54,040 --> 00:35:59,000
add more operations really easily. You just add a new function with another switch statement inside

436
00:35:59,000 --> 00:36:03,400
of it. And you've now added a new operation to all of these different variants. Yeah.

437
00:36:04,840 --> 00:36:13,480
Whilst the inheritance style is much more open to is more open to various operations this time. So

438
00:36:13,480 --> 00:36:17,000
it's a closed set of operations, but open to numerous amount of different variants. This is

439
00:36:17,000 --> 00:36:21,000
the whole point you have a base class and variants like subtyping from it, the whole point you have

440
00:36:21,000 --> 00:36:26,040
subtypes or whatever, and it's more open that way. So it's a lot more useful to be doing.

441
00:36:26,840 --> 00:36:36,280
If that makes any sense. Yeah, hopefully that's clear. So that's kind of the argument. Now my

442
00:36:36,280 --> 00:36:42,360
point personal view is that which is getting talking in the thing here with the commentary

443
00:36:42,360 --> 00:36:45,560
search is that the most the time you actually have a close set of variants, and usually you

444
00:36:45,560 --> 00:36:49,640
want to add more operations in practice. So because if you've got a close set of variants,

445
00:36:50,440 --> 00:36:55,720
why pretending as if it's completely open, which is what inheritance is for, it allows

446
00:36:56,360 --> 00:37:00,920
everybody to add more variants, even if you don't have control of that capability, you just

447
00:37:00,920 --> 00:37:05,560
extend to it and it's abstracted away. But most people within their own code base, like it's not

448
00:37:05,560 --> 00:37:11,480
going to be used by third party people ever, usually, pretty much isn't. So you in that case,

449
00:37:11,480 --> 00:37:15,560
it's very close set of opera, it's close at variance you have. And usually when you're

450
00:37:15,560 --> 00:37:17,960
modifying code, you actually want to add more operations. It's kind of like a

451
00:37:18,760 --> 00:37:21,320
different thing. And they're solving different problems. You have to understand this. It's just

452
00:37:21,320 --> 00:37:28,680
that the weird oddity here is their argument is actually, you know, the, the, the inherent style

453
00:37:28,680 --> 00:37:32,920
approach, which has all of the operations for each variant bundled with that variant,

454
00:37:33,960 --> 00:37:37,800
it's easier to manage. And the going on about like managing all these different

455
00:37:37,800 --> 00:37:40,600
dependencies and talking about how many different places you have to deal with.

456
00:37:40,600 --> 00:37:44,040
In case you just correctly point out like, Hey, it's just a different win in different ways,

457
00:37:44,120 --> 00:37:49,320
like this independence in version thing, is you're just trying to get complexity. And again,

458
00:37:49,320 --> 00:37:54,120
Mr. Martin says, yeah, like for every program composed of O operations and T types has complexity

459
00:37:54,120 --> 00:37:59,960
of O times T. If we use O, we can cruise T with minimal disruption to increasing O and vice versa.

460
00:37:59,960 --> 00:38:03,080
Well, it's like the switch same as you have increased operations within disruption, but

461
00:38:04,040 --> 00:38:08,200
disrupts source code. Now, I don't think this is true. I don't think the disruption is actually

462
00:38:08,200 --> 00:38:17,000
even equivalent because it's weird. I know we shouldn't be talking about much about this is

463
00:38:17,000 --> 00:38:24,280
not really clean code anymore, but it kind of is related to it. It's just the, but practically,

464
00:38:24,280 --> 00:38:27,560
how would you know which one is more true the case? In my opinion, personal experience, we've

465
00:38:27,560 --> 00:38:31,480
always had a close set of variants. Like if you want to have a new one, fine. But that variant

466
00:38:31,480 --> 00:38:35,960
doesn't really like, okay, we got updated every single place. Now I use Odin. So my switch statements

467
00:38:35,960 --> 00:38:41,080
will yell at me if I'm missing a case by default. It says, Oh, you've not handled this particular

468
00:38:41,080 --> 00:38:45,640
operation for this particular variant, like in this particular case. And I just need to handle it.

469
00:38:45,640 --> 00:38:49,640
Okay, great. That's just better. I know C and C++ and summer languages don't do this by default,

470
00:38:49,640 --> 00:38:53,640
but Odin does. So clearly, that's just a better language can solve those problems. It's not really

471
00:38:53,640 --> 00:38:59,880
a or better tooling in general. It's not really a inherent thing. It's just a tooling problem then.

472
00:39:00,600 --> 00:39:05,880
But then this is where it gets a bit weird. He starts breaking things down to source code

473
00:39:05,880 --> 00:39:11,320
management about runtime source code dependency inversion, and just make some terms up which

474
00:39:11,320 --> 00:39:16,360
are not colloquially understood to be meant in that context. But again, it's the right a lot of text.

475
00:39:18,520 --> 00:39:22,120
Try and make people understand how he thinks. And then Casey just write small amounts.

476
00:39:23,000 --> 00:39:26,680
It's the it is a very big politician thing pad it out. Very good rhetoric. I mean,

477
00:39:26,680 --> 00:39:31,560
he's great at this. This is where I'm praising him, by the way. So again, read it for yourself,

478
00:39:31,560 --> 00:39:35,000
make your own opinion. If you disagree with me tip can tell me in the comments below.

479
00:39:35,000 --> 00:39:38,600
Tell me where I'm wrong. Please tell me where I'm mischaracterizing me. If I'm being too harsh,

480
00:39:38,600 --> 00:39:44,600
if I'm not being harsh enough, if I might work, look, I'm not even it's fine. But he then it is fine,

481
00:39:44,600 --> 00:39:47,320
like just just read it. He's talking about these different things here, like he's

482
00:39:47,320 --> 00:39:51,240
procedural, so it's itself statements, which statements, whatever. And he's calling this a

483
00:39:51,240 --> 00:39:54,680
run time to high run time dependency, when actually, no, we're gonna make this compile time

484
00:39:54,680 --> 00:39:59,400
dispensary when it's on the type site. No, you just switched them around. They're both the same.

485
00:40:00,120 --> 00:40:01,000
So yeah.

486
00:40:07,320 --> 00:40:13,160
So one thing he brings up here, which I thought was interesting. And it through this bit, as well

487
00:40:13,160 --> 00:40:17,480
as the second part, these starts up, I'll explain why he does that in a minute. He brings up, I

488
00:40:17,480 --> 00:40:24,280
would call the canonical case for inheritance. So the canonical case of inheritance is the

489
00:40:24,280 --> 00:40:29,880
data stream. So sorry, if I've been a bit rambling all day, I'm just trying to understand it because

490
00:40:29,880 --> 00:40:35,400
it is weirdly flowing as well. Like the actual thing isn't like, it's a weird discussion. But so

491
00:40:35,400 --> 00:40:39,080
I apologize for that and also apologize for my rambling as well. So hopefully that's okay. But

492
00:40:39,080 --> 00:40:44,760
again, should be all clarified here. Here he does the canonical case for inheritance, which is

493
00:40:44,760 --> 00:40:49,960
literally a stream, a data stream, a file or something like that, and explains that Oh, these

494
00:40:50,040 --> 00:40:54,840
have standard operations, a close set of operations like open, close, read, write, and seek. Again,

495
00:40:54,840 --> 00:40:58,200
these are the five standard functions of the Unix IO driver. And again, these are very

496
00:40:58,200 --> 00:41:03,720
standard functions on all operating systems. So they actually map really well to the

497
00:41:03,720 --> 00:41:07,880
inheritance style of doing things, the very dynamic polymorphism is he's referring it to here,

498
00:41:07,880 --> 00:41:15,640
which is, yeah, it's dynamic dispatch. Subtype polymorphism with v tables. Yeah,

499
00:41:15,640 --> 00:41:19,320
that's what it is. But he's calling it dynamic polymorphism, which is not common term, but he's

500
00:41:19,320 --> 00:41:24,600
whatever is using his own terminology as he needs. But it's saying like, okay, we've got a

501
00:41:24,600 --> 00:41:27,640
closed set of operations, but we have so many different things like files could be anything,

502
00:41:27,640 --> 00:41:31,560
they could be a file, it could be a directory, they could be a piece of hardware on your device,

503
00:41:31,560 --> 00:41:35,720
they could be just a general socket, there could be anything. It's like, it's open to be whatever

504
00:41:35,720 --> 00:41:42,760
it could be. This is literally the canonical case. Why is the canonical case? Because operating

505
00:41:42,760 --> 00:41:48,440
systems make these files an object. They are an object. That's what they have. Like they're an

506
00:41:48,440 --> 00:41:53,640
abstracted away opaque thing with a open like close interface as to what they are.

507
00:41:55,720 --> 00:42:01,000
So he's trying to argue like this is what you meant to do. Now, there's a lovely lovely thing

508
00:42:01,000 --> 00:42:04,280
here is saying like, well, this clearly has to be a thing. And that's why he's trying to get down

509
00:42:04,280 --> 00:42:08,760
this route. He's trying to take the canonical case to show to Casey that hey, you need inheritance

510
00:42:08,760 --> 00:42:13,240
sometimes. And this is the great way. He's completely forgot the conversation is talking

511
00:42:13,240 --> 00:42:18,840
about clean code, which will bite him in the book later to use an American phrase later.

512
00:42:21,240 --> 00:42:26,600
But then there's one this weird thing he does here, where all of a sudden he talks about this

513
00:42:26,600 --> 00:42:34,120
hypothetical compiler, which would be able to you could write in the in the oopy stage,

514
00:42:34,120 --> 00:42:40,280
like an inheritance style, and then completely the compiler would magically make this be a

515
00:42:40,280 --> 00:42:43,400
switch statement if necessary, which is kind of interesting because it's like,

516
00:42:45,000 --> 00:42:48,120
what what benefits would you get from that? Because it seems to be now a textual benefit.

517
00:42:48,120 --> 00:42:51,080
It's like, you're talking about, oh, it's all clumped together. A new variant or you know,

518
00:42:51,080 --> 00:42:56,360
like, but you've some weird things. He just says it's just a really weird hypothetical

519
00:42:56,360 --> 00:43:00,920
scenario just kind of goes into. And they go on for this for a little while. And Casey's like,

520
00:43:00,920 --> 00:43:03,640
I don't understand what you're talking about. Like this doesn't make no difference,

521
00:43:04,600 --> 00:43:10,280
even with this hypothetical case. So Casey goes on a bit more further here, just mentoring

522
00:43:10,280 --> 00:43:14,760
different things. And talk, I try to get what the benefit of dependency inversion is anyway,

523
00:43:14,760 --> 00:43:19,880
and to begin with. And the go on about this, like, look, you've got a clothes interface with opaque

524
00:43:19,880 --> 00:43:24,600
stuff, and different ways of dealing with it. And then we talk about this payroll thing that

525
00:43:24,600 --> 00:43:27,880
they do all these different things. I recommend reading it. But it is going to be this.

526
00:43:29,880 --> 00:43:33,560
Like this is an oopy thing, obviously, you've just defined it to be because it is is defined

527
00:43:33,640 --> 00:43:41,240
to be oopy, sorry. Yeah, okay. Yeah, yeah, yeah, yeah. But again, Casey also kind of says it

528
00:43:41,240 --> 00:43:45,080
could just be sound line functions. There's no reason, whatever, whatever, that's not a problem.

529
00:43:45,080 --> 00:43:48,520
Where am I looking for now? I'm sorry, I'm just trying to skip through this because it just goes

530
00:43:48,520 --> 00:43:56,280
on for quite a while. Okay, so Casey says that hypothetically, you could just not do this and

531
00:43:56,280 --> 00:44:00,840
have it just a union. Because in the example that Casey does when he does the union, the shapes

532
00:44:00,840 --> 00:44:06,600
example in the video is, is this actually a union? It's what I would call a fat struct union or an

533
00:44:06,600 --> 00:44:09,880
open open union where it has a variant and then just open fields. So it's kind of like a table

534
00:44:09,880 --> 00:44:17,240
like thing, a fat struct is a term that's Ryan Flurry kind of popularized. And it's kind of

535
00:44:17,240 --> 00:44:21,720
just like, here's a table of data, all the fields available. But hey, how you can just switch on

536
00:44:21,720 --> 00:44:25,160
it like all this and just do whatever you need to do and just access the data when necessary.

537
00:44:25,160 --> 00:44:29,000
In case you're saying, look, hypothetically, you could do this, you could just have a file type

538
00:44:29,000 --> 00:44:33,400
with all the data that responds to this in this union and deal with it. Because in practice,

539
00:44:33,400 --> 00:44:37,720
there's actually only a certain set of files you could have, you could even have the general case

540
00:44:37,720 --> 00:44:42,120
where it's, it, it will be like a V table. Sometimes it won't use a V tail, but you can always

541
00:44:42,120 --> 00:44:47,080
optimize off that. And there's many different things he's discussing here and such. And he's

542
00:44:47,080 --> 00:44:51,720
talking about the union case. Now, Martin, Mr. Martin goes here and says, look, it seems like

543
00:44:51,720 --> 00:44:56,520
come on, come on, wild up at the agreement on just about everything other than per individual

544
00:44:56,600 --> 00:45:01,480
preference. And it's like, no, he's trying to say, look, but we don't disagree. It's like,

545
00:45:01,480 --> 00:45:05,480
actually, why are you having this conversation? If you don't disagree, you clearly do actually.

546
00:45:05,480 --> 00:45:10,600
And you'll show this later on in part two of this written document. And he says,

547
00:45:10,600 --> 00:45:13,320
thank you for the union collaboration. Now I understand what you're talking about unions,

548
00:45:13,320 --> 00:45:18,280
which is like, okay. And he says, I'll quibble you a bit on the difference between operand

549
00:45:18,280 --> 00:45:21,960
and operation, but I don't think the quibble is particularly important. In the end, it's just

550
00:45:21,960 --> 00:45:26,680
all functions regardless of how you spell it. As for human issue, performance is a human issue.

551
00:45:26,680 --> 00:45:30,760
The computer doesn't know how fast or slow an algorithm runs, but I think that that horse is

552
00:45:30,760 --> 00:45:37,400
dead now. And it's like, no, it isn't. This is kind of the point. And he goes back to his

553
00:45:37,400 --> 00:45:42,600
microseconds, different module things again. And then he then goes, look, we put a break in here

554
00:45:42,600 --> 00:45:47,640
to write extra bit more to go rewrite history and says, look, I'm going to continue us now in the

555
00:45:47,640 --> 00:45:55,320
second document, which is the number two. Because he's trying to like make break here,

556
00:45:55,320 --> 00:45:59,240
and then reframe the entire question in the second document, it's a pivot and a reframe

557
00:45:59,240 --> 00:46:03,960
at the same time, clever rhetoric trick. If you want to do that in an argument, you do that all

558
00:46:03,960 --> 00:46:06,920
the time, you reframe the question. So it's now they're not even talking about the original thing

559
00:46:06,920 --> 00:46:11,400
again. And he's tried to do this. So that's what he's done here. Right. So right at the beginning.

560
00:46:13,000 --> 00:46:16,520
And then Casey's reframed it and put it put it into the beginning. So he's first. So Casey

561
00:46:16,520 --> 00:46:24,920
knew what he was doing. So just don't let's not do that, shall we? Yeah. So Casey wasn't stupid.

562
00:46:26,920 --> 00:46:30,440
He's talking about all this goes back to the payroll example with all this kind of thing.

563
00:46:31,080 --> 00:46:36,680
And Casey's trying to say is like, look, this is not an open problem. You haven't got an open set

564
00:46:36,680 --> 00:46:44,840
of variants. It seems like it's an extremely well defined problem. So why does this need to be like

565
00:46:44,920 --> 00:46:51,880
operand, operand, primal design was in like variant open, rather than variant closed. And then

566
00:46:51,880 --> 00:46:56,440
operation open. So this seems to be both closed. Like it's very weird. Like what, what are you

567
00:46:56,440 --> 00:46:59,880
trying to have in like save developer cycles with like, where's this kind of thing coming from?

568
00:47:02,040 --> 00:47:08,760
And then this has been moved to because he reframed it. It's fine. No problems. He's talking

569
00:47:08,760 --> 00:47:13,960
about the programmer cycles thing. This is the thing he gave this random file he added in here,

570
00:47:14,600 --> 00:47:18,280
which is the, oh, great. Let's do a code golf example, shall we?

571
00:47:25,000 --> 00:47:27,880
Cute surprise. It's like the point is the program cycles, waste management,

572
00:47:27,880 --> 00:47:30,760
programming cycles, it's like, yeah, you just gave me a code golf example.

573
00:47:31,560 --> 00:47:35,720
The worst case of readability possible, like, but it's a code golf. That's the whole point.

574
00:47:35,720 --> 00:47:38,920
People write those things to be compact and human. Like that's what you're trying to say.

575
00:47:38,920 --> 00:47:42,040
Like we're trying to make it easier on like, can you prove my belief not mathematically,

576
00:47:42,040 --> 00:47:46,200
just as I'm sure that you cannot mathematically prove that your favorite style saves more or

577
00:47:46,200 --> 00:47:50,840
less programmer cycles than mine. It's like, so he's already admitting that actually you

578
00:47:50,840 --> 00:47:55,560
can't prove my style is worse than yours style. And it's like, because programmer cycles, like

579
00:47:55,560 --> 00:48:00,760
this is a qualitative thing. He knows he can't measure it. She's actually, I don't think that's

580
00:48:00,760 --> 00:48:03,720
true to be honest with you. It's just that no one's really bothered to do the science because

581
00:48:04,600 --> 00:48:09,560
programming isn't really young discipline or 70 years at best really as a discipline. So it has

582
00:48:09,560 --> 00:48:13,800
no evolutionary like pressure on there yet to say which which things are good or bad. So people

583
00:48:13,800 --> 00:48:18,680
just say random things. So it is literally just like, great, there's not really much science in

584
00:48:18,680 --> 00:48:23,080
computer science. Rather, again, I'm glad the rest of the world calls it informatics for a reason.

585
00:48:23,640 --> 00:48:26,840
I don't know why we don't we call it computer science, even though it's not an empirical

586
00:48:26,840 --> 00:48:31,320
science and it's close to mathematics, but even then it's not really in practice is close to

587
00:48:31,320 --> 00:48:37,560
engineering. It's just confusing term. Okay, confusing term. The dynamic was a dynamic

588
00:48:37,560 --> 00:48:41,480
building and other type of just from typos, whatever I make more than this might be in day

589
00:48:41,480 --> 00:48:47,160
to day life. And he's talking about this. So it says, do we agree so far about this? And it's like

590
00:48:52,040 --> 00:48:55,240
cases kind of like, well, we don't just worry about certain things in the general like in

591
00:48:55,240 --> 00:48:58,920
the specific, I'm still asking the same question about this data stream thing you're talking about.

592
00:48:59,800 --> 00:49:06,520
Then Mr. Martin brings up again, the like, hey, here's something like the read write thing for a

593
00:49:06,520 --> 00:49:13,000
C. These helper functions don't you know to do all the stuff? It's like, but if you had to do it in

594
00:49:13,000 --> 00:49:17,320
your case, we'd have to do a switch statement like this wouldn't we don't you know? Oh, it's like,

595
00:49:18,120 --> 00:49:21,960
look at all the different variations you could hypothetically do this just ugly. Don't you know

596
00:49:21,960 --> 00:49:27,320
it's ugly? By the way, if you this is, this is gonna tangent anyway, I've been writing the

597
00:49:27,320 --> 00:49:31,800
Odin core library and you actually have to do this anyway. Like if you actually have to do like

598
00:49:31,800 --> 00:49:36,680
you do the read at the OS read functions, because the console on Windows at least does not act

599
00:49:36,680 --> 00:49:42,600
like a normal file. In fact, the console on Windows is a UTF 16 document. So that means you have to

600
00:49:42,600 --> 00:49:48,920
write UTF 16 files. If you actually write a UTFT thing to it, you then you have to do a conversion

601
00:49:48,920 --> 00:49:52,120
to do it onto those. It's actually like already or you have to do this edge case. And not just that

602
00:49:52,120 --> 00:49:59,080
the console has other things in it, which are not handled the same as an old file again. So it's a

603
00:49:59,080 --> 00:50:06,520
very kind of have to do this. This is how real world code is not even purely like, oh, the operating

604
00:50:06,520 --> 00:50:10,680
system has dealt this properly. It's like, no, I still have to check if it's a console specifically

605
00:50:10,680 --> 00:50:17,800
and then deal with it. So it's like, I know like, this is not working. Like, yeah, it actually looks

606
00:50:17,800 --> 00:50:24,360
closer to this in real life, even with the, the abstraction on top of what a file is, but I digress.

607
00:50:24,680 --> 00:50:32,600
Yeah. But yeah, it's just interesting. And then again, many different breaks can different edits

608
00:50:32,600 --> 00:50:36,520
here different sections is breaking it up. The VTab we use by Unix, again, most operating systems

609
00:50:36,520 --> 00:50:41,480
do this as well. Things change around significantly. The idos can be loaded at any time, the iodevice,

610
00:50:41,480 --> 00:50:46,200
yeah, that's true. That's took in this details we're talking about. He's talking about code reuse,

611
00:50:46,200 --> 00:50:50,040
great example says the cases. I apologize for trying to be very specific, but I really want to be

612
00:50:50,040 --> 00:50:54,120
actually get to the exact proposal. And it wasn't clear from what could you actually tell me what

613
00:50:54,120 --> 00:50:57,880
the OS interface looks like and how it's implemented. You said, I guess that depends on a lot on

614
00:50:57,880 --> 00:51:02,360
the language and the application. But my understanding is that we're talking about the OS side. So, and

615
00:51:02,360 --> 00:51:08,120
again, it's the, how does the OS implement this, like the, the stream, the file, compared to how

616
00:51:08,120 --> 00:51:12,600
we're doing it in a language is very different. And not just that, again, I thought we were talking

617
00:51:12,600 --> 00:51:19,800
about clean code. But why has it gone down this digression? Just you wait. Let's go get that. Don't

618
00:51:19,800 --> 00:51:25,640
worry. Okay, we're talking about get all crap. Okay, because it just changed. That's, I can probably

619
00:51:25,640 --> 00:51:30,120
guess which day this was written on as well. Like you're saying it seems like it looks like this

620
00:51:30,120 --> 00:51:35,400
somewhere. Is it actually a base class? Is it whatever? Now, Mr. Martin says, okay, here's kind

621
00:51:35,400 --> 00:51:39,960
of the general interface that he's writing C++. Again, he's not answering the question he's asked.

622
00:51:39,960 --> 00:51:49,560
He's done another thing. Whatever, kind of missed the point again. And then he's saying, look,

623
00:51:49,640 --> 00:51:53,640
look, if we look at the, he's trying to say this is less like the code is easy to manage whatever.

624
00:51:53,640 --> 00:51:57,960
Like, yeah, but you've just chosen the canonical example. And he says, look, if I do the dynamic

625
00:51:57,960 --> 00:52:03,320
polymorphism case, so inheritance, I create, I create this file of three files and have to leave

626
00:52:03,320 --> 00:52:07,240
them with a switch case. I've now all of this and look at all these different things I have to define.

627
00:52:07,240 --> 00:52:13,000
I'm like, and cases, well, hold on, since I'm the switch proponent, at least I get to write it,

628
00:52:13,000 --> 00:52:17,640
please. Look again, look what he's just done. He says, well, I've just shown you how to do it.

629
00:52:17,640 --> 00:52:21,320
And look, it's just more complicated. I've had to write files. Oh, no, I'm like cases like,

630
00:52:22,760 --> 00:52:30,440
hold on, hold on. Yeah, and it's kind of doing like this. So it goes on and on,

631
00:52:30,440 --> 00:52:33,640
we just discuss things, but it's like cases like I want to know what the operating system again.

632
00:52:36,040 --> 00:52:39,800
And it's different. Okay. And then cases like we're not even talking about machine cycles again,

633
00:52:39,800 --> 00:52:43,720
I'm just focusing on the program cycles again, what like he's doing again. So I'm like paraphrasing

634
00:52:43,720 --> 00:52:49,720
this poorly ish, but it's kind of just like, I'm trying to show the techniques that he's doing here

635
00:52:49,720 --> 00:52:55,480
that he knows he's doing it. He isn't an idiot. I'm trying to be very careful like this. Mr.

636
00:52:55,480 --> 00:52:59,400
Martin knows exactly what he's doing. Like he's now just made another document on here,

637
00:52:59,400 --> 00:53:04,120
which only he talks about. And it's just he's trying to suggest like, oh, this is the clean code

638
00:53:04,120 --> 00:53:09,320
stuff. And then he's saying this is what clean code is. And I've just got the summation seems

639
00:53:09,400 --> 00:53:14,200
to correlate with what I most people think it is. Because I miss people people keep this understanding

640
00:53:14,200 --> 00:53:19,720
me kind of view. And it's like, wait a minute. So choose carefully names, not unique. Keep function

641
00:53:19,720 --> 00:53:26,040
small. Why keep classes small. Why manage your dependencies, vague as anything. Literally,

642
00:53:26,040 --> 00:53:32,920
be careful with side effects. Okay. Yeah, express yourself in code where possible. How else you

643
00:53:32,920 --> 00:53:37,560
meant to express yourself in code away? It's your programming. Use polymorphers when the type

644
00:53:37,560 --> 00:53:41,800
changes fast in the operations. This is new stuff he's added now. You switched when operating

645
00:53:41,800 --> 00:53:50,920
change fast in the types. Why? Why? And at what cost? And what Harvard evidence have you got?

646
00:53:50,920 --> 00:53:57,720
This is better. And like, you compare it to this and like, you sure? Okay, when possible,

647
00:53:57,720 --> 00:54:04,840
create designs where things that can change fast that change fast are types. Why keep asking this

648
00:54:04,840 --> 00:54:10,200
question? Here's in his even in his summarizations of here, he's actually saying, we'll prefer

649
00:54:10,200 --> 00:54:15,480
polymorphism. So now he's in like, well, I don't see how you got to that conclusion where like,

650
00:54:15,480 --> 00:54:19,640
I'm against switch tamers or something. I'll clear and prefer like default before like all this

651
00:54:19,640 --> 00:54:26,120
and like, you're literally saying it in here in this summarized document. If I'm misinterpreting

652
00:54:26,120 --> 00:54:32,200
it, please tell me again, in the comments or something. I'm just really confused. Like, what?

653
00:54:32,760 --> 00:54:39,560
Right. So Casey comes back again, and he's talking about the internals of this. It's like, okay,

654
00:54:39,560 --> 00:54:43,640
find the device, then you read it and you do this. This is how ring versions, if you understand how

655
00:54:43,640 --> 00:54:49,480
they work internally. Okay, great. There's class, here's the operations. And it's that looks,

656
00:54:49,480 --> 00:54:53,240
you can always do it this way around. And look, I've got a different way of doing it. So just a

657
00:54:53,240 --> 00:54:59,320
union based approach now, with all the data inside of it doing all what we need, whatever.

658
00:54:59,640 --> 00:55:05,240
And that thing that's just is actually trying to show the actual things internally, isn't

659
00:55:05,240 --> 00:55:10,040
it? But yeah, it's kind of like, look, now I don't like vtables, because obviously pretty

660
00:55:10,040 --> 00:55:14,520
much everywhere, because I find them hard to control. So I prefer this. So he says, look,

661
00:55:14,520 --> 00:55:20,920
I have a, not a vtable, but just inline things itself, it's not a table, just inline functions.

662
00:55:20,920 --> 00:55:26,920
So instead of a class, you've now just got inline methods. And this is just general handling

663
00:55:27,480 --> 00:55:31,560
thing, which is interesting. By the way, that should be more better for performance in general,

664
00:55:31,560 --> 00:55:36,520
because a vtable is usually a pointer to a structure of a function tape, like function pointers,

665
00:55:37,160 --> 00:55:40,440
whilst if you're embedding the function pointers, you've got rid of that indirection. So you've

666
00:55:40,440 --> 00:55:44,040
actually got it will be faster in general as well, because you've got rid of the indirection.

667
00:55:44,040 --> 00:55:49,320
It always has a better chance to optimize and even it has slightly better chance of inlining

668
00:55:49,320 --> 00:55:55,560
and slightly. But yeah, that's how compilers work. Sorry, rambling again, again. But I'm

669
00:55:55,560 --> 00:55:58,680
getting off the digression. But cases kind of saying like, look, we could just handle it for

670
00:55:58,680 --> 00:56:04,040
each of them that we could actually have one callback, just one, and we could directly embed

671
00:56:04,040 --> 00:56:09,320
it in the structure. So it's not even in directed anymore. And then we switch on this. Now this is

672
00:56:09,320 --> 00:56:13,800
interesting. You could do it for every single operation. And then look the codes in one place

673
00:56:13,800 --> 00:56:20,360
for this thing. We've now got the best of both worlds in many ways. And why wouldn't you prefer

674
00:56:20,360 --> 00:56:26,600
this way? I think now interestingly, I'm just going to like slightly digression here going into

675
00:56:26,600 --> 00:56:31,480
Odin. And this is what we actually do for the allocator. And I've been doing this for like a

676
00:56:31,480 --> 00:56:39,720
decade, maybe even before Odin. There is the thing sorry, apologize for the digression. This is

677
00:56:39,720 --> 00:56:44,840
clearly unscripted if you didn't guess. Here's the allocator. So we know that we have a built in

678
00:56:44,840 --> 00:56:48,280
concept from an allocator and allocator is just a little data structure with a pointer to a procedure

679
00:56:49,000 --> 00:56:54,920
and appointed to the data. So 16 bytes, you can easily copy this around. So it's usually not

680
00:56:54,920 --> 00:56:58,520
even appointed to the allocator, it's just the allocator itself in memory. And you just get the

681
00:56:58,520 --> 00:57:02,600
values. So that's what you're doing. So there's not an indirection again, because it has to be a

682
00:57:02,600 --> 00:57:06,200
pointer. And notice it's just in line with the function. And not just there's only one function

683
00:57:06,200 --> 00:57:09,560
you think, but there's loads of different allocation operations like yes, it's one function,

684
00:57:09,560 --> 00:57:13,960
you take all the arguments in, and you change the allocation mode is an allocation alloc free,

685
00:57:13,960 --> 00:57:17,640
free or resize query features query and for an alloc non zero. Because sometimes you want to be

686
00:57:17,640 --> 00:57:22,040
allocated without a zero, but by default you want zeroed because it's quite useful. And also it's

687
00:57:22,040 --> 00:57:26,360
pretty much free if you're using like virtual memory, like allocating zero memory is pretty much

688
00:57:26,360 --> 00:57:31,480
free. Because it has to be for security benefits. There's no option to not get it if you ask for

689
00:57:31,480 --> 00:57:37,080
virtual memory. So I'm just trying to show here that I already take advantage of this kind of

690
00:57:37,080 --> 00:57:41,320
approach. And then within every single allocator, I have a switch statement which then pairs each

691
00:57:41,320 --> 00:57:46,120
operation together. So I'm just trying to get off my digression a bit here. So this is what case

692
00:57:46,120 --> 00:57:49,800
is kind of trying to say and you could do this. So you're not having the full on inheritance style,

693
00:57:49,800 --> 00:57:53,560
you just have a switch you could do the blend of the two. And there are benefits to this,

694
00:57:53,560 --> 00:57:59,160
obviously. And you'd have all of this lovely. So because in either case, but this is larger

695
00:57:59,160 --> 00:58:03,320
rather than because it's solely look look up map look up now and to a specific device and it can

696
00:58:03,320 --> 00:58:07,480
be used in either design. Anyway, over the course of the development of the OS, I think the implementation

697
00:58:07,480 --> 00:58:12,040
saves programmers and cycles potentially a lot of them compared to the one I understand believed

698
00:58:12,040 --> 00:58:18,120
you favored by the clean code method. Again, which is interesting because the casey one is

699
00:58:18,120 --> 00:58:22,840
closer to being like, sub typing to a sentence, but there isn't sub typing, it's just like,

700
00:58:22,840 --> 00:58:28,200
here's the abstract thing with a function pointer, deal with it. Which is kind of close to inheritance,

701
00:58:28,200 --> 00:58:32,760
but it's not just one. And it sounds like a minor difference people say, oh, it's equivalent. It's

702
00:58:32,760 --> 00:58:38,040
like, but it isn't equivalent. In fact, it will be faster. You can easily measure it. It'll be easier

703
00:58:38,040 --> 00:58:41,880
to maintain because everything's in there. And not just that, if you add a new operation into

704
00:58:41,880 --> 00:58:44,920
there, every single one will just yell at you anyway, because you've not implemented it.

705
00:58:46,280 --> 00:58:49,960
So if you've got a language that tells you that switch name is not necessarily C or C++,

706
00:58:49,960 --> 00:58:55,480
maybe modern C++, I know, I think. And sometimes C with the, when you have warnings all and

707
00:58:55,480 --> 00:58:58,360
everything will tell you switch name is missing certain cases. But yeah.

708
00:59:01,160 --> 00:59:04,040
And cases look, I don't know if it's a bit of an extract and file, because I'm sick,

709
00:59:04,040 --> 00:59:07,080
but it was the first one you brought up. And it happened to be the contrast,

710
00:59:07,080 --> 00:59:10,760
the two designs in my opinion. So it works, works for me as Casey is saying here.

711
00:59:11,960 --> 00:59:17,800
Here's why I think an enum based design deserves the programmer cycles. In most systems, you don't

712
00:59:17,800 --> 00:59:21,560
know all the functions that are going to be used ahead of time when operating costs are hard boundary,

713
00:59:21,560 --> 00:59:25,480
like a driver, using operation codes instead of virtual function calls allows you to add more

714
00:59:25,480 --> 00:59:31,080
functions dynamically without recompiling all our drivers. In any modern operating system,

715
00:59:31,080 --> 00:59:34,520
multi-threading is a concern. But this is especially true for an operating system,

716
00:59:34,520 --> 00:59:40,200
having the protocol be structured based with an operation code allows us to trivially buffer

717
00:59:40,200 --> 00:59:47,320
operations in things like IO rings and other intermediaries, intermediaries, without writing

718
00:59:47,320 --> 00:59:52,680
any new code. The entire system remains identical. Yeah, I'm just trying to do this. And you just

719
00:59:52,680 --> 00:59:56,920
said, this is by the way, it seems like almost happens in almost all systems, OOP systems,

720
00:59:56,920 --> 01:00:01,640
I see, I'm trying to get around pronunciation, say, because eventually they need to serialize

721
01:00:01,720 --> 01:00:07,880
or something similar. And so they have to write my version as well as the version as their version,

722
01:00:07,880 --> 01:00:10,840
but they don't seem to realize how much time they're wasting. Like, yeah, this is

723
01:00:11,720 --> 01:00:16,280
clarifying this point. People think this seems like the clean code will actually save time,

724
01:00:16,280 --> 01:00:18,760
but it's actually no, you're now forcing another person to write the same thing again.

725
01:00:19,400 --> 01:00:22,920
And you are actually wasting time, you think you're saving things. But again,

726
01:00:22,920 --> 01:00:26,440
if you want to know if you're saving time, you're making a statement like this will save

727
01:00:26,520 --> 01:00:31,240
programmer cycles, like a claim, show the evidence. And don't just say, well,

728
01:00:31,240 --> 01:00:37,320
my your seniors may agree with me, because they were convinced by my argument. It's like, yeah,

729
01:00:37,320 --> 01:00:41,800
but where's the evidence, regardless of this authority, this later argument by authority.

730
01:00:43,000 --> 01:00:47,720
It is the after a while, many people will come out the phase and like, oh, I don't do this

731
01:00:47,720 --> 01:00:52,360
anyway. But some people don't. And it's like, okay, I never really went through the OOP phase

732
01:00:52,360 --> 01:00:55,960
myself. Going a bit of a digression here. Sorry, this is completely random today. I know.

733
01:00:56,680 --> 01:01:03,320
Very, very unstructured. But I went through the modern C++ like 11 phase. So that's what

734
01:01:03,320 --> 01:01:09,640
12 years ago now, probably a bit before actually, because it was C plus plus zero x for a long time.

735
01:01:11,720 --> 01:01:14,760
And I remember learning all that stuff. And that was the thing I got caught. I wasn't really

736
01:01:14,760 --> 01:01:18,840
necessarily the OOP phase. It was that phase. I was learning all that stuff. And it was a while

737
01:01:18,840 --> 01:01:23,240
took me a few years and after was like, I'm doing all this extra code, writing loads, and I'm not

738
01:01:23,240 --> 01:01:27,640
getting any more productive. In fact, it's how hard to maintain. I'm writing literally 10 times

739
01:01:27,640 --> 01:01:31,320
more code than I needed. And they kept telling people kept people kept telling me because I was

740
01:01:31,320 --> 01:01:35,160
kind of trusting these people who were more thought they were more experienced with me or

741
01:01:35,160 --> 01:01:37,960
they thought they knew more because they've been doing it for longer. And they were talking from

742
01:01:37,960 --> 01:01:42,840
positions of authority to a certain extent that they were going, Oh, of course.

743
01:01:45,080 --> 01:01:47,960
Like, of course, this is going better because I'm telling you it's going to be better. I'm like,

744
01:01:47,960 --> 01:01:51,240
and then I was kind of believing them. And I was like, it doesn't seem like I'm trusting them.

745
01:01:51,880 --> 01:01:55,400
But it didn't it didn't seem to the case when I just started programming back to like a normal

746
01:01:55,400 --> 01:01:59,480
basic C style with switch statements in many cases, and just like normal standalone functions,

747
01:01:59,480 --> 01:02:04,280
no, not even using methods. I got more productive. My code got smaller, got easier to read,

748
01:02:05,160 --> 01:02:10,440
just by not doing any of that. And it was kind of like not using not doing any of the stupid

749
01:02:10,440 --> 01:02:14,360
templates, not doing stupid any of the ownership semantics. I'm not saying ownership semantics

750
01:02:14,360 --> 01:02:19,240
stupid. I'm just saying the being everywhere was like, look, I just kind of went to more

751
01:02:19,240 --> 01:02:24,760
pod data was a plain old data data kind of style old fashioned C style, my code just got

752
01:02:24,760 --> 01:02:29,160
easier to read more maintainable and just everything like from a personal perspective,

753
01:02:29,160 --> 01:02:33,800
again, I cannot measure this. And the only way I can convince people say, here's my code, here's

754
01:02:33,800 --> 01:02:38,120
this normal code, which one define easier to read. And that's the only way that's not a measuring

755
01:02:38,120 --> 01:02:41,880
that's just still like a personal preference thing in the day. This is the problem in these

756
01:02:41,880 --> 01:02:51,720
discussions. And it is just getting down to that. It's like one side is there is an empirical

757
01:02:51,720 --> 01:02:56,200
thing to a certain extent, which I'm going to comment right at the end. I will get to this,

758
01:02:56,200 --> 01:03:01,800
don't worry. But he talks about this saying here at any point things, if we would like to

759
01:03:01,800 --> 01:03:04,280
buy third parties to allow communication with channels on the devices, blah, blah, blah,

760
01:03:04,280 --> 01:03:08,600
okay, we're talking about the IO stuff, fine. We're getting nearly getting the answers. So

761
01:03:08,600 --> 01:03:12,520
Mr. Martin says, okay, I think I see where we're going. So let me say, sure, looks good to me,

762
01:03:12,520 --> 01:03:17,640
the bullet points you added are after the fact are all quite valid. And the design you picks

763
01:03:17,640 --> 01:03:21,480
works well in this case. In the first point, you assume that operations will increase beyond

764
01:03:21,480 --> 01:03:28,200
the two original proposed, as we both agreed, as I wrote in the clean code, which, by the way,

765
01:03:28,200 --> 01:03:34,280
is not the same as your clean code. Right, when operation periphery more rapidly type

766
01:03:34,280 --> 01:03:42,120
switch statements are better. So there's that line alone is or another rhetoric trick,

767
01:03:42,120 --> 01:03:47,080
lovely one, in fact, in my opinion. In the first point, you assume that operations will increase

768
01:03:47,080 --> 01:03:55,560
beyond the two originally proposed. Okay, as we both agreed, I don't think Casey agreed to anything.

769
01:03:56,920 --> 01:04:00,840
And secondly, Casey's not calling what he claims clean code, he's trying to understand

770
01:04:00,840 --> 01:04:06,680
what your clean code is Casey never says his code is clean code, because yours is Mr. Martin's

771
01:04:06,680 --> 01:04:15,400
clean code with a capital C trademark to kind of think. Yeah. So another little kind of trick he

772
01:04:15,400 --> 01:04:20,760
does already any can't help himself really. So when operations profite more rapidly type switch

773
01:04:20,760 --> 01:04:24,920
statements are better. In point two and three, you raise the specter of multi threatening,

774
01:04:24,920 --> 01:04:29,400
you are of course correct that queuing operations is a lot easier. If you request packets of the

775
01:04:29,480 --> 01:04:34,600
same type you design no argument there. And the last point proposed a kind of hook for unknown

776
01:04:34,600 --> 01:04:40,120
and unspecified possibilities in the future. Yeah, so what he says is like, okay, you have the general

777
01:04:40,120 --> 01:04:44,440
cases and then have a hook for the unknown cases like the open cases. Okay, if you think those

778
01:04:44,440 --> 01:04:48,760
unknown cases and special are likely, then you should have considered them earlier. But then

779
01:04:48,760 --> 01:04:52,840
that raises a number of other concerns that we should not likely address in this document. It's

780
01:04:52,840 --> 01:04:57,720
like, no, no, no. So I think I'll let pass. No, why? Because if you didn't, he has to let that pass

781
01:04:57,720 --> 01:05:01,880
because it then kind of defeats his point. Because the inheritance approach, which is

782
01:05:01,880 --> 01:05:06,760
preferred by clean code, is saying that the open case is the open set of variants, the open set of

783
01:05:06,760 --> 01:05:12,600
operands is the general case. It isn't. Because if you've got a close set, which you know, like

784
01:05:12,600 --> 01:05:17,960
pretty much always know that 99% of the time 99.99% of the time is going to be

785
01:05:21,480 --> 01:05:25,560
going to be closed, like pretty much going to be that small set. So you're optimizing for them.

786
01:05:25,560 --> 01:05:31,080
And then you've got this, the unknown hook cases allow the user to add their own callbacks in there.

787
01:05:31,080 --> 01:05:36,040
Fine. That's fine. But it says, it says, unlike to consider the head of time, it's like, yeah,

788
01:05:36,040 --> 01:05:41,640
but you're assuming that those unknown cases are just as common as the known cases. And

789
01:05:43,480 --> 01:05:48,840
that is actually designing the API. Now the thing is, if you're optimizing for the general case,

790
01:05:48,840 --> 01:05:53,400
and then you allow a hook in, that hook is not going to be is not going to be any slower than

791
01:05:53,400 --> 01:05:59,160
if you design it to be always a general case than the specific cases. That's the point he's

792
01:05:59,160 --> 01:06:04,440
trying to say here. Like, that's why he's letting it pass, because it is literally just as fast

793
01:06:05,560 --> 01:06:08,920
to do it that way, then to design it all the way around as if it was always unknown,

794
01:06:09,720 --> 01:06:15,800
as if it was always dynamic polymorphism. Sorry, just say inheritance, be easier,

795
01:06:15,800 --> 01:06:22,600
because technically what it is in this case. So now where are we? You propose a solution that

796
01:06:22,600 --> 01:06:26,760
uses dynamic polymorphism, select two types, and then a switch same to select operations.

797
01:06:26,760 --> 01:06:31,880
I have no problem with this. It works well and satisfies my concerns about dependency inversion.

798
01:06:31,880 --> 01:06:37,240
I'm like, but it isn't the same kind of dynamic polymorphism that you've ever

799
01:06:38,120 --> 01:06:42,840
recommended to anybody. So this isn't technically key and code. In fact, anybody who

800
01:06:42,840 --> 01:06:48,200
would a clean code advocate would read Casey's code of, let me go back to it, this and go,

801
01:06:48,200 --> 01:06:55,400
that's not clean. So this leads to the problem of clean code is whatever Mr. Martin says it is

802
01:06:55,400 --> 01:07:00,280
at that moment. It's not like anyone could actually agree on what clean code is because

803
01:07:00,280 --> 01:07:03,800
it changes from time to time. It's not a well-structured thing. And he's like, that's fine.

804
01:07:03,800 --> 01:07:09,640
It's like, then why don't you just call it Mr. Martin style? Because it clearly doesn't work.

805
01:07:10,360 --> 01:07:14,360
It's not clean. And it clearly doesn't work the way he wants it to in every single case.

806
01:07:14,360 --> 01:07:18,280
But then you shouldn't do it like a dogmatic. And it's like, it's a weird trick. He says,

807
01:07:18,280 --> 01:07:23,000
look, don't be dogmatic. Don't follow these the rules. But then it's like, well, I won't,

808
01:07:23,000 --> 01:07:26,440
I don't agree with it anyway. Well, you clearly have some of these rules, don't you? It's like,

809
01:07:27,640 --> 01:07:33,400
it's that clever trick again. It's the pork barrel naming again. It's the rhetoric over

810
01:07:33,400 --> 01:07:41,240
rhetoric over again. I'm like, look, even if Mr. Martin style increased programmer cycles,

811
01:07:41,960 --> 01:07:47,880
the decrease of wasted programmer cycles, like, whatever. Great. But how do you prove this is

812
01:07:47,880 --> 01:07:53,560
the case? And we're getting to the end now, and we're just going to do here. So I'm going to

813
01:07:53,560 --> 01:07:56,920
read the best of it. So, so Mr. Martin's your proposed solution time with thing blah, blah,

814
01:07:56,920 --> 01:08:00,600
blah, blah. What do you got to this? I will say, however, that that is an ironic that after your

815
01:08:00,600 --> 01:08:04,120
video and after all the stress that you have been put on saving machine cycles, you eventually

816
01:08:04,120 --> 01:08:09,720
chose a design that sacrifices machine cycles to save programmer cycles. After all, on the OS side,

817
01:08:11,400 --> 01:08:16,600
this is where he thinks he has won the argument. Ready? This is what he's tried. He's tried a trick.

818
01:08:17,480 --> 01:08:22,120
He's tried to do it because he took the canonical case of a stream. After all, on the OS side,

819
01:08:22,120 --> 01:08:26,920
you've you've got to package up all the quest packets and it's the dynamically dispatched

820
01:08:26,920 --> 01:08:32,600
handler and then run the operation ID through a switch. And I think we wind up in the same place

821
01:08:32,600 --> 01:08:36,520
when operations proflate more rapidly than tights, we both use switches, you don't,

822
01:08:37,160 --> 01:08:40,440
you do not do this. I've read your code, your public code, you don't do this.

823
01:08:41,640 --> 01:08:46,680
But he's saying he does just pretend you believe it. Okay. When tight for a plate more rapidly

824
01:08:46,680 --> 01:08:51,160
than operations, we both use dynamic dispatch, we are both willing to sacrifice machine cycles to

825
01:08:51,160 --> 01:09:00,120
save programmer cycles. No. Also the way again, how Casey structured it will be better because

826
01:09:00,120 --> 01:09:04,840
it's not technically how many levels in direction do you have before like technically here has

827
01:09:04,840 --> 01:09:08,440
one level of indirection, which is a function pointer compared to normal inheritance, which

828
01:09:08,440 --> 01:09:13,320
is three levels of indirection. Why? You've got a pointer to the object, pointer to the vtable,

829
01:09:13,320 --> 01:09:22,360
then a pointer to the function. Guess which one's going to be faster? Just have a hesitant guess.

830
01:09:23,400 --> 01:09:27,480
Okay. And not just that, you've then have to go all through this indirection compared to having one,

831
01:09:27,480 --> 01:09:31,800
which is probably going to be in the literally cash already in the cash ready to be called.

832
01:09:31,800 --> 01:09:36,040
No problem. It's going to be easily predictable as well for the CPU. It's a very different thing,

833
01:09:36,680 --> 01:09:43,400
very different operation that is to a generalized vtable. So no, they are not equivalent,

834
01:09:43,400 --> 01:09:47,720
even in performance. One will be quicker than the other. I'm not doing this video. I could do

835
01:09:47,720 --> 01:09:50,680
another video if you'd like, but like we could prove it, one's going to be quicker.

836
01:09:51,720 --> 01:09:57,720
Single indirection compared to triple indirection. Okay. So when we are two individuals on the same

837
01:09:57,720 --> 01:10:03,560
eye and the only difference being that I wear this shirt and I don't know how to pronounce that word

838
01:10:04,040 --> 01:10:06,920
with clean code and you have one with clean code, I'm like,

839
01:10:07,720 --> 01:10:11,800
thank you for simulating the debate. I appreciate your candor and the civility that you exercise to

840
01:10:11,800 --> 01:10:15,480
and if, if not everywhere, I've come to experience your respect, your knowledge and blah, blah, blah,

841
01:10:15,480 --> 01:10:22,680
blah, whatever. So the first thing is this is a really dodgy thing. Casey and even cases,

842
01:10:22,680 --> 01:10:27,640
well, I disagree with most of that. But if we're ending here, I'll just finish my final responses

843
01:10:27,640 --> 01:10:35,240
for Gail poster poster posterity. And that is the thing. See how he tried to end it. And I'm

844
01:10:35,240 --> 01:10:38,520
going to read through Casey. I'm not going to comment on it now. I'm just going to read it for

845
01:10:38,520 --> 01:10:42,200
the end of this video because we've already been going on too long. Sorry. So I apologize

846
01:10:43,000 --> 01:10:48,360
for my rambling in between. I hope it's kind of an enjoyable if not, and I apologize again. So

847
01:10:48,360 --> 01:10:51,320
I'm just going to read through this. I'm just going to read Casey stuff. This is all Casey,

848
01:10:51,320 --> 01:10:56,760
not me. So regarding as I wrote in clean code, which by the way is not the same as your clean

849
01:10:56,760 --> 01:11:02,840
code? Well, the point is of discussion was your you to elaborate on what is not the same. But

850
01:11:02,840 --> 01:11:07,400
you're designed for the IO system looks exactly like my clean code example of virtual function

851
01:11:07,400 --> 01:11:13,400
for every operation, one class per element in the system with no predication. So what are these

852
01:11:13,400 --> 01:11:18,920
differences that you're referring to? Now would be the now would be the time to explain what they

853
01:11:18,920 --> 01:11:24,600
are since that was the point of the concrete example. If these are a bad example for accelerators,

854
01:11:24,760 --> 01:11:30,440
straighten the differences, that's fine. But it was the first one you gave to assumed that it would

855
01:11:30,440 --> 01:11:39,480
be the one you want to use. Regarding when operations proliferate more rapidly than types,

856
01:11:39,480 --> 01:11:44,440
switch teams are better. That was not the case here. In no way are operations proliferating

857
01:11:44,440 --> 01:11:50,680
more rapidly than types in the system. Vendors will add drivers to the OS constantly, perhaps

858
01:11:50,760 --> 01:11:55,240
monthly or even weekly, whereas the number of operations in a particular system tends to go

859
01:11:55,240 --> 01:12:00,600
much more slowly, once every few months at a maximum, but more likely once a year for something like

860
01:12:00,600 --> 01:12:08,520
the aniosis subsystem. It isn't the opposite of what you said. This is an important distinction,

861
01:12:08,520 --> 01:12:14,280
because what I'm demonstrating here is the opposite of your rule. This is showing that even in the

862
01:12:14,280 --> 01:12:20,440
case where types proliferate far more rapidly than operations, as in the case of drivers in an OS,

863
01:12:20,440 --> 01:12:28,200
the principle doesn't work. Enums are better in both cases, specifically because you have

864
01:12:28,840 --> 01:12:34,920
potentially thousands of types in the system, all different drivers, all the vendors have ever shipped.

865
01:12:35,880 --> 01:12:40,920
Adding a single operation, however rarely, can cost massive programmer cycles to the

866
01:12:40,920 --> 01:12:47,640
unnecessary work multiplication across types, the V-tapels course. Another way to say this would

867
01:12:47,640 --> 01:12:53,720
be enums are more important in a system where type proliferate rapidly, not less. Regarding,

868
01:12:53,720 --> 01:12:57,560
you eventually chose a design that sacrificed machine cycles to save program cycles.

869
01:12:58,120 --> 01:13:05,240
I did no such thing. The design achieves both, like why I like it. It's drastically faster to

870
01:13:05,240 --> 01:13:09,160
use something like a packet-based system than something that is originally proposed design,

871
01:13:09,800 --> 01:13:16,920
because you do not take a ring transition on every operation. New OS IO APIs are not all designed

872
01:13:16,920 --> 01:13:22,760
this way. This user writes data without taking in talking to the OS, and a kernel thread picks up

873
01:13:22,760 --> 01:13:28,120
those data writes. Nobody ever makes a function call, except occasionally to ensure the kernel

874
01:13:28,120 --> 01:13:34,280
thread hasn't gone to sleep. This is what I mean by the bullet point, if at some point we decide

875
01:13:34,280 --> 01:13:38,920
users should be able to do multi-threading book IO ops. I am talking about the necessity that

876
01:13:38,920 --> 01:13:43,880
actually occurred in both Linux and Windows of removing their frequency of ring transitions

877
01:13:43,880 --> 01:13:49,320
for saving CPU cycles. None of this is trading CPU cycles for programmer cycles. It's achieving

878
01:13:49,320 --> 01:13:55,960
both. The Linux kernel design of the IOU ring looks like my design. That did not add to save

879
01:13:55,960 --> 01:14:00,920
programmer cycles. They added it because they wanted the highest possible IO throughput. This is an

880
01:14:00,920 --> 01:14:06,520
almost universal principle of modern OS design. Anything that can be turned into data writes

881
01:14:06,520 --> 01:14:12,760
should be, and function calls should be minimized. It's been true for GPUs, for NICs, and for our

882
01:14:12,760 --> 01:14:18,280
example disk IO. And the last bullet point is regarding, and so I think we wind up in the

883
01:14:18,280 --> 01:14:24,200
same place when dynamic operations proliferate more rapidly than types we both use, switches,

884
01:14:24,200 --> 01:14:28,600
when types proliferate more openly than operations we both use dynamic dispatch. Again,

885
01:14:28,600 --> 01:14:34,280
I don't see how you got there. Obviously types are proliferating more rapidly in this system,

886
01:14:34,280 --> 01:14:39,560
so that is part, is true. If we didn't believe drivers are proliferating rapidly,

887
01:14:39,640 --> 01:14:45,640
why are we loading them dynamically? And I thought that was the entire point of the example,

888
01:14:45,640 --> 01:14:50,520
but perhaps more importantly, we are not using dynamic dispatch here in the way that you've been

889
01:14:50,520 --> 01:14:54,840
suggesting. As I was pointing out earlier, I said that when I proposed the design process,

890
01:14:54,840 --> 01:15:00,120
I would also do the inside drivers themselves. I would not duplicate drivers to remove if

891
01:15:00,120 --> 01:15:04,120
statements and switch statements inside a driver that allowed the drive to handle multiple similar

892
01:15:04,120 --> 01:15:10,360
devices. The only reason that there are function pointers in this system is because the problem

893
01:15:10,360 --> 01:15:15,880
definition required that we load the driver from a different module, and we are not presuming a JIT

894
01:15:15,880 --> 01:15:22,440
or something that can weld, wield, weld things together for us. That introduces a mandatory

895
01:15:22,440 --> 01:15:28,600
cut so we cannot get rid of it because the problem is defined to contain it. But note that this is

896
01:15:28,600 --> 01:15:33,000
not the same between our two approaches. I have a function pointer there because it's required,

897
01:15:33,720 --> 01:15:38,600
and you'll note I minimized the number of all the way down to one. I didn't put it in there

898
01:15:38,600 --> 01:15:43,160
because I think it saves program time. In fact, I'm not really sure I want it there at all. I

899
01:15:43,160 --> 01:15:47,880
haven't actually implemented this particular system in an OS, so it's somewhat off the top of my head,

900
01:15:47,880 --> 01:15:52,760
but it's very impossible that if I actually went to write this, I wouldn't include that function

901
01:15:52,760 --> 01:15:59,800
pointer at all. Instead, I might just have the OS thread reading the queue, sorry, the OS thread

902
01:15:59,800 --> 01:16:07,000
reading the queue, and pre-filtering the packets for quota permissions, then updating a shared

903
01:16:07,000 --> 01:16:12,680
memory access that lets the driver know it can process the packets directly without actually

904
01:16:12,680 --> 01:16:18,600
implementing. I can't say that's for sure what I would do, but it's probably something I would try.

905
01:16:18,600 --> 01:16:23,880
So thanks for overstating the similarity of our approaches, but I think that they're similar,

906
01:16:23,880 --> 01:16:29,000
then I guess that's just where we end up. Thanks for taking the time to create this thread which

907
01:16:29,000 --> 01:16:34,680
pushed the GitHub emoji to check a well beyond its limits. Sorry, I had to read all that, but yeah,

908
01:16:34,680 --> 01:16:38,680
that was all right. So this is kind of the point I was trying to point out is that case was saying

909
01:16:38,680 --> 01:16:44,200
this isn't what you were showing, and the point where I say like Mr. Martin thought he won the

910
01:16:44,200 --> 01:16:49,800
argument, like you need to use this style, is by using the canonical case of requiring it,

911
01:16:49,800 --> 01:16:53,240
which is the canonical case is a data stream, a canonical case of like you've got different

912
01:16:53,240 --> 01:16:59,240
operations fixed interface, but you've got an opaque different what it actually variant type,

913
01:16:59,240 --> 01:17:03,320
whatever it is. And then they talk about actually how does it implement the operating system case,

914
01:17:03,320 --> 01:17:06,680
it actually just shows that actually effective this is how you do it in Linux. We don't know how

915
01:17:06,680 --> 01:17:10,600
Windows works kind of, we can reverse engineer it, but like it's not the source code, it's not

916
01:17:10,600 --> 01:17:17,640
public obviously, because it's a closed source operating system. But that's kind of the the

917
01:17:17,640 --> 01:17:24,280
issue that's going on here. Mr. Martin thought he won by showing like you already just did dynamic

918
01:17:24,280 --> 01:17:29,960
dispatch. In case you went, you just find it to have it. And in fact, I didn't even require multiple

919
01:17:29,960 --> 01:17:35,160
functions acquired one, it's not tripling direct to any single interaction. And I just had a switch

920
01:17:35,160 --> 01:17:38,120
name in there, because this is also how the operating system does it. And it's better for

921
01:17:38,120 --> 01:17:44,200
literally CPU cycles and reduced programmer cycles. It's not one or the other. So hopefully this is

922
01:17:44,200 --> 01:17:49,400
okay. And I'm done now. I was just going to do this. And I was talking about this, we've already

923
01:17:49,400 --> 01:17:54,360
discussed this, what I've seen was I did a tweet on it mildly. And there were some other things

924
01:17:54,360 --> 01:17:58,200
I was talking about here on to talk about Mr. Martin, but I didn't in the end be honest with you.

925
01:17:59,880 --> 01:18:05,320
It was more of a, I'm just showing the rhetoric styles of Mr. Martin. That was it. So I hope you've

926
01:18:05,320 --> 01:18:11,720
enjoyed this. I apologize. This is about 120 minutes long. So thank you for putting up with

927
01:18:11,720 --> 01:18:17,320
all this. I wanted to end off with this little thing here is what I wanted in for. So we already

928
01:18:17,320 --> 01:18:22,120
had this in his code, but someone commented here saying, look, I says, but there's kinds of environments

929
01:18:22,120 --> 01:18:25,560
though, the parsimony is important nowadays, far and few between the vast majority of software

930
01:18:25,560 --> 01:18:29,880
requires less than 1% of modern processing. This is the first section we read. What's more

931
01:18:29,880 --> 01:18:33,400
processes are so cheap and available that is a trivial matter to add more of them to the system.

932
01:18:33,400 --> 01:18:37,880
Someone replied, I should know this person by the way personally, we do not consider it

933
01:18:37,880 --> 01:18:41,560
good engineering practice of the person wrote it, not the quote, good engineering practice to

934
01:18:41,560 --> 01:18:46,440
consume a resource lavishly just because it happens to be cheap in the class of it or Nicholas worth

935
01:18:46,440 --> 01:18:50,120
one of my actual programming idols out there. And I love this quote because it's kind of as

936
01:18:50,120 --> 01:18:54,440
viet slaw of worth slaw. However, it doesn't care. It's either name by or bind value. It doesn't

937
01:18:54,440 --> 01:18:59,480
matter. And then Mr. Martin replies, that depends upon the, which resource you are talking about

938
01:18:59,480 --> 01:19:03,400
computer cycles, computer cycle, programmer cycles, which should you trade against? And again,

939
01:19:03,400 --> 01:19:07,160
I don't see what being the odds, but simpler code is easier to write. Our bubble source is

940
01:19:07,160 --> 01:19:11,640
simpler. The tricky again, it's another trick. It was just last showing the rhetoric trick.

941
01:19:11,640 --> 01:19:19,160
Simple is actually an overloaded term in programming. And it's an overloaded term in English,

942
01:19:19,160 --> 01:19:23,240
because simply you need to mean the opposite of complicated, or it can mean the opposite of

943
01:19:23,240 --> 01:19:28,360
complex. And in the case of complex, the technical term would be simplex. So is it simple as in

944
01:19:28,360 --> 01:19:34,680
not complicated or simple as in simplex? And he has just done this on purpose. And he knows it

945
01:19:34,680 --> 01:19:40,920
very well by saying, well, bullsaw is simplex, but it's very expensive. Multiply and multiply by

946
01:19:40,920 --> 01:19:45,880
repeat about it. So it's simple. Actually, that's how, that's how like AMD processors, not AMD ARM

947
01:19:45,880 --> 01:19:51,320
processors actually work, by the way, they don't technically implement multiplication. x86 does,

948
01:19:51,320 --> 01:19:58,520
by the way, ARM does AMD 64. Sorry, I should say, AMD 64 does an x86 in general. It's actually one

949
01:19:58,520 --> 01:20:03,080
of the only, it's very, very, you find a processor that does this, but they did it. Linear searches

950
01:20:03,080 --> 01:20:06,600
are simple. Like, yeah, they are simplex. They also may be simpler, faster as well, but they might

951
01:20:06,600 --> 01:20:14,520
not be. Like, there's a reason. But this is the trick. So I just want to end on that note. So I hope

952
01:20:14,520 --> 01:20:21,480
you've enjoyed this. Please remember to like that smash button, and to comment in the description

953
01:20:21,480 --> 01:20:25,240
below. And again, if you want to read any of these links before, I will post them in the description

954
01:20:25,240 --> 01:20:30,040
of the doobly-doo below below here. And hopefully you've enjoyed this. This is a very unstructured

955
01:20:30,120 --> 01:20:37,240
ranty talking about Mr. Martin's rhetoric style with regards to clean code, how, and at the end,

956
01:20:37,240 --> 01:20:41,640
effectively, he just stated exactly what most people thought clean code was stating, and Casey

957
01:20:41,640 --> 01:20:50,440
went, so I was right about what clean code was. Okay, thank you. So goodbye, everyone, and stay

958
01:20:50,440 --> 01:20:52,440
tuned for the next video.

