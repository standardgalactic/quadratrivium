start	end	text
0	6720	Hello and welcome, I am Gingerbell and today I'll be talking about the fiasco that has
6720	12840	happened between Casey Muratori and Mr. Robert C. Martin. But before that I'm going to explain
12840	16240	why the history got here and I'm going to also explain some stuff. I'm not going to
16240	23600	try and criticise clean code itself. Casey Muratori has been trying to do this in the
23600	29640	long discussions he's had with Mr. Robert C. Martin already. But it's one of those things
29640	33880	where I just want to kind of show the rhetoric tricks of Mr. Robert C. Martin himself. So
33880	39800	before we get to that start off, let's begin with the thing that started it all, which
39800	46960	was this video that Casey made public from his thing. It's called clean code, horrible
46960	52680	performance, where they say 22 minutes long video, him showing the examples of what clean
52680	57400	code is and going into a more, let's say more like simplified code, which is more optimised
57400	60720	performance and showing the cost. Hey, if you do it the clean code where you're going
60720	66280	to be 15 to 25 times slower as your performance, do you want to take that hit? Understand what
66280	71160	the costs are kind of you. And again, this is this view has also taken our context is
71160	76200	blown up by mad. It's nearly half a million views so far at the moment at the time of
76200	82440	recording. And so it's clearly gone viral across the programming world. Unfortunately,
82440	91000	because it went viral, a lot of the context got lost. And because the context got lost.
91000	95080	People just adding their own context into it without even bothering to learn it. So the
95080	101280	context was this comes from a series that Casey's been doing on computer hands.com,
101280	106280	where it's a performance awareness course. So specifically the this is the programming
106280	110640	course he's been doing to performance awareness stuff. And this is a subscribed based thing
110680	116240	on the on the on here. And he's been doing many different topics on here as I was able
116240	121120	to learn how to performance awareness. Specifically, this was the blog post and he made completely
121120	124920	public for everybody showing all the code showing all this stuff. So then you can see
124920	129320	a whole video is all kind of transcribed down. And it's part of a series. It's not the beginning
129320	133240	of the fifth series is quite in the middle. So it's kind of like, Oh, okay, we're not
133240	138720	starting from a random place. So and also when people say and talk about the context
138720	142600	of this Casey understands this like, look, reminder, I don't think clean code is bad
142600	146600	just because of performance. My recent video is about poor performance, because it's part
146600	151000	of a course on performance. This is the context many people lost. And he's been doing this
151000	154560	for decades is saying so I recommend reading these tweets, I will try and provide all of
154560	159120	the links to everything I'm showing today in the description or the do blue do whatever
159120	165680	you want to do down below on YouTube. So be here. So yeah, hello. Good. So give a background.
165680	171320	He's picked up the attention of Robert, Mr. Robert C Martin, which he colloquially calls
171320	176400	himself Uncle Bob. For this talk, I'm just going to call him Mr. Martin, because I just
176400	182920	prefer saying Mr. Martin, insert your guesses as to why. But yeah, he is very well known
182920	189080	for my mainly three things, which is the agile manifesto, he helped develop that solid the
189080	195120	solid principles. So the agile manifesto and solid principles, which again, many people
195160	199000	know from the world, especially that he wrote it in his in his book, which is first in design
199000	204640	as principles and design patterns, as it says on here. And he's also in this thing known
204640	211280	for clean code. So clean with capital C code with capital C trademarked. This is his particular
211280	217600	thing, the capital C clean code thing. Okay. And this is what he kind of tries to describe.
217600	225080	So to get to show my biases and my background, I am the creator of the program language here.
225080	228200	And the only program language is the general purpose program language with the distinct
228200	233240	typing built for high performance modern systems and data order programming. So clearly, I'm
233240	237560	showing my biases, and I'm cleaning on more like case and oratory side when it comes to
237560	243240	this discussion. And also, I work at Django effects on emogen and liquid gen and geo gen,
243240	247320	which are all high performance real time pieces software like simulations, again, engines
247320	251400	for fire, smoke and explosions in real time. So clearly, I work in an industry where we
251400	255160	really care about high performance real time stuff. So clearly, I'm showing my biases straight
255160	261720	away. So people understand what's going on. Okay, so now you know, that's on the way. Can
261720	266760	we explain what clean code is before we get into this? So sure. So there is this kind of
266760	271320	little document I found the other day, and it's been well actively updated by looks only eight
271320	278440	hours ago at this time of recording. And today's date is the March the 30th, I believe. Yes, March
278440	283000	the 30th. So it's very active or someone's updated there's probably some typos and such
283000	287960	we can even see the revisions. And yeah, it's just some, hey, just capitalizing some straw.
287960	292920	That was all it was. Now, many people have seen to have liked this clearly over 5000 stars and
292920	298280	over 1000 forks of this gist, as well gist or I don't know we pronounce it on GitHub,
299080	305240	and explained some of the began your principles or points about clean code. Now there's many
305320	309400	of this. This is the thing about which is why clean code capital C thing trademarked by Mr
309400	314200	Martin is very popular because there's many of these rules, which no one would disagree with,
314200	317800	like follow standard conventions. Yeah, because conventions are a good thing because then you're
317800	322680	working on the same sun, only break them when you need to keep it simple, stupid, you're fine,
322680	327000	whatever. Boy Scott rule, leave the camp around cleaner than you found it, always find the root
327000	332520	cause you're no problem like this, yada, yada. Now some of these are things, okay, some of these are
332760	337240	not essential. These are accidental. Like, again, follow standard conventions. That's not
337960	342920	a unique to clean code, is it? You can do that in any philosophy out there. It's not a unique
342920	348280	principle to clean code itself. But some things like, for instance, I would say more essential
348280	354520	to clean code or prefer polymorphism to if or else cases. And separate multi floating code.
354520	360200	I'm not even sure what that means. Use dependency injection. Follow the law of Demeter or many
360200	364040	other things, many other things like here, like, Oh, use small functions functions, they only do
364040	367960	one thing use descriptive names, like getting that descriptive names, everyone agrees to that to a
367960	373000	certain extent, prefer fewer arguments have no side effects. So be more functional, it means more
373000	377560	and more rather than be like, have side effects itself, like be more imperative relying on like
377560	381880	global state or modifying state or whatever, don't use flag arguments, yada, yada, like, okay,
382680	387480	some of these people will agree with some people will disagree with them. But here's where the
387800	394680	the problem is with some of this is that for the most part, some of these rules,
394680	398360	people will agree with some of them don't. One of the particular is like small rules for me,
398360	402680	I actually disagree with this particular thing. There was a post here, this is on Jonathan
402680	406920	blows blog old, very old blog, actually, this one 2016. But he's actually even older than that,
406920	414280	because it's an old email response between him and john Carmack. So this is john Carmack explaining
414360	419880	effectively, what he preferred for the things is not the clean code up. This is what I wanted
419880	425720	was the wrong one. Whoops. Let's go to the blog post again. And it's this one here. So I accidentally
425720	429880	clicked the wrong button then. So this is john inline code. And john Carmack in the email is
429880	434120	explained, actually, he doesn't like the separate single functions here. It's better just have
434120	438040	one big function and then comment them. Now, some people might say be a bit easier to manage
438040	442280	looking at re things. Yeah, for code reviews, in a big corporate setting, it might be easier
442280	446200	looking a single function. But there's a few things you have to understand functions have
446200	450360	costs. If you split these things into multiple functions, this is a one is an extra cost. Yes,
450360	454760	is a minor cost when calling a function. But like that most people don't care about that cost,
455480	459320	unless you're doing particular things like you're worried about stack stacks or anything like that.
459320	463560	Like, okay, most things don't care. One thing it does do is it does actually doesn't mean it's
463560	467800	very easy to optimize for the optimizer. And I know how compilers work because I work on them for
467800	473000	kind of a living. And if you have things in line, one, it's not hard to read by just using
473000	476920	comments everywhere or block codes or anything like that. I think it's just as easy. And if you've
476920	483400	got text editors, which are use collapsible things, that's great. That's okay, no problems, just deal
483400	487400	with it that way. But then it's like, okay, but the optimizer can be ready, doesn't have to worry
487400	491240	about trying to inline that function. And then now optimize the new inline function that's been
491240	497000	got in line is out of another function. So there's that. And also you can usually start to see easy
497000	501800	patterns as well. If you start manually inlining things, it's not hard to read. Yes, okay, you've
501800	506920	got 10,000 lines, but most people's IDs and text editors are very easy for code folding, code
506920	513160	searching, code and organization. We're not living in the 80s anymore, or even the 70s,
513160	516440	to be honest, because even small talk had better options than this. I'm not saying I'm a big fan
516440	521640	of small talk. But again, the tooling is the argument going small function is more of a, hey,
521640	528840	it's our code review practices, big corporations, testing practices, and also maybe just tooling
528840	533320	practices. So that's one thing. But it's going to recommend highly reading this article, I really
533320	539720	do from 2014, again, it's from 2007, as it says here, I recommend it. But what I'm trying to get
539720	542600	out here about the word clean code, and I'm not even talking about the actual discussion that
542600	546600	Casey Motoria, they've been having yet, because I want to try to build up a picture here, as you
546600	550360	can probably tell, trying to be a storyteller, not very good at it, but let's carry on with it,
550360	554040	is that the concept of clean code is what I want to the term it capital C, capital
554680	559720	C on both of them, trademarked for Mr. Martin, is what I'm going to dub a pork barrel name.
560600	565480	So a pork barrel is a thing that America, American English, but it's kind of a
567400	571240	you have this bill, and it has a particular thing like citizens against government waste.
571240	575320	But it also has all of these things that are nothing even related to the actual name of the
575320	579640	bill. And to keep it in American context, because I know most people watching going to be Americans,
581160	584520	so I'm not going to use an English example, or another European example, like
584520	587080	Germans, I'm just going to use American example, I've run recent one as well,
587720	593240	is the Inflation Reduction Act of 2022. The name of it, the Inflation Reduction Act.
594520	598680	Okay, now I'm trying to be again, I'm not an American, don't really care politics, but I think
598680	603560	most people would agree, this act did not reduce inflation, in fact, it printed more money,
604520	607720	and more excess money, that money was not being in high demand.
608680	612360	So it increased inflation, in fact, it had loads of other things in there to do with
612360	618200	not to do with inflation. But a really clever political rhetoric trick is to say, oh, you
618200	622040	don't like this bill, we must like inflation, you're bad, everyone dislikes inflation.
622680	626840	So you must be, oh, you can't be against this bill, can you? It's like, but this doesn't,
626840	630920	ah, no, no, it doesn't inflation. How dare you don't want to, like, you can do this trick. And
630920	634200	again, it's not a political side either, literally all political parties or politicians,
634920	640440	I do this trick. Some countries like to do, like, oh, we're just getting names from bills.
640440	643800	But then they'll give them a name anyway, like a colloquial one to refer to it rather than giving
643800	647640	it like a letter or a number or some random numbers or something like that bill. And they'll
647640	650840	just say, look, no, this is what we're going to call it. Because technically internally,
651480	655560	the Americans do, but they give them a proper name and also a very long title. Again, this is
655560	661960	to provide for the reconciliation pursuant to Title II of the S Con Rez 14, I'm just reading it
662040	666360	as it says on here. And it's like, okay, but that's a good example from a political standpoint.
666360	669000	I'm just keeping it here, trying to keep it politically neutral. I don't really care about
669000	672520	the old politics, but it's just one of those funny things that show, hey, this is a trick,
673480	678440	because Mr. Martin will actually continually do this throughout. And it will trick, do a lot of
678440	683320	pivoting and a lot of these poor barrel names. Okay. So let's just say this is a good example
683320	688600	of this bad code. Just say no. And it's like, okay, so what's good code then? Because then it's,
689400	693160	phrases in the, oh, it's clean code, obviously. Now there was another tweet, I tried to find,
693160	698120	but I couldn't find it's probably been lost to the Twitter search, or it's just been deleted,
698120	703160	whatever. But he will commonly do this, Mr. Martin go like, oh, the opposite of bad code is clean
703160	708280	code with a capital C trademarked, which is interesting. Because that means anything that's
708280	716520	not clean code is a bad code. Yeah, let's not get there. But again, very clear, careful on this,
716520	721080	I'm not going to criticize him. I'm actually like, in admiration of his rhetoric, he's
721080	726360	a politician level when it comes to rhetoric, I mean this. And it's like, this is really good.
726360	731400	Like he's really good at it. But again, he's been doing it for nearly 50 years. He is what 70 years
731400	738280	old. He's been doing this sort of job since what, God, even the early 90s. So it, okay,
739640	745400	worst, like, it's 30 years, he's been doing this, he's probably been doing it for 40. Okay,
745400	749240	that's what he does for a living. He's very good at this rhetoric. So that's why I'm like,
749240	753320	I'm kind of admiring it into a certain extent, in a weird Machiavellian sense.
754120	757400	But sure, let's carry on with this, shall we? I've got some more things. Another thing in here,
757400	760760	he says, when this whole thing happened when he was talking about it, oh, no,
762120	764600	people don't like this code. But then he says, some people do this. And again,
764600	767480	I've shown you, he's very good, he's very good at knowing memes. He's not an old man, he's an old
767480	771720	man, but he's up to date with a lot of the stuff. And it sounds like silly, but it's not a book,
771720	775800	or the concept, it's a Cartesian pandering immature behavior. The author batches everyone,
775800	778520	and then he just shows this claim like, hey, I know how to play your joke.
779240	783240	Like, and he does, he's not that bad. But then there's other things. So here's like,
783240	788520	Casey Motori comes up with, I mean, he's talking about people criticising, and then he replies to
788520	792760	this, this is where kind of the start of the conversation is happening. So Casey has says
792760	797640	in this, even if true, to what extent would you tolerate the, yes, clean code is much slower,
797640	802200	but it's about programmer productivity for other products. Would you want a car that went only
802200	806680	five miles per hour, because the designers could do less work to make that car? Now,
807400	812760	Mr. Martin replies to what the auto owners notice he does a pivot. This is a pivot. And also,
812760	818120	it doesn't answer the question. He says, the automated mobile industry takes advantage of
818120	822840	every productivity tool they can reduce their enormous manpower cost of designing and manufacturing
822840	827160	cars. As a result, cars have gotten exponentially better over the decades, because the extra productivity
827160	834440	translates to better designs. Yes. But do you think they for their programming, they're using
834440	840920	clean code? Principles. In fact, we know they don't, especially after he's Mercer and stuff like that,
840920	844520	but they have to adhere to certain other things. And like, they're probably not doing clean,
844520	848840	clean code stuff. Now, I know the most things have started to relax, especially when it comes to,
848840	854920	like, Android Auto and I'm like, Apple Car play and stuff like that, it's, they're stuff a buggy.
854920	858200	But that's kind of like, Oh, it's your phone. That's a different thing. It's just we're interfacing
858200	862520	with it and whatever. And it's interesting. He does this because he does it again, when someone
863240	868200	replies to it and anything here. But he's kind of a, he knows what he's doing when he says these
868200	874920	arguments. That's not answering the question. All I'm going to say is that just watch that. Okay.
874920	878040	Another thing is this is when it starts, this was the beginning of his, I wash your thoughts and
878040	882360	he says, Oh, I've commented on this before clean code is made for programmer performance,
882360	888120	not algorithmic performance. If you need the latter, then write in C or assemble and live with
888120	894360	the high cost of development. So few things there already, PI programmer performance and
894360	899560	algorithmic performance. Okay, so program performance, it's the, in the contrast, how do you measure
899560	903640	that thing? How would you know if that your approach is better than another approach? And if
903640	907000	you need the latter, write in C and assemble, okay, it's assembly, I would call this, but yeah,
907000	910360	and then high cost of, so he's already implying that writing in C
911160	914680	is going to be a much higher cost of development than writing in another language.
914680	918600	It might be, but you should only write it in because you need the performance. And it's like,
919400	925720	okay, what? Look at the framing. He knows what he's doing. I'm not saying he's an idiot. He's
925720	929960	very smart. Okay, I'm sorry. I'm picturing it. I can already see which side I'm in, but I'm just
929960	933800	trying to explain the rhetoric tricks. So this is another thing is like the clean code to reply
933800	937240	to later with the automatic ability. I've got these switching around. It doesn't matter. People
937320	942600	says, how do you measure readability of the code by reading it? So obvious. But it's like,
942600	947880	when people say measure, they usually mean a quantifiable thing rather than a qualifying thing.
947880	954120	So this equality and a quantity are two distinct ontological categories, okay, or
954120	957080	epistemological, the many different things, which is not going to philosophy too much, but
957080	962040	you cannot quantify a quality and never qualify a quantity in a sense. They're different things
962120	970920	like, Hey, I have a tape measure here. Yeah, I can say it's got the, I say it's quality of being good
970920	975160	and round and green and stuff like that. And these aren't even very good qualities, to be
975160	981400	honest with you, but it has quantities. I know it's mass just by dropping it. That's what you need to
981400	985000	do. That's absolutely fine. And it masters. I'm just trying to explain the gravity thing. So
985000	988280	clearly it's got mass and we can measure that relative to other things that weigh things. So
988280	994520	we know how much this is weighs. This is probably weighs about, I don't know, eight ounces. So 225
994520	1001720	grams ish. That's quite heavy, actually, surprisingly, it's not even a good one. But there's kind of
1001720	1005320	the thing. So you can actually think you can sort of say, Oh, how, how green is where we can measure
1005320	1008760	the reflectings of it and then see how much it reflects back a certain light and some wavelengths
1008760	1012760	and such like this. You can say all these quantities and you're, these are quantities,
1012760	1016440	okay, but I want to go into too much clearly. I used to be a quantum metrologist. So I know
1016440	1020920	a lot of you may excuse measurements and all this stuff. But this is a clever trick by reading it.
1021880	1026040	That is not a quantity. And people are wanting to question how do you measure when we want an
1026040	1032200	objective measurement? What do you mean is they want a quantity? But he goes out by doing this.
1032200	1036280	So this was a big long twist post I've been here, where Lawrence Crow again,
1037080	1040840	the community anyway says people on hand made hating on Casey's videos about performance,
1040840	1044520	while their company is spending double digits of percentages of their revenue on
1044600	1048600	Amazon web server bills to serve three forms and a database view. And it's like, okay,
1048600	1053320	this is great nightlight discussion. Talking about this. And then Mr. Martin says here is his,
1053320	1057400	his analysis was correct. His rhetoric is abyssin, disingenuous. And the overall point was
1057400	1061320	extraordinary narrow. Clean code is about increasing programmer performance. He keeps
1061320	1066520	it straight this not computer performance. What are some real life life non-trial view
1066520	1070440	code bases support the hypothesis that strict clean code increases program performance
1071080	1071960	replies with a mean.
1075560	1080360	Again, he knows what he's doing. I'm not like, this is really cool. Like he knows what he's doing.
1080360	1083560	But yeah, so you don't have any of his tools that some says it. So the Vittorio
1083560	1087080	reminded me of a thing for the people I got into a discussion with him around about this time.
1087080	1092520	And I kind of partially convinced him about like, well, you need you've not go evidence for why one's
1092520	1096200	better than the other. Like show why how do you know one's better than the other? It's kind of
1096280	1100120	that question. Like how do you know what measurements are using what quantifiable or even
1100120	1103880	qualifiable things are you showing? Like, can you just show me the evidence? And then he goes,
1103880	1108200	he knows this for a fact, he says, the problem with scientific data is it's controlled in
1108200	1111640	controlled experiments and realistic software environments are economically feasible. You're
1111640	1116440	asking for something you'll never get. And yet you still decide. So look around and that's just
1116440	1119880	so it's especially your seniors. So first of all, it's just the first part of this thing here is
1120520	1126120	we have no evidence for our claims. But it's okay, because your associate seniors may agree
1126120	1135480	with me already. Nice little pairing here doesn't do the same thing. Okay. That's the first thing.
1136600	1140600	But then someone said like they said they use over the 10 lines of code sometimes wrong seniors,
1140600	1144600	I guess, and someone saying like, well, we've got my seniors don't agree with you. So sometimes,
1144600	1149160	of course, your seniors were correct. I presume they also told you that or else be your smaller
1149160	1153880	well named functions are better than really badly named functions is like, okay, notice the bad
1153880	1158120	pairing there already. A well named function is better than a badly named function. Agreed.
1158760	1163160	Smaller function may not be better than a long function. But notice is smaller well named
1163160	1166840	functions are better than really badly named functions. Never talked about the length of it.
1169000	1173640	I know it's like a minor word difference. But he knows what he's doing. And also he just changed
1173640	1177480	the topic and it's a pivot. He's gone from being the scientific data to now to well, trust your
1177480	1183000	the trust the authorities of your seniors or elders or whatever, like, that's going to authority
1183080	1188760	rather than going to like empirical data. Nice little pivot. He knows exactly what he's doing.
1189960	1194680	So another one here is always remember that computers operate on f in character one f in
1194680	1199000	character to times he's trying not to swear here. No matter what lovely subroutines you might be
1199000	1203160	using some replies, what about Sunday? Well, the context of the problem was JavaScript in a browser.
1203160	1209000	I'm like, what context I even tried to search through the other tweets. There was no context.
1209720	1220760	So, yeah. Okay, carry on. Another one. Someone has recently equated clean code
1220760	1226840	over engineering. That is, of course, an oxymoron. An over engine code is by definition not clean
1226840	1230120	and makes me wonder if those who complain so loudly have actually stood at the target of
1230120	1238120	their complaints. It's like, see the see the problem. So if he's over engineered, it can't be
1238120	1242600	clean code. Even though I've seen many clean code, which I've classes over and engineered. In fact,
1242600	1247720	I think clean code by default is kind of open engineered like it doesn't it's assuming this
1247720	1253160	could be open to change even though it's a close set of problems, which I'll get onto a bit later.
1254760	1258200	So then talking about this for tour of Rome, a shot we had earlier, I was discussing with him
1258200	1262440	previously. And he was kind of like, Oh, well, I can make it even faster. If you just change the
1262440	1266280	entire style of it and just have a raise of separate types. And I was just like, you being honest,
1266280	1270440	but this was the conversation I had even trying to confuse it like to not, he was kind of being
1270440	1273080	a bit confused, but also trying to be like explaining. And we kind of got to a point where
1273080	1277800	like, Oh, okay, like, first off, you've been a bit disingenuous here, man, with the argument,
1277800	1281560	but fine. This is not Mr. Martin anymore. This is just me explaining like there are people who are
1281560	1285960	trying not saying to defend him, but not understanding like Casey's point in this
1285960	1291000	discussion. So again, before I'm going to read this article, I recommend reading this clean
1291000	1296120	code, horror performance, YouTube video, again, links are in the description for all of these
1296120	1300600	links. So don't worry, they'll be there. So now I've done the 20 minutes spiel at the beginning
1300600	1306760	of this video. Let's get to the meat and potatoes of this entire thing, which is the written down
1307880	1315400	talk. Now this is quite interesting. And this written down talk is effectively a written
1315400	1320760	discussion between Casey Meritori and Mr. Martin. And they are both discussing with it,
1320760	1325000	and it's been split into different things. And I'll explain some points as I come along.
1325000	1328360	And so other little tricks. So first off, I'm just going to try and read it. I recommend
1328360	1332440	reading this again, links in the description below for everything. So Casey starts off with
1332440	1337000	thank you taking the time. And he's just kind of asking questions like so most explanations
1337000	1341320	on clean code, I've seen that you include all things I mentioned in the video, like
1341320	1346040	preferring inheritance hierarchies to ifstapes, which means like I remember if we look back
1346760	1351240	to the the where was the guest I found completely lost it already now.
1353320	1358440	It was here, right? Here it was here. Yeah, here's the design rules.
1360200	1364440	Like that some some size, that's not Mr. Martin's himself. But yeah, but it sounds like
1364440	1367640	you were surprised to hear me say that like all these different things he said is I look
1368600	1374200	Martin's going to disconnect. I'm not sure there is one. And interesting, he just says there is no
1374200	1378840	like disconnect. And Casey just asking questions about this. So Casey is asking a basic question
1378840	1382440	here like look, we're both familiar with Visual Studio and Clang, and it would be a reason more
1382440	1386920	that you're calling the back and uses it every day. I use these every day. I use LLVM and Visual
1386920	1390600	Studio every day. Are you calling these a vast majority of software that require less than
1390600	1395240	one things? And then he would go like, Oh, these are very specialized software, the only few in
1395240	1399560	existence, and only a few that have actually become popular. And then talks about why this case
1399560	1403720	and like actually talks about all these different things here, like, okay, speed is not necessarily
1403720	1408440	an issue. But you can summarize, I'm trying to summarize it. But then the first trick he does,
1409480	1414440	this is going to be consistent throughout here, is the nanoseconds, microseconds and milliseconds
1414440	1423000	framing. I will tell you this. So what it will do here is making sure that passing code preserves
1423080	1429400	nanoseconds can have a big effect. Or he says, I assiduously counted microseconds when it mattered.
1429400	1436280	Nanoseconds were way beyond anything I could imagine. And so then Casey kind of questions,
1436280	1441320	is a case of like, it sounds like most software that Casey actually uses and so with myself would
1441320	1445640	when nanoseconds actually matter. In other words, Visual Studio, LLVM, GCC, Microsoft Word,
1445640	1450120	PowerPoint, Excel, Firefox, Chrome, FFMPEG, there's a type of that, but TensorFlow, Linux,
1450200	1456440	Windows, macOS, all of these. And Martin goes again, Mr. Martin goes like, oh, not exactly,
1456440	1460600	rather my experience abroad, and does all the stuff. And then talks about this other applications
1460600	1463800	we have modules in the millisecond range. And he says, sort of these time ranges.
1464760	1469960	It's very like, he's trying to get the reader, because he knows people reading this, to think
1469960	1473640	about it, well, most problems are in there at ranges of milliseconds. So we can worry about
1473640	1477480	nanoseconds. Most people aren't have to worry about the automizer nanoseconds. But it's like,
1478120	1483480	you know, death by 1000 cuts, and 1000 milliseconds is a microsecond, 1000 microseconds is a
1483480	1489880	millisecond. So if you do things 1000 times badly, and you can, you've now gotten to the other
1489880	1497240	domain into the other module, as he was calling this, the time module. Okay, fine by me, not
1497240	1502360	necessarily criticizing that way of thinking, but it's a very weird framing, which,
1502920	1508200	like, even if I read here, so for example, I'm currently working on an application in which
1508200	1512680	the vast majority of modules work well at the millisecond level, but a require a 20 x per
1512680	1516600	better performance. My strategy has been to write the millisecond modules in closure,
1516600	1520440	because while slow, which is very convenient language, the microsecond modules I wrote in
1520440	1524520	Java, which were much more faster, more convenient, far less convenient. So it's like, okay, so if
1524520	1529240	I use them all like Java, it's easier, it's much less convenient, but I can write faster code,
1529800	1533720	compared to closure, which is, I write code quicker, but it's not going to be as
1533720	1537240	powerful as that. And those bits, these mergers again, because closure and Java both work on the
1537240	1543240	JVM, so they can interact with each other pretty easily, ish. But he's just talking about the other
1543240	1550600	things here. Now, one thing I found interesting is this slash here. You'll see in a minute,
1551560	1555080	right, he only wrote a book, and he said, oh, I wrote a book on clean code, don't you know?
1555640	1559960	I've only focused on the millisecond side of the problem, not the nanosecond. It's like,
1559960	1565320	well, I'm not walking about the performance of the code anymore. But like Casey just goes
1565320	1569560	town on the question. So Bob answers a very short question, milliseconds, of course.
1571480	1576520	And then he answers again. Now, he might be asking, wait, why is he answered twice?
1576520	1581960	Well, he went back in history and added some code text. He rewrote history. Yeah.
1582280	1588440	I'll say no more. But yeah, he keeps going on about this, and it's very interesting. So now
1588440	1592680	here's another problem he kind of talks about. And he talks about the actual he says he's now
1592680	1596600	actually finished watching the video, because he didn't actually watch the video when he started
1596600	1600200	discussing with the only watch the first bit of it until I've got enough of this. It's like,
1600200	1604840	you're not going to have discussion with someone you've not even watched the entirety of but you
1604840	1609480	think you're confident, you know, you can talk about it. I'm like, interesting. If you're that
1609480	1615160	confident, it usually means you're not actually talking about the thing itself.
1618280	1623400	Yeah. Yeah. But he says, you notice a nice little pattern. I love that basic form of
1623400	1627240	the like some coefficient times the length times the width. And in those moments, I only think
1627240	1631560	programs and mathematicians mathematicians can truly appreciate. It's like, oh, yeah, yeah,
1631560	1637640	like that was fine. Isn't that lovely? And that's fine, whatever. But Casey comes up,
1637640	1640760	okay, that sounds great. I think we've gotten to the same page because he was actually talking about
1641480	1646600	this, not this. Because he says, I've just finished watching it. So I'm going to add this bit back
1646600	1653640	in to make it split it up. Again, take it as you wish. What I'm trying to say is above paragraphs,
1653640	1657320	above the box, and there's just like, look, Casey has read and looked a lot of it. Like,
1657320	1661000	what you're talking about, he seems like these nanoseconds even matter, like everything seems
1661000	1665960	to be nanoseconds modules, which he says, like, all this makes no sense. And then he again,
1665960	1669560	he replies with, well, I'm one of the signatories of the agile manifesto who still believes to be
1669560	1677880	a bit up front of architecture design. Okay, why bring that up? Sure, but fine. This is the
1677880	1681480	bottom line, of course, is that single factor analysis is always suboptimal. There's no one
1681480	1684920	true way point. I've always made several times in clean code. And it's like,
1686600	1690280	but they may not be one true way, but you do kind of suggest there's a default you should go to.
1690360	1701240	And there are arguments for that. Okay. Casey has a lot of questions to ask already,
1701240	1704920	all of this. Again, I recommend watching this. Now, Casey says here is like, I watched a multi
1704920	1710120	part series at six parts six, and it's like nine hours he watched, not once in that one second
1710120	1714520	of it of that nine hours was in to go to get towards performance. And again, Mr. Martin says
1714520	1718760	it's fair criticism, absolutely fine, no problems. But again, I'm just going to show you here,
1718760	1722440	it's like, yeah, so thank you for the nudge kind of thing. Like, oh, next time I'll do,
1722440	1726760	I'll put a nudge in towards performance. It's like, been doing this for decades.
1729800	1732920	Hmm. Okay, so clearly you don't see, like, but like,
1734360	1737240	he's kind of butchering up trying to be polite or like, as you would, like you're trying to be a
1737240	1740520	conversation light always be polite someone as well and try and be nice and kind to a certain
1740520	1746520	extent, maybe always nice, but kind at least kind. But yeah, it's always kind of those kind of things
1746520	1752440	and after some reflection, blah, blah, blah. I'm just trying to go through over this again.
1753320	1756120	This is like, it's fine, not just all the conversation again, it's a lovely conversation
1756120	1758920	between two people trying to be just being honest between each other, not being horrible.
1760760	1764840	Casey was also showing off this video, which if I believe it's correct, he was just kind of
1764840	1769080	they were just joking about how slow is right GitHub, literally intent of just slowing down
1769080	1773960	along with the paragraph God. And they actually found after a while, why this was the case.
1774840	1780120	The thing they found out was that it was the code was looking back to the beginning of the
1780120	1783720	paragraph, looking for a colon, if it found a colon, and it was near the beginning,
1784360	1791240	it was going to then expand this to be a emoji. That was what the bug that think the slowness was.
1791240	1795560	So if you just, as Bob made his joke, like, oh, if I just replace everything, the spaces with
1795560	1799880	the colons is instant, there's no slowdown because it's found the colon, found it's not an emoji
1799880	1804200	and doesn't do the search anymore. And that's how slow, like, even though they were talking
1804200	1807960	about the complaining like slow codes, like, look how dumb this algorithm was in the web
1807960	1811560	browser. And it's just trying to do this. Now, one little thing I found a bit weird,
1811560	1815960	he says, I created this using going vi and I use this like replacement thing, because really,
1815960	1823560	I'm an old C hacker at heart. I'm like, what? What does that even mean? This just seems like a,
1823560	1829640	I'm an old C hacker at heart. I'm like, this has this is one, this is just, you're like vi or
1829720	1834920	vim or whatever you want to stuff. And then you've just done a regex for text replacement. And
1837160	1841160	this has nothing to do with C. I know what he's trying to say. Oh, it's just really low level
1841160	1846840	I'm doing all this. I'm like, what? Sorry, we just need one of those things like the what?
1847800	1851400	Right, kind of bit interesting here. So then there's the again, recommend if you want to
1851400	1853800	read the links in the bar for all this. So you don't I'm not trying to read the
1853800	1858600	descriptions here. I'm just trying to go over it. So now they figured out the things,
1858680	1862200	the slowness of GitHub, they've gone gone back pivoting up back to this talking about the stuff
1862200	1868120	about clean code again, capital C, capital trademarked, and explaining all that. And
1869000	1872680	some of the weird things like for instance, the descriptive names things, like,
1873640	1877960	I think everybody agrees with the descriptive names. This is not clean code exclusive to clean
1877960	1886040	code tests. This is one where he's more of a test driven development, while cases more of a,
1886040	1890600	it's more of a how they do frame it later on. In fact, I think Mr. Martin rephrases this quite
1890600	1896360	well, that he prefers like why you should write a test if you don't see a reason not to. And cases
1896360	1900280	more in the camp, I write a test when I need a reason to kind of thing. And they're just
1900280	1904200	they're not bad. One's more test driven. One's more of a, like a more of a base of regression
1904200	1908440	kind of thing or like other testing is more of a, I'll write tests when I need to because
1908440	1913800	I do have tests in general, it's just not a like unit tests or general tests of everything
1913800	1918840	code coverage and all that lot. It's a different thing. I'm not going to criticize test driven
1918840	1922200	development because it's not necessarily bad in certain domains, but in certain other domains,
1922200	1928200	it's kind of like not it seems like you're writing more tests than the actual code,
1928200	1933960	which is not necessarily productive. But whatever, or useful and as many things in here,
1935000	1938600	yes, it says like, look, cases, I do test as well. But then again, here's the difference he
1938600	1941800	writes. So Mr. Martin says, I appreciate tests, unless there's a good reason to this and Mr.
1941800	1946120	Martin and Casey write tests when there is no good reason to when there's a good reason to.
1946120	1951160	So it's kind of a different distinction here. Now he actually starts quoting again from his
1951160	1956840	book talking about this and he and he kind of distinguishes between the operand primal and
1958360	1962920	operation primal he's calling here. So it's kind of the difference between I'm going to call operands
1964040	1968920	operands variance in this case, because it's a variance and operation. So they're not using
1968920	1972520	the same hoe gets a little confusing for me. So now they're kind of talking about the different
1972520	1977640	benefits of using one of these two things. And great stuff here. But then there's one other
1977640	1982920	term that he brings up in here, which is dependencies. And he's using this in a very,
1984600	1990760	not the way that most people would use the term dependencies. So a good example of this would
1990760	1995800	be is calling dependency inversion. So I'm just going to read right, I'm going to say what he's
1995800	2001720	written because it's, I'm not going to paraphrase it very well if I don't, it says here, that would
2001720	2007400	be the bottom line if there was one other thing, okay, about dependencies, the cases of switch
2007400	2013080	statements create an outbound network of dependencies towards lower level modules and
2013080	2017160	modules in this case, he's talking about like timing and such like that, that kind of module
2017160	2022760	in this context. Yeah, each case may call to out to these other modules making the fan out of the
2022840	2027480	switch statement very high. So he's trying to argue against switch statements and trying to say, look,
2028120	2031800	if you go for the more polymorphic approach, like the inheritance base approach, we have like a v
2031800	2036360	table with sub typing, which is what I would class is inheritance to begin with any of the emergent
2036360	2041400	concept of those two things joined together. And he's saying this is going to be making it the fan
2041400	2047880	out of the switch and very high that this is going to be much bigger. Because it was caramel says
2047880	2052360	any change to one of these lower level modules can force the switch statement cases, which
2052360	2058280	statement the video, he's usually prefers the inheritance style not always, you'll get into
2058280	2063320	that can force switch statement and all higher level modules to depend on on that switch statement
2063320	2069000	to recompile and deploy it. That can be a very large cost. On the other hand, if one uses dynamic
2069000	2073480	polymorphism, object oriented, instead of a switch statement, then those compile time
2073480	2078520	dependencies are inverted. The lower level modules become sub types that depends on the
2078520	2082920	high level base type. And the source code depends is then point in the opposite direction of the
2082920	2089320	control flow. This is dependency inversion. It prevents changes at the low level modules from
2089320	2094040	forcing a wave of recompilation redeployment from sweeping through the system towards high level
2094040	2100600	modules. So this is just a really weird confusing terminology is just made up in a weird way. I'm
2100600	2105560	saying who has made it like no, he kind of actually has. I tried searching for this and it's like,
2105640	2109720	it's not consistent what people mean by that term. And also, when people talk about dependencies,
2109720	2114520	they usually mean like third party code, usually, or sometimes they talk about dependencies like,
2114520	2117640	Hey, what does it very dependent on the things like all the bits in the thing like he's talking
2117640	2125080	about modules, but that these concept of a module is much more like a class than a library. So it's
2125080	2131400	kind of a very more old fashioned approach before like libraries and packages and modules were more
2131400	2137240	like standardized in other languages, obviously, but whatever. This is why I'm going to confuse
2137240	2141880	because the argument he's trying to make. And this is the thing I would personally try to understand
2141880	2149400	as well is that between the the variance and the operations, the switch statement is closed to the
2149400	2154040	number of variants. But it's open to the number of operations. Like for instance, you can always
2154040	2159000	add more operations really easily. You just add a new function with another switch statement inside
2159000	2163400	of it. And you've now added a new operation to all of these different variants. Yeah.
2164840	2173480	Whilst the inheritance style is much more open to is more open to various operations this time. So
2173480	2177000	it's a closed set of operations, but open to numerous amount of different variants. This is
2177000	2181000	the whole point you have a base class and variants like subtyping from it, the whole point you have
2181000	2186040	subtypes or whatever, and it's more open that way. So it's a lot more useful to be doing.
2186840	2196280	If that makes any sense. Yeah, hopefully that's clear. So that's kind of the argument. Now my
2196280	2202360	point personal view is that which is getting talking in the thing here with the commentary
2202360	2205560	search is that the most the time you actually have a close set of variants, and usually you
2205560	2209640	want to add more operations in practice. So because if you've got a close set of variants,
2210440	2215720	why pretending as if it's completely open, which is what inheritance is for, it allows
2216360	2220920	everybody to add more variants, even if you don't have control of that capability, you just
2220920	2225560	extend to it and it's abstracted away. But most people within their own code base, like it's not
2225560	2231480	going to be used by third party people ever, usually, pretty much isn't. So you in that case,
2231480	2235560	it's very close set of opera, it's close at variance you have. And usually when you're
2235560	2237960	modifying code, you actually want to add more operations. It's kind of like a
2238760	2241320	different thing. And they're solving different problems. You have to understand this. It's just
2241320	2248680	that the weird oddity here is their argument is actually, you know, the, the, the inherent style
2248680	2252920	approach, which has all of the operations for each variant bundled with that variant,
2253960	2257800	it's easier to manage. And the going on about like managing all these different
2257800	2260600	dependencies and talking about how many different places you have to deal with.
2260600	2264040	In case you just correctly point out like, Hey, it's just a different win in different ways,
2264120	2269320	like this independence in version thing, is you're just trying to get complexity. And again,
2269320	2274120	Mr. Martin says, yeah, like for every program composed of O operations and T types has complexity
2274120	2279960	of O times T. If we use O, we can cruise T with minimal disruption to increasing O and vice versa.
2279960	2283080	Well, it's like the switch same as you have increased operations within disruption, but
2284040	2288200	disrupts source code. Now, I don't think this is true. I don't think the disruption is actually
2288200	2297000	even equivalent because it's weird. I know we shouldn't be talking about much about this is
2297000	2304280	not really clean code anymore, but it kind of is related to it. It's just the, but practically,
2304280	2307560	how would you know which one is more true the case? In my opinion, personal experience, we've
2307560	2311480	always had a close set of variants. Like if you want to have a new one, fine. But that variant
2311480	2315960	doesn't really like, okay, we got updated every single place. Now I use Odin. So my switch statements
2315960	2321080	will yell at me if I'm missing a case by default. It says, Oh, you've not handled this particular
2321080	2325640	operation for this particular variant, like in this particular case. And I just need to handle it.
2325640	2329640	Okay, great. That's just better. I know C and C++ and summer languages don't do this by default,
2329640	2333640	but Odin does. So clearly, that's just a better language can solve those problems. It's not really
2333640	2339880	a or better tooling in general. It's not really a inherent thing. It's just a tooling problem then.
2340600	2345880	But then this is where it gets a bit weird. He starts breaking things down to source code
2345880	2351320	management about runtime source code dependency inversion, and just make some terms up which
2351320	2356360	are not colloquially understood to be meant in that context. But again, it's the right a lot of text.
2358520	2362120	Try and make people understand how he thinks. And then Casey just write small amounts.
2363000	2366680	It's the it is a very big politician thing pad it out. Very good rhetoric. I mean,
2366680	2371560	he's great at this. This is where I'm praising him, by the way. So again, read it for yourself,
2371560	2375000	make your own opinion. If you disagree with me tip can tell me in the comments below.
2375000	2378600	Tell me where I'm wrong. Please tell me where I'm mischaracterizing me. If I'm being too harsh,
2378600	2384600	if I'm not being harsh enough, if I might work, look, I'm not even it's fine. But he then it is fine,
2384600	2387320	like just just read it. He's talking about these different things here, like he's
2387320	2391240	procedural, so it's itself statements, which statements, whatever. And he's calling this a
2391240	2394680	run time to high run time dependency, when actually, no, we're gonna make this compile time
2394680	2399400	dispensary when it's on the type site. No, you just switched them around. They're both the same.
2400120	2401000	So yeah.
2407320	2413160	So one thing he brings up here, which I thought was interesting. And it through this bit, as well
2413160	2417480	as the second part, these starts up, I'll explain why he does that in a minute. He brings up, I
2417480	2424280	would call the canonical case for inheritance. So the canonical case of inheritance is the
2424280	2429880	data stream. So sorry, if I've been a bit rambling all day, I'm just trying to understand it because
2429880	2435400	it is weirdly flowing as well. Like the actual thing isn't like, it's a weird discussion. But so
2435400	2439080	I apologize for that and also apologize for my rambling as well. So hopefully that's okay. But
2439080	2444760	again, should be all clarified here. Here he does the canonical case for inheritance, which is
2444760	2449960	literally a stream, a data stream, a file or something like that, and explains that Oh, these
2450040	2454840	have standard operations, a close set of operations like open, close, read, write, and seek. Again,
2454840	2458200	these are the five standard functions of the Unix IO driver. And again, these are very
2458200	2463720	standard functions on all operating systems. So they actually map really well to the
2463720	2467880	inheritance style of doing things, the very dynamic polymorphism is he's referring it to here,
2467880	2475640	which is, yeah, it's dynamic dispatch. Subtype polymorphism with v tables. Yeah,
2475640	2479320	that's what it is. But he's calling it dynamic polymorphism, which is not common term, but he's
2479320	2484600	whatever is using his own terminology as he needs. But it's saying like, okay, we've got a
2484600	2487640	closed set of operations, but we have so many different things like files could be anything,
2487640	2491560	they could be a file, it could be a directory, they could be a piece of hardware on your device,
2491560	2495720	they could be just a general socket, there could be anything. It's like, it's open to be whatever
2495720	2502760	it could be. This is literally the canonical case. Why is the canonical case? Because operating
2502760	2508440	systems make these files an object. They are an object. That's what they have. Like they're an
2508440	2513640	abstracted away opaque thing with a open like close interface as to what they are.
2515720	2521000	So he's trying to argue like this is what you meant to do. Now, there's a lovely lovely thing
2521000	2524280	here is saying like, well, this clearly has to be a thing. And that's why he's trying to get down
2524280	2528760	this route. He's trying to take the canonical case to show to Casey that hey, you need inheritance
2528760	2533240	sometimes. And this is the great way. He's completely forgot the conversation is talking
2533240	2538840	about clean code, which will bite him in the book later to use an American phrase later.
2541240	2546600	But then there's one this weird thing he does here, where all of a sudden he talks about this
2546600	2554120	hypothetical compiler, which would be able to you could write in the in the oopy stage,
2554120	2560280	like an inheritance style, and then completely the compiler would magically make this be a
2560280	2563400	switch statement if necessary, which is kind of interesting because it's like,
2565000	2568120	what what benefits would you get from that? Because it seems to be now a textual benefit.
2568120	2571080	It's like, you're talking about, oh, it's all clumped together. A new variant or you know,
2571080	2576360	like, but you've some weird things. He just says it's just a really weird hypothetical
2576360	2580920	scenario just kind of goes into. And they go on for this for a little while. And Casey's like,
2580920	2583640	I don't understand what you're talking about. Like this doesn't make no difference,
2584600	2590280	even with this hypothetical case. So Casey goes on a bit more further here, just mentoring
2590280	2594760	different things. And talk, I try to get what the benefit of dependency inversion is anyway,
2594760	2599880	and to begin with. And the go on about this, like, look, you've got a clothes interface with opaque
2599880	2604600	stuff, and different ways of dealing with it. And then we talk about this payroll thing that
2604600	2607880	they do all these different things. I recommend reading it. But it is going to be this.
2609880	2613560	Like this is an oopy thing, obviously, you've just defined it to be because it is is defined
2613640	2621240	to be oopy, sorry. Yeah, okay. Yeah, yeah, yeah, yeah. But again, Casey also kind of says it
2621240	2625080	could just be sound line functions. There's no reason, whatever, whatever, that's not a problem.
2625080	2628520	Where am I looking for now? I'm sorry, I'm just trying to skip through this because it just goes
2628520	2636280	on for quite a while. Okay, so Casey says that hypothetically, you could just not do this and
2636280	2640840	have it just a union. Because in the example that Casey does when he does the union, the shapes
2640840	2646600	example in the video is, is this actually a union? It's what I would call a fat struct union or an
2646600	2649880	open open union where it has a variant and then just open fields. So it's kind of like a table
2649880	2657240	like thing, a fat struct is a term that's Ryan Flurry kind of popularized. And it's kind of
2657240	2661720	just like, here's a table of data, all the fields available. But hey, how you can just switch on
2661720	2665160	it like all this and just do whatever you need to do and just access the data when necessary.
2665160	2669000	In case you're saying, look, hypothetically, you could do this, you could just have a file type
2669000	2673400	with all the data that responds to this in this union and deal with it. Because in practice,
2673400	2677720	there's actually only a certain set of files you could have, you could even have the general case
2677720	2682120	where it's, it, it will be like a V table. Sometimes it won't use a V tail, but you can always
2682120	2687080	optimize off that. And there's many different things he's discussing here and such. And he's
2687080	2691720	talking about the union case. Now, Martin, Mr. Martin goes here and says, look, it seems like
2691720	2696520	come on, come on, wild up at the agreement on just about everything other than per individual
2696600	2701480	preference. And it's like, no, he's trying to say, look, but we don't disagree. It's like,
2701480	2705480	actually, why are you having this conversation? If you don't disagree, you clearly do actually.
2705480	2710600	And you'll show this later on in part two of this written document. And he says,
2710600	2713320	thank you for the union collaboration. Now I understand what you're talking about unions,
2713320	2718280	which is like, okay. And he says, I'll quibble you a bit on the difference between operand
2718280	2721960	and operation, but I don't think the quibble is particularly important. In the end, it's just
2721960	2726680	all functions regardless of how you spell it. As for human issue, performance is a human issue.
2726680	2730760	The computer doesn't know how fast or slow an algorithm runs, but I think that that horse is
2730760	2737400	dead now. And it's like, no, it isn't. This is kind of the point. And he goes back to his
2737400	2742600	microseconds, different module things again. And then he then goes, look, we put a break in here
2742600	2747640	to write extra bit more to go rewrite history and says, look, I'm going to continue us now in the
2747640	2755320	second document, which is the number two. Because he's trying to like make break here,
2755320	2759240	and then reframe the entire question in the second document, it's a pivot and a reframe
2759240	2763960	at the same time, clever rhetoric trick. If you want to do that in an argument, you do that all
2763960	2766920	the time, you reframe the question. So it's now they're not even talking about the original thing
2766920	2771400	again. And he's tried to do this. So that's what he's done here. Right. So right at the beginning.
2773000	2776520	And then Casey's reframed it and put it put it into the beginning. So he's first. So Casey
2776520	2784920	knew what he was doing. So just don't let's not do that, shall we? Yeah. So Casey wasn't stupid.
2786920	2790440	He's talking about all this goes back to the payroll example with all this kind of thing.
2791080	2796680	And Casey's trying to say is like, look, this is not an open problem. You haven't got an open set
2796680	2804840	of variants. It seems like it's an extremely well defined problem. So why does this need to be like
2804920	2811880	operand, operand, primal design was in like variant open, rather than variant closed. And then
2811880	2816440	operation open. So this seems to be both closed. Like it's very weird. Like what, what are you
2816440	2819880	trying to have in like save developer cycles with like, where's this kind of thing coming from?
2822040	2828760	And then this has been moved to because he reframed it. It's fine. No problems. He's talking
2828760	2833960	about the programmer cycles thing. This is the thing he gave this random file he added in here,
2834600	2838280	which is the, oh, great. Let's do a code golf example, shall we?
2845000	2847880	Cute surprise. It's like the point is the program cycles, waste management,
2847880	2850760	programming cycles, it's like, yeah, you just gave me a code golf example.
2851560	2855720	The worst case of readability possible, like, but it's a code golf. That's the whole point.
2855720	2858920	People write those things to be compact and human. Like that's what you're trying to say.
2858920	2862040	Like we're trying to make it easier on like, can you prove my belief not mathematically,
2862040	2866200	just as I'm sure that you cannot mathematically prove that your favorite style saves more or
2866200	2870840	less programmer cycles than mine. It's like, so he's already admitting that actually you
2870840	2875560	can't prove my style is worse than yours style. And it's like, because programmer cycles, like
2875560	2880760	this is a qualitative thing. He knows he can't measure it. She's actually, I don't think that's
2880760	2883720	true to be honest with you. It's just that no one's really bothered to do the science because
2884600	2889560	programming isn't really young discipline or 70 years at best really as a discipline. So it has
2889560	2893800	no evolutionary like pressure on there yet to say which which things are good or bad. So people
2893800	2898680	just say random things. So it is literally just like, great, there's not really much science in
2898680	2903080	computer science. Rather, again, I'm glad the rest of the world calls it informatics for a reason.
2903640	2906840	I don't know why we don't we call it computer science, even though it's not an empirical
2906840	2911320	science and it's close to mathematics, but even then it's not really in practice is close to
2911320	2917560	engineering. It's just confusing term. Okay, confusing term. The dynamic was a dynamic
2917560	2921480	building and other type of just from typos, whatever I make more than this might be in day
2921480	2927160	to day life. And he's talking about this. So it says, do we agree so far about this? And it's like
2932040	2935240	cases kind of like, well, we don't just worry about certain things in the general like in
2935240	2938920	the specific, I'm still asking the same question about this data stream thing you're talking about.
2939800	2946520	Then Mr. Martin brings up again, the like, hey, here's something like the read write thing for a
2946520	2953000	C. These helper functions don't you know to do all the stuff? It's like, but if you had to do it in
2953000	2957320	your case, we'd have to do a switch statement like this wouldn't we don't you know? Oh, it's like,
2958120	2961960	look at all the different variations you could hypothetically do this just ugly. Don't you know
2961960	2967320	it's ugly? By the way, if you this is, this is gonna tangent anyway, I've been writing the
2967320	2971800	Odin core library and you actually have to do this anyway. Like if you actually have to do like
2971800	2976680	you do the read at the OS read functions, because the console on Windows at least does not act
2976680	2982600	like a normal file. In fact, the console on Windows is a UTF 16 document. So that means you have to
2982600	2988920	write UTF 16 files. If you actually write a UTFT thing to it, you then you have to do a conversion
2988920	2992120	to do it onto those. It's actually like already or you have to do this edge case. And not just that
2992120	2999080	the console has other things in it, which are not handled the same as an old file again. So it's a
2999080	3006520	very kind of have to do this. This is how real world code is not even purely like, oh, the operating
3006520	3010680	system has dealt this properly. It's like, no, I still have to check if it's a console specifically
3010680	3017800	and then deal with it. So it's like, I know like, this is not working. Like, yeah, it actually looks
3017800	3024360	closer to this in real life, even with the, the abstraction on top of what a file is, but I digress.
3024680	3032600	Yeah. But yeah, it's just interesting. And then again, many different breaks can different edits
3032600	3036520	here different sections is breaking it up. The VTab we use by Unix, again, most operating systems
3036520	3041480	do this as well. Things change around significantly. The idos can be loaded at any time, the iodevice,
3041480	3046200	yeah, that's true. That's took in this details we're talking about. He's talking about code reuse,
3046200	3050040	great example says the cases. I apologize for trying to be very specific, but I really want to be
3050040	3054120	actually get to the exact proposal. And it wasn't clear from what could you actually tell me what
3054120	3057880	the OS interface looks like and how it's implemented. You said, I guess that depends on a lot on
3057880	3062360	the language and the application. But my understanding is that we're talking about the OS side. So, and
3062360	3068120	again, it's the, how does the OS implement this, like the, the stream, the file, compared to how
3068120	3072600	we're doing it in a language is very different. And not just that, again, I thought we were talking
3072600	3079800	about clean code. But why has it gone down this digression? Just you wait. Let's go get that. Don't
3079800	3085640	worry. Okay, we're talking about get all crap. Okay, because it just changed. That's, I can probably
3085640	3090120	guess which day this was written on as well. Like you're saying it seems like it looks like this
3090120	3095400	somewhere. Is it actually a base class? Is it whatever? Now, Mr. Martin says, okay, here's kind
3095400	3099960	of the general interface that he's writing C++. Again, he's not answering the question he's asked.
3099960	3109560	He's done another thing. Whatever, kind of missed the point again. And then he's saying, look,
3109640	3113640	look, if we look at the, he's trying to say this is less like the code is easy to manage whatever.
3113640	3117960	Like, yeah, but you've just chosen the canonical example. And he says, look, if I do the dynamic
3117960	3123320	polymorphism case, so inheritance, I create, I create this file of three files and have to leave
3123320	3127240	them with a switch case. I've now all of this and look at all these different things I have to define.
3127240	3133000	I'm like, and cases, well, hold on, since I'm the switch proponent, at least I get to write it,
3133000	3137640	please. Look again, look what he's just done. He says, well, I've just shown you how to do it.
3137640	3141320	And look, it's just more complicated. I've had to write files. Oh, no, I'm like cases like,
3142760	3150440	hold on, hold on. Yeah, and it's kind of doing like this. So it goes on and on,
3150440	3153640	we just discuss things, but it's like cases like I want to know what the operating system again.
3156040	3159800	And it's different. Okay. And then cases like we're not even talking about machine cycles again,
3159800	3163720	I'm just focusing on the program cycles again, what like he's doing again. So I'm like paraphrasing
3163720	3169720	this poorly ish, but it's kind of just like, I'm trying to show the techniques that he's doing here
3169720	3175480	that he knows he's doing it. He isn't an idiot. I'm trying to be very careful like this. Mr.
3175480	3179400	Martin knows exactly what he's doing. Like he's now just made another document on here,
3179400	3184120	which only he talks about. And it's just he's trying to suggest like, oh, this is the clean code
3184120	3189320	stuff. And then he's saying this is what clean code is. And I've just got the summation seems
3189400	3194200	to correlate with what I most people think it is. Because I miss people people keep this understanding
3194200	3199720	me kind of view. And it's like, wait a minute. So choose carefully names, not unique. Keep function
3199720	3206040	small. Why keep classes small. Why manage your dependencies, vague as anything. Literally,
3206040	3212920	be careful with side effects. Okay. Yeah, express yourself in code where possible. How else you
3212920	3217560	meant to express yourself in code away? It's your programming. Use polymorphers when the type
3217560	3221800	changes fast in the operations. This is new stuff he's added now. You switched when operating
3221800	3230920	change fast in the types. Why? Why? And at what cost? And what Harvard evidence have you got?
3230920	3237720	This is better. And like, you compare it to this and like, you sure? Okay, when possible,
3237720	3244840	create designs where things that can change fast that change fast are types. Why keep asking this
3244840	3250200	question? Here's in his even in his summarizations of here, he's actually saying, we'll prefer
3250200	3255480	polymorphism. So now he's in like, well, I don't see how you got to that conclusion where like,
3255480	3259640	I'm against switch tamers or something. I'll clear and prefer like default before like all this
3259640	3266120	and like, you're literally saying it in here in this summarized document. If I'm misinterpreting
3266120	3272200	it, please tell me again, in the comments or something. I'm just really confused. Like, what?
3272760	3279560	Right. So Casey comes back again, and he's talking about the internals of this. It's like, okay,
3279560	3283640	find the device, then you read it and you do this. This is how ring versions, if you understand how
3283640	3289480	they work internally. Okay, great. There's class, here's the operations. And it's that looks,
3289480	3293240	you can always do it this way around. And look, I've got a different way of doing it. So just a
3293240	3299320	union based approach now, with all the data inside of it doing all what we need, whatever.
3299640	3305240	And that thing that's just is actually trying to show the actual things internally, isn't
3305240	3310040	it? But yeah, it's kind of like, look, now I don't like vtables, because obviously pretty
3310040	3314520	much everywhere, because I find them hard to control. So I prefer this. So he says, look,
3314520	3320920	I have a, not a vtable, but just inline things itself, it's not a table, just inline functions.
3320920	3326920	So instead of a class, you've now just got inline methods. And this is just general handling
3327480	3331560	thing, which is interesting. By the way, that should be more better for performance in general,
3331560	3336520	because a vtable is usually a pointer to a structure of a function tape, like function pointers,
3337160	3340440	whilst if you're embedding the function pointers, you've got rid of that indirection. So you've
3340440	3344040	actually got it will be faster in general as well, because you've got rid of the indirection.
3344040	3349320	It always has a better chance to optimize and even it has slightly better chance of inlining
3349320	3355560	and slightly. But yeah, that's how compilers work. Sorry, rambling again, again. But I'm
3355560	3358680	getting off the digression. But cases kind of saying like, look, we could just handle it for
3358680	3364040	each of them that we could actually have one callback, just one, and we could directly embed
3364040	3369320	it in the structure. So it's not even in directed anymore. And then we switch on this. Now this is
3369320	3373800	interesting. You could do it for every single operation. And then look the codes in one place
3373800	3380360	for this thing. We've now got the best of both worlds in many ways. And why wouldn't you prefer
3380360	3386600	this way? I think now interestingly, I'm just going to like slightly digression here going into
3386600	3391480	Odin. And this is what we actually do for the allocator. And I've been doing this for like a
3391480	3399720	decade, maybe even before Odin. There is the thing sorry, apologize for the digression. This is
3399720	3404840	clearly unscripted if you didn't guess. Here's the allocator. So we know that we have a built in
3404840	3408280	concept from an allocator and allocator is just a little data structure with a pointer to a procedure
3409000	3414920	and appointed to the data. So 16 bytes, you can easily copy this around. So it's usually not
3414920	3418520	even appointed to the allocator, it's just the allocator itself in memory. And you just get the
3418520	3422600	values. So that's what you're doing. So there's not an indirection again, because it has to be a
3422600	3426200	pointer. And notice it's just in line with the function. And not just there's only one function
3426200	3429560	you think, but there's loads of different allocation operations like yes, it's one function,
3429560	3433960	you take all the arguments in, and you change the allocation mode is an allocation alloc free,
3433960	3437640	free or resize query features query and for an alloc non zero. Because sometimes you want to be
3437640	3442040	allocated without a zero, but by default you want zeroed because it's quite useful. And also it's
3442040	3446360	pretty much free if you're using like virtual memory, like allocating zero memory is pretty much
3446360	3451480	free. Because it has to be for security benefits. There's no option to not get it if you ask for
3451480	3457080	virtual memory. So I'm just trying to show here that I already take advantage of this kind of
3457080	3461320	approach. And then within every single allocator, I have a switch statement which then pairs each
3461320	3466120	operation together. So I'm just trying to get off my digression a bit here. So this is what case
3466120	3469800	is kind of trying to say and you could do this. So you're not having the full on inheritance style,
3469800	3473560	you just have a switch you could do the blend of the two. And there are benefits to this,
3473560	3479160	obviously. And you'd have all of this lovely. So because in either case, but this is larger
3479160	3483320	rather than because it's solely look look up map look up now and to a specific device and it can
3483320	3487480	be used in either design. Anyway, over the course of the development of the OS, I think the implementation
3487480	3492040	saves programmers and cycles potentially a lot of them compared to the one I understand believed
3492040	3498120	you favored by the clean code method. Again, which is interesting because the casey one is
3498120	3502840	closer to being like, sub typing to a sentence, but there isn't sub typing, it's just like,
3502840	3508200	here's the abstract thing with a function pointer, deal with it. Which is kind of close to inheritance,
3508200	3512760	but it's not just one. And it sounds like a minor difference people say, oh, it's equivalent. It's
3512760	3518040	like, but it isn't equivalent. In fact, it will be faster. You can easily measure it. It'll be easier
3518040	3521880	to maintain because everything's in there. And not just that, if you add a new operation into
3521880	3524920	there, every single one will just yell at you anyway, because you've not implemented it.
3526280	3529960	So if you've got a language that tells you that switch name is not necessarily C or C++,
3529960	3535480	maybe modern C++, I know, I think. And sometimes C with the, when you have warnings all and
3535480	3538360	everything will tell you switch name is missing certain cases. But yeah.
3541160	3544040	And cases look, I don't know if it's a bit of an extract and file, because I'm sick,
3544040	3547080	but it was the first one you brought up. And it happened to be the contrast,
3547080	3550760	the two designs in my opinion. So it works, works for me as Casey is saying here.
3551960	3557800	Here's why I think an enum based design deserves the programmer cycles. In most systems, you don't
3557800	3561560	know all the functions that are going to be used ahead of time when operating costs are hard boundary,
3561560	3565480	like a driver, using operation codes instead of virtual function calls allows you to add more
3565480	3571080	functions dynamically without recompiling all our drivers. In any modern operating system,
3571080	3574520	multi-threading is a concern. But this is especially true for an operating system,
3574520	3580200	having the protocol be structured based with an operation code allows us to trivially buffer
3580200	3587320	operations in things like IO rings and other intermediaries, intermediaries, without writing
3587320	3592680	any new code. The entire system remains identical. Yeah, I'm just trying to do this. And you just
3592680	3596920	said, this is by the way, it seems like almost happens in almost all systems, OOP systems,
3596920	3601640	I see, I'm trying to get around pronunciation, say, because eventually they need to serialize
3601720	3607880	or something similar. And so they have to write my version as well as the version as their version,
3607880	3610840	but they don't seem to realize how much time they're wasting. Like, yeah, this is
3611720	3616280	clarifying this point. People think this seems like the clean code will actually save time,
3616280	3618760	but it's actually no, you're now forcing another person to write the same thing again.
3619400	3622920	And you are actually wasting time, you think you're saving things. But again,
3622920	3626440	if you want to know if you're saving time, you're making a statement like this will save
3626520	3631240	programmer cycles, like a claim, show the evidence. And don't just say, well,
3631240	3637320	my your seniors may agree with me, because they were convinced by my argument. It's like, yeah,
3637320	3641800	but where's the evidence, regardless of this authority, this later argument by authority.
3643000	3647720	It is the after a while, many people will come out the phase and like, oh, I don't do this
3647720	3652360	anyway. But some people don't. And it's like, okay, I never really went through the OOP phase
3652360	3655960	myself. Going a bit of a digression here. Sorry, this is completely random today. I know.
3656680	3663320	Very, very unstructured. But I went through the modern C++ like 11 phase. So that's what
3663320	3669640	12 years ago now, probably a bit before actually, because it was C plus plus zero x for a long time.
3671720	3674760	And I remember learning all that stuff. And that was the thing I got caught. I wasn't really
3674760	3678840	necessarily the OOP phase. It was that phase. I was learning all that stuff. And it was a while
3678840	3683240	took me a few years and after was like, I'm doing all this extra code, writing loads, and I'm not
3683240	3687640	getting any more productive. In fact, it's how hard to maintain. I'm writing literally 10 times
3687640	3691320	more code than I needed. And they kept telling people kept people kept telling me because I was
3691320	3695160	kind of trusting these people who were more thought they were more experienced with me or
3695160	3697960	they thought they knew more because they've been doing it for longer. And they were talking from
3697960	3702840	positions of authority to a certain extent that they were going, Oh, of course.
3705080	3707960	Like, of course, this is going better because I'm telling you it's going to be better. I'm like,
3707960	3711240	and then I was kind of believing them. And I was like, it doesn't seem like I'm trusting them.
3711880	3715400	But it didn't it didn't seem to the case when I just started programming back to like a normal
3715400	3719480	basic C style with switch statements in many cases, and just like normal standalone functions,
3719480	3724280	no, not even using methods. I got more productive. My code got smaller, got easier to read,
3725160	3730440	just by not doing any of that. And it was kind of like not using not doing any of the stupid
3730440	3734360	templates, not doing stupid any of the ownership semantics. I'm not saying ownership semantics
3734360	3739240	stupid. I'm just saying the being everywhere was like, look, I just kind of went to more
3739240	3744760	pod data was a plain old data data kind of style old fashioned C style, my code just got
3744760	3749160	easier to read more maintainable and just everything like from a personal perspective,
3749160	3753800	again, I cannot measure this. And the only way I can convince people say, here's my code, here's
3753800	3758120	this normal code, which one define easier to read. And that's the only way that's not a measuring
3758120	3761880	that's just still like a personal preference thing in the day. This is the problem in these
3761880	3771720	discussions. And it is just getting down to that. It's like one side is there is an empirical
3771720	3776200	thing to a certain extent, which I'm going to comment right at the end. I will get to this,
3776200	3781800	don't worry. But he talks about this saying here at any point things, if we would like to
3781800	3784280	buy third parties to allow communication with channels on the devices, blah, blah, blah,
3784280	3788600	okay, we're talking about the IO stuff, fine. We're getting nearly getting the answers. So
3788600	3792520	Mr. Martin says, okay, I think I see where we're going. So let me say, sure, looks good to me,
3792520	3797640	the bullet points you added are after the fact are all quite valid. And the design you picks
3797640	3801480	works well in this case. In the first point, you assume that operations will increase beyond
3801480	3808200	the two original proposed, as we both agreed, as I wrote in the clean code, which, by the way,
3808200	3814280	is not the same as your clean code. Right, when operation periphery more rapidly type
3814280	3822120	switch statements are better. So there's that line alone is or another rhetoric trick,
3822120	3827080	lovely one, in fact, in my opinion. In the first point, you assume that operations will increase
3827080	3835560	beyond the two originally proposed. Okay, as we both agreed, I don't think Casey agreed to anything.
3836920	3840840	And secondly, Casey's not calling what he claims clean code, he's trying to understand
3840840	3846680	what your clean code is Casey never says his code is clean code, because yours is Mr. Martin's
3846680	3855400	clean code with a capital C trademark to kind of think. Yeah. So another little kind of trick he
3855400	3860760	does already any can't help himself really. So when operations profite more rapidly type switch
3860760	3864920	statements are better. In point two and three, you raise the specter of multi threatening,
3864920	3869400	you are of course correct that queuing operations is a lot easier. If you request packets of the
3869480	3874600	same type you design no argument there. And the last point proposed a kind of hook for unknown
3874600	3880120	and unspecified possibilities in the future. Yeah, so what he says is like, okay, you have the general
3880120	3884440	cases and then have a hook for the unknown cases like the open cases. Okay, if you think those
3884440	3888760	unknown cases and special are likely, then you should have considered them earlier. But then
3888760	3892840	that raises a number of other concerns that we should not likely address in this document. It's
3892840	3897720	like, no, no, no. So I think I'll let pass. No, why? Because if you didn't, he has to let that pass
3897720	3901880	because it then kind of defeats his point. Because the inheritance approach, which is
3901880	3906760	preferred by clean code, is saying that the open case is the open set of variants, the open set of
3906760	3912600	operands is the general case. It isn't. Because if you've got a close set, which you know, like
3912600	3917960	pretty much always know that 99% of the time 99.99% of the time is going to be
3921480	3925560	going to be closed, like pretty much going to be that small set. So you're optimizing for them.
3925560	3931080	And then you've got this, the unknown hook cases allow the user to add their own callbacks in there.
3931080	3936040	Fine. That's fine. But it says, it says, unlike to consider the head of time, it's like, yeah,
3936040	3941640	but you're assuming that those unknown cases are just as common as the known cases. And
3943480	3948840	that is actually designing the API. Now the thing is, if you're optimizing for the general case,
3948840	3953400	and then you allow a hook in, that hook is not going to be is not going to be any slower than
3953400	3959160	if you design it to be always a general case than the specific cases. That's the point he's
3959160	3964440	trying to say here. Like, that's why he's letting it pass, because it is literally just as fast
3965560	3968920	to do it that way, then to design it all the way around as if it was always unknown,
3969720	3975800	as if it was always dynamic polymorphism. Sorry, just say inheritance, be easier,
3975800	3982600	because technically what it is in this case. So now where are we? You propose a solution that
3982600	3986760	uses dynamic polymorphism, select two types, and then a switch same to select operations.
3986760	3991880	I have no problem with this. It works well and satisfies my concerns about dependency inversion.
3991880	3997240	I'm like, but it isn't the same kind of dynamic polymorphism that you've ever
3998120	4002840	recommended to anybody. So this isn't technically key and code. In fact, anybody who
4002840	4008200	would a clean code advocate would read Casey's code of, let me go back to it, this and go,
4008200	4015400	that's not clean. So this leads to the problem of clean code is whatever Mr. Martin says it is
4015400	4020280	at that moment. It's not like anyone could actually agree on what clean code is because
4020280	4023800	it changes from time to time. It's not a well-structured thing. And he's like, that's fine.
4023800	4029640	It's like, then why don't you just call it Mr. Martin style? Because it clearly doesn't work.
4030360	4034360	It's not clean. And it clearly doesn't work the way he wants it to in every single case.
4034360	4038280	But then you shouldn't do it like a dogmatic. And it's like, it's a weird trick. He says,
4038280	4043000	look, don't be dogmatic. Don't follow these the rules. But then it's like, well, I won't,
4043000	4046440	I don't agree with it anyway. Well, you clearly have some of these rules, don't you? It's like,
4047640	4053400	it's that clever trick again. It's the pork barrel naming again. It's the rhetoric over
4053400	4061240	rhetoric over again. I'm like, look, even if Mr. Martin style increased programmer cycles,
4061960	4067880	the decrease of wasted programmer cycles, like, whatever. Great. But how do you prove this is
4067880	4073560	the case? And we're getting to the end now, and we're just going to do here. So I'm going to
4073560	4076920	read the best of it. So, so Mr. Martin's your proposed solution time with thing blah, blah,
4076920	4080600	blah, blah. What do you got to this? I will say, however, that that is an ironic that after your
4080600	4084120	video and after all the stress that you have been put on saving machine cycles, you eventually
4084120	4089720	chose a design that sacrifices machine cycles to save programmer cycles. After all, on the OS side,
4091400	4096600	this is where he thinks he has won the argument. Ready? This is what he's tried. He's tried a trick.
4097480	4102120	He's tried to do it because he took the canonical case of a stream. After all, on the OS side,
4102120	4106920	you've you've got to package up all the quest packets and it's the dynamically dispatched
4106920	4112600	handler and then run the operation ID through a switch. And I think we wind up in the same place
4112600	4116520	when operations proflate more rapidly than tights, we both use switches, you don't,
4117160	4120440	you do not do this. I've read your code, your public code, you don't do this.
4121640	4126680	But he's saying he does just pretend you believe it. Okay. When tight for a plate more rapidly
4126680	4131160	than operations, we both use dynamic dispatch, we are both willing to sacrifice machine cycles to
4131160	4140120	save programmer cycles. No. Also the way again, how Casey structured it will be better because
4140120	4144840	it's not technically how many levels in direction do you have before like technically here has
4144840	4148440	one level of indirection, which is a function pointer compared to normal inheritance, which
4148440	4153320	is three levels of indirection. Why? You've got a pointer to the object, pointer to the vtable,
4153320	4162360	then a pointer to the function. Guess which one's going to be faster? Just have a hesitant guess.
4163400	4167480	Okay. And not just that, you've then have to go all through this indirection compared to having one,
4167480	4171800	which is probably going to be in the literally cash already in the cash ready to be called.
4171800	4176040	No problem. It's going to be easily predictable as well for the CPU. It's a very different thing,
4176680	4183400	very different operation that is to a generalized vtable. So no, they are not equivalent,
4183400	4187720	even in performance. One will be quicker than the other. I'm not doing this video. I could do
4187720	4190680	another video if you'd like, but like we could prove it, one's going to be quicker.
4191720	4197720	Single indirection compared to triple indirection. Okay. So when we are two individuals on the same
4197720	4203560	eye and the only difference being that I wear this shirt and I don't know how to pronounce that word
4204040	4206920	with clean code and you have one with clean code, I'm like,
4207720	4211800	thank you for simulating the debate. I appreciate your candor and the civility that you exercise to
4211800	4215480	and if, if not everywhere, I've come to experience your respect, your knowledge and blah, blah, blah,
4215480	4222680	blah, whatever. So the first thing is this is a really dodgy thing. Casey and even cases,
4222680	4227640	well, I disagree with most of that. But if we're ending here, I'll just finish my final responses
4227640	4235240	for Gail poster poster posterity. And that is the thing. See how he tried to end it. And I'm
4235240	4238520	going to read through Casey. I'm not going to comment on it now. I'm just going to read it for
4238520	4242200	the end of this video because we've already been going on too long. Sorry. So I apologize
4243000	4248360	for my rambling in between. I hope it's kind of an enjoyable if not, and I apologize again. So
4248360	4251320	I'm just going to read through this. I'm just going to read Casey stuff. This is all Casey,
4251320	4256760	not me. So regarding as I wrote in clean code, which by the way is not the same as your clean
4256760	4262840	code? Well, the point is of discussion was your you to elaborate on what is not the same. But
4262840	4267400	you're designed for the IO system looks exactly like my clean code example of virtual function
4267400	4273400	for every operation, one class per element in the system with no predication. So what are these
4273400	4278920	differences that you're referring to? Now would be the now would be the time to explain what they
4278920	4284600	are since that was the point of the concrete example. If these are a bad example for accelerators,
4284760	4290440	straighten the differences, that's fine. But it was the first one you gave to assumed that it would
4290440	4299480	be the one you want to use. Regarding when operations proliferate more rapidly than types,
4299480	4304440	switch teams are better. That was not the case here. In no way are operations proliferating
4304440	4310680	more rapidly than types in the system. Vendors will add drivers to the OS constantly, perhaps
4310760	4315240	monthly or even weekly, whereas the number of operations in a particular system tends to go
4315240	4320600	much more slowly, once every few months at a maximum, but more likely once a year for something like
4320600	4328520	the aniosis subsystem. It isn't the opposite of what you said. This is an important distinction,
4328520	4334280	because what I'm demonstrating here is the opposite of your rule. This is showing that even in the
4334280	4340440	case where types proliferate far more rapidly than operations, as in the case of drivers in an OS,
4340440	4348200	the principle doesn't work. Enums are better in both cases, specifically because you have
4348840	4354920	potentially thousands of types in the system, all different drivers, all the vendors have ever shipped.
4355880	4360920	Adding a single operation, however rarely, can cost massive programmer cycles to the
4360920	4367640	unnecessary work multiplication across types, the V-tapels course. Another way to say this would
4367640	4373720	be enums are more important in a system where type proliferate rapidly, not less. Regarding,
4373720	4377560	you eventually chose a design that sacrificed machine cycles to save program cycles.
4378120	4385240	I did no such thing. The design achieves both, like why I like it. It's drastically faster to
4385240	4389160	use something like a packet-based system than something that is originally proposed design,
4389800	4396920	because you do not take a ring transition on every operation. New OS IO APIs are not all designed
4396920	4402760	this way. This user writes data without taking in talking to the OS, and a kernel thread picks up
4402760	4408120	those data writes. Nobody ever makes a function call, except occasionally to ensure the kernel
4408120	4414280	thread hasn't gone to sleep. This is what I mean by the bullet point, if at some point we decide
4414280	4418920	users should be able to do multi-threading book IO ops. I am talking about the necessity that
4418920	4423880	actually occurred in both Linux and Windows of removing their frequency of ring transitions
4423880	4429320	for saving CPU cycles. None of this is trading CPU cycles for programmer cycles. It's achieving
4429320	4435960	both. The Linux kernel design of the IOU ring looks like my design. That did not add to save
4435960	4440920	programmer cycles. They added it because they wanted the highest possible IO throughput. This is an
4440920	4446520	almost universal principle of modern OS design. Anything that can be turned into data writes
4446520	4452760	should be, and function calls should be minimized. It's been true for GPUs, for NICs, and for our
4452760	4458280	example disk IO. And the last bullet point is regarding, and so I think we wind up in the
4458280	4464200	same place when dynamic operations proliferate more rapidly than types we both use, switches,
4464200	4468600	when types proliferate more openly than operations we both use dynamic dispatch. Again,
4468600	4474280	I don't see how you got there. Obviously types are proliferating more rapidly in this system,
4474280	4479560	so that is part, is true. If we didn't believe drivers are proliferating rapidly,
4479640	4485640	why are we loading them dynamically? And I thought that was the entire point of the example,
4485640	4490520	but perhaps more importantly, we are not using dynamic dispatch here in the way that you've been
4490520	4494840	suggesting. As I was pointing out earlier, I said that when I proposed the design process,
4494840	4500120	I would also do the inside drivers themselves. I would not duplicate drivers to remove if
4500120	4504120	statements and switch statements inside a driver that allowed the drive to handle multiple similar
4504120	4510360	devices. The only reason that there are function pointers in this system is because the problem
4510360	4515880	definition required that we load the driver from a different module, and we are not presuming a JIT
4515880	4522440	or something that can weld, wield, weld things together for us. That introduces a mandatory
4522440	4528600	cut so we cannot get rid of it because the problem is defined to contain it. But note that this is
4528600	4533000	not the same between our two approaches. I have a function pointer there because it's required,
4533720	4538600	and you'll note I minimized the number of all the way down to one. I didn't put it in there
4538600	4543160	because I think it saves program time. In fact, I'm not really sure I want it there at all. I
4543160	4547880	haven't actually implemented this particular system in an OS, so it's somewhat off the top of my head,
4547880	4552760	but it's very impossible that if I actually went to write this, I wouldn't include that function
4552760	4559800	pointer at all. Instead, I might just have the OS thread reading the queue, sorry, the OS thread
4559800	4567000	reading the queue, and pre-filtering the packets for quota permissions, then updating a shared
4567000	4572680	memory access that lets the driver know it can process the packets directly without actually
4572680	4578600	implementing. I can't say that's for sure what I would do, but it's probably something I would try.
4578600	4583880	So thanks for overstating the similarity of our approaches, but I think that they're similar,
4583880	4589000	then I guess that's just where we end up. Thanks for taking the time to create this thread which
4589000	4594680	pushed the GitHub emoji to check a well beyond its limits. Sorry, I had to read all that, but yeah,
4594680	4598680	that was all right. So this is kind of the point I was trying to point out is that case was saying
4598680	4604200	this isn't what you were showing, and the point where I say like Mr. Martin thought he won the
4604200	4609800	argument, like you need to use this style, is by using the canonical case of requiring it,
4609800	4613240	which is the canonical case is a data stream, a canonical case of like you've got different
4613240	4619240	operations fixed interface, but you've got an opaque different what it actually variant type,
4619240	4623320	whatever it is. And then they talk about actually how does it implement the operating system case,
4623320	4626680	it actually just shows that actually effective this is how you do it in Linux. We don't know how
4626680	4630600	Windows works kind of, we can reverse engineer it, but like it's not the source code, it's not
4630600	4637640	public obviously, because it's a closed source operating system. But that's kind of the the
4637640	4644280	issue that's going on here. Mr. Martin thought he won by showing like you already just did dynamic
4644280	4649960	dispatch. In case you went, you just find it to have it. And in fact, I didn't even require multiple
4649960	4655160	functions acquired one, it's not tripling direct to any single interaction. And I just had a switch
4655160	4658120	name in there, because this is also how the operating system does it. And it's better for
4658120	4664200	literally CPU cycles and reduced programmer cycles. It's not one or the other. So hopefully this is
4664200	4669400	okay. And I'm done now. I was just going to do this. And I was talking about this, we've already
4669400	4674360	discussed this, what I've seen was I did a tweet on it mildly. And there were some other things
4674360	4678200	I was talking about here on to talk about Mr. Martin, but I didn't in the end be honest with you.
4679880	4685320	It was more of a, I'm just showing the rhetoric styles of Mr. Martin. That was it. So I hope you've
4685320	4691720	enjoyed this. I apologize. This is about 120 minutes long. So thank you for putting up with
4691720	4697320	all this. I wanted to end off with this little thing here is what I wanted in for. So we already
4697320	4702120	had this in his code, but someone commented here saying, look, I says, but there's kinds of environments
4702120	4705560	though, the parsimony is important nowadays, far and few between the vast majority of software
4705560	4709880	requires less than 1% of modern processing. This is the first section we read. What's more
4709880	4713400	processes are so cheap and available that is a trivial matter to add more of them to the system.
4713400	4717880	Someone replied, I should know this person by the way personally, we do not consider it
4717880	4721560	good engineering practice of the person wrote it, not the quote, good engineering practice to
4721560	4726440	consume a resource lavishly just because it happens to be cheap in the class of it or Nicholas worth
4726440	4730120	one of my actual programming idols out there. And I love this quote because it's kind of as
4730120	4734440	viet slaw of worth slaw. However, it doesn't care. It's either name by or bind value. It doesn't
4734440	4739480	matter. And then Mr. Martin replies, that depends upon the, which resource you are talking about
4739480	4743400	computer cycles, computer cycle, programmer cycles, which should you trade against? And again,
4743400	4747160	I don't see what being the odds, but simpler code is easier to write. Our bubble source is
4747160	4751640	simpler. The tricky again, it's another trick. It was just last showing the rhetoric trick.
4751640	4759160	Simple is actually an overloaded term in programming. And it's an overloaded term in English,
4759160	4763240	because simply you need to mean the opposite of complicated, or it can mean the opposite of
4763240	4768360	complex. And in the case of complex, the technical term would be simplex. So is it simple as in
4768360	4774680	not complicated or simple as in simplex? And he has just done this on purpose. And he knows it
4774680	4780920	very well by saying, well, bullsaw is simplex, but it's very expensive. Multiply and multiply by
4780920	4785880	repeat about it. So it's simple. Actually, that's how, that's how like AMD processors, not AMD ARM
4785880	4791320	processors actually work, by the way, they don't technically implement multiplication. x86 does,
4791320	4798520	by the way, ARM does AMD 64. Sorry, I should say, AMD 64 does an x86 in general. It's actually one
4798520	4803080	of the only, it's very, very, you find a processor that does this, but they did it. Linear searches
4803080	4806600	are simple. Like, yeah, they are simplex. They also may be simpler, faster as well, but they might
4806600	4814520	not be. Like, there's a reason. But this is the trick. So I just want to end on that note. So I hope
4814520	4821480	you've enjoyed this. Please remember to like that smash button, and to comment in the description
4821480	4825240	below. And again, if you want to read any of these links before, I will post them in the description
4825240	4830040	of the doobly-doo below below here. And hopefully you've enjoyed this. This is a very unstructured
4830120	4837240	ranty talking about Mr. Martin's rhetoric style with regards to clean code, how, and at the end,
4837240	4841640	effectively, he just stated exactly what most people thought clean code was stating, and Casey
4841640	4850440	went, so I was right about what clean code was. Okay, thank you. So goodbye, everyone, and stay
4850440	4852440	tuned for the next video.
