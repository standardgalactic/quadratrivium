WEBVTT

00:00.000 --> 00:06.720
Hello and welcome, I am Gingerbell and today I'll be talking about the fiasco that has

00:06.720 --> 00:12.840
happened between Casey Muratori and Mr. Robert C. Martin. But before that I'm going to explain

00:12.840 --> 00:16.240
why the history got here and I'm going to also explain some stuff. I'm not going to

00:16.240 --> 00:23.600
try and criticise clean code itself. Casey Muratori has been trying to do this in the

00:23.600 --> 00:29.640
long discussions he's had with Mr. Robert C. Martin already. But it's one of those things

00:29.640 --> 00:33.880
where I just want to kind of show the rhetoric tricks of Mr. Robert C. Martin himself. So

00:33.880 --> 00:39.800
before we get to that start off, let's begin with the thing that started it all, which

00:39.800 --> 00:46.960
was this video that Casey made public from his thing. It's called clean code, horrible

00:46.960 --> 00:52.680
performance, where they say 22 minutes long video, him showing the examples of what clean

00:52.680 --> 00:57.400
code is and going into a more, let's say more like simplified code, which is more optimised

00:57.400 --> 01:00.720
performance and showing the cost. Hey, if you do it the clean code where you're going

01:00.720 --> 01:06.280
to be 15 to 25 times slower as your performance, do you want to take that hit? Understand what

01:06.280 --> 01:11.160
the costs are kind of you. And again, this is this view has also taken our context is

01:11.160 --> 01:16.200
blown up by mad. It's nearly half a million views so far at the moment at the time of

01:16.200 --> 01:22.440
recording. And so it's clearly gone viral across the programming world. Unfortunately,

01:22.440 --> 01:31.000
because it went viral, a lot of the context got lost. And because the context got lost.

01:31.000 --> 01:35.080
People just adding their own context into it without even bothering to learn it. So the

01:35.080 --> 01:41.280
context was this comes from a series that Casey's been doing on computer hands.com,

01:41.280 --> 01:46.280
where it's a performance awareness course. So specifically the this is the programming

01:46.280 --> 01:50.640
course he's been doing to performance awareness stuff. And this is a subscribed based thing

01:50.680 --> 01:56.240
on the on the on here. And he's been doing many different topics on here as I was able

01:56.240 --> 02:01.120
to learn how to performance awareness. Specifically, this was the blog post and he made completely

02:01.120 --> 02:04.920
public for everybody showing all the code showing all this stuff. So then you can see

02:04.920 --> 02:09.320
a whole video is all kind of transcribed down. And it's part of a series. It's not the beginning

02:09.320 --> 02:13.240
of the fifth series is quite in the middle. So it's kind of like, Oh, okay, we're not

02:13.240 --> 02:18.720
starting from a random place. So and also when people say and talk about the context

02:18.720 --> 02:22.600
of this Casey understands this like, look, reminder, I don't think clean code is bad

02:22.600 --> 02:26.600
just because of performance. My recent video is about poor performance, because it's part

02:26.600 --> 02:31.000
of a course on performance. This is the context many people lost. And he's been doing this

02:31.000 --> 02:34.560
for decades is saying so I recommend reading these tweets, I will try and provide all of

02:34.560 --> 02:39.120
the links to everything I'm showing today in the description or the do blue do whatever

02:39.120 --> 02:45.680
you want to do down below on YouTube. So be here. So yeah, hello. Good. So give a background.

02:45.680 --> 02:51.320
He's picked up the attention of Robert, Mr. Robert C Martin, which he colloquially calls

02:51.320 --> 02:56.400
himself Uncle Bob. For this talk, I'm just going to call him Mr. Martin, because I just

02:56.400 --> 03:02.920
prefer saying Mr. Martin, insert your guesses as to why. But yeah, he is very well known

03:02.920 --> 03:09.080
for my mainly three things, which is the agile manifesto, he helped develop that solid the

03:09.080 --> 03:15.120
solid principles. So the agile manifesto and solid principles, which again, many people

03:15.160 --> 03:19.000
know from the world, especially that he wrote it in his in his book, which is first in design

03:19.000 --> 03:24.640
as principles and design patterns, as it says on here. And he's also in this thing known

03:24.640 --> 03:31.280
for clean code. So clean with capital C code with capital C trademarked. This is his particular

03:31.280 --> 03:37.600
thing, the capital C clean code thing. Okay. And this is what he kind of tries to describe.

03:37.600 --> 03:45.080
So to get to show my biases and my background, I am the creator of the program language here.

03:45.080 --> 03:48.200
And the only program language is the general purpose program language with the distinct

03:48.200 --> 03:53.240
typing built for high performance modern systems and data order programming. So clearly, I'm

03:53.240 --> 03:57.560
showing my biases, and I'm cleaning on more like case and oratory side when it comes to

03:57.560 --> 04:03.240
this discussion. And also, I work at Django effects on emogen and liquid gen and geo gen,

04:03.240 --> 04:07.320
which are all high performance real time pieces software like simulations, again, engines

04:07.320 --> 04:11.400
for fire, smoke and explosions in real time. So clearly, I work in an industry where we

04:11.400 --> 04:15.160
really care about high performance real time stuff. So clearly, I'm showing my biases straight

04:15.160 --> 04:21.720
away. So people understand what's going on. Okay, so now you know, that's on the way. Can

04:21.720 --> 04:26.760
we explain what clean code is before we get into this? So sure. So there is this kind of

04:26.760 --> 04:31.320
little document I found the other day, and it's been well actively updated by looks only eight

04:31.320 --> 04:38.440
hours ago at this time of recording. And today's date is the March the 30th, I believe. Yes, March

04:38.440 --> 04:43.000
the 30th. So it's very active or someone's updated there's probably some typos and such

04:43.000 --> 04:47.960
we can even see the revisions. And yeah, it's just some, hey, just capitalizing some straw.

04:47.960 --> 04:52.920
That was all it was. Now, many people have seen to have liked this clearly over 5000 stars and

04:52.920 --> 04:58.280
over 1000 forks of this gist, as well gist or I don't know we pronounce it on GitHub,

04:59.080 --> 05:05.240
and explained some of the began your principles or points about clean code. Now there's many

05:05.320 --> 05:09.400
of this. This is the thing about which is why clean code capital C thing trademarked by Mr

05:09.400 --> 05:14.200
Martin is very popular because there's many of these rules, which no one would disagree with,

05:14.200 --> 05:17.800
like follow standard conventions. Yeah, because conventions are a good thing because then you're

05:17.800 --> 05:22.680
working on the same sun, only break them when you need to keep it simple, stupid, you're fine,

05:22.680 --> 05:27.000
whatever. Boy Scott rule, leave the camp around cleaner than you found it, always find the root

05:27.000 --> 05:32.520
cause you're no problem like this, yada, yada. Now some of these are things, okay, some of these are

05:32.760 --> 05:37.240
not essential. These are accidental. Like, again, follow standard conventions. That's not

05:37.960 --> 05:42.920
a unique to clean code, is it? You can do that in any philosophy out there. It's not a unique

05:42.920 --> 05:48.280
principle to clean code itself. But some things like, for instance, I would say more essential

05:48.280 --> 05:54.520
to clean code or prefer polymorphism to if or else cases. And separate multi floating code.

05:54.520 --> 06:00.200
I'm not even sure what that means. Use dependency injection. Follow the law of Demeter or many

06:00.200 --> 06:04.040
other things, many other things like here, like, Oh, use small functions functions, they only do

06:04.040 --> 06:07.960
one thing use descriptive names, like getting that descriptive names, everyone agrees to that to a

06:07.960 --> 06:13.000
certain extent, prefer fewer arguments have no side effects. So be more functional, it means more

06:13.000 --> 06:17.560
and more rather than be like, have side effects itself, like be more imperative relying on like

06:17.560 --> 06:21.880
global state or modifying state or whatever, don't use flag arguments, yada, yada, like, okay,

06:22.680 --> 06:27.480
some of these people will agree with some people will disagree with them. But here's where the

06:27.800 --> 06:34.680
the problem is with some of this is that for the most part, some of these rules,

06:34.680 --> 06:38.360
people will agree with some of them don't. One of the particular is like small rules for me,

06:38.360 --> 06:42.680
I actually disagree with this particular thing. There was a post here, this is on Jonathan

06:42.680 --> 06:46.920
blows blog old, very old blog, actually, this one 2016. But he's actually even older than that,

06:46.920 --> 06:54.280
because it's an old email response between him and john Carmack. So this is john Carmack explaining

06:54.360 --> 06:59.880
effectively, what he preferred for the things is not the clean code up. This is what I wanted

06:59.880 --> 07:05.720
was the wrong one. Whoops. Let's go to the blog post again. And it's this one here. So I accidentally

07:05.720 --> 07:09.880
clicked the wrong button then. So this is john inline code. And john Carmack in the email is

07:09.880 --> 07:14.120
explained, actually, he doesn't like the separate single functions here. It's better just have

07:14.120 --> 07:18.040
one big function and then comment them. Now, some people might say be a bit easier to manage

07:18.040 --> 07:22.280
looking at re things. Yeah, for code reviews, in a big corporate setting, it might be easier

07:22.280 --> 07:26.200
looking a single function. But there's a few things you have to understand functions have

07:26.200 --> 07:30.360
costs. If you split these things into multiple functions, this is a one is an extra cost. Yes,

07:30.360 --> 07:34.760
is a minor cost when calling a function. But like that most people don't care about that cost,

07:35.480 --> 07:39.320
unless you're doing particular things like you're worried about stack stacks or anything like that.

07:39.320 --> 07:43.560
Like, okay, most things don't care. One thing it does do is it does actually doesn't mean it's

07:43.560 --> 07:47.800
very easy to optimize for the optimizer. And I know how compilers work because I work on them for

07:47.800 --> 07:53.000
kind of a living. And if you have things in line, one, it's not hard to read by just using

07:53.000 --> 07:56.920
comments everywhere or block codes or anything like that. I think it's just as easy. And if you've

07:56.920 --> 08:03.400
got text editors, which are use collapsible things, that's great. That's okay, no problems, just deal

08:03.400 --> 08:07.400
with it that way. But then it's like, okay, but the optimizer can be ready, doesn't have to worry

08:07.400 --> 08:11.240
about trying to inline that function. And then now optimize the new inline function that's been

08:11.240 --> 08:17.000
got in line is out of another function. So there's that. And also you can usually start to see easy

08:17.000 --> 08:21.800
patterns as well. If you start manually inlining things, it's not hard to read. Yes, okay, you've

08:21.800 --> 08:26.920
got 10,000 lines, but most people's IDs and text editors are very easy for code folding, code

08:26.920 --> 08:33.160
searching, code and organization. We're not living in the 80s anymore, or even the 70s,

08:33.160 --> 08:36.440
to be honest, because even small talk had better options than this. I'm not saying I'm a big fan

08:36.440 --> 08:41.640
of small talk. But again, the tooling is the argument going small function is more of a, hey,

08:41.640 --> 08:48.840
it's our code review practices, big corporations, testing practices, and also maybe just tooling

08:48.840 --> 08:53.320
practices. So that's one thing. But it's going to recommend highly reading this article, I really

08:53.320 --> 08:59.720
do from 2014, again, it's from 2007, as it says here, I recommend it. But what I'm trying to get

08:59.720 --> 09:02.600
out here about the word clean code, and I'm not even talking about the actual discussion that

09:02.600 --> 09:06.600
Casey Motoria, they've been having yet, because I want to try to build up a picture here, as you

09:06.600 --> 09:10.360
can probably tell, trying to be a storyteller, not very good at it, but let's carry on with it,

09:10.360 --> 09:14.040
is that the concept of clean code is what I want to the term it capital C, capital

09:14.680 --> 09:19.720
C on both of them, trademarked for Mr. Martin, is what I'm going to dub a pork barrel name.

09:20.600 --> 09:25.480
So a pork barrel is a thing that America, American English, but it's kind of a

09:27.400 --> 09:31.240
you have this bill, and it has a particular thing like citizens against government waste.

09:31.240 --> 09:35.320
But it also has all of these things that are nothing even related to the actual name of the

09:35.320 --> 09:39.640
bill. And to keep it in American context, because I know most people watching going to be Americans,

09:41.160 --> 09:44.520
so I'm not going to use an English example, or another European example, like

09:44.520 --> 09:47.080
Germans, I'm just going to use American example, I've run recent one as well,

09:47.720 --> 09:53.240
is the Inflation Reduction Act of 2022. The name of it, the Inflation Reduction Act.

09:54.520 --> 09:58.680
Okay, now I'm trying to be again, I'm not an American, don't really care politics, but I think

09:58.680 --> 10:03.560
most people would agree, this act did not reduce inflation, in fact, it printed more money,

10:04.520 --> 10:07.720
and more excess money, that money was not being in high demand.

10:08.680 --> 10:12.360
So it increased inflation, in fact, it had loads of other things in there to do with

10:12.360 --> 10:18.200
not to do with inflation. But a really clever political rhetoric trick is to say, oh, you

10:18.200 --> 10:22.040
don't like this bill, we must like inflation, you're bad, everyone dislikes inflation.

10:22.680 --> 10:26.840
So you must be, oh, you can't be against this bill, can you? It's like, but this doesn't,

10:26.840 --> 10:30.920
ah, no, no, it doesn't inflation. How dare you don't want to, like, you can do this trick. And

10:30.920 --> 10:34.200
again, it's not a political side either, literally all political parties or politicians,

10:34.920 --> 10:40.440
I do this trick. Some countries like to do, like, oh, we're just getting names from bills.

10:40.440 --> 10:43.800
But then they'll give them a name anyway, like a colloquial one to refer to it rather than giving

10:43.800 --> 10:47.640
it like a letter or a number or some random numbers or something like that bill. And they'll

10:47.640 --> 10:50.840
just say, look, no, this is what we're going to call it. Because technically internally,

10:51.480 --> 10:55.560
the Americans do, but they give them a proper name and also a very long title. Again, this is

10:55.560 --> 11:01.960
to provide for the reconciliation pursuant to Title II of the S Con Rez 14, I'm just reading it

11:02.040 --> 11:06.360
as it says on here. And it's like, okay, but that's a good example from a political standpoint.

11:06.360 --> 11:09.000
I'm just keeping it here, trying to keep it politically neutral. I don't really care about

11:09.000 --> 11:12.520
the old politics, but it's just one of those funny things that show, hey, this is a trick,

11:13.480 --> 11:18.440
because Mr. Martin will actually continually do this throughout. And it will trick, do a lot of

11:18.440 --> 11:23.320
pivoting and a lot of these poor barrel names. Okay. So let's just say this is a good example

11:23.320 --> 11:28.600
of this bad code. Just say no. And it's like, okay, so what's good code then? Because then it's,

11:29.400 --> 11:33.160
phrases in the, oh, it's clean code, obviously. Now there was another tweet, I tried to find,

11:33.160 --> 11:38.120
but I couldn't find it's probably been lost to the Twitter search, or it's just been deleted,

11:38.120 --> 11:43.160
whatever. But he will commonly do this, Mr. Martin go like, oh, the opposite of bad code is clean

11:43.160 --> 11:48.280
code with a capital C trademarked, which is interesting. Because that means anything that's

11:48.280 --> 11:56.520
not clean code is a bad code. Yeah, let's not get there. But again, very clear, careful on this,

11:56.520 --> 12:01.080
I'm not going to criticize him. I'm actually like, in admiration of his rhetoric, he's

12:01.080 --> 12:06.360
a politician level when it comes to rhetoric, I mean this. And it's like, this is really good.

12:06.360 --> 12:11.400
Like he's really good at it. But again, he's been doing it for nearly 50 years. He is what 70 years

12:11.400 --> 12:18.280
old. He's been doing this sort of job since what, God, even the early 90s. So it, okay,

12:19.640 --> 12:25.400
worst, like, it's 30 years, he's been doing this, he's probably been doing it for 40. Okay,

12:25.400 --> 12:29.240
that's what he does for a living. He's very good at this rhetoric. So that's why I'm like,

12:29.240 --> 12:33.320
I'm kind of admiring it into a certain extent, in a weird Machiavellian sense.

12:34.120 --> 12:37.400
But sure, let's carry on with this, shall we? I've got some more things. Another thing in here,

12:37.400 --> 12:40.760
he says, when this whole thing happened when he was talking about it, oh, no,

12:42.120 --> 12:44.600
people don't like this code. But then he says, some people do this. And again,

12:44.600 --> 12:47.480
I've shown you, he's very good, he's very good at knowing memes. He's not an old man, he's an old

12:47.480 --> 12:51.720
man, but he's up to date with a lot of the stuff. And it sounds like silly, but it's not a book,

12:51.720 --> 12:55.800
or the concept, it's a Cartesian pandering immature behavior. The author batches everyone,

12:55.800 --> 12:58.520
and then he just shows this claim like, hey, I know how to play your joke.

12:59.240 --> 13:03.240
Like, and he does, he's not that bad. But then there's other things. So here's like,

13:03.240 --> 13:08.520
Casey Motori comes up with, I mean, he's talking about people criticising, and then he replies to

13:08.520 --> 13:12.760
this, this is where kind of the start of the conversation is happening. So Casey has says

13:12.760 --> 13:17.640
in this, even if true, to what extent would you tolerate the, yes, clean code is much slower,

13:17.640 --> 13:22.200
but it's about programmer productivity for other products. Would you want a car that went only

13:22.200 --> 13:26.680
five miles per hour, because the designers could do less work to make that car? Now,

13:27.400 --> 13:32.760
Mr. Martin replies to what the auto owners notice he does a pivot. This is a pivot. And also,

13:32.760 --> 13:38.120
it doesn't answer the question. He says, the automated mobile industry takes advantage of

13:38.120 --> 13:42.840
every productivity tool they can reduce their enormous manpower cost of designing and manufacturing

13:42.840 --> 13:47.160
cars. As a result, cars have gotten exponentially better over the decades, because the extra productivity

13:47.160 --> 13:54.440
translates to better designs. Yes. But do you think they for their programming, they're using

13:54.440 --> 14:00.920
clean code? Principles. In fact, we know they don't, especially after he's Mercer and stuff like that,

14:00.920 --> 14:04.520
but they have to adhere to certain other things. And like, they're probably not doing clean,

14:04.520 --> 14:08.840
clean code stuff. Now, I know the most things have started to relax, especially when it comes to,

14:08.840 --> 14:14.920
like, Android Auto and I'm like, Apple Car play and stuff like that, it's, they're stuff a buggy.

14:14.920 --> 14:18.200
But that's kind of like, Oh, it's your phone. That's a different thing. It's just we're interfacing

14:18.200 --> 14:22.520
with it and whatever. And it's interesting. He does this because he does it again, when someone

14:23.240 --> 14:28.200
replies to it and anything here. But he's kind of a, he knows what he's doing when he says these

14:28.200 --> 14:34.920
arguments. That's not answering the question. All I'm going to say is that just watch that. Okay.

14:34.920 --> 14:38.040
Another thing is this is when it starts, this was the beginning of his, I wash your thoughts and

14:38.040 --> 14:42.360
he says, Oh, I've commented on this before clean code is made for programmer performance,

14:42.360 --> 14:48.120
not algorithmic performance. If you need the latter, then write in C or assemble and live with

14:48.120 --> 14:54.360
the high cost of development. So few things there already, PI programmer performance and

14:54.360 --> 14:59.560
algorithmic performance. Okay, so program performance, it's the, in the contrast, how do you measure

14:59.560 --> 15:03.640
that thing? How would you know if that your approach is better than another approach? And if

15:03.640 --> 15:07.000
you need the latter, write in C and assemble, okay, it's assembly, I would call this, but yeah,

15:07.000 --> 15:10.360
and then high cost of, so he's already implying that writing in C

15:11.160 --> 15:14.680
is going to be a much higher cost of development than writing in another language.

15:14.680 --> 15:18.600
It might be, but you should only write it in because you need the performance. And it's like,

15:19.400 --> 15:25.720
okay, what? Look at the framing. He knows what he's doing. I'm not saying he's an idiot. He's

15:25.720 --> 15:29.960
very smart. Okay, I'm sorry. I'm picturing it. I can already see which side I'm in, but I'm just

15:29.960 --> 15:33.800
trying to explain the rhetoric tricks. So this is another thing is like the clean code to reply

15:33.800 --> 15:37.240
to later with the automatic ability. I've got these switching around. It doesn't matter. People

15:37.320 --> 15:42.600
says, how do you measure readability of the code by reading it? So obvious. But it's like,

15:42.600 --> 15:47.880
when people say measure, they usually mean a quantifiable thing rather than a qualifying thing.

15:47.880 --> 15:54.120
So this equality and a quantity are two distinct ontological categories, okay, or

15:54.120 --> 15:57.080
epistemological, the many different things, which is not going to philosophy too much, but

15:57.080 --> 16:02.040
you cannot quantify a quality and never qualify a quantity in a sense. They're different things

16:02.120 --> 16:10.920
like, Hey, I have a tape measure here. Yeah, I can say it's got the, I say it's quality of being good

16:10.920 --> 16:15.160
and round and green and stuff like that. And these aren't even very good qualities, to be

16:15.160 --> 16:21.400
honest with you, but it has quantities. I know it's mass just by dropping it. That's what you need to

16:21.400 --> 16:25.000
do. That's absolutely fine. And it masters. I'm just trying to explain the gravity thing. So

16:25.000 --> 16:28.280
clearly it's got mass and we can measure that relative to other things that weigh things. So

16:28.280 --> 16:34.520
we know how much this is weighs. This is probably weighs about, I don't know, eight ounces. So 225

16:34.520 --> 16:41.720
grams ish. That's quite heavy, actually, surprisingly, it's not even a good one. But there's kind of

16:41.720 --> 16:45.320
the thing. So you can actually think you can sort of say, Oh, how, how green is where we can measure

16:45.320 --> 16:48.760
the reflectings of it and then see how much it reflects back a certain light and some wavelengths

16:48.760 --> 16:52.760
and such like this. You can say all these quantities and you're, these are quantities,

16:52.760 --> 16:56.440
okay, but I want to go into too much clearly. I used to be a quantum metrologist. So I know

16:56.440 --> 17:00.920
a lot of you may excuse measurements and all this stuff. But this is a clever trick by reading it.

17:01.880 --> 17:06.040
That is not a quantity. And people are wanting to question how do you measure when we want an

17:06.040 --> 17:12.200
objective measurement? What do you mean is they want a quantity? But he goes out by doing this.

17:12.200 --> 17:16.280
So this was a big long twist post I've been here, where Lawrence Crow again,

17:17.080 --> 17:20.840
the community anyway says people on hand made hating on Casey's videos about performance,

17:20.840 --> 17:24.520
while their company is spending double digits of percentages of their revenue on

17:24.600 --> 17:28.600
Amazon web server bills to serve three forms and a database view. And it's like, okay,

17:28.600 --> 17:33.320
this is great nightlight discussion. Talking about this. And then Mr. Martin says here is his,

17:33.320 --> 17:37.400
his analysis was correct. His rhetoric is abyssin, disingenuous. And the overall point was

17:37.400 --> 17:41.320
extraordinary narrow. Clean code is about increasing programmer performance. He keeps

17:41.320 --> 17:46.520
it straight this not computer performance. What are some real life life non-trial view

17:46.520 --> 17:50.440
code bases support the hypothesis that strict clean code increases program performance

17:51.080 --> 17:51.960
replies with a mean.

17:55.560 --> 18:00.360
Again, he knows what he's doing. I'm not like, this is really cool. Like he knows what he's doing.

18:00.360 --> 18:03.560
But yeah, so you don't have any of his tools that some says it. So the Vittorio

18:03.560 --> 18:07.080
reminded me of a thing for the people I got into a discussion with him around about this time.

18:07.080 --> 18:12.520
And I kind of partially convinced him about like, well, you need you've not go evidence for why one's

18:12.520 --> 18:16.200
better than the other. Like show why how do you know one's better than the other? It's kind of

18:16.280 --> 18:20.120
that question. Like how do you know what measurements are using what quantifiable or even

18:20.120 --> 18:23.880
qualifiable things are you showing? Like, can you just show me the evidence? And then he goes,

18:23.880 --> 18:28.200
he knows this for a fact, he says, the problem with scientific data is it's controlled in

18:28.200 --> 18:31.640
controlled experiments and realistic software environments are economically feasible. You're

18:31.640 --> 18:36.440
asking for something you'll never get. And yet you still decide. So look around and that's just

18:36.440 --> 18:39.880
so it's especially your seniors. So first of all, it's just the first part of this thing here is

18:40.520 --> 18:46.120
we have no evidence for our claims. But it's okay, because your associate seniors may agree

18:46.120 --> 18:55.480
with me already. Nice little pairing here doesn't do the same thing. Okay. That's the first thing.

18:56.600 --> 19:00.600
But then someone said like they said they use over the 10 lines of code sometimes wrong seniors,

19:00.600 --> 19:04.600
I guess, and someone saying like, well, we've got my seniors don't agree with you. So sometimes,

19:04.600 --> 19:09.160
of course, your seniors were correct. I presume they also told you that or else be your smaller

19:09.160 --> 19:13.880
well named functions are better than really badly named functions is like, okay, notice the bad

19:13.880 --> 19:18.120
pairing there already. A well named function is better than a badly named function. Agreed.

19:18.760 --> 19:23.160
Smaller function may not be better than a long function. But notice is smaller well named

19:23.160 --> 19:26.840
functions are better than really badly named functions. Never talked about the length of it.

19:29.000 --> 19:33.640
I know it's like a minor word difference. But he knows what he's doing. And also he just changed

19:33.640 --> 19:37.480
the topic and it's a pivot. He's gone from being the scientific data to now to well, trust your

19:37.480 --> 19:43.000
the trust the authorities of your seniors or elders or whatever, like, that's going to authority

19:43.080 --> 19:48.760
rather than going to like empirical data. Nice little pivot. He knows exactly what he's doing.

19:49.960 --> 19:54.680
So another one here is always remember that computers operate on f in character one f in

19:54.680 --> 19:59.000
character to times he's trying not to swear here. No matter what lovely subroutines you might be

19:59.000 --> 20:03.160
using some replies, what about Sunday? Well, the context of the problem was JavaScript in a browser.

20:03.160 --> 20:09.000
I'm like, what context I even tried to search through the other tweets. There was no context.

20:09.720 --> 20:20.760
So, yeah. Okay, carry on. Another one. Someone has recently equated clean code

20:20.760 --> 20:26.840
over engineering. That is, of course, an oxymoron. An over engine code is by definition not clean

20:26.840 --> 20:30.120
and makes me wonder if those who complain so loudly have actually stood at the target of

20:30.120 --> 20:38.120
their complaints. It's like, see the see the problem. So if he's over engineered, it can't be

20:38.120 --> 20:42.600
clean code. Even though I've seen many clean code, which I've classes over and engineered. In fact,

20:42.600 --> 20:47.720
I think clean code by default is kind of open engineered like it doesn't it's assuming this

20:47.720 --> 20:53.160
could be open to change even though it's a close set of problems, which I'll get onto a bit later.

20:54.760 --> 20:58.200
So then talking about this for tour of Rome, a shot we had earlier, I was discussing with him

20:58.200 --> 21:02.440
previously. And he was kind of like, Oh, well, I can make it even faster. If you just change the

21:02.440 --> 21:06.280
entire style of it and just have a raise of separate types. And I was just like, you being honest,

21:06.280 --> 21:10.440
but this was the conversation I had even trying to confuse it like to not, he was kind of being

21:10.440 --> 21:13.080
a bit confused, but also trying to be like explaining. And we kind of got to a point where

21:13.080 --> 21:17.800
like, Oh, okay, like, first off, you've been a bit disingenuous here, man, with the argument,

21:17.800 --> 21:21.560
but fine. This is not Mr. Martin anymore. This is just me explaining like there are people who are

21:21.560 --> 21:25.960
trying not saying to defend him, but not understanding like Casey's point in this

21:25.960 --> 21:31.000
discussion. So again, before I'm going to read this article, I recommend reading this clean

21:31.000 --> 21:36.120
code, horror performance, YouTube video, again, links are in the description for all of these

21:36.120 --> 21:40.600
links. So don't worry, they'll be there. So now I've done the 20 minutes spiel at the beginning

21:40.600 --> 21:46.760
of this video. Let's get to the meat and potatoes of this entire thing, which is the written down

21:47.880 --> 21:55.400
talk. Now this is quite interesting. And this written down talk is effectively a written

21:55.400 --> 22:00.760
discussion between Casey Meritori and Mr. Martin. And they are both discussing with it,

22:00.760 --> 22:05.000
and it's been split into different things. And I'll explain some points as I come along.

22:05.000 --> 22:08.360
And so other little tricks. So first off, I'm just going to try and read it. I recommend

22:08.360 --> 22:12.440
reading this again, links in the description below for everything. So Casey starts off with

22:12.440 --> 22:17.000
thank you taking the time. And he's just kind of asking questions like so most explanations

22:17.000 --> 22:21.320
on clean code, I've seen that you include all things I mentioned in the video, like

22:21.320 --> 22:26.040
preferring inheritance hierarchies to ifstapes, which means like I remember if we look back

22:26.760 --> 22:31.240
to the the where was the guest I found completely lost it already now.

22:33.320 --> 22:38.440
It was here, right? Here it was here. Yeah, here's the design rules.

22:40.200 --> 22:44.440
Like that some some size, that's not Mr. Martin's himself. But yeah, but it sounds like

22:44.440 --> 22:47.640
you were surprised to hear me say that like all these different things he said is I look

22:48.600 --> 22:54.200
Martin's going to disconnect. I'm not sure there is one. And interesting, he just says there is no

22:54.200 --> 22:58.840
like disconnect. And Casey just asking questions about this. So Casey is asking a basic question

22:58.840 --> 23:02.440
here like look, we're both familiar with Visual Studio and Clang, and it would be a reason more

23:02.440 --> 23:06.920
that you're calling the back and uses it every day. I use these every day. I use LLVM and Visual

23:06.920 --> 23:10.600
Studio every day. Are you calling these a vast majority of software that require less than

23:10.600 --> 23:15.240
one things? And then he would go like, Oh, these are very specialized software, the only few in

23:15.240 --> 23:19.560
existence, and only a few that have actually become popular. And then talks about why this case

23:19.560 --> 23:23.720
and like actually talks about all these different things here, like, okay, speed is not necessarily

23:23.720 --> 23:28.440
an issue. But you can summarize, I'm trying to summarize it. But then the first trick he does,

23:29.480 --> 23:34.440
this is going to be consistent throughout here, is the nanoseconds, microseconds and milliseconds

23:34.440 --> 23:43.000
framing. I will tell you this. So what it will do here is making sure that passing code preserves

23:43.080 --> 23:49.400
nanoseconds can have a big effect. Or he says, I assiduously counted microseconds when it mattered.

23:49.400 --> 23:56.280
Nanoseconds were way beyond anything I could imagine. And so then Casey kind of questions,

23:56.280 --> 24:01.320
is a case of like, it sounds like most software that Casey actually uses and so with myself would

24:01.320 --> 24:05.640
when nanoseconds actually matter. In other words, Visual Studio, LLVM, GCC, Microsoft Word,

24:05.640 --> 24:10.120
PowerPoint, Excel, Firefox, Chrome, FFMPEG, there's a type of that, but TensorFlow, Linux,

24:10.200 --> 24:16.440
Windows, macOS, all of these. And Martin goes again, Mr. Martin goes like, oh, not exactly,

24:16.440 --> 24:20.600
rather my experience abroad, and does all the stuff. And then talks about this other applications

24:20.600 --> 24:23.800
we have modules in the millisecond range. And he says, sort of these time ranges.

24:24.760 --> 24:29.960
It's very like, he's trying to get the reader, because he knows people reading this, to think

24:29.960 --> 24:33.640
about it, well, most problems are in there at ranges of milliseconds. So we can worry about

24:33.640 --> 24:37.480
nanoseconds. Most people aren't have to worry about the automizer nanoseconds. But it's like,

24:38.120 --> 24:43.480
you know, death by 1000 cuts, and 1000 milliseconds is a microsecond, 1000 microseconds is a

24:43.480 --> 24:49.880
millisecond. So if you do things 1000 times badly, and you can, you've now gotten to the other

24:49.880 --> 24:57.240
domain into the other module, as he was calling this, the time module. Okay, fine by me, not

24:57.240 --> 25:02.360
necessarily criticizing that way of thinking, but it's a very weird framing, which,

25:02.920 --> 25:08.200
like, even if I read here, so for example, I'm currently working on an application in which

25:08.200 --> 25:12.680
the vast majority of modules work well at the millisecond level, but a require a 20 x per

25:12.680 --> 25:16.600
better performance. My strategy has been to write the millisecond modules in closure,

25:16.600 --> 25:20.440
because while slow, which is very convenient language, the microsecond modules I wrote in

25:20.440 --> 25:24.520
Java, which were much more faster, more convenient, far less convenient. So it's like, okay, so if

25:24.520 --> 25:29.240
I use them all like Java, it's easier, it's much less convenient, but I can write faster code,

25:29.800 --> 25:33.720
compared to closure, which is, I write code quicker, but it's not going to be as

25:33.720 --> 25:37.240
powerful as that. And those bits, these mergers again, because closure and Java both work on the

25:37.240 --> 25:43.240
JVM, so they can interact with each other pretty easily, ish. But he's just talking about the other

25:43.240 --> 25:50.600
things here. Now, one thing I found interesting is this slash here. You'll see in a minute,

25:51.560 --> 25:55.080
right, he only wrote a book, and he said, oh, I wrote a book on clean code, don't you know?

25:55.640 --> 25:59.960
I've only focused on the millisecond side of the problem, not the nanosecond. It's like,

25:59.960 --> 26:05.320
well, I'm not walking about the performance of the code anymore. But like Casey just goes

26:05.320 --> 26:09.560
town on the question. So Bob answers a very short question, milliseconds, of course.

26:11.480 --> 26:16.520
And then he answers again. Now, he might be asking, wait, why is he answered twice?

26:16.520 --> 26:21.960
Well, he went back in history and added some code text. He rewrote history. Yeah.

26:22.280 --> 26:28.440
I'll say no more. But yeah, he keeps going on about this, and it's very interesting. So now

26:28.440 --> 26:32.680
here's another problem he kind of talks about. And he talks about the actual he says he's now

26:32.680 --> 26:36.600
actually finished watching the video, because he didn't actually watch the video when he started

26:36.600 --> 26:40.200
discussing with the only watch the first bit of it until I've got enough of this. It's like,

26:40.200 --> 26:44.840
you're not going to have discussion with someone you've not even watched the entirety of but you

26:44.840 --> 26:49.480
think you're confident, you know, you can talk about it. I'm like, interesting. If you're that

26:49.480 --> 26:55.160
confident, it usually means you're not actually talking about the thing itself.

26:58.280 --> 27:03.400
Yeah. Yeah. But he says, you notice a nice little pattern. I love that basic form of

27:03.400 --> 27:07.240
the like some coefficient times the length times the width. And in those moments, I only think

27:07.240 --> 27:11.560
programs and mathematicians mathematicians can truly appreciate. It's like, oh, yeah, yeah,

27:11.560 --> 27:17.640
like that was fine. Isn't that lovely? And that's fine, whatever. But Casey comes up,

27:17.640 --> 27:20.760
okay, that sounds great. I think we've gotten to the same page because he was actually talking about

27:21.480 --> 27:26.600
this, not this. Because he says, I've just finished watching it. So I'm going to add this bit back

27:26.600 --> 27:33.640
in to make it split it up. Again, take it as you wish. What I'm trying to say is above paragraphs,

27:33.640 --> 27:37.320
above the box, and there's just like, look, Casey has read and looked a lot of it. Like,

27:37.320 --> 27:41.000
what you're talking about, he seems like these nanoseconds even matter, like everything seems

27:41.000 --> 27:45.960
to be nanoseconds modules, which he says, like, all this makes no sense. And then he again,

27:45.960 --> 27:49.560
he replies with, well, I'm one of the signatories of the agile manifesto who still believes to be

27:49.560 --> 27:57.880
a bit up front of architecture design. Okay, why bring that up? Sure, but fine. This is the

27:57.880 --> 28:01.480
bottom line, of course, is that single factor analysis is always suboptimal. There's no one

28:01.480 --> 28:04.920
true way point. I've always made several times in clean code. And it's like,

28:06.600 --> 28:10.280
but they may not be one true way, but you do kind of suggest there's a default you should go to.

28:10.360 --> 28:21.240
And there are arguments for that. Okay. Casey has a lot of questions to ask already,

28:21.240 --> 28:24.920
all of this. Again, I recommend watching this. Now, Casey says here is like, I watched a multi

28:24.920 --> 28:30.120
part series at six parts six, and it's like nine hours he watched, not once in that one second

28:30.120 --> 28:34.520
of it of that nine hours was in to go to get towards performance. And again, Mr. Martin says

28:34.520 --> 28:38.760
it's fair criticism, absolutely fine, no problems. But again, I'm just going to show you here,

28:38.760 --> 28:42.440
it's like, yeah, so thank you for the nudge kind of thing. Like, oh, next time I'll do,

28:42.440 --> 28:46.760
I'll put a nudge in towards performance. It's like, been doing this for decades.

28:49.800 --> 28:52.920
Hmm. Okay, so clearly you don't see, like, but like,

28:54.360 --> 28:57.240
he's kind of butchering up trying to be polite or like, as you would, like you're trying to be a

28:57.240 --> 29:00.520
conversation light always be polite someone as well and try and be nice and kind to a certain

29:00.520 --> 29:06.520
extent, maybe always nice, but kind at least kind. But yeah, it's always kind of those kind of things

29:06.520 --> 29:12.440
and after some reflection, blah, blah, blah. I'm just trying to go through over this again.

29:13.320 --> 29:16.120
This is like, it's fine, not just all the conversation again, it's a lovely conversation

29:16.120 --> 29:18.920
between two people trying to be just being honest between each other, not being horrible.

29:20.760 --> 29:24.840
Casey was also showing off this video, which if I believe it's correct, he was just kind of

29:24.840 --> 29:29.080
they were just joking about how slow is right GitHub, literally intent of just slowing down

29:29.080 --> 29:33.960
along with the paragraph God. And they actually found after a while, why this was the case.

29:34.840 --> 29:40.120
The thing they found out was that it was the code was looking back to the beginning of the

29:40.120 --> 29:43.720
paragraph, looking for a colon, if it found a colon, and it was near the beginning,

29:44.360 --> 29:51.240
it was going to then expand this to be a emoji. That was what the bug that think the slowness was.

29:51.240 --> 29:55.560
So if you just, as Bob made his joke, like, oh, if I just replace everything, the spaces with

29:55.560 --> 29:59.880
the colons is instant, there's no slowdown because it's found the colon, found it's not an emoji

29:59.880 --> 30:04.200
and doesn't do the search anymore. And that's how slow, like, even though they were talking

30:04.200 --> 30:07.960
about the complaining like slow codes, like, look how dumb this algorithm was in the web

30:07.960 --> 30:11.560
browser. And it's just trying to do this. Now, one little thing I found a bit weird,

30:11.560 --> 30:15.960
he says, I created this using going vi and I use this like replacement thing, because really,

30:15.960 --> 30:23.560
I'm an old C hacker at heart. I'm like, what? What does that even mean? This just seems like a,

30:23.560 --> 30:29.640
I'm an old C hacker at heart. I'm like, this has this is one, this is just, you're like vi or

30:29.720 --> 30:34.920
vim or whatever you want to stuff. And then you've just done a regex for text replacement. And

30:37.160 --> 30:41.160
this has nothing to do with C. I know what he's trying to say. Oh, it's just really low level

30:41.160 --> 30:46.840
I'm doing all this. I'm like, what? Sorry, we just need one of those things like the what?

30:47.800 --> 30:51.400
Right, kind of bit interesting here. So then there's the again, recommend if you want to

30:51.400 --> 30:53.800
read the links in the bar for all this. So you don't I'm not trying to read the

30:53.800 --> 30:58.600
descriptions here. I'm just trying to go over it. So now they figured out the things,

30:58.680 --> 31:02.200
the slowness of GitHub, they've gone gone back pivoting up back to this talking about the stuff

31:02.200 --> 31:08.120
about clean code again, capital C, capital trademarked, and explaining all that. And

31:09.000 --> 31:12.680
some of the weird things like for instance, the descriptive names things, like,

31:13.640 --> 31:17.960
I think everybody agrees with the descriptive names. This is not clean code exclusive to clean

31:17.960 --> 31:26.040
code tests. This is one where he's more of a test driven development, while cases more of a,

31:26.040 --> 31:30.600
it's more of a how they do frame it later on. In fact, I think Mr. Martin rephrases this quite

31:30.600 --> 31:36.360
well, that he prefers like why you should write a test if you don't see a reason not to. And cases

31:36.360 --> 31:40.280
more in the camp, I write a test when I need a reason to kind of thing. And they're just

31:40.280 --> 31:44.200
they're not bad. One's more test driven. One's more of a, like a more of a base of regression

31:44.200 --> 31:48.440
kind of thing or like other testing is more of a, I'll write tests when I need to because

31:48.440 --> 31:53.800
I do have tests in general, it's just not a like unit tests or general tests of everything

31:53.800 --> 31:58.840
code coverage and all that lot. It's a different thing. I'm not going to criticize test driven

31:58.840 --> 32:02.200
development because it's not necessarily bad in certain domains, but in certain other domains,

32:02.200 --> 32:08.200
it's kind of like not it seems like you're writing more tests than the actual code,

32:08.200 --> 32:13.960
which is not necessarily productive. But whatever, or useful and as many things in here,

32:15.000 --> 32:18.600
yes, it says like, look, cases, I do test as well. But then again, here's the difference he

32:18.600 --> 32:21.800
writes. So Mr. Martin says, I appreciate tests, unless there's a good reason to this and Mr.

32:21.800 --> 32:26.120
Martin and Casey write tests when there is no good reason to when there's a good reason to.

32:26.120 --> 32:31.160
So it's kind of a different distinction here. Now he actually starts quoting again from his

32:31.160 --> 32:36.840
book talking about this and he and he kind of distinguishes between the operand primal and

32:38.360 --> 32:42.920
operation primal he's calling here. So it's kind of the difference between I'm going to call operands

32:44.040 --> 32:48.920
operands variance in this case, because it's a variance and operation. So they're not using

32:48.920 --> 32:52.520
the same hoe gets a little confusing for me. So now they're kind of talking about the different

32:52.520 --> 32:57.640
benefits of using one of these two things. And great stuff here. But then there's one other

32:57.640 --> 33:02.920
term that he brings up in here, which is dependencies. And he's using this in a very,

33:04.600 --> 33:10.760
not the way that most people would use the term dependencies. So a good example of this would

33:10.760 --> 33:15.800
be is calling dependency inversion. So I'm just going to read right, I'm going to say what he's

33:15.800 --> 33:21.720
written because it's, I'm not going to paraphrase it very well if I don't, it says here, that would

33:21.720 --> 33:27.400
be the bottom line if there was one other thing, okay, about dependencies, the cases of switch

33:27.400 --> 33:33.080
statements create an outbound network of dependencies towards lower level modules and

33:33.080 --> 33:37.160
modules in this case, he's talking about like timing and such like that, that kind of module

33:37.160 --> 33:42.760
in this context. Yeah, each case may call to out to these other modules making the fan out of the

33:42.840 --> 33:47.480
switch statement very high. So he's trying to argue against switch statements and trying to say, look,

33:48.120 --> 33:51.800
if you go for the more polymorphic approach, like the inheritance base approach, we have like a v

33:51.800 --> 33:56.360
table with sub typing, which is what I would class is inheritance to begin with any of the emergent

33:56.360 --> 34:01.400
concept of those two things joined together. And he's saying this is going to be making it the fan

34:01.400 --> 34:07.880
out of the switch and very high that this is going to be much bigger. Because it was caramel says

34:07.880 --> 34:12.360
any change to one of these lower level modules can force the switch statement cases, which

34:12.360 --> 34:18.280
statement the video, he's usually prefers the inheritance style not always, you'll get into

34:18.280 --> 34:23.320
that can force switch statement and all higher level modules to depend on on that switch statement

34:23.320 --> 34:29.000
to recompile and deploy it. That can be a very large cost. On the other hand, if one uses dynamic

34:29.000 --> 34:33.480
polymorphism, object oriented, instead of a switch statement, then those compile time

34:33.480 --> 34:38.520
dependencies are inverted. The lower level modules become sub types that depends on the

34:38.520 --> 34:42.920
high level base type. And the source code depends is then point in the opposite direction of the

34:42.920 --> 34:49.320
control flow. This is dependency inversion. It prevents changes at the low level modules from

34:49.320 --> 34:54.040
forcing a wave of recompilation redeployment from sweeping through the system towards high level

34:54.040 --> 35:00.600
modules. So this is just a really weird confusing terminology is just made up in a weird way. I'm

35:00.600 --> 35:05.560
saying who has made it like no, he kind of actually has. I tried searching for this and it's like,

35:05.640 --> 35:09.720
it's not consistent what people mean by that term. And also, when people talk about dependencies,

35:09.720 --> 35:14.520
they usually mean like third party code, usually, or sometimes they talk about dependencies like,

35:14.520 --> 35:17.640
Hey, what does it very dependent on the things like all the bits in the thing like he's talking

35:17.640 --> 35:25.080
about modules, but that these concept of a module is much more like a class than a library. So it's

35:25.080 --> 35:31.400
kind of a very more old fashioned approach before like libraries and packages and modules were more

35:31.400 --> 35:37.240
like standardized in other languages, obviously, but whatever. This is why I'm going to confuse

35:37.240 --> 35:41.880
because the argument he's trying to make. And this is the thing I would personally try to understand

35:41.880 --> 35:49.400
as well is that between the the variance and the operations, the switch statement is closed to the

35:49.400 --> 35:54.040
number of variants. But it's open to the number of operations. Like for instance, you can always

35:54.040 --> 35:59.000
add more operations really easily. You just add a new function with another switch statement inside

35:59.000 --> 36:03.400
of it. And you've now added a new operation to all of these different variants. Yeah.

36:04.840 --> 36:13.480
Whilst the inheritance style is much more open to is more open to various operations this time. So

36:13.480 --> 36:17.000
it's a closed set of operations, but open to numerous amount of different variants. This is

36:17.000 --> 36:21.000
the whole point you have a base class and variants like subtyping from it, the whole point you have

36:21.000 --> 36:26.040
subtypes or whatever, and it's more open that way. So it's a lot more useful to be doing.

36:26.840 --> 36:36.280
If that makes any sense. Yeah, hopefully that's clear. So that's kind of the argument. Now my

36:36.280 --> 36:42.360
point personal view is that which is getting talking in the thing here with the commentary

36:42.360 --> 36:45.560
search is that the most the time you actually have a close set of variants, and usually you

36:45.560 --> 36:49.640
want to add more operations in practice. So because if you've got a close set of variants,

36:50.440 --> 36:55.720
why pretending as if it's completely open, which is what inheritance is for, it allows

36:56.360 --> 37:00.920
everybody to add more variants, even if you don't have control of that capability, you just

37:00.920 --> 37:05.560
extend to it and it's abstracted away. But most people within their own code base, like it's not

37:05.560 --> 37:11.480
going to be used by third party people ever, usually, pretty much isn't. So you in that case,

37:11.480 --> 37:15.560
it's very close set of opera, it's close at variance you have. And usually when you're

37:15.560 --> 37:17.960
modifying code, you actually want to add more operations. It's kind of like a

37:18.760 --> 37:21.320
different thing. And they're solving different problems. You have to understand this. It's just

37:21.320 --> 37:28.680
that the weird oddity here is their argument is actually, you know, the, the, the inherent style

37:28.680 --> 37:32.920
approach, which has all of the operations for each variant bundled with that variant,

37:33.960 --> 37:37.800
it's easier to manage. And the going on about like managing all these different

37:37.800 --> 37:40.600
dependencies and talking about how many different places you have to deal with.

37:40.600 --> 37:44.040
In case you just correctly point out like, Hey, it's just a different win in different ways,

37:44.120 --> 37:49.320
like this independence in version thing, is you're just trying to get complexity. And again,

37:49.320 --> 37:54.120
Mr. Martin says, yeah, like for every program composed of O operations and T types has complexity

37:54.120 --> 37:59.960
of O times T. If we use O, we can cruise T with minimal disruption to increasing O and vice versa.

37:59.960 --> 38:03.080
Well, it's like the switch same as you have increased operations within disruption, but

38:04.040 --> 38:08.200
disrupts source code. Now, I don't think this is true. I don't think the disruption is actually

38:08.200 --> 38:17.000
even equivalent because it's weird. I know we shouldn't be talking about much about this is

38:17.000 --> 38:24.280
not really clean code anymore, but it kind of is related to it. It's just the, but practically,

38:24.280 --> 38:27.560
how would you know which one is more true the case? In my opinion, personal experience, we've

38:27.560 --> 38:31.480
always had a close set of variants. Like if you want to have a new one, fine. But that variant

38:31.480 --> 38:35.960
doesn't really like, okay, we got updated every single place. Now I use Odin. So my switch statements

38:35.960 --> 38:41.080
will yell at me if I'm missing a case by default. It says, Oh, you've not handled this particular

38:41.080 --> 38:45.640
operation for this particular variant, like in this particular case. And I just need to handle it.

38:45.640 --> 38:49.640
Okay, great. That's just better. I know C and C++ and summer languages don't do this by default,

38:49.640 --> 38:53.640
but Odin does. So clearly, that's just a better language can solve those problems. It's not really

38:53.640 --> 38:59.880
a or better tooling in general. It's not really a inherent thing. It's just a tooling problem then.

39:00.600 --> 39:05.880
But then this is where it gets a bit weird. He starts breaking things down to source code

39:05.880 --> 39:11.320
management about runtime source code dependency inversion, and just make some terms up which

39:11.320 --> 39:16.360
are not colloquially understood to be meant in that context. But again, it's the right a lot of text.

39:18.520 --> 39:22.120
Try and make people understand how he thinks. And then Casey just write small amounts.

39:23.000 --> 39:26.680
It's the it is a very big politician thing pad it out. Very good rhetoric. I mean,

39:26.680 --> 39:31.560
he's great at this. This is where I'm praising him, by the way. So again, read it for yourself,

39:31.560 --> 39:35.000
make your own opinion. If you disagree with me tip can tell me in the comments below.

39:35.000 --> 39:38.600
Tell me where I'm wrong. Please tell me where I'm mischaracterizing me. If I'm being too harsh,

39:38.600 --> 39:44.600
if I'm not being harsh enough, if I might work, look, I'm not even it's fine. But he then it is fine,

39:44.600 --> 39:47.320
like just just read it. He's talking about these different things here, like he's

39:47.320 --> 39:51.240
procedural, so it's itself statements, which statements, whatever. And he's calling this a

39:51.240 --> 39:54.680
run time to high run time dependency, when actually, no, we're gonna make this compile time

39:54.680 --> 39:59.400
dispensary when it's on the type site. No, you just switched them around. They're both the same.

40:00.120 --> 40:01.000
So yeah.

40:07.320 --> 40:13.160
So one thing he brings up here, which I thought was interesting. And it through this bit, as well

40:13.160 --> 40:17.480
as the second part, these starts up, I'll explain why he does that in a minute. He brings up, I

40:17.480 --> 40:24.280
would call the canonical case for inheritance. So the canonical case of inheritance is the

40:24.280 --> 40:29.880
data stream. So sorry, if I've been a bit rambling all day, I'm just trying to understand it because

40:29.880 --> 40:35.400
it is weirdly flowing as well. Like the actual thing isn't like, it's a weird discussion. But so

40:35.400 --> 40:39.080
I apologize for that and also apologize for my rambling as well. So hopefully that's okay. But

40:39.080 --> 40:44.760
again, should be all clarified here. Here he does the canonical case for inheritance, which is

40:44.760 --> 40:49.960
literally a stream, a data stream, a file or something like that, and explains that Oh, these

40:50.040 --> 40:54.840
have standard operations, a close set of operations like open, close, read, write, and seek. Again,

40:54.840 --> 40:58.200
these are the five standard functions of the Unix IO driver. And again, these are very

40:58.200 --> 41:03.720
standard functions on all operating systems. So they actually map really well to the

41:03.720 --> 41:07.880
inheritance style of doing things, the very dynamic polymorphism is he's referring it to here,

41:07.880 --> 41:15.640
which is, yeah, it's dynamic dispatch. Subtype polymorphism with v tables. Yeah,

41:15.640 --> 41:19.320
that's what it is. But he's calling it dynamic polymorphism, which is not common term, but he's

41:19.320 --> 41:24.600
whatever is using his own terminology as he needs. But it's saying like, okay, we've got a

41:24.600 --> 41:27.640
closed set of operations, but we have so many different things like files could be anything,

41:27.640 --> 41:31.560
they could be a file, it could be a directory, they could be a piece of hardware on your device,

41:31.560 --> 41:35.720
they could be just a general socket, there could be anything. It's like, it's open to be whatever

41:35.720 --> 41:42.760
it could be. This is literally the canonical case. Why is the canonical case? Because operating

41:42.760 --> 41:48.440
systems make these files an object. They are an object. That's what they have. Like they're an

41:48.440 --> 41:53.640
abstracted away opaque thing with a open like close interface as to what they are.

41:55.720 --> 42:01.000
So he's trying to argue like this is what you meant to do. Now, there's a lovely lovely thing

42:01.000 --> 42:04.280
here is saying like, well, this clearly has to be a thing. And that's why he's trying to get down

42:04.280 --> 42:08.760
this route. He's trying to take the canonical case to show to Casey that hey, you need inheritance

42:08.760 --> 42:13.240
sometimes. And this is the great way. He's completely forgot the conversation is talking

42:13.240 --> 42:18.840
about clean code, which will bite him in the book later to use an American phrase later.

42:21.240 --> 42:26.600
But then there's one this weird thing he does here, where all of a sudden he talks about this

42:26.600 --> 42:34.120
hypothetical compiler, which would be able to you could write in the in the oopy stage,

42:34.120 --> 42:40.280
like an inheritance style, and then completely the compiler would magically make this be a

42:40.280 --> 42:43.400
switch statement if necessary, which is kind of interesting because it's like,

42:45.000 --> 42:48.120
what what benefits would you get from that? Because it seems to be now a textual benefit.

42:48.120 --> 42:51.080
It's like, you're talking about, oh, it's all clumped together. A new variant or you know,

42:51.080 --> 42:56.360
like, but you've some weird things. He just says it's just a really weird hypothetical

42:56.360 --> 43:00.920
scenario just kind of goes into. And they go on for this for a little while. And Casey's like,

43:00.920 --> 43:03.640
I don't understand what you're talking about. Like this doesn't make no difference,

43:04.600 --> 43:10.280
even with this hypothetical case. So Casey goes on a bit more further here, just mentoring

43:10.280 --> 43:14.760
different things. And talk, I try to get what the benefit of dependency inversion is anyway,

43:14.760 --> 43:19.880
and to begin with. And the go on about this, like, look, you've got a clothes interface with opaque

43:19.880 --> 43:24.600
stuff, and different ways of dealing with it. And then we talk about this payroll thing that

43:24.600 --> 43:27.880
they do all these different things. I recommend reading it. But it is going to be this.

43:29.880 --> 43:33.560
Like this is an oopy thing, obviously, you've just defined it to be because it is is defined

43:33.640 --> 43:41.240
to be oopy, sorry. Yeah, okay. Yeah, yeah, yeah, yeah. But again, Casey also kind of says it

43:41.240 --> 43:45.080
could just be sound line functions. There's no reason, whatever, whatever, that's not a problem.

43:45.080 --> 43:48.520
Where am I looking for now? I'm sorry, I'm just trying to skip through this because it just goes

43:48.520 --> 43:56.280
on for quite a while. Okay, so Casey says that hypothetically, you could just not do this and

43:56.280 --> 44:00.840
have it just a union. Because in the example that Casey does when he does the union, the shapes

44:00.840 --> 44:06.600
example in the video is, is this actually a union? It's what I would call a fat struct union or an

44:06.600 --> 44:09.880
open open union where it has a variant and then just open fields. So it's kind of like a table

44:09.880 --> 44:17.240
like thing, a fat struct is a term that's Ryan Flurry kind of popularized. And it's kind of

44:17.240 --> 44:21.720
just like, here's a table of data, all the fields available. But hey, how you can just switch on

44:21.720 --> 44:25.160
it like all this and just do whatever you need to do and just access the data when necessary.

44:25.160 --> 44:29.000
In case you're saying, look, hypothetically, you could do this, you could just have a file type

44:29.000 --> 44:33.400
with all the data that responds to this in this union and deal with it. Because in practice,

44:33.400 --> 44:37.720
there's actually only a certain set of files you could have, you could even have the general case

44:37.720 --> 44:42.120
where it's, it, it will be like a V table. Sometimes it won't use a V tail, but you can always

44:42.120 --> 44:47.080
optimize off that. And there's many different things he's discussing here and such. And he's

44:47.080 --> 44:51.720
talking about the union case. Now, Martin, Mr. Martin goes here and says, look, it seems like

44:51.720 --> 44:56.520
come on, come on, wild up at the agreement on just about everything other than per individual

44:56.600 --> 45:01.480
preference. And it's like, no, he's trying to say, look, but we don't disagree. It's like,

45:01.480 --> 45:05.480
actually, why are you having this conversation? If you don't disagree, you clearly do actually.

45:05.480 --> 45:10.600
And you'll show this later on in part two of this written document. And he says,

45:10.600 --> 45:13.320
thank you for the union collaboration. Now I understand what you're talking about unions,

45:13.320 --> 45:18.280
which is like, okay. And he says, I'll quibble you a bit on the difference between operand

45:18.280 --> 45:21.960
and operation, but I don't think the quibble is particularly important. In the end, it's just

45:21.960 --> 45:26.680
all functions regardless of how you spell it. As for human issue, performance is a human issue.

45:26.680 --> 45:30.760
The computer doesn't know how fast or slow an algorithm runs, but I think that that horse is

45:30.760 --> 45:37.400
dead now. And it's like, no, it isn't. This is kind of the point. And he goes back to his

45:37.400 --> 45:42.600
microseconds, different module things again. And then he then goes, look, we put a break in here

45:42.600 --> 45:47.640
to write extra bit more to go rewrite history and says, look, I'm going to continue us now in the

45:47.640 --> 45:55.320
second document, which is the number two. Because he's trying to like make break here,

45:55.320 --> 45:59.240
and then reframe the entire question in the second document, it's a pivot and a reframe

45:59.240 --> 46:03.960
at the same time, clever rhetoric trick. If you want to do that in an argument, you do that all

46:03.960 --> 46:06.920
the time, you reframe the question. So it's now they're not even talking about the original thing

46:06.920 --> 46:11.400
again. And he's tried to do this. So that's what he's done here. Right. So right at the beginning.

46:13.000 --> 46:16.520
And then Casey's reframed it and put it put it into the beginning. So he's first. So Casey

46:16.520 --> 46:24.920
knew what he was doing. So just don't let's not do that, shall we? Yeah. So Casey wasn't stupid.

46:26.920 --> 46:30.440
He's talking about all this goes back to the payroll example with all this kind of thing.

46:31.080 --> 46:36.680
And Casey's trying to say is like, look, this is not an open problem. You haven't got an open set

46:36.680 --> 46:44.840
of variants. It seems like it's an extremely well defined problem. So why does this need to be like

46:44.920 --> 46:51.880
operand, operand, primal design was in like variant open, rather than variant closed. And then

46:51.880 --> 46:56.440
operation open. So this seems to be both closed. Like it's very weird. Like what, what are you

46:56.440 --> 46:59.880
trying to have in like save developer cycles with like, where's this kind of thing coming from?

47:02.040 --> 47:08.760
And then this has been moved to because he reframed it. It's fine. No problems. He's talking

47:08.760 --> 47:13.960
about the programmer cycles thing. This is the thing he gave this random file he added in here,

47:14.600 --> 47:18.280
which is the, oh, great. Let's do a code golf example, shall we?

47:25.000 --> 47:27.880
Cute surprise. It's like the point is the program cycles, waste management,

47:27.880 --> 47:30.760
programming cycles, it's like, yeah, you just gave me a code golf example.

47:31.560 --> 47:35.720
The worst case of readability possible, like, but it's a code golf. That's the whole point.

47:35.720 --> 47:38.920
People write those things to be compact and human. Like that's what you're trying to say.

47:38.920 --> 47:42.040
Like we're trying to make it easier on like, can you prove my belief not mathematically,

47:42.040 --> 47:46.200
just as I'm sure that you cannot mathematically prove that your favorite style saves more or

47:46.200 --> 47:50.840
less programmer cycles than mine. It's like, so he's already admitting that actually you

47:50.840 --> 47:55.560
can't prove my style is worse than yours style. And it's like, because programmer cycles, like

47:55.560 --> 48:00.760
this is a qualitative thing. He knows he can't measure it. She's actually, I don't think that's

48:00.760 --> 48:03.720
true to be honest with you. It's just that no one's really bothered to do the science because

48:04.600 --> 48:09.560
programming isn't really young discipline or 70 years at best really as a discipline. So it has

48:09.560 --> 48:13.800
no evolutionary like pressure on there yet to say which which things are good or bad. So people

48:13.800 --> 48:18.680
just say random things. So it is literally just like, great, there's not really much science in

48:18.680 --> 48:23.080
computer science. Rather, again, I'm glad the rest of the world calls it informatics for a reason.

48:23.640 --> 48:26.840
I don't know why we don't we call it computer science, even though it's not an empirical

48:26.840 --> 48:31.320
science and it's close to mathematics, but even then it's not really in practice is close to

48:31.320 --> 48:37.560
engineering. It's just confusing term. Okay, confusing term. The dynamic was a dynamic

48:37.560 --> 48:41.480
building and other type of just from typos, whatever I make more than this might be in day

48:41.480 --> 48:47.160
to day life. And he's talking about this. So it says, do we agree so far about this? And it's like

48:52.040 --> 48:55.240
cases kind of like, well, we don't just worry about certain things in the general like in

48:55.240 --> 48:58.920
the specific, I'm still asking the same question about this data stream thing you're talking about.

48:59.800 --> 49:06.520
Then Mr. Martin brings up again, the like, hey, here's something like the read write thing for a

49:06.520 --> 49:13.000
C. These helper functions don't you know to do all the stuff? It's like, but if you had to do it in

49:13.000 --> 49:17.320
your case, we'd have to do a switch statement like this wouldn't we don't you know? Oh, it's like,

49:18.120 --> 49:21.960
look at all the different variations you could hypothetically do this just ugly. Don't you know

49:21.960 --> 49:27.320
it's ugly? By the way, if you this is, this is gonna tangent anyway, I've been writing the

49:27.320 --> 49:31.800
Odin core library and you actually have to do this anyway. Like if you actually have to do like

49:31.800 --> 49:36.680
you do the read at the OS read functions, because the console on Windows at least does not act

49:36.680 --> 49:42.600
like a normal file. In fact, the console on Windows is a UTF 16 document. So that means you have to

49:42.600 --> 49:48.920
write UTF 16 files. If you actually write a UTFT thing to it, you then you have to do a conversion

49:48.920 --> 49:52.120
to do it onto those. It's actually like already or you have to do this edge case. And not just that

49:52.120 --> 49:59.080
the console has other things in it, which are not handled the same as an old file again. So it's a

49:59.080 --> 50:06.520
very kind of have to do this. This is how real world code is not even purely like, oh, the operating

50:06.520 --> 50:10.680
system has dealt this properly. It's like, no, I still have to check if it's a console specifically

50:10.680 --> 50:17.800
and then deal with it. So it's like, I know like, this is not working. Like, yeah, it actually looks

50:17.800 --> 50:24.360
closer to this in real life, even with the, the abstraction on top of what a file is, but I digress.

50:24.680 --> 50:32.600
Yeah. But yeah, it's just interesting. And then again, many different breaks can different edits

50:32.600 --> 50:36.520
here different sections is breaking it up. The VTab we use by Unix, again, most operating systems

50:36.520 --> 50:41.480
do this as well. Things change around significantly. The idos can be loaded at any time, the iodevice,

50:41.480 --> 50:46.200
yeah, that's true. That's took in this details we're talking about. He's talking about code reuse,

50:46.200 --> 50:50.040
great example says the cases. I apologize for trying to be very specific, but I really want to be

50:50.040 --> 50:54.120
actually get to the exact proposal. And it wasn't clear from what could you actually tell me what

50:54.120 --> 50:57.880
the OS interface looks like and how it's implemented. You said, I guess that depends on a lot on

50:57.880 --> 51:02.360
the language and the application. But my understanding is that we're talking about the OS side. So, and

51:02.360 --> 51:08.120
again, it's the, how does the OS implement this, like the, the stream, the file, compared to how

51:08.120 --> 51:12.600
we're doing it in a language is very different. And not just that, again, I thought we were talking

51:12.600 --> 51:19.800
about clean code. But why has it gone down this digression? Just you wait. Let's go get that. Don't

51:19.800 --> 51:25.640
worry. Okay, we're talking about get all crap. Okay, because it just changed. That's, I can probably

51:25.640 --> 51:30.120
guess which day this was written on as well. Like you're saying it seems like it looks like this

51:30.120 --> 51:35.400
somewhere. Is it actually a base class? Is it whatever? Now, Mr. Martin says, okay, here's kind

51:35.400 --> 51:39.960
of the general interface that he's writing C++. Again, he's not answering the question he's asked.

51:39.960 --> 51:49.560
He's done another thing. Whatever, kind of missed the point again. And then he's saying, look,

51:49.640 --> 51:53.640
look, if we look at the, he's trying to say this is less like the code is easy to manage whatever.

51:53.640 --> 51:57.960
Like, yeah, but you've just chosen the canonical example. And he says, look, if I do the dynamic

51:57.960 --> 52:03.320
polymorphism case, so inheritance, I create, I create this file of three files and have to leave

52:03.320 --> 52:07.240
them with a switch case. I've now all of this and look at all these different things I have to define.

52:07.240 --> 52:13.000
I'm like, and cases, well, hold on, since I'm the switch proponent, at least I get to write it,

52:13.000 --> 52:17.640
please. Look again, look what he's just done. He says, well, I've just shown you how to do it.

52:17.640 --> 52:21.320
And look, it's just more complicated. I've had to write files. Oh, no, I'm like cases like,

52:22.760 --> 52:30.440
hold on, hold on. Yeah, and it's kind of doing like this. So it goes on and on,

52:30.440 --> 52:33.640
we just discuss things, but it's like cases like I want to know what the operating system again.

52:36.040 --> 52:39.800
And it's different. Okay. And then cases like we're not even talking about machine cycles again,

52:39.800 --> 52:43.720
I'm just focusing on the program cycles again, what like he's doing again. So I'm like paraphrasing

52:43.720 --> 52:49.720
this poorly ish, but it's kind of just like, I'm trying to show the techniques that he's doing here

52:49.720 --> 52:55.480
that he knows he's doing it. He isn't an idiot. I'm trying to be very careful like this. Mr.

52:55.480 --> 52:59.400
Martin knows exactly what he's doing. Like he's now just made another document on here,

52:59.400 --> 53:04.120
which only he talks about. And it's just he's trying to suggest like, oh, this is the clean code

53:04.120 --> 53:09.320
stuff. And then he's saying this is what clean code is. And I've just got the summation seems

53:09.400 --> 53:14.200
to correlate with what I most people think it is. Because I miss people people keep this understanding

53:14.200 --> 53:19.720
me kind of view. And it's like, wait a minute. So choose carefully names, not unique. Keep function

53:19.720 --> 53:26.040
small. Why keep classes small. Why manage your dependencies, vague as anything. Literally,

53:26.040 --> 53:32.920
be careful with side effects. Okay. Yeah, express yourself in code where possible. How else you

53:32.920 --> 53:37.560
meant to express yourself in code away? It's your programming. Use polymorphers when the type

53:37.560 --> 53:41.800
changes fast in the operations. This is new stuff he's added now. You switched when operating

53:41.800 --> 53:50.920
change fast in the types. Why? Why? And at what cost? And what Harvard evidence have you got?

53:50.920 --> 53:57.720
This is better. And like, you compare it to this and like, you sure? Okay, when possible,

53:57.720 --> 54:04.840
create designs where things that can change fast that change fast are types. Why keep asking this

54:04.840 --> 54:10.200
question? Here's in his even in his summarizations of here, he's actually saying, we'll prefer

54:10.200 --> 54:15.480
polymorphism. So now he's in like, well, I don't see how you got to that conclusion where like,

54:15.480 --> 54:19.640
I'm against switch tamers or something. I'll clear and prefer like default before like all this

54:19.640 --> 54:26.120
and like, you're literally saying it in here in this summarized document. If I'm misinterpreting

54:26.120 --> 54:32.200
it, please tell me again, in the comments or something. I'm just really confused. Like, what?

54:32.760 --> 54:39.560
Right. So Casey comes back again, and he's talking about the internals of this. It's like, okay,

54:39.560 --> 54:43.640
find the device, then you read it and you do this. This is how ring versions, if you understand how

54:43.640 --> 54:49.480
they work internally. Okay, great. There's class, here's the operations. And it's that looks,

54:49.480 --> 54:53.240
you can always do it this way around. And look, I've got a different way of doing it. So just a

54:53.240 --> 54:59.320
union based approach now, with all the data inside of it doing all what we need, whatever.

54:59.640 --> 55:05.240
And that thing that's just is actually trying to show the actual things internally, isn't

55:05.240 --> 55:10.040
it? But yeah, it's kind of like, look, now I don't like vtables, because obviously pretty

55:10.040 --> 55:14.520
much everywhere, because I find them hard to control. So I prefer this. So he says, look,

55:14.520 --> 55:20.920
I have a, not a vtable, but just inline things itself, it's not a table, just inline functions.

55:20.920 --> 55:26.920
So instead of a class, you've now just got inline methods. And this is just general handling

55:27.480 --> 55:31.560
thing, which is interesting. By the way, that should be more better for performance in general,

55:31.560 --> 55:36.520
because a vtable is usually a pointer to a structure of a function tape, like function pointers,

55:37.160 --> 55:40.440
whilst if you're embedding the function pointers, you've got rid of that indirection. So you've

55:40.440 --> 55:44.040
actually got it will be faster in general as well, because you've got rid of the indirection.

55:44.040 --> 55:49.320
It always has a better chance to optimize and even it has slightly better chance of inlining

55:49.320 --> 55:55.560
and slightly. But yeah, that's how compilers work. Sorry, rambling again, again. But I'm

55:55.560 --> 55:58.680
getting off the digression. But cases kind of saying like, look, we could just handle it for

55:58.680 --> 56:04.040
each of them that we could actually have one callback, just one, and we could directly embed

56:04.040 --> 56:09.320
it in the structure. So it's not even in directed anymore. And then we switch on this. Now this is

56:09.320 --> 56:13.800
interesting. You could do it for every single operation. And then look the codes in one place

56:13.800 --> 56:20.360
for this thing. We've now got the best of both worlds in many ways. And why wouldn't you prefer

56:20.360 --> 56:26.600
this way? I think now interestingly, I'm just going to like slightly digression here going into

56:26.600 --> 56:31.480
Odin. And this is what we actually do for the allocator. And I've been doing this for like a

56:31.480 --> 56:39.720
decade, maybe even before Odin. There is the thing sorry, apologize for the digression. This is

56:39.720 --> 56:44.840
clearly unscripted if you didn't guess. Here's the allocator. So we know that we have a built in

56:44.840 --> 56:48.280
concept from an allocator and allocator is just a little data structure with a pointer to a procedure

56:49.000 --> 56:54.920
and appointed to the data. So 16 bytes, you can easily copy this around. So it's usually not

56:54.920 --> 56:58.520
even appointed to the allocator, it's just the allocator itself in memory. And you just get the

56:58.520 --> 57:02.600
values. So that's what you're doing. So there's not an indirection again, because it has to be a

57:02.600 --> 57:06.200
pointer. And notice it's just in line with the function. And not just there's only one function

57:06.200 --> 57:09.560
you think, but there's loads of different allocation operations like yes, it's one function,

57:09.560 --> 57:13.960
you take all the arguments in, and you change the allocation mode is an allocation alloc free,

57:13.960 --> 57:17.640
free or resize query features query and for an alloc non zero. Because sometimes you want to be

57:17.640 --> 57:22.040
allocated without a zero, but by default you want zeroed because it's quite useful. And also it's

57:22.040 --> 57:26.360
pretty much free if you're using like virtual memory, like allocating zero memory is pretty much

57:26.360 --> 57:31.480
free. Because it has to be for security benefits. There's no option to not get it if you ask for

57:31.480 --> 57:37.080
virtual memory. So I'm just trying to show here that I already take advantage of this kind of

57:37.080 --> 57:41.320
approach. And then within every single allocator, I have a switch statement which then pairs each

57:41.320 --> 57:46.120
operation together. So I'm just trying to get off my digression a bit here. So this is what case

57:46.120 --> 57:49.800
is kind of trying to say and you could do this. So you're not having the full on inheritance style,

57:49.800 --> 57:53.560
you just have a switch you could do the blend of the two. And there are benefits to this,

57:53.560 --> 57:59.160
obviously. And you'd have all of this lovely. So because in either case, but this is larger

57:59.160 --> 58:03.320
rather than because it's solely look look up map look up now and to a specific device and it can

58:03.320 --> 58:07.480
be used in either design. Anyway, over the course of the development of the OS, I think the implementation

58:07.480 --> 58:12.040
saves programmers and cycles potentially a lot of them compared to the one I understand believed

58:12.040 --> 58:18.120
you favored by the clean code method. Again, which is interesting because the casey one is

58:18.120 --> 58:22.840
closer to being like, sub typing to a sentence, but there isn't sub typing, it's just like,

58:22.840 --> 58:28.200
here's the abstract thing with a function pointer, deal with it. Which is kind of close to inheritance,

58:28.200 --> 58:32.760
but it's not just one. And it sounds like a minor difference people say, oh, it's equivalent. It's

58:32.760 --> 58:38.040
like, but it isn't equivalent. In fact, it will be faster. You can easily measure it. It'll be easier

58:38.040 --> 58:41.880
to maintain because everything's in there. And not just that, if you add a new operation into

58:41.880 --> 58:44.920
there, every single one will just yell at you anyway, because you've not implemented it.

58:46.280 --> 58:49.960
So if you've got a language that tells you that switch name is not necessarily C or C++,

58:49.960 --> 58:55.480
maybe modern C++, I know, I think. And sometimes C with the, when you have warnings all and

58:55.480 --> 58:58.360
everything will tell you switch name is missing certain cases. But yeah.

59:01.160 --> 59:04.040
And cases look, I don't know if it's a bit of an extract and file, because I'm sick,

59:04.040 --> 59:07.080
but it was the first one you brought up. And it happened to be the contrast,

59:07.080 --> 59:10.760
the two designs in my opinion. So it works, works for me as Casey is saying here.

59:11.960 --> 59:17.800
Here's why I think an enum based design deserves the programmer cycles. In most systems, you don't

59:17.800 --> 59:21.560
know all the functions that are going to be used ahead of time when operating costs are hard boundary,

59:21.560 --> 59:25.480
like a driver, using operation codes instead of virtual function calls allows you to add more

59:25.480 --> 59:31.080
functions dynamically without recompiling all our drivers. In any modern operating system,

59:31.080 --> 59:34.520
multi-threading is a concern. But this is especially true for an operating system,

59:34.520 --> 59:40.200
having the protocol be structured based with an operation code allows us to trivially buffer

59:40.200 --> 59:47.320
operations in things like IO rings and other intermediaries, intermediaries, without writing

59:47.320 --> 59:52.680
any new code. The entire system remains identical. Yeah, I'm just trying to do this. And you just

59:52.680 --> 59:56.920
said, this is by the way, it seems like almost happens in almost all systems, OOP systems,

59:56.920 --> 01:00:01.640
I see, I'm trying to get around pronunciation, say, because eventually they need to serialize

01:00:01.720 --> 01:00:07.880
or something similar. And so they have to write my version as well as the version as their version,

01:00:07.880 --> 01:00:10.840
but they don't seem to realize how much time they're wasting. Like, yeah, this is

01:00:11.720 --> 01:00:16.280
clarifying this point. People think this seems like the clean code will actually save time,

01:00:16.280 --> 01:00:18.760
but it's actually no, you're now forcing another person to write the same thing again.

01:00:19.400 --> 01:00:22.920
And you are actually wasting time, you think you're saving things. But again,

01:00:22.920 --> 01:00:26.440
if you want to know if you're saving time, you're making a statement like this will save

01:00:26.520 --> 01:00:31.240
programmer cycles, like a claim, show the evidence. And don't just say, well,

01:00:31.240 --> 01:00:37.320
my your seniors may agree with me, because they were convinced by my argument. It's like, yeah,

01:00:37.320 --> 01:00:41.800
but where's the evidence, regardless of this authority, this later argument by authority.

01:00:43.000 --> 01:00:47.720
It is the after a while, many people will come out the phase and like, oh, I don't do this

01:00:47.720 --> 01:00:52.360
anyway. But some people don't. And it's like, okay, I never really went through the OOP phase

01:00:52.360 --> 01:00:55.960
myself. Going a bit of a digression here. Sorry, this is completely random today. I know.

01:00:56.680 --> 01:01:03.320
Very, very unstructured. But I went through the modern C++ like 11 phase. So that's what

01:01:03.320 --> 01:01:09.640
12 years ago now, probably a bit before actually, because it was C plus plus zero x for a long time.

01:01:11.720 --> 01:01:14.760
And I remember learning all that stuff. And that was the thing I got caught. I wasn't really

01:01:14.760 --> 01:01:18.840
necessarily the OOP phase. It was that phase. I was learning all that stuff. And it was a while

01:01:18.840 --> 01:01:23.240
took me a few years and after was like, I'm doing all this extra code, writing loads, and I'm not

01:01:23.240 --> 01:01:27.640
getting any more productive. In fact, it's how hard to maintain. I'm writing literally 10 times

01:01:27.640 --> 01:01:31.320
more code than I needed. And they kept telling people kept people kept telling me because I was

01:01:31.320 --> 01:01:35.160
kind of trusting these people who were more thought they were more experienced with me or

01:01:35.160 --> 01:01:37.960
they thought they knew more because they've been doing it for longer. And they were talking from

01:01:37.960 --> 01:01:42.840
positions of authority to a certain extent that they were going, Oh, of course.

01:01:45.080 --> 01:01:47.960
Like, of course, this is going better because I'm telling you it's going to be better. I'm like,

01:01:47.960 --> 01:01:51.240
and then I was kind of believing them. And I was like, it doesn't seem like I'm trusting them.

01:01:51.880 --> 01:01:55.400
But it didn't it didn't seem to the case when I just started programming back to like a normal

01:01:55.400 --> 01:01:59.480
basic C style with switch statements in many cases, and just like normal standalone functions,

01:01:59.480 --> 01:02:04.280
no, not even using methods. I got more productive. My code got smaller, got easier to read,

01:02:05.160 --> 01:02:10.440
just by not doing any of that. And it was kind of like not using not doing any of the stupid

01:02:10.440 --> 01:02:14.360
templates, not doing stupid any of the ownership semantics. I'm not saying ownership semantics

01:02:14.360 --> 01:02:19.240
stupid. I'm just saying the being everywhere was like, look, I just kind of went to more

01:02:19.240 --> 01:02:24.760
pod data was a plain old data data kind of style old fashioned C style, my code just got

01:02:24.760 --> 01:02:29.160
easier to read more maintainable and just everything like from a personal perspective,

01:02:29.160 --> 01:02:33.800
again, I cannot measure this. And the only way I can convince people say, here's my code, here's

01:02:33.800 --> 01:02:38.120
this normal code, which one define easier to read. And that's the only way that's not a measuring

01:02:38.120 --> 01:02:41.880
that's just still like a personal preference thing in the day. This is the problem in these

01:02:41.880 --> 01:02:51.720
discussions. And it is just getting down to that. It's like one side is there is an empirical

01:02:51.720 --> 01:02:56.200
thing to a certain extent, which I'm going to comment right at the end. I will get to this,

01:02:56.200 --> 01:03:01.800
don't worry. But he talks about this saying here at any point things, if we would like to

01:03:01.800 --> 01:03:04.280
buy third parties to allow communication with channels on the devices, blah, blah, blah,

01:03:04.280 --> 01:03:08.600
okay, we're talking about the IO stuff, fine. We're getting nearly getting the answers. So

01:03:08.600 --> 01:03:12.520
Mr. Martin says, okay, I think I see where we're going. So let me say, sure, looks good to me,

01:03:12.520 --> 01:03:17.640
the bullet points you added are after the fact are all quite valid. And the design you picks

01:03:17.640 --> 01:03:21.480
works well in this case. In the first point, you assume that operations will increase beyond

01:03:21.480 --> 01:03:28.200
the two original proposed, as we both agreed, as I wrote in the clean code, which, by the way,

01:03:28.200 --> 01:03:34.280
is not the same as your clean code. Right, when operation periphery more rapidly type

01:03:34.280 --> 01:03:42.120
switch statements are better. So there's that line alone is or another rhetoric trick,

01:03:42.120 --> 01:03:47.080
lovely one, in fact, in my opinion. In the first point, you assume that operations will increase

01:03:47.080 --> 01:03:55.560
beyond the two originally proposed. Okay, as we both agreed, I don't think Casey agreed to anything.

01:03:56.920 --> 01:04:00.840
And secondly, Casey's not calling what he claims clean code, he's trying to understand

01:04:00.840 --> 01:04:06.680
what your clean code is Casey never says his code is clean code, because yours is Mr. Martin's

01:04:06.680 --> 01:04:15.400
clean code with a capital C trademark to kind of think. Yeah. So another little kind of trick he

01:04:15.400 --> 01:04:20.760
does already any can't help himself really. So when operations profite more rapidly type switch

01:04:20.760 --> 01:04:24.920
statements are better. In point two and three, you raise the specter of multi threatening,

01:04:24.920 --> 01:04:29.400
you are of course correct that queuing operations is a lot easier. If you request packets of the

01:04:29.480 --> 01:04:34.600
same type you design no argument there. And the last point proposed a kind of hook for unknown

01:04:34.600 --> 01:04:40.120
and unspecified possibilities in the future. Yeah, so what he says is like, okay, you have the general

01:04:40.120 --> 01:04:44.440
cases and then have a hook for the unknown cases like the open cases. Okay, if you think those

01:04:44.440 --> 01:04:48.760
unknown cases and special are likely, then you should have considered them earlier. But then

01:04:48.760 --> 01:04:52.840
that raises a number of other concerns that we should not likely address in this document. It's

01:04:52.840 --> 01:04:57.720
like, no, no, no. So I think I'll let pass. No, why? Because if you didn't, he has to let that pass

01:04:57.720 --> 01:05:01.880
because it then kind of defeats his point. Because the inheritance approach, which is

01:05:01.880 --> 01:05:06.760
preferred by clean code, is saying that the open case is the open set of variants, the open set of

01:05:06.760 --> 01:05:12.600
operands is the general case. It isn't. Because if you've got a close set, which you know, like

01:05:12.600 --> 01:05:17.960
pretty much always know that 99% of the time 99.99% of the time is going to be

01:05:21.480 --> 01:05:25.560
going to be closed, like pretty much going to be that small set. So you're optimizing for them.

01:05:25.560 --> 01:05:31.080
And then you've got this, the unknown hook cases allow the user to add their own callbacks in there.

01:05:31.080 --> 01:05:36.040
Fine. That's fine. But it says, it says, unlike to consider the head of time, it's like, yeah,

01:05:36.040 --> 01:05:41.640
but you're assuming that those unknown cases are just as common as the known cases. And

01:05:43.480 --> 01:05:48.840
that is actually designing the API. Now the thing is, if you're optimizing for the general case,

01:05:48.840 --> 01:05:53.400
and then you allow a hook in, that hook is not going to be is not going to be any slower than

01:05:53.400 --> 01:05:59.160
if you design it to be always a general case than the specific cases. That's the point he's

01:05:59.160 --> 01:06:04.440
trying to say here. Like, that's why he's letting it pass, because it is literally just as fast

01:06:05.560 --> 01:06:08.920
to do it that way, then to design it all the way around as if it was always unknown,

01:06:09.720 --> 01:06:15.800
as if it was always dynamic polymorphism. Sorry, just say inheritance, be easier,

01:06:15.800 --> 01:06:22.600
because technically what it is in this case. So now where are we? You propose a solution that

01:06:22.600 --> 01:06:26.760
uses dynamic polymorphism, select two types, and then a switch same to select operations.

01:06:26.760 --> 01:06:31.880
I have no problem with this. It works well and satisfies my concerns about dependency inversion.

01:06:31.880 --> 01:06:37.240
I'm like, but it isn't the same kind of dynamic polymorphism that you've ever

01:06:38.120 --> 01:06:42.840
recommended to anybody. So this isn't technically key and code. In fact, anybody who

01:06:42.840 --> 01:06:48.200
would a clean code advocate would read Casey's code of, let me go back to it, this and go,

01:06:48.200 --> 01:06:55.400
that's not clean. So this leads to the problem of clean code is whatever Mr. Martin says it is

01:06:55.400 --> 01:07:00.280
at that moment. It's not like anyone could actually agree on what clean code is because

01:07:00.280 --> 01:07:03.800
it changes from time to time. It's not a well-structured thing. And he's like, that's fine.

01:07:03.800 --> 01:07:09.640
It's like, then why don't you just call it Mr. Martin style? Because it clearly doesn't work.

01:07:10.360 --> 01:07:14.360
It's not clean. And it clearly doesn't work the way he wants it to in every single case.

01:07:14.360 --> 01:07:18.280
But then you shouldn't do it like a dogmatic. And it's like, it's a weird trick. He says,

01:07:18.280 --> 01:07:23.000
look, don't be dogmatic. Don't follow these the rules. But then it's like, well, I won't,

01:07:23.000 --> 01:07:26.440
I don't agree with it anyway. Well, you clearly have some of these rules, don't you? It's like,

01:07:27.640 --> 01:07:33.400
it's that clever trick again. It's the pork barrel naming again. It's the rhetoric over

01:07:33.400 --> 01:07:41.240
rhetoric over again. I'm like, look, even if Mr. Martin style increased programmer cycles,

01:07:41.960 --> 01:07:47.880
the decrease of wasted programmer cycles, like, whatever. Great. But how do you prove this is

01:07:47.880 --> 01:07:53.560
the case? And we're getting to the end now, and we're just going to do here. So I'm going to

01:07:53.560 --> 01:07:56.920
read the best of it. So, so Mr. Martin's your proposed solution time with thing blah, blah,

01:07:56.920 --> 01:08:00.600
blah, blah. What do you got to this? I will say, however, that that is an ironic that after your

01:08:00.600 --> 01:08:04.120
video and after all the stress that you have been put on saving machine cycles, you eventually

01:08:04.120 --> 01:08:09.720
chose a design that sacrifices machine cycles to save programmer cycles. After all, on the OS side,

01:08:11.400 --> 01:08:16.600
this is where he thinks he has won the argument. Ready? This is what he's tried. He's tried a trick.

01:08:17.480 --> 01:08:22.120
He's tried to do it because he took the canonical case of a stream. After all, on the OS side,

01:08:22.120 --> 01:08:26.920
you've you've got to package up all the quest packets and it's the dynamically dispatched

01:08:26.920 --> 01:08:32.600
handler and then run the operation ID through a switch. And I think we wind up in the same place

01:08:32.600 --> 01:08:36.520
when operations proflate more rapidly than tights, we both use switches, you don't,

01:08:37.160 --> 01:08:40.440
you do not do this. I've read your code, your public code, you don't do this.

01:08:41.640 --> 01:08:46.680
But he's saying he does just pretend you believe it. Okay. When tight for a plate more rapidly

01:08:46.680 --> 01:08:51.160
than operations, we both use dynamic dispatch, we are both willing to sacrifice machine cycles to

01:08:51.160 --> 01:09:00.120
save programmer cycles. No. Also the way again, how Casey structured it will be better because

01:09:00.120 --> 01:09:04.840
it's not technically how many levels in direction do you have before like technically here has

01:09:04.840 --> 01:09:08.440
one level of indirection, which is a function pointer compared to normal inheritance, which

01:09:08.440 --> 01:09:13.320
is three levels of indirection. Why? You've got a pointer to the object, pointer to the vtable,

01:09:13.320 --> 01:09:22.360
then a pointer to the function. Guess which one's going to be faster? Just have a hesitant guess.

01:09:23.400 --> 01:09:27.480
Okay. And not just that, you've then have to go all through this indirection compared to having one,

01:09:27.480 --> 01:09:31.800
which is probably going to be in the literally cash already in the cash ready to be called.

01:09:31.800 --> 01:09:36.040
No problem. It's going to be easily predictable as well for the CPU. It's a very different thing,

01:09:36.680 --> 01:09:43.400
very different operation that is to a generalized vtable. So no, they are not equivalent,

01:09:43.400 --> 01:09:47.720
even in performance. One will be quicker than the other. I'm not doing this video. I could do

01:09:47.720 --> 01:09:50.680
another video if you'd like, but like we could prove it, one's going to be quicker.

01:09:51.720 --> 01:09:57.720
Single indirection compared to triple indirection. Okay. So when we are two individuals on the same

01:09:57.720 --> 01:10:03.560
eye and the only difference being that I wear this shirt and I don't know how to pronounce that word

01:10:04.040 --> 01:10:06.920
with clean code and you have one with clean code, I'm like,

01:10:07.720 --> 01:10:11.800
thank you for simulating the debate. I appreciate your candor and the civility that you exercise to

01:10:11.800 --> 01:10:15.480
and if, if not everywhere, I've come to experience your respect, your knowledge and blah, blah, blah,

01:10:15.480 --> 01:10:22.680
blah, whatever. So the first thing is this is a really dodgy thing. Casey and even cases,

01:10:22.680 --> 01:10:27.640
well, I disagree with most of that. But if we're ending here, I'll just finish my final responses

01:10:27.640 --> 01:10:35.240
for Gail poster poster posterity. And that is the thing. See how he tried to end it. And I'm

01:10:35.240 --> 01:10:38.520
going to read through Casey. I'm not going to comment on it now. I'm just going to read it for

01:10:38.520 --> 01:10:42.200
the end of this video because we've already been going on too long. Sorry. So I apologize

01:10:43.000 --> 01:10:48.360
for my rambling in between. I hope it's kind of an enjoyable if not, and I apologize again. So

01:10:48.360 --> 01:10:51.320
I'm just going to read through this. I'm just going to read Casey stuff. This is all Casey,

01:10:51.320 --> 01:10:56.760
not me. So regarding as I wrote in clean code, which by the way is not the same as your clean

01:10:56.760 --> 01:11:02.840
code? Well, the point is of discussion was your you to elaborate on what is not the same. But

01:11:02.840 --> 01:11:07.400
you're designed for the IO system looks exactly like my clean code example of virtual function

01:11:07.400 --> 01:11:13.400
for every operation, one class per element in the system with no predication. So what are these

01:11:13.400 --> 01:11:18.920
differences that you're referring to? Now would be the now would be the time to explain what they

01:11:18.920 --> 01:11:24.600
are since that was the point of the concrete example. If these are a bad example for accelerators,

01:11:24.760 --> 01:11:30.440
straighten the differences, that's fine. But it was the first one you gave to assumed that it would

01:11:30.440 --> 01:11:39.480
be the one you want to use. Regarding when operations proliferate more rapidly than types,

01:11:39.480 --> 01:11:44.440
switch teams are better. That was not the case here. In no way are operations proliferating

01:11:44.440 --> 01:11:50.680
more rapidly than types in the system. Vendors will add drivers to the OS constantly, perhaps

01:11:50.760 --> 01:11:55.240
monthly or even weekly, whereas the number of operations in a particular system tends to go

01:11:55.240 --> 01:12:00.600
much more slowly, once every few months at a maximum, but more likely once a year for something like

01:12:00.600 --> 01:12:08.520
the aniosis subsystem. It isn't the opposite of what you said. This is an important distinction,

01:12:08.520 --> 01:12:14.280
because what I'm demonstrating here is the opposite of your rule. This is showing that even in the

01:12:14.280 --> 01:12:20.440
case where types proliferate far more rapidly than operations, as in the case of drivers in an OS,

01:12:20.440 --> 01:12:28.200
the principle doesn't work. Enums are better in both cases, specifically because you have

01:12:28.840 --> 01:12:34.920
potentially thousands of types in the system, all different drivers, all the vendors have ever shipped.

01:12:35.880 --> 01:12:40.920
Adding a single operation, however rarely, can cost massive programmer cycles to the

01:12:40.920 --> 01:12:47.640
unnecessary work multiplication across types, the V-tapels course. Another way to say this would

01:12:47.640 --> 01:12:53.720
be enums are more important in a system where type proliferate rapidly, not less. Regarding,

01:12:53.720 --> 01:12:57.560
you eventually chose a design that sacrificed machine cycles to save program cycles.

01:12:58.120 --> 01:13:05.240
I did no such thing. The design achieves both, like why I like it. It's drastically faster to

01:13:05.240 --> 01:13:09.160
use something like a packet-based system than something that is originally proposed design,

01:13:09.800 --> 01:13:16.920
because you do not take a ring transition on every operation. New OS IO APIs are not all designed

01:13:16.920 --> 01:13:22.760
this way. This user writes data without taking in talking to the OS, and a kernel thread picks up

01:13:22.760 --> 01:13:28.120
those data writes. Nobody ever makes a function call, except occasionally to ensure the kernel

01:13:28.120 --> 01:13:34.280
thread hasn't gone to sleep. This is what I mean by the bullet point, if at some point we decide

01:13:34.280 --> 01:13:38.920
users should be able to do multi-threading book IO ops. I am talking about the necessity that

01:13:38.920 --> 01:13:43.880
actually occurred in both Linux and Windows of removing their frequency of ring transitions

01:13:43.880 --> 01:13:49.320
for saving CPU cycles. None of this is trading CPU cycles for programmer cycles. It's achieving

01:13:49.320 --> 01:13:55.960
both. The Linux kernel design of the IOU ring looks like my design. That did not add to save

01:13:55.960 --> 01:14:00.920
programmer cycles. They added it because they wanted the highest possible IO throughput. This is an

01:14:00.920 --> 01:14:06.520
almost universal principle of modern OS design. Anything that can be turned into data writes

01:14:06.520 --> 01:14:12.760
should be, and function calls should be minimized. It's been true for GPUs, for NICs, and for our

01:14:12.760 --> 01:14:18.280
example disk IO. And the last bullet point is regarding, and so I think we wind up in the

01:14:18.280 --> 01:14:24.200
same place when dynamic operations proliferate more rapidly than types we both use, switches,

01:14:24.200 --> 01:14:28.600
when types proliferate more openly than operations we both use dynamic dispatch. Again,

01:14:28.600 --> 01:14:34.280
I don't see how you got there. Obviously types are proliferating more rapidly in this system,

01:14:34.280 --> 01:14:39.560
so that is part, is true. If we didn't believe drivers are proliferating rapidly,

01:14:39.640 --> 01:14:45.640
why are we loading them dynamically? And I thought that was the entire point of the example,

01:14:45.640 --> 01:14:50.520
but perhaps more importantly, we are not using dynamic dispatch here in the way that you've been

01:14:50.520 --> 01:14:54.840
suggesting. As I was pointing out earlier, I said that when I proposed the design process,

01:14:54.840 --> 01:15:00.120
I would also do the inside drivers themselves. I would not duplicate drivers to remove if

01:15:00.120 --> 01:15:04.120
statements and switch statements inside a driver that allowed the drive to handle multiple similar

01:15:04.120 --> 01:15:10.360
devices. The only reason that there are function pointers in this system is because the problem

01:15:10.360 --> 01:15:15.880
definition required that we load the driver from a different module, and we are not presuming a JIT

01:15:15.880 --> 01:15:22.440
or something that can weld, wield, weld things together for us. That introduces a mandatory

01:15:22.440 --> 01:15:28.600
cut so we cannot get rid of it because the problem is defined to contain it. But note that this is

01:15:28.600 --> 01:15:33.000
not the same between our two approaches. I have a function pointer there because it's required,

01:15:33.720 --> 01:15:38.600
and you'll note I minimized the number of all the way down to one. I didn't put it in there

01:15:38.600 --> 01:15:43.160
because I think it saves program time. In fact, I'm not really sure I want it there at all. I

01:15:43.160 --> 01:15:47.880
haven't actually implemented this particular system in an OS, so it's somewhat off the top of my head,

01:15:47.880 --> 01:15:52.760
but it's very impossible that if I actually went to write this, I wouldn't include that function

01:15:52.760 --> 01:15:59.800
pointer at all. Instead, I might just have the OS thread reading the queue, sorry, the OS thread

01:15:59.800 --> 01:16:07.000
reading the queue, and pre-filtering the packets for quota permissions, then updating a shared

01:16:07.000 --> 01:16:12.680
memory access that lets the driver know it can process the packets directly without actually

01:16:12.680 --> 01:16:18.600
implementing. I can't say that's for sure what I would do, but it's probably something I would try.

01:16:18.600 --> 01:16:23.880
So thanks for overstating the similarity of our approaches, but I think that they're similar,

01:16:23.880 --> 01:16:29.000
then I guess that's just where we end up. Thanks for taking the time to create this thread which

01:16:29.000 --> 01:16:34.680
pushed the GitHub emoji to check a well beyond its limits. Sorry, I had to read all that, but yeah,

01:16:34.680 --> 01:16:38.680
that was all right. So this is kind of the point I was trying to point out is that case was saying

01:16:38.680 --> 01:16:44.200
this isn't what you were showing, and the point where I say like Mr. Martin thought he won the

01:16:44.200 --> 01:16:49.800
argument, like you need to use this style, is by using the canonical case of requiring it,

01:16:49.800 --> 01:16:53.240
which is the canonical case is a data stream, a canonical case of like you've got different

01:16:53.240 --> 01:16:59.240
operations fixed interface, but you've got an opaque different what it actually variant type,

01:16:59.240 --> 01:17:03.320
whatever it is. And then they talk about actually how does it implement the operating system case,

01:17:03.320 --> 01:17:06.680
it actually just shows that actually effective this is how you do it in Linux. We don't know how

01:17:06.680 --> 01:17:10.600
Windows works kind of, we can reverse engineer it, but like it's not the source code, it's not

01:17:10.600 --> 01:17:17.640
public obviously, because it's a closed source operating system. But that's kind of the the

01:17:17.640 --> 01:17:24.280
issue that's going on here. Mr. Martin thought he won by showing like you already just did dynamic

01:17:24.280 --> 01:17:29.960
dispatch. In case you went, you just find it to have it. And in fact, I didn't even require multiple

01:17:29.960 --> 01:17:35.160
functions acquired one, it's not tripling direct to any single interaction. And I just had a switch

01:17:35.160 --> 01:17:38.120
name in there, because this is also how the operating system does it. And it's better for

01:17:38.120 --> 01:17:44.200
literally CPU cycles and reduced programmer cycles. It's not one or the other. So hopefully this is

01:17:44.200 --> 01:17:49.400
okay. And I'm done now. I was just going to do this. And I was talking about this, we've already

01:17:49.400 --> 01:17:54.360
discussed this, what I've seen was I did a tweet on it mildly. And there were some other things

01:17:54.360 --> 01:17:58.200
I was talking about here on to talk about Mr. Martin, but I didn't in the end be honest with you.

01:17:59.880 --> 01:18:05.320
It was more of a, I'm just showing the rhetoric styles of Mr. Martin. That was it. So I hope you've

01:18:05.320 --> 01:18:11.720
enjoyed this. I apologize. This is about 120 minutes long. So thank you for putting up with

01:18:11.720 --> 01:18:17.320
all this. I wanted to end off with this little thing here is what I wanted in for. So we already

01:18:17.320 --> 01:18:22.120
had this in his code, but someone commented here saying, look, I says, but there's kinds of environments

01:18:22.120 --> 01:18:25.560
though, the parsimony is important nowadays, far and few between the vast majority of software

01:18:25.560 --> 01:18:29.880
requires less than 1% of modern processing. This is the first section we read. What's more

01:18:29.880 --> 01:18:33.400
processes are so cheap and available that is a trivial matter to add more of them to the system.

01:18:33.400 --> 01:18:37.880
Someone replied, I should know this person by the way personally, we do not consider it

01:18:37.880 --> 01:18:41.560
good engineering practice of the person wrote it, not the quote, good engineering practice to

01:18:41.560 --> 01:18:46.440
consume a resource lavishly just because it happens to be cheap in the class of it or Nicholas worth

01:18:46.440 --> 01:18:50.120
one of my actual programming idols out there. And I love this quote because it's kind of as

01:18:50.120 --> 01:18:54.440
viet slaw of worth slaw. However, it doesn't care. It's either name by or bind value. It doesn't

01:18:54.440 --> 01:18:59.480
matter. And then Mr. Martin replies, that depends upon the, which resource you are talking about

01:18:59.480 --> 01:19:03.400
computer cycles, computer cycle, programmer cycles, which should you trade against? And again,

01:19:03.400 --> 01:19:07.160
I don't see what being the odds, but simpler code is easier to write. Our bubble source is

01:19:07.160 --> 01:19:11.640
simpler. The tricky again, it's another trick. It was just last showing the rhetoric trick.

01:19:11.640 --> 01:19:19.160
Simple is actually an overloaded term in programming. And it's an overloaded term in English,

01:19:19.160 --> 01:19:23.240
because simply you need to mean the opposite of complicated, or it can mean the opposite of

01:19:23.240 --> 01:19:28.360
complex. And in the case of complex, the technical term would be simplex. So is it simple as in

01:19:28.360 --> 01:19:34.680
not complicated or simple as in simplex? And he has just done this on purpose. And he knows it

01:19:34.680 --> 01:19:40.920
very well by saying, well, bullsaw is simplex, but it's very expensive. Multiply and multiply by

01:19:40.920 --> 01:19:45.880
repeat about it. So it's simple. Actually, that's how, that's how like AMD processors, not AMD ARM

01:19:45.880 --> 01:19:51.320
processors actually work, by the way, they don't technically implement multiplication. x86 does,

01:19:51.320 --> 01:19:58.520
by the way, ARM does AMD 64. Sorry, I should say, AMD 64 does an x86 in general. It's actually one

01:19:58.520 --> 01:20:03.080
of the only, it's very, very, you find a processor that does this, but they did it. Linear searches

01:20:03.080 --> 01:20:06.600
are simple. Like, yeah, they are simplex. They also may be simpler, faster as well, but they might

01:20:06.600 --> 01:20:14.520
not be. Like, there's a reason. But this is the trick. So I just want to end on that note. So I hope

01:20:14.520 --> 01:20:21.480
you've enjoyed this. Please remember to like that smash button, and to comment in the description

01:20:21.480 --> 01:20:25.240
below. And again, if you want to read any of these links before, I will post them in the description

01:20:25.240 --> 01:20:30.040
of the doobly-doo below below here. And hopefully you've enjoyed this. This is a very unstructured

01:20:30.120 --> 01:20:37.240
ranty talking about Mr. Martin's rhetoric style with regards to clean code, how, and at the end,

01:20:37.240 --> 01:20:41.640
effectively, he just stated exactly what most people thought clean code was stating, and Casey

01:20:41.640 --> 01:20:50.440
went, so I was right about what clean code was. Okay, thank you. So goodbye, everyone, and stay

01:20:50.440 --> 01:20:52.440
tuned for the next video.

