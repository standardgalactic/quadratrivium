Welcome to our tutorial on denoising diffusion-based gender modeling, foundations and applications.
My name is Arash Vathlet, I'm a Principal Research Scientist with NVIDIA Research, and
today I'm very excited to share this tutorial with you along with my dear friends and collaborators
including Karsten Kreis, who is a Senior Research Scientist with NVIDIA, as well as
Ruchi Gau, who is a Research Scientist with Google Brain.
Before starting the tutorial, I'd like to mention that the earlier version of this tutorial
was originally presented at CVPR 2022 in New Orleans.
This tutorial received a lot of interest from the research community, and given this
interest we decided to record our presentation again after the conference, and we'd like
to share this broadly with the research community through YouTube.
If you happen to watch this video, and you enjoy this video, we would like to encourage
you to share this with your friends and collaborators, and hopefully together we can create more
interest around denoising diffusion-based gender models.
If you're watching this video, most likely you'll find me with deep gender learning.
In deep gender learning, we assume that we have access to cliques of samples drawn from
unknown distribution.
We use this cliques of training data to train a deep neural network.
If everything goes smoothly, at the test time, we can use this deep neural network to
draw new samples that would hopefully mimic the training data distribution.
For example, if we use these images of cats to train our deep neural network at the test
time, we do hope that we can also generate images of cute handsome cats, as you can see
in the bottom.
Deep gender learning has many applications.
Mostly the main applications are content generation that have use cases in different
industries, including, for example, entertainment industry.
Deep gender learning can be used for representation learning as well.
If we have a deep gender model that generates really high quality images, mostly the internal
representation in that model can be used also for downstream discriminative applications,
such as semantic image segmentation, as you can see in this slide.
Deep gender models can be also used for building artistic tools.
In this example that you can see on this slide, we have a tool that can be used by an artist
who happens to be just a six-year-old kid to draw a semantic layout of a scene.
This tool can take the semantic layout and generate a corresponding high-quality image
that has the same semantic layout.
If you're a researcher and you watch the landscape of deep gender learning, you're going to see
that this landscape is filled with various frameworks ranging from generative adversarial
networks to virtual autoencoders, energy-based models, and autoregressive models and normalizing
tools.
Historically, the Computer Vision Committee has been using generative adversarial networks
as one of their main tools for training generative models.
In this talk, we would like to argue that there is a new and powerful generative framework
called the Noise and Diffusion Models.
These models obtain very strong results in generation, and we hopefully want to convince
you that these models are very strong and can be used for various applications.
Hopefully, in this talk, we're going to provide you with some foundational knowledge that requires
for using these models in practice, and we're going to even talk about how these models are
currently used for tackling some of the interesting applications that exist in the Computer Vision
Committee.
As I mentioned earlier, the Noise and Diffusion Models have recently emerged as a powerful
generative model of performing cancer.
In these two papers shown on this slide, one from OpenAI on the left side and one from
Google on the right side, researchers observe that you can use the Noise and Diffusion
Models to train generative models on challenging datasets such as ImageNet, and the results
generated by these models is often very high-quality and very diverse, something that we haven't
seen previously with other generative models such as GANs.
The Noise and Diffusion-based models have already been applied to interesting problems
such as super resolution.
In this slide, you can see a super resolution framework that takes a low-resolution Image64x64
dimension and generates high-resolution image in 1024x1024 pixels.
This results show that actually, the Super Resolution Models built on top of the Noise
and Diffusion Models can generate very high-quality, diverse models.
If you're on social media, you've been probably having a hard time not noticing a lot of excitement
that was created around Dolly 2 and Imagine.
These two frameworks are examples of text-to-image generative models that take text as input,
and they generate a corresponding image that can be described using that text.
Using their core, these models use the Noise and Diffusion generative models, and on the
left side, you can see for example Dolly 2 built by OpenAI can actually create this
image of teddy bears skateboarding in Times Square, and on the right side, you can see
Imagine can generate images of multiple teddy bears celebrating their colleague's birthday
while sitting behind a cake that looks like pizza.
This is impressive.
These models can generate very high-quality, diverse images, and they only take text as
input.
Today, not only are we going to talk about diffusion models, we're going to even talk
about how you can use diffusion models to create such models.
Towards the end of the video, Rucci will talk about these applications.
Today's program consists of six main parts, besides introduction and conclusion.
The first three parts that are shown in green are mostly the technical components of the
program.
I'm going to start with part one.
I will talk about the Noise and Diffusion probabilistic models, and after me, Carson
will talk about the score-based generative modeling with differential equations, and
after us, Rucci will talk about advanced techniques, mostly around accelerated sampling
and condition generation.
These parts, each one of them would be roughly around 65 minutes to 45 minutes.
After these parts, we're going to have three short parts around applications, and mostly
computer vision applications that have been recently used diffusion models in their core
to tackle various deep generative learning-related applications.
Finally, we're going to have a very short segment where I will talk about conclusions
of open problems and final remarks.
Before starting, I'd like to mention that our slides, videos, and some content will be
available on this website, so I'd like to encourage you to bookmark this website.
We're hoping to add more content in the future to this website.
Before starting the presentation, I'd like to just mention that we did our best to include
as many papers that we could, and we thought that it could be interesting to the community.
However, due to limited time and capacity, of course, we could not include every paper.
So if there's a particular paper that you are passionate about, you're very excited
about it, and you would like to be included in this tutorial, we apologize that we couldn't
do that, and what we encourage you to send us an email, let us know that there was a
paper that would be interesting to have in our program, and hopefully, in the future
versions of this tutorial, we will try to include those papers as well.
With that in mind, I will start the first segment, the noise and diffusion probabilistic models.
So part one, the noise and diffusion probabilistic model.
Here you can see an image of three cute dogs who are trying to understand the noise and
diffusion probabilistic models, and as you can see, they're a little bit lost.
So let's go over these models and discuss how these models can be generated.
So using diffusion models, officially consists of two processes, a forward diffusion process
that gradually adds noise to input.
This process is shown on this figure from left to right.
It starts from image of this cute cat.
His name is Peanut, he's my cat.
We can start from him, and we're going to add noise to this image one step at a time.
The forward diffusion process does this in so many steps such that eventually on the
right side, we converge to white noise distribution.
The second process is the reverse denoising process that learns to generate data by denoising.
This process is shown on this slide from right to left, and it starts from white noise and
it learns to generate data on the left side by denoising.
So this process will take a noisy image, and it will generate a less noisy version of it,
and it will repeat this process such that it can convert noise to data.
So we're going to dig deeper into these two processes, and we will see how we can define
these processes formally.
Then the forward diffusion process, as I said, starts from data and generates these intermediate
noisy images, by just simply adding noise one step at a time.
At every step, we're going to assume that we're going to use a normal distribution to generate
this noisy image condition on the previous image.
This normal distribution will have a very simple form.
We're going to represent this normal distribution using q that takes this x at the previous
step and generate x at the current step.
So it takes, for example, x1, and it generates x2.
As I said, it's a normal distribution over the current step, xt, where the mean is denoted
by this square root of one minus beta t times the image at the previous step, and this beta
t representing the variance.
For the moment, assume that this beta t is just simply a very small positive scalar value.
It can be like 0.001, some selectors.
Here, this normal distribution basically takes the image at the previous steps.
It rescale this image, the pixel values on this image, by the square root of one minus
beta t, and it adds a tiny bit of noise where the variance of noise is beta t.
So this is just a diffusion kind of we can call per time step, because we had this very
simple form per time step, like per step, in order to generate xt given xt minus one.
Now, we can also define the joint distribution for all the samples that will be generated
in this trajectory, starting from x1, all the way going to x capital T.
Capital T represents the number of steps in our model, and the joint distribution of all
these samples, condition of this input image of peanut, will be the product of conditionals
that are formed at each step.
So this just represents the joint distribution of all the samples that will be generated
on this trajectory using this Markov process.
This is a Markov process that generates one step, that generates examples one step at
the time, given the previous examples.
Now that we know how we can generate samples one step at a time, you may ask me, how can
I now just take this input image and jump to particular time the step?
Do I need to sample, generate samples one step at a time, or can I just take this x0
and generate xt, or x4, for example, here, just directly?
Because in the forward process, we're using a very simple Gaussian kernel to diffuse the
data, we can actually show that because of this simple form, we can first define this
scale.
This scalar alpha bar T is the product of one minus betas from time to step one all the
way up to current step T.
This is just defined based off the parameters of the diffusion kernel, and having defined
this alpha bar T, now we can define a Gaussian kernel or the diffusion kernel that will generate
xt, even x0.
So, for example, we can now generate using this Gaussian kernel, we can sample from x4
given x0, this would be again a normal distribution where mean is same as the input image, really
this square root of alpha bar T defined here alpha bar, and then the variance is also one
minus alpha bar T.
So, just remember that these betas are just parameters of the diffusion process, we can
compute this alpha bar T very easily, and then we can sample from xt given x0 using
this normal distribution, and this we're going to call this diffusion kernel that diffuses
input at time step zero to time step xt.
Recall that if you want to sample from just a simple normal distribution, you can use
the reparameterization trick.
So, if you want to draw samples from xt, you can just set xt to mean plus some white
nose epsilon that is drawn from standard normal distribution, rescaled with this square
root of one minus alpha bar T, which represents just a standard deviation of this normal distribution.
So, using this we can just simply generate samples at time step T given samples at time
step zero, so given x0 we can just diffuse it easily to time step T.
Beta T values are important, these are basically, we're going to call beta T values as the noise
schedule that defines how we're diffusing the data, and this noise schedule, this noise
schedule, designs such that alpha bar T, this alpha bar at the very last step, would
converge to zero, and when this converges to zero, if you just set alpha bar T to zero
here, you're going to see that because the way that the forward diffusion process is
defined, this diffusion kernel at last step given the x capital T given x0 would be just
can be approximately using normal distribution, standard normal distribution.
This basically means that at the end of this process, diffuse data will have just a standard
normal distribution, this is something that we will need later when we want to define a
generative point.
Now that I've talked about this forward process, like how we can diffuse the diffusion
kernel that diffuses data, let's talk about the marginal diffuse data distribution, let's
talk about what happens to data distribution as we go forward in the diffusion process.
So, have in mind that diffusion kernel that generates xt given x0 is different than the
diffuse data distribution, so we're going to use qxt to represent diffuse data distribution,
and in order to obtain this diffuse data distribution, we first need to form the joint
over clean data input data x0 and diffuse data xt, this joint simply can be defined as
product of input data distribution qx0 times this diffusion kernel, which is just a simple
normal distribution, and now we can marginalize at x0, we can just integrate at x0, and this
will give us marginal data diffuse data distribution at times the T.
If we just consider a very simple one dimensional data, and we hear on visualizing on visualizing
the diffuse data distribution at different time steps, on the left side we have data distribution
at times zero, why access represents this just one dimensional random variable and this x axis
represents the PDF probability density function of this random variable at time step zero, this
is just the data distribution visualized for one toy example, one dimensional toy example.
Here you can see the visualization of diffuse data distributions, and as you can see, as we
go in the forward process, we just take this data distribution, we're making kind of this
distribution smoother and smoother as we go forward in time, and eventually it becomes so
smooth that we can just represent this distribution using standard normal distribution, zero mean
unit variance normal distribution. As you see this smoothing process, we can actually show
mathematically this, the diffusion kernel in the forward process, this diffusion kernel here
is kind of applying a Gaussian convolution to the data distribution, so this smoothing
process can be just represented as Gaussian convolution, a convolution in the sense of
like signal processing convolution that takes input data distribution makes it smoother and
smoother. However, we should have in mind that we actually don't have access to these, to input
data distribution and intermediate diffuse data distribution practice, usually we only have
samples from data distribution, we don't have access to the explicit form of the probability density
function of data distribution, right? So even though we don't have access to this distribution
or all the intermediate diffuse distributions, we know how to draw samples from diffuse data
distribution, so in order to generate data from diffuse data distribution, we can just simply
sample from training data x0, and then we can just follow the forward diffusion process,
sample xt to an x0, in order to draw samples from xt, and this is basically the principle
of ancestral sampling that you can just basically use in order to generate data, for example, at times
that t, you can just use the training data, sample from training data, diffuse it and sample
at xt using diffusion kernel, and that will give you samples from marginal data distribution.
Okay, so so far we talked about forward process and how this forward process just smoothens
the data distribution, now let's talk about how we can define a generative model out of this.
In order to generate data in diffusion models, what we can do, we can start from this base
distribution at the end, we know that the diffuse data distribution would converge to
0 in unit variance, standard normal distribution, so we can sample from standard normal distribution
and we can follow the reverse process, where at every step we can now sample from the denoising model
that generates the less noisy version of data given current step, so this is the reverse model
where we now use the true denoising distribution to sample from xt minus 1 given xt.
So we just need to start from xt and just use this true denoising model to generate samples at time step 0.
So the algorithm will be something like this, we sample x capital t from standard normal distribution
and we sample iteratively from xc minus 1 using this true denoising distribution.
The problem here is that in general denoising distribution xt minus 1 given xt is intractable,
we don't have access to this distribution, we can use Bayes' rule to show that this distribution
is proportional to the product of the marginal data distribution at xc minus 1 times this diffusion
at t, this kernel is simple, it's just Gaussian distribution, however this distribution marginal
data distribution is intractable and in general because of this, this product is also intractable
so we don't have it in closed form. Now that we don't have it in closed form, you may say
can I approximate this denoising distribution from data and if yes, what is the best form
I can use to represent that denoising model. So the good news is, yes, we can try to train
a model to mimic this true denoising distribution xt minus 1 given xt and if you want to model
that, the best model that you can use, the statistical model you can use to represent this denoising model
is actually a normal distribution if in the forward process we use very small noise or the variance
of the noise that we're adding at each step is very small. If we know the forward process
at very small amount of noise, we know theoretically that actually the reverse process can be also approximated
using a normal distribution, so this denoising model can be represented using denoising model.
So now that we know this, we can actually define a parametric model to mimic or to train this true denoising model.
So this formally defined our parametric reverse denoising process. Remember that reverse denoising process starts
from noise and generous data by denoising once at a time. We're going to assume that the distribution of data
at time is the capital T at the end of the forward process, so it's the beginning of the reverse process.
It will be standard normal distribution here as soon as data has a standard normal distribution.
We define this denoising distribution. This is a parametric denoising distribution as samples from XT minus from given XT.
We're going to assume that it also can be represented using normal distribution where now mean here is parametric.
It's a deep neural network that takes noisy image XT and predicts the mean of the less noisy version, less noisy image.
So this neural network is the trainable component and then we have also the variance per time step.
This is just think of the sigma T squared as just some scalar value that represents the variance per time step.
And for now just assume that it's just some parameter or we have access to it. We're going to talk about it later.
But the most important part is this mean parameter.
Remember, this is the trainable network and it takes a noisy image at XT and predicts the mean of less noisy image at XT minus 1.
Because it takes an image and predicts an image, we can actually model this using a unit that has the same input and output shape.
Or you can think of it as just a denoising autoencoder that denoises the input image to less noisy level basically.
And we're going to talk about the architecture of this denoising model, this new filter.
Now that we have these definitions, we can define the joint distribution on the full trajectory.
This joint distribution is the product of the base distribution at step XT and the product of conditionals at all these steps at T steps where the condition comes from our denoising model.
This is again just a Markov process and we can define the joint distribution on the full trajectory by the product of base distribution and the product of these individual conditionals on each denoising step.
Okay, so now so far we talked about the forward process, the reverse process. Now let's talk about how we can train these models, how we can train the denoising model.
For training the denoising model, we're going to use variation upper bond that is mostly or commonly used for training by autoencoders.
In the variation upper bond, ideally we want to optimize marginal likelihood of the data under our parametric model.
Here we have this expectation over training data distribution, where we are computing the expected value of the low to likelihood that our trainable model gives to data distribution.
Unfortunately, this is interactive, we don't have access to this quantity here, but we can define variation upper bond, where now we have this expectation over training data, we have expectation over samples drawn from the forward process.
This is forward process, you can think of it as encoder in VAE, that samples from latent space, so you can think of these as latent variable x1 to capital T.
And we have this log ratio here where the nominator is the joint distribution of the samples on the full trajectory that is given by our denoising model, P theta, and in the denominator we have the likelihood of the samples generated by encoder.
This is basically the same objective or same training object, we would see variation of bond in variation autoencoders.
This is exactly the same.
The assumption is that the forward process is kind of like an encoder and the reverse process is the genitive model in VAE.
These two papers, by the way, our papers, the links on our slides are clickable, so if you want to check these papers just find our slides and click on these references and you're going to find the paper.
So these two papers showed that this variation bond can be decomposed to several times that we're going to go one by one.
The first term is just simply the KL divergence from the diffusion kernel in the last step, x capital T given x0 to this base distribution xT.
Remember by definition, the diffusion kernel for x capital T converges to standard normal distribution, which is same distribution we assume for xT.
So we can completely ignore this term because by definition, forward process defines such that at the end of process, samples converge to 0 million units of mass distribution.
So we can ignore this term.
We have this KL term that I'm going to go into details, and then we have this term that can be considered as the reconstruction term in VAEs.
This just measures the likelihood of input clean image, even the noise image at first step under our denoising model.
This term is also very simple, and it has actually structure very similar to this other term.
So for moment, just assume that we can compute this very easily, and we just ignore for a moment.
And mostly we just need to focus on this term, which is the most kind of important term here.
This is the KL divergence between this Q, xT minus 1 given xT and x0 to our denoising model.
This is our parametric denoising model, which is xT minus 1 given xT.
This Q distribution is a pretty well not new distribution.
We're going to call it the tractable posterior distribution.
These samples from xT minus 1, less noisy image, condition on noisy image, xT, and clean image at time step 0.
So it's kind of like you have clean image, you have noisy image, and you want to predict what would be the less noisy variation of this image if you knew what was the starting point, what was the x0 for generating this noisy image.
It turns out that this distribution is also very simple because the forward process is just Gaussian distribution.
The posterior distribution here is also very simple.
This is a pretty good posterior distribution, it's condition on x0. We know what is the starting point.
So this distribution is also normal distribution with mean expressed here.
This mean is just simply weighted average of the clean image and the noisy image at xT.
So it's actually very interesting if you have clean image and you have a noisy image.
If you want to predict what is the distribution of xT minus 1, the mean that this will be normal, this expression is just normal.
And the mean of that normal is just the weighted average of these two images where the weights come from our diffusion process, parametric diffusion process.
Very simple expression and the variance of this distribution is also defined based on the parameters of the forward process.
So you can think of it like this beta tilde t can be computed very easily from the parameters of the diffusion process.
So that we know none of this here, it's interesting.
It's interesting, so we have the scale divergence from this distribution trackable posterior distribution, which is normal.
And then this denoising model, which we assume that is normal as well.
So, now that we have two normal distributions, the scale divergence there.
So I'm just writing down the same scale divergence again.
The scale divergence can be computed analytically for two normal distributions.
We can show that the scale divergence simply just boils down to the squared L2 distance between the mean of this trackable posterior and the mean of the denoising model.
Right, plus some constant terms that we can ignore these constant terms do not depend on any trainable power.
So this just basically scale divergence is very interesting.
It just boils down to the difference between the mean of this denoising, sorry, this mean of the trackable posterior and our denoising model, parametric denoising model, which is represented by mean theta.
And this weight is one over two sigma t squared.
It's just the variance used in the denoising distribution.
So you can ignore for a moment this coefficient.
So we're going to focus on these two terms.
Recall that if you want to generate xt, if you want to generate a sample at times the t, you can use this parameterization trick that we discussed earlier.
And in this paper hall et al. in New York 2020, they observed that you can also express the mean of the trackable posterior distribution I discussed as xt, the input noise image minus the noise that was used to generate that data.
To get this expression, it's very simple, you just need to do some arithmetic operations on this equation and just plug the definition of xt from the parameterization trick.
With some arithmetic operation, you will see that if you basically have a noisy image and you want to predict the less noisy version, right?
If you knew the noise that was used to generate that noisy image, you can just subtract some re-scaled version.
So this is the scaled version of those.
So you can take noise, subtract just some scaled version of that noise from xt to get mean of xt minus one.
This is kind of very interesting information.
So you basically can represent this mean in a very simple form, expression of xt and epsilon, the noise that was used to generate xt.
So this actually is the same noise that was used to generate xt.
Knowing that knowledge, it means that now if we want to parameterize this network, we can use this knowledge in the parameterization of this model.
So we can say that in order to predict this mean of less noisy images, we're going to just take xt and subtract it from a neural network that predicts the noise that was used to generate this xt.
So basically we train a neural network to predict the noise that was used in order to generate xt in order to represent this noisy model.
This is just a parameterization trick.
Instead of just representing the mean of the noisy model directly, what we can do is that we can just represent the noise that was used to generate xt.
And if you have this, you can just subtract this from xt in order to get the mean of the denoising model.
So if you assume this parameterization for the denoising model.
And now we also know that this is true for mu theta t.
If you plot these two expressions into this, you're going to actually get a very simple expression here.
So we have this lt minus one, this is the same term, lt minus one becomes just you need to draw samples from training data distribution, you draw some noise vector from standard normal distribution.
And using this noise vector, you just generate this xt using the few samples using the parameterization trick.
You can now pass this if you sample to your epsilon prediction network, the network that is trained to predict that the noise that was used in order to generate xt.
So it's basically a very simple algorithm.
You draw samples from data distribution, you draw noise, you generate xt from that noise and input data.
And you train a network to predict the noise that was used in order to generate that xt.
And these weights here are just some scalar parameters that comes from this basically one over two sigma t here.
And this is like one over square root of beta t. And these terms that we know, we can compute very easily based on the parameters of the diffusion process.
So you can ignore them for a moment. Think of them as a scalar parameters that we can compute from the diffusion parameters.
So xt minus one can be represented as this weighted objective.
So we're going to just summarize these weights as lambda t. We're going to define a new scalar lambda t.
This lambda t ensures that your training objective is weighted properly for maximum data likelihood training.
So by using this lambda t weights, you're actually maximizing data likelihood.
But however what happens is that this lambda t ends up being very large for small t's and it is small for large t's.
So it kind of monotically decreases for small t's is very high and for large t's is very small.
And this is basically how the maximum data likelihood training is formulated.
However, in this paper by Hoh et al. in Europe's 2020, they observed that if you simply drop these weights or equally just if you simply set these weights to one and train the model using this on the weighted version.
Like if you drop this way, you're going to get very high quality sample generation using diffusion models.
So they introduced this very simple objective that does not have this weighting anymore.
This weighting is one.
So again, this objective simply draws samples from data distribution, draws white noise and randomly samples from one of the time steps from one to capital t.
It generates a diffused sample using the parameterization trick and it trains a model to predict a noise injected.
So it's exactly the same objective without any weighting and it can be done very easily.
And the answer is true that actually with this weighting, you will get very high quality sample generation using diffusion models.
This objective weighting actually plays a key role in getting high quality sample generation in diffusion models.
So if you're interested in checking this area, I would encourage you to check this paper by Hoh et al. published at CUQ 2022 that discuss how you can potentially change this weighting over time to get even better high quality images from diffusion models.
So let's summarize the training and sampling from diffusion models and what we've learned so far.
In order to train diffusion models, the algorithm is extremely simple.
You draw a batch of samples from your training data distribution.
You uniformly sample from these time steps from one to capital t.
You draw some random noise that has same dimensionality as your input data.
And you use the parameterization trick to generate sample at time step t.
You give the sample to your noise prediction network and you train this noise prediction network to predict the noise that was used to generate that diffuse sample.
And to train this you just simply use squared L2 loss to train this noise prediction network.
After training, if you like to draw samples from your diffusion model, you can use the reverse diffusion process to generate data.
So we're going to start from last step x capital t.
We're going to draw samples from standard normal distribution.
And then here we have a full look that walks back in diffusion process starting on capital t all the way to t equals to 1.
At every step we just draw white noise z from standard normal distribution.
Here we're forming the mean of the nosing model.
Remember this is the parameterization we use for the nosing model.
And then we add noise rescaled with the standard deviation of the nosing minus sigma t to generate xt minus 1.
And we can repeat this t times in order to generate x0.
So very simple training and very simple generation process.
So far we talked about training and sampling.
So let's talk about the implementation details of how to form neural networks for the nosing model.
In practice, most diffusion models use unit architecture to represent the nosing model.
This unit architecture often has residual blocks.
So here different rectangles represent residual blocks at different scales.
And these residual blocks often have also self-attention layers in them.
In some layers usually produce self-attention layers.
Remember this unit takes this diffused image, diffused peanut, xt, and it predicts the noise that was used in order to generate this diffuse image.
So this epsilon prediction will be trained to produce the predicted noise that was used to generate this xt.
This network is also conditional time.
It's shared across different time steps.
So it also takes time using some time embedding.
This time embedding can be done using, for example, sinusoidal positional embeddings that are often used in transformers or random free features to represent this time embedding.
This time embedding will be a vector that will be fed to a small fully connected network.
A network consists of a few fully connected layers to access some time representation.
And this time representation is usually fed to all the residual blocks.
In order to combine this time embedding with all the residual blocks, you have a few options.
For example, you can just take this time embedding and do arithmetic sum with all the spatial features in the residual blocks.
Or you can use, for example, adaptive group normalization in order to do this, like to add time embedding into residual blocks.
So I would encourage you to check this paper that discuss fruits and trades between adaptive group normalization and spatial recognition.
So, so far we talked about forward process, reverse process, training, as well as the network's design for diffusion models.
Let's also talk about some of these hyperparameters that we have in diffusion models, mostly beta T schedule, the variance of the forward process and the variance used in the reverse process, sigma T square.
So, one common assumption is that we can, most papers follow Jonathan Hobot of Newripp's 2020 paper, where they use just simply beta T's that are defined using just a linear function.
Just these beta T's are small values and they gradually go to some larger value through some linear schedule.
And it's also common to assume that sigma T square is just equal, set equal to beta T. This works also really well in practice, especially when the number of diffusions steps is large.
But you may ask me, how can I train these palms? Is there any way I can also train beta T and sigma T square?
So, there are a couple of papers that discuss this. One of them is this paper by Kimba Tao at Notives 2022. This paper introduces a new parameterization diffusion model using a concept called signal to noise ratio.
And they show how you can actually train this noise schedule using some training objective. So, they actually propose a method for training these beta T values.
There are also a couple of papers that discuss how you can train sigma T square, the variance of the reverse process.
This first paper here shows how you can use a variational bond that we use for training diffusion models to also train sigma T, the variance of the denuzin models.
And there's only paper here, analytically P.M. by Bobo et al. in ICELER 2022. This paper actually got outstanding paper award this year at ICELER.
And they showed how you can actually post-training, after training your diffusion models, how you can use this to compute the variance of the denuzin model analytically post-training.
So, so far, we talked about how we can train and how we can also pick up these hyperparameters and diffusion models. Let's look at the diffusion process and look into what happens to, for example, images in the forward process.
We call it, in order to sample from time step T, we can use this diffusion channel, and we can use this parameterization trick to generate XT from input image X0.
Here, XT, we know this diffuse sample, in order to analyze what happens to the image, what we're going to do, we're going to use Fourier transform to convert XT to the frequency domain.
So this FXT, you can think of just Fourier transform applied to XT, it's just a representation of the image in the signal, in the frequency domain.
And we know from Fourier transform that this XT can be just represented as Fourier transform of input image, plus Fourier transform of the noise, some together with some weights corresponds to the ways that we use actually in this parameterization trick.
This is just simple rules in Fourier transform.
You should have in mind that most images actually in the frequency domain have a very high response for low frequency, and they have very low response for high frequency content.
And this is because most images are very smooth.
In general, even if they're not super smooth, when you apply Fourier transform to them, you see usually that most images have very high concentration in low frequency, and their high frequency response is very low.
This is very common in most images.
One thing you should also know that if you have a white noise or Gaussian noise and you apply Fourier transform on top of it, in the frequency domain, actually this Gaussian noise can be also represented as just Gaussian noise in the frequency domain as well.
So Fourier transform of a Gaussian noise is itself Gaussian noise, which we can use now here for analysis.
So remember for the small t's, alpha bar t is almost one. So as a result, we actually did the perturbation we apply is very small in the, in the frequency domain as well.
So in frequency domain, because most of our input signal for input image is concentrated at the small t's, and because alpha bar is almost one, we actually don't perturb the low frequency content of the image that most.
And we mostly perturb when we kind of wash out this high frequency content of the image for small t's.
And then for large t's, because alpha bar t, this coefficient here is almost zero. So what happens is that you now push down all the frequency content, so you also push down the low frequency response of the image, and you wash away all the kind of frequency content of the image.
This basically shows that there's kind of a trade off in the forward process. In the forward process what happens is that the high frequency content is perturbed faster than the low frequency content.
So at small t's, most of the low frequency content is not perturbed, it's mostly the high frequency content that is being perturbed.
But eventually at the end of process is a time when we also completely get rid of the low frequency content of the image.
This is very important to also understand what happens in the reverse process, right, so because there's kind of trade off between content and detail, you can think of low frequency response is the main content of image and the high frequency response is just detail in that generation.
These diffuser model kind of trades off between these in different steps, so you can think of when you're training a generative model, the reverse denoising model, for in the large teams, your denoising models becoming specialized at generating low frequency content of the image.
So it's mostly the course content of the image is being generated large t's.
In a small t's, then your denoising model is becoming specialized in generating the high frequency content of the image.
So most of the low level details are generated in the low, low t's, the small t's.
This is also why the weighting of training objective becomes important, right, so because you have a model that is shared in different time steps and this model is responsible for generating course content versus low level details.
By reweighting this training objective, now we can kind of keep balance between how much we want to generate this course content that is visually very appealing usually, versus how much we want to generate the high frequency because that usually we ignore, we cannot necessarily observe them.
And the weighting plays a key role in keeping this trade off, you're balancing this trade off.
So, so far I talked about the fusion was in general, now let's talk about the connections between the fusion was and the VAEs, especially hierarchical VAEs.
In hierarchical VAEs, which one of the examples can be like any VAE work I did a few years ago.
In hierarchical VAEs, we have this deterministic path, you can think of just a resonant that generates data at x at the end, this is just a generative model.
In hierarchical VAEs we usually sample from noise and we inject to this deterministic path and then we go to second group sample from second group condition on the first group, and the after generating this noise we feed it to the, to the deterministic path and we keep doing this, we're just walking down in the hierarchical model.
So the fusion models can be considered as hierarchical models as well, where these diffuse steps are just latent variables in this hierarchical model, the condition dependencies of course different.
And here we're going to discuss like what are the main differences between the fusion was and hierarchical VAEs.
One major difference is that the encoder in VAEs is often trained, whereas encoder, which is the forward diffusion in diffusion models is fixed we're not training the forward diffusion which is using a fixed diffusion process as encode.
That's one major difference. The second difference is that latent variables in hierarchical VAEs can have a different shape and different dimensionality compared to input images.
Whereas in diffusion models we assume that all the intermediate variables have the same dimension as input data.
The third major difference is that in diffusion models, if you think of the noisy model as a generative model, this is actually shared across different steps.
Whereas in hierarchical VAEs, we actually don't make an assumption, we don't share any component in this hierarchical structure, usually.
In hierarchical VAEs, we usually train these models using variational bond, whereas when we're training diffusion models, we're using some different rebating of variational bond in order to drive the training objective of diffusion.
So even though these two are related, they're not exactly the same. There are some trade-offs that occur when we are rebating the variational bond.
So this brings me to the last slide. So in this part, I reviewed the noise and diffusion probabilistic models.
I showed how these models are just simply trained by sampling from forward diffusion process and training a noisy model that simply predicts the noise that was used in order to generate diffuse samples.
We discussed these models from different perspectives. We saw what happens to data as you go in the, what happens to images as you go forward in the diffusion process.
We also discussed what happens to data distribution in the forward process. We saw how data distribution becomes smoother and smoother in forward diffusion.
But of course, like any other deep learning framework, the devil is in the details, the network architecture, objective rebating, or even diffusion parameters play a key role in getting good high-quality results with diffusion models.
So if you're interested in knowing more about important design decisions that actually play a role in getting good diffusion models, I would encourage you to check this paper by other colleagues,
called Elucidating the Design Space of Diffusion-Based Genetic Models by Karas Etal. And this paper discusses important design decisions and how they play a role in getting good diffusion models.
So with that in mind, I'd like to pass the mic and with you to my dear friend and colleague Karsten to talk about score-based genetic modeling with differential courses.
Hello everyone, I'm Karsten, and I will now talk about score-based genetic modeling with differential equations.
In order to get started, let us actually consider the diffusion process that Arash already introduced in his part.
This diffusion process is defined through this Gaussian transition kernel of this form.
But now let us consider the limit of many, many small steps, and each step being very, very tiny.
So how does sampling from this diffusion process and in practice look like?
So from this Gaussian transition kernel, we can just do essentially the parametrization trick, and we take the xt minus one, we scale it down by this one minus beta t square width term, and we add a little bit of noise from the standard normal distribution,
scaled by this square width beta t term.
With beta t, we can actually interpret it as a step size essentially, so if beta t is zero, nothing happens, this term drops out, and also no rescaling of xt minus one happens.
So let's make this a little bit more explicit and write beta t as this delta t times this function beta of t.
So beta t is explicitly our step size, and beta of t is now this time dependent function that allows us to have different step sizes along the diffusion process t.
And now in this limit of many, many small tiny steps, it is delta t that goes to zero.
If delta t goes towards zero or tiny, we can actually tailor expand this square width expression here and obtain this equation at the bottom.
I just copied that over here.
And it turns out that this equation has a particular form.
We can interpret this as some iterative update, like the new xt is given by the old xt plus some term that depends on xt itself.
So this is just a small correction and some noise added.
It turns out that this iterative update will correspond to a certain solution or a certain discretization of a stochastic differential equation, and in particular this stochastic differential equation.
If I wanted to iteratively numerically solve this stochastic differential equation, for instance with an Euler-Maruama solver, then this is exactly the iterative scheme I would end up with.
Let us not get ahead of ourselves.
I'm not sure if everybody who's listening here is an expert in differential equations.
So let us do a one-slide crash course in differential equations, and let us start with ordinary differential equations, which are a little bit simpler than stochastic ones.
Here is an ordinary differential equation that can be written in that form.
So this is now the state that we're interested in. This code, for example, the value of a pixel in an image.
And t is some continuous time variable that captures the time along which this state changes or evolves.
And ultimately one is often interested in the evolution of this state x or this pixel value x of t.
And that is not what we're given an ordinary differential equation. What we've given is an expression for the time derivative of dx to dt in the form of this function f.
So this code, for instance, will be a neural network.
So what does this mean?
This f essentially describes not x itself, but the change of x.
So if you now look here in this graph at the bottom.
So for point x, for a given time t, this f of x now describes the change. So in other words, we could look.
So this f essentially corresponds to an arrow in this graph.
And if I now wanted to get x of t, I would just follow the arrows in this thing here.
So basically you just have to integrate up this differential equation following the arrows to get my final expression x of t.
And that's what I would have to do.
However, in practice, this f is often like highly complex nonlinear function, for instance, like a neural network, and solving this integral here analytically and following these field lines exactly is often not possible.
In fact, one can solve this whole thing iteratively numerically in a stepwise fashion.
So in that case, when we add some point x, we evaluate our neural network or our, well, our nonlinear function f, or function f, yeah, at this x and time t.
And then we do like a small linear step in this direction and access to our old state x.
Continue doing that again evaluate f and again update and so on and so forth.
So we have an approximation essentially to this analytical solution.
So, yeah, and now there are also stochastic differential equations.
And once a little bit more complex, these stochastic differential equations now have an additional term system sigma of x and t times this term omega.
So what is all this.
First of all, Omega, this is called a Vina process.
And what this is in practice is really just Gaussian white noise.
What this means is that our DX of t or ODE equation now has this additional term, which is corresponds to noise injection.
And this noise is scaled by this standard deviation term essentially sigma of x t.
And this has a name, this is a diffusion coefficient.
And in that context also the other term system here is called the drift coefficient.
And we can see that these equations are sometimes written like this explicit form with derivative here.
And sometimes also like this is written on the other side and it becomes a bit of a special expression for the Vina process.
Sometimes this differential equations or stochastic differential equations here also written like this, but this essentially means the same thing for the sake of this talk.
And importantly, keep in mind this omega of t is essentially a Gaussian random variables and strong independent for each team looks like this.
So how does this now look like if I want to solve this stochastic differential equation.
So for example, numerically, so it's a little bit similar to the iterative solution we had here.
So if I'm given a stage, I, I first updated corresponding to my updated corresponding to the drift coefficient, I evaluate that.
So update a little bit with that direction.
But then I also evaluate the diffusion coefficient and add a little bit of noise that is proportional the strength of the noise is proportional to the diffusion coefficient, and additionally also to the to the time stamp.
So if I do this, so each time I do this I made more different noise variables.
So this means there is not a unique solution like there was in the ordinary differential equation case, but there is a lot of noise injected.
So if I do this multiple times, I may get slightly different trajectories.
So over all these trajectories still approximately follow this deterministic F function, but we have additional noise injection.
So, yeah, this is how it may look like.
So I may ask, is there now also like an analytical framework to instead, you know, describe this analytically like it was for the ordinary differential equation case.
So there is, but this is a little bit more involved.
Because now we are not talking about one deterministic solution that we need to describe rather given one state in each at the beginning, we now have a probability distribution over possible states where we could land.
So the definition of these probability distribution that is described by the Fokker-Planck equation, but that is beyond the scope of this tutorial here.
Anyway, I think now you should also have some intuitions for not only ordinary differential equations, but also stochastic differential equations.
Now we can go back to our stochastic differential equation that we had here, and that actually describes the forward diffusion process of diffusion models.
So this is again just copy over the equation from the last slide here at the bottom. And this is now a visualization of how this whole thing looks like in practice more or less.
So let's go through that one by one. On the left hand side, we have some distribution here of x zero, this might be defined through an empirical data distribution or here we have this one dimensional toy distribution.
In a more realistic setting this may represent a distribution of images like images of these cats here.
So now if we simulate this stochastic differential equation forward, we get this green trajectories and they evolve towards this standard normal prior distribution.
And yeah, the images come progressively noisier and noisier as we do this.
So let's also look at the form of this equation and it's kind of intuitive. We see that this is updates or in the DX.
This update direction, it's actually proportional to the negative of the state x we're in. So this means if we have a large pixel value for instance.
It will pull us to go back towards zero. So direction is always is a negative direction corresponding to my, our x.
On the other hand, while all our states are being pulled towards zero as I've just explained, and at the same time we're also injecting noise.
So this makes it intuitive that after a while of simulating this whole process, we end up with this distribution.
It means that every single point basically completely converts itself to just plain noise where, yeah, with mean zero and certain variance.
Here's another animation of that.
Note that throughout this talk, we will make a lot of use of this image of this cat washes cat peanut. We do hope that it will become a little bit famous after this talk, but let's see how that goes.
Right. So, yeah, we have this forward diffusion sd with a drift term and diffusion term, one of them pulls towards the mode of the distribution the other one injects noise.
It may be worth mentioning that in the diffusion model it which are also other differential equations have been used to define other types of diffusion processes, often just take a more general form like this.
Yeah, I don't want to go into too much detail and in this talk we will stick to this equation for simplicity, but all the concepts that we tried in this tutorial also hold for other types of SDS.
The only thing that is important is that these drift kernels and fusion terms here these are basically linear function of X.
Otherwise, we couldn't solve for the probability distributions here, which reminds me the background this where this background in these.
In these pictures here these animations, this actually defines the marginal different probability distribution of the few data, which is your multimodal, and then he becomes union model.
So great, we have not talked about the forward diffusion process, but what about the reverse direction. So, which is necessary for generation.
So, can we also have like some differential equation that is quite sad.
It turns out yes.
There is this result described by an Anderson 1982 and then used in young songs like your paper last year.
So if there is a forward differential equation of this form for STD, then there is a corresponding reverse stochastic differential equation that once in the other direction, but tracks the exact same probability distribution.
So, really like the reverse direction, which generates data from noise, not noise from data.
So, and since we first generate the fusion STD, it looks like this.
And again has drift term and a diffusion term.
It's a diffusion term and the drift term look over all somewhat similar. So the diffusion term is the same thing. So this will be a process that again injects noise.
This drift term also has this same.
X minus one half p to t of X term, but then there was this additional term.
This is this red term and that is very important.
So this is the gradient of the logarithm of the marginal used density probability density of the data.
And this is known as a score function.
So this means, if you now had access to this object here like this score function, we could do data generation from random noise by just sampling or simulating this reverse diffusion STD.
So this in practice and what look like this, like I said, this reverse diffusion STD.
It's really a diffusion process running in the other direction. And so, yeah, simulating this is generative modeling essentially.
So, are we done. So, we can simulate this and generate data.
Well, not quite.
The question is, how do we actually get this score function.
We may have the naive idea, why not learn a neural network for the score function to approximate it, and then we can take this new network, we call this new network as data.
And then we can take this network inside it and our reverse diffusion STD.
And, yeah, so we can simulate it and generate data.
Something we could do, for instance, is draw a diffusion time along this diffusion process.
Now take like data, refused data from this point in the diffusion process samples is QFT of XT.
So we take a neural network that takes us as input, maybe we also additionally give up the time and train this, maybe with some simple square two term, which we minimize.
We train it to predict this score of this diffuse data, this marginal score to diffuse data.
Well, great idea, but unfortunately that doesn't work, because the score of this marginal diffuse data is not tractable or more explicitly this diffuse data density itself QT of XT is not tractable.
We don't have an analytic expression for that, which makes it to a different sense because, well, if we had we could just put NT for zero and get our data distribution that this is what we're interested in modeling in the first place.
So, too bad.
But what we can do is something different, which is now known as denoising score matching. So what we had on the previous slide was just general score matching.
So what we can do is, instead of considering this marginal distribution QFT given X, which corresponds to the full diffuse density.
Let us consider like individual data points X zero and diffuse those. So instead, we consider the conditional density QFT of XT given X zero that distribution actually is tractable.
So that's why it's preserving stochastic differential equation, which is precisely this SDE that we find our forward diffusion process.
For that case, this conditional density QFT of XT given one particular data point X zero, it has this expression, this form. So it is this normal distribution, where the mean is given by the initial point X zero that is now simply scaled down by some gamma of T, which
is a function that starts at one and be cased towards zero. And then we also have some variance, which is the other way around, which starts at zero and grows towards one.
So we can define all denoising score matching objective. So, again, we have, we draw a diffusion time T, we have an expectation over those.
Then we draw a data sample X zero, one particular sample. Overall, we again have an expectation. Then we diffuse that particular data sample.
And now we train it to predict the score of this one particular diffused data sample X zero. And yeah, now this is tractable, you know this is just a normal distribution so we can take the logarithm of this density of this expression for the density and also calculate the gradient.
Great. So, and now there's one very beautiful result. So after this expectation over the data, when we consider that, it turns out that this neural network then will still learn to approximate the score of the marginal data of the marginal diffuse
distribution, which is exactly what we need. And this sort of makes intuitively sense, because this x t that we're feeding to the neural network, this could corresponds to this is noisy right noisy data.
So this could corresponds to many possible different x zeros and many different possible like grant true scores that we we regressed was on practice neural network has to kind of average over those.
And it turns out that, yeah, after this averaging considering the expectation, this neural network will still model the marginal as the score of the marginal diffuse data distribution. And this is exactly what we need.
What we need in our decision model, or more specifically in the reverse genitive SDE for generation.
So, this is great.
So, yeah, in practice diffusion modeling basically boils down to learning this score function.
Let us now talk about a few implementation details here and what people do in practice because that's also crucial.
This is again just copied the denoising score matching formula.
So, how do we actually sample these diffused data points. And so this is really just with time and just sampling again from this normal distribution here so we have gamma times our input x zero.
And then we add noise to us that is scaled by the standard deviation sigma t.
We explicitly write down the star function, how it now looks like. So it's a gradient of the logarithm of this conditional distribution is the given x zero.
Oh, this is a normal distribution. So this is basically some exponential times some stuff.
We have the logarithm and exponential drop out. There's also a, by the way, a normalization constant, but this does not depend on x so it's not important for the derivative.
Anyway, so you advise at this time. So now we can take the gradient of system here.
Now here for x t. This is like the, the diffuse data point that we sampled, we can actually insert this expression here.
Then we get that, but now it turns out all these terms they cancel out this gamma t x zeroes, and also one of those signals, and what we left with a step.
It's interesting, because this means that the score function. It's basically just the, the noise values that we introduced doing the we permit rest sampling of our diffused data, like, minus that noise value and scale with the inverse standard deviation from the fusion.
But still, this is cool.
So, this maybe also suggests us how we should choose our neural network and how we should parameterize this.
More specifically, for instance, we can take this new network and define it by like some, yeah, some other neural networks times minus one and divided by the standard deviation, which is inspired by this salt here.
So if we insert both of the expression for the ground to a score, which is really just this noise value, and also this neural network parameterization, what we left with is this objective here at the bottom.
No, this is interesting. So this means, if I choose this parameterization, our neural network epsilon that amount is basically tasked with predicting noise values epsilon, which are really just the noise values that were used to perturb our data.
This also makes it kind of intuitive for this is called denoising score matching.
Because if our neural network can be nice, can predict those noise values that were used for perturbation, then yeah, we can be nice and reconstruct the original data point x zero.
So there's another implementation detail here.
So, I have kind of arbitrarily motivated that we can use this squared to turn to perform, you know, I think score matching and to regress this function.
And to give different weights to this L2 term to this L2 loss for different points along the diffusion process.
Keep in mind that this is one neural network that just as input gets a noisy state and tea, it's the same neural network for all teeth along the diffusion process.
So, maybe we want to specialize in that with a little bit more for large times along the diffusion process of small times or something like this, and give like different weights to this objective for different times along the diffusion process.
And this is a loss weight in a lot of tea.
So we introduce this loss rating lambda t that the busses.
And it turns out that different loss ratings trade off between like models is different good perceptual quality, like the images and look pretty that we can generate the set and sharp.
And this is no high log likelihood. For instance, if we choose a number of teeth to be exactly this variance of the forward diffusion process here to cancel out the variants in the denominator.
Then this is just an objective that is actually that leads to good high quality perceptual quality outputs.
And if we choose for lambda, for instance, beta of T, which is hyper parameter of the forward diffusion process, then this whole objective that we have corresponds to training our model towards maximum log likelihood.
More specifically, it's kind of a negative elbow.
This is interesting. And it turns out that, yeah, this is exactly the same objectives that we derived with the variational approach and part one presented by our.
And yeah, so this means that there are some deep connections between this variation derivation and actually like score matching and noising score matching in particular.
I would also like to point out that there are like much more sophisticated model parameterizations and loss breaking possible.
I would in particular refer you to this recent paper by Tero Carlos at all, who discusses in quite some detail.
There's another implementation detail I would like to talk about.
So, we know that this variance sigma T squared and of this forward diffusion process for like using individual data points that actually goes to zero as T goes to zero.
But this means that if I sample the T here close to zero, then this loss might be heavily amplified when sampling. Yeah, T close to zero.
And that's for the case when we do not choose lambda already in function to cancel out the sigma spread.
So for some of these for these reasons we sometimes see some tricks and implementations where we train the small time cut off so we prevent sampling teeth that are extremely close to zero.
So in a mental way how this can be fixed, like I said, this is especially relevant training models towards high block likelihood versus lambda T function maybe something like beta of T and the sigma squared is not cancelled out.
In that case, we can perform important sampling with respect to this, yeah, weight of this loss.
So we have an oversampled teeth close to zero and yeah.
So the objective then looks like this. So we oversample small teeth according to the important sample distribution that has most of its weight or small T.
And then we weigh down the confusion of those to the overall loss and with one over our teeth and constant distribution.
And I don't want to go into too much detail but this is a technique you see in several papers.
So here's a visualization of what happens.
So this is not a loss value. The wet is the loss value without an important sampling here. So, yeah, if I sample T close to zero then I have this heavily amplified loss values.
But with important sampling the blue line, the variance is significantly reduced.
Before moving on, it makes sense to briefly recapitulate what we have been doing so far.
So we have been introducing this diffusion modeling framework based on continuous times now, in contrast to the first part presented by Arash, where each diffusion step had a finite size and we overall had a finite number of discrete forward fixed diffusion process steps and also denoising steps.
In this section we have considered a continuous time. This allowed us to introduce this differential equation framework and also to make these connections to score matching.
But it is important to keep in mind that we are still describing the same types of diffusion models in this section. We are just using different tools at a different framework.
So this is important to realise after all we obtained the same objectives as we have seen on the last few slides.
But bear in mind, let us now move on and we will talk now about the probability flow ordinary differential equation.
However, let us first consider the reverse generative diffusion SDE again, that one, so object you have already seen so far.
With this generative reverse diffusion SDE, we can, when sampling random noise from this standard normal prior distribution, we can generate data and more specifically we basically can sample data all along the diffused data distribution, the reddish curves here, the reddish contours here.
It turns out there is an ordinary differential equation called the probability flow ODE that is in distribution equivalent to this reverse generative diffusion SDE.
It will become clear in a minute what exactly I mean with in distribution equivalent.
Let us first have a look at this ODE itself. It is written down here.
In contrast to the generative diffusion SDE, it doesn't have the noise term and also the score function term, which we will then later learn with the neural network, it doesn't have this factor of two in front anymore.
So what do I mean with in distribution equivalent?
When I sample many initial noise values from this standard normal distribution at initialization when I want to generate the data, then simulating all these samples on backwards versus probability flow ODE towards the data.
By doing that, we will sample from the exact same probability distribution, like with the generative diffusion SDE, with the only difference that we don't have this noise anymore.
So how does it look like more specifically? We can see this on that slide.
Here again, we have the probability flow ODE, just that we now have inserted the learned score function as a pattern for the score function.
And now these trajectories defined by this ODE, they look like this.
So we see that when we sample from this standard normal prior distribution on the right, these trajectories they will all flow into the modes of the data distribution.
We see this also at these bluish lines here at the background.
Yeah, so the probability quite literally flows into the modes of the data distribution.
And that's called the probability flow ODE.
Here we have an animation how it looks like.
And I think at this point it should really become clear what I meant with they are the same in distribution and they sample the same distribution.
On the left hand side, we have the SDE that we have that I have introduced earlier already SDE framework.
And we see that these trajectories are zigzagging, I have this noise injection, but I'm still landing at the modes of the data distribution.
Why for the ODE formulation, I now have these pretty like, not exactly straight but more deterministic trajectories that still land in the modes of the data distribution when I initialize some randomly from this prior distribution.
And the visual trajectory on the right is deterministic while this is stochastic.
So this probability flow ordinary differential equation, this is actually an instance of a neural ordinary differential equations which a while ago generated a lot of attention in the literature.
More specifically, we can even see this as a continuous normalizing flow.
So, why should we care, why should we use this probability flow ODE framework.
It turns out that this ordinary differential equation framework that allows the use of advanced ordinary differential equation solvers.
It is somewhat easier to work with ordinary differential equations than with stochastic differential equation.
And there really is a broad literature on how to quickly and very efficiently solve ordinary differential equation.
So we can build on top of this literature here.
But there are more advantages.
This ordinary differential equation, I can run this in both directions, I can run it as generation, where I go from the right to the left, where I sample the noise from a prior distribution and then go to the left to generate data.
But similarly, given a data point, I can also run the probability flow ODE in the other direction and encode this data point in the latent space of this diffusion model, this prior space.
So this is interesting.
And yeah, this allows for interesting applications, for instance, or semantic image interpolation.
And to make clear what I mean with that, let's look at this slide here.
What I'm doing here is I have drawn two noise values, or let's look first at the lower left.
So here we are drawing two noise values in the latent space of the diffusion model and this noise space.
And now I can linear interpolate these noise values in this space.
However, the model was trained in such a way that every sample under this noise distribution, so also every sample along this linear interpolation path between those noise values decodes to a coherent realistic image.
So when I then interpolate, it means that this results in continuous semantically meaningful changes in the data space, right?
And keep in mind, we could not just interpolate directly linearly in pixel space, this would not be meaningful.
But we can do that in noise space and then obtain semantically meaningful interpolations in the pixel space like this.
But because this ODE is so complex, right, under the hood, this means that we will sometimes have some jumps between nodes and such like this.
And we also see this in this animation here.
So in this animation at the top, yeah, we have been doing many of such interpolations one after another.
And yeah, sometimes you see like little jumps, this basically corresponds to that.
So all this is only possible due to this deterministic encoding and decoding path with the probability flow ODE.
I think it's clear that you couldn't do this so easily with a stochastic trajectory.
All right.
So there is another advantage of the probability flow ordinary differential equation.
We can also use it for block likelihood computation as in continuous normalizing flows.
More specifically, we can take a given image or a given data sample, for instance, this image of Arash's cat peanut.
Now we can take peanut and encode peanut in the latent space of our diffusion model.
Now we can calculate the probability of peanuts and coding under the prior distribution of our diffusion model.
And additionally, we take into account this using this instantaneous change of variables formula kind of the distortion of the ODE the volume change along the ODE trajectory.
So the probability of our data sample, in our case, the image of peanut is then given by that expression.
So we're really just using the tricks from the continuous normalizing flow literature here.
What all this means is actually that in their probability flow ODE formulation, diffusion models can also be considered as continuous normalizing flows.
However, in contrast to continuous normalizing flows, we train diffusion models with score matching.
Continuous normalizing flows themselves are usually trained directly with this objective to maximize the likelihood of the data.
However, training with such this objective directly is actually a hard task because for each training iteration, I have to simulate the whole trajectory here and back propagate it through it.
On the other hand, this diffusion model training relies on score matching.
And as we have seen earlier, score matching works quite differently in score matching.
We basically have like we can train for all these different times along the diffusion process separately.
This leads to a much more scalable and robust learning objective.
And yeah, this makes diffusion models very scalable in contrast to these normalizing flows, I would argue.
So I have not talked a lot about these differential equations, derive these, derive them and so on and so forth.
However, how should we actually solve these SDS and ODE in practice?
We have already seen that we can probably not solve this analytically because these SDS and ODE are defined with very complex nonlinear functions, namely these neural networks that approximate the score function.
So let us look at that.
So let's start with the generative diffusion SDE.
So the most naive way to do this is to use Euler-Mariouama sampling.
We have already briefly talked about Euler-Mariouama sampling in this earlier one slide crash course on differential equations.
What we do in that case is we simply evaluate our function here for different for our state t and x, then we propagate for like a small time step delta t.
And we additionally add a little bit of noise, which is also scaled by the time step.
And yeah, so we do this then iteratively one after another given a new step we evaluate again and then add a little bit of noise and so on and so forth.
By the way, as a small comment here, and you may wonder about the sign flip from here to here, this is because our dt is actually negative because we're running from like large time values to small time values and this delta t here is not supposed to be like an absolute step size.
So it's positive.
So this runs out also this enchant to a sampling that I wash talked about in the first part of our tutorial, and most specifically the way he showed us how we can, how we can sample from these discrete time diffusion models.
And this, this can actually be also considered a generative SDE sampler with this particular discretization used in that part.
So let's look at the probability flow ODE. How can we generate that, or using that.
Again, we could basically use Euler's method, which is analogous to the Euler-Maiorama approach and just now without this noise injection.
We would just intuitively evaluate our network and, yeah, the ODE function essentially do a small step, linear step for small time delta t.
We evaluate and continue doing that.
However, this is usually, I think nobody really does this in practice.
In practice, we can hear, as I mentioned earlier, really build on the advanced ordinary differential equation literature and use much better solvers and much better methods and higher order methods in particular.
So what we see for instance is the use of one cutter methods of linear multi stepping methods, exponential integrators.
Yes, there was a lot of literature in that direction.
Yeah, like I just said, adaptive step size when you put a method that's been used, also called the stochastic differential equation actually adaptive step size higher order methods have been used.
We parameterize the ODE has been proposed that also accelerates sampling.
So, yeah, there's a lot of literature in that direction.
And the main reason is that one drawback of fusion models is that sampling from them can be slow and contrast to like sampling from a generative adversarial network or variation auto encoder and such methods for instance, sampling from a differential
model requires many, many function calls on what are specifically neural network evaluations in our case, because during each step of this iterative denoising, we have to call this neural network again so we often have to call it many, many times.
And yeah, so this is why we want to use efficient solvers so that we can reduce this number of neural network evaluations that we have to use.
So now I have talked about how you can use how you can solve the SDS and the ODE and practice, but what should you use, should you actually rather build on the SD or the ODE framework when you want to sample from the model.
So to shine some light into that, let us look at the generative diffusion SD a little bit closer.
So it's like that.
But now we can actually decompose this into two terms.
Right, so this is just from here to here.
And it turns out the first term is really just the probability flow ODE that we have seen already, which itself can be used for deterministic data generation like you're on the right.
But then there is this additional term.
So this code basically corresponds to the noise injection.
And yeah, it has the noise injection here.
So what what do these terms do.
So this probability flow ODE term is essentially responsible for your pushing us from the right to the left here.
And this logical diffusion SD term, what it basically does is for each individual team, it actively pushes us towards correct diffuse data distribution.
But because of this, so when I do ours during my soul during my simulation going from the right to left you're going from noise to data.
If I have ever said, then this logical diffusion SD can help us to correct these errors and actively bring us back to the right data manifold back to the fused data distribution.
So this, yeah, this is an advantage can do some sort of error correction.
On the other hand, it's, it's often slower because this term itself requires a somewhat fine discretization during the solve.
Yeah.
So now let's look at the probability flow ODE.
So in that case, we do not have this SD term.
However, we can now leverage these really fast ODE solvers.
And so this is good when we target very fast sampling.
On the other hand, there is no stochastic error correction going on here.
And because of this, what we see in practice is that this is sometimes slightly lower performing than the stochastic sampling.
When we just look at the quality of the samples.
So to summarize what we see is, if we're not concerned about our budget of like neural network evaluations and we're willing to do like very a lot of steps, then this SDE framework can be very useful.
But if we want to go as fast as possible, then probably the ODE framework is better where we then can leverage these really fast solvers.
It is also worth mentioning that we can do things in between where we have only like this logic in diffusion SDE.
Active a little bit.
We can also, you know, like kind of solve for the first half using stochastic sampling and then afterwards switch to the ODE advanced methods are possible.
I would like to refer you to this paper here with which discusses some of these things in quite some detail.
Next, I would like to talk about a connection between diffusion models and energy based models.
So what are energy based models?
Energy based models are defined like this in an energy based model.
The probability distribution that we want to model the setter of x defined through an exponential to the power of minus a scalar energy function, which is now the function of the data.
And then this thing is normalized by a normalization constant to make sure it's a well defined probability distribution.
This normalization constant is also called sometimes called the partition function.
Furthermore, in this case, I have added a time variable t because this energy based model is now supposed to represent the diffuse data distributions for different t's in our case.
When we want to sample an energy based model, we usually do that by larger than dynamics, which is if we have seen larger than dynamics already.
Basically, this is very closely connected to these stochastic differential equations we have already discussed.
So to do this larger than dynamics sampling, we basically require the gradient of this scalar energy function.
And then we also iteratively update our sample with that.
And we also have like an additional noise term atter and some step size of learning weight atter here.
The important part to realize is when we do when we use these energy based models is that in practice, even though we are learning the scalar energy function.
We only require the gradient of this energy function or more specifically the negative gradient of this energy function for sampling the model at the end.
We do not require the energy function itself, nor do we require the partition function depth setter.
By the way, this atter is implicitly defined through this energy itself that we're learning.
So now it turns out that in diffusion models, what we're basically learning is the energy gradients for all these diffuse data distributions directly.
We are not learning energies, but basically energy gradients.
And one thing I want to add is that because in this EDM spirit, we're directly learning these energies and we have the probability, an expression for the probability distribution while also taking into account this partition function.
Because of this training energy based models can be actually really complex.
This often requires advanced Markov chain Monte Carlo methods, which can be very difficult to deal with.
One of that is available, I would add.
But yeah, diffusion models, we kind of circumvent that and we only directly learn these energy gradients.
Tell me somehow show that and derive that maybe.
So to this end, let's recall again that in diffusion models, our neural network basically we're trying to approximate our model more generally, we're trying to approximate this score function of the diffuse data distributions qt of x.
Now let us suppose that our model is parametrized such that the diffuse data distributions qt are given by this energy based model here.
Right.
So now let us insert this p theta here and yeah through the map.
We apply the logarithm both here, both on e to the minus the scalar energy function and also the denominator.
However, this term drops out because the partition function does not depend on the state x.
And what we are left with is just a negative gradient of the energy.
What does this mean?
So this means that this neural network s that we usually have in diffusion models to model the score function.
It means that it essentially learns the negative energy gradients of the energy model based model that would describe the diffuse data distribution.
So yeah, once again, fusion models kind of circumvent these complications and directly model the energy gradients and say avoid modeling this partition function explicitly for instance which leads to some of these difficulties that we have in classical energy based model training.
Also, these different noise levels that we have in diffusion models. This is actually analogous to a mere sampling and energy based models.
I would like to talk about one more thing about diffusion models, which is unique identity.
It turns out that the denoising model that we're learning in these diffusion models that is supposed to approximate the score function of the diffused data to t of x p.
This denoising model is in principle uniquely determined by the data that we're given and the forward diffusion process.
And not only the score model, so and by learning the score model also these data encodings that we obtain by using the probability flow of the e to deterministically encode data in the latency space.
All this is uniquely determined by the data and the forward diffusion.
What this means is that even if we use different neural network architectures for us and different network initialization, we should at the end recover identical model outputs like identical score function outputs and data encodings in the latency space assuming we have sufficient training data model capacity and optimization accuracy.
This is in contrast, for instance, to generate adversarial networks or variational auto encoders which do not have this property.
Because these models, depending on what kind of architectures we use and what kind of initializations we use, we will always obtain like somewhat different models and yet different data encodings and so on.
This is the unique property about these diffusion models.
Here's an example. What we are seeing here is the first 100 dimensions of the latent code obtained from a random cyber tent image that was encoded in the latency space of a diffusion model using this probability flow or the e approach.
We did this, most specifically Song and I did this with two different models and model architectures that were separately trained.
However, both of these encodings distributions here as we see, they are almost the same, they are almost identical, even though these were different architectures.
With that, I would like to come to a conclusion and briefly summarize.
So in this part of this talk, I have introduced you to this continuous time diffusion framework in contrast to what Arash talked about in step one.
We do not have finite size denoising and diffusion steps anymore and only a finite number of cells.
Rather, we consider continuous perturbations, a continuous forward diffusion process and then also a continuous generative process based on differential equations.
And to train these models, we make connections to score matching, most specifically denoising score matching.
Now, maybe this appeared somewhat complex and mathematically involved.
However, why should he use this differential equation and continuous time framework?
It really has unique advantages as I have shown hopefully and hopefully I can convince you during this part of the talk.
Most importantly, this allows us to leverage this broad existing literature on advanced and fast SCE and ODE solvers when sampling from the model.
This can help us to really accelerate sampling from diffusion models, which is very crucial because they can be slow.
Furthermore, in particular, this probability flow ODE is very useful because it allows us to also perform like these deterministic data encodings and it also allows us to do like local ideal estimation like in continuous normalizing flows and so on.
Additionally, this is overall a fairly clean mathematical framework based on diffusion processes, score matching and so on.
And this allowed us to use these connections to neural ordinary differential equations to continuous normalizing flows and to energy based models, which I think provides a lot of insights into diffusion modeling.
With that, I would like to conclude my part and take the mic to Wicci who will now talk about advanced techniques, accelerated sampling, conditional generation and beyond.
Thank you very much.
Hi everyone. I'm Richie from Google Brain Team. So let's continue our study on diffusion models.
So in the third part, we're going to discuss several advanced techniques of diffusion models which corresponds to accelerating sampling, conditional generation and beyond.
So here's an outline of what we're going to cover in this part. Basically want to address two important questions of diffusion models with advanced techniques.
The first one is how to accelerate the sampling process of diffusion models. We're going to tackle this question from three aspects, advanced forward process, advanced reverse process and advanced modeling, including hybrid models and model distillation.
The second question is how to do a high resolution, optionally conditional generation.
And I will talk about several important techniques to make this happen, especially the general conditional diffusion modeling framework, the classifier classifier free guidance, as well as cascade generation pipeline.
Let's start from the first question, so how to accelerate the sampling process of diffusion models.
To see why this question is important, let's consider what makes a good generative model. So in principle, we want a good generative model to enjoy the pulling three properties.
First, it should be fast to sample from this generative model. Second, we would expect the general model capture most of the major modes of the data distribution, or in other words, they should have adequate sample diversity.
And third, of course, we want the general model to give us high quality or high fidelity samples.
However, there is a generative learning dilemma for existing generative model frameworks. For example, for generating several networks, they are usually fast to sample from, and they can give us high quality samples.
However, because of this discriminative learning framework, there is a decent chance that GANS may miss certain modes of the data distribution.
And the other type of generative models are these likelihood based models, like variational autoencoders or normalizing flows.
So those models are usually optimized by maximizing likelihood or maximizing a variant of likelihood, for example, the evidence lower bound.
So usually this type of models are good at fast sampling, and they are able to capture certain modes of the data distribution because of this maximum likelihood learning framework.
However, usually they lead to subpar sample quality.
On the other hand, the diffusion models are good at both coverage because they are also optimizing the evidence lower bound of log likelihoods, and they are able to generate high quality samples.
However, the sampling of diffusion models is pretty slow, which usually requires thousands of functional calls before getting a simple batch of samples.
So if we can find techniques to accelerate the sampling process of diffusion models, we will get a generative model framework, which enjoys all those three great properties.
That is, we can tackle the dilemma of this generative learning framework.
Before I do that, before diving into details, I would like to recap the general formulation of diffusion models.
So for diffusion models, they usually define a simple forward process which slowly maps data to noise by repeatedly adding noise to the images.
The forward process is defined to map data, or to map noise back to data, and this is where the diffusion model is defined and trained.
In terms of the diffusion model, it is usually parameterized by a unit architecture, which takes the noisy inputs at certain time step, and then it tries to predict the clean samples, or it tries to predict the noise added to this noisy inputs.
So if we think about accelerating sampling, there are some naive methods that immediately come to our mind. For example, in training, we can reduce the number of diffusion time steps.
In sampling, we sample every K time step instead of going over the whole reverse process. However, those naive acceleration methods will lead to immediate voice performance of diffusion models in terms of both the sample quality as well as the likelihood estimations.
So we really need something clever, cleverer than those naive methods.
And more precisely, we want to ask, given a limited number of functional calls, which are usually much less than thousands, so how to improve the performance of diffusion models.
And as a side note, although the following techniques I'm going to discuss take this accelerated sampling as the main motivation, they definitely provide more insights and contributions to diffusion models as we will see soon.
So we will answer this question from three aspects. The first one is advanced forward process, and second is advanced reverse process, and then lastly the advanced diffusion models.
So first let's take a look at some advanced forward process. So recall that the original whole process defines a Markov process, where we start from this x zero, it is the clean sample, and we gradually add noise until it goes to this x big T corresponding to white noise signal.
So QXT, QXT minus one is simply a Gaussian distribution, and this beta T defines the noise schedule, and they are hyper parameters that are predefined before training the models.
So we are interested in the following questions. So first, does this forward process or noise schedule have to be predefined? And does it have to be a Markovian process?
And lastly, does it, is there any faster mixing diffusion process? The faster mixing is an important concept in Markov chain Monte Carlo, as we will discuss later.
For the first work I would like to discuss here is this variational diffusion models. It basically enables us to learn the parameters in this forward process together with the rest of parameters in the diffusion models.
In this case, we can really learn the forward process. So more specifically, given the forward process defined by QXT given x zero, it follows a Gaussian distribution with square root alpha T bar x zero as the mean and one minus alpha T bar as the variance.
So this is the formulation we have learned in part one.
And this work proposed to directly parametrize the variance one minus alpha T bar through a learnable function gamma eta. And this function is definitely by a similar function to ensure that the variance is within the range from zero to one.
Gamma eta T is further parametrized by a monotonic multilayer perceptron by using strictly positive ways and monotonic activations, for example, sigmoid activations.
And recall that in part one, we have learned that these diffusion models are directly connected to hierarchical variational auto encoders in the sense that diffusion models can be considered as a hierarchical variational encoders but with fixed encoder right.
And this model is named as variational diffusion models because it is even more similar to hierarchical variational encoders because we are optimizing the parameters in the encoder together with the parameters in the decoder.
And to optimize the parameters of the forward process, this paper further derive new parametrization of the training objectives in a boring sense. So basically they have shown that optimizing the variational upper bound of the diffusion models can be simplified to the following training objectives.
Note that this gamma eta participates in this weighting of like different L2 norm of different time steps.
This is the training objectives they derive for this great time session. And they have shown that by learning this noise schedule, it actually improves the likelihood estimation of diffusion models a lot, especially when we assume that there are fewer diffusion time steps.
Note that in the second part, we learned that the diffusion models can be interpreted from the perspective of stochastic differential equation and we learned the connection between diffusion models and denoting score matching.
This gives us a hint or a knowledge that the diffusion models can also be defined in the continuous time setting. And in this paper, they explicitly derive this variational upper bound in the continuous time setting with this gamma eta notation.
Basically, they show that when we let this big T goes to infinity, meaning like we have infinity amount of diffusion time steps, this corresponds to a continuous time setting, and then the variational upper bound can be derived in the following formulation.
And here the only difference is that the weighting term of different L2 terms, L2 distance at different time steps equals to the derivative of this gamma eta t function over time t.
And more interestingly, this paper shows that if we define the signal to noise ratio equals to alpha t bar minus one divided by one minus alpha t bar.
And then this L infinity is only related to the signal to noise ratio at the endpoints of the whole forward process.
And it is invariant to the noise schedule in between the endpoints. So if we want to optimize the forward process in the continuous time setting, we only need to optimize the signal to noise ratio at the beginning and the end of the forward process.
And they further show that the in-between process can be learned to minimize the variance of the training objective. And this enables the faster training of diffusion models besides faster sampling.
And another contribution of this work is that they show it is possible to use diffusion models to get state of the art likelihood estimation results.
So before this work, the benchmark of likelihood estimation have been dominated by autoregressive types of models for many years as shown in this figure, but this model shows like actually we can use diffusion models to get a big improvement out of the autoregressive model process.
And one key factor to make this happen is to add further features to the input of the unit. And this, those four features can range from low frequency to very high frequencies.
And the hypothesis for the assumption here is that to get good likelihood estimation, the model you really need to model all the bits or all the details in the input signal, either they are in perceptual or perceptual.
However, new networks are usually bad at modeling small changes to the inputs. So adding those four features, especially those high frequency components can potentially help the network to identify those small details.
And the paper found that this trick doesn't bring like much significant improvements to the autoregressive baselines. However, it leads to significant improvements in likelihood estimation for diffusion model class.
Okay, so next, like paper or method I'm going to discuss is this denoting diffusion implicit models. So in this work, the main idea is like they try to define a family of non markovian diffusion processes and the corresponding reverse processes.
And those processes are designed such that the model can still be optimized by the same surrogate objective as original diffusion models.
We call that this is the surrogate objective right so this L simple where we remove the weighting of each L2 loss term and we just simply take the average of the L2 loss at different time steps.
And then, because they can optimize by the same surrogate objective. So one can simply take a pre train diffusion model and treat it as the model of those non markovian diffusion processes, so that they are able.
We are able to use the corresponding reverse processes to reverse the model, which means like we will have more choices of our sampling procedure.
Okay, so to see how we can define those non markovian forward processes, let's recap the duration of the KL divergence in the variational lower bound.
So we have this LT minus one is defined as the KL divergence between this posterior distribution QXT minus one given XT and X zero, and this denoting distribution P theta XT minus one given XT so this P theta is parameterized by the diffusion model.
And because these two distribution, like both of them are Gaussian distributions with the same variance sigma T square, and this can be written as the outer distance between the the mean of these two distributions times a constant.
Note that these two mean function have been parameterized by like simple linear combination of XT and if so, or the combination of XT and the predicted if so, so if some listen noise added to the queen sample to get XT.
We can further write this KL divergence in the form of lambda T times the outer distance between the true noise if some and the predicted noise if some theta by our diffusion models.
And if we really think about the duration of this LT minus one, we found that if we assume like this lambda T can be after values, because in a surrogate objective we simply set it to one right so it doesn't matter what value this alpha T is originally.
So then we can find that about formulation holds as long as first we have this QXT give X zero, it follows this normal distribution.
And we need to make sure that this XT still equals to this formulation. And we have those two assumptions. First, the follow process, like the posterior distribution QXT minus one, give XT and X zero follows a Gaussian distribution.
And the meaning of this distribution is a linear combination of XT and the epsilon.
And our reverse process to be similar to the posterior distribution, which means it is also a Gaussian, and this new theta is the same linear combination of XT and the predicted noise.
So we can further rewrite, because we know XT equals to a linear combination of X zero and epsilon. So we can replace this epsilon, epsilon by the linear combination of XT and X zero.
And for the reverse process, we can rewrite it as a linear combination of XT and predicted X zero hat. So this X zero hat is defined as the predicted clean sample, given the predicting noise.
So if we make those three assumptions, then we can see that the about duration of our T minus one still holds, which means that we don't really need to specify this QXT, even XT minus one, and we don't need to require to be a common process.
All we need to assume is the posterior distribution of XT minus one, even XT and X zero.
And that's the basic, the, the insights of this, this, like how we can define the non-marcovian forward process, which leads to the same chain objecting as the original diffusion model.
Specifically, so this is the original diffusion process. And now the diffusion process change to the right diagram, where for each XT, it depends on both the XT minus one and the X zero.
And another remaining question is how we specify the linear combination parameters A and B. So note that here we need to specify this A and B such that this QXT given X zero still follows this Gaussian distributions.
At this end, this work defines a family of forward processes that meets the above requirements, which corresponds to specifying the posterior QXT minus one given XT and X zero in this formulation.
So we can similarly define the corresponding reverse process by just replacing this X zero to a predicted X zero hat.
And note that this specifying specification of formulation doesn't require like a specific value of this sigma t-tutor, which means like this sigma t-tutor can be literally arbitrary values.
So that's why it depends, it actually defines a family of forward processes with different values of sigma t-tutor.
And more importantly, if we specify like sigma t-tutor to be zero for all the time steps, this leads to this DDI and sampler where we wish is a deterministic reverse process because this variance is zero here.
And the only randomness comes from the like starting point of the reverse process, which is the starting white noise signal.
And recall that in the second part, we also build connection between the like stochastic reverse process with a probability flow ODE, which is corresponds to a deterministic generative process.
And we can also interpret the DDI and sampler in a similar way. Specifically, this DDI and sampler can be considered as an integration role of the following ordinary differential equation.
And note that here we do a bit of change of a variable where we define this x bar equals to x divided by the scaling factor square root of alpha bar.
And we define this eta to be basically the square root of the inverse signal to noise ratio.
And if we assume this sigma, this epsilon theta to be the optimal model, and then this ODE is equivalent to a probability flow ODE of a variance is floating SDE, which is in the following formulation.
Note that although these two are equivalent, the sampling procedure can still be different, because for the above ODE, we are taking like the sampling process over this eta t.
Well for the second formulation we are taking the, for example, for both of the two equations we use the standard Euler's method, then the second one is taking the Euler step over dt.
And basically, in practice, people find that the first one works better than the second one, because it depends less on the value of t, but it depends directly on the signal to noise ratio of the current time steps.
We also found that with this DDM sampler, we are able to use less time sampling steps, but reach better like performance.
And in terms of why this is true, this, this paper by Carols et al, argues that the ODE of the DDM is favored, because I saw in those two in those three illustrations, especially the third illustration.
The definition of the solution trajectories of DDM always points towards the denoider outputs, while for the first two ODE formulation, the variance preserving ODE and the variance is pulling ODE, which are two very commonly used ODE formulation
diffusion models.
They basically have more like high coverage regions along the trajectories.
So for the DDM, we can see like for the solution trajectories, most of the trajectories are linear and with low coverage.
And it is known that low coverage really means less truncation errors accumulating over the trajectories. So if we use this kind of trajectories, like we will have a smaller chance to accumulate more errors across the trajectories.
Thus, enable us to use like fewer number of diffusion time step, fewer number of sampling steps in inference.
Okay, so the third word I'm going to discuss for advanced, the forward process is just critically down to long-distance diffusion model.
Basically, they are trying to find a faster mixing diffusion process by using certain like background knowledge from Markov Chen and Monte Carlo.
And how this forward process is related to MCMC, let's see, like this is a regular forward diffusion process, which is a stochastic differential equation.
And it is actually a special case of overdone long-distance dynamics. If we assume the target distribution or the target density of this MCMC is this standard Gaussian distribution.
Given this connection, we can actually design more like efficient forward process in terms of MCMC.
Specifically, this word proposed to introduce an auxiliary variable, this velocity V, and the diffusion process is defined on the joint space of this velocity and the input.
And during the forward process, the noise is only added in this velocity space. And this image space or input space is only erupted by the coupling between this data and the velocity.
And the resulting process as showing this figure, we can see that the forward process in the V space is still exact. However, the process in the image space or the data space are much more smoother.
This V components is analogous to the Hamiltonian components in HMC or analogous to the momentum in momentum based optimizers. So by defining this joint space or defining the diffusion in this V space, it actually enables faster mixing and faster traverse of the joint space,
which enables fast, like more smoothly and efficient, more smooth and efficient forward process.
And the second, let's see some advanced reverse process. So before that, we would like to ask a question. So remember that we use this normal approximation of the reverse process, right.
It seems like the denoting distributions are always Gaussian distributions. But if we want to use less diffusion time steps, is this normal approximation of the reverse process still true or accurate?
Unfortunately, the answer is no. So this assumption, normal assumption in this denoting distribution holds only when the adjacent
the noise added between these adjacent steps are small. If we want to use less diffusion time steps in training, then we can see that this denoting distribution is not a unimodal normal distribution anymore.
So they are tend to be like multimodal and more complicated distributions. So in that case, it means like we really need more complicated functional approximators.
So we will talk about two examples of how we can include more complicated functional approximators here.
The first word is this denoting diffusion gains. So in this word, they propose to model the denoting distribution by conditional gain model.
Specifically, the model is training this other several learning framework. And we first get the samples xt minus one and xt by running this forward diffusion process.
And then this generator takes xt as input, as well as the time step as input. And it's actually trying to model the xt minus one. But instead of just directly outputting xt minus one from the network, it's first trying to predict this
screen sample x0. And then it tries to sample xt minus one from this tractable posterior distribution. And then the discriminator takes the real xt minus one and the fake xt minus one prime as input and try to discriminate these two samples.
And again, this discriminator is also conditional xt and the corresponding time step t.
One may ask, what is the benefit of this denoting diffusion gains compared to a one shot gain model.
But this paper shows that because like right now the conditional gains only need to model like the conditional distribution of xt minus one given xt.
This turns out to be a much simpler problem for both the generator and the discriminator compared to directly model the model distribution of the clean sample.
And this simple training objective for the two models leads to stronger mode coverage properties of gains and also leads to better training stability.
And recall that in the second part we learned that there's a close connection between energy based models and diffusion models. So, therefore, a natural idea is like we try to approximate the reverse process by conditional energy based models.
Recall that an energy based model is in the form of P beta x. It is solely dependent on the normalized log density function which is f theta x.
And we can further prime trend is f theta x by minus e theta x. So usually, people call this e theta x as the energy function. And this d theta is the partition function which is usually analytical and tractable.
And we can parameterize this f theta by a neural network which takes the signal as input and output as scalar to represent the value of this f.
And the learning of energy based models can be illustrated as follows. So suppose this is the energy landscape defined by the e theta function.
And after learning, we would like to put the observation data points into the regions of low energy and put all the other inputs to the regions of the high energy.
And optimizing the energy based models require, you really require the MSMC sampling from the current model p theta x as showing this formulation, which is really highly computational expensive, especially for high dimensional data.
So if we want to parameterize the denoising distribution by conditional energy based model, we can start by assuming like at each diffusion time step marginally the data follows a energy based model in the standard formulation.
So here I removed the, the script like the time step script for similar simplicity.
And let x theta be the data at a higher noise level.
So we can derive the conditional energy based models by Bayes and Rowe, but specifically this p x, the x theta is in this formulation.
And if we compare this conditional energy based models with with the original marginal energy based models, we see that the only difference is that there's an extra projected term here.
And this actual projected term actually has the effect of localize this highly multimodal energy landscape to a like more single mode model or uni model landscape, and with the model mode focus around the higher noise level signal x theta.
Therefore, compared to training a single energy based model the sampling here is more friendly and easier to converge because the energy landscape compared to the original marginal energy landscape is more uni model and more and simpler.
So that the training could be more efficient and the conversion and CMC can give us well formed energy potential after training.
And compared to diffusion models, this energy based to using this energy based model to a parameterize the denoting distribution can give enables us to define like much less diffusion steps up to six steps.
And more specifically to learn those models we simply maximize the conditional log likelihoods at each time step.
And then after training we just get samples by progressive sampling from the energy based models from high noise levels to low noise levels.
So the last part comes to the advanced diffusion models, basically want to ask two questions. For first, can we do model distillation so that the distilled model can do faster sampling.
And second, can we lift the diffusion model to a latent space that is faster to diffuse.
So the first idea comes to the distillation so here I want to discuss one representative work in this domain, which is this progressive distillation of diffusion models.
So essentially this work proposed to distill a deterministic DDIM sampler to the same model architecture of the original model.
And it's, it is, it went into this progressive pipeline, in a sense that at each distillation stage, we will have a teacher model, and, and we will learn a student model and this student model is learned to distill.
By each two adjacent sampling steps of the teacher model to one sampling step of the student model. And after learning this student model at next distillation stage.
The student model as a previous stage will serve as the teacher model at this new stage, and then we learn another student model at the new stage.
So we need this process until we can distill the original thousands of sampling steps to a single sampling step.
And implementation wise, the learning of the student model is quite similar to the original diffusion model training pipeline.
The difference is how we define this training target of the diffusion model, specifically, given the teacher model.
And we randomly sample a time step T, and then we draw, we run the sampler for two steps.
And then the target is the, is computed to make sure that the student model can reproduce the two sampling step within one sampling step.
And then the loss is defined as Euro where we minimize the out to distance between this target and the predicted, like X hat from this diffusion model or from the student model.
And after that, we have in the number of sampling steps and repeat this process until we reach one sampling step.
Another idea is like whether we can leave the diffusion models to a latent space, which is more friendly to this diffusion process.
And here's an example of this kind of idea where we can try to leave the diffusion models to a latent space of a pre trained variation of encoder.
In the latent space, the distribution of the data in this latent space is already quite close to the Gaussian distributions, which means like we can definitely use less diffusion time steps to diffuse the data in this latent space.
The advantages are pretty straightforward. So first, because this latent space already close to normal distribution, we are able to use less diffusion time steps to enable faster sampling.
And then compared to the original variational auto encoders, which assume that the prior distribution of the Z follows a single and simple Gaussian distribution.
This kind of hybrid model assume that the PFC is modeled by a diffusion models, which means that it has a diffusion prior. So it definitely will be much more expressive compared to the original variational auto encoder model.
So we can actually record that for the current stage that diffusion models only defining a continuous data space. However, there are more domains which may have more complicated data structure.
So this data type, as long as we can find an auto encoder model which are tailored to that data type and can map the data input to a continuous latent space, we will be able to apply the diffusion models to that latent space.
So these give us more possibilities to apply diffusion models to different modalities and different data types.
And a bit of the detailed formulation. So in this work, again, we optimize the model in terms of by minimizing the variational upper bound of the negative log likelihood.
The objective contains three terms. The first two terms are similar to the variational auto encoder objecting. And the third term corresponds to the training objective of the diffusion models.
And it actually corresponds to, we treat the encoding latents from this QZ0 given X as the observed data of the diffusion models.
And in that way, we can derive the similar training objective of the diffusion models as the original one. So we first do this random sampling of time step.
And then we draw samples from this forward diffusion. And then we have this diffusion kernel. This is the forward, this is from the forward process. And then we learn this score function for DT.
And of course we have some constant that is irrelevant of the model parameters.
Okay, so the second question we want to answer is how to do high resolution optionally conditional generation using diffusion models.
In the past two years, we have seen many impressive conditional generation results using diffusion models. For example, this style II and imagine recruits diffusion models to do high resolution text to image generation.
And another examples includes the using conditional diffusion models for super resolution or colorization.
Panorama generation is another example where we take a small size input but generate this panorama.
So how can we do that? Let's first take a look at the general formulation of conditional diffusion models, which is pretty straightforward. So the only modification we need to make is in this reverse process.
We can let this denoting distribution to incorporate an additional input, which is this condition C. And this corresponds to modify the mean of this Gaussian distribution to take an additional input C.
And optionally, we can also let this variance to be learned and it takes an input C.
But in practice, like most mostly we still just use this C in this mean and the variation of upper bounds only includes a small change, which lies in this KL divergence where we plug in this new formulation of the denoting distribution.
But it is a design arc in terms of how to incorporate different types of conditions into the unit, which is used to parameterize this new data.
Specifically, like these are the things people use in practice for scalar conditioning. For example, class label, we can do something similar to what we did for time step conditioning.
Specifically, we can encode the certain scalars to a vector embedding, and then we simply add the embedding to the intermediate layers of the unit, or we do this adaptive professionalization layers.
And if it is an image conditioning, we can do channel wise concatenation of the conditional image and the input image. And if it is for text conditioning,
this contains two cases. First, if the text, we embed the text to a single vector, then we can do something similar to the vector derived from the scalar conditioning.
And if we embed this text to a sequence of vectors, then we can consider using cross attention with the intermediate layers of the unit.
And for a high resolution conditional generation, another important component is this classifier guidance.
The main idea is like recall the diffusion model correspond to learning the score of a probability, for example, the score of log px.
And right now, because we incorporate the class condition, which means like the diffusion model actually gives us a score of a class conditional model p of xt given c.
And given this, we can train an additional classifier, which gives us the probability of c given x, and then we mix the gradients of these two models during sampling.
And this corresponds to, we sample from actually a modified score, which corresponds to the gradient of log px given c plus omega times log pc given x.
And this omega controls the strength of the guidance. And it actually corresponds to approximate sampling from the distribution, which is proportional to p of x given c times p of c given x to the omega power.
And in practice, it corresponds to we modify the normal distribution where we sample from and the mean of this normal distribution corresponds to the mean predicted by the score model or predicted by the diffusion model, plus the gradients from the classifier.
And if we use larger omega, then the samples will be more concentrated around the modes of this classifier, which really leads to better individual sample quality, but if we use too large omega, it will reduce the sample diversity.
So one really needs to find a sweet point for this omega to best balance the individual sample quality and sample diversity.
And one downside for this classifier guidance is that we need to train an additional classifier to do that, right, so that adds additional model complexity.
So inspired by that work. This works tries to introduce a classifier free guidance, meaning that we can actually get an implicit classifier by joining training a conditional and unconditional diffusion model in a pulling sense.
So suppose we have this PX given C, where the the score can be derived by a conditional diffusion model, and we also have the score of a unconditional model p of x, and then we can derive an implicit classifier PC given x which should be proportional to p of x given
divided by p of x. And in practice, the gradient or the score of these two probability are estimated by randomly dropping the condition in the diffusion models at a certain chance for each iteration.
And similarly, we can derive the modified score with this implicit classifier. We call this is the original modified score. And now we replace the log PC given x by log PX given C minus log PX.
And this is the resulting modified score we will use with this classifier free guidance where this log PX given C and this log PX are both estimated by the single diffusion model.
And in this three panels, we can see the trade off between sample quality and sample diversity more clearly. So from left to right correspond to we gradually increase the strength of the guidance, and we can see clearly individually speaking, the sample quality of each image increases.
However, the samples that look like more similar to each other if we use a large classifier or classifier free guidance.
And the last thing I want to talk about is this cascade generation pipeline, which are important to high resolution generation. And this kind of idea have already been explored by other type of generating models for, for example, game model.
And it's pretty straightforward. So we've started by learning an unconditional diffusion model at the lowest resolution. And then we've learned several super resolution models, taking the down sampled training images at lower resolution as the condition.
And during sampling, we just run the progressive sampling pipeline starting from the smallest unconditional model and going, going through all those super resolution models until we reach the highest resolution.
But one notorious problem of this kind of cascaded training pipeline is this compounding error problem. It's more specifically record that during training, the conditions we fit into the super resolution model is the down sampled version of the training images from the data set.
However, during sampling, the conditions we fit to those super resolution models are actually generative samples of from the low resolution models. So if there are certain artifacts in the samples from the low resolution models, those artifacts or inaccurate samples will affect the
the sample quality of the super resolution models as well, because of this mismatch issue between the conditions in training and condition in inference.
To activate this problem, this noise conditioning augmentation is proposed in reference works. Basically, during training, we try to degrade the conditioning low resolution images by adding variance amount of Gaussian noise, or just blur those images by Gaussian kernel.
And during inference, we sweep over the optimal amount of noise added to the low resolution images, which are the conditions to the super resolution models.
So the idea or the hypothesis is like if we try to reduce certain amount of information from the condition, then the super resolution model will be trained to be more robust to different type of artifacts when we send like the conditions as the samples.
And later on, more complicated degradation process have been proposed. For example, we can add a sequence of different types of degradation operations to the image, the low resolution image before sending as a condition to the super resolution models.
Okay, so here's a summary of these parts. So in this advanced techniques session, we learn to answer two questions. The first one is how we can accelerate the sampling process, and we introduce several important techniques from the aspects of advanced forward process, reverse process and modeling itself.
And the second question is how we can do high resolution conditional generation using diffusion models, and we discuss the general framework of conditional diffusion models, classifier and classifier free guidance, as well as cascade generation pipeline.
So in the application section, we will see how all those techniques will benefit in terms of various tasks.
Hi, everyone. Welcome to the first section of applications of diffusion models. So in this section, we're going to study applications of diffusion models in terms of image synthesized control generation as well as text to image generation.
So let's run text to image generation. So in the past two years, this task has been shown to be extremely suitable for diffusion models to work on.
So basically, this task is the inverse of the image captioning tasks, where we are given a text prompt C and we are trying to generate high resolution images X, as shown in this video.
So this video shows the generative image images by a text to image generation model called imagine as we will show later.
And let's start from this glide model by opening in last year. So this is essentially a cascading generation diffusion models, which contains 64 by 64 base model, and a 64 by 64 to 56 by 256 super resolution model.
And they have tried to use classifier free guidance and clip guidance. So I will talk about the clip guidance in details later, and they generally found that classifier free guidance works better than the clip guidance.
And those figures shows the generative samples from this model. And as we can see, the model is capable of generate fun, normal conversations of concepts that have never been seen from the data set.
For example, a hedge dog using a calculator and robots meditating in a vipassana retreat or etc.
So a bit introduction of the clip guidance, it can be treated as a special form of the classifier guidance.
And in terms of a clean model contains two components, a text encoder, G, and image encoder F, and during training batches of the image and caption pairs assembled from a large datasets.
And the model optimize a contrasting cross entropy loss, which encourages high dog product between this F and G, if the image X and C comes from the same image caption pair, and it encourages low product if X and C comes from different image caption pairs.
And it can be proved that the optimal value of this FX times GC is given by log PXC divided by P of X times P of C, which equals to log P, C given X minus log PC. So given this conclusion,
we will be able to use this clip model as the classifier in the classifier in the classifier guidance in the following sense. So recall that for the classifier guidance, we want to modify the score in this formulation.
And we can consider augment the augmenting the second term by a minus log PC term, because when we take gradient over X, then this part just disappeared. And then we can see that these two terms together can be modeled by a clip model.
So basically replace this part by the dog product between FX and GC. So that is the clip guidance. However, in Glide they show that the clip guidance is less favored compared to the classifier free guidance.
And besides pure text-to-image generation, the Glide has shown that it is possible to fine-tune the model for text-guided impending tasks. Basically, they try to fine-tune the trained text-to-image Glide model by fitting randomly occluded images with an additional mask channel as the input.
So using this fine-tune model, they are able to change or do image editing by changing the prompt. For example, given an old car in a green forest, they will be able to edit the background to a snowy forest. Similarly, they can add a white hat to a man's hat.
And later on, this DAO-E2 further scale up the Glide model to support 1K by 1K text-to-image generation. And this DAO-E2 has been shown to outperform the first version of text-to-image 1K by 1K generation by OpenEye, which is this DAO-E, which is an unregressive transformer-based model.
And in terms of the model components of DAO-E2, it's built up on a pre-trained clip model. More specifically, a clip model is first pre-trained, and the image embedding and text embedding are grabbed from this pre-trained clip embedding and frozen.
And after that, this pipeline has been built to generate images from text. Basically, this generation model contains two parts. The first is a prior model. This prior model tries to produce clip image embeddings conditioned on the input caption.
And then the second part is a decoder part, which produces the images conditioned on the clip image embedding as well as the text.
So one natural question is why we want to condition the decoder on the clip image embeddings, right? So why not we just directly condition this decoder on text only?
So the hypothesis here is that for the total amount of entropy of an input signal, for example, images, so there's certain part that captures the high-level semantic meanings while there's still a large proportion of the entropy, which corresponds to just low-level details, either perceptual-visible or even perceptual-invisible.
So the hypothesis is that clip image embeddings tend to have a higher chance to capture the high-level semantic meaning of an input signal, especially those related to the caption information.
And by conditioning on this high-level semantic meaning, the decoder is able to capture or catch up those low-level details of the images more quickly.
And later on, this paper also shows that this by-part later repetitions of the clip image embedding as well as the latency in the decoder model enables several text-guided image manipulation tasks, as we will show later.
And a bit more details of the model architecture of the prior and the decoder models.
For the prior, the paper tries two options. The first one is the auto-regressive pair, where they quantize the image embedding to a sequence of discrete codes and predict them auto-regressively.
And the second option is to model the prior by diffusion models, where they directly train diffusion models based on the continuous image embedding as well as the caption input.
And the paper shows that the second option gives better performance.
And in terms of the decoder, it's again a cascaded diffusion models, which contains a one-base model and two super resolution models.
And to save the compute and make the training more efficient, the largest super resolution model is trained on image patches of one quarter size.
But during inference, the model will take the full resolution inputs and directly do the inference on the full resolution.
And this paper also shows that the classifier-free guidance and noise conditioning augmentation are super important to make the decoder work well.
And a little bit more detail about the bipartisan latent representations. So given an input image, we can get the bipartisan latent representations in the following sense.
So it contains two parts.
First is this latent variable Z, which is the clip image embeddings, and it can be derived by running the clip image encoder.
And the second part is this xt, which is the latency from the decoder.
And this part can be derived by running the inversion of an ddim sampler for the decoder.
And after getting these two latent representations, the paper shows that it is possible to run this decoder and get near-perfect reconstruction of the original input image.
And given these bipartisan representations, the paper shows that it is possible to do several image manipulation tasks.
For example, this image variation tasks target at getting multiple variants of an input image, while with the hope of preserving the high-level semantic meanings of the input image.
And this is achieved by fixing the clip embedding Z, while changing to different latent xt in the decoder.
And as shown in this image panel, the first one is the input image, and the rest are the image variants generated by .e2.
And we can see that certain high-level semantic meanings are preserved, for example, the artist's style.
And this clock is preserved in all the image variants, but with different details in the image variants.
And the second task is this image interpolation task.
So given two input images, it's possible to use .e2 to do interpolation by interpolating the image clip embeddings of these two input images.
And we can get different interpolation trajectories by using different xt along these trajectories, as shown in those three rows.
And as we can see, although the trajectories are different, but the high-level semantic meanings are kept well for the two input images for all those three interpolation trajectories.
And the last task, the most interesting task that they show that can be done by .e2 is this text div task, which means like given an input image and the corresponding description, we would like to add this image towards a different prompt.
And this corresponds to an arithmetic operation in the latent space.
More specifically, they first try to compute the difference between the text clip embeddings of the original prompt and the target prompt.
And then they try to change the image clip embedding of the given input towards the difference between the text prompts.
And using this approach, they show that it's possible to do this text-guided image editing by changing the prompt.
And the last task to image diffusion model I want to talk about is this imagined model by Google Brain Team.
So again, the task is the same as .e2.
So we are given some text prompts as input, and we are trying to output 1k by 1k images aligned with the input text.
And the highlight of imagined model is as follows.
First, it provides an unprecedented degree of photorealisticism in terms of state-of-the-art automatic scores, such as FID scores, as well as state-of-the-art human ratings.
And it provides a deep level of language understanding, as can be told by the generated samples.
And it is extremely simple, so there is no latent space and no compensation.
And as we will see later, it's just like a pure cascaded diffusion model.
So I will first present several examples of imagined.
Yeah, this is my favorite one because I just created it to make it related to CVPR.
And in terms of the key modeling components of imagined, like I mentioned, it is a pure cascaded diffusion model containing one base model and two super resolution models.
And it uses classifier-free guidance and the dynamic thresholding, as I will talk about later.
And unlike DAI2, which uses clip text embedding as the, using this clip text encoder, this imagined used frozen large pre-train language models as the text encoders, more specifically this variant of T5 model.
And there are several key observations from imagined.
First, it is beneficial to use text conditioning for all the super resolution models.
The explanation is as follows. So remember, like for cascaded diffusion models, we need to use this noise conditioning augmentation technique to reduce the compounding error.
But however, this technique has a chance to weaken the information from the low resolution models.
Thus, we really need the text conditioning as extra information input to support the super resolution models.
And second observation is that scaling the text encoder is extremely efficient in terms of improving the performance of imagined.
And it has been shown that this is even more important than scaling the diffusion model side.
And lastly, comparing using the pre-trained large language model as the encoder versus the clip encoder, human readers actually prefer the large language model over the clip encoder on certain data sets.
And this dynamic thresholding is a new technique introduced by imagined.
This is mainly to solve the trade-off problem of using large classifier-free guidance weights, more specifically as we also discussed in the previous part.
So when we use large classifier guidance weights, there is a chance that it gives us better text alignment but worse image quality.
So as we use large free guidance weights, the clip score, which corresponds to a better text alignment, increases.
However, the IFID score also increases, which corresponds to worse sample quality.
So to elevate this issue, because we really want both the sample quality, like the good sample quality as well as good text elements, right?
So to elevate this trade-off issue, the hypothesis this paper made is that the reason why the sample quality decreases at large guidance weights is that at large guidance weights,
usually it corresponds to very large sample gradients in inference, and then the generated samples have a chance to be saturated because of the very large gradient updates.
So the solution they propose is this dynamic thresholding, meaning that at each sampling step, we adjust the pixel values of the samples to be within a dynamic range, and this dynamic range is computed over the statistics of the current samples.
And these two panels shows the qualitative comparisons between static thresholding and dynamic thresholding.
And you can see if we use this static thresholding, the images look kind of saturated, while the dynamic thresholding, the samples look more realistic.
And another contribution of Imagine is that they introduce a new benchmark, especially for this text-to-image evaluations.
So the motivation of introducing new benchmarks is that for existing datasets, for example, COCO, the text problem is kind of limited and is kind of easy.
So this benchmark introduced more challenging prompts to evaluate text-to-image models across multiple dimensions.
For example, it tries to evaluate the ability of the model to facefully render different colors, numbers of objects, spatial relations, text in the scene, unusual interactions between objects.
And it also contains some complex prompts, for example, long and intricate descriptions, wire words, and even misspelled prompts to test the robustness of your model.
And this figure shows several examples of the text prompts in this benchmark, and the corresponding generated images from Imagine using these text prompts.
And a bit more of the quantitative evaluations of Imagine.
Imagine got state-of-the-art automatic evaluation scores on the COCO dataset, and it's also preferred over reasoned work by human readers in both sample quality and image text alignment on the drawbench dataset.
And the reasoned work compared by Imagine includes this DAO-E2 slide, VQGAM plus clip, as well as the latent diffusion models.
Okay, so besides text-to-image generation, I also want to talk about the controllable generation using diffusion models.
And a representative work is this diffusion autoencoders, which propose to incorporate a semantic meaningful latent variables to diffusion models.
So more precisely, so given an input image, semantic encoders learn in this framework to generate this Z-SIM.
And this Z-SIM is fit into a conditional diffusion models to further predict the clean samples.
And this leads to some like the bipod latent representation similar to the DAO-E2 model, where we have this Z-SIM with the hope that it can capture high-level semantics.
And we also have this X-Big-T, which is the inversion of this conditional DTIM sampler.
And the hope is that it captures the low-level stochastic variations of the images.
And if we want to do unconditional sampling from this model, optionally, we can learn another diffusion model in the latent space of the Z-SIM.
Very similar to the latent diffusion models we talked about in the last part, to support this unconditional generation test.
Interestingly, they found that by assuming a low-dimensional semantic vector Z, they are able to learn different semantic meanings for different dimensions of this latent vector Z.
For example, by changing the certain dimension of this latent Z, they are trying to identify different semantic meanings such as the higher style, the expression, the age,
and also the color of the hair.
And they also are assuming that if we fix the Z-SIM for each row, and we change the latent X-Big-T in the conditional diffusion model, we can see it only corresponds to very tiny details in this image,
and perhaps other like perceptually invisible features in the images.
So that ends the first part of the application. Thanks for listening.
Awesome. Thanks Richie for the nice introduction of the first group of applications.
Here I'm going to start with the second group of applications. And in this part, I will mostly focus on image editing, image to image translation, super resolution, and semantic segmentation.
This is a super resolution. I'll start with talking about this work called super resolution, but we are repeated refinements, or SR3, which was proposed by Sahari et al at Google.
In image super resolution, we can consider this problem as training a conditional model P of X given Y, where Y is the low resolution image and X is the corresponding high resolution image.
So we want to be able to change the high resolution images given some input low resolution image.
In order to tackle this problem, the authors proposed to train a diffusion model, a conditional diffusion model using this objective.
Here in this objective, we have expectation over pairs of high resolution image X and low resolution image Y.
We have expectation over epsilon, which is drawn from standard normal distribution, and we have expectation over time, where time varies from, for example, zero to capital T corresponding to the diffusion process.
We have this excellent setup. This is a noise prediction network that takes diffused high resolution image, XT, the time, as well as this Y, this is the low resolution image that is provided as conditioning into epsilon prediction
network, and we train this epsilon prediction network to predict the noise that was used in order to generate diffused high resolution image.
The authors in this paper proposed to use different norms for minimizing this objective. They introduced L1, L2 norm, and they observed that one can trade quality for diversity by using L1 norm is L2 norm.
Since we are training a conditional model now you have in mind that we need to modify the unit that is used for epsilon prediction.
For the input of the unit, we will have access to diffused high resolution image, as well as this low resolution conditioning input.
Since these two images don't have the same special dimensions, the author proposed to use just simple image resizing algorithms to up sample the input low resolution image and concatenate it with diffused high resolution image and the channel dimension, and they provide
to the unit diffusion model or the epsilon prediction model and the network is trained to predict the noise that was used when generating the high resolution image.
This method achieves very high quality results for super resolution. For example, here you can see super resolution results with 64 by 64 pixel input when the output is 256 by 256.
And you can see that this method here shown in this column achieves a really high quality result compared to, for example, regression models or just simple image resizing algorithms or using by cubic interpolation.
And you can see that this actually does a good job of generating low level details.
Another work that I like to mention is called palette, image to mesh diffusion models. This method is also this paper is also proposed by same authors as a previous method.
So the author's area at home.
Similar to super resolution, many image to image translation applications can be considered as training a conditional model X given why.
This is the input image. For example, if you consider colorization problem X is the output color image and why is the grade level input.
So similar to the previous part, or previous slide we're going to again use, we're going to again trade and condition diffusion model using this objective.
Similarly, we have again expectation over pairs of input conditioning why, for example, why is again great image X is the output color image.
We have expectation over epsilon drawn from standard normal distribution expecting over time, we're training a conditional diffusion model that takes input grade level image for some input conditioning time as well as the diffuse output image that we want to generate
and then the model is trained to predict the noise that was used to generate diffuse samples.
Similar to previous part, again, we need to give a pair input to the unit model. And here, because for example, if we're attacking the color problem, we're going to have this grade level image and diffuse color image as input to unit and similarly it's trained to predict the noise that was trained for
generating diffuse sample.
The others tried their image to mist translation image to mist diffusion model on four different tasks, including colorization in painting jpeg restoration and uncropping, which is basically given this image, they wanted to extend the image and provide the copper part of this, what they called uncropping.
This paper shows that actually diffusion walls can achieve very good results on these four tasks.
We should have in mind that this problem this particular paper assumes that you have access to pairs of input and output data so they're they're training a conditional model assuming that they have input image and the output image that we want to generate.
If we don't make that assumption, what we can do we can potentially take an unconditional model that is trained on that for example natural images and we can modify it for a particular task.
So, as example of that approach, I want to mention I'd like to mention this paper called iterative latent variable refinement or by LBR for short, that was proposed by Joey et al at ICCB 2021.
This paper proposes an approach where, given a reference image, the authors like to modify the generative process of the fusion model, such that the output of the diffusion model can be similar to the reference image.
Again, we have a reference image and we want to modify the reverse generative SDEs or the reverse generative diffusion process, such that we can generate images that correspond to a reference input image.
So, and the authors and the speaker proposes to do this through using some unconditional model that is not trained for this specific task, it's just the unconditional model is trained to generate realistic for example faces on this slide.
So, so the basic idea is to modify the reverse denoting process, such that we can pull the samples towards the reference image.
So here you have the algorithm proposed in this paper, the algorithm starts from capital T goes to one so this is the reverse denoting process at every step we draw a random nodes vector vector from standard normal distribution, we sample from the reverse denoting distribution
to generate this proposal of this color x prime t minus one is the proposed denotes sample to run from the denoting model.
Why here represent the reference image so we're going to use the forward diffusion kernel to generate the diffused version of reference image so we're going to go forward in time for this reference image.
So I did what we want to do we want to make this proposed denotes image x prime t minus one to be more similar to whitey minus one.
So to do so that this paper proposes this simple operation here fine and represents some low pass filter.
So this operation is very simple, we have this proposed denotes image x prime t minus one, we subtract the low pass filter applied to this x t minus one, and we add the back low pass filter output of whitey minus one.
So you can think of this operation as operation that takes x t minus one, the x prime t minus one, this is the proposed denotes image, it removes its low pass filter low frequency content.
So, here we are removing the low frequency content of x prime t minus one, and the adding back the low frequency content of whitey minus one.
So basically we're putting the low frequency content of whitey minus one, this is the reference image into x prime, into x prime denotes the proposal sample.
What we are doing we're basically making sure that in the reverse process, we're generating a sample where the low frequency content is similar to the reference image so the most of the structure is very similar to the reference image.
So, as I mentioned, fine and it's just a low pass filter. And in order to implement this the artist proposed to use simply done sampling up sampling operation where n represents the, the, the, the down sampling ratio used for in this operation for something
n is equal to two, it means we're going to just take reference image or take this input down sample by factor of two and then up sample again by factor of two.
So, which is which corresponds to to a low pass filter operation.
Here you can see this reference, these two reference images, and how we can generate images with different values for n. So when n equals to four, it means that we actually take this during the generation we don't sample that for low pass filter we don't sample the
sample images by factor of four, by factor of four. Since this factor is a small, this means that most of the structure in the generation will be similar to reference image.
So you can see that in fact we're generating an image that is very similar to reference image. And as we increase this and we can see that now different levels of details can, can be generated through the diffusion model and the more global characteristics
like more global arrangements or low pass, low frequency content of the image is still remains the same as the reference image.
And now to show that actually you can do this for different tasks image translation given a portrait image they can generate a realistic image that corresponded to the portrait image.
So they can do paint to image so they can take all painting and generate realistic image, and they can do some simple editing, and for something can add back this watermark into.
In this part I'd like to talk about how we can take representation learned through diffusion models and use them for sometimes through applications such as semantic segmentation.
I'm talking about a specific paper called label efficient semantic segmentation with diffusion models that was proposed by one joke at all at ICLAR 2022.
So it's pretty a paper, propose a simple approach for using the representation trained in diffusion model for semantic segmentation. The others proposed to take input image and diffuse it by adding by following the forward diffusion process, and they only go to small steps
by following the forward diffusion step which corresponds to adding just a bit of noise into input image, then they pass this diffuse image to the denoising diffusion model the unit model the epsilon prediction model.
And they, they extract representation form, the internal representation form in this unit at different resolutions of the unit decoder.
So given these representations the up sample, all these intermediate representation, so that they have the same dimensional spatial dimensionality as input in so we have these up sampling layers.
We have these feature maps that have the same dimensionality as the input image, and now they simply concatenate all these intermediate feature maps, and they pass them to one by one convolutions that would do semantic segmentation per pixel.
So you can think of these as a pixel classifiers that just classify each pixel for each semantic object goals or semantic goals.
So, in order to train this model, that was supposed to use a pre-trained diffusion model and they're only training this component here.
Up sampling component doesn't have usually any training parameters, but most of the parameters, the additional parameters are basically here in these one by one convolutional networks.
This paper particularly shows that this approach is labeled efficient using very few labeled instances they can train diffusion models on several datasets as you can see on this slide.
And the other show that actually diffusion based segmentation models cannot perform mass encoders, can or VAE based models on this test, which is very interesting.
It shows that actually representation learning diffusion models can be used for downstream applications such as segmentation.
In this part, I like to talk about the particular paper parameter that is proposed for image editing. It's called SDE edit.
This paper was proposed by Ming Itala at Stanford University, and it was proposed, it was presented at ICLR 2022.
What this paper is trying to tackle is that, given this stroke painting, the authors propose a simple approach to generate realistic images that corresponds to that stroke painting.
The main intuition or the main idea in this paper is that the distribution of real images and stroke painting images, these are two different distribution.
If you have some smashes, they're not the same and in the, in the data space, they, they are not completely overlapping each other because of these differences.
But if you follow the forward diffusion process, if we have this distribution realistic images distribution stroke painted, if we follow the forward diffusion process these two distribution will stop having overlaps with each other because of the definition of forward
distribution, because we know that actually, if you have two distribution and you diffuse the samples in those two distribution, the distribution will start having overlap.
This forward diffusion simply corresponds to adding noise into input stroke painting.
Now that we know these two distribution are overlapping, we can use just a generative model train of real images to solve the reverse SDE, reverse denoising SDE.
That will start from this diffused stroke painting and try to generate a realistic image that corresponds to this noisy input.
And the authors show that they're actually using a generative model. This is an unconditional model again, train unrealistic images, they can come back to realistic images that where the colors here are very similar to this stroke painting colors.
So, this is, I think, a very clever idea to take stroke paintings and generate realistic images that correspond to those stroke paintings.
However, actually, we should have in mind that this train in a conditional setting, however, we should have in mind that this approach mostly relies on the color information in order to take this stroke painting and generate the corresponding image.
And this is a bit different than, for example, methods that would use the semantic layout, semantic mask of objects in order to tackle this problem.
So, it has some advantage and disadvantages that we should have in mind.
Delta shows very interesting results on different data sets. Here you can see stroke paintings for models train on this on bedroom, this on church and set up a and you can see here in these two row, how a generative model using SDE not can be used to generate realistic images that correspond to stroke.
Lastly, in this part, I'd like to talk about particular work that we did at NVIDIA for adversarial robustness and in this particular work we introduced diffusion models for adversarial clarification.
So the basic problem we want to add this is that given an adversially perturbed image, we want to see if we can use diffusion models to remove adversarial perturbations and clean this image such that maybe apply classifier on these adversially perturbed image images, we can actually get robust classification.
So this, the proposed idea here is similar to SDE edit mostly applied for adversarial clarification, given this adversarial perturbed image.
So what we propose to do is we propose to follow the forward SDE, which correspond to basically adding noise and diffusing the input adversarial perturbed image, using just a forward diffusion cannon.
So we go to particular times that T star we call, and we, and we simply diffuse the input adversarial perturbed image.
We know that by adding noise, we can now wash out all these adversarial perturbations that are applied into image.
Now that we have this noisy image, we use the reverse genitive SDE or reverse noise SDE to start from this noisy input and generate clean image that corresponds to this noisy image.
And we know that through this process, we can remove all the noise that was injected as well as all the adversarial perturbations presented here in this image.
So if we have this clean image or purified image, we can just pass it to classifier and hopefully make a robust classification prediction.
Like any adversarial difference mechanism, we need to be able to attack this model, evaluate our performance, we need to be able to attack this model.
And we also show how we can attack this model by backfogating end-to-end through classifier as well as our purification algorithm.
And this involves basically backfogating through this reverse SDE. So we showed in this paper how we can do this and how we can attack this mechanism end-to-end.
On the left side in this slide, you can see an example of adversarial perturb images and first column on a set of A data set.
Here, we intentionally increase the magnitude of adversarial perturbations so that they are visible to us.
These two groups are representing, these two images are representing adversarial perturbation for a smining class and these two represent adversarial perturbation for eyeglasses.
Here you can see diffuse samples that are generated by following the forward diffusion. This is simply corresponds to sampling from diffusion kernel.
And then here in these two columns, you can see samples that are generated when we're solving the reverse genetic SDE.
And as you can see, at time equals to zero, we can remove not only the adversarial perturbations as well as all the nodes that was injected through forward diffusion process.
And you can see that our generated energy equals to zero are very similar to input clean original images.
And we can see that the semantic attributes of these images are very similar to semantic attributes of the original images.
The nice thing about using a generative model for adversarial purification is that these modes are not trained for specific attacks and specific classifiers.
So at the test time, we can just apply them for unseen adversarial attacks.
In comparison to the state of dark methods that are designed for similar situation for unseen threats, we actually see that our proposed diffusion prefabrication method outperform these methods by large margin.
And we believe that, in fact, the fusion models can can be very strong models for designing adversarial purification techniques.
And this is probably because the fusion models can generate very high quality images and potential can use for removing all the artifacts that are generated by adversarial perturbations.
This brings me to the end of the second part of applications. Next person will will continue with the third part of applications.
All right, I will not talk about video synthesis medical imaging 3d generation and discrete state diffusion models.
Let's get started with video generation.
There are samples from a text conditioned video diffusion model like Jonathan how at all, where we condition on the string fireworks.
So I think these samples look pretty convincing.
So they're actually in general different video generation tasks. For instance, so it's unconditional generation where we want to generate all frames of the video on scratch without conditioning on anything.
There was a future prediction where we want to generate future frames conditioning on one or more past frames. We can also do past prediction the other way around.
We can also do interpolation, when we have some frames and we want to generate in between frames, just for instance useful to increase the frame rate of the video.
All these generation tasks can basically fall under one modeling framework. In all cases, we basically want to learn a model of form setter of xt one to xtk given x, how one to x, how I am.
So for the t's and tiles, you know the times for frames that you want to generate and for the frames that we condition on.
So for future predictions, these tiles will already smaller than the t's unconditional generation and we wouldn't have any tiles and so on and so forth.
Something we see in multiple of these recent works is that they try to learn one diffusion model for everything.
What they do is they concatenate and combine both the frames to be predicted and the conditioning frames together.
And then some of these frames are masked out, so once to be predicted.
And yeah, based on the conditioning frames, those are then generated and varying the masking and conditioning combinations during training, we can train one model for these different tasks.
In training, we would also tell the model which frames are masked out and we would feed the model time position encodings to encode the times for the different frames.
That's visualized here, for instance.
In terms of architecture, these models are still using these units, which we already know from the image based diffusion models.
We know like small detail. So, of course, now our data is higher dimensional, because in addition to the image and height and width dimensions, as well as the channel dimensions.
We now also have the time dimensions with the number of frames, so the data is essentially four dimensional.
One way is to use now 3D convolution instead of 2D convolutions to run convolutions over height width and the frames. This can be computationally expensive.
Another option is, for instance, to keep special 2D convolutions and use attention layers along the frame axis.
This has the additional advantage that ignoring those attention layers, a model can be trained additionally on pure image data, which is kind of nice.
So, let's see some results. It turns out that these video generation diffusion models, they can actually generate really long-term video in a hierarchical manner, which is quite impressive.
And there, we precisely leverage these masking schemes that we just had, and these generalized video diffusion frameworks.
So, one thing you can do, for instance, is we generate future frames in a sparse manner by conditioning on frames far back. This gives us long-term consistency.
And then we interpolate the in-between frames afterwards. So, we kind of generate the video in a stage-wise hierarchical manner.
And with that, it's possible to actually generate really long-length, one-hour coherent videos, which is quite impressive. So, here are some samples from this recent Harvey et al. work.
All right. Let us now talk about another application of diffusion models, which is solving inverse problems in medical imaging, another very relevant application.
So, medical imaging may refer to computer tomography or magnetic resonance imaging.
In those cases, we're basically interested in an image X, but that is not what we're actually measuring from the CT scanner or MI scanner.
So, let's consider the measurement process. For instance, in computer tomography, the forward measurement process can be modeled in the following form.
In the image, we are basically performing a radon transform, which gives us a sinogram, and then maybe this is sparsely sampled.
So, we end up, this is sparsely sampled sinogram Y. And now, the task is that needs to be solved to reconstruct the image given this measurement Y. So, this is an inverse problem.
This is a similar and magnetic resonance imaging, just that the forward process is now basically modeled with a Fourier transform, which is then sparsely sampled.
So, and this is where diffusion models now come in. So, they can actually be really used in this task. And the highly ideal is here to learn a generative diffusion model as a prior over the images we want to reconstruct.
And while sampling from the diffusion model, we guide synthesis condition while conditioning on the sparse observations that we have. This is the idea.
And it turns out that doing this actually performs really, really well. And even this outperforms even fully supervised methods sometimes.
Specifically, the thing is, when we train this fusion model over these CT or MRI images, we really just need the images, we do not need paired image measurement data to train this.
So yeah, there is actually a lot of work in that direction because it's a really high impact application, of course, and there are some citations that you are interested in learning more about this.
So let's move on to the next application topic, which is 3D shaped generation. Also, 3D shaped generation has recently been tackled with diffusion models.
So let us consider this work by zoo at our, for instance, here, 3D shapes are represented as point clouds.
And this has the advantage that they can be diffused really easily and intuitively, we see this here at the bottom right so where the diffusion actually goes from the right to the left, we have a bunch of points and they are perturbed and 3D towards this, yeah, Gaussian noise ball kind of, and the generation goes into the other direction.
So in those cases, the architectures that we use to implement the denoiser network are like typical point state of the art modern point cloud processing networks like no point net advanced versions of point and point boxes and so on and so forth.
How does this look like then.
Another animation.
I think this is quite nice. So, yeah, we can generate these pretty good shapes.
We can also train conditional shape completion diffusion models very condition, for instance, unlike that or like some sparse points like this, and then complete those shapes.
So in the multimodal fashion, for instance, in this example we have some legs of the chair given. And now we have like different plausible completions of the chair here.
Another thing that is also quite cool is that he works on real data. I think here the model was trained only on synthetic shape net data, and yet we can see the model images that we take these images and generate plausible 3D objects.
Very nice.
Finally, I would like to talk about discrete states to fusion models. This is less of an application but slightly different type of diffusion model, but I think it is worth mentioning as part of this tutorial.
So, so far, we have only been considered continuous diffusion entity noising processes, which I mean with that is, we basically kind of assume our data is of a continuous nature.
And we could add a little bit of Gaussian noise to it in a meaningful way. So both our fixed forward diffusion process and also our reverse generative process are usually were usually implemented as Gaussian distributions like here.
But what if our data is discrete, categorical, then continuous perturbations are not meaningful, they are not possible. Imagine, for instance, our data as text data, you know, pixel wise segmentation labels, or discrete image encodings.
Yeah, if our data is discrete, adding Gaussian continuous noise to it doesn't really make much sense. So, can we also generalize this diffusion concept to like discrete state situations.
In fact, there are categorical diffusion models. And in those cases, the forward diffusion process or like the perturbation now is defined using categorical distributions.
So consider perturbation corner q of xt given xt minus one, that is supposed to put up the discrete data. So this can now be a categorical distribution, where the probability to sample one of the teachers is now given by some transition
matrix q multiplied together with the state we are in xt minus one. So the probability to sample like the new state xt.
So this xt is usually a one-hot state factor describing the state we're in. And yeah, this transition matrix multiplied with will then give us probabilities to sample the next state.
So with that we can put up complex distributions categorical distributions towards like very random discrete distributions.
We choose this transition matrix accordingly. So for instance, in this example, if we look at the right, this may now be a complex data distribution.
We can perturb this towards a uniform discrete distribution over these three different states 13123.
So again, the reverse process for generation, and which is then implemented through a neural network, we can also parameterize as a categorical distribution.
In fact, there are different options for this perturbation process, this forward perturbation process.
We can use uniform categorical diffusion where we pull everything towards a uniform distribution over the different categories like I've just shown.
We can also progressively kind of mask out the data where we pull everything into one particular state. We can also analytically sample from such a distribution.
So it's also well suited for diffusion model.
We can also tailor our diffusion processes to ordinal data and use something like discretized Gaussian diffusion process that's also possible.
How does this look like for instance.
So here now I have the data distribution. It's a bit complex, but so this is basically each pixel of this image represents one categorical variable, and now the color of this pixel represents which teacher we are in.
So now if I would do like this uniform categorical diffusion, I would kind of, you know, yeah, would look like this, where I would transition into different states everywhere in the image.
I could also do something like Gaussian diffusion where it's more like this ordinal thing that's more based transition to neighboring states.
And then there was also this absorbing diffusion where I kind of progressively mask out or absorb my state sort of different ways to do this.
And then in the reverse process may for instance look like this. So here on the far right, this is a stationary distribution of this categorical distribution from which I can sample analytically.
And then denoising kind of progressively noises is bad towards the data distribution.
So yeah, one can use this and some papers have explored such discrete state diffusion models. For instance, we can also apply this on images by modeling the pixel values of images as discrete states to be in.
So this is a start from uniform uniformly distributed pixel values right here from this all gray kind of state or mask out state.
Another application is to use this in a discrete latin space. So in this work, for instance, images are encoded using a vector quantization techniques into visual tokens in a discrete latin space and then we can use something like discrete diffusion models and similar techniques to model the distribution
over the visual tokens.
This is also something one can do.
We can also use discrete state diffusion models to generate segmentation maps, which are also categorical distributions in pixel space.
And yeah, that concludes my part. And with that, I would like to pass a mic back to ours, we will now conclude our tutorial. Thank you very much.
Thank you for being with us. This basically brings us to the last part conclusions, open problems, and final remarks.
So today was a big day, we learned about diffusion models. At the beginning of this video, I started talking about the noise and diffusion prophecy models, which is a part, which is a type of discrete time diffusion models.
I showed you how these discrete time diffusion models can be described using two processes, a forward diffusion process that starts from data and generates those by adding those into the input, and then reverse the noise and process that learns to generate data by starting
from noise and denoising the input image one step at a time. I also talked about how we can train these diffusion models by simply generating diffuse samples and training network to predict that to predict the noise that was used to generate diffuse input images.
In the second part, Carson talked about the score-based generative modeling with differential equation, which corresponds to continuous time diffusion models.
Specifically, Carson talked about how we can consider diffusion models in the limit of infinite number of steps and how we can define or how we can describe these forward and reverse processes using stochastic differential equations or STEs.
I also talked about probability flow ordinary differential equations or ODEs, which describe a deterministic mapping between noise distribution and data distribution.
Another thing about working with stochastic differential equations or ODEs or ordinary differential equations is that we can actually use the same training that was used for training different discrete time diffusion models in the previous slide.
However, at the test time, we are free to choose different discretization or different OD or ST solvers that have been studied widely in different areas of science.
And those are basically to change the sampling time by using, for example, OD or ST solvers that don't require a lot of functional evaluations.
In the third part, Ruchi talked about advanced topics in diffusion models.
She mostly focused on accelerating sampling from diffusion models and she studied this from three different perspectives, including how we can define forward processes that accelerate sampling from diffusion models,
how we can come up with better reverse processes, or how we can come with better denoising models that allows us to access sampling from diffusion models.
Beyond that, she also talked about how we can scale up diffusion models to generate high resolution images in conditional and conditional setting.
Actually, especially talk about cascaded models and guided diffusion models that are heavily used in the current state-of-the-art image to text diffusion models, just imagine.
After talk about fundamental topics, all three of us talked about various computer vision applications that have been recently proposed and mostly applications that rely on diffusion models at their core recently.
So, now that we know about diffusion models and we know how we can use these models in practical applications, let's talk about some open problems.
I do hope that now we could make you interested in this topic and now that you know the some fundamental in this area, maybe you can think about open problems that exist in this space and together we can tackle some of these.
The first problem I want to, first of problems I want to mention are more on the technical side and later I will talk about more applied questions that arises in practice.
So, if you remember at the beginning of the talk, Mouskarsen and I talked about how diffusion models can be constructed as a special form of MIEs or continuous time normalising flows.
We exactly don't know why diffusion models do much better than VAEs and continuous time normalising flows. If we can understand this, maybe we can take the lessons learned from diffusion models and why they do so much better than VAEs and continuous time normalising flows in order to improve these frameworks,
meaning we can maybe use the lessons learned from diffusion models to improve VAEs or normalising flows.
Even though there has been a tremendous progress in the community for accelerating sampling from diffusion models, we can still do, in the best case scenario, we can still do, actually, the sampling using four to 10 steps on the small matrices such as Cypher 10.
However, the main question that remains on how we can get one step samples for diffusion models. And this can be very crucial for interactive applications where a user interacts with the diffusion model and this
we can reduce the latency that usually users observe when they are using generative models.
Some of the existing problems have to define one step samplers and part of the solution might be to come up with a better diffusion process that are intrinsically faster to generate sample from.
Diffusal models, very similar to VAEs or GANS, can be considered as latent variable models, but the latency space is very different. For example, GANS, we know in the latent space often have semantic meaning and using latent space manipulations, we can actually come up with image editing or image
manipulation frameworks. But in diffusion models, the latent space does not have semantics, and it's very tricky to come up with latent space semantic manipulation diffusion models. So part of problem here is how can we define
semantically meaningful latent space for diffusion models that allow us to do semantic manipulations.
In this talk, we mostly focus on generative applications, but one open problem is how we can use diffusion models for discriminative applications. For example, one way of using diffusion models might be for representation learning, and we might be able to tackle high level tasks such as image classification
versus low level tasks such as semantic image segmentation. And these two may require different traits of when we're trying to use diffusion models to address these.
Another group of applications that may benefit from diffusion models is uncertainty estimation. One question is how can we use on diffusion models to do uncertainty estimation in downstream discriminative applications.
And finally, one question that remains open is how we can define joint discriminator generator, sorry, joint discriminator generator models that not only classify images or input, they also can generate similar inputs.
So the committee mostly have been using unit architectures for modeling the score model in the score function in diffusion models. But one question is whether we can go beyond units and come up with better architectures for diffusion models.
One specific open area is how we can feed time input or other conditioning into diffusion models, and how we can potentially improve the sampling efficiency or how we can reduce the latency of sampling from diffusion models using better network design.
So far in this talk, we mostly focused on image generation, but we may be interested in generating other types of data. For example, 3D data that has different forms of representation, for example, it can be represented by stance function,
meshes, voxels, or volumetric representation. Or we might be interested in generating video text graph, which have their own characteristics. And given these characteristics, we actually may need to come up with specific diffusion models for these particular modalities.
One area of research is to do composition and controllable generation, and this will allow us to go beyond images and be able to generate larger scenes that are composed of multiple, for example, objects.
And also this will, as a technical example, allow us to have fine grain control in generation. So one interesting open problem is how we can achieve composition and controllable generation using diffusion models.
Finally, I think if we look back, look back to the vision community and the problems that we solved in the past few years, we see that most of the applications try to solve, most of the applications that rely on generative models, they try to solve,
and some solve with generative adversarial networks. So maybe it's a time for us to start revisiting those applications and see whether they can benefit from the, the nice properties that diffusion models have.
So one open question is which applications will benefit most from diffusion models, given that we have such amazing strong tool.
Let's go to the final slide. I want to say thank you for being with us today. This was, this is a very long video, and I do hope that we could provide some useful and fundamental background on diffusion models and how often are used in practice.
All of us are active on Twitter, if you are interested in knowing about follow up works that we, we build on diffusion models, please make sure that you follow us.
And lastly, I want to mention that all the content on this week and this video, including slides will be available on this video on this website.
If you happen to enjoy this video, I would like to ask you to share this video with your colleagues and collaborators, and hopefully together, we can come with more people to start looking into diffusion models and applying them to various interest applications.
Thanks a lot.
