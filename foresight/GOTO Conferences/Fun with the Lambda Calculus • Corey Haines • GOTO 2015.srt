1
00:00:00,000 --> 00:00:08,120
Okay, we've got lots to go through, so let's get through it.

2
00:00:08,120 --> 00:00:14,120
So most people have heard about, like, the Lambda Calculus.

3
00:00:14,120 --> 00:00:16,560
How many people have heard of Lambda Calculus?

4
00:00:16,560 --> 00:00:20,800
How many people have ever actually done anything in it, one person?

5
00:00:20,800 --> 00:00:21,800
Awesome.

6
00:00:21,800 --> 00:00:22,800
A couple people.

7
00:00:22,800 --> 00:00:23,800
Yeah, Tom's done a little bit of it.

8
00:00:23,800 --> 00:00:27,880
So I'm not really gonna go into, like, the details of Lambda Calculus and all of that.

9
00:00:27,880 --> 00:00:33,640
It leads to church numerals, and I find those a bit pretentious.

10
00:00:33,640 --> 00:00:36,840
You know, fancy list manipulation, stuff like that.

11
00:00:36,840 --> 00:00:38,920
But the code's really cool.

12
00:00:38,920 --> 00:00:43,760
When all you have is a Lambda, when all you have is a function, and you don't have anything

13
00:00:43,760 --> 00:00:45,480
else.

14
00:00:45,480 --> 00:00:50,640
So we've all, most people have kind of heard of it, but few people have really, like, actually

15
00:00:50,640 --> 00:00:55,080
gone in and done anything with it, or actually seen why.

16
00:00:55,080 --> 00:00:59,520
And a lot of times, if you do see people give talks on it, it's things like, here's

17
00:00:59,520 --> 00:01:03,960
how you build lists, and they just kind of put out the code.

18
00:01:03,960 --> 00:01:10,480
So what I thought it would be fun is to do some coding with a couple constraints, the

19
00:01:10,480 --> 00:01:15,520
main constraint being that all we have is a Lambda.

20
00:01:15,520 --> 00:01:19,280
And in fact, it only has one single input and single output.

21
00:01:19,280 --> 00:01:24,280
So a lot of the times coding, you can learn a lot if you put these really crazy constraints

22
00:01:24,280 --> 00:01:25,920
on what you're doing.

23
00:01:25,920 --> 00:01:30,800
So I thought, what fun did a coding conference then to stand up here and actually live code

24
00:01:30,800 --> 00:01:33,440
stuff with you?

25
00:01:33,440 --> 00:01:37,280
The other thing is we're going to do today in these 50 minutes, we're going to build

26
00:01:37,280 --> 00:01:41,720
up what are called the natural numbers.

27
00:01:41,720 --> 00:01:42,880
Anybody heard about numbers?

28
00:01:42,880 --> 00:01:44,800
They're pretty useful.

29
00:01:44,800 --> 00:01:49,000
We're going to do them with something called Piano's Axioms.

30
00:01:49,000 --> 00:01:51,040
Anybody heard of Piano's Axioms?

31
00:01:51,040 --> 00:01:52,040
Awesome.

32
00:01:52,040 --> 00:02:00,520
So Piano was a 19th century mathematician, Italian Giuseppe Piano, made these axioms

33
00:02:00,520 --> 00:02:08,080
as a sort of a statement about the natural numbers, zero, one, two, all of those.

34
00:02:08,080 --> 00:02:12,200
We're not going to go into a lot of the sort of mathematical formalism about it, but we're

35
00:02:12,200 --> 00:02:17,720
going to kind of go through starting with just a Lambda, and I'll show you what that

36
00:02:17,720 --> 00:02:22,240
looks like, and we're going to end up with the natural numbers.

37
00:02:22,240 --> 00:02:25,000
Fun coding exercise, everybody's happy.

38
00:02:25,000 --> 00:02:28,440
So what I want to do is I want to look through the Piano's Axioms, and I'm sure all of you

39
00:02:28,440 --> 00:02:33,040
have them in your clip ordering like I do.

40
00:02:33,040 --> 00:02:36,320
So the Piano Axioms, there's eight of them.

41
00:02:36,320 --> 00:02:40,560
The first one is a pretty obvious one, that zero is a natural number.

42
00:02:40,560 --> 00:02:42,880
It's sort of like the starting point.

43
00:02:42,880 --> 00:02:45,320
The next four are Equality Axioms.

44
00:02:45,320 --> 00:02:47,000
They talk about quality.

45
00:02:47,000 --> 00:02:50,080
This will take you back to grade school.

46
00:02:50,080 --> 00:02:53,520
For every number x, x equals x, that's reflexive.

47
00:02:53,520 --> 00:02:59,560
For everything x and y, if x equals y, then y equals z, that's symmetric.

48
00:02:59,560 --> 00:03:06,280
For all numbers x, y and z, if x equals y and y equals z, then x equals z, that's transitive.

49
00:03:06,280 --> 00:03:08,000
For all a and b, this is an important one.

50
00:03:08,000 --> 00:03:12,600
If b is a natural number, and a equals b, then a is also a natural number.

51
00:03:12,600 --> 00:03:16,480
This seems like kind of a weird one, that we have to have an axiom about being closed

52
00:03:16,480 --> 00:03:20,720
under equality, but this is essential because it means that if you have two things that

53
00:03:20,720 --> 00:03:26,080
you're saying are equal, one of them isn't like a cow, or some other thing.

54
00:03:26,080 --> 00:03:27,080
It's a natural number.

55
00:03:27,080 --> 00:03:30,280
You can, you know, if two things are equal, they're both natural numbers.

56
00:03:30,280 --> 00:03:34,160
The next three are about what is called a successor function, which we're going to build.

57
00:03:34,160 --> 00:03:35,800
It's going to be awesome.

58
00:03:35,800 --> 00:03:38,760
For every number n, s of n is a number.

59
00:03:38,760 --> 00:03:43,560
So we're closed under succession, I guess, or successor.

60
00:03:43,560 --> 00:03:49,000
For all numbers m and n, this is important, m equals n if and only if the successor of

61
00:03:49,000 --> 00:03:52,240
m equals the successor of n.

62
00:03:52,240 --> 00:03:56,760
This is effectively zero equals zero, one equals one, two equals two, but we're going

63
00:03:56,760 --> 00:03:59,600
to use this to great advantage.

64
00:03:59,600 --> 00:04:07,440
Number eight says that for every number n, oh, bye, the, if you find the successor of

65
00:04:07,440 --> 00:04:10,000
n equal to zero, that's false.

66
00:04:10,000 --> 00:04:15,040
So zero is kind of our starting point, and we'll actually use this one surprisingly.

67
00:04:15,040 --> 00:04:18,720
There's a ninth axiom, which is about induction, which is the way of saying that, oh, it's

68
00:04:18,720 --> 00:04:23,400
true for zero and one, and it's true for everything, so it's true for everything.

69
00:04:23,400 --> 00:04:26,840
I'm going to skip that and just wave my arms a lot.

70
00:04:26,840 --> 00:04:28,800
So, okay.

71
00:04:28,800 --> 00:04:31,680
Brief aside about how, I'm going to use Ruby.

72
00:04:31,680 --> 00:04:37,480
Most people would think that, like, Haskell would be a great thing for this, and it would.

73
00:04:37,480 --> 00:04:41,640
So we're going to use Ruby because, well, Ruby.

74
00:04:41,640 --> 00:04:46,880
So a lambda and Ruby gets written like this.

75
00:04:46,880 --> 00:04:49,560
Get an identifier.

76
00:04:49,560 --> 00:04:52,400
You don't need to know, if you don't know Ruby, that's okay, because most of the time

77
00:04:52,400 --> 00:04:56,760
when I'm done with this, nobody has actually recognized that I've written Ruby.

78
00:04:56,760 --> 00:05:02,880
We get an identifier, in this case the identity function, little stabby pointy thing, and

79
00:05:02,880 --> 00:05:05,360
then an x, which is your parameter.

80
00:05:06,360 --> 00:05:11,040
Ruby lambdas can take multiple parameters, but we're only letting it have one.

81
00:05:11,040 --> 00:05:14,400
And what's inside of it is your return value.

82
00:05:14,400 --> 00:05:17,560
In this case, this is the identity function.

83
00:05:17,560 --> 00:05:25,800
You can actually call Ruby parameter or Ruby lambdas in two different ways.

84
00:05:25,800 --> 00:05:34,360
You can use this wonderful dot parenthesis syntax, it looks like a method call, or you

85
00:05:34,360 --> 00:05:39,080
can use this bracket, which looks like accessing an array and doesn't seem like it should actually

86
00:05:39,080 --> 00:05:41,640
execute the lambda.

87
00:05:41,640 --> 00:05:50,720
But if you run this, and yeah, that actually is my normal prompt, it does run.

88
00:05:50,720 --> 00:05:56,480
So we're, of course, going to use the crazy bracket one, because why not?

89
00:05:56,480 --> 00:06:00,440
The other one has actually one more character, and I don't like to type that much.

90
00:06:00,440 --> 00:06:02,480
So let's get started.

91
00:06:02,480 --> 00:06:04,080
Everybody's cool.

92
00:06:04,080 --> 00:06:07,920
We need a good starting place, and a good starting place.

93
00:06:07,920 --> 00:06:14,680
As I learned last time I watched, I believe it's the sound of music, is that it's at the

94
00:06:14,680 --> 00:06:15,680
beginning.

95
00:06:15,680 --> 00:06:20,400
So zero is a natural number, that's a great place to start.

96
00:06:20,400 --> 00:06:22,440
So let's start with that.

97
00:06:22,440 --> 00:06:26,760
So I'm going to actually write something that is zero, zero.

98
00:06:26,760 --> 00:06:29,600
That seems like a pretty straightforward thing to write.

99
00:06:29,600 --> 00:06:31,840
But the problem is, of course, I don't know anything about this.

100
00:06:31,840 --> 00:06:33,720
I don't know anything about the zero function.

101
00:06:33,720 --> 00:06:36,920
I don't know anything about that zero statement there.

102
00:06:36,920 --> 00:06:39,800
We don't have any information at all.

103
00:06:39,800 --> 00:06:42,520
And also axioms are about statements of fact.

104
00:06:42,520 --> 00:06:45,560
They're not about, like, just having a piece of code.

105
00:06:45,560 --> 00:06:52,440
So really the axiom is more something like this, that I can assert that there's a zero,

106
00:06:52,440 --> 00:06:53,720
that there is something.

107
00:06:53,720 --> 00:06:55,600
So now I've got this other function assert, of course.

108
00:06:55,600 --> 00:06:57,760
I don't know anything about that either.

109
00:06:57,760 --> 00:07:00,000
And I'm just making stuff up as I go along.

110
00:07:00,000 --> 00:07:04,520
So let's take a step back and talk about assert.

111
00:07:04,520 --> 00:07:11,720
So the behavior we want from assert is, assert is something that I want to use to figure

112
00:07:11,720 --> 00:07:18,040
out if a statement is valid, whoops, that wasn't, oh, if a statement is valid.

113
00:07:18,040 --> 00:07:20,480
Now what does that mean?

114
00:07:20,480 --> 00:07:26,240
I don't know yet, but I know that if it's valid, I want it to print out something like

115
00:07:26,240 --> 00:07:30,520
a t, and if it's invalid, I want it to print out something like an f.

116
00:07:30,520 --> 00:07:34,080
So it needs to tell the difference between these two things, and I'm going to make up

117
00:07:34,080 --> 00:07:39,960
two other functions and two other statements called true and false.

118
00:07:39,960 --> 00:07:49,160
So my assert function, if I pass it true, I would expect it to output a t.

119
00:07:49,160 --> 00:07:52,040
And if it's false, I'm going to have it output an f.

120
00:07:52,040 --> 00:07:58,180
This is just a statement I can make up anything I want, because I got nothing to work with.

121
00:07:58,180 --> 00:08:01,880
So we've got these two new functions now, true and false.

122
00:08:01,880 --> 00:08:03,760
Remember everything's a function in this.

123
00:08:03,760 --> 00:08:06,560
So now I've got a little bit more information.

124
00:08:06,560 --> 00:08:08,320
I can talk about assert.

125
00:08:08,320 --> 00:08:11,240
Now so what are true and false?

126
00:08:11,240 --> 00:08:13,320
So I've got these two statements.

127
00:08:13,320 --> 00:08:16,960
So I'm going to do a little bit of circular logic here, because that's always a great

128
00:08:16,960 --> 00:08:19,120
way to make decisions.

129
00:08:19,120 --> 00:08:26,760
So true is the thing that if I pass it to assert, I see a t.

130
00:08:26,760 --> 00:08:31,480
And false is the thing that if I pass it to assert, I see an f.

131
00:08:31,480 --> 00:08:32,480
That's great.

132
00:08:32,480 --> 00:08:34,880
I can make up things as I want.

133
00:08:34,880 --> 00:08:40,320
Assert, if I'm going to say the definition of assert, the behavior I expect is that if

134
00:08:40,320 --> 00:08:45,120
I pass it a true, I see a t.

135
00:08:45,120 --> 00:08:48,920
And if I pass it a false, I see an f.

136
00:08:48,920 --> 00:08:53,960
It does seem kind of circular, but the only way to really talk about things and to figure

137
00:08:53,960 --> 00:09:00,080
things out is how they behave together, because if you abide by certain philosophies, nothing

138
00:09:00,080 --> 00:09:04,640
actually exists in reality, except as they interact with other things.

139
00:09:04,640 --> 00:09:08,840
That's kind of how I live, so we're going to do that.

140
00:09:08,840 --> 00:09:11,120
So what can I know about assert now?

141
00:09:11,120 --> 00:09:16,920
What I do know is that assert accepts something, and it accepts something called a boolean.

142
00:09:16,920 --> 00:09:18,440
I'm just going to make this term up.

143
00:09:18,440 --> 00:09:20,440
I don't know if you've ever heard of this.

144
00:09:20,440 --> 00:09:25,760
I'm going to make it up to mean true or false, but we don't know what assert actually has

145
00:09:25,760 --> 00:09:30,560
to do, so we figured out a little bit about it that it needs a boolean.

146
00:09:30,560 --> 00:09:35,040
If you look at assert and you look at the definition and this sort of circular logic,

147
00:09:35,040 --> 00:09:37,400
is that it's got to do three things.

148
00:09:37,400 --> 00:09:41,760
It has to figure out if I pass in a true or a false.

149
00:09:41,760 --> 00:09:48,840
It's got to figure out what to do, so print a t or print an f, and it also has to execute

150
00:09:48,840 --> 00:09:50,680
that function.

151
00:09:50,680 --> 00:09:57,080
So it's got to figure out what are the cases, choose which case, and then execute that case.

152
00:09:57,080 --> 00:10:03,400
That's three things, and of course that's way too many things for a function to do.

153
00:10:03,400 --> 00:10:07,880
One of the core principles of the lambda calculus and lambdas in general is this concept called

154
00:10:07,880 --> 00:10:13,040
the single responsibility principle, mostly because you only have like one line in there

155
00:10:13,040 --> 00:10:15,280
and so you can't do much.

156
00:10:15,280 --> 00:10:22,960
So what we're going to do is take a look at assert, and what we do know is that it needs

157
00:10:22,960 --> 00:10:32,880
to either puts a t or I want the function of puts an f.

158
00:10:32,880 --> 00:10:40,160
So assert its job is to actually do one of these two things.

159
00:10:40,160 --> 00:10:44,240
So we've already mentioned booleans that are true and false, these encapsulate the idea

160
00:10:44,240 --> 00:10:45,960
of two different things.

161
00:10:45,960 --> 00:10:47,840
We've got them right up there.

162
00:10:47,840 --> 00:10:53,600
So it seems reasonable to handle, let them handle an actual choice mechanism.

163
00:10:53,600 --> 00:10:59,080
So our booleans are the things that we're actually going to use to do the choosing, but we need

164
00:10:59,080 --> 00:11:00,240
one more construct.

165
00:11:00,240 --> 00:11:01,960
We have three things to do.

166
00:11:01,960 --> 00:11:04,160
We've got a responsibility for assert.

167
00:11:04,160 --> 00:11:06,520
We have a responsibility for our booleans.

168
00:11:06,520 --> 00:11:13,360
We have a third thing, and I'm going to pull just a word out of the dictionary, and I'm

169
00:11:13,360 --> 00:11:17,160
going to call that if.

170
00:11:17,160 --> 00:11:19,040
I know it's kind of crazy.

171
00:11:19,040 --> 00:11:26,000
So what ifs job is to do is to actually execute the final thing.

172
00:11:26,000 --> 00:11:31,840
So it's sort of a coordinator between my assert method and the boolean itself.

173
00:11:31,840 --> 00:11:36,360
I'm just making this up, and it's got two letters, so it's okay.

174
00:11:36,360 --> 00:11:40,120
One of the things that I want to be able to say about it, so I want to give a little bit

175
00:11:40,120 --> 00:11:42,640
of definition and a little examples of it.

176
00:11:42,640 --> 00:11:53,120
So if I give it a true, and I give it something that says you gave me a true, and then I give

177
00:11:53,120 --> 00:12:04,440
it something, you know, a second thing that puts you gave me a false, and I actually spell

178
00:12:04,440 --> 00:12:13,600
that right, then I should see you gave me a true and you gave me a false.

179
00:12:13,600 --> 00:12:16,040
This is what I would like to have happen.

180
00:12:16,040 --> 00:12:18,720
I would like the if statement to actually execute this.

181
00:12:18,720 --> 00:12:23,760
It coordinates between the boolean and these two options.

182
00:12:23,760 --> 00:12:28,800
For the sticklers out there, I am kind of breaking the only lambdas rule here.

183
00:12:28,800 --> 00:12:32,800
I'm using some ruby stuff to do puts, and there's a string there, but that's where

184
00:12:32,800 --> 00:12:38,600
expediency have to bear with me a tiny bit here, otherwise we're going to end up spending

185
00:12:38,600 --> 00:12:43,240
all day generating numbers and letters and strings and lists and all of that, and I don't

186
00:12:43,240 --> 00:12:46,080
really feel like doing that today.

187
00:12:46,080 --> 00:12:49,120
So let's look again at this.

188
00:12:49,120 --> 00:12:50,760
Now what is if?

189
00:12:50,760 --> 00:12:54,160
What can I tell about if since I've wrote these examples?

190
00:12:54,160 --> 00:13:04,440
So what I can say is that if it's a function that when given true executes the first function

191
00:13:04,440 --> 00:13:10,760
that I gave it, and if I give it false, it executes the second function.

192
00:13:10,760 --> 00:13:12,280
That's sort of the definition.

193
00:13:12,280 --> 00:13:16,000
That's what I want this construct to do.

194
00:13:16,000 --> 00:13:25,000
No, because false executes the second function.

195
00:13:25,000 --> 00:13:29,320
So I want this to say the first time you gave me a true, the second time you gave me a false.

196
00:13:29,320 --> 00:13:31,040
So awesome.

197
00:13:31,040 --> 00:13:35,080
So with this, I can start to define a little bit about if.

198
00:13:35,080 --> 00:13:37,840
I can start to figure out a few things about it.

199
00:13:37,840 --> 00:13:39,640
So what do we know?

200
00:13:39,640 --> 00:13:49,000
We know that if takes a Boolean, right, that's that first thing, it returns a function that

201
00:13:49,000 --> 00:13:54,480
takes something else because remember we only accept one parameter per function.

202
00:13:54,480 --> 00:14:03,840
That's the second thing, the true case, and then it takes a false case, like that.

203
00:14:03,840 --> 00:14:06,360
But I don't exactly know what goes here.

204
00:14:06,360 --> 00:14:13,680
I know that I want the behavior to be if Boolean is true, execute true case, if false, false

205
00:14:13,680 --> 00:14:15,520
case.

206
00:14:15,520 --> 00:14:19,640
So I know that that's kind of what the functionality that I want.

207
00:14:19,640 --> 00:14:24,480
So one thing, we're going to be implementing a couple sort of functions that technically

208
00:14:24,480 --> 00:14:30,240
take more than one parameter, but because our constraint is only one parameter, we have

209
00:14:30,240 --> 00:14:35,960
to do this sort of like crazy indented passing in other functions and things like that.

210
00:14:35,960 --> 00:14:41,240
I like to write it like this to sort of highlight that it actually is a three parameter function,

211
00:14:41,240 --> 00:14:47,280
but because I'm silly and put a constraint on myself, I can't do that.

212
00:14:47,280 --> 00:14:49,240
So also helps with some indentation stuff.

213
00:14:49,240 --> 00:14:52,520
So let's keep moving on.

214
00:14:52,520 --> 00:14:58,080
So the if statement is responsible for the execution.

215
00:14:58,080 --> 00:15:05,600
We decided that the Boolean was responsible for choosing, so we kind of, it would be nice

216
00:15:05,600 --> 00:15:08,280
if we could do this.

217
00:15:08,280 --> 00:15:16,080
Now what this says is, hey Boolean, why don't you choose between these two?

218
00:15:16,080 --> 00:15:18,480
And then whatever comes back, I'm going to execute.

219
00:15:18,480 --> 00:15:23,400
I have to pass in the identity because remember we have single parameter functions, so I can't

220
00:15:23,400 --> 00:15:24,640
just call the function.

221
00:15:24,640 --> 00:15:26,160
I have to give it something.

222
00:15:26,160 --> 00:15:30,320
And identity is the closest thing we have to I don't care.

223
00:15:30,320 --> 00:15:31,960
Like it's just, it's identity.

224
00:15:31,960 --> 00:15:32,960
Who has an identity?

225
00:15:32,960 --> 00:15:35,040
It doesn't really matter.

226
00:15:35,040 --> 00:15:37,080
Everything exists.

227
00:15:37,080 --> 00:15:41,200
So now we have a little bit about true and false.

228
00:15:41,200 --> 00:15:45,880
Now we've determined a few of the behaviors or one core behavior that we need, which is

229
00:15:45,880 --> 00:15:53,280
that true, it takes a first parameter and it takes a second parameter because that's

230
00:15:53,280 --> 00:15:55,280
what Booleans do.

231
00:15:55,280 --> 00:15:56,280
And what does it do?

232
00:15:56,280 --> 00:15:59,360
It returns me the first one.

233
00:15:59,360 --> 00:16:03,240
It returns me the true case.

234
00:16:03,240 --> 00:16:08,160
False on the other hand, let me just grab that.

235
00:16:08,160 --> 00:16:13,320
False returns me the second one.

236
00:16:13,320 --> 00:16:17,600
So now this if statement works.

237
00:16:17,600 --> 00:16:22,080
I pass the true case and the false case, if Boolean happens to be true, it will return

238
00:16:22,080 --> 00:16:23,080
me the first one.

239
00:16:23,080 --> 00:16:24,280
I execute it.

240
00:16:24,280 --> 00:16:25,280
Great.

241
00:16:25,280 --> 00:16:26,280
And let's see if it runs.

242
00:16:26,280 --> 00:16:31,720
And sure enough, we have our little sample here working.

243
00:16:31,720 --> 00:16:34,040
So now we have an if statement.

244
00:16:34,040 --> 00:16:38,560
We've devised this crazy idea called Booleans.

245
00:16:38,560 --> 00:16:41,160
So we can move on to assert now.

246
00:16:41,160 --> 00:16:48,560
So of course, our assert is pretty easy because we have everything that we needed.

247
00:16:48,560 --> 00:16:58,880
So if my Boolean is true, then prints that, otherwise there.

248
00:16:58,880 --> 00:17:00,040
So I just check it.

249
00:17:00,040 --> 00:17:05,400
This is the kind of a standard way to write it.

250
00:17:05,400 --> 00:17:11,000
Now I would expect my initial things that I wanted, assert true and assert false, to

251
00:17:11,000 --> 00:17:14,320
print T and F. Then sure enough, they do.

252
00:17:14,320 --> 00:17:16,320
So now I have an assert method.

253
00:17:16,320 --> 00:17:20,800
And of course, everybody knows that you can't code if you don't have an assert method because

254
00:17:20,800 --> 00:17:23,040
how do you know it works?

255
00:17:23,040 --> 00:17:28,080
So now we have our testing framework, which is really all you need.

256
00:17:28,080 --> 00:17:30,320
And we can come back.

257
00:17:30,320 --> 00:17:35,480
So we've done a lot of work here just to get sort of a basic thing.

258
00:17:35,480 --> 00:17:39,580
And there's this weird thing too here.

259
00:17:39,580 --> 00:17:45,600
The reason you have to put this, wrap this in a lambda, and I can't just say if Boolean

260
00:17:45,600 --> 00:17:53,080
puts T, is because Ruby is an eager evaluating language, which means that Ruby evaluates

261
00:17:53,080 --> 00:17:57,800
every function argument before it calls the function.

262
00:17:58,520 --> 00:18:05,080
If I didn't have this lambda like that, it would actually try to execute that puts T

263
00:18:05,080 --> 00:18:09,200
and the puts F, and then it would go into the functions, and you'd end up with a nail

264
00:18:09,200 --> 00:18:18,680
reference exception, which is sort of the general exception that always happens in Ruby.

265
00:18:18,680 --> 00:18:20,480
So we've got our assert.

266
00:18:20,480 --> 00:18:27,880
I'm going to jump just slightly ahead because if you have assert, it always is nice to have

267
00:18:27,880 --> 00:18:31,960
refute, which just does the other side.

268
00:18:31,960 --> 00:18:33,720
We're going to use this later.

269
00:18:33,720 --> 00:18:38,640
Refute just says the Boolean should be false.

270
00:18:38,640 --> 00:18:42,360
There's a whole nother talk I'm putting together where we actually build up Boolean logic and

271
00:18:42,360 --> 00:18:45,960
hand and knot and all of that stuff, but not this time.

272
00:18:45,960 --> 00:18:47,120
So now we've got assert.

273
00:18:47,120 --> 00:18:51,520
We can get back to this thing, assert.

274
00:18:51,520 --> 00:18:54,800
So now we're back to actually doing something interesting.

275
00:18:54,800 --> 00:19:01,080
If we try to run this, of course, we get uninitialized constant is zero because I haven't defined

276
00:19:01,080 --> 00:19:06,960
that, but by defining assert, I now have a little bit of information about is zero.

277
00:19:06,960 --> 00:19:14,640
I know that is zero has to take a parameter, and it has to return a Boolean because I'm

278
00:19:14,680 --> 00:19:18,560
asserting on it, and I've determined that assert takes a Boolean.

279
00:19:18,560 --> 00:19:24,960
So I'm just going to return true because that's always the easiest thing to do.

280
00:19:24,960 --> 00:19:29,440
We don't know anything about zero, either, the parameter that comes in.

281
00:19:29,440 --> 00:19:32,720
We do know that it's a function because everything's a function.

282
00:19:32,720 --> 00:19:36,280
So since I don't know anything about it, I'm just going to make something up and give it

283
00:19:36,280 --> 00:19:40,560
my stand-in for, hmm?

284
00:19:40,560 --> 00:19:42,000
Okay.

285
00:19:42,000 --> 00:19:43,840
So now we're passing.

286
00:19:43,840 --> 00:19:48,120
So we got our T, so we've actually got a zero now, and we have a way to determine whether

287
00:19:48,120 --> 00:19:49,840
or not something is zero.

288
00:19:49,840 --> 00:19:52,520
Pretty cool, right?

289
00:19:52,520 --> 00:19:54,840
That's a lot of work, so here's our reward.

290
00:19:54,840 --> 00:19:58,560
Yay, there's my cat sack.

291
00:19:58,560 --> 00:19:59,760
Okay?

292
00:19:59,760 --> 00:20:05,320
So now the piano axioms have a part about equality.

293
00:20:05,320 --> 00:20:06,720
All we have right now is zero.

294
00:20:06,720 --> 00:20:09,440
We've satisfied axiom one.

295
00:20:09,440 --> 00:20:12,040
We're going to start talking about equality.

296
00:20:12,040 --> 00:20:15,920
And two here states that for every number x, x equals x.

297
00:20:15,920 --> 00:20:16,920
Pretty straightforward.

298
00:20:16,920 --> 00:20:18,440
That's the symmetric property.

299
00:20:18,440 --> 00:20:27,280
So we're going to come down here and say, I can assert, right, that numbers equal zero

300
00:20:27,280 --> 00:20:30,160
and zero.

301
00:20:30,160 --> 00:20:33,840
That's a pretty, that's what axiom two says.

302
00:20:33,840 --> 00:20:38,680
Of course, I don't know what numbers equal is, so it'll help if I actually try to write

303
00:20:38,680 --> 00:20:39,840
that.

304
00:20:39,840 --> 00:20:41,360
So numbers equal.

305
00:20:41,360 --> 00:20:42,360
But what is it?

306
00:20:42,360 --> 00:20:46,240
I know it's a lambda that takes something.

307
00:20:46,240 --> 00:20:50,480
Because I've got the axiom that tells me that it's comparing two things, I know that it

308
00:20:50,480 --> 00:20:52,400
takes two parameters.

309
00:20:52,400 --> 00:20:57,000
So I'm going to take the first and the second parameter.

310
00:20:57,000 --> 00:21:03,540
Now, all we have in our numbering system is zero, and zero equals zero.

311
00:21:03,540 --> 00:21:06,840
We don't have any other things, so what should this return?

312
00:21:06,840 --> 00:21:08,560
I know it has to return a Boolean.

313
00:21:08,560 --> 00:21:12,160
Well, the simplest thing for it to return is true.

314
00:21:12,160 --> 00:21:15,800
Because as it stands, that's all I actually know.

315
00:21:15,800 --> 00:21:21,000
And if I run, there it is, I'm still, I'm passing again, and life is good.

316
00:21:21,000 --> 00:21:24,840
So life is really simple, this is a philosophical point.

317
00:21:24,840 --> 00:21:28,360
Life is simple when all you have is zero.

318
00:21:28,360 --> 00:21:29,860
Okay.

319
00:21:29,860 --> 00:21:32,720
That's my statement of fact about the world.

320
00:21:32,720 --> 00:21:37,440
So let's move onward to the building of sort of the natural numbers.

321
00:21:37,440 --> 00:21:42,080
We've started at zero, we actually kind of need to move up, otherwise nothing is really

322
00:21:42,080 --> 00:21:43,580
that interesting.

323
00:21:43,580 --> 00:21:46,080
So let's take a look at these successor functions.

324
00:21:46,080 --> 00:21:50,320
We kind of instinctively know that the successor function is sort of like plus one, or it's

325
00:21:50,320 --> 00:21:52,200
the next number in there.

326
00:21:52,200 --> 00:21:57,240
But we can't use our intuition on any of this, because of course we're using these axioms

327
00:21:57,240 --> 00:21:59,200
to build up the natural number.

328
00:21:59,200 --> 00:22:05,680
So if we come down and talk about, so for every number in, the successor of n is a number.

329
00:22:06,240 --> 00:22:07,720
Seems pretty straightforward.

330
00:22:07,720 --> 00:22:12,040
So what I can say is let's start building this function.

331
00:22:12,040 --> 00:22:20,560
So if I come up and I say successor, well, it's a function that takes a number.

332
00:22:20,560 --> 00:22:26,760
It has to return me a natural number, because the axiom says that the successor of n is

333
00:22:26,760 --> 00:22:27,760
a natural number.

334
00:22:27,760 --> 00:22:32,400
Well, I only have two natural numbers that I know about, zero and the successor of zero.

335
00:22:32,400 --> 00:22:37,600
And it seems kind of strange for the successor of zero to return the successor of zero.

336
00:22:37,600 --> 00:22:43,400
So since it doesn't tell me anything else, I'm just going to choose it to return zero.

337
00:22:43,400 --> 00:22:46,000
Still only kind of have zero, but everything's happy now.

338
00:22:46,000 --> 00:22:55,600
So since it's a natural number, we can use our number equality, because where is it?

339
00:22:55,600 --> 00:22:56,600
This thing.

340
00:22:56,600 --> 00:23:01,500
For all a and b, if b is a natural number and they're equal, they're natural numbers.

341
00:23:01,500 --> 00:23:10,180
So I can actually write that the numbers equal the successor of zero and the successor of

342
00:23:10,180 --> 00:23:12,220
zero.

343
00:23:12,220 --> 00:23:14,260
How do I know that that's true?

344
00:23:14,260 --> 00:23:17,260
There we go.

345
00:23:17,260 --> 00:23:27,860
I know this is true, because I have the axiom that says if x equals y, zero equals zero,

346
00:23:27,860 --> 00:23:34,020
and the successors, that's this one, zero equals zero if and only if the successors

347
00:23:34,020 --> 00:23:37,180
of zero is equal to the successors of zero.

348
00:23:37,180 --> 00:23:42,540
So I can make this statement, this bold, bold statement, and I can run my tests and sure

349
00:23:42,540 --> 00:23:44,300
enough it's true.

350
00:23:44,300 --> 00:23:49,460
As I've said a couple of times, life is super easy when all you have is zero.

351
00:23:49,460 --> 00:23:53,420
So this point, number equals always returns true.

352
00:23:53,420 --> 00:23:59,860
It doesn't give us that much wonderful information, but here's the thing we're going to do.

353
00:23:59,860 --> 00:24:07,660
Our big breakthrough comes when we look at the amazing axiom number eight.

354
00:24:07,660 --> 00:24:15,740
Axiom number eight says that for every number n, the successor of n is not zero.

355
00:24:15,740 --> 00:24:19,620
So if we say that it's zero, then we're false.

356
00:24:19,620 --> 00:24:22,560
So that gives us a little statement here.

357
00:24:22,560 --> 00:24:33,960
So we can say that we can actually refute the idea that the successor of zero is zero.

358
00:24:33,960 --> 00:24:44,400
And we can also refute if we try to do numbers equal of the successor of zero and zero.

359
00:24:44,400 --> 00:24:51,000
So these two statements, according to that axiom, this should give me truth.

360
00:24:51,000 --> 00:24:57,400
But my number system does not work.

361
00:24:57,400 --> 00:25:00,040
So these are kind of the same.

362
00:25:00,040 --> 00:25:05,920
But so let's take a step back to the beginning and look at is zero.

363
00:25:05,920 --> 00:25:11,080
This needs to differentiate now between zero and the successor of zero or zero and not

364
00:25:11,080 --> 00:25:12,240
zero.

365
00:25:12,240 --> 00:25:19,600
So what we can want to do is, well, let's do something.

366
00:25:20,040 --> 00:25:22,560
So let's make it so that zero, it's got to be a function.

367
00:25:22,560 --> 00:25:28,600
Let's actually make it a function that returns true that says, yeah, I'm zero.

368
00:25:28,600 --> 00:25:34,560
Successor, since it's zero, we can replace it with this, which is zero.

369
00:25:34,560 --> 00:25:38,640
But we want to just mark it and say you're not zero.

370
00:25:38,640 --> 00:25:45,360
So we're taking the code that zero was and just saying, nope, false.

371
00:25:45,360 --> 00:25:52,320
Let's run it so you can see it.

372
00:25:52,320 --> 00:25:55,280
So successor returns a function.

373
00:25:55,280 --> 00:26:00,320
We need to affect is zero here because is zero is just doing that.

374
00:26:00,320 --> 00:26:06,800
But now each number that we have is a function that returns whether it's zero or not.

375
00:26:06,800 --> 00:26:12,560
So we can just call it and get that true or false back.

376
00:26:12,560 --> 00:26:19,440
So at this point, is zero can ask are you zero or not?

377
00:26:19,440 --> 00:26:24,160
And we can see that we got one more t, which was this refutation.

378
00:26:24,160 --> 00:26:27,400
But our numbers equal still doesn't work.

379
00:26:27,400 --> 00:26:34,880
So we're going to take a little bit of a step back in order to get this working and comment

380
00:26:34,880 --> 00:26:41,440
these out and look again at numbers equals zero, zero.

381
00:26:41,440 --> 00:26:45,280
This is going to help us build out this numbers equal method for a second.

382
00:26:45,280 --> 00:26:57,840
So what we want to say is that if the numbers, if the first number is zero, then we can actually

383
00:26:57,840 --> 00:27:10,800
check and see if the second number is zero, make sure that I have like that.

384
00:27:11,160 --> 00:27:12,840
Otherwise we can just say you're not.

385
00:27:12,840 --> 00:27:13,840
It doesn't matter.

386
00:27:13,840 --> 00:27:18,440
So this says if the first number is zero, then just return whether or not the second

387
00:27:18,440 --> 00:27:19,440
number is zero.

388
00:27:19,440 --> 00:27:22,480
And if they're both zero, then you get a true.

389
00:27:22,480 --> 00:27:40,880
Doing this, it helps if I actually make that second.

390
00:27:40,880 --> 00:27:45,680
So this isn't the final solution, but it's something that satisfies what we have so far.

391
00:27:45,680 --> 00:27:48,800
And it satisfies axiom eight.

392
00:27:48,800 --> 00:27:54,960
So if I come down and get rid of these, which is the axiom eight, I can see that those are

393
00:27:54,960 --> 00:27:57,120
satisfied now.

394
00:27:57,120 --> 00:28:04,400
So we know that the successor of zero is not zero.

395
00:28:04,400 --> 00:28:10,880
And so we can kind of take the leap to move on to non-zero numbers and actually start

396
00:28:10,880 --> 00:28:14,480
talking about these a little bit more.

397
00:28:14,480 --> 00:28:26,400
Let's expand this one just a little bit to show that not equaling is sort of, successor

398
00:28:26,400 --> 00:28:31,160
of zero is not equal to zero, but also zero is not equal to the successor of zero, just

399
00:28:31,160 --> 00:28:32,920
kind of flipping them around.

400
00:28:32,920 --> 00:28:40,160
The idea that successor of zero is not equal to zero, and then the symmetric form says

401
00:28:40,160 --> 00:28:44,400
that zero is not equal to the successor of zero.

402
00:28:44,400 --> 00:28:49,760
One day, I'm actually, this whole successor, successor, successor, successor kind of thing

403
00:28:49,760 --> 00:28:52,480
will deal with that.

404
00:28:52,480 --> 00:28:56,320
So let's talk about non-zero numbers.

405
00:28:56,320 --> 00:29:04,440
So if we kind of jump up here for a second, we know that zero equals zero, right?

406
00:29:04,440 --> 00:29:10,600
And we know that m equals n if and only if the successor of m is equal to the successor

407
00:29:10,600 --> 00:29:13,840
of n.

408
00:29:13,840 --> 00:29:25,520
This implies that this implies this guy, that the successor of zero needs to be equal to

409
00:29:25,520 --> 00:29:27,760
the successor of zero.

410
00:29:27,760 --> 00:29:29,560
But there's an f.

411
00:29:29,560 --> 00:29:33,320
Our implementation doesn't satisfy this.

412
00:29:33,320 --> 00:29:37,080
And this makes sense because if you look at what we're doing, we're always returning

413
00:29:37,080 --> 00:29:38,560
false.

414
00:29:38,560 --> 00:29:41,680
So what should we do about this?

415
00:29:41,680 --> 00:29:44,680
Well let's look at axiom number seven.

416
00:29:44,680 --> 00:29:50,760
This says, oops, for all numbers m and n, m equals n if and only if the successor of

417
00:29:50,760 --> 00:29:55,280
m equals the successor of n.

418
00:29:55,280 --> 00:29:58,160
This means that this should be true.

419
00:29:58,160 --> 00:30:05,280
Since we're only working with zero and non-zero right now, we can put here that if the first

420
00:30:05,280 --> 00:30:14,880
number is not zero, then the second one can't be zero either.

421
00:30:14,880 --> 00:30:21,880
So I can just return false if the second one is zero.

422
00:30:21,880 --> 00:30:24,640
You need to open.

423
00:30:24,640 --> 00:30:31,600
And then I'm just going to return true here.

424
00:30:32,400 --> 00:30:39,520
Now we're back to everything passing off.

425
00:30:39,520 --> 00:30:40,520
All the Ts.

426
00:30:40,520 --> 00:30:41,720
Yay!

427
00:30:41,720 --> 00:30:43,920
So this is actually getting pretty ugly.

428
00:30:43,920 --> 00:30:46,840
Can anybody read this?

429
00:30:46,840 --> 00:30:47,840
It's kind of hard.

430
00:30:47,840 --> 00:30:48,840
Awesome.

431
00:30:48,840 --> 00:30:50,960
I want to tell you I can.

432
00:30:50,960 --> 00:30:55,160
But we're biting sort of my usual process of coding, which is make it work, then make

433
00:30:55,160 --> 00:30:59,880
it pretty, hopefully remembering that second part of it.

434
00:31:00,240 --> 00:31:07,960
We could return false here, but if we do that, then we get that failure.

435
00:31:07,960 --> 00:31:15,120
So true enough we need to return true to do it.

436
00:31:15,120 --> 00:31:16,440
So this works for two numbers.

437
00:31:16,440 --> 00:31:20,200
We now have zero and we have the successor of zero, but we don't have anything more

438
00:31:20,200 --> 00:31:22,200
than that.

439
00:31:22,200 --> 00:31:27,800
What this kind of says is I would really, really love it if I could take the successor

440
00:31:27,800 --> 00:31:40,800
of the successor of zero and compare it to the successor of zero.

441
00:31:40,800 --> 00:31:43,440
Does anybody think this should work?

442
00:31:43,440 --> 00:31:44,800
No!

443
00:31:44,800 --> 00:31:57,080
This is effectively two equals one, especially if I put an extra thing there, but it passes.

444
00:31:57,080 --> 00:32:03,000
Everybody of course has heard that two equals one for sufficiently large values of one.

445
00:32:03,000 --> 00:32:06,960
But for us, we can't abide by that.

446
00:32:06,960 --> 00:32:07,960
We don't have.

447
00:32:07,960 --> 00:32:09,920
We have just a size of one.

448
00:32:09,920 --> 00:32:18,480
So we're going to use the wonderful axiom here, axiom number eight, to figure this out.

449
00:32:18,480 --> 00:32:23,120
However, let's talk about how this is going to help us.

450
00:32:23,120 --> 00:32:27,920
So for every number in, the successor of n is equal to zero is false.

451
00:32:27,920 --> 00:32:30,600
So there's no number whose successor is zero.

452
00:32:30,600 --> 00:32:33,840
Now I'm going to do a little bit of math here.

453
00:32:33,840 --> 00:32:37,840
So hold your horses, I'm about to do math.

454
00:32:37,840 --> 00:32:42,880
I'm going to use a logic or a proof mechanism called proof by contradiction.

455
00:32:42,880 --> 00:32:43,880
So we'll walk through it quickly.

456
00:32:43,880 --> 00:32:46,280
It's my favorite way of proving things.

457
00:32:46,280 --> 00:32:51,000
So let's assume this is true, like our number statement or our system says.

458
00:32:51,000 --> 00:32:56,520
So let me do a little bit of setting a variable.

459
00:32:56,520 --> 00:33:02,120
I'm going to say m is equal to the successor of zero, n is equal to zero.

460
00:33:02,120 --> 00:33:10,520
So if I repeat this or substitute this back in, that says that the successor of m is equal

461
00:33:10,520 --> 00:33:15,320
to the successor of n, yeah?

462
00:33:15,320 --> 00:33:20,320
Now if I replace m and n with their definitions, right?

463
00:33:20,320 --> 00:33:25,320
What am I doing?

464
00:33:25,320 --> 00:33:26,320
Oh.

465
00:33:26,320 --> 00:33:34,280
m, n, this says the successor of m and n.

466
00:33:34,280 --> 00:33:43,120
We know that according to axiom eight or axiom seven, if m equals n, if and only if the

467
00:33:43,120 --> 00:33:49,240
successor of m is equal to the successor of n, which says I should, if the successors

468
00:33:49,240 --> 00:33:51,320
are equal, then the numbers are equal.

469
00:33:51,320 --> 00:33:58,480
So that tells me I can say this, m, n, right?

470
00:33:58,480 --> 00:33:59,480
Just by substituting.

471
00:33:59,480 --> 00:34:01,760
Well, let me substitute these back in.

472
00:34:01,760 --> 00:34:08,840
Oh, look at this.

473
00:34:08,840 --> 00:34:09,840
What does that say?

474
00:34:09,840 --> 00:34:16,220
It says that the successor of zero is equal to zero.

475
00:34:16,220 --> 00:34:20,880
That violates axiom number eight.

476
00:34:20,880 --> 00:34:23,600
So that means that I've reached a contradiction.

477
00:34:23,600 --> 00:34:28,400
I've reached something false, which means that's wrong, that's wrong, that's wrong, that's

478
00:34:28,400 --> 00:34:31,640
wrong, that's wrong, that's wrong.

479
00:34:31,640 --> 00:34:37,920
So since assuming that this was true led me to a contradiction, I actually have the opposite

480
00:34:37,920 --> 00:34:39,720
of what that assumption was.

481
00:34:40,600 --> 00:34:47,560
So these axioms along with what I have so far has shown me that I need to put a refute

482
00:34:47,560 --> 00:34:49,060
here.

483
00:34:49,060 --> 00:34:55,440
But my code doesn't satisfy that because my code only knows about this.

484
00:34:55,440 --> 00:34:57,840
Everybody follow that?

485
00:34:57,840 --> 00:35:01,920
Okay, well, let's have a picture of a cat.

486
00:35:01,920 --> 00:35:04,000
There's Squeaks.

487
00:35:04,000 --> 00:35:08,520
Their full name is you can do it, Squeaks, the story of little Carrie Strug by Corey

488
00:35:08,520 --> 00:35:10,520
Haynes.

489
00:35:10,520 --> 00:35:15,440
Because I find Carrie Strug to be one of the most inspirational figures in the world.

490
00:35:15,440 --> 00:35:19,080
So I wanted to name my cat after her.

491
00:35:19,080 --> 00:35:20,800
So awesome.

492
00:35:20,800 --> 00:35:21,800
Now here we are.

493
00:35:21,800 --> 00:35:23,440
We've got a failing test.

494
00:35:23,440 --> 00:35:24,440
Everything's good.

495
00:35:24,440 --> 00:35:25,720
We've only got a few minutes left.

496
00:35:25,720 --> 00:35:31,360
So we need to build four pages worth of stuff.

497
00:35:31,360 --> 00:35:33,800
So let's come up here.

498
00:35:33,800 --> 00:35:40,960
We're going to comment out this stuff for a second.

499
00:35:40,960 --> 00:35:43,840
And we're going to come up.

500
00:35:43,840 --> 00:35:45,400
So we have tests for successor.

501
00:35:45,400 --> 00:35:50,640
We have this final test that if it passes, we know that we have 0, 1, 2.

502
00:35:50,640 --> 00:35:53,280
We've got sort of the ability to get this.

503
00:35:53,280 --> 00:35:58,160
The successor of 0 is not the successor of 0.

504
00:35:58,160 --> 00:36:03,560
So what we really want to do, though, is be able to come down to this numbers equal and

505
00:36:03,560 --> 00:36:09,600
figure out not just everything's equal that isn't 0, but we actually want to be able to

506
00:36:09,600 --> 00:36:14,240
ask it, are these two numbers the same?

507
00:36:14,240 --> 00:36:20,000
To do this, we really need to know what are the things that caused first and second.

508
00:36:20,000 --> 00:36:23,120
First and second came about by calling successor on something.

509
00:36:23,120 --> 00:36:26,400
We need to find out what that something is.

510
00:36:26,400 --> 00:36:30,520
So what we're going to do is we're going to say we really would like a function called

511
00:36:30,640 --> 00:36:39,400
predecessor that is sort of the inverse of successor.

512
00:36:39,400 --> 00:36:43,480
It's the thing that caused my successor to be what it is.

513
00:36:43,480 --> 00:36:47,720
So if I take the successor of 0 and I take the predecessor of that, I should get 0.

514
00:36:47,720 --> 00:36:52,600
I'm going to write one that's kind of crazy just to capture it.

515
00:36:52,600 --> 00:37:04,240
So the predecessor of the successor of the successor of 0 is successor of 0.

516
00:37:04,240 --> 00:37:09,080
So these are kind of, they're smoke tests just to help me make sure that I've got predecessor

517
00:37:09,080 --> 00:37:10,080
working.

518
00:37:10,080 --> 00:37:17,640
Once we have predecessor working, then I can rely on number 7 that m equals n if and only

519
00:37:17,640 --> 00:37:19,880
if the successors.

520
00:37:19,880 --> 00:37:24,800
If I flip that, it's the successors are equal only if the numbers are equal, which says

521
00:37:24,800 --> 00:37:32,520
I should be able to come down here to numbers equal and say numbers equal predecessor of

522
00:37:32,520 --> 00:37:36,120
first, predecessor of second.

523
00:37:36,120 --> 00:37:41,920
If I build predecessor, I can do this and my numbers equal will be working, but I haven't

524
00:37:41,920 --> 00:37:43,960
yet, so I can't.

525
00:37:43,960 --> 00:37:46,840
So that's our goal is to build predecessor.

526
00:37:47,400 --> 00:37:50,520
Okay, so let's do that.

527
00:37:50,520 --> 00:37:55,200
Let's come up and look at 0, the successor.

528
00:37:55,200 --> 00:38:00,680
Okay, so these have gotten us pretty far, this 0 and successor where we're just returning

529
00:38:00,680 --> 00:38:05,200
true and false, but we need to not just mark whether it's 0 or not, but we need to somehow

530
00:38:05,200 --> 00:38:08,160
carry along when we call successor.

531
00:38:08,160 --> 00:38:12,120
We need to carry along what the number is that we are the successor of.

532
00:38:12,120 --> 00:38:19,800
So we kind of, if I kind of pseudocoded it, I'd like it to look something like this,

533
00:38:19,800 --> 00:38:24,400
you know, a pair.

534
00:38:24,400 --> 00:38:30,840
And because at that point, I can just say that the predecessor of a number m is just

535
00:38:30,840 --> 00:38:35,000
the rightmost thing of m.

536
00:38:35,000 --> 00:38:37,640
I just, I need a pair.

537
00:38:37,640 --> 00:38:41,480
Well of course we don't have a pair, all we have is a lambda and a couple of these things

538
00:38:41,480 --> 00:38:45,040
we did, so let's build pairs real quick.

539
00:38:45,040 --> 00:38:51,160
So in order to write some, just some smoke tests, I'm going to actually make a pair that

540
00:38:51,160 --> 00:38:58,480
is true and false, and then I'm going to make a pair that is false and true, and then I'm

541
00:38:58,480 --> 00:39:07,360
going to assert that the left, or the first part of true false, I can assert that because

542
00:39:07,360 --> 00:39:14,920
it should be true, and I can refute the second part of true false.

543
00:39:14,920 --> 00:39:27,120
And I can assert, or actually I can refute the first part of false true.

544
00:39:27,120 --> 00:39:31,240
So basically I'm making a pair of true false and false true, and then I'm writing a couple

545
00:39:31,240 --> 00:39:34,800
of smoke tests to say that first and second work.

546
00:39:34,920 --> 00:39:38,120
Okay, so what do we know about these functions?

547
00:39:38,120 --> 00:39:45,400
Well, I know that pair has to take a first and a second, right?

548
00:39:45,400 --> 00:39:47,680
I don't know what it does with them.

549
00:39:47,680 --> 00:39:53,000
I know that first is going to take a pair, I don't know what it does with it yet, and

550
00:39:53,000 --> 00:40:00,080
I know that second is going to take a pair, and it's going to do something similar to

551
00:40:00,080 --> 00:40:01,680
first, but I'm not sure exactly.

552
00:40:01,680 --> 00:40:07,240
But it feels a little bit like Booleans again, where Boolean the true picked the first one,

553
00:40:07,240 --> 00:40:10,520
so it makes me feel a little okay.

554
00:40:10,520 --> 00:40:12,840
So what do I know about pair?

555
00:40:12,840 --> 00:40:16,900
So let's work with first and second, because these are sort of our outer behaviors.

556
00:40:16,900 --> 00:40:18,760
What do I know about pair?

557
00:40:18,760 --> 00:40:25,400
I know one thing, it's a function, which means I can call it with a parameter.

558
00:40:25,400 --> 00:40:35,800
Wouldn't it be awesome if I could call it with a function that accepts the first and

559
00:40:35,800 --> 00:40:44,800
the second arguments in the pair and returns, not true, but the first one?

560
00:40:44,800 --> 00:40:50,880
So this is a technique I like to call programming by wishful thinking, which is I code it as

561
00:40:50,880 --> 00:40:55,980
though I always say to myself, wouldn't it be cool if I could do that and actually get

562
00:40:55,980 --> 00:40:56,980
the first item?

563
00:40:56,980 --> 00:40:57,980
Yes.

564
00:40:57,980 --> 00:40:58,980
Thank you.

565
00:40:58,980 --> 00:40:59,980
Second.

566
00:40:59,980 --> 00:41:06,720
Wouldn't it be cool if I could do that, it would be awesome.

567
00:41:06,720 --> 00:41:08,440
So how do I do that?

568
00:41:08,440 --> 00:41:12,800
Well, that tells me that pair needs to return a function.

569
00:41:12,800 --> 00:41:13,800
What's that function called?

570
00:41:13,800 --> 00:41:17,980
Well, I'm going to call it selects value.

571
00:41:17,980 --> 00:41:22,940
So it's a function that takes a function, and then it calls that function passing in

572
00:41:22,940 --> 00:41:24,820
first and second.

573
00:41:24,820 --> 00:41:27,700
Thank you.

574
00:41:27,700 --> 00:41:35,200
So when I call pair with true and false, it returns me a function that takes this selects

575
00:41:35,200 --> 00:41:36,700
value function.

576
00:41:36,700 --> 00:41:42,300
Oh, I didn't write pred yet.

577
00:41:42,300 --> 00:41:45,340
So these are passing.

578
00:41:45,340 --> 00:41:46,340
Look at that.

579
00:41:46,340 --> 00:41:47,380
Four Ts.

580
00:41:47,380 --> 00:41:50,700
So now I have pairs.

581
00:41:50,700 --> 00:41:54,100
Pretty fancy.

582
00:41:54,100 --> 00:41:55,580
So it passes the test.

583
00:41:55,580 --> 00:41:58,060
I'm going to get rid of these because, of course, these are just smoke tests.

584
00:41:58,060 --> 00:42:03,420
And if you saw Jay's talk, then you should delete all of your tests.

585
00:42:03,420 --> 00:42:07,340
And we're going to come down, and we're actually going to use a little bit of this to write

586
00:42:07,340 --> 00:42:08,340
some things.

587
00:42:08,340 --> 00:42:13,540
So zero, what I want zero to be is a pair of true and something else.

588
00:42:13,540 --> 00:42:15,220
It doesn't matter what it is.

589
00:42:15,220 --> 00:42:19,860
And whenever I don't care, I use my identity.

590
00:42:19,860 --> 00:42:26,100
Somewhere there's an identity theft joke in there, but it's not now.

591
00:42:26,100 --> 00:42:32,860
So is zero simply needs to take the first item of that?

592
00:42:32,860 --> 00:42:37,220
Well, what does successor do?

593
00:42:37,220 --> 00:42:42,100
Successor builds me a pair of false and in.

594
00:42:42,100 --> 00:42:47,540
That's like saying that the successor of n is equal to false n.

595
00:42:47,540 --> 00:42:52,860
The successor of the successor of n is equal to false, false n.

596
00:42:52,860 --> 00:42:57,860
So every successor knows that it is not zero.

597
00:42:57,860 --> 00:43:01,380
Now what does predecessor do?

598
00:43:01,380 --> 00:43:07,500
It takes the second part and returns it.

599
00:43:07,500 --> 00:43:19,140
Because if successor makes a pair of false and in, predecessor simply takes that out.

600
00:43:19,140 --> 00:43:26,900
That means that if I come down here and I run my tests, my little smoke tests for predecessor

601
00:43:26,900 --> 00:43:27,900
are working.

602
00:43:27,900 --> 00:43:37,180
So now predecessor is working, which means I can come back to here and do the big trick

603
00:43:37,180 --> 00:43:48,620
which is take, if the first is not zero and the second's not zero, then let me take the

604
00:43:48,620 --> 00:43:55,300
predecessor of the first and the predecessor of the second and see if they're equal.

605
00:43:55,300 --> 00:43:59,700
Because if they are, one more, nope, don't need one more.

606
00:43:59,700 --> 00:44:08,780
Going to seven, if first and second are only equal if their predecessors are equal.

607
00:44:08,780 --> 00:44:15,540
So now if I come up and I get rid of all of those, oh, look at that.

608
00:44:15,540 --> 00:44:17,620
That's my production app.

609
00:44:17,620 --> 00:44:18,780
They're all passing.

610
00:44:18,780 --> 00:44:22,020
Who's ah, who's ah?

611
00:44:22,020 --> 00:44:25,340
So what does this mean?

612
00:44:25,340 --> 00:44:26,340
Dave?

613
00:44:27,340 --> 00:44:31,460
Oh, it means I have five minutes left.

614
00:44:31,460 --> 00:44:33,660
Awesome.

615
00:44:33,660 --> 00:44:37,580
Of course I wouldn't expect Dave to know what all of this means.

616
00:44:37,580 --> 00:44:38,940
So what does this mean?

617
00:44:38,940 --> 00:44:46,380
Well this means that I have the ability to, I have a zero, I have a successor of zero,

618
00:44:46,380 --> 00:44:52,220
and I have a successor of a successor of zero that I know is different.

619
00:44:52,220 --> 00:45:03,420
So what I've got is I've got zero, I've got one, and I have two, and I know and I've proven

620
00:45:03,420 --> 00:45:10,820
that one does not equal two, and that my one is not sufficiently large.

621
00:45:10,820 --> 00:45:19,700
So with some arm waving around the induction axiom, what we have is we have an infinite

622
00:45:19,700 --> 00:45:23,380
number of natural numbers.

623
00:45:23,380 --> 00:45:31,100
To show that and to do something really fun with, since we have a couple minutes, let's

624
00:45:31,100 --> 00:45:36,700
build two natural.

625
00:45:36,700 --> 00:45:42,980
What this does is this takes a number in Ruby and gives me the associated successor, successor,

626
00:45:42,980 --> 00:45:48,900
successor, successor like that, and then we're going to take from natural, which does a little

627
00:45:48,900 --> 00:45:49,900
bit different.

628
00:45:49,900 --> 00:45:54,860
It takes one of my natural numbers and returns it as a Ruby numeral.

629
00:45:54,860 --> 00:46:08,740
And so what I can do with this is say puts from natural to natural ten, and it prints

630
00:46:08,740 --> 00:46:09,740
ten.

631
00:46:09,740 --> 00:46:21,060
Yes, yes, nailed it.

632
00:46:21,060 --> 00:46:27,220
What this does do though is I have three minutes, so we can use these numbers now to do some

633
00:46:27,220 --> 00:46:29,940
pretty cool stuff such as this.

634
00:46:29,940 --> 00:46:42,500
What if I wrote a function called times that took a do this this many times and said if

635
00:46:42,500 --> 00:46:52,740
this many times is zero, then just do the identity, which is nothing, of course.

636
00:46:52,740 --> 00:47:11,140
Otherwise, I want to do this passing in this many times and then call back to times except

637
00:47:11,140 --> 00:47:12,660
take the predecessor.

638
00:47:12,660 --> 00:47:17,180
So this is counting down.

639
00:47:17,180 --> 00:47:30,540
And if I wrote it correctly, I can say puts hello the index and say do this to natural

640
00:47:30,540 --> 00:47:34,060
number ten times.

641
00:47:34,060 --> 00:47:45,460
Am I missing a bracket?

642
00:47:45,460 --> 00:47:51,620
This is when I'm actually live coding.

643
00:47:51,620 --> 00:48:00,700
Because in is actually there, so from natural, look at that.

644
00:48:00,700 --> 00:48:01,700
Look at that.

645
00:48:01,700 --> 00:48:02,700
Nailed it.

646
00:48:02,700 --> 00:48:03,700
Awesome.

647
00:48:03,700 --> 00:48:04,700
All right.

648
00:48:04,700 --> 00:48:05,700
So that's my time.

649
00:48:05,700 --> 00:48:06,700
Hope it was fun.

650
00:48:06,700 --> 00:48:07,700
This was fun coding.

651
00:48:07,700 --> 00:48:18,740
One of the cool things about this exercise for home is to write add.

652
00:48:18,740 --> 00:48:24,260
And when you write add in this way, like you get up to like adding 100 and 100 and you

653
00:48:24,260 --> 00:48:27,580
can like visibly see your processor slow down.

654
00:48:27,580 --> 00:48:28,740
It's super fun.

655
00:48:28,740 --> 00:48:29,740
All right.

656
00:48:29,740 --> 00:48:30,740
Thank you very much.

657
00:48:30,740 --> 00:48:35,740
Oh, before you go.

658
00:48:35,740 --> 00:48:36,740
There's pistachio.

659
00:48:36,740 --> 00:48:40,620
Oh, I love her.

660
00:48:40,620 --> 00:48:41,620
Okay.

661
00:48:41,620 --> 00:48:44,140
And also you can buy my book.

662
00:48:44,140 --> 00:48:45,140
Thank you very much.

663
00:48:45,140 --> 00:48:46,380
Have a good afternoon.

