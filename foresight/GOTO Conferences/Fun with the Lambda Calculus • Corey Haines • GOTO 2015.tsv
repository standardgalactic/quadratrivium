start	end	text
0	8120	Okay, we've got lots to go through, so let's get through it.
8120	14120	So most people have heard about, like, the Lambda Calculus.
14120	16560	How many people have heard of Lambda Calculus?
16560	20800	How many people have ever actually done anything in it, one person?
20800	21800	Awesome.
21800	22800	A couple people.
22800	23800	Yeah, Tom's done a little bit of it.
23800	27880	So I'm not really gonna go into, like, the details of Lambda Calculus and all of that.
27880	33640	It leads to church numerals, and I find those a bit pretentious.
33640	36840	You know, fancy list manipulation, stuff like that.
36840	38920	But the code's really cool.
38920	43760	When all you have is a Lambda, when all you have is a function, and you don't have anything
43760	45480	else.
45480	50640	So we've all, most people have kind of heard of it, but few people have really, like, actually
50640	55080	gone in and done anything with it, or actually seen why.
55080	59520	And a lot of times, if you do see people give talks on it, it's things like, here's
59520	63960	how you build lists, and they just kind of put out the code.
63960	70480	So what I thought it would be fun is to do some coding with a couple constraints, the
70480	75520	main constraint being that all we have is a Lambda.
75520	79280	And in fact, it only has one single input and single output.
79280	84280	So a lot of the times coding, you can learn a lot if you put these really crazy constraints
84280	85920	on what you're doing.
85920	90800	So I thought, what fun did a coding conference then to stand up here and actually live code
90800	93440	stuff with you?
93440	97280	The other thing is we're going to do today in these 50 minutes, we're going to build
97280	101720	up what are called the natural numbers.
101720	102880	Anybody heard about numbers?
102880	104800	They're pretty useful.
104800	109000	We're going to do them with something called Piano's Axioms.
109000	111040	Anybody heard of Piano's Axioms?
111040	112040	Awesome.
112040	120520	So Piano was a 19th century mathematician, Italian Giuseppe Piano, made these axioms
120520	128080	as a sort of a statement about the natural numbers, zero, one, two, all of those.
128080	132200	We're not going to go into a lot of the sort of mathematical formalism about it, but we're
132200	137720	going to kind of go through starting with just a Lambda, and I'll show you what that
137720	142240	looks like, and we're going to end up with the natural numbers.
142240	145000	Fun coding exercise, everybody's happy.
145000	148440	So what I want to do is I want to look through the Piano's Axioms, and I'm sure all of you
148440	153040	have them in your clip ordering like I do.
153040	156320	So the Piano Axioms, there's eight of them.
156320	160560	The first one is a pretty obvious one, that zero is a natural number.
160560	162880	It's sort of like the starting point.
162880	165320	The next four are Equality Axioms.
165320	167000	They talk about quality.
167000	170080	This will take you back to grade school.
170080	173520	For every number x, x equals x, that's reflexive.
173520	179560	For everything x and y, if x equals y, then y equals z, that's symmetric.
179560	186280	For all numbers x, y and z, if x equals y and y equals z, then x equals z, that's transitive.
186280	188000	For all a and b, this is an important one.
188000	192600	If b is a natural number, and a equals b, then a is also a natural number.
192600	196480	This seems like kind of a weird one, that we have to have an axiom about being closed
196480	200720	under equality, but this is essential because it means that if you have two things that
200720	206080	you're saying are equal, one of them isn't like a cow, or some other thing.
206080	207080	It's a natural number.
207080	210280	You can, you know, if two things are equal, they're both natural numbers.
210280	214160	The next three are about what is called a successor function, which we're going to build.
214160	215800	It's going to be awesome.
215800	218760	For every number n, s of n is a number.
218760	223560	So we're closed under succession, I guess, or successor.
223560	229000	For all numbers m and n, this is important, m equals n if and only if the successor of
229000	232240	m equals the successor of n.
232240	236760	This is effectively zero equals zero, one equals one, two equals two, but we're going
236760	239600	to use this to great advantage.
239600	247440	Number eight says that for every number n, oh, bye, the, if you find the successor of
247440	250000	n equal to zero, that's false.
250000	255040	So zero is kind of our starting point, and we'll actually use this one surprisingly.
255040	258720	There's a ninth axiom, which is about induction, which is the way of saying that, oh, it's
258720	263400	true for zero and one, and it's true for everything, so it's true for everything.
263400	266840	I'm going to skip that and just wave my arms a lot.
266840	268800	So, okay.
268800	271680	Brief aside about how, I'm going to use Ruby.
271680	277480	Most people would think that, like, Haskell would be a great thing for this, and it would.
277480	281640	So we're going to use Ruby because, well, Ruby.
281640	286880	So a lambda and Ruby gets written like this.
286880	289560	Get an identifier.
289560	292400	You don't need to know, if you don't know Ruby, that's okay, because most of the time
292400	296760	when I'm done with this, nobody has actually recognized that I've written Ruby.
296760	302880	We get an identifier, in this case the identity function, little stabby pointy thing, and
302880	305360	then an x, which is your parameter.
306360	311040	Ruby lambdas can take multiple parameters, but we're only letting it have one.
311040	314400	And what's inside of it is your return value.
314400	317560	In this case, this is the identity function.
317560	325800	You can actually call Ruby parameter or Ruby lambdas in two different ways.
325800	334360	You can use this wonderful dot parenthesis syntax, it looks like a method call, or you
334360	339080	can use this bracket, which looks like accessing an array and doesn't seem like it should actually
339080	341640	execute the lambda.
341640	350720	But if you run this, and yeah, that actually is my normal prompt, it does run.
350720	356480	So we're, of course, going to use the crazy bracket one, because why not?
356480	360440	The other one has actually one more character, and I don't like to type that much.
360440	362480	So let's get started.
362480	364080	Everybody's cool.
364080	367920	We need a good starting place, and a good starting place.
367920	374680	As I learned last time I watched, I believe it's the sound of music, is that it's at the
374680	375680	beginning.
375680	380400	So zero is a natural number, that's a great place to start.
380400	382440	So let's start with that.
382440	386760	So I'm going to actually write something that is zero, zero.
386760	389600	That seems like a pretty straightforward thing to write.
389600	391840	But the problem is, of course, I don't know anything about this.
391840	393720	I don't know anything about the zero function.
393720	396920	I don't know anything about that zero statement there.
396920	399800	We don't have any information at all.
399800	402520	And also axioms are about statements of fact.
402520	405560	They're not about, like, just having a piece of code.
405560	412440	So really the axiom is more something like this, that I can assert that there's a zero,
412440	413720	that there is something.
413720	415600	So now I've got this other function assert, of course.
415600	417760	I don't know anything about that either.
417760	420000	And I'm just making stuff up as I go along.
420000	424520	So let's take a step back and talk about assert.
424520	431720	So the behavior we want from assert is, assert is something that I want to use to figure
431720	438040	out if a statement is valid, whoops, that wasn't, oh, if a statement is valid.
438040	440480	Now what does that mean?
440480	446240	I don't know yet, but I know that if it's valid, I want it to print out something like
446240	450520	a t, and if it's invalid, I want it to print out something like an f.
450520	454080	So it needs to tell the difference between these two things, and I'm going to make up
454080	459960	two other functions and two other statements called true and false.
459960	469160	So my assert function, if I pass it true, I would expect it to output a t.
469160	472040	And if it's false, I'm going to have it output an f.
472040	478180	This is just a statement I can make up anything I want, because I got nothing to work with.
478180	481880	So we've got these two new functions now, true and false.
481880	483760	Remember everything's a function in this.
483760	486560	So now I've got a little bit more information.
486560	488320	I can talk about assert.
488320	491240	Now so what are true and false?
491240	493320	So I've got these two statements.
493320	496960	So I'm going to do a little bit of circular logic here, because that's always a great
496960	499120	way to make decisions.
499120	506760	So true is the thing that if I pass it to assert, I see a t.
506760	511480	And false is the thing that if I pass it to assert, I see an f.
511480	512480	That's great.
512480	514880	I can make up things as I want.
514880	520320	Assert, if I'm going to say the definition of assert, the behavior I expect is that if
520320	525120	I pass it a true, I see a t.
525120	528920	And if I pass it a false, I see an f.
528920	533960	It does seem kind of circular, but the only way to really talk about things and to figure
533960	540080	things out is how they behave together, because if you abide by certain philosophies, nothing
540080	544640	actually exists in reality, except as they interact with other things.
544640	548840	That's kind of how I live, so we're going to do that.
548840	551120	So what can I know about assert now?
551120	556920	What I do know is that assert accepts something, and it accepts something called a boolean.
556920	558440	I'm just going to make this term up.
558440	560440	I don't know if you've ever heard of this.
560440	565760	I'm going to make it up to mean true or false, but we don't know what assert actually has
565760	570560	to do, so we figured out a little bit about it that it needs a boolean.
570560	575040	If you look at assert and you look at the definition and this sort of circular logic,
575040	577400	is that it's got to do three things.
577400	581760	It has to figure out if I pass in a true or a false.
581760	588840	It's got to figure out what to do, so print a t or print an f, and it also has to execute
588840	590680	that function.
590680	597080	So it's got to figure out what are the cases, choose which case, and then execute that case.
597080	603400	That's three things, and of course that's way too many things for a function to do.
603400	607880	One of the core principles of the lambda calculus and lambdas in general is this concept called
607880	613040	the single responsibility principle, mostly because you only have like one line in there
613040	615280	and so you can't do much.
615280	622960	So what we're going to do is take a look at assert, and what we do know is that it needs
622960	632880	to either puts a t or I want the function of puts an f.
632880	640160	So assert its job is to actually do one of these two things.
640160	644240	So we've already mentioned booleans that are true and false, these encapsulate the idea
644240	645960	of two different things.
645960	647840	We've got them right up there.
647840	653600	So it seems reasonable to handle, let them handle an actual choice mechanism.
653600	659080	So our booleans are the things that we're actually going to use to do the choosing, but we need
659080	660240	one more construct.
660240	661960	We have three things to do.
661960	664160	We've got a responsibility for assert.
664160	666520	We have a responsibility for our booleans.
666520	673360	We have a third thing, and I'm going to pull just a word out of the dictionary, and I'm
673360	677160	going to call that if.
677160	679040	I know it's kind of crazy.
679040	686000	So what ifs job is to do is to actually execute the final thing.
686000	691840	So it's sort of a coordinator between my assert method and the boolean itself.
691840	696360	I'm just making this up, and it's got two letters, so it's okay.
696360	700120	One of the things that I want to be able to say about it, so I want to give a little bit
700120	702640	of definition and a little examples of it.
702640	713120	So if I give it a true, and I give it something that says you gave me a true, and then I give
713120	724440	it something, you know, a second thing that puts you gave me a false, and I actually spell
724440	733600	that right, then I should see you gave me a true and you gave me a false.
733600	736040	This is what I would like to have happen.
736040	738720	I would like the if statement to actually execute this.
738720	743760	It coordinates between the boolean and these two options.
743760	748800	For the sticklers out there, I am kind of breaking the only lambdas rule here.
748800	752800	I'm using some ruby stuff to do puts, and there's a string there, but that's where
752800	758600	expediency have to bear with me a tiny bit here, otherwise we're going to end up spending
758600	763240	all day generating numbers and letters and strings and lists and all of that, and I don't
763240	766080	really feel like doing that today.
766080	769120	So let's look again at this.
769120	770760	Now what is if?
770760	774160	What can I tell about if since I've wrote these examples?
774160	784440	So what I can say is that if it's a function that when given true executes the first function
784440	790760	that I gave it, and if I give it false, it executes the second function.
790760	792280	That's sort of the definition.
792280	796000	That's what I want this construct to do.
796000	805000	No, because false executes the second function.
805000	809320	So I want this to say the first time you gave me a true, the second time you gave me a false.
809320	811040	So awesome.
811040	815080	So with this, I can start to define a little bit about if.
815080	817840	I can start to figure out a few things about it.
817840	819640	So what do we know?
819640	829000	We know that if takes a Boolean, right, that's that first thing, it returns a function that
829000	834480	takes something else because remember we only accept one parameter per function.
834480	843840	That's the second thing, the true case, and then it takes a false case, like that.
843840	846360	But I don't exactly know what goes here.
846360	853680	I know that I want the behavior to be if Boolean is true, execute true case, if false, false
853680	855520	case.
855520	859640	So I know that that's kind of what the functionality that I want.
859640	864480	So one thing, we're going to be implementing a couple sort of functions that technically
864480	870240	take more than one parameter, but because our constraint is only one parameter, we have
870240	875960	to do this sort of like crazy indented passing in other functions and things like that.
875960	881240	I like to write it like this to sort of highlight that it actually is a three parameter function,
881240	887280	but because I'm silly and put a constraint on myself, I can't do that.
887280	889240	So also helps with some indentation stuff.
889240	892520	So let's keep moving on.
892520	898080	So the if statement is responsible for the execution.
898080	905600	We decided that the Boolean was responsible for choosing, so we kind of, it would be nice
905600	908280	if we could do this.
908280	916080	Now what this says is, hey Boolean, why don't you choose between these two?
916080	918480	And then whatever comes back, I'm going to execute.
918480	923400	I have to pass in the identity because remember we have single parameter functions, so I can't
923400	924640	just call the function.
924640	926160	I have to give it something.
926160	930320	And identity is the closest thing we have to I don't care.
930320	931960	Like it's just, it's identity.
931960	932960	Who has an identity?
932960	935040	It doesn't really matter.
935040	937080	Everything exists.
937080	941200	So now we have a little bit about true and false.
941200	945880	Now we've determined a few of the behaviors or one core behavior that we need, which is
945880	953280	that true, it takes a first parameter and it takes a second parameter because that's
953280	955280	what Booleans do.
955280	956280	And what does it do?
956280	959360	It returns me the first one.
959360	963240	It returns me the true case.
963240	968160	False on the other hand, let me just grab that.
968160	973320	False returns me the second one.
973320	977600	So now this if statement works.
977600	982080	I pass the true case and the false case, if Boolean happens to be true, it will return
982080	983080	me the first one.
983080	984280	I execute it.
984280	985280	Great.
985280	986280	And let's see if it runs.
986280	991720	And sure enough, we have our little sample here working.
991720	994040	So now we have an if statement.
994040	998560	We've devised this crazy idea called Booleans.
998560	1001160	So we can move on to assert now.
1001160	1008560	So of course, our assert is pretty easy because we have everything that we needed.
1008560	1018880	So if my Boolean is true, then prints that, otherwise there.
1018880	1020040	So I just check it.
1020040	1025400	This is the kind of a standard way to write it.
1025400	1031000	Now I would expect my initial things that I wanted, assert true and assert false, to
1031000	1034320	print T and F. Then sure enough, they do.
1034320	1036320	So now I have an assert method.
1036320	1040800	And of course, everybody knows that you can't code if you don't have an assert method because
1040800	1043040	how do you know it works?
1043040	1048080	So now we have our testing framework, which is really all you need.
1048080	1050320	And we can come back.
1050320	1055480	So we've done a lot of work here just to get sort of a basic thing.
1055480	1059580	And there's this weird thing too here.
1059580	1065600	The reason you have to put this, wrap this in a lambda, and I can't just say if Boolean
1065600	1073080	puts T, is because Ruby is an eager evaluating language, which means that Ruby evaluates
1073080	1077800	every function argument before it calls the function.
1078520	1085080	If I didn't have this lambda like that, it would actually try to execute that puts T
1085080	1089200	and the puts F, and then it would go into the functions, and you'd end up with a nail
1089200	1098680	reference exception, which is sort of the general exception that always happens in Ruby.
1098680	1100480	So we've got our assert.
1100480	1107880	I'm going to jump just slightly ahead because if you have assert, it always is nice to have
1107880	1111960	refute, which just does the other side.
1111960	1113720	We're going to use this later.
1113720	1118640	Refute just says the Boolean should be false.
1118640	1122360	There's a whole nother talk I'm putting together where we actually build up Boolean logic and
1122360	1125960	hand and knot and all of that stuff, but not this time.
1125960	1127120	So now we've got assert.
1127120	1131520	We can get back to this thing, assert.
1131520	1134800	So now we're back to actually doing something interesting.
1134800	1141080	If we try to run this, of course, we get uninitialized constant is zero because I haven't defined
1141080	1146960	that, but by defining assert, I now have a little bit of information about is zero.
1146960	1154640	I know that is zero has to take a parameter, and it has to return a Boolean because I'm
1154680	1158560	asserting on it, and I've determined that assert takes a Boolean.
1158560	1164960	So I'm just going to return true because that's always the easiest thing to do.
1164960	1169440	We don't know anything about zero, either, the parameter that comes in.
1169440	1172720	We do know that it's a function because everything's a function.
1172720	1176280	So since I don't know anything about it, I'm just going to make something up and give it
1176280	1180560	my stand-in for, hmm?
1180560	1182000	Okay.
1182000	1183840	So now we're passing.
1183840	1188120	So we got our T, so we've actually got a zero now, and we have a way to determine whether
1188120	1189840	or not something is zero.
1189840	1192520	Pretty cool, right?
1192520	1194840	That's a lot of work, so here's our reward.
1194840	1198560	Yay, there's my cat sack.
1198560	1199760	Okay?
1199760	1205320	So now the piano axioms have a part about equality.
1205320	1206720	All we have right now is zero.
1206720	1209440	We've satisfied axiom one.
1209440	1212040	We're going to start talking about equality.
1212040	1215920	And two here states that for every number x, x equals x.
1215920	1216920	Pretty straightforward.
1216920	1218440	That's the symmetric property.
1218440	1227280	So we're going to come down here and say, I can assert, right, that numbers equal zero
1227280	1230160	and zero.
1230160	1233840	That's a pretty, that's what axiom two says.
1233840	1238680	Of course, I don't know what numbers equal is, so it'll help if I actually try to write
1238680	1239840	that.
1239840	1241360	So numbers equal.
1241360	1242360	But what is it?
1242360	1246240	I know it's a lambda that takes something.
1246240	1250480	Because I've got the axiom that tells me that it's comparing two things, I know that it
1250480	1252400	takes two parameters.
1252400	1257000	So I'm going to take the first and the second parameter.
1257000	1263540	Now, all we have in our numbering system is zero, and zero equals zero.
1263540	1266840	We don't have any other things, so what should this return?
1266840	1268560	I know it has to return a Boolean.
1268560	1272160	Well, the simplest thing for it to return is true.
1272160	1275800	Because as it stands, that's all I actually know.
1275800	1281000	And if I run, there it is, I'm still, I'm passing again, and life is good.
1281000	1284840	So life is really simple, this is a philosophical point.
1284840	1288360	Life is simple when all you have is zero.
1288360	1289860	Okay.
1289860	1292720	That's my statement of fact about the world.
1292720	1297440	So let's move onward to the building of sort of the natural numbers.
1297440	1302080	We've started at zero, we actually kind of need to move up, otherwise nothing is really
1302080	1303580	that interesting.
1303580	1306080	So let's take a look at these successor functions.
1306080	1310320	We kind of instinctively know that the successor function is sort of like plus one, or it's
1310320	1312200	the next number in there.
1312200	1317240	But we can't use our intuition on any of this, because of course we're using these axioms
1317240	1319200	to build up the natural number.
1319200	1325680	So if we come down and talk about, so for every number in, the successor of n is a number.
1326240	1327720	Seems pretty straightforward.
1327720	1332040	So what I can say is let's start building this function.
1332040	1340560	So if I come up and I say successor, well, it's a function that takes a number.
1340560	1346760	It has to return me a natural number, because the axiom says that the successor of n is
1346760	1347760	a natural number.
1347760	1352400	Well, I only have two natural numbers that I know about, zero and the successor of zero.
1352400	1357600	And it seems kind of strange for the successor of zero to return the successor of zero.
1357600	1363400	So since it doesn't tell me anything else, I'm just going to choose it to return zero.
1363400	1366000	Still only kind of have zero, but everything's happy now.
1366000	1375600	So since it's a natural number, we can use our number equality, because where is it?
1375600	1376600	This thing.
1376600	1381500	For all a and b, if b is a natural number and they're equal, they're natural numbers.
1381500	1390180	So I can actually write that the numbers equal the successor of zero and the successor of
1390180	1392220	zero.
1392220	1394260	How do I know that that's true?
1394260	1397260	There we go.
1397260	1407860	I know this is true, because I have the axiom that says if x equals y, zero equals zero,
1407860	1414020	and the successors, that's this one, zero equals zero if and only if the successors
1414020	1417180	of zero is equal to the successors of zero.
1417180	1422540	So I can make this statement, this bold, bold statement, and I can run my tests and sure
1422540	1424300	enough it's true.
1424300	1429460	As I've said a couple of times, life is super easy when all you have is zero.
1429460	1433420	So this point, number equals always returns true.
1433420	1439860	It doesn't give us that much wonderful information, but here's the thing we're going to do.
1439860	1447660	Our big breakthrough comes when we look at the amazing axiom number eight.
1447660	1455740	Axiom number eight says that for every number n, the successor of n is not zero.
1455740	1459620	So if we say that it's zero, then we're false.
1459620	1462560	So that gives us a little statement here.
1462560	1473960	So we can say that we can actually refute the idea that the successor of zero is zero.
1473960	1484400	And we can also refute if we try to do numbers equal of the successor of zero and zero.
1484400	1491000	So these two statements, according to that axiom, this should give me truth.
1491000	1497400	But my number system does not work.
1497400	1500040	So these are kind of the same.
1500040	1505920	But so let's take a step back to the beginning and look at is zero.
1505920	1511080	This needs to differentiate now between zero and the successor of zero or zero and not
1511080	1512240	zero.
1512240	1519600	So what we can want to do is, well, let's do something.
1520040	1522560	So let's make it so that zero, it's got to be a function.
1522560	1528600	Let's actually make it a function that returns true that says, yeah, I'm zero.
1528600	1534560	Successor, since it's zero, we can replace it with this, which is zero.
1534560	1538640	But we want to just mark it and say you're not zero.
1538640	1545360	So we're taking the code that zero was and just saying, nope, false.
1545360	1552320	Let's run it so you can see it.
1552320	1555280	So successor returns a function.
1555280	1560320	We need to affect is zero here because is zero is just doing that.
1560320	1566800	But now each number that we have is a function that returns whether it's zero or not.
1566800	1572560	So we can just call it and get that true or false back.
1572560	1579440	So at this point, is zero can ask are you zero or not?
1579440	1584160	And we can see that we got one more t, which was this refutation.
1584160	1587400	But our numbers equal still doesn't work.
1587400	1594880	So we're going to take a little bit of a step back in order to get this working and comment
1594880	1601440	these out and look again at numbers equals zero, zero.
1601440	1605280	This is going to help us build out this numbers equal method for a second.
1605280	1617840	So what we want to say is that if the numbers, if the first number is zero, then we can actually
1617840	1630800	check and see if the second number is zero, make sure that I have like that.
1631160	1632840	Otherwise we can just say you're not.
1632840	1633840	It doesn't matter.
1633840	1638440	So this says if the first number is zero, then just return whether or not the second
1638440	1639440	number is zero.
1639440	1642480	And if they're both zero, then you get a true.
1642480	1660880	Doing this, it helps if I actually make that second.
1660880	1665680	So this isn't the final solution, but it's something that satisfies what we have so far.
1665680	1668800	And it satisfies axiom eight.
1668800	1674960	So if I come down and get rid of these, which is the axiom eight, I can see that those are
1674960	1677120	satisfied now.
1677120	1684400	So we know that the successor of zero is not zero.
1684400	1690880	And so we can kind of take the leap to move on to non-zero numbers and actually start
1690880	1694480	talking about these a little bit more.
1694480	1706400	Let's expand this one just a little bit to show that not equaling is sort of, successor
1706400	1711160	of zero is not equal to zero, but also zero is not equal to the successor of zero, just
1711160	1712920	kind of flipping them around.
1712920	1720160	The idea that successor of zero is not equal to zero, and then the symmetric form says
1720160	1724400	that zero is not equal to the successor of zero.
1724400	1729760	One day, I'm actually, this whole successor, successor, successor, successor kind of thing
1729760	1732480	will deal with that.
1732480	1736320	So let's talk about non-zero numbers.
1736320	1744440	So if we kind of jump up here for a second, we know that zero equals zero, right?
1744440	1750600	And we know that m equals n if and only if the successor of m is equal to the successor
1750600	1753840	of n.
1753840	1765520	This implies that this implies this guy, that the successor of zero needs to be equal to
1765520	1767760	the successor of zero.
1767760	1769560	But there's an f.
1769560	1773320	Our implementation doesn't satisfy this.
1773320	1777080	And this makes sense because if you look at what we're doing, we're always returning
1777080	1778560	false.
1778560	1781680	So what should we do about this?
1781680	1784680	Well let's look at axiom number seven.
1784680	1790760	This says, oops, for all numbers m and n, m equals n if and only if the successor of
1790760	1795280	m equals the successor of n.
1795280	1798160	This means that this should be true.
1798160	1805280	Since we're only working with zero and non-zero right now, we can put here that if the first
1805280	1814880	number is not zero, then the second one can't be zero either.
1814880	1821880	So I can just return false if the second one is zero.
1821880	1824640	You need to open.
1824640	1831600	And then I'm just going to return true here.
1832400	1839520	Now we're back to everything passing off.
1839520	1840520	All the Ts.
1840520	1841720	Yay!
1841720	1843920	So this is actually getting pretty ugly.
1843920	1846840	Can anybody read this?
1846840	1847840	It's kind of hard.
1847840	1848840	Awesome.
1848840	1850960	I want to tell you I can.
1850960	1855160	But we're biting sort of my usual process of coding, which is make it work, then make
1855160	1859880	it pretty, hopefully remembering that second part of it.
1860240	1867960	We could return false here, but if we do that, then we get that failure.
1867960	1875120	So true enough we need to return true to do it.
1875120	1876440	So this works for two numbers.
1876440	1880200	We now have zero and we have the successor of zero, but we don't have anything more
1880200	1882200	than that.
1882200	1887800	What this kind of says is I would really, really love it if I could take the successor
1887800	1900800	of the successor of zero and compare it to the successor of zero.
1900800	1903440	Does anybody think this should work?
1903440	1904800	No!
1904800	1917080	This is effectively two equals one, especially if I put an extra thing there, but it passes.
1917080	1923000	Everybody of course has heard that two equals one for sufficiently large values of one.
1923000	1926960	But for us, we can't abide by that.
1926960	1927960	We don't have.
1927960	1929920	We have just a size of one.
1929920	1938480	So we're going to use the wonderful axiom here, axiom number eight, to figure this out.
1938480	1943120	However, let's talk about how this is going to help us.
1943120	1947920	So for every number in, the successor of n is equal to zero is false.
1947920	1950600	So there's no number whose successor is zero.
1950600	1953840	Now I'm going to do a little bit of math here.
1953840	1957840	So hold your horses, I'm about to do math.
1957840	1962880	I'm going to use a logic or a proof mechanism called proof by contradiction.
1962880	1963880	So we'll walk through it quickly.
1963880	1966280	It's my favorite way of proving things.
1966280	1971000	So let's assume this is true, like our number statement or our system says.
1971000	1976520	So let me do a little bit of setting a variable.
1976520	1982120	I'm going to say m is equal to the successor of zero, n is equal to zero.
1982120	1990520	So if I repeat this or substitute this back in, that says that the successor of m is equal
1990520	1995320	to the successor of n, yeah?
1995320	2000320	Now if I replace m and n with their definitions, right?
2000320	2005320	What am I doing?
2005320	2006320	Oh.
2006320	2014280	m, n, this says the successor of m and n.
2014280	2023120	We know that according to axiom eight or axiom seven, if m equals n, if and only if the
2023120	2029240	successor of m is equal to the successor of n, which says I should, if the successors
2029240	2031320	are equal, then the numbers are equal.
2031320	2038480	So that tells me I can say this, m, n, right?
2038480	2039480	Just by substituting.
2039480	2041760	Well, let me substitute these back in.
2041760	2048840	Oh, look at this.
2048840	2049840	What does that say?
2049840	2056220	It says that the successor of zero is equal to zero.
2056220	2060880	That violates axiom number eight.
2060880	2063600	So that means that I've reached a contradiction.
2063600	2068400	I've reached something false, which means that's wrong, that's wrong, that's wrong, that's
2068400	2071640	wrong, that's wrong, that's wrong.
2071640	2077920	So since assuming that this was true led me to a contradiction, I actually have the opposite
2077920	2079720	of what that assumption was.
2080600	2087560	So these axioms along with what I have so far has shown me that I need to put a refute
2087560	2089060	here.
2089060	2095440	But my code doesn't satisfy that because my code only knows about this.
2095440	2097840	Everybody follow that?
2097840	2101920	Okay, well, let's have a picture of a cat.
2101920	2104000	There's Squeaks.
2104000	2108520	Their full name is you can do it, Squeaks, the story of little Carrie Strug by Corey
2108520	2110520	Haynes.
2110520	2115440	Because I find Carrie Strug to be one of the most inspirational figures in the world.
2115440	2119080	So I wanted to name my cat after her.
2119080	2120800	So awesome.
2120800	2121800	Now here we are.
2121800	2123440	We've got a failing test.
2123440	2124440	Everything's good.
2124440	2125720	We've only got a few minutes left.
2125720	2131360	So we need to build four pages worth of stuff.
2131360	2133800	So let's come up here.
2133800	2140960	We're going to comment out this stuff for a second.
2140960	2143840	And we're going to come up.
2143840	2145400	So we have tests for successor.
2145400	2150640	We have this final test that if it passes, we know that we have 0, 1, 2.
2150640	2153280	We've got sort of the ability to get this.
2153280	2158160	The successor of 0 is not the successor of 0.
2158160	2163560	So what we really want to do, though, is be able to come down to this numbers equal and
2163560	2169600	figure out not just everything's equal that isn't 0, but we actually want to be able to
2169600	2174240	ask it, are these two numbers the same?
2174240	2180000	To do this, we really need to know what are the things that caused first and second.
2180000	2183120	First and second came about by calling successor on something.
2183120	2186400	We need to find out what that something is.
2186400	2190520	So what we're going to do is we're going to say we really would like a function called
2190640	2199400	predecessor that is sort of the inverse of successor.
2199400	2203480	It's the thing that caused my successor to be what it is.
2203480	2207720	So if I take the successor of 0 and I take the predecessor of that, I should get 0.
2207720	2212600	I'm going to write one that's kind of crazy just to capture it.
2212600	2224240	So the predecessor of the successor of the successor of 0 is successor of 0.
2224240	2229080	So these are kind of, they're smoke tests just to help me make sure that I've got predecessor
2229080	2230080	working.
2230080	2237640	Once we have predecessor working, then I can rely on number 7 that m equals n if and only
2237640	2239880	if the successors.
2239880	2244800	If I flip that, it's the successors are equal only if the numbers are equal, which says
2244800	2252520	I should be able to come down here to numbers equal and say numbers equal predecessor of
2252520	2256120	first, predecessor of second.
2256120	2261920	If I build predecessor, I can do this and my numbers equal will be working, but I haven't
2261920	2263960	yet, so I can't.
2263960	2266840	So that's our goal is to build predecessor.
2267400	2270520	Okay, so let's do that.
2270520	2275200	Let's come up and look at 0, the successor.
2275200	2280680	Okay, so these have gotten us pretty far, this 0 and successor where we're just returning
2280680	2285200	true and false, but we need to not just mark whether it's 0 or not, but we need to somehow
2285200	2288160	carry along when we call successor.
2288160	2292120	We need to carry along what the number is that we are the successor of.
2292120	2299800	So we kind of, if I kind of pseudocoded it, I'd like it to look something like this,
2299800	2304400	you know, a pair.
2304400	2310840	And because at that point, I can just say that the predecessor of a number m is just
2310840	2315000	the rightmost thing of m.
2315000	2317640	I just, I need a pair.
2317640	2321480	Well of course we don't have a pair, all we have is a lambda and a couple of these things
2321480	2325040	we did, so let's build pairs real quick.
2325040	2331160	So in order to write some, just some smoke tests, I'm going to actually make a pair that
2331160	2338480	is true and false, and then I'm going to make a pair that is false and true, and then I'm
2338480	2347360	going to assert that the left, or the first part of true false, I can assert that because
2347360	2354920	it should be true, and I can refute the second part of true false.
2354920	2367120	And I can assert, or actually I can refute the first part of false true.
2367120	2371240	So basically I'm making a pair of true false and false true, and then I'm writing a couple
2371240	2374800	of smoke tests to say that first and second work.
2374920	2378120	Okay, so what do we know about these functions?
2378120	2385400	Well, I know that pair has to take a first and a second, right?
2385400	2387680	I don't know what it does with them.
2387680	2393000	I know that first is going to take a pair, I don't know what it does with it yet, and
2393000	2400080	I know that second is going to take a pair, and it's going to do something similar to
2400080	2401680	first, but I'm not sure exactly.
2401680	2407240	But it feels a little bit like Booleans again, where Boolean the true picked the first one,
2407240	2410520	so it makes me feel a little okay.
2410520	2412840	So what do I know about pair?
2412840	2416900	So let's work with first and second, because these are sort of our outer behaviors.
2416900	2418760	What do I know about pair?
2418760	2425400	I know one thing, it's a function, which means I can call it with a parameter.
2425400	2435800	Wouldn't it be awesome if I could call it with a function that accepts the first and
2435800	2444800	the second arguments in the pair and returns, not true, but the first one?
2444800	2450880	So this is a technique I like to call programming by wishful thinking, which is I code it as
2450880	2455980	though I always say to myself, wouldn't it be cool if I could do that and actually get
2455980	2456980	the first item?
2456980	2457980	Yes.
2457980	2458980	Thank you.
2458980	2459980	Second.
2459980	2466720	Wouldn't it be cool if I could do that, it would be awesome.
2466720	2468440	So how do I do that?
2468440	2472800	Well, that tells me that pair needs to return a function.
2472800	2473800	What's that function called?
2473800	2477980	Well, I'm going to call it selects value.
2477980	2482940	So it's a function that takes a function, and then it calls that function passing in
2482940	2484820	first and second.
2484820	2487700	Thank you.
2487700	2495200	So when I call pair with true and false, it returns me a function that takes this selects
2495200	2496700	value function.
2496700	2502300	Oh, I didn't write pred yet.
2502300	2505340	So these are passing.
2505340	2506340	Look at that.
2506340	2507380	Four Ts.
2507380	2510700	So now I have pairs.
2510700	2514100	Pretty fancy.
2514100	2515580	So it passes the test.
2515580	2518060	I'm going to get rid of these because, of course, these are just smoke tests.
2518060	2523420	And if you saw Jay's talk, then you should delete all of your tests.
2523420	2527340	And we're going to come down, and we're actually going to use a little bit of this to write
2527340	2528340	some things.
2528340	2533540	So zero, what I want zero to be is a pair of true and something else.
2533540	2535220	It doesn't matter what it is.
2535220	2539860	And whenever I don't care, I use my identity.
2539860	2546100	Somewhere there's an identity theft joke in there, but it's not now.
2546100	2552860	So is zero simply needs to take the first item of that?
2552860	2557220	Well, what does successor do?
2557220	2562100	Successor builds me a pair of false and in.
2562100	2567540	That's like saying that the successor of n is equal to false n.
2567540	2572860	The successor of the successor of n is equal to false, false n.
2572860	2577860	So every successor knows that it is not zero.
2577860	2581380	Now what does predecessor do?
2581380	2587500	It takes the second part and returns it.
2587500	2599140	Because if successor makes a pair of false and in, predecessor simply takes that out.
2599140	2606900	That means that if I come down here and I run my tests, my little smoke tests for predecessor
2606900	2607900	are working.
2607900	2617180	So now predecessor is working, which means I can come back to here and do the big trick
2617180	2628620	which is take, if the first is not zero and the second's not zero, then let me take the
2628620	2635300	predecessor of the first and the predecessor of the second and see if they're equal.
2635300	2639700	Because if they are, one more, nope, don't need one more.
2639700	2648780	Going to seven, if first and second are only equal if their predecessors are equal.
2648780	2655540	So now if I come up and I get rid of all of those, oh, look at that.
2655540	2657620	That's my production app.
2657620	2658780	They're all passing.
2658780	2662020	Who's ah, who's ah?
2662020	2665340	So what does this mean?
2665340	2666340	Dave?
2667340	2671460	Oh, it means I have five minutes left.
2671460	2673660	Awesome.
2673660	2677580	Of course I wouldn't expect Dave to know what all of this means.
2677580	2678940	So what does this mean?
2678940	2686380	Well this means that I have the ability to, I have a zero, I have a successor of zero,
2686380	2692220	and I have a successor of a successor of zero that I know is different.
2692220	2703420	So what I've got is I've got zero, I've got one, and I have two, and I know and I've proven
2703420	2710820	that one does not equal two, and that my one is not sufficiently large.
2710820	2719700	So with some arm waving around the induction axiom, what we have is we have an infinite
2719700	2723380	number of natural numbers.
2723380	2731100	To show that and to do something really fun with, since we have a couple minutes, let's
2731100	2736700	build two natural.
2736700	2742980	What this does is this takes a number in Ruby and gives me the associated successor, successor,
2742980	2748900	successor, successor like that, and then we're going to take from natural, which does a little
2748900	2749900	bit different.
2749900	2754860	It takes one of my natural numbers and returns it as a Ruby numeral.
2754860	2768740	And so what I can do with this is say puts from natural to natural ten, and it prints
2768740	2769740	ten.
2769740	2781060	Yes, yes, nailed it.
2781060	2787220	What this does do though is I have three minutes, so we can use these numbers now to do some
2787220	2789940	pretty cool stuff such as this.
2789940	2802500	What if I wrote a function called times that took a do this this many times and said if
2802500	2812740	this many times is zero, then just do the identity, which is nothing, of course.
2812740	2831140	Otherwise, I want to do this passing in this many times and then call back to times except
2831140	2832660	take the predecessor.
2832660	2837180	So this is counting down.
2837180	2850540	And if I wrote it correctly, I can say puts hello the index and say do this to natural
2850540	2854060	number ten times.
2854060	2865460	Am I missing a bracket?
2865460	2871620	This is when I'm actually live coding.
2871620	2880700	Because in is actually there, so from natural, look at that.
2880700	2881700	Look at that.
2881700	2882700	Nailed it.
2882700	2883700	Awesome.
2883700	2884700	All right.
2884700	2885700	So that's my time.
2885700	2886700	Hope it was fun.
2886700	2887700	This was fun coding.
2887700	2898740	One of the cool things about this exercise for home is to write add.
2898740	2904260	And when you write add in this way, like you get up to like adding 100 and 100 and you
2904260	2907580	can like visibly see your processor slow down.
2907580	2908740	It's super fun.
2908740	2909740	All right.
2909740	2910740	Thank you very much.
2910740	2915740	Oh, before you go.
2915740	2916740	There's pistachio.
2916740	2920620	Oh, I love her.
2920620	2921620	Okay.
2921620	2924140	And also you can buy my book.
2924140	2925140	Thank you very much.
2925140	2926380	Have a good afternoon.
