WEBVTT

00:00.000 --> 00:08.120
Okay, we've got lots to go through, so let's get through it.

00:08.120 --> 00:14.120
So most people have heard about, like, the Lambda Calculus.

00:14.120 --> 00:16.560
How many people have heard of Lambda Calculus?

00:16.560 --> 00:20.800
How many people have ever actually done anything in it, one person?

00:20.800 --> 00:21.800
Awesome.

00:21.800 --> 00:22.800
A couple people.

00:22.800 --> 00:23.800
Yeah, Tom's done a little bit of it.

00:23.800 --> 00:27.880
So I'm not really gonna go into, like, the details of Lambda Calculus and all of that.

00:27.880 --> 00:33.640
It leads to church numerals, and I find those a bit pretentious.

00:33.640 --> 00:36.840
You know, fancy list manipulation, stuff like that.

00:36.840 --> 00:38.920
But the code's really cool.

00:38.920 --> 00:43.760
When all you have is a Lambda, when all you have is a function, and you don't have anything

00:43.760 --> 00:45.480
else.

00:45.480 --> 00:50.640
So we've all, most people have kind of heard of it, but few people have really, like, actually

00:50.640 --> 00:55.080
gone in and done anything with it, or actually seen why.

00:55.080 --> 00:59.520
And a lot of times, if you do see people give talks on it, it's things like, here's

00:59.520 --> 01:03.960
how you build lists, and they just kind of put out the code.

01:03.960 --> 01:10.480
So what I thought it would be fun is to do some coding with a couple constraints, the

01:10.480 --> 01:15.520
main constraint being that all we have is a Lambda.

01:15.520 --> 01:19.280
And in fact, it only has one single input and single output.

01:19.280 --> 01:24.280
So a lot of the times coding, you can learn a lot if you put these really crazy constraints

01:24.280 --> 01:25.920
on what you're doing.

01:25.920 --> 01:30.800
So I thought, what fun did a coding conference then to stand up here and actually live code

01:30.800 --> 01:33.440
stuff with you?

01:33.440 --> 01:37.280
The other thing is we're going to do today in these 50 minutes, we're going to build

01:37.280 --> 01:41.720
up what are called the natural numbers.

01:41.720 --> 01:42.880
Anybody heard about numbers?

01:42.880 --> 01:44.800
They're pretty useful.

01:44.800 --> 01:49.000
We're going to do them with something called Piano's Axioms.

01:49.000 --> 01:51.040
Anybody heard of Piano's Axioms?

01:51.040 --> 01:52.040
Awesome.

01:52.040 --> 02:00.520
So Piano was a 19th century mathematician, Italian Giuseppe Piano, made these axioms

02:00.520 --> 02:08.080
as a sort of a statement about the natural numbers, zero, one, two, all of those.

02:08.080 --> 02:12.200
We're not going to go into a lot of the sort of mathematical formalism about it, but we're

02:12.200 --> 02:17.720
going to kind of go through starting with just a Lambda, and I'll show you what that

02:17.720 --> 02:22.240
looks like, and we're going to end up with the natural numbers.

02:22.240 --> 02:25.000
Fun coding exercise, everybody's happy.

02:25.000 --> 02:28.440
So what I want to do is I want to look through the Piano's Axioms, and I'm sure all of you

02:28.440 --> 02:33.040
have them in your clip ordering like I do.

02:33.040 --> 02:36.320
So the Piano Axioms, there's eight of them.

02:36.320 --> 02:40.560
The first one is a pretty obvious one, that zero is a natural number.

02:40.560 --> 02:42.880
It's sort of like the starting point.

02:42.880 --> 02:45.320
The next four are Equality Axioms.

02:45.320 --> 02:47.000
They talk about quality.

02:47.000 --> 02:50.080
This will take you back to grade school.

02:50.080 --> 02:53.520
For every number x, x equals x, that's reflexive.

02:53.520 --> 02:59.560
For everything x and y, if x equals y, then y equals z, that's symmetric.

02:59.560 --> 03:06.280
For all numbers x, y and z, if x equals y and y equals z, then x equals z, that's transitive.

03:06.280 --> 03:08.000
For all a and b, this is an important one.

03:08.000 --> 03:12.600
If b is a natural number, and a equals b, then a is also a natural number.

03:12.600 --> 03:16.480
This seems like kind of a weird one, that we have to have an axiom about being closed

03:16.480 --> 03:20.720
under equality, but this is essential because it means that if you have two things that

03:20.720 --> 03:26.080
you're saying are equal, one of them isn't like a cow, or some other thing.

03:26.080 --> 03:27.080
It's a natural number.

03:27.080 --> 03:30.280
You can, you know, if two things are equal, they're both natural numbers.

03:30.280 --> 03:34.160
The next three are about what is called a successor function, which we're going to build.

03:34.160 --> 03:35.800
It's going to be awesome.

03:35.800 --> 03:38.760
For every number n, s of n is a number.

03:38.760 --> 03:43.560
So we're closed under succession, I guess, or successor.

03:43.560 --> 03:49.000
For all numbers m and n, this is important, m equals n if and only if the successor of

03:49.000 --> 03:52.240
m equals the successor of n.

03:52.240 --> 03:56.760
This is effectively zero equals zero, one equals one, two equals two, but we're going

03:56.760 --> 03:59.600
to use this to great advantage.

03:59.600 --> 04:07.440
Number eight says that for every number n, oh, bye, the, if you find the successor of

04:07.440 --> 04:10.000
n equal to zero, that's false.

04:10.000 --> 04:15.040
So zero is kind of our starting point, and we'll actually use this one surprisingly.

04:15.040 --> 04:18.720
There's a ninth axiom, which is about induction, which is the way of saying that, oh, it's

04:18.720 --> 04:23.400
true for zero and one, and it's true for everything, so it's true for everything.

04:23.400 --> 04:26.840
I'm going to skip that and just wave my arms a lot.

04:26.840 --> 04:28.800
So, okay.

04:28.800 --> 04:31.680
Brief aside about how, I'm going to use Ruby.

04:31.680 --> 04:37.480
Most people would think that, like, Haskell would be a great thing for this, and it would.

04:37.480 --> 04:41.640
So we're going to use Ruby because, well, Ruby.

04:41.640 --> 04:46.880
So a lambda and Ruby gets written like this.

04:46.880 --> 04:49.560
Get an identifier.

04:49.560 --> 04:52.400
You don't need to know, if you don't know Ruby, that's okay, because most of the time

04:52.400 --> 04:56.760
when I'm done with this, nobody has actually recognized that I've written Ruby.

04:56.760 --> 05:02.880
We get an identifier, in this case the identity function, little stabby pointy thing, and

05:02.880 --> 05:05.360
then an x, which is your parameter.

05:06.360 --> 05:11.040
Ruby lambdas can take multiple parameters, but we're only letting it have one.

05:11.040 --> 05:14.400
And what's inside of it is your return value.

05:14.400 --> 05:17.560
In this case, this is the identity function.

05:17.560 --> 05:25.800
You can actually call Ruby parameter or Ruby lambdas in two different ways.

05:25.800 --> 05:34.360
You can use this wonderful dot parenthesis syntax, it looks like a method call, or you

05:34.360 --> 05:39.080
can use this bracket, which looks like accessing an array and doesn't seem like it should actually

05:39.080 --> 05:41.640
execute the lambda.

05:41.640 --> 05:50.720
But if you run this, and yeah, that actually is my normal prompt, it does run.

05:50.720 --> 05:56.480
So we're, of course, going to use the crazy bracket one, because why not?

05:56.480 --> 06:00.440
The other one has actually one more character, and I don't like to type that much.

06:00.440 --> 06:02.480
So let's get started.

06:02.480 --> 06:04.080
Everybody's cool.

06:04.080 --> 06:07.920
We need a good starting place, and a good starting place.

06:07.920 --> 06:14.680
As I learned last time I watched, I believe it's the sound of music, is that it's at the

06:14.680 --> 06:15.680
beginning.

06:15.680 --> 06:20.400
So zero is a natural number, that's a great place to start.

06:20.400 --> 06:22.440
So let's start with that.

06:22.440 --> 06:26.760
So I'm going to actually write something that is zero, zero.

06:26.760 --> 06:29.600
That seems like a pretty straightforward thing to write.

06:29.600 --> 06:31.840
But the problem is, of course, I don't know anything about this.

06:31.840 --> 06:33.720
I don't know anything about the zero function.

06:33.720 --> 06:36.920
I don't know anything about that zero statement there.

06:36.920 --> 06:39.800
We don't have any information at all.

06:39.800 --> 06:42.520
And also axioms are about statements of fact.

06:42.520 --> 06:45.560
They're not about, like, just having a piece of code.

06:45.560 --> 06:52.440
So really the axiom is more something like this, that I can assert that there's a zero,

06:52.440 --> 06:53.720
that there is something.

06:53.720 --> 06:55.600
So now I've got this other function assert, of course.

06:55.600 --> 06:57.760
I don't know anything about that either.

06:57.760 --> 07:00.000
And I'm just making stuff up as I go along.

07:00.000 --> 07:04.520
So let's take a step back and talk about assert.

07:04.520 --> 07:11.720
So the behavior we want from assert is, assert is something that I want to use to figure

07:11.720 --> 07:18.040
out if a statement is valid, whoops, that wasn't, oh, if a statement is valid.

07:18.040 --> 07:20.480
Now what does that mean?

07:20.480 --> 07:26.240
I don't know yet, but I know that if it's valid, I want it to print out something like

07:26.240 --> 07:30.520
a t, and if it's invalid, I want it to print out something like an f.

07:30.520 --> 07:34.080
So it needs to tell the difference between these two things, and I'm going to make up

07:34.080 --> 07:39.960
two other functions and two other statements called true and false.

07:39.960 --> 07:49.160
So my assert function, if I pass it true, I would expect it to output a t.

07:49.160 --> 07:52.040
And if it's false, I'm going to have it output an f.

07:52.040 --> 07:58.180
This is just a statement I can make up anything I want, because I got nothing to work with.

07:58.180 --> 08:01.880
So we've got these two new functions now, true and false.

08:01.880 --> 08:03.760
Remember everything's a function in this.

08:03.760 --> 08:06.560
So now I've got a little bit more information.

08:06.560 --> 08:08.320
I can talk about assert.

08:08.320 --> 08:11.240
Now so what are true and false?

08:11.240 --> 08:13.320
So I've got these two statements.

08:13.320 --> 08:16.960
So I'm going to do a little bit of circular logic here, because that's always a great

08:16.960 --> 08:19.120
way to make decisions.

08:19.120 --> 08:26.760
So true is the thing that if I pass it to assert, I see a t.

08:26.760 --> 08:31.480
And false is the thing that if I pass it to assert, I see an f.

08:31.480 --> 08:32.480
That's great.

08:32.480 --> 08:34.880
I can make up things as I want.

08:34.880 --> 08:40.320
Assert, if I'm going to say the definition of assert, the behavior I expect is that if

08:40.320 --> 08:45.120
I pass it a true, I see a t.

08:45.120 --> 08:48.920
And if I pass it a false, I see an f.

08:48.920 --> 08:53.960
It does seem kind of circular, but the only way to really talk about things and to figure

08:53.960 --> 09:00.080
things out is how they behave together, because if you abide by certain philosophies, nothing

09:00.080 --> 09:04.640
actually exists in reality, except as they interact with other things.

09:04.640 --> 09:08.840
That's kind of how I live, so we're going to do that.

09:08.840 --> 09:11.120
So what can I know about assert now?

09:11.120 --> 09:16.920
What I do know is that assert accepts something, and it accepts something called a boolean.

09:16.920 --> 09:18.440
I'm just going to make this term up.

09:18.440 --> 09:20.440
I don't know if you've ever heard of this.

09:20.440 --> 09:25.760
I'm going to make it up to mean true or false, but we don't know what assert actually has

09:25.760 --> 09:30.560
to do, so we figured out a little bit about it that it needs a boolean.

09:30.560 --> 09:35.040
If you look at assert and you look at the definition and this sort of circular logic,

09:35.040 --> 09:37.400
is that it's got to do three things.

09:37.400 --> 09:41.760
It has to figure out if I pass in a true or a false.

09:41.760 --> 09:48.840
It's got to figure out what to do, so print a t or print an f, and it also has to execute

09:48.840 --> 09:50.680
that function.

09:50.680 --> 09:57.080
So it's got to figure out what are the cases, choose which case, and then execute that case.

09:57.080 --> 10:03.400
That's three things, and of course that's way too many things for a function to do.

10:03.400 --> 10:07.880
One of the core principles of the lambda calculus and lambdas in general is this concept called

10:07.880 --> 10:13.040
the single responsibility principle, mostly because you only have like one line in there

10:13.040 --> 10:15.280
and so you can't do much.

10:15.280 --> 10:22.960
So what we're going to do is take a look at assert, and what we do know is that it needs

10:22.960 --> 10:32.880
to either puts a t or I want the function of puts an f.

10:32.880 --> 10:40.160
So assert its job is to actually do one of these two things.

10:40.160 --> 10:44.240
So we've already mentioned booleans that are true and false, these encapsulate the idea

10:44.240 --> 10:45.960
of two different things.

10:45.960 --> 10:47.840
We've got them right up there.

10:47.840 --> 10:53.600
So it seems reasonable to handle, let them handle an actual choice mechanism.

10:53.600 --> 10:59.080
So our booleans are the things that we're actually going to use to do the choosing, but we need

10:59.080 --> 11:00.240
one more construct.

11:00.240 --> 11:01.960
We have three things to do.

11:01.960 --> 11:04.160
We've got a responsibility for assert.

11:04.160 --> 11:06.520
We have a responsibility for our booleans.

11:06.520 --> 11:13.360
We have a third thing, and I'm going to pull just a word out of the dictionary, and I'm

11:13.360 --> 11:17.160
going to call that if.

11:17.160 --> 11:19.040
I know it's kind of crazy.

11:19.040 --> 11:26.000
So what ifs job is to do is to actually execute the final thing.

11:26.000 --> 11:31.840
So it's sort of a coordinator between my assert method and the boolean itself.

11:31.840 --> 11:36.360
I'm just making this up, and it's got two letters, so it's okay.

11:36.360 --> 11:40.120
One of the things that I want to be able to say about it, so I want to give a little bit

11:40.120 --> 11:42.640
of definition and a little examples of it.

11:42.640 --> 11:53.120
So if I give it a true, and I give it something that says you gave me a true, and then I give

11:53.120 --> 12:04.440
it something, you know, a second thing that puts you gave me a false, and I actually spell

12:04.440 --> 12:13.600
that right, then I should see you gave me a true and you gave me a false.

12:13.600 --> 12:16.040
This is what I would like to have happen.

12:16.040 --> 12:18.720
I would like the if statement to actually execute this.

12:18.720 --> 12:23.760
It coordinates between the boolean and these two options.

12:23.760 --> 12:28.800
For the sticklers out there, I am kind of breaking the only lambdas rule here.

12:28.800 --> 12:32.800
I'm using some ruby stuff to do puts, and there's a string there, but that's where

12:32.800 --> 12:38.600
expediency have to bear with me a tiny bit here, otherwise we're going to end up spending

12:38.600 --> 12:43.240
all day generating numbers and letters and strings and lists and all of that, and I don't

12:43.240 --> 12:46.080
really feel like doing that today.

12:46.080 --> 12:49.120
So let's look again at this.

12:49.120 --> 12:50.760
Now what is if?

12:50.760 --> 12:54.160
What can I tell about if since I've wrote these examples?

12:54.160 --> 13:04.440
So what I can say is that if it's a function that when given true executes the first function

13:04.440 --> 13:10.760
that I gave it, and if I give it false, it executes the second function.

13:10.760 --> 13:12.280
That's sort of the definition.

13:12.280 --> 13:16.000
That's what I want this construct to do.

13:16.000 --> 13:25.000
No, because false executes the second function.

13:25.000 --> 13:29.320
So I want this to say the first time you gave me a true, the second time you gave me a false.

13:29.320 --> 13:31.040
So awesome.

13:31.040 --> 13:35.080
So with this, I can start to define a little bit about if.

13:35.080 --> 13:37.840
I can start to figure out a few things about it.

13:37.840 --> 13:39.640
So what do we know?

13:39.640 --> 13:49.000
We know that if takes a Boolean, right, that's that first thing, it returns a function that

13:49.000 --> 13:54.480
takes something else because remember we only accept one parameter per function.

13:54.480 --> 14:03.840
That's the second thing, the true case, and then it takes a false case, like that.

14:03.840 --> 14:06.360
But I don't exactly know what goes here.

14:06.360 --> 14:13.680
I know that I want the behavior to be if Boolean is true, execute true case, if false, false

14:13.680 --> 14:15.520
case.

14:15.520 --> 14:19.640
So I know that that's kind of what the functionality that I want.

14:19.640 --> 14:24.480
So one thing, we're going to be implementing a couple sort of functions that technically

14:24.480 --> 14:30.240
take more than one parameter, but because our constraint is only one parameter, we have

14:30.240 --> 14:35.960
to do this sort of like crazy indented passing in other functions and things like that.

14:35.960 --> 14:41.240
I like to write it like this to sort of highlight that it actually is a three parameter function,

14:41.240 --> 14:47.280
but because I'm silly and put a constraint on myself, I can't do that.

14:47.280 --> 14:49.240
So also helps with some indentation stuff.

14:49.240 --> 14:52.520
So let's keep moving on.

14:52.520 --> 14:58.080
So the if statement is responsible for the execution.

14:58.080 --> 15:05.600
We decided that the Boolean was responsible for choosing, so we kind of, it would be nice

15:05.600 --> 15:08.280
if we could do this.

15:08.280 --> 15:16.080
Now what this says is, hey Boolean, why don't you choose between these two?

15:16.080 --> 15:18.480
And then whatever comes back, I'm going to execute.

15:18.480 --> 15:23.400
I have to pass in the identity because remember we have single parameter functions, so I can't

15:23.400 --> 15:24.640
just call the function.

15:24.640 --> 15:26.160
I have to give it something.

15:26.160 --> 15:30.320
And identity is the closest thing we have to I don't care.

15:30.320 --> 15:31.960
Like it's just, it's identity.

15:31.960 --> 15:32.960
Who has an identity?

15:32.960 --> 15:35.040
It doesn't really matter.

15:35.040 --> 15:37.080
Everything exists.

15:37.080 --> 15:41.200
So now we have a little bit about true and false.

15:41.200 --> 15:45.880
Now we've determined a few of the behaviors or one core behavior that we need, which is

15:45.880 --> 15:53.280
that true, it takes a first parameter and it takes a second parameter because that's

15:53.280 --> 15:55.280
what Booleans do.

15:55.280 --> 15:56.280
And what does it do?

15:56.280 --> 15:59.360
It returns me the first one.

15:59.360 --> 16:03.240
It returns me the true case.

16:03.240 --> 16:08.160
False on the other hand, let me just grab that.

16:08.160 --> 16:13.320
False returns me the second one.

16:13.320 --> 16:17.600
So now this if statement works.

16:17.600 --> 16:22.080
I pass the true case and the false case, if Boolean happens to be true, it will return

16:22.080 --> 16:23.080
me the first one.

16:23.080 --> 16:24.280
I execute it.

16:24.280 --> 16:25.280
Great.

16:25.280 --> 16:26.280
And let's see if it runs.

16:26.280 --> 16:31.720
And sure enough, we have our little sample here working.

16:31.720 --> 16:34.040
So now we have an if statement.

16:34.040 --> 16:38.560
We've devised this crazy idea called Booleans.

16:38.560 --> 16:41.160
So we can move on to assert now.

16:41.160 --> 16:48.560
So of course, our assert is pretty easy because we have everything that we needed.

16:48.560 --> 16:58.880
So if my Boolean is true, then prints that, otherwise there.

16:58.880 --> 17:00.040
So I just check it.

17:00.040 --> 17:05.400
This is the kind of a standard way to write it.

17:05.400 --> 17:11.000
Now I would expect my initial things that I wanted, assert true and assert false, to

17:11.000 --> 17:14.320
print T and F. Then sure enough, they do.

17:14.320 --> 17:16.320
So now I have an assert method.

17:16.320 --> 17:20.800
And of course, everybody knows that you can't code if you don't have an assert method because

17:20.800 --> 17:23.040
how do you know it works?

17:23.040 --> 17:28.080
So now we have our testing framework, which is really all you need.

17:28.080 --> 17:30.320
And we can come back.

17:30.320 --> 17:35.480
So we've done a lot of work here just to get sort of a basic thing.

17:35.480 --> 17:39.580
And there's this weird thing too here.

17:39.580 --> 17:45.600
The reason you have to put this, wrap this in a lambda, and I can't just say if Boolean

17:45.600 --> 17:53.080
puts T, is because Ruby is an eager evaluating language, which means that Ruby evaluates

17:53.080 --> 17:57.800
every function argument before it calls the function.

17:58.520 --> 18:05.080
If I didn't have this lambda like that, it would actually try to execute that puts T

18:05.080 --> 18:09.200
and the puts F, and then it would go into the functions, and you'd end up with a nail

18:09.200 --> 18:18.680
reference exception, which is sort of the general exception that always happens in Ruby.

18:18.680 --> 18:20.480
So we've got our assert.

18:20.480 --> 18:27.880
I'm going to jump just slightly ahead because if you have assert, it always is nice to have

18:27.880 --> 18:31.960
refute, which just does the other side.

18:31.960 --> 18:33.720
We're going to use this later.

18:33.720 --> 18:38.640
Refute just says the Boolean should be false.

18:38.640 --> 18:42.360
There's a whole nother talk I'm putting together where we actually build up Boolean logic and

18:42.360 --> 18:45.960
hand and knot and all of that stuff, but not this time.

18:45.960 --> 18:47.120
So now we've got assert.

18:47.120 --> 18:51.520
We can get back to this thing, assert.

18:51.520 --> 18:54.800
So now we're back to actually doing something interesting.

18:54.800 --> 19:01.080
If we try to run this, of course, we get uninitialized constant is zero because I haven't defined

19:01.080 --> 19:06.960
that, but by defining assert, I now have a little bit of information about is zero.

19:06.960 --> 19:14.640
I know that is zero has to take a parameter, and it has to return a Boolean because I'm

19:14.680 --> 19:18.560
asserting on it, and I've determined that assert takes a Boolean.

19:18.560 --> 19:24.960
So I'm just going to return true because that's always the easiest thing to do.

19:24.960 --> 19:29.440
We don't know anything about zero, either, the parameter that comes in.

19:29.440 --> 19:32.720
We do know that it's a function because everything's a function.

19:32.720 --> 19:36.280
So since I don't know anything about it, I'm just going to make something up and give it

19:36.280 --> 19:40.560
my stand-in for, hmm?

19:40.560 --> 19:42.000
Okay.

19:42.000 --> 19:43.840
So now we're passing.

19:43.840 --> 19:48.120
So we got our T, so we've actually got a zero now, and we have a way to determine whether

19:48.120 --> 19:49.840
or not something is zero.

19:49.840 --> 19:52.520
Pretty cool, right?

19:52.520 --> 19:54.840
That's a lot of work, so here's our reward.

19:54.840 --> 19:58.560
Yay, there's my cat sack.

19:58.560 --> 19:59.760
Okay?

19:59.760 --> 20:05.320
So now the piano axioms have a part about equality.

20:05.320 --> 20:06.720
All we have right now is zero.

20:06.720 --> 20:09.440
We've satisfied axiom one.

20:09.440 --> 20:12.040
We're going to start talking about equality.

20:12.040 --> 20:15.920
And two here states that for every number x, x equals x.

20:15.920 --> 20:16.920
Pretty straightforward.

20:16.920 --> 20:18.440
That's the symmetric property.

20:18.440 --> 20:27.280
So we're going to come down here and say, I can assert, right, that numbers equal zero

20:27.280 --> 20:30.160
and zero.

20:30.160 --> 20:33.840
That's a pretty, that's what axiom two says.

20:33.840 --> 20:38.680
Of course, I don't know what numbers equal is, so it'll help if I actually try to write

20:38.680 --> 20:39.840
that.

20:39.840 --> 20:41.360
So numbers equal.

20:41.360 --> 20:42.360
But what is it?

20:42.360 --> 20:46.240
I know it's a lambda that takes something.

20:46.240 --> 20:50.480
Because I've got the axiom that tells me that it's comparing two things, I know that it

20:50.480 --> 20:52.400
takes two parameters.

20:52.400 --> 20:57.000
So I'm going to take the first and the second parameter.

20:57.000 --> 21:03.540
Now, all we have in our numbering system is zero, and zero equals zero.

21:03.540 --> 21:06.840
We don't have any other things, so what should this return?

21:06.840 --> 21:08.560
I know it has to return a Boolean.

21:08.560 --> 21:12.160
Well, the simplest thing for it to return is true.

21:12.160 --> 21:15.800
Because as it stands, that's all I actually know.

21:15.800 --> 21:21.000
And if I run, there it is, I'm still, I'm passing again, and life is good.

21:21.000 --> 21:24.840
So life is really simple, this is a philosophical point.

21:24.840 --> 21:28.360
Life is simple when all you have is zero.

21:28.360 --> 21:29.860
Okay.

21:29.860 --> 21:32.720
That's my statement of fact about the world.

21:32.720 --> 21:37.440
So let's move onward to the building of sort of the natural numbers.

21:37.440 --> 21:42.080
We've started at zero, we actually kind of need to move up, otherwise nothing is really

21:42.080 --> 21:43.580
that interesting.

21:43.580 --> 21:46.080
So let's take a look at these successor functions.

21:46.080 --> 21:50.320
We kind of instinctively know that the successor function is sort of like plus one, or it's

21:50.320 --> 21:52.200
the next number in there.

21:52.200 --> 21:57.240
But we can't use our intuition on any of this, because of course we're using these axioms

21:57.240 --> 21:59.200
to build up the natural number.

21:59.200 --> 22:05.680
So if we come down and talk about, so for every number in, the successor of n is a number.

22:06.240 --> 22:07.720
Seems pretty straightforward.

22:07.720 --> 22:12.040
So what I can say is let's start building this function.

22:12.040 --> 22:20.560
So if I come up and I say successor, well, it's a function that takes a number.

22:20.560 --> 22:26.760
It has to return me a natural number, because the axiom says that the successor of n is

22:26.760 --> 22:27.760
a natural number.

22:27.760 --> 22:32.400
Well, I only have two natural numbers that I know about, zero and the successor of zero.

22:32.400 --> 22:37.600
And it seems kind of strange for the successor of zero to return the successor of zero.

22:37.600 --> 22:43.400
So since it doesn't tell me anything else, I'm just going to choose it to return zero.

22:43.400 --> 22:46.000
Still only kind of have zero, but everything's happy now.

22:46.000 --> 22:55.600
So since it's a natural number, we can use our number equality, because where is it?

22:55.600 --> 22:56.600
This thing.

22:56.600 --> 23:01.500
For all a and b, if b is a natural number and they're equal, they're natural numbers.

23:01.500 --> 23:10.180
So I can actually write that the numbers equal the successor of zero and the successor of

23:10.180 --> 23:12.220
zero.

23:12.220 --> 23:14.260
How do I know that that's true?

23:14.260 --> 23:17.260
There we go.

23:17.260 --> 23:27.860
I know this is true, because I have the axiom that says if x equals y, zero equals zero,

23:27.860 --> 23:34.020
and the successors, that's this one, zero equals zero if and only if the successors

23:34.020 --> 23:37.180
of zero is equal to the successors of zero.

23:37.180 --> 23:42.540
So I can make this statement, this bold, bold statement, and I can run my tests and sure

23:42.540 --> 23:44.300
enough it's true.

23:44.300 --> 23:49.460
As I've said a couple of times, life is super easy when all you have is zero.

23:49.460 --> 23:53.420
So this point, number equals always returns true.

23:53.420 --> 23:59.860
It doesn't give us that much wonderful information, but here's the thing we're going to do.

23:59.860 --> 24:07.660
Our big breakthrough comes when we look at the amazing axiom number eight.

24:07.660 --> 24:15.740
Axiom number eight says that for every number n, the successor of n is not zero.

24:15.740 --> 24:19.620
So if we say that it's zero, then we're false.

24:19.620 --> 24:22.560
So that gives us a little statement here.

24:22.560 --> 24:33.960
So we can say that we can actually refute the idea that the successor of zero is zero.

24:33.960 --> 24:44.400
And we can also refute if we try to do numbers equal of the successor of zero and zero.

24:44.400 --> 24:51.000
So these two statements, according to that axiom, this should give me truth.

24:51.000 --> 24:57.400
But my number system does not work.

24:57.400 --> 25:00.040
So these are kind of the same.

25:00.040 --> 25:05.920
But so let's take a step back to the beginning and look at is zero.

25:05.920 --> 25:11.080
This needs to differentiate now between zero and the successor of zero or zero and not

25:11.080 --> 25:12.240
zero.

25:12.240 --> 25:19.600
So what we can want to do is, well, let's do something.

25:20.040 --> 25:22.560
So let's make it so that zero, it's got to be a function.

25:22.560 --> 25:28.600
Let's actually make it a function that returns true that says, yeah, I'm zero.

25:28.600 --> 25:34.560
Successor, since it's zero, we can replace it with this, which is zero.

25:34.560 --> 25:38.640
But we want to just mark it and say you're not zero.

25:38.640 --> 25:45.360
So we're taking the code that zero was and just saying, nope, false.

25:45.360 --> 25:52.320
Let's run it so you can see it.

25:52.320 --> 25:55.280
So successor returns a function.

25:55.280 --> 26:00.320
We need to affect is zero here because is zero is just doing that.

26:00.320 --> 26:06.800
But now each number that we have is a function that returns whether it's zero or not.

26:06.800 --> 26:12.560
So we can just call it and get that true or false back.

26:12.560 --> 26:19.440
So at this point, is zero can ask are you zero or not?

26:19.440 --> 26:24.160
And we can see that we got one more t, which was this refutation.

26:24.160 --> 26:27.400
But our numbers equal still doesn't work.

26:27.400 --> 26:34.880
So we're going to take a little bit of a step back in order to get this working and comment

26:34.880 --> 26:41.440
these out and look again at numbers equals zero, zero.

26:41.440 --> 26:45.280
This is going to help us build out this numbers equal method for a second.

26:45.280 --> 26:57.840
So what we want to say is that if the numbers, if the first number is zero, then we can actually

26:57.840 --> 27:10.800
check and see if the second number is zero, make sure that I have like that.

27:11.160 --> 27:12.840
Otherwise we can just say you're not.

27:12.840 --> 27:13.840
It doesn't matter.

27:13.840 --> 27:18.440
So this says if the first number is zero, then just return whether or not the second

27:18.440 --> 27:19.440
number is zero.

27:19.440 --> 27:22.480
And if they're both zero, then you get a true.

27:22.480 --> 27:40.880
Doing this, it helps if I actually make that second.

27:40.880 --> 27:45.680
So this isn't the final solution, but it's something that satisfies what we have so far.

27:45.680 --> 27:48.800
And it satisfies axiom eight.

27:48.800 --> 27:54.960
So if I come down and get rid of these, which is the axiom eight, I can see that those are

27:54.960 --> 27:57.120
satisfied now.

27:57.120 --> 28:04.400
So we know that the successor of zero is not zero.

28:04.400 --> 28:10.880
And so we can kind of take the leap to move on to non-zero numbers and actually start

28:10.880 --> 28:14.480
talking about these a little bit more.

28:14.480 --> 28:26.400
Let's expand this one just a little bit to show that not equaling is sort of, successor

28:26.400 --> 28:31.160
of zero is not equal to zero, but also zero is not equal to the successor of zero, just

28:31.160 --> 28:32.920
kind of flipping them around.

28:32.920 --> 28:40.160
The idea that successor of zero is not equal to zero, and then the symmetric form says

28:40.160 --> 28:44.400
that zero is not equal to the successor of zero.

28:44.400 --> 28:49.760
One day, I'm actually, this whole successor, successor, successor, successor kind of thing

28:49.760 --> 28:52.480
will deal with that.

28:52.480 --> 28:56.320
So let's talk about non-zero numbers.

28:56.320 --> 29:04.440
So if we kind of jump up here for a second, we know that zero equals zero, right?

29:04.440 --> 29:10.600
And we know that m equals n if and only if the successor of m is equal to the successor

29:10.600 --> 29:13.840
of n.

29:13.840 --> 29:25.520
This implies that this implies this guy, that the successor of zero needs to be equal to

29:25.520 --> 29:27.760
the successor of zero.

29:27.760 --> 29:29.560
But there's an f.

29:29.560 --> 29:33.320
Our implementation doesn't satisfy this.

29:33.320 --> 29:37.080
And this makes sense because if you look at what we're doing, we're always returning

29:37.080 --> 29:38.560
false.

29:38.560 --> 29:41.680
So what should we do about this?

29:41.680 --> 29:44.680
Well let's look at axiom number seven.

29:44.680 --> 29:50.760
This says, oops, for all numbers m and n, m equals n if and only if the successor of

29:50.760 --> 29:55.280
m equals the successor of n.

29:55.280 --> 29:58.160
This means that this should be true.

29:58.160 --> 30:05.280
Since we're only working with zero and non-zero right now, we can put here that if the first

30:05.280 --> 30:14.880
number is not zero, then the second one can't be zero either.

30:14.880 --> 30:21.880
So I can just return false if the second one is zero.

30:21.880 --> 30:24.640
You need to open.

30:24.640 --> 30:31.600
And then I'm just going to return true here.

30:32.400 --> 30:39.520
Now we're back to everything passing off.

30:39.520 --> 30:40.520
All the Ts.

30:40.520 --> 30:41.720
Yay!

30:41.720 --> 30:43.920
So this is actually getting pretty ugly.

30:43.920 --> 30:46.840
Can anybody read this?

30:46.840 --> 30:47.840
It's kind of hard.

30:47.840 --> 30:48.840
Awesome.

30:48.840 --> 30:50.960
I want to tell you I can.

30:50.960 --> 30:55.160
But we're biting sort of my usual process of coding, which is make it work, then make

30:55.160 --> 30:59.880
it pretty, hopefully remembering that second part of it.

31:00.240 --> 31:07.960
We could return false here, but if we do that, then we get that failure.

31:07.960 --> 31:15.120
So true enough we need to return true to do it.

31:15.120 --> 31:16.440
So this works for two numbers.

31:16.440 --> 31:20.200
We now have zero and we have the successor of zero, but we don't have anything more

31:20.200 --> 31:22.200
than that.

31:22.200 --> 31:27.800
What this kind of says is I would really, really love it if I could take the successor

31:27.800 --> 31:40.800
of the successor of zero and compare it to the successor of zero.

31:40.800 --> 31:43.440
Does anybody think this should work?

31:43.440 --> 31:44.800
No!

31:44.800 --> 31:57.080
This is effectively two equals one, especially if I put an extra thing there, but it passes.

31:57.080 --> 32:03.000
Everybody of course has heard that two equals one for sufficiently large values of one.

32:03.000 --> 32:06.960
But for us, we can't abide by that.

32:06.960 --> 32:07.960
We don't have.

32:07.960 --> 32:09.920
We have just a size of one.

32:09.920 --> 32:18.480
So we're going to use the wonderful axiom here, axiom number eight, to figure this out.

32:18.480 --> 32:23.120
However, let's talk about how this is going to help us.

32:23.120 --> 32:27.920
So for every number in, the successor of n is equal to zero is false.

32:27.920 --> 32:30.600
So there's no number whose successor is zero.

32:30.600 --> 32:33.840
Now I'm going to do a little bit of math here.

32:33.840 --> 32:37.840
So hold your horses, I'm about to do math.

32:37.840 --> 32:42.880
I'm going to use a logic or a proof mechanism called proof by contradiction.

32:42.880 --> 32:43.880
So we'll walk through it quickly.

32:43.880 --> 32:46.280
It's my favorite way of proving things.

32:46.280 --> 32:51.000
So let's assume this is true, like our number statement or our system says.

32:51.000 --> 32:56.520
So let me do a little bit of setting a variable.

32:56.520 --> 33:02.120
I'm going to say m is equal to the successor of zero, n is equal to zero.

33:02.120 --> 33:10.520
So if I repeat this or substitute this back in, that says that the successor of m is equal

33:10.520 --> 33:15.320
to the successor of n, yeah?

33:15.320 --> 33:20.320
Now if I replace m and n with their definitions, right?

33:20.320 --> 33:25.320
What am I doing?

33:25.320 --> 33:26.320
Oh.

33:26.320 --> 33:34.280
m, n, this says the successor of m and n.

33:34.280 --> 33:43.120
We know that according to axiom eight or axiom seven, if m equals n, if and only if the

33:43.120 --> 33:49.240
successor of m is equal to the successor of n, which says I should, if the successors

33:49.240 --> 33:51.320
are equal, then the numbers are equal.

33:51.320 --> 33:58.480
So that tells me I can say this, m, n, right?

33:58.480 --> 33:59.480
Just by substituting.

33:59.480 --> 34:01.760
Well, let me substitute these back in.

34:01.760 --> 34:08.840
Oh, look at this.

34:08.840 --> 34:09.840
What does that say?

34:09.840 --> 34:16.220
It says that the successor of zero is equal to zero.

34:16.220 --> 34:20.880
That violates axiom number eight.

34:20.880 --> 34:23.600
So that means that I've reached a contradiction.

34:23.600 --> 34:28.400
I've reached something false, which means that's wrong, that's wrong, that's wrong, that's

34:28.400 --> 34:31.640
wrong, that's wrong, that's wrong.

34:31.640 --> 34:37.920
So since assuming that this was true led me to a contradiction, I actually have the opposite

34:37.920 --> 34:39.720
of what that assumption was.

34:40.600 --> 34:47.560
So these axioms along with what I have so far has shown me that I need to put a refute

34:47.560 --> 34:49.060
here.

34:49.060 --> 34:55.440
But my code doesn't satisfy that because my code only knows about this.

34:55.440 --> 34:57.840
Everybody follow that?

34:57.840 --> 35:01.920
Okay, well, let's have a picture of a cat.

35:01.920 --> 35:04.000
There's Squeaks.

35:04.000 --> 35:08.520
Their full name is you can do it, Squeaks, the story of little Carrie Strug by Corey

35:08.520 --> 35:10.520
Haynes.

35:10.520 --> 35:15.440
Because I find Carrie Strug to be one of the most inspirational figures in the world.

35:15.440 --> 35:19.080
So I wanted to name my cat after her.

35:19.080 --> 35:20.800
So awesome.

35:20.800 --> 35:21.800
Now here we are.

35:21.800 --> 35:23.440
We've got a failing test.

35:23.440 --> 35:24.440
Everything's good.

35:24.440 --> 35:25.720
We've only got a few minutes left.

35:25.720 --> 35:31.360
So we need to build four pages worth of stuff.

35:31.360 --> 35:33.800
So let's come up here.

35:33.800 --> 35:40.960
We're going to comment out this stuff for a second.

35:40.960 --> 35:43.840
And we're going to come up.

35:43.840 --> 35:45.400
So we have tests for successor.

35:45.400 --> 35:50.640
We have this final test that if it passes, we know that we have 0, 1, 2.

35:50.640 --> 35:53.280
We've got sort of the ability to get this.

35:53.280 --> 35:58.160
The successor of 0 is not the successor of 0.

35:58.160 --> 36:03.560
So what we really want to do, though, is be able to come down to this numbers equal and

36:03.560 --> 36:09.600
figure out not just everything's equal that isn't 0, but we actually want to be able to

36:09.600 --> 36:14.240
ask it, are these two numbers the same?

36:14.240 --> 36:20.000
To do this, we really need to know what are the things that caused first and second.

36:20.000 --> 36:23.120
First and second came about by calling successor on something.

36:23.120 --> 36:26.400
We need to find out what that something is.

36:26.400 --> 36:30.520
So what we're going to do is we're going to say we really would like a function called

36:30.640 --> 36:39.400
predecessor that is sort of the inverse of successor.

36:39.400 --> 36:43.480
It's the thing that caused my successor to be what it is.

36:43.480 --> 36:47.720
So if I take the successor of 0 and I take the predecessor of that, I should get 0.

36:47.720 --> 36:52.600
I'm going to write one that's kind of crazy just to capture it.

36:52.600 --> 37:04.240
So the predecessor of the successor of the successor of 0 is successor of 0.

37:04.240 --> 37:09.080
So these are kind of, they're smoke tests just to help me make sure that I've got predecessor

37:09.080 --> 37:10.080
working.

37:10.080 --> 37:17.640
Once we have predecessor working, then I can rely on number 7 that m equals n if and only

37:17.640 --> 37:19.880
if the successors.

37:19.880 --> 37:24.800
If I flip that, it's the successors are equal only if the numbers are equal, which says

37:24.800 --> 37:32.520
I should be able to come down here to numbers equal and say numbers equal predecessor of

37:32.520 --> 37:36.120
first, predecessor of second.

37:36.120 --> 37:41.920
If I build predecessor, I can do this and my numbers equal will be working, but I haven't

37:41.920 --> 37:43.960
yet, so I can't.

37:43.960 --> 37:46.840
So that's our goal is to build predecessor.

37:47.400 --> 37:50.520
Okay, so let's do that.

37:50.520 --> 37:55.200
Let's come up and look at 0, the successor.

37:55.200 --> 38:00.680
Okay, so these have gotten us pretty far, this 0 and successor where we're just returning

38:00.680 --> 38:05.200
true and false, but we need to not just mark whether it's 0 or not, but we need to somehow

38:05.200 --> 38:08.160
carry along when we call successor.

38:08.160 --> 38:12.120
We need to carry along what the number is that we are the successor of.

38:12.120 --> 38:19.800
So we kind of, if I kind of pseudocoded it, I'd like it to look something like this,

38:19.800 --> 38:24.400
you know, a pair.

38:24.400 --> 38:30.840
And because at that point, I can just say that the predecessor of a number m is just

38:30.840 --> 38:35.000
the rightmost thing of m.

38:35.000 --> 38:37.640
I just, I need a pair.

38:37.640 --> 38:41.480
Well of course we don't have a pair, all we have is a lambda and a couple of these things

38:41.480 --> 38:45.040
we did, so let's build pairs real quick.

38:45.040 --> 38:51.160
So in order to write some, just some smoke tests, I'm going to actually make a pair that

38:51.160 --> 38:58.480
is true and false, and then I'm going to make a pair that is false and true, and then I'm

38:58.480 --> 39:07.360
going to assert that the left, or the first part of true false, I can assert that because

39:07.360 --> 39:14.920
it should be true, and I can refute the second part of true false.

39:14.920 --> 39:27.120
And I can assert, or actually I can refute the first part of false true.

39:27.120 --> 39:31.240
So basically I'm making a pair of true false and false true, and then I'm writing a couple

39:31.240 --> 39:34.800
of smoke tests to say that first and second work.

39:34.920 --> 39:38.120
Okay, so what do we know about these functions?

39:38.120 --> 39:45.400
Well, I know that pair has to take a first and a second, right?

39:45.400 --> 39:47.680
I don't know what it does with them.

39:47.680 --> 39:53.000
I know that first is going to take a pair, I don't know what it does with it yet, and

39:53.000 --> 40:00.080
I know that second is going to take a pair, and it's going to do something similar to

40:00.080 --> 40:01.680
first, but I'm not sure exactly.

40:01.680 --> 40:07.240
But it feels a little bit like Booleans again, where Boolean the true picked the first one,

40:07.240 --> 40:10.520
so it makes me feel a little okay.

40:10.520 --> 40:12.840
So what do I know about pair?

40:12.840 --> 40:16.900
So let's work with first and second, because these are sort of our outer behaviors.

40:16.900 --> 40:18.760
What do I know about pair?

40:18.760 --> 40:25.400
I know one thing, it's a function, which means I can call it with a parameter.

40:25.400 --> 40:35.800
Wouldn't it be awesome if I could call it with a function that accepts the first and

40:35.800 --> 40:44.800
the second arguments in the pair and returns, not true, but the first one?

40:44.800 --> 40:50.880
So this is a technique I like to call programming by wishful thinking, which is I code it as

40:50.880 --> 40:55.980
though I always say to myself, wouldn't it be cool if I could do that and actually get

40:55.980 --> 40:56.980
the first item?

40:56.980 --> 40:57.980
Yes.

40:57.980 --> 40:58.980
Thank you.

40:58.980 --> 40:59.980
Second.

40:59.980 --> 41:06.720
Wouldn't it be cool if I could do that, it would be awesome.

41:06.720 --> 41:08.440
So how do I do that?

41:08.440 --> 41:12.800
Well, that tells me that pair needs to return a function.

41:12.800 --> 41:13.800
What's that function called?

41:13.800 --> 41:17.980
Well, I'm going to call it selects value.

41:17.980 --> 41:22.940
So it's a function that takes a function, and then it calls that function passing in

41:22.940 --> 41:24.820
first and second.

41:24.820 --> 41:27.700
Thank you.

41:27.700 --> 41:35.200
So when I call pair with true and false, it returns me a function that takes this selects

41:35.200 --> 41:36.700
value function.

41:36.700 --> 41:42.300
Oh, I didn't write pred yet.

41:42.300 --> 41:45.340
So these are passing.

41:45.340 --> 41:46.340
Look at that.

41:46.340 --> 41:47.380
Four Ts.

41:47.380 --> 41:50.700
So now I have pairs.

41:50.700 --> 41:54.100
Pretty fancy.

41:54.100 --> 41:55.580
So it passes the test.

41:55.580 --> 41:58.060
I'm going to get rid of these because, of course, these are just smoke tests.

41:58.060 --> 42:03.420
And if you saw Jay's talk, then you should delete all of your tests.

42:03.420 --> 42:07.340
And we're going to come down, and we're actually going to use a little bit of this to write

42:07.340 --> 42:08.340
some things.

42:08.340 --> 42:13.540
So zero, what I want zero to be is a pair of true and something else.

42:13.540 --> 42:15.220
It doesn't matter what it is.

42:15.220 --> 42:19.860
And whenever I don't care, I use my identity.

42:19.860 --> 42:26.100
Somewhere there's an identity theft joke in there, but it's not now.

42:26.100 --> 42:32.860
So is zero simply needs to take the first item of that?

42:32.860 --> 42:37.220
Well, what does successor do?

42:37.220 --> 42:42.100
Successor builds me a pair of false and in.

42:42.100 --> 42:47.540
That's like saying that the successor of n is equal to false n.

42:47.540 --> 42:52.860
The successor of the successor of n is equal to false, false n.

42:52.860 --> 42:57.860
So every successor knows that it is not zero.

42:57.860 --> 43:01.380
Now what does predecessor do?

43:01.380 --> 43:07.500
It takes the second part and returns it.

43:07.500 --> 43:19.140
Because if successor makes a pair of false and in, predecessor simply takes that out.

43:19.140 --> 43:26.900
That means that if I come down here and I run my tests, my little smoke tests for predecessor

43:26.900 --> 43:27.900
are working.

43:27.900 --> 43:37.180
So now predecessor is working, which means I can come back to here and do the big trick

43:37.180 --> 43:48.620
which is take, if the first is not zero and the second's not zero, then let me take the

43:48.620 --> 43:55.300
predecessor of the first and the predecessor of the second and see if they're equal.

43:55.300 --> 43:59.700
Because if they are, one more, nope, don't need one more.

43:59.700 --> 44:08.780
Going to seven, if first and second are only equal if their predecessors are equal.

44:08.780 --> 44:15.540
So now if I come up and I get rid of all of those, oh, look at that.

44:15.540 --> 44:17.620
That's my production app.

44:17.620 --> 44:18.780
They're all passing.

44:18.780 --> 44:22.020
Who's ah, who's ah?

44:22.020 --> 44:25.340
So what does this mean?

44:25.340 --> 44:26.340
Dave?

44:27.340 --> 44:31.460
Oh, it means I have five minutes left.

44:31.460 --> 44:33.660
Awesome.

44:33.660 --> 44:37.580
Of course I wouldn't expect Dave to know what all of this means.

44:37.580 --> 44:38.940
So what does this mean?

44:38.940 --> 44:46.380
Well this means that I have the ability to, I have a zero, I have a successor of zero,

44:46.380 --> 44:52.220
and I have a successor of a successor of zero that I know is different.

44:52.220 --> 45:03.420
So what I've got is I've got zero, I've got one, and I have two, and I know and I've proven

45:03.420 --> 45:10.820
that one does not equal two, and that my one is not sufficiently large.

45:10.820 --> 45:19.700
So with some arm waving around the induction axiom, what we have is we have an infinite

45:19.700 --> 45:23.380
number of natural numbers.

45:23.380 --> 45:31.100
To show that and to do something really fun with, since we have a couple minutes, let's

45:31.100 --> 45:36.700
build two natural.

45:36.700 --> 45:42.980
What this does is this takes a number in Ruby and gives me the associated successor, successor,

45:42.980 --> 45:48.900
successor, successor like that, and then we're going to take from natural, which does a little

45:48.900 --> 45:49.900
bit different.

45:49.900 --> 45:54.860
It takes one of my natural numbers and returns it as a Ruby numeral.

45:54.860 --> 46:08.740
And so what I can do with this is say puts from natural to natural ten, and it prints

46:08.740 --> 46:09.740
ten.

46:09.740 --> 46:21.060
Yes, yes, nailed it.

46:21.060 --> 46:27.220
What this does do though is I have three minutes, so we can use these numbers now to do some

46:27.220 --> 46:29.940
pretty cool stuff such as this.

46:29.940 --> 46:42.500
What if I wrote a function called times that took a do this this many times and said if

46:42.500 --> 46:52.740
this many times is zero, then just do the identity, which is nothing, of course.

46:52.740 --> 47:11.140
Otherwise, I want to do this passing in this many times and then call back to times except

47:11.140 --> 47:12.660
take the predecessor.

47:12.660 --> 47:17.180
So this is counting down.

47:17.180 --> 47:30.540
And if I wrote it correctly, I can say puts hello the index and say do this to natural

47:30.540 --> 47:34.060
number ten times.

47:34.060 --> 47:45.460
Am I missing a bracket?

47:45.460 --> 47:51.620
This is when I'm actually live coding.

47:51.620 --> 48:00.700
Because in is actually there, so from natural, look at that.

48:00.700 --> 48:01.700
Look at that.

48:01.700 --> 48:02.700
Nailed it.

48:02.700 --> 48:03.700
Awesome.

48:03.700 --> 48:04.700
All right.

48:04.700 --> 48:05.700
So that's my time.

48:05.700 --> 48:06.700
Hope it was fun.

48:06.700 --> 48:07.700
This was fun coding.

48:07.700 --> 48:18.740
One of the cool things about this exercise for home is to write add.

48:18.740 --> 48:24.260
And when you write add in this way, like you get up to like adding 100 and 100 and you

48:24.260 --> 48:27.580
can like visibly see your processor slow down.

48:27.580 --> 48:28.740
It's super fun.

48:28.740 --> 48:29.740
All right.

48:29.740 --> 48:30.740
Thank you very much.

48:30.740 --> 48:35.740
Oh, before you go.

48:35.740 --> 48:36.740
There's pistachio.

48:36.740 --> 48:40.620
Oh, I love her.

48:40.620 --> 48:41.620
Okay.

48:41.620 --> 48:44.140
And also you can buy my book.

48:44.140 --> 48:45.140
Thank you very much.

48:45.140 --> 48:46.380
Have a good afternoon.

