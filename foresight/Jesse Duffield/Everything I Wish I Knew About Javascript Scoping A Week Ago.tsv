start	end	text
0	7200	Hi guys, welcome to my video on scoping in JavaScript.
7200	14280	So about a week ago I kind of started a deep dive into how JavaScript really works behind
14280	21180	the scenes and part of that was learning about scoping.
21180	26400	I made a blog post called Everything I Wish I Knew About JavaScript Scoping a Week Here
26400	31240	which kind of goes into details about a lot of these things, but the first kind of chunk
31240	36920	of that is really just about like, you know, var versus let versus const which are keywords
36920	41800	for declaring variables which to be honest, I wasn't really that interested in in the
41800	47760	first place and given that most people just don't use var anymore, I don't know how relevant
47760	54960	it is, but I still think that scoping in general is pretty important to learn about
55400	60320	and I learned some interesting things about static scoping, dynamic scoping and how it
60320	63360	relates to this binding.
63360	68440	So yeah, my plan with this video is to take you through what I learned and I'm going to
68440	75680	try and take an experimental approach where I'm not going to make any claims without having
75680	80880	some way of like backing it up, which is why I've got this, the Chrome Dev Tools open right
80880	81880	now.
81880	87520	We're going to try and understand how JavaScript works by actually observing what it does as
87520	89800	a program runs.
89800	95720	So we're starting with this program here, which basically declares a couple of variables
95720	102600	a and b and then declares this outer function, it itself declares two variables c and d,
102600	108200	then it declares a inner function which itself declares two more variables and then on the
108200	111680	inside here we just console log all four.
111680	119280	So a couple of these get overwritten, a does not get overwritten but c does, so in here
119280	125760	it's called shadowing when you've got a function where another variable is in scope outside
125760	128320	that function but we're kind of overriding its value here.
128320	132240	I mean, we're not overriding the value of this variable, we just have another variable
132240	137080	of the same name and therefore we can't really access this variable.
137080	141640	So we've got this function here, then we just call that function and then we call the
141640	142640	outer function.
142640	148080	So the way the program works is we go here, declare this guy, call this guy, then we go
148080	151680	inside here and declare this guy and then we call it.
151680	158280	So the point here is that we've got kind of nested scoping and we want to see how these
158280	159520	values end up coming out.
159880	167440	So I play this now, console log shows a is one, b is five, c is six and d is four.
167440	173640	So a is one because it gets started here and doesn't get overwritten or shadowed rather.
173640	179720	b starts as two but then over here we've got b is five so we shadow this guy and we just
179720	185400	say okay we've got our own b variable here which is equal to five so we use that.
185400	191160	c is three but then over here it gets shadowed and we get a new c variable whose value is
191160	198800	six so we end up saying c is six and finally d starts as four and does not get shadowed
198800	200080	so it's just four here.
200080	205360	So off the bat we can see that when you have a function declared inside another function
205360	211320	it has access to variables defined outside of its scope whether it's d in the outer function
211320	214400	or a in this global context.
214840	220360	Okay so let's have a look at what's actually happening here but a diagram that I made.
220360	227200	Basically JavaScript runs on an execution stack which is equivalent to a call stack.
227200	233280	At the bottom we've got the global execution context and so each of these little stack
233280	240120	frames is called an execution context so there's a global one at the bottom which is this
240200	246440	thing here this scope here then we've got the outer execution context which would be
247720	251240	everything that happens in here would be happening inside that context and then we've got the inner
251240	257480	one which would be this stuff so what an execution context does is it basically distores
258120	262520	information you need to be able to know where you are at in a function you know what the variables
262520	267800	are that you might be reading from and it's the kind of thing where if you know if you
267800	272120	turn the computer off and turn it back on again and this stack was still here
272120	275080	and almost up to the point or two then you should be able to just continue the program
276120	283160	from where you left off. So we've got our execution context on the execution stack
283160	290200	and each of these points to a I'd say points to you probably more accurately has a reference to
291160	297880	uh lexical environments so uh lexical environments uh when you see the word lexical it basically
297880	303720	means like letters or things you can you can see um in this case we're talking about actual variables
303720	310280	being defined so a lexical environment uh just contains two things it contains an environment
310280	317080	record and a pointer to the parent lexical environment so um uh this happens to be called a
317160	321080	declarative environment record but what an environment record is is is effectively just a
321080	326760	mapping of variables to their values so in the case of our inner function we've got b is five and c
326760	331480	is six so that's these two guys in our outer function we've got c is three and d is four
332040	338840	which are these two guys and then in our global lexical environment we actually have this is kind
338840	345400	of a it's a kind of weird edge case but um we've got a composite environment record consisting of
345400	352840	two things the declarative environment record um for which b is two and we have this other thing
352840	358840	called the object environment record so this is where things kind of get a bit weird um the uh
358840	363960	back in the day basically everything used these object environment records and they would all
363960	369960	have a thing called a binding object which was a literal javascript object that just contained
369960	377160	your variables as properties um it is still the case today that at the global level if you define
377160	385960	a variable with the um the var keyword then it actually ends up just being a property on the
385960	390920	global object um on the other hand if you use let or const it's going to be sitting in this
390920	397000	declarative environment record uh now what's the difference uh first of all uh when you actually
397000	401960	have an object environment record the binding object in this case global just can be accessed by
401960	410200	outside code um and uh it's not very efficient so these declarative ones um are there kind of
410200	419000	internally stored and it's not accessible from the outside um okay so uh the the fact that these
419000	424200	will point to each other allow us to create a scope chain where we can say you know i'm in the inner
424200	429640	function i'm looking for the a variable right now because i want to log it and it's not in my
429640	435160	declarative environment record it's so therefore i'll look to my parent it's not in there either
435160	441240	with my parent oh here it is on the global object so you can get the value of one and then you can
442120	451960	log that value so um it's probably also worth uh noting that um these uh functions when they
452040	457640	created they actually get a eternal internal reference to the scopes that they have access to
457640	469240	so let me go down here and actually gotta refresh the page if i go debugger and then play that okay so
471080	476520	if i look at the inner function you can see here this is just in my dev tools inspector
477480	483400	but in scope i've got my inner function it's got arguments it's got a prototype but it has this
483400	489480	internal thing and these uh internal things are denoted by these double square brackets um this
489480	497400	guy's called scopes and uh in this case uh we've got a few things i've got the value of d from
497400	503240	that outer function the value of b from a script uh anything that's defined at the top level with
503320	508840	let or const is considered to be script scoped um which is not the same as saying is actually
508840	512760	i only scoped to the we're talking about actual script tags here if i go for example
515800	522360	this thing would be a script tag um it's not actually scoped to the script tag it's just
524680	528760	any script will have access to it um and then we've got the global thing here so
529720	535240	we expand this guy we'll see that actually among the many properties of global object one is a
535240	543080	whose value is one so that's this guy here so kind of weird um but also pretty cool so let's move on
543080	548680	and i'm going to go to the next example so in this case we've got an inner and an outer function
548680	555240	but our inner function is actually defined outside the outer function so when this guy's defined um
556200	566040	uh the it references x but the x is actually defined in the uh global execution context
567000	574600	and the um outer function basically when it gets called it goes and creates a its own local
574600	582040	x variable and then it calls inner so the question here is which x will this inner function uh log
582600	589800	um and it turns out that when you run this guy it's going to log one which means logs this thing
590360	597960	so this kind of touches on the difference between static and dynamic scoping in static scoping
597960	606520	when a function is created um any uh variables that references from an outer scope um it looks
606600	612840	at okay like lexically or statically is what's called static scoping or lexical scoping uh what
612840	617240	have i got access to so i can just look on the page here and see okay well there's an x this
617240	622360	in scope here so that's what that's referring to um what actually you know is defined against
622360	627960	a function that might be calling my inner function um it doesn't matter so uh that's called static
627960	632600	scoping um which is to say that we you know you can just statically look at the page and know
633240	639960	uh which variables here are being referenced now you might ask yourself uh isn't this what
639960	645400	every programming language does and actually no it's not so here we have a bash script and
645400	651560	i'm just going to paste this in here so uh in this script we do the exact same thing we define x
651560	655800	we've got an inner function that just logs it an outer function that defines its own x and calls
655800	659880	the inner function and then we call the outer function so we're going to go x is one call the
659880	663880	outer function go in here create x equals two call it inner function and then echo x
664600	669240	press this uh if you play this okay so this actually logs two so what this means is that
670360	677640	bash does not use static scoping it uses dynamic scoping um dynamic scoping is where you care about
677640	683800	what variables are defined at call time um meaning you know at the time this guy's called
683800	688760	we look at okay what's uh what's the value of x so like we're in here we go okay we need the
688760	694840	value of x instead of looking electrically statically up to whatever was defined at the
694840	699800	point when this guy was created in which case x would be one we instead say well who called us
699800	704440	okay well we're being called by outer is there an x defined in this scope yes there is okay let's
704440	712040	log that so um a diagram that explains this discrepancy would be this so let's assume that
712040	717800	bash itself had a concept of lexical environments which it doesn't but if it did um then this is
717800	721320	the difference between how the two would operate so in this case we've got out inner function
722360	730120	doesn't have an x defined so uh in JavaScript we go well you know somehow we know that um
731320	735560	the uh parent lexical environment it's actually the global environment because when this guy was
735560	743960	defined uh i'm just gonna go back when this guy was defined it was uh lexically in scope here
743960	749400	this you know we didn't care about the outer function at the point this was created um so we
749400	755800	go here and find x is one and we log that on the other hand bash just follows the actual stack frame
755800	760600	so it goes okay nothing's defined here okay what about the guy that called me oh it is defined
760600	767160	there okay well i'll return that so um different languages have different approaches to this so
767240	773880	for example in pearl you can have both dynamic or static scoping depending on how you uh declare
773880	779880	your variables um they've got different benefits for different use cases but generally it's
779880	785000	considered that static scoping is superior because it enables uh there are a few reasons
785000	793000	one of which is you can more easily reason about how a function will behave so for example in this
793000	797720	case i don't need to care about you know once i've defined this function i know that this guy's
797720	802120	in scope and so it's referencing that i don't need to worry about whether in some other file
802120	810840	some other function is calling me and um it defines x in its own weird way so to understand
810840	815400	how a single function will work all i need to do is look at the page or look at the files defined
815400	820200	and look at the scope it's defined in and i'll understand um with dynamic scoping you need to
820200	825560	think about all the permutations and understand you know who knows what variables could be set
825560	832920	when i'm being called by some random outer function um dynamic scoping does have uh one benefit
832920	839640	which is that you um don't need to worry about storing variables on the heap so you know assuming
839640	844120	we're talking about primitives like booleans and integers you can just keep everything on the stack
844120	850760	here and as soon as you're done with the function you just you know drop down the stack pointer
850760	855480	throughout the memory when you put a new when you enter a new function you put a new stack frame on
855480	861560	the stack move the pointer up again and uh basically you know whenever you need to look for a variable
861560	867240	you just look down the stack until you find it um in JavaScript we need to kind of have some
867240	872680	additional uh metadata that we hold on to for example to say that you know this inner function
872680	878280	was really defined with this guy in scope we don't you know at the time we didn't care about the
878280	883080	outer function so we need to skip this guy because we've been static scoping you know the fact we
883080	887320	have to store those kinds of references means we can't do it all on the stack it's not as simple as
887320	897160	just looking from top to bottom um but let's continue so there is another way in which static
897160	905960	scoping um helps us and that is in how closures work so uh a closure it kind of has two definitions
905960	914280	the first definition of closure is a function that is paired with um a uh it's paired with this
914280	919480	environment so it's a function the client has knowledge about where it was for example created
919480	923960	and what variables were in scope at that point um there's another definition of closure which is
923960	927720	just referring to the environment part like you know the closure is just the things that are
927720	933880	captured the variables are captured so the two are kind of used interchangeably um but uh that
933880	940600	effectively referring to the same concept um so uh in this case we have a function we we define x
940600	946920	and we have an outer function now um that defines an inner function internally um outer has its own
946920	951960	x whose value is two and uh what happens here is the outer actually returns inner so it returns
951960	957960	a function so in javascript functions are first class which means that you can um pass them in
957960	962280	as arguments to functions and you can also return them from functions so you can treat them like
962280	969720	any other variable um so what's happening here is we're actually uh capturing this uh x value
969720	974280	here and we're capturing this one because lecicle scoping says that we first look at you know what's
974280	979720	the now immediate scope here all the values x okay well we'll just capture that guy um we return
979720	986360	the inner function and then we assign that to this variable foo so we call it outer it returns
986360	990760	inner so now foo's value is inner then we call foo which is the same as calling our inner function
992040	994760	and the question is what does it log so if you run this
1000120	1005720	we log the value of two so um okay what's interesting about this is that
1006440	1013240	that this variable two which is defining that outer function um really has no reason to exist
1013960	1020760	after we uh leave the called outer if not for our inner function we're trying to
1020760	1027400	capture that variable so I say capture another word will be close over the reason it's called
1027400	1032920	capture is because we need to hold on to this thing after the lifetime of that outer function
1033880	1037480	so if we for example we're just storing everything on the stack here
1038040	1043880	we'd have our outer function we'd have our inner function we'd have uh x equals two happening here
1044520	1049880	and uh we'd eventually have to pop off the stack and get back to our global execution
1049880	1056120	context for me down here but once we want to then call our inner function again um we need to have
1056120	1062920	some way of saying of keeping track of the fact that it uh has this variable x equals two which
1062920	1072120	isn't actually defined in its scope so um let me grab this diagram so what's happening here is that
1072120	1077560	by the time we get to foo which is really just a variable pointing it out inner function um
1077560	1081960	it has nothing to find in the statistical environment and because we use stack scoping it
1081960	1086920	just so happens that this uh function contained a reference to the electrical environment
1087880	1093880	of the outer function uh where x equals two and so we can say okay x equals two uh obviously that
1093880	1098120	also close to the global environment record now if we were if we were using dynamic scoping
1099320	1104440	what would happen here uh effectively we have a foo function here we'd be calling it in the
1104440	1110840	global context meaning this guy is in scope and the this guy is not and we'd be going console log x
1110840	1115160	and we just look down the call stack so foo we don't have it global context we do have it the
1115160	1122840	value is one um so we'll return one so um effectively dynamic scoping does not support
1122840	1129480	closures uh unlike static scoping which will allow you to kind of store these guys in memory
1129480	1136440	somehow and then later on you can access those uh variables and change them or just read from them
1137400	1142520	um so i'm just gonna start this again just as we can see what's actually happening here so
1143720	1149160	our foo function is has some scopes and we've got a closure here so it closes up x
1150680	1155240	then the next one up we've got our script for which x equals one and then the global object so these
1155240	1159640	two guys are kind of two parts of the composite environment record that happen in the global
1159640	1166920	execution context um so it's kind of interesting and if i go in here it's effectively the same
1166920	1172520	thing we have this uh well in this scope here actually now forget about function so just in
1172520	1177080	this scope um we're trying to console log this thing but access to this closure which we're saying
1177080	1185400	x equals two that's pretty cool um now uh let's look a little bit deeper into how for example
1185480	1193480	chrome which uses the v8 engine uh the javascript uh actually goes about uh creating these closures
1194600	1200440	now this is where we kind of diverge in terms of uh what ecma script says we should be doing
1201000	1207400	or what it's specifying and how the ecma script is actually implemented so ecma script is the
1207400	1214200	specification for the javascript language and um different browsers and for example node would
1214200	1218440	have their own implementations so for example the v8 engine that chrome uses is written in c plus
1218440	1224520	plus and it kind of compiles javascript on the fly while it runs it and tries to optimize things
1224520	1232120	as it goes um but as you can imagine the ecma script approach is a little bit um flawed so
1232920	1237640	you know if you have a bunch of variables defined in a function and only one of them gets captured
1237640	1241720	by an inner function and then you return from the outer function you don't really want to be
1241720	1248840	holding on to all of the variables in that electrical environment um past their jup uh their
1248840	1253800	their expiry date basically because no one's going to use them um if you've only captured one variable
1254600	1261320	so what we well what v8 does is kind of intelligent but i'm going to show you i'm going to show you
1261320	1266840	what it does so in this program we've got an outer function we define three different variables x y
1266840	1274920	and huge so huge let's just pretend this is a really big object and we have our uh we've got one
1274920	1280520	function here called bar which captures the huge variable so it references that doesn't reference
1280520	1285080	these two guys though then we have an inner function which captures x but doesn't capture these two
1285080	1289960	guys and then we return the inner function so bar is defined but doesn't actually get used
1291160	1294920	on the outside we did the same things before we call our outer function that gives us this
1294920	1301080	so you sign up for food and then we call food okay so let's have a look at how this actually
1301080	1307000	works so if i play this now um we've created a foo object so i can have a look in here and it's got
1307000	1315240	scopes now interestingly uh this guy is now it has a reference to a closure from the outer function
1315240	1319400	because the outer function is now returned and it actually refers to two different things so it
1319400	1325320	actually has a reference to x which it explicitly captured but also a huge object now uh it's good
1325320	1329320	to know that it doesn't have access to the y variable because that would be a waste of memory
1329320	1333960	because no one actually makes use of that but you know uh what does what does the inner function
1333960	1339000	care about the huge variable it doesn't make use of it in the case of the x variable so if we continue
1339000	1347800	again and we look at the actual closure that we have in our outer function um look at that so
1348760	1354200	we've got both of our things here that were captured so what this tells us is that in the v8
1354200	1362840	implementation of um closures effectively the way that it works is uh as soon as we probably actually
1363400	1369480	let me refresh this debugger save oops here we go
1372120	1380120	debugger oh i did it again okay this time will definitely work it's not only that you have
1380120	1387640	to do this save play all right so in here um let's have a look so we have debugger
1388200	1395240	we're being called script global bar you know this okay bar you know so this is just these
1395240	1401960	guys being hoisted uh as is y finally enough x and y sorry x is huge don't appear in my local
1401960	1410520	scope i can't see them in the they're not really in a um closure if i continue again
1411240	1417880	and they appear here interesting so what we'll do is later on i'm going to show
1417880	1422040	kind of what really happens on the actual heap because the dev chrome tools let you
1422040	1428040	so chrome dev tools let you actually inspect heap snatch odds um but for now i'm just going to
1428040	1435080	continue uh and we're going to talk about the this variable okay so um i have said so far that the
1435880	1443320	uh the JavaScript uses static scoping which is for the most part true but there is one notable
1443320	1448040	exception and that is the this binding um it's something a variable because it's its value
1448040	1452440	does not vary once you're inside the scope um it just kind of gets given a variable and that's what
1452440	1461320	it is um so the way that it works is it's effectively um well i'll show you an example so
1461320	1466280	here we said x to one then we create an object it's got a couple properties x and a a is a function
1466280	1472040	that just logs x and um this is really just a demonstration of how things get weird pretty
1472040	1479400	quick so we have a bar variable um and we're just setting that to the value of object dot a so this
1479400	1483160	is now going to be this function here and then we also can just call object dot a directly
1483160	1487320	funnily enough though this gives two different values i've played this get my console one or two
1487320	1492840	okay bizarre we've got the exact same function but depending on how we call it we get a different
1492840	1501800	value so in in uh the case of bar we get x and in the case of object dot a we get uh two so what's
1501800	1506760	going on here so the way that it works is if you have a function and it contains a this binding
1507960	1511640	the value that's passed in is actually based on the way in which you call that function so
1512440	1516840	if you just call it directly then it's going to be given the value of the
1518200	1526040	global object which is basically a object that contains this axis of property um whereas if
1526040	1530920	you call it so if on the left hand side of these brackets these parentheses you have what is called
1530920	1538360	a reference type then it's actually going to be given the um the this variable or this binding
1538360	1543320	will be given the value of the object itself meaning when we try and call the
1544840	1549880	x property on that it's going to be this guy so what's going on here so a reference type
1549880	1553640	is basically you can actually check these in brackets and it will still work hang on let me
1554600	1563560	copy this refresh do that save play same thing same thing yeah so what this actually is is a
1564520	1572360	it before it evaluates to the actual um uh like function it evaluates to a reference type
1572360	1575320	and a reference type is just when you have an object and then you're calling some property on
1575320	1579080	that object so in this case it's object dot a so whatever you do that and then you have the
1579080	1584840	parentheses here what it means is it'll it'll invoke this function but it will set the this
1584840	1593160	binding to the value of the actual object strange why would we uh violate static scoping in this way
1593240	1599560	right when this thing is defined uh it's with that the way you call it as a as opposed to the
1599560	1605800	way that you create it which is more of a dynamic scoping thing what influences value um and basically
1605800	1612520	what this enables is um sharing of code so we're going to have two objects here and a foo function
1612520	1618760	that makes use of the this dot x uh reference you can then assign that to both of these objects
1618760	1622200	and you can call them and you'll get different values because the different objects contain
1622200	1627560	different values for x so effectively because function is the first class it would be a shame
1627560	1634520	if we couldn't actually kind of uh make use of this neat functionality to have kind of uh
1635160	1641240	genericized logic that can be applied to different objects and different data um there is another
1641240	1648040	example of how this works which is um when creating prototypes so i'm going to too much detail about
1648040	1654760	prototypes here but prototypes are effectively the way the javascript enables inheritance so um
1654760	1658920	we've got a kind of constructor function here and it says okay you give me an object like an empty
1658920	1664040	object and i'll set x to one on that object and i'll set the blah property to this function
1664040	1670680	but just console log something and then i can say on here i can set the prototype of this function
1670680	1675640	which is a fancy way of saying you know when i create an object um from this guy using the the
1675640	1682120	new keyword um i want this object's prototype to have this additional functionality so in this case
1682120	1688600	i'm saying i've got a foo property and it has a function that console logs this dot x and if i go
1688600	1695000	and create my a object i'll get an object that just says x is one and then if i call foo on that um
1695000	1700680	because i'm making use of the this keyword here um i'll be referencing this x because i'm using a
1700680	1710040	reference type here so they play this one okay cool so um what this enables is basically inheritance
1710040	1721480	i can have multiple different objects here i can go b um and i can say a dot prototype equals b dot
1721480	1732520	prototype and make that two make that ha ha and i can go let's see um i can do object new b
1733320	1737400	and then there's a b2 and then it should log two so let me just save this
1739240	1745160	whoops oh no i've lost it oh that's all right i can just do it again so
1746120	1755960	okay i've got a b constructor by those two this says ha ha i'm going to say
1757160	1762360	b dot prototype equals a dot prototype and then make this a b it's going to be two
1763240	1769320	and save and play now it logs two okay cool so what this says is basically we've got two completely
1769320	1774040	different um constructors here but they both inherit from this same kind of prototype which
1774040	1778440	has this function on it where we can say just console log this dot x and there you go you can
1778440	1784600	create uh effectively we've created a taxonomy a and b both inherit from some prototype that
1784600	1791560	defines a behavior that we can call if the property itself doesn't exist on our base objects so um
1791560	1799560	through the this binding we basically enable these prototype chains to define um shared behavior
1799560	1808360	among the descendant objects um so uh pretty cool so this is what i mean so starting scoping on
1808360	1813640	the whole pretty good but sometimes it is worth it to go for the dynamic approach if it enables
1813640	1819960	things like in this case sharing code and uh inheritance okay so in this case this is just
1819960	1825800	an example of where it can get a bit weird and you might want to switch up what you're doing so
1825880	1830840	here we have a constructor function called foo set x to one and then we say set time out and
1830840	1836360	then when the time out when a second passes i'm going to console log this dot x okay there we go
1836360	1845880	f figures new foo so if you run this what's gonna happen one one let's have a look at that um console
1846840	1848840	x
1849240	1851880	why is it going one one let's try this again
1854120	1859000	oh because i hadn't i hadn't cleared my uh console okay good so it's logging undefined
1860120	1864440	kind of weird it's saying this dot x and this x is one so why would that be happening
1864440	1871880	the reason is because when we go set time out this guy gets added to our um our event queue
1871880	1876600	and when it finally gets popped off and gets ran it's ran on the global execution context
1876600	1883480	meaning it's not being called as you know f dot blah it's just being called directly
1885160	1890680	that means it gets past the global object as it's this and the global object does not define
1890680	1895880	ax if it did it would log that so if i go x equals two i think this will work maybe it won't
1895880	1902360	but let's find out um i'm gonna refresh i'm gonna paste i'm gonna save i'm gonna play
1903320	1908120	two okay cool so yeah it gets past the global object um so this is kind of weird because
1908920	1913800	we really wanted to just be able to reference the this this defined you know inside this scope
1914760	1920360	so what can we do let's go to the next example and what you can do is this is the exact same thing
1920360	1924200	we've just swapped out our function declaration for a uh lander expression
1924440	1929880	these are added in the es6 and basically now if you play this
1933240	1939800	yep one there you go so i had to wait a second um okay so what's the difference here so the
1939800	1945800	use of the lander expression is really a way of forcing static scoping um when otherwise the this
1945800	1950360	binding would be making use of dynamic scoping um to demonstrate let's have a look at what it
1950360	1957080	actually does behind the scenes so if we go to um this babel rebel it shows on the left hand side
1957080	1961320	this is the exact same thing we have here and we're saying set timeout we're using a lander
1961320	1966120	function and this is what it actually transpiles to so what we get is inside here we say first of all
1966120	1972200	let's just keep track of what our disc variable is inside this scope and then it means that when
1972200	1976520	we create this function here and so see how it's lambda here but it's not lambda here so it's really
1976520	1981080	just under the hood a regular function what we're doing here isn't it we're now instead of using
1981080	1985480	this directly because we know this thing is kind of unreliable and there's value changes let's
1985480	1992600	prefer to this um statically defined this variable and we'll call x on that and so then when we log
1992600	1999720	that that's how we get this value of one so um effectively what using a lander function does
1999720	2005880	is it basically forces JavaScript to make use of static scoping by under the hood going and
2005880	2012600	actually adding a um uh a variable to this classical scope and it means that you're not
2012600	2020600	worrying about what the value of this is when this guy's actually in vote so um yeah it's cool
2020600	2026520	so the this binding gives you some cool benefits when you want them when you don't want them there's
2026520	2032120	typically ways to get around having to use it um another way would be calling dot bind on a function
2032120	2038840	and passing it um the value of the current this um but i'm not going to go into that just uh just
2038840	2046280	now because i say the end but there's actually one more thing i want to show you guys okay so
2046280	2053080	here we're going to look at actually um what happens in terms of the heap when we are dealing
2053080	2059480	with closures so it's a similar function to what we had before we've got an outer we've got a inner
2059480	2066440	we've got a bar it doesn't really get used and we just call everything at the end so let's run this
2066440	2074280	guy see what happens okay so we've defined our outer function and actually let me just play through
2074280	2078600	here what actually happens here something's undefined okay what i'm going to do is i'm going to
2079400	2086680	every step of the way here i'm going to actually take a snapshot this is a heap snapshot and it
2086680	2089960	basically goes and tells you what are all the things that have been actually like all the
2089960	2094280	objects have been put on the heap um at this point in time so i'm going to play forwards i'm
2094280	2100840	going to take another snapshot i'm going to go again take another snapshot i'm going to go again
2100840	2108120	take another snapshot and then i'm going to go again i think one more snapshot okay cool now what
2108120	2115960	i'm going to do is i'm going to in each of these places only show the difference between the current
2115960	2124440	snapshot and the previous one so make sense okay cool so this is trying to see the difference in
2124440	2134040	what's been allocated what's been newly allocated between between um one snapshot and the next one
2134040	2140120	so okay snapshot two let's have a look at what happens inside here so we've got back to our sources
2140120	2147400	so that's looking at this guy so we create our outer function um okay so we've got a closure being
2147400	2152440	created here oh interesting so by the time we get to the end of um by the time we get to here
2153400	2160760	we've created this function and it has a closure object here so this is 124913 uh it's got a context
2162040	2167960	the preview okay that's got a lot of random stuff there okay so interesting all right let's look at
2167960	2172840	what snapshot three gives us okay so this is actually this is creating a closure this guy's
2172840	2178360	creating a context so in v8 this is there's a thing called a context capital c not to be confused
2178360	2188200	with an execution context and let me really um okay so uh let's see what we're actually creating here
2188200	2194680	okay so snapshot three that's one two three so at the very beginning when the code enters our
2194680	2202440	outer function we have already made a context object which is going to store the two things
2202440	2206120	which are being captured here so bar string and inner string okay let's have a look at this so
2206120	2213160	bar string is captured by bar down here inner string is captured by inner down here and uncaptured
2213160	2219240	string is actually not captured by anyone we just define that we don't use it so this is interesting
2219240	2224280	so as soon as we're here we actually JavaScript clearly goes ahead and before it actually goes
2224280	2228280	and continues writing the code it goes and says okay here's all the things to get to find in our
2228280	2233160	scope okay who's going to be using those things who's going to be capturing those things whoever
2233160	2240040	you know if anyone inside here if any function captures these variables then we need to actually
2240040	2244280	create a context object and put those variables on that context so here we've got one two five
2244360	2249880	one one nine okay interesting we move on and here we enter a block now this could this could
2249880	2255160	have just been like if you know true um but you actually don't need to have that you can actually
2255160	2259480	just enter a block directly um which is a it's a feature no one uses but i feel like maybe we should
2259480	2264360	use a bit more um to kind of limit variable scope but at any rate uh it's just here for
2264360	2271160	demonstration purposes so here we enter the block scope and here we have a block string
2271160	2277400	which is captured by bar so if i look in my memory on subject four we get another context here okay
2278040	2283640	and it's not really telling us much right now but it has as its previous context so it's like a
2283640	2290760	reference to the parent context um the uh same guy was over four one two five one one nine
2290760	2295240	so that's the same as this guy here and it's got uh both of these strings now have the whole
2295240	2301160	use by the time we get to this point uh in the code um so yeah funny that we don't have our um
2302760	2307560	this guy defined um but maybe it's slightly different behavior between functions and
2308200	2314280	blocks but at any rate let's go to the next snapshot so let's see the next snapshot is
2314840	2320840	the final one is this guy on the other side of bar okay so now we have a closure so that means
2320920	2327080	we've got a bar function and it now references this context so one two five three one three
2327080	2335000	that's the same as this guy and what's inside here okay so now it has funnily enough it has um
2336280	2341560	you know what the value of this thing is this um block string but doesn't doesn't say what the name
2341560	2348040	is i don't know why that is maybe it doesn't need it maybe it's going to be minified um but uh at
2348040	2353160	any rate it's been captured and then here we've got a point into our previous context which has
2353160	2359960	our other two things that are captured as well so what that tells us is that uh these context
2359960	2367640	objects exist in a given scope and they whatever variables from that scope get used by uh other
2367640	2372280	functions in that scope um or like descendant scopes those will be the ones that end up being
2372280	2377800	added to the context and then um when you actually you know return one of these functions for example
2379000	2381880	let me go here
2384120	2384680	and
2388280	2388920	run that
2391160	2397000	so right now uh in my scope is that's kind of weird why is F not in here
2397240	2406200	oh because i haven't right yes very good let's call it a const fresh paste say play
2410200	2414520	hmm quite the same thing outer
2418120	2421080	i think it's it's behaving differently because of the fact that
2422040	2427160	i need to just change the actual source code let's do that start again oh disconnected
2429000	2439240	and here we go okay that's better cool so now we have um we can see here we've got this closure
2439240	2444440	i think contains the things we cared about for our inner function it does not contain the closure
2444440	2449720	that was made for this guy because that's in its own uh block um but uh through this guy
2449800	2455320	does have access to this closure that was defined right up here it contains um not only
2455880	2460040	in a string which this guy explicitly captured but also bar string which is something that
2460040	2465160	captured so um something to keep in mind if you have a huge you know if you've got two functions
2465160	2469560	closing over a bunch of variables and one of them closes over some huge object and the other one
2469560	2475560	doesn't but the other one lives on past the lifetime of the parent function then uh you might
2475560	2480120	be holding onto that object in your in your heap in memory for longer than you want to
2481400	2488760	but that effectively wraps this up so um hopefully this was a good intro to JavaScript scoping and
2489400	2496520	how it balances static scoping with dynamic scoping how it supports closures and what actually
2496520	2501560	happens on the heap when we are dealing with creating closures so yeah thanks for thanks for
2501560	2507480	watching and um I'll add a link in the description to the original part which goes into some more
2507480	2511240	detail about what's going on behind the scenes thanks for watching
