WEBVTT

00:00.000 --> 00:07.200
Hi guys, welcome to my video on scoping in JavaScript.

00:07.200 --> 00:14.280
So about a week ago I kind of started a deep dive into how JavaScript really works behind

00:14.280 --> 00:21.180
the scenes and part of that was learning about scoping.

00:21.180 --> 00:26.400
I made a blog post called Everything I Wish I Knew About JavaScript Scoping a Week Here

00:26.400 --> 00:31.240
which kind of goes into details about a lot of these things, but the first kind of chunk

00:31.240 --> 00:36.920
of that is really just about like, you know, var versus let versus const which are keywords

00:36.920 --> 00:41.800
for declaring variables which to be honest, I wasn't really that interested in in the

00:41.800 --> 00:47.760
first place and given that most people just don't use var anymore, I don't know how relevant

00:47.760 --> 00:54.960
it is, but I still think that scoping in general is pretty important to learn about

00:55.400 --> 01:00.320
and I learned some interesting things about static scoping, dynamic scoping and how it

01:00.320 --> 01:03.360
relates to this binding.

01:03.360 --> 01:08.440
So yeah, my plan with this video is to take you through what I learned and I'm going to

01:08.440 --> 01:15.680
try and take an experimental approach where I'm not going to make any claims without having

01:15.680 --> 01:20.880
some way of like backing it up, which is why I've got this, the Chrome Dev Tools open right

01:20.880 --> 01:21.880
now.

01:21.880 --> 01:27.520
We're going to try and understand how JavaScript works by actually observing what it does as

01:27.520 --> 01:29.800
a program runs.

01:29.800 --> 01:35.720
So we're starting with this program here, which basically declares a couple of variables

01:35.720 --> 01:42.600
a and b and then declares this outer function, it itself declares two variables c and d,

01:42.600 --> 01:48.200
then it declares a inner function which itself declares two more variables and then on the

01:48.200 --> 01:51.680
inside here we just console log all four.

01:51.680 --> 01:59.280
So a couple of these get overwritten, a does not get overwritten but c does, so in here

01:59.280 --> 02:05.760
it's called shadowing when you've got a function where another variable is in scope outside

02:05.760 --> 02:08.320
that function but we're kind of overriding its value here.

02:08.320 --> 02:12.240
I mean, we're not overriding the value of this variable, we just have another variable

02:12.240 --> 02:17.080
of the same name and therefore we can't really access this variable.

02:17.080 --> 02:21.640
So we've got this function here, then we just call that function and then we call the

02:21.640 --> 02:22.640
outer function.

02:22.640 --> 02:28.080
So the way the program works is we go here, declare this guy, call this guy, then we go

02:28.080 --> 02:31.680
inside here and declare this guy and then we call it.

02:31.680 --> 02:38.280
So the point here is that we've got kind of nested scoping and we want to see how these

02:38.280 --> 02:39.520
values end up coming out.

02:39.880 --> 02:47.440
So I play this now, console log shows a is one, b is five, c is six and d is four.

02:47.440 --> 02:53.640
So a is one because it gets started here and doesn't get overwritten or shadowed rather.

02:53.640 --> 02:59.720
b starts as two but then over here we've got b is five so we shadow this guy and we just

02:59.720 --> 03:05.400
say okay we've got our own b variable here which is equal to five so we use that.

03:05.400 --> 03:11.160
c is three but then over here it gets shadowed and we get a new c variable whose value is

03:11.160 --> 03:18.800
six so we end up saying c is six and finally d starts as four and does not get shadowed

03:18.800 --> 03:20.080
so it's just four here.

03:20.080 --> 03:25.360
So off the bat we can see that when you have a function declared inside another function

03:25.360 --> 03:31.320
it has access to variables defined outside of its scope whether it's d in the outer function

03:31.320 --> 03:34.400
or a in this global context.

03:34.840 --> 03:40.360
Okay so let's have a look at what's actually happening here but a diagram that I made.

03:40.360 --> 03:47.200
Basically JavaScript runs on an execution stack which is equivalent to a call stack.

03:47.200 --> 03:53.280
At the bottom we've got the global execution context and so each of these little stack

03:53.280 --> 04:00.120
frames is called an execution context so there's a global one at the bottom which is this

04:00.200 --> 04:06.440
thing here this scope here then we've got the outer execution context which would be

04:07.720 --> 04:11.240
everything that happens in here would be happening inside that context and then we've got the inner

04:11.240 --> 04:17.480
one which would be this stuff so what an execution context does is it basically distores

04:18.120 --> 04:22.520
information you need to be able to know where you are at in a function you know what the variables

04:22.520 --> 04:27.800
are that you might be reading from and it's the kind of thing where if you know if you

04:27.800 --> 04:32.120
turn the computer off and turn it back on again and this stack was still here

04:32.120 --> 04:35.080
and almost up to the point or two then you should be able to just continue the program

04:36.120 --> 04:43.160
from where you left off. So we've got our execution context on the execution stack

04:43.160 --> 04:50.200
and each of these points to a I'd say points to you probably more accurately has a reference to

04:51.160 --> 04:57.880
uh lexical environments so uh lexical environments uh when you see the word lexical it basically

04:57.880 --> 05:03.720
means like letters or things you can you can see um in this case we're talking about actual variables

05:03.720 --> 05:10.280
being defined so a lexical environment uh just contains two things it contains an environment

05:10.280 --> 05:17.080
record and a pointer to the parent lexical environment so um uh this happens to be called a

05:17.160 --> 05:21.080
declarative environment record but what an environment record is is is effectively just a

05:21.080 --> 05:26.760
mapping of variables to their values so in the case of our inner function we've got b is five and c

05:26.760 --> 05:31.480
is six so that's these two guys in our outer function we've got c is three and d is four

05:32.040 --> 05:38.840
which are these two guys and then in our global lexical environment we actually have this is kind

05:38.840 --> 05:45.400
of a it's a kind of weird edge case but um we've got a composite environment record consisting of

05:45.400 --> 05:52.840
two things the declarative environment record um for which b is two and we have this other thing

05:52.840 --> 05:58.840
called the object environment record so this is where things kind of get a bit weird um the uh

05:58.840 --> 06:03.960
back in the day basically everything used these object environment records and they would all

06:03.960 --> 06:09.960
have a thing called a binding object which was a literal javascript object that just contained

06:09.960 --> 06:17.160
your variables as properties um it is still the case today that at the global level if you define

06:17.160 --> 06:25.960
a variable with the um the var keyword then it actually ends up just being a property on the

06:25.960 --> 06:30.920
global object um on the other hand if you use let or const it's going to be sitting in this

06:30.920 --> 06:37.000
declarative environment record uh now what's the difference uh first of all uh when you actually

06:37.000 --> 06:41.960
have an object environment record the binding object in this case global just can be accessed by

06:41.960 --> 06:50.200
outside code um and uh it's not very efficient so these declarative ones um are there kind of

06:50.200 --> 06:59.000
internally stored and it's not accessible from the outside um okay so uh the the fact that these

06:59.000 --> 07:04.200
will point to each other allow us to create a scope chain where we can say you know i'm in the inner

07:04.200 --> 07:09.640
function i'm looking for the a variable right now because i want to log it and it's not in my

07:09.640 --> 07:15.160
declarative environment record it's so therefore i'll look to my parent it's not in there either

07:15.160 --> 07:21.240
with my parent oh here it is on the global object so you can get the value of one and then you can

07:22.120 --> 07:31.960
log that value so um it's probably also worth uh noting that um these uh functions when they

07:32.040 --> 07:37.640
created they actually get a eternal internal reference to the scopes that they have access to

07:37.640 --> 07:49.240
so let me go down here and actually gotta refresh the page if i go debugger and then play that okay so

07:51.080 --> 07:56.520
if i look at the inner function you can see here this is just in my dev tools inspector

07:57.480 --> 08:03.400
but in scope i've got my inner function it's got arguments it's got a prototype but it has this

08:03.400 --> 08:09.480
internal thing and these uh internal things are denoted by these double square brackets um this

08:09.480 --> 08:17.400
guy's called scopes and uh in this case uh we've got a few things i've got the value of d from

08:17.400 --> 08:23.240
that outer function the value of b from a script uh anything that's defined at the top level with

08:23.320 --> 08:28.840
let or const is considered to be script scoped um which is not the same as saying is actually

08:28.840 --> 08:32.760
i only scoped to the we're talking about actual script tags here if i go for example

08:35.800 --> 08:42.360
this thing would be a script tag um it's not actually scoped to the script tag it's just

08:44.680 --> 08:48.760
any script will have access to it um and then we've got the global thing here so

08:49.720 --> 08:55.240
we expand this guy we'll see that actually among the many properties of global object one is a

08:55.240 --> 09:03.080
whose value is one so that's this guy here so kind of weird um but also pretty cool so let's move on

09:03.080 --> 09:08.680
and i'm going to go to the next example so in this case we've got an inner and an outer function

09:08.680 --> 09:15.240
but our inner function is actually defined outside the outer function so when this guy's defined um

09:16.200 --> 09:26.040
uh the it references x but the x is actually defined in the uh global execution context

09:27.000 --> 09:34.600
and the um outer function basically when it gets called it goes and creates a its own local

09:34.600 --> 09:42.040
x variable and then it calls inner so the question here is which x will this inner function uh log

09:42.600 --> 09:49.800
um and it turns out that when you run this guy it's going to log one which means logs this thing

09:50.360 --> 09:57.960
so this kind of touches on the difference between static and dynamic scoping in static scoping

09:57.960 --> 10:06.520
when a function is created um any uh variables that references from an outer scope um it looks

10:06.600 --> 10:12.840
at okay like lexically or statically is what's called static scoping or lexical scoping uh what

10:12.840 --> 10:17.240
have i got access to so i can just look on the page here and see okay well there's an x this

10:17.240 --> 10:22.360
in scope here so that's what that's referring to um what actually you know is defined against

10:22.360 --> 10:27.960
a function that might be calling my inner function um it doesn't matter so uh that's called static

10:27.960 --> 10:32.600
scoping um which is to say that we you know you can just statically look at the page and know

10:33.240 --> 10:39.960
uh which variables here are being referenced now you might ask yourself uh isn't this what

10:39.960 --> 10:45.400
every programming language does and actually no it's not so here we have a bash script and

10:45.400 --> 10:51.560
i'm just going to paste this in here so uh in this script we do the exact same thing we define x

10:51.560 --> 10:55.800
we've got an inner function that just logs it an outer function that defines its own x and calls

10:55.800 --> 10:59.880
the inner function and then we call the outer function so we're going to go x is one call the

10:59.880 --> 11:03.880
outer function go in here create x equals two call it inner function and then echo x

11:04.600 --> 11:09.240
press this uh if you play this okay so this actually logs two so what this means is that

11:10.360 --> 11:17.640
bash does not use static scoping it uses dynamic scoping um dynamic scoping is where you care about

11:17.640 --> 11:23.800
what variables are defined at call time um meaning you know at the time this guy's called

11:23.800 --> 11:28.760
we look at okay what's uh what's the value of x so like we're in here we go okay we need the

11:28.760 --> 11:34.840
value of x instead of looking electrically statically up to whatever was defined at the

11:34.840 --> 11:39.800
point when this guy was created in which case x would be one we instead say well who called us

11:39.800 --> 11:44.440
okay well we're being called by outer is there an x defined in this scope yes there is okay let's

11:44.440 --> 11:52.040
log that so um a diagram that explains this discrepancy would be this so let's assume that

11:52.040 --> 11:57.800
bash itself had a concept of lexical environments which it doesn't but if it did um then this is

11:57.800 --> 12:01.320
the difference between how the two would operate so in this case we've got out inner function

12:02.360 --> 12:10.120
doesn't have an x defined so uh in JavaScript we go well you know somehow we know that um

12:11.320 --> 12:15.560
the uh parent lexical environment it's actually the global environment because when this guy was

12:15.560 --> 12:23.960
defined uh i'm just gonna go back when this guy was defined it was uh lexically in scope here

12:23.960 --> 12:29.400
this you know we didn't care about the outer function at the point this was created um so we

12:29.400 --> 12:35.800
go here and find x is one and we log that on the other hand bash just follows the actual stack frame

12:35.800 --> 12:40.600
so it goes okay nothing's defined here okay what about the guy that called me oh it is defined

12:40.600 --> 12:47.160
there okay well i'll return that so um different languages have different approaches to this so

12:47.240 --> 12:53.880
for example in pearl you can have both dynamic or static scoping depending on how you uh declare

12:53.880 --> 12:59.880
your variables um they've got different benefits for different use cases but generally it's

12:59.880 --> 13:05.000
considered that static scoping is superior because it enables uh there are a few reasons

13:05.000 --> 13:13.000
one of which is you can more easily reason about how a function will behave so for example in this

13:13.000 --> 13:17.720
case i don't need to care about you know once i've defined this function i know that this guy's

13:17.720 --> 13:22.120
in scope and so it's referencing that i don't need to worry about whether in some other file

13:22.120 --> 13:30.840
some other function is calling me and um it defines x in its own weird way so to understand

13:30.840 --> 13:35.400
how a single function will work all i need to do is look at the page or look at the files defined

13:35.400 --> 13:40.200
and look at the scope it's defined in and i'll understand um with dynamic scoping you need to

13:40.200 --> 13:45.560
think about all the permutations and understand you know who knows what variables could be set

13:45.560 --> 13:52.920
when i'm being called by some random outer function um dynamic scoping does have uh one benefit

13:52.920 --> 13:59.640
which is that you um don't need to worry about storing variables on the heap so you know assuming

13:59.640 --> 14:04.120
we're talking about primitives like booleans and integers you can just keep everything on the stack

14:04.120 --> 14:10.760
here and as soon as you're done with the function you just you know drop down the stack pointer

14:10.760 --> 14:15.480
throughout the memory when you put a new when you enter a new function you put a new stack frame on

14:15.480 --> 14:21.560
the stack move the pointer up again and uh basically you know whenever you need to look for a variable

14:21.560 --> 14:27.240
you just look down the stack until you find it um in JavaScript we need to kind of have some

14:27.240 --> 14:32.680
additional uh metadata that we hold on to for example to say that you know this inner function

14:32.680 --> 14:38.280
was really defined with this guy in scope we don't you know at the time we didn't care about the

14:38.280 --> 14:43.080
outer function so we need to skip this guy because we've been static scoping you know the fact we

14:43.080 --> 14:47.320
have to store those kinds of references means we can't do it all on the stack it's not as simple as

14:47.320 --> 14:57.160
just looking from top to bottom um but let's continue so there is another way in which static

14:57.160 --> 15:05.960
scoping um helps us and that is in how closures work so uh a closure it kind of has two definitions

15:05.960 --> 15:14.280
the first definition of closure is a function that is paired with um a uh it's paired with this

15:14.280 --> 15:19.480
environment so it's a function the client has knowledge about where it was for example created

15:19.480 --> 15:23.960
and what variables were in scope at that point um there's another definition of closure which is

15:23.960 --> 15:27.720
just referring to the environment part like you know the closure is just the things that are

15:27.720 --> 15:33.880
captured the variables are captured so the two are kind of used interchangeably um but uh that

15:33.880 --> 15:40.600
effectively referring to the same concept um so uh in this case we have a function we we define x

15:40.600 --> 15:46.920
and we have an outer function now um that defines an inner function internally um outer has its own

15:46.920 --> 15:51.960
x whose value is two and uh what happens here is the outer actually returns inner so it returns

15:51.960 --> 15:57.960
a function so in javascript functions are first class which means that you can um pass them in

15:57.960 --> 16:02.280
as arguments to functions and you can also return them from functions so you can treat them like

16:02.280 --> 16:09.720
any other variable um so what's happening here is we're actually uh capturing this uh x value

16:09.720 --> 16:14.280
here and we're capturing this one because lecicle scoping says that we first look at you know what's

16:14.280 --> 16:19.720
the now immediate scope here all the values x okay well we'll just capture that guy um we return

16:19.720 --> 16:26.360
the inner function and then we assign that to this variable foo so we call it outer it returns

16:26.360 --> 16:30.760
inner so now foo's value is inner then we call foo which is the same as calling our inner function

16:32.040 --> 16:34.760
and the question is what does it log so if you run this

16:40.120 --> 16:45.720
we log the value of two so um okay what's interesting about this is that

16:46.440 --> 16:53.240
that this variable two which is defining that outer function um really has no reason to exist

16:53.960 --> 17:00.760
after we uh leave the called outer if not for our inner function we're trying to

17:00.760 --> 17:07.400
capture that variable so I say capture another word will be close over the reason it's called

17:07.400 --> 17:12.920
capture is because we need to hold on to this thing after the lifetime of that outer function

17:13.880 --> 17:17.480
so if we for example we're just storing everything on the stack here

17:18.040 --> 17:23.880
we'd have our outer function we'd have our inner function we'd have uh x equals two happening here

17:24.520 --> 17:29.880
and uh we'd eventually have to pop off the stack and get back to our global execution

17:29.880 --> 17:36.120
context for me down here but once we want to then call our inner function again um we need to have

17:36.120 --> 17:42.920
some way of saying of keeping track of the fact that it uh has this variable x equals two which

17:42.920 --> 17:52.120
isn't actually defined in its scope so um let me grab this diagram so what's happening here is that

17:52.120 --> 17:57.560
by the time we get to foo which is really just a variable pointing it out inner function um

17:57.560 --> 18:01.960
it has nothing to find in the statistical environment and because we use stack scoping it

18:01.960 --> 18:06.920
just so happens that this uh function contained a reference to the electrical environment

18:07.880 --> 18:13.880
of the outer function uh where x equals two and so we can say okay x equals two uh obviously that

18:13.880 --> 18:18.120
also close to the global environment record now if we were if we were using dynamic scoping

18:19.320 --> 18:24.440
what would happen here uh effectively we have a foo function here we'd be calling it in the

18:24.440 --> 18:30.840
global context meaning this guy is in scope and the this guy is not and we'd be going console log x

18:30.840 --> 18:35.160
and we just look down the call stack so foo we don't have it global context we do have it the

18:35.160 --> 18:42.840
value is one um so we'll return one so um effectively dynamic scoping does not support

18:42.840 --> 18:49.480
closures uh unlike static scoping which will allow you to kind of store these guys in memory

18:49.480 --> 18:56.440
somehow and then later on you can access those uh variables and change them or just read from them

18:57.400 --> 19:02.520
um so i'm just gonna start this again just as we can see what's actually happening here so

19:03.720 --> 19:09.160
our foo function is has some scopes and we've got a closure here so it closes up x

19:10.680 --> 19:15.240
then the next one up we've got our script for which x equals one and then the global object so these

19:15.240 --> 19:19.640
two guys are kind of two parts of the composite environment record that happen in the global

19:19.640 --> 19:26.920
execution context um so it's kind of interesting and if i go in here it's effectively the same

19:26.920 --> 19:32.520
thing we have this uh well in this scope here actually now forget about function so just in

19:32.520 --> 19:37.080
this scope um we're trying to console log this thing but access to this closure which we're saying

19:37.080 --> 19:45.400
x equals two that's pretty cool um now uh let's look a little bit deeper into how for example

19:45.480 --> 19:53.480
chrome which uses the v8 engine uh the javascript uh actually goes about uh creating these closures

19:54.600 --> 20:00.440
now this is where we kind of diverge in terms of uh what ecma script says we should be doing

20:01.000 --> 20:07.400
or what it's specifying and how the ecma script is actually implemented so ecma script is the

20:07.400 --> 20:14.200
specification for the javascript language and um different browsers and for example node would

20:14.200 --> 20:18.440
have their own implementations so for example the v8 engine that chrome uses is written in c plus

20:18.440 --> 20:24.520
plus and it kind of compiles javascript on the fly while it runs it and tries to optimize things

20:24.520 --> 20:32.120
as it goes um but as you can imagine the ecma script approach is a little bit um flawed so

20:32.920 --> 20:37.640
you know if you have a bunch of variables defined in a function and only one of them gets captured

20:37.640 --> 20:41.720
by an inner function and then you return from the outer function you don't really want to be

20:41.720 --> 20:48.840
holding on to all of the variables in that electrical environment um past their jup uh their

20:48.840 --> 20:53.800
their expiry date basically because no one's going to use them um if you've only captured one variable

20:54.600 --> 21:01.320
so what we well what v8 does is kind of intelligent but i'm going to show you i'm going to show you

21:01.320 --> 21:06.840
what it does so in this program we've got an outer function we define three different variables x y

21:06.840 --> 21:14.920
and huge so huge let's just pretend this is a really big object and we have our uh we've got one

21:14.920 --> 21:20.520
function here called bar which captures the huge variable so it references that doesn't reference

21:20.520 --> 21:25.080
these two guys though then we have an inner function which captures x but doesn't capture these two

21:25.080 --> 21:29.960
guys and then we return the inner function so bar is defined but doesn't actually get used

21:31.160 --> 21:34.920
on the outside we did the same things before we call our outer function that gives us this

21:34.920 --> 21:41.080
so you sign up for food and then we call food okay so let's have a look at how this actually

21:41.080 --> 21:47.000
works so if i play this now um we've created a foo object so i can have a look in here and it's got

21:47.000 --> 21:55.240
scopes now interestingly uh this guy is now it has a reference to a closure from the outer function

21:55.240 --> 21:59.400
because the outer function is now returned and it actually refers to two different things so it

21:59.400 --> 22:05.320
actually has a reference to x which it explicitly captured but also a huge object now uh it's good

22:05.320 --> 22:09.320
to know that it doesn't have access to the y variable because that would be a waste of memory

22:09.320 --> 22:13.960
because no one actually makes use of that but you know uh what does what does the inner function

22:13.960 --> 22:19.000
care about the huge variable it doesn't make use of it in the case of the x variable so if we continue

22:19.000 --> 22:27.800
again and we look at the actual closure that we have in our outer function um look at that so

22:28.760 --> 22:34.200
we've got both of our things here that were captured so what this tells us is that in the v8

22:34.200 --> 22:42.840
implementation of um closures effectively the way that it works is uh as soon as we probably actually

22:43.400 --> 22:49.480
let me refresh this debugger save oops here we go

22:52.120 --> 23:00.120
debugger oh i did it again okay this time will definitely work it's not only that you have

23:00.120 --> 23:07.640
to do this save play all right so in here um let's have a look so we have debugger

23:08.200 --> 23:15.240
we're being called script global bar you know this okay bar you know so this is just these

23:15.240 --> 23:21.960
guys being hoisted uh as is y finally enough x and y sorry x is huge don't appear in my local

23:21.960 --> 23:30.520
scope i can't see them in the they're not really in a um closure if i continue again

23:31.240 --> 23:37.880
and they appear here interesting so what we'll do is later on i'm going to show

23:37.880 --> 23:42.040
kind of what really happens on the actual heap because the dev chrome tools let you

23:42.040 --> 23:48.040
so chrome dev tools let you actually inspect heap snatch odds um but for now i'm just going to

23:48.040 --> 23:55.080
continue uh and we're going to talk about the this variable okay so um i have said so far that the

23:55.880 --> 24:03.320
uh the JavaScript uses static scoping which is for the most part true but there is one notable

24:03.320 --> 24:08.040
exception and that is the this binding um it's something a variable because it's its value

24:08.040 --> 24:12.440
does not vary once you're inside the scope um it just kind of gets given a variable and that's what

24:12.440 --> 24:21.320
it is um so the way that it works is it's effectively um well i'll show you an example so

24:21.320 --> 24:26.280
here we said x to one then we create an object it's got a couple properties x and a a is a function

24:26.280 --> 24:32.040
that just logs x and um this is really just a demonstration of how things get weird pretty

24:32.040 --> 24:39.400
quick so we have a bar variable um and we're just setting that to the value of object dot a so this

24:39.400 --> 24:43.160
is now going to be this function here and then we also can just call object dot a directly

24:43.160 --> 24:47.320
funnily enough though this gives two different values i've played this get my console one or two

24:47.320 --> 24:52.840
okay bizarre we've got the exact same function but depending on how we call it we get a different

24:52.840 --> 25:01.800
value so in in uh the case of bar we get x and in the case of object dot a we get uh two so what's

25:01.800 --> 25:06.760
going on here so the way that it works is if you have a function and it contains a this binding

25:07.960 --> 25:11.640
the value that's passed in is actually based on the way in which you call that function so

25:12.440 --> 25:16.840
if you just call it directly then it's going to be given the value of the

25:18.200 --> 25:26.040
global object which is basically a object that contains this axis of property um whereas if

25:26.040 --> 25:30.920
you call it so if on the left hand side of these brackets these parentheses you have what is called

25:30.920 --> 25:38.360
a reference type then it's actually going to be given the um the this variable or this binding

25:38.360 --> 25:43.320
will be given the value of the object itself meaning when we try and call the

25:44.840 --> 25:49.880
x property on that it's going to be this guy so what's going on here so a reference type

25:49.880 --> 25:53.640
is basically you can actually check these in brackets and it will still work hang on let me

25:54.600 --> 26:03.560
copy this refresh do that save play same thing same thing yeah so what this actually is is a

26:04.520 --> 26:12.360
it before it evaluates to the actual um uh like function it evaluates to a reference type

26:12.360 --> 26:15.320
and a reference type is just when you have an object and then you're calling some property on

26:15.320 --> 26:19.080
that object so in this case it's object dot a so whatever you do that and then you have the

26:19.080 --> 26:24.840
parentheses here what it means is it'll it'll invoke this function but it will set the this

26:24.840 --> 26:33.160
binding to the value of the actual object strange why would we uh violate static scoping in this way

26:33.240 --> 26:39.560
right when this thing is defined uh it's with that the way you call it as a as opposed to the

26:39.560 --> 26:45.800
way that you create it which is more of a dynamic scoping thing what influences value um and basically

26:45.800 --> 26:52.520
what this enables is um sharing of code so we're going to have two objects here and a foo function

26:52.520 --> 26:58.760
that makes use of the this dot x uh reference you can then assign that to both of these objects

26:58.760 --> 27:02.200
and you can call them and you'll get different values because the different objects contain

27:02.200 --> 27:07.560
different values for x so effectively because function is the first class it would be a shame

27:07.560 --> 27:14.520
if we couldn't actually kind of uh make use of this neat functionality to have kind of uh

27:15.160 --> 27:21.240
genericized logic that can be applied to different objects and different data um there is another

27:21.240 --> 27:28.040
example of how this works which is um when creating prototypes so i'm going to too much detail about

27:28.040 --> 27:34.760
prototypes here but prototypes are effectively the way the javascript enables inheritance so um

27:34.760 --> 27:38.920
we've got a kind of constructor function here and it says okay you give me an object like an empty

27:38.920 --> 27:44.040
object and i'll set x to one on that object and i'll set the blah property to this function

27:44.040 --> 27:50.680
but just console log something and then i can say on here i can set the prototype of this function

27:50.680 --> 27:55.640
which is a fancy way of saying you know when i create an object um from this guy using the the

27:55.640 --> 28:02.120
new keyword um i want this object's prototype to have this additional functionality so in this case

28:02.120 --> 28:08.600
i'm saying i've got a foo property and it has a function that console logs this dot x and if i go

28:08.600 --> 28:15.000
and create my a object i'll get an object that just says x is one and then if i call foo on that um

28:15.000 --> 28:20.680
because i'm making use of the this keyword here um i'll be referencing this x because i'm using a

28:20.680 --> 28:30.040
reference type here so they play this one okay cool so um what this enables is basically inheritance

28:30.040 --> 28:41.480
i can have multiple different objects here i can go b um and i can say a dot prototype equals b dot

28:41.480 --> 28:52.520
prototype and make that two make that ha ha and i can go let's see um i can do object new b

28:53.320 --> 28:57.400
and then there's a b2 and then it should log two so let me just save this

28:59.240 --> 29:05.160
whoops oh no i've lost it oh that's all right i can just do it again so

29:06.120 --> 29:15.960
okay i've got a b constructor by those two this says ha ha i'm going to say

29:17.160 --> 29:22.360
b dot prototype equals a dot prototype and then make this a b it's going to be two

29:23.240 --> 29:29.320
and save and play now it logs two okay cool so what this says is basically we've got two completely

29:29.320 --> 29:34.040
different um constructors here but they both inherit from this same kind of prototype which

29:34.040 --> 29:38.440
has this function on it where we can say just console log this dot x and there you go you can

29:38.440 --> 29:44.600
create uh effectively we've created a taxonomy a and b both inherit from some prototype that

29:44.600 --> 29:51.560
defines a behavior that we can call if the property itself doesn't exist on our base objects so um

29:51.560 --> 29:59.560
through the this binding we basically enable these prototype chains to define um shared behavior

29:59.560 --> 30:08.360
among the descendant objects um so uh pretty cool so this is what i mean so starting scoping on

30:08.360 --> 30:13.640
the whole pretty good but sometimes it is worth it to go for the dynamic approach if it enables

30:13.640 --> 30:19.960
things like in this case sharing code and uh inheritance okay so in this case this is just

30:19.960 --> 30:25.800
an example of where it can get a bit weird and you might want to switch up what you're doing so

30:25.880 --> 30:30.840
here we have a constructor function called foo set x to one and then we say set time out and

30:30.840 --> 30:36.360
then when the time out when a second passes i'm going to console log this dot x okay there we go

30:36.360 --> 30:45.880
f figures new foo so if you run this what's gonna happen one one let's have a look at that um console

30:46.840 --> 30:48.840
x

30:49.240 --> 30:51.880
why is it going one one let's try this again

30:54.120 --> 30:59.000
oh because i hadn't i hadn't cleared my uh console okay good so it's logging undefined

31:00.120 --> 31:04.440
kind of weird it's saying this dot x and this x is one so why would that be happening

31:04.440 --> 31:11.880
the reason is because when we go set time out this guy gets added to our um our event queue

31:11.880 --> 31:16.600
and when it finally gets popped off and gets ran it's ran on the global execution context

31:16.600 --> 31:23.480
meaning it's not being called as you know f dot blah it's just being called directly

31:25.160 --> 31:30.680
that means it gets past the global object as it's this and the global object does not define

31:30.680 --> 31:35.880
ax if it did it would log that so if i go x equals two i think this will work maybe it won't

31:35.880 --> 31:42.360
but let's find out um i'm gonna refresh i'm gonna paste i'm gonna save i'm gonna play

31:43.320 --> 31:48.120
two okay cool so yeah it gets past the global object um so this is kind of weird because

31:48.920 --> 31:53.800
we really wanted to just be able to reference the this this defined you know inside this scope

31:54.760 --> 32:00.360
so what can we do let's go to the next example and what you can do is this is the exact same thing

32:00.360 --> 32:04.200
we've just swapped out our function declaration for a uh lander expression

32:04.440 --> 32:09.880
these are added in the es6 and basically now if you play this

32:13.240 --> 32:19.800
yep one there you go so i had to wait a second um okay so what's the difference here so the

32:19.800 --> 32:25.800
use of the lander expression is really a way of forcing static scoping um when otherwise the this

32:25.800 --> 32:30.360
binding would be making use of dynamic scoping um to demonstrate let's have a look at what it

32:30.360 --> 32:37.080
actually does behind the scenes so if we go to um this babel rebel it shows on the left hand side

32:37.080 --> 32:41.320
this is the exact same thing we have here and we're saying set timeout we're using a lander

32:41.320 --> 32:46.120
function and this is what it actually transpiles to so what we get is inside here we say first of all

32:46.120 --> 32:52.200
let's just keep track of what our disc variable is inside this scope and then it means that when

32:52.200 --> 32:56.520
we create this function here and so see how it's lambda here but it's not lambda here so it's really

32:56.520 --> 33:01.080
just under the hood a regular function what we're doing here isn't it we're now instead of using

33:01.080 --> 33:05.480
this directly because we know this thing is kind of unreliable and there's value changes let's

33:05.480 --> 33:12.600
prefer to this um statically defined this variable and we'll call x on that and so then when we log

33:12.600 --> 33:19.720
that that's how we get this value of one so um effectively what using a lander function does

33:19.720 --> 33:25.880
is it basically forces JavaScript to make use of static scoping by under the hood going and

33:25.880 --> 33:32.600
actually adding a um uh a variable to this classical scope and it means that you're not

33:32.600 --> 33:40.600
worrying about what the value of this is when this guy's actually in vote so um yeah it's cool

33:40.600 --> 33:46.520
so the this binding gives you some cool benefits when you want them when you don't want them there's

33:46.520 --> 33:52.120
typically ways to get around having to use it um another way would be calling dot bind on a function

33:52.120 --> 33:58.840
and passing it um the value of the current this um but i'm not going to go into that just uh just

33:58.840 --> 34:06.280
now because i say the end but there's actually one more thing i want to show you guys okay so

34:06.280 --> 34:13.080
here we're going to look at actually um what happens in terms of the heap when we are dealing

34:13.080 --> 34:19.480
with closures so it's a similar function to what we had before we've got an outer we've got a inner

34:19.480 --> 34:26.440
we've got a bar it doesn't really get used and we just call everything at the end so let's run this

34:26.440 --> 34:34.280
guy see what happens okay so we've defined our outer function and actually let me just play through

34:34.280 --> 34:38.600
here what actually happens here something's undefined okay what i'm going to do is i'm going to

34:39.400 --> 34:46.680
every step of the way here i'm going to actually take a snapshot this is a heap snapshot and it

34:46.680 --> 34:49.960
basically goes and tells you what are all the things that have been actually like all the

34:49.960 --> 34:54.280
objects have been put on the heap um at this point in time so i'm going to play forwards i'm

34:54.280 --> 35:00.840
going to take another snapshot i'm going to go again take another snapshot i'm going to go again

35:00.840 --> 35:08.120
take another snapshot and then i'm going to go again i think one more snapshot okay cool now what

35:08.120 --> 35:15.960
i'm going to do is i'm going to in each of these places only show the difference between the current

35:15.960 --> 35:24.440
snapshot and the previous one so make sense okay cool so this is trying to see the difference in

35:24.440 --> 35:34.040
what's been allocated what's been newly allocated between between um one snapshot and the next one

35:34.040 --> 35:40.120
so okay snapshot two let's have a look at what happens inside here so we've got back to our sources

35:40.120 --> 35:47.400
so that's looking at this guy so we create our outer function um okay so we've got a closure being

35:47.400 --> 35:52.440
created here oh interesting so by the time we get to the end of um by the time we get to here

35:53.400 --> 36:00.760
we've created this function and it has a closure object here so this is 124913 uh it's got a context

36:02.040 --> 36:07.960
the preview okay that's got a lot of random stuff there okay so interesting all right let's look at

36:07.960 --> 36:12.840
what snapshot three gives us okay so this is actually this is creating a closure this guy's

36:12.840 --> 36:18.360
creating a context so in v8 this is there's a thing called a context capital c not to be confused

36:18.360 --> 36:28.200
with an execution context and let me really um okay so uh let's see what we're actually creating here

36:28.200 --> 36:34.680
okay so snapshot three that's one two three so at the very beginning when the code enters our

36:34.680 --> 36:42.440
outer function we have already made a context object which is going to store the two things

36:42.440 --> 36:46.120
which are being captured here so bar string and inner string okay let's have a look at this so

36:46.120 --> 36:53.160
bar string is captured by bar down here inner string is captured by inner down here and uncaptured

36:53.160 --> 36:59.240
string is actually not captured by anyone we just define that we don't use it so this is interesting

36:59.240 --> 37:04.280
so as soon as we're here we actually JavaScript clearly goes ahead and before it actually goes

37:04.280 --> 37:08.280
and continues writing the code it goes and says okay here's all the things to get to find in our

37:08.280 --> 37:13.160
scope okay who's going to be using those things who's going to be capturing those things whoever

37:13.160 --> 37:20.040
you know if anyone inside here if any function captures these variables then we need to actually

37:20.040 --> 37:24.280
create a context object and put those variables on that context so here we've got one two five

37:24.360 --> 37:29.880
one one nine okay interesting we move on and here we enter a block now this could this could

37:29.880 --> 37:35.160
have just been like if you know true um but you actually don't need to have that you can actually

37:35.160 --> 37:39.480
just enter a block directly um which is a it's a feature no one uses but i feel like maybe we should

37:39.480 --> 37:44.360
use a bit more um to kind of limit variable scope but at any rate uh it's just here for

37:44.360 --> 37:51.160
demonstration purposes so here we enter the block scope and here we have a block string

37:51.160 --> 37:57.400
which is captured by bar so if i look in my memory on subject four we get another context here okay

37:58.040 --> 38:03.640
and it's not really telling us much right now but it has as its previous context so it's like a

38:03.640 --> 38:10.760
reference to the parent context um the uh same guy was over four one two five one one nine

38:10.760 --> 38:15.240
so that's the same as this guy here and it's got uh both of these strings now have the whole

38:15.240 --> 38:21.160
use by the time we get to this point uh in the code um so yeah funny that we don't have our um

38:22.760 --> 38:27.560
this guy defined um but maybe it's slightly different behavior between functions and

38:28.200 --> 38:34.280
blocks but at any rate let's go to the next snapshot so let's see the next snapshot is

38:34.840 --> 38:40.840
the final one is this guy on the other side of bar okay so now we have a closure so that means

38:40.920 --> 38:47.080
we've got a bar function and it now references this context so one two five three one three

38:47.080 --> 38:55.000
that's the same as this guy and what's inside here okay so now it has funnily enough it has um

38:56.280 --> 39:01.560
you know what the value of this thing is this um block string but doesn't doesn't say what the name

39:01.560 --> 39:08.040
is i don't know why that is maybe it doesn't need it maybe it's going to be minified um but uh at

39:08.040 --> 39:13.160
any rate it's been captured and then here we've got a point into our previous context which has

39:13.160 --> 39:19.960
our other two things that are captured as well so what that tells us is that uh these context

39:19.960 --> 39:27.640
objects exist in a given scope and they whatever variables from that scope get used by uh other

39:27.640 --> 39:32.280
functions in that scope um or like descendant scopes those will be the ones that end up being

39:32.280 --> 39:37.800
added to the context and then um when you actually you know return one of these functions for example

39:39.000 --> 39:41.880
let me go here

39:44.120 --> 39:44.680
and

39:48.280 --> 39:48.920
run that

39:51.160 --> 39:57.000
so right now uh in my scope is that's kind of weird why is F not in here

39:57.240 --> 40:06.200
oh because i haven't right yes very good let's call it a const fresh paste say play

40:10.200 --> 40:14.520
hmm quite the same thing outer

40:18.120 --> 40:21.080
i think it's it's behaving differently because of the fact that

40:22.040 --> 40:27.160
i need to just change the actual source code let's do that start again oh disconnected

40:29.000 --> 40:39.240
and here we go okay that's better cool so now we have um we can see here we've got this closure

40:39.240 --> 40:44.440
i think contains the things we cared about for our inner function it does not contain the closure

40:44.440 --> 40:49.720
that was made for this guy because that's in its own uh block um but uh through this guy

40:49.800 --> 40:55.320
does have access to this closure that was defined right up here it contains um not only

40:55.880 --> 41:00.040
in a string which this guy explicitly captured but also bar string which is something that

41:00.040 --> 41:05.160
captured so um something to keep in mind if you have a huge you know if you've got two functions

41:05.160 --> 41:09.560
closing over a bunch of variables and one of them closes over some huge object and the other one

41:09.560 --> 41:15.560
doesn't but the other one lives on past the lifetime of the parent function then uh you might

41:15.560 --> 41:20.120
be holding onto that object in your in your heap in memory for longer than you want to

41:21.400 --> 41:28.760
but that effectively wraps this up so um hopefully this was a good intro to JavaScript scoping and

41:29.400 --> 41:36.520
how it balances static scoping with dynamic scoping how it supports closures and what actually

41:36.520 --> 41:41.560
happens on the heap when we are dealing with creating closures so yeah thanks for thanks for

41:41.560 --> 41:47.480
watching and um I'll add a link in the description to the original part which goes into some more

41:47.480 --> 41:51.240
detail about what's going on behind the scenes thanks for watching

