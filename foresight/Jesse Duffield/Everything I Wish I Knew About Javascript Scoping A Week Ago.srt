1
00:00:00,000 --> 00:00:07,200
Hi guys, welcome to my video on scoping in JavaScript.

2
00:00:07,200 --> 00:00:14,280
So about a week ago I kind of started a deep dive into how JavaScript really works behind

3
00:00:14,280 --> 00:00:21,180
the scenes and part of that was learning about scoping.

4
00:00:21,180 --> 00:00:26,400
I made a blog post called Everything I Wish I Knew About JavaScript Scoping a Week Here

5
00:00:26,400 --> 00:00:31,240
which kind of goes into details about a lot of these things, but the first kind of chunk

6
00:00:31,240 --> 00:00:36,920
of that is really just about like, you know, var versus let versus const which are keywords

7
00:00:36,920 --> 00:00:41,800
for declaring variables which to be honest, I wasn't really that interested in in the

8
00:00:41,800 --> 00:00:47,760
first place and given that most people just don't use var anymore, I don't know how relevant

9
00:00:47,760 --> 00:00:54,960
it is, but I still think that scoping in general is pretty important to learn about

10
00:00:55,400 --> 00:01:00,320
and I learned some interesting things about static scoping, dynamic scoping and how it

11
00:01:00,320 --> 00:01:03,360
relates to this binding.

12
00:01:03,360 --> 00:01:08,440
So yeah, my plan with this video is to take you through what I learned and I'm going to

13
00:01:08,440 --> 00:01:15,680
try and take an experimental approach where I'm not going to make any claims without having

14
00:01:15,680 --> 00:01:20,880
some way of like backing it up, which is why I've got this, the Chrome Dev Tools open right

15
00:01:20,880 --> 00:01:21,880
now.

16
00:01:21,880 --> 00:01:27,520
We're going to try and understand how JavaScript works by actually observing what it does as

17
00:01:27,520 --> 00:01:29,800
a program runs.

18
00:01:29,800 --> 00:01:35,720
So we're starting with this program here, which basically declares a couple of variables

19
00:01:35,720 --> 00:01:42,600
a and b and then declares this outer function, it itself declares two variables c and d,

20
00:01:42,600 --> 00:01:48,200
then it declares a inner function which itself declares two more variables and then on the

21
00:01:48,200 --> 00:01:51,680
inside here we just console log all four.

22
00:01:51,680 --> 00:01:59,280
So a couple of these get overwritten, a does not get overwritten but c does, so in here

23
00:01:59,280 --> 00:02:05,760
it's called shadowing when you've got a function where another variable is in scope outside

24
00:02:05,760 --> 00:02:08,320
that function but we're kind of overriding its value here.

25
00:02:08,320 --> 00:02:12,240
I mean, we're not overriding the value of this variable, we just have another variable

26
00:02:12,240 --> 00:02:17,080
of the same name and therefore we can't really access this variable.

27
00:02:17,080 --> 00:02:21,640
So we've got this function here, then we just call that function and then we call the

28
00:02:21,640 --> 00:02:22,640
outer function.

29
00:02:22,640 --> 00:02:28,080
So the way the program works is we go here, declare this guy, call this guy, then we go

30
00:02:28,080 --> 00:02:31,680
inside here and declare this guy and then we call it.

31
00:02:31,680 --> 00:02:38,280
So the point here is that we've got kind of nested scoping and we want to see how these

32
00:02:38,280 --> 00:02:39,520
values end up coming out.

33
00:02:39,880 --> 00:02:47,440
So I play this now, console log shows a is one, b is five, c is six and d is four.

34
00:02:47,440 --> 00:02:53,640
So a is one because it gets started here and doesn't get overwritten or shadowed rather.

35
00:02:53,640 --> 00:02:59,720
b starts as two but then over here we've got b is five so we shadow this guy and we just

36
00:02:59,720 --> 00:03:05,400
say okay we've got our own b variable here which is equal to five so we use that.

37
00:03:05,400 --> 00:03:11,160
c is three but then over here it gets shadowed and we get a new c variable whose value is

38
00:03:11,160 --> 00:03:18,800
six so we end up saying c is six and finally d starts as four and does not get shadowed

39
00:03:18,800 --> 00:03:20,080
so it's just four here.

40
00:03:20,080 --> 00:03:25,360
So off the bat we can see that when you have a function declared inside another function

41
00:03:25,360 --> 00:03:31,320
it has access to variables defined outside of its scope whether it's d in the outer function

42
00:03:31,320 --> 00:03:34,400
or a in this global context.

43
00:03:34,840 --> 00:03:40,360
Okay so let's have a look at what's actually happening here but a diagram that I made.

44
00:03:40,360 --> 00:03:47,200
Basically JavaScript runs on an execution stack which is equivalent to a call stack.

45
00:03:47,200 --> 00:03:53,280
At the bottom we've got the global execution context and so each of these little stack

46
00:03:53,280 --> 00:04:00,120
frames is called an execution context so there's a global one at the bottom which is this

47
00:04:00,200 --> 00:04:06,440
thing here this scope here then we've got the outer execution context which would be

48
00:04:07,720 --> 00:04:11,240
everything that happens in here would be happening inside that context and then we've got the inner

49
00:04:11,240 --> 00:04:17,480
one which would be this stuff so what an execution context does is it basically distores

50
00:04:18,120 --> 00:04:22,520
information you need to be able to know where you are at in a function you know what the variables

51
00:04:22,520 --> 00:04:27,800
are that you might be reading from and it's the kind of thing where if you know if you

52
00:04:27,800 --> 00:04:32,120
turn the computer off and turn it back on again and this stack was still here

53
00:04:32,120 --> 00:04:35,080
and almost up to the point or two then you should be able to just continue the program

54
00:04:36,120 --> 00:04:43,160
from where you left off. So we've got our execution context on the execution stack

55
00:04:43,160 --> 00:04:50,200
and each of these points to a I'd say points to you probably more accurately has a reference to

56
00:04:51,160 --> 00:04:57,880
uh lexical environments so uh lexical environments uh when you see the word lexical it basically

57
00:04:57,880 --> 00:05:03,720
means like letters or things you can you can see um in this case we're talking about actual variables

58
00:05:03,720 --> 00:05:10,280
being defined so a lexical environment uh just contains two things it contains an environment

59
00:05:10,280 --> 00:05:17,080
record and a pointer to the parent lexical environment so um uh this happens to be called a

60
00:05:17,160 --> 00:05:21,080
declarative environment record but what an environment record is is is effectively just a

61
00:05:21,080 --> 00:05:26,760
mapping of variables to their values so in the case of our inner function we've got b is five and c

62
00:05:26,760 --> 00:05:31,480
is six so that's these two guys in our outer function we've got c is three and d is four

63
00:05:32,040 --> 00:05:38,840
which are these two guys and then in our global lexical environment we actually have this is kind

64
00:05:38,840 --> 00:05:45,400
of a it's a kind of weird edge case but um we've got a composite environment record consisting of

65
00:05:45,400 --> 00:05:52,840
two things the declarative environment record um for which b is two and we have this other thing

66
00:05:52,840 --> 00:05:58,840
called the object environment record so this is where things kind of get a bit weird um the uh

67
00:05:58,840 --> 00:06:03,960
back in the day basically everything used these object environment records and they would all

68
00:06:03,960 --> 00:06:09,960
have a thing called a binding object which was a literal javascript object that just contained

69
00:06:09,960 --> 00:06:17,160
your variables as properties um it is still the case today that at the global level if you define

70
00:06:17,160 --> 00:06:25,960
a variable with the um the var keyword then it actually ends up just being a property on the

71
00:06:25,960 --> 00:06:30,920
global object um on the other hand if you use let or const it's going to be sitting in this

72
00:06:30,920 --> 00:06:37,000
declarative environment record uh now what's the difference uh first of all uh when you actually

73
00:06:37,000 --> 00:06:41,960
have an object environment record the binding object in this case global just can be accessed by

74
00:06:41,960 --> 00:06:50,200
outside code um and uh it's not very efficient so these declarative ones um are there kind of

75
00:06:50,200 --> 00:06:59,000
internally stored and it's not accessible from the outside um okay so uh the the fact that these

76
00:06:59,000 --> 00:07:04,200
will point to each other allow us to create a scope chain where we can say you know i'm in the inner

77
00:07:04,200 --> 00:07:09,640
function i'm looking for the a variable right now because i want to log it and it's not in my

78
00:07:09,640 --> 00:07:15,160
declarative environment record it's so therefore i'll look to my parent it's not in there either

79
00:07:15,160 --> 00:07:21,240
with my parent oh here it is on the global object so you can get the value of one and then you can

80
00:07:22,120 --> 00:07:31,960
log that value so um it's probably also worth uh noting that um these uh functions when they

81
00:07:32,040 --> 00:07:37,640
created they actually get a eternal internal reference to the scopes that they have access to

82
00:07:37,640 --> 00:07:49,240
so let me go down here and actually gotta refresh the page if i go debugger and then play that okay so

83
00:07:51,080 --> 00:07:56,520
if i look at the inner function you can see here this is just in my dev tools inspector

84
00:07:57,480 --> 00:08:03,400
but in scope i've got my inner function it's got arguments it's got a prototype but it has this

85
00:08:03,400 --> 00:08:09,480
internal thing and these uh internal things are denoted by these double square brackets um this

86
00:08:09,480 --> 00:08:17,400
guy's called scopes and uh in this case uh we've got a few things i've got the value of d from

87
00:08:17,400 --> 00:08:23,240
that outer function the value of b from a script uh anything that's defined at the top level with

88
00:08:23,320 --> 00:08:28,840
let or const is considered to be script scoped um which is not the same as saying is actually

89
00:08:28,840 --> 00:08:32,760
i only scoped to the we're talking about actual script tags here if i go for example

90
00:08:35,800 --> 00:08:42,360
this thing would be a script tag um it's not actually scoped to the script tag it's just

91
00:08:44,680 --> 00:08:48,760
any script will have access to it um and then we've got the global thing here so

92
00:08:49,720 --> 00:08:55,240
we expand this guy we'll see that actually among the many properties of global object one is a

93
00:08:55,240 --> 00:09:03,080
whose value is one so that's this guy here so kind of weird um but also pretty cool so let's move on

94
00:09:03,080 --> 00:09:08,680
and i'm going to go to the next example so in this case we've got an inner and an outer function

95
00:09:08,680 --> 00:09:15,240
but our inner function is actually defined outside the outer function so when this guy's defined um

96
00:09:16,200 --> 00:09:26,040
uh the it references x but the x is actually defined in the uh global execution context

97
00:09:27,000 --> 00:09:34,600
and the um outer function basically when it gets called it goes and creates a its own local

98
00:09:34,600 --> 00:09:42,040
x variable and then it calls inner so the question here is which x will this inner function uh log

99
00:09:42,600 --> 00:09:49,800
um and it turns out that when you run this guy it's going to log one which means logs this thing

100
00:09:50,360 --> 00:09:57,960
so this kind of touches on the difference between static and dynamic scoping in static scoping

101
00:09:57,960 --> 00:10:06,520
when a function is created um any uh variables that references from an outer scope um it looks

102
00:10:06,600 --> 00:10:12,840
at okay like lexically or statically is what's called static scoping or lexical scoping uh what

103
00:10:12,840 --> 00:10:17,240
have i got access to so i can just look on the page here and see okay well there's an x this

104
00:10:17,240 --> 00:10:22,360
in scope here so that's what that's referring to um what actually you know is defined against

105
00:10:22,360 --> 00:10:27,960
a function that might be calling my inner function um it doesn't matter so uh that's called static

106
00:10:27,960 --> 00:10:32,600
scoping um which is to say that we you know you can just statically look at the page and know

107
00:10:33,240 --> 00:10:39,960
uh which variables here are being referenced now you might ask yourself uh isn't this what

108
00:10:39,960 --> 00:10:45,400
every programming language does and actually no it's not so here we have a bash script and

109
00:10:45,400 --> 00:10:51,560
i'm just going to paste this in here so uh in this script we do the exact same thing we define x

110
00:10:51,560 --> 00:10:55,800
we've got an inner function that just logs it an outer function that defines its own x and calls

111
00:10:55,800 --> 00:10:59,880
the inner function and then we call the outer function so we're going to go x is one call the

112
00:10:59,880 --> 00:11:03,880
outer function go in here create x equals two call it inner function and then echo x

113
00:11:04,600 --> 00:11:09,240
press this uh if you play this okay so this actually logs two so what this means is that

114
00:11:10,360 --> 00:11:17,640
bash does not use static scoping it uses dynamic scoping um dynamic scoping is where you care about

115
00:11:17,640 --> 00:11:23,800
what variables are defined at call time um meaning you know at the time this guy's called

116
00:11:23,800 --> 00:11:28,760
we look at okay what's uh what's the value of x so like we're in here we go okay we need the

117
00:11:28,760 --> 00:11:34,840
value of x instead of looking electrically statically up to whatever was defined at the

118
00:11:34,840 --> 00:11:39,800
point when this guy was created in which case x would be one we instead say well who called us

119
00:11:39,800 --> 00:11:44,440
okay well we're being called by outer is there an x defined in this scope yes there is okay let's

120
00:11:44,440 --> 00:11:52,040
log that so um a diagram that explains this discrepancy would be this so let's assume that

121
00:11:52,040 --> 00:11:57,800
bash itself had a concept of lexical environments which it doesn't but if it did um then this is

122
00:11:57,800 --> 00:12:01,320
the difference between how the two would operate so in this case we've got out inner function

123
00:12:02,360 --> 00:12:10,120
doesn't have an x defined so uh in JavaScript we go well you know somehow we know that um

124
00:12:11,320 --> 00:12:15,560
the uh parent lexical environment it's actually the global environment because when this guy was

125
00:12:15,560 --> 00:12:23,960
defined uh i'm just gonna go back when this guy was defined it was uh lexically in scope here

126
00:12:23,960 --> 00:12:29,400
this you know we didn't care about the outer function at the point this was created um so we

127
00:12:29,400 --> 00:12:35,800
go here and find x is one and we log that on the other hand bash just follows the actual stack frame

128
00:12:35,800 --> 00:12:40,600
so it goes okay nothing's defined here okay what about the guy that called me oh it is defined

129
00:12:40,600 --> 00:12:47,160
there okay well i'll return that so um different languages have different approaches to this so

130
00:12:47,240 --> 00:12:53,880
for example in pearl you can have both dynamic or static scoping depending on how you uh declare

131
00:12:53,880 --> 00:12:59,880
your variables um they've got different benefits for different use cases but generally it's

132
00:12:59,880 --> 00:13:05,000
considered that static scoping is superior because it enables uh there are a few reasons

133
00:13:05,000 --> 00:13:13,000
one of which is you can more easily reason about how a function will behave so for example in this

134
00:13:13,000 --> 00:13:17,720
case i don't need to care about you know once i've defined this function i know that this guy's

135
00:13:17,720 --> 00:13:22,120
in scope and so it's referencing that i don't need to worry about whether in some other file

136
00:13:22,120 --> 00:13:30,840
some other function is calling me and um it defines x in its own weird way so to understand

137
00:13:30,840 --> 00:13:35,400
how a single function will work all i need to do is look at the page or look at the files defined

138
00:13:35,400 --> 00:13:40,200
and look at the scope it's defined in and i'll understand um with dynamic scoping you need to

139
00:13:40,200 --> 00:13:45,560
think about all the permutations and understand you know who knows what variables could be set

140
00:13:45,560 --> 00:13:52,920
when i'm being called by some random outer function um dynamic scoping does have uh one benefit

141
00:13:52,920 --> 00:13:59,640
which is that you um don't need to worry about storing variables on the heap so you know assuming

142
00:13:59,640 --> 00:14:04,120
we're talking about primitives like booleans and integers you can just keep everything on the stack

143
00:14:04,120 --> 00:14:10,760
here and as soon as you're done with the function you just you know drop down the stack pointer

144
00:14:10,760 --> 00:14:15,480
throughout the memory when you put a new when you enter a new function you put a new stack frame on

145
00:14:15,480 --> 00:14:21,560
the stack move the pointer up again and uh basically you know whenever you need to look for a variable

146
00:14:21,560 --> 00:14:27,240
you just look down the stack until you find it um in JavaScript we need to kind of have some

147
00:14:27,240 --> 00:14:32,680
additional uh metadata that we hold on to for example to say that you know this inner function

148
00:14:32,680 --> 00:14:38,280
was really defined with this guy in scope we don't you know at the time we didn't care about the

149
00:14:38,280 --> 00:14:43,080
outer function so we need to skip this guy because we've been static scoping you know the fact we

150
00:14:43,080 --> 00:14:47,320
have to store those kinds of references means we can't do it all on the stack it's not as simple as

151
00:14:47,320 --> 00:14:57,160
just looking from top to bottom um but let's continue so there is another way in which static

152
00:14:57,160 --> 00:15:05,960
scoping um helps us and that is in how closures work so uh a closure it kind of has two definitions

153
00:15:05,960 --> 00:15:14,280
the first definition of closure is a function that is paired with um a uh it's paired with this

154
00:15:14,280 --> 00:15:19,480
environment so it's a function the client has knowledge about where it was for example created

155
00:15:19,480 --> 00:15:23,960
and what variables were in scope at that point um there's another definition of closure which is

156
00:15:23,960 --> 00:15:27,720
just referring to the environment part like you know the closure is just the things that are

157
00:15:27,720 --> 00:15:33,880
captured the variables are captured so the two are kind of used interchangeably um but uh that

158
00:15:33,880 --> 00:15:40,600
effectively referring to the same concept um so uh in this case we have a function we we define x

159
00:15:40,600 --> 00:15:46,920
and we have an outer function now um that defines an inner function internally um outer has its own

160
00:15:46,920 --> 00:15:51,960
x whose value is two and uh what happens here is the outer actually returns inner so it returns

161
00:15:51,960 --> 00:15:57,960
a function so in javascript functions are first class which means that you can um pass them in

162
00:15:57,960 --> 00:16:02,280
as arguments to functions and you can also return them from functions so you can treat them like

163
00:16:02,280 --> 00:16:09,720
any other variable um so what's happening here is we're actually uh capturing this uh x value

164
00:16:09,720 --> 00:16:14,280
here and we're capturing this one because lecicle scoping says that we first look at you know what's

165
00:16:14,280 --> 00:16:19,720
the now immediate scope here all the values x okay well we'll just capture that guy um we return

166
00:16:19,720 --> 00:16:26,360
the inner function and then we assign that to this variable foo so we call it outer it returns

167
00:16:26,360 --> 00:16:30,760
inner so now foo's value is inner then we call foo which is the same as calling our inner function

168
00:16:32,040 --> 00:16:34,760
and the question is what does it log so if you run this

169
00:16:40,120 --> 00:16:45,720
we log the value of two so um okay what's interesting about this is that

170
00:16:46,440 --> 00:16:53,240
that this variable two which is defining that outer function um really has no reason to exist

171
00:16:53,960 --> 00:17:00,760
after we uh leave the called outer if not for our inner function we're trying to

172
00:17:00,760 --> 00:17:07,400
capture that variable so I say capture another word will be close over the reason it's called

173
00:17:07,400 --> 00:17:12,920
capture is because we need to hold on to this thing after the lifetime of that outer function

174
00:17:13,880 --> 00:17:17,480
so if we for example we're just storing everything on the stack here

175
00:17:18,040 --> 00:17:23,880
we'd have our outer function we'd have our inner function we'd have uh x equals two happening here

176
00:17:24,520 --> 00:17:29,880
and uh we'd eventually have to pop off the stack and get back to our global execution

177
00:17:29,880 --> 00:17:36,120
context for me down here but once we want to then call our inner function again um we need to have

178
00:17:36,120 --> 00:17:42,920
some way of saying of keeping track of the fact that it uh has this variable x equals two which

179
00:17:42,920 --> 00:17:52,120
isn't actually defined in its scope so um let me grab this diagram so what's happening here is that

180
00:17:52,120 --> 00:17:57,560
by the time we get to foo which is really just a variable pointing it out inner function um

181
00:17:57,560 --> 00:18:01,960
it has nothing to find in the statistical environment and because we use stack scoping it

182
00:18:01,960 --> 00:18:06,920
just so happens that this uh function contained a reference to the electrical environment

183
00:18:07,880 --> 00:18:13,880
of the outer function uh where x equals two and so we can say okay x equals two uh obviously that

184
00:18:13,880 --> 00:18:18,120
also close to the global environment record now if we were if we were using dynamic scoping

185
00:18:19,320 --> 00:18:24,440
what would happen here uh effectively we have a foo function here we'd be calling it in the

186
00:18:24,440 --> 00:18:30,840
global context meaning this guy is in scope and the this guy is not and we'd be going console log x

187
00:18:30,840 --> 00:18:35,160
and we just look down the call stack so foo we don't have it global context we do have it the

188
00:18:35,160 --> 00:18:42,840
value is one um so we'll return one so um effectively dynamic scoping does not support

189
00:18:42,840 --> 00:18:49,480
closures uh unlike static scoping which will allow you to kind of store these guys in memory

190
00:18:49,480 --> 00:18:56,440
somehow and then later on you can access those uh variables and change them or just read from them

191
00:18:57,400 --> 00:19:02,520
um so i'm just gonna start this again just as we can see what's actually happening here so

192
00:19:03,720 --> 00:19:09,160
our foo function is has some scopes and we've got a closure here so it closes up x

193
00:19:10,680 --> 00:19:15,240
then the next one up we've got our script for which x equals one and then the global object so these

194
00:19:15,240 --> 00:19:19,640
two guys are kind of two parts of the composite environment record that happen in the global

195
00:19:19,640 --> 00:19:26,920
execution context um so it's kind of interesting and if i go in here it's effectively the same

196
00:19:26,920 --> 00:19:32,520
thing we have this uh well in this scope here actually now forget about function so just in

197
00:19:32,520 --> 00:19:37,080
this scope um we're trying to console log this thing but access to this closure which we're saying

198
00:19:37,080 --> 00:19:45,400
x equals two that's pretty cool um now uh let's look a little bit deeper into how for example

199
00:19:45,480 --> 00:19:53,480
chrome which uses the v8 engine uh the javascript uh actually goes about uh creating these closures

200
00:19:54,600 --> 00:20:00,440
now this is where we kind of diverge in terms of uh what ecma script says we should be doing

201
00:20:01,000 --> 00:20:07,400
or what it's specifying and how the ecma script is actually implemented so ecma script is the

202
00:20:07,400 --> 00:20:14,200
specification for the javascript language and um different browsers and for example node would

203
00:20:14,200 --> 00:20:18,440
have their own implementations so for example the v8 engine that chrome uses is written in c plus

204
00:20:18,440 --> 00:20:24,520
plus and it kind of compiles javascript on the fly while it runs it and tries to optimize things

205
00:20:24,520 --> 00:20:32,120
as it goes um but as you can imagine the ecma script approach is a little bit um flawed so

206
00:20:32,920 --> 00:20:37,640
you know if you have a bunch of variables defined in a function and only one of them gets captured

207
00:20:37,640 --> 00:20:41,720
by an inner function and then you return from the outer function you don't really want to be

208
00:20:41,720 --> 00:20:48,840
holding on to all of the variables in that electrical environment um past their jup uh their

209
00:20:48,840 --> 00:20:53,800
their expiry date basically because no one's going to use them um if you've only captured one variable

210
00:20:54,600 --> 00:21:01,320
so what we well what v8 does is kind of intelligent but i'm going to show you i'm going to show you

211
00:21:01,320 --> 00:21:06,840
what it does so in this program we've got an outer function we define three different variables x y

212
00:21:06,840 --> 00:21:14,920
and huge so huge let's just pretend this is a really big object and we have our uh we've got one

213
00:21:14,920 --> 00:21:20,520
function here called bar which captures the huge variable so it references that doesn't reference

214
00:21:20,520 --> 00:21:25,080
these two guys though then we have an inner function which captures x but doesn't capture these two

215
00:21:25,080 --> 00:21:29,960
guys and then we return the inner function so bar is defined but doesn't actually get used

216
00:21:31,160 --> 00:21:34,920
on the outside we did the same things before we call our outer function that gives us this

217
00:21:34,920 --> 00:21:41,080
so you sign up for food and then we call food okay so let's have a look at how this actually

218
00:21:41,080 --> 00:21:47,000
works so if i play this now um we've created a foo object so i can have a look in here and it's got

219
00:21:47,000 --> 00:21:55,240
scopes now interestingly uh this guy is now it has a reference to a closure from the outer function

220
00:21:55,240 --> 00:21:59,400
because the outer function is now returned and it actually refers to two different things so it

221
00:21:59,400 --> 00:22:05,320
actually has a reference to x which it explicitly captured but also a huge object now uh it's good

222
00:22:05,320 --> 00:22:09,320
to know that it doesn't have access to the y variable because that would be a waste of memory

223
00:22:09,320 --> 00:22:13,960
because no one actually makes use of that but you know uh what does what does the inner function

224
00:22:13,960 --> 00:22:19,000
care about the huge variable it doesn't make use of it in the case of the x variable so if we continue

225
00:22:19,000 --> 00:22:27,800
again and we look at the actual closure that we have in our outer function um look at that so

226
00:22:28,760 --> 00:22:34,200
we've got both of our things here that were captured so what this tells us is that in the v8

227
00:22:34,200 --> 00:22:42,840
implementation of um closures effectively the way that it works is uh as soon as we probably actually

228
00:22:43,400 --> 00:22:49,480
let me refresh this debugger save oops here we go

229
00:22:52,120 --> 00:23:00,120
debugger oh i did it again okay this time will definitely work it's not only that you have

230
00:23:00,120 --> 00:23:07,640
to do this save play all right so in here um let's have a look so we have debugger

231
00:23:08,200 --> 00:23:15,240
we're being called script global bar you know this okay bar you know so this is just these

232
00:23:15,240 --> 00:23:21,960
guys being hoisted uh as is y finally enough x and y sorry x is huge don't appear in my local

233
00:23:21,960 --> 00:23:30,520
scope i can't see them in the they're not really in a um closure if i continue again

234
00:23:31,240 --> 00:23:37,880
and they appear here interesting so what we'll do is later on i'm going to show

235
00:23:37,880 --> 00:23:42,040
kind of what really happens on the actual heap because the dev chrome tools let you

236
00:23:42,040 --> 00:23:48,040
so chrome dev tools let you actually inspect heap snatch odds um but for now i'm just going to

237
00:23:48,040 --> 00:23:55,080
continue uh and we're going to talk about the this variable okay so um i have said so far that the

238
00:23:55,880 --> 00:24:03,320
uh the JavaScript uses static scoping which is for the most part true but there is one notable

239
00:24:03,320 --> 00:24:08,040
exception and that is the this binding um it's something a variable because it's its value

240
00:24:08,040 --> 00:24:12,440
does not vary once you're inside the scope um it just kind of gets given a variable and that's what

241
00:24:12,440 --> 00:24:21,320
it is um so the way that it works is it's effectively um well i'll show you an example so

242
00:24:21,320 --> 00:24:26,280
here we said x to one then we create an object it's got a couple properties x and a a is a function

243
00:24:26,280 --> 00:24:32,040
that just logs x and um this is really just a demonstration of how things get weird pretty

244
00:24:32,040 --> 00:24:39,400
quick so we have a bar variable um and we're just setting that to the value of object dot a so this

245
00:24:39,400 --> 00:24:43,160
is now going to be this function here and then we also can just call object dot a directly

246
00:24:43,160 --> 00:24:47,320
funnily enough though this gives two different values i've played this get my console one or two

247
00:24:47,320 --> 00:24:52,840
okay bizarre we've got the exact same function but depending on how we call it we get a different

248
00:24:52,840 --> 00:25:01,800
value so in in uh the case of bar we get x and in the case of object dot a we get uh two so what's

249
00:25:01,800 --> 00:25:06,760
going on here so the way that it works is if you have a function and it contains a this binding

250
00:25:07,960 --> 00:25:11,640
the value that's passed in is actually based on the way in which you call that function so

251
00:25:12,440 --> 00:25:16,840
if you just call it directly then it's going to be given the value of the

252
00:25:18,200 --> 00:25:26,040
global object which is basically a object that contains this axis of property um whereas if

253
00:25:26,040 --> 00:25:30,920
you call it so if on the left hand side of these brackets these parentheses you have what is called

254
00:25:30,920 --> 00:25:38,360
a reference type then it's actually going to be given the um the this variable or this binding

255
00:25:38,360 --> 00:25:43,320
will be given the value of the object itself meaning when we try and call the

256
00:25:44,840 --> 00:25:49,880
x property on that it's going to be this guy so what's going on here so a reference type

257
00:25:49,880 --> 00:25:53,640
is basically you can actually check these in brackets and it will still work hang on let me

258
00:25:54,600 --> 00:26:03,560
copy this refresh do that save play same thing same thing yeah so what this actually is is a

259
00:26:04,520 --> 00:26:12,360
it before it evaluates to the actual um uh like function it evaluates to a reference type

260
00:26:12,360 --> 00:26:15,320
and a reference type is just when you have an object and then you're calling some property on

261
00:26:15,320 --> 00:26:19,080
that object so in this case it's object dot a so whatever you do that and then you have the

262
00:26:19,080 --> 00:26:24,840
parentheses here what it means is it'll it'll invoke this function but it will set the this

263
00:26:24,840 --> 00:26:33,160
binding to the value of the actual object strange why would we uh violate static scoping in this way

264
00:26:33,240 --> 00:26:39,560
right when this thing is defined uh it's with that the way you call it as a as opposed to the

265
00:26:39,560 --> 00:26:45,800
way that you create it which is more of a dynamic scoping thing what influences value um and basically

266
00:26:45,800 --> 00:26:52,520
what this enables is um sharing of code so we're going to have two objects here and a foo function

267
00:26:52,520 --> 00:26:58,760
that makes use of the this dot x uh reference you can then assign that to both of these objects

268
00:26:58,760 --> 00:27:02,200
and you can call them and you'll get different values because the different objects contain

269
00:27:02,200 --> 00:27:07,560
different values for x so effectively because function is the first class it would be a shame

270
00:27:07,560 --> 00:27:14,520
if we couldn't actually kind of uh make use of this neat functionality to have kind of uh

271
00:27:15,160 --> 00:27:21,240
genericized logic that can be applied to different objects and different data um there is another

272
00:27:21,240 --> 00:27:28,040
example of how this works which is um when creating prototypes so i'm going to too much detail about

273
00:27:28,040 --> 00:27:34,760
prototypes here but prototypes are effectively the way the javascript enables inheritance so um

274
00:27:34,760 --> 00:27:38,920
we've got a kind of constructor function here and it says okay you give me an object like an empty

275
00:27:38,920 --> 00:27:44,040
object and i'll set x to one on that object and i'll set the blah property to this function

276
00:27:44,040 --> 00:27:50,680
but just console log something and then i can say on here i can set the prototype of this function

277
00:27:50,680 --> 00:27:55,640
which is a fancy way of saying you know when i create an object um from this guy using the the

278
00:27:55,640 --> 00:28:02,120
new keyword um i want this object's prototype to have this additional functionality so in this case

279
00:28:02,120 --> 00:28:08,600
i'm saying i've got a foo property and it has a function that console logs this dot x and if i go

280
00:28:08,600 --> 00:28:15,000
and create my a object i'll get an object that just says x is one and then if i call foo on that um

281
00:28:15,000 --> 00:28:20,680
because i'm making use of the this keyword here um i'll be referencing this x because i'm using a

282
00:28:20,680 --> 00:28:30,040
reference type here so they play this one okay cool so um what this enables is basically inheritance

283
00:28:30,040 --> 00:28:41,480
i can have multiple different objects here i can go b um and i can say a dot prototype equals b dot

284
00:28:41,480 --> 00:28:52,520
prototype and make that two make that ha ha and i can go let's see um i can do object new b

285
00:28:53,320 --> 00:28:57,400
and then there's a b2 and then it should log two so let me just save this

286
00:28:59,240 --> 00:29:05,160
whoops oh no i've lost it oh that's all right i can just do it again so

287
00:29:06,120 --> 00:29:15,960
okay i've got a b constructor by those two this says ha ha i'm going to say

288
00:29:17,160 --> 00:29:22,360
b dot prototype equals a dot prototype and then make this a b it's going to be two

289
00:29:23,240 --> 00:29:29,320
and save and play now it logs two okay cool so what this says is basically we've got two completely

290
00:29:29,320 --> 00:29:34,040
different um constructors here but they both inherit from this same kind of prototype which

291
00:29:34,040 --> 00:29:38,440
has this function on it where we can say just console log this dot x and there you go you can

292
00:29:38,440 --> 00:29:44,600
create uh effectively we've created a taxonomy a and b both inherit from some prototype that

293
00:29:44,600 --> 00:29:51,560
defines a behavior that we can call if the property itself doesn't exist on our base objects so um

294
00:29:51,560 --> 00:29:59,560
through the this binding we basically enable these prototype chains to define um shared behavior

295
00:29:59,560 --> 00:30:08,360
among the descendant objects um so uh pretty cool so this is what i mean so starting scoping on

296
00:30:08,360 --> 00:30:13,640
the whole pretty good but sometimes it is worth it to go for the dynamic approach if it enables

297
00:30:13,640 --> 00:30:19,960
things like in this case sharing code and uh inheritance okay so in this case this is just

298
00:30:19,960 --> 00:30:25,800
an example of where it can get a bit weird and you might want to switch up what you're doing so

299
00:30:25,880 --> 00:30:30,840
here we have a constructor function called foo set x to one and then we say set time out and

300
00:30:30,840 --> 00:30:36,360
then when the time out when a second passes i'm going to console log this dot x okay there we go

301
00:30:36,360 --> 00:30:45,880
f figures new foo so if you run this what's gonna happen one one let's have a look at that um console

302
00:30:46,840 --> 00:30:48,840
x

303
00:30:49,240 --> 00:30:51,880
why is it going one one let's try this again

304
00:30:54,120 --> 00:30:59,000
oh because i hadn't i hadn't cleared my uh console okay good so it's logging undefined

305
00:31:00,120 --> 00:31:04,440
kind of weird it's saying this dot x and this x is one so why would that be happening

306
00:31:04,440 --> 00:31:11,880
the reason is because when we go set time out this guy gets added to our um our event queue

307
00:31:11,880 --> 00:31:16,600
and when it finally gets popped off and gets ran it's ran on the global execution context

308
00:31:16,600 --> 00:31:23,480
meaning it's not being called as you know f dot blah it's just being called directly

309
00:31:25,160 --> 00:31:30,680
that means it gets past the global object as it's this and the global object does not define

310
00:31:30,680 --> 00:31:35,880
ax if it did it would log that so if i go x equals two i think this will work maybe it won't

311
00:31:35,880 --> 00:31:42,360
but let's find out um i'm gonna refresh i'm gonna paste i'm gonna save i'm gonna play

312
00:31:43,320 --> 00:31:48,120
two okay cool so yeah it gets past the global object um so this is kind of weird because

313
00:31:48,920 --> 00:31:53,800
we really wanted to just be able to reference the this this defined you know inside this scope

314
00:31:54,760 --> 00:32:00,360
so what can we do let's go to the next example and what you can do is this is the exact same thing

315
00:32:00,360 --> 00:32:04,200
we've just swapped out our function declaration for a uh lander expression

316
00:32:04,440 --> 00:32:09,880
these are added in the es6 and basically now if you play this

317
00:32:13,240 --> 00:32:19,800
yep one there you go so i had to wait a second um okay so what's the difference here so the

318
00:32:19,800 --> 00:32:25,800
use of the lander expression is really a way of forcing static scoping um when otherwise the this

319
00:32:25,800 --> 00:32:30,360
binding would be making use of dynamic scoping um to demonstrate let's have a look at what it

320
00:32:30,360 --> 00:32:37,080
actually does behind the scenes so if we go to um this babel rebel it shows on the left hand side

321
00:32:37,080 --> 00:32:41,320
this is the exact same thing we have here and we're saying set timeout we're using a lander

322
00:32:41,320 --> 00:32:46,120
function and this is what it actually transpiles to so what we get is inside here we say first of all

323
00:32:46,120 --> 00:32:52,200
let's just keep track of what our disc variable is inside this scope and then it means that when

324
00:32:52,200 --> 00:32:56,520
we create this function here and so see how it's lambda here but it's not lambda here so it's really

325
00:32:56,520 --> 00:33:01,080
just under the hood a regular function what we're doing here isn't it we're now instead of using

326
00:33:01,080 --> 00:33:05,480
this directly because we know this thing is kind of unreliable and there's value changes let's

327
00:33:05,480 --> 00:33:12,600
prefer to this um statically defined this variable and we'll call x on that and so then when we log

328
00:33:12,600 --> 00:33:19,720
that that's how we get this value of one so um effectively what using a lander function does

329
00:33:19,720 --> 00:33:25,880
is it basically forces JavaScript to make use of static scoping by under the hood going and

330
00:33:25,880 --> 00:33:32,600
actually adding a um uh a variable to this classical scope and it means that you're not

331
00:33:32,600 --> 00:33:40,600
worrying about what the value of this is when this guy's actually in vote so um yeah it's cool

332
00:33:40,600 --> 00:33:46,520
so the this binding gives you some cool benefits when you want them when you don't want them there's

333
00:33:46,520 --> 00:33:52,120
typically ways to get around having to use it um another way would be calling dot bind on a function

334
00:33:52,120 --> 00:33:58,840
and passing it um the value of the current this um but i'm not going to go into that just uh just

335
00:33:58,840 --> 00:34:06,280
now because i say the end but there's actually one more thing i want to show you guys okay so

336
00:34:06,280 --> 00:34:13,080
here we're going to look at actually um what happens in terms of the heap when we are dealing

337
00:34:13,080 --> 00:34:19,480
with closures so it's a similar function to what we had before we've got an outer we've got a inner

338
00:34:19,480 --> 00:34:26,440
we've got a bar it doesn't really get used and we just call everything at the end so let's run this

339
00:34:26,440 --> 00:34:34,280
guy see what happens okay so we've defined our outer function and actually let me just play through

340
00:34:34,280 --> 00:34:38,600
here what actually happens here something's undefined okay what i'm going to do is i'm going to

341
00:34:39,400 --> 00:34:46,680
every step of the way here i'm going to actually take a snapshot this is a heap snapshot and it

342
00:34:46,680 --> 00:34:49,960
basically goes and tells you what are all the things that have been actually like all the

343
00:34:49,960 --> 00:34:54,280
objects have been put on the heap um at this point in time so i'm going to play forwards i'm

344
00:34:54,280 --> 00:35:00,840
going to take another snapshot i'm going to go again take another snapshot i'm going to go again

345
00:35:00,840 --> 00:35:08,120
take another snapshot and then i'm going to go again i think one more snapshot okay cool now what

346
00:35:08,120 --> 00:35:15,960
i'm going to do is i'm going to in each of these places only show the difference between the current

347
00:35:15,960 --> 00:35:24,440
snapshot and the previous one so make sense okay cool so this is trying to see the difference in

348
00:35:24,440 --> 00:35:34,040
what's been allocated what's been newly allocated between between um one snapshot and the next one

349
00:35:34,040 --> 00:35:40,120
so okay snapshot two let's have a look at what happens inside here so we've got back to our sources

350
00:35:40,120 --> 00:35:47,400
so that's looking at this guy so we create our outer function um okay so we've got a closure being

351
00:35:47,400 --> 00:35:52,440
created here oh interesting so by the time we get to the end of um by the time we get to here

352
00:35:53,400 --> 00:36:00,760
we've created this function and it has a closure object here so this is 124913 uh it's got a context

353
00:36:02,040 --> 00:36:07,960
the preview okay that's got a lot of random stuff there okay so interesting all right let's look at

354
00:36:07,960 --> 00:36:12,840
what snapshot three gives us okay so this is actually this is creating a closure this guy's

355
00:36:12,840 --> 00:36:18,360
creating a context so in v8 this is there's a thing called a context capital c not to be confused

356
00:36:18,360 --> 00:36:28,200
with an execution context and let me really um okay so uh let's see what we're actually creating here

357
00:36:28,200 --> 00:36:34,680
okay so snapshot three that's one two three so at the very beginning when the code enters our

358
00:36:34,680 --> 00:36:42,440
outer function we have already made a context object which is going to store the two things

359
00:36:42,440 --> 00:36:46,120
which are being captured here so bar string and inner string okay let's have a look at this so

360
00:36:46,120 --> 00:36:53,160
bar string is captured by bar down here inner string is captured by inner down here and uncaptured

361
00:36:53,160 --> 00:36:59,240
string is actually not captured by anyone we just define that we don't use it so this is interesting

362
00:36:59,240 --> 00:37:04,280
so as soon as we're here we actually JavaScript clearly goes ahead and before it actually goes

363
00:37:04,280 --> 00:37:08,280
and continues writing the code it goes and says okay here's all the things to get to find in our

364
00:37:08,280 --> 00:37:13,160
scope okay who's going to be using those things who's going to be capturing those things whoever

365
00:37:13,160 --> 00:37:20,040
you know if anyone inside here if any function captures these variables then we need to actually

366
00:37:20,040 --> 00:37:24,280
create a context object and put those variables on that context so here we've got one two five

367
00:37:24,360 --> 00:37:29,880
one one nine okay interesting we move on and here we enter a block now this could this could

368
00:37:29,880 --> 00:37:35,160
have just been like if you know true um but you actually don't need to have that you can actually

369
00:37:35,160 --> 00:37:39,480
just enter a block directly um which is a it's a feature no one uses but i feel like maybe we should

370
00:37:39,480 --> 00:37:44,360
use a bit more um to kind of limit variable scope but at any rate uh it's just here for

371
00:37:44,360 --> 00:37:51,160
demonstration purposes so here we enter the block scope and here we have a block string

372
00:37:51,160 --> 00:37:57,400
which is captured by bar so if i look in my memory on subject four we get another context here okay

373
00:37:58,040 --> 00:38:03,640
and it's not really telling us much right now but it has as its previous context so it's like a

374
00:38:03,640 --> 00:38:10,760
reference to the parent context um the uh same guy was over four one two five one one nine

375
00:38:10,760 --> 00:38:15,240
so that's the same as this guy here and it's got uh both of these strings now have the whole

376
00:38:15,240 --> 00:38:21,160
use by the time we get to this point uh in the code um so yeah funny that we don't have our um

377
00:38:22,760 --> 00:38:27,560
this guy defined um but maybe it's slightly different behavior between functions and

378
00:38:28,200 --> 00:38:34,280
blocks but at any rate let's go to the next snapshot so let's see the next snapshot is

379
00:38:34,840 --> 00:38:40,840
the final one is this guy on the other side of bar okay so now we have a closure so that means

380
00:38:40,920 --> 00:38:47,080
we've got a bar function and it now references this context so one two five three one three

381
00:38:47,080 --> 00:38:55,000
that's the same as this guy and what's inside here okay so now it has funnily enough it has um

382
00:38:56,280 --> 00:39:01,560
you know what the value of this thing is this um block string but doesn't doesn't say what the name

383
00:39:01,560 --> 00:39:08,040
is i don't know why that is maybe it doesn't need it maybe it's going to be minified um but uh at

384
00:39:08,040 --> 00:39:13,160
any rate it's been captured and then here we've got a point into our previous context which has

385
00:39:13,160 --> 00:39:19,960
our other two things that are captured as well so what that tells us is that uh these context

386
00:39:19,960 --> 00:39:27,640
objects exist in a given scope and they whatever variables from that scope get used by uh other

387
00:39:27,640 --> 00:39:32,280
functions in that scope um or like descendant scopes those will be the ones that end up being

388
00:39:32,280 --> 00:39:37,800
added to the context and then um when you actually you know return one of these functions for example

389
00:39:39,000 --> 00:39:41,880
let me go here

390
00:39:44,120 --> 00:39:44,680
and

391
00:39:48,280 --> 00:39:48,920
run that

392
00:39:51,160 --> 00:39:57,000
so right now uh in my scope is that's kind of weird why is F not in here

393
00:39:57,240 --> 00:40:06,200
oh because i haven't right yes very good let's call it a const fresh paste say play

394
00:40:10,200 --> 00:40:14,520
hmm quite the same thing outer

395
00:40:18,120 --> 00:40:21,080
i think it's it's behaving differently because of the fact that

396
00:40:22,040 --> 00:40:27,160
i need to just change the actual source code let's do that start again oh disconnected

397
00:40:29,000 --> 00:40:39,240
and here we go okay that's better cool so now we have um we can see here we've got this closure

398
00:40:39,240 --> 00:40:44,440
i think contains the things we cared about for our inner function it does not contain the closure

399
00:40:44,440 --> 00:40:49,720
that was made for this guy because that's in its own uh block um but uh through this guy

400
00:40:49,800 --> 00:40:55,320
does have access to this closure that was defined right up here it contains um not only

401
00:40:55,880 --> 00:41:00,040
in a string which this guy explicitly captured but also bar string which is something that

402
00:41:00,040 --> 00:41:05,160
captured so um something to keep in mind if you have a huge you know if you've got two functions

403
00:41:05,160 --> 00:41:09,560
closing over a bunch of variables and one of them closes over some huge object and the other one

404
00:41:09,560 --> 00:41:15,560
doesn't but the other one lives on past the lifetime of the parent function then uh you might

405
00:41:15,560 --> 00:41:20,120
be holding onto that object in your in your heap in memory for longer than you want to

406
00:41:21,400 --> 00:41:28,760
but that effectively wraps this up so um hopefully this was a good intro to JavaScript scoping and

407
00:41:29,400 --> 00:41:36,520
how it balances static scoping with dynamic scoping how it supports closures and what actually

408
00:41:36,520 --> 00:41:41,560
happens on the heap when we are dealing with creating closures so yeah thanks for thanks for

409
00:41:41,560 --> 00:41:47,480
watching and um I'll add a link in the description to the original part which goes into some more

410
00:41:47,480 --> 00:41:51,240
detail about what's going on behind the scenes thanks for watching

