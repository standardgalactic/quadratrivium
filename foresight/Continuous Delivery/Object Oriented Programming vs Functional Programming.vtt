WEBVTT

00:00.000 --> 00:07.560
OO is better than functional. Or is it the other way around? Maybe the next big thing

00:07.560 --> 00:13.080
will be better than both of them. This is one of those arguments that exercises developers,

00:13.080 --> 00:18.040
and they tend to fall into one camp or the other. Either you think that functional programming

00:18.040 --> 00:24.120
is the only sane answer, or OO is the defining approach for complex systems. So what are

00:24.120 --> 00:29.760
the differences, and do they matter? What advantages does language paradigm have to offer?

00:29.760 --> 00:33.480
And have we found all of the paradigms that there are to find?

00:33.480 --> 00:46.360
Hi, I'm Dave Farley of Continuous Delivery. Welcome to my channel. If you haven't already,

00:46.360 --> 00:52.680
please do hit subscribe. And if you enjoyed the video, hit like as well. I'd like to begin by

00:52.680 --> 01:00.560
thanking my sponsors, Harness, Equal Experts, Octopus, and Speckflow. They're all helping us to

01:00.560 --> 01:07.200
grow this channel. So please do check out their links in the description below. Whatever programming

01:07.200 --> 01:13.840
paradigm or technology you pick, a deployment pipeline will improve your workflow. Check out

01:13.840 --> 01:20.080
my new Continuous Delivery Pipelines book on LeanPub, which will help you to get started

01:20.080 --> 01:25.800
building and to build better deployment pipelines. Links in the description again.

01:25.800 --> 01:33.000
In this episode, I want to explore programming paradigms. There's an argument made by Bob

01:33.000 --> 01:39.400
Martin that we've identified all of the paradigms that there are to find. I think that he might be

01:39.400 --> 01:46.720
wrong, but we'll cover that later on. I do, though, like his analysis of the language

01:46.720 --> 01:52.680
paradigms that we currently have. He argues that a programming paradigm works by removing a

01:52.680 --> 02:00.160
freedom of some kind. It constrains us in some way, limiting our options, in ways that tend to help

02:00.160 --> 02:07.760
us to reduce or even avoid some kinds of mistakes. I quite like that description. A good place to

02:07.760 --> 02:13.840
start is how these paradigms arose in the first place. The first languages were unstructured,

02:14.200 --> 02:19.920
paradigm-free. They were general-purpose languages, but this first generation were pretty

02:19.920 --> 02:25.560
unconstrained. They were really like high-level assembler languages in some sense. You could do

02:25.560 --> 02:32.560
anything. The usual way to describe the history of programming languages is as some kind of linear

02:32.560 --> 02:39.240
progression. We started with unstructured languages, invented structure, and then OO came along,

02:39.360 --> 02:46.600
and finally, functional, is the new kid on the block. This is rubbish and completely wrong. In

02:46.600 --> 02:52.760
reality, it was quite a lot messier than that. Grace Hopper wrote the first compiler of any kind

02:52.760 --> 02:59.720
in the early 1950s. Fortran was the first high-level language written in 1957, which is quickly

02:59.720 --> 03:07.920
followed by Lisp in 1958. So languages began with an unstructured language, Fortran, but then the

03:07.920 --> 03:15.000
second language invented was functional, kind of. Fortran was intentionally mathematical. Fortran

03:15.000 --> 03:20.960
was named for formula translator. It was unstructured, but was built on some core concepts

03:20.960 --> 03:26.800
that are common in programming today. Concepts like variable assignment, conditionals, and loops.

03:27.520 --> 03:33.520
COBOL was the next big language written in 1959. It was trying to make programming language more

03:33.520 --> 03:38.720
like natural language and so easier to learn, which I think that most people these days would

03:38.720 --> 03:44.880
consider a mistake for a general purpose language. Lisp was written for researching artificial

03:44.880 --> 03:51.680
intelligence at the time. We'll come back to the functional paradigm that Lisp gave birth to

03:51.680 --> 03:59.680
shortly. So people built most systems in Fortran or COBOL for a while. Lisp was a bit of an outlier

03:59.680 --> 04:05.200
even then, but systems were getting bigger and more complex, so the lack of constraints

04:05.200 --> 04:12.960
meant that there were lots of balls of mud being produced. Dijkstra came along in 1968. He wanted

04:12.960 --> 04:18.560
systems to be mathematically provable, so he said go-to statements are considered harmful

04:19.120 --> 04:25.840
and gave birth to structured programming in 68. Structured programming works by constraining

04:25.840 --> 04:32.720
the flow of transfer of control. You can't just jump to any point in a program as you could in

04:32.720 --> 04:40.000
COBOL or Fortran or Assembler. You are forced to jump to fixed points that are defined, jump to

04:40.000 --> 04:46.880
points in the language, if you like, that we these days call functions or methods. This allows us to

04:46.880 --> 04:53.760
be a bit more cautious at these points. We're forced to assemble arguments and we can check them

04:53.760 --> 05:01.040
for validity if we want to when a call is received. As I said earlier, it's a mistake to see this as

05:01.040 --> 05:08.160
some kind of linear progression of language goodness. While all of this was going on elsewhere in

05:08.160 --> 05:16.800
parallel, OO was being invented. The term OO was invented by Allen Kay in 1966, but the ideas that

05:16.800 --> 05:23.520
led to it were around for a few years before that, even as early as 1961. The first real

05:23.520 --> 05:30.320
OO language was similar, which was created in 1965, but there were earlier attempts.

05:31.120 --> 05:37.760
The radical OO step, though, was small talk in 1972. The OO paradigm is not really what most

05:37.760 --> 05:44.560
people think, though. It's not really about inheritance and why it is about putting data

05:44.560 --> 05:49.680
and behavior together. I think that most OO programmers would say it is much more about

05:49.680 --> 05:58.240
polymorphism. Later, Allen Kay said this, I'm sorry that I long ago coined the term objects for this

05:58.240 --> 06:04.560
topic, because it gets many people to focus on the lesser idea. The big idea is messaging.

06:05.920 --> 06:12.400
I think that what Kay means here is that the real value is that we can send a message to something

06:12.400 --> 06:19.200
and it figures out how to process that message. We can send the same message to two different things

06:19.760 --> 06:25.760
and each of them deals with that same message, but in different ways, ways that make sense to them.

06:26.880 --> 06:34.000
This is polymorphism, really. This is the real power of OO, not inheritance. In fact,

06:34.000 --> 06:42.160
the 1972 version of small talk didn't support inheritance at all. In Bob Martin's model,

06:42.160 --> 06:47.920
this is called dependency management through polymorphism. That's how he characterizes the

06:47.920 --> 06:55.680
OO paradigm. The real value of OO is our ability to modularize our systems and deal

06:55.680 --> 07:01.840
from the outside with different modules in consistent ways. This is polymorphism.

07:03.200 --> 07:07.120
Structured OO and functional aren't the only paradigms.

07:07.200 --> 07:12.800
Logic programming constrains programs to follow the rules of formal logic, for example.

07:12.800 --> 07:18.000
You could argue that machine learning in its current incarnation is a different paradigm

07:18.000 --> 07:23.680
that constrains programmers by allowing them to pick good examples and only define fitness

07:23.680 --> 07:30.880
functions. But let's get back to our topic for today, though. Remember, on the timeline,

07:30.880 --> 07:36.080
kind of weirdly structured programming is historically the last of these paradigms to

07:36.080 --> 07:44.080
turn up. But let's loop back to the current on-point fashion leader, the functional paradigm.

07:45.120 --> 07:50.640
The defining characteristic of functional programming is really that it constrains assignment.

07:51.600 --> 07:57.600
We write code with no side effects. Each function translates its inputs into a new

07:57.600 --> 08:04.160
output, and that's all it does, without changing these inputs in any way, and without relying

08:04.160 --> 08:10.240
on anything but its inputs to achieve its goals. Sometimes functional programmers talk

08:10.240 --> 08:15.840
about this as separating data and function. But if I'm honest, I think that this is probably

08:15.840 --> 08:21.360
so that they can argue with OO programmers who talk about combining data and behavior.

08:22.000 --> 08:28.560
In reality, I like the idea of the constraints. I think that we talk a lot of rubbish about

08:28.560 --> 08:36.160
languages and paradigms. I am probably primarily an OO programmer. That's where I spent most of my

08:36.160 --> 08:42.160
career. But a lot of my thinking was informed by my early programming in assembler languages of

08:42.160 --> 08:47.680
different kinds. An unstructured programming approach, if ever there was one. By shooting

08:47.680 --> 08:53.200
myself in the foot many times when writing assembler programs, I adopted some defensive

08:53.280 --> 08:59.840
habits that I later learned were part functional, part OO, part structured. So that when I learned

08:59.840 --> 09:06.480
more about these ideas, they kind of fit together. And that is what I like about this model of

09:06.480 --> 09:12.320
constraints, because that's exactly how and why I learned these things. I wanted to constrain

09:12.320 --> 09:18.960
the freedom with which I made designs so that I screwed up less often. I adopt programming habits

09:18.960 --> 09:24.880
that limit the degree to which I screw up when I write code. I don't really think of myself as a

09:24.880 --> 09:31.040
language or even a paradigm focused developer. But I like to pick the tools that make sense to me at

09:31.040 --> 09:39.920
the time. Modern languages are mostly a combination of these constraints, rarely pure in concept,

09:39.920 --> 09:46.640
although there are some. I laugh when functional programmers rubbish OO, for example, and then

09:46.640 --> 09:53.600
go on to use collections to implement folds. The degree to which the collections like these make

09:53.600 --> 10:01.520
sense is really applying polymorphism to me and OO idea. The degree to which the data is external

10:01.520 --> 10:07.600
in a list is an implementation detail in this case, as long as we don't change that data.

10:08.880 --> 10:15.440
If I write immutable code in Java or C sharp or any other OO programming language, then I can

10:15.440 --> 10:22.960
justifiably be seen to be writing in a functional style. I used to write C. I used to use ideas

10:22.960 --> 10:29.680
that I now I'd call OO and functional in the design of my code. My language didn't help me much in

10:29.680 --> 10:36.480
those days, in the same way that Java doesn't enforce no assignment when I'm using it. But

10:36.480 --> 10:42.000
it doesn't take a lot of self-discipline to achieve the same results if I want to.

10:42.080 --> 10:49.520
So at the technical level, I think that your choice of paradigm is just that. It's a choice,

10:50.240 --> 10:58.160
and it can be fluid and contextual. Let's be clear, though, you can write crap code in any paradigm,

10:58.160 --> 11:05.920
and you can write great code in any paradigm too. There's no functional good OO bad here.

11:06.400 --> 11:11.840
There's a fashion for each side to rubbish the other. And if I'm honest, I think that that is a

11:11.840 --> 11:18.640
little naive. There are advantages to different paradigms, different advantages for each. As I've

11:18.640 --> 11:24.480
said, I am more of an OO than a functional programmer, so probably somewhat biased. The problem

11:24.480 --> 11:29.840
with this kind of religious war is that people get over emotional. So if I do trample on any of

11:29.840 --> 11:34.560
your sacred cows during the course of this, please do forgive me. There is a social

11:34.800 --> 11:41.680
dimension to all of this, though, and we tend to be too tribal in software development. Broadly,

11:41.680 --> 11:48.080
I think that we could oversimplify the tribes like this. Functional programmers tend to think of

11:48.080 --> 11:55.520
programming as maths. OO programmers tend to think of coding as a problem of modeling. Neither of

11:55.520 --> 12:02.880
these are completely true, but may be a reasonable approximation. So the benefits of a functional

12:03.600 --> 12:09.920
approach are that we can abstract ideas into functions that are always correct. In every

12:09.920 --> 12:18.000
circumstance and so write less code. By excluding or at least constraining assignment, we can create

12:18.000 --> 12:25.280
more stable systems and maybe even prove more provable systems. The benefits of a model based

12:25.280 --> 12:31.760
approach are that we can be guided in our analysis by the problem. I think that this is one of the

12:32.240 --> 12:40.240
advantages that OO has over functional programming. It's that when done well, the code is more

12:40.240 --> 12:46.160
navigable because it's closer to the problem. It allows us to explore the relationships more

12:46.160 --> 12:52.400
clearly and understand the problem in small pieces in a way that is closely related to how we think

12:52.400 --> 13:00.640
about the problem. Human beings are naturally classifiers. This gets us to what seems to me

13:00.720 --> 13:07.680
like an important point. I think OO is more closely aligned with how humans brains work.

13:08.400 --> 13:13.920
I can certainly buy the claim that the more mathematical functional approach is a more

13:13.920 --> 13:21.440
rigorous way to capture an idea. But much as I love maths, it's famously difficult and in

13:21.440 --> 13:28.320
essence an unnatural way of thinking for human brains. We value mathematical thinkers highly

13:28.400 --> 13:34.000
because their skills are so rare. This is so obvious. If I throw a ball to you,

13:35.120 --> 13:39.920
is it easier to catch it or to work out the physics of its flight and predict where it will

13:39.920 --> 13:45.760
land so that you can move to the right place? We don't do the maths when we catch a ball.

13:45.760 --> 13:51.600
If we did, we'd certainly miss the ball. So there's something to be said for ease of

13:51.600 --> 14:02.480
comprehension, clarity of expression, which is clearer, this or this. Even if you are a functional

14:02.480 --> 14:08.400
programmer, I think that you would agree that the second version was easier to read. Sure,

14:08.400 --> 14:14.320
we can argue about the flexibility of folds versus loops and because of the immutability of

14:14.320 --> 14:20.400
functional style, our potential to parallelize the computation of our programs, an argument which I

14:20.400 --> 14:24.560
confess as a developer of high performance systems I'm a bit skeptical about, but the

14:24.560 --> 14:31.280
readability, the comprehensibility of our code matters a lot. Here is a function written in

14:31.280 --> 14:38.320
imperative style, in this case in Java. We're just going to look at a collection of numbers

14:38.320 --> 14:45.520
and form some kind of total. Here is the same function written in Haskell.

14:45.520 --> 14:56.000
In this case, we're going to define the function as a recursive function. The first seems to be a

14:56.000 --> 15:03.360
lot easier to explain to somebody that has never written any code because of this alignment with

15:03.360 --> 15:10.480
the way in which people think about things. You have to access some reasonably complex ideas

15:10.480 --> 15:17.680
like recursion to even start to understand the second example. Yes, the code is shorter,

15:18.240 --> 15:25.120
but that compromises its readability somewhat too. The first is a bit more like catching the ball

15:25.120 --> 15:32.080
than doing the maths. In reality, in Haskell, this sum function is a library function, which

15:32.080 --> 15:40.880
I'm told is apparently implemented like this. I rest my case. I think that the functional

15:40.880 --> 15:47.440
paradigm has a lot to offer. In particular, the idea of limiting side effects is an excellent one,

15:47.440 --> 15:52.880
however you choose to write your programs. I've adopted that style of thinking in my OO code

15:52.880 --> 15:59.360
for a long time now, not eliminating assignment, but certainly limiting it and reducing the side

15:59.360 --> 16:06.800
effects. I confess that I've never tried to write a whole functional system as a pure functional

16:06.800 --> 16:12.480
system, and I'm sure that I would learn a lot if I did, but I think that one of the reasons that

16:12.480 --> 16:17.840
everyone doesn't do functional programming is that it's more difficult to transpose these

16:17.840 --> 16:22.480
ISDs into the kinds of functions in a way that keeps the code readable and navigable.

16:22.720 --> 16:28.400
I said at the beginning that I disagreed somewhat with Bob Martin about whether we have found all of

16:28.400 --> 16:34.880
the programming paradigms. There is another aspect of programs and programming that we can

16:34.880 --> 16:43.600
usefully constrain that has some very interesting properties. That is synchronicity. What if we

16:43.600 --> 16:50.320
constrained our programs to disallow synchronous calls between modules of code? Each component of

16:50.400 --> 16:56.320
each component of the system only communicated with any other by sending a message.

16:57.200 --> 17:04.560
Response is sent in a different message some time later. I'm not talking about

17:04.560 --> 17:12.080
asynchro weights here, which I dislike. More like this. A sends an add item message to B

17:13.040 --> 17:18.720
some time later. B sends an item added message back, saying and confirming the receipt.

17:20.560 --> 17:24.480
Concurrency only allowed at these module boundaries,

17:24.480 --> 17:31.360
no creating threads inside a module. Each module is internally single threaded and so naturally

17:31.360 --> 17:39.120
concurrent. Each module is allowed to be state for or stateless as need arises.

17:40.240 --> 17:45.600
This approach is significantly higher performance than any other approach that I am familiar with,

17:45.600 --> 17:51.200
certainly higher performance than a functional design. Functional systems copy a lot of stuff

17:51.200 --> 17:57.600
to achieve immutability. The best that they can do is clever tricks to pretend that they're copying

17:57.600 --> 18:03.680
things, but actually not moving the bytes around in memory. However clever these tricks are though,

18:04.240 --> 18:10.560
it's still going to add CPU cycles. This is less tightly coupled than OO systems,

18:11.120 --> 18:17.120
this approach of limiting synchronicity that I've described, but it has some properties of

18:17.120 --> 18:24.000
both functional and OO design. It also sounds to me quite a lot closer to the vision that

18:24.000 --> 18:29.680
Alan Kay had back in the 1960s. I wrote about some of these ideas in a thing called the

18:29.680 --> 18:35.520
reactive manifesto. There's a link in the description. If you'd like to hear more about

18:35.520 --> 18:40.160
these kinds of ideas in a future video, do let me know in the comments. Thank you very much for

18:40.160 --> 18:50.160
watching.

