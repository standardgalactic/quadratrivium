{"text": " OO is better than functional. Or is it the other way around? Maybe the next big thing will be better than both of them. This is one of those arguments that exercises developers, and they tend to fall into one camp or the other. Either you think that functional programming is the only sane answer, or OO is the defining approach for complex systems. So what are the differences, and do they matter? What advantages does language paradigm have to offer? And have we found all of the paradigms that there are to find? Hi, I'm Dave Farley of Continuous Delivery. Welcome to my channel. If you haven't already, please do hit subscribe. And if you enjoyed the video, hit like as well. I'd like to begin by thanking my sponsors, Harness, Equal Experts, Octopus, and Speckflow. They're all helping us to grow this channel. So please do check out their links in the description below. Whatever programming paradigm or technology you pick, a deployment pipeline will improve your workflow. Check out my new Continuous Delivery Pipelines book on LeanPub, which will help you to get started building and to build better deployment pipelines. Links in the description again. In this episode, I want to explore programming paradigms. There's an argument made by Bob Martin that we've identified all of the paradigms that there are to find. I think that he might be wrong, but we'll cover that later on. I do, though, like his analysis of the language paradigms that we currently have. He argues that a programming paradigm works by removing a freedom of some kind. It constrains us in some way, limiting our options, in ways that tend to help us to reduce or even avoid some kinds of mistakes. I quite like that description. A good place to start is how these paradigms arose in the first place. The first languages were unstructured, paradigm-free. They were general-purpose languages, but this first generation were pretty unconstrained. They were really like high-level assembler languages in some sense. You could do anything. The usual way to describe the history of programming languages is as some kind of linear progression. We started with unstructured languages, invented structure, and then OO came along, and finally, functional, is the new kid on the block. This is rubbish and completely wrong. In reality, it was quite a lot messier than that. Grace Hopper wrote the first compiler of any kind in the early 1950s. Fortran was the first high-level language written in 1957, which is quickly followed by Lisp in 1958. So languages began with an unstructured language, Fortran, but then the second language invented was functional, kind of. Fortran was intentionally mathematical. Fortran was named for formula translator. It was unstructured, but was built on some core concepts that are common in programming today. Concepts like variable assignment, conditionals, and loops. COBOL was the next big language written in 1959. It was trying to make programming language more like natural language and so easier to learn, which I think that most people these days would consider a mistake for a general purpose language. Lisp was written for researching artificial intelligence at the time. We'll come back to the functional paradigm that Lisp gave birth to shortly. So people built most systems in Fortran or COBOL for a while. Lisp was a bit of an outlier even then, but systems were getting bigger and more complex, so the lack of constraints meant that there were lots of balls of mud being produced. Dijkstra came along in 1968. He wanted systems to be mathematically provable, so he said go-to statements are considered harmful and gave birth to structured programming in 68. Structured programming works by constraining the flow of transfer of control. You can't just jump to any point in a program as you could in COBOL or Fortran or Assembler. You are forced to jump to fixed points that are defined, jump to points in the language, if you like, that we these days call functions or methods. This allows us to be a bit more cautious at these points. We're forced to assemble arguments and we can check them for validity if we want to when a call is received. As I said earlier, it's a mistake to see this as some kind of linear progression of language goodness. While all of this was going on elsewhere in parallel, OO was being invented. The term OO was invented by Allen Kay in 1966, but the ideas that led to it were around for a few years before that, even as early as 1961. The first real OO language was similar, which was created in 1965, but there were earlier attempts. The radical OO step, though, was small talk in 1972. The OO paradigm is not really what most people think, though. It's not really about inheritance and why it is about putting data and behavior together. I think that most OO programmers would say it is much more about polymorphism. Later, Allen Kay said this, I'm sorry that I long ago coined the term objects for this topic, because it gets many people to focus on the lesser idea. The big idea is messaging. I think that what Kay means here is that the real value is that we can send a message to something and it figures out how to process that message. We can send the same message to two different things and each of them deals with that same message, but in different ways, ways that make sense to them. This is polymorphism, really. This is the real power of OO, not inheritance. In fact, the 1972 version of small talk didn't support inheritance at all. In Bob Martin's model, this is called dependency management through polymorphism. That's how he characterizes the OO paradigm. The real value of OO is our ability to modularize our systems and deal from the outside with different modules in consistent ways. This is polymorphism. Structured OO and functional aren't the only paradigms. Logic programming constrains programs to follow the rules of formal logic, for example. You could argue that machine learning in its current incarnation is a different paradigm that constrains programmers by allowing them to pick good examples and only define fitness functions. But let's get back to our topic for today, though. Remember, on the timeline, kind of weirdly structured programming is historically the last of these paradigms to turn up. But let's loop back to the current on-point fashion leader, the functional paradigm. The defining characteristic of functional programming is really that it constrains assignment. We write code with no side effects. Each function translates its inputs into a new output, and that's all it does, without changing these inputs in any way, and without relying on anything but its inputs to achieve its goals. Sometimes functional programmers talk about this as separating data and function. But if I'm honest, I think that this is probably so that they can argue with OO programmers who talk about combining data and behavior. In reality, I like the idea of the constraints. I think that we talk a lot of rubbish about languages and paradigms. I am probably primarily an OO programmer. That's where I spent most of my career. But a lot of my thinking was informed by my early programming in assembler languages of different kinds. An unstructured programming approach, if ever there was one. By shooting myself in the foot many times when writing assembler programs, I adopted some defensive habits that I later learned were part functional, part OO, part structured. So that when I learned more about these ideas, they kind of fit together. And that is what I like about this model of constraints, because that's exactly how and why I learned these things. I wanted to constrain the freedom with which I made designs so that I screwed up less often. I adopt programming habits that limit the degree to which I screw up when I write code. I don't really think of myself as a language or even a paradigm focused developer. But I like to pick the tools that make sense to me at the time. Modern languages are mostly a combination of these constraints, rarely pure in concept, although there are some. I laugh when functional programmers rubbish OO, for example, and then go on to use collections to implement folds. The degree to which the collections like these make sense is really applying polymorphism to me and OO idea. The degree to which the data is external in a list is an implementation detail in this case, as long as we don't change that data. If I write immutable code in Java or C sharp or any other OO programming language, then I can justifiably be seen to be writing in a functional style. I used to write C. I used to use ideas that I now I'd call OO and functional in the design of my code. My language didn't help me much in those days, in the same way that Java doesn't enforce no assignment when I'm using it. But it doesn't take a lot of self-discipline to achieve the same results if I want to. So at the technical level, I think that your choice of paradigm is just that. It's a choice, and it can be fluid and contextual. Let's be clear, though, you can write crap code in any paradigm, and you can write great code in any paradigm too. There's no functional good OO bad here. There's a fashion for each side to rubbish the other. And if I'm honest, I think that that is a little naive. There are advantages to different paradigms, different advantages for each. As I've said, I am more of an OO than a functional programmer, so probably somewhat biased. The problem with this kind of religious war is that people get over emotional. So if I do trample on any of your sacred cows during the course of this, please do forgive me. There is a social dimension to all of this, though, and we tend to be too tribal in software development. Broadly, I think that we could oversimplify the tribes like this. Functional programmers tend to think of programming as maths. OO programmers tend to think of coding as a problem of modeling. Neither of these are completely true, but may be a reasonable approximation. So the benefits of a functional approach are that we can abstract ideas into functions that are always correct. In every circumstance and so write less code. By excluding or at least constraining assignment, we can create more stable systems and maybe even prove more provable systems. The benefits of a model based approach are that we can be guided in our analysis by the problem. I think that this is one of the advantages that OO has over functional programming. It's that when done well, the code is more navigable because it's closer to the problem. It allows us to explore the relationships more clearly and understand the problem in small pieces in a way that is closely related to how we think about the problem. Human beings are naturally classifiers. This gets us to what seems to me like an important point. I think OO is more closely aligned with how humans brains work. I can certainly buy the claim that the more mathematical functional approach is a more rigorous way to capture an idea. But much as I love maths, it's famously difficult and in essence an unnatural way of thinking for human brains. We value mathematical thinkers highly because their skills are so rare. This is so obvious. If I throw a ball to you, is it easier to catch it or to work out the physics of its flight and predict where it will land so that you can move to the right place? We don't do the maths when we catch a ball. If we did, we'd certainly miss the ball. So there's something to be said for ease of comprehension, clarity of expression, which is clearer, this or this. Even if you are a functional programmer, I think that you would agree that the second version was easier to read. Sure, we can argue about the flexibility of folds versus loops and because of the immutability of functional style, our potential to parallelize the computation of our programs, an argument which I confess as a developer of high performance systems I'm a bit skeptical about, but the readability, the comprehensibility of our code matters a lot. Here is a function written in imperative style, in this case in Java. We're just going to look at a collection of numbers and form some kind of total. Here is the same function written in Haskell. In this case, we're going to define the function as a recursive function. The first seems to be a lot easier to explain to somebody that has never written any code because of this alignment with the way in which people think about things. You have to access some reasonably complex ideas like recursion to even start to understand the second example. Yes, the code is shorter, but that compromises its readability somewhat too. The first is a bit more like catching the ball than doing the maths. In reality, in Haskell, this sum function is a library function, which I'm told is apparently implemented like this. I rest my case. I think that the functional paradigm has a lot to offer. In particular, the idea of limiting side effects is an excellent one, however you choose to write your programs. I've adopted that style of thinking in my OO code for a long time now, not eliminating assignment, but certainly limiting it and reducing the side effects. I confess that I've never tried to write a whole functional system as a pure functional system, and I'm sure that I would learn a lot if I did, but I think that one of the reasons that everyone doesn't do functional programming is that it's more difficult to transpose these ISDs into the kinds of functions in a way that keeps the code readable and navigable. I said at the beginning that I disagreed somewhat with Bob Martin about whether we have found all of the programming paradigms. There is another aspect of programs and programming that we can usefully constrain that has some very interesting properties. That is synchronicity. What if we constrained our programs to disallow synchronous calls between modules of code? Each component of each component of the system only communicated with any other by sending a message. Response is sent in a different message some time later. I'm not talking about asynchro weights here, which I dislike. More like this. A sends an add item message to B some time later. B sends an item added message back, saying and confirming the receipt. Concurrency only allowed at these module boundaries, no creating threads inside a module. Each module is internally single threaded and so naturally concurrent. Each module is allowed to be state for or stateless as need arises. This approach is significantly higher performance than any other approach that I am familiar with, certainly higher performance than a functional design. Functional systems copy a lot of stuff to achieve immutability. The best that they can do is clever tricks to pretend that they're copying things, but actually not moving the bytes around in memory. However clever these tricks are though, it's still going to add CPU cycles. This is less tightly coupled than OO systems, this approach of limiting synchronicity that I've described, but it has some properties of both functional and OO design. It also sounds to me quite a lot closer to the vision that Alan Kay had back in the 1960s. I wrote about some of these ideas in a thing called the reactive manifesto. There's a link in the description. If you'd like to hear more about these kinds of ideas in a future video, do let me know in the comments. Thank you very much for watching.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 7.5600000000000005, "text": " OO is better than functional. Or is it the other way around? Maybe the next big thing", "tokens": [50364, 422, 46, 307, 1101, 813, 11745, 13, 1610, 307, 309, 264, 661, 636, 926, 30, 2704, 264, 958, 955, 551, 50742], "temperature": 0.0, "avg_logprob": -0.1339120864868164, "compression_ratio": 1.6261261261261262, "no_speech_prob": 0.12073594331741333}, {"id": 1, "seek": 0, "start": 7.5600000000000005, "end": 13.08, "text": " will be better than both of them. This is one of those arguments that exercises developers,", "tokens": [50742, 486, 312, 1101, 813, 1293, 295, 552, 13, 639, 307, 472, 295, 729, 12869, 300, 11900, 8849, 11, 51018], "temperature": 0.0, "avg_logprob": -0.1339120864868164, "compression_ratio": 1.6261261261261262, "no_speech_prob": 0.12073594331741333}, {"id": 2, "seek": 0, "start": 13.08, "end": 18.04, "text": " and they tend to fall into one camp or the other. Either you think that functional programming", "tokens": [51018, 293, 436, 3928, 281, 2100, 666, 472, 2255, 420, 264, 661, 13, 13746, 291, 519, 300, 11745, 9410, 51266], "temperature": 0.0, "avg_logprob": -0.1339120864868164, "compression_ratio": 1.6261261261261262, "no_speech_prob": 0.12073594331741333}, {"id": 3, "seek": 0, "start": 18.04, "end": 24.12, "text": " is the only sane answer, or OO is the defining approach for complex systems. So what are", "tokens": [51266, 307, 264, 787, 45610, 1867, 11, 420, 422, 46, 307, 264, 17827, 3109, 337, 3997, 3652, 13, 407, 437, 366, 51570], "temperature": 0.0, "avg_logprob": -0.1339120864868164, "compression_ratio": 1.6261261261261262, "no_speech_prob": 0.12073594331741333}, {"id": 4, "seek": 2412, "start": 24.12, "end": 29.76, "text": " the differences, and do they matter? What advantages does language paradigm have to offer?", "tokens": [50364, 264, 7300, 11, 293, 360, 436, 1871, 30, 708, 14906, 775, 2856, 24709, 362, 281, 2626, 30, 50646], "temperature": 0.0, "avg_logprob": -0.21367556254069012, "compression_ratio": 1.5022222222222221, "no_speech_prob": 0.2333095371723175}, {"id": 5, "seek": 2412, "start": 29.76, "end": 33.480000000000004, "text": " And have we found all of the paradigms that there are to find?", "tokens": [50646, 400, 362, 321, 1352, 439, 295, 264, 13480, 328, 2592, 300, 456, 366, 281, 915, 30, 50832], "temperature": 0.0, "avg_logprob": -0.21367556254069012, "compression_ratio": 1.5022222222222221, "no_speech_prob": 0.2333095371723175}, {"id": 6, "seek": 2412, "start": 33.480000000000004, "end": 46.36, "text": " Hi, I'm Dave Farley of Continuous Delivery. Welcome to my channel. If you haven't already,", "tokens": [50832, 2421, 11, 286, 478, 11017, 9067, 3420, 295, 14674, 12549, 5831, 8549, 13, 4027, 281, 452, 2269, 13, 759, 291, 2378, 380, 1217, 11, 51476], "temperature": 0.0, "avg_logprob": -0.21367556254069012, "compression_ratio": 1.5022222222222221, "no_speech_prob": 0.2333095371723175}, {"id": 7, "seek": 2412, "start": 46.36, "end": 52.68000000000001, "text": " please do hit subscribe. And if you enjoyed the video, hit like as well. I'd like to begin by", "tokens": [51476, 1767, 360, 2045, 3022, 13, 400, 498, 291, 4626, 264, 960, 11, 2045, 411, 382, 731, 13, 286, 1116, 411, 281, 1841, 538, 51792], "temperature": 0.0, "avg_logprob": -0.21367556254069012, "compression_ratio": 1.5022222222222221, "no_speech_prob": 0.2333095371723175}, {"id": 8, "seek": 5268, "start": 52.68, "end": 60.56, "text": " thanking my sponsors, Harness, Equal Experts, Octopus, and Speckflow. They're all helping us to", "tokens": [50364, 30830, 452, 22593, 11, 389, 16937, 11, 15624, 304, 12522, 1373, 11, 6788, 23280, 11, 293, 3550, 547, 10565, 13, 814, 434, 439, 4315, 505, 281, 50758], "temperature": 0.0, "avg_logprob": -0.17299390101170803, "compression_ratio": 1.5, "no_speech_prob": 0.07216141372919083}, {"id": 9, "seek": 5268, "start": 60.56, "end": 67.2, "text": " grow this channel. So please do check out their links in the description below. Whatever programming", "tokens": [50758, 1852, 341, 2269, 13, 407, 1767, 360, 1520, 484, 641, 6123, 294, 264, 3855, 2507, 13, 8541, 9410, 51090], "temperature": 0.0, "avg_logprob": -0.17299390101170803, "compression_ratio": 1.5, "no_speech_prob": 0.07216141372919083}, {"id": 10, "seek": 5268, "start": 67.2, "end": 73.84, "text": " paradigm or technology you pick, a deployment pipeline will improve your workflow. Check out", "tokens": [51090, 24709, 420, 2899, 291, 1888, 11, 257, 19317, 15517, 486, 3470, 428, 20993, 13, 6881, 484, 51422], "temperature": 0.0, "avg_logprob": -0.17299390101170803, "compression_ratio": 1.5, "no_speech_prob": 0.07216141372919083}, {"id": 11, "seek": 5268, "start": 73.84, "end": 80.08, "text": " my new Continuous Delivery Pipelines book on LeanPub, which will help you to get started", "tokens": [51422, 452, 777, 14674, 12549, 5831, 8549, 35396, 9173, 1446, 322, 49303, 47, 836, 11, 597, 486, 854, 291, 281, 483, 1409, 51734], "temperature": 0.0, "avg_logprob": -0.17299390101170803, "compression_ratio": 1.5, "no_speech_prob": 0.07216141372919083}, {"id": 12, "seek": 8008, "start": 80.08, "end": 85.8, "text": " building and to build better deployment pipelines. Links in the description again.", "tokens": [50364, 2390, 293, 281, 1322, 1101, 19317, 40168, 13, 37156, 294, 264, 3855, 797, 13, 50650], "temperature": 0.0, "avg_logprob": -0.12270327047868208, "compression_ratio": 1.5454545454545454, "no_speech_prob": 0.030555810779333115}, {"id": 13, "seek": 8008, "start": 85.8, "end": 93.0, "text": " In this episode, I want to explore programming paradigms. There's an argument made by Bob", "tokens": [50650, 682, 341, 3500, 11, 286, 528, 281, 6839, 9410, 13480, 328, 2592, 13, 821, 311, 364, 6770, 1027, 538, 6085, 51010], "temperature": 0.0, "avg_logprob": -0.12270327047868208, "compression_ratio": 1.5454545454545454, "no_speech_prob": 0.030555810779333115}, {"id": 14, "seek": 8008, "start": 93.0, "end": 99.4, "text": " Martin that we've identified all of the paradigms that there are to find. I think that he might be", "tokens": [51010, 9184, 300, 321, 600, 9234, 439, 295, 264, 13480, 328, 2592, 300, 456, 366, 281, 915, 13, 286, 519, 300, 415, 1062, 312, 51330], "temperature": 0.0, "avg_logprob": -0.12270327047868208, "compression_ratio": 1.5454545454545454, "no_speech_prob": 0.030555810779333115}, {"id": 15, "seek": 8008, "start": 99.4, "end": 106.72, "text": " wrong, but we'll cover that later on. I do, though, like his analysis of the language", "tokens": [51330, 2085, 11, 457, 321, 603, 2060, 300, 1780, 322, 13, 286, 360, 11, 1673, 11, 411, 702, 5215, 295, 264, 2856, 51696], "temperature": 0.0, "avg_logprob": -0.12270327047868208, "compression_ratio": 1.5454545454545454, "no_speech_prob": 0.030555810779333115}, {"id": 16, "seek": 10672, "start": 106.72, "end": 112.67999999999999, "text": " paradigms that we currently have. He argues that a programming paradigm works by removing a", "tokens": [50364, 13480, 328, 2592, 300, 321, 4362, 362, 13, 634, 38218, 300, 257, 9410, 24709, 1985, 538, 12720, 257, 50662], "temperature": 0.0, "avg_logprob": -0.10607319292814835, "compression_ratio": 1.6508620689655173, "no_speech_prob": 0.24981847405433655}, {"id": 17, "seek": 10672, "start": 112.67999999999999, "end": 120.16, "text": " freedom of some kind. It constrains us in some way, limiting our options, in ways that tend to help", "tokens": [50662, 5645, 295, 512, 733, 13, 467, 11525, 1292, 505, 294, 512, 636, 11, 22083, 527, 3956, 11, 294, 2098, 300, 3928, 281, 854, 51036], "temperature": 0.0, "avg_logprob": -0.10607319292814835, "compression_ratio": 1.6508620689655173, "no_speech_prob": 0.24981847405433655}, {"id": 18, "seek": 10672, "start": 120.16, "end": 127.75999999999999, "text": " us to reduce or even avoid some kinds of mistakes. I quite like that description. A good place to", "tokens": [51036, 505, 281, 5407, 420, 754, 5042, 512, 3685, 295, 8038, 13, 286, 1596, 411, 300, 3855, 13, 316, 665, 1081, 281, 51416], "temperature": 0.0, "avg_logprob": -0.10607319292814835, "compression_ratio": 1.6508620689655173, "no_speech_prob": 0.24981847405433655}, {"id": 19, "seek": 10672, "start": 127.75999999999999, "end": 133.84, "text": " start is how these paradigms arose in the first place. The first languages were unstructured,", "tokens": [51416, 722, 307, 577, 613, 13480, 328, 2592, 37192, 294, 264, 700, 1081, 13, 440, 700, 8650, 645, 18799, 46847, 11, 51720], "temperature": 0.0, "avg_logprob": -0.10607319292814835, "compression_ratio": 1.6508620689655173, "no_speech_prob": 0.24981847405433655}, {"id": 20, "seek": 13384, "start": 134.20000000000002, "end": 139.92000000000002, "text": " paradigm-free. They were general-purpose languages, but this first generation were pretty", "tokens": [50382, 24709, 12, 10792, 13, 814, 645, 2674, 12, 42601, 8650, 11, 457, 341, 700, 5125, 645, 1238, 50668], "temperature": 0.0, "avg_logprob": -0.157519250757554, "compression_ratio": 1.6493506493506493, "no_speech_prob": 0.003216113429516554}, {"id": 21, "seek": 13384, "start": 139.92000000000002, "end": 145.56, "text": " unconstrained. They were really like high-level assembler languages in some sense. You could do", "tokens": [50668, 35847, 19639, 2001, 13, 814, 645, 534, 411, 1090, 12, 12418, 8438, 1918, 8650, 294, 512, 2020, 13, 509, 727, 360, 50950], "temperature": 0.0, "avg_logprob": -0.157519250757554, "compression_ratio": 1.6493506493506493, "no_speech_prob": 0.003216113429516554}, {"id": 22, "seek": 13384, "start": 145.56, "end": 152.56, "text": " anything. The usual way to describe the history of programming languages is as some kind of linear", "tokens": [50950, 1340, 13, 440, 7713, 636, 281, 6786, 264, 2503, 295, 9410, 8650, 307, 382, 512, 733, 295, 8213, 51300], "temperature": 0.0, "avg_logprob": -0.157519250757554, "compression_ratio": 1.6493506493506493, "no_speech_prob": 0.003216113429516554}, {"id": 23, "seek": 13384, "start": 152.56, "end": 159.24, "text": " progression. We started with unstructured languages, invented structure, and then OO came along,", "tokens": [51300, 18733, 13, 492, 1409, 365, 18799, 46847, 8650, 11, 14479, 3877, 11, 293, 550, 422, 46, 1361, 2051, 11, 51634], "temperature": 0.0, "avg_logprob": -0.157519250757554, "compression_ratio": 1.6493506493506493, "no_speech_prob": 0.003216113429516554}, {"id": 24, "seek": 15924, "start": 159.36, "end": 166.60000000000002, "text": " and finally, functional, is the new kid on the block. This is rubbish and completely wrong. In", "tokens": [50370, 293, 2721, 11, 11745, 11, 307, 264, 777, 1636, 322, 264, 3461, 13, 639, 307, 29978, 293, 2584, 2085, 13, 682, 50732], "temperature": 0.0, "avg_logprob": -0.10506376286142881, "compression_ratio": 1.5461847389558232, "no_speech_prob": 0.007194542791694403}, {"id": 25, "seek": 15924, "start": 166.60000000000002, "end": 172.76000000000002, "text": " reality, it was quite a lot messier than that. Grace Hopper wrote the first compiler of any kind", "tokens": [50732, 4103, 11, 309, 390, 1596, 257, 688, 2082, 811, 813, 300, 13, 15742, 13438, 610, 4114, 264, 700, 31958, 295, 604, 733, 51040], "temperature": 0.0, "avg_logprob": -0.10506376286142881, "compression_ratio": 1.5461847389558232, "no_speech_prob": 0.007194542791694403}, {"id": 26, "seek": 15924, "start": 172.76000000000002, "end": 179.72, "text": " in the early 1950s. Fortran was the first high-level language written in 1957, which is quickly", "tokens": [51040, 294, 264, 2440, 18141, 82, 13, 11002, 4257, 390, 264, 700, 1090, 12, 12418, 2856, 3720, 294, 46256, 11, 597, 307, 2661, 51388], "temperature": 0.0, "avg_logprob": -0.10506376286142881, "compression_ratio": 1.5461847389558232, "no_speech_prob": 0.007194542791694403}, {"id": 27, "seek": 15924, "start": 179.72, "end": 187.92000000000002, "text": " followed by Lisp in 1958. So languages began with an unstructured language, Fortran, but then the", "tokens": [51388, 6263, 538, 441, 7631, 294, 45868, 13, 407, 8650, 4283, 365, 364, 18799, 46847, 2856, 11, 11002, 4257, 11, 457, 550, 264, 51798], "temperature": 0.0, "avg_logprob": -0.10506376286142881, "compression_ratio": 1.5461847389558232, "no_speech_prob": 0.007194542791694403}, {"id": 28, "seek": 18792, "start": 187.92, "end": 195.0, "text": " second language invented was functional, kind of. Fortran was intentionally mathematical. Fortran", "tokens": [50364, 1150, 2856, 14479, 390, 11745, 11, 733, 295, 13, 11002, 4257, 390, 22062, 18894, 13, 11002, 4257, 50718], "temperature": 0.0, "avg_logprob": -0.13764707726168346, "compression_ratio": 1.6297872340425532, "no_speech_prob": 0.00026938531664200127}, {"id": 29, "seek": 18792, "start": 195.0, "end": 200.95999999999998, "text": " was named for formula translator. It was unstructured, but was built on some core concepts", "tokens": [50718, 390, 4926, 337, 8513, 35223, 13, 467, 390, 18799, 46847, 11, 457, 390, 3094, 322, 512, 4965, 10392, 51016], "temperature": 0.0, "avg_logprob": -0.13764707726168346, "compression_ratio": 1.6297872340425532, "no_speech_prob": 0.00026938531664200127}, {"id": 30, "seek": 18792, "start": 200.95999999999998, "end": 206.79999999999998, "text": " that are common in programming today. Concepts like variable assignment, conditionals, and loops.", "tokens": [51016, 300, 366, 2689, 294, 9410, 965, 13, 47482, 82, 411, 7006, 15187, 11, 4188, 1124, 11, 293, 16121, 13, 51308], "temperature": 0.0, "avg_logprob": -0.13764707726168346, "compression_ratio": 1.6297872340425532, "no_speech_prob": 0.00026938531664200127}, {"id": 31, "seek": 18792, "start": 207.51999999999998, "end": 213.51999999999998, "text": " COBOL was the next big language written in 1959. It was trying to make programming language more", "tokens": [51344, 34812, 5046, 390, 264, 958, 955, 2856, 3720, 294, 45608, 13, 467, 390, 1382, 281, 652, 9410, 2856, 544, 51644], "temperature": 0.0, "avg_logprob": -0.13764707726168346, "compression_ratio": 1.6297872340425532, "no_speech_prob": 0.00026938531664200127}, {"id": 32, "seek": 21352, "start": 213.52, "end": 218.72, "text": " like natural language and so easier to learn, which I think that most people these days would", "tokens": [50364, 411, 3303, 2856, 293, 370, 3571, 281, 1466, 11, 597, 286, 519, 300, 881, 561, 613, 1708, 576, 50624], "temperature": 0.0, "avg_logprob": -0.06755986374415708, "compression_ratio": 1.5551020408163265, "no_speech_prob": 0.004515300504863262}, {"id": 33, "seek": 21352, "start": 218.72, "end": 224.88, "text": " consider a mistake for a general purpose language. Lisp was written for researching artificial", "tokens": [50624, 1949, 257, 6146, 337, 257, 2674, 4334, 2856, 13, 441, 7631, 390, 3720, 337, 24176, 11677, 50932], "temperature": 0.0, "avg_logprob": -0.06755986374415708, "compression_ratio": 1.5551020408163265, "no_speech_prob": 0.004515300504863262}, {"id": 34, "seek": 21352, "start": 224.88, "end": 231.68, "text": " intelligence at the time. We'll come back to the functional paradigm that Lisp gave birth to", "tokens": [50932, 7599, 412, 264, 565, 13, 492, 603, 808, 646, 281, 264, 11745, 24709, 300, 441, 7631, 2729, 3965, 281, 51272], "temperature": 0.0, "avg_logprob": -0.06755986374415708, "compression_ratio": 1.5551020408163265, "no_speech_prob": 0.004515300504863262}, {"id": 35, "seek": 21352, "start": 231.68, "end": 239.68, "text": " shortly. So people built most systems in Fortran or COBOL for a while. Lisp was a bit of an outlier", "tokens": [51272, 13392, 13, 407, 561, 3094, 881, 3652, 294, 11002, 4257, 420, 34812, 5046, 337, 257, 1339, 13, 441, 7631, 390, 257, 857, 295, 364, 484, 2753, 51672], "temperature": 0.0, "avg_logprob": -0.06755986374415708, "compression_ratio": 1.5551020408163265, "no_speech_prob": 0.004515300504863262}, {"id": 36, "seek": 23968, "start": 239.68, "end": 245.20000000000002, "text": " even then, but systems were getting bigger and more complex, so the lack of constraints", "tokens": [50364, 754, 550, 11, 457, 3652, 645, 1242, 3801, 293, 544, 3997, 11, 370, 264, 5011, 295, 18491, 50640], "temperature": 0.0, "avg_logprob": -0.09487700462341309, "compression_ratio": 1.6140350877192982, "no_speech_prob": 0.010313174687325954}, {"id": 37, "seek": 23968, "start": 245.20000000000002, "end": 252.96, "text": " meant that there were lots of balls of mud being produced. Dijkstra came along in 1968. He wanted", "tokens": [50640, 4140, 300, 456, 645, 3195, 295, 9803, 295, 8933, 885, 7126, 13, 413, 6940, 19639, 1361, 2051, 294, 29930, 13, 634, 1415, 51028], "temperature": 0.0, "avg_logprob": -0.09487700462341309, "compression_ratio": 1.6140350877192982, "no_speech_prob": 0.010313174687325954}, {"id": 38, "seek": 23968, "start": 252.96, "end": 258.56, "text": " systems to be mathematically provable, so he said go-to statements are considered harmful", "tokens": [51028, 3652, 281, 312, 44003, 1439, 712, 11, 370, 415, 848, 352, 12, 1353, 12363, 366, 4888, 19727, 51308], "temperature": 0.0, "avg_logprob": -0.09487700462341309, "compression_ratio": 1.6140350877192982, "no_speech_prob": 0.010313174687325954}, {"id": 39, "seek": 23968, "start": 259.12, "end": 265.84000000000003, "text": " and gave birth to structured programming in 68. Structured programming works by constraining", "tokens": [51336, 293, 2729, 3965, 281, 18519, 9410, 294, 23317, 13, 745, 46847, 9410, 1985, 538, 11525, 1760, 51672], "temperature": 0.0, "avg_logprob": -0.09487700462341309, "compression_ratio": 1.6140350877192982, "no_speech_prob": 0.010313174687325954}, {"id": 40, "seek": 26584, "start": 265.84, "end": 272.71999999999997, "text": " the flow of transfer of control. You can't just jump to any point in a program as you could in", "tokens": [50364, 264, 3095, 295, 5003, 295, 1969, 13, 509, 393, 380, 445, 3012, 281, 604, 935, 294, 257, 1461, 382, 291, 727, 294, 50708], "temperature": 0.0, "avg_logprob": -0.07746533471710827, "compression_ratio": 1.5967078189300412, "no_speech_prob": 0.0109131233766675}, {"id": 41, "seek": 26584, "start": 272.71999999999997, "end": 280.0, "text": " COBOL or Fortran or Assembler. You are forced to jump to fixed points that are defined, jump to", "tokens": [50708, 34812, 5046, 420, 11002, 4257, 420, 1018, 15750, 1918, 13, 509, 366, 7579, 281, 3012, 281, 6806, 2793, 300, 366, 7642, 11, 3012, 281, 51072], "temperature": 0.0, "avg_logprob": -0.07746533471710827, "compression_ratio": 1.5967078189300412, "no_speech_prob": 0.0109131233766675}, {"id": 42, "seek": 26584, "start": 280.0, "end": 286.88, "text": " points in the language, if you like, that we these days call functions or methods. This allows us to", "tokens": [51072, 2793, 294, 264, 2856, 11, 498, 291, 411, 11, 300, 321, 613, 1708, 818, 6828, 420, 7150, 13, 639, 4045, 505, 281, 51416], "temperature": 0.0, "avg_logprob": -0.07746533471710827, "compression_ratio": 1.5967078189300412, "no_speech_prob": 0.0109131233766675}, {"id": 43, "seek": 26584, "start": 286.88, "end": 293.76, "text": " be a bit more cautious at these points. We're forced to assemble arguments and we can check them", "tokens": [51416, 312, 257, 857, 544, 25278, 412, 613, 2793, 13, 492, 434, 7579, 281, 22364, 12869, 293, 321, 393, 1520, 552, 51760], "temperature": 0.0, "avg_logprob": -0.07746533471710827, "compression_ratio": 1.5967078189300412, "no_speech_prob": 0.0109131233766675}, {"id": 44, "seek": 29376, "start": 293.76, "end": 301.03999999999996, "text": " for validity if we want to when a call is received. As I said earlier, it's a mistake to see this as", "tokens": [50364, 337, 40943, 498, 321, 528, 281, 562, 257, 818, 307, 4613, 13, 1018, 286, 848, 3071, 11, 309, 311, 257, 6146, 281, 536, 341, 382, 50728], "temperature": 0.0, "avg_logprob": -0.08848625183105469, "compression_ratio": 1.4558823529411764, "no_speech_prob": 0.0037146469112485647}, {"id": 45, "seek": 29376, "start": 301.03999999999996, "end": 308.15999999999997, "text": " some kind of linear progression of language goodness. While all of this was going on elsewhere in", "tokens": [50728, 512, 733, 295, 8213, 18733, 295, 2856, 8387, 13, 3987, 439, 295, 341, 390, 516, 322, 14517, 294, 51084], "temperature": 0.0, "avg_logprob": -0.08848625183105469, "compression_ratio": 1.4558823529411764, "no_speech_prob": 0.0037146469112485647}, {"id": 46, "seek": 29376, "start": 308.15999999999997, "end": 316.8, "text": " parallel, OO was being invented. The term OO was invented by Allen Kay in 1966, but the ideas that", "tokens": [51084, 8952, 11, 422, 46, 390, 885, 14479, 13, 440, 1433, 422, 46, 390, 14479, 538, 17160, 14179, 294, 39157, 11, 457, 264, 3487, 300, 51516], "temperature": 0.0, "avg_logprob": -0.08848625183105469, "compression_ratio": 1.4558823529411764, "no_speech_prob": 0.0037146469112485647}, {"id": 47, "seek": 31680, "start": 316.8, "end": 323.52000000000004, "text": " led to it were around for a few years before that, even as early as 1961. The first real", "tokens": [50364, 4684, 281, 309, 645, 926, 337, 257, 1326, 924, 949, 300, 11, 754, 382, 2440, 382, 41720, 13, 440, 700, 957, 50700], "temperature": 0.0, "avg_logprob": -0.07949363390604655, "compression_ratio": 1.5570175438596492, "no_speech_prob": 0.09235764294862747}, {"id": 48, "seek": 31680, "start": 323.52000000000004, "end": 330.32, "text": " OO language was similar, which was created in 1965, but there were earlier attempts.", "tokens": [50700, 422, 46, 2856, 390, 2531, 11, 597, 390, 2942, 294, 33809, 11, 457, 456, 645, 3071, 15257, 13, 51040], "temperature": 0.0, "avg_logprob": -0.07949363390604655, "compression_ratio": 1.5570175438596492, "no_speech_prob": 0.09235764294862747}, {"id": 49, "seek": 31680, "start": 331.12, "end": 337.76, "text": " The radical OO step, though, was small talk in 1972. The OO paradigm is not really what most", "tokens": [51080, 440, 12001, 422, 46, 1823, 11, 1673, 11, 390, 1359, 751, 294, 32952, 13, 440, 422, 46, 24709, 307, 406, 534, 437, 881, 51412], "temperature": 0.0, "avg_logprob": -0.07949363390604655, "compression_ratio": 1.5570175438596492, "no_speech_prob": 0.09235764294862747}, {"id": 50, "seek": 31680, "start": 337.76, "end": 344.56, "text": " people think, though. It's not really about inheritance and why it is about putting data", "tokens": [51412, 561, 519, 11, 1673, 13, 467, 311, 406, 534, 466, 32122, 293, 983, 309, 307, 466, 3372, 1412, 51752], "temperature": 0.0, "avg_logprob": -0.07949363390604655, "compression_ratio": 1.5570175438596492, "no_speech_prob": 0.09235764294862747}, {"id": 51, "seek": 34456, "start": 344.56, "end": 349.68, "text": " and behavior together. I think that most OO programmers would say it is much more about", "tokens": [50364, 293, 5223, 1214, 13, 286, 519, 300, 881, 422, 46, 41504, 576, 584, 309, 307, 709, 544, 466, 50620], "temperature": 0.0, "avg_logprob": -0.05696916580200195, "compression_ratio": 1.5815899581589958, "no_speech_prob": 0.007063732482492924}, {"id": 52, "seek": 34456, "start": 349.68, "end": 358.24, "text": " polymorphism. Later, Allen Kay said this, I'm sorry that I long ago coined the term objects for this", "tokens": [50620, 6754, 76, 18191, 1434, 13, 11965, 11, 17160, 14179, 848, 341, 11, 286, 478, 2597, 300, 286, 938, 2057, 45222, 264, 1433, 6565, 337, 341, 51048], "temperature": 0.0, "avg_logprob": -0.05696916580200195, "compression_ratio": 1.5815899581589958, "no_speech_prob": 0.007063732482492924}, {"id": 53, "seek": 34456, "start": 358.24, "end": 364.56, "text": " topic, because it gets many people to focus on the lesser idea. The big idea is messaging.", "tokens": [51048, 4829, 11, 570, 309, 2170, 867, 561, 281, 1879, 322, 264, 22043, 1558, 13, 440, 955, 1558, 307, 21812, 13, 51364], "temperature": 0.0, "avg_logprob": -0.05696916580200195, "compression_ratio": 1.5815899581589958, "no_speech_prob": 0.007063732482492924}, {"id": 54, "seek": 34456, "start": 365.92, "end": 372.4, "text": " I think that what Kay means here is that the real value is that we can send a message to something", "tokens": [51432, 286, 519, 300, 437, 14179, 1355, 510, 307, 300, 264, 957, 2158, 307, 300, 321, 393, 2845, 257, 3636, 281, 746, 51756], "temperature": 0.0, "avg_logprob": -0.05696916580200195, "compression_ratio": 1.5815899581589958, "no_speech_prob": 0.007063732482492924}, {"id": 55, "seek": 37240, "start": 372.4, "end": 379.2, "text": " and it figures out how to process that message. We can send the same message to two different things", "tokens": [50364, 293, 309, 9624, 484, 577, 281, 1399, 300, 3636, 13, 492, 393, 2845, 264, 912, 3636, 281, 732, 819, 721, 50704], "temperature": 0.0, "avg_logprob": -0.061438831530119246, "compression_ratio": 1.609442060085837, "no_speech_prob": 0.0001558419899083674}, {"id": 56, "seek": 37240, "start": 379.76, "end": 385.76, "text": " and each of them deals with that same message, but in different ways, ways that make sense to them.", "tokens": [50732, 293, 1184, 295, 552, 11215, 365, 300, 912, 3636, 11, 457, 294, 819, 2098, 11, 2098, 300, 652, 2020, 281, 552, 13, 51032], "temperature": 0.0, "avg_logprob": -0.061438831530119246, "compression_ratio": 1.609442060085837, "no_speech_prob": 0.0001558419899083674}, {"id": 57, "seek": 37240, "start": 386.88, "end": 394.0, "text": " This is polymorphism, really. This is the real power of OO, not inheritance. In fact,", "tokens": [51088, 639, 307, 6754, 76, 18191, 1434, 11, 534, 13, 639, 307, 264, 957, 1347, 295, 422, 46, 11, 406, 32122, 13, 682, 1186, 11, 51444], "temperature": 0.0, "avg_logprob": -0.061438831530119246, "compression_ratio": 1.609442060085837, "no_speech_prob": 0.0001558419899083674}, {"id": 58, "seek": 37240, "start": 394.0, "end": 402.15999999999997, "text": " the 1972 version of small talk didn't support inheritance at all. In Bob Martin's model,", "tokens": [51444, 264, 32952, 3037, 295, 1359, 751, 994, 380, 1406, 32122, 412, 439, 13, 682, 6085, 9184, 311, 2316, 11, 51852], "temperature": 0.0, "avg_logprob": -0.061438831530119246, "compression_ratio": 1.609442060085837, "no_speech_prob": 0.0001558419899083674}, {"id": 59, "seek": 40216, "start": 402.16, "end": 407.92, "text": " this is called dependency management through polymorphism. That's how he characterizes the", "tokens": [50364, 341, 307, 1219, 33621, 4592, 807, 6754, 76, 18191, 1434, 13, 663, 311, 577, 415, 2517, 5660, 264, 50652], "temperature": 0.0, "avg_logprob": -0.07147871693478355, "compression_ratio": 1.56, "no_speech_prob": 0.0004161463584750891}, {"id": 60, "seek": 40216, "start": 407.92, "end": 415.68, "text": " OO paradigm. The real value of OO is our ability to modularize our systems and deal", "tokens": [50652, 422, 46, 24709, 13, 440, 957, 2158, 295, 422, 46, 307, 527, 3485, 281, 31111, 1125, 527, 3652, 293, 2028, 51040], "temperature": 0.0, "avg_logprob": -0.07147871693478355, "compression_ratio": 1.56, "no_speech_prob": 0.0004161463584750891}, {"id": 61, "seek": 40216, "start": 415.68, "end": 421.84000000000003, "text": " from the outside with different modules in consistent ways. This is polymorphism.", "tokens": [51040, 490, 264, 2380, 365, 819, 16679, 294, 8398, 2098, 13, 639, 307, 6754, 76, 18191, 1434, 13, 51348], "temperature": 0.0, "avg_logprob": -0.07147871693478355, "compression_ratio": 1.56, "no_speech_prob": 0.0004161463584750891}, {"id": 62, "seek": 40216, "start": 423.20000000000005, "end": 427.12, "text": " Structured OO and functional aren't the only paradigms.", "tokens": [51416, 745, 46847, 422, 46, 293, 11745, 3212, 380, 264, 787, 13480, 328, 2592, 13, 51612], "temperature": 0.0, "avg_logprob": -0.07147871693478355, "compression_ratio": 1.56, "no_speech_prob": 0.0004161463584750891}, {"id": 63, "seek": 42712, "start": 427.2, "end": 432.8, "text": " Logic programming constrains programs to follow the rules of formal logic, for example.", "tokens": [50368, 49898, 9410, 11525, 1292, 4268, 281, 1524, 264, 4474, 295, 9860, 9952, 11, 337, 1365, 13, 50648], "temperature": 0.0, "avg_logprob": -0.08771658456453713, "compression_ratio": 1.6806083650190113, "no_speech_prob": 0.0014543933793902397}, {"id": 64, "seek": 42712, "start": 432.8, "end": 438.0, "text": " You could argue that machine learning in its current incarnation is a different paradigm", "tokens": [50648, 509, 727, 9695, 300, 3479, 2539, 294, 1080, 2190, 49988, 307, 257, 819, 24709, 50908], "temperature": 0.0, "avg_logprob": -0.08771658456453713, "compression_ratio": 1.6806083650190113, "no_speech_prob": 0.0014543933793902397}, {"id": 65, "seek": 42712, "start": 438.0, "end": 443.68, "text": " that constrains programmers by allowing them to pick good examples and only define fitness", "tokens": [50908, 300, 11525, 1292, 41504, 538, 8293, 552, 281, 1888, 665, 5110, 293, 787, 6964, 15303, 51192], "temperature": 0.0, "avg_logprob": -0.08771658456453713, "compression_ratio": 1.6806083650190113, "no_speech_prob": 0.0014543933793902397}, {"id": 66, "seek": 42712, "start": 443.68, "end": 450.88, "text": " functions. But let's get back to our topic for today, though. Remember, on the timeline,", "tokens": [51192, 6828, 13, 583, 718, 311, 483, 646, 281, 527, 4829, 337, 965, 11, 1673, 13, 5459, 11, 322, 264, 12933, 11, 51552], "temperature": 0.0, "avg_logprob": -0.08771658456453713, "compression_ratio": 1.6806083650190113, "no_speech_prob": 0.0014543933793902397}, {"id": 67, "seek": 42712, "start": 450.88, "end": 456.08, "text": " kind of weirdly structured programming is historically the last of these paradigms to", "tokens": [51552, 733, 295, 48931, 18519, 9410, 307, 16180, 264, 1036, 295, 613, 13480, 328, 2592, 281, 51812], "temperature": 0.0, "avg_logprob": -0.08771658456453713, "compression_ratio": 1.6806083650190113, "no_speech_prob": 0.0014543933793902397}, {"id": 68, "seek": 45608, "start": 456.08, "end": 464.08, "text": " turn up. But let's loop back to the current on-point fashion leader, the functional paradigm.", "tokens": [50364, 1261, 493, 13, 583, 718, 311, 6367, 646, 281, 264, 2190, 322, 12, 6053, 6700, 5263, 11, 264, 11745, 24709, 13, 50764], "temperature": 0.0, "avg_logprob": -0.08296068803763684, "compression_ratio": 1.6079295154185023, "no_speech_prob": 0.0008039181120693684}, {"id": 69, "seek": 45608, "start": 465.12, "end": 470.64, "text": " The defining characteristic of functional programming is really that it constrains assignment.", "tokens": [50816, 440, 17827, 16282, 295, 11745, 9410, 307, 534, 300, 309, 11525, 1292, 15187, 13, 51092], "temperature": 0.0, "avg_logprob": -0.08296068803763684, "compression_ratio": 1.6079295154185023, "no_speech_prob": 0.0008039181120693684}, {"id": 70, "seek": 45608, "start": 471.59999999999997, "end": 477.59999999999997, "text": " We write code with no side effects. Each function translates its inputs into a new", "tokens": [51140, 492, 2464, 3089, 365, 572, 1252, 5065, 13, 6947, 2445, 28468, 1080, 15743, 666, 257, 777, 51440], "temperature": 0.0, "avg_logprob": -0.08296068803763684, "compression_ratio": 1.6079295154185023, "no_speech_prob": 0.0008039181120693684}, {"id": 71, "seek": 45608, "start": 477.59999999999997, "end": 484.15999999999997, "text": " output, and that's all it does, without changing these inputs in any way, and without relying", "tokens": [51440, 5598, 11, 293, 300, 311, 439, 309, 775, 11, 1553, 4473, 613, 15743, 294, 604, 636, 11, 293, 1553, 24140, 51768], "temperature": 0.0, "avg_logprob": -0.08296068803763684, "compression_ratio": 1.6079295154185023, "no_speech_prob": 0.0008039181120693684}, {"id": 72, "seek": 48416, "start": 484.16, "end": 490.24, "text": " on anything but its inputs to achieve its goals. Sometimes functional programmers talk", "tokens": [50364, 322, 1340, 457, 1080, 15743, 281, 4584, 1080, 5493, 13, 4803, 11745, 41504, 751, 50668], "temperature": 0.0, "avg_logprob": -0.06350320722998642, "compression_ratio": 1.6651162790697673, "no_speech_prob": 0.001672849990427494}, {"id": 73, "seek": 48416, "start": 490.24, "end": 495.84000000000003, "text": " about this as separating data and function. But if I'm honest, I think that this is probably", "tokens": [50668, 466, 341, 382, 29279, 1412, 293, 2445, 13, 583, 498, 286, 478, 3245, 11, 286, 519, 300, 341, 307, 1391, 50948], "temperature": 0.0, "avg_logprob": -0.06350320722998642, "compression_ratio": 1.6651162790697673, "no_speech_prob": 0.001672849990427494}, {"id": 74, "seek": 48416, "start": 495.84000000000003, "end": 501.36, "text": " so that they can argue with OO programmers who talk about combining data and behavior.", "tokens": [50948, 370, 300, 436, 393, 9695, 365, 422, 46, 41504, 567, 751, 466, 21928, 1412, 293, 5223, 13, 51224], "temperature": 0.0, "avg_logprob": -0.06350320722998642, "compression_ratio": 1.6651162790697673, "no_speech_prob": 0.001672849990427494}, {"id": 75, "seek": 48416, "start": 502.0, "end": 508.56, "text": " In reality, I like the idea of the constraints. I think that we talk a lot of rubbish about", "tokens": [51256, 682, 4103, 11, 286, 411, 264, 1558, 295, 264, 18491, 13, 286, 519, 300, 321, 751, 257, 688, 295, 29978, 466, 51584], "temperature": 0.0, "avg_logprob": -0.06350320722998642, "compression_ratio": 1.6651162790697673, "no_speech_prob": 0.001672849990427494}, {"id": 76, "seek": 50856, "start": 508.56, "end": 516.16, "text": " languages and paradigms. I am probably primarily an OO programmer. That's where I spent most of my", "tokens": [50364, 8650, 293, 13480, 328, 2592, 13, 286, 669, 1391, 10029, 364, 422, 46, 32116, 13, 663, 311, 689, 286, 4418, 881, 295, 452, 50744], "temperature": 0.0, "avg_logprob": -0.07078626857084387, "compression_ratio": 1.617391304347826, "no_speech_prob": 0.06634530425071716}, {"id": 77, "seek": 50856, "start": 516.16, "end": 522.16, "text": " career. But a lot of my thinking was informed by my early programming in assembler languages of", "tokens": [50744, 3988, 13, 583, 257, 688, 295, 452, 1953, 390, 11740, 538, 452, 2440, 9410, 294, 8438, 1918, 8650, 295, 51044], "temperature": 0.0, "avg_logprob": -0.07078626857084387, "compression_ratio": 1.617391304347826, "no_speech_prob": 0.06634530425071716}, {"id": 78, "seek": 50856, "start": 522.16, "end": 527.68, "text": " different kinds. An unstructured programming approach, if ever there was one. By shooting", "tokens": [51044, 819, 3685, 13, 1107, 18799, 46847, 9410, 3109, 11, 498, 1562, 456, 390, 472, 13, 3146, 5942, 51320], "temperature": 0.0, "avg_logprob": -0.07078626857084387, "compression_ratio": 1.617391304347826, "no_speech_prob": 0.06634530425071716}, {"id": 79, "seek": 50856, "start": 527.68, "end": 533.2, "text": " myself in the foot many times when writing assembler programs, I adopted some defensive", "tokens": [51320, 2059, 294, 264, 2671, 867, 1413, 562, 3579, 8438, 1918, 4268, 11, 286, 12175, 512, 16468, 51596], "temperature": 0.0, "avg_logprob": -0.07078626857084387, "compression_ratio": 1.617391304347826, "no_speech_prob": 0.06634530425071716}, {"id": 80, "seek": 53320, "start": 533.2800000000001, "end": 539.84, "text": " habits that I later learned were part functional, part OO, part structured. So that when I learned", "tokens": [50368, 14100, 300, 286, 1780, 3264, 645, 644, 11745, 11, 644, 422, 46, 11, 644, 18519, 13, 407, 300, 562, 286, 3264, 50696], "temperature": 0.0, "avg_logprob": -0.0741330729590522, "compression_ratio": 1.6594827586206897, "no_speech_prob": 0.07793629169464111}, {"id": 81, "seek": 53320, "start": 539.84, "end": 546.48, "text": " more about these ideas, they kind of fit together. And that is what I like about this model of", "tokens": [50696, 544, 466, 613, 3487, 11, 436, 733, 295, 3318, 1214, 13, 400, 300, 307, 437, 286, 411, 466, 341, 2316, 295, 51028], "temperature": 0.0, "avg_logprob": -0.0741330729590522, "compression_ratio": 1.6594827586206897, "no_speech_prob": 0.07793629169464111}, {"id": 82, "seek": 53320, "start": 546.48, "end": 552.32, "text": " constraints, because that's exactly how and why I learned these things. I wanted to constrain", "tokens": [51028, 18491, 11, 570, 300, 311, 2293, 577, 293, 983, 286, 3264, 613, 721, 13, 286, 1415, 281, 1817, 7146, 51320], "temperature": 0.0, "avg_logprob": -0.0741330729590522, "compression_ratio": 1.6594827586206897, "no_speech_prob": 0.07793629169464111}, {"id": 83, "seek": 53320, "start": 552.32, "end": 558.96, "text": " the freedom with which I made designs so that I screwed up less often. I adopt programming habits", "tokens": [51320, 264, 5645, 365, 597, 286, 1027, 11347, 370, 300, 286, 20331, 493, 1570, 2049, 13, 286, 6878, 9410, 14100, 51652], "temperature": 0.0, "avg_logprob": -0.0741330729590522, "compression_ratio": 1.6594827586206897, "no_speech_prob": 0.07793629169464111}, {"id": 84, "seek": 55896, "start": 558.96, "end": 564.88, "text": " that limit the degree to which I screw up when I write code. I don't really think of myself as a", "tokens": [50364, 300, 4948, 264, 4314, 281, 597, 286, 5630, 493, 562, 286, 2464, 3089, 13, 286, 500, 380, 534, 519, 295, 2059, 382, 257, 50660], "temperature": 0.0, "avg_logprob": -0.08089748843685611, "compression_ratio": 1.56, "no_speech_prob": 0.008164279162883759}, {"id": 85, "seek": 55896, "start": 564.88, "end": 571.0400000000001, "text": " language or even a paradigm focused developer. But I like to pick the tools that make sense to me at", "tokens": [50660, 2856, 420, 754, 257, 24709, 5178, 10754, 13, 583, 286, 411, 281, 1888, 264, 3873, 300, 652, 2020, 281, 385, 412, 50968], "temperature": 0.0, "avg_logprob": -0.08089748843685611, "compression_ratio": 1.56, "no_speech_prob": 0.008164279162883759}, {"id": 86, "seek": 55896, "start": 571.0400000000001, "end": 579.9200000000001, "text": " the time. Modern languages are mostly a combination of these constraints, rarely pure in concept,", "tokens": [50968, 264, 565, 13, 19814, 8650, 366, 5240, 257, 6562, 295, 613, 18491, 11, 13752, 6075, 294, 3410, 11, 51412], "temperature": 0.0, "avg_logprob": -0.08089748843685611, "compression_ratio": 1.56, "no_speech_prob": 0.008164279162883759}, {"id": 87, "seek": 55896, "start": 579.9200000000001, "end": 586.64, "text": " although there are some. I laugh when functional programmers rubbish OO, for example, and then", "tokens": [51412, 4878, 456, 366, 512, 13, 286, 5801, 562, 11745, 41504, 29978, 422, 46, 11, 337, 1365, 11, 293, 550, 51748], "temperature": 0.0, "avg_logprob": -0.08089748843685611, "compression_ratio": 1.56, "no_speech_prob": 0.008164279162883759}, {"id": 88, "seek": 58664, "start": 586.64, "end": 593.6, "text": " go on to use collections to implement folds. The degree to which the collections like these make", "tokens": [50364, 352, 322, 281, 764, 16641, 281, 4445, 31341, 13, 440, 4314, 281, 597, 264, 16641, 411, 613, 652, 50712], "temperature": 0.0, "avg_logprob": -0.0773317813873291, "compression_ratio": 1.6651982378854626, "no_speech_prob": 0.0038031921721994877}, {"id": 89, "seek": 58664, "start": 593.6, "end": 601.52, "text": " sense is really applying polymorphism to me and OO idea. The degree to which the data is external", "tokens": [50712, 2020, 307, 534, 9275, 6754, 76, 18191, 1434, 281, 385, 293, 422, 46, 1558, 13, 440, 4314, 281, 597, 264, 1412, 307, 8320, 51108], "temperature": 0.0, "avg_logprob": -0.0773317813873291, "compression_ratio": 1.6651982378854626, "no_speech_prob": 0.0038031921721994877}, {"id": 90, "seek": 58664, "start": 601.52, "end": 607.6, "text": " in a list is an implementation detail in this case, as long as we don't change that data.", "tokens": [51108, 294, 257, 1329, 307, 364, 11420, 2607, 294, 341, 1389, 11, 382, 938, 382, 321, 500, 380, 1319, 300, 1412, 13, 51412], "temperature": 0.0, "avg_logprob": -0.0773317813873291, "compression_ratio": 1.6651982378854626, "no_speech_prob": 0.0038031921721994877}, {"id": 91, "seek": 58664, "start": 608.88, "end": 615.4399999999999, "text": " If I write immutable code in Java or C sharp or any other OO programming language, then I can", "tokens": [51476, 759, 286, 2464, 3397, 32148, 3089, 294, 10745, 420, 383, 8199, 420, 604, 661, 422, 46, 9410, 2856, 11, 550, 286, 393, 51804], "temperature": 0.0, "avg_logprob": -0.0773317813873291, "compression_ratio": 1.6651982378854626, "no_speech_prob": 0.0038031921721994877}, {"id": 92, "seek": 61544, "start": 615.44, "end": 622.96, "text": " justifiably be seen to be writing in a functional style. I used to write C. I used to use ideas", "tokens": [50364, 445, 17638, 1188, 312, 1612, 281, 312, 3579, 294, 257, 11745, 3758, 13, 286, 1143, 281, 2464, 383, 13, 286, 1143, 281, 764, 3487, 50740], "temperature": 0.0, "avg_logprob": -0.06525740903966568, "compression_ratio": 1.593073593073593, "no_speech_prob": 0.0014091996708884835}, {"id": 93, "seek": 61544, "start": 622.96, "end": 629.6800000000001, "text": " that I now I'd call OO and functional in the design of my code. My language didn't help me much in", "tokens": [50740, 300, 286, 586, 286, 1116, 818, 422, 46, 293, 11745, 294, 264, 1715, 295, 452, 3089, 13, 1222, 2856, 994, 380, 854, 385, 709, 294, 51076], "temperature": 0.0, "avg_logprob": -0.06525740903966568, "compression_ratio": 1.593073593073593, "no_speech_prob": 0.0014091996708884835}, {"id": 94, "seek": 61544, "start": 629.6800000000001, "end": 636.48, "text": " those days, in the same way that Java doesn't enforce no assignment when I'm using it. But", "tokens": [51076, 729, 1708, 11, 294, 264, 912, 636, 300, 10745, 1177, 380, 24825, 572, 15187, 562, 286, 478, 1228, 309, 13, 583, 51416], "temperature": 0.0, "avg_logprob": -0.06525740903966568, "compression_ratio": 1.593073593073593, "no_speech_prob": 0.0014091996708884835}, {"id": 95, "seek": 61544, "start": 636.48, "end": 642.0, "text": " it doesn't take a lot of self-discipline to achieve the same results if I want to.", "tokens": [51416, 309, 1177, 380, 747, 257, 688, 295, 2698, 12, 13731, 19246, 533, 281, 4584, 264, 912, 3542, 498, 286, 528, 281, 13, 51692], "temperature": 0.0, "avg_logprob": -0.06525740903966568, "compression_ratio": 1.593073593073593, "no_speech_prob": 0.0014091996708884835}, {"id": 96, "seek": 64200, "start": 642.08, "end": 649.52, "text": " So at the technical level, I think that your choice of paradigm is just that. It's a choice,", "tokens": [50368, 407, 412, 264, 6191, 1496, 11, 286, 519, 300, 428, 3922, 295, 24709, 307, 445, 300, 13, 467, 311, 257, 3922, 11, 50740], "temperature": 0.0, "avg_logprob": -0.1429587682088216, "compression_ratio": 1.554945054945055, "no_speech_prob": 0.004607880022376776}, {"id": 97, "seek": 64200, "start": 650.24, "end": 658.16, "text": " and it can be fluid and contextual. Let's be clear, though, you can write crap code in any paradigm,", "tokens": [50776, 293, 309, 393, 312, 9113, 293, 35526, 13, 961, 311, 312, 1850, 11, 1673, 11, 291, 393, 2464, 12426, 3089, 294, 604, 24709, 11, 51172], "temperature": 0.0, "avg_logprob": -0.1429587682088216, "compression_ratio": 1.554945054945055, "no_speech_prob": 0.004607880022376776}, {"id": 98, "seek": 64200, "start": 658.16, "end": 665.92, "text": " and you can write great code in any paradigm too. There's no functional good OO bad here.", "tokens": [51172, 293, 291, 393, 2464, 869, 3089, 294, 604, 24709, 886, 13, 821, 311, 572, 11745, 665, 422, 46, 1578, 510, 13, 51560], "temperature": 0.0, "avg_logprob": -0.1429587682088216, "compression_ratio": 1.554945054945055, "no_speech_prob": 0.004607880022376776}, {"id": 99, "seek": 66592, "start": 666.4, "end": 671.8399999999999, "text": " There's a fashion for each side to rubbish the other. And if I'm honest, I think that that is a", "tokens": [50388, 821, 311, 257, 6700, 337, 1184, 1252, 281, 29978, 264, 661, 13, 400, 498, 286, 478, 3245, 11, 286, 519, 300, 300, 307, 257, 50660], "temperature": 0.0, "avg_logprob": -0.14752660245976895, "compression_ratio": 1.6631205673758864, "no_speech_prob": 0.010294832289218903}, {"id": 100, "seek": 66592, "start": 671.8399999999999, "end": 678.64, "text": " little naive. There are advantages to different paradigms, different advantages for each. As I've", "tokens": [50660, 707, 29052, 13, 821, 366, 14906, 281, 819, 13480, 328, 2592, 11, 819, 14906, 337, 1184, 13, 1018, 286, 600, 51000], "temperature": 0.0, "avg_logprob": -0.14752660245976895, "compression_ratio": 1.6631205673758864, "no_speech_prob": 0.010294832289218903}, {"id": 101, "seek": 66592, "start": 678.64, "end": 684.4799999999999, "text": " said, I am more of an OO than a functional programmer, so probably somewhat biased. The problem", "tokens": [51000, 848, 11, 286, 669, 544, 295, 364, 422, 46, 813, 257, 11745, 32116, 11, 370, 1391, 8344, 28035, 13, 440, 1154, 51292], "temperature": 0.0, "avg_logprob": -0.14752660245976895, "compression_ratio": 1.6631205673758864, "no_speech_prob": 0.010294832289218903}, {"id": 102, "seek": 66592, "start": 684.4799999999999, "end": 689.8399999999999, "text": " with this kind of religious war is that people get over emotional. So if I do trample on any of", "tokens": [51292, 365, 341, 733, 295, 7185, 1516, 307, 300, 561, 483, 670, 6863, 13, 407, 498, 286, 360, 25749, 781, 322, 604, 295, 51560], "temperature": 0.0, "avg_logprob": -0.14752660245976895, "compression_ratio": 1.6631205673758864, "no_speech_prob": 0.010294832289218903}, {"id": 103, "seek": 66592, "start": 689.8399999999999, "end": 694.56, "text": " your sacred cows during the course of this, please do forgive me. There is a social", "tokens": [51560, 428, 15757, 19148, 1830, 264, 1164, 295, 341, 11, 1767, 360, 10718, 385, 13, 821, 307, 257, 2093, 51796], "temperature": 0.0, "avg_logprob": -0.14752660245976895, "compression_ratio": 1.6631205673758864, "no_speech_prob": 0.010294832289218903}, {"id": 104, "seek": 69456, "start": 694.8, "end": 701.68, "text": " dimension to all of this, though, and we tend to be too tribal in software development. Broadly,", "tokens": [50376, 10139, 281, 439, 295, 341, 11, 1673, 11, 293, 321, 3928, 281, 312, 886, 20958, 294, 4722, 3250, 13, 14074, 356, 11, 50720], "temperature": 0.0, "avg_logprob": -0.16009210230229975, "compression_ratio": 1.6623931623931625, "no_speech_prob": 0.0004721608420368284}, {"id": 105, "seek": 69456, "start": 701.68, "end": 708.0799999999999, "text": " I think that we could oversimplify the tribes like this. Functional programmers tend to think of", "tokens": [50720, 286, 519, 300, 321, 727, 15488, 332, 564, 2505, 264, 19035, 411, 341, 13, 11166, 41048, 41504, 3928, 281, 519, 295, 51040], "temperature": 0.0, "avg_logprob": -0.16009210230229975, "compression_ratio": 1.6623931623931625, "no_speech_prob": 0.0004721608420368284}, {"id": 106, "seek": 69456, "start": 708.0799999999999, "end": 715.52, "text": " programming as maths. OO programmers tend to think of coding as a problem of modeling. Neither of", "tokens": [51040, 9410, 382, 36287, 13, 422, 46, 41504, 3928, 281, 519, 295, 17720, 382, 257, 1154, 295, 15983, 13, 23956, 295, 51412], "temperature": 0.0, "avg_logprob": -0.16009210230229975, "compression_ratio": 1.6623931623931625, "no_speech_prob": 0.0004721608420368284}, {"id": 107, "seek": 69456, "start": 715.52, "end": 722.88, "text": " these are completely true, but may be a reasonable approximation. So the benefits of a functional", "tokens": [51412, 613, 366, 2584, 2074, 11, 457, 815, 312, 257, 10585, 28023, 13, 407, 264, 5311, 295, 257, 11745, 51780], "temperature": 0.0, "avg_logprob": -0.16009210230229975, "compression_ratio": 1.6623931623931625, "no_speech_prob": 0.0004721608420368284}, {"id": 108, "seek": 72288, "start": 723.6, "end": 729.92, "text": " approach are that we can abstract ideas into functions that are always correct. In every", "tokens": [50400, 3109, 366, 300, 321, 393, 12649, 3487, 666, 6828, 300, 366, 1009, 3006, 13, 682, 633, 50716], "temperature": 0.0, "avg_logprob": -0.14915263232062845, "compression_ratio": 1.6754385964912282, "no_speech_prob": 0.00460598012432456}, {"id": 109, "seek": 72288, "start": 729.92, "end": 738.0, "text": " circumstance and so write less code. By excluding or at least constraining assignment, we can create", "tokens": [50716, 27640, 293, 370, 2464, 1570, 3089, 13, 3146, 49999, 420, 412, 1935, 11525, 1760, 15187, 11, 321, 393, 1884, 51120], "temperature": 0.0, "avg_logprob": -0.14915263232062845, "compression_ratio": 1.6754385964912282, "no_speech_prob": 0.00460598012432456}, {"id": 110, "seek": 72288, "start": 738.0, "end": 745.28, "text": " more stable systems and maybe even prove more provable systems. The benefits of a model based", "tokens": [51120, 544, 8351, 3652, 293, 1310, 754, 7081, 544, 1439, 712, 3652, 13, 440, 5311, 295, 257, 2316, 2361, 51484], "temperature": 0.0, "avg_logprob": -0.14915263232062845, "compression_ratio": 1.6754385964912282, "no_speech_prob": 0.00460598012432456}, {"id": 111, "seek": 72288, "start": 745.28, "end": 751.76, "text": " approach are that we can be guided in our analysis by the problem. I think that this is one of the", "tokens": [51484, 3109, 366, 300, 321, 393, 312, 19663, 294, 527, 5215, 538, 264, 1154, 13, 286, 519, 300, 341, 307, 472, 295, 264, 51808], "temperature": 0.0, "avg_logprob": -0.14915263232062845, "compression_ratio": 1.6754385964912282, "no_speech_prob": 0.00460598012432456}, {"id": 112, "seek": 75176, "start": 752.24, "end": 760.24, "text": " advantages that OO has over functional programming. It's that when done well, the code is more", "tokens": [50388, 14906, 300, 422, 46, 575, 670, 11745, 9410, 13, 467, 311, 300, 562, 1096, 731, 11, 264, 3089, 307, 544, 50788], "temperature": 0.0, "avg_logprob": -0.06701828158178995, "compression_ratio": 1.6406926406926408, "no_speech_prob": 0.00047178700333461165}, {"id": 113, "seek": 75176, "start": 760.24, "end": 766.16, "text": " navigable because it's closer to the problem. It allows us to explore the relationships more", "tokens": [50788, 7407, 712, 570, 309, 311, 4966, 281, 264, 1154, 13, 467, 4045, 505, 281, 6839, 264, 6159, 544, 51084], "temperature": 0.0, "avg_logprob": -0.06701828158178995, "compression_ratio": 1.6406926406926408, "no_speech_prob": 0.00047178700333461165}, {"id": 114, "seek": 75176, "start": 766.16, "end": 772.4, "text": " clearly and understand the problem in small pieces in a way that is closely related to how we think", "tokens": [51084, 4448, 293, 1223, 264, 1154, 294, 1359, 3755, 294, 257, 636, 300, 307, 8185, 4077, 281, 577, 321, 519, 51396], "temperature": 0.0, "avg_logprob": -0.06701828158178995, "compression_ratio": 1.6406926406926408, "no_speech_prob": 0.00047178700333461165}, {"id": 115, "seek": 75176, "start": 772.4, "end": 780.64, "text": " about the problem. Human beings are naturally classifiers. This gets us to what seems to me", "tokens": [51396, 466, 264, 1154, 13, 10294, 8958, 366, 8195, 1508, 23463, 13, 639, 2170, 505, 281, 437, 2544, 281, 385, 51808], "temperature": 0.0, "avg_logprob": -0.06701828158178995, "compression_ratio": 1.6406926406926408, "no_speech_prob": 0.00047178700333461165}, {"id": 116, "seek": 78064, "start": 780.72, "end": 787.68, "text": " like an important point. I think OO is more closely aligned with how humans brains work.", "tokens": [50368, 411, 364, 1021, 935, 13, 286, 519, 422, 46, 307, 544, 8185, 17962, 365, 577, 6255, 15442, 589, 13, 50716], "temperature": 0.0, "avg_logprob": -0.07879811298998096, "compression_ratio": 1.5982142857142858, "no_speech_prob": 0.005996310617774725}, {"id": 117, "seek": 78064, "start": 788.4, "end": 793.92, "text": " I can certainly buy the claim that the more mathematical functional approach is a more", "tokens": [50752, 286, 393, 3297, 2256, 264, 3932, 300, 264, 544, 18894, 11745, 3109, 307, 257, 544, 51028], "temperature": 0.0, "avg_logprob": -0.07879811298998096, "compression_ratio": 1.5982142857142858, "no_speech_prob": 0.005996310617774725}, {"id": 118, "seek": 78064, "start": 793.92, "end": 801.4399999999999, "text": " rigorous way to capture an idea. But much as I love maths, it's famously difficult and in", "tokens": [51028, 29882, 636, 281, 7983, 364, 1558, 13, 583, 709, 382, 286, 959, 36287, 11, 309, 311, 34360, 2252, 293, 294, 51404], "temperature": 0.0, "avg_logprob": -0.07879811298998096, "compression_ratio": 1.5982142857142858, "no_speech_prob": 0.005996310617774725}, {"id": 119, "seek": 78064, "start": 801.4399999999999, "end": 808.3199999999999, "text": " essence an unnatural way of thinking for human brains. We value mathematical thinkers highly", "tokens": [51404, 12801, 364, 43470, 636, 295, 1953, 337, 1952, 15442, 13, 492, 2158, 18894, 37895, 5405, 51748], "temperature": 0.0, "avg_logprob": -0.07879811298998096, "compression_ratio": 1.5982142857142858, "no_speech_prob": 0.005996310617774725}, {"id": 120, "seek": 80832, "start": 808.4000000000001, "end": 814.0, "text": " because their skills are so rare. This is so obvious. If I throw a ball to you,", "tokens": [50368, 570, 641, 3942, 366, 370, 5892, 13, 639, 307, 370, 6322, 13, 759, 286, 3507, 257, 2594, 281, 291, 11, 50648], "temperature": 0.0, "avg_logprob": -0.048496210828740546, "compression_ratio": 1.5585585585585586, "no_speech_prob": 0.0018639988265931606}, {"id": 121, "seek": 80832, "start": 815.12, "end": 819.9200000000001, "text": " is it easier to catch it or to work out the physics of its flight and predict where it will", "tokens": [50704, 307, 309, 3571, 281, 3745, 309, 420, 281, 589, 484, 264, 10649, 295, 1080, 7018, 293, 6069, 689, 309, 486, 50944], "temperature": 0.0, "avg_logprob": -0.048496210828740546, "compression_ratio": 1.5585585585585586, "no_speech_prob": 0.0018639988265931606}, {"id": 122, "seek": 80832, "start": 819.9200000000001, "end": 825.7600000000001, "text": " land so that you can move to the right place? We don't do the maths when we catch a ball.", "tokens": [50944, 2117, 370, 300, 291, 393, 1286, 281, 264, 558, 1081, 30, 492, 500, 380, 360, 264, 36287, 562, 321, 3745, 257, 2594, 13, 51236], "temperature": 0.0, "avg_logprob": -0.048496210828740546, "compression_ratio": 1.5585585585585586, "no_speech_prob": 0.0018639988265931606}, {"id": 123, "seek": 80832, "start": 825.7600000000001, "end": 831.6, "text": " If we did, we'd certainly miss the ball. So there's something to be said for ease of", "tokens": [51236, 759, 321, 630, 11, 321, 1116, 3297, 1713, 264, 2594, 13, 407, 456, 311, 746, 281, 312, 848, 337, 12708, 295, 51528], "temperature": 0.0, "avg_logprob": -0.048496210828740546, "compression_ratio": 1.5585585585585586, "no_speech_prob": 0.0018639988265931606}, {"id": 124, "seek": 83160, "start": 831.6, "end": 842.48, "text": " comprehension, clarity of expression, which is clearer, this or this. Even if you are a functional", "tokens": [50364, 44991, 11, 16992, 295, 6114, 11, 597, 307, 26131, 11, 341, 420, 341, 13, 2754, 498, 291, 366, 257, 11745, 50908], "temperature": 0.0, "avg_logprob": -0.09530045004451976, "compression_ratio": 1.6493506493506493, "no_speech_prob": 0.11054825782775879}, {"id": 125, "seek": 83160, "start": 842.48, "end": 848.4, "text": " programmer, I think that you would agree that the second version was easier to read. Sure,", "tokens": [50908, 32116, 11, 286, 519, 300, 291, 576, 3986, 300, 264, 1150, 3037, 390, 3571, 281, 1401, 13, 4894, 11, 51204], "temperature": 0.0, "avg_logprob": -0.09530045004451976, "compression_ratio": 1.6493506493506493, "no_speech_prob": 0.11054825782775879}, {"id": 126, "seek": 83160, "start": 848.4, "end": 854.32, "text": " we can argue about the flexibility of folds versus loops and because of the immutability of", "tokens": [51204, 321, 393, 9695, 466, 264, 12635, 295, 31341, 5717, 16121, 293, 570, 295, 264, 3397, 325, 2310, 295, 51500], "temperature": 0.0, "avg_logprob": -0.09530045004451976, "compression_ratio": 1.6493506493506493, "no_speech_prob": 0.11054825782775879}, {"id": 127, "seek": 83160, "start": 854.32, "end": 860.4, "text": " functional style, our potential to parallelize the computation of our programs, an argument which I", "tokens": [51500, 11745, 3758, 11, 527, 3995, 281, 8952, 1125, 264, 24903, 295, 527, 4268, 11, 364, 6770, 597, 286, 51804], "temperature": 0.0, "avg_logprob": -0.09530045004451976, "compression_ratio": 1.6493506493506493, "no_speech_prob": 0.11054825782775879}, {"id": 128, "seek": 86040, "start": 860.4, "end": 864.56, "text": " confess as a developer of high performance systems I'm a bit skeptical about, but the", "tokens": [50364, 19367, 382, 257, 10754, 295, 1090, 3389, 3652, 286, 478, 257, 857, 28601, 466, 11, 457, 264, 50572], "temperature": 0.0, "avg_logprob": -0.07793592839013963, "compression_ratio": 1.5779816513761469, "no_speech_prob": 0.001691550831310451}, {"id": 129, "seek": 86040, "start": 864.56, "end": 871.28, "text": " readability, the comprehensibility of our code matters a lot. Here is a function written in", "tokens": [50572, 1401, 2310, 11, 264, 10753, 694, 2841, 295, 527, 3089, 7001, 257, 688, 13, 1692, 307, 257, 2445, 3720, 294, 50908], "temperature": 0.0, "avg_logprob": -0.07793592839013963, "compression_ratio": 1.5779816513761469, "no_speech_prob": 0.001691550831310451}, {"id": 130, "seek": 86040, "start": 871.28, "end": 878.3199999999999, "text": " imperative style, in this case in Java. We're just going to look at a collection of numbers", "tokens": [50908, 32490, 3758, 11, 294, 341, 1389, 294, 10745, 13, 492, 434, 445, 516, 281, 574, 412, 257, 5765, 295, 3547, 51260], "temperature": 0.0, "avg_logprob": -0.07793592839013963, "compression_ratio": 1.5779816513761469, "no_speech_prob": 0.001691550831310451}, {"id": 131, "seek": 86040, "start": 878.3199999999999, "end": 885.52, "text": " and form some kind of total. Here is the same function written in Haskell.", "tokens": [51260, 293, 1254, 512, 733, 295, 3217, 13, 1692, 307, 264, 912, 2445, 3720, 294, 8646, 43723, 13, 51620], "temperature": 0.0, "avg_logprob": -0.07793592839013963, "compression_ratio": 1.5779816513761469, "no_speech_prob": 0.001691550831310451}, {"id": 132, "seek": 88552, "start": 885.52, "end": 896.0, "text": " In this case, we're going to define the function as a recursive function. The first seems to be a", "tokens": [50364, 682, 341, 1389, 11, 321, 434, 516, 281, 6964, 264, 2445, 382, 257, 20560, 488, 2445, 13, 440, 700, 2544, 281, 312, 257, 50888], "temperature": 0.0, "avg_logprob": -0.11380293185894307, "compression_ratio": 1.4947916666666667, "no_speech_prob": 0.001241964171640575}, {"id": 133, "seek": 88552, "start": 896.0, "end": 903.36, "text": " lot easier to explain to somebody that has never written any code because of this alignment with", "tokens": [50888, 688, 3571, 281, 2903, 281, 2618, 300, 575, 1128, 3720, 604, 3089, 570, 295, 341, 18515, 365, 51256], "temperature": 0.0, "avg_logprob": -0.11380293185894307, "compression_ratio": 1.4947916666666667, "no_speech_prob": 0.001241964171640575}, {"id": 134, "seek": 88552, "start": 903.36, "end": 910.48, "text": " the way in which people think about things. You have to access some reasonably complex ideas", "tokens": [51256, 264, 636, 294, 597, 561, 519, 466, 721, 13, 509, 362, 281, 2105, 512, 23551, 3997, 3487, 51612], "temperature": 0.0, "avg_logprob": -0.11380293185894307, "compression_ratio": 1.4947916666666667, "no_speech_prob": 0.001241964171640575}, {"id": 135, "seek": 91048, "start": 910.48, "end": 917.6800000000001, "text": " like recursion to even start to understand the second example. Yes, the code is shorter,", "tokens": [50364, 411, 20560, 313, 281, 754, 722, 281, 1223, 264, 1150, 1365, 13, 1079, 11, 264, 3089, 307, 11639, 11, 50724], "temperature": 0.0, "avg_logprob": -0.08023653310887954, "compression_ratio": 1.508108108108108, "no_speech_prob": 0.0209280364215374}, {"id": 136, "seek": 91048, "start": 918.24, "end": 925.12, "text": " but that compromises its readability somewhat too. The first is a bit more like catching the ball", "tokens": [50752, 457, 300, 11482, 3598, 1080, 1401, 2310, 8344, 886, 13, 440, 700, 307, 257, 857, 544, 411, 16124, 264, 2594, 51096], "temperature": 0.0, "avg_logprob": -0.08023653310887954, "compression_ratio": 1.508108108108108, "no_speech_prob": 0.0209280364215374}, {"id": 137, "seek": 91048, "start": 925.12, "end": 932.08, "text": " than doing the maths. In reality, in Haskell, this sum function is a library function, which", "tokens": [51096, 813, 884, 264, 36287, 13, 682, 4103, 11, 294, 8646, 43723, 11, 341, 2408, 2445, 307, 257, 6405, 2445, 11, 597, 51444], "temperature": 0.0, "avg_logprob": -0.08023653310887954, "compression_ratio": 1.508108108108108, "no_speech_prob": 0.0209280364215374}, {"id": 138, "seek": 93208, "start": 932.08, "end": 940.88, "text": " I'm told is apparently implemented like this. I rest my case. I think that the functional", "tokens": [50364, 286, 478, 1907, 307, 7970, 12270, 411, 341, 13, 286, 1472, 452, 1389, 13, 286, 519, 300, 264, 11745, 50804], "temperature": 0.0, "avg_logprob": -0.06710213422775269, "compression_ratio": 1.6016949152542372, "no_speech_prob": 0.014949183911085129}, {"id": 139, "seek": 93208, "start": 940.88, "end": 947.44, "text": " paradigm has a lot to offer. In particular, the idea of limiting side effects is an excellent one,", "tokens": [50804, 24709, 575, 257, 688, 281, 2626, 13, 682, 1729, 11, 264, 1558, 295, 22083, 1252, 5065, 307, 364, 7103, 472, 11, 51132], "temperature": 0.0, "avg_logprob": -0.06710213422775269, "compression_ratio": 1.6016949152542372, "no_speech_prob": 0.014949183911085129}, {"id": 140, "seek": 93208, "start": 947.44, "end": 952.88, "text": " however you choose to write your programs. I've adopted that style of thinking in my OO code", "tokens": [51132, 4461, 291, 2826, 281, 2464, 428, 4268, 13, 286, 600, 12175, 300, 3758, 295, 1953, 294, 452, 422, 46, 3089, 51404], "temperature": 0.0, "avg_logprob": -0.06710213422775269, "compression_ratio": 1.6016949152542372, "no_speech_prob": 0.014949183911085129}, {"id": 141, "seek": 93208, "start": 952.88, "end": 959.36, "text": " for a long time now, not eliminating assignment, but certainly limiting it and reducing the side", "tokens": [51404, 337, 257, 938, 565, 586, 11, 406, 31203, 15187, 11, 457, 3297, 22083, 309, 293, 12245, 264, 1252, 51728], "temperature": 0.0, "avg_logprob": -0.06710213422775269, "compression_ratio": 1.6016949152542372, "no_speech_prob": 0.014949183911085129}, {"id": 142, "seek": 95936, "start": 959.36, "end": 966.8000000000001, "text": " effects. I confess that I've never tried to write a whole functional system as a pure functional", "tokens": [50364, 5065, 13, 286, 19367, 300, 286, 600, 1128, 3031, 281, 2464, 257, 1379, 11745, 1185, 382, 257, 6075, 11745, 50736], "temperature": 0.0, "avg_logprob": -0.07723313770937117, "compression_ratio": 1.662162162162162, "no_speech_prob": 0.00537573779001832}, {"id": 143, "seek": 95936, "start": 966.8000000000001, "end": 972.48, "text": " system, and I'm sure that I would learn a lot if I did, but I think that one of the reasons that", "tokens": [50736, 1185, 11, 293, 286, 478, 988, 300, 286, 576, 1466, 257, 688, 498, 286, 630, 11, 457, 286, 519, 300, 472, 295, 264, 4112, 300, 51020], "temperature": 0.0, "avg_logprob": -0.07723313770937117, "compression_ratio": 1.662162162162162, "no_speech_prob": 0.00537573779001832}, {"id": 144, "seek": 95936, "start": 972.48, "end": 977.84, "text": " everyone doesn't do functional programming is that it's more difficult to transpose these", "tokens": [51020, 1518, 1177, 380, 360, 11745, 9410, 307, 300, 309, 311, 544, 2252, 281, 25167, 613, 51288], "temperature": 0.0, "avg_logprob": -0.07723313770937117, "compression_ratio": 1.662162162162162, "no_speech_prob": 0.00537573779001832}, {"id": 145, "seek": 95936, "start": 977.84, "end": 982.48, "text": " ISDs into the kinds of functions in a way that keeps the code readable and navigable.", "tokens": [51288, 6205, 35, 82, 666, 264, 3685, 295, 6828, 294, 257, 636, 300, 5965, 264, 3089, 49857, 293, 7407, 712, 13, 51520], "temperature": 0.0, "avg_logprob": -0.07723313770937117, "compression_ratio": 1.662162162162162, "no_speech_prob": 0.00537573779001832}, {"id": 146, "seek": 98248, "start": 982.72, "end": 988.4, "text": " I said at the beginning that I disagreed somewhat with Bob Martin about whether we have found all of", "tokens": [50376, 286, 848, 412, 264, 2863, 300, 286, 23926, 292, 8344, 365, 6085, 9184, 466, 1968, 321, 362, 1352, 439, 295, 50660], "temperature": 0.0, "avg_logprob": -0.1306163810548328, "compression_ratio": 1.6452991452991452, "no_speech_prob": 0.012414935044944286}, {"id": 147, "seek": 98248, "start": 988.4, "end": 994.88, "text": " the programming paradigms. There is another aspect of programs and programming that we can", "tokens": [50660, 264, 9410, 13480, 328, 2592, 13, 821, 307, 1071, 4171, 295, 4268, 293, 9410, 300, 321, 393, 50984], "temperature": 0.0, "avg_logprob": -0.1306163810548328, "compression_ratio": 1.6452991452991452, "no_speech_prob": 0.012414935044944286}, {"id": 148, "seek": 98248, "start": 994.88, "end": 1003.6, "text": " usefully constrain that has some very interesting properties. That is synchronicity. What if we", "tokens": [50984, 764, 2277, 1817, 7146, 300, 575, 512, 588, 1880, 7221, 13, 663, 307, 5451, 339, 10011, 507, 13, 708, 498, 321, 51420], "temperature": 0.0, "avg_logprob": -0.1306163810548328, "compression_ratio": 1.6452991452991452, "no_speech_prob": 0.012414935044944286}, {"id": 149, "seek": 98248, "start": 1003.6, "end": 1010.32, "text": " constrained our programs to disallow synchronous calls between modules of code? Each component of", "tokens": [51420, 38901, 527, 4268, 281, 717, 13253, 44743, 5498, 1296, 16679, 295, 3089, 30, 6947, 6542, 295, 51756], "temperature": 0.0, "avg_logprob": -0.1306163810548328, "compression_ratio": 1.6452991452991452, "no_speech_prob": 0.012414935044944286}, {"id": 150, "seek": 101032, "start": 1010.4000000000001, "end": 1016.32, "text": " each component of the system only communicated with any other by sending a message.", "tokens": [50368, 1184, 6542, 295, 264, 1185, 787, 34989, 365, 604, 661, 538, 7750, 257, 3636, 13, 50664], "temperature": 0.0, "avg_logprob": -0.2295117790316358, "compression_ratio": 1.6066350710900474, "no_speech_prob": 0.0009668212733231485}, {"id": 151, "seek": 101032, "start": 1017.2, "end": 1024.56, "text": " Response is sent in a different message some time later. I'm not talking about", "tokens": [50708, 43937, 307, 2279, 294, 257, 819, 3636, 512, 565, 1780, 13, 286, 478, 406, 1417, 466, 51076], "temperature": 0.0, "avg_logprob": -0.2295117790316358, "compression_ratio": 1.6066350710900474, "no_speech_prob": 0.0009668212733231485}, {"id": 152, "seek": 101032, "start": 1024.56, "end": 1032.0800000000002, "text": " asynchro weights here, which I dislike. More like this. A sends an add item message to B", "tokens": [51076, 382, 2534, 339, 340, 17443, 510, 11, 597, 286, 26006, 13, 5048, 411, 341, 13, 316, 14790, 364, 909, 3174, 3636, 281, 363, 51452], "temperature": 0.0, "avg_logprob": -0.2295117790316358, "compression_ratio": 1.6066350710900474, "no_speech_prob": 0.0009668212733231485}, {"id": 153, "seek": 101032, "start": 1033.04, "end": 1038.72, "text": " some time later. B sends an item added message back, saying and confirming the receipt.", "tokens": [51500, 512, 565, 1780, 13, 363, 14790, 364, 3174, 3869, 3636, 646, 11, 1566, 293, 42861, 264, 33882, 13, 51784], "temperature": 0.0, "avg_logprob": -0.2295117790316358, "compression_ratio": 1.6066350710900474, "no_speech_prob": 0.0009668212733231485}, {"id": 154, "seek": 104032, "start": 1040.56, "end": 1044.48, "text": " Concurrency only allowed at these module boundaries,", "tokens": [50376, 2656, 14112, 10457, 787, 4350, 412, 613, 10088, 13180, 11, 50572], "temperature": 0.0, "avg_logprob": -0.09569519153539685, "compression_ratio": 1.6515151515151516, "no_speech_prob": 0.0008039340027607977}, {"id": 155, "seek": 104032, "start": 1044.48, "end": 1051.36, "text": " no creating threads inside a module. Each module is internally single threaded and so naturally", "tokens": [50572, 572, 4084, 19314, 1854, 257, 10088, 13, 6947, 10088, 307, 19501, 2167, 47493, 293, 370, 8195, 50916], "temperature": 0.0, "avg_logprob": -0.09569519153539685, "compression_ratio": 1.6515151515151516, "no_speech_prob": 0.0008039340027607977}, {"id": 156, "seek": 104032, "start": 1051.36, "end": 1059.12, "text": " concurrent. Each module is allowed to be state for or stateless as need arises.", "tokens": [50916, 37702, 13, 6947, 10088, 307, 4350, 281, 312, 1785, 337, 420, 2219, 4272, 382, 643, 27388, 13, 51304], "temperature": 0.0, "avg_logprob": -0.09569519153539685, "compression_ratio": 1.6515151515151516, "no_speech_prob": 0.0008039340027607977}, {"id": 157, "seek": 104032, "start": 1060.24, "end": 1065.6, "text": " This approach is significantly higher performance than any other approach that I am familiar with,", "tokens": [51360, 639, 3109, 307, 10591, 2946, 3389, 813, 604, 661, 3109, 300, 286, 669, 4963, 365, 11, 51628], "temperature": 0.0, "avg_logprob": -0.09569519153539685, "compression_ratio": 1.6515151515151516, "no_speech_prob": 0.0008039340027607977}, {"id": 158, "seek": 106560, "start": 1065.6, "end": 1071.1999999999998, "text": " certainly higher performance than a functional design. Functional systems copy a lot of stuff", "tokens": [50364, 3297, 2946, 3389, 813, 257, 11745, 1715, 13, 11166, 41048, 3652, 5055, 257, 688, 295, 1507, 50644], "temperature": 0.0, "avg_logprob": -0.0984359068029067, "compression_ratio": 1.5690376569037656, "no_speech_prob": 0.0021089494694024324}, {"id": 159, "seek": 106560, "start": 1071.1999999999998, "end": 1077.6, "text": " to achieve immutability. The best that they can do is clever tricks to pretend that they're copying", "tokens": [50644, 281, 4584, 3397, 325, 2310, 13, 440, 1151, 300, 436, 393, 360, 307, 13494, 11733, 281, 11865, 300, 436, 434, 27976, 50964], "temperature": 0.0, "avg_logprob": -0.0984359068029067, "compression_ratio": 1.5690376569037656, "no_speech_prob": 0.0021089494694024324}, {"id": 160, "seek": 106560, "start": 1077.6, "end": 1083.6799999999998, "text": " things, but actually not moving the bytes around in memory. However clever these tricks are though,", "tokens": [50964, 721, 11, 457, 767, 406, 2684, 264, 36088, 926, 294, 4675, 13, 2908, 13494, 613, 11733, 366, 1673, 11, 51268], "temperature": 0.0, "avg_logprob": -0.0984359068029067, "compression_ratio": 1.5690376569037656, "no_speech_prob": 0.0021089494694024324}, {"id": 161, "seek": 106560, "start": 1084.24, "end": 1090.56, "text": " it's still going to add CPU cycles. This is less tightly coupled than OO systems,", "tokens": [51296, 309, 311, 920, 516, 281, 909, 13199, 17796, 13, 639, 307, 1570, 21952, 29482, 813, 422, 46, 3652, 11, 51612], "temperature": 0.0, "avg_logprob": -0.0984359068029067, "compression_ratio": 1.5690376569037656, "no_speech_prob": 0.0021089494694024324}, {"id": 162, "seek": 109056, "start": 1091.12, "end": 1097.12, "text": " this approach of limiting synchronicity that I've described, but it has some properties of", "tokens": [50392, 341, 3109, 295, 22083, 5451, 339, 10011, 507, 300, 286, 600, 7619, 11, 457, 309, 575, 512, 7221, 295, 50692], "temperature": 0.0, "avg_logprob": -0.10581706699572112, "compression_ratio": 1.5971731448763251, "no_speech_prob": 0.0063500795513391495}, {"id": 163, "seek": 109056, "start": 1097.12, "end": 1104.0, "text": " both functional and OO design. It also sounds to me quite a lot closer to the vision that", "tokens": [50692, 1293, 11745, 293, 422, 46, 1715, 13, 467, 611, 3263, 281, 385, 1596, 257, 688, 4966, 281, 264, 5201, 300, 51036], "temperature": 0.0, "avg_logprob": -0.10581706699572112, "compression_ratio": 1.5971731448763251, "no_speech_prob": 0.0063500795513391495}, {"id": 164, "seek": 109056, "start": 1104.0, "end": 1109.6799999999998, "text": " Alan Kay had back in the 1960s. I wrote about some of these ideas in a thing called the", "tokens": [51036, 16442, 14179, 632, 646, 294, 264, 16157, 82, 13, 286, 4114, 466, 512, 295, 613, 3487, 294, 257, 551, 1219, 264, 51320], "temperature": 0.0, "avg_logprob": -0.10581706699572112, "compression_ratio": 1.5971731448763251, "no_speech_prob": 0.0063500795513391495}, {"id": 165, "seek": 109056, "start": 1109.6799999999998, "end": 1115.52, "text": " reactive manifesto. There's a link in the description. If you'd like to hear more about", "tokens": [51320, 28897, 10067, 78, 13, 821, 311, 257, 2113, 294, 264, 3855, 13, 759, 291, 1116, 411, 281, 1568, 544, 466, 51612], "temperature": 0.0, "avg_logprob": -0.10581706699572112, "compression_ratio": 1.5971731448763251, "no_speech_prob": 0.0063500795513391495}, {"id": 166, "seek": 109056, "start": 1115.52, "end": 1120.1599999999999, "text": " these kinds of ideas in a future video, do let me know in the comments. Thank you very much for", "tokens": [51612, 613, 3685, 295, 3487, 294, 257, 2027, 960, 11, 360, 718, 385, 458, 294, 264, 3053, 13, 1044, 291, 588, 709, 337, 51844], "temperature": 0.0, "avg_logprob": -0.10581706699572112, "compression_ratio": 1.5971731448763251, "no_speech_prob": 0.0063500795513391495}, {"id": 167, "seek": 112016, "start": 1120.16, "end": 1130.16, "text": " watching.", "tokens": [50364, 1976, 13, 50864], "temperature": 0.0, "avg_logprob": -0.8527226448059082, "compression_ratio": 0.5294117647058824, "no_speech_prob": 0.31918829679489136}], "language": "en"}