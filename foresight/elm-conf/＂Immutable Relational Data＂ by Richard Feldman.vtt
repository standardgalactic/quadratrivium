WEBVTT

00:00.000 --> 00:13.000
All right, so this is immutable relational data.

00:13.000 --> 00:15.080
I'm Richard Feldman.

00:15.080 --> 00:19.520
So when I was first getting into Elm, there were two questions that I had, like very early

00:19.520 --> 00:23.200
on, things that I didn't really know how to do coming from JavaScript.

00:23.200 --> 00:26.560
And one was, how do I do this?

00:26.560 --> 00:32.160
Like I want to do some equivalent of courses bracket zero dot students bracket zero dot

00:32.160 --> 00:33.400
selected equals true.

00:33.400 --> 00:38.480
Like, how do I, there's a little nested record update syntax, like how do I, I don't know,

00:38.480 --> 00:41.080
I couldn't quite figure that out at first.

00:41.080 --> 00:45.720
And then another question I had was, when, if ever, should I put duplicate information

00:45.720 --> 00:46.720
in my model?

00:46.720 --> 00:49.720
Like should I ever have the same piece of information in two different places in my model?

00:49.720 --> 00:50.720
Is that a bad idea?

00:50.720 --> 00:52.720
Is that, I don't know, what are the trade-offs?

00:52.720 --> 00:54.840
I didn't really know.

00:54.840 --> 00:58.240
And as I got more into Elm, I kind of learned about different techniques for modeling data

00:58.240 --> 00:59.240
and so forth.

00:59.240 --> 01:04.440
And I ended up discovering that these two questions turned out to be related.

01:04.440 --> 01:07.120
And they have to do with the title of this talk.

01:07.120 --> 01:11.280
So we're going to go through sort of my progression of like how I learned about these things.

01:11.280 --> 01:12.760
And we're going to start with state synchronization.

01:12.760 --> 01:17.000
And then we're going to move on to talking about relational data in general.

01:17.000 --> 01:21.600
And then finally end up with immutable relational data and some techniques for dealing with

01:21.600 --> 01:22.600
it.

01:22.600 --> 01:23.600
Okay.

01:23.600 --> 01:25.360
Let's start with state synchronization.

01:25.360 --> 01:26.360
Okay.

01:26.360 --> 01:29.680
So some time ago, a friend of mine tweeted me.

01:29.680 --> 01:36.080
They said, hey, RT Feldman, remember that time in college when we were late to a potluck?

01:36.080 --> 01:43.120
And we went to a Wendy's drive-thru and got 20 orders of $1 five-piece nuggets?

01:43.120 --> 01:46.440
So we showed up to the potluck with 100 chicken nuggets, LOL.

01:46.440 --> 01:47.440
That's a true story.

01:47.440 --> 01:48.440
That did happen in college.

01:48.440 --> 01:54.000
So I saw this, I was like, oh, yeah, that was a good time.

01:54.000 --> 01:57.760
So I like, you know, went to the like button and hit like.

01:57.760 --> 01:58.760
But I got an error.

01:58.760 --> 02:00.280
I was like, no, you can't do that.

02:00.280 --> 02:01.280
It's like, what?

02:01.280 --> 02:02.280
No, no, for real.

02:02.280 --> 02:03.280
I like it.

02:03.280 --> 02:04.280
It's good times.

02:04.280 --> 02:06.280
So I hit the button again.

02:06.280 --> 02:07.280
It's error.

02:07.280 --> 02:09.160
Oh, come on.

02:09.160 --> 02:13.920
So as it turned out, what had happened was my friend, after posting this, decided this

02:13.920 --> 02:17.520
was maybe not something the entire internet needed to know.

02:17.520 --> 02:19.240
And so they ended up deleting it.

02:19.240 --> 02:25.400
And so they deleted it sometime between when I saw it and when I attempted to click like,

02:25.400 --> 02:27.200
resulting in the error.

02:27.200 --> 02:31.360
So this is essentially a sort of a mismatch between the client and the server.

02:31.360 --> 02:34.880
So my client, the web browser, was like, oh, yeah, this tweet totally exists.

02:34.880 --> 02:35.880
Sure.

02:35.880 --> 02:39.040
Here's a nice lovely like button in case you'd like to like it.

02:39.040 --> 02:41.720
But unfortunately, the server had a different idea, the server was like, oh, that's gone.

02:41.720 --> 02:42.720
What are you talking about?

02:42.720 --> 02:44.840
Like, that's been deleted for a while.

02:44.840 --> 02:49.240
So there was this mismatch between the two, and that led to the error.

02:49.240 --> 02:51.560
So this is a form of synchronization problem.

02:51.560 --> 02:55.960
Like, we had a synchronization mismatch between the client and the server.

02:55.960 --> 03:00.480
And when we have multiple sources of truth, we sort of need to synchronize them or else

03:00.480 --> 03:02.120
we can get this type of error.

03:02.120 --> 03:06.120
Now if we have multiple sources of truth, such as the client and the server, and they

03:06.120 --> 03:10.680
agree like if the client says the tweet exists and the server also believes that it exists,

03:10.680 --> 03:11.680
that's okay.

03:11.680 --> 03:12.680
That's no problem.

03:12.880 --> 03:16.240
The typical thing, which is why, you know, I was surprised to see this error and not

03:16.240 --> 03:19.920
just like, oh, yeah, another one of these just happens to me constantly.

03:19.920 --> 03:24.480
Usually despite the fact that there are multiple sources of truth, they're staying in sync

03:24.480 --> 03:25.800
so it doesn't actually matter.

03:25.800 --> 03:28.800
It doesn't sort of affect me.

03:28.800 --> 03:30.680
It's also fine if they both agree that it's gone.

03:30.680 --> 03:34.120
Like, eventually I refresh the page and then I saw, oh, the thing's gone.

03:34.120 --> 03:36.440
So they got synced up and then it was again, no problem.

03:36.440 --> 03:39.640
I was back to being in sync with the server and the multiple sources of truth were not

03:39.680 --> 03:43.160
really causing any problems there for me.

03:43.160 --> 03:46.720
So basically when multiple sources of truth remain synchronized, it's okay.

03:46.720 --> 03:50.520
There's sort of no symptoms, no problems that the end user is faced with.

03:50.520 --> 03:56.560
However, when they get out of sync, as happened to me in the tweet, then that causes a problem.

03:56.560 --> 04:00.200
So single sources of truth sort of don't have this issue.

04:00.200 --> 04:03.520
There's no synchronization because there's nothing to synchronize.

04:03.520 --> 04:05.480
It's just one source of truth.

04:05.480 --> 04:09.320
So this entire class of errors goes away, which is one of the things that's nice about

04:09.320 --> 04:12.240
having a single source of truth.

04:12.240 --> 04:15.400
So synchronization is sort of error prone.

04:15.400 --> 04:16.880
This is one of the problems with it.

04:16.880 --> 04:19.080
As we saw, this is sort of a case in point.

04:19.080 --> 04:21.400
This is a synchronization error.

04:21.400 --> 04:24.400
And these sort of things can happen all the time when you have to synchronize two pieces

04:24.400 --> 04:27.440
of information because there are multiple sources of truth.

04:27.440 --> 04:32.840
Which sort of begs the question, is it necessarily avoidable to have multiple sources of truth?

04:32.840 --> 04:36.400
Sometimes do we have to have multiple sources of truth even if we would prefer to have a

04:36.400 --> 04:39.760
single source of truth and not have to synchronize anything?

04:39.760 --> 04:45.200
Let's take this client server app as an example and see if we can arrange things such that

04:45.200 --> 04:47.200
we have a single source of truth.

04:47.200 --> 04:48.200
This is our goal.

04:48.200 --> 04:51.760
We're going to have a client and a server, multiple clients and a server, and we're going

04:51.760 --> 04:54.640
to have a single source of truth that's shared between all of them such that there's nothing

04:54.640 --> 04:56.720
that we need to synchronize.

04:56.720 --> 04:59.520
So to do this, probably what we're going to have to do is say, okay, the server is going

04:59.520 --> 05:01.080
to have to take care of rendering the UI.

05:01.080 --> 05:04.480
That's going to have to be the source of truth because that's where the database lives.

05:04.840 --> 05:10.320
I mean, if anyone ever disagrees with the database about what is true, the database is

05:10.320 --> 05:11.320
going to be right.

05:11.320 --> 05:15.200
So we're going to have the server render HTML like it's 15 years ago and it's just going

05:15.200 --> 05:19.040
to send it directly to the client on every single user interaction.

05:19.040 --> 05:22.200
Like I click anything and the server is going to render some HTML and send it to the client.

05:22.200 --> 05:27.280
So that way the server is the single source of truth, kind of.

05:27.280 --> 05:31.480
Problem is that sending stuff from the server to the client takes time.

05:31.480 --> 05:33.920
It doesn't just like appear on my screen instantaneously.

05:34.360 --> 05:38.640
There's like networks and packets and like latency and things like that.

05:38.640 --> 05:42.960
And in fact, there's so much of that that it's like perceptible, which in turn means

05:42.960 --> 05:46.640
that it's entirely possible that over the course of that network transmission while

05:46.640 --> 05:52.240
the currently up-to-date perfect single source of truth UI is headed towards my browser,

05:52.240 --> 05:56.920
my friend deletes the tweet, and now I am once again out of sync.

05:56.920 --> 06:00.720
So even trying as hard as we possibly can to have a single source of truth with a client

06:00.720 --> 06:03.800
server application, it's just not possible.

06:03.800 --> 06:07.720
You cannot have a single source of truth when you've got a client and a server.

06:07.720 --> 06:10.360
You sort of must have synchronization.

06:10.360 --> 06:15.400
It's completely unavoidable by the nature of this architecture, which is kind of a bummer

06:15.400 --> 06:18.160
because hey, clients and servers are nice.

06:18.160 --> 06:21.320
So we're sort of stuck synchronizing them.

06:21.320 --> 06:25.280
And again, even if it is unavoidable, synchronization is still error-prone.

06:25.280 --> 06:28.360
We're still going to have to deal with synchronization errors like this.

06:28.360 --> 06:35.280
So we'd sort of like to handle these synchronization errors in as graceful a way as we can.

06:35.280 --> 06:37.880
And there's sort of different levels to this.

06:37.880 --> 06:40.640
So one is basically just like fail without feedback.

06:40.640 --> 06:44.840
So this is the absolute worst, which is to say the tweet gets deleted and I hit like

06:44.840 --> 06:46.280
and then just nothing happens.

06:46.280 --> 06:48.560
I'm just like, what?

06:48.560 --> 06:51.960
Or you can do what's called optimistic updates where you're just like, I'm going to update

06:51.960 --> 06:55.520
the client state and assume it works out on the server.

06:55.520 --> 06:59.200
This can be even worse and I've been really, really badly burned by this in the past.

06:59.200 --> 07:01.280
That's basically where you hit like and it does the animation.

07:01.280 --> 07:02.720
It's like, yeah, everything worked.

07:02.720 --> 07:04.520
And then later on it just was gone.

07:04.520 --> 07:05.520
What?

07:05.520 --> 07:08.800
And then, you know, so once it actually gets in sync, you find out much after the fact

07:08.800 --> 07:09.800
that there was a problem.

07:09.800 --> 07:14.240
Having had no idea at the time that there was anything wrong, which would have at least

07:14.240 --> 07:15.240
given me a clue.

07:15.240 --> 07:19.360
Like, yeah, I want to try hitting like again in case maybe the server is down or something.

07:19.360 --> 07:24.360
So failing without feedback is sort of the worst way to handle a synchronization error.

07:24.360 --> 07:27.800
We can do a little bit better by at least informing the user that some sort of error

07:27.800 --> 07:28.800
occurred.

07:28.800 --> 07:34.000
Like error, even if you're saying like error 500, that's at least giving me some clue that

07:34.000 --> 07:38.440
something went wrong so I can, you know, react accordingly and not be surprised later on

07:38.440 --> 07:44.360
to discover that there was this mismatch between my expectation and what actually happened.

07:44.360 --> 07:46.800
Even better than that is to explain the problem.

07:46.800 --> 07:51.080
Something like this tweet was deleted before you could like it or maybe something more

07:51.080 --> 07:52.440
concise than that.

07:52.440 --> 07:55.720
But explaining the problem gives the user a better experience to understand, oh, this

07:55.720 --> 07:59.760
is not just like something went wrong, which could be so many different things and lead

07:59.760 --> 08:04.800
me to take completely futile actions such as hammering on the like button.

08:04.800 --> 08:08.360
If they explain it to me and say this tweet was deleted, then I'm like, oh, okay, well,

08:08.360 --> 08:10.720
I'm not going to keep hitting like because it's gone.

08:10.720 --> 08:12.800
I understand that now.

08:12.800 --> 08:16.360
And the best of all would be to explain and then fix the problem.

08:16.360 --> 08:21.640
So basically say, hey, this tweet was deleted and then not leave the UI in a state where

08:21.640 --> 08:24.280
I can continue to hammer on the like button at all.

08:24.280 --> 08:29.520
Say like this tweet was deleted and then actually synchronize, like change it so it doesn't look

08:29.520 --> 08:34.120
like this anymore, maybe gray it out, maybe fade out the whole tweet itself.

08:34.120 --> 08:36.240
There are any number of things you can do.

08:36.240 --> 08:39.200
But these all require different degrees of effort.

08:39.200 --> 08:43.360
So in order to synchronize while also reporting the error, it's not just that the server has

08:43.360 --> 08:44.840
to send back a 500.

08:44.840 --> 08:49.560
It also has to say, here's what the problem was and also describe how to synchronize the

08:49.560 --> 08:54.320
state in some particular format, which my client then has to be looking for and know

08:54.320 --> 08:57.400
to say, oh, I understand that I got this additional data.

08:57.400 --> 09:01.480
Now I can use this to sort of patch my understanding of the world so that I'm now synchronized

09:01.480 --> 09:02.480
with the server.

09:02.480 --> 09:05.040
It's a lot more work to deal with that synchronization error.

09:05.040 --> 09:09.280
And that's not even getting into what happens if we're trying to synchronize across multiple

09:09.280 --> 09:13.160
clients where it's not clear who the source of truth is and we have to resolve conflicts.

09:13.160 --> 09:19.520
So this can be a lot of work, like a lot, a lot of work if you want to do it right.

09:19.520 --> 09:21.360
First of all, you have to make the updates in the first place.

09:21.360 --> 09:24.960
If we have multiple sources of truth and something changes, we have to go around and propagate

09:24.960 --> 09:29.000
those updates to all of the potential places where it could get out of sync.

09:29.000 --> 09:32.320
Once we've done that, then we have to detect errors, figure out if things are out of sync

09:32.320 --> 09:34.400
as they were in the case of this tweet.

09:34.400 --> 09:37.880
And then once we've detected them, then we have to potentially resolve conflicts.

09:37.880 --> 09:42.720
If we have lack of clarity around who is the source of truth, we have multiple clients

09:42.720 --> 09:45.200
who made edits at the same time on the same document.

09:45.200 --> 09:46.200
How do we resolve those?

09:46.200 --> 09:47.400
There's a lot of techniques for doing that.

09:47.400 --> 09:49.600
That's kind of a whole field of study.

09:49.600 --> 09:52.280
And then finally, ideally, gracefully recovering.

09:52.280 --> 09:56.960
So if we want to give people a good user experience or the best user experience we can in the

09:56.960 --> 10:02.720
face of all of these potential synchronization problems, we'll look into a lot of work.

10:02.720 --> 10:06.600
All of which is to say we really want to synchronize as little as possible.

10:06.600 --> 10:09.880
The more we can have single source of truth and not have to deal with any of this and

10:09.880 --> 10:13.520
not have to think about it, not have to worry about the errors, not have to spend time handling

10:13.520 --> 10:18.760
them, resolving conflicts, repairing the state and getting things back in sync, the nicer

10:18.760 --> 10:23.120
our lives are going to be and more likely, the most likely, the better our user experience

10:23.120 --> 10:25.200
is going to be as well.

10:25.200 --> 10:26.400
Okay.

10:26.400 --> 10:29.040
So let's sort of draw a smaller box around this.

10:29.040 --> 10:32.920
We've concluded that it's not possible to have a complete client server application

10:32.920 --> 10:35.200
where we have one single source of truth.

10:35.200 --> 10:39.520
But what if we narrow it down a little bit just to the client UI state?

10:39.520 --> 10:42.440
So if we just draw a box around that, what about now?

10:42.520 --> 10:45.560
We actually can have a single source of truth.

10:45.560 --> 10:50.160
And we as Elm programmers know this because we use the Elm architecture in which we have

10:50.160 --> 10:51.160
a single source of truth.

10:51.160 --> 10:52.320
That's what model's job is.

10:52.320 --> 10:57.600
It is a single atomic immutable value that is the single source of truth for the entire

10:57.600 --> 11:00.720
client application state and everything else is built on that.

11:00.720 --> 11:04.200
And this is one of the reasons that the Elm architecture is nice to use, is that we have

11:04.200 --> 11:05.560
the single source of truth.

11:05.560 --> 11:09.320
We don't have to go around syncing a bunch of different disparate pieces of state.

11:09.320 --> 11:13.080
Like we might if we had something that were, you know, that is like one of the sources

11:13.080 --> 11:16.040
of truth and then we have a lot of other ones sprinkled around.

11:16.040 --> 11:17.040
So this is a good thing.

11:17.040 --> 11:18.960
This helps us out.

11:18.960 --> 11:21.640
So this brings me to my other question from earlier.

11:21.640 --> 11:26.040
Like when might model end up with multiple sources of truth anyway?

11:26.040 --> 11:30.520
Like when might it go from being the single source of truth to being a store that contains

11:30.520 --> 11:34.680
multiple values, each of which refer to the same piece of information and which might

11:34.720 --> 11:38.720
have different values for that piece of information depending on which part of the model I look

11:38.720 --> 11:40.760
at?

11:40.760 --> 11:44.440
Well one case where this might genuinely want to happen is caching.

11:44.440 --> 11:47.240
So and this is something that I would do for performance.

11:47.240 --> 11:50.880
So like basically let's say I have some sort of really expensive calculation that I'm

11:50.880 --> 11:52.960
doing using model data.

11:52.960 --> 11:55.920
Really in web applications this almost never happens but it's conceivable.

11:55.920 --> 12:00.200
I could have some really expensive thing that I have to do like 60 frames per second all

12:00.200 --> 12:02.880
the time using data from the model.

12:02.880 --> 12:07.240
And I can't cache it with HTML lazy for some reason but I mean usually I can and if I can

12:07.240 --> 12:10.240
that's certainly how I want to do it because that's the cache that's very nicely managed

12:10.240 --> 12:11.240
by the Elm runtime.

12:11.240 --> 12:14.800
I don't have to think about caching validation which is one of the famously hard problems

12:14.800 --> 12:20.880
in computer science and this calculation is so expensive that it's a performance bottleneck

12:20.880 --> 12:21.880
in practice.

12:21.880 --> 12:24.840
And now we're into the territory of extremely, extremely, extremely unlikely to the extremely

12:24.840 --> 12:31.120
power because really when we're talking about performance problems it's pretty much always

12:31.120 --> 12:33.000
to do with rendering stuff.

12:33.000 --> 12:36.320
It's basically never to do with calculations like this in practice.

12:36.320 --> 12:39.440
But let's say I did actually end up with something like that.

12:39.440 --> 12:43.640
This is one of the things that caching is used for is you have a piece of state that says

12:43.640 --> 12:48.280
I am sort of an intermediate value, some sort of incremental calculation and then I can

12:48.280 --> 12:51.640
base future calculations on that just like incrementing and decrementing rather than

12:51.640 --> 12:54.520
having to rebuild it all from scratch.

12:54.520 --> 12:59.920
So yes it's not like you should never, ever, ever in a bazillion years have duplicate information

12:59.920 --> 13:00.920
in the model.

13:00.920 --> 13:04.400
There is a use case but it's pretty rare in practice.

13:04.400 --> 13:08.440
So that's also good news because it means we can have a single source of truth pretty

13:08.440 --> 13:10.160
much all the time.

13:10.160 --> 13:12.600
So how about relational data that gets stored in the model?

13:12.600 --> 13:16.800
That is to say pieces of data where we have different pieces of information in the model

13:16.800 --> 13:19.040
but they relate to one another in some way.

13:19.040 --> 13:23.000
So let's look at an example of this.

13:23.000 --> 13:24.000
Relational data.

13:24.000 --> 13:29.280
So I work in a company called No Red Ink and we make stuff for English teachers.

13:29.280 --> 13:33.080
Now let's say hypothetically, just for the purposes of this example, that we decided

13:33.080 --> 13:38.360
to sort of like broaden our scope a little bit and we decided to introduce a new feature

13:38.360 --> 13:43.040
which is not English related but actually it's field trip management.

13:43.040 --> 13:47.720
This is why I'm not in charge of the product team.

13:47.720 --> 13:52.040
So we're going to build this new feature that's going to allow teachers to manage a field trip

13:52.040 --> 13:56.160
for their students where they take everybody on a bus and they go out somewhere interesting

13:56.160 --> 13:58.560
for the day and learn things there.

13:58.560 --> 14:03.160
So we've got an all day field trip coming up and the teacher wants to answer the question

14:03.160 --> 14:06.800
which students are going, sort of manage this and check off, okay, these students are going,

14:06.800 --> 14:07.880
these students are not going.

14:07.880 --> 14:11.000
So let's look at this from a data modeling perspective.

14:11.000 --> 14:16.680
So let's say we've got one of our students named Richard Feldman, going is false which

14:16.680 --> 14:20.160
is why he's making that face.

14:20.160 --> 14:23.240
Kid looks like a troublemaker.

14:23.240 --> 14:25.080
So this is our very simple data model.

14:25.080 --> 14:28.440
We have name which is a string and going which is a boolean.

14:28.440 --> 14:31.480
And for our purposes, that's going to be enough.

14:31.480 --> 14:33.760
And then the teacher has multiple courses.

14:33.760 --> 14:36.360
So let's say a teacher has a course called second period English.

14:36.360 --> 14:42.000
It's a very common name for a course that we see in practice and the teacher has a couple

14:42.000 --> 14:43.000
of students in that course.

14:43.000 --> 14:49.680
So R. Feldman, B. Knowles, A. Einstein and they can sort of check and uncheck which students

14:49.680 --> 14:52.040
are going to be going on this field trip.

14:52.040 --> 14:53.280
This is the UI we're building.

14:53.280 --> 14:55.960
They might have another course called fifth period history.

14:55.960 --> 14:59.600
So sometimes we have teachers who have, they're not dedicated English teachers.

14:59.600 --> 15:03.120
They have some courses that are English and then some courses that are another subject.

15:03.120 --> 15:06.520
And sometimes they use no reading because we teach writing among other things.

15:06.520 --> 15:09.720
And so they want their history students to be able to write more effective essays.

15:09.720 --> 15:14.280
So they'll have no reading activated for both their history course and their English course.

15:14.280 --> 15:17.560
And of course, if you're teaching multiple subjects, you can have the same student in

15:17.560 --> 15:18.560
multiple courses.

15:18.560 --> 15:22.800
So Richard Feldman could be in second period English as well as fifth period history in

15:22.800 --> 15:26.760
addition to some other number of students.

15:26.760 --> 15:29.520
So this is an entirely plausible scenario that we might end up with.

15:29.520 --> 15:32.960
And of course, this is relational data that we have students have a relationship to the

15:32.960 --> 15:36.000
course and also we have some sort of notion of identity.

15:36.000 --> 15:39.640
Like Richard Feldman is the same student whether he's in second period English or in fifth

15:39.640 --> 15:41.760
period history.

15:41.760 --> 15:45.040
So if the teacher checks one of these boxes because it's the same person, like either

15:45.040 --> 15:48.160
he's going on the field trip or he's not and it's an all day field trip.

15:48.160 --> 15:52.160
So certainly he's not going to be going for second period but not fifth period.

15:52.160 --> 15:56.360
So if the teacher checks one of the boxes because of the relationships innate in this

15:56.360 --> 15:58.960
data, it should check both of the boxes.

15:58.960 --> 16:01.720
That's otherwise, you know, we've got some sort of mistake.

16:01.720 --> 16:05.840
We should never end up with the teacher seeing this in their UI or else we've done something

16:05.840 --> 16:06.840
wrong.

16:06.840 --> 16:08.920
This would be a synchronization bug.

16:08.920 --> 16:10.520
Okay.

16:10.520 --> 16:15.360
So in JavaScript, the way that I might have done this is I would say something like going

16:15.360 --> 16:19.280
back to the very beginning of the talk, courses brackets zero dot students brackets zero dot

16:19.280 --> 16:20.600
going equals true.

16:20.600 --> 16:26.400
Which is to say the first student in the first course is now going on the field trip.

16:26.400 --> 16:30.200
When I check that box, that's what we've changed about our data model.

16:30.200 --> 16:34.440
Now if I do this and I put into a REPL courses brackets zero dot students brackets zero, it

16:34.440 --> 16:38.360
would now say, hey, this student is now going, great.

16:38.360 --> 16:42.960
And also, if I said courses bracket one, which is to say fifth period English dot students

16:42.960 --> 16:46.680
brackets zero, it would also say that that student is going.

16:46.680 --> 16:51.200
And the reason for that is that students in both cases are mutable references in JavaScript.

16:51.200 --> 16:55.480
These are JavaScript objects, JavaScript objects are mutable, and they store mutable references

16:55.480 --> 16:57.280
to other objects.

16:57.280 --> 17:00.960
So both of these are actually pointing to the same student in memory, which means if

17:00.960 --> 17:03.600
I change the one, it's going to change the other as well.

17:03.600 --> 17:07.680
Now this has various downsides that we're probably familiar with, like you pass something

17:07.680 --> 17:11.480
to a function, you're not sure if that function is going to mutate or not, plenty of downsides,

17:11.480 --> 17:15.120
but this is one of the upsides when it comes to data consistency.

17:15.160 --> 17:19.960
It means that when I mutate one, it automatically mutates all the others at the same time for

17:19.960 --> 17:20.960
me.

17:20.960 --> 17:25.600
So this is an example of relational data with a single source of truth.

17:25.600 --> 17:30.280
We don't actually have any duplicate information in this data model that we've built in this

17:30.280 --> 17:32.480
sort of JavaScript version.

17:32.480 --> 17:37.000
Okay, so now I'm, you know, was a JavaScript programmer, now I've transitioned to an Elm

17:37.000 --> 17:40.680
programmer, and so now I'm thinking in terms of immutable data.

17:40.680 --> 17:44.320
So one way that we might model this in Elm, and probably the way that I would have modeled

17:44.360 --> 17:48.920
it when I was starting out, I would say type alias student, name colon string, going is

17:48.920 --> 17:55.760
a Boolean, then I'd have type alias course, name is a string, students is a list of students,

17:55.760 --> 18:00.560
so we have nested records here, and then finally I would have my model which would have courses,

18:00.560 --> 18:03.960
which is a list of course, and then various other things, but at least within the scope

18:03.960 --> 18:07.680
of what we're talking about here, these are the relevant structures that we'd be dealing

18:07.680 --> 18:08.680
with.

18:08.680 --> 18:13.680
Now, believe it or not, already we've introduced multiple sources of truth.

18:13.720 --> 18:17.600
Even though this basically looks like a description of the same sort of schema that we had in

18:17.600 --> 18:21.960
the JavaScript version, just by virtue of the fact that we've gone from mutable objects

18:21.960 --> 18:26.120
to immutable data, we have now accidentally introduced multiple sources of truth.

18:26.120 --> 18:31.120
And this is kind of an easy thing to do, at least it was for me, when going from JavaScript

18:31.120 --> 18:34.480
to Elm because I'm like, oh, well, records look like objects, so I'll just take the thing

18:34.480 --> 18:38.000
that I would have done with an object and I'll just do it with a record.

18:38.000 --> 18:42.800
But it turns out that that mutable to immutable characteristic is actually significant implications

18:43.800 --> 18:49.800
to sort of do a more apples to apples transition, let's go from the JavaScript object that

18:49.800 --> 18:55.800
we did before to the JavaScript object notation, better known as JSON, because JavaScript

18:55.800 --> 18:59.640
objects are mutable references, but JSON is actually immutable data, which it sort of

18:59.640 --> 19:00.640
has to be to serialize.

19:00.640 --> 19:04.360
If you want to serialize mutable references to memory locations and just write them straight

19:04.360 --> 19:07.720
to the disk, it's probably not likely to work out very well when you try to deserialize

19:07.720 --> 19:08.720
them.

19:08.720 --> 19:13.760
JSON is immutable despite having the same structure as JavaScript objects.

19:13.760 --> 19:15.240
So let's look at the JSON version of this.

19:15.240 --> 19:19.920
So we have courses, we have name, second period English, students, and then an array, name

19:19.920 --> 19:25.840
Richard Feldman going false, and then another course, name, fifth period history, students,

19:25.840 --> 19:28.560
name Richard Feldman going false.

19:28.560 --> 19:32.800
So now we can kind of see more clearly that we actually do, in fact, have duplicated data

19:32.800 --> 19:33.800
now.

19:33.800 --> 19:38.680
Like before, both of those students were pointing to the same point in memory, but now we actually

19:38.680 --> 19:41.560
have two different independent pieces of data.

19:41.560 --> 19:43.240
So that means that they can now get out of sync.

19:43.240 --> 19:47.600
I can change one of them to true without changing the other one to false.

19:47.600 --> 19:49.520
That's a potential problem.

19:49.520 --> 19:55.600
So objects have mutable references, whereas records, and JSON, have immutable records.

19:55.600 --> 19:59.400
So objects have this upside of sort of implicit synchronization that sort of automatically

19:59.400 --> 20:04.400
happens whenever you change something, whereas records also have their own set of upsides,

20:04.400 --> 20:08.280
really cheap copying, equality checks that can just do reference equality, so on and

20:08.280 --> 20:09.360
so forth.

20:09.360 --> 20:13.400
But this is something that we have to be aware of when we're going from objects to records.

20:13.400 --> 20:15.960
This is a pretty significant difference.

20:15.960 --> 20:19.880
So let's move along to immutable relational data.

20:19.880 --> 20:24.200
So what are we going to do differently when we are transitioning to the world of immutability?

20:24.200 --> 20:27.080
Okay, so this was sort of the problem that we ran into.

20:27.080 --> 20:29.840
We had this duplicated data, and it could get out of sync.

20:29.840 --> 20:33.400
We could have going is true in one case and going is false in the other case, and that

20:33.400 --> 20:36.080
shouldn't be possible because it's the same student.

20:36.080 --> 20:38.920
Whether he's going on the field trip or he's not.

20:38.920 --> 20:44.080
So one way we could create a single source of truth out of this is by changing the JSON

20:44.080 --> 20:46.680
to look like this.

20:46.680 --> 20:47.920
So let's look at these differences here.

20:47.920 --> 20:54.040
So the first thing is we've introduced explicit identifiers for what the student refers to.

20:54.040 --> 20:58.760
We're no longer using memory references, we're actually using identifiers as references.

20:58.760 --> 21:02.800
So here we have students is just an array of IDs.

21:02.800 --> 21:08.200
So ID 217, we see down at the bottom there, refers to Richard Feldman.

21:08.200 --> 21:11.760
And that's the only place that Richard Feldman appears in this whole data model.

21:11.760 --> 21:15.880
Everywhere else it's an identifier referring to that one single source of truth.

21:15.880 --> 21:22.080
So we're using explicit identifiers to reference a single source of truth in a completely immutable

21:22.080 --> 21:23.800
way.

21:23.800 --> 21:30.960
So let's translate that idea into L. So we've got our type alias student course model.

21:30.960 --> 21:32.080
So this is what we had before.

21:32.080 --> 21:35.760
We had a list of students under course and we had a list of courses under model.

21:35.760 --> 21:37.920
So we're going to tweak that a little bit.

21:37.920 --> 21:41.720
Instead we're going to go from students to student IDs, which is going to be a list

21:41.720 --> 21:43.600
of student ID values.

21:43.600 --> 21:48.000
So student ID type could be whatever you want, you know, integers as we saw in the JSON example,

21:48.000 --> 21:51.480
strings, custom types, anything you want.

21:51.480 --> 21:55.560
Inside the model we're going to have students as a new value in the model.

21:55.560 --> 21:59.360
This is our single source of truth for all of our students across the entire model.

21:59.360 --> 22:01.280
And it's going to be a dictionary.

22:01.320 --> 22:04.760
So we're going to change on that same student ID and then having a single source of truth

22:04.760 --> 22:09.720
be the value of that particular student stored in that dictionary.

22:09.720 --> 22:13.320
By the way, one thing we would also want to do here, I think, that can sort of take this

22:13.320 --> 22:16.920
data model a little bit one step further, is to change from a list of student IDs to

22:16.920 --> 22:18.400
a set of student IDs.

22:18.400 --> 22:22.680
Because really, like, would it ever be useful to have the same student appear multiple times

22:22.680 --> 22:23.880
in the same course?

22:23.880 --> 22:24.880
Not really.

22:24.880 --> 22:26.800
That should be a set because sets have uniqueness.

22:27.200 --> 22:33.560
We should only have at most one student ID of the same value inside each course.

22:33.560 --> 22:37.520
OK, so now let's write a function called students in course that's going to take one

22:37.520 --> 22:42.280
of these courses, maybe something inside update, and it's going to return a list of

22:42.280 --> 22:43.280
students.

22:43.280 --> 22:46.960
So this is sort of our replacement for we want to work in terms of a list of students,

22:46.960 --> 22:50.320
which is why we originally said courses just have a list of students, but now we're just

22:50.320 --> 22:52.840
going to do a function to do the same thing.

22:52.840 --> 22:54.240
So it's going to take a course as an argument.

22:54.680 --> 22:57.800
And it's going to start off by doing a dicks.filter.

22:57.800 --> 22:59.240
What's it going to filter on?

22:59.240 --> 23:03.360
It's going to say, OK, I'm going to look at each of the students that I have, and I'm

23:03.360 --> 23:06.480
going to say, am I in this particular course?

23:06.480 --> 23:11.200
The way I can tell if I'm in this particular course is set.member, that particular student's

23:11.200 --> 23:15.040
ID, and the course's set of student IDs.

23:15.040 --> 23:19.560
So this is going to filter that dictionary of all the students down to just the ones

23:19.560 --> 23:21.320
who are in that particular course.

23:21.320 --> 23:22.200
And that's it.

23:22.240 --> 23:27.200
We have now gone from our single source of truth of all students in one expression down

23:27.200 --> 23:32.280
to a single source of truth for the list of students that are in that particular course.

23:32.280 --> 23:35.280
And now we can do whatever we want with that list of students, whatever we would have done

23:35.280 --> 23:38.720
previously by courses.students.

23:38.720 --> 23:41.880
And then, of course, if we want to actually get it from a dictionary to a list of students,

23:41.880 --> 23:44.600
we'd pipe it to dicks.values.

23:44.600 --> 23:49.320
OK, so here we have an example of immutable relational data where we've maintained a single

23:49.320 --> 23:52.320
source of truth, which means no synchronization problems.

23:52.320 --> 23:55.800
Also it means no nested record updates, which is cool.

23:55.800 --> 24:00.000
But basically, we no longer have that whole series of problems where we have to keep things

24:00.000 --> 24:04.800
updated, keep things in sync, detect errors, resolve conflicts, and so on and so forth.

24:04.800 --> 24:07.880
OK, but what about like more complex relationships?

24:07.880 --> 24:10.640
What if we had the JavaScript equivalent of something like this?

24:10.640 --> 24:15.320
Courses bracket zero.students bracket three.assignments bracket two.is done, something where we have

24:15.320 --> 24:19.200
lots of relationships and we're trying to merge them all together.

24:19.200 --> 24:21.080
How does this sort of like scale?

24:21.080 --> 24:25.960
Well, there's actually, as it turns out, an entire sort of field of study and a lot

24:25.960 --> 24:29.720
of implementations that work with these types of questions.

24:29.720 --> 24:33.120
If anyone recognizes this logo, this is a good elephant.

24:33.120 --> 24:34.120
This is PostgreSQL.

24:34.120 --> 24:39.760
You also got other databases like MySQL, SQLites, and it turns out relational data has been

24:39.760 --> 24:44.680
well studied and explored by relational databases.

24:44.680 --> 24:52.960
And we can, what's the word I'm looking for, steal shamelessly from the things that they've

24:52.960 --> 24:57.400
learned over the years about dealing with relational data without dealing with mutable

24:57.400 --> 25:01.280
references, which they don't use because they need to serialize everything to the disk.

25:01.280 --> 25:05.920
So what if we think about dictionaries as sort of like an analogy for database tables?

25:05.920 --> 25:06.920
What could that do for us?

25:06.920 --> 25:11.440
So what if we thought about things like select, where, and join in terms of SQL, and then

25:11.440 --> 25:16.760
we translated those to dictionary concepts like get, filter, intersect, and so forth.

25:16.760 --> 25:17.760
How might that look?

25:17.760 --> 25:20.800
So here's a really, really simple SQL query.

25:20.800 --> 25:22.560
Select count star from users.

25:22.560 --> 25:25.920
So that's sort of the equivalent of saying like, tick dot size users.

25:25.920 --> 25:26.920
Ha.

25:26.920 --> 25:28.800
Stake in the slides.

25:28.800 --> 25:31.480
Select count star from users where age is greater than or equal to 18.

25:31.480 --> 25:34.680
This would be voting age users in the U.S.

25:34.680 --> 25:38.840
So the equivalent to that, dicks dot filter is voting age users, which is kind of nice

25:38.840 --> 25:42.280
because it's actually a little bit more descriptive than the greater than or equal to 18.

25:42.280 --> 25:43.680
And then pipe that to dicks dot size.

25:43.680 --> 25:46.200
I got it right on this slide.

25:46.200 --> 25:49.560
So this is like a slightly more advanced query.

25:49.560 --> 25:52.040
So what if we just, okay, let's just go for it.

25:52.040 --> 25:53.040
Let's do joins.

25:53.040 --> 25:54.040
Let's do where.

25:54.040 --> 25:55.600
Let's just get some more stuff in there.

25:55.600 --> 25:58.560
Select count star from users where age is greater than or equal to 18.

25:58.560 --> 26:05.000
So this is voting age users inner join residence on residence.id equals users.id where residence.city

26:05.000 --> 26:06.000
equals stl.

26:06.000 --> 26:13.280
And now we're saying who are, like, how many users are a voting age and live in St. Louis?

26:13.280 --> 26:15.280
How do we do that using dictionaries?

26:15.280 --> 26:20.000
Well, let's start by defining a couple of type aliases because we can't just, you know,

26:20.000 --> 26:21.000
use a plain old dictionary.

26:21.000 --> 26:23.040
We're going to need to get some records involved here.

26:23.040 --> 26:26.000
So let's say we have user, which is user ID and age.

26:26.000 --> 26:30.680
And then we also have a model which has users, which is a dictionary between user ID and

26:30.680 --> 26:31.680
user.

26:31.680 --> 26:35.800
And we have residence, which is a dictionary between user ID and city ID or user ID and

26:35.800 --> 26:36.840
city.

26:36.840 --> 26:38.840
So these are, like, examples.

26:38.840 --> 26:42.240
You can imagine many more dictionaries all at the top level, but you can model as many

26:42.240 --> 26:46.720
relationships between as many different entities as we want, just like how databases have tables

26:46.720 --> 26:51.600
all at the top level, which model relationships between as many different tables as you want.

26:51.600 --> 26:54.280
So here's how we might implement this query.

26:54.280 --> 26:57.640
So we could say locals, which is to say St. Louis locals or St. Louisans or if you're

26:57.640 --> 27:00.720
part of Nellie's crew, St. Lunatics.

27:00.720 --> 27:05.120
And we would say dix.filter, user ID, city, so that user ID being the key and then the

27:05.120 --> 27:08.920
city being the value, city.name, double equals stl.

27:08.920 --> 27:13.320
So this is going to give us, among all the residents, only those whose city is St. Louis.

27:13.320 --> 27:18.120
Then we can do dix.filter on isvotingage, model.users, just like before.

27:18.120 --> 27:21.840
So now we have a dictionary of all the users who are voting age.

27:21.840 --> 27:27.520
And then to do the join, we do dix.intersect locals, which is going to take all of the

27:27.520 --> 27:31.680
users that we've filtered out for just the ones that have voting age, and then also all

27:31.680 --> 27:36.520
of those that have city name of St. Louis, because that's where they live.

27:36.520 --> 27:38.840
And then finally, dix.size.

27:38.840 --> 27:42.600
So just by using a couple of simple expressions, we end up with being able to essentially do

27:42.600 --> 27:46.040
the same types of things that we could do in a relational database.

27:46.040 --> 27:50.120
This is like pretty powerful stuff, and it's all with a single source of truth.

27:50.120 --> 27:51.880
And no nested record updates.

27:51.880 --> 27:52.880
Pretty cool.

27:52.880 --> 27:53.880
Okay.

27:53.880 --> 27:57.400
If you're curious to learn some more data modeling techniques, completely shameless

27:57.400 --> 27:58.400
plug.

27:58.400 --> 28:01.760
There's this book by a dude, Elman Action.

28:01.760 --> 28:02.760
So check it out.

28:02.760 --> 28:03.760
Okay.

28:03.760 --> 28:04.760
So let's recap.

28:04.760 --> 28:09.280
So first we talked about state synchronization, sort of some of the problems, some of the

28:09.280 --> 28:10.280
pitfalls.

28:10.280 --> 28:14.440
We talked about relational data, and then we talked about immutable relational data without

28:14.440 --> 28:16.440
using mutable references.

28:16.440 --> 28:20.640
We talked about how a single source of truth means there's nothing to synchronize.

28:20.640 --> 28:24.360
All of those problems that we saw with state synchronization, completely out the window,

28:24.360 --> 28:26.920
none of those tweet-related problems.

28:26.960 --> 28:30.920
We talked about the synchronization work that has to be done if we do have multiple sources

28:30.920 --> 28:34.880
of truth, making updates, detecting errors, resolving conflicts, gracefully recovering

28:34.880 --> 28:36.440
in the ideal case.

28:36.440 --> 28:40.040
And we talked about how relational data can be done with a single source of truth, and

28:40.040 --> 28:43.840
in fact, immutable relational data can still be done with a single source of truth, which

28:43.840 --> 28:48.160
is really what we would prefer to do if we have the option.

28:48.160 --> 28:52.400
Then we talked about dictionaries as tables, and sort of how we can use the metaphor of

28:52.400 --> 28:56.760
tables that appear in relational databases to do the same kinds of data modeling activities

28:57.040 --> 28:58.040
using dictionaries.

28:58.040 --> 29:01.840
And finally, we come back to the original two questions that I had.

29:01.840 --> 29:04.240
When should I put duplicate information in my model?

29:04.240 --> 29:08.800
The answer is basically almost never, unless performance absolutely demands a cache, and

29:08.800 --> 29:12.480
I'm really sure I have a performance problem, and I really just can't avoid it.

29:12.480 --> 29:15.840
That's really the only situation I've ever come across where I would say that that's

29:15.840 --> 29:17.560
a good idea.

29:17.560 --> 29:19.720
And how would I do something like this in Elm?

29:19.720 --> 29:25.600
Of course, it's bracket zero.studentbracketzero.selected equals true using dictionaries as tables.

29:25.600 --> 29:26.640
Thanks very much.

