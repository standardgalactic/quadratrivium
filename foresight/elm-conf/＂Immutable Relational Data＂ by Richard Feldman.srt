1
00:00:00,000 --> 00:00:13,000
All right, so this is immutable relational data.

2
00:00:13,000 --> 00:00:15,080
I'm Richard Feldman.

3
00:00:15,080 --> 00:00:19,520
So when I was first getting into Elm, there were two questions that I had, like very early

4
00:00:19,520 --> 00:00:23,200
on, things that I didn't really know how to do coming from JavaScript.

5
00:00:23,200 --> 00:00:26,560
And one was, how do I do this?

6
00:00:26,560 --> 00:00:32,160
Like I want to do some equivalent of courses bracket zero dot students bracket zero dot

7
00:00:32,160 --> 00:00:33,400
selected equals true.

8
00:00:33,400 --> 00:00:38,480
Like, how do I, there's a little nested record update syntax, like how do I, I don't know,

9
00:00:38,480 --> 00:00:41,080
I couldn't quite figure that out at first.

10
00:00:41,080 --> 00:00:45,720
And then another question I had was, when, if ever, should I put duplicate information

11
00:00:45,720 --> 00:00:46,720
in my model?

12
00:00:46,720 --> 00:00:49,720
Like should I ever have the same piece of information in two different places in my model?

13
00:00:49,720 --> 00:00:50,720
Is that a bad idea?

14
00:00:50,720 --> 00:00:52,720
Is that, I don't know, what are the trade-offs?

15
00:00:52,720 --> 00:00:54,840
I didn't really know.

16
00:00:54,840 --> 00:00:58,240
And as I got more into Elm, I kind of learned about different techniques for modeling data

17
00:00:58,240 --> 00:00:59,240
and so forth.

18
00:00:59,240 --> 00:01:04,440
And I ended up discovering that these two questions turned out to be related.

19
00:01:04,440 --> 00:01:07,120
And they have to do with the title of this talk.

20
00:01:07,120 --> 00:01:11,280
So we're going to go through sort of my progression of like how I learned about these things.

21
00:01:11,280 --> 00:01:12,760
And we're going to start with state synchronization.

22
00:01:12,760 --> 00:01:17,000
And then we're going to move on to talking about relational data in general.

23
00:01:17,000 --> 00:01:21,600
And then finally end up with immutable relational data and some techniques for dealing with

24
00:01:21,600 --> 00:01:22,600
it.

25
00:01:22,600 --> 00:01:23,600
Okay.

26
00:01:23,600 --> 00:01:25,360
Let's start with state synchronization.

27
00:01:25,360 --> 00:01:26,360
Okay.

28
00:01:26,360 --> 00:01:29,680
So some time ago, a friend of mine tweeted me.

29
00:01:29,680 --> 00:01:36,080
They said, hey, RT Feldman, remember that time in college when we were late to a potluck?

30
00:01:36,080 --> 00:01:43,120
And we went to a Wendy's drive-thru and got 20 orders of $1 five-piece nuggets?

31
00:01:43,120 --> 00:01:46,440
So we showed up to the potluck with 100 chicken nuggets, LOL.

32
00:01:46,440 --> 00:01:47,440
That's a true story.

33
00:01:47,440 --> 00:01:48,440
That did happen in college.

34
00:01:48,440 --> 00:01:54,000
So I saw this, I was like, oh, yeah, that was a good time.

35
00:01:54,000 --> 00:01:57,760
So I like, you know, went to the like button and hit like.

36
00:01:57,760 --> 00:01:58,760
But I got an error.

37
00:01:58,760 --> 00:02:00,280
I was like, no, you can't do that.

38
00:02:00,280 --> 00:02:01,280
It's like, what?

39
00:02:01,280 --> 00:02:02,280
No, no, for real.

40
00:02:02,280 --> 00:02:03,280
I like it.

41
00:02:03,280 --> 00:02:04,280
It's good times.

42
00:02:04,280 --> 00:02:06,280
So I hit the button again.

43
00:02:06,280 --> 00:02:07,280
It's error.

44
00:02:07,280 --> 00:02:09,160
Oh, come on.

45
00:02:09,160 --> 00:02:13,920
So as it turned out, what had happened was my friend, after posting this, decided this

46
00:02:13,920 --> 00:02:17,520
was maybe not something the entire internet needed to know.

47
00:02:17,520 --> 00:02:19,240
And so they ended up deleting it.

48
00:02:19,240 --> 00:02:25,400
And so they deleted it sometime between when I saw it and when I attempted to click like,

49
00:02:25,400 --> 00:02:27,200
resulting in the error.

50
00:02:27,200 --> 00:02:31,360
So this is essentially a sort of a mismatch between the client and the server.

51
00:02:31,360 --> 00:02:34,880
So my client, the web browser, was like, oh, yeah, this tweet totally exists.

52
00:02:34,880 --> 00:02:35,880
Sure.

53
00:02:35,880 --> 00:02:39,040
Here's a nice lovely like button in case you'd like to like it.

54
00:02:39,040 --> 00:02:41,720
But unfortunately, the server had a different idea, the server was like, oh, that's gone.

55
00:02:41,720 --> 00:02:42,720
What are you talking about?

56
00:02:42,720 --> 00:02:44,840
Like, that's been deleted for a while.

57
00:02:44,840 --> 00:02:49,240
So there was this mismatch between the two, and that led to the error.

58
00:02:49,240 --> 00:02:51,560
So this is a form of synchronization problem.

59
00:02:51,560 --> 00:02:55,960
Like, we had a synchronization mismatch between the client and the server.

60
00:02:55,960 --> 00:03:00,480
And when we have multiple sources of truth, we sort of need to synchronize them or else

61
00:03:00,480 --> 00:03:02,120
we can get this type of error.

62
00:03:02,120 --> 00:03:06,120
Now if we have multiple sources of truth, such as the client and the server, and they

63
00:03:06,120 --> 00:03:10,680
agree like if the client says the tweet exists and the server also believes that it exists,

64
00:03:10,680 --> 00:03:11,680
that's okay.

65
00:03:11,680 --> 00:03:12,680
That's no problem.

66
00:03:12,880 --> 00:03:16,240
The typical thing, which is why, you know, I was surprised to see this error and not

67
00:03:16,240 --> 00:03:19,920
just like, oh, yeah, another one of these just happens to me constantly.

68
00:03:19,920 --> 00:03:24,480
Usually despite the fact that there are multiple sources of truth, they're staying in sync

69
00:03:24,480 --> 00:03:25,800
so it doesn't actually matter.

70
00:03:25,800 --> 00:03:28,800
It doesn't sort of affect me.

71
00:03:28,800 --> 00:03:30,680
It's also fine if they both agree that it's gone.

72
00:03:30,680 --> 00:03:34,120
Like, eventually I refresh the page and then I saw, oh, the thing's gone.

73
00:03:34,120 --> 00:03:36,440
So they got synced up and then it was again, no problem.

74
00:03:36,440 --> 00:03:39,640
I was back to being in sync with the server and the multiple sources of truth were not

75
00:03:39,680 --> 00:03:43,160
really causing any problems there for me.

76
00:03:43,160 --> 00:03:46,720
So basically when multiple sources of truth remain synchronized, it's okay.

77
00:03:46,720 --> 00:03:50,520
There's sort of no symptoms, no problems that the end user is faced with.

78
00:03:50,520 --> 00:03:56,560
However, when they get out of sync, as happened to me in the tweet, then that causes a problem.

79
00:03:56,560 --> 00:04:00,200
So single sources of truth sort of don't have this issue.

80
00:04:00,200 --> 00:04:03,520
There's no synchronization because there's nothing to synchronize.

81
00:04:03,520 --> 00:04:05,480
It's just one source of truth.

82
00:04:05,480 --> 00:04:09,320
So this entire class of errors goes away, which is one of the things that's nice about

83
00:04:09,320 --> 00:04:12,240
having a single source of truth.

84
00:04:12,240 --> 00:04:15,400
So synchronization is sort of error prone.

85
00:04:15,400 --> 00:04:16,880
This is one of the problems with it.

86
00:04:16,880 --> 00:04:19,080
As we saw, this is sort of a case in point.

87
00:04:19,080 --> 00:04:21,400
This is a synchronization error.

88
00:04:21,400 --> 00:04:24,400
And these sort of things can happen all the time when you have to synchronize two pieces

89
00:04:24,400 --> 00:04:27,440
of information because there are multiple sources of truth.

90
00:04:27,440 --> 00:04:32,840
Which sort of begs the question, is it necessarily avoidable to have multiple sources of truth?

91
00:04:32,840 --> 00:04:36,400
Sometimes do we have to have multiple sources of truth even if we would prefer to have a

92
00:04:36,400 --> 00:04:39,760
single source of truth and not have to synchronize anything?

93
00:04:39,760 --> 00:04:45,200
Let's take this client server app as an example and see if we can arrange things such that

94
00:04:45,200 --> 00:04:47,200
we have a single source of truth.

95
00:04:47,200 --> 00:04:48,200
This is our goal.

96
00:04:48,200 --> 00:04:51,760
We're going to have a client and a server, multiple clients and a server, and we're going

97
00:04:51,760 --> 00:04:54,640
to have a single source of truth that's shared between all of them such that there's nothing

98
00:04:54,640 --> 00:04:56,720
that we need to synchronize.

99
00:04:56,720 --> 00:04:59,520
So to do this, probably what we're going to have to do is say, okay, the server is going

100
00:04:59,520 --> 00:05:01,080
to have to take care of rendering the UI.

101
00:05:01,080 --> 00:05:04,480
That's going to have to be the source of truth because that's where the database lives.

102
00:05:04,840 --> 00:05:10,320
I mean, if anyone ever disagrees with the database about what is true, the database is

103
00:05:10,320 --> 00:05:11,320
going to be right.

104
00:05:11,320 --> 00:05:15,200
So we're going to have the server render HTML like it's 15 years ago and it's just going

105
00:05:15,200 --> 00:05:19,040
to send it directly to the client on every single user interaction.

106
00:05:19,040 --> 00:05:22,200
Like I click anything and the server is going to render some HTML and send it to the client.

107
00:05:22,200 --> 00:05:27,280
So that way the server is the single source of truth, kind of.

108
00:05:27,280 --> 00:05:31,480
Problem is that sending stuff from the server to the client takes time.

109
00:05:31,480 --> 00:05:33,920
It doesn't just like appear on my screen instantaneously.

110
00:05:34,360 --> 00:05:38,640
There's like networks and packets and like latency and things like that.

111
00:05:38,640 --> 00:05:42,960
And in fact, there's so much of that that it's like perceptible, which in turn means

112
00:05:42,960 --> 00:05:46,640
that it's entirely possible that over the course of that network transmission while

113
00:05:46,640 --> 00:05:52,240
the currently up-to-date perfect single source of truth UI is headed towards my browser,

114
00:05:52,240 --> 00:05:56,920
my friend deletes the tweet, and now I am once again out of sync.

115
00:05:56,920 --> 00:06:00,720
So even trying as hard as we possibly can to have a single source of truth with a client

116
00:06:00,720 --> 00:06:03,800
server application, it's just not possible.

117
00:06:03,800 --> 00:06:07,720
You cannot have a single source of truth when you've got a client and a server.

118
00:06:07,720 --> 00:06:10,360
You sort of must have synchronization.

119
00:06:10,360 --> 00:06:15,400
It's completely unavoidable by the nature of this architecture, which is kind of a bummer

120
00:06:15,400 --> 00:06:18,160
because hey, clients and servers are nice.

121
00:06:18,160 --> 00:06:21,320
So we're sort of stuck synchronizing them.

122
00:06:21,320 --> 00:06:25,280
And again, even if it is unavoidable, synchronization is still error-prone.

123
00:06:25,280 --> 00:06:28,360
We're still going to have to deal with synchronization errors like this.

124
00:06:28,360 --> 00:06:35,280
So we'd sort of like to handle these synchronization errors in as graceful a way as we can.

125
00:06:35,280 --> 00:06:37,880
And there's sort of different levels to this.

126
00:06:37,880 --> 00:06:40,640
So one is basically just like fail without feedback.

127
00:06:40,640 --> 00:06:44,840
So this is the absolute worst, which is to say the tweet gets deleted and I hit like

128
00:06:44,840 --> 00:06:46,280
and then just nothing happens.

129
00:06:46,280 --> 00:06:48,560
I'm just like, what?

130
00:06:48,560 --> 00:06:51,960
Or you can do what's called optimistic updates where you're just like, I'm going to update

131
00:06:51,960 --> 00:06:55,520
the client state and assume it works out on the server.

132
00:06:55,520 --> 00:06:59,200
This can be even worse and I've been really, really badly burned by this in the past.

133
00:06:59,200 --> 00:07:01,280
That's basically where you hit like and it does the animation.

134
00:07:01,280 --> 00:07:02,720
It's like, yeah, everything worked.

135
00:07:02,720 --> 00:07:04,520
And then later on it just was gone.

136
00:07:04,520 --> 00:07:05,520
What?

137
00:07:05,520 --> 00:07:08,800
And then, you know, so once it actually gets in sync, you find out much after the fact

138
00:07:08,800 --> 00:07:09,800
that there was a problem.

139
00:07:09,800 --> 00:07:14,240
Having had no idea at the time that there was anything wrong, which would have at least

140
00:07:14,240 --> 00:07:15,240
given me a clue.

141
00:07:15,240 --> 00:07:19,360
Like, yeah, I want to try hitting like again in case maybe the server is down or something.

142
00:07:19,360 --> 00:07:24,360
So failing without feedback is sort of the worst way to handle a synchronization error.

143
00:07:24,360 --> 00:07:27,800
We can do a little bit better by at least informing the user that some sort of error

144
00:07:27,800 --> 00:07:28,800
occurred.

145
00:07:28,800 --> 00:07:34,000
Like error, even if you're saying like error 500, that's at least giving me some clue that

146
00:07:34,000 --> 00:07:38,440
something went wrong so I can, you know, react accordingly and not be surprised later on

147
00:07:38,440 --> 00:07:44,360
to discover that there was this mismatch between my expectation and what actually happened.

148
00:07:44,360 --> 00:07:46,800
Even better than that is to explain the problem.

149
00:07:46,800 --> 00:07:51,080
Something like this tweet was deleted before you could like it or maybe something more

150
00:07:51,080 --> 00:07:52,440
concise than that.

151
00:07:52,440 --> 00:07:55,720
But explaining the problem gives the user a better experience to understand, oh, this

152
00:07:55,720 --> 00:07:59,760
is not just like something went wrong, which could be so many different things and lead

153
00:07:59,760 --> 00:08:04,800
me to take completely futile actions such as hammering on the like button.

154
00:08:04,800 --> 00:08:08,360
If they explain it to me and say this tweet was deleted, then I'm like, oh, okay, well,

155
00:08:08,360 --> 00:08:10,720
I'm not going to keep hitting like because it's gone.

156
00:08:10,720 --> 00:08:12,800
I understand that now.

157
00:08:12,800 --> 00:08:16,360
And the best of all would be to explain and then fix the problem.

158
00:08:16,360 --> 00:08:21,640
So basically say, hey, this tweet was deleted and then not leave the UI in a state where

159
00:08:21,640 --> 00:08:24,280
I can continue to hammer on the like button at all.

160
00:08:24,280 --> 00:08:29,520
Say like this tweet was deleted and then actually synchronize, like change it so it doesn't look

161
00:08:29,520 --> 00:08:34,120
like this anymore, maybe gray it out, maybe fade out the whole tweet itself.

162
00:08:34,120 --> 00:08:36,240
There are any number of things you can do.

163
00:08:36,240 --> 00:08:39,200
But these all require different degrees of effort.

164
00:08:39,200 --> 00:08:43,360
So in order to synchronize while also reporting the error, it's not just that the server has

165
00:08:43,360 --> 00:08:44,840
to send back a 500.

166
00:08:44,840 --> 00:08:49,560
It also has to say, here's what the problem was and also describe how to synchronize the

167
00:08:49,560 --> 00:08:54,320
state in some particular format, which my client then has to be looking for and know

168
00:08:54,320 --> 00:08:57,400
to say, oh, I understand that I got this additional data.

169
00:08:57,400 --> 00:09:01,480
Now I can use this to sort of patch my understanding of the world so that I'm now synchronized

170
00:09:01,480 --> 00:09:02,480
with the server.

171
00:09:02,480 --> 00:09:05,040
It's a lot more work to deal with that synchronization error.

172
00:09:05,040 --> 00:09:09,280
And that's not even getting into what happens if we're trying to synchronize across multiple

173
00:09:09,280 --> 00:09:13,160
clients where it's not clear who the source of truth is and we have to resolve conflicts.

174
00:09:13,160 --> 00:09:19,520
So this can be a lot of work, like a lot, a lot of work if you want to do it right.

175
00:09:19,520 --> 00:09:21,360
First of all, you have to make the updates in the first place.

176
00:09:21,360 --> 00:09:24,960
If we have multiple sources of truth and something changes, we have to go around and propagate

177
00:09:24,960 --> 00:09:29,000
those updates to all of the potential places where it could get out of sync.

178
00:09:29,000 --> 00:09:32,320
Once we've done that, then we have to detect errors, figure out if things are out of sync

179
00:09:32,320 --> 00:09:34,400
as they were in the case of this tweet.

180
00:09:34,400 --> 00:09:37,880
And then once we've detected them, then we have to potentially resolve conflicts.

181
00:09:37,880 --> 00:09:42,720
If we have lack of clarity around who is the source of truth, we have multiple clients

182
00:09:42,720 --> 00:09:45,200
who made edits at the same time on the same document.

183
00:09:45,200 --> 00:09:46,200
How do we resolve those?

184
00:09:46,200 --> 00:09:47,400
There's a lot of techniques for doing that.

185
00:09:47,400 --> 00:09:49,600
That's kind of a whole field of study.

186
00:09:49,600 --> 00:09:52,280
And then finally, ideally, gracefully recovering.

187
00:09:52,280 --> 00:09:56,960
So if we want to give people a good user experience or the best user experience we can in the

188
00:09:56,960 --> 00:10:02,720
face of all of these potential synchronization problems, we'll look into a lot of work.

189
00:10:02,720 --> 00:10:06,600
All of which is to say we really want to synchronize as little as possible.

190
00:10:06,600 --> 00:10:09,880
The more we can have single source of truth and not have to deal with any of this and

191
00:10:09,880 --> 00:10:13,520
not have to think about it, not have to worry about the errors, not have to spend time handling

192
00:10:13,520 --> 00:10:18,760
them, resolving conflicts, repairing the state and getting things back in sync, the nicer

193
00:10:18,760 --> 00:10:23,120
our lives are going to be and more likely, the most likely, the better our user experience

194
00:10:23,120 --> 00:10:25,200
is going to be as well.

195
00:10:25,200 --> 00:10:26,400
Okay.

196
00:10:26,400 --> 00:10:29,040
So let's sort of draw a smaller box around this.

197
00:10:29,040 --> 00:10:32,920
We've concluded that it's not possible to have a complete client server application

198
00:10:32,920 --> 00:10:35,200
where we have one single source of truth.

199
00:10:35,200 --> 00:10:39,520
But what if we narrow it down a little bit just to the client UI state?

200
00:10:39,520 --> 00:10:42,440
So if we just draw a box around that, what about now?

201
00:10:42,520 --> 00:10:45,560
We actually can have a single source of truth.

202
00:10:45,560 --> 00:10:50,160
And we as Elm programmers know this because we use the Elm architecture in which we have

203
00:10:50,160 --> 00:10:51,160
a single source of truth.

204
00:10:51,160 --> 00:10:52,320
That's what model's job is.

205
00:10:52,320 --> 00:10:57,600
It is a single atomic immutable value that is the single source of truth for the entire

206
00:10:57,600 --> 00:11:00,720
client application state and everything else is built on that.

207
00:11:00,720 --> 00:11:04,200
And this is one of the reasons that the Elm architecture is nice to use, is that we have

208
00:11:04,200 --> 00:11:05,560
the single source of truth.

209
00:11:05,560 --> 00:11:09,320
We don't have to go around syncing a bunch of different disparate pieces of state.

210
00:11:09,320 --> 00:11:13,080
Like we might if we had something that were, you know, that is like one of the sources

211
00:11:13,080 --> 00:11:16,040
of truth and then we have a lot of other ones sprinkled around.

212
00:11:16,040 --> 00:11:17,040
So this is a good thing.

213
00:11:17,040 --> 00:11:18,960
This helps us out.

214
00:11:18,960 --> 00:11:21,640
So this brings me to my other question from earlier.

215
00:11:21,640 --> 00:11:26,040
Like when might model end up with multiple sources of truth anyway?

216
00:11:26,040 --> 00:11:30,520
Like when might it go from being the single source of truth to being a store that contains

217
00:11:30,520 --> 00:11:34,680
multiple values, each of which refer to the same piece of information and which might

218
00:11:34,720 --> 00:11:38,720
have different values for that piece of information depending on which part of the model I look

219
00:11:38,720 --> 00:11:40,760
at?

220
00:11:40,760 --> 00:11:44,440
Well one case where this might genuinely want to happen is caching.

221
00:11:44,440 --> 00:11:47,240
So and this is something that I would do for performance.

222
00:11:47,240 --> 00:11:50,880
So like basically let's say I have some sort of really expensive calculation that I'm

223
00:11:50,880 --> 00:11:52,960
doing using model data.

224
00:11:52,960 --> 00:11:55,920
Really in web applications this almost never happens but it's conceivable.

225
00:11:55,920 --> 00:12:00,200
I could have some really expensive thing that I have to do like 60 frames per second all

226
00:12:00,200 --> 00:12:02,880
the time using data from the model.

227
00:12:02,880 --> 00:12:07,240
And I can't cache it with HTML lazy for some reason but I mean usually I can and if I can

228
00:12:07,240 --> 00:12:10,240
that's certainly how I want to do it because that's the cache that's very nicely managed

229
00:12:10,240 --> 00:12:11,240
by the Elm runtime.

230
00:12:11,240 --> 00:12:14,800
I don't have to think about caching validation which is one of the famously hard problems

231
00:12:14,800 --> 00:12:20,880
in computer science and this calculation is so expensive that it's a performance bottleneck

232
00:12:20,880 --> 00:12:21,880
in practice.

233
00:12:21,880 --> 00:12:24,840
And now we're into the territory of extremely, extremely, extremely unlikely to the extremely

234
00:12:24,840 --> 00:12:31,120
power because really when we're talking about performance problems it's pretty much always

235
00:12:31,120 --> 00:12:33,000
to do with rendering stuff.

236
00:12:33,000 --> 00:12:36,320
It's basically never to do with calculations like this in practice.

237
00:12:36,320 --> 00:12:39,440
But let's say I did actually end up with something like that.

238
00:12:39,440 --> 00:12:43,640
This is one of the things that caching is used for is you have a piece of state that says

239
00:12:43,640 --> 00:12:48,280
I am sort of an intermediate value, some sort of incremental calculation and then I can

240
00:12:48,280 --> 00:12:51,640
base future calculations on that just like incrementing and decrementing rather than

241
00:12:51,640 --> 00:12:54,520
having to rebuild it all from scratch.

242
00:12:54,520 --> 00:12:59,920
So yes it's not like you should never, ever, ever in a bazillion years have duplicate information

243
00:12:59,920 --> 00:13:00,920
in the model.

244
00:13:00,920 --> 00:13:04,400
There is a use case but it's pretty rare in practice.

245
00:13:04,400 --> 00:13:08,440
So that's also good news because it means we can have a single source of truth pretty

246
00:13:08,440 --> 00:13:10,160
much all the time.

247
00:13:10,160 --> 00:13:12,600
So how about relational data that gets stored in the model?

248
00:13:12,600 --> 00:13:16,800
That is to say pieces of data where we have different pieces of information in the model

249
00:13:16,800 --> 00:13:19,040
but they relate to one another in some way.

250
00:13:19,040 --> 00:13:23,000
So let's look at an example of this.

251
00:13:23,000 --> 00:13:24,000
Relational data.

252
00:13:24,000 --> 00:13:29,280
So I work in a company called No Red Ink and we make stuff for English teachers.

253
00:13:29,280 --> 00:13:33,080
Now let's say hypothetically, just for the purposes of this example, that we decided

254
00:13:33,080 --> 00:13:38,360
to sort of like broaden our scope a little bit and we decided to introduce a new feature

255
00:13:38,360 --> 00:13:43,040
which is not English related but actually it's field trip management.

256
00:13:43,040 --> 00:13:47,720
This is why I'm not in charge of the product team.

257
00:13:47,720 --> 00:13:52,040
So we're going to build this new feature that's going to allow teachers to manage a field trip

258
00:13:52,040 --> 00:13:56,160
for their students where they take everybody on a bus and they go out somewhere interesting

259
00:13:56,160 --> 00:13:58,560
for the day and learn things there.

260
00:13:58,560 --> 00:14:03,160
So we've got an all day field trip coming up and the teacher wants to answer the question

261
00:14:03,160 --> 00:14:06,800
which students are going, sort of manage this and check off, okay, these students are going,

262
00:14:06,800 --> 00:14:07,880
these students are not going.

263
00:14:07,880 --> 00:14:11,000
So let's look at this from a data modeling perspective.

264
00:14:11,000 --> 00:14:16,680
So let's say we've got one of our students named Richard Feldman, going is false which

265
00:14:16,680 --> 00:14:20,160
is why he's making that face.

266
00:14:20,160 --> 00:14:23,240
Kid looks like a troublemaker.

267
00:14:23,240 --> 00:14:25,080
So this is our very simple data model.

268
00:14:25,080 --> 00:14:28,440
We have name which is a string and going which is a boolean.

269
00:14:28,440 --> 00:14:31,480
And for our purposes, that's going to be enough.

270
00:14:31,480 --> 00:14:33,760
And then the teacher has multiple courses.

271
00:14:33,760 --> 00:14:36,360
So let's say a teacher has a course called second period English.

272
00:14:36,360 --> 00:14:42,000
It's a very common name for a course that we see in practice and the teacher has a couple

273
00:14:42,000 --> 00:14:43,000
of students in that course.

274
00:14:43,000 --> 00:14:49,680
So R. Feldman, B. Knowles, A. Einstein and they can sort of check and uncheck which students

275
00:14:49,680 --> 00:14:52,040
are going to be going on this field trip.

276
00:14:52,040 --> 00:14:53,280
This is the UI we're building.

277
00:14:53,280 --> 00:14:55,960
They might have another course called fifth period history.

278
00:14:55,960 --> 00:14:59,600
So sometimes we have teachers who have, they're not dedicated English teachers.

279
00:14:59,600 --> 00:15:03,120
They have some courses that are English and then some courses that are another subject.

280
00:15:03,120 --> 00:15:06,520
And sometimes they use no reading because we teach writing among other things.

281
00:15:06,520 --> 00:15:09,720
And so they want their history students to be able to write more effective essays.

282
00:15:09,720 --> 00:15:14,280
So they'll have no reading activated for both their history course and their English course.

283
00:15:14,280 --> 00:15:17,560
And of course, if you're teaching multiple subjects, you can have the same student in

284
00:15:17,560 --> 00:15:18,560
multiple courses.

285
00:15:18,560 --> 00:15:22,800
So Richard Feldman could be in second period English as well as fifth period history in

286
00:15:22,800 --> 00:15:26,760
addition to some other number of students.

287
00:15:26,760 --> 00:15:29,520
So this is an entirely plausible scenario that we might end up with.

288
00:15:29,520 --> 00:15:32,960
And of course, this is relational data that we have students have a relationship to the

289
00:15:32,960 --> 00:15:36,000
course and also we have some sort of notion of identity.

290
00:15:36,000 --> 00:15:39,640
Like Richard Feldman is the same student whether he's in second period English or in fifth

291
00:15:39,640 --> 00:15:41,760
period history.

292
00:15:41,760 --> 00:15:45,040
So if the teacher checks one of these boxes because it's the same person, like either

293
00:15:45,040 --> 00:15:48,160
he's going on the field trip or he's not and it's an all day field trip.

294
00:15:48,160 --> 00:15:52,160
So certainly he's not going to be going for second period but not fifth period.

295
00:15:52,160 --> 00:15:56,360
So if the teacher checks one of the boxes because of the relationships innate in this

296
00:15:56,360 --> 00:15:58,960
data, it should check both of the boxes.

297
00:15:58,960 --> 00:16:01,720
That's otherwise, you know, we've got some sort of mistake.

298
00:16:01,720 --> 00:16:05,840
We should never end up with the teacher seeing this in their UI or else we've done something

299
00:16:05,840 --> 00:16:06,840
wrong.

300
00:16:06,840 --> 00:16:08,920
This would be a synchronization bug.

301
00:16:08,920 --> 00:16:10,520
Okay.

302
00:16:10,520 --> 00:16:15,360
So in JavaScript, the way that I might have done this is I would say something like going

303
00:16:15,360 --> 00:16:19,280
back to the very beginning of the talk, courses brackets zero dot students brackets zero dot

304
00:16:19,280 --> 00:16:20,600
going equals true.

305
00:16:20,600 --> 00:16:26,400
Which is to say the first student in the first course is now going on the field trip.

306
00:16:26,400 --> 00:16:30,200
When I check that box, that's what we've changed about our data model.

307
00:16:30,200 --> 00:16:34,440
Now if I do this and I put into a REPL courses brackets zero dot students brackets zero, it

308
00:16:34,440 --> 00:16:38,360
would now say, hey, this student is now going, great.

309
00:16:38,360 --> 00:16:42,960
And also, if I said courses bracket one, which is to say fifth period English dot students

310
00:16:42,960 --> 00:16:46,680
brackets zero, it would also say that that student is going.

311
00:16:46,680 --> 00:16:51,200
And the reason for that is that students in both cases are mutable references in JavaScript.

312
00:16:51,200 --> 00:16:55,480
These are JavaScript objects, JavaScript objects are mutable, and they store mutable references

313
00:16:55,480 --> 00:16:57,280
to other objects.

314
00:16:57,280 --> 00:17:00,960
So both of these are actually pointing to the same student in memory, which means if

315
00:17:00,960 --> 00:17:03,600
I change the one, it's going to change the other as well.

316
00:17:03,600 --> 00:17:07,680
Now this has various downsides that we're probably familiar with, like you pass something

317
00:17:07,680 --> 00:17:11,480
to a function, you're not sure if that function is going to mutate or not, plenty of downsides,

318
00:17:11,480 --> 00:17:15,120
but this is one of the upsides when it comes to data consistency.

319
00:17:15,160 --> 00:17:19,960
It means that when I mutate one, it automatically mutates all the others at the same time for

320
00:17:19,960 --> 00:17:20,960
me.

321
00:17:20,960 --> 00:17:25,600
So this is an example of relational data with a single source of truth.

322
00:17:25,600 --> 00:17:30,280
We don't actually have any duplicate information in this data model that we've built in this

323
00:17:30,280 --> 00:17:32,480
sort of JavaScript version.

324
00:17:32,480 --> 00:17:37,000
Okay, so now I'm, you know, was a JavaScript programmer, now I've transitioned to an Elm

325
00:17:37,000 --> 00:17:40,680
programmer, and so now I'm thinking in terms of immutable data.

326
00:17:40,680 --> 00:17:44,320
So one way that we might model this in Elm, and probably the way that I would have modeled

327
00:17:44,360 --> 00:17:48,920
it when I was starting out, I would say type alias student, name colon string, going is

328
00:17:48,920 --> 00:17:55,760
a Boolean, then I'd have type alias course, name is a string, students is a list of students,

329
00:17:55,760 --> 00:18:00,560
so we have nested records here, and then finally I would have my model which would have courses,

330
00:18:00,560 --> 00:18:03,960
which is a list of course, and then various other things, but at least within the scope

331
00:18:03,960 --> 00:18:07,680
of what we're talking about here, these are the relevant structures that we'd be dealing

332
00:18:07,680 --> 00:18:08,680
with.

333
00:18:08,680 --> 00:18:13,680
Now, believe it or not, already we've introduced multiple sources of truth.

334
00:18:13,720 --> 00:18:17,600
Even though this basically looks like a description of the same sort of schema that we had in

335
00:18:17,600 --> 00:18:21,960
the JavaScript version, just by virtue of the fact that we've gone from mutable objects

336
00:18:21,960 --> 00:18:26,120
to immutable data, we have now accidentally introduced multiple sources of truth.

337
00:18:26,120 --> 00:18:31,120
And this is kind of an easy thing to do, at least it was for me, when going from JavaScript

338
00:18:31,120 --> 00:18:34,480
to Elm because I'm like, oh, well, records look like objects, so I'll just take the thing

339
00:18:34,480 --> 00:18:38,000
that I would have done with an object and I'll just do it with a record.

340
00:18:38,000 --> 00:18:42,800
But it turns out that that mutable to immutable characteristic is actually significant implications

341
00:18:43,800 --> 00:18:49,800
to sort of do a more apples to apples transition, let's go from the JavaScript object that

342
00:18:49,800 --> 00:18:55,800
we did before to the JavaScript object notation, better known as JSON, because JavaScript

343
00:18:55,800 --> 00:18:59,640
objects are mutable references, but JSON is actually immutable data, which it sort of

344
00:18:59,640 --> 00:19:00,640
has to be to serialize.

345
00:19:00,640 --> 00:19:04,360
If you want to serialize mutable references to memory locations and just write them straight

346
00:19:04,360 --> 00:19:07,720
to the disk, it's probably not likely to work out very well when you try to deserialize

347
00:19:07,720 --> 00:19:08,720
them.

348
00:19:08,720 --> 00:19:13,760
JSON is immutable despite having the same structure as JavaScript objects.

349
00:19:13,760 --> 00:19:15,240
So let's look at the JSON version of this.

350
00:19:15,240 --> 00:19:19,920
So we have courses, we have name, second period English, students, and then an array, name

351
00:19:19,920 --> 00:19:25,840
Richard Feldman going false, and then another course, name, fifth period history, students,

352
00:19:25,840 --> 00:19:28,560
name Richard Feldman going false.

353
00:19:28,560 --> 00:19:32,800
So now we can kind of see more clearly that we actually do, in fact, have duplicated data

354
00:19:32,800 --> 00:19:33,800
now.

355
00:19:33,800 --> 00:19:38,680
Like before, both of those students were pointing to the same point in memory, but now we actually

356
00:19:38,680 --> 00:19:41,560
have two different independent pieces of data.

357
00:19:41,560 --> 00:19:43,240
So that means that they can now get out of sync.

358
00:19:43,240 --> 00:19:47,600
I can change one of them to true without changing the other one to false.

359
00:19:47,600 --> 00:19:49,520
That's a potential problem.

360
00:19:49,520 --> 00:19:55,600
So objects have mutable references, whereas records, and JSON, have immutable records.

361
00:19:55,600 --> 00:19:59,400
So objects have this upside of sort of implicit synchronization that sort of automatically

362
00:19:59,400 --> 00:20:04,400
happens whenever you change something, whereas records also have their own set of upsides,

363
00:20:04,400 --> 00:20:08,280
really cheap copying, equality checks that can just do reference equality, so on and

364
00:20:08,280 --> 00:20:09,360
so forth.

365
00:20:09,360 --> 00:20:13,400
But this is something that we have to be aware of when we're going from objects to records.

366
00:20:13,400 --> 00:20:15,960
This is a pretty significant difference.

367
00:20:15,960 --> 00:20:19,880
So let's move along to immutable relational data.

368
00:20:19,880 --> 00:20:24,200
So what are we going to do differently when we are transitioning to the world of immutability?

369
00:20:24,200 --> 00:20:27,080
Okay, so this was sort of the problem that we ran into.

370
00:20:27,080 --> 00:20:29,840
We had this duplicated data, and it could get out of sync.

371
00:20:29,840 --> 00:20:33,400
We could have going is true in one case and going is false in the other case, and that

372
00:20:33,400 --> 00:20:36,080
shouldn't be possible because it's the same student.

373
00:20:36,080 --> 00:20:38,920
Whether he's going on the field trip or he's not.

374
00:20:38,920 --> 00:20:44,080
So one way we could create a single source of truth out of this is by changing the JSON

375
00:20:44,080 --> 00:20:46,680
to look like this.

376
00:20:46,680 --> 00:20:47,920
So let's look at these differences here.

377
00:20:47,920 --> 00:20:54,040
So the first thing is we've introduced explicit identifiers for what the student refers to.

378
00:20:54,040 --> 00:20:58,760
We're no longer using memory references, we're actually using identifiers as references.

379
00:20:58,760 --> 00:21:02,800
So here we have students is just an array of IDs.

380
00:21:02,800 --> 00:21:08,200
So ID 217, we see down at the bottom there, refers to Richard Feldman.

381
00:21:08,200 --> 00:21:11,760
And that's the only place that Richard Feldman appears in this whole data model.

382
00:21:11,760 --> 00:21:15,880
Everywhere else it's an identifier referring to that one single source of truth.

383
00:21:15,880 --> 00:21:22,080
So we're using explicit identifiers to reference a single source of truth in a completely immutable

384
00:21:22,080 --> 00:21:23,800
way.

385
00:21:23,800 --> 00:21:30,960
So let's translate that idea into L. So we've got our type alias student course model.

386
00:21:30,960 --> 00:21:32,080
So this is what we had before.

387
00:21:32,080 --> 00:21:35,760
We had a list of students under course and we had a list of courses under model.

388
00:21:35,760 --> 00:21:37,920
So we're going to tweak that a little bit.

389
00:21:37,920 --> 00:21:41,720
Instead we're going to go from students to student IDs, which is going to be a list

390
00:21:41,720 --> 00:21:43,600
of student ID values.

391
00:21:43,600 --> 00:21:48,000
So student ID type could be whatever you want, you know, integers as we saw in the JSON example,

392
00:21:48,000 --> 00:21:51,480
strings, custom types, anything you want.

393
00:21:51,480 --> 00:21:55,560
Inside the model we're going to have students as a new value in the model.

394
00:21:55,560 --> 00:21:59,360
This is our single source of truth for all of our students across the entire model.

395
00:21:59,360 --> 00:22:01,280
And it's going to be a dictionary.

396
00:22:01,320 --> 00:22:04,760
So we're going to change on that same student ID and then having a single source of truth

397
00:22:04,760 --> 00:22:09,720
be the value of that particular student stored in that dictionary.

398
00:22:09,720 --> 00:22:13,320
By the way, one thing we would also want to do here, I think, that can sort of take this

399
00:22:13,320 --> 00:22:16,920
data model a little bit one step further, is to change from a list of student IDs to

400
00:22:16,920 --> 00:22:18,400
a set of student IDs.

401
00:22:18,400 --> 00:22:22,680
Because really, like, would it ever be useful to have the same student appear multiple times

402
00:22:22,680 --> 00:22:23,880
in the same course?

403
00:22:23,880 --> 00:22:24,880
Not really.

404
00:22:24,880 --> 00:22:26,800
That should be a set because sets have uniqueness.

405
00:22:27,200 --> 00:22:33,560
We should only have at most one student ID of the same value inside each course.

406
00:22:33,560 --> 00:22:37,520
OK, so now let's write a function called students in course that's going to take one

407
00:22:37,520 --> 00:22:42,280
of these courses, maybe something inside update, and it's going to return a list of

408
00:22:42,280 --> 00:22:43,280
students.

409
00:22:43,280 --> 00:22:46,960
So this is sort of our replacement for we want to work in terms of a list of students,

410
00:22:46,960 --> 00:22:50,320
which is why we originally said courses just have a list of students, but now we're just

411
00:22:50,320 --> 00:22:52,840
going to do a function to do the same thing.

412
00:22:52,840 --> 00:22:54,240
So it's going to take a course as an argument.

413
00:22:54,680 --> 00:22:57,800
And it's going to start off by doing a dicks.filter.

414
00:22:57,800 --> 00:22:59,240
What's it going to filter on?

415
00:22:59,240 --> 00:23:03,360
It's going to say, OK, I'm going to look at each of the students that I have, and I'm

416
00:23:03,360 --> 00:23:06,480
going to say, am I in this particular course?

417
00:23:06,480 --> 00:23:11,200
The way I can tell if I'm in this particular course is set.member, that particular student's

418
00:23:11,200 --> 00:23:15,040
ID, and the course's set of student IDs.

419
00:23:15,040 --> 00:23:19,560
So this is going to filter that dictionary of all the students down to just the ones

420
00:23:19,560 --> 00:23:21,320
who are in that particular course.

421
00:23:21,320 --> 00:23:22,200
And that's it.

422
00:23:22,240 --> 00:23:27,200
We have now gone from our single source of truth of all students in one expression down

423
00:23:27,200 --> 00:23:32,280
to a single source of truth for the list of students that are in that particular course.

424
00:23:32,280 --> 00:23:35,280
And now we can do whatever we want with that list of students, whatever we would have done

425
00:23:35,280 --> 00:23:38,720
previously by courses.students.

426
00:23:38,720 --> 00:23:41,880
And then, of course, if we want to actually get it from a dictionary to a list of students,

427
00:23:41,880 --> 00:23:44,600
we'd pipe it to dicks.values.

428
00:23:44,600 --> 00:23:49,320
OK, so here we have an example of immutable relational data where we've maintained a single

429
00:23:49,320 --> 00:23:52,320
source of truth, which means no synchronization problems.

430
00:23:52,320 --> 00:23:55,800
Also it means no nested record updates, which is cool.

431
00:23:55,800 --> 00:24:00,000
But basically, we no longer have that whole series of problems where we have to keep things

432
00:24:00,000 --> 00:24:04,800
updated, keep things in sync, detect errors, resolve conflicts, and so on and so forth.

433
00:24:04,800 --> 00:24:07,880
OK, but what about like more complex relationships?

434
00:24:07,880 --> 00:24:10,640
What if we had the JavaScript equivalent of something like this?

435
00:24:10,640 --> 00:24:15,320
Courses bracket zero.students bracket three.assignments bracket two.is done, something where we have

436
00:24:15,320 --> 00:24:19,200
lots of relationships and we're trying to merge them all together.

437
00:24:19,200 --> 00:24:21,080
How does this sort of like scale?

438
00:24:21,080 --> 00:24:25,960
Well, there's actually, as it turns out, an entire sort of field of study and a lot

439
00:24:25,960 --> 00:24:29,720
of implementations that work with these types of questions.

440
00:24:29,720 --> 00:24:33,120
If anyone recognizes this logo, this is a good elephant.

441
00:24:33,120 --> 00:24:34,120
This is PostgreSQL.

442
00:24:34,120 --> 00:24:39,760
You also got other databases like MySQL, SQLites, and it turns out relational data has been

443
00:24:39,760 --> 00:24:44,680
well studied and explored by relational databases.

444
00:24:44,680 --> 00:24:52,960
And we can, what's the word I'm looking for, steal shamelessly from the things that they've

445
00:24:52,960 --> 00:24:57,400
learned over the years about dealing with relational data without dealing with mutable

446
00:24:57,400 --> 00:25:01,280
references, which they don't use because they need to serialize everything to the disk.

447
00:25:01,280 --> 00:25:05,920
So what if we think about dictionaries as sort of like an analogy for database tables?

448
00:25:05,920 --> 00:25:06,920
What could that do for us?

449
00:25:06,920 --> 00:25:11,440
So what if we thought about things like select, where, and join in terms of SQL, and then

450
00:25:11,440 --> 00:25:16,760
we translated those to dictionary concepts like get, filter, intersect, and so forth.

451
00:25:16,760 --> 00:25:17,760
How might that look?

452
00:25:17,760 --> 00:25:20,800
So here's a really, really simple SQL query.

453
00:25:20,800 --> 00:25:22,560
Select count star from users.

454
00:25:22,560 --> 00:25:25,920
So that's sort of the equivalent of saying like, tick dot size users.

455
00:25:25,920 --> 00:25:26,920
Ha.

456
00:25:26,920 --> 00:25:28,800
Stake in the slides.

457
00:25:28,800 --> 00:25:31,480
Select count star from users where age is greater than or equal to 18.

458
00:25:31,480 --> 00:25:34,680
This would be voting age users in the U.S.

459
00:25:34,680 --> 00:25:38,840
So the equivalent to that, dicks dot filter is voting age users, which is kind of nice

460
00:25:38,840 --> 00:25:42,280
because it's actually a little bit more descriptive than the greater than or equal to 18.

461
00:25:42,280 --> 00:25:43,680
And then pipe that to dicks dot size.

462
00:25:43,680 --> 00:25:46,200
I got it right on this slide.

463
00:25:46,200 --> 00:25:49,560
So this is like a slightly more advanced query.

464
00:25:49,560 --> 00:25:52,040
So what if we just, okay, let's just go for it.

465
00:25:52,040 --> 00:25:53,040
Let's do joins.

466
00:25:53,040 --> 00:25:54,040
Let's do where.

467
00:25:54,040 --> 00:25:55,600
Let's just get some more stuff in there.

468
00:25:55,600 --> 00:25:58,560
Select count star from users where age is greater than or equal to 18.

469
00:25:58,560 --> 00:26:05,000
So this is voting age users inner join residence on residence.id equals users.id where residence.city

470
00:26:05,000 --> 00:26:06,000
equals stl.

471
00:26:06,000 --> 00:26:13,280
And now we're saying who are, like, how many users are a voting age and live in St. Louis?

472
00:26:13,280 --> 00:26:15,280
How do we do that using dictionaries?

473
00:26:15,280 --> 00:26:20,000
Well, let's start by defining a couple of type aliases because we can't just, you know,

474
00:26:20,000 --> 00:26:21,000
use a plain old dictionary.

475
00:26:21,000 --> 00:26:23,040
We're going to need to get some records involved here.

476
00:26:23,040 --> 00:26:26,000
So let's say we have user, which is user ID and age.

477
00:26:26,000 --> 00:26:30,680
And then we also have a model which has users, which is a dictionary between user ID and

478
00:26:30,680 --> 00:26:31,680
user.

479
00:26:31,680 --> 00:26:35,800
And we have residence, which is a dictionary between user ID and city ID or user ID and

480
00:26:35,800 --> 00:26:36,840
city.

481
00:26:36,840 --> 00:26:38,840
So these are, like, examples.

482
00:26:38,840 --> 00:26:42,240
You can imagine many more dictionaries all at the top level, but you can model as many

483
00:26:42,240 --> 00:26:46,720
relationships between as many different entities as we want, just like how databases have tables

484
00:26:46,720 --> 00:26:51,600
all at the top level, which model relationships between as many different tables as you want.

485
00:26:51,600 --> 00:26:54,280
So here's how we might implement this query.

486
00:26:54,280 --> 00:26:57,640
So we could say locals, which is to say St. Louis locals or St. Louisans or if you're

487
00:26:57,640 --> 00:27:00,720
part of Nellie's crew, St. Lunatics.

488
00:27:00,720 --> 00:27:05,120
And we would say dix.filter, user ID, city, so that user ID being the key and then the

489
00:27:05,120 --> 00:27:08,920
city being the value, city.name, double equals stl.

490
00:27:08,920 --> 00:27:13,320
So this is going to give us, among all the residents, only those whose city is St. Louis.

491
00:27:13,320 --> 00:27:18,120
Then we can do dix.filter on isvotingage, model.users, just like before.

492
00:27:18,120 --> 00:27:21,840
So now we have a dictionary of all the users who are voting age.

493
00:27:21,840 --> 00:27:27,520
And then to do the join, we do dix.intersect locals, which is going to take all of the

494
00:27:27,520 --> 00:27:31,680
users that we've filtered out for just the ones that have voting age, and then also all

495
00:27:31,680 --> 00:27:36,520
of those that have city name of St. Louis, because that's where they live.

496
00:27:36,520 --> 00:27:38,840
And then finally, dix.size.

497
00:27:38,840 --> 00:27:42,600
So just by using a couple of simple expressions, we end up with being able to essentially do

498
00:27:42,600 --> 00:27:46,040
the same types of things that we could do in a relational database.

499
00:27:46,040 --> 00:27:50,120
This is like pretty powerful stuff, and it's all with a single source of truth.

500
00:27:50,120 --> 00:27:51,880
And no nested record updates.

501
00:27:51,880 --> 00:27:52,880
Pretty cool.

502
00:27:52,880 --> 00:27:53,880
Okay.

503
00:27:53,880 --> 00:27:57,400
If you're curious to learn some more data modeling techniques, completely shameless

504
00:27:57,400 --> 00:27:58,400
plug.

505
00:27:58,400 --> 00:28:01,760
There's this book by a dude, Elman Action.

506
00:28:01,760 --> 00:28:02,760
So check it out.

507
00:28:02,760 --> 00:28:03,760
Okay.

508
00:28:03,760 --> 00:28:04,760
So let's recap.

509
00:28:04,760 --> 00:28:09,280
So first we talked about state synchronization, sort of some of the problems, some of the

510
00:28:09,280 --> 00:28:10,280
pitfalls.

511
00:28:10,280 --> 00:28:14,440
We talked about relational data, and then we talked about immutable relational data without

512
00:28:14,440 --> 00:28:16,440
using mutable references.

513
00:28:16,440 --> 00:28:20,640
We talked about how a single source of truth means there's nothing to synchronize.

514
00:28:20,640 --> 00:28:24,360
All of those problems that we saw with state synchronization, completely out the window,

515
00:28:24,360 --> 00:28:26,920
none of those tweet-related problems.

516
00:28:26,960 --> 00:28:30,920
We talked about the synchronization work that has to be done if we do have multiple sources

517
00:28:30,920 --> 00:28:34,880
of truth, making updates, detecting errors, resolving conflicts, gracefully recovering

518
00:28:34,880 --> 00:28:36,440
in the ideal case.

519
00:28:36,440 --> 00:28:40,040
And we talked about how relational data can be done with a single source of truth, and

520
00:28:40,040 --> 00:28:43,840
in fact, immutable relational data can still be done with a single source of truth, which

521
00:28:43,840 --> 00:28:48,160
is really what we would prefer to do if we have the option.

522
00:28:48,160 --> 00:28:52,400
Then we talked about dictionaries as tables, and sort of how we can use the metaphor of

523
00:28:52,400 --> 00:28:56,760
tables that appear in relational databases to do the same kinds of data modeling activities

524
00:28:57,040 --> 00:28:58,040
using dictionaries.

525
00:28:58,040 --> 00:29:01,840
And finally, we come back to the original two questions that I had.

526
00:29:01,840 --> 00:29:04,240
When should I put duplicate information in my model?

527
00:29:04,240 --> 00:29:08,800
The answer is basically almost never, unless performance absolutely demands a cache, and

528
00:29:08,800 --> 00:29:12,480
I'm really sure I have a performance problem, and I really just can't avoid it.

529
00:29:12,480 --> 00:29:15,840
That's really the only situation I've ever come across where I would say that that's

530
00:29:15,840 --> 00:29:17,560
a good idea.

531
00:29:17,560 --> 00:29:19,720
And how would I do something like this in Elm?

532
00:29:19,720 --> 00:29:25,600
Of course, it's bracket zero.studentbracketzero.selected equals true using dictionaries as tables.

533
00:29:25,600 --> 00:29:26,640
Thanks very much.

