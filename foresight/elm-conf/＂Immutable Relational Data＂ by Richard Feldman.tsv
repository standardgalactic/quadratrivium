start	end	text
0	13000	All right, so this is immutable relational data.
13000	15080	I'm Richard Feldman.
15080	19520	So when I was first getting into Elm, there were two questions that I had, like very early
19520	23200	on, things that I didn't really know how to do coming from JavaScript.
23200	26560	And one was, how do I do this?
26560	32160	Like I want to do some equivalent of courses bracket zero dot students bracket zero dot
32160	33400	selected equals true.
33400	38480	Like, how do I, there's a little nested record update syntax, like how do I, I don't know,
38480	41080	I couldn't quite figure that out at first.
41080	45720	And then another question I had was, when, if ever, should I put duplicate information
45720	46720	in my model?
46720	49720	Like should I ever have the same piece of information in two different places in my model?
49720	50720	Is that a bad idea?
50720	52720	Is that, I don't know, what are the trade-offs?
52720	54840	I didn't really know.
54840	58240	And as I got more into Elm, I kind of learned about different techniques for modeling data
58240	59240	and so forth.
59240	64440	And I ended up discovering that these two questions turned out to be related.
64440	67120	And they have to do with the title of this talk.
67120	71280	So we're going to go through sort of my progression of like how I learned about these things.
71280	72760	And we're going to start with state synchronization.
72760	77000	And then we're going to move on to talking about relational data in general.
77000	81600	And then finally end up with immutable relational data and some techniques for dealing with
81600	82600	it.
82600	83600	Okay.
83600	85360	Let's start with state synchronization.
85360	86360	Okay.
86360	89680	So some time ago, a friend of mine tweeted me.
89680	96080	They said, hey, RT Feldman, remember that time in college when we were late to a potluck?
96080	103120	And we went to a Wendy's drive-thru and got 20 orders of $1 five-piece nuggets?
103120	106440	So we showed up to the potluck with 100 chicken nuggets, LOL.
106440	107440	That's a true story.
107440	108440	That did happen in college.
108440	114000	So I saw this, I was like, oh, yeah, that was a good time.
114000	117760	So I like, you know, went to the like button and hit like.
117760	118760	But I got an error.
118760	120280	I was like, no, you can't do that.
120280	121280	It's like, what?
121280	122280	No, no, for real.
122280	123280	I like it.
123280	124280	It's good times.
124280	126280	So I hit the button again.
126280	127280	It's error.
127280	129160	Oh, come on.
129160	133920	So as it turned out, what had happened was my friend, after posting this, decided this
133920	137520	was maybe not something the entire internet needed to know.
137520	139240	And so they ended up deleting it.
139240	145400	And so they deleted it sometime between when I saw it and when I attempted to click like,
145400	147200	resulting in the error.
147200	151360	So this is essentially a sort of a mismatch between the client and the server.
151360	154880	So my client, the web browser, was like, oh, yeah, this tweet totally exists.
154880	155880	Sure.
155880	159040	Here's a nice lovely like button in case you'd like to like it.
159040	161720	But unfortunately, the server had a different idea, the server was like, oh, that's gone.
161720	162720	What are you talking about?
162720	164840	Like, that's been deleted for a while.
164840	169240	So there was this mismatch between the two, and that led to the error.
169240	171560	So this is a form of synchronization problem.
171560	175960	Like, we had a synchronization mismatch between the client and the server.
175960	180480	And when we have multiple sources of truth, we sort of need to synchronize them or else
180480	182120	we can get this type of error.
182120	186120	Now if we have multiple sources of truth, such as the client and the server, and they
186120	190680	agree like if the client says the tweet exists and the server also believes that it exists,
190680	191680	that's okay.
191680	192680	That's no problem.
192880	196240	The typical thing, which is why, you know, I was surprised to see this error and not
196240	199920	just like, oh, yeah, another one of these just happens to me constantly.
199920	204480	Usually despite the fact that there are multiple sources of truth, they're staying in sync
204480	205800	so it doesn't actually matter.
205800	208800	It doesn't sort of affect me.
208800	210680	It's also fine if they both agree that it's gone.
210680	214120	Like, eventually I refresh the page and then I saw, oh, the thing's gone.
214120	216440	So they got synced up and then it was again, no problem.
216440	219640	I was back to being in sync with the server and the multiple sources of truth were not
219680	223160	really causing any problems there for me.
223160	226720	So basically when multiple sources of truth remain synchronized, it's okay.
226720	230520	There's sort of no symptoms, no problems that the end user is faced with.
230520	236560	However, when they get out of sync, as happened to me in the tweet, then that causes a problem.
236560	240200	So single sources of truth sort of don't have this issue.
240200	243520	There's no synchronization because there's nothing to synchronize.
243520	245480	It's just one source of truth.
245480	249320	So this entire class of errors goes away, which is one of the things that's nice about
249320	252240	having a single source of truth.
252240	255400	So synchronization is sort of error prone.
255400	256880	This is one of the problems with it.
256880	259080	As we saw, this is sort of a case in point.
259080	261400	This is a synchronization error.
261400	264400	And these sort of things can happen all the time when you have to synchronize two pieces
264400	267440	of information because there are multiple sources of truth.
267440	272840	Which sort of begs the question, is it necessarily avoidable to have multiple sources of truth?
272840	276400	Sometimes do we have to have multiple sources of truth even if we would prefer to have a
276400	279760	single source of truth and not have to synchronize anything?
279760	285200	Let's take this client server app as an example and see if we can arrange things such that
285200	287200	we have a single source of truth.
287200	288200	This is our goal.
288200	291760	We're going to have a client and a server, multiple clients and a server, and we're going
291760	294640	to have a single source of truth that's shared between all of them such that there's nothing
294640	296720	that we need to synchronize.
296720	299520	So to do this, probably what we're going to have to do is say, okay, the server is going
299520	301080	to have to take care of rendering the UI.
301080	304480	That's going to have to be the source of truth because that's where the database lives.
304840	310320	I mean, if anyone ever disagrees with the database about what is true, the database is
310320	311320	going to be right.
311320	315200	So we're going to have the server render HTML like it's 15 years ago and it's just going
315200	319040	to send it directly to the client on every single user interaction.
319040	322200	Like I click anything and the server is going to render some HTML and send it to the client.
322200	327280	So that way the server is the single source of truth, kind of.
327280	331480	Problem is that sending stuff from the server to the client takes time.
331480	333920	It doesn't just like appear on my screen instantaneously.
334360	338640	There's like networks and packets and like latency and things like that.
338640	342960	And in fact, there's so much of that that it's like perceptible, which in turn means
342960	346640	that it's entirely possible that over the course of that network transmission while
346640	352240	the currently up-to-date perfect single source of truth UI is headed towards my browser,
352240	356920	my friend deletes the tweet, and now I am once again out of sync.
356920	360720	So even trying as hard as we possibly can to have a single source of truth with a client
360720	363800	server application, it's just not possible.
363800	367720	You cannot have a single source of truth when you've got a client and a server.
367720	370360	You sort of must have synchronization.
370360	375400	It's completely unavoidable by the nature of this architecture, which is kind of a bummer
375400	378160	because hey, clients and servers are nice.
378160	381320	So we're sort of stuck synchronizing them.
381320	385280	And again, even if it is unavoidable, synchronization is still error-prone.
385280	388360	We're still going to have to deal with synchronization errors like this.
388360	395280	So we'd sort of like to handle these synchronization errors in as graceful a way as we can.
395280	397880	And there's sort of different levels to this.
397880	400640	So one is basically just like fail without feedback.
400640	404840	So this is the absolute worst, which is to say the tweet gets deleted and I hit like
404840	406280	and then just nothing happens.
406280	408560	I'm just like, what?
408560	411960	Or you can do what's called optimistic updates where you're just like, I'm going to update
411960	415520	the client state and assume it works out on the server.
415520	419200	This can be even worse and I've been really, really badly burned by this in the past.
419200	421280	That's basically where you hit like and it does the animation.
421280	422720	It's like, yeah, everything worked.
422720	424520	And then later on it just was gone.
424520	425520	What?
425520	428800	And then, you know, so once it actually gets in sync, you find out much after the fact
428800	429800	that there was a problem.
429800	434240	Having had no idea at the time that there was anything wrong, which would have at least
434240	435240	given me a clue.
435240	439360	Like, yeah, I want to try hitting like again in case maybe the server is down or something.
439360	444360	So failing without feedback is sort of the worst way to handle a synchronization error.
444360	447800	We can do a little bit better by at least informing the user that some sort of error
447800	448800	occurred.
448800	454000	Like error, even if you're saying like error 500, that's at least giving me some clue that
454000	458440	something went wrong so I can, you know, react accordingly and not be surprised later on
458440	464360	to discover that there was this mismatch between my expectation and what actually happened.
464360	466800	Even better than that is to explain the problem.
466800	471080	Something like this tweet was deleted before you could like it or maybe something more
471080	472440	concise than that.
472440	475720	But explaining the problem gives the user a better experience to understand, oh, this
475720	479760	is not just like something went wrong, which could be so many different things and lead
479760	484800	me to take completely futile actions such as hammering on the like button.
484800	488360	If they explain it to me and say this tweet was deleted, then I'm like, oh, okay, well,
488360	490720	I'm not going to keep hitting like because it's gone.
490720	492800	I understand that now.
492800	496360	And the best of all would be to explain and then fix the problem.
496360	501640	So basically say, hey, this tweet was deleted and then not leave the UI in a state where
501640	504280	I can continue to hammer on the like button at all.
504280	509520	Say like this tweet was deleted and then actually synchronize, like change it so it doesn't look
509520	514120	like this anymore, maybe gray it out, maybe fade out the whole tweet itself.
514120	516240	There are any number of things you can do.
516240	519200	But these all require different degrees of effort.
519200	523360	So in order to synchronize while also reporting the error, it's not just that the server has
523360	524840	to send back a 500.
524840	529560	It also has to say, here's what the problem was and also describe how to synchronize the
529560	534320	state in some particular format, which my client then has to be looking for and know
534320	537400	to say, oh, I understand that I got this additional data.
537400	541480	Now I can use this to sort of patch my understanding of the world so that I'm now synchronized
541480	542480	with the server.
542480	545040	It's a lot more work to deal with that synchronization error.
545040	549280	And that's not even getting into what happens if we're trying to synchronize across multiple
549280	553160	clients where it's not clear who the source of truth is and we have to resolve conflicts.
553160	559520	So this can be a lot of work, like a lot, a lot of work if you want to do it right.
559520	561360	First of all, you have to make the updates in the first place.
561360	564960	If we have multiple sources of truth and something changes, we have to go around and propagate
564960	569000	those updates to all of the potential places where it could get out of sync.
569000	572320	Once we've done that, then we have to detect errors, figure out if things are out of sync
572320	574400	as they were in the case of this tweet.
574400	577880	And then once we've detected them, then we have to potentially resolve conflicts.
577880	582720	If we have lack of clarity around who is the source of truth, we have multiple clients
582720	585200	who made edits at the same time on the same document.
585200	586200	How do we resolve those?
586200	587400	There's a lot of techniques for doing that.
587400	589600	That's kind of a whole field of study.
589600	592280	And then finally, ideally, gracefully recovering.
592280	596960	So if we want to give people a good user experience or the best user experience we can in the
596960	602720	face of all of these potential synchronization problems, we'll look into a lot of work.
602720	606600	All of which is to say we really want to synchronize as little as possible.
606600	609880	The more we can have single source of truth and not have to deal with any of this and
609880	613520	not have to think about it, not have to worry about the errors, not have to spend time handling
613520	618760	them, resolving conflicts, repairing the state and getting things back in sync, the nicer
618760	623120	our lives are going to be and more likely, the most likely, the better our user experience
623120	625200	is going to be as well.
625200	626400	Okay.
626400	629040	So let's sort of draw a smaller box around this.
629040	632920	We've concluded that it's not possible to have a complete client server application
632920	635200	where we have one single source of truth.
635200	639520	But what if we narrow it down a little bit just to the client UI state?
639520	642440	So if we just draw a box around that, what about now?
642520	645560	We actually can have a single source of truth.
645560	650160	And we as Elm programmers know this because we use the Elm architecture in which we have
650160	651160	a single source of truth.
651160	652320	That's what model's job is.
652320	657600	It is a single atomic immutable value that is the single source of truth for the entire
657600	660720	client application state and everything else is built on that.
660720	664200	And this is one of the reasons that the Elm architecture is nice to use, is that we have
664200	665560	the single source of truth.
665560	669320	We don't have to go around syncing a bunch of different disparate pieces of state.
669320	673080	Like we might if we had something that were, you know, that is like one of the sources
673080	676040	of truth and then we have a lot of other ones sprinkled around.
676040	677040	So this is a good thing.
677040	678960	This helps us out.
678960	681640	So this brings me to my other question from earlier.
681640	686040	Like when might model end up with multiple sources of truth anyway?
686040	690520	Like when might it go from being the single source of truth to being a store that contains
690520	694680	multiple values, each of which refer to the same piece of information and which might
694720	698720	have different values for that piece of information depending on which part of the model I look
698720	700760	at?
700760	704440	Well one case where this might genuinely want to happen is caching.
704440	707240	So and this is something that I would do for performance.
707240	710880	So like basically let's say I have some sort of really expensive calculation that I'm
710880	712960	doing using model data.
712960	715920	Really in web applications this almost never happens but it's conceivable.
715920	720200	I could have some really expensive thing that I have to do like 60 frames per second all
720200	722880	the time using data from the model.
722880	727240	And I can't cache it with HTML lazy for some reason but I mean usually I can and if I can
727240	730240	that's certainly how I want to do it because that's the cache that's very nicely managed
730240	731240	by the Elm runtime.
731240	734800	I don't have to think about caching validation which is one of the famously hard problems
734800	740880	in computer science and this calculation is so expensive that it's a performance bottleneck
740880	741880	in practice.
741880	744840	And now we're into the territory of extremely, extremely, extremely unlikely to the extremely
744840	751120	power because really when we're talking about performance problems it's pretty much always
751120	753000	to do with rendering stuff.
753000	756320	It's basically never to do with calculations like this in practice.
756320	759440	But let's say I did actually end up with something like that.
759440	763640	This is one of the things that caching is used for is you have a piece of state that says
763640	768280	I am sort of an intermediate value, some sort of incremental calculation and then I can
768280	771640	base future calculations on that just like incrementing and decrementing rather than
771640	774520	having to rebuild it all from scratch.
774520	779920	So yes it's not like you should never, ever, ever in a bazillion years have duplicate information
779920	780920	in the model.
780920	784400	There is a use case but it's pretty rare in practice.
784400	788440	So that's also good news because it means we can have a single source of truth pretty
788440	790160	much all the time.
790160	792600	So how about relational data that gets stored in the model?
792600	796800	That is to say pieces of data where we have different pieces of information in the model
796800	799040	but they relate to one another in some way.
799040	803000	So let's look at an example of this.
803000	804000	Relational data.
804000	809280	So I work in a company called No Red Ink and we make stuff for English teachers.
809280	813080	Now let's say hypothetically, just for the purposes of this example, that we decided
813080	818360	to sort of like broaden our scope a little bit and we decided to introduce a new feature
818360	823040	which is not English related but actually it's field trip management.
823040	827720	This is why I'm not in charge of the product team.
827720	832040	So we're going to build this new feature that's going to allow teachers to manage a field trip
832040	836160	for their students where they take everybody on a bus and they go out somewhere interesting
836160	838560	for the day and learn things there.
838560	843160	So we've got an all day field trip coming up and the teacher wants to answer the question
843160	846800	which students are going, sort of manage this and check off, okay, these students are going,
846800	847880	these students are not going.
847880	851000	So let's look at this from a data modeling perspective.
851000	856680	So let's say we've got one of our students named Richard Feldman, going is false which
856680	860160	is why he's making that face.
860160	863240	Kid looks like a troublemaker.
863240	865080	So this is our very simple data model.
865080	868440	We have name which is a string and going which is a boolean.
868440	871480	And for our purposes, that's going to be enough.
871480	873760	And then the teacher has multiple courses.
873760	876360	So let's say a teacher has a course called second period English.
876360	882000	It's a very common name for a course that we see in practice and the teacher has a couple
882000	883000	of students in that course.
883000	889680	So R. Feldman, B. Knowles, A. Einstein and they can sort of check and uncheck which students
889680	892040	are going to be going on this field trip.
892040	893280	This is the UI we're building.
893280	895960	They might have another course called fifth period history.
895960	899600	So sometimes we have teachers who have, they're not dedicated English teachers.
899600	903120	They have some courses that are English and then some courses that are another subject.
903120	906520	And sometimes they use no reading because we teach writing among other things.
906520	909720	And so they want their history students to be able to write more effective essays.
909720	914280	So they'll have no reading activated for both their history course and their English course.
914280	917560	And of course, if you're teaching multiple subjects, you can have the same student in
917560	918560	multiple courses.
918560	922800	So Richard Feldman could be in second period English as well as fifth period history in
922800	926760	addition to some other number of students.
926760	929520	So this is an entirely plausible scenario that we might end up with.
929520	932960	And of course, this is relational data that we have students have a relationship to the
932960	936000	course and also we have some sort of notion of identity.
936000	939640	Like Richard Feldman is the same student whether he's in second period English or in fifth
939640	941760	period history.
941760	945040	So if the teacher checks one of these boxes because it's the same person, like either
945040	948160	he's going on the field trip or he's not and it's an all day field trip.
948160	952160	So certainly he's not going to be going for second period but not fifth period.
952160	956360	So if the teacher checks one of the boxes because of the relationships innate in this
956360	958960	data, it should check both of the boxes.
958960	961720	That's otherwise, you know, we've got some sort of mistake.
961720	965840	We should never end up with the teacher seeing this in their UI or else we've done something
965840	966840	wrong.
966840	968920	This would be a synchronization bug.
968920	970520	Okay.
970520	975360	So in JavaScript, the way that I might have done this is I would say something like going
975360	979280	back to the very beginning of the talk, courses brackets zero dot students brackets zero dot
979280	980600	going equals true.
980600	986400	Which is to say the first student in the first course is now going on the field trip.
986400	990200	When I check that box, that's what we've changed about our data model.
990200	994440	Now if I do this and I put into a REPL courses brackets zero dot students brackets zero, it
994440	998360	would now say, hey, this student is now going, great.
998360	1002960	And also, if I said courses bracket one, which is to say fifth period English dot students
1002960	1006680	brackets zero, it would also say that that student is going.
1006680	1011200	And the reason for that is that students in both cases are mutable references in JavaScript.
1011200	1015480	These are JavaScript objects, JavaScript objects are mutable, and they store mutable references
1015480	1017280	to other objects.
1017280	1020960	So both of these are actually pointing to the same student in memory, which means if
1020960	1023600	I change the one, it's going to change the other as well.
1023600	1027680	Now this has various downsides that we're probably familiar with, like you pass something
1027680	1031480	to a function, you're not sure if that function is going to mutate or not, plenty of downsides,
1031480	1035120	but this is one of the upsides when it comes to data consistency.
1035160	1039960	It means that when I mutate one, it automatically mutates all the others at the same time for
1039960	1040960	me.
1040960	1045600	So this is an example of relational data with a single source of truth.
1045600	1050280	We don't actually have any duplicate information in this data model that we've built in this
1050280	1052480	sort of JavaScript version.
1052480	1057000	Okay, so now I'm, you know, was a JavaScript programmer, now I've transitioned to an Elm
1057000	1060680	programmer, and so now I'm thinking in terms of immutable data.
1060680	1064320	So one way that we might model this in Elm, and probably the way that I would have modeled
1064360	1068920	it when I was starting out, I would say type alias student, name colon string, going is
1068920	1075760	a Boolean, then I'd have type alias course, name is a string, students is a list of students,
1075760	1080560	so we have nested records here, and then finally I would have my model which would have courses,
1080560	1083960	which is a list of course, and then various other things, but at least within the scope
1083960	1087680	of what we're talking about here, these are the relevant structures that we'd be dealing
1087680	1088680	with.
1088680	1093680	Now, believe it or not, already we've introduced multiple sources of truth.
1093720	1097600	Even though this basically looks like a description of the same sort of schema that we had in
1097600	1101960	the JavaScript version, just by virtue of the fact that we've gone from mutable objects
1101960	1106120	to immutable data, we have now accidentally introduced multiple sources of truth.
1106120	1111120	And this is kind of an easy thing to do, at least it was for me, when going from JavaScript
1111120	1114480	to Elm because I'm like, oh, well, records look like objects, so I'll just take the thing
1114480	1118000	that I would have done with an object and I'll just do it with a record.
1118000	1122800	But it turns out that that mutable to immutable characteristic is actually significant implications
1123800	1129800	to sort of do a more apples to apples transition, let's go from the JavaScript object that
1129800	1135800	we did before to the JavaScript object notation, better known as JSON, because JavaScript
1135800	1139640	objects are mutable references, but JSON is actually immutable data, which it sort of
1139640	1140640	has to be to serialize.
1140640	1144360	If you want to serialize mutable references to memory locations and just write them straight
1144360	1147720	to the disk, it's probably not likely to work out very well when you try to deserialize
1147720	1148720	them.
1148720	1153760	JSON is immutable despite having the same structure as JavaScript objects.
1153760	1155240	So let's look at the JSON version of this.
1155240	1159920	So we have courses, we have name, second period English, students, and then an array, name
1159920	1165840	Richard Feldman going false, and then another course, name, fifth period history, students,
1165840	1168560	name Richard Feldman going false.
1168560	1172800	So now we can kind of see more clearly that we actually do, in fact, have duplicated data
1172800	1173800	now.
1173800	1178680	Like before, both of those students were pointing to the same point in memory, but now we actually
1178680	1181560	have two different independent pieces of data.
1181560	1183240	So that means that they can now get out of sync.
1183240	1187600	I can change one of them to true without changing the other one to false.
1187600	1189520	That's a potential problem.
1189520	1195600	So objects have mutable references, whereas records, and JSON, have immutable records.
1195600	1199400	So objects have this upside of sort of implicit synchronization that sort of automatically
1199400	1204400	happens whenever you change something, whereas records also have their own set of upsides,
1204400	1208280	really cheap copying, equality checks that can just do reference equality, so on and
1208280	1209360	so forth.
1209360	1213400	But this is something that we have to be aware of when we're going from objects to records.
1213400	1215960	This is a pretty significant difference.
1215960	1219880	So let's move along to immutable relational data.
1219880	1224200	So what are we going to do differently when we are transitioning to the world of immutability?
1224200	1227080	Okay, so this was sort of the problem that we ran into.
1227080	1229840	We had this duplicated data, and it could get out of sync.
1229840	1233400	We could have going is true in one case and going is false in the other case, and that
1233400	1236080	shouldn't be possible because it's the same student.
1236080	1238920	Whether he's going on the field trip or he's not.
1238920	1244080	So one way we could create a single source of truth out of this is by changing the JSON
1244080	1246680	to look like this.
1246680	1247920	So let's look at these differences here.
1247920	1254040	So the first thing is we've introduced explicit identifiers for what the student refers to.
1254040	1258760	We're no longer using memory references, we're actually using identifiers as references.
1258760	1262800	So here we have students is just an array of IDs.
1262800	1268200	So ID 217, we see down at the bottom there, refers to Richard Feldman.
1268200	1271760	And that's the only place that Richard Feldman appears in this whole data model.
1271760	1275880	Everywhere else it's an identifier referring to that one single source of truth.
1275880	1282080	So we're using explicit identifiers to reference a single source of truth in a completely immutable
1282080	1283800	way.
1283800	1290960	So let's translate that idea into L. So we've got our type alias student course model.
1290960	1292080	So this is what we had before.
1292080	1295760	We had a list of students under course and we had a list of courses under model.
1295760	1297920	So we're going to tweak that a little bit.
1297920	1301720	Instead we're going to go from students to student IDs, which is going to be a list
1301720	1303600	of student ID values.
1303600	1308000	So student ID type could be whatever you want, you know, integers as we saw in the JSON example,
1308000	1311480	strings, custom types, anything you want.
1311480	1315560	Inside the model we're going to have students as a new value in the model.
1315560	1319360	This is our single source of truth for all of our students across the entire model.
1319360	1321280	And it's going to be a dictionary.
1321320	1324760	So we're going to change on that same student ID and then having a single source of truth
1324760	1329720	be the value of that particular student stored in that dictionary.
1329720	1333320	By the way, one thing we would also want to do here, I think, that can sort of take this
1333320	1336920	data model a little bit one step further, is to change from a list of student IDs to
1336920	1338400	a set of student IDs.
1338400	1342680	Because really, like, would it ever be useful to have the same student appear multiple times
1342680	1343880	in the same course?
1343880	1344880	Not really.
1344880	1346800	That should be a set because sets have uniqueness.
1347200	1353560	We should only have at most one student ID of the same value inside each course.
1353560	1357520	OK, so now let's write a function called students in course that's going to take one
1357520	1362280	of these courses, maybe something inside update, and it's going to return a list of
1362280	1363280	students.
1363280	1366960	So this is sort of our replacement for we want to work in terms of a list of students,
1366960	1370320	which is why we originally said courses just have a list of students, but now we're just
1370320	1372840	going to do a function to do the same thing.
1372840	1374240	So it's going to take a course as an argument.
1374680	1377800	And it's going to start off by doing a dicks.filter.
1377800	1379240	What's it going to filter on?
1379240	1383360	It's going to say, OK, I'm going to look at each of the students that I have, and I'm
1383360	1386480	going to say, am I in this particular course?
1386480	1391200	The way I can tell if I'm in this particular course is set.member, that particular student's
1391200	1395040	ID, and the course's set of student IDs.
1395040	1399560	So this is going to filter that dictionary of all the students down to just the ones
1399560	1401320	who are in that particular course.
1401320	1402200	And that's it.
1402240	1407200	We have now gone from our single source of truth of all students in one expression down
1407200	1412280	to a single source of truth for the list of students that are in that particular course.
1412280	1415280	And now we can do whatever we want with that list of students, whatever we would have done
1415280	1418720	previously by courses.students.
1418720	1421880	And then, of course, if we want to actually get it from a dictionary to a list of students,
1421880	1424600	we'd pipe it to dicks.values.
1424600	1429320	OK, so here we have an example of immutable relational data where we've maintained a single
1429320	1432320	source of truth, which means no synchronization problems.
1432320	1435800	Also it means no nested record updates, which is cool.
1435800	1440000	But basically, we no longer have that whole series of problems where we have to keep things
1440000	1444800	updated, keep things in sync, detect errors, resolve conflicts, and so on and so forth.
1444800	1447880	OK, but what about like more complex relationships?
1447880	1450640	What if we had the JavaScript equivalent of something like this?
1450640	1455320	Courses bracket zero.students bracket three.assignments bracket two.is done, something where we have
1455320	1459200	lots of relationships and we're trying to merge them all together.
1459200	1461080	How does this sort of like scale?
1461080	1465960	Well, there's actually, as it turns out, an entire sort of field of study and a lot
1465960	1469720	of implementations that work with these types of questions.
1469720	1473120	If anyone recognizes this logo, this is a good elephant.
1473120	1474120	This is PostgreSQL.
1474120	1479760	You also got other databases like MySQL, SQLites, and it turns out relational data has been
1479760	1484680	well studied and explored by relational databases.
1484680	1492960	And we can, what's the word I'm looking for, steal shamelessly from the things that they've
1492960	1497400	learned over the years about dealing with relational data without dealing with mutable
1497400	1501280	references, which they don't use because they need to serialize everything to the disk.
1501280	1505920	So what if we think about dictionaries as sort of like an analogy for database tables?
1505920	1506920	What could that do for us?
1506920	1511440	So what if we thought about things like select, where, and join in terms of SQL, and then
1511440	1516760	we translated those to dictionary concepts like get, filter, intersect, and so forth.
1516760	1517760	How might that look?
1517760	1520800	So here's a really, really simple SQL query.
1520800	1522560	Select count star from users.
1522560	1525920	So that's sort of the equivalent of saying like, tick dot size users.
1525920	1526920	Ha.
1526920	1528800	Stake in the slides.
1528800	1531480	Select count star from users where age is greater than or equal to 18.
1531480	1534680	This would be voting age users in the U.S.
1534680	1538840	So the equivalent to that, dicks dot filter is voting age users, which is kind of nice
1538840	1542280	because it's actually a little bit more descriptive than the greater than or equal to 18.
1542280	1543680	And then pipe that to dicks dot size.
1543680	1546200	I got it right on this slide.
1546200	1549560	So this is like a slightly more advanced query.
1549560	1552040	So what if we just, okay, let's just go for it.
1552040	1553040	Let's do joins.
1553040	1554040	Let's do where.
1554040	1555600	Let's just get some more stuff in there.
1555600	1558560	Select count star from users where age is greater than or equal to 18.
1558560	1565000	So this is voting age users inner join residence on residence.id equals users.id where residence.city
1565000	1566000	equals stl.
1566000	1573280	And now we're saying who are, like, how many users are a voting age and live in St. Louis?
1573280	1575280	How do we do that using dictionaries?
1575280	1580000	Well, let's start by defining a couple of type aliases because we can't just, you know,
1580000	1581000	use a plain old dictionary.
1581000	1583040	We're going to need to get some records involved here.
1583040	1586000	So let's say we have user, which is user ID and age.
1586000	1590680	And then we also have a model which has users, which is a dictionary between user ID and
1590680	1591680	user.
1591680	1595800	And we have residence, which is a dictionary between user ID and city ID or user ID and
1595800	1596840	city.
1596840	1598840	So these are, like, examples.
1598840	1602240	You can imagine many more dictionaries all at the top level, but you can model as many
1602240	1606720	relationships between as many different entities as we want, just like how databases have tables
1606720	1611600	all at the top level, which model relationships between as many different tables as you want.
1611600	1614280	So here's how we might implement this query.
1614280	1617640	So we could say locals, which is to say St. Louis locals or St. Louisans or if you're
1617640	1620720	part of Nellie's crew, St. Lunatics.
1620720	1625120	And we would say dix.filter, user ID, city, so that user ID being the key and then the
1625120	1628920	city being the value, city.name, double equals stl.
1628920	1633320	So this is going to give us, among all the residents, only those whose city is St. Louis.
1633320	1638120	Then we can do dix.filter on isvotingage, model.users, just like before.
1638120	1641840	So now we have a dictionary of all the users who are voting age.
1641840	1647520	And then to do the join, we do dix.intersect locals, which is going to take all of the
1647520	1651680	users that we've filtered out for just the ones that have voting age, and then also all
1651680	1656520	of those that have city name of St. Louis, because that's where they live.
1656520	1658840	And then finally, dix.size.
1658840	1662600	So just by using a couple of simple expressions, we end up with being able to essentially do
1662600	1666040	the same types of things that we could do in a relational database.
1666040	1670120	This is like pretty powerful stuff, and it's all with a single source of truth.
1670120	1671880	And no nested record updates.
1671880	1672880	Pretty cool.
1672880	1673880	Okay.
1673880	1677400	If you're curious to learn some more data modeling techniques, completely shameless
1677400	1678400	plug.
1678400	1681760	There's this book by a dude, Elman Action.
1681760	1682760	So check it out.
1682760	1683760	Okay.
1683760	1684760	So let's recap.
1684760	1689280	So first we talked about state synchronization, sort of some of the problems, some of the
1689280	1690280	pitfalls.
1690280	1694440	We talked about relational data, and then we talked about immutable relational data without
1694440	1696440	using mutable references.
1696440	1700640	We talked about how a single source of truth means there's nothing to synchronize.
1700640	1704360	All of those problems that we saw with state synchronization, completely out the window,
1704360	1706920	none of those tweet-related problems.
1706960	1710920	We talked about the synchronization work that has to be done if we do have multiple sources
1710920	1714880	of truth, making updates, detecting errors, resolving conflicts, gracefully recovering
1714880	1716440	in the ideal case.
1716440	1720040	And we talked about how relational data can be done with a single source of truth, and
1720040	1723840	in fact, immutable relational data can still be done with a single source of truth, which
1723840	1728160	is really what we would prefer to do if we have the option.
1728160	1732400	Then we talked about dictionaries as tables, and sort of how we can use the metaphor of
1732400	1736760	tables that appear in relational databases to do the same kinds of data modeling activities
1737040	1738040	using dictionaries.
1738040	1741840	And finally, we come back to the original two questions that I had.
1741840	1744240	When should I put duplicate information in my model?
1744240	1748800	The answer is basically almost never, unless performance absolutely demands a cache, and
1748800	1752480	I'm really sure I have a performance problem, and I really just can't avoid it.
1752480	1755840	That's really the only situation I've ever come across where I would say that that's
1755840	1757560	a good idea.
1757560	1759720	And how would I do something like this in Elm?
1759720	1765600	Of course, it's bracket zero.studentbracketzero.selected equals true using dictionaries as tables.
1765600	1766640	Thanks very much.
