1
00:00:00,000 --> 00:00:11,640
Okay, I'm Evan Treplicchi, I designed the Elm programming language, and what I wanted

2
00:00:11,640 --> 00:00:17,280
to talk about is people often wonder, they see similarities between React and Elm, both

3
00:00:17,280 --> 00:00:21,400
these things are about creating things in browsers, these interactive applications,

4
00:00:21,400 --> 00:00:25,480
and people say, well, which came first, where, who originated this idea, that idea?

5
00:00:25,480 --> 00:00:30,360
And so I thought I could offer a sort of unique perspective on how these things evolved in

6
00:00:30,360 --> 00:00:31,360
the timeline.

7
00:00:31,360 --> 00:00:37,800
And what's interesting is that usually it's a case of conversion evolution, where something

8
00:00:37,800 --> 00:00:43,040
was going on inside Facebook, I didn't know about it, and independently I was working

9
00:00:43,040 --> 00:00:49,680
on my thesis at college, coming up with certain ideas, and it just turns out we came to a

10
00:00:49,680 --> 00:00:53,920
lot of similar conclusions, and so I want to emphasize those and sort of see what that

11
00:00:53,920 --> 00:00:55,040
might mean.

12
00:00:55,040 --> 00:01:01,080
And I want to start by giving an example of conversion evolution, just from real life,

13
00:01:01,080 --> 00:01:05,960
which is you have these sort of very different creatures, birds and bees, that both can fly.

14
00:01:05,960 --> 00:01:11,440
They both somehow ended up with wings, even though millions of years ago they diverged

15
00:01:11,440 --> 00:01:13,040
evolutionarily.

16
00:01:13,040 --> 00:01:19,800
And one thing that a developer might say when they see this connection is like, well, who

17
00:01:19,800 --> 00:01:20,800
did it better?

18
00:01:20,800 --> 00:01:25,640
Who did wings best?

19
00:01:25,640 --> 00:01:32,440
And so one person may say, okay, well, birds, they have feathers, that's pretty cool.

20
00:01:32,440 --> 00:01:34,160
Whereas wings, they have chitin.

21
00:01:34,160 --> 00:01:37,960
And so with feathers, well, if it gets damaged, it can be replaced.

22
00:01:37,960 --> 00:01:41,680
Whereas with chitin, if it gets chipped, it's just chipped, it's just bad now.

23
00:01:41,680 --> 00:01:48,880
So like, but I think this is kind of a silly question, and in this context, like, it sort

24
00:01:48,920 --> 00:01:50,760
of seems ridiculous.

25
00:01:50,760 --> 00:01:55,480
And I prefer to ask the question, how does this design fit in with all the other features?

26
00:01:55,480 --> 00:02:00,440
So if we take a step back and we look at bees, well, bees have the exoskeleton, that's also

27
00:02:00,440 --> 00:02:01,600
made of chitin.

28
00:02:01,600 --> 00:02:04,800
And so the fact that the same material can be what their wings are made of, there's no

29
00:02:04,800 --> 00:02:09,760
extra nutrients that they need to be able to fly, it's kind of a beautiful design.

30
00:02:09,760 --> 00:02:13,640
They also have an open circulatory system, so instead of a heart, they just have like,

31
00:02:13,640 --> 00:02:19,280
they don't have blood, it's just like hemolymph seeps through their shell.

32
00:02:19,280 --> 00:02:25,360
Point is, they don't live a super long time because that's not an ideal system.

33
00:02:25,360 --> 00:02:32,280
But for the purpose of a bee, it's like, I'm going to be alive for six weeks, maybe a couple

34
00:02:32,280 --> 00:02:36,040
months, and if a wing gets chipped in that time, it's going to serve its purpose and

35
00:02:36,040 --> 00:02:38,520
do a really good job in that context.

36
00:02:38,520 --> 00:02:43,440
Whereas with a bird, you have hollow bones, and hey, if the bone breaks, the wing is broken

37
00:02:43,440 --> 00:02:49,520
too, so that thing about feathers wasn't such a nice thing.

38
00:02:49,520 --> 00:02:52,800
And they have a four-chamber heart, so they can be much bigger, so they can use their

39
00:02:52,800 --> 00:02:57,480
wings to kill bugs, so they're using the wings in very different ways.

40
00:02:57,480 --> 00:03:01,760
The big point here is that flying seems like a good idea.

41
00:03:01,760 --> 00:03:05,200
And the fact that these two creatures came to the same conclusion in these totally different

42
00:03:05,200 --> 00:03:13,240
ways with these totally different other feature sets, it's suggested like flying, it's pretty

43
00:03:13,240 --> 00:03:15,400
neat.

44
00:03:15,400 --> 00:03:19,480
And so when it comes to implementation details, I prefer to ask, how does this fit with other

45
00:03:19,480 --> 00:03:23,120
features rather than who did flying best?

46
00:03:23,120 --> 00:03:28,920
So with that context, we're going to try to do a similar thing with React and Elm.

47
00:03:28,920 --> 00:03:32,640
So one of the features that React and Elm have in common is virtual DOM.

48
00:03:32,640 --> 00:03:39,160
And so when I was working on Elm from the very beginning, we were having functions that

49
00:03:39,160 --> 00:03:42,680
would create this data structure, and then I would just, based on that data structure,

50
00:03:42,680 --> 00:03:46,000
we built the DOM on every frame.

51
00:03:46,000 --> 00:03:50,280
And I was like, that's kind of crazy, I don't know if that's going to work out.

52
00:03:50,280 --> 00:03:53,800
And so over time, I was like, okay, well, I can incrementally do it so it doesn't flash,

53
00:03:53,800 --> 00:03:56,200
and I can preserve some information.

54
00:03:56,200 --> 00:04:00,960
And subsequently, I saw that React did the same thing, and that sort of really validated

55
00:04:00,960 --> 00:04:07,680
that design that I think anyone I asked who would have said, that's obviously crazy.

56
00:04:07,680 --> 00:04:12,440
And so when you look into the details in virtual DOM, with React, you have a special

57
00:04:12,440 --> 00:04:17,240
syntax called JSX, so it's giving you this familiar HTML in your JavaScript code.

58
00:04:17,240 --> 00:04:20,360
Whereas in Elm, we don't have a special syntax, and this is something that people, when they

59
00:04:20,360 --> 00:04:24,960
come to Elm, will find weird, it's like, well, how do I set this up?

60
00:04:24,960 --> 00:04:31,520
So I want to show a little program here.

61
00:04:31,520 --> 00:04:40,640
So I'm going to take a program from the Elm guide.

62
00:04:40,640 --> 00:04:48,400
That's just like the very beginner thing, and we'll take a look at it.

63
00:04:48,400 --> 00:04:53,080
Tell me when you can see this.

64
00:04:53,080 --> 00:04:56,080
Okay.

65
00:04:56,080 --> 00:05:00,240
This is the problem of having the massive high resolution.

66
00:05:00,240 --> 00:05:03,040
It's quite the right size.

67
00:05:03,040 --> 00:05:04,200
Okay.

68
00:05:04,200 --> 00:05:08,680
So I'm going to build that, and we can look at how the view code works here.

69
00:05:08,680 --> 00:05:12,480
So rather than an HTML-style thing, we're saying, okay, I have a div, and it has three

70
00:05:12,480 --> 00:05:15,840
children, a button, a div, and another button.

71
00:05:15,840 --> 00:05:23,960
And when I actually go look at that code, we can see, okay, not the most exciting beginner

72
00:05:23,960 --> 00:05:26,760
program, but it does something.

73
00:05:26,760 --> 00:05:30,840
And when we look back at the view code, we see that exact structure.

74
00:05:30,840 --> 00:05:31,840
We have the button.

75
00:05:31,840 --> 00:05:33,720
It's got a negative sign.

76
00:05:33,720 --> 00:05:37,320
And what's neat about doing this all in Elm is anything you want to do, you can do it

77
00:05:37,320 --> 00:05:38,320
in Elm syntax.

78
00:05:38,320 --> 00:05:45,240
So rather than saying I want a number here, I can say maybe I want a list, and I want

79
00:05:45,240 --> 00:05:52,360
to view a dot for every number from one to the count.

80
00:05:52,360 --> 00:05:56,880
And then I can just make an Elm function of view dot that takes the number, and instead

81
00:05:56,880 --> 00:06:00,680
it just says, I'll show a star here.

82
00:06:00,680 --> 00:06:08,440
And so when I compile that, I can go and look, and oops.

83
00:06:08,440 --> 00:06:11,080
So now I see dots when it shows up.

84
00:06:11,080 --> 00:06:12,440
So it's quite a nice thing.

85
00:06:12,440 --> 00:06:16,560
So if I want to use any feature of Elm, it's sort of like the templating language for Elm

86
00:06:16,560 --> 00:06:18,800
is Elm.

87
00:06:18,800 --> 00:06:22,000
So I'm not here to say one way is better or not.

88
00:06:22,000 --> 00:06:24,040
It's better to look at it in context.

89
00:06:24,040 --> 00:06:29,120
And so in the React world, you're using JavaScript, you're using the C-style syntax.

90
00:06:29,120 --> 00:06:33,760
And this goes back to 1972 at least when C came out.

91
00:06:33,760 --> 00:06:39,560
And so JavaScript, if you believe the origin myths, could have had a Lisp syntax.

92
00:06:39,560 --> 00:06:43,720
But for the sake of familiarity, went with the C-style syntax that everyone was familiar

93
00:06:43,720 --> 00:06:44,720
with.

94
00:06:44,720 --> 00:06:50,040
So essentially, this is an ecosystem that's putting a premium or using familiarity as

95
00:06:50,040 --> 00:06:56,600
an onboarding tool to make people feel confident and dive into things and use that to learn.

96
00:06:56,600 --> 00:06:58,840
Whereas in Elm, I have an ML-style syntax.

97
00:06:58,840 --> 00:07:06,160
And interestingly, that goes back to 1973 at least, but it's just not as widely known.

98
00:07:06,160 --> 00:07:09,720
And so to say, well, which of these is better is kind of like saying, well, is Arabic script

99
00:07:09,720 --> 00:07:11,720
better or is Korean script better?

100
00:07:11,720 --> 00:07:13,760
It's like, well, which one do you know?

101
00:07:13,760 --> 00:07:18,640
And you probably will prefer that one, at least at first.

102
00:07:18,640 --> 00:07:23,840
And so I know that Elm pays a familiarity cost in making this choice.

103
00:07:23,840 --> 00:07:27,440
But I think it fits in with all the other Elm features that we're going to see.

104
00:07:27,440 --> 00:07:33,840
And so I'm willing to pay that hit in maybe where our community grows a little bit slower.

105
00:07:33,840 --> 00:07:35,440
But it makes this coherent whole.

106
00:07:35,440 --> 00:07:38,400
And so when a question comes up, should we use something like JSX?

107
00:07:38,400 --> 00:07:46,560
It's like, well, we've already sort of committed to not using syntax as an onboarding technique.

108
00:07:46,560 --> 00:07:49,880
So we'll come back to that and see how it fits in more.

109
00:07:49,880 --> 00:07:54,240
So another thing that React and Elm have in common is unidirectional flow.

110
00:07:54,240 --> 00:08:03,280
And so for me, I first sort of, this became a distinct concept for me when I was at Hacker

111
00:08:03,280 --> 00:08:06,120
School, now Recurse Center back in 2014.

112
00:08:06,120 --> 00:08:08,800
And a student there made this game called Bessel.

113
00:08:08,800 --> 00:08:14,760
And this student had never done like functional programming before.

114
00:08:14,760 --> 00:08:17,840
They had done Python, I think, with the language that they knew.

115
00:08:17,840 --> 00:08:21,120
And while I was there for the two weeks, they wanted to try something out.

116
00:08:21,120 --> 00:08:24,320
So they made this little game where you have to go through the blood vessel.

117
00:08:24,320 --> 00:08:27,600
And if you run into the wall, you explode.

118
00:08:27,600 --> 00:08:29,200
And so this is like a weak project.

119
00:08:29,200 --> 00:08:32,200
He's just trying functional programming for the first time.

120
00:08:32,200 --> 00:08:34,400
And at the end, he asked me for a code review.

121
00:08:34,400 --> 00:08:38,640
And what was crazy was his code was really good.

122
00:08:38,640 --> 00:08:43,960
And that's not to say like, it's just like when you start, I found it surprising that

123
00:08:43,960 --> 00:08:46,360
someone starting functional programming for the first time would end up with a program

124
00:08:46,360 --> 00:08:48,400
where like, that's how I would architect it.

125
00:08:48,400 --> 00:08:51,960
I have no concerns, like that's great.

126
00:08:51,960 --> 00:08:54,760
And it matched how I would structure my code as well.

127
00:08:54,760 --> 00:08:56,680
And I thought that was just a me thing.

128
00:08:56,680 --> 00:08:59,920
And so this was when I started to notice, okay, there's this pattern that sort of Elm

129
00:08:59,920 --> 00:09:01,920
wants us to write code in a certain way.

130
00:09:01,920 --> 00:09:05,880
So this is when the Elm architecture sort of got a name, even though everyone who used

131
00:09:05,880 --> 00:09:09,040
it, who used Elm had been doing this kind of pattern.

132
00:09:09,040 --> 00:09:14,400
And the idea is that you have a model that says what's going on in your application.

133
00:09:14,400 --> 00:09:15,800
And it creates HTML.

134
00:09:15,800 --> 00:09:17,680
That gets sent to the Elm runtime system.

135
00:09:17,680 --> 00:09:21,440
It renders it, deals with the DOM, does the diffing, all that kind of stuff.

136
00:09:21,440 --> 00:09:23,640
And then it'll send back messages.

137
00:09:23,640 --> 00:09:25,600
And that is how you update your model.

138
00:09:25,600 --> 00:09:30,000
You send new HTML, and the cycle just goes round and round and round.

139
00:09:30,000 --> 00:09:33,600
And when I first presented this kind of stuff, again, this was something that seemed like

140
00:09:33,600 --> 00:09:35,640
a crazy idea.

141
00:09:35,640 --> 00:09:37,240
And from the JavaScript world, it looked crazy.

142
00:09:37,240 --> 00:09:38,760
From the functional world, it looked crazy.

143
00:09:38,760 --> 00:09:41,600
Everyone was like, this is silly.

144
00:09:41,600 --> 00:09:47,040
And so when I saw that React had this thing called, they were promoting this thing called

145
00:09:47,040 --> 00:09:50,720
Flux, I was like, okay, that actually sort of validates this design.

146
00:09:50,720 --> 00:09:54,160
And it sort of arose, I think, separately.

147
00:09:54,160 --> 00:10:02,880
Since Flux, there's been more, it hasn't been as much independent development.

148
00:10:02,880 --> 00:10:05,320
So people have seen Elm architecture and things as neat.

149
00:10:05,320 --> 00:10:09,000
But so let's look at what the Elm architecture looked like in Elm.

150
00:10:09,000 --> 00:10:14,600
So we can go back to our little counter program.

151
00:10:14,600 --> 00:10:17,160
And we have a model.

152
00:10:17,160 --> 00:10:20,000
And in this case, it's just a number that we're counting up.

153
00:10:20,000 --> 00:10:21,240
And we have a way to update.

154
00:10:21,240 --> 00:10:24,840
So if we want to increment our document, we have messages like that.

155
00:10:24,840 --> 00:10:29,560
And when we handle them in each case, and then we can put those in here.

156
00:10:29,560 --> 00:10:35,760
So if I wanted to add a new feature, I could say, okay, I want a thing called reset.

157
00:10:35,760 --> 00:10:39,640
And it's going to be a reset button.

158
00:10:39,640 --> 00:10:49,080
And I need to add in that kind of message and handle that case.

159
00:10:49,080 --> 00:10:59,520
And if we go look at it, now I have my same thing and I can reset back.

160
00:10:59,520 --> 00:11:02,200
So it sort of gives structure to your program.

161
00:11:02,200 --> 00:11:05,480
And so this is a really simple example, but it actually shows up in every Elm program

162
00:11:05,480 --> 00:11:06,480
ever.

163
00:11:06,480 --> 00:11:18,240
So if we go look at the to do MVC code, we see the structure again.

164
00:11:18,240 --> 00:11:19,640
So we start with a model.

165
00:11:19,640 --> 00:11:21,960
In this case, it's a bit more complicated.

166
00:11:21,960 --> 00:11:26,600
So let's open it up.

167
00:11:26,600 --> 00:11:31,240
So here we can say hello in all of this.

168
00:11:31,240 --> 00:11:34,080
So we have a model of, we have a list of entries.

169
00:11:34,080 --> 00:11:35,600
We have a field that you can type in.

170
00:11:35,600 --> 00:11:37,720
We have what things are visible or not.

171
00:11:37,720 --> 00:11:38,720
We have our entries.

172
00:11:38,720 --> 00:11:39,720
That has a description.

173
00:11:39,720 --> 00:11:40,720
Is it completed?

174
00:11:40,720 --> 00:11:42,560
Is it being edited?

175
00:11:42,560 --> 00:11:46,120
We have our messages, all the things that you can do to this program.

176
00:11:46,120 --> 00:11:48,820
And a way to update our program.

177
00:11:48,820 --> 00:11:53,640
And we have a view, which again is using this Elm as the HTML syntax.

178
00:11:53,640 --> 00:11:56,360
So you can see, okay, I've got a div.

179
00:11:56,360 --> 00:11:57,360
It's got some attributes.

180
00:11:57,360 --> 00:12:00,000
It's got some children.

181
00:12:00,000 --> 00:12:03,280
And we're just using Elm functions to create the different parts.

182
00:12:03,280 --> 00:12:06,200
So here's where the text input is, that kind of thing.

183
00:12:06,200 --> 00:12:11,200
And no matter what level of crazy program you go to, so another program you could look

184
00:12:11,200 --> 00:12:16,720
at is Richard did this real world thing that's been sort of going around the internet in

185
00:12:16,720 --> 00:12:17,720
Elm.

186
00:12:17,720 --> 00:12:20,960
And you see the same pattern again, where there's the model, there's the update, there's

187
00:12:20,960 --> 00:12:21,960
a view.

188
00:12:21,960 --> 00:12:24,800
And one thing that's really neat about this is when you come to an Elm project, you're

189
00:12:24,800 --> 00:12:29,040
immediately oriented, because you're like, every Elm project starts this way, and then

190
00:12:29,040 --> 00:12:33,240
they're just functions out from there.

191
00:12:33,240 --> 00:12:39,840
So when you go and put this in context, in the react world, my understanding is that

192
00:12:39,840 --> 00:12:42,440
not everyone is into unidirectional flow.

193
00:12:42,440 --> 00:12:47,400
And I think that's because components are an important idea in the react world.

194
00:12:47,400 --> 00:12:53,080
And when I look at components, I see local, state, methods, like getters and setters to

195
00:12:53,080 --> 00:12:54,080
deal with it.

196
00:12:54,280 --> 00:12:56,680
Whenever I think of that, I think of an object.

197
00:12:56,680 --> 00:12:58,760
We've got local, state, getters and setters.

198
00:12:58,760 --> 00:13:01,200
It's sort of an object-oriented way of thinking.

199
00:13:01,200 --> 00:13:04,480
And that's one way to approach things, and this unidirectional flow is another way to

200
00:13:04,480 --> 00:13:05,480
approach it.

201
00:13:05,480 --> 00:13:09,560
Whereas in Elm, we don't have the objects, we just have functions.

202
00:13:09,560 --> 00:13:13,040
And if that's your only tool, you're going to end up with a unidirectional flow.

203
00:13:13,040 --> 00:13:17,240
So because of the feature set of Elm, it really makes sense that that's how all Elm programs

204
00:13:17,240 --> 00:13:18,240
work.

205
00:13:18,240 --> 00:13:22,320
And because the feature set of react, it makes sense that people might mix and match and use

206
00:13:22,320 --> 00:13:27,880
some depending on what their case is, depending on what their preferences are.

207
00:13:27,880 --> 00:13:33,080
Another case that people ended up at independently is immutability.

208
00:13:33,080 --> 00:13:38,560
So Elm is a language where every single value in the whole language is immutable.

209
00:13:38,560 --> 00:13:44,880
And so I think this became important in the react world because react has this thing called

210
00:13:44,880 --> 00:13:52,920
shouldComponentUpdate, and it looks something like this, where you have some function and

211
00:13:52,920 --> 00:13:56,080
you're saying, all right, did any of these properties change?

212
00:13:56,080 --> 00:13:58,600
If so, we should update.

213
00:13:58,600 --> 00:14:00,280
And I just want to do a quick poll.

214
00:14:00,280 --> 00:14:04,440
How many people have had a bug where they changed the component, but they forgot to

215
00:14:04,440 --> 00:14:09,560
change the shouldComponentUpdate, and then they were like, so how many people out there?

216
00:14:09,560 --> 00:14:14,640
Okay, was it a fun bug?

217
00:14:15,400 --> 00:14:19,280
This can be something that's super frustrating because you're like, I swear this code works,

218
00:14:19,280 --> 00:14:25,160
my test is fine, and you just don't think to look at this piece of code.

219
00:14:25,160 --> 00:14:32,320
And so ClosureScript, David Nolan came up with this idea of putting pairing shouldComponentUpdate

220
00:14:32,320 --> 00:14:34,160
with immutability.

221
00:14:34,160 --> 00:14:38,480
And so the basic realization is if you have an immutable value and you say, well, is this

222
00:14:38,480 --> 00:14:40,240
reference the same as that reference?

223
00:14:40,240 --> 00:14:43,200
No one could have changed it in the meantime, so it must be the same.

224
00:14:43,200 --> 00:14:49,680
And so it's a really nice way of making this reliable, even as the shape of that value changes.

225
00:14:49,680 --> 00:14:53,240
And so he wrote about this in this blog post, and I really want to give him credit for this

226
00:14:53,240 --> 00:14:58,640
idea because I think, one, it popularized, or like it made immutability palatable, like

227
00:14:58,640 --> 00:15:03,640
not an insane person idea in the JavaScript world, and it really made space for functional

228
00:15:03,640 --> 00:15:08,360
languages to have a place in front of development.

229
00:15:08,360 --> 00:15:10,520
So in Elm, everything's immutable.

230
00:15:10,520 --> 00:15:14,560
So I saw David Nolan's idea here, and I was like, great, like, what is this, how does

231
00:15:14,560 --> 00:15:18,720
this come to Elm in the Elmi way?

232
00:15:18,720 --> 00:15:21,400
And so we have this thing called lazy.

233
00:15:21,400 --> 00:15:29,880
So if we go look at our toDo app, I'm going to remove the lazies real quick so we can

234
00:15:29,880 --> 00:15:31,300
see it without.

235
00:15:31,300 --> 00:15:37,320
So here I have a div, it holds a section, and it has three subnodes.

236
00:15:37,320 --> 00:15:42,200
And so for the first one, I'm calling a function, and I'm giving it some field value, and that's

237
00:15:42,200 --> 00:15:43,960
what's going to show up in there.

238
00:15:43,960 --> 00:15:48,160
And so essentially what's happening when I add lazy is I'm saying, instead of calling

239
00:15:48,160 --> 00:15:53,920
this function now, building the virtual DOM, doing the diff, seeing if there's patches,

240
00:15:53,920 --> 00:15:58,960
and finding out yes or no, I'm going to say, okay, hold on to this function, hold on to

241
00:15:58,960 --> 00:16:04,400
this value, and when it's time to diff, I'll say, are these the same as last time?

242
00:16:04,400 --> 00:16:07,920
And if it's the same function by reference, same argument by reference, I'll just skip

243
00:16:07,920 --> 00:16:11,000
the whole thing because I know the results are going to be the same.

244
00:16:11,000 --> 00:16:16,600
And because everything in Elm is immutable, this is known to be safe.

245
00:16:16,600 --> 00:16:21,480
You can just trust, you can sprinkle in this lazy operator wherever you want.

246
00:16:21,480 --> 00:16:25,960
And so if we look around this file more, I use it in other places, so each entry in

247
00:16:25,960 --> 00:16:28,560
the list is lazy.

248
00:16:28,560 --> 00:16:33,400
This is the footer where there's some controls, so if we look at the app again, there's these

249
00:16:33,400 --> 00:16:38,720
kinds of things at the bottom.

250
00:16:38,720 --> 00:16:40,840
So that can be lazy too.

251
00:16:40,840 --> 00:16:44,200
And what's neat about this is it's not tied to the component itself, it's just if you

252
00:16:44,200 --> 00:16:50,960
have a function and you have some arguments, that can become a lazy piece of the structure.

253
00:16:50,960 --> 00:16:58,840
Okay, so another thing that React in Elm have in common that's maybe more, one of the more

254
00:16:58,840 --> 00:17:01,960
controversial things is static analysis.

255
00:17:01,960 --> 00:17:08,160
And so when I use that term, I mean how can computers look at your code and give you helpful

256
00:17:08,160 --> 00:17:15,760
timely hints that help make your code better and don't waste your time or don't give you

257
00:17:15,760 --> 00:17:17,280
good feedback.

258
00:17:17,280 --> 00:17:22,320
And so for React that may be a linter is a version of this, something like flow, something

259
00:17:22,320 --> 00:17:28,620
like TypeScript, giving this extra machine help to improve your code.

260
00:17:28,620 --> 00:17:32,660
So in Elm, static analysis has been sort of an important part from the very beginning.

261
00:17:32,660 --> 00:17:37,140
So in Elm, Compiler is able to give you these hints.

262
00:17:37,140 --> 00:17:39,620
And I want to look at a couple and try to put in context.

263
00:17:39,620 --> 00:17:45,020
It's something that's hard to, I feel like Elm programs have like a personal relationship

264
00:17:45,020 --> 00:17:49,320
with this, but it doesn't translate well, so I'm going to do my best.

265
00:17:49,320 --> 00:17:53,580
So we have here this little expression where I'm trying to join the strings Alice and Bob

266
00:17:53,580 --> 00:17:57,660
with the number four and it's saying, okay, function join is expecting the first argument

267
00:17:57,660 --> 00:17:59,900
to be a string, but in fact it's a number.

268
00:17:59,900 --> 00:18:03,860
So it's sort of giving you this very human explanation of what's going wrong in that

269
00:18:03,860 --> 00:18:04,860
code.

270
00:18:04,860 --> 00:18:07,300
And the neat thing is as your code gets bigger and bigger and bigger, the error may not be

271
00:18:07,300 --> 00:18:11,100
as simple as just it's the number four here, but you have some variable and through some

272
00:18:11,100 --> 00:18:14,820
other fact in your code base, it will be a number.

273
00:18:14,820 --> 00:18:16,460
It'll catch that as well.

274
00:18:16,460 --> 00:18:21,620
So in a little bit more complex case here, we have an if expression and in the body we're

275
00:18:21,620 --> 00:18:24,860
saying is the length, what is the length of this?

276
00:18:24,860 --> 00:18:28,300
And so Elm is saying, hey, this needs to be a Boolean value.

277
00:18:28,300 --> 00:18:30,940
You've given me an integer, but I need a Boolean.

278
00:18:30,940 --> 00:18:33,500
And what's nice about this one is it has the little hint.

279
00:18:33,500 --> 00:18:38,740
So I know that when people come to Elm, there's certain mistakes that are like super predictable,

280
00:18:38,740 --> 00:18:41,100
like lots of people are coming from Python, JavaScript.

281
00:18:41,100 --> 00:18:44,740
And so I try to give a hint that, hey, Elm doesn't have truthiness such that instance

282
00:18:44,740 --> 00:18:46,020
strings are automatically converted.

283
00:18:46,020 --> 00:18:48,300
You need to do that conversion explicitly.

284
00:18:48,300 --> 00:18:52,900
So I'm trying to give as much scaffolding as possible so that you know, okay, list length,

285
00:18:52,900 --> 00:18:53,900
is it equal to zero?

286
00:18:53,940 --> 00:18:58,460
Less than one is greater than 10, like be explicit about that kind of thing.

287
00:18:58,460 --> 00:19:03,300
Now I think those examples don't really show what this means in a large setting.

288
00:19:03,300 --> 00:19:07,660
So I work at this company called NoWriteInc, and we've been using Elm for about two years

289
00:19:07,660 --> 00:19:14,980
now, and we have about 200,000 lines of Elm code, and there's been zero runtime exceptions

290
00:19:14,980 --> 00:19:17,100
in production.

291
00:19:17,100 --> 00:19:23,260
And so the kinds of things that this is catching is really, really extensive, and it's doing

292
00:19:23,260 --> 00:19:27,540
it in a way that feels like a pair of programmers saying, hey, did you think about this case?

293
00:19:27,540 --> 00:19:29,660
Did you think about that case?

294
00:19:29,660 --> 00:19:34,220
And so one question you might ask is, how do you know it's zero, like is your URL misconfigured

295
00:19:34,220 --> 00:19:37,100
so you're just not getting any reports?

296
00:19:37,100 --> 00:19:40,620
There is legacy JavaScript code that will throw exceptions from time to time.

297
00:19:40,620 --> 00:19:44,060
So we know errors can be detected.

298
00:19:44,060 --> 00:19:52,740
So I want to show in a larger program what it means.

299
00:19:52,740 --> 00:19:58,620
And so I accidentally, okay, no, I think this is good, I think this is good.

300
00:19:58,620 --> 00:20:09,500
So let's say I want to add a new control, so rather than just having all the things,

301
00:20:09,500 --> 00:20:16,380
what's active, what's completed, I want to show if something's complex.

302
00:20:16,380 --> 00:20:21,860
So here I can say, here's my controls for which things are visible, and I'm going to

303
00:20:21,980 --> 00:20:29,620
add an extra case for, is it a complex task?

304
00:20:29,620 --> 00:20:41,380
So what's nice in Elm is you can kind of just run the compiler and see what it tells you.

305
00:20:41,380 --> 00:20:45,700
So in this case, it's saying, hey, this complex thing, I don't know what it is.

306
00:20:45,700 --> 00:20:49,020
Is it supposed to be an import?

307
00:20:49,180 --> 00:20:53,860
So where did the code go?

308
00:20:53,860 --> 00:20:59,460
Okay, so it's suggesting like, hey, you need to define complex before you use it.

309
00:20:59,460 --> 00:21:03,620
So one of the visibility options is, okay, I want complex stuff.

310
00:21:03,620 --> 00:21:06,460
So I added that, let's see if that works.

311
00:21:06,460 --> 00:21:12,180
And it's saying, hey, one of your cases doesn't cover that scenario, so case, visibility.

312
00:21:12,180 --> 00:21:14,780
So in this case, we're changing it to strings.

313
00:21:14,780 --> 00:21:18,740
So in the complex case, we're just going to say complex.

314
00:21:18,740 --> 00:21:23,140
And one question you may have here is, why turn it to strings that looks the same as

315
00:21:23,140 --> 00:21:24,140
the value?

316
00:21:24,140 --> 00:21:27,700
So your designer may say, I don't want it to be complex, I want it to be called like

317
00:21:27,700 --> 00:21:29,900
fancy tasks.

318
00:21:29,900 --> 00:21:32,180
And so you can change that without changing all your code.

319
00:21:32,180 --> 00:21:37,660
So I think this decoupling is important even if you're not using it at the start.

320
00:21:37,660 --> 00:21:39,820
So we'll stick with complex for now.

321
00:21:39,820 --> 00:21:42,140
So let's just ask the compiler again what's going on.

322
00:21:42,140 --> 00:21:45,740
Okay, this case doesn't handle all the possibilities.

323
00:21:45,740 --> 00:21:50,340
It's saying, hey, you need to handle complex in particular.

324
00:21:50,340 --> 00:21:52,700
So let's go find that.

325
00:21:52,700 --> 00:21:58,660
Okay, and so this is a function that's figuring out, given the visibility, is the entry visible

326
00:21:58,660 --> 00:21:59,660
or not?

327
00:21:59,660 --> 00:22:06,500
So in the complex case, we can say, is the length of the to-do description?

328
00:22:06,500 --> 00:22:10,180
Oh, yeah, and I want to make all sorts of typos here.

329
00:22:10,180 --> 00:22:11,700
So I misspell that.

330
00:22:11,700 --> 00:22:14,060
I'm going to misspell this thing.

331
00:22:14,060 --> 00:22:25,740
And the description, that was a legit typo, I didn't mean, is less than 15, let's say.

332
00:22:25,740 --> 00:22:30,700
So some of these errors are bound to happen eventually.

333
00:22:30,700 --> 00:22:33,020
So let's see what the compiler tells me about it.

334
00:22:33,020 --> 00:22:39,140
So it's saying, hey, I found this pattern complex.

335
00:22:39,140 --> 00:22:44,900
Maybe you want this other idea, okay, that is exactly what I want, in fact.

336
00:22:44,900 --> 00:22:45,900
And here's a naming error.

337
00:22:45,900 --> 00:22:50,820
You use toad, maybe you want one of these other things, and it tries to find names in

338
00:22:50,820 --> 00:22:53,180
scope that are close.

339
00:22:53,180 --> 00:22:55,140
So I want to do.

340
00:22:55,140 --> 00:22:56,860
So okay, I fixed all the errors.

341
00:22:56,860 --> 00:22:57,860
Let's see.

342
00:22:57,860 --> 00:23:02,820
And it's saying, hey, to-do doesn't have a thing called description, but this is close

343
00:23:02,820 --> 00:23:06,420
to a field that it could have, so maybe you want description.

344
00:23:06,420 --> 00:23:12,260
And so for each of those errors, had this been a string, it just would have been wrong.

345
00:23:12,260 --> 00:23:16,740
And then some point you find that error through some bug report.

346
00:23:16,740 --> 00:23:19,500
And then you find out that this was also misspelled.

347
00:23:19,500 --> 00:23:23,300
And then that would have been, I can't access a field on an undefined value.

348
00:23:23,300 --> 00:23:27,340
And then you would find out, okay, this thing is spelled wrong, and that's going to actually

349
00:23:27,340 --> 00:23:29,100
be an undefined.

350
00:23:29,100 --> 00:23:30,100
And what is string.length?

351
00:23:30,100 --> 00:23:31,100
Do you want undefined?

352
00:23:31,100 --> 00:23:33,980
I don't know.

353
00:23:33,980 --> 00:23:37,020
So it's catching all these things in a really nice way.

354
00:23:37,020 --> 00:23:41,420
And so as your program gets bigger, it's catching all these things still across a whole code

355
00:23:41,420 --> 00:23:42,420
base.

356
00:23:42,420 --> 00:23:46,580
So for the 200,000 lines that Norbert Inc. has, this is the kind of help they're getting

357
00:23:46,580 --> 00:23:48,180
along the way.

358
00:23:48,180 --> 00:23:52,780
And so because that's such an important part of Elm, it sort of fits in with, like, another

359
00:23:52,780 --> 00:23:57,500
question people have is, React uses NPM for all of its package management.

360
00:23:57,500 --> 00:24:00,900
Elm uses Elm package, so we actually don't use NPM.

361
00:24:00,900 --> 00:24:05,820
But all of the half a million packages on NPM aren't directly available.

362
00:24:05,820 --> 00:24:08,700
And so some people look at that and they're like, well, you're a crazy person.

363
00:24:08,700 --> 00:24:12,780
That's like, obviously, you need that to have something nice.

364
00:24:12,780 --> 00:24:16,980
And the thing is that because we have all the static analysis tools, it makes sense to

365
00:24:16,980 --> 00:24:19,180
use them in Elm package.

366
00:24:19,180 --> 00:24:26,580
So for example, if I say Elm package diff Elm laying core, which is the core library,

367
00:24:26,580 --> 00:24:31,660
then I'm going to take a recent release with the most recent release.

368
00:24:31,660 --> 00:24:36,580
It's going to tell me all the things that have changed between those two versions.

369
00:24:36,580 --> 00:24:43,420
And so I can do it on another package of mine, Elm tools parser.

370
00:24:43,420 --> 00:24:48,060
And the first release and the second release, I made a decent amount of changes.

371
00:24:48,060 --> 00:24:49,960
So here it can say, hey, this is a major change.

372
00:24:49,960 --> 00:24:50,960
You added all this stuff.

373
00:24:50,960 --> 00:24:52,460
You removed all this stuff.

374
00:24:52,460 --> 00:24:54,060
Here are the things you changed.

375
00:24:54,060 --> 00:24:58,220
And so for any package in the Elm ecosystem, you can ask this question and see exactly

376
00:24:58,220 --> 00:24:59,340
what changed.

377
00:24:59,340 --> 00:25:03,900
And what that means is when someone's publishing, I can say, okay, I looked at your code.

378
00:25:03,900 --> 00:25:05,500
You have made major changes.

379
00:25:05,500 --> 00:25:08,180
This is the new version number that you will be using.

380
00:25:08,180 --> 00:25:11,180
And so it's not a matter of like, oh, do people get semantic version?

381
00:25:11,180 --> 00:25:12,180
Do they like it or not?

382
00:25:12,180 --> 00:25:14,620
It's just like the Elm ecosystem uses semantic versioning.

383
00:25:14,620 --> 00:25:19,340
And if you're making a major change, everyone's going to get that major change.

384
00:25:19,340 --> 00:25:24,460
And so what that means for the whole ecosystem is there's no way to sneak through like, well,

385
00:25:24,460 --> 00:25:28,180
I know it'll break people's code, but it doesn't feel important.

386
00:25:28,180 --> 00:25:31,100
It doesn't feel major.

387
00:25:31,100 --> 00:25:34,500
And so I think, again, so this is like using the ML style syntax.

388
00:25:34,500 --> 00:25:38,780
I know that this means that Elm will have a smaller ecosystem and the community will

389
00:25:38,780 --> 00:25:40,220
grow more slowly.

390
00:25:40,220 --> 00:25:44,900
But I think it makes sense because of how everything fits together to make that investment

391
00:25:44,900 --> 00:25:48,820
and 10 years down the line, 20 years down the line, it's going to be something really,

392
00:25:48,820 --> 00:25:55,940
really special, even if it wasn't like as big as possible at the very beginning.

393
00:25:55,940 --> 00:26:01,060
So yeah, and to come back to the ML style syntax, when all your values are immutable,

394
00:26:01,060 --> 00:26:02,460
that syntax makes a lot of sense.

395
00:26:02,460 --> 00:26:07,740
So when it fits into the whole picture here, it becomes a coherent whole.

396
00:26:07,740 --> 00:26:14,180
And so I want to sort of end by saying, not one thing is better than the other, but these

397
00:26:14,180 --> 00:26:18,420
features that we arrived at independently seem like good ideas.

398
00:26:18,420 --> 00:26:20,020
And there are lots of ways to do it.

399
00:26:20,020 --> 00:26:23,660
And the thing you want to be thinking about is, how does this fit in with other features?

400
00:26:23,660 --> 00:26:25,520
What are the trade-offs that I need to make?

401
00:26:25,520 --> 00:26:26,620
What are my constraints?

402
00:26:26,620 --> 00:26:27,620
What are my preferences?

403
00:26:27,620 --> 00:26:29,440
How's that going to work for me?

404
00:26:29,440 --> 00:26:33,700
And if you're interested in Elm at all, you can learn more at the guide, which is trying

405
00:26:33,700 --> 00:26:37,500
to go through a bunch of these things, or on the subreddit or on Slack.

406
00:26:37,500 --> 00:26:40,220
And people are really friendly and happy to help out.

407
00:26:40,220 --> 00:26:44,180
And I encourage you, if you're interested, do it with a spirit of kindness and learning,

408
00:26:44,180 --> 00:26:47,620
because there are some people who really, really love Elm and they're really happy to

409
00:26:47,620 --> 00:26:48,620
be helpful.

410
00:26:48,620 --> 00:26:49,620
And I just want...

411
00:26:49,620 --> 00:26:52,980
I like them a lot, and I want them to have fun.

412
00:26:52,980 --> 00:26:56,820
And so ultimately, my goal with this project is I want to make web programming delightful.

413
00:26:56,820 --> 00:27:03,220
So even if Elm isn't for you, we're trying to do our best, and we'll hopefully get there.

414
00:27:03,220 --> 00:27:08,140
So I hope that spirit is how you come to these.

415
00:27:08,140 --> 00:27:11,740
And so ultimately, if the goal is to make web programming delightful, that will look

416
00:27:11,740 --> 00:27:12,980
different for different people.

417
00:27:12,980 --> 00:27:18,660
So if you go check out ClosureScript or Elm or TypeScript or Flow or React or whatever

418
00:27:18,660 --> 00:27:22,100
it is, you're going to find a place that works well for you.

419
00:27:22,100 --> 00:27:26,380
And it's not that someone's right, someone's wrong, it's that there are different constellations

420
00:27:26,380 --> 00:27:30,060
of features that work together in a particular way.

421
00:27:30,060 --> 00:27:34,500
And there are certain parts that overlap, and those seem like a good idea.

422
00:27:34,500 --> 00:27:35,500
Thank you.

423
00:27:35,500 --> 00:27:36,500
Thank you.

424
00:27:36,500 --> 00:27:37,500
Thank you.

425
00:27:37,500 --> 00:27:38,500
Thank you.

426
00:27:38,500 --> 00:27:39,500
Thank you.

427
00:27:39,500 --> 00:27:40,500
Thank you.

428
00:27:40,500 --> 00:27:41,500
Thank you.

429
00:27:41,500 --> 00:27:42,500
Thank you.

430
00:27:42,500 --> 00:27:43,500
Thank you.

431
00:27:43,500 --> 00:27:44,500
Thank you.

432
00:27:44,500 --> 00:27:45,500
Thank you.

433
00:27:45,500 --> 00:27:46,500
Thank you.

434
00:27:46,500 --> 00:27:47,500
Thank you.

435
00:27:47,500 --> 00:27:48,500
Thank you.

436
00:27:48,500 --> 00:27:49,500
Thank you.

437
00:27:49,500 --> 00:27:50,500
Thank you.

438
00:27:50,500 --> 00:27:51,500
Thank you.

439
00:27:51,500 --> 00:27:52,500
Thank you.

440
00:27:52,500 --> 00:27:53,500
Thank you.

441
00:27:53,500 --> 00:27:54,500
Thank you.

442
00:27:54,500 --> 00:27:55,500
Thank you.

443
00:27:55,500 --> 00:27:56,500
Thank you.

444
00:27:56,500 --> 00:27:57,500
Thank you.

445
00:27:57,500 --> 00:27:58,500
Thank you.

446
00:27:58,500 --> 00:27:59,500
Thank you.

447
00:27:59,500 --> 00:28:00,500
Thank you.

448
00:28:00,500 --> 00:28:01,500
Thank you.

449
00:28:01,500 --> 00:28:02,500
Thank you.

