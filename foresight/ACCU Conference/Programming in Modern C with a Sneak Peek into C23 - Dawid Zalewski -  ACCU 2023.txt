Good afternoon, everybody, and welcome to my talk about C, which is a quite unexpected
talk for this kind of conference, right?
You come here to hear all about modern languages like C++, Kotlin, a couple of years ago, nowadays
for us is hugely popular, and you hear about this.
And this is about C, which is like, yeah, this grandfather of languages.
So quite surprising, and I'm happy that you are here also to listen to it.
Now, on the other hand, C is not going anywhere.
It's definitely not going anywhere.
I had a pleasure to attend the conference a couple of weeks ago when there were people
from, lots of people from automotive industry, and obviously those guys only use C and C
plus plus, and it's a huge industry, and generally speaking, you know, related embedded industries.
And there are also people from MISRA C and MISRA C plus plus, people who standardize safety
for C and C plus plus, among others, for the automotive industry.
And then, I mean, there was a discussion in the audience, and what I heard a lot is this
is a billion dollar industry, and nobody's going to rewrite billion dollar libraries
and software into Rust anytime soon in any other language for that matter, because they
aren't just not going to drop it at one day.
So C is still rolling there.
So thank you that you are here.
Now, surprisingly, C is not a dead language.
You might think so.
I mean, it's not like, you know, in a rapid development cycle of C plus plus that every
three years to get a new standard.
But it's also not a dead language, quite to the contrary.
What you see there is a valid C, kind of a valid C, and you might be surprised when you
look at it, because there are crazy things happening.
Like, if you learned C from the standard C book, the C programming language, you definitely
have never seen bull as a type or true being returned from something or being passed to
a function.
There is also, that's just because I couldn't fit it on a slide, don't don't mention it.
The structure definition is in the return type directly.
This is a C feature.
So you can do things like this.
It's just I couldn't fit it otherwise.
Anyways, if you go further, there is type of, it's an operator in C that works pretty
much like decal type is just much less powerful and doesn't come with all the craziness craziness
of decal type.
There is constexpr nowadays, at least let's say since two weeks when the C23 was standardized.
There are weird things like indices in square brackets, also something that I don't think
many of you use, especially if you're coming from C++, there is auto.
I mean, it's been there since the beginning, right?
So it's for specifying the storage type in C.
So it's still there, but what's even more strange is the right-hand side of this expression
where it looks like I'm creating like a temporary structure and taking an address of it or casting
something like into a structure and taking an address of it, something, you know, among
these lines.
And I'm returning actually not really this pointer, but the reference in this pointer
later on.
And there is a null pointer, null PTR, just like in C++, it's a keyword again for exactly
past week or has been a keyword for exactly past one week.
So that's it.
This program is a valid C and it compiles.
You wouldn't believe it, but it compiles.
Unfortunately, it compiles only a single compiler now, and that's the trunk of GCC, otherwise
it won't compile.
This is the only compiler that accepts all these nice features because it's so new, it's
just freshly standardized, and they have some special meaning.
So you can compile it using, for example, the compiler explorer.
No problems.
You have to pass in this state is C to X.
It's still not 23 because it won't, I mean, in this compiler in the trunk version, they
weren't even sure that this is going to be C23.
It's going to compile with no warning whatsoever, and it's going to execute.
What's your guess?
What's it's going to do?
I mean, okay, it looks crazy.
I mean, you cannot guess from it what it's going to do.
I agree.
But if you look carefully in line 15, it definitely tries to print something.
No, line 13 is definitely trying to print something by using the putString function
puts, and it's casting this array as an argument.
So it definitely is going to print something.
What's it going to print?
It's going to print C.
It's great.
Long live C.
It's unique code characters for a good measure, right?
That's because C is still the language we love for its total lack of type safety.
It's really one of the reasons why C exists, and it's so popular in embedded industry,
in system programming industry, is that you don't care about types.
You can easily cast from one thing to another, just like a cast set and array of doubles
into a car pointer.
No problems whatsoever.
And if you know what you encode within these doubles, it's going to work.
And of course, it returns 42, as it should, which you also couldn't see.
So this is a talk about modern C, and I'm going to talk about modern C a lot.
And what people consider modern C is anything starting from C99 and above.
There were a couple of standards on the way, like for example, C17, which added a few things,
and now C23, but this is all modern.
That's generally a talk for everybody who learns C from the old books or who doesn't
know C a lot, who doesn't use C a lot, because I expected half of you don't really use C
every day.
Or maybe you got curious about something, maybe you heard something, and you want to
learn.
Anybody, if I ask now, who's using C, like at least once a week here, yeah, two persons.
That's a lot for this.
So I am also using it.
It's like half, half with C++.
So this is basically a talk exactly for you, for those of you who know nothing about C
or learned it a long time ago and think that it's still like in this old prehistoric times.
Now as I said, C is a cool language, and we all love it for its total lack of type safety,
and for the fact that basically you can do everything and express everything with C.
It's just that you have to be very careful not to create a bloody mess when you do it,
which is equally easy as creating a well-working program.
So this talk is going to cover a couple of topics that might be useful when trying not
to create a bloody mess, like how to initialize in modern C, how the initialization works
in modern C, because when you don't initialize variables, bad things happen.
Like C++ has some guarantees about what happens when you don't explicitly initialize,
like default, zero initialization, blah, blah, blah, and so on.
C doesn't.
C just gives you garbage if you don't initialize, right?
We're going to talk about pointers, arrays, and functions, because obviously it is a C talk,
so pointers must happen, otherwise it's not going to work,
and about how you can be a bit safer with pointers.
A bit safer, because those guarantees are now built into the language slowly.
We're going to talk about zeroing, assigning, and things basically like what's on the screen,
how to zero the whole data structure again, because it's an important part of modern C.
Finally, if time permits, a bit about fragile resource management, so cool new features
in C that make it very easy for people who deal with hardware to write efficient software,
and how to make dynamic resource management, and especially memory management less fragile
and easier to handle, and there will be some macro magic, if time permits, because obviously
this is a talk about C, so there must be macro magic.
So that's it.
I will throw, for a good measure, some C23 pieces here and there, but this is not a talk
about C23, mostly because I just couldn't make it in time.
It was standardized a week ago, and a week ago, people didn't even know what would be
really there and what wouldn't be there, so it was a bit too much risk to make a talk about
C23, and the features actually that they put in C23 require on talks on the topic only.
So there will be some 23, and whenever you see this logo, it means that there is a C23
feature.
Now, the quiz time.
It's only quiz, that's only in this talk, and I hope it's a cool quiz, and that you can
answer the questions that I'm going to ask you.
And you can shout.
We are not that many here, you can shout.
I had the microphone, I'm louder anyway.
We have a function, it's C.
It's not C++.
Print.
How many arguments does it accept?
Who's for none?
Okay, who's for possibly many?
Exactly.
Great.
This function accepts possibly many arguments, because in C, when you don't put void in between
the brackets, the function possibly accepts many arguments.
Next one, and that's a tricky one.
There is a function.
It accepts two arguments, A and B, with some types.
The types are not really defined there.
And then it prints the sum of those two arguments, A and B.
And I'm calling this function with two double arguments, 1.5 and 8.5.
And obviously, any normal person would say that the sum of those two is 10.
Who's for 10?
As a result of what the function is going to print?
Who's for 9?
Majority.
Great.
I like it.
It's going to print 9, you're absolutely right.
Because if you don't tell what the argument type is, it's going to be an integer, right?
Because in the old good type, times when C started to exist, there were only integers.
So everything was an integer.
Honestly, I'm on C23.
It's undefined.
Finally, it's undefined because it was a source of many errors.
So it's illegal to do it anymore.
Good things do happen.
Now, that's one tricky.
And the question is very easy.
What's the value of number and what's its type?
So it's just one line of code.
It's don't overthink it, right?
And as a hint, the literal is a floating point number.
It's a float on the right-hand side, right?
So you might think, well, it's a float because the right-hand side of the assignment is a
float.
And the other good hint or a good guess would be an integer.
And it would be an integer because like on the previous slide, if you don't define the
type, it's an integer, right?
And you are right and right depending on which language version you are.
If you are on anything below what happened last week, it's going to be 42 because it's
an integer.
Auto before last week meant automatic storage duration, nothing else.
So you could have skipped it and it would mean like then, you know, it's an integer
because obviously when you don't specify a type, it's an integer.
Now you wouldn't believe it, but auto means the same now in C as it means in C++.
It's for type inference.
Actually, it has this kind of a dual life now in C23.
It is for type inference or for storage duration specification.
That's whether you put the type or not yourself.
So if after the type I would put in, this auto would be specifying the storage duration.
But because I didn't, it's for type inference.
Next one.
Well, this compile in C, okay, this doesn't make any sense now to us because I just showed
you that it compiles in the first slide, but I asked this and there are two different
answers to it.
Either it will compile out of the box or you have to include something.
Who's for including that you have to include some standard headers for it to compile?
You are absolutely right.
Because you didn't read what happened last week, right?
When the bool and false became keywords in C also.
So they also kind of do the same thing like C++, they like to do things slowly.
They first standardized boolean with a totally weird notation underscore capital letter bool.
And you could have the normal bool through a header inclusion that was, it was simply
a type def inside and now it's standardized as a keyword.
That one, I'm not going to retorture you with this one.
I think it's fun.
Unless you know what's happening there, I mean, what's the size of the numbers array
and I don't want you really to count this one.
Because if you count, I think you're around eight.
So there are eight initializers listed there.
But there are many other options there and the correct answer and we're going to talk
about it is 12, which is not really apparent when you look at the list.
There is no 12 anywhere.
There are no 12 initializers, there is no index 11, nothing like this, right?
So it's like, why?
Because it's C and in C we like doing things our harmful way.
So that's why.
Next one, does anybody know actually what is the type of PK in line four?
If you look at it.
PK has a very specific type.
I mean, you are kind of born when you're not born with knowledge of C, it's not that far.
But we learn it when we learn C that pointers are pointers in C and a pointer is a pointer.
You can cast it, it basically doesn't have any further meaning, doesn't come along with
any further type specification, it's just a pointer.
It's not true.
This is a pointer to an array of 10 by 10 integers, exactly.
It's a strongly typed pointer to an array, two dimensional error.
And because of this, when I malloc it and use size of Asterix PK, I'm going to get
enough storage for 100 integers.
Is it integers?
Yes, it is integers.
So the answer is 400, at least on my platform.
And I think we are almost at the end of the funny quiz.
And the question is, is this program well-formed?
And I'm not talking about intendation, it's cool.
I'm talking whether it's going to compile, whether it's going to be accepted by a compiler.
And there are a couple of answers, and you can raise your hand if you think that this
answer sounds true.
Like A is no, because line 11 is fishy.
And line 11 is fishy, because it looks like, actually I don't know what I'm doing there.
It looks like an array, I'm casting actually open curly braces to an array, right?
That's what I'm doing.
Who thinks this line is fishy?
Yeah, it's definitely fishy, but it's not a problem.
It compiles.
The other answer is no, line 5, the address of a temporary is taken, or something that
looks like a temporary.
And I mean, the address is definitely taken in this line, but again, this is a perfectly
fine C.
An answer might be also no, there is no aggregate initialization or something like this, no,
there isn't, but you can initialize with designated initializers.
So this is a perfectly fine C, and it's going to compile.
And it's even going to print something.
I think it's going to print today on the screen.
And last but not least, and that's a tricky one.
What does this function accept?
What kind of arguments does it accept?
Because it accepts a very specific type of arguments.
So this again, type safety, pointer safety, do you have an idea?
C, this key, you're right, sorry, I first read D, which I also have an urge to actually
directly look at, you're right, it accepts valid non-null pointers to con-scar.
So it's a contract, it's basically your saying, it's a pointer to con-scar, and it
has to be valid, it cannot be null.
And you would be surprised, compilers check it.
So that's this.
And we are finally at the core of our talk.
Go on, please.
That one.
I don't hear you.
Is it also the case that the pointer was the pointer and it was the string?
No, no, it's only checked whether it's null or not.
So because it's a pointer, you can pass null, right, as an argument.
So that's been checked, but yeah, it doesn't look into the string really.
No, no, it's not that good.
I mean, there is no runtime in C, there is assembly, right?
So.
Even if you pass an empty string, you still have the null terminator there, so officially
it's valid, right?
I'm sorry, but it's officially valid.
This only checks for null and nothing else.
So okay, let's go.
Initialization.
The first topic, an important topic, and I mean, the quiz was also partially about initialization,
like you've seen lots of initializers.
Have you ever seen code like this?
Anybody?
Raise your hands, please.
All of you have seen this code because it comes from this book.
You must have seen it.
So this code attempts to initialize a structure, right, a structure of X and Y, a very simple
one.
And that's not how you write it nowadays.
Nowadays, what you would do is, of course, use the brace initialization, like you would
do it in C++.
The only difference is you need that equality, you know, or an assignment in between.
And that's how it works in up-to-date C. It exists in C. Brace initialization exists
in C, and you can pretty much initialize everything like this.
So, you know, like an array of undefined size, and then the size will be calculated from
the initializers.
You can initialize a list on an array, or an array with a defined size.
You can initialize structures like this.
No problems whatsoever.
You can initialize pretty much everything with braces, just like basically aggregate
initialization works in C++ for those of you who know what it is.
But when I mean everything, I really mean everything.
This is legal.
Some people write it because then it's uniform, and it looks nice.
And it scares people who don't understand.
And that's also good, because you don't want people who don't understand your C code to
touch your C code, right?
So you put it there just to scare off people.
That works.
There is also something called empty initialization in C. It got a name, empty initialization
a week ago, like a standardized name, before it was known under different names.
Some people called it zero initialization, some default initialization.
And basically the trick is you put a single zero in between the braces.
Nothing else.
This has the effect of zeroing everything, whatever is on the left-hand side.
So if it's a value, or if it's an array, or if it's a structure, then recursively all
the fields of the structure will be zeroed.
Nulls will be actually zeros, like a null is a zero, or most of the architectures will
be put where they should be put, and so on, and so on.
It kind of got its name from this one.
Because in C23 they removed the need for having a zero in between the braces, you can now
skip the zero in between the braces, and it's still going to work.
So that's where it comes from, the empty initialization.
Now what are the rules?
The rules are very simple.
When you empty initialize something, like a structure, what happens is that all your
fields in the structures are going to be zeroed, including the parting bytes.
Not because they have to be zeroed, but that's because what the compilers will do anyway,
and that's it.
There is no magic in it.
It also works for nested types.
So if you have an array of structures or whatever, you can just zero it like this.
It's great.
Right?
You don't have to use memset all of a sudden, and we are used to use memset.
I mean, at least I was used to use memset at all a lot when I was programming C.
So we just put zero there.
Now what if you don't want a zero?
What if you want different values, like, for example, you have a bigger structure with
five fields, and two of them should have some values, and the rest should be zeroed?
Because why not?
And then you might think, okay, what's my idea here?
I might zero first the whole structure, then set the fields, and so on, or do something
crazy like this, right, when you use the brace initialization and list all the members one
after another at the right positions and initialize with zero what needs to be initialized with
zeros.
Luckily, this is not the way, because there are designated initializers in C, just like
they're in C++, and they have the same exactly syntax.
So there is a dot, then the designator, then the equality symbol, and then the value you
initialize the designated field with.
This has the same effect as in C++, almost the same, because we don't have default initialization
here.
It zeros all the fields that are not explicitly initialized.
So those that you explicitly initialize with your designators are going to get the values,
the rest is going to be zeroed, which is great, because very often it happens, and especially
if you program in C, in C, people work with all fully long structures that have, I don't
know if you've ever looked, for example, how file is implemented, how many different fields
it has.
It's horrible.
Most of them are usually zero.
So that's great.
Now what's not so great, or actually maybe what's great, because C gives you all the
powers there is, there are in this world, so what's great, you can mix the positions
when you're designated initializer.
So you're not necessarily bound to the order of declaration, as you are in C++.
For C++, it's going to be a hard compilation error if you try something like this.
See, no problems whatsoever, mix them.
What's even, now I struggle to say it's better.
What's even cooler is that you can mix positional and designated initializer, something that's
also forbidden in C++.
You can freely mix them.
You've seen it already when I was asking about the size of an array with really weird indices.
This is a mix of designated and positional initializers, two positional initializers,
the first one and the last one and two designated, but you have to be careful about what you're
doing and how you're doing it, because you have to understand how the logic works behind
the initializations order then.
The first one is quite easy.
It's a positional initializer and it goes into the first field.
Then we have a designator status.
It names the last field in the structure, so the status is going to end up there.
Then we have another designator flex and it fits in there.
Last but not least, we have one more positional initializer with no designator.
It's going to end up directly after the flex and the reason for it, whenever you have a
designator in your initializer list, the counting for the next positional initializer
starts from this designator.
You have to know what you're doing, but that's great and of course the rest is zero.
If you know what you're doing, it's going to work nevertheless.
You can nest initializations just like you can do it in C++.
You can nest them, I mean, the designators and initializers for sub-objects.
Also with designators, no problems whatsoever.
You can even do crazy things like this, dot-flux, dot-extended, dot-extended designates a field
of a sub-object of the structure.
This is also not allowed in C++.
You cannot nest in C++ like this.
In C, it is allowed.
Now, this is also a funny thing and it's funny because I don't know really what's
the use for it.
I mean, I only know one use that I came up with when I was working on it once and it's
not even a good use, so I'm not going to mention.
No, okay.
You can use designators for arrays.
It's absolutely fine and this works the same way as for structures.
The designator designates a field or actually the subscript that you're going to initialize
with a value.
This is like an array of 42 numbers.
Three of them are going to be initialized with certain values.
This is a Fibonacci sequence, roughly.
That's a Fibonacci sequence, part of it.
The rest is going to be zeroed.
The rest of the numbers are going to be zeroed in this array, all of 99 of them, which might
be useful, might not be.
The same craziness applies as instructors.
You can mix the order, whatever you want.
You can mix positional initializers with designated initializers and, again, the same rules apply
as before.
If you have the designator, the index of the following positional initializers is counted
from this designator.
There is a designator 10 at the second position here, which means that 89 is going to end
up at index 11.
Because it's going to end up at index 11, there is nothing actually more to talk about,
but there is something to talk about here, because this is going to end up at index 11.
This array has a size of 12, because this is the highest index in the initializer list.
But this is crazy.
Things like this shouldn't be allowed.
Neither should be this, but it's there.
If you look at this, this is fine.
I mean, it's not fine, but you can do it.
You can have an array of structures, for example, and designate or initialize one of the fields
of those structures at a specific index of the array.
It's going to work out of the box.
The syntax, especially at the multiple level of nesting, looks really ... You cannot comprehend
it anymore, I think, at one moment or another.
It works, nevertheless.
So that's it.
That's the initialization.
That's how we initialize everything in modern C, believe me.
People really do it.
They use curly braces even for numbers, and there are no restrictions.
In C++, they have a lot of restrictions for it.
In C, there are none whatsoever, so you can do ... You can really confuse your colleagues
if you want to.
Now, and since we are talking about arrays, and there is one very popular topic when it
comes to arrays, we are going to discuss it.
Generally speaking, as all of you know, there are two types of arrays in this world.
You can have either an array with a static known size, constants known size, and that's
your good old array, as on the left-hand side, or you can have an array that you allocate
dynamically on the heap, and that's something like a runtime thing.
So during the runtime, you can come up with a value for the size of your array and allocate
it.
It's much better today like this because this size should be somewhere close to your numbers
definition to the array definition.
Nobody people don't put defines, hash define, within the function.
They can, but nobody dares to, for some reasons.
They put it somewhere outside, and then you don't know what the size of the array is,
but with Consexper, it's just more natural to put it next to the array, right?
So you can do it now.
Anyways, back to the arrays.
Question, is a lot a constant integral expression?
Who's for it that it's a constant integral expression?
Some people have doubts.
Who's against it, like totally against?
Nobody has doubts.
That's also fine.
It depends.
If you're coming from C++, obviously it's a constant integral expression in C0.
C, no, sorry, that's why we use defines in C, right?
Because we like to confuse people.
This is not a constant integral expression, so you cannot use it to define an array with
a constant known size.
It's illegal.
However, this code does compile.
It compiles, and many people hate it, that it compiles.
And we're going to talk about why they hate it in a moment.
What it really declares or defines is a so-called variable length array.
It's an array whose size is determined at the runtime, and usually it's allocated on the stack
by the compiler.
Like allocated on the stack during the runtime.
That means also calculating the size, calculating the register shift, the RSP register shift,
and manipulating it at the runtime.
So this creates an array with an unknown size, or actually not with a well-known size
during the runtime, on the stack.
And you can only do it within a block scope.
And the reason is quite obvious.
I mean, at the file scope, you don't have really a stack there.
So how do you declare an array there?
It's not really standardized that it does have to be on the stack, but all the compilers
do it on the stack.
C++ doesn't have this feature.
And for a reason, because there was a big discussion when they introduced it, it will
see also whether it's even needed.
And many people said that it's not needed.
I also said before that you can initialize everything with curly braces.
Well, not this one.
This is the only exception.
You cannot.
You have to initialize it element by element.
Anyways, as I said, some people hate it.
And they hate it with passion.
Like Linus said, that using VLS is actively stupid.
And for many reasons, and many other people in the community actually repeat the same
thing that is actively stupid to do it.
Nowadays, nobody's using VLS.
And that's not a joke.
I mean, students sometimes use it because they don't know that it's a bad code.
But otherwise, nobody's using it.
Why they don't use it?
Well, it's an array on the stack.
You know what's the problem with the stack?
Depending on your architecture, the stack is maybe four kilobytes or maybe eight megabytes
if you're lucky.
So when you declare an array or define an array with a size that's going to be determined
during the runtime, you definitely have to check whether it will fit on the stack.
Otherwise, you're going to blow up the stack and your program will crash.
So you must build in this check somewhere before this array even comes to being.
Otherwise, you are in danger zone.
And only then you can do your array thingy.
So the question is, why would you do it anyway this way?
I mean, isn't it just better to have directly the array with the myAllowedSize
and it will fit everything I need anyway?
So just do it like this, right?
And then this.
And I still have to check, obviously.
But now I have an array with a constant known size.
The compiler can see it upfront.
It can optimize for it.
So why?
What's even worse, if you look at the...
It's the same code as before, just without the stack check.
And I'm doing now the n of size 10 on the left-hand side.
It's a variable length array on the right-hand side.
It's an array with a constant known size.
It generates much worse code.
The VLA variant is much bigger in the assembly
because these calculations have to be done at the runtime.
So you have to calculate the shift.
You have to move the RSP by certain size.
Whereas on the right side, on the right-hand side,
the compiler knows it has to shift the stack pointer by 40 bytes
and it's done.
So it's bad.
It's actively bad.
I'm not going to say stupid, but it's actively bad to do it.
Don't do it.
Now, if you shouldn't do it, then why am I talking about it?
Unless you are, of course, a teacher
because then you are going to see students do it
and you have to correct them.
The reason is VLAs are used for other things.
And some people argue this is the primary reason
why VLAs are in the language.
They are not for having stack arrays with variable length.
They are for doing things like they're going to witness in a moment.
This is a function that takes an array of numbers
by a pointer and the size of the numbers
and does nothing special really.
Now, if you have code like this,
you can also write the argument a bit differently.
You can write the argument as the second parameter
or the second parameter being an array of type int
with n elements inside.
And this does something different.
This communicates your intent all of a sudden.
You say exactly that it must be an array of n elements
and there must be enough storage for those n elements.
The previous one didn't communicate it.
The trick is size has to come before the array
otherwise it's not going to work.
Right? Now, why would you do it?
I mean, you can do it for arrays with known size like that one
an array of five elements and it's going to compile just fine.
Or you can do very nasty things like a hidden bug there
when I'm trying to pass an array of five elements
and pretending it has six elements which is bad, actively bad,
and your compiler will tell you that you are doing something bad.
Compilers do detect those errors if you pass arguments
using the VLA syntax.
At least GCC does.
Clank doesn't really want to do it.
Sometimes it does but not in this case.
Surprisingly, it even works for dynamically allocated arrays.
If you try to pretend that a dynamically allocated array
is bigger than it is, GCC will warn you
with a string operation overflow.
Apparently, it is a string operation what we are doing.
Nevertheless, this is great, right?
It warns you.
And since we are already talking about arrays
and we are all kind of educated in the way that arrays decay
to pointers, unless there are three specific scenarios when they don't,
let's talk about more about how you pass arguments in modern C
and specifically how you pass pointers in modern C to functions.
There are four different scenarios that you can cover
when you think about how you pass pointers in C.
The first one or the first ones are about arrays.
The two second ones are about single objects.
Imagine you are passing an array of n objects
and you have enough storage for n objects
but not necessarily valid objects in this array.
What you're going to do then is use the syntax that I just showed you.
It works and the compilers will check it most often.
So in this case, it's a buffer of n characters uninitialized
and I'm never reading from it.
I'm actually initializing it or putting values into this buffer
but I have enough storage.
That's great.
Now another scenario, if it's an array with enough storage for n objects
and it must contain n valid objects.
That's like a hard requirement.
There are n valid objects inside.
There is this syntax that you guessed correctly for something different.
You use the keyword static before you mentioned the size.
It's been there since C11 if I'm not mistaken
and it means something special.
It basically means that those objects do have exist.
It's illegal not to have objects there
and some compilers are able to check not everything but some parts of it
but it clearly communicates the intent at least.
So static communicates the intent.
When it's a single object and it can be a null pointer,
well, you do it the old way, right?
There is nothing special about it.
You are responsible for checking it if it works or if it doesn't work.
Now the last one is actually the one that we already showed during the quiz
or I already showed during the quiz.
If you're passing a pointer and it mustn't be null,
it's illegal that it's a null pointer than you use static one.
It's a very common thing, especially static one,
somehow managed to permeate into the code, into the live code.
People use it because compilers check it and enforce it.
So use it and for a proof that compilers check it and enforce it,
especially when you use the static keyword, look at this piece of the code,
it basically tells that there is a function that takes an array of three doubles
and those doubles must exist.
And I'm trying to call this function with a dynamically created array
and notice that I'm totally not saying, I mean,
I'm not passing the size of the array here as an argument
and I'm trying to do it as statically created array.
This GCC triggers an error for both of them.
GCC, without even the static analyzer that it has built in,
is able to see that you're doing something very bad
and it will gonna tell you this time with, again,
with string operation overflow.
The first one with the static array also triggers an error on the clunk compiler.
So that's very good.
That protects you against very stupid mistakes that we often do,
you know, buffer overflows do happen.
Like there are single most important point of failure,
I mean, in all the spaceships that went down, right?
So do it.
It also works amazingly well for this kind of syntax,
which I said that protects you against passing a single null pointer
when you don't expect a null pointer.
And when you try to do something like this,
GCC will again emit an error.
And I think clunk also now emits an error.
So that's the summary of how you pass arguments in modern C.
Use the row pointer only if you're expecting one object
and only if it can be null.
Otherwise use the VLA notation sometimes with the static keyword
if you expect invalid objects to be in the array.
Compilers do enforce it.
Lots of modern C code is written like this.
And obviously it's not supported in C++, the static notation,
and the VLA syntax also not really there because it's a part of the VLA.
And since we are at the VLA's and there was, I asked this question before,
or I was talking about a PK pointer somewhere in the beginning of the talk.
As you can see, it's a two-dimensional array.
It's a beast.
It's a beast, it's a Gaussian filter.
It's a kernel of the Gaussian filter if I'm not mistaken.
It's a beast and it's a beast because multi-dimensional arrays in C and C++
are horrible to work with.
So that's like a five by five array.
The size doesn't matter.
What's horrible about it is not what you see on the screen.
It's what you see now on the screen.
Maloching this or allocating this array is still okay.
And by the way, notice that I'm also using the VLA syntax
with the size of operator.
This is also valid.
You can do something like this for the size of,
which greatly simplifies size-offing for your malochs.
And then when you index into this array,
I don't understand it now, right?
What I've done before, and I always have to look it up.
And nowadays, people use strategy-tp for these kind of things
before it was stuck overflow.
And I'm not joking because it's unclear.
You have to remember like what's, I mean,
how is the data laid off in the multi-dimensional array
to be able to do this magic.
So what we really want is something like pk
and then a first index, second index.
What we get is, yeah, is this.
Luckily, the VLA syntax does this for you.
When you use VLAs with strongly typed arrays,
you can achieve this because, you know,
VLAs don't only extend to declaring parameters
or to having stuck arrays.
They're also for declaring strong array types.
For those of you who are not fresh with the pointers,
like I wasn't, for example, when I was preparing this talk,
the pk is a pointer to an array of doubles,
to actually two-dimensional array of doubles
with the size as Z as Z, whatever the as Z is.
Because it's a VLA, so it doesn't matter.
It's determined at the runtime.
It's strongly typed.
And that sense that if you try to do something with this,
that's not allowed, like pass it to a function
that accepts a single double pointer,
it's not going to compile even.
And when you use it, all of a sudden,
this kind of syntax becomes possible.
So it's much better.
It's a huge improvement because you can now index
into your multi-dimensional array with this.
Compiler knows it's a pointer to a 2D array,
so it can index into it properly
and translate into the pointer operations.
What's even better, if you don't like the currently,
the brackets Asterix pk, you can also do it like this.
This is a bit of a cheating
because I gave up a bit of a type safety,
because it looks like I'm now allocking,
like an array, a one-dimensional array,
not really doing it, but this allows for this beautiful syntax.
And if you don't like pk, so that's what you do.
If you really fell in love with the VLA syntax,
notice that what I'm doing here on the right-hand side
of the malloc, it's not really cool, right?
I'm doing something like size of pk multiplied by size
and it's going to work correctly.
It's going to allocate the correct number of bytes,
but some people don't like it.
They say that it shouldn't be like this
and that you should use the VLA syntax
for your size of operators also
because it's much cleaner and it communicates the intent better
and you cannot make so many errors.
So if you just fell in love with the VLA syntax
and you want to show off, you can do it also.
Using a type of operator.
Because the type of the pk pointer,
the reference is the array of doubles of size size
and then there is another size then
and together they make a multi-dimensional array.
Think about type of a set decal type here.
So it works in exactly the same way.
So we just declare a type of an array of doubles of size as Z.
And you can combine it with index 10,
which is like, whoa, why?
I was pretty shocked when I discovered this.
Yeah, and since we are in C plus C23,
there is an old pointer obviously.
Anyways, that's the initialization and the arrays.
And now we're coming to the worst part of the talk
because it's the most difficult part of the talk.
Actually, it's not difficult.
It's a bit of a crazy part of the talk.
It's going to be about zero increase assigning
and disappearing L values or whatever you call them.
You remember this slide, right?
This was somewhere at the beginning of the talk
when I talked about the old C initialization
and the new C initialization syntax.
And I said, this is up to date C.
I lied, of course.
This is not an up to date C.
Nobody writes code like this unless you are born
in, yeah, in 2011.
I don't think those people write C.
Might, though.
You never know.
So you don't write this kind of code anymore.
It's not up to date.
It's modestly up to date C.
What you do nowadays is something like this.
You return these things that looks like casting.
And then there is the initializer list
with designated initializers inside.
Now, this has a name.
It's a compound literal.
And this is something that exists only in C.
It has a very simple syntax type in the normal brackets
followed by the initializer in the curly braces.
The initializer is not optional.
You have to put it there.
And it creates an unnamed object.
It's really created.
It exists.
This object has different storage duration.
It can have a static storage duration
if you declare it at the block scope.
For example, I am declaring a not at the block scope,
sorry, the file scope.
I am declaring at the file scope an array of doubles
that doesn't have any name, but I'm assigning it
to a variable of default coefficients.
And it's there.
It's going to exist throughout the duration of your program.
Or you can do automatic storage if it's in the block scope.
And here it is, I'm declaring a structure
or actually I'm assigning to a structure
with some new values.
So I'm using, you know, I have already a fear for structure
and I'm putting a new value into it with the assignment
with some other initializers and so on.
So two different storage locations
and where the object is created as,
like for any other object, if it's a static storage duration,
it's somewhere in the global memory.
So my coefficients are in the global memory.
And my object on the right have some side of the assignment
because this is what we are talking about.
We are not talking about the fear if I are variable.
We are talking about what's on the right hand side
is going to be allocated on the stack for a moment,
at least for the duration of this line.
The unnamed object is an L value.
And for those of you who know a bit about value categories,
it means many things like you can assign to it
or you can take an address of it.
It's fully legal.
It exists.
If it's declared in the block scope,
it's going to exist throughout the duration of this block
or the lifetime of this block.
And you can legally take an address of it.
And this allows for surprising applications like that one.
Those of you who ever dealt with time
are familiar with the normalizing function MakeTime,
which normalizes the TM structure.
You can normalize like this now
and get the Unix time out of it.
Cool thing if you ask me.
Now, those are not C++ temporaries.
They have nothing to do with C++ temporaries.
In C++, what's valid in C and looks very similar,
really very similar, is invalid.
You cannot do it in C++.
This creates a temporary object.
You take the address of it and you try to pass this to a function.
But when the function starts executing,
actually this object would still exist, I think.
Oh, no, it wouldn't.
So it's illegal to do it.
I mean, it's illegal because you are taking an address
of our value, right, of a temporary,
which is not even materialized yet, I think.
So you cannot do it.
In C, it is valid and you can do it.
And you can do crazy things with this.
And a crazy like in not negatively crazy,
but crazy in beautifying your code, crazy.
So something like a typical school assignment,
you have an array and you have to declare
and write a function that initializes this array.
And notice that it's a very simple array.
It has just a data field and a size and an account.
Sorry, capacity and account.
So obviously you're gonna allocate for data
and put some capacity and zero the count.
In the old C, you would do it like this, right?
So you are gonna most likely memset somewhere
or set the fields separately one by one to zero.
You're gonna allocate with caloc or malloc,
doesn't really matter.
And if you manage to allocate,
you are gonna set the capacity also
because that's what you do.
Now, nowadays people write it like this.
So they don't really like zero before they
just write it in one line.
So what happens here is I am creating this lvalue object
on the right hand side of the assignment of type arrays
and initializing with it through the designated initializers,
allocating memory on the fly or on the go.
And then I'm assigning it to the difference pointer.
So I'm basically assigning a structure to a structure
or reassigning a value to a structure.
And it works out of the box.
The compiler will of course optimize totally away
the creation of the temporary or not so temporary object.
It's not gonna be there, it's what the compiler is gonna do
is it's going to directly assign to your dereference PA
or through the PA pointer,
totally skipping all the logic on the way.
So that's how we would do it.
What's even better?
And that's just modernity.
Sorry, I had to put the static one there.
I don't know why.
What's even better, you can use it to zero things.
In the old good times, you would call memset.
If you want that, like in the array free,
when you first freed the data
and then zeroed the whole structure just to be sure,
you would call memset on anything.
It works.
It's everywhere in the old C code zeroing
because otherwise you get nasty bugs.
Nowadays, you can write it like this.
So you just assign a new value into your structure
and it's a zeroed value
because it uses empty initialization.
Now, the compiler will memset it for you actually.
If you write code like this,
what the compiler will emit,
depending on the size of your structure,
is either a few Mambo jambos with the XMM registers
to zero your structure directly
or it's going to call memset
if the structure is big enough to call memset.
So you don't have to do it.
Compilers understand what you're doing.
You have to express what you're doing
and let the compiler choose the best way to do it.
And that's not it.
That's not the end of the story
because unfortunately I said that there will be some macros
and I know it's late.
I think it's a good time for macros also
because either it puts people to sleep
or it makes them totally awake.
So let's do macros.
Compound literals can be used as arguments to functions
and for a good reason.
Like, look at this one.
It's a big ugly, right?
And there are even coding styles
which say that if you have to pass more than three
or four arguments,
then you should pass by structure.
There are coding guidelines
and so you shouldn't do things like this.
We agree on it, right?
First of all, this first argument
should be taken as a erase of static one size
but that's something else.
Now in this slide it is
because we already did it correctly.
We use the modernity to signal
that you have to pass valid objects to the blur function.
And of course what you then do
is create a param structures
and pass the address of the param structure to the function.
Much, much better, however, still ugly, right?
That's not what you do.
That's not what you want to do.
The first insight that you might come up with
is that the struct can be created in place
because, hooray, we have compound literals.
So why would you even create the structure
like outside of the function call?
Let's do it.
And I don't know if it's more readable.
No, it's not.
But it certainly looks cooler.
So your cool factor directly goes up.
That's a good idea to do something like this, right?
And then the second insight,
and this is a really breakthrough,
is when you realize that when you look at it,
some of those fields are actually kind of having
like default values.
Compute hardware is set to zero.
It's a default value.
Type box, I'm not showing it,
but maybe it's an enum or something like this,
also with a default value of zero.
And since we're using designated initializers,
we can skip those
because the rest will be zeroed automatically.
So you can pass only what you want to pass directly in place.
And that's good.
That's much, much better, right?
Not only your naming arguments now.
Named arguments are also cool, by the way.
You're naming it with a designated initializer.
You don't have to pass all the arguments.
Now, and because, as I said, it's also about macros.
When you add just one single macro magic line to the mix,
you can start writing code like this,
which totally looks like named parameters
or named arguments in C.
And they are, I mean, those look like named arguments.
And of course, the rest takes a default value of zero
of what you would not pass.
The macro itself, I'm now,
yeah, I have doubts whether it's a good statement now
that it's not much magic.
But let's assume it's not much magic.
I mean, it was middle of the day when I was writing it,
so you have to forgive me.
It's hash defined blur, obviously.
And for those of you who don't know this,
three dots in a macro mean variable number of arguments
that you can pass through in your macro expansion.
And that's exactly what I'm doing, right?
I'm just passing it through in my macro expansion
under the name VA underscore arcs.
This is how you pass through variable number,
variable arguments in C.
And it works.
All of a sudden, you can use this beautiful syntax in C.
Actually, also in C++ node,
because it doesn't have the compound literals.
So you cannot do this in C++,
but I'm pretty sure you can use other tricks there.
And I already said how it works, so I'm not going to repeat it.
And I'm sorry for this slide, but I had to put it there
that it went with a little effort,
a little effort, some arbitrary default values are also possible,
because up to now, if you didn't pass a value explicitly,
it would get a value of zero,
like it would be empty initialized in your structure.
So only zero default values were possible.
Well, that's a lie.
You can have default values by just specifying them in your macro.
If you don't specify them, when you call later the macro,
with your designators, the default values will be taken over,
and they will be used.
Great.
If you do specify them, like I do with here,
with here is specified as 64, and by default, it is 32.
Well, the 64 will be taken,
because in the initializer list, it is after the first initializer.
It emits a warning, as it should, right?
The compilers know that we have something bad in mind,
and they rightfully warn us about it.
This warning can be silenced with a couple of pragmas
that you can build into your macro.
And when I do this, when I later publish this,
because you will have access to it, this slide will be there,
but I knew it would be after 5 p.m. now,
so I skip this slide for now.
But with a bit of pragmas, you can remove the initializer
overwrite warning and do magic.
So that's compound literals.
They're really cool.
There are L values that allow you to do crazy things,
like zeroing the whole objects, initializing objects in a very
simple way, or even create default arguments to functions.
And since we are talking about structs,
and it's not like my favorite hobby topic,
but I use structs a lot.
I do a lot of what you call low-level programming,
system programming, obviously in C,
and I deal with structs and memory allocations from time to time.
So let's talk about one less crazy thing,
and this is the real one last crazy thing
that I'm going to talk about.
Let's make a string, something that you've already seen,
because we already were doing an array a moment before.
The layout was a bit different, if I remember correctly,
but, you know, you get the gist of it.
Again, the length, the size of the array,
and the pointer to the dynamically-arrowed array.
And now you imagine that you want to create a function
that creates such a string for you.
And because we are living in a dynamic world,
we want not only the memory that the array is pointing to
to be dynamically allocated,
we want the whole structure to be dynamically allocated.
So you come up with a piece of code like this.
You take a pointer to a string,
to the const car, sorry, a valid pointer, of course,
and then you do the first malloc to allocate the whole string
structure.
And if this one is valid, because you have to check in line 5
if it's valid, you do another malloc
to allocate the sub-object of the array, right?
And because this code is very complex,
all of a sudden, you have to, for example,
check whether your second allocation,
so the dot array is malloc, succeeded.
Because if it didn't succeed, you have to free,
again, the whole structure and return null.
And this is a code that invites errors,
like just by the sheer length of it
and number of pointers that appear there and mallocs.
So you don't want to write code like this.
Not only it is fragile, because you have to remember about,
like, and especially if it's like a bigger thing,
you have to remember about freeing,
about checking all the pointers.
It's also not really optimal.
You need twice to malloc, and that's bad.
It's a costly operation.
Depending on your luck or the lack of luck,
you might end up with fragmented memory.
Your data structure might end up
in a totally different piece of memory
than your array that's a part of this data structure.
You don't want something like this, right?
It's expensive.
It's bad.
What you want is a one-pic nice block of memory
which contains everything.
Array, there is a solution for it.
This solution, and that's actually why I have a layout like this,
why the car pointer is the last pointer there,
is called the flexible array member.
And it looks like this.
Structures in C can have an array of undefined size
as the last member.
And this is not just a pointer.
This signals that at the end of the structure,
there is an array which is a sub-object
or actually a member of this structure,
and you're going to define at the runtime
what the size of it is.
This string is also an incomplete type all of a sudden
because it doesn't have any proper size anymore.
Because the length of this is unknown at compile time,
at the compile time.
You can only set it up during the runtime.
So it must appear at the end.
And you cannot basically do anything with this string
anymore that's fancy.
Like you really cannot make an array of these strings directly.
It's not going to work because this doesn't have a definite size.
So that's not going to work.
But what you can do, I mean those are all the things you cannot do,
and I already told you what you cannot do,
what you can do is skip one malloc all of a sudden.
So instead of having two mallocs,
I now have one that takes care of allocating my base data structure.
And now if you use the size of,
it's only going to count the members that have a fixed size.
So it's not going to count the array.
And then you take the size of your string
that you want to put in your array and allocate it all at once.
There is no free, needed, no checks.
Actually, one check is needed because I mean,
I still need to properly initialize using the compound literal,
of course, because you already know how it works.
So why not?
And then copying the whole struct and so on.
And the layout becomes something like this.
So it's a contagious block of memory,
much better for your performance,
much better for your sanity, actually,
because the more mallocs, the less sane you become.
Unless you use sanitizers, yeah.
So only one malloc, no wasted space.
And one malloc space overhead.
And still I have, since I still have time,
I'm going to do this one.
And I'm going to do a very short demonstration at the end.
Because why not?
Let's do.
First, macro magic incoming.
This talks and with macros.
So you are shaken awake properly before the evening starts.
And we are going to talk about function overloading in C,
also known as generic selection,
because that's also a feature of C.
C can overload functions.
You wouldn't believe it.
It just does it in a bit different way
than normal people are used to.
Imagine that you have two different structures
and they're obviously shapes, like a circle and a rectangle.
And you want to write a scale function,
which takes those structures and scales them with some scale.
Now, you cannot have something like this in C, right?
Very unfortunately, you cannot,
because C doesn't know what name mangling is.
So it's not going to fly.
You need to, instead of having two scale functions,
you need to name them correctly,
like scale, circle, scale, rect, and so on.
And let's be honest, this is ugly.
I mean, I don't like code like this,
and this is not a joke.
I mean, why would I need two different names
for a function that does exactly the same?
I would prefer to have one function name.
And luckily, this is possible.
And as everything that's possible in C,
it's possible thanks to the macros.
C already, again, I think in C11, if I'm not mistaken,
introduced a new macro called a generic selection macro,
which works on types and switches based on types.
So it's like, it's basically a switch statement
if you look at it.
So in the first, you have the controlling expression,
just like in the switch statement.
And then you have the cases.
If it's type one, type two, or type three,
not really return everything, but replace my macro with this
because macros are about text substitution.
So depending on a control statement,
on the value of the control statement,
actually on the type of the control statement,
you get different things.
You can replace based on the types
your whole macro block with something else.
There's also a default because it's really like a switch statement.
So there is a default clause.
And this doesn't require lots of coding.
If we have two ugly functions, like scale,
circle, scale, rectangle, we can just do define object scale,
which is going to be our function like macro.
And then do this generic selection,
switching on the object based on the type of the object.
If it's a rectangular substitute with scale rectangles,
with scale rectangles, are they wise scale, circle?
And basically this whole block of those lines of code
is going to be substituted with either scale,
scale, rect or scale, circle, depending on the type.
And of course, since it's actually not a textual
substitution, you still have to call the parameters
or pass the parameters later on to the correct function.
And all of a sudden this works.
This is so popular that this is now part of the standard library.
Math functions are already standardized to use generic selection
because before you had like, you know,
for every single math function you had at least three variants
or sometimes more, depending on the argument type.
So now all of them got macros to enable this kind of magic.
Doesn't always work that great, must say,
because integer types get confused with Booleans sometimes.
If you are below C23, starting with C23, not anymore,
but before they get confused.
That's because a Boolean was just a type for Boolean.
And yeah, sorry for something else.
And it doesn't matter, works great.
And I just want to end up with a big bank.
You can also overload on the number of arguments,
if you really want to.
And if you really want to, I don't know.
There's no pub quiz, right?
So it's nobody to impress tonight.
But no, no, this is the kind of things you try to impress your colleagues with
during a pub quiz.
You can also do overloading of known arguments.
So imagine you have like circle, just there is one scale,
but for the rectangle, there's either the vertical or the horizontal scale.
So we take a separate two different scales or just one general scale.
And we would like to again be able to do the magic that we've done before.
So call depending, use the same name to call both of them.
The bad news is that generic is not going to help you that much
because you cannot put it in, I mean, it doesn't expand the macros within it.
So that doesn't work like this.
But the good news is that you can do still generic selection
for scale 2P and scale 1P, depending on the argument type,
just like I did before.
I mean, with a small difference, there is now a variable number of arguments
passed to the macro to account for one or two arguments.
Actually not, I think I was lazy
because those are fixed number of arguments for both cases.
I was lazy, sorry.
And then you do a classic trick.
Once you have those two generic selectors,
you do the invoke or the substitute trick, whatever people call it,
that's used to select a name from a list of names.
The invoke basically takes a number of arguments.
And depending on the number of arguments that you pass to invoke,
it will select different names.
I don't want to talk about the mechanics of it now,
mostly because I am not able to anymore.
That's number one reason.
The number second reason is I understand it,
but I will forget it after three days,
and I will have to look at it anyway.
If you want to use it, look it up.
Unless you're really coding daily with these kind of things.
But that's the standard way of selecting a name from a list of names
based on the number of arguments passed to the selection statement,
and then it will work.
So that was the generic selection,
which makes writing code much easier,
can be nested from multiple selectors
and suffers from all the macro shortcomings.
And generally speaking, this was almost all,
that's the slide that you've seen,
it's incorrect because I don't know
want to do a five minute quick code refactoring,
just to wake you up a bit.
And I'm going, you see, I have something like a vector,
so what we've been doing,
and a very deep function vector create,
written in the old style, like the totally old style.
It's taking a double pointer,
so it's, and the reason it's not why not,
the reason is because then it can write back to the pointer,
that the pointer points to something like this, right?
Something you shouldn't be scared when you see the code in C.
I am compiling on the only compiler that accepts C23,
this is the GCC trunk,
and it works now because it's written in correct old C,
with all the warnings, no warnings are popping up,
sanitizer doesn't kick in, good work.
We want to make it modern C,
and there are a couple of things when you see code like this,
that you have to take care of.
First, let's look at the return type, which is totally wrong,
I'm using the old style of returning integer,
like a negative is a mistake, positive is everything is okay,
and since we are on C23, we can do this out of the box,
we can return, I should return false actually here,
instead of minus one,
so that's the correct way of doing things, right?
And that one being the last one, this should be true.
Still compiles out of the box, no warning,
I don't include any header whatsoever to enable Boolean magic.
The next thing is actually I don't accept null pointers,
so maybe fix also that one, and put static one in here,
and if you do it, all of the sudden, you won't be able to pass
null into the function, it's not going to work,
because the compiler, I mean, it's going to work,
but the compiler will tell you that you are trying to pass a null
to a function that doesn't accept it.
A great thing, you have to pass a valid pointer.
What's next, I don't like null pointers,
I mean, I don't like null because it's not strongly typed,
null ptr, null pointer is a strongly typed alternative nowadays
in C23, use it, there's also null ptr underscore t
as the type of it, just same as in C++.
Define, nah, not really, right?
This is bad, and I don't mean to put it here,
we have constexpr, constexpr size t, I'm using capitals, I know it's bad,
but let it be so.
The compiler got a bit crazy, it doesn't understand really what I do,
because it says set but not use, which is not true,
I think that's, yeah, that's it, it's just too new,
it also doesn't work with auto by the way, and it should,
but then it totally, I mean, it goes monkeys.
So let's keep it like this, we're fine, so far so good.
Look at this, I'm doing the old style initialization, that's something,
you know, that's shameful nowadays.
If you do code like this, you should be ashamed,
because you have compound literals nowadays,
they are much better, express your intent better.
Why don't you do it, let's do it.
The change is not that bad, we have to put, I mean, it is bad,
but let's pretend it's not.
You have to put vector there, and then spell out the names,
we have dot data is equal to that one,
and it's not gonna compile out of the box, of course, dot capacity is that one,
and dot, it was size is that one, close that,
put the commas where they should be put,
and are we good, we are almost good, I mean, I did it incorrectly, of course,
but because I should have done that one here, small change, don't worry,
I am an expert, famous last words, right?
Okay, so we should initialize it like this, and the vector itself
should be still done with malloc size of vector, so let's do it correctly.
This code doesn't compile now without, I mean, it compiles without warnings.
If I'm not mistaken, let's compile without warnings, control itress, now it's not true.
Line 30, oh yes, yeah, that goes away, of course, thank you.
So it compiles without warnings, that's fine.
But then you have to notice, or actually, you should think about what you're doing,
you're doing again something that I told is not really cool, I'm doing a double mallocation, malloc,
because my structure is allocated and my data is allocated, there is first malloc to allocate
the structure, then the second malloc to allocate the data, it's hidden here and the
cast to double is not needed, by the way, in CU you can just cast without this one.
What to do about it? Change, of course, the data type to a flexible array member
or the field type, so do something like this, and now it's not going to work
like it worked before, now it's going to work much, much better,
because what you can do is malloc size of the vector itself plus
size of capacity multiplied by size of debo, I'm doing, I wanted to actually double
malloc and capacity, and it has to go, let's put it where it was,
let's move those up all the way where they belong to, because now it makes sense,
so I'm allocating everything at once, the whole array, as it should be allocated,
and then I don't need this one anymore, I do need to most likely return quickly,
if I don't manage to malloc, because that's still needed, and if I do manage to malloc, well,
all I need is actually that one, so I need to set the capacity correctly,
and that's done with 1.9, and I don't free anymore, because that's also not needed,
so my code now became like at least twice as short, I shouldn't return true,
can I return true here? Yeah, I can, or I can return just vector is different than null pointer,
which is a nice way of spelling the same thing, and do here is vector different than null pointer,
then I'm gonna assign the new capacity to it, and that's it, if I am not mistaken,
that's the end of the refactoring of doing it more modern, using modern proper syntax,
is it better? I think it's more readable, I think it's easier to maintain, because you don't have
so many lines of code, and you don't have so many branches, there are not so many ifs like before,
not so many else, and so on, and so on, and it doesn't compile as some of you most likely notice,
because I'm freeing something, I shouldn't be freeing now, I was freeing still the data,
and I cannot free the data separately now, because data is now a sub item of my big structure, right?
So that's all, that's really all, and that's the summary of it, don't be afraid of modernity,
some features really boost productivity, especially things like initializer,
designated initializers, and compound literals, do boost productivity enormously, some of them
will really help you with safety with pointers, when you use the variable length arrays syntax,
when passing things to functions, or when declaring multidimensional arrays, or even single
dimensional arrays, it's going to help you with safety, compilers are getting better and better,
like basically every year there is a new warning appearing, that wasn't there before for variable
length arrays, some features are scary, like using macros, this is always scary,
what's even more scary is chart GTP is very good at it,
and compilers will understand modernity and help you, when you zero using the compound
literals they will do memset under the hood, they will optimize away all those actually L values,
don't worry about it, like even if you're passing the whole structure to the function
through a compound literal, some compilers do optimize away a lot of it, and you don't pass
what you don't need to, thank you very much for listening, we have exactly 45 seconds left,
which is like perfect timing, but you can ask me later on questions if you have them,
so thanks again for coming here and staying with me awake, which is like a huge achievement
for all of you, so thanks a lot guys
