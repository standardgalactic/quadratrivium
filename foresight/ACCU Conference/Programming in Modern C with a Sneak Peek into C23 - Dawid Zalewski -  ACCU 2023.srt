1
00:00:00,000 --> 00:00:08,040
Good afternoon, everybody, and welcome to my talk about C, which is a quite unexpected

2
00:00:08,040 --> 00:00:09,720
talk for this kind of conference, right?

3
00:00:09,720 --> 00:00:15,720
You come here to hear all about modern languages like C++, Kotlin, a couple of years ago, nowadays

4
00:00:15,720 --> 00:00:20,920
for us is hugely popular, and you hear about this.

5
00:00:20,920 --> 00:00:27,200
And this is about C, which is like, yeah, this grandfather of languages.

6
00:00:27,200 --> 00:00:33,080
So quite surprising, and I'm happy that you are here also to listen to it.

7
00:00:33,080 --> 00:00:37,160
Now, on the other hand, C is not going anywhere.

8
00:00:37,160 --> 00:00:39,520
It's definitely not going anywhere.

9
00:00:39,520 --> 00:00:43,200
I had a pleasure to attend the conference a couple of weeks ago when there were people

10
00:00:43,200 --> 00:00:49,960
from, lots of people from automotive industry, and obviously those guys only use C and C

11
00:00:49,960 --> 00:00:55,000
plus plus, and it's a huge industry, and generally speaking, you know, related embedded industries.

12
00:00:55,000 --> 00:01:00,640
And there are also people from MISRA C and MISRA C plus plus, people who standardize safety

13
00:01:00,640 --> 00:01:06,360
for C and C plus plus, among others, for the automotive industry.

14
00:01:06,360 --> 00:01:13,840
And then, I mean, there was a discussion in the audience, and what I heard a lot is this

15
00:01:13,840 --> 00:01:18,880
is a billion dollar industry, and nobody's going to rewrite billion dollar libraries

16
00:01:18,880 --> 00:01:23,920
and software into Rust anytime soon in any other language for that matter, because they

17
00:01:23,920 --> 00:01:26,160
aren't just not going to drop it at one day.

18
00:01:26,160 --> 00:01:28,200
So C is still rolling there.

19
00:01:28,200 --> 00:01:29,840
So thank you that you are here.

20
00:01:29,840 --> 00:01:33,480
Now, surprisingly, C is not a dead language.

21
00:01:33,480 --> 00:01:34,480
You might think so.

22
00:01:34,480 --> 00:01:40,000
I mean, it's not like, you know, in a rapid development cycle of C plus plus that every

23
00:01:40,000 --> 00:01:43,120
three years to get a new standard.

24
00:01:43,120 --> 00:01:48,040
But it's also not a dead language, quite to the contrary.

25
00:01:48,040 --> 00:01:55,280
What you see there is a valid C, kind of a valid C, and you might be surprised when you

26
00:01:55,280 --> 00:01:58,440
look at it, because there are crazy things happening.

27
00:01:58,440 --> 00:02:05,080
Like, if you learned C from the standard C book, the C programming language, you definitely

28
00:02:05,080 --> 00:02:11,960
have never seen bull as a type or true being returned from something or being passed to

29
00:02:11,960 --> 00:02:12,960
a function.

30
00:02:13,880 --> 00:02:19,880
There is also, that's just because I couldn't fit it on a slide, don't don't mention it.

31
00:02:19,880 --> 00:02:22,920
The structure definition is in the return type directly.

32
00:02:22,920 --> 00:02:24,200
This is a C feature.

33
00:02:24,200 --> 00:02:26,960
So you can do things like this.

34
00:02:26,960 --> 00:02:28,880
It's just I couldn't fit it otherwise.

35
00:02:28,880 --> 00:02:36,480
Anyways, if you go further, there is type of, it's an operator in C that works pretty

36
00:02:36,480 --> 00:02:42,040
much like decal type is just much less powerful and doesn't come with all the craziness craziness

37
00:02:42,040 --> 00:02:44,560
of decal type.

38
00:02:44,560 --> 00:02:55,320
There is constexpr nowadays, at least let's say since two weeks when the C23 was standardized.

39
00:02:55,320 --> 00:03:03,960
There are weird things like indices in square brackets, also something that I don't think

40
00:03:03,960 --> 00:03:09,120
many of you use, especially if you're coming from C++, there is auto.

41
00:03:09,120 --> 00:03:11,720
I mean, it's been there since the beginning, right?

42
00:03:11,720 --> 00:03:18,160
So it's for specifying the storage type in C.

43
00:03:18,160 --> 00:03:26,440
So it's still there, but what's even more strange is the right-hand side of this expression

44
00:03:26,440 --> 00:03:32,240
where it looks like I'm creating like a temporary structure and taking an address of it or casting

45
00:03:32,240 --> 00:03:37,600
something like into a structure and taking an address of it, something, you know, among

46
00:03:37,600 --> 00:03:42,120
these lines.

47
00:03:42,120 --> 00:03:45,760
And I'm returning actually not really this pointer, but the reference in this pointer

48
00:03:45,760 --> 00:03:46,760
later on.

49
00:03:46,760 --> 00:03:54,920
And there is a null pointer, null PTR, just like in C++, it's a keyword again for exactly

50
00:03:54,920 --> 00:04:00,160
past week or has been a keyword for exactly past one week.

51
00:04:00,160 --> 00:04:01,480
So that's it.

52
00:04:01,480 --> 00:04:05,880
This program is a valid C and it compiles.

53
00:04:05,880 --> 00:04:07,920
You wouldn't believe it, but it compiles.

54
00:04:07,920 --> 00:04:15,480
Unfortunately, it compiles only a single compiler now, and that's the trunk of GCC, otherwise

55
00:04:15,480 --> 00:04:17,800
it won't compile.

56
00:04:17,800 --> 00:04:22,000
This is the only compiler that accepts all these nice features because it's so new, it's

57
00:04:22,000 --> 00:04:27,280
just freshly standardized, and they have some special meaning.

58
00:04:27,280 --> 00:04:30,120
So you can compile it using, for example, the compiler explorer.

59
00:04:30,120 --> 00:04:31,120
No problems.

60
00:04:31,120 --> 00:04:35,040
You have to pass in this state is C to X.

61
00:04:35,040 --> 00:04:39,480
It's still not 23 because it won't, I mean, in this compiler in the trunk version, they

62
00:04:39,480 --> 00:04:44,800
weren't even sure that this is going to be C23.

63
00:04:44,800 --> 00:04:49,480
It's going to compile with no warning whatsoever, and it's going to execute.

64
00:04:49,480 --> 00:04:50,480
What's your guess?

65
00:04:50,480 --> 00:04:51,480
What's it's going to do?

66
00:04:51,480 --> 00:04:52,720
I mean, okay, it looks crazy.

67
00:04:52,720 --> 00:04:55,880
I mean, you cannot guess from it what it's going to do.

68
00:04:55,880 --> 00:04:57,280
I agree.

69
00:04:57,280 --> 00:05:02,520
But if you look carefully in line 15, it definitely tries to print something.

70
00:05:02,840 --> 00:05:07,400
No, line 13 is definitely trying to print something by using the putString function

71
00:05:07,400 --> 00:05:11,120
puts, and it's casting this array as an argument.

72
00:05:11,120 --> 00:05:14,000
So it definitely is going to print something.

73
00:05:14,000 --> 00:05:15,160
What's it going to print?

74
00:05:15,160 --> 00:05:16,160
It's going to print C.

75
00:05:16,160 --> 00:05:17,160
It's great.

76
00:05:17,160 --> 00:05:18,160
Long live C.

77
00:05:18,160 --> 00:05:22,520
It's unique code characters for a good measure, right?

78
00:05:22,520 --> 00:05:31,200
That's because C is still the language we love for its total lack of type safety.

79
00:05:31,200 --> 00:05:36,760
It's really one of the reasons why C exists, and it's so popular in embedded industry,

80
00:05:36,760 --> 00:05:40,000
in system programming industry, is that you don't care about types.

81
00:05:40,000 --> 00:05:44,640
You can easily cast from one thing to another, just like a cast set and array of doubles

82
00:05:44,640 --> 00:05:47,400
into a car pointer.

83
00:05:47,400 --> 00:05:48,960
No problems whatsoever.

84
00:05:48,960 --> 00:05:52,360
And if you know what you encode within these doubles, it's going to work.

85
00:05:52,360 --> 00:05:59,360
And of course, it returns 42, as it should, which you also couldn't see.

86
00:05:59,360 --> 00:06:05,040
So this is a talk about modern C, and I'm going to talk about modern C a lot.

87
00:06:05,040 --> 00:06:12,880
And what people consider modern C is anything starting from C99 and above.

88
00:06:12,880 --> 00:06:17,320
There were a couple of standards on the way, like for example, C17, which added a few things,

89
00:06:17,320 --> 00:06:21,880
and now C23, but this is all modern.

90
00:06:21,880 --> 00:06:26,240
That's generally a talk for everybody who learns C from the old books or who doesn't

91
00:06:26,240 --> 00:06:31,680
know C a lot, who doesn't use C a lot, because I expected half of you don't really use C

92
00:06:31,680 --> 00:06:34,320
every day.

93
00:06:34,320 --> 00:06:38,280
Or maybe you got curious about something, maybe you heard something, and you want to

94
00:06:38,280 --> 00:06:39,280
learn.

95
00:06:39,280 --> 00:06:48,480
Anybody, if I ask now, who's using C, like at least once a week here, yeah, two persons.

96
00:06:48,480 --> 00:06:51,280
That's a lot for this.

97
00:06:51,280 --> 00:06:53,840
So I am also using it.

98
00:06:53,840 --> 00:06:57,080
It's like half, half with C++.

99
00:06:57,080 --> 00:07:02,360
So this is basically a talk exactly for you, for those of you who know nothing about C

100
00:07:02,360 --> 00:07:09,960
or learned it a long time ago and think that it's still like in this old prehistoric times.

101
00:07:09,960 --> 00:07:18,120
Now as I said, C is a cool language, and we all love it for its total lack of type safety,

102
00:07:18,120 --> 00:07:24,560
and for the fact that basically you can do everything and express everything with C.

103
00:07:24,560 --> 00:07:30,000
It's just that you have to be very careful not to create a bloody mess when you do it,

104
00:07:30,000 --> 00:07:33,320
which is equally easy as creating a well-working program.

105
00:07:33,320 --> 00:07:39,280
So this talk is going to cover a couple of topics that might be useful when trying not

106
00:07:39,280 --> 00:07:46,120
to create a bloody mess, like how to initialize in modern C, how the initialization works

107
00:07:46,120 --> 00:07:51,080
in modern C, because when you don't initialize variables, bad things happen.

108
00:07:51,080 --> 00:07:56,080
Like C++ has some guarantees about what happens when you don't explicitly initialize,

109
00:07:56,080 --> 00:07:59,760
like default, zero initialization, blah, blah, blah, and so on.

110
00:07:59,760 --> 00:08:01,040
C doesn't.

111
00:08:01,040 --> 00:08:04,720
C just gives you garbage if you don't initialize, right?

112
00:08:04,720 --> 00:08:08,840
We're going to talk about pointers, arrays, and functions, because obviously it is a C talk,

113
00:08:08,840 --> 00:08:13,240
so pointers must happen, otherwise it's not going to work,

114
00:08:13,240 --> 00:08:16,680
and about how you can be a bit safer with pointers.

115
00:08:16,680 --> 00:08:22,560
A bit safer, because those guarantees are now built into the language slowly.

116
00:08:22,560 --> 00:08:29,320
We're going to talk about zeroing, assigning, and things basically like what's on the screen,

117
00:08:29,320 --> 00:08:38,800
how to zero the whole data structure again, because it's an important part of modern C.

118
00:08:38,800 --> 00:08:45,040
Finally, if time permits, a bit about fragile resource management, so cool new features

119
00:08:45,040 --> 00:08:51,720
in C that make it very easy for people who deal with hardware to write efficient software,

120
00:08:51,720 --> 00:08:56,320
and how to make dynamic resource management, and especially memory management less fragile

121
00:08:56,320 --> 00:09:02,960
and easier to handle, and there will be some macro magic, if time permits, because obviously

122
00:09:02,960 --> 00:09:07,640
this is a talk about C, so there must be macro magic.

123
00:09:07,640 --> 00:09:09,360
So that's it.

124
00:09:09,360 --> 00:09:14,560
I will throw, for a good measure, some C23 pieces here and there, but this is not a talk

125
00:09:14,560 --> 00:09:18,240
about C23, mostly because I just couldn't make it in time.

126
00:09:18,240 --> 00:09:23,040
It was standardized a week ago, and a week ago, people didn't even know what would be

127
00:09:23,040 --> 00:09:28,400
really there and what wouldn't be there, so it was a bit too much risk to make a talk about

128
00:09:28,400 --> 00:09:36,360
C23, and the features actually that they put in C23 require on talks on the topic only.

129
00:09:36,360 --> 00:09:40,600
So there will be some 23, and whenever you see this logo, it means that there is a C23

130
00:09:40,600 --> 00:09:41,600
feature.

131
00:09:41,600 --> 00:09:43,480
Now, the quiz time.

132
00:09:43,480 --> 00:09:50,480
It's only quiz, that's only in this talk, and I hope it's a cool quiz, and that you can

133
00:09:50,480 --> 00:09:53,520
answer the questions that I'm going to ask you.

134
00:09:53,520 --> 00:09:54,520
And you can shout.

135
00:09:54,520 --> 00:09:56,240
We are not that many here, you can shout.

136
00:09:56,240 --> 00:09:58,280
I had the microphone, I'm louder anyway.

137
00:09:58,280 --> 00:10:01,280
We have a function, it's C.

138
00:10:01,280 --> 00:10:02,280
It's not C++.

139
00:10:02,280 --> 00:10:03,280
Print.

140
00:10:03,280 --> 00:10:07,080
How many arguments does it accept?

141
00:10:07,080 --> 00:10:09,680
Who's for none?

142
00:10:09,680 --> 00:10:15,160
Okay, who's for possibly many?

143
00:10:15,160 --> 00:10:16,680
Exactly.

144
00:10:16,680 --> 00:10:18,680
Great.

145
00:10:18,680 --> 00:10:23,800
This function accepts possibly many arguments, because in C, when you don't put void in between

146
00:10:23,800 --> 00:10:28,000
the brackets, the function possibly accepts many arguments.

147
00:10:28,000 --> 00:10:30,320
Next one, and that's a tricky one.

148
00:10:30,320 --> 00:10:31,320
There is a function.

149
00:10:31,320 --> 00:10:35,680
It accepts two arguments, A and B, with some types.

150
00:10:35,680 --> 00:10:38,600
The types are not really defined there.

151
00:10:38,600 --> 00:10:41,960
And then it prints the sum of those two arguments, A and B.

152
00:10:41,960 --> 00:10:48,120
And I'm calling this function with two double arguments, 1.5 and 8.5.

153
00:10:48,120 --> 00:10:53,760
And obviously, any normal person would say that the sum of those two is 10.

154
00:10:53,760 --> 00:10:54,760
Who's for 10?

155
00:10:54,760 --> 00:10:59,440
As a result of what the function is going to print?

156
00:10:59,440 --> 00:11:01,320
Who's for 9?

157
00:11:01,320 --> 00:11:02,320
Majority.

158
00:11:02,320 --> 00:11:03,320
Great.

159
00:11:03,320 --> 00:11:04,320
I like it.

160
00:11:04,320 --> 00:11:07,800
It's going to print 9, you're absolutely right.

161
00:11:07,800 --> 00:11:13,600
Because if you don't tell what the argument type is, it's going to be an integer, right?

162
00:11:13,600 --> 00:11:18,720
Because in the old good type, times when C started to exist, there were only integers.

163
00:11:18,720 --> 00:11:20,440
So everything was an integer.

164
00:11:20,440 --> 00:11:23,520
Honestly, I'm on C23.

165
00:11:23,520 --> 00:11:24,520
It's undefined.

166
00:11:24,520 --> 00:11:28,800
Finally, it's undefined because it was a source of many errors.

167
00:11:28,800 --> 00:11:32,280
So it's illegal to do it anymore.

168
00:11:32,280 --> 00:11:34,280
Good things do happen.

169
00:11:34,280 --> 00:11:37,880
Now, that's one tricky.

170
00:11:37,880 --> 00:11:40,080
And the question is very easy.

171
00:11:40,080 --> 00:11:46,880
What's the value of number and what's its type?

172
00:11:46,880 --> 00:11:48,760
So it's just one line of code.

173
00:11:48,760 --> 00:11:52,800
It's don't overthink it, right?

174
00:11:52,800 --> 00:11:56,400
And as a hint, the literal is a floating point number.

175
00:11:56,400 --> 00:12:01,080
It's a float on the right-hand side, right?

176
00:12:01,080 --> 00:12:06,720
So you might think, well, it's a float because the right-hand side of the assignment is a

177
00:12:06,720 --> 00:12:08,120
float.

178
00:12:08,120 --> 00:12:12,280
And the other good hint or a good guess would be an integer.

179
00:12:12,280 --> 00:12:16,160
And it would be an integer because like on the previous slide, if you don't define the

180
00:12:16,160 --> 00:12:19,120
type, it's an integer, right?

181
00:12:19,120 --> 00:12:27,280
And you are right and right depending on which language version you are.

182
00:12:27,280 --> 00:12:37,840
If you are on anything below what happened last week, it's going to be 42 because it's

183
00:12:37,840 --> 00:12:39,600
an integer.

184
00:12:39,600 --> 00:12:46,560
Auto before last week meant automatic storage duration, nothing else.

185
00:12:46,560 --> 00:12:51,280
So you could have skipped it and it would mean like then, you know, it's an integer

186
00:12:51,280 --> 00:12:54,480
because obviously when you don't specify a type, it's an integer.

187
00:12:54,480 --> 00:13:00,400
Now you wouldn't believe it, but auto means the same now in C as it means in C++.

188
00:13:00,400 --> 00:13:02,600
It's for type inference.

189
00:13:02,600 --> 00:13:08,720
Actually, it has this kind of a dual life now in C23.

190
00:13:08,720 --> 00:13:14,120
It is for type inference or for storage duration specification.

191
00:13:14,120 --> 00:13:16,720
That's whether you put the type or not yourself.

192
00:13:16,720 --> 00:13:23,600
So if after the type I would put in, this auto would be specifying the storage duration.

193
00:13:23,600 --> 00:13:26,720
But because I didn't, it's for type inference.

194
00:13:26,720 --> 00:13:27,720
Next one.

195
00:13:27,720 --> 00:13:31,520
Well, this compile in C, okay, this doesn't make any sense now to us because I just showed

196
00:13:31,520 --> 00:13:39,200
you that it compiles in the first slide, but I asked this and there are two different

197
00:13:39,200 --> 00:13:40,200
answers to it.

198
00:13:40,200 --> 00:13:45,920
Either it will compile out of the box or you have to include something.

199
00:13:45,920 --> 00:13:50,440
Who's for including that you have to include some standard headers for it to compile?

200
00:13:50,440 --> 00:13:54,840
You are absolutely right.

201
00:13:54,840 --> 00:13:57,840
Because you didn't read what happened last week, right?

202
00:13:57,840 --> 00:14:04,760
When the bool and false became keywords in C also.

203
00:14:04,760 --> 00:14:11,200
So they also kind of do the same thing like C++, they like to do things slowly.

204
00:14:11,200 --> 00:14:18,560
They first standardized boolean with a totally weird notation underscore capital letter bool.

205
00:14:18,560 --> 00:14:22,560
And you could have the normal bool through a header inclusion that was, it was simply

206
00:14:22,560 --> 00:14:28,840
a type def inside and now it's standardized as a keyword.

207
00:14:28,840 --> 00:14:31,440
That one, I'm not going to retorture you with this one.

208
00:14:31,440 --> 00:14:34,720
I think it's fun.

209
00:14:34,720 --> 00:14:40,360
Unless you know what's happening there, I mean, what's the size of the numbers array

210
00:14:40,360 --> 00:14:43,760
and I don't want you really to count this one.

211
00:14:43,760 --> 00:14:48,760
Because if you count, I think you're around eight.

212
00:14:48,760 --> 00:14:51,920
So there are eight initializers listed there.

213
00:14:51,920 --> 00:14:55,040
But there are many other options there and the correct answer and we're going to talk

214
00:14:55,040 --> 00:14:58,880
about it is 12, which is not really apparent when you look at the list.

215
00:14:58,880 --> 00:15:00,680
There is no 12 anywhere.

216
00:15:00,680 --> 00:15:04,760
There are no 12 initializers, there is no index 11, nothing like this, right?

217
00:15:04,760 --> 00:15:08,920
So it's like, why?

218
00:15:08,920 --> 00:15:14,040
Because it's C and in C we like doing things our harmful way.

219
00:15:14,040 --> 00:15:18,560
So that's why.

220
00:15:18,560 --> 00:15:24,600
Next one, does anybody know actually what is the type of PK in line four?

221
00:15:24,600 --> 00:15:26,920
If you look at it.

222
00:15:26,920 --> 00:15:32,560
PK has a very specific type.

223
00:15:32,560 --> 00:15:41,320
I mean, you are kind of born when you're not born with knowledge of C, it's not that far.

224
00:15:41,320 --> 00:15:49,280
But we learn it when we learn C that pointers are pointers in C and a pointer is a pointer.

225
00:15:49,280 --> 00:15:55,960
You can cast it, it basically doesn't have any further meaning, doesn't come along with

226
00:15:55,960 --> 00:15:58,720
any further type specification, it's just a pointer.

227
00:15:58,720 --> 00:15:59,720
It's not true.

228
00:15:59,720 --> 00:16:05,280
This is a pointer to an array of 10 by 10 integers, exactly.

229
00:16:05,280 --> 00:16:09,680
It's a strongly typed pointer to an array, two dimensional error.

230
00:16:09,680 --> 00:16:15,880
And because of this, when I malloc it and use size of Asterix PK, I'm going to get

231
00:16:15,880 --> 00:16:20,200
enough storage for 100 integers.

232
00:16:20,200 --> 00:16:21,200
Is it integers?

233
00:16:21,200 --> 00:16:24,280
Yes, it is integers.

234
00:16:24,280 --> 00:16:30,040
So the answer is 400, at least on my platform.

235
00:16:30,040 --> 00:16:35,120
And I think we are almost at the end of the funny quiz.

236
00:16:35,120 --> 00:16:38,520
And the question is, is this program well-formed?

237
00:16:38,520 --> 00:16:43,560
And I'm not talking about intendation, it's cool.

238
00:16:43,560 --> 00:16:48,440
I'm talking whether it's going to compile, whether it's going to be accepted by a compiler.

239
00:16:48,440 --> 00:16:52,840
And there are a couple of answers, and you can raise your hand if you think that this

240
00:16:52,840 --> 00:16:55,600
answer sounds true.

241
00:16:55,600 --> 00:17:01,720
Like A is no, because line 11 is fishy.

242
00:17:01,720 --> 00:17:10,000
And line 11 is fishy, because it looks like, actually I don't know what I'm doing there.

243
00:17:10,000 --> 00:17:18,080
It looks like an array, I'm casting actually open curly braces to an array, right?

244
00:17:18,080 --> 00:17:21,160
That's what I'm doing.

245
00:17:21,160 --> 00:17:22,920
Who thinks this line is fishy?

246
00:17:22,920 --> 00:17:28,560
Yeah, it's definitely fishy, but it's not a problem.

247
00:17:28,560 --> 00:17:29,560
It compiles.

248
00:17:29,560 --> 00:17:36,640
The other answer is no, line 5, the address of a temporary is taken, or something that

249
00:17:36,640 --> 00:17:39,200
looks like a temporary.

250
00:17:39,200 --> 00:17:44,040
And I mean, the address is definitely taken in this line, but again, this is a perfectly

251
00:17:44,040 --> 00:17:46,240
fine C.

252
00:17:46,240 --> 00:17:50,360
An answer might be also no, there is no aggregate initialization or something like this, no,

253
00:17:50,360 --> 00:17:54,840
there isn't, but you can initialize with designated initializers.

254
00:17:54,840 --> 00:17:59,040
So this is a perfectly fine C, and it's going to compile.

255
00:17:59,040 --> 00:18:01,080
And it's even going to print something.

256
00:18:01,080 --> 00:18:05,200
I think it's going to print today on the screen.

257
00:18:05,200 --> 00:18:13,000
And last but not least, and that's a tricky one.

258
00:18:13,000 --> 00:18:15,640
What does this function accept?

259
00:18:15,640 --> 00:18:19,400
What kind of arguments does it accept?

260
00:18:19,400 --> 00:18:22,360
Because it accepts a very specific type of arguments.

261
00:18:22,360 --> 00:18:26,880
So this again, type safety, pointer safety, do you have an idea?

262
00:18:26,880 --> 00:18:36,560
C, this key, you're right, sorry, I first read D, which I also have an urge to actually

263
00:18:36,560 --> 00:18:43,160
directly look at, you're right, it accepts valid non-null pointers to con-scar.

264
00:18:43,160 --> 00:18:49,320
So it's a contract, it's basically your saying, it's a pointer to con-scar, and it

265
00:18:49,320 --> 00:18:51,600
has to be valid, it cannot be null.

266
00:18:51,600 --> 00:18:54,640
And you would be surprised, compilers check it.

267
00:18:54,640 --> 00:18:56,440
So that's this.

268
00:18:56,440 --> 00:19:03,400
And we are finally at the core of our talk.

269
00:19:03,400 --> 00:19:07,520
Go on, please.

270
00:19:07,520 --> 00:19:08,520
That one.

271
00:19:08,520 --> 00:19:09,520
I don't hear you.

272
00:19:09,520 --> 00:19:14,840
Is it also the case that the pointer was the pointer and it was the string?

273
00:19:14,840 --> 00:19:18,880
No, no, it's only checked whether it's null or not.

274
00:19:18,920 --> 00:19:23,440
So because it's a pointer, you can pass null, right, as an argument.

275
00:19:23,440 --> 00:19:27,880
So that's been checked, but yeah, it doesn't look into the string really.

276
00:19:27,880 --> 00:19:30,880
No, no, it's not that good.

277
00:19:30,880 --> 00:19:35,000
I mean, there is no runtime in C, there is assembly, right?

278
00:19:35,000 --> 00:19:36,000
So.

279
00:19:36,000 --> 00:19:51,400
Even if you pass an empty string, you still have the null terminator there, so officially

280
00:19:51,400 --> 00:19:54,600
it's valid, right?

281
00:19:54,600 --> 00:19:57,800
I'm sorry, but it's officially valid.

282
00:19:57,800 --> 00:19:59,520
This only checks for null and nothing else.

283
00:19:59,520 --> 00:20:02,200
So okay, let's go.

284
00:20:02,200 --> 00:20:03,200
Initialization.

285
00:20:03,440 --> 00:20:08,480
The first topic, an important topic, and I mean, the quiz was also partially about initialization,

286
00:20:08,480 --> 00:20:11,120
like you've seen lots of initializers.

287
00:20:11,120 --> 00:20:13,280
Have you ever seen code like this?

288
00:20:13,280 --> 00:20:14,600
Anybody?

289
00:20:14,600 --> 00:20:15,800
Raise your hands, please.

290
00:20:15,800 --> 00:20:20,680
All of you have seen this code because it comes from this book.

291
00:20:20,680 --> 00:20:24,400
You must have seen it.

292
00:20:24,400 --> 00:20:30,800
So this code attempts to initialize a structure, right, a structure of X and Y, a very simple

293
00:20:30,800 --> 00:20:32,240
one.

294
00:20:32,240 --> 00:20:34,200
And that's not how you write it nowadays.

295
00:20:34,200 --> 00:20:39,480
Nowadays, what you would do is, of course, use the brace initialization, like you would

296
00:20:39,480 --> 00:20:40,480
do it in C++.

297
00:20:40,480 --> 00:20:46,280
The only difference is you need that equality, you know, or an assignment in between.

298
00:20:46,280 --> 00:20:52,080
And that's how it works in up-to-date C. It exists in C. Brace initialization exists

299
00:20:52,080 --> 00:20:55,840
in C, and you can pretty much initialize everything like this.

300
00:20:55,840 --> 00:21:02,800
So, you know, like an array of undefined size, and then the size will be calculated from

301
00:21:02,800 --> 00:21:04,840
the initializers.

302
00:21:04,840 --> 00:21:12,320
You can initialize a list on an array, or an array with a defined size.

303
00:21:12,320 --> 00:21:14,480
You can initialize structures like this.

304
00:21:14,480 --> 00:21:15,480
No problems whatsoever.

305
00:21:15,480 --> 00:21:20,960
You can initialize pretty much everything with braces, just like basically aggregate

306
00:21:20,960 --> 00:21:26,800
initialization works in C++ for those of you who know what it is.

307
00:21:26,800 --> 00:21:30,280
But when I mean everything, I really mean everything.

308
00:21:30,280 --> 00:21:31,800
This is legal.

309
00:21:31,800 --> 00:21:38,040
Some people write it because then it's uniform, and it looks nice.

310
00:21:38,040 --> 00:21:39,960
And it scares people who don't understand.

311
00:21:39,960 --> 00:21:42,840
And that's also good, because you don't want people who don't understand your C code to

312
00:21:42,840 --> 00:21:46,160
touch your C code, right?

313
00:21:46,160 --> 00:21:49,760
So you put it there just to scare off people.

314
00:21:49,760 --> 00:21:52,160
That works.

315
00:21:52,160 --> 00:21:59,160
There is also something called empty initialization in C. It got a name, empty initialization

316
00:21:59,160 --> 00:22:03,840
a week ago, like a standardized name, before it was known under different names.

317
00:22:03,840 --> 00:22:07,800
Some people called it zero initialization, some default initialization.

318
00:22:07,800 --> 00:22:12,400
And basically the trick is you put a single zero in between the braces.

319
00:22:12,400 --> 00:22:13,400
Nothing else.

320
00:22:13,400 --> 00:22:18,720
This has the effect of zeroing everything, whatever is on the left-hand side.

321
00:22:18,720 --> 00:22:25,240
So if it's a value, or if it's an array, or if it's a structure, then recursively all

322
00:22:25,240 --> 00:22:28,200
the fields of the structure will be zeroed.

323
00:22:28,200 --> 00:22:33,120
Nulls will be actually zeros, like a null is a zero, or most of the architectures will

324
00:22:33,120 --> 00:22:39,640
be put where they should be put, and so on, and so on.

325
00:22:39,640 --> 00:22:45,000
It kind of got its name from this one.

326
00:22:45,000 --> 00:22:51,560
Because in C23 they removed the need for having a zero in between the braces, you can now

327
00:22:51,560 --> 00:22:55,360
skip the zero in between the braces, and it's still going to work.

328
00:22:55,360 --> 00:22:58,520
So that's where it comes from, the empty initialization.

329
00:22:58,520 --> 00:22:59,960
Now what are the rules?

330
00:22:59,960 --> 00:23:01,920
The rules are very simple.

331
00:23:01,920 --> 00:23:10,640
When you empty initialize something, like a structure, what happens is that all your

332
00:23:10,640 --> 00:23:14,920
fields in the structures are going to be zeroed, including the parting bytes.

333
00:23:14,920 --> 00:23:19,480
Not because they have to be zeroed, but that's because what the compilers will do anyway,

334
00:23:19,480 --> 00:23:20,480
and that's it.

335
00:23:20,480 --> 00:23:23,080
There is no magic in it.

336
00:23:23,080 --> 00:23:24,680
It also works for nested types.

337
00:23:24,680 --> 00:23:29,760
So if you have an array of structures or whatever, you can just zero it like this.

338
00:23:29,760 --> 00:23:30,760
It's great.

339
00:23:30,760 --> 00:23:31,760
Right?

340
00:23:31,760 --> 00:23:35,560
You don't have to use memset all of a sudden, and we are used to use memset.

341
00:23:35,560 --> 00:23:40,600
I mean, at least I was used to use memset at all a lot when I was programming C.

342
00:23:40,600 --> 00:23:44,200
So we just put zero there.

343
00:23:44,200 --> 00:23:46,280
Now what if you don't want a zero?

344
00:23:46,280 --> 00:23:53,080
What if you want different values, like, for example, you have a bigger structure with

345
00:23:53,080 --> 00:24:00,320
five fields, and two of them should have some values, and the rest should be zeroed?

346
00:24:00,320 --> 00:24:02,120
Because why not?

347
00:24:02,120 --> 00:24:05,720
And then you might think, okay, what's my idea here?

348
00:24:05,720 --> 00:24:11,400
I might zero first the whole structure, then set the fields, and so on, or do something

349
00:24:11,400 --> 00:24:16,360
crazy like this, right, when you use the brace initialization and list all the members one

350
00:24:16,360 --> 00:24:21,080
after another at the right positions and initialize with zero what needs to be initialized with

351
00:24:21,080 --> 00:24:22,080
zeros.

352
00:24:22,080 --> 00:24:27,960
Luckily, this is not the way, because there are designated initializers in C, just like

353
00:24:27,960 --> 00:24:31,680
they're in C++, and they have the same exactly syntax.

354
00:24:31,680 --> 00:24:38,920
So there is a dot, then the designator, then the equality symbol, and then the value you

355
00:24:38,920 --> 00:24:44,480
initialize the designated field with.

356
00:24:44,480 --> 00:24:50,960
This has the same effect as in C++, almost the same, because we don't have default initialization

357
00:24:50,960 --> 00:24:52,460
here.

358
00:24:52,460 --> 00:24:58,120
It zeros all the fields that are not explicitly initialized.

359
00:24:58,120 --> 00:25:03,520
So those that you explicitly initialize with your designators are going to get the values,

360
00:25:03,520 --> 00:25:07,480
the rest is going to be zeroed, which is great, because very often it happens, and especially

361
00:25:07,480 --> 00:25:13,780
if you program in C, in C, people work with all fully long structures that have, I don't

362
00:25:13,780 --> 00:25:18,280
know if you've ever looked, for example, how file is implemented, how many different fields

363
00:25:18,280 --> 00:25:19,280
it has.

364
00:25:19,280 --> 00:25:20,280
It's horrible.

365
00:25:20,280 --> 00:25:23,120
Most of them are usually zero.

366
00:25:23,120 --> 00:25:25,120
So that's great.

367
00:25:25,120 --> 00:25:30,200
Now what's not so great, or actually maybe what's great, because C gives you all the

368
00:25:30,200 --> 00:25:38,360
powers there is, there are in this world, so what's great, you can mix the positions

369
00:25:38,360 --> 00:25:40,160
when you're designated initializer.

370
00:25:40,160 --> 00:25:44,480
So you're not necessarily bound to the order of declaration, as you are in C++.

371
00:25:44,480 --> 00:25:48,440
For C++, it's going to be a hard compilation error if you try something like this.

372
00:25:48,440 --> 00:25:52,320
See, no problems whatsoever, mix them.

373
00:25:52,320 --> 00:25:59,920
What's even, now I struggle to say it's better.

374
00:25:59,920 --> 00:26:09,960
What's even cooler is that you can mix positional and designated initializer, something that's

375
00:26:09,960 --> 00:26:12,240
also forbidden in C++.

376
00:26:12,240 --> 00:26:13,440
You can freely mix them.

377
00:26:13,440 --> 00:26:19,800
You've seen it already when I was asking about the size of an array with really weird indices.

378
00:26:19,800 --> 00:26:25,840
This is a mix of designated and positional initializers, two positional initializers,

379
00:26:25,840 --> 00:26:30,800
the first one and the last one and two designated, but you have to be careful about what you're

380
00:26:30,800 --> 00:26:39,120
doing and how you're doing it, because you have to understand how the logic works behind

381
00:26:39,120 --> 00:26:41,840
the initializations order then.

382
00:26:41,840 --> 00:26:43,200
The first one is quite easy.

383
00:26:43,200 --> 00:26:48,160
It's a positional initializer and it goes into the first field.

384
00:26:48,160 --> 00:26:51,400
Then we have a designator status.

385
00:26:51,400 --> 00:26:56,120
It names the last field in the structure, so the status is going to end up there.

386
00:26:56,120 --> 00:27:02,200
Then we have another designator flex and it fits in there.

387
00:27:02,200 --> 00:27:07,640
Last but not least, we have one more positional initializer with no designator.

388
00:27:07,640 --> 00:27:15,200
It's going to end up directly after the flex and the reason for it, whenever you have a

389
00:27:15,200 --> 00:27:21,040
designator in your initializer list, the counting for the next positional initializer

390
00:27:21,040 --> 00:27:25,600
starts from this designator.

391
00:27:25,600 --> 00:27:31,240
You have to know what you're doing, but that's great and of course the rest is zero.

392
00:27:31,240 --> 00:27:36,600
If you know what you're doing, it's going to work nevertheless.

393
00:27:36,600 --> 00:27:43,520
You can nest initializations just like you can do it in C++.

394
00:27:43,520 --> 00:27:52,440
You can nest them, I mean, the designators and initializers for sub-objects.

395
00:27:52,440 --> 00:27:54,880
Also with designators, no problems whatsoever.

396
00:27:54,880 --> 00:28:01,600
You can even do crazy things like this, dot-flux, dot-extended, dot-extended designates a field

397
00:28:01,600 --> 00:28:04,040
of a sub-object of the structure.

398
00:28:04,040 --> 00:28:06,200
This is also not allowed in C++.

399
00:28:06,200 --> 00:28:08,720
You cannot nest in C++ like this.

400
00:28:08,720 --> 00:28:11,160
In C, it is allowed.

401
00:28:11,160 --> 00:28:17,400
Now, this is also a funny thing and it's funny because I don't know really what's

402
00:28:17,400 --> 00:28:19,760
the use for it.

403
00:28:19,760 --> 00:28:26,640
I mean, I only know one use that I came up with when I was working on it once and it's

404
00:28:26,640 --> 00:28:30,880
not even a good use, so I'm not going to mention.

405
00:28:31,080 --> 00:28:33,360
No, okay.

406
00:28:33,360 --> 00:28:36,600
You can use designators for arrays.

407
00:28:36,600 --> 00:28:42,400
It's absolutely fine and this works the same way as for structures.

408
00:28:42,400 --> 00:28:49,480
The designator designates a field or actually the subscript that you're going to initialize

409
00:28:49,480 --> 00:28:51,160
with a value.

410
00:28:51,160 --> 00:28:54,200
This is like an array of 42 numbers.

411
00:28:54,200 --> 00:28:57,880
Three of them are going to be initialized with certain values.

412
00:28:57,880 --> 00:29:00,760
This is a Fibonacci sequence, roughly.

413
00:29:00,760 --> 00:29:05,200
That's a Fibonacci sequence, part of it.

414
00:29:05,200 --> 00:29:07,920
The rest is going to be zeroed.

415
00:29:07,920 --> 00:29:17,160
The rest of the numbers are going to be zeroed in this array, all of 99 of them, which might

416
00:29:17,160 --> 00:29:20,200
be useful, might not be.

417
00:29:20,200 --> 00:29:23,120
The same craziness applies as instructors.

418
00:29:23,120 --> 00:29:26,680
You can mix the order, whatever you want.

419
00:29:26,680 --> 00:29:34,320
You can mix positional initializers with designated initializers and, again, the same rules apply

420
00:29:34,320 --> 00:29:35,320
as before.

421
00:29:35,320 --> 00:29:43,960
If you have the designator, the index of the following positional initializers is counted

422
00:29:43,960 --> 00:29:45,880
from this designator.

423
00:29:45,880 --> 00:29:51,400
There is a designator 10 at the second position here, which means that 89 is going to end

424
00:29:51,400 --> 00:29:55,000
up at index 11.

425
00:29:55,000 --> 00:30:00,800
Because it's going to end up at index 11, there is nothing actually more to talk about,

426
00:30:00,800 --> 00:30:05,560
but there is something to talk about here, because this is going to end up at index 11.

427
00:30:05,560 --> 00:30:11,480
This array has a size of 12, because this is the highest index in the initializer list.

428
00:30:11,480 --> 00:30:13,240
But this is crazy.

429
00:30:13,240 --> 00:30:15,280
Things like this shouldn't be allowed.

430
00:30:15,280 --> 00:30:19,000
Neither should be this, but it's there.

431
00:30:19,000 --> 00:30:23,200
If you look at this, this is fine.

432
00:30:23,200 --> 00:30:27,120
I mean, it's not fine, but you can do it.

433
00:30:27,120 --> 00:30:34,640
You can have an array of structures, for example, and designate or initialize one of the fields

434
00:30:34,640 --> 00:30:37,680
of those structures at a specific index of the array.

435
00:30:37,680 --> 00:30:40,680
It's going to work out of the box.

436
00:30:40,680 --> 00:30:47,600
The syntax, especially at the multiple level of nesting, looks really ... You cannot comprehend

437
00:30:47,600 --> 00:30:50,120
it anymore, I think, at one moment or another.

438
00:30:50,120 --> 00:30:51,120
It works, nevertheless.

439
00:30:51,400 --> 00:30:52,400
So that's it.

440
00:30:52,400 --> 00:30:54,560
That's the initialization.

441
00:30:54,560 --> 00:30:57,280
That's how we initialize everything in modern C, believe me.

442
00:30:57,280 --> 00:30:58,280
People really do it.

443
00:30:58,280 --> 00:31:02,560
They use curly braces even for numbers, and there are no restrictions.

444
00:31:02,560 --> 00:31:05,560
In C++, they have a lot of restrictions for it.

445
00:31:05,560 --> 00:31:10,040
In C, there are none whatsoever, so you can do ... You can really confuse your colleagues

446
00:31:10,040 --> 00:31:11,040
if you want to.

447
00:31:11,040 --> 00:31:16,000
Now, and since we are talking about arrays, and there is one very popular topic when it

448
00:31:16,000 --> 00:31:21,600
comes to arrays, we are going to discuss it.

449
00:31:21,600 --> 00:31:26,120
Generally speaking, as all of you know, there are two types of arrays in this world.

450
00:31:26,120 --> 00:31:32,520
You can have either an array with a static known size, constants known size, and that's

451
00:31:32,520 --> 00:31:36,640
your good old array, as on the left-hand side, or you can have an array that you allocate

452
00:31:36,640 --> 00:31:40,320
dynamically on the heap, and that's something like a runtime thing.

453
00:31:40,320 --> 00:31:47,120
So during the runtime, you can come up with a value for the size of your array and allocate

454
00:31:47,120 --> 00:31:49,240
it.

455
00:31:49,240 --> 00:31:53,600
It's much better today like this because this size should be somewhere close to your numbers

456
00:31:53,600 --> 00:31:56,240
definition to the array definition.

457
00:31:56,240 --> 00:31:59,520
Nobody people don't put defines, hash define, within the function.

458
00:31:59,520 --> 00:32:03,040
They can, but nobody dares to, for some reasons.

459
00:32:03,040 --> 00:32:06,400
They put it somewhere outside, and then you don't know what the size of the array is,

460
00:32:06,720 --> 00:32:10,480
but with Consexper, it's just more natural to put it next to the array, right?

461
00:32:10,480 --> 00:32:11,760
So you can do it now.

462
00:32:11,760 --> 00:32:13,360
Anyways, back to the arrays.

463
00:32:14,560 --> 00:32:20,480
Question, is a lot a constant integral expression?

464
00:32:21,680 --> 00:32:24,720
Who's for it that it's a constant integral expression?

465
00:32:27,120 --> 00:32:29,680
Some people have doubts.

466
00:32:29,680 --> 00:32:31,840
Who's against it, like totally against?

467
00:32:33,840 --> 00:32:34,880
Nobody has doubts.

468
00:32:35,840 --> 00:32:37,120
That's also fine.

469
00:32:38,320 --> 00:32:39,040
It depends.

470
00:32:39,040 --> 00:32:43,200
If you're coming from C++, obviously it's a constant integral expression in C0.

471
00:32:43,200 --> 00:32:47,760
C, no, sorry, that's why we use defines in C, right?

472
00:32:47,760 --> 00:32:50,320
Because we like to confuse people.

473
00:32:51,600 --> 00:32:56,960
This is not a constant integral expression, so you cannot use it to define an array with

474
00:32:56,960 --> 00:32:58,640
a constant known size.

475
00:32:58,640 --> 00:32:59,920
It's illegal.

476
00:33:01,360 --> 00:33:03,280
However, this code does compile.

477
00:33:05,520 --> 00:33:09,760
It compiles, and many people hate it, that it compiles.

478
00:33:10,560 --> 00:33:14,160
And we're going to talk about why they hate it in a moment.

479
00:33:14,160 --> 00:33:19,760
What it really declares or defines is a so-called variable length array.

480
00:33:20,800 --> 00:33:28,480
It's an array whose size is determined at the runtime, and usually it's allocated on the stack

481
00:33:28,480 --> 00:33:29,360
by the compiler.

482
00:33:30,320 --> 00:33:33,200
Like allocated on the stack during the runtime.

483
00:33:33,200 --> 00:33:41,440
That means also calculating the size, calculating the register shift, the RSP register shift,

484
00:33:42,320 --> 00:33:44,080
and manipulating it at the runtime.

485
00:33:44,720 --> 00:33:49,360
So this creates an array with an unknown size, or actually not with a well-known size

486
00:33:49,360 --> 00:33:50,960
during the runtime, on the stack.

487
00:33:51,440 --> 00:33:54,080
And you can only do it within a block scope.

488
00:33:54,640 --> 00:33:56,560
And the reason is quite obvious.

489
00:33:56,800 --> 00:34:00,880
I mean, at the file scope, you don't have really a stack there.

490
00:34:00,880 --> 00:34:02,800
So how do you declare an array there?

491
00:34:03,840 --> 00:34:07,680
It's not really standardized that it does have to be on the stack, but all the compilers

492
00:34:07,680 --> 00:34:08,400
do it on the stack.

493
00:34:09,120 --> 00:34:11,120
C++ doesn't have this feature.

494
00:34:11,120 --> 00:34:14,560
And for a reason, because there was a big discussion when they introduced it, it will

495
00:34:14,560 --> 00:34:16,720
see also whether it's even needed.

496
00:34:16,720 --> 00:34:20,960
And many people said that it's not needed.

497
00:34:20,960 --> 00:34:26,400
I also said before that you can initialize everything with curly braces.

498
00:34:26,400 --> 00:34:27,840
Well, not this one.

499
00:34:27,840 --> 00:34:29,360
This is the only exception.

500
00:34:29,360 --> 00:34:30,240
You cannot.

501
00:34:30,240 --> 00:34:32,720
You have to initialize it element by element.

502
00:34:33,600 --> 00:34:35,600
Anyways, as I said, some people hate it.

503
00:34:36,480 --> 00:34:39,360
And they hate it with passion.

504
00:34:41,840 --> 00:34:47,360
Like Linus said, that using VLS is actively stupid.

505
00:34:48,960 --> 00:34:54,400
And for many reasons, and many other people in the community actually repeat the same

506
00:34:54,480 --> 00:34:57,040
thing that is actively stupid to do it.

507
00:34:57,040 --> 00:34:58,960
Nowadays, nobody's using VLS.

508
00:34:59,600 --> 00:35:00,880
And that's not a joke.

509
00:35:00,880 --> 00:35:05,600
I mean, students sometimes use it because they don't know that it's a bad code.

510
00:35:06,160 --> 00:35:07,760
But otherwise, nobody's using it.

511
00:35:07,760 --> 00:35:09,120
Why they don't use it?

512
00:35:09,120 --> 00:35:11,920
Well, it's an array on the stack.

513
00:35:11,920 --> 00:35:13,600
You know what's the problem with the stack?

514
00:35:13,600 --> 00:35:18,960
Depending on your architecture, the stack is maybe four kilobytes or maybe eight megabytes

515
00:35:18,960 --> 00:35:19,680
if you're lucky.

516
00:35:20,640 --> 00:35:25,680
So when you declare an array or define an array with a size that's going to be determined

517
00:35:25,680 --> 00:35:29,200
during the runtime, you definitely have to check whether it will fit on the stack.

518
00:35:29,840 --> 00:35:33,120
Otherwise, you're going to blow up the stack and your program will crash.

519
00:35:33,680 --> 00:35:39,600
So you must build in this check somewhere before this array even comes to being.

520
00:35:39,600 --> 00:35:41,360
Otherwise, you are in danger zone.

521
00:35:42,080 --> 00:35:45,120
And only then you can do your array thingy.

522
00:35:45,760 --> 00:35:49,200
So the question is, why would you do it anyway this way?

523
00:35:50,000 --> 00:35:55,040
I mean, isn't it just better to have directly the array with the myAllowedSize

524
00:35:55,920 --> 00:35:58,400
and it will fit everything I need anyway?

525
00:35:59,280 --> 00:36:01,040
So just do it like this, right?

526
00:36:01,920 --> 00:36:03,120
And then this.

527
00:36:03,760 --> 00:36:05,440
And I still have to check, obviously.

528
00:36:06,400 --> 00:36:10,560
But now I have an array with a constant known size.

529
00:36:10,560 --> 00:36:12,320
The compiler can see it upfront.

530
00:36:12,320 --> 00:36:13,680
It can optimize for it.

531
00:36:13,680 --> 00:36:14,240
So why?

532
00:36:15,440 --> 00:36:18,240
What's even worse, if you look at the...

533
00:36:18,240 --> 00:36:20,960
It's the same code as before, just without the stack check.

534
00:36:20,960 --> 00:36:24,720
And I'm doing now the n of size 10 on the left-hand side.

535
00:36:24,720 --> 00:36:26,640
It's a variable length array on the right-hand side.

536
00:36:26,640 --> 00:36:28,480
It's an array with a constant known size.

537
00:36:29,760 --> 00:36:31,520
It generates much worse code.

538
00:36:32,240 --> 00:36:35,360
The VLA variant is much bigger in the assembly

539
00:36:35,920 --> 00:36:38,800
because these calculations have to be done at the runtime.

540
00:36:38,800 --> 00:36:40,240
So you have to calculate the shift.

541
00:36:40,240 --> 00:36:43,840
You have to move the RSP by certain size.

542
00:36:43,840 --> 00:36:46,880
Whereas on the right side, on the right-hand side,

543
00:36:46,880 --> 00:36:51,200
the compiler knows it has to shift the stack pointer by 40 bytes

544
00:36:51,200 --> 00:36:52,080
and it's done.

545
00:36:52,880 --> 00:36:53,760
So it's bad.

546
00:36:53,760 --> 00:36:55,920
It's actively bad.

547
00:36:55,920 --> 00:36:59,600
I'm not going to say stupid, but it's actively bad to do it.

548
00:36:59,600 --> 00:37:00,720
Don't do it.

549
00:37:00,720 --> 00:37:04,240
Now, if you shouldn't do it, then why am I talking about it?

550
00:37:05,440 --> 00:37:06,880
Unless you are, of course, a teacher

551
00:37:06,880 --> 00:37:08,480
because then you are going to see students do it

552
00:37:09,360 --> 00:37:10,720
and you have to correct them.

553
00:37:10,720 --> 00:37:13,440
The reason is VLAs are used for other things.

554
00:37:13,440 --> 00:37:16,960
And some people argue this is the primary reason

555
00:37:16,960 --> 00:37:18,960
why VLAs are in the language.

556
00:37:18,960 --> 00:37:23,120
They are not for having stack arrays with variable length.

557
00:37:23,120 --> 00:37:27,040
They are for doing things like they're going to witness in a moment.

558
00:37:27,920 --> 00:37:31,120
This is a function that takes an array of numbers

559
00:37:32,240 --> 00:37:34,880
by a pointer and the size of the numbers

560
00:37:34,880 --> 00:37:36,240
and does nothing special really.

561
00:37:36,800 --> 00:37:39,760
Now, if you have code like this,

562
00:37:39,760 --> 00:37:44,320
you can also write the argument a bit differently.

563
00:37:45,760 --> 00:37:48,960
You can write the argument as the second parameter

564
00:37:48,960 --> 00:37:53,280
or the second parameter being an array of type int

565
00:37:53,280 --> 00:37:55,440
with n elements inside.

566
00:37:56,080 --> 00:37:58,080
And this does something different.

567
00:37:58,080 --> 00:38:01,200
This communicates your intent all of a sudden.

568
00:38:01,760 --> 00:38:06,160
You say exactly that it must be an array of n elements

569
00:38:06,160 --> 00:38:09,040
and there must be enough storage for those n elements.

570
00:38:09,120 --> 00:38:11,440
The previous one didn't communicate it.

571
00:38:12,880 --> 00:38:16,960
The trick is size has to come before the array

572
00:38:16,960 --> 00:38:18,000
otherwise it's not going to work.

573
00:38:18,000 --> 00:38:19,760
Right? Now, why would you do it?

574
00:38:19,760 --> 00:38:24,560
I mean, you can do it for arrays with known size like that one

575
00:38:24,560 --> 00:38:28,320
an array of five elements and it's going to compile just fine.

576
00:38:29,120 --> 00:38:34,720
Or you can do very nasty things like a hidden bug there

577
00:38:34,720 --> 00:38:37,040
when I'm trying to pass an array of five elements

578
00:38:37,040 --> 00:38:42,640
and pretending it has six elements which is bad, actively bad,

579
00:38:43,760 --> 00:38:46,960
and your compiler will tell you that you are doing something bad.

580
00:38:47,520 --> 00:38:51,440
Compilers do detect those errors if you pass arguments

581
00:38:51,440 --> 00:38:53,040
using the VLA syntax.

582
00:38:53,040 --> 00:38:54,160
At least GCC does.

583
00:38:55,040 --> 00:38:56,960
Clank doesn't really want to do it.

584
00:38:57,600 --> 00:38:59,440
Sometimes it does but not in this case.

585
00:39:00,720 --> 00:39:05,600
Surprisingly, it even works for dynamically allocated arrays.

586
00:39:05,600 --> 00:39:09,360
If you try to pretend that a dynamically allocated array

587
00:39:09,360 --> 00:39:12,240
is bigger than it is, GCC will warn you

588
00:39:12,240 --> 00:39:14,000
with a string operation overflow.

589
00:39:15,280 --> 00:39:17,760
Apparently, it is a string operation what we are doing.

590
00:39:18,880 --> 00:39:21,360
Nevertheless, this is great, right?

591
00:39:21,360 --> 00:39:22,560
It warns you.

592
00:39:22,560 --> 00:39:24,480
And since we are already talking about arrays

593
00:39:25,360 --> 00:39:33,280
and we are all kind of educated in the way that arrays decay

594
00:39:33,280 --> 00:39:37,440
to pointers, unless there are three specific scenarios when they don't,

595
00:39:38,640 --> 00:39:42,480
let's talk about more about how you pass arguments in modern C

596
00:39:42,480 --> 00:39:46,720
and specifically how you pass pointers in modern C to functions.

597
00:39:47,600 --> 00:39:49,840
There are four different scenarios that you can cover

598
00:39:50,560 --> 00:39:54,320
when you think about how you pass pointers in C.

599
00:39:55,120 --> 00:39:59,760
The first one or the first ones are about arrays.

600
00:39:59,760 --> 00:40:02,960
The two second ones are about single objects.

601
00:40:03,440 --> 00:40:05,920
Imagine you are passing an array of n objects

602
00:40:06,560 --> 00:40:10,080
and you have enough storage for n objects

603
00:40:10,080 --> 00:40:13,040
but not necessarily valid objects in this array.

604
00:40:13,040 --> 00:40:16,800
What you're going to do then is use the syntax that I just showed you.

605
00:40:16,800 --> 00:40:20,960
It works and the compilers will check it most often.

606
00:40:22,320 --> 00:40:27,760
So in this case, it's a buffer of n characters uninitialized

607
00:40:27,760 --> 00:40:29,120
and I'm never reading from it.

608
00:40:29,120 --> 00:40:33,360
I'm actually initializing it or putting values into this buffer

609
00:40:33,360 --> 00:40:34,880
but I have enough storage.

610
00:40:34,880 --> 00:40:35,840
That's great.

611
00:40:35,840 --> 00:40:41,280
Now another scenario, if it's an array with enough storage for n objects

612
00:40:42,240 --> 00:40:45,840
and it must contain n valid objects.

613
00:40:45,840 --> 00:40:47,760
That's like a hard requirement.

614
00:40:47,760 --> 00:40:49,760
There are n valid objects inside.

615
00:40:50,400 --> 00:40:56,400
There is this syntax that you guessed correctly for something different.

616
00:40:57,360 --> 00:41:03,840
You use the keyword static before you mentioned the size.

617
00:41:05,040 --> 00:41:08,880
It's been there since C11 if I'm not mistaken

618
00:41:10,000 --> 00:41:12,160
and it means something special.

619
00:41:12,960 --> 00:41:15,680
It basically means that those objects do have exist.

620
00:41:15,680 --> 00:41:17,840
It's illegal not to have objects there

621
00:41:17,840 --> 00:41:23,760
and some compilers are able to check not everything but some parts of it

622
00:41:23,760 --> 00:41:26,080
but it clearly communicates the intent at least.

623
00:41:26,960 --> 00:41:28,880
So static communicates the intent.

624
00:41:29,920 --> 00:41:34,480
When it's a single object and it can be a null pointer,

625
00:41:34,480 --> 00:41:36,880
well, you do it the old way, right?

626
00:41:36,880 --> 00:41:38,640
There is nothing special about it.

627
00:41:38,640 --> 00:41:43,520
You are responsible for checking it if it works or if it doesn't work.

628
00:41:43,520 --> 00:41:48,080
Now the last one is actually the one that we already showed during the quiz

629
00:41:48,080 --> 00:41:50,000
or I already showed during the quiz.

630
00:41:50,000 --> 00:41:53,280
If you're passing a pointer and it mustn't be null,

631
00:41:53,280 --> 00:41:58,800
it's illegal that it's a null pointer than you use static one.

632
00:41:58,800 --> 00:42:01,680
It's a very common thing, especially static one,

633
00:42:02,400 --> 00:42:08,400
somehow managed to permeate into the code, into the live code.

634
00:42:08,400 --> 00:42:11,440
People use it because compilers check it and enforce it.

635
00:42:16,400 --> 00:42:21,120
So use it and for a proof that compilers check it and enforce it,

636
00:42:22,080 --> 00:42:26,080
especially when you use the static keyword, look at this piece of the code,

637
00:42:27,520 --> 00:42:32,800
it basically tells that there is a function that takes an array of three doubles

638
00:42:32,800 --> 00:42:34,400
and those doubles must exist.

639
00:42:35,920 --> 00:42:39,280
And I'm trying to call this function with a dynamically created array

640
00:42:40,240 --> 00:42:43,760
and notice that I'm totally not saying, I mean,

641
00:42:43,760 --> 00:42:47,520
I'm not passing the size of the array here as an argument

642
00:42:47,520 --> 00:42:50,480
and I'm trying to do it as statically created array.

643
00:42:52,000 --> 00:42:58,400
This GCC triggers an error for both of them.

644
00:42:59,200 --> 00:43:03,040
GCC, without even the static analyzer that it has built in,

645
00:43:03,040 --> 00:43:05,840
is able to see that you're doing something very bad

646
00:43:05,840 --> 00:43:08,160
and it will gonna tell you this time with, again,

647
00:43:08,160 --> 00:43:09,680
with string operation overflow.

648
00:43:11,120 --> 00:43:18,400
The first one with the static array also triggers an error on the clunk compiler.

649
00:43:18,400 --> 00:43:20,080
So that's very good.

650
00:43:20,080 --> 00:43:24,640
That protects you against very stupid mistakes that we often do,

651
00:43:24,640 --> 00:43:26,880
you know, buffer overflows do happen.

652
00:43:27,680 --> 00:43:30,640
Like there are single most important point of failure,

653
00:43:31,760 --> 00:43:34,480
I mean, in all the spaceships that went down, right?

654
00:43:36,720 --> 00:43:38,400
So do it.

655
00:43:39,760 --> 00:43:45,680
It also works amazingly well for this kind of syntax,

656
00:43:45,680 --> 00:43:50,960
which I said that protects you against passing a single null pointer

657
00:43:50,960 --> 00:43:52,640
when you don't expect a null pointer.

658
00:43:53,280 --> 00:43:56,240
And when you try to do something like this,

659
00:43:56,240 --> 00:43:58,240
GCC will again emit an error.

660
00:43:58,240 --> 00:44:00,400
And I think clunk also now emits an error.

661
00:44:00,400 --> 00:44:05,520
So that's the summary of how you pass arguments in modern C.

662
00:44:06,720 --> 00:44:10,800
Use the row pointer only if you're expecting one object

663
00:44:12,560 --> 00:44:14,800
and only if it can be null.

664
00:44:14,800 --> 00:44:18,720
Otherwise use the VLA notation sometimes with the static keyword

665
00:44:19,280 --> 00:44:23,360
if you expect invalid objects to be in the array.

666
00:44:23,360 --> 00:44:25,040
Compilers do enforce it.

667
00:44:25,040 --> 00:44:27,280
Lots of modern C code is written like this.

668
00:44:27,840 --> 00:44:32,080
And obviously it's not supported in C++, the static notation,

669
00:44:32,080 --> 00:44:36,160
and the VLA syntax also not really there because it's a part of the VLA.

670
00:44:36,800 --> 00:44:40,640
And since we are at the VLA's and there was, I asked this question before,

671
00:44:41,600 --> 00:44:45,760
or I was talking about a PK pointer somewhere in the beginning of the talk.

672
00:44:47,360 --> 00:44:49,840
As you can see, it's a two-dimensional array.

673
00:44:49,840 --> 00:44:50,480
It's a beast.

674
00:44:51,360 --> 00:44:53,520
It's a beast, it's a Gaussian filter.

675
00:44:53,520 --> 00:44:56,080
It's a kernel of the Gaussian filter if I'm not mistaken.

676
00:44:58,400 --> 00:45:04,160
It's a beast and it's a beast because multi-dimensional arrays in C and C++

677
00:45:04,160 --> 00:45:05,600
are horrible to work with.

678
00:45:06,320 --> 00:45:08,400
So that's like a five by five array.

679
00:45:08,400 --> 00:45:09,600
The size doesn't matter.

680
00:45:10,560 --> 00:45:14,320
What's horrible about it is not what you see on the screen.

681
00:45:15,440 --> 00:45:17,200
It's what you see now on the screen.

682
00:45:17,760 --> 00:45:20,800
Maloching this or allocating this array is still okay.

683
00:45:20,800 --> 00:45:24,560
And by the way, notice that I'm also using the VLA syntax

684
00:45:25,840 --> 00:45:27,680
with the size of operator.

685
00:45:27,680 --> 00:45:28,880
This is also valid.

686
00:45:28,880 --> 00:45:30,880
You can do something like this for the size of,

687
00:45:30,880 --> 00:45:33,920
which greatly simplifies size-offing for your malochs.

688
00:45:36,160 --> 00:45:38,080
And then when you index into this array,

689
00:45:40,000 --> 00:45:42,400
I don't understand it now, right?

690
00:45:42,400 --> 00:45:45,040
What I've done before, and I always have to look it up.

691
00:45:46,160 --> 00:45:49,040
And nowadays, people use strategy-tp for these kind of things

692
00:45:49,040 --> 00:45:51,040
before it was stuck overflow.

693
00:45:51,040 --> 00:45:53,600
And I'm not joking because it's unclear.

694
00:45:53,600 --> 00:45:56,720
You have to remember like what's, I mean,

695
00:45:56,720 --> 00:46:00,400
how is the data laid off in the multi-dimensional array

696
00:46:00,400 --> 00:46:01,680
to be able to do this magic.

697
00:46:03,200 --> 00:46:08,080
So what we really want is something like pk

698
00:46:08,160 --> 00:46:10,240
and then a first index, second index.

699
00:46:10,240 --> 00:46:13,280
What we get is, yeah, is this.

700
00:46:15,120 --> 00:46:18,720
Luckily, the VLA syntax does this for you.

701
00:46:19,280 --> 00:46:22,960
When you use VLAs with strongly typed arrays,

702
00:46:22,960 --> 00:46:25,280
you can achieve this because, you know,

703
00:46:25,280 --> 00:46:29,200
VLAs don't only extend to declaring parameters

704
00:46:29,200 --> 00:46:33,520
or to having stuck arrays.

705
00:46:33,600 --> 00:46:39,120
They're also for declaring strong array types.

706
00:46:40,160 --> 00:46:42,880
For those of you who are not fresh with the pointers,

707
00:46:44,560 --> 00:46:47,520
like I wasn't, for example, when I was preparing this talk,

708
00:46:49,760 --> 00:46:53,200
the pk is a pointer to an array of doubles,

709
00:46:53,200 --> 00:46:56,080
to actually two-dimensional array of doubles

710
00:46:56,080 --> 00:46:59,760
with the size as Z as Z, whatever the as Z is.

711
00:46:59,760 --> 00:47:01,680
Because it's a VLA, so it doesn't matter.

712
00:47:01,760 --> 00:47:04,400
It's determined at the runtime.

713
00:47:05,440 --> 00:47:06,640
It's strongly typed.

714
00:47:07,200 --> 00:47:11,040
And that sense that if you try to do something with this,

715
00:47:11,040 --> 00:47:13,040
that's not allowed, like pass it to a function

716
00:47:13,040 --> 00:47:15,680
that accepts a single double pointer,

717
00:47:15,680 --> 00:47:16,800
it's not going to compile even.

718
00:47:17,840 --> 00:47:20,080
And when you use it, all of a sudden,

719
00:47:20,080 --> 00:47:22,080
this kind of syntax becomes possible.

720
00:47:23,280 --> 00:47:24,640
So it's much better.

721
00:47:24,640 --> 00:47:27,200
It's a huge improvement because you can now index

722
00:47:27,200 --> 00:47:29,680
into your multi-dimensional array with this.

723
00:47:29,680 --> 00:47:32,320
Compiler knows it's a pointer to a 2D array,

724
00:47:32,320 --> 00:47:34,000
so it can index into it properly

725
00:47:34,000 --> 00:47:37,520
and translate into the pointer operations.

726
00:47:38,080 --> 00:47:42,080
What's even better, if you don't like the currently,

727
00:47:42,080 --> 00:47:45,280
the brackets Asterix pk, you can also do it like this.

728
00:47:46,800 --> 00:47:48,080
This is a bit of a cheating

729
00:47:48,080 --> 00:47:50,640
because I gave up a bit of a type safety,

730
00:47:51,520 --> 00:47:53,520
because it looks like I'm now allocking,

731
00:47:54,480 --> 00:47:58,480
like an array, a one-dimensional array,

732
00:47:59,280 --> 00:48:03,280
not really doing it, but this allows for this beautiful syntax.

733
00:48:04,800 --> 00:48:11,040
And if you don't like pk, so that's what you do.

734
00:48:12,080 --> 00:48:14,560
If you really fell in love with the VLA syntax,

735
00:48:15,920 --> 00:48:18,960
notice that what I'm doing here on the right-hand side

736
00:48:18,960 --> 00:48:21,280
of the malloc, it's not really cool, right?

737
00:48:21,360 --> 00:48:24,240
I'm doing something like size of pk multiplied by size

738
00:48:24,240 --> 00:48:25,840
and it's going to work correctly.

739
00:48:25,840 --> 00:48:27,600
It's going to allocate the correct number of bytes,

740
00:48:28,640 --> 00:48:30,640
but some people don't like it.

741
00:48:30,640 --> 00:48:32,720
They say that it shouldn't be like this

742
00:48:33,840 --> 00:48:35,680
and that you should use the VLA syntax

743
00:48:35,680 --> 00:48:37,520
for your size of operators also

744
00:48:37,520 --> 00:48:40,640
because it's much cleaner and it communicates the intent better

745
00:48:41,360 --> 00:48:43,200
and you cannot make so many errors.

746
00:48:43,200 --> 00:48:46,720
So if you just fell in love with the VLA syntax

747
00:48:46,720 --> 00:48:50,720
and you want to show off, you can do it also.

748
00:48:51,280 --> 00:48:52,560
Using a type of operator.

749
00:48:55,280 --> 00:48:58,000
Because the type of the pk pointer,

750
00:48:58,000 --> 00:49:01,760
the reference is the array of doubles of size size

751
00:49:02,960 --> 00:49:06,720
and then there is another size then

752
00:49:06,720 --> 00:49:09,600
and together they make a multi-dimensional array.

753
00:49:10,160 --> 00:49:12,960
Think about type of a set decal type here.

754
00:49:12,960 --> 00:49:15,120
So it works in exactly the same way.

755
00:49:15,120 --> 00:49:20,880
So we just declare a type of an array of doubles of size as Z.

756
00:49:21,760 --> 00:49:23,600
And you can combine it with index 10,

757
00:49:23,600 --> 00:49:26,400
which is like, whoa, why?

758
00:49:27,280 --> 00:49:29,520
I was pretty shocked when I discovered this.

759
00:49:32,080 --> 00:49:35,360
Yeah, and since we are in C plus C23,

760
00:49:35,360 --> 00:49:36,800
there is an old pointer obviously.

761
00:49:38,320 --> 00:49:43,120
Anyways, that's the initialization and the arrays.

762
00:49:43,120 --> 00:49:45,680
And now we're coming to the worst part of the talk

763
00:49:45,680 --> 00:49:47,840
because it's the most difficult part of the talk.

764
00:49:47,840 --> 00:49:48,800
Actually, it's not difficult.

765
00:49:48,800 --> 00:49:52,560
It's a bit of a crazy part of the talk.

766
00:49:52,560 --> 00:49:54,800
It's going to be about zero increase assigning

767
00:49:54,800 --> 00:49:59,200
and disappearing L values or whatever you call them.

768
00:50:01,520 --> 00:50:03,040
You remember this slide, right?

769
00:50:03,040 --> 00:50:04,880
This was somewhere at the beginning of the talk

770
00:50:04,880 --> 00:50:07,040
when I talked about the old C initialization

771
00:50:07,040 --> 00:50:09,520
and the new C initialization syntax.

772
00:50:09,520 --> 00:50:11,280
And I said, this is up to date C.

773
00:50:11,920 --> 00:50:13,200
I lied, of course.

774
00:50:13,200 --> 00:50:14,800
This is not an up to date C.

775
00:50:14,800 --> 00:50:18,480
Nobody writes code like this unless you are born

776
00:50:18,480 --> 00:50:21,040
in, yeah, in 2011.

777
00:50:21,920 --> 00:50:23,280
I don't think those people write C.

778
00:50:24,400 --> 00:50:25,040
Might, though.

779
00:50:25,040 --> 00:50:25,600
You never know.

780
00:50:26,400 --> 00:50:29,280
So you don't write this kind of code anymore.

781
00:50:30,160 --> 00:50:31,120
It's not up to date.

782
00:50:31,120 --> 00:50:32,480
It's modestly up to date C.

783
00:50:33,520 --> 00:50:36,240
What you do nowadays is something like this.

784
00:50:37,760 --> 00:50:41,520
You return these things that looks like casting.

785
00:50:42,400 --> 00:50:44,560
And then there is the initializer list

786
00:50:45,440 --> 00:50:47,680
with designated initializers inside.

787
00:50:47,680 --> 00:50:49,760
Now, this has a name.

788
00:50:49,760 --> 00:50:51,120
It's a compound literal.

789
00:50:52,800 --> 00:50:55,040
And this is something that exists only in C.

790
00:50:56,880 --> 00:51:03,200
It has a very simple syntax type in the normal brackets

791
00:51:03,200 --> 00:51:05,840
followed by the initializer in the curly braces.

792
00:51:05,840 --> 00:51:07,920
The initializer is not optional.

793
00:51:07,920 --> 00:51:09,040
You have to put it there.

794
00:51:10,320 --> 00:51:14,240
And it creates an unnamed object.

795
00:51:15,200 --> 00:51:16,480
It's really created.

796
00:51:17,760 --> 00:51:18,320
It exists.

797
00:51:19,200 --> 00:51:22,880
This object has different storage duration.

798
00:51:22,880 --> 00:51:25,040
It can have a static storage duration

799
00:51:25,760 --> 00:51:27,440
if you declare it at the block scope.

800
00:51:27,440 --> 00:51:31,440
For example, I am declaring a not at the block scope,

801
00:51:31,440 --> 00:51:32,800
sorry, the file scope.

802
00:51:32,800 --> 00:51:36,560
I am declaring at the file scope an array of doubles

803
00:51:37,760 --> 00:51:40,240
that doesn't have any name, but I'm assigning it

804
00:51:41,760 --> 00:51:44,320
to a variable of default coefficients.

805
00:51:44,320 --> 00:51:45,760
And it's there.

806
00:51:45,760 --> 00:51:49,760
It's going to exist throughout the duration of your program.

807
00:51:49,760 --> 00:51:53,360
Or you can do automatic storage if it's in the block scope.

808
00:51:54,240 --> 00:51:57,280
And here it is, I'm declaring a structure

809
00:51:57,280 --> 00:51:59,040
or actually I'm assigning to a structure

810
00:52:00,560 --> 00:52:02,160
with some new values.

811
00:52:02,160 --> 00:52:06,240
So I'm using, you know, I have already a fear for structure

812
00:52:07,840 --> 00:52:11,280
and I'm putting a new value into it with the assignment

813
00:52:12,400 --> 00:52:15,600
with some other initializers and so on.

814
00:52:15,600 --> 00:52:17,680
So two different storage locations

815
00:52:17,680 --> 00:52:20,400
and where the object is created as,

816
00:52:20,400 --> 00:52:24,880
like for any other object, if it's a static storage duration,

817
00:52:25,680 --> 00:52:27,360
it's somewhere in the global memory.

818
00:52:27,360 --> 00:52:30,160
So my coefficients are in the global memory.

819
00:52:30,160 --> 00:52:36,080
And my object on the right have some side of the assignment

820
00:52:36,080 --> 00:52:38,320
because this is what we are talking about.

821
00:52:38,320 --> 00:52:41,760
We are not talking about the fear if I are variable.

822
00:52:41,760 --> 00:52:44,320
We are talking about what's on the right hand side

823
00:52:44,400 --> 00:52:51,280
is going to be allocated on the stack for a moment,

824
00:52:51,280 --> 00:52:52,880
at least for the duration of this line.

825
00:52:54,640 --> 00:52:57,040
The unnamed object is an L value.

826
00:52:57,680 --> 00:53:00,960
And for those of you who know a bit about value categories,

827
00:53:01,760 --> 00:53:04,480
it means many things like you can assign to it

828
00:53:07,120 --> 00:53:08,400
or you can take an address of it.

829
00:53:09,120 --> 00:53:10,240
It's fully legal.

830
00:53:10,240 --> 00:53:11,440
It exists.

831
00:53:11,440 --> 00:53:12,960
If it's declared in the block scope,

832
00:53:13,040 --> 00:53:16,000
it's going to exist throughout the duration of this block

833
00:53:16,000 --> 00:53:18,000
or the lifetime of this block.

834
00:53:18,000 --> 00:53:20,160
And you can legally take an address of it.

835
00:53:20,160 --> 00:53:22,880
And this allows for surprising applications like that one.

836
00:53:25,200 --> 00:53:29,120
Those of you who ever dealt with time

837
00:53:30,000 --> 00:53:33,440
are familiar with the normalizing function MakeTime,

838
00:53:33,440 --> 00:53:36,080
which normalizes the TM structure.

839
00:53:37,600 --> 00:53:39,040
You can normalize like this now

840
00:53:40,000 --> 00:53:43,360
and get the Unix time out of it.

841
00:53:44,240 --> 00:53:46,720
Cool thing if you ask me.

842
00:53:46,720 --> 00:53:50,000
Now, those are not C++ temporaries.

843
00:53:50,000 --> 00:53:52,800
They have nothing to do with C++ temporaries.

844
00:53:52,800 --> 00:53:58,160
In C++, what's valid in C and looks very similar,

845
00:53:59,200 --> 00:54:01,520
really very similar, is invalid.

846
00:54:01,520 --> 00:54:02,960
You cannot do it in C++.

847
00:54:02,960 --> 00:54:04,320
This creates a temporary object.

848
00:54:04,320 --> 00:54:07,280
You take the address of it and you try to pass this to a function.

849
00:54:07,280 --> 00:54:09,200
But when the function starts executing,

850
00:54:09,200 --> 00:54:11,120
actually this object would still exist, I think.

851
00:54:11,120 --> 00:54:11,920
Oh, no, it wouldn't.

852
00:54:12,880 --> 00:54:14,480
So it's illegal to do it.

853
00:54:16,000 --> 00:54:18,080
I mean, it's illegal because you are taking an address

854
00:54:18,080 --> 00:54:20,400
of our value, right, of a temporary,

855
00:54:20,400 --> 00:54:22,880
which is not even materialized yet, I think.

856
00:54:23,760 --> 00:54:24,560
So you cannot do it.

857
00:54:25,440 --> 00:54:27,680
In C, it is valid and you can do it.

858
00:54:28,240 --> 00:54:30,000
And you can do crazy things with this.

859
00:54:30,640 --> 00:54:34,720
And a crazy like in not negatively crazy,

860
00:54:34,720 --> 00:54:37,040
but crazy in beautifying your code, crazy.

861
00:54:38,240 --> 00:54:42,240
So something like a typical school assignment,

862
00:54:42,240 --> 00:54:45,200
you have an array and you have to declare

863
00:54:45,200 --> 00:54:48,240
and write a function that initializes this array.

864
00:54:48,240 --> 00:54:50,080
And notice that it's a very simple array.

865
00:54:50,080 --> 00:54:54,640
It has just a data field and a size and an account.

866
00:54:54,640 --> 00:54:55,920
Sorry, capacity and account.

867
00:54:55,920 --> 00:54:58,080
So obviously you're gonna allocate for data

868
00:54:58,080 --> 00:55:01,200
and put some capacity and zero the count.

869
00:55:01,200 --> 00:55:03,600
In the old C, you would do it like this, right?

870
00:55:03,600 --> 00:55:06,880
So you are gonna most likely memset somewhere

871
00:55:07,280 --> 00:55:10,960
or set the fields separately one by one to zero.

872
00:55:12,080 --> 00:55:15,120
You're gonna allocate with caloc or malloc,

873
00:55:15,120 --> 00:55:15,920
doesn't really matter.

874
00:55:17,440 --> 00:55:19,040
And if you manage to allocate,

875
00:55:19,040 --> 00:55:20,800
you are gonna set the capacity also

876
00:55:21,760 --> 00:55:22,800
because that's what you do.

877
00:55:23,680 --> 00:55:27,360
Now, nowadays people write it like this.

878
00:55:28,240 --> 00:55:31,840
So they don't really like zero before they

879
00:55:33,840 --> 00:55:36,480
just write it in one line.

880
00:55:36,560 --> 00:55:40,880
So what happens here is I am creating this lvalue object

881
00:55:43,760 --> 00:55:46,560
on the right hand side of the assignment of type arrays

882
00:55:47,280 --> 00:55:51,120
and initializing with it through the designated initializers,

883
00:55:51,120 --> 00:55:53,440
allocating memory on the fly or on the go.

884
00:55:54,080 --> 00:55:56,880
And then I'm assigning it to the difference pointer.

885
00:55:56,880 --> 00:55:59,680
So I'm basically assigning a structure to a structure

886
00:55:59,680 --> 00:56:01,600
or reassigning a value to a structure.

887
00:56:01,600 --> 00:56:03,280
And it works out of the box.

888
00:56:03,280 --> 00:56:06,000
The compiler will of course optimize totally away

889
00:56:06,000 --> 00:56:09,280
the creation of the temporary or not so temporary object.

890
00:56:09,280 --> 00:56:12,960
It's not gonna be there, it's what the compiler is gonna do

891
00:56:12,960 --> 00:56:17,280
is it's going to directly assign to your dereference PA

892
00:56:17,280 --> 00:56:19,200
or through the PA pointer,

893
00:56:19,200 --> 00:56:22,080
totally skipping all the logic on the way.

894
00:56:23,200 --> 00:56:24,320
So that's how we would do it.

895
00:56:24,880 --> 00:56:25,760
What's even better?

896
00:56:29,520 --> 00:56:31,040
And that's just modernity.

897
00:56:31,040 --> 00:56:33,280
Sorry, I had to put the static one there.

898
00:56:33,280 --> 00:56:33,920
I don't know why.

899
00:56:34,880 --> 00:56:39,120
What's even better, you can use it to zero things.

900
00:56:40,160 --> 00:56:42,560
In the old good times, you would call memset.

901
00:56:42,560 --> 00:56:44,560
If you want that, like in the array free,

902
00:56:44,560 --> 00:56:45,920
when you first freed the data

903
00:56:45,920 --> 00:56:48,000
and then zeroed the whole structure just to be sure,

904
00:56:48,560 --> 00:56:50,880
you would call memset on anything.

905
00:56:50,880 --> 00:56:51,600
It works.

906
00:56:52,720 --> 00:56:56,160
It's everywhere in the old C code zeroing

907
00:56:56,160 --> 00:56:58,160
because otherwise you get nasty bugs.

908
00:56:59,600 --> 00:57:01,920
Nowadays, you can write it like this.

909
00:57:02,880 --> 00:57:07,280
So you just assign a new value into your structure

910
00:57:07,280 --> 00:57:08,400
and it's a zeroed value

911
00:57:08,400 --> 00:57:10,480
because it uses empty initialization.

912
00:57:11,040 --> 00:57:15,280
Now, the compiler will memset it for you actually.

913
00:57:15,280 --> 00:57:16,640
If you write code like this,

914
00:57:16,640 --> 00:57:18,320
what the compiler will emit,

915
00:57:18,320 --> 00:57:21,120
depending on the size of your structure,

916
00:57:21,120 --> 00:57:27,840
is either a few Mambo jambos with the XMM registers

917
00:57:27,840 --> 00:57:30,880
to zero your structure directly

918
00:57:30,880 --> 00:57:32,240
or it's going to call memset

919
00:57:32,240 --> 00:57:36,880
if the structure is big enough to call memset.

920
00:57:37,520 --> 00:57:38,720
So you don't have to do it.

921
00:57:38,720 --> 00:57:40,560
Compilers understand what you're doing.

922
00:57:40,560 --> 00:57:42,160
You have to express what you're doing

923
00:57:42,160 --> 00:57:44,720
and let the compiler choose the best way to do it.

924
00:57:46,720 --> 00:57:47,520
And that's not it.

925
00:57:47,520 --> 00:57:49,200
That's not the end of the story

926
00:57:49,200 --> 00:57:51,760
because unfortunately I said that there will be some macros

927
00:57:51,760 --> 00:57:53,600
and I know it's late.

928
00:57:55,200 --> 00:57:57,200
I think it's a good time for macros also

929
00:57:57,360 --> 00:58:01,840
because either it puts people to sleep

930
00:58:01,840 --> 00:58:05,120
or it makes them totally awake.

931
00:58:06,400 --> 00:58:07,440
So let's do macros.

932
00:58:08,800 --> 00:58:12,240
Compound literals can be used as arguments to functions

933
00:58:12,240 --> 00:58:14,000
and for a good reason.

934
00:58:14,880 --> 00:58:16,480
Like, look at this one.

935
00:58:16,480 --> 00:58:17,920
It's a big ugly, right?

936
00:58:17,920 --> 00:58:19,280
And there are even coding styles

937
00:58:19,280 --> 00:58:21,680
which say that if you have to pass more than three

938
00:58:21,680 --> 00:58:23,600
or four arguments,

939
00:58:23,600 --> 00:58:24,960
then you should pass by structure.

940
00:58:25,920 --> 00:58:27,600
There are coding guidelines

941
00:58:27,600 --> 00:58:29,600
and so you shouldn't do things like this.

942
00:58:29,600 --> 00:58:30,880
We agree on it, right?

943
00:58:32,800 --> 00:58:35,120
First of all, this first argument

944
00:58:35,120 --> 00:58:38,400
should be taken as a erase of static one size

945
00:58:38,400 --> 00:58:39,920
but that's something else.

946
00:58:39,920 --> 00:58:41,600
Now in this slide it is

947
00:58:41,600 --> 00:58:43,360
because we already did it correctly.

948
00:58:43,360 --> 00:58:45,200
We use the modernity to signal

949
00:58:45,200 --> 00:58:48,480
that you have to pass valid objects to the blur function.

950
00:58:49,600 --> 00:58:52,400
And of course what you then do

951
00:58:53,040 --> 00:58:56,800
is create a param structures

952
00:58:56,800 --> 00:58:59,760
and pass the address of the param structure to the function.

953
00:58:59,760 --> 00:59:02,400
Much, much better, however, still ugly, right?

954
00:59:02,960 --> 00:59:04,080
That's not what you do.

955
00:59:04,080 --> 00:59:05,360
That's not what you want to do.

956
00:59:06,800 --> 00:59:09,440
The first insight that you might come up with

957
00:59:09,440 --> 00:59:12,160
is that the struct can be created in place

958
00:59:12,160 --> 00:59:14,720
because, hooray, we have compound literals.

959
00:59:14,720 --> 00:59:16,640
So why would you even create the structure

960
00:59:16,640 --> 00:59:19,200
like outside of the function call?

961
00:59:19,920 --> 00:59:20,480
Let's do it.

962
00:59:21,440 --> 00:59:24,320
And I don't know if it's more readable.

963
00:59:25,680 --> 00:59:26,400
No, it's not.

964
00:59:27,200 --> 00:59:29,040
But it certainly looks cooler.

965
00:59:30,960 --> 00:59:32,960
So your cool factor directly goes up.

966
00:59:34,720 --> 00:59:37,280
That's a good idea to do something like this, right?

967
00:59:38,480 --> 00:59:39,920
And then the second insight,

968
00:59:39,920 --> 00:59:43,600
and this is a really breakthrough,

969
00:59:43,600 --> 00:59:46,960
is when you realize that when you look at it,

970
00:59:47,600 --> 00:59:50,320
some of those fields are actually kind of having

971
00:59:50,320 --> 00:59:51,760
like default values.

972
00:59:51,760 --> 00:59:54,800
Compute hardware is set to zero.

973
00:59:54,800 --> 00:59:56,400
It's a default value.

974
00:59:56,400 --> 00:59:57,920
Type box, I'm not showing it,

975
00:59:57,920 --> 01:00:00,000
but maybe it's an enum or something like this,

976
01:00:00,000 --> 01:00:02,160
also with a default value of zero.

977
01:00:02,160 --> 01:00:04,400
And since we're using designated initializers,

978
01:00:04,400 --> 01:00:05,440
we can skip those

979
01:00:05,440 --> 01:00:08,000
because the rest will be zeroed automatically.

980
01:00:08,880 --> 01:00:12,400
So you can pass only what you want to pass directly in place.

981
01:00:13,680 --> 01:00:14,640
And that's good.

982
01:00:14,640 --> 01:00:16,400
That's much, much better, right?

983
01:00:17,920 --> 01:00:20,160
Not only your naming arguments now.

984
01:00:20,160 --> 01:00:21,840
Named arguments are also cool, by the way.

985
01:00:21,840 --> 01:00:23,920
You're naming it with a designated initializer.

986
01:00:23,920 --> 01:00:26,000
You don't have to pass all the arguments.

987
01:00:26,000 --> 01:00:32,400
Now, and because, as I said, it's also about macros.

988
01:00:32,400 --> 01:00:36,880
When you add just one single macro magic line to the mix,

989
01:00:37,440 --> 01:00:39,600
you can start writing code like this,

990
01:00:39,600 --> 01:00:42,000
which totally looks like named parameters

991
01:00:42,000 --> 01:00:43,440
or named arguments in C.

992
01:00:44,160 --> 01:00:47,680
And they are, I mean, those look like named arguments.

993
01:00:47,680 --> 01:00:50,160
And of course, the rest takes a default value of zero

994
01:00:50,160 --> 01:00:51,680
of what you would not pass.

995
01:00:52,480 --> 01:00:54,880
The macro itself, I'm now,

996
01:00:55,600 --> 01:00:58,400
yeah, I have doubts whether it's a good statement now

997
01:00:58,400 --> 01:00:59,600
that it's not much magic.

998
01:01:01,040 --> 01:01:02,960
But let's assume it's not much magic.

999
01:01:02,960 --> 01:01:06,400
I mean, it was middle of the day when I was writing it,

1000
01:01:06,400 --> 01:01:07,760
so you have to forgive me.

1001
01:01:08,880 --> 01:01:11,440
It's hash defined blur, obviously.

1002
01:01:11,440 --> 01:01:15,040
And for those of you who don't know this,

1003
01:01:15,040 --> 01:01:19,760
three dots in a macro mean variable number of arguments

1004
01:01:19,760 --> 01:01:23,040
that you can pass through in your macro expansion.

1005
01:01:23,600 --> 01:01:25,760
And that's exactly what I'm doing, right?

1006
01:01:25,760 --> 01:01:28,320
I'm just passing it through in my macro expansion

1007
01:01:29,280 --> 01:01:31,920
under the name VA underscore arcs.

1008
01:01:32,480 --> 01:01:34,800
This is how you pass through variable number,

1009
01:01:34,800 --> 01:01:37,760
variable arguments in C.

1010
01:01:37,760 --> 01:01:38,400
And it works.

1011
01:01:38,640 --> 01:01:41,920
All of a sudden, you can use this beautiful syntax in C.

1012
01:01:41,920 --> 01:01:43,920
Actually, also in C++ node,

1013
01:01:43,920 --> 01:01:46,720
because it doesn't have the compound literals.

1014
01:01:46,720 --> 01:01:48,320
So you cannot do this in C++,

1015
01:01:48,320 --> 01:01:50,320
but I'm pretty sure you can use other tricks there.

1016
01:01:54,160 --> 01:01:59,680
And I already said how it works, so I'm not going to repeat it.

1017
01:02:00,960 --> 01:02:03,520
And I'm sorry for this slide, but I had to put it there

1018
01:02:03,520 --> 01:02:06,400
that it went with a little effort,

1019
01:02:06,400 --> 01:02:11,600
a little effort, some arbitrary default values are also possible,

1020
01:02:11,600 --> 01:02:15,680
because up to now, if you didn't pass a value explicitly,

1021
01:02:16,480 --> 01:02:17,840
it would get a value of zero,

1022
01:02:17,840 --> 01:02:20,480
like it would be empty initialized in your structure.

1023
01:02:20,480 --> 01:02:23,360
So only zero default values were possible.

1024
01:02:23,360 --> 01:02:24,240
Well, that's a lie.

1025
01:02:26,000 --> 01:02:30,480
You can have default values by just specifying them in your macro.

1026
01:02:31,600 --> 01:02:35,840
If you don't specify them, when you call later the macro,

1027
01:02:36,480 --> 01:02:40,000
with your designators, the default values will be taken over,

1028
01:02:40,560 --> 01:02:41,520
and they will be used.

1029
01:02:42,080 --> 01:02:42,480
Great.

1030
01:02:44,320 --> 01:02:46,960
If you do specify them, like I do with here,

1031
01:02:46,960 --> 01:02:52,800
with here is specified as 64, and by default, it is 32.

1032
01:02:52,800 --> 01:02:56,000
Well, the 64 will be taken,

1033
01:02:56,000 --> 01:03:00,560
because in the initializer list, it is after the first initializer.

1034
01:03:01,360 --> 01:03:06,000
It emits a warning, as it should, right?

1035
01:03:07,040 --> 01:03:10,160
The compilers know that we have something bad in mind,

1036
01:03:11,360 --> 01:03:13,280
and they rightfully warn us about it.

1037
01:03:13,920 --> 01:03:18,720
This warning can be silenced with a couple of pragmas

1038
01:03:20,480 --> 01:03:22,000
that you can build into your macro.

1039
01:03:26,480 --> 01:03:29,120
And when I do this, when I later publish this,

1040
01:03:29,120 --> 01:03:32,320
because you will have access to it, this slide will be there,

1041
01:03:32,320 --> 01:03:34,560
but I knew it would be after 5 p.m. now,

1042
01:03:34,560 --> 01:03:36,000
so I skip this slide for now.

1043
01:03:37,840 --> 01:03:41,760
But with a bit of pragmas, you can remove the initializer

1044
01:03:41,760 --> 01:03:44,160
overwrite warning and do magic.

1045
01:03:45,200 --> 01:03:46,480
So that's compound literals.

1046
01:03:46,480 --> 01:03:47,680
They're really cool.

1047
01:03:47,680 --> 01:03:50,480
There are L values that allow you to do crazy things,

1048
01:03:50,480 --> 01:03:55,760
like zeroing the whole objects, initializing objects in a very

1049
01:03:56,720 --> 01:04:00,800
simple way, or even create default arguments to functions.

1050
01:04:01,600 --> 01:04:03,600
And since we are talking about structs,

1051
01:04:03,680 --> 01:04:08,000
and it's not like my favorite hobby topic,

1052
01:04:08,800 --> 01:04:10,000
but I use structs a lot.

1053
01:04:10,000 --> 01:04:13,280
I do a lot of what you call low-level programming,

1054
01:04:13,280 --> 01:04:17,120
system programming, obviously in C,

1055
01:04:18,080 --> 01:04:21,600
and I deal with structs and memory allocations from time to time.

1056
01:04:22,800 --> 01:04:26,320
So let's talk about one less crazy thing,

1057
01:04:26,320 --> 01:04:30,720
and this is the real one last crazy thing

1058
01:04:30,720 --> 01:04:31,680
that I'm going to talk about.

1059
01:04:32,640 --> 01:04:35,680
Let's make a string, something that you've already seen,

1060
01:04:35,680 --> 01:04:38,240
because we already were doing an array a moment before.

1061
01:04:39,760 --> 01:04:42,480
The layout was a bit different, if I remember correctly,

1062
01:04:43,360 --> 01:04:46,320
but, you know, you get the gist of it.

1063
01:04:46,320 --> 01:04:48,400
Again, the length, the size of the array,

1064
01:04:48,400 --> 01:04:50,880
and the pointer to the dynamically-arrowed array.

1065
01:04:51,520 --> 01:04:55,360
And now you imagine that you want to create a function

1066
01:04:55,360 --> 01:04:57,920
that creates such a string for you.

1067
01:04:57,920 --> 01:05:00,320
And because we are living in a dynamic world,

1068
01:05:00,320 --> 01:05:05,680
we want not only the memory that the array is pointing to

1069
01:05:05,680 --> 01:05:07,440
to be dynamically allocated,

1070
01:05:07,440 --> 01:05:10,480
we want the whole structure to be dynamically allocated.

1071
01:05:11,680 --> 01:05:13,840
So you come up with a piece of code like this.

1072
01:05:15,200 --> 01:05:17,120
You take a pointer to a string,

1073
01:05:19,040 --> 01:05:22,400
to the const car, sorry, a valid pointer, of course,

1074
01:05:22,400 --> 01:05:25,840
and then you do the first malloc to allocate the whole string

1075
01:05:26,800 --> 01:05:28,160
structure.

1076
01:05:28,160 --> 01:05:32,320
And if this one is valid, because you have to check in line 5

1077
01:05:32,320 --> 01:05:34,160
if it's valid, you do another malloc

1078
01:05:34,160 --> 01:05:38,000
to allocate the sub-object of the array, right?

1079
01:05:38,000 --> 01:05:41,440
And because this code is very complex,

1080
01:05:42,080 --> 01:05:44,320
all of a sudden, you have to, for example,

1081
01:05:44,320 --> 01:05:46,480
check whether your second allocation,

1082
01:05:46,480 --> 01:05:49,280
so the dot array is malloc, succeeded.

1083
01:05:49,280 --> 01:05:51,600
Because if it didn't succeed, you have to free,

1084
01:05:51,600 --> 01:05:53,600
again, the whole structure and return null.

1085
01:05:54,480 --> 01:05:58,400
And this is a code that invites errors,

1086
01:05:58,400 --> 01:06:01,760
like just by the sheer length of it

1087
01:06:01,760 --> 01:06:06,800
and number of pointers that appear there and mallocs.

1088
01:06:08,000 --> 01:06:10,560
So you don't want to write code like this.

1089
01:06:11,440 --> 01:06:14,080
Not only it is fragile, because you have to remember about,

1090
01:06:14,080 --> 01:06:16,080
like, and especially if it's like a bigger thing,

1091
01:06:17,040 --> 01:06:18,480
you have to remember about freeing,

1092
01:06:18,480 --> 01:06:20,240
about checking all the pointers.

1093
01:06:20,240 --> 01:06:22,800
It's also not really optimal.

1094
01:06:22,800 --> 01:06:25,600
You need twice to malloc, and that's bad.

1095
01:06:26,480 --> 01:06:28,000
It's a costly operation.

1096
01:06:28,880 --> 01:06:32,400
Depending on your luck or the lack of luck,

1097
01:06:33,200 --> 01:06:36,240
you might end up with fragmented memory.

1098
01:06:36,240 --> 01:06:37,920
Your data structure might end up

1099
01:06:37,920 --> 01:06:39,840
in a totally different piece of memory

1100
01:06:39,840 --> 01:06:42,400
than your array that's a part of this data structure.

1101
01:06:42,400 --> 01:06:44,640
You don't want something like this, right?

1102
01:06:44,640 --> 01:06:45,600
It's expensive.

1103
01:06:45,600 --> 01:06:46,240
It's bad.

1104
01:06:46,240 --> 01:06:49,600
What you want is a one-pic nice block of memory

1105
01:06:49,600 --> 01:06:51,040
which contains everything.

1106
01:06:51,040 --> 01:06:52,720
Array, there is a solution for it.

1107
01:06:53,840 --> 01:06:57,600
This solution, and that's actually why I have a layout like this,

1108
01:06:57,600 --> 01:07:00,000
why the car pointer is the last pointer there,

1109
01:07:00,800 --> 01:07:03,920
is called the flexible array member.

1110
01:07:03,920 --> 01:07:04,720
And it looks like this.

1111
01:07:05,920 --> 01:07:10,320
Structures in C can have an array of undefined size

1112
01:07:10,320 --> 01:07:11,440
as the last member.

1113
01:07:12,320 --> 01:07:14,480
And this is not just a pointer.

1114
01:07:14,480 --> 01:07:18,000
This signals that at the end of the structure,

1115
01:07:18,000 --> 01:07:20,800
there is an array which is a sub-object

1116
01:07:20,800 --> 01:07:22,960
or actually a member of this structure,

1117
01:07:22,960 --> 01:07:24,720
and you're going to define at the runtime

1118
01:07:24,720 --> 01:07:25,920
what the size of it is.

1119
01:07:27,040 --> 01:07:30,400
This string is also an incomplete type all of a sudden

1120
01:07:30,400 --> 01:07:33,200
because it doesn't have any proper size anymore.

1121
01:07:34,320 --> 01:07:38,320
Because the length of this is unknown at compile time,

1122
01:07:38,320 --> 01:07:39,120
at the compile time.

1123
01:07:39,120 --> 01:07:40,880
You can only set it up during the runtime.

1124
01:07:43,120 --> 01:07:44,400
So it must appear at the end.

1125
01:07:44,800 --> 01:07:48,000
And you cannot basically do anything with this string

1126
01:07:48,000 --> 01:07:49,520
anymore that's fancy.

1127
01:07:49,520 --> 01:07:53,360
Like you really cannot make an array of these strings directly.

1128
01:07:53,360 --> 01:07:57,440
It's not going to work because this doesn't have a definite size.

1129
01:07:58,240 --> 01:07:59,600
So that's not going to work.

1130
01:08:00,960 --> 01:08:05,600
But what you can do, I mean those are all the things you cannot do,

1131
01:08:05,600 --> 01:08:07,360
and I already told you what you cannot do,

1132
01:08:07,360 --> 01:08:10,560
what you can do is skip one malloc all of a sudden.

1133
01:08:10,560 --> 01:08:12,160
So instead of having two mallocs,

1134
01:08:12,160 --> 01:08:17,840
I now have one that takes care of allocating my base data structure.

1135
01:08:17,840 --> 01:08:20,400
And now if you use the size of,

1136
01:08:20,400 --> 01:08:25,920
it's only going to count the members that have a fixed size.

1137
01:08:25,920 --> 01:08:27,520
So it's not going to count the array.

1138
01:08:28,640 --> 01:08:33,200
And then you take the size of your string

1139
01:08:33,200 --> 01:08:38,160
that you want to put in your array and allocate it all at once.

1140
01:08:38,160 --> 01:08:40,480
There is no free, needed, no checks.

1141
01:08:40,480 --> 01:08:43,680
Actually, one check is needed because I mean,

1142
01:08:43,680 --> 01:08:47,920
I still need to properly initialize using the compound literal,

1143
01:08:47,920 --> 01:08:50,960
of course, because you already know how it works.

1144
01:08:50,960 --> 01:08:51,920
So why not?

1145
01:08:51,920 --> 01:08:54,320
And then copying the whole struct and so on.

1146
01:08:54,320 --> 01:08:56,880
And the layout becomes something like this.

1147
01:08:57,440 --> 01:08:59,920
So it's a contagious block of memory,

1148
01:09:00,560 --> 01:09:02,160
much better for your performance,

1149
01:09:02,160 --> 01:09:05,120
much better for your sanity, actually,

1150
01:09:05,120 --> 01:09:08,160
because the more mallocs, the less sane you become.

1151
01:09:10,560 --> 01:09:14,160
Unless you use sanitizers, yeah.

1152
01:09:15,520 --> 01:09:18,000
So only one malloc, no wasted space.

1153
01:09:18,000 --> 01:09:20,480
And one malloc space overhead.

1154
01:09:21,920 --> 01:09:24,400
And still I have, since I still have time,

1155
01:09:24,400 --> 01:09:26,080
I'm going to do this one.

1156
01:09:26,080 --> 01:09:29,680
And I'm going to do a very short demonstration at the end.

1157
01:09:29,680 --> 01:09:30,560
Because why not?

1158
01:09:31,920 --> 01:09:32,720
Let's do.

1159
01:09:32,720 --> 01:09:34,400
First, macro magic incoming.

1160
01:09:34,960 --> 01:09:36,640
This talks and with macros.

1161
01:09:37,200 --> 01:09:41,920
So you are shaken awake properly before the evening starts.

1162
01:09:44,160 --> 01:09:46,720
And we are going to talk about function overloading in C,

1163
01:09:46,720 --> 01:09:48,480
also known as generic selection,

1164
01:09:48,480 --> 01:09:50,160
because that's also a feature of C.

1165
01:09:50,800 --> 01:09:53,680
C can overload functions.

1166
01:09:53,680 --> 01:09:54,800
You wouldn't believe it.

1167
01:09:54,800 --> 01:09:56,720
It just does it in a bit different way

1168
01:09:56,720 --> 01:09:58,240
than normal people are used to.

1169
01:10:00,320 --> 01:10:04,640
Imagine that you have two different structures

1170
01:10:04,640 --> 01:10:07,440
and they're obviously shapes, like a circle and a rectangle.

1171
01:10:08,000 --> 01:10:09,920
And you want to write a scale function,

1172
01:10:09,920 --> 01:10:13,840
which takes those structures and scales them with some scale.

1173
01:10:14,800 --> 01:10:17,680
Now, you cannot have something like this in C, right?

1174
01:10:17,680 --> 01:10:19,280
Very unfortunately, you cannot,

1175
01:10:19,280 --> 01:10:23,440
because C doesn't know what name mangling is.

1176
01:10:23,440 --> 01:10:24,640
So it's not going to fly.

1177
01:10:26,560 --> 01:10:28,800
You need to, instead of having two scale functions,

1178
01:10:28,800 --> 01:10:32,000
you need to name them correctly,

1179
01:10:32,000 --> 01:10:34,720
like scale, circle, scale, rect, and so on.

1180
01:10:34,720 --> 01:10:38,480
And let's be honest, this is ugly.

1181
01:10:38,480 --> 01:10:40,880
I mean, I don't like code like this,

1182
01:10:40,880 --> 01:10:41,840
and this is not a joke.

1183
01:10:41,840 --> 01:10:44,320
I mean, why would I need two different names

1184
01:10:44,320 --> 01:10:46,080
for a function that does exactly the same?

1185
01:10:46,720 --> 01:10:48,640
I would prefer to have one function name.

1186
01:10:49,280 --> 01:10:53,120
And luckily, this is possible.

1187
01:10:53,120 --> 01:10:56,480
And as everything that's possible in C,

1188
01:10:56,480 --> 01:10:58,080
it's possible thanks to the macros.

1189
01:10:59,040 --> 01:11:03,760
C already, again, I think in C11, if I'm not mistaken,

1190
01:11:03,760 --> 01:11:08,160
introduced a new macro called a generic selection macro,

1191
01:11:09,280 --> 01:11:12,640
which works on types and switches based on types.

1192
01:11:13,280 --> 01:11:15,600
So it's like, it's basically a switch statement

1193
01:11:15,600 --> 01:11:16,800
if you look at it.

1194
01:11:16,800 --> 01:11:19,920
So in the first, you have the controlling expression,

1195
01:11:19,920 --> 01:11:21,680
just like in the switch statement.

1196
01:11:21,680 --> 01:11:22,720
And then you have the cases.

1197
01:11:23,920 --> 01:11:26,640
If it's type one, type two, or type three,

1198
01:11:28,720 --> 01:11:32,400
not really return everything, but replace my macro with this

1199
01:11:32,400 --> 01:11:35,040
because macros are about text substitution.

1200
01:11:36,160 --> 01:11:38,000
So depending on a control statement,

1201
01:11:38,960 --> 01:11:41,120
on the value of the control statement,

1202
01:11:41,120 --> 01:11:43,040
actually on the type of the control statement,

1203
01:11:43,760 --> 01:11:45,120
you get different things.

1204
01:11:45,120 --> 01:11:47,200
You can replace based on the types

1205
01:11:48,640 --> 01:11:50,880
your whole macro block with something else.

1206
01:11:50,880 --> 01:11:53,680
There's also a default because it's really like a switch statement.

1207
01:11:53,680 --> 01:11:54,880
So there is a default clause.

1208
01:11:55,520 --> 01:11:58,880
And this doesn't require lots of coding.

1209
01:11:58,880 --> 01:12:02,480
If we have two ugly functions, like scale,

1210
01:12:02,480 --> 01:12:07,680
circle, scale, rectangle, we can just do define object scale,

1211
01:12:07,680 --> 01:12:10,320
which is going to be our function like macro.

1212
01:12:11,200 --> 01:12:14,000
And then do this generic selection,

1213
01:12:14,000 --> 01:12:17,360
switching on the object based on the type of the object.

1214
01:12:17,360 --> 01:12:22,640
If it's a rectangular substitute with scale rectangles,

1215
01:12:22,720 --> 01:12:26,080
with scale rectangles, are they wise scale, circle?

1216
01:12:26,640 --> 01:12:30,080
And basically this whole block of those lines of code

1217
01:12:30,080 --> 01:12:32,640
is going to be substituted with either scale,

1218
01:12:32,640 --> 01:12:35,760
scale, rect or scale, circle, depending on the type.

1219
01:12:36,960 --> 01:12:39,360
And of course, since it's actually not a textual

1220
01:12:40,560 --> 01:12:42,880
substitution, you still have to call the parameters

1221
01:12:42,880 --> 01:12:46,640
or pass the parameters later on to the correct function.

1222
01:12:46,640 --> 01:12:48,080
And all of a sudden this works.

1223
01:12:48,080 --> 01:12:50,880
This is so popular that this is now part of the standard library.

1224
01:12:51,840 --> 01:12:55,600
Math functions are already standardized to use generic selection

1225
01:12:55,600 --> 01:12:58,560
because before you had like, you know,

1226
01:12:58,560 --> 01:13:01,280
for every single math function you had at least three variants

1227
01:13:01,280 --> 01:13:04,160
or sometimes more, depending on the argument type.

1228
01:13:04,160 --> 01:13:09,040
So now all of them got macros to enable this kind of magic.

1229
01:13:09,040 --> 01:13:12,000
Doesn't always work that great, must say,

1230
01:13:14,000 --> 01:13:17,440
because integer types get confused with Booleans sometimes.

1231
01:13:18,320 --> 01:13:23,280
If you are below C23, starting with C23, not anymore,

1232
01:13:23,280 --> 01:13:26,000
but before they get confused.

1233
01:13:26,000 --> 01:13:28,720
That's because a Boolean was just a type for Boolean.

1234
01:13:28,720 --> 01:13:31,920
And yeah, sorry for something else.

1235
01:13:31,920 --> 01:13:35,680
And it doesn't matter, works great.

1236
01:13:36,880 --> 01:13:39,120
And I just want to end up with a big bank.

1237
01:13:40,480 --> 01:13:43,200
You can also overload on the number of arguments,

1238
01:13:43,200 --> 01:13:44,320
if you really want to.

1239
01:13:45,280 --> 01:13:48,720
And if you really want to, I don't know.

1240
01:13:49,840 --> 01:13:50,960
There's no pub quiz, right?

1241
01:13:50,960 --> 01:13:52,720
So it's nobody to impress tonight.

1242
01:13:52,720 --> 01:13:57,200
But no, no, this is the kind of things you try to impress your colleagues with

1243
01:13:58,000 --> 01:13:58,880
during a pub quiz.

1244
01:13:59,600 --> 01:14:02,160
You can also do overloading of known arguments.

1245
01:14:02,160 --> 01:14:05,680
So imagine you have like circle, just there is one scale,

1246
01:14:05,680 --> 01:14:10,240
but for the rectangle, there's either the vertical or the horizontal scale.

1247
01:14:10,240 --> 01:14:14,880
So we take a separate two different scales or just one general scale.

1248
01:14:15,440 --> 01:14:19,600
And we would like to again be able to do the magic that we've done before.

1249
01:14:19,600 --> 01:14:24,320
So call depending, use the same name to call both of them.

1250
01:14:26,000 --> 01:14:29,280
The bad news is that generic is not going to help you that much

1251
01:14:29,840 --> 01:14:35,760
because you cannot put it in, I mean, it doesn't expand the macros within it.

1252
01:14:36,560 --> 01:14:39,520
So that doesn't work like this.

1253
01:14:40,240 --> 01:14:44,560
But the good news is that you can do still generic selection

1254
01:14:46,160 --> 01:14:50,800
for scale 2P and scale 1P, depending on the argument type,

1255
01:14:50,800 --> 01:14:52,080
just like I did before.

1256
01:14:53,920 --> 01:14:57,440
I mean, with a small difference, there is now a variable number of arguments

1257
01:14:57,440 --> 01:15:00,960
passed to the macro to account for one or two arguments.

1258
01:15:00,960 --> 01:15:02,640
Actually not, I think I was lazy

1259
01:15:03,600 --> 01:15:06,480
because those are fixed number of arguments for both cases.

1260
01:15:06,480 --> 01:15:08,400
I was lazy, sorry.

1261
01:15:09,680 --> 01:15:11,680
And then you do a classic trick.

1262
01:15:12,880 --> 01:15:15,520
Once you have those two generic selectors,

1263
01:15:15,520 --> 01:15:19,360
you do the invoke or the substitute trick, whatever people call it,

1264
01:15:20,640 --> 01:15:24,880
that's used to select a name from a list of names.

1265
01:15:26,000 --> 01:15:28,560
The invoke basically takes a number of arguments.

1266
01:15:28,880 --> 01:15:32,160
And depending on the number of arguments that you pass to invoke,

1267
01:15:32,160 --> 01:15:34,320
it will select different names.

1268
01:15:35,440 --> 01:15:38,240
I don't want to talk about the mechanics of it now,

1269
01:15:38,960 --> 01:15:41,200
mostly because I am not able to anymore.

1270
01:15:42,960 --> 01:15:44,240
That's number one reason.

1271
01:15:44,240 --> 01:15:48,640
The number second reason is I understand it,

1272
01:15:48,640 --> 01:15:50,800
but I will forget it after three days,

1273
01:15:50,800 --> 01:15:52,400
and I will have to look at it anyway.

1274
01:15:52,400 --> 01:15:54,240
If you want to use it, look it up.

1275
01:15:54,240 --> 01:15:56,640
Unless you're really coding daily with these kind of things.

1276
01:15:57,440 --> 01:16:01,280
But that's the standard way of selecting a name from a list of names

1277
01:16:01,280 --> 01:16:05,280
based on the number of arguments passed to the selection statement,

1278
01:16:05,920 --> 01:16:07,520
and then it will work.

1279
01:16:07,520 --> 01:16:09,040
So that was the generic selection,

1280
01:16:09,040 --> 01:16:10,480
which makes writing code much easier,

1281
01:16:10,480 --> 01:16:12,560
can be nested from multiple selectors

1282
01:16:14,720 --> 01:16:16,800
and suffers from all the macro shortcomings.

1283
01:16:17,920 --> 01:16:21,120
And generally speaking, this was almost all,

1284
01:16:21,120 --> 01:16:22,640
that's the slide that you've seen,

1285
01:16:22,640 --> 01:16:26,160
it's incorrect because I don't know

1286
01:16:26,720 --> 01:16:30,640
want to do a five minute quick code refactoring,

1287
01:16:32,400 --> 01:16:33,600
just to wake you up a bit.

1288
01:16:35,200 --> 01:16:40,960
And I'm going, you see, I have something like a vector,

1289
01:16:41,520 --> 01:16:42,640
so what we've been doing,

1290
01:16:43,200 --> 01:16:46,400
and a very deep function vector create,

1291
01:16:46,400 --> 01:16:49,760
written in the old style, like the totally old style.

1292
01:16:50,800 --> 01:16:52,240
It's taking a double pointer,

1293
01:16:52,480 --> 01:16:57,680
so it's, and the reason it's not why not,

1294
01:16:57,680 --> 01:17:01,120
the reason is because then it can write back to the pointer,

1295
01:17:01,120 --> 01:17:04,240
that the pointer points to something like this, right?

1296
01:17:06,160 --> 01:17:11,600
Something you shouldn't be scared when you see the code in C.

1297
01:17:11,600 --> 01:17:15,520
I am compiling on the only compiler that accepts C23,

1298
01:17:15,520 --> 01:17:16,960
this is the GCC trunk,

1299
01:17:17,680 --> 01:17:22,160
and it works now because it's written in correct old C,

1300
01:17:22,960 --> 01:17:25,600
with all the warnings, no warnings are popping up,

1301
01:17:25,600 --> 01:17:27,840
sanitizer doesn't kick in, good work.

1302
01:17:29,280 --> 01:17:30,960
We want to make it modern C,

1303
01:17:30,960 --> 01:17:34,720
and there are a couple of things when you see code like this,

1304
01:17:34,720 --> 01:17:36,080
that you have to take care of.

1305
01:17:42,080 --> 01:17:46,400
First, let's look at the return type, which is totally wrong,

1306
01:17:46,480 --> 01:17:50,000
I'm using the old style of returning integer,

1307
01:17:50,000 --> 01:17:54,080
like a negative is a mistake, positive is everything is okay,

1308
01:17:54,080 --> 01:18:00,400
and since we are on C23, we can do this out of the box,

1309
01:18:00,400 --> 01:18:03,200
we can return, I should return false actually here,

1310
01:18:03,200 --> 01:18:04,640
instead of minus one,

1311
01:18:04,640 --> 01:18:07,360
so that's the correct way of doing things, right?

1312
01:18:12,400 --> 01:18:15,760
And that one being the last one, this should be true.

1313
01:18:16,160 --> 01:18:19,280
Still compiles out of the box, no warning,

1314
01:18:19,280 --> 01:18:22,960
I don't include any header whatsoever to enable Boolean magic.

1315
01:18:24,080 --> 01:18:27,520
The next thing is actually I don't accept null pointers,

1316
01:18:28,240 --> 01:18:33,120
so maybe fix also that one, and put static one in here,

1317
01:18:34,400 --> 01:18:39,680
and if you do it, all of the sudden, you won't be able to pass

1318
01:18:40,480 --> 01:18:46,320
null into the function, it's not going to work,

1319
01:18:47,440 --> 01:18:49,440
because the compiler, I mean, it's going to work,

1320
01:18:49,440 --> 01:18:52,720
but the compiler will tell you that you are trying to pass a null

1321
01:18:52,720 --> 01:18:54,400
to a function that doesn't accept it.

1322
01:18:55,120 --> 01:18:58,640
A great thing, you have to pass a valid pointer.

1323
01:18:59,920 --> 01:19:03,440
What's next, I don't like null pointers,

1324
01:19:03,440 --> 01:19:06,160
I mean, I don't like null because it's not strongly typed,

1325
01:19:06,800 --> 01:19:11,040
null ptr, null pointer is a strongly typed alternative nowadays

1326
01:19:11,040 --> 01:19:15,600
in C23, use it, there's also null ptr underscore t

1327
01:19:16,720 --> 01:19:19,520
as the type of it, just same as in C++.

1328
01:19:21,120 --> 01:19:23,920
Define, nah, not really, right?

1329
01:19:24,880 --> 01:19:28,080
This is bad, and I don't mean to put it here,

1330
01:19:29,040 --> 01:19:37,520
we have constexpr, constexpr size t, I'm using capitals, I know it's bad,

1331
01:19:40,160 --> 01:19:41,120
but let it be so.

1332
01:19:43,040 --> 01:19:46,560
The compiler got a bit crazy, it doesn't understand really what I do,

1333
01:19:46,560 --> 01:19:49,600
because it says set but not use, which is not true,

1334
01:19:50,800 --> 01:19:53,760
I think that's, yeah, that's it, it's just too new,

1335
01:19:53,760 --> 01:19:56,960
it also doesn't work with auto by the way, and it should,

1336
01:19:56,960 --> 01:20:00,160
but then it totally, I mean, it goes monkeys.

1337
01:20:01,360 --> 01:20:06,880
So let's keep it like this, we're fine, so far so good.

1338
01:20:09,680 --> 01:20:16,720
Look at this, I'm doing the old style initialization, that's something,

1339
01:20:17,280 --> 01:20:20,720
you know, that's shameful nowadays.

1340
01:20:20,720 --> 01:20:23,440
If you do code like this, you should be ashamed,

1341
01:20:23,440 --> 01:20:25,600
because you have compound literals nowadays,

1342
01:20:25,600 --> 01:20:29,120
they are much better, express your intent better.

1343
01:20:29,120 --> 01:20:30,880
Why don't you do it, let's do it.

1344
01:20:33,280 --> 01:20:38,080
The change is not that bad, we have to put, I mean, it is bad,

1345
01:20:38,080 --> 01:20:39,360
but let's pretend it's not.

1346
01:20:40,240 --> 01:20:45,040
You have to put vector there, and then spell out the names,

1347
01:20:45,040 --> 01:20:48,480
we have dot data is equal to that one,

1348
01:20:49,280 --> 01:20:57,120
and it's not gonna compile out of the box, of course, dot capacity is that one,

1349
01:20:59,440 --> 01:21:04,160
and dot, it was size is that one, close that,

1350
01:21:05,920 --> 01:21:08,160
put the commas where they should be put,

1351
01:21:10,960 --> 01:21:16,480
and are we good, we are almost good, I mean, I did it incorrectly, of course,

1352
01:21:16,480 --> 01:21:21,920
but because I should have done that one here, small change, don't worry,

1353
01:21:23,040 --> 01:21:26,720
I am an expert, famous last words, right?

1354
01:21:28,960 --> 01:21:32,800
Okay, so we should initialize it like this, and the vector itself

1355
01:21:35,360 --> 01:21:42,000
should be still done with malloc size of vector, so let's do it correctly.

1356
01:21:42,160 --> 01:21:48,000
This code doesn't compile now without, I mean, it compiles without warnings.

1357
01:21:51,120 --> 01:21:56,720
If I'm not mistaken, let's compile without warnings, control itress, now it's not true.

1358
01:22:01,840 --> 01:22:08,000
Line 30, oh yes, yeah, that goes away, of course, thank you.

1359
01:22:08,000 --> 01:22:10,880
So it compiles without warnings, that's fine.

1360
01:22:12,960 --> 01:22:17,280
But then you have to notice, or actually, you should think about what you're doing,

1361
01:22:17,280 --> 01:22:23,440
you're doing again something that I told is not really cool, I'm doing a double mallocation, malloc,

1362
01:22:25,440 --> 01:22:30,800
because my structure is allocated and my data is allocated, there is first malloc to allocate

1363
01:22:30,800 --> 01:22:35,760
the structure, then the second malloc to allocate the data, it's hidden here and the

1364
01:22:35,840 --> 01:22:40,800
cast to double is not needed, by the way, in CU you can just cast without this one.

1365
01:22:42,400 --> 01:22:47,520
What to do about it? Change, of course, the data type to a flexible array member

1366
01:22:48,880 --> 01:22:55,680
or the field type, so do something like this, and now it's not going to work

1367
01:22:56,400 --> 01:22:59,680
like it worked before, now it's going to work much, much better,

1368
01:23:00,400 --> 01:23:08,480
because what you can do is malloc size of the vector itself plus

1369
01:23:10,080 --> 01:23:19,680
size of capacity multiplied by size of debo, I'm doing, I wanted to actually double

1370
01:23:20,640 --> 01:23:29,760
malloc and capacity, and it has to go, let's put it where it was,

1371
01:23:31,200 --> 01:23:37,520
let's move those up all the way where they belong to, because now it makes sense,

1372
01:23:37,520 --> 01:23:44,160
so I'm allocating everything at once, the whole array, as it should be allocated,

1373
01:23:44,160 --> 01:23:52,720
and then I don't need this one anymore, I do need to most likely return quickly,

1374
01:23:52,720 --> 01:23:58,720
if I don't manage to malloc, because that's still needed, and if I do manage to malloc, well,

1375
01:23:59,520 --> 01:24:04,080
all I need is actually that one, so I need to set the capacity correctly,

1376
01:24:05,680 --> 01:24:10,400
and that's done with 1.9, and I don't free anymore, because that's also not needed,

1377
01:24:11,200 --> 01:24:17,840
so my code now became like at least twice as short, I shouldn't return true,

1378
01:24:17,840 --> 01:24:24,800
can I return true here? Yeah, I can, or I can return just vector is different than null pointer,

1379
01:24:26,800 --> 01:24:34,640
which is a nice way of spelling the same thing, and do here is vector different than null pointer,

1380
01:24:35,280 --> 01:24:46,000
then I'm gonna assign the new capacity to it, and that's it, if I am not mistaken,

1381
01:24:46,000 --> 01:24:52,720
that's the end of the refactoring of doing it more modern, using modern proper syntax,

1382
01:24:55,360 --> 01:25:02,960
is it better? I think it's more readable, I think it's easier to maintain, because you don't have

1383
01:25:02,960 --> 01:25:08,720
so many lines of code, and you don't have so many branches, there are not so many ifs like before,

1384
01:25:08,720 --> 01:25:15,120
not so many else, and so on, and so on, and it doesn't compile as some of you most likely notice,

1385
01:25:15,120 --> 01:25:22,240
because I'm freeing something, I shouldn't be freeing now, I was freeing still the data,

1386
01:25:22,240 --> 01:25:28,560
and I cannot free the data separately now, because data is now a sub item of my big structure, right?

1387
01:25:28,560 --> 01:25:39,520
So that's all, that's really all, and that's the summary of it, don't be afraid of modernity,

1388
01:25:41,280 --> 01:25:45,120
some features really boost productivity, especially things like initializer,

1389
01:25:45,120 --> 01:25:51,840
designated initializers, and compound literals, do boost productivity enormously, some of them

1390
01:25:51,840 --> 01:25:58,000
will really help you with safety with pointers, when you use the variable length arrays syntax,

1391
01:25:58,000 --> 01:26:04,640
when passing things to functions, or when declaring multidimensional arrays, or even single

1392
01:26:04,640 --> 01:26:10,480
dimensional arrays, it's going to help you with safety, compilers are getting better and better,

1393
01:26:10,480 --> 01:26:17,520
like basically every year there is a new warning appearing, that wasn't there before for variable

1394
01:26:17,520 --> 01:26:24,240
length arrays, some features are scary, like using macros, this is always scary,

1395
01:26:24,960 --> 01:26:28,880
what's even more scary is chart GTP is very good at it,

1396
01:26:31,760 --> 01:26:38,560
and compilers will understand modernity and help you, when you zero using the compound

1397
01:26:38,560 --> 01:26:44,800
literals they will do memset under the hood, they will optimize away all those actually L values,

1398
01:26:44,800 --> 01:26:49,360
don't worry about it, like even if you're passing the whole structure to the function

1399
01:26:49,360 --> 01:26:54,800
through a compound literal, some compilers do optimize away a lot of it, and you don't pass

1400
01:26:54,800 --> 01:27:00,960
what you don't need to, thank you very much for listening, we have exactly 45 seconds left,

1401
01:27:02,960 --> 01:27:07,840
which is like perfect timing, but you can ask me later on questions if you have them,

1402
01:27:08,800 --> 01:27:15,120
so thanks again for coming here and staying with me awake, which is like a huge achievement

1403
01:27:15,120 --> 01:27:20,880
for all of you, so thanks a lot guys

