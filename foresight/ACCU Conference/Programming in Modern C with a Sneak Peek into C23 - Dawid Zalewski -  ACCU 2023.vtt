WEBVTT

00:00.000 --> 00:08.040
Good afternoon, everybody, and welcome to my talk about C, which is a quite unexpected

00:08.040 --> 00:09.720
talk for this kind of conference, right?

00:09.720 --> 00:15.720
You come here to hear all about modern languages like C++, Kotlin, a couple of years ago, nowadays

00:15.720 --> 00:20.920
for us is hugely popular, and you hear about this.

00:20.920 --> 00:27.200
And this is about C, which is like, yeah, this grandfather of languages.

00:27.200 --> 00:33.080
So quite surprising, and I'm happy that you are here also to listen to it.

00:33.080 --> 00:37.160
Now, on the other hand, C is not going anywhere.

00:37.160 --> 00:39.520
It's definitely not going anywhere.

00:39.520 --> 00:43.200
I had a pleasure to attend the conference a couple of weeks ago when there were people

00:43.200 --> 00:49.960
from, lots of people from automotive industry, and obviously those guys only use C and C

00:49.960 --> 00:55.000
plus plus, and it's a huge industry, and generally speaking, you know, related embedded industries.

00:55.000 --> 01:00.640
And there are also people from MISRA C and MISRA C plus plus, people who standardize safety

01:00.640 --> 01:06.360
for C and C plus plus, among others, for the automotive industry.

01:06.360 --> 01:13.840
And then, I mean, there was a discussion in the audience, and what I heard a lot is this

01:13.840 --> 01:18.880
is a billion dollar industry, and nobody's going to rewrite billion dollar libraries

01:18.880 --> 01:23.920
and software into Rust anytime soon in any other language for that matter, because they

01:23.920 --> 01:26.160
aren't just not going to drop it at one day.

01:26.160 --> 01:28.200
So C is still rolling there.

01:28.200 --> 01:29.840
So thank you that you are here.

01:29.840 --> 01:33.480
Now, surprisingly, C is not a dead language.

01:33.480 --> 01:34.480
You might think so.

01:34.480 --> 01:40.000
I mean, it's not like, you know, in a rapid development cycle of C plus plus that every

01:40.000 --> 01:43.120
three years to get a new standard.

01:43.120 --> 01:48.040
But it's also not a dead language, quite to the contrary.

01:48.040 --> 01:55.280
What you see there is a valid C, kind of a valid C, and you might be surprised when you

01:55.280 --> 01:58.440
look at it, because there are crazy things happening.

01:58.440 --> 02:05.080
Like, if you learned C from the standard C book, the C programming language, you definitely

02:05.080 --> 02:11.960
have never seen bull as a type or true being returned from something or being passed to

02:11.960 --> 02:12.960
a function.

02:13.880 --> 02:19.880
There is also, that's just because I couldn't fit it on a slide, don't don't mention it.

02:19.880 --> 02:22.920
The structure definition is in the return type directly.

02:22.920 --> 02:24.200
This is a C feature.

02:24.200 --> 02:26.960
So you can do things like this.

02:26.960 --> 02:28.880
It's just I couldn't fit it otherwise.

02:28.880 --> 02:36.480
Anyways, if you go further, there is type of, it's an operator in C that works pretty

02:36.480 --> 02:42.040
much like decal type is just much less powerful and doesn't come with all the craziness craziness

02:42.040 --> 02:44.560
of decal type.

02:44.560 --> 02:55.320
There is constexpr nowadays, at least let's say since two weeks when the C23 was standardized.

02:55.320 --> 03:03.960
There are weird things like indices in square brackets, also something that I don't think

03:03.960 --> 03:09.120
many of you use, especially if you're coming from C++, there is auto.

03:09.120 --> 03:11.720
I mean, it's been there since the beginning, right?

03:11.720 --> 03:18.160
So it's for specifying the storage type in C.

03:18.160 --> 03:26.440
So it's still there, but what's even more strange is the right-hand side of this expression

03:26.440 --> 03:32.240
where it looks like I'm creating like a temporary structure and taking an address of it or casting

03:32.240 --> 03:37.600
something like into a structure and taking an address of it, something, you know, among

03:37.600 --> 03:42.120
these lines.

03:42.120 --> 03:45.760
And I'm returning actually not really this pointer, but the reference in this pointer

03:45.760 --> 03:46.760
later on.

03:46.760 --> 03:54.920
And there is a null pointer, null PTR, just like in C++, it's a keyword again for exactly

03:54.920 --> 04:00.160
past week or has been a keyword for exactly past one week.

04:00.160 --> 04:01.480
So that's it.

04:01.480 --> 04:05.880
This program is a valid C and it compiles.

04:05.880 --> 04:07.920
You wouldn't believe it, but it compiles.

04:07.920 --> 04:15.480
Unfortunately, it compiles only a single compiler now, and that's the trunk of GCC, otherwise

04:15.480 --> 04:17.800
it won't compile.

04:17.800 --> 04:22.000
This is the only compiler that accepts all these nice features because it's so new, it's

04:22.000 --> 04:27.280
just freshly standardized, and they have some special meaning.

04:27.280 --> 04:30.120
So you can compile it using, for example, the compiler explorer.

04:30.120 --> 04:31.120
No problems.

04:31.120 --> 04:35.040
You have to pass in this state is C to X.

04:35.040 --> 04:39.480
It's still not 23 because it won't, I mean, in this compiler in the trunk version, they

04:39.480 --> 04:44.800
weren't even sure that this is going to be C23.

04:44.800 --> 04:49.480
It's going to compile with no warning whatsoever, and it's going to execute.

04:49.480 --> 04:50.480
What's your guess?

04:50.480 --> 04:51.480
What's it's going to do?

04:51.480 --> 04:52.720
I mean, okay, it looks crazy.

04:52.720 --> 04:55.880
I mean, you cannot guess from it what it's going to do.

04:55.880 --> 04:57.280
I agree.

04:57.280 --> 05:02.520
But if you look carefully in line 15, it definitely tries to print something.

05:02.840 --> 05:07.400
No, line 13 is definitely trying to print something by using the putString function

05:07.400 --> 05:11.120
puts, and it's casting this array as an argument.

05:11.120 --> 05:14.000
So it definitely is going to print something.

05:14.000 --> 05:15.160
What's it going to print?

05:15.160 --> 05:16.160
It's going to print C.

05:16.160 --> 05:17.160
It's great.

05:17.160 --> 05:18.160
Long live C.

05:18.160 --> 05:22.520
It's unique code characters for a good measure, right?

05:22.520 --> 05:31.200
That's because C is still the language we love for its total lack of type safety.

05:31.200 --> 05:36.760
It's really one of the reasons why C exists, and it's so popular in embedded industry,

05:36.760 --> 05:40.000
in system programming industry, is that you don't care about types.

05:40.000 --> 05:44.640
You can easily cast from one thing to another, just like a cast set and array of doubles

05:44.640 --> 05:47.400
into a car pointer.

05:47.400 --> 05:48.960
No problems whatsoever.

05:48.960 --> 05:52.360
And if you know what you encode within these doubles, it's going to work.

05:52.360 --> 05:59.360
And of course, it returns 42, as it should, which you also couldn't see.

05:59.360 --> 06:05.040
So this is a talk about modern C, and I'm going to talk about modern C a lot.

06:05.040 --> 06:12.880
And what people consider modern C is anything starting from C99 and above.

06:12.880 --> 06:17.320
There were a couple of standards on the way, like for example, C17, which added a few things,

06:17.320 --> 06:21.880
and now C23, but this is all modern.

06:21.880 --> 06:26.240
That's generally a talk for everybody who learns C from the old books or who doesn't

06:26.240 --> 06:31.680
know C a lot, who doesn't use C a lot, because I expected half of you don't really use C

06:31.680 --> 06:34.320
every day.

06:34.320 --> 06:38.280
Or maybe you got curious about something, maybe you heard something, and you want to

06:38.280 --> 06:39.280
learn.

06:39.280 --> 06:48.480
Anybody, if I ask now, who's using C, like at least once a week here, yeah, two persons.

06:48.480 --> 06:51.280
That's a lot for this.

06:51.280 --> 06:53.840
So I am also using it.

06:53.840 --> 06:57.080
It's like half, half with C++.

06:57.080 --> 07:02.360
So this is basically a talk exactly for you, for those of you who know nothing about C

07:02.360 --> 07:09.960
or learned it a long time ago and think that it's still like in this old prehistoric times.

07:09.960 --> 07:18.120
Now as I said, C is a cool language, and we all love it for its total lack of type safety,

07:18.120 --> 07:24.560
and for the fact that basically you can do everything and express everything with C.

07:24.560 --> 07:30.000
It's just that you have to be very careful not to create a bloody mess when you do it,

07:30.000 --> 07:33.320
which is equally easy as creating a well-working program.

07:33.320 --> 07:39.280
So this talk is going to cover a couple of topics that might be useful when trying not

07:39.280 --> 07:46.120
to create a bloody mess, like how to initialize in modern C, how the initialization works

07:46.120 --> 07:51.080
in modern C, because when you don't initialize variables, bad things happen.

07:51.080 --> 07:56.080
Like C++ has some guarantees about what happens when you don't explicitly initialize,

07:56.080 --> 07:59.760
like default, zero initialization, blah, blah, blah, and so on.

07:59.760 --> 08:01.040
C doesn't.

08:01.040 --> 08:04.720
C just gives you garbage if you don't initialize, right?

08:04.720 --> 08:08.840
We're going to talk about pointers, arrays, and functions, because obviously it is a C talk,

08:08.840 --> 08:13.240
so pointers must happen, otherwise it's not going to work,

08:13.240 --> 08:16.680
and about how you can be a bit safer with pointers.

08:16.680 --> 08:22.560
A bit safer, because those guarantees are now built into the language slowly.

08:22.560 --> 08:29.320
We're going to talk about zeroing, assigning, and things basically like what's on the screen,

08:29.320 --> 08:38.800
how to zero the whole data structure again, because it's an important part of modern C.

08:38.800 --> 08:45.040
Finally, if time permits, a bit about fragile resource management, so cool new features

08:45.040 --> 08:51.720
in C that make it very easy for people who deal with hardware to write efficient software,

08:51.720 --> 08:56.320
and how to make dynamic resource management, and especially memory management less fragile

08:56.320 --> 09:02.960
and easier to handle, and there will be some macro magic, if time permits, because obviously

09:02.960 --> 09:07.640
this is a talk about C, so there must be macro magic.

09:07.640 --> 09:09.360
So that's it.

09:09.360 --> 09:14.560
I will throw, for a good measure, some C23 pieces here and there, but this is not a talk

09:14.560 --> 09:18.240
about C23, mostly because I just couldn't make it in time.

09:18.240 --> 09:23.040
It was standardized a week ago, and a week ago, people didn't even know what would be

09:23.040 --> 09:28.400
really there and what wouldn't be there, so it was a bit too much risk to make a talk about

09:28.400 --> 09:36.360
C23, and the features actually that they put in C23 require on talks on the topic only.

09:36.360 --> 09:40.600
So there will be some 23, and whenever you see this logo, it means that there is a C23

09:40.600 --> 09:41.600
feature.

09:41.600 --> 09:43.480
Now, the quiz time.

09:43.480 --> 09:50.480
It's only quiz, that's only in this talk, and I hope it's a cool quiz, and that you can

09:50.480 --> 09:53.520
answer the questions that I'm going to ask you.

09:53.520 --> 09:54.520
And you can shout.

09:54.520 --> 09:56.240
We are not that many here, you can shout.

09:56.240 --> 09:58.280
I had the microphone, I'm louder anyway.

09:58.280 --> 10:01.280
We have a function, it's C.

10:01.280 --> 10:02.280
It's not C++.

10:02.280 --> 10:03.280
Print.

10:03.280 --> 10:07.080
How many arguments does it accept?

10:07.080 --> 10:09.680
Who's for none?

10:09.680 --> 10:15.160
Okay, who's for possibly many?

10:15.160 --> 10:16.680
Exactly.

10:16.680 --> 10:18.680
Great.

10:18.680 --> 10:23.800
This function accepts possibly many arguments, because in C, when you don't put void in between

10:23.800 --> 10:28.000
the brackets, the function possibly accepts many arguments.

10:28.000 --> 10:30.320
Next one, and that's a tricky one.

10:30.320 --> 10:31.320
There is a function.

10:31.320 --> 10:35.680
It accepts two arguments, A and B, with some types.

10:35.680 --> 10:38.600
The types are not really defined there.

10:38.600 --> 10:41.960
And then it prints the sum of those two arguments, A and B.

10:41.960 --> 10:48.120
And I'm calling this function with two double arguments, 1.5 and 8.5.

10:48.120 --> 10:53.760
And obviously, any normal person would say that the sum of those two is 10.

10:53.760 --> 10:54.760
Who's for 10?

10:54.760 --> 10:59.440
As a result of what the function is going to print?

10:59.440 --> 11:01.320
Who's for 9?

11:01.320 --> 11:02.320
Majority.

11:02.320 --> 11:03.320
Great.

11:03.320 --> 11:04.320
I like it.

11:04.320 --> 11:07.800
It's going to print 9, you're absolutely right.

11:07.800 --> 11:13.600
Because if you don't tell what the argument type is, it's going to be an integer, right?

11:13.600 --> 11:18.720
Because in the old good type, times when C started to exist, there were only integers.

11:18.720 --> 11:20.440
So everything was an integer.

11:20.440 --> 11:23.520
Honestly, I'm on C23.

11:23.520 --> 11:24.520
It's undefined.

11:24.520 --> 11:28.800
Finally, it's undefined because it was a source of many errors.

11:28.800 --> 11:32.280
So it's illegal to do it anymore.

11:32.280 --> 11:34.280
Good things do happen.

11:34.280 --> 11:37.880
Now, that's one tricky.

11:37.880 --> 11:40.080
And the question is very easy.

11:40.080 --> 11:46.880
What's the value of number and what's its type?

11:46.880 --> 11:48.760
So it's just one line of code.

11:48.760 --> 11:52.800
It's don't overthink it, right?

11:52.800 --> 11:56.400
And as a hint, the literal is a floating point number.

11:56.400 --> 12:01.080
It's a float on the right-hand side, right?

12:01.080 --> 12:06.720
So you might think, well, it's a float because the right-hand side of the assignment is a

12:06.720 --> 12:08.120
float.

12:08.120 --> 12:12.280
And the other good hint or a good guess would be an integer.

12:12.280 --> 12:16.160
And it would be an integer because like on the previous slide, if you don't define the

12:16.160 --> 12:19.120
type, it's an integer, right?

12:19.120 --> 12:27.280
And you are right and right depending on which language version you are.

12:27.280 --> 12:37.840
If you are on anything below what happened last week, it's going to be 42 because it's

12:37.840 --> 12:39.600
an integer.

12:39.600 --> 12:46.560
Auto before last week meant automatic storage duration, nothing else.

12:46.560 --> 12:51.280
So you could have skipped it and it would mean like then, you know, it's an integer

12:51.280 --> 12:54.480
because obviously when you don't specify a type, it's an integer.

12:54.480 --> 13:00.400
Now you wouldn't believe it, but auto means the same now in C as it means in C++.

13:00.400 --> 13:02.600
It's for type inference.

13:02.600 --> 13:08.720
Actually, it has this kind of a dual life now in C23.

13:08.720 --> 13:14.120
It is for type inference or for storage duration specification.

13:14.120 --> 13:16.720
That's whether you put the type or not yourself.

13:16.720 --> 13:23.600
So if after the type I would put in, this auto would be specifying the storage duration.

13:23.600 --> 13:26.720
But because I didn't, it's for type inference.

13:26.720 --> 13:27.720
Next one.

13:27.720 --> 13:31.520
Well, this compile in C, okay, this doesn't make any sense now to us because I just showed

13:31.520 --> 13:39.200
you that it compiles in the first slide, but I asked this and there are two different

13:39.200 --> 13:40.200
answers to it.

13:40.200 --> 13:45.920
Either it will compile out of the box or you have to include something.

13:45.920 --> 13:50.440
Who's for including that you have to include some standard headers for it to compile?

13:50.440 --> 13:54.840
You are absolutely right.

13:54.840 --> 13:57.840
Because you didn't read what happened last week, right?

13:57.840 --> 14:04.760
When the bool and false became keywords in C also.

14:04.760 --> 14:11.200
So they also kind of do the same thing like C++, they like to do things slowly.

14:11.200 --> 14:18.560
They first standardized boolean with a totally weird notation underscore capital letter bool.

14:18.560 --> 14:22.560
And you could have the normal bool through a header inclusion that was, it was simply

14:22.560 --> 14:28.840
a type def inside and now it's standardized as a keyword.

14:28.840 --> 14:31.440
That one, I'm not going to retorture you with this one.

14:31.440 --> 14:34.720
I think it's fun.

14:34.720 --> 14:40.360
Unless you know what's happening there, I mean, what's the size of the numbers array

14:40.360 --> 14:43.760
and I don't want you really to count this one.

14:43.760 --> 14:48.760
Because if you count, I think you're around eight.

14:48.760 --> 14:51.920
So there are eight initializers listed there.

14:51.920 --> 14:55.040
But there are many other options there and the correct answer and we're going to talk

14:55.040 --> 14:58.880
about it is 12, which is not really apparent when you look at the list.

14:58.880 --> 15:00.680
There is no 12 anywhere.

15:00.680 --> 15:04.760
There are no 12 initializers, there is no index 11, nothing like this, right?

15:04.760 --> 15:08.920
So it's like, why?

15:08.920 --> 15:14.040
Because it's C and in C we like doing things our harmful way.

15:14.040 --> 15:18.560
So that's why.

15:18.560 --> 15:24.600
Next one, does anybody know actually what is the type of PK in line four?

15:24.600 --> 15:26.920
If you look at it.

15:26.920 --> 15:32.560
PK has a very specific type.

15:32.560 --> 15:41.320
I mean, you are kind of born when you're not born with knowledge of C, it's not that far.

15:41.320 --> 15:49.280
But we learn it when we learn C that pointers are pointers in C and a pointer is a pointer.

15:49.280 --> 15:55.960
You can cast it, it basically doesn't have any further meaning, doesn't come along with

15:55.960 --> 15:58.720
any further type specification, it's just a pointer.

15:58.720 --> 15:59.720
It's not true.

15:59.720 --> 16:05.280
This is a pointer to an array of 10 by 10 integers, exactly.

16:05.280 --> 16:09.680
It's a strongly typed pointer to an array, two dimensional error.

16:09.680 --> 16:15.880
And because of this, when I malloc it and use size of Asterix PK, I'm going to get

16:15.880 --> 16:20.200
enough storage for 100 integers.

16:20.200 --> 16:21.200
Is it integers?

16:21.200 --> 16:24.280
Yes, it is integers.

16:24.280 --> 16:30.040
So the answer is 400, at least on my platform.

16:30.040 --> 16:35.120
And I think we are almost at the end of the funny quiz.

16:35.120 --> 16:38.520
And the question is, is this program well-formed?

16:38.520 --> 16:43.560
And I'm not talking about intendation, it's cool.

16:43.560 --> 16:48.440
I'm talking whether it's going to compile, whether it's going to be accepted by a compiler.

16:48.440 --> 16:52.840
And there are a couple of answers, and you can raise your hand if you think that this

16:52.840 --> 16:55.600
answer sounds true.

16:55.600 --> 17:01.720
Like A is no, because line 11 is fishy.

17:01.720 --> 17:10.000
And line 11 is fishy, because it looks like, actually I don't know what I'm doing there.

17:10.000 --> 17:18.080
It looks like an array, I'm casting actually open curly braces to an array, right?

17:18.080 --> 17:21.160
That's what I'm doing.

17:21.160 --> 17:22.920
Who thinks this line is fishy?

17:22.920 --> 17:28.560
Yeah, it's definitely fishy, but it's not a problem.

17:28.560 --> 17:29.560
It compiles.

17:29.560 --> 17:36.640
The other answer is no, line 5, the address of a temporary is taken, or something that

17:36.640 --> 17:39.200
looks like a temporary.

17:39.200 --> 17:44.040
And I mean, the address is definitely taken in this line, but again, this is a perfectly

17:44.040 --> 17:46.240
fine C.

17:46.240 --> 17:50.360
An answer might be also no, there is no aggregate initialization or something like this, no,

17:50.360 --> 17:54.840
there isn't, but you can initialize with designated initializers.

17:54.840 --> 17:59.040
So this is a perfectly fine C, and it's going to compile.

17:59.040 --> 18:01.080
And it's even going to print something.

18:01.080 --> 18:05.200
I think it's going to print today on the screen.

18:05.200 --> 18:13.000
And last but not least, and that's a tricky one.

18:13.000 --> 18:15.640
What does this function accept?

18:15.640 --> 18:19.400
What kind of arguments does it accept?

18:19.400 --> 18:22.360
Because it accepts a very specific type of arguments.

18:22.360 --> 18:26.880
So this again, type safety, pointer safety, do you have an idea?

18:26.880 --> 18:36.560
C, this key, you're right, sorry, I first read D, which I also have an urge to actually

18:36.560 --> 18:43.160
directly look at, you're right, it accepts valid non-null pointers to con-scar.

18:43.160 --> 18:49.320
So it's a contract, it's basically your saying, it's a pointer to con-scar, and it

18:49.320 --> 18:51.600
has to be valid, it cannot be null.

18:51.600 --> 18:54.640
And you would be surprised, compilers check it.

18:54.640 --> 18:56.440
So that's this.

18:56.440 --> 19:03.400
And we are finally at the core of our talk.

19:03.400 --> 19:07.520
Go on, please.

19:07.520 --> 19:08.520
That one.

19:08.520 --> 19:09.520
I don't hear you.

19:09.520 --> 19:14.840
Is it also the case that the pointer was the pointer and it was the string?

19:14.840 --> 19:18.880
No, no, it's only checked whether it's null or not.

19:18.920 --> 19:23.440
So because it's a pointer, you can pass null, right, as an argument.

19:23.440 --> 19:27.880
So that's been checked, but yeah, it doesn't look into the string really.

19:27.880 --> 19:30.880
No, no, it's not that good.

19:30.880 --> 19:35.000
I mean, there is no runtime in C, there is assembly, right?

19:35.000 --> 19:36.000
So.

19:36.000 --> 19:51.400
Even if you pass an empty string, you still have the null terminator there, so officially

19:51.400 --> 19:54.600
it's valid, right?

19:54.600 --> 19:57.800
I'm sorry, but it's officially valid.

19:57.800 --> 19:59.520
This only checks for null and nothing else.

19:59.520 --> 20:02.200
So okay, let's go.

20:02.200 --> 20:03.200
Initialization.

20:03.440 --> 20:08.480
The first topic, an important topic, and I mean, the quiz was also partially about initialization,

20:08.480 --> 20:11.120
like you've seen lots of initializers.

20:11.120 --> 20:13.280
Have you ever seen code like this?

20:13.280 --> 20:14.600
Anybody?

20:14.600 --> 20:15.800
Raise your hands, please.

20:15.800 --> 20:20.680
All of you have seen this code because it comes from this book.

20:20.680 --> 20:24.400
You must have seen it.

20:24.400 --> 20:30.800
So this code attempts to initialize a structure, right, a structure of X and Y, a very simple

20:30.800 --> 20:32.240
one.

20:32.240 --> 20:34.200
And that's not how you write it nowadays.

20:34.200 --> 20:39.480
Nowadays, what you would do is, of course, use the brace initialization, like you would

20:39.480 --> 20:40.480
do it in C++.

20:40.480 --> 20:46.280
The only difference is you need that equality, you know, or an assignment in between.

20:46.280 --> 20:52.080
And that's how it works in up-to-date C. It exists in C. Brace initialization exists

20:52.080 --> 20:55.840
in C, and you can pretty much initialize everything like this.

20:55.840 --> 21:02.800
So, you know, like an array of undefined size, and then the size will be calculated from

21:02.800 --> 21:04.840
the initializers.

21:04.840 --> 21:12.320
You can initialize a list on an array, or an array with a defined size.

21:12.320 --> 21:14.480
You can initialize structures like this.

21:14.480 --> 21:15.480
No problems whatsoever.

21:15.480 --> 21:20.960
You can initialize pretty much everything with braces, just like basically aggregate

21:20.960 --> 21:26.800
initialization works in C++ for those of you who know what it is.

21:26.800 --> 21:30.280
But when I mean everything, I really mean everything.

21:30.280 --> 21:31.800
This is legal.

21:31.800 --> 21:38.040
Some people write it because then it's uniform, and it looks nice.

21:38.040 --> 21:39.960
And it scares people who don't understand.

21:39.960 --> 21:42.840
And that's also good, because you don't want people who don't understand your C code to

21:42.840 --> 21:46.160
touch your C code, right?

21:46.160 --> 21:49.760
So you put it there just to scare off people.

21:49.760 --> 21:52.160
That works.

21:52.160 --> 21:59.160
There is also something called empty initialization in C. It got a name, empty initialization

21:59.160 --> 22:03.840
a week ago, like a standardized name, before it was known under different names.

22:03.840 --> 22:07.800
Some people called it zero initialization, some default initialization.

22:07.800 --> 22:12.400
And basically the trick is you put a single zero in between the braces.

22:12.400 --> 22:13.400
Nothing else.

22:13.400 --> 22:18.720
This has the effect of zeroing everything, whatever is on the left-hand side.

22:18.720 --> 22:25.240
So if it's a value, or if it's an array, or if it's a structure, then recursively all

22:25.240 --> 22:28.200
the fields of the structure will be zeroed.

22:28.200 --> 22:33.120
Nulls will be actually zeros, like a null is a zero, or most of the architectures will

22:33.120 --> 22:39.640
be put where they should be put, and so on, and so on.

22:39.640 --> 22:45.000
It kind of got its name from this one.

22:45.000 --> 22:51.560
Because in C23 they removed the need for having a zero in between the braces, you can now

22:51.560 --> 22:55.360
skip the zero in between the braces, and it's still going to work.

22:55.360 --> 22:58.520
So that's where it comes from, the empty initialization.

22:58.520 --> 22:59.960
Now what are the rules?

22:59.960 --> 23:01.920
The rules are very simple.

23:01.920 --> 23:10.640
When you empty initialize something, like a structure, what happens is that all your

23:10.640 --> 23:14.920
fields in the structures are going to be zeroed, including the parting bytes.

23:14.920 --> 23:19.480
Not because they have to be zeroed, but that's because what the compilers will do anyway,

23:19.480 --> 23:20.480
and that's it.

23:20.480 --> 23:23.080
There is no magic in it.

23:23.080 --> 23:24.680
It also works for nested types.

23:24.680 --> 23:29.760
So if you have an array of structures or whatever, you can just zero it like this.

23:29.760 --> 23:30.760
It's great.

23:30.760 --> 23:31.760
Right?

23:31.760 --> 23:35.560
You don't have to use memset all of a sudden, and we are used to use memset.

23:35.560 --> 23:40.600
I mean, at least I was used to use memset at all a lot when I was programming C.

23:40.600 --> 23:44.200
So we just put zero there.

23:44.200 --> 23:46.280
Now what if you don't want a zero?

23:46.280 --> 23:53.080
What if you want different values, like, for example, you have a bigger structure with

23:53.080 --> 24:00.320
five fields, and two of them should have some values, and the rest should be zeroed?

24:00.320 --> 24:02.120
Because why not?

24:02.120 --> 24:05.720
And then you might think, okay, what's my idea here?

24:05.720 --> 24:11.400
I might zero first the whole structure, then set the fields, and so on, or do something

24:11.400 --> 24:16.360
crazy like this, right, when you use the brace initialization and list all the members one

24:16.360 --> 24:21.080
after another at the right positions and initialize with zero what needs to be initialized with

24:21.080 --> 24:22.080
zeros.

24:22.080 --> 24:27.960
Luckily, this is not the way, because there are designated initializers in C, just like

24:27.960 --> 24:31.680
they're in C++, and they have the same exactly syntax.

24:31.680 --> 24:38.920
So there is a dot, then the designator, then the equality symbol, and then the value you

24:38.920 --> 24:44.480
initialize the designated field with.

24:44.480 --> 24:50.960
This has the same effect as in C++, almost the same, because we don't have default initialization

24:50.960 --> 24:52.460
here.

24:52.460 --> 24:58.120
It zeros all the fields that are not explicitly initialized.

24:58.120 --> 25:03.520
So those that you explicitly initialize with your designators are going to get the values,

25:03.520 --> 25:07.480
the rest is going to be zeroed, which is great, because very often it happens, and especially

25:07.480 --> 25:13.780
if you program in C, in C, people work with all fully long structures that have, I don't

25:13.780 --> 25:18.280
know if you've ever looked, for example, how file is implemented, how many different fields

25:18.280 --> 25:19.280
it has.

25:19.280 --> 25:20.280
It's horrible.

25:20.280 --> 25:23.120
Most of them are usually zero.

25:23.120 --> 25:25.120
So that's great.

25:25.120 --> 25:30.200
Now what's not so great, or actually maybe what's great, because C gives you all the

25:30.200 --> 25:38.360
powers there is, there are in this world, so what's great, you can mix the positions

25:38.360 --> 25:40.160
when you're designated initializer.

25:40.160 --> 25:44.480
So you're not necessarily bound to the order of declaration, as you are in C++.

25:44.480 --> 25:48.440
For C++, it's going to be a hard compilation error if you try something like this.

25:48.440 --> 25:52.320
See, no problems whatsoever, mix them.

25:52.320 --> 25:59.920
What's even, now I struggle to say it's better.

25:59.920 --> 26:09.960
What's even cooler is that you can mix positional and designated initializer, something that's

26:09.960 --> 26:12.240
also forbidden in C++.

26:12.240 --> 26:13.440
You can freely mix them.

26:13.440 --> 26:19.800
You've seen it already when I was asking about the size of an array with really weird indices.

26:19.800 --> 26:25.840
This is a mix of designated and positional initializers, two positional initializers,

26:25.840 --> 26:30.800
the first one and the last one and two designated, but you have to be careful about what you're

26:30.800 --> 26:39.120
doing and how you're doing it, because you have to understand how the logic works behind

26:39.120 --> 26:41.840
the initializations order then.

26:41.840 --> 26:43.200
The first one is quite easy.

26:43.200 --> 26:48.160
It's a positional initializer and it goes into the first field.

26:48.160 --> 26:51.400
Then we have a designator status.

26:51.400 --> 26:56.120
It names the last field in the structure, so the status is going to end up there.

26:56.120 --> 27:02.200
Then we have another designator flex and it fits in there.

27:02.200 --> 27:07.640
Last but not least, we have one more positional initializer with no designator.

27:07.640 --> 27:15.200
It's going to end up directly after the flex and the reason for it, whenever you have a

27:15.200 --> 27:21.040
designator in your initializer list, the counting for the next positional initializer

27:21.040 --> 27:25.600
starts from this designator.

27:25.600 --> 27:31.240
You have to know what you're doing, but that's great and of course the rest is zero.

27:31.240 --> 27:36.600
If you know what you're doing, it's going to work nevertheless.

27:36.600 --> 27:43.520
You can nest initializations just like you can do it in C++.

27:43.520 --> 27:52.440
You can nest them, I mean, the designators and initializers for sub-objects.

27:52.440 --> 27:54.880
Also with designators, no problems whatsoever.

27:54.880 --> 28:01.600
You can even do crazy things like this, dot-flux, dot-extended, dot-extended designates a field

28:01.600 --> 28:04.040
of a sub-object of the structure.

28:04.040 --> 28:06.200
This is also not allowed in C++.

28:06.200 --> 28:08.720
You cannot nest in C++ like this.

28:08.720 --> 28:11.160
In C, it is allowed.

28:11.160 --> 28:17.400
Now, this is also a funny thing and it's funny because I don't know really what's

28:17.400 --> 28:19.760
the use for it.

28:19.760 --> 28:26.640
I mean, I only know one use that I came up with when I was working on it once and it's

28:26.640 --> 28:30.880
not even a good use, so I'm not going to mention.

28:31.080 --> 28:33.360
No, okay.

28:33.360 --> 28:36.600
You can use designators for arrays.

28:36.600 --> 28:42.400
It's absolutely fine and this works the same way as for structures.

28:42.400 --> 28:49.480
The designator designates a field or actually the subscript that you're going to initialize

28:49.480 --> 28:51.160
with a value.

28:51.160 --> 28:54.200
This is like an array of 42 numbers.

28:54.200 --> 28:57.880
Three of them are going to be initialized with certain values.

28:57.880 --> 29:00.760
This is a Fibonacci sequence, roughly.

29:00.760 --> 29:05.200
That's a Fibonacci sequence, part of it.

29:05.200 --> 29:07.920
The rest is going to be zeroed.

29:07.920 --> 29:17.160
The rest of the numbers are going to be zeroed in this array, all of 99 of them, which might

29:17.160 --> 29:20.200
be useful, might not be.

29:20.200 --> 29:23.120
The same craziness applies as instructors.

29:23.120 --> 29:26.680
You can mix the order, whatever you want.

29:26.680 --> 29:34.320
You can mix positional initializers with designated initializers and, again, the same rules apply

29:34.320 --> 29:35.320
as before.

29:35.320 --> 29:43.960
If you have the designator, the index of the following positional initializers is counted

29:43.960 --> 29:45.880
from this designator.

29:45.880 --> 29:51.400
There is a designator 10 at the second position here, which means that 89 is going to end

29:51.400 --> 29:55.000
up at index 11.

29:55.000 --> 30:00.800
Because it's going to end up at index 11, there is nothing actually more to talk about,

30:00.800 --> 30:05.560
but there is something to talk about here, because this is going to end up at index 11.

30:05.560 --> 30:11.480
This array has a size of 12, because this is the highest index in the initializer list.

30:11.480 --> 30:13.240
But this is crazy.

30:13.240 --> 30:15.280
Things like this shouldn't be allowed.

30:15.280 --> 30:19.000
Neither should be this, but it's there.

30:19.000 --> 30:23.200
If you look at this, this is fine.

30:23.200 --> 30:27.120
I mean, it's not fine, but you can do it.

30:27.120 --> 30:34.640
You can have an array of structures, for example, and designate or initialize one of the fields

30:34.640 --> 30:37.680
of those structures at a specific index of the array.

30:37.680 --> 30:40.680
It's going to work out of the box.

30:40.680 --> 30:47.600
The syntax, especially at the multiple level of nesting, looks really ... You cannot comprehend

30:47.600 --> 30:50.120
it anymore, I think, at one moment or another.

30:50.120 --> 30:51.120
It works, nevertheless.

30:51.400 --> 30:52.400
So that's it.

30:52.400 --> 30:54.560
That's the initialization.

30:54.560 --> 30:57.280
That's how we initialize everything in modern C, believe me.

30:57.280 --> 30:58.280
People really do it.

30:58.280 --> 31:02.560
They use curly braces even for numbers, and there are no restrictions.

31:02.560 --> 31:05.560
In C++, they have a lot of restrictions for it.

31:05.560 --> 31:10.040
In C, there are none whatsoever, so you can do ... You can really confuse your colleagues

31:10.040 --> 31:11.040
if you want to.

31:11.040 --> 31:16.000
Now, and since we are talking about arrays, and there is one very popular topic when it

31:16.000 --> 31:21.600
comes to arrays, we are going to discuss it.

31:21.600 --> 31:26.120
Generally speaking, as all of you know, there are two types of arrays in this world.

31:26.120 --> 31:32.520
You can have either an array with a static known size, constants known size, and that's

31:32.520 --> 31:36.640
your good old array, as on the left-hand side, or you can have an array that you allocate

31:36.640 --> 31:40.320
dynamically on the heap, and that's something like a runtime thing.

31:40.320 --> 31:47.120
So during the runtime, you can come up with a value for the size of your array and allocate

31:47.120 --> 31:49.240
it.

31:49.240 --> 31:53.600
It's much better today like this because this size should be somewhere close to your numbers

31:53.600 --> 31:56.240
definition to the array definition.

31:56.240 --> 31:59.520
Nobody people don't put defines, hash define, within the function.

31:59.520 --> 32:03.040
They can, but nobody dares to, for some reasons.

32:03.040 --> 32:06.400
They put it somewhere outside, and then you don't know what the size of the array is,

32:06.720 --> 32:10.480
but with Consexper, it's just more natural to put it next to the array, right?

32:10.480 --> 32:11.760
So you can do it now.

32:11.760 --> 32:13.360
Anyways, back to the arrays.

32:14.560 --> 32:20.480
Question, is a lot a constant integral expression?

32:21.680 --> 32:24.720
Who's for it that it's a constant integral expression?

32:27.120 --> 32:29.680
Some people have doubts.

32:29.680 --> 32:31.840
Who's against it, like totally against?

32:33.840 --> 32:34.880
Nobody has doubts.

32:35.840 --> 32:37.120
That's also fine.

32:38.320 --> 32:39.040
It depends.

32:39.040 --> 32:43.200
If you're coming from C++, obviously it's a constant integral expression in C0.

32:43.200 --> 32:47.760
C, no, sorry, that's why we use defines in C, right?

32:47.760 --> 32:50.320
Because we like to confuse people.

32:51.600 --> 32:56.960
This is not a constant integral expression, so you cannot use it to define an array with

32:56.960 --> 32:58.640
a constant known size.

32:58.640 --> 32:59.920
It's illegal.

33:01.360 --> 33:03.280
However, this code does compile.

33:05.520 --> 33:09.760
It compiles, and many people hate it, that it compiles.

33:10.560 --> 33:14.160
And we're going to talk about why they hate it in a moment.

33:14.160 --> 33:19.760
What it really declares or defines is a so-called variable length array.

33:20.800 --> 33:28.480
It's an array whose size is determined at the runtime, and usually it's allocated on the stack

33:28.480 --> 33:29.360
by the compiler.

33:30.320 --> 33:33.200
Like allocated on the stack during the runtime.

33:33.200 --> 33:41.440
That means also calculating the size, calculating the register shift, the RSP register shift,

33:42.320 --> 33:44.080
and manipulating it at the runtime.

33:44.720 --> 33:49.360
So this creates an array with an unknown size, or actually not with a well-known size

33:49.360 --> 33:50.960
during the runtime, on the stack.

33:51.440 --> 33:54.080
And you can only do it within a block scope.

33:54.640 --> 33:56.560
And the reason is quite obvious.

33:56.800 --> 34:00.880
I mean, at the file scope, you don't have really a stack there.

34:00.880 --> 34:02.800
So how do you declare an array there?

34:03.840 --> 34:07.680
It's not really standardized that it does have to be on the stack, but all the compilers

34:07.680 --> 34:08.400
do it on the stack.

34:09.120 --> 34:11.120
C++ doesn't have this feature.

34:11.120 --> 34:14.560
And for a reason, because there was a big discussion when they introduced it, it will

34:14.560 --> 34:16.720
see also whether it's even needed.

34:16.720 --> 34:20.960
And many people said that it's not needed.

34:20.960 --> 34:26.400
I also said before that you can initialize everything with curly braces.

34:26.400 --> 34:27.840
Well, not this one.

34:27.840 --> 34:29.360
This is the only exception.

34:29.360 --> 34:30.240
You cannot.

34:30.240 --> 34:32.720
You have to initialize it element by element.

34:33.600 --> 34:35.600
Anyways, as I said, some people hate it.

34:36.480 --> 34:39.360
And they hate it with passion.

34:41.840 --> 34:47.360
Like Linus said, that using VLS is actively stupid.

34:48.960 --> 34:54.400
And for many reasons, and many other people in the community actually repeat the same

34:54.480 --> 34:57.040
thing that is actively stupid to do it.

34:57.040 --> 34:58.960
Nowadays, nobody's using VLS.

34:59.600 --> 35:00.880
And that's not a joke.

35:00.880 --> 35:05.600
I mean, students sometimes use it because they don't know that it's a bad code.

35:06.160 --> 35:07.760
But otherwise, nobody's using it.

35:07.760 --> 35:09.120
Why they don't use it?

35:09.120 --> 35:11.920
Well, it's an array on the stack.

35:11.920 --> 35:13.600
You know what's the problem with the stack?

35:13.600 --> 35:18.960
Depending on your architecture, the stack is maybe four kilobytes or maybe eight megabytes

35:18.960 --> 35:19.680
if you're lucky.

35:20.640 --> 35:25.680
So when you declare an array or define an array with a size that's going to be determined

35:25.680 --> 35:29.200
during the runtime, you definitely have to check whether it will fit on the stack.

35:29.840 --> 35:33.120
Otherwise, you're going to blow up the stack and your program will crash.

35:33.680 --> 35:39.600
So you must build in this check somewhere before this array even comes to being.

35:39.600 --> 35:41.360
Otherwise, you are in danger zone.

35:42.080 --> 35:45.120
And only then you can do your array thingy.

35:45.760 --> 35:49.200
So the question is, why would you do it anyway this way?

35:50.000 --> 35:55.040
I mean, isn't it just better to have directly the array with the myAllowedSize

35:55.920 --> 35:58.400
and it will fit everything I need anyway?

35:59.280 --> 36:01.040
So just do it like this, right?

36:01.920 --> 36:03.120
And then this.

36:03.760 --> 36:05.440
And I still have to check, obviously.

36:06.400 --> 36:10.560
But now I have an array with a constant known size.

36:10.560 --> 36:12.320
The compiler can see it upfront.

36:12.320 --> 36:13.680
It can optimize for it.

36:13.680 --> 36:14.240
So why?

36:15.440 --> 36:18.240
What's even worse, if you look at the...

36:18.240 --> 36:20.960
It's the same code as before, just without the stack check.

36:20.960 --> 36:24.720
And I'm doing now the n of size 10 on the left-hand side.

36:24.720 --> 36:26.640
It's a variable length array on the right-hand side.

36:26.640 --> 36:28.480
It's an array with a constant known size.

36:29.760 --> 36:31.520
It generates much worse code.

36:32.240 --> 36:35.360
The VLA variant is much bigger in the assembly

36:35.920 --> 36:38.800
because these calculations have to be done at the runtime.

36:38.800 --> 36:40.240
So you have to calculate the shift.

36:40.240 --> 36:43.840
You have to move the RSP by certain size.

36:43.840 --> 36:46.880
Whereas on the right side, on the right-hand side,

36:46.880 --> 36:51.200
the compiler knows it has to shift the stack pointer by 40 bytes

36:51.200 --> 36:52.080
and it's done.

36:52.880 --> 36:53.760
So it's bad.

36:53.760 --> 36:55.920
It's actively bad.

36:55.920 --> 36:59.600
I'm not going to say stupid, but it's actively bad to do it.

36:59.600 --> 37:00.720
Don't do it.

37:00.720 --> 37:04.240
Now, if you shouldn't do it, then why am I talking about it?

37:05.440 --> 37:06.880
Unless you are, of course, a teacher

37:06.880 --> 37:08.480
because then you are going to see students do it

37:09.360 --> 37:10.720
and you have to correct them.

37:10.720 --> 37:13.440
The reason is VLAs are used for other things.

37:13.440 --> 37:16.960
And some people argue this is the primary reason

37:16.960 --> 37:18.960
why VLAs are in the language.

37:18.960 --> 37:23.120
They are not for having stack arrays with variable length.

37:23.120 --> 37:27.040
They are for doing things like they're going to witness in a moment.

37:27.920 --> 37:31.120
This is a function that takes an array of numbers

37:32.240 --> 37:34.880
by a pointer and the size of the numbers

37:34.880 --> 37:36.240
and does nothing special really.

37:36.800 --> 37:39.760
Now, if you have code like this,

37:39.760 --> 37:44.320
you can also write the argument a bit differently.

37:45.760 --> 37:48.960
You can write the argument as the second parameter

37:48.960 --> 37:53.280
or the second parameter being an array of type int

37:53.280 --> 37:55.440
with n elements inside.

37:56.080 --> 37:58.080
And this does something different.

37:58.080 --> 38:01.200
This communicates your intent all of a sudden.

38:01.760 --> 38:06.160
You say exactly that it must be an array of n elements

38:06.160 --> 38:09.040
and there must be enough storage for those n elements.

38:09.120 --> 38:11.440
The previous one didn't communicate it.

38:12.880 --> 38:16.960
The trick is size has to come before the array

38:16.960 --> 38:18.000
otherwise it's not going to work.

38:18.000 --> 38:19.760
Right? Now, why would you do it?

38:19.760 --> 38:24.560
I mean, you can do it for arrays with known size like that one

38:24.560 --> 38:28.320
an array of five elements and it's going to compile just fine.

38:29.120 --> 38:34.720
Or you can do very nasty things like a hidden bug there

38:34.720 --> 38:37.040
when I'm trying to pass an array of five elements

38:37.040 --> 38:42.640
and pretending it has six elements which is bad, actively bad,

38:43.760 --> 38:46.960
and your compiler will tell you that you are doing something bad.

38:47.520 --> 38:51.440
Compilers do detect those errors if you pass arguments

38:51.440 --> 38:53.040
using the VLA syntax.

38:53.040 --> 38:54.160
At least GCC does.

38:55.040 --> 38:56.960
Clank doesn't really want to do it.

38:57.600 --> 38:59.440
Sometimes it does but not in this case.

39:00.720 --> 39:05.600
Surprisingly, it even works for dynamically allocated arrays.

39:05.600 --> 39:09.360
If you try to pretend that a dynamically allocated array

39:09.360 --> 39:12.240
is bigger than it is, GCC will warn you

39:12.240 --> 39:14.000
with a string operation overflow.

39:15.280 --> 39:17.760
Apparently, it is a string operation what we are doing.

39:18.880 --> 39:21.360
Nevertheless, this is great, right?

39:21.360 --> 39:22.560
It warns you.

39:22.560 --> 39:24.480
And since we are already talking about arrays

39:25.360 --> 39:33.280
and we are all kind of educated in the way that arrays decay

39:33.280 --> 39:37.440
to pointers, unless there are three specific scenarios when they don't,

39:38.640 --> 39:42.480
let's talk about more about how you pass arguments in modern C

39:42.480 --> 39:46.720
and specifically how you pass pointers in modern C to functions.

39:47.600 --> 39:49.840
There are four different scenarios that you can cover

39:50.560 --> 39:54.320
when you think about how you pass pointers in C.

39:55.120 --> 39:59.760
The first one or the first ones are about arrays.

39:59.760 --> 40:02.960
The two second ones are about single objects.

40:03.440 --> 40:05.920
Imagine you are passing an array of n objects

40:06.560 --> 40:10.080
and you have enough storage for n objects

40:10.080 --> 40:13.040
but not necessarily valid objects in this array.

40:13.040 --> 40:16.800
What you're going to do then is use the syntax that I just showed you.

40:16.800 --> 40:20.960
It works and the compilers will check it most often.

40:22.320 --> 40:27.760
So in this case, it's a buffer of n characters uninitialized

40:27.760 --> 40:29.120
and I'm never reading from it.

40:29.120 --> 40:33.360
I'm actually initializing it or putting values into this buffer

40:33.360 --> 40:34.880
but I have enough storage.

40:34.880 --> 40:35.840
That's great.

40:35.840 --> 40:41.280
Now another scenario, if it's an array with enough storage for n objects

40:42.240 --> 40:45.840
and it must contain n valid objects.

40:45.840 --> 40:47.760
That's like a hard requirement.

40:47.760 --> 40:49.760
There are n valid objects inside.

40:50.400 --> 40:56.400
There is this syntax that you guessed correctly for something different.

40:57.360 --> 41:03.840
You use the keyword static before you mentioned the size.

41:05.040 --> 41:08.880
It's been there since C11 if I'm not mistaken

41:10.000 --> 41:12.160
and it means something special.

41:12.960 --> 41:15.680
It basically means that those objects do have exist.

41:15.680 --> 41:17.840
It's illegal not to have objects there

41:17.840 --> 41:23.760
and some compilers are able to check not everything but some parts of it

41:23.760 --> 41:26.080
but it clearly communicates the intent at least.

41:26.960 --> 41:28.880
So static communicates the intent.

41:29.920 --> 41:34.480
When it's a single object and it can be a null pointer,

41:34.480 --> 41:36.880
well, you do it the old way, right?

41:36.880 --> 41:38.640
There is nothing special about it.

41:38.640 --> 41:43.520
You are responsible for checking it if it works or if it doesn't work.

41:43.520 --> 41:48.080
Now the last one is actually the one that we already showed during the quiz

41:48.080 --> 41:50.000
or I already showed during the quiz.

41:50.000 --> 41:53.280
If you're passing a pointer and it mustn't be null,

41:53.280 --> 41:58.800
it's illegal that it's a null pointer than you use static one.

41:58.800 --> 42:01.680
It's a very common thing, especially static one,

42:02.400 --> 42:08.400
somehow managed to permeate into the code, into the live code.

42:08.400 --> 42:11.440
People use it because compilers check it and enforce it.

42:16.400 --> 42:21.120
So use it and for a proof that compilers check it and enforce it,

42:22.080 --> 42:26.080
especially when you use the static keyword, look at this piece of the code,

42:27.520 --> 42:32.800
it basically tells that there is a function that takes an array of three doubles

42:32.800 --> 42:34.400
and those doubles must exist.

42:35.920 --> 42:39.280
And I'm trying to call this function with a dynamically created array

42:40.240 --> 42:43.760
and notice that I'm totally not saying, I mean,

42:43.760 --> 42:47.520
I'm not passing the size of the array here as an argument

42:47.520 --> 42:50.480
and I'm trying to do it as statically created array.

42:52.000 --> 42:58.400
This GCC triggers an error for both of them.

42:59.200 --> 43:03.040
GCC, without even the static analyzer that it has built in,

43:03.040 --> 43:05.840
is able to see that you're doing something very bad

43:05.840 --> 43:08.160
and it will gonna tell you this time with, again,

43:08.160 --> 43:09.680
with string operation overflow.

43:11.120 --> 43:18.400
The first one with the static array also triggers an error on the clunk compiler.

43:18.400 --> 43:20.080
So that's very good.

43:20.080 --> 43:24.640
That protects you against very stupid mistakes that we often do,

43:24.640 --> 43:26.880
you know, buffer overflows do happen.

43:27.680 --> 43:30.640
Like there are single most important point of failure,

43:31.760 --> 43:34.480
I mean, in all the spaceships that went down, right?

43:36.720 --> 43:38.400
So do it.

43:39.760 --> 43:45.680
It also works amazingly well for this kind of syntax,

43:45.680 --> 43:50.960
which I said that protects you against passing a single null pointer

43:50.960 --> 43:52.640
when you don't expect a null pointer.

43:53.280 --> 43:56.240
And when you try to do something like this,

43:56.240 --> 43:58.240
GCC will again emit an error.

43:58.240 --> 44:00.400
And I think clunk also now emits an error.

44:00.400 --> 44:05.520
So that's the summary of how you pass arguments in modern C.

44:06.720 --> 44:10.800
Use the row pointer only if you're expecting one object

44:12.560 --> 44:14.800
and only if it can be null.

44:14.800 --> 44:18.720
Otherwise use the VLA notation sometimes with the static keyword

44:19.280 --> 44:23.360
if you expect invalid objects to be in the array.

44:23.360 --> 44:25.040
Compilers do enforce it.

44:25.040 --> 44:27.280
Lots of modern C code is written like this.

44:27.840 --> 44:32.080
And obviously it's not supported in C++, the static notation,

44:32.080 --> 44:36.160
and the VLA syntax also not really there because it's a part of the VLA.

44:36.800 --> 44:40.640
And since we are at the VLA's and there was, I asked this question before,

44:41.600 --> 44:45.760
or I was talking about a PK pointer somewhere in the beginning of the talk.

44:47.360 --> 44:49.840
As you can see, it's a two-dimensional array.

44:49.840 --> 44:50.480
It's a beast.

44:51.360 --> 44:53.520
It's a beast, it's a Gaussian filter.

44:53.520 --> 44:56.080
It's a kernel of the Gaussian filter if I'm not mistaken.

44:58.400 --> 45:04.160
It's a beast and it's a beast because multi-dimensional arrays in C and C++

45:04.160 --> 45:05.600
are horrible to work with.

45:06.320 --> 45:08.400
So that's like a five by five array.

45:08.400 --> 45:09.600
The size doesn't matter.

45:10.560 --> 45:14.320
What's horrible about it is not what you see on the screen.

45:15.440 --> 45:17.200
It's what you see now on the screen.

45:17.760 --> 45:20.800
Maloching this or allocating this array is still okay.

45:20.800 --> 45:24.560
And by the way, notice that I'm also using the VLA syntax

45:25.840 --> 45:27.680
with the size of operator.

45:27.680 --> 45:28.880
This is also valid.

45:28.880 --> 45:30.880
You can do something like this for the size of,

45:30.880 --> 45:33.920
which greatly simplifies size-offing for your malochs.

45:36.160 --> 45:38.080
And then when you index into this array,

45:40.000 --> 45:42.400
I don't understand it now, right?

45:42.400 --> 45:45.040
What I've done before, and I always have to look it up.

45:46.160 --> 45:49.040
And nowadays, people use strategy-tp for these kind of things

45:49.040 --> 45:51.040
before it was stuck overflow.

45:51.040 --> 45:53.600
And I'm not joking because it's unclear.

45:53.600 --> 45:56.720
You have to remember like what's, I mean,

45:56.720 --> 46:00.400
how is the data laid off in the multi-dimensional array

46:00.400 --> 46:01.680
to be able to do this magic.

46:03.200 --> 46:08.080
So what we really want is something like pk

46:08.160 --> 46:10.240
and then a first index, second index.

46:10.240 --> 46:13.280
What we get is, yeah, is this.

46:15.120 --> 46:18.720
Luckily, the VLA syntax does this for you.

46:19.280 --> 46:22.960
When you use VLAs with strongly typed arrays,

46:22.960 --> 46:25.280
you can achieve this because, you know,

46:25.280 --> 46:29.200
VLAs don't only extend to declaring parameters

46:29.200 --> 46:33.520
or to having stuck arrays.

46:33.600 --> 46:39.120
They're also for declaring strong array types.

46:40.160 --> 46:42.880
For those of you who are not fresh with the pointers,

46:44.560 --> 46:47.520
like I wasn't, for example, when I was preparing this talk,

46:49.760 --> 46:53.200
the pk is a pointer to an array of doubles,

46:53.200 --> 46:56.080
to actually two-dimensional array of doubles

46:56.080 --> 46:59.760
with the size as Z as Z, whatever the as Z is.

46:59.760 --> 47:01.680
Because it's a VLA, so it doesn't matter.

47:01.760 --> 47:04.400
It's determined at the runtime.

47:05.440 --> 47:06.640
It's strongly typed.

47:07.200 --> 47:11.040
And that sense that if you try to do something with this,

47:11.040 --> 47:13.040
that's not allowed, like pass it to a function

47:13.040 --> 47:15.680
that accepts a single double pointer,

47:15.680 --> 47:16.800
it's not going to compile even.

47:17.840 --> 47:20.080
And when you use it, all of a sudden,

47:20.080 --> 47:22.080
this kind of syntax becomes possible.

47:23.280 --> 47:24.640
So it's much better.

47:24.640 --> 47:27.200
It's a huge improvement because you can now index

47:27.200 --> 47:29.680
into your multi-dimensional array with this.

47:29.680 --> 47:32.320
Compiler knows it's a pointer to a 2D array,

47:32.320 --> 47:34.000
so it can index into it properly

47:34.000 --> 47:37.520
and translate into the pointer operations.

47:38.080 --> 47:42.080
What's even better, if you don't like the currently,

47:42.080 --> 47:45.280
the brackets Asterix pk, you can also do it like this.

47:46.800 --> 47:48.080
This is a bit of a cheating

47:48.080 --> 47:50.640
because I gave up a bit of a type safety,

47:51.520 --> 47:53.520
because it looks like I'm now allocking,

47:54.480 --> 47:58.480
like an array, a one-dimensional array,

47:59.280 --> 48:03.280
not really doing it, but this allows for this beautiful syntax.

48:04.800 --> 48:11.040
And if you don't like pk, so that's what you do.

48:12.080 --> 48:14.560
If you really fell in love with the VLA syntax,

48:15.920 --> 48:18.960
notice that what I'm doing here on the right-hand side

48:18.960 --> 48:21.280
of the malloc, it's not really cool, right?

48:21.360 --> 48:24.240
I'm doing something like size of pk multiplied by size

48:24.240 --> 48:25.840
and it's going to work correctly.

48:25.840 --> 48:27.600
It's going to allocate the correct number of bytes,

48:28.640 --> 48:30.640
but some people don't like it.

48:30.640 --> 48:32.720
They say that it shouldn't be like this

48:33.840 --> 48:35.680
and that you should use the VLA syntax

48:35.680 --> 48:37.520
for your size of operators also

48:37.520 --> 48:40.640
because it's much cleaner and it communicates the intent better

48:41.360 --> 48:43.200
and you cannot make so many errors.

48:43.200 --> 48:46.720
So if you just fell in love with the VLA syntax

48:46.720 --> 48:50.720
and you want to show off, you can do it also.

48:51.280 --> 48:52.560
Using a type of operator.

48:55.280 --> 48:58.000
Because the type of the pk pointer,

48:58.000 --> 49:01.760
the reference is the array of doubles of size size

49:02.960 --> 49:06.720
and then there is another size then

49:06.720 --> 49:09.600
and together they make a multi-dimensional array.

49:10.160 --> 49:12.960
Think about type of a set decal type here.

49:12.960 --> 49:15.120
So it works in exactly the same way.

49:15.120 --> 49:20.880
So we just declare a type of an array of doubles of size as Z.

49:21.760 --> 49:23.600
And you can combine it with index 10,

49:23.600 --> 49:26.400
which is like, whoa, why?

49:27.280 --> 49:29.520
I was pretty shocked when I discovered this.

49:32.080 --> 49:35.360
Yeah, and since we are in C plus C23,

49:35.360 --> 49:36.800
there is an old pointer obviously.

49:38.320 --> 49:43.120
Anyways, that's the initialization and the arrays.

49:43.120 --> 49:45.680
And now we're coming to the worst part of the talk

49:45.680 --> 49:47.840
because it's the most difficult part of the talk.

49:47.840 --> 49:48.800
Actually, it's not difficult.

49:48.800 --> 49:52.560
It's a bit of a crazy part of the talk.

49:52.560 --> 49:54.800
It's going to be about zero increase assigning

49:54.800 --> 49:59.200
and disappearing L values or whatever you call them.

50:01.520 --> 50:03.040
You remember this slide, right?

50:03.040 --> 50:04.880
This was somewhere at the beginning of the talk

50:04.880 --> 50:07.040
when I talked about the old C initialization

50:07.040 --> 50:09.520
and the new C initialization syntax.

50:09.520 --> 50:11.280
And I said, this is up to date C.

50:11.920 --> 50:13.200
I lied, of course.

50:13.200 --> 50:14.800
This is not an up to date C.

50:14.800 --> 50:18.480
Nobody writes code like this unless you are born

50:18.480 --> 50:21.040
in, yeah, in 2011.

50:21.920 --> 50:23.280
I don't think those people write C.

50:24.400 --> 50:25.040
Might, though.

50:25.040 --> 50:25.600
You never know.

50:26.400 --> 50:29.280
So you don't write this kind of code anymore.

50:30.160 --> 50:31.120
It's not up to date.

50:31.120 --> 50:32.480
It's modestly up to date C.

50:33.520 --> 50:36.240
What you do nowadays is something like this.

50:37.760 --> 50:41.520
You return these things that looks like casting.

50:42.400 --> 50:44.560
And then there is the initializer list

50:45.440 --> 50:47.680
with designated initializers inside.

50:47.680 --> 50:49.760
Now, this has a name.

50:49.760 --> 50:51.120
It's a compound literal.

50:52.800 --> 50:55.040
And this is something that exists only in C.

50:56.880 --> 51:03.200
It has a very simple syntax type in the normal brackets

51:03.200 --> 51:05.840
followed by the initializer in the curly braces.

51:05.840 --> 51:07.920
The initializer is not optional.

51:07.920 --> 51:09.040
You have to put it there.

51:10.320 --> 51:14.240
And it creates an unnamed object.

51:15.200 --> 51:16.480
It's really created.

51:17.760 --> 51:18.320
It exists.

51:19.200 --> 51:22.880
This object has different storage duration.

51:22.880 --> 51:25.040
It can have a static storage duration

51:25.760 --> 51:27.440
if you declare it at the block scope.

51:27.440 --> 51:31.440
For example, I am declaring a not at the block scope,

51:31.440 --> 51:32.800
sorry, the file scope.

51:32.800 --> 51:36.560
I am declaring at the file scope an array of doubles

51:37.760 --> 51:40.240
that doesn't have any name, but I'm assigning it

51:41.760 --> 51:44.320
to a variable of default coefficients.

51:44.320 --> 51:45.760
And it's there.

51:45.760 --> 51:49.760
It's going to exist throughout the duration of your program.

51:49.760 --> 51:53.360
Or you can do automatic storage if it's in the block scope.

51:54.240 --> 51:57.280
And here it is, I'm declaring a structure

51:57.280 --> 51:59.040
or actually I'm assigning to a structure

52:00.560 --> 52:02.160
with some new values.

52:02.160 --> 52:06.240
So I'm using, you know, I have already a fear for structure

52:07.840 --> 52:11.280
and I'm putting a new value into it with the assignment

52:12.400 --> 52:15.600
with some other initializers and so on.

52:15.600 --> 52:17.680
So two different storage locations

52:17.680 --> 52:20.400
and where the object is created as,

52:20.400 --> 52:24.880
like for any other object, if it's a static storage duration,

52:25.680 --> 52:27.360
it's somewhere in the global memory.

52:27.360 --> 52:30.160
So my coefficients are in the global memory.

52:30.160 --> 52:36.080
And my object on the right have some side of the assignment

52:36.080 --> 52:38.320
because this is what we are talking about.

52:38.320 --> 52:41.760
We are not talking about the fear if I are variable.

52:41.760 --> 52:44.320
We are talking about what's on the right hand side

52:44.400 --> 52:51.280
is going to be allocated on the stack for a moment,

52:51.280 --> 52:52.880
at least for the duration of this line.

52:54.640 --> 52:57.040
The unnamed object is an L value.

52:57.680 --> 53:00.960
And for those of you who know a bit about value categories,

53:01.760 --> 53:04.480
it means many things like you can assign to it

53:07.120 --> 53:08.400
or you can take an address of it.

53:09.120 --> 53:10.240
It's fully legal.

53:10.240 --> 53:11.440
It exists.

53:11.440 --> 53:12.960
If it's declared in the block scope,

53:13.040 --> 53:16.000
it's going to exist throughout the duration of this block

53:16.000 --> 53:18.000
or the lifetime of this block.

53:18.000 --> 53:20.160
And you can legally take an address of it.

53:20.160 --> 53:22.880
And this allows for surprising applications like that one.

53:25.200 --> 53:29.120
Those of you who ever dealt with time

53:30.000 --> 53:33.440
are familiar with the normalizing function MakeTime,

53:33.440 --> 53:36.080
which normalizes the TM structure.

53:37.600 --> 53:39.040
You can normalize like this now

53:40.000 --> 53:43.360
and get the Unix time out of it.

53:44.240 --> 53:46.720
Cool thing if you ask me.

53:46.720 --> 53:50.000
Now, those are not C++ temporaries.

53:50.000 --> 53:52.800
They have nothing to do with C++ temporaries.

53:52.800 --> 53:58.160
In C++, what's valid in C and looks very similar,

53:59.200 --> 54:01.520
really very similar, is invalid.

54:01.520 --> 54:02.960
You cannot do it in C++.

54:02.960 --> 54:04.320
This creates a temporary object.

54:04.320 --> 54:07.280
You take the address of it and you try to pass this to a function.

54:07.280 --> 54:09.200
But when the function starts executing,

54:09.200 --> 54:11.120
actually this object would still exist, I think.

54:11.120 --> 54:11.920
Oh, no, it wouldn't.

54:12.880 --> 54:14.480
So it's illegal to do it.

54:16.000 --> 54:18.080
I mean, it's illegal because you are taking an address

54:18.080 --> 54:20.400
of our value, right, of a temporary,

54:20.400 --> 54:22.880
which is not even materialized yet, I think.

54:23.760 --> 54:24.560
So you cannot do it.

54:25.440 --> 54:27.680
In C, it is valid and you can do it.

54:28.240 --> 54:30.000
And you can do crazy things with this.

54:30.640 --> 54:34.720
And a crazy like in not negatively crazy,

54:34.720 --> 54:37.040
but crazy in beautifying your code, crazy.

54:38.240 --> 54:42.240
So something like a typical school assignment,

54:42.240 --> 54:45.200
you have an array and you have to declare

54:45.200 --> 54:48.240
and write a function that initializes this array.

54:48.240 --> 54:50.080
And notice that it's a very simple array.

54:50.080 --> 54:54.640
It has just a data field and a size and an account.

54:54.640 --> 54:55.920
Sorry, capacity and account.

54:55.920 --> 54:58.080
So obviously you're gonna allocate for data

54:58.080 --> 55:01.200
and put some capacity and zero the count.

55:01.200 --> 55:03.600
In the old C, you would do it like this, right?

55:03.600 --> 55:06.880
So you are gonna most likely memset somewhere

55:07.280 --> 55:10.960
or set the fields separately one by one to zero.

55:12.080 --> 55:15.120
You're gonna allocate with caloc or malloc,

55:15.120 --> 55:15.920
doesn't really matter.

55:17.440 --> 55:19.040
And if you manage to allocate,

55:19.040 --> 55:20.800
you are gonna set the capacity also

55:21.760 --> 55:22.800
because that's what you do.

55:23.680 --> 55:27.360
Now, nowadays people write it like this.

55:28.240 --> 55:31.840
So they don't really like zero before they

55:33.840 --> 55:36.480
just write it in one line.

55:36.560 --> 55:40.880
So what happens here is I am creating this lvalue object

55:43.760 --> 55:46.560
on the right hand side of the assignment of type arrays

55:47.280 --> 55:51.120
and initializing with it through the designated initializers,

55:51.120 --> 55:53.440
allocating memory on the fly or on the go.

55:54.080 --> 55:56.880
And then I'm assigning it to the difference pointer.

55:56.880 --> 55:59.680
So I'm basically assigning a structure to a structure

55:59.680 --> 56:01.600
or reassigning a value to a structure.

56:01.600 --> 56:03.280
And it works out of the box.

56:03.280 --> 56:06.000
The compiler will of course optimize totally away

56:06.000 --> 56:09.280
the creation of the temporary or not so temporary object.

56:09.280 --> 56:12.960
It's not gonna be there, it's what the compiler is gonna do

56:12.960 --> 56:17.280
is it's going to directly assign to your dereference PA

56:17.280 --> 56:19.200
or through the PA pointer,

56:19.200 --> 56:22.080
totally skipping all the logic on the way.

56:23.200 --> 56:24.320
So that's how we would do it.

56:24.880 --> 56:25.760
What's even better?

56:29.520 --> 56:31.040
And that's just modernity.

56:31.040 --> 56:33.280
Sorry, I had to put the static one there.

56:33.280 --> 56:33.920
I don't know why.

56:34.880 --> 56:39.120
What's even better, you can use it to zero things.

56:40.160 --> 56:42.560
In the old good times, you would call memset.

56:42.560 --> 56:44.560
If you want that, like in the array free,

56:44.560 --> 56:45.920
when you first freed the data

56:45.920 --> 56:48.000
and then zeroed the whole structure just to be sure,

56:48.560 --> 56:50.880
you would call memset on anything.

56:50.880 --> 56:51.600
It works.

56:52.720 --> 56:56.160
It's everywhere in the old C code zeroing

56:56.160 --> 56:58.160
because otherwise you get nasty bugs.

56:59.600 --> 57:01.920
Nowadays, you can write it like this.

57:02.880 --> 57:07.280
So you just assign a new value into your structure

57:07.280 --> 57:08.400
and it's a zeroed value

57:08.400 --> 57:10.480
because it uses empty initialization.

57:11.040 --> 57:15.280
Now, the compiler will memset it for you actually.

57:15.280 --> 57:16.640
If you write code like this,

57:16.640 --> 57:18.320
what the compiler will emit,

57:18.320 --> 57:21.120
depending on the size of your structure,

57:21.120 --> 57:27.840
is either a few Mambo jambos with the XMM registers

57:27.840 --> 57:30.880
to zero your structure directly

57:30.880 --> 57:32.240
or it's going to call memset

57:32.240 --> 57:36.880
if the structure is big enough to call memset.

57:37.520 --> 57:38.720
So you don't have to do it.

57:38.720 --> 57:40.560
Compilers understand what you're doing.

57:40.560 --> 57:42.160
You have to express what you're doing

57:42.160 --> 57:44.720
and let the compiler choose the best way to do it.

57:46.720 --> 57:47.520
And that's not it.

57:47.520 --> 57:49.200
That's not the end of the story

57:49.200 --> 57:51.760
because unfortunately I said that there will be some macros

57:51.760 --> 57:53.600
and I know it's late.

57:55.200 --> 57:57.200
I think it's a good time for macros also

57:57.360 --> 58:01.840
because either it puts people to sleep

58:01.840 --> 58:05.120
or it makes them totally awake.

58:06.400 --> 58:07.440
So let's do macros.

58:08.800 --> 58:12.240
Compound literals can be used as arguments to functions

58:12.240 --> 58:14.000
and for a good reason.

58:14.880 --> 58:16.480
Like, look at this one.

58:16.480 --> 58:17.920
It's a big ugly, right?

58:17.920 --> 58:19.280
And there are even coding styles

58:19.280 --> 58:21.680
which say that if you have to pass more than three

58:21.680 --> 58:23.600
or four arguments,

58:23.600 --> 58:24.960
then you should pass by structure.

58:25.920 --> 58:27.600
There are coding guidelines

58:27.600 --> 58:29.600
and so you shouldn't do things like this.

58:29.600 --> 58:30.880
We agree on it, right?

58:32.800 --> 58:35.120
First of all, this first argument

58:35.120 --> 58:38.400
should be taken as a erase of static one size

58:38.400 --> 58:39.920
but that's something else.

58:39.920 --> 58:41.600
Now in this slide it is

58:41.600 --> 58:43.360
because we already did it correctly.

58:43.360 --> 58:45.200
We use the modernity to signal

58:45.200 --> 58:48.480
that you have to pass valid objects to the blur function.

58:49.600 --> 58:52.400
And of course what you then do

58:53.040 --> 58:56.800
is create a param structures

58:56.800 --> 58:59.760
and pass the address of the param structure to the function.

58:59.760 --> 59:02.400
Much, much better, however, still ugly, right?

59:02.960 --> 59:04.080
That's not what you do.

59:04.080 --> 59:05.360
That's not what you want to do.

59:06.800 --> 59:09.440
The first insight that you might come up with

59:09.440 --> 59:12.160
is that the struct can be created in place

59:12.160 --> 59:14.720
because, hooray, we have compound literals.

59:14.720 --> 59:16.640
So why would you even create the structure

59:16.640 --> 59:19.200
like outside of the function call?

59:19.920 --> 59:20.480
Let's do it.

59:21.440 --> 59:24.320
And I don't know if it's more readable.

59:25.680 --> 59:26.400
No, it's not.

59:27.200 --> 59:29.040
But it certainly looks cooler.

59:30.960 --> 59:32.960
So your cool factor directly goes up.

59:34.720 --> 59:37.280
That's a good idea to do something like this, right?

59:38.480 --> 59:39.920
And then the second insight,

59:39.920 --> 59:43.600
and this is a really breakthrough,

59:43.600 --> 59:46.960
is when you realize that when you look at it,

59:47.600 --> 59:50.320
some of those fields are actually kind of having

59:50.320 --> 59:51.760
like default values.

59:51.760 --> 59:54.800
Compute hardware is set to zero.

59:54.800 --> 59:56.400
It's a default value.

59:56.400 --> 59:57.920
Type box, I'm not showing it,

59:57.920 --> 01:00:00.000
but maybe it's an enum or something like this,

01:00:00.000 --> 01:00:02.160
also with a default value of zero.

01:00:02.160 --> 01:00:04.400
And since we're using designated initializers,

01:00:04.400 --> 01:00:05.440
we can skip those

01:00:05.440 --> 01:00:08.000
because the rest will be zeroed automatically.

01:00:08.880 --> 01:00:12.400
So you can pass only what you want to pass directly in place.

01:00:13.680 --> 01:00:14.640
And that's good.

01:00:14.640 --> 01:00:16.400
That's much, much better, right?

01:00:17.920 --> 01:00:20.160
Not only your naming arguments now.

01:00:20.160 --> 01:00:21.840
Named arguments are also cool, by the way.

01:00:21.840 --> 01:00:23.920
You're naming it with a designated initializer.

01:00:23.920 --> 01:00:26.000
You don't have to pass all the arguments.

01:00:26.000 --> 01:00:32.400
Now, and because, as I said, it's also about macros.

01:00:32.400 --> 01:00:36.880
When you add just one single macro magic line to the mix,

01:00:37.440 --> 01:00:39.600
you can start writing code like this,

01:00:39.600 --> 01:00:42.000
which totally looks like named parameters

01:00:42.000 --> 01:00:43.440
or named arguments in C.

01:00:44.160 --> 01:00:47.680
And they are, I mean, those look like named arguments.

01:00:47.680 --> 01:00:50.160
And of course, the rest takes a default value of zero

01:00:50.160 --> 01:00:51.680
of what you would not pass.

01:00:52.480 --> 01:00:54.880
The macro itself, I'm now,

01:00:55.600 --> 01:00:58.400
yeah, I have doubts whether it's a good statement now

01:00:58.400 --> 01:00:59.600
that it's not much magic.

01:01:01.040 --> 01:01:02.960
But let's assume it's not much magic.

01:01:02.960 --> 01:01:06.400
I mean, it was middle of the day when I was writing it,

01:01:06.400 --> 01:01:07.760
so you have to forgive me.

01:01:08.880 --> 01:01:11.440
It's hash defined blur, obviously.

01:01:11.440 --> 01:01:15.040
And for those of you who don't know this,

01:01:15.040 --> 01:01:19.760
three dots in a macro mean variable number of arguments

01:01:19.760 --> 01:01:23.040
that you can pass through in your macro expansion.

01:01:23.600 --> 01:01:25.760
And that's exactly what I'm doing, right?

01:01:25.760 --> 01:01:28.320
I'm just passing it through in my macro expansion

01:01:29.280 --> 01:01:31.920
under the name VA underscore arcs.

01:01:32.480 --> 01:01:34.800
This is how you pass through variable number,

01:01:34.800 --> 01:01:37.760
variable arguments in C.

01:01:37.760 --> 01:01:38.400
And it works.

01:01:38.640 --> 01:01:41.920
All of a sudden, you can use this beautiful syntax in C.

01:01:41.920 --> 01:01:43.920
Actually, also in C++ node,

01:01:43.920 --> 01:01:46.720
because it doesn't have the compound literals.

01:01:46.720 --> 01:01:48.320
So you cannot do this in C++,

01:01:48.320 --> 01:01:50.320
but I'm pretty sure you can use other tricks there.

01:01:54.160 --> 01:01:59.680
And I already said how it works, so I'm not going to repeat it.

01:02:00.960 --> 01:02:03.520
And I'm sorry for this slide, but I had to put it there

01:02:03.520 --> 01:02:06.400
that it went with a little effort,

01:02:06.400 --> 01:02:11.600
a little effort, some arbitrary default values are also possible,

01:02:11.600 --> 01:02:15.680
because up to now, if you didn't pass a value explicitly,

01:02:16.480 --> 01:02:17.840
it would get a value of zero,

01:02:17.840 --> 01:02:20.480
like it would be empty initialized in your structure.

01:02:20.480 --> 01:02:23.360
So only zero default values were possible.

01:02:23.360 --> 01:02:24.240
Well, that's a lie.

01:02:26.000 --> 01:02:30.480
You can have default values by just specifying them in your macro.

01:02:31.600 --> 01:02:35.840
If you don't specify them, when you call later the macro,

01:02:36.480 --> 01:02:40.000
with your designators, the default values will be taken over,

01:02:40.560 --> 01:02:41.520
and they will be used.

01:02:42.080 --> 01:02:42.480
Great.

01:02:44.320 --> 01:02:46.960
If you do specify them, like I do with here,

01:02:46.960 --> 01:02:52.800
with here is specified as 64, and by default, it is 32.

01:02:52.800 --> 01:02:56.000
Well, the 64 will be taken,

01:02:56.000 --> 01:03:00.560
because in the initializer list, it is after the first initializer.

01:03:01.360 --> 01:03:06.000
It emits a warning, as it should, right?

01:03:07.040 --> 01:03:10.160
The compilers know that we have something bad in mind,

01:03:11.360 --> 01:03:13.280
and they rightfully warn us about it.

01:03:13.920 --> 01:03:18.720
This warning can be silenced with a couple of pragmas

01:03:20.480 --> 01:03:22.000
that you can build into your macro.

01:03:26.480 --> 01:03:29.120
And when I do this, when I later publish this,

01:03:29.120 --> 01:03:32.320
because you will have access to it, this slide will be there,

01:03:32.320 --> 01:03:34.560
but I knew it would be after 5 p.m. now,

01:03:34.560 --> 01:03:36.000
so I skip this slide for now.

01:03:37.840 --> 01:03:41.760
But with a bit of pragmas, you can remove the initializer

01:03:41.760 --> 01:03:44.160
overwrite warning and do magic.

01:03:45.200 --> 01:03:46.480
So that's compound literals.

01:03:46.480 --> 01:03:47.680
They're really cool.

01:03:47.680 --> 01:03:50.480
There are L values that allow you to do crazy things,

01:03:50.480 --> 01:03:55.760
like zeroing the whole objects, initializing objects in a very

01:03:56.720 --> 01:04:00.800
simple way, or even create default arguments to functions.

01:04:01.600 --> 01:04:03.600
And since we are talking about structs,

01:04:03.680 --> 01:04:08.000
and it's not like my favorite hobby topic,

01:04:08.800 --> 01:04:10.000
but I use structs a lot.

01:04:10.000 --> 01:04:13.280
I do a lot of what you call low-level programming,

01:04:13.280 --> 01:04:17.120
system programming, obviously in C,

01:04:18.080 --> 01:04:21.600
and I deal with structs and memory allocations from time to time.

01:04:22.800 --> 01:04:26.320
So let's talk about one less crazy thing,

01:04:26.320 --> 01:04:30.720
and this is the real one last crazy thing

01:04:30.720 --> 01:04:31.680
that I'm going to talk about.

01:04:32.640 --> 01:04:35.680
Let's make a string, something that you've already seen,

01:04:35.680 --> 01:04:38.240
because we already were doing an array a moment before.

01:04:39.760 --> 01:04:42.480
The layout was a bit different, if I remember correctly,

01:04:43.360 --> 01:04:46.320
but, you know, you get the gist of it.

01:04:46.320 --> 01:04:48.400
Again, the length, the size of the array,

01:04:48.400 --> 01:04:50.880
and the pointer to the dynamically-arrowed array.

01:04:51.520 --> 01:04:55.360
And now you imagine that you want to create a function

01:04:55.360 --> 01:04:57.920
that creates such a string for you.

01:04:57.920 --> 01:05:00.320
And because we are living in a dynamic world,

01:05:00.320 --> 01:05:05.680
we want not only the memory that the array is pointing to

01:05:05.680 --> 01:05:07.440
to be dynamically allocated,

01:05:07.440 --> 01:05:10.480
we want the whole structure to be dynamically allocated.

01:05:11.680 --> 01:05:13.840
So you come up with a piece of code like this.

01:05:15.200 --> 01:05:17.120
You take a pointer to a string,

01:05:19.040 --> 01:05:22.400
to the const car, sorry, a valid pointer, of course,

01:05:22.400 --> 01:05:25.840
and then you do the first malloc to allocate the whole string

01:05:26.800 --> 01:05:28.160
structure.

01:05:28.160 --> 01:05:32.320
And if this one is valid, because you have to check in line 5

01:05:32.320 --> 01:05:34.160
if it's valid, you do another malloc

01:05:34.160 --> 01:05:38.000
to allocate the sub-object of the array, right?

01:05:38.000 --> 01:05:41.440
And because this code is very complex,

01:05:42.080 --> 01:05:44.320
all of a sudden, you have to, for example,

01:05:44.320 --> 01:05:46.480
check whether your second allocation,

01:05:46.480 --> 01:05:49.280
so the dot array is malloc, succeeded.

01:05:49.280 --> 01:05:51.600
Because if it didn't succeed, you have to free,

01:05:51.600 --> 01:05:53.600
again, the whole structure and return null.

01:05:54.480 --> 01:05:58.400
And this is a code that invites errors,

01:05:58.400 --> 01:06:01.760
like just by the sheer length of it

01:06:01.760 --> 01:06:06.800
and number of pointers that appear there and mallocs.

01:06:08.000 --> 01:06:10.560
So you don't want to write code like this.

01:06:11.440 --> 01:06:14.080
Not only it is fragile, because you have to remember about,

01:06:14.080 --> 01:06:16.080
like, and especially if it's like a bigger thing,

01:06:17.040 --> 01:06:18.480
you have to remember about freeing,

01:06:18.480 --> 01:06:20.240
about checking all the pointers.

01:06:20.240 --> 01:06:22.800
It's also not really optimal.

01:06:22.800 --> 01:06:25.600
You need twice to malloc, and that's bad.

01:06:26.480 --> 01:06:28.000
It's a costly operation.

01:06:28.880 --> 01:06:32.400
Depending on your luck or the lack of luck,

01:06:33.200 --> 01:06:36.240
you might end up with fragmented memory.

01:06:36.240 --> 01:06:37.920
Your data structure might end up

01:06:37.920 --> 01:06:39.840
in a totally different piece of memory

01:06:39.840 --> 01:06:42.400
than your array that's a part of this data structure.

01:06:42.400 --> 01:06:44.640
You don't want something like this, right?

01:06:44.640 --> 01:06:45.600
It's expensive.

01:06:45.600 --> 01:06:46.240
It's bad.

01:06:46.240 --> 01:06:49.600
What you want is a one-pic nice block of memory

01:06:49.600 --> 01:06:51.040
which contains everything.

01:06:51.040 --> 01:06:52.720
Array, there is a solution for it.

01:06:53.840 --> 01:06:57.600
This solution, and that's actually why I have a layout like this,

01:06:57.600 --> 01:07:00.000
why the car pointer is the last pointer there,

01:07:00.800 --> 01:07:03.920
is called the flexible array member.

01:07:03.920 --> 01:07:04.720
And it looks like this.

01:07:05.920 --> 01:07:10.320
Structures in C can have an array of undefined size

01:07:10.320 --> 01:07:11.440
as the last member.

01:07:12.320 --> 01:07:14.480
And this is not just a pointer.

01:07:14.480 --> 01:07:18.000
This signals that at the end of the structure,

01:07:18.000 --> 01:07:20.800
there is an array which is a sub-object

01:07:20.800 --> 01:07:22.960
or actually a member of this structure,

01:07:22.960 --> 01:07:24.720
and you're going to define at the runtime

01:07:24.720 --> 01:07:25.920
what the size of it is.

01:07:27.040 --> 01:07:30.400
This string is also an incomplete type all of a sudden

01:07:30.400 --> 01:07:33.200
because it doesn't have any proper size anymore.

01:07:34.320 --> 01:07:38.320
Because the length of this is unknown at compile time,

01:07:38.320 --> 01:07:39.120
at the compile time.

01:07:39.120 --> 01:07:40.880
You can only set it up during the runtime.

01:07:43.120 --> 01:07:44.400
So it must appear at the end.

01:07:44.800 --> 01:07:48.000
And you cannot basically do anything with this string

01:07:48.000 --> 01:07:49.520
anymore that's fancy.

01:07:49.520 --> 01:07:53.360
Like you really cannot make an array of these strings directly.

01:07:53.360 --> 01:07:57.440
It's not going to work because this doesn't have a definite size.

01:07:58.240 --> 01:07:59.600
So that's not going to work.

01:08:00.960 --> 01:08:05.600
But what you can do, I mean those are all the things you cannot do,

01:08:05.600 --> 01:08:07.360
and I already told you what you cannot do,

01:08:07.360 --> 01:08:10.560
what you can do is skip one malloc all of a sudden.

01:08:10.560 --> 01:08:12.160
So instead of having two mallocs,

01:08:12.160 --> 01:08:17.840
I now have one that takes care of allocating my base data structure.

01:08:17.840 --> 01:08:20.400
And now if you use the size of,

01:08:20.400 --> 01:08:25.920
it's only going to count the members that have a fixed size.

01:08:25.920 --> 01:08:27.520
So it's not going to count the array.

01:08:28.640 --> 01:08:33.200
And then you take the size of your string

01:08:33.200 --> 01:08:38.160
that you want to put in your array and allocate it all at once.

01:08:38.160 --> 01:08:40.480
There is no free, needed, no checks.

01:08:40.480 --> 01:08:43.680
Actually, one check is needed because I mean,

01:08:43.680 --> 01:08:47.920
I still need to properly initialize using the compound literal,

01:08:47.920 --> 01:08:50.960
of course, because you already know how it works.

01:08:50.960 --> 01:08:51.920
So why not?

01:08:51.920 --> 01:08:54.320
And then copying the whole struct and so on.

01:08:54.320 --> 01:08:56.880
And the layout becomes something like this.

01:08:57.440 --> 01:08:59.920
So it's a contagious block of memory,

01:09:00.560 --> 01:09:02.160
much better for your performance,

01:09:02.160 --> 01:09:05.120
much better for your sanity, actually,

01:09:05.120 --> 01:09:08.160
because the more mallocs, the less sane you become.

01:09:10.560 --> 01:09:14.160
Unless you use sanitizers, yeah.

01:09:15.520 --> 01:09:18.000
So only one malloc, no wasted space.

01:09:18.000 --> 01:09:20.480
And one malloc space overhead.

01:09:21.920 --> 01:09:24.400
And still I have, since I still have time,

01:09:24.400 --> 01:09:26.080
I'm going to do this one.

01:09:26.080 --> 01:09:29.680
And I'm going to do a very short demonstration at the end.

01:09:29.680 --> 01:09:30.560
Because why not?

01:09:31.920 --> 01:09:32.720
Let's do.

01:09:32.720 --> 01:09:34.400
First, macro magic incoming.

01:09:34.960 --> 01:09:36.640
This talks and with macros.

01:09:37.200 --> 01:09:41.920
So you are shaken awake properly before the evening starts.

01:09:44.160 --> 01:09:46.720
And we are going to talk about function overloading in C,

01:09:46.720 --> 01:09:48.480
also known as generic selection,

01:09:48.480 --> 01:09:50.160
because that's also a feature of C.

01:09:50.800 --> 01:09:53.680
C can overload functions.

01:09:53.680 --> 01:09:54.800
You wouldn't believe it.

01:09:54.800 --> 01:09:56.720
It just does it in a bit different way

01:09:56.720 --> 01:09:58.240
than normal people are used to.

01:10:00.320 --> 01:10:04.640
Imagine that you have two different structures

01:10:04.640 --> 01:10:07.440
and they're obviously shapes, like a circle and a rectangle.

01:10:08.000 --> 01:10:09.920
And you want to write a scale function,

01:10:09.920 --> 01:10:13.840
which takes those structures and scales them with some scale.

01:10:14.800 --> 01:10:17.680
Now, you cannot have something like this in C, right?

01:10:17.680 --> 01:10:19.280
Very unfortunately, you cannot,

01:10:19.280 --> 01:10:23.440
because C doesn't know what name mangling is.

01:10:23.440 --> 01:10:24.640
So it's not going to fly.

01:10:26.560 --> 01:10:28.800
You need to, instead of having two scale functions,

01:10:28.800 --> 01:10:32.000
you need to name them correctly,

01:10:32.000 --> 01:10:34.720
like scale, circle, scale, rect, and so on.

01:10:34.720 --> 01:10:38.480
And let's be honest, this is ugly.

01:10:38.480 --> 01:10:40.880
I mean, I don't like code like this,

01:10:40.880 --> 01:10:41.840
and this is not a joke.

01:10:41.840 --> 01:10:44.320
I mean, why would I need two different names

01:10:44.320 --> 01:10:46.080
for a function that does exactly the same?

01:10:46.720 --> 01:10:48.640
I would prefer to have one function name.

01:10:49.280 --> 01:10:53.120
And luckily, this is possible.

01:10:53.120 --> 01:10:56.480
And as everything that's possible in C,

01:10:56.480 --> 01:10:58.080
it's possible thanks to the macros.

01:10:59.040 --> 01:11:03.760
C already, again, I think in C11, if I'm not mistaken,

01:11:03.760 --> 01:11:08.160
introduced a new macro called a generic selection macro,

01:11:09.280 --> 01:11:12.640
which works on types and switches based on types.

01:11:13.280 --> 01:11:15.600
So it's like, it's basically a switch statement

01:11:15.600 --> 01:11:16.800
if you look at it.

01:11:16.800 --> 01:11:19.920
So in the first, you have the controlling expression,

01:11:19.920 --> 01:11:21.680
just like in the switch statement.

01:11:21.680 --> 01:11:22.720
And then you have the cases.

01:11:23.920 --> 01:11:26.640
If it's type one, type two, or type three,

01:11:28.720 --> 01:11:32.400
not really return everything, but replace my macro with this

01:11:32.400 --> 01:11:35.040
because macros are about text substitution.

01:11:36.160 --> 01:11:38.000
So depending on a control statement,

01:11:38.960 --> 01:11:41.120
on the value of the control statement,

01:11:41.120 --> 01:11:43.040
actually on the type of the control statement,

01:11:43.760 --> 01:11:45.120
you get different things.

01:11:45.120 --> 01:11:47.200
You can replace based on the types

01:11:48.640 --> 01:11:50.880
your whole macro block with something else.

01:11:50.880 --> 01:11:53.680
There's also a default because it's really like a switch statement.

01:11:53.680 --> 01:11:54.880
So there is a default clause.

01:11:55.520 --> 01:11:58.880
And this doesn't require lots of coding.

01:11:58.880 --> 01:12:02.480
If we have two ugly functions, like scale,

01:12:02.480 --> 01:12:07.680
circle, scale, rectangle, we can just do define object scale,

01:12:07.680 --> 01:12:10.320
which is going to be our function like macro.

01:12:11.200 --> 01:12:14.000
And then do this generic selection,

01:12:14.000 --> 01:12:17.360
switching on the object based on the type of the object.

01:12:17.360 --> 01:12:22.640
If it's a rectangular substitute with scale rectangles,

01:12:22.720 --> 01:12:26.080
with scale rectangles, are they wise scale, circle?

01:12:26.640 --> 01:12:30.080
And basically this whole block of those lines of code

01:12:30.080 --> 01:12:32.640
is going to be substituted with either scale,

01:12:32.640 --> 01:12:35.760
scale, rect or scale, circle, depending on the type.

01:12:36.960 --> 01:12:39.360
And of course, since it's actually not a textual

01:12:40.560 --> 01:12:42.880
substitution, you still have to call the parameters

01:12:42.880 --> 01:12:46.640
or pass the parameters later on to the correct function.

01:12:46.640 --> 01:12:48.080
And all of a sudden this works.

01:12:48.080 --> 01:12:50.880
This is so popular that this is now part of the standard library.

01:12:51.840 --> 01:12:55.600
Math functions are already standardized to use generic selection

01:12:55.600 --> 01:12:58.560
because before you had like, you know,

01:12:58.560 --> 01:13:01.280
for every single math function you had at least three variants

01:13:01.280 --> 01:13:04.160
or sometimes more, depending on the argument type.

01:13:04.160 --> 01:13:09.040
So now all of them got macros to enable this kind of magic.

01:13:09.040 --> 01:13:12.000
Doesn't always work that great, must say,

01:13:14.000 --> 01:13:17.440
because integer types get confused with Booleans sometimes.

01:13:18.320 --> 01:13:23.280
If you are below C23, starting with C23, not anymore,

01:13:23.280 --> 01:13:26.000
but before they get confused.

01:13:26.000 --> 01:13:28.720
That's because a Boolean was just a type for Boolean.

01:13:28.720 --> 01:13:31.920
And yeah, sorry for something else.

01:13:31.920 --> 01:13:35.680
And it doesn't matter, works great.

01:13:36.880 --> 01:13:39.120
And I just want to end up with a big bank.

01:13:40.480 --> 01:13:43.200
You can also overload on the number of arguments,

01:13:43.200 --> 01:13:44.320
if you really want to.

01:13:45.280 --> 01:13:48.720
And if you really want to, I don't know.

01:13:49.840 --> 01:13:50.960
There's no pub quiz, right?

01:13:50.960 --> 01:13:52.720
So it's nobody to impress tonight.

01:13:52.720 --> 01:13:57.200
But no, no, this is the kind of things you try to impress your colleagues with

01:13:58.000 --> 01:13:58.880
during a pub quiz.

01:13:59.600 --> 01:14:02.160
You can also do overloading of known arguments.

01:14:02.160 --> 01:14:05.680
So imagine you have like circle, just there is one scale,

01:14:05.680 --> 01:14:10.240
but for the rectangle, there's either the vertical or the horizontal scale.

01:14:10.240 --> 01:14:14.880
So we take a separate two different scales or just one general scale.

01:14:15.440 --> 01:14:19.600
And we would like to again be able to do the magic that we've done before.

01:14:19.600 --> 01:14:24.320
So call depending, use the same name to call both of them.

01:14:26.000 --> 01:14:29.280
The bad news is that generic is not going to help you that much

01:14:29.840 --> 01:14:35.760
because you cannot put it in, I mean, it doesn't expand the macros within it.

01:14:36.560 --> 01:14:39.520
So that doesn't work like this.

01:14:40.240 --> 01:14:44.560
But the good news is that you can do still generic selection

01:14:46.160 --> 01:14:50.800
for scale 2P and scale 1P, depending on the argument type,

01:14:50.800 --> 01:14:52.080
just like I did before.

01:14:53.920 --> 01:14:57.440
I mean, with a small difference, there is now a variable number of arguments

01:14:57.440 --> 01:15:00.960
passed to the macro to account for one or two arguments.

01:15:00.960 --> 01:15:02.640
Actually not, I think I was lazy

01:15:03.600 --> 01:15:06.480
because those are fixed number of arguments for both cases.

01:15:06.480 --> 01:15:08.400
I was lazy, sorry.

01:15:09.680 --> 01:15:11.680
And then you do a classic trick.

01:15:12.880 --> 01:15:15.520
Once you have those two generic selectors,

01:15:15.520 --> 01:15:19.360
you do the invoke or the substitute trick, whatever people call it,

01:15:20.640 --> 01:15:24.880
that's used to select a name from a list of names.

01:15:26.000 --> 01:15:28.560
The invoke basically takes a number of arguments.

01:15:28.880 --> 01:15:32.160
And depending on the number of arguments that you pass to invoke,

01:15:32.160 --> 01:15:34.320
it will select different names.

01:15:35.440 --> 01:15:38.240
I don't want to talk about the mechanics of it now,

01:15:38.960 --> 01:15:41.200
mostly because I am not able to anymore.

01:15:42.960 --> 01:15:44.240
That's number one reason.

01:15:44.240 --> 01:15:48.640
The number second reason is I understand it,

01:15:48.640 --> 01:15:50.800
but I will forget it after three days,

01:15:50.800 --> 01:15:52.400
and I will have to look at it anyway.

01:15:52.400 --> 01:15:54.240
If you want to use it, look it up.

01:15:54.240 --> 01:15:56.640
Unless you're really coding daily with these kind of things.

01:15:57.440 --> 01:16:01.280
But that's the standard way of selecting a name from a list of names

01:16:01.280 --> 01:16:05.280
based on the number of arguments passed to the selection statement,

01:16:05.920 --> 01:16:07.520
and then it will work.

01:16:07.520 --> 01:16:09.040
So that was the generic selection,

01:16:09.040 --> 01:16:10.480
which makes writing code much easier,

01:16:10.480 --> 01:16:12.560
can be nested from multiple selectors

01:16:14.720 --> 01:16:16.800
and suffers from all the macro shortcomings.

01:16:17.920 --> 01:16:21.120
And generally speaking, this was almost all,

01:16:21.120 --> 01:16:22.640
that's the slide that you've seen,

01:16:22.640 --> 01:16:26.160
it's incorrect because I don't know

01:16:26.720 --> 01:16:30.640
want to do a five minute quick code refactoring,

01:16:32.400 --> 01:16:33.600
just to wake you up a bit.

01:16:35.200 --> 01:16:40.960
And I'm going, you see, I have something like a vector,

01:16:41.520 --> 01:16:42.640
so what we've been doing,

01:16:43.200 --> 01:16:46.400
and a very deep function vector create,

01:16:46.400 --> 01:16:49.760
written in the old style, like the totally old style.

01:16:50.800 --> 01:16:52.240
It's taking a double pointer,

01:16:52.480 --> 01:16:57.680
so it's, and the reason it's not why not,

01:16:57.680 --> 01:17:01.120
the reason is because then it can write back to the pointer,

01:17:01.120 --> 01:17:04.240
that the pointer points to something like this, right?

01:17:06.160 --> 01:17:11.600
Something you shouldn't be scared when you see the code in C.

01:17:11.600 --> 01:17:15.520
I am compiling on the only compiler that accepts C23,

01:17:15.520 --> 01:17:16.960
this is the GCC trunk,

01:17:17.680 --> 01:17:22.160
and it works now because it's written in correct old C,

01:17:22.960 --> 01:17:25.600
with all the warnings, no warnings are popping up,

01:17:25.600 --> 01:17:27.840
sanitizer doesn't kick in, good work.

01:17:29.280 --> 01:17:30.960
We want to make it modern C,

01:17:30.960 --> 01:17:34.720
and there are a couple of things when you see code like this,

01:17:34.720 --> 01:17:36.080
that you have to take care of.

01:17:42.080 --> 01:17:46.400
First, let's look at the return type, which is totally wrong,

01:17:46.480 --> 01:17:50.000
I'm using the old style of returning integer,

01:17:50.000 --> 01:17:54.080
like a negative is a mistake, positive is everything is okay,

01:17:54.080 --> 01:18:00.400
and since we are on C23, we can do this out of the box,

01:18:00.400 --> 01:18:03.200
we can return, I should return false actually here,

01:18:03.200 --> 01:18:04.640
instead of minus one,

01:18:04.640 --> 01:18:07.360
so that's the correct way of doing things, right?

01:18:12.400 --> 01:18:15.760
And that one being the last one, this should be true.

01:18:16.160 --> 01:18:19.280
Still compiles out of the box, no warning,

01:18:19.280 --> 01:18:22.960
I don't include any header whatsoever to enable Boolean magic.

01:18:24.080 --> 01:18:27.520
The next thing is actually I don't accept null pointers,

01:18:28.240 --> 01:18:33.120
so maybe fix also that one, and put static one in here,

01:18:34.400 --> 01:18:39.680
and if you do it, all of the sudden, you won't be able to pass

01:18:40.480 --> 01:18:46.320
null into the function, it's not going to work,

01:18:47.440 --> 01:18:49.440
because the compiler, I mean, it's going to work,

01:18:49.440 --> 01:18:52.720
but the compiler will tell you that you are trying to pass a null

01:18:52.720 --> 01:18:54.400
to a function that doesn't accept it.

01:18:55.120 --> 01:18:58.640
A great thing, you have to pass a valid pointer.

01:18:59.920 --> 01:19:03.440
What's next, I don't like null pointers,

01:19:03.440 --> 01:19:06.160
I mean, I don't like null because it's not strongly typed,

01:19:06.800 --> 01:19:11.040
null ptr, null pointer is a strongly typed alternative nowadays

01:19:11.040 --> 01:19:15.600
in C23, use it, there's also null ptr underscore t

01:19:16.720 --> 01:19:19.520
as the type of it, just same as in C++.

01:19:21.120 --> 01:19:23.920
Define, nah, not really, right?

01:19:24.880 --> 01:19:28.080
This is bad, and I don't mean to put it here,

01:19:29.040 --> 01:19:37.520
we have constexpr, constexpr size t, I'm using capitals, I know it's bad,

01:19:40.160 --> 01:19:41.120
but let it be so.

01:19:43.040 --> 01:19:46.560
The compiler got a bit crazy, it doesn't understand really what I do,

01:19:46.560 --> 01:19:49.600
because it says set but not use, which is not true,

01:19:50.800 --> 01:19:53.760
I think that's, yeah, that's it, it's just too new,

01:19:53.760 --> 01:19:56.960
it also doesn't work with auto by the way, and it should,

01:19:56.960 --> 01:20:00.160
but then it totally, I mean, it goes monkeys.

01:20:01.360 --> 01:20:06.880
So let's keep it like this, we're fine, so far so good.

01:20:09.680 --> 01:20:16.720
Look at this, I'm doing the old style initialization, that's something,

01:20:17.280 --> 01:20:20.720
you know, that's shameful nowadays.

01:20:20.720 --> 01:20:23.440
If you do code like this, you should be ashamed,

01:20:23.440 --> 01:20:25.600
because you have compound literals nowadays,

01:20:25.600 --> 01:20:29.120
they are much better, express your intent better.

01:20:29.120 --> 01:20:30.880
Why don't you do it, let's do it.

01:20:33.280 --> 01:20:38.080
The change is not that bad, we have to put, I mean, it is bad,

01:20:38.080 --> 01:20:39.360
but let's pretend it's not.

01:20:40.240 --> 01:20:45.040
You have to put vector there, and then spell out the names,

01:20:45.040 --> 01:20:48.480
we have dot data is equal to that one,

01:20:49.280 --> 01:20:57.120
and it's not gonna compile out of the box, of course, dot capacity is that one,

01:20:59.440 --> 01:21:04.160
and dot, it was size is that one, close that,

01:21:05.920 --> 01:21:08.160
put the commas where they should be put,

01:21:10.960 --> 01:21:16.480
and are we good, we are almost good, I mean, I did it incorrectly, of course,

01:21:16.480 --> 01:21:21.920
but because I should have done that one here, small change, don't worry,

01:21:23.040 --> 01:21:26.720
I am an expert, famous last words, right?

01:21:28.960 --> 01:21:32.800
Okay, so we should initialize it like this, and the vector itself

01:21:35.360 --> 01:21:42.000
should be still done with malloc size of vector, so let's do it correctly.

01:21:42.160 --> 01:21:48.000
This code doesn't compile now without, I mean, it compiles without warnings.

01:21:51.120 --> 01:21:56.720
If I'm not mistaken, let's compile without warnings, control itress, now it's not true.

01:22:01.840 --> 01:22:08.000
Line 30, oh yes, yeah, that goes away, of course, thank you.

01:22:08.000 --> 01:22:10.880
So it compiles without warnings, that's fine.

01:22:12.960 --> 01:22:17.280
But then you have to notice, or actually, you should think about what you're doing,

01:22:17.280 --> 01:22:23.440
you're doing again something that I told is not really cool, I'm doing a double mallocation, malloc,

01:22:25.440 --> 01:22:30.800
because my structure is allocated and my data is allocated, there is first malloc to allocate

01:22:30.800 --> 01:22:35.760
the structure, then the second malloc to allocate the data, it's hidden here and the

01:22:35.840 --> 01:22:40.800
cast to double is not needed, by the way, in CU you can just cast without this one.

01:22:42.400 --> 01:22:47.520
What to do about it? Change, of course, the data type to a flexible array member

01:22:48.880 --> 01:22:55.680
or the field type, so do something like this, and now it's not going to work

01:22:56.400 --> 01:22:59.680
like it worked before, now it's going to work much, much better,

01:23:00.400 --> 01:23:08.480
because what you can do is malloc size of the vector itself plus

01:23:10.080 --> 01:23:19.680
size of capacity multiplied by size of debo, I'm doing, I wanted to actually double

01:23:20.640 --> 01:23:29.760
malloc and capacity, and it has to go, let's put it where it was,

01:23:31.200 --> 01:23:37.520
let's move those up all the way where they belong to, because now it makes sense,

01:23:37.520 --> 01:23:44.160
so I'm allocating everything at once, the whole array, as it should be allocated,

01:23:44.160 --> 01:23:52.720
and then I don't need this one anymore, I do need to most likely return quickly,

01:23:52.720 --> 01:23:58.720
if I don't manage to malloc, because that's still needed, and if I do manage to malloc, well,

01:23:59.520 --> 01:24:04.080
all I need is actually that one, so I need to set the capacity correctly,

01:24:05.680 --> 01:24:10.400
and that's done with 1.9, and I don't free anymore, because that's also not needed,

01:24:11.200 --> 01:24:17.840
so my code now became like at least twice as short, I shouldn't return true,

01:24:17.840 --> 01:24:24.800
can I return true here? Yeah, I can, or I can return just vector is different than null pointer,

01:24:26.800 --> 01:24:34.640
which is a nice way of spelling the same thing, and do here is vector different than null pointer,

01:24:35.280 --> 01:24:46.000
then I'm gonna assign the new capacity to it, and that's it, if I am not mistaken,

01:24:46.000 --> 01:24:52.720
that's the end of the refactoring of doing it more modern, using modern proper syntax,

01:24:55.360 --> 01:25:02.960
is it better? I think it's more readable, I think it's easier to maintain, because you don't have

01:25:02.960 --> 01:25:08.720
so many lines of code, and you don't have so many branches, there are not so many ifs like before,

01:25:08.720 --> 01:25:15.120
not so many else, and so on, and so on, and it doesn't compile as some of you most likely notice,

01:25:15.120 --> 01:25:22.240
because I'm freeing something, I shouldn't be freeing now, I was freeing still the data,

01:25:22.240 --> 01:25:28.560
and I cannot free the data separately now, because data is now a sub item of my big structure, right?

01:25:28.560 --> 01:25:39.520
So that's all, that's really all, and that's the summary of it, don't be afraid of modernity,

01:25:41.280 --> 01:25:45.120
some features really boost productivity, especially things like initializer,

01:25:45.120 --> 01:25:51.840
designated initializers, and compound literals, do boost productivity enormously, some of them

01:25:51.840 --> 01:25:58.000
will really help you with safety with pointers, when you use the variable length arrays syntax,

01:25:58.000 --> 01:26:04.640
when passing things to functions, or when declaring multidimensional arrays, or even single

01:26:04.640 --> 01:26:10.480
dimensional arrays, it's going to help you with safety, compilers are getting better and better,

01:26:10.480 --> 01:26:17.520
like basically every year there is a new warning appearing, that wasn't there before for variable

01:26:17.520 --> 01:26:24.240
length arrays, some features are scary, like using macros, this is always scary,

01:26:24.960 --> 01:26:28.880
what's even more scary is chart GTP is very good at it,

01:26:31.760 --> 01:26:38.560
and compilers will understand modernity and help you, when you zero using the compound

01:26:38.560 --> 01:26:44.800
literals they will do memset under the hood, they will optimize away all those actually L values,

01:26:44.800 --> 01:26:49.360
don't worry about it, like even if you're passing the whole structure to the function

01:26:49.360 --> 01:26:54.800
through a compound literal, some compilers do optimize away a lot of it, and you don't pass

01:26:54.800 --> 01:27:00.960
what you don't need to, thank you very much for listening, we have exactly 45 seconds left,

01:27:02.960 --> 01:27:07.840
which is like perfect timing, but you can ask me later on questions if you have them,

01:27:08.800 --> 01:27:15.120
so thanks again for coming here and staying with me awake, which is like a huge achievement

01:27:15.120 --> 01:27:20.880
for all of you, so thanks a lot guys

