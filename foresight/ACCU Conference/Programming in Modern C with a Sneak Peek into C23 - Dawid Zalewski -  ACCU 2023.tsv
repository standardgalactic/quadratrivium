start	end	text
0	8040	Good afternoon, everybody, and welcome to my talk about C, which is a quite unexpected
8040	9720	talk for this kind of conference, right?
9720	15720	You come here to hear all about modern languages like C++, Kotlin, a couple of years ago, nowadays
15720	20920	for us is hugely popular, and you hear about this.
20920	27200	And this is about C, which is like, yeah, this grandfather of languages.
27200	33080	So quite surprising, and I'm happy that you are here also to listen to it.
33080	37160	Now, on the other hand, C is not going anywhere.
37160	39520	It's definitely not going anywhere.
39520	43200	I had a pleasure to attend the conference a couple of weeks ago when there were people
43200	49960	from, lots of people from automotive industry, and obviously those guys only use C and C
49960	55000	plus plus, and it's a huge industry, and generally speaking, you know, related embedded industries.
55000	60640	And there are also people from MISRA C and MISRA C plus plus, people who standardize safety
60640	66360	for C and C plus plus, among others, for the automotive industry.
66360	73840	And then, I mean, there was a discussion in the audience, and what I heard a lot is this
73840	78880	is a billion dollar industry, and nobody's going to rewrite billion dollar libraries
78880	83920	and software into Rust anytime soon in any other language for that matter, because they
83920	86160	aren't just not going to drop it at one day.
86160	88200	So C is still rolling there.
88200	89840	So thank you that you are here.
89840	93480	Now, surprisingly, C is not a dead language.
93480	94480	You might think so.
94480	100000	I mean, it's not like, you know, in a rapid development cycle of C plus plus that every
100000	103120	three years to get a new standard.
103120	108040	But it's also not a dead language, quite to the contrary.
108040	115280	What you see there is a valid C, kind of a valid C, and you might be surprised when you
115280	118440	look at it, because there are crazy things happening.
118440	125080	Like, if you learned C from the standard C book, the C programming language, you definitely
125080	131960	have never seen bull as a type or true being returned from something or being passed to
131960	132960	a function.
133880	139880	There is also, that's just because I couldn't fit it on a slide, don't don't mention it.
139880	142920	The structure definition is in the return type directly.
142920	144200	This is a C feature.
144200	146960	So you can do things like this.
146960	148880	It's just I couldn't fit it otherwise.
148880	156480	Anyways, if you go further, there is type of, it's an operator in C that works pretty
156480	162040	much like decal type is just much less powerful and doesn't come with all the craziness craziness
162040	164560	of decal type.
164560	175320	There is constexpr nowadays, at least let's say since two weeks when the C23 was standardized.
175320	183960	There are weird things like indices in square brackets, also something that I don't think
183960	189120	many of you use, especially if you're coming from C++, there is auto.
189120	191720	I mean, it's been there since the beginning, right?
191720	198160	So it's for specifying the storage type in C.
198160	206440	So it's still there, but what's even more strange is the right-hand side of this expression
206440	212240	where it looks like I'm creating like a temporary structure and taking an address of it or casting
212240	217600	something like into a structure and taking an address of it, something, you know, among
217600	222120	these lines.
222120	225760	And I'm returning actually not really this pointer, but the reference in this pointer
225760	226760	later on.
226760	234920	And there is a null pointer, null PTR, just like in C++, it's a keyword again for exactly
234920	240160	past week or has been a keyword for exactly past one week.
240160	241480	So that's it.
241480	245880	This program is a valid C and it compiles.
245880	247920	You wouldn't believe it, but it compiles.
247920	255480	Unfortunately, it compiles only a single compiler now, and that's the trunk of GCC, otherwise
255480	257800	it won't compile.
257800	262000	This is the only compiler that accepts all these nice features because it's so new, it's
262000	267280	just freshly standardized, and they have some special meaning.
267280	270120	So you can compile it using, for example, the compiler explorer.
270120	271120	No problems.
271120	275040	You have to pass in this state is C to X.
275040	279480	It's still not 23 because it won't, I mean, in this compiler in the trunk version, they
279480	284800	weren't even sure that this is going to be C23.
284800	289480	It's going to compile with no warning whatsoever, and it's going to execute.
289480	290480	What's your guess?
290480	291480	What's it's going to do?
291480	292720	I mean, okay, it looks crazy.
292720	295880	I mean, you cannot guess from it what it's going to do.
295880	297280	I agree.
297280	302520	But if you look carefully in line 15, it definitely tries to print something.
302840	307400	No, line 13 is definitely trying to print something by using the putString function
307400	311120	puts, and it's casting this array as an argument.
311120	314000	So it definitely is going to print something.
314000	315160	What's it going to print?
315160	316160	It's going to print C.
316160	317160	It's great.
317160	318160	Long live C.
318160	322520	It's unique code characters for a good measure, right?
322520	331200	That's because C is still the language we love for its total lack of type safety.
331200	336760	It's really one of the reasons why C exists, and it's so popular in embedded industry,
336760	340000	in system programming industry, is that you don't care about types.
340000	344640	You can easily cast from one thing to another, just like a cast set and array of doubles
344640	347400	into a car pointer.
347400	348960	No problems whatsoever.
348960	352360	And if you know what you encode within these doubles, it's going to work.
352360	359360	And of course, it returns 42, as it should, which you also couldn't see.
359360	365040	So this is a talk about modern C, and I'm going to talk about modern C a lot.
365040	372880	And what people consider modern C is anything starting from C99 and above.
372880	377320	There were a couple of standards on the way, like for example, C17, which added a few things,
377320	381880	and now C23, but this is all modern.
381880	386240	That's generally a talk for everybody who learns C from the old books or who doesn't
386240	391680	know C a lot, who doesn't use C a lot, because I expected half of you don't really use C
391680	394320	every day.
394320	398280	Or maybe you got curious about something, maybe you heard something, and you want to
398280	399280	learn.
399280	408480	Anybody, if I ask now, who's using C, like at least once a week here, yeah, two persons.
408480	411280	That's a lot for this.
411280	413840	So I am also using it.
413840	417080	It's like half, half with C++.
417080	422360	So this is basically a talk exactly for you, for those of you who know nothing about C
422360	429960	or learned it a long time ago and think that it's still like in this old prehistoric times.
429960	438120	Now as I said, C is a cool language, and we all love it for its total lack of type safety,
438120	444560	and for the fact that basically you can do everything and express everything with C.
444560	450000	It's just that you have to be very careful not to create a bloody mess when you do it,
450000	453320	which is equally easy as creating a well-working program.
453320	459280	So this talk is going to cover a couple of topics that might be useful when trying not
459280	466120	to create a bloody mess, like how to initialize in modern C, how the initialization works
466120	471080	in modern C, because when you don't initialize variables, bad things happen.
471080	476080	Like C++ has some guarantees about what happens when you don't explicitly initialize,
476080	479760	like default, zero initialization, blah, blah, blah, and so on.
479760	481040	C doesn't.
481040	484720	C just gives you garbage if you don't initialize, right?
484720	488840	We're going to talk about pointers, arrays, and functions, because obviously it is a C talk,
488840	493240	so pointers must happen, otherwise it's not going to work,
493240	496680	and about how you can be a bit safer with pointers.
496680	502560	A bit safer, because those guarantees are now built into the language slowly.
502560	509320	We're going to talk about zeroing, assigning, and things basically like what's on the screen,
509320	518800	how to zero the whole data structure again, because it's an important part of modern C.
518800	525040	Finally, if time permits, a bit about fragile resource management, so cool new features
525040	531720	in C that make it very easy for people who deal with hardware to write efficient software,
531720	536320	and how to make dynamic resource management, and especially memory management less fragile
536320	542960	and easier to handle, and there will be some macro magic, if time permits, because obviously
542960	547640	this is a talk about C, so there must be macro magic.
547640	549360	So that's it.
549360	554560	I will throw, for a good measure, some C23 pieces here and there, but this is not a talk
554560	558240	about C23, mostly because I just couldn't make it in time.
558240	563040	It was standardized a week ago, and a week ago, people didn't even know what would be
563040	568400	really there and what wouldn't be there, so it was a bit too much risk to make a talk about
568400	576360	C23, and the features actually that they put in C23 require on talks on the topic only.
576360	580600	So there will be some 23, and whenever you see this logo, it means that there is a C23
580600	581600	feature.
581600	583480	Now, the quiz time.
583480	590480	It's only quiz, that's only in this talk, and I hope it's a cool quiz, and that you can
590480	593520	answer the questions that I'm going to ask you.
593520	594520	And you can shout.
594520	596240	We are not that many here, you can shout.
596240	598280	I had the microphone, I'm louder anyway.
598280	601280	We have a function, it's C.
601280	602280	It's not C++.
602280	603280	Print.
603280	607080	How many arguments does it accept?
607080	609680	Who's for none?
609680	615160	Okay, who's for possibly many?
615160	616680	Exactly.
616680	618680	Great.
618680	623800	This function accepts possibly many arguments, because in C, when you don't put void in between
623800	628000	the brackets, the function possibly accepts many arguments.
628000	630320	Next one, and that's a tricky one.
630320	631320	There is a function.
631320	635680	It accepts two arguments, A and B, with some types.
635680	638600	The types are not really defined there.
638600	641960	And then it prints the sum of those two arguments, A and B.
641960	648120	And I'm calling this function with two double arguments, 1.5 and 8.5.
648120	653760	And obviously, any normal person would say that the sum of those two is 10.
653760	654760	Who's for 10?
654760	659440	As a result of what the function is going to print?
659440	661320	Who's for 9?
661320	662320	Majority.
662320	663320	Great.
663320	664320	I like it.
664320	667800	It's going to print 9, you're absolutely right.
667800	673600	Because if you don't tell what the argument type is, it's going to be an integer, right?
673600	678720	Because in the old good type, times when C started to exist, there were only integers.
678720	680440	So everything was an integer.
680440	683520	Honestly, I'm on C23.
683520	684520	It's undefined.
684520	688800	Finally, it's undefined because it was a source of many errors.
688800	692280	So it's illegal to do it anymore.
692280	694280	Good things do happen.
694280	697880	Now, that's one tricky.
697880	700080	And the question is very easy.
700080	706880	What's the value of number and what's its type?
706880	708760	So it's just one line of code.
708760	712800	It's don't overthink it, right?
712800	716400	And as a hint, the literal is a floating point number.
716400	721080	It's a float on the right-hand side, right?
721080	726720	So you might think, well, it's a float because the right-hand side of the assignment is a
726720	728120	float.
728120	732280	And the other good hint or a good guess would be an integer.
732280	736160	And it would be an integer because like on the previous slide, if you don't define the
736160	739120	type, it's an integer, right?
739120	747280	And you are right and right depending on which language version you are.
747280	757840	If you are on anything below what happened last week, it's going to be 42 because it's
757840	759600	an integer.
759600	766560	Auto before last week meant automatic storage duration, nothing else.
766560	771280	So you could have skipped it and it would mean like then, you know, it's an integer
771280	774480	because obviously when you don't specify a type, it's an integer.
774480	780400	Now you wouldn't believe it, but auto means the same now in C as it means in C++.
780400	782600	It's for type inference.
782600	788720	Actually, it has this kind of a dual life now in C23.
788720	794120	It is for type inference or for storage duration specification.
794120	796720	That's whether you put the type or not yourself.
796720	803600	So if after the type I would put in, this auto would be specifying the storage duration.
803600	806720	But because I didn't, it's for type inference.
806720	807720	Next one.
807720	811520	Well, this compile in C, okay, this doesn't make any sense now to us because I just showed
811520	819200	you that it compiles in the first slide, but I asked this and there are two different
819200	820200	answers to it.
820200	825920	Either it will compile out of the box or you have to include something.
825920	830440	Who's for including that you have to include some standard headers for it to compile?
830440	834840	You are absolutely right.
834840	837840	Because you didn't read what happened last week, right?
837840	844760	When the bool and false became keywords in C also.
844760	851200	So they also kind of do the same thing like C++, they like to do things slowly.
851200	858560	They first standardized boolean with a totally weird notation underscore capital letter bool.
858560	862560	And you could have the normal bool through a header inclusion that was, it was simply
862560	868840	a type def inside and now it's standardized as a keyword.
868840	871440	That one, I'm not going to retorture you with this one.
871440	874720	I think it's fun.
874720	880360	Unless you know what's happening there, I mean, what's the size of the numbers array
880360	883760	and I don't want you really to count this one.
883760	888760	Because if you count, I think you're around eight.
888760	891920	So there are eight initializers listed there.
891920	895040	But there are many other options there and the correct answer and we're going to talk
895040	898880	about it is 12, which is not really apparent when you look at the list.
898880	900680	There is no 12 anywhere.
900680	904760	There are no 12 initializers, there is no index 11, nothing like this, right?
904760	908920	So it's like, why?
908920	914040	Because it's C and in C we like doing things our harmful way.
914040	918560	So that's why.
918560	924600	Next one, does anybody know actually what is the type of PK in line four?
924600	926920	If you look at it.
926920	932560	PK has a very specific type.
932560	941320	I mean, you are kind of born when you're not born with knowledge of C, it's not that far.
941320	949280	But we learn it when we learn C that pointers are pointers in C and a pointer is a pointer.
949280	955960	You can cast it, it basically doesn't have any further meaning, doesn't come along with
955960	958720	any further type specification, it's just a pointer.
958720	959720	It's not true.
959720	965280	This is a pointer to an array of 10 by 10 integers, exactly.
965280	969680	It's a strongly typed pointer to an array, two dimensional error.
969680	975880	And because of this, when I malloc it and use size of Asterix PK, I'm going to get
975880	980200	enough storage for 100 integers.
980200	981200	Is it integers?
981200	984280	Yes, it is integers.
984280	990040	So the answer is 400, at least on my platform.
990040	995120	And I think we are almost at the end of the funny quiz.
995120	998520	And the question is, is this program well-formed?
998520	1003560	And I'm not talking about intendation, it's cool.
1003560	1008440	I'm talking whether it's going to compile, whether it's going to be accepted by a compiler.
1008440	1012840	And there are a couple of answers, and you can raise your hand if you think that this
1012840	1015600	answer sounds true.
1015600	1021720	Like A is no, because line 11 is fishy.
1021720	1030000	And line 11 is fishy, because it looks like, actually I don't know what I'm doing there.
1030000	1038080	It looks like an array, I'm casting actually open curly braces to an array, right?
1038080	1041160	That's what I'm doing.
1041160	1042920	Who thinks this line is fishy?
1042920	1048560	Yeah, it's definitely fishy, but it's not a problem.
1048560	1049560	It compiles.
1049560	1056640	The other answer is no, line 5, the address of a temporary is taken, or something that
1056640	1059200	looks like a temporary.
1059200	1064040	And I mean, the address is definitely taken in this line, but again, this is a perfectly
1064040	1066240	fine C.
1066240	1070360	An answer might be also no, there is no aggregate initialization or something like this, no,
1070360	1074840	there isn't, but you can initialize with designated initializers.
1074840	1079040	So this is a perfectly fine C, and it's going to compile.
1079040	1081080	And it's even going to print something.
1081080	1085200	I think it's going to print today on the screen.
1085200	1093000	And last but not least, and that's a tricky one.
1093000	1095640	What does this function accept?
1095640	1099400	What kind of arguments does it accept?
1099400	1102360	Because it accepts a very specific type of arguments.
1102360	1106880	So this again, type safety, pointer safety, do you have an idea?
1106880	1116560	C, this key, you're right, sorry, I first read D, which I also have an urge to actually
1116560	1123160	directly look at, you're right, it accepts valid non-null pointers to con-scar.
1123160	1129320	So it's a contract, it's basically your saying, it's a pointer to con-scar, and it
1129320	1131600	has to be valid, it cannot be null.
1131600	1134640	And you would be surprised, compilers check it.
1134640	1136440	So that's this.
1136440	1143400	And we are finally at the core of our talk.
1143400	1147520	Go on, please.
1147520	1148520	That one.
1148520	1149520	I don't hear you.
1149520	1154840	Is it also the case that the pointer was the pointer and it was the string?
1154840	1158880	No, no, it's only checked whether it's null or not.
1158920	1163440	So because it's a pointer, you can pass null, right, as an argument.
1163440	1167880	So that's been checked, but yeah, it doesn't look into the string really.
1167880	1170880	No, no, it's not that good.
1170880	1175000	I mean, there is no runtime in C, there is assembly, right?
1175000	1176000	So.
1176000	1191400	Even if you pass an empty string, you still have the null terminator there, so officially
1191400	1194600	it's valid, right?
1194600	1197800	I'm sorry, but it's officially valid.
1197800	1199520	This only checks for null and nothing else.
1199520	1202200	So okay, let's go.
1202200	1203200	Initialization.
1203440	1208480	The first topic, an important topic, and I mean, the quiz was also partially about initialization,
1208480	1211120	like you've seen lots of initializers.
1211120	1213280	Have you ever seen code like this?
1213280	1214600	Anybody?
1214600	1215800	Raise your hands, please.
1215800	1220680	All of you have seen this code because it comes from this book.
1220680	1224400	You must have seen it.
1224400	1230800	So this code attempts to initialize a structure, right, a structure of X and Y, a very simple
1230800	1232240	one.
1232240	1234200	And that's not how you write it nowadays.
1234200	1239480	Nowadays, what you would do is, of course, use the brace initialization, like you would
1239480	1240480	do it in C++.
1240480	1246280	The only difference is you need that equality, you know, or an assignment in between.
1246280	1252080	And that's how it works in up-to-date C. It exists in C. Brace initialization exists
1252080	1255840	in C, and you can pretty much initialize everything like this.
1255840	1262800	So, you know, like an array of undefined size, and then the size will be calculated from
1262800	1264840	the initializers.
1264840	1272320	You can initialize a list on an array, or an array with a defined size.
1272320	1274480	You can initialize structures like this.
1274480	1275480	No problems whatsoever.
1275480	1280960	You can initialize pretty much everything with braces, just like basically aggregate
1280960	1286800	initialization works in C++ for those of you who know what it is.
1286800	1290280	But when I mean everything, I really mean everything.
1290280	1291800	This is legal.
1291800	1298040	Some people write it because then it's uniform, and it looks nice.
1298040	1299960	And it scares people who don't understand.
1299960	1302840	And that's also good, because you don't want people who don't understand your C code to
1302840	1306160	touch your C code, right?
1306160	1309760	So you put it there just to scare off people.
1309760	1312160	That works.
1312160	1319160	There is also something called empty initialization in C. It got a name, empty initialization
1319160	1323840	a week ago, like a standardized name, before it was known under different names.
1323840	1327800	Some people called it zero initialization, some default initialization.
1327800	1332400	And basically the trick is you put a single zero in between the braces.
1332400	1333400	Nothing else.
1333400	1338720	This has the effect of zeroing everything, whatever is on the left-hand side.
1338720	1345240	So if it's a value, or if it's an array, or if it's a structure, then recursively all
1345240	1348200	the fields of the structure will be zeroed.
1348200	1353120	Nulls will be actually zeros, like a null is a zero, or most of the architectures will
1353120	1359640	be put where they should be put, and so on, and so on.
1359640	1365000	It kind of got its name from this one.
1365000	1371560	Because in C23 they removed the need for having a zero in between the braces, you can now
1371560	1375360	skip the zero in between the braces, and it's still going to work.
1375360	1378520	So that's where it comes from, the empty initialization.
1378520	1379960	Now what are the rules?
1379960	1381920	The rules are very simple.
1381920	1390640	When you empty initialize something, like a structure, what happens is that all your
1390640	1394920	fields in the structures are going to be zeroed, including the parting bytes.
1394920	1399480	Not because they have to be zeroed, but that's because what the compilers will do anyway,
1399480	1400480	and that's it.
1400480	1403080	There is no magic in it.
1403080	1404680	It also works for nested types.
1404680	1409760	So if you have an array of structures or whatever, you can just zero it like this.
1409760	1410760	It's great.
1410760	1411760	Right?
1411760	1415560	You don't have to use memset all of a sudden, and we are used to use memset.
1415560	1420600	I mean, at least I was used to use memset at all a lot when I was programming C.
1420600	1424200	So we just put zero there.
1424200	1426280	Now what if you don't want a zero?
1426280	1433080	What if you want different values, like, for example, you have a bigger structure with
1433080	1440320	five fields, and two of them should have some values, and the rest should be zeroed?
1440320	1442120	Because why not?
1442120	1445720	And then you might think, okay, what's my idea here?
1445720	1451400	I might zero first the whole structure, then set the fields, and so on, or do something
1451400	1456360	crazy like this, right, when you use the brace initialization and list all the members one
1456360	1461080	after another at the right positions and initialize with zero what needs to be initialized with
1461080	1462080	zeros.
1462080	1467960	Luckily, this is not the way, because there are designated initializers in C, just like
1467960	1471680	they're in C++, and they have the same exactly syntax.
1471680	1478920	So there is a dot, then the designator, then the equality symbol, and then the value you
1478920	1484480	initialize the designated field with.
1484480	1490960	This has the same effect as in C++, almost the same, because we don't have default initialization
1490960	1492460	here.
1492460	1498120	It zeros all the fields that are not explicitly initialized.
1498120	1503520	So those that you explicitly initialize with your designators are going to get the values,
1503520	1507480	the rest is going to be zeroed, which is great, because very often it happens, and especially
1507480	1513780	if you program in C, in C, people work with all fully long structures that have, I don't
1513780	1518280	know if you've ever looked, for example, how file is implemented, how many different fields
1518280	1519280	it has.
1519280	1520280	It's horrible.
1520280	1523120	Most of them are usually zero.
1523120	1525120	So that's great.
1525120	1530200	Now what's not so great, or actually maybe what's great, because C gives you all the
1530200	1538360	powers there is, there are in this world, so what's great, you can mix the positions
1538360	1540160	when you're designated initializer.
1540160	1544480	So you're not necessarily bound to the order of declaration, as you are in C++.
1544480	1548440	For C++, it's going to be a hard compilation error if you try something like this.
1548440	1552320	See, no problems whatsoever, mix them.
1552320	1559920	What's even, now I struggle to say it's better.
1559920	1569960	What's even cooler is that you can mix positional and designated initializer, something that's
1569960	1572240	also forbidden in C++.
1572240	1573440	You can freely mix them.
1573440	1579800	You've seen it already when I was asking about the size of an array with really weird indices.
1579800	1585840	This is a mix of designated and positional initializers, two positional initializers,
1585840	1590800	the first one and the last one and two designated, but you have to be careful about what you're
1590800	1599120	doing and how you're doing it, because you have to understand how the logic works behind
1599120	1601840	the initializations order then.
1601840	1603200	The first one is quite easy.
1603200	1608160	It's a positional initializer and it goes into the first field.
1608160	1611400	Then we have a designator status.
1611400	1616120	It names the last field in the structure, so the status is going to end up there.
1616120	1622200	Then we have another designator flex and it fits in there.
1622200	1627640	Last but not least, we have one more positional initializer with no designator.
1627640	1635200	It's going to end up directly after the flex and the reason for it, whenever you have a
1635200	1641040	designator in your initializer list, the counting for the next positional initializer
1641040	1645600	starts from this designator.
1645600	1651240	You have to know what you're doing, but that's great and of course the rest is zero.
1651240	1656600	If you know what you're doing, it's going to work nevertheless.
1656600	1663520	You can nest initializations just like you can do it in C++.
1663520	1672440	You can nest them, I mean, the designators and initializers for sub-objects.
1672440	1674880	Also with designators, no problems whatsoever.
1674880	1681600	You can even do crazy things like this, dot-flux, dot-extended, dot-extended designates a field
1681600	1684040	of a sub-object of the structure.
1684040	1686200	This is also not allowed in C++.
1686200	1688720	You cannot nest in C++ like this.
1688720	1691160	In C, it is allowed.
1691160	1697400	Now, this is also a funny thing and it's funny because I don't know really what's
1697400	1699760	the use for it.
1699760	1706640	I mean, I only know one use that I came up with when I was working on it once and it's
1706640	1710880	not even a good use, so I'm not going to mention.
1711080	1713360	No, okay.
1713360	1716600	You can use designators for arrays.
1716600	1722400	It's absolutely fine and this works the same way as for structures.
1722400	1729480	The designator designates a field or actually the subscript that you're going to initialize
1729480	1731160	with a value.
1731160	1734200	This is like an array of 42 numbers.
1734200	1737880	Three of them are going to be initialized with certain values.
1737880	1740760	This is a Fibonacci sequence, roughly.
1740760	1745200	That's a Fibonacci sequence, part of it.
1745200	1747920	The rest is going to be zeroed.
1747920	1757160	The rest of the numbers are going to be zeroed in this array, all of 99 of them, which might
1757160	1760200	be useful, might not be.
1760200	1763120	The same craziness applies as instructors.
1763120	1766680	You can mix the order, whatever you want.
1766680	1774320	You can mix positional initializers with designated initializers and, again, the same rules apply
1774320	1775320	as before.
1775320	1783960	If you have the designator, the index of the following positional initializers is counted
1783960	1785880	from this designator.
1785880	1791400	There is a designator 10 at the second position here, which means that 89 is going to end
1791400	1795000	up at index 11.
1795000	1800800	Because it's going to end up at index 11, there is nothing actually more to talk about,
1800800	1805560	but there is something to talk about here, because this is going to end up at index 11.
1805560	1811480	This array has a size of 12, because this is the highest index in the initializer list.
1811480	1813240	But this is crazy.
1813240	1815280	Things like this shouldn't be allowed.
1815280	1819000	Neither should be this, but it's there.
1819000	1823200	If you look at this, this is fine.
1823200	1827120	I mean, it's not fine, but you can do it.
1827120	1834640	You can have an array of structures, for example, and designate or initialize one of the fields
1834640	1837680	of those structures at a specific index of the array.
1837680	1840680	It's going to work out of the box.
1840680	1847600	The syntax, especially at the multiple level of nesting, looks really ... You cannot comprehend
1847600	1850120	it anymore, I think, at one moment or another.
1850120	1851120	It works, nevertheless.
1851400	1852400	So that's it.
1852400	1854560	That's the initialization.
1854560	1857280	That's how we initialize everything in modern C, believe me.
1857280	1858280	People really do it.
1858280	1862560	They use curly braces even for numbers, and there are no restrictions.
1862560	1865560	In C++, they have a lot of restrictions for it.
1865560	1870040	In C, there are none whatsoever, so you can do ... You can really confuse your colleagues
1870040	1871040	if you want to.
1871040	1876000	Now, and since we are talking about arrays, and there is one very popular topic when it
1876000	1881600	comes to arrays, we are going to discuss it.
1881600	1886120	Generally speaking, as all of you know, there are two types of arrays in this world.
1886120	1892520	You can have either an array with a static known size, constants known size, and that's
1892520	1896640	your good old array, as on the left-hand side, or you can have an array that you allocate
1896640	1900320	dynamically on the heap, and that's something like a runtime thing.
1900320	1907120	So during the runtime, you can come up with a value for the size of your array and allocate
1907120	1909240	it.
1909240	1913600	It's much better today like this because this size should be somewhere close to your numbers
1913600	1916240	definition to the array definition.
1916240	1919520	Nobody people don't put defines, hash define, within the function.
1919520	1923040	They can, but nobody dares to, for some reasons.
1923040	1926400	They put it somewhere outside, and then you don't know what the size of the array is,
1926720	1930480	but with Consexper, it's just more natural to put it next to the array, right?
1930480	1931760	So you can do it now.
1931760	1933360	Anyways, back to the arrays.
1934560	1940480	Question, is a lot a constant integral expression?
1941680	1944720	Who's for it that it's a constant integral expression?
1947120	1949680	Some people have doubts.
1949680	1951840	Who's against it, like totally against?
1953840	1954880	Nobody has doubts.
1955840	1957120	That's also fine.
1958320	1959040	It depends.
1959040	1963200	If you're coming from C++, obviously it's a constant integral expression in C0.
1963200	1967760	C, no, sorry, that's why we use defines in C, right?
1967760	1970320	Because we like to confuse people.
1971600	1976960	This is not a constant integral expression, so you cannot use it to define an array with
1976960	1978640	a constant known size.
1978640	1979920	It's illegal.
1981360	1983280	However, this code does compile.
1985520	1989760	It compiles, and many people hate it, that it compiles.
1990560	1994160	And we're going to talk about why they hate it in a moment.
1994160	1999760	What it really declares or defines is a so-called variable length array.
2000800	2008480	It's an array whose size is determined at the runtime, and usually it's allocated on the stack
2008480	2009360	by the compiler.
2010320	2013200	Like allocated on the stack during the runtime.
2013200	2021440	That means also calculating the size, calculating the register shift, the RSP register shift,
2022320	2024080	and manipulating it at the runtime.
2024720	2029360	So this creates an array with an unknown size, or actually not with a well-known size
2029360	2030960	during the runtime, on the stack.
2031440	2034080	And you can only do it within a block scope.
2034640	2036560	And the reason is quite obvious.
2036800	2040880	I mean, at the file scope, you don't have really a stack there.
2040880	2042800	So how do you declare an array there?
2043840	2047680	It's not really standardized that it does have to be on the stack, but all the compilers
2047680	2048400	do it on the stack.
2049120	2051120	C++ doesn't have this feature.
2051120	2054560	And for a reason, because there was a big discussion when they introduced it, it will
2054560	2056720	see also whether it's even needed.
2056720	2060960	And many people said that it's not needed.
2060960	2066400	I also said before that you can initialize everything with curly braces.
2066400	2067840	Well, not this one.
2067840	2069360	This is the only exception.
2069360	2070240	You cannot.
2070240	2072720	You have to initialize it element by element.
2073600	2075600	Anyways, as I said, some people hate it.
2076480	2079360	And they hate it with passion.
2081840	2087360	Like Linus said, that using VLS is actively stupid.
2088960	2094400	And for many reasons, and many other people in the community actually repeat the same
2094480	2097040	thing that is actively stupid to do it.
2097040	2098960	Nowadays, nobody's using VLS.
2099600	2100880	And that's not a joke.
2100880	2105600	I mean, students sometimes use it because they don't know that it's a bad code.
2106160	2107760	But otherwise, nobody's using it.
2107760	2109120	Why they don't use it?
2109120	2111920	Well, it's an array on the stack.
2111920	2113600	You know what's the problem with the stack?
2113600	2118960	Depending on your architecture, the stack is maybe four kilobytes or maybe eight megabytes
2118960	2119680	if you're lucky.
2120640	2125680	So when you declare an array or define an array with a size that's going to be determined
2125680	2129200	during the runtime, you definitely have to check whether it will fit on the stack.
2129840	2133120	Otherwise, you're going to blow up the stack and your program will crash.
2133680	2139600	So you must build in this check somewhere before this array even comes to being.
2139600	2141360	Otherwise, you are in danger zone.
2142080	2145120	And only then you can do your array thingy.
2145760	2149200	So the question is, why would you do it anyway this way?
2150000	2155040	I mean, isn't it just better to have directly the array with the myAllowedSize
2155920	2158400	and it will fit everything I need anyway?
2159280	2161040	So just do it like this, right?
2161920	2163120	And then this.
2163760	2165440	And I still have to check, obviously.
2166400	2170560	But now I have an array with a constant known size.
2170560	2172320	The compiler can see it upfront.
2172320	2173680	It can optimize for it.
2173680	2174240	So why?
2175440	2178240	What's even worse, if you look at the...
2178240	2180960	It's the same code as before, just without the stack check.
2180960	2184720	And I'm doing now the n of size 10 on the left-hand side.
2184720	2186640	It's a variable length array on the right-hand side.
2186640	2188480	It's an array with a constant known size.
2189760	2191520	It generates much worse code.
2192240	2195360	The VLA variant is much bigger in the assembly
2195920	2198800	because these calculations have to be done at the runtime.
2198800	2200240	So you have to calculate the shift.
2200240	2203840	You have to move the RSP by certain size.
2203840	2206880	Whereas on the right side, on the right-hand side,
2206880	2211200	the compiler knows it has to shift the stack pointer by 40 bytes
2211200	2212080	and it's done.
2212880	2213760	So it's bad.
2213760	2215920	It's actively bad.
2215920	2219600	I'm not going to say stupid, but it's actively bad to do it.
2219600	2220720	Don't do it.
2220720	2224240	Now, if you shouldn't do it, then why am I talking about it?
2225440	2226880	Unless you are, of course, a teacher
2226880	2228480	because then you are going to see students do it
2229360	2230720	and you have to correct them.
2230720	2233440	The reason is VLAs are used for other things.
2233440	2236960	And some people argue this is the primary reason
2236960	2238960	why VLAs are in the language.
2238960	2243120	They are not for having stack arrays with variable length.
2243120	2247040	They are for doing things like they're going to witness in a moment.
2247920	2251120	This is a function that takes an array of numbers
2252240	2254880	by a pointer and the size of the numbers
2254880	2256240	and does nothing special really.
2256800	2259760	Now, if you have code like this,
2259760	2264320	you can also write the argument a bit differently.
2265760	2268960	You can write the argument as the second parameter
2268960	2273280	or the second parameter being an array of type int
2273280	2275440	with n elements inside.
2276080	2278080	And this does something different.
2278080	2281200	This communicates your intent all of a sudden.
2281760	2286160	You say exactly that it must be an array of n elements
2286160	2289040	and there must be enough storage for those n elements.
2289120	2291440	The previous one didn't communicate it.
2292880	2296960	The trick is size has to come before the array
2296960	2298000	otherwise it's not going to work.
2298000	2299760	Right? Now, why would you do it?
2299760	2304560	I mean, you can do it for arrays with known size like that one
2304560	2308320	an array of five elements and it's going to compile just fine.
2309120	2314720	Or you can do very nasty things like a hidden bug there
2314720	2317040	when I'm trying to pass an array of five elements
2317040	2322640	and pretending it has six elements which is bad, actively bad,
2323760	2326960	and your compiler will tell you that you are doing something bad.
2327520	2331440	Compilers do detect those errors if you pass arguments
2331440	2333040	using the VLA syntax.
2333040	2334160	At least GCC does.
2335040	2336960	Clank doesn't really want to do it.
2337600	2339440	Sometimes it does but not in this case.
2340720	2345600	Surprisingly, it even works for dynamically allocated arrays.
2345600	2349360	If you try to pretend that a dynamically allocated array
2349360	2352240	is bigger than it is, GCC will warn you
2352240	2354000	with a string operation overflow.
2355280	2357760	Apparently, it is a string operation what we are doing.
2358880	2361360	Nevertheless, this is great, right?
2361360	2362560	It warns you.
2362560	2364480	And since we are already talking about arrays
2365360	2373280	and we are all kind of educated in the way that arrays decay
2373280	2377440	to pointers, unless there are three specific scenarios when they don't,
2378640	2382480	let's talk about more about how you pass arguments in modern C
2382480	2386720	and specifically how you pass pointers in modern C to functions.
2387600	2389840	There are four different scenarios that you can cover
2390560	2394320	when you think about how you pass pointers in C.
2395120	2399760	The first one or the first ones are about arrays.
2399760	2402960	The two second ones are about single objects.
2403440	2405920	Imagine you are passing an array of n objects
2406560	2410080	and you have enough storage for n objects
2410080	2413040	but not necessarily valid objects in this array.
2413040	2416800	What you're going to do then is use the syntax that I just showed you.
2416800	2420960	It works and the compilers will check it most often.
2422320	2427760	So in this case, it's a buffer of n characters uninitialized
2427760	2429120	and I'm never reading from it.
2429120	2433360	I'm actually initializing it or putting values into this buffer
2433360	2434880	but I have enough storage.
2434880	2435840	That's great.
2435840	2441280	Now another scenario, if it's an array with enough storage for n objects
2442240	2445840	and it must contain n valid objects.
2445840	2447760	That's like a hard requirement.
2447760	2449760	There are n valid objects inside.
2450400	2456400	There is this syntax that you guessed correctly for something different.
2457360	2463840	You use the keyword static before you mentioned the size.
2465040	2468880	It's been there since C11 if I'm not mistaken
2470000	2472160	and it means something special.
2472960	2475680	It basically means that those objects do have exist.
2475680	2477840	It's illegal not to have objects there
2477840	2483760	and some compilers are able to check not everything but some parts of it
2483760	2486080	but it clearly communicates the intent at least.
2486960	2488880	So static communicates the intent.
2489920	2494480	When it's a single object and it can be a null pointer,
2494480	2496880	well, you do it the old way, right?
2496880	2498640	There is nothing special about it.
2498640	2503520	You are responsible for checking it if it works or if it doesn't work.
2503520	2508080	Now the last one is actually the one that we already showed during the quiz
2508080	2510000	or I already showed during the quiz.
2510000	2513280	If you're passing a pointer and it mustn't be null,
2513280	2518800	it's illegal that it's a null pointer than you use static one.
2518800	2521680	It's a very common thing, especially static one,
2522400	2528400	somehow managed to permeate into the code, into the live code.
2528400	2531440	People use it because compilers check it and enforce it.
2536400	2541120	So use it and for a proof that compilers check it and enforce it,
2542080	2546080	especially when you use the static keyword, look at this piece of the code,
2547520	2552800	it basically tells that there is a function that takes an array of three doubles
2552800	2554400	and those doubles must exist.
2555920	2559280	And I'm trying to call this function with a dynamically created array
2560240	2563760	and notice that I'm totally not saying, I mean,
2563760	2567520	I'm not passing the size of the array here as an argument
2567520	2570480	and I'm trying to do it as statically created array.
2572000	2578400	This GCC triggers an error for both of them.
2579200	2583040	GCC, without even the static analyzer that it has built in,
2583040	2585840	is able to see that you're doing something very bad
2585840	2588160	and it will gonna tell you this time with, again,
2588160	2589680	with string operation overflow.
2591120	2598400	The first one with the static array also triggers an error on the clunk compiler.
2598400	2600080	So that's very good.
2600080	2604640	That protects you against very stupid mistakes that we often do,
2604640	2606880	you know, buffer overflows do happen.
2607680	2610640	Like there are single most important point of failure,
2611760	2614480	I mean, in all the spaceships that went down, right?
2616720	2618400	So do it.
2619760	2625680	It also works amazingly well for this kind of syntax,
2625680	2630960	which I said that protects you against passing a single null pointer
2630960	2632640	when you don't expect a null pointer.
2633280	2636240	And when you try to do something like this,
2636240	2638240	GCC will again emit an error.
2638240	2640400	And I think clunk also now emits an error.
2640400	2645520	So that's the summary of how you pass arguments in modern C.
2646720	2650800	Use the row pointer only if you're expecting one object
2652560	2654800	and only if it can be null.
2654800	2658720	Otherwise use the VLA notation sometimes with the static keyword
2659280	2663360	if you expect invalid objects to be in the array.
2663360	2665040	Compilers do enforce it.
2665040	2667280	Lots of modern C code is written like this.
2667840	2672080	And obviously it's not supported in C++, the static notation,
2672080	2676160	and the VLA syntax also not really there because it's a part of the VLA.
2676800	2680640	And since we are at the VLA's and there was, I asked this question before,
2681600	2685760	or I was talking about a PK pointer somewhere in the beginning of the talk.
2687360	2689840	As you can see, it's a two-dimensional array.
2689840	2690480	It's a beast.
2691360	2693520	It's a beast, it's a Gaussian filter.
2693520	2696080	It's a kernel of the Gaussian filter if I'm not mistaken.
2698400	2704160	It's a beast and it's a beast because multi-dimensional arrays in C and C++
2704160	2705600	are horrible to work with.
2706320	2708400	So that's like a five by five array.
2708400	2709600	The size doesn't matter.
2710560	2714320	What's horrible about it is not what you see on the screen.
2715440	2717200	It's what you see now on the screen.
2717760	2720800	Maloching this or allocating this array is still okay.
2720800	2724560	And by the way, notice that I'm also using the VLA syntax
2725840	2727680	with the size of operator.
2727680	2728880	This is also valid.
2728880	2730880	You can do something like this for the size of,
2730880	2733920	which greatly simplifies size-offing for your malochs.
2736160	2738080	And then when you index into this array,
2740000	2742400	I don't understand it now, right?
2742400	2745040	What I've done before, and I always have to look it up.
2746160	2749040	And nowadays, people use strategy-tp for these kind of things
2749040	2751040	before it was stuck overflow.
2751040	2753600	And I'm not joking because it's unclear.
2753600	2756720	You have to remember like what's, I mean,
2756720	2760400	how is the data laid off in the multi-dimensional array
2760400	2761680	to be able to do this magic.
2763200	2768080	So what we really want is something like pk
2768160	2770240	and then a first index, second index.
2770240	2773280	What we get is, yeah, is this.
2775120	2778720	Luckily, the VLA syntax does this for you.
2779280	2782960	When you use VLAs with strongly typed arrays,
2782960	2785280	you can achieve this because, you know,
2785280	2789200	VLAs don't only extend to declaring parameters
2789200	2793520	or to having stuck arrays.
2793600	2799120	They're also for declaring strong array types.
2800160	2802880	For those of you who are not fresh with the pointers,
2804560	2807520	like I wasn't, for example, when I was preparing this talk,
2809760	2813200	the pk is a pointer to an array of doubles,
2813200	2816080	to actually two-dimensional array of doubles
2816080	2819760	with the size as Z as Z, whatever the as Z is.
2819760	2821680	Because it's a VLA, so it doesn't matter.
2821760	2824400	It's determined at the runtime.
2825440	2826640	It's strongly typed.
2827200	2831040	And that sense that if you try to do something with this,
2831040	2833040	that's not allowed, like pass it to a function
2833040	2835680	that accepts a single double pointer,
2835680	2836800	it's not going to compile even.
2837840	2840080	And when you use it, all of a sudden,
2840080	2842080	this kind of syntax becomes possible.
2843280	2844640	So it's much better.
2844640	2847200	It's a huge improvement because you can now index
2847200	2849680	into your multi-dimensional array with this.
2849680	2852320	Compiler knows it's a pointer to a 2D array,
2852320	2854000	so it can index into it properly
2854000	2857520	and translate into the pointer operations.
2858080	2862080	What's even better, if you don't like the currently,
2862080	2865280	the brackets Asterix pk, you can also do it like this.
2866800	2868080	This is a bit of a cheating
2868080	2870640	because I gave up a bit of a type safety,
2871520	2873520	because it looks like I'm now allocking,
2874480	2878480	like an array, a one-dimensional array,
2879280	2883280	not really doing it, but this allows for this beautiful syntax.
2884800	2891040	And if you don't like pk, so that's what you do.
2892080	2894560	If you really fell in love with the VLA syntax,
2895920	2898960	notice that what I'm doing here on the right-hand side
2898960	2901280	of the malloc, it's not really cool, right?
2901360	2904240	I'm doing something like size of pk multiplied by size
2904240	2905840	and it's going to work correctly.
2905840	2907600	It's going to allocate the correct number of bytes,
2908640	2910640	but some people don't like it.
2910640	2912720	They say that it shouldn't be like this
2913840	2915680	and that you should use the VLA syntax
2915680	2917520	for your size of operators also
2917520	2920640	because it's much cleaner and it communicates the intent better
2921360	2923200	and you cannot make so many errors.
2923200	2926720	So if you just fell in love with the VLA syntax
2926720	2930720	and you want to show off, you can do it also.
2931280	2932560	Using a type of operator.
2935280	2938000	Because the type of the pk pointer,
2938000	2941760	the reference is the array of doubles of size size
2942960	2946720	and then there is another size then
2946720	2949600	and together they make a multi-dimensional array.
2950160	2952960	Think about type of a set decal type here.
2952960	2955120	So it works in exactly the same way.
2955120	2960880	So we just declare a type of an array of doubles of size as Z.
2961760	2963600	And you can combine it with index 10,
2963600	2966400	which is like, whoa, why?
2967280	2969520	I was pretty shocked when I discovered this.
2972080	2975360	Yeah, and since we are in C plus C23,
2975360	2976800	there is an old pointer obviously.
2978320	2983120	Anyways, that's the initialization and the arrays.
2983120	2985680	And now we're coming to the worst part of the talk
2985680	2987840	because it's the most difficult part of the talk.
2987840	2988800	Actually, it's not difficult.
2988800	2992560	It's a bit of a crazy part of the talk.
2992560	2994800	It's going to be about zero increase assigning
2994800	2999200	and disappearing L values or whatever you call them.
3001520	3003040	You remember this slide, right?
3003040	3004880	This was somewhere at the beginning of the talk
3004880	3007040	when I talked about the old C initialization
3007040	3009520	and the new C initialization syntax.
3009520	3011280	And I said, this is up to date C.
3011920	3013200	I lied, of course.
3013200	3014800	This is not an up to date C.
3014800	3018480	Nobody writes code like this unless you are born
3018480	3021040	in, yeah, in 2011.
3021920	3023280	I don't think those people write C.
3024400	3025040	Might, though.
3025040	3025600	You never know.
3026400	3029280	So you don't write this kind of code anymore.
3030160	3031120	It's not up to date.
3031120	3032480	It's modestly up to date C.
3033520	3036240	What you do nowadays is something like this.
3037760	3041520	You return these things that looks like casting.
3042400	3044560	And then there is the initializer list
3045440	3047680	with designated initializers inside.
3047680	3049760	Now, this has a name.
3049760	3051120	It's a compound literal.
3052800	3055040	And this is something that exists only in C.
3056880	3063200	It has a very simple syntax type in the normal brackets
3063200	3065840	followed by the initializer in the curly braces.
3065840	3067920	The initializer is not optional.
3067920	3069040	You have to put it there.
3070320	3074240	And it creates an unnamed object.
3075200	3076480	It's really created.
3077760	3078320	It exists.
3079200	3082880	This object has different storage duration.
3082880	3085040	It can have a static storage duration
3085760	3087440	if you declare it at the block scope.
3087440	3091440	For example, I am declaring a not at the block scope,
3091440	3092800	sorry, the file scope.
3092800	3096560	I am declaring at the file scope an array of doubles
3097760	3100240	that doesn't have any name, but I'm assigning it
3101760	3104320	to a variable of default coefficients.
3104320	3105760	And it's there.
3105760	3109760	It's going to exist throughout the duration of your program.
3109760	3113360	Or you can do automatic storage if it's in the block scope.
3114240	3117280	And here it is, I'm declaring a structure
3117280	3119040	or actually I'm assigning to a structure
3120560	3122160	with some new values.
3122160	3126240	So I'm using, you know, I have already a fear for structure
3127840	3131280	and I'm putting a new value into it with the assignment
3132400	3135600	with some other initializers and so on.
3135600	3137680	So two different storage locations
3137680	3140400	and where the object is created as,
3140400	3144880	like for any other object, if it's a static storage duration,
3145680	3147360	it's somewhere in the global memory.
3147360	3150160	So my coefficients are in the global memory.
3150160	3156080	And my object on the right have some side of the assignment
3156080	3158320	because this is what we are talking about.
3158320	3161760	We are not talking about the fear if I are variable.
3161760	3164320	We are talking about what's on the right hand side
3164400	3171280	is going to be allocated on the stack for a moment,
3171280	3172880	at least for the duration of this line.
3174640	3177040	The unnamed object is an L value.
3177680	3180960	And for those of you who know a bit about value categories,
3181760	3184480	it means many things like you can assign to it
3187120	3188400	or you can take an address of it.
3189120	3190240	It's fully legal.
3190240	3191440	It exists.
3191440	3192960	If it's declared in the block scope,
3193040	3196000	it's going to exist throughout the duration of this block
3196000	3198000	or the lifetime of this block.
3198000	3200160	And you can legally take an address of it.
3200160	3202880	And this allows for surprising applications like that one.
3205200	3209120	Those of you who ever dealt with time
3210000	3213440	are familiar with the normalizing function MakeTime,
3213440	3216080	which normalizes the TM structure.
3217600	3219040	You can normalize like this now
3220000	3223360	and get the Unix time out of it.
3224240	3226720	Cool thing if you ask me.
3226720	3230000	Now, those are not C++ temporaries.
3230000	3232800	They have nothing to do with C++ temporaries.
3232800	3238160	In C++, what's valid in C and looks very similar,
3239200	3241520	really very similar, is invalid.
3241520	3242960	You cannot do it in C++.
3242960	3244320	This creates a temporary object.
3244320	3247280	You take the address of it and you try to pass this to a function.
3247280	3249200	But when the function starts executing,
3249200	3251120	actually this object would still exist, I think.
3251120	3251920	Oh, no, it wouldn't.
3252880	3254480	So it's illegal to do it.
3256000	3258080	I mean, it's illegal because you are taking an address
3258080	3260400	of our value, right, of a temporary,
3260400	3262880	which is not even materialized yet, I think.
3263760	3264560	So you cannot do it.
3265440	3267680	In C, it is valid and you can do it.
3268240	3270000	And you can do crazy things with this.
3270640	3274720	And a crazy like in not negatively crazy,
3274720	3277040	but crazy in beautifying your code, crazy.
3278240	3282240	So something like a typical school assignment,
3282240	3285200	you have an array and you have to declare
3285200	3288240	and write a function that initializes this array.
3288240	3290080	And notice that it's a very simple array.
3290080	3294640	It has just a data field and a size and an account.
3294640	3295920	Sorry, capacity and account.
3295920	3298080	So obviously you're gonna allocate for data
3298080	3301200	and put some capacity and zero the count.
3301200	3303600	In the old C, you would do it like this, right?
3303600	3306880	So you are gonna most likely memset somewhere
3307280	3310960	or set the fields separately one by one to zero.
3312080	3315120	You're gonna allocate with caloc or malloc,
3315120	3315920	doesn't really matter.
3317440	3319040	And if you manage to allocate,
3319040	3320800	you are gonna set the capacity also
3321760	3322800	because that's what you do.
3323680	3327360	Now, nowadays people write it like this.
3328240	3331840	So they don't really like zero before they
3333840	3336480	just write it in one line.
3336560	3340880	So what happens here is I am creating this lvalue object
3343760	3346560	on the right hand side of the assignment of type arrays
3347280	3351120	and initializing with it through the designated initializers,
3351120	3353440	allocating memory on the fly or on the go.
3354080	3356880	And then I'm assigning it to the difference pointer.
3356880	3359680	So I'm basically assigning a structure to a structure
3359680	3361600	or reassigning a value to a structure.
3361600	3363280	And it works out of the box.
3363280	3366000	The compiler will of course optimize totally away
3366000	3369280	the creation of the temporary or not so temporary object.
3369280	3372960	It's not gonna be there, it's what the compiler is gonna do
3372960	3377280	is it's going to directly assign to your dereference PA
3377280	3379200	or through the PA pointer,
3379200	3382080	totally skipping all the logic on the way.
3383200	3384320	So that's how we would do it.
3384880	3385760	What's even better?
3389520	3391040	And that's just modernity.
3391040	3393280	Sorry, I had to put the static one there.
3393280	3393920	I don't know why.
3394880	3399120	What's even better, you can use it to zero things.
3400160	3402560	In the old good times, you would call memset.
3402560	3404560	If you want that, like in the array free,
3404560	3405920	when you first freed the data
3405920	3408000	and then zeroed the whole structure just to be sure,
3408560	3410880	you would call memset on anything.
3410880	3411600	It works.
3412720	3416160	It's everywhere in the old C code zeroing
3416160	3418160	because otherwise you get nasty bugs.
3419600	3421920	Nowadays, you can write it like this.
3422880	3427280	So you just assign a new value into your structure
3427280	3428400	and it's a zeroed value
3428400	3430480	because it uses empty initialization.
3431040	3435280	Now, the compiler will memset it for you actually.
3435280	3436640	If you write code like this,
3436640	3438320	what the compiler will emit,
3438320	3441120	depending on the size of your structure,
3441120	3447840	is either a few Mambo jambos with the XMM registers
3447840	3450880	to zero your structure directly
3450880	3452240	or it's going to call memset
3452240	3456880	if the structure is big enough to call memset.
3457520	3458720	So you don't have to do it.
3458720	3460560	Compilers understand what you're doing.
3460560	3462160	You have to express what you're doing
3462160	3464720	and let the compiler choose the best way to do it.
3466720	3467520	And that's not it.
3467520	3469200	That's not the end of the story
3469200	3471760	because unfortunately I said that there will be some macros
3471760	3473600	and I know it's late.
3475200	3477200	I think it's a good time for macros also
3477360	3481840	because either it puts people to sleep
3481840	3485120	or it makes them totally awake.
3486400	3487440	So let's do macros.
3488800	3492240	Compound literals can be used as arguments to functions
3492240	3494000	and for a good reason.
3494880	3496480	Like, look at this one.
3496480	3497920	It's a big ugly, right?
3497920	3499280	And there are even coding styles
3499280	3501680	which say that if you have to pass more than three
3501680	3503600	or four arguments,
3503600	3504960	then you should pass by structure.
3505920	3507600	There are coding guidelines
3507600	3509600	and so you shouldn't do things like this.
3509600	3510880	We agree on it, right?
3512800	3515120	First of all, this first argument
3515120	3518400	should be taken as a erase of static one size
3518400	3519920	but that's something else.
3519920	3521600	Now in this slide it is
3521600	3523360	because we already did it correctly.
3523360	3525200	We use the modernity to signal
3525200	3528480	that you have to pass valid objects to the blur function.
3529600	3532400	And of course what you then do
3533040	3536800	is create a param structures
3536800	3539760	and pass the address of the param structure to the function.
3539760	3542400	Much, much better, however, still ugly, right?
3542960	3544080	That's not what you do.
3544080	3545360	That's not what you want to do.
3546800	3549440	The first insight that you might come up with
3549440	3552160	is that the struct can be created in place
3552160	3554720	because, hooray, we have compound literals.
3554720	3556640	So why would you even create the structure
3556640	3559200	like outside of the function call?
3559920	3560480	Let's do it.
3561440	3564320	And I don't know if it's more readable.
3565680	3566400	No, it's not.
3567200	3569040	But it certainly looks cooler.
3570960	3572960	So your cool factor directly goes up.
3574720	3577280	That's a good idea to do something like this, right?
3578480	3579920	And then the second insight,
3579920	3583600	and this is a really breakthrough,
3583600	3586960	is when you realize that when you look at it,
3587600	3590320	some of those fields are actually kind of having
3590320	3591760	like default values.
3591760	3594800	Compute hardware is set to zero.
3594800	3596400	It's a default value.
3596400	3597920	Type box, I'm not showing it,
3597920	3600000	but maybe it's an enum or something like this,
3600000	3602160	also with a default value of zero.
3602160	3604400	And since we're using designated initializers,
3604400	3605440	we can skip those
3605440	3608000	because the rest will be zeroed automatically.
3608880	3612400	So you can pass only what you want to pass directly in place.
3613680	3614640	And that's good.
3614640	3616400	That's much, much better, right?
3617920	3620160	Not only your naming arguments now.
3620160	3621840	Named arguments are also cool, by the way.
3621840	3623920	You're naming it with a designated initializer.
3623920	3626000	You don't have to pass all the arguments.
3626000	3632400	Now, and because, as I said, it's also about macros.
3632400	3636880	When you add just one single macro magic line to the mix,
3637440	3639600	you can start writing code like this,
3639600	3642000	which totally looks like named parameters
3642000	3643440	or named arguments in C.
3644160	3647680	And they are, I mean, those look like named arguments.
3647680	3650160	And of course, the rest takes a default value of zero
3650160	3651680	of what you would not pass.
3652480	3654880	The macro itself, I'm now,
3655600	3658400	yeah, I have doubts whether it's a good statement now
3658400	3659600	that it's not much magic.
3661040	3662960	But let's assume it's not much magic.
3662960	3666400	I mean, it was middle of the day when I was writing it,
3666400	3667760	so you have to forgive me.
3668880	3671440	It's hash defined blur, obviously.
3671440	3675040	And for those of you who don't know this,
3675040	3679760	three dots in a macro mean variable number of arguments
3679760	3683040	that you can pass through in your macro expansion.
3683600	3685760	And that's exactly what I'm doing, right?
3685760	3688320	I'm just passing it through in my macro expansion
3689280	3691920	under the name VA underscore arcs.
3692480	3694800	This is how you pass through variable number,
3694800	3697760	variable arguments in C.
3697760	3698400	And it works.
3698640	3701920	All of a sudden, you can use this beautiful syntax in C.
3701920	3703920	Actually, also in C++ node,
3703920	3706720	because it doesn't have the compound literals.
3706720	3708320	So you cannot do this in C++,
3708320	3710320	but I'm pretty sure you can use other tricks there.
3714160	3719680	And I already said how it works, so I'm not going to repeat it.
3720960	3723520	And I'm sorry for this slide, but I had to put it there
3723520	3726400	that it went with a little effort,
3726400	3731600	a little effort, some arbitrary default values are also possible,
3731600	3735680	because up to now, if you didn't pass a value explicitly,
3736480	3737840	it would get a value of zero,
3737840	3740480	like it would be empty initialized in your structure.
3740480	3743360	So only zero default values were possible.
3743360	3744240	Well, that's a lie.
3746000	3750480	You can have default values by just specifying them in your macro.
3751600	3755840	If you don't specify them, when you call later the macro,
3756480	3760000	with your designators, the default values will be taken over,
3760560	3761520	and they will be used.
3762080	3762480	Great.
3764320	3766960	If you do specify them, like I do with here,
3766960	3772800	with here is specified as 64, and by default, it is 32.
3772800	3776000	Well, the 64 will be taken,
3776000	3780560	because in the initializer list, it is after the first initializer.
3781360	3786000	It emits a warning, as it should, right?
3787040	3790160	The compilers know that we have something bad in mind,
3791360	3793280	and they rightfully warn us about it.
3793920	3798720	This warning can be silenced with a couple of pragmas
3800480	3802000	that you can build into your macro.
3806480	3809120	And when I do this, when I later publish this,
3809120	3812320	because you will have access to it, this slide will be there,
3812320	3814560	but I knew it would be after 5 p.m. now,
3814560	3816000	so I skip this slide for now.
3817840	3821760	But with a bit of pragmas, you can remove the initializer
3821760	3824160	overwrite warning and do magic.
3825200	3826480	So that's compound literals.
3826480	3827680	They're really cool.
3827680	3830480	There are L values that allow you to do crazy things,
3830480	3835760	like zeroing the whole objects, initializing objects in a very
3836720	3840800	simple way, or even create default arguments to functions.
3841600	3843600	And since we are talking about structs,
3843680	3848000	and it's not like my favorite hobby topic,
3848800	3850000	but I use structs a lot.
3850000	3853280	I do a lot of what you call low-level programming,
3853280	3857120	system programming, obviously in C,
3858080	3861600	and I deal with structs and memory allocations from time to time.
3862800	3866320	So let's talk about one less crazy thing,
3866320	3870720	and this is the real one last crazy thing
3870720	3871680	that I'm going to talk about.
3872640	3875680	Let's make a string, something that you've already seen,
3875680	3878240	because we already were doing an array a moment before.
3879760	3882480	The layout was a bit different, if I remember correctly,
3883360	3886320	but, you know, you get the gist of it.
3886320	3888400	Again, the length, the size of the array,
3888400	3890880	and the pointer to the dynamically-arrowed array.
3891520	3895360	And now you imagine that you want to create a function
3895360	3897920	that creates such a string for you.
3897920	3900320	And because we are living in a dynamic world,
3900320	3905680	we want not only the memory that the array is pointing to
3905680	3907440	to be dynamically allocated,
3907440	3910480	we want the whole structure to be dynamically allocated.
3911680	3913840	So you come up with a piece of code like this.
3915200	3917120	You take a pointer to a string,
3919040	3922400	to the const car, sorry, a valid pointer, of course,
3922400	3925840	and then you do the first malloc to allocate the whole string
3926800	3928160	structure.
3928160	3932320	And if this one is valid, because you have to check in line 5
3932320	3934160	if it's valid, you do another malloc
3934160	3938000	to allocate the sub-object of the array, right?
3938000	3941440	And because this code is very complex,
3942080	3944320	all of a sudden, you have to, for example,
3944320	3946480	check whether your second allocation,
3946480	3949280	so the dot array is malloc, succeeded.
3949280	3951600	Because if it didn't succeed, you have to free,
3951600	3953600	again, the whole structure and return null.
3954480	3958400	And this is a code that invites errors,
3958400	3961760	like just by the sheer length of it
3961760	3966800	and number of pointers that appear there and mallocs.
3968000	3970560	So you don't want to write code like this.
3971440	3974080	Not only it is fragile, because you have to remember about,
3974080	3976080	like, and especially if it's like a bigger thing,
3977040	3978480	you have to remember about freeing,
3978480	3980240	about checking all the pointers.
3980240	3982800	It's also not really optimal.
3982800	3985600	You need twice to malloc, and that's bad.
3986480	3988000	It's a costly operation.
3988880	3992400	Depending on your luck or the lack of luck,
3993200	3996240	you might end up with fragmented memory.
3996240	3997920	Your data structure might end up
3997920	3999840	in a totally different piece of memory
3999840	4002400	than your array that's a part of this data structure.
4002400	4004640	You don't want something like this, right?
4004640	4005600	It's expensive.
4005600	4006240	It's bad.
4006240	4009600	What you want is a one-pic nice block of memory
4009600	4011040	which contains everything.
4011040	4012720	Array, there is a solution for it.
4013840	4017600	This solution, and that's actually why I have a layout like this,
4017600	4020000	why the car pointer is the last pointer there,
4020800	4023920	is called the flexible array member.
4023920	4024720	And it looks like this.
4025920	4030320	Structures in C can have an array of undefined size
4030320	4031440	as the last member.
4032320	4034480	And this is not just a pointer.
4034480	4038000	This signals that at the end of the structure,
4038000	4040800	there is an array which is a sub-object
4040800	4042960	or actually a member of this structure,
4042960	4044720	and you're going to define at the runtime
4044720	4045920	what the size of it is.
4047040	4050400	This string is also an incomplete type all of a sudden
4050400	4053200	because it doesn't have any proper size anymore.
4054320	4058320	Because the length of this is unknown at compile time,
4058320	4059120	at the compile time.
4059120	4060880	You can only set it up during the runtime.
4063120	4064400	So it must appear at the end.
4064800	4068000	And you cannot basically do anything with this string
4068000	4069520	anymore that's fancy.
4069520	4073360	Like you really cannot make an array of these strings directly.
4073360	4077440	It's not going to work because this doesn't have a definite size.
4078240	4079600	So that's not going to work.
4080960	4085600	But what you can do, I mean those are all the things you cannot do,
4085600	4087360	and I already told you what you cannot do,
4087360	4090560	what you can do is skip one malloc all of a sudden.
4090560	4092160	So instead of having two mallocs,
4092160	4097840	I now have one that takes care of allocating my base data structure.
4097840	4100400	And now if you use the size of,
4100400	4105920	it's only going to count the members that have a fixed size.
4105920	4107520	So it's not going to count the array.
4108640	4113200	And then you take the size of your string
4113200	4118160	that you want to put in your array and allocate it all at once.
4118160	4120480	There is no free, needed, no checks.
4120480	4123680	Actually, one check is needed because I mean,
4123680	4127920	I still need to properly initialize using the compound literal,
4127920	4130960	of course, because you already know how it works.
4130960	4131920	So why not?
4131920	4134320	And then copying the whole struct and so on.
4134320	4136880	And the layout becomes something like this.
4137440	4139920	So it's a contagious block of memory,
4140560	4142160	much better for your performance,
4142160	4145120	much better for your sanity, actually,
4145120	4148160	because the more mallocs, the less sane you become.
4150560	4154160	Unless you use sanitizers, yeah.
4155520	4158000	So only one malloc, no wasted space.
4158000	4160480	And one malloc space overhead.
4161920	4164400	And still I have, since I still have time,
4164400	4166080	I'm going to do this one.
4166080	4169680	And I'm going to do a very short demonstration at the end.
4169680	4170560	Because why not?
4171920	4172720	Let's do.
4172720	4174400	First, macro magic incoming.
4174960	4176640	This talks and with macros.
4177200	4181920	So you are shaken awake properly before the evening starts.
4184160	4186720	And we are going to talk about function overloading in C,
4186720	4188480	also known as generic selection,
4188480	4190160	because that's also a feature of C.
4190800	4193680	C can overload functions.
4193680	4194800	You wouldn't believe it.
4194800	4196720	It just does it in a bit different way
4196720	4198240	than normal people are used to.
4200320	4204640	Imagine that you have two different structures
4204640	4207440	and they're obviously shapes, like a circle and a rectangle.
4208000	4209920	And you want to write a scale function,
4209920	4213840	which takes those structures and scales them with some scale.
4214800	4217680	Now, you cannot have something like this in C, right?
4217680	4219280	Very unfortunately, you cannot,
4219280	4223440	because C doesn't know what name mangling is.
4223440	4224640	So it's not going to fly.
4226560	4228800	You need to, instead of having two scale functions,
4228800	4232000	you need to name them correctly,
4232000	4234720	like scale, circle, scale, rect, and so on.
4234720	4238480	And let's be honest, this is ugly.
4238480	4240880	I mean, I don't like code like this,
4240880	4241840	and this is not a joke.
4241840	4244320	I mean, why would I need two different names
4244320	4246080	for a function that does exactly the same?
4246720	4248640	I would prefer to have one function name.
4249280	4253120	And luckily, this is possible.
4253120	4256480	And as everything that's possible in C,
4256480	4258080	it's possible thanks to the macros.
4259040	4263760	C already, again, I think in C11, if I'm not mistaken,
4263760	4268160	introduced a new macro called a generic selection macro,
4269280	4272640	which works on types and switches based on types.
4273280	4275600	So it's like, it's basically a switch statement
4275600	4276800	if you look at it.
4276800	4279920	So in the first, you have the controlling expression,
4279920	4281680	just like in the switch statement.
4281680	4282720	And then you have the cases.
4283920	4286640	If it's type one, type two, or type three,
4288720	4292400	not really return everything, but replace my macro with this
4292400	4295040	because macros are about text substitution.
4296160	4298000	So depending on a control statement,
4298960	4301120	on the value of the control statement,
4301120	4303040	actually on the type of the control statement,
4303760	4305120	you get different things.
4305120	4307200	You can replace based on the types
4308640	4310880	your whole macro block with something else.
4310880	4313680	There's also a default because it's really like a switch statement.
4313680	4314880	So there is a default clause.
4315520	4318880	And this doesn't require lots of coding.
4318880	4322480	If we have two ugly functions, like scale,
4322480	4327680	circle, scale, rectangle, we can just do define object scale,
4327680	4330320	which is going to be our function like macro.
4331200	4334000	And then do this generic selection,
4334000	4337360	switching on the object based on the type of the object.
4337360	4342640	If it's a rectangular substitute with scale rectangles,
4342720	4346080	with scale rectangles, are they wise scale, circle?
4346640	4350080	And basically this whole block of those lines of code
4350080	4352640	is going to be substituted with either scale,
4352640	4355760	scale, rect or scale, circle, depending on the type.
4356960	4359360	And of course, since it's actually not a textual
4360560	4362880	substitution, you still have to call the parameters
4362880	4366640	or pass the parameters later on to the correct function.
4366640	4368080	And all of a sudden this works.
4368080	4370880	This is so popular that this is now part of the standard library.
4371840	4375600	Math functions are already standardized to use generic selection
4375600	4378560	because before you had like, you know,
4378560	4381280	for every single math function you had at least three variants
4381280	4384160	or sometimes more, depending on the argument type.
4384160	4389040	So now all of them got macros to enable this kind of magic.
4389040	4392000	Doesn't always work that great, must say,
4394000	4397440	because integer types get confused with Booleans sometimes.
4398320	4403280	If you are below C23, starting with C23, not anymore,
4403280	4406000	but before they get confused.
4406000	4408720	That's because a Boolean was just a type for Boolean.
4408720	4411920	And yeah, sorry for something else.
4411920	4415680	And it doesn't matter, works great.
4416880	4419120	And I just want to end up with a big bank.
4420480	4423200	You can also overload on the number of arguments,
4423200	4424320	if you really want to.
4425280	4428720	And if you really want to, I don't know.
4429840	4430960	There's no pub quiz, right?
4430960	4432720	So it's nobody to impress tonight.
4432720	4437200	But no, no, this is the kind of things you try to impress your colleagues with
4438000	4438880	during a pub quiz.
4439600	4442160	You can also do overloading of known arguments.
4442160	4445680	So imagine you have like circle, just there is one scale,
4445680	4450240	but for the rectangle, there's either the vertical or the horizontal scale.
4450240	4454880	So we take a separate two different scales or just one general scale.
4455440	4459600	And we would like to again be able to do the magic that we've done before.
4459600	4464320	So call depending, use the same name to call both of them.
4466000	4469280	The bad news is that generic is not going to help you that much
4469840	4475760	because you cannot put it in, I mean, it doesn't expand the macros within it.
4476560	4479520	So that doesn't work like this.
4480240	4484560	But the good news is that you can do still generic selection
4486160	4490800	for scale 2P and scale 1P, depending on the argument type,
4490800	4492080	just like I did before.
4493920	4497440	I mean, with a small difference, there is now a variable number of arguments
4497440	4500960	passed to the macro to account for one or two arguments.
4500960	4502640	Actually not, I think I was lazy
4503600	4506480	because those are fixed number of arguments for both cases.
4506480	4508400	I was lazy, sorry.
4509680	4511680	And then you do a classic trick.
4512880	4515520	Once you have those two generic selectors,
4515520	4519360	you do the invoke or the substitute trick, whatever people call it,
4520640	4524880	that's used to select a name from a list of names.
4526000	4528560	The invoke basically takes a number of arguments.
4528880	4532160	And depending on the number of arguments that you pass to invoke,
4532160	4534320	it will select different names.
4535440	4538240	I don't want to talk about the mechanics of it now,
4538960	4541200	mostly because I am not able to anymore.
4542960	4544240	That's number one reason.
4544240	4548640	The number second reason is I understand it,
4548640	4550800	but I will forget it after three days,
4550800	4552400	and I will have to look at it anyway.
4552400	4554240	If you want to use it, look it up.
4554240	4556640	Unless you're really coding daily with these kind of things.
4557440	4561280	But that's the standard way of selecting a name from a list of names
4561280	4565280	based on the number of arguments passed to the selection statement,
4565920	4567520	and then it will work.
4567520	4569040	So that was the generic selection,
4569040	4570480	which makes writing code much easier,
4570480	4572560	can be nested from multiple selectors
4574720	4576800	and suffers from all the macro shortcomings.
4577920	4581120	And generally speaking, this was almost all,
4581120	4582640	that's the slide that you've seen,
4582640	4586160	it's incorrect because I don't know
4586720	4590640	want to do a five minute quick code refactoring,
4592400	4593600	just to wake you up a bit.
4595200	4600960	And I'm going, you see, I have something like a vector,
4601520	4602640	so what we've been doing,
4603200	4606400	and a very deep function vector create,
4606400	4609760	written in the old style, like the totally old style.
4610800	4612240	It's taking a double pointer,
4612480	4617680	so it's, and the reason it's not why not,
4617680	4621120	the reason is because then it can write back to the pointer,
4621120	4624240	that the pointer points to something like this, right?
4626160	4631600	Something you shouldn't be scared when you see the code in C.
4631600	4635520	I am compiling on the only compiler that accepts C23,
4635520	4636960	this is the GCC trunk,
4637680	4642160	and it works now because it's written in correct old C,
4642960	4645600	with all the warnings, no warnings are popping up,
4645600	4647840	sanitizer doesn't kick in, good work.
4649280	4650960	We want to make it modern C,
4650960	4654720	and there are a couple of things when you see code like this,
4654720	4656080	that you have to take care of.
4662080	4666400	First, let's look at the return type, which is totally wrong,
4666480	4670000	I'm using the old style of returning integer,
4670000	4674080	like a negative is a mistake, positive is everything is okay,
4674080	4680400	and since we are on C23, we can do this out of the box,
4680400	4683200	we can return, I should return false actually here,
4683200	4684640	instead of minus one,
4684640	4687360	so that's the correct way of doing things, right?
4692400	4695760	And that one being the last one, this should be true.
4696160	4699280	Still compiles out of the box, no warning,
4699280	4702960	I don't include any header whatsoever to enable Boolean magic.
4704080	4707520	The next thing is actually I don't accept null pointers,
4708240	4713120	so maybe fix also that one, and put static one in here,
4714400	4719680	and if you do it, all of the sudden, you won't be able to pass
4720480	4726320	null into the function, it's not going to work,
4727440	4729440	because the compiler, I mean, it's going to work,
4729440	4732720	but the compiler will tell you that you are trying to pass a null
4732720	4734400	to a function that doesn't accept it.
4735120	4738640	A great thing, you have to pass a valid pointer.
4739920	4743440	What's next, I don't like null pointers,
4743440	4746160	I mean, I don't like null because it's not strongly typed,
4746800	4751040	null ptr, null pointer is a strongly typed alternative nowadays
4751040	4755600	in C23, use it, there's also null ptr underscore t
4756720	4759520	as the type of it, just same as in C++.
4761120	4763920	Define, nah, not really, right?
4764880	4768080	This is bad, and I don't mean to put it here,
4769040	4777520	we have constexpr, constexpr size t, I'm using capitals, I know it's bad,
4780160	4781120	but let it be so.
4783040	4786560	The compiler got a bit crazy, it doesn't understand really what I do,
4786560	4789600	because it says set but not use, which is not true,
4790800	4793760	I think that's, yeah, that's it, it's just too new,
4793760	4796960	it also doesn't work with auto by the way, and it should,
4796960	4800160	but then it totally, I mean, it goes monkeys.
4801360	4806880	So let's keep it like this, we're fine, so far so good.
4809680	4816720	Look at this, I'm doing the old style initialization, that's something,
4817280	4820720	you know, that's shameful nowadays.
4820720	4823440	If you do code like this, you should be ashamed,
4823440	4825600	because you have compound literals nowadays,
4825600	4829120	they are much better, express your intent better.
4829120	4830880	Why don't you do it, let's do it.
4833280	4838080	The change is not that bad, we have to put, I mean, it is bad,
4838080	4839360	but let's pretend it's not.
4840240	4845040	You have to put vector there, and then spell out the names,
4845040	4848480	we have dot data is equal to that one,
4849280	4857120	and it's not gonna compile out of the box, of course, dot capacity is that one,
4859440	4864160	and dot, it was size is that one, close that,
4865920	4868160	put the commas where they should be put,
4870960	4876480	and are we good, we are almost good, I mean, I did it incorrectly, of course,
4876480	4881920	but because I should have done that one here, small change, don't worry,
4883040	4886720	I am an expert, famous last words, right?
4888960	4892800	Okay, so we should initialize it like this, and the vector itself
4895360	4902000	should be still done with malloc size of vector, so let's do it correctly.
4902160	4908000	This code doesn't compile now without, I mean, it compiles without warnings.
4911120	4916720	If I'm not mistaken, let's compile without warnings, control itress, now it's not true.
4921840	4928000	Line 30, oh yes, yeah, that goes away, of course, thank you.
4928000	4930880	So it compiles without warnings, that's fine.
4932960	4937280	But then you have to notice, or actually, you should think about what you're doing,
4937280	4943440	you're doing again something that I told is not really cool, I'm doing a double mallocation, malloc,
4945440	4950800	because my structure is allocated and my data is allocated, there is first malloc to allocate
4950800	4955760	the structure, then the second malloc to allocate the data, it's hidden here and the
4955840	4960800	cast to double is not needed, by the way, in CU you can just cast without this one.
4962400	4967520	What to do about it? Change, of course, the data type to a flexible array member
4968880	4975680	or the field type, so do something like this, and now it's not going to work
4976400	4979680	like it worked before, now it's going to work much, much better,
4980400	4988480	because what you can do is malloc size of the vector itself plus
4990080	4999680	size of capacity multiplied by size of debo, I'm doing, I wanted to actually double
5000640	5009760	malloc and capacity, and it has to go, let's put it where it was,
5011200	5017520	let's move those up all the way where they belong to, because now it makes sense,
5017520	5024160	so I'm allocating everything at once, the whole array, as it should be allocated,
5024160	5032720	and then I don't need this one anymore, I do need to most likely return quickly,
5032720	5038720	if I don't manage to malloc, because that's still needed, and if I do manage to malloc, well,
5039520	5044080	all I need is actually that one, so I need to set the capacity correctly,
5045680	5050400	and that's done with 1.9, and I don't free anymore, because that's also not needed,
5051200	5057840	so my code now became like at least twice as short, I shouldn't return true,
5057840	5064800	can I return true here? Yeah, I can, or I can return just vector is different than null pointer,
5066800	5074640	which is a nice way of spelling the same thing, and do here is vector different than null pointer,
5075280	5086000	then I'm gonna assign the new capacity to it, and that's it, if I am not mistaken,
5086000	5092720	that's the end of the refactoring of doing it more modern, using modern proper syntax,
5095360	5102960	is it better? I think it's more readable, I think it's easier to maintain, because you don't have
5102960	5108720	so many lines of code, and you don't have so many branches, there are not so many ifs like before,
5108720	5115120	not so many else, and so on, and so on, and it doesn't compile as some of you most likely notice,
5115120	5122240	because I'm freeing something, I shouldn't be freeing now, I was freeing still the data,
5122240	5128560	and I cannot free the data separately now, because data is now a sub item of my big structure, right?
5128560	5139520	So that's all, that's really all, and that's the summary of it, don't be afraid of modernity,
5141280	5145120	some features really boost productivity, especially things like initializer,
5145120	5151840	designated initializers, and compound literals, do boost productivity enormously, some of them
5151840	5158000	will really help you with safety with pointers, when you use the variable length arrays syntax,
5158000	5164640	when passing things to functions, or when declaring multidimensional arrays, or even single
5164640	5170480	dimensional arrays, it's going to help you with safety, compilers are getting better and better,
5170480	5177520	like basically every year there is a new warning appearing, that wasn't there before for variable
5177520	5184240	length arrays, some features are scary, like using macros, this is always scary,
5184960	5188880	what's even more scary is chart GTP is very good at it,
5191760	5198560	and compilers will understand modernity and help you, when you zero using the compound
5198560	5204800	literals they will do memset under the hood, they will optimize away all those actually L values,
5204800	5209360	don't worry about it, like even if you're passing the whole structure to the function
5209360	5214800	through a compound literal, some compilers do optimize away a lot of it, and you don't pass
5214800	5220960	what you don't need to, thank you very much for listening, we have exactly 45 seconds left,
5222960	5227840	which is like perfect timing, but you can ask me later on questions if you have them,
5228800	5235120	so thanks again for coming here and staying with me awake, which is like a huge achievement
5235120	5240880	for all of you, so thanks a lot guys
