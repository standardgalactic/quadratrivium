WEBVTT

00:00.000 --> 00:25.520
So I'm Will and I was a middle school teacher and I ran a summer camp and I did all these

00:25.520 --> 00:30.680
things and then at some point I got a degree in computer science and I worked as a Java

00:30.680 --> 00:32.920
developer and all this stuff, right?

00:32.920 --> 00:37.880
And then I got fed up with the JavaScript and the Java and all that and I went to graduate

00:37.880 --> 00:43.120
school at Indiana University to work with Dan Friedman who you may have heard of.

00:43.120 --> 00:49.740
He's someone who wrote a book called The Little Lisper and a revised version called The Little

00:49.740 --> 00:52.040
Schemer and The Season Schemer.

00:52.040 --> 01:02.080
I wrote a book with him called The Reason Schemer and I took Dan's class the first semester

01:02.080 --> 01:09.440
I was there and a couple of weeks in to the class, Dan showed me a program that changed

01:09.440 --> 01:18.080
my life and basically I spent the last 12, 13 years trying to understand these five lines

01:18.080 --> 01:20.140
of code, right?

01:20.140 --> 01:25.620
And I will spend the rest of my life trying to understand the implications of these five

01:25.620 --> 01:29.260
lines of code and this is what I like, okay?

01:29.260 --> 01:33.980
So some people like writing a hundred thousand line compiler or an operating system kernel

01:33.980 --> 01:37.460
with two million lines of code or whatever and that's great.

01:37.460 --> 01:40.740
What I like is sort of going the opposite way.

01:40.740 --> 01:47.100
I like the 3 by 5 card or the 4 by 6 card and if you're not an American, I don't know

01:47.100 --> 01:55.620
what that is, it's A4 or something, I don't know, it's like a 3 by 5 card, maybe a 4 by

01:55.620 --> 01:56.620
6 card.

01:56.620 --> 02:03.460
If you can't fit down the idea on a 4 by 6 card, then think harder.

02:03.460 --> 02:06.060
That sort of Dan's philosophy, right?

02:06.060 --> 02:10.380
And ideally you get it down to the 3 by 5 card and then you write a little book on it

02:10.380 --> 02:17.060
and so that's kind of his way of thinking and I share a lot of that sensibility.

02:17.060 --> 02:22.580
So what I would like to talk a little bit about today is this program that I saw and

02:22.580 --> 02:25.300
it just floored me.

02:25.300 --> 02:30.260
And to this day I get nerd chills every time I think about it, right, I really get nerd

02:30.260 --> 02:38.900
chills and I think, you know, I was nervous about, I am nervous about giving this talk

02:38.900 --> 02:43.620
because one of the dangers I think is that when you've been programming for a while and

02:43.620 --> 02:48.380
I know a lot of people in this audience like NoLisp or they've worked through SICP or they've

02:48.380 --> 02:51.180
written lots of interpreters and all these sorts of things, they know something about

02:51.180 --> 02:58.500
Lambda Calculus, after a while you can feel like you understand something and that's the

02:58.500 --> 03:03.980
most dangerous way of thinking is to think you understand something, right, and that

03:03.980 --> 03:11.420
there are no, you know, kind of new tricks in this and basically every time I learn something

03:11.420 --> 03:15.980
new about computer science or, you know, every couple of years or something like that, I

03:15.980 --> 03:22.140
like to go back and try to think about those things which I learned a long time ago and

03:22.140 --> 03:25.340
I'd stop thinking about, you know, because I thought at least, you know, I've got some

03:25.340 --> 03:31.740
grasp of this and almost always I'll have a new angle, right, and for the really, truly

03:31.740 --> 03:38.780
deep ideas, computer science or anywhere in the other field, you know, there are many

03:38.820 --> 03:45.020
ways of looking at these deep ideas and I'm going to show you, you know, a couple ways

03:45.020 --> 03:51.460
of looking at this program but I'm not kidding when I can say that I'm going to spend the

03:51.460 --> 03:55.500
rest of my life trying to understand it and there are many other people who've tried to

03:55.500 --> 04:02.020
spend, you know, their careers basically understanding aspects of this five line program and, you

04:02.020 --> 04:08.060
know, to give you sort of a reminder of, you know, a five line program, the amount of complexity

04:08.180 --> 04:13.580
you can fit in there. Does anyone know about the Colatz function? What's the Colatz function?

04:19.420 --> 04:25.900
Yeah, it's this little function, you know, like three in plus one and, you know, you have

04:25.900 --> 04:31.260
like a division by two or something like that and, you know, basically you're trying to figure

04:31.260 --> 04:38.060
out if you give an integer, a positive integer as an input, will this operation terminate?

04:38.060 --> 04:41.260
It's just got some multiplications, additions and divisions, right, and it's like the tiny

04:41.260 --> 04:47.340
little program and, you know, it's like a three line or two line program and the best mathematicians

04:47.340 --> 04:53.260
in the world have been trying to prove for many decades utterly without success that this

04:53.260 --> 04:57.540
program always terminates if you give a positive integer and Paul Erdisch, one of the great

04:57.540 --> 05:03.940
mathematicians of all time, at one point said, mathematics is not ready for the Colatz

05:03.940 --> 05:11.140
problem, right? So that's a three line program who's stumped some of the greatest minds in

05:11.140 --> 05:17.420
history. So I'm talking about like a five line program, okay? So that should give you pause.

05:18.260 --> 05:24.460
That should give you pause and we all have to have a healthy amount of respect for the three by

05:24.460 --> 05:33.900
five card program. So anyway, the program I'm going to talk about is an interpreter for Lisp

05:33.900 --> 05:42.140
written in Lisp. And it's one of these things where if you don't know Lisp and you first see it

05:42.140 --> 05:46.060
and you're like, oh, what are these parentheses? And then after a while you kind of start thinking,

05:46.060 --> 05:51.260
what is this lambda thing? That's something to wrap your head around. And why are there two

05:51.260 --> 05:56.700
lambdas like nested? What does that mean? And you kind of go over these different ideas at

05:56.700 --> 06:00.380
the time and eventually you kind of get some sense. You trace through a bunch of programs and

06:00.380 --> 06:04.300
you're like, all right, I kind of get some sense of what's going on. And then you start modifying

06:04.300 --> 06:11.100
the interpreter. And one of the great things about this program is that there's so many ways to change

06:11.100 --> 06:16.940
it and explore it and play with it. You can add arguments to the interpreter. You can rewrite

06:16.940 --> 06:24.380
the interpreter in a variety of correctness preserving transformation styles. One program

06:24.380 --> 06:29.260
transformation you can apply is something called continuation passing style, which I consider

06:29.260 --> 06:35.020
the gateway drug of program transformations. You know, normally you CPS that sucker and then from

06:35.020 --> 06:42.540
then on, you know, it's off to the races. So, you know, you CPS an interpreter, you CPS it twice,

06:42.620 --> 06:50.860
that gives you delimited continuations. And now you're cooking with gas. You can add a store

06:50.860 --> 06:58.940
argument to the interpreter, right? You can add boxes and you could start doing, you know,

06:58.940 --> 07:04.620
mutation and side effects in different ways. You can do call by value versus call by need versus

07:04.620 --> 07:11.980
call by name trivially, right? You can do all sorts of things that are really deep and give you

07:11.980 --> 07:16.620
deep insights into concepts of programming languages that you'll use, you know, the rest of your

07:16.620 --> 07:24.220
career or the rest of your hobby years or whatever. And so I don't know of any other artifact in all

07:24.220 --> 07:29.820
of computer science that packs so many ideas and the potential extensions to explore so many

07:29.820 --> 07:40.300
different areas as this interpreter. And in fact, you know, Alan Kaye says that when he first saw

07:40.300 --> 07:47.020
the Lisp interpreter written in Lisp at the bottom of page 13 of the Lisp 1.5 manual, right?

07:47.660 --> 07:52.940
It changed his life and he realized these are Maxwell's equations of software, right?

07:52.940 --> 07:57.660
It's very much the same right down four little equations. It helps if you like take them from

07:57.660 --> 08:02.940
the other mathematicians and physicists and call them mathmen. But you said, you know, you write

08:02.940 --> 08:07.660
down the four equations and you put that on the three by five card, right? And then you spend the

08:07.660 --> 08:12.620
rest of your life trying to understand what those four equations are, what the implications are.

08:12.620 --> 08:19.340
So that's very much what this interpreter is. And I'm, you know, I can't do justice to it.

08:19.340 --> 08:26.060
I can only show you a couple of the many aspects of this multi-aspected, you know, beautiful system

08:26.060 --> 08:31.740
and many of which, you know, I feel like I'm a complete noob too. But I can tell you that

08:31.820 --> 08:37.500
there are very interesting things out there. So, for example, there's this idea of reflective

08:37.500 --> 08:41.660
towers of interpreters. We have an interpreter interpreting an interpreter interpreting an

08:41.660 --> 08:47.820
interpreter. That part's already interesting. But when you have infinitely deep tower or

08:47.820 --> 08:52.220
infinitely tall tower, that's when it starts getting fun. And in particular, it becomes

08:52.220 --> 08:57.340
especially fun when the interpreter being interpreted by another interpreter can reach

08:57.340 --> 09:04.860
back up into the interpreter interpreting it and change the semantics of itself by changing how

09:04.860 --> 09:11.100
the interpreter interpreting it works. And this is one of the things that Dan Freedman says he

09:11.100 --> 09:17.340
refuses to work on because it melted his brain too much. It's like basically the one thing that he's

09:17.340 --> 09:24.300
like, he won't touch anymore. So that's the sort of fun you can have. You know, it's bad enough

09:24.300 --> 09:28.380
having a five or six line program, but when you have infinitely many of them interacting in these

09:28.380 --> 09:33.260
ways, then you can do very interesting things. And if you're interested in that sort of thing,

09:33.260 --> 09:39.500
I would point you to the work of Kanichi Asai. And also, my friend Nada Min gave a keynote

09:39.500 --> 09:45.180
at Strange Loop a few years ago when she talked about this. I think she called the talk Programming

09:45.180 --> 09:50.300
Should Eat Itself. And she talked about this reflective tower idea. Okay, so that's just

09:50.300 --> 09:57.100
one aspect. You can go deep. You can go deep that direction if you want. I haven't touched that yet.

09:58.140 --> 10:03.180
I want to connect that with the thing I'm going to show you. And even the people who do

10:04.380 --> 10:09.580
this type of very bizarre programming, they kind of get scared look on their face when they start

10:09.580 --> 10:15.820
thinking about the implications. So that's a good feeling when you're scaring the veterans

10:15.900 --> 10:25.100
of the Lambda Calculus. So that's something I want to accomplish. And there are many,

10:25.100 --> 10:29.820
many other directions you can go. Program transformation, directions, different evaluation

10:29.820 --> 10:34.140
orders, all sorts of things. And then you can layer a type system on it, that kind of thing.

10:34.140 --> 10:38.860
Now you have the interpreter and a type inferencer and a share structure. And you can have them

10:38.860 --> 10:45.340
interact in interesting ways and all these sorts of things. So just like CPS is the gateway drug,

10:45.420 --> 10:51.820
program transformations, Lisp in Lisp is the gateway drug of the whole world of programming

10:51.820 --> 11:00.300
languages, I think. So what we're going to do is write an interpreter. We're going to write

11:00.300 --> 11:06.540
the Lisp in Lisp in the way that Dan wrote it. And Paul Airdish, the great mathematician, had this

11:06.540 --> 11:13.100
idea that there was a book that God kept that had every beautiful proof in it. Only the beautiful ones.

11:13.660 --> 11:17.900
And every once in a while, he or someone else would come across a particularly elegant

11:17.900 --> 11:23.020
and beautiful proof and say, oh, that's a proof in the book. And so we're going to see a program in

11:23.020 --> 11:27.500
the book. This is the program in the book. I've written hundreds of interpreters and I've read

11:27.500 --> 11:34.300
lots of books on interpreters, but this to me is the one in the book. Everything else is a pale

11:34.300 --> 11:43.580
limitation. All right. So who here is familiar with S expressions, symbolic expressions or

11:43.580 --> 11:49.820
some flavor of Lisp? I can read parentheses. All right. Maybe half and half. Okay. Well,

11:49.820 --> 11:54.540
I'll teach you how to do it. I'll teach you how to do it. And some of the things I'm going to show

11:54.540 --> 12:00.140
you, like I said, this is jam packed full of deep ideas and I can only scratch the surface,

12:00.220 --> 12:06.220
but even scratching the surface may leave you dizzy. If that's the case, close your eyes,

12:07.100 --> 12:14.700
lean forward, and the room will stop spinning. And then as we go on, you'll be able to hopefully

12:14.700 --> 12:18.860
pick up on some of the concepts and ideas and I'll show you some stuff at the end that maybe

12:19.580 --> 12:24.460
will be surprising to you, even if you don't understand all the details. And the great thing

12:24.460 --> 12:31.180
is that once you have some sense of what this is about, you will be filled with a fiery passion to

12:31.180 --> 12:37.020
learn all the rest. And I can point you to some references for that or we can talk about it over

12:37.020 --> 12:45.900
a milkshake. So the first thing I'm going to do is talk about lists. Let's talk about lists. So

12:45.900 --> 12:53.900
Scheme is a Lisp and Lisp comes from List Processing. That's what Lisp stands for, List Processing.

12:53.980 --> 12:58.860
So we're going to talk about lists and symbols. That's the first thing we're going to talk about.

12:58.860 --> 13:06.140
So let me go ahead and start up trusty Shea Scheme, which is now covered under an open

13:06.140 --> 13:13.820
source license. Woohoo! All right. So Shea Scheme has this thing called the REPL and it's pronounced

13:13.820 --> 13:21.900
REPL not REPL. And this you probably are familiar with if you've used other languages that have

13:21.900 --> 13:26.860
interactivity. One of the cool things about a good scheme implementation is that even though I'm

13:26.860 --> 13:32.060
typing expressions interactively, those get compiled on the fly directly to machine code.

13:32.860 --> 13:37.900
Actually, at least some versions of, say, Shea does an analysis first to determine whether or not

13:37.900 --> 13:45.820
it's faster to evaluate it or faster to compile and evaluate it. So this is faster in general than

13:45.820 --> 13:55.260
a lot of systems. Okay. Let's write a simple scheme program like 5. 5 evaluates to 5. All right?

13:56.940 --> 14:01.740
We don't have to make it evaluate to 5, but let's pretend that we will. Now,

14:03.260 --> 14:11.100
what else can we have? We can have a list containing 5 and you could see the list is

14:11.100 --> 14:19.180
represented by these beautiful parentheses. We can have a list containing 5 and 6.

14:20.620 --> 14:30.460
Notice that I did not defile my program with commas or anything else like that.

14:30.860 --> 14:45.820
We can have a list that contains a list. What do you think is going to happen?

14:47.180 --> 14:55.580
More parentheses. Look at that. We can go deeper. We can go as deep as we want.

14:55.820 --> 15:01.340
So we have lists. We can have lists of lists. What is another name for a list of lists?

15:02.860 --> 15:10.300
A tree. Oh, have you ever heard of trees? Right? Have you heard of this thing called XML,

15:10.300 --> 15:17.820
this new thing? Do you know what language came before XML? What language?

15:18.060 --> 15:24.220
SGML. Yes, right. Have you heard of something, a beautiful thing called XSLT?

15:26.060 --> 15:31.180
Brings joy into your heart. Do you know what the SGML equivalent of XSLT was?

15:32.460 --> 15:40.300
See who knows the obscure stuff. Dissil? Has anyone heard of Dissil? DSSSL? What is that?

15:40.860 --> 15:46.140
Dynamic style and semantics language or whatever, something like that. You know what Dissil was?

15:47.100 --> 15:55.500
It was Lisp. It was R4RS Scheme. Because if you're going to work on tree structure data,

15:56.620 --> 16:00.620
what's the right way to work on it? A tree is an inductively defined data type.

16:01.340 --> 16:09.580
How do you deal with that recursion? That's how you deal with trees. So Lisp is all about recursion

16:09.580 --> 16:15.500
and dealing with trees. Programs, most programs, represented as trees. If you're going to have

16:15.580 --> 16:21.900
a programming language that can modify programs, what better way to do it? Well,

16:23.020 --> 16:27.820
the Haas scholars will say there are better ways. But anyway, don't listen to them.

16:30.460 --> 16:35.660
Okay. So we have lists and things like that. By the way, if you want to learn scheme,

16:35.660 --> 16:41.020
there's an awesome interactive fiction game by Andrew Plotkin, aka Zarf, called Lists and Lists,

16:41.660 --> 16:47.500
where a genie teaches you to program and scheme. And you can actually implement logic programming

16:47.500 --> 16:52.460
inside of that scheme, although eventually you'll run out of memory because the Z machine doesn't

16:52.460 --> 16:57.900
have that much space. But anyway, it's a good exercise. So we have lists. We have lists contained

16:57.900 --> 17:03.180
lists, which are trees. We have numbers which evaluate to themselves. There are other values

17:03.180 --> 17:10.140
like hash t is a representation of truth. There is no representation of beauty, but

17:11.340 --> 17:16.460
we have hash f, which is a representation of false. An interesting fact about scheme is that

17:16.460 --> 17:22.620
every value in scheme is considered true except for hash f. So five is considered true. Well,

17:22.620 --> 17:31.980
then that's beautiful. It is open to debate. So we have also this amazing and very deep operator

17:31.980 --> 17:40.460
called quotation. Quote. Quote. And that is the topic of a lot of stuff I won't get into. But

17:40.460 --> 17:46.780
quote itself, this is a very controversial operator, how it should behave. People have created

17:46.780 --> 17:52.780
entire versions of lists just based on different notions of quotation. But in scheme, the way

17:52.780 --> 17:58.940
quote works is quote of anything gives you back that thing. So we quoted five. We get back five.

17:58.940 --> 18:04.140
We actually don't need to quote five. Quote five is something called a self-quoting or self-evaluating

18:04.140 --> 18:10.060
literal. But we can do things like quote a list. We can quote a list of five, six. And we can

18:10.060 --> 18:17.260
back the list five, six. We can quote the empty list, which has nothing in it. Because we use

18:17.260 --> 18:22.140
quote so much, we don't necessarily want to write quote this way. We're going to have a shorthand.

18:22.140 --> 18:25.500
Scheme doesn't have a lot of shorthand, but this is one of them. So we're going to write

18:26.460 --> 18:37.340
quote somewhat like that. Five, six. Okay. This I will allow. I don't like too much, you know,

18:37.340 --> 18:42.620
messing with my symbolic expressions, but this is going to be okay. And then in addition to

18:42.620 --> 18:46.460
having things like numbers and lists and lists containing lists and true and false values or

18:46.460 --> 18:55.100
bullions, we have an amazing thing called the symbol. And if you program in Java, I'm sorry,

18:55.180 --> 18:58.860
you don't get symbols. If you program in many languages, you don't get symbols. But you do have

18:58.860 --> 19:09.260
symbols in a scheme in most lists. So we can say milkshake with a quote around. And that gives

19:09.260 --> 19:14.940
us back milkshake. Milkshake is a symbol. It's a symbol. It's not a string. Strings are different.

19:15.500 --> 19:20.380
Symbols are things that represent metaphorically objects that we might care about. Okay. This is

19:20.380 --> 19:26.540
an atomic value. We can't tear it apart. We can't do anything like that. It's a unique thing. And

19:26.540 --> 19:31.260
it turns out internally it's fast to compare symbols. So we can use symbols to represent

19:31.260 --> 19:37.420
interesting data. We don't have to say, oh, we're in C. And so a milkshake is five or whatever it is.

19:37.420 --> 19:43.980
Right? So we can do things like this, which are classier. Okay. So we have symbols, lists. We

19:43.980 --> 19:49.900
can have symbols inside of our lists and things like that. We can also make decisions. We can

19:50.780 --> 19:59.420
do things like ask if a list is empty. So I say, is the empty list null? So if I have a list,

20:01.340 --> 20:07.740
there's friends. The thing that comes inside the friends first, that is basically a function call.

20:08.460 --> 20:12.460
Unless it's something like, quote, there's something called special forms that have special

20:12.460 --> 20:17.180
evaluation rules. But in this case, we're just calling a function. And the function,

20:17.180 --> 20:21.020
you can tell, is a predicate. It has a question mark that's going to return true or false.

20:22.060 --> 20:29.900
So we're asking if the input expression evaluates to the empty list. And it does. We can ask if

20:29.900 --> 20:37.340
five is null. Five is not null. So we can make a function call. We have notions of predicates.

20:38.140 --> 20:44.700
We can also build up lists in other ways that I haven't shown you yet. So I showed you two ways

20:44.700 --> 20:52.460
of lists. So I can just quote a literal list or I can call a function called list. 3, 4, 5. I can also

20:55.020 --> 21:02.060
build up list-like structures using an operator called cons. Cons for construction. In fact,

21:02.060 --> 21:07.420
Dan Friedman, who is my advisor, wrote a very famous paper with David Wise in 1976 called

21:07.420 --> 21:11.500
cons should not evaluate its arguments, which was one of the first papers on laziness like

21:11.500 --> 21:15.900
you have in Haskell. And there was another paper by Henry Baker called cons should not cons its

21:15.900 --> 21:24.380
arguments. That must have stayed up all night coming up with that one. So the typical way to

21:24.380 --> 21:30.620
use cons is to cons some object onto an existing list. So we can cons five onto the empty list.

21:30.620 --> 21:35.980
Now we get a list containing five. And I can build up chains of things using cons. So I can

21:35.980 --> 21:41.820
cons six onto the list to get back from the cons five. Cons takes two arguments. And I can build

21:41.820 --> 21:50.620
these lists up. Okay? All right. So that's cons. And we've seen like the null test. Let me show

21:50.620 --> 22:01.980
you how to make a choice. So I can use something like if, if five is null, then return six. Otherwise

22:01.980 --> 22:07.580
return seven. So if has three sub expressions, we have a test expression, what's called the

22:07.580 --> 22:13.100
consequent expression, and then the alternative expression. So what would be the value of this

22:13.100 --> 22:22.460
expression? Seven. Okay? All right. So that's one way to make a choice. And there are other ways.

22:23.100 --> 22:28.940
Another way to make a choice is something called conned. And the reason, I'll use this notation,

22:29.820 --> 22:36.940
the reason that we have this conned operator, conditional operator, is that it may be that

22:36.940 --> 22:43.180
we want to make lots of choices. So instead of having nested ifs, which gets annoying at some

22:43.180 --> 22:55.180
point, we can do something like this. Okay? What do you think this expression will evaluate too?

22:56.140 --> 23:05.180
Eight. All right. Great. Awesome. And I'll show you a couple of the things. One is, you know,

23:05.180 --> 23:12.700
we can do things like addition or multiplication. Okay? So addition is like plus. It's actually

23:12.700 --> 23:18.540
a function bound to a procedure that knows how to do addition. We also have multiplication. So I go,

23:18.540 --> 23:26.620
blah, blah. Right? And so I can deal with big dumps, arbitrarily large precision integers. So

23:26.620 --> 23:35.820
that's multiplication. And I can also do things like define. I can define functions. I can define

23:35.820 --> 23:42.460
all sorts of things. I can give a name to something. I'll call this, I don't know. I just had a tarot

23:42.460 --> 23:50.540
milkshake. So define tarot to be, quote, good. And there's a symbol. And if I type tarot,

23:50.540 --> 23:55.980
then the variable gets looked up in something called an environment. And I get back the value

23:55.980 --> 24:02.780
of that variable, which is a symbol, good. So define just gives a name to some value. I can give

24:02.780 --> 24:09.340
other sorts of values if I want. It doesn't matter. And another concept is that of a function.

24:10.300 --> 24:15.260
And the reads are a procedure, technically. And the way I create a procedure is with this

24:15.260 --> 24:20.620
expression called lambda. You type it L-A-M-B-D-A, but I've got this fancy thing that turns it into

24:20.620 --> 24:28.540
a symbol. And what you do with lambda is you have a list of arguments. These are the formal

24:28.540 --> 24:33.740
parameters to your procedure. And then you have a body. So this is lambda xx is the way it

24:33.740 --> 24:38.380
pronounced it. And this is just going to return its argument, the value of its argument. So this

24:38.380 --> 24:44.220
is the identity function, the value of the identity function. And we've already seen that you can

24:44.220 --> 24:51.580
write parentheses. And parentheses normally mean a procedure call. We're not specifically calling

24:51.580 --> 24:56.780
it, but that's the case unless we have what's called a special form in the first position,

24:56.780 --> 25:05.260
like quote or define, something like that. So I am going to apply that, the value of that

25:06.300 --> 25:11.500
lambda expression, which we'll evaluate to a procedure, to the expression five. Five is an

25:11.500 --> 25:16.940
expression that evaluates to the value five. So we are starting to have the notion of expression

25:16.940 --> 25:22.540
versus value. And I get back five. Through a mechanism that involves a number of steps,

25:23.180 --> 25:29.580
we evaluate the argument expressions. There's something called the operator expression,

25:29.580 --> 25:36.460
the rater. And the rand, the upper rand, we evaluate the operator that evaluates to a

25:36.460 --> 25:43.340
procedure of one argument. We evaluate the rand expression that evaluates to itself in this

25:43.340 --> 25:49.740
case. And then we perform a procedure application. And we apply that procedure to the value of the

25:49.740 --> 25:55.180
argument. And we get back five in this case. Okay, so that's the mechanism that we're going to

25:55.180 --> 26:04.620
implement. And I can, of course, give a name to a function. I can only call it double.

26:09.820 --> 26:15.980
Okay, so now I have a body that's a little more interesting. And I can double my fun.

26:16.460 --> 26:23.980
That doesn't work. The Haskellers are going to give me grief. But I could double five and get

26:24.860 --> 26:31.980
two in binary. So you can double anything you want. And I can define all sorts of things. So

26:31.980 --> 26:41.020
I can do things like define, define to be five. Right? Why is that a, oh, that's a great thing.

26:41.580 --> 26:48.780
So I can do a lot more than that. I can change what lambda means and things like that. That's

26:48.780 --> 26:54.300
where the real fun begins. So I'm not going to talk about that. That's for the next talk. But

26:54.300 --> 27:03.660
I'm going to restart my scheme. Just saying, just saying, I could, I could fly solo with that one,

27:03.660 --> 27:09.500
but I know how to do it. But I'm not going to do, you're not ready yet. You're not ready yet.

27:11.900 --> 27:19.500
Okay. So, so now you know scheme. Okay, now you, well, you're joking, or you think,

27:20.060 --> 27:23.900
you think I'm joking, but that's basically all you need. Okay. There's one other thing I'm going

27:23.900 --> 27:30.380
to talk about or show you very quickly. That's not technically built into scheme, but it's easy

27:30.380 --> 27:35.900
to add because scheme houses very powerful macro system that allows you to extend the language

27:35.900 --> 27:41.340
in different ways. And so what I'm going to do is I'm going to load a macro for pattern matching,

27:41.340 --> 27:48.220
something called P match. And this is just one of many systems that allow you to do pattern

27:48.220 --> 27:54.700
matching. And so basically P match is similar in spirit to our cond, except now we are going

27:54.700 --> 27:59.580
to match against an expression. So I can say, we're going to match against list three, four.

28:00.300 --> 28:04.620
And now we can have just like with a cond, different pattern or different expression

28:04.620 --> 28:10.140
or different clauses, but now we're going to match against the pattern. So I could say

28:12.300 --> 28:18.460
I have a pattern that matches against the list of two arguments. And these commas,

28:19.180 --> 28:23.100
I'm not going to really get into the details of what the commas means syntactically,

28:23.100 --> 28:28.620
but basically you can think that this list of two elements is getting pattern matched against

28:28.620 --> 28:35.020
the list we get back, the list three, four. So the x will be associated with or bound to three,

28:35.020 --> 28:43.740
the y will be bound to four. And then on the right hand side, we can use those x's and y's.

28:44.380 --> 28:50.780
And sure enough, we get back seven. So that's what P match does. If you haven't seen pattern

28:50.780 --> 28:55.980
matching before, it's very powerful, especially in conjunction with a form of quotation in scheme

28:56.060 --> 29:00.700
called quasi quotation or back quote. That's really what's going on. If you know scheme,

29:00.700 --> 29:06.460
there's an implicit back quote here. And those commas are called unquote.

29:07.500 --> 29:14.380
All right. So now we know basically everything we need to write an interpreter. So let's do that.

29:16.540 --> 29:23.740
All right. So let me go back to my file here. So I'll load my P match. And I can put this code

29:23.980 --> 29:32.060
online if people want to see it. All right. Okay. So one thing that we need to

29:33.900 --> 29:39.420
do is, you know, decide on the name for our interpreter. That's the hard part, right?

29:40.060 --> 29:46.300
So names are hard. What would be a good name for interpreter? Fitz Roy.

29:46.300 --> 29:52.780
Okay. Define. Fitz Roy. How do you spell that?

29:55.420 --> 30:03.420
All right. So we have a name. This is our life now. And thank you. Derailed us all.

30:04.700 --> 30:08.140
So, well, what do you think I should type next?

30:08.460 --> 30:19.660
P match, almost. We're not quite right. The arguments. So we need to define a function.

30:19.660 --> 30:24.140
The procedure is going to do something. So I have to type lambda. That's a good thing.

30:24.860 --> 30:31.500
When in doubt, the answer is lambda, right? So we have a lambda expression that's going to take

30:31.500 --> 30:36.780
some arguments. Okay. So if we looked at our interpreter here when we were writing stuff

30:36.780 --> 30:45.100
like plus three, four, this is basically an interpreter. Technically, it's not an

30:45.100 --> 30:52.300
interpreter. That's a form of evaluation. But it's an evaluator. So if you look over there,

30:52.300 --> 30:59.100
we have an expression coming in. And we evaluate the expression to get a value back. So we can

30:59.100 --> 31:05.500
have an expression. That's a good name. And I'm going to call this eval expression. Okay.

31:06.380 --> 31:13.500
Fitz Roy would have been fine. But this is a val expert. It's important as a safety tip

31:13.500 --> 31:21.580
to not call that argument exp. Now, why would that be? Yeah. Because scheme has an exponential

31:21.660 --> 31:29.740
function built in called exp. And if you type, you get very interesting errors if you do it wrong.

31:29.740 --> 31:39.340
So I call it expert. All right. Yeah. If you call your function eval, hilarity, may ensue.

31:40.620 --> 31:49.500
You can always restart. Now. Now it's time for P match. And what are we going to P match against?

31:50.380 --> 31:57.100
Well, guess what? We don't have a lot of choice. How about expert? All right. So we're going to

31:57.100 --> 32:03.500
P match against. See, it writes itself. Okay. So what sort of expressions do we want to have

32:03.500 --> 32:09.660
in our language? How about numbers? Number is a good thing to be able to evaluate. We had five.

32:09.660 --> 32:17.500
That was our first scheme program. So we're going to evaluate five. So the way that you write that

32:17.500 --> 32:25.020
pattern is that comma in will match against anything. And I mean anything. So that's no good.

32:25.660 --> 32:31.420
We have to add something called a guard where we can add a predicate. And so the predicate

32:32.620 --> 32:39.340
is basically part of this matching process. So if the pattern matches against expert,

32:39.340 --> 32:43.900
then additionally, the guard has to return a true value. That is any other value,

32:44.460 --> 32:48.860
the value, anything other than the hash F in order for the entire pattern to be

32:48.860 --> 32:53.020
considered matching. And in which case, we try the right hand side. Yes.

32:59.820 --> 33:06.300
We could, we could totally use a con here. And in that case, we could just have, you know,

33:06.300 --> 33:11.260
the number question mark of N, right? So right now it's not really paying for itself. It's a lot,

33:11.340 --> 33:15.340
a lot more mechanism than we need. But when we start getting the things like lambda

33:15.340 --> 33:20.220
that have more structure, we could do, that's a very good question. We don't need P match.

33:20.220 --> 33:24.140
Okay. This should be very clear. We could do everything with car. Oh, sorry. Did I talk about

33:24.140 --> 33:28.300
car? Well, we'll talk about car in a minute, maybe. Maybe, maybe we can avoid talking about car.

33:29.020 --> 33:35.020
We'll see. There's like a historical accident that involves some of the names and scheme

33:35.020 --> 33:40.380
that have not yet been corrected intentionally. But we don't talk about that. So

33:41.420 --> 33:45.580
anyway, so we're, we're going to use P match for reasons we'll see in a minute.

33:45.580 --> 33:49.420
We don't have to. So what do you think a number should evaluate to?

33:51.180 --> 33:57.500
It's self. Okay. Sounds good. So we'll just write down N. So now we have an interpreter. So let's try it.

34:00.540 --> 34:05.580
Well, you know, I don't have that much time. Okay. So we're going to load this thing.

34:06.540 --> 34:20.140
Uh, interp.scm. Okay. And now we can test it. Eval expert. And all right. Someone give me a nice

34:20.140 --> 34:28.300
expression to evaluate. Five. You're, you will go far. But that's the wrong answer. The right

34:28.300 --> 34:34.780
answer is quote of five, because we want to make sure that whatever expression we pass in

34:35.660 --> 34:44.140
is not evaluated by scheme. A classic error. Let me show you. Well, our interpreter works so well

34:45.580 --> 34:53.100
that we already can handle addition. Wow. That's really impressive. And if you've written enough

34:53.100 --> 34:57.900
interpreters, you've run into this problem before. I was like, whoa, that's, I guess I can turn in

34:57.900 --> 35:04.300
my homework early. Okay. So that's why we put a quote in front of whatever we're passing in. So

35:04.300 --> 35:09.980
really quote of five. All right. Well, maybe we want to have more things than just numbers. How

35:09.980 --> 35:20.620
about we add, add one. Add one is a function and scheme that adds one to a numeric argument.

35:21.260 --> 35:30.460
So let's implement add one. So, let me add another clause here. And in this case, we're

35:30.460 --> 35:36.860
actually going to match against the list. Okay. So we see list structure. And now you start seeing

35:36.860 --> 35:42.860
why we're using P match. So the expression we expect is an add one expression, which has a

35:42.860 --> 35:47.580
sub expression inside of it. This could be arbitrarily complicated. This doesn't just have to be a

35:47.580 --> 35:52.140
number. This could be something that evaluates to another, such as another call to add one.

35:52.700 --> 35:55.420
Okay. All right. So what do we do now in this case?

36:00.380 --> 36:03.100
Oh, yeah. Add one. Well, where did we get add one from?

36:06.220 --> 36:10.860
Scheme. We hope it's built in. We'll see. All right. So I'm going to call

36:11.420 --> 36:22.780
val expert inside of E. All right. So I'm going to use schemes add one to implement add one in

36:22.780 --> 36:37.980
my language. Okay. That's cool. So let's try it. Okay. So now let me quote add one.

36:38.220 --> 36:47.420
Okay. And then I can always do the test like this because otherwise you might accidentally

36:48.140 --> 36:53.900
not evaluate the sub expression. All right. So now we can do add one. That's great.

36:55.980 --> 37:05.820
All right. And I have one called sub one. All right. Same thing, right? All right. I should

37:05.820 --> 37:11.500
have used copy and paste abstraction. Well, I kind of did. But okay. So you see how this goes.

37:12.940 --> 37:20.540
That's fine. We could add a few other things. So we could add something like multiplication.

37:23.420 --> 37:27.980
Now, multiplication is interesting because our version of multiplication is going to take two

37:28.060 --> 37:32.220
sub expressions. Ooh. You want to need two. So now how do we write this thing?

37:36.620 --> 37:42.220
How many recursive calls do we have to make? Do. Right? Well, this is like falling off a log.

37:43.260 --> 37:52.940
All right. Okay. So we're going to multiply what we get back when we evaluate E1 and E2

37:53.500 --> 38:03.260
and multiply that. Okay. All right. Let's do another one. How about if? So I already told you

38:03.260 --> 38:09.740
there's a test and a consequent and an alternative. So how do we evaluate if?

38:11.420 --> 38:20.700
Any ideas? This is tricky. Using if. You're catching on. All right. How about if

38:21.500 --> 38:28.140
evalexper of t copy and paste abstraction?

38:32.380 --> 38:38.380
Yeah. All right. There's probably like a copy and paste monad in Haskell or something, right?

38:40.700 --> 38:43.900
So copy and paste abstraction. Now we have, yes. Great.

38:51.500 --> 38:57.180
Can we short circuit? Well, for things like and and or, we might want to do short circuit

38:57.180 --> 39:02.700
evaluation for if we're going to have to evaluate the test. But if semantics are that if the test

39:02.700 --> 39:07.820
is true, we will only evaluate the first sub expression. Otherwise, we'll only evaluate

39:07.820 --> 39:18.060
this sub expression. So they won't both be evaluated. Okay. Okay. Now, basically, this

39:18.140 --> 39:24.140
interpreter is pretty boring. All right. It's pretty boring. And the reason is we have not

39:24.140 --> 39:28.380
gotten to the beautiful part of the interpreter. The beautiful part of the interpreter has to do

39:28.380 --> 39:37.900
with three lines and only three lines. What are those three lines? Lambda. That's the, I told you

39:37.900 --> 39:44.460
there's always the answer, right? Told you. What's the second one? It's not lambda. What was that?

39:45.420 --> 39:57.420
Apply application. And the third one. Not a vowel. Not procedure. Was that? Not defined.

39:59.340 --> 40:04.700
Not quote. Oh, wow. All right. Stumped y'all. Haha. All right. We'll figure it out in a minute.

40:05.420 --> 40:16.860
Okay. So, let's try, you know, let's try doing, let's try doing a vowel. Okay. So,

40:16.860 --> 40:22.540
we've already seen the syntax and scheme. It's minimalist to say, not ro-co-co. And

40:23.740 --> 40:28.940
basically, we have a raider expression, an operator expression, and an operand expression.

40:28.940 --> 40:33.740
If you read a book and you see raider and ran, that's what they mean. You want to put this line

40:33.740 --> 40:38.620
last in your P match so it doesn't overlap. This pattern does not overlap with the others.

40:38.620 --> 40:42.780
This becomes fun when you start doing logic programming where the ordering isn't supposed

40:42.780 --> 40:47.180
to matter. But in this case, P match evaluates in the top down. And so we're going to put our

40:47.180 --> 40:54.940
application case last. All right. Okay. What do we do? We know the drill. We are going to evaluate

40:55.020 --> 41:01.260
via copy and paste subtraction, the raider and the ran. Perfect. Evaluate the raider

41:02.860 --> 41:14.380
and evaluate the ran. All right. Now, what do we do with those two values? The raider is supposed

41:14.380 --> 41:19.740
to evaluate to a procedure, some representation of procedure. And this is going to evaluate to some

41:19.820 --> 41:23.180
argument that we're going to call the procedure on. So what do we do now?

41:24.300 --> 41:31.340
Apply it. How do we apply it? No. Lambda doesn't apply. But you're right that I got caught up.

41:32.380 --> 41:38.940
We're going to use apply, which is through parentheses. Right? That's it. If you blink,

41:38.940 --> 41:44.780
you'll miss it. Some people have what I might call parentheses blindness. And they just can't see

41:44.780 --> 41:50.300
that that is different than without those parentheses. But they are different. There's no

41:50.300 --> 41:57.100
mistaking the difference in behavior. Okay. So that is our application. Very nice. So that's

41:57.100 --> 42:03.420
one of our three magic operators. We also have this thing called lambda. So I can match against

42:03.420 --> 42:07.740
the lambda expression. This is where the pattern matching comes in nicely. And I can give a name

42:07.740 --> 42:15.900
to the variable. And I can have a body expression. Okay. So something has got to happen with the

42:15.900 --> 42:26.060
lambda. Do you see that x? What is x? Well, there's a list containing x, but the x itself,

42:26.060 --> 42:34.300
not part of the list. What does that mean? What is that thing? It's an identifier. And if the x

42:34.300 --> 42:41.820
were to appear inside of rand, what would that be? It's a variable reference. Okay. So this is how

42:41.820 --> 42:50.300
we have a variable reference. And what's the value of the variable x? Tell me. Don't know yet. When

42:50.300 --> 42:57.100
will you know? No, at runtime when we've actually done the procedure application. That's right.

42:57.100 --> 43:04.060
We won't know until then. So if I call the resulting procedure with five as the argument,

43:04.060 --> 43:11.020
what would be the value of x? Five. So we have this idea that if a variable appears in the body,

43:11.740 --> 43:16.140
at some point, we may have to look up the value associated with that variable or bound to the

43:16.140 --> 43:21.500
variable. And in order to do that, we need some mechanism for variable lookup. And the traditional

43:21.500 --> 43:27.340
way of doing that in this sort of interpreter is called an environment. So we are going to write

43:27.340 --> 43:34.300
an environment passing interpreter. Okay. Anytime you hear passing, that means that there's going

43:34.300 --> 43:40.620
to be an argument coming in to our function for the interpreter. So you see right now, we basically

43:40.620 --> 43:46.380
have a calculator, we have an expression, but there's no context of the expression. There's no

43:46.380 --> 43:52.300
notion of variable bindings that may be in play at this point. So we're going to have to add

43:52.300 --> 43:57.500
something else to this expression, or sorry, in addition to the expression, as an argument.

43:57.500 --> 44:04.540
So I'm going to add an environment. And this changes everything. All those three magic lines

44:04.540 --> 44:12.220
are going to in some way be involved with the environment. Okay. So now we have an environment

44:13.580 --> 44:19.660
and the environment is going to contain somehow associations between variables and values.

44:20.300 --> 44:25.500
Now, what do you think the third magic line of code is based on what you've seen?

44:27.900 --> 44:35.900
Parentheses? This is the parenthesis line, the application. Cons, nope. Cons is useful, but

44:35.900 --> 44:39.500
you actually don't need it. You only need these three lines. That's turn complete, actually. It's

44:39.500 --> 44:44.300
amazing. We can delete all the other junk. The other stuff is junk. You don't need it.

44:45.740 --> 44:49.100
You don't need it. You only need the three lines. And I'm serious about that.

44:49.740 --> 44:53.820
You only need the three lines. You heard this thing called a Turing machine? This came first.

44:54.700 --> 45:01.900
Lambda calculus came first. Girdle didn't believe church that it was Turing complete,

45:01.900 --> 45:08.300
even though Turing completeness hadn't been a term yet. Okay. We need one more thing. No,

45:08.300 --> 45:15.180
we don't need to find either. Was it? Variable lookup. That's it. That's the last piece of magic.

45:15.180 --> 45:23.340
We've got to have a way to look up those variables. All right. So, I need a guard because I have my

45:23.340 --> 45:31.500
match anything pattern. And I am going to represent variables as symbols. Okay. Because we have symbols

45:31.500 --> 45:37.900
and scheme. So, if we have a pattern which is just a symbol by itself, right, we're going to say

45:37.900 --> 45:43.980
that's a variable and we're going to look it up. How do we look up a variable? In the environment.

45:44.540 --> 45:49.100
Okay. Now I have to tell you a piece of information you don't know. I am going to represent my

45:49.100 --> 45:55.820
environment as a procedure of one argument that takes a variable. So, how do I actually look up

45:55.820 --> 46:02.860
X in the environment? I'm not going to evaluate it, actually. Look up X in the environment.

46:03.820 --> 46:10.140
Like that. Procedure call. Okay. This is where it gets kind of weird. It's like kind of spartan,

46:10.140 --> 46:15.340
right? I'm just like, ah, got a procedure. There's only one useful thing a procedure can do. Call it.

46:16.140 --> 46:21.420
Takes one argument. Give it one argument. Call a day. That's it. All right. So, that's what we're

46:21.420 --> 46:36.700
doing. Okay. Great. Now, lambda. What is lambda going to do? Ah, yes. Extend the environment.

46:36.780 --> 46:42.780
It's the magic word. The environment extension is the key thing here. So, lambda expression

46:42.780 --> 46:48.060
evaluates to what in scheme? A procedure. Okay. So, we have to have a representation

46:48.060 --> 46:52.060
of a procedure which you can think of as a delayed computation where we don't have enough

46:52.060 --> 46:56.860
information to do the computation in the body yet. But we're going to wait until the procedure

46:56.860 --> 47:01.500
gets called and then some value will be bound to that variable and then we'll be able to evaluate

47:01.500 --> 47:04.540
the body at that point because we'll have the correct context. We'll know the variable binding.

47:05.340 --> 47:13.420
So, we have to somehow represent a procedure. How can we represent a procedure, do you think?

47:14.540 --> 47:20.780
Lambda. There you go. 60% of the time, it works every time.

47:25.260 --> 47:32.780
All right. Lambda arg. That's right. We're going to have an argument coming in.

47:32.780 --> 47:37.900
What is that arg thing do you think? What does that correspond to in the three magic lines of code?

47:40.780 --> 47:43.500
It doesn't correspond to X and this is something we have to be very careful about.

47:46.780 --> 47:52.700
It corresponds to the value of the RAND. Remember, the procedure application line

47:52.700 --> 47:58.060
and the lambda line are intimately connected because we're going to end up doing a procedure call

47:58.700 --> 48:02.940
on this lambda expression. The value of that lambda expression. That's going to evaluate to a scheme

48:02.940 --> 48:06.940
procedure and we're going to call the scheme procedure and pass in the value of the operand.

48:07.500 --> 48:12.460
Therefore, arg will be bound to the value of operand. If we're calling the identity function

48:12.460 --> 48:20.940
on 5, RAND will be evaluated to 5, arg will be bound to 5. Okay? Keep that in mind. Okay.

48:20.940 --> 48:27.180
So, now what I heard was we have to evaluate the body in the extended environment. So,

48:27.180 --> 48:38.220
let's do that. How do we evaluate the body? If only we had a procedure that knew how to evaluate

48:38.220 --> 48:43.980
the body. Well, that's what we're writing. Magic of recursion. Evaluate the body. Now we have to feed

48:43.980 --> 48:50.860
in an environment and we have to go back and retcon these lines because you don't have environments

48:50.860 --> 48:56.140
yet. So, we have to have an environment. So, for these lines down here is kind of boring.

48:56.220 --> 49:02.620
It's just the good old environment. Okay? But up here, we need an extended environment.

49:02.620 --> 49:05.740
What is the extension? How are we extending the environment?

49:07.980 --> 49:13.580
Lambda. That's right. You laugh. It is correct. You extend it using lambda.

49:16.380 --> 49:23.100
Yeah. It's a one-trick pony, but it's got a good trick. Lambda. Why?

49:23.500 --> 49:32.540
Whoo. All right. This is when the nerd chills start. Okay. That is an environment. Remember,

49:33.100 --> 49:38.860
we wanted to look something up. We called X on the environment. Well, that's the sort of creature

49:38.860 --> 49:43.020
we're talking about. A procedure of one argument. We're creating a procedure of one argument.

49:43.020 --> 49:46.220
That's our environment. So, extended environment. So, what are we going to do with that environment?

49:46.220 --> 49:53.180
What's going to happen inside? If. Oh, wow. Yeah. That's right. We have to make a choice.

49:53.180 --> 50:00.540
If of what? Oh, I didn't tell you this part yet. If equals. Well, there's this thing called

50:01.340 --> 50:07.180
EQ. Huh. Okay. If what is equal? What two things do we want to compare?

50:07.580 --> 50:13.260
Y and X. Okay. If they are equal, then what do we return?

50:15.580 --> 50:23.020
Not X. Arrg. This is the critical piece. And here's the other critical piece. What do we do

50:23.020 --> 50:29.660
if they don't, if they aren't equal? Inv. We're going to look up an inv. What do we look up?

50:30.940 --> 50:36.540
Y. Not X. Y. Because Y is what's coming into that lambda, the innermost lambda. That innermost

50:36.540 --> 50:42.460
lambda is an environment, extended environment. That lambda right there is a procedure. So,

50:42.460 --> 50:48.700
we have what's called a higher order representation of environments and procedures in our interpreter.

50:49.580 --> 50:55.980
Okay. So, let me go and fix up my VAL experts to give them environments. See, these lines are

50:55.980 --> 51:00.140
boring because we're not messing with the environment at all. It's not interesting at all.

51:01.020 --> 51:05.580
And you could say the application line isn't messing with the environment. And that's true

51:05.580 --> 51:11.100
with this representation of procedures and environments. But if we change our representation

51:11.100 --> 51:15.980
of procedures and environments, it actually does matter. You'll see that if we were to use data

51:15.980 --> 51:24.060
structures such as lists to represent our environment and procedures, then this application

51:24.060 --> 51:28.220
line would have a different looking structure. Basically, the work that we're doing up here

51:28.220 --> 51:35.180
in the lambda line, we get put into the application line. All right. So, in theory, this should work

51:35.180 --> 51:45.340
now. We'll see if you're all paying attention. Okay. VAL expert, let's try it out. Okay. So,

51:45.340 --> 51:57.660
add one and hopefully it still works. Oh. All right. We didn't pass it in. Oh, the call was wrong.

51:57.660 --> 52:04.300
Oh, very clever. Okay. So, you're right. We need to call a VAL expert now with an environment.

52:04.300 --> 52:12.860
What does an environment look like? Lambda. Yeah. Again. See. All you need is lambda.

52:14.780 --> 52:18.380
Y. Okay. And what is this environment going to do?

52:20.620 --> 52:27.180
What happens if we look up a variable like X in this environment? What should happen? Error.

52:27.900 --> 52:32.300
Means it's not bound. Okay. This environment starts out with nothing bound unless we want

52:32.380 --> 52:38.460
to put it in there. So, we can do a call to a scheme's error. We can call it. Look up. Something

52:38.460 --> 52:46.380
like that. You know, unbound. All right. Perfect. Okay. We get back seven. I can now look up a

52:46.380 --> 52:55.580
variable in the empty environment like X and I got my error. Okay. I can go ahead and do something

52:55.580 --> 53:00.540
like create a lambda expression. Let me try to do lambda xx. Okay. It gives me a procedure,

53:00.860 --> 53:05.980
a scheme procedure representing my procedure in my language. I can do a procedure application.

53:05.980 --> 53:13.500
Let's see if this works. I'm going to apply it to five and get back five. Proof. It works. I can

53:13.500 --> 53:19.100
do something a little more interesting. Lambda applied to lambda. So, I should get back into

53:19.100 --> 53:28.620
any function and I can apply the result of that to five. Okay. And then there's one ultimate test

53:31.180 --> 53:38.300
case. I think we've implemented everything. Oh, there's one more thing we need to add. Let me

53:38.300 --> 53:44.540
just add one more clause which is zero, huh? Okay. So, we're going to add one more clause

53:44.540 --> 53:51.980
to see if something's equal to zero. Let me just follow our usual thing. All right. And I think

53:51.980 --> 53:59.180
that may be enough now to do what I was going to show. So, there's one standard test case

54:01.020 --> 54:13.660
which tests everything and it's factorial. And it is factorial using something called,

54:13.660 --> 54:19.100
what Dan Friedman calls the poor man's y-combinator. You'll notice we don't have define

54:19.180 --> 54:22.940
in our language or in our interpreter. There's something called let rec to define

54:22.940 --> 54:27.180
mutually recursive functions. We don't have that either. What we do have lambda and the answer

54:27.180 --> 54:35.260
to everything is lambda as we know. So, this code here is factorial. You can see this got

54:35.260 --> 54:39.420
some function calls and stuff like that, but it may be you can believe the math. And then that

54:39.420 --> 54:46.860
little part up top with a bunch of lambdas, the part up top basically is what reaches what's

54:46.860 --> 54:52.380
called a fixed point. And so, you can see in scheme it works. So, let's see if it works in

54:52.380 --> 55:03.660
our interpreter. I have no idea. We'll try it out. Yeah! All right. Awesome. Well done.

55:08.780 --> 55:13.740
Okay. So, let's look at the interpreter real quick and just a couple of words about it.

55:14.700 --> 55:21.180
So, the first thing I'll say is that everything except the last three lines is an abomination.

55:22.620 --> 55:29.180
So, we are going to remove the abominable code. Bam, bam, bam, bam, bam, bam, bam,

55:30.060 --> 55:37.340
that. Okay. This is the 3 by 5 card interpreter. I may have to reformat it slightly differently

55:37.340 --> 55:44.300
for the screen, but if you have a 3 by 4 meter card, I guess you could fit at this side. But,

55:44.300 --> 55:49.580
you can actually write down at least on a 4 by 6 card and that is the magic. Okay. This is the

55:49.580 --> 55:55.260
key to the universe. You have everything here. You have lexical scope. You have higher order

55:55.260 --> 56:00.860
functions. You have all these sorts of things. Numbers, you don't need them. You can do church

56:00.860 --> 56:09.420
encoding. Okay. You don't need if. You can encode if as well. You encode all those things.

56:09.420 --> 56:17.100
They're kind of nonsense. Yes, they're useful for efficiency and expressiveness. You don't need

56:17.100 --> 56:25.100
them. This is all you need. It's Turing complete. Came before the Turing machine. This is similar

56:25.100 --> 56:29.900
related to something called the lambda calculus. This is a little bit different because we're using

56:29.980 --> 56:36.220
an environment instead of beta reduction if you're familiar with that. But similar idea. People

56:36.220 --> 56:41.820
would call this the call by value lambda calculus interpreter. Environment passing. You can play

56:41.820 --> 56:48.140
all sorts of really interesting games with this. You can change the representation of the environments

56:48.700 --> 56:55.420
and the procedures. You can use data structures. You can do lists and pattern matching. You can do

56:55.420 --> 57:00.220
all sorts of really cool things. You can add additional arguments just like we added the

57:00.220 --> 57:05.260
environment. So now we have an environment passing interpreter. You can add a store as well, which

57:05.260 --> 57:12.300
contains basically the current value of a variable. And you can change those values. So if you have

57:12.300 --> 57:18.540
an environment and a store, that allows you to do mutation like set bang and scheme. You can also add

57:18.540 --> 57:23.420
continuations. You can CPS the interpreter. Do another correctness preserving program

57:23.420 --> 57:27.820
transformation. CPS it. That gives you a representation of the rest of the program at any

57:27.820 --> 57:33.420
point potentially as a procedure. And you can just call that continuation anywhere you want.

57:33.420 --> 57:37.820
And you can implement all sorts of control structures. If you CPS your program twice, you

57:37.820 --> 57:41.820
have two continuations. That gives you limited continuations. You can do basically every control

57:41.820 --> 57:45.820
structure at that point. All sorts of very interesting games you can play. You can change.

57:45.820 --> 57:52.780
Anyway, I'm not going to get into all that. But what I recommend you do is what Dan suggested

57:52.860 --> 57:57.260
to all his students. And as far as I know, I'm the only one who did it. Maybe other people did.

57:57.260 --> 58:03.740
He said take a four by six card stack of them and spend 45 minutes writing this down over and over

58:03.740 --> 58:09.820
again until your eyes start bleeding. Sear it into your brain and your heart. And you'll never

58:09.820 --> 58:16.780
forget it. And if you really understand it and you try, you know, turning the crank and doing a

58:16.780 --> 58:22.380
bunch of evaluations, at some point you'll start to get some idea of the magic. But all of

58:22.460 --> 58:29.340
computation, all of the turing complete processes, all of, you know, the notion of computable

58:29.340 --> 58:35.900
functions are within this code. The secrets there. You can do things that run forever. You

58:35.900 --> 58:40.460
can do all sorts of things. They're very interesting. You can express colats inside of it. Okay.

58:41.340 --> 58:49.020
So that is sort of like the teaser. And, you know, you can go off to races once you really

58:49.020 --> 58:54.940
have this on the brain. You can do things like change the type of scope you have. You can go

58:54.940 --> 59:01.420
from what we have here. It's just called lexical scope or static scoping to dynamic scoping by

59:01.420 --> 59:07.180
changing how the environment variable lookup works and things like that. I'm not going to go

59:07.180 --> 59:10.940
into all those things. If you're interested in that, there's a book called Essentials of Programming

59:10.940 --> 59:17.740
Languages by Dan Friedman and Mitchell Wan that talks about a lot of these things. And

59:18.860 --> 59:26.300
there are lots of other resources you can find. What I want to show you now is what happens when

59:27.180 --> 59:33.820
you play these games in sort of a different context. So

59:41.740 --> 59:47.580
this is a paper by John McCarthy called a micromanual for Lisp, not the whole truth.

59:48.860 --> 59:55.660
And in this, he gives the rules for an interpreter. Okay. So you were asking about cons. Well,

59:55.660 --> 01:00:03.820
here's your cons. This is what cons does. And he gives basically the rules for a Lisp evaluator.

01:00:04.780 --> 01:00:11.900
And, you know, basically, he's calling his evaluator value as our val expert. And you can see

01:00:11.900 --> 01:00:19.100
that he has these equal signs. You're saying that expression is equal to that value. Now,

01:00:19.100 --> 01:00:24.300
equal, the notion of equality is actually one of the most subtle notions in all of mathematics and

01:00:24.300 --> 01:00:28.780
logic and computer science. Anyone who thinks they understand equality is just kind of some

01:00:28.780 --> 01:00:34.460
throwaway idea hasn't thought about it hard enough. Like homotopy type theory. All these people

01:00:35.180 --> 01:00:40.940
trying to understand different notions of equality there. So it's a very deep topic. And one of

01:00:40.940 --> 01:00:46.460
the things that's interesting is that, you know, we tend to read that equal sign if we're doing

01:00:46.460 --> 01:00:51.180
programming, programming languages, interpreters, compiler, stuff like that, basically is one

01:00:51.180 --> 01:00:57.580
directional from left to right. So we have an expression. We evaluate it. We write some function

01:00:57.580 --> 01:01:01.660
that's an evaluator. We compile it, some code that's going to run it. And we're going from that

01:01:01.660 --> 01:01:06.540
expression to that value. It's not really an equal sign. It's like a right-hand side arrow if you

01:01:06.540 --> 01:01:12.700
want to think of it that way. But what if we took the equal sign seriously? What if we seriously

01:01:12.700 --> 01:01:18.860
said, all right, well, this is like an algebra, right? And what do you do in algebra? When you were

01:01:18.860 --> 01:01:24.460
in, you know, I'm not talking about like the modern algebra. I'm talking about like, you know, when

01:01:24.460 --> 01:01:28.060
you were in high school or whatever, you took algebra in high school. What sort of things did

01:01:28.060 --> 01:01:34.780
you do in algebra? Solve equations. You put in variables like x and y and z and things like that.

01:01:34.780 --> 01:01:39.660
And you're supposed to figure out what is the value of that variable, right? That makes both sides

01:01:39.660 --> 01:01:45.900
equal. We're going to do that. So I've done some of the heavy lifting for you with a bunch of other

01:01:45.900 --> 01:01:51.180
people. We spent like the last 12 years doing it. And I'm going to show you some of the stuff that

01:01:51.180 --> 01:01:58.780
we got from it. So what we did was we wrote, and I started this at Indiana with Dan Friedman,

01:01:58.780 --> 01:02:01.820
a bunch of other talented people. I'm working right now with a whole bunch of other people,

01:02:01.820 --> 01:02:07.100
including like Michael Ballantyne at Utah and Greg Rosenblatt and all these other fine folks.

01:02:07.740 --> 01:02:15.580
We wrote an interpreter in what's called a logic programming language, okay? Or a relational

01:02:15.580 --> 01:02:23.180
programming language, that's what I normally call it. And this one doesn't fit on a 3x5 card,

01:02:23.180 --> 01:02:31.100
but it's not that long, actually. It's what? 403 lines. But you can fit the 3x5 card version

01:02:31.100 --> 01:02:35.820
on here quite nicely. And actually it looks a lot like the algebra part. In fact, you can write

01:02:35.820 --> 01:02:43.980
down the semantics. So here are the three lines we wrote for our interpreter. This is how you would

01:02:43.980 --> 01:02:49.980
write it in like an operational semantics, sort of math-y. And then this is on the right hand side

01:02:49.980 --> 01:02:54.380
is how you would express it in this language called mini-canon. And you can see it's really not much

01:02:54.380 --> 01:03:01.100
longer. It's about the same length. Okay, so anyway, we took the time and wrote this interpreter.

01:03:01.100 --> 01:03:04.300
So we wrote something equivalent to a vowel X, but in fact, you can see it's called a vowel

01:03:04.300 --> 01:03:11.180
expo, right? We even used the same name. And so now let me see if I can figure out how to load

01:03:11.180 --> 01:03:19.100
this thing. That's the, it's always the hard part. Here's the transcript. Let's see that. All right,

01:03:19.100 --> 01:03:29.740
now let's go in here. And let's see. Load MK. You know, it's all fine and good until you have to

01:03:29.740 --> 01:03:35.660
do things like load a file, right? There's no math for that. Probably the monad or something

01:03:35.660 --> 01:03:45.740
junk for that. Anyway, let's do full and term. All right, cool. So in this logic programming

01:03:45.740 --> 01:03:51.260
system called mini-canon, we have the ability to write queries. And the queries let us,

01:03:51.260 --> 01:03:54.300
you can think of it from a sort of database standpoint, you can think of it as an algebra

01:03:54.300 --> 01:04:00.700
standpoint. It allows us to write down things where we want to solve for the values. So we have

01:04:01.260 --> 01:04:13.180
you vowel expert. And I'm going to evaluate some, you know, some thing and get the value of it back.

01:04:13.180 --> 01:04:19.500
Let me just make sure that worked. Oh, expo. Yeah, you think I'd learn. Incorrect number of

01:04:19.500 --> 01:04:24.940
arguments. It probably takes the empty. Oh, I bet it's called a valo. Yeah, I think, see if I've

01:04:24.940 --> 01:04:30.140
gotten a valo. Yeah, awesome. Okay. So I've hidden the environment in this version because I'm just

01:04:30.140 --> 01:04:33.500
starting out in the empty environment. That's why we're not seeing an environment. We could

01:04:33.500 --> 01:04:39.500
type it in if we wanted to. Okay. So what's happening here is we have an interpreter

01:04:40.140 --> 01:04:44.220
written in a somewhat different style than what we just wrote. We have an evaluator,

01:04:44.860 --> 01:04:51.340
you know, and we have an expression just like the expressions we're passing into a valo expert.

01:04:51.900 --> 01:04:57.820
And correspondingly, we have the value. So this is a little bit different than before in that

01:04:58.460 --> 01:05:05.980
we are actually able to specify what the output should be. Now, in this case, we are putting

01:05:05.980 --> 01:05:10.860
in a variable, which means we don't know. We don't know what the value should be. In fact,

01:05:10.860 --> 01:05:17.420
if you want to think of it from an algebra standpoint, you know, I'll call it x. Or maybe,

01:05:17.980 --> 01:05:23.180
you know, another way to call it would be, you know, a question mark or something, right? So this

01:05:23.740 --> 01:05:28.060
is an unknown and we're trying to figure out what the value of the unknown must be.

01:05:28.700 --> 01:05:33.020
And in this case, the value of the unknown is five. The expression five evaluates to five. Great.

01:05:33.820 --> 01:05:40.060
So let's try doing something a little more interesting. Let's try having a lambda expression,

01:05:40.060 --> 01:05:48.220
let's say, about lambda xx. Okay. Oh, that's a big thing. You can see that it begins with closure.

01:05:48.220 --> 01:05:54.380
So closure is one way to represent a procedure. So some representation of a procedure, I'm not

01:05:54.380 --> 01:06:11.420
going to get into the details of it. But I can apply that function. I can apply that procedure

01:06:12.380 --> 01:06:23.500
to five, for example. So the identity function applied to five. And it gives me back five. Okay.

01:06:24.140 --> 01:06:32.300
Great. Now, this so far is just treating it like an interpreter, just like what we had before.

01:06:32.940 --> 01:06:37.340
And we have all sorts of other things, like we have the ability to create lists.

01:06:38.060 --> 01:06:43.820
You know, I could, and we have this cons operator I told you about. I think we have cons. Let's see.

01:06:44.620 --> 01:06:53.660
Cons A onto the list B. Yep. All right. So I can build up list structures. I can do all sorts of

01:06:53.660 --> 01:07:01.660
things. But what I can also do is play games where maybe I don't know the input expression

01:07:02.380 --> 01:07:12.460
and I know an output. So maybe the output is I want milkshake. Right. And now what I want

01:07:12.460 --> 01:07:19.260
is an expression in scheme that when you evaluate it produces the list I want milkshake. Okay.

01:07:20.140 --> 01:07:30.380
So let's try it. Quote, I want milkshake is one such expression. How about two? Oh, here is a

01:07:30.380 --> 01:07:37.100
procedure call. A procedure that takes any number of arguments whose body is the expression, quote,

01:07:37.100 --> 01:07:42.700
I want milkshake applied to no arguments. And we can do all sorts of games like that. Here's

01:07:42.700 --> 01:07:47.340
another one. Like, I don't need to go like 10. See if there are any good ones. Oh, yeah. Here's a

01:07:47.340 --> 01:07:52.380
call to car, which gets the first element in the list. The car of a list containing the list,

01:07:52.380 --> 01:08:00.780
I want milkshakes. And I can do things like that. All right. That's fun. So I work in the lab of

01:08:00.780 --> 01:08:13.500
Matt might at Utah. And he has this blog post called 99 ways not to die to say I love you in

01:08:13.500 --> 01:08:18.300
racket. So this was like his Valentine's Day post, right? It's like a slow Valentine's Day. You

01:08:18.300 --> 01:08:26.780
write this blog post. And it's 99 expressions in racket or scheme or whatever that actually

01:08:26.780 --> 01:08:40.380
evaluate to the list. I love you. Okay. So let's do that. So let's go back and come up with a run

01:08:40.460 --> 01:08:50.700
99 and say I love you. And we get all these programs. So here's one. It's called a list and

01:08:50.700 --> 01:08:54.460
it has a function call inside of it and stuff like that. And every one of these I can evaluate in

01:08:54.460 --> 01:09:04.300
scheme and it works just fine. All right. Yeah. Okay. So that's kind of fun. So let's try another

01:09:04.300 --> 01:09:15.980
one. Going back to John McCarthy's paper. He has this little note. So it's a difficult mathematical

01:09:15.980 --> 01:09:23.660
type exercise. Find a list E that means a program expression E such that the value of E is equal to

01:09:23.660 --> 01:09:29.900
E. What is that called? It's a quine. So we want to find a program that evaluates to itself. So how

01:09:29.900 --> 01:09:40.700
can we write such a query? Yeah. Well, let's let's out of respect to John McCarthy, call our variable

01:09:40.700 --> 01:09:48.780
E. We want E to evaluate to E. All right. Oh, that's a representation of a number five evaluates to

01:09:49.340 --> 01:09:57.500
five. That's true. Let's see who hash T evaluates to hash T. That's true. Hash F evaluates to hash

01:09:57.580 --> 01:10:03.020
F. Let's see if there's anything. Let's run for a second. Oh, what is this thing?

01:10:06.380 --> 01:10:10.780
All right. Forget those side conditions. Here's a more interesting looking expression

01:10:11.500 --> 01:10:16.700
and that evaluates to itself. Oh, okay. So we can do things like generate quines.

01:10:17.340 --> 01:10:23.100
What else can we do? Well, Michael Valentine at this point said, well, you know,

01:10:23.660 --> 01:10:30.140
what if you had a more interesting scheme expression that you're evaluating? So let's try

01:10:30.140 --> 01:10:34.780
something a little more interesting. So let's try doing something like

01:10:40.380 --> 01:10:46.380
writing a program that concatenates to lists. And, you know, don't worry about the syntax here. It's

01:10:47.020 --> 01:10:54.700
going to look, you know, if you don't know scheme, you may not read every single thing, but we're

01:10:54.700 --> 01:11:02.380
going to append, okay, and define a function called append that takes to lists L and S

01:11:02.460 --> 01:11:17.740
and is going to have an if. Make this a little smaller. If L is empty, then we return S. Otherwise,

01:11:17.740 --> 01:11:27.020
we're going to cons on the car of L to a recursive call to append with the rest of the list. That's

01:11:27.740 --> 01:11:35.500
called the Cutter and S. Okay. So let wreck, let's me define a recursive function. And now I'm

01:11:35.500 --> 01:11:43.980
going to have a call to append. I'm going to say append ABC to DE. And let's see if that works.

01:11:43.980 --> 01:11:50.700
And sure enough, it works. So it gives me ABCDE in a list because we can actually

01:11:50.700 --> 01:11:53.340
produce more than one answer. So let me show you what that would look like.

01:11:53.660 --> 01:12:02.460
What we could do is, well, actually let me show you something else first. So what if we put in the

01:12:02.460 --> 01:12:09.180
answer first? We know the answer should be ABCDE. Okay. So we put in the answer. And now I can put

01:12:09.180 --> 01:12:16.460
in that variable thing, the question mark, anywhere I want. So I can put in the question mark

01:12:16.780 --> 01:12:25.580
inside this argument. So I'm asking what list when it appended to DE gives me ABCDE. So what list

01:12:25.580 --> 01:12:35.420
should that be? ABC. And sure enough, I get that. Okay. I could ask for two things. Maybe X and Y.

01:12:36.380 --> 01:12:43.980
So I could say I want X and I want Y. There are all sorts of games I could show you with this,

01:12:43.980 --> 01:12:51.500
but I'm just going to show you a couple. So now I can have two lists that appended together

01:12:51.500 --> 01:12:57.340
give me ABCDE. And you can see the empty list applied to ABCDE is one such pair of lists.

01:12:57.340 --> 01:13:01.500
And I can actually ask for all such pairs. So I can do a run star.

01:13:04.380 --> 01:13:09.500
And now I get all the pairs back. And so if you've seen logic programming, if you've seen

01:13:09.500 --> 01:13:16.940
languages like prologue or minicanron, they let you do this sort of query. But notice we didn't

01:13:16.940 --> 01:13:23.100
write a logic program. We just took a scheme program in our interpreter. So we're taking the

01:13:23.100 --> 01:13:29.740
equal sign seriously. We're saying that equality really does mean equal. And there's no direction

01:13:29.740 --> 01:13:37.260
to that equal sign. We should be able to solve for any side. Okay. So let's try one more example.

01:13:37.740 --> 01:13:47.980
We could do something like have ABC and DE. And now we say the answer should be ABCDE.

01:13:47.980 --> 01:13:57.100
And minicanron responds with some gibberish that means that that's consistent. Okay. So the question

01:13:57.100 --> 01:14:05.020
is, where else could we put a logic variable representing something unknown? In the code.

01:14:05.740 --> 01:14:15.100
Yes. Yeah. All right. So I don't know. Let me find a target. How about this s? Let me put something

01:14:15.100 --> 01:14:25.500
there. I think this is the one with run star is a bad idea. Run one is good. And sure enough,

01:14:25.500 --> 01:14:31.900
it inferred the s that I removed and things like that. Now, at this point, we're actually doing

01:14:31.900 --> 01:14:39.980
program synthesis. So we have the ability to specify information in the form of things like

01:14:40.620 --> 01:14:47.020
the expected input and the corresponding expected output and use the semantics of our

01:14:47.020 --> 01:14:54.300
interpreter that we wrote as a relation and logic programming system to do inference, do a search

01:14:54.300 --> 01:14:59.340
basically and do constraint solving to try to infer the missing values. And those missing values

01:14:59.340 --> 01:15:04.860
could be the input arguments, the function, the output to the function, even code or some mixture

01:15:04.860 --> 01:15:12.060
thereof. We can put variables anywhere we want. Yeah. Let's try that. That's a good question.

01:15:12.940 --> 01:15:23.180
So let's go back to what we had. This is it. Yep. Let me put it where the append was. What do you

01:15:23.180 --> 01:15:31.580
think I'll get back? Oh, sorry. I have to change this back to the question mark.

01:15:32.620 --> 01:15:34.220
Hopefully append, right? Everybody start.

01:15:39.180 --> 01:15:49.500
What? Oh, did I call it runs? Oh, hilarity will ensue. That's the answer you expected, right?

01:15:49.740 --> 01:15:56.220
A procedure that ignores this argument and returns the list, AVCDE.

01:15:58.300 --> 01:16:05.100
Many canons like prove me wrong. I defy you to prove me wrong.

01:16:07.020 --> 01:16:13.500
So this is the fun for a thing you get into. So let's try to... So many canons like the genie,

01:16:13.500 --> 01:16:22.780
right? The genie is like, tell me your wish. I'm ready to go. So what we're going to do is we're

01:16:22.780 --> 01:16:31.260
going to create a list of calls to append. Sorry. I don't remember if we have lists or not. I think

01:16:31.260 --> 01:16:36.380
we have lists. So we'll have more than one test. That's right. So let's do two tests. So one will

01:16:36.380 --> 01:16:43.500
be empty list to empty list. And then in the output, we will have a list of expected outputs.

01:16:43.500 --> 01:16:52.220
So we'll have the empty list and then the list AVC. Oops. Let me try this. See if this works.

01:16:52.940 --> 01:16:56.700
Yeah, now it came up with a pen. So I was like, all right, I've got to work for it.

01:16:57.420 --> 01:17:04.380
Okay. Now what are we asked for two? So what happens? I don't know. I have no idea. Oh, okay.

01:17:04.940 --> 01:17:10.460
It's what that is. In case you can't read that. It's a direct application of a

01:17:10.460 --> 01:17:16.220
variadic function call with zero arguments, which returns the procedure of pen. It's like,

01:17:16.220 --> 01:17:23.020
okay, well, I'm no dummy. I'll keep doing that. So this version is quite slow. And if you want

01:17:23.020 --> 01:17:31.500
to synthesize code for real, it can take quite a while. But we've been working on a new tool.

01:17:32.220 --> 01:17:39.580
Let's see if I can zoom in. Ooh, it works today. Nice. All right. There's a tool called Barlemin

01:17:39.580 --> 01:17:48.300
that I've been developing with Greg Rosenblatt and Michael Bountine and other people. And this tool

01:17:49.100 --> 01:17:53.820
is basically just an interface. I learned a little bit of Swift code and I wrote this.

01:17:55.100 --> 01:18:00.300
You can see it's beautiful. And basically, this is just an interface on what you saw

01:18:00.300 --> 01:18:06.940
with some optimizations behind. It runs about 10 million times faster than the naive version.

01:18:07.900 --> 01:18:12.300
When you're doing program sensors, that's important because you're in an exponential space. So

01:18:12.940 --> 01:18:19.660
we are going to write a pen a slightly different way. So the code in the upper left

01:18:20.300 --> 01:18:27.100
is our definition of a pen. You can see we left some parts out. So we left the name of the function

01:18:27.100 --> 01:18:31.580
out. That's this comma a. That's a mini-canron logic variable. It's a meta variable. You can

01:18:31.580 --> 01:18:35.420
think of it as a whole in the program. We don't know what that expression is. We don't know what

01:18:35.420 --> 01:18:39.100
the arguments are to lambda or how many there are or anything like that. And we don't know what the

01:18:39.100 --> 01:18:45.260
body of the lambda is. So we're going to let our tool come up with that for us. And what we're

01:18:45.260 --> 01:18:50.140
going to do is just give some examples of a pen. So I'm going to append two lists, the empty list,

01:18:50.140 --> 01:18:54.860
to the empty list. So give me the empty list. And Barlowman's going to think about it and say,

01:18:54.860 --> 01:19:02.300
I've got a solution for you. You want a function called a pen. He's like, yes, very well. That

01:19:02.300 --> 01:19:08.860
function can take any number of arguments. Well, strictly, schemes of pen can. And it's going to

01:19:08.860 --> 01:19:16.620
return to the empty list. Right? Very exciting moment. All right. Well, that's okay, I guess.

01:19:17.340 --> 01:19:26.060
How about we have a list containing two lists, list A and list B, and we want to get back A, B.

01:19:27.100 --> 01:19:35.740
Okay. Well, add another test. Oh, lucky day. You want a function called a pen, which takes

01:19:35.740 --> 01:19:41.820
two arguments and doesn't matter what the names are. And if the second argument is empty, we'll

01:19:41.820 --> 01:19:46.540
return that. Why not? Because that's the first test. Otherwise, we'll return to list A, B.

01:19:48.460 --> 01:19:52.540
All right. Well, that's getting a little annoying. So let's introduce a new concept,

01:19:52.540 --> 01:19:57.500
that of the gensim, the generated symbol. We don't actually care what's in that list.

01:19:58.140 --> 01:20:02.860
We just want to make sure that that's not going to appear in the output program. As long as it

01:20:02.860 --> 01:20:08.620
doesn't appear in the output program, we're happy. So we're going to change that. Oh, now we do have

01:20:08.620 --> 01:20:15.180
to do a little more work. Two arguments, null test on the second argument. The second argument is

01:20:15.180 --> 01:20:21.420
null. Otherwise, we have to start doing some operations, cars and cons and things like that.

01:20:21.420 --> 01:20:25.980
But we haven't, there's no recursive call. It's not going to work. So let me try one more.

01:20:26.540 --> 01:20:32.060
List of length two. Yeah, you can see where this game goes.

01:20:41.420 --> 01:20:42.460
Let's think about that.

01:20:47.740 --> 01:20:53.740
It's thinking. It's like, all right. There's some putting in some work. Oh, what? Looks

01:20:53.740 --> 01:20:58.700
like a recursive call. That looks perilously close to being correct. It's a little hard to read.

01:20:58.700 --> 01:21:06.220
So I will give it, I will use the editor part to fill in some concrete names and see what we can get.

01:21:06.860 --> 01:21:13.900
Oh, that is a pen. That's nice. It's example-based program synthesis. Furthermore,

01:21:14.540 --> 01:21:18.460
I can do some other things that are interesting, like I could add a few more tests.

01:21:18.940 --> 01:21:27.180
So I could say append of list A to the empty list. Should be empty list. I could say append.

01:21:30.300 --> 01:21:36.780
Oh, oh, yeah. Yes. Yeah, garbage in, garbage out. Good call.

01:21:36.860 --> 01:21:47.820
Oh, okay. Anyone would like a job as a QA tester for Barleman.

01:21:48.860 --> 01:21:53.500
Okay. So I wrote some more tests. And of course, Barleman could already synthesize it. So it's

01:21:53.500 --> 01:22:00.460
not really necessary. But imagine for a second that maybe this program is too hard for Barleman

01:22:00.460 --> 01:22:05.340
to synthesize. So instead of having Barleman synthesize the program from the examples,

01:22:05.340 --> 01:22:10.540
we're going to do test-driven development, right? I mean, this is real test-driven development.

01:22:12.460 --> 01:22:17.500
So we wrote our tests first, and now we're going to write our code, right? So I'm going to call it

01:22:17.500 --> 01:22:25.980
a pen. If I call it, like, you know, king cat, many kinderans are like, no, wrong. Computer says no.

01:22:27.260 --> 01:22:32.860
Fail. All right. So let's call it a pen. And let's say we're going to take two arguments,

01:22:32.860 --> 01:22:42.460
L and S, like before. Great. And we probably want an if and a null check on L. And, you know,

01:22:42.460 --> 01:22:49.340
we can start kind of filling in the structure here. And Barleman can probably synthesize that,

01:22:49.340 --> 01:22:54.460
fine. But let's pretend we're working on something a little more complicated, and Barleman can't do

01:22:54.460 --> 01:22:59.900
it. So now I'm typing. And notice I've got some holes in my program. So I don't know what those

01:22:59.900 --> 01:23:03.500
are. And those are arbitrary expressions. This could be, you know, gigantic, right? I could have

01:23:03.500 --> 01:23:09.420
a scheme compiler as A or something. It is solving it faster because I've filled in more.

01:23:10.300 --> 01:23:13.660
The current version of Barleman, sometimes you fill in more and it's like really slow.

01:23:13.660 --> 01:23:20.300
Because it gets slower. So we're working on that. But anyway, so let me put in L. That's one of my

01:23:20.300 --> 01:23:25.500
arguments. So I'm going to think, hey, L is probably the right one. Oh, Barleman's like, no.

01:23:25.580 --> 01:23:31.420
Computer says, no. That particular test is incompatible with the partially specified program

01:23:31.420 --> 01:23:36.780
you've written. So what we can do is write our tests, try to use it for synthesis. But if it's too

01:23:36.780 --> 01:23:42.380
slow for synthesis, we can just use this as an editor. And it's constantly in the background

01:23:42.380 --> 01:23:47.900
taking up all your corridors and heating your apartment. And desperately trying to prove,

01:23:48.540 --> 01:23:53.660
and this is a proof because many cameras are theorem prover, that the partially specified code

01:23:53.660 --> 01:23:57.820
you've written is actually incompatible with when you test. It doesn't mean your test is wrong.

01:23:57.820 --> 01:24:01.660
Maybe your code is wrong. Maybe they're both wrong. Maybe the semantics for the interpreter

01:24:01.660 --> 01:24:09.100
underlying Barleman is wrong. But they're certainly inconsistent, right? And I think this sort of

01:24:09.100 --> 01:24:17.420
technology is, you know, getting ready at this point to be practical for at least some use cases.

01:24:17.420 --> 01:24:21.020
And I should also point out that there are many other people working on program synthesis,

01:24:21.580 --> 01:24:27.100
I think a renaissance in that area right now. But I do think that one thing that's interesting

01:24:27.100 --> 01:24:34.060
is sort of the way we're doing synthesis, which is by taking that interpreter that I showed you

01:24:34.060 --> 01:24:38.460
in the beginning, this beautiful piece of code, and looking at the original description of it

01:24:38.460 --> 01:24:43.580
in those equal signs, and taking the equal signs seriously. We're going back and revisiting this

01:24:43.580 --> 01:24:51.340
artifact that people had an understanding of, and we're trying to actually execute, you know,

01:24:51.340 --> 01:24:56.140
another way of looking at it, this relational semantics view. And people, you know, people

01:24:56.140 --> 01:25:00.460
know relational semantics. I mean, the way that the math was written down is as relations.

01:25:01.580 --> 01:25:06.620
But the whole point is we've designed this language mini-canron to let us encode these

01:25:06.620 --> 01:25:11.180
relations in a nice way, and then did a bunch of optimizations. So when you write an interpreter

01:25:11.180 --> 01:25:16.140
as a relation, you can do this fill-in-the-blank game, right? And there are all sorts of other

01:25:16.140 --> 01:25:21.260
examples I could show you with mini-canron, and some really neat things. If you're interested in

01:25:21.260 --> 01:25:27.820
that, you might check out the closure conge talk that I gave with Greg Rosenblatt at the conge,

01:25:27.820 --> 01:25:33.020
last year's conge. And we show off a whole bunch of examples of this sort of thing. And, you know,

01:25:33.020 --> 01:25:38.140
we're trying to actively improve it and explore other ways to do things. And we can take things

01:25:38.140 --> 01:25:42.860
like a proof checker and turn it into a theorem prover by making it a relation, all sorts of fun

01:25:42.860 --> 01:25:48.780
games. So if this appeals to you, let me know. You might check out the webpage mini-canron.org

01:25:48.780 --> 01:25:54.220
that has a description of a lot of the work we've been doing. And also, I run hangouts on

01:25:54.220 --> 01:25:59.820
Saturdays and Sundays, an intro hangout series, an advanced hangout series, to talk about some

01:25:59.820 --> 01:26:04.220
of these technologies. Just send me an email, drop my line, hang out, we'll get a milkshake.

01:26:04.220 --> 01:26:07.020
And we talk about these things. If this thing you're interested in, you want to actually do

01:26:07.020 --> 01:26:12.060
some research, work on it, hacking, whatever, you could probably improve the user interface

01:26:12.060 --> 01:26:18.700
of Parliament if nothing else, right? So anyway, this is why I think the interpreter,

01:26:19.340 --> 01:26:25.500
that interpreter written in Lisp, that's higher order, is so beautiful, such a beautiful object,

01:26:25.500 --> 01:26:31.740
that not only is it very, very dense and an interesting amalgam of very important ideas,

01:26:32.620 --> 01:26:38.860
but you can look at that object from many different standpoints, like I said, that infinite tower

01:26:38.860 --> 01:26:44.940
of interpreters, or any number of other ways, from program transformation standpoint,

01:26:44.940 --> 01:26:50.300
from a relational semantic standpoint, and so forth. And each time you look at that object,

01:26:50.300 --> 01:26:57.180
that like five line core program from a different standpoint, it yields some more secrets,

01:26:57.900 --> 01:27:02.380
right? In some sense, we know everything about the interpreter, but in some other real sense,

01:27:02.380 --> 01:27:05.900
like I would not have guessed that you could do this sort of thing just by taking that

01:27:06.460 --> 01:27:11.580
program and encoding it in a logic programming language, but you can, it turns out. I think

01:27:11.580 --> 01:27:17.820
that's really amazing. So that's why I think that's a really beautiful artifact and I hope

01:27:17.820 --> 01:27:23.740
everyone will take the time to really study it and get to know it and find their own ways of

01:27:23.740 --> 01:27:30.620
looking at it and new ways to consider how that thing works, okay? Thank you. Thank you very much.

01:27:31.900 --> 01:27:32.620
Round of applause.

01:27:37.100 --> 01:27:42.860
We have time for like two very short questions and then we have to get out of here. So we have one

01:27:42.860 --> 01:27:49.020
right in front here real fast. If you treat these tests as constraints to the program that

01:27:49.020 --> 01:27:53.020
is trying to guess, can you apply like meta constraints? Can you say like, I want this to be

01:27:53.020 --> 01:27:58.220
like a constant time algorithm or I want it to be, you know, an element of memory or something like

01:27:58.220 --> 01:28:04.780
that? That's a good question. So, you know, part of the issue is how do you specify what it is you

01:28:04.780 --> 01:28:09.580
want the program to do? And so one way is with these tests, you could also use something like

01:28:09.580 --> 01:28:13.980
types because we won't write type inferences in the same style. You can also write high level

01:28:13.980 --> 01:28:17.580
properties and logic. There are a whole bunch of ways you could do it. And you could also say

01:28:17.660 --> 01:28:22.780
something about the expected running time or desired running time and so forth. We're not at

01:28:22.780 --> 01:28:26.300
the point where we can do things like talk about the desired running time, although it is something

01:28:26.300 --> 01:28:34.380
I'd like to be able to do. And so no, you can't do that yet, but one of the areas we're very interested

01:28:34.380 --> 01:28:38.860
in is trying to do more expressiveness. Probably the most recent thing that we've been playing with

01:28:38.940 --> 01:28:47.740
that's interesting is just yesterday, I started, I basically wrote a version of this technology

01:28:48.380 --> 01:28:54.140
where you can take scheme programs, look at common patterns in scheme in terms of very simple and

01:28:54.140 --> 01:29:01.180
just looking at what the parent is for an expression like what, you know, if you see a define, it

01:29:01.180 --> 01:29:05.580
turns out there's usually a lambda inside of it. If you see a lambda, there's usually an if or a

01:29:05.580 --> 01:29:11.180
cond inside of it and looking for those sorts of simple patterns and specializing the relational

01:29:11.180 --> 01:29:16.620
interpreter based on that very, very simple knowledge. So instead of just having the semantics,

01:29:17.180 --> 01:29:22.220
the system also would know a little bit about sort of standard human style or things like that.

01:29:22.860 --> 01:29:27.100
And that alone looks like it speeds up since there's many orders of magnitude and we're

01:29:27.100 --> 01:29:32.300
trying to figure out can we apply that to sort of the optimizations we've already made. So I think

01:29:32.460 --> 01:29:36.940
the bottom line is like there's a whole bunch of things that we just haven't explored yet, but

01:29:36.940 --> 01:29:40.940
I think it's definitely possible. And there are other people in this program census community

01:29:40.940 --> 01:29:47.180
who particularly work on that problem of trying to synthesize programs that have, you know,

01:29:47.180 --> 01:29:51.340
different expected, you know, running times and things like that. This is a very cool problem.

01:29:53.260 --> 01:29:56.140
More questions. There's a lot to take in I know.

01:29:57.100 --> 01:29:57.580
Short.

01:30:00.220 --> 01:30:05.660
When you gave the example of coming up with the answer append, how does it,

01:30:05.660 --> 01:30:08.780
how do you seed the search space? Like how did it know to find append,

01:30:08.780 --> 01:30:10.540
how did it append to get into the search space?

01:30:10.540 --> 01:30:14.700
Well, I mean, it didn't find append first, right? It created a function that just returns a list.

01:30:16.060 --> 01:30:21.100
Well, because we have an interpreter, the interpreter has a notion of scoping,

01:30:21.100 --> 01:30:26.940
just like we implemented variable lookup. We implemented variable lookup in that interpreter,

01:30:26.940 --> 01:30:33.020
and the semantics of let rec, the binding structure of let rec means that within that call, you know,

01:30:33.020 --> 01:30:38.060
so the call to append was inside the definition of append. So therefore in the environment append

01:30:38.060 --> 01:30:42.940
is there because we define the function. And so one of the things it's going to try to do,

01:30:42.940 --> 01:30:46.780
the interpreters going to try to do is look up the variables that are currently bound in the

01:30:46.780 --> 01:30:50.300
environment and try all of those and see if that will help lead to a solution.

01:30:51.740 --> 01:30:54.620
Anyone else?

01:30:57.500 --> 01:31:01.180
No? All right. Thank you so much.

