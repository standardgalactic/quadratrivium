1
00:00:00,000 --> 00:00:25,520
So I'm Will and I was a middle school teacher and I ran a summer camp and I did all these

2
00:00:25,520 --> 00:00:30,680
things and then at some point I got a degree in computer science and I worked as a Java

3
00:00:30,680 --> 00:00:32,920
developer and all this stuff, right?

4
00:00:32,920 --> 00:00:37,880
And then I got fed up with the JavaScript and the Java and all that and I went to graduate

5
00:00:37,880 --> 00:00:43,120
school at Indiana University to work with Dan Friedman who you may have heard of.

6
00:00:43,120 --> 00:00:49,740
He's someone who wrote a book called The Little Lisper and a revised version called The Little

7
00:00:49,740 --> 00:00:52,040
Schemer and The Season Schemer.

8
00:00:52,040 --> 00:01:02,080
I wrote a book with him called The Reason Schemer and I took Dan's class the first semester

9
00:01:02,080 --> 00:01:09,440
I was there and a couple of weeks in to the class, Dan showed me a program that changed

10
00:01:09,440 --> 00:01:18,080
my life and basically I spent the last 12, 13 years trying to understand these five lines

11
00:01:18,080 --> 00:01:20,140
of code, right?

12
00:01:20,140 --> 00:01:25,620
And I will spend the rest of my life trying to understand the implications of these five

13
00:01:25,620 --> 00:01:29,260
lines of code and this is what I like, okay?

14
00:01:29,260 --> 00:01:33,980
So some people like writing a hundred thousand line compiler or an operating system kernel

15
00:01:33,980 --> 00:01:37,460
with two million lines of code or whatever and that's great.

16
00:01:37,460 --> 00:01:40,740
What I like is sort of going the opposite way.

17
00:01:40,740 --> 00:01:47,100
I like the 3 by 5 card or the 4 by 6 card and if you're not an American, I don't know

18
00:01:47,100 --> 00:01:55,620
what that is, it's A4 or something, I don't know, it's like a 3 by 5 card, maybe a 4 by

19
00:01:55,620 --> 00:01:56,620
6 card.

20
00:01:56,620 --> 00:02:03,460
If you can't fit down the idea on a 4 by 6 card, then think harder.

21
00:02:03,460 --> 00:02:06,060
That sort of Dan's philosophy, right?

22
00:02:06,060 --> 00:02:10,380
And ideally you get it down to the 3 by 5 card and then you write a little book on it

23
00:02:10,380 --> 00:02:17,060
and so that's kind of his way of thinking and I share a lot of that sensibility.

24
00:02:17,060 --> 00:02:22,580
So what I would like to talk a little bit about today is this program that I saw and

25
00:02:22,580 --> 00:02:25,300
it just floored me.

26
00:02:25,300 --> 00:02:30,260
And to this day I get nerd chills every time I think about it, right, I really get nerd

27
00:02:30,260 --> 00:02:38,900
chills and I think, you know, I was nervous about, I am nervous about giving this talk

28
00:02:38,900 --> 00:02:43,620
because one of the dangers I think is that when you've been programming for a while and

29
00:02:43,620 --> 00:02:48,380
I know a lot of people in this audience like NoLisp or they've worked through SICP or they've

30
00:02:48,380 --> 00:02:51,180
written lots of interpreters and all these sorts of things, they know something about

31
00:02:51,180 --> 00:02:58,500
Lambda Calculus, after a while you can feel like you understand something and that's the

32
00:02:58,500 --> 00:03:03,980
most dangerous way of thinking is to think you understand something, right, and that

33
00:03:03,980 --> 00:03:11,420
there are no, you know, kind of new tricks in this and basically every time I learn something

34
00:03:11,420 --> 00:03:15,980
new about computer science or, you know, every couple of years or something like that, I

35
00:03:15,980 --> 00:03:22,140
like to go back and try to think about those things which I learned a long time ago and

36
00:03:22,140 --> 00:03:25,340
I'd stop thinking about, you know, because I thought at least, you know, I've got some

37
00:03:25,340 --> 00:03:31,740
grasp of this and almost always I'll have a new angle, right, and for the really, truly

38
00:03:31,740 --> 00:03:38,780
deep ideas, computer science or anywhere in the other field, you know, there are many

39
00:03:38,820 --> 00:03:45,020
ways of looking at these deep ideas and I'm going to show you, you know, a couple ways

40
00:03:45,020 --> 00:03:51,460
of looking at this program but I'm not kidding when I can say that I'm going to spend the

41
00:03:51,460 --> 00:03:55,500
rest of my life trying to understand it and there are many other people who've tried to

42
00:03:55,500 --> 00:04:02,020
spend, you know, their careers basically understanding aspects of this five line program and, you

43
00:04:02,020 --> 00:04:08,060
know, to give you sort of a reminder of, you know, a five line program, the amount of complexity

44
00:04:08,180 --> 00:04:13,580
you can fit in there. Does anyone know about the Colatz function? What's the Colatz function?

45
00:04:19,420 --> 00:04:25,900
Yeah, it's this little function, you know, like three in plus one and, you know, you have

46
00:04:25,900 --> 00:04:31,260
like a division by two or something like that and, you know, basically you're trying to figure

47
00:04:31,260 --> 00:04:38,060
out if you give an integer, a positive integer as an input, will this operation terminate?

48
00:04:38,060 --> 00:04:41,260
It's just got some multiplications, additions and divisions, right, and it's like the tiny

49
00:04:41,260 --> 00:04:47,340
little program and, you know, it's like a three line or two line program and the best mathematicians

50
00:04:47,340 --> 00:04:53,260
in the world have been trying to prove for many decades utterly without success that this

51
00:04:53,260 --> 00:04:57,540
program always terminates if you give a positive integer and Paul Erdisch, one of the great

52
00:04:57,540 --> 00:05:03,940
mathematicians of all time, at one point said, mathematics is not ready for the Colatz

53
00:05:03,940 --> 00:05:11,140
problem, right? So that's a three line program who's stumped some of the greatest minds in

54
00:05:11,140 --> 00:05:17,420
history. So I'm talking about like a five line program, okay? So that should give you pause.

55
00:05:18,260 --> 00:05:24,460
That should give you pause and we all have to have a healthy amount of respect for the three by

56
00:05:24,460 --> 00:05:33,900
five card program. So anyway, the program I'm going to talk about is an interpreter for Lisp

57
00:05:33,900 --> 00:05:42,140
written in Lisp. And it's one of these things where if you don't know Lisp and you first see it

58
00:05:42,140 --> 00:05:46,060
and you're like, oh, what are these parentheses? And then after a while you kind of start thinking,

59
00:05:46,060 --> 00:05:51,260
what is this lambda thing? That's something to wrap your head around. And why are there two

60
00:05:51,260 --> 00:05:56,700
lambdas like nested? What does that mean? And you kind of go over these different ideas at

61
00:05:56,700 --> 00:06:00,380
the time and eventually you kind of get some sense. You trace through a bunch of programs and

62
00:06:00,380 --> 00:06:04,300
you're like, all right, I kind of get some sense of what's going on. And then you start modifying

63
00:06:04,300 --> 00:06:11,100
the interpreter. And one of the great things about this program is that there's so many ways to change

64
00:06:11,100 --> 00:06:16,940
it and explore it and play with it. You can add arguments to the interpreter. You can rewrite

65
00:06:16,940 --> 00:06:24,380
the interpreter in a variety of correctness preserving transformation styles. One program

66
00:06:24,380 --> 00:06:29,260
transformation you can apply is something called continuation passing style, which I consider

67
00:06:29,260 --> 00:06:35,020
the gateway drug of program transformations. You know, normally you CPS that sucker and then from

68
00:06:35,020 --> 00:06:42,540
then on, you know, it's off to the races. So, you know, you CPS an interpreter, you CPS it twice,

69
00:06:42,620 --> 00:06:50,860
that gives you delimited continuations. And now you're cooking with gas. You can add a store

70
00:06:50,860 --> 00:06:58,940
argument to the interpreter, right? You can add boxes and you could start doing, you know,

71
00:06:58,940 --> 00:07:04,620
mutation and side effects in different ways. You can do call by value versus call by need versus

72
00:07:04,620 --> 00:07:11,980
call by name trivially, right? You can do all sorts of things that are really deep and give you

73
00:07:11,980 --> 00:07:16,620
deep insights into concepts of programming languages that you'll use, you know, the rest of your

74
00:07:16,620 --> 00:07:24,220
career or the rest of your hobby years or whatever. And so I don't know of any other artifact in all

75
00:07:24,220 --> 00:07:29,820
of computer science that packs so many ideas and the potential extensions to explore so many

76
00:07:29,820 --> 00:07:40,300
different areas as this interpreter. And in fact, you know, Alan Kaye says that when he first saw

77
00:07:40,300 --> 00:07:47,020
the Lisp interpreter written in Lisp at the bottom of page 13 of the Lisp 1.5 manual, right?

78
00:07:47,660 --> 00:07:52,940
It changed his life and he realized these are Maxwell's equations of software, right?

79
00:07:52,940 --> 00:07:57,660
It's very much the same right down four little equations. It helps if you like take them from

80
00:07:57,660 --> 00:08:02,940
the other mathematicians and physicists and call them mathmen. But you said, you know, you write

81
00:08:02,940 --> 00:08:07,660
down the four equations and you put that on the three by five card, right? And then you spend the

82
00:08:07,660 --> 00:08:12,620
rest of your life trying to understand what those four equations are, what the implications are.

83
00:08:12,620 --> 00:08:19,340
So that's very much what this interpreter is. And I'm, you know, I can't do justice to it.

84
00:08:19,340 --> 00:08:26,060
I can only show you a couple of the many aspects of this multi-aspected, you know, beautiful system

85
00:08:26,060 --> 00:08:31,740
and many of which, you know, I feel like I'm a complete noob too. But I can tell you that

86
00:08:31,820 --> 00:08:37,500
there are very interesting things out there. So, for example, there's this idea of reflective

87
00:08:37,500 --> 00:08:41,660
towers of interpreters. We have an interpreter interpreting an interpreter interpreting an

88
00:08:41,660 --> 00:08:47,820
interpreter. That part's already interesting. But when you have infinitely deep tower or

89
00:08:47,820 --> 00:08:52,220
infinitely tall tower, that's when it starts getting fun. And in particular, it becomes

90
00:08:52,220 --> 00:08:57,340
especially fun when the interpreter being interpreted by another interpreter can reach

91
00:08:57,340 --> 00:09:04,860
back up into the interpreter interpreting it and change the semantics of itself by changing how

92
00:09:04,860 --> 00:09:11,100
the interpreter interpreting it works. And this is one of the things that Dan Freedman says he

93
00:09:11,100 --> 00:09:17,340
refuses to work on because it melted his brain too much. It's like basically the one thing that he's

94
00:09:17,340 --> 00:09:24,300
like, he won't touch anymore. So that's the sort of fun you can have. You know, it's bad enough

95
00:09:24,300 --> 00:09:28,380
having a five or six line program, but when you have infinitely many of them interacting in these

96
00:09:28,380 --> 00:09:33,260
ways, then you can do very interesting things. And if you're interested in that sort of thing,

97
00:09:33,260 --> 00:09:39,500
I would point you to the work of Kanichi Asai. And also, my friend Nada Min gave a keynote

98
00:09:39,500 --> 00:09:45,180
at Strange Loop a few years ago when she talked about this. I think she called the talk Programming

99
00:09:45,180 --> 00:09:50,300
Should Eat Itself. And she talked about this reflective tower idea. Okay, so that's just

100
00:09:50,300 --> 00:09:57,100
one aspect. You can go deep. You can go deep that direction if you want. I haven't touched that yet.

101
00:09:58,140 --> 00:10:03,180
I want to connect that with the thing I'm going to show you. And even the people who do

102
00:10:04,380 --> 00:10:09,580
this type of very bizarre programming, they kind of get scared look on their face when they start

103
00:10:09,580 --> 00:10:15,820
thinking about the implications. So that's a good feeling when you're scaring the veterans

104
00:10:15,900 --> 00:10:25,100
of the Lambda Calculus. So that's something I want to accomplish. And there are many,

105
00:10:25,100 --> 00:10:29,820
many other directions you can go. Program transformation, directions, different evaluation

106
00:10:29,820 --> 00:10:34,140
orders, all sorts of things. And then you can layer a type system on it, that kind of thing.

107
00:10:34,140 --> 00:10:38,860
Now you have the interpreter and a type inferencer and a share structure. And you can have them

108
00:10:38,860 --> 00:10:45,340
interact in interesting ways and all these sorts of things. So just like CPS is the gateway drug,

109
00:10:45,420 --> 00:10:51,820
program transformations, Lisp in Lisp is the gateway drug of the whole world of programming

110
00:10:51,820 --> 00:11:00,300
languages, I think. So what we're going to do is write an interpreter. We're going to write

111
00:11:00,300 --> 00:11:06,540
the Lisp in Lisp in the way that Dan wrote it. And Paul Airdish, the great mathematician, had this

112
00:11:06,540 --> 00:11:13,100
idea that there was a book that God kept that had every beautiful proof in it. Only the beautiful ones.

113
00:11:13,660 --> 00:11:17,900
And every once in a while, he or someone else would come across a particularly elegant

114
00:11:17,900 --> 00:11:23,020
and beautiful proof and say, oh, that's a proof in the book. And so we're going to see a program in

115
00:11:23,020 --> 00:11:27,500
the book. This is the program in the book. I've written hundreds of interpreters and I've read

116
00:11:27,500 --> 00:11:34,300
lots of books on interpreters, but this to me is the one in the book. Everything else is a pale

117
00:11:34,300 --> 00:11:43,580
limitation. All right. So who here is familiar with S expressions, symbolic expressions or

118
00:11:43,580 --> 00:11:49,820
some flavor of Lisp? I can read parentheses. All right. Maybe half and half. Okay. Well,

119
00:11:49,820 --> 00:11:54,540
I'll teach you how to do it. I'll teach you how to do it. And some of the things I'm going to show

120
00:11:54,540 --> 00:12:00,140
you, like I said, this is jam packed full of deep ideas and I can only scratch the surface,

121
00:12:00,220 --> 00:12:06,220
but even scratching the surface may leave you dizzy. If that's the case, close your eyes,

122
00:12:07,100 --> 00:12:14,700
lean forward, and the room will stop spinning. And then as we go on, you'll be able to hopefully

123
00:12:14,700 --> 00:12:18,860
pick up on some of the concepts and ideas and I'll show you some stuff at the end that maybe

124
00:12:19,580 --> 00:12:24,460
will be surprising to you, even if you don't understand all the details. And the great thing

125
00:12:24,460 --> 00:12:31,180
is that once you have some sense of what this is about, you will be filled with a fiery passion to

126
00:12:31,180 --> 00:12:37,020
learn all the rest. And I can point you to some references for that or we can talk about it over

127
00:12:37,020 --> 00:12:45,900
a milkshake. So the first thing I'm going to do is talk about lists. Let's talk about lists. So

128
00:12:45,900 --> 00:12:53,900
Scheme is a Lisp and Lisp comes from List Processing. That's what Lisp stands for, List Processing.

129
00:12:53,980 --> 00:12:58,860
So we're going to talk about lists and symbols. That's the first thing we're going to talk about.

130
00:12:58,860 --> 00:13:06,140
So let me go ahead and start up trusty Shea Scheme, which is now covered under an open

131
00:13:06,140 --> 00:13:13,820
source license. Woohoo! All right. So Shea Scheme has this thing called the REPL and it's pronounced

132
00:13:13,820 --> 00:13:21,900
REPL not REPL. And this you probably are familiar with if you've used other languages that have

133
00:13:21,900 --> 00:13:26,860
interactivity. One of the cool things about a good scheme implementation is that even though I'm

134
00:13:26,860 --> 00:13:32,060
typing expressions interactively, those get compiled on the fly directly to machine code.

135
00:13:32,860 --> 00:13:37,900
Actually, at least some versions of, say, Shea does an analysis first to determine whether or not

136
00:13:37,900 --> 00:13:45,820
it's faster to evaluate it or faster to compile and evaluate it. So this is faster in general than

137
00:13:45,820 --> 00:13:55,260
a lot of systems. Okay. Let's write a simple scheme program like 5. 5 evaluates to 5. All right?

138
00:13:56,940 --> 00:14:01,740
We don't have to make it evaluate to 5, but let's pretend that we will. Now,

139
00:14:03,260 --> 00:14:11,100
what else can we have? We can have a list containing 5 and you could see the list is

140
00:14:11,100 --> 00:14:19,180
represented by these beautiful parentheses. We can have a list containing 5 and 6.

141
00:14:20,620 --> 00:14:30,460
Notice that I did not defile my program with commas or anything else like that.

142
00:14:30,860 --> 00:14:45,820
We can have a list that contains a list. What do you think is going to happen?

143
00:14:47,180 --> 00:14:55,580
More parentheses. Look at that. We can go deeper. We can go as deep as we want.

144
00:14:55,820 --> 00:15:01,340
So we have lists. We can have lists of lists. What is another name for a list of lists?

145
00:15:02,860 --> 00:15:10,300
A tree. Oh, have you ever heard of trees? Right? Have you heard of this thing called XML,

146
00:15:10,300 --> 00:15:17,820
this new thing? Do you know what language came before XML? What language?

147
00:15:18,060 --> 00:15:24,220
SGML. Yes, right. Have you heard of something, a beautiful thing called XSLT?

148
00:15:26,060 --> 00:15:31,180
Brings joy into your heart. Do you know what the SGML equivalent of XSLT was?

149
00:15:32,460 --> 00:15:40,300
See who knows the obscure stuff. Dissil? Has anyone heard of Dissil? DSSSL? What is that?

150
00:15:40,860 --> 00:15:46,140
Dynamic style and semantics language or whatever, something like that. You know what Dissil was?

151
00:15:47,100 --> 00:15:55,500
It was Lisp. It was R4RS Scheme. Because if you're going to work on tree structure data,

152
00:15:56,620 --> 00:16:00,620
what's the right way to work on it? A tree is an inductively defined data type.

153
00:16:01,340 --> 00:16:09,580
How do you deal with that recursion? That's how you deal with trees. So Lisp is all about recursion

154
00:16:09,580 --> 00:16:15,500
and dealing with trees. Programs, most programs, represented as trees. If you're going to have

155
00:16:15,580 --> 00:16:21,900
a programming language that can modify programs, what better way to do it? Well,

156
00:16:23,020 --> 00:16:27,820
the Haas scholars will say there are better ways. But anyway, don't listen to them.

157
00:16:30,460 --> 00:16:35,660
Okay. So we have lists and things like that. By the way, if you want to learn scheme,

158
00:16:35,660 --> 00:16:41,020
there's an awesome interactive fiction game by Andrew Plotkin, aka Zarf, called Lists and Lists,

159
00:16:41,660 --> 00:16:47,500
where a genie teaches you to program and scheme. And you can actually implement logic programming

160
00:16:47,500 --> 00:16:52,460
inside of that scheme, although eventually you'll run out of memory because the Z machine doesn't

161
00:16:52,460 --> 00:16:57,900
have that much space. But anyway, it's a good exercise. So we have lists. We have lists contained

162
00:16:57,900 --> 00:17:03,180
lists, which are trees. We have numbers which evaluate to themselves. There are other values

163
00:17:03,180 --> 00:17:10,140
like hash t is a representation of truth. There is no representation of beauty, but

164
00:17:11,340 --> 00:17:16,460
we have hash f, which is a representation of false. An interesting fact about scheme is that

165
00:17:16,460 --> 00:17:22,620
every value in scheme is considered true except for hash f. So five is considered true. Well,

166
00:17:22,620 --> 00:17:31,980
then that's beautiful. It is open to debate. So we have also this amazing and very deep operator

167
00:17:31,980 --> 00:17:40,460
called quotation. Quote. Quote. And that is the topic of a lot of stuff I won't get into. But

168
00:17:40,460 --> 00:17:46,780
quote itself, this is a very controversial operator, how it should behave. People have created

169
00:17:46,780 --> 00:17:52,780
entire versions of lists just based on different notions of quotation. But in scheme, the way

170
00:17:52,780 --> 00:17:58,940
quote works is quote of anything gives you back that thing. So we quoted five. We get back five.

171
00:17:58,940 --> 00:18:04,140
We actually don't need to quote five. Quote five is something called a self-quoting or self-evaluating

172
00:18:04,140 --> 00:18:10,060
literal. But we can do things like quote a list. We can quote a list of five, six. And we can

173
00:18:10,060 --> 00:18:17,260
back the list five, six. We can quote the empty list, which has nothing in it. Because we use

174
00:18:17,260 --> 00:18:22,140
quote so much, we don't necessarily want to write quote this way. We're going to have a shorthand.

175
00:18:22,140 --> 00:18:25,500
Scheme doesn't have a lot of shorthand, but this is one of them. So we're going to write

176
00:18:26,460 --> 00:18:37,340
quote somewhat like that. Five, six. Okay. This I will allow. I don't like too much, you know,

177
00:18:37,340 --> 00:18:42,620
messing with my symbolic expressions, but this is going to be okay. And then in addition to

178
00:18:42,620 --> 00:18:46,460
having things like numbers and lists and lists containing lists and true and false values or

179
00:18:46,460 --> 00:18:55,100
bullions, we have an amazing thing called the symbol. And if you program in Java, I'm sorry,

180
00:18:55,180 --> 00:18:58,860
you don't get symbols. If you program in many languages, you don't get symbols. But you do have

181
00:18:58,860 --> 00:19:09,260
symbols in a scheme in most lists. So we can say milkshake with a quote around. And that gives

182
00:19:09,260 --> 00:19:14,940
us back milkshake. Milkshake is a symbol. It's a symbol. It's not a string. Strings are different.

183
00:19:15,500 --> 00:19:20,380
Symbols are things that represent metaphorically objects that we might care about. Okay. This is

184
00:19:20,380 --> 00:19:26,540
an atomic value. We can't tear it apart. We can't do anything like that. It's a unique thing. And

185
00:19:26,540 --> 00:19:31,260
it turns out internally it's fast to compare symbols. So we can use symbols to represent

186
00:19:31,260 --> 00:19:37,420
interesting data. We don't have to say, oh, we're in C. And so a milkshake is five or whatever it is.

187
00:19:37,420 --> 00:19:43,980
Right? So we can do things like this, which are classier. Okay. So we have symbols, lists. We

188
00:19:43,980 --> 00:19:49,900
can have symbols inside of our lists and things like that. We can also make decisions. We can

189
00:19:50,780 --> 00:19:59,420
do things like ask if a list is empty. So I say, is the empty list null? So if I have a list,

190
00:20:01,340 --> 00:20:07,740
there's friends. The thing that comes inside the friends first, that is basically a function call.

191
00:20:08,460 --> 00:20:12,460
Unless it's something like, quote, there's something called special forms that have special

192
00:20:12,460 --> 00:20:17,180
evaluation rules. But in this case, we're just calling a function. And the function,

193
00:20:17,180 --> 00:20:21,020
you can tell, is a predicate. It has a question mark that's going to return true or false.

194
00:20:22,060 --> 00:20:29,900
So we're asking if the input expression evaluates to the empty list. And it does. We can ask if

195
00:20:29,900 --> 00:20:37,340
five is null. Five is not null. So we can make a function call. We have notions of predicates.

196
00:20:38,140 --> 00:20:44,700
We can also build up lists in other ways that I haven't shown you yet. So I showed you two ways

197
00:20:44,700 --> 00:20:52,460
of lists. So I can just quote a literal list or I can call a function called list. 3, 4, 5. I can also

198
00:20:55,020 --> 00:21:02,060
build up list-like structures using an operator called cons. Cons for construction. In fact,

199
00:21:02,060 --> 00:21:07,420
Dan Friedman, who is my advisor, wrote a very famous paper with David Wise in 1976 called

200
00:21:07,420 --> 00:21:11,500
cons should not evaluate its arguments, which was one of the first papers on laziness like

201
00:21:11,500 --> 00:21:15,900
you have in Haskell. And there was another paper by Henry Baker called cons should not cons its

202
00:21:15,900 --> 00:21:24,380
arguments. That must have stayed up all night coming up with that one. So the typical way to

203
00:21:24,380 --> 00:21:30,620
use cons is to cons some object onto an existing list. So we can cons five onto the empty list.

204
00:21:30,620 --> 00:21:35,980
Now we get a list containing five. And I can build up chains of things using cons. So I can

205
00:21:35,980 --> 00:21:41,820
cons six onto the list to get back from the cons five. Cons takes two arguments. And I can build

206
00:21:41,820 --> 00:21:50,620
these lists up. Okay? All right. So that's cons. And we've seen like the null test. Let me show

207
00:21:50,620 --> 00:22:01,980
you how to make a choice. So I can use something like if, if five is null, then return six. Otherwise

208
00:22:01,980 --> 00:22:07,580
return seven. So if has three sub expressions, we have a test expression, what's called the

209
00:22:07,580 --> 00:22:13,100
consequent expression, and then the alternative expression. So what would be the value of this

210
00:22:13,100 --> 00:22:22,460
expression? Seven. Okay? All right. So that's one way to make a choice. And there are other ways.

211
00:22:23,100 --> 00:22:28,940
Another way to make a choice is something called conned. And the reason, I'll use this notation,

212
00:22:29,820 --> 00:22:36,940
the reason that we have this conned operator, conditional operator, is that it may be that

213
00:22:36,940 --> 00:22:43,180
we want to make lots of choices. So instead of having nested ifs, which gets annoying at some

214
00:22:43,180 --> 00:22:55,180
point, we can do something like this. Okay? What do you think this expression will evaluate too?

215
00:22:56,140 --> 00:23:05,180
Eight. All right. Great. Awesome. And I'll show you a couple of the things. One is, you know,

216
00:23:05,180 --> 00:23:12,700
we can do things like addition or multiplication. Okay? So addition is like plus. It's actually

217
00:23:12,700 --> 00:23:18,540
a function bound to a procedure that knows how to do addition. We also have multiplication. So I go,

218
00:23:18,540 --> 00:23:26,620
blah, blah. Right? And so I can deal with big dumps, arbitrarily large precision integers. So

219
00:23:26,620 --> 00:23:35,820
that's multiplication. And I can also do things like define. I can define functions. I can define

220
00:23:35,820 --> 00:23:42,460
all sorts of things. I can give a name to something. I'll call this, I don't know. I just had a tarot

221
00:23:42,460 --> 00:23:50,540
milkshake. So define tarot to be, quote, good. And there's a symbol. And if I type tarot,

222
00:23:50,540 --> 00:23:55,980
then the variable gets looked up in something called an environment. And I get back the value

223
00:23:55,980 --> 00:24:02,780
of that variable, which is a symbol, good. So define just gives a name to some value. I can give

224
00:24:02,780 --> 00:24:09,340
other sorts of values if I want. It doesn't matter. And another concept is that of a function.

225
00:24:10,300 --> 00:24:15,260
And the reads are a procedure, technically. And the way I create a procedure is with this

226
00:24:15,260 --> 00:24:20,620
expression called lambda. You type it L-A-M-B-D-A, but I've got this fancy thing that turns it into

227
00:24:20,620 --> 00:24:28,540
a symbol. And what you do with lambda is you have a list of arguments. These are the formal

228
00:24:28,540 --> 00:24:33,740
parameters to your procedure. And then you have a body. So this is lambda xx is the way it

229
00:24:33,740 --> 00:24:38,380
pronounced it. And this is just going to return its argument, the value of its argument. So this

230
00:24:38,380 --> 00:24:44,220
is the identity function, the value of the identity function. And we've already seen that you can

231
00:24:44,220 --> 00:24:51,580
write parentheses. And parentheses normally mean a procedure call. We're not specifically calling

232
00:24:51,580 --> 00:24:56,780
it, but that's the case unless we have what's called a special form in the first position,

233
00:24:56,780 --> 00:25:05,260
like quote or define, something like that. So I am going to apply that, the value of that

234
00:25:06,300 --> 00:25:11,500
lambda expression, which we'll evaluate to a procedure, to the expression five. Five is an

235
00:25:11,500 --> 00:25:16,940
expression that evaluates to the value five. So we are starting to have the notion of expression

236
00:25:16,940 --> 00:25:22,540
versus value. And I get back five. Through a mechanism that involves a number of steps,

237
00:25:23,180 --> 00:25:29,580
we evaluate the argument expressions. There's something called the operator expression,

238
00:25:29,580 --> 00:25:36,460
the rater. And the rand, the upper rand, we evaluate the operator that evaluates to a

239
00:25:36,460 --> 00:25:43,340
procedure of one argument. We evaluate the rand expression that evaluates to itself in this

240
00:25:43,340 --> 00:25:49,740
case. And then we perform a procedure application. And we apply that procedure to the value of the

241
00:25:49,740 --> 00:25:55,180
argument. And we get back five in this case. Okay, so that's the mechanism that we're going to

242
00:25:55,180 --> 00:26:04,620
implement. And I can, of course, give a name to a function. I can only call it double.

243
00:26:09,820 --> 00:26:15,980
Okay, so now I have a body that's a little more interesting. And I can double my fun.

244
00:26:16,460 --> 00:26:23,980
That doesn't work. The Haskellers are going to give me grief. But I could double five and get

245
00:26:24,860 --> 00:26:31,980
two in binary. So you can double anything you want. And I can define all sorts of things. So

246
00:26:31,980 --> 00:26:41,020
I can do things like define, define to be five. Right? Why is that a, oh, that's a great thing.

247
00:26:41,580 --> 00:26:48,780
So I can do a lot more than that. I can change what lambda means and things like that. That's

248
00:26:48,780 --> 00:26:54,300
where the real fun begins. So I'm not going to talk about that. That's for the next talk. But

249
00:26:54,300 --> 00:27:03,660
I'm going to restart my scheme. Just saying, just saying, I could, I could fly solo with that one,

250
00:27:03,660 --> 00:27:09,500
but I know how to do it. But I'm not going to do, you're not ready yet. You're not ready yet.

251
00:27:11,900 --> 00:27:19,500
Okay. So, so now you know scheme. Okay, now you, well, you're joking, or you think,

252
00:27:20,060 --> 00:27:23,900
you think I'm joking, but that's basically all you need. Okay. There's one other thing I'm going

253
00:27:23,900 --> 00:27:30,380
to talk about or show you very quickly. That's not technically built into scheme, but it's easy

254
00:27:30,380 --> 00:27:35,900
to add because scheme houses very powerful macro system that allows you to extend the language

255
00:27:35,900 --> 00:27:41,340
in different ways. And so what I'm going to do is I'm going to load a macro for pattern matching,

256
00:27:41,340 --> 00:27:48,220
something called P match. And this is just one of many systems that allow you to do pattern

257
00:27:48,220 --> 00:27:54,700
matching. And so basically P match is similar in spirit to our cond, except now we are going

258
00:27:54,700 --> 00:27:59,580
to match against an expression. So I can say, we're going to match against list three, four.

259
00:28:00,300 --> 00:28:04,620
And now we can have just like with a cond, different pattern or different expression

260
00:28:04,620 --> 00:28:10,140
or different clauses, but now we're going to match against the pattern. So I could say

261
00:28:12,300 --> 00:28:18,460
I have a pattern that matches against the list of two arguments. And these commas,

262
00:28:19,180 --> 00:28:23,100
I'm not going to really get into the details of what the commas means syntactically,

263
00:28:23,100 --> 00:28:28,620
but basically you can think that this list of two elements is getting pattern matched against

264
00:28:28,620 --> 00:28:35,020
the list we get back, the list three, four. So the x will be associated with or bound to three,

265
00:28:35,020 --> 00:28:43,740
the y will be bound to four. And then on the right hand side, we can use those x's and y's.

266
00:28:44,380 --> 00:28:50,780
And sure enough, we get back seven. So that's what P match does. If you haven't seen pattern

267
00:28:50,780 --> 00:28:55,980
matching before, it's very powerful, especially in conjunction with a form of quotation in scheme

268
00:28:56,060 --> 00:29:00,700
called quasi quotation or back quote. That's really what's going on. If you know scheme,

269
00:29:00,700 --> 00:29:06,460
there's an implicit back quote here. And those commas are called unquote.

270
00:29:07,500 --> 00:29:14,380
All right. So now we know basically everything we need to write an interpreter. So let's do that.

271
00:29:16,540 --> 00:29:23,740
All right. So let me go back to my file here. So I'll load my P match. And I can put this code

272
00:29:23,980 --> 00:29:32,060
online if people want to see it. All right. Okay. So one thing that we need to

273
00:29:33,900 --> 00:29:39,420
do is, you know, decide on the name for our interpreter. That's the hard part, right?

274
00:29:40,060 --> 00:29:46,300
So names are hard. What would be a good name for interpreter? Fitz Roy.

275
00:29:46,300 --> 00:29:52,780
Okay. Define. Fitz Roy. How do you spell that?

276
00:29:55,420 --> 00:30:03,420
All right. So we have a name. This is our life now. And thank you. Derailed us all.

277
00:30:04,700 --> 00:30:08,140
So, well, what do you think I should type next?

278
00:30:08,460 --> 00:30:19,660
P match, almost. We're not quite right. The arguments. So we need to define a function.

279
00:30:19,660 --> 00:30:24,140
The procedure is going to do something. So I have to type lambda. That's a good thing.

280
00:30:24,860 --> 00:30:31,500
When in doubt, the answer is lambda, right? So we have a lambda expression that's going to take

281
00:30:31,500 --> 00:30:36,780
some arguments. Okay. So if we looked at our interpreter here when we were writing stuff

282
00:30:36,780 --> 00:30:45,100
like plus three, four, this is basically an interpreter. Technically, it's not an

283
00:30:45,100 --> 00:30:52,300
interpreter. That's a form of evaluation. But it's an evaluator. So if you look over there,

284
00:30:52,300 --> 00:30:59,100
we have an expression coming in. And we evaluate the expression to get a value back. So we can

285
00:30:59,100 --> 00:31:05,500
have an expression. That's a good name. And I'm going to call this eval expression. Okay.

286
00:31:06,380 --> 00:31:13,500
Fitz Roy would have been fine. But this is a val expert. It's important as a safety tip

287
00:31:13,500 --> 00:31:21,580
to not call that argument exp. Now, why would that be? Yeah. Because scheme has an exponential

288
00:31:21,660 --> 00:31:29,740
function built in called exp. And if you type, you get very interesting errors if you do it wrong.

289
00:31:29,740 --> 00:31:39,340
So I call it expert. All right. Yeah. If you call your function eval, hilarity, may ensue.

290
00:31:40,620 --> 00:31:49,500
You can always restart. Now. Now it's time for P match. And what are we going to P match against?

291
00:31:50,380 --> 00:31:57,100
Well, guess what? We don't have a lot of choice. How about expert? All right. So we're going to

292
00:31:57,100 --> 00:32:03,500
P match against. See, it writes itself. Okay. So what sort of expressions do we want to have

293
00:32:03,500 --> 00:32:09,660
in our language? How about numbers? Number is a good thing to be able to evaluate. We had five.

294
00:32:09,660 --> 00:32:17,500
That was our first scheme program. So we're going to evaluate five. So the way that you write that

295
00:32:17,500 --> 00:32:25,020
pattern is that comma in will match against anything. And I mean anything. So that's no good.

296
00:32:25,660 --> 00:32:31,420
We have to add something called a guard where we can add a predicate. And so the predicate

297
00:32:32,620 --> 00:32:39,340
is basically part of this matching process. So if the pattern matches against expert,

298
00:32:39,340 --> 00:32:43,900
then additionally, the guard has to return a true value. That is any other value,

299
00:32:44,460 --> 00:32:48,860
the value, anything other than the hash F in order for the entire pattern to be

300
00:32:48,860 --> 00:32:53,020
considered matching. And in which case, we try the right hand side. Yes.

301
00:32:59,820 --> 00:33:06,300
We could, we could totally use a con here. And in that case, we could just have, you know,

302
00:33:06,300 --> 00:33:11,260
the number question mark of N, right? So right now it's not really paying for itself. It's a lot,

303
00:33:11,340 --> 00:33:15,340
a lot more mechanism than we need. But when we start getting the things like lambda

304
00:33:15,340 --> 00:33:20,220
that have more structure, we could do, that's a very good question. We don't need P match.

305
00:33:20,220 --> 00:33:24,140
Okay. This should be very clear. We could do everything with car. Oh, sorry. Did I talk about

306
00:33:24,140 --> 00:33:28,300
car? Well, we'll talk about car in a minute, maybe. Maybe, maybe we can avoid talking about car.

307
00:33:29,020 --> 00:33:35,020
We'll see. There's like a historical accident that involves some of the names and scheme

308
00:33:35,020 --> 00:33:40,380
that have not yet been corrected intentionally. But we don't talk about that. So

309
00:33:41,420 --> 00:33:45,580
anyway, so we're, we're going to use P match for reasons we'll see in a minute.

310
00:33:45,580 --> 00:33:49,420
We don't have to. So what do you think a number should evaluate to?

311
00:33:51,180 --> 00:33:57,500
It's self. Okay. Sounds good. So we'll just write down N. So now we have an interpreter. So let's try it.

312
00:34:00,540 --> 00:34:05,580
Well, you know, I don't have that much time. Okay. So we're going to load this thing.

313
00:34:06,540 --> 00:34:20,140
Uh, interp.scm. Okay. And now we can test it. Eval expert. And all right. Someone give me a nice

314
00:34:20,140 --> 00:34:28,300
expression to evaluate. Five. You're, you will go far. But that's the wrong answer. The right

315
00:34:28,300 --> 00:34:34,780
answer is quote of five, because we want to make sure that whatever expression we pass in

316
00:34:35,660 --> 00:34:44,140
is not evaluated by scheme. A classic error. Let me show you. Well, our interpreter works so well

317
00:34:45,580 --> 00:34:53,100
that we already can handle addition. Wow. That's really impressive. And if you've written enough

318
00:34:53,100 --> 00:34:57,900
interpreters, you've run into this problem before. I was like, whoa, that's, I guess I can turn in

319
00:34:57,900 --> 00:35:04,300
my homework early. Okay. So that's why we put a quote in front of whatever we're passing in. So

320
00:35:04,300 --> 00:35:09,980
really quote of five. All right. Well, maybe we want to have more things than just numbers. How

321
00:35:09,980 --> 00:35:20,620
about we add, add one. Add one is a function and scheme that adds one to a numeric argument.

322
00:35:21,260 --> 00:35:30,460
So let's implement add one. So, let me add another clause here. And in this case, we're

323
00:35:30,460 --> 00:35:36,860
actually going to match against the list. Okay. So we see list structure. And now you start seeing

324
00:35:36,860 --> 00:35:42,860
why we're using P match. So the expression we expect is an add one expression, which has a

325
00:35:42,860 --> 00:35:47,580
sub expression inside of it. This could be arbitrarily complicated. This doesn't just have to be a

326
00:35:47,580 --> 00:35:52,140
number. This could be something that evaluates to another, such as another call to add one.

327
00:35:52,700 --> 00:35:55,420
Okay. All right. So what do we do now in this case?

328
00:36:00,380 --> 00:36:03,100
Oh, yeah. Add one. Well, where did we get add one from?

329
00:36:06,220 --> 00:36:10,860
Scheme. We hope it's built in. We'll see. All right. So I'm going to call

330
00:36:11,420 --> 00:36:22,780
val expert inside of E. All right. So I'm going to use schemes add one to implement add one in

331
00:36:22,780 --> 00:36:37,980
my language. Okay. That's cool. So let's try it. Okay. So now let me quote add one.

332
00:36:38,220 --> 00:36:47,420
Okay. And then I can always do the test like this because otherwise you might accidentally

333
00:36:48,140 --> 00:36:53,900
not evaluate the sub expression. All right. So now we can do add one. That's great.

334
00:36:55,980 --> 00:37:05,820
All right. And I have one called sub one. All right. Same thing, right? All right. I should

335
00:37:05,820 --> 00:37:11,500
have used copy and paste abstraction. Well, I kind of did. But okay. So you see how this goes.

336
00:37:12,940 --> 00:37:20,540
That's fine. We could add a few other things. So we could add something like multiplication.

337
00:37:23,420 --> 00:37:27,980
Now, multiplication is interesting because our version of multiplication is going to take two

338
00:37:28,060 --> 00:37:32,220
sub expressions. Ooh. You want to need two. So now how do we write this thing?

339
00:37:36,620 --> 00:37:42,220
How many recursive calls do we have to make? Do. Right? Well, this is like falling off a log.

340
00:37:43,260 --> 00:37:52,940
All right. Okay. So we're going to multiply what we get back when we evaluate E1 and E2

341
00:37:53,500 --> 00:38:03,260
and multiply that. Okay. All right. Let's do another one. How about if? So I already told you

342
00:38:03,260 --> 00:38:09,740
there's a test and a consequent and an alternative. So how do we evaluate if?

343
00:38:11,420 --> 00:38:20,700
Any ideas? This is tricky. Using if. You're catching on. All right. How about if

344
00:38:21,500 --> 00:38:28,140
evalexper of t copy and paste abstraction?

345
00:38:32,380 --> 00:38:38,380
Yeah. All right. There's probably like a copy and paste monad in Haskell or something, right?

346
00:38:40,700 --> 00:38:43,900
So copy and paste abstraction. Now we have, yes. Great.

347
00:38:51,500 --> 00:38:57,180
Can we short circuit? Well, for things like and and or, we might want to do short circuit

348
00:38:57,180 --> 00:39:02,700
evaluation for if we're going to have to evaluate the test. But if semantics are that if the test

349
00:39:02,700 --> 00:39:07,820
is true, we will only evaluate the first sub expression. Otherwise, we'll only evaluate

350
00:39:07,820 --> 00:39:18,060
this sub expression. So they won't both be evaluated. Okay. Okay. Now, basically, this

351
00:39:18,140 --> 00:39:24,140
interpreter is pretty boring. All right. It's pretty boring. And the reason is we have not

352
00:39:24,140 --> 00:39:28,380
gotten to the beautiful part of the interpreter. The beautiful part of the interpreter has to do

353
00:39:28,380 --> 00:39:37,900
with three lines and only three lines. What are those three lines? Lambda. That's the, I told you

354
00:39:37,900 --> 00:39:44,460
there's always the answer, right? Told you. What's the second one? It's not lambda. What was that?

355
00:39:45,420 --> 00:39:57,420
Apply application. And the third one. Not a vowel. Not procedure. Was that? Not defined.

356
00:39:59,340 --> 00:40:04,700
Not quote. Oh, wow. All right. Stumped y'all. Haha. All right. We'll figure it out in a minute.

357
00:40:05,420 --> 00:40:16,860
Okay. So, let's try, you know, let's try doing, let's try doing a vowel. Okay. So,

358
00:40:16,860 --> 00:40:22,540
we've already seen the syntax and scheme. It's minimalist to say, not ro-co-co. And

359
00:40:23,740 --> 00:40:28,940
basically, we have a raider expression, an operator expression, and an operand expression.

360
00:40:28,940 --> 00:40:33,740
If you read a book and you see raider and ran, that's what they mean. You want to put this line

361
00:40:33,740 --> 00:40:38,620
last in your P match so it doesn't overlap. This pattern does not overlap with the others.

362
00:40:38,620 --> 00:40:42,780
This becomes fun when you start doing logic programming where the ordering isn't supposed

363
00:40:42,780 --> 00:40:47,180
to matter. But in this case, P match evaluates in the top down. And so we're going to put our

364
00:40:47,180 --> 00:40:54,940
application case last. All right. Okay. What do we do? We know the drill. We are going to evaluate

365
00:40:55,020 --> 00:41:01,260
via copy and paste subtraction, the raider and the ran. Perfect. Evaluate the raider

366
00:41:02,860 --> 00:41:14,380
and evaluate the ran. All right. Now, what do we do with those two values? The raider is supposed

367
00:41:14,380 --> 00:41:19,740
to evaluate to a procedure, some representation of procedure. And this is going to evaluate to some

368
00:41:19,820 --> 00:41:23,180
argument that we're going to call the procedure on. So what do we do now?

369
00:41:24,300 --> 00:41:31,340
Apply it. How do we apply it? No. Lambda doesn't apply. But you're right that I got caught up.

370
00:41:32,380 --> 00:41:38,940
We're going to use apply, which is through parentheses. Right? That's it. If you blink,

371
00:41:38,940 --> 00:41:44,780
you'll miss it. Some people have what I might call parentheses blindness. And they just can't see

372
00:41:44,780 --> 00:41:50,300
that that is different than without those parentheses. But they are different. There's no

373
00:41:50,300 --> 00:41:57,100
mistaking the difference in behavior. Okay. So that is our application. Very nice. So that's

374
00:41:57,100 --> 00:42:03,420
one of our three magic operators. We also have this thing called lambda. So I can match against

375
00:42:03,420 --> 00:42:07,740
the lambda expression. This is where the pattern matching comes in nicely. And I can give a name

376
00:42:07,740 --> 00:42:15,900
to the variable. And I can have a body expression. Okay. So something has got to happen with the

377
00:42:15,900 --> 00:42:26,060
lambda. Do you see that x? What is x? Well, there's a list containing x, but the x itself,

378
00:42:26,060 --> 00:42:34,300
not part of the list. What does that mean? What is that thing? It's an identifier. And if the x

379
00:42:34,300 --> 00:42:41,820
were to appear inside of rand, what would that be? It's a variable reference. Okay. So this is how

380
00:42:41,820 --> 00:42:50,300
we have a variable reference. And what's the value of the variable x? Tell me. Don't know yet. When

381
00:42:50,300 --> 00:42:57,100
will you know? No, at runtime when we've actually done the procedure application. That's right.

382
00:42:57,100 --> 00:43:04,060
We won't know until then. So if I call the resulting procedure with five as the argument,

383
00:43:04,060 --> 00:43:11,020
what would be the value of x? Five. So we have this idea that if a variable appears in the body,

384
00:43:11,740 --> 00:43:16,140
at some point, we may have to look up the value associated with that variable or bound to the

385
00:43:16,140 --> 00:43:21,500
variable. And in order to do that, we need some mechanism for variable lookup. And the traditional

386
00:43:21,500 --> 00:43:27,340
way of doing that in this sort of interpreter is called an environment. So we are going to write

387
00:43:27,340 --> 00:43:34,300
an environment passing interpreter. Okay. Anytime you hear passing, that means that there's going

388
00:43:34,300 --> 00:43:40,620
to be an argument coming in to our function for the interpreter. So you see right now, we basically

389
00:43:40,620 --> 00:43:46,380
have a calculator, we have an expression, but there's no context of the expression. There's no

390
00:43:46,380 --> 00:43:52,300
notion of variable bindings that may be in play at this point. So we're going to have to add

391
00:43:52,300 --> 00:43:57,500
something else to this expression, or sorry, in addition to the expression, as an argument.

392
00:43:57,500 --> 00:44:04,540
So I'm going to add an environment. And this changes everything. All those three magic lines

393
00:44:04,540 --> 00:44:12,220
are going to in some way be involved with the environment. Okay. So now we have an environment

394
00:44:13,580 --> 00:44:19,660
and the environment is going to contain somehow associations between variables and values.

395
00:44:20,300 --> 00:44:25,500
Now, what do you think the third magic line of code is based on what you've seen?

396
00:44:27,900 --> 00:44:35,900
Parentheses? This is the parenthesis line, the application. Cons, nope. Cons is useful, but

397
00:44:35,900 --> 00:44:39,500
you actually don't need it. You only need these three lines. That's turn complete, actually. It's

398
00:44:39,500 --> 00:44:44,300
amazing. We can delete all the other junk. The other stuff is junk. You don't need it.

399
00:44:45,740 --> 00:44:49,100
You don't need it. You only need the three lines. And I'm serious about that.

400
00:44:49,740 --> 00:44:53,820
You only need the three lines. You heard this thing called a Turing machine? This came first.

401
00:44:54,700 --> 00:45:01,900
Lambda calculus came first. Girdle didn't believe church that it was Turing complete,

402
00:45:01,900 --> 00:45:08,300
even though Turing completeness hadn't been a term yet. Okay. We need one more thing. No,

403
00:45:08,300 --> 00:45:15,180
we don't need to find either. Was it? Variable lookup. That's it. That's the last piece of magic.

404
00:45:15,180 --> 00:45:23,340
We've got to have a way to look up those variables. All right. So, I need a guard because I have my

405
00:45:23,340 --> 00:45:31,500
match anything pattern. And I am going to represent variables as symbols. Okay. Because we have symbols

406
00:45:31,500 --> 00:45:37,900
and scheme. So, if we have a pattern which is just a symbol by itself, right, we're going to say

407
00:45:37,900 --> 00:45:43,980
that's a variable and we're going to look it up. How do we look up a variable? In the environment.

408
00:45:44,540 --> 00:45:49,100
Okay. Now I have to tell you a piece of information you don't know. I am going to represent my

409
00:45:49,100 --> 00:45:55,820
environment as a procedure of one argument that takes a variable. So, how do I actually look up

410
00:45:55,820 --> 00:46:02,860
X in the environment? I'm not going to evaluate it, actually. Look up X in the environment.

411
00:46:03,820 --> 00:46:10,140
Like that. Procedure call. Okay. This is where it gets kind of weird. It's like kind of spartan,

412
00:46:10,140 --> 00:46:15,340
right? I'm just like, ah, got a procedure. There's only one useful thing a procedure can do. Call it.

413
00:46:16,140 --> 00:46:21,420
Takes one argument. Give it one argument. Call a day. That's it. All right. So, that's what we're

414
00:46:21,420 --> 00:46:36,700
doing. Okay. Great. Now, lambda. What is lambda going to do? Ah, yes. Extend the environment.

415
00:46:36,780 --> 00:46:42,780
It's the magic word. The environment extension is the key thing here. So, lambda expression

416
00:46:42,780 --> 00:46:48,060
evaluates to what in scheme? A procedure. Okay. So, we have to have a representation

417
00:46:48,060 --> 00:46:52,060
of a procedure which you can think of as a delayed computation where we don't have enough

418
00:46:52,060 --> 00:46:56,860
information to do the computation in the body yet. But we're going to wait until the procedure

419
00:46:56,860 --> 00:47:01,500
gets called and then some value will be bound to that variable and then we'll be able to evaluate

420
00:47:01,500 --> 00:47:04,540
the body at that point because we'll have the correct context. We'll know the variable binding.

421
00:47:05,340 --> 00:47:13,420
So, we have to somehow represent a procedure. How can we represent a procedure, do you think?

422
00:47:14,540 --> 00:47:20,780
Lambda. There you go. 60% of the time, it works every time.

423
00:47:25,260 --> 00:47:32,780
All right. Lambda arg. That's right. We're going to have an argument coming in.

424
00:47:32,780 --> 00:47:37,900
What is that arg thing do you think? What does that correspond to in the three magic lines of code?

425
00:47:40,780 --> 00:47:43,500
It doesn't correspond to X and this is something we have to be very careful about.

426
00:47:46,780 --> 00:47:52,700
It corresponds to the value of the RAND. Remember, the procedure application line

427
00:47:52,700 --> 00:47:58,060
and the lambda line are intimately connected because we're going to end up doing a procedure call

428
00:47:58,700 --> 00:48:02,940
on this lambda expression. The value of that lambda expression. That's going to evaluate to a scheme

429
00:48:02,940 --> 00:48:06,940
procedure and we're going to call the scheme procedure and pass in the value of the operand.

430
00:48:07,500 --> 00:48:12,460
Therefore, arg will be bound to the value of operand. If we're calling the identity function

431
00:48:12,460 --> 00:48:20,940
on 5, RAND will be evaluated to 5, arg will be bound to 5. Okay? Keep that in mind. Okay.

432
00:48:20,940 --> 00:48:27,180
So, now what I heard was we have to evaluate the body in the extended environment. So,

433
00:48:27,180 --> 00:48:38,220
let's do that. How do we evaluate the body? If only we had a procedure that knew how to evaluate

434
00:48:38,220 --> 00:48:43,980
the body. Well, that's what we're writing. Magic of recursion. Evaluate the body. Now we have to feed

435
00:48:43,980 --> 00:48:50,860
in an environment and we have to go back and retcon these lines because you don't have environments

436
00:48:50,860 --> 00:48:56,140
yet. So, we have to have an environment. So, for these lines down here is kind of boring.

437
00:48:56,220 --> 00:49:02,620
It's just the good old environment. Okay? But up here, we need an extended environment.

438
00:49:02,620 --> 00:49:05,740
What is the extension? How are we extending the environment?

439
00:49:07,980 --> 00:49:13,580
Lambda. That's right. You laugh. It is correct. You extend it using lambda.

440
00:49:16,380 --> 00:49:23,100
Yeah. It's a one-trick pony, but it's got a good trick. Lambda. Why?

441
00:49:23,500 --> 00:49:32,540
Whoo. All right. This is when the nerd chills start. Okay. That is an environment. Remember,

442
00:49:33,100 --> 00:49:38,860
we wanted to look something up. We called X on the environment. Well, that's the sort of creature

443
00:49:38,860 --> 00:49:43,020
we're talking about. A procedure of one argument. We're creating a procedure of one argument.

444
00:49:43,020 --> 00:49:46,220
That's our environment. So, extended environment. So, what are we going to do with that environment?

445
00:49:46,220 --> 00:49:53,180
What's going to happen inside? If. Oh, wow. Yeah. That's right. We have to make a choice.

446
00:49:53,180 --> 00:50:00,540
If of what? Oh, I didn't tell you this part yet. If equals. Well, there's this thing called

447
00:50:01,340 --> 00:50:07,180
EQ. Huh. Okay. If what is equal? What two things do we want to compare?

448
00:50:07,580 --> 00:50:13,260
Y and X. Okay. If they are equal, then what do we return?

449
00:50:15,580 --> 00:50:23,020
Not X. Arrg. This is the critical piece. And here's the other critical piece. What do we do

450
00:50:23,020 --> 00:50:29,660
if they don't, if they aren't equal? Inv. We're going to look up an inv. What do we look up?

451
00:50:30,940 --> 00:50:36,540
Y. Not X. Y. Because Y is what's coming into that lambda, the innermost lambda. That innermost

452
00:50:36,540 --> 00:50:42,460
lambda is an environment, extended environment. That lambda right there is a procedure. So,

453
00:50:42,460 --> 00:50:48,700
we have what's called a higher order representation of environments and procedures in our interpreter.

454
00:50:49,580 --> 00:50:55,980
Okay. So, let me go and fix up my VAL experts to give them environments. See, these lines are

455
00:50:55,980 --> 00:51:00,140
boring because we're not messing with the environment at all. It's not interesting at all.

456
00:51:01,020 --> 00:51:05,580
And you could say the application line isn't messing with the environment. And that's true

457
00:51:05,580 --> 00:51:11,100
with this representation of procedures and environments. But if we change our representation

458
00:51:11,100 --> 00:51:15,980
of procedures and environments, it actually does matter. You'll see that if we were to use data

459
00:51:15,980 --> 00:51:24,060
structures such as lists to represent our environment and procedures, then this application

460
00:51:24,060 --> 00:51:28,220
line would have a different looking structure. Basically, the work that we're doing up here

461
00:51:28,220 --> 00:51:35,180
in the lambda line, we get put into the application line. All right. So, in theory, this should work

462
00:51:35,180 --> 00:51:45,340
now. We'll see if you're all paying attention. Okay. VAL expert, let's try it out. Okay. So,

463
00:51:45,340 --> 00:51:57,660
add one and hopefully it still works. Oh. All right. We didn't pass it in. Oh, the call was wrong.

464
00:51:57,660 --> 00:52:04,300
Oh, very clever. Okay. So, you're right. We need to call a VAL expert now with an environment.

465
00:52:04,300 --> 00:52:12,860
What does an environment look like? Lambda. Yeah. Again. See. All you need is lambda.

466
00:52:14,780 --> 00:52:18,380
Y. Okay. And what is this environment going to do?

467
00:52:20,620 --> 00:52:27,180
What happens if we look up a variable like X in this environment? What should happen? Error.

468
00:52:27,900 --> 00:52:32,300
Means it's not bound. Okay. This environment starts out with nothing bound unless we want

469
00:52:32,380 --> 00:52:38,460
to put it in there. So, we can do a call to a scheme's error. We can call it. Look up. Something

470
00:52:38,460 --> 00:52:46,380
like that. You know, unbound. All right. Perfect. Okay. We get back seven. I can now look up a

471
00:52:46,380 --> 00:52:55,580
variable in the empty environment like X and I got my error. Okay. I can go ahead and do something

472
00:52:55,580 --> 00:53:00,540
like create a lambda expression. Let me try to do lambda xx. Okay. It gives me a procedure,

473
00:53:00,860 --> 00:53:05,980
a scheme procedure representing my procedure in my language. I can do a procedure application.

474
00:53:05,980 --> 00:53:13,500
Let's see if this works. I'm going to apply it to five and get back five. Proof. It works. I can

475
00:53:13,500 --> 00:53:19,100
do something a little more interesting. Lambda applied to lambda. So, I should get back into

476
00:53:19,100 --> 00:53:28,620
any function and I can apply the result of that to five. Okay. And then there's one ultimate test

477
00:53:31,180 --> 00:53:38,300
case. I think we've implemented everything. Oh, there's one more thing we need to add. Let me

478
00:53:38,300 --> 00:53:44,540
just add one more clause which is zero, huh? Okay. So, we're going to add one more clause

479
00:53:44,540 --> 00:53:51,980
to see if something's equal to zero. Let me just follow our usual thing. All right. And I think

480
00:53:51,980 --> 00:53:59,180
that may be enough now to do what I was going to show. So, there's one standard test case

481
00:54:01,020 --> 00:54:13,660
which tests everything and it's factorial. And it is factorial using something called,

482
00:54:13,660 --> 00:54:19,100
what Dan Friedman calls the poor man's y-combinator. You'll notice we don't have define

483
00:54:19,180 --> 00:54:22,940
in our language or in our interpreter. There's something called let rec to define

484
00:54:22,940 --> 00:54:27,180
mutually recursive functions. We don't have that either. What we do have lambda and the answer

485
00:54:27,180 --> 00:54:35,260
to everything is lambda as we know. So, this code here is factorial. You can see this got

486
00:54:35,260 --> 00:54:39,420
some function calls and stuff like that, but it may be you can believe the math. And then that

487
00:54:39,420 --> 00:54:46,860
little part up top with a bunch of lambdas, the part up top basically is what reaches what's

488
00:54:46,860 --> 00:54:52,380
called a fixed point. And so, you can see in scheme it works. So, let's see if it works in

489
00:54:52,380 --> 00:55:03,660
our interpreter. I have no idea. We'll try it out. Yeah! All right. Awesome. Well done.

490
00:55:08,780 --> 00:55:13,740
Okay. So, let's look at the interpreter real quick and just a couple of words about it.

491
00:55:14,700 --> 00:55:21,180
So, the first thing I'll say is that everything except the last three lines is an abomination.

492
00:55:22,620 --> 00:55:29,180
So, we are going to remove the abominable code. Bam, bam, bam, bam, bam, bam, bam,

493
00:55:30,060 --> 00:55:37,340
that. Okay. This is the 3 by 5 card interpreter. I may have to reformat it slightly differently

494
00:55:37,340 --> 00:55:44,300
for the screen, but if you have a 3 by 4 meter card, I guess you could fit at this side. But,

495
00:55:44,300 --> 00:55:49,580
you can actually write down at least on a 4 by 6 card and that is the magic. Okay. This is the

496
00:55:49,580 --> 00:55:55,260
key to the universe. You have everything here. You have lexical scope. You have higher order

497
00:55:55,260 --> 00:56:00,860
functions. You have all these sorts of things. Numbers, you don't need them. You can do church

498
00:56:00,860 --> 00:56:09,420
encoding. Okay. You don't need if. You can encode if as well. You encode all those things.

499
00:56:09,420 --> 00:56:17,100
They're kind of nonsense. Yes, they're useful for efficiency and expressiveness. You don't need

500
00:56:17,100 --> 00:56:25,100
them. This is all you need. It's Turing complete. Came before the Turing machine. This is similar

501
00:56:25,100 --> 00:56:29,900
related to something called the lambda calculus. This is a little bit different because we're using

502
00:56:29,980 --> 00:56:36,220
an environment instead of beta reduction if you're familiar with that. But similar idea. People

503
00:56:36,220 --> 00:56:41,820
would call this the call by value lambda calculus interpreter. Environment passing. You can play

504
00:56:41,820 --> 00:56:48,140
all sorts of really interesting games with this. You can change the representation of the environments

505
00:56:48,700 --> 00:56:55,420
and the procedures. You can use data structures. You can do lists and pattern matching. You can do

506
00:56:55,420 --> 00:57:00,220
all sorts of really cool things. You can add additional arguments just like we added the

507
00:57:00,220 --> 00:57:05,260
environment. So now we have an environment passing interpreter. You can add a store as well, which

508
00:57:05,260 --> 00:57:12,300
contains basically the current value of a variable. And you can change those values. So if you have

509
00:57:12,300 --> 00:57:18,540
an environment and a store, that allows you to do mutation like set bang and scheme. You can also add

510
00:57:18,540 --> 00:57:23,420
continuations. You can CPS the interpreter. Do another correctness preserving program

511
00:57:23,420 --> 00:57:27,820
transformation. CPS it. That gives you a representation of the rest of the program at any

512
00:57:27,820 --> 00:57:33,420
point potentially as a procedure. And you can just call that continuation anywhere you want.

513
00:57:33,420 --> 00:57:37,820
And you can implement all sorts of control structures. If you CPS your program twice, you

514
00:57:37,820 --> 00:57:41,820
have two continuations. That gives you limited continuations. You can do basically every control

515
00:57:41,820 --> 00:57:45,820
structure at that point. All sorts of very interesting games you can play. You can change.

516
00:57:45,820 --> 00:57:52,780
Anyway, I'm not going to get into all that. But what I recommend you do is what Dan suggested

517
00:57:52,860 --> 00:57:57,260
to all his students. And as far as I know, I'm the only one who did it. Maybe other people did.

518
00:57:57,260 --> 00:58:03,740
He said take a four by six card stack of them and spend 45 minutes writing this down over and over

519
00:58:03,740 --> 00:58:09,820
again until your eyes start bleeding. Sear it into your brain and your heart. And you'll never

520
00:58:09,820 --> 00:58:16,780
forget it. And if you really understand it and you try, you know, turning the crank and doing a

521
00:58:16,780 --> 00:58:22,380
bunch of evaluations, at some point you'll start to get some idea of the magic. But all of

522
00:58:22,460 --> 00:58:29,340
computation, all of the turing complete processes, all of, you know, the notion of computable

523
00:58:29,340 --> 00:58:35,900
functions are within this code. The secrets there. You can do things that run forever. You

524
00:58:35,900 --> 00:58:40,460
can do all sorts of things. They're very interesting. You can express colats inside of it. Okay.

525
00:58:41,340 --> 00:58:49,020
So that is sort of like the teaser. And, you know, you can go off to races once you really

526
00:58:49,020 --> 00:58:54,940
have this on the brain. You can do things like change the type of scope you have. You can go

527
00:58:54,940 --> 00:59:01,420
from what we have here. It's just called lexical scope or static scoping to dynamic scoping by

528
00:59:01,420 --> 00:59:07,180
changing how the environment variable lookup works and things like that. I'm not going to go

529
00:59:07,180 --> 00:59:10,940
into all those things. If you're interested in that, there's a book called Essentials of Programming

530
00:59:10,940 --> 00:59:17,740
Languages by Dan Friedman and Mitchell Wan that talks about a lot of these things. And

531
00:59:18,860 --> 00:59:26,300
there are lots of other resources you can find. What I want to show you now is what happens when

532
00:59:27,180 --> 00:59:33,820
you play these games in sort of a different context. So

533
00:59:41,740 --> 00:59:47,580
this is a paper by John McCarthy called a micromanual for Lisp, not the whole truth.

534
00:59:48,860 --> 00:59:55,660
And in this, he gives the rules for an interpreter. Okay. So you were asking about cons. Well,

535
00:59:55,660 --> 01:00:03,820
here's your cons. This is what cons does. And he gives basically the rules for a Lisp evaluator.

536
01:00:04,780 --> 01:00:11,900
And, you know, basically, he's calling his evaluator value as our val expert. And you can see

537
01:00:11,900 --> 01:00:19,100
that he has these equal signs. You're saying that expression is equal to that value. Now,

538
01:00:19,100 --> 01:00:24,300
equal, the notion of equality is actually one of the most subtle notions in all of mathematics and

539
01:00:24,300 --> 01:00:28,780
logic and computer science. Anyone who thinks they understand equality is just kind of some

540
01:00:28,780 --> 01:00:34,460
throwaway idea hasn't thought about it hard enough. Like homotopy type theory. All these people

541
01:00:35,180 --> 01:00:40,940
trying to understand different notions of equality there. So it's a very deep topic. And one of

542
01:00:40,940 --> 01:00:46,460
the things that's interesting is that, you know, we tend to read that equal sign if we're doing

543
01:00:46,460 --> 01:00:51,180
programming, programming languages, interpreters, compiler, stuff like that, basically is one

544
01:00:51,180 --> 01:00:57,580
directional from left to right. So we have an expression. We evaluate it. We write some function

545
01:00:57,580 --> 01:01:01,660
that's an evaluator. We compile it, some code that's going to run it. And we're going from that

546
01:01:01,660 --> 01:01:06,540
expression to that value. It's not really an equal sign. It's like a right-hand side arrow if you

547
01:01:06,540 --> 01:01:12,700
want to think of it that way. But what if we took the equal sign seriously? What if we seriously

548
01:01:12,700 --> 01:01:18,860
said, all right, well, this is like an algebra, right? And what do you do in algebra? When you were

549
01:01:18,860 --> 01:01:24,460
in, you know, I'm not talking about like the modern algebra. I'm talking about like, you know, when

550
01:01:24,460 --> 01:01:28,060
you were in high school or whatever, you took algebra in high school. What sort of things did

551
01:01:28,060 --> 01:01:34,780
you do in algebra? Solve equations. You put in variables like x and y and z and things like that.

552
01:01:34,780 --> 01:01:39,660
And you're supposed to figure out what is the value of that variable, right? That makes both sides

553
01:01:39,660 --> 01:01:45,900
equal. We're going to do that. So I've done some of the heavy lifting for you with a bunch of other

554
01:01:45,900 --> 01:01:51,180
people. We spent like the last 12 years doing it. And I'm going to show you some of the stuff that

555
01:01:51,180 --> 01:01:58,780
we got from it. So what we did was we wrote, and I started this at Indiana with Dan Friedman,

556
01:01:58,780 --> 01:02:01,820
a bunch of other talented people. I'm working right now with a whole bunch of other people,

557
01:02:01,820 --> 01:02:07,100
including like Michael Ballantyne at Utah and Greg Rosenblatt and all these other fine folks.

558
01:02:07,740 --> 01:02:15,580
We wrote an interpreter in what's called a logic programming language, okay? Or a relational

559
01:02:15,580 --> 01:02:23,180
programming language, that's what I normally call it. And this one doesn't fit on a 3x5 card,

560
01:02:23,180 --> 01:02:31,100
but it's not that long, actually. It's what? 403 lines. But you can fit the 3x5 card version

561
01:02:31,100 --> 01:02:35,820
on here quite nicely. And actually it looks a lot like the algebra part. In fact, you can write

562
01:02:35,820 --> 01:02:43,980
down the semantics. So here are the three lines we wrote for our interpreter. This is how you would

563
01:02:43,980 --> 01:02:49,980
write it in like an operational semantics, sort of math-y. And then this is on the right hand side

564
01:02:49,980 --> 01:02:54,380
is how you would express it in this language called mini-canon. And you can see it's really not much

565
01:02:54,380 --> 01:03:01,100
longer. It's about the same length. Okay, so anyway, we took the time and wrote this interpreter.

566
01:03:01,100 --> 01:03:04,300
So we wrote something equivalent to a vowel X, but in fact, you can see it's called a vowel

567
01:03:04,300 --> 01:03:11,180
expo, right? We even used the same name. And so now let me see if I can figure out how to load

568
01:03:11,180 --> 01:03:19,100
this thing. That's the, it's always the hard part. Here's the transcript. Let's see that. All right,

569
01:03:19,100 --> 01:03:29,740
now let's go in here. And let's see. Load MK. You know, it's all fine and good until you have to

570
01:03:29,740 --> 01:03:35,660
do things like load a file, right? There's no math for that. Probably the monad or something

571
01:03:35,660 --> 01:03:45,740
junk for that. Anyway, let's do full and term. All right, cool. So in this logic programming

572
01:03:45,740 --> 01:03:51,260
system called mini-canon, we have the ability to write queries. And the queries let us,

573
01:03:51,260 --> 01:03:54,300
you can think of it from a sort of database standpoint, you can think of it as an algebra

574
01:03:54,300 --> 01:04:00,700
standpoint. It allows us to write down things where we want to solve for the values. So we have

575
01:04:01,260 --> 01:04:13,180
you vowel expert. And I'm going to evaluate some, you know, some thing and get the value of it back.

576
01:04:13,180 --> 01:04:19,500
Let me just make sure that worked. Oh, expo. Yeah, you think I'd learn. Incorrect number of

577
01:04:19,500 --> 01:04:24,940
arguments. It probably takes the empty. Oh, I bet it's called a valo. Yeah, I think, see if I've

578
01:04:24,940 --> 01:04:30,140
gotten a valo. Yeah, awesome. Okay. So I've hidden the environment in this version because I'm just

579
01:04:30,140 --> 01:04:33,500
starting out in the empty environment. That's why we're not seeing an environment. We could

580
01:04:33,500 --> 01:04:39,500
type it in if we wanted to. Okay. So what's happening here is we have an interpreter

581
01:04:40,140 --> 01:04:44,220
written in a somewhat different style than what we just wrote. We have an evaluator,

582
01:04:44,860 --> 01:04:51,340
you know, and we have an expression just like the expressions we're passing into a valo expert.

583
01:04:51,900 --> 01:04:57,820
And correspondingly, we have the value. So this is a little bit different than before in that

584
01:04:58,460 --> 01:05:05,980
we are actually able to specify what the output should be. Now, in this case, we are putting

585
01:05:05,980 --> 01:05:10,860
in a variable, which means we don't know. We don't know what the value should be. In fact,

586
01:05:10,860 --> 01:05:17,420
if you want to think of it from an algebra standpoint, you know, I'll call it x. Or maybe,

587
01:05:17,980 --> 01:05:23,180
you know, another way to call it would be, you know, a question mark or something, right? So this

588
01:05:23,740 --> 01:05:28,060
is an unknown and we're trying to figure out what the value of the unknown must be.

589
01:05:28,700 --> 01:05:33,020
And in this case, the value of the unknown is five. The expression five evaluates to five. Great.

590
01:05:33,820 --> 01:05:40,060
So let's try doing something a little more interesting. Let's try having a lambda expression,

591
01:05:40,060 --> 01:05:48,220
let's say, about lambda xx. Okay. Oh, that's a big thing. You can see that it begins with closure.

592
01:05:48,220 --> 01:05:54,380
So closure is one way to represent a procedure. So some representation of a procedure, I'm not

593
01:05:54,380 --> 01:06:11,420
going to get into the details of it. But I can apply that function. I can apply that procedure

594
01:06:12,380 --> 01:06:23,500
to five, for example. So the identity function applied to five. And it gives me back five. Okay.

595
01:06:24,140 --> 01:06:32,300
Great. Now, this so far is just treating it like an interpreter, just like what we had before.

596
01:06:32,940 --> 01:06:37,340
And we have all sorts of other things, like we have the ability to create lists.

597
01:06:38,060 --> 01:06:43,820
You know, I could, and we have this cons operator I told you about. I think we have cons. Let's see.

598
01:06:44,620 --> 01:06:53,660
Cons A onto the list B. Yep. All right. So I can build up list structures. I can do all sorts of

599
01:06:53,660 --> 01:07:01,660
things. But what I can also do is play games where maybe I don't know the input expression

600
01:07:02,380 --> 01:07:12,460
and I know an output. So maybe the output is I want milkshake. Right. And now what I want

601
01:07:12,460 --> 01:07:19,260
is an expression in scheme that when you evaluate it produces the list I want milkshake. Okay.

602
01:07:20,140 --> 01:07:30,380
So let's try it. Quote, I want milkshake is one such expression. How about two? Oh, here is a

603
01:07:30,380 --> 01:07:37,100
procedure call. A procedure that takes any number of arguments whose body is the expression, quote,

604
01:07:37,100 --> 01:07:42,700
I want milkshake applied to no arguments. And we can do all sorts of games like that. Here's

605
01:07:42,700 --> 01:07:47,340
another one. Like, I don't need to go like 10. See if there are any good ones. Oh, yeah. Here's a

606
01:07:47,340 --> 01:07:52,380
call to car, which gets the first element in the list. The car of a list containing the list,

607
01:07:52,380 --> 01:08:00,780
I want milkshakes. And I can do things like that. All right. That's fun. So I work in the lab of

608
01:08:00,780 --> 01:08:13,500
Matt might at Utah. And he has this blog post called 99 ways not to die to say I love you in

609
01:08:13,500 --> 01:08:18,300
racket. So this was like his Valentine's Day post, right? It's like a slow Valentine's Day. You

610
01:08:18,300 --> 01:08:26,780
write this blog post. And it's 99 expressions in racket or scheme or whatever that actually

611
01:08:26,780 --> 01:08:40,380
evaluate to the list. I love you. Okay. So let's do that. So let's go back and come up with a run

612
01:08:40,460 --> 01:08:50,700
99 and say I love you. And we get all these programs. So here's one. It's called a list and

613
01:08:50,700 --> 01:08:54,460
it has a function call inside of it and stuff like that. And every one of these I can evaluate in

614
01:08:54,460 --> 01:09:04,300
scheme and it works just fine. All right. Yeah. Okay. So that's kind of fun. So let's try another

615
01:09:04,300 --> 01:09:15,980
one. Going back to John McCarthy's paper. He has this little note. So it's a difficult mathematical

616
01:09:15,980 --> 01:09:23,660
type exercise. Find a list E that means a program expression E such that the value of E is equal to

617
01:09:23,660 --> 01:09:29,900
E. What is that called? It's a quine. So we want to find a program that evaluates to itself. So how

618
01:09:29,900 --> 01:09:40,700
can we write such a query? Yeah. Well, let's let's out of respect to John McCarthy, call our variable

619
01:09:40,700 --> 01:09:48,780
E. We want E to evaluate to E. All right. Oh, that's a representation of a number five evaluates to

620
01:09:49,340 --> 01:09:57,500
five. That's true. Let's see who hash T evaluates to hash T. That's true. Hash F evaluates to hash

621
01:09:57,580 --> 01:10:03,020
F. Let's see if there's anything. Let's run for a second. Oh, what is this thing?

622
01:10:06,380 --> 01:10:10,780
All right. Forget those side conditions. Here's a more interesting looking expression

623
01:10:11,500 --> 01:10:16,700
and that evaluates to itself. Oh, okay. So we can do things like generate quines.

624
01:10:17,340 --> 01:10:23,100
What else can we do? Well, Michael Valentine at this point said, well, you know,

625
01:10:23,660 --> 01:10:30,140
what if you had a more interesting scheme expression that you're evaluating? So let's try

626
01:10:30,140 --> 01:10:34,780
something a little more interesting. So let's try doing something like

627
01:10:40,380 --> 01:10:46,380
writing a program that concatenates to lists. And, you know, don't worry about the syntax here. It's

628
01:10:47,020 --> 01:10:54,700
going to look, you know, if you don't know scheme, you may not read every single thing, but we're

629
01:10:54,700 --> 01:11:02,380
going to append, okay, and define a function called append that takes to lists L and S

630
01:11:02,460 --> 01:11:17,740
and is going to have an if. Make this a little smaller. If L is empty, then we return S. Otherwise,

631
01:11:17,740 --> 01:11:27,020
we're going to cons on the car of L to a recursive call to append with the rest of the list. That's

632
01:11:27,740 --> 01:11:35,500
called the Cutter and S. Okay. So let wreck, let's me define a recursive function. And now I'm

633
01:11:35,500 --> 01:11:43,980
going to have a call to append. I'm going to say append ABC to DE. And let's see if that works.

634
01:11:43,980 --> 01:11:50,700
And sure enough, it works. So it gives me ABCDE in a list because we can actually

635
01:11:50,700 --> 01:11:53,340
produce more than one answer. So let me show you what that would look like.

636
01:11:53,660 --> 01:12:02,460
What we could do is, well, actually let me show you something else first. So what if we put in the

637
01:12:02,460 --> 01:12:09,180
answer first? We know the answer should be ABCDE. Okay. So we put in the answer. And now I can put

638
01:12:09,180 --> 01:12:16,460
in that variable thing, the question mark, anywhere I want. So I can put in the question mark

639
01:12:16,780 --> 01:12:25,580
inside this argument. So I'm asking what list when it appended to DE gives me ABCDE. So what list

640
01:12:25,580 --> 01:12:35,420
should that be? ABC. And sure enough, I get that. Okay. I could ask for two things. Maybe X and Y.

641
01:12:36,380 --> 01:12:43,980
So I could say I want X and I want Y. There are all sorts of games I could show you with this,

642
01:12:43,980 --> 01:12:51,500
but I'm just going to show you a couple. So now I can have two lists that appended together

643
01:12:51,500 --> 01:12:57,340
give me ABCDE. And you can see the empty list applied to ABCDE is one such pair of lists.

644
01:12:57,340 --> 01:13:01,500
And I can actually ask for all such pairs. So I can do a run star.

645
01:13:04,380 --> 01:13:09,500
And now I get all the pairs back. And so if you've seen logic programming, if you've seen

646
01:13:09,500 --> 01:13:16,940
languages like prologue or minicanron, they let you do this sort of query. But notice we didn't

647
01:13:16,940 --> 01:13:23,100
write a logic program. We just took a scheme program in our interpreter. So we're taking the

648
01:13:23,100 --> 01:13:29,740
equal sign seriously. We're saying that equality really does mean equal. And there's no direction

649
01:13:29,740 --> 01:13:37,260
to that equal sign. We should be able to solve for any side. Okay. So let's try one more example.

650
01:13:37,740 --> 01:13:47,980
We could do something like have ABC and DE. And now we say the answer should be ABCDE.

651
01:13:47,980 --> 01:13:57,100
And minicanron responds with some gibberish that means that that's consistent. Okay. So the question

652
01:13:57,100 --> 01:14:05,020
is, where else could we put a logic variable representing something unknown? In the code.

653
01:14:05,740 --> 01:14:15,100
Yes. Yeah. All right. So I don't know. Let me find a target. How about this s? Let me put something

654
01:14:15,100 --> 01:14:25,500
there. I think this is the one with run star is a bad idea. Run one is good. And sure enough,

655
01:14:25,500 --> 01:14:31,900
it inferred the s that I removed and things like that. Now, at this point, we're actually doing

656
01:14:31,900 --> 01:14:39,980
program synthesis. So we have the ability to specify information in the form of things like

657
01:14:40,620 --> 01:14:47,020
the expected input and the corresponding expected output and use the semantics of our

658
01:14:47,020 --> 01:14:54,300
interpreter that we wrote as a relation and logic programming system to do inference, do a search

659
01:14:54,300 --> 01:14:59,340
basically and do constraint solving to try to infer the missing values. And those missing values

660
01:14:59,340 --> 01:15:04,860
could be the input arguments, the function, the output to the function, even code or some mixture

661
01:15:04,860 --> 01:15:12,060
thereof. We can put variables anywhere we want. Yeah. Let's try that. That's a good question.

662
01:15:12,940 --> 01:15:23,180
So let's go back to what we had. This is it. Yep. Let me put it where the append was. What do you

663
01:15:23,180 --> 01:15:31,580
think I'll get back? Oh, sorry. I have to change this back to the question mark.

664
01:15:32,620 --> 01:15:34,220
Hopefully append, right? Everybody start.

665
01:15:39,180 --> 01:15:49,500
What? Oh, did I call it runs? Oh, hilarity will ensue. That's the answer you expected, right?

666
01:15:49,740 --> 01:15:56,220
A procedure that ignores this argument and returns the list, AVCDE.

667
01:15:58,300 --> 01:16:05,100
Many canons like prove me wrong. I defy you to prove me wrong.

668
01:16:07,020 --> 01:16:13,500
So this is the fun for a thing you get into. So let's try to... So many canons like the genie,

669
01:16:13,500 --> 01:16:22,780
right? The genie is like, tell me your wish. I'm ready to go. So what we're going to do is we're

670
01:16:22,780 --> 01:16:31,260
going to create a list of calls to append. Sorry. I don't remember if we have lists or not. I think

671
01:16:31,260 --> 01:16:36,380
we have lists. So we'll have more than one test. That's right. So let's do two tests. So one will

672
01:16:36,380 --> 01:16:43,500
be empty list to empty list. And then in the output, we will have a list of expected outputs.

673
01:16:43,500 --> 01:16:52,220
So we'll have the empty list and then the list AVC. Oops. Let me try this. See if this works.

674
01:16:52,940 --> 01:16:56,700
Yeah, now it came up with a pen. So I was like, all right, I've got to work for it.

675
01:16:57,420 --> 01:17:04,380
Okay. Now what are we asked for two? So what happens? I don't know. I have no idea. Oh, okay.

676
01:17:04,940 --> 01:17:10,460
It's what that is. In case you can't read that. It's a direct application of a

677
01:17:10,460 --> 01:17:16,220
variadic function call with zero arguments, which returns the procedure of pen. It's like,

678
01:17:16,220 --> 01:17:23,020
okay, well, I'm no dummy. I'll keep doing that. So this version is quite slow. And if you want

679
01:17:23,020 --> 01:17:31,500
to synthesize code for real, it can take quite a while. But we've been working on a new tool.

680
01:17:32,220 --> 01:17:39,580
Let's see if I can zoom in. Ooh, it works today. Nice. All right. There's a tool called Barlemin

681
01:17:39,580 --> 01:17:48,300
that I've been developing with Greg Rosenblatt and Michael Bountine and other people. And this tool

682
01:17:49,100 --> 01:17:53,820
is basically just an interface. I learned a little bit of Swift code and I wrote this.

683
01:17:55,100 --> 01:18:00,300
You can see it's beautiful. And basically, this is just an interface on what you saw

684
01:18:00,300 --> 01:18:06,940
with some optimizations behind. It runs about 10 million times faster than the naive version.

685
01:18:07,900 --> 01:18:12,300
When you're doing program sensors, that's important because you're in an exponential space. So

686
01:18:12,940 --> 01:18:19,660
we are going to write a pen a slightly different way. So the code in the upper left

687
01:18:20,300 --> 01:18:27,100
is our definition of a pen. You can see we left some parts out. So we left the name of the function

688
01:18:27,100 --> 01:18:31,580
out. That's this comma a. That's a mini-canron logic variable. It's a meta variable. You can

689
01:18:31,580 --> 01:18:35,420
think of it as a whole in the program. We don't know what that expression is. We don't know what

690
01:18:35,420 --> 01:18:39,100
the arguments are to lambda or how many there are or anything like that. And we don't know what the

691
01:18:39,100 --> 01:18:45,260
body of the lambda is. So we're going to let our tool come up with that for us. And what we're

692
01:18:45,260 --> 01:18:50,140
going to do is just give some examples of a pen. So I'm going to append two lists, the empty list,

693
01:18:50,140 --> 01:18:54,860
to the empty list. So give me the empty list. And Barlowman's going to think about it and say,

694
01:18:54,860 --> 01:19:02,300
I've got a solution for you. You want a function called a pen. He's like, yes, very well. That

695
01:19:02,300 --> 01:19:08,860
function can take any number of arguments. Well, strictly, schemes of pen can. And it's going to

696
01:19:08,860 --> 01:19:16,620
return to the empty list. Right? Very exciting moment. All right. Well, that's okay, I guess.

697
01:19:17,340 --> 01:19:26,060
How about we have a list containing two lists, list A and list B, and we want to get back A, B.

698
01:19:27,100 --> 01:19:35,740
Okay. Well, add another test. Oh, lucky day. You want a function called a pen, which takes

699
01:19:35,740 --> 01:19:41,820
two arguments and doesn't matter what the names are. And if the second argument is empty, we'll

700
01:19:41,820 --> 01:19:46,540
return that. Why not? Because that's the first test. Otherwise, we'll return to list A, B.

701
01:19:48,460 --> 01:19:52,540
All right. Well, that's getting a little annoying. So let's introduce a new concept,

702
01:19:52,540 --> 01:19:57,500
that of the gensim, the generated symbol. We don't actually care what's in that list.

703
01:19:58,140 --> 01:20:02,860
We just want to make sure that that's not going to appear in the output program. As long as it

704
01:20:02,860 --> 01:20:08,620
doesn't appear in the output program, we're happy. So we're going to change that. Oh, now we do have

705
01:20:08,620 --> 01:20:15,180
to do a little more work. Two arguments, null test on the second argument. The second argument is

706
01:20:15,180 --> 01:20:21,420
null. Otherwise, we have to start doing some operations, cars and cons and things like that.

707
01:20:21,420 --> 01:20:25,980
But we haven't, there's no recursive call. It's not going to work. So let me try one more.

708
01:20:26,540 --> 01:20:32,060
List of length two. Yeah, you can see where this game goes.

709
01:20:41,420 --> 01:20:42,460
Let's think about that.

710
01:20:47,740 --> 01:20:53,740
It's thinking. It's like, all right. There's some putting in some work. Oh, what? Looks

711
01:20:53,740 --> 01:20:58,700
like a recursive call. That looks perilously close to being correct. It's a little hard to read.

712
01:20:58,700 --> 01:21:06,220
So I will give it, I will use the editor part to fill in some concrete names and see what we can get.

713
01:21:06,860 --> 01:21:13,900
Oh, that is a pen. That's nice. It's example-based program synthesis. Furthermore,

714
01:21:14,540 --> 01:21:18,460
I can do some other things that are interesting, like I could add a few more tests.

715
01:21:18,940 --> 01:21:27,180
So I could say append of list A to the empty list. Should be empty list. I could say append.

716
01:21:30,300 --> 01:21:36,780
Oh, oh, yeah. Yes. Yeah, garbage in, garbage out. Good call.

717
01:21:36,860 --> 01:21:47,820
Oh, okay. Anyone would like a job as a QA tester for Barleman.

718
01:21:48,860 --> 01:21:53,500
Okay. So I wrote some more tests. And of course, Barleman could already synthesize it. So it's

719
01:21:53,500 --> 01:22:00,460
not really necessary. But imagine for a second that maybe this program is too hard for Barleman

720
01:22:00,460 --> 01:22:05,340
to synthesize. So instead of having Barleman synthesize the program from the examples,

721
01:22:05,340 --> 01:22:10,540
we're going to do test-driven development, right? I mean, this is real test-driven development.

722
01:22:12,460 --> 01:22:17,500
So we wrote our tests first, and now we're going to write our code, right? So I'm going to call it

723
01:22:17,500 --> 01:22:25,980
a pen. If I call it, like, you know, king cat, many kinderans are like, no, wrong. Computer says no.

724
01:22:27,260 --> 01:22:32,860
Fail. All right. So let's call it a pen. And let's say we're going to take two arguments,

725
01:22:32,860 --> 01:22:42,460
L and S, like before. Great. And we probably want an if and a null check on L. And, you know,

726
01:22:42,460 --> 01:22:49,340
we can start kind of filling in the structure here. And Barleman can probably synthesize that,

727
01:22:49,340 --> 01:22:54,460
fine. But let's pretend we're working on something a little more complicated, and Barleman can't do

728
01:22:54,460 --> 01:22:59,900
it. So now I'm typing. And notice I've got some holes in my program. So I don't know what those

729
01:22:59,900 --> 01:23:03,500
are. And those are arbitrary expressions. This could be, you know, gigantic, right? I could have

730
01:23:03,500 --> 01:23:09,420
a scheme compiler as A or something. It is solving it faster because I've filled in more.

731
01:23:10,300 --> 01:23:13,660
The current version of Barleman, sometimes you fill in more and it's like really slow.

732
01:23:13,660 --> 01:23:20,300
Because it gets slower. So we're working on that. But anyway, so let me put in L. That's one of my

733
01:23:20,300 --> 01:23:25,500
arguments. So I'm going to think, hey, L is probably the right one. Oh, Barleman's like, no.

734
01:23:25,580 --> 01:23:31,420
Computer says, no. That particular test is incompatible with the partially specified program

735
01:23:31,420 --> 01:23:36,780
you've written. So what we can do is write our tests, try to use it for synthesis. But if it's too

736
01:23:36,780 --> 01:23:42,380
slow for synthesis, we can just use this as an editor. And it's constantly in the background

737
01:23:42,380 --> 01:23:47,900
taking up all your corridors and heating your apartment. And desperately trying to prove,

738
01:23:48,540 --> 01:23:53,660
and this is a proof because many cameras are theorem prover, that the partially specified code

739
01:23:53,660 --> 01:23:57,820
you've written is actually incompatible with when you test. It doesn't mean your test is wrong.

740
01:23:57,820 --> 01:24:01,660
Maybe your code is wrong. Maybe they're both wrong. Maybe the semantics for the interpreter

741
01:24:01,660 --> 01:24:09,100
underlying Barleman is wrong. But they're certainly inconsistent, right? And I think this sort of

742
01:24:09,100 --> 01:24:17,420
technology is, you know, getting ready at this point to be practical for at least some use cases.

743
01:24:17,420 --> 01:24:21,020
And I should also point out that there are many other people working on program synthesis,

744
01:24:21,580 --> 01:24:27,100
I think a renaissance in that area right now. But I do think that one thing that's interesting

745
01:24:27,100 --> 01:24:34,060
is sort of the way we're doing synthesis, which is by taking that interpreter that I showed you

746
01:24:34,060 --> 01:24:38,460
in the beginning, this beautiful piece of code, and looking at the original description of it

747
01:24:38,460 --> 01:24:43,580
in those equal signs, and taking the equal signs seriously. We're going back and revisiting this

748
01:24:43,580 --> 01:24:51,340
artifact that people had an understanding of, and we're trying to actually execute, you know,

749
01:24:51,340 --> 01:24:56,140
another way of looking at it, this relational semantics view. And people, you know, people

750
01:24:56,140 --> 01:25:00,460
know relational semantics. I mean, the way that the math was written down is as relations.

751
01:25:01,580 --> 01:25:06,620
But the whole point is we've designed this language mini-canron to let us encode these

752
01:25:06,620 --> 01:25:11,180
relations in a nice way, and then did a bunch of optimizations. So when you write an interpreter

753
01:25:11,180 --> 01:25:16,140
as a relation, you can do this fill-in-the-blank game, right? And there are all sorts of other

754
01:25:16,140 --> 01:25:21,260
examples I could show you with mini-canron, and some really neat things. If you're interested in

755
01:25:21,260 --> 01:25:27,820
that, you might check out the closure conge talk that I gave with Greg Rosenblatt at the conge,

756
01:25:27,820 --> 01:25:33,020
last year's conge. And we show off a whole bunch of examples of this sort of thing. And, you know,

757
01:25:33,020 --> 01:25:38,140
we're trying to actively improve it and explore other ways to do things. And we can take things

758
01:25:38,140 --> 01:25:42,860
like a proof checker and turn it into a theorem prover by making it a relation, all sorts of fun

759
01:25:42,860 --> 01:25:48,780
games. So if this appeals to you, let me know. You might check out the webpage mini-canron.org

760
01:25:48,780 --> 01:25:54,220
that has a description of a lot of the work we've been doing. And also, I run hangouts on

761
01:25:54,220 --> 01:25:59,820
Saturdays and Sundays, an intro hangout series, an advanced hangout series, to talk about some

762
01:25:59,820 --> 01:26:04,220
of these technologies. Just send me an email, drop my line, hang out, we'll get a milkshake.

763
01:26:04,220 --> 01:26:07,020
And we talk about these things. If this thing you're interested in, you want to actually do

764
01:26:07,020 --> 01:26:12,060
some research, work on it, hacking, whatever, you could probably improve the user interface

765
01:26:12,060 --> 01:26:18,700
of Parliament if nothing else, right? So anyway, this is why I think the interpreter,

766
01:26:19,340 --> 01:26:25,500
that interpreter written in Lisp, that's higher order, is so beautiful, such a beautiful object,

767
01:26:25,500 --> 01:26:31,740
that not only is it very, very dense and an interesting amalgam of very important ideas,

768
01:26:32,620 --> 01:26:38,860
but you can look at that object from many different standpoints, like I said, that infinite tower

769
01:26:38,860 --> 01:26:44,940
of interpreters, or any number of other ways, from program transformation standpoint,

770
01:26:44,940 --> 01:26:50,300
from a relational semantic standpoint, and so forth. And each time you look at that object,

771
01:26:50,300 --> 01:26:57,180
that like five line core program from a different standpoint, it yields some more secrets,

772
01:26:57,900 --> 01:27:02,380
right? In some sense, we know everything about the interpreter, but in some other real sense,

773
01:27:02,380 --> 01:27:05,900
like I would not have guessed that you could do this sort of thing just by taking that

774
01:27:06,460 --> 01:27:11,580
program and encoding it in a logic programming language, but you can, it turns out. I think

775
01:27:11,580 --> 01:27:17,820
that's really amazing. So that's why I think that's a really beautiful artifact and I hope

776
01:27:17,820 --> 01:27:23,740
everyone will take the time to really study it and get to know it and find their own ways of

777
01:27:23,740 --> 01:27:30,620
looking at it and new ways to consider how that thing works, okay? Thank you. Thank you very much.

778
01:27:31,900 --> 01:27:32,620
Round of applause.

779
01:27:37,100 --> 01:27:42,860
We have time for like two very short questions and then we have to get out of here. So we have one

780
01:27:42,860 --> 01:27:49,020
right in front here real fast. If you treat these tests as constraints to the program that

781
01:27:49,020 --> 01:27:53,020
is trying to guess, can you apply like meta constraints? Can you say like, I want this to be

782
01:27:53,020 --> 01:27:58,220
like a constant time algorithm or I want it to be, you know, an element of memory or something like

783
01:27:58,220 --> 01:28:04,780
that? That's a good question. So, you know, part of the issue is how do you specify what it is you

784
01:28:04,780 --> 01:28:09,580
want the program to do? And so one way is with these tests, you could also use something like

785
01:28:09,580 --> 01:28:13,980
types because we won't write type inferences in the same style. You can also write high level

786
01:28:13,980 --> 01:28:17,580
properties and logic. There are a whole bunch of ways you could do it. And you could also say

787
01:28:17,660 --> 01:28:22,780
something about the expected running time or desired running time and so forth. We're not at

788
01:28:22,780 --> 01:28:26,300
the point where we can do things like talk about the desired running time, although it is something

789
01:28:26,300 --> 01:28:34,380
I'd like to be able to do. And so no, you can't do that yet, but one of the areas we're very interested

790
01:28:34,380 --> 01:28:38,860
in is trying to do more expressiveness. Probably the most recent thing that we've been playing with

791
01:28:38,940 --> 01:28:47,740
that's interesting is just yesterday, I started, I basically wrote a version of this technology

792
01:28:48,380 --> 01:28:54,140
where you can take scheme programs, look at common patterns in scheme in terms of very simple and

793
01:28:54,140 --> 01:29:01,180
just looking at what the parent is for an expression like what, you know, if you see a define, it

794
01:29:01,180 --> 01:29:05,580
turns out there's usually a lambda inside of it. If you see a lambda, there's usually an if or a

795
01:29:05,580 --> 01:29:11,180
cond inside of it and looking for those sorts of simple patterns and specializing the relational

796
01:29:11,180 --> 01:29:16,620
interpreter based on that very, very simple knowledge. So instead of just having the semantics,

797
01:29:17,180 --> 01:29:22,220
the system also would know a little bit about sort of standard human style or things like that.

798
01:29:22,860 --> 01:29:27,100
And that alone looks like it speeds up since there's many orders of magnitude and we're

799
01:29:27,100 --> 01:29:32,300
trying to figure out can we apply that to sort of the optimizations we've already made. So I think

800
01:29:32,460 --> 01:29:36,940
the bottom line is like there's a whole bunch of things that we just haven't explored yet, but

801
01:29:36,940 --> 01:29:40,940
I think it's definitely possible. And there are other people in this program census community

802
01:29:40,940 --> 01:29:47,180
who particularly work on that problem of trying to synthesize programs that have, you know,

803
01:29:47,180 --> 01:29:51,340
different expected, you know, running times and things like that. This is a very cool problem.

804
01:29:53,260 --> 01:29:56,140
More questions. There's a lot to take in I know.

805
01:29:57,100 --> 01:29:57,580
Short.

806
01:30:00,220 --> 01:30:05,660
When you gave the example of coming up with the answer append, how does it,

807
01:30:05,660 --> 01:30:08,780
how do you seed the search space? Like how did it know to find append,

808
01:30:08,780 --> 01:30:10,540
how did it append to get into the search space?

809
01:30:10,540 --> 01:30:14,700
Well, I mean, it didn't find append first, right? It created a function that just returns a list.

810
01:30:16,060 --> 01:30:21,100
Well, because we have an interpreter, the interpreter has a notion of scoping,

811
01:30:21,100 --> 01:30:26,940
just like we implemented variable lookup. We implemented variable lookup in that interpreter,

812
01:30:26,940 --> 01:30:33,020
and the semantics of let rec, the binding structure of let rec means that within that call, you know,

813
01:30:33,020 --> 01:30:38,060
so the call to append was inside the definition of append. So therefore in the environment append

814
01:30:38,060 --> 01:30:42,940
is there because we define the function. And so one of the things it's going to try to do,

815
01:30:42,940 --> 01:30:46,780
the interpreters going to try to do is look up the variables that are currently bound in the

816
01:30:46,780 --> 01:30:50,300
environment and try all of those and see if that will help lead to a solution.

817
01:30:51,740 --> 01:30:54,620
Anyone else?

818
01:30:57,500 --> 01:31:01,180
No? All right. Thank you so much.

