So I'm Will and I was a middle school teacher and I ran a summer camp and I did all these
things and then at some point I got a degree in computer science and I worked as a Java
developer and all this stuff, right?
And then I got fed up with the JavaScript and the Java and all that and I went to graduate
school at Indiana University to work with Dan Friedman who you may have heard of.
He's someone who wrote a book called The Little Lisper and a revised version called The Little
Schemer and The Season Schemer.
I wrote a book with him called The Reason Schemer and I took Dan's class the first semester
I was there and a couple of weeks in to the class, Dan showed me a program that changed
my life and basically I spent the last 12, 13 years trying to understand these five lines
of code, right?
And I will spend the rest of my life trying to understand the implications of these five
lines of code and this is what I like, okay?
So some people like writing a hundred thousand line compiler or an operating system kernel
with two million lines of code or whatever and that's great.
What I like is sort of going the opposite way.
I like the 3 by 5 card or the 4 by 6 card and if you're not an American, I don't know
what that is, it's A4 or something, I don't know, it's like a 3 by 5 card, maybe a 4 by
6 card.
If you can't fit down the idea on a 4 by 6 card, then think harder.
That sort of Dan's philosophy, right?
And ideally you get it down to the 3 by 5 card and then you write a little book on it
and so that's kind of his way of thinking and I share a lot of that sensibility.
So what I would like to talk a little bit about today is this program that I saw and
it just floored me.
And to this day I get nerd chills every time I think about it, right, I really get nerd
chills and I think, you know, I was nervous about, I am nervous about giving this talk
because one of the dangers I think is that when you've been programming for a while and
I know a lot of people in this audience like NoLisp or they've worked through SICP or they've
written lots of interpreters and all these sorts of things, they know something about
Lambda Calculus, after a while you can feel like you understand something and that's the
most dangerous way of thinking is to think you understand something, right, and that
there are no, you know, kind of new tricks in this and basically every time I learn something
new about computer science or, you know, every couple of years or something like that, I
like to go back and try to think about those things which I learned a long time ago and
I'd stop thinking about, you know, because I thought at least, you know, I've got some
grasp of this and almost always I'll have a new angle, right, and for the really, truly
deep ideas, computer science or anywhere in the other field, you know, there are many
ways of looking at these deep ideas and I'm going to show you, you know, a couple ways
of looking at this program but I'm not kidding when I can say that I'm going to spend the
rest of my life trying to understand it and there are many other people who've tried to
spend, you know, their careers basically understanding aspects of this five line program and, you
know, to give you sort of a reminder of, you know, a five line program, the amount of complexity
you can fit in there. Does anyone know about the Colatz function? What's the Colatz function?
Yeah, it's this little function, you know, like three in plus one and, you know, you have
like a division by two or something like that and, you know, basically you're trying to figure
out if you give an integer, a positive integer as an input, will this operation terminate?
It's just got some multiplications, additions and divisions, right, and it's like the tiny
little program and, you know, it's like a three line or two line program and the best mathematicians
in the world have been trying to prove for many decades utterly without success that this
program always terminates if you give a positive integer and Paul Erdisch, one of the great
mathematicians of all time, at one point said, mathematics is not ready for the Colatz
problem, right? So that's a three line program who's stumped some of the greatest minds in
history. So I'm talking about like a five line program, okay? So that should give you pause.
That should give you pause and we all have to have a healthy amount of respect for the three by
five card program. So anyway, the program I'm going to talk about is an interpreter for Lisp
written in Lisp. And it's one of these things where if you don't know Lisp and you first see it
and you're like, oh, what are these parentheses? And then after a while you kind of start thinking,
what is this lambda thing? That's something to wrap your head around. And why are there two
lambdas like nested? What does that mean? And you kind of go over these different ideas at
the time and eventually you kind of get some sense. You trace through a bunch of programs and
you're like, all right, I kind of get some sense of what's going on. And then you start modifying
the interpreter. And one of the great things about this program is that there's so many ways to change
it and explore it and play with it. You can add arguments to the interpreter. You can rewrite
the interpreter in a variety of correctness preserving transformation styles. One program
transformation you can apply is something called continuation passing style, which I consider
the gateway drug of program transformations. You know, normally you CPS that sucker and then from
then on, you know, it's off to the races. So, you know, you CPS an interpreter, you CPS it twice,
that gives you delimited continuations. And now you're cooking with gas. You can add a store
argument to the interpreter, right? You can add boxes and you could start doing, you know,
mutation and side effects in different ways. You can do call by value versus call by need versus
call by name trivially, right? You can do all sorts of things that are really deep and give you
deep insights into concepts of programming languages that you'll use, you know, the rest of your
career or the rest of your hobby years or whatever. And so I don't know of any other artifact in all
of computer science that packs so many ideas and the potential extensions to explore so many
different areas as this interpreter. And in fact, you know, Alan Kaye says that when he first saw
the Lisp interpreter written in Lisp at the bottom of page 13 of the Lisp 1.5 manual, right?
It changed his life and he realized these are Maxwell's equations of software, right?
It's very much the same right down four little equations. It helps if you like take them from
the other mathematicians and physicists and call them mathmen. But you said, you know, you write
down the four equations and you put that on the three by five card, right? And then you spend the
rest of your life trying to understand what those four equations are, what the implications are.
So that's very much what this interpreter is. And I'm, you know, I can't do justice to it.
I can only show you a couple of the many aspects of this multi-aspected, you know, beautiful system
and many of which, you know, I feel like I'm a complete noob too. But I can tell you that
there are very interesting things out there. So, for example, there's this idea of reflective
towers of interpreters. We have an interpreter interpreting an interpreter interpreting an
interpreter. That part's already interesting. But when you have infinitely deep tower or
infinitely tall tower, that's when it starts getting fun. And in particular, it becomes
especially fun when the interpreter being interpreted by another interpreter can reach
back up into the interpreter interpreting it and change the semantics of itself by changing how
the interpreter interpreting it works. And this is one of the things that Dan Freedman says he
refuses to work on because it melted his brain too much. It's like basically the one thing that he's
like, he won't touch anymore. So that's the sort of fun you can have. You know, it's bad enough
having a five or six line program, but when you have infinitely many of them interacting in these
ways, then you can do very interesting things. And if you're interested in that sort of thing,
I would point you to the work of Kanichi Asai. And also, my friend Nada Min gave a keynote
at Strange Loop a few years ago when she talked about this. I think she called the talk Programming
Should Eat Itself. And she talked about this reflective tower idea. Okay, so that's just
one aspect. You can go deep. You can go deep that direction if you want. I haven't touched that yet.
I want to connect that with the thing I'm going to show you. And even the people who do
this type of very bizarre programming, they kind of get scared look on their face when they start
thinking about the implications. So that's a good feeling when you're scaring the veterans
of the Lambda Calculus. So that's something I want to accomplish. And there are many,
many other directions you can go. Program transformation, directions, different evaluation
orders, all sorts of things. And then you can layer a type system on it, that kind of thing.
Now you have the interpreter and a type inferencer and a share structure. And you can have them
interact in interesting ways and all these sorts of things. So just like CPS is the gateway drug,
program transformations, Lisp in Lisp is the gateway drug of the whole world of programming
languages, I think. So what we're going to do is write an interpreter. We're going to write
the Lisp in Lisp in the way that Dan wrote it. And Paul Airdish, the great mathematician, had this
idea that there was a book that God kept that had every beautiful proof in it. Only the beautiful ones.
And every once in a while, he or someone else would come across a particularly elegant
and beautiful proof and say, oh, that's a proof in the book. And so we're going to see a program in
the book. This is the program in the book. I've written hundreds of interpreters and I've read
lots of books on interpreters, but this to me is the one in the book. Everything else is a pale
limitation. All right. So who here is familiar with S expressions, symbolic expressions or
some flavor of Lisp? I can read parentheses. All right. Maybe half and half. Okay. Well,
I'll teach you how to do it. I'll teach you how to do it. And some of the things I'm going to show
you, like I said, this is jam packed full of deep ideas and I can only scratch the surface,
but even scratching the surface may leave you dizzy. If that's the case, close your eyes,
lean forward, and the room will stop spinning. And then as we go on, you'll be able to hopefully
pick up on some of the concepts and ideas and I'll show you some stuff at the end that maybe
will be surprising to you, even if you don't understand all the details. And the great thing
is that once you have some sense of what this is about, you will be filled with a fiery passion to
learn all the rest. And I can point you to some references for that or we can talk about it over
a milkshake. So the first thing I'm going to do is talk about lists. Let's talk about lists. So
Scheme is a Lisp and Lisp comes from List Processing. That's what Lisp stands for, List Processing.
So we're going to talk about lists and symbols. That's the first thing we're going to talk about.
So let me go ahead and start up trusty Shea Scheme, which is now covered under an open
source license. Woohoo! All right. So Shea Scheme has this thing called the REPL and it's pronounced
REPL not REPL. And this you probably are familiar with if you've used other languages that have
interactivity. One of the cool things about a good scheme implementation is that even though I'm
typing expressions interactively, those get compiled on the fly directly to machine code.
Actually, at least some versions of, say, Shea does an analysis first to determine whether or not
it's faster to evaluate it or faster to compile and evaluate it. So this is faster in general than
a lot of systems. Okay. Let's write a simple scheme program like 5. 5 evaluates to 5. All right?
We don't have to make it evaluate to 5, but let's pretend that we will. Now,
what else can we have? We can have a list containing 5 and you could see the list is
represented by these beautiful parentheses. We can have a list containing 5 and 6.
Notice that I did not defile my program with commas or anything else like that.
We can have a list that contains a list. What do you think is going to happen?
More parentheses. Look at that. We can go deeper. We can go as deep as we want.
So we have lists. We can have lists of lists. What is another name for a list of lists?
A tree. Oh, have you ever heard of trees? Right? Have you heard of this thing called XML,
this new thing? Do you know what language came before XML? What language?
SGML. Yes, right. Have you heard of something, a beautiful thing called XSLT?
Brings joy into your heart. Do you know what the SGML equivalent of XSLT was?
See who knows the obscure stuff. Dissil? Has anyone heard of Dissil? DSSSL? What is that?
Dynamic style and semantics language or whatever, something like that. You know what Dissil was?
It was Lisp. It was R4RS Scheme. Because if you're going to work on tree structure data,
what's the right way to work on it? A tree is an inductively defined data type.
How do you deal with that recursion? That's how you deal with trees. So Lisp is all about recursion
and dealing with trees. Programs, most programs, represented as trees. If you're going to have
a programming language that can modify programs, what better way to do it? Well,
the Haas scholars will say there are better ways. But anyway, don't listen to them.
Okay. So we have lists and things like that. By the way, if you want to learn scheme,
there's an awesome interactive fiction game by Andrew Plotkin, aka Zarf, called Lists and Lists,
where a genie teaches you to program and scheme. And you can actually implement logic programming
inside of that scheme, although eventually you'll run out of memory because the Z machine doesn't
have that much space. But anyway, it's a good exercise. So we have lists. We have lists contained
lists, which are trees. We have numbers which evaluate to themselves. There are other values
like hash t is a representation of truth. There is no representation of beauty, but
we have hash f, which is a representation of false. An interesting fact about scheme is that
every value in scheme is considered true except for hash f. So five is considered true. Well,
then that's beautiful. It is open to debate. So we have also this amazing and very deep operator
called quotation. Quote. Quote. And that is the topic of a lot of stuff I won't get into. But
quote itself, this is a very controversial operator, how it should behave. People have created
entire versions of lists just based on different notions of quotation. But in scheme, the way
quote works is quote of anything gives you back that thing. So we quoted five. We get back five.
We actually don't need to quote five. Quote five is something called a self-quoting or self-evaluating
literal. But we can do things like quote a list. We can quote a list of five, six. And we can
back the list five, six. We can quote the empty list, which has nothing in it. Because we use
quote so much, we don't necessarily want to write quote this way. We're going to have a shorthand.
Scheme doesn't have a lot of shorthand, but this is one of them. So we're going to write
quote somewhat like that. Five, six. Okay. This I will allow. I don't like too much, you know,
messing with my symbolic expressions, but this is going to be okay. And then in addition to
having things like numbers and lists and lists containing lists and true and false values or
bullions, we have an amazing thing called the symbol. And if you program in Java, I'm sorry,
you don't get symbols. If you program in many languages, you don't get symbols. But you do have
symbols in a scheme in most lists. So we can say milkshake with a quote around. And that gives
us back milkshake. Milkshake is a symbol. It's a symbol. It's not a string. Strings are different.
Symbols are things that represent metaphorically objects that we might care about. Okay. This is
an atomic value. We can't tear it apart. We can't do anything like that. It's a unique thing. And
it turns out internally it's fast to compare symbols. So we can use symbols to represent
interesting data. We don't have to say, oh, we're in C. And so a milkshake is five or whatever it is.
Right? So we can do things like this, which are classier. Okay. So we have symbols, lists. We
can have symbols inside of our lists and things like that. We can also make decisions. We can
do things like ask if a list is empty. So I say, is the empty list null? So if I have a list,
there's friends. The thing that comes inside the friends first, that is basically a function call.
Unless it's something like, quote, there's something called special forms that have special
evaluation rules. But in this case, we're just calling a function. And the function,
you can tell, is a predicate. It has a question mark that's going to return true or false.
So we're asking if the input expression evaluates to the empty list. And it does. We can ask if
five is null. Five is not null. So we can make a function call. We have notions of predicates.
We can also build up lists in other ways that I haven't shown you yet. So I showed you two ways
of lists. So I can just quote a literal list or I can call a function called list. 3, 4, 5. I can also
build up list-like structures using an operator called cons. Cons for construction. In fact,
Dan Friedman, who is my advisor, wrote a very famous paper with David Wise in 1976 called
cons should not evaluate its arguments, which was one of the first papers on laziness like
you have in Haskell. And there was another paper by Henry Baker called cons should not cons its
arguments. That must have stayed up all night coming up with that one. So the typical way to
use cons is to cons some object onto an existing list. So we can cons five onto the empty list.
Now we get a list containing five. And I can build up chains of things using cons. So I can
cons six onto the list to get back from the cons five. Cons takes two arguments. And I can build
these lists up. Okay? All right. So that's cons. And we've seen like the null test. Let me show
you how to make a choice. So I can use something like if, if five is null, then return six. Otherwise
return seven. So if has three sub expressions, we have a test expression, what's called the
consequent expression, and then the alternative expression. So what would be the value of this
expression? Seven. Okay? All right. So that's one way to make a choice. And there are other ways.
Another way to make a choice is something called conned. And the reason, I'll use this notation,
the reason that we have this conned operator, conditional operator, is that it may be that
we want to make lots of choices. So instead of having nested ifs, which gets annoying at some
point, we can do something like this. Okay? What do you think this expression will evaluate too?
Eight. All right. Great. Awesome. And I'll show you a couple of the things. One is, you know,
we can do things like addition or multiplication. Okay? So addition is like plus. It's actually
a function bound to a procedure that knows how to do addition. We also have multiplication. So I go,
blah, blah. Right? And so I can deal with big dumps, arbitrarily large precision integers. So
that's multiplication. And I can also do things like define. I can define functions. I can define
all sorts of things. I can give a name to something. I'll call this, I don't know. I just had a tarot
milkshake. So define tarot to be, quote, good. And there's a symbol. And if I type tarot,
then the variable gets looked up in something called an environment. And I get back the value
of that variable, which is a symbol, good. So define just gives a name to some value. I can give
other sorts of values if I want. It doesn't matter. And another concept is that of a function.
And the reads are a procedure, technically. And the way I create a procedure is with this
expression called lambda. You type it L-A-M-B-D-A, but I've got this fancy thing that turns it into
a symbol. And what you do with lambda is you have a list of arguments. These are the formal
parameters to your procedure. And then you have a body. So this is lambda xx is the way it
pronounced it. And this is just going to return its argument, the value of its argument. So this
is the identity function, the value of the identity function. And we've already seen that you can
write parentheses. And parentheses normally mean a procedure call. We're not specifically calling
it, but that's the case unless we have what's called a special form in the first position,
like quote or define, something like that. So I am going to apply that, the value of that
lambda expression, which we'll evaluate to a procedure, to the expression five. Five is an
expression that evaluates to the value five. So we are starting to have the notion of expression
versus value. And I get back five. Through a mechanism that involves a number of steps,
we evaluate the argument expressions. There's something called the operator expression,
the rater. And the rand, the upper rand, we evaluate the operator that evaluates to a
procedure of one argument. We evaluate the rand expression that evaluates to itself in this
case. And then we perform a procedure application. And we apply that procedure to the value of the
argument. And we get back five in this case. Okay, so that's the mechanism that we're going to
implement. And I can, of course, give a name to a function. I can only call it double.
Okay, so now I have a body that's a little more interesting. And I can double my fun.
That doesn't work. The Haskellers are going to give me grief. But I could double five and get
two in binary. So you can double anything you want. And I can define all sorts of things. So
I can do things like define, define to be five. Right? Why is that a, oh, that's a great thing.
So I can do a lot more than that. I can change what lambda means and things like that. That's
where the real fun begins. So I'm not going to talk about that. That's for the next talk. But
I'm going to restart my scheme. Just saying, just saying, I could, I could fly solo with that one,
but I know how to do it. But I'm not going to do, you're not ready yet. You're not ready yet.
Okay. So, so now you know scheme. Okay, now you, well, you're joking, or you think,
you think I'm joking, but that's basically all you need. Okay. There's one other thing I'm going
to talk about or show you very quickly. That's not technically built into scheme, but it's easy
to add because scheme houses very powerful macro system that allows you to extend the language
in different ways. And so what I'm going to do is I'm going to load a macro for pattern matching,
something called P match. And this is just one of many systems that allow you to do pattern
matching. And so basically P match is similar in spirit to our cond, except now we are going
to match against an expression. So I can say, we're going to match against list three, four.
And now we can have just like with a cond, different pattern or different expression
or different clauses, but now we're going to match against the pattern. So I could say
I have a pattern that matches against the list of two arguments. And these commas,
I'm not going to really get into the details of what the commas means syntactically,
but basically you can think that this list of two elements is getting pattern matched against
the list we get back, the list three, four. So the x will be associated with or bound to three,
the y will be bound to four. And then on the right hand side, we can use those x's and y's.
And sure enough, we get back seven. So that's what P match does. If you haven't seen pattern
matching before, it's very powerful, especially in conjunction with a form of quotation in scheme
called quasi quotation or back quote. That's really what's going on. If you know scheme,
there's an implicit back quote here. And those commas are called unquote.
All right. So now we know basically everything we need to write an interpreter. So let's do that.
All right. So let me go back to my file here. So I'll load my P match. And I can put this code
online if people want to see it. All right. Okay. So one thing that we need to
do is, you know, decide on the name for our interpreter. That's the hard part, right?
So names are hard. What would be a good name for interpreter? Fitz Roy.
Okay. Define. Fitz Roy. How do you spell that?
All right. So we have a name. This is our life now. And thank you. Derailed us all.
So, well, what do you think I should type next?
P match, almost. We're not quite right. The arguments. So we need to define a function.
The procedure is going to do something. So I have to type lambda. That's a good thing.
When in doubt, the answer is lambda, right? So we have a lambda expression that's going to take
some arguments. Okay. So if we looked at our interpreter here when we were writing stuff
like plus three, four, this is basically an interpreter. Technically, it's not an
interpreter. That's a form of evaluation. But it's an evaluator. So if you look over there,
we have an expression coming in. And we evaluate the expression to get a value back. So we can
have an expression. That's a good name. And I'm going to call this eval expression. Okay.
Fitz Roy would have been fine. But this is a val expert. It's important as a safety tip
to not call that argument exp. Now, why would that be? Yeah. Because scheme has an exponential
function built in called exp. And if you type, you get very interesting errors if you do it wrong.
So I call it expert. All right. Yeah. If you call your function eval, hilarity, may ensue.
You can always restart. Now. Now it's time for P match. And what are we going to P match against?
Well, guess what? We don't have a lot of choice. How about expert? All right. So we're going to
P match against. See, it writes itself. Okay. So what sort of expressions do we want to have
in our language? How about numbers? Number is a good thing to be able to evaluate. We had five.
That was our first scheme program. So we're going to evaluate five. So the way that you write that
pattern is that comma in will match against anything. And I mean anything. So that's no good.
We have to add something called a guard where we can add a predicate. And so the predicate
is basically part of this matching process. So if the pattern matches against expert,
then additionally, the guard has to return a true value. That is any other value,
the value, anything other than the hash F in order for the entire pattern to be
considered matching. And in which case, we try the right hand side. Yes.
We could, we could totally use a con here. And in that case, we could just have, you know,
the number question mark of N, right? So right now it's not really paying for itself. It's a lot,
a lot more mechanism than we need. But when we start getting the things like lambda
that have more structure, we could do, that's a very good question. We don't need P match.
Okay. This should be very clear. We could do everything with car. Oh, sorry. Did I talk about
car? Well, we'll talk about car in a minute, maybe. Maybe, maybe we can avoid talking about car.
We'll see. There's like a historical accident that involves some of the names and scheme
that have not yet been corrected intentionally. But we don't talk about that. So
anyway, so we're, we're going to use P match for reasons we'll see in a minute.
We don't have to. So what do you think a number should evaluate to?
It's self. Okay. Sounds good. So we'll just write down N. So now we have an interpreter. So let's try it.
Well, you know, I don't have that much time. Okay. So we're going to load this thing.
Uh, interp.scm. Okay. And now we can test it. Eval expert. And all right. Someone give me a nice
expression to evaluate. Five. You're, you will go far. But that's the wrong answer. The right
answer is quote of five, because we want to make sure that whatever expression we pass in
is not evaluated by scheme. A classic error. Let me show you. Well, our interpreter works so well
that we already can handle addition. Wow. That's really impressive. And if you've written enough
interpreters, you've run into this problem before. I was like, whoa, that's, I guess I can turn in
my homework early. Okay. So that's why we put a quote in front of whatever we're passing in. So
really quote of five. All right. Well, maybe we want to have more things than just numbers. How
about we add, add one. Add one is a function and scheme that adds one to a numeric argument.
So let's implement add one. So, let me add another clause here. And in this case, we're
actually going to match against the list. Okay. So we see list structure. And now you start seeing
why we're using P match. So the expression we expect is an add one expression, which has a
sub expression inside of it. This could be arbitrarily complicated. This doesn't just have to be a
number. This could be something that evaluates to another, such as another call to add one.
Okay. All right. So what do we do now in this case?
Oh, yeah. Add one. Well, where did we get add one from?
Scheme. We hope it's built in. We'll see. All right. So I'm going to call
val expert inside of E. All right. So I'm going to use schemes add one to implement add one in
my language. Okay. That's cool. So let's try it. Okay. So now let me quote add one.
Okay. And then I can always do the test like this because otherwise you might accidentally
not evaluate the sub expression. All right. So now we can do add one. That's great.
All right. And I have one called sub one. All right. Same thing, right? All right. I should
have used copy and paste abstraction. Well, I kind of did. But okay. So you see how this goes.
That's fine. We could add a few other things. So we could add something like multiplication.
Now, multiplication is interesting because our version of multiplication is going to take two
sub expressions. Ooh. You want to need two. So now how do we write this thing?
How many recursive calls do we have to make? Do. Right? Well, this is like falling off a log.
All right. Okay. So we're going to multiply what we get back when we evaluate E1 and E2
and multiply that. Okay. All right. Let's do another one. How about if? So I already told you
there's a test and a consequent and an alternative. So how do we evaluate if?
Any ideas? This is tricky. Using if. You're catching on. All right. How about if
evalexper of t copy and paste abstraction?
Yeah. All right. There's probably like a copy and paste monad in Haskell or something, right?
So copy and paste abstraction. Now we have, yes. Great.
Can we short circuit? Well, for things like and and or, we might want to do short circuit
evaluation for if we're going to have to evaluate the test. But if semantics are that if the test
is true, we will only evaluate the first sub expression. Otherwise, we'll only evaluate
this sub expression. So they won't both be evaluated. Okay. Okay. Now, basically, this
interpreter is pretty boring. All right. It's pretty boring. And the reason is we have not
gotten to the beautiful part of the interpreter. The beautiful part of the interpreter has to do
with three lines and only three lines. What are those three lines? Lambda. That's the, I told you
there's always the answer, right? Told you. What's the second one? It's not lambda. What was that?
Apply application. And the third one. Not a vowel. Not procedure. Was that? Not defined.
Not quote. Oh, wow. All right. Stumped y'all. Haha. All right. We'll figure it out in a minute.
Okay. So, let's try, you know, let's try doing, let's try doing a vowel. Okay. So,
we've already seen the syntax and scheme. It's minimalist to say, not ro-co-co. And
basically, we have a raider expression, an operator expression, and an operand expression.
If you read a book and you see raider and ran, that's what they mean. You want to put this line
last in your P match so it doesn't overlap. This pattern does not overlap with the others.
This becomes fun when you start doing logic programming where the ordering isn't supposed
to matter. But in this case, P match evaluates in the top down. And so we're going to put our
application case last. All right. Okay. What do we do? We know the drill. We are going to evaluate
via copy and paste subtraction, the raider and the ran. Perfect. Evaluate the raider
and evaluate the ran. All right. Now, what do we do with those two values? The raider is supposed
to evaluate to a procedure, some representation of procedure. And this is going to evaluate to some
argument that we're going to call the procedure on. So what do we do now?
Apply it. How do we apply it? No. Lambda doesn't apply. But you're right that I got caught up.
We're going to use apply, which is through parentheses. Right? That's it. If you blink,
you'll miss it. Some people have what I might call parentheses blindness. And they just can't see
that that is different than without those parentheses. But they are different. There's no
mistaking the difference in behavior. Okay. So that is our application. Very nice. So that's
one of our three magic operators. We also have this thing called lambda. So I can match against
the lambda expression. This is where the pattern matching comes in nicely. And I can give a name
to the variable. And I can have a body expression. Okay. So something has got to happen with the
lambda. Do you see that x? What is x? Well, there's a list containing x, but the x itself,
not part of the list. What does that mean? What is that thing? It's an identifier. And if the x
were to appear inside of rand, what would that be? It's a variable reference. Okay. So this is how
we have a variable reference. And what's the value of the variable x? Tell me. Don't know yet. When
will you know? No, at runtime when we've actually done the procedure application. That's right.
We won't know until then. So if I call the resulting procedure with five as the argument,
what would be the value of x? Five. So we have this idea that if a variable appears in the body,
at some point, we may have to look up the value associated with that variable or bound to the
variable. And in order to do that, we need some mechanism for variable lookup. And the traditional
way of doing that in this sort of interpreter is called an environment. So we are going to write
an environment passing interpreter. Okay. Anytime you hear passing, that means that there's going
to be an argument coming in to our function for the interpreter. So you see right now, we basically
have a calculator, we have an expression, but there's no context of the expression. There's no
notion of variable bindings that may be in play at this point. So we're going to have to add
something else to this expression, or sorry, in addition to the expression, as an argument.
So I'm going to add an environment. And this changes everything. All those three magic lines
are going to in some way be involved with the environment. Okay. So now we have an environment
and the environment is going to contain somehow associations between variables and values.
Now, what do you think the third magic line of code is based on what you've seen?
Parentheses? This is the parenthesis line, the application. Cons, nope. Cons is useful, but
you actually don't need it. You only need these three lines. That's turn complete, actually. It's
amazing. We can delete all the other junk. The other stuff is junk. You don't need it.
You don't need it. You only need the three lines. And I'm serious about that.
You only need the three lines. You heard this thing called a Turing machine? This came first.
Lambda calculus came first. Girdle didn't believe church that it was Turing complete,
even though Turing completeness hadn't been a term yet. Okay. We need one more thing. No,
we don't need to find either. Was it? Variable lookup. That's it. That's the last piece of magic.
We've got to have a way to look up those variables. All right. So, I need a guard because I have my
match anything pattern. And I am going to represent variables as symbols. Okay. Because we have symbols
and scheme. So, if we have a pattern which is just a symbol by itself, right, we're going to say
that's a variable and we're going to look it up. How do we look up a variable? In the environment.
Okay. Now I have to tell you a piece of information you don't know. I am going to represent my
environment as a procedure of one argument that takes a variable. So, how do I actually look up
X in the environment? I'm not going to evaluate it, actually. Look up X in the environment.
Like that. Procedure call. Okay. This is where it gets kind of weird. It's like kind of spartan,
right? I'm just like, ah, got a procedure. There's only one useful thing a procedure can do. Call it.
Takes one argument. Give it one argument. Call a day. That's it. All right. So, that's what we're
doing. Okay. Great. Now, lambda. What is lambda going to do? Ah, yes. Extend the environment.
It's the magic word. The environment extension is the key thing here. So, lambda expression
evaluates to what in scheme? A procedure. Okay. So, we have to have a representation
of a procedure which you can think of as a delayed computation where we don't have enough
information to do the computation in the body yet. But we're going to wait until the procedure
gets called and then some value will be bound to that variable and then we'll be able to evaluate
the body at that point because we'll have the correct context. We'll know the variable binding.
So, we have to somehow represent a procedure. How can we represent a procedure, do you think?
Lambda. There you go. 60% of the time, it works every time.
All right. Lambda arg. That's right. We're going to have an argument coming in.
What is that arg thing do you think? What does that correspond to in the three magic lines of code?
It doesn't correspond to X and this is something we have to be very careful about.
It corresponds to the value of the RAND. Remember, the procedure application line
and the lambda line are intimately connected because we're going to end up doing a procedure call
on this lambda expression. The value of that lambda expression. That's going to evaluate to a scheme
procedure and we're going to call the scheme procedure and pass in the value of the operand.
Therefore, arg will be bound to the value of operand. If we're calling the identity function
on 5, RAND will be evaluated to 5, arg will be bound to 5. Okay? Keep that in mind. Okay.
So, now what I heard was we have to evaluate the body in the extended environment. So,
let's do that. How do we evaluate the body? If only we had a procedure that knew how to evaluate
the body. Well, that's what we're writing. Magic of recursion. Evaluate the body. Now we have to feed
in an environment and we have to go back and retcon these lines because you don't have environments
yet. So, we have to have an environment. So, for these lines down here is kind of boring.
It's just the good old environment. Okay? But up here, we need an extended environment.
What is the extension? How are we extending the environment?
Lambda. That's right. You laugh. It is correct. You extend it using lambda.
Yeah. It's a one-trick pony, but it's got a good trick. Lambda. Why?
Whoo. All right. This is when the nerd chills start. Okay. That is an environment. Remember,
we wanted to look something up. We called X on the environment. Well, that's the sort of creature
we're talking about. A procedure of one argument. We're creating a procedure of one argument.
That's our environment. So, extended environment. So, what are we going to do with that environment?
What's going to happen inside? If. Oh, wow. Yeah. That's right. We have to make a choice.
If of what? Oh, I didn't tell you this part yet. If equals. Well, there's this thing called
EQ. Huh. Okay. If what is equal? What two things do we want to compare?
Y and X. Okay. If they are equal, then what do we return?
Not X. Arrg. This is the critical piece. And here's the other critical piece. What do we do
if they don't, if they aren't equal? Inv. We're going to look up an inv. What do we look up?
Y. Not X. Y. Because Y is what's coming into that lambda, the innermost lambda. That innermost
lambda is an environment, extended environment. That lambda right there is a procedure. So,
we have what's called a higher order representation of environments and procedures in our interpreter.
Okay. So, let me go and fix up my VAL experts to give them environments. See, these lines are
boring because we're not messing with the environment at all. It's not interesting at all.
And you could say the application line isn't messing with the environment. And that's true
with this representation of procedures and environments. But if we change our representation
of procedures and environments, it actually does matter. You'll see that if we were to use data
structures such as lists to represent our environment and procedures, then this application
line would have a different looking structure. Basically, the work that we're doing up here
in the lambda line, we get put into the application line. All right. So, in theory, this should work
now. We'll see if you're all paying attention. Okay. VAL expert, let's try it out. Okay. So,
add one and hopefully it still works. Oh. All right. We didn't pass it in. Oh, the call was wrong.
Oh, very clever. Okay. So, you're right. We need to call a VAL expert now with an environment.
What does an environment look like? Lambda. Yeah. Again. See. All you need is lambda.
Y. Okay. And what is this environment going to do?
What happens if we look up a variable like X in this environment? What should happen? Error.
Means it's not bound. Okay. This environment starts out with nothing bound unless we want
to put it in there. So, we can do a call to a scheme's error. We can call it. Look up. Something
like that. You know, unbound. All right. Perfect. Okay. We get back seven. I can now look up a
variable in the empty environment like X and I got my error. Okay. I can go ahead and do something
like create a lambda expression. Let me try to do lambda xx. Okay. It gives me a procedure,
a scheme procedure representing my procedure in my language. I can do a procedure application.
Let's see if this works. I'm going to apply it to five and get back five. Proof. It works. I can
do something a little more interesting. Lambda applied to lambda. So, I should get back into
any function and I can apply the result of that to five. Okay. And then there's one ultimate test
case. I think we've implemented everything. Oh, there's one more thing we need to add. Let me
just add one more clause which is zero, huh? Okay. So, we're going to add one more clause
to see if something's equal to zero. Let me just follow our usual thing. All right. And I think
that may be enough now to do what I was going to show. So, there's one standard test case
which tests everything and it's factorial. And it is factorial using something called,
what Dan Friedman calls the poor man's y-combinator. You'll notice we don't have define
in our language or in our interpreter. There's something called let rec to define
mutually recursive functions. We don't have that either. What we do have lambda and the answer
to everything is lambda as we know. So, this code here is factorial. You can see this got
some function calls and stuff like that, but it may be you can believe the math. And then that
little part up top with a bunch of lambdas, the part up top basically is what reaches what's
called a fixed point. And so, you can see in scheme it works. So, let's see if it works in
our interpreter. I have no idea. We'll try it out. Yeah! All right. Awesome. Well done.
Okay. So, let's look at the interpreter real quick and just a couple of words about it.
So, the first thing I'll say is that everything except the last three lines is an abomination.
So, we are going to remove the abominable code. Bam, bam, bam, bam, bam, bam, bam,
that. Okay. This is the 3 by 5 card interpreter. I may have to reformat it slightly differently
for the screen, but if you have a 3 by 4 meter card, I guess you could fit at this side. But,
you can actually write down at least on a 4 by 6 card and that is the magic. Okay. This is the
key to the universe. You have everything here. You have lexical scope. You have higher order
functions. You have all these sorts of things. Numbers, you don't need them. You can do church
encoding. Okay. You don't need if. You can encode if as well. You encode all those things.
They're kind of nonsense. Yes, they're useful for efficiency and expressiveness. You don't need
them. This is all you need. It's Turing complete. Came before the Turing machine. This is similar
related to something called the lambda calculus. This is a little bit different because we're using
an environment instead of beta reduction if you're familiar with that. But similar idea. People
would call this the call by value lambda calculus interpreter. Environment passing. You can play
all sorts of really interesting games with this. You can change the representation of the environments
and the procedures. You can use data structures. You can do lists and pattern matching. You can do
all sorts of really cool things. You can add additional arguments just like we added the
environment. So now we have an environment passing interpreter. You can add a store as well, which
contains basically the current value of a variable. And you can change those values. So if you have
an environment and a store, that allows you to do mutation like set bang and scheme. You can also add
continuations. You can CPS the interpreter. Do another correctness preserving program
transformation. CPS it. That gives you a representation of the rest of the program at any
point potentially as a procedure. And you can just call that continuation anywhere you want.
And you can implement all sorts of control structures. If you CPS your program twice, you
have two continuations. That gives you limited continuations. You can do basically every control
structure at that point. All sorts of very interesting games you can play. You can change.
Anyway, I'm not going to get into all that. But what I recommend you do is what Dan suggested
to all his students. And as far as I know, I'm the only one who did it. Maybe other people did.
He said take a four by six card stack of them and spend 45 minutes writing this down over and over
again until your eyes start bleeding. Sear it into your brain and your heart. And you'll never
forget it. And if you really understand it and you try, you know, turning the crank and doing a
bunch of evaluations, at some point you'll start to get some idea of the magic. But all of
computation, all of the turing complete processes, all of, you know, the notion of computable
functions are within this code. The secrets there. You can do things that run forever. You
can do all sorts of things. They're very interesting. You can express colats inside of it. Okay.
So that is sort of like the teaser. And, you know, you can go off to races once you really
have this on the brain. You can do things like change the type of scope you have. You can go
from what we have here. It's just called lexical scope or static scoping to dynamic scoping by
changing how the environment variable lookup works and things like that. I'm not going to go
into all those things. If you're interested in that, there's a book called Essentials of Programming
Languages by Dan Friedman and Mitchell Wan that talks about a lot of these things. And
there are lots of other resources you can find. What I want to show you now is what happens when
you play these games in sort of a different context. So
this is a paper by John McCarthy called a micromanual for Lisp, not the whole truth.
And in this, he gives the rules for an interpreter. Okay. So you were asking about cons. Well,
here's your cons. This is what cons does. And he gives basically the rules for a Lisp evaluator.
And, you know, basically, he's calling his evaluator value as our val expert. And you can see
that he has these equal signs. You're saying that expression is equal to that value. Now,
equal, the notion of equality is actually one of the most subtle notions in all of mathematics and
logic and computer science. Anyone who thinks they understand equality is just kind of some
throwaway idea hasn't thought about it hard enough. Like homotopy type theory. All these people
trying to understand different notions of equality there. So it's a very deep topic. And one of
the things that's interesting is that, you know, we tend to read that equal sign if we're doing
programming, programming languages, interpreters, compiler, stuff like that, basically is one
directional from left to right. So we have an expression. We evaluate it. We write some function
that's an evaluator. We compile it, some code that's going to run it. And we're going from that
expression to that value. It's not really an equal sign. It's like a right-hand side arrow if you
want to think of it that way. But what if we took the equal sign seriously? What if we seriously
said, all right, well, this is like an algebra, right? And what do you do in algebra? When you were
in, you know, I'm not talking about like the modern algebra. I'm talking about like, you know, when
you were in high school or whatever, you took algebra in high school. What sort of things did
you do in algebra? Solve equations. You put in variables like x and y and z and things like that.
And you're supposed to figure out what is the value of that variable, right? That makes both sides
equal. We're going to do that. So I've done some of the heavy lifting for you with a bunch of other
people. We spent like the last 12 years doing it. And I'm going to show you some of the stuff that
we got from it. So what we did was we wrote, and I started this at Indiana with Dan Friedman,
a bunch of other talented people. I'm working right now with a whole bunch of other people,
including like Michael Ballantyne at Utah and Greg Rosenblatt and all these other fine folks.
We wrote an interpreter in what's called a logic programming language, okay? Or a relational
programming language, that's what I normally call it. And this one doesn't fit on a 3x5 card,
but it's not that long, actually. It's what? 403 lines. But you can fit the 3x5 card version
on here quite nicely. And actually it looks a lot like the algebra part. In fact, you can write
down the semantics. So here are the three lines we wrote for our interpreter. This is how you would
write it in like an operational semantics, sort of math-y. And then this is on the right hand side
is how you would express it in this language called mini-canon. And you can see it's really not much
longer. It's about the same length. Okay, so anyway, we took the time and wrote this interpreter.
So we wrote something equivalent to a vowel X, but in fact, you can see it's called a vowel
expo, right? We even used the same name. And so now let me see if I can figure out how to load
this thing. That's the, it's always the hard part. Here's the transcript. Let's see that. All right,
now let's go in here. And let's see. Load MK. You know, it's all fine and good until you have to
do things like load a file, right? There's no math for that. Probably the monad or something
junk for that. Anyway, let's do full and term. All right, cool. So in this logic programming
system called mini-canon, we have the ability to write queries. And the queries let us,
you can think of it from a sort of database standpoint, you can think of it as an algebra
standpoint. It allows us to write down things where we want to solve for the values. So we have
you vowel expert. And I'm going to evaluate some, you know, some thing and get the value of it back.
Let me just make sure that worked. Oh, expo. Yeah, you think I'd learn. Incorrect number of
arguments. It probably takes the empty. Oh, I bet it's called a valo. Yeah, I think, see if I've
gotten a valo. Yeah, awesome. Okay. So I've hidden the environment in this version because I'm just
starting out in the empty environment. That's why we're not seeing an environment. We could
type it in if we wanted to. Okay. So what's happening here is we have an interpreter
written in a somewhat different style than what we just wrote. We have an evaluator,
you know, and we have an expression just like the expressions we're passing into a valo expert.
And correspondingly, we have the value. So this is a little bit different than before in that
we are actually able to specify what the output should be. Now, in this case, we are putting
in a variable, which means we don't know. We don't know what the value should be. In fact,
if you want to think of it from an algebra standpoint, you know, I'll call it x. Or maybe,
you know, another way to call it would be, you know, a question mark or something, right? So this
is an unknown and we're trying to figure out what the value of the unknown must be.
And in this case, the value of the unknown is five. The expression five evaluates to five. Great.
So let's try doing something a little more interesting. Let's try having a lambda expression,
let's say, about lambda xx. Okay. Oh, that's a big thing. You can see that it begins with closure.
So closure is one way to represent a procedure. So some representation of a procedure, I'm not
going to get into the details of it. But I can apply that function. I can apply that procedure
to five, for example. So the identity function applied to five. And it gives me back five. Okay.
Great. Now, this so far is just treating it like an interpreter, just like what we had before.
And we have all sorts of other things, like we have the ability to create lists.
You know, I could, and we have this cons operator I told you about. I think we have cons. Let's see.
Cons A onto the list B. Yep. All right. So I can build up list structures. I can do all sorts of
things. But what I can also do is play games where maybe I don't know the input expression
and I know an output. So maybe the output is I want milkshake. Right. And now what I want
is an expression in scheme that when you evaluate it produces the list I want milkshake. Okay.
So let's try it. Quote, I want milkshake is one such expression. How about two? Oh, here is a
procedure call. A procedure that takes any number of arguments whose body is the expression, quote,
I want milkshake applied to no arguments. And we can do all sorts of games like that. Here's
another one. Like, I don't need to go like 10. See if there are any good ones. Oh, yeah. Here's a
call to car, which gets the first element in the list. The car of a list containing the list,
I want milkshakes. And I can do things like that. All right. That's fun. So I work in the lab of
Matt might at Utah. And he has this blog post called 99 ways not to die to say I love you in
racket. So this was like his Valentine's Day post, right? It's like a slow Valentine's Day. You
write this blog post. And it's 99 expressions in racket or scheme or whatever that actually
evaluate to the list. I love you. Okay. So let's do that. So let's go back and come up with a run
99 and say I love you. And we get all these programs. So here's one. It's called a list and
it has a function call inside of it and stuff like that. And every one of these I can evaluate in
scheme and it works just fine. All right. Yeah. Okay. So that's kind of fun. So let's try another
one. Going back to John McCarthy's paper. He has this little note. So it's a difficult mathematical
type exercise. Find a list E that means a program expression E such that the value of E is equal to
E. What is that called? It's a quine. So we want to find a program that evaluates to itself. So how
can we write such a query? Yeah. Well, let's let's out of respect to John McCarthy, call our variable
E. We want E to evaluate to E. All right. Oh, that's a representation of a number five evaluates to
five. That's true. Let's see who hash T evaluates to hash T. That's true. Hash F evaluates to hash
F. Let's see if there's anything. Let's run for a second. Oh, what is this thing?
All right. Forget those side conditions. Here's a more interesting looking expression
and that evaluates to itself. Oh, okay. So we can do things like generate quines.
What else can we do? Well, Michael Valentine at this point said, well, you know,
what if you had a more interesting scheme expression that you're evaluating? So let's try
something a little more interesting. So let's try doing something like
writing a program that concatenates to lists. And, you know, don't worry about the syntax here. It's
going to look, you know, if you don't know scheme, you may not read every single thing, but we're
going to append, okay, and define a function called append that takes to lists L and S
and is going to have an if. Make this a little smaller. If L is empty, then we return S. Otherwise,
we're going to cons on the car of L to a recursive call to append with the rest of the list. That's
called the Cutter and S. Okay. So let wreck, let's me define a recursive function. And now I'm
going to have a call to append. I'm going to say append ABC to DE. And let's see if that works.
And sure enough, it works. So it gives me ABCDE in a list because we can actually
produce more than one answer. So let me show you what that would look like.
What we could do is, well, actually let me show you something else first. So what if we put in the
answer first? We know the answer should be ABCDE. Okay. So we put in the answer. And now I can put
in that variable thing, the question mark, anywhere I want. So I can put in the question mark
inside this argument. So I'm asking what list when it appended to DE gives me ABCDE. So what list
should that be? ABC. And sure enough, I get that. Okay. I could ask for two things. Maybe X and Y.
So I could say I want X and I want Y. There are all sorts of games I could show you with this,
but I'm just going to show you a couple. So now I can have two lists that appended together
give me ABCDE. And you can see the empty list applied to ABCDE is one such pair of lists.
And I can actually ask for all such pairs. So I can do a run star.
And now I get all the pairs back. And so if you've seen logic programming, if you've seen
languages like prologue or minicanron, they let you do this sort of query. But notice we didn't
write a logic program. We just took a scheme program in our interpreter. So we're taking the
equal sign seriously. We're saying that equality really does mean equal. And there's no direction
to that equal sign. We should be able to solve for any side. Okay. So let's try one more example.
We could do something like have ABC and DE. And now we say the answer should be ABCDE.
And minicanron responds with some gibberish that means that that's consistent. Okay. So the question
is, where else could we put a logic variable representing something unknown? In the code.
Yes. Yeah. All right. So I don't know. Let me find a target. How about this s? Let me put something
there. I think this is the one with run star is a bad idea. Run one is good. And sure enough,
it inferred the s that I removed and things like that. Now, at this point, we're actually doing
program synthesis. So we have the ability to specify information in the form of things like
the expected input and the corresponding expected output and use the semantics of our
interpreter that we wrote as a relation and logic programming system to do inference, do a search
basically and do constraint solving to try to infer the missing values. And those missing values
could be the input arguments, the function, the output to the function, even code or some mixture
thereof. We can put variables anywhere we want. Yeah. Let's try that. That's a good question.
So let's go back to what we had. This is it. Yep. Let me put it where the append was. What do you
think I'll get back? Oh, sorry. I have to change this back to the question mark.
Hopefully append, right? Everybody start.
What? Oh, did I call it runs? Oh, hilarity will ensue. That's the answer you expected, right?
A procedure that ignores this argument and returns the list, AVCDE.
Many canons like prove me wrong. I defy you to prove me wrong.
So this is the fun for a thing you get into. So let's try to... So many canons like the genie,
right? The genie is like, tell me your wish. I'm ready to go. So what we're going to do is we're
going to create a list of calls to append. Sorry. I don't remember if we have lists or not. I think
we have lists. So we'll have more than one test. That's right. So let's do two tests. So one will
be empty list to empty list. And then in the output, we will have a list of expected outputs.
So we'll have the empty list and then the list AVC. Oops. Let me try this. See if this works.
Yeah, now it came up with a pen. So I was like, all right, I've got to work for it.
Okay. Now what are we asked for two? So what happens? I don't know. I have no idea. Oh, okay.
It's what that is. In case you can't read that. It's a direct application of a
variadic function call with zero arguments, which returns the procedure of pen. It's like,
okay, well, I'm no dummy. I'll keep doing that. So this version is quite slow. And if you want
to synthesize code for real, it can take quite a while. But we've been working on a new tool.
Let's see if I can zoom in. Ooh, it works today. Nice. All right. There's a tool called Barlemin
that I've been developing with Greg Rosenblatt and Michael Bountine and other people. And this tool
is basically just an interface. I learned a little bit of Swift code and I wrote this.
You can see it's beautiful. And basically, this is just an interface on what you saw
with some optimizations behind. It runs about 10 million times faster than the naive version.
When you're doing program sensors, that's important because you're in an exponential space. So
we are going to write a pen a slightly different way. So the code in the upper left
is our definition of a pen. You can see we left some parts out. So we left the name of the function
out. That's this comma a. That's a mini-canron logic variable. It's a meta variable. You can
think of it as a whole in the program. We don't know what that expression is. We don't know what
the arguments are to lambda or how many there are or anything like that. And we don't know what the
body of the lambda is. So we're going to let our tool come up with that for us. And what we're
going to do is just give some examples of a pen. So I'm going to append two lists, the empty list,
to the empty list. So give me the empty list. And Barlowman's going to think about it and say,
I've got a solution for you. You want a function called a pen. He's like, yes, very well. That
function can take any number of arguments. Well, strictly, schemes of pen can. And it's going to
return to the empty list. Right? Very exciting moment. All right. Well, that's okay, I guess.
How about we have a list containing two lists, list A and list B, and we want to get back A, B.
Okay. Well, add another test. Oh, lucky day. You want a function called a pen, which takes
two arguments and doesn't matter what the names are. And if the second argument is empty, we'll
return that. Why not? Because that's the first test. Otherwise, we'll return to list A, B.
All right. Well, that's getting a little annoying. So let's introduce a new concept,
that of the gensim, the generated symbol. We don't actually care what's in that list.
We just want to make sure that that's not going to appear in the output program. As long as it
doesn't appear in the output program, we're happy. So we're going to change that. Oh, now we do have
to do a little more work. Two arguments, null test on the second argument. The second argument is
null. Otherwise, we have to start doing some operations, cars and cons and things like that.
But we haven't, there's no recursive call. It's not going to work. So let me try one more.
List of length two. Yeah, you can see where this game goes.
Let's think about that.
It's thinking. It's like, all right. There's some putting in some work. Oh, what? Looks
like a recursive call. That looks perilously close to being correct. It's a little hard to read.
So I will give it, I will use the editor part to fill in some concrete names and see what we can get.
Oh, that is a pen. That's nice. It's example-based program synthesis. Furthermore,
I can do some other things that are interesting, like I could add a few more tests.
So I could say append of list A to the empty list. Should be empty list. I could say append.
Oh, oh, yeah. Yes. Yeah, garbage in, garbage out. Good call.
Oh, okay. Anyone would like a job as a QA tester for Barleman.
Okay. So I wrote some more tests. And of course, Barleman could already synthesize it. So it's
not really necessary. But imagine for a second that maybe this program is too hard for Barleman
to synthesize. So instead of having Barleman synthesize the program from the examples,
we're going to do test-driven development, right? I mean, this is real test-driven development.
So we wrote our tests first, and now we're going to write our code, right? So I'm going to call it
a pen. If I call it, like, you know, king cat, many kinderans are like, no, wrong. Computer says no.
Fail. All right. So let's call it a pen. And let's say we're going to take two arguments,
L and S, like before. Great. And we probably want an if and a null check on L. And, you know,
we can start kind of filling in the structure here. And Barleman can probably synthesize that,
fine. But let's pretend we're working on something a little more complicated, and Barleman can't do
it. So now I'm typing. And notice I've got some holes in my program. So I don't know what those
are. And those are arbitrary expressions. This could be, you know, gigantic, right? I could have
a scheme compiler as A or something. It is solving it faster because I've filled in more.
The current version of Barleman, sometimes you fill in more and it's like really slow.
Because it gets slower. So we're working on that. But anyway, so let me put in L. That's one of my
arguments. So I'm going to think, hey, L is probably the right one. Oh, Barleman's like, no.
Computer says, no. That particular test is incompatible with the partially specified program
you've written. So what we can do is write our tests, try to use it for synthesis. But if it's too
slow for synthesis, we can just use this as an editor. And it's constantly in the background
taking up all your corridors and heating your apartment. And desperately trying to prove,
and this is a proof because many cameras are theorem prover, that the partially specified code
you've written is actually incompatible with when you test. It doesn't mean your test is wrong.
Maybe your code is wrong. Maybe they're both wrong. Maybe the semantics for the interpreter
underlying Barleman is wrong. But they're certainly inconsistent, right? And I think this sort of
technology is, you know, getting ready at this point to be practical for at least some use cases.
And I should also point out that there are many other people working on program synthesis,
I think a renaissance in that area right now. But I do think that one thing that's interesting
is sort of the way we're doing synthesis, which is by taking that interpreter that I showed you
in the beginning, this beautiful piece of code, and looking at the original description of it
in those equal signs, and taking the equal signs seriously. We're going back and revisiting this
artifact that people had an understanding of, and we're trying to actually execute, you know,
another way of looking at it, this relational semantics view. And people, you know, people
know relational semantics. I mean, the way that the math was written down is as relations.
But the whole point is we've designed this language mini-canron to let us encode these
relations in a nice way, and then did a bunch of optimizations. So when you write an interpreter
as a relation, you can do this fill-in-the-blank game, right? And there are all sorts of other
examples I could show you with mini-canron, and some really neat things. If you're interested in
that, you might check out the closure conge talk that I gave with Greg Rosenblatt at the conge,
last year's conge. And we show off a whole bunch of examples of this sort of thing. And, you know,
we're trying to actively improve it and explore other ways to do things. And we can take things
like a proof checker and turn it into a theorem prover by making it a relation, all sorts of fun
games. So if this appeals to you, let me know. You might check out the webpage mini-canron.org
that has a description of a lot of the work we've been doing. And also, I run hangouts on
Saturdays and Sundays, an intro hangout series, an advanced hangout series, to talk about some
of these technologies. Just send me an email, drop my line, hang out, we'll get a milkshake.
And we talk about these things. If this thing you're interested in, you want to actually do
some research, work on it, hacking, whatever, you could probably improve the user interface
of Parliament if nothing else, right? So anyway, this is why I think the interpreter,
that interpreter written in Lisp, that's higher order, is so beautiful, such a beautiful object,
that not only is it very, very dense and an interesting amalgam of very important ideas,
but you can look at that object from many different standpoints, like I said, that infinite tower
of interpreters, or any number of other ways, from program transformation standpoint,
from a relational semantic standpoint, and so forth. And each time you look at that object,
that like five line core program from a different standpoint, it yields some more secrets,
right? In some sense, we know everything about the interpreter, but in some other real sense,
like I would not have guessed that you could do this sort of thing just by taking that
program and encoding it in a logic programming language, but you can, it turns out. I think
that's really amazing. So that's why I think that's a really beautiful artifact and I hope
everyone will take the time to really study it and get to know it and find their own ways of
looking at it and new ways to consider how that thing works, okay? Thank you. Thank you very much.
Round of applause.
We have time for like two very short questions and then we have to get out of here. So we have one
right in front here real fast. If you treat these tests as constraints to the program that
is trying to guess, can you apply like meta constraints? Can you say like, I want this to be
like a constant time algorithm or I want it to be, you know, an element of memory or something like
that? That's a good question. So, you know, part of the issue is how do you specify what it is you
want the program to do? And so one way is with these tests, you could also use something like
types because we won't write type inferences in the same style. You can also write high level
properties and logic. There are a whole bunch of ways you could do it. And you could also say
something about the expected running time or desired running time and so forth. We're not at
the point where we can do things like talk about the desired running time, although it is something
I'd like to be able to do. And so no, you can't do that yet, but one of the areas we're very interested
in is trying to do more expressiveness. Probably the most recent thing that we've been playing with
that's interesting is just yesterday, I started, I basically wrote a version of this technology
where you can take scheme programs, look at common patterns in scheme in terms of very simple and
just looking at what the parent is for an expression like what, you know, if you see a define, it
turns out there's usually a lambda inside of it. If you see a lambda, there's usually an if or a
cond inside of it and looking for those sorts of simple patterns and specializing the relational
interpreter based on that very, very simple knowledge. So instead of just having the semantics,
the system also would know a little bit about sort of standard human style or things like that.
And that alone looks like it speeds up since there's many orders of magnitude and we're
trying to figure out can we apply that to sort of the optimizations we've already made. So I think
the bottom line is like there's a whole bunch of things that we just haven't explored yet, but
I think it's definitely possible. And there are other people in this program census community
who particularly work on that problem of trying to synthesize programs that have, you know,
different expected, you know, running times and things like that. This is a very cool problem.
More questions. There's a lot to take in I know.
Short.
When you gave the example of coming up with the answer append, how does it,
how do you seed the search space? Like how did it know to find append,
how did it append to get into the search space?
Well, I mean, it didn't find append first, right? It created a function that just returns a list.
Well, because we have an interpreter, the interpreter has a notion of scoping,
just like we implemented variable lookup. We implemented variable lookup in that interpreter,
and the semantics of let rec, the binding structure of let rec means that within that call, you know,
so the call to append was inside the definition of append. So therefore in the environment append
is there because we define the function. And so one of the things it's going to try to do,
the interpreters going to try to do is look up the variables that are currently bound in the
environment and try all of those and see if that will help lead to a solution.
Anyone else?
No? All right. Thank you so much.
