start	end	text
0	4360	Okay, G'day all and welcome to another video.
4360	6920	Today we're going to be talking about computing things.
6920	10960	But not just anything, today we are talking about computing everything.
10960	15360	The topic of today is going to be an adventure through the amazing world of discrete maths.
15360	19560	We're going to time travel through the Victorian era and talk about some crazy ideas that a
19560	21280	follicle George had once.
21280	25000	And we're going to travel through the 1940s and meet a brilliant little follicle Alan.
25000	29720	And we're going to look at how to compute every single thing ever along the way.
29720	30720	It's going to be fun.
30720	34920	Okay, I have written a little e-book for this video and I'll be putting that up for the
34920	37480	Patreons as a big thank you for supporting the channel.
37480	39480	It really, really does mean a lot to me.
39480	44360	If you, humble viewer, would like to become a Patreon of this very channel, there will
44360	47320	be a link down below and another one up above.
47320	50680	Okay, that's good, but computing things.
50680	54520	Let's imagine that we've got a very, very tiny computer.
54520	59640	It's extremely tiny, so small that a lot of people wouldn't even regard this as a computer
59640	63600	but I tell you what it is, it's just our tiny computer and it's brilliant.
63600	70920	Anyway, our tiny computer is very excellent and it reads only two inputs and it produces
70920	71920	one output.
71920	75800	For its inputs, they're both going to be binary and its output is also going to be binary.
75800	79720	So you could think of this like a computer and it just has two buttons, A and B, they're
79720	81200	either pushed or they're not.
81200	85440	And it's also got a monitor but the monitor is kind of a rubbish resolution and this monitor
85440	87120	is either on or off.
87120	89600	The monitor just shows a one or a zero.
89600	94080	So if we've got our little computer here and the inputs are labeled A and B, then these
94080	97640	are all four possible inputs that we could give to our computer.
97640	100680	These are the questions that we could ask this little computer.
100680	101920	Now there is no more.
101920	104360	We're either pushing button A or we're not.
104360	106840	We're pushing button B or we're not.
106840	111280	It's either off, off, off, on, on, off, or on, on.
111280	112280	That's all there is.
112280	118240	Now for each of those questions or input patterns, the computer can answer either zero or one.
118240	120600	It just puts it up on its monitor, zero or one.
120600	124640	We could add another little column just here for our little computer specification, the
124640	125640	output.
125640	128640	And this is going to list the answers to each of the questions.
128640	132000	So let's define what the answers to each of the questions is.
132000	133680	We can just make this up as we go.
133680	136220	Well I happen to like one zero zero zero.
136220	139120	So let's define that as the output, shall we?
139120	143960	Now some of you, possibly a lot of you, might recognize exactly what this little bad boy
143960	146240	is, but keep stumbling, keep stumbling.
146240	149400	Okay, but that is our inputs and our outputs.
149400	153740	So when we input zero zero to our computer, it returns zero.
153740	158320	And if we input zero one or one zero, our little computer will also return zero and
158320	159320	zero.
159320	163640	But and the exciting bit, I use the word exciting quite loosely, but the exciting bit is when
163640	168240	we input one one to our tiny computer, it returns one.
168240	169240	Good stuff.
169240	172920	Now a lot of you are probably thinking, well that's the dumbest computer I've ever seen.
172920	175240	Who would ever use a computer like this?
175240	179440	But what if I was to tell you that this little operation just here is computed literally
179440	184680	billions of times per second by basically every single computer on Earth.
184680	192600	For this, humble little operation is none other than Boolean and, well there you go.
192600	197880	Mr George Boole was a mathematician from Victorian era England.
197880	202000	Largely self-taught, he defined a logical algebra which bears his name to this very
202000	203000	day.
203000	205480	It would be quite amazing what this man thought of.
205480	211040	Like we're talking, you know, a good hundred years or so before computers really existed.
211040	215080	We're talking like Sherlock Holmes days, you know, this is Jack the Ripper era.
215080	216920	People were still getting around with horses and carts.
216920	219120	I mean there was barely any electric lighting.
219120	222520	He sat down one morning with his cup of tea and just thought, you know what, I'm tired
222520	223720	of doing algebra with numbers.
223720	225920	I'm going to do it with some logic instead.
225920	226920	How's about that?
226920	229960	Everybody around here must have just looked at him and thought, what on earth are you,
229960	230960	George?
230960	231960	What are you talking about?
231960	232960	What are you doing?
232960	238240	Well it turns out, it turns out that Mr Boole was onto something, I tell you what, the dude
238240	241520	was onto something, holy mackerel.
241520	246720	Another fella, Charles Babbage, was gone absolutely ballistic making crazy machines to do just
246720	247720	incredible things.
247720	251960	He had a machine called the Difference Engine, was performing calculus with a bunch of valves
251960	253720	and tubes and craziness.
253720	257600	But anyway, a lot of the ideas that these Victorian era mathematicians, your Booles
257600	261840	and your Babbage's, a lot of their ideas actually went on to be extremely useful.
261840	264400	And form the foundation of modern computing.
264400	266440	What a history we have here on earth, eh?
266440	272080	What an amazing place, amazing time, Victorian era, good stuff, well done the lot he is.
272080	277360	So this is Boolean and it takes two bits of input A and B and it returns a single output
277360	284080	O and the output is zero for all of the combinations of inputs except where A and B are one.
284080	287720	And the way that we've drawn this out in columns like this actually has a name, this is called
287720	288720	a truth table.
289000	294880	Truth tables are a common way to specify logical operations such as Boolean and anyway for
294880	300840	George Boole and was not enough for his algebra so he defined a couple more operations.
300840	305560	We've also got Boolean or and we've got Boolean not as well.
305560	311200	And here's Boolean or takes two bits just like Boolean and it returns one bit, the output
311200	315240	column just here and the pattern of zeros and ones that it returns is different.
315240	319040	So that's really what defines these different operations, it's the output.
319040	324040	At any rate Boolean or returns a one for all of the input patterns except for the first
324040	325040	one.
325040	329200	Whenever the inputs are zero zero, Boolean or returns zero, otherwise it returns one.
329200	332320	We can think about this in a whole bunch of different ways, really the operation is asking
332320	337840	is A or B one and if either of them is one or both of them are one then the answer is
337840	344200	one or yes or true and if both of the inputs are zero or false then the answer is false.
345160	350320	And the final operation that Mr. Boole defined is Boolean not not actually only takes one
350320	353560	input and it just returns whatever the opposite is.
353560	361400	So if we've got a as our input if a is zero then not a is one a is one then not a is zero.
361400	365880	So Boolean not is sometimes called the complement or the bit wise complement sometimes also
365880	370400	called the ones complement it just depends on the circumstance but Boolean not just flips
370400	371400	the bit.
371400	374920	I've also mentioned that sometimes along with calling these things operations or functions
374920	378560	or whatever you'll often see them called gates especially when they're implemented
378560	384840	in hardware using transistors and elect trickery yeah logic gate logic operation Boolean operation
384840	387320	whatever you want to call it it's all the same thing.
387320	393440	But we've got our three Boolean operations here Boolean and Boolean or and Boolean not
393440	399120	might be tempted to ask something like why those three operations why those three and
399160	403960	or and not I mean they seem interesting enough but why those three you might also be tempted
403960	409360	to ask well if those three exist how many other operations are there and what we can
409360	414840	do here to figure out the answer to this we can say well the output column has four bits
414840	420880	in it and if each of these operations is defined by a different output pattern then that means
420880	426520	that there must be two to the power of four different patterns 16 different operations
426520	433480	and here they all are in all their glory all 16 binary operations would you look at that
433480	437840	now it looks a little bit messy I mean there's just a bunch of ones and zeros everywhere but
437840	442520	there should be some familiar faces in there so right here that's Boolean and and here's
442520	447040	Boolean or you'll also notice that some of these operations have redundant information
447040	453160	in them for instance the operation not a just here which produces the opposite of the input
453160	458120	well not a actually only reads a doesn't read the b variable at all and not b is the
458120	462160	sort of reverse of that not b returns the opposite of the b variable and it doesn't
462160	466200	read the a variable at all the first operation just here doesn't even read the input so just
466200	472440	writes zero to the output and the final operation just writes one regardless of the input anyway
472440	477560	let's have a look at the first operation shall we so the first operation returns zero no matter
477560	482640	what we input but if we just remember back to what Boolean and does Boolean and returns
482640	489200	a one only if both of the inputs a and b are one otherwise it returns a zero so what we
489200	494960	might do is something a little bit interesting we might say a and not a we're performing
494960	500200	a Boolean and with the complement of the same variable and what's going to happen if we
500200	506080	do that well if the variable a is set to zero then not a will be one and we'll end up with
506080	512120	zero and one the and operation will return zero likewise if the a variable is one to
512120	518400	begin with then one and its complement zero is also zero so regardless of what the value
518400	525000	of the input is if we perform a and not a we're going to get zero as the output no matter
525000	529520	what we've got a sequence of these little Boolean operations that we can perform and
529520	534560	we can emulate the zero gate let's have a look at the final gate so the final gate writes
534560	540400	one no matter what the inputs are let's have a go at creating that using the Boolean operations
540480	547000	what we can do is we can say a or not a if we remember back to the or gate it returns
547000	553160	one for all situations except for the input zero zero if we all a with the complement
553160	558480	of itself it's either going to be zero or one or if a was one it's going to be one
558480	565720	or zero but either way we're going to get one as a result a or not a returns one no
565720	571080	matter what it emulates this final gate this one gate and so you might have a bit of an
571080	576560	inkling of where we're going just here those three Boolean operations believe it or not
576560	581680	can emulate all 16 of this complete set of operations and it looks a little bit messy
581680	587200	but here is an example of how we might emulate each of the 16 gates you don't need to implement
587200	592800	all 16 of the original complete set of gates you can just implement the Boolean operations
592800	598680	and or and not and you know that you can generate all 16 of the other gates okay but let's be
598680	603040	a little bit serious here for a moment so our computer has two bits of RAM and a monitor
603040	609760	that's either on or off that's not very useful let's move up to a computer with three inputs
609760	616440	a b and c we've got eight rows now in our truth table and we can define our little three input
616440	621000	operation once again if we're talking about binary just here the output values just here
621000	626680	can each be zero or one just make up a gate while we go we got all right the output column
626680	632320	might be for zero zero zero the output might be zero for the input zero zero one the output
632320	636920	might be zero then it might output a one and a one and a one and a zero and a zero and
636920	641560	a one whatever we've got some gate just here and now using this truth table here we could
641560	646600	figure out what our little computer is going to return given any input pattern anyway let's
646600	652080	make another gate shall we that first one was so much fun one zero zero zero one one one zero
652080	656960	there's another gate good stuff just by changing the pattern of bits in the output column we get
656960	661360	a new gate every time what fun but you might be tempted to ask how many of these three input
661360	666400	gates are there well you can see from the output column that there's eight bits and if there's
666400	672840	eight different bits then two to the power eight gives you 256 pretty crazy we went from the two
672840	679440	input set of operations there's only 16 of them we added one more input we've suddenly got 256 now
679440	684680	it would seem that these three input gates are far too numerous for something so simple as Boolean
684680	688680	operations to emulate but let's have a look at an interesting technique if we look at this gate
688680	693800	just here we could actually split it into two halves the upper half and the lower half if we
693800	698880	look at the upper half just by itself and we take away the a variable we just imagine it doesn't
698880	703400	exist for a moment if we look at this upper half what we can see is that we've actually got one
703400	709000	of the original 16 gates I mean this is a two input gate with one output the inputs here happen to
709000	712360	be B and C but it doesn't really matter to a Boolean operation I mean it doesn't care what the
712360	717560	variables are called and we could do the same with the lower half if we just ignore the a variable
717560	723240	for a moment what we've got here is a little two input single output gate we've got these two halves
723560	729120	and we know that the Boolean operations can emulate both of these halves separately so what we
729120	733920	really want to do is say something like if the a variable is zero in other words if it's the
733920	738600	upper half then you want to use this first expression as the answer then you want to say if
738600	744640	the a variable is one then we want to use this second lower half as the answer we need an if
744640	750720	statement but we're in Boolean algebra we don't have an if statement what we've got what we've got
750880	760200	is Boolean and to the rescue and what we do is this for the upper half we and that upper
760200	765880	half with not a we only want that upper half to apply when the a variable is zero in other words
765880	771760	when not a is one likewise for the lower half we only want that half to apply when the a variable
771760	777320	is one so we can and that lower half with a and what we end up with is two expressions we've got
777320	783800	not a and the upper half and we've got a and the lower half and if we all of those two expressions
783800	789720	together wouldn't you know it we've actually emulated a three input gate using nothing but
789720	794760	Boolean operations and what's interesting about that technique is that it wouldn't matter what the
794760	801560	bit pattern is in the three input gate it doesn't matter any of the 256 different three input gates
801960	807160	we know for certain that we could split them in halves we could and the upper half with not a
807160	812360	the lower half with a and we could all those two together and we would have the three input gate
812360	817160	this is really where we start to see just how powerful this algebra is just how good Mr.
817160	822840	Boole's operations were I mean you can start to read these as little numbers I mean zero one zero
822840	828120	that's binary for the number two zero one one is binary for the number three could read those as
828120	832280	numbers and we've got gates here like this one just here this actually tells you if a number
832280	837240	is prime or not it's an interesting gate this gate just here tells you if a number is divisible
837240	843160	by three there's all sorts of questions that these gates answer but no matter what the question is
843160	849320	any input that can be mapped to the range zero to seven we can emulate it with Boolean operations
849320	854200	now of course the interesting part is that we could actually take this further let's say that we
854200	861720	had four inputs now if we've got four inputs a b c and d and a single output column or even if we've
861720	865480	got more than one output column it doesn't really matter you write as many outputs as you want if
865480	871000	we've got four inputs there's a total of 16 different rows in the truth table and if we want to ask a
871000	875720	question like well how many different gates are there like that that take four inputs and return
875720	882120	a single output well the the answer is two to the power of 16 i mean six five five three six i think
882120	889720	65536 gates of this size and it might seem a little bit absurd to try and emulate that with
889720	896520	Boolean algebra but we know that we can emulate all of the three input gates just by splitting the
896520	901480	output column into upper and lower halves and we could actually apply exactly the same logic here
901480	906520	we could split the upper and lower halves we know that we can generate each of these halves and we
906520	912280	can actually mask then with the b variable this time just as we did with the a variable previously
912280	918440	and then we could mask again with the a variable and what we'd have is rather a long and very messy
918440	924200	and complicated looking expression but we know that no matter what the output column is doesn't
924200	930520	matter how complicated those bit patterns are we know that we can emulate that four input gate
930520	935480	using nothing but Boolean operations and then we could move up to five inputs and ten inputs and
935480	941160	a thousand inputs a million inputs it wouldn't matter it doesn't matter how complicated the input
941160	948360	is or how long the output column is we know for 100 certainty that we could emulate that using
948360	953960	nothing but Boolean operations and that's quite profound really that's absolutely extraordinary
953960	959880	because it means that no matter what questions we ask no matter how complicated the questions are
959880	966600	or how many outputs we need we know for 100 certainty that we could at least in theory
966600	972200	compute the result using and or and not now it might not seem that strange to to a programmer
972200	977080	but if you think about it that is quite odd we've got uh we've got no if statements we've got no
977080	983000	functions no objects i mean there's no branching or loops of any kind required we just read the
983000	989240	input perform exactly the same set of steps that exists some Boolean algebra that will give us the
989240	996040	right answer it means that Boolean algebra is universal it's complete there's not a single
996040	1002040	finite question that we couldn't answer using Boolean algebra not one that really is something
1002040	1006360	i'd tell you what things are about to get even crazier i mean they're going to get crazier
1006360	1012280	let's have a look at another little operation way way back when we were looking at the original
1012280	1017880	operations there's a gate just here a funny little gate a strange gate it returns the
1017880	1024440	opposite of and it returns not and in other words nand for short just like an and and then
1024440	1028600	you're not the result and it's a strange gate because let's have a bit of a look at something
1028600	1035560	if we go a nand a if we input the same variable for both parameters then it's either going to be
1035560	1042920	zero zero as the input or one one as the input for nand if we input zero zero it returns one
1042920	1049800	and if we input one one nand returns zero if we nand a variable with itself performs a Boolean
1049800	1055880	not but that's just to start my friends because have a look at this nand is not and right it's not
1055880	1063640	and it's nand it's great if we nand a and b together and then we nand that result with itself what we'll
1063640	1071240	get is the not of the not and we'll get Boolean and we can perform Boolean not and Boolean and
1071240	1076280	using a single weird little gate here's an interesting fact if you take a truth table
1076280	1081800	that's output from some Boolean expression if you complement each of the inputs so wherever
1081800	1086520	the variables are clean you put a not beside them like a becomes not a and wherever there's a not
1086520	1092040	you get rid of it if you complement each of the variables to this Boolean expression then the
1092040	1097800	truth table of this function will actually be the reverse of the original truth table it will
1097800	1109640	be the same thing flipped upside down if we look at the nand gates output we've got one one one zero
1109640	1111960	this is what the all gate returns but it's upside down
1119480	1126120	so if you wanted to emulate Boolean or using nothing but nand all you would have to do is
1126120	1132600	complement the two inputs a and b and we know already that we can complement the inputs using
1132600	1141160	nothing but nand if we go a nand a nand b nand b wouldn't you know it we've got Boolean or
1141800	1148920	now that's a little bit strange the original Boolean set is universal you can compute literally
1148920	1154280	anything at all be it an operating system a video game or weather forecaster doesn't matter
1154280	1160680	anything at all but you can compute the original Boolean set of operations using nothing but nand
1160680	1168280	and what does that mean well it means that nand itself is universal can compute absolutely anything
1168280	1174440	you don't need any loops you don't need any objects no if statements all you need is a long
1174440	1180680	string of nand this is often implemented in transistors in cpu's and various other hardware
1180680	1186120	themselves i mean this is how computers work this is how they work absolutely astonishing stuff
1186120	1191640	shout out to nor as well the nor gate is also universal different expressions of course to
1191640	1197480	produce the various Boolean operations but nor is also universal i should mention at some point
1197480	1203320	that it's not even remotely practical to use nand to write something like an operating system for
1203320	1209400	example if you wanted to write a video game the number of nands in your code if you write code
1209400	1214200	like this i mean it would be absolutely astronomically large i mean we're not even talking millions or
1214200	1219000	billions here um it would be like a google plex or like graham's number or something you know these
1219000	1225800	are completely and utterly impractical but it is interesting to see that uh at least in theory
1225800	1231080	no matter what the input bit patterns are and no matter what output you need you need nothing
1231080	1238440	other than nand to uh to generate that output okay and so we can't talk about a lot of this
1238440	1245480	stuff without mentioning the incredible mr allen turing really one of the most uh magnificent
1245480	1251560	people ever to walk the earth just an astonishing astonishingly intelligent man of course his life
1251560	1257800	was was really cut cut quite short with uh you know terrible tragedy but uh his work and influence
1257800	1263240	survives today in a very very big way so allen turing really wrote the book on what it means to
1263240	1268440	compute things and he envisaged these machines i think he called them automatons at the time
1268440	1273480	but they came to be known as uh turing machines and uh what he said was uh if you had a tape and
1273480	1278920	there was a head that was reading and writing to the tape zeros and ones or using some alphabet
1278920	1284200	he pointed out that you could in theory write code for this machine to solve any problem out there
1284200	1290120	and so turing complete means that any set of inputs can be used to produce any outputs
1290200	1294280	allen turing what a guy uh there's been movies made about him books made about him
1294280	1300440	yeah so we can uh we can never meet mr allen turing you know we can never say thank you to him
1301720	1308120	but uh for what it's worth just want to say here on a little youtube video mr allen turing
1309160	1311960	thanks mate you are amazing
