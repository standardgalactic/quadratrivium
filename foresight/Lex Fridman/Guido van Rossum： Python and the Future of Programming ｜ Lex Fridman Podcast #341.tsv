start	end	text
0	10800	Can you imagine possible features that Python 4.0 might have that would necessitate the creation
10800	20000	of the new 4.0 given the amount of pain and joy, suffering and triumph that was involved in the
20000	27280	move between version 2 and version 3? The following is a conversation with Guido van
27280	32960	Rossum, his second time on this podcast. He is the creator of the Python programming language
32960	40960	and is Python's emeritus BDFL, benevolent dictator for life. This is the Lex Friedman podcast.
40960	46000	To support it, please check out our sponsors in the description. And now dear friends,
46000	53040	here's Guido van Rossum. Python 3.11 is coming out very soon. In it,
53040	60480	Cpython claimed to be 10 to 60% faster. How did you pull that off? And what's Cpython?
60480	66480	Cpython is the last Python implementation standing also the first one that was ever created. The
66480	72000	original Python implementation that I started over 30 years ago. So what does it mean that Python,
72000	76800	the programming language is implemented in another programming language called C?
76800	81280	What kind of audience do you have in mind here? People who know programming?
81280	85680	No, there's somebody on a boat that's into fishing and have never heard about programming,
85680	90080	but also some world-class programmers. You're going to have to speak to both. Imagine a boat
90080	94720	with two people. One of them has not heard about programming is really into fishing.
94720	101440	And the other one is like an incredible Silicon Valley programmer that's programmed in everything.
101440	107440	C, C++, Python, Rust, Java. It knows the entire history of programming languages. So you're going
107440	112640	to have to speak to both. I imagine that boat in the middle of the ocean. I'm going to please
112640	119120	the guy who knows how to fish first. Yes, please. He seems like the most useful in the middle of
119120	125920	the ocean. You got to make him happy. I'm sure he has a cell phone. So he's probably very suspicious
125920	131120	about what goes on in that cell phone, but he must have heard that inside a cell phone is a tiny
131120	136960	computer. And a programming language is computer code that tells the computer what to do.
137440	144080	Very low-level language. It's zeros and ones, and then there's assembly, and then...
144080	150320	Oh, yeah. We don't talk about these really low levels because those just confuse people. I mean,
150960	155920	when we're talking about human language, we're not usually talking about vocal tracts and
155920	161280	how you position your tongue. I was talking yesterday about how when you have a Chinese person
162000	167760	and they speak English, this is a bit of a stereotype. They often don't know...
168720	175280	They can't seem to make the difference well between an L and an R. And I have a theory about
175280	182560	that, and I've never checked this with linguists, that it probably has to do with the fact that
182560	188640	in Chinese, there is not really a difference. And it could be that there are regional variations
188640	197760	in how native Chinese speakers pronounce that one sound that sounds like L to some of them,
197760	204080	like R to others. So, it's both the sounds you produce with your mouth throughout the history
204080	209200	of your life and what you're used to listening to. I mean, every language has that. Russian has...
209200	212400	Exactly. The Slavic languages have sounds like the letters
212960	218560	like Americans or English speakers don't seem to know the sounds.
220880	228160	They seem uncomfortable with that sound. Yeah. Oh, yes. Okay. So, we're not going to the shapes
228160	233440	of tongues and the sounds that the mouth can make. Fine. And similarly, we're not going into the
233440	239760	ones and zeros or machine language. I would say a programming language is a list of instructions
239840	248240	like a cookbook recipe that sort of tells you how to do a certain thing, like make a sandwich. Well,
249280	256480	acquire a loaf of bread, cut it in slices, take two slices, put mustard on one, put
258000	264640	jelly on the other or something, then add the meat, then add the cheese. I've heard that science
264640	271520	teachers can actually do great stuff with recipes like that and trying to interpret their students'
271520	276400	instructions incorrectly until the students are completely unambiguous about it.
277360	282160	With language, see, that's the difference between natural languages and programming languages.
282800	289200	I think ambiguity is a feature, not a bug in human spoken languages. Like,
290640	293120	that's the dance of communication between humans.
293120	301520	Well, for lawyers, ambiguity certainly is a feature. For plenty of other cases,
302240	309520	the ambiguity is not much of a feature, but we work around it, of course. What's more important
309520	316800	is context. So, with context, the precision of the statement becomes more and more concrete, right?
316800	321440	But, you know, when you say, I love you to a person that matters a lot to you,
322320	326160	the person doesn't try to compile that statement and return an error saying,
326160	334160	please define love, right? No, but I imagine that my wife and my son interpreted very differently.
335440	338560	Yes. Even though it's the same three words. But in precisely still.
339920	345040	Oh, for sure. Well, lawyers have a lot of follow-up questions for you. Nevertheless,
345040	352160	the context is already different in that case. Yes, fair enough. So, that's a programming language
352160	360720	is ability to unambiguously state a recipe. Actually, let's go back. Let's go to Pepe.
361360	368000	You go through in Pepe, the style guide for Python code, some ideas of what this language should
368000	374560	look like, feel like, read like. And the big idea there is that code readability counts.
374560	379040	What does that mean to you? And how do we achieve it? So, this recipe should be readable.
379040	386320	That's a thing between programmers. Because on the one hand, we always explain the concept of
386320	393760	programming language as computers need instructions and computers are very dumb and they need very
393760	399120	precise instructions because they don't have much context. In fact, they have lots of context,
399120	406880	but their context is very different. But what we've seen emerge during the development of
406880	416400	software starting in the probably in the late 40s is that software is a very social activity.
416400	422400	A software developer is not a mad scientist who sits alone in his lab writing brilliant code.
422720	431360	A software is developed by teams of people. Even the mad scientist sitting alone in his lab
431360	437600	can't type fast enough to produce enough code so that by the time he's done with his coding,
437600	445280	he still remembers what the first few lines he wrote mean. So, even the mad scientist coding
445280	455520	alone in his lab would be sort of wise to adopt conventions on how to format the instructions
455520	461840	that he gives to the computer so that the thing is there is a difference between a cookbook recipe
461840	468640	and a computer program. The cookbook recipe, the author of the cookbook writes it once
469440	476320	and then is printed in 100,000 copies and then lots of people in their kitchens try to
476320	486240	recreate that recipe, that particular pie or dish from the recipe. And so there the
487920	494880	goal of the cookbook author is to make it clear to the human reader of the recipe,
494880	505360	the human amateur chef in most cases. When you're writing a computer program, you have two audiences
505360	518000	at once. It needs to tell the computer what to do but it also is useful if that program is readable
518000	525200	by other programmers because computer software unlike the typical recipe for a cherry pie
525840	535360	is so complex that you don't get all of it right at once. You end up with the activity of debugging
535920	539280	and you end up with the activity of... So debugging is
542080	545840	trying to figure out why your code doesn't run the way you thought it should run.
546480	549760	That means broadly it could be stupid little errors or it could be big
550400	559920	logical errors. It could be anything from a typo to a wrong choice of algorithm to
560960	565440	building something that does what you tell it to do but that's not useful.
566480	573840	Yeah it seems to work really well 99% of the time but does weird things 1% of the time on some
573840	579920	edge cases. That's pretty much all software nowadays. All good software right? Well yeah for
579920	586080	for bad software then. That 99 goes down a lot so but it's not just about the complexity of the
586080	593680	program it's like you said it is a social endeavor in that you're constantly improving that recipe
593680	600000	for the cherry pie. But you're sort of you're in a group of people improving that recipe
600720	607680	or the mad scientist is improving the recipe that he created a year ago and making it better
608640	615680	or adding something. He decides that he wants I don't know he wants some decoration on his pie
615680	621920	or icing or... So there's broad philosophical things and there's specific advice on style.
622560	625920	So first of all the thing that people first experience when they look at Python
626880	633200	there is a it is very readable but there's also like a spatial structure to it.
634080	640880	Can you explain the indentation style of Python and what is the magic to it? Spaces are important
640880	650080	for readability of any kind of text. If you take a cookbook recipe and you remove all the sort of
650800	657280	all the bullets and other markup and you just crunch all the text together maybe you leave the
657280	664160	spaces between the words but that's all you leave. When you're in the kitchen trying to figure out
664160	670320	oh what are the ingredients and what are the steps and where does this step end and the next step
670320	676880	begin you're going to have a hard time if it's if it's just one solid block of text. On the other
677520	682800	On the other hand what what a typical cookbook does if the paper is not too expensive
683840	690400	each recipe starts on its own page maybe there's a picture next to it. The list of ingredients comes
690400	698000	first there's a standard notation there's there's shortcuts so that you don't have to
698720	704560	sort of write two sentences on how you have to cut the onion because there are only three ways
704560	710320	that people ever cut onions in the kitchen small medium and in slices or something like that.
711520	715600	Right. None of my examples make any sense to real cooks of course but yeah.
717920	723600	We're talking to programmers with the metaphor of cooking I love it but there is a strictness to
723600	730640	the spacing that Python defines so there's some looser things some stricter things but the four
730720	738960	spaces for the indentation is really interesting it really defines what the language looks and
738960	745760	feels like. Because indentation sort of taking a block of text and then having inside that block
745760	754480	of text a smaller block of text that is indented further as sort of a group it's like you have
755040	762800	a bulleted list in a complex business document and inside some of the bullets are other bulleted
762800	771280	lists you will indent those two if each bulleted list is indented several inches then at two levels
771280	777360	deep there's no no space left on the page to put any of the words of the text so you can't indent
777360	783920	too far on the other hand if you don't indent at all you can tell whether something is a top level
783920	790400	bullet or a second level bullet or a third level bullet so you have to have some compromise and
791760	799920	based on ancient conventions and the sort of the typical width of a computer screen in the 80s
801600	809520	and all sorts of things sort of we came up with sort of four spaces as a compromise
810240	817280	I mean there there are groups there are large groups of people who code with two spaces per
817280	824080	indent level for example the google style guide all the google python code and I think also all
824080	830560	the google c++ code is indented with only two spaces per block if you're not used to that it's
830560	838720	harder to at a glance understand the code because the sort of the high level structure
838800	844160	is determined by the indentation on the other hand there are there are other programming languages
844160	851920	where the indentation is eight spaces or a whole tap stop in in sort of classic unix and to me that
851920	858080	looks weird because you you sort of after three indent levels you've you've got no room left well
858080	864080	there is some languages where the indentation is a recommendation it's a stylistic one the code
864080	870480	compiles even without any indentation and then python really indentation is a fundamental part
870480	877520	of the language right it doesn't have to be four spaces so you you can code python with
877520	884560	two spaces per block or four or six spaces or 12 if you really want to go wild but
886240	892080	sort of everything that belongs to the same block needs to be indented the same way
892960	897760	in practice in most other languages people recommend doing that anyway if you look at
899280	907760	c or rust or c++ all those languages java don't have a requirement of indentation
908800	916400	but except in extreme cases they're just as anal about having their code properly indented
916960	925120	so any ide that the syntax highlighting that works with java or c++ they will yell at you
925760	931600	aggressively if you don't do proper indentation they'd suggest the proper indentation for you
932400	940240	like in c you type a few words and then you type a curly brace which there is their notion of
940240	948000	sort of begin an an indented block then you hit return and then it automatically indents
948000	953760	four or eight spaces depending on your style preferences or how your editor is configured
953760	958400	was there a possible universe in which you considered having braces in python
959200	967120	absolutely yeah well it was a 60 40 70 30 in your head uh what was the tradeoff
967120	973760	for a long time i was actually convinced that the indentation was just better
976720	981840	without context i would still claim that indentation is better
984080	990800	it reduces clutter however as i started to say earlier context is almost everything
991760	999440	and in the context of coding most programmers are familiar with multiple languages even if
999440	1006880	they're only good at one or two and apart from python and maybe fortran i don't know how that's
1006880	1012800	written these days anymore but all the other languages java rust cc plus plus javascript
1012800	1023440	typescript pearl are all using curly braces uh to sort of indicate blocks and so python is the odd
1023440	1030560	one out so it's a radical idea do you still as a radical renegade revolutionary do you still
1030560	1037440	stand behind this idea of space of indentation versus braces like what what can you dig into it
1037440	1045680	a little bit more why you still stand behind indentation because context is not the whole story
1045680	1055360	history in in a sense provides more context so for python there is no chance that we can switch
1056560	1063120	python is using curly braces for something else dictionaries mostly we would get in trouble if
1063120	1072720	we wanted to switch just like you couldn't redefine c to use indentation even if you agree that that
1072720	1081040	indentation sort of in a greenfield environment would be better you can't change that kind of thing
1081040	1088720	in a language yeah it's hard enough to reach agreement over over much more minor details maybe
1088800	1094640	i mean in the past in python we did have a big debate about teps versus spaces and four spaces
1094640	1104160	versus fewer or more and we sort of came up with a recommended standard and sort of options for people
1104160	1111600	who want to be different but yes i guess the thought experiment i'd like you to consider
1111600	1117360	is if you could travel back through time when the when the compatibility is not an issue
1118000	1125200	and you started python all over again can you make the case for indentation still
1126000	1131920	well it frees up a pair of matched brackets of which there are never enough in the world
1133200	1141840	for other purposes it really makes the language slightly sort of easier to grasp
1142560	1147280	for people who don't already know another programming language
1149120	1154720	because the sort of one of the things and i i mostly got this from my mentors who
1156240	1162160	taught me programming language design in the earlier 80s when you're teaching programming
1162880	1171600	for for the the the total newbie who has not coded before in not in any other language
1173840	1183600	a whole bunch of concepts in programming are very alien or sort of new and and maybe very
1183600	1188880	interesting but also distracting and confusing and there are many different things you have to learn
1188880	1197680	you have to sort of in a typical 13 week programming course you have to if if it's
1197680	1204240	like really learning to program from scratch you have to cover algorithms you have to cover
1204240	1212000	data structures you have to cover syntax you have to cover variables loops functions recursion
1212000	1221760	classes expressions operators there are so many concepts if you you sort of if you can spend a
1221760	1233840	little less time having to worry about the syntax the classic example was often oh the compiler
1233840	1240320	complains every time i put a semicolon in the wrong place or i forget to put a semicolon
1242080	1248160	python doesn't have semicons in that sense so you can't forget them and you are also not
1249040	1255280	sort of misled into putting them where they don't belong because you don't learn about them in the
1255280	1262640	first place the flip side of that is forcing the strictness onto the beginning programmer
1262640	1269040	to teach them that programming is values attention to details you don't get to just
1269120	1274080	write the way you write in english many of other details that they have to pay attention to so i
1274080	1280160	think they'll they'll still get the message about paying attention to details the interesting
1280160	1286000	design choice so i still program quite a bit in php and i'm sure there's other languages like this
1286000	1294000	but the dollar sign before a variable that was always an annoying thing for me it didn't quite
1294640	1299360	fit into my understanding of why this is good for a programming language i'm not sure if you
1299360	1306800	ever thought about that one that is a historical thing there is a whole lineage of programming
1306800	1317280	languages php is one pearl was one on the unix shell uh is one of the oldest or or all the
1317280	1326400	different shells the dollar was invented for that purpose because the very earliest shells had a
1326400	1333280	notion of scripting but they did not have a notion of parameterizing the scripting right and so a
1333280	1341760	script is just a few lines of text where each line of text is a command that is read by a very
1341840	1347760	primitive command processor that then sort of takes the first word on the line as the name of a
1347760	1355840	program and passes all the all the rest of the line as text into the program for the program to
1355840	1364240	figure out what to do with as arguments and so by the time scripting was slightly more mature
1364240	1372080	than the very first script there was a convention that just like the first word on the line is
1372880	1382960	uh the name of the program the following words uh could be names of files input dot text output dot
1382960	1391600	html things like that the next thing that happens is oh it would actually be really nice if we could
1391680	1397760	have variables and especially parameters for scripts parameters are usually what starts this
1397760	1406320	process but now you have a problem because you can't just say the parameters are x y and z
1407440	1413920	and so now we we call say let's say x is the input file and y is the output file and let's
1413920	1421040	forget about z for now i have my program and i write program x y well that already has a meaning
1421040	1429840	because that presumably means x itself is the file it's a file name it's not a variable name
1432400	1439600	and so the inventors of of things like the unique shell and i'm sure job command language
1439600	1449360	in at IBM before that uh had to use something that made it clear to the script processor
1451040	1456560	here is an x that is not actually the name of a file which you just pass through to the
1457440	1463280	to the program you're running here is an x that is the name of a variable yeah and
1464320	1469840	when you're writing a script processor you try to keep it as simple as possible
1470800	1477920	because at that as certainly in the the 50s and 60s uh the thing that interprets the script
1477920	1483360	was itself a very had to be a very small program because it had to fit in a very small part of
1483360	1492000	memory and so saying oh just look at each character and if you see a dollar sign you jump to another
1492000	1496960	section of the code and then you gobble up characters or say until the next space or something
1497600	1504880	and you say that's the variable name and so it was was sort of invented as
1505520	1513120	a clever way to make parsing of things that contain both contain both variable and fixed parts
1514080	1521360	very easy in a very simple script processor it also helps even then it also helps the human
1522400	1531920	author and the human reader of the the script to quickly see oh 20 lines down in the script
1531920	1537760	i see a reference to x y z oh it has a dollar in front of it so now we know that x y z must be
1537760	1542720	one of the parameters of the script well this is fascinating several things to say which is
1543680	1549760	the leftovers from the simple script processor languages are now in code bases like behind
1549760	1555200	facebook or behind most of the back end i think php's probably still runs most of the back end
1555200	1560880	of the internet oh yeah i think there's a lot of it in wikipedia too for example yeah it's funny
1560880	1566000	that those decisions are not funny it's fascinating that those decisions permeate through time
1567040	1573600	just like biological systems right i mean that the sort of the inner workings of dna
1574800	1581440	have been stable for well i don't know how long it was like 300 million years half a billion years
1581440	1587520	yeah and there there are all sorts of weird quirks there that don't make a lot of sense if
1587520	1594480	you were to design a system like self-replicating molecules from scratch well that system has a
1594480	1602880	lot of interesting resilience it has redundancy that results like it messes up in interesting ways
1602880	1608080	that still is resilient when you look at the system level of the organism code doesn't
1608080	1615760	necessarily have that a program a computer programming code you'd be surprised how much
1615840	1622560	resilience modern code has i mean if you if you look at the number of bugs per line of code
1623920	1632640	even in in very well tested code that in practice works just fine there are actually
1632640	1640800	lots of things that don't work fine and there are error correcting or self-correcting mechanisms
1640800	1648000	at many levels including probably the user of the code well in the end the user who sort of is
1648000	1658000	told well you got to reboot your your pc is part of that system and a slightly less drastic thing
1658000	1665120	is reload the page which we all know how to do without thinking about it when something weird
1665120	1669920	happens you try to reload a few times before you say oh there's something really weird
1669920	1675920	okay or try to click the button again if the first time didn't work well yeah that that we
1675920	1680800	should all have learned not to do that because that's probably just gonna turn the light back off
1681440	1688480	yeah true so do it three times that's the that's the right lesson so uh and i wonder how many people
1688480	1696960	actually like the dollar sign like you said it is documentation so to me it's whatever the
1696960	1703600	opposite of syntactic sugar is syntactic poison to me it is such a pain in the ass that i have to
1703600	1710640	type in a dollar sign also super error prone so it's not self documenting it's it's like a bug
1710640	1715920	generating thing it is a kind of documentation that's the pro and the con is it's a source of a
1715920	1722320	lot of bugs but actually i have to ask you um this is a really interesting idea of bugs per line of
1722320	1728880	code if you look at all the computer systems out there from the code that runs nuclear weapons
1729440	1735600	to the code that runs all the amazing companies that you've been involved with and not the code
1735600	1742800	that runs twitter and facebook and dropbox and google and microsoft windows and so on and we like
1742800	1751520	laid out wouldn't that be a cool like table bugs per line of code and what let's let's put like
1751520	1756560	actual companies aside do you think we'd be surprised by the number we see there for all
1756560	1764320	these companies that depends on whether you've ever read about research that's been done in this
1764320	1773600	area before and i don't know that the the last time i i saw some research like that there was
1773680	1781040	probably in the 90s and the research might have been done in the 80s but the the conclusion was
1781680	1790880	across a wide range of different software different languages different companies different
1790880	1799440	development styles the number of bugs is always i think it's in the order of about one bug per
1799440	1808160	thousand lines in sort of mature software that that is considered interesting as good as it gets
1808160	1814160	can't give you some facts here there's a lot of good papers so you said mature software right so
1814160	1823040	here's a report from a uh like programming analytics company now this is from a developer
1823040	1828640	perspective let me just say what it says because this is very weird and surprising
1828640	1833200	on average a developer creates 70 bugs per 1000 lines of code
1834560	1838320	15 bugs per 1000 lines of code find their way to the customers
1840000	1846000	this is in software they've oh i was i was wrong by an order working on an order fixing a bug takes
1846000	1853040	30 times longer than writing a line of code that i can believe yeah 75 of a developer's time is
1853040	1858960	spent on debugging um that's for an average developer that they analyze this 15 argue
1860560	1869280	1500 hours a year in us alone 113 billion dollars to spend annually on identifying and fixing bugs
1870400	1876160	and i imagine this is marketing literature for someone who claims to have a golden bullet or
1876160	1883280	silver bullet that makes all that investment in fixing bugs go away but that that is usually
1884240	1889280	not going to yeah that's not gonna happen well they're uh i mean they're referencing a lot of
1889280	1895600	stuff of course but it is the page uh that is you know there's a contact us button at the bottom
1896160	1901440	presumably if you just spend a little bit less than 100 billion dollars we're willing to solve
1901440	1907440	the problem for you right and there's also a report on stack exchange and stack overflow on the
1907440	1912400	exact same topic but when i open it up at the moment the page says stack overflow is currently
1912400	1918640	offline for maintenance oh that is ironic yes uh by the way their error page is awesome anyway
1920000	1926000	i mean can you believe that number of bugs oh absolutely isn't that scary that 70 bugs per
1926000	1933040	1000 lines of code so even 10 bugs per 1000 lines well that's about one bug every 15 lines and
1933040	1939360	that's when you're first typing it in yeah from a developer but like how many bugs are going to be
1939360	1947680	found if you're if you're typing well the development process is extremely iterative yeah typically you
1947680	1955040	don't make a plan for what software you're going to release a year from now yeah and work out all
1955040	1962400	the details because actually all the details uh themselves consist they sort of compose a program
1963920	1970800	and that that being a program all your plans will have bugs in them too and inaccuracies
1972320	1979040	but what what you actually do is you do a bunch of typing and i'm i'm actually
1979760	1985920	really i'm a really bad typist that's just i've never learned to type with 10 fingers
1987040	1994320	how many do you use well i use all 10 of them but not very well but i never i never took a
1994320	2001040	typing class and i never sort of corrected that so the first time i i seriously learned i had to
2001040	2008000	learn the layout of a of a qwerty keyboard was actually in college in my first programming classes
2008800	2017600	where we used punch cards and so with my two fingers i sort of pecked out my code
2018960	2027120	watch anyone give you a little coding demonstration they'll have to produce like four lines of code
2028400	2034800	and now see how many times they use the backspace key yeah because they made a mistake and and
2035760	2039200	and some people especially when when someone else is looking
2041680	2048960	will will backspace over 20 30 40 characters to fix a typo earlier in the line if you're
2050480	2055840	if you're slightly more experienced of course you use your arrow buttons to go or your mouse to
2055840	2063520	but the mouse is usually slower than than the arrows but a lot of people when they type a
2063680	2070240	20 character word which is not unusual and they realize they made us made a mistake at the start
2070240	2075840	of the word they backspace over the whole thing and then retype it and sometimes it takes three four
2075840	2084000	times to get it right so i don't know what your definition of bug is arguably mistyping a word
2084000	2092000	and then correcting it immediately is not a bug on the other hand you you already do sort of lose
2092000	2098640	time and every once in a while there's sort of a typo that you don't get in that process
2099760	2105360	and now you've you've you've typed like 10 lines of code and somewhere in the middle of it you
2105360	2112800	don't know where yet is a typo or maybe a thing code where you you forgot that you had to initialize
2112800	2117440	a variable or something but those are two different things and i would say yes you have to actually
2117440	2123600	run the code to discover that typo but forgetting to initialize a variable is a fundamentally different
2124160	2130400	thing because that thing could go undiscovered that depends on the language in python it will not
2130400	2136640	right and sort of modern compilers are usually pretty good at catching that even even foresee
2136640	2144080	so for that specific thing but actually deeper it might there might be another variable that
2144080	2152160	is initialized but logically speaking the one you meant related yep it's like name the same but
2152160	2158160	it's a different thing and you forgot to initialize whatever some counter or some some basic variable
2158160	2163840	they're using i can tell that you've coded yes by the way i should mention that i use a kinesis
2163840	2172000	keyboard which has the backspace under the thumb and one of the biggest reasons i use that keyboard
2172000	2177760	is because you realize in order to use the backspace on a usual keyboard you have to stretch
2177760	2186560	your pinky out and like the for most normal keyboards the backspace is under the pinky
2186560	2193840	and so i don't know if people realize the pain they go through in their life because of the backspace
2193840	2198080	key being so far away so with the kinesis it's right under the thumb so you don't have to actually
2198080	2205440	move your hands the backspace and what do you do if you're ever not with your own keyboard and you
2205440	2211760	have to use someone else's pc keyboard that has that standard layout so first of all it turns out
2212320	2218000	that you can actually go your whole life always having the keyboard with you so this well except
2218000	2223280	for that that little tablet that you're using so we're not taking right now right uh yeah so it's
2223280	2229920	very inefficient note-taking but i'm not i'm just looking stuff up but in most cases i would be actually
2229920	2235520	using the keyboard here right right now i just don't anticipate you have to calculate how much
2235520	2240480	typing do you anticipate if i anticipate quite a bit then i'll just i have a keyboard you pull
2240480	2249040	that and same same with i mean the embarrassing i've accepted being the weirdo that i am but
2249760	2254800	you know when i go on an airplane and i anticipate to do programming or a lot of typing
2255360	2261600	i will have a laptop that will pull out a kinesis keyboard in addition to the laptop
2261600	2267840	and it's just who i am you have to you have to accept who you are but also it's a you know for a
2267840	2274480	lot of people for me certainly there's a comfort space where there's a certain kind of setups that
2275120	2281680	maximize productivity and it's like some people have a warm blanket that they like
2282400	2289120	when they watch a movie i like the kinesis keyboard takes me to a place of focus and i still mostly
2289840	2296720	i i'm trying to make sure i use the state of the art ids for everything but my comfort place
2296720	2306960	just like the kinesis keyboard is still emacs so i still use i still i mean that's one of some
2306960	2313760	of the debates i have with myself about everything from a technology perspective is how much to hold
2313760	2320480	on to the tools you're comfortable with versus how much to invest in using modern tools and the
2320480	2326000	signal that the communities provide you with is the noisy one because a lot of people year to
2326000	2332560	year get excited about new tools and you have to make a prediction are these tools defining a new
2332560	2337280	generation of something that will transform programming or is this just a fad that will pass
2338080	2344720	certainly with javascript frameworks and front and the back end of the web there's a lot of
2344720	2351280	different styles that came and went i remember learning um what was it called action script
2351280	2358320	i remember for flash um you know learning how to program in flash learning how to design
2358320	2363200	doing graphic animation all that kind of stuff for flash same with java applets i remember
2363200	2367680	creating quite a lot of java applets thinking that this potentially defines the future of the
2367680	2376240	web and did not well you know in most cases like that the particular technology eventually gets
2376240	2386720	replaced but many of the concepts that the technology introduced or made accessible first
2388240	2395360	are preserved of course because yeah we're not using java applets anymore but the notion of
2395360	2405280	reactive web pages that sort of contain little bits of code that respond directly to something
2405360	2411840	you do like pressing a button or a link or hovering even uh is has certainly not gone away
2412560	2422720	and that those animations that were made painfully complicated with flash i mean flash was an
2422720	2430480	innovation when it first came up and when it was replaced by javascript equivalents stuff
2431440	2438480	it was a somewhat better way to do animations but those animations are still there not all of them
2439280	2446320	but but sort of again there is an evolution and often so often with technology
2447360	2454000	that the sort of the technology that was eventually thrown away or replaced was still
2454000	2460880	essential to to sort of get started there wouldn't be jet planes without propeller planes
2461680	2469600	i bet you but from a user perspective yes from the feature set yes but i from a programmer
2469600	2479040	perspective it feels like all the time i've spent with action script all the time i spent with
2479040	2484160	java on the applet side for the GUI development i well no java i have to push back that that was
2484160	2489760	useful that because it transfers but the flash doesn't transfer so some things you learn and
2489760	2496560	invest time in what yeah what what you learned the skill the skill you picked up learning action
2496560	2505600	script yeah was sort of it was perhaps a super valuable skill at the time you picked it up
2506240	2515360	if you if you if you learned action script early enough but that skill is no longer
2516560	2520800	in demand well that's the calculation you have to make when you're learning new things like today
2520800	2527520	people start learning programming today i'm trying to to see what are the new languages to try what
2527520	2534000	are the new systems to try that what are the new ideas to try to to keep keep improving that's
2534000	2541360	that's why we start when we're young right when when we're but but that seems very true to me that
2541360	2546640	that when you're young you have your whole life ahead of you and you're you're allowed to make
2546640	2553360	mistakes in fact you should you should feel encouraged to to do a bit of stupid stuff yeah
2553360	2561360	try not to get yourself killed or seriously maimed but try stuff that deviates from from
2561360	2569200	what everybody else is doing and like nine out of ten times you'll just learn why everybody else
2569200	2575600	is not doing that or why everybody else is doing it some other way and one out of ten times you
2575600	2582240	sort of you discover something that's better or that that somehow works i mean there are all
2582240	2590320	sorts of crazy things that were invented by accident by people trying trying stuff together
2591120	2596240	that's great advice to try random stuff make a lot of mistakes once you're married with kids
2596240	2601680	you're probably going to be a little more risk averse because now there's more at stake and
2601680	2607120	you've already hopefully had some time where you where you were experimenting with crazy shit
2607840	2612560	i like how marriage and kids solidifies your choice of programming language how does that the
2612560	2618240	the robber frost poem with the the road less taken which i think is misinterpreted by most people
2618240	2624720	but anyway i i feel like the choices you make early on especially if you go all in they're
2624720	2630720	going to define the rest of your life's trajectory in a way that like you basically are picking a
2630720	2637840	camp so you know there's if you invest a lot in php if you invest a lot in dot net if you
2637840	2646400	invest a lot in java script you're going to stick there you that's that's your life journey
2646960	2655120	it's very hard to tell only as far as that technology remains relevant yes yes i mean
2655120	2665440	if if at age 16 you learn coding in c and by the time you're 26 c is like a dead language
2668400	2675440	then there's still time to switch there's probably some kind of survivor bias or whatever it's called
2676160	2682720	in in sort of your observation that that you pick a camp because there are many different
2682720	2690000	camps to pick and if you pick dot net then then you can coast for the rest of your life because
2690000	2697040	that technology is now so ubiquitous of course that it's even if it's if it's bound to die it's
2697040	2704800	going to take a very long time well for me personally i had a very difficult and in my own
2704800	2710880	head brave leap that i had to take relevant to our discussion which is most of my life i programed
2710880	2719520	in c and c plus plus and so uh having that hammer everything looked like a nail so i would literally
2719520	2726080	even do scripting in c plus plus like i would create programs i do script like things and uh
2726080	2732240	when i first came to google and before then it became already before tensile for before all of
2732240	2738320	that there was a growing realization that c plus plus is not the right tool for machine learning
2738320	2743840	we could talk about why that is it's unclear why that is a lot of things has to do with
2743840	2748960	community and culture and how it emerges and stuff like that but for me to decide to take
2748960	2755120	the leap to python like all out basically switch completely from c plus plus except for
2756480	2761680	highly performant robotics applications there were still a there's still a culture of c plus
2761680	2769360	plus in in the space of robotics that was a big leap like i had to you know like like people have
2769360	2775440	like existential crises or midlife crises or whatever you have to realize almost like walking
2775440	2781600	away from uh from a person you love um because i was sure that c plus plus would have to be a life
2781600	2786640	long companion for a lot of problems i would want to solve c plus plus would be there and it was a
2786640	2791280	question to say well that might not be the case because c plus plus is still one of the most
2791280	2795920	popular languages in the world one of the most used one of the most dependent on it's also
2796480	2805600	still evolving quite a bit i mean that that is not a sort of a fossilizing community
2806160	2812240	yes they they are doing great innovative work actually a lot but yet the sort of their innovations
2812240	2818320	are hard to follow if you're not already a hardcore c plus plus user well this was the thing it pulls
2818320	2823520	you in it's a rabbit hole i was a hardcore the all meta programming template programming like
2823520	2830160	i i would start using the modern c plus plus as it developed right not just the not not just the
2830160	2834400	shared pointer in the garbage collection that's you that makes it easier for you to work with some
2834400	2840640	of the flaws but the detail like the meta programming the the crazy stuff that's that's coming out there
2840640	2848400	but then you have to just empirically look and step back and say what language am i more productive in
2848720	2856720	sorry to say what language do i enjoy my life with more and uh readability and able to think
2856720	2861120	through and all that kind of stuff that those questions are harder to ask when you already have
2862080	2869360	a loved one which in my case was c plus plus and then there's python uh like that meme was
2869360	2875360	is the the grass is greener on the other side am i just infatuated with a new fad new cool thing
2875360	2880480	new cool thing or is this actually going to make my life better and i think a lot of people face
2880480	2887200	that kind of decision it was a difficult decision for me um when i made it at this time it's an
2887200	2893920	obvious switch if you're into machine learning but that time it wasn't quite yet so obvious so it was
2893920	2899360	a risk and you know you have the same kind of stuff with um i still because of my connection
2899360	2903920	to wordpress i still do a lot of back end programming in php
2906640	2912320	and the question is you know no j s python do you switch to do you switch back end to any of those
2913440	2919680	programming there's the case for no j s for me well more more more of the front end it runs in
2919680	2926480	java script um and fascinating cool stuff is done as java script maybe use the same program
2926560	2932240	language for the back end as well uh the case for python for the back end is well you're doing so
2932240	2939440	much programming outside of the web in python so maybe use python for the back end and then the
2939440	2945840	case for php well most of the web still runs in php you have a lot of experience with php
2947120	2952480	why uh fix something that's not broken those are my own personal struggles but i think they
2952480	2956880	reflect the struggles of a lot of people with different programming languages with different
2956880	2961920	problems they're trying to solve it's a weird one and there there's not a single answer right
2961920	2968880	because depending on how much time you have to learn new stuff where you are in your life
2968880	2974240	what what you're currently working on who you want to work with what communities you like
2975200	2983200	there's not one right choice maybe if you if you sort of if you can look back 20 years you can say
2983200	2990480	well that whole detour through action script was a waste of time but nobody could know that
2991600	2999200	so you can't you can't beat yourself up over that uh you just need to accept that not every choice
2999280	3006720	you make is going to be perfect maybe sort of keep a plan be in the back of your mind
3008880	3017120	but don't don't overthink it don't don't try to sort of don't don't create a spreadsheet with like
3018320	3025120	where you're trying to estimate well if i learn this language i expect to make x million dollars
3025120	3031200	in a lifetime and if i learn that language i expect to make y million dollars in a lifetime
3031760	3037920	and which which is higher and what which has more risk and where is the chance that it's like
3037920	3049920	picking picking a stock kind of kind of but uh i think with stocks you can do diversifying your
3049920	3057520	investment is good with productivity in life boy that spreadsheet is possible to construct
3058960	3063920	like if you actually carefully analyze what your interests in life are where you think you can
3063920	3070320	maximally impact the world there really is better and worse choices for programming language
3070320	3075040	that are not just about the syntax but about the community about where you predict the
3075040	3080960	community's headed what large systems are programmed in that but can you create that
3080960	3085920	spreadsheet because that's sort of you're mentioning a whole bunch of inputs that go
3085920	3091760	into that spreadsheet where you have to estimate things that are very hard to measure and even
3091760	3097840	harder i mean they're they're hard to measure retroactively and they're even harder to predict
3097840	3105920	like what is the better community well better is is one of those incredibly difficult words
3106560	3110400	what's better for you is not better for someone else no but we're not doing a public
3110400	3116560	speech about what's better we're doing a personal spiritual journey i can determine a circle of
3116560	3122240	friends circle circle one and circle two and i can have a bunch of parties with one and a bunch
3122320	3129280	of parties with two and then write down or take a mental note of what made me happier right and
3129280	3134560	that you know you have if you're a machine learning person you want to say okay i want to build a
3134560	3141440	large company that does that is grounded in machine learning but also has a sexy interface
3141440	3146720	that has a large impact on the world what languages do i use you look at what facebook is using you
3146720	3153120	look at what twitter is using then you look at performant more newer languages like rust or you
3153120	3158480	look at languages that have taken that most of the community uses in machine learning space that's
3158480	3163840	python and you can like think through you can hang out and think through it and it's it's always a
3163840	3168640	invest and the the level of activity of the community is also really interesting like you
3168640	3173680	said c plus boss and python are super active in terms of the development of the language itself
3174480	3181920	but do you think that you can make objective choices there no no no but there's a gut you
3181920	3187360	build up like don't you don't you believe in that gut feeling oh everything is very subjective and
3187360	3192960	yes you most certainly can have a gut feeling and your gut can also be wrong that's why there are
3192960	3198720	billions of people because they're not all right i mean clearly there are more people
3198720	3205520	living in the bay area who have plans to sort of create a google sized company than there's
3205520	3210880	room in the world for google sized companies and they're going to have to duke it out in the market
3211440	3218080	the space and there's many more choices than just the programming language speaking of which
3218080	3222480	let's go back to the boat with the with the fisherman who's tuned out long ago
3223280	3228560	let's talk to the programmer let's jump around and go back to c python that we tried to define
3228560	3234000	as the reference implementation and one of the big things that's coming out in 3.11 what's the
3234000	3241920	right way to we tend to say 3.11 because it really was like we went 3.8 3.9 3.10 3.11 and
3241920	3250080	we're planning to go up to 3.99 99 what happens after 99 probably just 3.100 what if i make it
3250080	3257600	there okay and go all the way to 4.20 i got it forever python v3 we'll talk about four but more
3257600	3266080	for fun so 3.11 is coming out one of the big sexy things in it is it'll be much faster so how
3266880	3273280	did you beyond hiring a great team or working with a great team make it faster what are some ideas
3274240	3282000	uh that me makes it faster it has to do with simplicity of software versus performance
3283040	3290800	and so even though c is known to be a low-level language which is great for writing sort of
3291600	3300400	a high performance language interpreter when i originally started python or c python i
3301360	3313040	didn't expect there would be great success and fame in my future uh so i i try to get something
3313760	3323760	working and useful uh in about three months and so i i sort of i cut corners
3324480	3331920	i borrowed ideas left and right when it comes to language design as well as implementation
3332800	3342880	uh i also wrote much of the code as simple as it could be and there there are like there are
3342880	3351760	many things that you can code more efficiently by adding more code it's a bit of a sort of a time
3351760	3360800	space trade-off where you can compute a certain thing from a small number of inputs
3362800	3369040	and every time you get presented with a new input you do the whole computation from the top
3370320	3375920	that can be simple looking code it's easy to understand it's easy to reason about that you
3376240	3382080	you can tell quickly that it's correct at least in the sort of mathematical sense of correct
3384800	3393360	because it's implemented in c maybe it performs relatively well but over time as sort of
3395040	3403840	as the requirements for that code and the need for performance go up you might be able to rewrite
3403840	3412880	that same algorithm using more memory maybe remember previous results so you don't have to
3412880	3419680	recompute everything from scratch like the the classic example is computing prime numbers like
3420800	3427760	is 10 a prime number well you sort of is it divisible by two is it divisible by three is
3427760	3435280	it divisible by four and we go all the way to is it divisible by nine and it is not well actually
3435280	3442320	10 is divisible by two so there we stop at say 11 it's divisible by 10 the answer is nine is no
3442320	3449040	10 times in a row so now we know 11 is a prime number on the other hand if we already know that
3449040	3454640	two three five and seven are prime numbers and you know a little bit about the mathematics of
3455360	3461440	how prime numbers work you know that if you have a rough estimate for the square root of 11
3462160	3468240	you don't actually have to check is it divisible by four or is it divisible by five you all you
3468240	3474640	have to check in the case of 11 is is it divisible by two is it divisible by three because take 12
3475920	3482480	if it's divisible by four well 12 divided by four is three so you you should have come across the
3482480	3489120	question is it divisible by three first so if you know basically nothing about prime numbers
3489120	3498240	except the definition maybe you go for x from two through n minus one is n divisible by x
3499360	3506640	and then at the end if you got uh all knows uh for every single one of those questions
3507360	3513120	you know oh it must be a prime number well the first thing is you can stop iterating when you
3513120	3518960	find a yes answer and the second is you can also stop iterating when you had have reached
3520080	3527360	the square root of n because you know that if it has a divisor larger than than the square root
3527360	3534080	did not also have a divisor smaller than the square root then you say oh except for two
3534080	3538800	we don't need to bother with checking for even numbers because all even numbers are divisible
3538800	3544800	by two so if it's divisible by four we would already have come across the question is it
3544800	3550640	divisible by two and so now you go special case check is it divisible by two and then you just
3550640	3558560	check three five seven eleven uh and so now you you sort of reduced your search space by 50% again
3559120	3565360	by skipping all the even numbers it kept for two if you think a bit more about it or you just
3566400	3572080	read in your book about the history of math one of the first algorithms ever written down
3572880	3578480	all you have to do is check is it divisible by any of the previous prime numbers that are
3578480	3585120	smaller than the square root and before you get to a better algorithm than that
3586800	3594240	you have to have several phd's in in discrete math so that's as much as i know
3594240	3599280	so of course that same story applies to a lot of other algorithms string matching is a good example
3600320	3605680	of how to come up with an efficient algorithm and sometimes yeah the more efficient algorithm
3605680	3612480	is not so much more complex than the inefficient one but that's an art and it's not always the case
3612480	3618560	in the general cases the more performant the algorithm the more complex it's going to be
3618560	3625440	there's a there's a kind of trade-off the simpler algorithms are also the ones that people invent
3625440	3632400	first because when you're looking for a solution you look at the simplest way to get there first
3633200	3640400	and so if there is a simple solution even if it's not the best solution not the fastest
3640400	3649360	or the memory most memory efficient or whatever a simple solution and simple is is fairly subjective
3649360	3655280	but mathematicians have also thought about sort of what is a good definition for simple in the
3655280	3665360	case of algorithms but the simpler the simpler solutions tend to be easier to follow for other
3665360	3671680	programmers who haven't made a study of a particular field and when i when i started with python i
3672400	3677680	i was a good programmer in general i knew sort of basic data structures and knew the c-language
3677680	3688320	pretty well but there were many areas where i was only somewhat familiar with the state of the art
3690080	3697760	and so i i picked in many cases the simplest way i could solve a particular sub problem because
3697760	3703360	when you when you're designing and implementing a language you have to like you have many hundreds
3703360	3709280	of little problems to solve and you have to have solutions for every one of them
3710080	3714400	before you can can sort of say i've invented the programming language
3716320	3723840	first of all so c python what kind of things does it do it's an interpreter it takes in this
3723840	3729040	readable language that we talked about that is python what is it supposed to do the interpreter
3729040	3740480	basically it it's sort of a recipe for understanding recipes so instead of a recipe that says bake me
3740480	3751440	a cake we have a recipe for well given the text of a program how do we run that program and and
3751440	3757520	that is sort of the recipe for building a computer the recipe for the baker and the chef yeah what are
3757520	3765760	the algorithmically tricky things that happen to be low hanging fruit that could be improved on
3765760	3772640	maybe throughout the history of python but also now how is it possible that 3.11 in year 2022
3772640	3778000	it's possible to get such a big performance improvement we focused
3778560	3789280	on a few areas where we we still felt there was low hanging fruit the biggest one is actually
3789280	3796240	the interpreter itself and this has to do with details of how python is defined so
3797120	3802240	i don't know if the fisherman is going to follow this story he already he already jumped off the
3802240	3810080	boat he's he's he's he's a board yeah stupid python is actually even though it's always called an
3810080	3816000	interpreted language it's there's also a compiler in there it just doesn't compile to machine code
3816000	3824640	it compiles to bytecode which is sort of code for an imaginary computer that is called the python
3824640	3830880	interpreter so it's compiling code that is more easily digestible by the interpreter or is digestible
3831200	3836080	it is the code that is digested by the interpreter that's the compiler we tweaked
3836080	3842240	very minor bits of the compiler almost all the work was done in the interpreter because
3843760	3849440	when you have a program you compile it once and then you run the code a whole bunch of times
3850320	3855600	or maybe there's one function in the in the code that gets run many times
3856160	3863600	uh now i know that that's sort of people who who know this field are expecting me to at some point
3863600	3870480	say we built a just-in-time compiler actually we didn't we just made the interpreter uh a little
3870480	3878240	more efficient what's a just-in-time compiler that is a thing from the java world although it's
3878240	3885440	now applied to almost all programming languages especially interpreted ones so you see the
3885440	3891120	compiler inside python not like a just-in-time compiler but it's a compiler that creates bytecode
3891120	3897680	that is then fed to the interpreter and the compiler was there something interesting to
3897680	3902000	say about the compiler it's interesting that you haven't changed that tweaked out at all or much
3902000	3910640	we changed some parts of the bytecode but not very much and so we only had to change the parts of
3910640	3916720	the compiler where we decided that the the breakdown of a python program in bytecode instructions had
3916720	3928000	to be slightly different uh but that didn't that didn't gain us the performance uh improvements
3928000	3937600	that performance improvements were like making the interpreter faster in part by sort of removing
3937600	3946400	the fat from some internal data structures used by the interpreter but uh the the key idea is an
3946400	3953600	adaptive specializing interpreter let's go what is adaptive about it what is specialized about it
3953600	3959040	well let me first talk about the specializing part because the adaptive part is the sort of
3960400	3967520	the second order effect but they're both important so bytecode is a bunch of machine
3967520	3974000	instructions but it's an imaginary machine but the machine can do things like call a function
3974960	3981440	add two numbers print a value those are sort of typical instructions in python
3983680	3992240	and if we take the example of adding two numbers actually in python the language there's no such
3992240	3999360	thing as adding two numbers there's just the the compiler uh doesn't know that you're adding two
3999360	4007440	numbers you might as well be adding two strings or two lists uh or two instances of some user-defined
4007440	4014800	class that happen to implement this operator called add that's a very interesting and and
4014800	4020800	fairly powerful mathematical concept it's mostly a user interface trick because it means that
4022560	4029360	a certain category of functions uh can be written using a symbols single symbol the plus sign
4030400	4035840	and sort of a bunch of other functions can be written using another single symbol the multiply
4035920	4045760	sign uh so if we take addition the way traditionally in python the add bytecode was executed is
4048480	4056080	pointers pointers and more pointers so first we we we have two objects an object is basically
4056080	4062080	a pointer to a bunch of memory that contains more pointers pointers all the way down well not quite
4062160	4069600	but there there are a lot of them so to simplify a bit uh we look up in one of the objects
4071280	4077680	what is the type of that object and does that object type define an add operation
4078720	4085920	and so you can imagine that there is a sort of a type integer that knows how to add itself to
4085920	4091920	another integer and there is a type floating point number that knows how to add itself to
4091920	4100080	another floating point number and the integers and floating point numbers are sort of important
4100080	4108480	I think mostly historically because in the first computers uh you used the sort of the same bit
4108480	4113120	pattern when interpreted as a floating point number had a very different value than when
4113120	4118800	interpreted as an integer can ask a dumb question here please do given the basics of int and float
4118800	4127040	and add who carries the knowledge of how to add two integers is it the integer it's the type integer
4127040	4134080	versus it's the type integer and the type float what about the operator is the operator just
4134080	4142400	exist as a platonic form possessed by the integer the operator is more like
4144560	4153600	it's an index in a list of functions that the integer type defines and so the integer type
4155600	4161920	is really a collection of functions and there is an add function and there's a multiply function
4161920	4166960	and there are like 30 other functions for other operations there's a power function for example
4168000	4177680	and you can imagine that in in memory there is a distinct slot for the add operations let's say the
4177680	4183440	add operation is the first operation of a type and the multiply is the second operation of a type
4184080	4187600	so now we take the integer type and we take the floating point type
4188560	4195760	uh in both cases the add operation is the first slot and multiply is the second slot
4196480	4204880	but each slot contains a function and the functions are different because the the add
4204880	4214320	to integers function interprets the bit patterns as integers the add to float function interprets the
4214480	4220320	same bit pattern as as a floating point number and then there is the string
4221360	4230480	data type which again interprets the the bit pattern as the address of a of a sequence of
4230480	4236960	characters there are lots of lies in that story but that's that's that's sort of a basic idea
4236960	4242080	I could tell I could tell the fact the fake news and the fabrication going out here at the table
4242160	4245920	but uh where's the optimization is it on the operators is it different
4246480	4255840	so the optimization is the observation that in a particular line of code
4257200	4264160	so now you you write your little python program and you write a function and that function sort of
4264160	4271840	takes a bunch of inputs and at some point it adds two of the inputs together now I bet you even if
4271840	4280400	you call your function a thousand times that all those calls are likely all going to be about integers
4281120	4288640	because maybe your program is all about integers or maybe on that particular line of code where
4288640	4296800	that there's that plus operator every time the program hits that line the variables a and b
4296800	4304160	that b are being added together happen to be strings and so what we do is instead of having
4304160	4310320	this single byte code that says here's an ad operation and the implementation of ad is fully
4310320	4316240	generic it looks at the object from the object it looks at the type then it takes the type and it
4316240	4322320	looks at looks up the function pointer then it calls the function now the function has to be
4322320	4326400	has to look at the other argument and has to double check that the other argument has the
4326400	4333600	right type and then there's a bunch of error checking before it can actually just go ahead
4333600	4343120	and add the two bit patterns in the right way what we do is every time we execute an ad instruction
4343120	4354880	like that we we keep a little note of in the end after after we hit the code that that did the addition
4355680	4365280	for a particular type what type was it and then after a few times through that code if it's this
4365920	4377440	same type all the time we say oh so this ad operation even though it's the generic ad operation
4377440	4385200	it might as well be the ad integer operation and the ad integer operation is much more efficient
4385200	4392320	because it just says assume that a and b are integers do the addition operation do it right
4392320	4403680	there in line and produce the result and the big lie here is that in python even if you have great
4403680	4409200	evidence that in the past it was always two integers that you were adding at some point in
4409200	4414080	the future that same line of code could still be hit with two floating points or two strings or maybe
4414080	4421360	a string and an integer it's not a great lie that's just the fact of life i didn't account for what
4421440	4428640	should happen in that case in in the way i told the story there is some accounting for and and so
4429520	4437040	what we actually have to do is when we have the ad integer operation we still have to check
4438160	4445440	are the two arguments in fact integers we applied some tricks to make those checks efficient
4446240	4453600	and we know statistically that the outcome is almost always yes they were they are both integers
4455280	4461360	and so we quickly make that check and then we proceed with the the sort of ad integer operation
4461360	4466800	and then there is a fallback mechanism where we say oops one of them wasn't an integer
4467760	4473440	now we're going to pretend that there was just the fully generic ad operation we wasted a few
4473440	4480080	cycles believing it was what was going to be two integers and then we had to back up
4480640	4488800	but we didn't waste that much time and statistically most of the time basically we were we're sort of
4489920	4496320	hoping that most of the time we guess right because if we if it turns out that we guessed wrong too
4496400	4503440	often uh or we didn't have a good guess at all uh things might actually end up running a little
4503440	4511440	slower so someone with armed with this knowledge and a copy of the implementation someone could
4511440	4517440	easily construct a counter example where they say oh i have a program and now it runs five
4517440	4524560	times as slow in python 3 11 than it did in python 3 10 but that's a very unrealistic program that's
4524640	4532880	that's just like an extreme fluke it's a fun reverse engineering task though oh yeah so there's a
4535280	4545280	people like fun yes so there's some presumably heuristic of what defines the momentum of
4545280	4551120	saying you know you seem to be working adding two integers not two generic types uh so
4551840	4558320	how do you figure out that heuristic i think that the heuristic is actually we assume that the
4558320	4562480	weather tomorrow is going to be the same as the weather today so you don't need two days of the
4562480	4571200	weather no that is already so much better than than than guessing randomly that so how do you
4571200	4581600	find this idea hey i wonder if instead of adding two generic types we uh start assuming that the
4581600	4587680	weather tomorrow is the same as the weather today where do you find the idea for that because that
4587680	4593840	ultimately for you to do that you have to kind of understand how people are using the language
4593840	4600160	right python is not the first language to do a thing like this this is a fairly well known trick
4600160	4607840	especially from other interpreted languages that had reason to be sped up we occasionally
4607840	4618560	look at papers about hhvm which is for facebook's efficient compiler for php there are tricks known
4618560	4626160	from the jvm and sometimes it just comes from academia so the trick here is that the type itself
4626160	4632560	doesn't the variable doesn't know what type it is so this is not a statically typed language where you
4632560	4639760	can you can get afford to have a shortcut to saying it's ints this is a trick that is especially
4639760	4648720	important for uh for interpreted languages with dynamic typing because if if the compiler could
4648720	4655520	read in the source these x and y that we're adding are integers the compiler can just
4655520	4661600	insert the single add machine code that hardware machine instruction that exists
4662560	4672160	on every cpu and ditto for floats but because in python you don't generally declare your the
4672160	4677760	types of your variables you you don't even declare the existence of your variables they just spring
4677760	4685040	into existence when you first assign them which is really cool and and sort of helps those beginners
4685040	4690800	because there is less bookkeeping they have to learn how to do before they can start playing
4690800	4698960	around with code but it makes the the interpretation of the code less efficient and so we're we're sort of
4699280	4707840	trying to to make the interpretation more efficient without losing the the super dynamic nature of
4707840	4717440	the language that's always the challenge 3.5 got the pep 484 type hints what is type hinting and
4718080	4725920	is it used by the interpreter the hints or is it just syntactic sugar so the type hints is an optional
4726080	4734320	mechanism that people can use and it's especially popular with sort of larger companies that have
4734320	4739600	very large code bases written in python do you think of it as almost like documentation saying
4739600	4747600	these two variables are this type more than documentation i mean so it it it is a sub language
4747600	4754080	of python where where you can express the types of variables so here's a variable and it's an
4755040	4760880	integer and here's an argument to this function and it's a string and here is a function that
4760880	4767280	returns a list of strings but that's not checked when you run the code but exactly there there is a
4767280	4773120	separate piece of software called a static type checker that reads all your source code without
4773120	4782160	executing it and thinks long and hard about what it looks from just reading the code that code
4782240	4790800	might be doing and double checks if that makes sense if you take the types as annotated into
4790800	4796480	account so this is something you're supposed to run as you develop it's like a linter yeah that's
4796480	4805040	definitely a development tool but the type annotations currently are not used for speeding up the
4805040	4813520	interpreter and there are a number of reasons uh many people don't use them even when they do use them
4814960	4821440	they sometimes contain lies where the static type checker says everything's fine
4822560	4828560	i cannot prove that this integer is ever not an integer but at runtime somehow someone
4829280	4836960	manages to violate that assumption and the interpreter ends up doing just fine if we
4837600	4844000	started enforcing type annotations in python many python programs would no longer work
4845120	4849280	and some python programs wouldn't even be possible because they're too dynamic
4850000	4856320	and so we made we made the choice of not using the annotations there there is a possible future
4856320	4866160	where eventually three four five releases in the future we could start using those annotations to
4866160	4875200	sort of provide hints because we can we can still say well the source code leads us to
4875200	4882080	believe that these x and y are both integers and so we can generate an add an add integer instruction
4883040	4888960	but we can still have a fallback that says oh if the if somehow the code
4889600	4894800	coded runtime provided something else maybe it provided two decimal numbers
4896000	4902320	we can still use that generic add operation as a fallback but we're not there is there currently
4902320	4910080	a mechanism or do you see something like that where you can almost add like an assert inside
4910160	4916880	a function that says please check that my type hints are actually mapping to reality
4916880	4925280	sort of like insert manual static typing there are third party libraries that are in that business
4925280	4930160	it's possible to do that kind of thing it's possible to for a third party library to take a hint
4931280	4936880	and enforce it seems like a tricky thing but what what what we actually do is and this I think
4936880	4943920	this is a fairly unique feature in python the type hints can be introspective at runtime
4944800	4952960	so while the program is running they mean python is a very introspective language you can look at
4952960	4958720	a variable and ask yourself what the what is the type of this this variable and if that maybe
4958720	4964960	that variable happens to refer to a function you can ask what are the arguments to the function
4965680	4970720	and nowadays you can also ask what are the type annotations for the function
4970720	4977040	so the type annotations are there inside the variable as it's at runtime they're mostly associated
4977040	4983760	with the function object not with each individual variable but uh right you can sort of map from
4983760	4988720	from the arguments to the variables and that's what a third party library can help exactly and
4988720	4995440	the problem with that is that all that extra runtime type checking uh is going to slow your
4995440	5002720	code down instead of speed it up I think uh to reference this uh sales pitchy blog post
5003360	5008720	that says 75% of developers time is spent on debugging I would say that in some cases that
5008720	5014400	might be okay it might be okay to pay the cost of performance for the catching of the types
5014480	5023920	the type errors and in most cases doing it statically before you ship your code to production
5024960	5030880	is more efficient than doing it at runtime piecemeal yeah can you tell me about
5032400	5040880	my py my py project what is it what's the mission and in general what is the future
5040880	5050880	of static typing in python well so my py uh was started by a Finnish developer yuka letus hello
5051520	5056480	so many cool things out of Finland I gotta say just that part of the world I guess people have
5056480	5062720	nothing better to do in those long cold winters yeah I don't know I think yuka lived in England
5062720	5070720	when he invented that stuff actually but my py is the original static type checker for python
5070960	5079840	and the the type annotations that were introduced with pet 484 were sort of developed together
5080800	5087200	with the the static type checker and in fact yuka had first invented a different syntax
5087200	5095280	that wasn't quite compatible with python and uh yuka and I sort of met at a python conference
5096000	5107760	in I think in 2013 and we we sort of came up with a compromise syntax that would not require any
5107760	5115840	changes to python and that would let my py sort of be an add-on static type checker for python
5115840	5120400	just out of curiosity was it like double colon or something what was he proposing that would break
5120400	5129200	python I think he was using angular brackets for uh types like in c++ or uh java generics yeah you
5129200	5136800	can't use angular brackets in python it'll be too tricky for temp well we the the key thing is that
5136800	5144160	we already had uh no uh syntax for annotations we just didn't know what to use them for yet
5145120	5152400	so type annotations were just the sort of most logical thing to to use that existing dummy
5152400	5162880	syntax for but there was no there was no syntax for uh defining generics directly syntactically
5162880	5172160	in the language my py literally meant my version of python where my it refers to yuka he had a
5172240	5180960	parser that translated my py into python by like doing the type checks and then
5181680	5188320	removing the annotations and all the angular brackets uh from the positions where where he
5188320	5195520	was using them but a preprocessor model doesn't work very well with the typical workflow of
5195520	5201440	python development projects that's funny I mean that could have been another major split if it
5201440	5209760	became successful like uh if you watch typescript versus javascript is like a split in the community
5209760	5215760	over types right that seems to be stabilizing now it's not necessarily a split there are certainly
5215760	5224960	plenty of people who don't use typescript but just use the original javascript notation just
5224960	5229920	like there are many people in the python world who don't use type annotations and don't use static
5229920	5234960	type checkers now you know but there is a bit of a split between typescript and javas old school
5234960	5242640	javascript es whatever well in the javascript world transpilers are sort of the standard way of
5242640	5249600	working anyway which is why typescript being a transpiler itself is not a big deal and transpilers
5249600	5254800	for people who don't know it's what's the exact thing you said with my py it's the code I guess
5254800	5259360	you call preprocessing code that translates from one language to the other and that's part of the
5259360	5265440	culture part of the workflow of the javascript community so that's right at the same time
5266320	5272000	an interesting development in the javascript slash typescript world at the moment is that
5272960	5280320	there is a proposal under consideration it's only a stage one proposal that proposes to add a feature
5280320	5291280	to javascript where just like python it will ignore certain syntax when running the javascript code
5292080	5299120	and what it ignores is more or less a superset of the typescript annotation syntax
5300720	5307200	interesting so that would mean that eventually if you wanted to you could take typescript
5308080	5314080	and you could shove it directly into a javascript interpreter without
5314080	5319840	translation the interesting thing in the javascript world at least the web browser world
5320560	5328320	the web browsers have changed how they deploy and they they sort of update their javascript engines
5329280	5335600	much more quickly than they used to in the the early days and so there's much less of a need for
5336560	5343920	translation in javascript itself because most browsers just support the most recent version
5343920	5351040	of ECMAScript just an attention of attention do you see if you will recommend somebody use a thing
5351040	5357680	would you recommend typescript or javascript i would recommend typescript just because of the
5357680	5364560	strictness of the typing it's an enormously helpful extra tool that helps you sort of
5366880	5372960	keep your head straight about what your code is actually doing i mean it's it's it
5373680	5381520	it helps with editing your code it helps with ensuring that your code is not too incorrect
5381520	5388720	and it's actually quite compatible with javascript never mind this syntactic
5389360	5396560	sort of hack that is still years in the future but any library that is written in pure javascript
5396560	5403440	can still be used from typescript programs and also the other way around you can write a library
5403440	5411040	in typescript and then export it in a form that is totally consumable by javascript that sort of
5411520	5418960	compatibility is is sort of the key to this to the success of typescript yeah just to look at
5418960	5423040	it it's almost like a biological system that's evolving it's fascinating to see javascript
5423040	5427680	evolve the way it does well maybe we should consider that biological systems are just
5428320	5436480	engineering systems too right yes just very advanced with with more history but it's almost
5436560	5443040	like the most visceral in the javascript world because there's just so much code written in
5443040	5450960	javascript that for its history was messy if you talk about bugs per line of code i just feel like
5450960	5457520	javascript eats the cake or whatever the terminology is it beats python by a lot in terms of the number
5457520	5465040	of bugs meaning like way more bugs in javascript and then and then the obviously the browsers
5465600	5470960	just there's so much active development it feels a lot more like evolution where a bunch of stuff
5470960	5478960	is born and dies and there's experimentation debates versus python there's more all that stuff is
5478960	5485120	happening but there's just a longer history of stable working giant software systems written in
5485120	5493120	python versus javascript is just a giant beautiful i would say mess of code it's very different culture
5493200	5499840	and to some extent differences in culture are random but to some extent they the differences
5499840	5506800	have to do with the environment yeah and the fact that javascript is primarily
5508640	5516880	the language for developing web applications especially the client side and the fact that it's
5517440	5524560	basically the only language for developing web applications makes that community sort of just
5524560	5532080	have a different nature than the community of other languages plus the graphical component
5534000	5539760	and the fact that they're deploying it on all kinds of shapes of screens and devices and all
5539760	5545680	that kind of stuff it just creates a beautiful chaos anyway back to my pie so what okay you
5545760	5550720	met you talked about a syntax that could work where does it currently stand
5551600	5559120	what's the future static typing in python it is still controversial but it is much more accepted
5559120	5566800	than when my pie and pep 484 were were young what's the connection between pep 484 type hints
5566800	5576560	and my pie my pie was the original static type checker so it my pie quickly evolved from yuka's
5577280	5586160	own variant of python to a static type checker for python and sort of pep 484 that that was it like
5587680	5594800	a very productive year where like many hundreds of messages were exchanged debating the merits
5595680	5604640	of every aspect of of that pep and so my pie is a static type checker for python it is itself
5604640	5615040	written in python most additional static typing features that we introduced in the time since 36
5615760	5625200	uh were also prototyped through my pie my pie being an open source project with a very small
5625200	5632400	number of maintainers it was successful enough that people said this static type checking stuff
5632400	5641760	for python is actually worth an investment for our company nice but somehow they chose not to support
5641760	5652960	making my pie faster say or adding new features to my pie but both google and facebook and later
5652960	5660480	microsoft developed their own static type checker i think facebook was one of the first they
5661360	5668640	decided that they wanted to use the same technology that they had successfully used for uh hhvm
5668640	5676640	because they they sort of they had a bunch of compiler writers and and sort of static
5676640	5683760	type checking experts who had written the hhvm compiler and it was a big success within the
5683760	5693200	company and they had done it in a certain way sort of they wrote a big highly parallel application
5693200	5699360	in an obscure language named oh camel which is apparently mostly very good for writing static
5699360	5705760	type checkers interesting i have a lot of questions about how to write a static type
5705760	5711680	checker then that's very confusing facebook wrote their version and they worked on it
5711680	5719440	in secret for about a year and then they came clean and went open source uh google in the meantime
5719440	5727600	was developing something called pie type which was mostly interesting because it as you may have
5727600	5736240	heard they have one gigantic monorepo so all the code is checked into a single repository facebook
5736240	5742400	has a different approach so facebook developed pyre which which was written in oh camel which
5742400	5750880	worked well with facebook's development workflow uh google developed something they called py type
5750880	5758320	which was actually itself written in python uh and it was meant to sort of fit well in
5759600	5766960	their static type checking needs in google's gigantic monorepo so google was in one giant
5767040	5774480	got it so the just to clarify this static type checker philosophically is the thing that's
5774480	5779920	supposed to exist outside of the language itself and it's just a workflow like a debugger for the
5779920	5785440	program it's a linter for people who don't know a linter maybe you can correct me but it's it's a
5785440	5792480	thing that runs through the code continuously preprocessing to find issues based on style
5793200	5798480	documentation i mean there's all kinds of linters right it can check that what usual
5798480	5804960	things does a linter do maybe check that you haven't too many characters in a single line
5805760	5812960	linters often do static analysis where they try to point out things that are likely mistakes but
5812960	5820640	not incorrect according to the language specification like maybe you have a variable that you never use
5821520	5828320	for the compiler that is valid you might sort of you might be planning to use it in a future
5828320	5833680	version of the of the code and the compiler might just optimize it out but the compiler's not going
5833680	5840240	to tell you hey you're never using this variable a linter will tell you that variable is not used
5840240	5846080	maybe there's a typo somewhere else where you're meant to use it but you accidentally use something
5846080	5851280	else or there are a number of sort of common scenarios and a linter is often
5853760	5860880	a big collection of little heuristics where by looking at the combination of how your code is
5860880	5871040	laid out maybe how it's indented maybe the common structure but also just things like definition
5871040	5878400	of names use of names it'll tell you likely things that are wrong and in some cases linters are
5879120	5885040	are really style checkers uh for python there are a number of linters that check things like
5886000	5893680	do you use the the pep8 recommended naming scheme for your functions and classes and variables
5894320	5898480	because like classes start with an uppercase and the rest starts with a lower case and
5899440	5905600	there's like differences there and so the linter can tell you hey you have a class that uh whose
5905600	5912400	first letter is not an uppercase letter and that's just i just find it annoying if i wanted that to
5912400	5918240	be an uppercase letter i i would have typed an uppercase letter but other people find it very
5918240	5923840	comforting that if the linter is no longer complaining about their code that they have
5923920	5929040	followed all the style rules maybe it's a fast way for a new developer joining a team to learn
5929040	5934400	the style rules right yeah there's definitely that but the best use of a linter is probably
5935600	5943360	not so much to to sort of enforce team uniformity but to actually help developers
5944560	5951360	catch bugs that the compilers for whatever reason don't catch and there is lots of that in python
5952000	5960080	and so uh but aesthetic type checker focuses on uh a particular aspect of the linting which
5961120	5965040	i mean it might probably doesn't care how you name your classes and variables
5967440	5973440	but it is meticulous about when you say that there was an integer here and you're passing
5973440	5978720	a string there it will tell you hey that string is not an integer so something's wrong either
5979360	5984800	either you were incorrect when you said it was an integer or you're incorrect when you're passing
5984800	5990240	into string if this is a race of static type checkers there's somebody winning as you said
5990240	5996400	it's interesting that the companies didn't choose to invest in this centralized development
5997200	6004560	of mypi is is is there a future for mypi what do you see is that well one of the companies
6004560	6012960	went out and everybody uses like a py type whatever google's is called well microsoft is hoping that
6013600	6022960	microsoft's horse in that race called py right is going to win py right right like ri ghd correct
6022960	6030880	yeah my my all my word processors tend to type out correct that as py right the name of the i don't
6030880	6040880	know what it is some kind of semi precious metal oh right i love it okay so okay that's the microsoft
6040880	6046560	hope but okay so let me ask the question a different way is there going to be ever a future
6046560	6049600	whereas the static type checker gets integrated into the language
6053200	6060560	nobody is currently excited about doing any work towards that that doesn't mean that five
6060560	6072000	or ten years from now the situation isn't different at the moment all the static type checkers
6074080	6083680	still evolve at a much higher speed than python and its annotation syntax evolve you get a new
6083680	6090880	release of python once a year those are the only times that you can introduce new annotation
6090880	6096800	syntax and there's there are always people who invent new new annotation syntax that they're
6096800	6106560	trying to push uh and worse once we've all agreed that we are going to put some new syntax in we
6106560	6113920	can never take it back at least a sort of deprecating an existing feature takes many releases because
6113920	6119840	you have to assume that people started using it as soon as we announced it and then you can't take
6119840	6126240	it away from them right away you have to start telling them well this will go away but we're not
6126240	6132240	gonna tell you that it's an error yet and then later it's going to be a warning and then eventually
6132320	6139280	three releases in the future maybe we remove it on the other hand the typical static type checker
6140800	6142560	still has a release like
6145120	6152640	every month every two months certainly many times a year uh some type checkers also
6152640	6160720	include a bunch of experimental ideas that aren't official standard python syntax yet
6162320	6169920	the static type checkers also just get better at discovering things that that sort of are
6169920	6176560	unspecified by the language but that sort of could make sense and so each static type checker actually
6176560	6182640	has it's sort of strong and weak points so it's cool it's like a laboratory of experiments yeah
6182640	6187600	microsoft google and all and you get to see and you see that everywhere right because there's not
6187600	6194720	one single uh java script in engine either there is one in chrome there is one in safari there's one
6194720	6201520	in firefox but that said you said there's not interest i think there is a lot of interest in
6201520	6208560	type hinting right uh in the pep 484 actually like how many people use that do you have a sense
6209120	6215680	how many people use because it's optional this is sugar i can't put a number on it but
6216720	6222800	from the number of packages that do interesting things with it at runtime and the fact that there
6222800	6231280	are like now three or four very mature type checkers that each have their their segment
6231280	6236720	of the market and oh and then there is a pie charm which has a sort of more heuristic based
6236720	6245680	type checker that also supports the same syntax my assumption is that many many people developing
6245680	6253840	python software professionally for some kind of production situation are using a static type
6253840	6264240	checker especially any anybody who has a continuous integration cycle probably has uh one of the steps
6264240	6272240	in in there they're testing routine that that happens for basically every every commit uh is
6272240	6277040	run a static type checker and in most in most cases that will be my pie
6279600	6288560	so i think it's pretty popular topic according to this web page 20 to 30 of python three code
6288560	6294800	bases are using type hints wow i wonder how they measured that did they just scan all of github
6295760	6301200	yeah that's what it looks like yeah they did a quick sent not all of but like a random sampling
6302960	6307440	so you mentioned pie charm let me ask you the uh the big subjective question
6309520	6316080	what's the best ide for python and you're extremely biased now that you're with microsoft
6317440	6326960	is it pie charm vs code vim or emacs historically i actually started out with using vim but when
6326960	6338720	it was still called vi uh for a very long time i think from the early 80s to uh i'd say two years ago
6339920	6354400	i was emacs user nice between i'd say 2013 and 2018 i dabbled with pie charm uh mostly because it had
6355360	6364960	had a couple of features i mean pie charm is like driving an 18-wheeler truck whereas emacs is more
6367200	6375680	like driving your comfortable Toyota car that's that's that you've had for 100,000 miles and you
6375680	6382160	know what every little rattle of the car means i was very comfortable in emacs but there were
6382160	6388800	certain things it couldn't do it wasn't very good at that sort of at least the way i had configured it
6390800	6395200	i didn't have very good tooling in emacs for finding the definition of a function
6396640	6403360	got it when i was at Dropbox exploring a five million line python code base
6404560	6411680	uh just grabbing all that code for where there where is there a class foobar well turns out that
6411680	6416400	if you grab all five million lines of code there are many classes with the same name
6417920	6425360	and so pie charm sort of once once you fired it up and once it's indexed your repository
6426560	6433200	was very helpful but the soonest i had to edit code i would jump back to emacs and do all my
6433200	6439680	editing there because i could type much faster and switch between files when i when i knew which
6439680	6446080	file i wanted much much quicker and i never really got used to the the whole pie charm user interface
6446800	6452240	yeah i feel torn in that same kind of way because i've used pie charm off and on exactly in that
6452240	6459280	same way and i feel like i'm just being an old grumpy man for not learning how to quickly
6459280	6462720	switch between files and all that kind of stuff i feel like that has to do with shortcuts that has
6462720	6467680	to do with um i mean you just have to get accustomed just like with touch typing yeah you have to just
6467680	6473520	want to to learn that i mean if you don't need it much you don't need touch typing either you can
6473520	6479280	type with two fingers just fine in the short term but in the long term your life will become better
6479840	6485440	psychologically and productivity wise if you learn how to type with 10 fingers if you do a lot of
6485440	6492720	keyboard input before everyone emails and stuff right like you look at the the next 20 30 years of
6492720	6499040	your life you have to anticipate where technology is going um do you want to invest in handwriting
6499040	6505520	notes probably not more and more people are doing typing versus handwriting notes so you can anticipate
6505520	6510400	that so there's no reason to actually practice handwriting there's more reason to practice typing
6511440	6518160	you can actually estimate back to the spreadsheet the number of paragraphs sentences or words you'll
6518160	6527120	write for the rest of your life you can probably go again with the spreadsheet of my life i mean
6527120	6531600	all of that is not actual like converted to a spreadsheet but the gut feeling
6531600	6536720	like i have the same kind of gut feeling about books i've almost exclusively switched to kindle
6536720	6544080	now for ebook readers even though i still love and probably always will the smell the feel of a
6544080	6551440	physical book and you the reason i switched to kindle is like all right well this is really paving
6552160	6558880	the future is going to be digital in terms of consuming books and content of that nature so
6558880	6564240	you should get you know you should let your brain get accustomed to that experience and that same
6564240	6571600	way it feels like pie charm or vs code i think pie charm is is the most sort of sophisticated
6571600	6580000	feature full uh python id it feels like i should probably at some point very soon switch entire
6580000	6585760	like i'm not allowed to use anything else for python than this id or vs code it doesn't matter
6585760	6590560	but walk away from emacs for this particular application because i think i'm limiting myself
6591120	6596640	in the same way that using two fingers for typing is limiting myself it's i'm this is a therapy
6596640	6603440	session this is i'm not even but i'm sure a lot of people are thinking i'm not gonna stop you uh i
6604640	6610720	i think that that's sort of everybody has to decide for themselves which one they want to
6610720	6621440	invest more time in i actually ended up giving vs code a very tentative try when i started out at
6621440	6629920	microsoft and really liking it and it sort of it took me a while before i realized why that was
6630880	6637520	but and and i think that actually the founders of vs code may not necessarily agree with me on this
6638640	6649760	but to me vs code is in a sense the spiritual successor of emacs because as you probably know
6649760	6659200	as an old emacs hack the the key part of emacs is that it it's mostly written in in lisp and
6659200	6667120	that that's sort of new features of of emacs usually update all the list packages and add new
6667120	6675040	list packages and oh yeah there's also some very obscure thing improved in the part that's not in
6675040	6683440	lisp but that's usually not why you would upgrade to a new version of emacs there's a core implementation
6684480	6691760	that that sort of can read a file and it can put bits on the screen and it can sort of manage
6691760	6699040	memory and buffers and then what makes it an editor full of features is all the list packages
6699680	6706240	and of course the design of how the list packages interact with each other and with that that sort
6706240	6714960	of that base layer of the core immutable engine but almost everything in that core engine in emacs
6714960	6726800	case can still be overridden or replaced and so vs code has a similar architecture where there is
6726800	6736000	like a base engine that you have no control over i mean it's open source but nobody
6737040	6747280	except the people who work on that part changes it much and it has a sort of a package manager
6748240	6756080	and a whole series of interfaces for packages and an additional series of conventions for how
6756080	6763280	packages should interact with the lower layers and with each other and powerful primitive operations
6763280	6771760	that let you move the cursor around or select pieces of text or delete pieces of text or
6772720	6776640	interact with the keyboard and the mouse and whatever peripherals you have
6776880	6785040	and and so the sort of the the extreme extensibility and the package ecosystem
6785760	6793440	that you that you see in vs code is a mirror of very similar architectural features in emacs
6794240	6800640	well i'll have to give it a serious try because as far as sort of the hype and the excitement
6800640	6805360	in the general programming community vs code seems to dominate the interesting thing about
6806320	6814480	our pie charm and what is it php storm which are these jetbrains specific ids that are designed
6814480	6821840	for one programming language it's interesting to when an ids are specialized right they're usually
6822720	6829840	actually just specializations of intelligent because underneath it's all the same editing
6829840	6843280	engine with different veneer on top where in vs code many things you do require loading
6843280	6850000	third-party extensions in pie charm it is possible to have third-party extensions
6850640	6857360	but it is it is a struggle to create one yes it's not part of the culture all that kind of stuff
6857440	6863840	yeah we that i remember that might have been five years ago or so we were trying to get
6863840	6870720	some better my pie integration into pie charm because my pie is sort of python tooling and pie
6870720	6881120	charm had had its own type checking heuristic thing that we wanted to replace with uh something
6881120	6887360	based on my pie because that was what we were using in the company and it for the for the guy
6887360	6895440	who was writing that by charm extension it was really a struggle to to sort of find documentation
6895440	6903440	and get the development workflow going and and debug his code and all that so that that was
6903440	6910160	was not a pleasant experience let me talk to you about parallelism in your post titled
6910240	6916240	reasoning about asyncio semaphore you talk about a fast food restaurant in silicon valley that
6916240	6920720	has only one table is this a real thing i just wanted to ask you about that is that just like a
6920720	6925680	metaphor you're using or is that an actual restaurant in silicon valley it was it was a
6925680	6931920	metaphor of course okay i can imagine such a restaurant so for people who don't then read the
6931920	6939280	thing you should you should but it was a idea of a restaurant where there's only one table and you
6939280	6945200	show up one at a time and they are prepared and actually looked it up and there is restaurants
6945200	6951600	like this throughout the world and it just seems like a fascinating idea you stand in line you show
6951600	6958080	up there's one table they um they ask you all kinds of questions they cook just for you that's
6958080	6964240	fascinating it sounds like you'd find places like that in tokyo it sounds like a very japanese thing
6964240	6968640	or in the bay area there are pop of places that probably more or less work like that but i've
6968640	6974240	never eaten at such a place the fascinating thing is you propose is a fast food this is all for burger
6974240	6983280	it was one of my rare sort of more literary or poetic moments where i thought i'll i'll just open
6983280	6990640	with a crazy example to catch your attention and the rest is very dry stuff about uh locks and
6990640	6996400	semaphores and how a semaphore is a generalization of a lock well it was very poetic and well
6996400	7001280	delivered and it actually made me wonder if it's real or not because you don't make that explicit
7001280	7005920	and it feels like it could be true and in fact i wouldn't be surprised if somebody like
7005920	7011360	listens to this and knows exactly a restaurant like this in silicone valley anyway can we step back
7011360	7018720	and can you just talk about parallelism concurrency threading asynchronous all these different terms
7019520	7024960	what is it sort of a high philosophical level the uh the fisherman is back in the boat well
7024960	7033360	the idea is if the fisherman has uh two fishing rods uh since fishing is mostly a matter of waiting
7033360	7039280	for a fish to nibble well it depends on how you do it actually but if you had to if if you're doing
7039280	7045360	the style of fishing where you sort of you you throw it out and then you let it sit for a while
7045360	7053040	until maybe you see a nibble one fisherman can easily run two or three or four fishing rods and
7053040	7059840	so as long as you can afford the equipment you can catch four times as many fish by a small
7059840	7066080	investment in four fishing rods and so you since your time you sort of say you have all saturday
7066080	7072800	to go fishing if you can catch four times as much fish you have a much higher productivity
7072800	7076960	and that's actually i think how deep sea fishing is done you could just have a rod and you put in
7076960	7083440	a hole so you can have many rods uh what is there an interesting difference between parallelism and
7083440	7089920	concurrency and asynchronous is there one that's upset of the other to you like how do you think
7089920	7096400	about these terms in the computer world there is a big difference when people are talking about
7096960	7107840	parallelism like a parallel computer that's usually really several complete cpus that are
7107840	7119120	sort of tied together and and share something like memory or an iobus concurrency can be a much
7119120	7129120	more abstract concept where you have the illusion that things happen simultaneously but what the
7129120	7135920	computer actually does is it spends a little time running some this program for a while and
7135920	7140720	then it spends some time running that program for a while and then spending some time for the third
7140800	7148000	program for a while so parallelism is the reality and concurrency is part reality part
7148000	7154640	illusion yeah parallelism typically implies that there is multiple copies of the hardware
7155760	7160880	you write that implementing synchronization primitives is hard in that blog post and you
7160880	7167600	talk about locks and semaphores why is it hard to implement synchronization primitives because
7168160	7177120	at the conscious level our brains are not trained to to sort of keep track of multiple things
7177120	7184400	at the same time like obviously you can walk and chew gum at the same time because they're both
7185200	7192400	activities that require only a little bit of your conscious activity but try balancing your
7192400	7200480	checkbook and watching a murder mystery on tv yeah you'll mix up the digits or you'll miss
7200480	7206000	an essential clue on in the tv show so why does it matter that the programmer the human
7207280	7213760	is uh is bad because the programmer is at least with the current state of the art is responsible
7213760	7223600	for writing the code correctly and it's hard enough to keep track of a recipe that you just
7224720	7234400	execute one step at a time chop the carrots then peel the potatoes mix the icing you need your
7234400	7241440	whole brain when you're when you're reading a piece of code what what is going on okay we're
7241440	7248640	we're we're loading the number of mermaids in variable a and the number of mere men in variable
7248640	7255920	b and uh now we take the average or whatever uh i like we're just jumping from metaphor to metaphor
7255920	7262800	i like it you have to keep in your head what is in a what is in b what is in c uh hopefully you
7262880	7272960	have better names and that is challenging enough if you have two different pieces of code that are
7273520	7281120	are sort of being executed simultaneously whether it's using the parallel or the concurrent
7282000	7291760	approach if like a is the number of fishermen and b is the number of programmers but in another
7291760	7297600	part of the code a is the number of mermaids and b is the number of merman and somehow
7298640	7304160	that's the same variable if you do it sequentially if first you do your mermaids more people
7304160	7310400	computation and then you do your people in the boat computation it doesn't matter that the variables
7310400	7316160	are called a and b and that is literally the same variable because you you're done with one use of
7316160	7323200	that variable but when you mix them together suddenly the number of mere people replaces the
7323200	7329760	number of fishermen and your computation goes dramatically wrong and there's all kinds of ordering
7330880	7335600	of operations that could result in the assignment of those variables and so you have to anticipate
7335600	7342880	all possible orderings and you think you're smart and you'll put a look around it and in practice
7343440	7350720	in terms of bugs per line per thousand lines of code this is an area where everything is worse
7350720	7359760	so a lock is a mechanism by which you forbid only one chef can access the oven at a time
7360960	7367200	something like that and then semaphores allow you to do what multiple ovens that's not a bad
7367200	7373520	idea because if you're sort of if you're preparing if you're baking cakes and you have multiple people
7373520	7379520	all baking cakes but there's only one oven then maybe you can tell that the oven is in use but
7379520	7385440	maybe it's preheating and so you have to maybe maybe you make a sign that says oven in use
7387200	7391600	and you flip the sign over and it says oven is free when you're done baking your cake
7392080	7399280	and that's a lock that's sort of and and what do you do when you have two ovens or maybe you
7399280	7405760	have 10 ovens you you can put a separate sign on each oven or maybe you can sort of someone who
7405760	7412640	comes in wants to see at a glance and maybe there's an electronic sign that says there's
7412640	7421440	still five ovens available or maybe there are already three people waiting for an oven so you
7421440	7428240	can if you see an oven that's not in use it's already reserved for someone else who got in line
7428240	7433040	first and that's sort of what what what the restaurant metaphor was trying to explain
7433680	7440320	yeah and so you're now tasked you're sitting as a designer of python with a team of brilliant
7440320	7444960	core developers and you have to try to figure out to what degree can any of these ideas be
7444960	7452880	integrated and not so maybe this is a good time to ask what is a sync i o and how has it evolved
7452880	7461600	since python 3.4 wow yeah so we had this really old library for for doing things
7462320	7470560	concurrently especially things that had to do with i o and uh networking i o was especially
7470560	7482800	uh a sort of a popular topic and in the python standard library we had a brief period where
7482800	7490000	there was lots of development and i think it was late 90s maybe early 2000s and like
7491600	7497120	two little modules were added that were the state of the art of doing a synchronous i o or
7497120	7503200	sort of non-blocking a i o which means that you can keep multiple network connections open and
7503200	7509280	sort of service them all in parallel like a typical web server does so i o is input and
7509280	7515120	outputs you're writing either to the network yes the network connection or reading and writing to
7515200	7522000	hard drive the storage also possible and you can do uh the ideas you could do to multiple
7522000	7528800	while also doing computation so running some code that does some fancy stuff yeah like when
7528800	7536000	you're writing a web server when a request comes in a user the sort of needs to see a particular
7536000	7542640	web page uh you have to find that page maybe in the database and format it properly and send it
7542640	7548800	back to the client and there's a lot of waiting waiting for the database waiting for the network
7548800	7555680	and so you can handle hundreds or thousands or millions of requests concurrently on one machine
7555680	7564160	anyway waste of doing that in python were kind of stagnated and uh i forget it might have been around
7564160	7576080	2012 2014 uh when someone for the umpteenth time actually said these async chat and async core
7576080	7581840	modules that you have in the standard library are not quite enough to solve my particular problem
7582720	7589680	can we add one tiny little feature and everybody said no that stuff is not too but you're not
7589680	7595280	supposed to use that stuff write your own using uh third party library and then everybody started
7595280	7604320	the debate about what the right third party library was and somehow i i felt that there was
7604320	7613120	actually a queue for well maybe we need a better state of the art module in the standard library
7613120	7619200	for for multiplexing input output from different sources you could say that it spiraled out of
7619280	7625280	control a little bit it was at the time it was the largest python enhancement proposal that was
7625280	7631440	ever proposed and you were deeply involved with that at the time i was very much involved with
7631440	7640400	that i was like the lead architect uh i ended up talking to people who had already developed
7640400	7646960	serious third party libraries that did similar things and sort of taking ideas from them and
7647920	7654880	getting their feedback on my design and eventually we put it in the standard library and after a few
7654880	7660400	years i got distracted i think the thing the big thing that distracted me was actually type annotations
7661680	7668080	uh but other people kept it alive and kicking and it's been quite successful actually uh
7669040	7674640	in the world of python web clients so initially what are some of the design challenges there
7674640	7679120	in that debate for the pep and what are some things that got rejected what are some things that
7679120	7687040	got accepted to stand out to you there are a couple of different ways you can handle parallel i o and
7687040	7693200	this happens sort of at an architectural level in operating systems as well like windows prefers
7693200	7700400	to do it one way and unix prefers to do it the other way you sort of you have an object that
7700400	7709520	represents a network endpoint say a connection with a web browser that your client and say you're
7709520	7717200	you're waiting for an incoming request two fundamental approaches are okay i'm waiting
7717200	7722720	for an incoming request i'm doing something else come wake me up or of course sort of come tell me
7722720	7727440	when uh something interesting happened like a packet came in on that network connection
7728320	7738560	and the other paradigm is we're on a team of a whole bunch of people with maybe a little mind
7738560	7748640	and we we can only manage one web connection at a time so i'm just sitting looking at this
7748720	7756560	this web connection and i'm just blocked until something comes in and then uh i'm already waiting
7756560	7763840	for it uh i get i get the data i process the data and then i go back to the top and say no
7764560	7771760	sort of i'm waiting for the next packet those are about the two paradigms one is a paradigm
7771760	7777520	where there is sort of notionally a threat of control whether it's an actual operating system
7777520	7784800	thread or more an abstraction in asyncio we call them tasks but a task in asyncio or a
7784800	7793520	thread in other contexts is devoted to one thing and it has logic for all the stages like when it's
7793520	7800640	a web request like first wait wait for the first line of the web request parse it because then you
7800640	7808880	know if it's a get or a post or a put or whatever or an error then wait until you have a bunch of
7808880	7815360	lines until there's a blank line then parse that as headers and then interpret that and then wait
7815360	7821920	for the rest of the data to come in if there is any more that you request expect that sort of
7821920	7829120	standard web stuff and the other thing is and there's always endless debate about which approach
7829120	7836080	is more efficient and which approach is more error prone where i just have a whole bunch of stacks in
7836080	7844080	front of me and whenever a packet comes in i sort of look at the number of the pack that there's
7844080	7851200	some number on the packet and i say oh that packet goes on this pile and then i can do a little bit
7851200	7858160	and then sort of that pile provides my context and as soon as i'm done with with the processing i sort
7858160	7864400	of i can forget everything about what's going on because the next packet will come in from some
7864400	7871200	random other client and it's that pile or this pile uh and every time a pile is maybe empty or
7871200	7878640	full or whatever the criteria is i can toss it away or use it for a new space but several
7878640	7885680	traditional third party libraries for asynchronous i o processing in python chose the model of a
7885680	7892240	callback and that's that's the idea where you have a bunch of different stacks of paper in front of
7892240	7898160	you and every time someone gives you a piece gives you a new sheet you decide which stack it belongs
7898160	7910480	to and that leads to a certain style of spaghetti code that i find sort of aesthetically not pleasing
7910480	7917120	and i i was sort of never very successful and i had heard many stories about people who were also
7918640	7925680	sort of complaining about that style of coding uh it was very prevalent in javascript at the time
7925680	7933920	at least because it was like how the javascript event loop basically works and so i thought well
7933920	7941920	the task based model where each task has a bunch of logic we had mechanisms in the python language
7941920	7949360	that we could easily reuse for for that and i thought i want to build a whole library for
7949360	7956560	asynchronous networking i o uh and all the other things that may need to be done asynchronously
7957520	7965040	uh based on that paradigm and so i just chose a paradigm and try to see how far i could get
7965040	7970400	with that and it turns out that it's pretty good paradigm so people enjoy that kind of
7970400	7979840	paradigm programming for asynchronous i o relative to callbacks okay beautiful so how does that all
7979840	7987760	interplay with the infamous gill the goal the global interpreter lock maybe can you say what
7987760	7994800	the gill is and how does it dance beautifully with asynchio the global interpreter lock
7996240	8002320	solves the problem that python originally was not written with either asynchronous or or
8002880	8007200	parallelism in mind at all there was no concurrency in the language there was no
8007200	8014960	parallelism there were no threads only a small number of years into python's initial development
8015920	8023600	all the new cool operating systems like uh suno s and silicon graphics iris and then
8024240	8031760	eventually posix and windows all came with threading libraries that lets you do multiple
8031760	8039680	things in parallel and there is a certain certain sort of principle which is the operating system
8039680	8049920	handles the threads for you and the program can pretend that there are as many cpus as as there
8049920	8059360	are threads in the program and those cpus were completely independently and if you don't have
8059360	8066480	enough cpus the operating system sort of simulates those extra cpus on the other hand if you have
8066480	8075360	enough cpus you can get a lot of work done by deploying those multiple cpus but python wasn't
8075440	8081360	written to to do that and so
8083920	8092720	as libraries for for multi-threading were added to c but every operating system vendor was adding
8092720	8100080	their own version of that we thought and maybe we were wrong but at the time we thought well we
8100080	8106560	quickly want to be able to support these multiple threads because they seemed at the time in the
8106560	8113120	early 90s when they were new at least to me they seemed a cool interesting programming paradigm
8113760	8120240	and one of the things that that python at least at the time felt was nice about the language was
8120240	8129520	that we could give a safe version of all kinds of cool new operating system toys to the python
8129520	8138640	programmer like i remember one or two years before threading i i had spent some time adding
8138640	8146880	networking sockets to python and they were very literal translation of the networking sockets
8146880	8153920	that were in the bsd operating system so unix bsd but the nice thing was if you were using sockets
8153920	8160480	from python then all the things you can do wrong with sockets in c would automatically give you a
8160480	8166800	clear error message instead of just ending up with a malfunctioning hanging program and so we
8166800	8174640	thought well we'll do the same thing with threading but we didn't really want to rewrite the interpreter
8175600	8184080	to be thread safe because that that was was like that would be a very complex refactoring of all
8184080	8189600	the interpreter code and all the runtime code because all the objects were written with the
8189600	8196960	assumption that there's only one thread and so we said okay well we'll take our losses we'll provide
8196960	8203200	something that looks like threads and as long as you only have a single cpu on your computer
8203200	8208880	which most computers at the time did uh it feels just like threads because
8210640	8216560	the the whole idea of of multiple threads in the os was that even if your your computer only had
8216560	8223200	one cpu you could still fire up at many threads as you wanted well within reason maybe 10 or 12
8223200	8234720	not 5 000 and so we thought we had conquered the the abstraction of threads pretty well because
8234720	8244480	multi-core cpus were were not in in most python programmers hands anyway and then of course a
8244480	8250480	couple of more iterations of morse law and computers getting faster and at some point
8250720	8259280	uh the chip designers decided that they couldn't make the cpus faster but they could still make
8259280	8265920	them smaller and so they could put multiple cpus on one chip and suddenly there was all this pressure
8266560	8273520	about do things in parallel and that's where the the solution we had in python didn't work
8274160	8282000	and that's that's sort of the moment that the gill became became infamous because the gill the gill
8282000	8290080	was the solution we used to sort of take this single interpreter and share it between all the
8290080	8296960	different operating system threads that you could create and so as long as the the hardware
8297040	8304960	hardware physically only had one cpu that was all fine and then as hardware vendors were suddenly
8304960	8312480	telling us all oh you got to paralyze everything's got to be paralyzed people started saying oh uh
8312480	8319200	but we can use multiple threads in python and uh then they discovered oh but actually all threads
8319200	8326640	run on a single me a single core yeah i mean is there a way is there ideas in the future to remove
8327360	8336080	the global interpreter law gill like maybe multiple sub interpreters some tricky interpreters on top of
8336080	8342960	interpreters kind of thing yeah there there are a couple of possible uh futures there the
8343920	8351680	the most likely future is that we'll get multiple sub interpreters which each run a completely
8351680	8362080	independent python program nice but there there's still some benefit of of sort of faster communication
8362080	8369680	between those programs but it's also managing for you this running a multiple python programs
8370480	8376560	like yeah so it's hidden from you right the it's it's hidden from you but you have to spend more
8376560	8384400	time communicating between those programs because the sort of the attractive thing about the multi
8384400	8391280	threaded model is that the threads can share objects at the same time that's also the downfall
8391280	8398560	of the multi-threaded programming model because when you do share objects you weren't and you
8398560	8407120	didn't necessarily intend to share them or there were aspects of those objects that that were not
8407120	8415840	reusable you get all kinds of concurrency bugs and so the reason i wrote that little blog post
8415840	8424800	about semaphors was that concurrency bugs are just harder it would be nice if python had no
8424800	8428240	globally interpreter lock and it had the so-called free threading
8430080	8438480	but it would also cause a lot more software bugs the interesting thing is that there is still a
8438480	8445280	possible future where we are actually going to or where we could experiment at least with that
8446240	8456960	because there is a guy working for facebook who has developed a fork of c python that he called
8456960	8465040	the no gill interpreter where he removed the gill and made a whole bunch of optimizations
8465040	8472560	so that the single threaded case doesn't run too much slower and multi-threaded case will actually
8473520	8475360	use all the cores that you have
8477600	8485680	and so that that would be an interesting possibility if we would be willing as
8486960	8496880	python core developers to actually maintain that code indefinitely and if we're willing to put up
8496880	8504240	with the additional complexity of the interpreter and the additional sort of overhead for the single
8504240	8517600	threaded case and i'm personally not convinced that there are enough people needing the speed of
8517600	8526480	multiple threads with their python programs that it's worth to sort of take that performance
8526480	8532800	hit and that complexity hit and i i feel that the gill actually is a pretty nice
8533840	8541760	goldilocks point between no threads and all threads all the time but not everybody agrees on that
8541760	8548160	so that is definitely a possible future the sub interpreters look like a fairly safe bet for
8548160	8554800	312 so say a year from now a year so the goal is to do a new version every year
8555600	8561600	for python let me ask you perhaps a fun question but there's a philosophy to
8562320	8569840	will there ever be a python 4.0 now before you say it's currently a joke and probably not
8569840	8578960	we're going to go to 3.99 or 3.99999 can you imagine possible features
8579440	8590480	that python 4.0 might have that would necessitate the creation of the new 4.0 given the amount of
8591440	8599040	pain and joy suffering and triumph that was involved in the move between version 2 and version 3
8599120	8611600	yeah well we're we as a community and as a core development team we have a large amount of
8612320	8620880	painful memories about the python 3.0 transition which is one reason that sort of
8621840	8627680	everybody is happy that we've decided there's not going to be a 4.0 at least
8628560	8635360	not anytime soon and if there is going to be one it will sort of plan the transition very
8635360	8643200	differently because clearly we underestimated the pain that transition caused for our users
8643200	8653360	in the python 3.0 case and had we known we could have sort of designed python 3.0 somewhat
8653360	8660480	differently without making it any worse we just thought that we had a good plan but we
8661440	8667920	underestimated where what what sort of the users were capable of when it comes to that kind of
8667920	8676240	transition by the way i think we talked way before like a year and a half before the python 2
8676240	8683520	officially end of life end of life oh yeah what was that what was your memory of the end of life
8683520	8690160	did you shed a tear on january 1st 2020 that was there everyone standing alone the core team had
8690160	8697680	basically moved on years before yeah it was it was purely it was a little symbolic moment
8699680	8703840	to signal to the the remaining users that
8706240	8712560	there was no longer going to be any new releases or support for python 2.7
8713200	8717680	did you shed a single tear while looking out over the horizon
8718880	8724160	i'm not not a very poetic person and i don't shed tears like that but no
8726640	8732960	now we we actually had planned a party but the party was planned for the python con the
8732960	8738000	us python conference that year which would never happened of course because of the pandemic
8738000	8744480	oh is it like a march yeah the conference was uh going to be i think late april that year
8745920	8749200	so that that was a very difficult decision to cancel it but
8751120	8756640	they did so anyway if we're going to have a python 4 we're going to have to have both a
8756640	8764000	different reason for for having that and a different process for managing the transition
8764000	8771360	can you imagine a possible process that so so i think you're implying that if there is a 4.0 in
8771360	8780640	some ways it would break back compatibility well so here is here is a concrete thought i've had
8780640	8786080	and i'm not unique but not everyone agrees with this so this is definitely a personal opinion
8786240	8798000	if we were to try something like that no gill python uh my expectation is that
8799840	8809760	it would feel just different enough at least for the the part of the python ecosystem that
8810720	8819200	is heavily based on c extensions and that is like the entire machine learning data science
8819200	8830880	scientific python world is all based on c extensions for python and so those people would likely
8830960	8841200	feel the pain the most because they even if we don't change anything about the syntax of the
8841200	8846640	language and the semantics of the language when you're writing python code we we could even say
8846640	8855520	suppose that after python say 319 instead of 320 we'll have 4.0 suppose that's the time when we
8856480	8866320	flip the switch to 4.0 will will not have a gill imagine it was like that so i would probably
8866320	8876400	say that particular year the release that we named 4.0 will be syntactically it will not have any
8876400	8882960	new syntactical features no new modules in the standard library no new built-in functions
8883280	8893200	everything will be at the python level will be purely compatible with python 3.19 however
8894800	8902400	extension modules will have to make a change they will have to be recompiled they will not
8902480	8916000	have the same binary interface the semantics and and apis for for some things that are
8916000	8923120	frequently accessed by c extensions will be different and so for a pure python user
8924160	8930640	4.0 would be a breeze except that there are very few pure python users left because
8930640	8936880	everybody who is using python for something significant is using third-party extensions
8936880	8943280	there are like i don't know several hundreds of thousands of third-party extensions on the
8943280	8951280	pypi service and i'm not saying they're all they're all good but there is a large list of
8951280	8958320	extensions that would have to do work and some of those extensions are currently already low on
8958400	8966560	maintainers and they're struggling to keep afloat so there you can give a huge heads up to them
8966560	8972560	if you go to 4.0 to really keep developing it yeah we probably have to do something like
8974960	8981280	several years before who knows maybe five years earlier like 3.15 we would have to say
8982080	8987200	and and i'm just making that the specific numbers up but we at some point we'd have to say
8989520	8994960	the nogil python could be an option it might be a compile time option
8997200	9004320	if you want to use nogil python you have to recompile python from source for your platform
9004320	9010800	using your tool set all you have to do is change one configuration variable and then you just run
9010800	9019280	make or configure and make and it will build it for you but now you also have to use the
9019280	9026640	the nogil compatible versions of all extension modules you want to use and so as long as many
9026640	9034960	extension modules don't have fully functional sort of variants that work in the nogil world
9035920	9042720	that's not a very practical thing for python users but it would allow extension developers
9043920	9051360	to test the waters see what they need to syntactically to be able to compile at all maybe
9051360	9058400	they're using functions that are defined by the python 3 runtime that won't be in the python 4
9058400	9062720	runtime those functions will not work they'll have to find an alternative
9064320	9070240	but they can experiment with that and sort of write test applications and that would be a way
9070240	9079600	to transition and that that could be a series of releases where that python 4 is more and more imminent
9080560	9088480	we have supported more and more third-party extension modules to have solid support that
9088480	9100080	works for nogil python for that new api and then sort of python python 4.0 is like the official
9100080	9107600	moment that the mayor comes out and cuts the ribbon and now python now the sort of nogil mode
9107680	9113840	is the default and maybe the only mode there is the internet wants to know from reddit
9117040	9120080	it's uh it's a small and fun question there's many fun questions but
9121680	9129600	out of the pypy packages pypi packages do you have a do you have ones you like do you in your
9129600	9136400	opinion are there must have pypy libraries or ones you use all the time constantly oh my that
9138000	9143120	i should really have a standard answer for that question but like a positive standard
9143120	9149200	answer but my current standard answer is that i'm not a big user of third-party packages
9150080	9156720	when i write python code i'm usually developing some tooling around building python itself
9158640	9165120	and uh the last thing we want is dependencies on third-party packages so i i tend to just
9165120	9168880	use the standard library and that's where your focus is that's where your mind is
9170240	9176240	but do you do you keep an eye of what's out there to understand where the standard library
9176240	9182080	could be moving should be moving it's a good kind of landscape of what's missing from the standard
9182080	9191280	library well usually when something's missing from the standard library nowadays uh it is a
9191280	9200560	relatively new idea and there is a third-party implementation or maybe possibly multiple third
9200560	9207120	party implementations but they evolve at a much higher rate than they could when they're in the
9207120	9217120	standard library so they it would be a big reduction in in activity to incorporate things like that
9217120	9222640	in the standard library so i i like that there is a lively package ecosystem and that sort of
9223280	9227920	recent trends in the standard library are actually that we're doing the occasional
9227920	9239840	spring cleaning where we're just we're we're choosing some modules that have not had a lot of
9239840	9248880	change in a long time and that maybe would be better off not existing at all at this point
9248880	9254880	because there might be a better third-party alternative anyway and we're we're sort of
9254880	9262640	slowly removing those that like often those are things that i sort of i spiked somewhere in 1992
9262640	9272160	or 1993 and if you look look through the commit history it's very sad like all cosmetic changes
9272160	9279040	like changes in the indentation style or the name of this other standard library module got changed
9279040	9286000	or nothing nothing of any substance the api is identical to what it was 20 years ago
9286960	9294480	so speaking of packages they have a a lot of impact on a lot of people's lives does it make
9294480	9300000	sense to you why python has become the primary the dominant language for the machine learning
9300000	9306640	community so packages like pie torch tensorflow second learn and even like the lower level
9306640	9313200	stuff like non-pi sci-pi pandas matplot lib with visualization can you like does it make sense to
9313200	9323120	you why it uh permeated the entire data science machine learning ai community well it's part of
9323120	9329040	it is an effect that's as simple as we're all driving on the right side of the road right
9329200	9337840	uh it's compatibility yeah it's it's and and and part of it is uh
9339680	9345440	not not quite as as as fundamental as driving on the right side of the road which you have to do
9345440	9351440	for for safety reasons i mean you have to agree on something every they could have picked javascript
9351440	9356640	or pearl there was there was a time in the early 2000s that it really looked like pearl what was
9357200	9363680	going to dominate like biosciences because dna search was all based on regular expressions
9363680	9370240	and pearl has the fastest and most comprehensive regular expression engine still does i spent
9370240	9376720	quite a long time with pearl that was another letting go letting go of this kind of uh data
9376720	9387520	processing uh system the reasons why python became the lingua franca of the scientific code and and
9389760	9397040	machine learning in particular and data science it really had a lot to do with
9398320	9406000	anything was better than c or c plus plus recently a guy who worked at lauren's livermore
9406000	9415840	national laboratories in the the sort of computing division wrote me his his his memoirs and and he
9415840	9424480	had his his own view of how he helped something he called computational steering into existence
9426240	9432560	and this was the idea that you you take libraries that in in his days were written in fortran
9433120	9436800	that that solved universal mathematical problems
9439200	9444640	and those libraries still work but uh the scientists that use the libraries
9445680	9453360	use them to solve continuously different specific applications and answer different
9453360	9462880	questions and so those poor scientists were were required to to use say fortran because fortran
9462880	9469360	was the library the language that the library was written in and then the scientist would have to write
9470080	9478400	an application that sort of uses the library to solve a particular equation or set off of answer
9478400	9486640	a set of questions and the same for c plus plus because there's there's interoperability so the
9486640	9495360	dusty decks are written either in c plus plus or fortran uh and so paul du bois was one of the people
9495360	9505840	who i think in the mid 90s saw that that you needed a higher level language for the scientists
9506240	9514320	to to sort of tie together the fundamental mathematical algorithms of linear algebra
9514320	9525200	and and other stuff and so gradually some libraries started appearing that did very fundamental
9525840	9533840	stuff with arrays of numbers in python i mean when i first created python i was not expecting it to
9533840	9540320	be used for arrays of numbers much i thought that was like an outdated data type and everything was
9540320	9547280	like objects and strings and like python was good and fast at string manipulation and objects
9547280	9553280	obviously but arrays of numbers were not very efficient and the multi-dimensional arrays didn't
9553280	9562160	even exist in the language at all uh but there were people who realized that python had extensibility
9564080	9571760	that was flexible enough that they could write third-party packages that did support
9571760	9578880	large arrays of numbers and operations on them very efficiently and somehow they got a foothold
9579600	9586800	through sort of different parts of the scientific community i i remembered that the Hubble space
9586880	9594080	telescope people in baltimore were somehow big python fans in the late 90s and at various
9594640	9603600	points small improvements were made and more people got in touch with using python to derive
9603600	9612800	these libraries of interesting uh algorithms and like once once you have a bunch of scientists
9612800	9618800	who are working on similar problems say they're all working on stuff that that data that comes in
9618800	9623760	from the Hubble space telescope but they're looking at different things some some are looking at stars
9623760	9630000	in this galaxy other are looking at galaxies the math is completely different but the the underlying
9631040	9639360	libraries are still the same and so they exchange code they say well i wrote this python program
9639360	9646880	or i wrote a python library to solve this class of problems and the other guys either say oh i can
9646880	9654160	use that library too or if you make a few changes i can use that library too why right why start from
9654160	9662160	scratch in pearl or java script where there's not that infrastructure uh for arrays of numbers yet
9662160	9668640	whereas in python you have it and so more and more scientists at different places doing different
9669680	9678000	different work discovered python and then then people who had an idea for an important new
9678000	9687760	fundamental library decided oh python is is actually already known to our users so let's use python as
9687760	9692640	the user interface i think that's how tensor i imagine at least that's how tensor flow ended up
9692640	9699840	with python as the user interface interface right but with tensor flow there's a deeper
9700640	9705760	history of what the community is it's not just like what packages it needs it's like what the
9705760	9713600	community leans on for programming language because tensor flow had a prior library that was
9713600	9719760	internal to google but there was also competing machine learning frameworks like the ano
9720480	9727760	cafe they were in python there was some scala um some other languages but python was really
9727760	9734080	dominating it and it's interesting because um there's other languages from the engineering
9734080	9742480	space like matlab that a lot of people used but different design choices by the company by the
9742480	9750480	core developers led to it not spreading and one of the choices with matlab by mathworks is to not
9750480	9756560	make it open source right or yeah not you know having people pay it was a very expensive product
9756560	9764160	and so uh universities especially disliked it because it was a price per seat i i remember hearing
9765120	9772240	yeah but i think that's not why it failed or i failed to spread i think the universities
9772240	9778720	didn't like it but they would still pay for it the thing is it didn't feed into that github open
9778720	9788080	source uh packages culture so like and that's somehow a precondition for um for viral spreading
9788080	9793440	the hacker culture like the tinkerer culture uh with with python it feels like you can build a
9793440	9798160	package from scratch or solve a particular problem and get excited about sharing that package with
9798160	9804400	others and that creates an excitement about a language i tend to like python's approach to
9804400	9813440	open source in particular because it's sort of it's almost egalitarian uh there's there's little
9813440	9819600	hierarchy there's there's obviously some because like you all need to decide whether you drive on
9819600	9826320	the left or the right side of the road sometimes but there is a lot of access for people with
9826320	9832160	little power you don't have to work for a big tech company to make a difference in the python world
9834160	9840720	we have affordable events that really care about community and support people
9841520	9850400	and sort of the community is is is like a big deal at our conferences and in in the psf
9850960	9860400	when the psf funds events it's always about growing the community the psf funds very little
9860400	9867760	development they that they do some but most of the develop most of the money that the psf
9868560	9878640	forks out uh is to community fostering things so speaking of egalitarian last time we talked
9878640	9885520	four years ago it was just after you stepped down from your role as the benevolent dictator for
9885520	9892800	life bdfl now looking back what are your insights and lessons you learn from that experience about
9892800	9902480	python developer community about human nature about human civilization life itself oh my uh
9904000	9913520	i probably held on to the position too long i remember being just extremely stressed for a
9913520	9923360	long time and it wasn't very clear to me what was leading what was causing the stress
9926320	9938800	and looking back uh i i should have sort of relinquished my central role as bdfl sooner
9939040	9945520	what were the pros and cons of the bdfl role like what were the you not relinquishing it what
9945520	9951280	what what are the benefits of that for the community and what are the drawbacks well the
9951280	9962240	the benefits for the community would be things like uh clarity of vision and sort of
9962240	9973040	a clear direction because i i had certain ideas in in mind when i created python and
9973040	9980400	while i sort of let myself be influenced by many other ideas as python evolved and became
9982000	9990800	more successful and more complex and more used i also stuck to certain principles and it and
9990800	10000320	still hard to say what are python's core principles but the fact that i was playing that role and
10000320	10010800	sort of always very active grew the community in a certain way it modeled to the community how to
10010800	10018240	think about how to how to solve a certain problem well that was a source of stress but it was also
10018240	10023520	beneficial it was a source of stress for me personally but it was beneficial for the community
10023520	10032800	because uh people people sort of over time had learned how i was thinking and could predict
10034240	10039920	yeah but how how i would would decide about a particular issue and not always perfectly of
10039920	10046320	course but there was like there wasn't a lot of jerking around like this year we're all
10046880	10052400	this year the democrats are in power and we're doing these kind of things and now the republicans
10052400	10058880	are in power and they roll all that back and do those kind of things there is a clear fairly
10058880	10066320	straight path ahead and so fortunately the the successor structure with the steering council
10067120	10075280	has has sort of found a similar way of of leading the community in a fairly steady
10075280	10081840	direction without stagnating and and for me personally it's more fun because there are
10081840	10088320	there are things i can just ignore yeah oh yeah there's a bug in multi-processing let someone
10088320	10095120	else decide whether that's important to solve or not i'll i'll i'll stick to typing in the
10095120	10100960	async io and the faster interpreter yeah it allows you to focus a little bit more yeah
10103040	10107520	what are interesting differences in culture if you can comment on between google dropbox and
10107520	10112640	microsoft from a python programming perspective all places you've been to the positive
10114560	10120000	is there a difference or is it just about people and there's great people everywhere
10120080	10127040	or is there a culture differences sort of dropbox is much smaller than the other two in your list
10127760	10135520	yeah so that that is a big difference the set of products they provide is more it's narrower so
10135520	10142160	they're more focused smaller code based yeah and and dropbox sort of at least during the time i was
10142160	10151120	there had the tendency of sort of making a big plan putting the whole company behind that plan
10151120	10159920	for a year and then evaluate and then suddenly find that everything was wrong about the plan
10159920	10164800	and then they had to do something completely different and so there were there was like
10165760	10172480	the annual engineering reorg was was sort of an unpleasant tradition at dropbox because like
10172480	10177360	oh there's a new vp of engineering and so now all the directors are being reshuffled and
10178080	10185040	this guy was in charge of of infrastructure one year and the next year he was made in
10185040	10190320	charge of i don't know product development it's fascinating because like you don't think about
10190320	10196160	these companies internally but i you know dropbox to me from the very beginning was one of my favorite
10196800	10202880	uh services there's certain like programs and online services that make me happy make me more
10202880	10208080	efficient and all that kind of stuff but one of the powers of those kinds of services they disappear
10208080	10212400	that you're not supposed to think about how it all works but it's incredible to me that you can
10212480	10220880	think stuff effortlessly across so many machines so quickly and like don't have to worry about
10220880	10226480	conflicts they they take care of the you know as a person that comes from a version of repositories
10226480	10232480	and all that kind of stuff or merge is super difficult and uh just keeping different versions
10232480	10236320	of different files is very tricky the fact that they could take care of that just i don't know
10236880	10242000	the the engineering behind the scenes must be super difficult both on the compute infrastructure
10242080	10248240	and the software a lot of internal sort of hand-wringing about things like that
10249120	10255760	but the the product itself always worked very smoothly yeah well there's probably a lot of
10255760	10261680	lessons to that you can have a lot of turmoil inside on the engineering side but if the product
10261680	10266400	is good the product is good and don't maybe don't mess with that either to you know when it's good
10266400	10274400	keep it's like with google focus on the search and the ads right and the money will come yeah
10274400	10279040	and make sure that's done extremely well and don't forget what you do extremely well in
10279600	10285280	in what ways do you provide value and happiness to the world make sure you do that well
10286800	10291600	is there something else to say about google and microsoft microsoft has had a very fascinating
10291600	10298960	shift recently with the new ceo uh what you know recent ceo with purchasing github
10299920	10304480	embracing open source culture embracing the developer culture is pretty interesting to see
10304480	10310960	that's like why i joined microsoft i mean after after retiring and thinking that i would
10311680	10315440	stay retired for the rest of my life which of course was a ridiculous thought
10316160	10322400	but that i was i was done working for a bit and then the pandemic made me realize that work
10322400	10328640	work and also provide a source of fulfillment keep you keep you out of trouble
10331200	10338880	microsoft is a very interesting company because it has this incredible very long and
10339520	10348880	varied history and this amazing catalog of products that many of which also date way back
10349840	10359040	i mean i've been been talking to a bunch of excel people lately and excel is like 35 years old
10359040	10366080	yeah and they can still read spreadsheets that that they might find on an old floppy drive
10366080	10374960	yeah yeah there's man there's so many incredible tools through the years excel one of one of the
10374960	10382640	great shames of my life is that i've never learned how to use excel well i mean it just
10382640	10389360	always felt like so many features are there it's similar with ad is like pie charm it feels like
10389360	10395040	i converged quickly to the dumbest way to use a thing to get the job done when clearly there's
10395040	10401360	so much more power your fingertips yeah but there's i i do think there's probably expert users of
10401360	10409360	excel oh excel is a cash cow actually oh it actually brings the money oh yeah a lot of the
10409360	10416800	engineering sort of if you look deep inside excel there's some very good engineering very
10417680	10422800	very impressive stuff okay now i need to definitely learn excel a little better
10422800	10428400	i had issues because i'm a keyboard person so i had issues coming up with shortcuts and microsoft
10428400	10434480	sometimes it's changed over the years but sometimes they kind of want to make things easier for you
10434480	10442160	on the surface and therefore make it harder for like people that like to have shortcuts and all
10442160	10447360	that kind of stuff to optimize their workflow now excel is probably people are probably yelling at
10447360	10453120	me it's like no excel probably has a lot of ways to optimize the workflow but in fact i keep discovering
10453120	10460480	that there are many features in excel that only exists at keyboard shortcuts yeah that's the sense
10460480	10465920	i have and now like i'm embarrassed that it's just you just have to know what they are yeah that's
10465920	10473440	that's like there's no logic or or reason to the assignment of the keyboard shortcuts because they
10473440	10480560	they go back even longer than 35 years can you maybe comment about such an adela and how hard it
10480560	10485840	is for a ceo to sort of pivot a company towards open source towards developer culture is there
10485840	10492720	something you could see about like how what's the role of leadership in such a pivot and definition
10492720	10503440	of a new vision i've never met him but uh i hear he's just a really sharp thinker
10504960	10512640	but he also has an incredible business sense he took the organization that had very solid pieces
10512640	10522640	but that was also struggling with all sorts of shameful things especially the steve balmer time
10523520	10530480	i imagine in part through his personal charm and thinking and of course the the great trust that
10530480	10536480	that the the rest of the leadership has in him he managed to to really turn the company around and
10536480	10546320	sort of change it from from openly hostile to open source to to actively embracing open source
10546880	10552240	and that doesn't mean that suddenly excel is going to go open source but that means that
10552240	10559440	there's room for a product like vs code which is open source yeah it's fascinating it gives me faith
10559440	10566800	that large companies with good leadership can grow can expand can change and pivot and so on develop
10567600	10573360	because it gets harder and harder as the company gets large um you wrote a blog post in response
10573360	10578080	to a person looking for advice about whether with a cs degree to choose a nine to five job
10578800	10585280	or to become an entrepreneur it's an interesting question if you just think from first principles
10585280	10590960	right now somebody has took a few years in programming has loved software engineering
10590960	10598320	in some sense creating python is an entrepreneurial endeavor that's a choice that a lot of people
10598960	10605200	that are good programmers have to make do i work for a big company or do i create something new
10608000	10611840	or you can work for a big company and create something new there
10612080	10620080	oh inside the yeah i mean big companies have individuals who create new stuff
10620880	10626080	that eventually grows big all the time and if you're the person that creates a new thing
10626080	10631120	it grows big you you'll have a chance to move up quickly in the company to run that thing
10632400	10640000	if that's your aspiration what what what can also happen is that someone is brilliant engineer and
10640000	10650640	sort of builds a great first version of a product and has no aspirations to then become a manager
10650640	10656160	and grow the team from five people to 20 people to a hundred people to a thousand people and
10657360	10665600	be in charge of hiring and meetings and they move on to inventing another crazy thing inside
10665600	10673680	the same company or sometimes they they found a startup or they moved to a different great
10674480	10681520	large or small company there's all sorts of models and sometimes people sort of do have this
10682160	10690480	whole trajectory from engineer buckling down writing code not nine to five but more like
10691440	10699280	noon till midnight seven days a week and coming up with a product and sort of
10701360	10708480	staying in charge i mean if you take Drew Houston Dropbox's founder he is still the CEO
10710080	10714160	and at least when when i was there he had not checked out or anything he was
10715120	10722160	he was a good CEO but he had started out as the technical inventor or co-inventor
10723120	10730720	and so he was someone who i don't know if he always aspired that i think when when he was 16
10730720	10738080	he already started a company so maybe maybe he did but he sort of it turned out that that he
10738160	10746720	did have the the personal sort of skill set needed to to grow and and stay on top and other people
10747440	10754720	sort of are brilliant engineers and horrible at management i count myself at least in the
10754720	10760880	second category yeah so your your your first love and still your love is to be the quote-unquote
10760880	10769600	individual contributor so the programmer yep do you have advice for a programming beginner
10769600	10783840	on how to learn python the right way find something you actually want to do with it if you say i want
10783920	10790240	learn skill x that's not enough motivation you need to pick something
10791760	10797360	and it can be a it can be a crazy problem you want to solve it it can be completely unrealistic
10801120	10809920	but something that that challenges you into actually learning coding in in some language
10810880	10814640	and there's so many projects out there you can look for like that that doesn't have to be some
10814640	10820080	big ambitious thing it could be writing a small bot if you're into social media you can write a
10820080	10827440	red a bot or a twitter bot or or some aspect of automating some as something that you do every
10827440	10834080	single day processing files all that kind of stuff nowadays you can take machine learning components
10834160	10841120	and and sort of plug those things together so you cool stuff with them so that's actually a
10841120	10844720	really good example so if you're interested in machine learning the state of machine learning is
10844720	10852960	such that like a a tutorial that takes an hour can get you to start using uh pre-trained models
10852960	10857680	to do something super cool and that's a good way to learn python because you learn just enough to
10857680	10863680	run this model and that's like a sneaky way to get get in there to figure out how to import
10863760	10871680	stuff how to write basic io how to run functions and i'm not sure if it's the best way to learn
10871680	10877040	the basics in python but could be nice to just get fall in love first and then figure out the basics
10877040	10884400	right yeah you can't expect to learn python from a one hour video of course i'm blanking out on the
10884400	10895280	name of of someone who who wrote a very funny blog post where he said i see all these ads for things
10895280	10904560	like learn python in 10 days or so and he said the the goal should be learn python in 10 years
10905200	10911200	that's hilarious but i completely disagree with that i think the criticism behind that is that
10912160	10917120	the the place is just like the blog post from earlier the places that tell you learn python
10917120	10922080	in five minutes or 10 minutes they're actually usually really bad tutorials so the thing is i
10922080	10932000	do believe that you can learn a thing in an hour to like get some interesting quick like it hooks you
10932000	10935920	i mean this but it just takes a tremendous amount of skill to be that kind of educator
10935920	10940960	richard feinlin was able to condense a lot of ideas and physics in a very short amount of time
10940960	10947200	but that takes a deep deep understanding and so yes of course the actual i think the 10 the 10
10947200	10953200	years is about the experience the pain along the way and there's something you have to practice
10953200	10960480	you can memorize the syntax but well i couldn't but maybe maybe someone else can but that doesn't
10960480	10968640	make you a coder yeah actually coding has changed in fascinating ways because so much of coding is
10968640	10973760	copying pacing from stack overflow and then adjusting which is another way of coding and i
10973760	10978560	don't want to talk down to that kind of style of coding because it's kind of a nicely efficient
10978560	10986160	but you know where that is going a code generation get no seriously get a co-pilot yeah co-pilot
10986160	10993280	i use it every day and it really yeah it writes a lot of code for me and usually it's slightly
10993360	11000480	wrong but it still saves me typing because all i have to do is like change one word in a line
11000480	11007840	of text that otherwise it it generated perfectly and like how many times are you looking for like
11007840	11012800	oh what was i doing this morning i was looking for an begin marker and i was looking for an
11012800	11024400	end marker and so begin is blah blah blah search for begin this is the begin token and then the next
11024400	11032160	line i type e and it it completes the whole line with end instead of begin that's a very simple
11032160	11038400	example sometimes it it's sort of if i name my function right it writes a five or ten line function
11039040	11047840	and you know python enough to very quickly then detect the issues so it's it becomes a really
11047840	11053840	good dance partner then it doesn't save me a lot of thinking but since i'm a poor typist i'm very
11053840	11062000	much appreciative of all the all the typing it does for me much better actually than the the
11062000	11069200	previous generation of suggestions that are also still built in vs code uh where when you hit like
11069200	11076160	a dot it it tries to guess what the type is of the variable to the left of the dot and then it
11076160	11083280	gives you a list on the pop down menu of what the attributes of that object are but copilot is much
11083280	11089760	much smoother than that well it's fascinating to hear that you use github copilot uh do you think
11089760	11097680	do you worry about the future of that uh did the automatic cogeneration the increasing amount of
11098400	11104880	that kind of capability are programmers jobs threatened or is there still a significant
11104880	11112240	role for humans are programmers jobs threatened by the existence of stack overflow i don't think so
11112240	11119440	it helps you take care of the boring stuff and you shouldn't try to use it to do something that
11119440	11126880	you have no way of understanding what you're doing yet a tool like that is always best when
11127840	11136160	the question you're asking is please remind me of how i do this which i i could do i could look
11136160	11145040	up how to do it but right now i've forgotten whether the method is called foo or bar or how you
11145040	11152000	what the shape of the api is does it use a builder object or a constructor or a factory or
11154400	11161200	something else and what are the parameters it serves that role it's like a great assistant
11161920	11168480	but the creative work of sort of deciding what you want what you want the code to do is is totally
11168480	11175280	yours what do you think is the future of python in the next 10 20 50 years 100 years you look
11175280	11181600	forward you ever think about you ever imagine a future of human civilization or living inside the
11181600	11191520	metaverse on mars human or robots everywhere what part does python play in that it'll eventually
11191520	11198160	become a sort of a legacy language uh that plays an important role but that's that most people
11198160	11207120	have never heard of and uh don't need to know about just like all kinds of basic structures in in
11208240	11216560	biology like mitochondria so it permeates all of life all of digital life but people just build
11216560	11222320	on top of it and they only know the stuff that's on top of it yeah you guys you build layers of
11222320	11230480	obstructions i mean most programmers nowadays rarely need to do binary arithmetic right
11233360	11239200	yeah or even think about it or even learn about it or they could go quite far without knowing
11239680	11247040	i started building little digital circuits out of nend gates that i built myself with
11247120	11255360	transistors and resistors so i sort of i feel very blessed that with with that start when i was
11255360	11265520	a teenager i i learned some of the basic at least concepts that that go into building a computer
11266400	11276240	and i sort of every part i have some understanding what what it's for and why it's there and how it
11276240	11284160	works and i can't forget about all that most of the time but i sort of i enjoy knowing oh if you go
11284160	11291840	deeper you at at some point you get to uh nend gates and have adders and shift registers and
11293120	11298720	when it comes to the point of how do you how do you actually make a chip out of silicon i have no idea
11298720	11305360	that's just magic to me but you enjoy knowing that you can walk a while towards the lower and lower
11305360	11313120	layers but you don't need to it's nice the other day as a sort of a mental exercise i was trying to
11313120	11327120	figure out if i could build a flip flop circuit out of relays i was just sort of trying to remember
11327120	11333920	oh how does a real relay work yeah there's like this electromagnetic force that pulls a switch
11333920	11342080	open or shut uh and you can have have like it can open one switch in another shut another and
11344240	11349680	you can have multiple contacts that go at once and how many relays do i really need to
11349680	11354800	sort of represent one bit of information can the relay just feed on itself there was
11355600	11363120	i don't think i i i got to the final solution but it was fun that i i could still do a little
11363120	11369360	bit of problem solving and thinking at that level and it's cool how we build on top of each other
11369360	11373920	so there's people there just you you stood on the shoulders of giants and there's others
11373920	11380000	who'll stand on your shoulders and it's it's a giant beautiful higher yeah i feel i sort of
11380000	11386400	covered this middle layer of the technology stack where i sort of peters out below the
11387360	11395600	the level of of of nan gates and at the at the top i sort of i lose track when it gets to machine
11395600	11400960	learning and then eventually the machine learning will build higher and higher layers that will
11400960	11409280	help us understand the lowest layer of the physics and thereby the universe figures out how it itself
11409360	11417040	works maybe maybe not yeah i did i mean it's it's possible i mean if you think of human
11417040	11424560	consciousness if that's even the right concept it's it's interesting that that's sort of we
11424560	11431920	have this super parallel brain that does all these incredible parallel operations like image
11431920	11440000	recognition i recognize your face does huge amount of processing that goes on in parallel
11440000	11445600	there's lots of nerves between my eyes and my brain and the brain does a whole bunch of stuff
11445600	11450160	all at once because it's actually really slow circuits but there are many of them that all
11450160	11456960	work together on the other hand when i'm speaking everything is completely sequential
11457920	11466240	i i i have to sort of string words together one at a time and when i'm thinking about stuff
11466240	11473520	i'm when i'm when i'm understanding the world i'm also thinking of everything like one step at a time
11475440	11479520	and so we we've we've sort of we've got all this this incredible
11479760	11487840	parallel circuitry in our brains and eventually we use that to simulate a single threaded
11488800	11497360	much much higher level interpreter it's exactly i mean that's the illusion of it that's the illusion
11498400	11505120	of it for us that it's a single sequential set of thoughts and all of that came from a single cell
11505120	11513120	through the process of embryogenesis so dna is the code dna holds the entirety of the code
11513120	11520720	the information and how to use that information to build up an organism the entire like the arms the
11520720	11528880	how is it built yeah the brain so it's you don't buy a computer you buy like a you buy a seed a
11528880	11534720	yeah diagram and then you plant the computer and it builds itself in almost the same way
11535520	11543600	and then does the computation and then is uh eventually dies it gets stale but gives birth
11543600	11549280	to young computers more and more and gives them lessons but they figure stuff out on their own
11549280	11555280	and over time it goes on that way and those computers when they go to college tried to
11555280	11559760	figure out how to program and they built their own little computers and they're increasingly
11559760	11565520	more intelligent increasingly higher and higher levels of abstractions isn't it interesting that
11565520	11572560	that you sort of you see the same thing appearing at different levels though because you have like
11574800	11582960	cells that that create new cells and and eventually that builds a whole organism but then
11582960	11593840	the animal or the plant or the human has its own mechanism of replication that that is is sort of
11593840	11599920	connected in a very complicated way to the mechanism of replication of the cells and then
11599920	11606800	if you if you look inside the cell if you see how dna and proteins are are connected then
11606800	11613200	there is yet another completely different mechanism whereby proteins are mass produced
11614640	11620720	using enzymes and and and a little bit of code from from dna and of course viruses
11621360	11628400	break into it at that level and while the mechanisms might be different it seems like
11628400	11635920	the nature of the mechanism is the same and it carries across natural languages and programming
11635920	11644320	languages humans maybe even human civilizations or intelligent civilizations and then all the way
11644320	11651280	down to the single cell organisms it is it is fascinating to see what abstraction levels
11652160	11658240	are built on top of individual humans yeah and how you have like whole societies
11658640	11669040	that that sort of have a similar self-preservation i don't know what it is instinct nature abstraction
11670080	11676240	as the individuals have and the cells have and they self-replicate and breed in different ways
11676960	11681520	it's hard for us humans to introspect it because we were very focused on our particular layer of
11681520	11687520	abstraction but from an alien perspective looking on earth they'll they'll probably see
11688480	11695040	the higher level organism of human civilization as part of this bigger organism of life on earth
11695040	11702880	itself in fact that could be an organism just alone just life life life on earth this has been a
11702880	11708640	wild both philosophical and technical conversation you're you're an amazing human being you're
11709280	11713600	you were gracious enough to talk to me when i was first doing this podcast you're one of the
11713600	11719440	earliest first people i've talked to somebody i admired for a long time it's just a huge honor
11719440	11724560	that you did it at that time and you do it again you're awesome thank you lex thanks for listening
11724560	11729920	to this conversation with guido van rossum to support this podcast please check out our sponsors
11729920	11736480	in the description and now let me leave you some words from oscar wild experience is the name that
11736480	11745120	everyone gives to their mistakes thank you for listening and hope to see you next time
