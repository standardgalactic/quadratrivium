start	end	text
0	5680	The following is a conversation with Bjarn Strelstrom. He's the creator of C++,
5680	11600	programming language that after 40 years is still one of the most popular and powerful languages in
11600	18080	the world. Its focus on fast, stable, robust code underlies many of the biggest systems in the world
18080	23120	that we have come to rely on as a society. If you're watching this on YouTube, for example,
23120	29280	many of the critical back-end components of YouTube are written in C++. Same goes for Google,
29280	35200	Facebook, Amazon, Twitter, most Microsoft applications, Adobe applications, most database
35200	42160	systems, and most physical systems that operate in the real world, like cars, robots, rockets that
42160	49840	launch us into space, and one day will land us on Mars. C++ also happens to be the language
49840	55680	that I use more than any other in my life. I've written several hundred thousand lines of C++
55680	61520	source code. Of course, lines of source code don't mean much, but they do give hints of my
61520	66800	personal journey through the world of software. I've enjoyed watching the development of C++
66800	73040	as a programming language leading up to the big update in the standard in 2011 and those that
73040	80320	followed in 14, 17, and toward the new C++20 standard hopefully coming out next year.
81120	86560	This is the Artificial Intelligence Podcast. If you enjoy it, subscribe on YouTube, give it
86560	91920	five stars on iTunes, support it on Patreon, or simply connect with me on Twitter at Lex
91920	98880	Friedman, spelled F-R-I-D-M-A-N. And now, here's my conversation with Bjorn Strauss-Straub.
100240	104000	What was the first program you've ever written? Do you remember?
104080	112640	It was my second year in university, first year of computer science, and it was an Algor-60.
113520	122400	I calculated the shape of a super ellipse and then connected points on the perimeter,
122400	130480	creating star patterns. It was with a wedding on a paper printer.
131440	133280	And that was in college, university?
133280	137120	Yeah. I learned to program the second year in university.
138400	144960	And what was the first programming language, if I may ask it this way, that you fell in love with?
146480	159120	I think Algor-60. And after that, I remember Snowball. I remember Fortran didn't fall in love
159120	164720	with that. I remember Pascal didn't fall in love with that. It all got in the way of me.
166160	169360	And then I just covered Assembler, and that was much more fun.
170320	173920	And from there, I went to microcode.
174800	181120	So you were drawn to the, you found the low-level stuff beautiful?
181120	188080	I went through a lot of languages, and then I spent significant time in Assembler and
188080	194560	microcode. That was sort of the first really profitable things I paid for my masters, actually.
195360	198480	And then I discovered Simula, which was absolutely great.
199600	200080	Simula?
200640	209040	Simula was the extension of Algor-60 done primarily for simulation, but basically they
209040	216160	invented object-oriented programming at inheritance and runtime polymorphism while they were doing it.
216400	225840	And that was a language that taught me that you could have the sort of the problems of a program
225840	231520	grow with the size of the program rather than with the square of the size of the program.
232480	239520	That is, you can actually modularize very nicely. And that was a surprise to me.
240480	249920	It was also a surprise to me that a stricter type system than Pascal's was helpful, whereas Pascal's
249920	258720	type system got in my way all the time. So you need a strong type system to organize your code well,
258720	260800	but it has to be extensible and flexible.
261520	266480	Let's get into the details a little bit. If you remember, what kind of type system did Pascal have?
267120	270320	What type system, typing system did Algor-60 have?
271040	279280	Basically, Pascal was sort of the simplest language that Niklaus Wiert could define that
279280	288560	served the needs of Niklaus Wiert at the time. And it has a sort of a highly moral tone to it.
288560	293680	That is, if you can say it in Pascal, it's good. And if you can't, it's not so good.
294560	302000	Whereas, Simula, allowed you basically to build your own type system.
302880	308720	So instead of trying to fit yourself into Niklaus Wiert's world,
309920	315760	Christen Nürburgring's language and Oliohan Dahl's language allowed you to build your own.
315760	323680	So it's sort of close to the original idea of you build a domain specific language.
324480	331280	As a matter of fact, what you build is a set of types and relations among types
331280	335520	that allows you to express something that's suitable for an application.
336320	342160	When you say types, stuff you're saying has echoes of object during a programming.
342160	348240	Yes, they invented it. Every language that uses the word class for type
349040	353520	is a descendant of Simula, directly or indirectly.
355040	361920	Christen Nürburgring and Oliohan Dahl were mathematicians and they didn't think in terms of
361920	370400	types, but they understood sets and classes of elements. And so they called their types classes.
371360	376960	And basically in C++, as in Simula classes, a user-defined type.
378480	385120	So can you try the impossible task and give a brief history of programming languages from
385120	393120	your perspective? So we started with ALGOL 60, Simula, Pascal, but that's just the 60s and 70s.
394080	402560	I can try. The most sort of interesting and major improvement of programming languages was
403600	410720	FORTRAN, the first FORTRAN. Because before that, ALGOL was written for a specific machine and each
410720	420000	specific machine had a language, a simply language or a cross-impler or some extension of that idea.
420000	425760	But you are writing for a specific machine in the term, in the language of that machine.
427040	437200	And Barker and his team at IBM built a language that would allow you to write what you really
437200	444160	wanted. That is, you could write it in a language that was natural for people. Now these people
444160	449360	happened to be engineers and physicists, so the language that came out was somewhat unusual for
449360	454320	the rest of the world. But basically they said formula translation because they wanted to have
454320	462560	the mathematical formulas translated into the machine. And as a side effect, they got portability
463280	470000	because now they are writing in the terms that the humans used and the way humans thought.
470640	477440	And then they had a program that translated it into the machine's needs. And that was new and
477440	485840	that was great. And it's something to remember. We want to raise the language to the human level,
485840	492400	but we don't want to lose the efficiency. And that was the first step towards the human?
492400	498480	That was the first step. And of course, there were very particular kinds of humans. Business
498480	504880	people were different, so they got co-born instead and et cetera, et cetera. And Simula came
504880	515440	out. No, let's not go to Simula yet. Let's go to Algon. Fortran didn't have at the time the notions of
516640	527040	not a precise notion of type, not a precise notion of scope, not a set of translation faces that was
528000	535440	what we have today, lexical, syntax, semantics. It was sort of a bit of a model in the early days,
535440	541760	but hey, they've just done the big breakthrough in the history of programming, right? So you
541760	547600	can't criticize them for not having gotten all the technical details right. So we got Algon.
547600	556560	That was very pretty. And most people in commerce and science considered it useless because it was
556560	564160	not flexible enough and it wasn't efficient enough and et cetera, et cetera. But that was the breakthrough
564160	571440	from the technical point of view. And then Simula came along to make that idea more flexible.
572240	578640	And you could define your own types. And that's where I got very interested.
579600	583760	Christen Nygge, who's the main idea man behind Simula.
583760	585040	That was late 60s.
585040	591920	This was late 60s. Well, I was a visiting professor in Aarhus. And so I learned object
591920	602000	oriented programming by sitting around and, well, in theory, discussing with Christen Nygge.
602720	609200	But Christen, once you get started and in full flow, it's very hard to get a word in
609200	614160	edge ways. It was great. I learned it from there.
614160	619600	Not to romanticize the notion, but it seems like a big leap to think about or object-oriented
619600	631440	programming. It's really a leap of abstraction. And was that as big and beautiful of a leap
631440	637040	as it seems from now in retrospect? Or was it an obvious one at the time?
638160	645600	It was not obvious. And many people have tried to do something like that. And most people didn't
645600	653600	come up with something as wonderful as Simula. Lots of people got their PhDs and made their careers
653600	661040	out of forgetting about Simula or never knowing it. For me, the key idea was basically I could get
661040	670480	my own types. And that's the idea that goes further into C++, where I can get better types
670480	675360	and more flexible types and more efficient types. But it's still the fundamental idea.
675360	681520	When I want to write a program, I want to write it with my types. That is appropriate to my problem
682480	689040	and under the constraints that I'm under with hardware, software, environment, etc.
689840	698000	And that's the key idea. People picked up on the class hierarchies and the virtual functions
698000	707040	and the inheritance. And that was only part of it. It was an interesting and major part and
707040	714160	still a major part in a lot of graphic stuff. But it was not the most fundamental. It was
714800	719680	when you wanted to relate one type to another, you don't want them all to be independent.
720400	730480	The classical example is that you don't actually want to write city simulation with vehicles,
730480	736160	where you say, well, if it's a bicycle, write the code for turning a bicycle to the left,
736160	742160	if it's a normal car, turn right the normal carway, if it's a fire engine, turn right the fire engine
742160	750400	way, you get these big case statements and bunches of if statements and such. Instead, you tell the
751840	758240	base class that that's the vehicle and say, turn left the way you want to.
759600	770320	And this is actually a real example. They used it to simulate and optimize the emergency services
770320	779520	for somewhere in Norway back in the 60s. So this was one of the early examples for why you needed
779520	790640	inheritance and you needed runtime polymorphism because you wanted to handle this set of vehicles
790640	798640	in a manageable way. You can't just rewrite your code each time a new kind of vehicle comes along.
799600	804720	Yeah, that's a beautiful, powerful idea. And of course, it stretches through your work,
804720	813360	who C++ as we'll talk about. But I think you structured nicely what other breakthroughs came
813360	818480	along in the history of programming languages. If we were to tell the history in that way.
819440	824480	Obviously, I'm better telling the part of the history that that is the path I'm on,
824560	830240	as opposed to all the paths. Yeah, you skipped the hippie John McCarthy and Lisp,
830240	837680	one of my favorite languages. But Lisp is not one of my favorite languages. It's obviously
837680	843600	important. It's obviously interesting. Lots of people write code in it. And then they rewrite it
843600	852480	into CSE plus plus when they want to go to production. It's in the world I'm at, which are
852480	860880	constrained by performance, reliability, issues, deployability, cost of hardware.
862960	870480	I don't like things to be too dynamic. It is really hard to write a piece of code that's
870480	877840	perfectly flexible, that you can also deploy on a small computer. And that you can also put in,
877840	884240	say, a telephone switch in Bogota. What's the chance if you get an error and you find yourself
884240	890800	in the debugger that the telephone switch in Bogota on late Sunday night has a programmer around?
891840	900000	The chance is zero. And so a lot of things I think most about can't afford that flexibility.
900960	911920	I'm quite aware that maybe 70, 80% of all code are not under the kind of constraints I'm interested
911920	919840	in. But somebody has to do the job I'm doing, because you have to get from these high-level
919840	927200	flexible languages to the hardware. The stuff that lasts for 10, 20, 30 years is robust,
927280	933280	operates under very constrained conditions. Yes, absolutely. And it's fascinating and beautiful
933280	942000	in its own way. C++ is one of my favorite languages. And so is Lisp. So I can embody too
942000	951120	for different reasons as a programmer. I understand why Lisp is popular. And I can see
951120	965200	the beauty of the ideas and similarly with Smalltalk. It's just not as relevant in my world.
965200	969280	And by the way, I distinguish between those in the functional languages,
969280	977040	where I go to things like ML and Haskell. Different kind of languages. They have a
977040	982560	different kind of beauty and they're very interesting. And I actually try to learn from
983600	988560	all the languages I encounter to see what is there that would make
990000	995120	working on the kind of problems I'm interested in with the kind of constraints
996720	1003280	that I'm interested in. What can actually be done better? Because we can surely do better than we
1003280	1010480	do today. You've said that it's good for any professional programmer to know at least five
1010480	1018000	languages, speaking about a variety of languages that you've taken inspiration from. And you've
1018000	1026720	listed yours as being, at least at the time, C++, obviously, Java, Python, Ruby and JavaScript.
1027280	1033600	Can you, first of all, update that list, modify it? You don't have to be constrained
1035200	1040400	to just five. But can you describe what you picked up also from each of these languages,
1041760	1045920	how you see them as inspirations for even when you're working with C++?
1045920	1054320	This is a very hard question to answer. So about languages, you should know languages.
1054880	1062560	I reckon I knew about 25 or thereabouts when I did C++. It was easier in those days
1062560	1069120	because the languages were smaller and you didn't have to learn a whole programming environment
1069120	1075280	and such to do it. You could learn the language quite easily. And it's good to learn so many
1075280	1081680	languages. And I imagine, just like with natural language for communication,
1082400	1088240	there's different paradigms that emerge in all of them, that there's commonalities and so on.
1088880	1096720	So I picked five out of a hat. The important thing that the number is not one.
1101040	1106080	If you're a monoglot, you are likely to think that your own culture is the only one's
1106080	1111200	period for everybody else's. A good learning of a foreign language and a foreign culture
1111200	1116800	is important. It helps you think and be a better person. With programming languages,
1116800	1122080	you become a better programmer, a better designer with the second language. Now,
1122080	1129600	once you've got two, the way to five is not that long. It's the second one that's most important.
1130400	1139200	And then when I had to pick five, I thought of thinking what kinds of languages are there.
1139200	1144160	Well, there's a really low-level stuff. It's actually good to know machine code.
1145120	1147040	Even still, sorry to interrupt. Even today.
1149920	1153200	The C++ optimizer is right better machine code than I do.
1154160	1160960	But I don't think I could appreciate them if I actually didn't understand machine code
1160960	1166240	and machine architecture. At least in my position, I have to understand a bit of it,
1166240	1172400	because you mess up the cache and you're off in performance by a factor of 100.
1174320	1179600	It shouldn't be that if you're interested in either performance or the size of the computer
1179600	1188720	you have to deploy. So I would go, that's a simpler. I used to mention C, but these days
1188720	1195040	going low-level is not actually what gives you the performance. It is to express your ideas
1195600	1200400	so cleanly that you can think about it and the optimizer can understand what you're up to.
1201200	1207840	My favorite way of optimizing these days is to throw out the clever bits and see if it still
1207840	1216240	runs fast and sometimes it runs faster. So I need the abstraction mechanisms or something like C++
1216240	1224400	to write compact high-performance code. There was a beautiful keynote by Jason Turner at the CPP
1224400	1236640	Con a couple of years ago where he decided he was going to program Pong on Motorola 6800, I think it
1236640	1243600	was. And he says, well, this is relevant because it looks like a microcontroller. It has specialized
1243600	1250960	hardware, it has not very much memory and it's relatively slow. And so he shows in real time
1250960	1257760	how he writes Pong, starting with fairly straightforward low-level stuff, improving
1257760	1268640	his subscriptions and what he's doing, he's writing C++ and it translates into 86 assembler,
1268640	1276080	which you can do with Clang and you can see it in real time. It's the Compiler Explorer,
1276080	1281760	which you can use on the web. And then he wrote a little program that translated 86 assembler into
1282640	1290160	Motorola assembler. And so he types and you can see this thing in real time. You can see it in real
1290160	1296480	time and even if you can't read the assembly code, you can just see it, his code gets better,
1296480	1305120	the code, the assembler gets smaller, he increases the abstraction level, uses C++ 11 as it were
1305120	1311520	better. This code gets cleaner, it gets easier maintained when the code shrinks and it keeps
1311520	1320640	shrinking. And I could not, in any reasonable amount of time, write that assembler as good
1321200	1328640	as the compiler generated from really quite nice modern C++. And I'll go as far as to say that
1328640	1338960	the thing that looked like C was significantly uglier and smaller when it became, and larger
1338960	1346720	when it became machine code. So the abstractions that can be optimized are important.
1347280	1352160	I would love to see that kind of visualization in larger code bases. That might be beautiful.
1352160	1357840	But you can't show a larger code base in a one-hour talk and have it fit on screen.
1358640	1366800	So that's C and C++. So my two languages would be machine code and C++. And then I think you can
1366800	1373920	learn a lot from the functional languages. So PIG has Gloloy ML. I don't care which. I think,
1373920	1383280	actually, you learn the same lessons of expressing especially mathematical notions really clearly
1383280	1391360	and having a type system that's really strict. And then you should probably have a language for
1391360	1398640	sort of quickly churning out something. You could pick JavaScript, you could pick Python,
1398640	1403840	you could pick Ruby. What do you make of JavaScript in general? So you kind of,
1403840	1408560	you're talking in the platonic sense about languages, about what they're good at,
1409360	1414400	what their philosophy of design is. But there's also a large user base behind
1414400	1419440	each of these languages. And they use it in the way sometimes maybe it wasn't really designed for.
1419440	1420080	That's right.
1420080	1423680	JavaScript is used way beyond probably what it was designed for.
1423680	1428800	Let me say it this way. When you build a tool, you do not know how it's going to be used.
1429440	1435200	You try to improve the tool by looking at how it's being used and when people cut their fingers
1435280	1440960	off and try and stop that from happening. But really, you have no control over how
1440960	1447040	something is used. So I'm very happy and proud of some of the things C++ is being used at.
1447040	1453840	And some of the things I wish people wouldn't do, Bitcoin mining being my favorite example,
1453840	1459520	uses as much energy as Switzerland and mostly serves criminals.
1460320	1461120	Yeah.
1461120	1467360	But back to the languages, I actually think that having JavaScript run in the browser
1470480	1474640	wasn't an enabling thing for a lot of things. Yes, you could have done it better,
1474640	1477360	but people were trying to do it better and they were using
1480160	1485440	sort of more principles, language designs, but they just couldn't do it right. And the
1486240	1492560	non-professional programmers that write lots of that code just couldn't understand them. So
1493840	1501520	it did an amazing job for what it was. It's not the previous language and I don't think it ever
1501520	1506640	will be the previous language, but let's not be bigots here.
1507680	1510480	So what was the origin story of C++?
1511360	1512160	Yeah.
1512160	1520400	So you basically gave a few perspectives of your inspiration of object-oriented programming
1521120	1526240	that you had a connection with C++ and performance efficiency was an important
1526240	1527360	a thing you were drawn to.
1528320	1530000	Efficiency and reliability.
1530000	1530720	Reliability.
1530720	1531760	You have to get both.
1532880	1533920	What's reliability?
1534800	1542480	I really want my telephone calls to get through and I want the quality of what I am talking
1542480	1548320	coming out at the other end. The other end might be in London or wherever.
1549920	1556320	So and you don't want the system to be crashing. If you're doing a bank, you must
1556400	1563680	crash. It might be your bank account that is in trouble. There's different constraints like
1563680	1568720	games. It doesn't matter too much if there's a crash, nobody dies and nobody gets ruined.
1568720	1576720	But I'm interested in the combination of performance partly because of sort of speed
1576720	1585280	of things being done. Part of being able to do things that is necessary to have reliability
1586480	1594720	of larger systems. If you spend all your time interpreting a symbol function call,
1595280	1599440	you are not going to have enough time to do proper signal processing to get the
1599440	1606080	telephone calls to sound right. Either that or you have to have 10 times as many computers
1606080	1611840	and you can't afford your phone anymore. It's a ridiculous idea in the modern world because
1611840	1618000	we've solved all of those problems. I mean they keep popping up in different ways
1618000	1623120	because we tackle bigger and bigger problems so efficiency remains always an important aspect.
1623120	1630960	But you have to think about efficiency not just as speed but as an enabler to important things
1630960	1639840	and one of the things it enables is reliability, is dependability. When I press the pedal,
1640400	1648000	the brake pedal of a car, it does not actually connect it directly to anything but a computer.
1648800	1653840	That computer better work. Let's talk about reliability just a little bit.
1654480	1664000	So modern cars have ECUs, have millions of lines of code today. So this is certainly
1664000	1668400	especially true of autonomous vehicles where some of the aspect of the control or driver
1668480	1671440	assistance systems that steer the car, they keep it in the lane and so on.
1672080	1678240	So how do you think, I talked to regulators, people in government who are very nervous about
1678800	1685440	testing the safety of these systems of software, ultimately software that makes decisions that
1685440	1691920	could lead to fatalities. So how do we test software systems like these?
1692400	1703120	First of all, safety, like performance and like security is a systems property. People tend to
1703120	1710400	look at one part of a system at a time and saying something like, this is secure. That's all right.
1710400	1715680	I don't need to do that. Yeah, that piece of code is secure. I'll buy you an operator.
1715680	1722720	I'll buy you an operator. If you want to have reliability, if you want to have performance,
1722720	1726000	if you want to have security, you have to look at the whole system.
1726960	1730160	I did not expect you to say that, but that's very true. Yes.
1730160	1734560	I'm dealing with one part of the system and I want my part to be really good,
1735120	1742000	but I know it's not the whole system. Furthermore, making an individual part perfect
1742000	1749680	may actually not be the best way of getting the highest degree of reliability and performance and
1749680	1757680	such. There's people who say C++ type safe, not type safe. You can break it. Sure. I can break
1757680	1764480	anything that runs on a computer. I may not go through your type system. If I wanted to break
1764480	1770480	into your computer, I'll probably try SQL injection. It's very true. If you think about
1770480	1776800	safety or even reliability at its system level, especially when a human being is involved,
1778160	1786480	it starts becoming hopeless pretty quickly in terms of proving that something is
1787920	1792160	safe to a certain level because there's so many variables. It's so complex.
1792160	1797600	Well, let's get back to something we can talk about and actually make some progress on.
1798480	1805680	We can look at C++ programs and we can try and make sure they crash less often.
1806960	1818240	The way you do that is largely by simplification. The first step is to simplify the code, have less
1818240	1824480	code, have code that are less likely to go wrong. It's not by runtime testing everything.
1824480	1832400	It is not by big test frameworks that you're using. Yes, we do that also. But the first step
1832960	1839600	is actually to make sure that when you want to express something, you can express it directly in
1839600	1846640	code rather than going through endless loops and convolutions in your head before it gets down the
1846640	1856560	code. If the way you're thinking about a problem is not in the code, there is a missing piece
1856560	1863920	that's just in your head. The code, you can see what it does, but it cannot see what you thought
1863920	1869520	about it unless you have expressed things directly. When you express things directly,
1870160	1876080	you can maintain it. It's easier to find errors. It's easier to make modifications. It's actually
1876080	1884560	easier to test it and, lo and behold, it runs faster. Therefore, you can use a smaller number
1884560	1892240	of computers, which means there's less hardware that could possibly break. I think the key here
1892240	1899440	is simplification, but it has to be to use the Einstein quote as simple as possible and no
1899440	1905520	simpler. Not simpler. There are other areas with under constraints where you can be simpler than
1905520	1912240	you can be in C++, but in the domain I'm dealing with, that's the simplification I'm after.
1913440	1922640	So how do you inspire or ensure that the Einstein level of simplification is reached?
1923360	1931920	So can you do code review? Can you look at code? If I gave you the code for the Ford F-150
1932880	1941520	and said, here, is this a mess or is this okay? Is it possible to tell? Is it possible to regulate?
1943040	1951600	An experienced developer can look at code and see if it smells. I mixed it for us deliberately.
1952560	1965440	The point is that it is hard to generate something that is really obviously clean and
1966960	1972240	can be appreciated, but you can usually recognize when you haven't reached that point.
1973200	1984960	And so if I have never looked at the F-150 code, so I wouldn't know, but I know what I would be
1984960	1990960	looking for. There I'll be looking for some tricks that correlate with bugs and elsewhere, and
1991200	2002880	I have tried to formulate rules for what good code looks like, and the current version of that is
2002880	2012480	called the C++ Core Guidelines. One thing people should remember is there's what you can do in a
2012480	2020320	language and what you should do. In a language you have lots of things that is necessary in some
2020320	2026480	context, but not in others. There's things that exist just because there's 30-year-old code out
2026480	2031760	there and you can't get rid of it, but you can't have rules that says when you create it, try and
2031760	2041600	follow these rules. This does not create good programs by themselves, but it limits the damage
2042640	2049040	for mistakes. It limits the possibilities of mistakes, and basically we are trying to say
2049040	2056400	what is it that a good programmer does at the fairly simple level of where you use the language
2056400	2065360	and how you use it. Now I can put all the rules for chiseling in marble. It doesn't mean that somebody
2065360	2073200	who follows all of those rules can do a masterpiece by Michelangelo. That is, there's something else
2073840	2081360	to write a good program. Is there something else to create important work of art?
2083280	2092480	There's some kind of inspiration, understanding, gift, but we can approach the
2094800	2103040	technical, the craftsmanship level of it. The famous painters, the famous sculptures,
2103040	2113440	was among other things superb craftsmen. They could express their ideas using their tools very well,
2114160	2120400	and so these days I think what I'm doing, what a lot of people are doing, we're still trying to
2120400	2129920	figure out how it is to use our tools very well. For a really good piece of code, you need a spark
2129920	2139760	of inspiration, and you can't, I think, regulate that. You cannot say that I'll buy your picture
2139760	2149040	only if you're at least Van Gogh. There are other things you can regulate, but not the inspiration.
2150400	2158480	I think that's quite beautifully put. It is true that there is an experienced programmer when you
2158560	2169840	see code that's inspired, that's like Michelangelo, you know it when you see it, and the opposite
2169840	2176000	of that is code that is messy, code that smells, you know when you see it, and I'm not sure you
2176000	2183520	can describe it in words except vaguely through guidelines and so on. Yes, it's easier to recognize
2183600	2191040	ugly than to recognize beauty in code, and for the reason is that sometimes beauty comes from
2191040	2197840	something that's innovative and unusual, and you have to sometimes think reasonably hard to appreciate
2197840	2208240	that. On the other hand, the messes have things in common, and you can have static checkers and
2208240	2220400	dynamic checkers that finds a large number of the most common mistakes. You can catch a lot of
2220400	2228960	sloppiness mechanically. I'm a great fan of static analysis in particular, because you can check for
2228960	2235440	not just the language rules, but for the usage of language rules, and I think we will see much
2235440	2241360	more static analysis in the coming decade. Can you describe what static analysis is? You
2242400	2251520	represent a piece of code so that you can write a program that goes over that representation
2252160	2263360	and look for things that are right and not right. So for instance, you can analyze a program to see
2263440	2274240	if resources are leaked. That's one of my favorite problems. It's not actually all that hard in
2274240	2280320	modern C++, but you can do it. If you are writing in the C level, you have to have a malloc and a
2280320	2288880	free, and they have to match. If you have them in a single function, you can usually do it very
2288880	2296320	easily. If there's a malloc here, there should be a free there. On the other hand, in between can be
2296320	2303280	drawing complete code, and then it becomes impossible. If you pass that pointer to the memory
2303280	2312080	out of a function and then want to make sure that the free is done somewhere else, now it gets
2312080	2319200	really difficult. And so for static analysis, you can run through a program and you can try and figure
2319200	2328160	out if there's any leaks. And what you will probably find is that you will find some leaks,
2328160	2334880	and you will find quite a few places where your analysis can't be complete. It might depend on
2334880	2343840	runtime. It might depend on the cleverness of your analyzer, and it might take a long time. Some of
2343840	2353840	these programs run for a long time. But if you combine such analysis with a set of rules such
2353840	2361360	as how people could use it, you can actually see why the rules are violated, and that stops you from
2361440	2367280	getting into the impossible complexities. You don't want to solve the holding problem.
2368640	2372240	So static analysis is looking at the code without running the code?
2372240	2379920	Yes. And thereby, it's almost not a production code, but it's almost like an education tool
2380560	2389440	of how the language should be used. It guides you. At its best, it would guide you in how you
2389440	2391840	write future code as well, and you learn together.
2392400	2398320	Yes. So basically, you need a set of rules for how you use the language. Then you need a static
2398320	2406960	analysis that catches your mistakes when you violate the rules or when your code ends up
2407760	2412400	doing things that it shouldn't, despite the rules, because there is the language rules. We can go
2412400	2419280	further. And again, it's back to my idea that I would much rather find errors before I start
2419280	2426240	running the code. If nothing else, once the code runs, if it catches an error at run times, I have
2426240	2433520	to have an error handler. And one of the hardest things to write in code is error handling code,
2433520	2438640	because you know something went wrong. Do you know really exactly what went wrong?
2439360	2443120	Usually not. How can you recover when you don't know what the problem was?
2443760	2451840	You can't be 100 percent sure what the problem was in many, many cases. And this is part of it.
2451840	2458880	So yes, we need good languages with good type systems. We need rules for how to use them.
2458880	2464800	We need static analysis. And the ultimate for static analysis is, of course, program proof,
2464800	2472480	but that still doesn't scale to the kind of systems we deploy. Then we start needing testing and
2473280	2482000	the rest of the stuff. So C++ is an object-oriented programming language that creates, especially
2482000	2487040	with its newer versions, as we'll talk about, higher and higher levels of abstraction. So
2488160	2494000	how do you design? Let's even go back to the origin of C++. How do you design something with
2494000	2504800	so much abstraction that's still efficient and is still something that you can manage,
2504800	2510880	do static analysis on, you can have constraints on, they can be reliable, all those things we've
2510880	2520640	talked about. So to me, there's a slight tension between high level abstraction and efficiency.
2521440	2526720	That's a good question. I could probably have a year's course just trying to answer it.
2528400	2535440	Yes, there's a tension between efficiency and abstraction, but you also get the interesting
2535440	2543920	situation that you get the best efficiency out of the best abstraction. And my main tool for
2543920	2550640	efficiency for performance actually is abstraction. So let's go back to how C++ got there.
2552000	2556000	You said it was object-oriented programming language. I actually never said that.
2557120	2563040	It's always quoted, but I never did. I said C++ supports object-oriented programming
2563040	2569360	but it's not. And other techniques. And that's important because I think that the
2569360	2580080	best solution to most complex interesting problems require ideas and techniques from things that
2580080	2592320	has been called object-oriented data abstraction, function or traditional C-style code, all of the
2592320	2601680	above. And so when I was designing C++, I soon realized I couldn't just add features.
2603520	2608560	If you just add what looks pretty or what people ask for or what you think is good,
2609840	2616560	one by one, you're not going to get a coherent whole. What you need is a set of guidelines that
2617520	2624480	that guides your decisions. Should this feature be in or should this feature be out? How should a
2624480	2631520	feature be modified before it can go in and such? And in the book I wrote about that,
2631520	2637520	the design evolution of C++, there's a whole bunch of rules like that. Most of them are not
2637520	2646000	language technical. They are things like don't violate static type system because I like static
2646000	2654800	type system for the obvious reason that I like things to be reliable on reasonable amounts of
2654800	2663760	hardware. But one of these rules is the zero overhead principle. The zero overhead principle.
2664640	2673520	It basically says that if you have an abstraction, it should not cost anything compared to write
2674080	2684560	the equivalent code at a lower level. So if I have, say, a matrix multiply,
2686000	2692880	it should be written in such a way that you could not drop to the C level of abstraction and
2692880	2699600	use arrays and pointers and such and run faster. And so people have written such
2699680	2706800	matrix multiplications. And they've actually gotten code that ran faster than FORTRAN because
2706800	2712800	once you had the right abstraction, you can eliminate, you can eliminate temporaries and you
2712800	2720000	can do loop fusion and other good stuff like that. That's quite hard to do by hand and in a lower
2720000	2727520	level language. And there's some really nice examples of that. And the key here is that that
2728240	2735840	matrix multiplication, the matrix abstraction allows you to write code that's simple and easy.
2735840	2741360	You can do that in any language. But with C++, it has the features so that you can also have
2741360	2748880	this thing run faster than if you hand coded it. Now, people have given that lecture many times,
2748880	2754800	I and others, and a very common question after the talk where you have demonstrated that you're
2754800	2760160	going to outperform FORTRAN for dense matrix multiplication, people come up and says, yeah,
2760160	2768080	but there was C++. If I rewrote your code and see how much faster would it run? The answer is much
2768080	2774880	slower. This happened the first time actually back in the ages with a friend of mine called
2774880	2783840	Doug McElroy who demonstrated exactly this effect. And so the principle is you should
2783840	2789520	give programmers the tools so that the abstractions can follow the zero word principle.
2790320	2796080	Furthermore, when you put in a language feature on C++ or a standard library feature,
2796080	2802240	you try to meet this. It doesn't mean it's absolutely optimal, but it means if you hand
2802240	2810480	code it with the usual facilities in the language in C++ in C, you should not be able to better it.
2811120	2819440	Usually, you can do better if you use embedded assembler for machine code for some of the
2819440	2824000	details to utilize part of a computer that the compiler doesn't know about,
2824640	2828080	but you should get to that point before you beat the abstraction.
2829120	2834640	So that's a beautiful ideal to reach for. And we meet it quite often.
2835600	2842080	So where's the magic of that coming from? There's some of it is the compilation process. So the
2842080	2850720	implementation is C++. Some of it is the design of the feature itself, the guidelines. So I've
2850720	2858960	recently and often talked to Chris Ladner, so Clang. Just out of curiosity, is your
2859200	2865920	relationship in general with the different implementations of C++, as you think about
2866640	2871280	you and committee and other people in C++, think about the design of new features or design of
2871280	2882720	previous features in trying to reach the ideal of zero overhead? Does the magic come from the design,
2883280	2893840	the guidelines, or from the implementations? And not all. You go for programming technique,
2893840	2898080	program language features, and implementation techniques. You need all three.
2898960	2902880	And how can you think about all three at the same time?
2903680	2909200	It takes some experience, takes some practice, and sometimes you get it wrong. But after a while,
2909200	2914640	you sort of get it right. I don't write compilers anymore. But
2916720	2928240	Brian Kernighan pointed out that one of the reasons C++ succeeded was some of the craftsmanship I put
2928240	2934000	into the early compilers. And of course, I did the language design. Of course, I wrote a fair
2934000	2942160	amount of code using this kind of stuff. And I think most of the successes involves progress in
2942160	2950800	all three areas together. A small group of people can do that. Two, three people can work together
2950800	2955280	to do something like that. It's ideal if it's one person that has all the skills necessary.
2955840	2962560	But nobody has all the skills necessary in all the fields where C++ is used. So if you want to
2962560	2969600	approach my ideal in, say, concurrent programming, you need to know about algorithms of concurrent
2969600	2975680	programming. You need to know the the trigger of lock free programming. You need to know something
2975680	2981920	about the compiler techniques. And then you have to know some of the program areas, sorry,
2981920	2988880	the application areas where this is, like some forms of graphics or some forms of
2988880	2999040	what we call a web serving kind of stuff. And that's very hard to get into a single head.
2999040	3005200	But small groups can do it too. So is there differences in your view?
3006400	3010400	Not saying which is better or so on, but difference in the different implementations
3010400	3016160	of C++? Why are there several sort of maybe naive questions for me?
3017120	3025760	This is a very reasonable question. When I designed C++,
3028560	3036560	most languages have multiple implementations. Because if you run on an IBM, if you run on a
3036560	3042000	Sun, if you run on a Motorola, there was just many, many companies and they each have their
3042000	3048240	own compilation structure, the old compilers, it was just fairly common that there was many of them.
3049200	3056000	And I wrote C front, assuming that other people would write compilers with C++,
3056000	3064400	if successful. And furthermore, I wanted to utilize all the back end infrastructures that
3064400	3069840	were available. I soon realized that my users were using 25 different linkers. I couldn't
3069840	3078640	write my own linker. Yes, I could, but I couldn't write 25 linkers and also get any work done on
3078640	3086560	the language. And so it came from a world where there was many linkers, many optimizers, many
3087200	3096160	compiler front ends, not to start, but many operating systems. The whole world was not an
3096160	3103120	86 and Linux box or something, whatever is the standard today. In the old days, they said a
3103680	3111280	Vax. So basically, I assumed there would be lots of compilers. It was not a decision that there
3111280	3120480	should be many compilers. It was just a fact. That's the way the world is. And yes, many compilers
3121200	3131280	emerged. And today, there's at least four front ends, Clang, GCC, Microsoft, and
3132800	3141520	EDG. It is the same group. They supply a lot of the independent organizations and the embedded
3141520	3148320	systems industry. And there's lots and lots of back ends. We have to think about how many
3148320	3155280	dozen back ends there are, because different machines have different things, especially in the
3155280	3163600	embedded world, the machines are very different. The architectures are very different. And so
3163600	3172240	having a single implementation was never an option. Now, I also happen to dislike monocultures.
3173200	3174400	Monocultures.
3174400	3183120	They are dangerous, because whoever owns the monoculture can go stale and there's no competition
3183120	3190080	and there's no incentive to innovate. There's a lot of incentive to put barriers in the way of
3190080	3196160	change, because, hey, we own the world and it's a very comfortable world for us. And who are you to
3197120	3206800	mess with that? So I really am very happy that there's four front ends for C++. Clang's great,
3207680	3216640	but GCC was great. But then it got somewhat stale. Clang came along and GCC is much better now.
3217280	3218560	Competition is good.
3218560	3227920	Microsoft is much better now. So at least a low number of front end puts a lot of pressure on
3231120	3237840	standards compliance and also on performance and error messages and compile time speed,
3237840	3239360	all this good stuff that we want.
3240000	3247520	Do you think, crazy question, there might come along, do you hope there might come along
3248800	3255280	implementation of C++ written given all of its history written from scratch,
3256480	3258960	so written today from scratch?
3258960	3264400	Well, Clang and the LLVM is more or less written from scratch.
3264880	3270960	But there's been C++ 11, 14, 17, 20, there's been a lot of features.
3270960	3277520	Sooner or later, somebody is going to try again. There has been attempts to write new C++
3277520	3283280	compilers and some of them has been used and some of them has been absorbed into others and such.
3283280	3284080	Yeah, it'll happen.
3285200	3292960	So what are the key features of C++? And let's use that as a way to sort of talk about
3293920	3300880	the evolution of C++, the new feature. So at the highest level, what are the features that were
3300880	3303040	there in the beginning? What features got added?
3304400	3315120	Let's first get a principle or an aim in place. C++ is for people who want to use hardware really
3315200	3319920	well and then manage the complexity of doing that through abstraction.
3321600	3330400	And so the first facility you have is a way of manipulating the machines at a fairly low level.
3330960	3339920	That looks very much like C. It has loops, it has variables, it has pointers like machine
3340000	3349360	addresses, it can access memory directly, it can allocate stuff in the absolute minimum of space
3349360	3356400	needed on the machine. There's a machine facing part of C++, which is roughly equivalent to C.
3357200	3364160	I said C++ could beat C and it can. It doesn't mean I dislike C. If I disliked C, I wouldn't have
3365120	3372480	built on it. Furthermore, after Dennis Ritchie, I'm probably the major contributor to modern C.
3373760	3384480	And well, I had lunch with Dennis most days for 16 years and we never had a harsh word between us.
3384480	3391120	So these C versus C++ fights are for people who don't quite understand what's going on.
3392080	3399040	And then the other part is the abstraction. And there the key is the class, which is a user-defined
3399040	3405520	type. And my idea for the class is that you should be able to build a type that's just like the
3405520	3412880	built-in types in the way you use them, in the way you declare them, in the way you get the
3412880	3421920	memory, and you can do just as well. So in C++, there's an int. As in C, you should be able to
3421920	3429920	build an abstraction, a class, which we can call capital int, that you can use exactly like an
3429920	3437120	integer and run just as fast as an integer. There's the idea right there. And of course,
3437120	3443840	you probably don't want to use the int itself, but it has happened. People have wanted integers
3444720	3449360	that were range checked so that you couldn't overflow and such, especially for very safety
3449360	3456320	critical applications like the fuel injection for a marine diesel engine for the largest ships.
3457040	3463360	This is a real example, by the way. This has been done. They built themselves an integer
3463440	3468800	that was just like integer, except that it couldn't overflow. If there was an overflow,
3468800	3476320	you went into the error handling. And then you built more interesting types. You can build a
3476320	3484160	matrix, which you need to do graphics, or you could build a gnome for a video game.
3485040	3489840	And all of these are classes, and they appear just like the built-in types in terms of efficiency
3489840	3498720	and so on. So what else is there? And flexibility. I don't know. For people who are not familiar with
3498720	3505600	object-oriented programming, there's inheritance. There's a hierarchy of classes. Just like you
3505600	3514880	said, create a generic vehicle that can turn left. What people found was that you don't actually
3515760	3527520	know. How do I say this? A lot of types are related. That is, the vehicles, all vehicles are
3527520	3536000	related. Bicycles, cars, fire engines, tanks. They have some things in common and some things
3536000	3541520	that differ. And you would like to have the common things common and having the differences
3542480	3547520	specific. And when you didn't want to know about the differences, like just turn left,
3549120	3554560	you don't have to worry about it. That's how you get the traditional object-oriented
3554560	3561120	programming coming out of Cmula adopted by Smalltalk and C++ and all the other languages.
3561680	3567360	The other kind of obvious similarity between types comes when you have something like a vector.
3567920	3577280	Fortran gave us a vector called array of doubles. But the minute you have a vector of
3577280	3584560	doubles, you want a vector of double precision doubles and for short doubles, for graphics,
3584560	3591760	and why should you not have a vector of integers while you're at it? Or a vector of
3591760	3601440	vectors and a vector of vectors of chess pieces. Now we have a board, right? So this is, you express
3602400	3609280	the commonality as the idea of a vector and the variations come through parameterization.
3610160	3617440	And so here we get the two fundamental ways of abstracting, of having similarities of
3618400	3624320	types in C++. There's the inheritance and there's a parameterization. There's the object-oriented
3624320	3630080	programming and there's the generic programming. With the templates for the generic programming.
3630080	3638240	Yep. So you've presented it very nicely, but now you have to make all that happen and make it
3638240	3644800	efficient. So generic programming with templates, there's all kinds of magic going on, especially
3645760	3652720	recently, that you can help catch up on. But it feels to me like you can do way more than what
3652720	3658320	you just said with templates. You can start doing this kind of metaprogramming, this kind of...
3658320	3665200	You can do metaprogramming also. I didn't go there in that explanation. We're trying to be very
3665200	3670640	basics, but go back on to the implementation. If you couldn't implement this efficiently,
3671600	3678080	if you couldn't use it so that it became efficient, it has no place in C++ because it
3678080	3686080	will violate the zero overhead principle. So when I had to get object-oriented programming
3686080	3694800	inheritance, I took the idea of virtual functions from Simula. Virtual functions is a Simula term,
3694800	3701680	class is a Simula term. If you ever use those words, say thanks to Christian Nügel and Olio
3701680	3709920	Handahl. And I get the simplest implementation I knew of, which was basically a jump table.
3710880	3717040	So you get the virtual function table, the function goes in, do it, does an interaction
3717040	3721600	through a table and get the right function. That's how you pick the right thing there.
3721600	3729440	And I thought that was trivial. It's close to optimal. And it was obvious. It turned out the
3729440	3735920	Simula had a more complicated way of doing it and therefore slower. And it turns out that most
3735920	3740400	languages have something that's a little bit more complicated, sometimes more flexible,
3740400	3745920	but you pay for it. And one of the strengths of C++ was that you could actually do this
3745920	3752960	object-oriented stuff. And your overhead compared to ordinary functions, there's no
3752960	3761120	indirection, it's sort of in 5, 10, 25 percent of just the core. It's down there. It's not two.
3762800	3768160	And that means you can afford to use it. Furthermore, in C++, you have the distinction
3768160	3774080	between a virtual function and a non-virtual function. If you don't want any overhead,
3774080	3779520	if you don't need the interaction that gives you the flexibility in object-oriented programming,
3779520	3787040	just don't ask for it. So the idea is that you only use virtual functions if you actually need
3787040	3793040	the flexibility. So it's not zero overhead, but it's zero overhead compared to any other
3793040	3804480	way of achieving the flexibility. Now, or to parameterization. Basically, the compiler looks at
3806720	3817040	at the template, say the vector, and it looks at the parameter and then combines the two and
3817040	3823440	generates a piece of code that is exactly as if you're ridden a vector of that specific type.
3824560	3830640	So that's the minimal overhead. If you have many template parameters, you can actually
3830640	3837280	combine code that the compiler couldn't usually see at the same time, and therefore get code
3837280	3845040	that is faster than if you had handwritten the stuff, unless you were very, very clever.
3845040	3853200	So the thing is parameterized code, the compiler fills stuff in during the compilation process,
3853200	3860640	not during runtime. That's right. And furthermore, it gives all the information it's gotten,
3861360	3869040	which is the template, the parameter, and the context of use. It combines the three and generates
3869040	3877120	good code. But it can generate. Now, it's a little outside of what I'm even comfortable
3877120	3883440	thinking about, but it can generate a lot of code. Yes. And how do you, I remember
3884560	3892800	being both amazed at the power of that idea and how ugly the debugging looked.
3893520	3900160	Yes. Debugging can be truly horrid. Come back to this because I have a solution. Anyway,
3901040	3910400	the debugging was ugly. The code generated by C++ has always been ugly because there's these
3910400	3917760	inherent optimizations. A modern C++ compiler has front-end, middle-end, and back-end optimizations.
3917760	3925200	Even Cfront, back in 83, had front-end and back-end optimizations. I actually took the code,
3926800	3933680	generated an internal representation, munched that representation to generate good code.
3934240	3939600	So people say it's not a compiler, it generates C. The reason it generated C was I wanted to use
3939600	3945280	a C's code generators that was really good at back-end optimizations. But I needed front-end
3945360	3956240	optimizations. And therefore, the C I generated was optimized C. The way a really good handcrafted
3956240	3963440	optimizer human could generate it, and it was not meant for humans. It was the output of a program,
3963440	3970960	and it's much worse today. And with templates, it gets much worse still. So it's hard to combine
3971520	3980560	simple debugging with the optimal code, because the idea is to drag in information from different
3980560	3992960	parts of the code to generate machine code. And that's not readable. So what people often do
3993040	4002240	for debugging is they turn the optimizer off. And so you get code that when something in your
4002240	4008480	source code looks like a function core, it is a function core. When the optimizer is turned on,
4009120	4015280	it may disappear, the function core. It may inline. And so one of the things you can do
4016000	4024240	is you can actually get code that is smaller than the function core because you eliminate the
4024240	4032080	function preamble and return. And that's just the operation there. One of the key things when I did
4034560	4041200	templates was I wanted to make sure that if you have, say, a sort algorithm and you give it a
4042160	4050480	sorting criteria, if that sorting criteria is simply comparing things with less than,
4051280	4058880	the code generated should be the less than, not a indirect function core to a comparison
4060480	4067120	object, which is what it is in the source code. But we really want down to the single instruction.
4068080	4075280	And, but anyway, turn off the optimizer and you can debug. The first level of debugging
4076160	4081360	can be done and I always do without the optimization on because then I can see what's going on.
4082000	4090160	And then there's this idea of concepts that put some, now I've never even,
4091120	4097680	I don't know if it was ever available in any form, but it puts some constraints on the stuff
4097680	4105200	you can parameterize, essentially. Let me try and explain this. So yes, it wasn't there
4106400	4113840	10 years ago. We have had versions of it that actually work for the last four or five years.
4114800	4123760	It was a design by Gaby does raise at true sort and me, we were professors and postdocs in Texas
4123760	4133200	at the time. And the implementation by interest sort and has been available for that time.
4134080	4143280	And it is part of C plus plus 20. And this standard library that uses it. So this is
4143280	4153920	becoming really very real. It's available in Klangen and GCC, GCC for a couple of years.
4153920	4160000	And I believe Microsoft is soon going to do it expect all of C plus plus 20 to be available.
4160000	4170160	So in all the major compilers in 20. But this kind of stuff is available now. I'm just saying
4170160	4175760	that because otherwise people might think I was talking about science fiction. And so what I'm going
4175760	4183120	to say is concrete, you can write it today. And there's production uses of it. So the basic idea
4183120	4195040	is that when you have a generic component, like a sort function, the sort function will require
4195040	4203120	at least two parameters, one, a data structure with a given type and a comparison criteria.
4204640	4209920	And these things are related, but obviously you can't compare things if you don't know what the
4209920	4218720	type of things you compare. And so you want to be able to say, I'm going to sort something and it
4218720	4224720	is to be sortable. What does it mean to be sortable? You look it up in the standard, it has to have a
4224720	4231200	it has to be a sequence with a beginning and an end. There has to be random access to that sequence.
4231200	4237200	And there has to be the element types has to be comparable.
4238080	4241280	Which means less than operator can operate on. Yes.
4241280	4247280	Loss of logical operator can operate. Basically what concepts are their compile time predicates,
4247280	4253120	their predicates you can ask, are you a sequence? Yes, I have a beginning and end.
4253920	4259120	Are you a random access sequence? Yes, I have a subscripting and plus.
4261120	4266640	Is your element type something that has a less than? Yes, I have a less than it's and
4267360	4273200	so basically that's the system. And so instead of saying, I will take a parameter of any type,
4273200	4279920	it'll say I'll take something that's sortable. And it's well defined. And so we say, okay,
4280720	4285680	you can sort with less than I don't want less than I want greater than or something I invent.
4285680	4288880	So you have two parameters, the sortable thing and the
4289920	4294960	comparison criteria. And the comparison criteria will say, well, I can,
4297120	4300960	you can write in saying it should operate on the element type.
4302320	4308560	And it has the comparison operations. So that's just simply the fundamental thing.
4308560	4314560	It's compile time predicates. Do you have the properties I need? So it specifies the requirements
4315280	4322240	of the code on the parameters that it gets. It's very similar to types, actually.
4323200	4333280	But operating in the space of concepts. The word concept was used by Alex Stefanov,
4333280	4338160	who is sort of the father of generic programming in the context of C++.
4339520	4345120	You know, there's other places that use that word, but the way we call generic programming is
4345120	4350320	Alex's. And he called them concepts, because he said they're the sort of the fundamental
4350320	4356480	concepts of an area. So they should be called concepts. And we've had concepts all the time.
4356480	4362560	If you look at the K&R book about C, C has arithmetic types, and it has
4363440	4372160	integral types. It says so in the book. And then it lists what they are, and they have
4372160	4378720	certain properties. The difference today is that we can actually write a concept that will ask a
4378720	4385200	type, are you an integral type? Do you have the properties necessary to be an integral type?
4385280	4393360	Do you have plus, minus, divide, and such? So maybe the story of concepts,
4394000	4402720	because I thought it might be part of C++11, C0x, whatever it was at the time.
4407280	4411360	We'll talk a little bit about this fascinating process of standards, because I think it's
4411360	4418080	really interesting for people. It's interesting for me. But why did it take so long? What shapes
4418080	4428320	did the idea of concepts take? What were the challenges? Back in 1987 or thereabouts? 1987?
4429120	4434960	Well, 1987 or thereabouts. When I was designing templates, obviously, I wanted to express the
4434960	4442720	notion of what is required by a template of its arguments. And so I looked at this.
4443280	4450400	And basically, for templates, I wanted three properties. I wanted to be very flexible.
4451040	4459040	It had to be able to express things I couldn't imagine, because I know I can't imagine everything,
4459040	4465680	and I've been suffering from languages that try to constrain you to only do what the designer
4465680	4474640	thought good. I didn't want to do that. Secondly, it had to run as fast or faster than hand-written
4474640	4482080	code. So basically, if I have a vector of t and I take a vector of char, it should run as fast as
4482080	4490560	you build a vector of char yourself without parameterization. And thirdly, I wanted to be
4490560	4500480	able to express the constraints of the arguments, have proper type checking of the interfaces,
4501680	4509360	and neither I nor anybody else at the time knew how to get all three. And I thought for C++,
4509360	4517600	I must have the two first. Otherwise, it's not C++. And it bothered me for another couple of decades
4517600	4524320	that I couldn't solve the third one. I mean, I was the one that put function argument type checking
4524320	4530640	into C. I know the value of good interfaces. I didn't invent that idea. It's very common,
4530640	4538240	but I did it. And I wanted to do the same for templates, of course, and I couldn't. So it bothered
4538240	4548400	me. Then we tried again, 2002, 2003. Gaby just raised and I started analyzing the problem,
4549200	4557360	explained possible solutions. It was not a complete design. A group in University of Indiana,
4558480	4565520	an old friend of mine, they started a project at Indiana and
4568880	4575600	we thought we could get a good system of concepts in another two or three years.
4577360	4589280	That would have made C++ 11 to C++ 06 or 07. Well, it turned out that I think we got a lot
4589360	4598400	of the fundamental ideas wrong. They were too conventional. They didn't quite fit C++, in my
4598400	4606560	opinion. Didn't serve implicit conversions very well. It didn't serve mixed type arithmetic,
4606560	4612640	mixed type computations very well. A lot of stuff came out of the functional
4613200	4625600	community. That community didn't deal with multiple types in the same way as C++ does,
4626240	4633280	had more constraints on what you could express, and didn't have the draconian
4634000	4640480	performance requirements. Basically, we tried. We tried very hard. We had some successes,
4641360	4649440	but it just in the end wasn't. Didn't compile fast enough, was too hard to use,
4650320	4659600	and didn't run fast enough unless you had optimizers that was beyond the state of the art.
4659600	4668080	They still are. We had to do something else. Basically, it was the idea that a set of parameters
4668560	4674480	has defined a set of operations, and you go through an interaction table just like for
4674480	4681440	virtual functions, and then you try to optimize the interaction away to get performance.
4682720	4690960	We just couldn't do all of that. Get back to the standardization. We are standardizing C++
4690960	4698400	under ISO rules, which are very open process. People come in. There's no requirements for
4698400	4708560	education or experience. You've started to develop C++. When was the first standard
4708560	4714720	established? What is that like, the ISO standard? Is there a committee that you're referring to?
4714720	4719840	Sure. There's a group of people. What's that like? How often do you meet? What's the discussion?
4719840	4732800	I'll try and explain that. Sometime in early 1989, two people, one from IBM, one from HP,
4732800	4738560	turned up in my office and told me I would like to standardize C++.
4740400	4748240	This was a new idea to me. I pointed out that it wasn't finished yet, and it wasn't ready for
4748240	4754000	formal standardization and such. They said, no, Brianna, you haven't gotten it. You really want to
4754000	4763440	do this. Our organizations depend on C++. We cannot depend on something that's owned by
4763440	4770400	another corporation that might be a competitor. Of course, we could rely on you, but you might
4770400	4777120	get run over by a boss. We really need to get this out in the open. It has to be
4778080	4788160	standardized under formal rules. We are going to standardize it under ISO rules,
4788800	4793040	and you really want to be part of it because, basically, otherwise, we'll do it ourselves.
4795120	4803600	We know you can do it better. Through a combination of arm twisting and flattery,
4804560	4806560	it got started. In late
4808800	4817360	in late 89, there was a meeting in DC at the, actually, no, it was not ISO,
4817360	4820720	then it was ANSI, the American National Standard we're doing.
4823280	4828800	We met there. We were lectured on the rules of how to do an ANSI standard.
4828800	4834320	There was about 25 of us there, which apparently was a new record for that kind of meeting.
4837120	4842400	Some of the old C guys that has been standardized in C was there, so we got some expertise in.
4843360	4849200	The way this works is that it's an open process. Anybody can sign up if they pay the
4849200	4858800	minimal fee, which is about $1,000. It's a little bit more now. I think it's $1,280.
4859920	4867360	It's not going to kill you. We have three meetings a year. This is fairly standard.
4868320	4876480	We tried two meetings a year for a couple of years that didn't work too well. Three one-week
4876480	4884720	meetings a year. You meet and you have technical meetings, technical discussions,
4884720	4891120	and then you bring proposals forward for votes. The votes are done one person per
4892560	4900560	one vote per organization, so you can't have, say, IBM come in with 10 people and
4900560	4904560	dominate things that's not allowed. These are organizations that extents to the
4904560	4916000	UC++ or individuals. It's a bunch of people in the room deciding the design of a language
4916000	4923840	based on which a lot of the world's systems run. Right. Well, I think most people would agree it's
4923840	4931920	better than if I decided it, or better than if a single organization like AG&C decided it.
4931920	4937520	I don't know if everyone agrees to that, by the way. Bureaucracies have their critics too.
4937520	4945680	Yes. Look, standardization is not pleasant. It's horrifying.
4945680	4946720	It's like democracy.
4946720	4952560	But we, exactly. As Churchill says, democracy is the worst way except for the others.
4953520	4956560	And it's about, say, the same performance standardization.
4957200	4964880	But anyway, so we meet and we have these votes and that determines what the standard is.
4965760	4973920	Couple of years later, we extended this so it became worldwide. We have standard organizations
4973920	4988320	that are active in currently 15 to 20 countries and another 15 to 20 are sort of looking and voting
4989440	4996160	based on the rest of the work on it. And we meet three times a year. Next week, I'll be in Cologne,
4996240	5004000	Germany, spending a week doing standardization. And then we will vote out the committee draft
5004000	5013600	or C++20, which goes to the national standards committees for comments and requests for changes
5013600	5019680	and improvements. Then we do that. And there's a second set of votes where hopefully everybody
5019680	5027040	votes in favor. This has happened several times. The first time we finished, we started in the
5027040	5035760	first technical meeting was in 1990. The last was in 98. We voted it out. That was the standard
5035760	5042880	that people used till 11 or a little bit past 11. And it was an international standard.
5043600	5052320	All the countries voted in favor. It took longer with 11. I'll mention why, but all the
5052320	5061920	nations voted in favor. And we work on the basis of consensus. That is, we do not want something
5061920	5069440	that passes 60-40, because then we're getting dialects and opponents and people complain too
5069920	5076400	much. They all complain too much. But basically, it has no real effect. The standards have been
5076400	5084320	obeyed. They have been working to make it easier to use many compilers, many computers, and all
5084320	5092000	of that kind of stuff. And so the first, it was traditional with ISO standards to take 10 years.
5092560	5098640	We did the first one in eight, brilliant. And we thought we were going to do the next one in six,
5098640	5108240	because now we're good at it. It took 13. Yeah, it was named OX. It was named OX.
5108240	5113520	Hoping that you would at least get it within the single, within the odds, the single digits.
5113520	5117600	I thought we would get, I thought we would get six, seven, or eight.
5117600	5123120	The confidence of youth. That's right. Well, the point is that this was sort of like a second
5124080	5129200	system effect. That is, we now knew how to do it. And so we're going to do it much better.
5129200	5135680	And we've got more ambitious. And it took longer. Furthermore, there is this tendency,
5135680	5145200	because it's a 10-year cycle, or age, doesn't matter. Just before you're about to ship,
5145280	5153760	somebody has a bright idea. And so we really, really must get that in.
5155440	5164000	We did that successfully with the STL. We got the standard library that gives us all the STL
5164000	5171040	stuff. That basically, I think it saved C++. It was beautiful. And then people tried it with other
5171040	5177520	things. And it didn't work so well. They got things in, but it wasn't as dramatic. And it took
5177520	5186720	longer and longer and longer. So after C++ 11, which was a huge improvement, and what basically
5186720	5195760	what most people are using today, we decided never again. And so how do you avoid those slips?
5196480	5205200	And the answer is that you ship more often. So that if you have a slip on a 10-year cycle,
5206480	5212400	by the time you know it's a slip, there's 11 years till you get it. Now with a three-year cycle,
5213200	5221280	there is about four years till you get it. Like the delay between feature freeze and
5222080	5229680	shipping. So you always get one or two years more. And so we shipped 14 on time. We shipped
5230240	5239680	17 on time. And we will ship 20 on time. It'll happen. And furthermore, this
5239680	5245680	allows, this gives a predictability that allows the implementers, the compiler implementers,
5245760	5253680	the library implementers, they have a target and they deliver on it. 11 took two years before
5254400	5262000	most compilers were good enough. 14, most compilers were actually getting pretty good in 14.
5263040	5271360	17, everybody shipped in 17. We are going to have at least almost everybody ship,
5271360	5279120	almost everything in 20. And I know this because they're shipping in 19. Predictability is good,
5279120	5283920	delivery on time is good. And so, yeah. That's great. That's how it works.
5285920	5292640	There's a lot of features that came in in C++ 11. There's a lot of features at the birth of C++
5293280	5300320	that were amazing and ideas with concepts in 2020. What to you is the most,
5301840	5312480	just to you personally, beautiful or just do you sit back and think, wow, that's just nice
5313280	5322160	clean feature of C++? I have written two papers for the history of programming languages
5322160	5328400	conference, which basically asked me such questions. And I'm writing a third one, which I will
5328400	5334800	deliver at the history of programming languages conference in London next year. So I've been
5334800	5341440	thinking about that. And there is one clear answer, constructors and destructors. The way a
5341440	5349600	constructor can establish the environment for the use of a type for an object and the destructor
5349680	5356800	cleans up any messes at the end of it. That is the key to C++. That's why we don't have to use
5356800	5362800	garbage collection. That's how we can get predictable performance. That's how you can get
5363680	5372160	the minimal overhead in many, many cases and have really clean types. It's the idea of
5372160	5381280	constructor-destructor pairs. Sometimes it comes out under the name RII, resource acquisition is
5381280	5386400	initialization, which is the idea that you grab resources and the constructor and release them
5386400	5394160	in destructor. It's also the best example of why I shouldn't be in advertising. I get the best idea
5394160	5401440	and I call it resource acquisition is initialization. Not the greatest naming I've ever heard.
5403120	5413600	So it's types, abstraction of types. You said, I want to create my own types.
5413600	5420960	So types is an essential part of C++ and making them efficient is the key part.
5421920	5429040	And to you, this is almost getting philosophical, but the construction and the destruction,
5429040	5435760	the creation of an instance of a type and the freeing of resources from that
5436400	5444480	instance of a type is what defines the object. That's almost like birth and death is what
5444480	5450880	defines human life. Yeah, that's right. By the way, philosophy is important. You can't do
5451680	5457680	good language design without philosophy because what you are determining is what people can express
5457680	5466720	and how. This is very important. By the way, constructors, destructors came into C++ in 79
5467520	5474160	in about the second week of my work with what was then called C++. It is a fundamental idea.
5475200	5481280	Next comes the fact that you need to control copying because once you control, as you said,
5481280	5488480	birth and death, you have to control taking copies, which is another way of creating an object.
5489280	5495200	And finally, you have to be able to move things around so you get the move operations.
5495200	5500480	And that's the set of key operations you can define on a C++ type.
5501840	5511040	And so to you, those things are just a beautiful part of C++ that is at the core of it all.
5511440	5516800	Yes. You mentioned that you hope there will be one unified set of guidelines
5516800	5522320	in the future for how to construct the programming language. So perhaps not one programming language,
5522320	5530160	but a unification of how we build programming languages, if you remember such statements.
5530160	5535040	I have some trouble remembering it, but I know the origin of that idea.
5535040	5540000	So maybe you can talk about sort of C++ has been improving. There's been a lot of programming
5540000	5546480	language. Where does the archer history taking us? Do you hope that there is a unification about
5547040	5550480	the languages with which we communicate in the digital space?
5552560	5562400	Well, I think that languages should be designed not by clobbering language features together and
5563440	5567920	doing slightly different versions of somebody else's ideas, but through
5568880	5576080	the creation of a set of principles, rules of thumbs, whatever you call them.
5577200	5585280	I made them for C++ and we're trying to teach people in the Standards Committee about these
5585280	5589680	rules because a lot of people come in and say, I've got a great idea. Let's put it in the language.
5590400	5595600	And then you have to ask, why does it fit in the language? Why does it fit in this language?
5595680	5601680	It may fit in another language and not here or it may fit here and not the other language.
5601680	5606240	So you have to work from a set of principles and you have to develop that set of principles.
5607200	5618880	And one example that I sometimes remember is I was sitting down with some of the designers of
5618880	5625760	Common Lisp and we were talking about languages and language features and
5626880	5633440	obviously we didn't agree about anything because, well, Lisp is not C++ and vice versa.
5633440	5635040	It's too many parentheses.
5635040	5645120	But suddenly we started making progress. I said, I had this problem and I developed it
5645120	5649840	according to these ideas and they said, why? We had that problem, different problem,
5649840	5654800	and we developed it with the same kind of principles. And so we worked through
5656560	5663600	large chunks of C++ and large chunks of Common Lisp and figured out we actually had
5664320	5671200	similar sets of principles of how to do it. But the constraints on our designs were very
5671200	5678480	different and the aims for the usage was very different. But there was commonality
5679200	5685840	in the way you reason about language features and the fundamental principles you were trying to do.
5686400	5693200	So do you think that's possible to order? So just like there is perhaps a unified theory of
5693920	5698720	physics, of the fundamental forces of physics, I'm sure there is
5699680	5705840	commonalities among the languages, but there's also people involved that help
5705840	5712560	drive the development of these languages. Do you have a hope or an optimism that
5712560	5719440	there will be a unification if you think about physics in Einstein towards a simplified
5720080	5722720	language? Do you think that's possible?
5723440	5731680	So let's remember sort of modern physics, I think started with Galileo in the 1300s. So
5731680	5740960	they've had 700 years to get going. Modern computing started in about 49. We've got,
5741680	5749520	what is that, 70 years. They have 10 times. And furthermore, they're not as bothered with
5749600	5757360	people using physics the way we are worried about programming. It's done by humans. So
5758240	5764720	each have problems and constraints the others have, but we are very immature compared to physics.
5767360	5774000	So I would look at sort of the philosophical level and look for fundamental principles.
5774800	5784160	Like you don't leak resources, you shouldn't. You don't take errors at runtime that you don't
5784160	5792080	need to. You don't violate some kind of type system. There's many kinds of type systems,
5792080	5799120	but when you have one, you don't break it, et cetera, et cetera. There will be quite a few.
5799920	5806960	And it will not be the same for all languages. But I think if we step back at some kind of
5806960	5815280	philosophical level, we would be able to agree on sets of principles that applied to sets of
5815280	5826880	problem areas. And within an area of use, like in C++'s case, what used to be called systems
5826880	5833200	programming, the area between the hardware and the fluffier parts of the system,
5834640	5841360	you might very well see a convergence. So these days, you see Rust having adopted RAII.
5842080	5847360	And some time accuses me for having borrowed it 20 years before they discovered it. But
5848320	5857920	it's, we're seeing some kind of convergence here instead of relying on garbage collection all
5857920	5865920	the time. The garbage collection languages are doing things like the dispose patterns and such
5865920	5872480	that imitate some of the construction, destruction stuff. And they're trying not to use the garbage
5872480	5877840	collection all the time and things like that. So there's a conversion. But I think we have
5877840	5883040	to step back to the philosophical level, agree on principles, and then we'll see some conversions,
5884320	5890720	convergences, and it will be application domain specific.
5892160	5897600	So a crazy question, but I work a lot with machine learning with deep learning. I'm not
5897600	5904720	sure if you touched that world much. But you could think of programming as a thing that takes
5904720	5910160	some input. Programming is the task of creating a program. And the program takes some input and
5910160	5918720	produces some output. So machine learning systems train on data in order to be able to take an input
5918720	5928240	and produce output. But they're messy, fuzzy things, much like we as children grow up,
5928880	5933360	you know, we take some input, we make some output, but we're noisy, we mess up a lot,
5933360	5940560	we're definitely not reliable biological system or a giant mess. So there's a sense in which
5940560	5947520	machine learning is a kind of way of programming, but just fuzzy. It's very, very, very different
5947520	5954880	than C plus plus. Because C plus plus is like it's just like you said, it's extremely reliable.
5954880	5960240	It's efficient. It's, you know, you can you can measure you can test in a bunch of different ways
5961280	5965040	with biological systems or machine learning systems, you can't say
5966240	5971920	much, except sort of empirically saying that 99.8% of the time, it seems to work.
5971920	5979920	What do you think about this fuzzy kind of programming? Do you even see it as programming?
5979920	5982880	Is it solely and totally another kind of world?
5983600	5990160	I think it's a different kind of world. And it is fuzzy. And in my domain, I don't like fuzziness.
5991520	5997840	That is, people say things like they want everybody to be able to program.
5997840	6007200	But I don't want everybody to program my, my, my, my, my airplane controls or the car controls.
6008160	6013920	I want that to be done by engineers. I want that to be done with people that are specifically
6013920	6023840	educated and trained for doing building things. And it is not for everybody. Similarly, a language
6023840	6033760	like C++ is not for everybody. It is generated to be a sharp and effective tool for professionals,
6033760	6040000	basically, and definitely for people who, who, who aim at some kind of precision.
6040800	6048000	You don't have people doing calculations without understanding math, right? Counting on your fingers
6048000	6055520	is not going to cut it if you want to fly to the moon. And so there are areas where
6056960	6068560	an 84% accuracy rate, 16% false positive rate is perfectly acceptable and where people will
6068560	6077280	probably get no more than 70. You said 98%. I, what I've seen is more like 84. And by,
6077760	6081520	really, a lot of blood, sweat and tears, you can get up to the 92 and a half.
6082880	6093760	So this is fine if it is say pre-screening stuff before the human look at it. It is not
6093760	6101120	good enough for, for life-threatening situations. And so there's lots of areas where, where the
6101120	6106800	fuzziness is perfectly acceptable and good and better than humans, cheaper than humans.
6107600	6114400	But it's not the kind of engineering stuff I'm mostly interested in. I worry a bit about
6115200	6120240	machine learning in the context of cars. You know, much more about this than I do.
6120240	6121360	I worry too.
6121360	6127840	But I'm, I'm, I'm sort of an amateur here. I've read some of the papers, but I've not ever done it.
6128640	6137200	And the, the, the idea that scares me the most is the one I have heard and I don't know how
6137200	6148560	common it is that you have this AI system, machine learning, all of these trained neural
6148560	6155440	nets. And when there's something that's too complicated, they ask the human for help.
6156160	6164720	But the human is reading a book or sleep and he has 30 seconds or three seconds to figure out
6164720	6170800	what the problem was that the AI system couldn't handle and do the right thing. This is scary.
6172000	6175920	I mean, how do you do the cut-over between the machine and the human?
6176400	6187280	It's very, very difficult. And for the designer of one of the most reliable, efficient and powerful
6187280	6195600	programming languages, C++, I can understand why that world is actually unappealing. It is for
6195600	6202240	most engineers. To me, it's extremely appealing because we don't know how to get that interaction
6202240	6208480	right, but I think it's possible, but it's very, very hard. It is. I mean, I was stating a problem,
6208480	6213680	not a solution. That is possible. I mean, I would much rather never rely on a human. If you're
6213680	6220080	driving a nuclear reactor, if you're or an autonomous vehicle, it's much better to design
6220080	6227280	systems written in C++ that never ask human for help. Let, let, let's just get one fact in.
6227440	6231360	Yeah. All of this AI stuff is on top of C++.
6233760	6240080	So, so that's one reason I have to keep a weather eye out on what's going on in that field, but I
6240080	6244960	will never become an expert in that area. But it's a good example of how you separate
6245760	6251200	different areas of applications, and you have to have different tools, different principles.
6251840	6258640	And then they interact. No major system today is written in one language, and there are good
6258640	6269520	reasons for that. When you look back at your life work, what is a, what is a moment? What is a event
6270960	6275760	creation that you're really proud of? They say, damn, I did pretty good there.
6276320	6279440	Is it as obvious as the creation of C++?
6279440	6287680	It's obvious. I've spent a lot of time with C++ and there's a combination of a few good ideas,
6287680	6294480	a lot of hard work and a bit of luck. And I've tried to get away from it a few times,
6294480	6301200	but I get dragged in again, partly because I'm most effective in this area and partly because
6301920	6308400	partly because what I do has much more impact if I do it in the context of C++.
6308400	6314400	So I have four and a half million people that pick it up tomorrow if I get something right.
6314400	6318800	If I did it in another field, I would have to start learning, then I have to build it and then
6318800	6326960	we'll see if anybody wants to use it. One of the things that has kept me going for all of these
6326960	6334400	years is one, the good things that people do with it and the interesting things they do with it.
6334960	6341040	And also, I get to see a lot of interesting stuff and talk to a lot of interesting people.
6343440	6350880	I mean, if it has just been statements on paper or on a screen, I don't think I could have kept
6350880	6358480	going. But I get to see the telescopes up on Mauna Kea and I actually went and see how Ford
6358480	6369600	built cars and I got to JPL and see how they do the Mars rovers. There's so much cool stuff going on
6369600	6374800	and most of the cool stuff is done by pretty nice people and sometimes in very nice places,
6375760	6387440	Cambridge, Sofia and C++, Silicon Valley. There's more to it than just code, but code is central.
6389120	6393520	On top of the code are the people in very nice places. Well, I think I speak for
6394400	6402000	millions of people. We are in saying thank you for creating this language that so many
6402560	6408880	systems are built on top of that make a better world. So thank you and thank you for talking
6408880	6412320	today. Yeah, thanks and we'll make it even better. Good.
