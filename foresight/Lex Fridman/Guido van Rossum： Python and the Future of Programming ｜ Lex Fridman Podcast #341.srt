1
00:00:00,000 --> 00:00:10,800
Can you imagine possible features that Python 4.0 might have that would necessitate the creation

2
00:00:10,800 --> 00:00:20,000
of the new 4.0 given the amount of pain and joy, suffering and triumph that was involved in the

3
00:00:20,000 --> 00:00:27,280
move between version 2 and version 3? The following is a conversation with Guido van

4
00:00:27,280 --> 00:00:32,960
Rossum, his second time on this podcast. He is the creator of the Python programming language

5
00:00:32,960 --> 00:00:40,960
and is Python's emeritus BDFL, benevolent dictator for life. This is the Lex Friedman podcast.

6
00:00:40,960 --> 00:00:46,000
To support it, please check out our sponsors in the description. And now dear friends,

7
00:00:46,000 --> 00:00:53,040
here's Guido van Rossum. Python 3.11 is coming out very soon. In it,

8
00:00:53,040 --> 00:01:00,480
Cpython claimed to be 10 to 60% faster. How did you pull that off? And what's Cpython?

9
00:01:00,480 --> 00:01:06,480
Cpython is the last Python implementation standing also the first one that was ever created. The

10
00:01:06,480 --> 00:01:12,000
original Python implementation that I started over 30 years ago. So what does it mean that Python,

11
00:01:12,000 --> 00:01:16,800
the programming language is implemented in another programming language called C?

12
00:01:16,800 --> 00:01:21,280
What kind of audience do you have in mind here? People who know programming?

13
00:01:21,280 --> 00:01:25,680
No, there's somebody on a boat that's into fishing and have never heard about programming,

14
00:01:25,680 --> 00:01:30,080
but also some world-class programmers. You're going to have to speak to both. Imagine a boat

15
00:01:30,080 --> 00:01:34,720
with two people. One of them has not heard about programming is really into fishing.

16
00:01:34,720 --> 00:01:41,440
And the other one is like an incredible Silicon Valley programmer that's programmed in everything.

17
00:01:41,440 --> 00:01:47,440
C, C++, Python, Rust, Java. It knows the entire history of programming languages. So you're going

18
00:01:47,440 --> 00:01:52,640
to have to speak to both. I imagine that boat in the middle of the ocean. I'm going to please

19
00:01:52,640 --> 00:01:59,120
the guy who knows how to fish first. Yes, please. He seems like the most useful in the middle of

20
00:01:59,120 --> 00:02:05,920
the ocean. You got to make him happy. I'm sure he has a cell phone. So he's probably very suspicious

21
00:02:05,920 --> 00:02:11,120
about what goes on in that cell phone, but he must have heard that inside a cell phone is a tiny

22
00:02:11,120 --> 00:02:16,960
computer. And a programming language is computer code that tells the computer what to do.

23
00:02:17,440 --> 00:02:24,080
Very low-level language. It's zeros and ones, and then there's assembly, and then...

24
00:02:24,080 --> 00:02:30,320
Oh, yeah. We don't talk about these really low levels because those just confuse people. I mean,

25
00:02:30,960 --> 00:02:35,920
when we're talking about human language, we're not usually talking about vocal tracts and

26
00:02:35,920 --> 00:02:41,280
how you position your tongue. I was talking yesterday about how when you have a Chinese person

27
00:02:42,000 --> 00:02:47,760
and they speak English, this is a bit of a stereotype. They often don't know...

28
00:02:48,720 --> 00:02:55,280
They can't seem to make the difference well between an L and an R. And I have a theory about

29
00:02:55,280 --> 00:03:02,560
that, and I've never checked this with linguists, that it probably has to do with the fact that

30
00:03:02,560 --> 00:03:08,640
in Chinese, there is not really a difference. And it could be that there are regional variations

31
00:03:08,640 --> 00:03:17,760
in how native Chinese speakers pronounce that one sound that sounds like L to some of them,

32
00:03:17,760 --> 00:03:24,080
like R to others. So, it's both the sounds you produce with your mouth throughout the history

33
00:03:24,080 --> 00:03:29,200
of your life and what you're used to listening to. I mean, every language has that. Russian has...

34
00:03:29,200 --> 00:03:32,400
Exactly. The Slavic languages have sounds like the letters

35
00:03:32,960 --> 00:03:38,560
like Americans or English speakers don't seem to know the sounds.

36
00:03:40,880 --> 00:03:48,160
They seem uncomfortable with that sound. Yeah. Oh, yes. Okay. So, we're not going to the shapes

37
00:03:48,160 --> 00:03:53,440
of tongues and the sounds that the mouth can make. Fine. And similarly, we're not going into the

38
00:03:53,440 --> 00:03:59,760
ones and zeros or machine language. I would say a programming language is a list of instructions

39
00:03:59,840 --> 00:04:08,240
like a cookbook recipe that sort of tells you how to do a certain thing, like make a sandwich. Well,

40
00:04:09,280 --> 00:04:16,480
acquire a loaf of bread, cut it in slices, take two slices, put mustard on one, put

41
00:04:18,000 --> 00:04:24,640
jelly on the other or something, then add the meat, then add the cheese. I've heard that science

42
00:04:24,640 --> 00:04:31,520
teachers can actually do great stuff with recipes like that and trying to interpret their students'

43
00:04:31,520 --> 00:04:36,400
instructions incorrectly until the students are completely unambiguous about it.

44
00:04:37,360 --> 00:04:42,160
With language, see, that's the difference between natural languages and programming languages.

45
00:04:42,800 --> 00:04:49,200
I think ambiguity is a feature, not a bug in human spoken languages. Like,

46
00:04:50,640 --> 00:04:53,120
that's the dance of communication between humans.

47
00:04:53,120 --> 00:05:01,520
Well, for lawyers, ambiguity certainly is a feature. For plenty of other cases,

48
00:05:02,240 --> 00:05:09,520
the ambiguity is not much of a feature, but we work around it, of course. What's more important

49
00:05:09,520 --> 00:05:16,800
is context. So, with context, the precision of the statement becomes more and more concrete, right?

50
00:05:16,800 --> 00:05:21,440
But, you know, when you say, I love you to a person that matters a lot to you,

51
00:05:22,320 --> 00:05:26,160
the person doesn't try to compile that statement and return an error saying,

52
00:05:26,160 --> 00:05:34,160
please define love, right? No, but I imagine that my wife and my son interpreted very differently.

53
00:05:35,440 --> 00:05:38,560
Yes. Even though it's the same three words. But in precisely still.

54
00:05:39,920 --> 00:05:45,040
Oh, for sure. Well, lawyers have a lot of follow-up questions for you. Nevertheless,

55
00:05:45,040 --> 00:05:52,160
the context is already different in that case. Yes, fair enough. So, that's a programming language

56
00:05:52,160 --> 00:06:00,720
is ability to unambiguously state a recipe. Actually, let's go back. Let's go to Pepe.

57
00:06:01,360 --> 00:06:08,000
You go through in Pepe, the style guide for Python code, some ideas of what this language should

58
00:06:08,000 --> 00:06:14,560
look like, feel like, read like. And the big idea there is that code readability counts.

59
00:06:14,560 --> 00:06:19,040
What does that mean to you? And how do we achieve it? So, this recipe should be readable.

60
00:06:19,040 --> 00:06:26,320
That's a thing between programmers. Because on the one hand, we always explain the concept of

61
00:06:26,320 --> 00:06:33,760
programming language as computers need instructions and computers are very dumb and they need very

62
00:06:33,760 --> 00:06:39,120
precise instructions because they don't have much context. In fact, they have lots of context,

63
00:06:39,120 --> 00:06:46,880
but their context is very different. But what we've seen emerge during the development of

64
00:06:46,880 --> 00:06:56,400
software starting in the probably in the late 40s is that software is a very social activity.

65
00:06:56,400 --> 00:07:02,400
A software developer is not a mad scientist who sits alone in his lab writing brilliant code.

66
00:07:02,720 --> 00:07:11,360
A software is developed by teams of people. Even the mad scientist sitting alone in his lab

67
00:07:11,360 --> 00:07:17,600
can't type fast enough to produce enough code so that by the time he's done with his coding,

68
00:07:17,600 --> 00:07:25,280
he still remembers what the first few lines he wrote mean. So, even the mad scientist coding

69
00:07:25,280 --> 00:07:35,520
alone in his lab would be sort of wise to adopt conventions on how to format the instructions

70
00:07:35,520 --> 00:07:41,840
that he gives to the computer so that the thing is there is a difference between a cookbook recipe

71
00:07:41,840 --> 00:07:48,640
and a computer program. The cookbook recipe, the author of the cookbook writes it once

72
00:07:49,440 --> 00:07:56,320
and then is printed in 100,000 copies and then lots of people in their kitchens try to

73
00:07:56,320 --> 00:08:06,240
recreate that recipe, that particular pie or dish from the recipe. And so there the

74
00:08:07,920 --> 00:08:14,880
goal of the cookbook author is to make it clear to the human reader of the recipe,

75
00:08:14,880 --> 00:08:25,360
the human amateur chef in most cases. When you're writing a computer program, you have two audiences

76
00:08:25,360 --> 00:08:38,000
at once. It needs to tell the computer what to do but it also is useful if that program is readable

77
00:08:38,000 --> 00:08:45,200
by other programmers because computer software unlike the typical recipe for a cherry pie

78
00:08:45,840 --> 00:08:55,360
is so complex that you don't get all of it right at once. You end up with the activity of debugging

79
00:08:55,920 --> 00:08:59,280
and you end up with the activity of... So debugging is

80
00:09:02,080 --> 00:09:05,840
trying to figure out why your code doesn't run the way you thought it should run.

81
00:09:06,480 --> 00:09:09,760
That means broadly it could be stupid little errors or it could be big

82
00:09:10,400 --> 00:09:19,920
logical errors. It could be anything from a typo to a wrong choice of algorithm to

83
00:09:20,960 --> 00:09:25,440
building something that does what you tell it to do but that's not useful.

84
00:09:26,480 --> 00:09:33,840
Yeah it seems to work really well 99% of the time but does weird things 1% of the time on some

85
00:09:33,840 --> 00:09:39,920
edge cases. That's pretty much all software nowadays. All good software right? Well yeah for

86
00:09:39,920 --> 00:09:46,080
for bad software then. That 99 goes down a lot so but it's not just about the complexity of the

87
00:09:46,080 --> 00:09:53,680
program it's like you said it is a social endeavor in that you're constantly improving that recipe

88
00:09:53,680 --> 00:10:00,000
for the cherry pie. But you're sort of you're in a group of people improving that recipe

89
00:10:00,720 --> 00:10:07,680
or the mad scientist is improving the recipe that he created a year ago and making it better

90
00:10:08,640 --> 00:10:15,680
or adding something. He decides that he wants I don't know he wants some decoration on his pie

91
00:10:15,680 --> 00:10:21,920
or icing or... So there's broad philosophical things and there's specific advice on style.

92
00:10:22,560 --> 00:10:25,920
So first of all the thing that people first experience when they look at Python

93
00:10:26,880 --> 00:10:33,200
there is a it is very readable but there's also like a spatial structure to it.

94
00:10:34,080 --> 00:10:40,880
Can you explain the indentation style of Python and what is the magic to it? Spaces are important

95
00:10:40,880 --> 00:10:50,080
for readability of any kind of text. If you take a cookbook recipe and you remove all the sort of

96
00:10:50,800 --> 00:10:57,280
all the bullets and other markup and you just crunch all the text together maybe you leave the

97
00:10:57,280 --> 00:11:04,160
spaces between the words but that's all you leave. When you're in the kitchen trying to figure out

98
00:11:04,160 --> 00:11:10,320
oh what are the ingredients and what are the steps and where does this step end and the next step

99
00:11:10,320 --> 00:11:16,880
begin you're going to have a hard time if it's if it's just one solid block of text. On the other

100
00:11:17,520 --> 00:11:22,800
On the other hand what what a typical cookbook does if the paper is not too expensive

101
00:11:23,840 --> 00:11:30,400
each recipe starts on its own page maybe there's a picture next to it. The list of ingredients comes

102
00:11:30,400 --> 00:11:38,000
first there's a standard notation there's there's shortcuts so that you don't have to

103
00:11:38,720 --> 00:11:44,560
sort of write two sentences on how you have to cut the onion because there are only three ways

104
00:11:44,560 --> 00:11:50,320
that people ever cut onions in the kitchen small medium and in slices or something like that.

105
00:11:51,520 --> 00:11:55,600
Right. None of my examples make any sense to real cooks of course but yeah.

106
00:11:57,920 --> 00:12:03,600
We're talking to programmers with the metaphor of cooking I love it but there is a strictness to

107
00:12:03,600 --> 00:12:10,640
the spacing that Python defines so there's some looser things some stricter things but the four

108
00:12:10,720 --> 00:12:18,960
spaces for the indentation is really interesting it really defines what the language looks and

109
00:12:18,960 --> 00:12:25,760
feels like. Because indentation sort of taking a block of text and then having inside that block

110
00:12:25,760 --> 00:12:34,480
of text a smaller block of text that is indented further as sort of a group it's like you have

111
00:12:35,040 --> 00:12:42,800
a bulleted list in a complex business document and inside some of the bullets are other bulleted

112
00:12:42,800 --> 00:12:51,280
lists you will indent those two if each bulleted list is indented several inches then at two levels

113
00:12:51,280 --> 00:12:57,360
deep there's no no space left on the page to put any of the words of the text so you can't indent

114
00:12:57,360 --> 00:13:03,920
too far on the other hand if you don't indent at all you can tell whether something is a top level

115
00:13:03,920 --> 00:13:10,400
bullet or a second level bullet or a third level bullet so you have to have some compromise and

116
00:13:11,760 --> 00:13:19,920
based on ancient conventions and the sort of the typical width of a computer screen in the 80s

117
00:13:21,600 --> 00:13:29,520
and all sorts of things sort of we came up with sort of four spaces as a compromise

118
00:13:30,240 --> 00:13:37,280
I mean there there are groups there are large groups of people who code with two spaces per

119
00:13:37,280 --> 00:13:44,080
indent level for example the google style guide all the google python code and I think also all

120
00:13:44,080 --> 00:13:50,560
the google c++ code is indented with only two spaces per block if you're not used to that it's

121
00:13:50,560 --> 00:13:58,720
harder to at a glance understand the code because the sort of the high level structure

122
00:13:58,800 --> 00:14:04,160
is determined by the indentation on the other hand there are there are other programming languages

123
00:14:04,160 --> 00:14:11,920
where the indentation is eight spaces or a whole tap stop in in sort of classic unix and to me that

124
00:14:11,920 --> 00:14:18,080
looks weird because you you sort of after three indent levels you've you've got no room left well

125
00:14:18,080 --> 00:14:24,080
there is some languages where the indentation is a recommendation it's a stylistic one the code

126
00:14:24,080 --> 00:14:30,480
compiles even without any indentation and then python really indentation is a fundamental part

127
00:14:30,480 --> 00:14:37,520
of the language right it doesn't have to be four spaces so you you can code python with

128
00:14:37,520 --> 00:14:44,560
two spaces per block or four or six spaces or 12 if you really want to go wild but

129
00:14:46,240 --> 00:14:52,080
sort of everything that belongs to the same block needs to be indented the same way

130
00:14:52,960 --> 00:14:57,760
in practice in most other languages people recommend doing that anyway if you look at

131
00:14:59,280 --> 00:15:07,760
c or rust or c++ all those languages java don't have a requirement of indentation

132
00:15:08,800 --> 00:15:16,400
but except in extreme cases they're just as anal about having their code properly indented

133
00:15:16,960 --> 00:15:25,120
so any ide that the syntax highlighting that works with java or c++ they will yell at you

134
00:15:25,760 --> 00:15:31,600
aggressively if you don't do proper indentation they'd suggest the proper indentation for you

135
00:15:32,400 --> 00:15:40,240
like in c you type a few words and then you type a curly brace which there is their notion of

136
00:15:40,240 --> 00:15:48,000
sort of begin an an indented block then you hit return and then it automatically indents

137
00:15:48,000 --> 00:15:53,760
four or eight spaces depending on your style preferences or how your editor is configured

138
00:15:53,760 --> 00:15:58,400
was there a possible universe in which you considered having braces in python

139
00:15:59,200 --> 00:16:07,120
absolutely yeah well it was a 60 40 70 30 in your head uh what was the tradeoff

140
00:16:07,120 --> 00:16:13,760
for a long time i was actually convinced that the indentation was just better

141
00:16:16,720 --> 00:16:21,840
without context i would still claim that indentation is better

142
00:16:24,080 --> 00:16:30,800
it reduces clutter however as i started to say earlier context is almost everything

143
00:16:31,760 --> 00:16:39,440
and in the context of coding most programmers are familiar with multiple languages even if

144
00:16:39,440 --> 00:16:46,880
they're only good at one or two and apart from python and maybe fortran i don't know how that's

145
00:16:46,880 --> 00:16:52,800
written these days anymore but all the other languages java rust cc plus plus javascript

146
00:16:52,800 --> 00:17:03,440
typescript pearl are all using curly braces uh to sort of indicate blocks and so python is the odd

147
00:17:03,440 --> 00:17:10,560
one out so it's a radical idea do you still as a radical renegade revolutionary do you still

148
00:17:10,560 --> 00:17:17,440
stand behind this idea of space of indentation versus braces like what what can you dig into it

149
00:17:17,440 --> 00:17:25,680
a little bit more why you still stand behind indentation because context is not the whole story

150
00:17:25,680 --> 00:17:35,360
history in in a sense provides more context so for python there is no chance that we can switch

151
00:17:36,560 --> 00:17:43,120
python is using curly braces for something else dictionaries mostly we would get in trouble if

152
00:17:43,120 --> 00:17:52,720
we wanted to switch just like you couldn't redefine c to use indentation even if you agree that that

153
00:17:52,720 --> 00:18:01,040
indentation sort of in a greenfield environment would be better you can't change that kind of thing

154
00:18:01,040 --> 00:18:08,720
in a language yeah it's hard enough to reach agreement over over much more minor details maybe

155
00:18:08,800 --> 00:18:14,640
i mean in the past in python we did have a big debate about teps versus spaces and four spaces

156
00:18:14,640 --> 00:18:24,160
versus fewer or more and we sort of came up with a recommended standard and sort of options for people

157
00:18:24,160 --> 00:18:31,600
who want to be different but yes i guess the thought experiment i'd like you to consider

158
00:18:31,600 --> 00:18:37,360
is if you could travel back through time when the when the compatibility is not an issue

159
00:18:38,000 --> 00:18:45,200
and you started python all over again can you make the case for indentation still

160
00:18:46,000 --> 00:18:51,920
well it frees up a pair of matched brackets of which there are never enough in the world

161
00:18:53,200 --> 00:19:01,840
for other purposes it really makes the language slightly sort of easier to grasp

162
00:19:02,560 --> 00:19:07,280
for people who don't already know another programming language

163
00:19:09,120 --> 00:19:14,720
because the sort of one of the things and i i mostly got this from my mentors who

164
00:19:16,240 --> 00:19:22,160
taught me programming language design in the earlier 80s when you're teaching programming

165
00:19:22,880 --> 00:19:31,600
for for the the the total newbie who has not coded before in not in any other language

166
00:19:33,840 --> 00:19:43,600
a whole bunch of concepts in programming are very alien or sort of new and and maybe very

167
00:19:43,600 --> 00:19:48,880
interesting but also distracting and confusing and there are many different things you have to learn

168
00:19:48,880 --> 00:19:57,680
you have to sort of in a typical 13 week programming course you have to if if it's

169
00:19:57,680 --> 00:20:04,240
like really learning to program from scratch you have to cover algorithms you have to cover

170
00:20:04,240 --> 00:20:12,000
data structures you have to cover syntax you have to cover variables loops functions recursion

171
00:20:12,000 --> 00:20:21,760
classes expressions operators there are so many concepts if you you sort of if you can spend a

172
00:20:21,760 --> 00:20:33,840
little less time having to worry about the syntax the classic example was often oh the compiler

173
00:20:33,840 --> 00:20:40,320
complains every time i put a semicolon in the wrong place or i forget to put a semicolon

174
00:20:42,080 --> 00:20:48,160
python doesn't have semicons in that sense so you can't forget them and you are also not

175
00:20:49,040 --> 00:20:55,280
sort of misled into putting them where they don't belong because you don't learn about them in the

176
00:20:55,280 --> 00:21:02,640
first place the flip side of that is forcing the strictness onto the beginning programmer

177
00:21:02,640 --> 00:21:09,040
to teach them that programming is values attention to details you don't get to just

178
00:21:09,120 --> 00:21:14,080
write the way you write in english many of other details that they have to pay attention to so i

179
00:21:14,080 --> 00:21:20,160
think they'll they'll still get the message about paying attention to details the interesting

180
00:21:20,160 --> 00:21:26,000
design choice so i still program quite a bit in php and i'm sure there's other languages like this

181
00:21:26,000 --> 00:21:34,000
but the dollar sign before a variable that was always an annoying thing for me it didn't quite

182
00:21:34,640 --> 00:21:39,360
fit into my understanding of why this is good for a programming language i'm not sure if you

183
00:21:39,360 --> 00:21:46,800
ever thought about that one that is a historical thing there is a whole lineage of programming

184
00:21:46,800 --> 00:21:57,280
languages php is one pearl was one on the unix shell uh is one of the oldest or or all the

185
00:21:57,280 --> 00:22:06,400
different shells the dollar was invented for that purpose because the very earliest shells had a

186
00:22:06,400 --> 00:22:13,280
notion of scripting but they did not have a notion of parameterizing the scripting right and so a

187
00:22:13,280 --> 00:22:21,760
script is just a few lines of text where each line of text is a command that is read by a very

188
00:22:21,840 --> 00:22:27,760
primitive command processor that then sort of takes the first word on the line as the name of a

189
00:22:27,760 --> 00:22:35,840
program and passes all the all the rest of the line as text into the program for the program to

190
00:22:35,840 --> 00:22:44,240
figure out what to do with as arguments and so by the time scripting was slightly more mature

191
00:22:44,240 --> 00:22:52,080
than the very first script there was a convention that just like the first word on the line is

192
00:22:52,880 --> 00:23:02,960
uh the name of the program the following words uh could be names of files input dot text output dot

193
00:23:02,960 --> 00:23:11,600
html things like that the next thing that happens is oh it would actually be really nice if we could

194
00:23:11,680 --> 00:23:17,760
have variables and especially parameters for scripts parameters are usually what starts this

195
00:23:17,760 --> 00:23:26,320
process but now you have a problem because you can't just say the parameters are x y and z

196
00:23:27,440 --> 00:23:33,920
and so now we we call say let's say x is the input file and y is the output file and let's

197
00:23:33,920 --> 00:23:41,040
forget about z for now i have my program and i write program x y well that already has a meaning

198
00:23:41,040 --> 00:23:49,840
because that presumably means x itself is the file it's a file name it's not a variable name

199
00:23:52,400 --> 00:23:59,600
and so the inventors of of things like the unique shell and i'm sure job command language

200
00:23:59,600 --> 00:24:09,360
in at IBM before that uh had to use something that made it clear to the script processor

201
00:24:11,040 --> 00:24:16,560
here is an x that is not actually the name of a file which you just pass through to the

202
00:24:17,440 --> 00:24:23,280
to the program you're running here is an x that is the name of a variable yeah and

203
00:24:24,320 --> 00:24:29,840
when you're writing a script processor you try to keep it as simple as possible

204
00:24:30,800 --> 00:24:37,920
because at that as certainly in the the 50s and 60s uh the thing that interprets the script

205
00:24:37,920 --> 00:24:43,360
was itself a very had to be a very small program because it had to fit in a very small part of

206
00:24:43,360 --> 00:24:52,000
memory and so saying oh just look at each character and if you see a dollar sign you jump to another

207
00:24:52,000 --> 00:24:56,960
section of the code and then you gobble up characters or say until the next space or something

208
00:24:57,600 --> 00:25:04,880
and you say that's the variable name and so it was was sort of invented as

209
00:25:05,520 --> 00:25:13,120
a clever way to make parsing of things that contain both contain both variable and fixed parts

210
00:25:14,080 --> 00:25:21,360
very easy in a very simple script processor it also helps even then it also helps the human

211
00:25:22,400 --> 00:25:31,920
author and the human reader of the the script to quickly see oh 20 lines down in the script

212
00:25:31,920 --> 00:25:37,760
i see a reference to x y z oh it has a dollar in front of it so now we know that x y z must be

213
00:25:37,760 --> 00:25:42,720
one of the parameters of the script well this is fascinating several things to say which is

214
00:25:43,680 --> 00:25:49,760
the leftovers from the simple script processor languages are now in code bases like behind

215
00:25:49,760 --> 00:25:55,200
facebook or behind most of the back end i think php's probably still runs most of the back end

216
00:25:55,200 --> 00:26:00,880
of the internet oh yeah i think there's a lot of it in wikipedia too for example yeah it's funny

217
00:26:00,880 --> 00:26:06,000
that those decisions are not funny it's fascinating that those decisions permeate through time

218
00:26:07,040 --> 00:26:13,600
just like biological systems right i mean that the sort of the inner workings of dna

219
00:26:14,800 --> 00:26:21,440
have been stable for well i don't know how long it was like 300 million years half a billion years

220
00:26:21,440 --> 00:26:27,520
yeah and there there are all sorts of weird quirks there that don't make a lot of sense if

221
00:26:27,520 --> 00:26:34,480
you were to design a system like self-replicating molecules from scratch well that system has a

222
00:26:34,480 --> 00:26:42,880
lot of interesting resilience it has redundancy that results like it messes up in interesting ways

223
00:26:42,880 --> 00:26:48,080
that still is resilient when you look at the system level of the organism code doesn't

224
00:26:48,080 --> 00:26:55,760
necessarily have that a program a computer programming code you'd be surprised how much

225
00:26:55,840 --> 00:27:02,560
resilience modern code has i mean if you if you look at the number of bugs per line of code

226
00:27:03,920 --> 00:27:12,640
even in in very well tested code that in practice works just fine there are actually

227
00:27:12,640 --> 00:27:20,800
lots of things that don't work fine and there are error correcting or self-correcting mechanisms

228
00:27:20,800 --> 00:27:28,000
at many levels including probably the user of the code well in the end the user who sort of is

229
00:27:28,000 --> 00:27:38,000
told well you got to reboot your your pc is part of that system and a slightly less drastic thing

230
00:27:38,000 --> 00:27:45,120
is reload the page which we all know how to do without thinking about it when something weird

231
00:27:45,120 --> 00:27:49,920
happens you try to reload a few times before you say oh there's something really weird

232
00:27:49,920 --> 00:27:55,920
okay or try to click the button again if the first time didn't work well yeah that that we

233
00:27:55,920 --> 00:28:00,800
should all have learned not to do that because that's probably just gonna turn the light back off

234
00:28:01,440 --> 00:28:08,480
yeah true so do it three times that's the that's the right lesson so uh and i wonder how many people

235
00:28:08,480 --> 00:28:16,960
actually like the dollar sign like you said it is documentation so to me it's whatever the

236
00:28:16,960 --> 00:28:23,600
opposite of syntactic sugar is syntactic poison to me it is such a pain in the ass that i have to

237
00:28:23,600 --> 00:28:30,640
type in a dollar sign also super error prone so it's not self documenting it's it's like a bug

238
00:28:30,640 --> 00:28:35,920
generating thing it is a kind of documentation that's the pro and the con is it's a source of a

239
00:28:35,920 --> 00:28:42,320
lot of bugs but actually i have to ask you um this is a really interesting idea of bugs per line of

240
00:28:42,320 --> 00:28:48,880
code if you look at all the computer systems out there from the code that runs nuclear weapons

241
00:28:49,440 --> 00:28:55,600
to the code that runs all the amazing companies that you've been involved with and not the code

242
00:28:55,600 --> 00:29:02,800
that runs twitter and facebook and dropbox and google and microsoft windows and so on and we like

243
00:29:02,800 --> 00:29:11,520
laid out wouldn't that be a cool like table bugs per line of code and what let's let's put like

244
00:29:11,520 --> 00:29:16,560
actual companies aside do you think we'd be surprised by the number we see there for all

245
00:29:16,560 --> 00:29:24,320
these companies that depends on whether you've ever read about research that's been done in this

246
00:29:24,320 --> 00:29:33,600
area before and i don't know that the the last time i i saw some research like that there was

247
00:29:33,680 --> 00:29:41,040
probably in the 90s and the research might have been done in the 80s but the the conclusion was

248
00:29:41,680 --> 00:29:50,880
across a wide range of different software different languages different companies different

249
00:29:50,880 --> 00:29:59,440
development styles the number of bugs is always i think it's in the order of about one bug per

250
00:29:59,440 --> 00:30:08,160
thousand lines in sort of mature software that that is considered interesting as good as it gets

251
00:30:08,160 --> 00:30:14,160
can't give you some facts here there's a lot of good papers so you said mature software right so

252
00:30:14,160 --> 00:30:23,040
here's a report from a uh like programming analytics company now this is from a developer

253
00:30:23,040 --> 00:30:28,640
perspective let me just say what it says because this is very weird and surprising

254
00:30:28,640 --> 00:30:33,200
on average a developer creates 70 bugs per 1000 lines of code

255
00:30:34,560 --> 00:30:38,320
15 bugs per 1000 lines of code find their way to the customers

256
00:30:40,000 --> 00:30:46,000
this is in software they've oh i was i was wrong by an order working on an order fixing a bug takes

257
00:30:46,000 --> 00:30:53,040
30 times longer than writing a line of code that i can believe yeah 75 of a developer's time is

258
00:30:53,040 --> 00:30:58,960
spent on debugging um that's for an average developer that they analyze this 15 argue

259
00:31:00,560 --> 00:31:09,280
1500 hours a year in us alone 113 billion dollars to spend annually on identifying and fixing bugs

260
00:31:10,400 --> 00:31:16,160
and i imagine this is marketing literature for someone who claims to have a golden bullet or

261
00:31:16,160 --> 00:31:23,280
silver bullet that makes all that investment in fixing bugs go away but that that is usually

262
00:31:24,240 --> 00:31:29,280
not going to yeah that's not gonna happen well they're uh i mean they're referencing a lot of

263
00:31:29,280 --> 00:31:35,600
stuff of course but it is the page uh that is you know there's a contact us button at the bottom

264
00:31:36,160 --> 00:31:41,440
presumably if you just spend a little bit less than 100 billion dollars we're willing to solve

265
00:31:41,440 --> 00:31:47,440
the problem for you right and there's also a report on stack exchange and stack overflow on the

266
00:31:47,440 --> 00:31:52,400
exact same topic but when i open it up at the moment the page says stack overflow is currently

267
00:31:52,400 --> 00:31:58,640
offline for maintenance oh that is ironic yes uh by the way their error page is awesome anyway

268
00:32:00,000 --> 00:32:06,000
i mean can you believe that number of bugs oh absolutely isn't that scary that 70 bugs per

269
00:32:06,000 --> 00:32:13,040
1000 lines of code so even 10 bugs per 1000 lines well that's about one bug every 15 lines and

270
00:32:13,040 --> 00:32:19,360
that's when you're first typing it in yeah from a developer but like how many bugs are going to be

271
00:32:19,360 --> 00:32:27,680
found if you're if you're typing well the development process is extremely iterative yeah typically you

272
00:32:27,680 --> 00:32:35,040
don't make a plan for what software you're going to release a year from now yeah and work out all

273
00:32:35,040 --> 00:32:42,400
the details because actually all the details uh themselves consist they sort of compose a program

274
00:32:43,920 --> 00:32:50,800
and that that being a program all your plans will have bugs in them too and inaccuracies

275
00:32:52,320 --> 00:32:59,040
but what what you actually do is you do a bunch of typing and i'm i'm actually

276
00:32:59,760 --> 00:33:05,920
really i'm a really bad typist that's just i've never learned to type with 10 fingers

277
00:33:07,040 --> 00:33:14,320
how many do you use well i use all 10 of them but not very well but i never i never took a

278
00:33:14,320 --> 00:33:21,040
typing class and i never sort of corrected that so the first time i i seriously learned i had to

279
00:33:21,040 --> 00:33:28,000
learn the layout of a of a qwerty keyboard was actually in college in my first programming classes

280
00:33:28,800 --> 00:33:37,600
where we used punch cards and so with my two fingers i sort of pecked out my code

281
00:33:38,960 --> 00:33:47,120
watch anyone give you a little coding demonstration they'll have to produce like four lines of code

282
00:33:48,400 --> 00:33:54,800
and now see how many times they use the backspace key yeah because they made a mistake and and

283
00:33:55,760 --> 00:33:59,200
and some people especially when when someone else is looking

284
00:34:01,680 --> 00:34:08,960
will will backspace over 20 30 40 characters to fix a typo earlier in the line if you're

285
00:34:10,480 --> 00:34:15,840
if you're slightly more experienced of course you use your arrow buttons to go or your mouse to

286
00:34:15,840 --> 00:34:23,520
but the mouse is usually slower than than the arrows but a lot of people when they type a

287
00:34:23,680 --> 00:34:30,240
20 character word which is not unusual and they realize they made us made a mistake at the start

288
00:34:30,240 --> 00:34:35,840
of the word they backspace over the whole thing and then retype it and sometimes it takes three four

289
00:34:35,840 --> 00:34:44,000
times to get it right so i don't know what your definition of bug is arguably mistyping a word

290
00:34:44,000 --> 00:34:52,000
and then correcting it immediately is not a bug on the other hand you you already do sort of lose

291
00:34:52,000 --> 00:34:58,640
time and every once in a while there's sort of a typo that you don't get in that process

292
00:34:59,760 --> 00:35:05,360
and now you've you've you've typed like 10 lines of code and somewhere in the middle of it you

293
00:35:05,360 --> 00:35:12,800
don't know where yet is a typo or maybe a thing code where you you forgot that you had to initialize

294
00:35:12,800 --> 00:35:17,440
a variable or something but those are two different things and i would say yes you have to actually

295
00:35:17,440 --> 00:35:23,600
run the code to discover that typo but forgetting to initialize a variable is a fundamentally different

296
00:35:24,160 --> 00:35:30,400
thing because that thing could go undiscovered that depends on the language in python it will not

297
00:35:30,400 --> 00:35:36,640
right and sort of modern compilers are usually pretty good at catching that even even foresee

298
00:35:36,640 --> 00:35:44,080
so for that specific thing but actually deeper it might there might be another variable that

299
00:35:44,080 --> 00:35:52,160
is initialized but logically speaking the one you meant related yep it's like name the same but

300
00:35:52,160 --> 00:35:58,160
it's a different thing and you forgot to initialize whatever some counter or some some basic variable

301
00:35:58,160 --> 00:36:03,840
they're using i can tell that you've coded yes by the way i should mention that i use a kinesis

302
00:36:03,840 --> 00:36:12,000
keyboard which has the backspace under the thumb and one of the biggest reasons i use that keyboard

303
00:36:12,000 --> 00:36:17,760
is because you realize in order to use the backspace on a usual keyboard you have to stretch

304
00:36:17,760 --> 00:36:26,560
your pinky out and like the for most normal keyboards the backspace is under the pinky

305
00:36:26,560 --> 00:36:33,840
and so i don't know if people realize the pain they go through in their life because of the backspace

306
00:36:33,840 --> 00:36:38,080
key being so far away so with the kinesis it's right under the thumb so you don't have to actually

307
00:36:38,080 --> 00:36:45,440
move your hands the backspace and what do you do if you're ever not with your own keyboard and you

308
00:36:45,440 --> 00:36:51,760
have to use someone else's pc keyboard that has that standard layout so first of all it turns out

309
00:36:52,320 --> 00:36:58,000
that you can actually go your whole life always having the keyboard with you so this well except

310
00:36:58,000 --> 00:37:03,280
for that that little tablet that you're using so we're not taking right now right uh yeah so it's

311
00:37:03,280 --> 00:37:09,920
very inefficient note-taking but i'm not i'm just looking stuff up but in most cases i would be actually

312
00:37:09,920 --> 00:37:15,520
using the keyboard here right right now i just don't anticipate you have to calculate how much

313
00:37:15,520 --> 00:37:20,480
typing do you anticipate if i anticipate quite a bit then i'll just i have a keyboard you pull

314
00:37:20,480 --> 00:37:29,040
that and same same with i mean the embarrassing i've accepted being the weirdo that i am but

315
00:37:29,760 --> 00:37:34,800
you know when i go on an airplane and i anticipate to do programming or a lot of typing

316
00:37:35,360 --> 00:37:41,600
i will have a laptop that will pull out a kinesis keyboard in addition to the laptop

317
00:37:41,600 --> 00:37:47,840
and it's just who i am you have to you have to accept who you are but also it's a you know for a

318
00:37:47,840 --> 00:37:54,480
lot of people for me certainly there's a comfort space where there's a certain kind of setups that

319
00:37:55,120 --> 00:38:01,680
maximize productivity and it's like some people have a warm blanket that they like

320
00:38:02,400 --> 00:38:09,120
when they watch a movie i like the kinesis keyboard takes me to a place of focus and i still mostly

321
00:38:09,840 --> 00:38:16,720
i i'm trying to make sure i use the state of the art ids for everything but my comfort place

322
00:38:16,720 --> 00:38:26,960
just like the kinesis keyboard is still emacs so i still use i still i mean that's one of some

323
00:38:26,960 --> 00:38:33,760
of the debates i have with myself about everything from a technology perspective is how much to hold

324
00:38:33,760 --> 00:38:40,480
on to the tools you're comfortable with versus how much to invest in using modern tools and the

325
00:38:40,480 --> 00:38:46,000
signal that the communities provide you with is the noisy one because a lot of people year to

326
00:38:46,000 --> 00:38:52,560
year get excited about new tools and you have to make a prediction are these tools defining a new

327
00:38:52,560 --> 00:38:57,280
generation of something that will transform programming or is this just a fad that will pass

328
00:38:58,080 --> 00:39:04,720
certainly with javascript frameworks and front and the back end of the web there's a lot of

329
00:39:04,720 --> 00:39:11,280
different styles that came and went i remember learning um what was it called action script

330
00:39:11,280 --> 00:39:18,320
i remember for flash um you know learning how to program in flash learning how to design

331
00:39:18,320 --> 00:39:23,200
doing graphic animation all that kind of stuff for flash same with java applets i remember

332
00:39:23,200 --> 00:39:27,680
creating quite a lot of java applets thinking that this potentially defines the future of the

333
00:39:27,680 --> 00:39:36,240
web and did not well you know in most cases like that the particular technology eventually gets

334
00:39:36,240 --> 00:39:46,720
replaced but many of the concepts that the technology introduced or made accessible first

335
00:39:48,240 --> 00:39:55,360
are preserved of course because yeah we're not using java applets anymore but the notion of

336
00:39:55,360 --> 00:40:05,280
reactive web pages that sort of contain little bits of code that respond directly to something

337
00:40:05,360 --> 00:40:11,840
you do like pressing a button or a link or hovering even uh is has certainly not gone away

338
00:40:12,560 --> 00:40:22,720
and that those animations that were made painfully complicated with flash i mean flash was an

339
00:40:22,720 --> 00:40:30,480
innovation when it first came up and when it was replaced by javascript equivalents stuff

340
00:40:31,440 --> 00:40:38,480
it was a somewhat better way to do animations but those animations are still there not all of them

341
00:40:39,280 --> 00:40:46,320
but but sort of again there is an evolution and often so often with technology

342
00:40:47,360 --> 00:40:54,000
that the sort of the technology that was eventually thrown away or replaced was still

343
00:40:54,000 --> 00:41:00,880
essential to to sort of get started there wouldn't be jet planes without propeller planes

344
00:41:01,680 --> 00:41:09,600
i bet you but from a user perspective yes from the feature set yes but i from a programmer

345
00:41:09,600 --> 00:41:19,040
perspective it feels like all the time i've spent with action script all the time i spent with

346
00:41:19,040 --> 00:41:24,160
java on the applet side for the GUI development i well no java i have to push back that that was

347
00:41:24,160 --> 00:41:29,760
useful that because it transfers but the flash doesn't transfer so some things you learn and

348
00:41:29,760 --> 00:41:36,560
invest time in what yeah what what you learned the skill the skill you picked up learning action

349
00:41:36,560 --> 00:41:45,600
script yeah was sort of it was perhaps a super valuable skill at the time you picked it up

350
00:41:46,240 --> 00:41:55,360
if you if you if you learned action script early enough but that skill is no longer

351
00:41:56,560 --> 00:42:00,800
in demand well that's the calculation you have to make when you're learning new things like today

352
00:42:00,800 --> 00:42:07,520
people start learning programming today i'm trying to to see what are the new languages to try what

353
00:42:07,520 --> 00:42:14,000
are the new systems to try that what are the new ideas to try to to keep keep improving that's

354
00:42:14,000 --> 00:42:21,360
that's why we start when we're young right when when we're but but that seems very true to me that

355
00:42:21,360 --> 00:42:26,640
that when you're young you have your whole life ahead of you and you're you're allowed to make

356
00:42:26,640 --> 00:42:33,360
mistakes in fact you should you should feel encouraged to to do a bit of stupid stuff yeah

357
00:42:33,360 --> 00:42:41,360
try not to get yourself killed or seriously maimed but try stuff that deviates from from

358
00:42:41,360 --> 00:42:49,200
what everybody else is doing and like nine out of ten times you'll just learn why everybody else

359
00:42:49,200 --> 00:42:55,600
is not doing that or why everybody else is doing it some other way and one out of ten times you

360
00:42:55,600 --> 00:43:02,240
sort of you discover something that's better or that that somehow works i mean there are all

361
00:43:02,240 --> 00:43:10,320
sorts of crazy things that were invented by accident by people trying trying stuff together

362
00:43:11,120 --> 00:43:16,240
that's great advice to try random stuff make a lot of mistakes once you're married with kids

363
00:43:16,240 --> 00:43:21,680
you're probably going to be a little more risk averse because now there's more at stake and

364
00:43:21,680 --> 00:43:27,120
you've already hopefully had some time where you where you were experimenting with crazy shit

365
00:43:27,840 --> 00:43:32,560
i like how marriage and kids solidifies your choice of programming language how does that the

366
00:43:32,560 --> 00:43:38,240
the robber frost poem with the the road less taken which i think is misinterpreted by most people

367
00:43:38,240 --> 00:43:44,720
but anyway i i feel like the choices you make early on especially if you go all in they're

368
00:43:44,720 --> 00:43:50,720
going to define the rest of your life's trajectory in a way that like you basically are picking a

369
00:43:50,720 --> 00:43:57,840
camp so you know there's if you invest a lot in php if you invest a lot in dot net if you

370
00:43:57,840 --> 00:44:06,400
invest a lot in java script you're going to stick there you that's that's your life journey

371
00:44:06,960 --> 00:44:15,120
it's very hard to tell only as far as that technology remains relevant yes yes i mean

372
00:44:15,120 --> 00:44:25,440
if if at age 16 you learn coding in c and by the time you're 26 c is like a dead language

373
00:44:28,400 --> 00:44:35,440
then there's still time to switch there's probably some kind of survivor bias or whatever it's called

374
00:44:36,160 --> 00:44:42,720
in in sort of your observation that that you pick a camp because there are many different

375
00:44:42,720 --> 00:44:50,000
camps to pick and if you pick dot net then then you can coast for the rest of your life because

376
00:44:50,000 --> 00:44:57,040
that technology is now so ubiquitous of course that it's even if it's if it's bound to die it's

377
00:44:57,040 --> 00:45:04,800
going to take a very long time well for me personally i had a very difficult and in my own

378
00:45:04,800 --> 00:45:10,880
head brave leap that i had to take relevant to our discussion which is most of my life i programed

379
00:45:10,880 --> 00:45:19,520
in c and c plus plus and so uh having that hammer everything looked like a nail so i would literally

380
00:45:19,520 --> 00:45:26,080
even do scripting in c plus plus like i would create programs i do script like things and uh

381
00:45:26,080 --> 00:45:32,240
when i first came to google and before then it became already before tensile for before all of

382
00:45:32,240 --> 00:45:38,320
that there was a growing realization that c plus plus is not the right tool for machine learning

383
00:45:38,320 --> 00:45:43,840
we could talk about why that is it's unclear why that is a lot of things has to do with

384
00:45:43,840 --> 00:45:48,960
community and culture and how it emerges and stuff like that but for me to decide to take

385
00:45:48,960 --> 00:45:55,120
the leap to python like all out basically switch completely from c plus plus except for

386
00:45:56,480 --> 00:46:01,680
highly performant robotics applications there were still a there's still a culture of c plus

387
00:46:01,680 --> 00:46:09,360
plus in in the space of robotics that was a big leap like i had to you know like like people have

388
00:46:09,360 --> 00:46:15,440
like existential crises or midlife crises or whatever you have to realize almost like walking

389
00:46:15,440 --> 00:46:21,600
away from uh from a person you love um because i was sure that c plus plus would have to be a life

390
00:46:21,600 --> 00:46:26,640
long companion for a lot of problems i would want to solve c plus plus would be there and it was a

391
00:46:26,640 --> 00:46:31,280
question to say well that might not be the case because c plus plus is still one of the most

392
00:46:31,280 --> 00:46:35,920
popular languages in the world one of the most used one of the most dependent on it's also

393
00:46:36,480 --> 00:46:45,600
still evolving quite a bit i mean that that is not a sort of a fossilizing community

394
00:46:46,160 --> 00:46:52,240
yes they they are doing great innovative work actually a lot but yet the sort of their innovations

395
00:46:52,240 --> 00:46:58,320
are hard to follow if you're not already a hardcore c plus plus user well this was the thing it pulls

396
00:46:58,320 --> 00:47:03,520
you in it's a rabbit hole i was a hardcore the all meta programming template programming like

397
00:47:03,520 --> 00:47:10,160
i i would start using the modern c plus plus as it developed right not just the not not just the

398
00:47:10,160 --> 00:47:14,400
shared pointer in the garbage collection that's you that makes it easier for you to work with some

399
00:47:14,400 --> 00:47:20,640
of the flaws but the detail like the meta programming the the crazy stuff that's that's coming out there

400
00:47:20,640 --> 00:47:28,400
but then you have to just empirically look and step back and say what language am i more productive in

401
00:47:28,720 --> 00:47:36,720
sorry to say what language do i enjoy my life with more and uh readability and able to think

402
00:47:36,720 --> 00:47:41,120
through and all that kind of stuff that those questions are harder to ask when you already have

403
00:47:42,080 --> 00:47:49,360
a loved one which in my case was c plus plus and then there's python uh like that meme was

404
00:47:49,360 --> 00:47:55,360
is the the grass is greener on the other side am i just infatuated with a new fad new cool thing

405
00:47:55,360 --> 00:48:00,480
new cool thing or is this actually going to make my life better and i think a lot of people face

406
00:48:00,480 --> 00:48:07,200
that kind of decision it was a difficult decision for me um when i made it at this time it's an

407
00:48:07,200 --> 00:48:13,920
obvious switch if you're into machine learning but that time it wasn't quite yet so obvious so it was

408
00:48:13,920 --> 00:48:19,360
a risk and you know you have the same kind of stuff with um i still because of my connection

409
00:48:19,360 --> 00:48:23,920
to wordpress i still do a lot of back end programming in php

410
00:48:26,640 --> 00:48:32,320
and the question is you know no j s python do you switch to do you switch back end to any of those

411
00:48:33,440 --> 00:48:39,680
programming there's the case for no j s for me well more more more of the front end it runs in

412
00:48:39,680 --> 00:48:46,480
java script um and fascinating cool stuff is done as java script maybe use the same program

413
00:48:46,560 --> 00:48:52,240
language for the back end as well uh the case for python for the back end is well you're doing so

414
00:48:52,240 --> 00:48:59,440
much programming outside of the web in python so maybe use python for the back end and then the

415
00:48:59,440 --> 00:49:05,840
case for php well most of the web still runs in php you have a lot of experience with php

416
00:49:07,120 --> 00:49:12,480
why uh fix something that's not broken those are my own personal struggles but i think they

417
00:49:12,480 --> 00:49:16,880
reflect the struggles of a lot of people with different programming languages with different

418
00:49:16,880 --> 00:49:21,920
problems they're trying to solve it's a weird one and there there's not a single answer right

419
00:49:21,920 --> 00:49:28,880
because depending on how much time you have to learn new stuff where you are in your life

420
00:49:28,880 --> 00:49:34,240
what what you're currently working on who you want to work with what communities you like

421
00:49:35,200 --> 00:49:43,200
there's not one right choice maybe if you if you sort of if you can look back 20 years you can say

422
00:49:43,200 --> 00:49:50,480
well that whole detour through action script was a waste of time but nobody could know that

423
00:49:51,600 --> 00:49:59,200
so you can't you can't beat yourself up over that uh you just need to accept that not every choice

424
00:49:59,280 --> 00:50:06,720
you make is going to be perfect maybe sort of keep a plan be in the back of your mind

425
00:50:08,880 --> 00:50:17,120
but don't don't overthink it don't don't try to sort of don't don't create a spreadsheet with like

426
00:50:18,320 --> 00:50:25,120
where you're trying to estimate well if i learn this language i expect to make x million dollars

427
00:50:25,120 --> 00:50:31,200
in a lifetime and if i learn that language i expect to make y million dollars in a lifetime

428
00:50:31,760 --> 00:50:37,920
and which which is higher and what which has more risk and where is the chance that it's like

429
00:50:37,920 --> 00:50:49,920
picking picking a stock kind of kind of but uh i think with stocks you can do diversifying your

430
00:50:49,920 --> 00:50:57,520
investment is good with productivity in life boy that spreadsheet is possible to construct

431
00:50:58,960 --> 00:51:03,920
like if you actually carefully analyze what your interests in life are where you think you can

432
00:51:03,920 --> 00:51:10,320
maximally impact the world there really is better and worse choices for programming language

433
00:51:10,320 --> 00:51:15,040
that are not just about the syntax but about the community about where you predict the

434
00:51:15,040 --> 00:51:20,960
community's headed what large systems are programmed in that but can you create that

435
00:51:20,960 --> 00:51:25,920
spreadsheet because that's sort of you're mentioning a whole bunch of inputs that go

436
00:51:25,920 --> 00:51:31,760
into that spreadsheet where you have to estimate things that are very hard to measure and even

437
00:51:31,760 --> 00:51:37,840
harder i mean they're they're hard to measure retroactively and they're even harder to predict

438
00:51:37,840 --> 00:51:45,920
like what is the better community well better is is one of those incredibly difficult words

439
00:51:46,560 --> 00:51:50,400
what's better for you is not better for someone else no but we're not doing a public

440
00:51:50,400 --> 00:51:56,560
speech about what's better we're doing a personal spiritual journey i can determine a circle of

441
00:51:56,560 --> 00:52:02,240
friends circle circle one and circle two and i can have a bunch of parties with one and a bunch

442
00:52:02,320 --> 00:52:09,280
of parties with two and then write down or take a mental note of what made me happier right and

443
00:52:09,280 --> 00:52:14,560
that you know you have if you're a machine learning person you want to say okay i want to build a

444
00:52:14,560 --> 00:52:21,440
large company that does that is grounded in machine learning but also has a sexy interface

445
00:52:21,440 --> 00:52:26,720
that has a large impact on the world what languages do i use you look at what facebook is using you

446
00:52:26,720 --> 00:52:33,120
look at what twitter is using then you look at performant more newer languages like rust or you

447
00:52:33,120 --> 00:52:38,480
look at languages that have taken that most of the community uses in machine learning space that's

448
00:52:38,480 --> 00:52:43,840
python and you can like think through you can hang out and think through it and it's it's always a

449
00:52:43,840 --> 00:52:48,640
invest and the the level of activity of the community is also really interesting like you

450
00:52:48,640 --> 00:52:53,680
said c plus boss and python are super active in terms of the development of the language itself

451
00:52:54,480 --> 00:53:01,920
but do you think that you can make objective choices there no no no but there's a gut you

452
00:53:01,920 --> 00:53:07,360
build up like don't you don't you believe in that gut feeling oh everything is very subjective and

453
00:53:07,360 --> 00:53:12,960
yes you most certainly can have a gut feeling and your gut can also be wrong that's why there are

454
00:53:12,960 --> 00:53:18,720
billions of people because they're not all right i mean clearly there are more people

455
00:53:18,720 --> 00:53:25,520
living in the bay area who have plans to sort of create a google sized company than there's

456
00:53:25,520 --> 00:53:30,880
room in the world for google sized companies and they're going to have to duke it out in the market

457
00:53:31,440 --> 00:53:38,080
the space and there's many more choices than just the programming language speaking of which

458
00:53:38,080 --> 00:53:42,480
let's go back to the boat with the with the fisherman who's tuned out long ago

459
00:53:43,280 --> 00:53:48,560
let's talk to the programmer let's jump around and go back to c python that we tried to define

460
00:53:48,560 --> 00:53:54,000
as the reference implementation and one of the big things that's coming out in 3.11 what's the

461
00:53:54,000 --> 00:54:01,920
right way to we tend to say 3.11 because it really was like we went 3.8 3.9 3.10 3.11 and

462
00:54:01,920 --> 00:54:10,080
we're planning to go up to 3.99 99 what happens after 99 probably just 3.100 what if i make it

463
00:54:10,080 --> 00:54:17,600
there okay and go all the way to 4.20 i got it forever python v3 we'll talk about four but more

464
00:54:17,600 --> 00:54:26,080
for fun so 3.11 is coming out one of the big sexy things in it is it'll be much faster so how

465
00:54:26,880 --> 00:54:33,280
did you beyond hiring a great team or working with a great team make it faster what are some ideas

466
00:54:34,240 --> 00:54:42,000
uh that me makes it faster it has to do with simplicity of software versus performance

467
00:54:43,040 --> 00:54:50,800
and so even though c is known to be a low-level language which is great for writing sort of

468
00:54:51,600 --> 00:55:00,400
a high performance language interpreter when i originally started python or c python i

469
00:55:01,360 --> 00:55:13,040
didn't expect there would be great success and fame in my future uh so i i try to get something

470
00:55:13,760 --> 00:55:23,760
working and useful uh in about three months and so i i sort of i cut corners

471
00:55:24,480 --> 00:55:31,920
i borrowed ideas left and right when it comes to language design as well as implementation

472
00:55:32,800 --> 00:55:42,880
uh i also wrote much of the code as simple as it could be and there there are like there are

473
00:55:42,880 --> 00:55:51,760
many things that you can code more efficiently by adding more code it's a bit of a sort of a time

474
00:55:51,760 --> 00:56:00,800
space trade-off where you can compute a certain thing from a small number of inputs

475
00:56:02,800 --> 00:56:09,040
and every time you get presented with a new input you do the whole computation from the top

476
00:56:10,320 --> 00:56:15,920
that can be simple looking code it's easy to understand it's easy to reason about that you

477
00:56:16,240 --> 00:56:22,080
you can tell quickly that it's correct at least in the sort of mathematical sense of correct

478
00:56:24,800 --> 00:56:33,360
because it's implemented in c maybe it performs relatively well but over time as sort of

479
00:56:35,040 --> 00:56:43,840
as the requirements for that code and the need for performance go up you might be able to rewrite

480
00:56:43,840 --> 00:56:52,880
that same algorithm using more memory maybe remember previous results so you don't have to

481
00:56:52,880 --> 00:56:59,680
recompute everything from scratch like the the classic example is computing prime numbers like

482
00:57:00,800 --> 00:57:07,760
is 10 a prime number well you sort of is it divisible by two is it divisible by three is

483
00:57:07,760 --> 00:57:15,280
it divisible by four and we go all the way to is it divisible by nine and it is not well actually

484
00:57:15,280 --> 00:57:22,320
10 is divisible by two so there we stop at say 11 it's divisible by 10 the answer is nine is no

485
00:57:22,320 --> 00:57:29,040
10 times in a row so now we know 11 is a prime number on the other hand if we already know that

486
00:57:29,040 --> 00:57:34,640
two three five and seven are prime numbers and you know a little bit about the mathematics of

487
00:57:35,360 --> 00:57:41,440
how prime numbers work you know that if you have a rough estimate for the square root of 11

488
00:57:42,160 --> 00:57:48,240
you don't actually have to check is it divisible by four or is it divisible by five you all you

489
00:57:48,240 --> 00:57:54,640
have to check in the case of 11 is is it divisible by two is it divisible by three because take 12

490
00:57:55,920 --> 00:58:02,480
if it's divisible by four well 12 divided by four is three so you you should have come across the

491
00:58:02,480 --> 00:58:09,120
question is it divisible by three first so if you know basically nothing about prime numbers

492
00:58:09,120 --> 00:58:18,240
except the definition maybe you go for x from two through n minus one is n divisible by x

493
00:58:19,360 --> 00:58:26,640
and then at the end if you got uh all knows uh for every single one of those questions

494
00:58:27,360 --> 00:58:33,120
you know oh it must be a prime number well the first thing is you can stop iterating when you

495
00:58:33,120 --> 00:58:38,960
find a yes answer and the second is you can also stop iterating when you had have reached

496
00:58:40,080 --> 00:58:47,360
the square root of n because you know that if it has a divisor larger than than the square root

497
00:58:47,360 --> 00:58:54,080
did not also have a divisor smaller than the square root then you say oh except for two

498
00:58:54,080 --> 00:58:58,800
we don't need to bother with checking for even numbers because all even numbers are divisible

499
00:58:58,800 --> 00:59:04,800
by two so if it's divisible by four we would already have come across the question is it

500
00:59:04,800 --> 00:59:10,640
divisible by two and so now you go special case check is it divisible by two and then you just

501
00:59:10,640 --> 00:59:18,560
check three five seven eleven uh and so now you you sort of reduced your search space by 50% again

502
00:59:19,120 --> 00:59:25,360
by skipping all the even numbers it kept for two if you think a bit more about it or you just

503
00:59:26,400 --> 00:59:32,080
read in your book about the history of math one of the first algorithms ever written down

504
00:59:32,880 --> 00:59:38,480
all you have to do is check is it divisible by any of the previous prime numbers that are

505
00:59:38,480 --> 00:59:45,120
smaller than the square root and before you get to a better algorithm than that

506
00:59:46,800 --> 00:59:54,240
you have to have several phd's in in discrete math so that's as much as i know

507
00:59:54,240 --> 00:59:59,280
so of course that same story applies to a lot of other algorithms string matching is a good example

508
01:00:00,320 --> 01:00:05,680
of how to come up with an efficient algorithm and sometimes yeah the more efficient algorithm

509
01:00:05,680 --> 01:00:12,480
is not so much more complex than the inefficient one but that's an art and it's not always the case

510
01:00:12,480 --> 01:00:18,560
in the general cases the more performant the algorithm the more complex it's going to be

511
01:00:18,560 --> 01:00:25,440
there's a there's a kind of trade-off the simpler algorithms are also the ones that people invent

512
01:00:25,440 --> 01:00:32,400
first because when you're looking for a solution you look at the simplest way to get there first

513
01:00:33,200 --> 01:00:40,400
and so if there is a simple solution even if it's not the best solution not the fastest

514
01:00:40,400 --> 01:00:49,360
or the memory most memory efficient or whatever a simple solution and simple is is fairly subjective

515
01:00:49,360 --> 01:00:55,280
but mathematicians have also thought about sort of what is a good definition for simple in the

516
01:00:55,280 --> 01:01:05,360
case of algorithms but the simpler the simpler solutions tend to be easier to follow for other

517
01:01:05,360 --> 01:01:11,680
programmers who haven't made a study of a particular field and when i when i started with python i

518
01:01:12,400 --> 01:01:17,680
i was a good programmer in general i knew sort of basic data structures and knew the c-language

519
01:01:17,680 --> 01:01:28,320
pretty well but there were many areas where i was only somewhat familiar with the state of the art

520
01:01:30,080 --> 01:01:37,760
and so i i picked in many cases the simplest way i could solve a particular sub problem because

521
01:01:37,760 --> 01:01:43,360
when you when you're designing and implementing a language you have to like you have many hundreds

522
01:01:43,360 --> 01:01:49,280
of little problems to solve and you have to have solutions for every one of them

523
01:01:50,080 --> 01:01:54,400
before you can can sort of say i've invented the programming language

524
01:01:56,320 --> 01:02:03,840
first of all so c python what kind of things does it do it's an interpreter it takes in this

525
01:02:03,840 --> 01:02:09,040
readable language that we talked about that is python what is it supposed to do the interpreter

526
01:02:09,040 --> 01:02:20,480
basically it it's sort of a recipe for understanding recipes so instead of a recipe that says bake me

527
01:02:20,480 --> 01:02:31,440
a cake we have a recipe for well given the text of a program how do we run that program and and

528
01:02:31,440 --> 01:02:37,520
that is sort of the recipe for building a computer the recipe for the baker and the chef yeah what are

529
01:02:37,520 --> 01:02:45,760
the algorithmically tricky things that happen to be low hanging fruit that could be improved on

530
01:02:45,760 --> 01:02:52,640
maybe throughout the history of python but also now how is it possible that 3.11 in year 2022

531
01:02:52,640 --> 01:02:58,000
it's possible to get such a big performance improvement we focused

532
01:02:58,560 --> 01:03:09,280
on a few areas where we we still felt there was low hanging fruit the biggest one is actually

533
01:03:09,280 --> 01:03:16,240
the interpreter itself and this has to do with details of how python is defined so

534
01:03:17,120 --> 01:03:22,240
i don't know if the fisherman is going to follow this story he already he already jumped off the

535
01:03:22,240 --> 01:03:30,080
boat he's he's he's he's a board yeah stupid python is actually even though it's always called an

536
01:03:30,080 --> 01:03:36,000
interpreted language it's there's also a compiler in there it just doesn't compile to machine code

537
01:03:36,000 --> 01:03:44,640
it compiles to bytecode which is sort of code for an imaginary computer that is called the python

538
01:03:44,640 --> 01:03:50,880
interpreter so it's compiling code that is more easily digestible by the interpreter or is digestible

539
01:03:51,200 --> 01:03:56,080
it is the code that is digested by the interpreter that's the compiler we tweaked

540
01:03:56,080 --> 01:04:02,240
very minor bits of the compiler almost all the work was done in the interpreter because

541
01:04:03,760 --> 01:04:09,440
when you have a program you compile it once and then you run the code a whole bunch of times

542
01:04:10,320 --> 01:04:15,600
or maybe there's one function in the in the code that gets run many times

543
01:04:16,160 --> 01:04:23,600
uh now i know that that's sort of people who who know this field are expecting me to at some point

544
01:04:23,600 --> 01:04:30,480
say we built a just-in-time compiler actually we didn't we just made the interpreter uh a little

545
01:04:30,480 --> 01:04:38,240
more efficient what's a just-in-time compiler that is a thing from the java world although it's

546
01:04:38,240 --> 01:04:45,440
now applied to almost all programming languages especially interpreted ones so you see the

547
01:04:45,440 --> 01:04:51,120
compiler inside python not like a just-in-time compiler but it's a compiler that creates bytecode

548
01:04:51,120 --> 01:04:57,680
that is then fed to the interpreter and the compiler was there something interesting to

549
01:04:57,680 --> 01:05:02,000
say about the compiler it's interesting that you haven't changed that tweaked out at all or much

550
01:05:02,000 --> 01:05:10,640
we changed some parts of the bytecode but not very much and so we only had to change the parts of

551
01:05:10,640 --> 01:05:16,720
the compiler where we decided that the the breakdown of a python program in bytecode instructions had

552
01:05:16,720 --> 01:05:28,000
to be slightly different uh but that didn't that didn't gain us the performance uh improvements

553
01:05:28,000 --> 01:05:37,600
that performance improvements were like making the interpreter faster in part by sort of removing

554
01:05:37,600 --> 01:05:46,400
the fat from some internal data structures used by the interpreter but uh the the key idea is an

555
01:05:46,400 --> 01:05:53,600
adaptive specializing interpreter let's go what is adaptive about it what is specialized about it

556
01:05:53,600 --> 01:05:59,040
well let me first talk about the specializing part because the adaptive part is the sort of

557
01:06:00,400 --> 01:06:07,520
the second order effect but they're both important so bytecode is a bunch of machine

558
01:06:07,520 --> 01:06:14,000
instructions but it's an imaginary machine but the machine can do things like call a function

559
01:06:14,960 --> 01:06:21,440
add two numbers print a value those are sort of typical instructions in python

560
01:06:23,680 --> 01:06:32,240
and if we take the example of adding two numbers actually in python the language there's no such

561
01:06:32,240 --> 01:06:39,360
thing as adding two numbers there's just the the compiler uh doesn't know that you're adding two

562
01:06:39,360 --> 01:06:47,440
numbers you might as well be adding two strings or two lists uh or two instances of some user-defined

563
01:06:47,440 --> 01:06:54,800
class that happen to implement this operator called add that's a very interesting and and

564
01:06:54,800 --> 01:07:00,800
fairly powerful mathematical concept it's mostly a user interface trick because it means that

565
01:07:02,560 --> 01:07:09,360
a certain category of functions uh can be written using a symbols single symbol the plus sign

566
01:07:10,400 --> 01:07:15,840
and sort of a bunch of other functions can be written using another single symbol the multiply

567
01:07:15,920 --> 01:07:25,760
sign uh so if we take addition the way traditionally in python the add bytecode was executed is

568
01:07:28,480 --> 01:07:36,080
pointers pointers and more pointers so first we we we have two objects an object is basically

569
01:07:36,080 --> 01:07:42,080
a pointer to a bunch of memory that contains more pointers pointers all the way down well not quite

570
01:07:42,160 --> 01:07:49,600
but there there are a lot of them so to simplify a bit uh we look up in one of the objects

571
01:07:51,280 --> 01:07:57,680
what is the type of that object and does that object type define an add operation

572
01:07:58,720 --> 01:08:05,920
and so you can imagine that there is a sort of a type integer that knows how to add itself to

573
01:08:05,920 --> 01:08:11,920
another integer and there is a type floating point number that knows how to add itself to

574
01:08:11,920 --> 01:08:20,080
another floating point number and the integers and floating point numbers are sort of important

575
01:08:20,080 --> 01:08:28,480
I think mostly historically because in the first computers uh you used the sort of the same bit

576
01:08:28,480 --> 01:08:33,120
pattern when interpreted as a floating point number had a very different value than when

577
01:08:33,120 --> 01:08:38,800
interpreted as an integer can ask a dumb question here please do given the basics of int and float

578
01:08:38,800 --> 01:08:47,040
and add who carries the knowledge of how to add two integers is it the integer it's the type integer

579
01:08:47,040 --> 01:08:54,080
versus it's the type integer and the type float what about the operator is the operator just

580
01:08:54,080 --> 01:09:02,400
exist as a platonic form possessed by the integer the operator is more like

581
01:09:04,560 --> 01:09:13,600
it's an index in a list of functions that the integer type defines and so the integer type

582
01:09:15,600 --> 01:09:21,920
is really a collection of functions and there is an add function and there's a multiply function

583
01:09:21,920 --> 01:09:26,960
and there are like 30 other functions for other operations there's a power function for example

584
01:09:28,000 --> 01:09:37,680
and you can imagine that in in memory there is a distinct slot for the add operations let's say the

585
01:09:37,680 --> 01:09:43,440
add operation is the first operation of a type and the multiply is the second operation of a type

586
01:09:44,080 --> 01:09:47,600
so now we take the integer type and we take the floating point type

587
01:09:48,560 --> 01:09:55,760
uh in both cases the add operation is the first slot and multiply is the second slot

588
01:09:56,480 --> 01:10:04,880
but each slot contains a function and the functions are different because the the add

589
01:10:04,880 --> 01:10:14,320
to integers function interprets the bit patterns as integers the add to float function interprets the

590
01:10:14,480 --> 01:10:20,320
same bit pattern as as a floating point number and then there is the string

591
01:10:21,360 --> 01:10:30,480
data type which again interprets the the bit pattern as the address of a of a sequence of

592
01:10:30,480 --> 01:10:36,960
characters there are lots of lies in that story but that's that's that's sort of a basic idea

593
01:10:36,960 --> 01:10:42,080
I could tell I could tell the fact the fake news and the fabrication going out here at the table

594
01:10:42,160 --> 01:10:45,920
but uh where's the optimization is it on the operators is it different

595
01:10:46,480 --> 01:10:55,840
so the optimization is the observation that in a particular line of code

596
01:10:57,200 --> 01:11:04,160
so now you you write your little python program and you write a function and that function sort of

597
01:11:04,160 --> 01:11:11,840
takes a bunch of inputs and at some point it adds two of the inputs together now I bet you even if

598
01:11:11,840 --> 01:11:20,400
you call your function a thousand times that all those calls are likely all going to be about integers

599
01:11:21,120 --> 01:11:28,640
because maybe your program is all about integers or maybe on that particular line of code where

600
01:11:28,640 --> 01:11:36,800
that there's that plus operator every time the program hits that line the variables a and b

601
01:11:36,800 --> 01:11:44,160
that b are being added together happen to be strings and so what we do is instead of having

602
01:11:44,160 --> 01:11:50,320
this single byte code that says here's an ad operation and the implementation of ad is fully

603
01:11:50,320 --> 01:11:56,240
generic it looks at the object from the object it looks at the type then it takes the type and it

604
01:11:56,240 --> 01:12:02,320
looks at looks up the function pointer then it calls the function now the function has to be

605
01:12:02,320 --> 01:12:06,400
has to look at the other argument and has to double check that the other argument has the

606
01:12:06,400 --> 01:12:13,600
right type and then there's a bunch of error checking before it can actually just go ahead

607
01:12:13,600 --> 01:12:23,120
and add the two bit patterns in the right way what we do is every time we execute an ad instruction

608
01:12:23,120 --> 01:12:34,880
like that we we keep a little note of in the end after after we hit the code that that did the addition

609
01:12:35,680 --> 01:12:45,280
for a particular type what type was it and then after a few times through that code if it's this

610
01:12:45,920 --> 01:12:57,440
same type all the time we say oh so this ad operation even though it's the generic ad operation

611
01:12:57,440 --> 01:13:05,200
it might as well be the ad integer operation and the ad integer operation is much more efficient

612
01:13:05,200 --> 01:13:12,320
because it just says assume that a and b are integers do the addition operation do it right

613
01:13:12,320 --> 01:13:23,680
there in line and produce the result and the big lie here is that in python even if you have great

614
01:13:23,680 --> 01:13:29,200
evidence that in the past it was always two integers that you were adding at some point in

615
01:13:29,200 --> 01:13:34,080
the future that same line of code could still be hit with two floating points or two strings or maybe

616
01:13:34,080 --> 01:13:41,360
a string and an integer it's not a great lie that's just the fact of life i didn't account for what

617
01:13:41,440 --> 01:13:48,640
should happen in that case in in the way i told the story there is some accounting for and and so

618
01:13:49,520 --> 01:13:57,040
what we actually have to do is when we have the ad integer operation we still have to check

619
01:13:58,160 --> 01:14:05,440
are the two arguments in fact integers we applied some tricks to make those checks efficient

620
01:14:06,240 --> 01:14:13,600
and we know statistically that the outcome is almost always yes they were they are both integers

621
01:14:15,280 --> 01:14:21,360
and so we quickly make that check and then we proceed with the the sort of ad integer operation

622
01:14:21,360 --> 01:14:26,800
and then there is a fallback mechanism where we say oops one of them wasn't an integer

623
01:14:27,760 --> 01:14:33,440
now we're going to pretend that there was just the fully generic ad operation we wasted a few

624
01:14:33,440 --> 01:14:40,080
cycles believing it was what was going to be two integers and then we had to back up

625
01:14:40,640 --> 01:14:48,800
but we didn't waste that much time and statistically most of the time basically we were we're sort of

626
01:14:49,920 --> 01:14:56,320
hoping that most of the time we guess right because if we if it turns out that we guessed wrong too

627
01:14:56,400 --> 01:15:03,440
often uh or we didn't have a good guess at all uh things might actually end up running a little

628
01:15:03,440 --> 01:15:11,440
slower so someone with armed with this knowledge and a copy of the implementation someone could

629
01:15:11,440 --> 01:15:17,440
easily construct a counter example where they say oh i have a program and now it runs five

630
01:15:17,440 --> 01:15:24,560
times as slow in python 3 11 than it did in python 3 10 but that's a very unrealistic program that's

631
01:15:24,640 --> 01:15:32,880
that's just like an extreme fluke it's a fun reverse engineering task though oh yeah so there's a

632
01:15:35,280 --> 01:15:45,280
people like fun yes so there's some presumably heuristic of what defines the momentum of

633
01:15:45,280 --> 01:15:51,120
saying you know you seem to be working adding two integers not two generic types uh so

634
01:15:51,840 --> 01:15:58,320
how do you figure out that heuristic i think that the heuristic is actually we assume that the

635
01:15:58,320 --> 01:16:02,480
weather tomorrow is going to be the same as the weather today so you don't need two days of the

636
01:16:02,480 --> 01:16:11,200
weather no that is already so much better than than than guessing randomly that so how do you

637
01:16:11,200 --> 01:16:21,600
find this idea hey i wonder if instead of adding two generic types we uh start assuming that the

638
01:16:21,600 --> 01:16:27,680
weather tomorrow is the same as the weather today where do you find the idea for that because that

639
01:16:27,680 --> 01:16:33,840
ultimately for you to do that you have to kind of understand how people are using the language

640
01:16:33,840 --> 01:16:40,160
right python is not the first language to do a thing like this this is a fairly well known trick

641
01:16:40,160 --> 01:16:47,840
especially from other interpreted languages that had reason to be sped up we occasionally

642
01:16:47,840 --> 01:16:58,560
look at papers about hhvm which is for facebook's efficient compiler for php there are tricks known

643
01:16:58,560 --> 01:17:06,160
from the jvm and sometimes it just comes from academia so the trick here is that the type itself

644
01:17:06,160 --> 01:17:12,560
doesn't the variable doesn't know what type it is so this is not a statically typed language where you

645
01:17:12,560 --> 01:17:19,760
can you can get afford to have a shortcut to saying it's ints this is a trick that is especially

646
01:17:19,760 --> 01:17:28,720
important for uh for interpreted languages with dynamic typing because if if the compiler could

647
01:17:28,720 --> 01:17:35,520
read in the source these x and y that we're adding are integers the compiler can just

648
01:17:35,520 --> 01:17:41,600
insert the single add machine code that hardware machine instruction that exists

649
01:17:42,560 --> 01:17:52,160
on every cpu and ditto for floats but because in python you don't generally declare your the

650
01:17:52,160 --> 01:17:57,760
types of your variables you you don't even declare the existence of your variables they just spring

651
01:17:57,760 --> 01:18:05,040
into existence when you first assign them which is really cool and and sort of helps those beginners

652
01:18:05,040 --> 01:18:10,800
because there is less bookkeeping they have to learn how to do before they can start playing

653
01:18:10,800 --> 01:18:18,960
around with code but it makes the the interpretation of the code less efficient and so we're we're sort of

654
01:18:19,280 --> 01:18:27,840
trying to to make the interpretation more efficient without losing the the super dynamic nature of

655
01:18:27,840 --> 01:18:37,440
the language that's always the challenge 3.5 got the pep 484 type hints what is type hinting and

656
01:18:38,080 --> 01:18:45,920
is it used by the interpreter the hints or is it just syntactic sugar so the type hints is an optional

657
01:18:46,080 --> 01:18:54,320
mechanism that people can use and it's especially popular with sort of larger companies that have

658
01:18:54,320 --> 01:18:59,600
very large code bases written in python do you think of it as almost like documentation saying

659
01:18:59,600 --> 01:19:07,600
these two variables are this type more than documentation i mean so it it it is a sub language

660
01:19:07,600 --> 01:19:14,080
of python where where you can express the types of variables so here's a variable and it's an

661
01:19:15,040 --> 01:19:20,880
integer and here's an argument to this function and it's a string and here is a function that

662
01:19:20,880 --> 01:19:27,280
returns a list of strings but that's not checked when you run the code but exactly there there is a

663
01:19:27,280 --> 01:19:33,120
separate piece of software called a static type checker that reads all your source code without

664
01:19:33,120 --> 01:19:42,160
executing it and thinks long and hard about what it looks from just reading the code that code

665
01:19:42,240 --> 01:19:50,800
might be doing and double checks if that makes sense if you take the types as annotated into

666
01:19:50,800 --> 01:19:56,480
account so this is something you're supposed to run as you develop it's like a linter yeah that's

667
01:19:56,480 --> 01:20:05,040
definitely a development tool but the type annotations currently are not used for speeding up the

668
01:20:05,040 --> 01:20:13,520
interpreter and there are a number of reasons uh many people don't use them even when they do use them

669
01:20:14,960 --> 01:20:21,440
they sometimes contain lies where the static type checker says everything's fine

670
01:20:22,560 --> 01:20:28,560
i cannot prove that this integer is ever not an integer but at runtime somehow someone

671
01:20:29,280 --> 01:20:36,960
manages to violate that assumption and the interpreter ends up doing just fine if we

672
01:20:37,600 --> 01:20:44,000
started enforcing type annotations in python many python programs would no longer work

673
01:20:45,120 --> 01:20:49,280
and some python programs wouldn't even be possible because they're too dynamic

674
01:20:50,000 --> 01:20:56,320
and so we made we made the choice of not using the annotations there there is a possible future

675
01:20:56,320 --> 01:21:06,160
where eventually three four five releases in the future we could start using those annotations to

676
01:21:06,160 --> 01:21:15,200
sort of provide hints because we can we can still say well the source code leads us to

677
01:21:15,200 --> 01:21:22,080
believe that these x and y are both integers and so we can generate an add an add integer instruction

678
01:21:23,040 --> 01:21:28,960
but we can still have a fallback that says oh if the if somehow the code

679
01:21:29,600 --> 01:21:34,800
coded runtime provided something else maybe it provided two decimal numbers

680
01:21:36,000 --> 01:21:42,320
we can still use that generic add operation as a fallback but we're not there is there currently

681
01:21:42,320 --> 01:21:50,080
a mechanism or do you see something like that where you can almost add like an assert inside

682
01:21:50,160 --> 01:21:56,880
a function that says please check that my type hints are actually mapping to reality

683
01:21:56,880 --> 01:22:05,280
sort of like insert manual static typing there are third party libraries that are in that business

684
01:22:05,280 --> 01:22:10,160
it's possible to do that kind of thing it's possible to for a third party library to take a hint

685
01:22:11,280 --> 01:22:16,880
and enforce it seems like a tricky thing but what what what we actually do is and this I think

686
01:22:16,880 --> 01:22:23,920
this is a fairly unique feature in python the type hints can be introspective at runtime

687
01:22:24,800 --> 01:22:32,960
so while the program is running they mean python is a very introspective language you can look at

688
01:22:32,960 --> 01:22:38,720
a variable and ask yourself what the what is the type of this this variable and if that maybe

689
01:22:38,720 --> 01:22:44,960
that variable happens to refer to a function you can ask what are the arguments to the function

690
01:22:45,680 --> 01:22:50,720
and nowadays you can also ask what are the type annotations for the function

691
01:22:50,720 --> 01:22:57,040
so the type annotations are there inside the variable as it's at runtime they're mostly associated

692
01:22:57,040 --> 01:23:03,760
with the function object not with each individual variable but uh right you can sort of map from

693
01:23:03,760 --> 01:23:08,720
from the arguments to the variables and that's what a third party library can help exactly and

694
01:23:08,720 --> 01:23:15,440
the problem with that is that all that extra runtime type checking uh is going to slow your

695
01:23:15,440 --> 01:23:22,720
code down instead of speed it up I think uh to reference this uh sales pitchy blog post

696
01:23:23,360 --> 01:23:28,720
that says 75% of developers time is spent on debugging I would say that in some cases that

697
01:23:28,720 --> 01:23:34,400
might be okay it might be okay to pay the cost of performance for the catching of the types

698
01:23:34,480 --> 01:23:43,920
the type errors and in most cases doing it statically before you ship your code to production

699
01:23:44,960 --> 01:23:50,880
is more efficient than doing it at runtime piecemeal yeah can you tell me about

700
01:23:52,400 --> 01:24:00,880
my py my py project what is it what's the mission and in general what is the future

701
01:24:00,880 --> 01:24:10,880
of static typing in python well so my py uh was started by a Finnish developer yuka letus hello

702
01:24:11,520 --> 01:24:16,480
so many cool things out of Finland I gotta say just that part of the world I guess people have

703
01:24:16,480 --> 01:24:22,720
nothing better to do in those long cold winters yeah I don't know I think yuka lived in England

704
01:24:22,720 --> 01:24:30,720
when he invented that stuff actually but my py is the original static type checker for python

705
01:24:30,960 --> 01:24:39,840
and the the type annotations that were introduced with pet 484 were sort of developed together

706
01:24:40,800 --> 01:24:47,200
with the the static type checker and in fact yuka had first invented a different syntax

707
01:24:47,200 --> 01:24:55,280
that wasn't quite compatible with python and uh yuka and I sort of met at a python conference

708
01:24:56,000 --> 01:25:07,760
in I think in 2013 and we we sort of came up with a compromise syntax that would not require any

709
01:25:07,760 --> 01:25:15,840
changes to python and that would let my py sort of be an add-on static type checker for python

710
01:25:15,840 --> 01:25:20,400
just out of curiosity was it like double colon or something what was he proposing that would break

711
01:25:20,400 --> 01:25:29,200
python I think he was using angular brackets for uh types like in c++ or uh java generics yeah you

712
01:25:29,200 --> 01:25:36,800
can't use angular brackets in python it'll be too tricky for temp well we the the key thing is that

713
01:25:36,800 --> 01:25:44,160
we already had uh no uh syntax for annotations we just didn't know what to use them for yet

714
01:25:45,120 --> 01:25:52,400
so type annotations were just the sort of most logical thing to to use that existing dummy

715
01:25:52,400 --> 01:26:02,880
syntax for but there was no there was no syntax for uh defining generics directly syntactically

716
01:26:02,880 --> 01:26:12,160
in the language my py literally meant my version of python where my it refers to yuka he had a

717
01:26:12,240 --> 01:26:20,960
parser that translated my py into python by like doing the type checks and then

718
01:26:21,680 --> 01:26:28,320
removing the annotations and all the angular brackets uh from the positions where where he

719
01:26:28,320 --> 01:26:35,520
was using them but a preprocessor model doesn't work very well with the typical workflow of

720
01:26:35,520 --> 01:26:41,440
python development projects that's funny I mean that could have been another major split if it

721
01:26:41,440 --> 01:26:49,760
became successful like uh if you watch typescript versus javascript is like a split in the community

722
01:26:49,760 --> 01:26:55,760
over types right that seems to be stabilizing now it's not necessarily a split there are certainly

723
01:26:55,760 --> 01:27:04,960
plenty of people who don't use typescript but just use the original javascript notation just

724
01:27:04,960 --> 01:27:09,920
like there are many people in the python world who don't use type annotations and don't use static

725
01:27:09,920 --> 01:27:14,960
type checkers now you know but there is a bit of a split between typescript and javas old school

726
01:27:14,960 --> 01:27:22,640
javascript es whatever well in the javascript world transpilers are sort of the standard way of

727
01:27:22,640 --> 01:27:29,600
working anyway which is why typescript being a transpiler itself is not a big deal and transpilers

728
01:27:29,600 --> 01:27:34,800
for people who don't know it's what's the exact thing you said with my py it's the code I guess

729
01:27:34,800 --> 01:27:39,360
you call preprocessing code that translates from one language to the other and that's part of the

730
01:27:39,360 --> 01:27:45,440
culture part of the workflow of the javascript community so that's right at the same time

731
01:27:46,320 --> 01:27:52,000
an interesting development in the javascript slash typescript world at the moment is that

732
01:27:52,960 --> 01:28:00,320
there is a proposal under consideration it's only a stage one proposal that proposes to add a feature

733
01:28:00,320 --> 01:28:11,280
to javascript where just like python it will ignore certain syntax when running the javascript code

734
01:28:12,080 --> 01:28:19,120
and what it ignores is more or less a superset of the typescript annotation syntax

735
01:28:20,720 --> 01:28:27,200
interesting so that would mean that eventually if you wanted to you could take typescript

736
01:28:28,080 --> 01:28:34,080
and you could shove it directly into a javascript interpreter without

737
01:28:34,080 --> 01:28:39,840
translation the interesting thing in the javascript world at least the web browser world

738
01:28:40,560 --> 01:28:48,320
the web browsers have changed how they deploy and they they sort of update their javascript engines

739
01:28:49,280 --> 01:28:55,600
much more quickly than they used to in the the early days and so there's much less of a need for

740
01:28:56,560 --> 01:29:03,920
translation in javascript itself because most browsers just support the most recent version

741
01:29:03,920 --> 01:29:11,040
of ECMAScript just an attention of attention do you see if you will recommend somebody use a thing

742
01:29:11,040 --> 01:29:17,680
would you recommend typescript or javascript i would recommend typescript just because of the

743
01:29:17,680 --> 01:29:24,560
strictness of the typing it's an enormously helpful extra tool that helps you sort of

744
01:29:26,880 --> 01:29:32,960
keep your head straight about what your code is actually doing i mean it's it's it

745
01:29:33,680 --> 01:29:41,520
it helps with editing your code it helps with ensuring that your code is not too incorrect

746
01:29:41,520 --> 01:29:48,720
and it's actually quite compatible with javascript never mind this syntactic

747
01:29:49,360 --> 01:29:56,560
sort of hack that is still years in the future but any library that is written in pure javascript

748
01:29:56,560 --> 01:30:03,440
can still be used from typescript programs and also the other way around you can write a library

749
01:30:03,440 --> 01:30:11,040
in typescript and then export it in a form that is totally consumable by javascript that sort of

750
01:30:11,520 --> 01:30:18,960
compatibility is is sort of the key to this to the success of typescript yeah just to look at

751
01:30:18,960 --> 01:30:23,040
it it's almost like a biological system that's evolving it's fascinating to see javascript

752
01:30:23,040 --> 01:30:27,680
evolve the way it does well maybe we should consider that biological systems are just

753
01:30:28,320 --> 01:30:36,480
engineering systems too right yes just very advanced with with more history but it's almost

754
01:30:36,560 --> 01:30:43,040
like the most visceral in the javascript world because there's just so much code written in

755
01:30:43,040 --> 01:30:50,960
javascript that for its history was messy if you talk about bugs per line of code i just feel like

756
01:30:50,960 --> 01:30:57,520
javascript eats the cake or whatever the terminology is it beats python by a lot in terms of the number

757
01:30:57,520 --> 01:31:05,040
of bugs meaning like way more bugs in javascript and then and then the obviously the browsers

758
01:31:05,600 --> 01:31:10,960
just there's so much active development it feels a lot more like evolution where a bunch of stuff

759
01:31:10,960 --> 01:31:18,960
is born and dies and there's experimentation debates versus python there's more all that stuff is

760
01:31:18,960 --> 01:31:25,120
happening but there's just a longer history of stable working giant software systems written in

761
01:31:25,120 --> 01:31:33,120
python versus javascript is just a giant beautiful i would say mess of code it's very different culture

762
01:31:33,200 --> 01:31:39,840
and to some extent differences in culture are random but to some extent they the differences

763
01:31:39,840 --> 01:31:46,800
have to do with the environment yeah and the fact that javascript is primarily

764
01:31:48,640 --> 01:31:56,880
the language for developing web applications especially the client side and the fact that it's

765
01:31:57,440 --> 01:32:04,560
basically the only language for developing web applications makes that community sort of just

766
01:32:04,560 --> 01:32:12,080
have a different nature than the community of other languages plus the graphical component

767
01:32:14,000 --> 01:32:19,760
and the fact that they're deploying it on all kinds of shapes of screens and devices and all

768
01:32:19,760 --> 01:32:25,680
that kind of stuff it just creates a beautiful chaos anyway back to my pie so what okay you

769
01:32:25,760 --> 01:32:30,720
met you talked about a syntax that could work where does it currently stand

770
01:32:31,600 --> 01:32:39,120
what's the future static typing in python it is still controversial but it is much more accepted

771
01:32:39,120 --> 01:32:46,800
than when my pie and pep 484 were were young what's the connection between pep 484 type hints

772
01:32:46,800 --> 01:32:56,560
and my pie my pie was the original static type checker so it my pie quickly evolved from yuka's

773
01:32:57,280 --> 01:33:06,160
own variant of python to a static type checker for python and sort of pep 484 that that was it like

774
01:33:07,680 --> 01:33:14,800
a very productive year where like many hundreds of messages were exchanged debating the merits

775
01:33:15,680 --> 01:33:24,640
of every aspect of of that pep and so my pie is a static type checker for python it is itself

776
01:33:24,640 --> 01:33:35,040
written in python most additional static typing features that we introduced in the time since 36

777
01:33:35,760 --> 01:33:45,200
uh were also prototyped through my pie my pie being an open source project with a very small

778
01:33:45,200 --> 01:33:52,400
number of maintainers it was successful enough that people said this static type checking stuff

779
01:33:52,400 --> 01:34:01,760
for python is actually worth an investment for our company nice but somehow they chose not to support

780
01:34:01,760 --> 01:34:12,960
making my pie faster say or adding new features to my pie but both google and facebook and later

781
01:34:12,960 --> 01:34:20,480
microsoft developed their own static type checker i think facebook was one of the first they

782
01:34:21,360 --> 01:34:28,640
decided that they wanted to use the same technology that they had successfully used for uh hhvm

783
01:34:28,640 --> 01:34:36,640
because they they sort of they had a bunch of compiler writers and and sort of static

784
01:34:36,640 --> 01:34:43,760
type checking experts who had written the hhvm compiler and it was a big success within the

785
01:34:43,760 --> 01:34:53,200
company and they had done it in a certain way sort of they wrote a big highly parallel application

786
01:34:53,200 --> 01:34:59,360
in an obscure language named oh camel which is apparently mostly very good for writing static

787
01:34:59,360 --> 01:35:05,760
type checkers interesting i have a lot of questions about how to write a static type

788
01:35:05,760 --> 01:35:11,680
checker then that's very confusing facebook wrote their version and they worked on it

789
01:35:11,680 --> 01:35:19,440
in secret for about a year and then they came clean and went open source uh google in the meantime

790
01:35:19,440 --> 01:35:27,600
was developing something called pie type which was mostly interesting because it as you may have

791
01:35:27,600 --> 01:35:36,240
heard they have one gigantic monorepo so all the code is checked into a single repository facebook

792
01:35:36,240 --> 01:35:42,400
has a different approach so facebook developed pyre which which was written in oh camel which

793
01:35:42,400 --> 01:35:50,880
worked well with facebook's development workflow uh google developed something they called py type

794
01:35:50,880 --> 01:35:58,320
which was actually itself written in python uh and it was meant to sort of fit well in

795
01:35:59,600 --> 01:36:06,960
their static type checking needs in google's gigantic monorepo so google was in one giant

796
01:36:07,040 --> 01:36:14,480
got it so the just to clarify this static type checker philosophically is the thing that's

797
01:36:14,480 --> 01:36:19,920
supposed to exist outside of the language itself and it's just a workflow like a debugger for the

798
01:36:19,920 --> 01:36:25,440
program it's a linter for people who don't know a linter maybe you can correct me but it's it's a

799
01:36:25,440 --> 01:36:32,480
thing that runs through the code continuously preprocessing to find issues based on style

800
01:36:33,200 --> 01:36:38,480
documentation i mean there's all kinds of linters right it can check that what usual

801
01:36:38,480 --> 01:36:44,960
things does a linter do maybe check that you haven't too many characters in a single line

802
01:36:45,760 --> 01:36:52,960
linters often do static analysis where they try to point out things that are likely mistakes but

803
01:36:52,960 --> 01:37:00,640
not incorrect according to the language specification like maybe you have a variable that you never use

804
01:37:01,520 --> 01:37:08,320
for the compiler that is valid you might sort of you might be planning to use it in a future

805
01:37:08,320 --> 01:37:13,680
version of the of the code and the compiler might just optimize it out but the compiler's not going

806
01:37:13,680 --> 01:37:20,240
to tell you hey you're never using this variable a linter will tell you that variable is not used

807
01:37:20,240 --> 01:37:26,080
maybe there's a typo somewhere else where you're meant to use it but you accidentally use something

808
01:37:26,080 --> 01:37:31,280
else or there are a number of sort of common scenarios and a linter is often

809
01:37:33,760 --> 01:37:40,880
a big collection of little heuristics where by looking at the combination of how your code is

810
01:37:40,880 --> 01:37:51,040
laid out maybe how it's indented maybe the common structure but also just things like definition

811
01:37:51,040 --> 01:37:58,400
of names use of names it'll tell you likely things that are wrong and in some cases linters are

812
01:37:59,120 --> 01:38:05,040
are really style checkers uh for python there are a number of linters that check things like

813
01:38:06,000 --> 01:38:13,680
do you use the the pep8 recommended naming scheme for your functions and classes and variables

814
01:38:14,320 --> 01:38:18,480
because like classes start with an uppercase and the rest starts with a lower case and

815
01:38:19,440 --> 01:38:25,600
there's like differences there and so the linter can tell you hey you have a class that uh whose

816
01:38:25,600 --> 01:38:32,400
first letter is not an uppercase letter and that's just i just find it annoying if i wanted that to

817
01:38:32,400 --> 01:38:38,240
be an uppercase letter i i would have typed an uppercase letter but other people find it very

818
01:38:38,240 --> 01:38:43,840
comforting that if the linter is no longer complaining about their code that they have

819
01:38:43,920 --> 01:38:49,040
followed all the style rules maybe it's a fast way for a new developer joining a team to learn

820
01:38:49,040 --> 01:38:54,400
the style rules right yeah there's definitely that but the best use of a linter is probably

821
01:38:55,600 --> 01:39:03,360
not so much to to sort of enforce team uniformity but to actually help developers

822
01:39:04,560 --> 01:39:11,360
catch bugs that the compilers for whatever reason don't catch and there is lots of that in python

823
01:39:12,000 --> 01:39:20,080
and so uh but aesthetic type checker focuses on uh a particular aspect of the linting which

824
01:39:21,120 --> 01:39:25,040
i mean it might probably doesn't care how you name your classes and variables

825
01:39:27,440 --> 01:39:33,440
but it is meticulous about when you say that there was an integer here and you're passing

826
01:39:33,440 --> 01:39:38,720
a string there it will tell you hey that string is not an integer so something's wrong either

827
01:39:39,360 --> 01:39:44,800
either you were incorrect when you said it was an integer or you're incorrect when you're passing

828
01:39:44,800 --> 01:39:50,240
into string if this is a race of static type checkers there's somebody winning as you said

829
01:39:50,240 --> 01:39:56,400
it's interesting that the companies didn't choose to invest in this centralized development

830
01:39:57,200 --> 01:40:04,560
of mypi is is is there a future for mypi what do you see is that well one of the companies

831
01:40:04,560 --> 01:40:12,960
went out and everybody uses like a py type whatever google's is called well microsoft is hoping that

832
01:40:13,600 --> 01:40:22,960
microsoft's horse in that race called py right is going to win py right right like ri ghd correct

833
01:40:22,960 --> 01:40:30,880
yeah my my all my word processors tend to type out correct that as py right the name of the i don't

834
01:40:30,880 --> 01:40:40,880
know what it is some kind of semi precious metal oh right i love it okay so okay that's the microsoft

835
01:40:40,880 --> 01:40:46,560
hope but okay so let me ask the question a different way is there going to be ever a future

836
01:40:46,560 --> 01:40:49,600
whereas the static type checker gets integrated into the language

837
01:40:53,200 --> 01:41:00,560
nobody is currently excited about doing any work towards that that doesn't mean that five

838
01:41:00,560 --> 01:41:12,000
or ten years from now the situation isn't different at the moment all the static type checkers

839
01:41:14,080 --> 01:41:23,680
still evolve at a much higher speed than python and its annotation syntax evolve you get a new

840
01:41:23,680 --> 01:41:30,880
release of python once a year those are the only times that you can introduce new annotation

841
01:41:30,880 --> 01:41:36,800
syntax and there's there are always people who invent new new annotation syntax that they're

842
01:41:36,800 --> 01:41:46,560
trying to push uh and worse once we've all agreed that we are going to put some new syntax in we

843
01:41:46,560 --> 01:41:53,920
can never take it back at least a sort of deprecating an existing feature takes many releases because

844
01:41:53,920 --> 01:41:59,840
you have to assume that people started using it as soon as we announced it and then you can't take

845
01:41:59,840 --> 01:42:06,240
it away from them right away you have to start telling them well this will go away but we're not

846
01:42:06,240 --> 01:42:12,240
gonna tell you that it's an error yet and then later it's going to be a warning and then eventually

847
01:42:12,320 --> 01:42:19,280
three releases in the future maybe we remove it on the other hand the typical static type checker

848
01:42:20,800 --> 01:42:22,560
still has a release like

849
01:42:25,120 --> 01:42:32,640
every month every two months certainly many times a year uh some type checkers also

850
01:42:32,640 --> 01:42:40,720
include a bunch of experimental ideas that aren't official standard python syntax yet

851
01:42:42,320 --> 01:42:49,920
the static type checkers also just get better at discovering things that that sort of are

852
01:42:49,920 --> 01:42:56,560
unspecified by the language but that sort of could make sense and so each static type checker actually

853
01:42:56,560 --> 01:43:02,640
has it's sort of strong and weak points so it's cool it's like a laboratory of experiments yeah

854
01:43:02,640 --> 01:43:07,600
microsoft google and all and you get to see and you see that everywhere right because there's not

855
01:43:07,600 --> 01:43:14,720
one single uh java script in engine either there is one in chrome there is one in safari there's one

856
01:43:14,720 --> 01:43:21,520
in firefox but that said you said there's not interest i think there is a lot of interest in

857
01:43:21,520 --> 01:43:28,560
type hinting right uh in the pep 484 actually like how many people use that do you have a sense

858
01:43:29,120 --> 01:43:35,680
how many people use because it's optional this is sugar i can't put a number on it but

859
01:43:36,720 --> 01:43:42,800
from the number of packages that do interesting things with it at runtime and the fact that there

860
01:43:42,800 --> 01:43:51,280
are like now three or four very mature type checkers that each have their their segment

861
01:43:51,280 --> 01:43:56,720
of the market and oh and then there is a pie charm which has a sort of more heuristic based

862
01:43:56,720 --> 01:44:05,680
type checker that also supports the same syntax my assumption is that many many people developing

863
01:44:05,680 --> 01:44:13,840
python software professionally for some kind of production situation are using a static type

864
01:44:13,840 --> 01:44:24,240
checker especially any anybody who has a continuous integration cycle probably has uh one of the steps

865
01:44:24,240 --> 01:44:32,240
in in there they're testing routine that that happens for basically every every commit uh is

866
01:44:32,240 --> 01:44:37,040
run a static type checker and in most in most cases that will be my pie

867
01:44:39,600 --> 01:44:48,560
so i think it's pretty popular topic according to this web page 20 to 30 of python three code

868
01:44:48,560 --> 01:44:54,800
bases are using type hints wow i wonder how they measured that did they just scan all of github

869
01:44:55,760 --> 01:45:01,200
yeah that's what it looks like yeah they did a quick sent not all of but like a random sampling

870
01:45:02,960 --> 01:45:07,440
so you mentioned pie charm let me ask you the uh the big subjective question

871
01:45:09,520 --> 01:45:16,080
what's the best ide for python and you're extremely biased now that you're with microsoft

872
01:45:17,440 --> 01:45:26,960
is it pie charm vs code vim or emacs historically i actually started out with using vim but when

873
01:45:26,960 --> 01:45:38,720
it was still called vi uh for a very long time i think from the early 80s to uh i'd say two years ago

874
01:45:39,920 --> 01:45:54,400
i was emacs user nice between i'd say 2013 and 2018 i dabbled with pie charm uh mostly because it had

875
01:45:55,360 --> 01:46:04,960
had a couple of features i mean pie charm is like driving an 18-wheeler truck whereas emacs is more

876
01:46:07,200 --> 01:46:15,680
like driving your comfortable Toyota car that's that's that you've had for 100,000 miles and you

877
01:46:15,680 --> 01:46:22,160
know what every little rattle of the car means i was very comfortable in emacs but there were

878
01:46:22,160 --> 01:46:28,800
certain things it couldn't do it wasn't very good at that sort of at least the way i had configured it

879
01:46:30,800 --> 01:46:35,200
i didn't have very good tooling in emacs for finding the definition of a function

880
01:46:36,640 --> 01:46:43,360
got it when i was at Dropbox exploring a five million line python code base

881
01:46:44,560 --> 01:46:51,680
uh just grabbing all that code for where there where is there a class foobar well turns out that

882
01:46:51,680 --> 01:46:56,400
if you grab all five million lines of code there are many classes with the same name

883
01:46:57,920 --> 01:47:05,360
and so pie charm sort of once once you fired it up and once it's indexed your repository

884
01:47:06,560 --> 01:47:13,200
was very helpful but the soonest i had to edit code i would jump back to emacs and do all my

885
01:47:13,200 --> 01:47:19,680
editing there because i could type much faster and switch between files when i when i knew which

886
01:47:19,680 --> 01:47:26,080
file i wanted much much quicker and i never really got used to the the whole pie charm user interface

887
01:47:26,800 --> 01:47:32,240
yeah i feel torn in that same kind of way because i've used pie charm off and on exactly in that

888
01:47:32,240 --> 01:47:39,280
same way and i feel like i'm just being an old grumpy man for not learning how to quickly

889
01:47:39,280 --> 01:47:42,720
switch between files and all that kind of stuff i feel like that has to do with shortcuts that has

890
01:47:42,720 --> 01:47:47,680
to do with um i mean you just have to get accustomed just like with touch typing yeah you have to just

891
01:47:47,680 --> 01:47:53,520
want to to learn that i mean if you don't need it much you don't need touch typing either you can

892
01:47:53,520 --> 01:47:59,280
type with two fingers just fine in the short term but in the long term your life will become better

893
01:47:59,840 --> 01:48:05,440
psychologically and productivity wise if you learn how to type with 10 fingers if you do a lot of

894
01:48:05,440 --> 01:48:12,720
keyboard input before everyone emails and stuff right like you look at the the next 20 30 years of

895
01:48:12,720 --> 01:48:19,040
your life you have to anticipate where technology is going um do you want to invest in handwriting

896
01:48:19,040 --> 01:48:25,520
notes probably not more and more people are doing typing versus handwriting notes so you can anticipate

897
01:48:25,520 --> 01:48:30,400
that so there's no reason to actually practice handwriting there's more reason to practice typing

898
01:48:31,440 --> 01:48:38,160
you can actually estimate back to the spreadsheet the number of paragraphs sentences or words you'll

899
01:48:38,160 --> 01:48:47,120
write for the rest of your life you can probably go again with the spreadsheet of my life i mean

900
01:48:47,120 --> 01:48:51,600
all of that is not actual like converted to a spreadsheet but the gut feeling

901
01:48:51,600 --> 01:48:56,720
like i have the same kind of gut feeling about books i've almost exclusively switched to kindle

902
01:48:56,720 --> 01:49:04,080
now for ebook readers even though i still love and probably always will the smell the feel of a

903
01:49:04,080 --> 01:49:11,440
physical book and you the reason i switched to kindle is like all right well this is really paving

904
01:49:12,160 --> 01:49:18,880
the future is going to be digital in terms of consuming books and content of that nature so

905
01:49:18,880 --> 01:49:24,240
you should get you know you should let your brain get accustomed to that experience and that same

906
01:49:24,240 --> 01:49:31,600
way it feels like pie charm or vs code i think pie charm is is the most sort of sophisticated

907
01:49:31,600 --> 01:49:40,000
feature full uh python id it feels like i should probably at some point very soon switch entire

908
01:49:40,000 --> 01:49:45,760
like i'm not allowed to use anything else for python than this id or vs code it doesn't matter

909
01:49:45,760 --> 01:49:50,560
but walk away from emacs for this particular application because i think i'm limiting myself

910
01:49:51,120 --> 01:49:56,640
in the same way that using two fingers for typing is limiting myself it's i'm this is a therapy

911
01:49:56,640 --> 01:50:03,440
session this is i'm not even but i'm sure a lot of people are thinking i'm not gonna stop you uh i

912
01:50:04,640 --> 01:50:10,720
i think that that's sort of everybody has to decide for themselves which one they want to

913
01:50:10,720 --> 01:50:21,440
invest more time in i actually ended up giving vs code a very tentative try when i started out at

914
01:50:21,440 --> 01:50:29,920
microsoft and really liking it and it sort of it took me a while before i realized why that was

915
01:50:30,880 --> 01:50:37,520
but and and i think that actually the founders of vs code may not necessarily agree with me on this

916
01:50:38,640 --> 01:50:49,760
but to me vs code is in a sense the spiritual successor of emacs because as you probably know

917
01:50:49,760 --> 01:50:59,200
as an old emacs hack the the key part of emacs is that it it's mostly written in in lisp and

918
01:50:59,200 --> 01:51:07,120
that that's sort of new features of of emacs usually update all the list packages and add new

919
01:51:07,120 --> 01:51:15,040
list packages and oh yeah there's also some very obscure thing improved in the part that's not in

920
01:51:15,040 --> 01:51:23,440
lisp but that's usually not why you would upgrade to a new version of emacs there's a core implementation

921
01:51:24,480 --> 01:51:31,760
that that sort of can read a file and it can put bits on the screen and it can sort of manage

922
01:51:31,760 --> 01:51:39,040
memory and buffers and then what makes it an editor full of features is all the list packages

923
01:51:39,680 --> 01:51:46,240
and of course the design of how the list packages interact with each other and with that that sort

924
01:51:46,240 --> 01:51:54,960
of that base layer of the core immutable engine but almost everything in that core engine in emacs

925
01:51:54,960 --> 01:52:06,800
case can still be overridden or replaced and so vs code has a similar architecture where there is

926
01:52:06,800 --> 01:52:16,000
like a base engine that you have no control over i mean it's open source but nobody

927
01:52:17,040 --> 01:52:27,280
except the people who work on that part changes it much and it has a sort of a package manager

928
01:52:28,240 --> 01:52:36,080
and a whole series of interfaces for packages and an additional series of conventions for how

929
01:52:36,080 --> 01:52:43,280
packages should interact with the lower layers and with each other and powerful primitive operations

930
01:52:43,280 --> 01:52:51,760
that let you move the cursor around or select pieces of text or delete pieces of text or

931
01:52:52,720 --> 01:52:56,640
interact with the keyboard and the mouse and whatever peripherals you have

932
01:52:56,880 --> 01:53:05,040
and and so the sort of the the extreme extensibility and the package ecosystem

933
01:53:05,760 --> 01:53:13,440
that you that you see in vs code is a mirror of very similar architectural features in emacs

934
01:53:14,240 --> 01:53:20,640
well i'll have to give it a serious try because as far as sort of the hype and the excitement

935
01:53:20,640 --> 01:53:25,360
in the general programming community vs code seems to dominate the interesting thing about

936
01:53:26,320 --> 01:53:34,480
our pie charm and what is it php storm which are these jetbrains specific ids that are designed

937
01:53:34,480 --> 01:53:41,840
for one programming language it's interesting to when an ids are specialized right they're usually

938
01:53:42,720 --> 01:53:49,840
actually just specializations of intelligent because underneath it's all the same editing

939
01:53:49,840 --> 01:54:03,280
engine with different veneer on top where in vs code many things you do require loading

940
01:54:03,280 --> 01:54:10,000
third-party extensions in pie charm it is possible to have third-party extensions

941
01:54:10,640 --> 01:54:17,360
but it is it is a struggle to create one yes it's not part of the culture all that kind of stuff

942
01:54:17,440 --> 01:54:23,840
yeah we that i remember that might have been five years ago or so we were trying to get

943
01:54:23,840 --> 01:54:30,720
some better my pie integration into pie charm because my pie is sort of python tooling and pie

944
01:54:30,720 --> 01:54:41,120
charm had had its own type checking heuristic thing that we wanted to replace with uh something

945
01:54:41,120 --> 01:54:47,360
based on my pie because that was what we were using in the company and it for the for the guy

946
01:54:47,360 --> 01:54:55,440
who was writing that by charm extension it was really a struggle to to sort of find documentation

947
01:54:55,440 --> 01:55:03,440
and get the development workflow going and and debug his code and all that so that that was

948
01:55:03,440 --> 01:55:10,160
was not a pleasant experience let me talk to you about parallelism in your post titled

949
01:55:10,240 --> 01:55:16,240
reasoning about asyncio semaphore you talk about a fast food restaurant in silicon valley that

950
01:55:16,240 --> 01:55:20,720
has only one table is this a real thing i just wanted to ask you about that is that just like a

951
01:55:20,720 --> 01:55:25,680
metaphor you're using or is that an actual restaurant in silicon valley it was it was a

952
01:55:25,680 --> 01:55:31,920
metaphor of course okay i can imagine such a restaurant so for people who don't then read the

953
01:55:31,920 --> 01:55:39,280
thing you should you should but it was a idea of a restaurant where there's only one table and you

954
01:55:39,280 --> 01:55:45,200
show up one at a time and they are prepared and actually looked it up and there is restaurants

955
01:55:45,200 --> 01:55:51,600
like this throughout the world and it just seems like a fascinating idea you stand in line you show

956
01:55:51,600 --> 01:55:58,080
up there's one table they um they ask you all kinds of questions they cook just for you that's

957
01:55:58,080 --> 01:56:04,240
fascinating it sounds like you'd find places like that in tokyo it sounds like a very japanese thing

958
01:56:04,240 --> 01:56:08,640
or in the bay area there are pop of places that probably more or less work like that but i've

959
01:56:08,640 --> 01:56:14,240
never eaten at such a place the fascinating thing is you propose is a fast food this is all for burger

960
01:56:14,240 --> 01:56:23,280
it was one of my rare sort of more literary or poetic moments where i thought i'll i'll just open

961
01:56:23,280 --> 01:56:30,640
with a crazy example to catch your attention and the rest is very dry stuff about uh locks and

962
01:56:30,640 --> 01:56:36,400
semaphores and how a semaphore is a generalization of a lock well it was very poetic and well

963
01:56:36,400 --> 01:56:41,280
delivered and it actually made me wonder if it's real or not because you don't make that explicit

964
01:56:41,280 --> 01:56:45,920
and it feels like it could be true and in fact i wouldn't be surprised if somebody like

965
01:56:45,920 --> 01:56:51,360
listens to this and knows exactly a restaurant like this in silicone valley anyway can we step back

966
01:56:51,360 --> 01:56:58,720
and can you just talk about parallelism concurrency threading asynchronous all these different terms

967
01:56:59,520 --> 01:57:04,960
what is it sort of a high philosophical level the uh the fisherman is back in the boat well

968
01:57:04,960 --> 01:57:13,360
the idea is if the fisherman has uh two fishing rods uh since fishing is mostly a matter of waiting

969
01:57:13,360 --> 01:57:19,280
for a fish to nibble well it depends on how you do it actually but if you had to if if you're doing

970
01:57:19,280 --> 01:57:25,360
the style of fishing where you sort of you you throw it out and then you let it sit for a while

971
01:57:25,360 --> 01:57:33,040
until maybe you see a nibble one fisherman can easily run two or three or four fishing rods and

972
01:57:33,040 --> 01:57:39,840
so as long as you can afford the equipment you can catch four times as many fish by a small

973
01:57:39,840 --> 01:57:46,080
investment in four fishing rods and so you since your time you sort of say you have all saturday

974
01:57:46,080 --> 01:57:52,800
to go fishing if you can catch four times as much fish you have a much higher productivity

975
01:57:52,800 --> 01:57:56,960
and that's actually i think how deep sea fishing is done you could just have a rod and you put in

976
01:57:56,960 --> 01:58:03,440
a hole so you can have many rods uh what is there an interesting difference between parallelism and

977
01:58:03,440 --> 01:58:09,920
concurrency and asynchronous is there one that's upset of the other to you like how do you think

978
01:58:09,920 --> 01:58:16,400
about these terms in the computer world there is a big difference when people are talking about

979
01:58:16,960 --> 01:58:27,840
parallelism like a parallel computer that's usually really several complete cpus that are

980
01:58:27,840 --> 01:58:39,120
sort of tied together and and share something like memory or an iobus concurrency can be a much

981
01:58:39,120 --> 01:58:49,120
more abstract concept where you have the illusion that things happen simultaneously but what the

982
01:58:49,120 --> 01:58:55,920
computer actually does is it spends a little time running some this program for a while and

983
01:58:55,920 --> 01:59:00,720
then it spends some time running that program for a while and then spending some time for the third

984
01:59:00,800 --> 01:59:08,000
program for a while so parallelism is the reality and concurrency is part reality part

985
01:59:08,000 --> 01:59:14,640
illusion yeah parallelism typically implies that there is multiple copies of the hardware

986
01:59:15,760 --> 01:59:20,880
you write that implementing synchronization primitives is hard in that blog post and you

987
01:59:20,880 --> 01:59:27,600
talk about locks and semaphores why is it hard to implement synchronization primitives because

988
01:59:28,160 --> 01:59:37,120
at the conscious level our brains are not trained to to sort of keep track of multiple things

989
01:59:37,120 --> 01:59:44,400
at the same time like obviously you can walk and chew gum at the same time because they're both

990
01:59:45,200 --> 01:59:52,400
activities that require only a little bit of your conscious activity but try balancing your

991
01:59:52,400 --> 02:00:00,480
checkbook and watching a murder mystery on tv yeah you'll mix up the digits or you'll miss

992
02:00:00,480 --> 02:00:06,000
an essential clue on in the tv show so why does it matter that the programmer the human

993
02:00:07,280 --> 02:00:13,760
is uh is bad because the programmer is at least with the current state of the art is responsible

994
02:00:13,760 --> 02:00:23,600
for writing the code correctly and it's hard enough to keep track of a recipe that you just

995
02:00:24,720 --> 02:00:34,400
execute one step at a time chop the carrots then peel the potatoes mix the icing you need your

996
02:00:34,400 --> 02:00:41,440
whole brain when you're when you're reading a piece of code what what is going on okay we're

997
02:00:41,440 --> 02:00:48,640
we're we're loading the number of mermaids in variable a and the number of mere men in variable

998
02:00:48,640 --> 02:00:55,920
b and uh now we take the average or whatever uh i like we're just jumping from metaphor to metaphor

999
02:00:55,920 --> 02:01:02,800
i like it you have to keep in your head what is in a what is in b what is in c uh hopefully you

1000
02:01:02,880 --> 02:01:12,960
have better names and that is challenging enough if you have two different pieces of code that are

1001
02:01:13,520 --> 02:01:21,120
are sort of being executed simultaneously whether it's using the parallel or the concurrent

1002
02:01:22,000 --> 02:01:31,760
approach if like a is the number of fishermen and b is the number of programmers but in another

1003
02:01:31,760 --> 02:01:37,600
part of the code a is the number of mermaids and b is the number of merman and somehow

1004
02:01:38,640 --> 02:01:44,160
that's the same variable if you do it sequentially if first you do your mermaids more people

1005
02:01:44,160 --> 02:01:50,400
computation and then you do your people in the boat computation it doesn't matter that the variables

1006
02:01:50,400 --> 02:01:56,160
are called a and b and that is literally the same variable because you you're done with one use of

1007
02:01:56,160 --> 02:02:03,200
that variable but when you mix them together suddenly the number of mere people replaces the

1008
02:02:03,200 --> 02:02:09,760
number of fishermen and your computation goes dramatically wrong and there's all kinds of ordering

1009
02:02:10,880 --> 02:02:15,600
of operations that could result in the assignment of those variables and so you have to anticipate

1010
02:02:15,600 --> 02:02:22,880
all possible orderings and you think you're smart and you'll put a look around it and in practice

1011
02:02:23,440 --> 02:02:30,720
in terms of bugs per line per thousand lines of code this is an area where everything is worse

1012
02:02:30,720 --> 02:02:39,760
so a lock is a mechanism by which you forbid only one chef can access the oven at a time

1013
02:02:40,960 --> 02:02:47,200
something like that and then semaphores allow you to do what multiple ovens that's not a bad

1014
02:02:47,200 --> 02:02:53,520
idea because if you're sort of if you're preparing if you're baking cakes and you have multiple people

1015
02:02:53,520 --> 02:02:59,520
all baking cakes but there's only one oven then maybe you can tell that the oven is in use but

1016
02:02:59,520 --> 02:03:05,440
maybe it's preheating and so you have to maybe maybe you make a sign that says oven in use

1017
02:03:07,200 --> 02:03:11,600
and you flip the sign over and it says oven is free when you're done baking your cake

1018
02:03:12,080 --> 02:03:19,280
and that's a lock that's sort of and and what do you do when you have two ovens or maybe you

1019
02:03:19,280 --> 02:03:25,760
have 10 ovens you you can put a separate sign on each oven or maybe you can sort of someone who

1020
02:03:25,760 --> 02:03:32,640
comes in wants to see at a glance and maybe there's an electronic sign that says there's

1021
02:03:32,640 --> 02:03:41,440
still five ovens available or maybe there are already three people waiting for an oven so you

1022
02:03:41,440 --> 02:03:48,240
can if you see an oven that's not in use it's already reserved for someone else who got in line

1023
02:03:48,240 --> 02:03:53,040
first and that's sort of what what what the restaurant metaphor was trying to explain

1024
02:03:53,680 --> 02:04:00,320
yeah and so you're now tasked you're sitting as a designer of python with a team of brilliant

1025
02:04:00,320 --> 02:04:04,960
core developers and you have to try to figure out to what degree can any of these ideas be

1026
02:04:04,960 --> 02:04:12,880
integrated and not so maybe this is a good time to ask what is a sync i o and how has it evolved

1027
02:04:12,880 --> 02:04:21,600
since python 3.4 wow yeah so we had this really old library for for doing things

1028
02:04:22,320 --> 02:04:30,560
concurrently especially things that had to do with i o and uh networking i o was especially

1029
02:04:30,560 --> 02:04:42,800
uh a sort of a popular topic and in the python standard library we had a brief period where

1030
02:04:42,800 --> 02:04:50,000
there was lots of development and i think it was late 90s maybe early 2000s and like

1031
02:04:51,600 --> 02:04:57,120
two little modules were added that were the state of the art of doing a synchronous i o or

1032
02:04:57,120 --> 02:05:03,200
sort of non-blocking a i o which means that you can keep multiple network connections open and

1033
02:05:03,200 --> 02:05:09,280
sort of service them all in parallel like a typical web server does so i o is input and

1034
02:05:09,280 --> 02:05:15,120
outputs you're writing either to the network yes the network connection or reading and writing to

1035
02:05:15,200 --> 02:05:22,000
hard drive the storage also possible and you can do uh the ideas you could do to multiple

1036
02:05:22,000 --> 02:05:28,800
while also doing computation so running some code that does some fancy stuff yeah like when

1037
02:05:28,800 --> 02:05:36,000
you're writing a web server when a request comes in a user the sort of needs to see a particular

1038
02:05:36,000 --> 02:05:42,640
web page uh you have to find that page maybe in the database and format it properly and send it

1039
02:05:42,640 --> 02:05:48,800
back to the client and there's a lot of waiting waiting for the database waiting for the network

1040
02:05:48,800 --> 02:05:55,680
and so you can handle hundreds or thousands or millions of requests concurrently on one machine

1041
02:05:55,680 --> 02:06:04,160
anyway waste of doing that in python were kind of stagnated and uh i forget it might have been around

1042
02:06:04,160 --> 02:06:16,080
2012 2014 uh when someone for the umpteenth time actually said these async chat and async core

1043
02:06:16,080 --> 02:06:21,840
modules that you have in the standard library are not quite enough to solve my particular problem

1044
02:06:22,720 --> 02:06:29,680
can we add one tiny little feature and everybody said no that stuff is not too but you're not

1045
02:06:29,680 --> 02:06:35,280
supposed to use that stuff write your own using uh third party library and then everybody started

1046
02:06:35,280 --> 02:06:44,320
the debate about what the right third party library was and somehow i i felt that there was

1047
02:06:44,320 --> 02:06:53,120
actually a queue for well maybe we need a better state of the art module in the standard library

1048
02:06:53,120 --> 02:06:59,200
for for multiplexing input output from different sources you could say that it spiraled out of

1049
02:06:59,280 --> 02:07:05,280
control a little bit it was at the time it was the largest python enhancement proposal that was

1050
02:07:05,280 --> 02:07:11,440
ever proposed and you were deeply involved with that at the time i was very much involved with

1051
02:07:11,440 --> 02:07:20,400
that i was like the lead architect uh i ended up talking to people who had already developed

1052
02:07:20,400 --> 02:07:26,960
serious third party libraries that did similar things and sort of taking ideas from them and

1053
02:07:27,920 --> 02:07:34,880
getting their feedback on my design and eventually we put it in the standard library and after a few

1054
02:07:34,880 --> 02:07:40,400
years i got distracted i think the thing the big thing that distracted me was actually type annotations

1055
02:07:41,680 --> 02:07:48,080
uh but other people kept it alive and kicking and it's been quite successful actually uh

1056
02:07:49,040 --> 02:07:54,640
in the world of python web clients so initially what are some of the design challenges there

1057
02:07:54,640 --> 02:07:59,120
in that debate for the pep and what are some things that got rejected what are some things that

1058
02:07:59,120 --> 02:08:07,040
got accepted to stand out to you there are a couple of different ways you can handle parallel i o and

1059
02:08:07,040 --> 02:08:13,200
this happens sort of at an architectural level in operating systems as well like windows prefers

1060
02:08:13,200 --> 02:08:20,400
to do it one way and unix prefers to do it the other way you sort of you have an object that

1061
02:08:20,400 --> 02:08:29,520
represents a network endpoint say a connection with a web browser that your client and say you're

1062
02:08:29,520 --> 02:08:37,200
you're waiting for an incoming request two fundamental approaches are okay i'm waiting

1063
02:08:37,200 --> 02:08:42,720
for an incoming request i'm doing something else come wake me up or of course sort of come tell me

1064
02:08:42,720 --> 02:08:47,440
when uh something interesting happened like a packet came in on that network connection

1065
02:08:48,320 --> 02:08:58,560
and the other paradigm is we're on a team of a whole bunch of people with maybe a little mind

1066
02:08:58,560 --> 02:09:08,640
and we we can only manage one web connection at a time so i'm just sitting looking at this

1067
02:09:08,720 --> 02:09:16,560
this web connection and i'm just blocked until something comes in and then uh i'm already waiting

1068
02:09:16,560 --> 02:09:23,840
for it uh i get i get the data i process the data and then i go back to the top and say no

1069
02:09:24,560 --> 02:09:31,760
sort of i'm waiting for the next packet those are about the two paradigms one is a paradigm

1070
02:09:31,760 --> 02:09:37,520
where there is sort of notionally a threat of control whether it's an actual operating system

1071
02:09:37,520 --> 02:09:44,800
thread or more an abstraction in asyncio we call them tasks but a task in asyncio or a

1072
02:09:44,800 --> 02:09:53,520
thread in other contexts is devoted to one thing and it has logic for all the stages like when it's

1073
02:09:53,520 --> 02:10:00,640
a web request like first wait wait for the first line of the web request parse it because then you

1074
02:10:00,640 --> 02:10:08,880
know if it's a get or a post or a put or whatever or an error then wait until you have a bunch of

1075
02:10:08,880 --> 02:10:15,360
lines until there's a blank line then parse that as headers and then interpret that and then wait

1076
02:10:15,360 --> 02:10:21,920
for the rest of the data to come in if there is any more that you request expect that sort of

1077
02:10:21,920 --> 02:10:29,120
standard web stuff and the other thing is and there's always endless debate about which approach

1078
02:10:29,120 --> 02:10:36,080
is more efficient and which approach is more error prone where i just have a whole bunch of stacks in

1079
02:10:36,080 --> 02:10:44,080
front of me and whenever a packet comes in i sort of look at the number of the pack that there's

1080
02:10:44,080 --> 02:10:51,200
some number on the packet and i say oh that packet goes on this pile and then i can do a little bit

1081
02:10:51,200 --> 02:10:58,160
and then sort of that pile provides my context and as soon as i'm done with with the processing i sort

1082
02:10:58,160 --> 02:11:04,400
of i can forget everything about what's going on because the next packet will come in from some

1083
02:11:04,400 --> 02:11:11,200
random other client and it's that pile or this pile uh and every time a pile is maybe empty or

1084
02:11:11,200 --> 02:11:18,640
full or whatever the criteria is i can toss it away or use it for a new space but several

1085
02:11:18,640 --> 02:11:25,680
traditional third party libraries for asynchronous i o processing in python chose the model of a

1086
02:11:25,680 --> 02:11:32,240
callback and that's that's the idea where you have a bunch of different stacks of paper in front of

1087
02:11:32,240 --> 02:11:38,160
you and every time someone gives you a piece gives you a new sheet you decide which stack it belongs

1088
02:11:38,160 --> 02:11:50,480
to and that leads to a certain style of spaghetti code that i find sort of aesthetically not pleasing

1089
02:11:50,480 --> 02:11:57,120
and i i was sort of never very successful and i had heard many stories about people who were also

1090
02:11:58,640 --> 02:12:05,680
sort of complaining about that style of coding uh it was very prevalent in javascript at the time

1091
02:12:05,680 --> 02:12:13,920
at least because it was like how the javascript event loop basically works and so i thought well

1092
02:12:13,920 --> 02:12:21,920
the task based model where each task has a bunch of logic we had mechanisms in the python language

1093
02:12:21,920 --> 02:12:29,360
that we could easily reuse for for that and i thought i want to build a whole library for

1094
02:12:29,360 --> 02:12:36,560
asynchronous networking i o uh and all the other things that may need to be done asynchronously

1095
02:12:37,520 --> 02:12:45,040
uh based on that paradigm and so i just chose a paradigm and try to see how far i could get

1096
02:12:45,040 --> 02:12:50,400
with that and it turns out that it's pretty good paradigm so people enjoy that kind of

1097
02:12:50,400 --> 02:12:59,840
paradigm programming for asynchronous i o relative to callbacks okay beautiful so how does that all

1098
02:12:59,840 --> 02:13:07,760
interplay with the infamous gill the goal the global interpreter lock maybe can you say what

1099
02:13:07,760 --> 02:13:14,800
the gill is and how does it dance beautifully with asynchio the global interpreter lock

1100
02:13:16,240 --> 02:13:22,320
solves the problem that python originally was not written with either asynchronous or or

1101
02:13:22,880 --> 02:13:27,200
parallelism in mind at all there was no concurrency in the language there was no

1102
02:13:27,200 --> 02:13:34,960
parallelism there were no threads only a small number of years into python's initial development

1103
02:13:35,920 --> 02:13:43,600
all the new cool operating systems like uh suno s and silicon graphics iris and then

1104
02:13:44,240 --> 02:13:51,760
eventually posix and windows all came with threading libraries that lets you do multiple

1105
02:13:51,760 --> 02:13:59,680
things in parallel and there is a certain certain sort of principle which is the operating system

1106
02:13:59,680 --> 02:14:09,920
handles the threads for you and the program can pretend that there are as many cpus as as there

1107
02:14:09,920 --> 02:14:19,360
are threads in the program and those cpus were completely independently and if you don't have

1108
02:14:19,360 --> 02:14:26,480
enough cpus the operating system sort of simulates those extra cpus on the other hand if you have

1109
02:14:26,480 --> 02:14:35,360
enough cpus you can get a lot of work done by deploying those multiple cpus but python wasn't

1110
02:14:35,440 --> 02:14:41,360
written to to do that and so

1111
02:14:43,920 --> 02:14:52,720
as libraries for for multi-threading were added to c but every operating system vendor was adding

1112
02:14:52,720 --> 02:15:00,080
their own version of that we thought and maybe we were wrong but at the time we thought well we

1113
02:15:00,080 --> 02:15:06,560
quickly want to be able to support these multiple threads because they seemed at the time in the

1114
02:15:06,560 --> 02:15:13,120
early 90s when they were new at least to me they seemed a cool interesting programming paradigm

1115
02:15:13,760 --> 02:15:20,240
and one of the things that that python at least at the time felt was nice about the language was

1116
02:15:20,240 --> 02:15:29,520
that we could give a safe version of all kinds of cool new operating system toys to the python

1117
02:15:29,520 --> 02:15:38,640
programmer like i remember one or two years before threading i i had spent some time adding

1118
02:15:38,640 --> 02:15:46,880
networking sockets to python and they were very literal translation of the networking sockets

1119
02:15:46,880 --> 02:15:53,920
that were in the bsd operating system so unix bsd but the nice thing was if you were using sockets

1120
02:15:53,920 --> 02:16:00,480
from python then all the things you can do wrong with sockets in c would automatically give you a

1121
02:16:00,480 --> 02:16:06,800
clear error message instead of just ending up with a malfunctioning hanging program and so we

1122
02:16:06,800 --> 02:16:14,640
thought well we'll do the same thing with threading but we didn't really want to rewrite the interpreter

1123
02:16:15,600 --> 02:16:24,080
to be thread safe because that that was was like that would be a very complex refactoring of all

1124
02:16:24,080 --> 02:16:29,600
the interpreter code and all the runtime code because all the objects were written with the

1125
02:16:29,600 --> 02:16:36,960
assumption that there's only one thread and so we said okay well we'll take our losses we'll provide

1126
02:16:36,960 --> 02:16:43,200
something that looks like threads and as long as you only have a single cpu on your computer

1127
02:16:43,200 --> 02:16:48,880
which most computers at the time did uh it feels just like threads because

1128
02:16:50,640 --> 02:16:56,560
the the whole idea of of multiple threads in the os was that even if your your computer only had

1129
02:16:56,560 --> 02:17:03,200
one cpu you could still fire up at many threads as you wanted well within reason maybe 10 or 12

1130
02:17:03,200 --> 02:17:14,720
not 5 000 and so we thought we had conquered the the abstraction of threads pretty well because

1131
02:17:14,720 --> 02:17:24,480
multi-core cpus were were not in in most python programmers hands anyway and then of course a

1132
02:17:24,480 --> 02:17:30,480
couple of more iterations of morse law and computers getting faster and at some point

1133
02:17:30,720 --> 02:17:39,280
uh the chip designers decided that they couldn't make the cpus faster but they could still make

1134
02:17:39,280 --> 02:17:45,920
them smaller and so they could put multiple cpus on one chip and suddenly there was all this pressure

1135
02:17:46,560 --> 02:17:53,520
about do things in parallel and that's where the the solution we had in python didn't work

1136
02:17:54,160 --> 02:18:02,000
and that's that's sort of the moment that the gill became became infamous because the gill the gill

1137
02:18:02,000 --> 02:18:10,080
was the solution we used to sort of take this single interpreter and share it between all the

1138
02:18:10,080 --> 02:18:16,960
different operating system threads that you could create and so as long as the the hardware

1139
02:18:17,040 --> 02:18:24,960
hardware physically only had one cpu that was all fine and then as hardware vendors were suddenly

1140
02:18:24,960 --> 02:18:32,480
telling us all oh you got to paralyze everything's got to be paralyzed people started saying oh uh

1141
02:18:32,480 --> 02:18:39,200
but we can use multiple threads in python and uh then they discovered oh but actually all threads

1142
02:18:39,200 --> 02:18:46,640
run on a single me a single core yeah i mean is there a way is there ideas in the future to remove

1143
02:18:47,360 --> 02:18:56,080
the global interpreter law gill like maybe multiple sub interpreters some tricky interpreters on top of

1144
02:18:56,080 --> 02:19:02,960
interpreters kind of thing yeah there there are a couple of possible uh futures there the

1145
02:19:03,920 --> 02:19:11,680
the most likely future is that we'll get multiple sub interpreters which each run a completely

1146
02:19:11,680 --> 02:19:22,080
independent python program nice but there there's still some benefit of of sort of faster communication

1147
02:19:22,080 --> 02:19:29,680
between those programs but it's also managing for you this running a multiple python programs

1148
02:19:30,480 --> 02:19:36,560
like yeah so it's hidden from you right the it's it's hidden from you but you have to spend more

1149
02:19:36,560 --> 02:19:44,400
time communicating between those programs because the sort of the attractive thing about the multi

1150
02:19:44,400 --> 02:19:51,280
threaded model is that the threads can share objects at the same time that's also the downfall

1151
02:19:51,280 --> 02:19:58,560
of the multi-threaded programming model because when you do share objects you weren't and you

1152
02:19:58,560 --> 02:20:07,120
didn't necessarily intend to share them or there were aspects of those objects that that were not

1153
02:20:07,120 --> 02:20:15,840
reusable you get all kinds of concurrency bugs and so the reason i wrote that little blog post

1154
02:20:15,840 --> 02:20:24,800
about semaphors was that concurrency bugs are just harder it would be nice if python had no

1155
02:20:24,800 --> 02:20:28,240
globally interpreter lock and it had the so-called free threading

1156
02:20:30,080 --> 02:20:38,480
but it would also cause a lot more software bugs the interesting thing is that there is still a

1157
02:20:38,480 --> 02:20:45,280
possible future where we are actually going to or where we could experiment at least with that

1158
02:20:46,240 --> 02:20:56,960
because there is a guy working for facebook who has developed a fork of c python that he called

1159
02:20:56,960 --> 02:21:05,040
the no gill interpreter where he removed the gill and made a whole bunch of optimizations

1160
02:21:05,040 --> 02:21:12,560
so that the single threaded case doesn't run too much slower and multi-threaded case will actually

1161
02:21:13,520 --> 02:21:15,360
use all the cores that you have

1162
02:21:17,600 --> 02:21:25,680
and so that that would be an interesting possibility if we would be willing as

1163
02:21:26,960 --> 02:21:36,880
python core developers to actually maintain that code indefinitely and if we're willing to put up

1164
02:21:36,880 --> 02:21:44,240
with the additional complexity of the interpreter and the additional sort of overhead for the single

1165
02:21:44,240 --> 02:21:57,600
threaded case and i'm personally not convinced that there are enough people needing the speed of

1166
02:21:57,600 --> 02:22:06,480
multiple threads with their python programs that it's worth to sort of take that performance

1167
02:22:06,480 --> 02:22:12,800
hit and that complexity hit and i i feel that the gill actually is a pretty nice

1168
02:22:13,840 --> 02:22:21,760
goldilocks point between no threads and all threads all the time but not everybody agrees on that

1169
02:22:21,760 --> 02:22:28,160
so that is definitely a possible future the sub interpreters look like a fairly safe bet for

1170
02:22:28,160 --> 02:22:34,800
312 so say a year from now a year so the goal is to do a new version every year

1171
02:22:35,600 --> 02:22:41,600
for python let me ask you perhaps a fun question but there's a philosophy to

1172
02:22:42,320 --> 02:22:49,840
will there ever be a python 4.0 now before you say it's currently a joke and probably not

1173
02:22:49,840 --> 02:22:58,960
we're going to go to 3.99 or 3.99999 can you imagine possible features

1174
02:22:59,440 --> 02:23:10,480
that python 4.0 might have that would necessitate the creation of the new 4.0 given the amount of

1175
02:23:11,440 --> 02:23:19,040
pain and joy suffering and triumph that was involved in the move between version 2 and version 3

1176
02:23:19,120 --> 02:23:31,600
yeah well we're we as a community and as a core development team we have a large amount of

1177
02:23:32,320 --> 02:23:40,880
painful memories about the python 3.0 transition which is one reason that sort of

1178
02:23:41,840 --> 02:23:47,680
everybody is happy that we've decided there's not going to be a 4.0 at least

1179
02:23:48,560 --> 02:23:55,360
not anytime soon and if there is going to be one it will sort of plan the transition very

1180
02:23:55,360 --> 02:24:03,200
differently because clearly we underestimated the pain that transition caused for our users

1181
02:24:03,200 --> 02:24:13,360
in the python 3.0 case and had we known we could have sort of designed python 3.0 somewhat

1182
02:24:13,360 --> 02:24:20,480
differently without making it any worse we just thought that we had a good plan but we

1183
02:24:21,440 --> 02:24:27,920
underestimated where what what sort of the users were capable of when it comes to that kind of

1184
02:24:27,920 --> 02:24:36,240
transition by the way i think we talked way before like a year and a half before the python 2

1185
02:24:36,240 --> 02:24:43,520
officially end of life end of life oh yeah what was that what was your memory of the end of life

1186
02:24:43,520 --> 02:24:50,160
did you shed a tear on january 1st 2020 that was there everyone standing alone the core team had

1187
02:24:50,160 --> 02:24:57,680
basically moved on years before yeah it was it was purely it was a little symbolic moment

1188
02:24:59,680 --> 02:25:03,840
to signal to the the remaining users that

1189
02:25:06,240 --> 02:25:12,560
there was no longer going to be any new releases or support for python 2.7

1190
02:25:13,200 --> 02:25:17,680
did you shed a single tear while looking out over the horizon

1191
02:25:18,880 --> 02:25:24,160
i'm not not a very poetic person and i don't shed tears like that but no

1192
02:25:26,640 --> 02:25:32,960
now we we actually had planned a party but the party was planned for the python con the

1193
02:25:32,960 --> 02:25:38,000
us python conference that year which would never happened of course because of the pandemic

1194
02:25:38,000 --> 02:25:44,480
oh is it like a march yeah the conference was uh going to be i think late april that year

1195
02:25:45,920 --> 02:25:49,200
so that that was a very difficult decision to cancel it but

1196
02:25:51,120 --> 02:25:56,640
they did so anyway if we're going to have a python 4 we're going to have to have both a

1197
02:25:56,640 --> 02:26:04,000
different reason for for having that and a different process for managing the transition

1198
02:26:04,000 --> 02:26:11,360
can you imagine a possible process that so so i think you're implying that if there is a 4.0 in

1199
02:26:11,360 --> 02:26:20,640
some ways it would break back compatibility well so here is here is a concrete thought i've had

1200
02:26:20,640 --> 02:26:26,080
and i'm not unique but not everyone agrees with this so this is definitely a personal opinion

1201
02:26:26,240 --> 02:26:38,000
if we were to try something like that no gill python uh my expectation is that

1202
02:26:39,840 --> 02:26:49,760
it would feel just different enough at least for the the part of the python ecosystem that

1203
02:26:50,720 --> 02:26:59,200
is heavily based on c extensions and that is like the entire machine learning data science

1204
02:26:59,200 --> 02:27:10,880
scientific python world is all based on c extensions for python and so those people would likely

1205
02:27:10,960 --> 02:27:21,200
feel the pain the most because they even if we don't change anything about the syntax of the

1206
02:27:21,200 --> 02:27:26,640
language and the semantics of the language when you're writing python code we we could even say

1207
02:27:26,640 --> 02:27:35,520
suppose that after python say 319 instead of 320 we'll have 4.0 suppose that's the time when we

1208
02:27:36,480 --> 02:27:46,320
flip the switch to 4.0 will will not have a gill imagine it was like that so i would probably

1209
02:27:46,320 --> 02:27:56,400
say that particular year the release that we named 4.0 will be syntactically it will not have any

1210
02:27:56,400 --> 02:28:02,960
new syntactical features no new modules in the standard library no new built-in functions

1211
02:28:03,280 --> 02:28:13,200
everything will be at the python level will be purely compatible with python 3.19 however

1212
02:28:14,800 --> 02:28:22,400
extension modules will have to make a change they will have to be recompiled they will not

1213
02:28:22,480 --> 02:28:36,000
have the same binary interface the semantics and and apis for for some things that are

1214
02:28:36,000 --> 02:28:43,120
frequently accessed by c extensions will be different and so for a pure python user

1215
02:28:44,160 --> 02:28:50,640
4.0 would be a breeze except that there are very few pure python users left because

1216
02:28:50,640 --> 02:28:56,880
everybody who is using python for something significant is using third-party extensions

1217
02:28:56,880 --> 02:29:03,280
there are like i don't know several hundreds of thousands of third-party extensions on the

1218
02:29:03,280 --> 02:29:11,280
pypi service and i'm not saying they're all they're all good but there is a large list of

1219
02:29:11,280 --> 02:29:18,320
extensions that would have to do work and some of those extensions are currently already low on

1220
02:29:18,400 --> 02:29:26,560
maintainers and they're struggling to keep afloat so there you can give a huge heads up to them

1221
02:29:26,560 --> 02:29:32,560
if you go to 4.0 to really keep developing it yeah we probably have to do something like

1222
02:29:34,960 --> 02:29:41,280
several years before who knows maybe five years earlier like 3.15 we would have to say

1223
02:29:42,080 --> 02:29:47,200
and and i'm just making that the specific numbers up but we at some point we'd have to say

1224
02:29:49,520 --> 02:29:54,960
the nogil python could be an option it might be a compile time option

1225
02:29:57,200 --> 02:30:04,320
if you want to use nogil python you have to recompile python from source for your platform

1226
02:30:04,320 --> 02:30:10,800
using your tool set all you have to do is change one configuration variable and then you just run

1227
02:30:10,800 --> 02:30:19,280
make or configure and make and it will build it for you but now you also have to use the

1228
02:30:19,280 --> 02:30:26,640
the nogil compatible versions of all extension modules you want to use and so as long as many

1229
02:30:26,640 --> 02:30:34,960
extension modules don't have fully functional sort of variants that work in the nogil world

1230
02:30:35,920 --> 02:30:42,720
that's not a very practical thing for python users but it would allow extension developers

1231
02:30:43,920 --> 02:30:51,360
to test the waters see what they need to syntactically to be able to compile at all maybe

1232
02:30:51,360 --> 02:30:58,400
they're using functions that are defined by the python 3 runtime that won't be in the python 4

1233
02:30:58,400 --> 02:31:02,720
runtime those functions will not work they'll have to find an alternative

1234
02:31:04,320 --> 02:31:10,240
but they can experiment with that and sort of write test applications and that would be a way

1235
02:31:10,240 --> 02:31:19,600
to transition and that that could be a series of releases where that python 4 is more and more imminent

1236
02:31:20,560 --> 02:31:28,480
we have supported more and more third-party extension modules to have solid support that

1237
02:31:28,480 --> 02:31:40,080
works for nogil python for that new api and then sort of python python 4.0 is like the official

1238
02:31:40,080 --> 02:31:47,600
moment that the mayor comes out and cuts the ribbon and now python now the sort of nogil mode

1239
02:31:47,680 --> 02:31:53,840
is the default and maybe the only mode there is the internet wants to know from reddit

1240
02:31:57,040 --> 02:32:00,080
it's uh it's a small and fun question there's many fun questions but

1241
02:32:01,680 --> 02:32:09,600
out of the pypy packages pypi packages do you have a do you have ones you like do you in your

1242
02:32:09,600 --> 02:32:16,400
opinion are there must have pypy libraries or ones you use all the time constantly oh my that

1243
02:32:18,000 --> 02:32:23,120
i should really have a standard answer for that question but like a positive standard

1244
02:32:23,120 --> 02:32:29,200
answer but my current standard answer is that i'm not a big user of third-party packages

1245
02:32:30,080 --> 02:32:36,720
when i write python code i'm usually developing some tooling around building python itself

1246
02:32:38,640 --> 02:32:45,120
and uh the last thing we want is dependencies on third-party packages so i i tend to just

1247
02:32:45,120 --> 02:32:48,880
use the standard library and that's where your focus is that's where your mind is

1248
02:32:50,240 --> 02:32:56,240
but do you do you keep an eye of what's out there to understand where the standard library

1249
02:32:56,240 --> 02:33:02,080
could be moving should be moving it's a good kind of landscape of what's missing from the standard

1250
02:33:02,080 --> 02:33:11,280
library well usually when something's missing from the standard library nowadays uh it is a

1251
02:33:11,280 --> 02:33:20,560
relatively new idea and there is a third-party implementation or maybe possibly multiple third

1252
02:33:20,560 --> 02:33:27,120
party implementations but they evolve at a much higher rate than they could when they're in the

1253
02:33:27,120 --> 02:33:37,120
standard library so they it would be a big reduction in in activity to incorporate things like that

1254
02:33:37,120 --> 02:33:42,640
in the standard library so i i like that there is a lively package ecosystem and that sort of

1255
02:33:43,280 --> 02:33:47,920
recent trends in the standard library are actually that we're doing the occasional

1256
02:33:47,920 --> 02:33:59,840
spring cleaning where we're just we're we're choosing some modules that have not had a lot of

1257
02:33:59,840 --> 02:34:08,880
change in a long time and that maybe would be better off not existing at all at this point

1258
02:34:08,880 --> 02:34:14,880
because there might be a better third-party alternative anyway and we're we're sort of

1259
02:34:14,880 --> 02:34:22,640
slowly removing those that like often those are things that i sort of i spiked somewhere in 1992

1260
02:34:22,640 --> 02:34:32,160
or 1993 and if you look look through the commit history it's very sad like all cosmetic changes

1261
02:34:32,160 --> 02:34:39,040
like changes in the indentation style or the name of this other standard library module got changed

1262
02:34:39,040 --> 02:34:46,000
or nothing nothing of any substance the api is identical to what it was 20 years ago

1263
02:34:46,960 --> 02:34:54,480
so speaking of packages they have a a lot of impact on a lot of people's lives does it make

1264
02:34:54,480 --> 02:35:00,000
sense to you why python has become the primary the dominant language for the machine learning

1265
02:35:00,000 --> 02:35:06,640
community so packages like pie torch tensorflow second learn and even like the lower level

1266
02:35:06,640 --> 02:35:13,200
stuff like non-pi sci-pi pandas matplot lib with visualization can you like does it make sense to

1267
02:35:13,200 --> 02:35:23,120
you why it uh permeated the entire data science machine learning ai community well it's part of

1268
02:35:23,120 --> 02:35:29,040
it is an effect that's as simple as we're all driving on the right side of the road right

1269
02:35:29,200 --> 02:35:37,840
uh it's compatibility yeah it's it's and and and part of it is uh

1270
02:35:39,680 --> 02:35:45,440
not not quite as as as fundamental as driving on the right side of the road which you have to do

1271
02:35:45,440 --> 02:35:51,440
for for safety reasons i mean you have to agree on something every they could have picked javascript

1272
02:35:51,440 --> 02:35:56,640
or pearl there was there was a time in the early 2000s that it really looked like pearl what was

1273
02:35:57,200 --> 02:36:03,680
going to dominate like biosciences because dna search was all based on regular expressions

1274
02:36:03,680 --> 02:36:10,240
and pearl has the fastest and most comprehensive regular expression engine still does i spent

1275
02:36:10,240 --> 02:36:16,720
quite a long time with pearl that was another letting go letting go of this kind of uh data

1276
02:36:16,720 --> 02:36:27,520
processing uh system the reasons why python became the lingua franca of the scientific code and and

1277
02:36:29,760 --> 02:36:37,040
machine learning in particular and data science it really had a lot to do with

1278
02:36:38,320 --> 02:36:46,000
anything was better than c or c plus plus recently a guy who worked at lauren's livermore

1279
02:36:46,000 --> 02:36:55,840
national laboratories in the the sort of computing division wrote me his his his memoirs and and he

1280
02:36:55,840 --> 02:37:04,480
had his his own view of how he helped something he called computational steering into existence

1281
02:37:06,240 --> 02:37:12,560
and this was the idea that you you take libraries that in in his days were written in fortran

1282
02:37:13,120 --> 02:37:16,800
that that solved universal mathematical problems

1283
02:37:19,200 --> 02:37:24,640
and those libraries still work but uh the scientists that use the libraries

1284
02:37:25,680 --> 02:37:33,360
use them to solve continuously different specific applications and answer different

1285
02:37:33,360 --> 02:37:42,880
questions and so those poor scientists were were required to to use say fortran because fortran

1286
02:37:42,880 --> 02:37:49,360
was the library the language that the library was written in and then the scientist would have to write

1287
02:37:50,080 --> 02:37:58,400
an application that sort of uses the library to solve a particular equation or set off of answer

1288
02:37:58,400 --> 02:38:06,640
a set of questions and the same for c plus plus because there's there's interoperability so the

1289
02:38:06,640 --> 02:38:15,360
dusty decks are written either in c plus plus or fortran uh and so paul du bois was one of the people

1290
02:38:15,360 --> 02:38:25,840
who i think in the mid 90s saw that that you needed a higher level language for the scientists

1291
02:38:26,240 --> 02:38:34,320
to to sort of tie together the fundamental mathematical algorithms of linear algebra

1292
02:38:34,320 --> 02:38:45,200
and and other stuff and so gradually some libraries started appearing that did very fundamental

1293
02:38:45,840 --> 02:38:53,840
stuff with arrays of numbers in python i mean when i first created python i was not expecting it to

1294
02:38:53,840 --> 02:39:00,320
be used for arrays of numbers much i thought that was like an outdated data type and everything was

1295
02:39:00,320 --> 02:39:07,280
like objects and strings and like python was good and fast at string manipulation and objects

1296
02:39:07,280 --> 02:39:13,280
obviously but arrays of numbers were not very efficient and the multi-dimensional arrays didn't

1297
02:39:13,280 --> 02:39:22,160
even exist in the language at all uh but there were people who realized that python had extensibility

1298
02:39:24,080 --> 02:39:31,760
that was flexible enough that they could write third-party packages that did support

1299
02:39:31,760 --> 02:39:38,880
large arrays of numbers and operations on them very efficiently and somehow they got a foothold

1300
02:39:39,600 --> 02:39:46,800
through sort of different parts of the scientific community i i remembered that the Hubble space

1301
02:39:46,880 --> 02:39:54,080
telescope people in baltimore were somehow big python fans in the late 90s and at various

1302
02:39:54,640 --> 02:40:03,600
points small improvements were made and more people got in touch with using python to derive

1303
02:40:03,600 --> 02:40:12,800
these libraries of interesting uh algorithms and like once once you have a bunch of scientists

1304
02:40:12,800 --> 02:40:18,800
who are working on similar problems say they're all working on stuff that that data that comes in

1305
02:40:18,800 --> 02:40:23,760
from the Hubble space telescope but they're looking at different things some some are looking at stars

1306
02:40:23,760 --> 02:40:30,000
in this galaxy other are looking at galaxies the math is completely different but the the underlying

1307
02:40:31,040 --> 02:40:39,360
libraries are still the same and so they exchange code they say well i wrote this python program

1308
02:40:39,360 --> 02:40:46,880
or i wrote a python library to solve this class of problems and the other guys either say oh i can

1309
02:40:46,880 --> 02:40:54,160
use that library too or if you make a few changes i can use that library too why right why start from

1310
02:40:54,160 --> 02:41:02,160
scratch in pearl or java script where there's not that infrastructure uh for arrays of numbers yet

1311
02:41:02,160 --> 02:41:08,640
whereas in python you have it and so more and more scientists at different places doing different

1312
02:41:09,680 --> 02:41:18,000
different work discovered python and then then people who had an idea for an important new

1313
02:41:18,000 --> 02:41:27,760
fundamental library decided oh python is is actually already known to our users so let's use python as

1314
02:41:27,760 --> 02:41:32,640
the user interface i think that's how tensor i imagine at least that's how tensor flow ended up

1315
02:41:32,640 --> 02:41:39,840
with python as the user interface interface right but with tensor flow there's a deeper

1316
02:41:40,640 --> 02:41:45,760
history of what the community is it's not just like what packages it needs it's like what the

1317
02:41:45,760 --> 02:41:53,600
community leans on for programming language because tensor flow had a prior library that was

1318
02:41:53,600 --> 02:41:59,760
internal to google but there was also competing machine learning frameworks like the ano

1319
02:42:00,480 --> 02:42:07,760
cafe they were in python there was some scala um some other languages but python was really

1320
02:42:07,760 --> 02:42:14,080
dominating it and it's interesting because um there's other languages from the engineering

1321
02:42:14,080 --> 02:42:22,480
space like matlab that a lot of people used but different design choices by the company by the

1322
02:42:22,480 --> 02:42:30,480
core developers led to it not spreading and one of the choices with matlab by mathworks is to not

1323
02:42:30,480 --> 02:42:36,560
make it open source right or yeah not you know having people pay it was a very expensive product

1324
02:42:36,560 --> 02:42:44,160
and so uh universities especially disliked it because it was a price per seat i i remember hearing

1325
02:42:45,120 --> 02:42:52,240
yeah but i think that's not why it failed or i failed to spread i think the universities

1326
02:42:52,240 --> 02:42:58,720
didn't like it but they would still pay for it the thing is it didn't feed into that github open

1327
02:42:58,720 --> 02:43:08,080
source uh packages culture so like and that's somehow a precondition for um for viral spreading

1328
02:43:08,080 --> 02:43:13,440
the hacker culture like the tinkerer culture uh with with python it feels like you can build a

1329
02:43:13,440 --> 02:43:18,160
package from scratch or solve a particular problem and get excited about sharing that package with

1330
02:43:18,160 --> 02:43:24,400
others and that creates an excitement about a language i tend to like python's approach to

1331
02:43:24,400 --> 02:43:33,440
open source in particular because it's sort of it's almost egalitarian uh there's there's little

1332
02:43:33,440 --> 02:43:39,600
hierarchy there's there's obviously some because like you all need to decide whether you drive on

1333
02:43:39,600 --> 02:43:46,320
the left or the right side of the road sometimes but there is a lot of access for people with

1334
02:43:46,320 --> 02:43:52,160
little power you don't have to work for a big tech company to make a difference in the python world

1335
02:43:54,160 --> 02:44:00,720
we have affordable events that really care about community and support people

1336
02:44:01,520 --> 02:44:10,400
and sort of the community is is is like a big deal at our conferences and in in the psf

1337
02:44:10,960 --> 02:44:20,400
when the psf funds events it's always about growing the community the psf funds very little

1338
02:44:20,400 --> 02:44:27,760
development they that they do some but most of the develop most of the money that the psf

1339
02:44:28,560 --> 02:44:38,640
forks out uh is to community fostering things so speaking of egalitarian last time we talked

1340
02:44:38,640 --> 02:44:45,520
four years ago it was just after you stepped down from your role as the benevolent dictator for

1341
02:44:45,520 --> 02:44:52,800
life bdfl now looking back what are your insights and lessons you learn from that experience about

1342
02:44:52,800 --> 02:45:02,480
python developer community about human nature about human civilization life itself oh my uh

1343
02:45:04,000 --> 02:45:13,520
i probably held on to the position too long i remember being just extremely stressed for a

1344
02:45:13,520 --> 02:45:23,360
long time and it wasn't very clear to me what was leading what was causing the stress

1345
02:45:26,320 --> 02:45:38,800
and looking back uh i i should have sort of relinquished my central role as bdfl sooner

1346
02:45:39,040 --> 02:45:45,520
what were the pros and cons of the bdfl role like what were the you not relinquishing it what

1347
02:45:45,520 --> 02:45:51,280
what what are the benefits of that for the community and what are the drawbacks well the

1348
02:45:51,280 --> 02:46:02,240
the benefits for the community would be things like uh clarity of vision and sort of

1349
02:46:02,240 --> 02:46:13,040
a clear direction because i i had certain ideas in in mind when i created python and

1350
02:46:13,040 --> 02:46:20,400
while i sort of let myself be influenced by many other ideas as python evolved and became

1351
02:46:22,000 --> 02:46:30,800
more successful and more complex and more used i also stuck to certain principles and it and

1352
02:46:30,800 --> 02:46:40,320
still hard to say what are python's core principles but the fact that i was playing that role and

1353
02:46:40,320 --> 02:46:50,800
sort of always very active grew the community in a certain way it modeled to the community how to

1354
02:46:50,800 --> 02:46:58,240
think about how to how to solve a certain problem well that was a source of stress but it was also

1355
02:46:58,240 --> 02:47:03,520
beneficial it was a source of stress for me personally but it was beneficial for the community

1356
02:47:03,520 --> 02:47:12,800
because uh people people sort of over time had learned how i was thinking and could predict

1357
02:47:14,240 --> 02:47:19,920
yeah but how how i would would decide about a particular issue and not always perfectly of

1358
02:47:19,920 --> 02:47:26,320
course but there was like there wasn't a lot of jerking around like this year we're all

1359
02:47:26,880 --> 02:47:32,400
this year the democrats are in power and we're doing these kind of things and now the republicans

1360
02:47:32,400 --> 02:47:38,880
are in power and they roll all that back and do those kind of things there is a clear fairly

1361
02:47:38,880 --> 02:47:46,320
straight path ahead and so fortunately the the successor structure with the steering council

1362
02:47:47,120 --> 02:47:55,280
has has sort of found a similar way of of leading the community in a fairly steady

1363
02:47:55,280 --> 02:48:01,840
direction without stagnating and and for me personally it's more fun because there are

1364
02:48:01,840 --> 02:48:08,320
there are things i can just ignore yeah oh yeah there's a bug in multi-processing let someone

1365
02:48:08,320 --> 02:48:15,120
else decide whether that's important to solve or not i'll i'll i'll stick to typing in the

1366
02:48:15,120 --> 02:48:20,960
async io and the faster interpreter yeah it allows you to focus a little bit more yeah

1367
02:48:23,040 --> 02:48:27,520
what are interesting differences in culture if you can comment on between google dropbox and

1368
02:48:27,520 --> 02:48:32,640
microsoft from a python programming perspective all places you've been to the positive

1369
02:48:34,560 --> 02:48:40,000
is there a difference or is it just about people and there's great people everywhere

1370
02:48:40,080 --> 02:48:47,040
or is there a culture differences sort of dropbox is much smaller than the other two in your list

1371
02:48:47,760 --> 02:48:55,520
yeah so that that is a big difference the set of products they provide is more it's narrower so

1372
02:48:55,520 --> 02:49:02,160
they're more focused smaller code based yeah and and dropbox sort of at least during the time i was

1373
02:49:02,160 --> 02:49:11,120
there had the tendency of sort of making a big plan putting the whole company behind that plan

1374
02:49:11,120 --> 02:49:19,920
for a year and then evaluate and then suddenly find that everything was wrong about the plan

1375
02:49:19,920 --> 02:49:24,800
and then they had to do something completely different and so there were there was like

1376
02:49:25,760 --> 02:49:32,480
the annual engineering reorg was was sort of an unpleasant tradition at dropbox because like

1377
02:49:32,480 --> 02:49:37,360
oh there's a new vp of engineering and so now all the directors are being reshuffled and

1378
02:49:38,080 --> 02:49:45,040
this guy was in charge of of infrastructure one year and the next year he was made in

1379
02:49:45,040 --> 02:49:50,320
charge of i don't know product development it's fascinating because like you don't think about

1380
02:49:50,320 --> 02:49:56,160
these companies internally but i you know dropbox to me from the very beginning was one of my favorite

1381
02:49:56,800 --> 02:50:02,880
uh services there's certain like programs and online services that make me happy make me more

1382
02:50:02,880 --> 02:50:08,080
efficient and all that kind of stuff but one of the powers of those kinds of services they disappear

1383
02:50:08,080 --> 02:50:12,400
that you're not supposed to think about how it all works but it's incredible to me that you can

1384
02:50:12,480 --> 02:50:20,880
think stuff effortlessly across so many machines so quickly and like don't have to worry about

1385
02:50:20,880 --> 02:50:26,480
conflicts they they take care of the you know as a person that comes from a version of repositories

1386
02:50:26,480 --> 02:50:32,480
and all that kind of stuff or merge is super difficult and uh just keeping different versions

1387
02:50:32,480 --> 02:50:36,320
of different files is very tricky the fact that they could take care of that just i don't know

1388
02:50:36,880 --> 02:50:42,000
the the engineering behind the scenes must be super difficult both on the compute infrastructure

1389
02:50:42,080 --> 02:50:48,240
and the software a lot of internal sort of hand-wringing about things like that

1390
02:50:49,120 --> 02:50:55,760
but the the product itself always worked very smoothly yeah well there's probably a lot of

1391
02:50:55,760 --> 02:51:01,680
lessons to that you can have a lot of turmoil inside on the engineering side but if the product

1392
02:51:01,680 --> 02:51:06,400
is good the product is good and don't maybe don't mess with that either to you know when it's good

1393
02:51:06,400 --> 02:51:14,400
keep it's like with google focus on the search and the ads right and the money will come yeah

1394
02:51:14,400 --> 02:51:19,040
and make sure that's done extremely well and don't forget what you do extremely well in

1395
02:51:19,600 --> 02:51:25,280
in what ways do you provide value and happiness to the world make sure you do that well

1396
02:51:26,800 --> 02:51:31,600
is there something else to say about google and microsoft microsoft has had a very fascinating

1397
02:51:31,600 --> 02:51:38,960
shift recently with the new ceo uh what you know recent ceo with purchasing github

1398
02:51:39,920 --> 02:51:44,480
embracing open source culture embracing the developer culture is pretty interesting to see

1399
02:51:44,480 --> 02:51:50,960
that's like why i joined microsoft i mean after after retiring and thinking that i would

1400
02:51:51,680 --> 02:51:55,440
stay retired for the rest of my life which of course was a ridiculous thought

1401
02:51:56,160 --> 02:52:02,400
but that i was i was done working for a bit and then the pandemic made me realize that work

1402
02:52:02,400 --> 02:52:08,640
work and also provide a source of fulfillment keep you keep you out of trouble

1403
02:52:11,200 --> 02:52:18,880
microsoft is a very interesting company because it has this incredible very long and

1404
02:52:19,520 --> 02:52:28,880
varied history and this amazing catalog of products that many of which also date way back

1405
02:52:29,840 --> 02:52:39,040
i mean i've been been talking to a bunch of excel people lately and excel is like 35 years old

1406
02:52:39,040 --> 02:52:46,080
yeah and they can still read spreadsheets that that they might find on an old floppy drive

1407
02:52:46,080 --> 02:52:54,960
yeah yeah there's man there's so many incredible tools through the years excel one of one of the

1408
02:52:54,960 --> 02:53:02,640
great shames of my life is that i've never learned how to use excel well i mean it just

1409
02:53:02,640 --> 02:53:09,360
always felt like so many features are there it's similar with ad is like pie charm it feels like

1410
02:53:09,360 --> 02:53:15,040
i converged quickly to the dumbest way to use a thing to get the job done when clearly there's

1411
02:53:15,040 --> 02:53:21,360
so much more power your fingertips yeah but there's i i do think there's probably expert users of

1412
02:53:21,360 --> 02:53:29,360
excel oh excel is a cash cow actually oh it actually brings the money oh yeah a lot of the

1413
02:53:29,360 --> 02:53:36,800
engineering sort of if you look deep inside excel there's some very good engineering very

1414
02:53:37,680 --> 02:53:42,800
very impressive stuff okay now i need to definitely learn excel a little better

1415
02:53:42,800 --> 02:53:48,400
i had issues because i'm a keyboard person so i had issues coming up with shortcuts and microsoft

1416
02:53:48,400 --> 02:53:54,480
sometimes it's changed over the years but sometimes they kind of want to make things easier for you

1417
02:53:54,480 --> 02:54:02,160
on the surface and therefore make it harder for like people that like to have shortcuts and all

1418
02:54:02,160 --> 02:54:07,360
that kind of stuff to optimize their workflow now excel is probably people are probably yelling at

1419
02:54:07,360 --> 02:54:13,120
me it's like no excel probably has a lot of ways to optimize the workflow but in fact i keep discovering

1420
02:54:13,120 --> 02:54:20,480
that there are many features in excel that only exists at keyboard shortcuts yeah that's the sense

1421
02:54:20,480 --> 02:54:25,920
i have and now like i'm embarrassed that it's just you just have to know what they are yeah that's

1422
02:54:25,920 --> 02:54:33,440
that's like there's no logic or or reason to the assignment of the keyboard shortcuts because they

1423
02:54:33,440 --> 02:54:40,560
they go back even longer than 35 years can you maybe comment about such an adela and how hard it

1424
02:54:40,560 --> 02:54:45,840
is for a ceo to sort of pivot a company towards open source towards developer culture is there

1425
02:54:45,840 --> 02:54:52,720
something you could see about like how what's the role of leadership in such a pivot and definition

1426
02:54:52,720 --> 02:55:03,440
of a new vision i've never met him but uh i hear he's just a really sharp thinker

1427
02:55:04,960 --> 02:55:12,640
but he also has an incredible business sense he took the organization that had very solid pieces

1428
02:55:12,640 --> 02:55:22,640
but that was also struggling with all sorts of shameful things especially the steve balmer time

1429
02:55:23,520 --> 02:55:30,480
i imagine in part through his personal charm and thinking and of course the the great trust that

1430
02:55:30,480 --> 02:55:36,480
that the the rest of the leadership has in him he managed to to really turn the company around and

1431
02:55:36,480 --> 02:55:46,320
sort of change it from from openly hostile to open source to to actively embracing open source

1432
02:55:46,880 --> 02:55:52,240
and that doesn't mean that suddenly excel is going to go open source but that means that

1433
02:55:52,240 --> 02:55:59,440
there's room for a product like vs code which is open source yeah it's fascinating it gives me faith

1434
02:55:59,440 --> 02:56:06,800
that large companies with good leadership can grow can expand can change and pivot and so on develop

1435
02:56:07,600 --> 02:56:13,360
because it gets harder and harder as the company gets large um you wrote a blog post in response

1436
02:56:13,360 --> 02:56:18,080
to a person looking for advice about whether with a cs degree to choose a nine to five job

1437
02:56:18,800 --> 02:56:25,280
or to become an entrepreneur it's an interesting question if you just think from first principles

1438
02:56:25,280 --> 02:56:30,960
right now somebody has took a few years in programming has loved software engineering

1439
02:56:30,960 --> 02:56:38,320
in some sense creating python is an entrepreneurial endeavor that's a choice that a lot of people

1440
02:56:38,960 --> 02:56:45,200
that are good programmers have to make do i work for a big company or do i create something new

1441
02:56:48,000 --> 02:56:51,840
or you can work for a big company and create something new there

1442
02:56:52,080 --> 02:57:00,080
oh inside the yeah i mean big companies have individuals who create new stuff

1443
02:57:00,880 --> 02:57:06,080
that eventually grows big all the time and if you're the person that creates a new thing

1444
02:57:06,080 --> 02:57:11,120
it grows big you you'll have a chance to move up quickly in the company to run that thing

1445
02:57:12,400 --> 02:57:20,000
if that's your aspiration what what what can also happen is that someone is brilliant engineer and

1446
02:57:20,000 --> 02:57:30,640
sort of builds a great first version of a product and has no aspirations to then become a manager

1447
02:57:30,640 --> 02:57:36,160
and grow the team from five people to 20 people to a hundred people to a thousand people and

1448
02:57:37,360 --> 02:57:45,600
be in charge of hiring and meetings and they move on to inventing another crazy thing inside

1449
02:57:45,600 --> 02:57:53,680
the same company or sometimes they they found a startup or they moved to a different great

1450
02:57:54,480 --> 02:58:01,520
large or small company there's all sorts of models and sometimes people sort of do have this

1451
02:58:02,160 --> 02:58:10,480
whole trajectory from engineer buckling down writing code not nine to five but more like

1452
02:58:11,440 --> 02:58:19,280
noon till midnight seven days a week and coming up with a product and sort of

1453
02:58:21,360 --> 02:58:28,480
staying in charge i mean if you take Drew Houston Dropbox's founder he is still the CEO

1454
02:58:30,080 --> 02:58:34,160
and at least when when i was there he had not checked out or anything he was

1455
02:58:35,120 --> 02:58:42,160
he was a good CEO but he had started out as the technical inventor or co-inventor

1456
02:58:43,120 --> 02:58:50,720
and so he was someone who i don't know if he always aspired that i think when when he was 16

1457
02:58:50,720 --> 02:58:58,080
he already started a company so maybe maybe he did but he sort of it turned out that that he

1458
02:58:58,160 --> 02:59:06,720
did have the the personal sort of skill set needed to to grow and and stay on top and other people

1459
02:59:07,440 --> 02:59:14,720
sort of are brilliant engineers and horrible at management i count myself at least in the

1460
02:59:14,720 --> 02:59:20,880
second category yeah so your your your first love and still your love is to be the quote-unquote

1461
02:59:20,880 --> 02:59:29,600
individual contributor so the programmer yep do you have advice for a programming beginner

1462
02:59:29,600 --> 02:59:43,840
on how to learn python the right way find something you actually want to do with it if you say i want

1463
02:59:43,920 --> 02:59:50,240
learn skill x that's not enough motivation you need to pick something

1464
02:59:51,760 --> 02:59:57,360
and it can be a it can be a crazy problem you want to solve it it can be completely unrealistic

1465
03:00:01,120 --> 03:00:09,920
but something that that challenges you into actually learning coding in in some language

1466
03:00:10,880 --> 03:00:14,640
and there's so many projects out there you can look for like that that doesn't have to be some

1467
03:00:14,640 --> 03:00:20,080
big ambitious thing it could be writing a small bot if you're into social media you can write a

1468
03:00:20,080 --> 03:00:27,440
red a bot or a twitter bot or or some aspect of automating some as something that you do every

1469
03:00:27,440 --> 03:00:34,080
single day processing files all that kind of stuff nowadays you can take machine learning components

1470
03:00:34,160 --> 03:00:41,120
and and sort of plug those things together so you cool stuff with them so that's actually a

1471
03:00:41,120 --> 03:00:44,720
really good example so if you're interested in machine learning the state of machine learning is

1472
03:00:44,720 --> 03:00:52,960
such that like a a tutorial that takes an hour can get you to start using uh pre-trained models

1473
03:00:52,960 --> 03:00:57,680
to do something super cool and that's a good way to learn python because you learn just enough to

1474
03:00:57,680 --> 03:01:03,680
run this model and that's like a sneaky way to get get in there to figure out how to import

1475
03:01:03,760 --> 03:01:11,680
stuff how to write basic io how to run functions and i'm not sure if it's the best way to learn

1476
03:01:11,680 --> 03:01:17,040
the basics in python but could be nice to just get fall in love first and then figure out the basics

1477
03:01:17,040 --> 03:01:24,400
right yeah you can't expect to learn python from a one hour video of course i'm blanking out on the

1478
03:01:24,400 --> 03:01:35,280
name of of someone who who wrote a very funny blog post where he said i see all these ads for things

1479
03:01:35,280 --> 03:01:44,560
like learn python in 10 days or so and he said the the goal should be learn python in 10 years

1480
03:01:45,200 --> 03:01:51,200
that's hilarious but i completely disagree with that i think the criticism behind that is that

1481
03:01:52,160 --> 03:01:57,120
the the place is just like the blog post from earlier the places that tell you learn python

1482
03:01:57,120 --> 03:02:02,080
in five minutes or 10 minutes they're actually usually really bad tutorials so the thing is i

1483
03:02:02,080 --> 03:02:12,000
do believe that you can learn a thing in an hour to like get some interesting quick like it hooks you

1484
03:02:12,000 --> 03:02:15,920
i mean this but it just takes a tremendous amount of skill to be that kind of educator

1485
03:02:15,920 --> 03:02:20,960
richard feinlin was able to condense a lot of ideas and physics in a very short amount of time

1486
03:02:20,960 --> 03:02:27,200
but that takes a deep deep understanding and so yes of course the actual i think the 10 the 10

1487
03:02:27,200 --> 03:02:33,200
years is about the experience the pain along the way and there's something you have to practice

1488
03:02:33,200 --> 03:02:40,480
you can memorize the syntax but well i couldn't but maybe maybe someone else can but that doesn't

1489
03:02:40,480 --> 03:02:48,640
make you a coder yeah actually coding has changed in fascinating ways because so much of coding is

1490
03:02:48,640 --> 03:02:53,760
copying pacing from stack overflow and then adjusting which is another way of coding and i

1491
03:02:53,760 --> 03:02:58,560
don't want to talk down to that kind of style of coding because it's kind of a nicely efficient

1492
03:02:58,560 --> 03:03:06,160
but you know where that is going a code generation get no seriously get a co-pilot yeah co-pilot

1493
03:03:06,160 --> 03:03:13,280
i use it every day and it really yeah it writes a lot of code for me and usually it's slightly

1494
03:03:13,360 --> 03:03:20,480
wrong but it still saves me typing because all i have to do is like change one word in a line

1495
03:03:20,480 --> 03:03:27,840
of text that otherwise it it generated perfectly and like how many times are you looking for like

1496
03:03:27,840 --> 03:03:32,800
oh what was i doing this morning i was looking for an begin marker and i was looking for an

1497
03:03:32,800 --> 03:03:44,400
end marker and so begin is blah blah blah search for begin this is the begin token and then the next

1498
03:03:44,400 --> 03:03:52,160
line i type e and it it completes the whole line with end instead of begin that's a very simple

1499
03:03:52,160 --> 03:03:58,400
example sometimes it it's sort of if i name my function right it writes a five or ten line function

1500
03:03:59,040 --> 03:04:07,840
and you know python enough to very quickly then detect the issues so it's it becomes a really

1501
03:04:07,840 --> 03:04:13,840
good dance partner then it doesn't save me a lot of thinking but since i'm a poor typist i'm very

1502
03:04:13,840 --> 03:04:22,000
much appreciative of all the all the typing it does for me much better actually than the the

1503
03:04:22,000 --> 03:04:29,200
previous generation of suggestions that are also still built in vs code uh where when you hit like

1504
03:04:29,200 --> 03:04:36,160
a dot it it tries to guess what the type is of the variable to the left of the dot and then it

1505
03:04:36,160 --> 03:04:43,280
gives you a list on the pop down menu of what the attributes of that object are but copilot is much

1506
03:04:43,280 --> 03:04:49,760
much smoother than that well it's fascinating to hear that you use github copilot uh do you think

1507
03:04:49,760 --> 03:04:57,680
do you worry about the future of that uh did the automatic cogeneration the increasing amount of

1508
03:04:58,400 --> 03:05:04,880
that kind of capability are programmers jobs threatened or is there still a significant

1509
03:05:04,880 --> 03:05:12,240
role for humans are programmers jobs threatened by the existence of stack overflow i don't think so

1510
03:05:12,240 --> 03:05:19,440
it helps you take care of the boring stuff and you shouldn't try to use it to do something that

1511
03:05:19,440 --> 03:05:26,880
you have no way of understanding what you're doing yet a tool like that is always best when

1512
03:05:27,840 --> 03:05:36,160
the question you're asking is please remind me of how i do this which i i could do i could look

1513
03:05:36,160 --> 03:05:45,040
up how to do it but right now i've forgotten whether the method is called foo or bar or how you

1514
03:05:45,040 --> 03:05:52,000
what the shape of the api is does it use a builder object or a constructor or a factory or

1515
03:05:54,400 --> 03:06:01,200
something else and what are the parameters it serves that role it's like a great assistant

1516
03:06:01,920 --> 03:06:08,480
but the creative work of sort of deciding what you want what you want the code to do is is totally

1517
03:06:08,480 --> 03:06:15,280
yours what do you think is the future of python in the next 10 20 50 years 100 years you look

1518
03:06:15,280 --> 03:06:21,600
forward you ever think about you ever imagine a future of human civilization or living inside the

1519
03:06:21,600 --> 03:06:31,520
metaverse on mars human or robots everywhere what part does python play in that it'll eventually

1520
03:06:31,520 --> 03:06:38,160
become a sort of a legacy language uh that plays an important role but that's that most people

1521
03:06:38,160 --> 03:06:47,120
have never heard of and uh don't need to know about just like all kinds of basic structures in in

1522
03:06:48,240 --> 03:06:56,560
biology like mitochondria so it permeates all of life all of digital life but people just build

1523
03:06:56,560 --> 03:07:02,320
on top of it and they only know the stuff that's on top of it yeah you guys you build layers of

1524
03:07:02,320 --> 03:07:10,480
obstructions i mean most programmers nowadays rarely need to do binary arithmetic right

1525
03:07:13,360 --> 03:07:19,200
yeah or even think about it or even learn about it or they could go quite far without knowing

1526
03:07:19,680 --> 03:07:27,040
i started building little digital circuits out of nend gates that i built myself with

1527
03:07:27,120 --> 03:07:35,360
transistors and resistors so i sort of i feel very blessed that with with that start when i was

1528
03:07:35,360 --> 03:07:45,520
a teenager i i learned some of the basic at least concepts that that go into building a computer

1529
03:07:46,400 --> 03:07:56,240
and i sort of every part i have some understanding what what it's for and why it's there and how it

1530
03:07:56,240 --> 03:08:04,160
works and i can't forget about all that most of the time but i sort of i enjoy knowing oh if you go

1531
03:08:04,160 --> 03:08:11,840
deeper you at at some point you get to uh nend gates and have adders and shift registers and

1532
03:08:13,120 --> 03:08:18,720
when it comes to the point of how do you how do you actually make a chip out of silicon i have no idea

1533
03:08:18,720 --> 03:08:25,360
that's just magic to me but you enjoy knowing that you can walk a while towards the lower and lower

1534
03:08:25,360 --> 03:08:33,120
layers but you don't need to it's nice the other day as a sort of a mental exercise i was trying to

1535
03:08:33,120 --> 03:08:47,120
figure out if i could build a flip flop circuit out of relays i was just sort of trying to remember

1536
03:08:47,120 --> 03:08:53,920
oh how does a real relay work yeah there's like this electromagnetic force that pulls a switch

1537
03:08:53,920 --> 03:09:02,080
open or shut uh and you can have have like it can open one switch in another shut another and

1538
03:09:04,240 --> 03:09:09,680
you can have multiple contacts that go at once and how many relays do i really need to

1539
03:09:09,680 --> 03:09:14,800
sort of represent one bit of information can the relay just feed on itself there was

1540
03:09:15,600 --> 03:09:23,120
i don't think i i i got to the final solution but it was fun that i i could still do a little

1541
03:09:23,120 --> 03:09:29,360
bit of problem solving and thinking at that level and it's cool how we build on top of each other

1542
03:09:29,360 --> 03:09:33,920
so there's people there just you you stood on the shoulders of giants and there's others

1543
03:09:33,920 --> 03:09:40,000
who'll stand on your shoulders and it's it's a giant beautiful higher yeah i feel i sort of

1544
03:09:40,000 --> 03:09:46,400
covered this middle layer of the technology stack where i sort of peters out below the

1545
03:09:47,360 --> 03:09:55,600
the level of of of nan gates and at the at the top i sort of i lose track when it gets to machine

1546
03:09:55,600 --> 03:10:00,960
learning and then eventually the machine learning will build higher and higher layers that will

1547
03:10:00,960 --> 03:10:09,280
help us understand the lowest layer of the physics and thereby the universe figures out how it itself

1548
03:10:09,360 --> 03:10:17,040
works maybe maybe not yeah i did i mean it's it's possible i mean if you think of human

1549
03:10:17,040 --> 03:10:24,560
consciousness if that's even the right concept it's it's interesting that that's sort of we

1550
03:10:24,560 --> 03:10:31,920
have this super parallel brain that does all these incredible parallel operations like image

1551
03:10:31,920 --> 03:10:40,000
recognition i recognize your face does huge amount of processing that goes on in parallel

1552
03:10:40,000 --> 03:10:45,600
there's lots of nerves between my eyes and my brain and the brain does a whole bunch of stuff

1553
03:10:45,600 --> 03:10:50,160
all at once because it's actually really slow circuits but there are many of them that all

1554
03:10:50,160 --> 03:10:56,960
work together on the other hand when i'm speaking everything is completely sequential

1555
03:10:57,920 --> 03:11:06,240
i i i have to sort of string words together one at a time and when i'm thinking about stuff

1556
03:11:06,240 --> 03:11:13,520
i'm when i'm when i'm understanding the world i'm also thinking of everything like one step at a time

1557
03:11:15,440 --> 03:11:19,520
and so we we've we've sort of we've got all this this incredible

1558
03:11:19,760 --> 03:11:27,840
parallel circuitry in our brains and eventually we use that to simulate a single threaded

1559
03:11:28,800 --> 03:11:37,360
much much higher level interpreter it's exactly i mean that's the illusion of it that's the illusion

1560
03:11:38,400 --> 03:11:45,120
of it for us that it's a single sequential set of thoughts and all of that came from a single cell

1561
03:11:45,120 --> 03:11:53,120
through the process of embryogenesis so dna is the code dna holds the entirety of the code

1562
03:11:53,120 --> 03:12:00,720
the information and how to use that information to build up an organism the entire like the arms the

1563
03:12:00,720 --> 03:12:08,880
how is it built yeah the brain so it's you don't buy a computer you buy like a you buy a seed a

1564
03:12:08,880 --> 03:12:14,720
yeah diagram and then you plant the computer and it builds itself in almost the same way

1565
03:12:15,520 --> 03:12:23,600
and then does the computation and then is uh eventually dies it gets stale but gives birth

1566
03:12:23,600 --> 03:12:29,280
to young computers more and more and gives them lessons but they figure stuff out on their own

1567
03:12:29,280 --> 03:12:35,280
and over time it goes on that way and those computers when they go to college tried to

1568
03:12:35,280 --> 03:12:39,760
figure out how to program and they built their own little computers and they're increasingly

1569
03:12:39,760 --> 03:12:45,520
more intelligent increasingly higher and higher levels of abstractions isn't it interesting that

1570
03:12:45,520 --> 03:12:52,560
that you sort of you see the same thing appearing at different levels though because you have like

1571
03:12:54,800 --> 03:13:02,960
cells that that create new cells and and eventually that builds a whole organism but then

1572
03:13:02,960 --> 03:13:13,840
the animal or the plant or the human has its own mechanism of replication that that is is sort of

1573
03:13:13,840 --> 03:13:19,920
connected in a very complicated way to the mechanism of replication of the cells and then

1574
03:13:19,920 --> 03:13:26,800
if you if you look inside the cell if you see how dna and proteins are are connected then

1575
03:13:26,800 --> 03:13:33,200
there is yet another completely different mechanism whereby proteins are mass produced

1576
03:13:34,640 --> 03:13:40,720
using enzymes and and and a little bit of code from from dna and of course viruses

1577
03:13:41,360 --> 03:13:48,400
break into it at that level and while the mechanisms might be different it seems like

1578
03:13:48,400 --> 03:13:55,920
the nature of the mechanism is the same and it carries across natural languages and programming

1579
03:13:55,920 --> 03:14:04,320
languages humans maybe even human civilizations or intelligent civilizations and then all the way

1580
03:14:04,320 --> 03:14:11,280
down to the single cell organisms it is it is fascinating to see what abstraction levels

1581
03:14:12,160 --> 03:14:18,240
are built on top of individual humans yeah and how you have like whole societies

1582
03:14:18,640 --> 03:14:29,040
that that sort of have a similar self-preservation i don't know what it is instinct nature abstraction

1583
03:14:30,080 --> 03:14:36,240
as the individuals have and the cells have and they self-replicate and breed in different ways

1584
03:14:36,960 --> 03:14:41,520
it's hard for us humans to introspect it because we were very focused on our particular layer of

1585
03:14:41,520 --> 03:14:47,520
abstraction but from an alien perspective looking on earth they'll they'll probably see

1586
03:14:48,480 --> 03:14:55,040
the higher level organism of human civilization as part of this bigger organism of life on earth

1587
03:14:55,040 --> 03:15:02,880
itself in fact that could be an organism just alone just life life life on earth this has been a

1588
03:15:02,880 --> 03:15:08,640
wild both philosophical and technical conversation you're you're an amazing human being you're

1589
03:15:09,280 --> 03:15:13,600
you were gracious enough to talk to me when i was first doing this podcast you're one of the

1590
03:15:13,600 --> 03:15:19,440
earliest first people i've talked to somebody i admired for a long time it's just a huge honor

1591
03:15:19,440 --> 03:15:24,560
that you did it at that time and you do it again you're awesome thank you lex thanks for listening

1592
03:15:24,560 --> 03:15:29,920
to this conversation with guido van rossum to support this podcast please check out our sponsors

1593
03:15:29,920 --> 03:15:36,480
in the description and now let me leave you some words from oscar wild experience is the name that

1594
03:15:36,480 --> 03:15:45,120
everyone gives to their mistakes thank you for listening and hope to see you next time

