1
00:00:00,000 --> 00:00:04,920
One of the areas of computing that I'm really curious about, and I think the software world

2
00:00:04,920 --> 00:00:11,000
has a lot to learn from, is game programming. Probably not on a surface level, I've never

3
00:00:11,000 --> 00:00:17,120
worked for an e-commerce company that needed collision detection. But get below that surface,

4
00:00:17,120 --> 00:00:21,360
and a lot of modern games, especially once they go multiplayer, they're dealing with

5
00:00:21,360 --> 00:00:28,720
things like global networking issues, multi-user concurrency, competitive concurrency, massive

6
00:00:28,720 --> 00:00:34,960
data volumes, under brutal latency requirements. They have a lot of the programming issues that

7
00:00:34,960 --> 00:00:40,240
we're familiar with, but under much harsher conditions. And being a somewhat separate world,

8
00:00:40,240 --> 00:00:45,680
they tend to approach the solution from a novel angle. So this week, we're going to go digging

9
00:00:45,680 --> 00:00:51,760
for system design ideas in the gaming world. And my guest for this is Tyler Cloutier. He's got a

10
00:00:51,760 --> 00:00:56,920
background in distributed systems and data science for the gaming industry. And he's

11
00:00:56,920 --> 00:01:03,160
currently building BitCraft, which is a massive multiplayer open world game, and to support it,

12
00:01:03,160 --> 00:01:09,200
a really interesting flavor of database called SpacetimeDB, from which we're going to mine

13
00:01:09,200 --> 00:01:17,200
some ideas about concurrency, transactions, data security, query management, lots more. A lot of

14
00:01:17,200 --> 00:01:23,200
juicy ideas solved from an angle that I'd never considered. So let's get going. I'm your host

15
00:01:23,240 --> 00:01:27,960
Chris Jenkins. This is Developer Voices. And today's voice is Tyler Cloutier.

16
00:01:41,440 --> 00:01:44,520
My guest this week is Tyler Cloutier. How you doing, Tyler?

17
00:01:44,520 --> 00:01:45,840
I'm doing well. How are you?

18
00:01:46,160 --> 00:01:54,160
I'm very well. You're going to take me to a new world for me, because I have a long history in

19
00:01:54,160 --> 00:02:01,280
programming, but one thing I've never done is computer game programming. And along with that,

20
00:02:01,280 --> 00:02:07,600
the one thing I've always wondered is they must have a lot of the same problems that the rest

21
00:02:07,600 --> 00:02:12,400
of us industrial programmers have, not like the dealing with graphics and story and stuff,

22
00:02:12,480 --> 00:02:14,880
but then there are data problems everywhere, right?

23
00:02:15,760 --> 00:02:21,440
That's right. Actually, I would say what I have experience is that they have the normal problems

24
00:02:22,000 --> 00:02:26,320
that everybody else has, but times 100, because not only do they have to build the thing,

25
00:02:26,880 --> 00:02:33,600
but it has to interact with all of the data in the program besides just sort of individual parts.

26
00:02:33,600 --> 00:02:35,360
And then it has to go really, really fast.

27
00:02:36,080 --> 00:02:39,360
Yeah. Yeah. All our problems except at 60 times a second.

28
00:02:39,920 --> 00:02:46,800
That's right. Yeah. So your background is originally in game design or data science

29
00:02:46,800 --> 00:02:51,440
for games or what's your origin story? My original background is actually in chemical and

30
00:02:51,440 --> 00:02:57,120
biomolecular engineering, which is completely unrelated to games. And then I did my master's

31
00:02:57,120 --> 00:03:04,240
in computer science focusing on distributed systems and machine learning. After that, I did

32
00:03:04,240 --> 00:03:08,480
some time at Bloomberg and then Apple and then a company called Machine Zone, which is a game

33
00:03:08,480 --> 00:03:14,640
development company. Right. And what did you do for them? So there I worked in their data science

34
00:03:14,640 --> 00:03:21,920
and engineering department as a data science engineer. And there we were building two things.

35
00:03:21,920 --> 00:03:27,200
One, pipelines for data. So making sure that we got the real live data as quickly as possible

36
00:03:27,200 --> 00:03:31,600
into a form that we could then feed into our models. So then the second part of what I did is

37
00:03:31,600 --> 00:03:36,800
also build those models, which predicted various things about how players are likely to behave.

38
00:03:36,800 --> 00:03:42,480
So like, how likely is this player to turn? How likely is this player to spend money? Will

39
00:03:42,480 --> 00:03:47,280
they give us a good review? That kind of thing. This is a pay to play game. This is a free to

40
00:03:47,280 --> 00:03:54,880
play game, actually, that is quite expensive. Ultimately. Because it's the business model

41
00:03:54,880 --> 00:03:59,920
where like most players don't pay anything, but some pay for like cosmetics upgrades,

42
00:03:59,920 --> 00:04:03,280
that kind of thing. And they spend a lot. No, no, it's much worse than that. So it's a mobile game.

43
00:04:04,240 --> 00:04:10,800
And it's the whole idea of the game is it's supposed to simulate what it feels like to be a king.

44
00:04:11,360 --> 00:04:17,120
And so what that ends up being is that you have this little city, it's called the forex game,

45
00:04:17,120 --> 00:04:22,080
which is for the four different types of play that you're going to do. And

46
00:04:24,560 --> 00:04:30,000
you build the city up, you upgrade your buildings. And then you can start sending marches out to

47
00:04:30,000 --> 00:04:35,440
attack other players. And ultimately, you want to capture a what's called a wonder,

48
00:04:35,440 --> 00:04:41,280
which will give you make you the king of the kingdom. And the process of capturing that wonder

49
00:04:41,280 --> 00:04:49,360
is quite an expensive endeavor. So the way it works is that they sell you speed ups. So upgrades

50
00:04:49,360 --> 00:04:55,040
take time, you can speed things up by paying for it. And some people pay quite a lot. There were

51
00:04:55,040 --> 00:05:00,560
individuals who spent upwards of several million dollars in that game.

52
00:05:01,920 --> 00:05:08,480
Several million. You heard that correct. If I did not see it myself, I would not have believed it.

53
00:05:09,360 --> 00:05:15,120
Gee, I can't, I struggle to compute why someone would do that and how they can be rich enough

54
00:05:15,120 --> 00:05:20,160
that that's their disposable income. There were Saudi princes, there were people of that kind.

55
00:05:20,160 --> 00:05:25,440
I mean, it was a global game. And so it attracted a lot of people who were interested in

56
00:05:26,240 --> 00:05:32,560
simulating what it felt like to be a king. There was one person who was rumored to have hired

57
00:05:33,120 --> 00:05:37,920
at least one person or a team of people to actually purchase and open the packs because

58
00:05:38,960 --> 00:05:45,120
it's actually mechanically a lot of work to open a $1 million worth of $100 packs,

59
00:05:45,120 --> 00:05:51,120
right? That's 10,000. That's 10,000 packs. So there's that. There was another person

60
00:05:51,120 --> 00:05:56,560
who used to fly his entire alliance out to Las Vegas to be closer to the servers

61
00:05:57,120 --> 00:06:00,560
so that they could do the Super Wonder event more effectively.

62
00:06:01,600 --> 00:06:07,920
That's, I mean, A, that's really weird, but B, is it that much weirder than traders putting

63
00:06:07,920 --> 00:06:12,080
their computers right by their main exchange? I don't know.

64
00:06:13,040 --> 00:06:18,480
I don't, I suppose not. I mean, these people really cared about the game. I asked players,

65
00:06:19,200 --> 00:06:27,040
why are you so interested in this game? And I remember one told me, I'm a security guard at

66
00:06:27,040 --> 00:06:31,120
a place or something to that effect. And I just sat there all day and I downloaded this just to

67
00:06:31,120 --> 00:06:37,760
pass the time. But over time, I found that I had like real actual friends in this game. And

68
00:06:39,040 --> 00:06:43,120
when I would log on, they'd say, oh my God, this person's here. And he felt like somebody,

69
00:06:43,120 --> 00:06:47,280
whereas in real life, he did not really feel like someone. And that, that was important to him.

70
00:06:47,280 --> 00:06:54,240
Okay, I can see that. But, okay, so curious game mechanics, but that's not why I want to talk to

71
00:06:54,240 --> 00:07:00,800
you. The thing that's, the reason I get into that is because you're there clearly in a

72
00:07:00,800 --> 00:07:09,200
background where there's serious amounts of data coming in live and serious money to be made in

73
00:07:09,200 --> 00:07:16,080
understanding the flow of that data. Certainly. Yep. Tell me about that and how it led into

74
00:07:16,080 --> 00:07:22,240
what you did next. Sure. So now this is an interesting story because it's sort of

75
00:07:22,880 --> 00:07:28,480
obliquely leads into what we actually ended up building. Because certainly my time at

76
00:07:28,480 --> 00:07:34,000
Machine Zone inspired it. But it's not the way I would explain exactly what we're doing. But

77
00:07:34,000 --> 00:07:40,000
let me tell you, I suppose the origin story. So while I was at Machine Zone, always we wanted

78
00:07:40,000 --> 00:07:44,880
historical data. So we wanted to know not only this is the current power of this individual,

79
00:07:44,880 --> 00:07:49,600
or this is the current set of items that they have. But what is the full history of what they

80
00:07:49,600 --> 00:07:55,840
have? So we can predict, for example, hey, look, this person was attacked, they got zeroed out,

81
00:07:55,840 --> 00:07:59,120
and now they left the game, and they're not likely to come back. We always wanted to know

82
00:07:59,120 --> 00:08:05,600
that data. And Machine Zone didn't have that data because the traditional infrastructure of companies

83
00:08:05,600 --> 00:08:16,240
is to have their game data or their really website data in normal relational databases, like in this

84
00:08:16,240 --> 00:08:21,760
case, I believe it was MySQL. Right. And the problem is, when you update someone's power in those

85
00:08:21,760 --> 00:08:27,920
databases, the old power goes away. So you need to have some kind of a way to actually get that

86
00:08:27,920 --> 00:08:32,960
historical data. And what they started to do was they were snapshotting their databases every 12

87
00:08:32,960 --> 00:08:39,760
hours. And we would then get that snapshot data, and we'd try to piece together a historical data.

88
00:08:39,760 --> 00:08:45,520
But that was very sad for two reasons. The first reason is that the data itself was awful, because

89
00:08:46,480 --> 00:08:50,160
a lot can happen in 12 hours, that could cause you to leave the game, right? So you don't really

90
00:08:50,160 --> 00:08:53,920
have that information. And I should also say there was another stream of data, which was just event

91
00:08:53,920 --> 00:08:58,720
data. But it was very loosey-goosey event data that was sort of whatever people had slapped together.

92
00:09:00,240 --> 00:09:05,200
Right. So you tried to build up a picture of what had happened historically from these two sources.

93
00:09:06,080 --> 00:09:11,760
And the other reason the snapshotting data was bad was that it was enormous, because if you think

94
00:09:11,760 --> 00:09:19,680
about it, 99% of the data in a database does not change in 12 hours. If 99% of your players have

95
00:09:19,680 --> 00:09:24,720
turned, you're just copying this old data every 12 hours. And so eventually, they had to pert to

96
00:09:24,720 --> 00:09:32,560
the old data, so they couldn't keep it forever. And they spent millions of dollars trying to

97
00:09:32,560 --> 00:09:37,600
clean up this data and get it into a form. We built a system which was based on the Lambda

98
00:09:37,600 --> 00:09:41,440
architecture. And if you're not familiar with how the Lambda architecture works, you essentially

99
00:09:41,440 --> 00:09:46,640
set up a streaming part of your data pipeline, and you set up a sort of a batch part of your data

100
00:09:46,640 --> 00:09:54,560
pipeline, and you try to weave those two together. So you might put all of your big, well-formed data

101
00:09:54,560 --> 00:10:04,320
in Hive, which is a write, append-only database made by Facebook for large data, and then you would

102
00:10:04,320 --> 00:10:09,920
have something like Flink or Apache Spark taking your real-time data and trying to make decision

103
00:10:09,920 --> 00:10:15,280
space in that and bringing it in with your batch process data as well. There's a huge amount of

104
00:10:15,280 --> 00:10:23,600
work. And I would say 95% of the data science was actually just getting the data into the

105
00:10:23,600 --> 00:10:29,600
right form in the right place at the right time. That's a very familiar statement that spans way

106
00:10:29,600 --> 00:10:38,880
past gaming, right? Absolutely. So when we began to build our own game, I decided I'm not going to

107
00:10:38,880 --> 00:10:45,520
have it. We're going to have the full history of the data. So I want to be able to go back to

108
00:10:45,520 --> 00:10:50,560
any point in time and actually see what the game state was. But more than that, I want to actually

109
00:10:50,560 --> 00:10:54,880
be able to replay it at that time so that you could hop into the game at that time and actually

110
00:10:54,880 --> 00:11:03,120
see it being replayed. On that level of granularity. Right. So you're not just storing events, but

111
00:11:03,520 --> 00:11:12,880
player thumbstick movements and stuff. Correct. And actually, I saw on an earlier podcast that

112
00:11:12,880 --> 00:11:18,160
you had, I think it was maybe two weeks ago, you were talking about event streaming. And the guest

113
00:11:18,160 --> 00:11:23,920
there said at the end, this doesn't always work for everything. It doesn't work, for example,

114
00:11:23,920 --> 00:11:29,600
for games. And I thought, aha, how wrong you are. In fact, this is exactly what we're doing.

115
00:11:30,400 --> 00:11:33,760
So event sourcing is essentially what Space SoundDB does.

116
00:11:34,480 --> 00:11:41,200
Okay. That's colossal amounts of data, very widely distributed user base,

117
00:11:42,000 --> 00:11:48,560
high response times required, because you've got to deal with things 60 frames a second ideally.

118
00:11:51,040 --> 00:11:56,640
That's a big challenge. How do you start to break that down into something? What's your approach?

119
00:11:57,360 --> 00:12:02,640
I think the best place to start is to first understand what the game is that we're trying to

120
00:12:02,640 --> 00:12:08,720
build. And then from that, you can see why Space SoundDB is a necessary requirement. So we have

121
00:12:08,720 --> 00:12:14,720
two products. We have a game called BigCraft Online, which is a massively multiplayer online

122
00:12:14,720 --> 00:12:21,280
role playing game. You can sort of think of it as like a combination between RuneScape,

123
00:12:21,280 --> 00:12:26,640
if you're familiar with that, and Minecraft. So there's this very long term

124
00:12:27,440 --> 00:12:31,760
skilling and progression in the game. But at the same time, you can actually change and edit the

125
00:12:31,760 --> 00:12:38,960
world and build your own things within the world. That's the game that we set out to build. And in

126
00:12:38,960 --> 00:12:44,320
order to do that, notably, the first thing you think is, well, we need to put everybody in a

127
00:12:44,320 --> 00:12:52,240
single world logically, because you can't have people occupying the same space in the way that

128
00:12:52,240 --> 00:12:57,760
you could in a normal MMORPG, because they actually are editing the world. So if I was a normal MMORPG,

129
00:12:57,760 --> 00:13:04,320
I'd put many, many instances all in the same city, right? It doesn't matter. In our game,

130
00:13:04,320 --> 00:13:08,000
it certainly does, because you actually need to do that. So now you have a very interesting

131
00:13:08,000 --> 00:13:12,880
distributed systems challenge on your hands. Yeah, you've got a large global mutatable state.

132
00:13:13,440 --> 00:13:17,520
Correct. And it has to be persistent. So if your servers crash, people want to have their

133
00:13:17,520 --> 00:13:24,080
buildings that they spent their time building and stuff like that. Yeah. So that's the first thing

134
00:13:24,080 --> 00:13:30,560
you have to understand about how we came at this problem. And so in order to do that, we realized,

135
00:13:31,120 --> 00:13:36,640
okay, well, we need a system which is built around the persistence, right? Because

136
00:13:37,040 --> 00:13:43,120
if we're going to be making these permanent changes to the world, and it is everywhere, either we're

137
00:13:43,120 --> 00:13:49,120
going to be doing the normal architecture of games, which I'll take a brief aside to explain. So the

138
00:13:49,120 --> 00:13:54,720
normal architecture is you'd have a game server, you'd have your databases, the game server itself,

139
00:13:54,720 --> 00:14:01,360
unlike a web server, would have quite a bit of state, right? And you at periodic times,

140
00:14:01,600 --> 00:14:06,800
at periodic times, or when people did important events, would write to the database with a

141
00:14:06,800 --> 00:14:13,600
transaction. And then you get that back. But you as the developer are doing a lot of work to

142
00:14:16,000 --> 00:14:22,000
maintain, I suppose, synchronicity between your database and your game server state.

143
00:14:22,640 --> 00:14:29,200
Because for example, if I kill an enemy, there's a lot of things you can do that make things

144
00:14:29,920 --> 00:14:36,560
pretty crazy. But if I kill an enemy, that enemy is probably not, their position is probably not

145
00:14:36,560 --> 00:14:42,480
stored in the database, but they that there was an enemy might be, or that you picked up items

146
00:14:42,480 --> 00:14:47,360
probably is because if Susie enters your inventory, you don't want to lose that. Or you could do it

147
00:14:47,360 --> 00:14:52,640
periodically, and then they could do replays and stuff. What you end up getting to is a place where

148
00:14:52,640 --> 00:14:58,560
you're spending a lot of your time as the game developer, not thinking about the actual gameplay

149
00:14:58,560 --> 00:15:03,600
programming, and rather thinking about the distributed system environment in which you're

150
00:15:03,600 --> 00:15:11,200
actually building this game. Yeah, I can believe that. So what we decided to do is say, we are going

151
00:15:11,200 --> 00:15:16,560
to make that all, I suppose, opaque to the game developer, and we're going to put them in a context

152
00:15:17,120 --> 00:15:22,960
where they're operating inside a transaction already. That transaction is going to be manipulating

153
00:15:23,040 --> 00:15:30,000
in memory data. And then we are going to do all of the necessary things to persist that data to

154
00:15:30,000 --> 00:15:36,400
disk so that the gameplay programmer does not have to think about that at all. What's that look

155
00:15:36,400 --> 00:15:42,800
like for the programmer? They just, they're treating their local client side instances,

156
00:15:42,800 --> 00:15:51,520
though it's a relational database. Is this what you say? That is one consequence. But the main

157
00:15:51,520 --> 00:15:58,880
point of what I'm saying is that on the server, all things inside of BitCraft happen

158
00:15:59,840 --> 00:16:05,840
within a database. So let me explain just a little bit about how SpacetimeDB works and what it is

159
00:16:05,840 --> 00:16:10,880
actually. So we built this game and we wanted to do this in this way. So we built a system called

160
00:16:10,880 --> 00:16:18,080
SpacetimeDB, which is fundamentally a database. So it's very focused on persistence. The way it

161
00:16:18,080 --> 00:16:25,040
works is you take BitCraft, you compile it to a WebAssembly module, you upload that into the

162
00:16:25,040 --> 00:16:30,160
database, and then clients connect directly to the database. And now I hear a lot of people

163
00:16:30,160 --> 00:16:35,920
in the audience screaming, oh, you can't do that. You couldn't do that. And it maybe was a bad idea

164
00:16:35,920 --> 00:16:43,920
for databases like Postgres and so forth. But we have built a permissions model around SpacetimeDB

165
00:16:43,920 --> 00:16:53,920
that allows you to do that safely. And so the way that works is you, as a client, call what we

166
00:16:53,920 --> 00:16:59,440
call reducers on the database. They're very similar to store procedures. And then those store procedures

167
00:16:59,440 --> 00:17:03,760
which are written in whatever language you want that compiles the WebAssembly will access things

168
00:17:03,760 --> 00:17:08,400
from the database and write them back to the database. So just as an example, let's say we had

169
00:17:08,480 --> 00:17:12,960
player move. And notably, everything in BitCraft, including all the player movement,

170
00:17:12,960 --> 00:17:17,440
all the chat, all the trees, all the ground, everything is stored within the database.

171
00:17:18,160 --> 00:17:22,640
So if we want to move a player, what we do is we call a reducer called move player

172
00:17:22,640 --> 00:17:27,440
on the server that updates some rows in the database and then commits those rows. And that's it.

173
00:17:28,400 --> 00:17:35,440
Then clients, other clients will subscribe to the database state. So they'll say, I want to select

174
00:17:35,440 --> 00:17:42,000
star from player position, where they are near me, basically, would be what that word clause would

175
00:17:42,000 --> 00:17:47,040
say. And then all connected clients that have subscribed to that, when that player moves,

176
00:17:47,040 --> 00:17:52,480
we'll hear about those rows and their updates, and then automatically update it in the database.

177
00:17:52,480 --> 00:17:59,680
I'm sorry, on their local client. So hang on, where is the database? The database is on a server

178
00:18:00,320 --> 00:18:06,240
stored. In this case, I believe in New York. Okay, so how on earth does that possibly work

179
00:18:06,240 --> 00:18:12,160
when I'm moving and expecting things to update 60 times a second? So, okay, this is the first thing

180
00:18:12,160 --> 00:18:18,080
that's interesting about games. You would not have a tick rate on the server that's 60 times per

181
00:18:18,080 --> 00:18:23,840
second, unless you were making a game like Counter Strike. So typically, I'll give you sort of a

182
00:18:23,840 --> 00:18:30,560
range. Minecraft updates 20 times per second. So every 50 milliseconds. RuneScape updates,

183
00:18:30,560 --> 00:18:37,120
I believe, four times a second. So every quarter of a second. So there's a variety of different

184
00:18:37,120 --> 00:18:42,960
levels that you can do. Generally speaking, the larger your game is, obviously, the fewer updates

185
00:18:42,960 --> 00:18:47,440
per second you want to be doing, because there's so many entities to move within a timeframe.

186
00:18:48,000 --> 00:18:54,400
Yeah, but I mean, I'm in London. I'm not sure I can guarantee four frames a second in New York

187
00:18:54,400 --> 00:19:02,160
and back. I see. So I understand your question now. With any game like this, you do not wait for

188
00:19:02,160 --> 00:19:08,960
the round trip. So how long would the round trip be from New York to London? I actually happen to

189
00:19:08,960 --> 00:19:14,240
know it's about 80 milliseconds or 70 milliseconds, something like that. So it's actually not crazy.

190
00:19:14,560 --> 00:19:18,640
You can play it without what's called client side prediction. But the typical way

191
00:19:18,640 --> 00:19:22,480
that you would actually do this is you'd run client side prediction. What does that mean?

192
00:19:22,480 --> 00:19:30,640
That means that I as a client have some subset of the server state. And when a player, my player,

193
00:19:30,640 --> 00:19:36,480
decides to do something, I can predict what the server is going to do to my local state,

194
00:19:37,120 --> 00:19:40,160
assuming that it will work. So based on the state of the world as I know it,

195
00:19:40,880 --> 00:19:46,800
if I try to move, I should be able to update my local state, assuming the server will agree with

196
00:19:46,800 --> 00:19:51,840
me. And so I will do that. And then I will immediately see the results of that on my own

197
00:19:51,840 --> 00:19:57,280
local client. But I will send something to the server. Now, if the server agrees, we basically

198
00:19:57,280 --> 00:20:03,040
come back, we reconcile, no problem. If the server disagrees, let's say somebody exploded a bomb

199
00:20:03,040 --> 00:20:09,840
that your client hadn't heard about yet, right on top of you. And the thing you try to do is

200
00:20:09,920 --> 00:20:16,000
invalidated by that. Maybe you're dead now. What will happen is you will have sent a request to

201
00:20:16,000 --> 00:20:20,800
the server that says, I want to move. The server interjects and says, actually, you died.

202
00:20:23,040 --> 00:20:28,320
What will happen is your client will say, oh, I understand, it will roll back to the point at

203
00:20:28,320 --> 00:20:33,920
which you were going to move. And it will then play forward the updates as they actually happen

204
00:20:33,920 --> 00:20:39,360
from the server and then try to replay your move. So it would go originally before you heard about

205
00:20:39,360 --> 00:20:44,560
from the server, it would go, you're standing here, you move, you actually move. Then what happens

206
00:20:44,560 --> 00:20:49,520
is you hear about the bomb, you roll back to the point at which you were about to move,

207
00:20:50,320 --> 00:20:55,200
you then blow up because of the bomb. And then you find out, then at that point, you try to move,

208
00:20:55,200 --> 00:20:59,520
but you can't move because you're dead. Right. And that's how that reconciles.

209
00:20:59,520 --> 00:21:02,800
This sounds very like transaction on the client side.

210
00:21:03,440 --> 00:21:04,400
Yes, it does.

211
00:21:04,400 --> 00:21:06,320
So is there a database on the client side?

212
00:21:07,200 --> 00:21:12,960
Well, I believe basically everything is a database. I have more I could talk about that,

213
00:21:12,960 --> 00:21:17,360
but essentially, yes, although typically people don't think of it that way. So typically the way

214
00:21:17,360 --> 00:21:24,560
that people think about it, first of all, in games is with a tick. So on the client, you would have

215
00:21:25,280 --> 00:21:30,400
a frame, essentially, that happens, they would call it like a server frame if it's not the

216
00:21:30,400 --> 00:21:35,520
actual render frame. So the render frame always happens at 60 frames per second, or sometimes

217
00:21:35,520 --> 00:21:42,800
now like 120 or 144 or whatever your monitor actually has. A server frame typically doesn't

218
00:21:42,800 --> 00:21:50,000
go beyond 60 frames per second. And it assumes there's a loop. And basically, we're going to

219
00:21:50,000 --> 00:21:54,720
update all the state once a frame. Space IDB actually doesn't make that assumption. You can

220
00:21:54,720 --> 00:22:00,240
do that with Space IDB, but it's not a requirement. So I'll just say that. And there's latency

221
00:22:00,240 --> 00:22:04,400
versus throughput trade-offs with that. That's essentially what that will end up with.

222
00:22:05,200 --> 00:22:09,920
Because if you have something ticking 60 frames a second, the minimum latency that you can have

223
00:22:09,920 --> 00:22:16,960
is one 60th of one second. Because you could have the wrong time. You could have tried to do

224
00:22:16,960 --> 00:22:19,920
something just as the frame was starting. And now you have to wait the full frame time

225
00:22:20,640 --> 00:22:29,680
before you actually that effect is applied. So now, yes, is the client a database?

226
00:22:30,400 --> 00:22:36,400
What is happening on the client is there's really two ways of doing it. And so I want to be careful.

227
00:22:38,640 --> 00:22:44,880
In the one way of doing it, the client has a deterministic simulation of the game world.

228
00:22:45,440 --> 00:22:52,560
So that means that all of the inputs that are going to manipulate the game state are being sent

229
00:22:52,560 --> 00:22:57,040
to the server and replicated out to the clients. Those clients then receive that input. And then

230
00:22:57,040 --> 00:23:04,960
they run the game forward a little bit, like one frame. And they will find out what actually

231
00:23:04,960 --> 00:23:09,680
has changed in the game state and they move their state forward. That requires having total

232
00:23:09,680 --> 00:23:15,360
knowledge of all of the state. Because if you don't have total knowledge, you're

233
00:23:15,360 --> 00:23:19,760
non-deterministic because you no longer know what you don't know. You don't know that that bomb

234
00:23:20,320 --> 00:23:23,520
might come in from outside and actually...

235
00:23:24,480 --> 00:23:28,000
Yeah, if you want total knowledge, you have to have the entire world so you can see events

236
00:23:28,000 --> 00:23:29,440
that might be coming over the horizon.

237
00:23:30,880 --> 00:23:38,080
Yes, this type of server synchronization really only happens with match-based games.

238
00:23:38,880 --> 00:23:42,800
So games with a sort of small state, so like League of Legends, that kind of thing.

239
00:23:44,320 --> 00:23:50,080
Or like RTSs, which is another match-based game, where the inputs are quite simple,

240
00:23:50,160 --> 00:23:54,800
but the outputs are quite complex. So you might click here to move a group of guys,

241
00:23:54,800 --> 00:23:59,840
but 500 guys might move. And so that's actually a lot of data to say where all the positions of

242
00:23:59,840 --> 00:24:03,680
them are, but you don't have to do that. You just have to replicate. I clicked here, or this player

243
00:24:03,680 --> 00:24:08,800
clicked here, and thus when I play my deterministic simulation forward, all the guys will move within

244
00:24:08,800 --> 00:24:11,280
my simulation. I don't have to communicate that data over the network.

245
00:24:11,840 --> 00:24:17,280
Okay, yeah, I can see that. So that's one way to do it. For MMOs, part of the reason they're so

246
00:24:17,280 --> 00:24:21,280
difficult is you can't do that, because I cannot possibly have the total state of the world

247
00:24:22,640 --> 00:24:28,720
on my client. It's too big, sort of fundamentally, by design. I can't put the whole world of

248
00:24:28,720 --> 00:24:35,120
Warcraft and all its players on every single machine. Correct, alas, you cannot. So instead,

249
00:24:35,120 --> 00:24:42,000
what they do is typically the way this would work is you have your game server. That game server

250
00:24:42,000 --> 00:24:46,560
knows what a game client is, and when they connect, they know where the player is, and they have a

251
00:24:46,560 --> 00:24:50,080
bunch of special logic to say, okay, I know what this player is, I know what they need, I'm going

252
00:24:50,080 --> 00:24:55,600
to send down that data to the client. And then I'm going to send down that data to the client

253
00:24:58,240 --> 00:25:02,960
let's say once a frame. So every frame, I will compute, okay, what has changed on the server,

254
00:25:02,960 --> 00:25:06,880
and I'm going to send a bunch of messages down saying these are the new positions of all the

255
00:25:06,880 --> 00:25:15,760
players. That's the typical way of doing it. Now, notably, this means that you have baked in

256
00:25:17,520 --> 00:25:23,760
what your client wants to know about into your server code. Because you as the server need to

257
00:25:23,760 --> 00:25:28,320
know what they need to know, because you're going to do this streaming update to them. Yeah,

258
00:25:28,320 --> 00:25:34,240
so it's more complex than first, for example, let's say a web site with a GraphQL query,

259
00:25:34,240 --> 00:25:38,400
because with a GraphQL query, you can say, Oh, I'm this client of client, and I want to know

260
00:25:38,400 --> 00:25:42,240
all about this data. And I'm this kind of client, I want to know about this data. But because games

261
00:25:42,240 --> 00:25:46,560
are streaming, and they need to go fast, and they have this tick based thing built into it.

262
00:25:46,560 --> 00:25:52,320
Historically, people have built them so that you write all the code for synchronizing the

263
00:25:52,320 --> 00:25:56,240
clients, and you build in some concepts, like you probably build in the concept of positions

264
00:25:56,240 --> 00:25:59,520
and of players, and that players want to know about things that are around them,

265
00:25:59,520 --> 00:26:04,720
and all of that good stuff. So if you were to then go build an AI that doesn't care about

266
00:26:04,720 --> 00:26:07,680
where certain players are, maybe it's trying to regrow the trees or something.

267
00:26:08,480 --> 00:26:14,560
And it wants to listen to the data. No can do. You've already built in the particular query

268
00:26:14,560 --> 00:26:22,720
that wants to be done on that game server state. Right. So we're inverting the controls. So the

269
00:26:22,720 --> 00:26:28,160
server knows what kind of things you would want and pushes those to you.

270
00:26:28,160 --> 00:26:34,480
Correct. So that really bakes in the server then has to have very fixed ideas about what

271
00:26:34,560 --> 00:26:38,240
kind of people connect and what they might want to do. Absolutely. Correct.

272
00:26:39,440 --> 00:26:43,360
What space time to be does is the opposite. We actually treat it sort of from a formal database

273
00:26:43,360 --> 00:26:47,840
perspective and say, actually, clients are just going to write queries, which are going to be

274
00:26:47,840 --> 00:26:56,880
executed with a query engine in a subscription based streaming way. So first, we connect,

275
00:26:57,600 --> 00:27:00,480
and we send a query, and we say, I want to listen to all of these players in this

276
00:27:01,120 --> 00:27:05,920
region or whatever we are interested in. And then that data will be incrementally streamed

277
00:27:05,920 --> 00:27:10,480
down. So as the data changes in the database, we compute that query for all the subscribe things

278
00:27:10,480 --> 00:27:16,400
and we send it down to their clients. Then you can think of their clients as having a replica

279
00:27:17,200 --> 00:27:22,720
of the server database. Now that replica is a subset of the data, and it is only prefix

280
00:27:22,720 --> 00:27:27,440
consistent. So it's not strongly consistent. Would you mean by prefix consistent?

281
00:27:28,080 --> 00:27:37,600
You have the database state as it existed at some point in time in the past. So you have all of the

282
00:27:37,600 --> 00:27:45,200
updates in a prefix of the message log, of the write ahead log, up to a certain point. That's

283
00:27:45,200 --> 00:27:49,600
what I mean. Now it's a subset. So it's not, I have the whole database, I have some set of the

284
00:27:49,600 --> 00:27:55,760
data as it was in time. So it's not eventually consistent. I don't see any weird things about

285
00:27:55,840 --> 00:28:00,800
it. I will see the database state as it was maybe like five milliseconds ago, or if I'm far away

286
00:28:00,800 --> 00:28:07,040
a hundred milliseconds ago. Right, yeah. And so what that allows us to do is then you can query

287
00:28:07,040 --> 00:28:13,200
your local database as though it were the actual database. And so you can get this information

288
00:28:13,200 --> 00:28:20,720
out from your local database much more conveniently and faster than you might otherwise do in a

289
00:28:20,720 --> 00:28:26,080
normal game server. You'll forgive me being really boring here, but I'm translating this

290
00:28:26,080 --> 00:28:35,040
into a non gaming world. And I can see I can imagine I as a as a client of the second client

291
00:28:35,040 --> 00:28:42,480
of a bank or trading platform, I might want to have all the data relating to my accounts and

292
00:28:42,480 --> 00:28:49,120
maybe some of my counterparties, but not the entire bank's data. And then I want to be able to

293
00:28:49,360 --> 00:28:54,480
optimistically make transactions on that data. They get sent back to the central server and I get

294
00:28:54,480 --> 00:28:59,840
told if that works, but I can progress as though it did. Yes. And that would be exactly the same

295
00:28:59,840 --> 00:29:06,080
architecture we're talking about in the gaming world. 100%. Yes. So what we are in sense, sense

296
00:29:06,080 --> 00:29:13,200
trying to do is unify across both of those things. A lot of people in why, why is that important?

297
00:29:14,160 --> 00:29:23,920
Because many people have tried to make a game service, game server back end kind of thing,

298
00:29:23,920 --> 00:29:30,880
like a game engine, but for the server, right? So there's unity, you've got Unreal. Wouldn't it

299
00:29:30,880 --> 00:29:34,800
be nice if somebody made that for the back end? The problem that people have is that

300
00:29:35,760 --> 00:29:41,360
when you think about what a game is on the client, it's the same across all games. If I'm playing

301
00:29:42,000 --> 00:29:47,600
chess or solitaire, what I want to do on the client is very similar to what I want to do in

302
00:29:47,600 --> 00:29:53,840
World of Warcraft. Let's say I'm making a 3D solitaire. I am rendering objects on a screen

303
00:29:53,840 --> 00:29:59,440
and I have all of that stuff. It's all kind of the same across both games. I want to render a 3D

304
00:29:59,440 --> 00:30:05,680
world. I want to loop that, apply some logic to the state of that world. And then I want to,

305
00:30:05,680 --> 00:30:10,400
yes, and I want to turn it into 3D objects and I want to project them onto a screen and I want

306
00:30:10,400 --> 00:30:14,880
to do lighting effects and I want to do sound effects and I want to do all of that. Every game

307
00:30:14,880 --> 00:30:19,840
from the client perspective is not identical, but they rhyme. They have a lie in common that

308
00:30:19,840 --> 00:30:25,120
an engine could do that we don't have to write over and over and over again, essentially. On the

309
00:30:25,120 --> 00:30:30,480
server, if you think about what chess versus World of Warcraft is, those architectures are,

310
00:30:31,280 --> 00:30:36,480
they share nothing. They might as well, one is like a web app kind of, right? Like a chess move.

311
00:30:37,360 --> 00:30:42,400
I could build that with a web server and Node.js and all that. And the other one is a very complex

312
00:30:44,800 --> 00:30:51,920
multi-user, fast-changing state thing, which synchronizes data persistently to the database

313
00:30:51,920 --> 00:30:56,560
and updates positions and all of that. So what we're trying to do in some sense with SpacetimeDB

314
00:30:56,560 --> 00:31:01,280
is close over all of those things and you really have to go all the way back to the database

315
00:31:01,280 --> 00:31:05,520
for it to be general enough to actually apply to both of those scenarios.

316
00:31:06,800 --> 00:31:12,480
Yeah. Okay. I can see that. It sounds like a colossal amount of work to do well, though.

317
00:31:13,200 --> 00:31:21,520
It does. Nobody knows this better than I do. Let me put it to you this way, though, with respect to

318
00:31:21,520 --> 00:31:28,320
that. When we decided we were going to make BitCraft, we were committed to making such a system.

319
00:31:28,400 --> 00:31:33,840
The fact that it's available as its own standalone thing is not really that much more work.

320
00:31:34,400 --> 00:31:42,400
Every MMO that you have ever seen has an architecture which is at least as complicated

321
00:31:42,960 --> 00:31:50,960
as SpacetimeDB. And I actually know that some of them, I can't necessarily name them,

322
00:31:52,560 --> 00:31:57,680
operate in the same sort of stored procedure way because it's the sort of convergent evolution

323
00:31:57,680 --> 00:32:03,680
that they arrived at, but they just didn't formally call it a database. In some sense,

324
00:32:03,680 --> 00:32:11,040
an easier problem because if you treat it as a database formally, you get to use all of the

325
00:32:11,040 --> 00:32:18,800
research and learnings that 50 years of database research has brought about. You do not have to

326
00:32:18,800 --> 00:32:27,040
reinvent the wheel, is what I'm saying on a lot of these things. And so we were always

327
00:32:27,040 --> 00:32:33,840
destined to create a system that's like this. As soon as we decided we wanted to actually create

328
00:32:33,840 --> 00:32:40,800
this kind of thing. Ours is arguably just not sort of shoestring and duct tape, not to

329
00:32:40,800 --> 00:32:46,320
disparage anyone else. It's very hard to build an MMORPG, but that's kind of how I would think

330
00:32:46,320 --> 00:32:51,360
about it. Let's say rather than that, it's not an afterthought. Not an afterthought,

331
00:32:51,360 --> 00:32:59,680
yes, correct. Okay, so what we've got here is a system where I as the game programmer,

332
00:33:01,280 --> 00:33:07,280
updating a row in a date, someone moves the joystick up, I update the Y position

333
00:33:07,920 --> 00:33:15,520
of their player's row in a database. Correct. Magic Clitty, that's going to be synchronized

334
00:33:15,520 --> 00:33:20,800
to the server without me worrying about it. And roll back if it turned out it didn't work.

335
00:33:20,800 --> 00:33:24,880
And then I just have a rendering function that's also looking at my local database

336
00:33:26,080 --> 00:33:29,600
and drawing it to the screen. That is correct, yes, that's essentially correct.

337
00:33:31,520 --> 00:33:38,640
Okay, let's start with the first objection. That's going to be too slow, even

338
00:33:39,920 --> 00:33:43,440
even if you don't have to do the server round trip every time.

339
00:33:44,560 --> 00:33:50,320
So let me ask a follow up question to your question. What specifically would be too slow?

340
00:33:50,880 --> 00:33:56,800
Because what I want to ascertain is exactly what you're talking about. There is a perception

341
00:33:56,800 --> 00:34:02,400
that databases are slow, and perhaps that's what you're driving at.

342
00:34:02,400 --> 00:34:11,280
I think because, okay, it's got to be transactional. It's probably iterate. Once you get into things

343
00:34:11,280 --> 00:34:16,960
like, oh, my bullet's flying across the screen and hitting people, it's updating a considerable

344
00:34:16,960 --> 00:34:22,960
amount of data. And collision detection, it's got to happen a lot of times a second. I won't

345
00:34:22,960 --> 00:34:30,320
give you the number, you can give it to me. But that feels like that's going to grind on a

346
00:34:30,320 --> 00:34:35,840
transactional database. Okay, so this is a great question. And I understand where you're coming

347
00:34:35,840 --> 00:34:44,480
from. And we had to be a little bit crazy to think that this was a thing that should be done

348
00:34:44,480 --> 00:34:51,200
originally. But for several reasons, which I'm about to outline, I think you will come to agree

349
00:34:51,200 --> 00:34:55,040
that actually that's completely possible and plausible to do within a database context.

350
00:34:55,840 --> 00:35:00,400
So the first thing I will draw your attention to is that we're not, by no means the first,

351
00:35:00,400 --> 00:35:07,360
to do things like this in history. There is a database called times 10,

352
00:35:07,360 --> 00:35:10,880
which was developed in the 90s. Oh, that was bought out by Oracle, wasn't it?

353
00:35:10,960 --> 00:35:15,760
It was bought out by Oracle, correct. And it actually has a very similar architecture to

354
00:35:15,760 --> 00:35:22,880
SpacetimeDB. So a couple of things. One, it's fully in memory. So the whole purpose of that

355
00:35:22,880 --> 00:35:27,520
database was that for certain very high throughput, low latency applications,

356
00:35:28,720 --> 00:35:34,480
current databases weren't hacking it, not even that currently server architectures weren't

357
00:35:34,560 --> 00:35:42,160
hacking it. So what they decided to do is to have a database, have in memory state in that

358
00:35:42,160 --> 00:35:49,120
database, put the logic of your program, physically within the same process as that database, and

359
00:35:49,120 --> 00:35:56,320
then have you access the data within the same process. So you're literally reaching into your

360
00:35:56,320 --> 00:36:01,120
current program memory, you're treating your program memory as though it were a database.

361
00:36:02,080 --> 00:36:07,520
And then what they do is all the updates to that data, they append in an append-only fashion

362
00:36:08,080 --> 00:36:17,200
to a write-ahead log. And this was developed for telecom processing, like routing calls,

363
00:36:18,480 --> 00:36:23,760
these kinds of very, very low latency high throughput things. That's the almost identical

364
00:36:23,760 --> 00:36:29,040
architecture actually to how SpacetimeDB operates. We have just modernized it for

365
00:36:31,200 --> 00:36:36,240
use with WebAssembly and whatever language you would like, and some nice things on top of that,

366
00:36:36,240 --> 00:36:41,760
including subscribing to the database, which I don't believe TimeSend actually provides that

367
00:36:41,760 --> 00:36:49,760
information. Okay, but that write-ahead log that we've got into persistence, which you said is

368
00:36:49,760 --> 00:36:59,120
important, isn't that a blocker to the performance? Not typically. So first thing I would say is that

369
00:37:00,000 --> 00:37:06,240
appending to a write-ahead log is actually quite performant on modern hardware. So that's actually

370
00:37:06,240 --> 00:37:10,160
how Kafka works, and it's how it's assumed to work. And Kafka is known as sort of a low latency

371
00:37:10,160 --> 00:37:16,000
streaming thing. It's not that low latency because of details, but it's relative to what a lot of

372
00:37:16,000 --> 00:37:22,160
people use, very low latency. The other thing that's important to know about Kafka and systems like

373
00:37:22,160 --> 00:37:30,000
that is that you can trade off throughput for latency. So in the case of Kafka, you can batch

374
00:37:30,000 --> 00:37:35,040
more things up, which will cause the latency to increase, but will cause the throughput to go

375
00:37:35,040 --> 00:37:40,400
up. You can always say, I care about latency more than I care about throughput. So I will

376
00:37:41,600 --> 00:37:45,760
decrease it down to just one transaction. So that would make sense for I want a really high,

377
00:37:45,760 --> 00:37:51,680
fast-paced game where I really want the lowest possible latency, or I don't really care if things

378
00:37:51,680 --> 00:37:59,040
come in late. So that's one thing. The next thing I would say is that for games, or really any

379
00:37:59,040 --> 00:38:06,400
application, choosing the level of durability that you want should be configuration and not code.

380
00:38:06,960 --> 00:38:13,840
So what I mean by that is I ought to be able to decide that I want to listen to data that might

381
00:38:13,840 --> 00:38:20,240
not be persisted to disk, because I don't actually care about that. For a player movement, if my

382
00:38:20,240 --> 00:38:28,560
server crashes and they move back 10 feet, don't really care about that. If I'm running a bank

383
00:38:28,560 --> 00:38:35,760
transaction and it rolls back the last 10 seconds or whatever of bank transactions, it could be a

384
00:38:35,760 --> 00:38:39,600
problem, because they might have already given away the item that the guy bought, right?

385
00:38:39,600 --> 00:38:45,200
Okay, yeah, yeah. So when you say that's configuration, are you configuring it on a

386
00:38:45,280 --> 00:38:53,600
per object type basis? So could I make some match levels of persistence, you guaranteed?

387
00:38:53,600 --> 00:38:58,880
You actually configure it on a subscriber basis. So you would say, hey, I'm going to subscribe to

388
00:38:58,880 --> 00:39:04,880
this data. And for this particular subscription, I want to see the data as soon as it updates.

389
00:39:04,880 --> 00:39:10,080
I don't care if it's ready. Like, I want to hear about, so there's sort of levels at which you

390
00:39:10,080 --> 00:39:15,120
can listen in. So there's a pipeline of data that comes in. My message happens, I update the data,

391
00:39:15,840 --> 00:39:20,240
that changes the stuff in memory, I write it to disk, I replicate it to other machines,

392
00:39:20,240 --> 00:39:23,360
all of this. And at any point in time, you can decide, like, you know what, it's good enough,

393
00:39:23,360 --> 00:39:27,360
I want to listen in here, right? So I want to listen in after it's been updated memory versus

394
00:39:27,360 --> 00:39:32,560
I want to listen after it's been persisted disk versus I want to listen only when it's been replicated

395
00:39:32,560 --> 00:39:39,040
to five machines. That's a sort of a different level of listening, if that makes sense.

396
00:39:39,040 --> 00:39:43,680
I'm jumping around trying to get my handle or my hands all over. But, okay, so how does that

397
00:39:43,680 --> 00:39:50,400
work programming? I let's say the score, player score, is gradually ticking up. It's not the

398
00:39:50,400 --> 00:39:56,880
end of the world if it maybe rolls back a little bit. Am I writing some code that just subscribes

399
00:39:56,880 --> 00:40:03,120
to the score changing and just renders that corner of the screen? You certainly could do that.

400
00:40:03,680 --> 00:40:07,200
Typically, what a client will do is they'll subscribe to all the data that they want right

401
00:40:07,200 --> 00:40:10,960
up front. So they'll say, like, let's say it's a chess match, you'll say, I want to subscribe to

402
00:40:10,960 --> 00:40:15,040
all the peace positions. Or I want to subscribe to, it depends on how you program that match,

403
00:40:15,040 --> 00:40:19,680
but let's say you're going to do it in a certain way. I'm going to listen to all the peace positions

404
00:40:19,680 --> 00:40:24,000
and I want to subscribe to the score. You don't actually, a lot of cases, you can actually

405
00:40:24,000 --> 00:40:29,360
compute the score on the client based on the state of the game. But let's say you can't,

406
00:40:29,360 --> 00:40:33,280
for some reason, in this game, you would subscribe to the score as well. And then that will be

407
00:40:33,280 --> 00:40:40,080
updated in a row and you'll just say from score table, subscribe, select off star from essentially.

408
00:40:40,480 --> 00:40:46,880
Am I doing like a, am I joining those datasets? So select all from pieces, union, select all from

409
00:40:47,440 --> 00:40:54,560
score? Yeah. So in this case, you're going to basically select a subset of each server table.

410
00:40:54,560 --> 00:41:03,920
We do not yet support subscription joins. We do actually. So we support what's called a

411
00:41:04,880 --> 00:41:11,760
semi-join. So you may filter out rows from a table based on a join from another table. So for

412
00:41:11,760 --> 00:41:20,080
example, I might want to subscribe to all players who's, who are friends with this other person.

413
00:41:20,080 --> 00:41:25,520
So I would write a join and I could, but I would always get the whole player row.

414
00:41:26,320 --> 00:41:31,120
And I'm not going to get any like player plus others data. If you want to do that,

415
00:41:31,120 --> 00:41:34,640
you would subscribe to the other table as well. And then we union all of those together and send

416
00:41:34,640 --> 00:41:42,880
them down. Okay. And are we writing this query in SQL? SQL. Currently. We, there's no reason we

417
00:41:42,880 --> 00:41:47,200
can't also support other query languages like GraphQL in the future. It's just for right now,

418
00:41:47,200 --> 00:41:52,800
for building an MMO or RPG, we need SQL. Okay. So as a game programmer, I'm writing,

419
00:41:54,640 --> 00:42:00,400
like you say, very much like stored procedures that have a mixture of SQL and coding. And like,

420
00:42:00,400 --> 00:42:05,840
what's the language? So the language is the module that you're writing is a WebAssembly module.

421
00:42:05,840 --> 00:42:12,560
So it's any language that you want that compiles to WebAssembly. Notably, we support Rust and Csharp

422
00:42:12,560 --> 00:42:16,240
in terms of building a library of nice things for you to use in those languages.

423
00:42:17,360 --> 00:42:22,240
In principle, anybody else could do whatever language they want that compiles to WebAssembly.

424
00:42:23,280 --> 00:42:25,920
But yeah, those are the two that we support right now. Okay.

425
00:42:26,400 --> 00:42:31,680
I risk framing this all as objections, but I'm trying to think...

426
00:42:31,680 --> 00:42:39,600
Sure. No, no, please. There is an objectionable idea that happens to work. And so it's quite

427
00:42:39,600 --> 00:42:44,960
exciting. Okay. So the other thing that people always complain about with stored procedures,

428
00:42:44,960 --> 00:42:48,720
I mean, a lot of people dislike stored procedures. And I think the reason is,

429
00:42:50,000 --> 00:42:54,480
I think there's two reasons. One is the language can be weird for stored procedures. Personally,

430
00:42:54,560 --> 00:42:59,120
I reject that one. If it's valuable enough, you'll learn the language. The real one is

431
00:42:59,120 --> 00:43:05,600
management of stored procedures is a misery. Correct. Yes, it is. And I think these are the...

432
00:43:05,600 --> 00:43:09,760
So I would actually go a little bit further too. The permissions model of stored procedures

433
00:43:09,760 --> 00:43:19,840
at times can be arcane as well. So I believe it's really, to your point, fundamentally a user

434
00:43:19,840 --> 00:43:26,320
experience problem, not a theoretical or technological problem, if that makes sense.

435
00:43:26,320 --> 00:43:30,960
Yeah. It's like developer experience rather than this simply doesn't work.

436
00:43:30,960 --> 00:43:34,720
Yes. I mean, why... If you actually think about stored procedures as they were,

437
00:43:34,720 --> 00:43:39,600
it's a nightmare. You have data that's in your database operating that's opaque because somebody

438
00:43:39,600 --> 00:43:42,560
updated it, but you don't... It's not in version control. You don't have any idea like,

439
00:43:43,440 --> 00:43:50,560
what was running? Did somebody change it? It's like, where is it stored? It's just a nightmare.

440
00:43:52,400 --> 00:43:57,040
It's a great point. What I will say to this is actually, we didn't set out to build the database

441
00:43:57,040 --> 00:44:01,760
in stored procedures. What actually happened is we built a system that had the right UX for what

442
00:44:01,760 --> 00:44:05,920
we wanted our developers to have and then looked at it and said like, oh, from this angle, actually,

443
00:44:05,920 --> 00:44:09,840
this is just a database with stored procedures. So it was very much a... We backed into it,

444
00:44:09,840 --> 00:44:14,320
we didn't arrive there. So that's number one. Developer experience is the most important aspect

445
00:44:14,320 --> 00:44:19,280
of space time DB. And if it is bad, there's no point to doing it. That was why we created it in the

446
00:44:19,280 --> 00:44:24,640
first place. The way we solve these problems are, number one is we put all of the stored procedures

447
00:44:25,440 --> 00:44:31,920
as the root of your database. It is all in a single module that's based from a single repo,

448
00:44:31,920 --> 00:44:38,880
in this case, that you can version in version control and then you can see the versions of it.

449
00:44:38,960 --> 00:44:44,160
The thing I would liken it to, from a developer experience perspective, and now I'm going to

450
00:44:44,160 --> 00:44:53,040
say something that will maybe trigger a lot of people, but it's similar in principle to smart

451
00:44:53,040 --> 00:44:59,840
contracts. So from there, you... Nobody thinks the developer experience of those is bad, except

452
00:44:59,840 --> 00:45:04,720
the fact that they have to deal with the blockchain. But ultimately... And the programming language

453
00:45:04,720 --> 00:45:07,840
can be pretty terrible. And the programming language can be pretty terrible. But fortunately,

454
00:45:07,840 --> 00:45:12,960
we've solved both of those problems by removing the blockchain and making it so you can use whatever

455
00:45:12,960 --> 00:45:20,640
programming language you'd like. But it's the same idea, right? You do not need a DevOps team

456
00:45:21,200 --> 00:45:26,560
to maintain or an operations team or any of that or AWS credit or any of that to run your

457
00:45:28,400 --> 00:45:33,360
smart contract. What you do is you say publish, you set it, you forget it, you walk away. You

458
00:45:33,360 --> 00:45:37,600
don't have to deal with that ever again. It's running, someone's running it for you. You really

459
00:45:37,600 --> 00:45:42,160
truly don't care. And that is the promise of the developer experience that I think we can provide

460
00:45:42,160 --> 00:45:46,320
with store procedures. And it's very easy in the case of smart contracts to keep them in sync.

461
00:45:46,320 --> 00:45:49,760
Normally, actually, in a lot of systems, you can't update your smart contracts. So that's one thing.

462
00:45:50,560 --> 00:45:56,240
But in our case, you can update a space-time-due module. And it comes from a database, and you

463
00:45:56,240 --> 00:45:59,440
can see the version that was up there. And the version is stored in the log. So

464
00:46:02,240 --> 00:46:06,320
the fact that you're updating your whole database and you can do migrations within your

465
00:46:07,840 --> 00:46:14,800
module, and you're doing the whole module at a time, vastly, vastly improves it. Then you have

466
00:46:14,800 --> 00:46:18,400
the language that you want to work within, which is a normal programming language.

467
00:46:19,200 --> 00:46:22,800
And then on top of that, we have built a permissions model that allows you to

468
00:46:24,000 --> 00:46:30,800
have complex logic, which is easy to understand by the developer, if that makes sense.

469
00:46:31,440 --> 00:46:38,480
Let's go through the permissions thing. For instance, if I've got access to subscribing

470
00:46:38,480 --> 00:46:44,880
to data from the server, I wouldn't. Hypothetical black hat me would very much like to use it to

471
00:46:44,880 --> 00:46:48,720
cheat on the game. By subscribing to other people's data.

472
00:46:48,720 --> 00:46:56,720
Okay. So first thing I'll note, all games of the first type that I described, where they have a

473
00:46:56,720 --> 00:47:02,000
deterministic client and they're replicating inputs, must know about all data in those games.

474
00:47:02,000 --> 00:47:07,520
So League of Legends, you can cheat. In fact, they're doing like a kernel extension to prevent

475
00:47:07,520 --> 00:47:16,000
people from cheating. But beside the point, they require you to see all data. So if you see Fog

476
00:47:16,000 --> 00:47:21,360
of War in an RTS, you could get data, everything under that Fog of War is there. You could remove

477
00:47:21,360 --> 00:47:25,760
the Fog of War on your client and see all of the units. So sad times. So first of all, they're

478
00:47:25,760 --> 00:47:31,440
just right out. They don't provide that to you at all. In our case, what you can do is

479
00:47:32,560 --> 00:47:36,080
there's two types of permissions. There's sort of write permissions and then there's read permissions.

480
00:47:36,080 --> 00:47:42,080
So if you want to update the database, clients are only allowed to update the database through

481
00:47:42,080 --> 00:47:46,320
the module. And so what that will be is like, let's say I wanted to move a player, but I try to

482
00:47:48,160 --> 00:47:52,560
move a player in a way that's illegal. Like I'm trying to go into this level, this place where

483
00:47:52,560 --> 00:47:59,760
I need to be level 56 and I'm only level 50. What the server will do is it will check the

484
00:47:59,760 --> 00:48:03,280
level of the player because you're just writing the logic and you'll just fail the transaction.

485
00:48:03,280 --> 00:48:06,720
So you'll just say, no, you can't do that. We roll everything back and we throw it away.

486
00:48:07,520 --> 00:48:12,240
All right, so that's the first thing. The way that works is each client has an identifier,

487
00:48:12,240 --> 00:48:16,480
which is called the identity, makes sense. It's kind of like an Ethereum address,

488
00:48:16,480 --> 00:48:19,600
if you want to liken it to something in that regard, you can see who the person is.

489
00:48:20,560 --> 00:48:26,720
And then you can say, you do all the procedural checks you want in the whole world.

490
00:48:27,280 --> 00:48:31,920
Is this player friends with that or do they know each other, whatever it is,

491
00:48:31,920 --> 00:48:36,560
and then fail the transaction if it's not allowed? So that's the right. So right is super simple,

492
00:48:36,560 --> 00:48:42,800
very, very easy to do. From a read perspective, there's a couple layers that you can do. So first

493
00:48:42,800 --> 00:48:48,640
of all, what we implement today is private tables. So that's just, hey, this table is only

494
00:48:48,640 --> 00:48:53,280
viewable by the owner of the module. So based with the database creator.

495
00:48:55,600 --> 00:49:01,280
And we would like to add, so we have not yet added because it's not yet 1.0,

496
00:49:02,480 --> 00:49:09,040
both column permissions and then column read permissions and then row level security. So

497
00:49:09,040 --> 00:49:15,760
what that means is you should be able to write a function inside of your module that says,

498
00:49:16,160 --> 00:49:21,280
well, in the case of column, you're just going to annotate columns as being private, right?

499
00:49:21,280 --> 00:49:27,520
And that's that's pretty sure for for row level security. That means like, can this person see

500
00:49:27,520 --> 00:49:31,600
this row? So if they subscribe to these players, maybe this player is invisible, and I shouldn't

501
00:49:31,600 --> 00:49:35,920
be able to see them right now. Right. So you want to be able to write a filter function

502
00:49:36,880 --> 00:49:41,520
on a table. So a filter function that applies to a table that allows you to do arbitrary

503
00:49:41,520 --> 00:49:48,000
procedural logic that basically says whether or not this player should be or this row in this table

504
00:49:48,000 --> 00:49:57,040
should be visible to this subscriber. So if I had like a hypothetical card game of some kind,

505
00:49:57,040 --> 00:50:02,640
where I have cards that only I can see, cards that all my teammates can see, and cards that

506
00:50:02,640 --> 00:50:07,520
the opponent can also see, would I be able to model that? You certainly would. So you'd be able,

507
00:50:07,520 --> 00:50:11,040
what you'd do is you'd say, let's say you just have one table called cards and you'd write

508
00:50:12,080 --> 00:50:17,200
a function that says, this is the subscriber, which is like this is the identity of the subscriber.

509
00:50:18,240 --> 00:50:22,000
Do you want to show this row or these batch of rows or however we end up

510
00:50:22,000 --> 00:50:27,120
ultimately implementing it for performance reasons? And you would look through the row and you would

511
00:50:27,120 --> 00:50:33,040
say, ah, is this who is the owner of this card? I am the owner of this card. I can see it. Oh,

512
00:50:33,040 --> 00:50:37,520
I'm not the owner of this card. Is the owner of this card my teammate? Okay, I can see it.

513
00:50:38,240 --> 00:50:41,920
I am, you know, and so forth and whatever conflicts logic you want.

514
00:50:41,920 --> 00:50:45,200
Okay. And I'm writing those functions in the same language?

515
00:50:45,200 --> 00:50:51,280
In, yes, in Rust or whatever language. Okay. So the language to define security roles is

516
00:50:51,280 --> 00:50:55,360
the general purpose language. The general purpose language. And it's a procedural language,

517
00:50:56,320 --> 00:51:02,560
not going very fancy. Obviously, you can do what, for example, SuperBase does, which is they have

518
00:51:02,560 --> 00:51:09,440
you write those row level security rules in SQL. So we may also support that. I'm not sure right

519
00:51:09,440 --> 00:51:16,160
now, but boy, it is a lot easier to write Rust than some arcane SQL query about row level security.

520
00:51:16,160 --> 00:51:20,720
I'll tell you that. Okay. Right. Where does that leave us? So

521
00:51:24,000 --> 00:51:29,120
is my experience programming the server side similar to my experience program in the client

522
00:51:29,200 --> 00:51:31,920
side? Okay, this is a fantastic question.

523
00:51:35,600 --> 00:51:41,520
Let me tell you where we are today. And the vision for where we want to be with SpaceMDB.

524
00:51:42,240 --> 00:51:48,320
So where we are today is you write your server module that runs on the server. It's written in,

525
00:51:48,320 --> 00:51:54,000
let's say, Rust. You write your client. We have a Rust SDK. And what that does is

526
00:51:54,960 --> 00:52:00,320
gives you a bunch of functions that you can use like subscribe function where you can pass in

527
00:52:00,320 --> 00:52:04,320
all your SQL queries, and then you can get all the data back. The Rust SDK currently stores that

528
00:52:04,320 --> 00:52:10,160
data internally. So it has this like data, little mini database, if you will, like a little mini

529
00:52:10,160 --> 00:52:15,760
memory, and you can query that data. The querying of that data is relatively rudimentary. It's based

530
00:52:15,840 --> 00:52:24,720
on code generation that we do. So your module has a bunch of types, right? And a bunch of

531
00:52:24,720 --> 00:52:30,000
schemas and all that stuff. You can take a module, and then you can extract the schema from that

532
00:52:30,000 --> 00:52:34,640
module, and then you can code generate whatever type of clients you want. So for example,

533
00:52:35,840 --> 00:52:42,320
you can call a particular function from the client. You can get the type, so if you have a

534
00:52:42,320 --> 00:52:47,600
Rust module and a C sharp client, as we do, you can get that C sharp equivalent type to the Rust

535
00:52:47,600 --> 00:52:53,920
type on your client, if that makes sense. Okay. Which is important because that's another thing

536
00:52:53,920 --> 00:52:59,680
with with store procedures is that like, oh, the type, like you hopefully the types work because

537
00:52:59,680 --> 00:53:04,160
it's like dynamic, who knows, it's just crazy the way they do things. Or you have to sort of like

538
00:53:04,160 --> 00:53:10,960
apply a type and you have to maintain the types. We are code generating a lot of it's like protobuf,

539
00:53:10,960 --> 00:53:17,120
right? So you, you have your schema, we scoop that out of your module. It's like a protobuf

540
00:53:17,120 --> 00:53:21,760
representation of your schema, you can then code generate on whatever client you want,

541
00:53:21,760 --> 00:53:25,520
whatever types you need. So TypeScript, we support for right now TypeScript, Python,

542
00:53:26,640 --> 00:53:33,520
Rust and C sharp for clients. Okay. Yeah, but when I call those functions, they're still going to the

543
00:53:33,520 --> 00:53:42,240
local space time to be client instance. Okay. So they do and then they, they get sent out to the

544
00:53:42,240 --> 00:53:46,960
server. We don't automatically do client side prediction right now. That is something that

545
00:53:46,960 --> 00:53:54,720
for example, in bitcraft, we have to replicate the, the logic of so if you move a player, you have

546
00:53:54,720 --> 00:53:59,200
to move them fit like yourself is to rewrite the logic and C sharp and then you have to write the

547
00:53:59,200 --> 00:54:04,960
logic in Rust. That's typically how a lot of people do this, these things and it is a huge pain.

548
00:54:04,960 --> 00:54:08,400
They duplicate the logic and they have to do this thing and it's a huge pain. Yeah.

549
00:54:09,120 --> 00:54:12,240
Some more clever people, actually, I know of some that are developing

550
00:54:15,280 --> 00:54:24,240
an RTS use web assembly and they run the server both on the client and the server

551
00:54:24,240 --> 00:54:27,200
and they do that. And so that's ultimately where we'd like to go with this. So ultimately,

552
00:54:27,200 --> 00:54:31,760
we want to run space and to be not only in the server, but also in the client and have them

553
00:54:31,760 --> 00:54:36,320
synchronized between each other automatically based on your subscriptions. And then you have

554
00:54:36,320 --> 00:54:42,000
a fully running module. So the same module is running the server is running on the client.

555
00:54:43,120 --> 00:54:49,680
And when you update, when you do a call, actually we run the actual server logic on your client,

556
00:54:49,680 --> 00:54:53,600
update that and then that does the whole reconciliation. So you automatically get client

557
00:54:53,600 --> 00:54:58,720
side prediction for free. Really, how far away do you think that is?

558
00:54:59,600 --> 00:55:03,520
It's a good question. So in a sense, we're already doing it on the,

559
00:55:04,320 --> 00:55:08,160
what we call space and to be cloud, which is our cloud office. So we have, okay, there are two

560
00:55:08,160 --> 00:55:12,320
versions of space and to be there's space and to be standalone, which is the open source version

561
00:55:12,320 --> 00:55:18,160
that's on GitHub. You can take a look at that, everything that'll run like a single node clustered

562
00:55:19,120 --> 00:55:25,600
as though it were your own personal instance of space and to be, we also have cloud, which is a

563
00:55:25,600 --> 00:55:31,120
distributed system, which will run many machines in coordinate between them all. And the way we

564
00:55:31,120 --> 00:55:34,960
replicate from one to the other is sort of the normal way in which you would replicate

565
00:55:34,960 --> 00:55:39,280
a client. So they're all just clients of each other is an interesting thing. Right.

566
00:55:39,280 --> 00:55:42,720
And that has a lot of implications for strong consistency, but I don't think we have time to

567
00:55:42,720 --> 00:55:48,640
get into that. But either way, we're working towards that, I suppose on the server. And then

568
00:55:49,920 --> 00:55:54,000
we will do that as soon as we can on the client. We're also building an MMORPG. So we're a little

569
00:55:54,000 --> 00:55:59,760
bit busy. So I'm not sure exactly when that'll be, but it is still useful in the way that it is right

570
00:55:59,760 --> 00:56:04,480
now that is to say, not automatically doing client side prediction. But we will, we will

571
00:56:04,480 --> 00:56:08,480
eventually do that. I envision world. So here's the secret. Here's the real secret to what space

572
00:56:08,560 --> 00:56:15,520
and to be is actually it's not really a database at all. What it really is, is a distributed

573
00:56:15,520 --> 00:56:23,520
operating system in the spirit of plan nine, which has never sort of taken off. Let me explain. Okay.

574
00:56:25,040 --> 00:56:32,880
Briefly. So space and to be cloud, as I mentioned, runs over, let's say 100 computers,

575
00:56:32,880 --> 00:56:38,320
right? So you've got this, this thing that's running from the outside, it looks like just one

576
00:56:38,320 --> 00:56:43,120
instance of space time to be. So you can't really tell that it is made up of 100 computers.

577
00:56:43,680 --> 00:56:46,640
And what you're doing is you're taking a program and you're running it

578
00:56:47,600 --> 00:56:52,560
on that distributed computer. So it looks again, like a single

579
00:56:54,320 --> 00:57:00,160
computer. And you're running a program on it. And we're abstracting away the hardware. Boy,

580
00:57:00,160 --> 00:57:06,240
that does sound like an operating system, doesn't it? And so that is really ultimately where we'd

581
00:57:06,240 --> 00:57:14,080
like to go is a place where the cloud is not this collection of hardware and services that you

582
00:57:14,080 --> 00:57:22,080
have to piece together in this grotesque fashion. But really, it is just a giant computer. And

583
00:57:22,080 --> 00:57:25,840
you're going to take your program and you're going to run it on that giant computer. And that's it.

584
00:57:26,640 --> 00:57:30,160
This is going to be even more blurred when you've got a series of clients connecting

585
00:57:30,160 --> 00:57:33,200
into that who are themselves similarly programmed.

586
00:57:33,840 --> 00:57:41,200
Correct. And so what you might say is that you're building a gigantic distributed

587
00:57:42,480 --> 00:57:49,200
operating system that the whole world runs on top of, right? You could say that if you were so bold.

588
00:57:49,840 --> 00:57:53,760
And I don't know that we are yet, but one day, perhaps we will. So the idea would be

589
00:57:54,560 --> 00:58:02,160
that you're all operating on the same protocol to speak with each other and that you can't really

590
00:58:02,160 --> 00:58:07,680
even tell. I mean, there's a lot of details in this one. And to be quite honest, I haven't thought

591
00:58:07,680 --> 00:58:11,760
through all of it. But if everybody's speaking the same language, you have all of these modules

592
00:58:11,760 --> 00:58:16,480
subscribing to each other, it's just the actor model, you know what it is. It's very similar

593
00:58:16,480 --> 00:58:21,600
to Erlang, right? It's got the same kind of spirit. You've got these actors, and they are

594
00:58:21,600 --> 00:58:26,480
sending messages to each other, and they're listening to messages that are being sent to them,

595
00:58:26,480 --> 00:58:31,840
and they're updating their state, and they're moving on. So it's very much in that spirit.

596
00:58:31,840 --> 00:58:36,080
Okay. Let me ask you this, and you may not like this question, but I'm going to ask it anyway.

597
00:58:36,720 --> 00:58:40,320
If someone thought this is a great idea, but I'm not waiting for you to do it,

598
00:58:40,320 --> 00:58:45,280
I'm going to build this on Erlang myself. Sure. What parts would they be missing? What

599
00:58:45,280 --> 00:58:49,840
parts would they find hard? Yeah, so the whole database part, right? So don't forget about that.

600
00:58:49,920 --> 00:58:55,520
So I've thought about this in a sense. So let's say you want to build this on Erlang. Cool.

601
00:58:56,240 --> 00:59:00,080
What is Erlang missing? Well, it's missing the persistence. I know they have persistent actors,

602
00:59:01,360 --> 00:59:09,440
but the performance of that is key. The size of each actor is key. So within a space on DB actor,

603
00:59:09,440 --> 00:59:16,640
if you think about them as actors, we also do multi-version concurrency control so that we can

604
00:59:16,640 --> 00:59:22,320
run as many transactions as possible within one machine as sort of one actor as you might

605
00:59:22,320 --> 00:59:28,320
possibly be able to do. So you want each actor to be as large as possible before you start going

606
00:59:28,320 --> 00:59:31,360
into other actors because as soon as you go into distributed systems, it's complicated,

607
00:59:32,080 --> 00:59:38,320
and you can do a lot with a single machine, it turns out. Although each actor could in principle

608
00:59:38,320 --> 00:59:42,480
be more than one machine, but I digress. That's another direction to go in down in the future.

609
00:59:43,360 --> 00:59:49,120
And then there's the whole relational model. So you need to build on top of Erlang the ability

610
00:59:49,120 --> 00:59:54,400
to do queries on the rows and get the actual row data out, all of the type system stuff.

611
00:59:54,400 --> 00:59:58,960
You'd want to be able to run in whatever language you would like to because maybe

612
01:00:00,000 --> 01:00:03,360
your programmers are familiar with C-Sharp because they're Unity developers and all that.

613
01:00:04,160 --> 01:00:09,360
Let's say also now, what about the subscription? So actors in the Erlang model, as I understand,

614
01:00:09,360 --> 01:00:12,400
you can send messages to other clients, but that's kind of like the old way of

615
01:00:12,400 --> 01:00:16,400
doing it with the game servers where I need to know what this other actor wants to know

616
01:00:17,360 --> 01:00:21,200
or build a subscription system where they send me a message, which is their subscription,

617
01:00:21,200 --> 01:00:25,520
and then I run the whole query engine and then I send them what they need to know,

618
01:00:25,520 --> 01:00:29,760
which is what we have done. So you have to build that whole query subscription system up

619
01:00:30,800 --> 01:00:35,120
from the ground as well. So good luck to you. And I would love to see and use your system

620
01:00:35,120 --> 01:00:41,040
if you do that because we wanted to make a game. We are doing this because we must.

621
01:00:42,160 --> 01:00:47,520
Okay. Then perhaps we should wrap it up with the last two questions. If someone decides they

622
01:00:47,520 --> 01:00:54,240
don't want to do that, what state is SpacetimeDB in for me as a user? Can I go and play with it?

623
01:00:55,120 --> 01:00:59,360
You absolutely can. So you can go to spacetimedb.com. You can play with a demo. It's right there.

624
01:01:00,320 --> 01:01:04,720
You can also very quickly go to our quick start guide, install spacetimedb,

625
01:01:04,720 --> 01:01:09,520
get a local instance of it running, spacetime standalone. You can upload a module to that.

626
01:01:09,520 --> 01:01:14,800
You can connect to that. You can call functions on that. You can also upload to our testnet.

627
01:01:14,800 --> 01:01:20,080
So our testnet is a version of spacetimedb cloud, which is relatively nascent,

628
01:01:20,720 --> 01:01:25,360
but it's meant for you to play around with what the cloud version will be. It's completely free.

629
01:01:25,840 --> 01:01:33,920
We give you a free amount of energy. Energy is what powers these things. It's not actual energy,

630
01:01:33,920 --> 01:01:38,960
to be clear. It's just points. You can give it AWS credits. We give you AWS credits.

631
01:01:41,280 --> 01:01:49,200
You can go to town on that. Then notably for the testnet, we reserve the right monthly to

632
01:01:49,760 --> 01:01:54,480
wipe the data because we're still updating the ABI and we don't want to be locked in yet.

633
01:01:55,760 --> 01:02:04,400
Early this year, we're trying for, let's say, April to move into 1.0 and the main net. The main net

634
01:02:04,400 --> 01:02:09,120
of spacetimedb will be the version of spacetimedb where we guarantee that your data is going to

635
01:02:09,120 --> 01:02:14,400
be there forever and it will be persisted and replicated and all that good stuff.

636
01:02:16,640 --> 01:02:20,560
You can begin building your applications now for a launch post-April.

637
01:02:20,960 --> 01:02:25,920
Okay. Here's another dangerous question because there's only really one right answer.

638
01:02:26,800 --> 01:02:30,000
Is your game, BitCraft, going to be running on that testnet?

639
01:02:30,000 --> 01:02:31,360
On that main net?

640
01:02:31,360 --> 01:02:32,160
It already is.

641
01:02:32,160 --> 01:02:38,800
So, yes, 100%. We are working on, so a lot of our focus right now is getting the performance

642
01:02:39,760 --> 01:02:43,360
to where it needs to be. BitCraft used to run on what we called janktimedb,

643
01:02:43,360 --> 01:02:47,440
which was like spacetimedb, but it was the thing that we built first and it was not its own product.

644
01:02:48,240 --> 01:02:55,680
And that works quite well, but it actually was more like the traditional old servers where

645
01:02:55,680 --> 01:03:01,040
the server knew what the client wanted and it was relatively performant. And we're now

646
01:03:01,600 --> 01:03:06,400
getting back to that point that right around now, we had the same performance of janktimedb

647
01:03:06,400 --> 01:03:11,280
and now as we gear up for the alpha, which, by the way, signed up for the BitCraft alpha,

648
01:03:11,280 --> 01:03:13,440
it's happening early this year as well.

649
01:03:13,440 --> 01:03:14,880
I'll put a link in the show notes.

650
01:03:15,680 --> 01:03:24,240
Yes. And we are getting to the point where we are at that performance level that we need for

651
01:03:24,240 --> 01:03:29,280
that alpha. So that's like, well, I don't know how much I can say without upsetting the BitCraft team,

652
01:03:29,280 --> 01:03:32,720
but it's many more users than we had previously, concurrently, running in the game.

653
01:03:33,360 --> 01:03:37,040
Right. Cool. Well, you've got a busy year, a busy few years coming up.

654
01:03:37,040 --> 01:03:38,880
We surely do. We surely do.

655
01:03:38,880 --> 01:03:42,880
Awesome. Well, good luck with spacetimedb. I hope it takes off.

656
01:03:42,960 --> 01:03:46,400
Good luck with BitCraft. I hope that takes off. And if they both take off,

657
01:03:46,400 --> 01:03:48,640
you're going to invite me to your private yacht for a follow-up.

658
01:03:49,200 --> 01:03:53,120
I don't know that I'll have one of those. I'll be too busy on the next part of spacetimedb.

659
01:03:53,120 --> 01:03:56,000
So good luck. I need satellite from there.

660
01:03:57,280 --> 01:03:59,280
You'll be able to afford it if both of those work.

661
01:03:59,280 --> 01:04:00,640
I guess so. I guess so.

662
01:04:01,440 --> 01:04:03,280
Tyler, thanks very much for joining us. Cheers.

663
01:04:03,280 --> 01:04:06,400
Thanks for having me. And that's all from Tyler. Thank you very much.

664
01:04:07,040 --> 01:04:12,480
You know, in among all the things we discussed in there, I think Tyler must be something like

665
01:04:12,480 --> 01:04:16,640
our third guest to reference the Plan 9 operating system.

666
01:04:17,200 --> 01:04:20,480
And I don't know much about Plan 9, except it never took off,

667
01:04:21,040 --> 01:04:23,840
but it was a huge influence for a lot of people.

668
01:04:23,840 --> 01:04:27,440
I think we might have to have some kind of retrospective

669
01:04:27,440 --> 01:04:30,960
what we could have learned as an industry episode on Plan 9 one day.

670
01:04:31,600 --> 01:04:35,920
So if you're a Plan 9 expert, or if you know one, please get in touch.

671
01:04:36,640 --> 01:04:40,160
And the way you get in touch is the same way you send us any feedback.

672
01:04:40,160 --> 01:04:42,400
My contact details are in the show notes.

673
01:04:42,400 --> 01:04:45,760
If you're on YouTube, there's a comment box just down there.

674
01:04:46,480 --> 01:04:51,760
Spotify has a Q&A thing for each episode these days, and so on and so on. Check your app.

675
01:04:52,640 --> 01:04:55,680
On the subject of feedback and the future episodes,

676
01:04:55,680 --> 01:04:59,520
if you enjoyed this episode, please leave a like or a comment.

677
01:05:00,160 --> 01:05:03,120
If you think other people should find this podcast,

678
01:05:03,120 --> 01:05:05,280
please rate it or share it with a friend.

679
01:05:05,920 --> 01:05:09,280
And make sure you're subscribed because we're going to be back next week

680
01:05:09,280 --> 01:05:12,560
with more interesting voices from the software development world.

681
01:05:13,200 --> 01:05:16,160
Until then, I've been your host, Chris Jenkins.

682
01:05:16,160 --> 01:05:19,280
This has been Developer Voices with Tyler Clute here.

683
01:05:19,280 --> 01:05:20,240
Thanks for listening.

684
01:05:39,280 --> 01:05:40,740
you

