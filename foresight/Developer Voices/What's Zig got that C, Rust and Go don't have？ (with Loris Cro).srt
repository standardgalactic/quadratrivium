1
00:00:00,000 --> 00:00:05,640
One trend we've seen a lot in programming in recent years is the attempt to replace C.

2
00:00:05,640 --> 00:00:09,560
And I think that's both wise and terrifying.

3
00:00:09,560 --> 00:00:12,920
It's wise because C is about 50 years old,

4
00:00:12,920 --> 00:00:19,240
and being old doesn't make it bad, but it has given us five decades to think about what works

5
00:00:19,240 --> 00:00:22,160
and what doesn't work in programming language design.

6
00:00:22,160 --> 00:00:27,120
We've got 50 years worth of techniques we really ought to be putting into practice.

7
00:00:27,320 --> 00:00:32,720
And putting them into practice is the terrifying part, because C is everywhere.

8
00:00:32,720 --> 00:00:38,080
You may not write C, but I guarantee you're writing something that runs on something that runs C

9
00:00:38,080 --> 00:00:39,760
and was written in C.

10
00:00:39,760 --> 00:00:43,840
It's in the compilation stack for everything we install.

11
00:00:43,840 --> 00:00:48,240
So if languages like Go and Rust want to become the new C,

12
00:00:48,240 --> 00:00:51,000
they've really got their work cut out for them.

13
00:00:51,000 --> 00:00:55,680
All of which makes this week's topic kind of breathtaking.

14
00:00:55,680 --> 00:00:57,160
We're looking at ZIG.

15
00:00:57,160 --> 00:01:02,920
It's a language that's not only trying to take on C and C++ and Rust and Go

16
00:01:02,920 --> 00:01:05,800
for that systems programming crown,

17
00:01:05,800 --> 00:01:11,800
it's also trying to replace the infrastructure that C itself gets built on, things like LLVM.

18
00:01:11,800 --> 00:01:19,320
So it can hopefully become the best way to build systems-level software across all different architectures.

19
00:01:19,320 --> 00:01:22,720
ZIG ends up being a project with a huge scope.

20
00:01:22,760 --> 00:01:26,680
And if you're a fan of programming languages, there is a lot to chew on this week.

21
00:01:26,680 --> 00:01:31,520
We cover cross-platform compilation, to memory management techniques,

22
00:01:31,520 --> 00:01:35,560
to new thoughts in compile-time metaprogramming.

23
00:01:35,560 --> 00:01:38,920
As well as when you've got these huge long-term ambitions,

24
00:01:38,920 --> 00:01:43,160
how do you structure an open-source project for long-term funding?

25
00:01:43,160 --> 00:01:47,200
There is a lot of ground to cover, so this is a bit of a longer episode than usual,

26
00:01:47,200 --> 00:01:48,840
and we'd best get started.

27
00:01:48,840 --> 00:01:50,480
I'm your host, Chris Jenkins.

28
00:01:50,480 --> 00:01:54,160
This is Developer Voices, and today's voice is Loris Crowe.

29
00:02:07,920 --> 00:02:09,600
I'm joined today by Loris Crowe.

30
00:02:09,600 --> 00:02:11,160
How are you doing out there, Loris?

31
00:02:11,160 --> 00:02:12,480
Hello, hi, Chris.

32
00:02:12,480 --> 00:02:13,600
Pretty good, thank you.

33
00:02:13,600 --> 00:02:15,360
Good, good. It's good to have you here.

34
00:02:15,360 --> 00:02:17,560
I always love it when we do a language deep dive,

35
00:02:17,600 --> 00:02:20,320
because I'm a particular fan of the world's programming languages.

36
00:02:21,320 --> 00:02:23,440
And you're going to tell us all about ZIG,

37
00:02:23,440 --> 00:02:26,120
which is a language I don't think I've heard of,

38
00:02:26,120 --> 00:02:31,800
until we had Joran Dirk Grief on the show from Tiger Beetle,

39
00:02:31,800 --> 00:02:33,800
who said they've written a new database in ZIG,

40
00:02:33,800 --> 00:02:35,880
and I thought, well, we have to do something about ZIG.

41
00:02:35,880 --> 00:02:37,280
I have to learn about that.

42
00:02:38,280 --> 00:02:40,360
So let's start here.

43
00:02:40,360 --> 00:02:44,800
I always think new programming languages come into being

44
00:02:44,800 --> 00:02:50,320
as a reaction to what's missing in the marketplace, if you like.

45
00:02:50,320 --> 00:02:54,160
Like, there's a burning reason why ZIG needed to exist.

46
00:02:54,920 --> 00:02:56,040
Do you think that's true?

47
00:02:56,040 --> 00:02:57,880
What's ZIG's raison d'Ãªtre?

48
00:02:59,640 --> 00:03:05,880
Right. So I guess a way of answering this question,

49
00:03:05,880 --> 00:03:11,560
like, actually, is maybe to look at how it was created originally.

50
00:03:11,560 --> 00:03:15,080
So the original creator, Andrew Kelly,

51
00:03:16,040 --> 00:03:21,640
wanted to make a digital audio workstation software.

52
00:03:22,280 --> 00:03:24,280
For making electronic music and that kind of thing.

53
00:03:24,280 --> 00:03:25,520
Exactly.

54
00:03:25,520 --> 00:03:28,280
And he tried a bunch of different languages

55
00:03:28,280 --> 00:03:30,760
and he was unhappy with all the solutions,

56
00:03:30,760 --> 00:03:35,200
with all the trade-offs that each offered.

57
00:03:35,200 --> 00:03:38,120
So I think he started with higher level languages

58
00:03:38,120 --> 00:03:41,320
and then quickly found out that to do real-time audio processing,

59
00:03:42,440 --> 00:03:48,920
you can't use a language with automated memory management.

60
00:03:48,920 --> 00:03:52,880
And languages that don't give you precise control over the hardware.

61
00:03:53,560 --> 00:03:54,280
Yeah.

62
00:03:54,280 --> 00:03:57,480
Because audio is one of the places where we're talking hard real-time.

63
00:03:57,480 --> 00:03:58,280
Exactly.

64
00:03:58,280 --> 00:03:58,800
Yeah.

65
00:03:58,800 --> 00:04:00,400
You have to be there on time.

66
00:04:02,200 --> 00:04:02,720
Yeah.

67
00:04:02,720 --> 00:04:06,280
And but on the other end of the spectrum,

68
00:04:07,080 --> 00:04:10,960
at the time, the main languages that did give you

69
00:04:11,720 --> 00:04:14,560
full control over the machine were like C and C++.

70
00:04:14,560 --> 00:04:20,240
And each had its own, like, if you will, baggage of issues,

71
00:04:20,240 --> 00:04:24,480
which some of it is also up to, like, personal taste.

72
00:04:25,360 --> 00:04:28,680
But for example, C is very low level,

73
00:04:28,680 --> 00:04:32,360
but it doesn't have good metaprogramming facilities.

74
00:04:32,720 --> 00:04:37,440
C macros are very well known for being not particularly good.

75
00:04:37,880 --> 00:04:39,240
Yeah.

76
00:04:39,240 --> 00:04:40,040
Yeah.

77
00:04:40,120 --> 00:04:42,240
They're not much better than string mungent, right?

78
00:04:42,240 --> 00:04:43,080
Yeah, exactly.

79
00:04:43,080 --> 00:04:47,840
You mess around with strings and you have a lot of, like, unwanted side effects.

80
00:04:48,920 --> 00:04:49,880
Oftentimes.

81
00:04:49,880 --> 00:04:51,920
So it's a food gun.

82
00:04:51,920 --> 00:04:53,600
That's how we usually think of it.

83
00:04:53,600 --> 00:04:55,280
Yeah, yeah.

84
00:04:55,280 --> 00:04:57,320
On the other hand, you have C++,

85
00:04:57,320 --> 00:05:00,480
which I don't know if he actually did attempt to use,

86
00:05:00,480 --> 00:05:03,840
but in general, C++ exists in a space

87
00:05:04,880 --> 00:05:07,920
where the language is very powerful.

88
00:05:07,920 --> 00:05:09,720
It's very complex.

89
00:05:09,760 --> 00:05:16,600
And it's a type of language where you are heavy with abstractions, oftentimes.

90
00:05:17,360 --> 00:05:21,960
And that kind of detracts from what you're trying to accomplish.

91
00:05:22,320 --> 00:05:26,080
Or rather, some people can definitely make it work for them.

92
00:05:26,080 --> 00:05:28,600
And that is their preferred way of programming.

93
00:05:28,600 --> 00:05:29,720
So that's good.

94
00:05:29,720 --> 00:05:33,160
But for some other people, C++ doesn't really,

95
00:05:34,080 --> 00:05:39,280
you know, it doesn't feel good in your hand as a tool.

96
00:05:40,160 --> 00:05:41,600
For some people.

97
00:05:41,600 --> 00:05:45,840
Yeah, and I can see how people that we're not going to start a language war,

98
00:05:45,840 --> 00:05:49,120
but you can certainly see how people would feel that way about C++.

99
00:05:49,280 --> 00:05:50,040
Absolutely.

100
00:05:50,040 --> 00:05:54,520
And to me, you know, this is not really a thing of language war at all.

101
00:05:54,520 --> 00:06:00,040
Like, I can fully appreciate how somebody who likes that way of doing things

102
00:06:00,040 --> 00:06:02,280
can make it work for them.

103
00:06:02,280 --> 00:06:04,960
And but on the other hand, like, for me personally,

104
00:06:04,960 --> 00:06:07,680
that doesn't that way of doing things doesn't really click.

105
00:06:07,800 --> 00:06:12,480
So ultimately, I can totally see how somebody would be productive

106
00:06:12,480 --> 00:06:14,440
with C++ and I wouldn't.

107
00:06:14,440 --> 00:06:16,560
So I need a different tool.

108
00:06:16,560 --> 00:06:17,440
Right.

109
00:06:17,440 --> 00:06:20,160
And I think that Andrew also shares,

110
00:06:21,440 --> 00:06:22,960
generally speaking, this perspective.

111
00:06:22,960 --> 00:06:26,000
So he wanted to make a language that was

112
00:06:27,440 --> 00:06:29,920
low level, so they gave you full control over the machine

113
00:06:30,800 --> 00:06:33,440
that would be suitable for an audio workstation.

114
00:06:34,160 --> 00:06:39,720
And that, on the other hand, it wouldn't be overly complicated.

115
00:06:40,720 --> 00:06:44,880
And there's like a sentence that you can you can find in

116
00:06:46,000 --> 00:06:49,120
like Ziggs on the website where we say

117
00:06:50,440 --> 00:06:52,880
it's one of the first things that you can see on the front page.

118
00:06:52,880 --> 00:06:55,840
It says focus on debugging your application

119
00:06:55,920 --> 00:06:58,640
rather than debugging your programming language knowledge.

120
00:06:59,640 --> 00:07:01,840
Right. Yeah. Yeah.

121
00:07:01,920 --> 00:07:05,760
OK, so that's kind of I know people.

122
00:07:05,760 --> 00:07:08,480
Anytime you write something that's sort of competing with C

123
00:07:08,480 --> 00:07:12,840
in the low level world, someone says, why not go and why not rust?

124
00:07:13,000 --> 00:07:15,880
But you yeah, you begin to demarcate those as

125
00:07:16,880 --> 00:07:19,080
I'll let you answer it. Why is it not go or rust?

126
00:07:21,040 --> 00:07:25,720
So the reason why it's not rust, I would say is

127
00:07:26,200 --> 00:07:29,920
like the answer is very in a very general way.

128
00:07:30,800 --> 00:07:33,080
It's kind of the same answer as why not C++?

129
00:07:33,160 --> 00:07:37,560
I think that rust is another language that likes its own complexity

130
00:07:38,080 --> 00:07:40,320
and it gives a ton of power from that, for sure.

131
00:07:40,960 --> 00:07:43,280
But but the complexity is there.

132
00:07:43,800 --> 00:07:46,760
And and also

133
00:07:48,360 --> 00:07:52,000
when it comes to like giving you full control over the machine rust,

134
00:07:52,040 --> 00:07:57,440
it's not entirely of that opinion like rust for good reasons,

135
00:07:57,440 --> 00:08:00,240
for for safety reasons, rust wants to.

136
00:08:02,640 --> 00:08:07,040
Religate certain things inside unsafe rust,

137
00:08:07,040 --> 00:08:10,080
which is a part of rust that you are not supposed to use lightly.

138
00:08:10,600 --> 00:08:15,400
So that means that you will find out their libraries that

139
00:08:16,480 --> 00:08:20,280
when choosing between maximum performance in safety,

140
00:08:20,600 --> 00:08:24,480
they will choose safety, probably overperformance, oftentimes,

141
00:08:24,480 --> 00:08:27,240
because you do get audited if you have unsafe or not.

142
00:08:27,240 --> 00:08:31,640
So in general, rust is going for something slightly different

143
00:08:31,680 --> 00:08:33,840
than what Z is going for. OK.

144
00:08:34,720 --> 00:08:37,880
So both in terms of like tradeoffs between performance and safety,

145
00:08:37,920 --> 00:08:42,040
but also in terms of obstruction.

146
00:08:42,120 --> 00:08:46,440
And I would argue also like readability in terms of like the complexity

147
00:08:46,720 --> 00:08:52,000
because writing abstracted code makes it harder to understand and to read for for a consumer.

148
00:08:53,000 --> 00:08:58,320
But when it comes to to go, I think they go and they both share.

149
00:08:59,920 --> 00:09:04,400
An appreciation for simplicity, although go is not just simple,

150
00:09:04,400 --> 00:09:05,800
it's also very minimalistic.

151
00:09:07,560 --> 00:09:11,560
So I would say that there are like some parallels between Z can go,

152
00:09:11,800 --> 00:09:15,080
but we don't have the exact same take on everything.

153
00:09:15,080 --> 00:09:17,040
And I can get more into detail if you want later.

154
00:09:17,920 --> 00:09:26,000
But but ultimately, go is not as low level as rust and Z are.

155
00:09:27,000 --> 00:09:33,040
I am not sure if go would be the best choice for an audio workstation,

156
00:09:33,040 --> 00:09:37,640
for example, or for an operative system, because go has a runtime,

157
00:09:37,640 --> 00:09:39,640
has a garbage collector.

158
00:09:39,640 --> 00:09:44,640
Also, interoperability with C is a bit complicated in go because,

159
00:09:44,640 --> 00:09:47,640
well, first of all, everything, any language that has a runtime

160
00:09:47,880 --> 00:09:51,120
that makes interoperability with C a little bit more complicated

161
00:09:51,120 --> 00:09:57,560
because you need to give information to the runtime of your language

162
00:09:57,560 --> 00:10:00,440
to the garbage collector about what's going on with memory.

163
00:10:00,480 --> 00:10:02,840
And so that sometimes makes things a little bit awkward.

164
00:10:03,600 --> 00:10:06,160
But we go specifically.

165
00:10:06,160 --> 00:10:10,000
I do think that the for the go team, interoperability with C

166
00:10:10,360 --> 00:10:13,520
was never a priority or something that they really liked.

167
00:10:13,880 --> 00:10:18,320
So go can call C functions, for example.

168
00:10:19,400 --> 00:10:21,600
But you cannot do the inverse easily.

169
00:10:21,640 --> 00:10:26,200
So you cannot make a go function that can be easily called from C.

170
00:10:26,800 --> 00:10:31,520
And I think basically this is like a philosophy of the go team.

171
00:10:31,520 --> 00:10:34,360
Like they basically said, no, we want to do something different.

172
00:10:34,360 --> 00:10:35,840
We don't want to do something.

173
00:10:35,840 --> 00:10:39,720
We don't want people to rely too much on like we want to be able to consume

174
00:10:39,720 --> 00:10:42,920
C libraries, but we don't want to do the inverse.

175
00:10:43,200 --> 00:10:44,600
If you're in go land, you just go.

176
00:10:44,600 --> 00:10:46,480
I think that's kind of their philosophy there.

177
00:10:46,800 --> 00:10:50,520
Yeah, yeah, it's like we want to be able to reuse existing C,

178
00:10:50,520 --> 00:10:53,680
but we're not intending to live in the same ecosystem quite.

179
00:10:54,240 --> 00:10:55,640
Yeah, exactly. I would say that.

180
00:10:55,640 --> 00:10:59,280
And you can see that also in a bunch of choices

181
00:10:59,280 --> 00:11:02,440
that they made also with how compilation works in go

182
00:11:03,640 --> 00:11:04,920
like in terms of the compiler.

183
00:11:04,920 --> 00:11:07,360
But I think it's a reasonable choice.

184
00:11:07,360 --> 00:11:11,120
It makes sense, very different from what Zig is going for.

185
00:11:11,760 --> 00:11:14,360
Yeah, there's there's a I don't think we need language wars

186
00:11:14,360 --> 00:11:17,120
because there's a huge design space to be explored.

187
00:11:17,120 --> 00:11:20,160
And there's plenty of there's plenty of land for everyone.

188
00:11:20,280 --> 00:11:21,400
Right. Yeah.

189
00:11:21,400 --> 00:11:24,160
But OK, so that demarks what you want to be.

190
00:11:24,160 --> 00:11:28,640
What's what's Zig's answer to this set of design constraints?

191
00:11:30,840 --> 00:11:33,440
I think that.

192
00:11:34,800 --> 00:11:37,800
I think the most interesting part about the answer to like,

193
00:11:37,800 --> 00:11:40,720
let's say systems programming like lower level programming in general

194
00:11:41,360 --> 00:11:44,640
is to rebuild it from scratch.

195
00:11:45,480 --> 00:11:49,200
All these other languages that I own, not all these other languages,

196
00:11:49,200 --> 00:11:54,400
but like it is common to consider kind of like see the bottom layer

197
00:11:54,960 --> 00:11:56,800
of abstraction of what you're building.

198
00:11:56,800 --> 00:12:00,360
So for example, there are programming languages that compile to C code.

199
00:12:00,920 --> 00:12:03,360
Yeah, I think name is an example of this.

200
00:12:04,360 --> 00:12:09,080
And Rust itself, it doesn't compile to C, but for example,

201
00:12:09,080 --> 00:12:14,160
Rust depends on the C standard library of the platform that you're targeting.

202
00:12:14,160 --> 00:12:18,480
So if you're writing a Linux program, like a Rust program

203
00:12:18,480 --> 00:12:20,520
that you want to deploy on Linux,

204
00:12:20,520 --> 00:12:25,520
Rust will use the libc of your Linux distribution.

205
00:12:28,080 --> 00:12:32,560
With Zig, the idea instead is to really, really build

206
00:12:33,120 --> 00:12:35,200
everything from the bottom up.

207
00:12:35,920 --> 00:12:38,800
And this is a big scope.

208
00:12:38,920 --> 00:12:41,360
This is not like for the faint of heart.

209
00:12:42,360 --> 00:12:46,640
It's a lot of work, but it does yield some very good

210
00:12:48,960 --> 00:12:52,440
results, like some very good things that you can do once you are willing

211
00:12:52,440 --> 00:12:55,960
to do that work. So I would say that the most important

212
00:12:55,960 --> 00:13:00,440
interesting thing about Zig is that it really is a language

213
00:13:00,440 --> 00:13:05,640
that allows you to build for every target from any target,

214
00:13:05,960 --> 00:13:10,840
meaning that if you want to target like not just normal computers,

215
00:13:10,840 --> 00:13:14,400
but also very tiny embedded devices, you can do so easily.

216
00:13:14,880 --> 00:13:18,160
And that's also cross compilation because you're like you're compiling

217
00:13:18,160 --> 00:13:23,120
on a Linux machine, probably, which is going to be maybe X8664

218
00:13:23,520 --> 00:13:27,760
and you're targeting a very tiny ARM V8 embedded device.

219
00:13:27,880 --> 00:13:30,600
So you're compiling for different architecture there.

220
00:13:30,800 --> 00:13:32,800
But this is also true from computer to computer.

221
00:13:32,800 --> 00:13:36,280
So with Zig, it's a very it's considered fundamental,

222
00:13:36,280 --> 00:13:41,240
the ability to build your program for Mac OS Windows Linux

223
00:13:41,240 --> 00:13:43,480
from any of those other RSS.

224
00:13:43,480 --> 00:13:46,600
So from Linux to Windows, from Windows to Mac, etc.

225
00:13:46,920 --> 00:13:48,800
That's surprisingly rare.

226
00:13:48,800 --> 00:13:50,920
Yeah, but a very nice feature.

227
00:13:50,920 --> 00:13:55,240
And it doesn't end here because we can do this for Zig applications.

228
00:13:55,320 --> 00:13:59,200
And to be fair, I think that Go can do it for Go, Rust can do it for Rust,

229
00:13:59,480 --> 00:14:02,120
but they cannot do it for C.

230
00:14:02,120 --> 00:14:04,520
Well, we can do it also for C and C++.

231
00:14:04,520 --> 00:14:09,680
So the idea is that if you have a project that has Zig code in it

232
00:14:09,800 --> 00:14:14,080
and also a C dependency, not only you can cross compile the Zig part,

233
00:14:14,080 --> 00:14:16,520
but you can also cross compile the C part.

234
00:14:17,120 --> 00:14:18,920
Really? Yes.

235
00:14:18,920 --> 00:14:21,480
And that is, I think, the huge thing.

236
00:14:21,480 --> 00:14:28,400
And it's so big that actually you can use Zig as your C C++ compiler

237
00:14:29,080 --> 00:14:32,080
when you are trying to cross compile a Rust,

238
00:14:32,280 --> 00:14:35,920
a mixed project between Rust and C or a Go and C one.

239
00:14:35,920 --> 00:14:40,360
So, for example, Go people have been using the Zig compiler

240
00:14:41,080 --> 00:14:46,000
to enable to complete the close the circle to enable complete cross

241
00:14:46,000 --> 00:14:49,080
compilation of C Go programs.

242
00:14:49,280 --> 00:14:55,000
C Go is basically what you call a project that has both Go and C in it.

243
00:14:55,120 --> 00:14:58,000
C Go is like a component of their of the Go compiler.

244
00:14:58,240 --> 00:15:01,120
That's how they compile in a link to C code.

245
00:15:01,600 --> 00:15:06,520
So, people having using Go projects,

246
00:15:06,520 --> 00:15:09,480
they are using Zig to cross compile and same with Rust.

247
00:15:09,680 --> 00:15:14,680
Even AWS is using Zig to cross compile.

248
00:15:15,680 --> 00:15:18,560
Rust lambdas for their lambda engines

249
00:15:18,560 --> 00:15:22,080
because Rust depends on the libc of the target

250
00:15:22,600 --> 00:15:26,240
and their machines running lambda functions

251
00:15:26,920 --> 00:15:31,920
are running a specific version of Linux with an older libc.

252
00:15:32,440 --> 00:15:35,440
And you need to be able to target the correct version of the libc

253
00:15:35,440 --> 00:15:38,200
to make sure that everything runs smoothly.

254
00:15:38,520 --> 00:15:41,360
Right. And that's not something that normally compilers can do.

255
00:15:41,960 --> 00:15:46,440
And Rust itself, which doesn't concern itself with C compilation at all,

256
00:15:47,280 --> 00:15:48,520
certainly cannot do.

257
00:15:48,520 --> 00:15:52,080
So, they have there's a package called Cargo Zig build

258
00:15:52,480 --> 00:15:55,280
that allows you to use Zig to basically link

259
00:15:55,280 --> 00:15:58,120
against the correct libc version that works on lambda.

260
00:15:59,880 --> 00:16:01,200
How on earth is that working?

261
00:16:01,200 --> 00:16:04,960
Are you telling me that Zig also has a C compiler built in or?

262
00:16:05,200 --> 00:16:06,200
Yeah, it does.

263
00:16:07,400 --> 00:16:08,400
It straight up does.

264
00:16:12,360 --> 00:16:15,480
And Andrew started out trying to build an audio workstation

265
00:16:15,480 --> 00:16:18,520
and ended up building a language that also includes a C compiler.

266
00:16:18,840 --> 00:16:20,840
Yeah, pretty much. That's legendary.

267
00:16:20,920 --> 00:16:26,360
Yeah. And this is like, I would say we're like halfway through the journey

268
00:16:26,360 --> 00:16:29,680
because we want to get even more hardcore than this.

269
00:16:29,680 --> 00:16:32,760
So, I mean, if you want, we can change subject.

270
00:16:32,760 --> 00:16:34,640
Otherwise, I can. No, I'm fascinated.

271
00:16:34,640 --> 00:16:36,600
Keep going. Yeah. OK.

272
00:16:36,640 --> 00:16:42,760
So, do you remember when Apple released the M1 architecture?

273
00:16:42,760 --> 00:16:45,120
Right? Yeah, they went from Intel to ARM.

274
00:16:45,920 --> 00:16:51,240
And that was big news because, well, turned out it's also pretty good CPU,

275
00:16:51,240 --> 00:16:54,680
like pretty good architecture, Numex, I would say are pretty nice from.

276
00:16:56,280 --> 00:16:57,880
Like they're powerful.

277
00:16:57,880 --> 00:17:00,200
They overheat less. It's they're nice.

278
00:17:00,400 --> 00:17:01,400
So.

279
00:17:02,400 --> 00:17:03,720
When it will release the M1,

280
00:17:05,160 --> 00:17:07,840
Zeke was the first compiler

281
00:17:08,720 --> 00:17:14,800
that was able to cross compile for M1 from another target, from another machine.

282
00:17:14,840 --> 00:17:18,960
So, Apple, obviously, when they really well, well, not only when they released,

283
00:17:18,960 --> 00:17:22,080
but also while they were developing the M1, obviously,

284
00:17:22,080 --> 00:17:24,560
they had a tooling to compile for the M1.

285
00:17:25,480 --> 00:17:29,840
But they never released or other when when everything came out,

286
00:17:29,920 --> 00:17:36,880
they had not released any tooling for compiling for M1 from another machine.

287
00:17:38,280 --> 00:17:41,240
So you had to buy the new Mac in order to build for the new Mac?

288
00:17:41,320 --> 00:17:48,080
Exactly, because what you would get was when you have Mac OS, you get clang.

289
00:17:48,120 --> 00:17:52,320
You like you get a fork of LLVM, which is

290
00:17:53,280 --> 00:17:57,560
yeah, it's I would say it's kind of pretty much LLVM, except with like private patches

291
00:17:57,560 --> 00:18:00,280
that Apple makes specific to their system.

292
00:18:01,080 --> 00:18:05,560
And when the M1 came out, they had patches specific to the new architecture.

293
00:18:05,560 --> 00:18:10,480
So you could compile, obviously, from M1 to M1.

294
00:18:10,600 --> 00:18:16,560
But LLVM itself, the open source project, did not support M1 yet fully.

295
00:18:16,960 --> 00:18:21,280
And so you could not get LLVM like on Windows or Linux

296
00:18:21,280 --> 00:18:23,360
and then use that to compile for Mac OS.

297
00:18:23,360 --> 00:18:24,640
We were the first ones.

298
00:18:24,680 --> 00:18:29,280
And that was because not only Zig is a C compiler and to be fair,

299
00:18:29,280 --> 00:18:33,920
the C compiler stuff right now, I would say at its core, it's not super impressive.

300
00:18:33,920 --> 00:18:39,280
The the idea is that Zig uses LLVM and LLVM is like this library that allows you to.

301
00:18:40,240 --> 00:18:47,400
It's like a unified framework for optimizing for generating optimized machine code.

302
00:18:47,400 --> 00:18:53,680
So the idea is that you your compiler reads the program that it's trying to compile

303
00:18:54,040 --> 00:18:56,880
builds a data structure in memory, does semantic analysis,

304
00:18:56,880 --> 00:18:59,000
all the usual stuff that our language has to do.

305
00:18:59,000 --> 00:19:03,720
But then the final step is to give some of that information to LLVM,

306
00:19:04,040 --> 00:19:09,240
which will then take care of selecting which exact instructions

307
00:19:10,280 --> 00:19:13,920
to use for the for the CPU that you're targeting.

308
00:19:14,400 --> 00:19:20,440
Right. So it's I suppose I want to say it's almost a little bit like WebAssembly.

309
00:19:20,440 --> 00:19:25,480
It's like a very low level language is actually going to generate the final machine code.

310
00:19:26,480 --> 00:19:29,800
Yeah, that's a bit of a stretch, but that's I think that's fair.

311
00:19:29,800 --> 00:19:35,640
That's what that's the that's called the LLVM IR intermediate representation.

312
00:19:35,640 --> 00:19:40,360
Yeah, that's what you create, which is a bit code of some kind.

313
00:19:40,400 --> 00:19:45,240
And by code, sorry, of some kind, kind of like a WebAssembly.

314
00:19:45,280 --> 00:19:47,200
I think that's a fair parallel.

315
00:19:47,960 --> 00:19:49,480
OK. Yeah.

316
00:19:49,480 --> 00:19:51,080
So we give that to LLVM.

317
00:19:51,080 --> 00:19:54,760
And since we are already bundling all of LLVM,

318
00:19:54,880 --> 00:20:01,720
it doesn't take much to also add clang, which is the C compiler that runs on LLVM.

319
00:20:01,760 --> 00:20:03,720
So that's what's allowed us to build C.

320
00:20:03,720 --> 00:20:06,720
There's more than it does, but at its core, it's not super complicated.

321
00:20:07,760 --> 00:20:16,600
But but a compiler is just one step necessary to create an final executable.

322
00:20:16,640 --> 00:20:18,880
There's also a linking page at the end.

323
00:20:18,880 --> 00:20:25,280
So the main problem with the new M1 Max was that linking

324
00:20:26,760 --> 00:20:28,520
needed to be different than it was in the past.

325
00:20:28,520 --> 00:20:34,200
And the reason why we were the first ones to be able to cross compile for M1

326
00:20:35,720 --> 00:20:38,440
was because we had our own in-house linker.

327
00:20:39,320 --> 00:20:42,200
There's a core team member in the project.

328
00:20:42,640 --> 00:20:45,960
His name is Jacob Conca, and he used to work in Microsoft.

329
00:20:46,080 --> 00:20:49,920
And we kind of poached him to work.

330
00:20:49,960 --> 00:20:52,200
Well, I guess he poached himself.

331
00:20:52,280 --> 00:20:54,440
He wanted to work on on linkers.

332
00:20:55,080 --> 00:20:59,680
I think at Microsoft, he was not working on anything even remotely as exciting.

333
00:21:00,080 --> 00:21:03,520
And so he decided to jump ship and join the project full time.

334
00:21:03,840 --> 00:21:08,000
So we have our own linker, and most of the work is done by him.

335
00:21:09,520 --> 00:21:14,360
And so that my point here is that by having our own linker,

336
00:21:14,800 --> 00:21:20,640
we were able to reach to to have a feature even faster than LLVM code.

337
00:21:21,280 --> 00:21:25,040
And LLVM is considered in general like a very good project, and it is.

338
00:21:25,080 --> 00:21:26,680
And it is. Yeah.

339
00:21:26,680 --> 00:21:32,080
But by not the point is that we did not consider LLVM the baseline.

340
00:21:32,120 --> 00:21:36,440
We were willing to get past LLVM and do some of that work ourselves.

341
00:21:36,880 --> 00:21:41,120
And now going forward in this ties back to my point that we are only halfway

342
00:21:41,160 --> 00:21:46,760
through our journey now going forward, we plan to make LLVM a completely

343
00:21:46,800 --> 00:21:47,960
optional component.

344
00:21:48,080 --> 00:21:55,440
So that means that we have our own implementation of some of what LLVM does.

345
00:21:55,520 --> 00:21:58,520
So we have what we call them backends.

346
00:21:58,520 --> 00:22:03,560
So we have our own implementation of what reads the internal representation

347
00:22:03,720 --> 00:22:08,440
of the compiler, the internal data structures and the sides, which

348
00:22:08,480 --> 00:22:09,760
instructions to output.

349
00:22:11,080 --> 00:22:14,280
That's a lot of work because you have to build one of those things for each

350
00:22:14,600 --> 00:22:15,960
architecture they want to support.

351
00:22:16,000 --> 00:22:18,160
So you want to support x8664.

352
00:22:18,560 --> 00:22:19,600
That's one implementation.

353
00:22:20,000 --> 00:22:26,600
Arm 32 bit another arm 64 bit x86 like 32 bit x86.

354
00:22:26,640 --> 00:22:27,400
That's another one.

355
00:22:28,680 --> 00:22:29,920
There's more architectures out there.

356
00:22:29,920 --> 00:22:32,240
So for each one, you have to write a specific one.

357
00:22:32,240 --> 00:22:39,480
And then you have to write another bit based on the OS that you're targeting.

358
00:22:39,480 --> 00:22:47,280
So like x86 64 Windows is a little bit different than x86 64 Mac, not in terms

359
00:22:47,280 --> 00:22:51,040
of like the instructions of the program, but like the packaging, like how

360
00:22:51,040 --> 00:22:55,520
an executable is structured all the like surrounding metadata, the frame in a

361
00:22:55,520 --> 00:22:55,960
sense.

362
00:22:56,360 --> 00:22:56,640
Right.

363
00:22:56,680 --> 00:22:56,960
Yeah.

364
00:22:57,440 --> 00:22:58,720
And we're doing it.

365
00:22:59,200 --> 00:23:04,680
Now, the work that we're doing in that regard right now is not to replace

366
00:23:04,680 --> 00:23:06,920
LVM in terms of optimizations.

367
00:23:07,320 --> 00:23:11,520
So the bulk of what LVM does and what it's considered the state of the art

368
00:23:11,520 --> 00:23:12,960
for is optimizations.

369
00:23:12,960 --> 00:23:14,360
We are not doing that yet.

370
00:23:14,800 --> 00:23:19,480
What we're doing right now is basically do the work so that we can have

371
00:23:19,800 --> 00:23:26,000
debug builds, which are not optimized happen without needing LVM at all.

372
00:23:27,000 --> 00:23:29,240
Oh, that's our starting point.

373
00:23:29,480 --> 00:23:36,000
But the plan is going forward to basically have a competing, optimizing

374
00:23:36,000 --> 00:23:36,560
backend.

375
00:23:36,920 --> 00:23:41,080
So you will still be able to use LVM if you want, how it's going to happen

376
00:23:41,080 --> 00:23:42,840
in practice doesn't matter much.

377
00:23:42,840 --> 00:23:47,520
I think it's going to happen that you basically will need to get LVM through

378
00:23:47,520 --> 00:23:48,320
the package manager.

379
00:23:48,600 --> 00:23:53,400
So you will use the package manager to get LVM instead of getting it bundled

380
00:23:53,480 --> 00:23:57,960
in the compiler itself, but then you will be able to get an LVM optimized

381
00:23:57,960 --> 00:23:59,640
final executable regardless.

382
00:23:59,680 --> 00:24:03,840
But we're going to work on our competing version and you will decide

383
00:24:03,840 --> 00:24:04,880
which one you like more.

384
00:24:05,400 --> 00:24:10,280
And over time, if we do a good job, it might even be that our competing

385
00:24:10,280 --> 00:24:15,440
backend becomes compelling enough that people will use that one over LVM.

386
00:24:16,240 --> 00:24:20,880
Crikey, you're not kidding about going all the way down to the lowest level,

387
00:24:20,880 --> 00:24:21,200
right?

388
00:24:21,360 --> 00:24:22,400
Yeah, geez.

389
00:24:23,160 --> 00:24:23,440
Yeah.

390
00:24:23,480 --> 00:24:23,840
Okay.

391
00:24:23,840 --> 00:24:26,600
That's what's your timeline for that?

392
00:24:27,640 --> 00:24:30,680
Ooh, that's got to be a multi-year project, right?

393
00:24:30,880 --> 00:24:31,800
100%.

394
00:24:32,160 --> 00:24:32,920
Yeah, for sure.

395
00:24:33,720 --> 00:24:35,800
Honestly, I don't know what the timeline is going to be.

396
00:24:36,160 --> 00:24:40,640
The reality is that the timeline of these things can vary dramatically,

397
00:24:41,240 --> 00:24:44,560
depending on the amount of talent that you attract.

398
00:24:45,720 --> 00:24:51,960
One thing that the people usually say when we first tell them, yeah,

399
00:24:52,480 --> 00:24:57,320
we want to get rid of LVM, they start by saying, oh, you're insane.

400
00:24:57,640 --> 00:24:58,840
You're never going to be able to do it.

401
00:24:58,920 --> 00:25:01,520
There's a bunch of geniuses that work on LVM.

402
00:25:03,200 --> 00:25:03,560
Fair.

403
00:25:04,680 --> 00:25:05,040
Fine.

404
00:25:05,120 --> 00:25:06,400
Let's assume that that's right.

405
00:25:06,400 --> 00:25:08,640
I mean, I'm sure that the people working on LVM are smart.

406
00:25:09,960 --> 00:25:14,960
But it's not like they are bound by a blood contract to work on LVM.

407
00:25:15,840 --> 00:25:22,200
And if we work on LVM, it's a humongous C++ project that takes forever

408
00:25:22,200 --> 00:25:27,640
to compile and it's in some ways like it's messy.

409
00:25:28,440 --> 00:25:33,720
What if we were to be able to present to people working in that field

410
00:25:34,800 --> 00:25:39,120
another ecosystem where they can research the same exact kind of

411
00:25:39,320 --> 00:25:43,080
of optimizations that they are researching and implementing on LVM.

412
00:25:43,920 --> 00:25:50,560
But the compiler, instead of taking four hours to build, it takes 20 seconds.

413
00:25:52,880 --> 00:25:54,640
I imagine that would be very seductive.

414
00:25:54,920 --> 00:25:58,920
And I think you're deliberately trying to seduce people over to the zig side,

415
00:25:59,280 --> 00:26:00,360
which is fair enough.

416
00:26:01,120 --> 00:26:06,360
And I mean, we already have people in the core team who have pushed access to LVM.

417
00:26:07,000 --> 00:26:12,480
So it's not like we are like, well, I don't know anybody who is part

418
00:26:12,520 --> 00:26:15,840
like the leadership of LVM, so I wouldn't say we are like insiders.

419
00:26:17,040 --> 00:26:21,640
But we already know people who do this.

420
00:26:22,000 --> 00:26:27,600
So there's a, sounds like there's potential for both knowledge sharing

421
00:26:27,600 --> 00:26:29,800
and maybe some more kinds of sharing out there.

422
00:26:29,840 --> 00:26:31,440
Absolutely. And absolutely.

423
00:26:31,440 --> 00:26:35,400
And if LVM also ends up benefiting from this, it's great for everybody.

424
00:26:35,800 --> 00:26:39,120
Sounds like one of those whoever wins, we all win situations.

425
00:26:39,200 --> 00:26:39,840
Absolutely.

426
00:26:40,040 --> 00:26:42,360
OK. This is getting very low level.

427
00:26:42,360 --> 00:26:45,960
Maybe we should try and pull it back into a user space.

428
00:26:47,760 --> 00:26:49,600
Love the ambition, though, absolutely.

429
00:26:50,000 --> 00:26:54,520
But I do want to get a sense of what it's like to write zig.

430
00:26:54,560 --> 00:26:56,760
What am I going to find as a programmer?

431
00:26:56,840 --> 00:26:57,640
What am I going to like?

432
00:26:57,640 --> 00:26:59,200
What am I going to need to learn?

433
00:26:59,200 --> 00:27:00,200
Right. So.

434
00:27:03,880 --> 00:27:07,160
The hardest part about the zig is not the at all.

435
00:27:07,240 --> 00:27:10,360
Zig is a language is very, very simple.

436
00:27:10,360 --> 00:27:14,120
The most complicated part of zig right now is comp time,

437
00:27:14,200 --> 00:27:19,040
which is the ability to run code at compile time instead of runtime.

438
00:27:19,840 --> 00:27:25,160
And if you're not used to thinking about the two different like.

439
00:27:27,600 --> 00:27:31,960
Lifetimes of your program, the two different phases of its life,

440
00:27:32,520 --> 00:27:36,200
then you might get a little bit confused about what it is that you can can do

441
00:27:36,200 --> 00:27:39,240
at comp time or what it is that you cannot do at comp time.

442
00:27:39,520 --> 00:27:43,800
But overall, the core principle is, in my opinion, kind of straightforward

443
00:27:44,280 --> 00:27:48,360
where things get complicated is once you get into

444
00:27:48,720 --> 00:27:50,480
systems programming more in general.

445
00:27:50,560 --> 00:27:54,040
So if you were like a JavaScript or a Python developer

446
00:27:54,560 --> 00:27:57,920
and you never had in your life to think about the stock versus hip,

447
00:27:58,200 --> 00:28:01,120
or maybe people told you, but like if you're a Python programmer,

448
00:28:01,240 --> 00:28:03,440
this is something that also happened to me like in university.

449
00:28:05,000 --> 00:28:08,040
If you do Python and people told you about the stock versus hip,

450
00:28:08,080 --> 00:28:11,520
that's like philosophy to you because that's yeah, right.

451
00:28:11,520 --> 00:28:14,040
You don't have fascinating, but you'll never use this knowledge.

452
00:28:14,040 --> 00:28:15,920
Exactly. Like you don't have control over it.

453
00:28:15,920 --> 00:28:17,320
And yeah.

454
00:28:19,760 --> 00:28:21,720
When you're getting to low level systems program,

455
00:28:21,720 --> 00:28:23,600
suddenly this becomes a real concern, right?

456
00:28:23,840 --> 00:28:28,320
Exactly. And so people, so the hardest part is, for example,

457
00:28:28,320 --> 00:28:34,120
understanding the difference between an array of which of whose length

458
00:28:34,320 --> 00:28:37,680
you know, you know, statically, like this is going to be a six element array

459
00:28:37,680 --> 00:28:41,960
and it's always going to be six or maybe, you know, you need up to six slots.

460
00:28:41,960 --> 00:28:45,000
Maybe at some point in time, you use fewer than those.

461
00:28:45,040 --> 00:28:48,480
So you have like a counter that tells you how many slots you're using,

462
00:28:48,880 --> 00:28:49,840
but six is the limit.

463
00:28:49,840 --> 00:28:52,840
So and if you know this statically at compile time,

464
00:28:52,880 --> 00:28:54,920
then this can be put on the stock.

465
00:28:55,880 --> 00:28:58,760
And there's some things that you can do with this memory

466
00:28:59,600 --> 00:29:04,920
thanks to the knowledge of the fact that it's bounded to six elements.

467
00:29:05,000 --> 00:29:07,280
And you know exactly how much memory it's going to need

468
00:29:07,280 --> 00:29:08,760
for the whole lifetime of the program.

469
00:29:08,760 --> 00:29:12,120
Exactly. And that is critical information for the compiler itself,

470
00:29:12,120 --> 00:29:16,840
like the language, lower level languages are like designed

471
00:29:16,840 --> 00:29:20,800
around these very critical concepts of like what you know statically

472
00:29:20,800 --> 00:29:22,640
and what you do not know statically.

473
00:29:22,640 --> 00:29:25,160
So if, for example, instead, you have a program

474
00:29:25,160 --> 00:29:28,720
where you ask the user to tell you how many items they want to enter

475
00:29:28,800 --> 00:29:31,600
and they are allowed to enter 10,000 if they want,

476
00:29:32,080 --> 00:29:37,080
or more realistically, imagine parsing a JSON file

477
00:29:37,160 --> 00:29:40,840
like a JSON file can be arbitrarily deeply nested

478
00:29:40,960 --> 00:29:42,800
or big in general.

479
00:29:42,800 --> 00:29:48,400
So in that point, you need to concern yourself with heap allocation,

480
00:29:49,160 --> 00:29:51,240
which again is something that in Python and JavaScript

481
00:29:51,240 --> 00:29:55,160
you don't do directly because the runtime manages that for you.

482
00:29:55,560 --> 00:29:58,760
Yeah. So that's one example.

483
00:29:58,840 --> 00:30:03,160
Another example is all things that your platform

484
00:30:03,240 --> 00:30:07,160
like APIs that your OS operative system gives to you,

485
00:30:07,840 --> 00:30:11,800
which people sometimes are used to think about as in terms of capabilities

486
00:30:11,800 --> 00:30:15,240
that the language gives to them, even though the language

487
00:30:16,040 --> 00:30:17,480
can only act as an intermediary.

488
00:30:17,480 --> 00:30:20,200
So for example, sometimes people ask,

489
00:30:20,960 --> 00:30:25,400
how do I get the size of the terminal window in Zig?

490
00:30:26,480 --> 00:30:31,280
And the answer is, well, the question, the real question is,

491
00:30:31,400 --> 00:30:34,800
how does your OS allow you to get that information?

492
00:30:35,800 --> 00:30:36,800
Right.

493
00:30:36,800 --> 00:30:40,680
And then, and that's going to happen through a syscall of some kind.

494
00:30:41,040 --> 00:30:43,920
And then the, I guess the secondary question is,

495
00:30:43,920 --> 00:30:49,120
well, has somebody written the boilerplate to access that syscall

496
00:30:49,160 --> 00:30:51,080
and where is it in the Zig standard library?

497
00:30:51,080 --> 00:30:54,960
So the question of how you do this kind of stuff in Zig

498
00:30:54,960 --> 00:30:57,960
or in each specific language, it's not completely wrong.

499
00:30:57,960 --> 00:30:59,600
It does make sense.

500
00:30:59,680 --> 00:31:05,320
But understanding what is the actual API below you

501
00:31:05,800 --> 00:31:08,680
can be a little bit annoying, especially when the language

502
00:31:09,440 --> 00:31:13,120
wants to show you precisely what that is.

503
00:31:13,120 --> 00:31:17,360
And it's not trying to give you a sugared interface

504
00:31:17,360 --> 00:31:21,920
that is overly simplified, because sometimes you do also get that

505
00:31:21,920 --> 00:31:23,600
in other languages, which might make sense.

506
00:31:23,600 --> 00:31:26,120
Like a higher level programming language, it makes sense that it doesn't

507
00:31:26,120 --> 00:31:30,320
give you necessarily low level access to, like, to everything.

508
00:31:32,080 --> 00:31:33,880
So I would say these are like the biggest challenges.

509
00:31:33,880 --> 00:31:35,960
People need to learn systems programming.

510
00:31:35,960 --> 00:31:38,200
They need to have this mindset where they have to think, OK,

511
00:31:38,200 --> 00:31:41,200
how like for another example, people sometimes ask,

512
00:31:41,200 --> 00:31:43,400
how do I print, call or text in the terminal?

513
00:31:43,800 --> 00:31:45,600
How do you do that in Zig?

514
00:31:45,600 --> 00:31:49,440
And the answer is, Zig doesn't concern itself with this.

515
00:31:49,440 --> 00:31:50,840
Like these are escape codes.

516
00:31:50,840 --> 00:31:55,400
It depends on which terminal you're using and a bunch of other related concerns

517
00:31:55,400 --> 00:31:58,040
that really are pretty much transparent to Zig.

518
00:31:59,440 --> 00:32:00,960
But people don't have this mindset.

519
00:32:00,960 --> 00:32:04,280
So I would say that is the hardest part about learning Zig.

520
00:32:04,400 --> 00:32:09,520
And connected to this, there aren't a lot of good learning materials, in my opinion.

521
00:32:11,320 --> 00:32:16,920
So this sounds like the usual kind of young national language problem

522
00:32:17,360 --> 00:32:19,840
where maybe there isn't a library for everything.

523
00:32:19,840 --> 00:32:22,640
Yes. And there aren't there isn't documentation for everything yet.

524
00:32:23,080 --> 00:32:24,440
Yeah, for sure.

525
00:32:24,440 --> 00:32:29,240
But also, I mean, it's not like Zig has invented systems programming.

526
00:32:29,240 --> 00:32:31,440
So it would be nice, right?

527
00:32:31,440 --> 00:32:36,280
If there was some good piece of like a good book

528
00:32:36,280 --> 00:32:40,360
that taught you the core principles without too much fuss.

529
00:32:40,360 --> 00:32:45,760
And in fact, there are plenty of books that try to teach you these things.

530
00:32:45,800 --> 00:32:49,240
It's just that in my experience, most of those that I've seen,

531
00:32:49,280 --> 00:32:55,600
they tend to conflate C specific stuff with the OS.

532
00:32:55,600 --> 00:32:58,160
So for example, you have this book that it's trying to teach you systems

533
00:32:58,160 --> 00:33:04,680
programming and it starts by telling you about how the C compilation model works

534
00:33:05,600 --> 00:33:09,840
and how that intertwines with like how libraries are

535
00:33:11,200 --> 00:33:13,800
certain files are like laid out in your system.

536
00:33:13,800 --> 00:33:15,400
And this is all real and concrete.

537
00:33:15,400 --> 00:33:19,520
And it was especially real and concrete and concrete like 40 years ago.

538
00:33:20,200 --> 00:33:25,080
But those concepts are like in other things like macros

539
00:33:25,080 --> 00:33:27,800
and where things are usually in the system library.

540
00:33:27,800 --> 00:33:31,840
But those are things that are specific to C.

541
00:33:31,840 --> 00:33:33,600
So if you're not doing C,

542
00:33:33,600 --> 00:33:38,400
a lot of these things are not as timeless as the book thinks they are.

543
00:33:38,920 --> 00:33:42,480
While instead that versus hip, that one is much more timeless.

544
00:33:42,520 --> 00:33:45,720
So personally, I think that we're missing learning materials

545
00:33:45,720 --> 00:33:51,720
that can discern between really timeless systems programming concepts

546
00:33:51,720 --> 00:33:57,800
like stock versus hip versus C isms that are not the relevant anymore.

547
00:33:58,800 --> 00:34:06,080
Yeah, yeah, that's sort of a long life cycle, but not not mathematically pure.

548
00:34:06,800 --> 00:34:08,600
You almost say, yeah, yeah.

549
00:34:08,600 --> 00:34:13,320
OK, but so I would like to talk about how the C interrupt works

550
00:34:13,800 --> 00:34:15,640
and maybe this is the way to do it.

551
00:34:15,640 --> 00:34:20,440
So if I'm if I'm actually looking to get the size of a terminal window,

552
00:34:21,080 --> 00:34:23,360
am I going to go looking for a sysop call and find

553
00:34:23,360 --> 00:34:26,040
I actually have to do it through an OSC library?

554
00:34:26,040 --> 00:34:28,720
And how's that going to play out when I actually start coding?

555
00:34:29,680 --> 00:34:34,680
So, well, I guess it depends on the US.

556
00:34:34,720 --> 00:34:37,280
Let's assume that the US is Linux. OK, for simplicity.

557
00:34:38,200 --> 00:34:41,320
So if the US is Linux, you're in luck

558
00:34:42,000 --> 00:34:47,320
because in Linux, the syscalls are considered a public API of the US.

559
00:34:48,120 --> 00:34:53,240
So you are not forced to use the C library of your OS.

560
00:34:53,960 --> 00:34:56,040
You can invoke the syscalls directly.

561
00:34:56,040 --> 00:34:59,120
And in the case of Ziggs, since we like doing things from scratch,

562
00:35:00,880 --> 00:35:05,400
you will find in the Ziggs library that we do implement the syscall,

563
00:35:05,760 --> 00:35:08,560
which I think it's IOCTL.

564
00:35:08,560 --> 00:35:12,600
This is called that you can use to get that information from the US.

565
00:35:12,760 --> 00:35:17,480
So in the case of Ziggs, so in the case of Linux,

566
00:35:18,360 --> 00:35:22,160
that's how you find that out.

567
00:35:22,160 --> 00:35:27,360
But in other platforms, yes, you would have to use a C lib,

568
00:35:27,360 --> 00:35:29,720
although we do have also bindings to the C lib.

569
00:35:29,720 --> 00:35:35,240
So in practice, you wouldn't have to do everything yourself from scratch.

570
00:35:36,400 --> 00:35:39,000
When it comes to like these very common things,

571
00:35:39,000 --> 00:35:41,600
but let's imagine that instead you want to use like a C library.

572
00:35:42,120 --> 00:35:45,120
OK, let's imagine that you want to use, I don't know, SQLite.

573
00:35:46,120 --> 00:35:50,560
By the way, SQLite is a perfect example of a very popular library used,

574
00:35:50,560 --> 00:35:52,000
for example, by Go.

575
00:35:52,000 --> 00:35:55,400
There's a lot of Go projects that the bundle SQLite,

576
00:35:55,760 --> 00:35:57,160
but SQLite is a C project.

577
00:35:57,160 --> 00:36:02,840
So that's one major use case of people using Ziggs to do cross compilation

578
00:36:02,880 --> 00:36:04,440
when they also want to bundle SQLite.

579
00:36:04,440 --> 00:36:06,880
Anyway, you want to use SQLite.

580
00:36:06,880 --> 00:36:10,200
So at its baseline, here's what you want to do.

581
00:36:10,760 --> 00:36:16,280
You want to the way this stuff works in C is that you have C files

582
00:36:16,280 --> 00:36:19,840
that contain implementations of things and have header files,

583
00:36:19,840 --> 00:36:22,480
which are like files with a dot h extension.

584
00:36:23,080 --> 00:36:24,880
And those files contain definitions.

585
00:36:24,880 --> 00:36:27,320
So they contain they do not contain the full implementation.

586
00:36:27,320 --> 00:36:30,440
They only contain like the signature of a function, for example.

587
00:36:30,440 --> 00:36:32,640
The original kind of API docs, right?

588
00:36:32,640 --> 00:36:35,120
Exactly. The original API docs, like they're there.

589
00:36:36,680 --> 00:36:38,880
What's it called? Is it called Open API, I think?

590
00:36:40,440 --> 00:36:43,120
The thing that used to be called this walker, it's basically like

591
00:36:43,400 --> 00:36:46,240
it's a system to document like a restful API, right?

592
00:36:46,360 --> 00:36:49,000
That's kind of the idea, except systems programming.

593
00:36:50,640 --> 00:36:57,120
Yeah, so the way this works is that then SQLite comes with a bunch of C files

594
00:36:57,640 --> 00:37:01,560
and one header file that you are supposed to include in your project

595
00:37:01,600 --> 00:37:03,880
to get access to the public API.

596
00:37:04,560 --> 00:37:07,200
With ZIG, you can do that directly.

597
00:37:07,200 --> 00:37:13,520
So in ZIG, you can import a C header file and it will work right away.

598
00:37:13,600 --> 00:37:18,120
Like you import that and you immediately get access to all the definitions in there.

599
00:37:18,480 --> 00:37:19,600
Oh, interesting. OK.

600
00:37:19,600 --> 00:37:22,160
So there's no kind of bridging file that you have to write.

601
00:37:22,640 --> 00:37:25,560
Well, the bridging file, in a sense, gets auto-generated.

602
00:37:25,680 --> 00:37:27,240
That's the idea. Right. OK.

603
00:37:27,240 --> 00:37:29,280
So you don't see this.

604
00:37:29,360 --> 00:37:33,200
And actually, if you do want, you can do that manually.

605
00:37:33,200 --> 00:37:36,880
Like you can take the header file, translate it to C definitions.

606
00:37:37,840 --> 00:37:42,000
And in case there's like the need to tweak something manually, you can do that if you want.

607
00:37:42,800 --> 00:37:46,880
But the happy path, like the most common way you will want to do this

608
00:37:46,920 --> 00:37:51,720
is to straight up import the header file and have ZIG do that bridging internally.

609
00:37:52,040 --> 00:37:52,880
OK.

610
00:37:54,120 --> 00:37:59,160
Then at that point, you can just straight up call all the SQLite.

611
00:37:59,280 --> 00:38:00,600
Functions, they are defining there.

612
00:38:00,600 --> 00:38:05,720
So you can you can just like go read the SQLite documentation

613
00:38:06,200 --> 00:38:08,360
and they will tell you called. I'm making this up.

614
00:38:08,360 --> 00:38:14,520
I don't remember how to use SQLite, but there's going to be maybe a test of the SQLite header API syntax.

615
00:38:14,520 --> 00:38:16,200
Don't worry. OK.

616
00:38:16,200 --> 00:38:19,280
So there's going to be some kind of SQLite in it function.

617
00:38:19,320 --> 00:38:21,400
So you just call it and it works.

618
00:38:23,480 --> 00:38:27,600
There's also a couple other things that ZIG does that help you with interoperability with C.

619
00:38:27,600 --> 00:38:31,920
So, for example, C uses non-terminated strings a lot.

620
00:38:33,480 --> 00:38:38,560
So basically, there's a you when you want to give to a function is string,

621
00:38:38,560 --> 00:38:41,400
you give it a pointer to the beginning of the string.

622
00:38:41,840 --> 00:38:44,360
And the pointer doesn't carry information about the length.

623
00:38:44,440 --> 00:38:49,920
The length will be discovered by the function that you're calling by iterating through the sting

624
00:38:50,040 --> 00:38:55,040
to the string until it encounters a zero character once it like a zero byte.

625
00:38:55,440 --> 00:38:57,440
Once you find this, your body knows that the string is over.

626
00:38:59,000 --> 00:39:01,640
Modern languages don't like to do that anymore.

627
00:39:01,680 --> 00:39:05,680
Modern languages very much prefer something else.

628
00:39:05,800 --> 00:39:07,000
I'll tell you my age.

629
00:39:07,000 --> 00:39:09,320
I can remember when we didn't like to do it at the time.

630
00:39:11,880 --> 00:39:15,520
So in ZIG, for example, normally a string,

631
00:39:15,600 --> 00:39:20,360
it's not just a pointer to the beginning of some data without null in the end.

632
00:39:20,880 --> 00:39:26,360
But in ZIG, we use slices, which other languages sometimes call five pointers.

633
00:39:26,400 --> 00:39:32,000
So the tiny what you call the pointer is a pointer, but also a length.

634
00:39:32,560 --> 00:39:34,920
So, yeah, you have both informations.

635
00:39:34,920 --> 00:39:41,160
And to be fair, sometimes in C, you also have APIs that want a length.

636
00:39:41,200 --> 00:39:45,560
No, they don't want to discover a null byte at some point, but they want you to pass in a length.

637
00:39:45,600 --> 00:39:48,960
But those have have always to be two separate arguments,

638
00:39:49,000 --> 00:39:53,240
two separate values that you need to move around in parallel.

639
00:39:53,400 --> 00:39:58,560
Anyway, so how does ZIG help with the interoperability?

640
00:39:58,560 --> 00:40:03,800
Well, string literals in ZIG are null terminated.

641
00:40:04,240 --> 00:40:07,440
So basically, when you write, I don't know, Hello World,

642
00:40:08,080 --> 00:40:12,880
and you want to use that string literal in ZIG, that's going to be a pointer plus a length.

643
00:40:13,120 --> 00:40:15,160
I don't know how long Hello World is.

644
00:40:15,160 --> 00:40:17,520
Ten characters, nine characters, whatever.

645
00:40:17,600 --> 00:40:20,560
Pencil there, you include the traditional exclamation mark at the end.

646
00:40:21,160 --> 00:40:26,440
OK, so you do have this information, but there's also going to be a null byte

647
00:40:26,680 --> 00:40:28,800
past the end of the string.

648
00:40:29,560 --> 00:40:35,080
So you can take a C, a ZIG string literal and pass it to C transparently.

649
00:40:35,240 --> 00:40:37,440
No need to do anything else, and it's always going to work.

650
00:40:38,120 --> 00:40:42,760
And more in general, ZIG does have a bunch of functions in the Sanda library

651
00:40:42,760 --> 00:40:46,960
that allow you to deal with null terminated strings,

652
00:40:46,960 --> 00:40:49,280
which are not the preferred type of string in ZIG.

653
00:40:49,280 --> 00:40:53,040
Like you don't treat strings as null terminated normally, but

654
00:40:55,400 --> 00:40:58,240
null terminated strings are a reality because not only because of C

655
00:40:58,240 --> 00:41:01,600
interoperability, like in terms of SQLite, but also because of C

656
00:41:01,600 --> 00:41:07,760
interoperability with the OS, like OS APIs, the lib C, that's C,

657
00:41:07,760 --> 00:41:11,720
but also the Cs calls often time inherit some C ism,

658
00:41:11,720 --> 00:41:16,800
some like some ways of communicating data that are like mirroring what C does.

659
00:41:17,040 --> 00:41:21,160
Yeah, unsurprisingly, often the OS is written in C.

660
00:41:21,400 --> 00:41:25,000
Exactly, because the OS is written in C, because that's maybe how people used

661
00:41:25,000 --> 00:41:26,120
to do things at the time.

662
00:41:26,120 --> 00:41:27,880
And so these things are still there.

663
00:41:28,440 --> 00:41:29,680
Yeah. Yeah.

664
00:41:29,800 --> 00:41:34,440
And OK, so to conclude, you have string literals.

665
00:41:34,480 --> 00:41:38,480
You have a lot of other like operators in ZIG that you can also use

666
00:41:38,480 --> 00:41:42,840
with C functions very easily, kind of transparently.

667
00:41:43,840 --> 00:41:47,240
But just to name one, I think it's really cool.

668
00:41:47,560 --> 00:41:48,720
You can use defer.

669
00:41:48,880 --> 00:41:54,320
So defer is almost the same concept as goes defer.

670
00:41:54,600 --> 00:41:56,840
There's like some minor differences.

671
00:41:57,480 --> 00:42:00,840
But the idea is that basically if you want to.

672
00:42:02,280 --> 00:42:07,560
Free a resource while when exiting the function, instead of making sure that

673
00:42:07,560 --> 00:42:12,200
you call free or like file close, for example, like the whatever resource

674
00:42:12,240 --> 00:42:15,760
release function you need to call, instead of making sure that you copy,

675
00:42:15,760 --> 00:42:20,280
paste that call at every exit point of your function, what you can do is

676
00:42:20,720 --> 00:42:26,280
on one line, you open a file and on the line below, you defer, close it.

677
00:42:27,480 --> 00:42:29,120
Oh, OK.

678
00:42:29,120 --> 00:42:33,800
Yeah. So you have basically a cleanup that you can put immediately

679
00:42:33,800 --> 00:42:35,680
after the creation of the resource.

680
00:42:36,200 --> 00:42:41,520
And whenever you leave that scope, no matter how you leave it, whenever

681
00:42:41,960 --> 00:42:44,640
you leave that scope, that function will be called.

682
00:42:45,720 --> 00:42:50,560
Yeah, because it's always deeply dissatisfying that you have to you

683
00:42:50,560 --> 00:42:54,840
have to remember to stick the close call or the free up call at the end.

684
00:42:54,840 --> 00:42:58,680
And it just screams this is going to get forgotten one day.

685
00:42:58,960 --> 00:43:00,320
Yeah, absolutely.

686
00:43:00,320 --> 00:43:05,200
So defer saves you from having to be too careful about like branching

687
00:43:05,200 --> 00:43:07,120
paths in your function.

688
00:43:07,160 --> 00:43:11,880
And if you look at it from a maybe it's not as handy as, you know,

689
00:43:11,880 --> 00:43:16,360
what C plus plus can do with the array with the structures that run

690
00:43:16,360 --> 00:43:18,280
automatically, you don't even have to write defer.

691
00:43:18,760 --> 00:43:24,720
But C plus plus destructors only work with C plus plus defer in zig

692
00:43:25,120 --> 00:43:27,680
also can be called on C functions.

693
00:43:27,960 --> 00:43:29,920
It's completely transparent.

694
00:43:29,920 --> 00:43:32,280
So there's this funny end result.

695
00:43:32,280 --> 00:43:39,440
We were basically zig, in a sense, is better at using C libraries than C

696
00:43:40,920 --> 00:43:45,480
because the same cleanup routine in C would require you maybe to even use go

697
00:43:45,480 --> 00:43:50,880
to like it's not uncommon for people to use go to and have like a label

698
00:43:50,880 --> 00:43:53,160
like a section of the function with all the cleanup functions.

699
00:43:53,160 --> 00:43:54,760
But it gets really messy.

700
00:43:54,760 --> 00:44:00,480
Like I don't think I am able to fully convey how messy cleanup can get in C

701
00:44:01,160 --> 00:44:02,640
because it doesn't have the fur.

702
00:44:03,160 --> 00:44:03,880
I can believe.

703
00:44:03,880 --> 00:44:04,960
Yeah, absolutely.

704
00:44:05,320 --> 00:44:06,400
That's interesting.

705
00:44:06,560 --> 00:44:10,760
That's interesting still being in C, but building on it with new syntax.

706
00:44:11,800 --> 00:44:16,360
I have to ask before we leave this particular thread, what about pointers?

707
00:44:16,360 --> 00:44:19,240
The pointer, does pointer arithmetic come into zig?

708
00:44:20,800 --> 00:44:23,120
Pointer arithmetic can come into zig.

709
00:44:23,160 --> 00:44:24,480
By the way, that's a great point.

710
00:44:24,480 --> 00:44:29,360
I was forgetting that's another great improvement over C that also helps

711
00:44:29,360 --> 00:44:30,960
beautifully with interoperability.

712
00:44:30,960 --> 00:44:35,120
So you can do pointer arithmetic in in zig if you want to,

713
00:44:35,840 --> 00:44:40,120
because because that's what the machine allows you to do.

714
00:44:40,280 --> 00:44:43,800
And maybe occasionally some OS API will require you to do so.

715
00:44:44,200 --> 00:44:48,040
But in general, you do not do pointer arithmetic in zig.

716
00:44:48,560 --> 00:44:52,760
And specifically in zig, you cannot do so in the type system.

717
00:44:52,800 --> 00:44:55,920
You are not allowed to do arithmetic on pointers.

718
00:44:56,000 --> 00:45:01,320
What you have to do is take your pointer, convert it to an integer,

719
00:45:01,800 --> 00:45:04,920
which is not like an operation that does anything at runtime.

720
00:45:04,920 --> 00:45:07,800
It's just like a type system thing.

721
00:45:07,800 --> 00:45:10,920
Like you have to be explicit about taking a pointer,

722
00:45:12,320 --> 00:45:16,240
interpreting it as a number, apply the math to the number

723
00:45:16,560 --> 00:45:18,600
and then convert it back to a pointer.

724
00:45:18,600 --> 00:45:22,280
So you can do it if you want, or if you need.

725
00:45:22,680 --> 00:45:25,720
Probably if you need, you shouldn't want the language.

726
00:45:25,920 --> 00:45:28,760
It's not going to make it easy or like very comfortable to you.

727
00:45:28,760 --> 00:45:30,760
There's a little bit of friction introduced there.

728
00:45:30,800 --> 00:45:35,000
And on the flip side, it helps identify very quickly

729
00:45:35,400 --> 00:45:37,760
where these kind of shenanigans are happening.

730
00:45:40,200 --> 00:45:44,960
Right. So it's mainly there for the sake of C interoper,

731
00:45:44,960 --> 00:45:48,720
rather than writing zig day to day.

732
00:45:49,120 --> 00:45:52,840
Exactly. And I mean, we say C interop, but I don't know.

733
00:45:52,840 --> 00:45:56,160
There might be other things out there like I'm thinking of firmwares,

734
00:45:56,160 --> 00:45:59,760
like your programming tiny embedded device, and you need something like this

735
00:45:59,760 --> 00:46:02,560
because of the very low level stuff that you're doing,

736
00:46:02,560 --> 00:46:06,080
which is not really necessarily specific to C anymore.

737
00:46:06,600 --> 00:46:09,120
But it's like low, super low level bit fiddling.

738
00:46:09,280 --> 00:46:11,760
Maybe at that point you need something like this.

739
00:46:11,760 --> 00:46:13,480
But otherwise you normally don't.

740
00:46:13,480 --> 00:46:17,160
And still related to pointers, there's another crucial thing.

741
00:46:17,880 --> 00:46:22,080
Pointers in C are very under specified in the sense

742
00:46:22,080 --> 00:46:26,280
that you see a char star, so you know it's a pointer.

743
00:46:26,560 --> 00:46:29,360
And when you dereference it, you get a character.

744
00:46:29,800 --> 00:46:33,080
But then the question is, can the pointer be null or not?

745
00:46:33,240 --> 00:46:37,400
You don't know. Maybe documentation tells you, but you're not sure normally.

746
00:46:38,200 --> 00:46:42,240
The second question is, OK, I'm getting a character at the end of this pointer.

747
00:46:42,960 --> 00:46:44,600
Assuming it's not null.

748
00:46:44,600 --> 00:46:47,840
Now, is there going to be just one character on the other side?

749
00:46:47,880 --> 00:46:49,480
Or is this like a string?

750
00:46:49,480 --> 00:46:52,000
Is this like expected to have another character afterwards

751
00:46:52,000 --> 00:46:54,080
and another one afterwards until I encounter a null?

752
00:46:54,280 --> 00:46:58,120
Is there going to be a null or am I supposed to know how many items to get

753
00:46:58,120 --> 00:46:59,520
because of another variable?

754
00:46:59,520 --> 00:47:02,400
This is not encoded in a type system at all in ZIG.

755
00:47:02,760 --> 00:47:04,960
All of these are different type of pointers.

756
00:47:04,960 --> 00:47:07,480
So if a pointer can be null, it's an optional pointer.

757
00:47:07,640 --> 00:47:10,120
So we do the thing that all modern languages are doing

758
00:47:10,120 --> 00:47:13,960
where you have the concept of optional and then you need to unwrap the optional.

759
00:47:15,080 --> 00:47:17,160
And we use that to represent null pointers.

760
00:47:18,000 --> 00:47:20,400
But then we have types for.

761
00:47:20,400 --> 00:47:23,480
So you have normal ZIG slices, which are a pointer and in length.

762
00:47:24,200 --> 00:47:27,320
But then you have a C style pointer that can be

763
00:47:27,760 --> 00:47:31,760
that's going to be a pointer either to one item, one specific item.

764
00:47:31,760 --> 00:47:34,800
So you're explicitly saying there's going to be one character, one chart.

765
00:47:34,800 --> 00:47:36,320
Again, not many.

766
00:47:36,320 --> 00:47:40,000
Or there's a syntax for saying, no, this is like a pointer

767
00:47:40,000 --> 00:47:44,160
to a unknown number of characters.

768
00:47:44,440 --> 00:47:46,400
So there's specific syntax and it's going to tell you,

769
00:47:46,720 --> 00:47:48,920
yes, this is a pointer to many items,

770
00:47:48,920 --> 00:47:51,240
but the pointer itself doesn't tell you how many.

771
00:47:52,280 --> 00:47:55,960
And then there's a pointer to an unknown number of characters

772
00:47:56,360 --> 00:47:58,440
with a null terminator at the end.

773
00:47:58,440 --> 00:48:00,360
And this is in the type system.

774
00:48:00,360 --> 00:48:04,360
So, for example, if you by mistake think that

775
00:48:05,160 --> 00:48:09,120
you're trying to create a string off of another string.

776
00:48:09,120 --> 00:48:13,040
And so like you maybe take a tiny slice from the middle of the string

777
00:48:13,040 --> 00:48:15,400
and you try to pass it to another application

778
00:48:15,480 --> 00:48:20,880
and you forget that that API is expecting an alt terminator at the end,

779
00:48:20,880 --> 00:48:24,160
which is not going to be there because you just split off like a tiny

780
00:48:24,160 --> 00:48:26,160
like two characters from the middle of a string, right?

781
00:48:26,160 --> 00:48:28,560
So there's not going to be an alt terminator on the other side.

782
00:48:29,000 --> 00:48:31,920
The Z-type system will tell you, it will give you a compile error

783
00:48:31,920 --> 00:48:35,520
because it will tell you, I'm expecting an alt term into the string.

784
00:48:36,040 --> 00:48:39,840
But the operation that you like,

785
00:48:39,840 --> 00:48:42,280
the slicing operation that you did on the other string

786
00:48:42,800 --> 00:48:44,760
does not yield an alt terminator string.

787
00:48:44,800 --> 00:48:46,880
So you will get a compile error right away

788
00:48:46,880 --> 00:48:49,320
instead of having your program read random garbage

789
00:48:49,320 --> 00:48:52,360
and maybe sometimes crash.

790
00:48:53,280 --> 00:48:54,680
Yeah, yeah.

791
00:48:54,680 --> 00:48:56,960
That's that's one other question I have to ask you then,

792
00:48:56,960 --> 00:49:01,960
because I can see right now this appealing to people that need to use C,

793
00:49:02,080 --> 00:49:07,240
don't want to use C, got into Rust, didn't make friends with the borough checker.

794
00:49:07,600 --> 00:49:08,680
Yeah.

795
00:49:08,680 --> 00:49:12,880
And now have could find ZIG being the ideal place

796
00:49:12,880 --> 00:49:17,160
if I want more type safety around C, particularly around strings.

797
00:49:17,560 --> 00:49:19,800
Yeah. What about memory management?

798
00:49:20,320 --> 00:49:22,400
Because that's the other big sticking point.

799
00:49:22,400 --> 00:49:24,360
Right. Yeah. Agreed.

800
00:49:25,840 --> 00:49:28,800
So in general, so if we want to talk about.

801
00:49:30,640 --> 00:49:33,720
If we want to talk about ergonomics, what I just what I described earlier,

802
00:49:33,720 --> 00:49:37,200
like the first statement that really helps a lot with memory management

803
00:49:38,200 --> 00:49:43,920
because you allocate a resource, defer, free it, and you're good to go.

804
00:49:43,920 --> 00:49:49,400
You need to have an explicit like malloc free call in ZIGLAND.

805
00:49:49,680 --> 00:49:50,600
Exactly.

806
00:49:50,600 --> 00:49:54,720
And to be even more concrete about this,

807
00:49:56,120 --> 00:49:58,720
ZIG does not have a global allocator.

808
00:49:59,200 --> 00:50:03,720
So in C, you have malloc and malloc is like the allocator

809
00:50:04,320 --> 00:50:08,120
and maybe different projects use a different implementation of malloc.

810
00:50:08,400 --> 00:50:12,360
There's like a few competing implementations, but in ZIG libraries,

811
00:50:12,360 --> 00:50:17,000
there's this idea that in C libraries, there's this idea that you have

812
00:50:17,760 --> 00:50:21,520
malloc coming from the ecosystem that allows you to allocate memory

813
00:50:21,880 --> 00:50:26,200
in ZIG allocators are always passed around explicitly.

814
00:50:26,760 --> 00:50:32,240
So if a function wants to allocate, it needs to accept an allocator as input.

815
00:50:33,240 --> 00:50:34,560
Interesting.

816
00:50:34,560 --> 00:50:40,480
Yeah. So this makes it more easy, dramatically, more easy to audit

817
00:50:40,480 --> 00:50:42,520
what it is that's allocating memory or not.

818
00:50:42,520 --> 00:50:46,720
If a function doesn't accept an allocator or a data structure

819
00:50:46,720 --> 00:50:49,680
that bundles the allocator in it, like it's also like, for example,

820
00:50:49,680 --> 00:50:53,480
we have a RayList, which would be like equivalent of a C++ vector.

821
00:50:53,840 --> 00:50:56,000
So like it's a growable array, right?

822
00:50:56,000 --> 00:50:59,160
When you make an array list, you give to it an allocator.

823
00:50:59,280 --> 00:51:01,760
And then when you pass around the array list,

824
00:51:01,760 --> 00:51:03,400
the array list will be able to allocate

825
00:51:03,400 --> 00:51:06,640
because it bundles a reference to the allocator inside of it.

826
00:51:08,280 --> 00:51:09,240
That's for convenience.

827
00:51:09,240 --> 00:51:13,760
But in general, you can very quickly audit

828
00:51:13,760 --> 00:51:15,920
if a function can allocate or not.

829
00:51:17,720 --> 00:51:22,840
Does that help you audit if a function is forgetting to deallocate?

830
00:51:24,480 --> 00:51:26,040
That by itself, no.

831
00:51:26,120 --> 00:51:31,480
What it helps is that the doing that is that the what we call

832
00:51:31,480 --> 00:51:34,200
the general purpose allocator, the main allocator implementation

833
00:51:34,200 --> 00:51:36,160
that you find inside of Z in the standard library.

834
00:51:37,160 --> 00:51:41,400
That allocator in debug mode has leak detection.

835
00:51:43,280 --> 00:51:49,160
So you cannot check statically if all allocator allocations are

836
00:51:49,160 --> 00:51:53,560
afraid or rather you can't unless you're willing to become Rust.

837
00:51:53,760 --> 00:51:54,440
Rust can.

838
00:51:55,440 --> 00:51:58,960
With all the limits, they also have limits on the type of like

839
00:51:58,960 --> 00:52:02,800
memory management strategies that the borrower can understand.

840
00:52:02,800 --> 00:52:03,800
But they can.

841
00:52:03,800 --> 00:52:10,880
We can't, but we can instrument the default allocator with checks

842
00:52:10,880 --> 00:52:13,200
for leaks in the bug builds.

843
00:52:13,680 --> 00:52:18,040
So when you run your tests, basically the allocator will fail

844
00:52:18,040 --> 00:52:21,960
the test if at the end of it you have like still memory allocated.

845
00:52:22,960 --> 00:52:23,480
Okay.

846
00:52:23,480 --> 00:52:26,960
And that's default built in part of the tests we don't have to

847
00:52:27,120 --> 00:52:28,480
specifically instrument.

848
00:52:28,760 --> 00:52:29,200
Exactly.

849
00:52:29,200 --> 00:52:30,240
You don't have to do anything.

850
00:52:30,720 --> 00:52:31,760
Oh, that's nice.

851
00:52:32,040 --> 00:52:39,440
Yeah, there's another angle to this also, which is that it is

852
00:52:39,440 --> 00:52:44,800
correct for programs to want to leak memory occasionally.

853
00:52:45,280 --> 00:52:49,320
In this sense, I'll use the Z compiler itself as an example.

854
00:52:49,640 --> 00:52:56,280
So the Z compiler, when built in the bug mode, we'll make sure

855
00:52:56,280 --> 00:53:02,800
to free everything when built in release mode, it will not free

856
00:53:03,360 --> 00:53:04,360
once it's about to leave.

857
00:53:04,360 --> 00:53:08,320
It will not free memory when it wants it's about to live to close

858
00:53:08,440 --> 00:53:11,000
because the OS will clean up that memory anyway.

859
00:53:11,520 --> 00:53:14,680
And there's no point in freeing every single item that you've

860
00:53:14,680 --> 00:53:16,960
allocated if your program is about to exit.

861
00:53:17,680 --> 00:53:21,360
Like making sure to free tiny things makes perfect sense when

862
00:53:21,360 --> 00:53:23,880
your program is going to use a ton of memory, or it's going to

863
00:53:23,880 --> 00:53:26,320
be super long lived, like otherwise it's going to consume

864
00:53:26,320 --> 00:53:29,480
more and more memory over time until it eats all the available

865
00:53:29,480 --> 00:53:31,200
memory and everything explodes.

866
00:53:31,440 --> 00:53:31,720
Yeah.

867
00:53:32,520 --> 00:53:36,320
But for like, let's say one shot programs, kind of like a

868
00:53:36,320 --> 00:53:39,080
compiler is like you run utility, it runs to the end and then it

869
00:53:39,080 --> 00:53:42,080
closes cleaning stuff up at the end.

870
00:53:42,600 --> 00:53:43,880
It's just wasted time.

871
00:53:44,160 --> 00:53:47,160
So have you ever used like Visual Studio?

872
00:53:49,000 --> 00:53:50,240
Not for so long.

873
00:53:50,960 --> 00:53:51,800
Yeah, I can't believe.

874
00:53:52,800 --> 00:53:56,560
Thankfully, I haven't had to use it in a while now, but a few

875
00:53:56,560 --> 00:53:59,640
years ago, like seven years ago or something, I had to use it

876
00:53:59,640 --> 00:54:00,360
consistently.

877
00:54:00,920 --> 00:54:06,000
And it drives me nuts that when you close it, not only it takes

878
00:54:06,000 --> 00:54:08,440
forever to load, that is already not okay.

879
00:54:09,400 --> 00:54:12,560
But when you close it, it takes forever to close.

880
00:54:13,400 --> 00:54:13,880
Why?

881
00:54:13,920 --> 00:54:15,160
Why is it taking forever to close?

882
00:54:15,200 --> 00:54:19,280
Because as it's closing, it's trying to free and run the

883
00:54:19,280 --> 00:54:23,520
distractors of every single component and sub component and

884
00:54:23,520 --> 00:54:24,480
sub component.

885
00:54:24,800 --> 00:54:27,160
I have a vague memory of doing this with Eclipse and just

886
00:54:27,160 --> 00:54:30,120
getting into the habit of force quitting because who cares?

887
00:54:30,400 --> 00:54:31,760
Exactly, exactly.

888
00:54:31,840 --> 00:54:35,640
And Eclipse is another in Java, I think it's another language

889
00:54:35,640 --> 00:54:40,680
that has distractors and and so kind of makes people want to use

890
00:54:40,680 --> 00:54:41,320
them a lot.

891
00:54:41,680 --> 00:54:45,280
But then there's moments where you actually really in terms of

892
00:54:45,280 --> 00:54:47,600
like functionality that you're offering to the user, you don't

893
00:54:47,600 --> 00:54:48,200
want to do it.

894
00:54:48,240 --> 00:54:50,760
Like you just want to close it right away.

895
00:54:51,240 --> 00:54:57,440
Yeah, so long story short, I made this point because in

896
00:54:57,440 --> 00:55:03,360
reality, it is a legitimate behavior to have the program in

897
00:55:03,360 --> 00:55:07,480
specific circumstances, like memory, if you think about it.

898
00:55:07,760 --> 00:55:10,520
Because like for real, like the user experience would be

899
00:55:10,560 --> 00:55:14,440
generally significantly improved in both Eclipse and Visual

900
00:55:14,440 --> 00:55:17,440
Studio, if the thing just exited right away.

901
00:55:17,640 --> 00:55:23,160
Of course, you do want to have a toggle like a flag that makes

902
00:55:23,160 --> 00:55:27,760
sure you free all the memory cleanly so that you can guarantee

903
00:55:27,760 --> 00:55:29,960
that you do not have unwanted leaks.

904
00:55:30,120 --> 00:55:33,520
Like Visual Studio, for example, is a long running program in

905
00:55:33,520 --> 00:55:33,960
Eclipse.

906
00:55:34,280 --> 00:55:34,480
Yeah.

907
00:55:34,760 --> 00:55:39,680
So they should not be leaking memory in the normal operations.

908
00:55:39,720 --> 00:55:40,840
So it's not.

909
00:55:41,320 --> 00:55:44,640
So you still want to be able to test for that.

910
00:55:45,000 --> 00:55:45,920
There are like two minutes.

911
00:55:46,200 --> 00:55:48,480
There are at least two memory management strategies.

912
00:55:48,480 --> 00:55:50,920
One is be very careful about what you're using because it's a

913
00:55:50,920 --> 00:55:52,040
limited resource.

914
00:55:52,280 --> 00:55:52,600
Yeah.

915
00:55:52,880 --> 00:55:56,200
But for the long run, you know, whatever memory you're using at

916
00:55:56,200 --> 00:55:58,000
the end, you can just drop on the floor.

917
00:55:58,240 --> 00:55:58,560
Right.

918
00:55:58,720 --> 00:55:59,160
Exactly.

919
00:55:59,360 --> 00:56:00,720
Yeah, yeah, that makes perfect sense.

920
00:56:01,480 --> 00:56:04,600
There's one other big thing that you've talked about a little

921
00:56:04,600 --> 00:56:08,280
bit, but I'm tempted to run over our usual time slots.

922
00:56:08,280 --> 00:56:09,600
I'm fascinated by this.

923
00:56:09,600 --> 00:56:10,160
Go for it.

924
00:56:10,160 --> 00:56:12,120
I'm not in a rush, for sure.

925
00:56:12,360 --> 00:56:12,680
Good.

926
00:56:13,040 --> 00:56:16,200
So comp time, you talked a bit about that.

927
00:56:16,240 --> 00:56:20,720
And as an old list programmer, this is a concept that makes sense

928
00:56:20,720 --> 00:56:23,440
to me, but I think it's never really gone mainstream.

929
00:56:23,960 --> 00:56:26,920
So why don't we talk a bit about the separation between runtime

930
00:56:26,920 --> 00:56:29,000
programs and compile time programs?

931
00:56:29,560 --> 00:56:30,080
Sure.

932
00:56:30,320 --> 00:56:30,720
Sure.

933
00:56:32,880 --> 00:56:37,680
So let me tell you about how Zig does this more specifically.

934
00:56:39,160 --> 00:56:45,040
So comp time in Zig is interesting because Zig as a language

935
00:56:45,360 --> 00:56:47,680
doesn't have runtime type information.

936
00:56:47,880 --> 00:56:52,360
So for example, in JavaScript, Python, also in Go, you can ask

937
00:56:52,360 --> 00:56:56,560
questions to the program running at runtime about its types.

938
00:56:57,320 --> 00:57:00,760
C programs, on the other hand, don't have a runtime, and they

939
00:57:00,760 --> 00:57:02,560
don't have runtime type information.

940
00:57:02,600 --> 00:57:05,760
Usually it's not always the case, but usually runtime type

941
00:57:05,760 --> 00:57:10,400
information tends to go hand in hand with an actual runtime of

942
00:57:10,400 --> 00:57:10,960
the language.

943
00:57:10,960 --> 00:57:16,040
So for example, in Python, you can create new types at runtime.

944
00:57:16,080 --> 00:57:17,280
You can do introspection.

945
00:57:17,760 --> 00:57:23,680
And so having a runtime that can yield those dynamic properties to

946
00:57:23,760 --> 00:57:28,640
you usually benefits from having runtime type information.

947
00:57:29,640 --> 00:57:33,760
C doesn't have those facilities because a struct in C at the end

948
00:57:33,760 --> 00:57:36,720
of the day boils down to offsets in memory.

949
00:57:37,680 --> 00:57:43,680
Oh, the struct is, I don't know, 16 bytes long and eight bytes in.

950
00:57:44,320 --> 00:57:46,560
And it contains two fields.

951
00:57:46,560 --> 00:57:49,920
The first field is at offset zero and the other one is at offset

952
00:57:49,920 --> 00:57:51,760
eight, and that's the end of it.

953
00:57:51,760 --> 00:57:53,360
So everything else has disappeared.

954
00:57:56,240 --> 00:58:01,760
But it is useful to be able to inspect types and reason about

955
00:58:01,760 --> 00:58:03,320
types at least statically.

956
00:58:03,320 --> 00:58:04,320
So that's what ZIG does.

957
00:58:04,320 --> 00:58:07,520
ZIG does not give you runtime type information, but it does give

958
00:58:07,520 --> 00:58:09,880
you com time type information.

959
00:58:10,200 --> 00:58:12,840
So you are not allowed, you're not able to create new types at

960
00:58:12,840 --> 00:58:18,720
runtime, but you are able to create new types at compile time by

961
00:58:18,720 --> 00:58:20,320
reasoning on other types.

962
00:58:21,040 --> 00:58:23,680
And the way you reason on other types, and by the way, this is

963
00:58:23,680 --> 00:58:25,600
also what generic does in other languages.

964
00:58:25,600 --> 00:58:30,480
It's just that this is usually done in other imperative languages.

965
00:58:30,480 --> 00:58:34,800
This is usually done with a funky declarative syntax and a bunch

966
00:58:34,800 --> 00:58:38,400
of diamond brackets where you use diamond brackets to denote

967
00:58:38,400 --> 00:58:43,360
like the generic type and then to put constraints on it using

968
00:58:43,360 --> 00:58:45,760
like some kind of declarative syntax.

969
00:58:45,760 --> 00:58:48,560
Like I want type T to be, I don't know.

970
00:58:51,280 --> 00:58:54,560
To conform to interface A or interface B, et cetera.

971
00:58:55,360 --> 00:58:58,480
Okay, so you're using, you're saying you're using com time to do

972
00:58:58,480 --> 00:59:01,600
things like I want a list of As, but now I need to pin it down

973
00:59:01,600 --> 00:59:03,200
to be a list of eight bit integers.

974
00:59:03,920 --> 00:59:04,400
Yeah.

975
00:59:04,800 --> 00:59:05,280
Yeah, okay.

976
00:59:06,000 --> 00:59:10,800
Because you can, because the idea is that you are creating a new

977
00:59:10,800 --> 00:59:15,440
type by referring to another existing types, another existing

978
00:59:15,520 --> 00:59:16,160
type.

979
00:59:16,160 --> 00:59:20,640
And the way you do this in Zig is not via these custom syntax,

980
00:59:20,640 --> 00:59:23,520
but by using normal Zig syntax.

981
00:59:23,520 --> 00:59:27,520
So literally a list, for example, let's say you want to make a generic

982
00:59:27,520 --> 00:59:30,160
list and you want then to be able to make a list of integers,

983
00:59:30,160 --> 00:59:31,520
a list of characters, whatever.

984
00:59:32,560 --> 00:59:35,600
The way you implement this in Zig is that you create a function

985
00:59:35,600 --> 00:59:41,760
called list that accepts a type as input, which has to be marked

986
00:59:41,760 --> 00:59:43,040
as a com time parameter.

987
00:59:43,040 --> 00:59:47,520
So like the signature would literally read fn list, open parentheses,

988
00:59:48,160 --> 00:59:51,120
com time t column type.

989
00:59:51,120 --> 00:59:55,760
So it's a com time parameter named t of type type.

990
00:59:55,760 --> 00:59:57,360
You have to pass in a type.

991
00:59:57,360 --> 00:59:59,680
And so that could be like integer or whatever.

992
01:00:00,480 --> 01:00:02,720
And then this function returns another type.

993
01:00:03,600 --> 01:00:07,920
And in the function body, you create a, you create a struct,

994
01:00:07,920 --> 01:00:11,200
you return a struct definition that places,

995
01:00:11,200 --> 01:00:14,560
that defines the payload field, like a struct probably that has

996
01:00:14,560 --> 01:00:18,240
the payload field of type t, what you passed in,

997
01:00:18,240 --> 01:00:19,520
which is kind of like generic's work.

998
01:00:20,480 --> 01:00:25,520
But it's normal procedural Zig code that gets executed compile time.

999
01:00:25,520 --> 01:00:28,480
So for example, you could create like an,

1000
01:00:29,760 --> 01:00:32,880
let's say you're making a simple array, but the length of that array,

1001
01:00:32,880 --> 01:00:36,480
you want to be the result of other reasoning.

1002
01:00:36,480 --> 01:00:40,160
You could create a Fibonacci function, run it at com time,

1003
01:00:40,160 --> 01:00:44,640
and say that your array is long the 10th Fibonacci number,

1004
01:00:45,280 --> 01:00:47,120
which I don't know how much it is, but it's not going to be 10.

1005
01:00:47,120 --> 01:00:48,160
It's going to be a bigger number.

1006
01:00:49,440 --> 01:00:50,080
Right.

1007
01:00:50,080 --> 01:00:53,680
So you can call normal, run normal Z code.

1008
01:00:53,680 --> 01:00:58,480
It's going to be interpreted by the compiler while compiling.

1009
01:00:59,040 --> 01:01:02,240
And usually you do have some of that in other languages.

1010
01:01:02,240 --> 01:01:04,320
It's just not fully general purpose.

1011
01:01:04,320 --> 01:01:07,520
They give you restricted language to specify properties

1012
01:01:07,520 --> 01:01:11,120
and they have their own special rules in Z.

1013
01:01:11,120 --> 01:01:12,960
It's just you run the Z code.

1014
01:01:12,960 --> 01:01:17,680
And the compiler has like a concept of a execution quota.

1015
01:01:17,680 --> 01:01:21,280
So that like, for example, if you make a mistake and you try to make,

1016
01:01:23,440 --> 01:01:28,400
you make an array that is the 1000 Fibonacci number,

1017
01:01:28,400 --> 01:01:30,720
but your Fibonacci implementation is very bad.

1018
01:01:30,720 --> 01:01:32,640
The compiler after a while is going to tell you

1019
01:01:33,600 --> 01:01:35,680
I executed like 10,000 loops.

1020
01:01:36,400 --> 01:01:41,440
And I, and since we couldn't come to a conclusion, I gave up.

1021
01:01:41,440 --> 01:01:45,680
And if you really think this is, this is not like an infinite loop,

1022
01:01:45,680 --> 01:01:47,840
then you can pull up that number,

1023
01:01:47,840 --> 01:01:52,720
like the number of executions before giving up and we're going to try again.

1024
01:01:52,720 --> 01:01:57,280
But so that way basically we, the compiler is how it deals with like infinite loops

1025
01:01:57,280 --> 01:01:58,480
and undecidable stuff.

1026
01:01:59,120 --> 01:02:02,000
Yeah. So you're protecting against people making,

1027
01:02:02,000 --> 01:02:04,160
accidentally making compile time infinitely long.

1028
01:02:04,160 --> 01:02:04,880
Exactly.

1029
01:02:04,880 --> 01:02:06,080
Yeah. Yeah. Yeah.

1030
01:02:06,080 --> 01:02:09,600
And Alan Turing has opinions on why you can't automate that.

1031
01:02:09,600 --> 01:02:10,240
Yeah, exactly.

1032
01:02:10,240 --> 01:02:11,920
So, and you know what?

1033
01:02:11,920 --> 01:02:16,720
In our case, I think it's fine in practice to solve the indecidability problem

1034
01:02:16,720 --> 01:02:20,720
by just giving up because ultimately, like you're trying to compile a program

1035
01:02:20,720 --> 01:02:23,840
and you're not willing to sit there forever

1036
01:02:23,840 --> 01:02:26,240
or up with radical long to have it compile.

1037
01:02:26,240 --> 01:02:27,440
So yeah.

1038
01:02:28,080 --> 01:02:30,560
Okay. So this raises two natural questions.

1039
01:02:30,560 --> 01:02:33,840
And the first has got to be, what's that like as a,

1040
01:02:33,840 --> 01:02:34,800
as a programmer?

1041
01:02:35,360 --> 01:02:40,160
Because most of us are used to using like diamond brackets for generics.

1042
01:02:40,160 --> 01:02:41,520
Do you prefer the zig way?

1043
01:02:41,520 --> 01:02:43,440
Does it feel natural once you get used to it?

1044
01:02:44,000 --> 01:02:46,480
I think it feels insanely natural.

1045
01:02:46,480 --> 01:02:49,520
Like you mentioned earlier, Lisp to me,

1046
01:02:49,520 --> 01:02:51,520
by the way, I also love Lisp.

1047
01:02:51,520 --> 01:02:53,360
I've never used Lisp professionally,

1048
01:02:53,360 --> 01:02:56,880
but like in university, definitely one of my favorite subjects.

1049
01:02:56,880 --> 01:03:02,480
And I also loved writing macros in Lisp.

1050
01:03:03,360 --> 01:03:06,320
And it feels like writing macros in Lisp.

1051
01:03:06,320 --> 01:03:10,560
Or actually, I would say it's even better than writing macros in Lisp.

1052
01:03:11,120 --> 01:03:13,360
Yeah, the spice opinion.

1053
01:03:13,360 --> 01:03:18,960
Well, so what I think happens with Lisp is that people say macros in Lisp are nice

1054
01:03:18,960 --> 01:03:23,280
because Lisp is an almost iconic language.

1055
01:03:23,280 --> 01:03:28,560
So the language itself is the data structure that represents it.

1056
01:03:28,560 --> 01:03:33,440
It's the list, the, well, the symbolic expression that represents it,

1057
01:03:34,560 --> 01:03:35,120
which is fair.

1058
01:03:35,120 --> 01:03:43,920
But I do think that the actual truth is that by having the program be a data structure,

1059
01:03:44,880 --> 01:03:52,320
you are naturally, the language is steering you naturally towards treating

1060
01:03:52,960 --> 01:03:57,760
the program as a data structure instead of it being a textual transformation.

1061
01:03:59,280 --> 01:04:03,360
And in fact, you can write macros in Lisp that don't generalize really well,

1062
01:04:03,360 --> 01:04:09,360
that like make assumptions about a specific like argument being,

1063
01:04:10,240 --> 01:04:13,680
being or not being a list or being or not being quoted, for example.

1064
01:04:14,480 --> 01:04:17,360
In ZIG, you are literally,

1065
01:04:18,480 --> 01:04:22,560
comp time is more limited than what you can do with list macros just to be clear.

1066
01:04:22,560 --> 01:04:24,000
And that's also kind of by design.

1067
01:04:24,000 --> 01:04:26,400
It's kind of like a 80-20 thing.

1068
01:04:26,400 --> 01:04:32,160
Like it gives you 80% of the power, but it saves you from the 20% of really cursed stuff

1069
01:04:32,160 --> 01:04:37,280
that people will want to do all the time or rather with 20% of the complexity,

1070
01:04:37,280 --> 01:04:39,200
which does save you from cursed stuff.

1071
01:04:41,280 --> 01:04:48,240
In ZIG, what you do is like the, when you look at the time, you literally call a function,

1072
01:04:49,120 --> 01:04:53,120
like you call at type info and you pass in a struct.

1073
01:04:53,120 --> 01:04:57,920
So let's say that you made a struct called named person and person has age and name.

1074
01:04:58,880 --> 01:05:03,040
And then you call type info on person and what you get back

1075
01:05:04,240 --> 01:05:10,560
is a data structure that contains, like it's another struct that contains all the info about

1076
01:05:10,560 --> 01:05:17,120
that type. Like among other things, it will contain like an array that contains the two fields

1077
01:05:17,120 --> 01:05:21,840
with information about how the field is called, what's the type, etc., etc.

1078
01:05:22,640 --> 01:05:30,000
And so your metaprogramming is always going to look at the program as data and never as

1079
01:05:30,000 --> 01:05:35,200
syntax. And I think that's the key that makes come time weirdly, weirdly natural.

1080
01:05:36,160 --> 01:05:42,080
Okay, yeah. Yeah, it does remind me, I mean, the frustration with Lisp macros was always

1081
01:05:42,080 --> 01:05:47,040
that they were untyped and you could really cause things to explode in an even more spectacular way

1082
01:05:47,120 --> 01:05:52,960
than normal Lisp. Absolutely. But the nice thing was that there was absolutely no difference between

1083
01:05:52,960 --> 01:05:57,120
writing programs that work to compile time and runtime, because it was the same tools,

1084
01:05:57,120 --> 01:06:03,600
same language, same everything. Exactly. And it's the same for zig. Because you do use the same

1085
01:06:03,600 --> 01:06:11,120
syntax. You like, I have an example on a blog post that I've wrote, trying to introduce people to

1086
01:06:11,120 --> 01:06:18,240
the concept of comp time. And my favorite example in there is this idea that, which is actually

1087
01:06:18,240 --> 01:06:24,720
taken from real life experience. I was writing a Redis client for zig. And in Redis, you have

1088
01:06:25,280 --> 01:06:31,760
commands, like the query language of Redis makes you write commands that are case insensitive.

1089
01:06:31,760 --> 01:06:36,400
So if you write it uppercase or lowercase, it doesn't matter. So at some point in my client,

1090
01:06:36,400 --> 01:06:40,800
I wanted to recognize some of those commands. So I wanted to check for equality between two

1091
01:06:40,800 --> 01:06:50,800
strings. And my idea was, well, to slightly, very slightly improve the performance of the comparison

1092
01:06:50,800 --> 01:06:57,680
function. If I know that the constant string, like the string literal that I hard code in my

1093
01:06:58,720 --> 01:07:03,920
program that I used to check the user provided string against, if I know that that one is always

1094
01:07:03,920 --> 01:07:09,040
going to be uppercase, I can simplify the comparison code ever so slightly. I can just remove one

1095
01:07:09,040 --> 01:07:18,480
branch from the comparison. But now I have, I want to enforce that when you call my equal function,

1096
01:07:19,200 --> 01:07:23,280
you always pass in the first argument, the argument that you're passing,

1097
01:07:24,000 --> 01:07:27,280
like the first argument that you're passing is always going to be uppercase.

1098
01:07:28,480 --> 01:07:32,640
Right. So you want some compile time code to check those strings are correctly written.

1099
01:07:32,640 --> 01:07:39,120
Exactly. Now, imagine trying to do that with diamond brackets stuff. I have no idea if you

1100
01:07:39,120 --> 01:07:44,240
can actually even pull it off. Here's what you do in Zig. In Zig, in the function body,

1101
01:07:45,040 --> 01:07:50,000
you open a comp time block. Well, first of all, you have to mark the first argument as always

1102
01:07:50,000 --> 01:07:54,160
being available at comp time. So people will be forced to give you, it doesn't have to be a string

1103
01:07:54,160 --> 01:08:00,640
literal directly. It can be like a variable name. But ultimately, the value containing that variable

1104
01:08:00,640 --> 01:08:05,760
needs to be resolvable at comp time. It doesn't need to depend on weird stuff like the network.

1105
01:08:10,320 --> 01:08:17,200
So you open a comp time block, and in there, you have a for loop that loops over the string

1106
01:08:17,200 --> 01:08:23,520
and checks that its character is in the correct range. That's it. That's all you do. Nothing

1107
01:08:23,520 --> 01:08:27,200
weird. You just use the language to check the string character by character. And if you find a

1108
01:08:27,200 --> 01:08:33,440
character that is not in your expected range, so in my case, it was between uppercase A and uppercase

1109
01:08:33,440 --> 01:08:41,120
Z, what you do is that you emit a compile error. And you can emit a compile error that says, well,

1110
01:08:41,120 --> 01:08:45,040
you are supposed to give me a uppercase string, and you didn't give me an uppercase string because

1111
01:08:45,040 --> 01:08:50,640
this character is lowercase. You can even be precise and print the string and point out a

1112
01:08:50,640 --> 01:08:54,880
point at the specific character if you want. You can craft the message whichever way you want.

1113
01:08:54,880 --> 01:09:00,640
And that becomes the compile error. And so now, users of your API, not only the constraint is

1114
01:09:00,640 --> 01:09:05,680
enforced, so if they give you a bad string, they will get a compile error. But the compile error

1115
01:09:05,680 --> 01:09:11,600
is also going to be designed by you. So people will get a nice compiler from the compiler that

1116
01:09:11,600 --> 01:09:15,520
will tell them you are supposed to pass an uppercase string, but you didn't.

1117
01:09:16,640 --> 01:09:22,240
Nice. Yeah, so you can start doing bespoke compiler extensions, and you don't have to learn a new

1118
01:09:22,240 --> 01:09:28,480
language to do it. No. That's pretty sweet. Okay. Okay, that gives me a good sense of the

1119
01:09:28,480 --> 01:09:33,360
footprint of the language. So there's one other big topic I think we should talk about,

1120
01:09:34,960 --> 01:09:41,680
which is, I thought it was really interesting the way that the Zig project is funded, right?

1121
01:09:41,680 --> 01:09:47,120
Because every language, particularly in every open source project, has a problem with getting

1122
01:09:47,760 --> 01:09:51,760
enough work done because you've got to give up your day job if you really want a language to

1123
01:09:51,760 --> 01:09:58,320
take off. Yeah. And your approach, Zig's approach to funding is fairly novel. Tell me about that.

1124
01:09:59,200 --> 01:10:07,520
So Zig is a 501c3 non-profit foundation, U.S. non-profit foundation, like 501c3 is a

1125
01:10:08,480 --> 01:10:14,400
thing in the U.S. legal system. It's been kind of set up like a charity.

1126
01:10:14,480 --> 01:10:21,680
Yeah, it's exactly what we normally would consider a charity. So it's tax exempt,

1127
01:10:22,720 --> 01:10:30,320
and you cannot pay dividends. So all the money that goes into the organization has to be used

1128
01:10:30,320 --> 01:10:35,840
to pursue your mission. So basically, you have to use the money to run the company. You can take

1129
01:10:35,840 --> 01:10:44,080
it out and buy a yacht with it or whatever I mentioned. Zig is not the only language that

1130
01:10:44,080 --> 01:10:50,640
has this legal structure. Python, I think, is also another 501c3. But not all languages are that.

1131
01:10:50,640 --> 01:10:55,680
Some other languages are a different type of... It's still considered non-profit, but it's a

1132
01:10:55,680 --> 01:11:02,560
different type of organization and which does have to pay taxes. This is what is... Usually,

1133
01:11:02,560 --> 01:11:08,560
it's 501c6. Like, it might seem that there's not much of a difference between 3 and 6, especially

1134
01:11:08,560 --> 01:11:12,880
because it's a place where we normally, in like, the marketing versioning, we would have like,

1135
01:11:12,880 --> 01:11:19,600
the patch number. So you think, oh, c6c3, whatever, it's like... They fix the bug in there. No,

1136
01:11:19,600 --> 01:11:26,080
that's a huge difference. We're not always consistent with version numbers, but my

1137
01:11:26,080 --> 01:11:29,520
god, lawyers, they can really change the rules between versions.

1138
01:11:32,240 --> 01:11:39,200
So, Zig specifically leaves mainly off of donations. So most of our income comes from

1139
01:11:39,200 --> 01:11:45,760
people donating money to the foundation so that we can move forward with the development of Zig.

1140
01:11:47,360 --> 01:11:53,760
Some money also comes from other things. So it's only... It's mainly donations from individuals.

1141
01:11:53,760 --> 01:11:58,400
We do have also a good number of donations from companies, but I think in terms of like, if we

1142
01:11:58,400 --> 01:12:06,000
were to do a pie chart and plot them both, they would, I think, roughly be balanced. So

1143
01:12:06,800 --> 01:12:14,080
we do try actively to keep a balance between our sources of income, because we don't want to get in

1144
01:12:14,080 --> 01:12:19,440
a situation where like, one entity or like a very small number of individuals end up having control

1145
01:12:19,440 --> 01:12:24,880
basically over the foundation. Maybe not directly, right? Not legally, but if they control the money

1146
01:12:24,880 --> 01:12:31,360
flow, then ultimately they do control the destiny of the organization. And we do want to be able to

1147
01:12:31,360 --> 01:12:39,840
say no to people. We do have support contracts. All right, we have one with Uber, because Uber

1148
01:12:39,840 --> 01:12:50,560
is using Zig to cross compile. They are cross compiling, I think, as of today, all their

1149
01:12:51,520 --> 01:12:58,000
backend services that require cross compilation because of ARM servers, mainly. So like, they

1150
01:12:58,000 --> 01:13:04,720
wanted a while ago to be able to have ARM servers and not just Intel, well, XAD664. And so they use

1151
01:13:04,720 --> 01:13:10,880
Zig. And now they did the work to actually make sure that all their C and C++ stuff

1152
01:13:10,880 --> 01:13:16,800
cross-compiles correctly. And yeah, so they have a support contract with us. But then again,

1153
01:13:16,800 --> 01:13:25,040
it's not a huge chunk of our income. And that is mainly when it comes from income. So

1154
01:13:25,680 --> 01:13:32,320
related to this, also, we kind of want to be independent. And we're very serious about this.

1155
01:13:32,320 --> 01:13:39,760
Like, we used to joke that like the, because, you know, people sometimes say, oh, if you want to,

1156
01:13:40,400 --> 01:13:44,960
if you want this, your language to succeed, like, you cannot make a successful language

1157
01:13:44,960 --> 01:13:50,880
unless you are supported by a big tech company. And we kind of beg to differ, but also

1158
01:13:51,520 --> 01:14:01,840
our standard offer is how much money whatever big tech company wants to give us in exchange for

1159
01:14:01,840 --> 01:14:10,240
0% of the foundation and zero seats in the board of directors. But they do get Zig at the end.

1160
01:14:10,240 --> 01:14:15,200
So they do get something at the end. Yeah, yeah. There is some quid pro quo, but no power.

1161
01:14:15,200 --> 01:14:24,320
No power, no control at all, zero, absolute zero. And because we really want to make sure that we

1162
01:14:24,320 --> 01:14:30,160
like the Zig is a BDFL run project. So also compared to other languages, we basically

1163
01:14:30,160 --> 01:14:36,560
ultimately have Andrew, who is the creator who acts as like the ultimate decision maker. It's

1164
01:14:36,560 --> 01:14:41,840
not only him, there's a core team, there's people, there's a process which is also very public,

1165
01:14:41,840 --> 01:14:47,680
like you can read proposals to change the language on the GitHub. And discussion happens in public,

1166
01:14:47,680 --> 01:14:54,720
and actually anybody can chime in. But for example, it's not a democratic process, like if

1167
01:14:55,440 --> 01:15:01,920
feature proposal has a huge number of outputs that counts zero towards the decision of whether

1168
01:15:01,920 --> 01:15:10,080
to include that feature of or not in Zig. Right. Yeah, that usually that has some downside,

1169
01:15:10,160 --> 01:15:16,880
but usually has great upsides for design consistency. Absolutely. And it's absolutely,

1170
01:15:16,880 --> 01:15:22,800
in my opinion, fundamental, if you want to have your language stay small, if you don't want it to

1171
01:15:22,800 --> 01:15:29,200
eventually devolve into a kitchen sink. Yeah, that's true. And there was a talk by the creator

1172
01:15:29,200 --> 01:15:36,000
of the Elm programming language recently, that I think dove into, dove into this general concept,

1173
01:15:36,000 --> 01:15:40,080
I think in a very nice way. Basically, I'm paraphrasing and I'm going to oversimplify.

1174
01:15:41,200 --> 01:15:47,920
The talk is titled The Economics of Programming Languages, I think. It's from a strange loop,

1175
01:15:47,920 --> 01:15:54,560
and well, it was given a strange loop. I highly recommend it. But the bit that I'm interested

1176
01:15:54,560 --> 01:16:02,240
about was said something along the lines of languages that are like 501c6s, like more

1177
01:16:02,240 --> 01:16:07,680
corporate languages that end up having like a bunch of organizations come together into a kind

1178
01:16:07,680 --> 01:16:17,360
of consortium or like a trade association. They basically look at the language as a marketplace.

1179
01:16:17,360 --> 01:16:24,800
They look at the shared infrastructure and all the commerce, all the commerce, all the business

1180
01:16:24,800 --> 01:16:30,160
that this thing can support. So which is reasonable, right? You look at a language like

1181
01:16:30,160 --> 01:16:35,920
I don't know C sharp or Java, and those languages do enable a certain type of commerce.

1182
01:16:36,720 --> 01:16:42,400
So from their perspective, they want the commerce to be as much as possible. They want to give the

1183
01:16:42,400 --> 01:16:50,080
best market to their organization members. And so if an organization member wants something,

1184
01:16:50,080 --> 01:16:58,000
because it helps them do their business, you have a strong incentive to say yes. And whoever

1185
01:16:58,000 --> 01:17:02,880
doesn't need that feature, they cannot use it. They can disable it. They don't have to use it,

1186
01:17:02,880 --> 01:17:10,560
right? So there's no point in saying no to people if your goal is to enable the have the biggest

1187
01:17:10,560 --> 01:17:18,320
possible market. But as technologies, we know that, well, there's some downsides from that, right?

1188
01:17:18,320 --> 01:17:23,520
Once your language becomes a kitchen sink, then it's like, it's not good over time. So there's

1189
01:17:23,600 --> 01:17:28,720
huge value in keeping your thing small and consistent. And I think that's what you get by

1190
01:17:29,360 --> 01:17:34,720
choosing 501c3 over 501c6, or rather not going down the path of making your

1191
01:17:35,440 --> 01:17:37,440
organization like a trade association.

1192
01:17:38,080 --> 01:17:43,600
Yeah, yeah. It's interesting the thought that that one decision, how you're structured

1193
01:17:44,240 --> 01:17:50,000
as a company, or as a financial organization will influence how you're designed as a language.

1194
01:17:50,720 --> 01:17:59,200
Yeah, it has huge influence. People, programmers, don't want to think about this stuff. They like

1195
01:17:59,200 --> 01:18:05,840
to think, oh, I just want to focus on the code, which is, it's a sentiment that I can understand.

1196
01:18:05,840 --> 01:18:12,160
Frankly, I would like to only focus on the code. But the hard lesson that I learned is that

1197
01:18:13,440 --> 01:18:18,640
to have the best technology, you have to get right the business side. Like the business

1198
01:18:18,720 --> 01:18:22,880
side comes first. Every time you make a mistake there, the technology will suffer.

1199
01:18:24,000 --> 01:18:28,320
It will, in the long run, it really matters. In the short term, it doesn't. The long run,

1200
01:18:28,320 --> 01:18:35,360
it has a huge effect. Yeah, that's true. Okay, well, I'm very glad we diverted into comp time,

1201
01:18:35,360 --> 01:18:41,360
but we should probably wrap up and let the listeners go to run time. How's that for a segue? So

1202
01:18:42,240 --> 01:18:49,920
yeah, if someone wants to get started with ZIG, I know you have LSP support, you have a VS code

1203
01:18:49,920 --> 01:18:54,240
plugin, you've got all the quality of life things for a new beginner, but where should they start

1204
01:18:54,240 --> 01:19:01,280
learning? My recommendation would be go to the official website, ziglang.org, and there there's

1205
01:19:01,280 --> 01:19:08,480
a learn section. The learn section has a guide on how to download ZIG, install it, and it also

1206
01:19:08,480 --> 01:19:14,080
links you to some learning resources. Personally, among those, the two, actually the three main ones

1207
01:19:14,080 --> 01:19:20,160
that I would suggest is, as a starting point, the language reference, the documentation that

1208
01:19:20,160 --> 01:19:24,080
tells you about the language, not the Sunday library. That one teaches you specifically

1209
01:19:24,080 --> 01:19:31,360
about like syntax of the language, and it's one page. It's one long page, like it's not an A4

1210
01:19:31,360 --> 01:19:37,280
or US letter page, but it's like just one page is not huge. And you don't have to read it all

1211
01:19:38,240 --> 01:19:44,560
precisely, you can scroll through it. But that one gives you baseline understanding of ZIG.

1212
01:19:45,440 --> 01:19:50,560
Then from there, I would suggest if you don't have like experience with a lower level programming

1213
01:19:50,560 --> 01:19:57,280
and you want like a very smooth learning curve, ZIG links is the best starting point in my opinion.

1214
01:19:57,280 --> 01:20:02,400
So ZIG links is like a community project where basically you clone the repo and you get a

1215
01:20:02,400 --> 01:20:08,160
collection of very tiny programs that don't compile or that don't behave correctly.

1216
01:20:09,360 --> 01:20:16,240
Yeah. And the comments tell you how to fix them. So you go one by one and you, the comment will go,

1217
01:20:16,240 --> 01:20:20,320
this program is supposed to print all award, but it doesn't fix it. And that's going to be super

1218
01:20:20,320 --> 01:20:25,440
simple, right? You're going to just fix the string literal. But then going forward, the

1219
01:20:25,440 --> 01:20:30,320
exercises will become very smoothly, but they will become harder and they will require you to

1220
01:20:30,320 --> 01:20:32,080
understand more of the syntax.

1221
01:20:32,080 --> 01:20:36,960
You know, I think that's how I learned closure. They had a similar thing called, I think the

1222
01:20:36,960 --> 01:20:43,360
closure cones as like a series of failing, small failing programs that you have to fix

1223
01:20:43,360 --> 01:20:47,280
and you gradually learn the whole language. It's a lovely way to learn a new language.

1224
01:20:47,280 --> 01:20:52,640
Yeah. ZIG links is very, very, very popular. I would say it's probably the most popular

1225
01:20:53,440 --> 01:20:59,120
piece of educational content in the ZIG ecosystem. And the name ZIG links is also inspired by

1226
01:20:59,120 --> 01:21:05,600
Rust links. Because Rust also has it. The same thing. And they call it Rust link.

1227
01:21:06,480 --> 01:21:09,440
Right. Nice. I will link to both of those in the show notes.

1228
01:21:11,120 --> 01:21:18,720
But for now, Loris, thank you very much for joining us. It's a fascinating language with

1229
01:21:20,240 --> 01:21:22,960
almost more scope than C, which I can't believe.

1230
01:21:23,840 --> 01:21:28,320
It has pretty much all the scope of C. It tries to fix all the things that C,

1231
01:21:28,320 --> 01:21:33,440
for some reason, never wanted to fix. Think about it. Why is ZIG able to cross-compile C?

1232
01:21:34,320 --> 01:21:39,600
And a C compiler is not going to be able to give you that out of the box. We didn't get into this,

1233
01:21:39,600 --> 01:21:45,760
but you get a ZIG compiler and you write hello world in C and you can compile it from Linux

1234
01:21:45,760 --> 01:21:49,200
to Windows. Try to do the same with Clang. It's not going to work.

1235
01:21:50,640 --> 01:21:52,080
I'm not even going to try.

1236
01:21:52,080 --> 01:21:58,080
Yeah, but it's insane. So yeah, the scope is all of C. All of the things that C

1237
01:21:58,080 --> 01:22:01,120
should have done that he didn't do. Well, that's a little bit extra.

1238
01:22:02,240 --> 01:22:05,280
Nice. That's enough to keep us busy for a while.

1239
01:22:05,280 --> 01:22:06,080
Yeah.

1240
01:22:06,080 --> 01:22:07,680
Loris, thank you very much for joining us.

1241
01:22:08,320 --> 01:22:08,720
Thank you.

1242
01:22:09,760 --> 01:22:14,480
Thank you, Loris. Since we recorded that conversation, I have been playing around

1243
01:22:14,480 --> 01:22:18,960
with the Zieglings tutorial he mentioned. And yeah, I can confirm it's a nice way to learn.

1244
01:22:19,680 --> 01:22:24,720
I'm also planning to find time to pull out my old Arduino microcontrollers,

1245
01:22:24,720 --> 01:22:29,200
because I've dabbled with kind of embedded hardware in the past. I've never really been

1246
01:22:29,200 --> 01:22:35,360
happy writing C. I've loved using Rust, but it's been a fight to get things to compile

1247
01:22:35,360 --> 01:22:41,120
onto the embedded hardware. So hopefully, Zieg is going to finally make me happy when I'm tinkering

1248
01:22:41,120 --> 01:22:47,680
with soldering irons and wires and LEDs and stuff. In the meantime, I leave you with links to the

1249
01:22:47,680 --> 01:22:51,440
everything we've discussed. They're all in the show notes. There is a wealth of information

1250
01:22:51,520 --> 01:22:56,560
out there about Zieg, how to learn it, what it does, extra features we didn't get a chance to cover.

1251
01:22:57,200 --> 01:23:03,600
And I'll leave you with a funny story. If you install Zieg and type Ziegzen, it will tell you

1252
01:23:03,600 --> 01:23:09,280
why it exists. I'll let you go and discover that. Before you go, please do take the time to give us

1253
01:23:09,280 --> 01:23:15,280
a like or a share or a rate or a review. It is the easiest way to let us know which topics you

1254
01:23:15,280 --> 01:23:20,800
find most interesting so we can do more episodes on those kinds of topics. And if you haven't already,

1255
01:23:20,800 --> 01:23:26,000
click subscribe or follow to catch future episodes. And until the next episode,

1256
01:23:26,000 --> 01:23:31,520
I've been your host, Chris Jenkins. This has been Developer Voices with Loris Crowe. Thanks for listening.

