WEBVTT

00:00.000 --> 00:05.640
One trend we've seen a lot in programming in recent years is the attempt to replace C.

00:05.640 --> 00:09.560
And I think that's both wise and terrifying.

00:09.560 --> 00:12.920
It's wise because C is about 50 years old,

00:12.920 --> 00:19.240
and being old doesn't make it bad, but it has given us five decades to think about what works

00:19.240 --> 00:22.160
and what doesn't work in programming language design.

00:22.160 --> 00:27.120
We've got 50 years worth of techniques we really ought to be putting into practice.

00:27.320 --> 00:32.720
And putting them into practice is the terrifying part, because C is everywhere.

00:32.720 --> 00:38.080
You may not write C, but I guarantee you're writing something that runs on something that runs C

00:38.080 --> 00:39.760
and was written in C.

00:39.760 --> 00:43.840
It's in the compilation stack for everything we install.

00:43.840 --> 00:48.240
So if languages like Go and Rust want to become the new C,

00:48.240 --> 00:51.000
they've really got their work cut out for them.

00:51.000 --> 00:55.680
All of which makes this week's topic kind of breathtaking.

00:55.680 --> 00:57.160
We're looking at ZIG.

00:57.160 --> 01:02.920
It's a language that's not only trying to take on C and C++ and Rust and Go

01:02.920 --> 01:05.800
for that systems programming crown,

01:05.800 --> 01:11.800
it's also trying to replace the infrastructure that C itself gets built on, things like LLVM.

01:11.800 --> 01:19.320
So it can hopefully become the best way to build systems-level software across all different architectures.

01:19.320 --> 01:22.720
ZIG ends up being a project with a huge scope.

01:22.760 --> 01:26.680
And if you're a fan of programming languages, there is a lot to chew on this week.

01:26.680 --> 01:31.520
We cover cross-platform compilation, to memory management techniques,

01:31.520 --> 01:35.560
to new thoughts in compile-time metaprogramming.

01:35.560 --> 01:38.920
As well as when you've got these huge long-term ambitions,

01:38.920 --> 01:43.160
how do you structure an open-source project for long-term funding?

01:43.160 --> 01:47.200
There is a lot of ground to cover, so this is a bit of a longer episode than usual,

01:47.200 --> 01:48.840
and we'd best get started.

01:48.840 --> 01:50.480
I'm your host, Chris Jenkins.

01:50.480 --> 01:54.160
This is Developer Voices, and today's voice is Loris Crowe.

02:07.920 --> 02:09.600
I'm joined today by Loris Crowe.

02:09.600 --> 02:11.160
How are you doing out there, Loris?

02:11.160 --> 02:12.480
Hello, hi, Chris.

02:12.480 --> 02:13.600
Pretty good, thank you.

02:13.600 --> 02:15.360
Good, good. It's good to have you here.

02:15.360 --> 02:17.560
I always love it when we do a language deep dive,

02:17.600 --> 02:20.320
because I'm a particular fan of the world's programming languages.

02:21.320 --> 02:23.440
And you're going to tell us all about ZIG,

02:23.440 --> 02:26.120
which is a language I don't think I've heard of,

02:26.120 --> 02:31.800
until we had Joran Dirk Grief on the show from Tiger Beetle,

02:31.800 --> 02:33.800
who said they've written a new database in ZIG,

02:33.800 --> 02:35.880
and I thought, well, we have to do something about ZIG.

02:35.880 --> 02:37.280
I have to learn about that.

02:38.280 --> 02:40.360
So let's start here.

02:40.360 --> 02:44.800
I always think new programming languages come into being

02:44.800 --> 02:50.320
as a reaction to what's missing in the marketplace, if you like.

02:50.320 --> 02:54.160
Like, there's a burning reason why ZIG needed to exist.

02:54.920 --> 02:56.040
Do you think that's true?

02:56.040 --> 02:57.880
What's ZIG's raison d'Ãªtre?

02:59.640 --> 03:05.880
Right. So I guess a way of answering this question,

03:05.880 --> 03:11.560
like, actually, is maybe to look at how it was created originally.

03:11.560 --> 03:15.080
So the original creator, Andrew Kelly,

03:16.040 --> 03:21.640
wanted to make a digital audio workstation software.

03:22.280 --> 03:24.280
For making electronic music and that kind of thing.

03:24.280 --> 03:25.520
Exactly.

03:25.520 --> 03:28.280
And he tried a bunch of different languages

03:28.280 --> 03:30.760
and he was unhappy with all the solutions,

03:30.760 --> 03:35.200
with all the trade-offs that each offered.

03:35.200 --> 03:38.120
So I think he started with higher level languages

03:38.120 --> 03:41.320
and then quickly found out that to do real-time audio processing,

03:42.440 --> 03:48.920
you can't use a language with automated memory management.

03:48.920 --> 03:52.880
And languages that don't give you precise control over the hardware.

03:53.560 --> 03:54.280
Yeah.

03:54.280 --> 03:57.480
Because audio is one of the places where we're talking hard real-time.

03:57.480 --> 03:58.280
Exactly.

03:58.280 --> 03:58.800
Yeah.

03:58.800 --> 04:00.400
You have to be there on time.

04:02.200 --> 04:02.720
Yeah.

04:02.720 --> 04:06.280
And but on the other end of the spectrum,

04:07.080 --> 04:10.960
at the time, the main languages that did give you

04:11.720 --> 04:14.560
full control over the machine were like C and C++.

04:14.560 --> 04:20.240
And each had its own, like, if you will, baggage of issues,

04:20.240 --> 04:24.480
which some of it is also up to, like, personal taste.

04:25.360 --> 04:28.680
But for example, C is very low level,

04:28.680 --> 04:32.360
but it doesn't have good metaprogramming facilities.

04:32.720 --> 04:37.440
C macros are very well known for being not particularly good.

04:37.880 --> 04:39.240
Yeah.

04:39.240 --> 04:40.040
Yeah.

04:40.120 --> 04:42.240
They're not much better than string mungent, right?

04:42.240 --> 04:43.080
Yeah, exactly.

04:43.080 --> 04:47.840
You mess around with strings and you have a lot of, like, unwanted side effects.

04:48.920 --> 04:49.880
Oftentimes.

04:49.880 --> 04:51.920
So it's a food gun.

04:51.920 --> 04:53.600
That's how we usually think of it.

04:53.600 --> 04:55.280
Yeah, yeah.

04:55.280 --> 04:57.320
On the other hand, you have C++,

04:57.320 --> 05:00.480
which I don't know if he actually did attempt to use,

05:00.480 --> 05:03.840
but in general, C++ exists in a space

05:04.880 --> 05:07.920
where the language is very powerful.

05:07.920 --> 05:09.720
It's very complex.

05:09.760 --> 05:16.600
And it's a type of language where you are heavy with abstractions, oftentimes.

05:17.360 --> 05:21.960
And that kind of detracts from what you're trying to accomplish.

05:22.320 --> 05:26.080
Or rather, some people can definitely make it work for them.

05:26.080 --> 05:28.600
And that is their preferred way of programming.

05:28.600 --> 05:29.720
So that's good.

05:29.720 --> 05:33.160
But for some other people, C++ doesn't really,

05:34.080 --> 05:39.280
you know, it doesn't feel good in your hand as a tool.

05:40.160 --> 05:41.600
For some people.

05:41.600 --> 05:45.840
Yeah, and I can see how people that we're not going to start a language war,

05:45.840 --> 05:49.120
but you can certainly see how people would feel that way about C++.

05:49.280 --> 05:50.040
Absolutely.

05:50.040 --> 05:54.520
And to me, you know, this is not really a thing of language war at all.

05:54.520 --> 06:00.040
Like, I can fully appreciate how somebody who likes that way of doing things

06:00.040 --> 06:02.280
can make it work for them.

06:02.280 --> 06:04.960
And but on the other hand, like, for me personally,

06:04.960 --> 06:07.680
that doesn't that way of doing things doesn't really click.

06:07.800 --> 06:12.480
So ultimately, I can totally see how somebody would be productive

06:12.480 --> 06:14.440
with C++ and I wouldn't.

06:14.440 --> 06:16.560
So I need a different tool.

06:16.560 --> 06:17.440
Right.

06:17.440 --> 06:20.160
And I think that Andrew also shares,

06:21.440 --> 06:22.960
generally speaking, this perspective.

06:22.960 --> 06:26.000
So he wanted to make a language that was

06:27.440 --> 06:29.920
low level, so they gave you full control over the machine

06:30.800 --> 06:33.440
that would be suitable for an audio workstation.

06:34.160 --> 06:39.720
And that, on the other hand, it wouldn't be overly complicated.

06:40.720 --> 06:44.880
And there's like a sentence that you can you can find in

06:46.000 --> 06:49.120
like Ziggs on the website where we say

06:50.440 --> 06:52.880
it's one of the first things that you can see on the front page.

06:52.880 --> 06:55.840
It says focus on debugging your application

06:55.920 --> 06:58.640
rather than debugging your programming language knowledge.

06:59.640 --> 07:01.840
Right. Yeah. Yeah.

07:01.920 --> 07:05.760
OK, so that's kind of I know people.

07:05.760 --> 07:08.480
Anytime you write something that's sort of competing with C

07:08.480 --> 07:12.840
in the low level world, someone says, why not go and why not rust?

07:13.000 --> 07:15.880
But you yeah, you begin to demarcate those as

07:16.880 --> 07:19.080
I'll let you answer it. Why is it not go or rust?

07:21.040 --> 07:25.720
So the reason why it's not rust, I would say is

07:26.200 --> 07:29.920
like the answer is very in a very general way.

07:30.800 --> 07:33.080
It's kind of the same answer as why not C++?

07:33.160 --> 07:37.560
I think that rust is another language that likes its own complexity

07:38.080 --> 07:40.320
and it gives a ton of power from that, for sure.

07:40.960 --> 07:43.280
But but the complexity is there.

07:43.800 --> 07:46.760
And and also

07:48.360 --> 07:52.000
when it comes to like giving you full control over the machine rust,

07:52.040 --> 07:57.440
it's not entirely of that opinion like rust for good reasons,

07:57.440 --> 08:00.240
for for safety reasons, rust wants to.

08:02.640 --> 08:07.040
Religate certain things inside unsafe rust,

08:07.040 --> 08:10.080
which is a part of rust that you are not supposed to use lightly.

08:10.600 --> 08:15.400
So that means that you will find out their libraries that

08:16.480 --> 08:20.280
when choosing between maximum performance in safety,

08:20.600 --> 08:24.480
they will choose safety, probably overperformance, oftentimes,

08:24.480 --> 08:27.240
because you do get audited if you have unsafe or not.

08:27.240 --> 08:31.640
So in general, rust is going for something slightly different

08:31.680 --> 08:33.840
than what Z is going for. OK.

08:34.720 --> 08:37.880
So both in terms of like tradeoffs between performance and safety,

08:37.920 --> 08:42.040
but also in terms of obstruction.

08:42.120 --> 08:46.440
And I would argue also like readability in terms of like the complexity

08:46.720 --> 08:52.000
because writing abstracted code makes it harder to understand and to read for for a consumer.

08:53.000 --> 08:58.320
But when it comes to to go, I think they go and they both share.

08:59.920 --> 09:04.400
An appreciation for simplicity, although go is not just simple,

09:04.400 --> 09:05.800
it's also very minimalistic.

09:07.560 --> 09:11.560
So I would say that there are like some parallels between Z can go,

09:11.800 --> 09:15.080
but we don't have the exact same take on everything.

09:15.080 --> 09:17.040
And I can get more into detail if you want later.

09:17.920 --> 09:26.000
But but ultimately, go is not as low level as rust and Z are.

09:27.000 --> 09:33.040
I am not sure if go would be the best choice for an audio workstation,

09:33.040 --> 09:37.640
for example, or for an operative system, because go has a runtime,

09:37.640 --> 09:39.640
has a garbage collector.

09:39.640 --> 09:44.640
Also, interoperability with C is a bit complicated in go because,

09:44.640 --> 09:47.640
well, first of all, everything, any language that has a runtime

09:47.880 --> 09:51.120
that makes interoperability with C a little bit more complicated

09:51.120 --> 09:57.560
because you need to give information to the runtime of your language

09:57.560 --> 10:00.440
to the garbage collector about what's going on with memory.

10:00.480 --> 10:02.840
And so that sometimes makes things a little bit awkward.

10:03.600 --> 10:06.160
But we go specifically.

10:06.160 --> 10:10.000
I do think that the for the go team, interoperability with C

10:10.360 --> 10:13.520
was never a priority or something that they really liked.

10:13.880 --> 10:18.320
So go can call C functions, for example.

10:19.400 --> 10:21.600
But you cannot do the inverse easily.

10:21.640 --> 10:26.200
So you cannot make a go function that can be easily called from C.

10:26.800 --> 10:31.520
And I think basically this is like a philosophy of the go team.

10:31.520 --> 10:34.360
Like they basically said, no, we want to do something different.

10:34.360 --> 10:35.840
We don't want to do something.

10:35.840 --> 10:39.720
We don't want people to rely too much on like we want to be able to consume

10:39.720 --> 10:42.920
C libraries, but we don't want to do the inverse.

10:43.200 --> 10:44.600
If you're in go land, you just go.

10:44.600 --> 10:46.480
I think that's kind of their philosophy there.

10:46.800 --> 10:50.520
Yeah, yeah, it's like we want to be able to reuse existing C,

10:50.520 --> 10:53.680
but we're not intending to live in the same ecosystem quite.

10:54.240 --> 10:55.640
Yeah, exactly. I would say that.

10:55.640 --> 10:59.280
And you can see that also in a bunch of choices

10:59.280 --> 11:02.440
that they made also with how compilation works in go

11:03.640 --> 11:04.920
like in terms of the compiler.

11:04.920 --> 11:07.360
But I think it's a reasonable choice.

11:07.360 --> 11:11.120
It makes sense, very different from what Zig is going for.

11:11.760 --> 11:14.360
Yeah, there's there's a I don't think we need language wars

11:14.360 --> 11:17.120
because there's a huge design space to be explored.

11:17.120 --> 11:20.160
And there's plenty of there's plenty of land for everyone.

11:20.280 --> 11:21.400
Right. Yeah.

11:21.400 --> 11:24.160
But OK, so that demarks what you want to be.

11:24.160 --> 11:28.640
What's what's Zig's answer to this set of design constraints?

11:30.840 --> 11:33.440
I think that.

11:34.800 --> 11:37.800
I think the most interesting part about the answer to like,

11:37.800 --> 11:40.720
let's say systems programming like lower level programming in general

11:41.360 --> 11:44.640
is to rebuild it from scratch.

11:45.480 --> 11:49.200
All these other languages that I own, not all these other languages,

11:49.200 --> 11:54.400
but like it is common to consider kind of like see the bottom layer

11:54.960 --> 11:56.800
of abstraction of what you're building.

11:56.800 --> 12:00.360
So for example, there are programming languages that compile to C code.

12:00.920 --> 12:03.360
Yeah, I think name is an example of this.

12:04.360 --> 12:09.080
And Rust itself, it doesn't compile to C, but for example,

12:09.080 --> 12:14.160
Rust depends on the C standard library of the platform that you're targeting.

12:14.160 --> 12:18.480
So if you're writing a Linux program, like a Rust program

12:18.480 --> 12:20.520
that you want to deploy on Linux,

12:20.520 --> 12:25.520
Rust will use the libc of your Linux distribution.

12:28.080 --> 12:32.560
With Zig, the idea instead is to really, really build

12:33.120 --> 12:35.200
everything from the bottom up.

12:35.920 --> 12:38.800
And this is a big scope.

12:38.920 --> 12:41.360
This is not like for the faint of heart.

12:42.360 --> 12:46.640
It's a lot of work, but it does yield some very good

12:48.960 --> 12:52.440
results, like some very good things that you can do once you are willing

12:52.440 --> 12:55.960
to do that work. So I would say that the most important

12:55.960 --> 13:00.440
interesting thing about Zig is that it really is a language

13:00.440 --> 13:05.640
that allows you to build for every target from any target,

13:05.960 --> 13:10.840
meaning that if you want to target like not just normal computers,

13:10.840 --> 13:14.400
but also very tiny embedded devices, you can do so easily.

13:14.880 --> 13:18.160
And that's also cross compilation because you're like you're compiling

13:18.160 --> 13:23.120
on a Linux machine, probably, which is going to be maybe X8664

13:23.520 --> 13:27.760
and you're targeting a very tiny ARM V8 embedded device.

13:27.880 --> 13:30.600
So you're compiling for different architecture there.

13:30.800 --> 13:32.800
But this is also true from computer to computer.

13:32.800 --> 13:36.280
So with Zig, it's a very it's considered fundamental,

13:36.280 --> 13:41.240
the ability to build your program for Mac OS Windows Linux

13:41.240 --> 13:43.480
from any of those other RSS.

13:43.480 --> 13:46.600
So from Linux to Windows, from Windows to Mac, etc.

13:46.920 --> 13:48.800
That's surprisingly rare.

13:48.800 --> 13:50.920
Yeah, but a very nice feature.

13:50.920 --> 13:55.240
And it doesn't end here because we can do this for Zig applications.

13:55.320 --> 13:59.200
And to be fair, I think that Go can do it for Go, Rust can do it for Rust,

13:59.480 --> 14:02.120
but they cannot do it for C.

14:02.120 --> 14:04.520
Well, we can do it also for C and C++.

14:04.520 --> 14:09.680
So the idea is that if you have a project that has Zig code in it

14:09.800 --> 14:14.080
and also a C dependency, not only you can cross compile the Zig part,

14:14.080 --> 14:16.520
but you can also cross compile the C part.

14:17.120 --> 14:18.920
Really? Yes.

14:18.920 --> 14:21.480
And that is, I think, the huge thing.

14:21.480 --> 14:28.400
And it's so big that actually you can use Zig as your C C++ compiler

14:29.080 --> 14:32.080
when you are trying to cross compile a Rust,

14:32.280 --> 14:35.920
a mixed project between Rust and C or a Go and C one.

14:35.920 --> 14:40.360
So, for example, Go people have been using the Zig compiler

14:41.080 --> 14:46.000
to enable to complete the close the circle to enable complete cross

14:46.000 --> 14:49.080
compilation of C Go programs.

14:49.280 --> 14:55.000
C Go is basically what you call a project that has both Go and C in it.

14:55.120 --> 14:58.000
C Go is like a component of their of the Go compiler.

14:58.240 --> 15:01.120
That's how they compile in a link to C code.

15:01.600 --> 15:06.520
So, people having using Go projects,

15:06.520 --> 15:09.480
they are using Zig to cross compile and same with Rust.

15:09.680 --> 15:14.680
Even AWS is using Zig to cross compile.

15:15.680 --> 15:18.560
Rust lambdas for their lambda engines

15:18.560 --> 15:22.080
because Rust depends on the libc of the target

15:22.600 --> 15:26.240
and their machines running lambda functions

15:26.920 --> 15:31.920
are running a specific version of Linux with an older libc.

15:32.440 --> 15:35.440
And you need to be able to target the correct version of the libc

15:35.440 --> 15:38.200
to make sure that everything runs smoothly.

15:38.520 --> 15:41.360
Right. And that's not something that normally compilers can do.

15:41.960 --> 15:46.440
And Rust itself, which doesn't concern itself with C compilation at all,

15:47.280 --> 15:48.520
certainly cannot do.

15:48.520 --> 15:52.080
So, they have there's a package called Cargo Zig build

15:52.480 --> 15:55.280
that allows you to use Zig to basically link

15:55.280 --> 15:58.120
against the correct libc version that works on lambda.

15:59.880 --> 16:01.200
How on earth is that working?

16:01.200 --> 16:04.960
Are you telling me that Zig also has a C compiler built in or?

16:05.200 --> 16:06.200
Yeah, it does.

16:07.400 --> 16:08.400
It straight up does.

16:12.360 --> 16:15.480
And Andrew started out trying to build an audio workstation

16:15.480 --> 16:18.520
and ended up building a language that also includes a C compiler.

16:18.840 --> 16:20.840
Yeah, pretty much. That's legendary.

16:20.920 --> 16:26.360
Yeah. And this is like, I would say we're like halfway through the journey

16:26.360 --> 16:29.680
because we want to get even more hardcore than this.

16:29.680 --> 16:32.760
So, I mean, if you want, we can change subject.

16:32.760 --> 16:34.640
Otherwise, I can. No, I'm fascinated.

16:34.640 --> 16:36.600
Keep going. Yeah. OK.

16:36.640 --> 16:42.760
So, do you remember when Apple released the M1 architecture?

16:42.760 --> 16:45.120
Right? Yeah, they went from Intel to ARM.

16:45.920 --> 16:51.240
And that was big news because, well, turned out it's also pretty good CPU,

16:51.240 --> 16:54.680
like pretty good architecture, Numex, I would say are pretty nice from.

16:56.280 --> 16:57.880
Like they're powerful.

16:57.880 --> 17:00.200
They overheat less. It's they're nice.

17:00.400 --> 17:01.400
So.

17:02.400 --> 17:03.720
When it will release the M1,

17:05.160 --> 17:07.840
Zeke was the first compiler

17:08.720 --> 17:14.800
that was able to cross compile for M1 from another target, from another machine.

17:14.840 --> 17:18.960
So, Apple, obviously, when they really well, well, not only when they released,

17:18.960 --> 17:22.080
but also while they were developing the M1, obviously,

17:22.080 --> 17:24.560
they had a tooling to compile for the M1.

17:25.480 --> 17:29.840
But they never released or other when when everything came out,

17:29.920 --> 17:36.880
they had not released any tooling for compiling for M1 from another machine.

17:38.280 --> 17:41.240
So you had to buy the new Mac in order to build for the new Mac?

17:41.320 --> 17:48.080
Exactly, because what you would get was when you have Mac OS, you get clang.

17:48.120 --> 17:52.320
You like you get a fork of LLVM, which is

17:53.280 --> 17:57.560
yeah, it's I would say it's kind of pretty much LLVM, except with like private patches

17:57.560 --> 18:00.280
that Apple makes specific to their system.

18:01.080 --> 18:05.560
And when the M1 came out, they had patches specific to the new architecture.

18:05.560 --> 18:10.480
So you could compile, obviously, from M1 to M1.

18:10.600 --> 18:16.560
But LLVM itself, the open source project, did not support M1 yet fully.

18:16.960 --> 18:21.280
And so you could not get LLVM like on Windows or Linux

18:21.280 --> 18:23.360
and then use that to compile for Mac OS.

18:23.360 --> 18:24.640
We were the first ones.

18:24.680 --> 18:29.280
And that was because not only Zig is a C compiler and to be fair,

18:29.280 --> 18:33.920
the C compiler stuff right now, I would say at its core, it's not super impressive.

18:33.920 --> 18:39.280
The the idea is that Zig uses LLVM and LLVM is like this library that allows you to.

18:40.240 --> 18:47.400
It's like a unified framework for optimizing for generating optimized machine code.

18:47.400 --> 18:53.680
So the idea is that you your compiler reads the program that it's trying to compile

18:54.040 --> 18:56.880
builds a data structure in memory, does semantic analysis,

18:56.880 --> 18:59.000
all the usual stuff that our language has to do.

18:59.000 --> 19:03.720
But then the final step is to give some of that information to LLVM,

19:04.040 --> 19:09.240
which will then take care of selecting which exact instructions

19:10.280 --> 19:13.920
to use for the for the CPU that you're targeting.

19:14.400 --> 19:20.440
Right. So it's I suppose I want to say it's almost a little bit like WebAssembly.

19:20.440 --> 19:25.480
It's like a very low level language is actually going to generate the final machine code.

19:26.480 --> 19:29.800
Yeah, that's a bit of a stretch, but that's I think that's fair.

19:29.800 --> 19:35.640
That's what that's the that's called the LLVM IR intermediate representation.

19:35.640 --> 19:40.360
Yeah, that's what you create, which is a bit code of some kind.

19:40.400 --> 19:45.240
And by code, sorry, of some kind, kind of like a WebAssembly.

19:45.280 --> 19:47.200
I think that's a fair parallel.

19:47.960 --> 19:49.480
OK. Yeah.

19:49.480 --> 19:51.080
So we give that to LLVM.

19:51.080 --> 19:54.760
And since we are already bundling all of LLVM,

19:54.880 --> 20:01.720
it doesn't take much to also add clang, which is the C compiler that runs on LLVM.

20:01.760 --> 20:03.720
So that's what's allowed us to build C.

20:03.720 --> 20:06.720
There's more than it does, but at its core, it's not super complicated.

20:07.760 --> 20:16.600
But but a compiler is just one step necessary to create an final executable.

20:16.640 --> 20:18.880
There's also a linking page at the end.

20:18.880 --> 20:25.280
So the main problem with the new M1 Max was that linking

20:26.760 --> 20:28.520
needed to be different than it was in the past.

20:28.520 --> 20:34.200
And the reason why we were the first ones to be able to cross compile for M1

20:35.720 --> 20:38.440
was because we had our own in-house linker.

20:39.320 --> 20:42.200
There's a core team member in the project.

20:42.640 --> 20:45.960
His name is Jacob Conca, and he used to work in Microsoft.

20:46.080 --> 20:49.920
And we kind of poached him to work.

20:49.960 --> 20:52.200
Well, I guess he poached himself.

20:52.280 --> 20:54.440
He wanted to work on on linkers.

20:55.080 --> 20:59.680
I think at Microsoft, he was not working on anything even remotely as exciting.

21:00.080 --> 21:03.520
And so he decided to jump ship and join the project full time.

21:03.840 --> 21:08.000
So we have our own linker, and most of the work is done by him.

21:09.520 --> 21:14.360
And so that my point here is that by having our own linker,

21:14.800 --> 21:20.640
we were able to reach to to have a feature even faster than LLVM code.

21:21.280 --> 21:25.040
And LLVM is considered in general like a very good project, and it is.

21:25.080 --> 21:26.680
And it is. Yeah.

21:26.680 --> 21:32.080
But by not the point is that we did not consider LLVM the baseline.

21:32.120 --> 21:36.440
We were willing to get past LLVM and do some of that work ourselves.

21:36.880 --> 21:41.120
And now going forward in this ties back to my point that we are only halfway

21:41.160 --> 21:46.760
through our journey now going forward, we plan to make LLVM a completely

21:46.800 --> 21:47.960
optional component.

21:48.080 --> 21:55.440
So that means that we have our own implementation of some of what LLVM does.

21:55.520 --> 21:58.520
So we have what we call them backends.

21:58.520 --> 22:03.560
So we have our own implementation of what reads the internal representation

22:03.720 --> 22:08.440
of the compiler, the internal data structures and the sides, which

22:08.480 --> 22:09.760
instructions to output.

22:11.080 --> 22:14.280
That's a lot of work because you have to build one of those things for each

22:14.600 --> 22:15.960
architecture they want to support.

22:16.000 --> 22:18.160
So you want to support x8664.

22:18.560 --> 22:19.600
That's one implementation.

22:20.000 --> 22:26.600
Arm 32 bit another arm 64 bit x86 like 32 bit x86.

22:26.640 --> 22:27.400
That's another one.

22:28.680 --> 22:29.920
There's more architectures out there.

22:29.920 --> 22:32.240
So for each one, you have to write a specific one.

22:32.240 --> 22:39.480
And then you have to write another bit based on the OS that you're targeting.

22:39.480 --> 22:47.280
So like x86 64 Windows is a little bit different than x86 64 Mac, not in terms

22:47.280 --> 22:51.040
of like the instructions of the program, but like the packaging, like how

22:51.040 --> 22:55.520
an executable is structured all the like surrounding metadata, the frame in a

22:55.520 --> 22:55.960
sense.

22:56.360 --> 22:56.640
Right.

22:56.680 --> 22:56.960
Yeah.

22:57.440 --> 22:58.720
And we're doing it.

22:59.200 --> 23:04.680
Now, the work that we're doing in that regard right now is not to replace

23:04.680 --> 23:06.920
LVM in terms of optimizations.

23:07.320 --> 23:11.520
So the bulk of what LVM does and what it's considered the state of the art

23:11.520 --> 23:12.960
for is optimizations.

23:12.960 --> 23:14.360
We are not doing that yet.

23:14.800 --> 23:19.480
What we're doing right now is basically do the work so that we can have

23:19.800 --> 23:26.000
debug builds, which are not optimized happen without needing LVM at all.

23:27.000 --> 23:29.240
Oh, that's our starting point.

23:29.480 --> 23:36.000
But the plan is going forward to basically have a competing, optimizing

23:36.000 --> 23:36.560
backend.

23:36.920 --> 23:41.080
So you will still be able to use LVM if you want, how it's going to happen

23:41.080 --> 23:42.840
in practice doesn't matter much.

23:42.840 --> 23:47.520
I think it's going to happen that you basically will need to get LVM through

23:47.520 --> 23:48.320
the package manager.

23:48.600 --> 23:53.400
So you will use the package manager to get LVM instead of getting it bundled

23:53.480 --> 23:57.960
in the compiler itself, but then you will be able to get an LVM optimized

23:57.960 --> 23:59.640
final executable regardless.

23:59.680 --> 24:03.840
But we're going to work on our competing version and you will decide

24:03.840 --> 24:04.880
which one you like more.

24:05.400 --> 24:10.280
And over time, if we do a good job, it might even be that our competing

24:10.280 --> 24:15.440
backend becomes compelling enough that people will use that one over LVM.

24:16.240 --> 24:20.880
Crikey, you're not kidding about going all the way down to the lowest level,

24:20.880 --> 24:21.200
right?

24:21.360 --> 24:22.400
Yeah, geez.

24:23.160 --> 24:23.440
Yeah.

24:23.480 --> 24:23.840
Okay.

24:23.840 --> 24:26.600
That's what's your timeline for that?

24:27.640 --> 24:30.680
Ooh, that's got to be a multi-year project, right?

24:30.880 --> 24:31.800
100%.

24:32.160 --> 24:32.920
Yeah, for sure.

24:33.720 --> 24:35.800
Honestly, I don't know what the timeline is going to be.

24:36.160 --> 24:40.640
The reality is that the timeline of these things can vary dramatically,

24:41.240 --> 24:44.560
depending on the amount of talent that you attract.

24:45.720 --> 24:51.960
One thing that the people usually say when we first tell them, yeah,

24:52.480 --> 24:57.320
we want to get rid of LVM, they start by saying, oh, you're insane.

24:57.640 --> 24:58.840
You're never going to be able to do it.

24:58.920 --> 25:01.520
There's a bunch of geniuses that work on LVM.

25:03.200 --> 25:03.560
Fair.

25:04.680 --> 25:05.040
Fine.

25:05.120 --> 25:06.400
Let's assume that that's right.

25:06.400 --> 25:08.640
I mean, I'm sure that the people working on LVM are smart.

25:09.960 --> 25:14.960
But it's not like they are bound by a blood contract to work on LVM.

25:15.840 --> 25:22.200
And if we work on LVM, it's a humongous C++ project that takes forever

25:22.200 --> 25:27.640
to compile and it's in some ways like it's messy.

25:28.440 --> 25:33.720
What if we were to be able to present to people working in that field

25:34.800 --> 25:39.120
another ecosystem where they can research the same exact kind of

25:39.320 --> 25:43.080
of optimizations that they are researching and implementing on LVM.

25:43.920 --> 25:50.560
But the compiler, instead of taking four hours to build, it takes 20 seconds.

25:52.880 --> 25:54.640
I imagine that would be very seductive.

25:54.920 --> 25:58.920
And I think you're deliberately trying to seduce people over to the zig side,

25:59.280 --> 26:00.360
which is fair enough.

26:01.120 --> 26:06.360
And I mean, we already have people in the core team who have pushed access to LVM.

26:07.000 --> 26:12.480
So it's not like we are like, well, I don't know anybody who is part

26:12.520 --> 26:15.840
like the leadership of LVM, so I wouldn't say we are like insiders.

26:17.040 --> 26:21.640
But we already know people who do this.

26:22.000 --> 26:27.600
So there's a, sounds like there's potential for both knowledge sharing

26:27.600 --> 26:29.800
and maybe some more kinds of sharing out there.

26:29.840 --> 26:31.440
Absolutely. And absolutely.

26:31.440 --> 26:35.400
And if LVM also ends up benefiting from this, it's great for everybody.

26:35.800 --> 26:39.120
Sounds like one of those whoever wins, we all win situations.

26:39.200 --> 26:39.840
Absolutely.

26:40.040 --> 26:42.360
OK. This is getting very low level.

26:42.360 --> 26:45.960
Maybe we should try and pull it back into a user space.

26:47.760 --> 26:49.600
Love the ambition, though, absolutely.

26:50.000 --> 26:54.520
But I do want to get a sense of what it's like to write zig.

26:54.560 --> 26:56.760
What am I going to find as a programmer?

26:56.840 --> 26:57.640
What am I going to like?

26:57.640 --> 26:59.200
What am I going to need to learn?

26:59.200 --> 27:00.200
Right. So.

27:03.880 --> 27:07.160
The hardest part about the zig is not the at all.

27:07.240 --> 27:10.360
Zig is a language is very, very simple.

27:10.360 --> 27:14.120
The most complicated part of zig right now is comp time,

27:14.200 --> 27:19.040
which is the ability to run code at compile time instead of runtime.

27:19.840 --> 27:25.160
And if you're not used to thinking about the two different like.

27:27.600 --> 27:31.960
Lifetimes of your program, the two different phases of its life,

27:32.520 --> 27:36.200
then you might get a little bit confused about what it is that you can can do

27:36.200 --> 27:39.240
at comp time or what it is that you cannot do at comp time.

27:39.520 --> 27:43.800
But overall, the core principle is, in my opinion, kind of straightforward

27:44.280 --> 27:48.360
where things get complicated is once you get into

27:48.720 --> 27:50.480
systems programming more in general.

27:50.560 --> 27:54.040
So if you were like a JavaScript or a Python developer

27:54.560 --> 27:57.920
and you never had in your life to think about the stock versus hip,

27:58.200 --> 28:01.120
or maybe people told you, but like if you're a Python programmer,

28:01.240 --> 28:03.440
this is something that also happened to me like in university.

28:05.000 --> 28:08.040
If you do Python and people told you about the stock versus hip,

28:08.080 --> 28:11.520
that's like philosophy to you because that's yeah, right.

28:11.520 --> 28:14.040
You don't have fascinating, but you'll never use this knowledge.

28:14.040 --> 28:15.920
Exactly. Like you don't have control over it.

28:15.920 --> 28:17.320
And yeah.

28:19.760 --> 28:21.720
When you're getting to low level systems program,

28:21.720 --> 28:23.600
suddenly this becomes a real concern, right?

28:23.840 --> 28:28.320
Exactly. And so people, so the hardest part is, for example,

28:28.320 --> 28:34.120
understanding the difference between an array of which of whose length

28:34.320 --> 28:37.680
you know, you know, statically, like this is going to be a six element array

28:37.680 --> 28:41.960
and it's always going to be six or maybe, you know, you need up to six slots.

28:41.960 --> 28:45.000
Maybe at some point in time, you use fewer than those.

28:45.040 --> 28:48.480
So you have like a counter that tells you how many slots you're using,

28:48.880 --> 28:49.840
but six is the limit.

28:49.840 --> 28:52.840
So and if you know this statically at compile time,

28:52.880 --> 28:54.920
then this can be put on the stock.

28:55.880 --> 28:58.760
And there's some things that you can do with this memory

28:59.600 --> 29:04.920
thanks to the knowledge of the fact that it's bounded to six elements.

29:05.000 --> 29:07.280
And you know exactly how much memory it's going to need

29:07.280 --> 29:08.760
for the whole lifetime of the program.

29:08.760 --> 29:12.120
Exactly. And that is critical information for the compiler itself,

29:12.120 --> 29:16.840
like the language, lower level languages are like designed

29:16.840 --> 29:20.800
around these very critical concepts of like what you know statically

29:20.800 --> 29:22.640
and what you do not know statically.

29:22.640 --> 29:25.160
So if, for example, instead, you have a program

29:25.160 --> 29:28.720
where you ask the user to tell you how many items they want to enter

29:28.800 --> 29:31.600
and they are allowed to enter 10,000 if they want,

29:32.080 --> 29:37.080
or more realistically, imagine parsing a JSON file

29:37.160 --> 29:40.840
like a JSON file can be arbitrarily deeply nested

29:40.960 --> 29:42.800
or big in general.

29:42.800 --> 29:48.400
So in that point, you need to concern yourself with heap allocation,

29:49.160 --> 29:51.240
which again is something that in Python and JavaScript

29:51.240 --> 29:55.160
you don't do directly because the runtime manages that for you.

29:55.560 --> 29:58.760
Yeah. So that's one example.

29:58.840 --> 30:03.160
Another example is all things that your platform

30:03.240 --> 30:07.160
like APIs that your OS operative system gives to you,

30:07.840 --> 30:11.800
which people sometimes are used to think about as in terms of capabilities

30:11.800 --> 30:15.240
that the language gives to them, even though the language

30:16.040 --> 30:17.480
can only act as an intermediary.

30:17.480 --> 30:20.200
So for example, sometimes people ask,

30:20.960 --> 30:25.400
how do I get the size of the terminal window in Zig?

30:26.480 --> 30:31.280
And the answer is, well, the question, the real question is,

30:31.400 --> 30:34.800
how does your OS allow you to get that information?

30:35.800 --> 30:36.800
Right.

30:36.800 --> 30:40.680
And then, and that's going to happen through a syscall of some kind.

30:41.040 --> 30:43.920
And then the, I guess the secondary question is,

30:43.920 --> 30:49.120
well, has somebody written the boilerplate to access that syscall

30:49.160 --> 30:51.080
and where is it in the Zig standard library?

30:51.080 --> 30:54.960
So the question of how you do this kind of stuff in Zig

30:54.960 --> 30:57.960
or in each specific language, it's not completely wrong.

30:57.960 --> 30:59.600
It does make sense.

30:59.680 --> 31:05.320
But understanding what is the actual API below you

31:05.800 --> 31:08.680
can be a little bit annoying, especially when the language

31:09.440 --> 31:13.120
wants to show you precisely what that is.

31:13.120 --> 31:17.360
And it's not trying to give you a sugared interface

31:17.360 --> 31:21.920
that is overly simplified, because sometimes you do also get that

31:21.920 --> 31:23.600
in other languages, which might make sense.

31:23.600 --> 31:26.120
Like a higher level programming language, it makes sense that it doesn't

31:26.120 --> 31:30.320
give you necessarily low level access to, like, to everything.

31:32.080 --> 31:33.880
So I would say these are like the biggest challenges.

31:33.880 --> 31:35.960
People need to learn systems programming.

31:35.960 --> 31:38.200
They need to have this mindset where they have to think, OK,

31:38.200 --> 31:41.200
how like for another example, people sometimes ask,

31:41.200 --> 31:43.400
how do I print, call or text in the terminal?

31:43.800 --> 31:45.600
How do you do that in Zig?

31:45.600 --> 31:49.440
And the answer is, Zig doesn't concern itself with this.

31:49.440 --> 31:50.840
Like these are escape codes.

31:50.840 --> 31:55.400
It depends on which terminal you're using and a bunch of other related concerns

31:55.400 --> 31:58.040
that really are pretty much transparent to Zig.

31:59.440 --> 32:00.960
But people don't have this mindset.

32:00.960 --> 32:04.280
So I would say that is the hardest part about learning Zig.

32:04.400 --> 32:09.520
And connected to this, there aren't a lot of good learning materials, in my opinion.

32:11.320 --> 32:16.920
So this sounds like the usual kind of young national language problem

32:17.360 --> 32:19.840
where maybe there isn't a library for everything.

32:19.840 --> 32:22.640
Yes. And there aren't there isn't documentation for everything yet.

32:23.080 --> 32:24.440
Yeah, for sure.

32:24.440 --> 32:29.240
But also, I mean, it's not like Zig has invented systems programming.

32:29.240 --> 32:31.440
So it would be nice, right?

32:31.440 --> 32:36.280
If there was some good piece of like a good book

32:36.280 --> 32:40.360
that taught you the core principles without too much fuss.

32:40.360 --> 32:45.760
And in fact, there are plenty of books that try to teach you these things.

32:45.800 --> 32:49.240
It's just that in my experience, most of those that I've seen,

32:49.280 --> 32:55.600
they tend to conflate C specific stuff with the OS.

32:55.600 --> 32:58.160
So for example, you have this book that it's trying to teach you systems

32:58.160 --> 33:04.680
programming and it starts by telling you about how the C compilation model works

33:05.600 --> 33:09.840
and how that intertwines with like how libraries are

33:11.200 --> 33:13.800
certain files are like laid out in your system.

33:13.800 --> 33:15.400
And this is all real and concrete.

33:15.400 --> 33:19.520
And it was especially real and concrete and concrete like 40 years ago.

33:20.200 --> 33:25.080
But those concepts are like in other things like macros

33:25.080 --> 33:27.800
and where things are usually in the system library.

33:27.800 --> 33:31.840
But those are things that are specific to C.

33:31.840 --> 33:33.600
So if you're not doing C,

33:33.600 --> 33:38.400
a lot of these things are not as timeless as the book thinks they are.

33:38.920 --> 33:42.480
While instead that versus hip, that one is much more timeless.

33:42.520 --> 33:45.720
So personally, I think that we're missing learning materials

33:45.720 --> 33:51.720
that can discern between really timeless systems programming concepts

33:51.720 --> 33:57.800
like stock versus hip versus C isms that are not the relevant anymore.

33:58.800 --> 34:06.080
Yeah, yeah, that's sort of a long life cycle, but not not mathematically pure.

34:06.800 --> 34:08.600
You almost say, yeah, yeah.

34:08.600 --> 34:13.320
OK, but so I would like to talk about how the C interrupt works

34:13.800 --> 34:15.640
and maybe this is the way to do it.

34:15.640 --> 34:20.440
So if I'm if I'm actually looking to get the size of a terminal window,

34:21.080 --> 34:23.360
am I going to go looking for a sysop call and find

34:23.360 --> 34:26.040
I actually have to do it through an OSC library?

34:26.040 --> 34:28.720
And how's that going to play out when I actually start coding?

34:29.680 --> 34:34.680
So, well, I guess it depends on the US.

34:34.720 --> 34:37.280
Let's assume that the US is Linux. OK, for simplicity.

34:38.200 --> 34:41.320
So if the US is Linux, you're in luck

34:42.000 --> 34:47.320
because in Linux, the syscalls are considered a public API of the US.

34:48.120 --> 34:53.240
So you are not forced to use the C library of your OS.

34:53.960 --> 34:56.040
You can invoke the syscalls directly.

34:56.040 --> 34:59.120
And in the case of Ziggs, since we like doing things from scratch,

35:00.880 --> 35:05.400
you will find in the Ziggs library that we do implement the syscall,

35:05.760 --> 35:08.560
which I think it's IOCTL.

35:08.560 --> 35:12.600
This is called that you can use to get that information from the US.

35:12.760 --> 35:17.480
So in the case of Ziggs, so in the case of Linux,

35:18.360 --> 35:22.160
that's how you find that out.

35:22.160 --> 35:27.360
But in other platforms, yes, you would have to use a C lib,

35:27.360 --> 35:29.720
although we do have also bindings to the C lib.

35:29.720 --> 35:35.240
So in practice, you wouldn't have to do everything yourself from scratch.

35:36.400 --> 35:39.000
When it comes to like these very common things,

35:39.000 --> 35:41.600
but let's imagine that instead you want to use like a C library.

35:42.120 --> 35:45.120
OK, let's imagine that you want to use, I don't know, SQLite.

35:46.120 --> 35:50.560
By the way, SQLite is a perfect example of a very popular library used,

35:50.560 --> 35:52.000
for example, by Go.

35:52.000 --> 35:55.400
There's a lot of Go projects that the bundle SQLite,

35:55.760 --> 35:57.160
but SQLite is a C project.

35:57.160 --> 36:02.840
So that's one major use case of people using Ziggs to do cross compilation

36:02.880 --> 36:04.440
when they also want to bundle SQLite.

36:04.440 --> 36:06.880
Anyway, you want to use SQLite.

36:06.880 --> 36:10.200
So at its baseline, here's what you want to do.

36:10.760 --> 36:16.280
You want to the way this stuff works in C is that you have C files

36:16.280 --> 36:19.840
that contain implementations of things and have header files,

36:19.840 --> 36:22.480
which are like files with a dot h extension.

36:23.080 --> 36:24.880
And those files contain definitions.

36:24.880 --> 36:27.320
So they contain they do not contain the full implementation.

36:27.320 --> 36:30.440
They only contain like the signature of a function, for example.

36:30.440 --> 36:32.640
The original kind of API docs, right?

36:32.640 --> 36:35.120
Exactly. The original API docs, like they're there.

36:36.680 --> 36:38.880
What's it called? Is it called Open API, I think?

36:40.440 --> 36:43.120
The thing that used to be called this walker, it's basically like

36:43.400 --> 36:46.240
it's a system to document like a restful API, right?

36:46.360 --> 36:49.000
That's kind of the idea, except systems programming.

36:50.640 --> 36:57.120
Yeah, so the way this works is that then SQLite comes with a bunch of C files

36:57.640 --> 37:01.560
and one header file that you are supposed to include in your project

37:01.600 --> 37:03.880
to get access to the public API.

37:04.560 --> 37:07.200
With ZIG, you can do that directly.

37:07.200 --> 37:13.520
So in ZIG, you can import a C header file and it will work right away.

37:13.600 --> 37:18.120
Like you import that and you immediately get access to all the definitions in there.

37:18.480 --> 37:19.600
Oh, interesting. OK.

37:19.600 --> 37:22.160
So there's no kind of bridging file that you have to write.

37:22.640 --> 37:25.560
Well, the bridging file, in a sense, gets auto-generated.

37:25.680 --> 37:27.240
That's the idea. Right. OK.

37:27.240 --> 37:29.280
So you don't see this.

37:29.360 --> 37:33.200
And actually, if you do want, you can do that manually.

37:33.200 --> 37:36.880
Like you can take the header file, translate it to C definitions.

37:37.840 --> 37:42.000
And in case there's like the need to tweak something manually, you can do that if you want.

37:42.800 --> 37:46.880
But the happy path, like the most common way you will want to do this

37:46.920 --> 37:51.720
is to straight up import the header file and have ZIG do that bridging internally.

37:52.040 --> 37:52.880
OK.

37:54.120 --> 37:59.160
Then at that point, you can just straight up call all the SQLite.

37:59.280 --> 38:00.600
Functions, they are defining there.

38:00.600 --> 38:05.720
So you can you can just like go read the SQLite documentation

38:06.200 --> 38:08.360
and they will tell you called. I'm making this up.

38:08.360 --> 38:14.520
I don't remember how to use SQLite, but there's going to be maybe a test of the SQLite header API syntax.

38:14.520 --> 38:16.200
Don't worry. OK.

38:16.200 --> 38:19.280
So there's going to be some kind of SQLite in it function.

38:19.320 --> 38:21.400
So you just call it and it works.

38:23.480 --> 38:27.600
There's also a couple other things that ZIG does that help you with interoperability with C.

38:27.600 --> 38:31.920
So, for example, C uses non-terminated strings a lot.

38:33.480 --> 38:38.560
So basically, there's a you when you want to give to a function is string,

38:38.560 --> 38:41.400
you give it a pointer to the beginning of the string.

38:41.840 --> 38:44.360
And the pointer doesn't carry information about the length.

38:44.440 --> 38:49.920
The length will be discovered by the function that you're calling by iterating through the sting

38:50.040 --> 38:55.040
to the string until it encounters a zero character once it like a zero byte.

38:55.440 --> 38:57.440
Once you find this, your body knows that the string is over.

38:59.000 --> 39:01.640
Modern languages don't like to do that anymore.

39:01.680 --> 39:05.680
Modern languages very much prefer something else.

39:05.800 --> 39:07.000
I'll tell you my age.

39:07.000 --> 39:09.320
I can remember when we didn't like to do it at the time.

39:11.880 --> 39:15.520
So in ZIG, for example, normally a string,

39:15.600 --> 39:20.360
it's not just a pointer to the beginning of some data without null in the end.

39:20.880 --> 39:26.360
But in ZIG, we use slices, which other languages sometimes call five pointers.

39:26.400 --> 39:32.000
So the tiny what you call the pointer is a pointer, but also a length.

39:32.560 --> 39:34.920
So, yeah, you have both informations.

39:34.920 --> 39:41.160
And to be fair, sometimes in C, you also have APIs that want a length.

39:41.200 --> 39:45.560
No, they don't want to discover a null byte at some point, but they want you to pass in a length.

39:45.600 --> 39:48.960
But those have have always to be two separate arguments,

39:49.000 --> 39:53.240
two separate values that you need to move around in parallel.

39:53.400 --> 39:58.560
Anyway, so how does ZIG help with the interoperability?

39:58.560 --> 40:03.800
Well, string literals in ZIG are null terminated.

40:04.240 --> 40:07.440
So basically, when you write, I don't know, Hello World,

40:08.080 --> 40:12.880
and you want to use that string literal in ZIG, that's going to be a pointer plus a length.

40:13.120 --> 40:15.160
I don't know how long Hello World is.

40:15.160 --> 40:17.520
Ten characters, nine characters, whatever.

40:17.600 --> 40:20.560
Pencil there, you include the traditional exclamation mark at the end.

40:21.160 --> 40:26.440
OK, so you do have this information, but there's also going to be a null byte

40:26.680 --> 40:28.800
past the end of the string.

40:29.560 --> 40:35.080
So you can take a C, a ZIG string literal and pass it to C transparently.

40:35.240 --> 40:37.440
No need to do anything else, and it's always going to work.

40:38.120 --> 40:42.760
And more in general, ZIG does have a bunch of functions in the Sanda library

40:42.760 --> 40:46.960
that allow you to deal with null terminated strings,

40:46.960 --> 40:49.280
which are not the preferred type of string in ZIG.

40:49.280 --> 40:53.040
Like you don't treat strings as null terminated normally, but

40:55.400 --> 40:58.240
null terminated strings are a reality because not only because of C

40:58.240 --> 41:01.600
interoperability, like in terms of SQLite, but also because of C

41:01.600 --> 41:07.760
interoperability with the OS, like OS APIs, the lib C, that's C,

41:07.760 --> 41:11.720
but also the Cs calls often time inherit some C ism,

41:11.720 --> 41:16.800
some like some ways of communicating data that are like mirroring what C does.

41:17.040 --> 41:21.160
Yeah, unsurprisingly, often the OS is written in C.

41:21.400 --> 41:25.000
Exactly, because the OS is written in C, because that's maybe how people used

41:25.000 --> 41:26.120
to do things at the time.

41:26.120 --> 41:27.880
And so these things are still there.

41:28.440 --> 41:29.680
Yeah. Yeah.

41:29.800 --> 41:34.440
And OK, so to conclude, you have string literals.

41:34.480 --> 41:38.480
You have a lot of other like operators in ZIG that you can also use

41:38.480 --> 41:42.840
with C functions very easily, kind of transparently.

41:43.840 --> 41:47.240
But just to name one, I think it's really cool.

41:47.560 --> 41:48.720
You can use defer.

41:48.880 --> 41:54.320
So defer is almost the same concept as goes defer.

41:54.600 --> 41:56.840
There's like some minor differences.

41:57.480 --> 42:00.840
But the idea is that basically if you want to.

42:02.280 --> 42:07.560
Free a resource while when exiting the function, instead of making sure that

42:07.560 --> 42:12.200
you call free or like file close, for example, like the whatever resource

42:12.240 --> 42:15.760
release function you need to call, instead of making sure that you copy,

42:15.760 --> 42:20.280
paste that call at every exit point of your function, what you can do is

42:20.720 --> 42:26.280
on one line, you open a file and on the line below, you defer, close it.

42:27.480 --> 42:29.120
Oh, OK.

42:29.120 --> 42:33.800
Yeah. So you have basically a cleanup that you can put immediately

42:33.800 --> 42:35.680
after the creation of the resource.

42:36.200 --> 42:41.520
And whenever you leave that scope, no matter how you leave it, whenever

42:41.960 --> 42:44.640
you leave that scope, that function will be called.

42:45.720 --> 42:50.560
Yeah, because it's always deeply dissatisfying that you have to you

42:50.560 --> 42:54.840
have to remember to stick the close call or the free up call at the end.

42:54.840 --> 42:58.680
And it just screams this is going to get forgotten one day.

42:58.960 --> 43:00.320
Yeah, absolutely.

43:00.320 --> 43:05.200
So defer saves you from having to be too careful about like branching

43:05.200 --> 43:07.120
paths in your function.

43:07.160 --> 43:11.880
And if you look at it from a maybe it's not as handy as, you know,

43:11.880 --> 43:16.360
what C plus plus can do with the array with the structures that run

43:16.360 --> 43:18.280
automatically, you don't even have to write defer.

43:18.760 --> 43:24.720
But C plus plus destructors only work with C plus plus defer in zig

43:25.120 --> 43:27.680
also can be called on C functions.

43:27.960 --> 43:29.920
It's completely transparent.

43:29.920 --> 43:32.280
So there's this funny end result.

43:32.280 --> 43:39.440
We were basically zig, in a sense, is better at using C libraries than C

43:40.920 --> 43:45.480
because the same cleanup routine in C would require you maybe to even use go

43:45.480 --> 43:50.880
to like it's not uncommon for people to use go to and have like a label

43:50.880 --> 43:53.160
like a section of the function with all the cleanup functions.

43:53.160 --> 43:54.760
But it gets really messy.

43:54.760 --> 44:00.480
Like I don't think I am able to fully convey how messy cleanup can get in C

44:01.160 --> 44:02.640
because it doesn't have the fur.

44:03.160 --> 44:03.880
I can believe.

44:03.880 --> 44:04.960
Yeah, absolutely.

44:05.320 --> 44:06.400
That's interesting.

44:06.560 --> 44:10.760
That's interesting still being in C, but building on it with new syntax.

44:11.800 --> 44:16.360
I have to ask before we leave this particular thread, what about pointers?

44:16.360 --> 44:19.240
The pointer, does pointer arithmetic come into zig?

44:20.800 --> 44:23.120
Pointer arithmetic can come into zig.

44:23.160 --> 44:24.480
By the way, that's a great point.

44:24.480 --> 44:29.360
I was forgetting that's another great improvement over C that also helps

44:29.360 --> 44:30.960
beautifully with interoperability.

44:30.960 --> 44:35.120
So you can do pointer arithmetic in in zig if you want to,

44:35.840 --> 44:40.120
because because that's what the machine allows you to do.

44:40.280 --> 44:43.800
And maybe occasionally some OS API will require you to do so.

44:44.200 --> 44:48.040
But in general, you do not do pointer arithmetic in zig.

44:48.560 --> 44:52.760
And specifically in zig, you cannot do so in the type system.

44:52.800 --> 44:55.920
You are not allowed to do arithmetic on pointers.

44:56.000 --> 45:01.320
What you have to do is take your pointer, convert it to an integer,

45:01.800 --> 45:04.920
which is not like an operation that does anything at runtime.

45:04.920 --> 45:07.800
It's just like a type system thing.

45:07.800 --> 45:10.920
Like you have to be explicit about taking a pointer,

45:12.320 --> 45:16.240
interpreting it as a number, apply the math to the number

45:16.560 --> 45:18.600
and then convert it back to a pointer.

45:18.600 --> 45:22.280
So you can do it if you want, or if you need.

45:22.680 --> 45:25.720
Probably if you need, you shouldn't want the language.

45:25.920 --> 45:28.760
It's not going to make it easy or like very comfortable to you.

45:28.760 --> 45:30.760
There's a little bit of friction introduced there.

45:30.800 --> 45:35.000
And on the flip side, it helps identify very quickly

45:35.400 --> 45:37.760
where these kind of shenanigans are happening.

45:40.200 --> 45:44.960
Right. So it's mainly there for the sake of C interoper,

45:44.960 --> 45:48.720
rather than writing zig day to day.

45:49.120 --> 45:52.840
Exactly. And I mean, we say C interop, but I don't know.

45:52.840 --> 45:56.160
There might be other things out there like I'm thinking of firmwares,

45:56.160 --> 45:59.760
like your programming tiny embedded device, and you need something like this

45:59.760 --> 46:02.560
because of the very low level stuff that you're doing,

46:02.560 --> 46:06.080
which is not really necessarily specific to C anymore.

46:06.600 --> 46:09.120
But it's like low, super low level bit fiddling.

46:09.280 --> 46:11.760
Maybe at that point you need something like this.

46:11.760 --> 46:13.480
But otherwise you normally don't.

46:13.480 --> 46:17.160
And still related to pointers, there's another crucial thing.

46:17.880 --> 46:22.080
Pointers in C are very under specified in the sense

46:22.080 --> 46:26.280
that you see a char star, so you know it's a pointer.

46:26.560 --> 46:29.360
And when you dereference it, you get a character.

46:29.800 --> 46:33.080
But then the question is, can the pointer be null or not?

46:33.240 --> 46:37.400
You don't know. Maybe documentation tells you, but you're not sure normally.

46:38.200 --> 46:42.240
The second question is, OK, I'm getting a character at the end of this pointer.

46:42.960 --> 46:44.600
Assuming it's not null.

46:44.600 --> 46:47.840
Now, is there going to be just one character on the other side?

46:47.880 --> 46:49.480
Or is this like a string?

46:49.480 --> 46:52.000
Is this like expected to have another character afterwards

46:52.000 --> 46:54.080
and another one afterwards until I encounter a null?

46:54.280 --> 46:58.120
Is there going to be a null or am I supposed to know how many items to get

46:58.120 --> 46:59.520
because of another variable?

46:59.520 --> 47:02.400
This is not encoded in a type system at all in ZIG.

47:02.760 --> 47:04.960
All of these are different type of pointers.

47:04.960 --> 47:07.480
So if a pointer can be null, it's an optional pointer.

47:07.640 --> 47:10.120
So we do the thing that all modern languages are doing

47:10.120 --> 47:13.960
where you have the concept of optional and then you need to unwrap the optional.

47:15.080 --> 47:17.160
And we use that to represent null pointers.

47:18.000 --> 47:20.400
But then we have types for.

47:20.400 --> 47:23.480
So you have normal ZIG slices, which are a pointer and in length.

47:24.200 --> 47:27.320
But then you have a C style pointer that can be

47:27.760 --> 47:31.760
that's going to be a pointer either to one item, one specific item.

47:31.760 --> 47:34.800
So you're explicitly saying there's going to be one character, one chart.

47:34.800 --> 47:36.320
Again, not many.

47:36.320 --> 47:40.000
Or there's a syntax for saying, no, this is like a pointer

47:40.000 --> 47:44.160
to a unknown number of characters.

47:44.440 --> 47:46.400
So there's specific syntax and it's going to tell you,

47:46.720 --> 47:48.920
yes, this is a pointer to many items,

47:48.920 --> 47:51.240
but the pointer itself doesn't tell you how many.

47:52.280 --> 47:55.960
And then there's a pointer to an unknown number of characters

47:56.360 --> 47:58.440
with a null terminator at the end.

47:58.440 --> 48:00.360
And this is in the type system.

48:00.360 --> 48:04.360
So, for example, if you by mistake think that

48:05.160 --> 48:09.120
you're trying to create a string off of another string.

48:09.120 --> 48:13.040
And so like you maybe take a tiny slice from the middle of the string

48:13.040 --> 48:15.400
and you try to pass it to another application

48:15.480 --> 48:20.880
and you forget that that API is expecting an alt terminator at the end,

48:20.880 --> 48:24.160
which is not going to be there because you just split off like a tiny

48:24.160 --> 48:26.160
like two characters from the middle of a string, right?

48:26.160 --> 48:28.560
So there's not going to be an alt terminator on the other side.

48:29.000 --> 48:31.920
The Z-type system will tell you, it will give you a compile error

48:31.920 --> 48:35.520
because it will tell you, I'm expecting an alt term into the string.

48:36.040 --> 48:39.840
But the operation that you like,

48:39.840 --> 48:42.280
the slicing operation that you did on the other string

48:42.800 --> 48:44.760
does not yield an alt terminator string.

48:44.800 --> 48:46.880
So you will get a compile error right away

48:46.880 --> 48:49.320
instead of having your program read random garbage

48:49.320 --> 48:52.360
and maybe sometimes crash.

48:53.280 --> 48:54.680
Yeah, yeah.

48:54.680 --> 48:56.960
That's that's one other question I have to ask you then,

48:56.960 --> 49:01.960
because I can see right now this appealing to people that need to use C,

49:02.080 --> 49:07.240
don't want to use C, got into Rust, didn't make friends with the borough checker.

49:07.600 --> 49:08.680
Yeah.

49:08.680 --> 49:12.880
And now have could find ZIG being the ideal place

49:12.880 --> 49:17.160
if I want more type safety around C, particularly around strings.

49:17.560 --> 49:19.800
Yeah. What about memory management?

49:20.320 --> 49:22.400
Because that's the other big sticking point.

49:22.400 --> 49:24.360
Right. Yeah. Agreed.

49:25.840 --> 49:28.800
So in general, so if we want to talk about.

49:30.640 --> 49:33.720
If we want to talk about ergonomics, what I just what I described earlier,

49:33.720 --> 49:37.200
like the first statement that really helps a lot with memory management

49:38.200 --> 49:43.920
because you allocate a resource, defer, free it, and you're good to go.

49:43.920 --> 49:49.400
You need to have an explicit like malloc free call in ZIGLAND.

49:49.680 --> 49:50.600
Exactly.

49:50.600 --> 49:54.720
And to be even more concrete about this,

49:56.120 --> 49:58.720
ZIG does not have a global allocator.

49:59.200 --> 50:03.720
So in C, you have malloc and malloc is like the allocator

50:04.320 --> 50:08.120
and maybe different projects use a different implementation of malloc.

50:08.400 --> 50:12.360
There's like a few competing implementations, but in ZIG libraries,

50:12.360 --> 50:17.000
there's this idea that in C libraries, there's this idea that you have

50:17.760 --> 50:21.520
malloc coming from the ecosystem that allows you to allocate memory

50:21.880 --> 50:26.200
in ZIG allocators are always passed around explicitly.

50:26.760 --> 50:32.240
So if a function wants to allocate, it needs to accept an allocator as input.

50:33.240 --> 50:34.560
Interesting.

50:34.560 --> 50:40.480
Yeah. So this makes it more easy, dramatically, more easy to audit

50:40.480 --> 50:42.520
what it is that's allocating memory or not.

50:42.520 --> 50:46.720
If a function doesn't accept an allocator or a data structure

50:46.720 --> 50:49.680
that bundles the allocator in it, like it's also like, for example,

50:49.680 --> 50:53.480
we have a RayList, which would be like equivalent of a C++ vector.

50:53.840 --> 50:56.000
So like it's a growable array, right?

50:56.000 --> 50:59.160
When you make an array list, you give to it an allocator.

50:59.280 --> 51:01.760
And then when you pass around the array list,

51:01.760 --> 51:03.400
the array list will be able to allocate

51:03.400 --> 51:06.640
because it bundles a reference to the allocator inside of it.

51:08.280 --> 51:09.240
That's for convenience.

51:09.240 --> 51:13.760
But in general, you can very quickly audit

51:13.760 --> 51:15.920
if a function can allocate or not.

51:17.720 --> 51:22.840
Does that help you audit if a function is forgetting to deallocate?

51:24.480 --> 51:26.040
That by itself, no.

51:26.120 --> 51:31.480
What it helps is that the doing that is that the what we call

51:31.480 --> 51:34.200
the general purpose allocator, the main allocator implementation

51:34.200 --> 51:36.160
that you find inside of Z in the standard library.

51:37.160 --> 51:41.400
That allocator in debug mode has leak detection.

51:43.280 --> 51:49.160
So you cannot check statically if all allocator allocations are

51:49.160 --> 51:53.560
afraid or rather you can't unless you're willing to become Rust.

51:53.760 --> 51:54.440
Rust can.

51:55.440 --> 51:58.960
With all the limits, they also have limits on the type of like

51:58.960 --> 52:02.800
memory management strategies that the borrower can understand.

52:02.800 --> 52:03.800
But they can.

52:03.800 --> 52:10.880
We can't, but we can instrument the default allocator with checks

52:10.880 --> 52:13.200
for leaks in the bug builds.

52:13.680 --> 52:18.040
So when you run your tests, basically the allocator will fail

52:18.040 --> 52:21.960
the test if at the end of it you have like still memory allocated.

52:22.960 --> 52:23.480
Okay.

52:23.480 --> 52:26.960
And that's default built in part of the tests we don't have to

52:27.120 --> 52:28.480
specifically instrument.

52:28.760 --> 52:29.200
Exactly.

52:29.200 --> 52:30.240
You don't have to do anything.

52:30.720 --> 52:31.760
Oh, that's nice.

52:32.040 --> 52:39.440
Yeah, there's another angle to this also, which is that it is

52:39.440 --> 52:44.800
correct for programs to want to leak memory occasionally.

52:45.280 --> 52:49.320
In this sense, I'll use the Z compiler itself as an example.

52:49.640 --> 52:56.280
So the Z compiler, when built in the bug mode, we'll make sure

52:56.280 --> 53:02.800
to free everything when built in release mode, it will not free

53:03.360 --> 53:04.360
once it's about to leave.

53:04.360 --> 53:08.320
It will not free memory when it wants it's about to live to close

53:08.440 --> 53:11.000
because the OS will clean up that memory anyway.

53:11.520 --> 53:14.680
And there's no point in freeing every single item that you've

53:14.680 --> 53:16.960
allocated if your program is about to exit.

53:17.680 --> 53:21.360
Like making sure to free tiny things makes perfect sense when

53:21.360 --> 53:23.880
your program is going to use a ton of memory, or it's going to

53:23.880 --> 53:26.320
be super long lived, like otherwise it's going to consume

53:26.320 --> 53:29.480
more and more memory over time until it eats all the available

53:29.480 --> 53:31.200
memory and everything explodes.

53:31.440 --> 53:31.720
Yeah.

53:32.520 --> 53:36.320
But for like, let's say one shot programs, kind of like a

53:36.320 --> 53:39.080
compiler is like you run utility, it runs to the end and then it

53:39.080 --> 53:42.080
closes cleaning stuff up at the end.

53:42.600 --> 53:43.880
It's just wasted time.

53:44.160 --> 53:47.160
So have you ever used like Visual Studio?

53:49.000 --> 53:50.240
Not for so long.

53:50.960 --> 53:51.800
Yeah, I can't believe.

53:52.800 --> 53:56.560
Thankfully, I haven't had to use it in a while now, but a few

53:56.560 --> 53:59.640
years ago, like seven years ago or something, I had to use it

53:59.640 --> 54:00.360
consistently.

54:00.920 --> 54:06.000
And it drives me nuts that when you close it, not only it takes

54:06.000 --> 54:08.440
forever to load, that is already not okay.

54:09.400 --> 54:12.560
But when you close it, it takes forever to close.

54:13.400 --> 54:13.880
Why?

54:13.920 --> 54:15.160
Why is it taking forever to close?

54:15.200 --> 54:19.280
Because as it's closing, it's trying to free and run the

54:19.280 --> 54:23.520
distractors of every single component and sub component and

54:23.520 --> 54:24.480
sub component.

54:24.800 --> 54:27.160
I have a vague memory of doing this with Eclipse and just

54:27.160 --> 54:30.120
getting into the habit of force quitting because who cares?

54:30.400 --> 54:31.760
Exactly, exactly.

54:31.840 --> 54:35.640
And Eclipse is another in Java, I think it's another language

54:35.640 --> 54:40.680
that has distractors and and so kind of makes people want to use

54:40.680 --> 54:41.320
them a lot.

54:41.680 --> 54:45.280
But then there's moments where you actually really in terms of

54:45.280 --> 54:47.600
like functionality that you're offering to the user, you don't

54:47.600 --> 54:48.200
want to do it.

54:48.240 --> 54:50.760
Like you just want to close it right away.

54:51.240 --> 54:57.440
Yeah, so long story short, I made this point because in

54:57.440 --> 55:03.360
reality, it is a legitimate behavior to have the program in

55:03.360 --> 55:07.480
specific circumstances, like memory, if you think about it.

55:07.760 --> 55:10.520
Because like for real, like the user experience would be

55:10.560 --> 55:14.440
generally significantly improved in both Eclipse and Visual

55:14.440 --> 55:17.440
Studio, if the thing just exited right away.

55:17.640 --> 55:23.160
Of course, you do want to have a toggle like a flag that makes

55:23.160 --> 55:27.760
sure you free all the memory cleanly so that you can guarantee

55:27.760 --> 55:29.960
that you do not have unwanted leaks.

55:30.120 --> 55:33.520
Like Visual Studio, for example, is a long running program in

55:33.520 --> 55:33.960
Eclipse.

55:34.280 --> 55:34.480
Yeah.

55:34.760 --> 55:39.680
So they should not be leaking memory in the normal operations.

55:39.720 --> 55:40.840
So it's not.

55:41.320 --> 55:44.640
So you still want to be able to test for that.

55:45.000 --> 55:45.920
There are like two minutes.

55:46.200 --> 55:48.480
There are at least two memory management strategies.

55:48.480 --> 55:50.920
One is be very careful about what you're using because it's a

55:50.920 --> 55:52.040
limited resource.

55:52.280 --> 55:52.600
Yeah.

55:52.880 --> 55:56.200
But for the long run, you know, whatever memory you're using at

55:56.200 --> 55:58.000
the end, you can just drop on the floor.

55:58.240 --> 55:58.560
Right.

55:58.720 --> 55:59.160
Exactly.

55:59.360 --> 56:00.720
Yeah, yeah, that makes perfect sense.

56:01.480 --> 56:04.600
There's one other big thing that you've talked about a little

56:04.600 --> 56:08.280
bit, but I'm tempted to run over our usual time slots.

56:08.280 --> 56:09.600
I'm fascinated by this.

56:09.600 --> 56:10.160
Go for it.

56:10.160 --> 56:12.120
I'm not in a rush, for sure.

56:12.360 --> 56:12.680
Good.

56:13.040 --> 56:16.200
So comp time, you talked a bit about that.

56:16.240 --> 56:20.720
And as an old list programmer, this is a concept that makes sense

56:20.720 --> 56:23.440
to me, but I think it's never really gone mainstream.

56:23.960 --> 56:26.920
So why don't we talk a bit about the separation between runtime

56:26.920 --> 56:29.000
programs and compile time programs?

56:29.560 --> 56:30.080
Sure.

56:30.320 --> 56:30.720
Sure.

56:32.880 --> 56:37.680
So let me tell you about how Zig does this more specifically.

56:39.160 --> 56:45.040
So comp time in Zig is interesting because Zig as a language

56:45.360 --> 56:47.680
doesn't have runtime type information.

56:47.880 --> 56:52.360
So for example, in JavaScript, Python, also in Go, you can ask

56:52.360 --> 56:56.560
questions to the program running at runtime about its types.

56:57.320 --> 57:00.760
C programs, on the other hand, don't have a runtime, and they

57:00.760 --> 57:02.560
don't have runtime type information.

57:02.600 --> 57:05.760
Usually it's not always the case, but usually runtime type

57:05.760 --> 57:10.400
information tends to go hand in hand with an actual runtime of

57:10.400 --> 57:10.960
the language.

57:10.960 --> 57:16.040
So for example, in Python, you can create new types at runtime.

57:16.080 --> 57:17.280
You can do introspection.

57:17.760 --> 57:23.680
And so having a runtime that can yield those dynamic properties to

57:23.760 --> 57:28.640
you usually benefits from having runtime type information.

57:29.640 --> 57:33.760
C doesn't have those facilities because a struct in C at the end

57:33.760 --> 57:36.720
of the day boils down to offsets in memory.

57:37.680 --> 57:43.680
Oh, the struct is, I don't know, 16 bytes long and eight bytes in.

57:44.320 --> 57:46.560
And it contains two fields.

57:46.560 --> 57:49.920
The first field is at offset zero and the other one is at offset

57:49.920 --> 57:51.760
eight, and that's the end of it.

57:51.760 --> 57:53.360
So everything else has disappeared.

57:56.240 --> 58:01.760
But it is useful to be able to inspect types and reason about

58:01.760 --> 58:03.320
types at least statically.

58:03.320 --> 58:04.320
So that's what ZIG does.

58:04.320 --> 58:07.520
ZIG does not give you runtime type information, but it does give

58:07.520 --> 58:09.880
you com time type information.

58:10.200 --> 58:12.840
So you are not allowed, you're not able to create new types at

58:12.840 --> 58:18.720
runtime, but you are able to create new types at compile time by

58:18.720 --> 58:20.320
reasoning on other types.

58:21.040 --> 58:23.680
And the way you reason on other types, and by the way, this is

58:23.680 --> 58:25.600
also what generic does in other languages.

58:25.600 --> 58:30.480
It's just that this is usually done in other imperative languages.

58:30.480 --> 58:34.800
This is usually done with a funky declarative syntax and a bunch

58:34.800 --> 58:38.400
of diamond brackets where you use diamond brackets to denote

58:38.400 --> 58:43.360
like the generic type and then to put constraints on it using

58:43.360 --> 58:45.760
like some kind of declarative syntax.

58:45.760 --> 58:48.560
Like I want type T to be, I don't know.

58:51.280 --> 58:54.560
To conform to interface A or interface B, et cetera.

58:55.360 --> 58:58.480
Okay, so you're using, you're saying you're using com time to do

58:58.480 --> 59:01.600
things like I want a list of As, but now I need to pin it down

59:01.600 --> 59:03.200
to be a list of eight bit integers.

59:03.920 --> 59:04.400
Yeah.

59:04.800 --> 59:05.280
Yeah, okay.

59:06.000 --> 59:10.800
Because you can, because the idea is that you are creating a new

59:10.800 --> 59:15.440
type by referring to another existing types, another existing

59:15.520 --> 59:16.160
type.

59:16.160 --> 59:20.640
And the way you do this in Zig is not via these custom syntax,

59:20.640 --> 59:23.520
but by using normal Zig syntax.

59:23.520 --> 59:27.520
So literally a list, for example, let's say you want to make a generic

59:27.520 --> 59:30.160
list and you want then to be able to make a list of integers,

59:30.160 --> 59:31.520
a list of characters, whatever.

59:32.560 --> 59:35.600
The way you implement this in Zig is that you create a function

59:35.600 --> 59:41.760
called list that accepts a type as input, which has to be marked

59:41.760 --> 59:43.040
as a com time parameter.

59:43.040 --> 59:47.520
So like the signature would literally read fn list, open parentheses,

59:48.160 --> 59:51.120
com time t column type.

59:51.120 --> 59:55.760
So it's a com time parameter named t of type type.

59:55.760 --> 59:57.360
You have to pass in a type.

59:57.360 --> 59:59.680
And so that could be like integer or whatever.

01:00:00.480 --> 01:00:02.720
And then this function returns another type.

01:00:03.600 --> 01:00:07.920
And in the function body, you create a, you create a struct,

01:00:07.920 --> 01:00:11.200
you return a struct definition that places,

01:00:11.200 --> 01:00:14.560
that defines the payload field, like a struct probably that has

01:00:14.560 --> 01:00:18.240
the payload field of type t, what you passed in,

01:00:18.240 --> 01:00:19.520
which is kind of like generic's work.

01:00:20.480 --> 01:00:25.520
But it's normal procedural Zig code that gets executed compile time.

01:00:25.520 --> 01:00:28.480
So for example, you could create like an,

01:00:29.760 --> 01:00:32.880
let's say you're making a simple array, but the length of that array,

01:00:32.880 --> 01:00:36.480
you want to be the result of other reasoning.

01:00:36.480 --> 01:00:40.160
You could create a Fibonacci function, run it at com time,

01:00:40.160 --> 01:00:44.640
and say that your array is long the 10th Fibonacci number,

01:00:45.280 --> 01:00:47.120
which I don't know how much it is, but it's not going to be 10.

01:00:47.120 --> 01:00:48.160
It's going to be a bigger number.

01:00:49.440 --> 01:00:50.080
Right.

01:00:50.080 --> 01:00:53.680
So you can call normal, run normal Z code.

01:00:53.680 --> 01:00:58.480
It's going to be interpreted by the compiler while compiling.

01:00:59.040 --> 01:01:02.240
And usually you do have some of that in other languages.

01:01:02.240 --> 01:01:04.320
It's just not fully general purpose.

01:01:04.320 --> 01:01:07.520
They give you restricted language to specify properties

01:01:07.520 --> 01:01:11.120
and they have their own special rules in Z.

01:01:11.120 --> 01:01:12.960
It's just you run the Z code.

01:01:12.960 --> 01:01:17.680
And the compiler has like a concept of a execution quota.

01:01:17.680 --> 01:01:21.280
So that like, for example, if you make a mistake and you try to make,

01:01:23.440 --> 01:01:28.400
you make an array that is the 1000 Fibonacci number,

01:01:28.400 --> 01:01:30.720
but your Fibonacci implementation is very bad.

01:01:30.720 --> 01:01:32.640
The compiler after a while is going to tell you

01:01:33.600 --> 01:01:35.680
I executed like 10,000 loops.

01:01:36.400 --> 01:01:41.440
And I, and since we couldn't come to a conclusion, I gave up.

01:01:41.440 --> 01:01:45.680
And if you really think this is, this is not like an infinite loop,

01:01:45.680 --> 01:01:47.840
then you can pull up that number,

01:01:47.840 --> 01:01:52.720
like the number of executions before giving up and we're going to try again.

01:01:52.720 --> 01:01:57.280
But so that way basically we, the compiler is how it deals with like infinite loops

01:01:57.280 --> 01:01:58.480
and undecidable stuff.

01:01:59.120 --> 01:02:02.000
Yeah. So you're protecting against people making,

01:02:02.000 --> 01:02:04.160
accidentally making compile time infinitely long.

01:02:04.160 --> 01:02:04.880
Exactly.

01:02:04.880 --> 01:02:06.080
Yeah. Yeah. Yeah.

01:02:06.080 --> 01:02:09.600
And Alan Turing has opinions on why you can't automate that.

01:02:09.600 --> 01:02:10.240
Yeah, exactly.

01:02:10.240 --> 01:02:11.920
So, and you know what?

01:02:11.920 --> 01:02:16.720
In our case, I think it's fine in practice to solve the indecidability problem

01:02:16.720 --> 01:02:20.720
by just giving up because ultimately, like you're trying to compile a program

01:02:20.720 --> 01:02:23.840
and you're not willing to sit there forever

01:02:23.840 --> 01:02:26.240
or up with radical long to have it compile.

01:02:26.240 --> 01:02:27.440
So yeah.

01:02:28.080 --> 01:02:30.560
Okay. So this raises two natural questions.

01:02:30.560 --> 01:02:33.840
And the first has got to be, what's that like as a,

01:02:33.840 --> 01:02:34.800
as a programmer?

01:02:35.360 --> 01:02:40.160
Because most of us are used to using like diamond brackets for generics.

01:02:40.160 --> 01:02:41.520
Do you prefer the zig way?

01:02:41.520 --> 01:02:43.440
Does it feel natural once you get used to it?

01:02:44.000 --> 01:02:46.480
I think it feels insanely natural.

01:02:46.480 --> 01:02:49.520
Like you mentioned earlier, Lisp to me,

01:02:49.520 --> 01:02:51.520
by the way, I also love Lisp.

01:02:51.520 --> 01:02:53.360
I've never used Lisp professionally,

01:02:53.360 --> 01:02:56.880
but like in university, definitely one of my favorite subjects.

01:02:56.880 --> 01:03:02.480
And I also loved writing macros in Lisp.

01:03:03.360 --> 01:03:06.320
And it feels like writing macros in Lisp.

01:03:06.320 --> 01:03:10.560
Or actually, I would say it's even better than writing macros in Lisp.

01:03:11.120 --> 01:03:13.360
Yeah, the spice opinion.

01:03:13.360 --> 01:03:18.960
Well, so what I think happens with Lisp is that people say macros in Lisp are nice

01:03:18.960 --> 01:03:23.280
because Lisp is an almost iconic language.

01:03:23.280 --> 01:03:28.560
So the language itself is the data structure that represents it.

01:03:28.560 --> 01:03:33.440
It's the list, the, well, the symbolic expression that represents it,

01:03:34.560 --> 01:03:35.120
which is fair.

01:03:35.120 --> 01:03:43.920
But I do think that the actual truth is that by having the program be a data structure,

01:03:44.880 --> 01:03:52.320
you are naturally, the language is steering you naturally towards treating

01:03:52.960 --> 01:03:57.760
the program as a data structure instead of it being a textual transformation.

01:03:59.280 --> 01:04:03.360
And in fact, you can write macros in Lisp that don't generalize really well,

01:04:03.360 --> 01:04:09.360
that like make assumptions about a specific like argument being,

01:04:10.240 --> 01:04:13.680
being or not being a list or being or not being quoted, for example.

01:04:14.480 --> 01:04:17.360
In ZIG, you are literally,

01:04:18.480 --> 01:04:22.560
comp time is more limited than what you can do with list macros just to be clear.

01:04:22.560 --> 01:04:24.000
And that's also kind of by design.

01:04:24.000 --> 01:04:26.400
It's kind of like a 80-20 thing.

01:04:26.400 --> 01:04:32.160
Like it gives you 80% of the power, but it saves you from the 20% of really cursed stuff

01:04:32.160 --> 01:04:37.280
that people will want to do all the time or rather with 20% of the complexity,

01:04:37.280 --> 01:04:39.200
which does save you from cursed stuff.

01:04:41.280 --> 01:04:48.240
In ZIG, what you do is like the, when you look at the time, you literally call a function,

01:04:49.120 --> 01:04:53.120
like you call at type info and you pass in a struct.

01:04:53.120 --> 01:04:57.920
So let's say that you made a struct called named person and person has age and name.

01:04:58.880 --> 01:05:03.040
And then you call type info on person and what you get back

01:05:04.240 --> 01:05:10.560
is a data structure that contains, like it's another struct that contains all the info about

01:05:10.560 --> 01:05:17.120
that type. Like among other things, it will contain like an array that contains the two fields

01:05:17.120 --> 01:05:21.840
with information about how the field is called, what's the type, etc., etc.

01:05:22.640 --> 01:05:30.000
And so your metaprogramming is always going to look at the program as data and never as

01:05:30.000 --> 01:05:35.200
syntax. And I think that's the key that makes come time weirdly, weirdly natural.

01:05:36.160 --> 01:05:42.080
Okay, yeah. Yeah, it does remind me, I mean, the frustration with Lisp macros was always

01:05:42.080 --> 01:05:47.040
that they were untyped and you could really cause things to explode in an even more spectacular way

01:05:47.120 --> 01:05:52.960
than normal Lisp. Absolutely. But the nice thing was that there was absolutely no difference between

01:05:52.960 --> 01:05:57.120
writing programs that work to compile time and runtime, because it was the same tools,

01:05:57.120 --> 01:06:03.600
same language, same everything. Exactly. And it's the same for zig. Because you do use the same

01:06:03.600 --> 01:06:11.120
syntax. You like, I have an example on a blog post that I've wrote, trying to introduce people to

01:06:11.120 --> 01:06:18.240
the concept of comp time. And my favorite example in there is this idea that, which is actually

01:06:18.240 --> 01:06:24.720
taken from real life experience. I was writing a Redis client for zig. And in Redis, you have

01:06:25.280 --> 01:06:31.760
commands, like the query language of Redis makes you write commands that are case insensitive.

01:06:31.760 --> 01:06:36.400
So if you write it uppercase or lowercase, it doesn't matter. So at some point in my client,

01:06:36.400 --> 01:06:40.800
I wanted to recognize some of those commands. So I wanted to check for equality between two

01:06:40.800 --> 01:06:50.800
strings. And my idea was, well, to slightly, very slightly improve the performance of the comparison

01:06:50.800 --> 01:06:57.680
function. If I know that the constant string, like the string literal that I hard code in my

01:06:58.720 --> 01:07:03.920
program that I used to check the user provided string against, if I know that that one is always

01:07:03.920 --> 01:07:09.040
going to be uppercase, I can simplify the comparison code ever so slightly. I can just remove one

01:07:09.040 --> 01:07:18.480
branch from the comparison. But now I have, I want to enforce that when you call my equal function,

01:07:19.200 --> 01:07:23.280
you always pass in the first argument, the argument that you're passing,

01:07:24.000 --> 01:07:27.280
like the first argument that you're passing is always going to be uppercase.

01:07:28.480 --> 01:07:32.640
Right. So you want some compile time code to check those strings are correctly written.

01:07:32.640 --> 01:07:39.120
Exactly. Now, imagine trying to do that with diamond brackets stuff. I have no idea if you

01:07:39.120 --> 01:07:44.240
can actually even pull it off. Here's what you do in Zig. In Zig, in the function body,

01:07:45.040 --> 01:07:50.000
you open a comp time block. Well, first of all, you have to mark the first argument as always

01:07:50.000 --> 01:07:54.160
being available at comp time. So people will be forced to give you, it doesn't have to be a string

01:07:54.160 --> 01:08:00.640
literal directly. It can be like a variable name. But ultimately, the value containing that variable

01:08:00.640 --> 01:08:05.760
needs to be resolvable at comp time. It doesn't need to depend on weird stuff like the network.

01:08:10.320 --> 01:08:17.200
So you open a comp time block, and in there, you have a for loop that loops over the string

01:08:17.200 --> 01:08:23.520
and checks that its character is in the correct range. That's it. That's all you do. Nothing

01:08:23.520 --> 01:08:27.200
weird. You just use the language to check the string character by character. And if you find a

01:08:27.200 --> 01:08:33.440
character that is not in your expected range, so in my case, it was between uppercase A and uppercase

01:08:33.440 --> 01:08:41.120
Z, what you do is that you emit a compile error. And you can emit a compile error that says, well,

01:08:41.120 --> 01:08:45.040
you are supposed to give me a uppercase string, and you didn't give me an uppercase string because

01:08:45.040 --> 01:08:50.640
this character is lowercase. You can even be precise and print the string and point out a

01:08:50.640 --> 01:08:54.880
point at the specific character if you want. You can craft the message whichever way you want.

01:08:54.880 --> 01:09:00.640
And that becomes the compile error. And so now, users of your API, not only the constraint is

01:09:00.640 --> 01:09:05.680
enforced, so if they give you a bad string, they will get a compile error. But the compile error

01:09:05.680 --> 01:09:11.600
is also going to be designed by you. So people will get a nice compiler from the compiler that

01:09:11.600 --> 01:09:15.520
will tell them you are supposed to pass an uppercase string, but you didn't.

01:09:16.640 --> 01:09:22.240
Nice. Yeah, so you can start doing bespoke compiler extensions, and you don't have to learn a new

01:09:22.240 --> 01:09:28.480
language to do it. No. That's pretty sweet. Okay. Okay, that gives me a good sense of the

01:09:28.480 --> 01:09:33.360
footprint of the language. So there's one other big topic I think we should talk about,

01:09:34.960 --> 01:09:41.680
which is, I thought it was really interesting the way that the Zig project is funded, right?

01:09:41.680 --> 01:09:47.120
Because every language, particularly in every open source project, has a problem with getting

01:09:47.760 --> 01:09:51.760
enough work done because you've got to give up your day job if you really want a language to

01:09:51.760 --> 01:09:58.320
take off. Yeah. And your approach, Zig's approach to funding is fairly novel. Tell me about that.

01:09:59.200 --> 01:10:07.520
So Zig is a 501c3 non-profit foundation, U.S. non-profit foundation, like 501c3 is a

01:10:08.480 --> 01:10:14.400
thing in the U.S. legal system. It's been kind of set up like a charity.

01:10:14.480 --> 01:10:21.680
Yeah, it's exactly what we normally would consider a charity. So it's tax exempt,

01:10:22.720 --> 01:10:30.320
and you cannot pay dividends. So all the money that goes into the organization has to be used

01:10:30.320 --> 01:10:35.840
to pursue your mission. So basically, you have to use the money to run the company. You can take

01:10:35.840 --> 01:10:44.080
it out and buy a yacht with it or whatever I mentioned. Zig is not the only language that

01:10:44.080 --> 01:10:50.640
has this legal structure. Python, I think, is also another 501c3. But not all languages are that.

01:10:50.640 --> 01:10:55.680
Some other languages are a different type of... It's still considered non-profit, but it's a

01:10:55.680 --> 01:11:02.560
different type of organization and which does have to pay taxes. This is what is... Usually,

01:11:02.560 --> 01:11:08.560
it's 501c6. Like, it might seem that there's not much of a difference between 3 and 6, especially

01:11:08.560 --> 01:11:12.880
because it's a place where we normally, in like, the marketing versioning, we would have like,

01:11:12.880 --> 01:11:19.600
the patch number. So you think, oh, c6c3, whatever, it's like... They fix the bug in there. No,

01:11:19.600 --> 01:11:26.080
that's a huge difference. We're not always consistent with version numbers, but my

01:11:26.080 --> 01:11:29.520
god, lawyers, they can really change the rules between versions.

01:11:32.240 --> 01:11:39.200
So, Zig specifically leaves mainly off of donations. So most of our income comes from

01:11:39.200 --> 01:11:45.760
people donating money to the foundation so that we can move forward with the development of Zig.

01:11:47.360 --> 01:11:53.760
Some money also comes from other things. So it's only... It's mainly donations from individuals.

01:11:53.760 --> 01:11:58.400
We do have also a good number of donations from companies, but I think in terms of like, if we

01:11:58.400 --> 01:12:06.000
were to do a pie chart and plot them both, they would, I think, roughly be balanced. So

01:12:06.800 --> 01:12:14.080
we do try actively to keep a balance between our sources of income, because we don't want to get in

01:12:14.080 --> 01:12:19.440
a situation where like, one entity or like a very small number of individuals end up having control

01:12:19.440 --> 01:12:24.880
basically over the foundation. Maybe not directly, right? Not legally, but if they control the money

01:12:24.880 --> 01:12:31.360
flow, then ultimately they do control the destiny of the organization. And we do want to be able to

01:12:31.360 --> 01:12:39.840
say no to people. We do have support contracts. All right, we have one with Uber, because Uber

01:12:39.840 --> 01:12:50.560
is using Zig to cross compile. They are cross compiling, I think, as of today, all their

01:12:51.520 --> 01:12:58.000
backend services that require cross compilation because of ARM servers, mainly. So like, they

01:12:58.000 --> 01:13:04.720
wanted a while ago to be able to have ARM servers and not just Intel, well, XAD664. And so they use

01:13:04.720 --> 01:13:10.880
Zig. And now they did the work to actually make sure that all their C and C++ stuff

01:13:10.880 --> 01:13:16.800
cross-compiles correctly. And yeah, so they have a support contract with us. But then again,

01:13:16.800 --> 01:13:25.040
it's not a huge chunk of our income. And that is mainly when it comes from income. So

01:13:25.680 --> 01:13:32.320
related to this, also, we kind of want to be independent. And we're very serious about this.

01:13:32.320 --> 01:13:39.760
Like, we used to joke that like the, because, you know, people sometimes say, oh, if you want to,

01:13:40.400 --> 01:13:44.960
if you want this, your language to succeed, like, you cannot make a successful language

01:13:44.960 --> 01:13:50.880
unless you are supported by a big tech company. And we kind of beg to differ, but also

01:13:51.520 --> 01:14:01.840
our standard offer is how much money whatever big tech company wants to give us in exchange for

01:14:01.840 --> 01:14:10.240
0% of the foundation and zero seats in the board of directors. But they do get Zig at the end.

01:14:10.240 --> 01:14:15.200
So they do get something at the end. Yeah, yeah. There is some quid pro quo, but no power.

01:14:15.200 --> 01:14:24.320
No power, no control at all, zero, absolute zero. And because we really want to make sure that we

01:14:24.320 --> 01:14:30.160
like the Zig is a BDFL run project. So also compared to other languages, we basically

01:14:30.160 --> 01:14:36.560
ultimately have Andrew, who is the creator who acts as like the ultimate decision maker. It's

01:14:36.560 --> 01:14:41.840
not only him, there's a core team, there's people, there's a process which is also very public,

01:14:41.840 --> 01:14:47.680
like you can read proposals to change the language on the GitHub. And discussion happens in public,

01:14:47.680 --> 01:14:54.720
and actually anybody can chime in. But for example, it's not a democratic process, like if

01:14:55.440 --> 01:15:01.920
feature proposal has a huge number of outputs that counts zero towards the decision of whether

01:15:01.920 --> 01:15:10.080
to include that feature of or not in Zig. Right. Yeah, that usually that has some downside,

01:15:10.160 --> 01:15:16.880
but usually has great upsides for design consistency. Absolutely. And it's absolutely,

01:15:16.880 --> 01:15:22.800
in my opinion, fundamental, if you want to have your language stay small, if you don't want it to

01:15:22.800 --> 01:15:29.200
eventually devolve into a kitchen sink. Yeah, that's true. And there was a talk by the creator

01:15:29.200 --> 01:15:36.000
of the Elm programming language recently, that I think dove into, dove into this general concept,

01:15:36.000 --> 01:15:40.080
I think in a very nice way. Basically, I'm paraphrasing and I'm going to oversimplify.

01:15:41.200 --> 01:15:47.920
The talk is titled The Economics of Programming Languages, I think. It's from a strange loop,

01:15:47.920 --> 01:15:54.560
and well, it was given a strange loop. I highly recommend it. But the bit that I'm interested

01:15:54.560 --> 01:16:02.240
about was said something along the lines of languages that are like 501c6s, like more

01:16:02.240 --> 01:16:07.680
corporate languages that end up having like a bunch of organizations come together into a kind

01:16:07.680 --> 01:16:17.360
of consortium or like a trade association. They basically look at the language as a marketplace.

01:16:17.360 --> 01:16:24.800
They look at the shared infrastructure and all the commerce, all the commerce, all the business

01:16:24.800 --> 01:16:30.160
that this thing can support. So which is reasonable, right? You look at a language like

01:16:30.160 --> 01:16:35.920
I don't know C sharp or Java, and those languages do enable a certain type of commerce.

01:16:36.720 --> 01:16:42.400
So from their perspective, they want the commerce to be as much as possible. They want to give the

01:16:42.400 --> 01:16:50.080
best market to their organization members. And so if an organization member wants something,

01:16:50.080 --> 01:16:58.000
because it helps them do their business, you have a strong incentive to say yes. And whoever

01:16:58.000 --> 01:17:02.880
doesn't need that feature, they cannot use it. They can disable it. They don't have to use it,

01:17:02.880 --> 01:17:10.560
right? So there's no point in saying no to people if your goal is to enable the have the biggest

01:17:10.560 --> 01:17:18.320
possible market. But as technologies, we know that, well, there's some downsides from that, right?

01:17:18.320 --> 01:17:23.520
Once your language becomes a kitchen sink, then it's like, it's not good over time. So there's

01:17:23.600 --> 01:17:28.720
huge value in keeping your thing small and consistent. And I think that's what you get by

01:17:29.360 --> 01:17:34.720
choosing 501c3 over 501c6, or rather not going down the path of making your

01:17:35.440 --> 01:17:37.440
organization like a trade association.

01:17:38.080 --> 01:17:43.600
Yeah, yeah. It's interesting the thought that that one decision, how you're structured

01:17:44.240 --> 01:17:50.000
as a company, or as a financial organization will influence how you're designed as a language.

01:17:50.720 --> 01:17:59.200
Yeah, it has huge influence. People, programmers, don't want to think about this stuff. They like

01:17:59.200 --> 01:18:05.840
to think, oh, I just want to focus on the code, which is, it's a sentiment that I can understand.

01:18:05.840 --> 01:18:12.160
Frankly, I would like to only focus on the code. But the hard lesson that I learned is that

01:18:13.440 --> 01:18:18.640
to have the best technology, you have to get right the business side. Like the business

01:18:18.720 --> 01:18:22.880
side comes first. Every time you make a mistake there, the technology will suffer.

01:18:24.000 --> 01:18:28.320
It will, in the long run, it really matters. In the short term, it doesn't. The long run,

01:18:28.320 --> 01:18:35.360
it has a huge effect. Yeah, that's true. Okay, well, I'm very glad we diverted into comp time,

01:18:35.360 --> 01:18:41.360
but we should probably wrap up and let the listeners go to run time. How's that for a segue? So

01:18:42.240 --> 01:18:49.920
yeah, if someone wants to get started with ZIG, I know you have LSP support, you have a VS code

01:18:49.920 --> 01:18:54.240
plugin, you've got all the quality of life things for a new beginner, but where should they start

01:18:54.240 --> 01:19:01.280
learning? My recommendation would be go to the official website, ziglang.org, and there there's

01:19:01.280 --> 01:19:08.480
a learn section. The learn section has a guide on how to download ZIG, install it, and it also

01:19:08.480 --> 01:19:14.080
links you to some learning resources. Personally, among those, the two, actually the three main ones

01:19:14.080 --> 01:19:20.160
that I would suggest is, as a starting point, the language reference, the documentation that

01:19:20.160 --> 01:19:24.080
tells you about the language, not the Sunday library. That one teaches you specifically

01:19:24.080 --> 01:19:31.360
about like syntax of the language, and it's one page. It's one long page, like it's not an A4

01:19:31.360 --> 01:19:37.280
or US letter page, but it's like just one page is not huge. And you don't have to read it all

01:19:38.240 --> 01:19:44.560
precisely, you can scroll through it. But that one gives you baseline understanding of ZIG.

01:19:45.440 --> 01:19:50.560
Then from there, I would suggest if you don't have like experience with a lower level programming

01:19:50.560 --> 01:19:57.280
and you want like a very smooth learning curve, ZIG links is the best starting point in my opinion.

01:19:57.280 --> 01:20:02.400
So ZIG links is like a community project where basically you clone the repo and you get a

01:20:02.400 --> 01:20:08.160
collection of very tiny programs that don't compile or that don't behave correctly.

01:20:09.360 --> 01:20:16.240
Yeah. And the comments tell you how to fix them. So you go one by one and you, the comment will go,

01:20:16.240 --> 01:20:20.320
this program is supposed to print all award, but it doesn't fix it. And that's going to be super

01:20:20.320 --> 01:20:25.440
simple, right? You're going to just fix the string literal. But then going forward, the

01:20:25.440 --> 01:20:30.320
exercises will become very smoothly, but they will become harder and they will require you to

01:20:30.320 --> 01:20:32.080
understand more of the syntax.

01:20:32.080 --> 01:20:36.960
You know, I think that's how I learned closure. They had a similar thing called, I think the

01:20:36.960 --> 01:20:43.360
closure cones as like a series of failing, small failing programs that you have to fix

01:20:43.360 --> 01:20:47.280
and you gradually learn the whole language. It's a lovely way to learn a new language.

01:20:47.280 --> 01:20:52.640
Yeah. ZIG links is very, very, very popular. I would say it's probably the most popular

01:20:53.440 --> 01:20:59.120
piece of educational content in the ZIG ecosystem. And the name ZIG links is also inspired by

01:20:59.120 --> 01:21:05.600
Rust links. Because Rust also has it. The same thing. And they call it Rust link.

01:21:06.480 --> 01:21:09.440
Right. Nice. I will link to both of those in the show notes.

01:21:11.120 --> 01:21:18.720
But for now, Loris, thank you very much for joining us. It's a fascinating language with

01:21:20.240 --> 01:21:22.960
almost more scope than C, which I can't believe.

01:21:23.840 --> 01:21:28.320
It has pretty much all the scope of C. It tries to fix all the things that C,

01:21:28.320 --> 01:21:33.440
for some reason, never wanted to fix. Think about it. Why is ZIG able to cross-compile C?

01:21:34.320 --> 01:21:39.600
And a C compiler is not going to be able to give you that out of the box. We didn't get into this,

01:21:39.600 --> 01:21:45.760
but you get a ZIG compiler and you write hello world in C and you can compile it from Linux

01:21:45.760 --> 01:21:49.200
to Windows. Try to do the same with Clang. It's not going to work.

01:21:50.640 --> 01:21:52.080
I'm not even going to try.

01:21:52.080 --> 01:21:58.080
Yeah, but it's insane. So yeah, the scope is all of C. All of the things that C

01:21:58.080 --> 01:22:01.120
should have done that he didn't do. Well, that's a little bit extra.

01:22:02.240 --> 01:22:05.280
Nice. That's enough to keep us busy for a while.

01:22:05.280 --> 01:22:06.080
Yeah.

01:22:06.080 --> 01:22:07.680
Loris, thank you very much for joining us.

01:22:08.320 --> 01:22:08.720
Thank you.

01:22:09.760 --> 01:22:14.480
Thank you, Loris. Since we recorded that conversation, I have been playing around

01:22:14.480 --> 01:22:18.960
with the Zieglings tutorial he mentioned. And yeah, I can confirm it's a nice way to learn.

01:22:19.680 --> 01:22:24.720
I'm also planning to find time to pull out my old Arduino microcontrollers,

01:22:24.720 --> 01:22:29.200
because I've dabbled with kind of embedded hardware in the past. I've never really been

01:22:29.200 --> 01:22:35.360
happy writing C. I've loved using Rust, but it's been a fight to get things to compile

01:22:35.360 --> 01:22:41.120
onto the embedded hardware. So hopefully, Zieg is going to finally make me happy when I'm tinkering

01:22:41.120 --> 01:22:47.680
with soldering irons and wires and LEDs and stuff. In the meantime, I leave you with links to the

01:22:47.680 --> 01:22:51.440
everything we've discussed. They're all in the show notes. There is a wealth of information

01:22:51.520 --> 01:22:56.560
out there about Zieg, how to learn it, what it does, extra features we didn't get a chance to cover.

01:22:57.200 --> 01:23:03.600
And I'll leave you with a funny story. If you install Zieg and type Ziegzen, it will tell you

01:23:03.600 --> 01:23:09.280
why it exists. I'll let you go and discover that. Before you go, please do take the time to give us

01:23:09.280 --> 01:23:15.280
a like or a share or a rate or a review. It is the easiest way to let us know which topics you

01:23:15.280 --> 01:23:20.800
find most interesting so we can do more episodes on those kinds of topics. And if you haven't already,

01:23:20.800 --> 01:23:26.000
click subscribe or follow to catch future episodes. And until the next episode,

01:23:26.000 --> 01:23:31.520
I've been your host, Chris Jenkins. This has been Developer Voices with Loris Crowe. Thanks for listening.

