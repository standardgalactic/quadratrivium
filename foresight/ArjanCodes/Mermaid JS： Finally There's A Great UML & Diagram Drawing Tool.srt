1
00:00:00,000 --> 00:00:04,500
UML diagrams are pretty useful for visualizing aspects of your code.

2
00:00:04,500 --> 00:00:11,000
Float your hearts for visualizing user interactions, class diagrams to explain the structure of your code, and so on.

3
00:00:11,000 --> 00:00:13,300
The problem is, they're painted draw.

4
00:00:13,300 --> 00:00:20,000
I don't like using these generic drawing tools where you have to choose between millions of different arrows to find the right one.

5
00:00:20,000 --> 00:00:28,000
And when you draw a box and you have an arrow that you think is attached to it, but then you move the box and the arrow doesn't move along, it's just really frustrating.

6
00:00:28,000 --> 00:00:31,500
And for this reason, I've not been using UML diagrams very much.

7
00:00:31,500 --> 00:00:36,000
But recently, I discovered a tool called Mermaid that I think is going to change this.

8
00:00:36,000 --> 00:00:43,000
So in today's video, I'm going to talk about four types of diagrams that I think are very useful for illustrating your design.

9
00:00:43,000 --> 00:00:48,500
And then I'm going to show you how to draw them very quickly in Mermaid without all of the frustrations.

10
00:00:48,500 --> 00:00:51,500
Now, before we start, I have something for you.

11
00:00:51,500 --> 00:00:56,500
It's a free guide that's available at ariancodes.com slash design guide.

12
00:00:56,500 --> 00:01:01,500
It contains the seven steps that I take when I design software from scratch.

13
00:01:01,500 --> 00:01:05,500
So I hope that ultimately this is going to help you make better design decisions.

14
00:01:05,500 --> 00:01:08,500
So ariancodes.com slash design guide.

15
00:01:08,500 --> 00:01:11,500
I've also put the link in the description of this video.

16
00:01:11,500 --> 00:01:13,500
Now, let's dive into UML.

17
00:01:13,500 --> 00:01:16,500
When you install VS Coding, you start editing markdown files.

18
00:01:16,500 --> 00:01:19,000
Mermaid is not supported out of the box.

19
00:01:19,000 --> 00:01:23,500
For example, here I can open the preview of this particular markdown file.

20
00:01:23,500 --> 00:01:27,500
And if I try to add some mermaid code to this like so,

21
00:01:27,500 --> 00:01:32,500
and let's say we want to add a simple flowchart like this,

22
00:01:32,500 --> 00:01:36,000
I'll talk more about the exact syntax later on the video.

23
00:01:36,000 --> 00:01:39,000
So I see it simply displays the text right now.

24
00:01:39,000 --> 00:01:42,500
In order for this to actually display the mermaid rendered chart,

25
00:01:42,500 --> 00:01:45,000
we need to install plugin in VS Code.

26
00:01:45,000 --> 00:01:50,500
And the one I'm using is, I'll scroll down here, is called markdown preview mermaid support.

27
00:01:50,500 --> 00:01:52,500
Let me close this preview here.

28
00:01:52,500 --> 00:01:55,500
I've disabled it now to show you what happens if you don't install this.

29
00:01:55,500 --> 00:01:59,500
But if I enable this and now I go back to the markdown file,

30
00:01:59,500 --> 00:02:01,500
let me open the preview again.

31
00:02:01,500 --> 00:02:04,000
Now you see we get the actual mermaid diagram.

32
00:02:04,000 --> 00:02:06,500
The problem with using mermaid in VS Code in this way

33
00:02:06,500 --> 00:02:10,000
is that there's no easy way to export this to a PDF.

34
00:02:10,000 --> 00:02:13,500
There is an extension that allows you to export these previews as PDFs,

35
00:02:13,500 --> 00:02:16,000
but unfortunately it doesn't work with mermaid.

36
00:02:16,000 --> 00:02:21,000
If you want to be able to export these diagrams as PDF files or images or whatever,

37
00:02:21,000 --> 00:02:25,500
then you can actually use mermaid.live and that's this site.

38
00:02:25,500 --> 00:02:29,500
And there you can basically edit your mermaid code right here.

39
00:02:29,500 --> 00:02:32,500
Then it's going to create the diagram right here.

40
00:02:32,500 --> 00:02:35,500
And then they have a couple of these export options.

41
00:02:35,500 --> 00:02:37,500
You even have different themes.

42
00:02:37,500 --> 00:02:40,500
So this is the default dark theme that I can change it to.

43
00:02:40,500 --> 00:02:41,500
Well, let's see cupcake.

44
00:02:41,500 --> 00:02:43,500
That sounds happy cupcake.

45
00:02:43,500 --> 00:02:45,500
Ooh, I'm not sure I like that.

46
00:02:45,500 --> 00:02:49,500
There is corporate for the, you know, serious diagramming needs.

47
00:02:49,500 --> 00:02:52,000
We have a couple of our valentines.

48
00:02:52,000 --> 00:02:53,000
Oh, that's nice.

49
00:02:53,000 --> 00:02:54,000
That's soon.

50
00:02:54,000 --> 00:02:57,000
Actually, I should get something for my wife.

51
00:02:57,000 --> 00:02:58,000
There's a couple more here.

52
00:02:58,000 --> 00:03:01,000
We have black, which is just simple black and white.

53
00:03:01,000 --> 00:03:02,000
There's wireframe.

54
00:03:02,000 --> 00:03:04,000
Oh my, is this comic sans?

55
00:03:04,000 --> 00:03:06,000
I think it's comic sans.

56
00:03:06,000 --> 00:03:07,000
Okay.

57
00:03:07,000 --> 00:03:08,000
I have to get out of here.

58
00:03:08,000 --> 00:03:09,000
Okay.

59
00:03:09,000 --> 00:03:10,000
Close call.

60
00:03:10,000 --> 00:03:11,000
All right.

61
00:03:11,000 --> 00:03:12,000
So this is not an alternative.

62
00:03:12,000 --> 00:03:16,000
So you can write your mermaid diagrams here and then you can simply export it as PNG

63
00:03:16,000 --> 00:03:19,500
or SVG or I don't know what this is.

64
00:03:19,500 --> 00:03:20,500
Some other format.

65
00:03:20,500 --> 00:03:25,500
But the reason I like to do it in VS code is that I can integrate these diagrams directly

66
00:03:25,500 --> 00:03:27,500
within my markdown files.

67
00:03:27,500 --> 00:03:32,500
So for example, if I write a feature document where I want to talk about a new feature in

68
00:03:32,500 --> 00:03:36,500
our platform in my company, then, you know, I write it down here.

69
00:03:36,500 --> 00:03:42,500
I can add some diagrams to clarify things and it all works in a simple text format,

70
00:03:42,500 --> 00:03:43,500
which I really like.

71
00:03:44,000 --> 00:03:49,000
So I want to go through a couple of options in mermaids and show you a couple of things

72
00:03:49,000 --> 00:03:50,000
that you can do with it.

73
00:03:50,000 --> 00:03:56,000
And it can do lots of different things, lots of different types of charts and diagrams.

74
00:03:56,000 --> 00:03:59,000
But there are a couple that I find particularly useful.

75
00:03:59,000 --> 00:04:02,000
And the first one that I want to talk about is the flow chart.

76
00:04:02,000 --> 00:04:05,000
And you already see an example of the flow chart right here.

77
00:04:05,000 --> 00:04:09,500
So flow chart is basically used for modeling flows.

78
00:04:09,500 --> 00:04:15,000
It's often useful if you want to model, let's say the way that a user interacts with your

79
00:04:15,000 --> 00:04:21,000
application, and you can identify the various paths through the flow that the user is taking.

80
00:04:21,000 --> 00:04:26,000
So for example, what you could do, let's say we create a flow chart like this, you can

81
00:04:26,000 --> 00:04:30,500
now add different blocks in here with arrows between them and that then models the flow

82
00:04:30,500 --> 00:04:35,500
or the path that the user takes flow chart also has some options to control the way that

83
00:04:35,500 --> 00:04:36,500
it looks.

84
00:04:36,500 --> 00:04:40,500
So we're going from top to bottom, but you can create a flow chart that goes from left

85
00:04:40,500 --> 00:04:41,500
to right.

86
00:04:41,500 --> 00:04:45,500
So it's really easy just change it in text and it updates the diagram on the right or

87
00:04:45,500 --> 00:04:47,500
bottom to top if you want that.

88
00:04:47,500 --> 00:04:51,500
So there's a couple of different options here that you can use.

89
00:04:51,500 --> 00:04:54,000
So let's stay with the default one.

90
00:04:54,000 --> 00:04:58,500
And this is the basic way that you describe a piece of the flow.

91
00:04:58,500 --> 00:04:59,500
And you can add more of these.

92
00:04:59,500 --> 00:05:01,500
For example, I could also add a second one.

93
00:05:01,500 --> 00:05:06,500
Say we have a start block and that goes to a like so.

94
00:05:06,500 --> 00:05:10,500
You can also put semicolons behind them if you feel so inclined.

95
00:05:10,500 --> 00:05:13,000
These are the names of these different blocks.

96
00:05:13,000 --> 00:05:18,000
You can actually also change the label on it because now it simply shows the name and

97
00:05:18,000 --> 00:05:20,000
S doesn't really tell us very much.

98
00:05:20,000 --> 00:05:24,500
So one thing you can do is simply rename the block to something like start.

99
00:05:24,500 --> 00:05:28,000
But what you can also do is add a separate label like so.

100
00:05:28,000 --> 00:05:33,000
And then you refer to this block in other parts of your flow charts by using the S

101
00:05:33,000 --> 00:05:34,000
character.

102
00:05:34,000 --> 00:05:36,500
But then this is the label that's displayed in the block itself.

103
00:05:36,500 --> 00:05:38,000
It's what you see right here.

104
00:05:38,000 --> 00:05:39,000
So we have no flow chart.

105
00:05:39,000 --> 00:05:40,500
It goes from start to A.

106
00:05:40,500 --> 00:05:42,500
Let's say we model a login flow.

107
00:05:42,500 --> 00:05:47,500
So A is enter your email address, right?

108
00:05:47,500 --> 00:05:49,500
And then it goes to B.

109
00:05:49,500 --> 00:05:52,500
There's different ways in which you can display these blocks.

110
00:05:52,500 --> 00:05:55,000
So here I'm using square brackets.

111
00:05:55,000 --> 00:05:58,000
So that gives me this basically quite boring rectangle.

112
00:05:58,000 --> 00:06:01,000
But you can also add rounded corners like so.

113
00:06:01,000 --> 00:06:03,500
And now this block has rounded corners.

114
00:06:03,500 --> 00:06:06,500
I like using this for most of the blocks in my flow charts.

115
00:06:06,500 --> 00:06:08,000
And then it goes to B.

116
00:06:08,000 --> 00:06:12,000
And let's say B is a check whether the user already exists or not.

117
00:06:12,000 --> 00:06:19,000
And by using the braces like so, you can create this kind of diamond shape.

118
00:06:19,000 --> 00:06:20,500
And this is often used for choice.

119
00:06:20,500 --> 00:06:22,000
Like is this an existing user?

120
00:06:22,000 --> 00:06:24,000
We can add a question mark here.

121
00:06:24,000 --> 00:06:27,500
And now we can split the flow into a yes case and a no case.

122
00:06:27,500 --> 00:06:30,500
So let's say it's not an existing user.

123
00:06:30,500 --> 00:06:38,000
So then we need to go to a C state, which is enter name like so.

124
00:06:38,000 --> 00:06:41,500
And I have to make this a bit smaller so we can actually see what's happening.

125
00:06:41,500 --> 00:06:42,500
So like this.

126
00:06:42,500 --> 00:06:47,500
And of course, we now need to put a label on top of this arrow to indicate that this is a no case.

127
00:06:47,500 --> 00:06:52,500
And that you can do by adding no behind the arrow like so.

128
00:06:52,500 --> 00:06:54,500
So I write no here.

129
00:06:54,500 --> 00:06:56,500
Now you see the arrow gets a label no.

130
00:06:56,500 --> 00:06:59,500
So if it's not an existing user, we've asked for the username.

131
00:06:59,500 --> 00:07:01,500
Then we can continue the flow.

132
00:07:01,500 --> 00:07:09,500
So we go from C to D and we want the user to accept the conditions.

133
00:07:09,500 --> 00:07:12,500
So that's another choice block like this.

134
00:07:12,500 --> 00:07:16,500
And then if the user says no.

135
00:07:16,500 --> 00:07:18,500
So then this is basically what you get.

136
00:07:18,500 --> 00:07:21,500
Let me make that again a bit smaller so we can see what's happening.

137
00:07:21,500 --> 00:07:27,500
Or perhaps I could change this to a left to right flow chart and that will be a bit easier to see like so.

138
00:07:27,500 --> 00:07:29,500
So enter email address is an existing user.

139
00:07:29,500 --> 00:07:32,500
No, then we enter the name, we accept the conditions.

140
00:07:32,500 --> 00:07:34,500
No, we go back to enter your email address.

141
00:07:34,500 --> 00:07:40,500
If you do yes.

142
00:07:40,500 --> 00:07:45,500
Then we can go to the end state and let's put a label ends over there like so.

143
00:07:45,500 --> 00:07:54,500
And what we do in the end state is send email with a magic link, right?

144
00:07:54,500 --> 00:07:58,500
And then the user can use that magic link to log in like so.

145
00:07:58,500 --> 00:08:04,500
And then there's a couple of other cases like what happens if it is already an existing user.

146
00:08:04,500 --> 00:08:09,500
So if the case here was yes, well, in that case, if it's an existing user.

147
00:08:09,500 --> 00:08:15,500
So from B and the answer is yes, we can go directly to E.

148
00:08:15,500 --> 00:08:18,500
And then it also sends an email with a magic link.

149
00:08:18,500 --> 00:08:22,500
And I think it's somehow removed the no case for the accept conditions question.

150
00:08:22,500 --> 00:08:26,500
So let's add that back here like so.

151
00:08:26,500 --> 00:08:28,500
And then we go back to a.

152
00:08:28,500 --> 00:08:29,500
There we go.

153
00:08:29,500 --> 00:08:38,500
And then finally what we can do is that we have the estates and that goes to the end state so that we end up in an end state right here.

154
00:08:38,500 --> 00:08:40,500
So this is the flow chat that we get them.

155
00:08:40,500 --> 00:08:43,500
Let's try the top to bottom again.

156
00:08:43,500 --> 00:08:45,500
And then this is what you see.

157
00:08:45,500 --> 00:08:49,500
So you can see it's quite easy to create these flow charts right here in mermaid.

158
00:08:49,500 --> 00:08:57,500
The disadvantage of using something like mermaid is that you don't have a lot of control over where these blocks in the diagram are located.

159
00:08:57,500 --> 00:09:03,500
For example, perhaps it would be nicer to have this send email with magic link block aligned more to the left.

160
00:09:03,500 --> 00:09:11,500
So this yes arrow right here could actually go through this place instead of going straight through the no arrow.

161
00:09:11,500 --> 00:09:14,500
It might be a bit easier to understand the diagram in that way.

162
00:09:14,500 --> 00:09:25,500
But still I find this way of drawing diagrams much faster than using a real drawing tool because I can just write it down in text and it appears right here on the right side of the screen.

163
00:09:25,500 --> 00:09:27,500
So that's a flow chart.

164
00:09:27,500 --> 00:09:36,500
So flow charts are very useful for modeling these kinds of flows and modeling alternative flows and defining what should happen in that case.

165
00:09:36,500 --> 00:09:40,500
And it's helpful to have these kinds of visualizations in your design documents.

166
00:09:40,500 --> 00:09:45,500
Now flow charts really focus on modeling the flow, which makes sense because they're flow charts.

167
00:09:45,500 --> 00:09:53,500
But sometimes you want to do something a bit differently, especially if you have, let's say, multiple participants in a particular operation.

168
00:09:53,500 --> 00:10:00,500
That also actually happens a lot in authentication flows where you might have a client that wants to authenticate itself.

169
00:10:00,500 --> 00:10:09,500
You have a server that needs an authenticated client and you have an authentication provider that does the job of authentication.

170
00:10:09,500 --> 00:10:15,500
So then you have three parties that are part of, let's say, a flow or a sequence to be authenticated.

171
00:10:15,500 --> 00:10:23,500
And flow charts are not really that helpful for that because they don't really indicate who is where in which part of the flow.

172
00:10:23,500 --> 00:10:28,500
This is really more suited for how a user would do things.

173
00:10:28,500 --> 00:10:37,500
And if you want to have the participants in a certain operation to be shown more explicitly, then something like a sequence diagram is actually quite helpful.

174
00:10:37,500 --> 00:10:39,500
Let me show you how that works.

175
00:10:39,500 --> 00:10:45,500
So I'm going to add a sequence diagram here right in Mermaid.

176
00:10:45,500 --> 00:10:48,500
And then we're going to have a number of participants.

177
00:10:48,500 --> 00:10:53,500
So for each participant in this sequence, I'm going to define it right here.

178
00:10:53,500 --> 00:10:56,500
And let's say we're going to model this authentication flow.

179
00:10:56,500 --> 00:11:02,500
So we're going to have participants, clients.

180
00:11:02,500 --> 00:11:12,500
We're going to have a participant OOF provider, which is the server that handles authentication requests.

181
00:11:12,500 --> 00:11:20,500
And we're going to have a participant server that needs an authenticated client in order to do things.

182
00:11:20,500 --> 00:11:29,500
So what you can do now is model the various steps in the sequence of authenticating and getting something from the server.

183
00:11:29,500 --> 00:11:36,500
So the first thing that you're probably going to have is something like the client that's going to talk with the OOF provider to get authenticated.

184
00:11:36,500 --> 00:11:44,500
And communication in a sequence diagram, I actually should add the A here, is done by using this type of error.

185
00:11:44,500 --> 00:11:49,500
So we have the client and then we have the OOF provider.

186
00:11:49,500 --> 00:11:56,500
And what this is going to do is request an access token like so.

187
00:11:56,500 --> 00:11:58,500
And this should be in I as well.

188
00:11:58,500 --> 00:12:00,500
So then this is what you get, right?

189
00:12:00,500 --> 00:12:05,500
We have the client, OOF provider in the server and the client requests an access token.

190
00:12:05,500 --> 00:12:08,500
And we can add more operations in the sequence.

191
00:12:08,500 --> 00:12:19,500
So the OOF provider like this sends an access token back to the client,

192
00:12:19,500 --> 00:12:22,500
assuming that the client provided the right credentials.

193
00:12:22,500 --> 00:12:31,500
Then the client has the access token, so the client goes to the server and requests a resource.

194
00:12:31,500 --> 00:12:35,500
Then the server has to verify that the client is properly authenticated.

195
00:12:35,500 --> 00:12:43,500
So the server talks back to the OOF provider to validate the token.

196
00:12:43,500 --> 00:12:51,500
Then the OOF provider sends back to the server that the token is valid.

197
00:12:51,500 --> 00:12:58,500
And then finally the server goes back to the client and sends the resource.

198
00:12:58,500 --> 00:13:02,500
And there we have a basic example of a sequence diagram in Mermaid.

199
00:13:02,500 --> 00:13:07,500
The advantage of using a sequence diagram instead of a flowchart like we had before

200
00:13:07,500 --> 00:13:12,500
is that it's really clear what the roles are of the different parties in this sequence.

201
00:13:12,500 --> 00:13:17,500
So we have the client, OOF provider in the server and this really visualizes very clearly how they communicate.

202
00:13:17,500 --> 00:13:21,500
So for these kinds of operations, a sequence diagram is actually quite helpful.

203
00:13:21,500 --> 00:13:28,500
There's a couple of other things you can do to clarify when the operation is handled by which party.

204
00:13:28,500 --> 00:13:34,500
So what you can do is activating and deactivating participants in the sequence diagram.

205
00:13:34,500 --> 00:13:37,500
And that's then shown by adding rectangles to these lines.

206
00:13:37,500 --> 00:13:42,500
So for example, what you can do is when the client sends something to the OOF provider right here,

207
00:13:42,500 --> 00:13:48,500
we can activate the OOF provider.

208
00:13:48,500 --> 00:13:57,500
And once the OOF provider sends things back to the client, we can deactivate the OOF provider again.

209
00:13:57,500 --> 00:14:02,500
And now you see we get this little square here to indicate this is when the OOF provider is active.

210
00:14:02,500 --> 00:14:04,500
And we can do that also for the server.

211
00:14:04,500 --> 00:14:15,500
So let's say we activate the server here and here we activate the OOF provider again.

212
00:14:15,500 --> 00:14:27,500
And here we deactivate the OOF provider and finally we also deactivate the server like so.

213
00:14:27,500 --> 00:14:29,500
And then this is basically what you get.

214
00:14:29,500 --> 00:14:31,500
Now I'm not sure why I'm seeing this twice.

215
00:14:31,500 --> 00:14:33,500
Did I do something weird?

216
00:14:33,500 --> 00:14:34,500
I don't know.

217
00:14:34,500 --> 00:14:36,500
For some reason I'm seeing it twice.

218
00:14:36,500 --> 00:14:37,500
I'm not sure why that is.

219
00:14:37,500 --> 00:14:39,500
Maybe I should reopen the preview.

220
00:14:39,500 --> 00:14:40,500
Oh, okay.

221
00:14:40,500 --> 00:14:42,500
So it was apparently a rendering issue.

222
00:14:42,500 --> 00:14:43,500
All right.

223
00:14:43,500 --> 00:14:45,500
So this is your basic sequence diagram.

224
00:14:45,500 --> 00:14:48,500
One more thing that you can do is add numbers to these things.

225
00:14:48,500 --> 00:14:54,500
So often you may want to refer in your document to certain steps in the sequence.

226
00:14:54,500 --> 00:14:56,500
And it's nice to be able to add numbers to this.

227
00:14:56,500 --> 00:14:59,500
And sequence diagram has a auto number feature.

228
00:14:59,500 --> 00:15:02,500
So you're just right here, auto number like this.

229
00:15:02,500 --> 00:15:07,500
And now it's going to add these numbers so you can, in your text, refer to step three

230
00:15:07,500 --> 00:15:11,500
or step four in the sequence and then you can easily find it back in the diagram.

231
00:15:11,500 --> 00:15:13,500
So that's a sequence diagram.

232
00:15:13,500 --> 00:15:18,500
Also quite helpful and also like that it's really easy to create this in Mermaid.

233
00:15:18,500 --> 00:15:22,500
So next type of diagram that I want to talk about is the famous class diagram.

234
00:15:22,500 --> 00:15:26,500
This is probably what UML is most known for.

235
00:15:26,500 --> 00:15:29,500
And this is how you create it in Mermaid.

236
00:15:29,500 --> 00:15:35,500
So we can have a class diagram and then you add your classes and your relationships below this line.

237
00:15:35,500 --> 00:15:40,500
For example, let's create a class that's called order.

238
00:15:40,500 --> 00:15:46,500
And it's going to have, let's say, an order status like so.

239
00:15:46,500 --> 00:15:51,500
So it has one instance variable of type order status and what that is we'll look into that later.

240
00:15:51,500 --> 00:15:56,500
But this is your basic diagram containing a simple class.

241
00:15:56,500 --> 00:15:59,500
Personally, I don't use class diagrams all that much.

242
00:15:59,500 --> 00:16:07,500
The main reason being that I'm moving more towards functional approaches and a class diagram doesn't allow you to define functions as separate objects.

243
00:16:07,500 --> 00:16:13,500
Now you could, of course, create something here you call the class, but then it's actually a function.

244
00:16:13,500 --> 00:16:17,500
But well, the question is whether it really makes a lot of sense.

245
00:16:17,500 --> 00:16:23,500
Actually, there's another diagram type that I do use quite a lot that I find quite useful and I'll talk about that in a minute.

246
00:16:23,500 --> 00:16:26,500
Let's first look a bit more closely at class diagrams.

247
00:16:26,500 --> 00:16:32,500
They are quite useful if you want to model things like design patterns and visualize how design pattern works.

248
00:16:32,500 --> 00:16:36,500
But when I write my applications, I generally don't create class diagrams.

249
00:16:36,500 --> 00:16:41,500
I just create the classes directly inside the code and for me that works just as well.

250
00:16:41,500 --> 00:16:47,500
So class diagram, there's a couple of different things you can do in a class diagram in Mermaid.

251
00:16:47,500 --> 00:16:51,500
One thing you can do is let's say this order status is an enumeration.

252
00:16:51,500 --> 00:16:53,500
You can add a second class.

253
00:16:53,500 --> 00:16:58,500
Let's call that order status and order status has a few options.

254
00:16:58,500 --> 00:17:01,500
So we have, let's say, failed, pending and paid.

255
00:17:01,500 --> 00:17:07,500
And you can indicate that this is an enumeration by using this in Mermaid.

256
00:17:07,500 --> 00:17:15,500
So now it's an enumeration and we add a couple of states here like failed, pending and paid like so.

257
00:17:15,500 --> 00:17:16,500
So that's our order status.

258
00:17:16,500 --> 00:17:22,500
And let's say we have another class that is a payment processor that we use for processing payments.

259
00:17:22,500 --> 00:17:27,500
So we have a class, let's call that a payment processor class.

260
00:17:27,500 --> 00:17:33,500
And we want this to be an interface or in Python protocol class or an abstract class

261
00:17:33,500 --> 00:17:38,500
because we're going to create subclasses for specific payment processors.

262
00:17:38,500 --> 00:17:40,500
So Stripe, PayPal, et cetera, et cetera.

263
00:17:40,500 --> 00:17:47,500
And in order to indicate that something is abstract or an interface, you write this in Mermaid.

264
00:17:47,500 --> 00:17:49,500
And then what are we going to have?

265
00:17:49,500 --> 00:17:54,500
Well, we're going to have an API key to connect to that particular processor.

266
00:17:54,500 --> 00:17:57,500
So that's a string API key.

267
00:17:57,500 --> 00:18:07,500
And we're going to have a method to connect so that gets a URL and perhaps some JSON data, whatever.

268
00:18:07,500 --> 00:18:13,500
And we're going to have a method to process a payment.

269
00:18:13,500 --> 00:18:20,500
And that's going to get an order and that's going to return the order status.

270
00:18:20,500 --> 00:18:23,500
So this is our simple interface for payment processor.

271
00:18:23,500 --> 00:18:30,500
Many object oriented programming languages have a mechanism to protect access to particular parts of class.

272
00:18:30,500 --> 00:18:33,500
So you can make members private or protected or public.

273
00:18:33,500 --> 00:18:39,500
Python doesn't have it, but in your class diagram, it's often useful to indicate this in some way.

274
00:18:39,500 --> 00:18:44,500
So you know which parts are going to be internal and which parts are going to be used externally.

275
00:18:44,500 --> 00:18:50,500
So for example, in the case of the payment processor, well, probably the API key, you don't want others to access this.

276
00:18:50,500 --> 00:18:57,500
So you could make it private and making something private, you do that by putting a minus in front of the method name.

277
00:18:57,500 --> 00:19:00,500
Processing the payment is probably something that's going to be public.

278
00:19:00,500 --> 00:19:06,500
So you can put a plus in front of this and connect is probably something that's going to be internal,

279
00:19:06,500 --> 00:19:11,500
but you might want to override that method and call it from the subclass as well.

280
00:19:11,500 --> 00:19:16,500
So you could make it protected and a protected member we indicate by using this hash.

281
00:19:16,500 --> 00:19:20,500
That's the kind of standard way to do it in UML.

282
00:19:20,500 --> 00:19:23,500
And then order status, we can also make that public like so.

283
00:19:23,500 --> 00:19:28,500
So these are the main classes in this particular example we have an order that has a status

284
00:19:28,500 --> 00:19:32,500
and there's a payment processor that can process payments of an order.

285
00:19:32,500 --> 00:19:34,500
Another thing you might have is a customer.

286
00:19:34,500 --> 00:19:41,500
So let's also create a class customer and the customer is going to have a name like so.

287
00:19:41,500 --> 00:19:46,500
And that's also going to be public and that's probably going to be address information and etc.

288
00:19:46,500 --> 00:19:48,500
But let's leave that out for now.

289
00:19:48,500 --> 00:19:52,500
So we have our four different concepts in the class diagram.

290
00:19:52,500 --> 00:19:56,500
And now we can start modeling relationships between them.

291
00:19:56,500 --> 00:20:00,500
There's a couple of relationships that are in particular important.

292
00:20:00,500 --> 00:20:03,500
We have inheritance relationships.

293
00:20:03,500 --> 00:20:10,500
We have composition relationships and we have aggregation relationships.

294
00:20:10,500 --> 00:20:13,500
So these all look different and they are actually also different,

295
00:20:13,500 --> 00:20:17,500
although composition and aggregation are really closely related.

296
00:20:17,500 --> 00:20:22,500
So inheritance means that we have a class and a subclass relationship.

297
00:20:22,500 --> 00:20:25,500
For example, here we have the customer class, which has a name,

298
00:20:25,500 --> 00:20:30,500
but I could create a private customer and a business customer.

299
00:20:30,500 --> 00:20:37,500
So we can model a relationship here, an inheritance relationship that goes from customer to

300
00:20:37,500 --> 00:20:44,500
and this is how we indicate inheritance in Mermaid, a private customer.

301
00:20:44,500 --> 00:20:49,500
And you also see that this inheritance relationship appears here directly in the diagram.

302
00:20:49,500 --> 00:20:55,500
And let's do the same thing, but then let's create a business customer as well.

303
00:20:55,500 --> 00:21:01,500
So we have the customer class that can have a private customer or a business customer subclass.

304
00:21:01,500 --> 00:21:03,500
So that's inheritance relationships.

305
00:21:03,500 --> 00:21:08,500
And we can do the same thing, for example, for the payment processor, like so.

306
00:21:08,500 --> 00:21:16,500
And let's also create an inheritance relationship and we will have a stripe payment processor.

307
00:21:16,500 --> 00:21:23,500
And we're going to have a PayPal payment processor like so.

308
00:21:23,500 --> 00:21:28,500
So now we have our interface payment process that has implementation subclasses,

309
00:21:28,500 --> 00:21:32,500
stripe payment processor and PayPal payment processor.

310
00:21:32,500 --> 00:21:35,500
You can put these method definitions also again in this class.

311
00:21:35,500 --> 00:21:40,500
You simply can add the stripe payment processor class here and add any instance variables

312
00:21:40,500 --> 00:21:42,500
or methods that you like.

313
00:21:42,500 --> 00:21:46,500
So what about the relationship between, let's say, the order and the customer

314
00:21:46,500 --> 00:21:50,500
because every order should have a customer associated with it.

315
00:21:50,500 --> 00:21:52,500
There's two options that come to mind.

316
00:21:52,500 --> 00:21:54,500
There is composition and there's aggregation.

317
00:21:54,500 --> 00:21:55,500
But what's the difference exactly?

318
00:21:55,500 --> 00:21:59,500
There's actually a more generic term in UML that's called an association

319
00:21:59,500 --> 00:22:03,500
that also describes a relationship between two objects.

320
00:22:03,500 --> 00:22:08,500
And aggregation and composition are basically special cases of associations.

321
00:22:08,500 --> 00:22:14,500
In both of these cases, it means that an object maintains a reference to an object of another class.

322
00:22:14,500 --> 00:22:21,500
But the difference is that aggregation is a relationship where the child or the object

323
00:22:21,500 --> 00:22:27,500
that you have a relationship with can, in principle, exist independently from the other object,

324
00:22:27,500 --> 00:22:28,500
which is the case here.

325
00:22:28,500 --> 00:22:31,500
We could have an order that has a customer.

326
00:22:31,500 --> 00:22:35,500
But if we delete the order, we still might want to keep the customer

327
00:22:35,500 --> 00:22:39,500
and actually have multiple orders over their customer lifetime, right?

328
00:22:39,500 --> 00:22:43,500
So there the customer can exist independent of the order.

329
00:22:43,500 --> 00:22:47,500
And the way to model this in Mermaid is using this type of error.

330
00:22:47,500 --> 00:22:53,500
So we have an order and then we write the relationship like so.

331
00:22:53,500 --> 00:23:00,500
And now you see that customer is actually attached to order via this aggregation relationship.

332
00:23:00,500 --> 00:23:05,500
If you turn this into a composition, then you would use a star instead of an O.

333
00:23:05,500 --> 00:23:09,500
And then this will be colored in and that means it's a composition.

334
00:23:09,500 --> 00:23:16,500
But actually an aggregation makes more sense here because customer can exist independently from the order.

335
00:23:16,500 --> 00:23:22,500
Suppose you have a car class, then you could have a composition of the car with the engine,

336
00:23:22,500 --> 00:23:24,500
which is what you see here on the right.

337
00:23:24,500 --> 00:23:28,500
And here composition makes more sense than aggregation because in principle,

338
00:23:28,500 --> 00:23:31,500
the engine is simply part of the car.

339
00:23:31,500 --> 00:23:34,500
There is no reason that an engine is in multiple cars or something.

340
00:23:34,500 --> 00:23:38,500
So a car really has, it contains an engine.

341
00:23:38,500 --> 00:23:43,500
And the child, the engine doesn't normally exist independently of the car.

342
00:23:43,500 --> 00:23:46,500
If you're building software for a car repair facility,

343
00:23:46,500 --> 00:23:49,500
then maybe you would have engine be a separate part of the car.

344
00:23:49,500 --> 00:23:53,500
So it depends on the application that you're building, obviously.

345
00:23:53,500 --> 00:23:57,500
I hope you can see that there's a difference between this type of relationship,

346
00:23:57,500 --> 00:24:00,500
customers and orders and cars and engines.

347
00:24:00,500 --> 00:24:05,500
So this is aggregation and this is composition and they're both specific versions

348
00:24:05,500 --> 00:24:08,500
of a more generic relationship, which is called association.

349
00:24:08,500 --> 00:24:11,500
Again, I don't use these class diagrams very much myself

350
00:24:11,500 --> 00:24:15,500
because I rely less and less on classes and more functions nowadays in my code.

351
00:24:15,500 --> 00:24:20,500
But still, it can be useful to draw this out in text, in mermaids really easily like this.

352
00:24:20,500 --> 00:24:22,500
So the final type of diagram that I want to talk with you about,

353
00:24:22,500 --> 00:24:24,500
and this one is actually quite useful,

354
00:24:24,500 --> 00:24:27,500
this is called the entity relationship diagram.

355
00:24:27,500 --> 00:24:32,500
And we write it in mermaid like so, er diagram.

356
00:24:32,500 --> 00:24:35,500
And what I like about the entity relationship diagram

357
00:24:35,500 --> 00:24:37,500
is that it's a bit more generic than the class diagram.

358
00:24:37,500 --> 00:24:42,500
It simply talks about concepts that are related in some way.

359
00:24:42,500 --> 00:24:48,500
And this is actually useful if you, let's say you're trying to build software in a particular domain

360
00:24:48,500 --> 00:24:51,500
and you want to create a model of that domain.

361
00:24:51,500 --> 00:24:53,500
You want to understand how things are related

362
00:24:53,500 --> 00:24:56,500
and what the main concepts are in that domain.

363
00:24:56,500 --> 00:25:01,500
So what you do is you create an entity relationship diagram that describes this domain.

364
00:25:01,500 --> 00:25:05,500
And then normally what you do in this kind of diagram is that you have the concepts

365
00:25:05,500 --> 00:25:07,500
and the relationships between the concepts

366
00:25:07,500 --> 00:25:12,500
and often there's kind of like a verb associated with each relationship.

367
00:25:12,500 --> 00:25:15,500
So for example, what you could have is a customer.

368
00:25:15,500 --> 00:25:18,500
I'm kind of sticking with the customer order example

369
00:25:18,500 --> 00:25:21,500
and customer is related to an order.

370
00:25:21,500 --> 00:25:26,500
So we have the order and then between customer and order we have a relationship.

371
00:25:26,500 --> 00:25:33,500
And in an entity relationship diagram, this is how we do it.

372
00:25:33,500 --> 00:25:36,500
And then we write a verb behind it.

373
00:25:36,500 --> 00:25:39,500
And as you can see this relationship, it looks a bit complicated.

374
00:25:39,500 --> 00:25:43,500
What this actually means is that this identifies how many things

375
00:25:43,500 --> 00:25:46,500
of something are connected with something else.

376
00:25:46,500 --> 00:25:48,500
So in this case, a customer plays an order.

377
00:25:48,500 --> 00:25:54,500
What this means right here is that the order is going to have exactly one customer.

378
00:25:54,500 --> 00:25:56,500
So one order cannot have multiple customers.

379
00:25:56,500 --> 00:25:59,500
And if you go to the mermaid documentation,

380
00:25:59,500 --> 00:26:04,500
so let me scroll down for the entity relationship diagrams.

381
00:26:04,500 --> 00:26:07,500
So these are the options for the arrows.

382
00:26:07,500 --> 00:26:10,500
This means zero or one. This means exactly one.

383
00:26:10,500 --> 00:26:13,500
This means zero or more with no upper limit.

384
00:26:13,500 --> 00:26:15,500
And this means one or more.

385
00:26:15,500 --> 00:26:19,500
And these are kind of the most commonly used relationships

386
00:26:19,500 --> 00:26:21,500
in an entity relationship diagram.

387
00:26:21,500 --> 00:26:26,500
So if we look at this example, so you can see that we have one customer

388
00:26:26,500 --> 00:26:30,500
that places zero or more orders.

389
00:26:30,500 --> 00:26:33,500
So a customer can exist independently of an order.

390
00:26:33,500 --> 00:26:35,500
And we can add more relationships.

391
00:26:35,500 --> 00:26:38,500
So we could also have an order.

392
00:26:38,500 --> 00:26:46,500
So one order is going to have one or more line items.

393
00:26:46,500 --> 00:26:49,500
And that's a contains relationship, right?

394
00:26:49,500 --> 00:26:53,500
So an order without any line item whatsoever is not a valid order.

395
00:26:53,500 --> 00:26:57,500
And then what you can do is also add some attributes.

396
00:26:57,500 --> 00:27:01,500
So the main thing here is that we don't really care if customer is a class

397
00:27:01,500 --> 00:27:04,500
or if it's a module containing a bunch of functions or whatever.

398
00:27:04,500 --> 00:27:08,500
It's a concept and we're modeling the concepts and the relationships

399
00:27:08,500 --> 00:27:10,500
between the concepts.

400
00:27:10,500 --> 00:27:13,500
So that makes a difference from a class diagram in UML.

401
00:27:13,500 --> 00:27:18,500
Now you can add instance variables or let's say data that belongs

402
00:27:18,500 --> 00:27:20,500
to a particular concept.

403
00:27:20,500 --> 00:27:26,500
So we could have a customer and perhaps we want the customer to have an ID

404
00:27:26,500 --> 00:27:30,500
and we want the customer to have a name like so.

405
00:27:30,500 --> 00:27:33,500
And you see it also appearing here on the right.

406
00:27:33,500 --> 00:27:38,500
And we can do the same thing like, for example, the order, it might have an ID

407
00:27:38,500 --> 00:27:44,500
and it might have a status, right, for being paid or not.

408
00:27:44,500 --> 00:27:46,500
And line item, similar.

409
00:27:46,500 --> 00:27:51,500
So we have line item that might have some kind of code.

410
00:27:51,500 --> 00:27:59,500
It might have a description, a quantity and a price.

411
00:27:59,500 --> 00:28:03,500
So the entity relationship diagram still allows you to associate data with concepts

412
00:28:03,500 --> 00:28:06,500
to kind of indicate how concepts are structured.

413
00:28:06,500 --> 00:28:10,500
But it's not about classes, it's really about concepts and how they're related.

414
00:28:10,500 --> 00:28:13,500
And this is a diagram we also like to use from time to time

415
00:28:13,500 --> 00:28:17,500
just to give a global overview of how things fit together.

416
00:28:17,500 --> 00:28:20,500
So I hope you enjoyed this video and that has given you some ideas

417
00:28:20,500 --> 00:28:24,500
for how to use Mermaid to write better software design documents.

418
00:28:24,500 --> 00:28:27,500
If you enjoyed it, give it a like, consider subscribing to my channel

419
00:28:27,500 --> 00:28:30,500
if you want to learn more about software design and development.

420
00:28:30,500 --> 00:28:33,500
Thanks for watching. Take care. See you next time.

