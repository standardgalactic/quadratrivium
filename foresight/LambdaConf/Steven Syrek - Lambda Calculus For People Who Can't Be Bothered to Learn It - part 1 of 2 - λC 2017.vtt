WEBVTT

00:00.000 --> 00:10.000
Rwy'n cael ei ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud.

00:30.000 --> 00:43.000
So, welcome everybody to this workshop, Lambda Calculus for people who can't be bothered to learn it.

00:43.000 --> 00:52.000
I was surprised to see on the schedule, I think there are at least four Lambda Calculus related workshops and presentations at this conference.

00:52.000 --> 00:56.000
That's a lot of Lambda Calculus. Did any of you go to the six hour one yesterday?

00:57.000 --> 01:09.000
Dana Scott? All day? How was that? I'm sure way over my head. This will not be a reprise of that at all.

01:09.000 --> 01:16.000
For people who can't be bothered to learn it part, that is because I'm not really going to teach you all of Lambda Calculus.

01:16.000 --> 01:20.000
It is actually quite a deep subject, there's a lot to it, there are many different Lambda Calculi.

01:20.000 --> 01:27.000
I'm mostly going to be doing a little bit with the simply type Lambda Calculus, which I think is something anybody can learn pretty quickly.

01:27.000 --> 01:36.000
And it can actually be a little bit fun. Also though we're going to be implementing it in America's favorite programming language, JavaScript.

01:36.000 --> 01:43.000
Now this is not because I recommend JavaScript for functional programming or any practical purpose whatsoever.

01:43.000 --> 01:49.000
It's because I don't want to have to ask everybody to install Haskell or some other language.

01:49.000 --> 01:55.000
You all have JavaScript on your machines already. For those of you who don't know this, you may be slightly surprised by that fact.

01:55.000 --> 02:01.000
But I assume all of you know this in your browsers, you have a console, it runs JavaScript, that's all you need. So easy for me.

02:01.000 --> 02:09.000
I'm also not going to be using very much of the JavaScript syntax such as it is at all. Just anonymous functions, but we'll get to that.

02:10.000 --> 02:20.000
So again, just to reiterate, please stop me, ask questions. I don't generally like the Socratic method of teaching, but let's see if you can read my mind.

02:20.000 --> 02:27.000
What do you suppose is maybe the simplest, what you might think of as the dumbest possible question you might ask about Lambda Calculus?

02:27.000 --> 02:30.000
Anyone want to take a guess? I'll never do this again.

02:31.000 --> 02:32.000
Why?

02:32.000 --> 02:33.000
Why what?

02:41.000 --> 02:44.000
Why do you need to bother?

02:46.000 --> 02:48.000
That's a smart question. I'm looking for a dumb question.

02:51.000 --> 02:55.000
That's it. Yeah, why is it called Lambda Calculus? Does anyone actually know why it's called Lambda Calculus? I know you know.

02:56.000 --> 03:01.000
No, no, no, no. I don't want you to. Yeah. Yeah. Yeah. Okay. Good. I'm glad for all of you people know.

03:01.000 --> 03:07.000
This is an important point. It seems like a trivial point. This might be a little bit of mythology. Very quickly. I think it's kind of funny.

03:07.000 --> 03:12.000
All right. People are afraid of this. It's got a Greek letter. It's called Calculus. If you're not a math person, I'm not a math person. It sounds scary, right?

03:12.000 --> 03:18.000
Forget the calculus part. You know, we're going to count some things with it or something like that. So forget calculus.

03:18.000 --> 03:23.000
But Lambda, what is this Lambda thing? A little bit intimidating. This whole conference is about Lambdas, right? Lambda comp.

03:23.000 --> 03:45.000
Well, Alonso Church, the person who developed, discovered, invented Lambda Calculus, the story that I read in academic literature was that he actually wanted to use some notation from, I guess, the 18th century that looked something like this, actually like a little hat.

03:46.000 --> 03:55.000
If he had gotten his way, we'd be calling it hat calculus, I suppose. I know that sounds funny, but there actually is a hat calculus. Look it up on Wikipedia. It became a different thing.

03:55.000 --> 04:06.000
Back then, professors had secretaries. I'm actually a recovering English professor. I never had a secretary. But typewriters couldn't do that.

04:06.000 --> 04:20.000
So his secretary ended up kind of doing that to represent it. He could do that with some slashes. This could all be a myth. I don't know. What does that look like? Yeah, capital Lambda, right? That's it.

04:20.000 --> 04:29.000
So they called it Lambda Calculus and eventually went lowercase. I suppose it looks nicer. They use this for type systems now. That's it. So what is the point?

04:29.000 --> 04:40.000
I mean, okay, it's like a little bit of a factoid. Completely arbitrary, right? These are not things to be scared of. All of the names that are used in Lambda Calculus and much of functional programming, they're just arbitrary names.

04:40.000 --> 04:53.000
There's nothing to worry about. They sound a little bit intimidating. They certainly intimidated me. I may be more easily intimidated than all of you. But the point is like, who cares? It doesn't even matter. These names are not important.

04:54.000 --> 05:07.000
Okay. I'm not going to do a lot of slides. In fact, originally, I wasn't going to do any, but I thought it's probably worthwhile to introduce the syntax of Lambda Calculus a little bit before going straight into JavaScript.

05:07.000 --> 05:17.000
I need to ease you into JavaScript because I know it's a little bit painful. And I should introduce myself. This is my name, Stephen Syrac, in case you're wondering about the pronunciation. I'm SJ Syrac in all the places.

05:18.000 --> 05:34.000
And like I said, I'm a recovering English professor. And I just want to point out to you that if I can do this, you can do this. I've not been doing this for very long. I taught myself Lambda Calculus while I was learning Haskell not very long ago.

05:34.000 --> 05:41.000
I think I started a year and a half ago at the most. And I became very excited about it enough that I was willing to do this right now.

05:41.000 --> 05:48.000
So I want to make that point not only because I want to be encouraging to all of you, but because there are two purposes to this talk in my mind.

05:48.000 --> 05:57.000
One is that maybe I can communicate something about Lambda Calculus to you and why it's useful, why it's awesome, why it's the foundation of everything that this conference is about.

05:57.000 --> 06:07.000
But also, and for me more importantly, and for those of you who do have experience, and by the way, those of you who do have experience, feel free at any time to tell me when I'm wrong.

06:07.000 --> 06:12.000
I need that and I appreciate it. And also please help others around you.

06:12.000 --> 06:18.000
I want everyone to be able to come away from this presentation able to teach this material to somebody else.

06:18.000 --> 06:23.000
The only way the functional programming world is going to grow is if all of us become teachers.

06:23.000 --> 06:27.000
Maybe that sounds like an extreme statement, but we're a very small community.

06:27.000 --> 06:33.000
And for our own self-preservation, we need to expand, like expand or die.

06:33.000 --> 06:36.000
And the other reason I'm using JavaScript is precisely for this reason.

06:36.000 --> 06:42.000
You can go back to your places of work or to your friends if you can convince them to learn something called Lambda Calculus.

06:42.000 --> 06:50.000
And everybody has a web browser and you will be able to open that up and show them some things without having them install a complicated programming language or some software they don't understand.

06:50.000 --> 06:52.000
Because like I said, anybody can learn this.

06:52.000 --> 06:59.000
So if you already feel competent with this material, then at the very least you can help me develop this into a better presentation for teaching others.

06:59.000 --> 07:03.000
And then find a way to use this material to teach your colleagues, right?

07:03.000 --> 07:12.000
Because you may not get them to install Haskell, but you can get them to open up a browser and then you can just immediately start writing functions and show them how this stuff works.

07:12.000 --> 07:16.000
Okay, so that's enough motivation I think.

07:16.000 --> 07:18.000
Are there any questions at this point?

07:18.000 --> 07:23.000
I know that you wanted me to go over purposes and aims or something.

07:23.000 --> 07:35.000
Perhaps just some specific examples of how perhaps Lambda has helped you to better understand or other ways to change the way you approach my house.

07:35.000 --> 07:38.000
We don't program any Lambda Calculus.

07:38.000 --> 07:39.000
This is a mental exercise.

07:39.000 --> 07:41.000
Don't you?

07:41.000 --> 07:42.000
Don't you?

07:42.000 --> 07:48.000
That's very heavy, but it's a useful exercise for the ultimate American language.

07:48.000 --> 07:50.000
Thank you for asking.

07:50.000 --> 07:55.000
I think it's really useful for developing an intuition for what functional programming is all about.

07:55.000 --> 08:01.000
Raise your hand if you're really not sure what functional programming is.

08:01.000 --> 08:03.000
Yeah, honest people.

08:03.000 --> 08:05.000
Yeah, exactly.

08:05.000 --> 08:09.000
Raise your hand if you think that you would be able to competently explain it to somebody else.

08:09.000 --> 08:12.000
That's the other kind of question.

08:12.000 --> 08:16.000
Functional programming is programming with functions.

08:16.000 --> 08:17.000
So helpful.

08:17.000 --> 08:22.000
I think actually this material will really show you what functional programming is all about.

08:22.000 --> 08:25.000
It's elementary particles as it were.

08:25.000 --> 08:30.000
What has Lambda Calculus itself taught me about programming?

08:30.000 --> 08:33.000
I think I only have a boring answer to that question.

08:33.000 --> 08:35.000
Haskell is a Lambda Calculus.

08:35.000 --> 08:38.000
So I made this joke, don't we program with Lambda Calculus?

08:38.000 --> 08:42.000
Yes, if you're using functional programming language or using Lambda Calculus, you just may not know it.

08:42.000 --> 08:44.000
So at the very least now you'll know it.

08:44.000 --> 08:49.000
I never really thought about how Lambda Calculus specifically...

08:49.000 --> 08:54.000
I mean, I suppose I can look at a function and know that I'm doing Ada reduction now,

08:54.000 --> 08:56.000
or that maybe I should do Ada reduction.

08:56.000 --> 09:01.000
I guess there are places in which it helps me with refactoring or conceptualizing.

09:01.000 --> 09:05.000
I'm not going to be talking specifically about that, I don't think.

09:05.000 --> 09:13.000
I guess I would maybe be able to talk about how Lambda Calculus gives us for free all of these features that we hear about

09:13.000 --> 09:15.000
when we talk about FP, right?

09:15.000 --> 09:21.000
Referential transparency, immutability, currying.

09:21.000 --> 09:23.000
What are some other good ones?

09:23.000 --> 09:25.000
I don't know, fixed point recursion?

09:25.000 --> 09:28.000
Anyway, that stuff all just sort of falls out for free from Lambda Calculus.

09:28.000 --> 09:30.000
Anyway, let's get to it.

09:30.000 --> 09:31.000
This is the whole language, right?

09:31.000 --> 09:33.000
World's smallest programming language.

09:33.000 --> 09:37.000
Maybe actually the first programming language invented.

09:37.000 --> 09:41.000
1933, anyone know the date? 1933?

09:41.000 --> 09:43.000
I think it up in Wikipedia, Alonso Church, Lambda Calculus.

09:43.000 --> 09:45.000
Before there were computers, right?

09:45.000 --> 09:48.000
They got it right the first time.

09:48.000 --> 09:54.000
This is the whole language right here.

09:54.000 --> 09:57.000
Concentrating first on the first line.

09:57.000 --> 10:03.000
Anything in Lambda Calculus is an expression, and then there are three kinds of expressions.

10:03.000 --> 10:07.000
Names, functions, and applications, and that's it.

10:07.000 --> 10:11.000
A function can be a name, so the lambda name.

10:11.000 --> 10:13.000
I'm going to explain all this a little bit in more detail.

10:13.000 --> 10:18.000
Lambda name.expression, and an application is just two expressions next to each other.

10:18.000 --> 10:23.000
So you can see how this is a bit of a recursively defined language.

10:23.000 --> 10:29.000
The lambda in the second line, that's the famous lambda that everybody wears.

10:29.000 --> 10:31.000
Does anyone have a lambda on their t-shirt right now?

10:31.000 --> 10:35.000
I'd be surprised, actually, if nobody did.

10:35.000 --> 10:38.000
You're probably all wearing one on your lanyard thing.

10:38.000 --> 10:40.000
It's just an abstraction operator.

10:40.000 --> 10:43.000
If you're a programmer, you're used to abstraction, even if you don't know functional programming.

10:43.000 --> 10:53.000
All that is saying is create an abstraction called name and bind to that, this expression, whatever the expression is.

10:53.000 --> 10:58.000
And then function application is two expressions next to each other.

10:58.000 --> 11:04.000
So if you're used to Haskell syntax, the reason why we don't have parentheses in Haskell is because function application is kind of the only operation we have.

11:04.000 --> 11:09.000
So we keep it simple. It's just two expressions next to each other.

11:09.000 --> 11:15.000
I'm so happy to have a blackboard. I don't do slides, so I'm more used to blackboards personally.

11:15.000 --> 11:18.000
God, this is like very fat chalk.

11:18.000 --> 11:24.000
I will be showing some expressions soon, but I just want to make this point.

11:24.000 --> 11:29.000
So you can have something like lambda x dot x.

11:29.000 --> 11:32.000
We actually call this the identity function.

11:32.000 --> 11:43.000
And this part here, we can call it the head, this part is the body.

11:43.000 --> 11:48.000
This is an expression.

11:48.000 --> 11:51.000
Obviously x has no meaning. This is an abstract syntax.

11:51.000 --> 12:01.000
Whatever you have here, whatever the expression is, it's just some stuff that we're going to compute under this thing, lambda x.

12:01.000 --> 12:07.000
You've heard anonymous function. I don't like anonymous function. It doesn't have a name. It doesn't matter.

12:07.000 --> 12:12.000
This operator creates an abstraction out of this expression.

12:12.000 --> 12:16.000
And the x just means that this x and this x are the same.

12:16.000 --> 12:27.000
If you're used to functions that look something like this, it's just text substitution, really.

12:28.000 --> 12:31.000
Really, it's just text substitution. This was invented before there were computers.

12:31.000 --> 12:36.000
In fact, with the lambda calculus, as simple as it is, you can model any computation whatsoever.

12:36.000 --> 12:38.000
That's what's really neat about it. Maybe that's a good answer to your question.

12:38.000 --> 12:41.000
You can compute anything that can be computed with this.

12:41.000 --> 12:44.000
It doesn't seem like you should be able to. I'll prove that.

12:44.000 --> 12:48.000
I mean, there are things you can't compute, and there are things you can,

12:48.000 --> 12:54.000
and that's just sort of a property of nature, and this sort of captures that in the simplest possible way.

12:54.000 --> 12:58.000
So, there's an expression, x. It's just something, something x.

12:58.000 --> 13:01.000
Lambda x.x, I just showed you that. This is a function.

13:01.000 --> 13:07.000
Body dot body dot, sorry, head dot body.

13:07.000 --> 13:16.000
Lambda x.lambda y.xy. This is another expression, and you can think of this as a function with two arguments, x and y.

13:17.000 --> 13:21.000
Lambda x.x, in parentheses, applied to y.

13:21.000 --> 13:26.000
This is not terribly different than if you had simply x, y.

13:26.000 --> 13:33.000
This is also function application. This lambda x.x, y is also function application.

13:33.000 --> 13:38.000
By function application, again, I mean text substitution.

13:38.000 --> 13:43.000
It's probably worth not thinking too much about functions as procedures,

13:43.000 --> 13:47.000
or what you're used to in imperative programming languages.

13:47.000 --> 13:55.000
Lambda x.xy.

13:55.000 --> 13:58.000
Function application means we're doing text substitution,

13:58.000 --> 14:03.000
so the y substitutes for this x in the expression.

14:03.000 --> 14:08.000
This goes away, and we're just left with y.

14:08.000 --> 14:13.000
Y goes into x, turns into y.

14:13.000 --> 14:21.000
This is also a function application, and it's not more complicated.

14:21.000 --> 14:27.000
They get longer and more, they look trickier, but ultimately the rules are the same.

14:27.000 --> 14:32.000
Lambda x.x, lambda y.

14:32.000 --> 14:34.000
Anybody want to guess what this turns into?

14:35.000 --> 14:41.000
Because this whole thing goes into here and is substituted for this x,

14:41.000 --> 14:44.000
so we're just left with that.

14:44.000 --> 14:48.000
This is one of the operations, actually, beta reduction.

14:48.000 --> 14:51.000
Anybody want to get another guess for the audience?

14:51.000 --> 14:56.000
When we say alpha substitution or alpha conversion, where does the alpha come from?

14:56.000 --> 14:58.000
Why alpha?

14:58.000 --> 15:01.000
What's the dumbest possible answer?

15:02.000 --> 15:05.000
Yeah, that's it.

15:05.000 --> 15:07.000
I've got to call it something.

15:15.000 --> 15:19.000
Oh god, I can try the third one.

15:24.000 --> 15:27.000
Lambda x, lambda y, xy.

15:27.000 --> 15:29.000
Lambda x.

15:32.000 --> 15:35.000
Write that using, like, f?

15:40.000 --> 15:43.000
Well, does somebody else want to try?

15:43.000 --> 15:46.000
I mean, I could do it, but maybe someone else should do it.

15:47.000 --> 16:01.000
I mean, I suppose you could have f of x, y,

16:01.000 --> 16:07.000
and then you could apply that to one and then two.

16:07.000 --> 16:10.000
I mean, these don't do anything, right?

16:10.000 --> 16:12.000
We don't know what x and y mean.

16:12.000 --> 16:14.000
It's just a function.

16:15.000 --> 16:17.000
It's just a pure function.

16:17.000 --> 16:20.000
For any given input, it has the same output, right?

16:23.000 --> 16:25.000
Whatever x you give it is always x.

16:25.000 --> 16:27.000
It's always the same, right?

16:27.000 --> 16:29.000
It's mapping between sets.

16:29.000 --> 16:31.000
Is that helpful?

16:31.000 --> 16:44.000
When we get to the JavaScript,

16:44.000 --> 16:46.000
well, I never thought I would say this sentence.

16:46.000 --> 16:49.000
When we get to JavaScript, it'll make more sense.

16:49.000 --> 16:52.000
OK, so here's alpha substitution.

16:52.000 --> 16:55.000
Again, the variable names, they don't mean anything.

16:55.000 --> 16:58.000
You can use any variable that you want,

16:58.000 --> 17:01.000
and yeah, I'm being very funny about using poop emoji,

17:01.000 --> 17:04.000
but the point is these are all the same, OK?

17:04.000 --> 17:06.000
I'm going to use this triple equals a lot

17:06.000 --> 17:08.000
because this is not equality per se.

17:08.000 --> 17:10.000
These are all actually identical.

17:10.000 --> 17:12.000
Lambda A dot A, lambda Z dot Z, poop, whatever.

17:12.000 --> 17:14.000
They're all the same.

17:14.000 --> 17:16.000
All of these represent the exact same things.

17:16.000 --> 17:19.000
You can substitute them one for the other.

17:19.000 --> 17:23.000
And you sometimes need to do that in complicated lambda reductions,

17:23.000 --> 17:25.000
which we are not going to do, right?

17:25.000 --> 17:27.000
I don't want to learn lambda calculus.

17:27.000 --> 17:29.000
That's why you came here.

17:29.000 --> 17:31.000
When we get to the JavaScript, sorry, yeah?

17:31.000 --> 17:35.000
Is there a difference between the same after the dot?

17:35.000 --> 17:37.000
Legibility?

17:37.000 --> 17:39.000
But no.

17:39.000 --> 17:43.000
You're separating the arguments from the expression.

17:43.000 --> 17:45.000
That's what the period is.

17:45.000 --> 17:46.000
Yeah, yeah, yeah.

17:46.000 --> 17:48.000
A is the argument.

17:48.000 --> 17:50.000
Lambda A, that A is the argument,

17:50.000 --> 17:52.000
and the A after the dot is the expression.

17:52.000 --> 17:54.000
Yeah.

17:54.000 --> 17:56.000
It doesn't matter. It's just notation, right?

17:56.000 --> 17:58.000
This is not a programming language.

17:58.000 --> 18:00.000
I'm sorry, this is a programming language.

18:00.000 --> 18:02.000
This is not something you can run on a computer.

18:02.000 --> 18:04.000
Here's a slightly more complicated.

18:04.000 --> 18:06.000
That was alpha substitution. This is beta reduction.

18:06.000 --> 18:08.000
I kind of did a few already, so I hope this makes sense.

18:08.000 --> 18:12.000
You have lambda X, lambda Y, X, Y applied to P and Q.

18:12.000 --> 18:14.000
So first you apply the P, the X goes away.

18:14.000 --> 18:16.000
Now you have lambda Y dot PY.

18:16.000 --> 18:18.000
Then you apply the Q, the lambda Y goes away,

18:18.000 --> 18:20.000
and you end up with PQ.

18:20.000 --> 18:23.000
Does that make sense?

18:24.000 --> 18:26.000
It worries me sometimes that this stuff doesn't actually

18:26.000 --> 18:28.000
make intuitive sense, so if it doesn't make sense,

18:28.000 --> 18:30.000
I will explain it in more detail.

18:30.000 --> 18:32.000
Again, I thought I was going to get 10 people,

18:32.000 --> 18:34.000
and I'd be like, does it make sense to you?

18:34.000 --> 18:36.000
I think it does.

18:36.000 --> 18:39.000
I know. Well, we're going to get there.

18:39.000 --> 18:41.000
This is just supposed to be a warm-up.

18:41.000 --> 18:43.000
I actually don't want this to take that long.

18:43.000 --> 18:44.000
This is kind of neat.

18:44.000 --> 18:48.000
Lambda X dot XX applied to lambda X dot XX.

18:48.000 --> 18:51.000
When we reduce that, we get the same thing, right?

18:51.000 --> 18:56.000
Because if you plug this into this expression,

18:56.000 --> 18:59.000
this X goes away, and you actually substitute this

18:59.000 --> 19:01.000
for both of these Xs, right,

19:01.000 --> 19:04.000
and then you get the same thing again.

19:04.000 --> 19:06.000
Recursion.

19:06.000 --> 19:08.000
You can do recursion with pencil and paper.

19:08.000 --> 19:11.000
I thought that was pretty neat when I first learned it.

19:11.000 --> 19:13.000
Finally, eta conversion.

19:13.000 --> 19:15.000
This is mostly for your information.

19:15.000 --> 19:18.000
It's not going to be terribly important for the talk today,

19:18.000 --> 19:21.000
except eta conversion will come up in one very important place later.

19:21.000 --> 19:26.000
What I'm saying here is that maybe this is the math part that will help.

19:26.000 --> 19:28.000
I don't know.

19:35.000 --> 19:38.000
I can't really make it simpler than it is.

19:38.000 --> 19:40.000
Lambda X dot F of X is just the same thing as F.

19:40.000 --> 19:44.000
The X is superfluous. It's the same thing as a function F.

19:44.000 --> 19:46.000
If you have a function F applied to an X,

19:46.000 --> 19:48.000
you can put that into a lambda abstraction.

19:48.000 --> 19:51.000
That is the same thing as F itself.

20:05.000 --> 20:07.000
Which one?

20:07.000 --> 20:09.000
Lambda X dot F of X.

20:09.000 --> 20:11.000
That's a good point.

20:19.000 --> 20:21.000
I wasn't going to talk about free variables.

20:21.000 --> 20:23.000
The F is not bound in this expression.

20:23.000 --> 20:25.000
If I were actually teaching you lambda calculus,

20:25.000 --> 20:27.000
which I'm not supposed to be doing,

20:27.000 --> 20:29.000
I would say that the F is a free variable.

20:29.000 --> 20:31.000
It's F in some global state.

20:31.000 --> 20:33.000
We don't like global state in functional programming.

20:33.000 --> 20:36.000
It represents some global binding F.

20:36.000 --> 20:38.000
These two things just happen to be identical in meaning.

20:38.000 --> 20:40.000
The F is the same in this case.

20:40.000 --> 20:42.000
That's a good point.

20:42.000 --> 20:44.000
Let's get right into combinators.

20:44.000 --> 20:46.000
Another scary word.

20:46.000 --> 20:50.000
A combinator is a function with no free variables.

20:50.000 --> 20:52.000
It's a function you can combine with other functions

20:52.000 --> 20:54.000
to do some very neat things.

20:54.000 --> 20:56.000
We've already seen this one.

20:56.000 --> 20:58.000
Lambda X dot X.

20:58.000 --> 21:00.000
We call this the identity function because whatever we give it,

21:00.000 --> 21:02.000
we get it back again.

21:02.000 --> 21:04.000
This will prove to be useful and important

21:04.000 --> 21:06.000
in many places in functional programming.

21:06.000 --> 21:08.000
This is also, I guess you could say,

21:08.000 --> 21:10.000
the universal fixed point combinator.

21:10.000 --> 21:12.000
That sounds scary too.

21:12.000 --> 21:16.000
The fixed point of a function

21:16.000 --> 21:18.000
is the value that when you give it to a function,

21:18.000 --> 21:20.000
you get the same value back.

21:20.000 --> 21:24.000
There are many examples of this in math.

21:24.000 --> 21:26.000
I'm not going to go over them,

21:26.000 --> 21:28.000
but I hope you can see that for this function.

21:28.000 --> 21:30.000
Lambda X dot X.

21:30.000 --> 21:32.000
Whatever you give it, you get back.

21:32.000 --> 21:35.000
That's what I mean by universal fixed point combinator.

21:35.000 --> 21:39.000
Fixed point combinators will also come up again later

21:39.000 --> 21:41.000
in a much sexier way.

21:41.000 --> 21:47.000
This is what the identity function looks like in Haskell.

21:47.000 --> 21:49.000
My favorite programming language.

21:49.000 --> 21:51.000
And yours too, I assume.

21:51.000 --> 21:55.000
It's not easy to type a lambda on your computer,

21:55.000 --> 21:57.000
so we have a slash there instead.

21:57.000 --> 21:59.000
That represents a lambda, essentially.

21:59.000 --> 22:03.000
This is what we're going to use in JavaScript.

22:03.000 --> 22:05.000
Assuming that your browsers are all up to date

22:05.000 --> 22:07.000
and you have fat arrow functions.

22:07.000 --> 22:09.000
Same thing, very simple, right?

22:09.000 --> 22:11.000
This is the basic building block that we're going to use.

22:11.000 --> 22:13.000
Anybody know what this is?

22:13.000 --> 22:15.000
Python.

22:15.000 --> 22:17.000
Yeah, Python.

22:17.000 --> 22:19.000
Anyway, what about that?

22:19.000 --> 22:21.000
Ruby.

22:21.000 --> 22:23.000
Yeah, this is good for me to gauge the room.

22:23.000 --> 22:25.000
Who knows what?

22:25.000 --> 22:27.000
What about this weird looking one?

22:27.000 --> 22:29.000
Not Ruby.

22:29.000 --> 22:31.000
No.

22:31.000 --> 22:33.000
Can you do this in Java? I don't actually know Java.

22:33.000 --> 22:35.000
I'm proud of the fact.

22:35.000 --> 22:39.000
I've been programming as a hobby my whole life.

22:39.000 --> 22:41.000
I lost interest in the 90s,

22:41.000 --> 22:43.000
which is when Java started becoming popular

22:43.000 --> 22:45.000
and I got back into it not very long ago.

22:45.000 --> 22:49.000
I feel like my great pride in life is I missed the Java period.

22:49.000 --> 22:51.000
I hope.

22:51.000 --> 22:53.000
I'm sorry if I'm moving too quickly.

22:53.000 --> 22:55.000
I do want to get to JavaScript.

22:55.000 --> 22:57.000
I can't believe I'm saying this stuff.

22:58.000 --> 23:00.000
Now we have a very simple notation

23:00.000 --> 23:02.000
for creating computations,

23:02.000 --> 23:04.000
but it's a little bit clumsy.

23:04.000 --> 23:07.000
We need to actually start creating some primitive values.

23:07.000 --> 23:09.000
We can create true.

23:09.000 --> 23:12.000
Again, this is not a binding in the sense of a variable binding.

23:12.000 --> 23:14.000
These two things are completely equivalent.

23:14.000 --> 23:16.000
They are a substitutable one for another wherever you see them.

23:16.000 --> 23:18.000
We're just going to say,

23:18.000 --> 23:20.000
lambda x dot lambda y dot x means true.

23:20.000 --> 23:23.000
This is simply a function that takes two values,

23:23.000 --> 23:26.000
an x and a y, and it returns the first one.

23:26.000 --> 23:28.000
We're just going to say that that's true.

23:28.000 --> 23:30.000
You could do it a different way if you want,

23:30.000 --> 23:32.000
but we're going to use that as our convention.

23:32.000 --> 23:35.000
We're just going to encode true as this function.

23:35.000 --> 23:38.000
We're going to encode false as the opposite.

23:38.000 --> 23:40.000
It's a function that takes two values

23:40.000 --> 23:42.000
and returns the second value.

23:42.000 --> 23:44.000
That's it.

23:44.000 --> 23:47.000
This is not like some standard of lambda calculus.

23:47.000 --> 23:49.000
This is just totally a convention.

23:49.000 --> 23:51.000
It's the convention that is typically used, so I'm using it,

23:51.000 --> 23:53.000
but we're just making it up.

23:53.000 --> 23:55.000
Did I see a hand somewhere?

23:55.000 --> 23:57.000
Sorry, I was just going to interject.

23:57.000 --> 23:59.000
If somebody is trying to use node and you're using

23:59.000 --> 24:01.000
new language features, it might not work.

24:01.000 --> 24:03.000
You can use Babel.

24:03.000 --> 24:05.000
I'm going to put that in the chat.

24:05.000 --> 24:07.000
Okay.

24:07.000 --> 24:12.000
Actually, Babel inspired me to do this at some point.

24:12.000 --> 24:14.000
Actually, I was very frustrated

24:14.000 --> 24:16.000
with trying to learn lambda calculus.

24:16.000 --> 24:18.000
I started messing around with it in JavaScript

24:18.000 --> 24:20.000
because it was there.

24:20.000 --> 24:22.000
Then eventually one thing led to another.

24:22.000 --> 24:23.000
Here we are.

24:23.000 --> 24:25.000
We can make more complicated functions,

24:25.000 --> 24:27.000
logic functions like and.

24:27.000 --> 24:30.000
I hope that if you look at this and you're a programmer,

24:30.000 --> 24:32.000
this makes sense.

24:32.000 --> 24:34.000
If you have two values, you can determine

24:34.000 --> 24:37.000
whether or not they are both true.

24:37.000 --> 24:40.000
You look at the first one.

24:40.000 --> 24:42.000
Is it true?

24:42.000 --> 24:44.000
If it's true, you compare it to the second one.

24:44.000 --> 24:48.000
Actually, let me be clear here.

24:48.000 --> 24:50.000
We have two functions, true and false.

24:50.000 --> 24:52.000
True returns the first value.

24:52.000 --> 24:54.000
False returns the second value.

24:54.000 --> 25:00.000
If A is a Boolean value, true or false,

25:00.000 --> 25:03.000
if it's true, it's going to return whatever B is.

25:03.000 --> 25:05.000
If it's false, it returns false right away

25:05.000 --> 25:08.000
because it's an and.

25:08.000 --> 25:10.000
If B is a true, then it's true.

25:10.000 --> 25:12.000
If B is false, then the whole thing is false.

25:12.000 --> 25:13.000
Does that make sense?

25:13.000 --> 25:15.000
That's why that looks like that.

25:15.000 --> 25:17.000
I can do it on the board too.

25:17.000 --> 25:19.000
I hate chalk.

25:20.000 --> 25:23.000
From my understanding, I see that basically,

25:23.000 --> 25:26.000
when you see lambda x, it means the function f.

25:26.000 --> 25:29.000
In the first situation, it takes two variables,

25:29.000 --> 25:31.000
f of x, y.

25:31.000 --> 25:33.000
In this case, it returns x.

25:33.000 --> 25:36.000
In the second question, it takes f of x, y.

25:36.000 --> 25:38.000
Then it returns y.

25:38.000 --> 25:40.000
In the third case, it takes two arguments

25:40.000 --> 25:42.000
and returns an and.

25:42.000 --> 25:44.000
That's basically it.

25:44.000 --> 25:46.000
That's the same thing.

25:46.000 --> 25:48.000
It really isn't more complicated than that.

25:48.000 --> 25:52.000
Does the notation is just what is causing the confusion?

25:52.000 --> 25:55.000
Here's the ultimate cop out.

25:55.000 --> 25:57.000
I didn't invent this notation.

25:57.000 --> 25:59.000
It provides us a universal language

25:59.000 --> 26:01.000
with which to speak about functions

26:01.000 --> 26:03.000
and function application.

26:03.000 --> 26:05.000
When I said this is what functional programming

26:05.000 --> 26:07.000
is all about, literally everything is a function.

26:07.000 --> 26:08.000
You've heard everything is a function.

26:08.000 --> 26:09.000
What does that really mean?

26:09.000 --> 26:11.000
Functions are values.

26:11.000 --> 26:14.000
We're just saying lambda x dot lambda y to x is true.

26:14.000 --> 26:16.000
It is the value true.

26:16.000 --> 26:19.000
We're loading truth as that function.

26:19.000 --> 26:21.000
Then we can do stuff with that function

26:21.000 --> 26:23.000
to build up more complicated expressions.

26:23.000 --> 26:25.000
There's an and, there's an or.

26:25.000 --> 26:27.000
We can do not.

26:29.000 --> 26:31.000
Now we have booleans.

26:31.000 --> 26:34.000
We're getting close to being able to do actual logic.

26:34.000 --> 26:36.000
It's all functions.

26:36.000 --> 26:39.000
I don't know how you feel about this inside your own head.

26:39.000 --> 26:41.000
This was mind-blowing for me when I first learned about it.

26:41.000 --> 26:43.000
Reducing expressions.

26:43.000 --> 26:45.000
We can take an and and a true and a false.

26:45.000 --> 26:47.000
We can take the lambdas back in.

26:47.000 --> 26:48.000
It looks like that.

26:48.000 --> 26:50.000
Already it's starting to be headache inducing.

26:50.000 --> 26:51.000
I know.

26:51.000 --> 26:55.000
The point is and a true false is identical to this expression.

26:55.000 --> 26:58.000
It's easier for us as people to deal with and true false

26:58.000 --> 27:00.000
than with all of this lambda stuff,

27:00.000 --> 27:02.000
but you can actually still work this out on paper.

27:02.000 --> 27:05.000
You can perform these reduction steps that I showed you.

27:05.000 --> 27:07.000
Ultimately, there's the first step of the reduction,

27:07.000 --> 27:09.000
another step of the reduction, another step, another step.

27:09.000 --> 27:11.000
By the way, the slides are all on GitHub,

27:11.000 --> 27:13.000
so you can play with this later if you like.

27:13.000 --> 27:15.000
Essentially, all of this reduces down to this function.

27:15.000 --> 27:17.000
These are the reduction steps.

27:17.000 --> 27:21.000
If you are plugging things in and replacing your bound values

27:21.000 --> 27:23.000
in the expressions at each step of the way,

27:23.000 --> 27:25.000
finally you get to lambda x dot lambda y dot lambda y,

27:25.000 --> 27:27.000
which we already know is false.

27:27.000 --> 27:28.000
That's how it works.

27:28.000 --> 27:30.000
That's how you do a computation anyway in lambda calculus.

27:30.000 --> 27:32.000
A very simple one.

27:37.000 --> 27:39.000
I can, but why do you want me to?

27:43.000 --> 27:45.000
I'm going to be honest with you.

27:45.000 --> 27:47.000
I hate touching chalk and I am trying to avoid it.

27:47.000 --> 27:49.000
I will do it if necessary,

27:49.000 --> 27:51.000
but I would just be writing that again.

27:51.000 --> 27:53.000
You want me to go through the whole thing?

27:53.000 --> 27:55.000
No, that's not.

27:55.000 --> 27:57.000
Totally, I will do it later, pen and paper,

27:57.000 --> 27:59.000
but it will take too long.

27:59.000 --> 28:01.000
I only have two hours.

28:01.000 --> 28:03.000
I think you were just saying the end in the last slide,

28:03.000 --> 28:05.000
you could just pop through it,

28:05.000 --> 28:07.000
but you didn't write it.

28:07.000 --> 28:09.000
Is it arbitrary like you're in false?

28:09.000 --> 28:11.000
Yes.

28:11.000 --> 28:13.000
I'm just going to say that's true and that's false.

28:15.000 --> 28:17.000
Just like truth and false in real life are arbitrary.

28:19.000 --> 28:21.000
You came for the deep stuff today.

28:23.000 --> 28:25.000
I know you want to look for some meaning,

28:25.000 --> 28:27.000
but I showed you that first slide with the,

28:29.000 --> 28:31.000
that's it, that's the whole language.

28:31.000 --> 28:33.000
Those three things are the whole language.

28:33.000 --> 28:35.000
I have to build the entire system of computation out of that,

28:35.000 --> 28:37.000
out of just functions.

28:37.000 --> 28:39.000
If I want to do Boolean operations,

28:39.000 --> 28:41.000
I need some notion of truth and false.

28:41.000 --> 28:43.000
If I want to do comparisons,

28:43.000 --> 28:45.000
I just have to invent them.

28:45.000 --> 28:47.000
I have to invent them in a way that they'll work

28:47.000 --> 28:49.000
and this happens to work.

28:49.000 --> 28:51.000
It seems like a bit of magic and I guess it is.

28:55.000 --> 28:57.000
You're saying that they're arbitrary,

28:57.000 --> 28:59.000
but they're not arbitrary

28:59.000 --> 29:01.000
in comparison to each other.

29:01.000 --> 29:03.000
These are built up in such a way that...

29:03.000 --> 29:05.000
The system is logically consistent.

29:05.000 --> 29:07.000
It actually has...

29:07.000 --> 29:09.000
It developed out of the study of logic, in fact.

29:09.000 --> 29:11.000
Formal logic.

29:11.000 --> 29:13.000
Not stuff I know a whole lot about.

29:13.000 --> 29:15.000
But yeah, they're not like random.

29:15.000 --> 29:17.000
They're sort of encodings that were decided upon

29:17.000 --> 29:19.000
as part of a system that is internally coherent.

29:21.000 --> 29:23.000
Wait till we get to numbers.

29:27.000 --> 29:29.000
Okay.

29:29.000 --> 29:31.000
So now that we have some Booleans,

29:31.000 --> 29:33.000
we can actually create useful functions.

29:33.000 --> 29:35.000
That determines whether or not a value is zero.

29:35.000 --> 29:37.000
I've rearranged this presentation

29:37.000 --> 29:39.000
since the last time I did some piece of it.

29:39.000 --> 29:41.000
So we don't have numbers yet.

29:41.000 --> 29:43.000
Bear with me.

29:43.000 --> 29:45.000
So let's say that X is a number.

29:45.000 --> 29:47.000
This function will tell you whether or not

29:47.000 --> 29:49.000
that number is zero.

29:51.000 --> 29:53.000
This is maybe an easier way to look at it.

29:55.000 --> 29:57.000
Is zero n?

29:57.000 --> 29:59.000
So is zero n is going to return

29:59.000 --> 30:01.000
a true or a false?

30:01.000 --> 30:03.000
And if it returns true,

30:03.000 --> 30:05.000
so we're applying...

30:05.000 --> 30:07.000
I think I need to maybe explain this a little bit better.

30:07.000 --> 30:09.000
So this is zero n

30:09.000 --> 30:11.000
is going to reduce down to a true or a false.

30:11.000 --> 30:13.000
We know that true returns the first value

30:13.000 --> 30:15.000
that it's given, right?

30:15.000 --> 30:17.000
So it's going to return true.

30:17.000 --> 30:19.000
If it's not zero, it will return false.

30:19.000 --> 30:21.000
Because false returns the second value.

30:21.000 --> 30:23.000
That's it.

30:23.000 --> 30:25.000
We're applying true and false to this function

30:25.000 --> 30:27.000
is zero n, yeah.

30:31.000 --> 30:33.000
So it's going to return true,

30:33.000 --> 30:35.000
and now you're talking about same features.

30:35.000 --> 30:37.000
So how do they match into the number?

30:37.000 --> 30:39.000
What is one for zero?

30:39.000 --> 30:41.000
Oh, you're going to love it.

30:41.000 --> 30:43.000
I think it's on the next slide.

30:43.000 --> 30:45.000
Yeah, yeah.

30:45.000 --> 30:47.000
I wanted to do predicates after a boolean,

30:47.000 --> 30:49.000
so the numbers are slightly out of order.

30:49.000 --> 30:51.000
So bear with me.

30:53.000 --> 30:55.000
Okay, so now we can have

30:55.000 --> 30:57.000
branching in our Lambda Calculus.

30:57.000 --> 30:59.000
We can say an if statement

30:59.000 --> 31:01.000
is simply a function

31:01.000 --> 31:03.000
that is a predicate, right?

31:03.000 --> 31:05.000
A predicate is a function that returns true or false.

31:05.000 --> 31:07.000
And then we apply to that

31:07.000 --> 31:09.000
two values, x and y.

31:09.000 --> 31:11.000
And if that predicate p is true,

31:11.000 --> 31:13.000
it will return the first value if it's false

31:13.000 --> 31:15.000
that returns the second value.

31:15.000 --> 31:17.000
Yeah.

31:17.000 --> 31:19.000
What's the definition of zero?

31:19.000 --> 31:21.000
You're saying is zero for a false.

31:21.000 --> 31:23.000
What is the definition of zero?

31:23.000 --> 31:25.000
We're going to get to that.

31:25.000 --> 31:27.000
Yeah.

31:27.000 --> 31:29.000
So that kind of would look like that, right?

31:29.000 --> 31:31.000
If n is zero,

31:31.000 --> 31:33.000
then you would do the value

31:33.000 --> 31:35.000
in that then branch.

31:35.000 --> 31:37.000
Otherwise, the else, right?

31:37.000 --> 31:39.000
And actually, we can factor out

31:39.000 --> 31:41.000
the p, the x, and the y.

31:41.000 --> 31:43.000
We can just say that if it's the identity function.

31:43.000 --> 31:45.000
It's the same thing really,

31:45.000 --> 31:47.000
because we're just dealing with predicates.

31:47.000 --> 31:49.000
Whoops.

31:49.000 --> 31:51.000
Right, that's...

31:51.000 --> 31:53.000
If you want to write it as like a little law for yourself, right?

31:53.000 --> 31:55.000
Expression one, expression two.

31:55.000 --> 31:57.000
If p is true, then e1, else e2.

31:57.000 --> 31:59.000
Okay. Everyone wants to do numbers.

31:59.000 --> 32:01.000
And you know what? I don't blame you, because

32:01.000 --> 32:03.000
how the heck do you do numbers with only functions?

32:03.000 --> 32:05.000
This is really where the whole idea

32:05.000 --> 32:07.000
of functions as values, I think, is going to

32:07.000 --> 32:09.000
make sense.

32:09.000 --> 32:11.000
I hope I'm going to drive this home for you.

32:13.000 --> 32:15.000
Speaking of arbitrary,

32:15.000 --> 32:17.000
we're going to call zero

32:17.000 --> 32:19.000
a function that takes

32:19.000 --> 32:21.000
an x and returns an x.

32:21.000 --> 32:23.000
It does nothing to it, right?

32:23.000 --> 32:25.000
We're just going to say that's zero.

32:29.000 --> 32:31.000
That's a zero, but it's just an encoding,

32:31.000 --> 32:33.000
ultimately. You can encode it in binary.

32:33.000 --> 32:35.000
That's another way of encoding it.

32:35.000 --> 32:37.000
Again, a convention.

32:37.000 --> 32:39.000
This symbol represents some idea

32:39.000 --> 32:41.000
of zero. We are so used to using it.

32:41.000 --> 32:43.000
We think, well, that's zero.

32:43.000 --> 32:45.000
And that's five.

32:45.000 --> 32:47.000
But it's just a symbol.

32:47.000 --> 32:49.000
There's one.

32:49.000 --> 32:51.000
Lambda f dot, lambda x

32:51.000 --> 32:53.000
dot f of x.

32:53.000 --> 32:55.000
You're going to see a pattern very soon.

32:55.000 --> 32:57.000
So now we're taking a function and a value,

32:57.000 --> 32:59.000
and we're applying the function to the value one time.

33:01.000 --> 33:03.000
There's two. There's three.

33:03.000 --> 33:05.000
You can probably guess what four looks like,

33:05.000 --> 33:07.000
and possibly 5,000 at this point.

33:07.000 --> 33:09.000
Because what is a number? If you're doing something

33:09.000 --> 33:11.000
with a number in computation,

33:11.000 --> 33:13.000
you may just be storing a value, but

33:13.000 --> 33:15.000
very likely you're probably going to be performing

33:15.000 --> 33:17.000
some operation that number of times, right?

33:17.000 --> 33:19.000
For any number n, you're going to do something

33:19.000 --> 33:21.000
three times. That's all that this is doing.

33:21.000 --> 33:23.000
Some number x.

33:23.000 --> 33:25.000
If you want to do something

33:25.000 --> 33:27.000
with the value three,

33:27.000 --> 33:29.000
then you apply, with a function,

33:29.000 --> 33:31.000
you apply that function to the value three times.

33:31.000 --> 33:33.000
Four, five.

33:35.000 --> 33:37.000
It gets ridiculous.

33:37.000 --> 33:39.000
And by the way, again, this is not variable binding.

33:41.000 --> 33:43.000
These are identical. I'm just using this

33:43.000 --> 33:45.000
as a convenient symbol. You could use poop emoji here, too, if you want.

33:45.000 --> 33:47.000
I want you to be able to read this.

33:47.000 --> 33:49.000
So, all of this stuff,

33:49.000 --> 33:51.000
I don't want to type that ever again.

33:51.000 --> 33:53.000
Especially when they start to get really big.

33:53.000 --> 33:55.000
So, I just attach convenient names to them

33:55.000 --> 33:57.000
for my own benefit.

33:57.000 --> 33:59.000
Now, enumeration. We can actually

33:59.000 --> 34:01.000
work with these numbers and get somewhere with them.

34:01.000 --> 34:03.000
There is a function that will tell you what the

34:03.000 --> 34:05.000
next value is for a given value n.

34:07.000 --> 34:09.000
This one's more complicated.

34:11.000 --> 34:13.000
I don't want to divert too much into these things.

34:13.000 --> 34:15.000
So, again, I'm not meant

34:15.000 --> 34:17.000
to be teaching you lambda calculus. This is taking too long.

34:17.000 --> 34:19.000
I just want to show you

34:19.000 --> 34:21.000
that you can do this kind of stuff

34:21.000 --> 34:23.000
and that this is the basis of functional programming.

34:23.000 --> 34:25.000
These are functional combinators

34:25.000 --> 34:27.000
where all values are functions

34:27.000 --> 34:29.000
and you can actually do computation with just functions.

34:31.000 --> 34:33.000
Pred is complicated

34:33.000 --> 34:35.000
and it actually was kind of a discovery at the time

34:35.000 --> 34:37.000
because they didn't know how to do it.

34:37.000 --> 34:39.000
And it will tell you the number.

34:39.000 --> 34:41.000
Suck of two is one

34:41.000 --> 34:43.000
and pred of...

34:43.000 --> 34:45.000
Sorry, suck of two is three

34:45.000 --> 34:47.000
and pred of two is one.

34:47.000 --> 34:49.000
That's what those are for.

34:49.000 --> 34:51.000
There's a reduction. You can write it out on paper

34:51.000 --> 34:53.000
if you don't believe me. It totally works.

34:53.000 --> 34:55.000
The number after one is definitely two

34:55.000 --> 34:57.000
and the number before one is definitely zero.

34:57.000 --> 34:59.000
They work. I tested these.

35:01.000 --> 35:03.000
Now we can do some complicated arithmetic.

35:03.000 --> 35:05.000
There's ad and at this point

35:05.000 --> 35:07.000
I'm going to start going a little faster

35:07.000 --> 35:09.000
because the actual encodings don't particularly matter.

35:09.000 --> 35:11.000
The fact that we can do them is what matters.

35:11.000 --> 35:13.000
Different ways of doing ad

35:13.000 --> 35:15.000
they both will give you the same result.

35:15.000 --> 35:17.000
Subtract, multiplication,

35:17.000 --> 35:19.000
exponent which is delightfully simple.

35:19.000 --> 35:21.000
Totally makes sense though

35:21.000 --> 35:23.000
that you're applying a function

35:23.000 --> 35:25.000
that gets applied a number of times

35:25.000 --> 35:27.000
to another function that gets applied a number of times.

35:27.000 --> 35:29.000
Now you have an exponent.

35:29.000 --> 35:31.000
Here's a reduction.

35:31.000 --> 35:33.000
If you add one and two together using functions you get three.

35:33.000 --> 35:35.000
You get a functional encoding of three.

35:35.000 --> 35:37.000
Now if you're doing functional programming

35:37.000 --> 35:39.000
you get this garbage.

35:39.000 --> 35:41.000
But this is the underlying substrate

35:41.000 --> 35:43.000
you might say of the functional computation

35:43.000 --> 35:45.000
and it ultimately gives you

35:45.000 --> 35:47.000
the correct answer that you want.

35:47.000 --> 35:49.000
This is just a very simple sort of program.

35:51.000 --> 35:53.000
Subtraction is a little bit more tedious.

35:53.000 --> 35:55.000
I mean tedious for me.

35:55.000 --> 35:57.000
I'm so terrified of being wrong.

35:57.000 --> 35:59.000
I sat down and wrote these out on paper.

35:59.000 --> 36:01.000
I encourage you to do that

36:01.000 --> 36:03.000
just to get an intuition for it.

36:03.000 --> 36:05.000
Multiplication and exponentiation.

36:05.000 --> 36:07.000
Look at that eight.

36:07.000 --> 36:09.000
I think it's crazy.

36:09.000 --> 36:11.000
All the parentheses.

36:11.000 --> 36:13.000
This is really the hot stuff.

36:13.000 --> 36:15.000
Raise your hand if you've heard of Y Combinator.

36:15.000 --> 36:17.000
Like the company, right?

36:17.000 --> 36:19.000
I hope you all end up...

36:19.000 --> 36:21.000
Do I hope that you all...

36:21.000 --> 36:23.000
No.

36:23.000 --> 36:25.000
Raise your hand if you've seen the Y Combinator.

36:25.000 --> 36:27.000
This Y Combinator.

36:27.000 --> 36:29.000
I don't know if you are aware of this

36:29.000 --> 36:31.000
but the company Y Combinator

36:31.000 --> 36:33.000
the name is based on this function.

36:33.000 --> 36:35.000
This is how you perform recursion

36:35.000 --> 36:37.000
in the simply...

36:37.000 --> 36:39.000
Sorry, the untyped lambda calculus.

36:39.000 --> 36:41.000
I referred earlier to fixed point

36:41.000 --> 36:43.000
combinators and this is a fixed point

36:43.000 --> 36:45.000
combinator for functions.

36:45.000 --> 36:47.000
Any function...

36:47.000 --> 36:49.000
For any function that you give fix

36:49.000 --> 36:51.000
it will return that function again

36:51.000 --> 36:53.000
and that is how you perform recursion.

36:53.000 --> 36:55.000
For example, everyone's favorite example,

36:55.000 --> 36:57.000
factorial.

36:57.000 --> 36:59.000
Here's a function that will perform a factorial

36:59.000 --> 37:01.000
but we need to do recursion to perform

37:01.000 --> 37:03.000
a factorial, right?

37:03.000 --> 37:05.000
We'll say factorial is

37:05.000 --> 37:07.000
going to be a function

37:07.000 --> 37:09.000
that is the fixed point of this function F.

37:09.000 --> 37:11.000
We're going to pass F to our

37:11.000 --> 37:13.000
fixed point...

37:13.000 --> 37:15.000
I didn't call it Y because I want to be clear.

37:15.000 --> 37:17.000
The fixed point combinator is a function

37:17.000 --> 37:19.000
that when you give it a function

37:19.000 --> 37:21.000
it will return that function again.

37:21.000 --> 37:23.000
It actually embeds the function into the expression

37:23.000 --> 37:25.000
in a way that you're going to see in a minute.

37:25.000 --> 37:27.000
Honestly, the details aren't important

37:27.000 --> 37:29.000
because you're not here to learn lambda calculus, honestly.

37:29.000 --> 37:31.000
But I want you to get a sense for it,

37:31.000 --> 37:33.000
an intuition, right?

37:33.000 --> 37:35.000
We're going to take the function F

37:35.000 --> 37:37.000
and we're going to pass it to the fixed point combinator

37:37.000 --> 37:39.000
and it looks like that.

37:39.000 --> 37:41.000
That's what we get in the first reduction step

37:41.000 --> 37:43.000
and you can see that F is now embedded into the recursion

37:43.000 --> 37:45.000
and that's how we can perform

37:45.000 --> 37:47.000
a factorial operation.

37:47.000 --> 37:49.000
There it is again

37:49.000 --> 37:51.000
and it looks like that.

37:51.000 --> 37:53.000
It will keep doing that until we're done,

37:53.000 --> 37:55.000
until we reach our base case.

37:55.000 --> 37:57.000
The base case, right?

37:57.000 --> 37:59.000
End part.

37:59.000 --> 38:01.000
Without the base case then it doesn't stop.

38:01.000 --> 38:03.000
It lets a lot of writing.

38:03.000 --> 38:05.000
I'm going to walk you through the recursion now

38:05.000 --> 38:07.000
step by step.

38:07.000 --> 38:09.000
I don't expect you to...

38:09.000 --> 38:11.000
This is mostly for entertainment.

38:11.000 --> 38:13.000
This is what it looks like when you write this out, right?

38:13.000 --> 38:15.000
We're going to calculate now the factorial of 2

38:15.000 --> 38:17.000
step by step

38:17.000 --> 38:19.000
and we're doing beta reduction right now.

38:19.000 --> 38:21.000
It's just text substitution.

38:21.000 --> 38:23.000
We're putting values into functions.

38:23.000 --> 38:25.000
I'm actually cheating a little bit

38:25.000 --> 38:27.000
because I'm not expanding all the lambda expressions

38:27.000 --> 38:29.000
because I know that...

38:29.000 --> 38:31.000
I know that

38:31.000 --> 38:33.000
whether or not a number is zero

38:33.000 --> 38:35.000
so I'm just doing this in my own head

38:35.000 --> 38:37.000
but this is an accurate representation

38:37.000 --> 38:39.000
of the reduction, right?

38:39.000 --> 38:41.000
At each step.

38:41.000 --> 38:43.000
It's almost legible, right?

38:43.000 --> 38:45.000
Even if you don't know lambda calculus

38:45.000 --> 38:47.000
you know a little bit of programming maybe.

38:47.000 --> 38:49.000
You can see how this would work

38:49.000 --> 38:51.000
to calculate a factorial

38:51.000 --> 38:53.000
and I end up with that

38:53.000 --> 38:55.000
and this one is two.

38:55.000 --> 38:57.000
I can do anything now, right?

38:59.000 --> 39:01.000
I have numbers, I have recursion,

39:01.000 --> 39:03.000
I have branching.

39:03.000 --> 39:05.000
I can calculate anything.

39:05.000 --> 39:07.000
You wouldn't want to calculate anything in lambda calculus

39:07.000 --> 39:09.000
like this but you could, in principle

39:09.000 --> 39:11.000
you could.

39:11.000 --> 39:13.000
I think that's the point.

39:13.000 --> 39:15.000
The first step of what's happening

39:15.000 --> 39:17.000
is getting substitutions and building

39:17.000 --> 39:19.000
that first step is getting substitutions

39:19.000 --> 39:21.000
and building this whole thing out

39:21.000 --> 39:23.000
and then the next step is evaluation

39:23.000 --> 39:25.000
and trying to figure it all down.

39:25.000 --> 39:27.000
Well, I mean

39:27.000 --> 39:29.000
not exactly.

39:29.000 --> 39:31.000
Okay, maybe the point

39:31.000 --> 39:33.000
is abstraction, right?

39:33.000 --> 39:35.000
Because I don't want to write lambda expressions

39:35.000 --> 39:37.000
but I want to be able to trust

39:37.000 --> 39:39.000
that this stuff is going to work

39:39.000 --> 39:41.000
without worrying about the notation.

39:41.000 --> 39:43.000
When you get to a real programming language

39:43.000 --> 39:45.000
then obviously you're not worrying about this.

39:45.000 --> 39:47.000
This is sort of how functional programming

39:47.000 --> 39:49.000
works at some very primitive level.

39:49.000 --> 39:51.000
You might think of it that way.

39:51.000 --> 39:53.000
When you write programs you're not writing stuff like this

39:53.000 --> 39:55.000
but if you're working with pure functions

39:55.000 --> 39:57.000
you don't worry about state

39:57.000 --> 39:59.000
then you know that

39:59.000 --> 40:01.000
when I write fact I'm really writing

40:01.000 --> 40:03.000
fact after what I'm writing all that lambda stuff

40:03.000 --> 40:05.000
and it will work the same every single time.

40:05.000 --> 40:07.000
I would rather work with

40:07.000 --> 40:09.000
named functions because they're easier for me

40:09.000 --> 40:11.000
and named values than with long

40:11.000 --> 40:13.000
lambda expressions.

40:21.000 --> 40:23.000
Yes?

40:23.000 --> 40:25.000
I wasn't going to say it yet

40:25.000 --> 40:27.000
but look, you get currying for free. It's right there.

40:27.000 --> 40:29.000
Because you're applying each argument one at a time.

40:31.000 --> 40:33.000
If you're familiar with currying that's what it is.

40:33.000 --> 40:35.000
Instead of applying all your arguments at once

40:35.000 --> 40:37.000
you can do them one at a time

40:37.000 --> 40:39.000
and you take a function, you apply an argument

40:39.000 --> 40:41.000
now you have a new function with that argument applied

40:41.000 --> 40:43.000
and then you do the next one and the next one.

40:43.000 --> 40:45.000
It's a freebie.

40:45.000 --> 40:47.000
Like referential transparency.

40:47.000 --> 40:49.000
That just means that

40:49.000 --> 40:51.000
when I was showing you earlier that these expressions

40:51.000 --> 40:53.000
triple equal sign or this name

40:53.000 --> 40:55.000
triple equal sign this expression

40:55.000 --> 40:57.000
that those are completely identical

40:57.000 --> 40:59.000
and you can do equational reasoning with these things

40:59.000 --> 41:01.000
and trust that it's always going to work

41:01.000 --> 41:03.000
because there's no such thing as global state

41:03.000 --> 41:05.000
there's no memory. This is not a Turing machine.

41:05.000 --> 41:07.000
It's just symbolic manipulation.

41:07.000 --> 41:09.000
Okay, so I told you I cheated a little bit

41:09.000 --> 41:11.000
with this example.

41:11.000 --> 41:13.000
Here's what the real thing looks like if you're working with just lambdas.

41:13.000 --> 41:15.000
Can you even read this?

41:15.000 --> 41:17.000
I blew it up, you can't read it anyway.

41:17.000 --> 41:19.000
So this is the whole thing and if you sat down

41:19.000 --> 41:21.000
and you worked this out with a pen

41:21.000 --> 41:23.000
and a piece of paper like I did

41:23.000 --> 41:25.000
so that in the event that someone was in the audience

41:25.000 --> 41:27.000
and did this and found that I was wrong I wouldn't be embarrassed.

41:27.000 --> 41:29.000
It works.

41:29.000 --> 41:31.000
These are the reduction steps

41:31.000 --> 41:33.000
for just as just factorial of 2

41:33.000 --> 41:35.000
if you did factorial of a higher number

41:35.000 --> 41:37.000
you get to the point where it will take you

41:37.000 --> 41:39.000
until the heat death of the universe to compute probably

41:39.000 --> 41:41.000
but you can see how the reduction steps

41:41.000 --> 41:43.000
ultimately get you to the same answer.

41:43.000 --> 41:45.000
There it is.

41:45.000 --> 41:47.000
lambdaf.lambdax.f.f of x

41:49.000 --> 41:51.000
is 2.

41:51.000 --> 41:53.000
So now you know the factorial of 2 is 2.

41:53.000 --> 41:55.000
That is the entirety

41:55.000 --> 41:57.000
of the syntax of lambda calculus I want to talk about.

41:57.000 --> 41:59.000
Are there any questions?

41:59.000 --> 42:01.000
No.

42:01.000 --> 42:03.000
That's more than I want it to do in fact.

42:03.000 --> 42:05.000
You mentioned a lot of paper and pen.

42:05.000 --> 42:07.000
When you're learning lambda calculus

42:07.000 --> 42:09.000
do you recommend paper and pen?

42:09.000 --> 42:11.000
No, paper and pen.

42:11.000 --> 42:13.000
It's easier.

42:13.000 --> 42:15.000
Why don't you check yourself

42:15.000 --> 42:17.000
because there's no compromise with what you're trying to do?

42:17.000 --> 42:19.000
It's a good question.

42:19.000 --> 42:21.000
How do you check yourself?

42:21.000 --> 42:23.000
I just did.

42:23.000 --> 42:25.000
This is a proof, right?

42:25.000 --> 42:27.000
It works.

42:27.000 --> 42:29.000
You can do it and make sure I did it right.

42:29.000 --> 42:31.000
In lambda calculus

42:31.000 --> 42:33.000
you know what 3 plus 0 is in real life.

42:33.000 --> 42:35.000
So you don't take 3 plus 0

42:39.000 --> 42:41.000
in lambda calculus and you know you did it wrong.

42:41.000 --> 42:43.000
Right.

42:43.000 --> 42:45.000
I'm establishing a principle essentially, yeah.

42:45.000 --> 42:47.000
So basically in the yw ychwanegwch,

42:47.000 --> 42:49.000
ychwanegwch, ychwanegwch, ychwanegwch,

42:49.000 --> 42:51.000
ychwanegwch, ychwanegwch, ychwanegwch,

42:51.000 --> 42:53.000
ychwanegwch, ychwanegwch, ychwanegwch.

42:53.000 --> 42:55.000
If you have a base case

42:55.000 --> 42:57.000
if you don't,

42:57.000 --> 42:59.000
then it diverges forever.

42:59.000 --> 43:01.000
It never converges on an answer.

43:01.000 --> 43:03.000
Similar to what?

43:03.000 --> 43:05.000
Similar to what?

43:05.000 --> 43:07.000
Like a for loop.

43:07.000 --> 43:09.000
I mean, yeah.

43:09.000 --> 43:11.000
I mean, yeah.

43:11.000 --> 43:13.000
I mean, I don't love comparisons

43:13.000 --> 43:15.000
to imperative programming constructs.

43:15.000 --> 43:17.000
This is what it is.

43:17.000 --> 43:19.000
This predates for loops.

43:19.000 --> 43:21.000
I thank.

43:21.000 --> 43:23.000
Pretty sure.

43:23.000 --> 43:25.000
Lambda calculus.

43:25.000 --> 43:27.000
Now we're going to do JavaScript.

43:27.000 --> 43:29.000
Thank God, right?

43:29.000 --> 43:31.000
Something everybody is familiar with.

43:31.000 --> 43:33.000
So I hope that everybody...

43:35.000 --> 43:37.000
Can everyone see that? Is that big enough?

43:37.000 --> 43:39.000
No, not.

43:39.000 --> 43:41.000
Okay, maybe.

43:41.000 --> 43:43.000
Oops.

43:43.000 --> 43:45.000
Oh, great.

43:49.000 --> 43:51.000
How about that?

43:52.000 --> 43:54.000
Or that. Is that good?

44:00.000 --> 44:02.000
Yeah, my normal background is even lower contrast.

44:02.000 --> 44:04.000
I thought maybe this would be easier.

44:04.000 --> 44:06.000
No, not so much.

44:08.000 --> 44:10.000
I can do dark...

44:10.000 --> 44:14.000
This is slightly different, but almost exactly identical.

44:14.000 --> 44:16.000
Let me see.

44:16.000 --> 44:18.000
Why am I using BBEdit?

44:18.000 --> 44:20.000
Um...

44:20.000 --> 44:22.000
Do you like this better?

44:22.000 --> 44:24.000
Yeah, okay.

44:30.000 --> 44:32.000
Hi.

44:32.000 --> 44:34.000
Bigger?

44:34.000 --> 44:36.000
Whatever, I don't care.

44:36.000 --> 44:39.000
So at this point, I hope you can all open up the file

44:39.000 --> 44:42.000
and open up your...

44:42.000 --> 44:44.000
Java...

44:44.000 --> 44:46.000
I'm doing this in Chrome, and I tested it in Safari

44:46.000 --> 44:48.000
and Firefox.

44:48.000 --> 44:50.000
I don't know off the top of my head how you open a JavaScript console

44:50.000 --> 44:53.000
in Safari or Firefox.

44:53.000 --> 44:55.000
Command-option-j

44:55.000 --> 44:57.000
in Chrome if you have

44:57.000 --> 45:00.000
the lambda.html page open.

45:03.000 --> 45:05.000
Sorry, question?

45:05.000 --> 45:07.000
Question?

45:07.000 --> 45:09.000
Okay, so now we're going to move more into

45:09.000 --> 45:12.000
more of a workshop format, because that was a little bit more explanation

45:12.000 --> 45:14.000
than I had wanted to do.

45:14.000 --> 45:16.000
You have all of the functions that I've shown you

45:16.000 --> 45:18.000
and a lot of other stuff,

45:18.000 --> 45:20.000
and what I want you to be able to do with now

45:20.000 --> 45:22.000
is really play with them in your browsers.

45:22.000 --> 45:24.000
The point is, I don't want to lecture at you.

45:24.000 --> 45:26.000
Here's what functional programming is all about.

45:26.000 --> 45:28.000
I actually want you to use these functions

45:28.000 --> 45:30.000
and build computations with them so you learn

45:30.000 --> 45:32.000
not only what functional programming is,

45:32.000 --> 45:34.000
you develop this intuition that will allow you to explain it

45:34.000 --> 45:36.000
to others.

45:36.000 --> 45:38.000
What does it mean when we say functions are values?

45:38.000 --> 45:41.000
That is the whole point of what I did this for.

45:41.000 --> 45:43.000
So type stuff in.

45:43.000 --> 45:45.000
As I go through these things.

45:45.000 --> 45:47.000
I'm just going to go through

45:47.000 --> 45:49.000
the code, essentially.

45:49.000 --> 45:51.000
I just want you to play with it in your browsers

45:51.000 --> 45:53.000
and see what you can come up with.

45:53.000 --> 45:55.000
There are a couple of little exercises that you can do if you want.

45:55.000 --> 45:57.000
I actually have never given

45:57.000 --> 45:59.000
these kinds of exercises for a group before,

45:59.000 --> 46:01.000
so I don't know how that will go over.

46:01.000 --> 46:03.000
We'll just find out.

46:03.000 --> 46:05.000
Now we're in JavaScript,

46:05.000 --> 46:07.000
maybe you'll see the magic for real.

46:07.000 --> 46:09.000
We're only going to use the anonymous arrow function

46:09.000 --> 46:11.000
to do everything.

46:11.000 --> 46:13.000
The same with operations.

46:13.000 --> 46:15.000
This is what I showed you.

46:15.000 --> 46:17.000
Alpha, beta, and eta conversion.

46:17.000 --> 46:19.000
If you type these in.

46:19.000 --> 46:21.000
These are like a little toy proofs.

46:21.000 --> 46:23.000
You know, they work.

46:23.000 --> 46:25.000
They're true.

46:25.000 --> 46:27.000
Oh, I should note also

46:27.000 --> 46:29.000
this file has a bunch of helper functions

46:29.000 --> 46:31.000
because we need to translate between

46:31.000 --> 46:33.000
JavaScript and lambdas.

46:33.000 --> 46:35.000
Otherwise we can't read anything.

46:35.000 --> 46:37.000
For example, I can type in one,

46:37.000 --> 46:39.000
but it looks like that.

46:39.000 --> 46:41.000
What you know is like a lamb to f lamb to x,

46:41.000 --> 46:43.000
f of x. We know that that's one,

46:43.000 --> 46:45.000
but...

46:45.000 --> 46:47.000
Good point.

46:47.000 --> 46:49.000
How about that?

46:49.000 --> 46:51.000
Okay.

46:51.000 --> 46:53.000
So here's our identity combinator,

46:53.000 --> 46:55.000
id equals x,

46:55.000 --> 46:57.000
returning x.

46:57.000 --> 46:59.000
Assuming everybody is either familiar

46:59.000 --> 47:01.000
with the JavaScript arrow syntax,

47:01.000 --> 47:03.000
or this is trivial enough

47:03.000 --> 47:05.000
that you can pick it up.

47:05.000 --> 47:07.000
Here's our true and false.

47:07.000 --> 47:09.000
It takes two values, x and y,

47:09.000 --> 47:11.000
and returns x is true, and the opposite is false.

47:11.000 --> 47:13.000
Again, you can

47:13.000 --> 47:15.000
cut and paste these things

47:15.000 --> 47:17.000
to test them.

47:17.000 --> 47:19.000
I have a two-bool function

47:19.000 --> 47:21.000
that you can...

47:21.000 --> 47:23.000
and true, false.

47:23.000 --> 47:25.000
Returns false.

47:25.000 --> 47:27.000
They work, thankfully.

47:27.000 --> 47:29.000
At some point you will probably be able

47:29.000 --> 47:31.000
to break this because

47:31.000 --> 47:33.000
JavaScript isn't designed for

47:33.000 --> 47:35.000
deeply nested function calls.

47:35.000 --> 47:37.000
Try calculating the factorial of, like, 10.

47:39.000 --> 47:41.000
So here we have and, we have or, we have not,

47:41.000 --> 47:43.000
and play with this stuff.

47:43.000 --> 47:45.000
See what you can do.

47:45.000 --> 47:47.000
That's kind of all I want you to do right now.

47:47.000 --> 47:49.000
And true and true returns true, right?

47:49.000 --> 47:51.000
And false, false returns false.

47:51.000 --> 47:53.000
Well, actually, this probably won't work

47:53.000 --> 47:55.000
because these are just functions.

47:55.000 --> 47:57.000
Oh, look, it works. How about that?

47:57.000 --> 47:59.000
If I type in plus,

47:59.000 --> 48:01.000
any plus expression,

48:01.000 --> 48:03.000
it looks the same,

48:03.000 --> 48:05.000
but then the true and true

48:05.000 --> 48:07.000
works instead of right now.

48:07.000 --> 48:09.000
What do you mean?

48:09.000 --> 48:11.000
If I type in 1 plus 1, 5.

48:11.000 --> 48:13.000
Oh, you did like that?

48:13.000 --> 48:15.000
No, no, with the constant for the named functions.

48:15.000 --> 48:17.000
You did this?

48:17.000 --> 48:19.000
1, 5?

48:19.000 --> 48:21.000
Correct. I'll change the second over to 3.

48:21.000 --> 48:23.000
It's going to look the same.

48:23.000 --> 48:25.000
Oh, that's...

48:25.000 --> 48:27.000
But your true and true function does work in this way?

48:27.000 --> 48:29.000
Yeah.

48:29.000 --> 48:31.000
I don't know why it does that.

48:31.000 --> 48:33.000
It's just the way the Chrome console works.

48:33.000 --> 48:35.000
It's just a situation.

48:39.000 --> 48:41.000
Chrome's like, what are you doing?

48:41.000 --> 48:43.000
No, it wasn't.

48:43.000 --> 48:45.000
Yeah, so we have to...

48:45.000 --> 48:47.000
You can look at the utility functions.

48:47.000 --> 48:49.000
They're at the bottom of the file.

48:49.000 --> 48:51.000
Just for convenience, I'm converting back and forth

48:51.000 --> 48:53.000
between these lambda expressions and primitive values.

48:53.000 --> 48:55.000
Okay, so a little exercise.

48:55.000 --> 48:57.000
Try to implement XOR, right?

48:57.000 --> 48:59.000
I've given you and or not.

48:59.000 --> 49:01.000
See if you can come up with XOR

49:01.000 --> 49:03.000
and what that would look like.

49:07.000 --> 49:09.000
When someone comes up with it,

49:09.000 --> 49:11.000
raise your hand.

49:11.000 --> 49:13.000
We don't need to take all day.

49:24.000 --> 49:26.000
Anyone have a good XOR implementation?

49:34.000 --> 49:36.000
Brad, this is exclusive or...

49:42.000 --> 49:44.000
No, I'm not trying to trick you.

49:44.000 --> 49:46.000
I mean, I haven't written it for me yet,

49:46.000 --> 49:48.000
but it's basically A and not B

49:48.000 --> 49:50.000
or not A and B.

49:52.000 --> 49:54.000
I think that's what I got.

49:54.000 --> 49:56.000
Right?

49:58.000 --> 50:00.000
You can test it.

50:00.000 --> 50:02.000
I don't know if I've actually typed this in XOR.

50:02.000 --> 50:04.000
Yeah, so...

50:04.000 --> 50:06.000
I haven't actually typed it in yet, so...

50:06.000 --> 50:08.000
Yeah, I encourage you to test these things, too.

50:08.000 --> 50:10.000
Prove it to yourself, right?

50:10.000 --> 50:12.000
Don't believe me.

50:12.000 --> 50:14.000
Or find mistakes.

50:14.000 --> 50:16.000
There are a couple of little weird bugs.

50:16.000 --> 50:18.000
Well, there's one that I can think of

50:18.000 --> 50:20.000
that you probably won't encounter.

50:20.000 --> 50:22.000
By and large, this works about 99%,

50:22.000 --> 50:24.000
which is pretty good for JavaScript, right?

50:28.000 --> 50:30.000
Here's branching.

50:30.000 --> 50:32.000
Remember before I said that,

50:32.000 --> 50:34.000
in principle,

50:34.000 --> 50:36.000
the if-then-else statement you can write

50:36.000 --> 50:38.000
is this function

50:38.000 --> 50:40.000
that takes a predicate, right?

50:40.000 --> 50:42.000
A function that returns true or false.

50:42.000 --> 50:44.000
And then two values, X or Y.

50:44.000 --> 50:46.000
And if P is true, it returns X.

50:46.000 --> 50:48.000
If it's false, it returns Y.

50:48.000 --> 50:50.000
And as we did with Lambda Calculus,

50:50.000 --> 50:52.000
you can do this in JavaScript.

50:52.000 --> 50:54.000
You can factor out the X, factor out the Y,

50:54.000 --> 50:56.000
factor out the P, and it's just the same function as ID.

50:58.000 --> 51:00.000
Now you can write...

51:00.000 --> 51:02.000
I don't know.

51:04.000 --> 51:06.000
If-then-else.

51:06.000 --> 51:08.000
So if this is true,

51:08.000 --> 51:10.000
return true, if not return...

51:10.000 --> 51:12.000
Maybe that'll work. That works.

51:14.000 --> 51:16.000
Here are the natural numbers.

51:16.000 --> 51:18.000
Here are some enumeration functions.

51:18.000 --> 51:20.000
I can explain a little bit

51:20.000 --> 51:22.000
how predecessor works.

51:22.000 --> 51:24.000
It essentially will take

51:24.000 --> 51:26.000
a pair of values,

51:26.000 --> 51:28.000
a pair of zeros,

51:28.000 --> 51:30.000
and it will increment one of them

51:30.000 --> 51:32.000
up to the point.

51:32.000 --> 51:34.000
A predecessor of five.

51:34.000 --> 51:36.000
It'll increment one of those values to five.

51:36.000 --> 51:38.000
And it will increment the other one.

51:38.000 --> 51:40.000
It will skip one of the incrementations.

51:40.000 --> 51:42.000
Increments.

51:42.000 --> 51:44.000
It will skip one of the increments.

51:44.000 --> 51:46.000
Then you get five and four,

51:46.000 --> 51:48.000
and then it selects for the four.

51:50.000 --> 51:52.000
That's something I could probably

51:52.000 --> 51:54.000
demonstrate at great length,

51:54.000 --> 51:56.000
but it would take too long, and so I won't.

51:56.000 --> 51:58.000
But I do have a reduction to show you on that.

51:58.000 --> 52:00.000
And because

52:00.000 --> 52:02.000
this talk is

52:02.000 --> 52:04.000
for people who don't want to learn Lambda Calculus,

52:04.000 --> 52:06.000
I don't care if you learn Lambda Calculus.

52:06.000 --> 52:08.000
I just want you to get comfortable working with functions

52:08.000 --> 52:10.000
so that you can understand their expressive power

52:10.000 --> 52:12.000
and why we do functional programming.

52:14.000 --> 52:16.000
We're building actually an entire programming language

52:16.000 --> 52:18.000
within your JavaScript console right now.

52:18.000 --> 52:20.000
I don't know if that's apparent.

52:20.000 --> 52:22.000
You can start putting more complicated things together

52:22.000 --> 52:24.000
with these primitives,

52:24.000 --> 52:26.000
and ultimately, in principle, you can do anything.

52:26.000 --> 52:28.000
I'm not saying that you should write programs

52:28.000 --> 52:30.000
out of these Lambdas.

52:30.000 --> 52:32.000
I'm really nervous right now because

52:32.000 --> 52:34.000
John said earlier at the end of the keynote

52:34.000 --> 52:36.000
that these workshops are meant to be teaching skills.

52:38.000 --> 52:40.000
Much from doing that, yeah.

52:40.000 --> 52:42.000
No, yeah.

52:52.000 --> 52:54.000
Yeah.

52:54.000 --> 52:56.000
Yeah.

52:58.000 --> 53:00.000
I'm not clear on how that evaluates us through.

53:00.000 --> 53:02.000
Does that make sense?

53:02.000 --> 53:04.000
Yeah, I'll try.

53:04.000 --> 53:06.000
Let's see.

53:08.000 --> 53:10.000
Let's say, we'll say A equals,

53:10.000 --> 53:12.000
so let's say,

53:12.000 --> 53:14.000
hmm.

53:14.000 --> 53:16.000
I can apply

53:16.000 --> 53:18.000
true to the and function.

53:18.000 --> 53:20.000
And I'll just get another function back.

53:22.000 --> 53:24.000
Yeah.

53:24.000 --> 53:26.000
It's in there. I closed over it.

53:26.000 --> 53:28.000
I would think that the X would be true now.

53:30.000 --> 53:32.000
It is.

53:32.000 --> 53:34.000
But I haven't evaluated the function.

53:34.000 --> 53:36.000
I haven't reduced.

53:36.000 --> 53:38.000
If I two-bould my little A function,

53:38.000 --> 53:40.000
it gives me, you know,

53:40.000 --> 53:42.000
it doesn't know what I'm trying to do.

53:42.000 --> 53:44.000
No meaning.

53:44.000 --> 53:46.000
So I've actually partially applied the true to my and.

53:46.000 --> 53:48.000
So now I can apply the false.

53:48.000 --> 53:50.000
Let's say B is A

53:50.000 --> 53:52.000
applied to false.

53:52.000 --> 53:54.000
Now B is fully applied.

53:57.000 --> 53:59.000
Now I can two-bool on the B.

54:04.000 --> 54:06.000
Is that meaningful

54:06.000 --> 54:08.000
as far as reduction steps are concerned?

54:12.000 --> 54:14.000
Let's see.

54:14.000 --> 54:16.000
OK. No problem.

54:16.000 --> 54:18.000
You're making me think on my feet.

54:18.000 --> 54:20.000
It's good.

54:20.000 --> 54:22.000
I can just type it in.

54:22.000 --> 54:24.000
Right?

54:24.000 --> 54:26.000
So this is

54:26.000 --> 54:28.000
a function after all.

54:28.000 --> 54:30.000
That's not special.

54:32.000 --> 54:34.000
So this is

54:36.000 --> 54:38.000
this is and, right?

54:38.000 --> 54:40.000
So I want to apply.

54:40.000 --> 54:42.000
In fact, I'll even replace the false with

54:44.000 --> 54:46.000
I don't know.

54:46.000 --> 54:48.000
I've not done this before.

54:48.000 --> 54:50.000
So why not do it the hard way?

54:50.000 --> 54:52.000
That's my motto in life.

54:52.000 --> 54:54.000
OK.

54:54.000 --> 54:56.000
So I'm actually going to get rid of the two-bool

54:56.000 --> 54:58.000
because it's going to confuse me for a moment.

55:00.000 --> 55:02.000
I think that that looks right.

55:02.000 --> 55:04.000
I think that's the and function.

55:04.000 --> 55:06.000
Right?

55:06.000 --> 55:08.000
So now I can apply

55:08.000 --> 55:10.000
like a true to it, for example.

55:10.000 --> 55:12.000
But instead of applying the true,

55:12.000 --> 55:14.000
let's just kill off

55:14.000 --> 55:16.000
the X

55:16.000 --> 55:18.000
and put it in there.

55:22.000 --> 55:24.000
Let me start over

55:24.000 --> 55:26.000
because I'm going to confuse myself.

55:26.000 --> 55:28.000
I'm glad we're doing this because

55:28.000 --> 55:30.000
this is the point.

55:30.000 --> 55:32.000
I don't care.

55:32.000 --> 55:34.000
It's helpful for me.

55:34.000 --> 55:36.000
This talks about me.

55:36.000 --> 55:38.000
It's not about you.

55:38.000 --> 55:40.000
I actually might leave the

55:40.000 --> 55:42.000
false in as it is because you get the idea

55:42.000 --> 55:44.000
and I don't want to waste time being confused.

55:44.000 --> 55:46.000
OK. So there's the true. We're going to apply this to true.

55:46.000 --> 55:48.000
But instead of doing that, we'll kill off

55:48.000 --> 55:50.000
that X and we'll just stick it there.

55:50.000 --> 55:52.000
I need some other boolean value, right?

55:52.000 --> 55:54.000
Because we need two branches.

55:54.000 --> 55:56.000
So let's say the other branch

55:56.000 --> 55:58.000
is false.

55:58.000 --> 56:00.000
Right. So now I kill off

56:00.000 --> 56:02.000
the Y

56:02.000 --> 56:04.000
and now I have false.

56:04.000 --> 56:06.000
OK.

56:06.000 --> 56:08.000
But remember true is also just a function.

56:08.000 --> 56:10.000
It's a function X, Y

56:10.000 --> 56:12.000
that returns X.

56:12.000 --> 56:14.000
Right? So then we have

56:14.000 --> 56:16.000
this false.

56:16.000 --> 56:18.000
We take that

56:18.000 --> 56:20.000
and pull off this X

56:20.000 --> 56:22.000
and then it's there.

56:22.000 --> 56:24.000
OK.

56:24.000 --> 56:26.000
Then we have another false

56:26.000 --> 56:28.000
and we apply that to Y

56:28.000 --> 56:30.000
and then we're left with false.

56:30.000 --> 56:32.000
Does that last a little bit there?

56:32.000 --> 56:34.000
We say you're applying the Y

56:34.000 --> 56:36.000
and when you have the false, it was done

56:36.000 --> 56:38.000
just two falses.

56:38.000 --> 56:40.000
Is that why?

56:40.000 --> 56:42.000
You know, it's tricky

56:42.000 --> 56:44.000
because I'm just branching using booleans.

56:44.000 --> 56:46.000
I'm not branching using real expressions.

56:46.000 --> 56:48.000
Maybe if I say

56:48.000 --> 56:50.000
you know, is 0, 1

56:50.000 --> 56:52.000
true otherwise false

56:52.000 --> 56:54.000
something like that.

56:54.000 --> 56:56.000
It was helpful that you reminded me

56:56.000 --> 56:58.000
that it was a function.

56:58.000 --> 57:00.000
Yeah, yeah.

57:00.000 --> 57:02.000
Remember, everything is a function.

57:02.000 --> 57:04.000
You don't really know what it means.

57:04.000 --> 57:06.000
Everything is a function.

57:06.000 --> 57:08.000
Functional programming is programming with functions.

57:08.000 --> 57:10.000
No, it's not intuitive at all.

57:10.000 --> 57:12.000
I don't think it's intuitive.

57:12.000 --> 57:14.000
But once it becomes intuitive,

57:14.000 --> 57:16.000
one is a function.

57:16.000 --> 57:18.000
Right, no.

57:18.000 --> 57:20.000
You think I'm trying to trick you, right?

57:20.000 --> 57:22.000
Programming, I must have embedded primitive values

57:22.000 --> 57:24.000
into this somewhere, right?

57:24.000 --> 57:26.000
I have not. They're all just functions.

57:26.000 --> 57:28.000
They're simply encoding.

57:28.000 --> 57:30.000
I'm a human being. I'm going to say this is true.

57:30.000 --> 57:32.000
The computer or the notation doesn't know

57:32.000 --> 57:34.000
what true means.

57:36.000 --> 57:38.000
True and false are really bad names.

57:38.000 --> 57:40.000
Names are hard, right?

57:40.000 --> 57:42.000
This is not philosophy, it's just computation.

57:42.000 --> 57:44.000
I'm just trying to make decisions.

57:44.000 --> 57:46.000
Is zero false? Why?

57:46.000 --> 57:48.000
No, really, I want to know.

57:50.000 --> 57:52.000
Does JavaScript think zero is false?

57:52.000 --> 57:54.000
I don't even remember.

57:58.000 --> 58:00.000
That's reassuring.

58:00.000 --> 58:02.000
It's not reassuring that that's not a type error.

58:06.000 --> 58:08.000
Actually, it should return something like that, probably.

58:08.000 --> 58:10.000
Anyway.

58:10.000 --> 58:12.000
What does double equals do?

58:12.000 --> 58:14.000
Oh, man.

58:38.000 --> 58:40.000
No.

58:40.000 --> 58:42.000
No.

58:42.000 --> 58:44.000
No.

58:44.000 --> 58:46.000
No.

58:46.000 --> 58:48.000
No.

58:48.000 --> 58:50.000
No.

58:50.000 --> 58:52.000
No.

58:52.000 --> 58:54.000
No.

58:54.000 --> 58:56.000
No.

58:56.000 --> 58:58.000
No.

58:58.000 --> 59:00.000
No.

59:02.000 --> 59:04.000
No.

59:04.000 --> 59:06.000
No.

