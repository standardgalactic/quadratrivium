start	end	text
0	10000	Rwy'n cael ei ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud.
30000	43000	So, welcome everybody to this workshop, Lambda Calculus for people who can't be bothered to learn it.
43000	52000	I was surprised to see on the schedule, I think there are at least four Lambda Calculus related workshops and presentations at this conference.
52000	56000	That's a lot of Lambda Calculus. Did any of you go to the six hour one yesterday?
57000	69000	Dana Scott? All day? How was that? I'm sure way over my head. This will not be a reprise of that at all.
69000	76000	For people who can't be bothered to learn it part, that is because I'm not really going to teach you all of Lambda Calculus.
76000	80000	It is actually quite a deep subject, there's a lot to it, there are many different Lambda Calculi.
80000	87000	I'm mostly going to be doing a little bit with the simply type Lambda Calculus, which I think is something anybody can learn pretty quickly.
87000	96000	And it can actually be a little bit fun. Also though we're going to be implementing it in America's favorite programming language, JavaScript.
96000	103000	Now this is not because I recommend JavaScript for functional programming or any practical purpose whatsoever.
103000	109000	It's because I don't want to have to ask everybody to install Haskell or some other language.
109000	115000	You all have JavaScript on your machines already. For those of you who don't know this, you may be slightly surprised by that fact.
115000	121000	But I assume all of you know this in your browsers, you have a console, it runs JavaScript, that's all you need. So easy for me.
121000	129000	I'm also not going to be using very much of the JavaScript syntax such as it is at all. Just anonymous functions, but we'll get to that.
130000	140000	So again, just to reiterate, please stop me, ask questions. I don't generally like the Socratic method of teaching, but let's see if you can read my mind.
140000	147000	What do you suppose is maybe the simplest, what you might think of as the dumbest possible question you might ask about Lambda Calculus?
147000	150000	Anyone want to take a guess? I'll never do this again.
151000	152000	Why?
152000	153000	Why what?
161000	164000	Why do you need to bother?
166000	168000	That's a smart question. I'm looking for a dumb question.
171000	175000	That's it. Yeah, why is it called Lambda Calculus? Does anyone actually know why it's called Lambda Calculus? I know you know.
176000	181000	No, no, no, no. I don't want you to. Yeah. Yeah. Yeah. Okay. Good. I'm glad for all of you people know.
181000	187000	This is an important point. It seems like a trivial point. This might be a little bit of mythology. Very quickly. I think it's kind of funny.
187000	192000	All right. People are afraid of this. It's got a Greek letter. It's called Calculus. If you're not a math person, I'm not a math person. It sounds scary, right?
192000	198000	Forget the calculus part. You know, we're going to count some things with it or something like that. So forget calculus.
198000	203000	But Lambda, what is this Lambda thing? A little bit intimidating. This whole conference is about Lambdas, right? Lambda comp.
203000	225000	Well, Alonso Church, the person who developed, discovered, invented Lambda Calculus, the story that I read in academic literature was that he actually wanted to use some notation from, I guess, the 18th century that looked something like this, actually like a little hat.
226000	235000	If he had gotten his way, we'd be calling it hat calculus, I suppose. I know that sounds funny, but there actually is a hat calculus. Look it up on Wikipedia. It became a different thing.
235000	246000	Back then, professors had secretaries. I'm actually a recovering English professor. I never had a secretary. But typewriters couldn't do that.
246000	260000	So his secretary ended up kind of doing that to represent it. He could do that with some slashes. This could all be a myth. I don't know. What does that look like? Yeah, capital Lambda, right? That's it.
260000	269000	So they called it Lambda Calculus and eventually went lowercase. I suppose it looks nicer. They use this for type systems now. That's it. So what is the point?
269000	280000	I mean, okay, it's like a little bit of a factoid. Completely arbitrary, right? These are not things to be scared of. All of the names that are used in Lambda Calculus and much of functional programming, they're just arbitrary names.
280000	293000	There's nothing to worry about. They sound a little bit intimidating. They certainly intimidated me. I may be more easily intimidated than all of you. But the point is like, who cares? It doesn't even matter. These names are not important.
294000	307000	Okay. I'm not going to do a lot of slides. In fact, originally, I wasn't going to do any, but I thought it's probably worthwhile to introduce the syntax of Lambda Calculus a little bit before going straight into JavaScript.
307000	317000	I need to ease you into JavaScript because I know it's a little bit painful. And I should introduce myself. This is my name, Stephen Syrac, in case you're wondering about the pronunciation. I'm SJ Syrac in all the places.
318000	334000	And like I said, I'm a recovering English professor. And I just want to point out to you that if I can do this, you can do this. I've not been doing this for very long. I taught myself Lambda Calculus while I was learning Haskell not very long ago.
334000	341000	I think I started a year and a half ago at the most. And I became very excited about it enough that I was willing to do this right now.
341000	348000	So I want to make that point not only because I want to be encouraging to all of you, but because there are two purposes to this talk in my mind.
348000	357000	One is that maybe I can communicate something about Lambda Calculus to you and why it's useful, why it's awesome, why it's the foundation of everything that this conference is about.
357000	367000	But also, and for me more importantly, and for those of you who do have experience, and by the way, those of you who do have experience, feel free at any time to tell me when I'm wrong.
367000	372000	I need that and I appreciate it. And also please help others around you.
372000	378000	I want everyone to be able to come away from this presentation able to teach this material to somebody else.
378000	383000	The only way the functional programming world is going to grow is if all of us become teachers.
383000	387000	Maybe that sounds like an extreme statement, but we're a very small community.
387000	393000	And for our own self-preservation, we need to expand, like expand or die.
393000	396000	And the other reason I'm using JavaScript is precisely for this reason.
396000	402000	You can go back to your places of work or to your friends if you can convince them to learn something called Lambda Calculus.
402000	410000	And everybody has a web browser and you will be able to open that up and show them some things without having them install a complicated programming language or some software they don't understand.
410000	412000	Because like I said, anybody can learn this.
412000	419000	So if you already feel competent with this material, then at the very least you can help me develop this into a better presentation for teaching others.
419000	423000	And then find a way to use this material to teach your colleagues, right?
423000	432000	Because you may not get them to install Haskell, but you can get them to open up a browser and then you can just immediately start writing functions and show them how this stuff works.
432000	436000	Okay, so that's enough motivation I think.
436000	438000	Are there any questions at this point?
438000	443000	I know that you wanted me to go over purposes and aims or something.
443000	455000	Perhaps just some specific examples of how perhaps Lambda has helped you to better understand or other ways to change the way you approach my house.
455000	458000	We don't program any Lambda Calculus.
458000	459000	This is a mental exercise.
459000	461000	Don't you?
461000	462000	Don't you?
462000	468000	That's very heavy, but it's a useful exercise for the ultimate American language.
468000	470000	Thank you for asking.
470000	475000	I think it's really useful for developing an intuition for what functional programming is all about.
475000	481000	Raise your hand if you're really not sure what functional programming is.
481000	483000	Yeah, honest people.
483000	485000	Yeah, exactly.
485000	489000	Raise your hand if you think that you would be able to competently explain it to somebody else.
489000	492000	That's the other kind of question.
492000	496000	Functional programming is programming with functions.
496000	497000	So helpful.
497000	502000	I think actually this material will really show you what functional programming is all about.
502000	505000	It's elementary particles as it were.
505000	510000	What has Lambda Calculus itself taught me about programming?
510000	513000	I think I only have a boring answer to that question.
513000	515000	Haskell is a Lambda Calculus.
515000	518000	So I made this joke, don't we program with Lambda Calculus?
518000	522000	Yes, if you're using functional programming language or using Lambda Calculus, you just may not know it.
522000	524000	So at the very least now you'll know it.
524000	529000	I never really thought about how Lambda Calculus specifically...
529000	534000	I mean, I suppose I can look at a function and know that I'm doing Ada reduction now,
534000	536000	or that maybe I should do Ada reduction.
536000	541000	I guess there are places in which it helps me with refactoring or conceptualizing.
541000	545000	I'm not going to be talking specifically about that, I don't think.
545000	553000	I guess I would maybe be able to talk about how Lambda Calculus gives us for free all of these features that we hear about
553000	555000	when we talk about FP, right?
555000	561000	Referential transparency, immutability, currying.
561000	563000	What are some other good ones?
563000	565000	I don't know, fixed point recursion?
565000	568000	Anyway, that stuff all just sort of falls out for free from Lambda Calculus.
568000	570000	Anyway, let's get to it.
570000	571000	This is the whole language, right?
571000	573000	World's smallest programming language.
573000	577000	Maybe actually the first programming language invented.
577000	581000	1933, anyone know the date? 1933?
581000	583000	I think it up in Wikipedia, Alonso Church, Lambda Calculus.
583000	585000	Before there were computers, right?
585000	588000	They got it right the first time.
588000	594000	This is the whole language right here.
594000	597000	Concentrating first on the first line.
597000	603000	Anything in Lambda Calculus is an expression, and then there are three kinds of expressions.
603000	607000	Names, functions, and applications, and that's it.
607000	611000	A function can be a name, so the lambda name.
611000	613000	I'm going to explain all this a little bit in more detail.
613000	618000	Lambda name.expression, and an application is just two expressions next to each other.
618000	623000	So you can see how this is a bit of a recursively defined language.
623000	629000	The lambda in the second line, that's the famous lambda that everybody wears.
629000	631000	Does anyone have a lambda on their t-shirt right now?
631000	635000	I'd be surprised, actually, if nobody did.
635000	638000	You're probably all wearing one on your lanyard thing.
638000	640000	It's just an abstraction operator.
640000	643000	If you're a programmer, you're used to abstraction, even if you don't know functional programming.
643000	653000	All that is saying is create an abstraction called name and bind to that, this expression, whatever the expression is.
653000	658000	And then function application is two expressions next to each other.
658000	664000	So if you're used to Haskell syntax, the reason why we don't have parentheses in Haskell is because function application is kind of the only operation we have.
664000	669000	So we keep it simple. It's just two expressions next to each other.
669000	675000	I'm so happy to have a blackboard. I don't do slides, so I'm more used to blackboards personally.
675000	678000	God, this is like very fat chalk.
678000	684000	I will be showing some expressions soon, but I just want to make this point.
684000	689000	So you can have something like lambda x dot x.
689000	692000	We actually call this the identity function.
692000	703000	And this part here, we can call it the head, this part is the body.
703000	708000	This is an expression.
708000	711000	Obviously x has no meaning. This is an abstract syntax.
711000	721000	Whatever you have here, whatever the expression is, it's just some stuff that we're going to compute under this thing, lambda x.
721000	727000	You've heard anonymous function. I don't like anonymous function. It doesn't have a name. It doesn't matter.
727000	732000	This operator creates an abstraction out of this expression.
732000	736000	And the x just means that this x and this x are the same.
736000	747000	If you're used to functions that look something like this, it's just text substitution, really.
748000	751000	Really, it's just text substitution. This was invented before there were computers.
751000	756000	In fact, with the lambda calculus, as simple as it is, you can model any computation whatsoever.
756000	758000	That's what's really neat about it. Maybe that's a good answer to your question.
758000	761000	You can compute anything that can be computed with this.
761000	764000	It doesn't seem like you should be able to. I'll prove that.
764000	768000	I mean, there are things you can't compute, and there are things you can,
768000	774000	and that's just sort of a property of nature, and this sort of captures that in the simplest possible way.
774000	778000	So, there's an expression, x. It's just something, something x.
778000	781000	Lambda x.x, I just showed you that. This is a function.
781000	787000	Body dot body dot, sorry, head dot body.
787000	796000	Lambda x.lambda y.xy. This is another expression, and you can think of this as a function with two arguments, x and y.
797000	801000	Lambda x.x, in parentheses, applied to y.
801000	806000	This is not terribly different than if you had simply x, y.
806000	813000	This is also function application. This lambda x.x, y is also function application.
813000	818000	By function application, again, I mean text substitution.
818000	823000	It's probably worth not thinking too much about functions as procedures,
823000	827000	or what you're used to in imperative programming languages.
827000	835000	Lambda x.xy.
835000	838000	Function application means we're doing text substitution,
838000	843000	so the y substitutes for this x in the expression.
843000	848000	This goes away, and we're just left with y.
848000	853000	Y goes into x, turns into y.
853000	861000	This is also a function application, and it's not more complicated.
861000	867000	They get longer and more, they look trickier, but ultimately the rules are the same.
867000	872000	Lambda x.x, lambda y.
872000	874000	Anybody want to guess what this turns into?
875000	881000	Because this whole thing goes into here and is substituted for this x,
881000	884000	so we're just left with that.
884000	888000	This is one of the operations, actually, beta reduction.
888000	891000	Anybody want to get another guess for the audience?
891000	896000	When we say alpha substitution or alpha conversion, where does the alpha come from?
896000	898000	Why alpha?
898000	901000	What's the dumbest possible answer?
902000	905000	Yeah, that's it.
905000	907000	I've got to call it something.
915000	919000	Oh god, I can try the third one.
924000	927000	Lambda x, lambda y, xy.
927000	929000	Lambda x.
932000	935000	Write that using, like, f?
940000	943000	Well, does somebody else want to try?
943000	946000	I mean, I could do it, but maybe someone else should do it.
947000	961000	I mean, I suppose you could have f of x, y,
961000	967000	and then you could apply that to one and then two.
967000	970000	I mean, these don't do anything, right?
970000	972000	We don't know what x and y mean.
972000	974000	It's just a function.
975000	977000	It's just a pure function.
977000	980000	For any given input, it has the same output, right?
983000	985000	Whatever x you give it is always x.
985000	987000	It's always the same, right?
987000	989000	It's mapping between sets.
989000	991000	Is that helpful?
991000	1004000	When we get to the JavaScript,
1004000	1006000	well, I never thought I would say this sentence.
1006000	1009000	When we get to JavaScript, it'll make more sense.
1009000	1012000	OK, so here's alpha substitution.
1012000	1015000	Again, the variable names, they don't mean anything.
1015000	1018000	You can use any variable that you want,
1018000	1021000	and yeah, I'm being very funny about using poop emoji,
1021000	1024000	but the point is these are all the same, OK?
1024000	1026000	I'm going to use this triple equals a lot
1026000	1028000	because this is not equality per se.
1028000	1030000	These are all actually identical.
1030000	1032000	Lambda A dot A, lambda Z dot Z, poop, whatever.
1032000	1034000	They're all the same.
1034000	1036000	All of these represent the exact same things.
1036000	1039000	You can substitute them one for the other.
1039000	1043000	And you sometimes need to do that in complicated lambda reductions,
1043000	1045000	which we are not going to do, right?
1045000	1047000	I don't want to learn lambda calculus.
1047000	1049000	That's why you came here.
1049000	1051000	When we get to the JavaScript, sorry, yeah?
1051000	1055000	Is there a difference between the same after the dot?
1055000	1057000	Legibility?
1057000	1059000	But no.
1059000	1063000	You're separating the arguments from the expression.
1063000	1065000	That's what the period is.
1065000	1066000	Yeah, yeah, yeah.
1066000	1068000	A is the argument.
1068000	1070000	Lambda A, that A is the argument,
1070000	1072000	and the A after the dot is the expression.
1072000	1074000	Yeah.
1074000	1076000	It doesn't matter. It's just notation, right?
1076000	1078000	This is not a programming language.
1078000	1080000	I'm sorry, this is a programming language.
1080000	1082000	This is not something you can run on a computer.
1082000	1084000	Here's a slightly more complicated.
1084000	1086000	That was alpha substitution. This is beta reduction.
1086000	1088000	I kind of did a few already, so I hope this makes sense.
1088000	1092000	You have lambda X, lambda Y, X, Y applied to P and Q.
1092000	1094000	So first you apply the P, the X goes away.
1094000	1096000	Now you have lambda Y dot PY.
1096000	1098000	Then you apply the Q, the lambda Y goes away,
1098000	1100000	and you end up with PQ.
1100000	1103000	Does that make sense?
1104000	1106000	It worries me sometimes that this stuff doesn't actually
1106000	1108000	make intuitive sense, so if it doesn't make sense,
1108000	1110000	I will explain it in more detail.
1110000	1112000	Again, I thought I was going to get 10 people,
1112000	1114000	and I'd be like, does it make sense to you?
1114000	1116000	I think it does.
1116000	1119000	I know. Well, we're going to get there.
1119000	1121000	This is just supposed to be a warm-up.
1121000	1123000	I actually don't want this to take that long.
1123000	1124000	This is kind of neat.
1124000	1128000	Lambda X dot XX applied to lambda X dot XX.
1128000	1131000	When we reduce that, we get the same thing, right?
1131000	1136000	Because if you plug this into this expression,
1136000	1139000	this X goes away, and you actually substitute this
1139000	1141000	for both of these Xs, right,
1141000	1144000	and then you get the same thing again.
1144000	1146000	Recursion.
1146000	1148000	You can do recursion with pencil and paper.
1148000	1151000	I thought that was pretty neat when I first learned it.
1151000	1153000	Finally, eta conversion.
1153000	1155000	This is mostly for your information.
1155000	1158000	It's not going to be terribly important for the talk today,
1158000	1161000	except eta conversion will come up in one very important place later.
1161000	1166000	What I'm saying here is that maybe this is the math part that will help.
1166000	1168000	I don't know.
1175000	1178000	I can't really make it simpler than it is.
1178000	1180000	Lambda X dot F of X is just the same thing as F.
1180000	1184000	The X is superfluous. It's the same thing as a function F.
1184000	1186000	If you have a function F applied to an X,
1186000	1188000	you can put that into a lambda abstraction.
1188000	1191000	That is the same thing as F itself.
1205000	1207000	Which one?
1207000	1209000	Lambda X dot F of X.
1209000	1211000	That's a good point.
1219000	1221000	I wasn't going to talk about free variables.
1221000	1223000	The F is not bound in this expression.
1223000	1225000	If I were actually teaching you lambda calculus,
1225000	1227000	which I'm not supposed to be doing,
1227000	1229000	I would say that the F is a free variable.
1229000	1231000	It's F in some global state.
1231000	1233000	We don't like global state in functional programming.
1233000	1236000	It represents some global binding F.
1236000	1238000	These two things just happen to be identical in meaning.
1238000	1240000	The F is the same in this case.
1240000	1242000	That's a good point.
1242000	1244000	Let's get right into combinators.
1244000	1246000	Another scary word.
1246000	1250000	A combinator is a function with no free variables.
1250000	1252000	It's a function you can combine with other functions
1252000	1254000	to do some very neat things.
1254000	1256000	We've already seen this one.
1256000	1258000	Lambda X dot X.
1258000	1260000	We call this the identity function because whatever we give it,
1260000	1262000	we get it back again.
1262000	1264000	This will prove to be useful and important
1264000	1266000	in many places in functional programming.
1266000	1268000	This is also, I guess you could say,
1268000	1270000	the universal fixed point combinator.
1270000	1272000	That sounds scary too.
1272000	1276000	The fixed point of a function
1276000	1278000	is the value that when you give it to a function,
1278000	1280000	you get the same value back.
1280000	1284000	There are many examples of this in math.
1284000	1286000	I'm not going to go over them,
1286000	1288000	but I hope you can see that for this function.
1288000	1290000	Lambda X dot X.
1290000	1292000	Whatever you give it, you get back.
1292000	1295000	That's what I mean by universal fixed point combinator.
1295000	1299000	Fixed point combinators will also come up again later
1299000	1301000	in a much sexier way.
1301000	1307000	This is what the identity function looks like in Haskell.
1307000	1309000	My favorite programming language.
1309000	1311000	And yours too, I assume.
1311000	1315000	It's not easy to type a lambda on your computer,
1315000	1317000	so we have a slash there instead.
1317000	1319000	That represents a lambda, essentially.
1319000	1323000	This is what we're going to use in JavaScript.
1323000	1325000	Assuming that your browsers are all up to date
1325000	1327000	and you have fat arrow functions.
1327000	1329000	Same thing, very simple, right?
1329000	1331000	This is the basic building block that we're going to use.
1331000	1333000	Anybody know what this is?
1333000	1335000	Python.
1335000	1337000	Yeah, Python.
1337000	1339000	Anyway, what about that?
1339000	1341000	Ruby.
1341000	1343000	Yeah, this is good for me to gauge the room.
1343000	1345000	Who knows what?
1345000	1347000	What about this weird looking one?
1347000	1349000	Not Ruby.
1349000	1351000	No.
1351000	1353000	Can you do this in Java? I don't actually know Java.
1353000	1355000	I'm proud of the fact.
1355000	1359000	I've been programming as a hobby my whole life.
1359000	1361000	I lost interest in the 90s,
1361000	1363000	which is when Java started becoming popular
1363000	1365000	and I got back into it not very long ago.
1365000	1369000	I feel like my great pride in life is I missed the Java period.
1369000	1371000	I hope.
1371000	1373000	I'm sorry if I'm moving too quickly.
1373000	1375000	I do want to get to JavaScript.
1375000	1377000	I can't believe I'm saying this stuff.
1378000	1380000	Now we have a very simple notation
1380000	1382000	for creating computations,
1382000	1384000	but it's a little bit clumsy.
1384000	1387000	We need to actually start creating some primitive values.
1387000	1389000	We can create true.
1389000	1392000	Again, this is not a binding in the sense of a variable binding.
1392000	1394000	These two things are completely equivalent.
1394000	1396000	They are a substitutable one for another wherever you see them.
1396000	1398000	We're just going to say,
1398000	1400000	lambda x dot lambda y dot x means true.
1400000	1403000	This is simply a function that takes two values,
1403000	1406000	an x and a y, and it returns the first one.
1406000	1408000	We're just going to say that that's true.
1408000	1410000	You could do it a different way if you want,
1410000	1412000	but we're going to use that as our convention.
1412000	1415000	We're just going to encode true as this function.
1415000	1418000	We're going to encode false as the opposite.
1418000	1420000	It's a function that takes two values
1420000	1422000	and returns the second value.
1422000	1424000	That's it.
1424000	1427000	This is not like some standard of lambda calculus.
1427000	1429000	This is just totally a convention.
1429000	1431000	It's the convention that is typically used, so I'm using it,
1431000	1433000	but we're just making it up.
1433000	1435000	Did I see a hand somewhere?
1435000	1437000	Sorry, I was just going to interject.
1437000	1439000	If somebody is trying to use node and you're using
1439000	1441000	new language features, it might not work.
1441000	1443000	You can use Babel.
1443000	1445000	I'm going to put that in the chat.
1445000	1447000	Okay.
1447000	1452000	Actually, Babel inspired me to do this at some point.
1452000	1454000	Actually, I was very frustrated
1454000	1456000	with trying to learn lambda calculus.
1456000	1458000	I started messing around with it in JavaScript
1458000	1460000	because it was there.
1460000	1462000	Then eventually one thing led to another.
1462000	1463000	Here we are.
1463000	1465000	We can make more complicated functions,
1465000	1467000	logic functions like and.
1467000	1470000	I hope that if you look at this and you're a programmer,
1470000	1472000	this makes sense.
1472000	1474000	If you have two values, you can determine
1474000	1477000	whether or not they are both true.
1477000	1480000	You look at the first one.
1480000	1482000	Is it true?
1482000	1484000	If it's true, you compare it to the second one.
1484000	1488000	Actually, let me be clear here.
1488000	1490000	We have two functions, true and false.
1490000	1492000	True returns the first value.
1492000	1494000	False returns the second value.
1494000	1500000	If A is a Boolean value, true or false,
1500000	1503000	if it's true, it's going to return whatever B is.
1503000	1505000	If it's false, it returns false right away
1505000	1508000	because it's an and.
1508000	1510000	If B is a true, then it's true.
1510000	1512000	If B is false, then the whole thing is false.
1512000	1513000	Does that make sense?
1513000	1515000	That's why that looks like that.
1515000	1517000	I can do it on the board too.
1517000	1519000	I hate chalk.
1520000	1523000	From my understanding, I see that basically,
1523000	1526000	when you see lambda x, it means the function f.
1526000	1529000	In the first situation, it takes two variables,
1529000	1531000	f of x, y.
1531000	1533000	In this case, it returns x.
1533000	1536000	In the second question, it takes f of x, y.
1536000	1538000	Then it returns y.
1538000	1540000	In the third case, it takes two arguments
1540000	1542000	and returns an and.
1542000	1544000	That's basically it.
1544000	1546000	That's the same thing.
1546000	1548000	It really isn't more complicated than that.
1548000	1552000	Does the notation is just what is causing the confusion?
1552000	1555000	Here's the ultimate cop out.
1555000	1557000	I didn't invent this notation.
1557000	1559000	It provides us a universal language
1559000	1561000	with which to speak about functions
1561000	1563000	and function application.
1563000	1565000	When I said this is what functional programming
1565000	1567000	is all about, literally everything is a function.
1567000	1568000	You've heard everything is a function.
1568000	1569000	What does that really mean?
1569000	1571000	Functions are values.
1571000	1574000	We're just saying lambda x dot lambda y to x is true.
1574000	1576000	It is the value true.
1576000	1579000	We're loading truth as that function.
1579000	1581000	Then we can do stuff with that function
1581000	1583000	to build up more complicated expressions.
1583000	1585000	There's an and, there's an or.
1585000	1587000	We can do not.
1589000	1591000	Now we have booleans.
1591000	1594000	We're getting close to being able to do actual logic.
1594000	1596000	It's all functions.
1596000	1599000	I don't know how you feel about this inside your own head.
1599000	1601000	This was mind-blowing for me when I first learned about it.
1601000	1603000	Reducing expressions.
1603000	1605000	We can take an and and a true and a false.
1605000	1607000	We can take the lambdas back in.
1607000	1608000	It looks like that.
1608000	1610000	Already it's starting to be headache inducing.
1610000	1611000	I know.
1611000	1615000	The point is and a true false is identical to this expression.
1615000	1618000	It's easier for us as people to deal with and true false
1618000	1620000	than with all of this lambda stuff,
1620000	1622000	but you can actually still work this out on paper.
1622000	1625000	You can perform these reduction steps that I showed you.
1625000	1627000	Ultimately, there's the first step of the reduction,
1627000	1629000	another step of the reduction, another step, another step.
1629000	1631000	By the way, the slides are all on GitHub,
1631000	1633000	so you can play with this later if you like.
1633000	1635000	Essentially, all of this reduces down to this function.
1635000	1637000	These are the reduction steps.
1637000	1641000	If you are plugging things in and replacing your bound values
1641000	1643000	in the expressions at each step of the way,
1643000	1645000	finally you get to lambda x dot lambda y dot lambda y,
1645000	1647000	which we already know is false.
1647000	1648000	That's how it works.
1648000	1650000	That's how you do a computation anyway in lambda calculus.
1650000	1652000	A very simple one.
1657000	1659000	I can, but why do you want me to?
1663000	1665000	I'm going to be honest with you.
1665000	1667000	I hate touching chalk and I am trying to avoid it.
1667000	1669000	I will do it if necessary,
1669000	1671000	but I would just be writing that again.
1671000	1673000	You want me to go through the whole thing?
1673000	1675000	No, that's not.
1675000	1677000	Totally, I will do it later, pen and paper,
1677000	1679000	but it will take too long.
1679000	1681000	I only have two hours.
1681000	1683000	I think you were just saying the end in the last slide,
1683000	1685000	you could just pop through it,
1685000	1687000	but you didn't write it.
1687000	1689000	Is it arbitrary like you're in false?
1689000	1691000	Yes.
1691000	1693000	I'm just going to say that's true and that's false.
1695000	1697000	Just like truth and false in real life are arbitrary.
1699000	1701000	You came for the deep stuff today.
1703000	1705000	I know you want to look for some meaning,
1705000	1707000	but I showed you that first slide with the,
1709000	1711000	that's it, that's the whole language.
1711000	1713000	Those three things are the whole language.
1713000	1715000	I have to build the entire system of computation out of that,
1715000	1717000	out of just functions.
1717000	1719000	If I want to do Boolean operations,
1719000	1721000	I need some notion of truth and false.
1721000	1723000	If I want to do comparisons,
1723000	1725000	I just have to invent them.
1725000	1727000	I have to invent them in a way that they'll work
1727000	1729000	and this happens to work.
1729000	1731000	It seems like a bit of magic and I guess it is.
1735000	1737000	You're saying that they're arbitrary,
1737000	1739000	but they're not arbitrary
1739000	1741000	in comparison to each other.
1741000	1743000	These are built up in such a way that...
1743000	1745000	The system is logically consistent.
1745000	1747000	It actually has...
1747000	1749000	It developed out of the study of logic, in fact.
1749000	1751000	Formal logic.
1751000	1753000	Not stuff I know a whole lot about.
1753000	1755000	But yeah, they're not like random.
1755000	1757000	They're sort of encodings that were decided upon
1757000	1759000	as part of a system that is internally coherent.
1761000	1763000	Wait till we get to numbers.
1767000	1769000	Okay.
1769000	1771000	So now that we have some Booleans,
1771000	1773000	we can actually create useful functions.
1773000	1775000	That determines whether or not a value is zero.
1775000	1777000	I've rearranged this presentation
1777000	1779000	since the last time I did some piece of it.
1779000	1781000	So we don't have numbers yet.
1781000	1783000	Bear with me.
1783000	1785000	So let's say that X is a number.
1785000	1787000	This function will tell you whether or not
1787000	1789000	that number is zero.
1791000	1793000	This is maybe an easier way to look at it.
1795000	1797000	Is zero n?
1797000	1799000	So is zero n is going to return
1799000	1801000	a true or a false?
1801000	1803000	And if it returns true,
1803000	1805000	so we're applying...
1805000	1807000	I think I need to maybe explain this a little bit better.
1807000	1809000	So this is zero n
1809000	1811000	is going to reduce down to a true or a false.
1811000	1813000	We know that true returns the first value
1813000	1815000	that it's given, right?
1815000	1817000	So it's going to return true.
1817000	1819000	If it's not zero, it will return false.
1819000	1821000	Because false returns the second value.
1821000	1823000	That's it.
1823000	1825000	We're applying true and false to this function
1825000	1827000	is zero n, yeah.
1831000	1833000	So it's going to return true,
1833000	1835000	and now you're talking about same features.
1835000	1837000	So how do they match into the number?
1837000	1839000	What is one for zero?
1839000	1841000	Oh, you're going to love it.
1841000	1843000	I think it's on the next slide.
1843000	1845000	Yeah, yeah.
1845000	1847000	I wanted to do predicates after a boolean,
1847000	1849000	so the numbers are slightly out of order.
1849000	1851000	So bear with me.
1853000	1855000	Okay, so now we can have
1855000	1857000	branching in our Lambda Calculus.
1857000	1859000	We can say an if statement
1859000	1861000	is simply a function
1861000	1863000	that is a predicate, right?
1863000	1865000	A predicate is a function that returns true or false.
1865000	1867000	And then we apply to that
1867000	1869000	two values, x and y.
1869000	1871000	And if that predicate p is true,
1871000	1873000	it will return the first value if it's false
1873000	1875000	that returns the second value.
1875000	1877000	Yeah.
1877000	1879000	What's the definition of zero?
1879000	1881000	You're saying is zero for a false.
1881000	1883000	What is the definition of zero?
1883000	1885000	We're going to get to that.
1885000	1887000	Yeah.
1887000	1889000	So that kind of would look like that, right?
1889000	1891000	If n is zero,
1891000	1893000	then you would do the value
1893000	1895000	in that then branch.
1895000	1897000	Otherwise, the else, right?
1897000	1899000	And actually, we can factor out
1899000	1901000	the p, the x, and the y.
1901000	1903000	We can just say that if it's the identity function.
1903000	1905000	It's the same thing really,
1905000	1907000	because we're just dealing with predicates.
1907000	1909000	Whoops.
1909000	1911000	Right, that's...
1911000	1913000	If you want to write it as like a little law for yourself, right?
1913000	1915000	Expression one, expression two.
1915000	1917000	If p is true, then e1, else e2.
1917000	1919000	Okay. Everyone wants to do numbers.
1919000	1921000	And you know what? I don't blame you, because
1921000	1923000	how the heck do you do numbers with only functions?
1923000	1925000	This is really where the whole idea
1925000	1927000	of functions as values, I think, is going to
1927000	1929000	make sense.
1929000	1931000	I hope I'm going to drive this home for you.
1933000	1935000	Speaking of arbitrary,
1935000	1937000	we're going to call zero
1937000	1939000	a function that takes
1939000	1941000	an x and returns an x.
1941000	1943000	It does nothing to it, right?
1943000	1945000	We're just going to say that's zero.
1949000	1951000	That's a zero, but it's just an encoding,
1951000	1953000	ultimately. You can encode it in binary.
1953000	1955000	That's another way of encoding it.
1955000	1957000	Again, a convention.
1957000	1959000	This symbol represents some idea
1959000	1961000	of zero. We are so used to using it.
1961000	1963000	We think, well, that's zero.
1963000	1965000	And that's five.
1965000	1967000	But it's just a symbol.
1967000	1969000	There's one.
1969000	1971000	Lambda f dot, lambda x
1971000	1973000	dot f of x.
1973000	1975000	You're going to see a pattern very soon.
1975000	1977000	So now we're taking a function and a value,
1977000	1979000	and we're applying the function to the value one time.
1981000	1983000	There's two. There's three.
1983000	1985000	You can probably guess what four looks like,
1985000	1987000	and possibly 5,000 at this point.
1987000	1989000	Because what is a number? If you're doing something
1989000	1991000	with a number in computation,
1991000	1993000	you may just be storing a value, but
1993000	1995000	very likely you're probably going to be performing
1995000	1997000	some operation that number of times, right?
1997000	1999000	For any number n, you're going to do something
1999000	2001000	three times. That's all that this is doing.
2001000	2003000	Some number x.
2003000	2005000	If you want to do something
2005000	2007000	with the value three,
2007000	2009000	then you apply, with a function,
2009000	2011000	you apply that function to the value three times.
2011000	2013000	Four, five.
2015000	2017000	It gets ridiculous.
2017000	2019000	And by the way, again, this is not variable binding.
2021000	2023000	These are identical. I'm just using this
2023000	2025000	as a convenient symbol. You could use poop emoji here, too, if you want.
2025000	2027000	I want you to be able to read this.
2027000	2029000	So, all of this stuff,
2029000	2031000	I don't want to type that ever again.
2031000	2033000	Especially when they start to get really big.
2033000	2035000	So, I just attach convenient names to them
2035000	2037000	for my own benefit.
2037000	2039000	Now, enumeration. We can actually
2039000	2041000	work with these numbers and get somewhere with them.
2041000	2043000	There is a function that will tell you what the
2043000	2045000	next value is for a given value n.
2047000	2049000	This one's more complicated.
2051000	2053000	I don't want to divert too much into these things.
2053000	2055000	So, again, I'm not meant
2055000	2057000	to be teaching you lambda calculus. This is taking too long.
2057000	2059000	I just want to show you
2059000	2061000	that you can do this kind of stuff
2061000	2063000	and that this is the basis of functional programming.
2063000	2065000	These are functional combinators
2065000	2067000	where all values are functions
2067000	2069000	and you can actually do computation with just functions.
2071000	2073000	Pred is complicated
2073000	2075000	and it actually was kind of a discovery at the time
2075000	2077000	because they didn't know how to do it.
2077000	2079000	And it will tell you the number.
2079000	2081000	Suck of two is one
2081000	2083000	and pred of...
2083000	2085000	Sorry, suck of two is three
2085000	2087000	and pred of two is one.
2087000	2089000	That's what those are for.
2089000	2091000	There's a reduction. You can write it out on paper
2091000	2093000	if you don't believe me. It totally works.
2093000	2095000	The number after one is definitely two
2095000	2097000	and the number before one is definitely zero.
2097000	2099000	They work. I tested these.
2101000	2103000	Now we can do some complicated arithmetic.
2103000	2105000	There's ad and at this point
2105000	2107000	I'm going to start going a little faster
2107000	2109000	because the actual encodings don't particularly matter.
2109000	2111000	The fact that we can do them is what matters.
2111000	2113000	Different ways of doing ad
2113000	2115000	they both will give you the same result.
2115000	2117000	Subtract, multiplication,
2117000	2119000	exponent which is delightfully simple.
2119000	2121000	Totally makes sense though
2121000	2123000	that you're applying a function
2123000	2125000	that gets applied a number of times
2125000	2127000	to another function that gets applied a number of times.
2127000	2129000	Now you have an exponent.
2129000	2131000	Here's a reduction.
2131000	2133000	If you add one and two together using functions you get three.
2133000	2135000	You get a functional encoding of three.
2135000	2137000	Now if you're doing functional programming
2137000	2139000	you get this garbage.
2139000	2141000	But this is the underlying substrate
2141000	2143000	you might say of the functional computation
2143000	2145000	and it ultimately gives you
2145000	2147000	the correct answer that you want.
2147000	2149000	This is just a very simple sort of program.
2151000	2153000	Subtraction is a little bit more tedious.
2153000	2155000	I mean tedious for me.
2155000	2157000	I'm so terrified of being wrong.
2157000	2159000	I sat down and wrote these out on paper.
2159000	2161000	I encourage you to do that
2161000	2163000	just to get an intuition for it.
2163000	2165000	Multiplication and exponentiation.
2165000	2167000	Look at that eight.
2167000	2169000	I think it's crazy.
2169000	2171000	All the parentheses.
2171000	2173000	This is really the hot stuff.
2173000	2175000	Raise your hand if you've heard of Y Combinator.
2175000	2177000	Like the company, right?
2177000	2179000	I hope you all end up...
2179000	2181000	Do I hope that you all...
2181000	2183000	No.
2183000	2185000	Raise your hand if you've seen the Y Combinator.
2185000	2187000	This Y Combinator.
2187000	2189000	I don't know if you are aware of this
2189000	2191000	but the company Y Combinator
2191000	2193000	the name is based on this function.
2193000	2195000	This is how you perform recursion
2195000	2197000	in the simply...
2197000	2199000	Sorry, the untyped lambda calculus.
2199000	2201000	I referred earlier to fixed point
2201000	2203000	combinators and this is a fixed point
2203000	2205000	combinator for functions.
2205000	2207000	Any function...
2207000	2209000	For any function that you give fix
2209000	2211000	it will return that function again
2211000	2213000	and that is how you perform recursion.
2213000	2215000	For example, everyone's favorite example,
2215000	2217000	factorial.
2217000	2219000	Here's a function that will perform a factorial
2219000	2221000	but we need to do recursion to perform
2221000	2223000	a factorial, right?
2223000	2225000	We'll say factorial is
2225000	2227000	going to be a function
2227000	2229000	that is the fixed point of this function F.
2229000	2231000	We're going to pass F to our
2231000	2233000	fixed point...
2233000	2235000	I didn't call it Y because I want to be clear.
2235000	2237000	The fixed point combinator is a function
2237000	2239000	that when you give it a function
2239000	2241000	it will return that function again.
2241000	2243000	It actually embeds the function into the expression
2243000	2245000	in a way that you're going to see in a minute.
2245000	2247000	Honestly, the details aren't important
2247000	2249000	because you're not here to learn lambda calculus, honestly.
2249000	2251000	But I want you to get a sense for it,
2251000	2253000	an intuition, right?
2253000	2255000	We're going to take the function F
2255000	2257000	and we're going to pass it to the fixed point combinator
2257000	2259000	and it looks like that.
2259000	2261000	That's what we get in the first reduction step
2261000	2263000	and you can see that F is now embedded into the recursion
2263000	2265000	and that's how we can perform
2265000	2267000	a factorial operation.
2267000	2269000	There it is again
2269000	2271000	and it looks like that.
2271000	2273000	It will keep doing that until we're done,
2273000	2275000	until we reach our base case.
2275000	2277000	The base case, right?
2277000	2279000	End part.
2279000	2281000	Without the base case then it doesn't stop.
2281000	2283000	It lets a lot of writing.
2283000	2285000	I'm going to walk you through the recursion now
2285000	2287000	step by step.
2287000	2289000	I don't expect you to...
2289000	2291000	This is mostly for entertainment.
2291000	2293000	This is what it looks like when you write this out, right?
2293000	2295000	We're going to calculate now the factorial of 2
2295000	2297000	step by step
2297000	2299000	and we're doing beta reduction right now.
2299000	2301000	It's just text substitution.
2301000	2303000	We're putting values into functions.
2303000	2305000	I'm actually cheating a little bit
2305000	2307000	because I'm not expanding all the lambda expressions
2307000	2309000	because I know that...
2309000	2311000	I know that
2311000	2313000	whether or not a number is zero
2313000	2315000	so I'm just doing this in my own head
2315000	2317000	but this is an accurate representation
2317000	2319000	of the reduction, right?
2319000	2321000	At each step.
2321000	2323000	It's almost legible, right?
2323000	2325000	Even if you don't know lambda calculus
2325000	2327000	you know a little bit of programming maybe.
2327000	2329000	You can see how this would work
2329000	2331000	to calculate a factorial
2331000	2333000	and I end up with that
2333000	2335000	and this one is two.
2335000	2337000	I can do anything now, right?
2339000	2341000	I have numbers, I have recursion,
2341000	2343000	I have branching.
2343000	2345000	I can calculate anything.
2345000	2347000	You wouldn't want to calculate anything in lambda calculus
2347000	2349000	like this but you could, in principle
2349000	2351000	you could.
2351000	2353000	I think that's the point.
2353000	2355000	The first step of what's happening
2355000	2357000	is getting substitutions and building
2357000	2359000	that first step is getting substitutions
2359000	2361000	and building this whole thing out
2361000	2363000	and then the next step is evaluation
2363000	2365000	and trying to figure it all down.
2365000	2367000	Well, I mean
2367000	2369000	not exactly.
2369000	2371000	Okay, maybe the point
2371000	2373000	is abstraction, right?
2373000	2375000	Because I don't want to write lambda expressions
2375000	2377000	but I want to be able to trust
2377000	2379000	that this stuff is going to work
2379000	2381000	without worrying about the notation.
2381000	2383000	When you get to a real programming language
2383000	2385000	then obviously you're not worrying about this.
2385000	2387000	This is sort of how functional programming
2387000	2389000	works at some very primitive level.
2389000	2391000	You might think of it that way.
2391000	2393000	When you write programs you're not writing stuff like this
2393000	2395000	but if you're working with pure functions
2395000	2397000	you don't worry about state
2397000	2399000	then you know that
2399000	2401000	when I write fact I'm really writing
2401000	2403000	fact after what I'm writing all that lambda stuff
2403000	2405000	and it will work the same every single time.
2405000	2407000	I would rather work with
2407000	2409000	named functions because they're easier for me
2409000	2411000	and named values than with long
2411000	2413000	lambda expressions.
2421000	2423000	Yes?
2423000	2425000	I wasn't going to say it yet
2425000	2427000	but look, you get currying for free. It's right there.
2427000	2429000	Because you're applying each argument one at a time.
2431000	2433000	If you're familiar with currying that's what it is.
2433000	2435000	Instead of applying all your arguments at once
2435000	2437000	you can do them one at a time
2437000	2439000	and you take a function, you apply an argument
2439000	2441000	now you have a new function with that argument applied
2441000	2443000	and then you do the next one and the next one.
2443000	2445000	It's a freebie.
2445000	2447000	Like referential transparency.
2447000	2449000	That just means that
2449000	2451000	when I was showing you earlier that these expressions
2451000	2453000	triple equal sign or this name
2453000	2455000	triple equal sign this expression
2455000	2457000	that those are completely identical
2457000	2459000	and you can do equational reasoning with these things
2459000	2461000	and trust that it's always going to work
2461000	2463000	because there's no such thing as global state
2463000	2465000	there's no memory. This is not a Turing machine.
2465000	2467000	It's just symbolic manipulation.
2467000	2469000	Okay, so I told you I cheated a little bit
2469000	2471000	with this example.
2471000	2473000	Here's what the real thing looks like if you're working with just lambdas.
2473000	2475000	Can you even read this?
2475000	2477000	I blew it up, you can't read it anyway.
2477000	2479000	So this is the whole thing and if you sat down
2479000	2481000	and you worked this out with a pen
2481000	2483000	and a piece of paper like I did
2483000	2485000	so that in the event that someone was in the audience
2485000	2487000	and did this and found that I was wrong I wouldn't be embarrassed.
2487000	2489000	It works.
2489000	2491000	These are the reduction steps
2491000	2493000	for just as just factorial of 2
2493000	2495000	if you did factorial of a higher number
2495000	2497000	you get to the point where it will take you
2497000	2499000	until the heat death of the universe to compute probably
2499000	2501000	but you can see how the reduction steps
2501000	2503000	ultimately get you to the same answer.
2503000	2505000	There it is.
2505000	2507000	lambdaf.lambdax.f.f of x
2509000	2511000	is 2.
2511000	2513000	So now you know the factorial of 2 is 2.
2513000	2515000	That is the entirety
2515000	2517000	of the syntax of lambda calculus I want to talk about.
2517000	2519000	Are there any questions?
2519000	2521000	No.
2521000	2523000	That's more than I want it to do in fact.
2523000	2525000	You mentioned a lot of paper and pen.
2525000	2527000	When you're learning lambda calculus
2527000	2529000	do you recommend paper and pen?
2529000	2531000	No, paper and pen.
2531000	2533000	It's easier.
2533000	2535000	Why don't you check yourself
2535000	2537000	because there's no compromise with what you're trying to do?
2537000	2539000	It's a good question.
2539000	2541000	How do you check yourself?
2541000	2543000	I just did.
2543000	2545000	This is a proof, right?
2545000	2547000	It works.
2547000	2549000	You can do it and make sure I did it right.
2549000	2551000	In lambda calculus
2551000	2553000	you know what 3 plus 0 is in real life.
2553000	2555000	So you don't take 3 plus 0
2559000	2561000	in lambda calculus and you know you did it wrong.
2561000	2563000	Right.
2563000	2565000	I'm establishing a principle essentially, yeah.
2565000	2567000	So basically in the yw ychwanegwch,
2567000	2569000	ychwanegwch, ychwanegwch, ychwanegwch,
2569000	2571000	ychwanegwch, ychwanegwch, ychwanegwch,
2571000	2573000	ychwanegwch, ychwanegwch, ychwanegwch.
2573000	2575000	If you have a base case
2575000	2577000	if you don't,
2577000	2579000	then it diverges forever.
2579000	2581000	It never converges on an answer.
2581000	2583000	Similar to what?
2583000	2585000	Similar to what?
2585000	2587000	Like a for loop.
2587000	2589000	I mean, yeah.
2589000	2591000	I mean, yeah.
2591000	2593000	I mean, I don't love comparisons
2593000	2595000	to imperative programming constructs.
2595000	2597000	This is what it is.
2597000	2599000	This predates for loops.
2599000	2601000	I thank.
2601000	2603000	Pretty sure.
2603000	2605000	Lambda calculus.
2605000	2607000	Now we're going to do JavaScript.
2607000	2609000	Thank God, right?
2609000	2611000	Something everybody is familiar with.
2611000	2613000	So I hope that everybody...
2615000	2617000	Can everyone see that? Is that big enough?
2617000	2619000	No, not.
2619000	2621000	Okay, maybe.
2621000	2623000	Oops.
2623000	2625000	Oh, great.
2629000	2631000	How about that?
2632000	2634000	Or that. Is that good?
2640000	2642000	Yeah, my normal background is even lower contrast.
2642000	2644000	I thought maybe this would be easier.
2644000	2646000	No, not so much.
2648000	2650000	I can do dark...
2650000	2654000	This is slightly different, but almost exactly identical.
2654000	2656000	Let me see.
2656000	2658000	Why am I using BBEdit?
2658000	2660000	Um...
2660000	2662000	Do you like this better?
2662000	2664000	Yeah, okay.
2670000	2672000	Hi.
2672000	2674000	Bigger?
2674000	2676000	Whatever, I don't care.
2676000	2679000	So at this point, I hope you can all open up the file
2679000	2682000	and open up your...
2682000	2684000	Java...
2684000	2686000	I'm doing this in Chrome, and I tested it in Safari
2686000	2688000	and Firefox.
2688000	2690000	I don't know off the top of my head how you open a JavaScript console
2690000	2693000	in Safari or Firefox.
2693000	2695000	Command-option-j
2695000	2697000	in Chrome if you have
2697000	2700000	the lambda.html page open.
2703000	2705000	Sorry, question?
2705000	2707000	Question?
2707000	2709000	Okay, so now we're going to move more into
2709000	2712000	more of a workshop format, because that was a little bit more explanation
2712000	2714000	than I had wanted to do.
2714000	2716000	You have all of the functions that I've shown you
2716000	2718000	and a lot of other stuff,
2718000	2720000	and what I want you to be able to do with now
2720000	2722000	is really play with them in your browsers.
2722000	2724000	The point is, I don't want to lecture at you.
2724000	2726000	Here's what functional programming is all about.
2726000	2728000	I actually want you to use these functions
2728000	2730000	and build computations with them so you learn
2730000	2732000	not only what functional programming is,
2732000	2734000	you develop this intuition that will allow you to explain it
2734000	2736000	to others.
2736000	2738000	What does it mean when we say functions are values?
2738000	2741000	That is the whole point of what I did this for.
2741000	2743000	So type stuff in.
2743000	2745000	As I go through these things.
2745000	2747000	I'm just going to go through
2747000	2749000	the code, essentially.
2749000	2751000	I just want you to play with it in your browsers
2751000	2753000	and see what you can come up with.
2753000	2755000	There are a couple of little exercises that you can do if you want.
2755000	2757000	I actually have never given
2757000	2759000	these kinds of exercises for a group before,
2759000	2761000	so I don't know how that will go over.
2761000	2763000	We'll just find out.
2763000	2765000	Now we're in JavaScript,
2765000	2767000	maybe you'll see the magic for real.
2767000	2769000	We're only going to use the anonymous arrow function
2769000	2771000	to do everything.
2771000	2773000	The same with operations.
2773000	2775000	This is what I showed you.
2775000	2777000	Alpha, beta, and eta conversion.
2777000	2779000	If you type these in.
2779000	2781000	These are like a little toy proofs.
2781000	2783000	You know, they work.
2783000	2785000	They're true.
2785000	2787000	Oh, I should note also
2787000	2789000	this file has a bunch of helper functions
2789000	2791000	because we need to translate between
2791000	2793000	JavaScript and lambdas.
2793000	2795000	Otherwise we can't read anything.
2795000	2797000	For example, I can type in one,
2797000	2799000	but it looks like that.
2799000	2801000	What you know is like a lamb to f lamb to x,
2801000	2803000	f of x. We know that that's one,
2803000	2805000	but...
2805000	2807000	Good point.
2807000	2809000	How about that?
2809000	2811000	Okay.
2811000	2813000	So here's our identity combinator,
2813000	2815000	id equals x,
2815000	2817000	returning x.
2817000	2819000	Assuming everybody is either familiar
2819000	2821000	with the JavaScript arrow syntax,
2821000	2823000	or this is trivial enough
2823000	2825000	that you can pick it up.
2825000	2827000	Here's our true and false.
2827000	2829000	It takes two values, x and y,
2829000	2831000	and returns x is true, and the opposite is false.
2831000	2833000	Again, you can
2833000	2835000	cut and paste these things
2835000	2837000	to test them.
2837000	2839000	I have a two-bool function
2839000	2841000	that you can...
2841000	2843000	and true, false.
2843000	2845000	Returns false.
2845000	2847000	They work, thankfully.
2847000	2849000	At some point you will probably be able
2849000	2851000	to break this because
2851000	2853000	JavaScript isn't designed for
2853000	2855000	deeply nested function calls.
2855000	2857000	Try calculating the factorial of, like, 10.
2859000	2861000	So here we have and, we have or, we have not,
2861000	2863000	and play with this stuff.
2863000	2865000	See what you can do.
2865000	2867000	That's kind of all I want you to do right now.
2867000	2869000	And true and true returns true, right?
2869000	2871000	And false, false returns false.
2871000	2873000	Well, actually, this probably won't work
2873000	2875000	because these are just functions.
2875000	2877000	Oh, look, it works. How about that?
2877000	2879000	If I type in plus,
2879000	2881000	any plus expression,
2881000	2883000	it looks the same,
2883000	2885000	but then the true and true
2885000	2887000	works instead of right now.
2887000	2889000	What do you mean?
2889000	2891000	If I type in 1 plus 1, 5.
2891000	2893000	Oh, you did like that?
2893000	2895000	No, no, with the constant for the named functions.
2895000	2897000	You did this?
2897000	2899000	1, 5?
2899000	2901000	Correct. I'll change the second over to 3.
2901000	2903000	It's going to look the same.
2903000	2905000	Oh, that's...
2905000	2907000	But your true and true function does work in this way?
2907000	2909000	Yeah.
2909000	2911000	I don't know why it does that.
2911000	2913000	It's just the way the Chrome console works.
2913000	2915000	It's just a situation.
2919000	2921000	Chrome's like, what are you doing?
2921000	2923000	No, it wasn't.
2923000	2925000	Yeah, so we have to...
2925000	2927000	You can look at the utility functions.
2927000	2929000	They're at the bottom of the file.
2929000	2931000	Just for convenience, I'm converting back and forth
2931000	2933000	between these lambda expressions and primitive values.
2933000	2935000	Okay, so a little exercise.
2935000	2937000	Try to implement XOR, right?
2937000	2939000	I've given you and or not.
2939000	2941000	See if you can come up with XOR
2941000	2943000	and what that would look like.
2947000	2949000	When someone comes up with it,
2949000	2951000	raise your hand.
2951000	2953000	We don't need to take all day.
2964000	2966000	Anyone have a good XOR implementation?
2974000	2976000	Brad, this is exclusive or...
2982000	2984000	No, I'm not trying to trick you.
2984000	2986000	I mean, I haven't written it for me yet,
2986000	2988000	but it's basically A and not B
2988000	2990000	or not A and B.
2992000	2994000	I think that's what I got.
2994000	2996000	Right?
2998000	3000000	You can test it.
3000000	3002000	I don't know if I've actually typed this in XOR.
3002000	3004000	Yeah, so...
3004000	3006000	I haven't actually typed it in yet, so...
3006000	3008000	Yeah, I encourage you to test these things, too.
3008000	3010000	Prove it to yourself, right?
3010000	3012000	Don't believe me.
3012000	3014000	Or find mistakes.
3014000	3016000	There are a couple of little weird bugs.
3016000	3018000	Well, there's one that I can think of
3018000	3020000	that you probably won't encounter.
3020000	3022000	By and large, this works about 99%,
3022000	3024000	which is pretty good for JavaScript, right?
3028000	3030000	Here's branching.
3030000	3032000	Remember before I said that,
3032000	3034000	in principle,
3034000	3036000	the if-then-else statement you can write
3036000	3038000	is this function
3038000	3040000	that takes a predicate, right?
3040000	3042000	A function that returns true or false.
3042000	3044000	And then two values, X or Y.
3044000	3046000	And if P is true, it returns X.
3046000	3048000	If it's false, it returns Y.
3048000	3050000	And as we did with Lambda Calculus,
3050000	3052000	you can do this in JavaScript.
3052000	3054000	You can factor out the X, factor out the Y,
3054000	3056000	factor out the P, and it's just the same function as ID.
3058000	3060000	Now you can write...
3060000	3062000	I don't know.
3064000	3066000	If-then-else.
3066000	3068000	So if this is true,
3068000	3070000	return true, if not return...
3070000	3072000	Maybe that'll work. That works.
3074000	3076000	Here are the natural numbers.
3076000	3078000	Here are some enumeration functions.
3078000	3080000	I can explain a little bit
3080000	3082000	how predecessor works.
3082000	3084000	It essentially will take
3084000	3086000	a pair of values,
3086000	3088000	a pair of zeros,
3088000	3090000	and it will increment one of them
3090000	3092000	up to the point.
3092000	3094000	A predecessor of five.
3094000	3096000	It'll increment one of those values to five.
3096000	3098000	And it will increment the other one.
3098000	3100000	It will skip one of the incrementations.
3100000	3102000	Increments.
3102000	3104000	It will skip one of the increments.
3104000	3106000	Then you get five and four,
3106000	3108000	and then it selects for the four.
3110000	3112000	That's something I could probably
3112000	3114000	demonstrate at great length,
3114000	3116000	but it would take too long, and so I won't.
3116000	3118000	But I do have a reduction to show you on that.
3118000	3120000	And because
3120000	3122000	this talk is
3122000	3124000	for people who don't want to learn Lambda Calculus,
3124000	3126000	I don't care if you learn Lambda Calculus.
3126000	3128000	I just want you to get comfortable working with functions
3128000	3130000	so that you can understand their expressive power
3130000	3132000	and why we do functional programming.
3134000	3136000	We're building actually an entire programming language
3136000	3138000	within your JavaScript console right now.
3138000	3140000	I don't know if that's apparent.
3140000	3142000	You can start putting more complicated things together
3142000	3144000	with these primitives,
3144000	3146000	and ultimately, in principle, you can do anything.
3146000	3148000	I'm not saying that you should write programs
3148000	3150000	out of these Lambdas.
3150000	3152000	I'm really nervous right now because
3152000	3154000	John said earlier at the end of the keynote
3154000	3156000	that these workshops are meant to be teaching skills.
3158000	3160000	Much from doing that, yeah.
3160000	3162000	No, yeah.
3172000	3174000	Yeah.
3174000	3176000	Yeah.
3178000	3180000	I'm not clear on how that evaluates us through.
3180000	3182000	Does that make sense?
3182000	3184000	Yeah, I'll try.
3184000	3186000	Let's see.
3188000	3190000	Let's say, we'll say A equals,
3190000	3192000	so let's say,
3192000	3194000	hmm.
3194000	3196000	I can apply
3196000	3198000	true to the and function.
3198000	3200000	And I'll just get another function back.
3202000	3204000	Yeah.
3204000	3206000	It's in there. I closed over it.
3206000	3208000	I would think that the X would be true now.
3210000	3212000	It is.
3212000	3214000	But I haven't evaluated the function.
3214000	3216000	I haven't reduced.
3216000	3218000	If I two-bould my little A function,
3218000	3220000	it gives me, you know,
3220000	3222000	it doesn't know what I'm trying to do.
3222000	3224000	No meaning.
3224000	3226000	So I've actually partially applied the true to my and.
3226000	3228000	So now I can apply the false.
3228000	3230000	Let's say B is A
3230000	3232000	applied to false.
3232000	3234000	Now B is fully applied.
3237000	3239000	Now I can two-bool on the B.
3244000	3246000	Is that meaningful
3246000	3248000	as far as reduction steps are concerned?
3252000	3254000	Let's see.
3254000	3256000	OK. No problem.
3256000	3258000	You're making me think on my feet.
3258000	3260000	It's good.
3260000	3262000	I can just type it in.
3262000	3264000	Right?
3264000	3266000	So this is
3266000	3268000	a function after all.
3268000	3270000	That's not special.
3272000	3274000	So this is
3276000	3278000	this is and, right?
3278000	3280000	So I want to apply.
3280000	3282000	In fact, I'll even replace the false with
3284000	3286000	I don't know.
3286000	3288000	I've not done this before.
3288000	3290000	So why not do it the hard way?
3290000	3292000	That's my motto in life.
3292000	3294000	OK.
3294000	3296000	So I'm actually going to get rid of the two-bool
3296000	3298000	because it's going to confuse me for a moment.
3300000	3302000	I think that that looks right.
3302000	3304000	I think that's the and function.
3304000	3306000	Right?
3306000	3308000	So now I can apply
3308000	3310000	like a true to it, for example.
3310000	3312000	But instead of applying the true,
3312000	3314000	let's just kill off
3314000	3316000	the X
3316000	3318000	and put it in there.
3322000	3324000	Let me start over
3324000	3326000	because I'm going to confuse myself.
3326000	3328000	I'm glad we're doing this because
3328000	3330000	this is the point.
3330000	3332000	I don't care.
3332000	3334000	It's helpful for me.
3334000	3336000	This talks about me.
3336000	3338000	It's not about you.
3338000	3340000	I actually might leave the
3340000	3342000	false in as it is because you get the idea
3342000	3344000	and I don't want to waste time being confused.
3344000	3346000	OK. So there's the true. We're going to apply this to true.
3346000	3348000	But instead of doing that, we'll kill off
3348000	3350000	that X and we'll just stick it there.
3350000	3352000	I need some other boolean value, right?
3352000	3354000	Because we need two branches.
3354000	3356000	So let's say the other branch
3356000	3358000	is false.
3358000	3360000	Right. So now I kill off
3360000	3362000	the Y
3362000	3364000	and now I have false.
3364000	3366000	OK.
3366000	3368000	But remember true is also just a function.
3368000	3370000	It's a function X, Y
3370000	3372000	that returns X.
3372000	3374000	Right? So then we have
3374000	3376000	this false.
3376000	3378000	We take that
3378000	3380000	and pull off this X
3380000	3382000	and then it's there.
3382000	3384000	OK.
3384000	3386000	Then we have another false
3386000	3388000	and we apply that to Y
3388000	3390000	and then we're left with false.
3390000	3392000	Does that last a little bit there?
3392000	3394000	We say you're applying the Y
3394000	3396000	and when you have the false, it was done
3396000	3398000	just two falses.
3398000	3400000	Is that why?
3400000	3402000	You know, it's tricky
3402000	3404000	because I'm just branching using booleans.
3404000	3406000	I'm not branching using real expressions.
3406000	3408000	Maybe if I say
3408000	3410000	you know, is 0, 1
3410000	3412000	true otherwise false
3412000	3414000	something like that.
3414000	3416000	It was helpful that you reminded me
3416000	3418000	that it was a function.
3418000	3420000	Yeah, yeah.
3420000	3422000	Remember, everything is a function.
3422000	3424000	You don't really know what it means.
3424000	3426000	Everything is a function.
3426000	3428000	Functional programming is programming with functions.
3428000	3430000	No, it's not intuitive at all.
3430000	3432000	I don't think it's intuitive.
3432000	3434000	But once it becomes intuitive,
3434000	3436000	one is a function.
3436000	3438000	Right, no.
3438000	3440000	You think I'm trying to trick you, right?
3440000	3442000	Programming, I must have embedded primitive values
3442000	3444000	into this somewhere, right?
3444000	3446000	I have not. They're all just functions.
3446000	3448000	They're simply encoding.
3448000	3450000	I'm a human being. I'm going to say this is true.
3450000	3452000	The computer or the notation doesn't know
3452000	3454000	what true means.
3456000	3458000	True and false are really bad names.
3458000	3460000	Names are hard, right?
3460000	3462000	This is not philosophy, it's just computation.
3462000	3464000	I'm just trying to make decisions.
3464000	3466000	Is zero false? Why?
3466000	3468000	No, really, I want to know.
3470000	3472000	Does JavaScript think zero is false?
3472000	3474000	I don't even remember.
3478000	3480000	That's reassuring.
3480000	3482000	It's not reassuring that that's not a type error.
3486000	3488000	Actually, it should return something like that, probably.
3488000	3490000	Anyway.
3490000	3492000	What does double equals do?
3492000	3494000	Oh, man.
3518000	3520000	No.
3520000	3522000	No.
3522000	3524000	No.
3524000	3526000	No.
3526000	3528000	No.
3528000	3530000	No.
3530000	3532000	No.
3532000	3534000	No.
3534000	3536000	No.
3536000	3538000	No.
3538000	3540000	No.
3542000	3544000	No.
3544000	3546000	No.
