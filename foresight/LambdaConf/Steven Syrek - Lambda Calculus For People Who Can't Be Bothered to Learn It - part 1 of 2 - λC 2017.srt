1
00:00:00,000 --> 00:00:10,000
Rwy'n cael ei ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud.

2
00:00:30,000 --> 00:00:43,000
So, welcome everybody to this workshop, Lambda Calculus for people who can't be bothered to learn it.

3
00:00:43,000 --> 00:00:52,000
I was surprised to see on the schedule, I think there are at least four Lambda Calculus related workshops and presentations at this conference.

4
00:00:52,000 --> 00:00:56,000
That's a lot of Lambda Calculus. Did any of you go to the six hour one yesterday?

5
00:00:57,000 --> 00:01:09,000
Dana Scott? All day? How was that? I'm sure way over my head. This will not be a reprise of that at all.

6
00:01:09,000 --> 00:01:16,000
For people who can't be bothered to learn it part, that is because I'm not really going to teach you all of Lambda Calculus.

7
00:01:16,000 --> 00:01:20,000
It is actually quite a deep subject, there's a lot to it, there are many different Lambda Calculi.

8
00:01:20,000 --> 00:01:27,000
I'm mostly going to be doing a little bit with the simply type Lambda Calculus, which I think is something anybody can learn pretty quickly.

9
00:01:27,000 --> 00:01:36,000
And it can actually be a little bit fun. Also though we're going to be implementing it in America's favorite programming language, JavaScript.

10
00:01:36,000 --> 00:01:43,000
Now this is not because I recommend JavaScript for functional programming or any practical purpose whatsoever.

11
00:01:43,000 --> 00:01:49,000
It's because I don't want to have to ask everybody to install Haskell or some other language.

12
00:01:49,000 --> 00:01:55,000
You all have JavaScript on your machines already. For those of you who don't know this, you may be slightly surprised by that fact.

13
00:01:55,000 --> 00:02:01,000
But I assume all of you know this in your browsers, you have a console, it runs JavaScript, that's all you need. So easy for me.

14
00:02:01,000 --> 00:02:09,000
I'm also not going to be using very much of the JavaScript syntax such as it is at all. Just anonymous functions, but we'll get to that.

15
00:02:10,000 --> 00:02:20,000
So again, just to reiterate, please stop me, ask questions. I don't generally like the Socratic method of teaching, but let's see if you can read my mind.

16
00:02:20,000 --> 00:02:27,000
What do you suppose is maybe the simplest, what you might think of as the dumbest possible question you might ask about Lambda Calculus?

17
00:02:27,000 --> 00:02:30,000
Anyone want to take a guess? I'll never do this again.

18
00:02:31,000 --> 00:02:32,000
Why?

19
00:02:32,000 --> 00:02:33,000
Why what?

20
00:02:41,000 --> 00:02:44,000
Why do you need to bother?

21
00:02:46,000 --> 00:02:48,000
That's a smart question. I'm looking for a dumb question.

22
00:02:51,000 --> 00:02:55,000
That's it. Yeah, why is it called Lambda Calculus? Does anyone actually know why it's called Lambda Calculus? I know you know.

23
00:02:56,000 --> 00:03:01,000
No, no, no, no. I don't want you to. Yeah. Yeah. Yeah. Okay. Good. I'm glad for all of you people know.

24
00:03:01,000 --> 00:03:07,000
This is an important point. It seems like a trivial point. This might be a little bit of mythology. Very quickly. I think it's kind of funny.

25
00:03:07,000 --> 00:03:12,000
All right. People are afraid of this. It's got a Greek letter. It's called Calculus. If you're not a math person, I'm not a math person. It sounds scary, right?

26
00:03:12,000 --> 00:03:18,000
Forget the calculus part. You know, we're going to count some things with it or something like that. So forget calculus.

27
00:03:18,000 --> 00:03:23,000
But Lambda, what is this Lambda thing? A little bit intimidating. This whole conference is about Lambdas, right? Lambda comp.

28
00:03:23,000 --> 00:03:45,000
Well, Alonso Church, the person who developed, discovered, invented Lambda Calculus, the story that I read in academic literature was that he actually wanted to use some notation from, I guess, the 18th century that looked something like this, actually like a little hat.

29
00:03:46,000 --> 00:03:55,000
If he had gotten his way, we'd be calling it hat calculus, I suppose. I know that sounds funny, but there actually is a hat calculus. Look it up on Wikipedia. It became a different thing.

30
00:03:55,000 --> 00:04:06,000
Back then, professors had secretaries. I'm actually a recovering English professor. I never had a secretary. But typewriters couldn't do that.

31
00:04:06,000 --> 00:04:20,000
So his secretary ended up kind of doing that to represent it. He could do that with some slashes. This could all be a myth. I don't know. What does that look like? Yeah, capital Lambda, right? That's it.

32
00:04:20,000 --> 00:04:29,000
So they called it Lambda Calculus and eventually went lowercase. I suppose it looks nicer. They use this for type systems now. That's it. So what is the point?

33
00:04:29,000 --> 00:04:40,000
I mean, okay, it's like a little bit of a factoid. Completely arbitrary, right? These are not things to be scared of. All of the names that are used in Lambda Calculus and much of functional programming, they're just arbitrary names.

34
00:04:40,000 --> 00:04:53,000
There's nothing to worry about. They sound a little bit intimidating. They certainly intimidated me. I may be more easily intimidated than all of you. But the point is like, who cares? It doesn't even matter. These names are not important.

35
00:04:54,000 --> 00:05:07,000
Okay. I'm not going to do a lot of slides. In fact, originally, I wasn't going to do any, but I thought it's probably worthwhile to introduce the syntax of Lambda Calculus a little bit before going straight into JavaScript.

36
00:05:07,000 --> 00:05:17,000
I need to ease you into JavaScript because I know it's a little bit painful. And I should introduce myself. This is my name, Stephen Syrac, in case you're wondering about the pronunciation. I'm SJ Syrac in all the places.

37
00:05:18,000 --> 00:05:34,000
And like I said, I'm a recovering English professor. And I just want to point out to you that if I can do this, you can do this. I've not been doing this for very long. I taught myself Lambda Calculus while I was learning Haskell not very long ago.

38
00:05:34,000 --> 00:05:41,000
I think I started a year and a half ago at the most. And I became very excited about it enough that I was willing to do this right now.

39
00:05:41,000 --> 00:05:48,000
So I want to make that point not only because I want to be encouraging to all of you, but because there are two purposes to this talk in my mind.

40
00:05:48,000 --> 00:05:57,000
One is that maybe I can communicate something about Lambda Calculus to you and why it's useful, why it's awesome, why it's the foundation of everything that this conference is about.

41
00:05:57,000 --> 00:06:07,000
But also, and for me more importantly, and for those of you who do have experience, and by the way, those of you who do have experience, feel free at any time to tell me when I'm wrong.

42
00:06:07,000 --> 00:06:12,000
I need that and I appreciate it. And also please help others around you.

43
00:06:12,000 --> 00:06:18,000
I want everyone to be able to come away from this presentation able to teach this material to somebody else.

44
00:06:18,000 --> 00:06:23,000
The only way the functional programming world is going to grow is if all of us become teachers.

45
00:06:23,000 --> 00:06:27,000
Maybe that sounds like an extreme statement, but we're a very small community.

46
00:06:27,000 --> 00:06:33,000
And for our own self-preservation, we need to expand, like expand or die.

47
00:06:33,000 --> 00:06:36,000
And the other reason I'm using JavaScript is precisely for this reason.

48
00:06:36,000 --> 00:06:42,000
You can go back to your places of work or to your friends if you can convince them to learn something called Lambda Calculus.

49
00:06:42,000 --> 00:06:50,000
And everybody has a web browser and you will be able to open that up and show them some things without having them install a complicated programming language or some software they don't understand.

50
00:06:50,000 --> 00:06:52,000
Because like I said, anybody can learn this.

51
00:06:52,000 --> 00:06:59,000
So if you already feel competent with this material, then at the very least you can help me develop this into a better presentation for teaching others.

52
00:06:59,000 --> 00:07:03,000
And then find a way to use this material to teach your colleagues, right?

53
00:07:03,000 --> 00:07:12,000
Because you may not get them to install Haskell, but you can get them to open up a browser and then you can just immediately start writing functions and show them how this stuff works.

54
00:07:12,000 --> 00:07:16,000
Okay, so that's enough motivation I think.

55
00:07:16,000 --> 00:07:18,000
Are there any questions at this point?

56
00:07:18,000 --> 00:07:23,000
I know that you wanted me to go over purposes and aims or something.

57
00:07:23,000 --> 00:07:35,000
Perhaps just some specific examples of how perhaps Lambda has helped you to better understand or other ways to change the way you approach my house.

58
00:07:35,000 --> 00:07:38,000
We don't program any Lambda Calculus.

59
00:07:38,000 --> 00:07:39,000
This is a mental exercise.

60
00:07:39,000 --> 00:07:41,000
Don't you?

61
00:07:41,000 --> 00:07:42,000
Don't you?

62
00:07:42,000 --> 00:07:48,000
That's very heavy, but it's a useful exercise for the ultimate American language.

63
00:07:48,000 --> 00:07:50,000
Thank you for asking.

64
00:07:50,000 --> 00:07:55,000
I think it's really useful for developing an intuition for what functional programming is all about.

65
00:07:55,000 --> 00:08:01,000
Raise your hand if you're really not sure what functional programming is.

66
00:08:01,000 --> 00:08:03,000
Yeah, honest people.

67
00:08:03,000 --> 00:08:05,000
Yeah, exactly.

68
00:08:05,000 --> 00:08:09,000
Raise your hand if you think that you would be able to competently explain it to somebody else.

69
00:08:09,000 --> 00:08:12,000
That's the other kind of question.

70
00:08:12,000 --> 00:08:16,000
Functional programming is programming with functions.

71
00:08:16,000 --> 00:08:17,000
So helpful.

72
00:08:17,000 --> 00:08:22,000
I think actually this material will really show you what functional programming is all about.

73
00:08:22,000 --> 00:08:25,000
It's elementary particles as it were.

74
00:08:25,000 --> 00:08:30,000
What has Lambda Calculus itself taught me about programming?

75
00:08:30,000 --> 00:08:33,000
I think I only have a boring answer to that question.

76
00:08:33,000 --> 00:08:35,000
Haskell is a Lambda Calculus.

77
00:08:35,000 --> 00:08:38,000
So I made this joke, don't we program with Lambda Calculus?

78
00:08:38,000 --> 00:08:42,000
Yes, if you're using functional programming language or using Lambda Calculus, you just may not know it.

79
00:08:42,000 --> 00:08:44,000
So at the very least now you'll know it.

80
00:08:44,000 --> 00:08:49,000
I never really thought about how Lambda Calculus specifically...

81
00:08:49,000 --> 00:08:54,000
I mean, I suppose I can look at a function and know that I'm doing Ada reduction now,

82
00:08:54,000 --> 00:08:56,000
or that maybe I should do Ada reduction.

83
00:08:56,000 --> 00:09:01,000
I guess there are places in which it helps me with refactoring or conceptualizing.

84
00:09:01,000 --> 00:09:05,000
I'm not going to be talking specifically about that, I don't think.

85
00:09:05,000 --> 00:09:13,000
I guess I would maybe be able to talk about how Lambda Calculus gives us for free all of these features that we hear about

86
00:09:13,000 --> 00:09:15,000
when we talk about FP, right?

87
00:09:15,000 --> 00:09:21,000
Referential transparency, immutability, currying.

88
00:09:21,000 --> 00:09:23,000
What are some other good ones?

89
00:09:23,000 --> 00:09:25,000
I don't know, fixed point recursion?

90
00:09:25,000 --> 00:09:28,000
Anyway, that stuff all just sort of falls out for free from Lambda Calculus.

91
00:09:28,000 --> 00:09:30,000
Anyway, let's get to it.

92
00:09:30,000 --> 00:09:31,000
This is the whole language, right?

93
00:09:31,000 --> 00:09:33,000
World's smallest programming language.

94
00:09:33,000 --> 00:09:37,000
Maybe actually the first programming language invented.

95
00:09:37,000 --> 00:09:41,000
1933, anyone know the date? 1933?

96
00:09:41,000 --> 00:09:43,000
I think it up in Wikipedia, Alonso Church, Lambda Calculus.

97
00:09:43,000 --> 00:09:45,000
Before there were computers, right?

98
00:09:45,000 --> 00:09:48,000
They got it right the first time.

99
00:09:48,000 --> 00:09:54,000
This is the whole language right here.

100
00:09:54,000 --> 00:09:57,000
Concentrating first on the first line.

101
00:09:57,000 --> 00:10:03,000
Anything in Lambda Calculus is an expression, and then there are three kinds of expressions.

102
00:10:03,000 --> 00:10:07,000
Names, functions, and applications, and that's it.

103
00:10:07,000 --> 00:10:11,000
A function can be a name, so the lambda name.

104
00:10:11,000 --> 00:10:13,000
I'm going to explain all this a little bit in more detail.

105
00:10:13,000 --> 00:10:18,000
Lambda name.expression, and an application is just two expressions next to each other.

106
00:10:18,000 --> 00:10:23,000
So you can see how this is a bit of a recursively defined language.

107
00:10:23,000 --> 00:10:29,000
The lambda in the second line, that's the famous lambda that everybody wears.

108
00:10:29,000 --> 00:10:31,000
Does anyone have a lambda on their t-shirt right now?

109
00:10:31,000 --> 00:10:35,000
I'd be surprised, actually, if nobody did.

110
00:10:35,000 --> 00:10:38,000
You're probably all wearing one on your lanyard thing.

111
00:10:38,000 --> 00:10:40,000
It's just an abstraction operator.

112
00:10:40,000 --> 00:10:43,000
If you're a programmer, you're used to abstraction, even if you don't know functional programming.

113
00:10:43,000 --> 00:10:53,000
All that is saying is create an abstraction called name and bind to that, this expression, whatever the expression is.

114
00:10:53,000 --> 00:10:58,000
And then function application is two expressions next to each other.

115
00:10:58,000 --> 00:11:04,000
So if you're used to Haskell syntax, the reason why we don't have parentheses in Haskell is because function application is kind of the only operation we have.

116
00:11:04,000 --> 00:11:09,000
So we keep it simple. It's just two expressions next to each other.

117
00:11:09,000 --> 00:11:15,000
I'm so happy to have a blackboard. I don't do slides, so I'm more used to blackboards personally.

118
00:11:15,000 --> 00:11:18,000
God, this is like very fat chalk.

119
00:11:18,000 --> 00:11:24,000
I will be showing some expressions soon, but I just want to make this point.

120
00:11:24,000 --> 00:11:29,000
So you can have something like lambda x dot x.

121
00:11:29,000 --> 00:11:32,000
We actually call this the identity function.

122
00:11:32,000 --> 00:11:43,000
And this part here, we can call it the head, this part is the body.

123
00:11:43,000 --> 00:11:48,000
This is an expression.

124
00:11:48,000 --> 00:11:51,000
Obviously x has no meaning. This is an abstract syntax.

125
00:11:51,000 --> 00:12:01,000
Whatever you have here, whatever the expression is, it's just some stuff that we're going to compute under this thing, lambda x.

126
00:12:01,000 --> 00:12:07,000
You've heard anonymous function. I don't like anonymous function. It doesn't have a name. It doesn't matter.

127
00:12:07,000 --> 00:12:12,000
This operator creates an abstraction out of this expression.

128
00:12:12,000 --> 00:12:16,000
And the x just means that this x and this x are the same.

129
00:12:16,000 --> 00:12:27,000
If you're used to functions that look something like this, it's just text substitution, really.

130
00:12:28,000 --> 00:12:31,000
Really, it's just text substitution. This was invented before there were computers.

131
00:12:31,000 --> 00:12:36,000
In fact, with the lambda calculus, as simple as it is, you can model any computation whatsoever.

132
00:12:36,000 --> 00:12:38,000
That's what's really neat about it. Maybe that's a good answer to your question.

133
00:12:38,000 --> 00:12:41,000
You can compute anything that can be computed with this.

134
00:12:41,000 --> 00:12:44,000
It doesn't seem like you should be able to. I'll prove that.

135
00:12:44,000 --> 00:12:48,000
I mean, there are things you can't compute, and there are things you can,

136
00:12:48,000 --> 00:12:54,000
and that's just sort of a property of nature, and this sort of captures that in the simplest possible way.

137
00:12:54,000 --> 00:12:58,000
So, there's an expression, x. It's just something, something x.

138
00:12:58,000 --> 00:13:01,000
Lambda x.x, I just showed you that. This is a function.

139
00:13:01,000 --> 00:13:07,000
Body dot body dot, sorry, head dot body.

140
00:13:07,000 --> 00:13:16,000
Lambda x.lambda y.xy. This is another expression, and you can think of this as a function with two arguments, x and y.

141
00:13:17,000 --> 00:13:21,000
Lambda x.x, in parentheses, applied to y.

142
00:13:21,000 --> 00:13:26,000
This is not terribly different than if you had simply x, y.

143
00:13:26,000 --> 00:13:33,000
This is also function application. This lambda x.x, y is also function application.

144
00:13:33,000 --> 00:13:38,000
By function application, again, I mean text substitution.

145
00:13:38,000 --> 00:13:43,000
It's probably worth not thinking too much about functions as procedures,

146
00:13:43,000 --> 00:13:47,000
or what you're used to in imperative programming languages.

147
00:13:47,000 --> 00:13:55,000
Lambda x.xy.

148
00:13:55,000 --> 00:13:58,000
Function application means we're doing text substitution,

149
00:13:58,000 --> 00:14:03,000
so the y substitutes for this x in the expression.

150
00:14:03,000 --> 00:14:08,000
This goes away, and we're just left with y.

151
00:14:08,000 --> 00:14:13,000
Y goes into x, turns into y.

152
00:14:13,000 --> 00:14:21,000
This is also a function application, and it's not more complicated.

153
00:14:21,000 --> 00:14:27,000
They get longer and more, they look trickier, but ultimately the rules are the same.

154
00:14:27,000 --> 00:14:32,000
Lambda x.x, lambda y.

155
00:14:32,000 --> 00:14:34,000
Anybody want to guess what this turns into?

156
00:14:35,000 --> 00:14:41,000
Because this whole thing goes into here and is substituted for this x,

157
00:14:41,000 --> 00:14:44,000
so we're just left with that.

158
00:14:44,000 --> 00:14:48,000
This is one of the operations, actually, beta reduction.

159
00:14:48,000 --> 00:14:51,000
Anybody want to get another guess for the audience?

160
00:14:51,000 --> 00:14:56,000
When we say alpha substitution or alpha conversion, where does the alpha come from?

161
00:14:56,000 --> 00:14:58,000
Why alpha?

162
00:14:58,000 --> 00:15:01,000
What's the dumbest possible answer?

163
00:15:02,000 --> 00:15:05,000
Yeah, that's it.

164
00:15:05,000 --> 00:15:07,000
I've got to call it something.

165
00:15:15,000 --> 00:15:19,000
Oh god, I can try the third one.

166
00:15:24,000 --> 00:15:27,000
Lambda x, lambda y, xy.

167
00:15:27,000 --> 00:15:29,000
Lambda x.

168
00:15:32,000 --> 00:15:35,000
Write that using, like, f?

169
00:15:40,000 --> 00:15:43,000
Well, does somebody else want to try?

170
00:15:43,000 --> 00:15:46,000
I mean, I could do it, but maybe someone else should do it.

171
00:15:47,000 --> 00:16:01,000
I mean, I suppose you could have f of x, y,

172
00:16:01,000 --> 00:16:07,000
and then you could apply that to one and then two.

173
00:16:07,000 --> 00:16:10,000
I mean, these don't do anything, right?

174
00:16:10,000 --> 00:16:12,000
We don't know what x and y mean.

175
00:16:12,000 --> 00:16:14,000
It's just a function.

176
00:16:15,000 --> 00:16:17,000
It's just a pure function.

177
00:16:17,000 --> 00:16:20,000
For any given input, it has the same output, right?

178
00:16:23,000 --> 00:16:25,000
Whatever x you give it is always x.

179
00:16:25,000 --> 00:16:27,000
It's always the same, right?

180
00:16:27,000 --> 00:16:29,000
It's mapping between sets.

181
00:16:29,000 --> 00:16:31,000
Is that helpful?

182
00:16:31,000 --> 00:16:44,000
When we get to the JavaScript,

183
00:16:44,000 --> 00:16:46,000
well, I never thought I would say this sentence.

184
00:16:46,000 --> 00:16:49,000
When we get to JavaScript, it'll make more sense.

185
00:16:49,000 --> 00:16:52,000
OK, so here's alpha substitution.

186
00:16:52,000 --> 00:16:55,000
Again, the variable names, they don't mean anything.

187
00:16:55,000 --> 00:16:58,000
You can use any variable that you want,

188
00:16:58,000 --> 00:17:01,000
and yeah, I'm being very funny about using poop emoji,

189
00:17:01,000 --> 00:17:04,000
but the point is these are all the same, OK?

190
00:17:04,000 --> 00:17:06,000
I'm going to use this triple equals a lot

191
00:17:06,000 --> 00:17:08,000
because this is not equality per se.

192
00:17:08,000 --> 00:17:10,000
These are all actually identical.

193
00:17:10,000 --> 00:17:12,000
Lambda A dot A, lambda Z dot Z, poop, whatever.

194
00:17:12,000 --> 00:17:14,000
They're all the same.

195
00:17:14,000 --> 00:17:16,000
All of these represent the exact same things.

196
00:17:16,000 --> 00:17:19,000
You can substitute them one for the other.

197
00:17:19,000 --> 00:17:23,000
And you sometimes need to do that in complicated lambda reductions,

198
00:17:23,000 --> 00:17:25,000
which we are not going to do, right?

199
00:17:25,000 --> 00:17:27,000
I don't want to learn lambda calculus.

200
00:17:27,000 --> 00:17:29,000
That's why you came here.

201
00:17:29,000 --> 00:17:31,000
When we get to the JavaScript, sorry, yeah?

202
00:17:31,000 --> 00:17:35,000
Is there a difference between the same after the dot?

203
00:17:35,000 --> 00:17:37,000
Legibility?

204
00:17:37,000 --> 00:17:39,000
But no.

205
00:17:39,000 --> 00:17:43,000
You're separating the arguments from the expression.

206
00:17:43,000 --> 00:17:45,000
That's what the period is.

207
00:17:45,000 --> 00:17:46,000
Yeah, yeah, yeah.

208
00:17:46,000 --> 00:17:48,000
A is the argument.

209
00:17:48,000 --> 00:17:50,000
Lambda A, that A is the argument,

210
00:17:50,000 --> 00:17:52,000
and the A after the dot is the expression.

211
00:17:52,000 --> 00:17:54,000
Yeah.

212
00:17:54,000 --> 00:17:56,000
It doesn't matter. It's just notation, right?

213
00:17:56,000 --> 00:17:58,000
This is not a programming language.

214
00:17:58,000 --> 00:18:00,000
I'm sorry, this is a programming language.

215
00:18:00,000 --> 00:18:02,000
This is not something you can run on a computer.

216
00:18:02,000 --> 00:18:04,000
Here's a slightly more complicated.

217
00:18:04,000 --> 00:18:06,000
That was alpha substitution. This is beta reduction.

218
00:18:06,000 --> 00:18:08,000
I kind of did a few already, so I hope this makes sense.

219
00:18:08,000 --> 00:18:12,000
You have lambda X, lambda Y, X, Y applied to P and Q.

220
00:18:12,000 --> 00:18:14,000
So first you apply the P, the X goes away.

221
00:18:14,000 --> 00:18:16,000
Now you have lambda Y dot PY.

222
00:18:16,000 --> 00:18:18,000
Then you apply the Q, the lambda Y goes away,

223
00:18:18,000 --> 00:18:20,000
and you end up with PQ.

224
00:18:20,000 --> 00:18:23,000
Does that make sense?

225
00:18:24,000 --> 00:18:26,000
It worries me sometimes that this stuff doesn't actually

226
00:18:26,000 --> 00:18:28,000
make intuitive sense, so if it doesn't make sense,

227
00:18:28,000 --> 00:18:30,000
I will explain it in more detail.

228
00:18:30,000 --> 00:18:32,000
Again, I thought I was going to get 10 people,

229
00:18:32,000 --> 00:18:34,000
and I'd be like, does it make sense to you?

230
00:18:34,000 --> 00:18:36,000
I think it does.

231
00:18:36,000 --> 00:18:39,000
I know. Well, we're going to get there.

232
00:18:39,000 --> 00:18:41,000
This is just supposed to be a warm-up.

233
00:18:41,000 --> 00:18:43,000
I actually don't want this to take that long.

234
00:18:43,000 --> 00:18:44,000
This is kind of neat.

235
00:18:44,000 --> 00:18:48,000
Lambda X dot XX applied to lambda X dot XX.

236
00:18:48,000 --> 00:18:51,000
When we reduce that, we get the same thing, right?

237
00:18:51,000 --> 00:18:56,000
Because if you plug this into this expression,

238
00:18:56,000 --> 00:18:59,000
this X goes away, and you actually substitute this

239
00:18:59,000 --> 00:19:01,000
for both of these Xs, right,

240
00:19:01,000 --> 00:19:04,000
and then you get the same thing again.

241
00:19:04,000 --> 00:19:06,000
Recursion.

242
00:19:06,000 --> 00:19:08,000
You can do recursion with pencil and paper.

243
00:19:08,000 --> 00:19:11,000
I thought that was pretty neat when I first learned it.

244
00:19:11,000 --> 00:19:13,000
Finally, eta conversion.

245
00:19:13,000 --> 00:19:15,000
This is mostly for your information.

246
00:19:15,000 --> 00:19:18,000
It's not going to be terribly important for the talk today,

247
00:19:18,000 --> 00:19:21,000
except eta conversion will come up in one very important place later.

248
00:19:21,000 --> 00:19:26,000
What I'm saying here is that maybe this is the math part that will help.

249
00:19:26,000 --> 00:19:28,000
I don't know.

250
00:19:35,000 --> 00:19:38,000
I can't really make it simpler than it is.

251
00:19:38,000 --> 00:19:40,000
Lambda X dot F of X is just the same thing as F.

252
00:19:40,000 --> 00:19:44,000
The X is superfluous. It's the same thing as a function F.

253
00:19:44,000 --> 00:19:46,000
If you have a function F applied to an X,

254
00:19:46,000 --> 00:19:48,000
you can put that into a lambda abstraction.

255
00:19:48,000 --> 00:19:51,000
That is the same thing as F itself.

256
00:20:05,000 --> 00:20:07,000
Which one?

257
00:20:07,000 --> 00:20:09,000
Lambda X dot F of X.

258
00:20:09,000 --> 00:20:11,000
That's a good point.

259
00:20:19,000 --> 00:20:21,000
I wasn't going to talk about free variables.

260
00:20:21,000 --> 00:20:23,000
The F is not bound in this expression.

261
00:20:23,000 --> 00:20:25,000
If I were actually teaching you lambda calculus,

262
00:20:25,000 --> 00:20:27,000
which I'm not supposed to be doing,

263
00:20:27,000 --> 00:20:29,000
I would say that the F is a free variable.

264
00:20:29,000 --> 00:20:31,000
It's F in some global state.

265
00:20:31,000 --> 00:20:33,000
We don't like global state in functional programming.

266
00:20:33,000 --> 00:20:36,000
It represents some global binding F.

267
00:20:36,000 --> 00:20:38,000
These two things just happen to be identical in meaning.

268
00:20:38,000 --> 00:20:40,000
The F is the same in this case.

269
00:20:40,000 --> 00:20:42,000
That's a good point.

270
00:20:42,000 --> 00:20:44,000
Let's get right into combinators.

271
00:20:44,000 --> 00:20:46,000
Another scary word.

272
00:20:46,000 --> 00:20:50,000
A combinator is a function with no free variables.

273
00:20:50,000 --> 00:20:52,000
It's a function you can combine with other functions

274
00:20:52,000 --> 00:20:54,000
to do some very neat things.

275
00:20:54,000 --> 00:20:56,000
We've already seen this one.

276
00:20:56,000 --> 00:20:58,000
Lambda X dot X.

277
00:20:58,000 --> 00:21:00,000
We call this the identity function because whatever we give it,

278
00:21:00,000 --> 00:21:02,000
we get it back again.

279
00:21:02,000 --> 00:21:04,000
This will prove to be useful and important

280
00:21:04,000 --> 00:21:06,000
in many places in functional programming.

281
00:21:06,000 --> 00:21:08,000
This is also, I guess you could say,

282
00:21:08,000 --> 00:21:10,000
the universal fixed point combinator.

283
00:21:10,000 --> 00:21:12,000
That sounds scary too.

284
00:21:12,000 --> 00:21:16,000
The fixed point of a function

285
00:21:16,000 --> 00:21:18,000
is the value that when you give it to a function,

286
00:21:18,000 --> 00:21:20,000
you get the same value back.

287
00:21:20,000 --> 00:21:24,000
There are many examples of this in math.

288
00:21:24,000 --> 00:21:26,000
I'm not going to go over them,

289
00:21:26,000 --> 00:21:28,000
but I hope you can see that for this function.

290
00:21:28,000 --> 00:21:30,000
Lambda X dot X.

291
00:21:30,000 --> 00:21:32,000
Whatever you give it, you get back.

292
00:21:32,000 --> 00:21:35,000
That's what I mean by universal fixed point combinator.

293
00:21:35,000 --> 00:21:39,000
Fixed point combinators will also come up again later

294
00:21:39,000 --> 00:21:41,000
in a much sexier way.

295
00:21:41,000 --> 00:21:47,000
This is what the identity function looks like in Haskell.

296
00:21:47,000 --> 00:21:49,000
My favorite programming language.

297
00:21:49,000 --> 00:21:51,000
And yours too, I assume.

298
00:21:51,000 --> 00:21:55,000
It's not easy to type a lambda on your computer,

299
00:21:55,000 --> 00:21:57,000
so we have a slash there instead.

300
00:21:57,000 --> 00:21:59,000
That represents a lambda, essentially.

301
00:21:59,000 --> 00:22:03,000
This is what we're going to use in JavaScript.

302
00:22:03,000 --> 00:22:05,000
Assuming that your browsers are all up to date

303
00:22:05,000 --> 00:22:07,000
and you have fat arrow functions.

304
00:22:07,000 --> 00:22:09,000
Same thing, very simple, right?

305
00:22:09,000 --> 00:22:11,000
This is the basic building block that we're going to use.

306
00:22:11,000 --> 00:22:13,000
Anybody know what this is?

307
00:22:13,000 --> 00:22:15,000
Python.

308
00:22:15,000 --> 00:22:17,000
Yeah, Python.

309
00:22:17,000 --> 00:22:19,000
Anyway, what about that?

310
00:22:19,000 --> 00:22:21,000
Ruby.

311
00:22:21,000 --> 00:22:23,000
Yeah, this is good for me to gauge the room.

312
00:22:23,000 --> 00:22:25,000
Who knows what?

313
00:22:25,000 --> 00:22:27,000
What about this weird looking one?

314
00:22:27,000 --> 00:22:29,000
Not Ruby.

315
00:22:29,000 --> 00:22:31,000
No.

316
00:22:31,000 --> 00:22:33,000
Can you do this in Java? I don't actually know Java.

317
00:22:33,000 --> 00:22:35,000
I'm proud of the fact.

318
00:22:35,000 --> 00:22:39,000
I've been programming as a hobby my whole life.

319
00:22:39,000 --> 00:22:41,000
I lost interest in the 90s,

320
00:22:41,000 --> 00:22:43,000
which is when Java started becoming popular

321
00:22:43,000 --> 00:22:45,000
and I got back into it not very long ago.

322
00:22:45,000 --> 00:22:49,000
I feel like my great pride in life is I missed the Java period.

323
00:22:49,000 --> 00:22:51,000
I hope.

324
00:22:51,000 --> 00:22:53,000
I'm sorry if I'm moving too quickly.

325
00:22:53,000 --> 00:22:55,000
I do want to get to JavaScript.

326
00:22:55,000 --> 00:22:57,000
I can't believe I'm saying this stuff.

327
00:22:58,000 --> 00:23:00,000
Now we have a very simple notation

328
00:23:00,000 --> 00:23:02,000
for creating computations,

329
00:23:02,000 --> 00:23:04,000
but it's a little bit clumsy.

330
00:23:04,000 --> 00:23:07,000
We need to actually start creating some primitive values.

331
00:23:07,000 --> 00:23:09,000
We can create true.

332
00:23:09,000 --> 00:23:12,000
Again, this is not a binding in the sense of a variable binding.

333
00:23:12,000 --> 00:23:14,000
These two things are completely equivalent.

334
00:23:14,000 --> 00:23:16,000
They are a substitutable one for another wherever you see them.

335
00:23:16,000 --> 00:23:18,000
We're just going to say,

336
00:23:18,000 --> 00:23:20,000
lambda x dot lambda y dot x means true.

337
00:23:20,000 --> 00:23:23,000
This is simply a function that takes two values,

338
00:23:23,000 --> 00:23:26,000
an x and a y, and it returns the first one.

339
00:23:26,000 --> 00:23:28,000
We're just going to say that that's true.

340
00:23:28,000 --> 00:23:30,000
You could do it a different way if you want,

341
00:23:30,000 --> 00:23:32,000
but we're going to use that as our convention.

342
00:23:32,000 --> 00:23:35,000
We're just going to encode true as this function.

343
00:23:35,000 --> 00:23:38,000
We're going to encode false as the opposite.

344
00:23:38,000 --> 00:23:40,000
It's a function that takes two values

345
00:23:40,000 --> 00:23:42,000
and returns the second value.

346
00:23:42,000 --> 00:23:44,000
That's it.

347
00:23:44,000 --> 00:23:47,000
This is not like some standard of lambda calculus.

348
00:23:47,000 --> 00:23:49,000
This is just totally a convention.

349
00:23:49,000 --> 00:23:51,000
It's the convention that is typically used, so I'm using it,

350
00:23:51,000 --> 00:23:53,000
but we're just making it up.

351
00:23:53,000 --> 00:23:55,000
Did I see a hand somewhere?

352
00:23:55,000 --> 00:23:57,000
Sorry, I was just going to interject.

353
00:23:57,000 --> 00:23:59,000
If somebody is trying to use node and you're using

354
00:23:59,000 --> 00:24:01,000
new language features, it might not work.

355
00:24:01,000 --> 00:24:03,000
You can use Babel.

356
00:24:03,000 --> 00:24:05,000
I'm going to put that in the chat.

357
00:24:05,000 --> 00:24:07,000
Okay.

358
00:24:07,000 --> 00:24:12,000
Actually, Babel inspired me to do this at some point.

359
00:24:12,000 --> 00:24:14,000
Actually, I was very frustrated

360
00:24:14,000 --> 00:24:16,000
with trying to learn lambda calculus.

361
00:24:16,000 --> 00:24:18,000
I started messing around with it in JavaScript

362
00:24:18,000 --> 00:24:20,000
because it was there.

363
00:24:20,000 --> 00:24:22,000
Then eventually one thing led to another.

364
00:24:22,000 --> 00:24:23,000
Here we are.

365
00:24:23,000 --> 00:24:25,000
We can make more complicated functions,

366
00:24:25,000 --> 00:24:27,000
logic functions like and.

367
00:24:27,000 --> 00:24:30,000
I hope that if you look at this and you're a programmer,

368
00:24:30,000 --> 00:24:32,000
this makes sense.

369
00:24:32,000 --> 00:24:34,000
If you have two values, you can determine

370
00:24:34,000 --> 00:24:37,000
whether or not they are both true.

371
00:24:37,000 --> 00:24:40,000
You look at the first one.

372
00:24:40,000 --> 00:24:42,000
Is it true?

373
00:24:42,000 --> 00:24:44,000
If it's true, you compare it to the second one.

374
00:24:44,000 --> 00:24:48,000
Actually, let me be clear here.

375
00:24:48,000 --> 00:24:50,000
We have two functions, true and false.

376
00:24:50,000 --> 00:24:52,000
True returns the first value.

377
00:24:52,000 --> 00:24:54,000
False returns the second value.

378
00:24:54,000 --> 00:25:00,000
If A is a Boolean value, true or false,

379
00:25:00,000 --> 00:25:03,000
if it's true, it's going to return whatever B is.

380
00:25:03,000 --> 00:25:05,000
If it's false, it returns false right away

381
00:25:05,000 --> 00:25:08,000
because it's an and.

382
00:25:08,000 --> 00:25:10,000
If B is a true, then it's true.

383
00:25:10,000 --> 00:25:12,000
If B is false, then the whole thing is false.

384
00:25:12,000 --> 00:25:13,000
Does that make sense?

385
00:25:13,000 --> 00:25:15,000
That's why that looks like that.

386
00:25:15,000 --> 00:25:17,000
I can do it on the board too.

387
00:25:17,000 --> 00:25:19,000
I hate chalk.

388
00:25:20,000 --> 00:25:23,000
From my understanding, I see that basically,

389
00:25:23,000 --> 00:25:26,000
when you see lambda x, it means the function f.

390
00:25:26,000 --> 00:25:29,000
In the first situation, it takes two variables,

391
00:25:29,000 --> 00:25:31,000
f of x, y.

392
00:25:31,000 --> 00:25:33,000
In this case, it returns x.

393
00:25:33,000 --> 00:25:36,000
In the second question, it takes f of x, y.

394
00:25:36,000 --> 00:25:38,000
Then it returns y.

395
00:25:38,000 --> 00:25:40,000
In the third case, it takes two arguments

396
00:25:40,000 --> 00:25:42,000
and returns an and.

397
00:25:42,000 --> 00:25:44,000
That's basically it.

398
00:25:44,000 --> 00:25:46,000
That's the same thing.

399
00:25:46,000 --> 00:25:48,000
It really isn't more complicated than that.

400
00:25:48,000 --> 00:25:52,000
Does the notation is just what is causing the confusion?

401
00:25:52,000 --> 00:25:55,000
Here's the ultimate cop out.

402
00:25:55,000 --> 00:25:57,000
I didn't invent this notation.

403
00:25:57,000 --> 00:25:59,000
It provides us a universal language

404
00:25:59,000 --> 00:26:01,000
with which to speak about functions

405
00:26:01,000 --> 00:26:03,000
and function application.

406
00:26:03,000 --> 00:26:05,000
When I said this is what functional programming

407
00:26:05,000 --> 00:26:07,000
is all about, literally everything is a function.

408
00:26:07,000 --> 00:26:08,000
You've heard everything is a function.

409
00:26:08,000 --> 00:26:09,000
What does that really mean?

410
00:26:09,000 --> 00:26:11,000
Functions are values.

411
00:26:11,000 --> 00:26:14,000
We're just saying lambda x dot lambda y to x is true.

412
00:26:14,000 --> 00:26:16,000
It is the value true.

413
00:26:16,000 --> 00:26:19,000
We're loading truth as that function.

414
00:26:19,000 --> 00:26:21,000
Then we can do stuff with that function

415
00:26:21,000 --> 00:26:23,000
to build up more complicated expressions.

416
00:26:23,000 --> 00:26:25,000
There's an and, there's an or.

417
00:26:25,000 --> 00:26:27,000
We can do not.

418
00:26:29,000 --> 00:26:31,000
Now we have booleans.

419
00:26:31,000 --> 00:26:34,000
We're getting close to being able to do actual logic.

420
00:26:34,000 --> 00:26:36,000
It's all functions.

421
00:26:36,000 --> 00:26:39,000
I don't know how you feel about this inside your own head.

422
00:26:39,000 --> 00:26:41,000
This was mind-blowing for me when I first learned about it.

423
00:26:41,000 --> 00:26:43,000
Reducing expressions.

424
00:26:43,000 --> 00:26:45,000
We can take an and and a true and a false.

425
00:26:45,000 --> 00:26:47,000
We can take the lambdas back in.

426
00:26:47,000 --> 00:26:48,000
It looks like that.

427
00:26:48,000 --> 00:26:50,000
Already it's starting to be headache inducing.

428
00:26:50,000 --> 00:26:51,000
I know.

429
00:26:51,000 --> 00:26:55,000
The point is and a true false is identical to this expression.

430
00:26:55,000 --> 00:26:58,000
It's easier for us as people to deal with and true false

431
00:26:58,000 --> 00:27:00,000
than with all of this lambda stuff,

432
00:27:00,000 --> 00:27:02,000
but you can actually still work this out on paper.

433
00:27:02,000 --> 00:27:05,000
You can perform these reduction steps that I showed you.

434
00:27:05,000 --> 00:27:07,000
Ultimately, there's the first step of the reduction,

435
00:27:07,000 --> 00:27:09,000
another step of the reduction, another step, another step.

436
00:27:09,000 --> 00:27:11,000
By the way, the slides are all on GitHub,

437
00:27:11,000 --> 00:27:13,000
so you can play with this later if you like.

438
00:27:13,000 --> 00:27:15,000
Essentially, all of this reduces down to this function.

439
00:27:15,000 --> 00:27:17,000
These are the reduction steps.

440
00:27:17,000 --> 00:27:21,000
If you are plugging things in and replacing your bound values

441
00:27:21,000 --> 00:27:23,000
in the expressions at each step of the way,

442
00:27:23,000 --> 00:27:25,000
finally you get to lambda x dot lambda y dot lambda y,

443
00:27:25,000 --> 00:27:27,000
which we already know is false.

444
00:27:27,000 --> 00:27:28,000
That's how it works.

445
00:27:28,000 --> 00:27:30,000
That's how you do a computation anyway in lambda calculus.

446
00:27:30,000 --> 00:27:32,000
A very simple one.

447
00:27:37,000 --> 00:27:39,000
I can, but why do you want me to?

448
00:27:43,000 --> 00:27:45,000
I'm going to be honest with you.

449
00:27:45,000 --> 00:27:47,000
I hate touching chalk and I am trying to avoid it.

450
00:27:47,000 --> 00:27:49,000
I will do it if necessary,

451
00:27:49,000 --> 00:27:51,000
but I would just be writing that again.

452
00:27:51,000 --> 00:27:53,000
You want me to go through the whole thing?

453
00:27:53,000 --> 00:27:55,000
No, that's not.

454
00:27:55,000 --> 00:27:57,000
Totally, I will do it later, pen and paper,

455
00:27:57,000 --> 00:27:59,000
but it will take too long.

456
00:27:59,000 --> 00:28:01,000
I only have two hours.

457
00:28:01,000 --> 00:28:03,000
I think you were just saying the end in the last slide,

458
00:28:03,000 --> 00:28:05,000
you could just pop through it,

459
00:28:05,000 --> 00:28:07,000
but you didn't write it.

460
00:28:07,000 --> 00:28:09,000
Is it arbitrary like you're in false?

461
00:28:09,000 --> 00:28:11,000
Yes.

462
00:28:11,000 --> 00:28:13,000
I'm just going to say that's true and that's false.

463
00:28:15,000 --> 00:28:17,000
Just like truth and false in real life are arbitrary.

464
00:28:19,000 --> 00:28:21,000
You came for the deep stuff today.

465
00:28:23,000 --> 00:28:25,000
I know you want to look for some meaning,

466
00:28:25,000 --> 00:28:27,000
but I showed you that first slide with the,

467
00:28:29,000 --> 00:28:31,000
that's it, that's the whole language.

468
00:28:31,000 --> 00:28:33,000
Those three things are the whole language.

469
00:28:33,000 --> 00:28:35,000
I have to build the entire system of computation out of that,

470
00:28:35,000 --> 00:28:37,000
out of just functions.

471
00:28:37,000 --> 00:28:39,000
If I want to do Boolean operations,

472
00:28:39,000 --> 00:28:41,000
I need some notion of truth and false.

473
00:28:41,000 --> 00:28:43,000
If I want to do comparisons,

474
00:28:43,000 --> 00:28:45,000
I just have to invent them.

475
00:28:45,000 --> 00:28:47,000
I have to invent them in a way that they'll work

476
00:28:47,000 --> 00:28:49,000
and this happens to work.

477
00:28:49,000 --> 00:28:51,000
It seems like a bit of magic and I guess it is.

478
00:28:55,000 --> 00:28:57,000
You're saying that they're arbitrary,

479
00:28:57,000 --> 00:28:59,000
but they're not arbitrary

480
00:28:59,000 --> 00:29:01,000
in comparison to each other.

481
00:29:01,000 --> 00:29:03,000
These are built up in such a way that...

482
00:29:03,000 --> 00:29:05,000
The system is logically consistent.

483
00:29:05,000 --> 00:29:07,000
It actually has...

484
00:29:07,000 --> 00:29:09,000
It developed out of the study of logic, in fact.

485
00:29:09,000 --> 00:29:11,000
Formal logic.

486
00:29:11,000 --> 00:29:13,000
Not stuff I know a whole lot about.

487
00:29:13,000 --> 00:29:15,000
But yeah, they're not like random.

488
00:29:15,000 --> 00:29:17,000
They're sort of encodings that were decided upon

489
00:29:17,000 --> 00:29:19,000
as part of a system that is internally coherent.

490
00:29:21,000 --> 00:29:23,000
Wait till we get to numbers.

491
00:29:27,000 --> 00:29:29,000
Okay.

492
00:29:29,000 --> 00:29:31,000
So now that we have some Booleans,

493
00:29:31,000 --> 00:29:33,000
we can actually create useful functions.

494
00:29:33,000 --> 00:29:35,000
That determines whether or not a value is zero.

495
00:29:35,000 --> 00:29:37,000
I've rearranged this presentation

496
00:29:37,000 --> 00:29:39,000
since the last time I did some piece of it.

497
00:29:39,000 --> 00:29:41,000
So we don't have numbers yet.

498
00:29:41,000 --> 00:29:43,000
Bear with me.

499
00:29:43,000 --> 00:29:45,000
So let's say that X is a number.

500
00:29:45,000 --> 00:29:47,000
This function will tell you whether or not

501
00:29:47,000 --> 00:29:49,000
that number is zero.

502
00:29:51,000 --> 00:29:53,000
This is maybe an easier way to look at it.

503
00:29:55,000 --> 00:29:57,000
Is zero n?

504
00:29:57,000 --> 00:29:59,000
So is zero n is going to return

505
00:29:59,000 --> 00:30:01,000
a true or a false?

506
00:30:01,000 --> 00:30:03,000
And if it returns true,

507
00:30:03,000 --> 00:30:05,000
so we're applying...

508
00:30:05,000 --> 00:30:07,000
I think I need to maybe explain this a little bit better.

509
00:30:07,000 --> 00:30:09,000
So this is zero n

510
00:30:09,000 --> 00:30:11,000
is going to reduce down to a true or a false.

511
00:30:11,000 --> 00:30:13,000
We know that true returns the first value

512
00:30:13,000 --> 00:30:15,000
that it's given, right?

513
00:30:15,000 --> 00:30:17,000
So it's going to return true.

514
00:30:17,000 --> 00:30:19,000
If it's not zero, it will return false.

515
00:30:19,000 --> 00:30:21,000
Because false returns the second value.

516
00:30:21,000 --> 00:30:23,000
That's it.

517
00:30:23,000 --> 00:30:25,000
We're applying true and false to this function

518
00:30:25,000 --> 00:30:27,000
is zero n, yeah.

519
00:30:31,000 --> 00:30:33,000
So it's going to return true,

520
00:30:33,000 --> 00:30:35,000
and now you're talking about same features.

521
00:30:35,000 --> 00:30:37,000
So how do they match into the number?

522
00:30:37,000 --> 00:30:39,000
What is one for zero?

523
00:30:39,000 --> 00:30:41,000
Oh, you're going to love it.

524
00:30:41,000 --> 00:30:43,000
I think it's on the next slide.

525
00:30:43,000 --> 00:30:45,000
Yeah, yeah.

526
00:30:45,000 --> 00:30:47,000
I wanted to do predicates after a boolean,

527
00:30:47,000 --> 00:30:49,000
so the numbers are slightly out of order.

528
00:30:49,000 --> 00:30:51,000
So bear with me.

529
00:30:53,000 --> 00:30:55,000
Okay, so now we can have

530
00:30:55,000 --> 00:30:57,000
branching in our Lambda Calculus.

531
00:30:57,000 --> 00:30:59,000
We can say an if statement

532
00:30:59,000 --> 00:31:01,000
is simply a function

533
00:31:01,000 --> 00:31:03,000
that is a predicate, right?

534
00:31:03,000 --> 00:31:05,000
A predicate is a function that returns true or false.

535
00:31:05,000 --> 00:31:07,000
And then we apply to that

536
00:31:07,000 --> 00:31:09,000
two values, x and y.

537
00:31:09,000 --> 00:31:11,000
And if that predicate p is true,

538
00:31:11,000 --> 00:31:13,000
it will return the first value if it's false

539
00:31:13,000 --> 00:31:15,000
that returns the second value.

540
00:31:15,000 --> 00:31:17,000
Yeah.

541
00:31:17,000 --> 00:31:19,000
What's the definition of zero?

542
00:31:19,000 --> 00:31:21,000
You're saying is zero for a false.

543
00:31:21,000 --> 00:31:23,000
What is the definition of zero?

544
00:31:23,000 --> 00:31:25,000
We're going to get to that.

545
00:31:25,000 --> 00:31:27,000
Yeah.

546
00:31:27,000 --> 00:31:29,000
So that kind of would look like that, right?

547
00:31:29,000 --> 00:31:31,000
If n is zero,

548
00:31:31,000 --> 00:31:33,000
then you would do the value

549
00:31:33,000 --> 00:31:35,000
in that then branch.

550
00:31:35,000 --> 00:31:37,000
Otherwise, the else, right?

551
00:31:37,000 --> 00:31:39,000
And actually, we can factor out

552
00:31:39,000 --> 00:31:41,000
the p, the x, and the y.

553
00:31:41,000 --> 00:31:43,000
We can just say that if it's the identity function.

554
00:31:43,000 --> 00:31:45,000
It's the same thing really,

555
00:31:45,000 --> 00:31:47,000
because we're just dealing with predicates.

556
00:31:47,000 --> 00:31:49,000
Whoops.

557
00:31:49,000 --> 00:31:51,000
Right, that's...

558
00:31:51,000 --> 00:31:53,000
If you want to write it as like a little law for yourself, right?

559
00:31:53,000 --> 00:31:55,000
Expression one, expression two.

560
00:31:55,000 --> 00:31:57,000
If p is true, then e1, else e2.

561
00:31:57,000 --> 00:31:59,000
Okay. Everyone wants to do numbers.

562
00:31:59,000 --> 00:32:01,000
And you know what? I don't blame you, because

563
00:32:01,000 --> 00:32:03,000
how the heck do you do numbers with only functions?

564
00:32:03,000 --> 00:32:05,000
This is really where the whole idea

565
00:32:05,000 --> 00:32:07,000
of functions as values, I think, is going to

566
00:32:07,000 --> 00:32:09,000
make sense.

567
00:32:09,000 --> 00:32:11,000
I hope I'm going to drive this home for you.

568
00:32:13,000 --> 00:32:15,000
Speaking of arbitrary,

569
00:32:15,000 --> 00:32:17,000
we're going to call zero

570
00:32:17,000 --> 00:32:19,000
a function that takes

571
00:32:19,000 --> 00:32:21,000
an x and returns an x.

572
00:32:21,000 --> 00:32:23,000
It does nothing to it, right?

573
00:32:23,000 --> 00:32:25,000
We're just going to say that's zero.

574
00:32:29,000 --> 00:32:31,000
That's a zero, but it's just an encoding,

575
00:32:31,000 --> 00:32:33,000
ultimately. You can encode it in binary.

576
00:32:33,000 --> 00:32:35,000
That's another way of encoding it.

577
00:32:35,000 --> 00:32:37,000
Again, a convention.

578
00:32:37,000 --> 00:32:39,000
This symbol represents some idea

579
00:32:39,000 --> 00:32:41,000
of zero. We are so used to using it.

580
00:32:41,000 --> 00:32:43,000
We think, well, that's zero.

581
00:32:43,000 --> 00:32:45,000
And that's five.

582
00:32:45,000 --> 00:32:47,000
But it's just a symbol.

583
00:32:47,000 --> 00:32:49,000
There's one.

584
00:32:49,000 --> 00:32:51,000
Lambda f dot, lambda x

585
00:32:51,000 --> 00:32:53,000
dot f of x.

586
00:32:53,000 --> 00:32:55,000
You're going to see a pattern very soon.

587
00:32:55,000 --> 00:32:57,000
So now we're taking a function and a value,

588
00:32:57,000 --> 00:32:59,000
and we're applying the function to the value one time.

589
00:33:01,000 --> 00:33:03,000
There's two. There's three.

590
00:33:03,000 --> 00:33:05,000
You can probably guess what four looks like,

591
00:33:05,000 --> 00:33:07,000
and possibly 5,000 at this point.

592
00:33:07,000 --> 00:33:09,000
Because what is a number? If you're doing something

593
00:33:09,000 --> 00:33:11,000
with a number in computation,

594
00:33:11,000 --> 00:33:13,000
you may just be storing a value, but

595
00:33:13,000 --> 00:33:15,000
very likely you're probably going to be performing

596
00:33:15,000 --> 00:33:17,000
some operation that number of times, right?

597
00:33:17,000 --> 00:33:19,000
For any number n, you're going to do something

598
00:33:19,000 --> 00:33:21,000
three times. That's all that this is doing.

599
00:33:21,000 --> 00:33:23,000
Some number x.

600
00:33:23,000 --> 00:33:25,000
If you want to do something

601
00:33:25,000 --> 00:33:27,000
with the value three,

602
00:33:27,000 --> 00:33:29,000
then you apply, with a function,

603
00:33:29,000 --> 00:33:31,000
you apply that function to the value three times.

604
00:33:31,000 --> 00:33:33,000
Four, five.

605
00:33:35,000 --> 00:33:37,000
It gets ridiculous.

606
00:33:37,000 --> 00:33:39,000
And by the way, again, this is not variable binding.

607
00:33:41,000 --> 00:33:43,000
These are identical. I'm just using this

608
00:33:43,000 --> 00:33:45,000
as a convenient symbol. You could use poop emoji here, too, if you want.

609
00:33:45,000 --> 00:33:47,000
I want you to be able to read this.

610
00:33:47,000 --> 00:33:49,000
So, all of this stuff,

611
00:33:49,000 --> 00:33:51,000
I don't want to type that ever again.

612
00:33:51,000 --> 00:33:53,000
Especially when they start to get really big.

613
00:33:53,000 --> 00:33:55,000
So, I just attach convenient names to them

614
00:33:55,000 --> 00:33:57,000
for my own benefit.

615
00:33:57,000 --> 00:33:59,000
Now, enumeration. We can actually

616
00:33:59,000 --> 00:34:01,000
work with these numbers and get somewhere with them.

617
00:34:01,000 --> 00:34:03,000
There is a function that will tell you what the

618
00:34:03,000 --> 00:34:05,000
next value is for a given value n.

619
00:34:07,000 --> 00:34:09,000
This one's more complicated.

620
00:34:11,000 --> 00:34:13,000
I don't want to divert too much into these things.

621
00:34:13,000 --> 00:34:15,000
So, again, I'm not meant

622
00:34:15,000 --> 00:34:17,000
to be teaching you lambda calculus. This is taking too long.

623
00:34:17,000 --> 00:34:19,000
I just want to show you

624
00:34:19,000 --> 00:34:21,000
that you can do this kind of stuff

625
00:34:21,000 --> 00:34:23,000
and that this is the basis of functional programming.

626
00:34:23,000 --> 00:34:25,000
These are functional combinators

627
00:34:25,000 --> 00:34:27,000
where all values are functions

628
00:34:27,000 --> 00:34:29,000
and you can actually do computation with just functions.

629
00:34:31,000 --> 00:34:33,000
Pred is complicated

630
00:34:33,000 --> 00:34:35,000
and it actually was kind of a discovery at the time

631
00:34:35,000 --> 00:34:37,000
because they didn't know how to do it.

632
00:34:37,000 --> 00:34:39,000
And it will tell you the number.

633
00:34:39,000 --> 00:34:41,000
Suck of two is one

634
00:34:41,000 --> 00:34:43,000
and pred of...

635
00:34:43,000 --> 00:34:45,000
Sorry, suck of two is three

636
00:34:45,000 --> 00:34:47,000
and pred of two is one.

637
00:34:47,000 --> 00:34:49,000
That's what those are for.

638
00:34:49,000 --> 00:34:51,000
There's a reduction. You can write it out on paper

639
00:34:51,000 --> 00:34:53,000
if you don't believe me. It totally works.

640
00:34:53,000 --> 00:34:55,000
The number after one is definitely two

641
00:34:55,000 --> 00:34:57,000
and the number before one is definitely zero.

642
00:34:57,000 --> 00:34:59,000
They work. I tested these.

643
00:35:01,000 --> 00:35:03,000
Now we can do some complicated arithmetic.

644
00:35:03,000 --> 00:35:05,000
There's ad and at this point

645
00:35:05,000 --> 00:35:07,000
I'm going to start going a little faster

646
00:35:07,000 --> 00:35:09,000
because the actual encodings don't particularly matter.

647
00:35:09,000 --> 00:35:11,000
The fact that we can do them is what matters.

648
00:35:11,000 --> 00:35:13,000
Different ways of doing ad

649
00:35:13,000 --> 00:35:15,000
they both will give you the same result.

650
00:35:15,000 --> 00:35:17,000
Subtract, multiplication,

651
00:35:17,000 --> 00:35:19,000
exponent which is delightfully simple.

652
00:35:19,000 --> 00:35:21,000
Totally makes sense though

653
00:35:21,000 --> 00:35:23,000
that you're applying a function

654
00:35:23,000 --> 00:35:25,000
that gets applied a number of times

655
00:35:25,000 --> 00:35:27,000
to another function that gets applied a number of times.

656
00:35:27,000 --> 00:35:29,000
Now you have an exponent.

657
00:35:29,000 --> 00:35:31,000
Here's a reduction.

658
00:35:31,000 --> 00:35:33,000
If you add one and two together using functions you get three.

659
00:35:33,000 --> 00:35:35,000
You get a functional encoding of three.

660
00:35:35,000 --> 00:35:37,000
Now if you're doing functional programming

661
00:35:37,000 --> 00:35:39,000
you get this garbage.

662
00:35:39,000 --> 00:35:41,000
But this is the underlying substrate

663
00:35:41,000 --> 00:35:43,000
you might say of the functional computation

664
00:35:43,000 --> 00:35:45,000
and it ultimately gives you

665
00:35:45,000 --> 00:35:47,000
the correct answer that you want.

666
00:35:47,000 --> 00:35:49,000
This is just a very simple sort of program.

667
00:35:51,000 --> 00:35:53,000
Subtraction is a little bit more tedious.

668
00:35:53,000 --> 00:35:55,000
I mean tedious for me.

669
00:35:55,000 --> 00:35:57,000
I'm so terrified of being wrong.

670
00:35:57,000 --> 00:35:59,000
I sat down and wrote these out on paper.

671
00:35:59,000 --> 00:36:01,000
I encourage you to do that

672
00:36:01,000 --> 00:36:03,000
just to get an intuition for it.

673
00:36:03,000 --> 00:36:05,000
Multiplication and exponentiation.

674
00:36:05,000 --> 00:36:07,000
Look at that eight.

675
00:36:07,000 --> 00:36:09,000
I think it's crazy.

676
00:36:09,000 --> 00:36:11,000
All the parentheses.

677
00:36:11,000 --> 00:36:13,000
This is really the hot stuff.

678
00:36:13,000 --> 00:36:15,000
Raise your hand if you've heard of Y Combinator.

679
00:36:15,000 --> 00:36:17,000
Like the company, right?

680
00:36:17,000 --> 00:36:19,000
I hope you all end up...

681
00:36:19,000 --> 00:36:21,000
Do I hope that you all...

682
00:36:21,000 --> 00:36:23,000
No.

683
00:36:23,000 --> 00:36:25,000
Raise your hand if you've seen the Y Combinator.

684
00:36:25,000 --> 00:36:27,000
This Y Combinator.

685
00:36:27,000 --> 00:36:29,000
I don't know if you are aware of this

686
00:36:29,000 --> 00:36:31,000
but the company Y Combinator

687
00:36:31,000 --> 00:36:33,000
the name is based on this function.

688
00:36:33,000 --> 00:36:35,000
This is how you perform recursion

689
00:36:35,000 --> 00:36:37,000
in the simply...

690
00:36:37,000 --> 00:36:39,000
Sorry, the untyped lambda calculus.

691
00:36:39,000 --> 00:36:41,000
I referred earlier to fixed point

692
00:36:41,000 --> 00:36:43,000
combinators and this is a fixed point

693
00:36:43,000 --> 00:36:45,000
combinator for functions.

694
00:36:45,000 --> 00:36:47,000
Any function...

695
00:36:47,000 --> 00:36:49,000
For any function that you give fix

696
00:36:49,000 --> 00:36:51,000
it will return that function again

697
00:36:51,000 --> 00:36:53,000
and that is how you perform recursion.

698
00:36:53,000 --> 00:36:55,000
For example, everyone's favorite example,

699
00:36:55,000 --> 00:36:57,000
factorial.

700
00:36:57,000 --> 00:36:59,000
Here's a function that will perform a factorial

701
00:36:59,000 --> 00:37:01,000
but we need to do recursion to perform

702
00:37:01,000 --> 00:37:03,000
a factorial, right?

703
00:37:03,000 --> 00:37:05,000
We'll say factorial is

704
00:37:05,000 --> 00:37:07,000
going to be a function

705
00:37:07,000 --> 00:37:09,000
that is the fixed point of this function F.

706
00:37:09,000 --> 00:37:11,000
We're going to pass F to our

707
00:37:11,000 --> 00:37:13,000
fixed point...

708
00:37:13,000 --> 00:37:15,000
I didn't call it Y because I want to be clear.

709
00:37:15,000 --> 00:37:17,000
The fixed point combinator is a function

710
00:37:17,000 --> 00:37:19,000
that when you give it a function

711
00:37:19,000 --> 00:37:21,000
it will return that function again.

712
00:37:21,000 --> 00:37:23,000
It actually embeds the function into the expression

713
00:37:23,000 --> 00:37:25,000
in a way that you're going to see in a minute.

714
00:37:25,000 --> 00:37:27,000
Honestly, the details aren't important

715
00:37:27,000 --> 00:37:29,000
because you're not here to learn lambda calculus, honestly.

716
00:37:29,000 --> 00:37:31,000
But I want you to get a sense for it,

717
00:37:31,000 --> 00:37:33,000
an intuition, right?

718
00:37:33,000 --> 00:37:35,000
We're going to take the function F

719
00:37:35,000 --> 00:37:37,000
and we're going to pass it to the fixed point combinator

720
00:37:37,000 --> 00:37:39,000
and it looks like that.

721
00:37:39,000 --> 00:37:41,000
That's what we get in the first reduction step

722
00:37:41,000 --> 00:37:43,000
and you can see that F is now embedded into the recursion

723
00:37:43,000 --> 00:37:45,000
and that's how we can perform

724
00:37:45,000 --> 00:37:47,000
a factorial operation.

725
00:37:47,000 --> 00:37:49,000
There it is again

726
00:37:49,000 --> 00:37:51,000
and it looks like that.

727
00:37:51,000 --> 00:37:53,000
It will keep doing that until we're done,

728
00:37:53,000 --> 00:37:55,000
until we reach our base case.

729
00:37:55,000 --> 00:37:57,000
The base case, right?

730
00:37:57,000 --> 00:37:59,000
End part.

731
00:37:59,000 --> 00:38:01,000
Without the base case then it doesn't stop.

732
00:38:01,000 --> 00:38:03,000
It lets a lot of writing.

733
00:38:03,000 --> 00:38:05,000
I'm going to walk you through the recursion now

734
00:38:05,000 --> 00:38:07,000
step by step.

735
00:38:07,000 --> 00:38:09,000
I don't expect you to...

736
00:38:09,000 --> 00:38:11,000
This is mostly for entertainment.

737
00:38:11,000 --> 00:38:13,000
This is what it looks like when you write this out, right?

738
00:38:13,000 --> 00:38:15,000
We're going to calculate now the factorial of 2

739
00:38:15,000 --> 00:38:17,000
step by step

740
00:38:17,000 --> 00:38:19,000
and we're doing beta reduction right now.

741
00:38:19,000 --> 00:38:21,000
It's just text substitution.

742
00:38:21,000 --> 00:38:23,000
We're putting values into functions.

743
00:38:23,000 --> 00:38:25,000
I'm actually cheating a little bit

744
00:38:25,000 --> 00:38:27,000
because I'm not expanding all the lambda expressions

745
00:38:27,000 --> 00:38:29,000
because I know that...

746
00:38:29,000 --> 00:38:31,000
I know that

747
00:38:31,000 --> 00:38:33,000
whether or not a number is zero

748
00:38:33,000 --> 00:38:35,000
so I'm just doing this in my own head

749
00:38:35,000 --> 00:38:37,000
but this is an accurate representation

750
00:38:37,000 --> 00:38:39,000
of the reduction, right?

751
00:38:39,000 --> 00:38:41,000
At each step.

752
00:38:41,000 --> 00:38:43,000
It's almost legible, right?

753
00:38:43,000 --> 00:38:45,000
Even if you don't know lambda calculus

754
00:38:45,000 --> 00:38:47,000
you know a little bit of programming maybe.

755
00:38:47,000 --> 00:38:49,000
You can see how this would work

756
00:38:49,000 --> 00:38:51,000
to calculate a factorial

757
00:38:51,000 --> 00:38:53,000
and I end up with that

758
00:38:53,000 --> 00:38:55,000
and this one is two.

759
00:38:55,000 --> 00:38:57,000
I can do anything now, right?

760
00:38:59,000 --> 00:39:01,000
I have numbers, I have recursion,

761
00:39:01,000 --> 00:39:03,000
I have branching.

762
00:39:03,000 --> 00:39:05,000
I can calculate anything.

763
00:39:05,000 --> 00:39:07,000
You wouldn't want to calculate anything in lambda calculus

764
00:39:07,000 --> 00:39:09,000
like this but you could, in principle

765
00:39:09,000 --> 00:39:11,000
you could.

766
00:39:11,000 --> 00:39:13,000
I think that's the point.

767
00:39:13,000 --> 00:39:15,000
The first step of what's happening

768
00:39:15,000 --> 00:39:17,000
is getting substitutions and building

769
00:39:17,000 --> 00:39:19,000
that first step is getting substitutions

770
00:39:19,000 --> 00:39:21,000
and building this whole thing out

771
00:39:21,000 --> 00:39:23,000
and then the next step is evaluation

772
00:39:23,000 --> 00:39:25,000
and trying to figure it all down.

773
00:39:25,000 --> 00:39:27,000
Well, I mean

774
00:39:27,000 --> 00:39:29,000
not exactly.

775
00:39:29,000 --> 00:39:31,000
Okay, maybe the point

776
00:39:31,000 --> 00:39:33,000
is abstraction, right?

777
00:39:33,000 --> 00:39:35,000
Because I don't want to write lambda expressions

778
00:39:35,000 --> 00:39:37,000
but I want to be able to trust

779
00:39:37,000 --> 00:39:39,000
that this stuff is going to work

780
00:39:39,000 --> 00:39:41,000
without worrying about the notation.

781
00:39:41,000 --> 00:39:43,000
When you get to a real programming language

782
00:39:43,000 --> 00:39:45,000
then obviously you're not worrying about this.

783
00:39:45,000 --> 00:39:47,000
This is sort of how functional programming

784
00:39:47,000 --> 00:39:49,000
works at some very primitive level.

785
00:39:49,000 --> 00:39:51,000
You might think of it that way.

786
00:39:51,000 --> 00:39:53,000
When you write programs you're not writing stuff like this

787
00:39:53,000 --> 00:39:55,000
but if you're working with pure functions

788
00:39:55,000 --> 00:39:57,000
you don't worry about state

789
00:39:57,000 --> 00:39:59,000
then you know that

790
00:39:59,000 --> 00:40:01,000
when I write fact I'm really writing

791
00:40:01,000 --> 00:40:03,000
fact after what I'm writing all that lambda stuff

792
00:40:03,000 --> 00:40:05,000
and it will work the same every single time.

793
00:40:05,000 --> 00:40:07,000
I would rather work with

794
00:40:07,000 --> 00:40:09,000
named functions because they're easier for me

795
00:40:09,000 --> 00:40:11,000
and named values than with long

796
00:40:11,000 --> 00:40:13,000
lambda expressions.

797
00:40:21,000 --> 00:40:23,000
Yes?

798
00:40:23,000 --> 00:40:25,000
I wasn't going to say it yet

799
00:40:25,000 --> 00:40:27,000
but look, you get currying for free. It's right there.

800
00:40:27,000 --> 00:40:29,000
Because you're applying each argument one at a time.

801
00:40:31,000 --> 00:40:33,000
If you're familiar with currying that's what it is.

802
00:40:33,000 --> 00:40:35,000
Instead of applying all your arguments at once

803
00:40:35,000 --> 00:40:37,000
you can do them one at a time

804
00:40:37,000 --> 00:40:39,000
and you take a function, you apply an argument

805
00:40:39,000 --> 00:40:41,000
now you have a new function with that argument applied

806
00:40:41,000 --> 00:40:43,000
and then you do the next one and the next one.

807
00:40:43,000 --> 00:40:45,000
It's a freebie.

808
00:40:45,000 --> 00:40:47,000
Like referential transparency.

809
00:40:47,000 --> 00:40:49,000
That just means that

810
00:40:49,000 --> 00:40:51,000
when I was showing you earlier that these expressions

811
00:40:51,000 --> 00:40:53,000
triple equal sign or this name

812
00:40:53,000 --> 00:40:55,000
triple equal sign this expression

813
00:40:55,000 --> 00:40:57,000
that those are completely identical

814
00:40:57,000 --> 00:40:59,000
and you can do equational reasoning with these things

815
00:40:59,000 --> 00:41:01,000
and trust that it's always going to work

816
00:41:01,000 --> 00:41:03,000
because there's no such thing as global state

817
00:41:03,000 --> 00:41:05,000
there's no memory. This is not a Turing machine.

818
00:41:05,000 --> 00:41:07,000
It's just symbolic manipulation.

819
00:41:07,000 --> 00:41:09,000
Okay, so I told you I cheated a little bit

820
00:41:09,000 --> 00:41:11,000
with this example.

821
00:41:11,000 --> 00:41:13,000
Here's what the real thing looks like if you're working with just lambdas.

822
00:41:13,000 --> 00:41:15,000
Can you even read this?

823
00:41:15,000 --> 00:41:17,000
I blew it up, you can't read it anyway.

824
00:41:17,000 --> 00:41:19,000
So this is the whole thing and if you sat down

825
00:41:19,000 --> 00:41:21,000
and you worked this out with a pen

826
00:41:21,000 --> 00:41:23,000
and a piece of paper like I did

827
00:41:23,000 --> 00:41:25,000
so that in the event that someone was in the audience

828
00:41:25,000 --> 00:41:27,000
and did this and found that I was wrong I wouldn't be embarrassed.

829
00:41:27,000 --> 00:41:29,000
It works.

830
00:41:29,000 --> 00:41:31,000
These are the reduction steps

831
00:41:31,000 --> 00:41:33,000
for just as just factorial of 2

832
00:41:33,000 --> 00:41:35,000
if you did factorial of a higher number

833
00:41:35,000 --> 00:41:37,000
you get to the point where it will take you

834
00:41:37,000 --> 00:41:39,000
until the heat death of the universe to compute probably

835
00:41:39,000 --> 00:41:41,000
but you can see how the reduction steps

836
00:41:41,000 --> 00:41:43,000
ultimately get you to the same answer.

837
00:41:43,000 --> 00:41:45,000
There it is.

838
00:41:45,000 --> 00:41:47,000
lambdaf.lambdax.f.f of x

839
00:41:49,000 --> 00:41:51,000
is 2.

840
00:41:51,000 --> 00:41:53,000
So now you know the factorial of 2 is 2.

841
00:41:53,000 --> 00:41:55,000
That is the entirety

842
00:41:55,000 --> 00:41:57,000
of the syntax of lambda calculus I want to talk about.

843
00:41:57,000 --> 00:41:59,000
Are there any questions?

844
00:41:59,000 --> 00:42:01,000
No.

845
00:42:01,000 --> 00:42:03,000
That's more than I want it to do in fact.

846
00:42:03,000 --> 00:42:05,000
You mentioned a lot of paper and pen.

847
00:42:05,000 --> 00:42:07,000
When you're learning lambda calculus

848
00:42:07,000 --> 00:42:09,000
do you recommend paper and pen?

849
00:42:09,000 --> 00:42:11,000
No, paper and pen.

850
00:42:11,000 --> 00:42:13,000
It's easier.

851
00:42:13,000 --> 00:42:15,000
Why don't you check yourself

852
00:42:15,000 --> 00:42:17,000
because there's no compromise with what you're trying to do?

853
00:42:17,000 --> 00:42:19,000
It's a good question.

854
00:42:19,000 --> 00:42:21,000
How do you check yourself?

855
00:42:21,000 --> 00:42:23,000
I just did.

856
00:42:23,000 --> 00:42:25,000
This is a proof, right?

857
00:42:25,000 --> 00:42:27,000
It works.

858
00:42:27,000 --> 00:42:29,000
You can do it and make sure I did it right.

859
00:42:29,000 --> 00:42:31,000
In lambda calculus

860
00:42:31,000 --> 00:42:33,000
you know what 3 plus 0 is in real life.

861
00:42:33,000 --> 00:42:35,000
So you don't take 3 plus 0

862
00:42:39,000 --> 00:42:41,000
in lambda calculus and you know you did it wrong.

863
00:42:41,000 --> 00:42:43,000
Right.

864
00:42:43,000 --> 00:42:45,000
I'm establishing a principle essentially, yeah.

865
00:42:45,000 --> 00:42:47,000
So basically in the yw ychwanegwch,

866
00:42:47,000 --> 00:42:49,000
ychwanegwch, ychwanegwch, ychwanegwch,

867
00:42:49,000 --> 00:42:51,000
ychwanegwch, ychwanegwch, ychwanegwch,

868
00:42:51,000 --> 00:42:53,000
ychwanegwch, ychwanegwch, ychwanegwch.

869
00:42:53,000 --> 00:42:55,000
If you have a base case

870
00:42:55,000 --> 00:42:57,000
if you don't,

871
00:42:57,000 --> 00:42:59,000
then it diverges forever.

872
00:42:59,000 --> 00:43:01,000
It never converges on an answer.

873
00:43:01,000 --> 00:43:03,000
Similar to what?

874
00:43:03,000 --> 00:43:05,000
Similar to what?

875
00:43:05,000 --> 00:43:07,000
Like a for loop.

876
00:43:07,000 --> 00:43:09,000
I mean, yeah.

877
00:43:09,000 --> 00:43:11,000
I mean, yeah.

878
00:43:11,000 --> 00:43:13,000
I mean, I don't love comparisons

879
00:43:13,000 --> 00:43:15,000
to imperative programming constructs.

880
00:43:15,000 --> 00:43:17,000
This is what it is.

881
00:43:17,000 --> 00:43:19,000
This predates for loops.

882
00:43:19,000 --> 00:43:21,000
I thank.

883
00:43:21,000 --> 00:43:23,000
Pretty sure.

884
00:43:23,000 --> 00:43:25,000
Lambda calculus.

885
00:43:25,000 --> 00:43:27,000
Now we're going to do JavaScript.

886
00:43:27,000 --> 00:43:29,000
Thank God, right?

887
00:43:29,000 --> 00:43:31,000
Something everybody is familiar with.

888
00:43:31,000 --> 00:43:33,000
So I hope that everybody...

889
00:43:35,000 --> 00:43:37,000
Can everyone see that? Is that big enough?

890
00:43:37,000 --> 00:43:39,000
No, not.

891
00:43:39,000 --> 00:43:41,000
Okay, maybe.

892
00:43:41,000 --> 00:43:43,000
Oops.

893
00:43:43,000 --> 00:43:45,000
Oh, great.

894
00:43:49,000 --> 00:43:51,000
How about that?

895
00:43:52,000 --> 00:43:54,000
Or that. Is that good?

896
00:44:00,000 --> 00:44:02,000
Yeah, my normal background is even lower contrast.

897
00:44:02,000 --> 00:44:04,000
I thought maybe this would be easier.

898
00:44:04,000 --> 00:44:06,000
No, not so much.

899
00:44:08,000 --> 00:44:10,000
I can do dark...

900
00:44:10,000 --> 00:44:14,000
This is slightly different, but almost exactly identical.

901
00:44:14,000 --> 00:44:16,000
Let me see.

902
00:44:16,000 --> 00:44:18,000
Why am I using BBEdit?

903
00:44:18,000 --> 00:44:20,000
Um...

904
00:44:20,000 --> 00:44:22,000
Do you like this better?

905
00:44:22,000 --> 00:44:24,000
Yeah, okay.

906
00:44:30,000 --> 00:44:32,000
Hi.

907
00:44:32,000 --> 00:44:34,000
Bigger?

908
00:44:34,000 --> 00:44:36,000
Whatever, I don't care.

909
00:44:36,000 --> 00:44:39,000
So at this point, I hope you can all open up the file

910
00:44:39,000 --> 00:44:42,000
and open up your...

911
00:44:42,000 --> 00:44:44,000
Java...

912
00:44:44,000 --> 00:44:46,000
I'm doing this in Chrome, and I tested it in Safari

913
00:44:46,000 --> 00:44:48,000
and Firefox.

914
00:44:48,000 --> 00:44:50,000
I don't know off the top of my head how you open a JavaScript console

915
00:44:50,000 --> 00:44:53,000
in Safari or Firefox.

916
00:44:53,000 --> 00:44:55,000
Command-option-j

917
00:44:55,000 --> 00:44:57,000
in Chrome if you have

918
00:44:57,000 --> 00:45:00,000
the lambda.html page open.

919
00:45:03,000 --> 00:45:05,000
Sorry, question?

920
00:45:05,000 --> 00:45:07,000
Question?

921
00:45:07,000 --> 00:45:09,000
Okay, so now we're going to move more into

922
00:45:09,000 --> 00:45:12,000
more of a workshop format, because that was a little bit more explanation

923
00:45:12,000 --> 00:45:14,000
than I had wanted to do.

924
00:45:14,000 --> 00:45:16,000
You have all of the functions that I've shown you

925
00:45:16,000 --> 00:45:18,000
and a lot of other stuff,

926
00:45:18,000 --> 00:45:20,000
and what I want you to be able to do with now

927
00:45:20,000 --> 00:45:22,000
is really play with them in your browsers.

928
00:45:22,000 --> 00:45:24,000
The point is, I don't want to lecture at you.

929
00:45:24,000 --> 00:45:26,000
Here's what functional programming is all about.

930
00:45:26,000 --> 00:45:28,000
I actually want you to use these functions

931
00:45:28,000 --> 00:45:30,000
and build computations with them so you learn

932
00:45:30,000 --> 00:45:32,000
not only what functional programming is,

933
00:45:32,000 --> 00:45:34,000
you develop this intuition that will allow you to explain it

934
00:45:34,000 --> 00:45:36,000
to others.

935
00:45:36,000 --> 00:45:38,000
What does it mean when we say functions are values?

936
00:45:38,000 --> 00:45:41,000
That is the whole point of what I did this for.

937
00:45:41,000 --> 00:45:43,000
So type stuff in.

938
00:45:43,000 --> 00:45:45,000
As I go through these things.

939
00:45:45,000 --> 00:45:47,000
I'm just going to go through

940
00:45:47,000 --> 00:45:49,000
the code, essentially.

941
00:45:49,000 --> 00:45:51,000
I just want you to play with it in your browsers

942
00:45:51,000 --> 00:45:53,000
and see what you can come up with.

943
00:45:53,000 --> 00:45:55,000
There are a couple of little exercises that you can do if you want.

944
00:45:55,000 --> 00:45:57,000
I actually have never given

945
00:45:57,000 --> 00:45:59,000
these kinds of exercises for a group before,

946
00:45:59,000 --> 00:46:01,000
so I don't know how that will go over.

947
00:46:01,000 --> 00:46:03,000
We'll just find out.

948
00:46:03,000 --> 00:46:05,000
Now we're in JavaScript,

949
00:46:05,000 --> 00:46:07,000
maybe you'll see the magic for real.

950
00:46:07,000 --> 00:46:09,000
We're only going to use the anonymous arrow function

951
00:46:09,000 --> 00:46:11,000
to do everything.

952
00:46:11,000 --> 00:46:13,000
The same with operations.

953
00:46:13,000 --> 00:46:15,000
This is what I showed you.

954
00:46:15,000 --> 00:46:17,000
Alpha, beta, and eta conversion.

955
00:46:17,000 --> 00:46:19,000
If you type these in.

956
00:46:19,000 --> 00:46:21,000
These are like a little toy proofs.

957
00:46:21,000 --> 00:46:23,000
You know, they work.

958
00:46:23,000 --> 00:46:25,000
They're true.

959
00:46:25,000 --> 00:46:27,000
Oh, I should note also

960
00:46:27,000 --> 00:46:29,000
this file has a bunch of helper functions

961
00:46:29,000 --> 00:46:31,000
because we need to translate between

962
00:46:31,000 --> 00:46:33,000
JavaScript and lambdas.

963
00:46:33,000 --> 00:46:35,000
Otherwise we can't read anything.

964
00:46:35,000 --> 00:46:37,000
For example, I can type in one,

965
00:46:37,000 --> 00:46:39,000
but it looks like that.

966
00:46:39,000 --> 00:46:41,000
What you know is like a lamb to f lamb to x,

967
00:46:41,000 --> 00:46:43,000
f of x. We know that that's one,

968
00:46:43,000 --> 00:46:45,000
but...

969
00:46:45,000 --> 00:46:47,000
Good point.

970
00:46:47,000 --> 00:46:49,000
How about that?

971
00:46:49,000 --> 00:46:51,000
Okay.

972
00:46:51,000 --> 00:46:53,000
So here's our identity combinator,

973
00:46:53,000 --> 00:46:55,000
id equals x,

974
00:46:55,000 --> 00:46:57,000
returning x.

975
00:46:57,000 --> 00:46:59,000
Assuming everybody is either familiar

976
00:46:59,000 --> 00:47:01,000
with the JavaScript arrow syntax,

977
00:47:01,000 --> 00:47:03,000
or this is trivial enough

978
00:47:03,000 --> 00:47:05,000
that you can pick it up.

979
00:47:05,000 --> 00:47:07,000
Here's our true and false.

980
00:47:07,000 --> 00:47:09,000
It takes two values, x and y,

981
00:47:09,000 --> 00:47:11,000
and returns x is true, and the opposite is false.

982
00:47:11,000 --> 00:47:13,000
Again, you can

983
00:47:13,000 --> 00:47:15,000
cut and paste these things

984
00:47:15,000 --> 00:47:17,000
to test them.

985
00:47:17,000 --> 00:47:19,000
I have a two-bool function

986
00:47:19,000 --> 00:47:21,000
that you can...

987
00:47:21,000 --> 00:47:23,000
and true, false.

988
00:47:23,000 --> 00:47:25,000
Returns false.

989
00:47:25,000 --> 00:47:27,000
They work, thankfully.

990
00:47:27,000 --> 00:47:29,000
At some point you will probably be able

991
00:47:29,000 --> 00:47:31,000
to break this because

992
00:47:31,000 --> 00:47:33,000
JavaScript isn't designed for

993
00:47:33,000 --> 00:47:35,000
deeply nested function calls.

994
00:47:35,000 --> 00:47:37,000
Try calculating the factorial of, like, 10.

995
00:47:39,000 --> 00:47:41,000
So here we have and, we have or, we have not,

996
00:47:41,000 --> 00:47:43,000
and play with this stuff.

997
00:47:43,000 --> 00:47:45,000
See what you can do.

998
00:47:45,000 --> 00:47:47,000
That's kind of all I want you to do right now.

999
00:47:47,000 --> 00:47:49,000
And true and true returns true, right?

1000
00:47:49,000 --> 00:47:51,000
And false, false returns false.

1001
00:47:51,000 --> 00:47:53,000
Well, actually, this probably won't work

1002
00:47:53,000 --> 00:47:55,000
because these are just functions.

1003
00:47:55,000 --> 00:47:57,000
Oh, look, it works. How about that?

1004
00:47:57,000 --> 00:47:59,000
If I type in plus,

1005
00:47:59,000 --> 00:48:01,000
any plus expression,

1006
00:48:01,000 --> 00:48:03,000
it looks the same,

1007
00:48:03,000 --> 00:48:05,000
but then the true and true

1008
00:48:05,000 --> 00:48:07,000
works instead of right now.

1009
00:48:07,000 --> 00:48:09,000
What do you mean?

1010
00:48:09,000 --> 00:48:11,000
If I type in 1 plus 1, 5.

1011
00:48:11,000 --> 00:48:13,000
Oh, you did like that?

1012
00:48:13,000 --> 00:48:15,000
No, no, with the constant for the named functions.

1013
00:48:15,000 --> 00:48:17,000
You did this?

1014
00:48:17,000 --> 00:48:19,000
1, 5?

1015
00:48:19,000 --> 00:48:21,000
Correct. I'll change the second over to 3.

1016
00:48:21,000 --> 00:48:23,000
It's going to look the same.

1017
00:48:23,000 --> 00:48:25,000
Oh, that's...

1018
00:48:25,000 --> 00:48:27,000
But your true and true function does work in this way?

1019
00:48:27,000 --> 00:48:29,000
Yeah.

1020
00:48:29,000 --> 00:48:31,000
I don't know why it does that.

1021
00:48:31,000 --> 00:48:33,000
It's just the way the Chrome console works.

1022
00:48:33,000 --> 00:48:35,000
It's just a situation.

1023
00:48:39,000 --> 00:48:41,000
Chrome's like, what are you doing?

1024
00:48:41,000 --> 00:48:43,000
No, it wasn't.

1025
00:48:43,000 --> 00:48:45,000
Yeah, so we have to...

1026
00:48:45,000 --> 00:48:47,000
You can look at the utility functions.

1027
00:48:47,000 --> 00:48:49,000
They're at the bottom of the file.

1028
00:48:49,000 --> 00:48:51,000
Just for convenience, I'm converting back and forth

1029
00:48:51,000 --> 00:48:53,000
between these lambda expressions and primitive values.

1030
00:48:53,000 --> 00:48:55,000
Okay, so a little exercise.

1031
00:48:55,000 --> 00:48:57,000
Try to implement XOR, right?

1032
00:48:57,000 --> 00:48:59,000
I've given you and or not.

1033
00:48:59,000 --> 00:49:01,000
See if you can come up with XOR

1034
00:49:01,000 --> 00:49:03,000
and what that would look like.

1035
00:49:07,000 --> 00:49:09,000
When someone comes up with it,

1036
00:49:09,000 --> 00:49:11,000
raise your hand.

1037
00:49:11,000 --> 00:49:13,000
We don't need to take all day.

1038
00:49:24,000 --> 00:49:26,000
Anyone have a good XOR implementation?

1039
00:49:34,000 --> 00:49:36,000
Brad, this is exclusive or...

1040
00:49:42,000 --> 00:49:44,000
No, I'm not trying to trick you.

1041
00:49:44,000 --> 00:49:46,000
I mean, I haven't written it for me yet,

1042
00:49:46,000 --> 00:49:48,000
but it's basically A and not B

1043
00:49:48,000 --> 00:49:50,000
or not A and B.

1044
00:49:52,000 --> 00:49:54,000
I think that's what I got.

1045
00:49:54,000 --> 00:49:56,000
Right?

1046
00:49:58,000 --> 00:50:00,000
You can test it.

1047
00:50:00,000 --> 00:50:02,000
I don't know if I've actually typed this in XOR.

1048
00:50:02,000 --> 00:50:04,000
Yeah, so...

1049
00:50:04,000 --> 00:50:06,000
I haven't actually typed it in yet, so...

1050
00:50:06,000 --> 00:50:08,000
Yeah, I encourage you to test these things, too.

1051
00:50:08,000 --> 00:50:10,000
Prove it to yourself, right?

1052
00:50:10,000 --> 00:50:12,000
Don't believe me.

1053
00:50:12,000 --> 00:50:14,000
Or find mistakes.

1054
00:50:14,000 --> 00:50:16,000
There are a couple of little weird bugs.

1055
00:50:16,000 --> 00:50:18,000
Well, there's one that I can think of

1056
00:50:18,000 --> 00:50:20,000
that you probably won't encounter.

1057
00:50:20,000 --> 00:50:22,000
By and large, this works about 99%,

1058
00:50:22,000 --> 00:50:24,000
which is pretty good for JavaScript, right?

1059
00:50:28,000 --> 00:50:30,000
Here's branching.

1060
00:50:30,000 --> 00:50:32,000
Remember before I said that,

1061
00:50:32,000 --> 00:50:34,000
in principle,

1062
00:50:34,000 --> 00:50:36,000
the if-then-else statement you can write

1063
00:50:36,000 --> 00:50:38,000
is this function

1064
00:50:38,000 --> 00:50:40,000
that takes a predicate, right?

1065
00:50:40,000 --> 00:50:42,000
A function that returns true or false.

1066
00:50:42,000 --> 00:50:44,000
And then two values, X or Y.

1067
00:50:44,000 --> 00:50:46,000
And if P is true, it returns X.

1068
00:50:46,000 --> 00:50:48,000
If it's false, it returns Y.

1069
00:50:48,000 --> 00:50:50,000
And as we did with Lambda Calculus,

1070
00:50:50,000 --> 00:50:52,000
you can do this in JavaScript.

1071
00:50:52,000 --> 00:50:54,000
You can factor out the X, factor out the Y,

1072
00:50:54,000 --> 00:50:56,000
factor out the P, and it's just the same function as ID.

1073
00:50:58,000 --> 00:51:00,000
Now you can write...

1074
00:51:00,000 --> 00:51:02,000
I don't know.

1075
00:51:04,000 --> 00:51:06,000
If-then-else.

1076
00:51:06,000 --> 00:51:08,000
So if this is true,

1077
00:51:08,000 --> 00:51:10,000
return true, if not return...

1078
00:51:10,000 --> 00:51:12,000
Maybe that'll work. That works.

1079
00:51:14,000 --> 00:51:16,000
Here are the natural numbers.

1080
00:51:16,000 --> 00:51:18,000
Here are some enumeration functions.

1081
00:51:18,000 --> 00:51:20,000
I can explain a little bit

1082
00:51:20,000 --> 00:51:22,000
how predecessor works.

1083
00:51:22,000 --> 00:51:24,000
It essentially will take

1084
00:51:24,000 --> 00:51:26,000
a pair of values,

1085
00:51:26,000 --> 00:51:28,000
a pair of zeros,

1086
00:51:28,000 --> 00:51:30,000
and it will increment one of them

1087
00:51:30,000 --> 00:51:32,000
up to the point.

1088
00:51:32,000 --> 00:51:34,000
A predecessor of five.

1089
00:51:34,000 --> 00:51:36,000
It'll increment one of those values to five.

1090
00:51:36,000 --> 00:51:38,000
And it will increment the other one.

1091
00:51:38,000 --> 00:51:40,000
It will skip one of the incrementations.

1092
00:51:40,000 --> 00:51:42,000
Increments.

1093
00:51:42,000 --> 00:51:44,000
It will skip one of the increments.

1094
00:51:44,000 --> 00:51:46,000
Then you get five and four,

1095
00:51:46,000 --> 00:51:48,000
and then it selects for the four.

1096
00:51:50,000 --> 00:51:52,000
That's something I could probably

1097
00:51:52,000 --> 00:51:54,000
demonstrate at great length,

1098
00:51:54,000 --> 00:51:56,000
but it would take too long, and so I won't.

1099
00:51:56,000 --> 00:51:58,000
But I do have a reduction to show you on that.

1100
00:51:58,000 --> 00:52:00,000
And because

1101
00:52:00,000 --> 00:52:02,000
this talk is

1102
00:52:02,000 --> 00:52:04,000
for people who don't want to learn Lambda Calculus,

1103
00:52:04,000 --> 00:52:06,000
I don't care if you learn Lambda Calculus.

1104
00:52:06,000 --> 00:52:08,000
I just want you to get comfortable working with functions

1105
00:52:08,000 --> 00:52:10,000
so that you can understand their expressive power

1106
00:52:10,000 --> 00:52:12,000
and why we do functional programming.

1107
00:52:14,000 --> 00:52:16,000
We're building actually an entire programming language

1108
00:52:16,000 --> 00:52:18,000
within your JavaScript console right now.

1109
00:52:18,000 --> 00:52:20,000
I don't know if that's apparent.

1110
00:52:20,000 --> 00:52:22,000
You can start putting more complicated things together

1111
00:52:22,000 --> 00:52:24,000
with these primitives,

1112
00:52:24,000 --> 00:52:26,000
and ultimately, in principle, you can do anything.

1113
00:52:26,000 --> 00:52:28,000
I'm not saying that you should write programs

1114
00:52:28,000 --> 00:52:30,000
out of these Lambdas.

1115
00:52:30,000 --> 00:52:32,000
I'm really nervous right now because

1116
00:52:32,000 --> 00:52:34,000
John said earlier at the end of the keynote

1117
00:52:34,000 --> 00:52:36,000
that these workshops are meant to be teaching skills.

1118
00:52:38,000 --> 00:52:40,000
Much from doing that, yeah.

1119
00:52:40,000 --> 00:52:42,000
No, yeah.

1120
00:52:52,000 --> 00:52:54,000
Yeah.

1121
00:52:54,000 --> 00:52:56,000
Yeah.

1122
00:52:58,000 --> 00:53:00,000
I'm not clear on how that evaluates us through.

1123
00:53:00,000 --> 00:53:02,000
Does that make sense?

1124
00:53:02,000 --> 00:53:04,000
Yeah, I'll try.

1125
00:53:04,000 --> 00:53:06,000
Let's see.

1126
00:53:08,000 --> 00:53:10,000
Let's say, we'll say A equals,

1127
00:53:10,000 --> 00:53:12,000
so let's say,

1128
00:53:12,000 --> 00:53:14,000
hmm.

1129
00:53:14,000 --> 00:53:16,000
I can apply

1130
00:53:16,000 --> 00:53:18,000
true to the and function.

1131
00:53:18,000 --> 00:53:20,000
And I'll just get another function back.

1132
00:53:22,000 --> 00:53:24,000
Yeah.

1133
00:53:24,000 --> 00:53:26,000
It's in there. I closed over it.

1134
00:53:26,000 --> 00:53:28,000
I would think that the X would be true now.

1135
00:53:30,000 --> 00:53:32,000
It is.

1136
00:53:32,000 --> 00:53:34,000
But I haven't evaluated the function.

1137
00:53:34,000 --> 00:53:36,000
I haven't reduced.

1138
00:53:36,000 --> 00:53:38,000
If I two-bould my little A function,

1139
00:53:38,000 --> 00:53:40,000
it gives me, you know,

1140
00:53:40,000 --> 00:53:42,000
it doesn't know what I'm trying to do.

1141
00:53:42,000 --> 00:53:44,000
No meaning.

1142
00:53:44,000 --> 00:53:46,000
So I've actually partially applied the true to my and.

1143
00:53:46,000 --> 00:53:48,000
So now I can apply the false.

1144
00:53:48,000 --> 00:53:50,000
Let's say B is A

1145
00:53:50,000 --> 00:53:52,000
applied to false.

1146
00:53:52,000 --> 00:53:54,000
Now B is fully applied.

1147
00:53:57,000 --> 00:53:59,000
Now I can two-bool on the B.

1148
00:54:04,000 --> 00:54:06,000
Is that meaningful

1149
00:54:06,000 --> 00:54:08,000
as far as reduction steps are concerned?

1150
00:54:12,000 --> 00:54:14,000
Let's see.

1151
00:54:14,000 --> 00:54:16,000
OK. No problem.

1152
00:54:16,000 --> 00:54:18,000
You're making me think on my feet.

1153
00:54:18,000 --> 00:54:20,000
It's good.

1154
00:54:20,000 --> 00:54:22,000
I can just type it in.

1155
00:54:22,000 --> 00:54:24,000
Right?

1156
00:54:24,000 --> 00:54:26,000
So this is

1157
00:54:26,000 --> 00:54:28,000
a function after all.

1158
00:54:28,000 --> 00:54:30,000
That's not special.

1159
00:54:32,000 --> 00:54:34,000
So this is

1160
00:54:36,000 --> 00:54:38,000
this is and, right?

1161
00:54:38,000 --> 00:54:40,000
So I want to apply.

1162
00:54:40,000 --> 00:54:42,000
In fact, I'll even replace the false with

1163
00:54:44,000 --> 00:54:46,000
I don't know.

1164
00:54:46,000 --> 00:54:48,000
I've not done this before.

1165
00:54:48,000 --> 00:54:50,000
So why not do it the hard way?

1166
00:54:50,000 --> 00:54:52,000
That's my motto in life.

1167
00:54:52,000 --> 00:54:54,000
OK.

1168
00:54:54,000 --> 00:54:56,000
So I'm actually going to get rid of the two-bool

1169
00:54:56,000 --> 00:54:58,000
because it's going to confuse me for a moment.

1170
00:55:00,000 --> 00:55:02,000
I think that that looks right.

1171
00:55:02,000 --> 00:55:04,000
I think that's the and function.

1172
00:55:04,000 --> 00:55:06,000
Right?

1173
00:55:06,000 --> 00:55:08,000
So now I can apply

1174
00:55:08,000 --> 00:55:10,000
like a true to it, for example.

1175
00:55:10,000 --> 00:55:12,000
But instead of applying the true,

1176
00:55:12,000 --> 00:55:14,000
let's just kill off

1177
00:55:14,000 --> 00:55:16,000
the X

1178
00:55:16,000 --> 00:55:18,000
and put it in there.

1179
00:55:22,000 --> 00:55:24,000
Let me start over

1180
00:55:24,000 --> 00:55:26,000
because I'm going to confuse myself.

1181
00:55:26,000 --> 00:55:28,000
I'm glad we're doing this because

1182
00:55:28,000 --> 00:55:30,000
this is the point.

1183
00:55:30,000 --> 00:55:32,000
I don't care.

1184
00:55:32,000 --> 00:55:34,000
It's helpful for me.

1185
00:55:34,000 --> 00:55:36,000
This talks about me.

1186
00:55:36,000 --> 00:55:38,000
It's not about you.

1187
00:55:38,000 --> 00:55:40,000
I actually might leave the

1188
00:55:40,000 --> 00:55:42,000
false in as it is because you get the idea

1189
00:55:42,000 --> 00:55:44,000
and I don't want to waste time being confused.

1190
00:55:44,000 --> 00:55:46,000
OK. So there's the true. We're going to apply this to true.

1191
00:55:46,000 --> 00:55:48,000
But instead of doing that, we'll kill off

1192
00:55:48,000 --> 00:55:50,000
that X and we'll just stick it there.

1193
00:55:50,000 --> 00:55:52,000
I need some other boolean value, right?

1194
00:55:52,000 --> 00:55:54,000
Because we need two branches.

1195
00:55:54,000 --> 00:55:56,000
So let's say the other branch

1196
00:55:56,000 --> 00:55:58,000
is false.

1197
00:55:58,000 --> 00:56:00,000
Right. So now I kill off

1198
00:56:00,000 --> 00:56:02,000
the Y

1199
00:56:02,000 --> 00:56:04,000
and now I have false.

1200
00:56:04,000 --> 00:56:06,000
OK.

1201
00:56:06,000 --> 00:56:08,000
But remember true is also just a function.

1202
00:56:08,000 --> 00:56:10,000
It's a function X, Y

1203
00:56:10,000 --> 00:56:12,000
that returns X.

1204
00:56:12,000 --> 00:56:14,000
Right? So then we have

1205
00:56:14,000 --> 00:56:16,000
this false.

1206
00:56:16,000 --> 00:56:18,000
We take that

1207
00:56:18,000 --> 00:56:20,000
and pull off this X

1208
00:56:20,000 --> 00:56:22,000
and then it's there.

1209
00:56:22,000 --> 00:56:24,000
OK.

1210
00:56:24,000 --> 00:56:26,000
Then we have another false

1211
00:56:26,000 --> 00:56:28,000
and we apply that to Y

1212
00:56:28,000 --> 00:56:30,000
and then we're left with false.

1213
00:56:30,000 --> 00:56:32,000
Does that last a little bit there?

1214
00:56:32,000 --> 00:56:34,000
We say you're applying the Y

1215
00:56:34,000 --> 00:56:36,000
and when you have the false, it was done

1216
00:56:36,000 --> 00:56:38,000
just two falses.

1217
00:56:38,000 --> 00:56:40,000
Is that why?

1218
00:56:40,000 --> 00:56:42,000
You know, it's tricky

1219
00:56:42,000 --> 00:56:44,000
because I'm just branching using booleans.

1220
00:56:44,000 --> 00:56:46,000
I'm not branching using real expressions.

1221
00:56:46,000 --> 00:56:48,000
Maybe if I say

1222
00:56:48,000 --> 00:56:50,000
you know, is 0, 1

1223
00:56:50,000 --> 00:56:52,000
true otherwise false

1224
00:56:52,000 --> 00:56:54,000
something like that.

1225
00:56:54,000 --> 00:56:56,000
It was helpful that you reminded me

1226
00:56:56,000 --> 00:56:58,000
that it was a function.

1227
00:56:58,000 --> 00:57:00,000
Yeah, yeah.

1228
00:57:00,000 --> 00:57:02,000
Remember, everything is a function.

1229
00:57:02,000 --> 00:57:04,000
You don't really know what it means.

1230
00:57:04,000 --> 00:57:06,000
Everything is a function.

1231
00:57:06,000 --> 00:57:08,000
Functional programming is programming with functions.

1232
00:57:08,000 --> 00:57:10,000
No, it's not intuitive at all.

1233
00:57:10,000 --> 00:57:12,000
I don't think it's intuitive.

1234
00:57:12,000 --> 00:57:14,000
But once it becomes intuitive,

1235
00:57:14,000 --> 00:57:16,000
one is a function.

1236
00:57:16,000 --> 00:57:18,000
Right, no.

1237
00:57:18,000 --> 00:57:20,000
You think I'm trying to trick you, right?

1238
00:57:20,000 --> 00:57:22,000
Programming, I must have embedded primitive values

1239
00:57:22,000 --> 00:57:24,000
into this somewhere, right?

1240
00:57:24,000 --> 00:57:26,000
I have not. They're all just functions.

1241
00:57:26,000 --> 00:57:28,000
They're simply encoding.

1242
00:57:28,000 --> 00:57:30,000
I'm a human being. I'm going to say this is true.

1243
00:57:30,000 --> 00:57:32,000
The computer or the notation doesn't know

1244
00:57:32,000 --> 00:57:34,000
what true means.

1245
00:57:36,000 --> 00:57:38,000
True and false are really bad names.

1246
00:57:38,000 --> 00:57:40,000
Names are hard, right?

1247
00:57:40,000 --> 00:57:42,000
This is not philosophy, it's just computation.

1248
00:57:42,000 --> 00:57:44,000
I'm just trying to make decisions.

1249
00:57:44,000 --> 00:57:46,000
Is zero false? Why?

1250
00:57:46,000 --> 00:57:48,000
No, really, I want to know.

1251
00:57:50,000 --> 00:57:52,000
Does JavaScript think zero is false?

1252
00:57:52,000 --> 00:57:54,000
I don't even remember.

1253
00:57:58,000 --> 00:58:00,000
That's reassuring.

1254
00:58:00,000 --> 00:58:02,000
It's not reassuring that that's not a type error.

1255
00:58:06,000 --> 00:58:08,000
Actually, it should return something like that, probably.

1256
00:58:08,000 --> 00:58:10,000
Anyway.

1257
00:58:10,000 --> 00:58:12,000
What does double equals do?

1258
00:58:12,000 --> 00:58:14,000
Oh, man.

1259
00:58:38,000 --> 00:58:40,000
No.

1260
00:58:40,000 --> 00:58:42,000
No.

1261
00:58:42,000 --> 00:58:44,000
No.

1262
00:58:44,000 --> 00:58:46,000
No.

1263
00:58:46,000 --> 00:58:48,000
No.

1264
00:58:48,000 --> 00:58:50,000
No.

1265
00:58:50,000 --> 00:58:52,000
No.

1266
00:58:52,000 --> 00:58:54,000
No.

1267
00:58:54,000 --> 00:58:56,000
No.

1268
00:58:56,000 --> 00:58:58,000
No.

1269
00:58:58,000 --> 00:59:00,000
No.

1270
00:59:02,000 --> 00:59:04,000
No.

1271
00:59:04,000 --> 00:59:06,000
No.

