Rwy'n cael ei ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud.
So, welcome everybody to this workshop, Lambda Calculus for people who can't be bothered to learn it.
I was surprised to see on the schedule, I think there are at least four Lambda Calculus related workshops and presentations at this conference.
That's a lot of Lambda Calculus. Did any of you go to the six hour one yesterday?
Dana Scott? All day? How was that? I'm sure way over my head. This will not be a reprise of that at all.
For people who can't be bothered to learn it part, that is because I'm not really going to teach you all of Lambda Calculus.
It is actually quite a deep subject, there's a lot to it, there are many different Lambda Calculi.
I'm mostly going to be doing a little bit with the simply type Lambda Calculus, which I think is something anybody can learn pretty quickly.
And it can actually be a little bit fun. Also though we're going to be implementing it in America's favorite programming language, JavaScript.
Now this is not because I recommend JavaScript for functional programming or any practical purpose whatsoever.
It's because I don't want to have to ask everybody to install Haskell or some other language.
You all have JavaScript on your machines already. For those of you who don't know this, you may be slightly surprised by that fact.
But I assume all of you know this in your browsers, you have a console, it runs JavaScript, that's all you need. So easy for me.
I'm also not going to be using very much of the JavaScript syntax such as it is at all. Just anonymous functions, but we'll get to that.
So again, just to reiterate, please stop me, ask questions. I don't generally like the Socratic method of teaching, but let's see if you can read my mind.
What do you suppose is maybe the simplest, what you might think of as the dumbest possible question you might ask about Lambda Calculus?
Anyone want to take a guess? I'll never do this again.
Why?
Why what?
Why do you need to bother?
That's a smart question. I'm looking for a dumb question.
That's it. Yeah, why is it called Lambda Calculus? Does anyone actually know why it's called Lambda Calculus? I know you know.
No, no, no, no. I don't want you to. Yeah. Yeah. Yeah. Okay. Good. I'm glad for all of you people know.
This is an important point. It seems like a trivial point. This might be a little bit of mythology. Very quickly. I think it's kind of funny.
All right. People are afraid of this. It's got a Greek letter. It's called Calculus. If you're not a math person, I'm not a math person. It sounds scary, right?
Forget the calculus part. You know, we're going to count some things with it or something like that. So forget calculus.
But Lambda, what is this Lambda thing? A little bit intimidating. This whole conference is about Lambdas, right? Lambda comp.
Well, Alonso Church, the person who developed, discovered, invented Lambda Calculus, the story that I read in academic literature was that he actually wanted to use some notation from, I guess, the 18th century that looked something like this, actually like a little hat.
If he had gotten his way, we'd be calling it hat calculus, I suppose. I know that sounds funny, but there actually is a hat calculus. Look it up on Wikipedia. It became a different thing.
Back then, professors had secretaries. I'm actually a recovering English professor. I never had a secretary. But typewriters couldn't do that.
So his secretary ended up kind of doing that to represent it. He could do that with some slashes. This could all be a myth. I don't know. What does that look like? Yeah, capital Lambda, right? That's it.
So they called it Lambda Calculus and eventually went lowercase. I suppose it looks nicer. They use this for type systems now. That's it. So what is the point?
I mean, okay, it's like a little bit of a factoid. Completely arbitrary, right? These are not things to be scared of. All of the names that are used in Lambda Calculus and much of functional programming, they're just arbitrary names.
There's nothing to worry about. They sound a little bit intimidating. They certainly intimidated me. I may be more easily intimidated than all of you. But the point is like, who cares? It doesn't even matter. These names are not important.
Okay. I'm not going to do a lot of slides. In fact, originally, I wasn't going to do any, but I thought it's probably worthwhile to introduce the syntax of Lambda Calculus a little bit before going straight into JavaScript.
I need to ease you into JavaScript because I know it's a little bit painful. And I should introduce myself. This is my name, Stephen Syrac, in case you're wondering about the pronunciation. I'm SJ Syrac in all the places.
And like I said, I'm a recovering English professor. And I just want to point out to you that if I can do this, you can do this. I've not been doing this for very long. I taught myself Lambda Calculus while I was learning Haskell not very long ago.
I think I started a year and a half ago at the most. And I became very excited about it enough that I was willing to do this right now.
So I want to make that point not only because I want to be encouraging to all of you, but because there are two purposes to this talk in my mind.
One is that maybe I can communicate something about Lambda Calculus to you and why it's useful, why it's awesome, why it's the foundation of everything that this conference is about.
But also, and for me more importantly, and for those of you who do have experience, and by the way, those of you who do have experience, feel free at any time to tell me when I'm wrong.
I need that and I appreciate it. And also please help others around you.
I want everyone to be able to come away from this presentation able to teach this material to somebody else.
The only way the functional programming world is going to grow is if all of us become teachers.
Maybe that sounds like an extreme statement, but we're a very small community.
And for our own self-preservation, we need to expand, like expand or die.
And the other reason I'm using JavaScript is precisely for this reason.
You can go back to your places of work or to your friends if you can convince them to learn something called Lambda Calculus.
And everybody has a web browser and you will be able to open that up and show them some things without having them install a complicated programming language or some software they don't understand.
Because like I said, anybody can learn this.
So if you already feel competent with this material, then at the very least you can help me develop this into a better presentation for teaching others.
And then find a way to use this material to teach your colleagues, right?
Because you may not get them to install Haskell, but you can get them to open up a browser and then you can just immediately start writing functions and show them how this stuff works.
Okay, so that's enough motivation I think.
Are there any questions at this point?
I know that you wanted me to go over purposes and aims or something.
Perhaps just some specific examples of how perhaps Lambda has helped you to better understand or other ways to change the way you approach my house.
We don't program any Lambda Calculus.
This is a mental exercise.
Don't you?
Don't you?
That's very heavy, but it's a useful exercise for the ultimate American language.
Thank you for asking.
I think it's really useful for developing an intuition for what functional programming is all about.
Raise your hand if you're really not sure what functional programming is.
Yeah, honest people.
Yeah, exactly.
Raise your hand if you think that you would be able to competently explain it to somebody else.
That's the other kind of question.
Functional programming is programming with functions.
So helpful.
I think actually this material will really show you what functional programming is all about.
It's elementary particles as it were.
What has Lambda Calculus itself taught me about programming?
I think I only have a boring answer to that question.
Haskell is a Lambda Calculus.
So I made this joke, don't we program with Lambda Calculus?
Yes, if you're using functional programming language or using Lambda Calculus, you just may not know it.
So at the very least now you'll know it.
I never really thought about how Lambda Calculus specifically...
I mean, I suppose I can look at a function and know that I'm doing Ada reduction now,
or that maybe I should do Ada reduction.
I guess there are places in which it helps me with refactoring or conceptualizing.
I'm not going to be talking specifically about that, I don't think.
I guess I would maybe be able to talk about how Lambda Calculus gives us for free all of these features that we hear about
when we talk about FP, right?
Referential transparency, immutability, currying.
What are some other good ones?
I don't know, fixed point recursion?
Anyway, that stuff all just sort of falls out for free from Lambda Calculus.
Anyway, let's get to it.
This is the whole language, right?
World's smallest programming language.
Maybe actually the first programming language invented.
1933, anyone know the date? 1933?
I think it up in Wikipedia, Alonso Church, Lambda Calculus.
Before there were computers, right?
They got it right the first time.
This is the whole language right here.
Concentrating first on the first line.
Anything in Lambda Calculus is an expression, and then there are three kinds of expressions.
Names, functions, and applications, and that's it.
A function can be a name, so the lambda name.
I'm going to explain all this a little bit in more detail.
Lambda name.expression, and an application is just two expressions next to each other.
So you can see how this is a bit of a recursively defined language.
The lambda in the second line, that's the famous lambda that everybody wears.
Does anyone have a lambda on their t-shirt right now?
I'd be surprised, actually, if nobody did.
You're probably all wearing one on your lanyard thing.
It's just an abstraction operator.
If you're a programmer, you're used to abstraction, even if you don't know functional programming.
All that is saying is create an abstraction called name and bind to that, this expression, whatever the expression is.
And then function application is two expressions next to each other.
So if you're used to Haskell syntax, the reason why we don't have parentheses in Haskell is because function application is kind of the only operation we have.
So we keep it simple. It's just two expressions next to each other.
I'm so happy to have a blackboard. I don't do slides, so I'm more used to blackboards personally.
God, this is like very fat chalk.
I will be showing some expressions soon, but I just want to make this point.
So you can have something like lambda x dot x.
We actually call this the identity function.
And this part here, we can call it the head, this part is the body.
This is an expression.
Obviously x has no meaning. This is an abstract syntax.
Whatever you have here, whatever the expression is, it's just some stuff that we're going to compute under this thing, lambda x.
You've heard anonymous function. I don't like anonymous function. It doesn't have a name. It doesn't matter.
This operator creates an abstraction out of this expression.
And the x just means that this x and this x are the same.
If you're used to functions that look something like this, it's just text substitution, really.
Really, it's just text substitution. This was invented before there were computers.
In fact, with the lambda calculus, as simple as it is, you can model any computation whatsoever.
That's what's really neat about it. Maybe that's a good answer to your question.
You can compute anything that can be computed with this.
It doesn't seem like you should be able to. I'll prove that.
I mean, there are things you can't compute, and there are things you can,
and that's just sort of a property of nature, and this sort of captures that in the simplest possible way.
So, there's an expression, x. It's just something, something x.
Lambda x.x, I just showed you that. This is a function.
Body dot body dot, sorry, head dot body.
Lambda x.lambda y.xy. This is another expression, and you can think of this as a function with two arguments, x and y.
Lambda x.x, in parentheses, applied to y.
This is not terribly different than if you had simply x, y.
This is also function application. This lambda x.x, y is also function application.
By function application, again, I mean text substitution.
It's probably worth not thinking too much about functions as procedures,
or what you're used to in imperative programming languages.
Lambda x.xy.
Function application means we're doing text substitution,
so the y substitutes for this x in the expression.
This goes away, and we're just left with y.
Y goes into x, turns into y.
This is also a function application, and it's not more complicated.
They get longer and more, they look trickier, but ultimately the rules are the same.
Lambda x.x, lambda y.
Anybody want to guess what this turns into?
Because this whole thing goes into here and is substituted for this x,
so we're just left with that.
This is one of the operations, actually, beta reduction.
Anybody want to get another guess for the audience?
When we say alpha substitution or alpha conversion, where does the alpha come from?
Why alpha?
What's the dumbest possible answer?
Yeah, that's it.
I've got to call it something.
Oh god, I can try the third one.
Lambda x, lambda y, xy.
Lambda x.
Write that using, like, f?
Well, does somebody else want to try?
I mean, I could do it, but maybe someone else should do it.
I mean, I suppose you could have f of x, y,
and then you could apply that to one and then two.
I mean, these don't do anything, right?
We don't know what x and y mean.
It's just a function.
It's just a pure function.
For any given input, it has the same output, right?
Whatever x you give it is always x.
It's always the same, right?
It's mapping between sets.
Is that helpful?
When we get to the JavaScript,
well, I never thought I would say this sentence.
When we get to JavaScript, it'll make more sense.
OK, so here's alpha substitution.
Again, the variable names, they don't mean anything.
You can use any variable that you want,
and yeah, I'm being very funny about using poop emoji,
but the point is these are all the same, OK?
I'm going to use this triple equals a lot
because this is not equality per se.
These are all actually identical.
Lambda A dot A, lambda Z dot Z, poop, whatever.
They're all the same.
All of these represent the exact same things.
You can substitute them one for the other.
And you sometimes need to do that in complicated lambda reductions,
which we are not going to do, right?
I don't want to learn lambda calculus.
That's why you came here.
When we get to the JavaScript, sorry, yeah?
Is there a difference between the same after the dot?
Legibility?
But no.
You're separating the arguments from the expression.
That's what the period is.
Yeah, yeah, yeah.
A is the argument.
Lambda A, that A is the argument,
and the A after the dot is the expression.
Yeah.
It doesn't matter. It's just notation, right?
This is not a programming language.
I'm sorry, this is a programming language.
This is not something you can run on a computer.
Here's a slightly more complicated.
That was alpha substitution. This is beta reduction.
I kind of did a few already, so I hope this makes sense.
You have lambda X, lambda Y, X, Y applied to P and Q.
So first you apply the P, the X goes away.
Now you have lambda Y dot PY.
Then you apply the Q, the lambda Y goes away,
and you end up with PQ.
Does that make sense?
It worries me sometimes that this stuff doesn't actually
make intuitive sense, so if it doesn't make sense,
I will explain it in more detail.
Again, I thought I was going to get 10 people,
and I'd be like, does it make sense to you?
I think it does.
I know. Well, we're going to get there.
This is just supposed to be a warm-up.
I actually don't want this to take that long.
This is kind of neat.
Lambda X dot XX applied to lambda X dot XX.
When we reduce that, we get the same thing, right?
Because if you plug this into this expression,
this X goes away, and you actually substitute this
for both of these Xs, right,
and then you get the same thing again.
Recursion.
You can do recursion with pencil and paper.
I thought that was pretty neat when I first learned it.
Finally, eta conversion.
This is mostly for your information.
It's not going to be terribly important for the talk today,
except eta conversion will come up in one very important place later.
What I'm saying here is that maybe this is the math part that will help.
I don't know.
I can't really make it simpler than it is.
Lambda X dot F of X is just the same thing as F.
The X is superfluous. It's the same thing as a function F.
If you have a function F applied to an X,
you can put that into a lambda abstraction.
That is the same thing as F itself.
Which one?
Lambda X dot F of X.
That's a good point.
I wasn't going to talk about free variables.
The F is not bound in this expression.
If I were actually teaching you lambda calculus,
which I'm not supposed to be doing,
I would say that the F is a free variable.
It's F in some global state.
We don't like global state in functional programming.
It represents some global binding F.
These two things just happen to be identical in meaning.
The F is the same in this case.
That's a good point.
Let's get right into combinators.
Another scary word.
A combinator is a function with no free variables.
It's a function you can combine with other functions
to do some very neat things.
We've already seen this one.
Lambda X dot X.
We call this the identity function because whatever we give it,
we get it back again.
This will prove to be useful and important
in many places in functional programming.
This is also, I guess you could say,
the universal fixed point combinator.
That sounds scary too.
The fixed point of a function
is the value that when you give it to a function,
you get the same value back.
There are many examples of this in math.
I'm not going to go over them,
but I hope you can see that for this function.
Lambda X dot X.
Whatever you give it, you get back.
That's what I mean by universal fixed point combinator.
Fixed point combinators will also come up again later
in a much sexier way.
This is what the identity function looks like in Haskell.
My favorite programming language.
And yours too, I assume.
It's not easy to type a lambda on your computer,
so we have a slash there instead.
That represents a lambda, essentially.
This is what we're going to use in JavaScript.
Assuming that your browsers are all up to date
and you have fat arrow functions.
Same thing, very simple, right?
This is the basic building block that we're going to use.
Anybody know what this is?
Python.
Yeah, Python.
Anyway, what about that?
Ruby.
Yeah, this is good for me to gauge the room.
Who knows what?
What about this weird looking one?
Not Ruby.
No.
Can you do this in Java? I don't actually know Java.
I'm proud of the fact.
I've been programming as a hobby my whole life.
I lost interest in the 90s,
which is when Java started becoming popular
and I got back into it not very long ago.
I feel like my great pride in life is I missed the Java period.
I hope.
I'm sorry if I'm moving too quickly.
I do want to get to JavaScript.
I can't believe I'm saying this stuff.
Now we have a very simple notation
for creating computations,
but it's a little bit clumsy.
We need to actually start creating some primitive values.
We can create true.
Again, this is not a binding in the sense of a variable binding.
These two things are completely equivalent.
They are a substitutable one for another wherever you see them.
We're just going to say,
lambda x dot lambda y dot x means true.
This is simply a function that takes two values,
an x and a y, and it returns the first one.
We're just going to say that that's true.
You could do it a different way if you want,
but we're going to use that as our convention.
We're just going to encode true as this function.
We're going to encode false as the opposite.
It's a function that takes two values
and returns the second value.
That's it.
This is not like some standard of lambda calculus.
This is just totally a convention.
It's the convention that is typically used, so I'm using it,
but we're just making it up.
Did I see a hand somewhere?
Sorry, I was just going to interject.
If somebody is trying to use node and you're using
new language features, it might not work.
You can use Babel.
I'm going to put that in the chat.
Okay.
Actually, Babel inspired me to do this at some point.
Actually, I was very frustrated
with trying to learn lambda calculus.
I started messing around with it in JavaScript
because it was there.
Then eventually one thing led to another.
Here we are.
We can make more complicated functions,
logic functions like and.
I hope that if you look at this and you're a programmer,
this makes sense.
If you have two values, you can determine
whether or not they are both true.
You look at the first one.
Is it true?
If it's true, you compare it to the second one.
Actually, let me be clear here.
We have two functions, true and false.
True returns the first value.
False returns the second value.
If A is a Boolean value, true or false,
if it's true, it's going to return whatever B is.
If it's false, it returns false right away
because it's an and.
If B is a true, then it's true.
If B is false, then the whole thing is false.
Does that make sense?
That's why that looks like that.
I can do it on the board too.
I hate chalk.
From my understanding, I see that basically,
when you see lambda x, it means the function f.
In the first situation, it takes two variables,
f of x, y.
In this case, it returns x.
In the second question, it takes f of x, y.
Then it returns y.
In the third case, it takes two arguments
and returns an and.
That's basically it.
That's the same thing.
It really isn't more complicated than that.
Does the notation is just what is causing the confusion?
Here's the ultimate cop out.
I didn't invent this notation.
It provides us a universal language
with which to speak about functions
and function application.
When I said this is what functional programming
is all about, literally everything is a function.
You've heard everything is a function.
What does that really mean?
Functions are values.
We're just saying lambda x dot lambda y to x is true.
It is the value true.
We're loading truth as that function.
Then we can do stuff with that function
to build up more complicated expressions.
There's an and, there's an or.
We can do not.
Now we have booleans.
We're getting close to being able to do actual logic.
It's all functions.
I don't know how you feel about this inside your own head.
This was mind-blowing for me when I first learned about it.
Reducing expressions.
We can take an and and a true and a false.
We can take the lambdas back in.
It looks like that.
Already it's starting to be headache inducing.
I know.
The point is and a true false is identical to this expression.
It's easier for us as people to deal with and true false
than with all of this lambda stuff,
but you can actually still work this out on paper.
You can perform these reduction steps that I showed you.
Ultimately, there's the first step of the reduction,
another step of the reduction, another step, another step.
By the way, the slides are all on GitHub,
so you can play with this later if you like.
Essentially, all of this reduces down to this function.
These are the reduction steps.
If you are plugging things in and replacing your bound values
in the expressions at each step of the way,
finally you get to lambda x dot lambda y dot lambda y,
which we already know is false.
That's how it works.
That's how you do a computation anyway in lambda calculus.
A very simple one.
I can, but why do you want me to?
I'm going to be honest with you.
I hate touching chalk and I am trying to avoid it.
I will do it if necessary,
but I would just be writing that again.
You want me to go through the whole thing?
No, that's not.
Totally, I will do it later, pen and paper,
but it will take too long.
I only have two hours.
I think you were just saying the end in the last slide,
you could just pop through it,
but you didn't write it.
Is it arbitrary like you're in false?
Yes.
I'm just going to say that's true and that's false.
Just like truth and false in real life are arbitrary.
You came for the deep stuff today.
I know you want to look for some meaning,
but I showed you that first slide with the,
that's it, that's the whole language.
Those three things are the whole language.
I have to build the entire system of computation out of that,
out of just functions.
If I want to do Boolean operations,
I need some notion of truth and false.
If I want to do comparisons,
I just have to invent them.
I have to invent them in a way that they'll work
and this happens to work.
It seems like a bit of magic and I guess it is.
You're saying that they're arbitrary,
but they're not arbitrary
in comparison to each other.
These are built up in such a way that...
The system is logically consistent.
It actually has...
It developed out of the study of logic, in fact.
Formal logic.
Not stuff I know a whole lot about.
But yeah, they're not like random.
They're sort of encodings that were decided upon
as part of a system that is internally coherent.
Wait till we get to numbers.
Okay.
So now that we have some Booleans,
we can actually create useful functions.
That determines whether or not a value is zero.
I've rearranged this presentation
since the last time I did some piece of it.
So we don't have numbers yet.
Bear with me.
So let's say that X is a number.
This function will tell you whether or not
that number is zero.
This is maybe an easier way to look at it.
Is zero n?
So is zero n is going to return
a true or a false?
And if it returns true,
so we're applying...
I think I need to maybe explain this a little bit better.
So this is zero n
is going to reduce down to a true or a false.
We know that true returns the first value
that it's given, right?
So it's going to return true.
If it's not zero, it will return false.
Because false returns the second value.
That's it.
We're applying true and false to this function
is zero n, yeah.
So it's going to return true,
and now you're talking about same features.
So how do they match into the number?
What is one for zero?
Oh, you're going to love it.
I think it's on the next slide.
Yeah, yeah.
I wanted to do predicates after a boolean,
so the numbers are slightly out of order.
So bear with me.
Okay, so now we can have
branching in our Lambda Calculus.
We can say an if statement
is simply a function
that is a predicate, right?
A predicate is a function that returns true or false.
And then we apply to that
two values, x and y.
And if that predicate p is true,
it will return the first value if it's false
that returns the second value.
Yeah.
What's the definition of zero?
You're saying is zero for a false.
What is the definition of zero?
We're going to get to that.
Yeah.
So that kind of would look like that, right?
If n is zero,
then you would do the value
in that then branch.
Otherwise, the else, right?
And actually, we can factor out
the p, the x, and the y.
We can just say that if it's the identity function.
It's the same thing really,
because we're just dealing with predicates.
Whoops.
Right, that's...
If you want to write it as like a little law for yourself, right?
Expression one, expression two.
If p is true, then e1, else e2.
Okay. Everyone wants to do numbers.
And you know what? I don't blame you, because
how the heck do you do numbers with only functions?
This is really where the whole idea
of functions as values, I think, is going to
make sense.
I hope I'm going to drive this home for you.
Speaking of arbitrary,
we're going to call zero
a function that takes
an x and returns an x.
It does nothing to it, right?
We're just going to say that's zero.
That's a zero, but it's just an encoding,
ultimately. You can encode it in binary.
That's another way of encoding it.
Again, a convention.
This symbol represents some idea
of zero. We are so used to using it.
We think, well, that's zero.
And that's five.
But it's just a symbol.
There's one.
Lambda f dot, lambda x
dot f of x.
You're going to see a pattern very soon.
So now we're taking a function and a value,
and we're applying the function to the value one time.
There's two. There's three.
You can probably guess what four looks like,
and possibly 5,000 at this point.
Because what is a number? If you're doing something
with a number in computation,
you may just be storing a value, but
very likely you're probably going to be performing
some operation that number of times, right?
For any number n, you're going to do something
three times. That's all that this is doing.
Some number x.
If you want to do something
with the value three,
then you apply, with a function,
you apply that function to the value three times.
Four, five.
It gets ridiculous.
And by the way, again, this is not variable binding.
These are identical. I'm just using this
as a convenient symbol. You could use poop emoji here, too, if you want.
I want you to be able to read this.
So, all of this stuff,
I don't want to type that ever again.
Especially when they start to get really big.
So, I just attach convenient names to them
for my own benefit.
Now, enumeration. We can actually
work with these numbers and get somewhere with them.
There is a function that will tell you what the
next value is for a given value n.
This one's more complicated.
I don't want to divert too much into these things.
So, again, I'm not meant
to be teaching you lambda calculus. This is taking too long.
I just want to show you
that you can do this kind of stuff
and that this is the basis of functional programming.
These are functional combinators
where all values are functions
and you can actually do computation with just functions.
Pred is complicated
and it actually was kind of a discovery at the time
because they didn't know how to do it.
And it will tell you the number.
Suck of two is one
and pred of...
Sorry, suck of two is three
and pred of two is one.
That's what those are for.
There's a reduction. You can write it out on paper
if you don't believe me. It totally works.
The number after one is definitely two
and the number before one is definitely zero.
They work. I tested these.
Now we can do some complicated arithmetic.
There's ad and at this point
I'm going to start going a little faster
because the actual encodings don't particularly matter.
The fact that we can do them is what matters.
Different ways of doing ad
they both will give you the same result.
Subtract, multiplication,
exponent which is delightfully simple.
Totally makes sense though
that you're applying a function
that gets applied a number of times
to another function that gets applied a number of times.
Now you have an exponent.
Here's a reduction.
If you add one and two together using functions you get three.
You get a functional encoding of three.
Now if you're doing functional programming
you get this garbage.
But this is the underlying substrate
you might say of the functional computation
and it ultimately gives you
the correct answer that you want.
This is just a very simple sort of program.
Subtraction is a little bit more tedious.
I mean tedious for me.
I'm so terrified of being wrong.
I sat down and wrote these out on paper.
I encourage you to do that
just to get an intuition for it.
Multiplication and exponentiation.
Look at that eight.
I think it's crazy.
All the parentheses.
This is really the hot stuff.
Raise your hand if you've heard of Y Combinator.
Like the company, right?
I hope you all end up...
Do I hope that you all...
No.
Raise your hand if you've seen the Y Combinator.
This Y Combinator.
I don't know if you are aware of this
but the company Y Combinator
the name is based on this function.
This is how you perform recursion
in the simply...
Sorry, the untyped lambda calculus.
I referred earlier to fixed point
combinators and this is a fixed point
combinator for functions.
Any function...
For any function that you give fix
it will return that function again
and that is how you perform recursion.
For example, everyone's favorite example,
factorial.
Here's a function that will perform a factorial
but we need to do recursion to perform
a factorial, right?
We'll say factorial is
going to be a function
that is the fixed point of this function F.
We're going to pass F to our
fixed point...
I didn't call it Y because I want to be clear.
The fixed point combinator is a function
that when you give it a function
it will return that function again.
It actually embeds the function into the expression
in a way that you're going to see in a minute.
Honestly, the details aren't important
because you're not here to learn lambda calculus, honestly.
But I want you to get a sense for it,
an intuition, right?
We're going to take the function F
and we're going to pass it to the fixed point combinator
and it looks like that.
That's what we get in the first reduction step
and you can see that F is now embedded into the recursion
and that's how we can perform
a factorial operation.
There it is again
and it looks like that.
It will keep doing that until we're done,
until we reach our base case.
The base case, right?
End part.
Without the base case then it doesn't stop.
It lets a lot of writing.
I'm going to walk you through the recursion now
step by step.
I don't expect you to...
This is mostly for entertainment.
This is what it looks like when you write this out, right?
We're going to calculate now the factorial of 2
step by step
and we're doing beta reduction right now.
It's just text substitution.
We're putting values into functions.
I'm actually cheating a little bit
because I'm not expanding all the lambda expressions
because I know that...
I know that
whether or not a number is zero
so I'm just doing this in my own head
but this is an accurate representation
of the reduction, right?
At each step.
It's almost legible, right?
Even if you don't know lambda calculus
you know a little bit of programming maybe.
You can see how this would work
to calculate a factorial
and I end up with that
and this one is two.
I can do anything now, right?
I have numbers, I have recursion,
I have branching.
I can calculate anything.
You wouldn't want to calculate anything in lambda calculus
like this but you could, in principle
you could.
I think that's the point.
The first step of what's happening
is getting substitutions and building
that first step is getting substitutions
and building this whole thing out
and then the next step is evaluation
and trying to figure it all down.
Well, I mean
not exactly.
Okay, maybe the point
is abstraction, right?
Because I don't want to write lambda expressions
but I want to be able to trust
that this stuff is going to work
without worrying about the notation.
When you get to a real programming language
then obviously you're not worrying about this.
This is sort of how functional programming
works at some very primitive level.
You might think of it that way.
When you write programs you're not writing stuff like this
but if you're working with pure functions
you don't worry about state
then you know that
when I write fact I'm really writing
fact after what I'm writing all that lambda stuff
and it will work the same every single time.
I would rather work with
named functions because they're easier for me
and named values than with long
lambda expressions.
Yes?
I wasn't going to say it yet
but look, you get currying for free. It's right there.
Because you're applying each argument one at a time.
If you're familiar with currying that's what it is.
Instead of applying all your arguments at once
you can do them one at a time
and you take a function, you apply an argument
now you have a new function with that argument applied
and then you do the next one and the next one.
It's a freebie.
Like referential transparency.
That just means that
when I was showing you earlier that these expressions
triple equal sign or this name
triple equal sign this expression
that those are completely identical
and you can do equational reasoning with these things
and trust that it's always going to work
because there's no such thing as global state
there's no memory. This is not a Turing machine.
It's just symbolic manipulation.
Okay, so I told you I cheated a little bit
with this example.
Here's what the real thing looks like if you're working with just lambdas.
Can you even read this?
I blew it up, you can't read it anyway.
So this is the whole thing and if you sat down
and you worked this out with a pen
and a piece of paper like I did
so that in the event that someone was in the audience
and did this and found that I was wrong I wouldn't be embarrassed.
It works.
These are the reduction steps
for just as just factorial of 2
if you did factorial of a higher number
you get to the point where it will take you
until the heat death of the universe to compute probably
but you can see how the reduction steps
ultimately get you to the same answer.
There it is.
lambdaf.lambdax.f.f of x
is 2.
So now you know the factorial of 2 is 2.
That is the entirety
of the syntax of lambda calculus I want to talk about.
Are there any questions?
No.
That's more than I want it to do in fact.
You mentioned a lot of paper and pen.
When you're learning lambda calculus
do you recommend paper and pen?
No, paper and pen.
It's easier.
Why don't you check yourself
because there's no compromise with what you're trying to do?
It's a good question.
How do you check yourself?
I just did.
This is a proof, right?
It works.
You can do it and make sure I did it right.
In lambda calculus
you know what 3 plus 0 is in real life.
So you don't take 3 plus 0
in lambda calculus and you know you did it wrong.
Right.
I'm establishing a principle essentially, yeah.
So basically in the yw ychwanegwch,
ychwanegwch, ychwanegwch, ychwanegwch,
ychwanegwch, ychwanegwch, ychwanegwch,
ychwanegwch, ychwanegwch, ychwanegwch.
If you have a base case
if you don't,
then it diverges forever.
It never converges on an answer.
Similar to what?
Similar to what?
Like a for loop.
I mean, yeah.
I mean, yeah.
I mean, I don't love comparisons
to imperative programming constructs.
This is what it is.
This predates for loops.
I thank.
Pretty sure.
Lambda calculus.
Now we're going to do JavaScript.
Thank God, right?
Something everybody is familiar with.
So I hope that everybody...
Can everyone see that? Is that big enough?
No, not.
Okay, maybe.
Oops.
Oh, great.
How about that?
Or that. Is that good?
Yeah, my normal background is even lower contrast.
I thought maybe this would be easier.
No, not so much.
I can do dark...
This is slightly different, but almost exactly identical.
Let me see.
Why am I using BBEdit?
Um...
Do you like this better?
Yeah, okay.
Hi.
Bigger?
Whatever, I don't care.
So at this point, I hope you can all open up the file
and open up your...
Java...
I'm doing this in Chrome, and I tested it in Safari
and Firefox.
I don't know off the top of my head how you open a JavaScript console
in Safari or Firefox.
Command-option-j
in Chrome if you have
the lambda.html page open.
Sorry, question?
Question?
Okay, so now we're going to move more into
more of a workshop format, because that was a little bit more explanation
than I had wanted to do.
You have all of the functions that I've shown you
and a lot of other stuff,
and what I want you to be able to do with now
is really play with them in your browsers.
The point is, I don't want to lecture at you.
Here's what functional programming is all about.
I actually want you to use these functions
and build computations with them so you learn
not only what functional programming is,
you develop this intuition that will allow you to explain it
to others.
What does it mean when we say functions are values?
That is the whole point of what I did this for.
So type stuff in.
As I go through these things.
I'm just going to go through
the code, essentially.
I just want you to play with it in your browsers
and see what you can come up with.
There are a couple of little exercises that you can do if you want.
I actually have never given
these kinds of exercises for a group before,
so I don't know how that will go over.
We'll just find out.
Now we're in JavaScript,
maybe you'll see the magic for real.
We're only going to use the anonymous arrow function
to do everything.
The same with operations.
This is what I showed you.
Alpha, beta, and eta conversion.
If you type these in.
These are like a little toy proofs.
You know, they work.
They're true.
Oh, I should note also
this file has a bunch of helper functions
because we need to translate between
JavaScript and lambdas.
Otherwise we can't read anything.
For example, I can type in one,
but it looks like that.
What you know is like a lamb to f lamb to x,
f of x. We know that that's one,
but...
Good point.
How about that?
Okay.
So here's our identity combinator,
id equals x,
returning x.
Assuming everybody is either familiar
with the JavaScript arrow syntax,
or this is trivial enough
that you can pick it up.
Here's our true and false.
It takes two values, x and y,
and returns x is true, and the opposite is false.
Again, you can
cut and paste these things
to test them.
I have a two-bool function
that you can...
and true, false.
Returns false.
They work, thankfully.
At some point you will probably be able
to break this because
JavaScript isn't designed for
deeply nested function calls.
Try calculating the factorial of, like, 10.
So here we have and, we have or, we have not,
and play with this stuff.
See what you can do.
That's kind of all I want you to do right now.
And true and true returns true, right?
And false, false returns false.
Well, actually, this probably won't work
because these are just functions.
Oh, look, it works. How about that?
If I type in plus,
any plus expression,
it looks the same,
but then the true and true
works instead of right now.
What do you mean?
If I type in 1 plus 1, 5.
Oh, you did like that?
No, no, with the constant for the named functions.
You did this?
1, 5?
Correct. I'll change the second over to 3.
It's going to look the same.
Oh, that's...
But your true and true function does work in this way?
Yeah.
I don't know why it does that.
It's just the way the Chrome console works.
It's just a situation.
Chrome's like, what are you doing?
No, it wasn't.
Yeah, so we have to...
You can look at the utility functions.
They're at the bottom of the file.
Just for convenience, I'm converting back and forth
between these lambda expressions and primitive values.
Okay, so a little exercise.
Try to implement XOR, right?
I've given you and or not.
See if you can come up with XOR
and what that would look like.
When someone comes up with it,
raise your hand.
We don't need to take all day.
Anyone have a good XOR implementation?
Brad, this is exclusive or...
No, I'm not trying to trick you.
I mean, I haven't written it for me yet,
but it's basically A and not B
or not A and B.
I think that's what I got.
Right?
You can test it.
I don't know if I've actually typed this in XOR.
Yeah, so...
I haven't actually typed it in yet, so...
Yeah, I encourage you to test these things, too.
Prove it to yourself, right?
Don't believe me.
Or find mistakes.
There are a couple of little weird bugs.
Well, there's one that I can think of
that you probably won't encounter.
By and large, this works about 99%,
which is pretty good for JavaScript, right?
Here's branching.
Remember before I said that,
in principle,
the if-then-else statement you can write
is this function
that takes a predicate, right?
A function that returns true or false.
And then two values, X or Y.
And if P is true, it returns X.
If it's false, it returns Y.
And as we did with Lambda Calculus,
you can do this in JavaScript.
You can factor out the X, factor out the Y,
factor out the P, and it's just the same function as ID.
Now you can write...
I don't know.
If-then-else.
So if this is true,
return true, if not return...
Maybe that'll work. That works.
Here are the natural numbers.
Here are some enumeration functions.
I can explain a little bit
how predecessor works.
It essentially will take
a pair of values,
a pair of zeros,
and it will increment one of them
up to the point.
A predecessor of five.
It'll increment one of those values to five.
And it will increment the other one.
It will skip one of the incrementations.
Increments.
It will skip one of the increments.
Then you get five and four,
and then it selects for the four.
That's something I could probably
demonstrate at great length,
but it would take too long, and so I won't.
But I do have a reduction to show you on that.
And because
this talk is
for people who don't want to learn Lambda Calculus,
I don't care if you learn Lambda Calculus.
I just want you to get comfortable working with functions
so that you can understand their expressive power
and why we do functional programming.
We're building actually an entire programming language
within your JavaScript console right now.
I don't know if that's apparent.
You can start putting more complicated things together
with these primitives,
and ultimately, in principle, you can do anything.
I'm not saying that you should write programs
out of these Lambdas.
I'm really nervous right now because
John said earlier at the end of the keynote
that these workshops are meant to be teaching skills.
Much from doing that, yeah.
No, yeah.
Yeah.
Yeah.
I'm not clear on how that evaluates us through.
Does that make sense?
Yeah, I'll try.
Let's see.
Let's say, we'll say A equals,
so let's say,
hmm.
I can apply
true to the and function.
And I'll just get another function back.
Yeah.
It's in there. I closed over it.
I would think that the X would be true now.
It is.
But I haven't evaluated the function.
I haven't reduced.
If I two-bould my little A function,
it gives me, you know,
it doesn't know what I'm trying to do.
No meaning.
So I've actually partially applied the true to my and.
So now I can apply the false.
Let's say B is A
applied to false.
Now B is fully applied.
Now I can two-bool on the B.
Is that meaningful
as far as reduction steps are concerned?
Let's see.
OK. No problem.
You're making me think on my feet.
It's good.
I can just type it in.
Right?
So this is
a function after all.
That's not special.
So this is
this is and, right?
So I want to apply.
In fact, I'll even replace the false with
I don't know.
I've not done this before.
So why not do it the hard way?
That's my motto in life.
OK.
So I'm actually going to get rid of the two-bool
because it's going to confuse me for a moment.
I think that that looks right.
I think that's the and function.
Right?
So now I can apply
like a true to it, for example.
But instead of applying the true,
let's just kill off
the X
and put it in there.
Let me start over
because I'm going to confuse myself.
I'm glad we're doing this because
this is the point.
I don't care.
It's helpful for me.
This talks about me.
It's not about you.
I actually might leave the
false in as it is because you get the idea
and I don't want to waste time being confused.
OK. So there's the true. We're going to apply this to true.
But instead of doing that, we'll kill off
that X and we'll just stick it there.
I need some other boolean value, right?
Because we need two branches.
So let's say the other branch
is false.
Right. So now I kill off
the Y
and now I have false.
OK.
But remember true is also just a function.
It's a function X, Y
that returns X.
Right? So then we have
this false.
We take that
and pull off this X
and then it's there.
OK.
Then we have another false
and we apply that to Y
and then we're left with false.
Does that last a little bit there?
We say you're applying the Y
and when you have the false, it was done
just two falses.
Is that why?
You know, it's tricky
because I'm just branching using booleans.
I'm not branching using real expressions.
Maybe if I say
you know, is 0, 1
true otherwise false
something like that.
It was helpful that you reminded me
that it was a function.
Yeah, yeah.
Remember, everything is a function.
You don't really know what it means.
Everything is a function.
Functional programming is programming with functions.
No, it's not intuitive at all.
I don't think it's intuitive.
But once it becomes intuitive,
one is a function.
Right, no.
You think I'm trying to trick you, right?
Programming, I must have embedded primitive values
into this somewhere, right?
I have not. They're all just functions.
They're simply encoding.
I'm a human being. I'm going to say this is true.
The computer or the notation doesn't know
what true means.
True and false are really bad names.
Names are hard, right?
This is not philosophy, it's just computation.
I'm just trying to make decisions.
Is zero false? Why?
No, really, I want to know.
Does JavaScript think zero is false?
I don't even remember.
That's reassuring.
It's not reassuring that that's not a type error.
Actually, it should return something like that, probably.
Anyway.
What does double equals do?
Oh, man.
No.
No.
No.
No.
No.
No.
No.
No.
No.
No.
No.
No.
No.
