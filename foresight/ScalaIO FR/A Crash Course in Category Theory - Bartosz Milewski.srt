1
00:00:00,000 --> 00:00:11,200
So many people are interested in category theory.

2
00:00:11,200 --> 00:00:12,760
This is a new thing.

3
00:00:12,760 --> 00:00:22,240
A few years ago, nobody wanted to listen about category theory, and now it seems like it's

4
00:00:22,240 --> 00:00:26,000
a very hot topic, lots of talks.

5
00:00:26,000 --> 00:00:32,880
And people are mentioning categorical terms in all the talks, I listened to several talks

6
00:00:32,880 --> 00:00:45,040
and it was like functors, monads, applicatives, all this beautiful stuff from category theory.

7
00:00:45,040 --> 00:00:51,400
And also a lot of people, when they talk about data structures, they say, okay, things like

8
00:00:51,400 --> 00:00:57,640
algebraic data structures, some types, product types, and so on, all this stuff has roots

9
00:00:57,640 --> 00:00:59,600
in category theory.

10
00:00:59,600 --> 00:01:03,320
So I want to talk about these things as well today.

11
00:01:03,320 --> 00:01:09,160
This is just an intro to category theory, so I won't cover a lot.

12
00:01:09,160 --> 00:01:12,800
Here's the plan for the talk.

13
00:01:12,800 --> 00:01:20,040
I'll talk a little bit about categorical semantics, about semantics of programming languages in

14
00:01:20,040 --> 00:01:22,480
very generic terms.

15
00:01:22,480 --> 00:01:27,200
And of course I'll talk about composability, because composability is what category theory

16
00:01:27,200 --> 00:01:29,680
is about.

17
00:01:29,680 --> 00:01:32,440
Then I'll talk a little bit about algebraic data types.

18
00:01:32,440 --> 00:01:38,280
I feel quite a bit about algebraic data types, come to think of it, because it's like a very

19
00:01:38,280 --> 00:01:41,320
important part.

20
00:01:41,320 --> 00:01:45,480
Then I'll talk about function types, because we're at a functional conference, functional

21
00:01:45,480 --> 00:01:48,000
programming conference, right?

22
00:01:48,000 --> 00:01:54,600
So function types and currying, and finally I want to end up with a Yoneda lemma, which

23
00:01:54,600 --> 00:02:05,240
is like the central theorem in category theory.

24
00:02:05,240 --> 00:02:13,520
So well, let me start immediately, because we don't have that much time.

25
00:02:13,520 --> 00:02:18,640
So I want to motivate you a little bit, right?

26
00:02:18,640 --> 00:02:23,520
And I have lots of motivations why category theory is important, and so on.

27
00:02:23,520 --> 00:02:30,400
But I think the real reason why I got into category theory is because it's fun.

28
00:02:30,400 --> 00:02:34,120
It's interesting, and it's mind-expanding.

29
00:02:34,120 --> 00:02:42,400
So if you are looking for reasons to study category theory, maybe you should just like

30
00:02:42,400 --> 00:02:46,000
enjoy it.

31
00:02:46,000 --> 00:02:52,760
I know that category theory is a branch of mathematics, and a lot of people have some

32
00:02:52,760 --> 00:02:58,200
preconceptions about what mathematics is, and a lot of people don't like mathematics,

33
00:02:58,200 --> 00:03:10,560
because they were, starting with primary school, we are taught not to like mathematics.

34
00:03:10,560 --> 00:03:16,080
And here I give an example of the things that we teach our kids in schools.

35
00:03:16,080 --> 00:03:19,360
This is like multiplying two numbers.

36
00:03:19,360 --> 00:03:20,920
This is a horrible thing.

37
00:03:20,920 --> 00:03:25,320
This is like mind-breaking for humans, okay?

38
00:03:25,320 --> 00:03:33,800
There is this huge discrepancy between, or impedance mismatches, like between human

39
00:03:33,800 --> 00:03:37,640
mind and computers, okay?

40
00:03:37,640 --> 00:03:40,880
And there are two ways of bridging this gap.

41
00:03:40,880 --> 00:03:48,360
One is we insist on being humans and just ask the computers to come up to our level.

42
00:03:48,360 --> 00:03:53,600
The other is to lower ourselves to the level of computers, and I think this is wrong.

43
00:03:53,600 --> 00:03:56,840
So this is an example of multiplication, right?

44
00:03:56,840 --> 00:04:04,240
We teach our kids to do this, and it has all the elements at which computers are very good

45
00:04:04,240 --> 00:04:07,080
and humans are very bad, okay?

46
00:04:07,080 --> 00:04:12,160
The only thing that's important here is that there is an algorithm behind it, right?

47
00:04:12,160 --> 00:04:15,880
But we don't even tell the kids that there is an algorithm.

48
00:04:15,880 --> 00:04:19,440
We just tell them, here are instructions.

49
00:04:19,440 --> 00:04:24,440
Perform these instructions one after another, okay?

50
00:04:24,440 --> 00:04:31,040
And this is the moment where we are teaching kids imperative programming, and they are spoiled

51
00:04:31,040 --> 00:04:32,040
for life.

52
00:04:32,040 --> 00:04:38,360
And then we have to take years and years to un-teach them, you know, functional programming

53
00:04:38,360 --> 00:04:42,440
is like the declarative way of saying things.

54
00:04:42,440 --> 00:04:48,360
That's much more human, but we are so used to this kind of thinking, the imperative thinking

55
00:04:48,360 --> 00:04:54,080
from the very beginning, that it's very hard to break these things.

56
00:04:54,080 --> 00:05:04,200
So here I match things that we are good at versus what the computers are good at.

57
00:05:04,200 --> 00:05:08,480
Computers are very kind of local thinking, right?

58
00:05:08,480 --> 00:05:11,160
They look at the next instruction.

59
00:05:11,160 --> 00:05:18,480
They are not, they don't have this global perspective that humans have, right?

60
00:05:18,480 --> 00:05:24,520
When we start programming, right, we think about the problem that we are trying to solve.

61
00:05:24,520 --> 00:05:31,080
We have this global view, like where does this problem fit into the, you know, bigger

62
00:05:31,080 --> 00:05:39,120
picture of, we want our company to make money, for instance, you know, goals that we have,

63
00:05:39,120 --> 00:05:40,120
and so on.

64
00:05:40,120 --> 00:05:45,920
So we have this global view, and then we kind of descend to the nitty-gritty eventually,

65
00:05:45,920 --> 00:05:47,080
right?

66
00:05:47,080 --> 00:05:51,400
Computers are just nitty-gritty from the very beginning and all the time, right?

67
00:05:51,400 --> 00:05:55,160
They look at the particular instruction.

68
00:05:55,160 --> 00:05:58,440
Computers are progress-oriented.

69
00:05:58,440 --> 00:05:59,640
They just want to make progress.

70
00:05:59,640 --> 00:06:05,120
They just want to go from one instruction to the next instruction, one line of code

71
00:06:05,120 --> 00:06:07,640
to another line of code, and so on.

72
00:06:07,640 --> 00:06:13,600
They are not interested in what's happening, it's just locally and making progress.

73
00:06:13,600 --> 00:06:14,600
That's important.

74
00:06:14,880 --> 00:06:17,240
Whereas we are goal-oriented.

75
00:06:17,240 --> 00:06:20,400
We know why we are doing this, right?

76
00:06:20,400 --> 00:06:21,560
We have a goal.

77
00:06:21,560 --> 00:06:27,120
We want to calculate some value, or we want to draw something, we want to animate some

78
00:06:27,120 --> 00:06:29,760
pictures, you know, all this stuff.

79
00:06:29,760 --> 00:06:31,520
That's our goal.

80
00:06:31,520 --> 00:06:37,160
Making progress for the sake of progress makes no sense for us, right?

81
00:06:37,160 --> 00:06:38,800
For a computer, there is no goal.

82
00:06:38,800 --> 00:06:42,280
It's just making progress.

83
00:06:42,280 --> 00:06:48,480
Computers are very detail-oriented, whereas we operate with ideas.

84
00:06:48,480 --> 00:06:49,800
We have these abstractions.

85
00:06:49,800 --> 00:06:50,800
We have ideas.

86
00:06:50,800 --> 00:06:59,760
We try to convey these ideas to the computer so that it can be executed in some way.

87
00:06:59,760 --> 00:07:03,480
Computers have vast memory, right?

88
00:07:03,480 --> 00:07:07,200
They have memory in the computer.

89
00:07:07,200 --> 00:07:09,280
They can access disks.

90
00:07:09,280 --> 00:07:14,680
They can go on the Internet, servers, farms, and so on.

91
00:07:14,680 --> 00:07:16,960
There's vast amounts of memory.

92
00:07:16,960 --> 00:07:20,920
We humans have tiny memory, right?

93
00:07:20,920 --> 00:07:22,640
Especially the working memory.

94
00:07:22,640 --> 00:07:28,480
I mean, we remember stuff from our childhood and so on, but the working memory is tiny.

95
00:07:28,480 --> 00:07:35,880
We can only keep in our working memory like seven things at a time, right?

96
00:07:35,880 --> 00:07:38,240
Computers are pretty reliable.

97
00:07:38,240 --> 00:07:42,840
I wanted to write reliable, but then I thought, okay, yeah, right.

98
00:07:42,840 --> 00:07:47,920
Computers are made by humans, therefore, they cannot be 100% reliable.

99
00:07:47,920 --> 00:07:54,640
But when you are writing a program and it doesn't work, your first thought is not, oh,

100
00:07:54,640 --> 00:07:57,160
there must be something wrong with the chip, right?

101
00:07:57,160 --> 00:08:01,640
Or the compiler has a bug.

102
00:08:01,640 --> 00:08:05,520
The first thought is, I made a mistake, right?

103
00:08:05,520 --> 00:08:11,480
Only once in a long, long time it happens that the compiler is wrong and very rarely

104
00:08:11,480 --> 00:08:18,120
that the actual CPU is wrong, right?

105
00:08:18,120 --> 00:08:21,760
But we humans are extremely error-prone, right?

106
00:08:21,760 --> 00:08:26,600
And we should admit it, and we shouldn't punish our kids for making errors when they

107
00:08:26,600 --> 00:08:28,960
are doing calculations like these.

108
00:08:28,960 --> 00:08:33,200
This is normal for us to make errors, okay?

109
00:08:33,200 --> 00:08:35,440
Let's accept it.

110
00:08:35,560 --> 00:08:39,960
Computers don't make these errors, and computers should do these things.

111
00:08:39,960 --> 00:08:41,080
We have calculators.

112
00:08:41,080 --> 00:08:44,600
We can calculate all this stuff, right?

113
00:08:44,600 --> 00:08:48,680
We don't need that.

114
00:08:48,680 --> 00:08:51,240
And finally, the language.

115
00:08:51,240 --> 00:08:53,760
There's this language barrier, okay?

116
00:08:53,760 --> 00:08:59,840
And I think, of course, computers understand machine language, right?

117
00:08:59,840 --> 00:09:04,680
And we used to program in machine language in the very, very beginning, you know, switches,

118
00:09:04,720 --> 00:09:06,320
zeros, ones, and so on.

119
00:09:06,320 --> 00:09:10,160
Like, very quickly, we learned we humans are not very good.

120
00:09:10,160 --> 00:09:14,400
Computers don't mind, okay, zeros, ones, great.

121
00:09:14,400 --> 00:09:16,840
But we humans do mind.

122
00:09:16,840 --> 00:09:20,800
It's very difficult for us to program using zeros and ones.

123
00:09:20,800 --> 00:09:25,240
So we come up with higher and higher level languages to program computers.

124
00:09:25,240 --> 00:09:32,480
But ultimately, and that's my main point, is that ultimately the language that's most

125
00:09:32,480 --> 00:09:38,680
human to talk about ideas is the language of mathematics.

126
00:09:38,680 --> 00:09:44,160
And the reasons why we are not constantly using mathematics when we are talking about

127
00:09:44,160 --> 00:09:50,480
programming is because of that, because of this multiplication that they forced on us,

128
00:09:50,480 --> 00:09:55,080
you know, that they taught us mathematics in the wrong way.

129
00:09:55,080 --> 00:09:59,280
And category theory is a branch of mathematics that doesn't look like this.

130
00:09:59,280 --> 00:10:01,400
It looks much nicer.

131
00:10:01,400 --> 00:10:06,600
You know, it doesn't talk about numbers and doesn't talk about making stupid

132
00:10:06,600 --> 00:10:09,160
mistakes and algorithms and so on.

133
00:10:09,160 --> 00:10:11,360
Talks about ideas.

134
00:10:11,360 --> 00:10:19,720
And that's much more human-like than dealing with numbers and bits.

135
00:10:21,720 --> 00:10:27,720
So I think the reason it's sometimes easier for us to think like a machine,

136
00:10:27,720 --> 00:10:33,480
for programmers to think like a machine and then use mathematics is because of this

137
00:10:33,480 --> 00:10:37,560
unfortunate bias.

138
00:10:37,560 --> 00:10:43,320
So when we talk to computers, right, we use computer languages.

139
00:10:43,320 --> 00:10:51,360
And the important thing is when we program, we have to understand the meaning of the program

140
00:10:51,360 --> 00:10:54,880
that we are writing, right, that's called semantics.

141
00:10:54,880 --> 00:11:00,080
So you're programming a language and the language has to have some kind of semantics.

142
00:11:00,080 --> 00:11:08,120
What does it mean to say for n equals 1 and less than n plus plus and so on, right?

143
00:11:08,120 --> 00:11:09,480
What's the semantics of this?

144
00:11:09,480 --> 00:11:15,000
So there are several approaches to defining semantics of languages.

145
00:11:15,000 --> 00:11:22,640
One is this operational semantics when we say, you know, if you are in this state and

146
00:11:22,640 --> 00:11:26,640
you do this, then the next state will be this.

147
00:11:26,640 --> 00:11:30,800
And then if you apply this, then the next state will be this, okay?

148
00:11:30,800 --> 00:11:39,120
I think this kind of operational semantics is very computer-oriented, not human-oriented,

149
00:11:39,120 --> 00:11:41,280
right?

150
00:11:41,280 --> 00:11:46,680
So the other approach is denotational semantics.

151
00:11:46,680 --> 00:11:54,920
In denotational semantics, we say this program has meaning because it can be translated into

152
00:11:54,920 --> 00:11:59,360
another language that we humans understand much better.

153
00:11:59,360 --> 00:12:03,320
And the perfect language for this is the language of mathematics.

154
00:12:03,320 --> 00:12:11,480
So in most cases, denotational semantics means your program actually has a meaning as a piece

155
00:12:11,480 --> 00:12:18,840
of mathematics, like a proof, like a theorem, you know, like an operation in mathematics

156
00:12:18,840 --> 00:12:26,240
or declaration, definition, you know, this, right?

157
00:12:26,240 --> 00:12:33,200
And when we are using operational semantics and we are writing a program, how do we understand

158
00:12:33,200 --> 00:12:35,600
what this program does?

159
00:12:35,600 --> 00:12:43,640
Firstly, we are running this imaginary machine in our minds, and we are going like, this statement

160
00:12:43,640 --> 00:12:48,680
will do this, then this statement will do this, will change these variables, so I have

161
00:12:48,680 --> 00:12:51,480
to keep in mind which variables, right?

162
00:12:51,480 --> 00:12:56,920
I mean, this is, some people are very good at this, and some people are very bad at this.

163
00:12:56,920 --> 00:13:00,960
I am bad at this, okay?

164
00:13:00,960 --> 00:13:08,640
And I have seen people who think more like machines, and they can do very quick programming,

165
00:13:08,640 --> 00:13:19,280
you know, and say, they, but I think ultimately, you know, none of us is as good as a computer,

166
00:13:19,280 --> 00:13:22,560
at that kind of game, right?

167
00:13:22,560 --> 00:13:27,960
We shouldn't try to beat the computer at their games, we should try to, the computer is to

168
00:13:27,960 --> 00:13:32,600
beat us at our games, let's see them compete with us, right?

169
00:13:32,600 --> 00:13:36,480
Not the other way around.

170
00:13:36,480 --> 00:13:41,960
And math is this ancient language, thousands of years, right?

171
00:13:41,960 --> 00:13:48,440
And it was developed long, long before we had computers, it was developed by humans,

172
00:13:48,440 --> 00:13:51,920
for humans to communicate about ideas, right?

173
00:13:51,920 --> 00:14:01,120
It's very important, so you know, we cannot dismiss math so easily as a language.

174
00:14:01,120 --> 00:14:04,560
So let's talk about functional programming.

175
00:14:04,560 --> 00:14:10,280
Functional programming, and I want to like start explaining a little bit of this mathematical

176
00:14:10,280 --> 00:14:12,200
semantics, right?

177
00:14:12,200 --> 00:14:20,480
So in functional programming, we deal with types and functions, right?

178
00:14:20,480 --> 00:14:26,840
And like the simplest mathematical model for a type is that a type is a set of values,

179
00:14:26,840 --> 00:14:28,920
so set theory, okay?

180
00:14:28,920 --> 00:14:34,200
So that's a branch of mathematics that talks about sets, okay?

181
00:14:34,200 --> 00:14:36,760
Fine.

182
00:14:36,760 --> 00:14:44,120
Functions in this model correspond to functions between sets, so it's like, you know, give

183
00:14:44,120 --> 00:14:49,080
me this element of a set, I'll give you that element of a set.

184
00:14:49,080 --> 00:14:56,400
And in this kind of theoretical mathematical view, really, we are not talking about how

185
00:14:56,400 --> 00:15:01,840
the function is evaluated, this is what computers do, they evaluate this function, but we first

186
00:15:01,840 --> 00:15:10,080
concentrate on the definition of a function, like what is actually happening if I give

187
00:15:10,080 --> 00:15:13,840
you this argument, what will you return, right?

188
00:15:13,840 --> 00:15:20,920
In mathematics, we don't really deal with time, like how long will it take to calculate

189
00:15:20,920 --> 00:15:21,920
this value?

190
00:15:21,920 --> 00:15:22,920
It doesn't matter.

191
00:15:22,920 --> 00:15:28,800
First, we have to start by understanding this value corresponds to this value.

192
00:15:28,800 --> 00:15:35,400
So function is just a mapping of values to values, between different types in general,

193
00:15:35,400 --> 00:15:37,560
right?

194
00:15:37,560 --> 00:15:45,400
But this is really, no mathematicians, that's a funny thing, mathematicians also consider

195
00:15:45,400 --> 00:15:51,800
set theory as sort of an assembly language of mathematics.

196
00:15:51,800 --> 00:15:55,200
Mathematics also has these levels of abstraction, right?

197
00:15:55,200 --> 00:15:57,880
Building higher and higher levels of abstraction.

198
00:15:57,880 --> 00:16:05,800
And set theory turns out to be this really low-level assembly language of mathematics.

199
00:16:05,800 --> 00:16:13,080
And mathematicians recently started, tried to avoid using set theory so much as they

200
00:16:13,080 --> 00:16:21,080
used to, like there are new branches of mathematics, like homotopy type theory and category theory,

201
00:16:21,080 --> 00:16:26,480
that try to avoid using the assembly language, so even they are going a little bit higher.

202
00:16:26,480 --> 00:16:35,180
So I think we could also go a little bit higher and think of program semantics in terms of

203
00:16:35,180 --> 00:16:37,980
category theory rather than sets.

204
00:16:37,980 --> 00:16:43,980
And sets form a category that's fine, you know, and sort of like a lot of our intuitions

205
00:16:43,980 --> 00:16:48,500
about category comes from set theory.

206
00:16:48,500 --> 00:16:54,820
So for most purposes, like we think about an example in set theory and we sort of try

207
00:16:54,820 --> 00:17:02,880
to recast it into categorical terms for programming, okay?

208
00:17:02,880 --> 00:17:09,160
So in a categorical view, category theory simplifies these things tremendously because

209
00:17:09,160 --> 00:17:16,080
it says there are only two things, objects and morphisms or arrows between objects.

210
00:17:16,080 --> 00:17:17,080
That's it.

211
00:17:17,080 --> 00:17:27,040
And it doesn't even specify what these objects are, what these arrows are.

212
00:17:28,040 --> 00:17:35,880
The mapping between category theory and programming is just this, functions that we use in programming,

213
00:17:35,880 --> 00:17:41,800
so here function meaning what we program, right, in a language.

214
00:17:41,800 --> 00:17:48,800
These are the arrows between objects and the objects are types, like you have integer type,

215
00:17:48,800 --> 00:17:54,840
you know, tree type, list type, whatever type you are using, okay?

216
00:17:54,840 --> 00:17:57,480
These are your objects.

217
00:17:57,480 --> 00:18:07,080
But the important difference between the set theoretical view and categorical view is that

218
00:18:07,080 --> 00:18:10,200
it's a change of perspective.

219
00:18:10,200 --> 00:18:17,680
In set theoretical view, you define properties of sets by talking about elements of sets,

220
00:18:17,680 --> 00:18:18,880
okay?

221
00:18:18,880 --> 00:18:24,040
In categorical view, you shrink the whole set to a point.

222
00:18:24,040 --> 00:18:28,200
You say, I cannot look at the structure of the set.

223
00:18:28,200 --> 00:18:29,360
It's forbidden.

224
00:18:29,360 --> 00:18:34,120
So it's like, you know, in functional programming, there are certain things that are forbidden,

225
00:18:34,120 --> 00:18:35,120
right?

226
00:18:35,120 --> 00:18:39,160
Like you are not supposed to modify a variable, right?

227
00:18:39,160 --> 00:18:43,280
And that forces us to change perspective, right?

228
00:18:43,280 --> 00:18:48,480
We come up with these persistent data structures and so on, right?

229
00:18:48,480 --> 00:18:51,240
Because we are forbidden to do certain things.

230
00:18:51,240 --> 00:18:56,640
So if you switch this perspective that you are forbidden to talk about elements of sets

231
00:18:56,640 --> 00:19:03,200
or talking about values, you know, then suddenly you have to rethink everything and say, so

232
00:19:03,200 --> 00:19:07,000
how do I describe different kinds of sets?

233
00:19:07,000 --> 00:19:12,440
You describe them by their interaction with other sets, which in category theory means

234
00:19:12,880 --> 00:19:15,160
arrows.

235
00:19:15,160 --> 00:19:24,520
So you can describe the properties of objects by talking about arrows, the arrows that are

236
00:19:24,520 --> 00:19:31,960
incoming into these objects and the arrows that are outgoing from these objects, okay?

237
00:19:31,960 --> 00:19:34,720
And that's a very interesting way of looking at things.

238
00:19:34,720 --> 00:19:40,720
It's like, tell me who your friends are and I'll tell you who you are, right, exactly

239
00:19:40,720 --> 00:19:41,720
this way.

240
00:19:41,720 --> 00:19:46,320
Instead of interviewing you, I'm just interviewing your friends and I can learn much more about

241
00:19:46,320 --> 00:19:49,240
you, right?

242
00:19:49,240 --> 00:19:54,840
But in principle, we just want to be able to express the same things we can express using

243
00:19:54,840 --> 00:20:01,180
elements of sets as we can do with arrows, okay?

244
00:20:01,180 --> 00:20:06,760
So this is like a very quick recap of the definition of a category.

245
00:20:06,760 --> 00:20:12,520
You've heard it several times and Daniela talked about what the category is.

246
00:20:12,520 --> 00:20:20,360
So objects and arrows and in parentheses, I say, what's your model for this?

247
00:20:20,360 --> 00:20:24,760
Like, oh, let's think about types and functions in programming, right?

248
00:20:24,760 --> 00:20:29,960
But categories are all kinds of different categories, right?

249
00:20:29,960 --> 00:20:32,520
But that's the one important for us.

250
00:20:32,520 --> 00:20:38,000
I'll talk about another category that's not exactly types and functions later, the

251
00:20:38,000 --> 00:20:41,440
functor category.

252
00:20:41,440 --> 00:20:45,040
The most important thing about arrows is that they compose.

253
00:20:45,040 --> 00:20:47,880
This is why category theory is all about composition.

254
00:20:47,880 --> 00:20:54,400
There's nothing more in category theory but this composition, if two arrows match end

255
00:20:54,400 --> 00:21:02,500
to end from A to B and B to C, then you can go from A to C. That's it, right?

256
00:21:03,500 --> 00:21:05,100
And we want these properties.

257
00:21:05,100 --> 00:21:07,580
We want the associativity of composition.

258
00:21:07,580 --> 00:21:14,220
So composition here is this little circle that's how mathematicians know they did.

259
00:21:14,220 --> 00:21:22,780
In Haskell, it's a dot and I guess in Scala, it's compose, right?

260
00:21:22,780 --> 00:21:24,500
And there has to be an identity.

261
00:21:24,500 --> 00:21:31,300
Every object has to have an arrow that goes from the object back to itself.

262
00:21:31,300 --> 00:21:37,700
It's sort of, you can say this is an arrow that does nothing, but you cannot say it does

263
00:21:37,700 --> 00:21:44,940
nothing because an arrow doesn't do anything to an object because objects don't have structure.

264
00:21:44,940 --> 00:21:47,900
They are just these points, right?

265
00:21:47,900 --> 00:21:56,380
So doing nothing that doesn't even make sense, but you can say that if you compose it with

266
00:21:56,380 --> 00:22:00,820
something else, then it does nothing to composition.

267
00:22:00,820 --> 00:22:05,100
So you compose ID with F, you get back F.

268
00:22:05,100 --> 00:22:08,100
You compose F with ID, you get back F.

269
00:22:08,100 --> 00:22:12,140
So composing with ID doesn't change anything.

270
00:22:12,140 --> 00:22:15,500
Okay, so now let's get to work, okay?

271
00:22:15,500 --> 00:22:24,100
We want to define some very simple things that we know from set theory or from type theory,

272
00:22:24,100 --> 00:22:28,940
from programming, some data types, okay?

273
00:22:28,940 --> 00:22:32,060
Using purely categorical language.

274
00:22:32,060 --> 00:22:36,060
So the first data type is void.

275
00:22:36,060 --> 00:22:42,620
This is not a type that you would use normally every day.

276
00:22:42,620 --> 00:22:44,700
It corresponds to an empty set.

277
00:22:44,700 --> 00:22:48,620
So what kind of type it is?

278
00:22:48,620 --> 00:22:53,180
There's not much that you can do with it, right?

279
00:22:53,180 --> 00:22:57,460
But it's interesting as like a boundary case, right?

280
00:22:57,460 --> 00:23:05,380
So from point-of-view set theory, we are describing an empty set, no elements, okay?

281
00:23:05,380 --> 00:23:09,540
But in category theory, since we cannot talk about the elements, we don't know what it

282
00:23:09,540 --> 00:23:12,400
means no elements, right?

283
00:23:12,400 --> 00:23:15,060
We don't know what elements are.

284
00:23:15,060 --> 00:23:18,860
So we have to define it using arrows.

285
00:23:18,860 --> 00:23:27,420
And defining something using arrows in category theory means saying something universal, meaning

286
00:23:28,420 --> 00:23:34,940
you have to tell me about the relationship of this object with the rest of the universe,

287
00:23:34,940 --> 00:23:38,660
with every other object in the category.

288
00:23:38,660 --> 00:23:43,700
Mathematicians are not afraid of infinities, you know, it's like you have infinitely many

289
00:23:43,700 --> 00:23:46,660
types, possible types, right?

290
00:23:46,660 --> 00:23:51,380
We are talking not only about the types that you use from day to day in programming, we

291
00:23:51,380 --> 00:23:57,860
are talking about all possible types that you can invent and describe, right?

292
00:23:57,860 --> 00:24:03,980
Lists, cues, trees, whatever, right?

293
00:24:03,980 --> 00:24:05,140
All these types.

294
00:24:05,140 --> 00:24:11,780
So there is this universal property, and in category theory, the object that has this

295
00:24:11,780 --> 00:24:14,780
property is called the initial object in a category.

296
00:24:14,780 --> 00:24:17,620
Not every category has an initial object.

297
00:24:17,620 --> 00:24:22,060
category of sets has an initial object, which is an empty set, okay?

298
00:24:22,060 --> 00:24:32,060
And the universal property of this object is that it has an arrow going to every single

299
00:24:32,060 --> 00:24:35,500
other object in the category.

300
00:24:35,500 --> 00:24:39,980
Moreover, there is only one such arrow for every object.

301
00:24:39,980 --> 00:24:44,060
So like you pick one object, this one, okay?

302
00:24:44,060 --> 00:24:48,940
There has to be a single arrow going from my initial object to this object.

303
00:24:48,940 --> 00:24:57,740
Not two arrows, not three arrows, not zero arrows, one, okay?

304
00:24:57,740 --> 00:25:09,340
And this is a translation to Scala that was done by a friend of mine.

305
00:25:09,340 --> 00:25:13,420
I wrote it in a Haskell and it translated.

306
00:25:13,420 --> 00:25:23,860
So when we are defining data types in these categorical terms, it's usually a definition

307
00:25:23,860 --> 00:25:29,780
consists of two parts, because we have to say about the arrows that are coming into

308
00:25:29,780 --> 00:25:35,220
the object and something about the arrows that are outgoing from this object.

309
00:25:35,220 --> 00:25:40,740
So the arrows that are coming to an object, we call them constructors, right?

310
00:25:41,100 --> 00:25:47,820
It's like you take some type or a bunch of types and you construct my object, right?

311
00:25:47,820 --> 00:25:49,900
So these arrows are functions, right?

312
00:25:49,900 --> 00:25:55,260
So you have a function that takes a bunch of objects and produces my object.

313
00:25:55,260 --> 00:25:56,660
That's a constructor.

314
00:25:56,660 --> 00:26:04,060
So incoming arrows are constructors and in mathematics it's called introduction rule.

315
00:26:04,060 --> 00:26:07,700
Introduction rule corresponds to what we say a constructor, right?

316
00:26:07,700 --> 00:26:13,060
So there is no possibility of constructing an empty set.

317
00:26:13,060 --> 00:26:14,060
What does it mean?

318
00:26:14,060 --> 00:26:15,900
What does it mean to construct an empty set?

319
00:26:15,900 --> 00:26:24,660
It means to write a function that would return an element of an empty set, okay?

320
00:26:24,660 --> 00:26:29,900
In set theoretical, there's no way you can write a function that would return an element

321
00:26:29,900 --> 00:26:33,340
of an empty set, because an empty set has no elements, right?

322
00:26:33,340 --> 00:26:40,780
So there is no introduction for type void.

323
00:26:40,780 --> 00:26:47,900
The other, the outgoing arrows, okay, this is called the elimination, okay?

324
00:26:47,900 --> 00:26:55,140
So like if you give me an object of type void, what can I do with it?

325
00:26:55,140 --> 00:27:05,180
Eliminate the object, well, in a sense by transforming it into something else, right?

326
00:27:05,180 --> 00:27:11,340
So I need to know what kind of arrows are outgoing from this object.

327
00:27:11,340 --> 00:27:19,260
And for the initial object, you know, all we know is that there is a single arrow to

328
00:27:19,260 --> 00:27:21,220
any other object.

329
00:27:21,220 --> 00:27:24,660
So this is what you would say in Scala.

330
00:27:24,660 --> 00:27:31,460
There is a unique function for every type A, there's a function called absurd.

331
00:27:31,460 --> 00:27:33,220
So it's a polymorphic function, right?

332
00:27:33,220 --> 00:27:34,820
Because it works for any type.

333
00:27:34,820 --> 00:27:40,860
It's a polymorphic function, absurd, that takes a void and produces an A.

334
00:27:40,860 --> 00:27:42,940
How does it do it?

335
00:27:42,940 --> 00:27:47,540
Well, don't ask me how it does it.

336
00:27:47,540 --> 00:27:52,740
Just give me an element of void and I'll give you an element of A, okay?

337
00:27:53,740 --> 00:27:58,740
So that's a kind of tricky thing, yes?

338
00:27:58,740 --> 00:28:01,740
So the question, what do you think about including self?

339
00:28:01,740 --> 00:28:06,740
So if void doesn't have a structure, including self?

340
00:28:06,740 --> 00:28:18,620
Oh, oh, including self, it means every object in a category theory has to have the identity

341
00:28:18,620 --> 00:28:21,100
arrow, including this one.

342
00:28:21,100 --> 00:28:23,140
So it has an identity arrow.

343
00:28:23,140 --> 00:28:28,620
An identity arrow is an example of a function that takes a void and returns a void, okay?

344
00:28:28,620 --> 00:28:35,300
Well, so this is like, yeah, I mean, if you give me a void, I'll return you a void.

345
00:28:35,300 --> 00:28:37,700
And I can even implement this function.

346
00:28:37,700 --> 00:28:40,900
Here's an element of void, I'm returning it back to you.

347
00:28:40,900 --> 00:28:41,900
Yes?

348
00:28:41,900 --> 00:28:45,180
If it doesn't have inbound arrows.

349
00:28:45,180 --> 00:28:50,380
I didn't say it doesn't have inbound arrows.

350
00:28:50,380 --> 00:28:51,380
I didn't say that.

351
00:28:51,380 --> 00:28:53,660
I said it has a unique outgoing arrow.

352
00:28:53,660 --> 00:28:55,660
It didn't say anything about inbound arrows.

353
00:28:55,660 --> 00:29:01,020
If you make an absolute, is it a strategy for a method that don't take an item of that

354
00:29:01,020 --> 00:29:02,020
rule?

355
00:29:02,020 --> 00:29:03,020
No.

356
00:29:03,020 --> 00:29:04,020
Is it a strategy?

357
00:29:04,020 --> 00:29:05,020
No.

358
00:29:05,020 --> 00:29:06,020
Is it a strategy?

359
00:29:06,020 --> 00:29:07,020
No.

360
00:29:07,020 --> 00:29:08,020
Is it a strategy?

361
00:29:08,020 --> 00:29:09,020
No.

362
00:29:09,020 --> 00:29:10,020
Is it a strategy or not?

363
00:29:10,020 --> 00:29:11,020
No.

364
00:29:11,020 --> 00:29:12,020
Is it a strategy?

365
00:29:12,020 --> 00:29:19,860
Well, it's, I mean, from the point of view of mathematics, right, like if you try to

366
00:29:19,860 --> 00:29:22,260
do it in set theory, okay?

367
00:29:22,260 --> 00:29:28,220
So how many functions are there from an empty set to another set?

368
00:29:28,220 --> 00:29:31,100
There's only one, okay?

369
00:29:31,100 --> 00:29:36,380
It doesn't matter what it does, right?

370
00:29:36,380 --> 00:29:40,460
Because you can never call it, okay?

371
00:29:40,460 --> 00:29:48,260
I mean, it's a typical mathematical thinking, but there's an interesting thing about this,

372
00:29:48,260 --> 00:29:57,140
because there is a one-to-one correspondence between category theory and logic and type

373
00:29:57,140 --> 00:29:58,300
theory.

374
00:29:58,300 --> 00:30:06,060
So, logically, this corresponds to the statement that from falsehood, void corresponds to

375
00:30:06,060 --> 00:30:09,420
falsehood in logic, okay?

376
00:30:09,420 --> 00:30:15,260
So from falsehood, you can derive anything, right?

377
00:30:15,260 --> 00:30:21,260
This is why this function is called absurd, okay?

378
00:30:21,260 --> 00:30:22,260
Next one.

379
00:30:22,260 --> 00:30:24,420
Next one is a little bit more useful.

380
00:30:24,420 --> 00:30:26,660
It's called unit, okay?

381
00:30:26,660 --> 00:30:28,500
The type is called unit.

382
00:30:28,500 --> 00:30:38,180
In set theory, this corresponds to a singleton set, a set that has only one element, okay?

383
00:30:38,180 --> 00:30:41,540
So this is type unit, also in scalar, right?

384
00:30:41,540 --> 00:30:43,260
There is a type unit.

385
00:30:43,260 --> 00:30:48,140
And it has a single element, I don't know, is that what you call this element?

386
00:30:48,140 --> 00:30:49,140
Yeah?

387
00:30:49,140 --> 00:30:52,580
Okay, okay, just like in Haskell.

388
00:30:52,580 --> 00:30:56,980
In Haskell, this type also is called bracket, bracket, right?

389
00:30:56,980 --> 00:31:01,540
So this is like the opposite of the initial object.

390
00:31:01,540 --> 00:31:03,460
It's called a terminal object.

391
00:31:03,460 --> 00:31:06,300
And by opposite, I mean, it's dual.

392
00:31:06,300 --> 00:31:11,660
So actually, in category theory, you have this duality, like whatever definition you

393
00:31:11,660 --> 00:31:16,740
come up with, you can just invert all the arrows and you get something else for free.

394
00:31:16,740 --> 00:31:21,780
So here we are just inverting the arrows and we're saying, okay, the universal property

395
00:31:21,780 --> 00:31:28,260
of a terminal object is that there is a unique arrow from any type to it, okay?

396
00:31:28,260 --> 00:31:32,740
From any object, from any type.

397
00:31:32,740 --> 00:31:37,540
So now this guy will have an introduction rule, right?

398
00:31:37,540 --> 00:31:44,060
Which says that for any type, a, you can produce a unit.

399
00:31:44,060 --> 00:31:47,100
How is this function implemented?

400
00:31:47,100 --> 00:31:49,540
It just ignores the input, right?

401
00:31:49,540 --> 00:31:54,300
And just returns this unit because it can always produce the unit.

402
00:31:54,300 --> 00:32:01,100
The element of the singleton set called the unit, right?

403
00:32:01,100 --> 00:32:02,740
So this is very easy to implement.

404
00:32:02,740 --> 00:32:06,260
It's like, we cannot implement all these functions, right?

405
00:32:06,260 --> 00:32:07,740
That's great.

406
00:32:07,740 --> 00:32:09,580
The elimination rule.

407
00:32:09,580 --> 00:32:14,580
And here we can clearly see that, you know, I'm talking about incoming arrows.

408
00:32:14,580 --> 00:32:17,660
It doesn't mean that there are no outgoing arrows.

409
00:32:17,660 --> 00:32:22,500
In fact, there are lots of outgoing arrows from it.

410
00:32:22,500 --> 00:32:28,780
The elimination rule is that if you have a unit, you can have a function to any other

411
00:32:28,780 --> 00:32:29,780
type.

412
00:32:29,780 --> 00:32:35,020
In fact, you have many functions depending on the type.

413
00:32:35,020 --> 00:32:39,500
What does a function from a unit to a type do?

414
00:32:39,500 --> 00:32:43,420
It picks one element from this type, right?

415
00:32:43,420 --> 00:32:50,660
So if you give me a unit, I can define a function to integer that returns 7.

416
00:32:50,660 --> 00:32:56,140
I can define another function from a unit to integer that returns 42.

417
00:32:56,140 --> 00:32:58,000
And so on, right?

418
00:32:58,000 --> 00:33:03,040
So this is actually a pretty useful thing because we are not supposed to talk about

419
00:33:03,040 --> 00:33:04,800
elements.

420
00:33:04,800 --> 00:33:13,720
But if we want to pick an element from a type, we can always cheat and say, okay, I cannot

421
00:33:13,720 --> 00:33:14,720
pick an element.

422
00:33:14,720 --> 00:33:20,560
But I can say that there is a morphism or arrow from unit to this, okay?

423
00:33:20,560 --> 00:33:24,600
So instead of picking element, you pick a morphism.

424
00:33:24,600 --> 00:33:28,760
Form is the same as arrow, okay?

425
00:33:28,760 --> 00:33:33,960
Now for something really interesting, product.

426
00:33:33,960 --> 00:33:39,280
So product, in set theory, this is just Cartesian product or a set of pairs.

427
00:33:39,280 --> 00:33:46,960
So you have two types, right, and you produce a pair type from these two types, right?

428
00:33:46,960 --> 00:33:54,840
So the universal construction for this thing is kind of interesting because, like, what

429
00:33:54,840 --> 00:33:59,680
is the property in terms of arrows of a product?

430
00:33:59,680 --> 00:34:06,760
The only thing we can say that there have to be two arrows from a product, one going

431
00:34:06,760 --> 00:34:12,480
to the type A and one going to type B, if you have a product of A and B, right?

432
00:34:12,480 --> 00:34:14,560
These are called projections, right?

433
00:34:15,040 --> 00:34:21,080
Like, if you have a pair of integer and bull, then you can project an integer.

434
00:34:21,080 --> 00:34:25,560
And I think this function called underscore one in Scala, yeah?

435
00:34:25,560 --> 00:34:26,440
Okay?

436
00:34:26,440 --> 00:34:29,000
Good translation, and there's underscore two.

437
00:34:31,880 --> 00:34:40,600
So we know, but what else can we say about a product that would identify it from many,

438
00:34:40,600 --> 00:34:45,320
many other possible objects in the universe, right?

439
00:34:45,320 --> 00:34:49,480
Well, so we say, okay, well, let's try some other object.

440
00:34:49,480 --> 00:34:52,320
Let's say C, okay?

441
00:34:52,320 --> 00:34:55,640
Suppose that C has these two projections also.

442
00:34:55,640 --> 00:35:01,080
So we know that the candidate for a product has to have these two projections, right?

443
00:35:01,080 --> 00:35:05,120
And the only thing we know about these projections is that there are arrows.

444
00:35:05,120 --> 00:35:10,040
So there is an arrow F to A and there's an arrow G to B, okay?

445
00:35:11,600 --> 00:35:18,320
So out of all these candidates, we can pick the best one.

446
00:35:18,320 --> 00:35:24,360
So look at all possible candidates, all possible types that have a projection on A and B.

447
00:35:25,880 --> 00:35:27,120
Pick the best one.

448
00:35:27,120 --> 00:35:29,160
How do we pick the best one?

449
00:35:29,160 --> 00:35:34,120
Okay, the best one is the one that for any other type,

450
00:35:34,120 --> 00:35:40,120
there's a unique arrow going to this type, okay?

451
00:35:41,160 --> 00:35:46,680
So like, for instance, you come up with a candidate that say,

452
00:35:48,480 --> 00:35:52,440
a triple A, B, and C, okay?

453
00:35:53,720 --> 00:35:59,120
Let's say, well, the pair A, B is better than triple A, B, C.

454
00:35:59,120 --> 00:35:59,920
Why?

455
00:35:59,920 --> 00:36:08,400
Because there is a unique function H that just picks the pair from the triple, right?

456
00:36:08,400 --> 00:36:10,640
Just discard C and picks A, B.

457
00:36:12,140 --> 00:36:17,840
And this function has this property that we can express in terms of composability

458
00:36:17,840 --> 00:36:23,360
that this arrow composed with this arrow gives me this arrow.

459
00:36:23,360 --> 00:36:26,400
And this arrow composed with this arrow gives me this arrow.

460
00:36:27,400 --> 00:36:31,200
So if I go through H and then project the first component,

461
00:36:31,200 --> 00:36:32,800
it's the same as going through F.

462
00:36:33,800 --> 00:36:37,720
So, this is a universal property.

463
00:36:37,720 --> 00:36:42,400
From all the objects, I picked the best one that has this property

464
00:36:42,400 --> 00:36:46,520
that any other is decomposable into it, okay?

465
00:36:47,560 --> 00:36:51,880
And this might seem like really a crazy way of defining things,

466
00:36:51,880 --> 00:36:55,960
because like, how would you write a program to do this?

467
00:36:55,960 --> 00:37:08,160
Well, let me write a big loop in which I go over all possible types in my type system, right?

468
00:37:09,040 --> 00:37:10,200
It's crazy, right?

469
00:37:10,200 --> 00:37:12,040
There are infinitely many of them.

470
00:37:12,040 --> 00:37:18,960
And then for each of these types, see if I have arrows going to A and B, right?

471
00:37:18,960 --> 00:37:24,680
And then from all these, see if I have a unigarrow going to A, B.

472
00:37:24,680 --> 00:37:28,720
And if this is true, then I had my product.

473
00:37:28,720 --> 00:37:34,720
If it's not true, then I try a different candidate, and so on forever, you know?

474
00:37:34,720 --> 00:37:36,800
But there is no time in mathematics.

475
00:37:38,000 --> 00:37:43,160
Yeah, I think I'm not even going to get through half of my presentation.

476
00:37:48,160 --> 00:37:54,640
Okay, so here it is written, you know, F is from C to A, G is from C to B.

477
00:37:55,360 --> 00:38:00,840
And H can be defined, you know, like as programmers, we can define this H, you know,

478
00:38:00,840 --> 00:38:03,520
F acting on C paired with G acting on C.

479
00:38:04,280 --> 00:38:07,280
That's the solution of this problem, right?

480
00:38:08,120 --> 00:38:13,680
And of course, I have to say what is the introduction and what is the elimination?

481
00:38:13,680 --> 00:38:20,720
The introduction, you have to have, in order to produce a pair, you have to have A,

482
00:38:20,720 --> 00:38:24,160
and you have to have an element of A, and you have to have an element of B.

483
00:38:24,160 --> 00:38:28,960
You need both of them to create a pair, right?

484
00:38:28,960 --> 00:38:32,560
So that's the constructor of a pair, very simple.

485
00:38:33,840 --> 00:38:40,800
The elimination rule is these two arrows from A to B.

486
00:38:40,800 --> 00:38:44,080
So if you give me a pair, what can I do with a pair?

487
00:38:44,080 --> 00:38:50,800
Well, I can project it, I can extract the first part of the second part, that's all I can do.

488
00:38:50,840 --> 00:38:54,960
And then I can do with this stuff more, you know, more interesting things.

489
00:38:54,960 --> 00:38:56,840
But I always start by projecting.

490
00:38:58,840 --> 00:39:02,680
And this defines all the product types.

491
00:39:02,680 --> 00:39:08,400
This is why they are called product types, because they come from a product.

492
00:39:08,400 --> 00:39:14,320
Things like pairs, tuples, records, and so on, right?

493
00:39:16,280 --> 00:39:20,000
And of course, there is a dual to it, a sum type, okay?

494
00:39:20,000 --> 00:39:22,640
Now you will understand why these things are called sum types.

495
00:39:22,640 --> 00:39:25,800
They are called also a coproduct.

496
00:39:25,800 --> 00:39:30,840
In categories here, they are called a coproduct, because they are dual to a product.

497
00:39:30,840 --> 00:39:38,440
And it's just the same picture, but I took the upside down and reversed all the arrows, okay?

498
00:39:38,440 --> 00:39:45,240
So a sum type, an example is either A and B, okay?

499
00:39:45,240 --> 00:39:49,320
That's like the simplest sum type of two types.

500
00:39:52,920 --> 00:39:58,040
Instead of having these projections, it has injections left and right.

501
00:39:58,040 --> 00:40:02,560
So left takes A and produces either A and B, right?

502
00:40:02,560 --> 00:40:06,760
It doesn't need a B, it's enough that it has an A.

503
00:40:06,760 --> 00:40:11,480
Or if you have B, you can produce either an A, B, and you don't need A, right?

504
00:40:11,480 --> 00:40:13,440
So there are two ways of constructing it.

505
00:40:16,240 --> 00:40:24,640
Now again, universal construction says either A and B is like the best of these guys that have these two injections.

506
00:40:24,640 --> 00:40:34,160
Anything else that has these two injections will factorize through some unique H, okay?

507
00:40:34,160 --> 00:40:43,760
So here's the factorization, like how can you define H, you know, from the type either A, B.

508
00:40:43,800 --> 00:40:47,120
If you have these two injections, F and G.

509
00:40:47,120 --> 00:40:51,920
So F and G here are these two injections, right?

510
00:40:51,920 --> 00:41:02,720
Right, these, and here I'm defining H from either A, B to my type C, right?

511
00:41:02,720 --> 00:41:05,400
And I just do case analysis.

512
00:41:05,400 --> 00:41:08,920
If it's left, then F, A, if it's right, then G, B.

513
00:41:08,920 --> 00:41:10,440
And I got it.

514
00:41:14,000 --> 00:41:14,600
Right?

515
00:41:16,480 --> 00:41:26,720
And introduction, I can introduce the type either A and B if I have A or if I have B.

516
00:41:26,720 --> 00:41:29,120
There are two ways of introducing it.

517
00:41:29,120 --> 00:41:35,280
The elimination is just by pattern matching, left, right.

518
00:41:35,280 --> 00:41:40,800
And this is, in programming, it's usually called tagged unions, right?

519
00:41:40,880 --> 00:41:44,560
In Scala, you have different name for it.

520
00:41:44,560 --> 00:41:47,480
But you use the term some types, right?

521
00:41:47,480 --> 00:41:49,080
So this is where they come from.

522
00:41:49,080 --> 00:41:51,800
They come from some types, okay?

523
00:41:56,280 --> 00:41:59,280
Monoidal category, wonderful thing, huh?

524
00:42:01,480 --> 00:42:02,560
Very simple.

525
00:42:02,560 --> 00:42:06,520
So actually, I told you already everything about this monoidal category.

526
00:42:06,520 --> 00:42:10,640
I told you it's a category in which you have both products.

527
00:42:10,640 --> 00:42:13,760
For every two elements, you can create a product.

528
00:42:13,760 --> 00:42:17,960
And for every two elements, you can create a sum type, okay?

529
00:42:17,960 --> 00:42:20,760
So why is it called monoidal?

530
00:42:20,760 --> 00:42:23,880
Okay, let me explain why it's called monoidal.

531
00:42:23,880 --> 00:42:30,480
Because this product kinda looks like multiplication.

532
00:42:30,480 --> 00:42:37,040
A monoid is something that has this multiplication, essentially, or addition.

533
00:42:37,040 --> 00:42:43,480
It's like a simple arithmetic, you know?

534
00:42:43,480 --> 00:42:51,320
So it has this operation that operates on two things and produces one thing, right?

535
00:42:51,320 --> 00:42:55,960
So this is a monoid in types.

536
00:42:55,960 --> 00:43:04,080
So given two types, I can multiply them by creating a product type, right?

537
00:43:04,080 --> 00:43:06,400
A pair type.

538
00:43:06,400 --> 00:43:08,440
So that's my multiplication.

539
00:43:08,440 --> 00:43:14,040
Now, in order for this to be a monoid, it has to be associative.

540
00:43:14,040 --> 00:43:18,240
So like if I have three types, right, I can pair them differently.

541
00:43:18,240 --> 00:43:23,000
I can pair B with C and then pair it with A.

542
00:43:23,040 --> 00:43:26,240
Or I can pair A and B and then pair it with C.

543
00:43:26,240 --> 00:43:32,840
This is not exactly the same type, like the type checker would reject this in a program.

544
00:43:32,840 --> 00:43:35,760
However, these two types are isomorphic.

545
00:43:35,760 --> 00:43:39,640
Meaning there is a function that takes this type to this type and

546
00:43:39,640 --> 00:43:42,560
there's an inverse function that takes this type to this type.

547
00:43:42,560 --> 00:43:44,400
It just rearranges stuff.

548
00:43:44,400 --> 00:43:46,720
That's very simple.

549
00:43:46,720 --> 00:43:50,640
So up to isomorphism, this is associative.

550
00:43:51,600 --> 00:43:55,800
And the other thing that the monoid has to have is this has to have this unit.

551
00:43:55,800 --> 00:44:00,920
Something that if you multiply by unit, you don't change anything, right?

552
00:44:00,920 --> 00:44:07,080
And the unit in case of these types is the unit type, actually.

553
00:44:07,080 --> 00:44:09,880
So this is why it's called unit type, right?

554
00:44:09,880 --> 00:44:15,760
Because if you take a pair of unit and A, it is equivalent to A.

555
00:44:15,840 --> 00:44:21,200
You're not adding any more information to A by pairing it with a unit, right?

556
00:44:21,200 --> 00:44:25,200
It's like a redundant thing, okay?

557
00:44:25,200 --> 00:44:27,120
Also up to isomorphism.

558
00:44:27,120 --> 00:44:29,920
So this is why it's called a monoid.

559
00:44:29,920 --> 00:44:33,560
So we have a monoidal category at our disposal.

560
00:44:33,560 --> 00:44:40,720
And also, the either, the coproduct, the some types also form a separate monoid.

561
00:44:41,680 --> 00:44:47,520
Here's the associativity for either, and here's the unit.

562
00:44:47,520 --> 00:44:51,560
The unit for either, and this is where Void comes back, right?

563
00:44:51,560 --> 00:44:54,400
This type Void is a unit.

564
00:44:54,400 --> 00:45:00,080
Because if you take either Void or A, it definitely contains A.

565
00:45:00,080 --> 00:45:01,360
Why do I know this?

566
00:45:03,120 --> 00:45:05,840
Because try to create, you know, from Void.

567
00:45:07,600 --> 00:45:10,360
Void has no element, so it will never be called.

568
00:45:10,920 --> 00:45:15,680
So this one injection just doesn't exist.

569
00:45:15,680 --> 00:45:19,560
The injection that would inject a Void to it sometime.

570
00:45:19,560 --> 00:45:21,280
So it always has to have an A.

571
00:45:21,280 --> 00:45:26,360
The only way you can construct this by providing an A, and you can extract this A.

572
00:45:26,360 --> 00:45:31,560
So it's isomorphic.

573
00:45:31,680 --> 00:45:40,640
So this is why we have this beautiful algebra of types.

574
00:45:40,640 --> 00:45:43,680
Okay, we have a monoid with respect to product.

575
00:45:43,680 --> 00:45:45,880
We have a monoid with respect to some.

576
00:45:47,160 --> 00:45:51,000
They actually interact together very nicely.

577
00:45:51,000 --> 00:45:58,680
So we have like a, you know, bi-cartesian monoidal category.

578
00:45:58,680 --> 00:46:03,120
It's something like this beautiful name that mathematicians give it.

579
00:46:03,120 --> 00:46:06,240
But this is really what we need for programming.

580
00:46:06,240 --> 00:46:10,160
We need a monoidal category because we have to have some types and

581
00:46:10,160 --> 00:46:13,040
we have to have product types, right?

582
00:46:13,040 --> 00:46:15,120
We also have to have function types.

583
00:46:15,120 --> 00:46:17,440
And that would be like the second part of my talk.

584
00:46:17,440 --> 00:46:20,520
And I think I'm just gonna stop here because.

585
00:46:20,520 --> 00:46:38,920
Is there enough tape, is there enough tape for the diaper?

586
00:46:38,920 --> 00:46:42,320
So how about if we make like a one minute break so

587
00:46:42,320 --> 00:46:47,680
that people who don't want to listen can leave and I will not be watching, okay?

588
00:46:50,520 --> 00:47:05,120
Okay, so here's the way we can use this algebra of types to create.

589
00:47:05,120 --> 00:47:12,040
Essentially, from this point on, we can create all types with just these tools.

590
00:47:12,040 --> 00:47:15,360
Okay, this will be kind of awkward.

591
00:47:15,360 --> 00:47:18,680
For instance, the type Boolean, right?

592
00:47:18,680 --> 00:47:20,600
It's nice to have a Boolean type.

593
00:47:20,600 --> 00:47:23,920
A Boolean type is just either unit or unit.

594
00:47:25,200 --> 00:47:29,600
It means you can create it as a left thing or a right thing.

595
00:47:29,600 --> 00:47:34,040
And it has no other information other than whether it's left or right.

596
00:47:34,040 --> 00:47:39,280
And we call the left thing true, for instance, and the right thing false.

597
00:47:39,280 --> 00:47:41,000
That's it, the sum type.

598
00:47:41,000 --> 00:47:43,800
It can either be true or false, right?

599
00:47:43,800 --> 00:47:48,840
So here's the sealed, straight, bull, okay.

600
00:47:48,840 --> 00:47:54,720
So this is how you do sum types in Scala, right?

601
00:47:56,120 --> 00:48:02,160
Type natural, you would have to do infinitely many.

602
00:48:02,160 --> 00:48:13,640
But type natural number is either one or two or three or four and so on.

603
00:48:13,640 --> 00:48:16,040
So it is a sum type.

604
00:48:16,040 --> 00:48:21,080
So essentially having sum types, and if you apply it infinitely many times,

605
00:48:21,080 --> 00:48:24,120
you'll get natural numbers.

606
00:48:24,120 --> 00:48:25,920
Okay, this is a very awkward definition.

607
00:48:25,920 --> 00:48:28,720
There are better definitions than that, right?

608
00:48:28,720 --> 00:48:33,280
But just to show you the idea, the option type, right?

609
00:48:33,280 --> 00:48:37,880
The maybe type, the option type, a little bit more interesting.

610
00:48:37,880 --> 00:48:42,760
It's a sum type, it's either of unit and A.

611
00:48:42,760 --> 00:48:48,080
So it is a polymorphic type, parametrized type by some type A, right?

612
00:48:48,080 --> 00:48:53,440
So you can either construct by providing unit, which you can always do.

613
00:48:53,440 --> 00:48:58,560
And that's the nothing part in Haskell.

614
00:48:58,560 --> 00:49:00,040
What do you call it in Scala?

615
00:49:00,040 --> 00:49:05,080
None, none, okay, so none, that corresponds to none.

616
00:49:05,080 --> 00:49:10,560
And this corresponds to what you call sum, okay, none, sum.

617
00:49:10,560 --> 00:49:15,760
Nothing just in Haskell, same thing, right?

618
00:49:15,760 --> 00:49:20,480
Then you can go into recursive types, you can define a list.

619
00:49:20,480 --> 00:49:23,080
List is a sum of two things.

620
00:49:23,080 --> 00:49:29,400
Unit here, that signifies empty list.

621
00:49:29,400 --> 00:49:32,600
You can construct an empty list, right, always, right?

622
00:49:32,600 --> 00:49:37,440
And contains no information, so you can construct it from unit.

623
00:49:37,440 --> 00:49:43,080
You always have at your disposal, because the units are just everywhere.

624
00:49:43,080 --> 00:49:49,840
You just pull them from the air, and you create a list using unit, and

625
00:49:49,840 --> 00:49:51,840
that's an empty list.

626
00:49:51,840 --> 00:49:57,840
Or you can create it from a product here, right?

627
00:49:57,840 --> 00:50:02,280
Of A, which will serve as the head of the list.

628
00:50:02,280 --> 00:50:06,960
And the whole other list, which is the tail of the list, right?

629
00:50:06,960 --> 00:50:14,360
So here we have a sum and a product together, and it's recursive, right?

630
00:50:14,360 --> 00:50:17,520
And this is how you could express it, okay?

631
00:50:18,960 --> 00:50:22,880
So this is like the skeleton of a whole type system.

632
00:50:22,880 --> 00:50:26,760
Everything else is just syntactic sugar on top of this.

633
00:50:26,760 --> 00:50:30,120
That's very interesting to know, right?

634
00:50:31,040 --> 00:50:37,640
Okay, so now you've heard the word functor so many times today, right?

635
00:50:37,640 --> 00:50:39,520
And yesterday.

636
00:50:39,520 --> 00:50:44,240
Okay, so let me just introduce the functor categorically.

637
00:50:46,760 --> 00:50:50,480
So in general, the functor is a mapping between categories.

638
00:50:50,480 --> 00:50:55,760
So mathematicians are always interested in how things that have

639
00:50:55,760 --> 00:51:02,440
a certain structure relate to another thing that has a similar structure, right?

640
00:51:02,440 --> 00:51:09,080
And a functor, in this case, takes one category and

641
00:51:09,080 --> 00:51:13,080
embeds its structure into another category.

642
00:51:14,600 --> 00:51:17,120
So it's a mapping from category to category.

643
00:51:17,120 --> 00:51:21,720
So if it's mapping a category, and the category is nothing else but objects and

644
00:51:21,720 --> 00:51:26,800
arrows, so naturally it has to map objects and arrows.

645
00:51:28,160 --> 00:51:32,400
So it maps objects to objects and arrows to arrows, right?

646
00:51:32,400 --> 00:51:37,360
And because it has to preserve the structure, what does it mean structure?

647
00:51:37,360 --> 00:51:41,560
It means that if you have an object A and an object B, okay?

648
00:51:41,560 --> 00:51:47,160
So A goes into F A, that's an object F A, this is an object F B, right?

649
00:51:47,160 --> 00:51:53,000
If there is an arrow between A and B, then this arrow has to be mapped into

650
00:51:53,000 --> 00:51:55,000
another arrow, right?

651
00:51:55,000 --> 00:51:59,160
But it cannot be an arbitrary arrow anywhere else, right?

652
00:51:59,160 --> 00:52:04,880
It better be an arrow that connects F of A to F of B, right?

653
00:52:04,880 --> 00:52:09,760
Because if these things are connected in this category,

654
00:52:09,760 --> 00:52:14,120
they must be connected in this category as well, okay?

655
00:52:14,120 --> 00:52:20,640
The factor may do things like collapse two objects into one.

656
00:52:20,640 --> 00:52:24,280
It can collapse multiple arrows into one and so on.

657
00:52:24,280 --> 00:52:28,600
But as long as you have a connection in one category, it will preserve this connection.

658
00:52:28,600 --> 00:52:32,240
And it will also preserve the unit arrows, and

659
00:52:32,240 --> 00:52:35,040
it will preserve the composition of arrows, okay?

660
00:52:36,680 --> 00:52:40,880
So how does this translate into programming?

661
00:52:41,120 --> 00:52:46,040
So first of all, in mathematics, the most general functor goes from one category

662
00:52:46,040 --> 00:52:47,160
to another category.

663
00:52:49,160 --> 00:52:53,760
In programming, most of the functors will go from the same category to the same

664
00:52:53,760 --> 00:52:56,680
category, they are called endo functors.

665
00:52:56,680 --> 00:53:00,920
Endo means inside, like endoscopy, you know.

666
00:53:00,920 --> 00:53:10,680
Yeah, so we have a functor that goes within the category.

667
00:53:10,680 --> 00:53:18,240
So it takes a type A and maps it into a type list of A, okay?

668
00:53:18,240 --> 00:53:22,880
So it takes a type integer, maps it into a list of integer.

669
00:53:22,880 --> 00:53:26,960
It's mapping between types, this is a very important thing.

670
00:53:26,960 --> 00:53:28,960
Many people get confused because of this.

671
00:53:28,960 --> 00:53:34,120
It's not mapping of elements of these sets, it just maps the whole set into the whole set.

672
00:53:34,120 --> 00:53:39,920
It's like, say, here's an integer set, or integer type,

673
00:53:39,920 --> 00:53:44,680
maps it into a list of integer type, type to type.

674
00:53:44,680 --> 00:53:46,320
Like a parametric type, right?

675
00:53:46,320 --> 00:53:48,480
A type constructor, right?

676
00:53:48,480 --> 00:53:50,000
Okay, so type constructor.

677
00:53:53,840 --> 00:54:01,600
So the type constructor part of it is that this F with a bracket in Scala, right?

678
00:54:01,600 --> 00:54:03,000
So that's a type constructor.

679
00:54:03,000 --> 00:54:06,520
It takes a type and produces a type F of A.

680
00:54:06,520 --> 00:54:08,560
Takes A, produces F of A.

681
00:54:08,560 --> 00:54:13,000
So this is the part of acting on objects, the blue arrows.

682
00:54:13,000 --> 00:54:19,440
And we have to separately define how it acts on arrows.

683
00:54:19,440 --> 00:54:23,680
So it takes an arrow F, that's this arrow F.

684
00:54:23,680 --> 00:54:25,960
This arrow goes from A to B, right?

685
00:54:25,960 --> 00:54:27,880
From A to B, okay?

686
00:54:27,880 --> 00:54:37,520
And maps it into an arrow that takes F of A, this guy, and returns F of B, this guy, okay?

687
00:54:37,520 --> 00:54:41,800
So if you draw a picture, this is really very simple, right?

688
00:54:41,800 --> 00:54:45,320
So it takes this arrow and maps it into this arrow.

689
00:54:45,320 --> 00:54:47,240
And you have to provide this function.

690
00:54:47,240 --> 00:54:51,920
For every function, you have to provide part of the definition of a function is how does

691
00:54:51,920 --> 00:54:55,440
it act on arrows, right?

692
00:54:55,440 --> 00:54:59,760
Maybe there are sometimes factors that have different actions on arrows,

693
00:54:59,760 --> 00:55:05,920
the same action on an object, but differ by acting on arrows, okay?

694
00:55:05,920 --> 00:55:10,440
So I guess this is, okay, I think you guys call it map, not F map.

695
00:55:10,440 --> 00:55:17,720
Haskell calls it F map, for historical reasons, really, no, no.

696
00:55:17,720 --> 00:55:20,960
So this is how it acts on lists, right?

697
00:55:20,960 --> 00:55:22,120
But you've seen this before.

698
00:55:23,120 --> 00:55:27,840
So why am I talking about functors?

699
00:55:27,840 --> 00:55:31,360
And now I have to introduce adjunctions between functors.

700
00:55:31,360 --> 00:55:39,840
I have to introduce adjunctions between functors because there is one extremely important example

701
00:55:39,840 --> 00:55:47,520
of an adjunction that's very useful in programming, especially functional programming.

702
00:55:47,520 --> 00:55:57,800
And so little motivation, right?

703
00:55:57,800 --> 00:55:59,000
You know what types are.

704
00:55:59,000 --> 00:56:01,040
So I told you about all these types.

705
00:56:01,040 --> 00:56:03,440
They are objects.

706
00:56:03,440 --> 00:56:06,800
Separately, I said we have arrows.

707
00:56:06,800 --> 00:56:09,680
They correspond to functions, okay?

708
00:56:09,680 --> 00:56:20,680
But you know that, like when I say F from A to B, I mean a type of a function, right?

709
00:56:20,680 --> 00:56:23,280
A type of a function.

710
00:56:23,280 --> 00:56:29,640
But we said types are objects, and this is an arrow, right?

711
00:56:29,640 --> 00:56:32,560
So how is this connected?

712
00:56:32,560 --> 00:56:41,040
So you have to have an object inside the category of types that corresponds to the set of arrows

713
00:56:41,040 --> 00:56:43,080
between objects A and B.

714
00:56:43,080 --> 00:56:51,040
So for every pair of objects A and B, there is a set of arrows between them, but there

715
00:56:51,040 --> 00:57:01,160
has to be also an object, separate objects, that represents the set of arrows, right?

716
00:57:01,160 --> 00:57:06,800
And that's called the type of function, function type.

717
00:57:06,800 --> 00:57:12,960
Not every category will have this, but the category that we are interested in, in which

718
00:57:12,960 --> 00:57:19,120
we can program, must have this object for every pair of A and B, okay?

719
00:57:19,120 --> 00:57:25,840
And you know, this object can be introduced by another universal construction, I'll show

720
00:57:25,840 --> 00:57:26,840
you in a moment.

721
00:57:26,840 --> 00:57:33,040
The easiest way of introducing it is through an adjunction of two functors, in particular

722
00:57:33,040 --> 00:57:36,200
two endo functors that we are interested.

723
00:57:36,200 --> 00:57:41,720
So an adjunction is not one functor, but a pair of functor.

724
00:57:41,720 --> 00:57:46,440
One functor adjoins to the other functor, okay?

725
00:57:46,440 --> 00:57:51,720
So one functor goes from one category, from this category to this category, and there's

726
00:57:51,720 --> 00:57:56,280
another functor going this way, okay?

727
00:57:57,280 --> 00:58:02,040
If you have two functors going in the opposite directions, you might say, okay, like if one

728
00:58:02,040 --> 00:58:07,320
is the inverse of another, that means that these two categories look the same, right?

729
00:58:07,320 --> 00:58:10,160
There is like an isomorphism of categories.

730
00:58:10,160 --> 00:58:18,240
But it's much more interesting if these are not inverses of each other, but they act in

731
00:58:18,240 --> 00:58:24,680
a very interesting way on arrows, okay?

732
00:58:26,880 --> 00:58:39,800
So we say that the functor f is left adjoined to the functor u, if you draw the set of arrows

733
00:58:39,800 --> 00:58:49,280
from fA to B and the set of arrows from A to UB, they are isomorphic.

734
00:58:49,280 --> 00:58:56,080
Having isomorphic set of arrows tells us about how these two objects are related, right?

735
00:58:56,080 --> 00:58:58,920
They are related in a particular way.

736
00:58:58,920 --> 00:59:05,400
If they have the same set of arrows going between them, right, it means that their relationship

737
00:59:05,400 --> 00:59:07,360
is very similar.

738
00:59:07,360 --> 00:59:13,520
And you can think of this as like you are preparing an argument for a function, you know, using

739
00:59:13,520 --> 00:59:23,360
functor f, and here you are modifying the output of a function by applying functor u.

740
00:59:23,360 --> 00:59:30,160
So if you prepare arguments to functions, or you modify the output of functions, you

741
00:59:30,160 --> 00:59:37,640
get this isomorphism between these two, okay?

742
00:59:37,640 --> 00:59:46,000
And when you hear this first time, it's really like kind of weird, like why is this so interesting?

743
00:59:46,000 --> 00:59:49,680
So I'll give you one example, and there are many, many interesting examples, but I'll

744
00:59:49,680 --> 00:59:55,400
give you one example that like pops out immediately.

745
00:59:55,400 --> 01:00:05,600
So let's pick the functor f acting on A, it pairs it with C, okay?

746
01:00:05,600 --> 01:00:12,400
So I take the type A and I pair it with C, I get a pair type.

747
01:00:12,400 --> 01:00:14,400
So that's one functor.

748
01:00:14,400 --> 01:00:27,080
The other functor is acting on B, it creates a type of function from C to B, okay?

749
01:00:27,080 --> 01:00:28,080
Nothing yet, right?

750
01:00:28,080 --> 01:00:33,240
It's like, oh, okay, all right, all right.

751
01:00:33,240 --> 01:00:36,360
Now let me write this isomorphism between these.

752
01:00:36,360 --> 01:00:45,440
So like if I prepare my argument by pairing it with C, okay, and I have a function on

753
01:00:45,440 --> 01:00:56,280
arrow from A, C to B, this is equivalent isomorphic to all these functions that take A without

754
01:00:56,280 --> 01:01:06,320
any preparation, but modify the argument B by putting this as an output of a function

755
01:01:06,320 --> 01:01:10,520
that takes C, okay?

756
01:01:10,520 --> 01:01:16,720
Now if you look at it, this is called curring, right?

757
01:01:16,720 --> 01:01:24,080
Curring, a function that takes a pair is equivalent to a function that takes one element and returns

758
01:01:24,080 --> 01:01:28,680
another function that takes the second one, okay?

759
01:01:28,680 --> 01:01:37,120
So this is how curring arises from an adjunction, right?

760
01:01:37,120 --> 01:01:41,760
This is this adjunction, oh, this is a general adjunction, right?

761
01:01:41,760 --> 01:01:44,840
This is this particular adjunction.

762
01:01:44,840 --> 01:01:52,800
And in category theory, this function type, this C to B, because you can take this as a

763
01:01:52,800 --> 01:01:59,280
definition of the function object, because this is a type of functions from C to B. You

764
01:01:59,280 --> 01:02:10,080
can say this, if you have in your category pairing or product, then you may, if you have

765
01:02:10,080 --> 01:02:18,000
this adjunction, you will be able to define what it means to have a function type, right?

766
01:02:18,000 --> 01:02:21,800
And the category in which this is defined is called closed.

767
01:02:21,800 --> 01:02:28,080
So taking together, we have a Cartesian closed category.

768
01:02:28,080 --> 01:02:33,360
Cartesian because it has a Cartesian product, closed because it has a function type.

769
01:02:33,360 --> 01:02:38,920
And we are operating a Cartesian closed category when we are doing programming, right?

770
01:02:38,920 --> 01:02:44,400
So next time somebody tells you about Cartesian closed categories, you know, oh, yeah, this

771
01:02:44,400 --> 01:02:48,240
is what we use in our everyday programming.

772
01:02:48,240 --> 01:02:54,040
This is what, yeah, this is our bread and butter.

773
01:02:54,040 --> 01:02:59,680
In mathematics, this is called an exponential, A to B. Function type from B to A is called

774
01:02:59,680 --> 01:03:06,640
A to the power of B. And it actually, I'm not going to go into it, but actually, like

775
01:03:06,640 --> 01:03:13,520
if you look at it as an exponential and combine it with multiplication being product type,

776
01:03:13,520 --> 01:03:21,920
sum type using either and exponential, you can like write all these identities from high

777
01:03:21,920 --> 01:03:29,080
school like A plus B to the power of C is A to the power of B plus and so on.

778
01:03:29,080 --> 01:03:36,280
All these identities actually work on types, which is, on one level, it's a weird thing,

779
01:03:36,280 --> 01:03:37,280
right?

780
01:03:37,360 --> 01:03:45,520
Another level, you see the repetition of the same patterns in mathematics all the time.

781
01:03:45,520 --> 01:03:51,560
And that's an interesting thing to think about, you know, free time.

782
01:03:51,560 --> 01:03:54,000
So I'll show you just this diagram.

783
01:03:54,000 --> 01:03:58,320
Function types can be defined using universal construction, right?

784
01:03:58,320 --> 01:04:03,440
This is like the diagram that, it's a little more complicated than defining a product, but

785
01:04:03,440 --> 01:04:06,140
it can be done, okay?

786
01:04:06,140 --> 01:04:09,740
And of course we can say, what's the introduction and elimination?

787
01:04:09,740 --> 01:04:14,740
The introduction of function is called lambda, okay?

788
01:04:14,740 --> 01:04:21,460
So if you have an object of type A and you have an expression of type B, then lambda

789
01:04:21,460 --> 01:04:28,380
X E of X is of the type A to B, okay?

790
01:04:28,380 --> 01:04:31,780
And elimination is called eval.

791
01:04:31,780 --> 01:04:38,460
So you eliminate a function by providing an argument and getting the result.

792
01:04:38,460 --> 01:04:48,380
Okay, so I'll have to speed up now.

793
01:04:48,380 --> 01:04:51,820
Natural transformations are extremely important.

794
01:04:51,820 --> 01:04:56,060
We know them as polymorphic functions, okay?

795
01:04:56,060 --> 01:05:01,980
In category theory, they are just mappings between functors.

796
01:05:01,980 --> 01:05:13,260
So if you have two functors, F and G, you pick an object A and you map it to F A and

797
01:05:13,260 --> 01:05:15,660
you can map it to G A.

798
01:05:15,660 --> 01:05:23,020
A natural transformation is when you pick these arrows, for every F A G A, you pick one arrow.

799
01:05:23,020 --> 01:05:27,620
So you pick a function that depends on A, right?

800
01:05:27,620 --> 01:05:30,660
You keep changing A, you get different functions.

801
01:05:30,660 --> 01:05:32,660
So it's a polymorphic function.

802
01:05:32,660 --> 01:05:39,860
It's a polymorphic function whose argument is a factorial and whose result is factorial.

803
01:05:39,860 --> 01:05:42,060
So here's an example of something like this.

804
01:05:42,060 --> 01:05:49,660
You take a list and you produce an option, right?

805
01:05:49,660 --> 01:05:51,260
Did I rewrite it?

806
01:05:51,260 --> 01:05:59,260
Yeah, this is, yeah, okay, non-sum, okay, yeah, yeah.

807
01:05:59,260 --> 01:06:04,740
It returns an option, right?

808
01:06:04,740 --> 01:06:07,340
Why is it important to have natural transformations?

809
01:06:07,340 --> 01:06:14,180
Because now I can say, and this is like a typical thing in category theory, okay, I have

810
01:06:14,180 --> 01:06:24,860
functors and I have natural transformations which transform one function to another, okay.

811
01:06:24,860 --> 01:06:28,100
Are these arrows between functors?

812
01:06:28,100 --> 01:06:30,940
Maybe I have a category, right?

813
01:06:30,940 --> 01:06:36,940
Like what if functors are objects and natural transformations would be arrows between these

814
01:06:36,940 --> 01:06:40,260
objects, okay.

815
01:06:40,260 --> 01:06:41,580
What do I have to show?

816
01:06:41,580 --> 01:06:47,020
I have to show, if I want to have a category, I would have to show that there is a composition

817
01:06:47,020 --> 01:06:53,380
and of course there is a composition of these arrows because if I have another functor H,

818
01:06:53,380 --> 01:06:58,420
you know, I'll just compose these two and I get a third one, right?

819
01:06:58,420 --> 01:07:09,900
There is an identity and of course there is associativity, right?

820
01:07:09,900 --> 01:07:13,660
An identity, so that works fine, right?

821
01:07:13,660 --> 01:07:23,540
So I can construct something called a functor category in which objects are functors and

822
01:07:23,540 --> 01:07:25,780
arrows are natural transformations.

823
01:07:25,780 --> 01:07:33,420
So this is an example of a category that's not slightly different than what we were talking

824
01:07:33,420 --> 01:07:35,620
about before, right?

825
01:07:35,620 --> 01:07:40,860
But it is a very important category, a functor category.

826
01:07:40,860 --> 01:07:46,100
Now in our case we talk about endofunctors and endofunctors also being functors form

827
01:07:46,100 --> 01:07:48,260
a category, right?

828
01:07:48,260 --> 01:07:55,060
So they form a category, it's called, that's how mathematicians write it, it's a category

829
01:07:55,060 --> 01:08:01,740
of functors from C to C, okay?

830
01:08:01,740 --> 01:08:08,620
So the final minute, the yoneta embedding, okay?

831
01:08:08,620 --> 01:08:11,920
The yoneta embedding.

832
01:08:11,920 --> 01:08:19,020
So this is the kind of thinking that can break your brain a little bit, right?

833
01:08:19,020 --> 01:08:25,260
But it shows you the power of categories here, this is like, because there is this notion

834
01:08:25,260 --> 01:08:34,660
that we have replaced contents of objects, we replace it with arrows.

835
01:08:34,660 --> 01:08:45,820
Like we say, everything we can say about the object can be said using arrows, right?

836
01:08:45,820 --> 01:08:52,860
Objects shrunk to a point and everything, all its properties are expressed using arrows.

837
01:08:52,860 --> 01:08:59,820
So the next step would be to say, well, instead of talking about an object, why don't I talk

838
01:08:59,820 --> 01:09:06,860
about all the arrows that are, let's say, impinging on this object, okay?

839
01:09:06,860 --> 01:09:18,220
Like if I take the totality of arrows in my category that end in this object, do they

840
01:09:18,220 --> 01:09:26,300
contain exactly the same information as the object itself, right?

841
01:09:26,300 --> 01:09:30,820
Can I replace this object by just talking about the totality of arrows that come to

842
01:09:30,820 --> 01:09:33,180
this object?

843
01:09:33,180 --> 01:09:39,540
And the answer is yes, and it's called the yoneta embedding, okay?

844
01:09:39,540 --> 01:09:43,100
So let me go through, like, steps, right?

845
01:09:43,100 --> 01:09:48,700
So first of all, how do I even define the totality of arrows coming to an object?

846
01:09:48,700 --> 01:09:56,260
Well, I'll start with a, so I'm talking about object A, that's my object, okay?

847
01:09:56,260 --> 01:10:04,780
Let me pick another object X and have a totality of arrows from X to A to begin with.

848
01:10:04,780 --> 01:10:06,420
I have to start somewhere, right?

849
01:10:06,420 --> 01:10:07,780
So let me take these arrows.

850
01:10:07,780 --> 01:10:10,780
What do they, they form a set.

851
01:10:10,780 --> 01:10:20,380
They form a set of arrows, set of arrows from X to A, okay?

852
01:10:20,380 --> 01:10:22,260
But this is just one X.

853
01:10:22,260 --> 01:10:27,340
If I want to talk about totality of arrows that go to A, I have to vary X.

854
01:10:27,340 --> 01:10:32,380
I have to, like, go to every possible X in my category, right?

855
01:10:32,380 --> 01:10:38,060
So if I start varying X, then I get different sets here.

856
01:10:38,060 --> 01:10:45,260
So this is for X, you know, I pick Y, there will be from Y to A, and so on.

857
01:10:45,260 --> 01:10:54,580
So I end up with something that's like a mapping of X, when I vary X, to sets.

858
01:10:54,580 --> 01:10:58,020
Sets are objects in the category of set, okay?

859
01:10:58,020 --> 01:11:08,420
So I have a mapping that goes from X to X to A for a fixed A.

860
01:11:08,420 --> 01:11:13,940
And this mapping, I define this mapping for objects, for Xs, right?

861
01:11:13,940 --> 01:11:20,020
This mapping can be extended also to arrows, which means that it's really a functor.

862
01:11:20,020 --> 01:11:27,100
This is a functor, if you vary X, it's called a contraviant functor, because it acts weirdly

863
01:11:27,100 --> 01:11:29,980
on arrows, like the opposite of the arrows.

864
01:11:29,980 --> 01:11:40,180
But it's a functor, and it's a functor from this category C to the category set, okay?

865
01:11:40,180 --> 01:11:51,260
So now, for every object A, I get a functor from C to set, okay?

866
01:11:51,260 --> 01:11:52,900
Keep this in mind.

867
01:11:52,900 --> 01:12:03,500
From every A, I have a functor from C to set, it just takes an X and puts it into XA.

868
01:12:03,500 --> 01:12:10,300
So now if I start varying A on top of this, okay?

869
01:12:10,300 --> 01:12:21,580
Then I have a mapping that takes an A and creates a functor from C to set, okay?

870
01:12:21,580 --> 01:12:26,780
So this is the functor category from C to set.

871
01:12:26,780 --> 01:12:32,300
Here's my X, here's my A, I'm varying A to B, okay?

872
01:12:32,300 --> 01:12:38,140
So for every object A, I have a functor, right?

873
01:12:38,140 --> 01:12:41,700
That takes these arrows and puts it here, right?

874
01:12:41,700 --> 01:12:49,860
So I have a mapping that embeds an object from category C into the functor category.

875
01:12:49,860 --> 01:12:58,900
And now if I have a mapping of objects from one category C to another category, which

876
01:12:58,900 --> 01:13:04,300
is a functor category, is this mapping a functor?

877
01:13:04,300 --> 01:13:09,740
Turns out this mapping is a functor too, okay?

878
01:13:09,740 --> 01:13:18,460
And moreover, it's action on arrows, so here's an arrow from A to B, it's action of arrows,

879
01:13:19,020 --> 01:13:24,020
well, so it's action on arrows would have to be a natural transformation because arrows

880
01:13:24,020 --> 01:13:27,060
in this category are natural transformations.

881
01:13:27,060 --> 01:13:31,980
So there's a mapping from these arrows to these arrows.

882
01:13:31,980 --> 01:13:36,820
These are just functions, these are natural transformations, right?

883
01:13:36,820 --> 01:13:44,860
So this is a function from A to B, it's mapped into this natural transformation from this

884
01:13:44,900 --> 01:13:49,420
functor to this functor, okay?

885
01:13:49,420 --> 01:13:57,780
When I vary X, this is a functor, okay?

886
01:13:57,780 --> 01:14:03,100
And the Yoneda Lemma says this mapping goes both ways.

887
01:14:03,100 --> 01:14:11,260
It's actually an isomorphism, which means that this whole category C can be embedded

888
01:14:11,380 --> 01:14:20,380
in the category of functors, which is called a fully faithful embedding, meaning it takes

889
01:14:20,380 --> 01:14:25,780
all arrows and nothing more than maps them to all two arrows here.

890
01:14:25,780 --> 01:14:31,820
So if you map A to this functor, B to this functor, all arrows from A to B go into natural

891
01:14:31,820 --> 01:14:36,460
transformations from this functor to this functor, and nothing more is there.

892
01:14:36,460 --> 01:14:42,500
So you can take all natural transformations, they will correspond to arrows here, right?

893
01:14:42,500 --> 01:14:49,500
So you have a perfect picture of this whole category embedded in this category of functors,

894
01:14:49,500 --> 01:14:51,060
okay?

895
01:14:51,060 --> 01:14:53,060
And I think this is a good point to end.

896
01:14:53,060 --> 01:15:00,060
Thank you.

