WEBVTT

00:00.000 --> 00:11.200
So many people are interested in category theory.

00:11.200 --> 00:12.760
This is a new thing.

00:12.760 --> 00:22.240
A few years ago, nobody wanted to listen about category theory, and now it seems like it's

00:22.240 --> 00:26.000
a very hot topic, lots of talks.

00:26.000 --> 00:32.880
And people are mentioning categorical terms in all the talks, I listened to several talks

00:32.880 --> 00:45.040
and it was like functors, monads, applicatives, all this beautiful stuff from category theory.

00:45.040 --> 00:51.400
And also a lot of people, when they talk about data structures, they say, okay, things like

00:51.400 --> 00:57.640
algebraic data structures, some types, product types, and so on, all this stuff has roots

00:57.640 --> 00:59.600
in category theory.

00:59.600 --> 01:03.320
So I want to talk about these things as well today.

01:03.320 --> 01:09.160
This is just an intro to category theory, so I won't cover a lot.

01:09.160 --> 01:12.800
Here's the plan for the talk.

01:12.800 --> 01:20.040
I'll talk a little bit about categorical semantics, about semantics of programming languages in

01:20.040 --> 01:22.480
very generic terms.

01:22.480 --> 01:27.200
And of course I'll talk about composability, because composability is what category theory

01:27.200 --> 01:29.680
is about.

01:29.680 --> 01:32.440
Then I'll talk a little bit about algebraic data types.

01:32.440 --> 01:38.280
I feel quite a bit about algebraic data types, come to think of it, because it's like a very

01:38.280 --> 01:41.320
important part.

01:41.320 --> 01:45.480
Then I'll talk about function types, because we're at a functional conference, functional

01:45.480 --> 01:48.000
programming conference, right?

01:48.000 --> 01:54.600
So function types and currying, and finally I want to end up with a Yoneda lemma, which

01:54.600 --> 02:05.240
is like the central theorem in category theory.

02:05.240 --> 02:13.520
So well, let me start immediately, because we don't have that much time.

02:13.520 --> 02:18.640
So I want to motivate you a little bit, right?

02:18.640 --> 02:23.520
And I have lots of motivations why category theory is important, and so on.

02:23.520 --> 02:30.400
But I think the real reason why I got into category theory is because it's fun.

02:30.400 --> 02:34.120
It's interesting, and it's mind-expanding.

02:34.120 --> 02:42.400
So if you are looking for reasons to study category theory, maybe you should just like

02:42.400 --> 02:46.000
enjoy it.

02:46.000 --> 02:52.760
I know that category theory is a branch of mathematics, and a lot of people have some

02:52.760 --> 02:58.200
preconceptions about what mathematics is, and a lot of people don't like mathematics,

02:58.200 --> 03:10.560
because they were, starting with primary school, we are taught not to like mathematics.

03:10.560 --> 03:16.080
And here I give an example of the things that we teach our kids in schools.

03:16.080 --> 03:19.360
This is like multiplying two numbers.

03:19.360 --> 03:20.920
This is a horrible thing.

03:20.920 --> 03:25.320
This is like mind-breaking for humans, okay?

03:25.320 --> 03:33.800
There is this huge discrepancy between, or impedance mismatches, like between human

03:33.800 --> 03:37.640
mind and computers, okay?

03:37.640 --> 03:40.880
And there are two ways of bridging this gap.

03:40.880 --> 03:48.360
One is we insist on being humans and just ask the computers to come up to our level.

03:48.360 --> 03:53.600
The other is to lower ourselves to the level of computers, and I think this is wrong.

03:53.600 --> 03:56.840
So this is an example of multiplication, right?

03:56.840 --> 04:04.240
We teach our kids to do this, and it has all the elements at which computers are very good

04:04.240 --> 04:07.080
and humans are very bad, okay?

04:07.080 --> 04:12.160
The only thing that's important here is that there is an algorithm behind it, right?

04:12.160 --> 04:15.880
But we don't even tell the kids that there is an algorithm.

04:15.880 --> 04:19.440
We just tell them, here are instructions.

04:19.440 --> 04:24.440
Perform these instructions one after another, okay?

04:24.440 --> 04:31.040
And this is the moment where we are teaching kids imperative programming, and they are spoiled

04:31.040 --> 04:32.040
for life.

04:32.040 --> 04:38.360
And then we have to take years and years to un-teach them, you know, functional programming

04:38.360 --> 04:42.440
is like the declarative way of saying things.

04:42.440 --> 04:48.360
That's much more human, but we are so used to this kind of thinking, the imperative thinking

04:48.360 --> 04:54.080
from the very beginning, that it's very hard to break these things.

04:54.080 --> 05:04.200
So here I match things that we are good at versus what the computers are good at.

05:04.200 --> 05:08.480
Computers are very kind of local thinking, right?

05:08.480 --> 05:11.160
They look at the next instruction.

05:11.160 --> 05:18.480
They are not, they don't have this global perspective that humans have, right?

05:18.480 --> 05:24.520
When we start programming, right, we think about the problem that we are trying to solve.

05:24.520 --> 05:31.080
We have this global view, like where does this problem fit into the, you know, bigger

05:31.080 --> 05:39.120
picture of, we want our company to make money, for instance, you know, goals that we have,

05:39.120 --> 05:40.120
and so on.

05:40.120 --> 05:45.920
So we have this global view, and then we kind of descend to the nitty-gritty eventually,

05:45.920 --> 05:47.080
right?

05:47.080 --> 05:51.400
Computers are just nitty-gritty from the very beginning and all the time, right?

05:51.400 --> 05:55.160
They look at the particular instruction.

05:55.160 --> 05:58.440
Computers are progress-oriented.

05:58.440 --> 05:59.640
They just want to make progress.

05:59.640 --> 06:05.120
They just want to go from one instruction to the next instruction, one line of code

06:05.120 --> 06:07.640
to another line of code, and so on.

06:07.640 --> 06:13.600
They are not interested in what's happening, it's just locally and making progress.

06:13.600 --> 06:14.600
That's important.

06:14.880 --> 06:17.240
Whereas we are goal-oriented.

06:17.240 --> 06:20.400
We know why we are doing this, right?

06:20.400 --> 06:21.560
We have a goal.

06:21.560 --> 06:27.120
We want to calculate some value, or we want to draw something, we want to animate some

06:27.120 --> 06:29.760
pictures, you know, all this stuff.

06:29.760 --> 06:31.520
That's our goal.

06:31.520 --> 06:37.160
Making progress for the sake of progress makes no sense for us, right?

06:37.160 --> 06:38.800
For a computer, there is no goal.

06:38.800 --> 06:42.280
It's just making progress.

06:42.280 --> 06:48.480
Computers are very detail-oriented, whereas we operate with ideas.

06:48.480 --> 06:49.800
We have these abstractions.

06:49.800 --> 06:50.800
We have ideas.

06:50.800 --> 06:59.760
We try to convey these ideas to the computer so that it can be executed in some way.

06:59.760 --> 07:03.480
Computers have vast memory, right?

07:03.480 --> 07:07.200
They have memory in the computer.

07:07.200 --> 07:09.280
They can access disks.

07:09.280 --> 07:14.680
They can go on the Internet, servers, farms, and so on.

07:14.680 --> 07:16.960
There's vast amounts of memory.

07:16.960 --> 07:20.920
We humans have tiny memory, right?

07:20.920 --> 07:22.640
Especially the working memory.

07:22.640 --> 07:28.480
I mean, we remember stuff from our childhood and so on, but the working memory is tiny.

07:28.480 --> 07:35.880
We can only keep in our working memory like seven things at a time, right?

07:35.880 --> 07:38.240
Computers are pretty reliable.

07:38.240 --> 07:42.840
I wanted to write reliable, but then I thought, okay, yeah, right.

07:42.840 --> 07:47.920
Computers are made by humans, therefore, they cannot be 100% reliable.

07:47.920 --> 07:54.640
But when you are writing a program and it doesn't work, your first thought is not, oh,

07:54.640 --> 07:57.160
there must be something wrong with the chip, right?

07:57.160 --> 08:01.640
Or the compiler has a bug.

08:01.640 --> 08:05.520
The first thought is, I made a mistake, right?

08:05.520 --> 08:11.480
Only once in a long, long time it happens that the compiler is wrong and very rarely

08:11.480 --> 08:18.120
that the actual CPU is wrong, right?

08:18.120 --> 08:21.760
But we humans are extremely error-prone, right?

08:21.760 --> 08:26.600
And we should admit it, and we shouldn't punish our kids for making errors when they

08:26.600 --> 08:28.960
are doing calculations like these.

08:28.960 --> 08:33.200
This is normal for us to make errors, okay?

08:33.200 --> 08:35.440
Let's accept it.

08:35.560 --> 08:39.960
Computers don't make these errors, and computers should do these things.

08:39.960 --> 08:41.080
We have calculators.

08:41.080 --> 08:44.600
We can calculate all this stuff, right?

08:44.600 --> 08:48.680
We don't need that.

08:48.680 --> 08:51.240
And finally, the language.

08:51.240 --> 08:53.760
There's this language barrier, okay?

08:53.760 --> 08:59.840
And I think, of course, computers understand machine language, right?

08:59.840 --> 09:04.680
And we used to program in machine language in the very, very beginning, you know, switches,

09:04.720 --> 09:06.320
zeros, ones, and so on.

09:06.320 --> 09:10.160
Like, very quickly, we learned we humans are not very good.

09:10.160 --> 09:14.400
Computers don't mind, okay, zeros, ones, great.

09:14.400 --> 09:16.840
But we humans do mind.

09:16.840 --> 09:20.800
It's very difficult for us to program using zeros and ones.

09:20.800 --> 09:25.240
So we come up with higher and higher level languages to program computers.

09:25.240 --> 09:32.480
But ultimately, and that's my main point, is that ultimately the language that's most

09:32.480 --> 09:38.680
human to talk about ideas is the language of mathematics.

09:38.680 --> 09:44.160
And the reasons why we are not constantly using mathematics when we are talking about

09:44.160 --> 09:50.480
programming is because of that, because of this multiplication that they forced on us,

09:50.480 --> 09:55.080
you know, that they taught us mathematics in the wrong way.

09:55.080 --> 09:59.280
And category theory is a branch of mathematics that doesn't look like this.

09:59.280 --> 10:01.400
It looks much nicer.

10:01.400 --> 10:06.600
You know, it doesn't talk about numbers and doesn't talk about making stupid

10:06.600 --> 10:09.160
mistakes and algorithms and so on.

10:09.160 --> 10:11.360
Talks about ideas.

10:11.360 --> 10:19.720
And that's much more human-like than dealing with numbers and bits.

10:21.720 --> 10:27.720
So I think the reason it's sometimes easier for us to think like a machine,

10:27.720 --> 10:33.480
for programmers to think like a machine and then use mathematics is because of this

10:33.480 --> 10:37.560
unfortunate bias.

10:37.560 --> 10:43.320
So when we talk to computers, right, we use computer languages.

10:43.320 --> 10:51.360
And the important thing is when we program, we have to understand the meaning of the program

10:51.360 --> 10:54.880
that we are writing, right, that's called semantics.

10:54.880 --> 11:00.080
So you're programming a language and the language has to have some kind of semantics.

11:00.080 --> 11:08.120
What does it mean to say for n equals 1 and less than n plus plus and so on, right?

11:08.120 --> 11:09.480
What's the semantics of this?

11:09.480 --> 11:15.000
So there are several approaches to defining semantics of languages.

11:15.000 --> 11:22.640
One is this operational semantics when we say, you know, if you are in this state and

11:22.640 --> 11:26.640
you do this, then the next state will be this.

11:26.640 --> 11:30.800
And then if you apply this, then the next state will be this, okay?

11:30.800 --> 11:39.120
I think this kind of operational semantics is very computer-oriented, not human-oriented,

11:39.120 --> 11:41.280
right?

11:41.280 --> 11:46.680
So the other approach is denotational semantics.

11:46.680 --> 11:54.920
In denotational semantics, we say this program has meaning because it can be translated into

11:54.920 --> 11:59.360
another language that we humans understand much better.

11:59.360 --> 12:03.320
And the perfect language for this is the language of mathematics.

12:03.320 --> 12:11.480
So in most cases, denotational semantics means your program actually has a meaning as a piece

12:11.480 --> 12:18.840
of mathematics, like a proof, like a theorem, you know, like an operation in mathematics

12:18.840 --> 12:26.240
or declaration, definition, you know, this, right?

12:26.240 --> 12:33.200
And when we are using operational semantics and we are writing a program, how do we understand

12:33.200 --> 12:35.600
what this program does?

12:35.600 --> 12:43.640
Firstly, we are running this imaginary machine in our minds, and we are going like, this statement

12:43.640 --> 12:48.680
will do this, then this statement will do this, will change these variables, so I have

12:48.680 --> 12:51.480
to keep in mind which variables, right?

12:51.480 --> 12:56.920
I mean, this is, some people are very good at this, and some people are very bad at this.

12:56.920 --> 13:00.960
I am bad at this, okay?

13:00.960 --> 13:08.640
And I have seen people who think more like machines, and they can do very quick programming,

13:08.640 --> 13:19.280
you know, and say, they, but I think ultimately, you know, none of us is as good as a computer,

13:19.280 --> 13:22.560
at that kind of game, right?

13:22.560 --> 13:27.960
We shouldn't try to beat the computer at their games, we should try to, the computer is to

13:27.960 --> 13:32.600
beat us at our games, let's see them compete with us, right?

13:32.600 --> 13:36.480
Not the other way around.

13:36.480 --> 13:41.960
And math is this ancient language, thousands of years, right?

13:41.960 --> 13:48.440
And it was developed long, long before we had computers, it was developed by humans,

13:48.440 --> 13:51.920
for humans to communicate about ideas, right?

13:51.920 --> 14:01.120
It's very important, so you know, we cannot dismiss math so easily as a language.

14:01.120 --> 14:04.560
So let's talk about functional programming.

14:04.560 --> 14:10.280
Functional programming, and I want to like start explaining a little bit of this mathematical

14:10.280 --> 14:12.200
semantics, right?

14:12.200 --> 14:20.480
So in functional programming, we deal with types and functions, right?

14:20.480 --> 14:26.840
And like the simplest mathematical model for a type is that a type is a set of values,

14:26.840 --> 14:28.920
so set theory, okay?

14:28.920 --> 14:34.200
So that's a branch of mathematics that talks about sets, okay?

14:34.200 --> 14:36.760
Fine.

14:36.760 --> 14:44.120
Functions in this model correspond to functions between sets, so it's like, you know, give

14:44.120 --> 14:49.080
me this element of a set, I'll give you that element of a set.

14:49.080 --> 14:56.400
And in this kind of theoretical mathematical view, really, we are not talking about how

14:56.400 --> 15:01.840
the function is evaluated, this is what computers do, they evaluate this function, but we first

15:01.840 --> 15:10.080
concentrate on the definition of a function, like what is actually happening if I give

15:10.080 --> 15:13.840
you this argument, what will you return, right?

15:13.840 --> 15:20.920
In mathematics, we don't really deal with time, like how long will it take to calculate

15:20.920 --> 15:21.920
this value?

15:21.920 --> 15:22.920
It doesn't matter.

15:22.920 --> 15:28.800
First, we have to start by understanding this value corresponds to this value.

15:28.800 --> 15:35.400
So function is just a mapping of values to values, between different types in general,

15:35.400 --> 15:37.560
right?

15:37.560 --> 15:45.400
But this is really, no mathematicians, that's a funny thing, mathematicians also consider

15:45.400 --> 15:51.800
set theory as sort of an assembly language of mathematics.

15:51.800 --> 15:55.200
Mathematics also has these levels of abstraction, right?

15:55.200 --> 15:57.880
Building higher and higher levels of abstraction.

15:57.880 --> 16:05.800
And set theory turns out to be this really low-level assembly language of mathematics.

16:05.800 --> 16:13.080
And mathematicians recently started, tried to avoid using set theory so much as they

16:13.080 --> 16:21.080
used to, like there are new branches of mathematics, like homotopy type theory and category theory,

16:21.080 --> 16:26.480
that try to avoid using the assembly language, so even they are going a little bit higher.

16:26.480 --> 16:35.180
So I think we could also go a little bit higher and think of program semantics in terms of

16:35.180 --> 16:37.980
category theory rather than sets.

16:37.980 --> 16:43.980
And sets form a category that's fine, you know, and sort of like a lot of our intuitions

16:43.980 --> 16:48.500
about category comes from set theory.

16:48.500 --> 16:54.820
So for most purposes, like we think about an example in set theory and we sort of try

16:54.820 --> 17:02.880
to recast it into categorical terms for programming, okay?

17:02.880 --> 17:09.160
So in a categorical view, category theory simplifies these things tremendously because

17:09.160 --> 17:16.080
it says there are only two things, objects and morphisms or arrows between objects.

17:16.080 --> 17:17.080
That's it.

17:17.080 --> 17:27.040
And it doesn't even specify what these objects are, what these arrows are.

17:28.040 --> 17:35.880
The mapping between category theory and programming is just this, functions that we use in programming,

17:35.880 --> 17:41.800
so here function meaning what we program, right, in a language.

17:41.800 --> 17:48.800
These are the arrows between objects and the objects are types, like you have integer type,

17:48.800 --> 17:54.840
you know, tree type, list type, whatever type you are using, okay?

17:54.840 --> 17:57.480
These are your objects.

17:57.480 --> 18:07.080
But the important difference between the set theoretical view and categorical view is that

18:07.080 --> 18:10.200
it's a change of perspective.

18:10.200 --> 18:17.680
In set theoretical view, you define properties of sets by talking about elements of sets,

18:17.680 --> 18:18.880
okay?

18:18.880 --> 18:24.040
In categorical view, you shrink the whole set to a point.

18:24.040 --> 18:28.200
You say, I cannot look at the structure of the set.

18:28.200 --> 18:29.360
It's forbidden.

18:29.360 --> 18:34.120
So it's like, you know, in functional programming, there are certain things that are forbidden,

18:34.120 --> 18:35.120
right?

18:35.120 --> 18:39.160
Like you are not supposed to modify a variable, right?

18:39.160 --> 18:43.280
And that forces us to change perspective, right?

18:43.280 --> 18:48.480
We come up with these persistent data structures and so on, right?

18:48.480 --> 18:51.240
Because we are forbidden to do certain things.

18:51.240 --> 18:56.640
So if you switch this perspective that you are forbidden to talk about elements of sets

18:56.640 --> 19:03.200
or talking about values, you know, then suddenly you have to rethink everything and say, so

19:03.200 --> 19:07.000
how do I describe different kinds of sets?

19:07.000 --> 19:12.440
You describe them by their interaction with other sets, which in category theory means

19:12.880 --> 19:15.160
arrows.

19:15.160 --> 19:24.520
So you can describe the properties of objects by talking about arrows, the arrows that are

19:24.520 --> 19:31.960
incoming into these objects and the arrows that are outgoing from these objects, okay?

19:31.960 --> 19:34.720
And that's a very interesting way of looking at things.

19:34.720 --> 19:40.720
It's like, tell me who your friends are and I'll tell you who you are, right, exactly

19:40.720 --> 19:41.720
this way.

19:41.720 --> 19:46.320
Instead of interviewing you, I'm just interviewing your friends and I can learn much more about

19:46.320 --> 19:49.240
you, right?

19:49.240 --> 19:54.840
But in principle, we just want to be able to express the same things we can express using

19:54.840 --> 20:01.180
elements of sets as we can do with arrows, okay?

20:01.180 --> 20:06.760
So this is like a very quick recap of the definition of a category.

20:06.760 --> 20:12.520
You've heard it several times and Daniela talked about what the category is.

20:12.520 --> 20:20.360
So objects and arrows and in parentheses, I say, what's your model for this?

20:20.360 --> 20:24.760
Like, oh, let's think about types and functions in programming, right?

20:24.760 --> 20:29.960
But categories are all kinds of different categories, right?

20:29.960 --> 20:32.520
But that's the one important for us.

20:32.520 --> 20:38.000
I'll talk about another category that's not exactly types and functions later, the

20:38.000 --> 20:41.440
functor category.

20:41.440 --> 20:45.040
The most important thing about arrows is that they compose.

20:45.040 --> 20:47.880
This is why category theory is all about composition.

20:47.880 --> 20:54.400
There's nothing more in category theory but this composition, if two arrows match end

20:54.400 --> 21:02.500
to end from A to B and B to C, then you can go from A to C. That's it, right?

21:03.500 --> 21:05.100
And we want these properties.

21:05.100 --> 21:07.580
We want the associativity of composition.

21:07.580 --> 21:14.220
So composition here is this little circle that's how mathematicians know they did.

21:14.220 --> 21:22.780
In Haskell, it's a dot and I guess in Scala, it's compose, right?

21:22.780 --> 21:24.500
And there has to be an identity.

21:24.500 --> 21:31.300
Every object has to have an arrow that goes from the object back to itself.

21:31.300 --> 21:37.700
It's sort of, you can say this is an arrow that does nothing, but you cannot say it does

21:37.700 --> 21:44.940
nothing because an arrow doesn't do anything to an object because objects don't have structure.

21:44.940 --> 21:47.900
They are just these points, right?

21:47.900 --> 21:56.380
So doing nothing that doesn't even make sense, but you can say that if you compose it with

21:56.380 --> 22:00.820
something else, then it does nothing to composition.

22:00.820 --> 22:05.100
So you compose ID with F, you get back F.

22:05.100 --> 22:08.100
You compose F with ID, you get back F.

22:08.100 --> 22:12.140
So composing with ID doesn't change anything.

22:12.140 --> 22:15.500
Okay, so now let's get to work, okay?

22:15.500 --> 22:24.100
We want to define some very simple things that we know from set theory or from type theory,

22:24.100 --> 22:28.940
from programming, some data types, okay?

22:28.940 --> 22:32.060
Using purely categorical language.

22:32.060 --> 22:36.060
So the first data type is void.

22:36.060 --> 22:42.620
This is not a type that you would use normally every day.

22:42.620 --> 22:44.700
It corresponds to an empty set.

22:44.700 --> 22:48.620
So what kind of type it is?

22:48.620 --> 22:53.180
There's not much that you can do with it, right?

22:53.180 --> 22:57.460
But it's interesting as like a boundary case, right?

22:57.460 --> 23:05.380
So from point-of-view set theory, we are describing an empty set, no elements, okay?

23:05.380 --> 23:09.540
But in category theory, since we cannot talk about the elements, we don't know what it

23:09.540 --> 23:12.400
means no elements, right?

23:12.400 --> 23:15.060
We don't know what elements are.

23:15.060 --> 23:18.860
So we have to define it using arrows.

23:18.860 --> 23:27.420
And defining something using arrows in category theory means saying something universal, meaning

23:28.420 --> 23:34.940
you have to tell me about the relationship of this object with the rest of the universe,

23:34.940 --> 23:38.660
with every other object in the category.

23:38.660 --> 23:43.700
Mathematicians are not afraid of infinities, you know, it's like you have infinitely many

23:43.700 --> 23:46.660
types, possible types, right?

23:46.660 --> 23:51.380
We are talking not only about the types that you use from day to day in programming, we

23:51.380 --> 23:57.860
are talking about all possible types that you can invent and describe, right?

23:57.860 --> 24:03.980
Lists, cues, trees, whatever, right?

24:03.980 --> 24:05.140
All these types.

24:05.140 --> 24:11.780
So there is this universal property, and in category theory, the object that has this

24:11.780 --> 24:14.780
property is called the initial object in a category.

24:14.780 --> 24:17.620
Not every category has an initial object.

24:17.620 --> 24:22.060
category of sets has an initial object, which is an empty set, okay?

24:22.060 --> 24:32.060
And the universal property of this object is that it has an arrow going to every single

24:32.060 --> 24:35.500
other object in the category.

24:35.500 --> 24:39.980
Moreover, there is only one such arrow for every object.

24:39.980 --> 24:44.060
So like you pick one object, this one, okay?

24:44.060 --> 24:48.940
There has to be a single arrow going from my initial object to this object.

24:48.940 --> 24:57.740
Not two arrows, not three arrows, not zero arrows, one, okay?

24:57.740 --> 25:09.340
And this is a translation to Scala that was done by a friend of mine.

25:09.340 --> 25:13.420
I wrote it in a Haskell and it translated.

25:13.420 --> 25:23.860
So when we are defining data types in these categorical terms, it's usually a definition

25:23.860 --> 25:29.780
consists of two parts, because we have to say about the arrows that are coming into

25:29.780 --> 25:35.220
the object and something about the arrows that are outgoing from this object.

25:35.220 --> 25:40.740
So the arrows that are coming to an object, we call them constructors, right?

25:41.100 --> 25:47.820
It's like you take some type or a bunch of types and you construct my object, right?

25:47.820 --> 25:49.900
So these arrows are functions, right?

25:49.900 --> 25:55.260
So you have a function that takes a bunch of objects and produces my object.

25:55.260 --> 25:56.660
That's a constructor.

25:56.660 --> 26:04.060
So incoming arrows are constructors and in mathematics it's called introduction rule.

26:04.060 --> 26:07.700
Introduction rule corresponds to what we say a constructor, right?

26:07.700 --> 26:13.060
So there is no possibility of constructing an empty set.

26:13.060 --> 26:14.060
What does it mean?

26:14.060 --> 26:15.900
What does it mean to construct an empty set?

26:15.900 --> 26:24.660
It means to write a function that would return an element of an empty set, okay?

26:24.660 --> 26:29.900
In set theoretical, there's no way you can write a function that would return an element

26:29.900 --> 26:33.340
of an empty set, because an empty set has no elements, right?

26:33.340 --> 26:40.780
So there is no introduction for type void.

26:40.780 --> 26:47.900
The other, the outgoing arrows, okay, this is called the elimination, okay?

26:47.900 --> 26:55.140
So like if you give me an object of type void, what can I do with it?

26:55.140 --> 27:05.180
Eliminate the object, well, in a sense by transforming it into something else, right?

27:05.180 --> 27:11.340
So I need to know what kind of arrows are outgoing from this object.

27:11.340 --> 27:19.260
And for the initial object, you know, all we know is that there is a single arrow to

27:19.260 --> 27:21.220
any other object.

27:21.220 --> 27:24.660
So this is what you would say in Scala.

27:24.660 --> 27:31.460
There is a unique function for every type A, there's a function called absurd.

27:31.460 --> 27:33.220
So it's a polymorphic function, right?

27:33.220 --> 27:34.820
Because it works for any type.

27:34.820 --> 27:40.860
It's a polymorphic function, absurd, that takes a void and produces an A.

27:40.860 --> 27:42.940
How does it do it?

27:42.940 --> 27:47.540
Well, don't ask me how it does it.

27:47.540 --> 27:52.740
Just give me an element of void and I'll give you an element of A, okay?

27:53.740 --> 27:58.740
So that's a kind of tricky thing, yes?

27:58.740 --> 28:01.740
So the question, what do you think about including self?

28:01.740 --> 28:06.740
So if void doesn't have a structure, including self?

28:06.740 --> 28:18.620
Oh, oh, including self, it means every object in a category theory has to have the identity

28:18.620 --> 28:21.100
arrow, including this one.

28:21.100 --> 28:23.140
So it has an identity arrow.

28:23.140 --> 28:28.620
An identity arrow is an example of a function that takes a void and returns a void, okay?

28:28.620 --> 28:35.300
Well, so this is like, yeah, I mean, if you give me a void, I'll return you a void.

28:35.300 --> 28:37.700
And I can even implement this function.

28:37.700 --> 28:40.900
Here's an element of void, I'm returning it back to you.

28:40.900 --> 28:41.900
Yes?

28:41.900 --> 28:45.180
If it doesn't have inbound arrows.

28:45.180 --> 28:50.380
I didn't say it doesn't have inbound arrows.

28:50.380 --> 28:51.380
I didn't say that.

28:51.380 --> 28:53.660
I said it has a unique outgoing arrow.

28:53.660 --> 28:55.660
It didn't say anything about inbound arrows.

28:55.660 --> 29:01.020
If you make an absolute, is it a strategy for a method that don't take an item of that

29:01.020 --> 29:02.020
rule?

29:02.020 --> 29:03.020
No.

29:03.020 --> 29:04.020
Is it a strategy?

29:04.020 --> 29:05.020
No.

29:05.020 --> 29:06.020
Is it a strategy?

29:06.020 --> 29:07.020
No.

29:07.020 --> 29:08.020
Is it a strategy?

29:08.020 --> 29:09.020
No.

29:09.020 --> 29:10.020
Is it a strategy or not?

29:10.020 --> 29:11.020
No.

29:11.020 --> 29:12.020
Is it a strategy?

29:12.020 --> 29:19.860
Well, it's, I mean, from the point of view of mathematics, right, like if you try to

29:19.860 --> 29:22.260
do it in set theory, okay?

29:22.260 --> 29:28.220
So how many functions are there from an empty set to another set?

29:28.220 --> 29:31.100
There's only one, okay?

29:31.100 --> 29:36.380
It doesn't matter what it does, right?

29:36.380 --> 29:40.460
Because you can never call it, okay?

29:40.460 --> 29:48.260
I mean, it's a typical mathematical thinking, but there's an interesting thing about this,

29:48.260 --> 29:57.140
because there is a one-to-one correspondence between category theory and logic and type

29:57.140 --> 29:58.300
theory.

29:58.300 --> 30:06.060
So, logically, this corresponds to the statement that from falsehood, void corresponds to

30:06.060 --> 30:09.420
falsehood in logic, okay?

30:09.420 --> 30:15.260
So from falsehood, you can derive anything, right?

30:15.260 --> 30:21.260
This is why this function is called absurd, okay?

30:21.260 --> 30:22.260
Next one.

30:22.260 --> 30:24.420
Next one is a little bit more useful.

30:24.420 --> 30:26.660
It's called unit, okay?

30:26.660 --> 30:28.500
The type is called unit.

30:28.500 --> 30:38.180
In set theory, this corresponds to a singleton set, a set that has only one element, okay?

30:38.180 --> 30:41.540
So this is type unit, also in scalar, right?

30:41.540 --> 30:43.260
There is a type unit.

30:43.260 --> 30:48.140
And it has a single element, I don't know, is that what you call this element?

30:48.140 --> 30:49.140
Yeah?

30:49.140 --> 30:52.580
Okay, okay, just like in Haskell.

30:52.580 --> 30:56.980
In Haskell, this type also is called bracket, bracket, right?

30:56.980 --> 31:01.540
So this is like the opposite of the initial object.

31:01.540 --> 31:03.460
It's called a terminal object.

31:03.460 --> 31:06.300
And by opposite, I mean, it's dual.

31:06.300 --> 31:11.660
So actually, in category theory, you have this duality, like whatever definition you

31:11.660 --> 31:16.740
come up with, you can just invert all the arrows and you get something else for free.

31:16.740 --> 31:21.780
So here we are just inverting the arrows and we're saying, okay, the universal property

31:21.780 --> 31:28.260
of a terminal object is that there is a unique arrow from any type to it, okay?

31:28.260 --> 31:32.740
From any object, from any type.

31:32.740 --> 31:37.540
So now this guy will have an introduction rule, right?

31:37.540 --> 31:44.060
Which says that for any type, a, you can produce a unit.

31:44.060 --> 31:47.100
How is this function implemented?

31:47.100 --> 31:49.540
It just ignores the input, right?

31:49.540 --> 31:54.300
And just returns this unit because it can always produce the unit.

31:54.300 --> 32:01.100
The element of the singleton set called the unit, right?

32:01.100 --> 32:02.740
So this is very easy to implement.

32:02.740 --> 32:06.260
It's like, we cannot implement all these functions, right?

32:06.260 --> 32:07.740
That's great.

32:07.740 --> 32:09.580
The elimination rule.

32:09.580 --> 32:14.580
And here we can clearly see that, you know, I'm talking about incoming arrows.

32:14.580 --> 32:17.660
It doesn't mean that there are no outgoing arrows.

32:17.660 --> 32:22.500
In fact, there are lots of outgoing arrows from it.

32:22.500 --> 32:28.780
The elimination rule is that if you have a unit, you can have a function to any other

32:28.780 --> 32:29.780
type.

32:29.780 --> 32:35.020
In fact, you have many functions depending on the type.

32:35.020 --> 32:39.500
What does a function from a unit to a type do?

32:39.500 --> 32:43.420
It picks one element from this type, right?

32:43.420 --> 32:50.660
So if you give me a unit, I can define a function to integer that returns 7.

32:50.660 --> 32:56.140
I can define another function from a unit to integer that returns 42.

32:56.140 --> 32:58.000
And so on, right?

32:58.000 --> 33:03.040
So this is actually a pretty useful thing because we are not supposed to talk about

33:03.040 --> 33:04.800
elements.

33:04.800 --> 33:13.720
But if we want to pick an element from a type, we can always cheat and say, okay, I cannot

33:13.720 --> 33:14.720
pick an element.

33:14.720 --> 33:20.560
But I can say that there is a morphism or arrow from unit to this, okay?

33:20.560 --> 33:24.600
So instead of picking element, you pick a morphism.

33:24.600 --> 33:28.760
Form is the same as arrow, okay?

33:28.760 --> 33:33.960
Now for something really interesting, product.

33:33.960 --> 33:39.280
So product, in set theory, this is just Cartesian product or a set of pairs.

33:39.280 --> 33:46.960
So you have two types, right, and you produce a pair type from these two types, right?

33:46.960 --> 33:54.840
So the universal construction for this thing is kind of interesting because, like, what

33:54.840 --> 33:59.680
is the property in terms of arrows of a product?

33:59.680 --> 34:06.760
The only thing we can say that there have to be two arrows from a product, one going

34:06.760 --> 34:12.480
to the type A and one going to type B, if you have a product of A and B, right?

34:12.480 --> 34:14.560
These are called projections, right?

34:15.040 --> 34:21.080
Like, if you have a pair of integer and bull, then you can project an integer.

34:21.080 --> 34:25.560
And I think this function called underscore one in Scala, yeah?

34:25.560 --> 34:26.440
Okay?

34:26.440 --> 34:29.000
Good translation, and there's underscore two.

34:31.880 --> 34:40.600
So we know, but what else can we say about a product that would identify it from many,

34:40.600 --> 34:45.320
many other possible objects in the universe, right?

34:45.320 --> 34:49.480
Well, so we say, okay, well, let's try some other object.

34:49.480 --> 34:52.320
Let's say C, okay?

34:52.320 --> 34:55.640
Suppose that C has these two projections also.

34:55.640 --> 35:01.080
So we know that the candidate for a product has to have these two projections, right?

35:01.080 --> 35:05.120
And the only thing we know about these projections is that there are arrows.

35:05.120 --> 35:10.040
So there is an arrow F to A and there's an arrow G to B, okay?

35:11.600 --> 35:18.320
So out of all these candidates, we can pick the best one.

35:18.320 --> 35:24.360
So look at all possible candidates, all possible types that have a projection on A and B.

35:25.880 --> 35:27.120
Pick the best one.

35:27.120 --> 35:29.160
How do we pick the best one?

35:29.160 --> 35:34.120
Okay, the best one is the one that for any other type,

35:34.120 --> 35:40.120
there's a unique arrow going to this type, okay?

35:41.160 --> 35:46.680
So like, for instance, you come up with a candidate that say,

35:48.480 --> 35:52.440
a triple A, B, and C, okay?

35:53.720 --> 35:59.120
Let's say, well, the pair A, B is better than triple A, B, C.

35:59.120 --> 35:59.920
Why?

35:59.920 --> 36:08.400
Because there is a unique function H that just picks the pair from the triple, right?

36:08.400 --> 36:10.640
Just discard C and picks A, B.

36:12.140 --> 36:17.840
And this function has this property that we can express in terms of composability

36:17.840 --> 36:23.360
that this arrow composed with this arrow gives me this arrow.

36:23.360 --> 36:26.400
And this arrow composed with this arrow gives me this arrow.

36:27.400 --> 36:31.200
So if I go through H and then project the first component,

36:31.200 --> 36:32.800
it's the same as going through F.

36:33.800 --> 36:37.720
So, this is a universal property.

36:37.720 --> 36:42.400
From all the objects, I picked the best one that has this property

36:42.400 --> 36:46.520
that any other is decomposable into it, okay?

36:47.560 --> 36:51.880
And this might seem like really a crazy way of defining things,

36:51.880 --> 36:55.960
because like, how would you write a program to do this?

36:55.960 --> 37:08.160
Well, let me write a big loop in which I go over all possible types in my type system, right?

37:09.040 --> 37:10.200
It's crazy, right?

37:10.200 --> 37:12.040
There are infinitely many of them.

37:12.040 --> 37:18.960
And then for each of these types, see if I have arrows going to A and B, right?

37:18.960 --> 37:24.680
And then from all these, see if I have a unigarrow going to A, B.

37:24.680 --> 37:28.720
And if this is true, then I had my product.

37:28.720 --> 37:34.720
If it's not true, then I try a different candidate, and so on forever, you know?

37:34.720 --> 37:36.800
But there is no time in mathematics.

37:38.000 --> 37:43.160
Yeah, I think I'm not even going to get through half of my presentation.

37:48.160 --> 37:54.640
Okay, so here it is written, you know, F is from C to A, G is from C to B.

37:55.360 --> 38:00.840
And H can be defined, you know, like as programmers, we can define this H, you know,

38:00.840 --> 38:03.520
F acting on C paired with G acting on C.

38:04.280 --> 38:07.280
That's the solution of this problem, right?

38:08.120 --> 38:13.680
And of course, I have to say what is the introduction and what is the elimination?

38:13.680 --> 38:20.720
The introduction, you have to have, in order to produce a pair, you have to have A,

38:20.720 --> 38:24.160
and you have to have an element of A, and you have to have an element of B.

38:24.160 --> 38:28.960
You need both of them to create a pair, right?

38:28.960 --> 38:32.560
So that's the constructor of a pair, very simple.

38:33.840 --> 38:40.800
The elimination rule is these two arrows from A to B.

38:40.800 --> 38:44.080
So if you give me a pair, what can I do with a pair?

38:44.080 --> 38:50.800
Well, I can project it, I can extract the first part of the second part, that's all I can do.

38:50.840 --> 38:54.960
And then I can do with this stuff more, you know, more interesting things.

38:54.960 --> 38:56.840
But I always start by projecting.

38:58.840 --> 39:02.680
And this defines all the product types.

39:02.680 --> 39:08.400
This is why they are called product types, because they come from a product.

39:08.400 --> 39:14.320
Things like pairs, tuples, records, and so on, right?

39:16.280 --> 39:20.000
And of course, there is a dual to it, a sum type, okay?

39:20.000 --> 39:22.640
Now you will understand why these things are called sum types.

39:22.640 --> 39:25.800
They are called also a coproduct.

39:25.800 --> 39:30.840
In categories here, they are called a coproduct, because they are dual to a product.

39:30.840 --> 39:38.440
And it's just the same picture, but I took the upside down and reversed all the arrows, okay?

39:38.440 --> 39:45.240
So a sum type, an example is either A and B, okay?

39:45.240 --> 39:49.320
That's like the simplest sum type of two types.

39:52.920 --> 39:58.040
Instead of having these projections, it has injections left and right.

39:58.040 --> 40:02.560
So left takes A and produces either A and B, right?

40:02.560 --> 40:06.760
It doesn't need a B, it's enough that it has an A.

40:06.760 --> 40:11.480
Or if you have B, you can produce either an A, B, and you don't need A, right?

40:11.480 --> 40:13.440
So there are two ways of constructing it.

40:16.240 --> 40:24.640
Now again, universal construction says either A and B is like the best of these guys that have these two injections.

40:24.640 --> 40:34.160
Anything else that has these two injections will factorize through some unique H, okay?

40:34.160 --> 40:43.760
So here's the factorization, like how can you define H, you know, from the type either A, B.

40:43.800 --> 40:47.120
If you have these two injections, F and G.

40:47.120 --> 40:51.920
So F and G here are these two injections, right?

40:51.920 --> 41:02.720
Right, these, and here I'm defining H from either A, B to my type C, right?

41:02.720 --> 41:05.400
And I just do case analysis.

41:05.400 --> 41:08.920
If it's left, then F, A, if it's right, then G, B.

41:08.920 --> 41:10.440
And I got it.

41:14.000 --> 41:14.600
Right?

41:16.480 --> 41:26.720
And introduction, I can introduce the type either A and B if I have A or if I have B.

41:26.720 --> 41:29.120
There are two ways of introducing it.

41:29.120 --> 41:35.280
The elimination is just by pattern matching, left, right.

41:35.280 --> 41:40.800
And this is, in programming, it's usually called tagged unions, right?

41:40.880 --> 41:44.560
In Scala, you have different name for it.

41:44.560 --> 41:47.480
But you use the term some types, right?

41:47.480 --> 41:49.080
So this is where they come from.

41:49.080 --> 41:51.800
They come from some types, okay?

41:56.280 --> 41:59.280
Monoidal category, wonderful thing, huh?

42:01.480 --> 42:02.560
Very simple.

42:02.560 --> 42:06.520
So actually, I told you already everything about this monoidal category.

42:06.520 --> 42:10.640
I told you it's a category in which you have both products.

42:10.640 --> 42:13.760
For every two elements, you can create a product.

42:13.760 --> 42:17.960
And for every two elements, you can create a sum type, okay?

42:17.960 --> 42:20.760
So why is it called monoidal?

42:20.760 --> 42:23.880
Okay, let me explain why it's called monoidal.

42:23.880 --> 42:30.480
Because this product kinda looks like multiplication.

42:30.480 --> 42:37.040
A monoid is something that has this multiplication, essentially, or addition.

42:37.040 --> 42:43.480
It's like a simple arithmetic, you know?

42:43.480 --> 42:51.320
So it has this operation that operates on two things and produces one thing, right?

42:51.320 --> 42:55.960
So this is a monoid in types.

42:55.960 --> 43:04.080
So given two types, I can multiply them by creating a product type, right?

43:04.080 --> 43:06.400
A pair type.

43:06.400 --> 43:08.440
So that's my multiplication.

43:08.440 --> 43:14.040
Now, in order for this to be a monoid, it has to be associative.

43:14.040 --> 43:18.240
So like if I have three types, right, I can pair them differently.

43:18.240 --> 43:23.000
I can pair B with C and then pair it with A.

43:23.040 --> 43:26.240
Or I can pair A and B and then pair it with C.

43:26.240 --> 43:32.840
This is not exactly the same type, like the type checker would reject this in a program.

43:32.840 --> 43:35.760
However, these two types are isomorphic.

43:35.760 --> 43:39.640
Meaning there is a function that takes this type to this type and

43:39.640 --> 43:42.560
there's an inverse function that takes this type to this type.

43:42.560 --> 43:44.400
It just rearranges stuff.

43:44.400 --> 43:46.720
That's very simple.

43:46.720 --> 43:50.640
So up to isomorphism, this is associative.

43:51.600 --> 43:55.800
And the other thing that the monoid has to have is this has to have this unit.

43:55.800 --> 44:00.920
Something that if you multiply by unit, you don't change anything, right?

44:00.920 --> 44:07.080
And the unit in case of these types is the unit type, actually.

44:07.080 --> 44:09.880
So this is why it's called unit type, right?

44:09.880 --> 44:15.760
Because if you take a pair of unit and A, it is equivalent to A.

44:15.840 --> 44:21.200
You're not adding any more information to A by pairing it with a unit, right?

44:21.200 --> 44:25.200
It's like a redundant thing, okay?

44:25.200 --> 44:27.120
Also up to isomorphism.

44:27.120 --> 44:29.920
So this is why it's called a monoid.

44:29.920 --> 44:33.560
So we have a monoidal category at our disposal.

44:33.560 --> 44:40.720
And also, the either, the coproduct, the some types also form a separate monoid.

44:41.680 --> 44:47.520
Here's the associativity for either, and here's the unit.

44:47.520 --> 44:51.560
The unit for either, and this is where Void comes back, right?

44:51.560 --> 44:54.400
This type Void is a unit.

44:54.400 --> 45:00.080
Because if you take either Void or A, it definitely contains A.

45:00.080 --> 45:01.360
Why do I know this?

45:03.120 --> 45:05.840
Because try to create, you know, from Void.

45:07.600 --> 45:10.360
Void has no element, so it will never be called.

45:10.920 --> 45:15.680
So this one injection just doesn't exist.

45:15.680 --> 45:19.560
The injection that would inject a Void to it sometime.

45:19.560 --> 45:21.280
So it always has to have an A.

45:21.280 --> 45:26.360
The only way you can construct this by providing an A, and you can extract this A.

45:26.360 --> 45:31.560
So it's isomorphic.

45:31.680 --> 45:40.640
So this is why we have this beautiful algebra of types.

45:40.640 --> 45:43.680
Okay, we have a monoid with respect to product.

45:43.680 --> 45:45.880
We have a monoid with respect to some.

45:47.160 --> 45:51.000
They actually interact together very nicely.

45:51.000 --> 45:58.680
So we have like a, you know, bi-cartesian monoidal category.

45:58.680 --> 46:03.120
It's something like this beautiful name that mathematicians give it.

46:03.120 --> 46:06.240
But this is really what we need for programming.

46:06.240 --> 46:10.160
We need a monoidal category because we have to have some types and

46:10.160 --> 46:13.040
we have to have product types, right?

46:13.040 --> 46:15.120
We also have to have function types.

46:15.120 --> 46:17.440
And that would be like the second part of my talk.

46:17.440 --> 46:20.520
And I think I'm just gonna stop here because.

46:20.520 --> 46:38.920
Is there enough tape, is there enough tape for the diaper?

46:38.920 --> 46:42.320
So how about if we make like a one minute break so

46:42.320 --> 46:47.680
that people who don't want to listen can leave and I will not be watching, okay?

46:50.520 --> 47:05.120
Okay, so here's the way we can use this algebra of types to create.

47:05.120 --> 47:12.040
Essentially, from this point on, we can create all types with just these tools.

47:12.040 --> 47:15.360
Okay, this will be kind of awkward.

47:15.360 --> 47:18.680
For instance, the type Boolean, right?

47:18.680 --> 47:20.600
It's nice to have a Boolean type.

47:20.600 --> 47:23.920
A Boolean type is just either unit or unit.

47:25.200 --> 47:29.600
It means you can create it as a left thing or a right thing.

47:29.600 --> 47:34.040
And it has no other information other than whether it's left or right.

47:34.040 --> 47:39.280
And we call the left thing true, for instance, and the right thing false.

47:39.280 --> 47:41.000
That's it, the sum type.

47:41.000 --> 47:43.800
It can either be true or false, right?

47:43.800 --> 47:48.840
So here's the sealed, straight, bull, okay.

47:48.840 --> 47:54.720
So this is how you do sum types in Scala, right?

47:56.120 --> 48:02.160
Type natural, you would have to do infinitely many.

48:02.160 --> 48:13.640
But type natural number is either one or two or three or four and so on.

48:13.640 --> 48:16.040
So it is a sum type.

48:16.040 --> 48:21.080
So essentially having sum types, and if you apply it infinitely many times,

48:21.080 --> 48:24.120
you'll get natural numbers.

48:24.120 --> 48:25.920
Okay, this is a very awkward definition.

48:25.920 --> 48:28.720
There are better definitions than that, right?

48:28.720 --> 48:33.280
But just to show you the idea, the option type, right?

48:33.280 --> 48:37.880
The maybe type, the option type, a little bit more interesting.

48:37.880 --> 48:42.760
It's a sum type, it's either of unit and A.

48:42.760 --> 48:48.080
So it is a polymorphic type, parametrized type by some type A, right?

48:48.080 --> 48:53.440
So you can either construct by providing unit, which you can always do.

48:53.440 --> 48:58.560
And that's the nothing part in Haskell.

48:58.560 --> 49:00.040
What do you call it in Scala?

49:00.040 --> 49:05.080
None, none, okay, so none, that corresponds to none.

49:05.080 --> 49:10.560
And this corresponds to what you call sum, okay, none, sum.

49:10.560 --> 49:15.760
Nothing just in Haskell, same thing, right?

49:15.760 --> 49:20.480
Then you can go into recursive types, you can define a list.

49:20.480 --> 49:23.080
List is a sum of two things.

49:23.080 --> 49:29.400
Unit here, that signifies empty list.

49:29.400 --> 49:32.600
You can construct an empty list, right, always, right?

49:32.600 --> 49:37.440
And contains no information, so you can construct it from unit.

49:37.440 --> 49:43.080
You always have at your disposal, because the units are just everywhere.

49:43.080 --> 49:49.840
You just pull them from the air, and you create a list using unit, and

49:49.840 --> 49:51.840
that's an empty list.

49:51.840 --> 49:57.840
Or you can create it from a product here, right?

49:57.840 --> 50:02.280
Of A, which will serve as the head of the list.

50:02.280 --> 50:06.960
And the whole other list, which is the tail of the list, right?

50:06.960 --> 50:14.360
So here we have a sum and a product together, and it's recursive, right?

50:14.360 --> 50:17.520
And this is how you could express it, okay?

50:18.960 --> 50:22.880
So this is like the skeleton of a whole type system.

50:22.880 --> 50:26.760
Everything else is just syntactic sugar on top of this.

50:26.760 --> 50:30.120
That's very interesting to know, right?

50:31.040 --> 50:37.640
Okay, so now you've heard the word functor so many times today, right?

50:37.640 --> 50:39.520
And yesterday.

50:39.520 --> 50:44.240
Okay, so let me just introduce the functor categorically.

50:46.760 --> 50:50.480
So in general, the functor is a mapping between categories.

50:50.480 --> 50:55.760
So mathematicians are always interested in how things that have

50:55.760 --> 51:02.440
a certain structure relate to another thing that has a similar structure, right?

51:02.440 --> 51:09.080
And a functor, in this case, takes one category and

51:09.080 --> 51:13.080
embeds its structure into another category.

51:14.600 --> 51:17.120
So it's a mapping from category to category.

51:17.120 --> 51:21.720
So if it's mapping a category, and the category is nothing else but objects and

51:21.720 --> 51:26.800
arrows, so naturally it has to map objects and arrows.

51:28.160 --> 51:32.400
So it maps objects to objects and arrows to arrows, right?

51:32.400 --> 51:37.360
And because it has to preserve the structure, what does it mean structure?

51:37.360 --> 51:41.560
It means that if you have an object A and an object B, okay?

51:41.560 --> 51:47.160
So A goes into F A, that's an object F A, this is an object F B, right?

51:47.160 --> 51:53.000
If there is an arrow between A and B, then this arrow has to be mapped into

51:53.000 --> 51:55.000
another arrow, right?

51:55.000 --> 51:59.160
But it cannot be an arbitrary arrow anywhere else, right?

51:59.160 --> 52:04.880
It better be an arrow that connects F of A to F of B, right?

52:04.880 --> 52:09.760
Because if these things are connected in this category,

52:09.760 --> 52:14.120
they must be connected in this category as well, okay?

52:14.120 --> 52:20.640
The factor may do things like collapse two objects into one.

52:20.640 --> 52:24.280
It can collapse multiple arrows into one and so on.

52:24.280 --> 52:28.600
But as long as you have a connection in one category, it will preserve this connection.

52:28.600 --> 52:32.240
And it will also preserve the unit arrows, and

52:32.240 --> 52:35.040
it will preserve the composition of arrows, okay?

52:36.680 --> 52:40.880
So how does this translate into programming?

52:41.120 --> 52:46.040
So first of all, in mathematics, the most general functor goes from one category

52:46.040 --> 52:47.160
to another category.

52:49.160 --> 52:53.760
In programming, most of the functors will go from the same category to the same

52:53.760 --> 52:56.680
category, they are called endo functors.

52:56.680 --> 53:00.920
Endo means inside, like endoscopy, you know.

53:00.920 --> 53:10.680
Yeah, so we have a functor that goes within the category.

53:10.680 --> 53:18.240
So it takes a type A and maps it into a type list of A, okay?

53:18.240 --> 53:22.880
So it takes a type integer, maps it into a list of integer.

53:22.880 --> 53:26.960
It's mapping between types, this is a very important thing.

53:26.960 --> 53:28.960
Many people get confused because of this.

53:28.960 --> 53:34.120
It's not mapping of elements of these sets, it just maps the whole set into the whole set.

53:34.120 --> 53:39.920
It's like, say, here's an integer set, or integer type,

53:39.920 --> 53:44.680
maps it into a list of integer type, type to type.

53:44.680 --> 53:46.320
Like a parametric type, right?

53:46.320 --> 53:48.480
A type constructor, right?

53:48.480 --> 53:50.000
Okay, so type constructor.

53:53.840 --> 54:01.600
So the type constructor part of it is that this F with a bracket in Scala, right?

54:01.600 --> 54:03.000
So that's a type constructor.

54:03.000 --> 54:06.520
It takes a type and produces a type F of A.

54:06.520 --> 54:08.560
Takes A, produces F of A.

54:08.560 --> 54:13.000
So this is the part of acting on objects, the blue arrows.

54:13.000 --> 54:19.440
And we have to separately define how it acts on arrows.

54:19.440 --> 54:23.680
So it takes an arrow F, that's this arrow F.

54:23.680 --> 54:25.960
This arrow goes from A to B, right?

54:25.960 --> 54:27.880
From A to B, okay?

54:27.880 --> 54:37.520
And maps it into an arrow that takes F of A, this guy, and returns F of B, this guy, okay?

54:37.520 --> 54:41.800
So if you draw a picture, this is really very simple, right?

54:41.800 --> 54:45.320
So it takes this arrow and maps it into this arrow.

54:45.320 --> 54:47.240
And you have to provide this function.

54:47.240 --> 54:51.920
For every function, you have to provide part of the definition of a function is how does

54:51.920 --> 54:55.440
it act on arrows, right?

54:55.440 --> 54:59.760
Maybe there are sometimes factors that have different actions on arrows,

54:59.760 --> 55:05.920
the same action on an object, but differ by acting on arrows, okay?

55:05.920 --> 55:10.440
So I guess this is, okay, I think you guys call it map, not F map.

55:10.440 --> 55:17.720
Haskell calls it F map, for historical reasons, really, no, no.

55:17.720 --> 55:20.960
So this is how it acts on lists, right?

55:20.960 --> 55:22.120
But you've seen this before.

55:23.120 --> 55:27.840
So why am I talking about functors?

55:27.840 --> 55:31.360
And now I have to introduce adjunctions between functors.

55:31.360 --> 55:39.840
I have to introduce adjunctions between functors because there is one extremely important example

55:39.840 --> 55:47.520
of an adjunction that's very useful in programming, especially functional programming.

55:47.520 --> 55:57.800
And so little motivation, right?

55:57.800 --> 55:59.000
You know what types are.

55:59.000 --> 56:01.040
So I told you about all these types.

56:01.040 --> 56:03.440
They are objects.

56:03.440 --> 56:06.800
Separately, I said we have arrows.

56:06.800 --> 56:09.680
They correspond to functions, okay?

56:09.680 --> 56:20.680
But you know that, like when I say F from A to B, I mean a type of a function, right?

56:20.680 --> 56:23.280
A type of a function.

56:23.280 --> 56:29.640
But we said types are objects, and this is an arrow, right?

56:29.640 --> 56:32.560
So how is this connected?

56:32.560 --> 56:41.040
So you have to have an object inside the category of types that corresponds to the set of arrows

56:41.040 --> 56:43.080
between objects A and B.

56:43.080 --> 56:51.040
So for every pair of objects A and B, there is a set of arrows between them, but there

56:51.040 --> 57:01.160
has to be also an object, separate objects, that represents the set of arrows, right?

57:01.160 --> 57:06.800
And that's called the type of function, function type.

57:06.800 --> 57:12.960
Not every category will have this, but the category that we are interested in, in which

57:12.960 --> 57:19.120
we can program, must have this object for every pair of A and B, okay?

57:19.120 --> 57:25.840
And you know, this object can be introduced by another universal construction, I'll show

57:25.840 --> 57:26.840
you in a moment.

57:26.840 --> 57:33.040
The easiest way of introducing it is through an adjunction of two functors, in particular

57:33.040 --> 57:36.200
two endo functors that we are interested.

57:36.200 --> 57:41.720
So an adjunction is not one functor, but a pair of functor.

57:41.720 --> 57:46.440
One functor adjoins to the other functor, okay?

57:46.440 --> 57:51.720
So one functor goes from one category, from this category to this category, and there's

57:51.720 --> 57:56.280
another functor going this way, okay?

57:57.280 --> 58:02.040
If you have two functors going in the opposite directions, you might say, okay, like if one

58:02.040 --> 58:07.320
is the inverse of another, that means that these two categories look the same, right?

58:07.320 --> 58:10.160
There is like an isomorphism of categories.

58:10.160 --> 58:18.240
But it's much more interesting if these are not inverses of each other, but they act in

58:18.240 --> 58:24.680
a very interesting way on arrows, okay?

58:26.880 --> 58:39.800
So we say that the functor f is left adjoined to the functor u, if you draw the set of arrows

58:39.800 --> 58:49.280
from fA to B and the set of arrows from A to UB, they are isomorphic.

58:49.280 --> 58:56.080
Having isomorphic set of arrows tells us about how these two objects are related, right?

58:56.080 --> 58:58.920
They are related in a particular way.

58:58.920 --> 59:05.400
If they have the same set of arrows going between them, right, it means that their relationship

59:05.400 --> 59:07.360
is very similar.

59:07.360 --> 59:13.520
And you can think of this as like you are preparing an argument for a function, you know, using

59:13.520 --> 59:23.360
functor f, and here you are modifying the output of a function by applying functor u.

59:23.360 --> 59:30.160
So if you prepare arguments to functions, or you modify the output of functions, you

59:30.160 --> 59:37.640
get this isomorphism between these two, okay?

59:37.640 --> 59:46.000
And when you hear this first time, it's really like kind of weird, like why is this so interesting?

59:46.000 --> 59:49.680
So I'll give you one example, and there are many, many interesting examples, but I'll

59:49.680 --> 59:55.400
give you one example that like pops out immediately.

59:55.400 --> 01:00:05.600
So let's pick the functor f acting on A, it pairs it with C, okay?

01:00:05.600 --> 01:00:12.400
So I take the type A and I pair it with C, I get a pair type.

01:00:12.400 --> 01:00:14.400
So that's one functor.

01:00:14.400 --> 01:00:27.080
The other functor is acting on B, it creates a type of function from C to B, okay?

01:00:27.080 --> 01:00:28.080
Nothing yet, right?

01:00:28.080 --> 01:00:33.240
It's like, oh, okay, all right, all right.

01:00:33.240 --> 01:00:36.360
Now let me write this isomorphism between these.

01:00:36.360 --> 01:00:45.440
So like if I prepare my argument by pairing it with C, okay, and I have a function on

01:00:45.440 --> 01:00:56.280
arrow from A, C to B, this is equivalent isomorphic to all these functions that take A without

01:00:56.280 --> 01:01:06.320
any preparation, but modify the argument B by putting this as an output of a function

01:01:06.320 --> 01:01:10.520
that takes C, okay?

01:01:10.520 --> 01:01:16.720
Now if you look at it, this is called curring, right?

01:01:16.720 --> 01:01:24.080
Curring, a function that takes a pair is equivalent to a function that takes one element and returns

01:01:24.080 --> 01:01:28.680
another function that takes the second one, okay?

01:01:28.680 --> 01:01:37.120
So this is how curring arises from an adjunction, right?

01:01:37.120 --> 01:01:41.760
This is this adjunction, oh, this is a general adjunction, right?

01:01:41.760 --> 01:01:44.840
This is this particular adjunction.

01:01:44.840 --> 01:01:52.800
And in category theory, this function type, this C to B, because you can take this as a

01:01:52.800 --> 01:01:59.280
definition of the function object, because this is a type of functions from C to B. You

01:01:59.280 --> 01:02:10.080
can say this, if you have in your category pairing or product, then you may, if you have

01:02:10.080 --> 01:02:18.000
this adjunction, you will be able to define what it means to have a function type, right?

01:02:18.000 --> 01:02:21.800
And the category in which this is defined is called closed.

01:02:21.800 --> 01:02:28.080
So taking together, we have a Cartesian closed category.

01:02:28.080 --> 01:02:33.360
Cartesian because it has a Cartesian product, closed because it has a function type.

01:02:33.360 --> 01:02:38.920
And we are operating a Cartesian closed category when we are doing programming, right?

01:02:38.920 --> 01:02:44.400
So next time somebody tells you about Cartesian closed categories, you know, oh, yeah, this

01:02:44.400 --> 01:02:48.240
is what we use in our everyday programming.

01:02:48.240 --> 01:02:54.040
This is what, yeah, this is our bread and butter.

01:02:54.040 --> 01:02:59.680
In mathematics, this is called an exponential, A to B. Function type from B to A is called

01:02:59.680 --> 01:03:06.640
A to the power of B. And it actually, I'm not going to go into it, but actually, like

01:03:06.640 --> 01:03:13.520
if you look at it as an exponential and combine it with multiplication being product type,

01:03:13.520 --> 01:03:21.920
sum type using either and exponential, you can like write all these identities from high

01:03:21.920 --> 01:03:29.080
school like A plus B to the power of C is A to the power of B plus and so on.

01:03:29.080 --> 01:03:36.280
All these identities actually work on types, which is, on one level, it's a weird thing,

01:03:36.280 --> 01:03:37.280
right?

01:03:37.360 --> 01:03:45.520
Another level, you see the repetition of the same patterns in mathematics all the time.

01:03:45.520 --> 01:03:51.560
And that's an interesting thing to think about, you know, free time.

01:03:51.560 --> 01:03:54.000
So I'll show you just this diagram.

01:03:54.000 --> 01:03:58.320
Function types can be defined using universal construction, right?

01:03:58.320 --> 01:04:03.440
This is like the diagram that, it's a little more complicated than defining a product, but

01:04:03.440 --> 01:04:06.140
it can be done, okay?

01:04:06.140 --> 01:04:09.740
And of course we can say, what's the introduction and elimination?

01:04:09.740 --> 01:04:14.740
The introduction of function is called lambda, okay?

01:04:14.740 --> 01:04:21.460
So if you have an object of type A and you have an expression of type B, then lambda

01:04:21.460 --> 01:04:28.380
X E of X is of the type A to B, okay?

01:04:28.380 --> 01:04:31.780
And elimination is called eval.

01:04:31.780 --> 01:04:38.460
So you eliminate a function by providing an argument and getting the result.

01:04:38.460 --> 01:04:48.380
Okay, so I'll have to speed up now.

01:04:48.380 --> 01:04:51.820
Natural transformations are extremely important.

01:04:51.820 --> 01:04:56.060
We know them as polymorphic functions, okay?

01:04:56.060 --> 01:05:01.980
In category theory, they are just mappings between functors.

01:05:01.980 --> 01:05:13.260
So if you have two functors, F and G, you pick an object A and you map it to F A and

01:05:13.260 --> 01:05:15.660
you can map it to G A.

01:05:15.660 --> 01:05:23.020
A natural transformation is when you pick these arrows, for every F A G A, you pick one arrow.

01:05:23.020 --> 01:05:27.620
So you pick a function that depends on A, right?

01:05:27.620 --> 01:05:30.660
You keep changing A, you get different functions.

01:05:30.660 --> 01:05:32.660
So it's a polymorphic function.

01:05:32.660 --> 01:05:39.860
It's a polymorphic function whose argument is a factorial and whose result is factorial.

01:05:39.860 --> 01:05:42.060
So here's an example of something like this.

01:05:42.060 --> 01:05:49.660
You take a list and you produce an option, right?

01:05:49.660 --> 01:05:51.260
Did I rewrite it?

01:05:51.260 --> 01:05:59.260
Yeah, this is, yeah, okay, non-sum, okay, yeah, yeah.

01:05:59.260 --> 01:06:04.740
It returns an option, right?

01:06:04.740 --> 01:06:07.340
Why is it important to have natural transformations?

01:06:07.340 --> 01:06:14.180
Because now I can say, and this is like a typical thing in category theory, okay, I have

01:06:14.180 --> 01:06:24.860
functors and I have natural transformations which transform one function to another, okay.

01:06:24.860 --> 01:06:28.100
Are these arrows between functors?

01:06:28.100 --> 01:06:30.940
Maybe I have a category, right?

01:06:30.940 --> 01:06:36.940
Like what if functors are objects and natural transformations would be arrows between these

01:06:36.940 --> 01:06:40.260
objects, okay.

01:06:40.260 --> 01:06:41.580
What do I have to show?

01:06:41.580 --> 01:06:47.020
I have to show, if I want to have a category, I would have to show that there is a composition

01:06:47.020 --> 01:06:53.380
and of course there is a composition of these arrows because if I have another functor H,

01:06:53.380 --> 01:06:58.420
you know, I'll just compose these two and I get a third one, right?

01:06:58.420 --> 01:07:09.900
There is an identity and of course there is associativity, right?

01:07:09.900 --> 01:07:13.660
An identity, so that works fine, right?

01:07:13.660 --> 01:07:23.540
So I can construct something called a functor category in which objects are functors and

01:07:23.540 --> 01:07:25.780
arrows are natural transformations.

01:07:25.780 --> 01:07:33.420
So this is an example of a category that's not slightly different than what we were talking

01:07:33.420 --> 01:07:35.620
about before, right?

01:07:35.620 --> 01:07:40.860
But it is a very important category, a functor category.

01:07:40.860 --> 01:07:46.100
Now in our case we talk about endofunctors and endofunctors also being functors form

01:07:46.100 --> 01:07:48.260
a category, right?

01:07:48.260 --> 01:07:55.060
So they form a category, it's called, that's how mathematicians write it, it's a category

01:07:55.060 --> 01:08:01.740
of functors from C to C, okay?

01:08:01.740 --> 01:08:08.620
So the final minute, the yoneta embedding, okay?

01:08:08.620 --> 01:08:11.920
The yoneta embedding.

01:08:11.920 --> 01:08:19.020
So this is the kind of thinking that can break your brain a little bit, right?

01:08:19.020 --> 01:08:25.260
But it shows you the power of categories here, this is like, because there is this notion

01:08:25.260 --> 01:08:34.660
that we have replaced contents of objects, we replace it with arrows.

01:08:34.660 --> 01:08:45.820
Like we say, everything we can say about the object can be said using arrows, right?

01:08:45.820 --> 01:08:52.860
Objects shrunk to a point and everything, all its properties are expressed using arrows.

01:08:52.860 --> 01:08:59.820
So the next step would be to say, well, instead of talking about an object, why don't I talk

01:08:59.820 --> 01:09:06.860
about all the arrows that are, let's say, impinging on this object, okay?

01:09:06.860 --> 01:09:18.220
Like if I take the totality of arrows in my category that end in this object, do they

01:09:18.220 --> 01:09:26.300
contain exactly the same information as the object itself, right?

01:09:26.300 --> 01:09:30.820
Can I replace this object by just talking about the totality of arrows that come to

01:09:30.820 --> 01:09:33.180
this object?

01:09:33.180 --> 01:09:39.540
And the answer is yes, and it's called the yoneta embedding, okay?

01:09:39.540 --> 01:09:43.100
So let me go through, like, steps, right?

01:09:43.100 --> 01:09:48.700
So first of all, how do I even define the totality of arrows coming to an object?

01:09:48.700 --> 01:09:56.260
Well, I'll start with a, so I'm talking about object A, that's my object, okay?

01:09:56.260 --> 01:10:04.780
Let me pick another object X and have a totality of arrows from X to A to begin with.

01:10:04.780 --> 01:10:06.420
I have to start somewhere, right?

01:10:06.420 --> 01:10:07.780
So let me take these arrows.

01:10:07.780 --> 01:10:10.780
What do they, they form a set.

01:10:10.780 --> 01:10:20.380
They form a set of arrows, set of arrows from X to A, okay?

01:10:20.380 --> 01:10:22.260
But this is just one X.

01:10:22.260 --> 01:10:27.340
If I want to talk about totality of arrows that go to A, I have to vary X.

01:10:27.340 --> 01:10:32.380
I have to, like, go to every possible X in my category, right?

01:10:32.380 --> 01:10:38.060
So if I start varying X, then I get different sets here.

01:10:38.060 --> 01:10:45.260
So this is for X, you know, I pick Y, there will be from Y to A, and so on.

01:10:45.260 --> 01:10:54.580
So I end up with something that's like a mapping of X, when I vary X, to sets.

01:10:54.580 --> 01:10:58.020
Sets are objects in the category of set, okay?

01:10:58.020 --> 01:11:08.420
So I have a mapping that goes from X to X to A for a fixed A.

01:11:08.420 --> 01:11:13.940
And this mapping, I define this mapping for objects, for Xs, right?

01:11:13.940 --> 01:11:20.020
This mapping can be extended also to arrows, which means that it's really a functor.

01:11:20.020 --> 01:11:27.100
This is a functor, if you vary X, it's called a contraviant functor, because it acts weirdly

01:11:27.100 --> 01:11:29.980
on arrows, like the opposite of the arrows.

01:11:29.980 --> 01:11:40.180
But it's a functor, and it's a functor from this category C to the category set, okay?

01:11:40.180 --> 01:11:51.260
So now, for every object A, I get a functor from C to set, okay?

01:11:51.260 --> 01:11:52.900
Keep this in mind.

01:11:52.900 --> 01:12:03.500
From every A, I have a functor from C to set, it just takes an X and puts it into XA.

01:12:03.500 --> 01:12:10.300
So now if I start varying A on top of this, okay?

01:12:10.300 --> 01:12:21.580
Then I have a mapping that takes an A and creates a functor from C to set, okay?

01:12:21.580 --> 01:12:26.780
So this is the functor category from C to set.

01:12:26.780 --> 01:12:32.300
Here's my X, here's my A, I'm varying A to B, okay?

01:12:32.300 --> 01:12:38.140
So for every object A, I have a functor, right?

01:12:38.140 --> 01:12:41.700
That takes these arrows and puts it here, right?

01:12:41.700 --> 01:12:49.860
So I have a mapping that embeds an object from category C into the functor category.

01:12:49.860 --> 01:12:58.900
And now if I have a mapping of objects from one category C to another category, which

01:12:58.900 --> 01:13:04.300
is a functor category, is this mapping a functor?

01:13:04.300 --> 01:13:09.740
Turns out this mapping is a functor too, okay?

01:13:09.740 --> 01:13:18.460
And moreover, it's action on arrows, so here's an arrow from A to B, it's action of arrows,

01:13:19.020 --> 01:13:24.020
well, so it's action on arrows would have to be a natural transformation because arrows

01:13:24.020 --> 01:13:27.060
in this category are natural transformations.

01:13:27.060 --> 01:13:31.980
So there's a mapping from these arrows to these arrows.

01:13:31.980 --> 01:13:36.820
These are just functions, these are natural transformations, right?

01:13:36.820 --> 01:13:44.860
So this is a function from A to B, it's mapped into this natural transformation from this

01:13:44.900 --> 01:13:49.420
functor to this functor, okay?

01:13:49.420 --> 01:13:57.780
When I vary X, this is a functor, okay?

01:13:57.780 --> 01:14:03.100
And the Yoneda Lemma says this mapping goes both ways.

01:14:03.100 --> 01:14:11.260
It's actually an isomorphism, which means that this whole category C can be embedded

01:14:11.380 --> 01:14:20.380
in the category of functors, which is called a fully faithful embedding, meaning it takes

01:14:20.380 --> 01:14:25.780
all arrows and nothing more than maps them to all two arrows here.

01:14:25.780 --> 01:14:31.820
So if you map A to this functor, B to this functor, all arrows from A to B go into natural

01:14:31.820 --> 01:14:36.460
transformations from this functor to this functor, and nothing more is there.

01:14:36.460 --> 01:14:42.500
So you can take all natural transformations, they will correspond to arrows here, right?

01:14:42.500 --> 01:14:49.500
So you have a perfect picture of this whole category embedded in this category of functors,

01:14:49.500 --> 01:14:51.060
okay?

01:14:51.060 --> 01:14:53.060
And I think this is a good point to end.

01:14:53.060 --> 01:15:00.060
Thank you.

