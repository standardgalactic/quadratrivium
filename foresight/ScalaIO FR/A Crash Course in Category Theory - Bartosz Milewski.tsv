start	end	text
0	11200	So many people are interested in category theory.
11200	12760	This is a new thing.
12760	22240	A few years ago, nobody wanted to listen about category theory, and now it seems like it's
22240	26000	a very hot topic, lots of talks.
26000	32880	And people are mentioning categorical terms in all the talks, I listened to several talks
32880	45040	and it was like functors, monads, applicatives, all this beautiful stuff from category theory.
45040	51400	And also a lot of people, when they talk about data structures, they say, okay, things like
51400	57640	algebraic data structures, some types, product types, and so on, all this stuff has roots
57640	59600	in category theory.
59600	63320	So I want to talk about these things as well today.
63320	69160	This is just an intro to category theory, so I won't cover a lot.
69160	72800	Here's the plan for the talk.
72800	80040	I'll talk a little bit about categorical semantics, about semantics of programming languages in
80040	82480	very generic terms.
82480	87200	And of course I'll talk about composability, because composability is what category theory
87200	89680	is about.
89680	92440	Then I'll talk a little bit about algebraic data types.
92440	98280	I feel quite a bit about algebraic data types, come to think of it, because it's like a very
98280	101320	important part.
101320	105480	Then I'll talk about function types, because we're at a functional conference, functional
105480	108000	programming conference, right?
108000	114600	So function types and currying, and finally I want to end up with a Yoneda lemma, which
114600	125240	is like the central theorem in category theory.
125240	133520	So well, let me start immediately, because we don't have that much time.
133520	138640	So I want to motivate you a little bit, right?
138640	143520	And I have lots of motivations why category theory is important, and so on.
143520	150400	But I think the real reason why I got into category theory is because it's fun.
150400	154120	It's interesting, and it's mind-expanding.
154120	162400	So if you are looking for reasons to study category theory, maybe you should just like
162400	166000	enjoy it.
166000	172760	I know that category theory is a branch of mathematics, and a lot of people have some
172760	178200	preconceptions about what mathematics is, and a lot of people don't like mathematics,
178200	190560	because they were, starting with primary school, we are taught not to like mathematics.
190560	196080	And here I give an example of the things that we teach our kids in schools.
196080	199360	This is like multiplying two numbers.
199360	200920	This is a horrible thing.
200920	205320	This is like mind-breaking for humans, okay?
205320	213800	There is this huge discrepancy between, or impedance mismatches, like between human
213800	217640	mind and computers, okay?
217640	220880	And there are two ways of bridging this gap.
220880	228360	One is we insist on being humans and just ask the computers to come up to our level.
228360	233600	The other is to lower ourselves to the level of computers, and I think this is wrong.
233600	236840	So this is an example of multiplication, right?
236840	244240	We teach our kids to do this, and it has all the elements at which computers are very good
244240	247080	and humans are very bad, okay?
247080	252160	The only thing that's important here is that there is an algorithm behind it, right?
252160	255880	But we don't even tell the kids that there is an algorithm.
255880	259440	We just tell them, here are instructions.
259440	264440	Perform these instructions one after another, okay?
264440	271040	And this is the moment where we are teaching kids imperative programming, and they are spoiled
271040	272040	for life.
272040	278360	And then we have to take years and years to un-teach them, you know, functional programming
278360	282440	is like the declarative way of saying things.
282440	288360	That's much more human, but we are so used to this kind of thinking, the imperative thinking
288360	294080	from the very beginning, that it's very hard to break these things.
294080	304200	So here I match things that we are good at versus what the computers are good at.
304200	308480	Computers are very kind of local thinking, right?
308480	311160	They look at the next instruction.
311160	318480	They are not, they don't have this global perspective that humans have, right?
318480	324520	When we start programming, right, we think about the problem that we are trying to solve.
324520	331080	We have this global view, like where does this problem fit into the, you know, bigger
331080	339120	picture of, we want our company to make money, for instance, you know, goals that we have,
339120	340120	and so on.
340120	345920	So we have this global view, and then we kind of descend to the nitty-gritty eventually,
345920	347080	right?
347080	351400	Computers are just nitty-gritty from the very beginning and all the time, right?
351400	355160	They look at the particular instruction.
355160	358440	Computers are progress-oriented.
358440	359640	They just want to make progress.
359640	365120	They just want to go from one instruction to the next instruction, one line of code
365120	367640	to another line of code, and so on.
367640	373600	They are not interested in what's happening, it's just locally and making progress.
373600	374600	That's important.
374880	377240	Whereas we are goal-oriented.
377240	380400	We know why we are doing this, right?
380400	381560	We have a goal.
381560	387120	We want to calculate some value, or we want to draw something, we want to animate some
387120	389760	pictures, you know, all this stuff.
389760	391520	That's our goal.
391520	397160	Making progress for the sake of progress makes no sense for us, right?
397160	398800	For a computer, there is no goal.
398800	402280	It's just making progress.
402280	408480	Computers are very detail-oriented, whereas we operate with ideas.
408480	409800	We have these abstractions.
409800	410800	We have ideas.
410800	419760	We try to convey these ideas to the computer so that it can be executed in some way.
419760	423480	Computers have vast memory, right?
423480	427200	They have memory in the computer.
427200	429280	They can access disks.
429280	434680	They can go on the Internet, servers, farms, and so on.
434680	436960	There's vast amounts of memory.
436960	440920	We humans have tiny memory, right?
440920	442640	Especially the working memory.
442640	448480	I mean, we remember stuff from our childhood and so on, but the working memory is tiny.
448480	455880	We can only keep in our working memory like seven things at a time, right?
455880	458240	Computers are pretty reliable.
458240	462840	I wanted to write reliable, but then I thought, okay, yeah, right.
462840	467920	Computers are made by humans, therefore, they cannot be 100% reliable.
467920	474640	But when you are writing a program and it doesn't work, your first thought is not, oh,
474640	477160	there must be something wrong with the chip, right?
477160	481640	Or the compiler has a bug.
481640	485520	The first thought is, I made a mistake, right?
485520	491480	Only once in a long, long time it happens that the compiler is wrong and very rarely
491480	498120	that the actual CPU is wrong, right?
498120	501760	But we humans are extremely error-prone, right?
501760	506600	And we should admit it, and we shouldn't punish our kids for making errors when they
506600	508960	are doing calculations like these.
508960	513200	This is normal for us to make errors, okay?
513200	515440	Let's accept it.
515560	519960	Computers don't make these errors, and computers should do these things.
519960	521080	We have calculators.
521080	524600	We can calculate all this stuff, right?
524600	528680	We don't need that.
528680	531240	And finally, the language.
531240	533760	There's this language barrier, okay?
533760	539840	And I think, of course, computers understand machine language, right?
539840	544680	And we used to program in machine language in the very, very beginning, you know, switches,
544720	546320	zeros, ones, and so on.
546320	550160	Like, very quickly, we learned we humans are not very good.
550160	554400	Computers don't mind, okay, zeros, ones, great.
554400	556840	But we humans do mind.
556840	560800	It's very difficult for us to program using zeros and ones.
560800	565240	So we come up with higher and higher level languages to program computers.
565240	572480	But ultimately, and that's my main point, is that ultimately the language that's most
572480	578680	human to talk about ideas is the language of mathematics.
578680	584160	And the reasons why we are not constantly using mathematics when we are talking about
584160	590480	programming is because of that, because of this multiplication that they forced on us,
590480	595080	you know, that they taught us mathematics in the wrong way.
595080	599280	And category theory is a branch of mathematics that doesn't look like this.
599280	601400	It looks much nicer.
601400	606600	You know, it doesn't talk about numbers and doesn't talk about making stupid
606600	609160	mistakes and algorithms and so on.
609160	611360	Talks about ideas.
611360	619720	And that's much more human-like than dealing with numbers and bits.
621720	627720	So I think the reason it's sometimes easier for us to think like a machine,
627720	633480	for programmers to think like a machine and then use mathematics is because of this
633480	637560	unfortunate bias.
637560	643320	So when we talk to computers, right, we use computer languages.
643320	651360	And the important thing is when we program, we have to understand the meaning of the program
651360	654880	that we are writing, right, that's called semantics.
654880	660080	So you're programming a language and the language has to have some kind of semantics.
660080	668120	What does it mean to say for n equals 1 and less than n plus plus and so on, right?
668120	669480	What's the semantics of this?
669480	675000	So there are several approaches to defining semantics of languages.
675000	682640	One is this operational semantics when we say, you know, if you are in this state and
682640	686640	you do this, then the next state will be this.
686640	690800	And then if you apply this, then the next state will be this, okay?
690800	699120	I think this kind of operational semantics is very computer-oriented, not human-oriented,
699120	701280	right?
701280	706680	So the other approach is denotational semantics.
706680	714920	In denotational semantics, we say this program has meaning because it can be translated into
714920	719360	another language that we humans understand much better.
719360	723320	And the perfect language for this is the language of mathematics.
723320	731480	So in most cases, denotational semantics means your program actually has a meaning as a piece
731480	738840	of mathematics, like a proof, like a theorem, you know, like an operation in mathematics
738840	746240	or declaration, definition, you know, this, right?
746240	753200	And when we are using operational semantics and we are writing a program, how do we understand
753200	755600	what this program does?
755600	763640	Firstly, we are running this imaginary machine in our minds, and we are going like, this statement
763640	768680	will do this, then this statement will do this, will change these variables, so I have
768680	771480	to keep in mind which variables, right?
771480	776920	I mean, this is, some people are very good at this, and some people are very bad at this.
776920	780960	I am bad at this, okay?
780960	788640	And I have seen people who think more like machines, and they can do very quick programming,
788640	799280	you know, and say, they, but I think ultimately, you know, none of us is as good as a computer,
799280	802560	at that kind of game, right?
802560	807960	We shouldn't try to beat the computer at their games, we should try to, the computer is to
807960	812600	beat us at our games, let's see them compete with us, right?
812600	816480	Not the other way around.
816480	821960	And math is this ancient language, thousands of years, right?
821960	828440	And it was developed long, long before we had computers, it was developed by humans,
828440	831920	for humans to communicate about ideas, right?
831920	841120	It's very important, so you know, we cannot dismiss math so easily as a language.
841120	844560	So let's talk about functional programming.
844560	850280	Functional programming, and I want to like start explaining a little bit of this mathematical
850280	852200	semantics, right?
852200	860480	So in functional programming, we deal with types and functions, right?
860480	866840	And like the simplest mathematical model for a type is that a type is a set of values,
866840	868920	so set theory, okay?
868920	874200	So that's a branch of mathematics that talks about sets, okay?
874200	876760	Fine.
876760	884120	Functions in this model correspond to functions between sets, so it's like, you know, give
884120	889080	me this element of a set, I'll give you that element of a set.
889080	896400	And in this kind of theoretical mathematical view, really, we are not talking about how
896400	901840	the function is evaluated, this is what computers do, they evaluate this function, but we first
901840	910080	concentrate on the definition of a function, like what is actually happening if I give
910080	913840	you this argument, what will you return, right?
913840	920920	In mathematics, we don't really deal with time, like how long will it take to calculate
920920	921920	this value?
921920	922920	It doesn't matter.
922920	928800	First, we have to start by understanding this value corresponds to this value.
928800	935400	So function is just a mapping of values to values, between different types in general,
935400	937560	right?
937560	945400	But this is really, no mathematicians, that's a funny thing, mathematicians also consider
945400	951800	set theory as sort of an assembly language of mathematics.
951800	955200	Mathematics also has these levels of abstraction, right?
955200	957880	Building higher and higher levels of abstraction.
957880	965800	And set theory turns out to be this really low-level assembly language of mathematics.
965800	973080	And mathematicians recently started, tried to avoid using set theory so much as they
973080	981080	used to, like there are new branches of mathematics, like homotopy type theory and category theory,
981080	986480	that try to avoid using the assembly language, so even they are going a little bit higher.
986480	995180	So I think we could also go a little bit higher and think of program semantics in terms of
995180	997980	category theory rather than sets.
997980	1003980	And sets form a category that's fine, you know, and sort of like a lot of our intuitions
1003980	1008500	about category comes from set theory.
1008500	1014820	So for most purposes, like we think about an example in set theory and we sort of try
1014820	1022880	to recast it into categorical terms for programming, okay?
1022880	1029160	So in a categorical view, category theory simplifies these things tremendously because
1029160	1036080	it says there are only two things, objects and morphisms or arrows between objects.
1036080	1037080	That's it.
1037080	1047040	And it doesn't even specify what these objects are, what these arrows are.
1048040	1055880	The mapping between category theory and programming is just this, functions that we use in programming,
1055880	1061800	so here function meaning what we program, right, in a language.
1061800	1068800	These are the arrows between objects and the objects are types, like you have integer type,
1068800	1074840	you know, tree type, list type, whatever type you are using, okay?
1074840	1077480	These are your objects.
1077480	1087080	But the important difference between the set theoretical view and categorical view is that
1087080	1090200	it's a change of perspective.
1090200	1097680	In set theoretical view, you define properties of sets by talking about elements of sets,
1097680	1098880	okay?
1098880	1104040	In categorical view, you shrink the whole set to a point.
1104040	1108200	You say, I cannot look at the structure of the set.
1108200	1109360	It's forbidden.
1109360	1114120	So it's like, you know, in functional programming, there are certain things that are forbidden,
1114120	1115120	right?
1115120	1119160	Like you are not supposed to modify a variable, right?
1119160	1123280	And that forces us to change perspective, right?
1123280	1128480	We come up with these persistent data structures and so on, right?
1128480	1131240	Because we are forbidden to do certain things.
1131240	1136640	So if you switch this perspective that you are forbidden to talk about elements of sets
1136640	1143200	or talking about values, you know, then suddenly you have to rethink everything and say, so
1143200	1147000	how do I describe different kinds of sets?
1147000	1152440	You describe them by their interaction with other sets, which in category theory means
1152880	1155160	arrows.
1155160	1164520	So you can describe the properties of objects by talking about arrows, the arrows that are
1164520	1171960	incoming into these objects and the arrows that are outgoing from these objects, okay?
1171960	1174720	And that's a very interesting way of looking at things.
1174720	1180720	It's like, tell me who your friends are and I'll tell you who you are, right, exactly
1180720	1181720	this way.
1181720	1186320	Instead of interviewing you, I'm just interviewing your friends and I can learn much more about
1186320	1189240	you, right?
1189240	1194840	But in principle, we just want to be able to express the same things we can express using
1194840	1201180	elements of sets as we can do with arrows, okay?
1201180	1206760	So this is like a very quick recap of the definition of a category.
1206760	1212520	You've heard it several times and Daniela talked about what the category is.
1212520	1220360	So objects and arrows and in parentheses, I say, what's your model for this?
1220360	1224760	Like, oh, let's think about types and functions in programming, right?
1224760	1229960	But categories are all kinds of different categories, right?
1229960	1232520	But that's the one important for us.
1232520	1238000	I'll talk about another category that's not exactly types and functions later, the
1238000	1241440	functor category.
1241440	1245040	The most important thing about arrows is that they compose.
1245040	1247880	This is why category theory is all about composition.
1247880	1254400	There's nothing more in category theory but this composition, if two arrows match end
1254400	1262500	to end from A to B and B to C, then you can go from A to C. That's it, right?
1263500	1265100	And we want these properties.
1265100	1267580	We want the associativity of composition.
1267580	1274220	So composition here is this little circle that's how mathematicians know they did.
1274220	1282780	In Haskell, it's a dot and I guess in Scala, it's compose, right?
1282780	1284500	And there has to be an identity.
1284500	1291300	Every object has to have an arrow that goes from the object back to itself.
1291300	1297700	It's sort of, you can say this is an arrow that does nothing, but you cannot say it does
1297700	1304940	nothing because an arrow doesn't do anything to an object because objects don't have structure.
1304940	1307900	They are just these points, right?
1307900	1316380	So doing nothing that doesn't even make sense, but you can say that if you compose it with
1316380	1320820	something else, then it does nothing to composition.
1320820	1325100	So you compose ID with F, you get back F.
1325100	1328100	You compose F with ID, you get back F.
1328100	1332140	So composing with ID doesn't change anything.
1332140	1335500	Okay, so now let's get to work, okay?
1335500	1344100	We want to define some very simple things that we know from set theory or from type theory,
1344100	1348940	from programming, some data types, okay?
1348940	1352060	Using purely categorical language.
1352060	1356060	So the first data type is void.
1356060	1362620	This is not a type that you would use normally every day.
1362620	1364700	It corresponds to an empty set.
1364700	1368620	So what kind of type it is?
1368620	1373180	There's not much that you can do with it, right?
1373180	1377460	But it's interesting as like a boundary case, right?
1377460	1385380	So from point-of-view set theory, we are describing an empty set, no elements, okay?
1385380	1389540	But in category theory, since we cannot talk about the elements, we don't know what it
1389540	1392400	means no elements, right?
1392400	1395060	We don't know what elements are.
1395060	1398860	So we have to define it using arrows.
1398860	1407420	And defining something using arrows in category theory means saying something universal, meaning
1408420	1414940	you have to tell me about the relationship of this object with the rest of the universe,
1414940	1418660	with every other object in the category.
1418660	1423700	Mathematicians are not afraid of infinities, you know, it's like you have infinitely many
1423700	1426660	types, possible types, right?
1426660	1431380	We are talking not only about the types that you use from day to day in programming, we
1431380	1437860	are talking about all possible types that you can invent and describe, right?
1437860	1443980	Lists, cues, trees, whatever, right?
1443980	1445140	All these types.
1445140	1451780	So there is this universal property, and in category theory, the object that has this
1451780	1454780	property is called the initial object in a category.
1454780	1457620	Not every category has an initial object.
1457620	1462060	category of sets has an initial object, which is an empty set, okay?
1462060	1472060	And the universal property of this object is that it has an arrow going to every single
1472060	1475500	other object in the category.
1475500	1479980	Moreover, there is only one such arrow for every object.
1479980	1484060	So like you pick one object, this one, okay?
1484060	1488940	There has to be a single arrow going from my initial object to this object.
1488940	1497740	Not two arrows, not three arrows, not zero arrows, one, okay?
1497740	1509340	And this is a translation to Scala that was done by a friend of mine.
1509340	1513420	I wrote it in a Haskell and it translated.
1513420	1523860	So when we are defining data types in these categorical terms, it's usually a definition
1523860	1529780	consists of two parts, because we have to say about the arrows that are coming into
1529780	1535220	the object and something about the arrows that are outgoing from this object.
1535220	1540740	So the arrows that are coming to an object, we call them constructors, right?
1541100	1547820	It's like you take some type or a bunch of types and you construct my object, right?
1547820	1549900	So these arrows are functions, right?
1549900	1555260	So you have a function that takes a bunch of objects and produces my object.
1555260	1556660	That's a constructor.
1556660	1564060	So incoming arrows are constructors and in mathematics it's called introduction rule.
1564060	1567700	Introduction rule corresponds to what we say a constructor, right?
1567700	1573060	So there is no possibility of constructing an empty set.
1573060	1574060	What does it mean?
1574060	1575900	What does it mean to construct an empty set?
1575900	1584660	It means to write a function that would return an element of an empty set, okay?
1584660	1589900	In set theoretical, there's no way you can write a function that would return an element
1589900	1593340	of an empty set, because an empty set has no elements, right?
1593340	1600780	So there is no introduction for type void.
1600780	1607900	The other, the outgoing arrows, okay, this is called the elimination, okay?
1607900	1615140	So like if you give me an object of type void, what can I do with it?
1615140	1625180	Eliminate the object, well, in a sense by transforming it into something else, right?
1625180	1631340	So I need to know what kind of arrows are outgoing from this object.
1631340	1639260	And for the initial object, you know, all we know is that there is a single arrow to
1639260	1641220	any other object.
1641220	1644660	So this is what you would say in Scala.
1644660	1651460	There is a unique function for every type A, there's a function called absurd.
1651460	1653220	So it's a polymorphic function, right?
1653220	1654820	Because it works for any type.
1654820	1660860	It's a polymorphic function, absurd, that takes a void and produces an A.
1660860	1662940	How does it do it?
1662940	1667540	Well, don't ask me how it does it.
1667540	1672740	Just give me an element of void and I'll give you an element of A, okay?
1673740	1678740	So that's a kind of tricky thing, yes?
1678740	1681740	So the question, what do you think about including self?
1681740	1686740	So if void doesn't have a structure, including self?
1686740	1698620	Oh, oh, including self, it means every object in a category theory has to have the identity
1698620	1701100	arrow, including this one.
1701100	1703140	So it has an identity arrow.
1703140	1708620	An identity arrow is an example of a function that takes a void and returns a void, okay?
1708620	1715300	Well, so this is like, yeah, I mean, if you give me a void, I'll return you a void.
1715300	1717700	And I can even implement this function.
1717700	1720900	Here's an element of void, I'm returning it back to you.
1720900	1721900	Yes?
1721900	1725180	If it doesn't have inbound arrows.
1725180	1730380	I didn't say it doesn't have inbound arrows.
1730380	1731380	I didn't say that.
1731380	1733660	I said it has a unique outgoing arrow.
1733660	1735660	It didn't say anything about inbound arrows.
1735660	1741020	If you make an absolute, is it a strategy for a method that don't take an item of that
1741020	1742020	rule?
1742020	1743020	No.
1743020	1744020	Is it a strategy?
1744020	1745020	No.
1745020	1746020	Is it a strategy?
1746020	1747020	No.
1747020	1748020	Is it a strategy?
1748020	1749020	No.
1749020	1750020	Is it a strategy or not?
1750020	1751020	No.
1751020	1752020	Is it a strategy?
1752020	1759860	Well, it's, I mean, from the point of view of mathematics, right, like if you try to
1759860	1762260	do it in set theory, okay?
1762260	1768220	So how many functions are there from an empty set to another set?
1768220	1771100	There's only one, okay?
1771100	1776380	It doesn't matter what it does, right?
1776380	1780460	Because you can never call it, okay?
1780460	1788260	I mean, it's a typical mathematical thinking, but there's an interesting thing about this,
1788260	1797140	because there is a one-to-one correspondence between category theory and logic and type
1797140	1798300	theory.
1798300	1806060	So, logically, this corresponds to the statement that from falsehood, void corresponds to
1806060	1809420	falsehood in logic, okay?
1809420	1815260	So from falsehood, you can derive anything, right?
1815260	1821260	This is why this function is called absurd, okay?
1821260	1822260	Next one.
1822260	1824420	Next one is a little bit more useful.
1824420	1826660	It's called unit, okay?
1826660	1828500	The type is called unit.
1828500	1838180	In set theory, this corresponds to a singleton set, a set that has only one element, okay?
1838180	1841540	So this is type unit, also in scalar, right?
1841540	1843260	There is a type unit.
1843260	1848140	And it has a single element, I don't know, is that what you call this element?
1848140	1849140	Yeah?
1849140	1852580	Okay, okay, just like in Haskell.
1852580	1856980	In Haskell, this type also is called bracket, bracket, right?
1856980	1861540	So this is like the opposite of the initial object.
1861540	1863460	It's called a terminal object.
1863460	1866300	And by opposite, I mean, it's dual.
1866300	1871660	So actually, in category theory, you have this duality, like whatever definition you
1871660	1876740	come up with, you can just invert all the arrows and you get something else for free.
1876740	1881780	So here we are just inverting the arrows and we're saying, okay, the universal property
1881780	1888260	of a terminal object is that there is a unique arrow from any type to it, okay?
1888260	1892740	From any object, from any type.
1892740	1897540	So now this guy will have an introduction rule, right?
1897540	1904060	Which says that for any type, a, you can produce a unit.
1904060	1907100	How is this function implemented?
1907100	1909540	It just ignores the input, right?
1909540	1914300	And just returns this unit because it can always produce the unit.
1914300	1921100	The element of the singleton set called the unit, right?
1921100	1922740	So this is very easy to implement.
1922740	1926260	It's like, we cannot implement all these functions, right?
1926260	1927740	That's great.
1927740	1929580	The elimination rule.
1929580	1934580	And here we can clearly see that, you know, I'm talking about incoming arrows.
1934580	1937660	It doesn't mean that there are no outgoing arrows.
1937660	1942500	In fact, there are lots of outgoing arrows from it.
1942500	1948780	The elimination rule is that if you have a unit, you can have a function to any other
1948780	1949780	type.
1949780	1955020	In fact, you have many functions depending on the type.
1955020	1959500	What does a function from a unit to a type do?
1959500	1963420	It picks one element from this type, right?
1963420	1970660	So if you give me a unit, I can define a function to integer that returns 7.
1970660	1976140	I can define another function from a unit to integer that returns 42.
1976140	1978000	And so on, right?
1978000	1983040	So this is actually a pretty useful thing because we are not supposed to talk about
1983040	1984800	elements.
1984800	1993720	But if we want to pick an element from a type, we can always cheat and say, okay, I cannot
1993720	1994720	pick an element.
1994720	2000560	But I can say that there is a morphism or arrow from unit to this, okay?
2000560	2004600	So instead of picking element, you pick a morphism.
2004600	2008760	Form is the same as arrow, okay?
2008760	2013960	Now for something really interesting, product.
2013960	2019280	So product, in set theory, this is just Cartesian product or a set of pairs.
2019280	2026960	So you have two types, right, and you produce a pair type from these two types, right?
2026960	2034840	So the universal construction for this thing is kind of interesting because, like, what
2034840	2039680	is the property in terms of arrows of a product?
2039680	2046760	The only thing we can say that there have to be two arrows from a product, one going
2046760	2052480	to the type A and one going to type B, if you have a product of A and B, right?
2052480	2054560	These are called projections, right?
2055040	2061080	Like, if you have a pair of integer and bull, then you can project an integer.
2061080	2065560	And I think this function called underscore one in Scala, yeah?
2065560	2066440	Okay?
2066440	2069000	Good translation, and there's underscore two.
2071880	2080600	So we know, but what else can we say about a product that would identify it from many,
2080600	2085320	many other possible objects in the universe, right?
2085320	2089480	Well, so we say, okay, well, let's try some other object.
2089480	2092320	Let's say C, okay?
2092320	2095640	Suppose that C has these two projections also.
2095640	2101080	So we know that the candidate for a product has to have these two projections, right?
2101080	2105120	And the only thing we know about these projections is that there are arrows.
2105120	2110040	So there is an arrow F to A and there's an arrow G to B, okay?
2111600	2118320	So out of all these candidates, we can pick the best one.
2118320	2124360	So look at all possible candidates, all possible types that have a projection on A and B.
2125880	2127120	Pick the best one.
2127120	2129160	How do we pick the best one?
2129160	2134120	Okay, the best one is the one that for any other type,
2134120	2140120	there's a unique arrow going to this type, okay?
2141160	2146680	So like, for instance, you come up with a candidate that say,
2148480	2152440	a triple A, B, and C, okay?
2153720	2159120	Let's say, well, the pair A, B is better than triple A, B, C.
2159120	2159920	Why?
2159920	2168400	Because there is a unique function H that just picks the pair from the triple, right?
2168400	2170640	Just discard C and picks A, B.
2172140	2177840	And this function has this property that we can express in terms of composability
2177840	2183360	that this arrow composed with this arrow gives me this arrow.
2183360	2186400	And this arrow composed with this arrow gives me this arrow.
2187400	2191200	So if I go through H and then project the first component,
2191200	2192800	it's the same as going through F.
2193800	2197720	So, this is a universal property.
2197720	2202400	From all the objects, I picked the best one that has this property
2202400	2206520	that any other is decomposable into it, okay?
2207560	2211880	And this might seem like really a crazy way of defining things,
2211880	2215960	because like, how would you write a program to do this?
2215960	2228160	Well, let me write a big loop in which I go over all possible types in my type system, right?
2229040	2230200	It's crazy, right?
2230200	2232040	There are infinitely many of them.
2232040	2238960	And then for each of these types, see if I have arrows going to A and B, right?
2238960	2244680	And then from all these, see if I have a unigarrow going to A, B.
2244680	2248720	And if this is true, then I had my product.
2248720	2254720	If it's not true, then I try a different candidate, and so on forever, you know?
2254720	2256800	But there is no time in mathematics.
2258000	2263160	Yeah, I think I'm not even going to get through half of my presentation.
2268160	2274640	Okay, so here it is written, you know, F is from C to A, G is from C to B.
2275360	2280840	And H can be defined, you know, like as programmers, we can define this H, you know,
2280840	2283520	F acting on C paired with G acting on C.
2284280	2287280	That's the solution of this problem, right?
2288120	2293680	And of course, I have to say what is the introduction and what is the elimination?
2293680	2300720	The introduction, you have to have, in order to produce a pair, you have to have A,
2300720	2304160	and you have to have an element of A, and you have to have an element of B.
2304160	2308960	You need both of them to create a pair, right?
2308960	2312560	So that's the constructor of a pair, very simple.
2313840	2320800	The elimination rule is these two arrows from A to B.
2320800	2324080	So if you give me a pair, what can I do with a pair?
2324080	2330800	Well, I can project it, I can extract the first part of the second part, that's all I can do.
2330840	2334960	And then I can do with this stuff more, you know, more interesting things.
2334960	2336840	But I always start by projecting.
2338840	2342680	And this defines all the product types.
2342680	2348400	This is why they are called product types, because they come from a product.
2348400	2354320	Things like pairs, tuples, records, and so on, right?
2356280	2360000	And of course, there is a dual to it, a sum type, okay?
2360000	2362640	Now you will understand why these things are called sum types.
2362640	2365800	They are called also a coproduct.
2365800	2370840	In categories here, they are called a coproduct, because they are dual to a product.
2370840	2378440	And it's just the same picture, but I took the upside down and reversed all the arrows, okay?
2378440	2385240	So a sum type, an example is either A and B, okay?
2385240	2389320	That's like the simplest sum type of two types.
2392920	2398040	Instead of having these projections, it has injections left and right.
2398040	2402560	So left takes A and produces either A and B, right?
2402560	2406760	It doesn't need a B, it's enough that it has an A.
2406760	2411480	Or if you have B, you can produce either an A, B, and you don't need A, right?
2411480	2413440	So there are two ways of constructing it.
2416240	2424640	Now again, universal construction says either A and B is like the best of these guys that have these two injections.
2424640	2434160	Anything else that has these two injections will factorize through some unique H, okay?
2434160	2443760	So here's the factorization, like how can you define H, you know, from the type either A, B.
2443800	2447120	If you have these two injections, F and G.
2447120	2451920	So F and G here are these two injections, right?
2451920	2462720	Right, these, and here I'm defining H from either A, B to my type C, right?
2462720	2465400	And I just do case analysis.
2465400	2468920	If it's left, then F, A, if it's right, then G, B.
2468920	2470440	And I got it.
2474000	2474600	Right?
2476480	2486720	And introduction, I can introduce the type either A and B if I have A or if I have B.
2486720	2489120	There are two ways of introducing it.
2489120	2495280	The elimination is just by pattern matching, left, right.
2495280	2500800	And this is, in programming, it's usually called tagged unions, right?
2500880	2504560	In Scala, you have different name for it.
2504560	2507480	But you use the term some types, right?
2507480	2509080	So this is where they come from.
2509080	2511800	They come from some types, okay?
2516280	2519280	Monoidal category, wonderful thing, huh?
2521480	2522560	Very simple.
2522560	2526520	So actually, I told you already everything about this monoidal category.
2526520	2530640	I told you it's a category in which you have both products.
2530640	2533760	For every two elements, you can create a product.
2533760	2537960	And for every two elements, you can create a sum type, okay?
2537960	2540760	So why is it called monoidal?
2540760	2543880	Okay, let me explain why it's called monoidal.
2543880	2550480	Because this product kinda looks like multiplication.
2550480	2557040	A monoid is something that has this multiplication, essentially, or addition.
2557040	2563480	It's like a simple arithmetic, you know?
2563480	2571320	So it has this operation that operates on two things and produces one thing, right?
2571320	2575960	So this is a monoid in types.
2575960	2584080	So given two types, I can multiply them by creating a product type, right?
2584080	2586400	A pair type.
2586400	2588440	So that's my multiplication.
2588440	2594040	Now, in order for this to be a monoid, it has to be associative.
2594040	2598240	So like if I have three types, right, I can pair them differently.
2598240	2603000	I can pair B with C and then pair it with A.
2603040	2606240	Or I can pair A and B and then pair it with C.
2606240	2612840	This is not exactly the same type, like the type checker would reject this in a program.
2612840	2615760	However, these two types are isomorphic.
2615760	2619640	Meaning there is a function that takes this type to this type and
2619640	2622560	there's an inverse function that takes this type to this type.
2622560	2624400	It just rearranges stuff.
2624400	2626720	That's very simple.
2626720	2630640	So up to isomorphism, this is associative.
2631600	2635800	And the other thing that the monoid has to have is this has to have this unit.
2635800	2640920	Something that if you multiply by unit, you don't change anything, right?
2640920	2647080	And the unit in case of these types is the unit type, actually.
2647080	2649880	So this is why it's called unit type, right?
2649880	2655760	Because if you take a pair of unit and A, it is equivalent to A.
2655840	2661200	You're not adding any more information to A by pairing it with a unit, right?
2661200	2665200	It's like a redundant thing, okay?
2665200	2667120	Also up to isomorphism.
2667120	2669920	So this is why it's called a monoid.
2669920	2673560	So we have a monoidal category at our disposal.
2673560	2680720	And also, the either, the coproduct, the some types also form a separate monoid.
2681680	2687520	Here's the associativity for either, and here's the unit.
2687520	2691560	The unit for either, and this is where Void comes back, right?
2691560	2694400	This type Void is a unit.
2694400	2700080	Because if you take either Void or A, it definitely contains A.
2700080	2701360	Why do I know this?
2703120	2705840	Because try to create, you know, from Void.
2707600	2710360	Void has no element, so it will never be called.
2710920	2715680	So this one injection just doesn't exist.
2715680	2719560	The injection that would inject a Void to it sometime.
2719560	2721280	So it always has to have an A.
2721280	2726360	The only way you can construct this by providing an A, and you can extract this A.
2726360	2731560	So it's isomorphic.
2731680	2740640	So this is why we have this beautiful algebra of types.
2740640	2743680	Okay, we have a monoid with respect to product.
2743680	2745880	We have a monoid with respect to some.
2747160	2751000	They actually interact together very nicely.
2751000	2758680	So we have like a, you know, bi-cartesian monoidal category.
2758680	2763120	It's something like this beautiful name that mathematicians give it.
2763120	2766240	But this is really what we need for programming.
2766240	2770160	We need a monoidal category because we have to have some types and
2770160	2773040	we have to have product types, right?
2773040	2775120	We also have to have function types.
2775120	2777440	And that would be like the second part of my talk.
2777440	2780520	And I think I'm just gonna stop here because.
2780520	2798920	Is there enough tape, is there enough tape for the diaper?
2798920	2802320	So how about if we make like a one minute break so
2802320	2807680	that people who don't want to listen can leave and I will not be watching, okay?
2810520	2825120	Okay, so here's the way we can use this algebra of types to create.
2825120	2832040	Essentially, from this point on, we can create all types with just these tools.
2832040	2835360	Okay, this will be kind of awkward.
2835360	2838680	For instance, the type Boolean, right?
2838680	2840600	It's nice to have a Boolean type.
2840600	2843920	A Boolean type is just either unit or unit.
2845200	2849600	It means you can create it as a left thing or a right thing.
2849600	2854040	And it has no other information other than whether it's left or right.
2854040	2859280	And we call the left thing true, for instance, and the right thing false.
2859280	2861000	That's it, the sum type.
2861000	2863800	It can either be true or false, right?
2863800	2868840	So here's the sealed, straight, bull, okay.
2868840	2874720	So this is how you do sum types in Scala, right?
2876120	2882160	Type natural, you would have to do infinitely many.
2882160	2893640	But type natural number is either one or two or three or four and so on.
2893640	2896040	So it is a sum type.
2896040	2901080	So essentially having sum types, and if you apply it infinitely many times,
2901080	2904120	you'll get natural numbers.
2904120	2905920	Okay, this is a very awkward definition.
2905920	2908720	There are better definitions than that, right?
2908720	2913280	But just to show you the idea, the option type, right?
2913280	2917880	The maybe type, the option type, a little bit more interesting.
2917880	2922760	It's a sum type, it's either of unit and A.
2922760	2928080	So it is a polymorphic type, parametrized type by some type A, right?
2928080	2933440	So you can either construct by providing unit, which you can always do.
2933440	2938560	And that's the nothing part in Haskell.
2938560	2940040	What do you call it in Scala?
2940040	2945080	None, none, okay, so none, that corresponds to none.
2945080	2950560	And this corresponds to what you call sum, okay, none, sum.
2950560	2955760	Nothing just in Haskell, same thing, right?
2955760	2960480	Then you can go into recursive types, you can define a list.
2960480	2963080	List is a sum of two things.
2963080	2969400	Unit here, that signifies empty list.
2969400	2972600	You can construct an empty list, right, always, right?
2972600	2977440	And contains no information, so you can construct it from unit.
2977440	2983080	You always have at your disposal, because the units are just everywhere.
2983080	2989840	You just pull them from the air, and you create a list using unit, and
2989840	2991840	that's an empty list.
2991840	2997840	Or you can create it from a product here, right?
2997840	3002280	Of A, which will serve as the head of the list.
3002280	3006960	And the whole other list, which is the tail of the list, right?
3006960	3014360	So here we have a sum and a product together, and it's recursive, right?
3014360	3017520	And this is how you could express it, okay?
3018960	3022880	So this is like the skeleton of a whole type system.
3022880	3026760	Everything else is just syntactic sugar on top of this.
3026760	3030120	That's very interesting to know, right?
3031040	3037640	Okay, so now you've heard the word functor so many times today, right?
3037640	3039520	And yesterday.
3039520	3044240	Okay, so let me just introduce the functor categorically.
3046760	3050480	So in general, the functor is a mapping between categories.
3050480	3055760	So mathematicians are always interested in how things that have
3055760	3062440	a certain structure relate to another thing that has a similar structure, right?
3062440	3069080	And a functor, in this case, takes one category and
3069080	3073080	embeds its structure into another category.
3074600	3077120	So it's a mapping from category to category.
3077120	3081720	So if it's mapping a category, and the category is nothing else but objects and
3081720	3086800	arrows, so naturally it has to map objects and arrows.
3088160	3092400	So it maps objects to objects and arrows to arrows, right?
3092400	3097360	And because it has to preserve the structure, what does it mean structure?
3097360	3101560	It means that if you have an object A and an object B, okay?
3101560	3107160	So A goes into F A, that's an object F A, this is an object F B, right?
3107160	3113000	If there is an arrow between A and B, then this arrow has to be mapped into
3113000	3115000	another arrow, right?
3115000	3119160	But it cannot be an arbitrary arrow anywhere else, right?
3119160	3124880	It better be an arrow that connects F of A to F of B, right?
3124880	3129760	Because if these things are connected in this category,
3129760	3134120	they must be connected in this category as well, okay?
3134120	3140640	The factor may do things like collapse two objects into one.
3140640	3144280	It can collapse multiple arrows into one and so on.
3144280	3148600	But as long as you have a connection in one category, it will preserve this connection.
3148600	3152240	And it will also preserve the unit arrows, and
3152240	3155040	it will preserve the composition of arrows, okay?
3156680	3160880	So how does this translate into programming?
3161120	3166040	So first of all, in mathematics, the most general functor goes from one category
3166040	3167160	to another category.
3169160	3173760	In programming, most of the functors will go from the same category to the same
3173760	3176680	category, they are called endo functors.
3176680	3180920	Endo means inside, like endoscopy, you know.
3180920	3190680	Yeah, so we have a functor that goes within the category.
3190680	3198240	So it takes a type A and maps it into a type list of A, okay?
3198240	3202880	So it takes a type integer, maps it into a list of integer.
3202880	3206960	It's mapping between types, this is a very important thing.
3206960	3208960	Many people get confused because of this.
3208960	3214120	It's not mapping of elements of these sets, it just maps the whole set into the whole set.
3214120	3219920	It's like, say, here's an integer set, or integer type,
3219920	3224680	maps it into a list of integer type, type to type.
3224680	3226320	Like a parametric type, right?
3226320	3228480	A type constructor, right?
3228480	3230000	Okay, so type constructor.
3233840	3241600	So the type constructor part of it is that this F with a bracket in Scala, right?
3241600	3243000	So that's a type constructor.
3243000	3246520	It takes a type and produces a type F of A.
3246520	3248560	Takes A, produces F of A.
3248560	3253000	So this is the part of acting on objects, the blue arrows.
3253000	3259440	And we have to separately define how it acts on arrows.
3259440	3263680	So it takes an arrow F, that's this arrow F.
3263680	3265960	This arrow goes from A to B, right?
3265960	3267880	From A to B, okay?
3267880	3277520	And maps it into an arrow that takes F of A, this guy, and returns F of B, this guy, okay?
3277520	3281800	So if you draw a picture, this is really very simple, right?
3281800	3285320	So it takes this arrow and maps it into this arrow.
3285320	3287240	And you have to provide this function.
3287240	3291920	For every function, you have to provide part of the definition of a function is how does
3291920	3295440	it act on arrows, right?
3295440	3299760	Maybe there are sometimes factors that have different actions on arrows,
3299760	3305920	the same action on an object, but differ by acting on arrows, okay?
3305920	3310440	So I guess this is, okay, I think you guys call it map, not F map.
3310440	3317720	Haskell calls it F map, for historical reasons, really, no, no.
3317720	3320960	So this is how it acts on lists, right?
3320960	3322120	But you've seen this before.
3323120	3327840	So why am I talking about functors?
3327840	3331360	And now I have to introduce adjunctions between functors.
3331360	3339840	I have to introduce adjunctions between functors because there is one extremely important example
3339840	3347520	of an adjunction that's very useful in programming, especially functional programming.
3347520	3357800	And so little motivation, right?
3357800	3359000	You know what types are.
3359000	3361040	So I told you about all these types.
3361040	3363440	They are objects.
3363440	3366800	Separately, I said we have arrows.
3366800	3369680	They correspond to functions, okay?
3369680	3380680	But you know that, like when I say F from A to B, I mean a type of a function, right?
3380680	3383280	A type of a function.
3383280	3389640	But we said types are objects, and this is an arrow, right?
3389640	3392560	So how is this connected?
3392560	3401040	So you have to have an object inside the category of types that corresponds to the set of arrows
3401040	3403080	between objects A and B.
3403080	3411040	So for every pair of objects A and B, there is a set of arrows between them, but there
3411040	3421160	has to be also an object, separate objects, that represents the set of arrows, right?
3421160	3426800	And that's called the type of function, function type.
3426800	3432960	Not every category will have this, but the category that we are interested in, in which
3432960	3439120	we can program, must have this object for every pair of A and B, okay?
3439120	3445840	And you know, this object can be introduced by another universal construction, I'll show
3445840	3446840	you in a moment.
3446840	3453040	The easiest way of introducing it is through an adjunction of two functors, in particular
3453040	3456200	two endo functors that we are interested.
3456200	3461720	So an adjunction is not one functor, but a pair of functor.
3461720	3466440	One functor adjoins to the other functor, okay?
3466440	3471720	So one functor goes from one category, from this category to this category, and there's
3471720	3476280	another functor going this way, okay?
3477280	3482040	If you have two functors going in the opposite directions, you might say, okay, like if one
3482040	3487320	is the inverse of another, that means that these two categories look the same, right?
3487320	3490160	There is like an isomorphism of categories.
3490160	3498240	But it's much more interesting if these are not inverses of each other, but they act in
3498240	3504680	a very interesting way on arrows, okay?
3506880	3519800	So we say that the functor f is left adjoined to the functor u, if you draw the set of arrows
3519800	3529280	from fA to B and the set of arrows from A to UB, they are isomorphic.
3529280	3536080	Having isomorphic set of arrows tells us about how these two objects are related, right?
3536080	3538920	They are related in a particular way.
3538920	3545400	If they have the same set of arrows going between them, right, it means that their relationship
3545400	3547360	is very similar.
3547360	3553520	And you can think of this as like you are preparing an argument for a function, you know, using
3553520	3563360	functor f, and here you are modifying the output of a function by applying functor u.
3563360	3570160	So if you prepare arguments to functions, or you modify the output of functions, you
3570160	3577640	get this isomorphism between these two, okay?
3577640	3586000	And when you hear this first time, it's really like kind of weird, like why is this so interesting?
3586000	3589680	So I'll give you one example, and there are many, many interesting examples, but I'll
3589680	3595400	give you one example that like pops out immediately.
3595400	3605600	So let's pick the functor f acting on A, it pairs it with C, okay?
3605600	3612400	So I take the type A and I pair it with C, I get a pair type.
3612400	3614400	So that's one functor.
3614400	3627080	The other functor is acting on B, it creates a type of function from C to B, okay?
3627080	3628080	Nothing yet, right?
3628080	3633240	It's like, oh, okay, all right, all right.
3633240	3636360	Now let me write this isomorphism between these.
3636360	3645440	So like if I prepare my argument by pairing it with C, okay, and I have a function on
3645440	3656280	arrow from A, C to B, this is equivalent isomorphic to all these functions that take A without
3656280	3666320	any preparation, but modify the argument B by putting this as an output of a function
3666320	3670520	that takes C, okay?
3670520	3676720	Now if you look at it, this is called curring, right?
3676720	3684080	Curring, a function that takes a pair is equivalent to a function that takes one element and returns
3684080	3688680	another function that takes the second one, okay?
3688680	3697120	So this is how curring arises from an adjunction, right?
3697120	3701760	This is this adjunction, oh, this is a general adjunction, right?
3701760	3704840	This is this particular adjunction.
3704840	3712800	And in category theory, this function type, this C to B, because you can take this as a
3712800	3719280	definition of the function object, because this is a type of functions from C to B. You
3719280	3730080	can say this, if you have in your category pairing or product, then you may, if you have
3730080	3738000	this adjunction, you will be able to define what it means to have a function type, right?
3738000	3741800	And the category in which this is defined is called closed.
3741800	3748080	So taking together, we have a Cartesian closed category.
3748080	3753360	Cartesian because it has a Cartesian product, closed because it has a function type.
3753360	3758920	And we are operating a Cartesian closed category when we are doing programming, right?
3758920	3764400	So next time somebody tells you about Cartesian closed categories, you know, oh, yeah, this
3764400	3768240	is what we use in our everyday programming.
3768240	3774040	This is what, yeah, this is our bread and butter.
3774040	3779680	In mathematics, this is called an exponential, A to B. Function type from B to A is called
3779680	3786640	A to the power of B. And it actually, I'm not going to go into it, but actually, like
3786640	3793520	if you look at it as an exponential and combine it with multiplication being product type,
3793520	3801920	sum type using either and exponential, you can like write all these identities from high
3801920	3809080	school like A plus B to the power of C is A to the power of B plus and so on.
3809080	3816280	All these identities actually work on types, which is, on one level, it's a weird thing,
3816280	3817280	right?
3817360	3825520	Another level, you see the repetition of the same patterns in mathematics all the time.
3825520	3831560	And that's an interesting thing to think about, you know, free time.
3831560	3834000	So I'll show you just this diagram.
3834000	3838320	Function types can be defined using universal construction, right?
3838320	3843440	This is like the diagram that, it's a little more complicated than defining a product, but
3843440	3846140	it can be done, okay?
3846140	3849740	And of course we can say, what's the introduction and elimination?
3849740	3854740	The introduction of function is called lambda, okay?
3854740	3861460	So if you have an object of type A and you have an expression of type B, then lambda
3861460	3868380	X E of X is of the type A to B, okay?
3868380	3871780	And elimination is called eval.
3871780	3878460	So you eliminate a function by providing an argument and getting the result.
3878460	3888380	Okay, so I'll have to speed up now.
3888380	3891820	Natural transformations are extremely important.
3891820	3896060	We know them as polymorphic functions, okay?
3896060	3901980	In category theory, they are just mappings between functors.
3901980	3913260	So if you have two functors, F and G, you pick an object A and you map it to F A and
3913260	3915660	you can map it to G A.
3915660	3923020	A natural transformation is when you pick these arrows, for every F A G A, you pick one arrow.
3923020	3927620	So you pick a function that depends on A, right?
3927620	3930660	You keep changing A, you get different functions.
3930660	3932660	So it's a polymorphic function.
3932660	3939860	It's a polymorphic function whose argument is a factorial and whose result is factorial.
3939860	3942060	So here's an example of something like this.
3942060	3949660	You take a list and you produce an option, right?
3949660	3951260	Did I rewrite it?
3951260	3959260	Yeah, this is, yeah, okay, non-sum, okay, yeah, yeah.
3959260	3964740	It returns an option, right?
3964740	3967340	Why is it important to have natural transformations?
3967340	3974180	Because now I can say, and this is like a typical thing in category theory, okay, I have
3974180	3984860	functors and I have natural transformations which transform one function to another, okay.
3984860	3988100	Are these arrows between functors?
3988100	3990940	Maybe I have a category, right?
3990940	3996940	Like what if functors are objects and natural transformations would be arrows between these
3996940	4000260	objects, okay.
4000260	4001580	What do I have to show?
4001580	4007020	I have to show, if I want to have a category, I would have to show that there is a composition
4007020	4013380	and of course there is a composition of these arrows because if I have another functor H,
4013380	4018420	you know, I'll just compose these two and I get a third one, right?
4018420	4029900	There is an identity and of course there is associativity, right?
4029900	4033660	An identity, so that works fine, right?
4033660	4043540	So I can construct something called a functor category in which objects are functors and
4043540	4045780	arrows are natural transformations.
4045780	4053420	So this is an example of a category that's not slightly different than what we were talking
4053420	4055620	about before, right?
4055620	4060860	But it is a very important category, a functor category.
4060860	4066100	Now in our case we talk about endofunctors and endofunctors also being functors form
4066100	4068260	a category, right?
4068260	4075060	So they form a category, it's called, that's how mathematicians write it, it's a category
4075060	4081740	of functors from C to C, okay?
4081740	4088620	So the final minute, the yoneta embedding, okay?
4088620	4091920	The yoneta embedding.
4091920	4099020	So this is the kind of thinking that can break your brain a little bit, right?
4099020	4105260	But it shows you the power of categories here, this is like, because there is this notion
4105260	4114660	that we have replaced contents of objects, we replace it with arrows.
4114660	4125820	Like we say, everything we can say about the object can be said using arrows, right?
4125820	4132860	Objects shrunk to a point and everything, all its properties are expressed using arrows.
4132860	4139820	So the next step would be to say, well, instead of talking about an object, why don't I talk
4139820	4146860	about all the arrows that are, let's say, impinging on this object, okay?
4146860	4158220	Like if I take the totality of arrows in my category that end in this object, do they
4158220	4166300	contain exactly the same information as the object itself, right?
4166300	4170820	Can I replace this object by just talking about the totality of arrows that come to
4170820	4173180	this object?
4173180	4179540	And the answer is yes, and it's called the yoneta embedding, okay?
4179540	4183100	So let me go through, like, steps, right?
4183100	4188700	So first of all, how do I even define the totality of arrows coming to an object?
4188700	4196260	Well, I'll start with a, so I'm talking about object A, that's my object, okay?
4196260	4204780	Let me pick another object X and have a totality of arrows from X to A to begin with.
4204780	4206420	I have to start somewhere, right?
4206420	4207780	So let me take these arrows.
4207780	4210780	What do they, they form a set.
4210780	4220380	They form a set of arrows, set of arrows from X to A, okay?
4220380	4222260	But this is just one X.
4222260	4227340	If I want to talk about totality of arrows that go to A, I have to vary X.
4227340	4232380	I have to, like, go to every possible X in my category, right?
4232380	4238060	So if I start varying X, then I get different sets here.
4238060	4245260	So this is for X, you know, I pick Y, there will be from Y to A, and so on.
4245260	4254580	So I end up with something that's like a mapping of X, when I vary X, to sets.
4254580	4258020	Sets are objects in the category of set, okay?
4258020	4268420	So I have a mapping that goes from X to X to A for a fixed A.
4268420	4273940	And this mapping, I define this mapping for objects, for Xs, right?
4273940	4280020	This mapping can be extended also to arrows, which means that it's really a functor.
4280020	4287100	This is a functor, if you vary X, it's called a contraviant functor, because it acts weirdly
4287100	4289980	on arrows, like the opposite of the arrows.
4289980	4300180	But it's a functor, and it's a functor from this category C to the category set, okay?
4300180	4311260	So now, for every object A, I get a functor from C to set, okay?
4311260	4312900	Keep this in mind.
4312900	4323500	From every A, I have a functor from C to set, it just takes an X and puts it into XA.
4323500	4330300	So now if I start varying A on top of this, okay?
4330300	4341580	Then I have a mapping that takes an A and creates a functor from C to set, okay?
4341580	4346780	So this is the functor category from C to set.
4346780	4352300	Here's my X, here's my A, I'm varying A to B, okay?
4352300	4358140	So for every object A, I have a functor, right?
4358140	4361700	That takes these arrows and puts it here, right?
4361700	4369860	So I have a mapping that embeds an object from category C into the functor category.
4369860	4378900	And now if I have a mapping of objects from one category C to another category, which
4378900	4384300	is a functor category, is this mapping a functor?
4384300	4389740	Turns out this mapping is a functor too, okay?
4389740	4398460	And moreover, it's action on arrows, so here's an arrow from A to B, it's action of arrows,
4399020	4404020	well, so it's action on arrows would have to be a natural transformation because arrows
4404020	4407060	in this category are natural transformations.
4407060	4411980	So there's a mapping from these arrows to these arrows.
4411980	4416820	These are just functions, these are natural transformations, right?
4416820	4424860	So this is a function from A to B, it's mapped into this natural transformation from this
4424900	4429420	functor to this functor, okay?
4429420	4437780	When I vary X, this is a functor, okay?
4437780	4443100	And the Yoneda Lemma says this mapping goes both ways.
4443100	4451260	It's actually an isomorphism, which means that this whole category C can be embedded
4451380	4460380	in the category of functors, which is called a fully faithful embedding, meaning it takes
4460380	4465780	all arrows and nothing more than maps them to all two arrows here.
4465780	4471820	So if you map A to this functor, B to this functor, all arrows from A to B go into natural
4471820	4476460	transformations from this functor to this functor, and nothing more is there.
4476460	4482500	So you can take all natural transformations, they will correspond to arrows here, right?
4482500	4489500	So you have a perfect picture of this whole category embedded in this category of functors,
4489500	4491060	okay?
4491060	4493060	And I think this is a good point to end.
4493060	4500060	Thank you.
