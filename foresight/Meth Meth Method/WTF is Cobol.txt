Hej alla! Det här är Fontes.
I dag ska jag försöka köpa.
Och det är för att det är att jag har sett mycket om köp.
Att vara, vad det kallar,
att vara fördelad nu i New Jersey eller något sådant.
Låt oss se vad Twitter säger.
Jag tror att jag har sett köp trenden.
Det här är nån av de här.
Och Kobol.
Så det ser ut som att världen är i en djur nivå för folk att förstå Kobol.
Så förstås jag ska försöka förstå Kobol.
Kobol är en av de här länge som jag har hört om hela mitt liv.
Men jag vet inte vad det ser ut som.
Så jag tänkte att jag ska försöka och lära lite Kobol nu från en absolut skratch.
Så i den här episodeen ser du mig att jag har kämpat.
Jag vet inte om det kan röra på Windows.
Jag vet inte vad det gör.
Jag har en seriöst seriös erfarenhet med det.
Så jag tror att vi ska börja och se vad som händer när jag lär Kobol.
Målet kan göra en liten människa från att lära det.
Hur vet du så?
Let's create a blank slate här och.
Get started with Kobol Windows.
Microfokus dot kom.
Never been there.
This looks like a good tutorial.
Let's just go in here and see what happens.
OK.
Well, this looks classic.
As soon as in a bit.
OK, common business oriented language.
Good from 1959 older than me nice.
What else does it say here in the website to help you learn Kobol.
Microfokus provides a range.
OK, who is who are microfokus by the way.
Per standard learning practice.
I'm not gonna invest too much time in anything.
I'm just gonna try to find the gist of everything.
OK, this looks like some typing person wrote this lot of text.
Probably useless.
Calling a Kobol program.
Special in going to be called.
What the hell is this?
OK, let's go to the hello world thing.
This is what I'm talking about.
OK.
This tutorial walks you through the steps to create your first hello Kobol world application and demonstrates the basic features of the Visual Studio integrated.
I have to use Visual Studio.
Oh, this is gonna be a long episode.
I might have it installed so let's see Visual Studio 2017.
Hey, hey, hey.
Welcome all you connected developers.
Yeah, I know that was not at all what it said.
Connect all you do.
I don't want to do that.
I have to.
Not now, maybe later.
This is the feeling right there.
A familiar environment.
Dark.
Dread and settings.
General.
I cannot pick Kobol here.
OK.
Let's take a look at this again here.
Windows 10 and later.
That's me.
From your Windows desktop.
Click start.
Visual Studio 2007.
I did that.
If this is the first time you have started Visual Studio in your machine, you're prompted to specify default environment settings.
Ah, general development settings.
That's where we are.
Good.
The windows is open.
I guess I'm going to continue.
Let's tab in to Visual Studio here.
General.
I'm just going to double check that.
OK, it's not exactly the same, but.
It's probably what they mean.
Let me resize this.
Humongous window.
OK, don't want to sign in all accounts.
My evaluation period has ended.
OK, I guess it ended in 2017.
What do you do now?
What options do I have here?
What options do I have here?
OK, what is this?
OK, I'm going to write cobalt in VS code.
OK, looks like it doesn't support cobalt by default, at least.
I guess it's not cool.
Why does this page look broken, by the way?
Not a good sign.
The end times is coming.
But I just want to get started, but why do you have to use Visual Studio normal?
Cobalt plusback.
These things are so alien to me.
It's quite interesting, actually.
Is this maybe a virus?
That icon looks so virusy.
Cobalt, acrobalt, cobalt.
Ja.
Wait a minute.
Cobalt on Linux.
OK, schnellt ändå.
Can you make a note that I'll be talking.
Are you fine?
No, I'm fine.
That was all off Cuba.
Let's have a open two window here.
I probably need to resize it a little bit like that.
It's easy to see.
Let's install it.
Hoppsam.
Yes.
Let's see where this gets us.
I'm gonna continue read this.
This looks boring.
Package management.
You should find it.
Once installed.
Is this what the code program looks like?
I guess we don't need vicious studio then.
So let's just goodbye.
And open vicious studio code.
Add workspace folder.
And...
I'm gonna add a folder called cobble hello world.
There's cobble in it.
Let's call it that.
That's a good folder.
It's an update.
I don't need this.
Let's see what happens if I just...
Copy and paste this into a cobble file.
I need to find code test.cbl.
So a new file.
I paste that in.
I'm gonna save this as test.cbl.
Let's see if it's .txt.
No thank you.
Aha.
The marketplace has extension and help with cbl files.
Let's see what we can do.
Okay, very nice.
This is the one we had up on the page here I think.
Why does this page look so silly?
Okay, let's just not use that.
It was a good lead, so thank you page.
But this is what we want to push.
Bam, install.
So this is just a source colorizer.
Let's just look through this quickly and see if there's something that we obviously want.
Autocomplete highlighting diagnostics.
We'll see what happens.
Okay, nice.
We have colors.
By the way, why are these lines there in the middle?
Sorry.
Okay.
Can I run my code program now?
Let's go in here.
We have installed all the things from Cobol and Fink.
So let's go in to this folder that we created and find out test.cbl.
Where do you have these things?
Development.
Method.
Cobol in it.
There it is.
And let's go and find what does this opencobol provide.
It probably provides a compiler of some sort.
So it looks here like we can write cobxhello.cob.
And then we get an executable called dot slash hello, or yes, called hello, that is executable.
Let's try that out.
Cob C.
No input files.
Like we have this command.
Let's clear the window.
And we write cobc minus xhello.cob.
But our file is called test.cbl.
I guess that works.
Cob C.
Cob C.
X as I think is.
Let's see what it says there.
Wow, lots of options.
X means build an executable program.
Okay.
Nice.
Clear this again.
Cob C minus x and test.cbl.
Was there something else we needed?
No, it looks like, I guess it will compile it to the executable dot hello if it's called hello.
So our executable is probably going to be called test.
Syntax error already.
Okay.
Well, that's not even a column.
Yeah, there is a line one column seven.
This doesn't look good.
One, two, three, four, five, seven.
Oh, this is where I discover those lines that I don't know what they are.
I wonder what that means.
Oh.
Hmm.
This was interesting.
So apparently everything is fine until here.
No, can't write F there.
Interesting.
I don't understand this.
Is this compiler not compatible with this tutorial?
What is going on here?
What is the first line here?
Hello, Cob.
Is that from the editor or what?
No, this is the full program, right?
Okay, it doesn't look good.
We wrote test.cbl, right?
We're going to display Chow.
Okay.
Okay, yes, some interesting things here we'll learn.
But it's not good that we can't even go past this step.
What could this be?
Okay.
We can Google this error too.
Okay, it looks like somebody had this same problem.
Go away.
Okay, I have a simple code program that is not compiling.
Can someone tell me what is wrong?
Okay, that's me.
What?
Seriously, I hate webpages.
Go away.
I have a very simple, yes, that's me.
I have purged and installed libcob1, an opencob2no effect.
Error in value index F at column 7.
Okay, that's me.
Identification division.
Let's see if that is what we had.
Yes.
What does that mean by the way?
I should probably find out.
Try this slight mod due to syntax from a limerick site.
Okay, I don't...
That is completely alien to me.
Okay, a limerick site.
Probably something that you know about when you write code.
What is the mod exactly?
Let's...
I'm just going to copy-paste this in.
I'll see what happens.
Oh, it's so good to feel like a complete beginner.
That's the exact same problem.
Let's make sure that this is actually the file that I expected to be.
Okay, yeah.
That is what we pasted.
And apparently the syntax there are here.
Really, really.
Is that it?
Ah, this is silly.
Should I add this too?
Source format free.
Maybe it is.
What do I know?
I mean JavaScript has used strict.
Let's save this, see what happens.
Okay, interesting.
Interesting.
Seem to work.
We have an executable here.
Why not test it and execute the test.
And the first number.
I don't know what the program does, but I'm going to enter the first number.
And everybody knows that the first number is one.
And the second number, that's two.
Result is zero two.
Okay.
Nice.
I know COBOL now.
I wonder what this program does.
Let's see if we can figure this out.
Example program using accept display and multiply to get.
Two single digit numbers from the user and multiply them together.
Well, you sure did do that.
The output was a little bit unexpected.
I didn't expect that leading zero.
But let's try something else.
And the first number.
What should we pick?
Three.
And second number.
Twelve.
We should see 36, right?
Oh, it can only be one digit.
Okay.
So three and nine should be 27, I think.
Yeah.
You go program.
You're a good program.
Okay.
So this was interesting.
That's something probably everybody knows in COBOL world.
That you have to write that in the top otherwise you will get a very confusing error.
It looks like this person did something similar.
Okay.
I will never again, which I stopped doing a long time ago, complain about somebody that doesn't know a specific thing in a language.
But this was interesting.
This feels just like when I was younger and I was just, what is this for?
I don't understand what this thing is for.
Why did they do it like that?
This sucks.
But now I suck.
It feels good.
Okay.
Let's go back to a tutorial and see if we can rewrite, get this to work now.
When we know this magic trick of COBOL world.
So we can do math.
That was pretty impressive.
Now we're gonna see if we can print.
Ciao!
Which is fitting.
Italy is a nice place.
We'd love to go there.
Let's compile that.
It worked.
You know what?
This source format 3 is my favorite thing in COBOL.
But I'm back here in the micro focus tutorial.
And I'm gonna continue with this one because I noticed, oh now I remember what was so funny.
I isn't there supposed to be a history menu item here somewhere.
Or they just remove that for no reason.
Okay this makes so much sense.
Thanks Google for being annoying.
Okay, I guess I can't find that page easily.
So let's just continue with this project here.
So we solved the compiling program.
And here is the reminisced remnants of what I did before.
Let's clear that out so this makes sense.
Okay.
Add a source file.
We can do that.
Because we know how to compile.
So I'm gonna create a source file called helloworld.cbl.
Just keep in line with this tutorial.
Copping that.
Creating a new file here.
Saving it.
Add hello world.cbl.
Plam, pasting this in.
No, that's not what I'm pasting in.
You can delete the skeleton problem that's created when you created a project.
We don't need to do that.
But in the code within the new file.
Navigate to the line that contains procedure division.
So since we have created it not with Witcher Studio.
We didn't get any of the skeleton things.
So I'm gonna copy that from our test file.
Into helloworld.cbl.
And looking at here.
Procedure division.
Oops.
It's here.
So it looks like this.
There's two parts of this source file.
One is this statement.
That just, I guess it tells the compiler what source file is formatted like.
Oh, source format free.
Is that the same as using this?
Let's save this and see if we can compile it.
If you compile this with x, it compiles.
Can we remove that?
I get that error we had in the beginning.
But if I add dash free.
Oh, it makes it work.
So it looks like this statement.
And that one is the same.
Okay, that's good to know.
Okay, good to know.
I wonder why that is.
And what is non free format?
I will never know.
May we find out later.
But let's get in line with this.
We should find the procedure division.
And then we press enter at the line of the file.
Let's do this.
There we go.
This creates a new line in the file and the cursor position right after the gray margin area.
I don't think we have the gray margin area.
And what is the AB area?
I don't know.
But anyway, let's go down to number six here.
Type the code to write some text in the console.
Copping this out.
Boom.
Compile.
And run.
It works. Fantastic.
I'm actually going to combine the compiling and the run stage with the double ampersons there.
That way I can just press up and run it.
And compile it at the same time.
Okay, build application.
We can do that.
Run hello world.
We have done that.
Okay, what's next?
Continue with the next tutorial, configuring the hellocobalworld application.
Okay.
Copybooks.
Okay, let's see what this is.
Tutorial configuring the hellocobalworld application.
Cobal application often consists of cobalt source files and of copybooks.
Files that include code that is copied into other programs.
That's the new concept to me.
Or at least the name copybooks.
Copybooks might not be stored in the same location as the source files.
This tutorial demonstrates how to configure a project to locate any copybooks that are not in the project directory.
This is strange to me.
Why would this be the first thing you want to learn about?
But let's just continue.
You're now going to modify and configure a hellocobalworld application,
which you created in the tutorial hellocobalworld application.
To use a copybook,
which is an external to the project.
It still feels very strange to me that this is the second thing you do when you learn a cobalt.
But who am I to judge?
This is what you're going to do as part of this tutorial.
Create a project in the same solution that only contains a copybook.
Move a part of the code from the hellocobalprogram in the lower.
Replace the original code and hellocobalworld with a copy statement.
The changes you make to your project will cause some build issues.
Modify the project's properties to add a path to the copybook.
In file in order to resolve these build issues.
I wonder what this is if you're not the vicious studio code.
Let's just try to figure it out.
They want to create a console application that probably doesn't apply to us.
Create a copybook.
Copybook, project, solution, add new item.
Click copybook. What is a copybook?
I'm going to create a new file called hello.cpy and click add.
This crazy file in the project opens it in the editor.
You're now going to add some code to the file from the hellocobalworld project.
Copy the following line from the file.
Let's try this.
I think we have one thing missing here.
Hello.cpy probably requires some scaffolding before we can make it work.
By scaffolding, I mean this part, the identification division, the procedure division.
Let's follow it blindly and see what problems we get.
They want us to call it hello.cpy.
I am going to create a new file.
The first copy is a new file, paste it in.
Call it hello.cpy.
That seems to be a cobalt thing.
That's it recognized by Visual Studio.
I just have this literally in that file.
And then I'm supposed to...
What was it?
Run this, copy hello.cpy.
To here.
Is that supposed to be like that?
Let's see what happens.
I did that, noted the line for the copy statement in noworld.cbl.
It's now underlined with the red wave line in the editor.
No, it's not.
But that's just because we're not using Visual Studio.
Okay, this looks boring. This is not programming. This is product setup.
Interesting tutorial. I want to compile this to see what happens.
What? No.
Did that actually work?
Looks like it did, right?
Let's just write something else to make sure that we're actually running what we think we're running.
Here we are.
So I guess that whole part was useless for us.
And this looks like an import statement to me.
Looks like a very flaky way to import something.
But whatever.
Okay, but so we know what copybooks are.
They are pretty boring and shit.
So let's continue debugging the helloCovol world application.
Come on.
This is not fun.
I want to create a function or something.
Maybe that doesn't even exist in Covol. What do I know?
So add the following code on a new line immediately at the line for code.
I don't want to do that. I don't want to debug right now.
Creating a native Covol application. Let's start something else.
Running unitest. What the hell is this tutorial?
Here's all the boring things that doesn't make the program do what you want to do that you need to learn first.
I understand why I hate taking programming classes in school because they were exactly like this.
First we need to understand everything perfectly before the program does anything.
And I was more like, I'd rather do something first.
What else could you do here?
Delta file editor. I want to do something fun.
What is a native Covol application then?
Now this website starts to work. No, it works again.
Visual Covol.
We're back in from start. I'm going to have to find something more fun.
Microfokus. What's focus? Two micro for me.
Let's dump this.
We know how to write a Covol program, so let's start something else.
Covol tutorial.
Add tutorials point.
React all the cookies.
Overview. What can we get there?
History and evolution of Covol.
Environment setup.
Not really interested in that right now.
I know how to compile it.
What else can we do? Program structure.
Program, division, sections, paragraph, sentence, statements, and characters.
Nice.
Interesting.
This part here looks a little bit like assembler to me.
Specially with this move10 to WSID.
Okej.
You can tell that this tutorial is written by somebody that hates the world.
Is this the code?
Environment division, input, output, section, file control, select, file, and the organization is sequential.
This is interesting.
Am I going to write a program like this today?
We'll see.
Let me just do something funny now.
Damn you tutorial, you suck.
Basic syntax.
Who is going to remember this when you start learning something?
This is such a strange way to teach something.
Okej, nu vet jag vad det är.
Det här är att kolla en film och först kolla på alla kastor för att veta vilka personer existerar i den.
Det är inte hur vi presentar information.
Det här är inte en tutorial.
Det här är en teknisk data sheet.
Okej, let's go back, I give up.
Vad kan vi se?
Kanske kan vi se Cobaltborn.
Låt oss se på den här.
Vill du läsa hur man ska byta ditt första webbpagel?
Nej, jag vill läsa Cobalt.
Jag vill bara tacka till en av våra sponsor.
Tack, bror.
Du ska gå och checka dem ut, linken är i beskrivningen.
De är en kodingbubkamp och de kan läsa dig webbdevelopment i Iowa i veckan.
Jag har en fråga om hur man ska läsa Cobaltborn.
Jag var på en artikel som talade om USA-banknaderna i att använda Cobaltborn.
Jag har träffat nya människor för att läsa Cobaltborn
och hålla de äldre legacysystemen.
Jag frågar om Cobaltborn är en bra nyheter
och om man ska läsa det.
Jag tänkte att jag skulle ge min opinion om det.
Jag har aldrig hört om det.
Det är lite intressant.
Men du har två saker som jag vill säga
som kommer att gå mot dig.
Det är svårt.
Vi ska se vad det har att offer.
Det mest funnande i så länge
var det program som kalkulat.
Det var en multiplikation.
Jag har en tietäädivision
med en börs långa del.
Vi ska se om det funnande.
J rust Championsð
Du har en psycho三a
Ska vi se vad som händer om vi förberederar data-divisionen?
Ska programmen krascha?
Ja.
Jag tror att data-divisionen är nivån.
Jag tror att det här är vad de kallar en section.
Eller vad var det?
Vill vi ha en övergivning sådär?
Låt oss se om det var en section eller en paragraf eller något.
Det här var en division och det här var en section.
Så det här är egentligen en klipp eller en section.
Eller vad vill du säga?
En header för det här.
Jag tror att det betyder att det här...
Jag vet att det inte verkar, men...
Okej, det sker en sak.
Så det verkar en storlekare.
Det är egentligen att reservera människan.
Det sker en sak.
0-1, num 1, pick 9.
Jag tror att det här är hur jag reserverar människan.
Låt oss ta fram programmet.
För att...
För att...
För att ta fram tre nummer samtidigt.
Låt oss göra en lördekollegang här.
Kopie den här linjen, namn num 3.
Och den första nummeren, 1-1.
Vi har ingen avgång!
Okej.
Dritt nummer, num 3.
Multi-by, by.
By, num 3, resulta.
Resulta är resulta.
Låt oss se om det här verkar.
Syntexerat, undanvisade by.
Okej, jag kan inte göra det.
Jag tror att det betyder att multipla kan bara multipla två nummer.
Låt oss se vad som händer om vi googlar.
Kobol.
Kobol, multipla.
Wow, dessa webbplatser.
Låt oss se.
Multi-by, multipla nummer.
Format 1.
Literal 1, data item.
By, data item 2.
Okej.
Kan vi multipla tre saker...
...utan att ha en extra...
...inbetween variable?
Låt oss se om vi kan...
Jag ska experimentera lite här.
Låt oss ha resulta.
Låt oss kolla det här...
...inbetween.
Och utan att ge dig resulta här,
vi ger till inbetween.
Man kan ta ut det här.
Man kan multipla...
...num3
...by, inbetween.
Och ge det två resulta.
Kan vi kompilera det här?
Okej.
Det kompileras åtminstone.
Så vi multiplar två...
...byr tre...
...byr fyra.
Ja.
Det jobbade.
Men det här var lite annorlunda.
Vad händer?
Kan vi multipla in till nummer 1 här?
Jag vet inte om det verkar.
Två, tre, fyra.
Det har fungerat.
Det betyder att jag har överrott en av den här.
Det här är intressant.
Jag ska rejala programmet...
...och se om jag kan åka ut...
...för att bara ha resultat...
...och input.
Och idé är att jag alltid multiplar...
...det nästa input...
...med resultat och ta den till resultat.
Så...
Först här...
...jag kommer att läsa input.
Det är kanske en reserve ord...
...för att jag frågar det...
...för att det inte är vit.
Så...
Okej, jag kan inte läsa input.
Så jag kommer att läsa...
...nummer.
Ah, num, då.
Num, num, num.
Så jag alltid läser input...
...till den nummervarivalen.
Och direkt efter...
...jag...
...multiplar det med resultat...
...och ta den till resultat.
Och...
Där går vi.
Där går vi.
Och då kan vi ta resultat.
Se hur det fungerar.
Två, tre, fyra.
Ha, nej.
Jag frågar, varför?
Ah...
...att ta nummervarivalen...
...och ta resultat.
Det kanske är...
...att jag tror att vi...
...hade ett switch tidigare.
Jag frågar om det har en effekt.
Vi ser.
Två, tre, fyra.
Nej.
Okej, det gör lite mer mer.
Så vad har det gjort tidigare när vi hade alla dessa nummer?
Jag trodde att det här var en ekonomi av vad vi gjorde...
...i början.
Kanske gjorde vi faktiskt överrättat här...
...men det har hänt med samma effekt...
...för nummer ett var två.
Jag är inte säker.
Så här nummer ett blir två.
Nummer två blir tre.
Och vi tar det.
Det här blir sikt här.
Och vi gör det här.
Jag är inte säker vad det här displayet är...
...att exakt exakt.
Det kanske inte är möjligt att göra vad jag gjorde där.
Okej.
Låt oss inte försöka det igen...
...eller ska vi?
Det är ganska skönt.
Låt oss ta det ibaka.
Jag är ibaka bara påbörjande i länge nu...
...och försöker försöka få ut vad det är som det är.
Så det verkar.
Två, tre, fyra.
Det är 24.
Och kan jag gå ut med att inte använda nummer tre?
Låt oss se.
Låt oss använda nummer en här igen.
Nej, vi kan definitivt göra det.
Men låt oss använda den här.
Och sen kan vi reusesa nummer en.
Nummer en.
Nej, vi har råd det till där.
Så jag vill skriva det till resultatet där.
Okej, nu kommer jag inte att skriva det.
Nu kommer jag inte att skriva en ideell kod.
Jag är bara att följa runt lite.
Jag har lost track av vad jag tänkte där.
Men jag ville gå ner.
Jag vill bara ha...
...så jag tar en input och multipliserar den med resultatet.
Jag tar en input igen.
Resultatet börjar med 0.
Så jag kan inte, obviously, multipla den där.
I the beginning I need at least two numbers to do that.
Så let's see if we can get away with two and still have three.
Så that makes sense.
So we have to have at least two numbers.
There are none zero.
Before we multiply.
And if we multiply with one of them there is zero.
It will always be zero, obviously.
So let's see if we multiply this into result.
Not wait a minute.
I feel like we should be able to do this in a smart clever way.
If the first one we put into the result.
Or what is it called in multiplication?
The product.
And let's look up with what are parts of multiplication called.
There are the multipliers.
Recall that.
They are called factors.
So I'm going to have a factor.
And I'm going to have a product.
And the product is actually this one.
And then on the first input we input it into the product.
Because one multiplied by one is always one.
Or one multiplied by itself.
The first number is always the product.
If I only have one number.
Then the second number we put in the factor.
And then we multiply the factor with the product.
Giving it a new product.
Then we overwrite the factor and we do this thing again.
Now I think we can run a program.
At least that's what I'm hoping for.
Result undefined.
We need to print the product.
2, 3, 4.
Yes!
That worked.
So now I understand this a little bit better.
But I would like to have a loop here.
So that we can enter how many numbers we should multiply.
Let's see if there is such a thing as a loop in cobalt.
Loop statements.
Nice.
Perform through.
Perform through is used to execute a series of paragraphs
by giving the first and last paragraph names in the sequence.
Okay.
After executing the last paragraph the control is returned back.
Okay.
Inline perform.
Statements inside the perform will be executed till end of the paragraph.
And perform is reached.
Syntax.
The following syntax is a syntax of inline perform.
Okay.
Out of line perform.
Here a statement is executed in one paragraph.
And then the control is transferred to other paragraph or section.
Okay.
Perform paragraph one through paragraph two.
Okay, interesting.
They have a really interesting way of giving away execution context in this language.
Okay.
Perform display and perform.
Okay.
This looks a little bit like what we want to do.
I guess these are paragraphs.
No.
Hmm.
A para is the first paragraph, I guess.
Perform display in a para.
And perform.
Perform see para through e para.
I guess it just runs this, this and that.
Okay.
This is interesting.
Hmm.
Hmm.
Okay.
This looks more like something we should want to be doing.
In perform until a paragraph is executed until a given condition becomes true.
Sounds like a while loop.
Or a for loop.
With test before is a default condition and it indicates that condition is checked before the execution of statements in a paragraph.
Okay.
I think that I want to have two variables here.
One call step and one call steps.
I'm writing zero one here without knowing why.
But the idea is that I want to have a number count up until another number.
So imagine a for loop where you have i and length.
So step is going to be this one, peak nine.
I think that is a single digit number.
And the value of that.
I don't know, but I want to set it to zero and increment it.
So zero one and is step last.
Let's call it step current to be even more clear what I want to be doing.
Pick nine value zeros.
But I want this step last to be contained nine.
I guess before we continue too long here we should probably see if we can put a number in step current.
Or step last.
Oh, I could ask how many numbers I want to multiply.
So let's add a statement here and say how many numbers should be.
Let's just ask how many numbers that's easier.
And we accept that in the step last.
Then let's just write out display.
We will multiply.
Can I write that numbers.
And the step last will be here.
Is that how you concatenate things.
Oh, three.
Oh, we will multiply four numbers that works. Nice.
Okay, and we know the rest of the program works, but now how to use the for loop.
I think let's output also a step.
So I'm going to say.
Enter.
And then the step current.
Enter.
Number.
Step current.
And then slash off step last.
One digit.
With no advancing.
And see what happens.
Okay, good.
We are at step one there, but we call it zero because it's zero based.
Okay, interesting.
We had an extra line here we don't need.
And I guess can we concatenate this immediately.
Can we add a one to the step current here.
Like this in COBOL.
Let's try it out.
No, I cannot.
So let's see.
What should I do here?
Should I?
The cheap way of doing that is to just start the step at one.
Okay, let's see how I assign a variable in COBOL.
Assign variable in COBOL.
Okay, this is going to be interesting.
Okay, this is not just going to be too long declaring data.
Actually, let's see, war loop in COBOL.
How what we will learn from this loop statement.
Okay.
Perform times looks interesting too.
Let's look at perform times.
I guess if you write this perform a paragraph five times.
If we can replace this with our step last.
Then we should be able to run this.
I guess we need to first paragraph the multiplication part.
So let's create a paragraph here.
Is that supposed to be in the procedure division?
Will it always start with the first one?
Actually, let's run add a paragraph here.
See what happens.
What happens if we just do this?
Will that mean that program just stops immediately?
Yes.
So I guess it always starts.
This looks probably like a go to statement.
Might that be so.
I think it is.
So...
So I was thinking if I put this in a paragraph.
As I say it is set up para.
And it displays how many numbers.
And it accepts the step last.
And it says how many numbers we are going to accept.
Could it end a paragraph two somehow.
Stop run stops the entire program.
So I want to look for something that goes to set up para.
Immediately here.
Not sure this is a good way to write it.
But my thinking is I want to have the entry point in the top.
And I want to set up the structure of the program.
So basically something like this.
Run set up para.
Then I want to do that thing that's called.
Perform something para five times.
So if imagine that this was called the calculation para.
I could remove this.
That's the idea at least.
And then I would say perform calculation para.
And I would say step last times.
So if we run this as many times as you inputted here.
And then in the end I would just say display result is product.
So this way we will start here.
We will set it up asking for the number.
We run this five times.
And then if we display the product.
So it looks like there are definitely things missing here.
We have the stop run.
Which I'm not sure how it works.
Let's look a little bit more here and see if we can have some hints.
What does the stop run seems to be stopping the program completely I think.
I would like to learn more.
Here we go.
So this means go to setup para.
And I'm going to call this the init para.
Even though I probably don't need a name here.
I think before we continue too long.
Let's just see if we got anything there.
Calculation para undefined.
But it is here.
Maybe.
No I don't know at all what's going on.
I didn't expect that.
That's interesting.
Line 27.
Oh this is not the definition.
It complains.
What does that mean?
Do I need to define the paragraphs?
In some other way.
This.
Looks like they just write the paragraph.
And then here they go to be para.
They do say with a dot.
But we do that too there.
I can't really see the difference.
I have here.
Go to setup para.
No.
What does this mean?
In hello world in paragraph setup para.
We had these two errors.
Is that what it means?
I think I made too many differences here.
In the same time.
Let's scroll this back.
I know exactly what I want.
Let's get the program back into a working state.
So let's do one thing at a time.
Or a somewhat working state at least.
Or.
One, two, three.
Okay.
So the program kind of works.
But we don't have that number thing.
So.
What if we.
Add a stop run here.
Okay.
That's good.
But before the stop run, I want to jump down here.
I'm actually going to use the exact same context they use here.
So they have a para and b para.
Not sure.
I thought I could name this anything I want.
But let's add a para in the top here.
See what happens.
Okay.
That didn't destroy anything.
So let's call this the B.
B para.
Let's see if it was destroyed.
No.
No.
Let's see if it was destroyed.
No.
But in the end.
Let's go to.
Was that how it's called?
Sure.
So unconditional go to.
So in the end here I want to go to be para.
Ja.
Is.
Can I choose any name I want here?
Because I want to do this with the calculation para.
Calc para, we call it.
Because I'm not sure I'm allowed to call this whatever I want to.
Even though I thought so.
Yeah, that seemed to work.
Can I call this init para?
As I wanted to.
Or main para maybe.
Without breaking.
That seemed to work.
So if I now.
If I now.
This is the thing that stops it.
If I don't have this.
Will I be able to display something else here?
Will it jump back up here when it's done?
Let's try this out.
Woo!
We call it.
Two numbers.
One, two, three.
No.
It just went down here and.
Stopped.
So I can't jump back up without explicitly.
Telling it to I guess.
Does that go for the perform too?
This looks like something we want.
I'm sure we're doing too much in the same time now.
But perform calc para.
Väring.
One until from one by one until.
Okay, this looks like a for loop.
So I guess this will be step current.
Från 1.
By 1.
Untill step current.
Equals.
Step last.
Okay.
Let's remove a bunch of bullshit here.
And see what happens.
I'm gonna move this up here too.
I have no idea.
It's probably breaking so many ways.
How many numbers?
Three.
And the number one out of three.
One.
Two.
Three.
Four.
Hmm.
There was something going on here that kind of worked to be honest.
We don't need a second number.
And.
But we do have a problem here that the first result needs to be stored in the previous one.
Or in the factor.
So how can I do that in for loop?
I don't think I ever did that.
Hard.
I don't want to write this with an if statement to be honest.
What if I could push all these numbers to an array?
Is that even a thing in cobalt?
Cobal.
Array.
Array table concept.
This looks hard.
Ooh.
Ooh.
Okej.
I think it may be not that hard.
I'm very unused to this syntax.
But.
I'm not sure if I can write this right now without being completely confused on every step of the way.
Let's see what this says.
Cobal arrays or tables.
Single dimensional arrays.
Arrays are data structures that are used to simplify coding and improve processing efficiency.
The primary uses of arrays are to define a series of similar like format i input and output.
Okej.
I know this.
Deklaring an array.
Arrays assault cobalt data items.
Must be declaring a data division.
But are distinguished from scaler unsubscripted data items by use of the occurs class in their data definition.
Arrays may be declared for elementary or group data items at level 02 to 49.
To declare an array of elementary data items use the class occurs int num times.
In the data definition int num is any positive integer specifying the number of elements in the array.
Daily temp 05 temp occurs 25 times pick 999.
Okej.
I don't know what this first number means but I think that is how to define it.
This looks more like something I am interested in.
What this is number is that just like in the order it executes or something.
Just like in basic.
Okej, this looks interesting too.
So I am thinking that I should be able to get away with this.
So instead of factor I am going to have factors.
And what is temp?
What does it mean temp here?
It occurs 25 times pick.
So I guess this is we have two instances of temp.
But why do we need daily temp?
Okej.
This example occurs an array named temp that contains 24 elements data items each of pick 999.
So pick 999 I think is a number that has 3 respots that can contain up to number 9 in each of them.
And it's referenced like this temp 1 temp 24 Okej.
Daily temp is not itself an array but the group data item 72 characters long.
24 times 3 Okej.
So that's 24 there and the 3 bytes are basically I guess.
And it's 0,2 to 49 level data frame can contain an occurs clause.
So I guess the daily temp we probably don't need it.
But I am going to call it factors.
And there is a dot there right?
Yeah.
And I am going to call this factor.
But I need to be able to say how I need this to be variable.
Because I input the number dynamically in my program.
And I don't know how to do that yet.
I guess I could just take a very high number.
I feel it with the ones.
But it is a little bit dumb.
But I am pretty dumb when I write cobalt.
So I must admit.
So I am not sure how to do this in a way that I am not going to get too confused.
I am literally still subscript here.
Well...
Before I do too much maybe I should just try this out.
So let's put a 9 here.
Should I do this?
And put values 1.
Can I do that?
The idea is here.
Like if I have a ton of factors in the program.
Basically multipliers.
And the rest of them is 1.
It doesn't matter if I multiply them all in the end of the program.
I know it's really really bad.
But I also want to see if this works.
Let's compile this and see what happens.
I don't even know if this is at all going to work.
Okej, the setup of the compilation seems to work.
So let's do something more then.
We can remove the factor.
So now the program should probably break, I hope.
No.
Oh, we are not using my factor right now.
I guess...
What I should do here is accept this number into the factor step current.
Not sure if this works.
Let's display what we did too.
Stored.
And then factor step current.
Three.
We will multiply three numbers.
Two.
Three.
And four.
Whoa!
That was actually almost working.
We have some of by one error here.
I think...
Can we do this?
I think...
Can we have...
Put this like this.
Step current is...
Until it's less or equal.
Okej, let's solve this later.
They were off by one error.
But in the end here, I want to multiply all the factors.
Kan we do that here, maybe?
Perform until this.
It looks like until number data can be used as a subscript.
I don't know what subscript is about.
It looks like we can multiply things here.
I'm not sure.
I'm ready to do this just yet.
I first want to get a good concept of what this program does.
So let's remove...
Let's print something out there in the product.
No.
Maybe it was easy to do the thing we did before.
I guess if the first number is one.
Okej, I guess I can cheat a little bit here.
If I store the first result as one.
I don't need this array.
So I'm going to scroll back a little bit here.
I fake it.
So here now we have the factor and the product.
And the product...
It's going to start out by being one.
I think that is possible.
Then every time we accept the number into the factor.
We multiply the factor with the product.
I think that should work.
Where is the multiplication step?
Step.
Let's scroll back.
There we go.
So accept the factor.
And then we add the factor to the product.
So if the product starts at one.
Then we go down here and we accept the factor.
Then we store the factor.
We multiply the factor by the product into the product.
Then we do that again and again.
For all until we reach the step last.
I think we have something going here.
How many digits?
Five.
No, let's start with four.
Enter number one of four.
Two.
Enter number two of four.
Three.
Enter number three out of four.
Four.
Result is 24.
Wow!
A program kind of works.
But it has an off by one error.
So let's fix that.
Then I think the first course in COBOL is complete.
Might be the world's shittiest COBOL program to bonus.
But I'm pretty proud of myself still.
I only took almost two hours to make a shit program.
So how to solve this off by one error.
I guess we could have, we need a minus somewhere.
Or.
A step last.
Why is a step current?
I guess.
If this was while.
No, that doesn't work.
Let's see what options we have here for looping.
Loop statements.
We have the perform until.
Wasn't there something else?
Perform times is pretty interesting.
Let's try this.
Perform calc step last times.
Two.
One.
Two.
Okay, that worked.
But we have to update the step current.
Mm-hm.
And I guess.
We could do that.
By just adding to step current here.
Add.
Add.
One.
Two.
Step current.
Let's try that out.
Three.
One.
Two.
Three.
Ah, look at that.
That worked.
COBOL is really good.
I have some fluency in COBOL now.
That was pretty satisfying.
Even though this whole program is quite silly.
I like it.
I feel accomplished today.
Let's see if there is anything we should clean up.
Let's change the author.
This method.
Yeah.
Example program using.
Perform.
We are using.
Accept.
And we are using.
Times.
Kollekt.
A number of user.
The finable integers.
Finable integers.
And.
Multiply them.
With.
With.
Low memory footprint.
I can't write.
I'm having so much fun.
Low memory footprint.
And return the result.
No display.
And this.
Display the result.
Data division.
Step current.
Step last.
Fantastic.
Okay.
Pretty nice.
I must say.
Wait, I need to upload this to GitHub.
East.
Wacka the whack.
Det.
My first global program.
We call it.
Calculate.
Like.
Bank.
CBL.
There we go.
We are public.
Gonna leave this link in the subscription.
I mean in the description.
I kinda like it.
I'm.
Happy that you took time and looked at how to learn COBOL.
The world is our oyster now.
Let's go get those banks and get a fat paycheck.
For the summer.
Alright.
Thanks.
See you later.
