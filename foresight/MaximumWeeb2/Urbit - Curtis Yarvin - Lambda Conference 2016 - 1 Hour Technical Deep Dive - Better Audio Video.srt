1
00:00:00,000 --> 00:00:03,120
So I'm going to be talking about this interesting little system,

2
00:00:03,120 --> 00:00:05,840
Erbit, that I and some friends have built.

3
00:00:05,840 --> 00:00:10,000
Erbit is a clean slate full stack system.

4
00:00:10,000 --> 00:00:13,360
So let me explain sort of briefly the problem that we're

5
00:00:13,360 --> 00:00:16,560
solving here first, because this is a little different

6
00:00:16,560 --> 00:00:21,080
from the problem that a usual language is solving.

7
00:00:21,080 --> 00:00:24,200
So we have basically a coupling of kind of two interesting

8
00:00:24,200 --> 00:00:24,840
problems here.

9
00:00:24,840 --> 00:00:28,240
We have a very different kind of technical problem that we're

10
00:00:28,240 --> 00:00:31,680
solving, and we also have a different human market need

11
00:00:31,680 --> 00:00:33,120
that we're solving.

12
00:00:33,120 --> 00:00:35,160
So let me go through both of those super quickly.

13
00:00:35,160 --> 00:00:38,480
So the technical problem we're trying to solve here is

14
00:00:38,480 --> 00:00:41,040
something I call a high level deterministic computer.

15
00:00:41,040 --> 00:00:44,360
So that would be basically a computer whose entire life

16
00:00:44,360 --> 00:00:47,080
cycle is defined by a single frozen function.

17
00:00:47,080 --> 00:00:49,400
So it's really very functional.

18
00:00:49,400 --> 00:00:53,640
Of course, a hardware VM, a CPU, is defined by a single

19
00:00:53,640 --> 00:00:55,920
frozen function, which is the CPU function, which is very

20
00:00:55,960 --> 00:00:58,680
frozen because it's on the chip.

21
00:00:58,680 --> 00:01:02,600
But we'd actually like to define that at a layer at the same

22
00:01:02,600 --> 00:01:05,960
level at which the programmer conceives the system.

23
00:01:05,960 --> 00:01:09,360
So if we look at some kind of approximations to this that

24
00:01:09,360 --> 00:01:13,600
exist in reality today, JavaScript and the Java VM, of

25
00:01:13,600 --> 00:01:19,320
course, are high level definitions, but they're

26
00:01:19,320 --> 00:01:22,040
defined only sort of for a transient system.

27
00:01:22,040 --> 00:01:24,600
So here we're defining the whole life cycle of the

28
00:01:24,600 --> 00:01:25,320
computer.

29
00:01:25,320 --> 00:01:26,640
This is not just a memory image.

30
00:01:26,640 --> 00:01:30,040
This is the whole machine, which is a single level store.

31
00:01:30,040 --> 00:01:33,000
Lisp and small talk have these image-based systems that

32
00:01:33,000 --> 00:01:36,120
come a little closer to this kind of approach.

33
00:01:36,120 --> 00:01:38,280
I don't think people in practice usually use Lisp and

34
00:01:38,280 --> 00:01:40,400
small talk actually as databases.

35
00:01:40,400 --> 00:01:44,960
And they're not defined functionally in the same way.

36
00:01:44,960 --> 00:01:49,800
But it's definitely in the image-based system tradition.

37
00:01:49,800 --> 00:01:51,840
When you're using this thing, it basically feels like an

38
00:01:51,840 --> 00:01:54,560
integrated interpreter OS and database, which is a very

39
00:01:54,720 --> 00:01:58,760
kind of unusual feeling for a programming environment.

40
00:01:58,760 --> 00:02:00,960
You might also ask what happens when a determinist to

41
00:02:00,960 --> 00:02:03,240
computer hits an undecidable problem.

42
00:02:03,240 --> 00:02:06,360
We'll get into that in a little bit.

43
00:02:06,360 --> 00:02:10,800
One way of sort of defining this problem that I like to use

44
00:02:10,800 --> 00:02:13,960
is an unusual versioning system that we use, which I

45
00:02:13,960 --> 00:02:15,000
call Kelvin versioning.

46
00:02:15,000 --> 00:02:18,240
So Kelvin versioning, you count down to absolute zero and

47
00:02:18,240 --> 00:02:19,600
you count by integers.

48
00:02:19,600 --> 00:02:22,360
So if you run out of numbers, you've made a mistake,

49
00:02:22,360 --> 00:02:22,880
basically.

50
00:02:22,880 --> 00:02:25,640
So absolute zero is absolutely frozen.

51
00:02:25,640 --> 00:02:28,680
So Erbit, or at least the sort of the formal definition of

52
00:02:28,680 --> 00:02:31,760
Erbit, which does fit on a t-shirt, is at five Kelvin,

53
00:02:31,760 --> 00:02:34,640
which is like liquid helium, basically at the moment.

54
00:02:34,640 --> 00:02:37,680
And we'll see that spec in a little bit.

55
00:02:37,680 --> 00:02:41,080
Let's switch gears totally and talk about the human need that

56
00:02:41,080 --> 00:02:43,280
this system is supposed to be solving.

57
00:02:43,280 --> 00:02:45,840
We have this little problem in the computer world, which is

58
00:02:45,840 --> 00:02:48,240
that the internet actually failed.

59
00:02:48,240 --> 00:02:50,360
It succeeded very well as a digital modem.

60
00:02:50,360 --> 00:02:52,480
It's a great digital modem.

61
00:02:52,520 --> 00:02:54,560
It's entirely a client-server environment.

62
00:02:54,560 --> 00:02:56,200
It is not a peer-to-peer network.

63
00:02:56,200 --> 00:02:58,920
It's never going to be a peer-to-peer network.

64
00:02:58,920 --> 00:03:01,400
And if you look at sort of the dream of the internet from

65
00:03:01,400 --> 00:03:05,760
the 80s and 90s, it was a dream in which everyone on this

66
00:03:05,760 --> 00:03:07,880
network would have their own server.

67
00:03:07,880 --> 00:03:11,080
And things like what we do on Facebook today would be done

68
00:03:11,080 --> 00:03:13,320
by protocols like SMTP.

69
00:03:13,320 --> 00:03:16,000
Well, you can't introduce a new wide area protocol on the

70
00:03:16,000 --> 00:03:16,640
internet today.

71
00:03:16,640 --> 00:03:20,240
You can barely keep SMTP alive.

72
00:03:20,280 --> 00:03:22,560
These systems were designed in the 70s.

73
00:03:22,560 --> 00:03:25,480
The same thing for basically Linux, which is, in a sense,

74
00:03:25,480 --> 00:03:27,360
I would say, layer seven of the internet.

75
00:03:27,360 --> 00:03:29,280
It's the application layer.

76
00:03:29,280 --> 00:03:31,320
If you're on the internet, you're either a Unix box or

77
00:03:31,320 --> 00:03:33,400
you're pretending to be a Unix box.

78
00:03:33,400 --> 00:03:37,360
You can't really say to my mother, hey, you should go out

79
00:03:37,360 --> 00:03:40,440
and get an AWS box and put all your data on that and app

80
00:03:40,440 --> 00:03:44,000
get installed, something.

81
00:03:44,000 --> 00:03:46,040
That's just never basically going to fly.

82
00:03:46,040 --> 00:03:49,720
And so we've kind of reconciled ourselves to those

83
00:03:49,720 --> 00:03:52,600
sort of loss of this dream where people actually control

84
00:03:52,600 --> 00:03:54,000
their own individual computing.

85
00:03:54,000 --> 00:03:58,960
And instead, we've basically gone back and recreated the

86
00:03:58,960 --> 00:04:01,120
Hayes modem protocol with HTTP.

87
00:04:01,120 --> 00:04:04,400
And we've recreated AOL with Facebook.

88
00:04:04,400 --> 00:04:06,920
And we're kind of stuck in this space.

89
00:04:06,920 --> 00:04:08,760
So we have a big problem here.

90
00:04:08,760 --> 00:04:11,560
And these systems aren't basically not fixable.

91
00:04:11,560 --> 00:04:14,360
Well, there's a way to get out of a problem that isn't

92
00:04:14,360 --> 00:04:16,080
fixable, which is to layer over it.

93
00:04:16,080 --> 00:04:18,760
So the browser already did this on the client side.

94
00:04:18,800 --> 00:04:21,040
Basically, you had these OS APIs.

95
00:04:21,040 --> 00:04:23,360
And they're like, OK, we're going to build a new

96
00:04:23,360 --> 00:04:24,600
application layer.

97
00:04:24,600 --> 00:04:27,160
I guess browser people didn't realize that this is what

98
00:04:27,160 --> 00:04:27,640
they were doing.

99
00:04:27,640 --> 00:04:29,120
But it's certainly what they were doing.

100
00:04:29,120 --> 00:04:31,040
We're going to build a new programming layer that is

101
00:04:31,040 --> 00:04:34,360
isolated from the substrate under it that cannot call out

102
00:04:34,360 --> 00:04:36,040
in any way, shape, or form.

103
00:04:36,040 --> 00:04:38,720
And we're just going to program to that layer and not care

104
00:04:38,720 --> 00:04:40,840
about the underlying OS.

105
00:04:40,840 --> 00:04:43,120
And that actually kind of worked great.

106
00:04:43,120 --> 00:04:45,240
So on the server side, basically, this

107
00:04:45,240 --> 00:04:47,240
hasn't been done yet.

108
00:04:47,240 --> 00:04:50,160
And I would say, basically, we don't know that people don't

109
00:04:50,160 --> 00:04:51,280
want personal servers.

110
00:04:51,280 --> 00:04:54,360
People ask them, you tell them what a personal server is.

111
00:04:54,360 --> 00:04:56,160
And they say, yes, I want that.

112
00:04:56,160 --> 00:04:58,640
We do know that they don't want Linux and internet

113
00:04:58,640 --> 00:04:59,400
personal servers.

114
00:04:59,400 --> 00:05:02,160
We do know that my mother is never going to run an open

115
00:05:02,160 --> 00:05:03,760
Linux server on the internet.

116
00:05:03,760 --> 00:05:07,720
So there's basically a real case to be made for saying, OK,

117
00:05:07,720 --> 00:05:09,880
we need a new layer here.

118
00:05:09,880 --> 00:05:13,120
If we sort of drill down a little bit and define the need,

119
00:05:13,120 --> 00:05:17,120
the need is basically caused by the, essentially, the

120
00:05:17,120 --> 00:05:19,560
obstacle to the universal personal server is just

121
00:05:19,560 --> 00:05:20,440
administrative cost.

122
00:05:20,440 --> 00:05:22,320
My mother is not a Linux is that thing.

123
00:05:22,320 --> 00:05:25,320
So when you're looking at a problem and your problem is

124
00:05:25,320 --> 00:05:28,440
administrative cost, it makes sense that a solution to this

125
00:05:28,440 --> 00:05:30,160
problem is going to be technical simplicity.

126
00:05:30,160 --> 00:05:32,920
Because basically, the difficulty of administering

127
00:05:32,920 --> 00:05:35,640
the system tends to be roughly proportional to the number of

128
00:05:35,640 --> 00:05:36,840
lines of code in it.

129
00:05:36,840 --> 00:05:38,720
And if you haven't noticed, there's a lot of lines of

130
00:05:38,720 --> 00:05:40,800
code in Ubuntu.

131
00:05:40,800 --> 00:05:45,120
And so basically, the idea of building the browser for the

132
00:05:45,120 --> 00:05:48,400
server side is sort of a problem that kind of makes sense

133
00:05:48,400 --> 00:05:50,640
next to this problem of let's build a high-level

134
00:05:50,640 --> 00:05:53,200
deterministic computer.

135
00:05:53,200 --> 00:05:55,640
So OK, let's build it.

136
00:05:55,640 --> 00:05:57,840
How do you define a one-function computer?

137
00:05:57,840 --> 00:06:00,800
Well, you need, remember, we're defining both the network

138
00:06:00,800 --> 00:06:01,560
and the OS here.

139
00:06:01,560 --> 00:06:04,760
We're really defining a computing environment as if we

140
00:06:04,760 --> 00:06:07,400
just stumbled on a planet that had chips and wires and no

141
00:06:07,400 --> 00:06:10,600
software whatsoever, which is kind of fun.

142
00:06:10,600 --> 00:06:13,560
And if you're going to define the way this works, you're

143
00:06:13,560 --> 00:06:15,520
defining networking from scratch.

144
00:06:15,520 --> 00:06:17,960
I find the simplest way to think about networking is to

145
00:06:17,960 --> 00:06:20,280
imagine just basically a global party line.

146
00:06:20,280 --> 00:06:23,600
So a packet is just a big integer blob that people put

147
00:06:23,600 --> 00:06:24,200
out.

148
00:06:24,200 --> 00:06:26,040
Everybody hears everyone else's packets.

149
00:06:26,040 --> 00:06:28,680
And if you have the keys to decrypt those packets and make

150
00:06:28,680 --> 00:06:30,960
them make sense, then you use them.

151
00:06:30,960 --> 00:06:34,240
Then you can basically say to this global party line, hey,

152
00:06:34,240 --> 00:06:36,600
we would like to actually optimize this.

153
00:06:36,600 --> 00:06:38,600
And you get back to routing.

154
00:06:38,600 --> 00:06:42,520
But routing is basically an optimization in Van Jacobsen

155
00:06:42,520 --> 00:06:46,000
has this great term, a content-centric network, where

156
00:06:46,000 --> 00:06:49,080
you're basically ignoring who sent you the packet doesn't

157
00:06:49,080 --> 00:06:49,400
matter.

158
00:06:49,400 --> 00:06:51,200
What matters is what's in the packet.

159
00:06:51,200 --> 00:06:56,320
So that's sort of the network perspective on this.

160
00:06:56,320 --> 00:06:59,520
From the sort of functional perspective, there's basically

161
00:06:59,520 --> 00:07:02,040
two ways to define a one-function computer.

162
00:07:02,040 --> 00:07:04,440
You can define it as a life cycle function, which is

163
00:07:04,440 --> 00:07:07,880
where the state is a pure function of input history.

164
00:07:07,880 --> 00:07:09,320
And remember, this is a frozen function.

165
00:07:09,320 --> 00:07:10,680
This never changes.

166
00:07:10,680 --> 00:07:12,640
You cannot upgrade this function.

167
00:07:12,640 --> 00:07:14,680
Or you can define it as a transition function, where

168
00:07:14,680 --> 00:07:17,280
basically you have an input event in an old state,

169
00:07:17,280 --> 00:07:20,520
outcomes, a bunch of output actions in a new state.

170
00:07:20,520 --> 00:07:23,360
These are really, in practice, basically turned into the

171
00:07:23,360 --> 00:07:23,880
same thing.

172
00:07:23,880 --> 00:07:27,520
In practice, essentially any life cycle function is going

173
00:07:27,520 --> 00:07:29,720
to wind up spending most of its time as a transition

174
00:07:29,720 --> 00:07:32,360
function, because you're certainly not going to

175
00:07:32,360 --> 00:07:36,320
recompute the whole log every time you get a packet.

176
00:07:36,320 --> 00:07:38,360
And one of the advantages of doing it the life cycle

177
00:07:38,360 --> 00:07:41,520
function way is when you're basically building a system

178
00:07:41,520 --> 00:07:43,800
where you have one frozen function which defines the

179
00:07:43,800 --> 00:07:47,080
semantics of every computer in the world, you need to

180
00:07:47,080 --> 00:07:48,440
basically break symmetry.

181
00:07:48,440 --> 00:07:51,040
And you need to basically, when you're starting that up, you

182
00:07:51,040 --> 00:07:52,360
need some startup packets.

183
00:07:52,360 --> 00:07:53,400
You need some startup.

184
00:07:53,400 --> 00:07:55,440
You need the load and operating system into your

185
00:07:55,440 --> 00:07:57,200
function, essentially.

186
00:07:57,200 --> 00:07:59,880
And so a life cycle function makes slightly more sense as a

187
00:07:59,880 --> 00:08:01,880
way to define this.

188
00:08:01,880 --> 00:08:05,080
Let me skip down for a second and talk about how you

189
00:08:05,080 --> 00:08:05,880
implement these things.

190
00:08:05,880 --> 00:08:10,320
Actually, implementing a sort of one function computer like

191
00:08:10,320 --> 00:08:12,720
this is kind of very easy with the kind of substrates that

192
00:08:12,720 --> 00:08:14,280
you have at the moment.

193
00:08:14,280 --> 00:08:17,480
Event sourcing is basically this pattern.

194
00:08:17,480 --> 00:08:20,080
It's usually not used for a general purpose computer, but

195
00:08:20,080 --> 00:08:22,080
it's the same pattern.

196
00:08:22,080 --> 00:08:28,000
You have low latency reliable logs are uniformly available.

197
00:08:28,000 --> 00:08:31,000
Kafka isn't the greatest thing in the world, but it works fine.

198
00:08:31,000 --> 00:08:33,760
Normal databases are defined in terms of the pend only

199
00:08:33,760 --> 00:08:38,280
transaction log and an image snapshot.

200
00:08:38,280 --> 00:08:41,520
So you're basically building this the same way a normal

201
00:08:41,520 --> 00:08:42,760
database is built.

202
00:08:42,760 --> 00:08:45,960
You're saying every packet is a transaction.

203
00:08:45,960 --> 00:08:47,320
And it basically works great.

204
00:08:47,320 --> 00:08:50,000
You can also do non-packet I.O. I mean, I like to think of an

205
00:08:50,000 --> 00:08:54,040
abstract computer as just packets in, packets out.

206
00:08:54,040 --> 00:08:58,000
But as you'll see, we want to serve web pages and so forth.

207
00:08:58,000 --> 00:09:03,600
So basically, you can model even ordinary HDDB requests

208
00:09:04,440 --> 00:09:06,480
as here's an event that's like you got a request.

209
00:09:06,480 --> 00:09:08,600
Here's my action respond to this request.

210
00:09:08,600 --> 00:09:12,600
So there's a great library LibUV, which is used by Node.js

211
00:09:12,600 --> 00:09:14,800
that implements these patterns very nicely.

212
00:09:14,800 --> 00:09:16,520
So it's super easy to do.

213
00:09:16,520 --> 00:09:18,120
I mentioned decidability earlier.

214
00:09:18,120 --> 00:09:20,120
That's kind of an interesting problem for a deterministic

215
00:09:20,120 --> 00:09:23,160
computer or any kind of non-preemptive OS.

216
00:09:23,160 --> 00:09:25,440
When you're building a non-preemptive system, basically

217
00:09:25,440 --> 00:09:28,640
the decision of when to terminate a computation is

218
00:09:28,640 --> 00:09:31,360
essentially a heuristic choice.

219
00:09:31,840 --> 00:09:34,400
If that event is caused by a console, that heuristic choice

220
00:09:34,400 --> 00:09:35,240
is very easy.

221
00:09:35,240 --> 00:09:37,720
Just go until they hit Control C.

222
00:09:37,720 --> 00:09:39,360
If it's a packet, that's a little harder.

223
00:09:39,360 --> 00:09:41,240
You need to decide when to time that out.

224
00:09:41,240 --> 00:09:44,600
There's a kind of nice duality between unreliable packet

225
00:09:44,600 --> 00:09:46,600
networking and turn completeness.

226
00:09:46,600 --> 00:09:48,760
And when you drop a packet because it's

227
00:09:48,760 --> 00:09:52,600
spending too long, you're essentially detecting congestion

228
00:09:52,600 --> 00:09:54,600
in the CPU.

229
00:09:54,600 --> 00:09:57,600
And so that kind of makes a certain amount of sense.

230
00:09:57,600 --> 00:10:00,040
Node.js has shown that you can actually do very useful

231
00:10:00,040 --> 00:10:01,880
things with non-preemptive systems.

232
00:10:01,880 --> 00:10:04,080
One of the most interesting problems in building a system

233
00:10:04,080 --> 00:10:05,960
like this is you're going to have certain kinds of

234
00:10:05,960 --> 00:10:07,800
non-determinism that you can't avoid.

235
00:10:07,800 --> 00:10:09,040
Let's say I write an infinite loop.

236
00:10:09,040 --> 00:10:09,720
I made a mistake.

237
00:10:09,720 --> 00:10:10,600
I wrote an infinite loop.

238
00:10:10,600 --> 00:10:12,920
I pressed Control C. One thing I really want there is a

239
00:10:12,920 --> 00:10:13,920
stack trace.

240
00:10:13,920 --> 00:10:15,480
So that stack trace is completely

241
00:10:15,480 --> 00:10:16,960
non-deterministic information.

242
00:10:16,960 --> 00:10:20,440
You can't get that into a deterministic way.

243
00:10:20,440 --> 00:10:25,000
But all is not lost because basically the underlying C

244
00:10:25,000 --> 00:10:27,880
code that actually implements this system sees that stack

245
00:10:27,880 --> 00:10:29,400
trace, has that stack trace.

246
00:10:29,400 --> 00:10:32,040
All it needs to do is basically inject that back in as a

247
00:10:32,040 --> 00:10:33,400
deterministic event.

248
00:10:33,400 --> 00:10:36,040
And so basically, you get an event that says, hey, I was

249
00:10:36,040 --> 00:10:37,760
trying to do this packet, but it crashed.

250
00:10:37,760 --> 00:10:38,640
And here's where it crashed.

251
00:10:38,640 --> 00:10:40,840
And then you can write that to the user in the appropriate

252
00:10:40,840 --> 00:10:42,680
way, and that actually works.

253
00:10:42,680 --> 00:10:47,560
So if you replay that log, we've replayed 30 gigabyte logs

254
00:10:47,560 --> 00:10:50,400
and wound up for the same bit for bit state.

255
00:10:50,400 --> 00:10:53,200
If you replay that log, it will replay the error.

256
00:10:53,200 --> 00:10:54,520
Essentially, it won't even bother with their

257
00:10:54,520 --> 00:10:55,520
original transaction.

258
00:10:55,520 --> 00:10:57,800
So this is not pieing the sky.

259
00:10:57,800 --> 00:10:59,320
This is a working system.

260
00:10:59,320 --> 00:11:02,400
This is clearly doable.

261
00:11:02,400 --> 00:11:06,400
So probably a lot of Lisp fans in the audience, let's try

262
00:11:06,400 --> 00:11:08,040
doing this in Lisp.

263
00:11:08,040 --> 00:11:10,960
So it's actually easy to define a life cycle function in

264
00:11:10,960 --> 00:11:11,600
Lisp.

265
00:11:11,600 --> 00:11:16,080
You simply say, OK, the first event in the log is my

266
00:11:16,080 --> 00:11:17,280
operating system.

267
00:11:17,280 --> 00:11:20,880
And all the rest of the log, the cutter of the log, is the

268
00:11:20,880 --> 00:11:21,560
rest of the event.

269
00:11:21,560 --> 00:11:24,000
So run the operating system on the rest of the events.

270
00:11:24,000 --> 00:11:25,280
You still have to write the function.

271
00:11:25,280 --> 00:11:27,960
But OK, you've made progress.

272
00:11:27,960 --> 00:11:29,680
And now, all we need is the one true Lisp.

273
00:11:32,480 --> 00:11:37,200
So I think all Lisp needs is the one true Lisp.

274
00:11:37,200 --> 00:11:38,760
There have been a lot of attempts to create the one

275
00:11:38,760 --> 00:11:39,720
true Lisp.

276
00:11:39,720 --> 00:11:41,960
I haven't really worked out.

277
00:11:41,960 --> 00:11:44,640
In my view, that's basically a problem that goes back to

278
00:11:44,640 --> 00:11:48,600
really the root of how we came up with this idea of

279
00:11:48,600 --> 00:11:49,240
computing.

280
00:11:49,240 --> 00:11:53,480
Because the Lambda Calculus is OK.

281
00:11:53,480 --> 00:11:54,280
We're at LambdaConf.

282
00:11:54,280 --> 00:11:55,960
I can't say bad things about Lambda Calculus.

283
00:11:55,960 --> 00:11:58,920
But it was originally designed not as a means of

284
00:11:58,920 --> 00:11:59,400
programming.

285
00:11:59,400 --> 00:12:01,320
It was originally designed as basically a

286
00:12:01,320 --> 00:12:02,880
metamathematical tool.

287
00:12:02,880 --> 00:12:05,160
And people picked this up, and they found, hey, wow, this

288
00:12:05,160 --> 00:12:07,560
thing that Church came up with actually works really well

289
00:12:07,560 --> 00:12:08,440
for programming.

290
00:12:08,440 --> 00:12:10,560
So you take that in one direction, and it becomes Lisp.

291
00:12:10,560 --> 00:12:12,160
You take that in another direction, much more

292
00:12:12,160 --> 00:12:14,840
mathematical, and it becomes Haskell.

293
00:12:14,840 --> 00:12:17,640
And it's not like Lisp and Haskell are compatible in

294
00:12:17,640 --> 00:12:18,120
any ways.

295
00:12:18,120 --> 00:12:20,560
You're always basically taking Lambda, and you're growing

296
00:12:20,560 --> 00:12:23,640
hair on it to make it a practical system.

297
00:12:23,680 --> 00:12:26,840
And I would say that that comes from basically a very

298
00:12:26,840 --> 00:12:31,600
deep conflict in the heart of Lambda, which is that it has

299
00:12:31,600 --> 00:12:34,440
these features that are like symbols and variables and

300
00:12:34,440 --> 00:12:38,120
scope that are features of a higher level language.

301
00:12:38,120 --> 00:12:41,040
But if you want to use that as an axiomatic system, and we

302
00:12:41,040 --> 00:12:44,040
just saw a talk on Shen which compiles to Lisp, if you want

303
00:12:44,040 --> 00:12:47,240
to use that as an axiomatic system, basically, and put

304
00:12:47,240 --> 00:12:50,000
the higher level language as something that is actually

305
00:12:50,000 --> 00:12:53,280
loaded onto that axiomatic interpreter, then those things

306
00:12:53,280 --> 00:12:54,040
are in the wrong place.

307
00:12:54,040 --> 00:12:55,400
They're in the wrong layer.

308
00:12:55,400 --> 00:12:58,040
And if you're going to build an axiomatic system like this,

309
00:12:58,040 --> 00:13:00,440
you have just the demands on the precision of your

310
00:13:00,440 --> 00:13:02,280
interpreter are just extremely high.

311
00:13:02,280 --> 00:13:05,160
You want that to be just tiny and diamond perfect.

312
00:13:05,160 --> 00:13:06,920
And you can't grow hair on it.

313
00:13:06,920 --> 00:13:10,600
So in a way, basically, you sort of have no choice but to

314
00:13:10,600 --> 00:13:13,520
invent a kind of different computational model at the

315
00:13:13,520 --> 00:13:15,280
bottom end.

316
00:13:15,280 --> 00:13:20,880
So this gives me a motivation to actually invent all this

317
00:13:20,880 --> 00:13:22,520
crap.

318
00:13:22,520 --> 00:13:24,480
We know that you should never invent anything, but

319
00:13:24,480 --> 00:13:26,160
sometimes you have no choice.

320
00:13:26,160 --> 00:13:29,760
So the bottom of the stack is this thing called knock.

321
00:13:29,760 --> 00:13:32,320
It's a typeless, frozen, accommodator, interpreter,

322
00:13:32,320 --> 00:13:33,280
non-LAMDA.

323
00:13:33,280 --> 00:13:34,560
It's defined in 200 words.

324
00:13:34,560 --> 00:13:36,760
It fits on a t-shirt.

325
00:13:36,760 --> 00:13:40,240
Not wearing a t-shirt today, but I'll wear it tomorrow.

326
00:13:40,240 --> 00:13:44,120
And I know, I know, it's bad choice.

327
00:13:44,120 --> 00:13:46,680
On top of that is a hoon, which is a pure, strict type

328
00:13:46,680 --> 00:13:47,960
functional language.

329
00:13:47,960 --> 00:13:49,880
It compiles itself to knock.

330
00:13:49,880 --> 00:13:52,080
This is type functional programming without category

331
00:13:52,080 --> 00:13:53,440
theory.

332
00:13:53,440 --> 00:13:55,280
We've heard from some people that they hate category

333
00:13:55,280 --> 00:13:56,160
theory.

334
00:13:56,160 --> 00:13:57,400
I've heard that somewhere, not sure.

335
00:13:57,400 --> 00:13:58,760
Probably not in this room.

336
00:14:01,480 --> 00:14:04,280
So you can see how if you have a compiler that compiles

337
00:14:04,280 --> 00:14:07,800
itself to knock, then you can kind of bootstrap off of

338
00:14:07,800 --> 00:14:10,200
this basic, essentially, bootloader.

339
00:14:10,200 --> 00:14:14,120
On top of that, we have ARVO, which is a non-preemptive OS.

340
00:14:14,120 --> 00:14:15,600
And yeah, we'll see.

341
00:14:15,600 --> 00:14:17,720
So basically, what I've got to do here is just a really

342
00:14:17,760 --> 00:14:20,920
lightning tour through these three systems.

343
00:14:20,920 --> 00:14:22,800
Don't worry if there's, there might be a little bit of

344
00:14:22,800 --> 00:14:25,720
stuff you don't understand, but just kind of sit back and

345
00:14:25,720 --> 00:14:27,200
get an impression of the system.

346
00:14:27,200 --> 00:14:29,880
All right, let's go into knock for a second.

347
00:14:29,880 --> 00:14:32,320
So I sometimes call knock a functional assembly language.

348
00:14:32,320 --> 00:14:34,720
You can program in knock, but there are no symbols or

349
00:14:34,720 --> 00:14:36,720
anything, so you're typing numbers and doing tree

350
00:14:36,720 --> 00:14:38,400
geometry by hand.

351
00:14:38,400 --> 00:14:40,040
Very much like writing assembly language.

352
00:14:40,040 --> 00:14:41,960
You could, but you wouldn't want to.

353
00:14:41,960 --> 00:14:43,920
It's basically, it is a list, in a sense.

354
00:14:43,920 --> 00:14:46,400
It's a list without any of these high level tools.

355
00:14:46,400 --> 00:14:48,040
How do you get symbols out of a lisp?

356
00:14:48,040 --> 00:14:49,600
Well, maybe it's not a lisp.

357
00:14:52,200 --> 00:14:55,240
A key point, no cyclic data structures, no laziness, so

358
00:14:55,240 --> 00:14:56,600
no infinite data structures.

359
00:14:56,600 --> 00:14:58,640
You cannot knock as an interpreter, which cannot

360
00:14:58,640 --> 00:15:00,760
create cycles.

361
00:15:00,760 --> 00:15:03,480
I think that is basically very much the right choice in the

362
00:15:03,480 --> 00:15:04,840
modern world.

363
00:15:04,840 --> 00:15:07,040
No tracing garbage collectors.

364
00:15:07,040 --> 00:15:09,520
Kind of nice.

365
00:15:09,520 --> 00:15:11,640
Also, remember, this is a persistent system.

366
00:15:11,640 --> 00:15:13,680
And if you look at persistent systems, any kind of

367
00:15:13,680 --> 00:15:18,240
database, whether it's no SQL or a SQL, basically you'll see

368
00:15:18,240 --> 00:15:20,040
acyclic data structures everywhere there.

369
00:15:20,040 --> 00:15:24,000
You will not see very many successful databases that

370
00:15:24,000 --> 00:15:26,360
use cyclic data structures.

371
00:15:26,360 --> 00:15:30,440
And it's also, if you're sending data over the network, how

372
00:15:30,440 --> 00:15:32,360
do you send a lazy list over the network?

373
00:15:32,360 --> 00:15:34,040
How do you send a cycle over the network?

374
00:15:34,040 --> 00:15:34,800
I mean, you can.

375
00:15:34,800 --> 00:15:36,720
It's a little bit harder.

376
00:15:36,720 --> 00:15:40,800
And so this is definitely very much designed for the

377
00:15:40,800 --> 00:15:42,960
network edge, obviously.

378
00:15:42,960 --> 00:15:44,760
It should be extremely efficient.

379
00:15:44,760 --> 00:15:45,880
We'll get to how that works in a bit.

380
00:15:45,880 --> 00:15:47,080
It should fit on a t-shirt.

381
00:15:47,080 --> 00:15:49,280
It should be obviously perfect.

382
00:15:49,280 --> 00:15:52,160
I believe that actually I've hit these points.

383
00:15:52,160 --> 00:15:53,320
So concepts of knock.

384
00:15:53,320 --> 00:15:53,600
Quick.

385
00:15:53,600 --> 00:15:55,480
So a value in knock is a noun.

386
00:15:55,480 --> 00:15:58,680
A noun is basically our version of S expressions.

387
00:15:58,680 --> 00:16:01,440
It's S expressions without the S, because basically all that

388
00:16:01,440 --> 00:16:02,800
stuff has been stripped off.

389
00:16:02,800 --> 00:16:05,280
List, essentially, I would say has almost kind of a dynamic

390
00:16:05,280 --> 00:16:08,120
type system for atoms, which you need if you don't have

391
00:16:08,120 --> 00:16:10,440
another type system on top of it, because how do you print

392
00:16:10,440 --> 00:16:11,920
an atom?

393
00:16:11,920 --> 00:16:13,640
Well, if you have a type system, the type system will

394
00:16:13,640 --> 00:16:14,600
tell you how to print the atom.

395
00:16:14,600 --> 00:16:17,440
But if you don't have it, so basically an atom is just an

396
00:16:17,440 --> 00:16:18,840
unsigned integer of any size.

397
00:16:18,840 --> 00:16:20,040
We use this.

398
00:16:20,040 --> 00:16:21,480
An atom will be a number.

399
00:16:21,480 --> 00:16:22,600
It could be a string.

400
00:16:22,600 --> 00:16:24,000
It could be a network packet.

401
00:16:24,000 --> 00:16:25,960
It could be a giant file.

402
00:16:25,960 --> 00:16:27,640
It's a blob.

403
00:16:27,640 --> 00:16:30,440
But a blob as a number, not as a blob as a number.

404
00:16:30,440 --> 00:16:32,920
And this is how long the number is.

405
00:16:32,920 --> 00:16:34,920
A cell is an ordered pair of any two nouns.

406
00:16:34,920 --> 00:16:37,680
We don't do pointer comparison.

407
00:16:37,680 --> 00:16:41,880
This abstraction is completely semantically opaque.

408
00:16:41,880 --> 00:16:45,040
Knock itself is a function from two nouns, or a cell of

409
00:16:45,040 --> 00:16:47,520
nouns, a subject and a formula to a product.

410
00:16:47,520 --> 00:16:49,040
Subject is the data.

411
00:16:49,040 --> 00:16:50,560
Formula is the function.

412
00:16:50,560 --> 00:16:52,040
A product is the result.

413
00:16:52,040 --> 00:16:54,360
And the way we define knock, we define errors as

414
00:16:54,360 --> 00:16:55,080
non-termination.

415
00:16:55,080 --> 00:16:57,680
So errors are basically anything that produces bottom.

416
00:16:57,680 --> 00:16:59,920
Obviously, we don't do that in practice.

417
00:16:59,920 --> 00:17:04,120
But that's how we define the function.

418
00:17:04,120 --> 00:17:05,400
So let's go over the spec.

419
00:17:05,400 --> 00:17:07,800
We'll see the knock spec in two slides.

420
00:17:07,800 --> 00:17:09,920
These are reduction rules.

421
00:17:09,920 --> 00:17:12,320
You see four basic operators here.

422
00:17:12,320 --> 00:17:16,000
The first one is question mark, or as I would say, what?

423
00:17:16,000 --> 00:17:17,240
This is a deep operator.

424
00:17:17,240 --> 00:17:21,080
So is this a cell, or is it an atom?

425
00:17:21,080 --> 00:17:22,960
If it's a cell, it's zero, meaning true.

426
00:17:22,960 --> 00:17:26,080
And if it's an atom, it's one, meaning false.

427
00:17:26,080 --> 00:17:28,120
Zero for true, one for false.

428
00:17:28,120 --> 00:17:31,760
Probably a decision I might do differently next time.

429
00:17:31,760 --> 00:17:35,280
But it's morally right, and it works.

430
00:17:35,280 --> 00:17:37,400
We can also increment an atom.

431
00:17:37,400 --> 00:17:39,840
That's our only arithmetic operator is increment.

432
00:17:40,720 --> 00:17:43,320
If you try to increment a cell, it reduces to itself,

433
00:17:43,320 --> 00:17:46,640
which means an infinite loop, which means an error.

434
00:17:46,640 --> 00:17:48,280
You can test for equality, same thing.

435
00:17:48,280 --> 00:17:51,080
You can't test for an atom for equality.

436
00:17:51,080 --> 00:17:53,600
And the only interesting operator here is this slash,

437
00:17:53,600 --> 00:17:56,560
which is a slot, which is a tree addressing scheme.

438
00:17:56,560 --> 00:18:01,240
So in this tree addressing scheme, basically, one

439
00:18:01,240 --> 00:18:04,240
is the root of the tree, two n is the left child of any node,

440
00:18:04,240 --> 00:18:06,080
two n plus one is the right child.

441
00:18:06,080 --> 00:18:08,560
So basically, having this kind of simple tree addressing

442
00:18:08,560 --> 00:18:10,160
built into the fundamental interpreter

443
00:18:10,160 --> 00:18:13,400
is what lets us not have to deal with scopes and environments

444
00:18:13,400 --> 00:18:17,600
and basically all that jazz that we know and love from Wisp.

445
00:18:17,600 --> 00:18:19,480
So that's all higher level stuff.

446
00:18:19,480 --> 00:18:22,880
All right, so this is the rest of the knock spec.

447
00:18:22,880 --> 00:18:24,960
This is a complete spec here.

448
00:18:24,960 --> 00:18:27,560
So the first reduction rule here is kind of interesting.

449
00:18:27,560 --> 00:18:29,680
This is something I call autocons.

450
00:18:29,680 --> 00:18:33,720
So basically, if you have a knock formula,

451
00:18:33,720 --> 00:18:36,480
either the head of that formula, the formula is always a cell.

452
00:18:36,480 --> 00:18:37,400
It's always a pair.

453
00:18:37,400 --> 00:18:40,320
The head of that formula is either a cell or an atom.

454
00:18:40,320 --> 00:18:42,160
If it's a cell, then what we have here

455
00:18:42,160 --> 00:18:43,560
is a pair of two formulas.

456
00:18:43,560 --> 00:18:46,240
And the semantics of that is cons in those formulas.

457
00:18:46,240 --> 00:18:47,800
So basically, you can build up, you

458
00:18:47,800 --> 00:18:50,480
know, cons is essentially an implicit operator in a way here.

459
00:18:50,480 --> 00:18:53,600
You can build up and just glom formulas together

460
00:18:53,600 --> 00:18:57,600
and you get this kind of automatically cons thing.

461
00:18:57,600 --> 00:19:02,480
Otherwise, so if you see A here is always the subject

462
00:19:02,480 --> 00:19:05,520
and then we're pattern matching in the formula.

463
00:19:05,960 --> 00:19:07,720
This, by the way, is not the syntax or anything.

464
00:19:07,720 --> 00:19:09,040
It's just pseudocode.

465
00:19:09,040 --> 00:19:11,160
Obviously, if you're writing axioms at a certain level,

466
00:19:11,160 --> 00:19:12,440
they're written in English.

467
00:19:15,160 --> 00:19:23,040
So if the head of a formula is a number, then if it's well

468
00:19:23,040 --> 00:19:25,840
formed, otherwise, you see down at the bottom,

469
00:19:25,840 --> 00:19:27,880
anything that's not well formed resolves to itself.

470
00:19:27,880 --> 00:19:29,800
Again, an error.

471
00:19:29,800 --> 00:19:32,760
If it's well formed, we have instruction 0,

472
00:19:32,760 --> 00:19:35,000
which is just the slot operator.

473
00:19:35,000 --> 00:19:36,680
So that lets us basically pick out

474
00:19:36,680 --> 00:19:39,880
a subtree of the subject.

475
00:19:39,880 --> 00:19:43,520
And then, you know, one, constant.

476
00:19:43,520 --> 00:19:44,920
Two is eval.

477
00:19:44,920 --> 00:19:50,360
So basically, B and C here are formulas

478
00:19:50,360 --> 00:19:53,040
against the current subject for a new subject in formula

479
00:19:53,040 --> 00:19:55,200
that we're going to evaluate.

480
00:19:55,200 --> 00:19:56,680
Again, pretty straightforward.

481
00:19:56,680 --> 00:20:00,480
3, 4, and 5 are the deep bump in same operators

482
00:20:00,480 --> 00:20:02,560
that we've seen before.

483
00:20:02,600 --> 00:20:06,440
Depth test, increment, and equals.

484
00:20:06,440 --> 00:20:07,800
Those are actually all the operators

485
00:20:07,800 --> 00:20:10,680
that we need for not to be as expressive as it wants to be.

486
00:20:10,680 --> 00:20:13,720
So we could actually throw away 6 through 10 completely

487
00:20:13,720 --> 00:20:16,960
and have a much shorter, cleaner spec.

488
00:20:16,960 --> 00:20:19,440
There are simpler Turing-complete interpreters

489
00:20:19,440 --> 00:20:20,120
in this, certainly.

490
00:20:20,120 --> 00:20:24,280
So this is intended to be a practical Turing-complete

491
00:20:24,280 --> 00:20:25,320
interpreter.

492
00:20:25,320 --> 00:20:27,880
And it is actually practical, believe it or not.

493
00:20:27,880 --> 00:20:30,240
And you probably don't believe it.

494
00:20:30,240 --> 00:20:38,080
But so 6 is, I'll leave you with an exercise to the reader

495
00:20:38,080 --> 00:20:39,680
if you can figure out how these macros work,

496
00:20:39,680 --> 00:20:41,480
but 6 through 10 are all macros.

497
00:20:41,480 --> 00:20:43,200
6 is if and else.

498
00:20:43,200 --> 00:20:45,560
7 composes two formulas.

499
00:20:45,560 --> 00:20:48,560
8 composes a formula with the cell

500
00:20:48,560 --> 00:20:49,720
of the product of a formula.

501
00:20:49,720 --> 00:20:51,680
It's basically declaring a variable, essentially.

502
00:20:51,680 --> 00:20:55,600
You're putting a new value onto that subject

503
00:20:55,600 --> 00:20:58,760
and then using it for the next formula.

504
00:20:58,760 --> 00:21:01,000
9 is essentially implementing what

505
00:21:01,000 --> 00:21:06,080
whom we use as a function call to simplify it enormously.

506
00:21:06,080 --> 00:21:07,240
And 10 is a hint.

507
00:21:07,240 --> 00:21:09,040
So you see two 10s there because you

508
00:21:09,040 --> 00:21:11,240
can have a dynamic hint or a static hint.

509
00:21:11,240 --> 00:21:13,000
What a hint is in this environment

510
00:21:13,000 --> 00:21:15,000
is an instruction that throws away data.

511
00:21:15,000 --> 00:21:17,040
So if you discard data, basically,

512
00:21:17,040 --> 00:21:18,360
you're saying to the interpreter,

513
00:21:18,360 --> 00:21:19,840
do whatever you want with this data.

514
00:21:19,840 --> 00:21:20,920
Do something with it.

515
00:21:20,920 --> 00:21:24,600
So hints or anything like a debugging printf is a hint.

516
00:21:24,600 --> 00:21:27,800
You're like, yeah, I don't know that a debugging printf happened.

517
00:21:27,800 --> 00:21:31,120
But if you want to make it happen, make it happen.

518
00:21:31,120 --> 00:21:31,840
Memoization.

519
00:21:31,840 --> 00:21:33,520
There's a memoization hint.

520
00:21:33,520 --> 00:21:34,640
That's another good example.

521
00:21:34,640 --> 00:21:36,800
So the hint basically doesn't change

522
00:21:36,800 --> 00:21:40,720
the formal result of the computation,

523
00:21:40,720 --> 00:21:43,600
but it helps the interpreter do something interesting with it.

524
00:21:43,600 --> 00:21:44,480
So that's all of NOC.

525
00:21:46,920 --> 00:21:49,360
And now let's see.

526
00:21:49,360 --> 00:21:50,560
Here's a little example.

527
00:21:50,560 --> 00:21:56,040
So NOC, of course, the only integer operation is increment.

528
00:21:56,040 --> 00:21:58,160
So if you want to decrement, well,

529
00:21:58,160 --> 00:21:59,440
that's a little bit of a problem.

530
00:21:59,440 --> 00:22:01,360
You actually have to write some code.

531
00:22:01,360 --> 00:22:03,680
You're going to actually have to count up to n minus 1

532
00:22:03,680 --> 00:22:05,440
to decrement.

533
00:22:05,440 --> 00:22:06,200
Not a big deal.

534
00:22:06,200 --> 00:22:08,000
Very simple algorithm.

535
00:22:08,000 --> 00:22:09,640
So here, we're jumping ahead.

536
00:22:09,640 --> 00:22:11,600
And on the right side of your screen, basically,

537
00:22:11,600 --> 00:22:13,800
you're seeing some poon.

538
00:22:13,800 --> 00:22:16,760
Those are two, basically, kind of alternate syntaxes for poon.

539
00:22:16,760 --> 00:22:19,200
One of them is a keyword syntax, which you can probably read

540
00:22:19,200 --> 00:22:20,560
just by looking at it.

541
00:22:20,560 --> 00:22:23,280
The other one is a rune syntax, which you probably can't read,

542
00:22:23,280 --> 00:22:24,960
but that's what we actually use in practice.

543
00:22:25,000 --> 00:22:28,680
It's kind of training wheels, no training wheels.

544
00:22:28,680 --> 00:22:31,560
And on the left is the actual NOC formula

545
00:22:31,560 --> 00:22:33,320
that we generate from this.

546
00:22:33,320 --> 00:22:35,200
If I had a couple more hours, I would actually

547
00:22:35,200 --> 00:22:36,200
go through this formula.

548
00:22:36,200 --> 00:22:39,840
But as it is, it'll just have to serve as an example.

549
00:22:39,840 --> 00:22:42,120
All we're doing is we're basically saying, OK,

550
00:22:42,120 --> 00:22:45,160
we're going to call the subject a, because that's the number

551
00:22:45,160 --> 00:22:46,120
we're decrementing.

552
00:22:46,120 --> 00:22:49,320
We're going to add a counter, which is 0.

553
00:22:49,320 --> 00:22:50,120
We're going to loop.

554
00:22:50,120 --> 00:22:56,800
And we're going to count up until the increment of b is a.

555
00:22:56,800 --> 00:22:59,200
If that is true, our product is b.

556
00:22:59,200 --> 00:23:00,920
Otherwise, we're going to loop again

557
00:23:00,920 --> 00:23:03,120
with b changed to the increment of b.

558
00:23:03,120 --> 00:23:08,000
Pretty straightforward decrement, not super hard.

559
00:23:08,000 --> 00:23:10,840
But that kind of brings up a problem

560
00:23:10,840 --> 00:23:15,480
that you might think of, which is g, o of n decrement.

561
00:23:15,480 --> 00:23:18,000
Well, if you actually run, if you try to boot

562
00:23:18,000 --> 00:23:20,520
urbit with a completely naive interpreter,

563
00:23:20,520 --> 00:23:22,080
it will immediately start decrementing

564
00:23:22,080 --> 00:23:24,360
and keep decrementing until pretty much the end of time.

565
00:23:24,360 --> 00:23:27,800
So that's clearly basically a non-starter.

566
00:23:27,800 --> 00:23:30,240
There's a well-known solution to optimization problems

567
00:23:30,240 --> 00:23:30,800
of this kind.

568
00:23:30,800 --> 00:23:33,680
It's called a sufficiently smart interpreter.

569
00:23:33,680 --> 00:23:35,560
All your interpreter has to do is simply

570
00:23:35,560 --> 00:23:38,280
recognize that it needs to analyze the algorithm that

571
00:23:38,280 --> 00:23:41,240
it's interpreting, recognize that it's decrement algorithm,

572
00:23:41,240 --> 00:23:44,000
and implement it efficiently accordingly.

573
00:23:44,000 --> 00:23:46,160
We also need to recognize add, multiply,

574
00:23:46,160 --> 00:23:47,880
and all of their interesting functions.

575
00:23:47,880 --> 00:23:50,120
So if you know anything about compiler theory,

576
00:23:50,120 --> 00:23:53,400
you know that this is a very hard problem.

577
00:23:53,400 --> 00:23:55,720
Fortunately, there's a much easier problem

578
00:23:55,720 --> 00:23:56,960
which is related to it.

579
00:23:56,960 --> 00:23:58,640
We don't have to recognize every decrement.

580
00:23:58,640 --> 00:24:00,880
We just have to recognize the one that we actually call,

581
00:24:00,880 --> 00:24:03,200
which is the one in the standard library.

582
00:24:03,200 --> 00:24:07,440
And so basically, the way we optimize in the system,

583
00:24:07,440 --> 00:24:09,520
and this should be sort of compared to,

584
00:24:09,520 --> 00:24:12,080
let's say you're building, you're using Java or using Python.

585
00:24:12,080 --> 00:24:15,920
What you do is you say, OK, I wrote some pure code.

586
00:24:15,920 --> 00:24:16,560
It's beautiful.

587
00:24:17,360 --> 00:24:19,880
Oh, it's not fast enough.

588
00:24:19,880 --> 00:24:21,760
And I guess I need a native method.

589
00:24:21,760 --> 00:24:25,600
So then you call it to C. You rewrite your interloop

590
00:24:25,600 --> 00:24:28,800
or whatever in C. You throw away their original pure code.

591
00:24:28,800 --> 00:24:30,360
There's another great advantage, which

592
00:24:30,360 --> 00:24:32,520
is that your interloop in C can make system calls.

593
00:24:32,520 --> 00:24:36,200
So it can modify the file system or something.

594
00:24:36,200 --> 00:24:42,000
And that is not necessarily a very functional way

595
00:24:42,000 --> 00:24:43,720
of proceeding.

596
00:24:43,720 --> 00:24:46,280
The way we optimize knock and hoon is a little different.

597
00:24:46,280 --> 00:24:49,240
So we basically say, when you write, say, decrement,

598
00:24:49,240 --> 00:24:51,920
you say, OK, I'm going to declare this in a namespace.

599
00:24:51,920 --> 00:24:53,840
I'm going to say to the interpreter,

600
00:24:53,840 --> 00:24:55,480
I believe this to be decrement.

601
00:24:55,480 --> 00:24:57,040
It's just a conventional name.

602
00:24:57,040 --> 00:24:57,840
This is decrement.

603
00:24:57,840 --> 00:25:00,280
The interpreter is like, oh, he says this is decrement.

604
00:25:00,280 --> 00:25:00,920
Is this true?

605
00:25:00,920 --> 00:25:04,720
Well, gee, I'm built to recognize, literally,

606
00:25:04,720 --> 00:25:06,840
with the hash of the formula, I'm

607
00:25:06,840 --> 00:25:10,240
built to run this specific formula efficiently.

608
00:25:10,240 --> 00:25:12,720
So I'm going to match this, which is a slightly hard problem,

609
00:25:12,720 --> 00:25:14,320
but I don't know how to super hard problem.

610
00:25:14,320 --> 00:25:15,680
I'm going to match this at runtime,

611
00:25:15,680 --> 00:25:17,560
and then I'm going to do the efficient decrement.

612
00:25:17,560 --> 00:25:19,200
So the advantage of this approach,

613
00:25:19,200 --> 00:25:21,560
and there's a number of advantages of this approach.

614
00:25:21,560 --> 00:25:23,760
First of all, you have both those routines,

615
00:25:23,760 --> 00:25:25,920
the fast decrement in C, which is totally

616
00:25:25,920 --> 00:25:27,480
an implementation detail.

617
00:25:27,480 --> 00:25:30,720
And you're separating mechanism and policy there,

618
00:25:30,720 --> 00:25:31,160
essentially.

619
00:25:31,160 --> 00:25:33,240
So you have your fast decrement in C,

620
00:25:33,240 --> 00:25:38,680
and then you're essentially executable specification

621
00:25:38,680 --> 00:25:40,200
of decrement.

622
00:25:40,200 --> 00:25:43,920
And you're basically binding the two together.

623
00:25:43,920 --> 00:25:47,560
So obviously, you can test these against each other

624
00:25:47,560 --> 00:25:49,520
at runtime, if you choose.

625
00:25:49,520 --> 00:25:51,840
There's certainly, you can sandbox your jet,

626
00:25:51,840 --> 00:25:55,960
so it has no reason to make system calls.

627
00:25:55,960 --> 00:25:59,960
You can also extend this up the stack quite a ways.

628
00:25:59,960 --> 00:26:03,880
So for example, we have one of the,

629
00:26:03,880 --> 00:26:06,440
we serve our own website using Herbit.

630
00:26:06,440 --> 00:26:09,280
And one of the, we serve it from Markdown.

631
00:26:09,280 --> 00:26:11,160
So we have a Markdown parser written in Hoon.

632
00:26:11,160 --> 00:26:13,080
Well, it's a decent Markdown parser.

633
00:26:13,120 --> 00:26:15,240
Maybe not the world's fastest.

634
00:26:15,240 --> 00:26:17,760
Fortunately, Markdown is a standard for some values

635
00:26:17,760 --> 00:26:19,760
of the word standard.

636
00:26:19,760 --> 00:26:23,560
And we basically jet that Markdown parser

637
00:26:23,560 --> 00:26:26,600
with an efficient common mark implementation in C.

638
00:26:26,600 --> 00:26:29,120
Our, for another example is, Google

639
00:26:29,120 --> 00:26:31,600
has this lovely library called TensorFlow.

640
00:26:31,600 --> 00:26:34,080
They recently announced that basically they built an ASIC

641
00:26:34,080 --> 00:26:35,440
for TensorFlow.

642
00:26:35,440 --> 00:26:38,400
I don't know how exactly the programmer talks to that ASIC,

643
00:26:38,400 --> 00:26:40,840
but I'm sure it's a mess.

644
00:26:40,840 --> 00:26:42,640
What you actually want to do is basically

645
00:26:42,640 --> 00:26:46,600
say, OK, I as a programmer, I'm using TensorFlow of this version.

646
00:26:46,600 --> 00:26:49,160
I run TensorFlow, I declare that this is TensorFlow

647
00:26:49,160 --> 00:26:50,360
of a certain version.

648
00:26:50,360 --> 00:26:52,600
And then my interpreter is like, aha,

649
00:26:52,600 --> 00:26:55,000
I have a chip that can speed up TensorFlow of this version.

650
00:26:55,000 --> 00:26:56,600
I'll just use that.

651
00:26:56,600 --> 00:27:00,320
And so that scales kind of in more interesting ways

652
00:27:00,320 --> 00:27:03,880
than the, let's call it, to see model scale.

653
00:27:03,880 --> 00:27:06,080
So we also use it, by the way, to virtualize knock.

654
00:27:06,080 --> 00:27:08,760
So there's actually a virtual knock written in knock

655
00:27:08,760 --> 00:27:10,840
if you thought knock was slow.

656
00:27:10,880 --> 00:27:14,680
But basically, you can get unlimited levels of virtualization

657
00:27:14,680 --> 00:27:17,040
pyramid by basically just recognizing

658
00:27:17,040 --> 00:27:19,320
that you're running your own virtualizer and just saying,

659
00:27:19,320 --> 00:27:21,400
hey, we're at six levels deep.

660
00:27:21,400 --> 00:27:22,960
So that's an improvement as well.

661
00:27:22,960 --> 00:27:24,200
All right, we're done with knock.

662
00:27:24,200 --> 00:27:25,080
That's knock.

663
00:27:25,080 --> 00:27:25,600
Pretty cool.

664
00:27:25,600 --> 00:27:28,440
Let's build Hoon.

665
00:27:28,440 --> 00:27:31,640
Hoon obviously needs to compile itself to knock.

666
00:27:31,640 --> 00:27:34,360
It needs to be a pure strict higher order type functional

667
00:27:34,360 --> 00:27:36,840
language, because that's the hotness.

668
00:27:36,840 --> 00:27:39,040
It needs to have a, I believe it needs

669
00:27:39,040 --> 00:27:40,840
to have a simple transformation to knock.

670
00:27:40,840 --> 00:27:43,080
So I'm really a Unix and Seaguy.

671
00:27:43,080 --> 00:27:46,080
I'm not a functional programming guy at all,

672
00:27:46,080 --> 00:27:49,640
and actually don't know any of their functional languages.

673
00:27:49,640 --> 00:27:53,000
And so that sort of simplicity, that feeling

674
00:27:53,000 --> 00:27:55,240
that basically the compiler is doing something

675
00:27:55,240 --> 00:27:58,560
very simple for you, is really like a wonderful feeling

676
00:27:58,560 --> 00:28:00,560
when you're working inside C. You're

677
00:28:00,560 --> 00:28:03,240
seeing the system basically at two levels.

678
00:28:03,240 --> 00:28:05,800
We definitely want a system that doesn't require

679
00:28:05,800 --> 00:28:08,200
people to have a math degree.

680
00:28:08,240 --> 00:28:11,360
And that's a subject to complaint.

681
00:28:11,360 --> 00:28:14,040
I think more generally, one of the things

682
00:28:14,040 --> 00:28:16,600
that languages like Haskell do is they encourage

683
00:28:16,600 --> 00:28:17,960
their functional programming languages,

684
00:28:17,960 --> 00:28:20,320
and they encourage you to use these powerful tools

685
00:28:20,320 --> 00:28:22,680
as much as possible.

686
00:28:22,680 --> 00:28:23,760
Hoon is kind of opposite.

687
00:28:23,760 --> 00:28:26,680
It encourages you to not use these tools.

688
00:28:26,680 --> 00:28:29,920
It's basically like, OK, the power is there if you need it.

689
00:28:29,920 --> 00:28:32,200
But bear in mind, when you're using this kind of functional

690
00:28:32,200 --> 00:28:34,400
power, you're imposing cognitive overhead

691
00:28:34,400 --> 00:28:36,440
on the ordinary programmer.

692
00:28:36,440 --> 00:28:39,120
Because we really want this to be something

693
00:28:39,120 --> 00:28:42,000
that a Python programmer can pick up and program in.

694
00:28:42,000 --> 00:28:46,120
And I think the ability to basically teach people

695
00:28:46,120 --> 00:28:50,000
these higher order constructs is really debatable.

696
00:28:50,000 --> 00:28:52,360
I don't think it's proven at all.

697
00:28:52,360 --> 00:28:54,960
There's another thing that often happens, both with macros

698
00:28:54,960 --> 00:28:57,560
and with kind of advanced functional languages,

699
00:28:57,560 --> 00:28:59,440
where you get into this kind of DSL pattern,

700
00:28:59,440 --> 00:29:02,760
where basically you're so higher order, you're so meta,

701
00:29:02,760 --> 00:29:06,800
that every file is written in its own language, which

702
00:29:06,800 --> 00:29:08,440
basically gets you to write only code.

703
00:29:08,440 --> 00:29:10,920
And that's like a kind of serious downside

704
00:29:10,920 --> 00:29:13,200
of functional programming.

705
00:29:13,200 --> 00:29:15,960
And the thing is Hoon is still basically almost as

706
00:29:15,960 --> 00:29:17,560
expressive as Haskell.

707
00:29:17,560 --> 00:29:19,480
It has the equivalent of type classes.

708
00:29:19,480 --> 00:29:20,600
It has generosity.

709
00:29:20,600 --> 00:29:23,240
It's like, it's not Haskell.

710
00:29:23,240 --> 00:29:25,160
Haskell people will be a little disappointed in it,

711
00:29:25,160 --> 00:29:28,600
but it's definitely not a lisp.

712
00:29:28,600 --> 00:29:31,960
OK, so let's go a little more into detail on Hoon.

713
00:29:32,840 --> 00:29:35,520
So basically, the back end of Hoon is extremely simple.

714
00:29:35,520 --> 00:29:38,120
So type inference and code generation together,

715
00:29:38,120 --> 00:29:40,440
1,500 lines of code.

716
00:29:40,440 --> 00:29:42,360
Shouldn't be super hard to learn.

717
00:29:42,360 --> 00:29:45,720
So where basically Nock is doing subject and formula

718
00:29:45,720 --> 00:29:48,640
to product, of course, in Hoon, we have an actual expression

719
00:29:48,640 --> 00:29:51,120
that is written in, for some values of the word,

720
00:29:51,120 --> 00:29:54,120
user level code, user level code.

721
00:29:54,120 --> 00:29:56,520
The experience of programming without an environment,

722
00:29:56,520 --> 00:29:58,160
or without a scope, or without a heap,

723
00:29:58,160 --> 00:30:01,200
or without the sort of extra piece of state,

724
00:30:01,240 --> 00:30:04,080
where you just have, the subject is just one noun,

725
00:30:04,080 --> 00:30:06,360
and everything that you need is in the subject,

726
00:30:06,360 --> 00:30:09,160
is sort of somewhat unique and different.

727
00:30:09,160 --> 00:30:11,200
You keep sort of reaching for that,

728
00:30:11,200 --> 00:30:13,000
oh, there must be something that has my variables,

729
00:30:13,000 --> 00:30:14,720
but no, there's really just one noun

730
00:30:14,720 --> 00:30:16,840
that you're defining a function against.

731
00:30:18,680 --> 00:30:22,680
So when we basically take a type system

732
00:30:22,680 --> 00:30:24,960
and layer it on top of Nock,

733
00:30:24,960 --> 00:30:27,520
we're basically computing a mapping from a type in an

734
00:30:27,520 --> 00:30:30,120
expression to a type in a formula.

735
00:30:30,160 --> 00:30:33,720
So we have input type, or subject type,

736
00:30:33,720 --> 00:30:38,160
and expression turns into product type,

737
00:30:38,160 --> 00:30:40,720
and the Nock formula that computes that expression.

738
00:30:40,720 --> 00:30:44,440
So again, a very, very simple straightforward kind of

739
00:30:44,440 --> 00:30:47,280
relationship to Nock here.

740
00:30:47,280 --> 00:30:49,440
The inference algorithm is extremely stupid.

741
00:30:49,440 --> 00:30:53,880
It infers only forward, it does not use unification at all.

742
00:30:53,880 --> 00:30:57,640
It can infer tail recursion, but not head recursion.

743
00:30:58,640 --> 00:31:02,120
So a general pattern is you need a few more sort of casts

744
00:31:02,120 --> 00:31:03,200
to help the type system out.

745
00:31:03,200 --> 00:31:05,640
It's still a strict type system,

746
00:31:05,640 --> 00:31:09,480
but you need to help it a little bit.

747
00:31:09,480 --> 00:31:11,880
My view is that basically having a stupider inference

748
00:31:11,880 --> 00:31:16,760
algorithm is, again, a UI win for a language,

749
00:31:16,760 --> 00:31:19,280
because basically when you program in a language,

750
00:31:19,280 --> 00:31:23,840
you kinda need to follow what the compiler is doing.

751
00:31:23,840 --> 00:31:26,400
The more powerful the algorithm you're following,

752
00:31:26,400 --> 00:31:29,080
basically the harder it's gonna be for people to follow.

753
00:31:29,080 --> 00:31:31,880
And so when I look at Haskell, I see basically two kinds

754
00:31:31,880 --> 00:31:33,000
of Haskell users in a way.

755
00:31:33,000 --> 00:31:36,160
I see people who treat Haskell as a black box,

756
00:31:36,160 --> 00:31:38,240
and they're like, it's sort of a learn you a Haskell

757
00:31:38,240 --> 00:31:41,160
kind of way, and they're like, oh, I made it work, cool.

758
00:31:41,160 --> 00:31:43,320
And then there are the people that actually understand

759
00:31:43,320 --> 00:31:48,320
the math, and both of those situations don't scale in a way.

760
00:31:49,400 --> 00:31:52,680
And so having a simpler system is definitely,

761
00:31:53,920 --> 00:31:54,880
I think a win.

762
00:31:55,800 --> 00:31:58,400
So a little more about Hoon.

763
00:31:58,400 --> 00:32:01,560
So this is brought us in for some criticism,

764
00:32:01,560 --> 00:32:05,640
but Hoon basically, since it sort of has its own way

765
00:32:05,640 --> 00:32:07,320
of doing things, we invent a lot of terms,

766
00:32:07,320 --> 00:32:10,600
because basically the ordinary terms tend to be confusing.

767
00:32:10,600 --> 00:32:13,520
So, and we also have a four letter name

768
00:32:13,520 --> 00:32:14,720
kind of convention going on.

769
00:32:14,720 --> 00:32:17,760
So an expression, or an AST, is a twig.

770
00:32:17,760 --> 00:32:20,800
A type is, well, there's actually three things

771
00:32:20,800 --> 00:32:23,000
that are basically correspond to a type.

772
00:32:23,000 --> 00:32:25,760
So a type, as in sort of a set of nouns

773
00:32:25,760 --> 00:32:28,960
and a semantics ascribed to them, is called a span.

774
00:32:28,960 --> 00:32:32,360
A type in terms of a constructor is called a mold.

775
00:32:32,360 --> 00:32:34,800
And then we also have basically, at the kind of OS level,

776
00:32:34,800 --> 00:32:36,680
I don't think I'll get into that today,

777
00:32:36,680 --> 00:32:38,200
basically the equivalent of mind types,

778
00:32:38,200 --> 00:32:40,560
which is something else also entirely.

779
00:32:42,160 --> 00:32:43,640
Looking at molds, basically,

780
00:32:43,640 --> 00:32:45,160
Hoon is a pure prototype language.

781
00:32:45,160 --> 00:32:47,840
There's no syntax for defining a span.

782
00:32:47,840 --> 00:32:50,800
The only thing you can define are twigs.

783
00:32:50,800 --> 00:32:53,160
So when you want to define basically a span,

784
00:32:53,160 --> 00:32:54,960
a range, a type in the usual sense,

785
00:32:54,960 --> 00:32:56,840
a set of nouns that you're interested in,

786
00:32:56,840 --> 00:32:59,600
what you define is actually a normalizing function

787
00:32:59,600 --> 00:33:03,240
that takes an arbitrary noun and produces a noun

788
00:33:03,240 --> 00:33:05,680
of that type that you're interested in.

789
00:33:05,680 --> 00:33:07,480
What's kind of nice about that is that basically,

790
00:33:07,480 --> 00:33:09,280
if this is the way you define types,

791
00:33:09,280 --> 00:33:10,480
anytime you define a type,

792
00:33:10,480 --> 00:33:13,600
you've defined a validator for untrusted network data.

793
00:33:13,600 --> 00:33:17,040
So we do a fair bit of validating untrusted network data

794
00:33:17,040 --> 00:33:20,240
in today's environment, so that's kind of a win.

795
00:33:21,800 --> 00:33:24,960
Basic concepts of the type system.

796
00:33:24,960 --> 00:33:27,400
This is almost a complete definition

797
00:33:27,400 --> 00:33:28,280
of the Hoon type system.

798
00:33:28,280 --> 00:33:30,120
It's missing a little bit of stuff.

799
00:33:31,160 --> 00:33:32,240
I'll see if I can fill that in,

800
00:33:32,240 --> 00:33:34,280
but we've got to move pretty fast here.

801
00:33:35,480 --> 00:33:37,200
So, and I'm not going to talk about twigs at all,

802
00:33:37,200 --> 00:33:39,560
because once you understand basically a data representation,

803
00:33:39,560 --> 00:33:40,560
it's pretty straightforward.

804
00:33:40,560 --> 00:33:43,080
So a span defines a set of nouns.

805
00:33:43,080 --> 00:33:44,720
What can the set be?

806
00:33:44,720 --> 00:33:47,080
It can be noun, which means it could be any noun,

807
00:33:47,080 --> 00:33:49,520
any remember S expression, basically.

808
00:33:49,640 --> 00:33:51,600
It could be void, which is an empty set.

809
00:33:51,600 --> 00:33:53,480
I'm going to skip over Adam and Core,

810
00:33:53,480 --> 00:33:55,160
because I have separate slides for those.

811
00:33:55,160 --> 00:33:56,680
A cell, obviously a cell.

812
00:33:56,680 --> 00:33:59,280
Here's a span of the head, span of the tail.

813
00:33:59,280 --> 00:34:01,840
A face, basically we're going to label this span.

814
00:34:01,840 --> 00:34:03,680
And so remember that there's no symbol table,

815
00:34:03,680 --> 00:34:04,680
there's no anything in here.

816
00:34:04,680 --> 00:34:07,400
So the labels actually live inside the type.

817
00:34:07,400 --> 00:34:08,760
So when you're searching for a label,

818
00:34:08,760 --> 00:34:11,000
you're actually doing a depth-first search

819
00:34:11,000 --> 00:34:13,920
of basically the type of the subject.

820
00:34:13,920 --> 00:34:16,600
Fortunately, computers have gotten a lot faster.

821
00:34:16,600 --> 00:34:18,000
You can cache this, we do cache it,

822
00:34:18,000 --> 00:34:19,560
but I mean, fine, it's a depth-first search.

823
00:34:19,560 --> 00:34:21,280
How big is your subject, right?

824
00:34:22,560 --> 00:34:25,560
You can have a fork, which is a union of spans.

825
00:34:25,560 --> 00:34:26,840
Pretty obvious.

826
00:34:26,840 --> 00:34:29,720
And the only really interesting one in this page is hold.

827
00:34:29,720 --> 00:34:32,360
So basically one thing we never do in the systems,

828
00:34:32,360 --> 00:34:34,280
we never calculate type signatures.

829
00:34:34,280 --> 00:34:38,840
So this is a strict system, we can't do laziness.

830
00:34:38,840 --> 00:34:41,600
What hold means is basically the span here

831
00:34:41,600 --> 00:34:44,480
is the result of if you take subject P

832
00:34:44,480 --> 00:34:46,560
and run expression Q against it.

833
00:34:46,560 --> 00:34:49,240
So this is very much manual laziness.

834
00:34:50,160 --> 00:34:51,880
Manual laziness has some nice benefits.

835
00:34:51,880 --> 00:34:53,920
Namely, you can use this as a,

836
00:34:53,920 --> 00:34:56,920
you can use a manually lazy span as a key

837
00:34:56,920 --> 00:34:58,760
in a key value data structure,

838
00:34:58,760 --> 00:35:01,360
which is pretty difficult with infinite data structures.

839
00:35:03,560 --> 00:35:07,360
So that's basically, those are the simple ones.

840
00:35:07,360 --> 00:35:10,920
Let me get to the non-boring spans, Adam and Core.

841
00:35:10,920 --> 00:35:14,240
So Adam is just an Adam, slightly non-boring

842
00:35:14,240 --> 00:35:16,360
in that you can say this could be any Adam

843
00:35:16,360 --> 00:35:18,320
or you could say this could be a constant.

844
00:35:18,320 --> 00:35:21,200
So the unit there is who's equivalent of maybe.

845
00:35:22,920 --> 00:35:26,360
And so if that's set, then we have,

846
00:35:26,360 --> 00:35:27,880
this is just a constant Adam.

847
00:35:27,880 --> 00:35:30,000
Then we have P there is something interesting.

848
00:35:30,000 --> 00:35:31,920
The term is a symbol essentially.

849
00:35:32,840 --> 00:35:35,040
And we have what I call an aura.

850
00:35:35,040 --> 00:35:37,000
This is a soft type.

851
00:35:37,000 --> 00:35:39,360
This is a basically non-enforced type

852
00:35:39,360 --> 00:35:41,000
or enforced gently type.

853
00:35:41,000 --> 00:35:44,640
And if you remember, Lisp of course has this dynamic type

854
00:35:44,640 --> 00:35:47,120
and it's Adams, which is just really awful

855
00:35:47,120 --> 00:35:49,480
in my personal opinion.

856
00:35:49,480 --> 00:35:52,040
And if you have a type system, basically the type system

857
00:35:52,040 --> 00:35:55,080
when it has an Adam needs to be able to describe

858
00:35:55,080 --> 00:35:57,160
how do you print this Adam?

859
00:35:57,160 --> 00:36:00,160
Gee, what happens if I try to use a furlong

860
00:36:00,160 --> 00:36:01,440
as if it was a Fortnite?

861
00:36:02,320 --> 00:36:04,000
What happens if I try to use an IP address

862
00:36:04,000 --> 00:36:04,960
as if it was a string?

863
00:36:04,960 --> 00:36:06,160
All those are Adams.

864
00:36:06,160 --> 00:36:09,240
And so you basically need to label those

865
00:36:09,240 --> 00:36:11,400
and describe them kind of informally.

866
00:36:11,400 --> 00:36:15,080
And there's a basically system of specialization

867
00:36:15,080 --> 00:36:17,440
simply by the length of the name.

868
00:36:17,440 --> 00:36:20,560
So you can basically text, ASCII text,

869
00:36:20,560 --> 00:36:22,600
ASCII text with a symbol constraint.

870
00:36:22,600 --> 00:36:24,920
None of the, all these are informal conventions.

871
00:36:24,920 --> 00:36:27,680
None of them are, there's no dependent types in the system.

872
00:36:27,680 --> 00:36:29,560
Sorry, get another no dependent types.

873
00:36:30,560 --> 00:36:32,960
And they're not enforced at all,

874
00:36:32,960 --> 00:36:36,600
except that basically if you wanna turn an IP address

875
00:36:36,600 --> 00:36:39,960
into a string basically and be so foolish,

876
00:36:39,960 --> 00:36:41,440
you have to manually tell it,

877
00:36:41,440 --> 00:36:44,920
you have to cast up to just a raw Adam

878
00:36:44,920 --> 00:36:47,440
and then down back to your string.

879
00:36:47,440 --> 00:36:50,800
So you have to work to basically screw up that way.

880
00:36:50,800 --> 00:36:52,880
That's an interesting design.

881
00:36:52,880 --> 00:36:55,560
You don't usually see a soft type in a functional language.

882
00:36:55,560 --> 00:36:56,920
I think it's worked pretty well.

883
00:36:56,920 --> 00:36:58,600
It's not perfect.

884
00:36:58,600 --> 00:37:00,520
I think the most interesting span,

885
00:37:00,520 --> 00:37:04,600
and remember a span is describing a set of nouns.

886
00:37:04,600 --> 00:37:06,280
The most interesting one is core,

887
00:37:06,280 --> 00:37:08,760
which is essentially an object.

888
00:37:08,760 --> 00:37:10,240
Or it's an object that's sort of

889
00:37:10,240 --> 00:37:12,040
in a very broad in general sense.

890
00:37:12,040 --> 00:37:15,720
It's actually the general case of objects and functions

891
00:37:15,720 --> 00:37:17,120
and a lot of other things,

892
00:37:17,120 --> 00:37:19,320
which you don't really have a name for.

893
00:37:19,320 --> 00:37:20,680
A core is a cell.

894
00:37:20,680 --> 00:37:22,520
The head of the cell is a battery,

895
00:37:22,520 --> 00:37:25,880
which is either one formula or a tree of formulas.

896
00:37:25,880 --> 00:37:28,880
Remembering a formula is just a knock function.

897
00:37:28,880 --> 00:37:31,600
The tail is a payload, which is basically any noun.

898
00:37:33,120 --> 00:37:36,920
And when we run the arms, which are the,

899
00:37:36,920 --> 00:37:38,160
basically they're not methods,

900
00:37:38,160 --> 00:37:40,960
they're computed attributes in the battery.

901
00:37:40,960 --> 00:37:43,360
We run that with the whole core as the subject.

902
00:37:43,360 --> 00:37:44,920
So we basically have this thing

903
00:37:44,920 --> 00:37:46,440
that has a bunch of code in it.

904
00:37:46,440 --> 00:37:47,280
It's like, you can think of,

905
00:37:47,280 --> 00:37:49,280
if you know C++ implementation,

906
00:37:49,280 --> 00:37:51,920
you can think of it as like a V-table, right?

907
00:37:51,920 --> 00:37:54,860
And so it's, here's a V-table with a bunch of formulas in it.

908
00:37:54,860 --> 00:37:56,320
And you say, I wanna run,

909
00:37:56,320 --> 00:37:57,840
I wanna get foo out of this core.

910
00:37:57,840 --> 00:37:59,520
It's like, oh, great, I have a foo.

911
00:37:59,520 --> 00:38:01,920
I'm gonna basically calculate,

912
00:38:01,920 --> 00:38:04,440
that's gonna resolve to this calculation.

913
00:38:04,440 --> 00:38:06,040
So there's no separate namespace

914
00:38:06,040 --> 00:38:07,880
for basically data and for code.

915
00:38:07,880 --> 00:38:09,720
So if you're looking for foo on a core,

916
00:38:09,720 --> 00:38:11,080
and the core doesn't have foo,

917
00:38:11,080 --> 00:38:12,640
there's no foo in the battery.

918
00:38:13,880 --> 00:38:15,880
Then it goes in and says,

919
00:38:15,880 --> 00:38:17,160
oh, well, let's look in the payload.

920
00:38:17,160 --> 00:38:19,440
Let's descend down the tree.

921
00:38:19,440 --> 00:38:20,560
Notice also again,

922
00:38:20,560 --> 00:38:24,060
that there is no attempt to create a type signature here.

923
00:38:24,060 --> 00:38:26,160
So this is just a map of a term to the twig.

924
00:38:26,160 --> 00:38:27,400
Twig is a source.

925
00:38:27,400 --> 00:38:28,840
That's a source expression.

926
00:38:28,840 --> 00:38:30,720
So basically, and that's in the type.

927
00:38:30,720 --> 00:38:34,040
So when I call foo on this core,

928
00:38:34,040 --> 00:38:35,440
I basically go in and I say,

929
00:38:35,440 --> 00:38:38,680
well, okay, that's gonna generate one of these whole things.

930
00:38:38,680 --> 00:38:40,960
So it says, okay, the result,

931
00:38:40,960 --> 00:38:44,800
the type of the span of the result of this foo

932
00:38:44,800 --> 00:38:49,200
is basically the core type and the twig.

933
00:38:49,200 --> 00:38:51,040
And so when we actually evaluate that,

934
00:38:51,040 --> 00:38:53,800
we have to basically manually work through the laziness

935
00:38:53,800 --> 00:38:55,840
and say, oh, well, what's in that type?

936
00:38:55,840 --> 00:38:58,840
Gee, I don't know, let me calculate it and find out.

937
00:38:58,840 --> 00:39:00,980
That actually, that works rather well.

938
00:39:01,900 --> 00:39:06,800
Let me, okay, here's some advanced theory.

939
00:39:06,800 --> 00:39:08,460
I'm gonna go over this super quickly.

940
00:39:08,460 --> 00:39:10,380
So hold again is manual laziness.

941
00:39:10,380 --> 00:39:12,380
One of the nice things about it is that basically,

942
00:39:12,380 --> 00:39:14,660
you can build a conservative work list algorithm.

943
00:39:14,660 --> 00:39:15,920
Let's say you're building a linked list.

944
00:39:15,920 --> 00:39:18,820
Let's say you wanna do a type comparison on two linked lists.

945
00:39:18,820 --> 00:39:20,620
Okay, now this is a basically,

946
00:39:21,540 --> 00:39:23,060
this is a structural comparison.

947
00:39:23,060 --> 00:39:25,960
So you're saying, these could be totally different definitions

948
00:39:25,960 --> 00:39:27,100
of linked list.

949
00:39:27,100 --> 00:39:28,380
Do they match?

950
00:39:28,380 --> 00:39:33,380
So if you basically traverse this span,

951
00:39:34,340 --> 00:39:37,380
what you're gonna see is that that traverse repeats itself.

952
00:39:37,380 --> 00:39:39,620
And because it repeats itself, you can say,

953
00:39:39,620 --> 00:39:42,660
oh, gee, I already checked that there were no violations

954
00:39:42,660 --> 00:39:46,940
on this arm, on this branch, so I'm gonna call that fine.

955
00:39:46,940 --> 00:39:50,180
And that's basically how you can do sort of type logic

956
00:39:50,180 --> 00:39:52,280
in this manually evaluated space.

957
00:39:52,280 --> 00:39:54,940
Again, very, very stupid if you ask,

958
00:39:54,940 --> 00:39:57,580
any smart undergraduate could come up with this scheme.

959
00:39:58,940 --> 00:40:00,780
A little more, at a little more depth,

960
00:40:00,780 --> 00:40:02,020
I'm gonna go over this super quickly.

961
00:40:02,020 --> 00:40:03,700
You may not understand it.

962
00:40:03,700 --> 00:40:07,060
Basically, in polymorphism, you have two,

963
00:40:08,300 --> 00:40:10,140
a lot of different kinds of languages.

964
00:40:10,140 --> 00:40:11,300
And I'm thinking of like Eiffel

965
00:40:11,300 --> 00:40:13,620
and like the Bertrand Meyer kind of world of languages

966
00:40:13,620 --> 00:40:15,980
have basically two kinds of polymorphism.

967
00:40:15,980 --> 00:40:17,740
You have variance and you have generosity.

968
00:40:17,740 --> 00:40:21,180
So basically, any polymorphism in any system like this

969
00:40:21,180 --> 00:40:23,620
is about basically, if I change a core,

970
00:40:23,620 --> 00:40:25,220
let's say, okay, I built this core,

971
00:40:25,220 --> 00:40:28,020
I stuck this battery on this payload.

972
00:40:28,020 --> 00:40:29,380
But now I changed the payload.

973
00:40:29,380 --> 00:40:30,460
Maybe I changed the payload

974
00:40:30,460 --> 00:40:31,820
to something of a different type.

975
00:40:31,820 --> 00:40:33,380
Can I run this core?

976
00:40:33,380 --> 00:40:35,420
So basically, can I run this arm

977
00:40:35,420 --> 00:40:37,660
or will it just be a total disaster?

978
00:40:37,660 --> 00:40:39,340
And that question is actually answered

979
00:40:39,340 --> 00:40:40,820
when you try to run the arm.

980
00:40:40,820 --> 00:40:45,580
So there's sort of simple question of variance, basically.

981
00:40:45,580 --> 00:40:47,980
Can I use this one payload as another payload?

982
00:40:49,060 --> 00:40:51,700
The way we do generosity is,

983
00:40:51,700 --> 00:40:54,060
I can sort of explain this intuitively

984
00:40:54,060 --> 00:40:55,540
at a very high level.

985
00:40:55,540 --> 00:40:56,620
When you're doing generosity,

986
00:40:56,620 --> 00:40:58,540
you're basically saying,

987
00:40:58,540 --> 00:40:59,380
when you're doing variance,

988
00:40:59,380 --> 00:41:01,220
you're basically saying, okay,

989
00:41:01,220 --> 00:41:04,500
does my mutated payload work like the original payload?

990
00:41:04,500 --> 00:41:05,540
When you're doing generosity,

991
00:41:05,540 --> 00:41:06,940
what you're saying is you're saying,

992
00:41:06,940 --> 00:41:09,220
okay, I've changed the type of this payload.

993
00:41:09,220 --> 00:41:10,940
I've changed something totally different.

994
00:41:10,940 --> 00:41:12,620
Now I'm gonna run this arm on it.

995
00:41:12,620 --> 00:41:13,900
I'm not gonna recompile this arm.

996
00:41:13,900 --> 00:41:16,180
I'm gonna run the original knock formula

997
00:41:16,180 --> 00:41:17,020
that was calculated

998
00:41:17,020 --> 00:41:19,540
for something of a totally different type.

999
00:41:19,540 --> 00:41:21,180
And the question you have to answer is,

1000
00:41:21,180 --> 00:41:22,420
is that gonna work?

1001
00:41:22,420 --> 00:41:24,180
And what span is it gonna produce?

1002
00:41:25,180 --> 00:41:28,100
And you're basically treating the twig,

1003
00:41:28,100 --> 00:41:29,980
you're treating the arm as a macro,

1004
00:41:29,980 --> 00:41:32,860
and essentially working through it.

1005
00:41:32,860 --> 00:41:34,420
So it's like the classic example,

1006
00:41:34,420 --> 00:41:35,660
can you build a function

1007
00:41:35,660 --> 00:41:38,260
to swap two things of an arbitrary type?

1008
00:41:38,260 --> 00:41:43,260
So yeah, you basically do that with generosity in Hoon.

1009
00:41:44,620 --> 00:41:46,940
So that works, that's how we do containers,

1010
00:41:46,940 --> 00:41:48,780
all the usual jazz.

1011
00:41:48,780 --> 00:41:52,020
And it's essentially kind of this ghetto,

1012
00:41:52,140 --> 00:41:53,940
low rent way of doing type classes.

1013
00:41:55,140 --> 00:41:57,180
Syntax design, let's go into the syntax.

1014
00:41:57,180 --> 00:42:00,540
Hoon has a very unusual syntax you've seen already.

1015
00:42:00,540 --> 00:42:02,740
A lot of people think it looks pretty gnarly.

1016
00:42:03,660 --> 00:42:05,780
There is a reason for doing this gnarly thing.

1017
00:42:05,780 --> 00:42:08,340
The reason is that basically there are kind of three problems

1018
00:42:08,340 --> 00:42:10,860
that you see in a lot of functional languages

1019
00:42:10,860 --> 00:42:13,140
that are syntactic problems.

1020
00:42:13,140 --> 00:42:14,860
One problem is that basically expression

1021
00:42:14,860 --> 00:42:16,220
is sloped downward into the right,

1022
00:42:16,220 --> 00:42:18,100
and so they keep attacking your right margin

1023
00:42:18,100 --> 00:42:19,580
if they get too complicated.

1024
00:42:19,580 --> 00:42:20,620
In a procedural language,

1025
00:42:20,620 --> 00:42:22,620
you've got this nice division between statements

1026
00:42:22,620 --> 00:42:24,260
and expressions, and statements flow down,

1027
00:42:24,260 --> 00:42:25,900
and expressions flow across,

1028
00:42:25,900 --> 00:42:28,140
and it gives you this kind of nice tree-shaped structure

1029
00:42:28,140 --> 00:42:31,100
which lets you work within an 80-column margin.

1030
00:42:32,060 --> 00:42:34,060
In a functional language, you often don't have that,

1031
00:42:34,060 --> 00:42:36,660
so you get this slanty thing,

1032
00:42:36,660 --> 00:42:39,060
which is uncomfortable to work with.

1033
00:42:39,060 --> 00:42:42,140
Another problem in syntax that a lot of these languages have

1034
00:42:42,140 --> 00:42:44,180
is they have this unpleasant choice between,

1035
00:42:44,180 --> 00:42:46,700
am I gonna have 17 parentheses in a row,

1036
00:42:46,700 --> 00:42:49,140
or am I gonna do significant white space?

1037
00:42:49,140 --> 00:42:51,420
Both of those have, they work, they work,

1038
00:42:51,420 --> 00:42:54,220
they just have, they're just not super pretty.

1039
00:42:54,220 --> 00:42:56,060
Another problem that I don't know if everyone has

1040
00:42:56,060 --> 00:42:57,420
this problem, I certainly have this problem

1041
00:42:57,420 --> 00:43:00,580
when I look at LISPs and a lot of similar things,

1042
00:43:00,580 --> 00:43:03,700
is basically I can't distinguish special forms from symbols.

1043
00:43:03,700 --> 00:43:05,860
I can't distinguish, is this part of the language,

1044
00:43:05,860 --> 00:43:07,980
or is this something that somebody included

1045
00:43:07,980 --> 00:43:10,940
from the library, or is it a macro?

1046
00:43:10,940 --> 00:43:13,340
And basically making that, again,

1047
00:43:13,340 --> 00:43:16,380
getting away from this sort of pervasive DSLization

1048
00:43:17,380 --> 00:43:21,100
is definitely a goal of the system.

1049
00:43:22,540 --> 00:43:25,460
Speeding up a little, so let me,

1050
00:43:25,460 --> 00:43:28,260
before showing the syntax, basically a twig structure.

1051
00:43:28,260 --> 00:43:32,060
Once again, the twig is a hoon AST.

1052
00:43:33,500 --> 00:43:38,500
You can do, hoon has the same kind of auto cons feature

1053
00:43:39,460 --> 00:43:42,940
that knock does, so basically cons is assumed.

1054
00:43:42,940 --> 00:43:45,540
If you basically make a cell of two hoon twigs,

1055
00:43:45,540 --> 00:43:47,220
that's a cons.

1056
00:43:47,220 --> 00:43:48,660
In general, as opposed to LISP,

1057
00:43:48,660 --> 00:43:51,740
hoon is kind of more pair-oriented and more tuple-oriented.

1058
00:43:51,740 --> 00:43:54,900
We don't throw in terminators everywhere willy-nilly.

1059
00:43:54,900 --> 00:43:57,740
That's kind of more appropriate for a typed system, I think.

1060
00:43:58,820 --> 00:44:02,380
Most twigs are tagged unions, so they have a head,

1061
00:44:02,380 --> 00:44:05,300
which is a stem, which is a symbol, and a bulb,

1062
00:44:05,300 --> 00:44:10,300
which is the tail, which is totally dependent on the stem.

1063
00:44:10,860 --> 00:44:15,700
It's usually a tuple or a list of twigs,

1064
00:44:15,700 --> 00:44:18,740
and let's see how that works in practice.

1065
00:44:18,740 --> 00:44:20,460
Basically, there's a regular form.

1066
00:44:20,460 --> 00:44:23,340
Again, most bulbs are tuples.

1067
00:44:23,340 --> 00:44:26,460
Some are in-area, and there we do need a terminator.

1068
00:44:26,460 --> 00:44:27,740
But what we do is we separate,

1069
00:44:27,740 --> 00:44:30,460
we basically have two regular forms of syntax.

1070
00:44:30,460 --> 00:44:32,580
One, which sort of looks like an expression,

1071
00:44:32,580 --> 00:44:35,220
and one which looks like a statement.

1072
00:44:35,220 --> 00:44:37,820
Those two ifs there are the same code,

1073
00:44:38,700 --> 00:44:40,740
but they look a little different.

1074
00:44:40,740 --> 00:44:43,460
What you do is you basically build a structure

1075
00:44:43,460 --> 00:44:46,620
whose backbone is basically tall twigs,

1076
00:44:46,620 --> 00:44:49,700
and then a tall twig can contain a flat one,

1077
00:44:49,700 --> 00:44:50,900
but not vice versa.

1078
00:44:50,900 --> 00:44:53,660
Basically, you're mimicking the kind of structure

1079
00:44:53,660 --> 00:44:55,940
of imperative code that has this kind of statement

1080
00:44:55,940 --> 00:44:58,460
expression duality, but it's all an expression.

1081
00:44:58,460 --> 00:45:00,380
There's no imperative anything.

1082
00:45:01,860 --> 00:45:03,340
Another thing that you're doing basically

1083
00:45:03,340 --> 00:45:05,100
to control the right margin here,

1084
00:45:05,100 --> 00:45:07,540
what you really want, you'll notice that C

1085
00:45:07,540 --> 00:45:10,020
is at the same indentation as the if there.

1086
00:45:10,020 --> 00:45:13,380
So basically, you want to lose no space,

1087
00:45:13,380 --> 00:45:15,660
basically for your largest,

1088
00:45:15,660 --> 00:45:17,780
hopefully C is the biggest branch,

1089
00:45:17,780 --> 00:45:19,020
C is not the biggest branch,

1090
00:45:19,020 --> 00:45:21,380
you want unless instead of if.

1091
00:45:21,380 --> 00:45:24,300
But basically, you really, as a programmer,

1092
00:45:24,300 --> 00:45:26,940
there's sort of an art of arranging these things,

1093
00:45:26,940 --> 00:45:30,820
and you arrange them so that they flow down and not across.

1094
00:45:30,820 --> 00:45:33,780
And it becomes very easy to read once you know it,

1095
00:45:33,780 --> 00:45:34,820
like any language.

1096
00:45:35,700 --> 00:45:39,020
And here's the funnest and most fancy part

1097
00:45:39,020 --> 00:45:40,580
of our crazy syntax.

1098
00:45:40,580 --> 00:45:42,900
So first of all, you've got regular forms

1099
00:45:42,900 --> 00:45:43,740
and irregular forms.

1100
00:45:43,740 --> 00:45:46,860
So in a regular form, arbitrary syntax,

1101
00:45:46,860 --> 00:45:48,860
at least it's always flat,

1102
00:45:48,860 --> 00:45:51,100
but that's just something you have to learn.

1103
00:45:51,100 --> 00:45:54,180
One of the things I feel, if you look at the implementation

1104
00:45:54,180 --> 00:45:57,900
of the Hoon compiler, what you'll see is that basically,

1105
00:45:57,900 --> 00:46:00,180
the front end is actually as big as the back end,

1106
00:46:00,180 --> 00:46:01,740
which is really quite unusual.

1107
00:46:02,580 --> 00:46:05,540
And that's because basically, as a human being,

1108
00:46:05,540 --> 00:46:08,860
you've got this great hardware for basically parsing.

1109
00:46:08,860 --> 00:46:11,100
You don't have hardware for type inference.

1110
00:46:11,100 --> 00:46:16,100
And so what we've done is basically the keyword form

1111
00:46:18,220 --> 00:46:20,340
that you saw, I remember you saw those two forms

1112
00:46:20,340 --> 00:46:23,820
of Hoon, one using keywords and one using runes.

1113
00:46:23,820 --> 00:46:25,780
I'm gonna step forward and show you.

1114
00:46:25,780 --> 00:46:28,060
Here are two forms of fizzbuzz.

1115
00:46:28,060 --> 00:46:29,900
On the right you see runes.

1116
00:46:29,900 --> 00:46:31,580
On the left you see keywords.

1117
00:46:32,300 --> 00:46:33,580
Stepping back for a second,

1118
00:46:33,580 --> 00:46:36,100
to make these basically pronounceable,

1119
00:46:36,100 --> 00:46:39,100
what we've done is taken every ASCII character

1120
00:46:39,100 --> 00:46:42,780
and given it a single syllable name.

1121
00:46:42,780 --> 00:46:46,540
So where, if you see like if here,

1122
00:46:46,540 --> 00:46:49,600
so if is the colon prefixed f there.

1123
00:46:49,600 --> 00:46:51,460
That's also the symbol that's actually

1124
00:46:51,460 --> 00:46:53,860
in the physical twig.

1125
00:46:53,860 --> 00:46:57,260
You can also, as a syntax, you can say question colon.

1126
00:46:57,260 --> 00:47:00,660
I wouldn't say question colon though, I would say what?

1127
00:47:00,700 --> 00:47:02,620
Which is a lot faster than the same question colon,

1128
00:47:02,620 --> 00:47:04,260
not to mention ampersand.

1129
00:47:06,300 --> 00:47:10,020
So basically everyone who's learned this is like,

1130
00:47:10,020 --> 00:47:11,020
why doesn't everyone know this

1131
00:47:11,020 --> 00:47:13,380
and why do I have to say till like my normal friends

1132
00:47:13,380 --> 00:47:14,420
when I could say sick?

1133
00:47:15,340 --> 00:47:17,660
So hopefully it'll catch on,

1134
00:47:17,660 --> 00:47:20,260
if it doesn't catch on at least it's useful in Hoon.

1135
00:47:20,260 --> 00:47:24,340
So if we go back to this and we look at the right,

1136
00:47:24,340 --> 00:47:28,180
you would say gate infest atom or you would say

1137
00:47:28,180 --> 00:47:30,660
park his infest atom for the start of that.

1138
00:47:31,860 --> 00:47:34,900
Let me give you 20 seconds to just observe

1139
00:47:34,900 --> 00:47:36,260
the fizz buzzes here.

1140
00:47:36,260 --> 00:47:37,660
I think that the one on the left

1141
00:47:37,660 --> 00:47:39,940
should be at least pretty readable.

1142
00:47:48,460 --> 00:47:50,140
Okay, so that's Hoon.

1143
00:47:50,140 --> 00:47:52,580
Let's move up on up to Arvo.

1144
00:47:52,580 --> 00:47:54,500
Now we're at the operating system level.

1145
00:47:55,980 --> 00:47:58,100
The kernel of Arvo is a Hoon core

1146
00:47:59,020 --> 00:48:00,580
and this is basically where we get back

1147
00:48:00,580 --> 00:48:01,860
to our transition function.

1148
00:48:01,860 --> 00:48:06,860
So this core basically has a very fixed battery structure.

1149
00:48:07,100 --> 00:48:09,500
You can think of it as basically like a V table

1150
00:48:09,500 --> 00:48:12,820
with a fixed structure.

1151
00:48:12,820 --> 00:48:15,900
And the Unix interpreter talks to this core

1152
00:48:15,900 --> 00:48:17,860
basically at the knock level.

1153
00:48:17,860 --> 00:48:20,100
In the life cycle function it's defined at the knock level.

1154
00:48:20,100 --> 00:48:24,220
So you basically just hard code those formula offsets.

1155
00:48:25,300 --> 00:48:27,580
You can just fix that

1156
00:48:27,580 --> 00:48:29,820
because you have only a few functions there.

1157
00:48:29,820 --> 00:48:32,060
So basically this is how you have a system

1158
00:48:32,060 --> 00:48:33,740
that can completely upgrade itself

1159
00:48:33,740 --> 00:48:36,340
because again the whole life cycle function

1160
00:48:36,340 --> 00:48:38,580
is defined entirely in knock.

1161
00:48:39,540 --> 00:48:42,300
And basically let's say you get an event

1162
00:48:42,300 --> 00:48:46,220
and that event is actually a source code update

1163
00:48:46,220 --> 00:48:47,980
in the revision control system

1164
00:48:47,980 --> 00:48:49,300
that gives you new source code

1165
00:48:49,300 --> 00:48:52,100
for Hoon the language itself.

1166
00:48:52,100 --> 00:48:54,580
As long as your new language can build a core

1167
00:48:54,580 --> 00:48:57,100
that is shaped like the ones that your old language built,

1168
00:48:57,100 --> 00:48:58,620
you can turn Hoon into anything.

1169
00:49:00,820 --> 00:49:03,180
So ARBO is actually a very, very simple system.

1170
00:49:03,180 --> 00:49:04,820
It's only a few hundred lines of code.

1171
00:49:04,820 --> 00:49:07,780
It probably should be less than 600 actually.

1172
00:49:07,780 --> 00:49:11,460
What it does is it does sort of an internal event cascade.

1173
00:49:11,460 --> 00:49:13,780
So you're all familiar with you know,

1174
00:49:13,780 --> 00:49:15,280
like you get an event from the outside

1175
00:49:15,280 --> 00:49:18,180
and then you're like this happened internally.

1176
00:49:18,180 --> 00:49:22,300
Events systems that are very complicated

1177
00:49:22,300 --> 00:49:24,220
and deep like this one very quickly

1178
00:49:24,220 --> 00:49:26,780
turn into spaghetti event logic.

1179
00:49:26,780 --> 00:49:30,060
There's a duality between events and procedure calls

1180
00:49:31,060 --> 00:49:36,060
in which basically an event is a transfer of control

1181
00:49:36,100 --> 00:49:38,940
essentially and if you take that duality simply,

1182
00:49:38,940 --> 00:49:41,880
the dual of a simple event system is go to.

1183
00:49:42,780 --> 00:49:45,020
So basically when you have, you're like,

1184
00:49:45,020 --> 00:49:46,620
oh through these events and then it's like

1185
00:49:46,620 --> 00:49:48,380
the system will go here and it will go there

1186
00:49:48,380 --> 00:49:51,420
and it was like why are you doing this?

1187
00:49:51,420 --> 00:49:53,980
So essentially we have what you might call

1188
00:49:53,980 --> 00:49:56,820
the equivalent of a go sub for anyone

1189
00:49:56,820 --> 00:49:59,060
no basic in this room, anyone?

1190
00:49:59,060 --> 00:50:00,220
Wow, that's awesome.

1191
00:50:01,780 --> 00:50:03,100
I don't feel so old now.

1192
00:50:05,580 --> 00:50:09,800
So you have essentially the equivalent of subroutines

1193
00:50:09,800 --> 00:50:12,940
in an event kind of model and you have basically

1194
00:50:12,940 --> 00:50:15,580
this kind of causal model which I don't wanna get super into

1195
00:50:15,580 --> 00:50:17,100
but definitely if you're building

1196
00:50:17,100 --> 00:50:18,580
JavaScript event frameworks I think

1197
00:50:18,580 --> 00:50:20,180
you could use something like this.

1198
00:50:20,180 --> 00:50:21,920
It also has a global type referentially

1199
00:50:21,960 --> 00:50:26,160
transparent namespace so basically use any data

1200
00:50:26,160 --> 00:50:28,400
in the world as if it was a type constant.

1201
00:50:28,400 --> 00:50:30,040
That's kind of nice.

1202
00:50:30,040 --> 00:50:34,000
Most of the work of ARVO is done by what are called

1203
00:50:34,000 --> 00:50:36,040
veins which are essentially kernel modules

1204
00:50:36,040 --> 00:50:38,360
and they have essentially the same kind of core-like

1205
00:50:38,360 --> 00:50:40,880
structure as the ARVO core itself.

1206
00:50:40,880 --> 00:50:44,120
So these are loaded from source obviously at runtime.

1207
00:50:44,120 --> 00:50:47,400
Let me just run through a few of the things we do.

1208
00:50:47,400 --> 00:50:49,280
So encrypted packing networking,

1209
00:50:49,280 --> 00:50:50,360
we'll talk about that in a sec.

1210
00:50:50,360 --> 00:50:53,920
Timer is obviously clay which is like a typed git.

1211
00:50:55,000 --> 00:50:56,800
Console obviously air.

1212
00:50:56,800 --> 00:50:59,800
We'll see that hopefully driving a demo in a second.

1213
00:50:59,800 --> 00:51:01,640
A function build system and I don't really know

1214
00:51:01,640 --> 00:51:04,520
how to describe that and an application engine.

1215
00:51:04,520 --> 00:51:07,520
And the applications again are cores within Gaul.

1216
00:51:07,520 --> 00:51:09,440
So you have sort of these kind of multiple levels

1217
00:51:09,440 --> 00:51:10,720
of virtualization.

1218
00:51:10,720 --> 00:51:12,200
When you're running user level code

1219
00:51:12,200 --> 00:51:14,520
you're actually running it in a virtual knock.

1220
00:51:14,520 --> 00:51:17,640
And that virtual knock has an extra instruction.

1221
00:51:17,640 --> 00:51:20,120
It has an instruction 11 that de-references

1222
00:51:20,120 --> 00:51:22,080
the basically global namespace.

1223
00:51:22,080 --> 00:51:24,520
So you're really like de-referencing the whole world

1224
00:51:24,520 --> 00:51:25,680
as if it was a constant.

1225
00:51:27,120 --> 00:51:30,760
Again that due to the way knock works

1226
00:51:30,760 --> 00:51:33,040
you can basically virtualize at any depth

1227
00:51:33,040 --> 00:51:35,600
of virtual interpreters without any real cost.

1228
00:51:35,600 --> 00:51:37,120
Cause you're actually in implementation

1229
00:51:37,120 --> 00:51:38,120
just setting a flag.

1230
00:51:39,760 --> 00:51:42,840
All right that's a very, very broad overview of ARVO.

1231
00:51:42,840 --> 00:51:45,240
Let's go back to the top and basically look

1232
00:51:45,240 --> 00:51:48,600
at what Erbit is doing at the top level.

1233
00:51:48,600 --> 00:51:51,760
So we're sort of back to the user level here.

1234
00:51:51,760 --> 00:51:53,680
There's fortunately nothing else in the stack

1235
00:51:53,680 --> 00:51:57,520
besides NACUN and ARVO and at the top level

1236
00:51:57,520 --> 00:51:59,680
what users really see the most in Erbit

1237
00:51:59,680 --> 00:52:01,360
is the public key infrastructure

1238
00:52:01,360 --> 00:52:03,200
of kind of the identity model.

1239
00:52:03,200 --> 00:52:06,800
Basically one Erbit is one event history.

1240
00:52:06,800 --> 00:52:08,360
It's one state, it's one instance

1241
00:52:08,360 --> 00:52:09,880
and it has one identity.

1242
00:52:10,960 --> 00:52:13,160
And you know we basically establish that identity

1243
00:52:13,160 --> 00:52:16,640
when we're booting the Erbit.

1244
00:52:16,640 --> 00:52:18,000
What exactly is this identity?

1245
00:52:18,040 --> 00:52:18,880
What does it mean?

1246
00:52:20,240 --> 00:52:23,200
So basically again the kind of the great thing

1247
00:52:23,200 --> 00:52:24,680
about doing things from a clean slate

1248
00:52:24,680 --> 00:52:26,600
is you really get to think from scratch

1249
00:52:26,600 --> 00:52:28,480
which is kind of neat.

1250
00:52:28,480 --> 00:52:30,080
And one thing about networking

1251
00:52:30,080 --> 00:52:31,880
that is done kind of in a conventional

1252
00:52:31,880 --> 00:52:34,320
in the internet certainly is you have these two levels

1253
00:52:34,320 --> 00:52:37,240
of well that could spit our audio.

1254
00:52:38,760 --> 00:52:42,200
You have these two levels of addressing.

1255
00:52:42,200 --> 00:52:44,160
So you have IP addressings and you have DNS.

1256
00:52:44,160 --> 00:52:45,920
And the DNS is human meaningful

1257
00:52:45,920 --> 00:52:48,120
and IP addresses are routable addresses.

1258
00:52:48,120 --> 00:52:50,800
So in Erbit this is compressed into one layer.

1259
00:52:50,800 --> 00:52:52,240
So you actually have one layer

1260
00:52:52,240 --> 00:52:55,480
which is both a human memorable layer

1261
00:52:55,480 --> 00:52:58,760
and it's both a routing address and a name.

1262
00:52:58,760 --> 00:53:01,920
And it's actually your personal identity as well.

1263
00:53:01,920 --> 00:53:04,080
It's also the base of a path

1264
00:53:04,080 --> 00:53:06,040
in the global immutable namespace.

1265
00:53:06,040 --> 00:53:07,840
So there's a problem called Zikos Triangle.

1266
00:53:07,840 --> 00:53:10,240
Does anyone in the room know Zikos Triangle?

1267
00:53:11,400 --> 00:53:14,280
We're definitely not in network land here.

1268
00:53:14,280 --> 00:53:15,480
That's fine.

1269
00:53:15,520 --> 00:53:17,760
Zikos Triangle basically says there are three things

1270
00:53:17,760 --> 00:53:20,400
that you want out of an identity system.

1271
00:53:20,400 --> 00:53:24,760
You want the names to be human meaningful.

1272
00:53:24,760 --> 00:53:26,080
You want them to be secure

1273
00:53:26,080 --> 00:53:28,200
and you want them to be decentralized.

1274
00:53:28,200 --> 00:53:30,640
And you can get only two of those three things.

1275
00:53:30,640 --> 00:53:33,400
So Facebook, Secure, I hope,

1276
00:53:33,400 --> 00:53:36,800
human meaningful names definitely decentralized,

1277
00:53:36,800 --> 00:53:37,640
not at all.

1278
00:53:39,480 --> 00:53:44,320
BitTorrent, decentralized, yes, human meaningful names, no.

1279
00:53:45,240 --> 00:53:48,000
And so there's basically a problem there

1280
00:53:48,000 --> 00:53:51,560
that as an OS guy, what they teach us to do

1281
00:53:51,560 --> 00:53:54,400
is find the trade off and almost solve the problem.

1282
00:53:54,400 --> 00:53:57,480
So the trade off that we make here is basically,

1283
00:53:57,480 --> 00:54:00,840
the trivial solution for an identity system of this scale

1284
00:54:00,840 --> 00:54:03,000
is basically to say your identity

1285
00:54:03,000 --> 00:54:05,240
is the hash of your initial public key.

1286
00:54:05,240 --> 00:54:08,000
Very easy, IPFS uses this, very easy to do.

1287
00:54:09,520 --> 00:54:11,600
How do you remember a 128-bit hash?

1288
00:54:12,720 --> 00:54:13,560
You don't.

1289
00:54:14,600 --> 00:54:17,040
And so what we're looking for is basically a way

1290
00:54:17,040 --> 00:54:19,720
to make these names that are memorable,

1291
00:54:19,720 --> 00:54:20,560
but not meaningful.

1292
00:54:20,560 --> 00:54:24,920
So first trick we do is we basically come up

1293
00:54:24,920 --> 00:54:27,200
with a new way of representing numbers.

1294
00:54:27,200 --> 00:54:28,760
Many things like this have been done before,

1295
00:54:28,760 --> 00:54:32,320
not super original, but we do a phonemic base 256.

1296
00:54:32,320 --> 00:54:34,280
So if you look at my three numbers there,

1297
00:54:34,280 --> 00:54:36,600
there's a hexadecimal number in urban syntax,

1298
00:54:36,600 --> 00:54:39,600
there's an in-hune syntax, there's an IP address.

1299
00:54:39,600 --> 00:54:41,160
We also have a syntax for that.

1300
00:54:41,160 --> 00:54:45,160
And then there's 128, 42, 19, 109,

1301
00:54:45,160 --> 00:54:46,520
versus patent of tarlott.

1302
00:54:46,520 --> 00:54:48,760
Patent of tarlott is a lot easier to remember.

1303
00:54:48,760 --> 00:54:52,160
It's kind of like a human name in a foreign language.

1304
00:54:52,160 --> 00:54:53,840
People actually bond with these names

1305
00:54:53,840 --> 00:54:55,520
very easily and very quickly.

1306
00:54:55,520 --> 00:54:57,640
I'm a task-fine part of it, I think of myself.

1307
00:54:57,640 --> 00:54:59,440
People say task-fine, I turn around.

1308
00:55:00,760 --> 00:55:05,320
And so of course that's a 32-bit number,

1309
00:55:05,320 --> 00:55:07,800
which is a lot shorter than a 128-bit number.

1310
00:55:07,800 --> 00:55:11,120
So how you get from 128 bits to 32

1311
00:55:11,120 --> 00:55:12,000
is tricky.

1312
00:55:12,000 --> 00:55:14,320
So you can actually do the 128-bit hash

1313
00:55:14,320 --> 00:55:16,040
of a public key thing, that's called a comment.

1314
00:55:16,040 --> 00:55:18,320
Anyone can create their own urban identity.

1315
00:55:18,320 --> 00:55:21,760
That is a completely non-scarce resource.

1316
00:55:22,760 --> 00:55:26,120
And it's also, there's just no way

1317
00:55:26,120 --> 00:55:29,040
of making a 128-bit number memorable.

1318
00:55:29,040 --> 00:55:30,360
So what you notice is that basically

1319
00:55:30,360 --> 00:55:32,160
the most valuable real estate in this

1320
00:55:32,160 --> 00:55:35,280
is down at the bottom of this whole 128-bit space.

1321
00:55:35,280 --> 00:55:38,840
And in fact, you can overlay a 128-bit hash

1322
00:55:38,840 --> 00:55:40,720
will never be a 64-bit number.

1323
00:55:40,720 --> 00:55:42,560
So you can overlay a completely different

1324
00:55:42,560 --> 00:55:45,840
64-bit identity scheme on the bottom of this.

1325
00:55:45,840 --> 00:55:49,800
So your 64-bit scheme is distributed hierarchically.

1326
00:55:49,800 --> 00:55:52,400
It's basically, it's cryptographic property

1327
00:55:52,400 --> 00:55:55,000
a little bit like Bitcoin, but it doesn't use a blockchain.

1328
00:55:55,000 --> 00:55:58,360
So the way it works is that a 64-bit chip

1329
00:55:58,360 --> 00:56:01,600
is the initial key is signed by its 32-bit parent,

1330
00:56:01,600 --> 00:56:04,080
basically the half width prefix.

1331
00:56:04,080 --> 00:56:08,040
The 32-bit chip is signed by a 16-bit parent.

1332
00:56:08,040 --> 00:56:10,200
The 16-bit chip, which is a star,

1333
00:56:10,200 --> 00:56:11,840
is signed by its 8-bit parent.

1334
00:56:11,840 --> 00:56:15,160
And the fingerprints of 8-bit galaxies

1335
00:56:15,160 --> 00:56:18,040
are hard-coded in the kernel source.

1336
00:56:18,040 --> 00:56:21,280
This is what we call a pre-mind in the Bitcoin world.

1337
00:56:24,680 --> 00:56:28,880
So basically again, this is a PKI

1338
00:56:28,880 --> 00:56:32,760
in which revocation and renewal are the same thing.

1339
00:56:32,760 --> 00:56:34,720
So basically when you wanna change a key,

1340
00:56:34,720 --> 00:56:37,320
whether that's because you wanna give someone else

1341
00:56:37,320 --> 00:56:40,320
this identity or you just feel like your key

1342
00:56:40,320 --> 00:56:41,560
might be a little bit compromised,

1343
00:56:41,560 --> 00:56:44,120
you basically sign the new key with the old key.

1344
00:56:44,120 --> 00:56:45,120
Unless you're a moon,

1345
00:56:45,120 --> 00:56:47,400
moon should not be floating around unaccompanied.

1346
00:56:47,400 --> 00:56:48,640
You sign your own updates.

1347
00:56:48,640 --> 00:56:52,160
So basically your parent signs the first key,

1348
00:56:52,160 --> 00:56:53,080
but you sign the second.

1349
00:56:53,080 --> 00:56:55,720
So you're genuinely independent here.

1350
00:56:55,720 --> 00:56:58,840
The main sort of question in that is basically

1351
00:56:58,840 --> 00:57:01,480
how these updates get distributed.

1352
00:57:01,480 --> 00:57:03,480
Fortunately, there's a lot fewer of them

1353
00:57:03,480 --> 00:57:06,600
than sort of the equivalent, which is like a Bitcoin spend.

1354
00:57:06,680 --> 00:57:09,480
So there's a lot more room for basically

1355
00:57:09,480 --> 00:57:13,360
just sort of handling it in a kind of less aggressive way

1356
00:57:13,360 --> 00:57:15,000
than Bitcoin does.

1357
00:57:15,000 --> 00:57:16,360
But it's the same basic principle.

1358
00:57:16,360 --> 00:57:18,880
Your identity is definitely cryptographic property.

1359
00:57:18,880 --> 00:57:21,320
You own it, you can sell it, et cetera.

1360
00:57:21,320 --> 00:57:24,400
And there's the 32-bit point

1361
00:57:24,400 --> 00:57:27,000
is clearly kind of the right point for human beings.

1362
00:57:27,000 --> 00:57:29,400
One of the things about having these 32-bit names

1363
00:57:29,400 --> 00:57:32,840
as your names is basically like in any situation

1364
00:57:32,840 --> 00:57:34,880
in which people are actually using this system,

1365
00:57:34,880 --> 00:57:35,720
some people are using it,

1366
00:57:35,720 --> 00:57:38,320
but hopefully everyone will be using it.

1367
00:57:38,320 --> 00:57:39,480
You have a scarcity there.

1368
00:57:39,480 --> 00:57:40,640
You only have four billion.

1369
00:57:40,640 --> 00:57:44,280
And so the price of the scarce resource cannot fault a zero.

1370
00:57:44,280 --> 00:57:48,000
So one of the things about that situation

1371
00:57:48,000 --> 00:57:50,040
is that the basic problem,

1372
00:57:50,040 --> 00:57:51,560
one of the reasons why my mother

1373
00:57:51,560 --> 00:57:53,080
can't run her own internet server

1374
00:57:53,080 --> 00:57:55,680
is that the internet is basically, you know,

1375
00:57:55,680 --> 00:57:56,880
a digital mazizly.

1376
00:57:56,880 --> 00:57:59,620
I mean, it's just all kinds of scum and villainy are out there.

1377
00:57:59,620 --> 00:58:01,960
And when you get a packet from someone,

1378
00:58:01,960 --> 00:58:04,880
you have no way of ascertaining the reputation

1379
00:58:04,880 --> 00:58:07,080
of this IP address.

1380
00:58:07,080 --> 00:58:09,960
Yes, there are IP address reputation systems in practice.

1381
00:58:09,960 --> 00:58:12,040
They basically turn off all residential things

1382
00:58:12,040 --> 00:58:14,180
and don't let them send email.

1383
00:58:14,180 --> 00:58:16,800
But the ownership of an IP address is not clear.

1384
00:58:16,800 --> 00:58:19,920
And so you can't really use, an IP address is not property.

1385
00:58:19,920 --> 00:58:23,180
You can't really use it as a mechanism in this way.

1386
00:58:23,180 --> 00:58:24,880
When you basically have an address

1387
00:58:24,880 --> 00:58:25,880
that's a scarce resource,

1388
00:58:25,880 --> 00:58:28,480
let's say you paid 10 bucks for your planet.

1389
00:58:28,480 --> 00:58:31,160
Okay, I paid 10 bucks so I wanna be able to compute.

1390
00:58:32,160 --> 00:58:33,680
Then you're gonna send messages

1391
00:58:33,680 --> 00:58:34,760
directly from that planet.

1392
00:58:34,760 --> 00:58:36,200
You're definitely not gonna send them through

1393
00:58:36,200 --> 00:58:38,640
like Google or some MTU, like, you know.

1394
00:58:39,640 --> 00:58:42,920
And if you spam, like someone's like,

1395
00:58:42,920 --> 00:58:46,120
hey, I got a spam from Taskline Partive.

1396
00:58:46,120 --> 00:58:47,880
And you go on a blacklist like this.

1397
00:58:47,880 --> 00:58:50,560
And basically your 10 bucks is now worthless

1398
00:58:50,560 --> 00:58:52,600
because no one will accept anything

1399
00:58:52,600 --> 00:58:54,000
from that planet anymore.

1400
00:58:54,000 --> 00:58:56,640
So essentially in order, like your spam better

1401
00:58:56,640 --> 00:58:59,320
have made you 10 bucks or like, you know,

1402
00:58:59,320 --> 00:59:00,960
and that's a pretty high bar for spam.

1403
00:59:00,960 --> 00:59:03,840
And so basically just by having this sort of limited

1404
00:59:04,760 --> 00:59:08,120
supply of real estate that's treated as digital property,

1405
00:59:08,120 --> 00:59:10,320
you basically have the basis for building

1406
00:59:10,320 --> 00:59:12,200
a reputation system that works

1407
00:59:12,200 --> 00:59:14,680
because the real killer of reputation systems

1408
00:59:14,680 --> 00:59:16,560
is an infinite supply of identities.

1409
00:59:16,560 --> 00:59:18,320
Because you have this problem where you're like,

1410
00:59:18,320 --> 00:59:19,920
I've never seen this identity before.

1411
00:59:19,920 --> 00:59:21,160
Maybe it's a new user.

1412
00:59:21,160 --> 00:59:22,240
I really wanna say hi.

1413
00:59:22,240 --> 00:59:23,880
Maybe it's that spammer I just banned.

1414
00:59:23,880 --> 00:59:25,200
I really don't wanna say hi.

1415
00:59:25,200 --> 00:59:26,960
That's kind of an unsolvable problem.

1416
00:59:26,960 --> 00:59:30,320
And so basically I think this is one of the things like,

1417
00:59:30,320 --> 00:59:33,320
you know, nobody, a tiny young network like Erbit,

1418
00:59:33,320 --> 00:59:34,960
nobody abuses.

1419
00:59:34,960 --> 00:59:37,560
But, you know, in the future, as you grow,

1420
00:59:37,560 --> 00:59:38,880
basically you become a target.

1421
00:59:38,880 --> 00:59:40,320
And so having a system like this

1422
00:59:40,320 --> 00:59:41,680
helps you not be a target.

1423
00:59:43,280 --> 00:59:45,560
Let's fall back on the point of all this.

1424
00:59:46,720 --> 00:59:49,240
Inventing new system software is always a bad idea.

1425
00:59:49,240 --> 00:59:51,120
It's a terrible, terrible thing to do.

1426
00:59:51,120 --> 00:59:53,240
Never, never, never do this.

1427
00:59:54,680 --> 00:59:59,680
So let's go back to basically the goal of this project,

1428
00:59:59,720 --> 01:00:01,080
which is to build a personal server.

1429
01:00:01,080 --> 01:00:03,360
So a personal server is gonna be a social server.

1430
01:00:03,360 --> 01:00:05,120
So if you have a real personal server

1431
01:00:05,120 --> 01:00:06,520
that's a real social server,

1432
01:00:06,520 --> 01:00:08,240
when I socialize with you,

1433
01:00:08,240 --> 01:00:09,160
in the one nearer case,

1434
01:00:09,160 --> 01:00:11,080
barring like weird identity games,

1435
01:00:11,080 --> 01:00:13,360
I shouldn't be sending packets directly to you.

1436
01:00:13,360 --> 01:00:15,600
I shouldn't be sending packets to some Facebook thing

1437
01:00:15,600 --> 01:00:17,080
over there that then sends them to you.

1438
01:00:17,080 --> 01:00:19,960
I should be able to basically actually socialize

1439
01:00:19,960 --> 01:00:22,640
in a distributed way using distributed protocols.

1440
01:00:22,640 --> 01:00:25,960
And one of the things about the way we compute today,

1441
01:00:25,960 --> 01:00:29,000
and the reason basically we don't do this,

1442
01:00:29,040 --> 01:00:30,560
is that if you look at the difficulty

1443
01:00:30,560 --> 01:00:32,040
of distributed programming,

1444
01:00:32,040 --> 01:00:34,080
let's say you're building like a tic-tac-toe app,

1445
01:00:34,080 --> 01:00:36,560
compare the difficulty of building distributed tic-tac-toe

1446
01:00:36,560 --> 01:00:39,000
with the difficulty of building centralized tic-tac-toe.

1447
01:00:39,000 --> 01:00:41,440
Centralized tic-tac-toe, my score,

1448
01:00:41,440 --> 01:00:42,400
your score, they're variables.

1449
01:00:42,400 --> 01:00:44,280
They're in the same data structure.

1450
01:00:44,280 --> 01:00:45,120
It's easy.

1451
01:00:45,120 --> 01:00:47,240
Then suddenly you're building distributed tic-tac-toe

1452
01:00:47,240 --> 01:00:49,760
and you're like have to apply to the ITF for an RFC

1453
01:00:49,760 --> 01:00:51,960
for your TTTTP, right?

1454
01:00:51,960 --> 01:00:55,920
And it's just like six orders of magnitude different

1455
01:00:55,920 --> 01:00:57,080
in difficulty.

1456
01:00:57,080 --> 01:00:59,040
And if you wanna ask why we don't have

1457
01:00:59,040 --> 01:01:00,480
a decentralized internet,

1458
01:01:00,480 --> 01:01:03,160
basically the reason we don't have a decentralized internet

1459
01:01:03,160 --> 01:01:06,600
is that decentralized programming is too damn hard.

1460
01:01:06,600 --> 01:01:08,560
So basically you need to solve this problem

1461
01:01:08,560 --> 01:01:12,080
if you're gonna build anything like a true personal server.

1462
01:01:12,080 --> 01:01:13,680
So let me talk a little bit about

1463
01:01:13,680 --> 01:01:15,360
the kind of programming or experience

1464
01:01:15,360 --> 01:01:17,400
of where we're aiming to get with this.

1465
01:01:17,400 --> 01:01:19,200
This is actually my next last slide.

1466
01:01:20,400 --> 01:01:21,840
So let's see, first of all,

1467
01:01:21,840 --> 01:01:22,960
you're programming in the system.

1468
01:01:22,960 --> 01:01:25,120
You can dereference a global immutable namespace.

1469
01:01:25,120 --> 01:01:27,040
So basically use any data in the world

1470
01:01:27,040 --> 01:01:28,760
as if it was a typed constant.

1471
01:01:28,760 --> 01:01:30,280
That's kinda nice.

1472
01:01:30,280 --> 01:01:31,760
Your application state is permanent.

1473
01:01:31,760 --> 01:01:35,080
You don't need a database to basically flush stuff out too

1474
01:01:35,080 --> 01:01:38,560
when for your data actually exist.

1475
01:01:40,000 --> 01:01:41,280
When you do an update,

1476
01:01:41,280 --> 01:01:43,440
your updates basically come through reactively

1477
01:01:43,440 --> 01:01:46,600
through the, you have basically a revision control system

1478
01:01:46,600 --> 01:01:48,720
that's clay or I didn't talk much about that,

1479
01:01:48,720 --> 01:01:52,160
but it's basically a revision control system with hooks.

1480
01:01:52,160 --> 01:01:55,100
And so you're like, oh, I got a source code update

1481
01:01:55,100 --> 01:01:56,080
for this thing I'm running.

1482
01:01:56,120 --> 01:01:59,040
And then I'm like, oh, I need to change out the code.

1483
01:01:59,040 --> 01:02:01,200
Oh, gee, the type of my data change.

1484
01:02:01,200 --> 01:02:04,280
So I need to have a type adapter in there

1485
01:02:04,280 --> 01:02:06,440
to make that work.

1486
01:02:06,440 --> 01:02:07,720
That all works great.

1487
01:02:08,680 --> 01:02:11,380
A very different experience from kind of updates

1488
01:02:11,380 --> 01:02:13,440
or upgrades in a lot of systems.

1489
01:02:14,960 --> 01:02:17,880
When you get to messaging patterns, basically,

1490
01:02:17,880 --> 01:02:21,160
you've got a poke, which is a forward, basically,

1491
01:02:21,160 --> 01:02:23,840
essentially an RTC without a return.

1492
01:02:23,840 --> 01:02:25,880
And you've got a subscription model.

1493
01:02:25,880 --> 01:02:28,360
Let's look at basically what we get with pokes

1494
01:02:28,360 --> 01:02:29,720
for a moment.

1495
01:02:29,720 --> 01:02:32,080
Number one, you get exactly once delivery.

1496
01:02:32,080 --> 01:02:35,160
You've probably heard that exactly once delivery is impossible.

1497
01:02:35,160 --> 01:02:38,200
It was a great blog post about that a few months ago.

1498
01:02:38,200 --> 01:02:40,160
Exactly once delivery and message semantics

1499
01:02:40,160 --> 01:02:43,080
actually is possible if all of your entities

1500
01:02:43,080 --> 01:02:44,400
are single level stores.

1501
01:02:44,400 --> 01:02:47,120
And if they can basically run permanent sessions.

1502
01:02:47,120 --> 01:02:49,120
So you have a permanent session and you're like,

1503
01:02:49,120 --> 01:02:52,880
oh, I expect message seven from you.

1504
01:02:52,880 --> 01:02:55,720
Well, you're only gonna get message seven once.

1505
01:02:55,720 --> 01:02:57,520
Where that breaks down in this kind of system

1506
01:02:57,520 --> 01:02:59,080
where you have transient and permanent state

1507
01:02:59,080 --> 01:03:01,480
is you reboot the computer and then you're like,

1508
01:03:01,480 --> 01:03:03,480
do I expect message seven or message six?

1509
01:03:03,480 --> 01:03:08,480
Or you have these idempotence problems.

1510
01:03:08,520 --> 01:03:10,620
So every message is a transaction

1511
01:03:10,620 --> 01:03:13,440
in this kind of distributed programming environment.

1512
01:03:13,440 --> 01:03:16,240
If the transaction succeeds, there's no return data.

1513
01:03:16,240 --> 01:03:18,480
So it's a one way transaction.

1514
01:03:18,480 --> 01:03:20,320
Your messages are automatically type checked

1515
01:03:20,320 --> 01:03:22,580
and validated on the receiving side.

1516
01:03:22,580 --> 01:03:25,120
You can even do basically protocol type updates

1517
01:03:25,120 --> 01:03:28,200
on the live network and not propagate errors to the user.

1518
01:03:30,400 --> 01:03:33,280
The data that you get over the wire is passed to you typed.

1519
01:03:33,280 --> 01:03:34,920
You basically just get it as an argument

1520
01:03:34,920 --> 01:03:36,620
and it's a typed value.

1521
01:03:37,760 --> 01:03:39,480
We do end-to-end acknowledgments,

1522
01:03:39,480 --> 01:03:41,600
which basically means there's kind of a single error mode.

1523
01:03:41,600 --> 01:03:43,320
So when you're doing acknowledgments,

1524
01:03:43,320 --> 01:03:47,000
like think about you're doing a normal RPC or HTTP.

1525
01:03:47,000 --> 01:03:47,840
Something goes wrong.

1526
01:03:47,840 --> 01:03:48,840
Well, what could go wrong?

1527
01:03:48,840 --> 01:03:50,300
Your socket could break.

1528
01:03:50,300 --> 01:03:52,100
You could get an HTTP error.

1529
01:03:52,100 --> 01:03:54,880
You could get an error at the RPC layer.

1530
01:03:54,880 --> 01:03:56,400
What do you even do with half of these things?

1531
01:03:56,400 --> 01:03:59,360
Like there are different kinds of error.

1532
01:03:59,360 --> 01:04:02,400
And that basically is just very, very difficult to handle.

1533
01:04:02,400 --> 01:04:04,160
So if you're basically doing acknowledgments

1534
01:04:04,160 --> 01:04:05,760
at an end-to-end level,

1535
01:04:05,760 --> 01:04:08,640
that means the packet level act that you send back

1536
01:04:08,640 --> 01:04:12,560
is actually the transaction acknowledgement

1537
01:04:12,560 --> 01:04:14,040
that you succeeded or failed.

1538
01:04:15,360 --> 01:04:17,120
Messages are queued by the sender.

1539
01:04:17,120 --> 01:04:19,920
Obviously, this is a P2P network.

1540
01:04:19,920 --> 01:04:23,800
It traverses NAT and of course it's authenticated

1541
01:04:23,840 --> 01:04:25,080
and encrypted.

1542
01:04:25,080 --> 01:04:27,720
Your subscriptions are sending diffs.

1543
01:04:27,720 --> 01:04:29,520
Those again are typed.

1544
01:04:29,520 --> 01:04:33,440
So this is a very different distributed programming experience

1545
01:04:33,440 --> 01:04:38,440
than your sort of normal, I'm writing this in node experience.

1546
01:04:39,080 --> 01:04:41,720
And our experience is basically it's,

1547
01:04:41,720 --> 01:04:45,000
you just do things and they pretty much just work.

1548
01:04:45,000 --> 01:04:47,080
What is the status of this system?

1549
01:04:47,080 --> 01:04:50,160
It's about 30,000 lines of Coon, including basic apps.

1550
01:04:50,160 --> 01:04:51,640
It's totally open source.

1551
01:04:51,640 --> 01:04:53,480
You can go to urban.org.

1552
01:04:53,480 --> 01:04:56,080
And which is served by Arbit, although we cash it.

1553
01:04:57,600 --> 01:05:02,520
And yeah, I mean, it essentially works.

1554
01:05:02,520 --> 01:05:04,080
We were on occasional global flag days,

1555
01:05:04,080 --> 01:05:06,880
so you might not want to move your business onto this system.

1556
01:05:09,080 --> 01:05:13,480
But yeah, I mean, when creating a system like this,

1557
01:05:13,480 --> 01:05:15,920
involves a lot of rewriting stuff over and over again

1558
01:05:15,920 --> 01:05:17,440
until it actually works right.

1559
01:05:18,320 --> 01:05:22,000
And we're basically getting to the end of that process

1560
01:05:22,000 --> 01:05:24,920
and we're kind of close to being ready to sell

1561
01:05:24,920 --> 01:05:26,400
some address space to the public.

1562
01:05:26,400 --> 01:05:30,120
Let me do a quick demo of this system

1563
01:05:30,120 --> 01:05:33,320
to see if it's actually working.

1564
01:05:33,320 --> 01:05:35,680
I'm actually doing this over my,

1565
01:05:37,440 --> 01:05:39,360
so here is, you're in Arbit.

1566
01:05:41,400 --> 01:05:42,880
Live, yes, we're live.

1567
01:05:42,880 --> 01:05:45,440
That bounced off the server and came back.

1568
01:05:45,440 --> 01:05:49,240
So that's basically a simple console talk app.

1569
01:05:50,240 --> 01:05:55,440
Hello from, a little bit slow on the typing there.

1570
01:05:55,440 --> 01:05:57,840
Our console path is pretty complicated

1571
01:05:57,840 --> 01:05:59,840
and we could use some serious optimization.

1572
01:05:59,840 --> 01:06:03,440
Let me see if I can bring up the web UI of talk.

1573
01:06:03,440 --> 01:06:05,720
Ah, yes, here is a web app.

1574
01:06:08,080 --> 01:06:10,240
Let me get it fully up.

1575
01:06:12,040 --> 01:06:13,360
Looks like it needs a reload,

1576
01:06:13,360 --> 01:06:14,920
which it actually should not.

1577
01:06:16,400 --> 01:06:18,320
Hate it when that happens.

1578
01:06:18,320 --> 01:06:22,360
But here, basically, you're seeing a web UI.

1579
01:06:22,360 --> 01:06:23,200
Do you want to say something?

1580
01:06:23,200 --> 01:06:24,560
Anyone want to say something?

1581
01:06:24,560 --> 01:06:26,800
I'll just be, hello from William the Comfort Inn.

1582
01:06:32,200 --> 01:06:34,040
Boulder is beautiful.

1583
01:06:34,040 --> 01:06:39,040
So, beautiful with an extra K.

1584
01:06:40,600 --> 01:06:43,960
And this has to bounce off the server to get back.

1585
01:06:43,960 --> 01:06:47,240
Actually, the Colorado's router

1586
01:06:47,280 --> 01:06:52,280
seems to be blocking my transition directly.

1587
01:06:53,520 --> 01:06:57,080
But, you know, I'm doing it via Verizon, so it works fine.

1588
01:06:57,080 --> 01:06:59,880
TaskFind Partive is actually running on this laptop here.

1589
01:07:01,960 --> 01:07:03,800
Yeah, so that was a very simple demo

1590
01:07:03,800 --> 01:07:05,560
and now, any questions?

1591
01:07:05,560 --> 01:07:06,400
Yes.

1592
01:07:06,400 --> 01:07:08,760
So, does Richard Stallman know about this?

1593
01:07:08,760 --> 01:07:09,600
I don't think so.

1594
01:07:09,600 --> 01:07:13,160
Because I don't think this would really get

1595
01:07:13,160 --> 01:07:15,440
to what Richard Stallman would like to see.

1596
01:07:15,440 --> 01:07:17,640
Yeah, I think there's a lot of people

1597
01:07:17,640 --> 01:07:20,360
who are tired of this sort of Facebook-ization

1598
01:07:20,360 --> 01:07:21,520
of the internet.

1599
01:07:21,520 --> 01:07:24,800
And this is definitely also, I mean, yeah,

1600
01:07:24,800 --> 01:07:25,640
is this a list?

1601
01:07:25,640 --> 01:07:27,240
Is this basically E-Max?

1602
01:07:27,240 --> 01:07:29,680
At a certain level, it's basically E-Max.

1603
01:07:29,680 --> 01:07:33,920
So, yeah, you know, all right,

1604
01:07:33,920 --> 01:07:35,640
we're at a one-minute warning here.

1605
01:07:35,640 --> 01:07:37,800
Time for maybe one or two more questions.

1606
01:07:39,400 --> 01:07:40,360
Be over?

1607
01:07:40,360 --> 01:07:41,440
Yes?

1608
01:07:41,440 --> 01:07:43,640
So, I feel like maybe you're trying to

1609
01:07:43,640 --> 01:07:46,440
talk to me confusing, like, do you use the word twig,

1610
01:07:46,440 --> 01:07:48,280
but like, I'll be referred to as a nasty?

1611
01:07:48,280 --> 01:07:49,120
Mm-hmm.

1612
01:07:49,120 --> 01:07:50,160
Is there a particular reason for, like,

1613
01:07:50,160 --> 01:07:51,920
these more or less travel elements?

1614
01:07:52,920 --> 01:07:55,400
Yeah, I mean, the reason is basically you're,

1615
01:07:56,320 --> 01:07:59,840
you want to use the word that the actual source code uses.

1616
01:07:59,840 --> 01:08:01,800
Is the reason for that being the convention

1617
01:08:01,800 --> 01:08:03,720
and the source code, is that a good reason?

1618
01:08:03,720 --> 01:08:05,360
Maybe not necessarily.

1619
01:08:05,360 --> 01:08:06,880
It certainly makes things kind of tire

1620
01:08:06,880 --> 01:08:08,200
and more readable in a way.

1621
01:08:08,200 --> 01:08:10,560
There's an aesthetic, which kind of,

1622
01:08:10,560 --> 01:08:12,040
there's an aesthetic of short names,

1623
01:08:12,040 --> 01:08:14,480
which works fairly well in kind of a functional environment,

1624
01:08:14,480 --> 01:08:17,160
which wouldn't work in an imperative environment.

1625
01:08:17,160 --> 01:08:19,720
But, yeah, I mean, you know, the criticism

1626
01:08:19,720 --> 01:08:21,120
that this is a little more obfuscated

1627
01:08:21,120 --> 01:08:22,240
than it has to be, is certainly one

1628
01:08:22,240 --> 01:08:24,240
that I think holds a little bit of water.

1629
01:08:26,280 --> 01:08:28,160
So, when you chat with the one message

1630
01:08:28,160 --> 01:08:29,760
and so there's a browser,

1631
01:08:29,760 --> 01:08:33,920
how do you go through the centralized events?

1632
01:08:33,920 --> 01:08:37,800
So, that is basically, that, if you saw,

1633
01:08:37,800 --> 01:08:39,920
if I turn on debugging, here,

1634
01:08:40,920 --> 01:08:45,920
turn on debugging, and you'll see a lot of...

1635
01:08:49,560 --> 01:08:52,320
Okay, so what's actually happening is that packet,

1636
01:08:52,320 --> 01:08:55,400
so I'm logged into, I could log in via

1637
01:08:55,400 --> 01:08:57,120
taskfinepartive.erb.org, here,

1638
01:08:57,120 --> 01:08:58,840
let me turn this off, this is horrible.

1639
01:08:59,840 --> 01:09:04,280
And I could log in via taskfinepartive.erb.org

1640
01:09:04,280 --> 01:09:06,880
and be proxied by basically the star

1641
01:09:06,960 --> 01:09:11,960
that is, taskfinepartive is a planet of.

1642
01:09:11,960 --> 01:09:13,600
But, basically, I'm in a channel,

1643
01:09:13,600 --> 01:09:15,240
that channel is hosted on DOSNEC,

1644
01:09:15,240 --> 01:09:18,640
which is the star that I'm responsible to.

1645
01:09:18,640 --> 01:09:21,920
And so, basically, that packet is going up to DOSNEC,

1646
01:09:21,920 --> 01:09:23,600
coming back to me, and then it's going

1647
01:09:23,600 --> 01:09:26,000
over localhost8080 to the browser.

1648
01:09:28,200 --> 01:09:29,880
All right, any more questions?

1649
01:09:29,880 --> 01:09:31,560
I think we're time.

1650
01:09:32,560 --> 01:09:33,560
Thank you.

1651
01:09:33,560 --> 01:09:34,560
Thank you.

1652
01:09:34,560 --> 01:09:35,560
Thank you.

1653
01:09:35,560 --> 01:09:36,560
Thank you.

