start	end	text
0	3120	So I'm going to be talking about this interesting little system,
3120	5840	Erbit, that I and some friends have built.
5840	10000	Erbit is a clean slate full stack system.
10000	13360	So let me explain sort of briefly the problem that we're
13360	16560	solving here first, because this is a little different
16560	21080	from the problem that a usual language is solving.
21080	24200	So we have basically a coupling of kind of two interesting
24200	24840	problems here.
24840	28240	We have a very different kind of technical problem that we're
28240	31680	solving, and we also have a different human market need
31680	33120	that we're solving.
33120	35160	So let me go through both of those super quickly.
35160	38480	So the technical problem we're trying to solve here is
38480	41040	something I call a high level deterministic computer.
41040	44360	So that would be basically a computer whose entire life
44360	47080	cycle is defined by a single frozen function.
47080	49400	So it's really very functional.
49400	53640	Of course, a hardware VM, a CPU, is defined by a single
53640	55920	frozen function, which is the CPU function, which is very
55960	58680	frozen because it's on the chip.
58680	62600	But we'd actually like to define that at a layer at the same
62600	65960	level at which the programmer conceives the system.
65960	69360	So if we look at some kind of approximations to this that
69360	73600	exist in reality today, JavaScript and the Java VM, of
73600	79320	course, are high level definitions, but they're
79320	82040	defined only sort of for a transient system.
82040	84600	So here we're defining the whole life cycle of the
84600	85320	computer.
85320	86640	This is not just a memory image.
86640	90040	This is the whole machine, which is a single level store.
90040	93000	Lisp and small talk have these image-based systems that
93000	96120	come a little closer to this kind of approach.
96120	98280	I don't think people in practice usually use Lisp and
98280	100400	small talk actually as databases.
100400	104960	And they're not defined functionally in the same way.
104960	109800	But it's definitely in the image-based system tradition.
109800	111840	When you're using this thing, it basically feels like an
111840	114560	integrated interpreter OS and database, which is a very
114720	118760	kind of unusual feeling for a programming environment.
118760	120960	You might also ask what happens when a determinist to
120960	123240	computer hits an undecidable problem.
123240	126360	We'll get into that in a little bit.
126360	130800	One way of sort of defining this problem that I like to use
130800	133960	is an unusual versioning system that we use, which I
133960	135000	call Kelvin versioning.
135000	138240	So Kelvin versioning, you count down to absolute zero and
138240	139600	you count by integers.
139600	142360	So if you run out of numbers, you've made a mistake,
142360	142880	basically.
142880	145640	So absolute zero is absolutely frozen.
145640	148680	So Erbit, or at least the sort of the formal definition of
148680	151760	Erbit, which does fit on a t-shirt, is at five Kelvin,
151760	154640	which is like liquid helium, basically at the moment.
154640	157680	And we'll see that spec in a little bit.
157680	161080	Let's switch gears totally and talk about the human need that
161080	163280	this system is supposed to be solving.
163280	165840	We have this little problem in the computer world, which is
165840	168240	that the internet actually failed.
168240	170360	It succeeded very well as a digital modem.
170360	172480	It's a great digital modem.
172520	174560	It's entirely a client-server environment.
174560	176200	It is not a peer-to-peer network.
176200	178920	It's never going to be a peer-to-peer network.
178920	181400	And if you look at sort of the dream of the internet from
181400	185760	the 80s and 90s, it was a dream in which everyone on this
185760	187880	network would have their own server.
187880	191080	And things like what we do on Facebook today would be done
191080	193320	by protocols like SMTP.
193320	196000	Well, you can't introduce a new wide area protocol on the
196000	196640	internet today.
196640	200240	You can barely keep SMTP alive.
200280	202560	These systems were designed in the 70s.
202560	205480	The same thing for basically Linux, which is, in a sense,
205480	207360	I would say, layer seven of the internet.
207360	209280	It's the application layer.
209280	211320	If you're on the internet, you're either a Unix box or
211320	213400	you're pretending to be a Unix box.
213400	217360	You can't really say to my mother, hey, you should go out
217360	220440	and get an AWS box and put all your data on that and app
220440	224000	get installed, something.
224000	226040	That's just never basically going to fly.
226040	229720	And so we've kind of reconciled ourselves to those
229720	232600	sort of loss of this dream where people actually control
232600	234000	their own individual computing.
234000	238960	And instead, we've basically gone back and recreated the
238960	241120	Hayes modem protocol with HTTP.
241120	244400	And we've recreated AOL with Facebook.
244400	246920	And we're kind of stuck in this space.
246920	248760	So we have a big problem here.
248760	251560	And these systems aren't basically not fixable.
251560	254360	Well, there's a way to get out of a problem that isn't
254360	256080	fixable, which is to layer over it.
256080	258760	So the browser already did this on the client side.
258800	261040	Basically, you had these OS APIs.
261040	263360	And they're like, OK, we're going to build a new
263360	264600	application layer.
264600	267160	I guess browser people didn't realize that this is what
267160	267640	they were doing.
267640	269120	But it's certainly what they were doing.
269120	271040	We're going to build a new programming layer that is
271040	274360	isolated from the substrate under it that cannot call out
274360	276040	in any way, shape, or form.
276040	278720	And we're just going to program to that layer and not care
278720	280840	about the underlying OS.
280840	283120	And that actually kind of worked great.
283120	285240	So on the server side, basically, this
285240	287240	hasn't been done yet.
287240	290160	And I would say, basically, we don't know that people don't
290160	291280	want personal servers.
291280	294360	People ask them, you tell them what a personal server is.
294360	296160	And they say, yes, I want that.
296160	298640	We do know that they don't want Linux and internet
298640	299400	personal servers.
299400	302160	We do know that my mother is never going to run an open
302160	303760	Linux server on the internet.
303760	307720	So there's basically a real case to be made for saying, OK,
307720	309880	we need a new layer here.
309880	313120	If we sort of drill down a little bit and define the need,
313120	317120	the need is basically caused by the, essentially, the
317120	319560	obstacle to the universal personal server is just
319560	320440	administrative cost.
320440	322320	My mother is not a Linux is that thing.
322320	325320	So when you're looking at a problem and your problem is
325320	328440	administrative cost, it makes sense that a solution to this
328440	330160	problem is going to be technical simplicity.
330160	332920	Because basically, the difficulty of administering
332920	335640	the system tends to be roughly proportional to the number of
335640	336840	lines of code in it.
336840	338720	And if you haven't noticed, there's a lot of lines of
338720	340800	code in Ubuntu.
340800	345120	And so basically, the idea of building the browser for the
345120	348400	server side is sort of a problem that kind of makes sense
348400	350640	next to this problem of let's build a high-level
350640	353200	deterministic computer.
353200	355640	So OK, let's build it.
355640	357840	How do you define a one-function computer?
357840	360800	Well, you need, remember, we're defining both the network
360800	361560	and the OS here.
361560	364760	We're really defining a computing environment as if we
364760	367400	just stumbled on a planet that had chips and wires and no
367400	370600	software whatsoever, which is kind of fun.
370600	373560	And if you're going to define the way this works, you're
373560	375520	defining networking from scratch.
375520	377960	I find the simplest way to think about networking is to
377960	380280	imagine just basically a global party line.
380280	383600	So a packet is just a big integer blob that people put
383600	384200	out.
384200	386040	Everybody hears everyone else's packets.
386040	388680	And if you have the keys to decrypt those packets and make
388680	390960	them make sense, then you use them.
390960	394240	Then you can basically say to this global party line, hey,
394240	396600	we would like to actually optimize this.
396600	398600	And you get back to routing.
398600	402520	But routing is basically an optimization in Van Jacobsen
402520	406000	has this great term, a content-centric network, where
406000	409080	you're basically ignoring who sent you the packet doesn't
409080	409400	matter.
409400	411200	What matters is what's in the packet.
411200	416320	So that's sort of the network perspective on this.
416320	419520	From the sort of functional perspective, there's basically
419520	422040	two ways to define a one-function computer.
422040	424440	You can define it as a life cycle function, which is
424440	427880	where the state is a pure function of input history.
427880	429320	And remember, this is a frozen function.
429320	430680	This never changes.
430680	432640	You cannot upgrade this function.
432640	434680	Or you can define it as a transition function, where
434680	437280	basically you have an input event in an old state,
437280	440520	outcomes, a bunch of output actions in a new state.
440520	443360	These are really, in practice, basically turned into the
443360	443880	same thing.
443880	447520	In practice, essentially any life cycle function is going
447520	449720	to wind up spending most of its time as a transition
449720	452360	function, because you're certainly not going to
452360	456320	recompute the whole log every time you get a packet.
456320	458360	And one of the advantages of doing it the life cycle
458360	461520	function way is when you're basically building a system
461520	463800	where you have one frozen function which defines the
463800	467080	semantics of every computer in the world, you need to
467080	468440	basically break symmetry.
468440	471040	And you need to basically, when you're starting that up, you
471040	472360	need some startup packets.
472360	473400	You need some startup.
473400	475440	You need the load and operating system into your
475440	477200	function, essentially.
477200	479880	And so a life cycle function makes slightly more sense as a
479880	481880	way to define this.
481880	485080	Let me skip down for a second and talk about how you
485080	485880	implement these things.
485880	490320	Actually, implementing a sort of one function computer like
490320	492720	this is kind of very easy with the kind of substrates that
492720	494280	you have at the moment.
494280	497480	Event sourcing is basically this pattern.
497480	500080	It's usually not used for a general purpose computer, but
500080	502080	it's the same pattern.
502080	508000	You have low latency reliable logs are uniformly available.
508000	511000	Kafka isn't the greatest thing in the world, but it works fine.
511000	513760	Normal databases are defined in terms of the pend only
513760	518280	transaction log and an image snapshot.
518280	521520	So you're basically building this the same way a normal
521520	522760	database is built.
522760	525960	You're saying every packet is a transaction.
525960	527320	And it basically works great.
527320	530000	You can also do non-packet I.O. I mean, I like to think of an
530000	534040	abstract computer as just packets in, packets out.
534040	538000	But as you'll see, we want to serve web pages and so forth.
538000	543600	So basically, you can model even ordinary HDDB requests
544440	546480	as here's an event that's like you got a request.
546480	548600	Here's my action respond to this request.
548600	552600	So there's a great library LibUV, which is used by Node.js
552600	554800	that implements these patterns very nicely.
554800	556520	So it's super easy to do.
556520	558120	I mentioned decidability earlier.
558120	560120	That's kind of an interesting problem for a deterministic
560120	563160	computer or any kind of non-preemptive OS.
563160	565440	When you're building a non-preemptive system, basically
565440	568640	the decision of when to terminate a computation is
568640	571360	essentially a heuristic choice.
571840	574400	If that event is caused by a console, that heuristic choice
574400	575240	is very easy.
575240	577720	Just go until they hit Control C.
577720	579360	If it's a packet, that's a little harder.
579360	581240	You need to decide when to time that out.
581240	584600	There's a kind of nice duality between unreliable packet
584600	586600	networking and turn completeness.
586600	588760	And when you drop a packet because it's
588760	592600	spending too long, you're essentially detecting congestion
592600	594600	in the CPU.
594600	597600	And so that kind of makes a certain amount of sense.
597600	600040	Node.js has shown that you can actually do very useful
600040	601880	things with non-preemptive systems.
601880	604080	One of the most interesting problems in building a system
604080	605960	like this is you're going to have certain kinds of
605960	607800	non-determinism that you can't avoid.
607800	609040	Let's say I write an infinite loop.
609040	609720	I made a mistake.
609720	610600	I wrote an infinite loop.
610600	612920	I pressed Control C. One thing I really want there is a
612920	613920	stack trace.
613920	615480	So that stack trace is completely
615480	616960	non-deterministic information.
616960	620440	You can't get that into a deterministic way.
620440	625000	But all is not lost because basically the underlying C
625000	627880	code that actually implements this system sees that stack
627880	629400	trace, has that stack trace.
629400	632040	All it needs to do is basically inject that back in as a
632040	633400	deterministic event.
633400	636040	And so basically, you get an event that says, hey, I was
636040	637760	trying to do this packet, but it crashed.
637760	638640	And here's where it crashed.
638640	640840	And then you can write that to the user in the appropriate
640840	642680	way, and that actually works.
642680	647560	So if you replay that log, we've replayed 30 gigabyte logs
647560	650400	and wound up for the same bit for bit state.
650400	653200	If you replay that log, it will replay the error.
653200	654520	Essentially, it won't even bother with their
654520	655520	original transaction.
655520	657800	So this is not pieing the sky.
657800	659320	This is a working system.
659320	662400	This is clearly doable.
662400	666400	So probably a lot of Lisp fans in the audience, let's try
666400	668040	doing this in Lisp.
668040	670960	So it's actually easy to define a life cycle function in
670960	671600	Lisp.
671600	676080	You simply say, OK, the first event in the log is my
676080	677280	operating system.
677280	680880	And all the rest of the log, the cutter of the log, is the
680880	681560	rest of the event.
681560	684000	So run the operating system on the rest of the events.
684000	685280	You still have to write the function.
685280	687960	But OK, you've made progress.
687960	689680	And now, all we need is the one true Lisp.
692480	697200	So I think all Lisp needs is the one true Lisp.
697200	698760	There have been a lot of attempts to create the one
698760	699720	true Lisp.
699720	701960	I haven't really worked out.
701960	704640	In my view, that's basically a problem that goes back to
704640	708600	really the root of how we came up with this idea of
708600	709240	computing.
709240	713480	Because the Lambda Calculus is OK.
713480	714280	We're at LambdaConf.
714280	715960	I can't say bad things about Lambda Calculus.
715960	718920	But it was originally designed not as a means of
718920	719400	programming.
719400	721320	It was originally designed as basically a
721320	722880	metamathematical tool.
722880	725160	And people picked this up, and they found, hey, wow, this
725160	727560	thing that Church came up with actually works really well
727560	728440	for programming.
728440	730560	So you take that in one direction, and it becomes Lisp.
730560	732160	You take that in another direction, much more
732160	734840	mathematical, and it becomes Haskell.
734840	737640	And it's not like Lisp and Haskell are compatible in
737640	738120	any ways.
738120	740560	You're always basically taking Lambda, and you're growing
740560	743640	hair on it to make it a practical system.
743680	746840	And I would say that that comes from basically a very
746840	751600	deep conflict in the heart of Lambda, which is that it has
751600	754440	these features that are like symbols and variables and
754440	758120	scope that are features of a higher level language.
758120	761040	But if you want to use that as an axiomatic system, and we
761040	764040	just saw a talk on Shen which compiles to Lisp, if you want
764040	767240	to use that as an axiomatic system, basically, and put
767240	770000	the higher level language as something that is actually
770000	773280	loaded onto that axiomatic interpreter, then those things
773280	774040	are in the wrong place.
774040	775400	They're in the wrong layer.
775400	778040	And if you're going to build an axiomatic system like this,
778040	780440	you have just the demands on the precision of your
780440	782280	interpreter are just extremely high.
782280	785160	You want that to be just tiny and diamond perfect.
785160	786920	And you can't grow hair on it.
786920	790600	So in a way, basically, you sort of have no choice but to
790600	793520	invent a kind of different computational model at the
793520	795280	bottom end.
795280	800880	So this gives me a motivation to actually invent all this
800880	802520	crap.
802520	804480	We know that you should never invent anything, but
804480	806160	sometimes you have no choice.
806160	809760	So the bottom of the stack is this thing called knock.
809760	812320	It's a typeless, frozen, accommodator, interpreter,
812320	813280	non-LAMDA.
813280	814560	It's defined in 200 words.
814560	816760	It fits on a t-shirt.
816760	820240	Not wearing a t-shirt today, but I'll wear it tomorrow.
820240	824120	And I know, I know, it's bad choice.
824120	826680	On top of that is a hoon, which is a pure, strict type
826680	827960	functional language.
827960	829880	It compiles itself to knock.
829880	832080	This is type functional programming without category
832080	833440	theory.
833440	835280	We've heard from some people that they hate category
835280	836160	theory.
836160	837400	I've heard that somewhere, not sure.
837400	838760	Probably not in this room.
841480	844280	So you can see how if you have a compiler that compiles
844280	847800	itself to knock, then you can kind of bootstrap off of
847800	850200	this basic, essentially, bootloader.
850200	854120	On top of that, we have ARVO, which is a non-preemptive OS.
854120	855600	And yeah, we'll see.
855600	857720	So basically, what I've got to do here is just a really
857760	860920	lightning tour through these three systems.
860920	862800	Don't worry if there's, there might be a little bit of
862800	865720	stuff you don't understand, but just kind of sit back and
865720	867200	get an impression of the system.
867200	869880	All right, let's go into knock for a second.
869880	872320	So I sometimes call knock a functional assembly language.
872320	874720	You can program in knock, but there are no symbols or
874720	876720	anything, so you're typing numbers and doing tree
876720	878400	geometry by hand.
878400	880040	Very much like writing assembly language.
880040	881960	You could, but you wouldn't want to.
881960	883920	It's basically, it is a list, in a sense.
883920	886400	It's a list without any of these high level tools.
886400	888040	How do you get symbols out of a lisp?
888040	889600	Well, maybe it's not a lisp.
892200	895240	A key point, no cyclic data structures, no laziness, so
895240	896600	no infinite data structures.
896600	898640	You cannot knock as an interpreter, which cannot
898640	900760	create cycles.
900760	903480	I think that is basically very much the right choice in the
903480	904840	modern world.
904840	907040	No tracing garbage collectors.
907040	909520	Kind of nice.
909520	911640	Also, remember, this is a persistent system.
911640	913680	And if you look at persistent systems, any kind of
913680	918240	database, whether it's no SQL or a SQL, basically you'll see
918240	920040	acyclic data structures everywhere there.
920040	924000	You will not see very many successful databases that
924000	926360	use cyclic data structures.
926360	930440	And it's also, if you're sending data over the network, how
930440	932360	do you send a lazy list over the network?
932360	934040	How do you send a cycle over the network?
934040	934800	I mean, you can.
934800	936720	It's a little bit harder.
936720	940800	And so this is definitely very much designed for the
940800	942960	network edge, obviously.
942960	944760	It should be extremely efficient.
944760	945880	We'll get to how that works in a bit.
945880	947080	It should fit on a t-shirt.
947080	949280	It should be obviously perfect.
949280	952160	I believe that actually I've hit these points.
952160	953320	So concepts of knock.
953320	953600	Quick.
953600	955480	So a value in knock is a noun.
955480	958680	A noun is basically our version of S expressions.
958680	961440	It's S expressions without the S, because basically all that
961440	962800	stuff has been stripped off.
962800	965280	List, essentially, I would say has almost kind of a dynamic
965280	968120	type system for atoms, which you need if you don't have
968120	970440	another type system on top of it, because how do you print
970440	971920	an atom?
971920	973640	Well, if you have a type system, the type system will
973640	974600	tell you how to print the atom.
974600	977440	But if you don't have it, so basically an atom is just an
977440	978840	unsigned integer of any size.
978840	980040	We use this.
980040	981480	An atom will be a number.
981480	982600	It could be a string.
982600	984000	It could be a network packet.
984000	985960	It could be a giant file.
985960	987640	It's a blob.
987640	990440	But a blob as a number, not as a blob as a number.
990440	992920	And this is how long the number is.
992920	994920	A cell is an ordered pair of any two nouns.
994920	997680	We don't do pointer comparison.
997680	1001880	This abstraction is completely semantically opaque.
1001880	1005040	Knock itself is a function from two nouns, or a cell of
1005040	1007520	nouns, a subject and a formula to a product.
1007520	1009040	Subject is the data.
1009040	1010560	Formula is the function.
1010560	1012040	A product is the result.
1012040	1014360	And the way we define knock, we define errors as
1014360	1015080	non-termination.
1015080	1017680	So errors are basically anything that produces bottom.
1017680	1019920	Obviously, we don't do that in practice.
1019920	1024120	But that's how we define the function.
1024120	1025400	So let's go over the spec.
1025400	1027800	We'll see the knock spec in two slides.
1027800	1029920	These are reduction rules.
1029920	1032320	You see four basic operators here.
1032320	1036000	The first one is question mark, or as I would say, what?
1036000	1037240	This is a deep operator.
1037240	1041080	So is this a cell, or is it an atom?
1041080	1042960	If it's a cell, it's zero, meaning true.
1042960	1046080	And if it's an atom, it's one, meaning false.
1046080	1048120	Zero for true, one for false.
1048120	1051760	Probably a decision I might do differently next time.
1051760	1055280	But it's morally right, and it works.
1055280	1057400	We can also increment an atom.
1057400	1059840	That's our only arithmetic operator is increment.
1060720	1063320	If you try to increment a cell, it reduces to itself,
1063320	1066640	which means an infinite loop, which means an error.
1066640	1068280	You can test for equality, same thing.
1068280	1071080	You can't test for an atom for equality.
1071080	1073600	And the only interesting operator here is this slash,
1073600	1076560	which is a slot, which is a tree addressing scheme.
1076560	1081240	So in this tree addressing scheme, basically, one
1081240	1084240	is the root of the tree, two n is the left child of any node,
1084240	1086080	two n plus one is the right child.
1086080	1088560	So basically, having this kind of simple tree addressing
1088560	1090160	built into the fundamental interpreter
1090160	1093400	is what lets us not have to deal with scopes and environments
1093400	1097600	and basically all that jazz that we know and love from Wisp.
1097600	1099480	So that's all higher level stuff.
1099480	1102880	All right, so this is the rest of the knock spec.
1102880	1104960	This is a complete spec here.
1104960	1107560	So the first reduction rule here is kind of interesting.
1107560	1109680	This is something I call autocons.
1109680	1113720	So basically, if you have a knock formula,
1113720	1116480	either the head of that formula, the formula is always a cell.
1116480	1117400	It's always a pair.
1117400	1120320	The head of that formula is either a cell or an atom.
1120320	1122160	If it's a cell, then what we have here
1122160	1123560	is a pair of two formulas.
1123560	1126240	And the semantics of that is cons in those formulas.
1126240	1127800	So basically, you can build up, you
1127800	1130480	know, cons is essentially an implicit operator in a way here.
1130480	1133600	You can build up and just glom formulas together
1133600	1137600	and you get this kind of automatically cons thing.
1137600	1142480	Otherwise, so if you see A here is always the subject
1142480	1145520	and then we're pattern matching in the formula.
1145960	1147720	This, by the way, is not the syntax or anything.
1147720	1149040	It's just pseudocode.
1149040	1151160	Obviously, if you're writing axioms at a certain level,
1151160	1152440	they're written in English.
1155160	1163040	So if the head of a formula is a number, then if it's well
1163040	1165840	formed, otherwise, you see down at the bottom,
1165840	1167880	anything that's not well formed resolves to itself.
1167880	1169800	Again, an error.
1169800	1172760	If it's well formed, we have instruction 0,
1172760	1175000	which is just the slot operator.
1175000	1176680	So that lets us basically pick out
1176680	1179880	a subtree of the subject.
1179880	1183520	And then, you know, one, constant.
1183520	1184920	Two is eval.
1184920	1190360	So basically, B and C here are formulas
1190360	1193040	against the current subject for a new subject in formula
1193040	1195200	that we're going to evaluate.
1195200	1196680	Again, pretty straightforward.
1196680	1200480	3, 4, and 5 are the deep bump in same operators
1200480	1202560	that we've seen before.
1202600	1206440	Depth test, increment, and equals.
1206440	1207800	Those are actually all the operators
1207800	1210680	that we need for not to be as expressive as it wants to be.
1210680	1213720	So we could actually throw away 6 through 10 completely
1213720	1216960	and have a much shorter, cleaner spec.
1216960	1219440	There are simpler Turing-complete interpreters
1219440	1220120	in this, certainly.
1220120	1224280	So this is intended to be a practical Turing-complete
1224280	1225320	interpreter.
1225320	1227880	And it is actually practical, believe it or not.
1227880	1230240	And you probably don't believe it.
1230240	1238080	But so 6 is, I'll leave you with an exercise to the reader
1238080	1239680	if you can figure out how these macros work,
1239680	1241480	but 6 through 10 are all macros.
1241480	1243200	6 is if and else.
1243200	1245560	7 composes two formulas.
1245560	1248560	8 composes a formula with the cell
1248560	1249720	of the product of a formula.
1249720	1251680	It's basically declaring a variable, essentially.
1251680	1255600	You're putting a new value onto that subject
1255600	1258760	and then using it for the next formula.
1258760	1261000	9 is essentially implementing what
1261000	1266080	whom we use as a function call to simplify it enormously.
1266080	1267240	And 10 is a hint.
1267240	1269040	So you see two 10s there because you
1269040	1271240	can have a dynamic hint or a static hint.
1271240	1273000	What a hint is in this environment
1273000	1275000	is an instruction that throws away data.
1275000	1277040	So if you discard data, basically,
1277040	1278360	you're saying to the interpreter,
1278360	1279840	do whatever you want with this data.
1279840	1280920	Do something with it.
1280920	1284600	So hints or anything like a debugging printf is a hint.
1284600	1287800	You're like, yeah, I don't know that a debugging printf happened.
1287800	1291120	But if you want to make it happen, make it happen.
1291120	1291840	Memoization.
1291840	1293520	There's a memoization hint.
1293520	1294640	That's another good example.
1294640	1296800	So the hint basically doesn't change
1296800	1300720	the formal result of the computation,
1300720	1303600	but it helps the interpreter do something interesting with it.
1303600	1304480	So that's all of NOC.
1306920	1309360	And now let's see.
1309360	1310560	Here's a little example.
1310560	1316040	So NOC, of course, the only integer operation is increment.
1316040	1318160	So if you want to decrement, well,
1318160	1319440	that's a little bit of a problem.
1319440	1321360	You actually have to write some code.
1321360	1323680	You're going to actually have to count up to n minus 1
1323680	1325440	to decrement.
1325440	1326200	Not a big deal.
1326200	1328000	Very simple algorithm.
1328000	1329640	So here, we're jumping ahead.
1329640	1331600	And on the right side of your screen, basically,
1331600	1333800	you're seeing some poon.
1333800	1336760	Those are two, basically, kind of alternate syntaxes for poon.
1336760	1339200	One of them is a keyword syntax, which you can probably read
1339200	1340560	just by looking at it.
1340560	1343280	The other one is a rune syntax, which you probably can't read,
1343280	1344960	but that's what we actually use in practice.
1345000	1348680	It's kind of training wheels, no training wheels.
1348680	1351560	And on the left is the actual NOC formula
1351560	1353320	that we generate from this.
1353320	1355200	If I had a couple more hours, I would actually
1355200	1356200	go through this formula.
1356200	1359840	But as it is, it'll just have to serve as an example.
1359840	1362120	All we're doing is we're basically saying, OK,
1362120	1365160	we're going to call the subject a, because that's the number
1365160	1366120	we're decrementing.
1366120	1369320	We're going to add a counter, which is 0.
1369320	1370120	We're going to loop.
1370120	1376800	And we're going to count up until the increment of b is a.
1376800	1379200	If that is true, our product is b.
1379200	1380920	Otherwise, we're going to loop again
1380920	1383120	with b changed to the increment of b.
1383120	1388000	Pretty straightforward decrement, not super hard.
1388000	1390840	But that kind of brings up a problem
1390840	1395480	that you might think of, which is g, o of n decrement.
1395480	1398000	Well, if you actually run, if you try to boot
1398000	1400520	urbit with a completely naive interpreter,
1400520	1402080	it will immediately start decrementing
1402080	1404360	and keep decrementing until pretty much the end of time.
1404360	1407800	So that's clearly basically a non-starter.
1407800	1410240	There's a well-known solution to optimization problems
1410240	1410800	of this kind.
1410800	1413680	It's called a sufficiently smart interpreter.
1413680	1415560	All your interpreter has to do is simply
1415560	1418280	recognize that it needs to analyze the algorithm that
1418280	1421240	it's interpreting, recognize that it's decrement algorithm,
1421240	1424000	and implement it efficiently accordingly.
1424000	1426160	We also need to recognize add, multiply,
1426160	1427880	and all of their interesting functions.
1427880	1430120	So if you know anything about compiler theory,
1430120	1433400	you know that this is a very hard problem.
1433400	1435720	Fortunately, there's a much easier problem
1435720	1436960	which is related to it.
1436960	1438640	We don't have to recognize every decrement.
1438640	1440880	We just have to recognize the one that we actually call,
1440880	1443200	which is the one in the standard library.
1443200	1447440	And so basically, the way we optimize in the system,
1447440	1449520	and this should be sort of compared to,
1449520	1452080	let's say you're building, you're using Java or using Python.
1452080	1455920	What you do is you say, OK, I wrote some pure code.
1455920	1456560	It's beautiful.
1457360	1459880	Oh, it's not fast enough.
1459880	1461760	And I guess I need a native method.
1461760	1465600	So then you call it to C. You rewrite your interloop
1465600	1468800	or whatever in C. You throw away their original pure code.
1468800	1470360	There's another great advantage, which
1470360	1472520	is that your interloop in C can make system calls.
1472520	1476200	So it can modify the file system or something.
1476200	1482000	And that is not necessarily a very functional way
1482000	1483720	of proceeding.
1483720	1486280	The way we optimize knock and hoon is a little different.
1486280	1489240	So we basically say, when you write, say, decrement,
1489240	1491920	you say, OK, I'm going to declare this in a namespace.
1491920	1493840	I'm going to say to the interpreter,
1493840	1495480	I believe this to be decrement.
1495480	1497040	It's just a conventional name.
1497040	1497840	This is decrement.
1497840	1500280	The interpreter is like, oh, he says this is decrement.
1500280	1500920	Is this true?
1500920	1504720	Well, gee, I'm built to recognize, literally,
1504720	1506840	with the hash of the formula, I'm
1506840	1510240	built to run this specific formula efficiently.
1510240	1512720	So I'm going to match this, which is a slightly hard problem,
1512720	1514320	but I don't know how to super hard problem.
1514320	1515680	I'm going to match this at runtime,
1515680	1517560	and then I'm going to do the efficient decrement.
1517560	1519200	So the advantage of this approach,
1519200	1521560	and there's a number of advantages of this approach.
1521560	1523760	First of all, you have both those routines,
1523760	1525920	the fast decrement in C, which is totally
1525920	1527480	an implementation detail.
1527480	1530720	And you're separating mechanism and policy there,
1530720	1531160	essentially.
1531160	1533240	So you have your fast decrement in C,
1533240	1538680	and then you're essentially executable specification
1538680	1540200	of decrement.
1540200	1543920	And you're basically binding the two together.
1543920	1547560	So obviously, you can test these against each other
1547560	1549520	at runtime, if you choose.
1549520	1551840	There's certainly, you can sandbox your jet,
1551840	1555960	so it has no reason to make system calls.
1555960	1559960	You can also extend this up the stack quite a ways.
1559960	1563880	So for example, we have one of the,
1563880	1566440	we serve our own website using Herbit.
1566440	1569280	And one of the, we serve it from Markdown.
1569280	1571160	So we have a Markdown parser written in Hoon.
1571160	1573080	Well, it's a decent Markdown parser.
1573120	1575240	Maybe not the world's fastest.
1575240	1577760	Fortunately, Markdown is a standard for some values
1577760	1579760	of the word standard.
1579760	1583560	And we basically jet that Markdown parser
1583560	1586600	with an efficient common mark implementation in C.
1586600	1589120	Our, for another example is, Google
1589120	1591600	has this lovely library called TensorFlow.
1591600	1594080	They recently announced that basically they built an ASIC
1594080	1595440	for TensorFlow.
1595440	1598400	I don't know how exactly the programmer talks to that ASIC,
1598400	1600840	but I'm sure it's a mess.
1600840	1602640	What you actually want to do is basically
1602640	1606600	say, OK, I as a programmer, I'm using TensorFlow of this version.
1606600	1609160	I run TensorFlow, I declare that this is TensorFlow
1609160	1610360	of a certain version.
1610360	1612600	And then my interpreter is like, aha,
1612600	1615000	I have a chip that can speed up TensorFlow of this version.
1615000	1616600	I'll just use that.
1616600	1620320	And so that scales kind of in more interesting ways
1620320	1623880	than the, let's call it, to see model scale.
1623880	1626080	So we also use it, by the way, to virtualize knock.
1626080	1628760	So there's actually a virtual knock written in knock
1628760	1630840	if you thought knock was slow.
1630880	1634680	But basically, you can get unlimited levels of virtualization
1634680	1637040	pyramid by basically just recognizing
1637040	1639320	that you're running your own virtualizer and just saying,
1639320	1641400	hey, we're at six levels deep.
1641400	1642960	So that's an improvement as well.
1642960	1644200	All right, we're done with knock.
1644200	1645080	That's knock.
1645080	1645600	Pretty cool.
1645600	1648440	Let's build Hoon.
1648440	1651640	Hoon obviously needs to compile itself to knock.
1651640	1654360	It needs to be a pure strict higher order type functional
1654360	1656840	language, because that's the hotness.
1656840	1659040	It needs to have a, I believe it needs
1659040	1660840	to have a simple transformation to knock.
1660840	1663080	So I'm really a Unix and Seaguy.
1663080	1666080	I'm not a functional programming guy at all,
1666080	1669640	and actually don't know any of their functional languages.
1669640	1673000	And so that sort of simplicity, that feeling
1673000	1675240	that basically the compiler is doing something
1675240	1678560	very simple for you, is really like a wonderful feeling
1678560	1680560	when you're working inside C. You're
1680560	1683240	seeing the system basically at two levels.
1683240	1685800	We definitely want a system that doesn't require
1685800	1688200	people to have a math degree.
1688240	1691360	And that's a subject to complaint.
1691360	1694040	I think more generally, one of the things
1694040	1696600	that languages like Haskell do is they encourage
1696600	1697960	their functional programming languages,
1697960	1700320	and they encourage you to use these powerful tools
1700320	1702680	as much as possible.
1702680	1703760	Hoon is kind of opposite.
1703760	1706680	It encourages you to not use these tools.
1706680	1709920	It's basically like, OK, the power is there if you need it.
1709920	1712200	But bear in mind, when you're using this kind of functional
1712200	1714400	power, you're imposing cognitive overhead
1714400	1716440	on the ordinary programmer.
1716440	1719120	Because we really want this to be something
1719120	1722000	that a Python programmer can pick up and program in.
1722000	1726120	And I think the ability to basically teach people
1726120	1730000	these higher order constructs is really debatable.
1730000	1732360	I don't think it's proven at all.
1732360	1734960	There's another thing that often happens, both with macros
1734960	1737560	and with kind of advanced functional languages,
1737560	1739440	where you get into this kind of DSL pattern,
1739440	1742760	where basically you're so higher order, you're so meta,
1742760	1746800	that every file is written in its own language, which
1746800	1748440	basically gets you to write only code.
1748440	1750920	And that's like a kind of serious downside
1750920	1753200	of functional programming.
1753200	1755960	And the thing is Hoon is still basically almost as
1755960	1757560	expressive as Haskell.
1757560	1759480	It has the equivalent of type classes.
1759480	1760600	It has generosity.
1760600	1763240	It's like, it's not Haskell.
1763240	1765160	Haskell people will be a little disappointed in it,
1765160	1768600	but it's definitely not a lisp.
1768600	1771960	OK, so let's go a little more into detail on Hoon.
1772840	1775520	So basically, the back end of Hoon is extremely simple.
1775520	1778120	So type inference and code generation together,
1778120	1780440	1,500 lines of code.
1780440	1782360	Shouldn't be super hard to learn.
1782360	1785720	So where basically Nock is doing subject and formula
1785720	1788640	to product, of course, in Hoon, we have an actual expression
1788640	1791120	that is written in, for some values of the word,
1791120	1794120	user level code, user level code.
1794120	1796520	The experience of programming without an environment,
1796520	1798160	or without a scope, or without a heap,
1798160	1801200	or without the sort of extra piece of state,
1801240	1804080	where you just have, the subject is just one noun,
1804080	1806360	and everything that you need is in the subject,
1806360	1809160	is sort of somewhat unique and different.
1809160	1811200	You keep sort of reaching for that,
1811200	1813000	oh, there must be something that has my variables,
1813000	1814720	but no, there's really just one noun
1814720	1816840	that you're defining a function against.
1818680	1822680	So when we basically take a type system
1822680	1824960	and layer it on top of Nock,
1824960	1827520	we're basically computing a mapping from a type in an
1827520	1830120	expression to a type in a formula.
1830160	1833720	So we have input type, or subject type,
1833720	1838160	and expression turns into product type,
1838160	1840720	and the Nock formula that computes that expression.
1840720	1844440	So again, a very, very simple straightforward kind of
1844440	1847280	relationship to Nock here.
1847280	1849440	The inference algorithm is extremely stupid.
1849440	1853880	It infers only forward, it does not use unification at all.
1853880	1857640	It can infer tail recursion, but not head recursion.
1858640	1862120	So a general pattern is you need a few more sort of casts
1862120	1863200	to help the type system out.
1863200	1865640	It's still a strict type system,
1865640	1869480	but you need to help it a little bit.
1869480	1871880	My view is that basically having a stupider inference
1871880	1876760	algorithm is, again, a UI win for a language,
1876760	1879280	because basically when you program in a language,
1879280	1883840	you kinda need to follow what the compiler is doing.
1883840	1886400	The more powerful the algorithm you're following,
1886400	1889080	basically the harder it's gonna be for people to follow.
1889080	1891880	And so when I look at Haskell, I see basically two kinds
1891880	1893000	of Haskell users in a way.
1893000	1896160	I see people who treat Haskell as a black box,
1896160	1898240	and they're like, it's sort of a learn you a Haskell
1898240	1901160	kind of way, and they're like, oh, I made it work, cool.
1901160	1903320	And then there are the people that actually understand
1903320	1908320	the math, and both of those situations don't scale in a way.
1909400	1912680	And so having a simpler system is definitely,
1913920	1914880	I think a win.
1915800	1918400	So a little more about Hoon.
1918400	1921560	So this is brought us in for some criticism,
1921560	1925640	but Hoon basically, since it sort of has its own way
1925640	1927320	of doing things, we invent a lot of terms,
1927320	1930600	because basically the ordinary terms tend to be confusing.
1930600	1933520	So, and we also have a four letter name
1933520	1934720	kind of convention going on.
1934720	1937760	So an expression, or an AST, is a twig.
1937760	1940800	A type is, well, there's actually three things
1940800	1943000	that are basically correspond to a type.
1943000	1945760	So a type, as in sort of a set of nouns
1945760	1948960	and a semantics ascribed to them, is called a span.
1948960	1952360	A type in terms of a constructor is called a mold.
1952360	1954800	And then we also have basically, at the kind of OS level,
1954800	1956680	I don't think I'll get into that today,
1956680	1958200	basically the equivalent of mind types,
1958200	1960560	which is something else also entirely.
1962160	1963640	Looking at molds, basically,
1963640	1965160	Hoon is a pure prototype language.
1965160	1967840	There's no syntax for defining a span.
1967840	1970800	The only thing you can define are twigs.
1970800	1973160	So when you want to define basically a span,
1973160	1974960	a range, a type in the usual sense,
1974960	1976840	a set of nouns that you're interested in,
1976840	1979600	what you define is actually a normalizing function
1979600	1983240	that takes an arbitrary noun and produces a noun
1983240	1985680	of that type that you're interested in.
1985680	1987480	What's kind of nice about that is that basically,
1987480	1989280	if this is the way you define types,
1989280	1990480	anytime you define a type,
1990480	1993600	you've defined a validator for untrusted network data.
1993600	1997040	So we do a fair bit of validating untrusted network data
1997040	2000240	in today's environment, so that's kind of a win.
2001800	2004960	Basic concepts of the type system.
2004960	2007400	This is almost a complete definition
2007400	2008280	of the Hoon type system.
2008280	2010120	It's missing a little bit of stuff.
2011160	2012240	I'll see if I can fill that in,
2012240	2014280	but we've got to move pretty fast here.
2015480	2017200	So, and I'm not going to talk about twigs at all,
2017200	2019560	because once you understand basically a data representation,
2019560	2020560	it's pretty straightforward.
2020560	2023080	So a span defines a set of nouns.
2023080	2024720	What can the set be?
2024720	2027080	It can be noun, which means it could be any noun,
2027080	2029520	any remember S expression, basically.
2029640	2031600	It could be void, which is an empty set.
2031600	2033480	I'm going to skip over Adam and Core,
2033480	2035160	because I have separate slides for those.
2035160	2036680	A cell, obviously a cell.
2036680	2039280	Here's a span of the head, span of the tail.
2039280	2041840	A face, basically we're going to label this span.
2041840	2043680	And so remember that there's no symbol table,
2043680	2044680	there's no anything in here.
2044680	2047400	So the labels actually live inside the type.
2047400	2048760	So when you're searching for a label,
2048760	2051000	you're actually doing a depth-first search
2051000	2053920	of basically the type of the subject.
2053920	2056600	Fortunately, computers have gotten a lot faster.
2056600	2058000	You can cache this, we do cache it,
2058000	2059560	but I mean, fine, it's a depth-first search.
2059560	2061280	How big is your subject, right?
2062560	2065560	You can have a fork, which is a union of spans.
2065560	2066840	Pretty obvious.
2066840	2069720	And the only really interesting one in this page is hold.
2069720	2072360	So basically one thing we never do in the systems,
2072360	2074280	we never calculate type signatures.
2074280	2078840	So this is a strict system, we can't do laziness.
2078840	2081600	What hold means is basically the span here
2081600	2084480	is the result of if you take subject P
2084480	2086560	and run expression Q against it.
2086560	2089240	So this is very much manual laziness.
2090160	2091880	Manual laziness has some nice benefits.
2091880	2093920	Namely, you can use this as a,
2093920	2096920	you can use a manually lazy span as a key
2096920	2098760	in a key value data structure,
2098760	2101360	which is pretty difficult with infinite data structures.
2103560	2107360	So that's basically, those are the simple ones.
2107360	2110920	Let me get to the non-boring spans, Adam and Core.
2110920	2114240	So Adam is just an Adam, slightly non-boring
2114240	2116360	in that you can say this could be any Adam
2116360	2118320	or you could say this could be a constant.
2118320	2121200	So the unit there is who's equivalent of maybe.
2122920	2126360	And so if that's set, then we have,
2126360	2127880	this is just a constant Adam.
2127880	2130000	Then we have P there is something interesting.
2130000	2131920	The term is a symbol essentially.
2132840	2135040	And we have what I call an aura.
2135040	2137000	This is a soft type.
2137000	2139360	This is a basically non-enforced type
2139360	2141000	or enforced gently type.
2141000	2144640	And if you remember, Lisp of course has this dynamic type
2144640	2147120	and it's Adams, which is just really awful
2147120	2149480	in my personal opinion.
2149480	2152040	And if you have a type system, basically the type system
2152040	2155080	when it has an Adam needs to be able to describe
2155080	2157160	how do you print this Adam?
2157160	2160160	Gee, what happens if I try to use a furlong
2160160	2161440	as if it was a Fortnite?
2162320	2164000	What happens if I try to use an IP address
2164000	2164960	as if it was a string?
2164960	2166160	All those are Adams.
2166160	2169240	And so you basically need to label those
2169240	2171400	and describe them kind of informally.
2171400	2175080	And there's a basically system of specialization
2175080	2177440	simply by the length of the name.
2177440	2180560	So you can basically text, ASCII text,
2180560	2182600	ASCII text with a symbol constraint.
2182600	2184920	None of the, all these are informal conventions.
2184920	2187680	None of them are, there's no dependent types in the system.
2187680	2189560	Sorry, get another no dependent types.
2190560	2192960	And they're not enforced at all,
2192960	2196600	except that basically if you wanna turn an IP address
2196600	2199960	into a string basically and be so foolish,
2199960	2201440	you have to manually tell it,
2201440	2204920	you have to cast up to just a raw Adam
2204920	2207440	and then down back to your string.
2207440	2210800	So you have to work to basically screw up that way.
2210800	2212880	That's an interesting design.
2212880	2215560	You don't usually see a soft type in a functional language.
2215560	2216920	I think it's worked pretty well.
2216920	2218600	It's not perfect.
2218600	2220520	I think the most interesting span,
2220520	2224600	and remember a span is describing a set of nouns.
2224600	2226280	The most interesting one is core,
2226280	2228760	which is essentially an object.
2228760	2230240	Or it's an object that's sort of
2230240	2232040	in a very broad in general sense.
2232040	2235720	It's actually the general case of objects and functions
2235720	2237120	and a lot of other things,
2237120	2239320	which you don't really have a name for.
2239320	2240680	A core is a cell.
2240680	2242520	The head of the cell is a battery,
2242520	2245880	which is either one formula or a tree of formulas.
2245880	2248880	Remembering a formula is just a knock function.
2248880	2251600	The tail is a payload, which is basically any noun.
2253120	2256920	And when we run the arms, which are the,
2256920	2258160	basically they're not methods,
2258160	2260960	they're computed attributes in the battery.
2260960	2263360	We run that with the whole core as the subject.
2263360	2264920	So we basically have this thing
2264920	2266440	that has a bunch of code in it.
2266440	2267280	It's like, you can think of,
2267280	2269280	if you know C++ implementation,
2269280	2271920	you can think of it as like a V-table, right?
2271920	2274860	And so it's, here's a V-table with a bunch of formulas in it.
2274860	2276320	And you say, I wanna run,
2276320	2277840	I wanna get foo out of this core.
2277840	2279520	It's like, oh, great, I have a foo.
2279520	2281920	I'm gonna basically calculate,
2281920	2284440	that's gonna resolve to this calculation.
2284440	2286040	So there's no separate namespace
2286040	2287880	for basically data and for code.
2287880	2289720	So if you're looking for foo on a core,
2289720	2291080	and the core doesn't have foo,
2291080	2292640	there's no foo in the battery.
2293880	2295880	Then it goes in and says,
2295880	2297160	oh, well, let's look in the payload.
2297160	2299440	Let's descend down the tree.
2299440	2300560	Notice also again,
2300560	2304060	that there is no attempt to create a type signature here.
2304060	2306160	So this is just a map of a term to the twig.
2306160	2307400	Twig is a source.
2307400	2308840	That's a source expression.
2308840	2310720	So basically, and that's in the type.
2310720	2314040	So when I call foo on this core,
2314040	2315440	I basically go in and I say,
2315440	2318680	well, okay, that's gonna generate one of these whole things.
2318680	2320960	So it says, okay, the result,
2320960	2324800	the type of the span of the result of this foo
2324800	2329200	is basically the core type and the twig.
2329200	2331040	And so when we actually evaluate that,
2331040	2333800	we have to basically manually work through the laziness
2333800	2335840	and say, oh, well, what's in that type?
2335840	2338840	Gee, I don't know, let me calculate it and find out.
2338840	2340980	That actually, that works rather well.
2341900	2346800	Let me, okay, here's some advanced theory.
2346800	2348460	I'm gonna go over this super quickly.
2348460	2350380	So hold again is manual laziness.
2350380	2352380	One of the nice things about it is that basically,
2352380	2354660	you can build a conservative work list algorithm.
2354660	2355920	Let's say you're building a linked list.
2355920	2358820	Let's say you wanna do a type comparison on two linked lists.
2358820	2360620	Okay, now this is a basically,
2361540	2363060	this is a structural comparison.
2363060	2365960	So you're saying, these could be totally different definitions
2365960	2367100	of linked list.
2367100	2368380	Do they match?
2368380	2373380	So if you basically traverse this span,
2374340	2377380	what you're gonna see is that that traverse repeats itself.
2377380	2379620	And because it repeats itself, you can say,
2379620	2382660	oh, gee, I already checked that there were no violations
2382660	2386940	on this arm, on this branch, so I'm gonna call that fine.
2386940	2390180	And that's basically how you can do sort of type logic
2390180	2392280	in this manually evaluated space.
2392280	2394940	Again, very, very stupid if you ask,
2394940	2397580	any smart undergraduate could come up with this scheme.
2398940	2400780	A little more, at a little more depth,
2400780	2402020	I'm gonna go over this super quickly.
2402020	2403700	You may not understand it.
2403700	2407060	Basically, in polymorphism, you have two,
2408300	2410140	a lot of different kinds of languages.
2410140	2411300	And I'm thinking of like Eiffel
2411300	2413620	and like the Bertrand Meyer kind of world of languages
2413620	2415980	have basically two kinds of polymorphism.
2415980	2417740	You have variance and you have generosity.
2417740	2421180	So basically, any polymorphism in any system like this
2421180	2423620	is about basically, if I change a core,
2423620	2425220	let's say, okay, I built this core,
2425220	2428020	I stuck this battery on this payload.
2428020	2429380	But now I changed the payload.
2429380	2430460	Maybe I changed the payload
2430460	2431820	to something of a different type.
2431820	2433380	Can I run this core?
2433380	2435420	So basically, can I run this arm
2435420	2437660	or will it just be a total disaster?
2437660	2439340	And that question is actually answered
2439340	2440820	when you try to run the arm.
2440820	2445580	So there's sort of simple question of variance, basically.
2445580	2447980	Can I use this one payload as another payload?
2449060	2451700	The way we do generosity is,
2451700	2454060	I can sort of explain this intuitively
2454060	2455540	at a very high level.
2455540	2456620	When you're doing generosity,
2456620	2458540	you're basically saying,
2458540	2459380	when you're doing variance,
2459380	2461220	you're basically saying, okay,
2461220	2464500	does my mutated payload work like the original payload?
2464500	2465540	When you're doing generosity,
2465540	2466940	what you're saying is you're saying,
2466940	2469220	okay, I've changed the type of this payload.
2469220	2470940	I've changed something totally different.
2470940	2472620	Now I'm gonna run this arm on it.
2472620	2473900	I'm not gonna recompile this arm.
2473900	2476180	I'm gonna run the original knock formula
2476180	2477020	that was calculated
2477020	2479540	for something of a totally different type.
2479540	2481180	And the question you have to answer is,
2481180	2482420	is that gonna work?
2482420	2484180	And what span is it gonna produce?
2485180	2488100	And you're basically treating the twig,
2488100	2489980	you're treating the arm as a macro,
2489980	2492860	and essentially working through it.
2492860	2494420	So it's like the classic example,
2494420	2495660	can you build a function
2495660	2498260	to swap two things of an arbitrary type?
2498260	2503260	So yeah, you basically do that with generosity in Hoon.
2504620	2506940	So that works, that's how we do containers,
2506940	2508780	all the usual jazz.
2508780	2512020	And it's essentially kind of this ghetto,
2512140	2513940	low rent way of doing type classes.
2515140	2517180	Syntax design, let's go into the syntax.
2517180	2520540	Hoon has a very unusual syntax you've seen already.
2520540	2522740	A lot of people think it looks pretty gnarly.
2523660	2525780	There is a reason for doing this gnarly thing.
2525780	2528340	The reason is that basically there are kind of three problems
2528340	2530860	that you see in a lot of functional languages
2530860	2533140	that are syntactic problems.
2533140	2534860	One problem is that basically expression
2534860	2536220	is sloped downward into the right,
2536220	2538100	and so they keep attacking your right margin
2538100	2539580	if they get too complicated.
2539580	2540620	In a procedural language,
2540620	2542620	you've got this nice division between statements
2542620	2544260	and expressions, and statements flow down,
2544260	2545900	and expressions flow across,
2545900	2548140	and it gives you this kind of nice tree-shaped structure
2548140	2551100	which lets you work within an 80-column margin.
2552060	2554060	In a functional language, you often don't have that,
2554060	2556660	so you get this slanty thing,
2556660	2559060	which is uncomfortable to work with.
2559060	2562140	Another problem in syntax that a lot of these languages have
2562140	2564180	is they have this unpleasant choice between,
2564180	2566700	am I gonna have 17 parentheses in a row,
2566700	2569140	or am I gonna do significant white space?
2569140	2571420	Both of those have, they work, they work,
2571420	2574220	they just have, they're just not super pretty.
2574220	2576060	Another problem that I don't know if everyone has
2576060	2577420	this problem, I certainly have this problem
2577420	2580580	when I look at LISPs and a lot of similar things,
2580580	2583700	is basically I can't distinguish special forms from symbols.
2583700	2585860	I can't distinguish, is this part of the language,
2585860	2587980	or is this something that somebody included
2587980	2590940	from the library, or is it a macro?
2590940	2593340	And basically making that, again,
2593340	2596380	getting away from this sort of pervasive DSLization
2597380	2601100	is definitely a goal of the system.
2602540	2605460	Speeding up a little, so let me,
2605460	2608260	before showing the syntax, basically a twig structure.
2608260	2612060	Once again, the twig is a hoon AST.
2613500	2618500	You can do, hoon has the same kind of auto cons feature
2619460	2622940	that knock does, so basically cons is assumed.
2622940	2625540	If you basically make a cell of two hoon twigs,
2625540	2627220	that's a cons.
2627220	2628660	In general, as opposed to LISP,
2628660	2631740	hoon is kind of more pair-oriented and more tuple-oriented.
2631740	2634900	We don't throw in terminators everywhere willy-nilly.
2634900	2637740	That's kind of more appropriate for a typed system, I think.
2638820	2642380	Most twigs are tagged unions, so they have a head,
2642380	2645300	which is a stem, which is a symbol, and a bulb,
2645300	2650300	which is the tail, which is totally dependent on the stem.
2650860	2655700	It's usually a tuple or a list of twigs,
2655700	2658740	and let's see how that works in practice.
2658740	2660460	Basically, there's a regular form.
2660460	2663340	Again, most bulbs are tuples.
2663340	2666460	Some are in-area, and there we do need a terminator.
2666460	2667740	But what we do is we separate,
2667740	2670460	we basically have two regular forms of syntax.
2670460	2672580	One, which sort of looks like an expression,
2672580	2675220	and one which looks like a statement.
2675220	2677820	Those two ifs there are the same code,
2678700	2680740	but they look a little different.
2680740	2683460	What you do is you basically build a structure
2683460	2686620	whose backbone is basically tall twigs,
2686620	2689700	and then a tall twig can contain a flat one,
2689700	2690900	but not vice versa.
2690900	2693660	Basically, you're mimicking the kind of structure
2693660	2695940	of imperative code that has this kind of statement
2695940	2698460	expression duality, but it's all an expression.
2698460	2700380	There's no imperative anything.
2701860	2703340	Another thing that you're doing basically
2703340	2705100	to control the right margin here,
2705100	2707540	what you really want, you'll notice that C
2707540	2710020	is at the same indentation as the if there.
2710020	2713380	So basically, you want to lose no space,
2713380	2715660	basically for your largest,
2715660	2717780	hopefully C is the biggest branch,
2717780	2719020	C is not the biggest branch,
2719020	2721380	you want unless instead of if.
2721380	2724300	But basically, you really, as a programmer,
2724300	2726940	there's sort of an art of arranging these things,
2726940	2730820	and you arrange them so that they flow down and not across.
2730820	2733780	And it becomes very easy to read once you know it,
2733780	2734820	like any language.
2735700	2739020	And here's the funnest and most fancy part
2739020	2740580	of our crazy syntax.
2740580	2742900	So first of all, you've got regular forms
2742900	2743740	and irregular forms.
2743740	2746860	So in a regular form, arbitrary syntax,
2746860	2748860	at least it's always flat,
2748860	2751100	but that's just something you have to learn.
2751100	2754180	One of the things I feel, if you look at the implementation
2754180	2757900	of the Hoon compiler, what you'll see is that basically,
2757900	2760180	the front end is actually as big as the back end,
2760180	2761740	which is really quite unusual.
2762580	2765540	And that's because basically, as a human being,
2765540	2768860	you've got this great hardware for basically parsing.
2768860	2771100	You don't have hardware for type inference.
2771100	2776100	And so what we've done is basically the keyword form
2778220	2780340	that you saw, I remember you saw those two forms
2780340	2783820	of Hoon, one using keywords and one using runes.
2783820	2785780	I'm gonna step forward and show you.
2785780	2788060	Here are two forms of fizzbuzz.
2788060	2789900	On the right you see runes.
2789900	2791580	On the left you see keywords.
2792300	2793580	Stepping back for a second,
2793580	2796100	to make these basically pronounceable,
2796100	2799100	what we've done is taken every ASCII character
2799100	2802780	and given it a single syllable name.
2802780	2806540	So where, if you see like if here,
2806540	2809600	so if is the colon prefixed f there.
2809600	2811460	That's also the symbol that's actually
2811460	2813860	in the physical twig.
2813860	2817260	You can also, as a syntax, you can say question colon.
2817260	2820660	I wouldn't say question colon though, I would say what?
2820700	2822620	Which is a lot faster than the same question colon,
2822620	2824260	not to mention ampersand.
2826300	2830020	So basically everyone who's learned this is like,
2830020	2831020	why doesn't everyone know this
2831020	2833380	and why do I have to say till like my normal friends
2833380	2834420	when I could say sick?
2835340	2837660	So hopefully it'll catch on,
2837660	2840260	if it doesn't catch on at least it's useful in Hoon.
2840260	2844340	So if we go back to this and we look at the right,
2844340	2848180	you would say gate infest atom or you would say
2848180	2850660	park his infest atom for the start of that.
2851860	2854900	Let me give you 20 seconds to just observe
2854900	2856260	the fizz buzzes here.
2856260	2857660	I think that the one on the left
2857660	2859940	should be at least pretty readable.
2868460	2870140	Okay, so that's Hoon.
2870140	2872580	Let's move up on up to Arvo.
2872580	2874500	Now we're at the operating system level.
2875980	2878100	The kernel of Arvo is a Hoon core
2879020	2880580	and this is basically where we get back
2880580	2881860	to our transition function.
2881860	2886860	So this core basically has a very fixed battery structure.
2887100	2889500	You can think of it as basically like a V table
2889500	2892820	with a fixed structure.
2892820	2895900	And the Unix interpreter talks to this core
2895900	2897860	basically at the knock level.
2897860	2900100	In the life cycle function it's defined at the knock level.
2900100	2904220	So you basically just hard code those formula offsets.
2905300	2907580	You can just fix that
2907580	2909820	because you have only a few functions there.
2909820	2912060	So basically this is how you have a system
2912060	2913740	that can completely upgrade itself
2913740	2916340	because again the whole life cycle function
2916340	2918580	is defined entirely in knock.
2919540	2922300	And basically let's say you get an event
2922300	2926220	and that event is actually a source code update
2926220	2927980	in the revision control system
2927980	2929300	that gives you new source code
2929300	2932100	for Hoon the language itself.
2932100	2934580	As long as your new language can build a core
2934580	2937100	that is shaped like the ones that your old language built,
2937100	2938620	you can turn Hoon into anything.
2940820	2943180	So ARBO is actually a very, very simple system.
2943180	2944820	It's only a few hundred lines of code.
2944820	2947780	It probably should be less than 600 actually.
2947780	2951460	What it does is it does sort of an internal event cascade.
2951460	2953780	So you're all familiar with you know,
2953780	2955280	like you get an event from the outside
2955280	2958180	and then you're like this happened internally.
2958180	2962300	Events systems that are very complicated
2962300	2964220	and deep like this one very quickly
2964220	2966780	turn into spaghetti event logic.
2966780	2970060	There's a duality between events and procedure calls
2971060	2976060	in which basically an event is a transfer of control
2976100	2978940	essentially and if you take that duality simply,
2978940	2981880	the dual of a simple event system is go to.
2982780	2985020	So basically when you have, you're like,
2985020	2986620	oh through these events and then it's like
2986620	2988380	the system will go here and it will go there
2988380	2991420	and it was like why are you doing this?
2991420	2993980	So essentially we have what you might call
2993980	2996820	the equivalent of a go sub for anyone
2996820	2999060	no basic in this room, anyone?
2999060	3000220	Wow, that's awesome.
3001780	3003100	I don't feel so old now.
3005580	3009800	So you have essentially the equivalent of subroutines
3009800	3012940	in an event kind of model and you have basically
3012940	3015580	this kind of causal model which I don't wanna get super into
3015580	3017100	but definitely if you're building
3017100	3018580	JavaScript event frameworks I think
3018580	3020180	you could use something like this.
3020180	3021920	It also has a global type referentially
3021960	3026160	transparent namespace so basically use any data
3026160	3028400	in the world as if it was a type constant.
3028400	3030040	That's kind of nice.
3030040	3034000	Most of the work of ARVO is done by what are called
3034000	3036040	veins which are essentially kernel modules
3036040	3038360	and they have essentially the same kind of core-like
3038360	3040880	structure as the ARVO core itself.
3040880	3044120	So these are loaded from source obviously at runtime.
3044120	3047400	Let me just run through a few of the things we do.
3047400	3049280	So encrypted packing networking,
3049280	3050360	we'll talk about that in a sec.
3050360	3053920	Timer is obviously clay which is like a typed git.
3055000	3056800	Console obviously air.
3056800	3059800	We'll see that hopefully driving a demo in a second.
3059800	3061640	A function build system and I don't really know
3061640	3064520	how to describe that and an application engine.
3064520	3067520	And the applications again are cores within Gaul.
3067520	3069440	So you have sort of these kind of multiple levels
3069440	3070720	of virtualization.
3070720	3072200	When you're running user level code
3072200	3074520	you're actually running it in a virtual knock.
3074520	3077640	And that virtual knock has an extra instruction.
3077640	3080120	It has an instruction 11 that de-references
3080120	3082080	the basically global namespace.
3082080	3084520	So you're really like de-referencing the whole world
3084520	3085680	as if it was a constant.
3087120	3090760	Again that due to the way knock works
3090760	3093040	you can basically virtualize at any depth
3093040	3095600	of virtual interpreters without any real cost.
3095600	3097120	Cause you're actually in implementation
3097120	3098120	just setting a flag.
3099760	3102840	All right that's a very, very broad overview of ARVO.
3102840	3105240	Let's go back to the top and basically look
3105240	3108600	at what Erbit is doing at the top level.
3108600	3111760	So we're sort of back to the user level here.
3111760	3113680	There's fortunately nothing else in the stack
3113680	3117520	besides NACUN and ARVO and at the top level
3117520	3119680	what users really see the most in Erbit
3119680	3121360	is the public key infrastructure
3121360	3123200	of kind of the identity model.
3123200	3126800	Basically one Erbit is one event history.
3126800	3128360	It's one state, it's one instance
3128360	3129880	and it has one identity.
3130960	3133160	And you know we basically establish that identity
3133160	3136640	when we're booting the Erbit.
3136640	3138000	What exactly is this identity?
3138040	3138880	What does it mean?
3140240	3143200	So basically again the kind of the great thing
3143200	3144680	about doing things from a clean slate
3144680	3146600	is you really get to think from scratch
3146600	3148480	which is kind of neat.
3148480	3150080	And one thing about networking
3150080	3151880	that is done kind of in a conventional
3151880	3154320	in the internet certainly is you have these two levels
3154320	3157240	of well that could spit our audio.
3158760	3162200	You have these two levels of addressing.
3162200	3164160	So you have IP addressings and you have DNS.
3164160	3165920	And the DNS is human meaningful
3165920	3168120	and IP addresses are routable addresses.
3168120	3170800	So in Erbit this is compressed into one layer.
3170800	3172240	So you actually have one layer
3172240	3175480	which is both a human memorable layer
3175480	3178760	and it's both a routing address and a name.
3178760	3181920	And it's actually your personal identity as well.
3181920	3184080	It's also the base of a path
3184080	3186040	in the global immutable namespace.
3186040	3187840	So there's a problem called Zikos Triangle.
3187840	3190240	Does anyone in the room know Zikos Triangle?
3191400	3194280	We're definitely not in network land here.
3194280	3195480	That's fine.
3195520	3197760	Zikos Triangle basically says there are three things
3197760	3200400	that you want out of an identity system.
3200400	3204760	You want the names to be human meaningful.
3204760	3206080	You want them to be secure
3206080	3208200	and you want them to be decentralized.
3208200	3210640	And you can get only two of those three things.
3210640	3213400	So Facebook, Secure, I hope,
3213400	3216800	human meaningful names definitely decentralized,
3216800	3217640	not at all.
3219480	3224320	BitTorrent, decentralized, yes, human meaningful names, no.
3225240	3228000	And so there's basically a problem there
3228000	3231560	that as an OS guy, what they teach us to do
3231560	3234400	is find the trade off and almost solve the problem.
3234400	3237480	So the trade off that we make here is basically,
3237480	3240840	the trivial solution for an identity system of this scale
3240840	3243000	is basically to say your identity
3243000	3245240	is the hash of your initial public key.
3245240	3248000	Very easy, IPFS uses this, very easy to do.
3249520	3251600	How do you remember a 128-bit hash?
3252720	3253560	You don't.
3254600	3257040	And so what we're looking for is basically a way
3257040	3259720	to make these names that are memorable,
3259720	3260560	but not meaningful.
3260560	3264920	So first trick we do is we basically come up
3264920	3267200	with a new way of representing numbers.
3267200	3268760	Many things like this have been done before,
3268760	3272320	not super original, but we do a phonemic base 256.
3272320	3274280	So if you look at my three numbers there,
3274280	3276600	there's a hexadecimal number in urban syntax,
3276600	3279600	there's an in-hune syntax, there's an IP address.
3279600	3281160	We also have a syntax for that.
3281160	3285160	And then there's 128, 42, 19, 109,
3285160	3286520	versus patent of tarlott.
3286520	3288760	Patent of tarlott is a lot easier to remember.
3288760	3292160	It's kind of like a human name in a foreign language.
3292160	3293840	People actually bond with these names
3293840	3295520	very easily and very quickly.
3295520	3297640	I'm a task-fine part of it, I think of myself.
3297640	3299440	People say task-fine, I turn around.
3300760	3305320	And so of course that's a 32-bit number,
3305320	3307800	which is a lot shorter than a 128-bit number.
3307800	3311120	So how you get from 128 bits to 32
3311120	3312000	is tricky.
3312000	3314320	So you can actually do the 128-bit hash
3314320	3316040	of a public key thing, that's called a comment.
3316040	3318320	Anyone can create their own urban identity.
3318320	3321760	That is a completely non-scarce resource.
3322760	3326120	And it's also, there's just no way
3326120	3329040	of making a 128-bit number memorable.
3329040	3330360	So what you notice is that basically
3330360	3332160	the most valuable real estate in this
3332160	3335280	is down at the bottom of this whole 128-bit space.
3335280	3338840	And in fact, you can overlay a 128-bit hash
3338840	3340720	will never be a 64-bit number.
3340720	3342560	So you can overlay a completely different
3342560	3345840	64-bit identity scheme on the bottom of this.
3345840	3349800	So your 64-bit scheme is distributed hierarchically.
3349800	3352400	It's basically, it's cryptographic property
3352400	3355000	a little bit like Bitcoin, but it doesn't use a blockchain.
3355000	3358360	So the way it works is that a 64-bit chip
3358360	3361600	is the initial key is signed by its 32-bit parent,
3361600	3364080	basically the half width prefix.
3364080	3368040	The 32-bit chip is signed by a 16-bit parent.
3368040	3370200	The 16-bit chip, which is a star,
3370200	3371840	is signed by its 8-bit parent.
3371840	3375160	And the fingerprints of 8-bit galaxies
3375160	3378040	are hard-coded in the kernel source.
3378040	3381280	This is what we call a pre-mind in the Bitcoin world.
3384680	3388880	So basically again, this is a PKI
3388880	3392760	in which revocation and renewal are the same thing.
3392760	3394720	So basically when you wanna change a key,
3394720	3397320	whether that's because you wanna give someone else
3397320	3400320	this identity or you just feel like your key
3400320	3401560	might be a little bit compromised,
3401560	3404120	you basically sign the new key with the old key.
3404120	3405120	Unless you're a moon,
3405120	3407400	moon should not be floating around unaccompanied.
3407400	3408640	You sign your own updates.
3408640	3412160	So basically your parent signs the first key,
3412160	3413080	but you sign the second.
3413080	3415720	So you're genuinely independent here.
3415720	3418840	The main sort of question in that is basically
3418840	3421480	how these updates get distributed.
3421480	3423480	Fortunately, there's a lot fewer of them
3423480	3426600	than sort of the equivalent, which is like a Bitcoin spend.
3426680	3429480	So there's a lot more room for basically
3429480	3433360	just sort of handling it in a kind of less aggressive way
3433360	3435000	than Bitcoin does.
3435000	3436360	But it's the same basic principle.
3436360	3438880	Your identity is definitely cryptographic property.
3438880	3441320	You own it, you can sell it, et cetera.
3441320	3444400	And there's the 32-bit point
3444400	3447000	is clearly kind of the right point for human beings.
3447000	3449400	One of the things about having these 32-bit names
3449400	3452840	as your names is basically like in any situation
3452840	3454880	in which people are actually using this system,
3454880	3455720	some people are using it,
3455720	3458320	but hopefully everyone will be using it.
3458320	3459480	You have a scarcity there.
3459480	3460640	You only have four billion.
3460640	3464280	And so the price of the scarce resource cannot fault a zero.
3464280	3468000	So one of the things about that situation
3468000	3470040	is that the basic problem,
3470040	3471560	one of the reasons why my mother
3471560	3473080	can't run her own internet server
3473080	3475680	is that the internet is basically, you know,
3475680	3476880	a digital mazizly.
3476880	3479620	I mean, it's just all kinds of scum and villainy are out there.
3479620	3481960	And when you get a packet from someone,
3481960	3484880	you have no way of ascertaining the reputation
3484880	3487080	of this IP address.
3487080	3489960	Yes, there are IP address reputation systems in practice.
3489960	3492040	They basically turn off all residential things
3492040	3494180	and don't let them send email.
3494180	3496800	But the ownership of an IP address is not clear.
3496800	3499920	And so you can't really use, an IP address is not property.
3499920	3503180	You can't really use it as a mechanism in this way.
3503180	3504880	When you basically have an address
3504880	3505880	that's a scarce resource,
3505880	3508480	let's say you paid 10 bucks for your planet.
3508480	3511160	Okay, I paid 10 bucks so I wanna be able to compute.
3512160	3513680	Then you're gonna send messages
3513680	3514760	directly from that planet.
3514760	3516200	You're definitely not gonna send them through
3516200	3518640	like Google or some MTU, like, you know.
3519640	3522920	And if you spam, like someone's like,
3522920	3526120	hey, I got a spam from Taskline Partive.
3526120	3527880	And you go on a blacklist like this.
3527880	3530560	And basically your 10 bucks is now worthless
3530560	3532600	because no one will accept anything
3532600	3534000	from that planet anymore.
3534000	3536640	So essentially in order, like your spam better
3536640	3539320	have made you 10 bucks or like, you know,
3539320	3540960	and that's a pretty high bar for spam.
3540960	3543840	And so basically just by having this sort of limited
3544760	3548120	supply of real estate that's treated as digital property,
3548120	3550320	you basically have the basis for building
3550320	3552200	a reputation system that works
3552200	3554680	because the real killer of reputation systems
3554680	3556560	is an infinite supply of identities.
3556560	3558320	Because you have this problem where you're like,
3558320	3559920	I've never seen this identity before.
3559920	3561160	Maybe it's a new user.
3561160	3562240	I really wanna say hi.
3562240	3563880	Maybe it's that spammer I just banned.
3563880	3565200	I really don't wanna say hi.
3565200	3566960	That's kind of an unsolvable problem.
3566960	3570320	And so basically I think this is one of the things like,
3570320	3573320	you know, nobody, a tiny young network like Erbit,
3573320	3574960	nobody abuses.
3574960	3577560	But, you know, in the future, as you grow,
3577560	3578880	basically you become a target.
3578880	3580320	And so having a system like this
3580320	3581680	helps you not be a target.
3583280	3585560	Let's fall back on the point of all this.
3586720	3589240	Inventing new system software is always a bad idea.
3589240	3591120	It's a terrible, terrible thing to do.
3591120	3593240	Never, never, never do this.
3594680	3599680	So let's go back to basically the goal of this project,
3599720	3601080	which is to build a personal server.
3601080	3603360	So a personal server is gonna be a social server.
3603360	3605120	So if you have a real personal server
3605120	3606520	that's a real social server,
3606520	3608240	when I socialize with you,
3608240	3609160	in the one nearer case,
3609160	3611080	barring like weird identity games,
3611080	3613360	I shouldn't be sending packets directly to you.
3613360	3615600	I shouldn't be sending packets to some Facebook thing
3615600	3617080	over there that then sends them to you.
3617080	3619960	I should be able to basically actually socialize
3619960	3622640	in a distributed way using distributed protocols.
3622640	3625960	And one of the things about the way we compute today,
3625960	3629000	and the reason basically we don't do this,
3629040	3630560	is that if you look at the difficulty
3630560	3632040	of distributed programming,
3632040	3634080	let's say you're building like a tic-tac-toe app,
3634080	3636560	compare the difficulty of building distributed tic-tac-toe
3636560	3639000	with the difficulty of building centralized tic-tac-toe.
3639000	3641440	Centralized tic-tac-toe, my score,
3641440	3642400	your score, they're variables.
3642400	3644280	They're in the same data structure.
3644280	3645120	It's easy.
3645120	3647240	Then suddenly you're building distributed tic-tac-toe
3647240	3649760	and you're like have to apply to the ITF for an RFC
3649760	3651960	for your TTTTP, right?
3651960	3655920	And it's just like six orders of magnitude different
3655920	3657080	in difficulty.
3657080	3659040	And if you wanna ask why we don't have
3659040	3660480	a decentralized internet,
3660480	3663160	basically the reason we don't have a decentralized internet
3663160	3666600	is that decentralized programming is too damn hard.
3666600	3668560	So basically you need to solve this problem
3668560	3672080	if you're gonna build anything like a true personal server.
3672080	3673680	So let me talk a little bit about
3673680	3675360	the kind of programming or experience
3675360	3677400	of where we're aiming to get with this.
3677400	3679200	This is actually my next last slide.
3680400	3681840	So let's see, first of all,
3681840	3682960	you're programming in the system.
3682960	3685120	You can dereference a global immutable namespace.
3685120	3687040	So basically use any data in the world
3687040	3688760	as if it was a typed constant.
3688760	3690280	That's kinda nice.
3690280	3691760	Your application state is permanent.
3691760	3695080	You don't need a database to basically flush stuff out too
3695080	3698560	when for your data actually exist.
3700000	3701280	When you do an update,
3701280	3703440	your updates basically come through reactively
3703440	3706600	through the, you have basically a revision control system
3706600	3708720	that's clay or I didn't talk much about that,
3708720	3712160	but it's basically a revision control system with hooks.
3712160	3715100	And so you're like, oh, I got a source code update
3715100	3716080	for this thing I'm running.
3716120	3719040	And then I'm like, oh, I need to change out the code.
3719040	3721200	Oh, gee, the type of my data change.
3721200	3724280	So I need to have a type adapter in there
3724280	3726440	to make that work.
3726440	3727720	That all works great.
3728680	3731380	A very different experience from kind of updates
3731380	3733440	or upgrades in a lot of systems.
3734960	3737880	When you get to messaging patterns, basically,
3737880	3741160	you've got a poke, which is a forward, basically,
3741160	3743840	essentially an RTC without a return.
3743840	3745880	And you've got a subscription model.
3745880	3748360	Let's look at basically what we get with pokes
3748360	3749720	for a moment.
3749720	3752080	Number one, you get exactly once delivery.
3752080	3755160	You've probably heard that exactly once delivery is impossible.
3755160	3758200	It was a great blog post about that a few months ago.
3758200	3760160	Exactly once delivery and message semantics
3760160	3763080	actually is possible if all of your entities
3763080	3764400	are single level stores.
3764400	3767120	And if they can basically run permanent sessions.
3767120	3769120	So you have a permanent session and you're like,
3769120	3772880	oh, I expect message seven from you.
3772880	3775720	Well, you're only gonna get message seven once.
3775720	3777520	Where that breaks down in this kind of system
3777520	3779080	where you have transient and permanent state
3779080	3781480	is you reboot the computer and then you're like,
3781480	3783480	do I expect message seven or message six?
3783480	3788480	Or you have these idempotence problems.
3788520	3790620	So every message is a transaction
3790620	3793440	in this kind of distributed programming environment.
3793440	3796240	If the transaction succeeds, there's no return data.
3796240	3798480	So it's a one way transaction.
3798480	3800320	Your messages are automatically type checked
3800320	3802580	and validated on the receiving side.
3802580	3805120	You can even do basically protocol type updates
3805120	3808200	on the live network and not propagate errors to the user.
3810400	3813280	The data that you get over the wire is passed to you typed.
3813280	3814920	You basically just get it as an argument
3814920	3816620	and it's a typed value.
3817760	3819480	We do end-to-end acknowledgments,
3819480	3821600	which basically means there's kind of a single error mode.
3821600	3823320	So when you're doing acknowledgments,
3823320	3827000	like think about you're doing a normal RPC or HTTP.
3827000	3827840	Something goes wrong.
3827840	3828840	Well, what could go wrong?
3828840	3830300	Your socket could break.
3830300	3832100	You could get an HTTP error.
3832100	3834880	You could get an error at the RPC layer.
3834880	3836400	What do you even do with half of these things?
3836400	3839360	Like there are different kinds of error.
3839360	3842400	And that basically is just very, very difficult to handle.
3842400	3844160	So if you're basically doing acknowledgments
3844160	3845760	at an end-to-end level,
3845760	3848640	that means the packet level act that you send back
3848640	3852560	is actually the transaction acknowledgement
3852560	3854040	that you succeeded or failed.
3855360	3857120	Messages are queued by the sender.
3857120	3859920	Obviously, this is a P2P network.
3859920	3863800	It traverses NAT and of course it's authenticated
3863840	3865080	and encrypted.
3865080	3867720	Your subscriptions are sending diffs.
3867720	3869520	Those again are typed.
3869520	3873440	So this is a very different distributed programming experience
3873440	3878440	than your sort of normal, I'm writing this in node experience.
3879080	3881720	And our experience is basically it's,
3881720	3885000	you just do things and they pretty much just work.
3885000	3887080	What is the status of this system?
3887080	3890160	It's about 30,000 lines of Coon, including basic apps.
3890160	3891640	It's totally open source.
3891640	3893480	You can go to urban.org.
3893480	3896080	And which is served by Arbit, although we cash it.
3897600	3902520	And yeah, I mean, it essentially works.
3902520	3904080	We were on occasional global flag days,
3904080	3906880	so you might not want to move your business onto this system.
3909080	3913480	But yeah, I mean, when creating a system like this,
3913480	3915920	involves a lot of rewriting stuff over and over again
3915920	3917440	until it actually works right.
3918320	3922000	And we're basically getting to the end of that process
3922000	3924920	and we're kind of close to being ready to sell
3924920	3926400	some address space to the public.
3926400	3930120	Let me do a quick demo of this system
3930120	3933320	to see if it's actually working.
3933320	3935680	I'm actually doing this over my,
3937440	3939360	so here is, you're in Arbit.
3941400	3942880	Live, yes, we're live.
3942880	3945440	That bounced off the server and came back.
3945440	3949240	So that's basically a simple console talk app.
3950240	3955440	Hello from, a little bit slow on the typing there.
3955440	3957840	Our console path is pretty complicated
3957840	3959840	and we could use some serious optimization.
3959840	3963440	Let me see if I can bring up the web UI of talk.
3963440	3965720	Ah, yes, here is a web app.
3968080	3970240	Let me get it fully up.
3972040	3973360	Looks like it needs a reload,
3973360	3974920	which it actually should not.
3976400	3978320	Hate it when that happens.
3978320	3982360	But here, basically, you're seeing a web UI.
3982360	3983200	Do you want to say something?
3983200	3984560	Anyone want to say something?
3984560	3986800	I'll just be, hello from William the Comfort Inn.
3992200	3994040	Boulder is beautiful.
3994040	3999040	So, beautiful with an extra K.
4000600	4003960	And this has to bounce off the server to get back.
4003960	4007240	Actually, the Colorado's router
4007280	4012280	seems to be blocking my transition directly.
4013520	4017080	But, you know, I'm doing it via Verizon, so it works fine.
4017080	4019880	TaskFind Partive is actually running on this laptop here.
4021960	4023800	Yeah, so that was a very simple demo
4023800	4025560	and now, any questions?
4025560	4026400	Yes.
4026400	4028760	So, does Richard Stallman know about this?
4028760	4029600	I don't think so.
4029600	4033160	Because I don't think this would really get
4033160	4035440	to what Richard Stallman would like to see.
4035440	4037640	Yeah, I think there's a lot of people
4037640	4040360	who are tired of this sort of Facebook-ization
4040360	4041520	of the internet.
4041520	4044800	And this is definitely also, I mean, yeah,
4044800	4045640	is this a list?
4045640	4047240	Is this basically E-Max?
4047240	4049680	At a certain level, it's basically E-Max.
4049680	4053920	So, yeah, you know, all right,
4053920	4055640	we're at a one-minute warning here.
4055640	4057800	Time for maybe one or two more questions.
4059400	4060360	Be over?
4060360	4061440	Yes?
4061440	4063640	So, I feel like maybe you're trying to
4063640	4066440	talk to me confusing, like, do you use the word twig,
4066440	4068280	but like, I'll be referred to as a nasty?
4068280	4069120	Mm-hmm.
4069120	4070160	Is there a particular reason for, like,
4070160	4071920	these more or less travel elements?
4072920	4075400	Yeah, I mean, the reason is basically you're,
4076320	4079840	you want to use the word that the actual source code uses.
4079840	4081800	Is the reason for that being the convention
4081800	4083720	and the source code, is that a good reason?
4083720	4085360	Maybe not necessarily.
4085360	4086880	It certainly makes things kind of tire
4086880	4088200	and more readable in a way.
4088200	4090560	There's an aesthetic, which kind of,
4090560	4092040	there's an aesthetic of short names,
4092040	4094480	which works fairly well in kind of a functional environment,
4094480	4097160	which wouldn't work in an imperative environment.
4097160	4099720	But, yeah, I mean, you know, the criticism
4099720	4101120	that this is a little more obfuscated
4101120	4102240	than it has to be, is certainly one
4102240	4104240	that I think holds a little bit of water.
4106280	4108160	So, when you chat with the one message
4108160	4109760	and so there's a browser,
4109760	4113920	how do you go through the centralized events?
4113920	4117800	So, that is basically, that, if you saw,
4117800	4119920	if I turn on debugging, here,
4120920	4125920	turn on debugging, and you'll see a lot of...
4129560	4132320	Okay, so what's actually happening is that packet,
4132320	4135400	so I'm logged into, I could log in via
4135400	4137120	taskfinepartive.erb.org, here,
4137120	4138840	let me turn this off, this is horrible.
4139840	4144280	And I could log in via taskfinepartive.erb.org
4144280	4146880	and be proxied by basically the star
4146960	4151960	that is, taskfinepartive is a planet of.
4151960	4153600	But, basically, I'm in a channel,
4153600	4155240	that channel is hosted on DOSNEC,
4155240	4158640	which is the star that I'm responsible to.
4158640	4161920	And so, basically, that packet is going up to DOSNEC,
4161920	4163600	coming back to me, and then it's going
4163600	4166000	over localhost8080 to the browser.
4168200	4169880	All right, any more questions?
4169880	4171560	I think we're time.
4172560	4173560	Thank you.
4173560	4174560	Thank you.
4174560	4175560	Thank you.
4175560	4176560	Thank you.
