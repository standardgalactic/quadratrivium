WEBVTT

00:00.000 --> 00:03.120
So I'm going to be talking about this interesting little system,

00:03.120 --> 00:05.840
Erbit, that I and some friends have built.

00:05.840 --> 00:10.000
Erbit is a clean slate full stack system.

00:10.000 --> 00:13.360
So let me explain sort of briefly the problem that we're

00:13.360 --> 00:16.560
solving here first, because this is a little different

00:16.560 --> 00:21.080
from the problem that a usual language is solving.

00:21.080 --> 00:24.200
So we have basically a coupling of kind of two interesting

00:24.200 --> 00:24.840
problems here.

00:24.840 --> 00:28.240
We have a very different kind of technical problem that we're

00:28.240 --> 00:31.680
solving, and we also have a different human market need

00:31.680 --> 00:33.120
that we're solving.

00:33.120 --> 00:35.160
So let me go through both of those super quickly.

00:35.160 --> 00:38.480
So the technical problem we're trying to solve here is

00:38.480 --> 00:41.040
something I call a high level deterministic computer.

00:41.040 --> 00:44.360
So that would be basically a computer whose entire life

00:44.360 --> 00:47.080
cycle is defined by a single frozen function.

00:47.080 --> 00:49.400
So it's really very functional.

00:49.400 --> 00:53.640
Of course, a hardware VM, a CPU, is defined by a single

00:53.640 --> 00:55.920
frozen function, which is the CPU function, which is very

00:55.960 --> 00:58.680
frozen because it's on the chip.

00:58.680 --> 01:02.600
But we'd actually like to define that at a layer at the same

01:02.600 --> 01:05.960
level at which the programmer conceives the system.

01:05.960 --> 01:09.360
So if we look at some kind of approximations to this that

01:09.360 --> 01:13.600
exist in reality today, JavaScript and the Java VM, of

01:13.600 --> 01:19.320
course, are high level definitions, but they're

01:19.320 --> 01:22.040
defined only sort of for a transient system.

01:22.040 --> 01:24.600
So here we're defining the whole life cycle of the

01:24.600 --> 01:25.320
computer.

01:25.320 --> 01:26.640
This is not just a memory image.

01:26.640 --> 01:30.040
This is the whole machine, which is a single level store.

01:30.040 --> 01:33.000
Lisp and small talk have these image-based systems that

01:33.000 --> 01:36.120
come a little closer to this kind of approach.

01:36.120 --> 01:38.280
I don't think people in practice usually use Lisp and

01:38.280 --> 01:40.400
small talk actually as databases.

01:40.400 --> 01:44.960
And they're not defined functionally in the same way.

01:44.960 --> 01:49.800
But it's definitely in the image-based system tradition.

01:49.800 --> 01:51.840
When you're using this thing, it basically feels like an

01:51.840 --> 01:54.560
integrated interpreter OS and database, which is a very

01:54.720 --> 01:58.760
kind of unusual feeling for a programming environment.

01:58.760 --> 02:00.960
You might also ask what happens when a determinist to

02:00.960 --> 02:03.240
computer hits an undecidable problem.

02:03.240 --> 02:06.360
We'll get into that in a little bit.

02:06.360 --> 02:10.800
One way of sort of defining this problem that I like to use

02:10.800 --> 02:13.960
is an unusual versioning system that we use, which I

02:13.960 --> 02:15.000
call Kelvin versioning.

02:15.000 --> 02:18.240
So Kelvin versioning, you count down to absolute zero and

02:18.240 --> 02:19.600
you count by integers.

02:19.600 --> 02:22.360
So if you run out of numbers, you've made a mistake,

02:22.360 --> 02:22.880
basically.

02:22.880 --> 02:25.640
So absolute zero is absolutely frozen.

02:25.640 --> 02:28.680
So Erbit, or at least the sort of the formal definition of

02:28.680 --> 02:31.760
Erbit, which does fit on a t-shirt, is at five Kelvin,

02:31.760 --> 02:34.640
which is like liquid helium, basically at the moment.

02:34.640 --> 02:37.680
And we'll see that spec in a little bit.

02:37.680 --> 02:41.080
Let's switch gears totally and talk about the human need that

02:41.080 --> 02:43.280
this system is supposed to be solving.

02:43.280 --> 02:45.840
We have this little problem in the computer world, which is

02:45.840 --> 02:48.240
that the internet actually failed.

02:48.240 --> 02:50.360
It succeeded very well as a digital modem.

02:50.360 --> 02:52.480
It's a great digital modem.

02:52.520 --> 02:54.560
It's entirely a client-server environment.

02:54.560 --> 02:56.200
It is not a peer-to-peer network.

02:56.200 --> 02:58.920
It's never going to be a peer-to-peer network.

02:58.920 --> 03:01.400
And if you look at sort of the dream of the internet from

03:01.400 --> 03:05.760
the 80s and 90s, it was a dream in which everyone on this

03:05.760 --> 03:07.880
network would have their own server.

03:07.880 --> 03:11.080
And things like what we do on Facebook today would be done

03:11.080 --> 03:13.320
by protocols like SMTP.

03:13.320 --> 03:16.000
Well, you can't introduce a new wide area protocol on the

03:16.000 --> 03:16.640
internet today.

03:16.640 --> 03:20.240
You can barely keep SMTP alive.

03:20.280 --> 03:22.560
These systems were designed in the 70s.

03:22.560 --> 03:25.480
The same thing for basically Linux, which is, in a sense,

03:25.480 --> 03:27.360
I would say, layer seven of the internet.

03:27.360 --> 03:29.280
It's the application layer.

03:29.280 --> 03:31.320
If you're on the internet, you're either a Unix box or

03:31.320 --> 03:33.400
you're pretending to be a Unix box.

03:33.400 --> 03:37.360
You can't really say to my mother, hey, you should go out

03:37.360 --> 03:40.440
and get an AWS box and put all your data on that and app

03:40.440 --> 03:44.000
get installed, something.

03:44.000 --> 03:46.040
That's just never basically going to fly.

03:46.040 --> 03:49.720
And so we've kind of reconciled ourselves to those

03:49.720 --> 03:52.600
sort of loss of this dream where people actually control

03:52.600 --> 03:54.000
their own individual computing.

03:54.000 --> 03:58.960
And instead, we've basically gone back and recreated the

03:58.960 --> 04:01.120
Hayes modem protocol with HTTP.

04:01.120 --> 04:04.400
And we've recreated AOL with Facebook.

04:04.400 --> 04:06.920
And we're kind of stuck in this space.

04:06.920 --> 04:08.760
So we have a big problem here.

04:08.760 --> 04:11.560
And these systems aren't basically not fixable.

04:11.560 --> 04:14.360
Well, there's a way to get out of a problem that isn't

04:14.360 --> 04:16.080
fixable, which is to layer over it.

04:16.080 --> 04:18.760
So the browser already did this on the client side.

04:18.800 --> 04:21.040
Basically, you had these OS APIs.

04:21.040 --> 04:23.360
And they're like, OK, we're going to build a new

04:23.360 --> 04:24.600
application layer.

04:24.600 --> 04:27.160
I guess browser people didn't realize that this is what

04:27.160 --> 04:27.640
they were doing.

04:27.640 --> 04:29.120
But it's certainly what they were doing.

04:29.120 --> 04:31.040
We're going to build a new programming layer that is

04:31.040 --> 04:34.360
isolated from the substrate under it that cannot call out

04:34.360 --> 04:36.040
in any way, shape, or form.

04:36.040 --> 04:38.720
And we're just going to program to that layer and not care

04:38.720 --> 04:40.840
about the underlying OS.

04:40.840 --> 04:43.120
And that actually kind of worked great.

04:43.120 --> 04:45.240
So on the server side, basically, this

04:45.240 --> 04:47.240
hasn't been done yet.

04:47.240 --> 04:50.160
And I would say, basically, we don't know that people don't

04:50.160 --> 04:51.280
want personal servers.

04:51.280 --> 04:54.360
People ask them, you tell them what a personal server is.

04:54.360 --> 04:56.160
And they say, yes, I want that.

04:56.160 --> 04:58.640
We do know that they don't want Linux and internet

04:58.640 --> 04:59.400
personal servers.

04:59.400 --> 05:02.160
We do know that my mother is never going to run an open

05:02.160 --> 05:03.760
Linux server on the internet.

05:03.760 --> 05:07.720
So there's basically a real case to be made for saying, OK,

05:07.720 --> 05:09.880
we need a new layer here.

05:09.880 --> 05:13.120
If we sort of drill down a little bit and define the need,

05:13.120 --> 05:17.120
the need is basically caused by the, essentially, the

05:17.120 --> 05:19.560
obstacle to the universal personal server is just

05:19.560 --> 05:20.440
administrative cost.

05:20.440 --> 05:22.320
My mother is not a Linux is that thing.

05:22.320 --> 05:25.320
So when you're looking at a problem and your problem is

05:25.320 --> 05:28.440
administrative cost, it makes sense that a solution to this

05:28.440 --> 05:30.160
problem is going to be technical simplicity.

05:30.160 --> 05:32.920
Because basically, the difficulty of administering

05:32.920 --> 05:35.640
the system tends to be roughly proportional to the number of

05:35.640 --> 05:36.840
lines of code in it.

05:36.840 --> 05:38.720
And if you haven't noticed, there's a lot of lines of

05:38.720 --> 05:40.800
code in Ubuntu.

05:40.800 --> 05:45.120
And so basically, the idea of building the browser for the

05:45.120 --> 05:48.400
server side is sort of a problem that kind of makes sense

05:48.400 --> 05:50.640
next to this problem of let's build a high-level

05:50.640 --> 05:53.200
deterministic computer.

05:53.200 --> 05:55.640
So OK, let's build it.

05:55.640 --> 05:57.840
How do you define a one-function computer?

05:57.840 --> 06:00.800
Well, you need, remember, we're defining both the network

06:00.800 --> 06:01.560
and the OS here.

06:01.560 --> 06:04.760
We're really defining a computing environment as if we

06:04.760 --> 06:07.400
just stumbled on a planet that had chips and wires and no

06:07.400 --> 06:10.600
software whatsoever, which is kind of fun.

06:10.600 --> 06:13.560
And if you're going to define the way this works, you're

06:13.560 --> 06:15.520
defining networking from scratch.

06:15.520 --> 06:17.960
I find the simplest way to think about networking is to

06:17.960 --> 06:20.280
imagine just basically a global party line.

06:20.280 --> 06:23.600
So a packet is just a big integer blob that people put

06:23.600 --> 06:24.200
out.

06:24.200 --> 06:26.040
Everybody hears everyone else's packets.

06:26.040 --> 06:28.680
And if you have the keys to decrypt those packets and make

06:28.680 --> 06:30.960
them make sense, then you use them.

06:30.960 --> 06:34.240
Then you can basically say to this global party line, hey,

06:34.240 --> 06:36.600
we would like to actually optimize this.

06:36.600 --> 06:38.600
And you get back to routing.

06:38.600 --> 06:42.520
But routing is basically an optimization in Van Jacobsen

06:42.520 --> 06:46.000
has this great term, a content-centric network, where

06:46.000 --> 06:49.080
you're basically ignoring who sent you the packet doesn't

06:49.080 --> 06:49.400
matter.

06:49.400 --> 06:51.200
What matters is what's in the packet.

06:51.200 --> 06:56.320
So that's sort of the network perspective on this.

06:56.320 --> 06:59.520
From the sort of functional perspective, there's basically

06:59.520 --> 07:02.040
two ways to define a one-function computer.

07:02.040 --> 07:04.440
You can define it as a life cycle function, which is

07:04.440 --> 07:07.880
where the state is a pure function of input history.

07:07.880 --> 07:09.320
And remember, this is a frozen function.

07:09.320 --> 07:10.680
This never changes.

07:10.680 --> 07:12.640
You cannot upgrade this function.

07:12.640 --> 07:14.680
Or you can define it as a transition function, where

07:14.680 --> 07:17.280
basically you have an input event in an old state,

07:17.280 --> 07:20.520
outcomes, a bunch of output actions in a new state.

07:20.520 --> 07:23.360
These are really, in practice, basically turned into the

07:23.360 --> 07:23.880
same thing.

07:23.880 --> 07:27.520
In practice, essentially any life cycle function is going

07:27.520 --> 07:29.720
to wind up spending most of its time as a transition

07:29.720 --> 07:32.360
function, because you're certainly not going to

07:32.360 --> 07:36.320
recompute the whole log every time you get a packet.

07:36.320 --> 07:38.360
And one of the advantages of doing it the life cycle

07:38.360 --> 07:41.520
function way is when you're basically building a system

07:41.520 --> 07:43.800
where you have one frozen function which defines the

07:43.800 --> 07:47.080
semantics of every computer in the world, you need to

07:47.080 --> 07:48.440
basically break symmetry.

07:48.440 --> 07:51.040
And you need to basically, when you're starting that up, you

07:51.040 --> 07:52.360
need some startup packets.

07:52.360 --> 07:53.400
You need some startup.

07:53.400 --> 07:55.440
You need the load and operating system into your

07:55.440 --> 07:57.200
function, essentially.

07:57.200 --> 07:59.880
And so a life cycle function makes slightly more sense as a

07:59.880 --> 08:01.880
way to define this.

08:01.880 --> 08:05.080
Let me skip down for a second and talk about how you

08:05.080 --> 08:05.880
implement these things.

08:05.880 --> 08:10.320
Actually, implementing a sort of one function computer like

08:10.320 --> 08:12.720
this is kind of very easy with the kind of substrates that

08:12.720 --> 08:14.280
you have at the moment.

08:14.280 --> 08:17.480
Event sourcing is basically this pattern.

08:17.480 --> 08:20.080
It's usually not used for a general purpose computer, but

08:20.080 --> 08:22.080
it's the same pattern.

08:22.080 --> 08:28.000
You have low latency reliable logs are uniformly available.

08:28.000 --> 08:31.000
Kafka isn't the greatest thing in the world, but it works fine.

08:31.000 --> 08:33.760
Normal databases are defined in terms of the pend only

08:33.760 --> 08:38.280
transaction log and an image snapshot.

08:38.280 --> 08:41.520
So you're basically building this the same way a normal

08:41.520 --> 08:42.760
database is built.

08:42.760 --> 08:45.960
You're saying every packet is a transaction.

08:45.960 --> 08:47.320
And it basically works great.

08:47.320 --> 08:50.000
You can also do non-packet I.O. I mean, I like to think of an

08:50.000 --> 08:54.040
abstract computer as just packets in, packets out.

08:54.040 --> 08:58.000
But as you'll see, we want to serve web pages and so forth.

08:58.000 --> 09:03.600
So basically, you can model even ordinary HDDB requests

09:04.440 --> 09:06.480
as here's an event that's like you got a request.

09:06.480 --> 09:08.600
Here's my action respond to this request.

09:08.600 --> 09:12.600
So there's a great library LibUV, which is used by Node.js

09:12.600 --> 09:14.800
that implements these patterns very nicely.

09:14.800 --> 09:16.520
So it's super easy to do.

09:16.520 --> 09:18.120
I mentioned decidability earlier.

09:18.120 --> 09:20.120
That's kind of an interesting problem for a deterministic

09:20.120 --> 09:23.160
computer or any kind of non-preemptive OS.

09:23.160 --> 09:25.440
When you're building a non-preemptive system, basically

09:25.440 --> 09:28.640
the decision of when to terminate a computation is

09:28.640 --> 09:31.360
essentially a heuristic choice.

09:31.840 --> 09:34.400
If that event is caused by a console, that heuristic choice

09:34.400 --> 09:35.240
is very easy.

09:35.240 --> 09:37.720
Just go until they hit Control C.

09:37.720 --> 09:39.360
If it's a packet, that's a little harder.

09:39.360 --> 09:41.240
You need to decide when to time that out.

09:41.240 --> 09:44.600
There's a kind of nice duality between unreliable packet

09:44.600 --> 09:46.600
networking and turn completeness.

09:46.600 --> 09:48.760
And when you drop a packet because it's

09:48.760 --> 09:52.600
spending too long, you're essentially detecting congestion

09:52.600 --> 09:54.600
in the CPU.

09:54.600 --> 09:57.600
And so that kind of makes a certain amount of sense.

09:57.600 --> 10:00.040
Node.js has shown that you can actually do very useful

10:00.040 --> 10:01.880
things with non-preemptive systems.

10:01.880 --> 10:04.080
One of the most interesting problems in building a system

10:04.080 --> 10:05.960
like this is you're going to have certain kinds of

10:05.960 --> 10:07.800
non-determinism that you can't avoid.

10:07.800 --> 10:09.040
Let's say I write an infinite loop.

10:09.040 --> 10:09.720
I made a mistake.

10:09.720 --> 10:10.600
I wrote an infinite loop.

10:10.600 --> 10:12.920
I pressed Control C. One thing I really want there is a

10:12.920 --> 10:13.920
stack trace.

10:13.920 --> 10:15.480
So that stack trace is completely

10:15.480 --> 10:16.960
non-deterministic information.

10:16.960 --> 10:20.440
You can't get that into a deterministic way.

10:20.440 --> 10:25.000
But all is not lost because basically the underlying C

10:25.000 --> 10:27.880
code that actually implements this system sees that stack

10:27.880 --> 10:29.400
trace, has that stack trace.

10:29.400 --> 10:32.040
All it needs to do is basically inject that back in as a

10:32.040 --> 10:33.400
deterministic event.

10:33.400 --> 10:36.040
And so basically, you get an event that says, hey, I was

10:36.040 --> 10:37.760
trying to do this packet, but it crashed.

10:37.760 --> 10:38.640
And here's where it crashed.

10:38.640 --> 10:40.840
And then you can write that to the user in the appropriate

10:40.840 --> 10:42.680
way, and that actually works.

10:42.680 --> 10:47.560
So if you replay that log, we've replayed 30 gigabyte logs

10:47.560 --> 10:50.400
and wound up for the same bit for bit state.

10:50.400 --> 10:53.200
If you replay that log, it will replay the error.

10:53.200 --> 10:54.520
Essentially, it won't even bother with their

10:54.520 --> 10:55.520
original transaction.

10:55.520 --> 10:57.800
So this is not pieing the sky.

10:57.800 --> 10:59.320
This is a working system.

10:59.320 --> 11:02.400
This is clearly doable.

11:02.400 --> 11:06.400
So probably a lot of Lisp fans in the audience, let's try

11:06.400 --> 11:08.040
doing this in Lisp.

11:08.040 --> 11:10.960
So it's actually easy to define a life cycle function in

11:10.960 --> 11:11.600
Lisp.

11:11.600 --> 11:16.080
You simply say, OK, the first event in the log is my

11:16.080 --> 11:17.280
operating system.

11:17.280 --> 11:20.880
And all the rest of the log, the cutter of the log, is the

11:20.880 --> 11:21.560
rest of the event.

11:21.560 --> 11:24.000
So run the operating system on the rest of the events.

11:24.000 --> 11:25.280
You still have to write the function.

11:25.280 --> 11:27.960
But OK, you've made progress.

11:27.960 --> 11:29.680
And now, all we need is the one true Lisp.

11:32.480 --> 11:37.200
So I think all Lisp needs is the one true Lisp.

11:37.200 --> 11:38.760
There have been a lot of attempts to create the one

11:38.760 --> 11:39.720
true Lisp.

11:39.720 --> 11:41.960
I haven't really worked out.

11:41.960 --> 11:44.640
In my view, that's basically a problem that goes back to

11:44.640 --> 11:48.600
really the root of how we came up with this idea of

11:48.600 --> 11:49.240
computing.

11:49.240 --> 11:53.480
Because the Lambda Calculus is OK.

11:53.480 --> 11:54.280
We're at LambdaConf.

11:54.280 --> 11:55.960
I can't say bad things about Lambda Calculus.

11:55.960 --> 11:58.920
But it was originally designed not as a means of

11:58.920 --> 11:59.400
programming.

11:59.400 --> 12:01.320
It was originally designed as basically a

12:01.320 --> 12:02.880
metamathematical tool.

12:02.880 --> 12:05.160
And people picked this up, and they found, hey, wow, this

12:05.160 --> 12:07.560
thing that Church came up with actually works really well

12:07.560 --> 12:08.440
for programming.

12:08.440 --> 12:10.560
So you take that in one direction, and it becomes Lisp.

12:10.560 --> 12:12.160
You take that in another direction, much more

12:12.160 --> 12:14.840
mathematical, and it becomes Haskell.

12:14.840 --> 12:17.640
And it's not like Lisp and Haskell are compatible in

12:17.640 --> 12:18.120
any ways.

12:18.120 --> 12:20.560
You're always basically taking Lambda, and you're growing

12:20.560 --> 12:23.640
hair on it to make it a practical system.

12:23.680 --> 12:26.840
And I would say that that comes from basically a very

12:26.840 --> 12:31.600
deep conflict in the heart of Lambda, which is that it has

12:31.600 --> 12:34.440
these features that are like symbols and variables and

12:34.440 --> 12:38.120
scope that are features of a higher level language.

12:38.120 --> 12:41.040
But if you want to use that as an axiomatic system, and we

12:41.040 --> 12:44.040
just saw a talk on Shen which compiles to Lisp, if you want

12:44.040 --> 12:47.240
to use that as an axiomatic system, basically, and put

12:47.240 --> 12:50.000
the higher level language as something that is actually

12:50.000 --> 12:53.280
loaded onto that axiomatic interpreter, then those things

12:53.280 --> 12:54.040
are in the wrong place.

12:54.040 --> 12:55.400
They're in the wrong layer.

12:55.400 --> 12:58.040
And if you're going to build an axiomatic system like this,

12:58.040 --> 13:00.440
you have just the demands on the precision of your

13:00.440 --> 13:02.280
interpreter are just extremely high.

13:02.280 --> 13:05.160
You want that to be just tiny and diamond perfect.

13:05.160 --> 13:06.920
And you can't grow hair on it.

13:06.920 --> 13:10.600
So in a way, basically, you sort of have no choice but to

13:10.600 --> 13:13.520
invent a kind of different computational model at the

13:13.520 --> 13:15.280
bottom end.

13:15.280 --> 13:20.880
So this gives me a motivation to actually invent all this

13:20.880 --> 13:22.520
crap.

13:22.520 --> 13:24.480
We know that you should never invent anything, but

13:24.480 --> 13:26.160
sometimes you have no choice.

13:26.160 --> 13:29.760
So the bottom of the stack is this thing called knock.

13:29.760 --> 13:32.320
It's a typeless, frozen, accommodator, interpreter,

13:32.320 --> 13:33.280
non-LAMDA.

13:33.280 --> 13:34.560
It's defined in 200 words.

13:34.560 --> 13:36.760
It fits on a t-shirt.

13:36.760 --> 13:40.240
Not wearing a t-shirt today, but I'll wear it tomorrow.

13:40.240 --> 13:44.120
And I know, I know, it's bad choice.

13:44.120 --> 13:46.680
On top of that is a hoon, which is a pure, strict type

13:46.680 --> 13:47.960
functional language.

13:47.960 --> 13:49.880
It compiles itself to knock.

13:49.880 --> 13:52.080
This is type functional programming without category

13:52.080 --> 13:53.440
theory.

13:53.440 --> 13:55.280
We've heard from some people that they hate category

13:55.280 --> 13:56.160
theory.

13:56.160 --> 13:57.400
I've heard that somewhere, not sure.

13:57.400 --> 13:58.760
Probably not in this room.

14:01.480 --> 14:04.280
So you can see how if you have a compiler that compiles

14:04.280 --> 14:07.800
itself to knock, then you can kind of bootstrap off of

14:07.800 --> 14:10.200
this basic, essentially, bootloader.

14:10.200 --> 14:14.120
On top of that, we have ARVO, which is a non-preemptive OS.

14:14.120 --> 14:15.600
And yeah, we'll see.

14:15.600 --> 14:17.720
So basically, what I've got to do here is just a really

14:17.760 --> 14:20.920
lightning tour through these three systems.

14:20.920 --> 14:22.800
Don't worry if there's, there might be a little bit of

14:22.800 --> 14:25.720
stuff you don't understand, but just kind of sit back and

14:25.720 --> 14:27.200
get an impression of the system.

14:27.200 --> 14:29.880
All right, let's go into knock for a second.

14:29.880 --> 14:32.320
So I sometimes call knock a functional assembly language.

14:32.320 --> 14:34.720
You can program in knock, but there are no symbols or

14:34.720 --> 14:36.720
anything, so you're typing numbers and doing tree

14:36.720 --> 14:38.400
geometry by hand.

14:38.400 --> 14:40.040
Very much like writing assembly language.

14:40.040 --> 14:41.960
You could, but you wouldn't want to.

14:41.960 --> 14:43.920
It's basically, it is a list, in a sense.

14:43.920 --> 14:46.400
It's a list without any of these high level tools.

14:46.400 --> 14:48.040
How do you get symbols out of a lisp?

14:48.040 --> 14:49.600
Well, maybe it's not a lisp.

14:52.200 --> 14:55.240
A key point, no cyclic data structures, no laziness, so

14:55.240 --> 14:56.600
no infinite data structures.

14:56.600 --> 14:58.640
You cannot knock as an interpreter, which cannot

14:58.640 --> 15:00.760
create cycles.

15:00.760 --> 15:03.480
I think that is basically very much the right choice in the

15:03.480 --> 15:04.840
modern world.

15:04.840 --> 15:07.040
No tracing garbage collectors.

15:07.040 --> 15:09.520
Kind of nice.

15:09.520 --> 15:11.640
Also, remember, this is a persistent system.

15:11.640 --> 15:13.680
And if you look at persistent systems, any kind of

15:13.680 --> 15:18.240
database, whether it's no SQL or a SQL, basically you'll see

15:18.240 --> 15:20.040
acyclic data structures everywhere there.

15:20.040 --> 15:24.000
You will not see very many successful databases that

15:24.000 --> 15:26.360
use cyclic data structures.

15:26.360 --> 15:30.440
And it's also, if you're sending data over the network, how

15:30.440 --> 15:32.360
do you send a lazy list over the network?

15:32.360 --> 15:34.040
How do you send a cycle over the network?

15:34.040 --> 15:34.800
I mean, you can.

15:34.800 --> 15:36.720
It's a little bit harder.

15:36.720 --> 15:40.800
And so this is definitely very much designed for the

15:40.800 --> 15:42.960
network edge, obviously.

15:42.960 --> 15:44.760
It should be extremely efficient.

15:44.760 --> 15:45.880
We'll get to how that works in a bit.

15:45.880 --> 15:47.080
It should fit on a t-shirt.

15:47.080 --> 15:49.280
It should be obviously perfect.

15:49.280 --> 15:52.160
I believe that actually I've hit these points.

15:52.160 --> 15:53.320
So concepts of knock.

15:53.320 --> 15:53.600
Quick.

15:53.600 --> 15:55.480
So a value in knock is a noun.

15:55.480 --> 15:58.680
A noun is basically our version of S expressions.

15:58.680 --> 16:01.440
It's S expressions without the S, because basically all that

16:01.440 --> 16:02.800
stuff has been stripped off.

16:02.800 --> 16:05.280
List, essentially, I would say has almost kind of a dynamic

16:05.280 --> 16:08.120
type system for atoms, which you need if you don't have

16:08.120 --> 16:10.440
another type system on top of it, because how do you print

16:10.440 --> 16:11.920
an atom?

16:11.920 --> 16:13.640
Well, if you have a type system, the type system will

16:13.640 --> 16:14.600
tell you how to print the atom.

16:14.600 --> 16:17.440
But if you don't have it, so basically an atom is just an

16:17.440 --> 16:18.840
unsigned integer of any size.

16:18.840 --> 16:20.040
We use this.

16:20.040 --> 16:21.480
An atom will be a number.

16:21.480 --> 16:22.600
It could be a string.

16:22.600 --> 16:24.000
It could be a network packet.

16:24.000 --> 16:25.960
It could be a giant file.

16:25.960 --> 16:27.640
It's a blob.

16:27.640 --> 16:30.440
But a blob as a number, not as a blob as a number.

16:30.440 --> 16:32.920
And this is how long the number is.

16:32.920 --> 16:34.920
A cell is an ordered pair of any two nouns.

16:34.920 --> 16:37.680
We don't do pointer comparison.

16:37.680 --> 16:41.880
This abstraction is completely semantically opaque.

16:41.880 --> 16:45.040
Knock itself is a function from two nouns, or a cell of

16:45.040 --> 16:47.520
nouns, a subject and a formula to a product.

16:47.520 --> 16:49.040
Subject is the data.

16:49.040 --> 16:50.560
Formula is the function.

16:50.560 --> 16:52.040
A product is the result.

16:52.040 --> 16:54.360
And the way we define knock, we define errors as

16:54.360 --> 16:55.080
non-termination.

16:55.080 --> 16:57.680
So errors are basically anything that produces bottom.

16:57.680 --> 16:59.920
Obviously, we don't do that in practice.

16:59.920 --> 17:04.120
But that's how we define the function.

17:04.120 --> 17:05.400
So let's go over the spec.

17:05.400 --> 17:07.800
We'll see the knock spec in two slides.

17:07.800 --> 17:09.920
These are reduction rules.

17:09.920 --> 17:12.320
You see four basic operators here.

17:12.320 --> 17:16.000
The first one is question mark, or as I would say, what?

17:16.000 --> 17:17.240
This is a deep operator.

17:17.240 --> 17:21.080
So is this a cell, or is it an atom?

17:21.080 --> 17:22.960
If it's a cell, it's zero, meaning true.

17:22.960 --> 17:26.080
And if it's an atom, it's one, meaning false.

17:26.080 --> 17:28.120
Zero for true, one for false.

17:28.120 --> 17:31.760
Probably a decision I might do differently next time.

17:31.760 --> 17:35.280
But it's morally right, and it works.

17:35.280 --> 17:37.400
We can also increment an atom.

17:37.400 --> 17:39.840
That's our only arithmetic operator is increment.

17:40.720 --> 17:43.320
If you try to increment a cell, it reduces to itself,

17:43.320 --> 17:46.640
which means an infinite loop, which means an error.

17:46.640 --> 17:48.280
You can test for equality, same thing.

17:48.280 --> 17:51.080
You can't test for an atom for equality.

17:51.080 --> 17:53.600
And the only interesting operator here is this slash,

17:53.600 --> 17:56.560
which is a slot, which is a tree addressing scheme.

17:56.560 --> 18:01.240
So in this tree addressing scheme, basically, one

18:01.240 --> 18:04.240
is the root of the tree, two n is the left child of any node,

18:04.240 --> 18:06.080
two n plus one is the right child.

18:06.080 --> 18:08.560
So basically, having this kind of simple tree addressing

18:08.560 --> 18:10.160
built into the fundamental interpreter

18:10.160 --> 18:13.400
is what lets us not have to deal with scopes and environments

18:13.400 --> 18:17.600
and basically all that jazz that we know and love from Wisp.

18:17.600 --> 18:19.480
So that's all higher level stuff.

18:19.480 --> 18:22.880
All right, so this is the rest of the knock spec.

18:22.880 --> 18:24.960
This is a complete spec here.

18:24.960 --> 18:27.560
So the first reduction rule here is kind of interesting.

18:27.560 --> 18:29.680
This is something I call autocons.

18:29.680 --> 18:33.720
So basically, if you have a knock formula,

18:33.720 --> 18:36.480
either the head of that formula, the formula is always a cell.

18:36.480 --> 18:37.400
It's always a pair.

18:37.400 --> 18:40.320
The head of that formula is either a cell or an atom.

18:40.320 --> 18:42.160
If it's a cell, then what we have here

18:42.160 --> 18:43.560
is a pair of two formulas.

18:43.560 --> 18:46.240
And the semantics of that is cons in those formulas.

18:46.240 --> 18:47.800
So basically, you can build up, you

18:47.800 --> 18:50.480
know, cons is essentially an implicit operator in a way here.

18:50.480 --> 18:53.600
You can build up and just glom formulas together

18:53.600 --> 18:57.600
and you get this kind of automatically cons thing.

18:57.600 --> 19:02.480
Otherwise, so if you see A here is always the subject

19:02.480 --> 19:05.520
and then we're pattern matching in the formula.

19:05.960 --> 19:07.720
This, by the way, is not the syntax or anything.

19:07.720 --> 19:09.040
It's just pseudocode.

19:09.040 --> 19:11.160
Obviously, if you're writing axioms at a certain level,

19:11.160 --> 19:12.440
they're written in English.

19:15.160 --> 19:23.040
So if the head of a formula is a number, then if it's well

19:23.040 --> 19:25.840
formed, otherwise, you see down at the bottom,

19:25.840 --> 19:27.880
anything that's not well formed resolves to itself.

19:27.880 --> 19:29.800
Again, an error.

19:29.800 --> 19:32.760
If it's well formed, we have instruction 0,

19:32.760 --> 19:35.000
which is just the slot operator.

19:35.000 --> 19:36.680
So that lets us basically pick out

19:36.680 --> 19:39.880
a subtree of the subject.

19:39.880 --> 19:43.520
And then, you know, one, constant.

19:43.520 --> 19:44.920
Two is eval.

19:44.920 --> 19:50.360
So basically, B and C here are formulas

19:50.360 --> 19:53.040
against the current subject for a new subject in formula

19:53.040 --> 19:55.200
that we're going to evaluate.

19:55.200 --> 19:56.680
Again, pretty straightforward.

19:56.680 --> 20:00.480
3, 4, and 5 are the deep bump in same operators

20:00.480 --> 20:02.560
that we've seen before.

20:02.600 --> 20:06.440
Depth test, increment, and equals.

20:06.440 --> 20:07.800
Those are actually all the operators

20:07.800 --> 20:10.680
that we need for not to be as expressive as it wants to be.

20:10.680 --> 20:13.720
So we could actually throw away 6 through 10 completely

20:13.720 --> 20:16.960
and have a much shorter, cleaner spec.

20:16.960 --> 20:19.440
There are simpler Turing-complete interpreters

20:19.440 --> 20:20.120
in this, certainly.

20:20.120 --> 20:24.280
So this is intended to be a practical Turing-complete

20:24.280 --> 20:25.320
interpreter.

20:25.320 --> 20:27.880
And it is actually practical, believe it or not.

20:27.880 --> 20:30.240
And you probably don't believe it.

20:30.240 --> 20:38.080
But so 6 is, I'll leave you with an exercise to the reader

20:38.080 --> 20:39.680
if you can figure out how these macros work,

20:39.680 --> 20:41.480
but 6 through 10 are all macros.

20:41.480 --> 20:43.200
6 is if and else.

20:43.200 --> 20:45.560
7 composes two formulas.

20:45.560 --> 20:48.560
8 composes a formula with the cell

20:48.560 --> 20:49.720
of the product of a formula.

20:49.720 --> 20:51.680
It's basically declaring a variable, essentially.

20:51.680 --> 20:55.600
You're putting a new value onto that subject

20:55.600 --> 20:58.760
and then using it for the next formula.

20:58.760 --> 21:01.000
9 is essentially implementing what

21:01.000 --> 21:06.080
whom we use as a function call to simplify it enormously.

21:06.080 --> 21:07.240
And 10 is a hint.

21:07.240 --> 21:09.040
So you see two 10s there because you

21:09.040 --> 21:11.240
can have a dynamic hint or a static hint.

21:11.240 --> 21:13.000
What a hint is in this environment

21:13.000 --> 21:15.000
is an instruction that throws away data.

21:15.000 --> 21:17.040
So if you discard data, basically,

21:17.040 --> 21:18.360
you're saying to the interpreter,

21:18.360 --> 21:19.840
do whatever you want with this data.

21:19.840 --> 21:20.920
Do something with it.

21:20.920 --> 21:24.600
So hints or anything like a debugging printf is a hint.

21:24.600 --> 21:27.800
You're like, yeah, I don't know that a debugging printf happened.

21:27.800 --> 21:31.120
But if you want to make it happen, make it happen.

21:31.120 --> 21:31.840
Memoization.

21:31.840 --> 21:33.520
There's a memoization hint.

21:33.520 --> 21:34.640
That's another good example.

21:34.640 --> 21:36.800
So the hint basically doesn't change

21:36.800 --> 21:40.720
the formal result of the computation,

21:40.720 --> 21:43.600
but it helps the interpreter do something interesting with it.

21:43.600 --> 21:44.480
So that's all of NOC.

21:46.920 --> 21:49.360
And now let's see.

21:49.360 --> 21:50.560
Here's a little example.

21:50.560 --> 21:56.040
So NOC, of course, the only integer operation is increment.

21:56.040 --> 21:58.160
So if you want to decrement, well,

21:58.160 --> 21:59.440
that's a little bit of a problem.

21:59.440 --> 22:01.360
You actually have to write some code.

22:01.360 --> 22:03.680
You're going to actually have to count up to n minus 1

22:03.680 --> 22:05.440
to decrement.

22:05.440 --> 22:06.200
Not a big deal.

22:06.200 --> 22:08.000
Very simple algorithm.

22:08.000 --> 22:09.640
So here, we're jumping ahead.

22:09.640 --> 22:11.600
And on the right side of your screen, basically,

22:11.600 --> 22:13.800
you're seeing some poon.

22:13.800 --> 22:16.760
Those are two, basically, kind of alternate syntaxes for poon.

22:16.760 --> 22:19.200
One of them is a keyword syntax, which you can probably read

22:19.200 --> 22:20.560
just by looking at it.

22:20.560 --> 22:23.280
The other one is a rune syntax, which you probably can't read,

22:23.280 --> 22:24.960
but that's what we actually use in practice.

22:25.000 --> 22:28.680
It's kind of training wheels, no training wheels.

22:28.680 --> 22:31.560
And on the left is the actual NOC formula

22:31.560 --> 22:33.320
that we generate from this.

22:33.320 --> 22:35.200
If I had a couple more hours, I would actually

22:35.200 --> 22:36.200
go through this formula.

22:36.200 --> 22:39.840
But as it is, it'll just have to serve as an example.

22:39.840 --> 22:42.120
All we're doing is we're basically saying, OK,

22:42.120 --> 22:45.160
we're going to call the subject a, because that's the number

22:45.160 --> 22:46.120
we're decrementing.

22:46.120 --> 22:49.320
We're going to add a counter, which is 0.

22:49.320 --> 22:50.120
We're going to loop.

22:50.120 --> 22:56.800
And we're going to count up until the increment of b is a.

22:56.800 --> 22:59.200
If that is true, our product is b.

22:59.200 --> 23:00.920
Otherwise, we're going to loop again

23:00.920 --> 23:03.120
with b changed to the increment of b.

23:03.120 --> 23:08.000
Pretty straightforward decrement, not super hard.

23:08.000 --> 23:10.840
But that kind of brings up a problem

23:10.840 --> 23:15.480
that you might think of, which is g, o of n decrement.

23:15.480 --> 23:18.000
Well, if you actually run, if you try to boot

23:18.000 --> 23:20.520
urbit with a completely naive interpreter,

23:20.520 --> 23:22.080
it will immediately start decrementing

23:22.080 --> 23:24.360
and keep decrementing until pretty much the end of time.

23:24.360 --> 23:27.800
So that's clearly basically a non-starter.

23:27.800 --> 23:30.240
There's a well-known solution to optimization problems

23:30.240 --> 23:30.800
of this kind.

23:30.800 --> 23:33.680
It's called a sufficiently smart interpreter.

23:33.680 --> 23:35.560
All your interpreter has to do is simply

23:35.560 --> 23:38.280
recognize that it needs to analyze the algorithm that

23:38.280 --> 23:41.240
it's interpreting, recognize that it's decrement algorithm,

23:41.240 --> 23:44.000
and implement it efficiently accordingly.

23:44.000 --> 23:46.160
We also need to recognize add, multiply,

23:46.160 --> 23:47.880
and all of their interesting functions.

23:47.880 --> 23:50.120
So if you know anything about compiler theory,

23:50.120 --> 23:53.400
you know that this is a very hard problem.

23:53.400 --> 23:55.720
Fortunately, there's a much easier problem

23:55.720 --> 23:56.960
which is related to it.

23:56.960 --> 23:58.640
We don't have to recognize every decrement.

23:58.640 --> 24:00.880
We just have to recognize the one that we actually call,

24:00.880 --> 24:03.200
which is the one in the standard library.

24:03.200 --> 24:07.440
And so basically, the way we optimize in the system,

24:07.440 --> 24:09.520
and this should be sort of compared to,

24:09.520 --> 24:12.080
let's say you're building, you're using Java or using Python.

24:12.080 --> 24:15.920
What you do is you say, OK, I wrote some pure code.

24:15.920 --> 24:16.560
It's beautiful.

24:17.360 --> 24:19.880
Oh, it's not fast enough.

24:19.880 --> 24:21.760
And I guess I need a native method.

24:21.760 --> 24:25.600
So then you call it to C. You rewrite your interloop

24:25.600 --> 24:28.800
or whatever in C. You throw away their original pure code.

24:28.800 --> 24:30.360
There's another great advantage, which

24:30.360 --> 24:32.520
is that your interloop in C can make system calls.

24:32.520 --> 24:36.200
So it can modify the file system or something.

24:36.200 --> 24:42.000
And that is not necessarily a very functional way

24:42.000 --> 24:43.720
of proceeding.

24:43.720 --> 24:46.280
The way we optimize knock and hoon is a little different.

24:46.280 --> 24:49.240
So we basically say, when you write, say, decrement,

24:49.240 --> 24:51.920
you say, OK, I'm going to declare this in a namespace.

24:51.920 --> 24:53.840
I'm going to say to the interpreter,

24:53.840 --> 24:55.480
I believe this to be decrement.

24:55.480 --> 24:57.040
It's just a conventional name.

24:57.040 --> 24:57.840
This is decrement.

24:57.840 --> 25:00.280
The interpreter is like, oh, he says this is decrement.

25:00.280 --> 25:00.920
Is this true?

25:00.920 --> 25:04.720
Well, gee, I'm built to recognize, literally,

25:04.720 --> 25:06.840
with the hash of the formula, I'm

25:06.840 --> 25:10.240
built to run this specific formula efficiently.

25:10.240 --> 25:12.720
So I'm going to match this, which is a slightly hard problem,

25:12.720 --> 25:14.320
but I don't know how to super hard problem.

25:14.320 --> 25:15.680
I'm going to match this at runtime,

25:15.680 --> 25:17.560
and then I'm going to do the efficient decrement.

25:17.560 --> 25:19.200
So the advantage of this approach,

25:19.200 --> 25:21.560
and there's a number of advantages of this approach.

25:21.560 --> 25:23.760
First of all, you have both those routines,

25:23.760 --> 25:25.920
the fast decrement in C, which is totally

25:25.920 --> 25:27.480
an implementation detail.

25:27.480 --> 25:30.720
And you're separating mechanism and policy there,

25:30.720 --> 25:31.160
essentially.

25:31.160 --> 25:33.240
So you have your fast decrement in C,

25:33.240 --> 25:38.680
and then you're essentially executable specification

25:38.680 --> 25:40.200
of decrement.

25:40.200 --> 25:43.920
And you're basically binding the two together.

25:43.920 --> 25:47.560
So obviously, you can test these against each other

25:47.560 --> 25:49.520
at runtime, if you choose.

25:49.520 --> 25:51.840
There's certainly, you can sandbox your jet,

25:51.840 --> 25:55.960
so it has no reason to make system calls.

25:55.960 --> 25:59.960
You can also extend this up the stack quite a ways.

25:59.960 --> 26:03.880
So for example, we have one of the,

26:03.880 --> 26:06.440
we serve our own website using Herbit.

26:06.440 --> 26:09.280
And one of the, we serve it from Markdown.

26:09.280 --> 26:11.160
So we have a Markdown parser written in Hoon.

26:11.160 --> 26:13.080
Well, it's a decent Markdown parser.

26:13.120 --> 26:15.240
Maybe not the world's fastest.

26:15.240 --> 26:17.760
Fortunately, Markdown is a standard for some values

26:17.760 --> 26:19.760
of the word standard.

26:19.760 --> 26:23.560
And we basically jet that Markdown parser

26:23.560 --> 26:26.600
with an efficient common mark implementation in C.

26:26.600 --> 26:29.120
Our, for another example is, Google

26:29.120 --> 26:31.600
has this lovely library called TensorFlow.

26:31.600 --> 26:34.080
They recently announced that basically they built an ASIC

26:34.080 --> 26:35.440
for TensorFlow.

26:35.440 --> 26:38.400
I don't know how exactly the programmer talks to that ASIC,

26:38.400 --> 26:40.840
but I'm sure it's a mess.

26:40.840 --> 26:42.640
What you actually want to do is basically

26:42.640 --> 26:46.600
say, OK, I as a programmer, I'm using TensorFlow of this version.

26:46.600 --> 26:49.160
I run TensorFlow, I declare that this is TensorFlow

26:49.160 --> 26:50.360
of a certain version.

26:50.360 --> 26:52.600
And then my interpreter is like, aha,

26:52.600 --> 26:55.000
I have a chip that can speed up TensorFlow of this version.

26:55.000 --> 26:56.600
I'll just use that.

26:56.600 --> 27:00.320
And so that scales kind of in more interesting ways

27:00.320 --> 27:03.880
than the, let's call it, to see model scale.

27:03.880 --> 27:06.080
So we also use it, by the way, to virtualize knock.

27:06.080 --> 27:08.760
So there's actually a virtual knock written in knock

27:08.760 --> 27:10.840
if you thought knock was slow.

27:10.880 --> 27:14.680
But basically, you can get unlimited levels of virtualization

27:14.680 --> 27:17.040
pyramid by basically just recognizing

27:17.040 --> 27:19.320
that you're running your own virtualizer and just saying,

27:19.320 --> 27:21.400
hey, we're at six levels deep.

27:21.400 --> 27:22.960
So that's an improvement as well.

27:22.960 --> 27:24.200
All right, we're done with knock.

27:24.200 --> 27:25.080
That's knock.

27:25.080 --> 27:25.600
Pretty cool.

27:25.600 --> 27:28.440
Let's build Hoon.

27:28.440 --> 27:31.640
Hoon obviously needs to compile itself to knock.

27:31.640 --> 27:34.360
It needs to be a pure strict higher order type functional

27:34.360 --> 27:36.840
language, because that's the hotness.

27:36.840 --> 27:39.040
It needs to have a, I believe it needs

27:39.040 --> 27:40.840
to have a simple transformation to knock.

27:40.840 --> 27:43.080
So I'm really a Unix and Seaguy.

27:43.080 --> 27:46.080
I'm not a functional programming guy at all,

27:46.080 --> 27:49.640
and actually don't know any of their functional languages.

27:49.640 --> 27:53.000
And so that sort of simplicity, that feeling

27:53.000 --> 27:55.240
that basically the compiler is doing something

27:55.240 --> 27:58.560
very simple for you, is really like a wonderful feeling

27:58.560 --> 28:00.560
when you're working inside C. You're

28:00.560 --> 28:03.240
seeing the system basically at two levels.

28:03.240 --> 28:05.800
We definitely want a system that doesn't require

28:05.800 --> 28:08.200
people to have a math degree.

28:08.240 --> 28:11.360
And that's a subject to complaint.

28:11.360 --> 28:14.040
I think more generally, one of the things

28:14.040 --> 28:16.600
that languages like Haskell do is they encourage

28:16.600 --> 28:17.960
their functional programming languages,

28:17.960 --> 28:20.320
and they encourage you to use these powerful tools

28:20.320 --> 28:22.680
as much as possible.

28:22.680 --> 28:23.760
Hoon is kind of opposite.

28:23.760 --> 28:26.680
It encourages you to not use these tools.

28:26.680 --> 28:29.920
It's basically like, OK, the power is there if you need it.

28:29.920 --> 28:32.200
But bear in mind, when you're using this kind of functional

28:32.200 --> 28:34.400
power, you're imposing cognitive overhead

28:34.400 --> 28:36.440
on the ordinary programmer.

28:36.440 --> 28:39.120
Because we really want this to be something

28:39.120 --> 28:42.000
that a Python programmer can pick up and program in.

28:42.000 --> 28:46.120
And I think the ability to basically teach people

28:46.120 --> 28:50.000
these higher order constructs is really debatable.

28:50.000 --> 28:52.360
I don't think it's proven at all.

28:52.360 --> 28:54.960
There's another thing that often happens, both with macros

28:54.960 --> 28:57.560
and with kind of advanced functional languages,

28:57.560 --> 28:59.440
where you get into this kind of DSL pattern,

28:59.440 --> 29:02.760
where basically you're so higher order, you're so meta,

29:02.760 --> 29:06.800
that every file is written in its own language, which

29:06.800 --> 29:08.440
basically gets you to write only code.

29:08.440 --> 29:10.920
And that's like a kind of serious downside

29:10.920 --> 29:13.200
of functional programming.

29:13.200 --> 29:15.960
And the thing is Hoon is still basically almost as

29:15.960 --> 29:17.560
expressive as Haskell.

29:17.560 --> 29:19.480
It has the equivalent of type classes.

29:19.480 --> 29:20.600
It has generosity.

29:20.600 --> 29:23.240
It's like, it's not Haskell.

29:23.240 --> 29:25.160
Haskell people will be a little disappointed in it,

29:25.160 --> 29:28.600
but it's definitely not a lisp.

29:28.600 --> 29:31.960
OK, so let's go a little more into detail on Hoon.

29:32.840 --> 29:35.520
So basically, the back end of Hoon is extremely simple.

29:35.520 --> 29:38.120
So type inference and code generation together,

29:38.120 --> 29:40.440
1,500 lines of code.

29:40.440 --> 29:42.360
Shouldn't be super hard to learn.

29:42.360 --> 29:45.720
So where basically Nock is doing subject and formula

29:45.720 --> 29:48.640
to product, of course, in Hoon, we have an actual expression

29:48.640 --> 29:51.120
that is written in, for some values of the word,

29:51.120 --> 29:54.120
user level code, user level code.

29:54.120 --> 29:56.520
The experience of programming without an environment,

29:56.520 --> 29:58.160
or without a scope, or without a heap,

29:58.160 --> 30:01.200
or without the sort of extra piece of state,

30:01.240 --> 30:04.080
where you just have, the subject is just one noun,

30:04.080 --> 30:06.360
and everything that you need is in the subject,

30:06.360 --> 30:09.160
is sort of somewhat unique and different.

30:09.160 --> 30:11.200
You keep sort of reaching for that,

30:11.200 --> 30:13.000
oh, there must be something that has my variables,

30:13.000 --> 30:14.720
but no, there's really just one noun

30:14.720 --> 30:16.840
that you're defining a function against.

30:18.680 --> 30:22.680
So when we basically take a type system

30:22.680 --> 30:24.960
and layer it on top of Nock,

30:24.960 --> 30:27.520
we're basically computing a mapping from a type in an

30:27.520 --> 30:30.120
expression to a type in a formula.

30:30.160 --> 30:33.720
So we have input type, or subject type,

30:33.720 --> 30:38.160
and expression turns into product type,

30:38.160 --> 30:40.720
and the Nock formula that computes that expression.

30:40.720 --> 30:44.440
So again, a very, very simple straightforward kind of

30:44.440 --> 30:47.280
relationship to Nock here.

30:47.280 --> 30:49.440
The inference algorithm is extremely stupid.

30:49.440 --> 30:53.880
It infers only forward, it does not use unification at all.

30:53.880 --> 30:57.640
It can infer tail recursion, but not head recursion.

30:58.640 --> 31:02.120
So a general pattern is you need a few more sort of casts

31:02.120 --> 31:03.200
to help the type system out.

31:03.200 --> 31:05.640
It's still a strict type system,

31:05.640 --> 31:09.480
but you need to help it a little bit.

31:09.480 --> 31:11.880
My view is that basically having a stupider inference

31:11.880 --> 31:16.760
algorithm is, again, a UI win for a language,

31:16.760 --> 31:19.280
because basically when you program in a language,

31:19.280 --> 31:23.840
you kinda need to follow what the compiler is doing.

31:23.840 --> 31:26.400
The more powerful the algorithm you're following,

31:26.400 --> 31:29.080
basically the harder it's gonna be for people to follow.

31:29.080 --> 31:31.880
And so when I look at Haskell, I see basically two kinds

31:31.880 --> 31:33.000
of Haskell users in a way.

31:33.000 --> 31:36.160
I see people who treat Haskell as a black box,

31:36.160 --> 31:38.240
and they're like, it's sort of a learn you a Haskell

31:38.240 --> 31:41.160
kind of way, and they're like, oh, I made it work, cool.

31:41.160 --> 31:43.320
And then there are the people that actually understand

31:43.320 --> 31:48.320
the math, and both of those situations don't scale in a way.

31:49.400 --> 31:52.680
And so having a simpler system is definitely,

31:53.920 --> 31:54.880
I think a win.

31:55.800 --> 31:58.400
So a little more about Hoon.

31:58.400 --> 32:01.560
So this is brought us in for some criticism,

32:01.560 --> 32:05.640
but Hoon basically, since it sort of has its own way

32:05.640 --> 32:07.320
of doing things, we invent a lot of terms,

32:07.320 --> 32:10.600
because basically the ordinary terms tend to be confusing.

32:10.600 --> 32:13.520
So, and we also have a four letter name

32:13.520 --> 32:14.720
kind of convention going on.

32:14.720 --> 32:17.760
So an expression, or an AST, is a twig.

32:17.760 --> 32:20.800
A type is, well, there's actually three things

32:20.800 --> 32:23.000
that are basically correspond to a type.

32:23.000 --> 32:25.760
So a type, as in sort of a set of nouns

32:25.760 --> 32:28.960
and a semantics ascribed to them, is called a span.

32:28.960 --> 32:32.360
A type in terms of a constructor is called a mold.

32:32.360 --> 32:34.800
And then we also have basically, at the kind of OS level,

32:34.800 --> 32:36.680
I don't think I'll get into that today,

32:36.680 --> 32:38.200
basically the equivalent of mind types,

32:38.200 --> 32:40.560
which is something else also entirely.

32:42.160 --> 32:43.640
Looking at molds, basically,

32:43.640 --> 32:45.160
Hoon is a pure prototype language.

32:45.160 --> 32:47.840
There's no syntax for defining a span.

32:47.840 --> 32:50.800
The only thing you can define are twigs.

32:50.800 --> 32:53.160
So when you want to define basically a span,

32:53.160 --> 32:54.960
a range, a type in the usual sense,

32:54.960 --> 32:56.840
a set of nouns that you're interested in,

32:56.840 --> 32:59.600
what you define is actually a normalizing function

32:59.600 --> 33:03.240
that takes an arbitrary noun and produces a noun

33:03.240 --> 33:05.680
of that type that you're interested in.

33:05.680 --> 33:07.480
What's kind of nice about that is that basically,

33:07.480 --> 33:09.280
if this is the way you define types,

33:09.280 --> 33:10.480
anytime you define a type,

33:10.480 --> 33:13.600
you've defined a validator for untrusted network data.

33:13.600 --> 33:17.040
So we do a fair bit of validating untrusted network data

33:17.040 --> 33:20.240
in today's environment, so that's kind of a win.

33:21.800 --> 33:24.960
Basic concepts of the type system.

33:24.960 --> 33:27.400
This is almost a complete definition

33:27.400 --> 33:28.280
of the Hoon type system.

33:28.280 --> 33:30.120
It's missing a little bit of stuff.

33:31.160 --> 33:32.240
I'll see if I can fill that in,

33:32.240 --> 33:34.280
but we've got to move pretty fast here.

33:35.480 --> 33:37.200
So, and I'm not going to talk about twigs at all,

33:37.200 --> 33:39.560
because once you understand basically a data representation,

33:39.560 --> 33:40.560
it's pretty straightforward.

33:40.560 --> 33:43.080
So a span defines a set of nouns.

33:43.080 --> 33:44.720
What can the set be?

33:44.720 --> 33:47.080
It can be noun, which means it could be any noun,

33:47.080 --> 33:49.520
any remember S expression, basically.

33:49.640 --> 33:51.600
It could be void, which is an empty set.

33:51.600 --> 33:53.480
I'm going to skip over Adam and Core,

33:53.480 --> 33:55.160
because I have separate slides for those.

33:55.160 --> 33:56.680
A cell, obviously a cell.

33:56.680 --> 33:59.280
Here's a span of the head, span of the tail.

33:59.280 --> 34:01.840
A face, basically we're going to label this span.

34:01.840 --> 34:03.680
And so remember that there's no symbol table,

34:03.680 --> 34:04.680
there's no anything in here.

34:04.680 --> 34:07.400
So the labels actually live inside the type.

34:07.400 --> 34:08.760
So when you're searching for a label,

34:08.760 --> 34:11.000
you're actually doing a depth-first search

34:11.000 --> 34:13.920
of basically the type of the subject.

34:13.920 --> 34:16.600
Fortunately, computers have gotten a lot faster.

34:16.600 --> 34:18.000
You can cache this, we do cache it,

34:18.000 --> 34:19.560
but I mean, fine, it's a depth-first search.

34:19.560 --> 34:21.280
How big is your subject, right?

34:22.560 --> 34:25.560
You can have a fork, which is a union of spans.

34:25.560 --> 34:26.840
Pretty obvious.

34:26.840 --> 34:29.720
And the only really interesting one in this page is hold.

34:29.720 --> 34:32.360
So basically one thing we never do in the systems,

34:32.360 --> 34:34.280
we never calculate type signatures.

34:34.280 --> 34:38.840
So this is a strict system, we can't do laziness.

34:38.840 --> 34:41.600
What hold means is basically the span here

34:41.600 --> 34:44.480
is the result of if you take subject P

34:44.480 --> 34:46.560
and run expression Q against it.

34:46.560 --> 34:49.240
So this is very much manual laziness.

34:50.160 --> 34:51.880
Manual laziness has some nice benefits.

34:51.880 --> 34:53.920
Namely, you can use this as a,

34:53.920 --> 34:56.920
you can use a manually lazy span as a key

34:56.920 --> 34:58.760
in a key value data structure,

34:58.760 --> 35:01.360
which is pretty difficult with infinite data structures.

35:03.560 --> 35:07.360
So that's basically, those are the simple ones.

35:07.360 --> 35:10.920
Let me get to the non-boring spans, Adam and Core.

35:10.920 --> 35:14.240
So Adam is just an Adam, slightly non-boring

35:14.240 --> 35:16.360
in that you can say this could be any Adam

35:16.360 --> 35:18.320
or you could say this could be a constant.

35:18.320 --> 35:21.200
So the unit there is who's equivalent of maybe.

35:22.920 --> 35:26.360
And so if that's set, then we have,

35:26.360 --> 35:27.880
this is just a constant Adam.

35:27.880 --> 35:30.000
Then we have P there is something interesting.

35:30.000 --> 35:31.920
The term is a symbol essentially.

35:32.840 --> 35:35.040
And we have what I call an aura.

35:35.040 --> 35:37.000
This is a soft type.

35:37.000 --> 35:39.360
This is a basically non-enforced type

35:39.360 --> 35:41.000
or enforced gently type.

35:41.000 --> 35:44.640
And if you remember, Lisp of course has this dynamic type

35:44.640 --> 35:47.120
and it's Adams, which is just really awful

35:47.120 --> 35:49.480
in my personal opinion.

35:49.480 --> 35:52.040
And if you have a type system, basically the type system

35:52.040 --> 35:55.080
when it has an Adam needs to be able to describe

35:55.080 --> 35:57.160
how do you print this Adam?

35:57.160 --> 36:00.160
Gee, what happens if I try to use a furlong

36:00.160 --> 36:01.440
as if it was a Fortnite?

36:02.320 --> 36:04.000
What happens if I try to use an IP address

36:04.000 --> 36:04.960
as if it was a string?

36:04.960 --> 36:06.160
All those are Adams.

36:06.160 --> 36:09.240
And so you basically need to label those

36:09.240 --> 36:11.400
and describe them kind of informally.

36:11.400 --> 36:15.080
And there's a basically system of specialization

36:15.080 --> 36:17.440
simply by the length of the name.

36:17.440 --> 36:20.560
So you can basically text, ASCII text,

36:20.560 --> 36:22.600
ASCII text with a symbol constraint.

36:22.600 --> 36:24.920
None of the, all these are informal conventions.

36:24.920 --> 36:27.680
None of them are, there's no dependent types in the system.

36:27.680 --> 36:29.560
Sorry, get another no dependent types.

36:30.560 --> 36:32.960
And they're not enforced at all,

36:32.960 --> 36:36.600
except that basically if you wanna turn an IP address

36:36.600 --> 36:39.960
into a string basically and be so foolish,

36:39.960 --> 36:41.440
you have to manually tell it,

36:41.440 --> 36:44.920
you have to cast up to just a raw Adam

36:44.920 --> 36:47.440
and then down back to your string.

36:47.440 --> 36:50.800
So you have to work to basically screw up that way.

36:50.800 --> 36:52.880
That's an interesting design.

36:52.880 --> 36:55.560
You don't usually see a soft type in a functional language.

36:55.560 --> 36:56.920
I think it's worked pretty well.

36:56.920 --> 36:58.600
It's not perfect.

36:58.600 --> 37:00.520
I think the most interesting span,

37:00.520 --> 37:04.600
and remember a span is describing a set of nouns.

37:04.600 --> 37:06.280
The most interesting one is core,

37:06.280 --> 37:08.760
which is essentially an object.

37:08.760 --> 37:10.240
Or it's an object that's sort of

37:10.240 --> 37:12.040
in a very broad in general sense.

37:12.040 --> 37:15.720
It's actually the general case of objects and functions

37:15.720 --> 37:17.120
and a lot of other things,

37:17.120 --> 37:19.320
which you don't really have a name for.

37:19.320 --> 37:20.680
A core is a cell.

37:20.680 --> 37:22.520
The head of the cell is a battery,

37:22.520 --> 37:25.880
which is either one formula or a tree of formulas.

37:25.880 --> 37:28.880
Remembering a formula is just a knock function.

37:28.880 --> 37:31.600
The tail is a payload, which is basically any noun.

37:33.120 --> 37:36.920
And when we run the arms, which are the,

37:36.920 --> 37:38.160
basically they're not methods,

37:38.160 --> 37:40.960
they're computed attributes in the battery.

37:40.960 --> 37:43.360
We run that with the whole core as the subject.

37:43.360 --> 37:44.920
So we basically have this thing

37:44.920 --> 37:46.440
that has a bunch of code in it.

37:46.440 --> 37:47.280
It's like, you can think of,

37:47.280 --> 37:49.280
if you know C++ implementation,

37:49.280 --> 37:51.920
you can think of it as like a V-table, right?

37:51.920 --> 37:54.860
And so it's, here's a V-table with a bunch of formulas in it.

37:54.860 --> 37:56.320
And you say, I wanna run,

37:56.320 --> 37:57.840
I wanna get foo out of this core.

37:57.840 --> 37:59.520
It's like, oh, great, I have a foo.

37:59.520 --> 38:01.920
I'm gonna basically calculate,

38:01.920 --> 38:04.440
that's gonna resolve to this calculation.

38:04.440 --> 38:06.040
So there's no separate namespace

38:06.040 --> 38:07.880
for basically data and for code.

38:07.880 --> 38:09.720
So if you're looking for foo on a core,

38:09.720 --> 38:11.080
and the core doesn't have foo,

38:11.080 --> 38:12.640
there's no foo in the battery.

38:13.880 --> 38:15.880
Then it goes in and says,

38:15.880 --> 38:17.160
oh, well, let's look in the payload.

38:17.160 --> 38:19.440
Let's descend down the tree.

38:19.440 --> 38:20.560
Notice also again,

38:20.560 --> 38:24.060
that there is no attempt to create a type signature here.

38:24.060 --> 38:26.160
So this is just a map of a term to the twig.

38:26.160 --> 38:27.400
Twig is a source.

38:27.400 --> 38:28.840
That's a source expression.

38:28.840 --> 38:30.720
So basically, and that's in the type.

38:30.720 --> 38:34.040
So when I call foo on this core,

38:34.040 --> 38:35.440
I basically go in and I say,

38:35.440 --> 38:38.680
well, okay, that's gonna generate one of these whole things.

38:38.680 --> 38:40.960
So it says, okay, the result,

38:40.960 --> 38:44.800
the type of the span of the result of this foo

38:44.800 --> 38:49.200
is basically the core type and the twig.

38:49.200 --> 38:51.040
And so when we actually evaluate that,

38:51.040 --> 38:53.800
we have to basically manually work through the laziness

38:53.800 --> 38:55.840
and say, oh, well, what's in that type?

38:55.840 --> 38:58.840
Gee, I don't know, let me calculate it and find out.

38:58.840 --> 39:00.980
That actually, that works rather well.

39:01.900 --> 39:06.800
Let me, okay, here's some advanced theory.

39:06.800 --> 39:08.460
I'm gonna go over this super quickly.

39:08.460 --> 39:10.380
So hold again is manual laziness.

39:10.380 --> 39:12.380
One of the nice things about it is that basically,

39:12.380 --> 39:14.660
you can build a conservative work list algorithm.

39:14.660 --> 39:15.920
Let's say you're building a linked list.

39:15.920 --> 39:18.820
Let's say you wanna do a type comparison on two linked lists.

39:18.820 --> 39:20.620
Okay, now this is a basically,

39:21.540 --> 39:23.060
this is a structural comparison.

39:23.060 --> 39:25.960
So you're saying, these could be totally different definitions

39:25.960 --> 39:27.100
of linked list.

39:27.100 --> 39:28.380
Do they match?

39:28.380 --> 39:33.380
So if you basically traverse this span,

39:34.340 --> 39:37.380
what you're gonna see is that that traverse repeats itself.

39:37.380 --> 39:39.620
And because it repeats itself, you can say,

39:39.620 --> 39:42.660
oh, gee, I already checked that there were no violations

39:42.660 --> 39:46.940
on this arm, on this branch, so I'm gonna call that fine.

39:46.940 --> 39:50.180
And that's basically how you can do sort of type logic

39:50.180 --> 39:52.280
in this manually evaluated space.

39:52.280 --> 39:54.940
Again, very, very stupid if you ask,

39:54.940 --> 39:57.580
any smart undergraduate could come up with this scheme.

39:58.940 --> 40:00.780
A little more, at a little more depth,

40:00.780 --> 40:02.020
I'm gonna go over this super quickly.

40:02.020 --> 40:03.700
You may not understand it.

40:03.700 --> 40:07.060
Basically, in polymorphism, you have two,

40:08.300 --> 40:10.140
a lot of different kinds of languages.

40:10.140 --> 40:11.300
And I'm thinking of like Eiffel

40:11.300 --> 40:13.620
and like the Bertrand Meyer kind of world of languages

40:13.620 --> 40:15.980
have basically two kinds of polymorphism.

40:15.980 --> 40:17.740
You have variance and you have generosity.

40:17.740 --> 40:21.180
So basically, any polymorphism in any system like this

40:21.180 --> 40:23.620
is about basically, if I change a core,

40:23.620 --> 40:25.220
let's say, okay, I built this core,

40:25.220 --> 40:28.020
I stuck this battery on this payload.

40:28.020 --> 40:29.380
But now I changed the payload.

40:29.380 --> 40:30.460
Maybe I changed the payload

40:30.460 --> 40:31.820
to something of a different type.

40:31.820 --> 40:33.380
Can I run this core?

40:33.380 --> 40:35.420
So basically, can I run this arm

40:35.420 --> 40:37.660
or will it just be a total disaster?

40:37.660 --> 40:39.340
And that question is actually answered

40:39.340 --> 40:40.820
when you try to run the arm.

40:40.820 --> 40:45.580
So there's sort of simple question of variance, basically.

40:45.580 --> 40:47.980
Can I use this one payload as another payload?

40:49.060 --> 40:51.700
The way we do generosity is,

40:51.700 --> 40:54.060
I can sort of explain this intuitively

40:54.060 --> 40:55.540
at a very high level.

40:55.540 --> 40:56.620
When you're doing generosity,

40:56.620 --> 40:58.540
you're basically saying,

40:58.540 --> 40:59.380
when you're doing variance,

40:59.380 --> 41:01.220
you're basically saying, okay,

41:01.220 --> 41:04.500
does my mutated payload work like the original payload?

41:04.500 --> 41:05.540
When you're doing generosity,

41:05.540 --> 41:06.940
what you're saying is you're saying,

41:06.940 --> 41:09.220
okay, I've changed the type of this payload.

41:09.220 --> 41:10.940
I've changed something totally different.

41:10.940 --> 41:12.620
Now I'm gonna run this arm on it.

41:12.620 --> 41:13.900
I'm not gonna recompile this arm.

41:13.900 --> 41:16.180
I'm gonna run the original knock formula

41:16.180 --> 41:17.020
that was calculated

41:17.020 --> 41:19.540
for something of a totally different type.

41:19.540 --> 41:21.180
And the question you have to answer is,

41:21.180 --> 41:22.420
is that gonna work?

41:22.420 --> 41:24.180
And what span is it gonna produce?

41:25.180 --> 41:28.100
And you're basically treating the twig,

41:28.100 --> 41:29.980
you're treating the arm as a macro,

41:29.980 --> 41:32.860
and essentially working through it.

41:32.860 --> 41:34.420
So it's like the classic example,

41:34.420 --> 41:35.660
can you build a function

41:35.660 --> 41:38.260
to swap two things of an arbitrary type?

41:38.260 --> 41:43.260
So yeah, you basically do that with generosity in Hoon.

41:44.620 --> 41:46.940
So that works, that's how we do containers,

41:46.940 --> 41:48.780
all the usual jazz.

41:48.780 --> 41:52.020
And it's essentially kind of this ghetto,

41:52.140 --> 41:53.940
low rent way of doing type classes.

41:55.140 --> 41:57.180
Syntax design, let's go into the syntax.

41:57.180 --> 42:00.540
Hoon has a very unusual syntax you've seen already.

42:00.540 --> 42:02.740
A lot of people think it looks pretty gnarly.

42:03.660 --> 42:05.780
There is a reason for doing this gnarly thing.

42:05.780 --> 42:08.340
The reason is that basically there are kind of three problems

42:08.340 --> 42:10.860
that you see in a lot of functional languages

42:10.860 --> 42:13.140
that are syntactic problems.

42:13.140 --> 42:14.860
One problem is that basically expression

42:14.860 --> 42:16.220
is sloped downward into the right,

42:16.220 --> 42:18.100
and so they keep attacking your right margin

42:18.100 --> 42:19.580
if they get too complicated.

42:19.580 --> 42:20.620
In a procedural language,

42:20.620 --> 42:22.620
you've got this nice division between statements

42:22.620 --> 42:24.260
and expressions, and statements flow down,

42:24.260 --> 42:25.900
and expressions flow across,

42:25.900 --> 42:28.140
and it gives you this kind of nice tree-shaped structure

42:28.140 --> 42:31.100
which lets you work within an 80-column margin.

42:32.060 --> 42:34.060
In a functional language, you often don't have that,

42:34.060 --> 42:36.660
so you get this slanty thing,

42:36.660 --> 42:39.060
which is uncomfortable to work with.

42:39.060 --> 42:42.140
Another problem in syntax that a lot of these languages have

42:42.140 --> 42:44.180
is they have this unpleasant choice between,

42:44.180 --> 42:46.700
am I gonna have 17 parentheses in a row,

42:46.700 --> 42:49.140
or am I gonna do significant white space?

42:49.140 --> 42:51.420
Both of those have, they work, they work,

42:51.420 --> 42:54.220
they just have, they're just not super pretty.

42:54.220 --> 42:56.060
Another problem that I don't know if everyone has

42:56.060 --> 42:57.420
this problem, I certainly have this problem

42:57.420 --> 43:00.580
when I look at LISPs and a lot of similar things,

43:00.580 --> 43:03.700
is basically I can't distinguish special forms from symbols.

43:03.700 --> 43:05.860
I can't distinguish, is this part of the language,

43:05.860 --> 43:07.980
or is this something that somebody included

43:07.980 --> 43:10.940
from the library, or is it a macro?

43:10.940 --> 43:13.340
And basically making that, again,

43:13.340 --> 43:16.380
getting away from this sort of pervasive DSLization

43:17.380 --> 43:21.100
is definitely a goal of the system.

43:22.540 --> 43:25.460
Speeding up a little, so let me,

43:25.460 --> 43:28.260
before showing the syntax, basically a twig structure.

43:28.260 --> 43:32.060
Once again, the twig is a hoon AST.

43:33.500 --> 43:38.500
You can do, hoon has the same kind of auto cons feature

43:39.460 --> 43:42.940
that knock does, so basically cons is assumed.

43:42.940 --> 43:45.540
If you basically make a cell of two hoon twigs,

43:45.540 --> 43:47.220
that's a cons.

43:47.220 --> 43:48.660
In general, as opposed to LISP,

43:48.660 --> 43:51.740
hoon is kind of more pair-oriented and more tuple-oriented.

43:51.740 --> 43:54.900
We don't throw in terminators everywhere willy-nilly.

43:54.900 --> 43:57.740
That's kind of more appropriate for a typed system, I think.

43:58.820 --> 44:02.380
Most twigs are tagged unions, so they have a head,

44:02.380 --> 44:05.300
which is a stem, which is a symbol, and a bulb,

44:05.300 --> 44:10.300
which is the tail, which is totally dependent on the stem.

44:10.860 --> 44:15.700
It's usually a tuple or a list of twigs,

44:15.700 --> 44:18.740
and let's see how that works in practice.

44:18.740 --> 44:20.460
Basically, there's a regular form.

44:20.460 --> 44:23.340
Again, most bulbs are tuples.

44:23.340 --> 44:26.460
Some are in-area, and there we do need a terminator.

44:26.460 --> 44:27.740
But what we do is we separate,

44:27.740 --> 44:30.460
we basically have two regular forms of syntax.

44:30.460 --> 44:32.580
One, which sort of looks like an expression,

44:32.580 --> 44:35.220
and one which looks like a statement.

44:35.220 --> 44:37.820
Those two ifs there are the same code,

44:38.700 --> 44:40.740
but they look a little different.

44:40.740 --> 44:43.460
What you do is you basically build a structure

44:43.460 --> 44:46.620
whose backbone is basically tall twigs,

44:46.620 --> 44:49.700
and then a tall twig can contain a flat one,

44:49.700 --> 44:50.900
but not vice versa.

44:50.900 --> 44:53.660
Basically, you're mimicking the kind of structure

44:53.660 --> 44:55.940
of imperative code that has this kind of statement

44:55.940 --> 44:58.460
expression duality, but it's all an expression.

44:58.460 --> 45:00.380
There's no imperative anything.

45:01.860 --> 45:03.340
Another thing that you're doing basically

45:03.340 --> 45:05.100
to control the right margin here,

45:05.100 --> 45:07.540
what you really want, you'll notice that C

45:07.540 --> 45:10.020
is at the same indentation as the if there.

45:10.020 --> 45:13.380
So basically, you want to lose no space,

45:13.380 --> 45:15.660
basically for your largest,

45:15.660 --> 45:17.780
hopefully C is the biggest branch,

45:17.780 --> 45:19.020
C is not the biggest branch,

45:19.020 --> 45:21.380
you want unless instead of if.

45:21.380 --> 45:24.300
But basically, you really, as a programmer,

45:24.300 --> 45:26.940
there's sort of an art of arranging these things,

45:26.940 --> 45:30.820
and you arrange them so that they flow down and not across.

45:30.820 --> 45:33.780
And it becomes very easy to read once you know it,

45:33.780 --> 45:34.820
like any language.

45:35.700 --> 45:39.020
And here's the funnest and most fancy part

45:39.020 --> 45:40.580
of our crazy syntax.

45:40.580 --> 45:42.900
So first of all, you've got regular forms

45:42.900 --> 45:43.740
and irregular forms.

45:43.740 --> 45:46.860
So in a regular form, arbitrary syntax,

45:46.860 --> 45:48.860
at least it's always flat,

45:48.860 --> 45:51.100
but that's just something you have to learn.

45:51.100 --> 45:54.180
One of the things I feel, if you look at the implementation

45:54.180 --> 45:57.900
of the Hoon compiler, what you'll see is that basically,

45:57.900 --> 46:00.180
the front end is actually as big as the back end,

46:00.180 --> 46:01.740
which is really quite unusual.

46:02.580 --> 46:05.540
And that's because basically, as a human being,

46:05.540 --> 46:08.860
you've got this great hardware for basically parsing.

46:08.860 --> 46:11.100
You don't have hardware for type inference.

46:11.100 --> 46:16.100
And so what we've done is basically the keyword form

46:18.220 --> 46:20.340
that you saw, I remember you saw those two forms

46:20.340 --> 46:23.820
of Hoon, one using keywords and one using runes.

46:23.820 --> 46:25.780
I'm gonna step forward and show you.

46:25.780 --> 46:28.060
Here are two forms of fizzbuzz.

46:28.060 --> 46:29.900
On the right you see runes.

46:29.900 --> 46:31.580
On the left you see keywords.

46:32.300 --> 46:33.580
Stepping back for a second,

46:33.580 --> 46:36.100
to make these basically pronounceable,

46:36.100 --> 46:39.100
what we've done is taken every ASCII character

46:39.100 --> 46:42.780
and given it a single syllable name.

46:42.780 --> 46:46.540
So where, if you see like if here,

46:46.540 --> 46:49.600
so if is the colon prefixed f there.

46:49.600 --> 46:51.460
That's also the symbol that's actually

46:51.460 --> 46:53.860
in the physical twig.

46:53.860 --> 46:57.260
You can also, as a syntax, you can say question colon.

46:57.260 --> 47:00.660
I wouldn't say question colon though, I would say what?

47:00.700 --> 47:02.620
Which is a lot faster than the same question colon,

47:02.620 --> 47:04.260
not to mention ampersand.

47:06.300 --> 47:10.020
So basically everyone who's learned this is like,

47:10.020 --> 47:11.020
why doesn't everyone know this

47:11.020 --> 47:13.380
and why do I have to say till like my normal friends

47:13.380 --> 47:14.420
when I could say sick?

47:15.340 --> 47:17.660
So hopefully it'll catch on,

47:17.660 --> 47:20.260
if it doesn't catch on at least it's useful in Hoon.

47:20.260 --> 47:24.340
So if we go back to this and we look at the right,

47:24.340 --> 47:28.180
you would say gate infest atom or you would say

47:28.180 --> 47:30.660
park his infest atom for the start of that.

47:31.860 --> 47:34.900
Let me give you 20 seconds to just observe

47:34.900 --> 47:36.260
the fizz buzzes here.

47:36.260 --> 47:37.660
I think that the one on the left

47:37.660 --> 47:39.940
should be at least pretty readable.

47:48.460 --> 47:50.140
Okay, so that's Hoon.

47:50.140 --> 47:52.580
Let's move up on up to Arvo.

47:52.580 --> 47:54.500
Now we're at the operating system level.

47:55.980 --> 47:58.100
The kernel of Arvo is a Hoon core

47:59.020 --> 48:00.580
and this is basically where we get back

48:00.580 --> 48:01.860
to our transition function.

48:01.860 --> 48:06.860
So this core basically has a very fixed battery structure.

48:07.100 --> 48:09.500
You can think of it as basically like a V table

48:09.500 --> 48:12.820
with a fixed structure.

48:12.820 --> 48:15.900
And the Unix interpreter talks to this core

48:15.900 --> 48:17.860
basically at the knock level.

48:17.860 --> 48:20.100
In the life cycle function it's defined at the knock level.

48:20.100 --> 48:24.220
So you basically just hard code those formula offsets.

48:25.300 --> 48:27.580
You can just fix that

48:27.580 --> 48:29.820
because you have only a few functions there.

48:29.820 --> 48:32.060
So basically this is how you have a system

48:32.060 --> 48:33.740
that can completely upgrade itself

48:33.740 --> 48:36.340
because again the whole life cycle function

48:36.340 --> 48:38.580
is defined entirely in knock.

48:39.540 --> 48:42.300
And basically let's say you get an event

48:42.300 --> 48:46.220
and that event is actually a source code update

48:46.220 --> 48:47.980
in the revision control system

48:47.980 --> 48:49.300
that gives you new source code

48:49.300 --> 48:52.100
for Hoon the language itself.

48:52.100 --> 48:54.580
As long as your new language can build a core

48:54.580 --> 48:57.100
that is shaped like the ones that your old language built,

48:57.100 --> 48:58.620
you can turn Hoon into anything.

49:00.820 --> 49:03.180
So ARBO is actually a very, very simple system.

49:03.180 --> 49:04.820
It's only a few hundred lines of code.

49:04.820 --> 49:07.780
It probably should be less than 600 actually.

49:07.780 --> 49:11.460
What it does is it does sort of an internal event cascade.

49:11.460 --> 49:13.780
So you're all familiar with you know,

49:13.780 --> 49:15.280
like you get an event from the outside

49:15.280 --> 49:18.180
and then you're like this happened internally.

49:18.180 --> 49:22.300
Events systems that are very complicated

49:22.300 --> 49:24.220
and deep like this one very quickly

49:24.220 --> 49:26.780
turn into spaghetti event logic.

49:26.780 --> 49:30.060
There's a duality between events and procedure calls

49:31.060 --> 49:36.060
in which basically an event is a transfer of control

49:36.100 --> 49:38.940
essentially and if you take that duality simply,

49:38.940 --> 49:41.880
the dual of a simple event system is go to.

49:42.780 --> 49:45.020
So basically when you have, you're like,

49:45.020 --> 49:46.620
oh through these events and then it's like

49:46.620 --> 49:48.380
the system will go here and it will go there

49:48.380 --> 49:51.420
and it was like why are you doing this?

49:51.420 --> 49:53.980
So essentially we have what you might call

49:53.980 --> 49:56.820
the equivalent of a go sub for anyone

49:56.820 --> 49:59.060
no basic in this room, anyone?

49:59.060 --> 50:00.220
Wow, that's awesome.

50:01.780 --> 50:03.100
I don't feel so old now.

50:05.580 --> 50:09.800
So you have essentially the equivalent of subroutines

50:09.800 --> 50:12.940
in an event kind of model and you have basically

50:12.940 --> 50:15.580
this kind of causal model which I don't wanna get super into

50:15.580 --> 50:17.100
but definitely if you're building

50:17.100 --> 50:18.580
JavaScript event frameworks I think

50:18.580 --> 50:20.180
you could use something like this.

50:20.180 --> 50:21.920
It also has a global type referentially

50:21.960 --> 50:26.160
transparent namespace so basically use any data

50:26.160 --> 50:28.400
in the world as if it was a type constant.

50:28.400 --> 50:30.040
That's kind of nice.

50:30.040 --> 50:34.000
Most of the work of ARVO is done by what are called

50:34.000 --> 50:36.040
veins which are essentially kernel modules

50:36.040 --> 50:38.360
and they have essentially the same kind of core-like

50:38.360 --> 50:40.880
structure as the ARVO core itself.

50:40.880 --> 50:44.120
So these are loaded from source obviously at runtime.

50:44.120 --> 50:47.400
Let me just run through a few of the things we do.

50:47.400 --> 50:49.280
So encrypted packing networking,

50:49.280 --> 50:50.360
we'll talk about that in a sec.

50:50.360 --> 50:53.920
Timer is obviously clay which is like a typed git.

50:55.000 --> 50:56.800
Console obviously air.

50:56.800 --> 50:59.800
We'll see that hopefully driving a demo in a second.

50:59.800 --> 51:01.640
A function build system and I don't really know

51:01.640 --> 51:04.520
how to describe that and an application engine.

51:04.520 --> 51:07.520
And the applications again are cores within Gaul.

51:07.520 --> 51:09.440
So you have sort of these kind of multiple levels

51:09.440 --> 51:10.720
of virtualization.

51:10.720 --> 51:12.200
When you're running user level code

51:12.200 --> 51:14.520
you're actually running it in a virtual knock.

51:14.520 --> 51:17.640
And that virtual knock has an extra instruction.

51:17.640 --> 51:20.120
It has an instruction 11 that de-references

51:20.120 --> 51:22.080
the basically global namespace.

51:22.080 --> 51:24.520
So you're really like de-referencing the whole world

51:24.520 --> 51:25.680
as if it was a constant.

51:27.120 --> 51:30.760
Again that due to the way knock works

51:30.760 --> 51:33.040
you can basically virtualize at any depth

51:33.040 --> 51:35.600
of virtual interpreters without any real cost.

51:35.600 --> 51:37.120
Cause you're actually in implementation

51:37.120 --> 51:38.120
just setting a flag.

51:39.760 --> 51:42.840
All right that's a very, very broad overview of ARVO.

51:42.840 --> 51:45.240
Let's go back to the top and basically look

51:45.240 --> 51:48.600
at what Erbit is doing at the top level.

51:48.600 --> 51:51.760
So we're sort of back to the user level here.

51:51.760 --> 51:53.680
There's fortunately nothing else in the stack

51:53.680 --> 51:57.520
besides NACUN and ARVO and at the top level

51:57.520 --> 51:59.680
what users really see the most in Erbit

51:59.680 --> 52:01.360
is the public key infrastructure

52:01.360 --> 52:03.200
of kind of the identity model.

52:03.200 --> 52:06.800
Basically one Erbit is one event history.

52:06.800 --> 52:08.360
It's one state, it's one instance

52:08.360 --> 52:09.880
and it has one identity.

52:10.960 --> 52:13.160
And you know we basically establish that identity

52:13.160 --> 52:16.640
when we're booting the Erbit.

52:16.640 --> 52:18.000
What exactly is this identity?

52:18.040 --> 52:18.880
What does it mean?

52:20.240 --> 52:23.200
So basically again the kind of the great thing

52:23.200 --> 52:24.680
about doing things from a clean slate

52:24.680 --> 52:26.600
is you really get to think from scratch

52:26.600 --> 52:28.480
which is kind of neat.

52:28.480 --> 52:30.080
And one thing about networking

52:30.080 --> 52:31.880
that is done kind of in a conventional

52:31.880 --> 52:34.320
in the internet certainly is you have these two levels

52:34.320 --> 52:37.240
of well that could spit our audio.

52:38.760 --> 52:42.200
You have these two levels of addressing.

52:42.200 --> 52:44.160
So you have IP addressings and you have DNS.

52:44.160 --> 52:45.920
And the DNS is human meaningful

52:45.920 --> 52:48.120
and IP addresses are routable addresses.

52:48.120 --> 52:50.800
So in Erbit this is compressed into one layer.

52:50.800 --> 52:52.240
So you actually have one layer

52:52.240 --> 52:55.480
which is both a human memorable layer

52:55.480 --> 52:58.760
and it's both a routing address and a name.

52:58.760 --> 53:01.920
And it's actually your personal identity as well.

53:01.920 --> 53:04.080
It's also the base of a path

53:04.080 --> 53:06.040
in the global immutable namespace.

53:06.040 --> 53:07.840
So there's a problem called Zikos Triangle.

53:07.840 --> 53:10.240
Does anyone in the room know Zikos Triangle?

53:11.400 --> 53:14.280
We're definitely not in network land here.

53:14.280 --> 53:15.480
That's fine.

53:15.520 --> 53:17.760
Zikos Triangle basically says there are three things

53:17.760 --> 53:20.400
that you want out of an identity system.

53:20.400 --> 53:24.760
You want the names to be human meaningful.

53:24.760 --> 53:26.080
You want them to be secure

53:26.080 --> 53:28.200
and you want them to be decentralized.

53:28.200 --> 53:30.640
And you can get only two of those three things.

53:30.640 --> 53:33.400
So Facebook, Secure, I hope,

53:33.400 --> 53:36.800
human meaningful names definitely decentralized,

53:36.800 --> 53:37.640
not at all.

53:39.480 --> 53:44.320
BitTorrent, decentralized, yes, human meaningful names, no.

53:45.240 --> 53:48.000
And so there's basically a problem there

53:48.000 --> 53:51.560
that as an OS guy, what they teach us to do

53:51.560 --> 53:54.400
is find the trade off and almost solve the problem.

53:54.400 --> 53:57.480
So the trade off that we make here is basically,

53:57.480 --> 54:00.840
the trivial solution for an identity system of this scale

54:00.840 --> 54:03.000
is basically to say your identity

54:03.000 --> 54:05.240
is the hash of your initial public key.

54:05.240 --> 54:08.000
Very easy, IPFS uses this, very easy to do.

54:09.520 --> 54:11.600
How do you remember a 128-bit hash?

54:12.720 --> 54:13.560
You don't.

54:14.600 --> 54:17.040
And so what we're looking for is basically a way

54:17.040 --> 54:19.720
to make these names that are memorable,

54:19.720 --> 54:20.560
but not meaningful.

54:20.560 --> 54:24.920
So first trick we do is we basically come up

54:24.920 --> 54:27.200
with a new way of representing numbers.

54:27.200 --> 54:28.760
Many things like this have been done before,

54:28.760 --> 54:32.320
not super original, but we do a phonemic base 256.

54:32.320 --> 54:34.280
So if you look at my three numbers there,

54:34.280 --> 54:36.600
there's a hexadecimal number in urban syntax,

54:36.600 --> 54:39.600
there's an in-hune syntax, there's an IP address.

54:39.600 --> 54:41.160
We also have a syntax for that.

54:41.160 --> 54:45.160
And then there's 128, 42, 19, 109,

54:45.160 --> 54:46.520
versus patent of tarlott.

54:46.520 --> 54:48.760
Patent of tarlott is a lot easier to remember.

54:48.760 --> 54:52.160
It's kind of like a human name in a foreign language.

54:52.160 --> 54:53.840
People actually bond with these names

54:53.840 --> 54:55.520
very easily and very quickly.

54:55.520 --> 54:57.640
I'm a task-fine part of it, I think of myself.

54:57.640 --> 54:59.440
People say task-fine, I turn around.

55:00.760 --> 55:05.320
And so of course that's a 32-bit number,

55:05.320 --> 55:07.800
which is a lot shorter than a 128-bit number.

55:07.800 --> 55:11.120
So how you get from 128 bits to 32

55:11.120 --> 55:12.000
is tricky.

55:12.000 --> 55:14.320
So you can actually do the 128-bit hash

55:14.320 --> 55:16.040
of a public key thing, that's called a comment.

55:16.040 --> 55:18.320
Anyone can create their own urban identity.

55:18.320 --> 55:21.760
That is a completely non-scarce resource.

55:22.760 --> 55:26.120
And it's also, there's just no way

55:26.120 --> 55:29.040
of making a 128-bit number memorable.

55:29.040 --> 55:30.360
So what you notice is that basically

55:30.360 --> 55:32.160
the most valuable real estate in this

55:32.160 --> 55:35.280
is down at the bottom of this whole 128-bit space.

55:35.280 --> 55:38.840
And in fact, you can overlay a 128-bit hash

55:38.840 --> 55:40.720
will never be a 64-bit number.

55:40.720 --> 55:42.560
So you can overlay a completely different

55:42.560 --> 55:45.840
64-bit identity scheme on the bottom of this.

55:45.840 --> 55:49.800
So your 64-bit scheme is distributed hierarchically.

55:49.800 --> 55:52.400
It's basically, it's cryptographic property

55:52.400 --> 55:55.000
a little bit like Bitcoin, but it doesn't use a blockchain.

55:55.000 --> 55:58.360
So the way it works is that a 64-bit chip

55:58.360 --> 56:01.600
is the initial key is signed by its 32-bit parent,

56:01.600 --> 56:04.080
basically the half width prefix.

56:04.080 --> 56:08.040
The 32-bit chip is signed by a 16-bit parent.

56:08.040 --> 56:10.200
The 16-bit chip, which is a star,

56:10.200 --> 56:11.840
is signed by its 8-bit parent.

56:11.840 --> 56:15.160
And the fingerprints of 8-bit galaxies

56:15.160 --> 56:18.040
are hard-coded in the kernel source.

56:18.040 --> 56:21.280
This is what we call a pre-mind in the Bitcoin world.

56:24.680 --> 56:28.880
So basically again, this is a PKI

56:28.880 --> 56:32.760
in which revocation and renewal are the same thing.

56:32.760 --> 56:34.720
So basically when you wanna change a key,

56:34.720 --> 56:37.320
whether that's because you wanna give someone else

56:37.320 --> 56:40.320
this identity or you just feel like your key

56:40.320 --> 56:41.560
might be a little bit compromised,

56:41.560 --> 56:44.120
you basically sign the new key with the old key.

56:44.120 --> 56:45.120
Unless you're a moon,

56:45.120 --> 56:47.400
moon should not be floating around unaccompanied.

56:47.400 --> 56:48.640
You sign your own updates.

56:48.640 --> 56:52.160
So basically your parent signs the first key,

56:52.160 --> 56:53.080
but you sign the second.

56:53.080 --> 56:55.720
So you're genuinely independent here.

56:55.720 --> 56:58.840
The main sort of question in that is basically

56:58.840 --> 57:01.480
how these updates get distributed.

57:01.480 --> 57:03.480
Fortunately, there's a lot fewer of them

57:03.480 --> 57:06.600
than sort of the equivalent, which is like a Bitcoin spend.

57:06.680 --> 57:09.480
So there's a lot more room for basically

57:09.480 --> 57:13.360
just sort of handling it in a kind of less aggressive way

57:13.360 --> 57:15.000
than Bitcoin does.

57:15.000 --> 57:16.360
But it's the same basic principle.

57:16.360 --> 57:18.880
Your identity is definitely cryptographic property.

57:18.880 --> 57:21.320
You own it, you can sell it, et cetera.

57:21.320 --> 57:24.400
And there's the 32-bit point

57:24.400 --> 57:27.000
is clearly kind of the right point for human beings.

57:27.000 --> 57:29.400
One of the things about having these 32-bit names

57:29.400 --> 57:32.840
as your names is basically like in any situation

57:32.840 --> 57:34.880
in which people are actually using this system,

57:34.880 --> 57:35.720
some people are using it,

57:35.720 --> 57:38.320
but hopefully everyone will be using it.

57:38.320 --> 57:39.480
You have a scarcity there.

57:39.480 --> 57:40.640
You only have four billion.

57:40.640 --> 57:44.280
And so the price of the scarce resource cannot fault a zero.

57:44.280 --> 57:48.000
So one of the things about that situation

57:48.000 --> 57:50.040
is that the basic problem,

57:50.040 --> 57:51.560
one of the reasons why my mother

57:51.560 --> 57:53.080
can't run her own internet server

57:53.080 --> 57:55.680
is that the internet is basically, you know,

57:55.680 --> 57:56.880
a digital mazizly.

57:56.880 --> 57:59.620
I mean, it's just all kinds of scum and villainy are out there.

57:59.620 --> 58:01.960
And when you get a packet from someone,

58:01.960 --> 58:04.880
you have no way of ascertaining the reputation

58:04.880 --> 58:07.080
of this IP address.

58:07.080 --> 58:09.960
Yes, there are IP address reputation systems in practice.

58:09.960 --> 58:12.040
They basically turn off all residential things

58:12.040 --> 58:14.180
and don't let them send email.

58:14.180 --> 58:16.800
But the ownership of an IP address is not clear.

58:16.800 --> 58:19.920
And so you can't really use, an IP address is not property.

58:19.920 --> 58:23.180
You can't really use it as a mechanism in this way.

58:23.180 --> 58:24.880
When you basically have an address

58:24.880 --> 58:25.880
that's a scarce resource,

58:25.880 --> 58:28.480
let's say you paid 10 bucks for your planet.

58:28.480 --> 58:31.160
Okay, I paid 10 bucks so I wanna be able to compute.

58:32.160 --> 58:33.680
Then you're gonna send messages

58:33.680 --> 58:34.760
directly from that planet.

58:34.760 --> 58:36.200
You're definitely not gonna send them through

58:36.200 --> 58:38.640
like Google or some MTU, like, you know.

58:39.640 --> 58:42.920
And if you spam, like someone's like,

58:42.920 --> 58:46.120
hey, I got a spam from Taskline Partive.

58:46.120 --> 58:47.880
And you go on a blacklist like this.

58:47.880 --> 58:50.560
And basically your 10 bucks is now worthless

58:50.560 --> 58:52.600
because no one will accept anything

58:52.600 --> 58:54.000
from that planet anymore.

58:54.000 --> 58:56.640
So essentially in order, like your spam better

58:56.640 --> 58:59.320
have made you 10 bucks or like, you know,

58:59.320 --> 59:00.960
and that's a pretty high bar for spam.

59:00.960 --> 59:03.840
And so basically just by having this sort of limited

59:04.760 --> 59:08.120
supply of real estate that's treated as digital property,

59:08.120 --> 59:10.320
you basically have the basis for building

59:10.320 --> 59:12.200
a reputation system that works

59:12.200 --> 59:14.680
because the real killer of reputation systems

59:14.680 --> 59:16.560
is an infinite supply of identities.

59:16.560 --> 59:18.320
Because you have this problem where you're like,

59:18.320 --> 59:19.920
I've never seen this identity before.

59:19.920 --> 59:21.160
Maybe it's a new user.

59:21.160 --> 59:22.240
I really wanna say hi.

59:22.240 --> 59:23.880
Maybe it's that spammer I just banned.

59:23.880 --> 59:25.200
I really don't wanna say hi.

59:25.200 --> 59:26.960
That's kind of an unsolvable problem.

59:26.960 --> 59:30.320
And so basically I think this is one of the things like,

59:30.320 --> 59:33.320
you know, nobody, a tiny young network like Erbit,

59:33.320 --> 59:34.960
nobody abuses.

59:34.960 --> 59:37.560
But, you know, in the future, as you grow,

59:37.560 --> 59:38.880
basically you become a target.

59:38.880 --> 59:40.320
And so having a system like this

59:40.320 --> 59:41.680
helps you not be a target.

59:43.280 --> 59:45.560
Let's fall back on the point of all this.

59:46.720 --> 59:49.240
Inventing new system software is always a bad idea.

59:49.240 --> 59:51.120
It's a terrible, terrible thing to do.

59:51.120 --> 59:53.240
Never, never, never do this.

59:54.680 --> 59:59.680
So let's go back to basically the goal of this project,

59:59.720 --> 01:00:01.080
which is to build a personal server.

01:00:01.080 --> 01:00:03.360
So a personal server is gonna be a social server.

01:00:03.360 --> 01:00:05.120
So if you have a real personal server

01:00:05.120 --> 01:00:06.520
that's a real social server,

01:00:06.520 --> 01:00:08.240
when I socialize with you,

01:00:08.240 --> 01:00:09.160
in the one nearer case,

01:00:09.160 --> 01:00:11.080
barring like weird identity games,

01:00:11.080 --> 01:00:13.360
I shouldn't be sending packets directly to you.

01:00:13.360 --> 01:00:15.600
I shouldn't be sending packets to some Facebook thing

01:00:15.600 --> 01:00:17.080
over there that then sends them to you.

01:00:17.080 --> 01:00:19.960
I should be able to basically actually socialize

01:00:19.960 --> 01:00:22.640
in a distributed way using distributed protocols.

01:00:22.640 --> 01:00:25.960
And one of the things about the way we compute today,

01:00:25.960 --> 01:00:29.000
and the reason basically we don't do this,

01:00:29.040 --> 01:00:30.560
is that if you look at the difficulty

01:00:30.560 --> 01:00:32.040
of distributed programming,

01:00:32.040 --> 01:00:34.080
let's say you're building like a tic-tac-toe app,

01:00:34.080 --> 01:00:36.560
compare the difficulty of building distributed tic-tac-toe

01:00:36.560 --> 01:00:39.000
with the difficulty of building centralized tic-tac-toe.

01:00:39.000 --> 01:00:41.440
Centralized tic-tac-toe, my score,

01:00:41.440 --> 01:00:42.400
your score, they're variables.

01:00:42.400 --> 01:00:44.280
They're in the same data structure.

01:00:44.280 --> 01:00:45.120
It's easy.

01:00:45.120 --> 01:00:47.240
Then suddenly you're building distributed tic-tac-toe

01:00:47.240 --> 01:00:49.760
and you're like have to apply to the ITF for an RFC

01:00:49.760 --> 01:00:51.960
for your TTTTP, right?

01:00:51.960 --> 01:00:55.920
And it's just like six orders of magnitude different

01:00:55.920 --> 01:00:57.080
in difficulty.

01:00:57.080 --> 01:00:59.040
And if you wanna ask why we don't have

01:00:59.040 --> 01:01:00.480
a decentralized internet,

01:01:00.480 --> 01:01:03.160
basically the reason we don't have a decentralized internet

01:01:03.160 --> 01:01:06.600
is that decentralized programming is too damn hard.

01:01:06.600 --> 01:01:08.560
So basically you need to solve this problem

01:01:08.560 --> 01:01:12.080
if you're gonna build anything like a true personal server.

01:01:12.080 --> 01:01:13.680
So let me talk a little bit about

01:01:13.680 --> 01:01:15.360
the kind of programming or experience

01:01:15.360 --> 01:01:17.400
of where we're aiming to get with this.

01:01:17.400 --> 01:01:19.200
This is actually my next last slide.

01:01:20.400 --> 01:01:21.840
So let's see, first of all,

01:01:21.840 --> 01:01:22.960
you're programming in the system.

01:01:22.960 --> 01:01:25.120
You can dereference a global immutable namespace.

01:01:25.120 --> 01:01:27.040
So basically use any data in the world

01:01:27.040 --> 01:01:28.760
as if it was a typed constant.

01:01:28.760 --> 01:01:30.280
That's kinda nice.

01:01:30.280 --> 01:01:31.760
Your application state is permanent.

01:01:31.760 --> 01:01:35.080
You don't need a database to basically flush stuff out too

01:01:35.080 --> 01:01:38.560
when for your data actually exist.

01:01:40.000 --> 01:01:41.280
When you do an update,

01:01:41.280 --> 01:01:43.440
your updates basically come through reactively

01:01:43.440 --> 01:01:46.600
through the, you have basically a revision control system

01:01:46.600 --> 01:01:48.720
that's clay or I didn't talk much about that,

01:01:48.720 --> 01:01:52.160
but it's basically a revision control system with hooks.

01:01:52.160 --> 01:01:55.100
And so you're like, oh, I got a source code update

01:01:55.100 --> 01:01:56.080
for this thing I'm running.

01:01:56.120 --> 01:01:59.040
And then I'm like, oh, I need to change out the code.

01:01:59.040 --> 01:02:01.200
Oh, gee, the type of my data change.

01:02:01.200 --> 01:02:04.280
So I need to have a type adapter in there

01:02:04.280 --> 01:02:06.440
to make that work.

01:02:06.440 --> 01:02:07.720
That all works great.

01:02:08.680 --> 01:02:11.380
A very different experience from kind of updates

01:02:11.380 --> 01:02:13.440
or upgrades in a lot of systems.

01:02:14.960 --> 01:02:17.880
When you get to messaging patterns, basically,

01:02:17.880 --> 01:02:21.160
you've got a poke, which is a forward, basically,

01:02:21.160 --> 01:02:23.840
essentially an RTC without a return.

01:02:23.840 --> 01:02:25.880
And you've got a subscription model.

01:02:25.880 --> 01:02:28.360
Let's look at basically what we get with pokes

01:02:28.360 --> 01:02:29.720
for a moment.

01:02:29.720 --> 01:02:32.080
Number one, you get exactly once delivery.

01:02:32.080 --> 01:02:35.160
You've probably heard that exactly once delivery is impossible.

01:02:35.160 --> 01:02:38.200
It was a great blog post about that a few months ago.

01:02:38.200 --> 01:02:40.160
Exactly once delivery and message semantics

01:02:40.160 --> 01:02:43.080
actually is possible if all of your entities

01:02:43.080 --> 01:02:44.400
are single level stores.

01:02:44.400 --> 01:02:47.120
And if they can basically run permanent sessions.

01:02:47.120 --> 01:02:49.120
So you have a permanent session and you're like,

01:02:49.120 --> 01:02:52.880
oh, I expect message seven from you.

01:02:52.880 --> 01:02:55.720
Well, you're only gonna get message seven once.

01:02:55.720 --> 01:02:57.520
Where that breaks down in this kind of system

01:02:57.520 --> 01:02:59.080
where you have transient and permanent state

01:02:59.080 --> 01:03:01.480
is you reboot the computer and then you're like,

01:03:01.480 --> 01:03:03.480
do I expect message seven or message six?

01:03:03.480 --> 01:03:08.480
Or you have these idempotence problems.

01:03:08.520 --> 01:03:10.620
So every message is a transaction

01:03:10.620 --> 01:03:13.440
in this kind of distributed programming environment.

01:03:13.440 --> 01:03:16.240
If the transaction succeeds, there's no return data.

01:03:16.240 --> 01:03:18.480
So it's a one way transaction.

01:03:18.480 --> 01:03:20.320
Your messages are automatically type checked

01:03:20.320 --> 01:03:22.580
and validated on the receiving side.

01:03:22.580 --> 01:03:25.120
You can even do basically protocol type updates

01:03:25.120 --> 01:03:28.200
on the live network and not propagate errors to the user.

01:03:30.400 --> 01:03:33.280
The data that you get over the wire is passed to you typed.

01:03:33.280 --> 01:03:34.920
You basically just get it as an argument

01:03:34.920 --> 01:03:36.620
and it's a typed value.

01:03:37.760 --> 01:03:39.480
We do end-to-end acknowledgments,

01:03:39.480 --> 01:03:41.600
which basically means there's kind of a single error mode.

01:03:41.600 --> 01:03:43.320
So when you're doing acknowledgments,

01:03:43.320 --> 01:03:47.000
like think about you're doing a normal RPC or HTTP.

01:03:47.000 --> 01:03:47.840
Something goes wrong.

01:03:47.840 --> 01:03:48.840
Well, what could go wrong?

01:03:48.840 --> 01:03:50.300
Your socket could break.

01:03:50.300 --> 01:03:52.100
You could get an HTTP error.

01:03:52.100 --> 01:03:54.880
You could get an error at the RPC layer.

01:03:54.880 --> 01:03:56.400
What do you even do with half of these things?

01:03:56.400 --> 01:03:59.360
Like there are different kinds of error.

01:03:59.360 --> 01:04:02.400
And that basically is just very, very difficult to handle.

01:04:02.400 --> 01:04:04.160
So if you're basically doing acknowledgments

01:04:04.160 --> 01:04:05.760
at an end-to-end level,

01:04:05.760 --> 01:04:08.640
that means the packet level act that you send back

01:04:08.640 --> 01:04:12.560
is actually the transaction acknowledgement

01:04:12.560 --> 01:04:14.040
that you succeeded or failed.

01:04:15.360 --> 01:04:17.120
Messages are queued by the sender.

01:04:17.120 --> 01:04:19.920
Obviously, this is a P2P network.

01:04:19.920 --> 01:04:23.800
It traverses NAT and of course it's authenticated

01:04:23.840 --> 01:04:25.080
and encrypted.

01:04:25.080 --> 01:04:27.720
Your subscriptions are sending diffs.

01:04:27.720 --> 01:04:29.520
Those again are typed.

01:04:29.520 --> 01:04:33.440
So this is a very different distributed programming experience

01:04:33.440 --> 01:04:38.440
than your sort of normal, I'm writing this in node experience.

01:04:39.080 --> 01:04:41.720
And our experience is basically it's,

01:04:41.720 --> 01:04:45.000
you just do things and they pretty much just work.

01:04:45.000 --> 01:04:47.080
What is the status of this system?

01:04:47.080 --> 01:04:50.160
It's about 30,000 lines of Coon, including basic apps.

01:04:50.160 --> 01:04:51.640
It's totally open source.

01:04:51.640 --> 01:04:53.480
You can go to urban.org.

01:04:53.480 --> 01:04:56.080
And which is served by Arbit, although we cash it.

01:04:57.600 --> 01:05:02.520
And yeah, I mean, it essentially works.

01:05:02.520 --> 01:05:04.080
We were on occasional global flag days,

01:05:04.080 --> 01:05:06.880
so you might not want to move your business onto this system.

01:05:09.080 --> 01:05:13.480
But yeah, I mean, when creating a system like this,

01:05:13.480 --> 01:05:15.920
involves a lot of rewriting stuff over and over again

01:05:15.920 --> 01:05:17.440
until it actually works right.

01:05:18.320 --> 01:05:22.000
And we're basically getting to the end of that process

01:05:22.000 --> 01:05:24.920
and we're kind of close to being ready to sell

01:05:24.920 --> 01:05:26.400
some address space to the public.

01:05:26.400 --> 01:05:30.120
Let me do a quick demo of this system

01:05:30.120 --> 01:05:33.320
to see if it's actually working.

01:05:33.320 --> 01:05:35.680
I'm actually doing this over my,

01:05:37.440 --> 01:05:39.360
so here is, you're in Arbit.

01:05:41.400 --> 01:05:42.880
Live, yes, we're live.

01:05:42.880 --> 01:05:45.440
That bounced off the server and came back.

01:05:45.440 --> 01:05:49.240
So that's basically a simple console talk app.

01:05:50.240 --> 01:05:55.440
Hello from, a little bit slow on the typing there.

01:05:55.440 --> 01:05:57.840
Our console path is pretty complicated

01:05:57.840 --> 01:05:59.840
and we could use some serious optimization.

01:05:59.840 --> 01:06:03.440
Let me see if I can bring up the web UI of talk.

01:06:03.440 --> 01:06:05.720
Ah, yes, here is a web app.

01:06:08.080 --> 01:06:10.240
Let me get it fully up.

01:06:12.040 --> 01:06:13.360
Looks like it needs a reload,

01:06:13.360 --> 01:06:14.920
which it actually should not.

01:06:16.400 --> 01:06:18.320
Hate it when that happens.

01:06:18.320 --> 01:06:22.360
But here, basically, you're seeing a web UI.

01:06:22.360 --> 01:06:23.200
Do you want to say something?

01:06:23.200 --> 01:06:24.560
Anyone want to say something?

01:06:24.560 --> 01:06:26.800
I'll just be, hello from William the Comfort Inn.

01:06:32.200 --> 01:06:34.040
Boulder is beautiful.

01:06:34.040 --> 01:06:39.040
So, beautiful with an extra K.

01:06:40.600 --> 01:06:43.960
And this has to bounce off the server to get back.

01:06:43.960 --> 01:06:47.240
Actually, the Colorado's router

01:06:47.280 --> 01:06:52.280
seems to be blocking my transition directly.

01:06:53.520 --> 01:06:57.080
But, you know, I'm doing it via Verizon, so it works fine.

01:06:57.080 --> 01:06:59.880
TaskFind Partive is actually running on this laptop here.

01:07:01.960 --> 01:07:03.800
Yeah, so that was a very simple demo

01:07:03.800 --> 01:07:05.560
and now, any questions?

01:07:05.560 --> 01:07:06.400
Yes.

01:07:06.400 --> 01:07:08.760
So, does Richard Stallman know about this?

01:07:08.760 --> 01:07:09.600
I don't think so.

01:07:09.600 --> 01:07:13.160
Because I don't think this would really get

01:07:13.160 --> 01:07:15.440
to what Richard Stallman would like to see.

01:07:15.440 --> 01:07:17.640
Yeah, I think there's a lot of people

01:07:17.640 --> 01:07:20.360
who are tired of this sort of Facebook-ization

01:07:20.360 --> 01:07:21.520
of the internet.

01:07:21.520 --> 01:07:24.800
And this is definitely also, I mean, yeah,

01:07:24.800 --> 01:07:25.640
is this a list?

01:07:25.640 --> 01:07:27.240
Is this basically E-Max?

01:07:27.240 --> 01:07:29.680
At a certain level, it's basically E-Max.

01:07:29.680 --> 01:07:33.920
So, yeah, you know, all right,

01:07:33.920 --> 01:07:35.640
we're at a one-minute warning here.

01:07:35.640 --> 01:07:37.800
Time for maybe one or two more questions.

01:07:39.400 --> 01:07:40.360
Be over?

01:07:40.360 --> 01:07:41.440
Yes?

01:07:41.440 --> 01:07:43.640
So, I feel like maybe you're trying to

01:07:43.640 --> 01:07:46.440
talk to me confusing, like, do you use the word twig,

01:07:46.440 --> 01:07:48.280
but like, I'll be referred to as a nasty?

01:07:48.280 --> 01:07:49.120
Mm-hmm.

01:07:49.120 --> 01:07:50.160
Is there a particular reason for, like,

01:07:50.160 --> 01:07:51.920
these more or less travel elements?

01:07:52.920 --> 01:07:55.400
Yeah, I mean, the reason is basically you're,

01:07:56.320 --> 01:07:59.840
you want to use the word that the actual source code uses.

01:07:59.840 --> 01:08:01.800
Is the reason for that being the convention

01:08:01.800 --> 01:08:03.720
and the source code, is that a good reason?

01:08:03.720 --> 01:08:05.360
Maybe not necessarily.

01:08:05.360 --> 01:08:06.880
It certainly makes things kind of tire

01:08:06.880 --> 01:08:08.200
and more readable in a way.

01:08:08.200 --> 01:08:10.560
There's an aesthetic, which kind of,

01:08:10.560 --> 01:08:12.040
there's an aesthetic of short names,

01:08:12.040 --> 01:08:14.480
which works fairly well in kind of a functional environment,

01:08:14.480 --> 01:08:17.160
which wouldn't work in an imperative environment.

01:08:17.160 --> 01:08:19.720
But, yeah, I mean, you know, the criticism

01:08:19.720 --> 01:08:21.120
that this is a little more obfuscated

01:08:21.120 --> 01:08:22.240
than it has to be, is certainly one

01:08:22.240 --> 01:08:24.240
that I think holds a little bit of water.

01:08:26.280 --> 01:08:28.160
So, when you chat with the one message

01:08:28.160 --> 01:08:29.760
and so there's a browser,

01:08:29.760 --> 01:08:33.920
how do you go through the centralized events?

01:08:33.920 --> 01:08:37.800
So, that is basically, that, if you saw,

01:08:37.800 --> 01:08:39.920
if I turn on debugging, here,

01:08:40.920 --> 01:08:45.920
turn on debugging, and you'll see a lot of...

01:08:49.560 --> 01:08:52.320
Okay, so what's actually happening is that packet,

01:08:52.320 --> 01:08:55.400
so I'm logged into, I could log in via

01:08:55.400 --> 01:08:57.120
taskfinepartive.erb.org, here,

01:08:57.120 --> 01:08:58.840
let me turn this off, this is horrible.

01:08:59.840 --> 01:09:04.280
And I could log in via taskfinepartive.erb.org

01:09:04.280 --> 01:09:06.880
and be proxied by basically the star

01:09:06.960 --> 01:09:11.960
that is, taskfinepartive is a planet of.

01:09:11.960 --> 01:09:13.600
But, basically, I'm in a channel,

01:09:13.600 --> 01:09:15.240
that channel is hosted on DOSNEC,

01:09:15.240 --> 01:09:18.640
which is the star that I'm responsible to.

01:09:18.640 --> 01:09:21.920
And so, basically, that packet is going up to DOSNEC,

01:09:21.920 --> 01:09:23.600
coming back to me, and then it's going

01:09:23.600 --> 01:09:26.000
over localhost8080 to the browser.

01:09:28.200 --> 01:09:29.880
All right, any more questions?

01:09:29.880 --> 01:09:31.560
I think we're time.

01:09:32.560 --> 01:09:33.560
Thank you.

01:09:33.560 --> 01:09:34.560
Thank you.

01:09:34.560 --> 01:09:35.560
Thank you.

01:09:35.560 --> 01:09:36.560
Thank you.

