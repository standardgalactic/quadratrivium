1
00:00:00,000 --> 00:00:06,960
Hello.

2
00:00:06,960 --> 00:00:11,720
My name is Jimmy Cupple, and I live a dual life.

3
00:00:11,720 --> 00:00:15,840
By day, I work at MIT, I'm a researcher.

4
00:00:15,840 --> 00:00:19,480
I work on program synthesis, programs that write programs.

5
00:00:19,480 --> 00:00:25,120
By night, I lead workshops teaching software engineers like yourself how to write better

6
00:00:25,120 --> 00:00:26,120
code.

7
00:00:26,720 --> 00:00:33,320
Today I'm going to talk about something from intersection of both worlds.

8
00:00:33,320 --> 00:00:37,000
Software engineering advice today is confusing.

9
00:00:37,000 --> 00:00:43,120
For anything you read online, you'll find someone else arguing the opposite.

10
00:00:43,120 --> 00:00:48,640
And today I want to ask the question, how do we find a source of truth in software engineering

11
00:00:48,640 --> 00:00:51,080
advice?

12
00:00:51,080 --> 00:00:55,400
This whole situation reminds me of another source of truth.

13
00:00:55,400 --> 00:01:00,200
How do you prevent scurvy?

14
00:01:00,200 --> 00:01:04,760
Scurvy is an ancient disease caused by vitamin C deficiency.

15
00:01:04,760 --> 00:01:10,360
And after thousands of years of deaths, finally the 1700s, a British scientist named James

16
00:01:10,360 --> 00:01:18,240
Lynde, proved in an experiment, the cure, eat citrus.

17
00:01:18,240 --> 00:01:24,520
And so by the end of the century, the Royal Navy had started requiring all of their sailors

18
00:01:24,600 --> 00:01:26,840
to drink lemon juice.

19
00:01:26,840 --> 00:01:31,080
Scurvy rates went from crippling to almost none.

20
00:01:31,080 --> 00:01:36,280
But then, in the 19th century, they lost the cure.

21
00:01:36,280 --> 00:01:42,920
They didn't understand it well enough, they thought, lemons, why not limes, big mistake.

22
00:01:42,920 --> 00:01:50,240
As a result, there were multiple voyages to the polls, as late as 1910, in which everyone

23
00:01:50,240 --> 00:01:53,320
got scurvy and people died.

24
00:01:53,320 --> 00:01:58,560
Now imagine that you are an 18th century sailor, and you ask the powers that be, how

25
00:01:58,560 --> 00:02:03,680
can I prevent scurvy, and the answer comes, eat citrus.

26
00:02:03,680 --> 00:02:11,040
But wait, lemons, not limes, and wait, do not boil it, and wait, do not store the juice

27
00:02:11,040 --> 00:02:12,040
in copper.

28
00:02:12,040 --> 00:02:16,800
If you store it in copper, it's worthless.

29
00:02:16,800 --> 00:02:20,520
This is kind of starting to sound like witchdoctry.

30
00:02:20,520 --> 00:02:22,760
Now compare soft engineering advice.

31
00:02:22,760 --> 00:02:29,200
But first, so, before I get there, so from this, I coined the term citrus advice.

32
00:02:29,200 --> 00:02:34,920
The advice to eat citrus is good advice to save people, but it was not precise enough

33
00:02:34,920 --> 00:02:40,640
to capture the reality, and so it came with this long list of caveats that made it hard

34
00:02:40,640 --> 00:02:41,640
to use.

35
00:02:41,640 --> 00:02:48,280
The precise advice is to get vitamin C. And while it took about 200 years to get from

36
00:02:48,280 --> 00:02:54,000
citrus to vitamin C, this is the ideal to be aiming for, the simple thing that explains

37
00:02:54,000 --> 00:02:56,520
all of the caveats.

38
00:02:56,520 --> 00:02:58,960
Now compare soft engineering advice.

39
00:02:58,960 --> 00:03:04,760
The guru says, discover abstractions to make your code shorter.

40
00:03:04,760 --> 00:03:08,040
Okay, I abstracted my code.

41
00:03:08,040 --> 00:03:11,160
No, that is the wrong abstraction.

42
00:03:11,160 --> 00:03:13,280
Duplication is better than the wrong abstraction.

43
00:03:13,280 --> 00:03:17,760
Well, then how do I know fend an abstraction is a good design?

44
00:03:18,240 --> 00:03:22,280
Well, you see, good design leads to simplicity.

45
00:03:22,280 --> 00:03:26,280
Okay, I simplified my API.

46
00:03:26,280 --> 00:03:29,240
No, you broke your API.

47
00:03:29,240 --> 00:03:34,280
And if you break your API, that creates complexity for other programmers.

48
00:03:34,280 --> 00:03:39,080
So this advice, not so easy, it's citrus advice.

49
00:03:39,080 --> 00:03:43,760
And I think that if you were to take these four people, three people, these are all close

50
00:03:43,760 --> 00:03:45,760
to but not actual quotes by these people.

51
00:03:45,760 --> 00:03:50,080
If you were to show them the same piece of code and ask the same question, you would

52
00:03:50,080 --> 00:03:54,960
get similar advice, which goes to show you that they have some deeper intuition about

53
00:03:54,960 --> 00:04:00,960
some deeper reality that these words are not precise enough to capture.

54
00:04:00,960 --> 00:04:05,480
So how do we get to more precise engineering advice?

55
00:04:05,480 --> 00:04:09,520
Many years ago, I got really into program synthesis.

56
00:04:09,520 --> 00:04:13,480
Program synthesis is amazing.

57
00:04:13,480 --> 00:04:17,840
You like, it's this program where you just give them stuff, like you tell what you want

58
00:04:17,840 --> 00:04:23,400
to do, on this input you should do this, maybe here's a little bit of information on what

59
00:04:23,400 --> 00:04:27,200
the program should look like, and it thinks for a while with its algorithm and it gives

60
00:04:27,200 --> 00:04:28,800
you a correct program.

61
00:04:28,800 --> 00:04:30,160
It's cool.

62
00:04:30,160 --> 00:04:34,160
But a really nice thing is that you cannot be as a synthesizer.

63
00:04:34,160 --> 00:04:38,400
You cannot be as a synthesizer and you cannot be as a synthesizer.

64
00:04:38,400 --> 00:04:43,240
If you ask a programmer, hey, Bob, if I do this thing, will it make it easier for us

65
00:04:43,240 --> 00:04:46,040
to program later on?

66
00:04:46,040 --> 00:04:49,240
It can be a pretty vague question, hard to answer.

67
00:04:49,240 --> 00:04:54,920
But if you ask if I do this this way, will it make it easier to synthesize?

68
00:04:54,920 --> 00:04:56,680
The algorithm is on paper.

69
00:04:56,680 --> 00:05:03,480
You can just look at it, get an answer, and if you want to know if I have this data format

70
00:05:03,480 --> 00:05:07,080
of the millions and millions of possible code that I can write, is there anything that's

71
00:05:07,080 --> 00:05:08,080
clean?

72
00:05:08,080 --> 00:05:16,760
You can just try it, get an answer, now.

73
00:05:16,760 --> 00:05:22,240
So we're going to look at the parallels between synthesis and human programming.

74
00:05:22,240 --> 00:05:25,000
We're going to dive into the different schools of synthesis.

75
00:05:25,000 --> 00:05:27,320
Marley speaking, there are three kinds.

76
00:05:27,320 --> 00:05:33,200
Non-synthesizers, theorem-proving, logic, enumerative, searching very cleverly through

77
00:05:33,200 --> 00:05:36,000
large programs.

78
00:05:36,000 --> 00:05:42,000
This is how your database optimizes your SQL queries, by the way, and using constraint

79
00:05:42,000 --> 00:05:43,000
solvers.

80
00:05:43,000 --> 00:05:47,480
In the interest of time, we're mostly going to talk about deductives today, a little bit

81
00:05:47,480 --> 00:05:50,760
about constraint-based, no enumerative.

82
00:05:50,760 --> 00:05:56,360
But there is a very important fourth school of synthesis.

83
00:05:56,360 --> 00:06:00,720
And in fact, we have a few hundred examples of them in this room.

84
00:06:00,720 --> 00:06:02,280
That is you.

85
00:06:02,280 --> 00:06:03,600
You are a synthesizer.

86
00:06:03,600 --> 00:06:06,120
You write programs.

87
00:06:06,120 --> 00:06:10,560
And while you might work a little bit differently than these other algorithms, you do not have

88
00:06:10,560 --> 00:06:15,920
the constraint solve in your head, although I do think you do work a bit like the deductive

89
00:06:15,920 --> 00:06:23,760
synthesizer and do that kind of deductive reasoning, there is only one universe of possible programs.

90
00:06:23,760 --> 00:06:29,240
Only one universe of possible algorithms for writing programs.

91
00:06:29,240 --> 00:06:34,720
And so by looking at these other schools of synthesis, we can learn insights that we can

92
00:06:34,720 --> 00:06:42,200
take into our own programming, and that is the thesis of today's talk.

93
00:06:42,200 --> 00:06:48,000
And throughout our journey to synthesis lands, we will see three common recurring themes

94
00:06:48,000 --> 00:06:56,680
of abstractions, constraints, and logic.

95
00:06:56,680 --> 00:06:59,880
Enter deductive synthesis.

96
00:06:59,880 --> 00:07:04,640
At a high level, deductive synthesis is about taking a high level idea, and through a series

97
00:07:04,640 --> 00:07:09,680
of mechanical transformations, make it more and more refined and precise until you reach

98
00:07:09,680 --> 00:07:14,000
an implementation.

99
00:07:14,000 --> 00:07:17,720
So what is the information a deductive synthesizer works with?

100
00:07:18,440 --> 00:07:24,680
When we talk about software, we are saying at one of three levels.

101
00:07:24,680 --> 00:07:26,000
Here is a max function.

102
00:07:26,000 --> 00:07:31,800
You can talk about the run time values, or you can talk about all inputs and look at

103
00:07:31,800 --> 00:07:32,800
the code.

104
00:07:32,800 --> 00:07:37,600
So run time is level one, code level two.

105
00:07:37,600 --> 00:07:41,480
But this is not capturing the why of the code.

106
00:07:41,480 --> 00:07:46,680
It does not explain why it works, it does not explain how you came up with it.

107
00:07:46,680 --> 00:07:53,000
That information is in the logic, in the derivation or proof, and I call this level

108
00:07:53,000 --> 00:07:55,600
three.

109
00:07:55,600 --> 00:08:01,000
As you might guess from the relative size of these boxes, the most information lies

110
00:08:01,000 --> 00:08:03,120
in level three.

111
00:08:03,120 --> 00:08:08,600
But this is the why, this is the stuff that is only in your head normally.

112
00:08:08,600 --> 00:08:16,200
But to a synthesizer, this is just as concrete as the code it outputs at the end.

113
00:08:16,200 --> 00:08:19,400
So let's look at it from the synthesizer's perspective.

114
00:08:19,400 --> 00:08:22,880
So quick background, here is what the deductive synthesizer looks like.

115
00:08:22,880 --> 00:08:28,480
So it has some goal, like I need to get an integer, which is the maximum to other integers.

116
00:08:28,480 --> 00:08:34,320
And you write down a logical formula for what that means, or specify it in some way.

117
00:08:34,320 --> 00:08:38,200
And so our goal is we are given two integers, and we want a program such as after running

118
00:08:38,200 --> 00:08:45,560
the program, then this condition, it is the maximum of the two inputs, will be true.

119
00:08:45,560 --> 00:08:54,360
This tools, it has a bunch of rules that relate a piece of code to the abstract logical meaning

120
00:08:54,360 --> 00:08:57,280
of the program.

121
00:08:57,280 --> 00:08:58,600
And now it can do a search.

122
00:08:58,600 --> 00:09:03,640
So we want this maximum, okay, let's try running the if rule.

123
00:09:03,640 --> 00:09:09,320
Now we know the outer skeletons in if, and we have two sub goals to prove.

124
00:09:09,320 --> 00:09:14,000
And we need to go into the search, maybe try if again, okay, let's try another rule, another

125
00:09:14,000 --> 00:09:15,000
rule.

126
00:09:15,120 --> 00:09:19,200
Maybe using if there was not a good idea, maybe it's trying to assignment instead, ah, that

127
00:09:19,200 --> 00:09:20,960
works, there's my assignment.

128
00:09:20,960 --> 00:09:25,080
Now I know a little bit more about the program, and it keeps going like this, and eventually

129
00:09:25,080 --> 00:09:28,400
it gets the actual program.

130
00:09:28,400 --> 00:09:34,720
So that was 40-year-old consensus nutshell, but you also see this idea in a lot of newer

131
00:09:34,720 --> 00:09:35,720
systems.

132
00:09:35,720 --> 00:09:39,400
If you're at Nadia's talk an hour ago, you saw her talk about an deductive synthesizer

133
00:09:39,400 --> 00:09:43,720
called SYNQUID, Nadia was a post-talk in my lab.

134
00:09:43,720 --> 00:09:46,680
The world of synthesis is very small.

135
00:09:46,680 --> 00:09:51,040
And here are a couple other systems, Lambda squared and Fiat.

136
00:09:51,040 --> 00:09:57,320
All these only do small functional programs because synthesis is very hard, which is why

137
00:09:57,320 --> 00:10:01,720
instead of actually using this today, I'll tell you to not use it, but instead learn

138
00:10:01,720 --> 00:10:08,400
the insights and use it to improve the only algorithms within your head.

139
00:10:09,040 --> 00:10:15,760
By looking at things, this lens, deductive synthesis, we can come up with some deeper

140
00:10:15,760 --> 00:10:17,280
insights to code.

141
00:10:17,280 --> 00:10:20,960
Let's look at specification level notions.

142
00:10:20,960 --> 00:10:26,880
I'm Ronnie at Web App, and I need sanitize strings, no excess attacks.

143
00:10:26,880 --> 00:10:32,600
So to sanitize a string, I escape all single quotes.

144
00:10:32,600 --> 00:10:34,760
And now I have two choices for how to use this.

145
00:10:34,760 --> 00:10:39,160
Before I save my data to this, it must be sanitized, and I can do it either by calling

146
00:10:39,160 --> 00:10:44,760
the sanitize function that I just wrote, or by doing it by hand.

147
00:10:44,760 --> 00:10:50,840
And take a few seconds to look at these, decide whether you prefer option one or option two.

148
00:10:50,840 --> 00:11:09,000
So when I've shown this before, it's a plurality for option one.

149
00:11:09,000 --> 00:11:15,520
A slightly smaller number have no opinion, and a small minority for option two.

150
00:11:15,520 --> 00:11:20,400
And in a minute, I'll give you a sense in which option one is a correct answer, and

151
00:11:20,400 --> 00:11:22,680
there's some interpretations.

152
00:11:22,680 --> 00:11:27,000
But so how else when you might have come to this conclusion?

153
00:11:27,000 --> 00:11:32,760
Well, you might have used the folk engineering advice, and it's like it's more abstract,

154
00:11:32,760 --> 00:11:37,000
but the other is more direct, and this one's hard to do in happening, it's more to understand,

155
00:11:37,000 --> 00:11:39,040
it's easier to change.

156
00:11:39,040 --> 00:11:45,080
And when you're working at this level, it's basically like two lawyers in the podium arguing

157
00:11:45,080 --> 00:11:48,520
with their side, and both of them have case laws to support them.

158
00:11:49,280 --> 00:11:52,400
It's hard to get a real right answer.

159
00:11:52,400 --> 00:11:55,200
And even if you do, it might not be good enough.

160
00:11:55,200 --> 00:11:59,880
So here's an engineer that I used to train, let's call him Steven, and his head is full

161
00:11:59,880 --> 00:12:05,040
of citrus advice, and he looks at this and says, option one, it centralizes the code.

162
00:12:05,040 --> 00:12:06,680
Good job, Steven.

163
00:12:06,680 --> 00:12:10,760
But his understanding of the information hiding was not deep enough, because five minutes

164
00:12:10,760 --> 00:12:14,760
later, I gave him a similar example.

165
00:12:14,840 --> 00:12:20,280
So this time, I have my Twitter box, and I type in 139 characters, and it says too long.

166
00:12:20,280 --> 00:12:21,280
What?

167
00:12:21,280 --> 00:12:26,880
It's because it escaped my string, and it double counted every single quote, because

168
00:12:26,880 --> 00:12:29,440
every single quote became two characters.

169
00:12:29,440 --> 00:12:35,240
So let's not do that, let's undouble count the single quotes.

170
00:12:35,240 --> 00:12:38,720
And I'm very glad that the Python standard library has this count function.

171
00:12:38,720 --> 00:12:42,560
It made this slide easier to write.

172
00:12:42,560 --> 00:12:48,080
But I propose, instead of doing maths, we abstract this counting pre-sanitized string

173
00:12:48,080 --> 00:12:50,680
into a function.

174
00:12:50,680 --> 00:12:54,200
And Steven looks at this, and he says, no.

175
00:12:54,200 --> 00:12:59,400
Option one, it's a mistake in the slide, just say option one, is over-engineering.

176
00:12:59,400 --> 00:13:03,400
This is premature abstraction, evil!

177
00:13:03,680 --> 00:13:13,680
In a moment, we shall see how there is a principle that picks option one in both circumstances.

178
00:13:13,680 --> 00:13:19,400
And if you adhere to this principle, then not only is option two disprofforable, it

179
00:13:19,400 --> 00:13:21,280
is wrong.

180
00:13:21,280 --> 00:13:28,560
And my wrong, I mean compile air level wrong.

181
00:13:28,560 --> 00:13:33,040
This comes to the idea of encapsulating ideas.

182
00:13:33,200 --> 00:13:42,680
And what the f does that mean?

183
00:13:42,680 --> 00:13:48,200
So this is one of those vague things you might have heard before, where once you learn to

184
00:13:48,200 --> 00:13:54,360
think like a synthesizer and actually see the logic it's based on, it becomes very precise.

185
00:13:54,360 --> 00:13:57,360
And so let's do it.

186
00:13:57,360 --> 00:14:01,760
And so through this lens of deduction and deductive synthesis, we're going to see how

187
00:14:01,760 --> 00:14:08,000
option one is preferable in information hiding, how easy it is to think about and how easy

188
00:14:08,000 --> 00:14:13,000
it is to write, and give precise meanings to all three of these lines.

189
00:14:13,000 --> 00:14:18,280
And let's begin just by talking about what we mean by sanitized.

190
00:14:18,280 --> 00:14:22,400
Well right now it means that every single quote is escaped.

191
00:14:22,400 --> 00:14:25,560
And I can write this down formally in one of many notations.

192
00:14:25,560 --> 00:14:31,360
I'm going to use cook because I'm familiar with it, but you can pick any of these others.

193
00:14:31,360 --> 00:14:34,880
And you learned one of these earlier today, that's another session.

194
00:14:34,880 --> 00:14:40,360
It looks like this, says before every single quote, there's a backslash.

195
00:14:40,360 --> 00:14:45,120
And now other modules can use this definition when they're reading about code.

196
00:14:45,120 --> 00:14:50,480
But there's something missing here, which is really that definition I gave a sanitized,

197
00:14:50,480 --> 00:14:52,600
that's just today's definition.

198
00:14:52,600 --> 00:14:57,080
And other modules can use it, but what if tomorrow I decide I need to escape other things?

199
00:14:57,080 --> 00:14:59,600
I've changed the meaning of being sanitized.

200
00:14:59,600 --> 00:15:05,880
Now all this other code, that in the reasoning, use the fact that this is what sanitized means,

201
00:15:05,880 --> 00:15:08,040
those are now broken.

202
00:15:08,040 --> 00:15:18,720
So what I want is to put all current and future meanings of sanitized behind some abstract

203
00:15:18,720 --> 00:15:19,720
predicates.

204
00:15:19,720 --> 00:15:22,880
Let's say I give this string, it is sanitized, what do you mean it's sanitized?

205
00:15:22,880 --> 00:15:26,240
It's sanitized and that's final.

206
00:15:26,240 --> 00:15:31,920
And now this sanitization module can change its mind about what it means by sanitized

207
00:15:31,920 --> 00:15:33,240
and no one will ever know.

208
00:15:33,240 --> 00:15:35,120
It's a secret.

209
00:15:35,120 --> 00:15:41,240
And that is an abstraction barrier.

210
00:15:41,240 --> 00:15:43,240
Do not cross.

211
00:15:43,240 --> 00:15:50,560
Now, and you might have seen a diagram like this before, oh, I centralize my functionality,

212
00:15:50,560 --> 00:15:54,760
I wrap it in a function, you can't expose it.

213
00:15:54,760 --> 00:15:55,840
This is not like that.

214
00:15:55,840 --> 00:15:57,520
This is purely an idea.

215
00:15:57,520 --> 00:16:00,960
This sanitized predicate does not correspond to anything in your code, it's just how you

216
00:16:00,960 --> 00:16:02,480
think about the code.

217
00:16:02,480 --> 00:16:06,600
And on this slide, you'll see exactly how.

218
00:16:06,600 --> 00:16:12,320
So in Cork, you write this idea of an opaque predicate, an existential predicate with the

219
00:16:12,320 --> 00:16:13,520
opaque keyword.

220
00:16:13,520 --> 00:16:19,680
Again, you can do this in about any other formalism, that is, this is the abstraction

221
00:16:19,680 --> 00:16:23,520
boundary but written as code.

222
00:16:23,520 --> 00:16:27,760
And now other modules do not get to think in detail, all they know is, I got a sanitized

223
00:16:27,760 --> 00:16:32,320
thing, whatever that means, it's a black box.

224
00:16:32,320 --> 00:16:35,480
So this is the sense in which option two is wrong.

225
00:16:35,480 --> 00:16:39,720
Because in order to look at that code and read it as a human and say, I'm going to justify

226
00:16:39,720 --> 00:16:45,760
why this is doing what I want, you have to do something in your head, access the information

227
00:16:45,760 --> 00:16:49,960
that sanitized strings have single quotes escaped and nothing else escaped.

228
00:16:49,960 --> 00:16:55,600
And so what it's actually doing is it's piercing the abstraction barrier, do not cross, and

229
00:16:55,600 --> 00:16:59,720
relying on this old piece of information that may change.

230
00:16:59,720 --> 00:17:01,120
Dangerous.

231
00:17:01,120 --> 00:17:08,800
Whereas in option one, all the information about what sanitized means is encapsulated

232
00:17:08,800 --> 00:17:10,880
into the sanitization module.

233
00:17:10,880 --> 00:17:15,320
So maybe the sanitized Stirland function, which is right next to sanitized, is allowed

234
00:17:15,320 --> 00:17:21,440
to know what it means to be sanitized, but this user code is not.

235
00:17:21,440 --> 00:17:29,280
And so thus, it is a secret preserved, it may be changed.

236
00:17:29,280 --> 00:17:35,320
And the same view the sanitized predicates gives us the answer to the first question.

237
00:17:35,320 --> 00:17:41,960
So here, my sanitized function returns, was returned, means it returns a sanitized string,

238
00:17:41,960 --> 00:17:44,160
whatever that means.

239
00:17:44,160 --> 00:17:49,240
And before I save, I have to feed it in a sanitized string, whatever that means.

240
00:17:49,240 --> 00:17:52,240
And so when I put these functions together, they line up.

241
00:17:52,240 --> 00:18:01,160
But when I try to sanitize it by hand, it's like, you gave me a string where you escape

242
00:18:01,160 --> 00:18:02,160
single quotes.

243
00:18:02,160 --> 00:18:03,640
I need a sanitized string.

244
00:18:03,640 --> 00:18:05,560
I don't know these are the same.

245
00:18:05,560 --> 00:18:06,560
What do you mean?

246
00:18:06,560 --> 00:18:07,760
That is a sanitized string.

247
00:18:07,760 --> 00:18:10,240
Oh, no, you can't use that information.

248
00:18:10,240 --> 00:18:11,600
It is opaque, hidden.

249
00:18:11,600 --> 00:18:17,440
It's behind the abstraction barrier, do not cross.

250
00:18:17,440 --> 00:18:18,880
But that's just an interpretation.

251
00:18:18,880 --> 00:18:25,680
There's another way of looking at the program that gives you the opposite conclusion.

252
00:18:25,680 --> 00:18:29,400
Suppose the sanitized function is not allowed to know what the sanitized means.

253
00:18:29,400 --> 00:18:34,600
I don't know what it returns, but you can't show it does not know what that means.

254
00:18:34,600 --> 00:18:37,800
But this other code does know what sanitized means.

255
00:18:37,800 --> 00:18:42,960
Then it works when you do it by hand, but not when you call this foreign function, who

256
00:18:42,960 --> 00:18:46,680
knows what it does.

257
00:18:46,680 --> 00:18:51,720
But of course, there is in the third option in which both are acceptable.

258
00:18:51,720 --> 00:18:53,320
This is the hippie version.

259
00:18:53,320 --> 00:18:55,680
There is no abstraction boundary.

260
00:18:55,680 --> 00:19:01,360
Everyone gets to know about sanitization, those dirty hippies.

261
00:19:01,360 --> 00:19:06,920
And in that case, in both modules, you're allowed to think about the definition of sanitized

262
00:19:06,920 --> 00:19:11,600
and see that these line up and do either.

263
00:19:11,600 --> 00:19:17,040
Now when you're actually programming, you don't write down these formal logic things.

264
00:19:17,040 --> 00:19:21,480
You don't write pre-conditions and post-conditions in gratuitous detail and everything.

265
00:19:21,480 --> 00:19:28,120
No, you have an idea in your head about what you're supposed to do, but it's not given

266
00:19:28,120 --> 00:19:30,160
to the compiler.

267
00:19:30,160 --> 00:19:34,960
And so for all three of these interpretations, all three of these worlds, whoever is allowed

268
00:19:34,960 --> 00:19:39,360
to know what sanitized means, these all result in the same code.

269
00:19:39,360 --> 00:19:47,080
The difference is only at level three in the logic, in the why, not in level two code.

270
00:19:47,080 --> 00:19:53,120
But it's still which one of these worlds you choose is your interpretation determines

271
00:19:53,120 --> 00:19:56,880
which option is correct and preferable.

272
00:19:56,880 --> 00:19:58,840
So is it just a matter of interpretation?

273
00:19:58,840 --> 00:20:03,080
Well, there's some pretty clear, like everything's a trade-off, but there are some pretty clear

274
00:20:03,080 --> 00:20:05,680
reasons to pick option one.

275
00:20:05,680 --> 00:20:12,320
So in option one, I'm all sanitized, and I need a sanitized string for save, so I could

276
00:20:12,320 --> 00:20:18,840
have sanitized x, I need to show sanitized x in order to save it, and this proof is trivial.

277
00:20:18,840 --> 00:20:23,880
Not always is it trivial, but if I'm programming in Koch, I can actually type in the word trivial

278
00:20:23,880 --> 00:20:29,120
period, and it'll say, yep, that's a proof.

279
00:20:29,120 --> 00:20:35,560
And more generally, it can get more complicated when you have aliasing and conditionals, but

280
00:20:35,560 --> 00:20:40,480
it's still going to fall within a fragment of first-order logic called effectively propositional,

281
00:20:40,480 --> 00:20:46,600
or EPR logic, which is generally pretty easy to reason about.

282
00:20:46,600 --> 00:20:48,800
There are fast algorithms.

283
00:20:48,800 --> 00:20:53,960
In the other world, I'm doing this replace all thing by hands, and you show it satisfies

284
00:20:53,960 --> 00:21:00,960
some complicated condition about what goes where, and we can do this, but it's a little

285
00:21:00,960 --> 00:21:02,640
bit harder.

286
00:21:02,640 --> 00:21:08,200
So hard that was only discovered this year.

287
00:21:08,200 --> 00:21:17,160
So in the first case, when I first write sanitized, I still need to prove that when I sanitize

288
00:21:17,160 --> 00:21:21,800
a string, it satisfies the meaning of being sanitized, and so there I need to think a

289
00:21:21,800 --> 00:21:26,400
little bit harder about the sanitized function, but when I actually use it, I can use the

290
00:21:26,400 --> 00:21:28,600
fast EPR logic solver.

291
00:21:28,600 --> 00:21:29,600
It's easy for me.

292
00:21:29,600 --> 00:21:35,360
It's easy for this program to think about, whereas in the other options, I don't have

293
00:21:35,360 --> 00:21:41,160
to clean module boundary, and so when I call save with this complicated by hand, replace

294
00:21:41,160 --> 00:21:50,080
alling, now I need to use the very fancy chun algorithm and think about strings.

295
00:21:50,440 --> 00:21:57,280
It's also easier for the synthesizer, because if I say, okay, I have a string, now I need

296
00:21:57,280 --> 00:22:02,360
a sanitized string, I need to satisfy some condition about what goes where, everything

297
00:22:02,360 --> 00:22:03,360
escapes.

298
00:22:03,360 --> 00:22:06,840
It's like, okay, look, how can I get a sanitized string?

299
00:22:06,840 --> 00:22:11,280
Is there a way to use replace all, is there a way to concatenate things or reverse things?

300
00:22:11,280 --> 00:22:15,120
It has a lot of options to choose from and try in its search.

301
00:22:15,120 --> 00:22:18,720
When you say it is sanitized, what does that mean?

302
00:22:19,080 --> 00:22:21,360
It means no basis.

303
00:22:21,360 --> 00:22:25,920
Then it is only one option for how to get a sanitized string, which is to call the sanitized

304
00:22:25,920 --> 00:22:31,440
function, which exports an interface saying, get you a sanitized string.

305
00:22:31,440 --> 00:22:37,920
And so that is the precise meaning of easier to think about and easier to code, synthesis

306
00:22:37,920 --> 00:22:40,320
style.

307
00:22:40,320 --> 00:22:48,120
So we've explored some correspondencies between the deductive schools of synthesis and you.

308
00:22:48,120 --> 00:22:55,000
We've seen the themes of abstraction in the way that we hid, hid sanitized behind the

309
00:22:55,000 --> 00:22:58,640
abstraction barrier, do not cross.

310
00:22:58,640 --> 00:23:03,400
How does put constraints on the program and what is it possible to write?

311
00:23:03,400 --> 00:23:08,760
And of course, all this is only seen at the level of logic.

312
00:23:08,760 --> 00:23:11,560
Let's look at another example.

313
00:23:11,560 --> 00:23:17,560
How is it possible to write a straight line program, no, no indentation.

314
00:23:17,560 --> 00:23:20,640
That contains a conditional.

315
00:23:20,640 --> 00:23:21,640
Let's find out.

316
00:23:21,640 --> 00:23:30,840
I have a program on the server, returns 496, I swear it returns 1024.

317
00:23:30,840 --> 00:23:39,600
And my friend Stephen sees this code and he sees that if statement and he gets mad.

318
00:23:39,600 --> 00:23:43,400
Because the internet told him, do not use if statements.

319
00:23:43,400 --> 00:23:51,480
Off to the if statements, join the if campaign, if statements are bad.

320
00:23:51,480 --> 00:23:54,440
So it goes back to this code, he gets an idea.

321
00:23:54,440 --> 00:23:59,880
This is in C. That is on server variable is either 0 or 1.

322
00:23:59,880 --> 00:24:05,760
We can replace this if with an array index.

323
00:24:05,760 --> 00:24:09,160
The guru is not pleased.

324
00:24:09,160 --> 00:24:13,840
You have only moved the conditional into the array.

325
00:24:13,840 --> 00:24:15,720
What?

326
00:24:15,720 --> 00:24:25,640
So this is the if advice, a little bit less straightforward than it may have seen.

327
00:24:25,640 --> 00:24:27,360
Let's see what that means.

328
00:24:27,360 --> 00:24:29,840
A quick change of notation.

329
00:24:29,840 --> 00:24:37,400
I'm going to denote the array, 1024, 496 by saying start with the empty array, add 0,

330
00:24:37,520 --> 00:24:43,160
insert 1024, add 1, insert 496.

331
00:24:43,160 --> 00:24:45,960
On top of this notation, we have the array axioms.

332
00:24:45,960 --> 00:24:53,440
I'm not going to go into them in detail, but they tell me exactly what it means for, they

333
00:24:53,440 --> 00:24:57,640
tell me exactly what it means for to index the array.

334
00:24:57,640 --> 00:25:05,400
And it gives me this, it says, that's 1, the index is 496, else let's go deeper to the

335
00:25:05,400 --> 00:25:11,360
array, add 0, it's 1024, let's go deeper to the array, oh, we're out of array, we're out

336
00:25:11,360 --> 00:25:18,920
of axioms, so now it's undefined, but really the only thing you care about is at the bottom

337
00:25:18,920 --> 00:25:19,920
right.

338
00:25:19,920 --> 00:25:27,000
This simplifies to the formula, if x equals 0, the index is 1224, and if x is 1, then the

339
00:25:27,000 --> 00:25:30,760
index is 496.

340
00:25:30,760 --> 00:25:37,640
That formula is conditional, if x is this, then it's that, if x is this, then it's that.

341
00:25:37,640 --> 00:25:42,600
Now using this, we can go back to the program and come up with a logical formula to describe

342
00:25:42,600 --> 00:25:45,600
what the program does.

343
00:25:45,600 --> 00:25:52,920
And we get a conditional, if it's on server, then it's 496, I'll say it's 1024.

344
00:25:52,920 --> 00:25:58,600
And we can use other axioms to do the exact same for the original program, and we get

345
00:25:58,600 --> 00:26:02,680
the exact same formula.

346
00:26:02,680 --> 00:26:07,920
And so there's a sense that both of these have an additional, the same conditional.

347
00:26:07,920 --> 00:26:12,000
And so the synthesizer is only looking at these formulas.

348
00:26:12,000 --> 00:26:17,800
And so from its perspective, these two pieces of code are not just semantically equivalent,

349
00:26:17,800 --> 00:26:23,760
they're actually structurally identical, we haven't changed it at all.

350
00:26:23,760 --> 00:26:28,720
And so conditionals are a semantic notion, not an intact notion.

351
00:26:28,720 --> 00:26:33,560
Just because you don't write the words letters I F, does not mean there's no if statement

352
00:26:33,560 --> 00:26:36,080
in your code.

353
00:26:36,080 --> 00:26:40,840
So the thing that happened here was the array index was conditional in disguise.

354
00:26:40,840 --> 00:26:46,720
Does this mean we should have an anti-array campaign and no arrays, definitely array?

355
00:26:46,720 --> 00:26:47,960
No.

356
00:26:47,960 --> 00:26:54,280
Not every array access is conditional, but the difference is subtle.

357
00:26:54,280 --> 00:26:58,440
And it cannot be purely determined from the code, but it's a property rather of the level

358
00:26:58,440 --> 00:27:00,760
three, how you think about it.

359
00:27:00,760 --> 00:27:01,760
Let's inspect.

360
00:27:01,760 --> 00:27:03,760
Here's another array.

361
00:27:03,760 --> 00:27:06,480
It's a list of all the president names.

362
00:27:06,480 --> 00:27:09,480
And using that, we can define a president after function.

363
00:27:09,480 --> 00:27:11,640
The president after Washington was Adams.

364
00:27:11,640 --> 00:27:16,360
The president after Thomas Jefferson was James Madison and so on.

365
00:27:16,360 --> 00:27:18,640
Here's a pretty simple function that does that.

366
00:27:18,640 --> 00:27:23,640
It totally breaks on bad inputs, negatives, the last president.

367
00:27:23,640 --> 00:27:24,640
Don't tell me about those.

368
00:27:24,640 --> 00:27:26,920
It's a simple example.

369
00:27:26,920 --> 00:27:29,720
And let's talk about what it means index into the array.

370
00:27:29,720 --> 00:27:34,480
And like before, we get a giant conditional at zero, it's Washington, and it's one, it's

371
00:27:34,480 --> 00:27:36,160
Adams, and so on.

372
00:27:36,160 --> 00:27:40,520
This does not look promising, it looks conditional.

373
00:27:40,520 --> 00:27:49,440
But if you already have a notion, an external notion of the ith president, then you can

374
00:27:49,440 --> 00:27:52,560
relate this formula to that.

375
00:27:52,560 --> 00:27:57,960
And you can get the simpler formula, it's the index of the ith, to name the ith president,

376
00:27:57,960 --> 00:28:01,000
which is not involved in any ranching at all.

377
00:28:01,000 --> 00:28:05,800
And now we can use this abstracted formula to look at this code and think about it in

378
00:28:05,800 --> 00:28:10,480
a very short foreign manner, get this index, I can name the next president, and I'm done.

379
00:28:11,440 --> 00:28:15,840
That's how you would think about it, and that's also how a veripyrocynthesizer would think

380
00:28:15,840 --> 00:28:20,480
about it, just like I've written down here.

381
00:28:20,480 --> 00:28:23,480
There's no casework in here, there's no branching.

382
00:28:23,480 --> 00:28:24,480
Just works.

383
00:28:24,480 --> 00:28:33,000
And so that's a sense in which one array index is a conditional and the other is not.

384
00:28:33,000 --> 00:28:37,320
So the difference is that we're able to abstract one and not the other.

385
00:28:37,320 --> 00:28:41,680
And you could abstract the size of the array, find a better way of thinking about it, but

386
00:28:41,680 --> 00:28:42,680
I didn't.

387
00:28:42,680 --> 00:28:49,400
And because I didn't find it's a way, that was conditional, and this one is not.

388
00:28:49,400 --> 00:28:53,800
So we've again seen this insight from the doctoral school of synthesis to the human,

389
00:28:53,800 --> 00:28:58,880
and when you see the abstraction and how we abstracted the array access, this lets us

390
00:28:58,880 --> 00:29:03,560
put extra constraints in a program like death of the statement.

391
00:29:03,560 --> 00:29:10,800
But this only is understood at the level of logic.

392
00:29:10,800 --> 00:29:15,240
Let's go into another school of synthesis, the constraint-based, and this section is

393
00:29:15,240 --> 00:29:17,840
going to be a little bit different from the previous ones.

394
00:29:17,840 --> 00:29:22,440
I said at the beginning that a human and a deductive synthesizer are kind of similar,

395
00:29:22,440 --> 00:29:28,360
and so deductive synthesis can shed light on software engineering advice, whereas the

396
00:29:28,360 --> 00:29:32,400
numerator and constraint-based, they're not like a human synthesizer, so they're just

397
00:29:32,440 --> 00:29:36,840
going to eliminate the nature of the programs themselves.

398
00:29:36,840 --> 00:29:42,600
We're going to be talking about a tool called Sketch, built by my advisor, Armando Suarezama,

399
00:29:42,600 --> 00:29:48,480
and the sketch is about programming with holes, like humans are clever and insightful

400
00:29:48,480 --> 00:29:49,480
and slow.

401
00:29:49,480 --> 00:29:51,200
Synthesizers are dumb, thorough, and fast.

402
00:29:51,200 --> 00:29:52,200
Let's put them together.

403
00:29:52,200 --> 00:29:57,160
You're going to write a higher level of the program, what the program kind of looks like,

404
00:29:57,160 --> 00:29:59,480
the synthesizers are going to fill in the details.

405
00:29:59,480 --> 00:30:01,920
So here's the Hello World example.

406
00:30:01,920 --> 00:30:05,360
That question mark is a hole.

407
00:30:05,360 --> 00:30:10,120
So this thing is asking, find me an integer question mark such that x times question mark

408
00:30:10,120 --> 00:30:16,920
is equivalent to x times x for all inputs.

409
00:30:16,920 --> 00:30:20,160
And you might figure out the answer, it's 2.

410
00:30:20,160 --> 00:30:24,800
And this synthesizer will figure that out, too, after 0.452 seconds.

411
00:30:24,800 --> 00:30:29,120
You can do more complicated things like Sketch, like if you have a really inefficient link

412
00:30:29,120 --> 00:30:32,200
to this reversal, you can get the fast one.

413
00:30:32,200 --> 00:30:35,840
You do need a bit more of a complicated hole than an integer, say, like some number of

414
00:30:35,840 --> 00:30:39,680
statements where a statement looks like this, but it can do it.

415
00:30:39,680 --> 00:30:45,240
So I'm going to give you a two-minute version of the synthesis algorithm.

416
00:30:45,240 --> 00:30:51,160
There's two parts, constraint and solving, and the see just loop.

417
00:30:51,160 --> 00:30:53,520
So it looks like this.

418
00:30:53,800 --> 00:30:56,120
For simplicity, all integers are two bits.

419
00:30:56,120 --> 00:30:59,680
You'll think we have added a moment.

420
00:30:59,680 --> 00:31:04,920
And we can just say, let's look at the bits of the inputs and the hole and the arithmetic

421
00:31:04,920 --> 00:31:05,920
expressions.

422
00:31:05,920 --> 00:31:10,640
And all these give us constraints that the bits of the digits of the plus expression

423
00:31:10,640 --> 00:31:14,360
need to match the corresponding ones in the multiplication expression.

424
00:31:14,360 --> 00:31:17,520
So we get a list of constraints on the bits.

425
00:31:17,520 --> 00:31:22,240
And now we can also write down bits, level formulas for every bit of the plus in the

426
00:31:22,240 --> 00:31:23,240
times.

427
00:31:23,240 --> 00:31:29,080
And it looks like this, some big Boolean formulas, thank goodness there's only two bit numbers.

428
00:31:29,080 --> 00:31:33,720
And now we'll just solve for what the bits of the hole are.

429
00:31:33,720 --> 00:31:37,560
And if you're taking a theory of computing course, you might start getting a little scared.

430
00:31:37,560 --> 00:31:40,680
Because in a theory of computing course, you might have learned that this is the Boolean

431
00:31:40,680 --> 00:31:41,960
satisfiability problem.

432
00:31:41,960 --> 00:31:46,200
We need to find a sign to these bits that the thing works.

433
00:31:46,200 --> 00:31:47,720
That's the SAT problem.

434
00:31:47,720 --> 00:31:51,640
Oh, no, that's NP-hard.

435
00:31:51,640 --> 00:31:54,800
And that is a lie.

436
00:31:54,800 --> 00:31:58,960
Because it's actually NP-easy.

437
00:31:58,960 --> 00:32:04,800
And by that, I mean that modern SAT solvers can take in millions of variables and solve

438
00:32:04,800 --> 00:32:09,200
them very fast, most of the time.

439
00:32:09,200 --> 00:32:12,520
In this case, we're lucky enough to be in the most of the time.

440
00:32:12,520 --> 00:32:18,160
And so we figure out the bits of the hole and we get the final answer of two.

441
00:32:18,160 --> 00:32:23,000
Woo-hoo, synthesis.

442
00:32:23,000 --> 00:32:28,440
But really, it makes it easier to think about if you just pick a few inputs at one time

443
00:32:28,440 --> 00:32:31,000
instead of all inputs.

444
00:32:31,000 --> 00:32:35,000
So on top of this, we build something called the counter-example-guided inductive synthesis

445
00:32:35,000 --> 00:32:36,600
loop, sieges.

446
00:32:36,600 --> 00:32:40,640
And it's basically a conversation between two parts, the inductive synthesizer and

447
00:32:40,640 --> 00:32:41,640
the verifier.

448
00:32:41,640 --> 00:32:46,040
The inductive synthesizer takes some input, takes some tests, gives you a program.

449
00:32:46,040 --> 00:32:51,200
The verifier takes in a program and says, if it always works, if not, a failing input.

450
00:32:51,200 --> 00:32:52,200
So does this work?

451
00:32:52,200 --> 00:32:53,200
No.

452
00:32:53,200 --> 00:32:54,200
It fails this input.

453
00:32:54,200 --> 00:32:55,200
Does this work?

454
00:32:55,200 --> 00:32:56,200
No.

455
00:32:56,200 --> 00:32:57,200
It's a failing test.

456
00:32:57,200 --> 00:32:58,200
Does this work?

457
00:32:58,200 --> 00:32:59,200
Yes.

458
00:32:59,200 --> 00:33:03,000
In other words, sieges is test-driven development.

459
00:33:03,000 --> 00:33:09,320
And from this, I get the idea, maybe you can somehow use Sketch and sieges to tell us

460
00:33:09,320 --> 00:33:11,760
something about testing.

461
00:33:11,760 --> 00:33:13,760
Let's do it.

462
00:33:13,760 --> 00:33:18,000
What we're going to do is I want to see if my test case is good enough.

463
00:33:18,000 --> 00:33:21,520
If it's good enough, if the test pass, my program works.

464
00:33:21,520 --> 00:33:29,000
So is there a way to write a program that passes all my tests but is the wrong program?

465
00:33:29,000 --> 00:33:32,240
Let's use synthesis to find out.

466
00:33:32,240 --> 00:33:39,960
A view of testing is that you have some space of correct programs that you want to find,

467
00:33:39,960 --> 00:33:45,520
and every test is going to narrow down the passing programs more and more, hopefully to

468
00:33:45,520 --> 00:33:48,560
just the correct ones.

469
00:33:48,560 --> 00:33:51,080
But there's something missing from this story.

470
00:33:51,080 --> 00:33:56,120
Here's a very simple kind of program, curves on an xy plane.

471
00:33:56,120 --> 00:34:01,280
Here are my test points, and I want a curve that goes through all three points.

472
00:34:01,280 --> 00:34:04,680
Can you guess what curve I have in mind?

473
00:34:04,680 --> 00:34:05,680
That's right.

474
00:34:05,680 --> 00:34:06,680
It's this guy.

475
00:34:06,680 --> 00:34:07,680
No, no, no.

476
00:34:07,680 --> 00:34:08,680
Here's another test.

477
00:34:08,920 --> 00:34:11,920
Oh, you mean this one?

478
00:34:11,920 --> 00:34:17,040
But if we add a structural constraint that the curve must be a line, then those two

479
00:34:17,040 --> 00:34:21,000
options go away, and the only option is this line.

480
00:34:21,000 --> 00:34:25,360
And not only that, but I need fewer points, fewer test cases.

481
00:34:25,360 --> 00:34:29,040
And programs are just generalized polynomials.

482
00:34:29,040 --> 00:34:32,440
And programs such that this is just generalized curve fitting.

483
00:34:32,440 --> 00:34:35,000
So what does this look like for testing programs?

484
00:34:35,720 --> 00:34:39,520
Well, if you have some kind of structural constraint in the program that you can write,

485
00:34:39,520 --> 00:34:42,520
then maybe you don't need this third test.

486
00:34:42,520 --> 00:34:44,640
So let's put that in action.

487
00:34:44,640 --> 00:34:50,000
So I want to synthesize a function to do something very complicated, the length of a link list.

488
00:34:50,000 --> 00:34:53,120
Here are my three test cases on the left.

489
00:34:53,120 --> 00:35:02,600
And for this, I do need to have some kind of oracle that tells me what the correct answer

490
00:35:02,600 --> 00:35:04,040
is.

491
00:35:04,040 --> 00:35:09,000
Using this, I'm going to synthesize a length function, which passes all the three tests

492
00:35:09,000 --> 00:35:14,480
that I gave it, whether it is some input list question mark, which differs from the

493
00:35:14,480 --> 00:35:15,840
correct answer.

494
00:35:15,840 --> 00:35:19,440
So pass all the test cases, but it's wrong on somewhere.

495
00:35:19,440 --> 00:35:23,040
Let's synthesize.

496
00:35:23,040 --> 00:35:27,280
So first, I say it'll have at most three branches.

497
00:35:27,280 --> 00:35:31,720
Each conditional looks something like this, some reasonable list operations.

498
00:35:31,720 --> 00:35:37,520
Now things can happen within each branch, and let's see if it can come up with something.

499
00:35:37,520 --> 00:35:39,040
And it does.

500
00:35:39,040 --> 00:35:42,800
Sketch produces correct output, not readable output.

501
00:35:42,800 --> 00:35:49,040
And so in order to make sure I have the right program, I need to add another test, like

502
00:35:49,040 --> 00:35:50,800
list of length three.

503
00:35:50,800 --> 00:35:56,760
And now it says, if it passed all the tests, there's no way to make it the wrong program.

504
00:35:56,760 --> 00:36:03,480
But if I restrict my program a little bit, then I don't need that test anymore.

505
00:36:03,480 --> 00:36:08,800
And just the only three tests, I must have the correct program.

506
00:36:08,800 --> 00:36:14,640
So there's all this talk about more coverage, more tests, more precise.

507
00:36:14,640 --> 00:36:20,080
But we don't often hear about writing the simpler code, in that the more one we have,

508
00:36:20,080 --> 00:36:21,080
the less the other we need.

509
00:36:21,080 --> 00:36:25,440
Write simpler code, then you don't need as many tests.

510
00:36:25,440 --> 00:36:32,600
And it's a choice, but I know which end I prefer.

511
00:36:32,600 --> 00:36:38,360
Because there's a saying that quality cannot be tested in, quality must be built in.

512
00:36:38,360 --> 00:36:42,280
And this is what it means.

513
00:36:42,280 --> 00:36:46,920
So we've gotten some insights into writing programs, writing tests from the School of

514
00:36:46,920 --> 00:36:48,960
Constraint-based Synthesis.

515
00:36:48,960 --> 00:36:55,320
And again, we've seen abstraction in our use of this test oracle, constraints in how

516
00:36:55,320 --> 00:37:00,360
we restrict the program space to make it work, and the synthesis algorithm itself is based

517
00:37:00,360 --> 00:37:03,640
on logic.

518
00:37:03,640 --> 00:37:08,720
So we've seen a lot of stuff today.

519
00:37:08,720 --> 00:37:14,560
You've learned the high level of two different synthesis algorithms, seen a lot of stuff

520
00:37:14,560 --> 00:37:19,120
you probably haven't seen before, but really what we're doing is reaching that black box

521
00:37:19,120 --> 00:37:24,200
in your head of how we write programs, and kind of opening up a bit and seeing how it

522
00:37:24,200 --> 00:37:25,200
works.

523
00:37:25,200 --> 00:37:34,760
And in doing so, we can start to stop accepting vague answers for what we should be doing,

524
00:37:34,760 --> 00:37:38,600
start to accept, maybe we can think a little bit deeper about what's going on.

525
00:37:38,600 --> 00:37:41,360
What is it possible for me to write right now?

526
00:37:41,360 --> 00:37:45,480
Sometimes we're on a wild west, not anything goes, there's a structure to what it's possible

527
00:37:45,480 --> 00:37:50,600
to write, and we're accepting that we can find it.

528
00:37:50,600 --> 00:37:56,280
So my hope is that becoming here today, you're joining me all, you're all joining me on a

529
00:37:56,280 --> 00:38:01,960
journey to get away from the citrus advice to become used to, start to learn how to see

530
00:38:01,960 --> 00:38:05,160
the vitamins in our code.

531
00:38:05,160 --> 00:38:10,920
Because the first step, the most important step you've already done, to get to more precise

532
00:38:10,960 --> 00:38:16,000
hard-generated advice, the big step is simply to believe that it's possible, because you

533
00:38:16,000 --> 00:38:19,240
are a program synthesizer.

534
00:38:19,240 --> 00:38:25,520
So if you want to see more about this, check out my blog, I love this stuff.

535
00:38:25,520 --> 00:38:27,200
I also teach it.

536
00:38:27,200 --> 00:38:29,320
I have a web course starting in two weeks.

537
00:38:29,320 --> 00:38:34,680
We have one of my former students sitting right there.

538
00:38:34,680 --> 00:38:38,240
I'd like to thank all the people who made this possible, people who invented what I

539
00:38:38,320 --> 00:38:44,920
talked about, well as organizers, but most importantly, St. Louis is my hometown, and

540
00:38:44,920 --> 00:38:47,560
so we have a very special guest today.

541
00:38:47,560 --> 00:38:53,560
I'd like to thank my father for never telling me that I'm crazy, even when he thought it.

542
00:38:58,560 --> 00:39:05,560
Remember, you are a program synthesizer, and do not cross the streams and do not cross

543
00:39:05,560 --> 00:39:09,720
the abstraction boundary.

544
00:39:09,720 --> 00:39:14,720
So one minute for questions, but I'll stay as long as I have askers.

545
00:39:14,720 --> 00:39:19,720
So let's wait for this to load.

546
00:39:19,720 --> 00:39:24,720
While it's loading, I'll take a hand.

547
00:39:24,720 --> 00:39:27,720
It's loaded.

548
00:39:27,720 --> 00:39:33,720
Let's see, I do not see any questions.

549
00:39:35,560 --> 00:39:42,560
If there are no questions, it's great to see you all today, and I hope you had a great strange loop.

