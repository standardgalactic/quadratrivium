start	end	text
0	6960	Hello.
6960	11720	My name is Jimmy Cupple, and I live a dual life.
11720	15840	By day, I work at MIT, I'm a researcher.
15840	19480	I work on program synthesis, programs that write programs.
19480	25120	By night, I lead workshops teaching software engineers like yourself how to write better
25120	26120	code.
26720	33320	Today I'm going to talk about something from intersection of both worlds.
33320	37000	Software engineering advice today is confusing.
37000	43120	For anything you read online, you'll find someone else arguing the opposite.
43120	48640	And today I want to ask the question, how do we find a source of truth in software engineering
48640	51080	advice?
51080	55400	This whole situation reminds me of another source of truth.
55400	60200	How do you prevent scurvy?
60200	64760	Scurvy is an ancient disease caused by vitamin C deficiency.
64760	70360	And after thousands of years of deaths, finally the 1700s, a British scientist named James
70360	78240	Lynde, proved in an experiment, the cure, eat citrus.
78240	84520	And so by the end of the century, the Royal Navy had started requiring all of their sailors
84600	86840	to drink lemon juice.
86840	91080	Scurvy rates went from crippling to almost none.
91080	96280	But then, in the 19th century, they lost the cure.
96280	102920	They didn't understand it well enough, they thought, lemons, why not limes, big mistake.
102920	110240	As a result, there were multiple voyages to the polls, as late as 1910, in which everyone
110240	113320	got scurvy and people died.
113320	118560	Now imagine that you are an 18th century sailor, and you ask the powers that be, how
118560	123680	can I prevent scurvy, and the answer comes, eat citrus.
123680	131040	But wait, lemons, not limes, and wait, do not boil it, and wait, do not store the juice
131040	132040	in copper.
132040	136800	If you store it in copper, it's worthless.
136800	140520	This is kind of starting to sound like witchdoctry.
140520	142760	Now compare soft engineering advice.
142760	149200	But first, so, before I get there, so from this, I coined the term citrus advice.
149200	154920	The advice to eat citrus is good advice to save people, but it was not precise enough
154920	160640	to capture the reality, and so it came with this long list of caveats that made it hard
160640	161640	to use.
161640	168280	The precise advice is to get vitamin C. And while it took about 200 years to get from
168280	174000	citrus to vitamin C, this is the ideal to be aiming for, the simple thing that explains
174000	176520	all of the caveats.
176520	178960	Now compare soft engineering advice.
178960	184760	The guru says, discover abstractions to make your code shorter.
184760	188040	Okay, I abstracted my code.
188040	191160	No, that is the wrong abstraction.
191160	193280	Duplication is better than the wrong abstraction.
193280	197760	Well, then how do I know fend an abstraction is a good design?
198240	202280	Well, you see, good design leads to simplicity.
202280	206280	Okay, I simplified my API.
206280	209240	No, you broke your API.
209240	214280	And if you break your API, that creates complexity for other programmers.
214280	219080	So this advice, not so easy, it's citrus advice.
219080	223760	And I think that if you were to take these four people, three people, these are all close
223760	225760	to but not actual quotes by these people.
225760	230080	If you were to show them the same piece of code and ask the same question, you would
230080	234960	get similar advice, which goes to show you that they have some deeper intuition about
234960	240960	some deeper reality that these words are not precise enough to capture.
240960	245480	So how do we get to more precise engineering advice?
245480	249520	Many years ago, I got really into program synthesis.
249520	253480	Program synthesis is amazing.
253480	257840	You like, it's this program where you just give them stuff, like you tell what you want
257840	263400	to do, on this input you should do this, maybe here's a little bit of information on what
263400	267200	the program should look like, and it thinks for a while with its algorithm and it gives
267200	268800	you a correct program.
268800	270160	It's cool.
270160	274160	But a really nice thing is that you cannot be as a synthesizer.
274160	278400	You cannot be as a synthesizer and you cannot be as a synthesizer.
278400	283240	If you ask a programmer, hey, Bob, if I do this thing, will it make it easier for us
283240	286040	to program later on?
286040	289240	It can be a pretty vague question, hard to answer.
289240	294920	But if you ask if I do this this way, will it make it easier to synthesize?
294920	296680	The algorithm is on paper.
296680	303480	You can just look at it, get an answer, and if you want to know if I have this data format
303480	307080	of the millions and millions of possible code that I can write, is there anything that's
307080	308080	clean?
308080	316760	You can just try it, get an answer, now.
316760	322240	So we're going to look at the parallels between synthesis and human programming.
322240	325000	We're going to dive into the different schools of synthesis.
325000	327320	Marley speaking, there are three kinds.
327320	333200	Non-synthesizers, theorem-proving, logic, enumerative, searching very cleverly through
333200	336000	large programs.
336000	342000	This is how your database optimizes your SQL queries, by the way, and using constraint
342000	343000	solvers.
343000	347480	In the interest of time, we're mostly going to talk about deductives today, a little bit
347480	350760	about constraint-based, no enumerative.
350760	356360	But there is a very important fourth school of synthesis.
356360	360720	And in fact, we have a few hundred examples of them in this room.
360720	362280	That is you.
362280	363600	You are a synthesizer.
363600	366120	You write programs.
366120	370560	And while you might work a little bit differently than these other algorithms, you do not have
370560	375920	the constraint solve in your head, although I do think you do work a bit like the deductive
375920	383760	synthesizer and do that kind of deductive reasoning, there is only one universe of possible programs.
383760	389240	Only one universe of possible algorithms for writing programs.
389240	394720	And so by looking at these other schools of synthesis, we can learn insights that we can
394720	402200	take into our own programming, and that is the thesis of today's talk.
402200	408000	And throughout our journey to synthesis lands, we will see three common recurring themes
408000	416680	of abstractions, constraints, and logic.
416680	419880	Enter deductive synthesis.
419880	424640	At a high level, deductive synthesis is about taking a high level idea, and through a series
424640	429680	of mechanical transformations, make it more and more refined and precise until you reach
429680	434000	an implementation.
434000	437720	So what is the information a deductive synthesizer works with?
438440	444680	When we talk about software, we are saying at one of three levels.
444680	446000	Here is a max function.
446000	451800	You can talk about the run time values, or you can talk about all inputs and look at
451800	452800	the code.
452800	457600	So run time is level one, code level two.
457600	461480	But this is not capturing the why of the code.
461480	466680	It does not explain why it works, it does not explain how you came up with it.
466680	473000	That information is in the logic, in the derivation or proof, and I call this level
473000	475600	three.
475600	481000	As you might guess from the relative size of these boxes, the most information lies
481000	483120	in level three.
483120	488600	But this is the why, this is the stuff that is only in your head normally.
488600	496200	But to a synthesizer, this is just as concrete as the code it outputs at the end.
496200	499400	So let's look at it from the synthesizer's perspective.
499400	502880	So quick background, here is what the deductive synthesizer looks like.
502880	508480	So it has some goal, like I need to get an integer, which is the maximum to other integers.
508480	514320	And you write down a logical formula for what that means, or specify it in some way.
514320	518200	And so our goal is we are given two integers, and we want a program such as after running
518200	525560	the program, then this condition, it is the maximum of the two inputs, will be true.
525560	534360	This tools, it has a bunch of rules that relate a piece of code to the abstract logical meaning
534360	537280	of the program.
537280	538600	And now it can do a search.
538600	543640	So we want this maximum, okay, let's try running the if rule.
543640	549320	Now we know the outer skeletons in if, and we have two sub goals to prove.
549320	554000	And we need to go into the search, maybe try if again, okay, let's try another rule, another
554000	555000	rule.
555120	559200	Maybe using if there was not a good idea, maybe it's trying to assignment instead, ah, that
559200	560960	works, there's my assignment.
560960	565080	Now I know a little bit more about the program, and it keeps going like this, and eventually
565080	568400	it gets the actual program.
568400	574720	So that was 40-year-old consensus nutshell, but you also see this idea in a lot of newer
574720	575720	systems.
575720	579400	If you're at Nadia's talk an hour ago, you saw her talk about an deductive synthesizer
579400	583720	called SYNQUID, Nadia was a post-talk in my lab.
583720	586680	The world of synthesis is very small.
586680	591040	And here are a couple other systems, Lambda squared and Fiat.
591040	597320	All these only do small functional programs because synthesis is very hard, which is why
597320	601720	instead of actually using this today, I'll tell you to not use it, but instead learn
601720	608400	the insights and use it to improve the only algorithms within your head.
609040	615760	By looking at things, this lens, deductive synthesis, we can come up with some deeper
615760	617280	insights to code.
617280	620960	Let's look at specification level notions.
620960	626880	I'm Ronnie at Web App, and I need sanitize strings, no excess attacks.
626880	632600	So to sanitize a string, I escape all single quotes.
632600	634760	And now I have two choices for how to use this.
634760	639160	Before I save my data to this, it must be sanitized, and I can do it either by calling
639160	644760	the sanitize function that I just wrote, or by doing it by hand.
644760	650840	And take a few seconds to look at these, decide whether you prefer option one or option two.
650840	669000	So when I've shown this before, it's a plurality for option one.
669000	675520	A slightly smaller number have no opinion, and a small minority for option two.
675520	680400	And in a minute, I'll give you a sense in which option one is a correct answer, and
680400	682680	there's some interpretations.
682680	687000	But so how else when you might have come to this conclusion?
687000	692760	Well, you might have used the folk engineering advice, and it's like it's more abstract,
692760	697000	but the other is more direct, and this one's hard to do in happening, it's more to understand,
697000	699040	it's easier to change.
699040	705080	And when you're working at this level, it's basically like two lawyers in the podium arguing
705080	708520	with their side, and both of them have case laws to support them.
709280	712400	It's hard to get a real right answer.
712400	715200	And even if you do, it might not be good enough.
715200	719880	So here's an engineer that I used to train, let's call him Steven, and his head is full
719880	725040	of citrus advice, and he looks at this and says, option one, it centralizes the code.
725040	726680	Good job, Steven.
726680	730760	But his understanding of the information hiding was not deep enough, because five minutes
730760	734760	later, I gave him a similar example.
734840	740280	So this time, I have my Twitter box, and I type in 139 characters, and it says too long.
740280	741280	What?
741280	746880	It's because it escaped my string, and it double counted every single quote, because
746880	749440	every single quote became two characters.
749440	755240	So let's not do that, let's undouble count the single quotes.
755240	758720	And I'm very glad that the Python standard library has this count function.
758720	762560	It made this slide easier to write.
762560	768080	But I propose, instead of doing maths, we abstract this counting pre-sanitized string
768080	770680	into a function.
770680	774200	And Steven looks at this, and he says, no.
774200	779400	Option one, it's a mistake in the slide, just say option one, is over-engineering.
779400	783400	This is premature abstraction, evil!
783680	793680	In a moment, we shall see how there is a principle that picks option one in both circumstances.
793680	799400	And if you adhere to this principle, then not only is option two disprofforable, it
799400	801280	is wrong.
801280	808560	And my wrong, I mean compile air level wrong.
808560	813040	This comes to the idea of encapsulating ideas.
813200	822680	And what the f does that mean?
822680	828200	So this is one of those vague things you might have heard before, where once you learn to
828200	834360	think like a synthesizer and actually see the logic it's based on, it becomes very precise.
834360	837360	And so let's do it.
837360	841760	And so through this lens of deduction and deductive synthesis, we're going to see how
841760	848000	option one is preferable in information hiding, how easy it is to think about and how easy
848000	853000	it is to write, and give precise meanings to all three of these lines.
853000	858280	And let's begin just by talking about what we mean by sanitized.
858280	862400	Well right now it means that every single quote is escaped.
862400	865560	And I can write this down formally in one of many notations.
865560	871360	I'm going to use cook because I'm familiar with it, but you can pick any of these others.
871360	874880	And you learned one of these earlier today, that's another session.
874880	880360	It looks like this, says before every single quote, there's a backslash.
880360	885120	And now other modules can use this definition when they're reading about code.
885120	890480	But there's something missing here, which is really that definition I gave a sanitized,
890480	892600	that's just today's definition.
892600	897080	And other modules can use it, but what if tomorrow I decide I need to escape other things?
897080	899600	I've changed the meaning of being sanitized.
899600	905880	Now all this other code, that in the reasoning, use the fact that this is what sanitized means,
905880	908040	those are now broken.
908040	918720	So what I want is to put all current and future meanings of sanitized behind some abstract
918720	919720	predicates.
919720	922880	Let's say I give this string, it is sanitized, what do you mean it's sanitized?
922880	926240	It's sanitized and that's final.
926240	931920	And now this sanitization module can change its mind about what it means by sanitized
931920	933240	and no one will ever know.
933240	935120	It's a secret.
935120	941240	And that is an abstraction barrier.
941240	943240	Do not cross.
943240	950560	Now, and you might have seen a diagram like this before, oh, I centralize my functionality,
950560	954760	I wrap it in a function, you can't expose it.
954760	955840	This is not like that.
955840	957520	This is purely an idea.
957520	960960	This sanitized predicate does not correspond to anything in your code, it's just how you
960960	962480	think about the code.
962480	966600	And on this slide, you'll see exactly how.
966600	972320	So in Cork, you write this idea of an opaque predicate, an existential predicate with the
972320	973520	opaque keyword.
973520	979680	Again, you can do this in about any other formalism, that is, this is the abstraction
979680	983520	boundary but written as code.
983520	987760	And now other modules do not get to think in detail, all they know is, I got a sanitized
987760	992320	thing, whatever that means, it's a black box.
992320	995480	So this is the sense in which option two is wrong.
995480	999720	Because in order to look at that code and read it as a human and say, I'm going to justify
999720	1005760	why this is doing what I want, you have to do something in your head, access the information
1005760	1009960	that sanitized strings have single quotes escaped and nothing else escaped.
1009960	1015600	And so what it's actually doing is it's piercing the abstraction barrier, do not cross, and
1015600	1019720	relying on this old piece of information that may change.
1019720	1021120	Dangerous.
1021120	1028800	Whereas in option one, all the information about what sanitized means is encapsulated
1028800	1030880	into the sanitization module.
1030880	1035320	So maybe the sanitized Stirland function, which is right next to sanitized, is allowed
1035320	1041440	to know what it means to be sanitized, but this user code is not.
1041440	1049280	And so thus, it is a secret preserved, it may be changed.
1049280	1055320	And the same view the sanitized predicates gives us the answer to the first question.
1055320	1061960	So here, my sanitized function returns, was returned, means it returns a sanitized string,
1061960	1064160	whatever that means.
1064160	1069240	And before I save, I have to feed it in a sanitized string, whatever that means.
1069240	1072240	And so when I put these functions together, they line up.
1072240	1081160	But when I try to sanitize it by hand, it's like, you gave me a string where you escape
1081160	1082160	single quotes.
1082160	1083640	I need a sanitized string.
1083640	1085560	I don't know these are the same.
1085560	1086560	What do you mean?
1086560	1087760	That is a sanitized string.
1087760	1090240	Oh, no, you can't use that information.
1090240	1091600	It is opaque, hidden.
1091600	1097440	It's behind the abstraction barrier, do not cross.
1097440	1098880	But that's just an interpretation.
1098880	1105680	There's another way of looking at the program that gives you the opposite conclusion.
1105680	1109400	Suppose the sanitized function is not allowed to know what the sanitized means.
1109400	1114600	I don't know what it returns, but you can't show it does not know what that means.
1114600	1117800	But this other code does know what sanitized means.
1117800	1122960	Then it works when you do it by hand, but not when you call this foreign function, who
1122960	1126680	knows what it does.
1126680	1131720	But of course, there is in the third option in which both are acceptable.
1131720	1133320	This is the hippie version.
1133320	1135680	There is no abstraction boundary.
1135680	1141360	Everyone gets to know about sanitization, those dirty hippies.
1141360	1146920	And in that case, in both modules, you're allowed to think about the definition of sanitized
1146920	1151600	and see that these line up and do either.
1151600	1157040	Now when you're actually programming, you don't write down these formal logic things.
1157040	1161480	You don't write pre-conditions and post-conditions in gratuitous detail and everything.
1161480	1168120	No, you have an idea in your head about what you're supposed to do, but it's not given
1168120	1170160	to the compiler.
1170160	1174960	And so for all three of these interpretations, all three of these worlds, whoever is allowed
1174960	1179360	to know what sanitized means, these all result in the same code.
1179360	1187080	The difference is only at level three in the logic, in the why, not in level two code.
1187080	1193120	But it's still which one of these worlds you choose is your interpretation determines
1193120	1196880	which option is correct and preferable.
1196880	1198840	So is it just a matter of interpretation?
1198840	1203080	Well, there's some pretty clear, like everything's a trade-off, but there are some pretty clear
1203080	1205680	reasons to pick option one.
1205680	1212320	So in option one, I'm all sanitized, and I need a sanitized string for save, so I could
1212320	1218840	have sanitized x, I need to show sanitized x in order to save it, and this proof is trivial.
1218840	1223880	Not always is it trivial, but if I'm programming in Koch, I can actually type in the word trivial
1223880	1229120	period, and it'll say, yep, that's a proof.
1229120	1235560	And more generally, it can get more complicated when you have aliasing and conditionals, but
1235560	1240480	it's still going to fall within a fragment of first-order logic called effectively propositional,
1240480	1246600	or EPR logic, which is generally pretty easy to reason about.
1246600	1248800	There are fast algorithms.
1248800	1253960	In the other world, I'm doing this replace all thing by hands, and you show it satisfies
1253960	1260960	some complicated condition about what goes where, and we can do this, but it's a little
1260960	1262640	bit harder.
1262640	1268200	So hard that was only discovered this year.
1268200	1277160	So in the first case, when I first write sanitized, I still need to prove that when I sanitize
1277160	1281800	a string, it satisfies the meaning of being sanitized, and so there I need to think a
1281800	1286400	little bit harder about the sanitized function, but when I actually use it, I can use the
1286400	1288600	fast EPR logic solver.
1288600	1289600	It's easy for me.
1289600	1295360	It's easy for this program to think about, whereas in the other options, I don't have
1295360	1301160	to clean module boundary, and so when I call save with this complicated by hand, replace
1301160	1310080	alling, now I need to use the very fancy chun algorithm and think about strings.
1310440	1317280	It's also easier for the synthesizer, because if I say, okay, I have a string, now I need
1317280	1322360	a sanitized string, I need to satisfy some condition about what goes where, everything
1322360	1323360	escapes.
1323360	1326840	It's like, okay, look, how can I get a sanitized string?
1326840	1331280	Is there a way to use replace all, is there a way to concatenate things or reverse things?
1331280	1335120	It has a lot of options to choose from and try in its search.
1335120	1338720	When you say it is sanitized, what does that mean?
1339080	1341360	It means no basis.
1341360	1345920	Then it is only one option for how to get a sanitized string, which is to call the sanitized
1345920	1351440	function, which exports an interface saying, get you a sanitized string.
1351440	1357920	And so that is the precise meaning of easier to think about and easier to code, synthesis
1357920	1360320	style.
1360320	1368120	So we've explored some correspondencies between the deductive schools of synthesis and you.
1368120	1375000	We've seen the themes of abstraction in the way that we hid, hid sanitized behind the
1375000	1378640	abstraction barrier, do not cross.
1378640	1383400	How does put constraints on the program and what is it possible to write?
1383400	1388760	And of course, all this is only seen at the level of logic.
1388760	1391560	Let's look at another example.
1391560	1397560	How is it possible to write a straight line program, no, no indentation.
1397560	1400640	That contains a conditional.
1400640	1401640	Let's find out.
1401640	1410840	I have a program on the server, returns 496, I swear it returns 1024.
1410840	1419600	And my friend Stephen sees this code and he sees that if statement and he gets mad.
1419600	1423400	Because the internet told him, do not use if statements.
1423400	1431480	Off to the if statements, join the if campaign, if statements are bad.
1431480	1434440	So it goes back to this code, he gets an idea.
1434440	1439880	This is in C. That is on server variable is either 0 or 1.
1439880	1445760	We can replace this if with an array index.
1445760	1449160	The guru is not pleased.
1449160	1453840	You have only moved the conditional into the array.
1453840	1455720	What?
1455720	1465640	So this is the if advice, a little bit less straightforward than it may have seen.
1465640	1467360	Let's see what that means.
1467360	1469840	A quick change of notation.
1469840	1477400	I'm going to denote the array, 1024, 496 by saying start with the empty array, add 0,
1477520	1483160	insert 1024, add 1, insert 496.
1483160	1485960	On top of this notation, we have the array axioms.
1485960	1493440	I'm not going to go into them in detail, but they tell me exactly what it means for, they
1493440	1497640	tell me exactly what it means for to index the array.
1497640	1505400	And it gives me this, it says, that's 1, the index is 496, else let's go deeper to the
1505400	1511360	array, add 0, it's 1024, let's go deeper to the array, oh, we're out of array, we're out
1511360	1518920	of axioms, so now it's undefined, but really the only thing you care about is at the bottom
1518920	1519920	right.
1519920	1527000	This simplifies to the formula, if x equals 0, the index is 1224, and if x is 1, then the
1527000	1530760	index is 496.
1530760	1537640	That formula is conditional, if x is this, then it's that, if x is this, then it's that.
1537640	1542600	Now using this, we can go back to the program and come up with a logical formula to describe
1542600	1545600	what the program does.
1545600	1552920	And we get a conditional, if it's on server, then it's 496, I'll say it's 1024.
1552920	1558600	And we can use other axioms to do the exact same for the original program, and we get
1558600	1562680	the exact same formula.
1562680	1567920	And so there's a sense that both of these have an additional, the same conditional.
1567920	1572000	And so the synthesizer is only looking at these formulas.
1572000	1577800	And so from its perspective, these two pieces of code are not just semantically equivalent,
1577800	1583760	they're actually structurally identical, we haven't changed it at all.
1583760	1588720	And so conditionals are a semantic notion, not an intact notion.
1588720	1593560	Just because you don't write the words letters I F, does not mean there's no if statement
1593560	1596080	in your code.
1596080	1600840	So the thing that happened here was the array index was conditional in disguise.
1600840	1606720	Does this mean we should have an anti-array campaign and no arrays, definitely array?
1606720	1607960	No.
1607960	1614280	Not every array access is conditional, but the difference is subtle.
1614280	1618440	And it cannot be purely determined from the code, but it's a property rather of the level
1618440	1620760	three, how you think about it.
1620760	1621760	Let's inspect.
1621760	1623760	Here's another array.
1623760	1626480	It's a list of all the president names.
1626480	1629480	And using that, we can define a president after function.
1629480	1631640	The president after Washington was Adams.
1631640	1636360	The president after Thomas Jefferson was James Madison and so on.
1636360	1638640	Here's a pretty simple function that does that.
1638640	1643640	It totally breaks on bad inputs, negatives, the last president.
1643640	1644640	Don't tell me about those.
1644640	1646920	It's a simple example.
1646920	1649720	And let's talk about what it means index into the array.
1649720	1654480	And like before, we get a giant conditional at zero, it's Washington, and it's one, it's
1654480	1656160	Adams, and so on.
1656160	1660520	This does not look promising, it looks conditional.
1660520	1669440	But if you already have a notion, an external notion of the ith president, then you can
1669440	1672560	relate this formula to that.
1672560	1677960	And you can get the simpler formula, it's the index of the ith, to name the ith president,
1677960	1681000	which is not involved in any ranching at all.
1681000	1685800	And now we can use this abstracted formula to look at this code and think about it in
1685800	1690480	a very short foreign manner, get this index, I can name the next president, and I'm done.
1691440	1695840	That's how you would think about it, and that's also how a veripyrocynthesizer would think
1695840	1700480	about it, just like I've written down here.
1700480	1703480	There's no casework in here, there's no branching.
1703480	1704480	Just works.
1704480	1713000	And so that's a sense in which one array index is a conditional and the other is not.
1713000	1717320	So the difference is that we're able to abstract one and not the other.
1717320	1721680	And you could abstract the size of the array, find a better way of thinking about it, but
1721680	1722680	I didn't.
1722680	1729400	And because I didn't find it's a way, that was conditional, and this one is not.
1729400	1733800	So we've again seen this insight from the doctoral school of synthesis to the human,
1733800	1738880	and when you see the abstraction and how we abstracted the array access, this lets us
1738880	1743560	put extra constraints in a program like death of the statement.
1743560	1750800	But this only is understood at the level of logic.
1750800	1755240	Let's go into another school of synthesis, the constraint-based, and this section is
1755240	1757840	going to be a little bit different from the previous ones.
1757840	1762440	I said at the beginning that a human and a deductive synthesizer are kind of similar,
1762440	1768360	and so deductive synthesis can shed light on software engineering advice, whereas the
1768360	1772400	numerator and constraint-based, they're not like a human synthesizer, so they're just
1772440	1776840	going to eliminate the nature of the programs themselves.
1776840	1782600	We're going to be talking about a tool called Sketch, built by my advisor, Armando Suarezama,
1782600	1788480	and the sketch is about programming with holes, like humans are clever and insightful
1788480	1789480	and slow.
1789480	1791200	Synthesizers are dumb, thorough, and fast.
1791200	1792200	Let's put them together.
1792200	1797160	You're going to write a higher level of the program, what the program kind of looks like,
1797160	1799480	the synthesizers are going to fill in the details.
1799480	1801920	So here's the Hello World example.
1801920	1805360	That question mark is a hole.
1805360	1810120	So this thing is asking, find me an integer question mark such that x times question mark
1810120	1816920	is equivalent to x times x for all inputs.
1816920	1820160	And you might figure out the answer, it's 2.
1820160	1824800	And this synthesizer will figure that out, too, after 0.452 seconds.
1824800	1829120	You can do more complicated things like Sketch, like if you have a really inefficient link
1829120	1832200	to this reversal, you can get the fast one.
1832200	1835840	You do need a bit more of a complicated hole than an integer, say, like some number of
1835840	1839680	statements where a statement looks like this, but it can do it.
1839680	1845240	So I'm going to give you a two-minute version of the synthesis algorithm.
1845240	1851160	There's two parts, constraint and solving, and the see just loop.
1851160	1853520	So it looks like this.
1853800	1856120	For simplicity, all integers are two bits.
1856120	1859680	You'll think we have added a moment.
1859680	1864920	And we can just say, let's look at the bits of the inputs and the hole and the arithmetic
1864920	1865920	expressions.
1865920	1870640	And all these give us constraints that the bits of the digits of the plus expression
1870640	1874360	need to match the corresponding ones in the multiplication expression.
1874360	1877520	So we get a list of constraints on the bits.
1877520	1882240	And now we can also write down bits, level formulas for every bit of the plus in the
1882240	1883240	times.
1883240	1889080	And it looks like this, some big Boolean formulas, thank goodness there's only two bit numbers.
1889080	1893720	And now we'll just solve for what the bits of the hole are.
1893720	1897560	And if you're taking a theory of computing course, you might start getting a little scared.
1897560	1900680	Because in a theory of computing course, you might have learned that this is the Boolean
1900680	1901960	satisfiability problem.
1901960	1906200	We need to find a sign to these bits that the thing works.
1906200	1907720	That's the SAT problem.
1907720	1911640	Oh, no, that's NP-hard.
1911640	1914800	And that is a lie.
1914800	1918960	Because it's actually NP-easy.
1918960	1924800	And by that, I mean that modern SAT solvers can take in millions of variables and solve
1924800	1929200	them very fast, most of the time.
1929200	1932520	In this case, we're lucky enough to be in the most of the time.
1932520	1938160	And so we figure out the bits of the hole and we get the final answer of two.
1938160	1943000	Woo-hoo, synthesis.
1943000	1948440	But really, it makes it easier to think about if you just pick a few inputs at one time
1948440	1951000	instead of all inputs.
1951000	1955000	So on top of this, we build something called the counter-example-guided inductive synthesis
1955000	1956600	loop, sieges.
1956600	1960640	And it's basically a conversation between two parts, the inductive synthesizer and
1960640	1961640	the verifier.
1961640	1966040	The inductive synthesizer takes some input, takes some tests, gives you a program.
1966040	1971200	The verifier takes in a program and says, if it always works, if not, a failing input.
1971200	1972200	So does this work?
1972200	1973200	No.
1973200	1974200	It fails this input.
1974200	1975200	Does this work?
1975200	1976200	No.
1976200	1977200	It's a failing test.
1977200	1978200	Does this work?
1978200	1979200	Yes.
1979200	1983000	In other words, sieges is test-driven development.
1983000	1989320	And from this, I get the idea, maybe you can somehow use Sketch and sieges to tell us
1989320	1991760	something about testing.
1991760	1993760	Let's do it.
1993760	1998000	What we're going to do is I want to see if my test case is good enough.
1998000	2001520	If it's good enough, if the test pass, my program works.
2001520	2009000	So is there a way to write a program that passes all my tests but is the wrong program?
2009000	2012240	Let's use synthesis to find out.
2012240	2019960	A view of testing is that you have some space of correct programs that you want to find,
2019960	2025520	and every test is going to narrow down the passing programs more and more, hopefully to
2025520	2028560	just the correct ones.
2028560	2031080	But there's something missing from this story.
2031080	2036120	Here's a very simple kind of program, curves on an xy plane.
2036120	2041280	Here are my test points, and I want a curve that goes through all three points.
2041280	2044680	Can you guess what curve I have in mind?
2044680	2045680	That's right.
2045680	2046680	It's this guy.
2046680	2047680	No, no, no.
2047680	2048680	Here's another test.
2048920	2051920	Oh, you mean this one?
2051920	2057040	But if we add a structural constraint that the curve must be a line, then those two
2057040	2061000	options go away, and the only option is this line.
2061000	2065360	And not only that, but I need fewer points, fewer test cases.
2065360	2069040	And programs are just generalized polynomials.
2069040	2072440	And programs such that this is just generalized curve fitting.
2072440	2075000	So what does this look like for testing programs?
2075720	2079520	Well, if you have some kind of structural constraint in the program that you can write,
2079520	2082520	then maybe you don't need this third test.
2082520	2084640	So let's put that in action.
2084640	2090000	So I want to synthesize a function to do something very complicated, the length of a link list.
2090000	2093120	Here are my three test cases on the left.
2093120	2102600	And for this, I do need to have some kind of oracle that tells me what the correct answer
2102600	2104040	is.
2104040	2109000	Using this, I'm going to synthesize a length function, which passes all the three tests
2109000	2114480	that I gave it, whether it is some input list question mark, which differs from the
2114480	2115840	correct answer.
2115840	2119440	So pass all the test cases, but it's wrong on somewhere.
2119440	2123040	Let's synthesize.
2123040	2127280	So first, I say it'll have at most three branches.
2127280	2131720	Each conditional looks something like this, some reasonable list operations.
2131720	2137520	Now things can happen within each branch, and let's see if it can come up with something.
2137520	2139040	And it does.
2139040	2142800	Sketch produces correct output, not readable output.
2142800	2149040	And so in order to make sure I have the right program, I need to add another test, like
2149040	2150800	list of length three.
2150800	2156760	And now it says, if it passed all the tests, there's no way to make it the wrong program.
2156760	2163480	But if I restrict my program a little bit, then I don't need that test anymore.
2163480	2168800	And just the only three tests, I must have the correct program.
2168800	2174640	So there's all this talk about more coverage, more tests, more precise.
2174640	2180080	But we don't often hear about writing the simpler code, in that the more one we have,
2180080	2181080	the less the other we need.
2181080	2185440	Write simpler code, then you don't need as many tests.
2185440	2192600	And it's a choice, but I know which end I prefer.
2192600	2198360	Because there's a saying that quality cannot be tested in, quality must be built in.
2198360	2202280	And this is what it means.
2202280	2206920	So we've gotten some insights into writing programs, writing tests from the School of
2206920	2208960	Constraint-based Synthesis.
2208960	2215320	And again, we've seen abstraction in our use of this test oracle, constraints in how
2215320	2220360	we restrict the program space to make it work, and the synthesis algorithm itself is based
2220360	2223640	on logic.
2223640	2228720	So we've seen a lot of stuff today.
2228720	2234560	You've learned the high level of two different synthesis algorithms, seen a lot of stuff
2234560	2239120	you probably haven't seen before, but really what we're doing is reaching that black box
2239120	2244200	in your head of how we write programs, and kind of opening up a bit and seeing how it
2244200	2245200	works.
2245200	2254760	And in doing so, we can start to stop accepting vague answers for what we should be doing,
2254760	2258600	start to accept, maybe we can think a little bit deeper about what's going on.
2258600	2261360	What is it possible for me to write right now?
2261360	2265480	Sometimes we're on a wild west, not anything goes, there's a structure to what it's possible
2265480	2270600	to write, and we're accepting that we can find it.
2270600	2276280	So my hope is that becoming here today, you're joining me all, you're all joining me on a
2276280	2281960	journey to get away from the citrus advice to become used to, start to learn how to see
2281960	2285160	the vitamins in our code.
2285160	2290920	Because the first step, the most important step you've already done, to get to more precise
2290960	2296000	hard-generated advice, the big step is simply to believe that it's possible, because you
2296000	2299240	are a program synthesizer.
2299240	2305520	So if you want to see more about this, check out my blog, I love this stuff.
2305520	2307200	I also teach it.
2307200	2309320	I have a web course starting in two weeks.
2309320	2314680	We have one of my former students sitting right there.
2314680	2318240	I'd like to thank all the people who made this possible, people who invented what I
2318320	2324920	talked about, well as organizers, but most importantly, St. Louis is my hometown, and
2324920	2327560	so we have a very special guest today.
2327560	2333560	I'd like to thank my father for never telling me that I'm crazy, even when he thought it.
2338560	2345560	Remember, you are a program synthesizer, and do not cross the streams and do not cross
2345560	2349720	the abstraction boundary.
2349720	2354720	So one minute for questions, but I'll stay as long as I have askers.
2354720	2359720	So let's wait for this to load.
2359720	2364720	While it's loading, I'll take a hand.
2364720	2367720	It's loaded.
2367720	2373720	Let's see, I do not see any questions.
2375560	2382560	If there are no questions, it's great to see you all today, and I hope you had a great strange loop.
