WEBVTT

00:00.000 --> 00:06.960
Hello.

00:06.960 --> 00:11.720
My name is Jimmy Cupple, and I live a dual life.

00:11.720 --> 00:15.840
By day, I work at MIT, I'm a researcher.

00:15.840 --> 00:19.480
I work on program synthesis, programs that write programs.

00:19.480 --> 00:25.120
By night, I lead workshops teaching software engineers like yourself how to write better

00:25.120 --> 00:26.120
code.

00:26.720 --> 00:33.320
Today I'm going to talk about something from intersection of both worlds.

00:33.320 --> 00:37.000
Software engineering advice today is confusing.

00:37.000 --> 00:43.120
For anything you read online, you'll find someone else arguing the opposite.

00:43.120 --> 00:48.640
And today I want to ask the question, how do we find a source of truth in software engineering

00:48.640 --> 00:51.080
advice?

00:51.080 --> 00:55.400
This whole situation reminds me of another source of truth.

00:55.400 --> 01:00.200
How do you prevent scurvy?

01:00.200 --> 01:04.760
Scurvy is an ancient disease caused by vitamin C deficiency.

01:04.760 --> 01:10.360
And after thousands of years of deaths, finally the 1700s, a British scientist named James

01:10.360 --> 01:18.240
Lynde, proved in an experiment, the cure, eat citrus.

01:18.240 --> 01:24.520
And so by the end of the century, the Royal Navy had started requiring all of their sailors

01:24.600 --> 01:26.840
to drink lemon juice.

01:26.840 --> 01:31.080
Scurvy rates went from crippling to almost none.

01:31.080 --> 01:36.280
But then, in the 19th century, they lost the cure.

01:36.280 --> 01:42.920
They didn't understand it well enough, they thought, lemons, why not limes, big mistake.

01:42.920 --> 01:50.240
As a result, there were multiple voyages to the polls, as late as 1910, in which everyone

01:50.240 --> 01:53.320
got scurvy and people died.

01:53.320 --> 01:58.560
Now imagine that you are an 18th century sailor, and you ask the powers that be, how

01:58.560 --> 02:03.680
can I prevent scurvy, and the answer comes, eat citrus.

02:03.680 --> 02:11.040
But wait, lemons, not limes, and wait, do not boil it, and wait, do not store the juice

02:11.040 --> 02:12.040
in copper.

02:12.040 --> 02:16.800
If you store it in copper, it's worthless.

02:16.800 --> 02:20.520
This is kind of starting to sound like witchdoctry.

02:20.520 --> 02:22.760
Now compare soft engineering advice.

02:22.760 --> 02:29.200
But first, so, before I get there, so from this, I coined the term citrus advice.

02:29.200 --> 02:34.920
The advice to eat citrus is good advice to save people, but it was not precise enough

02:34.920 --> 02:40.640
to capture the reality, and so it came with this long list of caveats that made it hard

02:40.640 --> 02:41.640
to use.

02:41.640 --> 02:48.280
The precise advice is to get vitamin C. And while it took about 200 years to get from

02:48.280 --> 02:54.000
citrus to vitamin C, this is the ideal to be aiming for, the simple thing that explains

02:54.000 --> 02:56.520
all of the caveats.

02:56.520 --> 02:58.960
Now compare soft engineering advice.

02:58.960 --> 03:04.760
The guru says, discover abstractions to make your code shorter.

03:04.760 --> 03:08.040
Okay, I abstracted my code.

03:08.040 --> 03:11.160
No, that is the wrong abstraction.

03:11.160 --> 03:13.280
Duplication is better than the wrong abstraction.

03:13.280 --> 03:17.760
Well, then how do I know fend an abstraction is a good design?

03:18.240 --> 03:22.280
Well, you see, good design leads to simplicity.

03:22.280 --> 03:26.280
Okay, I simplified my API.

03:26.280 --> 03:29.240
No, you broke your API.

03:29.240 --> 03:34.280
And if you break your API, that creates complexity for other programmers.

03:34.280 --> 03:39.080
So this advice, not so easy, it's citrus advice.

03:39.080 --> 03:43.760
And I think that if you were to take these four people, three people, these are all close

03:43.760 --> 03:45.760
to but not actual quotes by these people.

03:45.760 --> 03:50.080
If you were to show them the same piece of code and ask the same question, you would

03:50.080 --> 03:54.960
get similar advice, which goes to show you that they have some deeper intuition about

03:54.960 --> 04:00.960
some deeper reality that these words are not precise enough to capture.

04:00.960 --> 04:05.480
So how do we get to more precise engineering advice?

04:05.480 --> 04:09.520
Many years ago, I got really into program synthesis.

04:09.520 --> 04:13.480
Program synthesis is amazing.

04:13.480 --> 04:17.840
You like, it's this program where you just give them stuff, like you tell what you want

04:17.840 --> 04:23.400
to do, on this input you should do this, maybe here's a little bit of information on what

04:23.400 --> 04:27.200
the program should look like, and it thinks for a while with its algorithm and it gives

04:27.200 --> 04:28.800
you a correct program.

04:28.800 --> 04:30.160
It's cool.

04:30.160 --> 04:34.160
But a really nice thing is that you cannot be as a synthesizer.

04:34.160 --> 04:38.400
You cannot be as a synthesizer and you cannot be as a synthesizer.

04:38.400 --> 04:43.240
If you ask a programmer, hey, Bob, if I do this thing, will it make it easier for us

04:43.240 --> 04:46.040
to program later on?

04:46.040 --> 04:49.240
It can be a pretty vague question, hard to answer.

04:49.240 --> 04:54.920
But if you ask if I do this this way, will it make it easier to synthesize?

04:54.920 --> 04:56.680
The algorithm is on paper.

04:56.680 --> 05:03.480
You can just look at it, get an answer, and if you want to know if I have this data format

05:03.480 --> 05:07.080
of the millions and millions of possible code that I can write, is there anything that's

05:07.080 --> 05:08.080
clean?

05:08.080 --> 05:16.760
You can just try it, get an answer, now.

05:16.760 --> 05:22.240
So we're going to look at the parallels between synthesis and human programming.

05:22.240 --> 05:25.000
We're going to dive into the different schools of synthesis.

05:25.000 --> 05:27.320
Marley speaking, there are three kinds.

05:27.320 --> 05:33.200
Non-synthesizers, theorem-proving, logic, enumerative, searching very cleverly through

05:33.200 --> 05:36.000
large programs.

05:36.000 --> 05:42.000
This is how your database optimizes your SQL queries, by the way, and using constraint

05:42.000 --> 05:43.000
solvers.

05:43.000 --> 05:47.480
In the interest of time, we're mostly going to talk about deductives today, a little bit

05:47.480 --> 05:50.760
about constraint-based, no enumerative.

05:50.760 --> 05:56.360
But there is a very important fourth school of synthesis.

05:56.360 --> 06:00.720
And in fact, we have a few hundred examples of them in this room.

06:00.720 --> 06:02.280
That is you.

06:02.280 --> 06:03.600
You are a synthesizer.

06:03.600 --> 06:06.120
You write programs.

06:06.120 --> 06:10.560
And while you might work a little bit differently than these other algorithms, you do not have

06:10.560 --> 06:15.920
the constraint solve in your head, although I do think you do work a bit like the deductive

06:15.920 --> 06:23.760
synthesizer and do that kind of deductive reasoning, there is only one universe of possible programs.

06:23.760 --> 06:29.240
Only one universe of possible algorithms for writing programs.

06:29.240 --> 06:34.720
And so by looking at these other schools of synthesis, we can learn insights that we can

06:34.720 --> 06:42.200
take into our own programming, and that is the thesis of today's talk.

06:42.200 --> 06:48.000
And throughout our journey to synthesis lands, we will see three common recurring themes

06:48.000 --> 06:56.680
of abstractions, constraints, and logic.

06:56.680 --> 06:59.880
Enter deductive synthesis.

06:59.880 --> 07:04.640
At a high level, deductive synthesis is about taking a high level idea, and through a series

07:04.640 --> 07:09.680
of mechanical transformations, make it more and more refined and precise until you reach

07:09.680 --> 07:14.000
an implementation.

07:14.000 --> 07:17.720
So what is the information a deductive synthesizer works with?

07:18.440 --> 07:24.680
When we talk about software, we are saying at one of three levels.

07:24.680 --> 07:26.000
Here is a max function.

07:26.000 --> 07:31.800
You can talk about the run time values, or you can talk about all inputs and look at

07:31.800 --> 07:32.800
the code.

07:32.800 --> 07:37.600
So run time is level one, code level two.

07:37.600 --> 07:41.480
But this is not capturing the why of the code.

07:41.480 --> 07:46.680
It does not explain why it works, it does not explain how you came up with it.

07:46.680 --> 07:53.000
That information is in the logic, in the derivation or proof, and I call this level

07:53.000 --> 07:55.600
three.

07:55.600 --> 08:01.000
As you might guess from the relative size of these boxes, the most information lies

08:01.000 --> 08:03.120
in level three.

08:03.120 --> 08:08.600
But this is the why, this is the stuff that is only in your head normally.

08:08.600 --> 08:16.200
But to a synthesizer, this is just as concrete as the code it outputs at the end.

08:16.200 --> 08:19.400
So let's look at it from the synthesizer's perspective.

08:19.400 --> 08:22.880
So quick background, here is what the deductive synthesizer looks like.

08:22.880 --> 08:28.480
So it has some goal, like I need to get an integer, which is the maximum to other integers.

08:28.480 --> 08:34.320
And you write down a logical formula for what that means, or specify it in some way.

08:34.320 --> 08:38.200
And so our goal is we are given two integers, and we want a program such as after running

08:38.200 --> 08:45.560
the program, then this condition, it is the maximum of the two inputs, will be true.

08:45.560 --> 08:54.360
This tools, it has a bunch of rules that relate a piece of code to the abstract logical meaning

08:54.360 --> 08:57.280
of the program.

08:57.280 --> 08:58.600
And now it can do a search.

08:58.600 --> 09:03.640
So we want this maximum, okay, let's try running the if rule.

09:03.640 --> 09:09.320
Now we know the outer skeletons in if, and we have two sub goals to prove.

09:09.320 --> 09:14.000
And we need to go into the search, maybe try if again, okay, let's try another rule, another

09:14.000 --> 09:15.000
rule.

09:15.120 --> 09:19.200
Maybe using if there was not a good idea, maybe it's trying to assignment instead, ah, that

09:19.200 --> 09:20.960
works, there's my assignment.

09:20.960 --> 09:25.080
Now I know a little bit more about the program, and it keeps going like this, and eventually

09:25.080 --> 09:28.400
it gets the actual program.

09:28.400 --> 09:34.720
So that was 40-year-old consensus nutshell, but you also see this idea in a lot of newer

09:34.720 --> 09:35.720
systems.

09:35.720 --> 09:39.400
If you're at Nadia's talk an hour ago, you saw her talk about an deductive synthesizer

09:39.400 --> 09:43.720
called SYNQUID, Nadia was a post-talk in my lab.

09:43.720 --> 09:46.680
The world of synthesis is very small.

09:46.680 --> 09:51.040
And here are a couple other systems, Lambda squared and Fiat.

09:51.040 --> 09:57.320
All these only do small functional programs because synthesis is very hard, which is why

09:57.320 --> 10:01.720
instead of actually using this today, I'll tell you to not use it, but instead learn

10:01.720 --> 10:08.400
the insights and use it to improve the only algorithms within your head.

10:09.040 --> 10:15.760
By looking at things, this lens, deductive synthesis, we can come up with some deeper

10:15.760 --> 10:17.280
insights to code.

10:17.280 --> 10:20.960
Let's look at specification level notions.

10:20.960 --> 10:26.880
I'm Ronnie at Web App, and I need sanitize strings, no excess attacks.

10:26.880 --> 10:32.600
So to sanitize a string, I escape all single quotes.

10:32.600 --> 10:34.760
And now I have two choices for how to use this.

10:34.760 --> 10:39.160
Before I save my data to this, it must be sanitized, and I can do it either by calling

10:39.160 --> 10:44.760
the sanitize function that I just wrote, or by doing it by hand.

10:44.760 --> 10:50.840
And take a few seconds to look at these, decide whether you prefer option one or option two.

10:50.840 --> 11:09.000
So when I've shown this before, it's a plurality for option one.

11:09.000 --> 11:15.520
A slightly smaller number have no opinion, and a small minority for option two.

11:15.520 --> 11:20.400
And in a minute, I'll give you a sense in which option one is a correct answer, and

11:20.400 --> 11:22.680
there's some interpretations.

11:22.680 --> 11:27.000
But so how else when you might have come to this conclusion?

11:27.000 --> 11:32.760
Well, you might have used the folk engineering advice, and it's like it's more abstract,

11:32.760 --> 11:37.000
but the other is more direct, and this one's hard to do in happening, it's more to understand,

11:37.000 --> 11:39.040
it's easier to change.

11:39.040 --> 11:45.080
And when you're working at this level, it's basically like two lawyers in the podium arguing

11:45.080 --> 11:48.520
with their side, and both of them have case laws to support them.

11:49.280 --> 11:52.400
It's hard to get a real right answer.

11:52.400 --> 11:55.200
And even if you do, it might not be good enough.

11:55.200 --> 11:59.880
So here's an engineer that I used to train, let's call him Steven, and his head is full

11:59.880 --> 12:05.040
of citrus advice, and he looks at this and says, option one, it centralizes the code.

12:05.040 --> 12:06.680
Good job, Steven.

12:06.680 --> 12:10.760
But his understanding of the information hiding was not deep enough, because five minutes

12:10.760 --> 12:14.760
later, I gave him a similar example.

12:14.840 --> 12:20.280
So this time, I have my Twitter box, and I type in 139 characters, and it says too long.

12:20.280 --> 12:21.280
What?

12:21.280 --> 12:26.880
It's because it escaped my string, and it double counted every single quote, because

12:26.880 --> 12:29.440
every single quote became two characters.

12:29.440 --> 12:35.240
So let's not do that, let's undouble count the single quotes.

12:35.240 --> 12:38.720
And I'm very glad that the Python standard library has this count function.

12:38.720 --> 12:42.560
It made this slide easier to write.

12:42.560 --> 12:48.080
But I propose, instead of doing maths, we abstract this counting pre-sanitized string

12:48.080 --> 12:50.680
into a function.

12:50.680 --> 12:54.200
And Steven looks at this, and he says, no.

12:54.200 --> 12:59.400
Option one, it's a mistake in the slide, just say option one, is over-engineering.

12:59.400 --> 13:03.400
This is premature abstraction, evil!

13:03.680 --> 13:13.680
In a moment, we shall see how there is a principle that picks option one in both circumstances.

13:13.680 --> 13:19.400
And if you adhere to this principle, then not only is option two disprofforable, it

13:19.400 --> 13:21.280
is wrong.

13:21.280 --> 13:28.560
And my wrong, I mean compile air level wrong.

13:28.560 --> 13:33.040
This comes to the idea of encapsulating ideas.

13:33.200 --> 13:42.680
And what the f does that mean?

13:42.680 --> 13:48.200
So this is one of those vague things you might have heard before, where once you learn to

13:48.200 --> 13:54.360
think like a synthesizer and actually see the logic it's based on, it becomes very precise.

13:54.360 --> 13:57.360
And so let's do it.

13:57.360 --> 14:01.760
And so through this lens of deduction and deductive synthesis, we're going to see how

14:01.760 --> 14:08.000
option one is preferable in information hiding, how easy it is to think about and how easy

14:08.000 --> 14:13.000
it is to write, and give precise meanings to all three of these lines.

14:13.000 --> 14:18.280
And let's begin just by talking about what we mean by sanitized.

14:18.280 --> 14:22.400
Well right now it means that every single quote is escaped.

14:22.400 --> 14:25.560
And I can write this down formally in one of many notations.

14:25.560 --> 14:31.360
I'm going to use cook because I'm familiar with it, but you can pick any of these others.

14:31.360 --> 14:34.880
And you learned one of these earlier today, that's another session.

14:34.880 --> 14:40.360
It looks like this, says before every single quote, there's a backslash.

14:40.360 --> 14:45.120
And now other modules can use this definition when they're reading about code.

14:45.120 --> 14:50.480
But there's something missing here, which is really that definition I gave a sanitized,

14:50.480 --> 14:52.600
that's just today's definition.

14:52.600 --> 14:57.080
And other modules can use it, but what if tomorrow I decide I need to escape other things?

14:57.080 --> 14:59.600
I've changed the meaning of being sanitized.

14:59.600 --> 15:05.880
Now all this other code, that in the reasoning, use the fact that this is what sanitized means,

15:05.880 --> 15:08.040
those are now broken.

15:08.040 --> 15:18.720
So what I want is to put all current and future meanings of sanitized behind some abstract

15:18.720 --> 15:19.720
predicates.

15:19.720 --> 15:22.880
Let's say I give this string, it is sanitized, what do you mean it's sanitized?

15:22.880 --> 15:26.240
It's sanitized and that's final.

15:26.240 --> 15:31.920
And now this sanitization module can change its mind about what it means by sanitized

15:31.920 --> 15:33.240
and no one will ever know.

15:33.240 --> 15:35.120
It's a secret.

15:35.120 --> 15:41.240
And that is an abstraction barrier.

15:41.240 --> 15:43.240
Do not cross.

15:43.240 --> 15:50.560
Now, and you might have seen a diagram like this before, oh, I centralize my functionality,

15:50.560 --> 15:54.760
I wrap it in a function, you can't expose it.

15:54.760 --> 15:55.840
This is not like that.

15:55.840 --> 15:57.520
This is purely an idea.

15:57.520 --> 16:00.960
This sanitized predicate does not correspond to anything in your code, it's just how you

16:00.960 --> 16:02.480
think about the code.

16:02.480 --> 16:06.600
And on this slide, you'll see exactly how.

16:06.600 --> 16:12.320
So in Cork, you write this idea of an opaque predicate, an existential predicate with the

16:12.320 --> 16:13.520
opaque keyword.

16:13.520 --> 16:19.680
Again, you can do this in about any other formalism, that is, this is the abstraction

16:19.680 --> 16:23.520
boundary but written as code.

16:23.520 --> 16:27.760
And now other modules do not get to think in detail, all they know is, I got a sanitized

16:27.760 --> 16:32.320
thing, whatever that means, it's a black box.

16:32.320 --> 16:35.480
So this is the sense in which option two is wrong.

16:35.480 --> 16:39.720
Because in order to look at that code and read it as a human and say, I'm going to justify

16:39.720 --> 16:45.760
why this is doing what I want, you have to do something in your head, access the information

16:45.760 --> 16:49.960
that sanitized strings have single quotes escaped and nothing else escaped.

16:49.960 --> 16:55.600
And so what it's actually doing is it's piercing the abstraction barrier, do not cross, and

16:55.600 --> 16:59.720
relying on this old piece of information that may change.

16:59.720 --> 17:01.120
Dangerous.

17:01.120 --> 17:08.800
Whereas in option one, all the information about what sanitized means is encapsulated

17:08.800 --> 17:10.880
into the sanitization module.

17:10.880 --> 17:15.320
So maybe the sanitized Stirland function, which is right next to sanitized, is allowed

17:15.320 --> 17:21.440
to know what it means to be sanitized, but this user code is not.

17:21.440 --> 17:29.280
And so thus, it is a secret preserved, it may be changed.

17:29.280 --> 17:35.320
And the same view the sanitized predicates gives us the answer to the first question.

17:35.320 --> 17:41.960
So here, my sanitized function returns, was returned, means it returns a sanitized string,

17:41.960 --> 17:44.160
whatever that means.

17:44.160 --> 17:49.240
And before I save, I have to feed it in a sanitized string, whatever that means.

17:49.240 --> 17:52.240
And so when I put these functions together, they line up.

17:52.240 --> 18:01.160
But when I try to sanitize it by hand, it's like, you gave me a string where you escape

18:01.160 --> 18:02.160
single quotes.

18:02.160 --> 18:03.640
I need a sanitized string.

18:03.640 --> 18:05.560
I don't know these are the same.

18:05.560 --> 18:06.560
What do you mean?

18:06.560 --> 18:07.760
That is a sanitized string.

18:07.760 --> 18:10.240
Oh, no, you can't use that information.

18:10.240 --> 18:11.600
It is opaque, hidden.

18:11.600 --> 18:17.440
It's behind the abstraction barrier, do not cross.

18:17.440 --> 18:18.880
But that's just an interpretation.

18:18.880 --> 18:25.680
There's another way of looking at the program that gives you the opposite conclusion.

18:25.680 --> 18:29.400
Suppose the sanitized function is not allowed to know what the sanitized means.

18:29.400 --> 18:34.600
I don't know what it returns, but you can't show it does not know what that means.

18:34.600 --> 18:37.800
But this other code does know what sanitized means.

18:37.800 --> 18:42.960
Then it works when you do it by hand, but not when you call this foreign function, who

18:42.960 --> 18:46.680
knows what it does.

18:46.680 --> 18:51.720
But of course, there is in the third option in which both are acceptable.

18:51.720 --> 18:53.320
This is the hippie version.

18:53.320 --> 18:55.680
There is no abstraction boundary.

18:55.680 --> 19:01.360
Everyone gets to know about sanitization, those dirty hippies.

19:01.360 --> 19:06.920
And in that case, in both modules, you're allowed to think about the definition of sanitized

19:06.920 --> 19:11.600
and see that these line up and do either.

19:11.600 --> 19:17.040
Now when you're actually programming, you don't write down these formal logic things.

19:17.040 --> 19:21.480
You don't write pre-conditions and post-conditions in gratuitous detail and everything.

19:21.480 --> 19:28.120
No, you have an idea in your head about what you're supposed to do, but it's not given

19:28.120 --> 19:30.160
to the compiler.

19:30.160 --> 19:34.960
And so for all three of these interpretations, all three of these worlds, whoever is allowed

19:34.960 --> 19:39.360
to know what sanitized means, these all result in the same code.

19:39.360 --> 19:47.080
The difference is only at level three in the logic, in the why, not in level two code.

19:47.080 --> 19:53.120
But it's still which one of these worlds you choose is your interpretation determines

19:53.120 --> 19:56.880
which option is correct and preferable.

19:56.880 --> 19:58.840
So is it just a matter of interpretation?

19:58.840 --> 20:03.080
Well, there's some pretty clear, like everything's a trade-off, but there are some pretty clear

20:03.080 --> 20:05.680
reasons to pick option one.

20:05.680 --> 20:12.320
So in option one, I'm all sanitized, and I need a sanitized string for save, so I could

20:12.320 --> 20:18.840
have sanitized x, I need to show sanitized x in order to save it, and this proof is trivial.

20:18.840 --> 20:23.880
Not always is it trivial, but if I'm programming in Koch, I can actually type in the word trivial

20:23.880 --> 20:29.120
period, and it'll say, yep, that's a proof.

20:29.120 --> 20:35.560
And more generally, it can get more complicated when you have aliasing and conditionals, but

20:35.560 --> 20:40.480
it's still going to fall within a fragment of first-order logic called effectively propositional,

20:40.480 --> 20:46.600
or EPR logic, which is generally pretty easy to reason about.

20:46.600 --> 20:48.800
There are fast algorithms.

20:48.800 --> 20:53.960
In the other world, I'm doing this replace all thing by hands, and you show it satisfies

20:53.960 --> 21:00.960
some complicated condition about what goes where, and we can do this, but it's a little

21:00.960 --> 21:02.640
bit harder.

21:02.640 --> 21:08.200
So hard that was only discovered this year.

21:08.200 --> 21:17.160
So in the first case, when I first write sanitized, I still need to prove that when I sanitize

21:17.160 --> 21:21.800
a string, it satisfies the meaning of being sanitized, and so there I need to think a

21:21.800 --> 21:26.400
little bit harder about the sanitized function, but when I actually use it, I can use the

21:26.400 --> 21:28.600
fast EPR logic solver.

21:28.600 --> 21:29.600
It's easy for me.

21:29.600 --> 21:35.360
It's easy for this program to think about, whereas in the other options, I don't have

21:35.360 --> 21:41.160
to clean module boundary, and so when I call save with this complicated by hand, replace

21:41.160 --> 21:50.080
alling, now I need to use the very fancy chun algorithm and think about strings.

21:50.440 --> 21:57.280
It's also easier for the synthesizer, because if I say, okay, I have a string, now I need

21:57.280 --> 22:02.360
a sanitized string, I need to satisfy some condition about what goes where, everything

22:02.360 --> 22:03.360
escapes.

22:03.360 --> 22:06.840
It's like, okay, look, how can I get a sanitized string?

22:06.840 --> 22:11.280
Is there a way to use replace all, is there a way to concatenate things or reverse things?

22:11.280 --> 22:15.120
It has a lot of options to choose from and try in its search.

22:15.120 --> 22:18.720
When you say it is sanitized, what does that mean?

22:19.080 --> 22:21.360
It means no basis.

22:21.360 --> 22:25.920
Then it is only one option for how to get a sanitized string, which is to call the sanitized

22:25.920 --> 22:31.440
function, which exports an interface saying, get you a sanitized string.

22:31.440 --> 22:37.920
And so that is the precise meaning of easier to think about and easier to code, synthesis

22:37.920 --> 22:40.320
style.

22:40.320 --> 22:48.120
So we've explored some correspondencies between the deductive schools of synthesis and you.

22:48.120 --> 22:55.000
We've seen the themes of abstraction in the way that we hid, hid sanitized behind the

22:55.000 --> 22:58.640
abstraction barrier, do not cross.

22:58.640 --> 23:03.400
How does put constraints on the program and what is it possible to write?

23:03.400 --> 23:08.760
And of course, all this is only seen at the level of logic.

23:08.760 --> 23:11.560
Let's look at another example.

23:11.560 --> 23:17.560
How is it possible to write a straight line program, no, no indentation.

23:17.560 --> 23:20.640
That contains a conditional.

23:20.640 --> 23:21.640
Let's find out.

23:21.640 --> 23:30.840
I have a program on the server, returns 496, I swear it returns 1024.

23:30.840 --> 23:39.600
And my friend Stephen sees this code and he sees that if statement and he gets mad.

23:39.600 --> 23:43.400
Because the internet told him, do not use if statements.

23:43.400 --> 23:51.480
Off to the if statements, join the if campaign, if statements are bad.

23:51.480 --> 23:54.440
So it goes back to this code, he gets an idea.

23:54.440 --> 23:59.880
This is in C. That is on server variable is either 0 or 1.

23:59.880 --> 24:05.760
We can replace this if with an array index.

24:05.760 --> 24:09.160
The guru is not pleased.

24:09.160 --> 24:13.840
You have only moved the conditional into the array.

24:13.840 --> 24:15.720
What?

24:15.720 --> 24:25.640
So this is the if advice, a little bit less straightforward than it may have seen.

24:25.640 --> 24:27.360
Let's see what that means.

24:27.360 --> 24:29.840
A quick change of notation.

24:29.840 --> 24:37.400
I'm going to denote the array, 1024, 496 by saying start with the empty array, add 0,

24:37.520 --> 24:43.160
insert 1024, add 1, insert 496.

24:43.160 --> 24:45.960
On top of this notation, we have the array axioms.

24:45.960 --> 24:53.440
I'm not going to go into them in detail, but they tell me exactly what it means for, they

24:53.440 --> 24:57.640
tell me exactly what it means for to index the array.

24:57.640 --> 25:05.400
And it gives me this, it says, that's 1, the index is 496, else let's go deeper to the

25:05.400 --> 25:11.360
array, add 0, it's 1024, let's go deeper to the array, oh, we're out of array, we're out

25:11.360 --> 25:18.920
of axioms, so now it's undefined, but really the only thing you care about is at the bottom

25:18.920 --> 25:19.920
right.

25:19.920 --> 25:27.000
This simplifies to the formula, if x equals 0, the index is 1224, and if x is 1, then the

25:27.000 --> 25:30.760
index is 496.

25:30.760 --> 25:37.640
That formula is conditional, if x is this, then it's that, if x is this, then it's that.

25:37.640 --> 25:42.600
Now using this, we can go back to the program and come up with a logical formula to describe

25:42.600 --> 25:45.600
what the program does.

25:45.600 --> 25:52.920
And we get a conditional, if it's on server, then it's 496, I'll say it's 1024.

25:52.920 --> 25:58.600
And we can use other axioms to do the exact same for the original program, and we get

25:58.600 --> 26:02.680
the exact same formula.

26:02.680 --> 26:07.920
And so there's a sense that both of these have an additional, the same conditional.

26:07.920 --> 26:12.000
And so the synthesizer is only looking at these formulas.

26:12.000 --> 26:17.800
And so from its perspective, these two pieces of code are not just semantically equivalent,

26:17.800 --> 26:23.760
they're actually structurally identical, we haven't changed it at all.

26:23.760 --> 26:28.720
And so conditionals are a semantic notion, not an intact notion.

26:28.720 --> 26:33.560
Just because you don't write the words letters I F, does not mean there's no if statement

26:33.560 --> 26:36.080
in your code.

26:36.080 --> 26:40.840
So the thing that happened here was the array index was conditional in disguise.

26:40.840 --> 26:46.720
Does this mean we should have an anti-array campaign and no arrays, definitely array?

26:46.720 --> 26:47.960
No.

26:47.960 --> 26:54.280
Not every array access is conditional, but the difference is subtle.

26:54.280 --> 26:58.440
And it cannot be purely determined from the code, but it's a property rather of the level

26:58.440 --> 27:00.760
three, how you think about it.

27:00.760 --> 27:01.760
Let's inspect.

27:01.760 --> 27:03.760
Here's another array.

27:03.760 --> 27:06.480
It's a list of all the president names.

27:06.480 --> 27:09.480
And using that, we can define a president after function.

27:09.480 --> 27:11.640
The president after Washington was Adams.

27:11.640 --> 27:16.360
The president after Thomas Jefferson was James Madison and so on.

27:16.360 --> 27:18.640
Here's a pretty simple function that does that.

27:18.640 --> 27:23.640
It totally breaks on bad inputs, negatives, the last president.

27:23.640 --> 27:24.640
Don't tell me about those.

27:24.640 --> 27:26.920
It's a simple example.

27:26.920 --> 27:29.720
And let's talk about what it means index into the array.

27:29.720 --> 27:34.480
And like before, we get a giant conditional at zero, it's Washington, and it's one, it's

27:34.480 --> 27:36.160
Adams, and so on.

27:36.160 --> 27:40.520
This does not look promising, it looks conditional.

27:40.520 --> 27:49.440
But if you already have a notion, an external notion of the ith president, then you can

27:49.440 --> 27:52.560
relate this formula to that.

27:52.560 --> 27:57.960
And you can get the simpler formula, it's the index of the ith, to name the ith president,

27:57.960 --> 28:01.000
which is not involved in any ranching at all.

28:01.000 --> 28:05.800
And now we can use this abstracted formula to look at this code and think about it in

28:05.800 --> 28:10.480
a very short foreign manner, get this index, I can name the next president, and I'm done.

28:11.440 --> 28:15.840
That's how you would think about it, and that's also how a veripyrocynthesizer would think

28:15.840 --> 28:20.480
about it, just like I've written down here.

28:20.480 --> 28:23.480
There's no casework in here, there's no branching.

28:23.480 --> 28:24.480
Just works.

28:24.480 --> 28:33.000
And so that's a sense in which one array index is a conditional and the other is not.

28:33.000 --> 28:37.320
So the difference is that we're able to abstract one and not the other.

28:37.320 --> 28:41.680
And you could abstract the size of the array, find a better way of thinking about it, but

28:41.680 --> 28:42.680
I didn't.

28:42.680 --> 28:49.400
And because I didn't find it's a way, that was conditional, and this one is not.

28:49.400 --> 28:53.800
So we've again seen this insight from the doctoral school of synthesis to the human,

28:53.800 --> 28:58.880
and when you see the abstraction and how we abstracted the array access, this lets us

28:58.880 --> 29:03.560
put extra constraints in a program like death of the statement.

29:03.560 --> 29:10.800
But this only is understood at the level of logic.

29:10.800 --> 29:15.240
Let's go into another school of synthesis, the constraint-based, and this section is

29:15.240 --> 29:17.840
going to be a little bit different from the previous ones.

29:17.840 --> 29:22.440
I said at the beginning that a human and a deductive synthesizer are kind of similar,

29:22.440 --> 29:28.360
and so deductive synthesis can shed light on software engineering advice, whereas the

29:28.360 --> 29:32.400
numerator and constraint-based, they're not like a human synthesizer, so they're just

29:32.440 --> 29:36.840
going to eliminate the nature of the programs themselves.

29:36.840 --> 29:42.600
We're going to be talking about a tool called Sketch, built by my advisor, Armando Suarezama,

29:42.600 --> 29:48.480
and the sketch is about programming with holes, like humans are clever and insightful

29:48.480 --> 29:49.480
and slow.

29:49.480 --> 29:51.200
Synthesizers are dumb, thorough, and fast.

29:51.200 --> 29:52.200
Let's put them together.

29:52.200 --> 29:57.160
You're going to write a higher level of the program, what the program kind of looks like,

29:57.160 --> 29:59.480
the synthesizers are going to fill in the details.

29:59.480 --> 30:01.920
So here's the Hello World example.

30:01.920 --> 30:05.360
That question mark is a hole.

30:05.360 --> 30:10.120
So this thing is asking, find me an integer question mark such that x times question mark

30:10.120 --> 30:16.920
is equivalent to x times x for all inputs.

30:16.920 --> 30:20.160
And you might figure out the answer, it's 2.

30:20.160 --> 30:24.800
And this synthesizer will figure that out, too, after 0.452 seconds.

30:24.800 --> 30:29.120
You can do more complicated things like Sketch, like if you have a really inefficient link

30:29.120 --> 30:32.200
to this reversal, you can get the fast one.

30:32.200 --> 30:35.840
You do need a bit more of a complicated hole than an integer, say, like some number of

30:35.840 --> 30:39.680
statements where a statement looks like this, but it can do it.

30:39.680 --> 30:45.240
So I'm going to give you a two-minute version of the synthesis algorithm.

30:45.240 --> 30:51.160
There's two parts, constraint and solving, and the see just loop.

30:51.160 --> 30:53.520
So it looks like this.

30:53.800 --> 30:56.120
For simplicity, all integers are two bits.

30:56.120 --> 30:59.680
You'll think we have added a moment.

30:59.680 --> 31:04.920
And we can just say, let's look at the bits of the inputs and the hole and the arithmetic

31:04.920 --> 31:05.920
expressions.

31:05.920 --> 31:10.640
And all these give us constraints that the bits of the digits of the plus expression

31:10.640 --> 31:14.360
need to match the corresponding ones in the multiplication expression.

31:14.360 --> 31:17.520
So we get a list of constraints on the bits.

31:17.520 --> 31:22.240
And now we can also write down bits, level formulas for every bit of the plus in the

31:22.240 --> 31:23.240
times.

31:23.240 --> 31:29.080
And it looks like this, some big Boolean formulas, thank goodness there's only two bit numbers.

31:29.080 --> 31:33.720
And now we'll just solve for what the bits of the hole are.

31:33.720 --> 31:37.560
And if you're taking a theory of computing course, you might start getting a little scared.

31:37.560 --> 31:40.680
Because in a theory of computing course, you might have learned that this is the Boolean

31:40.680 --> 31:41.960
satisfiability problem.

31:41.960 --> 31:46.200
We need to find a sign to these bits that the thing works.

31:46.200 --> 31:47.720
That's the SAT problem.

31:47.720 --> 31:51.640
Oh, no, that's NP-hard.

31:51.640 --> 31:54.800
And that is a lie.

31:54.800 --> 31:58.960
Because it's actually NP-easy.

31:58.960 --> 32:04.800
And by that, I mean that modern SAT solvers can take in millions of variables and solve

32:04.800 --> 32:09.200
them very fast, most of the time.

32:09.200 --> 32:12.520
In this case, we're lucky enough to be in the most of the time.

32:12.520 --> 32:18.160
And so we figure out the bits of the hole and we get the final answer of two.

32:18.160 --> 32:23.000
Woo-hoo, synthesis.

32:23.000 --> 32:28.440
But really, it makes it easier to think about if you just pick a few inputs at one time

32:28.440 --> 32:31.000
instead of all inputs.

32:31.000 --> 32:35.000
So on top of this, we build something called the counter-example-guided inductive synthesis

32:35.000 --> 32:36.600
loop, sieges.

32:36.600 --> 32:40.640
And it's basically a conversation between two parts, the inductive synthesizer and

32:40.640 --> 32:41.640
the verifier.

32:41.640 --> 32:46.040
The inductive synthesizer takes some input, takes some tests, gives you a program.

32:46.040 --> 32:51.200
The verifier takes in a program and says, if it always works, if not, a failing input.

32:51.200 --> 32:52.200
So does this work?

32:52.200 --> 32:53.200
No.

32:53.200 --> 32:54.200
It fails this input.

32:54.200 --> 32:55.200
Does this work?

32:55.200 --> 32:56.200
No.

32:56.200 --> 32:57.200
It's a failing test.

32:57.200 --> 32:58.200
Does this work?

32:58.200 --> 32:59.200
Yes.

32:59.200 --> 33:03.000
In other words, sieges is test-driven development.

33:03.000 --> 33:09.320
And from this, I get the idea, maybe you can somehow use Sketch and sieges to tell us

33:09.320 --> 33:11.760
something about testing.

33:11.760 --> 33:13.760
Let's do it.

33:13.760 --> 33:18.000
What we're going to do is I want to see if my test case is good enough.

33:18.000 --> 33:21.520
If it's good enough, if the test pass, my program works.

33:21.520 --> 33:29.000
So is there a way to write a program that passes all my tests but is the wrong program?

33:29.000 --> 33:32.240
Let's use synthesis to find out.

33:32.240 --> 33:39.960
A view of testing is that you have some space of correct programs that you want to find,

33:39.960 --> 33:45.520
and every test is going to narrow down the passing programs more and more, hopefully to

33:45.520 --> 33:48.560
just the correct ones.

33:48.560 --> 33:51.080
But there's something missing from this story.

33:51.080 --> 33:56.120
Here's a very simple kind of program, curves on an xy plane.

33:56.120 --> 34:01.280
Here are my test points, and I want a curve that goes through all three points.

34:01.280 --> 34:04.680
Can you guess what curve I have in mind?

34:04.680 --> 34:05.680
That's right.

34:05.680 --> 34:06.680
It's this guy.

34:06.680 --> 34:07.680
No, no, no.

34:07.680 --> 34:08.680
Here's another test.

34:08.920 --> 34:11.920
Oh, you mean this one?

34:11.920 --> 34:17.040
But if we add a structural constraint that the curve must be a line, then those two

34:17.040 --> 34:21.000
options go away, and the only option is this line.

34:21.000 --> 34:25.360
And not only that, but I need fewer points, fewer test cases.

34:25.360 --> 34:29.040
And programs are just generalized polynomials.

34:29.040 --> 34:32.440
And programs such that this is just generalized curve fitting.

34:32.440 --> 34:35.000
So what does this look like for testing programs?

34:35.720 --> 34:39.520
Well, if you have some kind of structural constraint in the program that you can write,

34:39.520 --> 34:42.520
then maybe you don't need this third test.

34:42.520 --> 34:44.640
So let's put that in action.

34:44.640 --> 34:50.000
So I want to synthesize a function to do something very complicated, the length of a link list.

34:50.000 --> 34:53.120
Here are my three test cases on the left.

34:53.120 --> 35:02.600
And for this, I do need to have some kind of oracle that tells me what the correct answer

35:02.600 --> 35:04.040
is.

35:04.040 --> 35:09.000
Using this, I'm going to synthesize a length function, which passes all the three tests

35:09.000 --> 35:14.480
that I gave it, whether it is some input list question mark, which differs from the

35:14.480 --> 35:15.840
correct answer.

35:15.840 --> 35:19.440
So pass all the test cases, but it's wrong on somewhere.

35:19.440 --> 35:23.040
Let's synthesize.

35:23.040 --> 35:27.280
So first, I say it'll have at most three branches.

35:27.280 --> 35:31.720
Each conditional looks something like this, some reasonable list operations.

35:31.720 --> 35:37.520
Now things can happen within each branch, and let's see if it can come up with something.

35:37.520 --> 35:39.040
And it does.

35:39.040 --> 35:42.800
Sketch produces correct output, not readable output.

35:42.800 --> 35:49.040
And so in order to make sure I have the right program, I need to add another test, like

35:49.040 --> 35:50.800
list of length three.

35:50.800 --> 35:56.760
And now it says, if it passed all the tests, there's no way to make it the wrong program.

35:56.760 --> 36:03.480
But if I restrict my program a little bit, then I don't need that test anymore.

36:03.480 --> 36:08.800
And just the only three tests, I must have the correct program.

36:08.800 --> 36:14.640
So there's all this talk about more coverage, more tests, more precise.

36:14.640 --> 36:20.080
But we don't often hear about writing the simpler code, in that the more one we have,

36:20.080 --> 36:21.080
the less the other we need.

36:21.080 --> 36:25.440
Write simpler code, then you don't need as many tests.

36:25.440 --> 36:32.600
And it's a choice, but I know which end I prefer.

36:32.600 --> 36:38.360
Because there's a saying that quality cannot be tested in, quality must be built in.

36:38.360 --> 36:42.280
And this is what it means.

36:42.280 --> 36:46.920
So we've gotten some insights into writing programs, writing tests from the School of

36:46.920 --> 36:48.960
Constraint-based Synthesis.

36:48.960 --> 36:55.320
And again, we've seen abstraction in our use of this test oracle, constraints in how

36:55.320 --> 37:00.360
we restrict the program space to make it work, and the synthesis algorithm itself is based

37:00.360 --> 37:03.640
on logic.

37:03.640 --> 37:08.720
So we've seen a lot of stuff today.

37:08.720 --> 37:14.560
You've learned the high level of two different synthesis algorithms, seen a lot of stuff

37:14.560 --> 37:19.120
you probably haven't seen before, but really what we're doing is reaching that black box

37:19.120 --> 37:24.200
in your head of how we write programs, and kind of opening up a bit and seeing how it

37:24.200 --> 37:25.200
works.

37:25.200 --> 37:34.760
And in doing so, we can start to stop accepting vague answers for what we should be doing,

37:34.760 --> 37:38.600
start to accept, maybe we can think a little bit deeper about what's going on.

37:38.600 --> 37:41.360
What is it possible for me to write right now?

37:41.360 --> 37:45.480
Sometimes we're on a wild west, not anything goes, there's a structure to what it's possible

37:45.480 --> 37:50.600
to write, and we're accepting that we can find it.

37:50.600 --> 37:56.280
So my hope is that becoming here today, you're joining me all, you're all joining me on a

37:56.280 --> 38:01.960
journey to get away from the citrus advice to become used to, start to learn how to see

38:01.960 --> 38:05.160
the vitamins in our code.

38:05.160 --> 38:10.920
Because the first step, the most important step you've already done, to get to more precise

38:10.960 --> 38:16.000
hard-generated advice, the big step is simply to believe that it's possible, because you

38:16.000 --> 38:19.240
are a program synthesizer.

38:19.240 --> 38:25.520
So if you want to see more about this, check out my blog, I love this stuff.

38:25.520 --> 38:27.200
I also teach it.

38:27.200 --> 38:29.320
I have a web course starting in two weeks.

38:29.320 --> 38:34.680
We have one of my former students sitting right there.

38:34.680 --> 38:38.240
I'd like to thank all the people who made this possible, people who invented what I

38:38.320 --> 38:44.920
talked about, well as organizers, but most importantly, St. Louis is my hometown, and

38:44.920 --> 38:47.560
so we have a very special guest today.

38:47.560 --> 38:53.560
I'd like to thank my father for never telling me that I'm crazy, even when he thought it.

38:58.560 --> 39:05.560
Remember, you are a program synthesizer, and do not cross the streams and do not cross

39:05.560 --> 39:09.720
the abstraction boundary.

39:09.720 --> 39:14.720
So one minute for questions, but I'll stay as long as I have askers.

39:14.720 --> 39:19.720
So let's wait for this to load.

39:19.720 --> 39:24.720
While it's loading, I'll take a hand.

39:24.720 --> 39:27.720
It's loaded.

39:27.720 --> 39:33.720
Let's see, I do not see any questions.

39:35.560 --> 39:42.560
If there are no questions, it's great to see you all today, and I hope you had a great strange loop.

