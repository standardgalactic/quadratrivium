Okay, we want to see who is who is going to start you. Okay, we have written some questions for him.
My first question is, we don't see Chuck much online, and I'm very interested in what he's doing now and is he still working on and with Ford.
Yes, of course.
Can you hear me.
Yes.
Yes.
Okay.
Wonderful version of color force, which I use almost every day.
I'm not doing anything impressive with it, just messing around with computers.
Basically, I'm retired.
I spend a lot of time exercising, trying to stay alive.
I eat a lot of food.
Very pleasant, very pleasant life. And I certainly don't want to be under any kind of pressure to produce things.
So I'm basically not.
I have a number of applications in color force that I enjoy.
They are emphatically not portable.
Forced to me I agree with Ulrich is a personal language, and I'm doing it my way.
And I would be happy to share ideas.
But no one would be interested in my fourth code.
I think we all interested in everyone's ideas and especially yours.
I would love to see it.
Sometimes maybe I can show it to you but I'm not set up to do that now.
What's the computer are you doing it at the moment.
Sorry.
Are you doing it on the GA 144.
Not a computer, a special computer maybe.
It's on a PC.
I've got a 4k display.
And it's all tuned to 4k.
Although I have the parameterized so I could display it on 2k.
It doesn't work very well.
That means it's small screen.
55 inch.
55 inch 4k display.
It's a PCL television.
It works just fine.
You only do force on it.
So other things.
I browse the web and YouTube.
That is my fourth display.
It's very nice to meet you.
We have got an old club here.
From 1979 about.
Okay.
We are rather active still with a few members, maybe 13 members are active.
And more than a hundred members are there, but not here normally.
And they're all very happy to use force because it's very flexible.
And it's very basic. You can do very smart things with a few.
A little bit of pop.
It's always been my favorite language.
I'm impressed.
I'm very happy.
I'm impressed with how many people are interested.
I gave up long ago.
Trying to promote force.
Yes, it's a hard sell.
And I would just rather use it myself.
I can understand that it's really a hard sell.
You can write beautiful code with it.
Most people only do a segment of relations.
I believe.
And that doesn't help.
Beautiful code is right.
It's.
Back in the back in the old days.
I thought that people would write their own programs.
And it forced to be a great vehicle for doing that.
And it would appear that.
A thousand people.
Out of.
8 billion.
Are willing to write their own programs.
Yes.
Most of the people like to copy and paste only.
Question for check more.
I really wonder what your most used application does.
The application I use.
The application you mostly use.
It's a clock.
I have a, I have a screen full of numbers.
The date and time.
Julian day.
Moonrise.
I don't know what the number of days till.
Things like they like savings time.
All of the.
Time questions that I asked myself.
Have got the answers.
And it's a pretty display.
Sounds nice. Thank you.
One thing I have done.
Is a new character set.
You may be aware that I've done many, many different character sets.
This one is the prettiest.
And simplest.
And it has a unique property.
Normally what I have been doing.
Would be I would generate.
A character.
As a raster.
I would have.
What 48.
Symbols representing the.
Characters.
Stored.
In rain Ram.
It finally occurred to me that.
Computers are much faster than they need to be.
Instead of storing the.
Characters I store the code that generates the characters.
And when I want to display one, I can do it.
Computers are pretty fast to do that.
With those perceptible delay.
And it saves memory.
It adds flexibility. You can edit your characters on the fly.
And you can invest.
A fair amount of work in calculating a character because it doesn't matter.
So I've got pretty characters.
Available on demand.
I encourage people to design their own characters.
It's fun.
It's easy.
And it gives you another customizable.
And it's very, very nice.
So there's something that is called display post script on,
on Mac OS 10, for example, or I don't know whether it's called like this.
So this is something like display force.
So a force program runs when you display text.
Because it draws the characters.
Yep.
Yeah, great.
I like that.
I can draw characters sometimes when I can.
They're very pretty in 4k.
I can draw very large characters.
They're all scalable.
And some curves.
Chuck, this is Don.
You gave a talk, I think it was last fourth day where you were writing
directly to the memory buffer.
That's what this system you're describing is you're writing directly to the memory
buffer.
Yeah.
Oh, yes.
You have to have a.
Kind of speed.
If you go through the windows.
Interface.
It's much too slow.
Hi, Chuck.
This is Carlos here.
Hi.
I'm Carlos.
I'm a member of the planetary networking special interest group.
I know you have been.
For many years interested in space and space exploration.
Have you been working at some point.
About the late tolerant networking.
And interfacing with force.
What is called.
I don't understand.
DTN is a protocol.
That use environmental protocol encapsulates the TCP IP or LTP like
like the transport protocol to connect.
With the space it's using the international space station and also in
much rovers.
And.
I.
I've been looking to different languages to interface with.
DTN.
We are working with Pinto surfing this in this project about interplanetary
internet.
And I would like to know if you have been interested at some point in this
kind of communication.
I haven't been able to get on to the internet.
I'm indeed interested, but I've done nothing in that direction.
In fact, I haven't even been able to get onto the internet.
The.
Tools that windows provides are.
Opaid to me.
And I've just been forced to deal with things locally.
Thank you.
Hi, Chuck. My name is Bob Flanders. It's a pleasure to meet you, sir.
Yeah.
Somebody just brought up the original list things.
Hi, Bob. Nice. Nice to meet you. Nice to see you in the group.
Nice to meet you too, Peter. It's been a, it's been a long time coming.
There's kind of an interesting little story about what's on the screen on
2011 or thereabouts.
It's been a pleasure to talk to ask if he had any old code.
For the IBM 1130, which was the first computer he wrote for thought
of fully working forth on this. I understand it. In fact, the name of,
of four would have been F O U R T H had it not been for the 1130s
limited file system, which only allows five characters.
So it had to be named F L R K H to be a file on the 1130.
Just kind of fun and has led to the idea of it being something that we go
forth.
So anyway, in 2011, I sent a message to him asking if he had any old code
for the, to be 1130 and he said, yeah, I'll rummage around and,
and he'll take a look and see what he has. And he found this.
And he sent it to me, but I missed the message or something.
Well, a few years later, I guess it was 2017 or so.
Carl Clanch, who is a fellow IBM 1130 enthusiast,
sent me a message that he had spoken with Chuck.
And Chuck had said, I think I send it to the sky Flanders and
he'd since gotten rid of the papers and so I rummaged around
in my Gmail and I found it.
And it turns out it's either a free version one or pretty close to
version one copy of the code and the basic kernel,
the, you know, the assemble level words and then the additional words on
it, but, and I've had a tiny amount of contribution to helping Carl
get it working on the IBM 1130 emulator.
And Carl actually has a working IBM 1130.
And he's, he's gotten it working.
One critical word that we probably would all be completely lost without
had it not had that wasn't there in this version, which was period.
So he couldn't print out the top of the stack.
I think that the top of the stack may have only been shown in the
indicator on the, on the 1130 for the, for the accumulator.
And it was a very interesting, a very interesting bit of work to, to
put it together and get it running.
There were, there were some typos or some not typos, but some, some hand
written notes on the code and notice some things that needed to be
adjusted a little bit, maybe also we made typos, putting it in.
And there is, there's actually floating about out there a version one
fourth of the IBM 1130.
The way I became interested in fourth personally was I was hired by
MCI telecommunications.
Like 1986 or thereabouts.
And I had no fourth experience, but a friend recommended me.
And I came in and the guy said, well, listen, let's, let's give you a
try.
First thing I want you to do is write a word that shows a timestamp.
So I fumbled around and wrote a timestamp.
Then the next thing he said is I want you to implement drivers for a
multi port serial card.
And I wrote that and then he said, okay, you got the job.
And I ended up working for eight years.
And I ended up using LMI fourth under some DOS extender.
To implement a system that ran on.
At the end, I think it was nearly a thousand.
What we're called site controllers.
And they are put in their co located at the various MCI facilities and
talk to digital cross connects and extended.
Extender sup frame monitoring units.
And it would send all the information back to a central computer,
which would then use its interface support to do things like,
you know, a customer call up, say, Hey, I need a,
a circuit from Washington DC to Los Angeles.
And they would go into the digital cross connects hook up the,
hook up the T one, get it all running.
And then, you know, go out and get it delivered to the customer.
And they would have to get it delivered at the end points to whatever
provisions were necessary.
And it was very cool and interesting system.
I haven't done much with fourth sense.
But I'm always like, I'm always looking backwards.
Oh, I want to do this.
I want to work on, like, I'm writing 1130.
Emulator.
And things like that. So it's always an interest me to,
to do things with older code.
But I program and C-Shark and do a lot of sequel stuff on it.
Anyway, pleasure to meet, sir. Thank you so much.
Fourth is brilliant. It was brilliant. It is brilliant and shall continue to be better.
I can add a little bit to the 1130 story.
It isn't as if I was sitting in an office working with the 1130.
The 1130 was on the abandoned production floor of a textile mill.
It was a huge room about 200 feet long and 100 feet wide.
And the exact center of it was this 1130, which had been delivered by IBM.
And nobody knew what to do with it.
Except me.
And so that was the environment in which fourth was invented.
It was challenging in many ways.
Yeah, it was the 1130.
If there hadn't been 1130 in my high school, this was about 1972.
And I started using one.
And at that time, I had no understanding of what I was doing.
Then meant for the 1130, I probably would never have gotten into computing.
But that started my career.
First mini computer.
Yeah, I call it my first personal computer.
Hi Chuck.
Hey.
We've met a couple of times and many of us here will remember the
1980 edition of Bites where you introduced the language to a much wider audience.
But that was the time that you felt that the software had been done and you are now looking towards the hardware.
Could you, could you tell us a bit about how you made that transition from software to hardware
and you, you moved towards the, the Novix period of fourth history.
Yes, I did feel the software had been perfected in the, in context of fourth.
What I was doing at the time was putting off, putting forth on many different computers and interfacing it with many different devices.
And this of course is very easy to do.
That's why fourth exists.
Now, the interfacing with many different devices got very frustrating because these devices were badly designed.
The interface I had to go through was the czar baroque.
And I got kind of tired of doing that.
And I said, well, I could design a better interface.
I can design a better computer.
Now, people didn't do that at the time.
This was the business of someone else.
So it took really a leap of a leap of faith to abandon software for hardware.
I actually didn't because I had to develop the software to design the hardware.
Thereafter, my software efforts went in the hardware direction and simulators and layout tools.
And it was very rewarding.
My, my hardware worked.
And it worked much better than anyone expected or even would admit.
I'm still doing that in the sense of the greener rays, multi-processor chips.
They are incredibly simple, incredibly effective, and totally unpopular.
So forth hardware is just as unacceptable as for software.
Yep. And that's, that's absolutely fine.
Some people like forth, like everybody here would imagine other people don't understand.
We've met a couple of times too.
I'd just like to say, thank you.
You've made my career in programming much more fun than it would ever have been otherwise.
May the flowers and flowers bloom.
Thank you.
G'day Chuck.
I've met you once back in 1988 back in the year when I had Australian symposium here.
And, but, and I've been using forth since the early 80s, you know, I started the big project with that.
And I've been using it ever since.
And yes, you know, a lot of people won't admit that it works so well.
You know, that's true.
It was a hardware and software.
And it also makes the hardware a lot simpler.
We don't have to use any complicated hardware.
And, you know, that was my original fourth board I did up, you know, with a Rockwell chips, et cetera.
And then, you know, I ended to a module, you know, a little credit card size module, but this is mid 80s.
And, and that was okay for the mid 80s.
And now I use the PT multi core processor with 64 smart pins, et cetera.
And, and so, and I, so you do a lot of better control.
This is, this is a question I really wanted to, wanted to ask you, you just mentioned the greener rates.
It's got all these processes on there.
I've got the, the propeller parallax propeller processor.
We've got eight cogs or light cores.
It has hub ram, so it shares everything and every, every one of those cores can access all the IO equally.
But when I look at the greener rays, I can't figure out how I can use it.
When you're saying it's an effective processor, what has it proved to be effective in, you know, really?
How can I use it for general embedded control and smart stuff?
That's a good question.
It has 144 computers.
Exactly cores. They're independent computers.
They communicate with one another.
And the ones around the edge communicate with pins.
So if you want to control a pin, you have to use the computer, which is attached to it.
The computer pretty much can't do anything except run that pin and communicate with its neighbors.
So you end up building a little network of computers, not 144, but maybe half a dozen that all cooperate and communicate in running the protocol on that pin.
It's a fun thing to do.
It's totally different than any other computer where you would just run a serial processor.
Your, your whole attention is in coordinating the efforts of as many independent computers as you want.
I don't think I've done an application with more than about a few dozen computers.
So Chuck, so in talking about applications, what, what do you, what, if you had to showcase an application, say, look, you know, look how well it does this.
And, and I'm, I'm bearing in mind too that what you said already, there's a bit of work setting it all up for those cores to communicate with one another or, you know, those little secret years to communicate with one another.
I'm familiar with the whole architecture.
But what would you say, which, you know, you could hold off an application and say, man, you know, this doesn't so well.
Well, one of his applications through and forth to, you can use some of the, some of the computers to drive a display.
You can use some of the computers to read a keyboard.
And you can put them together to run forth.
I haven't done that. I've never got around to doing that, although I got close.
We've got
each computer has 64 words of realm.
And one of the computers interfaces with a flash memory.
So there's infinite, infinite amounts of data available.
Another set of three computers can commute with communicate with DRAM.
So what you want to do is set up a system whereby
you store it in flash, you store it in DRAM, and you read it back from DRAM and do whatever you want to do.
So, so with, with, you know, so, you know, I'm wondering why you haven't done a PC with it yet. Come on, you know, you can do it.
But the thing is, okay, so I use chips, you know, so that one's got 512k of RAM.
And plus all the 4k around on each CPU, etc.
And so it's really easy to make it work.
And if, and I talk to an IO and I can even instruct the IO to do something by itself.
It's a smart IO. It has everything built into it.
I, you know, I keep racking my brains looking at the green arrays.
And I can't think, you know, like, even if I could get it to do something, it'll be a lot of work.
You know, it'll be fun, but it'll be a lot of work to do it.
And you mentioned memory displays, for instance, well, there were a lot of more effective ways of doing displays, but I can do a VGA or even a HD display from the RAM on this one.
But I have to add a bolt on all that RAM onto the green arrays.
You know, I'd really love to see a green arrays one that was had less CPUs, had a bit more memory on each one and more access to the IO.
And it was like, that would be really great, you know, 64 CPUs, we get about 144.
Give me 64 and, you know, as you said, you don't need to use many.
We'd love to do that. We've had plans for doing that, but we've never been able to make such a chip.
Right.
We'd have to integrate someone else's memory onto our chip, but that isn't easy to do.
Yeah, well, you know, I appreciate it. I just wanted to ask you that question because it's like, it's the one thing that bugs me.
It's like these fourth chips right going right from the early days, Novix and all that, and they're all really great.
And, and then, you know, like, I've got 21, I've got the, the, the Shubhams and everything like that, but I can't figure out how to use the green arrays.
So I really love to see some application.
I'll even forget about application notes, but just by showcase something to showcase that particular chip power was used really well.
Well, the biggest advantage of the 144 is it doesn't use any energy.
Somebody put a lot of energy in to make it work though. That's the trouble.
Yeah.
Yeah. Well, thanks, Chuck. Yeah. No, appreciate it. Well, very much all your work.
We, you know, when we, we, we love for the other question, can I, I just wanted to ask you nothing to do with technical things, but we often talk about how, how is it that we can really promote forth?
You know, it's just that mindset, you know, you've, you've had way more experience with encountering the opposition and with, with, with people accepting forth.
And it's like, well, this before I had forth built into the chip and silicon on this particular P2 chip.
And that was a hard task to get that done at the time.
But forth is a dirty word, you know, people just don't like companies don't like mentioning it.
Do you see anything that would help break down that barrier?
A killer app.
We've been looking for a killer app for 50 years and haven't found one.
Well, after PC's, you know, I think, I think most of the fourth use, you know, I've always used forth on micros embedded.
And so it's built into airports and roadways and all kinds of vending machines, anything, you know.
And so they're all out there.
People just don't see it, but it keeps going 24 seven.
And it's also my prototype language that I use.
You probably want to prototype this, you know, people are used to using breadboards or forth.
You can move stuff around like that.
You can fritz all you like with forth.
And it's very quick.
So, you know, I have a project now where they are saying, hey, you know, do it with Arduino, you know, see and everything else like this.
And I'm thinking they can ask me, but I'm still doing it my way because, you know, I can get it done.
But yeah, but it's just that opposition to it.
And I don't know if there's anything we often talk about it on our group and forth 2020, how we can get young people interested.
It's not going to be a killer app.
I think it's going to be the easy use.
How they're using it make it's how to how to make use force, you know, can use forth easily straight away.
They say.
I have a question for Chuck.
And Chuck, was the sun force in bios or open force open.
How was the name open OS.
Open boot.
Yes, exactly open boot.
Was this not the fourth killer app because this was installed in so many computers, and also on the one laptop per child I know this was a really big, a really big installation of force.
Yes, that's true, but bios is such a obscure application that didn't attract any, any, any, any attention.
It was a technical triumph.
The attention that open boot attracted was attempts to replace it with conventional software.
That didn't work. Fourth didn't work to because there was not an industry behind it.
That's always been a problem.
We lack large scale support.
Yeah, Intel came along and killed open firmware open, not open boot open firmware.
And yeah, Intel was responsible for UEFI.
And that killed open firmware.
But fourth really doesn't need corporate support to prosper.
It's an individual thing rather than a collective.
As you did check with your been raised talk on, you did a discussion of that video, how you got the 144 trips to drive the video.
I was very impressed that you don't have generic video hardware driving the video in your demonstration.
You just chips, each programming, the timing.
And that was significant of how you got the greener a chip to do video that wouldn't be normally required.
Just to produce an output for people to see in applications, which don't really need consoles.
When you manipulate in data, you work the data and you produce the storage of the of the output for the for later display for people to see.
And so the video display was just just a really fantastic ability that the trip array could actually program and the speed.
Absolutely significant was the power savings that your trip said that nobody else could do.
And it was a lot of fun program that DGA.
And it was, it wasn't easy timing was a big problem.
And it was just fun.
I would say so too.
It's quite unique that you've got this hardware, and you're interfacing the greener rays into that hardware. So there's another incredible example of what the greener rays trip set can do.
Anything. It's got it's got the speed.
And this is with a obsolete geometry, 180 nanometers. This is this is abandoned.
Competitive with with the 10 nanometer geometries.
Quite the greener rays chip set to be a risk processor where everybody's going to system processes with multi with multi instructions.
What you can do on a risk processor like the greener rays.
It's so much quicker.
It may need a little bit of effort to do the stuff that needs to be done.
But clearly, the number of instructions to do the work supersedes the performance that any of the standard processes can work with.
And at the cost of power, which was so much cheaper on.
I've got to jump in here a little bit about programming these machines Chuck's machines.
I was one of the first Novix programmers, and one of the early greener rays series of processors.
Jeff Fox and I, at the beginning, we're doing our darndest to pack as much code as we could into those 64 words of Ram.
Over years, now we found that the smaller amount of code the smallest amount that you can put into a node.
You can use the least power, because each node is cooperating sending messages between them.
And when it isn't running, it isn't. It's only got leakage power going.
Look at for the earlier speaker about getting into a greener rays programming mind mode.
Look at the examples that are on the greener rays website.
You'll get a lot of that.
One of the things that I did sort of as a skunk works program with a good friend of mine, Bill Minch, who was also an early programmer for the.
I think it was the 24 processor chip was to implement a virtual machine to execute a fourth.
We put bills, Bill was the originator of E fourth and Ting is taking it taken off with it in assembly language, we did it all in high level.
And we built a virtual machine using, I think it was three or four of the nodes to execute E fourth op codes eight bit op codes directly.
That has facilitated actually.
It's been moved and Greg Bailey's version of poly forth for thanks code is now running virtually on the novice on the greener rays chip.
And all the development that's happening currently is being done in standard fourth.
You do not need to know the details, just like every other processor.
So, take a look at those application write ups on the greener rays website.
For example, if I may 10 words of code forms and ethernet Manchester decoder and receiver converting the weekly signals on the twisted pairs into bits going to the next node.
Wow.
I listened to all this and I think, wow, this is their stuff you guys are doing are incredible little chunks right. And then there's a question.
I could something like forth and take how do we take forth to the next level, how do we get it to, you know, push it into the future.
I'll tell you something, you know, I watch this one guy on YouTube his name is Jeff yearly, and he's trying to deal with taking a video card and getting it to run in a PCI E single lane.
Some of the new Raspberry Pi compute boards.
If, if you could do something like build a fourth driven video card with an open interface that could be, you know, could be added to the drivers and such could be added to that would have some kind of a standard interface.
And that's like, you know, we'll work with open GL or, I don't know what the current, the modern of the current video standards are.
If you could build something like that, that would then sit in like a PCI E one, one lane PCI East one is sell a billion of these because they repeat the very, the CM for Raspberry Pi CM forced things are taking are becoming incredibly popular
small on like, you know, systems with all with a bunch of slots and stuff like that for multiple safety news, and then having a, you know, a PCI E card or something like that sitting in there to show have a video.
It seems like busy building.
The track is busy building a thing called HD fourth from his last this from his last discussion.
And that seems so significant what he's working with on an HDMI interface. I'll be interesting to see further development that he's working on on his HD fourth.
HD fourth has evolved into what I call you HD fourth, you even better for the 4k display.
Wow.
It's running on a PC.
The x86
It's unique characteristic is that
a lot of the code is an assembler. Well, is in machine language.
And there's no assembler.
There are hex op codes for the x86 instructions.
I had to memorize those up codes.
But it was as easy to memorize the up codes as it was to memorize the assembly code.
And it gives you beautiful versatility and efficiency.
Completely unportable.
That's what I use. I call it color fourth, but that's that's versions I'm using now.
And it is
the nicest fourth I've ever had, because it gives me the closest interface with the hardware.
On the other hand, in the old days.
You wanted to interface to a chip.
Or a board.
That chip or board was documented.
And you could really download the spec sheet and
and work with it.
Nowadays there's no documentation.
The best I have found is in windows.
But windows is incredibly complex.
It's incredibly obscure.
Badly designed.
Almost impossible to work with. And I work with it when I must.
But it has turned me off trying to interface with the larger world.
As I said before, I've never been able to figure out how to get on the internet.
And I'm afraid it's changed in such a way as to disadvantage us.
The
calls hackers.
You're supposed to sign on
to the corporate vision of computers.
And if you don't or can't do that.
You're being left behind.
Perhaps some of you know.
Werner Vinge's
science fiction novels.
He has one cold.
Oh, fire in the sky, something like that.
In which
the problem of
buggy
software was mentioned.
The spaceships of that era were programmed in some obscure language.
But nobody could really master.
And it was determined that you should improve rewrite the software.
So that that was simple, clean, bug free.
And entire planets.
Attempted to do so.
They could not reproduce all of the obscure bugs in the existing software.
So it was not useful on existing spaceships.
And the whole project led to
enormous costs, effort and failure.
That would equate in today's view with trying to reprogram windows, say,
or Linux.
In fourth.
It probably can't be done.
It certainly is not.
Sound like much fun.
Because you have to reproduce the bugs.
He wants to reduce banks.
He wants to get the bags out.
What you really need is just an IP stack.
Internet or Wi-Fi interface.
And once you have those, you're pretty much good to go.
Sorry.
The hard part is the Wi-Fi interface into proprietary firmware though.
That's why I went to the 144.
Rather than try to interface with the existing world.
I wanted to try something different.
Something standalone.
144.
Could drive a GPU.
I don't know how to do that.
I don't even know how to find out how to do that.
If it could be done.
If it can be done, of course.
But whether you can figure out how is a completely different question.
And I've given up on that.
Chuck, here's a challenge.
If you were to develop the 144 to do bitcoining.
Everybody will stop using the GPU.
Processes.
The sales of the 144 would go.
Through the roof.
You'd be making money over money because the, the people ask,
they wouldn't realize just how fast these.
The 144s could process the hash tables.
Quite right.
But.
Among other things that takes money.
To develop such an application.
I don't have any money.
I have a, I have an open question for you, Chuck.
If I may, first of all, let me say that I'm feel very honored to,
to speak to you today.
I mean, fourth for me was a fantastic concept since the 80s when I
was a student.
So definitely it's a wonderful experience to speak to you.
Now for the question is related to IOT.
Since fourth is by design, very,
very efficient in terms of power consumption in terms of
processing efficiency.
I'm surprised that are you fourth is not more commonly used for
all developments based on IOTs where of course energy consumption
and responsiveness and real time aspects absolutely critical.
What do you think about this?
I think that's an absolutely wonderful application area.
And.
Greener raises.
Projects which are trying to address that.
The fact we use very little energy.
It's a no brainer.
But.
We haven't found the killer app.
Well, next week I have to go and explain to a professor.
At University of Wyoming.
Why the fact that we don't run standard high level languages.
In a pair of streaming glasses.
Is not a killer of our technology.
The point is.
The reason why people don't use our chips is that we don't have
these giant fat libraries of crappy code,
which they can glue together,
which is all they know how to do.
They don't know how to write code.
They don't know how to program.
And the story.
No, that's the first.
I've got a question for Chuck.
I may.
Yeah, please go ahead, Ken.
It's a historical question, Chuck.
When you made the transition from.
Software to hardware.
In the very early 1980s.
Did you.
Prototype any of the early fourth hardware.
Using, I guess, TTL at that time.
Before you, before you move to the, the, the gate array of the,
of the Novics.
Did you prototype any of that stuff?
Thanks.
Yes, I, I did.
I did build a prototype.
Of a fourth computer.
And then I moved to simulating the data array.
As a more.
Helpful.
Designed.
As a more.
As a more.
Helpful.
As a more.
Helpful.
Design tool.
In fourth.
So the fourth.
Fourth hardware prototype.
Didn't really.
Wasn't really helpful. Didn't go anywhere.
It only helped to convince some other people to support the.
Data array.
Okay, thanks. That's, that's quite fascinating.
So I guess you were on the transition between.
Building prototypes and hardware.
To simulating them.
By 1981, 82, I guess we had.
16 bit PCs and.
Simulation became a reality. Yeah.
I see Jared.
Yeah. Hello, everybody.
You're muted. Now you are muted.
I just had a couple of words and then your mic went off.
No, no, no, no, no sound.
We can't hear you.
It just broke.
Yeah.
Now comes the mic.
Can you hear me? Yeah, yeah.
That's good.
No, no, no, no, no, no, no, no, no, no.
That's strange. It was just a, again, just a word.
Maybe we'll log off and log back in.
Of the zoom.
Like drop.
If you're having problems with the audio, sometimes that fixes it.
You might get a message or reinstall.
Yeah.
Like it happened to me reinstall windows.
Dropout.
I want to.
I put on the chat.
Something that Chuck will.
Love to see.
I will put this on the chat.
Probably you have seen some of you.
I am watching, I started watching yesterday on Netflix.
The billion dollar code battle of over Google Earth and a German
company called television.
It's absolute amazing.
The fantastic film.
And this has to do.
With this killer up.
We were speaking before.
This is very, this is very interesting to watch.
Thank you.
Okay.
I've got a question for Chuck.
Um, yeah, I just, I'm just curious about the changes in fourth from
the sort of the classic fourth.
From the early 80s through to California and some of your
observations and reasons for.
The kinds of design.
The way forth has gone from.
From the classic fourth to the fourth you're using now.
What was some of the reasons that drove some of those design
decisions in the more recent versions that you're using now.
Wow.
Fourth was originally an interpreter.
And I had to learn how to make it into a compiler.
And that was largely a question of confidence.
The.
The first thing that I used was a bell go.
Developed at Stanford.
And I was a graduate student at Stanford.
And there's this team of half a dozen people.
Who wrote a bell go compiler.
And I said, well, if they can do it, I can do it.
And so I wrote a standalone fourth.
That was the first one.
The criteria was to make it simple because I couldn't do
anything complicated.
And I think all of my later developments of fourth implementations.
Were to try to make it simpler.
Originally fourth had a threaded dictionary.
And that hung on for a long time.
Perhaps until you HD fourth.
Now I don't have a threaded dictionary.
I have dictionary broken into pieces.
Each piece.
There's the.
Each array.
One array contains the words.
Another array contains parameters.
Another array contains the code address.
This, this lets me search.
The name array.
With this hardware instruction.
On.
But really nothing has changed.
I'm amazed that the original.
Concept structure of fourth.
With this dictionary and stack.
It has remained for 50 years without significant alteration.
At the moment, I don't know how to make it any simpler.
And of course, the hardware has changed.
It was originally memory constrained and now it's not.
Infinite amounts of memory.
Fourth doesn't know how to use infinite amounts of memory.
It's just not necessary.
So.
I don't know where to go from here.
I have a question which is not about technology only.
I mean, and as Christian said, I mean, you are free mind, right?
What, what is the topic?
I mean, considering the news, considering the way the world is going at the
moment, what is the topic that makes you passionate about at the moment.
What is the topic that makes you passionate about technology?
What is the topic that makes you passionate about technology?
The fourth could be AI or could be something not about technology.
AI goes back to my early days at the.
What they call them.
The early neural nets.
I am of two minds.
You can see this played out in the full drug, full self driving cars.
Do you use artificial intelligence or do you use pre-programmed decision
making?
I'm.
A pre-programmed decision maker.
So I.
That that's the way I do things.
If AI becomes.
Magic.
As it has in the case of go and chess.
I'll be disturbed because.
We can't understand how it does it.
If we get AI in the form of a mobile robot or a.
Mainframe in the cloud.
I don't know how it works.
I don't know that we've accomplished anything.
You've got the oracles of ancient Greece.
Who could answer your questions?
How is that different if an AI is answering your questions?
But I don't know what side to come down on.
I think I will stick with my deterministic clock.
And perhaps try to get precision time protocol and something like that.
Yeah.
Chuck.
This is Don.
You know, we're working on this FPGA base fourth.
And I'm very curious about your comments on the dictionary because we haven't
implemented the.
The outer interpreter in the dictionary quite yet, you know, the compiler part.
You said that you have three arrays.
You, you have the CFA's.
You have the strings, the word, the word strings, the name of the words.
And then you have the data.
What is, what's the data?
The data is usually on the stack, right? So.
In the case of a constant, it would be the value of the constant.
Oh, okay. So, so, so that's, yeah, it's in a constant array.
Well, it's an array. You can put anything in it you want the address of a variable,
the value of a constant.
I think those are the only two I actually use.
You have to have a data field.
In the case of a code reference, the data field merely indicates that it is a
code reference.
But this was like the most efficient implementation of all these things that I've
ever had.
I have a second question, you know, I'm in the space business now I'm working on
space robotics.
It's a very rich history in space.
Your RTX, especially.
I know that talking with Dr. King in 2010, the Goddard space laboratory had him do
some work implementing forth for one of their missions.
Can you talk a little bit about the history of forth in space.
I programmed reconnaissance satellite once.
But I had very little to do with it, because the NC 4000 was the prototype of
the RTX.
And yet I had no contact with it at all. Nobody ever asked me a question.
Nobody ever paid me money to do anything.
The whole space application went on without my participation.
So most of the space stuff was done by four think.
And Elizabeth Rathers people.
Well,
they were kind of the focus John John Hayes and Hopkins University.
John Hopkins University crew.
They were good people.
They.
What was the name.
Proves that forth was the provable language.
Which was an issue at the time.
I don't know why that is interesting because it's pretty obvious it's correct.
What's very interesting right now that I found being in the space business is
FPGAs are naturally radiation immune so they're very much favored in space because
it's much larger than the modern microprocessors, right.
So a radiation hit is not going to impact an FPG.
And I think this is a huge opportunity for forth.
If you can imagine 100 robots working out in Pluto assembling something.
And you have this low speed data link.
And you're going to send a C binary blob up there every time you want to change code.
You know, fourth is interactive. You just make your, your core words deferred words, and you, you update as necessary using text.
I think it's the same thing applies to only over the year updates that Tesla uses.
I don't know how they do it.
But I doubt they use a fourth model.
Okay, we have a queue of people that raise their hands to ask questions. So Dimitri is next as far as I know.
Put my hand up after, after Don.
My question for Chuck is, okay, I've got, I've got a few finite list.
What would you say are the most important things about fourth, that someone learning the language needs to know I'm interested in those who are learning it today.
I myself, I'm quite young, I've learned fourth in the past couple years.
I'm wondering what you, what your thoughts on this.
The first thing you have to learn is how to handle the stack of conventional programmers.
Don't think in stack terms.
The transition that takes, oh, maybe a couple years before you really know what to put on the stack, what not to put on the stack, and how to keep the stack clean.
The, the, the processor used in greener rays chips as a circular stack.
So you can put things on it, leave it there, and it will be forgotten in an optimal way. You don't ever have to keep the stack clean.
And that's what I do in UHD fourth also have a circular stack, a little more expensive.
But it's a hard lot, a lot easier.
Beyond that, you've got to learn to factor.
The problem, break it into pieces, give names to each line of code, so that you can combine them into a higher level structure.
That's,
that's not unique to fourth.
That's a term that's a kind of good programmer practice that no one uses.
You can create a conventional to use very large subroutines, lots of parameters.
And fourth has very small subroutines with almost no parameters.
You have to make that mental transition.
So what things do you recommend, leaving on the stack at a time like how many things in the stack should the word consume is there any rough guide on that.
One or two, one or two. Yeah, the, the,
the GA 144 has eight deep stacks.
It doesn't have 16 deep stacks, whatever, but my UHD fourth has eight deep stacks. That's all you need.
On the FPGA process I'm working on with Don, yeah, we've implemented a circular stacks and I think, I think it's 32 at the moment, but I thought 16 might be a reasonable depth for, for fourth programming so that's reassuring to know.
Let's, others have their hand up I asked my next question which is, what was it like working with fourth compared to a Fortran or our goal.
What was it about Fortran or our goal that made you think my I needs to develop the language fourth.
Interactivity.
As others have said, in Fortran, you have to recompile the entire application.
I worked in Fortran. In fact, an early version of fourth was coded in Fortran.
And it was a pain to have to recompile the whole thing it took half an hour maybe.
And I wanted something that was easier to to patch.
Now, there are two flavors of fourth that I've seen.
One is where you have a large body, a large dictionary with many things in it, and different vocabularies.
The other is which you know, no vocabularies, and you recompile apps on top of each other.
That's the way my UHD fourth works. One of the most, one of the most common apps I use is the editor.
It overlays whatever other app might be active, because clearly it isn't interesting any longer.
And it compiles a new version of a block, and then I can recompile the recompile that block to make the new app.
So I'm going to compile times are zero edit times are trivial.
And the application is tiny.
So I have a lot of tiny apps, instead of one huge one.
Wow, so that really, that really is fascinating and I've tried out using blocks I think is implemented in the ESP 32 fourth and I found it very very handy.
And my final question which follows on from the previous one is, do you think that fourth still has these advantages that you method that you mentioned.
Do you think it still has these advantages over languages today like see Java and Python.
Absolutely. I haven't seen any progress in the conventional language world.
It's been portrait. All these languages are in fixed notation.
They are not interactive.
They are huge.
Nothing has changed in the last 50 years.
What would you say is wrong with in fixed notation.
It's
it's a perversion of notation and concept and implementation in high school.
People have taught in fixed notation as algebra.
And it is a pain, because it is unnatural.
HP calculators are much more efficient.
In keystrokes than an infix calculator.
It's just a path that society has taken that I think is suboptimal.
I would agree with you and that concludes my questions by the way. Yeah, I would agree because I had a bug recently at work, which was caused by an infix operator that I got the precedence for it wrong.
So it was evaluating it completely incorrectly and I was thinking, if I was using forth, this would not happen.
And it's amazing how, how often people run into these things to see problems on Facebook sometimes where someone says, solve this math equation.
And it's because it's confusing these rules are confusing. They're good for mathematics, but they're not actually as intuitive as people think they are the only intuitive because we're taught them.
But yeah, that's it for me. Thank you for answering my questions, Chuck, and I will continue learning.
Yeah, thanks. So next with the right hand is James Norris.
Please go ahead.
We can't hear you, James.
Can you hear me? Yeah, no.
I was wondering about the x86 hand coding that you're doing. Would you consider using a similar or why don't you do it.
A similar is just another layer of software that gets in your way.
What I have is the hex op codes with subscripts.
I will put a number on the stack.
And the subscript indicates how many bytes that will take in the object code.
And stringing these numbers together gives you a program.
Now this is totally inappropriate for large programs. This is insane.
But for a one line fourth definition, it's trivial.
Would you be interested? I wrote a fourth base x86 assembler if you ever want to do anything bigger.
My second question is, what about using fourth as a, right now they're coming out with Russ trying to do this. They figured out that a lot of program languages have problems like C++ has memory management problems and things like that.
And it causes all these expensive bugs for like Microsoft and stuff and they spend millions of dollars trying to fix bugs in their operating system caused by the programming language.
So if you are trying to come up with rust as a magic solution, what about for fun, you could take for this really simple. You could put in all that error checking that doesn't have. What do you think about that.
Yes, we certainly could.
Fourth doesn't have to be a standalone language. It can be a module in an operating system.
It just doesn't seem to strike people's fancy.
That was all my questions.
Okay, thank you. So Gerald's next try.
Okay, next try. Can you hear me now. Yeah.
I'm very sorry about the blur before.
So Chuck, I wanted to ask just because you also mentioned before that not a lot has changed in force.
Regarding to the basic structure of having a directory and having a stack.
I actually recall having a discussion with you where you mentioned investigating multiple stacks and using locals even did you have. Did you do any further research, or is this just been a short excursion for you.
No, that doesn't lead anywhere useful.
I've done in new HD forth.
I've taken advantage of all the registers that the x86 has.
And you could almost say that you could make a force register based instead of stack based.
And I explored that a bit.
And abandoned it.
And why is that the stack is absolutely essential.
You might not use it all the time. You might take advantage of the registers.
If you don't have a stack on which you can pass parameters.
You're crippled.
And why do you give up on having even more stacks.
There's just floating point arithmetic so there's no, no reason to have a floating point stack.
And I have never found a use for any other kind of stack.
Okay, thank you.
Right, thanks. So our next question come from Greg.
Hello, hello Chuck. It's a pleasure to meet you.
Actually, I was curious about something that was said earlier you mentioned as a, as a general rule.
Just limit the number of things on the staff to maybe just to.
And so just as a, as a possible example, if I were to develop a word that is to draw a rectangle, and it, it takes two points, you know, top left bottom right, let's say, as parameters that would, that would be for arguments on the stack so I might think,
maybe I should start thinking about structures so maybe I'll create a structure that's a point object.
And so I could put two points on the stack and, you know, that's only a couple of things placed on the stack but now I have a structure.
That structure would be, I think in fourth would be typically global, which some people might look a scans that and say it's a global variable.
But I would also think of it in terms of, well, maybe I could create an object called a rectangle and the rectangle might have methods to set its points and to display itself or whatever I decide make make sense.
And I think fits well with the noun verb.
You know, structure that forth, I think encourages, you know, objects, you know, action type of thing, you know, machine on machine off sort of thing.
I'm curious as to what your thoughts, you know, would be on how you might structure and your thoughts, some problem like that and, and, you know, what are your thoughts on structures and objects and that level of abstraction,
you know, in addition to just the basics of what gives you
that that's one way of doing things.
Is I have a word at that sets the cursor takes two parameters and specifies the location on the screen.
And then I have another word called rectangle.
Has the dimensions of the rectangle that I'm going to draw at the cursor.
So I've broken it into two pieces instead of having one large piece.
I'm going to use the word at for triangles as well, or for circles.
Now in the case of a triangle.
It's a problem because you've got three points.
And I use a structure for that.
There's one parameter, the radius.
So it's on stack.
So to generalize and say everything should be structures is not right.
And everything should be in a stack is not right either you have to be flexible.
What are your thoughts on objects.
Having, you know,
I created.
I created an object and forth.
Called the month.
And this object had starting point in the year and the number of days or something like that.
This was back back very early.
That's the only object I've ever.
And it was useless.
I have much better ways of doing months now.
So I think object learning programming is the mistake.
There are not enough instances of the object to make worth the generalization.
Interesting.
Thank you for your thoughts on that appreciate.
That's why they call it oops.
Okay, Francis, please ask your questions.
Hi Chuck.
Can you hear me.
Yes.
Okay.
Hi Chuck, it's an honor to speak with you.
I've been following for a while, and I just wanted to thank you for this gift to us. I was wondering if you could speak a little bit about the motivations for the circuit simulation software you wrote its performance and its current status.
Say again.
I was wondering if you could speak a little bit about your motivations for the circuit simulation software used to do the lay on the simulations, its performance and its current status.
Yeah.
That is my.
That's one of my favorite applications. It's one of the things that I've spent most time on.
And I think I've done the best job on.
Um,
there's there's two aspects to it.
One is the circuit logic die logic description.
And the other is a layout.
If you are laying out a circuit board, or whether you're laying out a chip.
Basically the same problem with different geometries.
And what I have learned to do is in both cases.
I do the layout.
And from the layout, I derive the circuit.
An array of transistors and interconnects.
It's extremely efficient, extremely intuitive.
Pretty simple to implement.
And gives wonderfully complete results.
I've done a lot of circuit boards.
But I've done even more chips.
And the chip layout.
Well, conventionally one has a logic description of gates that are connected and then you that you derive the, the layout.
And then you do it the other way. The layout is predominant.
And the function of layout is determined from it.
Yeah.
This is this is a strange side effect.
There is no need to do a validation, proving that the layout accurately reflects the circuit.
This is the circuit and is by definition, correct.
Amazing.
And it's a lot of fun. I enjoy working with rectangles and layouts.
Yeah.
Unfortunately, again, just like the world doesn't let you interface with chips or boards or GPUs.
The world doesn't let you interface with chips any longer.
You give it a
GDS approved layout,
which they will validate
before they construct a layout, which vaguely resembles the one that you work from
to frustrating technological development.
I would love to have a chip making machine.
Something that will generate a prototype chip in a desktop environment.
But the world is going to the world prefers to have billion dollar fabs.
Yep.
Yep.
I asked that because I was in my daily job.
I do this as a maker and a hobbyist of the cyber.
In my daily job, I do chip design and process development for some of the one of the big semiconductor companies.
And this is a cool interest of mine.
I thought I would ask about that.
This is another question.
What are the most interesting one or two applications you've seen in forth from others that you didn't see coming.
The applications and forth think does.
And you can go to their website for a list.
But they've done the
communication networks,
device handlers.
I did a Hollywood robot once.
Robot camera.
Cement making plants.
I'd love to see that full self driving car.
And forth.
That's a, that's a heavy thing though. As soon as you get into applications that
risk human lives.
It's a whole new game. And I've never done one of those.
And just a, just a, just a last question.
In hindsight, has anything sort of done differently with regards to forth and setting it up developing it all that.
Looking back after all these, these news.
No, in, in hindsight, I don't know that I've done particularly well.
But I don't know that there's anything I would have or could have done differently.
In back in what 1970 or so.
Fourth, in a sense was competing with Microsoft.
Not exactly, but conceptually.
And if, if we at four think had developed an operating system.
We could have competed with Microsoft.
But we didn't.
We couldn't.
And I'm perhaps glad we didn't.
I'm much happier with where we are now than where with Microsoft is now.
Microsoft has to be compatible.
With the exception maybe of Windows 11.
With everything they have ever done before.
Yeah.
And that is a horrible burden to bear.
As it stands.
Fourth is free to reinvent the wheel.
And I think that is a marvelous concept. No one should ever be afraid to reinvent the wheel.
And we do it every day.
Thank you, thank you.
Yeah, thanks. And Howard, your turn.
And please open the mic.
Hi, Chuck, I've already had a turn at chatting to you, but one more question about ones compliment.
The whole, it used to be very popular a long time ago.
The IP internet protocol uses a ones compliment checksum.
And it has some interesting properties.
I have a feeling that it's a really good way to go.
And I observed that you use one's compliment in the color fourth.
And I just wanted to hear your opinion. Do you think that the world went wrong when it moved over to.
Toes compliment.
No, I, I, I worried about this.
One of the main frames I programmed early on was one's compliment arithmetic.
But who's as much more convenient.
And it doesn't cost anything in hardware.
So to complement is definitely the way to go.
And I can understand that, that point of view, the thing, the thing I like about ones compliment is that you've got this extra state in the system and normal, normal.
Toes compliments, you've got zero and you've got everything else and in ones compliment you've got plus zero and minus zero.
And it helps me that it's very useful to have this extra states that can be used so you can have a value is either zero, not zero or not set or some such.
And I think this, this whole idea of having three states in a value rather than two.
It brings it closer to the optimal number of symbols required to transmit data, which I believe is e somebody proves a long time ago.
Anyway, it's just, I think it's a good idea.
You're talking about having code.
Yeah, yeah, yeah.
Yes.
The introduction on computer file about that two days ago, but having codes and the transition of following the edges of the of the square to get to that.
Okay, thanks for the link.
I'll look into that.
Okay, thanks, Chuck.
Okay.
Right. So, Bob, you will raise your hand.
Hello.
Okay, I have a few one thing I'm wondering when I heard you programmed a mainframe that was once compliment what mainframe was that you remember.
That's why I didn't name it.
Okay.
Could it have been a spare Univac.
No, it might have been the
don't use this.
Was it when you did that at the regs.
The first super computer right I can't come up with the name of it.
Oh, great.
Or us.
Great.
Or maybe one of its input terminals something like that.
Cool.
Second question.
You mentioned compatibility, you know, and how Microsoft does maintain compatibility.
You've just mentioned mainframes.
I was thinking, ZVM, which is the current version of Z of OS and MBS, which is OS MBT, which is OS 360 has maintained compatibility across since the 1960s.
When it first started and evidently you can compile a program today on CVM.
You've got ZOS, rather I'm sorry, ZOS mainframe and run.
I mean, just, you know, it was interesting that you'd mentioned compatibility.
IBM is having maintained that for all these years.
Compatibility guarantees there won't be any progress.
Yes.
What is the smallest fourth even you've run across what's the, you know, what's the minimum, like, if you could.
I don't know exactly I quantify it but like the smallest amount of memory smallest amount of space. What is, what is that.
What is that.
The smallest one I've done was called CM fourth.
For the Novics I think it was.
It for thing we had.
Micro fourth and many fourth, which explored the range of having a small kernel and everything else compiled.
And I believe he forced those out I believe.
But I have, I've heard references to these some micro computer fourth that had very small kernels.
I would say a kernel should not be more than 4k.
If you get it down to one K that would be nice.
Okay.
So you mentioned in talking and I forget who it was but you mentioned that the two parameters that you mentioned the stack that's on the feet.
Is that for like, as many levels as deep as you go or is it a.
I've never thought he was also small.
I would think in terms of the circular stack with eight elements.
So that you could put as many things on the stack as you want but you only have access to eight of them.
Now, for the nice circuit tracing algorithms.
I've needed to stack thousands deep, because as you trace a circuit you're recursing and recursing and recursing.
It's a whole different concept that I would have a software stack for the hardware stack can be very small for is too small, a to small 16 is plenty.
Okay, cool.
Two more. One is, did you know that the current dot net implementation of languages for do something called I L and I L is a fourth light stack language.
So they actually you compile C into a fourth language.
I don't know if none of that.
I would say no because I haven't understood what you said.
Okay, well, us that net is the kind of the IP.
I'm sorry, Microsoft's answer to Java C sharp is Microsoft's answer to Java.
become very popular so actually learn this language, if you're writing that kind of software.
But when it compiles, it compiles down into something called intermediate language, which is actually a very forth like language to stack based language.
I was, I thought that was interesting. I didn't know if you'd heard of that.
Well, all infects languages have to compile into a stack.
So yeah.
But if the interesting thing is this.
It doesn't compile.
It doesn't compile to a native, it compiles I L I L gets compiled to native.
An intermediate language.
Yeah.
That is.
To me that is grossly inefficient.
Why not writing intermediate language.
And on last thing is that you, you've talked about assembler and you don't even know the x86 op codes and such like that.
In the 1130 assembler, you wrote an assembler.
I mean, in 1134, you wrote an assembler so you could write 1130 instructions in a fourth life notation.
I mean, there's a right there right at the beginning is very cool.
Not only 1130 all of my, all of my computers had assembly words.
I don't think that that was a waste of time.
It was, it was hard to figure out how to construct the words.
It was hard to remember how they were constructed.
It was inefficient to implement the, the hex op codes are on any computer are far the simplest way of implementing it.
So it was, it was, it's interesting you saying that because it was just like, that was when we were looking at the code.
That was one of the most intense parts of the story.
What are you doing here.
And then like saying, wow, no, we fought, we fought really.
So it was fun.
It was, it was a clever.
But it was at least as difficult as the hex codes.
Yeah.
Okay, that's it. I'm out of here. I'm, at least I'm calling you. Thank you for your time.
Okay, thanks, Bob.
Our next questions come from Jan Bramkamp or Jen Brankamp.
I don't know.
If my microphone is working.
Yes.
So my question is, you've already rented about infix notation and how it doesn't compose.
And what do you think about a prefix notation like list.
I'm sorry, I lost my earpiece.
Sorry, let me repeat that.
You've already given us your opinion on infix notation and how badly it composes.
Your opinion on prefix notation languages like list.
Um,
they made an unfortunate choice.
I believe the human brain works on post fix.
You, you, you accept data.
You store it in your short term stack, and then you operate on it.
And then you pre fix things.
Okay, short answer.
And are you satisfied with it?
Yes, I got my answer.
Okay.
Okay, thanks, Jan.
The next is Anton Airtel.
Anton, please go ahead.
Oh, maybe your mic volume has been turned down.
So that's what happened to Jared.
So we can't hear you.
Mic selection.
No, no, no.
No, no, no.
No, and now not again.
So, yeah, yeah.
Go ahead.
All right. So, um, the question is, um, what is your take on state smart words?
I think you had them in your early fourth systems and then you eliminated them.
And I'm not sure if you have them in, in the reason systems.
I don't think so.
But can you talk a little bit about them?
And yeah.
Yeah, I think maybe that's an area in which forth has made some progress,
or at least my fourth.
And you HD fourth is basically color fourth.
And different words have different colors.
The state smart words would have different colors for different states.
For instance, the color white means execute immediately.
The color green means compile.
And those are only only two states that I need.
But I do have to be aware.
In programming.
For instance, a conditional word like if.
Or them.
That is an immediate word and must be in white.
If I have an if in green, it means compile a reference to if for future use.
And that's basically what the state smart words did.
You didn't have to be aware that they were.
Which state they were in.
If they knew.
But now I must be aware.
To distinguish green from white.
And that is a programming challenge.
Sometimes I get it wrong.
Thank you.
Yeah, interesting.
Yeah, don't.
Please.
Check again.
How many items or how deep do you think we should build the return stack in our fpj fourth.
32 bit fourth.
That doesn't matter.
I would go with eight.
Okay.
I think the return stack.
And the data stack.
Need not be the same length.
But by default, I would make them the same length.
So that until experience proved otherwise.
The next thing is that a circular stack that you're talking about.
It doesn't matter.
We actually implemented circular stacks.
So that was Dr. Ting.
We shared the code with me said, you circular stacks.
Okay, so we did that.
Dmitry implemented that.
It costs nothing in hardware.
My next question to you is.
Yep.
Why don't you utilize fpj's because that is your desktop chip making.
Scenario today.
And I will offer you when we get finished, I'll send you a complete system that you can play with.
And it's going to be in system bear log.
It's, it's very beautiful code right now.
It's like two pages of code to implement a fourth processor basic.
So why, why haven't you used fpj or development?
Because they wouldn't let me program them in fourth.
There you go.
That's great.
That's literally the reason and the only reason I would love to use an fpj, but they won't let me.
I have, I'd have to learn someone else's ugly language.
Yeah.
Remember that's only maybe five years that there are open source tool chains for for fpj programming.
Thanks, Chuck.
Okay, or not. You're raising your hand and you're putting it down and raising it. Maybe you have a question.
I actually wasn't putting it down, but it's okay.
Sorry. Yeah, I have a question. I think, like, fourth is like, you know, perceived as a runtime language, right.
It could be like a meta language. It could be like incredibly like expressive and like, you know, what are your thoughts about that?
And also, yeah, I can, I can ask the next question.
So what exactly was your question?
Oh, sorry.
So the question is, we're thinking about stacks and what stack to use and like, you know, what kind of stack size to use because like, that's a runtime for it.
Right. That's the fourth where it's like, you know, we execute a like a stack based we have a stack based runtime, right.
And that has like a certain costs in terms of like, you know, like third performance costs and it doesn't actually map to architectures like GPUs, for example, because there is not even like a concept of stacks just like, I mean, you could have like a memory stack on the GPUs
but it's got to work on like, you know, I think, I think fourth can be an amazing like compiler, you know, like, it's, it's, it's, I'm sorry, I can be, I'm super excited.
So I am somewhat in our particulates and can be harsh.
Oh, let me, let me try to address that.
Yes.
Thank you. The stack is nearly a tool that forth uses to express things compactly. And certainly forth has applications far beyond stack oriented things.
Fourth would make an excellent compiler. Fourth would make a good language translator. Fourth would make a good artificial intelligence effect.
And yes, I kind of agree fourth is a middle language. It lets you define an application language suitable for your environment.
Yes. Yes. Thank you. I mean, also, that brings to the second question, which is, like, I also think, like, having the, like, you know, the 144 chip, the, how, like, in terms of like the simplicity, that's, that's the way to actually reach like the energy, like, consumption to the minimum, right.
And we think there could be other constructs other than the stack to like, you know, or like, it could be like, I don't know.
I was thinking maybe it could be like a hardware definition language where we define those kinds of constructs for whatever problem at hand. So the hardware could morph, depending on like what kind of application is what run we redefine the hardware sort of
You don't need to be, you don't want to think restricted to a stack, you don't have to use a stack for everything.
As I said earlier, you can have you can have structures, which relieve the depth of the stack.
And, but the stack I think is in this, at least the small stack is absolutely essential for passing parameters.
I think I also come to that conclusion, because like it's super simple to pass parameters.
And yet I think like, you know, at some level, it's, it's, it's all like, it's, it's, it could be even like, you know, we implement the whole compiler and assembly and like, like use the
Sorry, I can, I can.
Also, I just want to say like, I, I thank you for, for all the inspiration and like for everything. I mean, I am, I'm so, so happy that I briefly got to introduce you to some of the work that I've been doing.
Yeah.
Okay, thank you very much. I think we follow up on that later.
Dimitri, another one.
It's a very short question. It was, it was based on Don's question on the return stack.
And in the, in the chat on Peter Jackie, he was saying, well, you know, wouldn't the return stack need to be deeper if you're going to factor your code heavily.
How could we have a return stack or say eight steep and still factor our fourth code.
Oh, no, it's a question. It's a question of complexity.
If you, if you have to deep a call sequence, this calls that calls that calls that.
It gets complicated and you lose track of what's going on.
I rarely have more than two or three levels of nested calls, which is what the return stack is for.
You see, okay, so it's quite flat to yes, because you can still, you can still factor your application into lots of short words, but they're just not words that call one another one another in a chain.
You're going to stay at the same level.
That's right.
The return stack is to hold the loop count, although that's not the only way of doing it.
So you want to consider how many nested loops you have, as well as how many nested calls.
Okay, that makes sense to me now thank you.
Okay, great.
Thanks so young for another question.
Yes, this time my question is regarding state smart words, I found them a pain in the posterior to work with.
And wouldn't it be possibly easier to have an always compiling forth where interactive code is compiled into an anonymous function and executed afterward just to be immediately deallocated.
Is there a downside to setting up a fourth system like this that it's always in compile mode and the defining a word would only move the compiler location from the scratch pad to the dictionary.
I'm a little bit out of my depth, because I don't know how state smart words are done conventionally.
I do, I do agree there needs to be two distinct behaviors, one in which you're interpreting and one in which you're compiling.
So do I need the interpreting state at all.
Couldn't this be solved by compiling into a temporary scratch pad area.
Large enough to hold a line of code or two, then calling this code and we using the scratch pad for the next interactive input. So always compile being in compile mode.
I can't do that. I think I did that once upon a time.
What is the downside.
It's no less clumsy. You still have to be aware of what you're doing.
And it's just a different way.
What say there's three ways of doing it. One you can have a state flag.
There's three different colors, or three you could have this compiled scratch and execute.
There's three ways of doing the same thing. I think the color way is is latest.
I went into this G for for Mac with still ours is that yes, that's a state verbal and some words respond to it and as soon as you want to do heavy meta programming and you need one of those states smart.
What's in another state smart word they don't nest.
That's really cool.
At that point you're scratching your head and some for systems work around it by providing non state smart versions and suddenly you have to two or three times the number of words.
For those words.
It's got the special treatment.
That's
Yes, I would rethink the problem.
Which is why I asked because
I have a state smart
state state smart question for Chuck so you know what I was thinking is, you have a 32 bit wide fourth computer in an FPJ.
Make the inside data bus 34 bits wide and then use the top four bits for your state.
Or whether it's an immediate word, or
you know compile, I guess it's compiling an immediate is that the two, two things you need to figure out.
I have done that on one of the early computers that I
had fabricated at 21 bit words.
Whereas the memory was only 20 bits and that extra bit was used as a flag for various things.
It was not good.
It was, it was as awkward and confusing and difficult as anything else.
Okay.
I maybe I have a follow up question and another one on that you once talked about the ice principle interpret compile execute.
So if we enroll everything into just compile.
Don't we lose the interpretation capability to calculate things up front before we compile. So do we need interpret compile execute the ice principle.
You're exactly right, we do need the ability to calculate things. And that's why in color fourth, if I compile green words, I can interpret interpolate white words to do the calculation.
Yeah, so so we don't want to lose this and maybe on this also answers a little bit of that.
We don't want to lose the capability to do execution while we compile and calculate things and generate code or whatever.
I didn't propose to eliminate immediate words.
Anyway,
my second question.
I was talking about the map is not the territory. And I would like to hear your current opinion on on the statement and how you think about abstraction.
The map, the map is not the territory.
But currently I prefer to work in the territory.
No that's not it that's inaccurate either.
In the case of drawing characters.
You draw the character, or you can describe the character.
Long time ago I would draw the characters.
And that became a pain, because I would somehow move a pixel the wrong place.
Now I describe the character.
I've come up with, I think a very compact way of describing characters.
So,
I go back and forth between the map and the territory.
I see. Yeah, thank you. Thank you very much and thank you very much for influencing my life over the last 40 years.
Yeah, maybe without knowing it, but you did the responsibility.
Right. Next question come from Travis.
I'll unmute so that we can hear you.
About eight deep return stacks.
I found a number of different uses for return stacks like, for instance, I'll make a word I have a word that out that a lot space in the dictionary.
And then deal us afterwards.
And I'll use the return stack as scratch space for storing the top of the here pointer for an afterwards so I can restore it and return it.
I think if an exception occurs.
I'll catch the exception or store the step which the dictionary, then rethrow the exception.
And also, in my fourth, I have to deal with exception frames, which go on this return stack.
Or there can be nested exception frames, where one exception is within another.
So, all the pop, and furthermore, the vote the tasking uses the return stack.
So, to store registers and all that. So, in essence, I need far more than eight cells on the return stack store all the possible states.
Even if my code itself does that go that deep.
What are your thoughts on this.
I understand you can have a larger, you can have a large multi purpose return stack certainly.
My concern is that it's getting complicated.
And I tend not to like it being complicated.
I would observe that in the case of circular stacks.
When you get an exception.
You don't need to do anything to the stacks, you just leave them where they are and get on your business, because you don't need to keep them clean.
Yeah.
I think the simple solution is to have a small return stack.
But I understand the convenience of having a large return stack.
Thank you.
Okay, we have two other guys that want to ask questions john Hardy please.
Again, I was just, I mean, it's return stacks, an interesting topic because it is necessary to discuss all sorts of different aspects of fourth, because, because the return stack is so critical to the virtual machine.
I'm interested in the changes that happened in colorful.
One of them I have to do with your use of tail call optimization as a way of reducing. So, you know that we're optimizing away calls.
So they become jumps, which means that they use less stack space.
So, I can see that would reduce the size of a return stack.
But one thing that seemed to get thrown away from my understanding of classic fourth is that you use a tow call optimization as a looping mechanism.
And that you when you do when you in classic fourth when you redefine a word, or when you define a word you don't have access to that word it's hidden until you're finished defining it.
Whereas in color fourth I believe the word is is visible so that you can call it so it can be called by itself.
So, can you talk a little bit about that change in the language. And, you know, like, what are your thoughts about the way you're ditching the idea of the original fourth and going forward in this way.
Yeah.
The, the original way would be my preference that you rarely reference a word within itself.
More likely you want to redefine the word, add some functionality to its previous definition.
That was complicated and awkward.
And in color fourth I just threw it away and said okay I'll have to live with the fact that if I want to redefine the name of a word.
I'll have to say word colon word.
Word zero word zero stuff stuff stuff.
That's awkward, but it doesn't happen very often.
Yeah.
Actually, I found that in my fourth that doing it the way that you did it before.
It's simply a matter of linking the word that you're compiling into dictionary after you hit the semi colon at the end.
And it works.
Basically, like, how it was where you, if you redefine a word you refer to its old meeting from within the new word without any work at all.
That is, that is exactly right.
But in my current fourth, semi colon does not indicate end of word.
It merely indicates return from word return. Yeah.
And so I have no word that identify the end of a word.
Okay, john.
Another question or
No, that's it.
You're done. Thank you very much.
Satisfied.
Okay, the last question for today comes from James Norris.
I was wondering what the most fun thing you ever worked on was
most fun thing.
And it gives you frequent positive feedback.
I have to say my chip layout and simulation.
It took years, five years.
But I was immediately doing good work after one week.
So I got this positive feedback, which continue and continue and continue.
The hard part of that was when you submit a chip for for fabrication.
And you have to wait three months before you know whether it worked or not.
And what do you do during those three months.
But I have to say that was a lot of fun for a lot of years.
This is great asking another question.
The trip simulation is fantastic. I think one of your very first projects that you ever worked on was the, the telescopic pointing and the data analysis you did interactively in that on the system with all the other astronomers watching the work output.
Because that is, that is quite significant to use something as large as a radio telescope to capture the data live and to manipulate the data to generate those graphs that I think are to be significant.
Because at the time, there was this this millimeter radio telescope was being used to discover interstellar molecule molecules.
Wow. And you would, you would, you would collect data and display it. And if there was a peak where you're expected to peak you discover the molecule.
And the immediate feedback was very useful for the astronomers.
But they still required that I record the raw data so they could take it home and repeat the analysis, even though that was completely unnecessary.
Brilliant.
You've done the processing already.
I'm not going to redo it probably not as well because I had good statistics.
Live statistics forget about post statistics.
Well, guys, I see, and we had a fantastic meeting today. We need to thanks 1000 times to Chuck.
And there are people in the meeting.
I see Rob Jude from Australia. Do you want to say hello and anything to Chuck not not questions but only hi.
Or do you have questions. Sorry.
No questions. Okay, who else I see Ray Gardner also from Australia very late in the night.
Ray.
Ray showed us in the group in the Facebook group. Fantastic pictures of his boards with the RTX 2000 and image vision in Australia for machines for different machines so he's the.
He's a wonderful for the run incredible incredible stuff. I see in the meeting Ashley Faniello wanted to show us the wonderful cognition do you want to say anything.
Ashley, something to Chuck.
I'll just hold Chuck. We met once in 2013 at the strange loop conference, but it's great to see you again it's always great to hear what you have to say.
Who else. I see Ilya that as a foremost cow. He's chatting but he does not like to talk what happens either too much vodka today.
Hello to Chuck. Okay. Okay, I'm here but I'm afraid with my new microphone is it will be not possible to hear me.
Okay, very good. It's very good. I just want to say hello.
No more. What else.
Hello.
What else and wish everyone to be healthy.
Thank you. Thank you to you to 330 in the morning in Australia.
Indeed this is a word by word translation of Russian hello be healthy.
Wonderful. Thank you Ilya. I see also Jonas Carlson. Where are you in the world Jonas. Do you want to say hello to Chuck.
Oh yeah one moment. Yes. So yeah I'm in Bangkok at the moment and well at the moment you're all stuck where we are right so it's two years.
So I had time to play with a lot of things and the last thing I played a few months ago was 6502 fourth and I was reading in parallel a lot of things about color fourth in and I found similarities when I was basically creating a system with an online editor running on a 6502 where
page 256 bytes was maybe it was buffer size basically and and this fourth was a bytecoded fourth actually is alphabetical bytecoded fourth so I use D for Duke and I use S for swap and so on and of course the arithmetic operations are plus and I remember reading
when I was working on this that you actually liked the idea of a bytecoded fourth but you never really went to do that. Do you have any comments about that and especially about the code bloat today.
We have so big systems and they are compiled to yield hundreds of bytes. Yeah, so that's my my general question.
I thought about bytecoding.
Other people have also.
It's a good strategy.
The closest I've come to it is the, the
the 144 instruction codes.
They are five bits.
So effectively done by coding on the hardware.
Arm microcontrollers with on the seven M have the T a BH and T H H instruction which are basically what you're asking for bytecode, the jump tables in mass manufactured CPUs, which can be used.
Yeah, but at fourth with a very tiny interpreter.
Yeah, I'm finally building my my so called alphabetical fourth, which is supposedly half readable kind of bytecode with the letters and symbols.
And I'm writing a very tiny C compiler that compile C to this fourth and I have it kind of working for functional C with no variables and just the other day I added variables.
So, as soon as I'll be able to compile C to fourth and the rationale for this is ESP 32, which I calculated that yes it's a very powerful thing that one line of C code usually ends up being about 80 bytes.
Oh, fantastic. Jonas, we are saying bye bye. Bye bye. We are finishing. Bye bye. Thank you.
Great. Another, another one here.
Holy Neppu. Holy Neppu. Is this correct?
Holy. Yeah, from time.
Holy. How are you?
I want to invite us to join this in, join this meeting.
To say that I have developed the, the course compiler for different micros MC use.
And the course compiler includes assembler disassembler and compiler and close compile.
And one special trick is that once the assembler is generated, the disassembly is automatically generated.
And the assembly that I designed is based on algebraic assembler.
So, every microcontroller can be seen the same, because we use, I use the same, same instruction like register and immediate word.
You can see that the old microcontroller can be seen as a false chip.
Not the really false chip, but the, actually we, if we say it is for chip and it contains only register and immediate word.
So that way, based on these two words, two, two characters, I can design the assembler based on these two.
So every microcontroller seems the same.
The assembler has, I can design the assembler in different way.
Fantastic. This is, this is great news. So we, we love to hear from you.
And we send all our regards to the fantastic thick Taiwan and all the great members you have.
Also, in, in the name of the team who is here and he wanted to show, to show something, but we will do this in the next meeting because we are out of time.
Thank you, Holly.
Looking forward to hearing more about that later time.
Another friend here is Igor Mats from Estonia. Is this correct the name Igor.
Only to say hello to Chuck and wish, wish him well and etc.
Do you hear me, yes.
Yeah, but the mic is not making noise, but it will do.
Hello Chuck, thank you very much for your creation.
Thanks for the first time in my school and it made a big movement in my development as progress. Thank you very much for one more time and be healthy in this time and I wish you many years and a lot of implement your plans.
Thank you Igor karsten. Do you want to say hi to Chuck and bye bye. Where are you from karsten from Germany.
Carson, yeah.
Your microphone.
I cannot.
I think you have to put on the volume, increase the volume, Karsten.
Okay, no problem.
Wave into the camera next time. So customers from Hamburg actually, oh, across the city.
Right. Thank you very much Karsten for participating next next time we we talk with you.
Also from Germany, do you want to say bye bye to check and thanks, etc.
Thank you for the microphone who else I am.
You're muted.
Check. I want to say hello from Germany, benefit. And I was motivated to write my own force, my own tiny force, because everybody should write his own tiny for before using a professional for us, I think, and I learned it from you.
And also Thomas Gweppel from Germany, he helped us putting the link in the hackaday so I thank you very much to Thomas, and he's also a great participant here in our meetings.
No sound, Thomas.
Hello.
Thank you, then, if you have no sound, thank you, thank you again.
Who else?
Atle from Norway, do you want to say bye bye and thank you to Charles.
I'm a relative newbie in short, and I just want to say thank you and I find it brilliant.
Thank you. Anthony for a lot. Do you want to say bye bye and thanks to Chuck.
Yes, I say hello to say hello to Chuck and thank you so much for all the difficult nights I have to work through to find books in my programs for me later.
It was really enjoyable. And still today, two months ago I started a new project with forth, so it is still very alive for me. Thank you.
Well, who else, George from Brazil, George is an item. Do you want to say.
Oh, hi, I really see me.
Yes.
Hello, I'm George from Brazil. I'd like to say thank you everyone, especially Peter for organizing this event. Chuck for Discover, like he says, this incredible language, it's amazing.
It's more than a language, it's a philosophy.
I don't know what to think. I don't know. I really love this. It's a pleasure to talk about it.
Forfe with people who likes Forfe. Oh, thanks. Thanks Peter, Ulrich, John Hard, Chuck, Dr. Ting, everyone. It's really, really nice to stay with them today.
Thank you for your love in the language, George. You are a great father. I have also here, Thomas from Kern. Thomas.
Yeah, thank you. Can you hear me. Thank you, Chuck. Thank you everybody for this very marvelous meeting. And I was using force of being in, I think, 85 to 87 brought my PhD, no my thesis in physics was a great time.
So thank you all and have a good time, Chuck. See you soon.
Bye bye.
Thank you, Thomas. Pablo, the Argentina Pablo Reda.
Hi, I like to say thank you to Chuck Moore. I am a color for fun.
I'm learning for reading the color for the source. And I changed my life with this marvelous language. Thank you.
Thank you, Pablo. Who else somebody else. And then we close Cecil Bayona. I don't know, Philip.
So Chuck, again, many thanks for the inspiration you gave me during those years when I was a student and still now and and clearly you are a wonderful person. So thank you for everything.
Fantastic.
Thanks again, Chuck, for being here.
I've been following force for many, many, many years.
And in my youth.
When I first heard about forth I was so excited.
Somebody who wanted to keep things simple rather than the abortions we had for programming at the time.
So thanks again for your great idea.
And what can I say.
Thank you again.
Well, guys, this was fantastic. I don't know if Chuck agrees to that and we do all these meetings, thinking and thanking everybody in the first community.
All people from as we think also who helped us every meeting and from all the communities in the world.
How do you have a race, race in hand.
Yeah. Chuck, is there any chance I could get my hands on your clock code.
I'd like to put it in as an app in color fourth.
You do you have any plans to post it anywhere.
Hey,
I don't have a vehicle for posting things.
I can send it by email.
I can send screen captures maybe I'll keep it in mind.
Okay, I'd also like to see the source for your character generator code that interests me.
That I would have would gladly publish.
Again, if I had some way of doing it. I used to have a website.
I was thinking, maybe I should reactivate the website.
But I haven't yet.
Okay, if you come up with any way of transferring it can help in any way let me know and I'll help you gladly.
Okay, I want to thank you all for inviting me. It's been fun.
And it's gratifying to see so many interested fourth people.
And I'm sure you will in your endeavors.
Thank you.
Thank you.
Thank you very much.
Thank you.
Thank you very much for joining us.
Thank you.
Thank you.
Thank you everybody.
Thank you.
