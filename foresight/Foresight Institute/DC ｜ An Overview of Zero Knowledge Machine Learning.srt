1
00:00:00,000 --> 00:00:03,200
Hi, Vern. Welcome to FOSAT's Intelligent Cooperation Group.

2
00:00:03,200 --> 00:00:05,080
We're really excited about this seminar.

3
00:00:05,080 --> 00:00:07,560
We have DC here from Welkheim.

4
00:00:07,560 --> 00:00:11,160
Thank you so much for joining us to give an overview of ZKML,

5
00:00:11,160 --> 00:00:13,560
which is a topic that has come up so much,

6
00:00:13,560 --> 00:00:16,920
especially, I guess, data coming up already a few years ago

7
00:00:16,920 --> 00:00:18,560
in this group, and then much, much more

8
00:00:18,560 --> 00:00:20,640
to have really ramping up in the last year.

9
00:00:20,640 --> 00:00:22,720
And so I'm really excited for you to share a little bit more

10
00:00:22,720 --> 00:00:24,840
about it because we have not had a dedicated seminar

11
00:00:24,840 --> 00:00:25,600
to this topic yet.

12
00:00:25,600 --> 00:00:26,960
So thanks a lot for joining.

13
00:00:26,960 --> 00:00:28,640
We're really excited about you guys' work.

14
00:00:28,720 --> 00:00:30,120
Without further ado, please take it away.

15
00:00:30,120 --> 00:00:31,760
I'll be in the chat monitoring questions,

16
00:00:31,760 --> 00:00:33,760
and we're off to the races.

17
00:00:33,760 --> 00:00:35,600
Awesome. Thank you for having me.

18
00:00:35,600 --> 00:00:38,640
So today, I'll be talking about the zero-knowledge machine

19
00:00:38,640 --> 00:00:39,120
learning.

20
00:00:39,120 --> 00:00:41,600
I'll be giving a very brief introduction.

21
00:00:41,600 --> 00:00:45,120
But first, maybe let me start by saying a little bit about myself.

22
00:00:45,120 --> 00:00:48,200
I'm a research engineer at the World Coin Foundation,

23
00:00:48,200 --> 00:00:49,640
and World Coin is this project that

24
00:00:49,640 --> 00:00:53,640
is trying to build the largest identity and financial network.

25
00:00:53,640 --> 00:00:56,720
And there is an interplay of various technologies

26
00:00:56,720 --> 00:00:59,600
in the products and things that we're building at World Coin,

27
00:00:59,600 --> 00:01:03,040
and some of which are AI, and some of which are cryptography.

28
00:01:03,040 --> 00:01:05,160
So we've had expertise in both realms

29
00:01:05,160 --> 00:01:06,840
from different teams internally.

30
00:01:06,840 --> 00:01:09,840
And there have been some essentially experimentation

31
00:01:09,840 --> 00:01:10,960
that naturally occurred.

32
00:01:10,960 --> 00:01:12,840
We have some AI parts of the stack,

33
00:01:12,840 --> 00:01:15,200
and there are some reasons why cryptography might

34
00:01:15,200 --> 00:01:17,560
be useful in the AI sector of the stack.

35
00:01:17,560 --> 00:01:21,200
And so this prompted us to think about this topic

36
00:01:21,200 --> 00:01:23,000
about two years ago in August.

37
00:01:23,000 --> 00:01:25,280
Almost two years ago, August of 2022.

38
00:01:25,760 --> 00:01:28,240
One of my teammates was just playing around with cryptography

39
00:01:28,240 --> 00:01:30,160
and trying to prove machine learning models.

40
00:01:30,160 --> 00:01:32,640
But so this is a little bit of a background.

41
00:01:32,640 --> 00:01:34,920
I mostly run our grants program, where

42
00:01:34,920 --> 00:01:36,920
we give grants to people to help decentralize World

43
00:01:36,920 --> 00:01:38,400
Coin and solve some more problems,

44
00:01:38,400 --> 00:01:41,040
and also help with a bunch of different R&D efforts

45
00:01:41,040 --> 00:01:43,080
as an individual contribute.

46
00:01:43,080 --> 00:01:46,240
So without further ado, let me start with the presentation.

47
00:01:46,240 --> 00:01:48,720
Usually, the way that I like to start with this presentation

48
00:01:48,720 --> 00:01:52,400
is that I like to decompose the statement into its constituents

49
00:01:52,400 --> 00:01:55,560
so that people have an understanding of which elements

50
00:01:55,560 --> 00:01:57,040
or what is zero-knowledge machine learning?

51
00:01:57,040 --> 00:01:58,280
What is the zero-knowledge part?

52
00:01:58,280 --> 00:02:00,040
What is the machine learning part?

53
00:02:00,040 --> 00:02:03,000
I like to decompose it into its fundamental compositions,

54
00:02:03,000 --> 00:02:04,240
so competition.

55
00:02:04,240 --> 00:02:06,280
And the first one that I want to talk about

56
00:02:06,280 --> 00:02:10,280
is zero-knowledge cryptography, or called zero-knowledge.

57
00:02:10,280 --> 00:02:12,720
I don't know if many of you understand the reference that

58
00:02:12,720 --> 00:02:15,320
or get the reference that I put here, which is Waldo,

59
00:02:15,320 --> 00:02:16,320
finding Waldo.

60
00:02:16,320 --> 00:02:20,160
Waldo essentially is a character or one specific analogy,

61
00:02:20,200 --> 00:02:22,320
which is very simple, very easy, very friendly

62
00:02:22,320 --> 00:02:24,280
to explain what zero-knowledge cryptography is

63
00:02:24,280 --> 00:02:26,320
to people who have never heard about it.

64
00:02:26,320 --> 00:02:28,760
Because there is this essentially like poster

65
00:02:28,760 --> 00:02:31,080
that many people know where there's just lots of characters

66
00:02:31,080 --> 00:02:33,960
which are in the city, and there's one Waldo.

67
00:02:33,960 --> 00:02:36,960
And it takes some amount of time to essentially find the Waldo,

68
00:02:36,960 --> 00:02:39,720
and that's like the challenge of these specific games.

69
00:02:39,720 --> 00:02:41,840
And so there is one specific analogy

70
00:02:41,840 --> 00:02:44,360
which allows people to explain what zero-knowledge is,

71
00:02:44,360 --> 00:02:50,120
which is that if I put a bigger like white paper

72
00:02:50,240 --> 00:02:53,400
on top of the poster, defining Waldo game,

73
00:02:53,400 --> 00:02:56,120
and if I create a little tiny cutout for the head of Waldo,

74
00:02:56,120 --> 00:02:59,520
and I place the cutout just on top of Waldo's head,

75
00:02:59,520 --> 00:03:03,960
but covering the entire game itself, or the poster itself,

76
00:03:03,960 --> 00:03:06,960
then I'm able to prove to anyone that I know where Waldo is

77
00:03:06,960 --> 00:03:09,400
without revealing his location within the poster.

78
00:03:09,400 --> 00:03:10,680
So this is like the good analogy

79
00:03:10,680 --> 00:03:12,640
for explaining what zero-knowledge cryptography is,

80
00:03:12,640 --> 00:03:15,600
because I'm able to prove things that I know

81
00:03:15,600 --> 00:03:17,880
to someone else, to an outside observer,

82
00:03:17,880 --> 00:03:20,360
without them learning everything

83
00:03:20,360 --> 00:03:21,800
about the things I'm making a proof of.

84
00:03:21,800 --> 00:03:24,440
I can selectively prove specific statements

85
00:03:24,440 --> 00:03:25,960
because I have information,

86
00:03:25,960 --> 00:03:27,880
but I don't have to reveal everything

87
00:03:27,880 --> 00:03:29,360
in order to be able to prove that statement.

88
00:03:29,360 --> 00:03:32,240
So this is like a good analogy to explain DK.

89
00:03:32,240 --> 00:03:35,520
So some of the properties that zero-knowledge cryptography has.

90
00:03:35,520 --> 00:03:37,600
So the first one, which I think is the most important one,

91
00:03:37,600 --> 00:03:39,200
especially in the context of blockchain,

92
00:03:39,200 --> 00:03:42,800
I saw that many of you were like in previous presentations

93
00:03:42,800 --> 00:03:44,720
of this specific group.

94
00:03:44,720 --> 00:03:46,120
I saw that there's a few crypto people

95
00:03:46,120 --> 00:03:47,240
that were talking about different things.

96
00:03:47,240 --> 00:03:49,920
I'm sure that came along a few times.

97
00:03:49,920 --> 00:03:51,960
So succinct list essentially just means

98
00:03:51,960 --> 00:03:55,320
that in order to verify a proof of a statement,

99
00:03:55,320 --> 00:03:57,680
it's a lot less computationally expensive

100
00:03:57,680 --> 00:03:59,160
or a lot less expensive

101
00:03:59,160 --> 00:04:02,160
than to actually prove the computation

102
00:04:02,160 --> 00:04:04,520
or to just perform the computation yourself, right?

103
00:04:04,520 --> 00:04:07,600
So essentially verifying that I know where Waldo is,

104
00:04:07,600 --> 00:04:08,680
as an outside observer,

105
00:04:08,680 --> 00:04:11,320
it's a lot easier than me finding Waldo myself.

106
00:04:11,320 --> 00:04:13,280
So this is really important in the context of blockchains

107
00:04:13,280 --> 00:04:15,160
because for example, for scalability solutions,

108
00:04:15,160 --> 00:04:17,080
instead of everyone having to re-execute

109
00:04:17,080 --> 00:04:18,720
the same transactions in a block,

110
00:04:18,720 --> 00:04:20,000
I can just verify a proof

111
00:04:20,000 --> 00:04:21,280
and I can just update my state

112
00:04:21,280 --> 00:04:23,760
without having to secure it myself, for example.

113
00:04:23,760 --> 00:04:25,640
So this property is important for the kid

114
00:04:25,640 --> 00:04:27,720
because it allows us to very easily,

115
00:04:27,720 --> 00:04:30,440
computationally easily verify things

116
00:04:30,440 --> 00:04:32,000
without having to do computation ourselves.

117
00:04:32,000 --> 00:04:33,600
This is a really important property.

118
00:04:33,600 --> 00:04:37,240
The second one, arguably the one that is most known for,

119
00:04:37,240 --> 00:04:38,200
is correctness.

120
00:04:38,200 --> 00:04:39,640
So correctness essentially means

121
00:04:39,640 --> 00:04:42,960
that I can have almost 100% certainty

122
00:04:42,960 --> 00:04:46,400
that this statement that I'm proving is correct, right?

123
00:04:46,440 --> 00:04:47,680
That I cannot lie.

124
00:04:47,680 --> 00:04:49,840
There is no way that I as a prover

125
00:04:49,840 --> 00:04:52,000
can lie to a verifier

126
00:04:52,000 --> 00:04:55,000
unless if the cryptography is sound in this case.

127
00:04:55,000 --> 00:04:56,520
There's two specific properties

128
00:04:56,520 --> 00:04:58,040
that constitute correctness.

129
00:04:58,040 --> 00:04:59,440
One is soundness.

130
00:04:59,440 --> 00:05:01,760
So soundness means that I, if I'm a prover,

131
00:05:01,760 --> 00:05:04,560
someone making this claim, someone making a statement,

132
00:05:04,560 --> 00:05:08,720
I'm not able to fool a verifier with invalid proof

133
00:05:08,720 --> 00:05:11,040
and completeness is another property

134
00:05:11,040 --> 00:05:14,280
where I'm not essentially able to create a valid proof

135
00:05:14,280 --> 00:05:15,220
unless I know the truth.

136
00:05:15,220 --> 00:05:16,180
If I don't know the truth,

137
00:05:16,180 --> 00:05:20,380
I cannot make a valid proof as a prover.

138
00:05:20,380 --> 00:05:23,460
And the third one, which is name after, zero knowledge,

139
00:05:23,460 --> 00:05:26,860
is this property where I can hide parts of the statement.

140
00:05:26,860 --> 00:05:28,660
For example, let's say that I have,

141
00:05:28,660 --> 00:05:29,820
I don't know, this is a good example.

142
00:05:29,820 --> 00:05:31,260
Let's say I have my passport.

143
00:05:31,260 --> 00:05:34,380
So I have my name, my nationality, my date of birth,

144
00:05:34,380 --> 00:05:36,980
where I'm from, which country I was born in,

145
00:05:36,980 --> 00:05:39,100
for example, the place of birth.

146
00:05:39,100 --> 00:05:40,460
So something that would be useful

147
00:05:40,460 --> 00:05:43,220
or like something that would constitute a zero knowledge proof

148
00:05:43,220 --> 00:05:44,500
is that I can make the statement

149
00:05:44,500 --> 00:05:47,500
that my age is over 18 years old

150
00:05:47,500 --> 00:05:49,460
without revealing to anyone my age,

151
00:05:49,460 --> 00:05:53,060
but anyone can just verify that I'm actually over 18.

152
00:05:53,060 --> 00:05:54,540
The way that this is actually implemented

153
00:05:54,540 --> 00:05:55,820
is that within a zero knowledge proof,

154
00:05:55,820 --> 00:05:59,100
I can verify a signature from some issuing body

155
00:05:59,100 --> 00:06:00,160
like the government.

156
00:06:00,160 --> 00:06:02,020
And then I can make a statement that like A,

157
00:06:02,020 --> 00:06:03,820
this age, which was attested to

158
00:06:03,820 --> 00:06:07,420
or essentially committed to by a government is over 18

159
00:06:07,420 --> 00:06:08,780
and you don't learn my age.

160
00:06:08,780 --> 00:06:10,100
So this is the zero knowledge part

161
00:06:10,100 --> 00:06:11,940
where I'm able to hide parts of the state

162
00:06:11,940 --> 00:06:14,740
that I'm making a statement about or proof about

163
00:06:14,740 --> 00:06:17,780
according to some constraint or some statement, right?

164
00:06:17,780 --> 00:06:19,580
Like I can say greater than, less than,

165
00:06:19,580 --> 00:06:23,020
equal to a bunch of other properties

166
00:06:23,020 --> 00:06:24,540
that I think can put.

167
00:06:24,540 --> 00:06:27,020
So the second part of the statement

168
00:06:27,020 --> 00:06:28,340
of zero knowledge machine learning,

169
00:06:28,340 --> 00:06:29,420
this machine learning, right?

170
00:06:29,420 --> 00:06:32,020
I think that one is much more familiar to most of you

171
00:06:32,020 --> 00:06:35,100
since it's been generating such a buzz everywhere,

172
00:06:35,100 --> 00:06:36,860
like machine learning through a generative AI,

173
00:06:36,860 --> 00:06:39,060
like in things like ChagYPT or Dali

174
00:06:39,060 --> 00:06:41,300
or a lot of generative AI models

175
00:06:41,340 --> 00:06:43,940
or natural language processing, categorizing models

176
00:06:43,940 --> 00:06:46,180
like robots, the machine learning essentially,

177
00:06:46,180 --> 00:06:49,540
the way that I think about it is that it's a tool

178
00:06:49,540 --> 00:06:53,340
that allows us to give us not the non-deterministic solutions

179
00:06:53,340 --> 00:06:56,220
or just estimates for short for problems

180
00:06:56,220 --> 00:06:58,940
that don't really have a concrete solution, right?

181
00:06:58,940 --> 00:07:00,860
There's usually there's some problems

182
00:07:00,860 --> 00:07:02,820
which we can solve algorithmically

183
00:07:02,820 --> 00:07:04,180
and we can just have a set of steps

184
00:07:04,180 --> 00:07:07,140
that we can just execute in order to solve it

185
00:07:07,140 --> 00:07:09,620
and we will have a perfect solution every time.

186
00:07:09,620 --> 00:07:11,900
In the case of machine learning, however,

187
00:07:11,900 --> 00:07:13,420
most of the problems that are being solved

188
00:07:13,420 --> 00:07:15,340
by machine learning are not such problems.

189
00:07:15,340 --> 00:07:16,820
Therefore, we need to,

190
00:07:16,820 --> 00:07:19,500
because maybe like the space of solutions is too big

191
00:07:19,500 --> 00:07:22,420
or the space of the steps that we can take is too big,

192
00:07:22,420 --> 00:07:24,940
so it's really hard to navigate deterministically,

193
00:07:24,940 --> 00:07:27,060
then we just have this sort of juristic.

194
00:07:27,060 --> 00:07:30,620
A juristic essentially is a good enough approximation

195
00:07:30,620 --> 00:07:33,460
to the real solution which we can work with

196
00:07:33,460 --> 00:07:35,820
and which has some form of accuracy, right?

197
00:07:35,820 --> 00:07:37,540
So in the context of machine learning,

198
00:07:37,540 --> 00:07:40,300
we have some sort of juristic for some problem.

199
00:07:40,300 --> 00:07:42,540
So let's say I want to categorize

200
00:07:42,540 --> 00:07:46,060
whether an image that I see is the image of a dog or a cat.

201
00:07:46,060 --> 00:07:48,340
This I can train a machine learning model

202
00:07:48,340 --> 00:07:49,980
to essentially solve this task,

203
00:07:49,980 --> 00:07:52,300
but the machine learning model will never be 100% correct.

204
00:07:52,300 --> 00:07:54,460
It will have some accuracy, right?

205
00:07:54,460 --> 00:07:55,780
It will have some that will fail on,

206
00:07:55,780 --> 00:07:58,940
it will have, most of them it will get correct.

207
00:07:58,940 --> 00:08:01,860
But essentially the way that the machine learning model works

208
00:08:01,860 --> 00:08:04,380
is that it trains on some data.

209
00:08:04,380 --> 00:08:06,620
So I feed some data to some model

210
00:08:06,740 --> 00:08:09,340
or to some machine learning algorithm and it gets better.

211
00:08:09,340 --> 00:08:11,940
And this juristic keep getting better and better

212
00:08:11,940 --> 00:08:14,060
for things that it hasn't seen before.

213
00:08:14,060 --> 00:08:15,820
It generalizes over the data

214
00:08:15,820 --> 00:08:18,540
and it's able to make essentially like predictions

215
00:08:18,540 --> 00:08:21,060
or classifications or all sorts of things.

216
00:08:21,060 --> 00:08:22,300
So in the case, for example,

217
00:08:22,300 --> 00:08:25,220
of foundational models for large language models,

218
00:08:25,220 --> 00:08:28,620
they get better at creating like cohesive explanations

219
00:08:28,620 --> 00:08:30,620
or at reasoning or at mathematics

220
00:08:30,620 --> 00:08:32,620
or at all sorts of different things.

221
00:08:32,620 --> 00:08:34,380
And we can have these benchmarks

222
00:08:34,380 --> 00:08:36,860
and with more data, they get better at these benchmarks,

223
00:08:36,860 --> 00:08:39,540
which essentially provide better juristic problems

224
00:08:39,540 --> 00:08:41,060
that we're grading them on.

225
00:08:41,060 --> 00:08:44,180
So another concept that I want to explain here

226
00:08:44,180 --> 00:08:47,140
is that there's two specific parts within machine learning

227
00:08:47,140 --> 00:08:50,580
or two specific things you can do usually,

228
00:08:50,580 --> 00:08:53,380
is that when you have a model, you can train a model.

229
00:08:53,380 --> 00:08:56,540
The act of training a model is the act of creating a function

230
00:08:56,540 --> 00:08:58,860
which gets actually better and better

231
00:08:58,860 --> 00:09:00,820
at giving you the juristics,

232
00:09:00,820 --> 00:09:02,700
the more data you feed into it, right?

233
00:09:02,700 --> 00:09:04,780
So I'm able to update the parameters of this function

234
00:09:04,780 --> 00:09:07,820
by learning, this is what learning is, right?

235
00:09:07,820 --> 00:09:09,340
I'm updating parameters of a function

236
00:09:09,340 --> 00:09:10,980
in order to get a better jurist.

237
00:09:10,980 --> 00:09:12,900
And this process is really expensive, right?

238
00:09:12,900 --> 00:09:15,820
It's really hard, you have to co-locate a data center,

239
00:09:15,820 --> 00:09:19,340
it's running lots of graphics cards in a big place

240
00:09:19,340 --> 00:09:21,460
and consuming lots of electricity for months on end

241
00:09:21,460 --> 00:09:23,500
in order to be able to create something useful

242
00:09:23,500 --> 00:09:25,540
or meaningful, this is really expensive.

243
00:09:25,540 --> 00:09:27,580
But the end product is very easy to run.

244
00:09:27,580 --> 00:09:29,020
So once I've trained this function,

245
00:09:29,020 --> 00:09:30,700
once I have my set of parameters,

246
00:09:30,700 --> 00:09:32,620
evaluating this function at some input,

247
00:09:32,620 --> 00:09:35,340
is usually inexpensive or very inexpensive

248
00:09:35,340 --> 00:09:37,300
compared to actually training it,

249
00:09:37,300 --> 00:09:39,500
several orders of magnitude less.

250
00:09:39,500 --> 00:09:41,220
So these are like the,

251
00:09:41,220 --> 00:09:44,300
how I usually explain machine learning just very briefly.

252
00:09:44,300 --> 00:09:45,700
And so now I want to get,

253
00:09:45,700 --> 00:09:47,660
what is zero knowledge machine learning, right?

254
00:09:47,660 --> 00:09:49,620
We have some intuitions from the ZK side,

255
00:09:49,620 --> 00:09:51,740
some intuitions from the machine learning side.

256
00:09:51,740 --> 00:09:55,700
Now we can discuss what ZK machine learning can be

257
00:09:55,700 --> 00:09:58,780
or is within the modern understanding of it.

258
00:09:58,780 --> 00:10:00,780
So essentially what ZKML is,

259
00:10:00,780 --> 00:10:04,060
is the creation of zero knowledge proofs

260
00:10:04,060 --> 00:10:05,980
of machine learning algorithms, right?

261
00:10:05,980 --> 00:10:08,460
So zero knowledge cryptography allows you

262
00:10:08,460 --> 00:10:11,420
to create proofs of arbitrary computations.

263
00:10:11,420 --> 00:10:14,620
It can be a proof that I've computed some specific thing.

264
00:10:14,620 --> 00:10:17,500
It can be a proof that some variable is bigger than another.

265
00:10:17,500 --> 00:10:19,300
Essentially it's making proofs about computation

266
00:10:19,300 --> 00:10:22,140
and you know the person who's verifying that proof

267
00:10:22,140 --> 00:10:24,540
knows that someone has executed that computation

268
00:10:24,540 --> 00:10:27,860
on some inputs and has produced some output.

269
00:10:27,860 --> 00:10:29,100
So in the context of machine learning,

270
00:10:29,100 --> 00:10:32,260
usually you have some input, a function or a model,

271
00:10:32,260 --> 00:10:33,500
and then some output, right?

272
00:10:33,500 --> 00:10:35,460
So if it's let's say like charge EPT,

273
00:10:35,460 --> 00:10:37,700
I have a prompt which I feed into the model.

274
00:10:37,700 --> 00:10:41,380
The model just takes that prompt and evaluates its model

275
00:10:41,380 --> 00:10:42,700
and it gives you an output,

276
00:10:42,700 --> 00:10:44,660
which is the thing that you then read in the end,

277
00:10:44,660 --> 00:10:46,060
which is the result, right?

278
00:10:46,060 --> 00:10:48,780
So zero knowledge machine learning would be the art

279
00:10:48,780 --> 00:10:53,060
or act of creating a proof that I have fed an input

280
00:10:53,060 --> 00:10:54,940
to a model and I've produced some output.

281
00:10:54,940 --> 00:10:58,060
And I can verify that this output came from a model

282
00:10:58,100 --> 00:11:01,700
without essentially having to evaluate this myself personally.

283
00:11:01,700 --> 00:11:03,900
I just know that this comes from a model

284
00:11:03,900 --> 00:11:07,100
because I have a cryptographic proof that this indeed happened.

285
00:11:07,100 --> 00:11:09,300
So something that many people in the space

286
00:11:09,300 --> 00:11:13,140
actually use as a good analogy that accountable AI, right?

287
00:11:13,140 --> 00:11:15,380
Usually AI or machine learning models,

288
00:11:15,380 --> 00:11:17,540
you don't know that they're actually correct

289
00:11:17,540 --> 00:11:20,180
unless you run them yourself, right?

290
00:11:20,180 --> 00:11:22,260
If you run it yourself on your own local machine

291
00:11:22,260 --> 00:11:24,940
or your own data center which you have privileged access to,

292
00:11:24,940 --> 00:11:27,580
then you know that you've run the right thing.

293
00:11:27,580 --> 00:11:30,660
But let's say that you're using some form of server or API, right?

294
00:11:30,660 --> 00:11:33,860
If I go to chat GPT, like the website,

295
00:11:33,860 --> 00:11:36,940
how do I know that OpenAI is actually serving me

296
00:11:36,940 --> 00:11:37,860
the right model?

297
00:11:37,860 --> 00:11:40,940
They claim, like in the UI, in the front end,

298
00:11:40,940 --> 00:11:43,740
they claim that I am using GPT-4, but how do I know that?

299
00:11:43,740 --> 00:11:46,540
There's no way of me of actually verifying that this is GPT-4.

300
00:11:46,540 --> 00:11:48,180
They might be serving me a worse model,

301
00:11:48,180 --> 00:11:49,540
which is cheaper to run

302
00:11:49,540 --> 00:11:52,020
and just pocketing the difference, for example, right?

303
00:11:52,020 --> 00:11:52,900
I don't know.

304
00:11:52,900 --> 00:11:55,460
So one good thing that ZKML provides

305
00:11:55,460 --> 00:11:56,780
is this form of accountability

306
00:11:56,780 --> 00:12:00,660
where I, as the consumer of some API or some model,

307
00:12:00,660 --> 00:12:02,900
I know that this actually came from something

308
00:12:02,900 --> 00:12:05,100
because I can verify a cryptographic proof

309
00:12:05,100 --> 00:12:06,020
that this indeed happened.

310
00:12:06,020 --> 00:12:07,740
So we can make AIs accountable.

311
00:12:07,740 --> 00:12:09,780
We can make anyone using AI accountable

312
00:12:09,780 --> 00:12:12,620
because we can make proofs of computation.

313
00:12:12,620 --> 00:12:17,020
Many of the framing for ZKML in the modern way

314
00:12:17,020 --> 00:12:20,340
is that they want to essentially bring machine learning on-chain

315
00:12:20,340 --> 00:12:22,220
or onto the blockchain in this case, right?

316
00:12:22,220 --> 00:12:24,860
Like we have the blockchains where we have

317
00:12:24,860 --> 00:12:29,100
very interconnected networks of low-end hardware, mostly.

318
00:12:29,100 --> 00:12:32,220
It's like consumer hardware, which is available everywhere,

319
00:12:32,220 --> 00:12:34,460
to run these decentralized networks.

320
00:12:34,460 --> 00:12:36,700
And the problem with this is that every single computer

321
00:12:36,700 --> 00:12:39,420
on this network needs to re-execute everything

322
00:12:39,420 --> 00:12:41,620
that the network sees in order to validate

323
00:12:41,620 --> 00:12:43,860
that the network is progressing correctly.

324
00:12:43,860 --> 00:12:45,100
And this is a big problem

325
00:12:45,100 --> 00:12:47,060
because now everything is really expensive.

326
00:12:47,060 --> 00:12:49,940
If it's already expensive running it on your own machine,

327
00:12:49,940 --> 00:12:52,100
if you have to run it on 1,000 machines

328
00:12:52,100 --> 00:12:53,900
or 10,000 or 100,000 machines,

329
00:12:53,940 --> 00:12:56,620
it's as many times more expensive.

330
00:12:56,620 --> 00:13:00,300
So it's unfeasible to essentially do machine learning

331
00:13:00,300 --> 00:13:03,500
on-chain right now because it's just too expensive.

332
00:13:03,500 --> 00:13:05,140
And the computational environment

333
00:13:05,140 --> 00:13:07,300
that these usually like blockchains have,

334
00:13:07,300 --> 00:13:09,900
like virtual machines, let's say if they're about the EVM,

335
00:13:09,900 --> 00:13:12,900
Solana has SVM, the Solana virtual machine,

336
00:13:12,900 --> 00:13:15,060
that every single blockchain or most blockchains

337
00:13:15,060 --> 00:13:17,460
do have some form of execution capabilities

338
00:13:17,460 --> 00:13:18,740
or computing capabilities.

339
00:13:18,740 --> 00:13:20,420
And these are very constrained.

340
00:13:20,460 --> 00:13:23,940
So some of the things that blockchains are good at

341
00:13:23,940 --> 00:13:26,580
is cryptography because they're usually subsidized

342
00:13:26,580 --> 00:13:30,100
within the cost of execution in blockchain.

343
00:13:30,100 --> 00:13:33,700
So I can verify a zero-knowledge proof on a blockchain

344
00:13:33,700 --> 00:13:36,540
and I can bring something that I run off-chain

345
00:13:36,540 --> 00:13:38,060
on-chain by providing a proof, right?

346
00:13:38,060 --> 00:13:41,300
So for example, if I'm evaluating a model locally,

347
00:13:41,300 --> 00:13:42,820
I'm able to create a zero-knowledge proof

348
00:13:42,820 --> 00:13:44,900
that I've evaluated a model on some input

349
00:13:44,900 --> 00:13:47,460
and I can just send the output to the chain

350
00:13:47,460 --> 00:13:48,660
and verify a proof.

351
00:13:48,660 --> 00:13:50,820
And then the chain or the smart contract

352
00:13:50,820 --> 00:13:53,860
can know that I've actually run a model on some inputs

353
00:13:53,860 --> 00:13:57,060
and I don't have to run that within the environment,

354
00:13:57,060 --> 00:13:58,180
the computing environment, the blockchain,

355
00:13:58,180 --> 00:13:59,660
so I can save a lot of cost.

356
00:13:59,660 --> 00:14:02,340
And if I make ML more accessible on-chain,

357
00:14:02,340 --> 00:14:04,820
I can actually bring it and I can build application

358
00:14:04,820 --> 00:14:07,420
that leverage machine learning for lots of different things

359
00:14:07,420 --> 00:14:09,820
which I'll get into a little bit later.

360
00:14:09,820 --> 00:14:12,660
And the last one is the zero-knowledge part of things

361
00:14:12,660 --> 00:14:15,660
where I'm able to hide specific parts of the computation

362
00:14:15,660 --> 00:14:18,420
or specific parts of the data that I'm making proofs about

363
00:14:18,420 --> 00:14:21,340
and therefore I can make machine learning private.

364
00:14:21,340 --> 00:14:22,660
In order to make machine learning private,

365
00:14:22,660 --> 00:14:24,540
there's other techniques as well

366
00:14:24,540 --> 00:14:26,260
which is like fully homomorphic encryption

367
00:14:26,260 --> 00:14:27,860
and multi-party computation.

368
00:14:27,860 --> 00:14:30,340
Each of these other types of cryptography

369
00:14:30,340 --> 00:14:33,700
or types of distributed systems engineering and compute it

370
00:14:33,700 --> 00:14:35,460
usually have different trade-offs.

371
00:14:35,460 --> 00:14:37,580
So for example, fully homomorphic encryption

372
00:14:37,580 --> 00:14:40,140
does not give you this correctness assumption

373
00:14:40,140 --> 00:14:41,500
or like probability.

374
00:14:41,500 --> 00:14:43,620
I cannot verify that something happened correctly,

375
00:14:43,620 --> 00:14:47,020
but I can, for example, make computations on Cyphertex.

376
00:14:47,020 --> 00:14:48,500
So if I encrypt some data,

377
00:14:48,500 --> 00:14:51,220
I'm able to perform computations on encrypted data.

378
00:14:51,220 --> 00:14:54,380
And when I decrypt, I have the computation performed

379
00:14:54,380 --> 00:14:57,020
on the original input, on the original plaintext

380
00:14:57,020 --> 00:14:59,180
which is something that is quite fascinating.

381
00:14:59,180 --> 00:15:01,140
However, I do lose this property of ZK

382
00:15:01,140 --> 00:15:04,220
where I cannot verify that something happened correctly.

383
00:15:04,220 --> 00:15:07,060
Multi-party computation is like the better of both worlds

384
00:15:07,060 --> 00:15:10,380
but for example, these protocols require multiple parties

385
00:15:10,380 --> 00:15:12,140
to work in unison

386
00:15:12,140 --> 00:15:14,740
and this is really hard to manage, for example.

387
00:15:14,740 --> 00:15:17,060
So yeah, so I want to talk a bit

388
00:15:17,060 --> 00:15:18,620
about who is actually building

389
00:15:18,620 --> 00:15:21,380
Zeronautic Machine Learning nowadays.

390
00:15:21,380 --> 00:15:23,260
Like which startups, which teams,

391
00:15:23,260 --> 00:15:24,700
what are they're focusing on?

392
00:15:25,700 --> 00:15:28,500
So full disclosure, I am an investor in Giza and Modulus

393
00:15:28,500 --> 00:15:31,980
so I don't want to put that out there, just so you know.

394
00:15:31,980 --> 00:15:35,180
So essentially there's different avenues

395
00:15:35,180 --> 00:15:38,980
on what is there to build on within the ZKML domain

396
00:15:38,980 --> 00:15:40,820
in order to make these systems better

397
00:15:40,820 --> 00:15:42,540
or to make this more interesting

398
00:15:42,540 --> 00:15:45,140
or faster and all sorts of different things.

399
00:15:45,140 --> 00:15:48,220
So the three main companies that usually go around

400
00:15:48,220 --> 00:15:50,740
are Giza, Modulus and Ezekio.

401
00:15:50,740 --> 00:15:53,300
On Giza, for example, they're building

402
00:15:53,300 --> 00:15:54,860
on top of the StarkNet ecosystem

403
00:15:54,860 --> 00:15:57,060
which is like one specific scalability solution

404
00:15:57,060 --> 00:15:58,780
in the Ethereum space

405
00:15:58,780 --> 00:16:02,420
and they're implemented a bunch of machine learning models

406
00:16:02,420 --> 00:16:04,580
within this computational environment

407
00:16:04,580 --> 00:16:06,740
that this blockchain had, which is called Cairo.

408
00:16:06,740 --> 00:16:08,220
The computational environment is called Cairo,

409
00:16:08,220 --> 00:16:09,940
the blockchain is called Tarkin

410
00:16:09,940 --> 00:16:11,900
and they're building products, right?

411
00:16:11,900 --> 00:16:13,300
So they're building, for example,

412
00:16:13,300 --> 00:16:14,980
tooling so that financial products

413
00:16:14,980 --> 00:16:16,540
that are deployed on StarkNet

414
00:16:16,540 --> 00:16:19,220
can leverage machine learning within their,

415
00:16:19,220 --> 00:16:21,780
for example, prediction models for financial services

416
00:16:21,780 --> 00:16:25,020
so they can predict where the highest yield is

417
00:16:25,020 --> 00:16:26,740
to routes my money into

418
00:16:26,740 --> 00:16:28,940
so I can get the highest yield on my collateral

419
00:16:28,940 --> 00:16:31,540
or my assets so I can use machine learning off-chain

420
00:16:31,540 --> 00:16:32,580
or machine learning on-chain

421
00:16:32,580 --> 00:16:34,060
within this computational environment,

422
00:16:34,060 --> 00:16:35,780
I can prove it, et cetera, et cetera.

423
00:16:35,780 --> 00:16:36,820
So essentially Giza is building

424
00:16:36,820 --> 00:16:38,180
a lot of the product side of things,

425
00:16:38,180 --> 00:16:40,540
like different abstraction, different SDKs,

426
00:16:40,540 --> 00:16:43,620
different representations of models, on-chain, et cetera.

427
00:16:43,620 --> 00:16:48,260
Modulus is mostly working on the foundational side of things

428
00:16:48,260 --> 00:16:51,420
and by foundation, I mean the primordial science

429
00:16:51,420 --> 00:16:55,140
of doing cryptography and doing engineering.

430
00:16:55,140 --> 00:16:57,580
So they're essentially building their own,

431
00:16:57,580 --> 00:16:59,660
the thing so-called like approving system

432
00:16:59,660 --> 00:17:02,740
which is how do you implement a zero-knowledge scheme?

433
00:17:02,740 --> 00:17:05,020
Like zero-knowledge, it boiled down to mathematics

434
00:17:05,020 --> 00:17:07,940
and working with polynomials and finite fields

435
00:17:07,940 --> 00:17:12,260
and mostly like linear algebra and abstract algebra

436
00:17:12,260 --> 00:17:14,940
and modular arithmetic and bunch of things of this sort.

437
00:17:14,940 --> 00:17:17,020
So essentially they're trying to build

438
00:17:17,020 --> 00:17:19,980
better cryptographic models and better cryptographic systems

439
00:17:19,980 --> 00:17:22,020
in order for zero-knowledge machine learning

440
00:17:22,020 --> 00:17:25,460
to be more efficient within the actual representation of it

441
00:17:25,460 --> 00:17:27,460
in the computing sense, right?

442
00:17:27,460 --> 00:17:29,580
So this is what they're working on.

443
00:17:29,580 --> 00:17:31,580
I'm happy to then after this presentation

444
00:17:31,580 --> 00:17:34,140
or in the FAQ, I'm happy to share more if anyone wants.

445
00:17:34,140 --> 00:17:37,020
Like there's plenty of resources to learn more

446
00:17:37,020 --> 00:17:38,940
and Ithiko is mostly building, tooling

447
00:17:38,940 --> 00:17:41,180
and also some of the products type of things

448
00:17:41,180 --> 00:17:43,580
and infrastructure, a lot of infrastructure as well.

449
00:17:43,580 --> 00:17:46,140
So Ithiko, for example, is building an abstraction layer

450
00:17:46,140 --> 00:17:47,980
that allows developers that are,

451
00:17:47,980 --> 00:17:49,740
they come from the machine learning world.

452
00:17:49,740 --> 00:17:51,620
So people who usually know Python

453
00:17:51,620 --> 00:17:54,180
or right now in this context is just Python.

454
00:17:54,180 --> 00:17:57,020
So people who know Python and know the standard tools

455
00:17:57,020 --> 00:17:58,300
for building machine learning models,

456
00:17:58,300 --> 00:18:00,220
whether it's TensorFlow or Pycorg

457
00:18:00,220 --> 00:18:03,580
or I could learn or any other library for machine learning,

458
00:18:03,580 --> 00:18:05,700
they even have a standardized representation

459
00:18:05,700 --> 00:18:08,260
of a model which can be exported

460
00:18:08,260 --> 00:18:11,340
to this model representation called ONIX, ONIX,

461
00:18:11,340 --> 00:18:13,540
open your network exchange format.

462
00:18:13,540 --> 00:18:15,780
And this format essentially is something

463
00:18:15,780 --> 00:18:18,460
that represents what the model looks like

464
00:18:18,460 --> 00:18:19,700
in the computational sense.

465
00:18:19,700 --> 00:18:21,660
It's a computational graph of different operations

466
00:18:21,660 --> 00:18:23,060
that you need to perform.

467
00:18:23,060 --> 00:18:26,980
And Ithiko allows you to convert whatever you are building

468
00:18:26,980 --> 00:18:30,300
within Python to something that can be ZK proven,

469
00:18:30,300 --> 00:18:33,300
that you can make a proof of in a very easy way.

470
00:18:33,300 --> 00:18:35,740
So you just import a Python library,

471
00:18:35,740 --> 00:18:36,780
you will create your model

472
00:18:36,780 --> 00:18:39,500
and then you just do model that ZK proved

473
00:18:39,500 --> 00:18:41,300
and you are able to ZK prove that

474
00:18:41,300 --> 00:18:43,060
without you as a Python engineer,

475
00:18:43,060 --> 00:18:44,380
as a machine learning engineer,

476
00:18:44,380 --> 00:18:46,500
you don't need to know how ZK works.

477
00:18:46,500 --> 00:18:47,620
You just create a proof of it

478
00:18:47,620 --> 00:18:50,980
because Ithiko has built a tool that helped convert

479
00:18:50,980 --> 00:18:52,660
the way that you work with ML

480
00:18:52,660 --> 00:18:54,620
to something that cryptography can,

481
00:18:54,620 --> 00:18:57,060
the cryptography tooling can create proofs of.

482
00:18:57,060 --> 00:18:58,820
And of course, academia, academia

483
00:18:58,820 --> 00:19:01,100
has been a crucial element of all of this.

484
00:19:01,140 --> 00:19:02,700
There's lots of cryptography,

485
00:19:02,700 --> 00:19:05,860
new cryptography coming out every week almost.

486
00:19:05,860 --> 00:19:07,580
There's new proving systems,

487
00:19:07,580 --> 00:19:09,860
there's new types of final field arithmetic,

488
00:19:09,860 --> 00:19:12,540
there's new discoveries in different field.

489
00:19:12,540 --> 00:19:13,740
There's different optimizations

490
00:19:13,740 --> 00:19:16,500
like computing optimization from representation,

491
00:19:16,500 --> 00:19:18,500
better models on the machine learning side.

492
00:19:18,500 --> 00:19:19,740
There's also improvements

493
00:19:19,740 --> 00:19:22,020
and since usually ZK ML,

494
00:19:22,020 --> 00:19:24,540
you need both things to become more performant.

495
00:19:24,540 --> 00:19:26,460
If academia comes up with better models

496
00:19:26,460 --> 00:19:28,820
and better quantization schemes and whatnot,

497
00:19:28,820 --> 00:19:31,540
all of these improvements, compounds, right?

498
00:19:31,540 --> 00:19:33,180
It's usually the worst of both,

499
00:19:33,180 --> 00:19:36,300
the thing that becomes the worst for the aggregate.

500
00:19:36,300 --> 00:19:38,300
So the worst of KML, or sorry,

501
00:19:38,300 --> 00:19:39,940
the worst of ZK and the worst of ML

502
00:19:39,940 --> 00:19:43,060
become the worst of ZK ML, like the bottlenecks.

503
00:19:43,060 --> 00:19:45,860
So academia is working a lot of the foundational bottlenecks

504
00:19:45,860 --> 00:19:47,740
when it comes to cryptography

505
00:19:47,740 --> 00:19:49,860
and all these other things that I mentioned.

506
00:19:51,060 --> 00:19:52,940
So some of the use cases,

507
00:19:52,940 --> 00:19:54,500
I do wanna talk about use cases

508
00:19:54,500 --> 00:19:55,940
because I've seen a lot of people

509
00:19:55,940 --> 00:19:59,020
who are really deeply interested in the technology,

510
00:19:59,020 --> 00:20:01,060
but the only way that I've seen technology

511
00:20:01,060 --> 00:20:04,580
actually progress forward is if there's funding

512
00:20:04,580 --> 00:20:07,180
and people actually are interested and excited about it.

513
00:20:07,180 --> 00:20:09,180
For example, in the case of zero knowledge cryptography,

514
00:20:09,180 --> 00:20:10,660
because I mostly spend most of my time

515
00:20:10,660 --> 00:20:12,100
in the blockchain space,

516
00:20:12,100 --> 00:20:15,020
zero knowledge cryptography has become really popular

517
00:20:15,020 --> 00:20:16,380
in the last two to three years,

518
00:20:16,380 --> 00:20:19,220
mostly because there's been products that actually use it,

519
00:20:19,220 --> 00:20:20,740
whether it's scalability solutions,

520
00:20:20,740 --> 00:20:22,660
whether it's privacy solutions,

521
00:20:22,660 --> 00:20:24,700
whether it's digital identity solutions,

522
00:20:24,740 --> 00:20:26,900
there's been product market fit for this technology

523
00:20:26,900 --> 00:20:28,820
and so new companies have been created

524
00:20:28,820 --> 00:20:31,100
and a lot of capital has been poured in

525
00:20:31,100 --> 00:20:33,780
and this capital was reinvested

526
00:20:33,780 --> 00:20:35,940
into the actual development of better cryptography,

527
00:20:35,940 --> 00:20:38,300
better tooling, better hardware,

528
00:20:38,300 --> 00:20:41,100
and also there's a lot of network effects, right?

529
00:20:41,100 --> 00:20:43,300
So if there's lots of people using something,

530
00:20:43,300 --> 00:20:45,100
other vendors like hardware vendors

531
00:20:45,100 --> 00:20:47,300
might want to create hardware for these people,

532
00:20:47,300 --> 00:20:49,620
so it will even speed it up even further.

533
00:20:49,620 --> 00:20:51,900
So I do believe that, for example,

534
00:20:51,900 --> 00:20:54,060
ZKML needs a lot of product market fit

535
00:20:54,060 --> 00:20:56,860
or products or catalysts and use cases,

536
00:20:56,860 --> 00:20:59,340
which would improve the state of the art

537
00:20:59,340 --> 00:21:01,460
just by the fact that there's many people looking at it,

538
00:21:01,460 --> 00:21:04,380
there's a lot of mind share, there's high excitement.

539
00:21:04,380 --> 00:21:06,420
So of course there's negative parts to this as well,

540
00:21:06,420 --> 00:21:08,620
but mostly I think it's good.

541
00:21:08,620 --> 00:21:11,500
So some of the use cases that I've seen around,

542
00:21:11,500 --> 00:21:12,860
so I personally work at WorldQuake

543
00:21:12,860 --> 00:21:16,220
and that's like the way that I got exposed to it.

544
00:21:16,220 --> 00:21:19,660
I'll explain our specific youth case towards the end.

545
00:21:19,660 --> 00:21:21,420
So provable inference is one,

546
00:21:21,420 --> 00:21:25,580
so I mentioned earlier on that I do not know

547
00:21:25,580 --> 00:21:26,780
if I'm using chat GPT,

548
00:21:26,780 --> 00:21:29,060
that someone is actually serving me

549
00:21:29,060 --> 00:21:30,900
the model that they claim they are.

550
00:21:30,900 --> 00:21:32,780
So provable inference is just this concept

551
00:21:32,780 --> 00:21:36,340
where I can know that whomever who used a model

552
00:21:36,340 --> 00:21:38,900
to infer some output, I know where it came from.

553
00:21:38,900 --> 00:21:40,100
I know which model it came from.

554
00:21:40,100 --> 00:21:41,300
If it's public, of course,

555
00:21:41,300 --> 00:21:44,300
the APIs can choose to keep the model private,

556
00:21:44,300 --> 00:21:46,460
but at least they can, for example, commit to it.

557
00:21:46,460 --> 00:21:47,940
Something that I can do if, let's say,

558
00:21:47,940 --> 00:21:49,260
GPT-Force Quilt Force, right?

559
00:21:49,260 --> 00:21:50,700
Open source is not open source.

560
00:21:50,740 --> 00:21:53,860
OpenAI did not open source GPT-Force, as of now.

561
00:21:53,860 --> 00:21:56,380
And so if, for example,

562
00:21:56,380 --> 00:21:59,380
I cannot know that someone used GPT-Force

563
00:21:59,380 --> 00:22:01,060
because I don't have the weights, right?

564
00:22:01,060 --> 00:22:03,380
It's not a public thing.

565
00:22:03,380 --> 00:22:06,020
But something that OpenAI could do or anyone else

566
00:22:06,020 --> 00:22:07,700
with a private model could do

567
00:22:07,700 --> 00:22:11,140
is that they can commit to a specific model,

568
00:22:11,140 --> 00:22:12,380
let's say a hash.

569
00:22:12,380 --> 00:22:15,100
And for example, I know that for the entire user base,

570
00:22:15,100 --> 00:22:16,660
they're using the same model.

571
00:22:16,660 --> 00:22:18,220
So they cannot fool any single user

572
00:22:18,220 --> 00:22:20,300
that they're using specific different models

573
00:22:20,300 --> 00:22:21,460
for anyone else.

574
00:22:21,460 --> 00:22:23,180
At least they can commit to it

575
00:22:23,180 --> 00:22:25,620
with a cryptographic hash, so I can just hash.

576
00:22:25,620 --> 00:22:27,420
I know that there is one deterministic output

577
00:22:27,420 --> 00:22:28,260
for this model.

578
00:22:28,260 --> 00:22:30,460
And I know every single user knows

579
00:22:30,460 --> 00:22:31,580
that they're using the same model

580
00:22:31,580 --> 00:22:33,340
because within the zero-knowledge group,

581
00:22:33,340 --> 00:22:36,700
they have a commitment to some specific set of weights,

582
00:22:36,700 --> 00:22:38,020
but they do not reveal the weight.

583
00:22:38,020 --> 00:22:39,060
They're just committed.

584
00:22:39,060 --> 00:22:41,820
And maybe later, they open source the model,

585
00:22:41,820 --> 00:22:43,020
they can reveal the weights,

586
00:22:43,020 --> 00:22:44,300
and you can see that the commitment

587
00:22:44,300 --> 00:22:45,460
does indeed match the weight.

588
00:22:45,460 --> 00:22:49,500
So you actually learn that you did indeed learn about that.

589
00:22:49,500 --> 00:22:52,460
That they did actually use the model they claimed they were.

590
00:22:52,460 --> 00:22:53,540
In this case, GPT-4,

591
00:22:53,540 --> 00:22:55,900
they managed to open source the weights.

592
00:22:55,900 --> 00:22:57,300
So that's provable inference.

593
00:22:57,300 --> 00:22:58,580
It can be used for APIs.

594
00:22:58,580 --> 00:22:59,780
So I mentioned like chat GPT,

595
00:22:59,780 --> 00:23:01,700
but there's many others, like video games.

596
00:23:01,700 --> 00:23:03,340
If I'm playing an on-chain game

597
00:23:03,340 --> 00:23:04,820
and there's some form of ML,

598
00:23:04,820 --> 00:23:06,540
how do I know that the game is not cheating?

599
00:23:06,540 --> 00:23:09,300
How do I know that I have fair rules on there?

600
00:23:09,300 --> 00:23:11,220
The second one is bringing AI on chain.

601
00:23:11,220 --> 00:23:13,180
So there's lots of smart contracts,

602
00:23:13,180 --> 00:23:15,380
lots of applications that people are building

603
00:23:15,380 --> 00:23:16,940
within the blockchain domain.

604
00:23:16,940 --> 00:23:18,820
And within the blockchain domain right now,

605
00:23:18,820 --> 00:23:21,020
it's very limited in terms of things it can do.

606
00:23:21,020 --> 00:23:23,860
And machine learning can provide lots of cool solutions

607
00:23:23,860 --> 00:23:25,860
to a lot of different problems, right?

608
00:23:25,860 --> 00:23:27,980
At the end of the day, machine learning is able to provide

609
00:23:27,980 --> 00:23:30,980
good enough approximations to problems that people have.

610
00:23:30,980 --> 00:23:32,860
And so if we're able to bring that on chain,

611
00:23:32,860 --> 00:23:35,220
we might be able to bring some interesting

612
00:23:35,220 --> 00:23:36,620
opportunity to the table.

613
00:23:36,620 --> 00:23:38,340
I mentioned the financial ones,

614
00:23:38,340 --> 00:23:41,540
where for example, I have a yield protocol on chain

615
00:23:41,540 --> 00:23:44,340
where I deposit assets to this protocol

616
00:23:44,340 --> 00:23:46,660
and it tries to optimize the yield

617
00:23:46,660 --> 00:23:48,140
that I get on those assets.

618
00:23:48,140 --> 00:23:50,300
But it can, it has to use a strategy.

619
00:23:50,300 --> 00:23:53,220
Usually these strategies are called source and hidden,

620
00:23:53,220 --> 00:23:55,700
but at least I can commit to a strategy.

621
00:23:55,700 --> 00:23:57,700
And this strategy can now leverage machine learning

622
00:23:57,700 --> 00:23:59,500
and I can take proof to the protocol

623
00:23:59,500 --> 00:24:02,420
that we're using a machine learning strategy fairly

624
00:24:02,420 --> 00:24:04,300
and we're not updating the weights.

625
00:24:04,300 --> 00:24:05,500
And we can also, for example,

626
00:24:05,500 --> 00:24:07,380
prove that it was trained on some historical data

627
00:24:07,380 --> 00:24:08,780
with some accuracy, right?

628
00:24:08,780 --> 00:24:11,380
I can make a proof that my model is accurate

629
00:24:11,380 --> 00:24:13,860
on some historical data in terms of yield routing

630
00:24:13,860 --> 00:24:15,660
with some accuracy and it's routed

631
00:24:15,660 --> 00:24:19,180
the most performant way, for example.

632
00:24:19,180 --> 00:24:22,020
There's also another one which is agents or intents

633
00:24:22,020 --> 00:24:23,060
in the context of blockchain.

634
00:24:23,060 --> 00:24:26,580
So agents is a word that comes from the ML lingo,

635
00:24:26,580 --> 00:24:29,380
which is like a program that has the ability

636
00:24:29,380 --> 00:24:30,860
to do actions on their own, right?

637
00:24:30,860 --> 00:24:32,700
They're a player, some system,

638
00:24:32,700 --> 00:24:34,740
like game theoretical system in this case.

639
00:24:34,740 --> 00:24:37,580
So if we have some system, let's say that, I don't know,

640
00:24:37,580 --> 00:24:39,660
like we have a program and we allow

641
00:24:39,660 --> 00:24:41,980
this machine learning algorithm, let's say robotics.

642
00:24:41,980 --> 00:24:45,300
Robotic agents are, is a good analogy, right?

643
00:24:45,340 --> 00:24:47,820
So I have a robot and the robot is able

644
00:24:47,820 --> 00:24:49,100
to interact with the real world

645
00:24:49,100 --> 00:24:51,860
because it has limbs, it has different tools

646
00:24:51,860 --> 00:24:53,180
like cameras, et cetera.

647
00:24:53,180 --> 00:24:54,700
And it's able to interact with the real world.

648
00:24:54,700 --> 00:24:56,420
The robot in this case is an agent, right?

649
00:24:56,420 --> 00:24:58,700
It's a program which is able to perform actions

650
00:24:58,700 --> 00:24:59,540
in the real world.

651
00:24:59,540 --> 00:25:01,140
It doesn't have to be a real world agent.

652
00:25:01,140 --> 00:25:02,220
It can be a digital agent.

653
00:25:02,220 --> 00:25:03,500
It can interact with a website.

654
00:25:03,500 --> 00:25:04,660
It can browse the web.

655
00:25:04,660 --> 00:25:08,180
It can watch a video and give me some information about it.

656
00:25:08,180 --> 00:25:10,700
But essentially on-chain agent could, for example,

657
00:25:10,700 --> 00:25:12,340
interact with a blockchain

658
00:25:12,340 --> 00:25:13,980
if they have maybe some knowledge, right?

659
00:25:13,980 --> 00:25:16,020
So if it's a smart agent, it sees that,

660
00:25:16,020 --> 00:25:17,460
okay, something happened here.

661
00:25:17,460 --> 00:25:19,860
So maybe I see that there's a liquidation happening.

662
00:25:19,860 --> 00:25:22,380
So let me do this, let me buy this, let me sell that.

663
00:25:22,380 --> 00:25:24,860
There's different agents that can learn based on information

664
00:25:24,860 --> 00:25:27,540
and if they have a set of steps that they can do,

665
00:25:27,540 --> 00:25:29,860
they can maybe try and optimize for some goal

666
00:25:29,860 --> 00:25:31,860
and then they become agents in the system.

667
00:25:31,860 --> 00:25:34,740
Blockchain people like to call this intense, yeah?

668
00:25:34,740 --> 00:25:37,820
And another one is attestations, for example.

669
00:25:37,820 --> 00:25:40,660
So I can make attestations about things, right?

670
00:25:40,660 --> 00:25:43,340
I can prove to a smart contract that I'm over 18.

671
00:25:43,380 --> 00:25:47,140
I can prove that all sorts of different things, right?

672
00:25:47,140 --> 00:25:49,540
Essentially, I'm just able to use machine learning off-chain

673
00:25:49,540 --> 00:25:51,900
and I can prove that and bring it on-chain.

674
00:25:51,900 --> 00:25:53,420
Private and machine learning cruise.

675
00:25:53,420 --> 00:25:55,460
So this one is a cool one.

676
00:25:55,460 --> 00:25:57,300
So for example, in the context of medicine,

677
00:25:57,300 --> 00:26:01,060
let's say that there's a cancer diagnosis model

678
00:26:01,060 --> 00:26:04,620
and I as the patient, I do not wanna reveal to anyone

679
00:26:04,620 --> 00:26:07,580
like my personal health records.

680
00:26:07,580 --> 00:26:08,980
But for example, there's a doctor

681
00:26:08,980 --> 00:26:10,660
or some health institution

682
00:26:10,660 --> 00:26:14,100
which signs some form of report

683
00:26:14,100 --> 00:26:15,500
or some form of certificates

684
00:26:15,500 --> 00:26:18,420
to some personal health records or data.

685
00:26:18,420 --> 00:26:20,580
And then there's a machine learning model

686
00:26:20,580 --> 00:26:23,420
which uses this data to essentially evaluate it

687
00:26:23,420 --> 00:26:25,940
and tells you whether you're likely to have cancer

688
00:26:25,940 --> 00:26:29,100
or whether you have cancer and with what's uncertainty.

689
00:26:29,100 --> 00:26:30,940
So something that you can hear

690
00:26:30,940 --> 00:26:32,660
is that if you want to prove to, for example,

691
00:26:32,660 --> 00:26:36,100
let's say that an insurance or a payout

692
00:26:36,100 --> 00:26:38,300
had a condition that you've been insured against

693
00:26:38,300 --> 00:26:39,980
or something like that,

694
00:26:39,980 --> 00:26:41,420
you'd be able to prove to them

695
00:26:41,420 --> 00:26:44,060
that there's some health institution

696
00:26:44,060 --> 00:26:46,900
or a specific health institution if you want

697
00:26:46,900 --> 00:26:50,340
that has concluded that I am indeed this

698
00:26:50,340 --> 00:26:52,620
or have been diagnosed with a specific thing

699
00:26:52,620 --> 00:26:56,180
without revealing the model, without revealing the weight,

700
00:26:56,180 --> 00:26:58,300
but you at least know that there's some specific thing

701
00:26:58,300 --> 00:27:00,180
that you can make a proof about.

702
00:27:00,180 --> 00:27:02,500
The possibilities here are early big

703
00:27:02,500 --> 00:27:05,620
in the sense that there is generally programmable.

704
00:27:05,620 --> 00:27:07,900
So this is like just one concrete example,

705
00:27:07,900 --> 00:27:11,500
but people can essentially make proofs about anything,

706
00:27:11,500 --> 00:27:14,060
any data that they have and computations that they did

707
00:27:14,060 --> 00:27:16,580
when they're machine learning base or not

708
00:27:16,580 --> 00:27:18,540
without revealing the data itself, right?

709
00:27:18,540 --> 00:27:20,260
The only person who learns about the data

710
00:27:20,260 --> 00:27:23,340
in the context of ZK is the person making the proof.

711
00:27:23,340 --> 00:27:26,420
I mentioned earlier that this property called completeness.

712
00:27:26,420 --> 00:27:28,260
So in order to make a valid proof,

713
00:27:28,260 --> 00:27:29,660
I do need to have the data.

714
00:27:29,660 --> 00:27:32,580
So the problem is that there's always a prover,

715
00:27:32,580 --> 00:27:33,660
always learns the data,

716
00:27:33,660 --> 00:27:35,940
but if the prover is controlled by myself,

717
00:27:35,940 --> 00:27:38,660
then only it's the same thing as me learning data.

718
00:27:38,660 --> 00:27:40,620
So it's something that is a worthy trade-off.

719
00:27:40,620 --> 00:27:42,700
So if I'm making a proof on my own computer,

720
00:27:42,700 --> 00:27:43,540
that makes sense.

721
00:27:43,540 --> 00:27:45,220
And I can prove to anyone else anything

722
00:27:45,220 --> 00:27:46,420
without revealing my data.

723
00:27:46,420 --> 00:27:48,780
But if I am, for example, delegating it to a server,

724
00:27:48,780 --> 00:27:50,620
the server doesn't need to learn my information,

725
00:27:50,620 --> 00:27:52,500
so I need to be careful.

726
00:27:52,500 --> 00:27:54,180
And digital identity.

727
00:27:54,180 --> 00:27:56,140
So I do want to explain very briefly,

728
00:27:56,140 --> 00:27:58,860
like how did we come to this at WorldCoding?

729
00:27:58,860 --> 00:28:01,540
So we have this hardware device, it's called an org.

730
00:28:01,540 --> 00:28:02,940
I do have it with me.

731
00:28:02,940 --> 00:28:06,060
Maybe if you guys want, I can just go grab it.

732
00:28:06,060 --> 00:28:08,620
And one second in the FAQs, I can show it.

733
00:28:08,620 --> 00:28:12,140
But essentially the WorldCoding org is a piece of hardware

734
00:28:12,140 --> 00:28:13,820
that verifies two things.

735
00:28:13,820 --> 00:28:16,460
It proves that there's a real person

736
00:28:16,460 --> 00:28:18,260
in front of this hardware device.

737
00:28:18,260 --> 00:28:22,980
It does this bunch of phenomenally detection like methods,

738
00:28:22,980 --> 00:28:26,900
and some other like statistical-based methods,

739
00:28:26,900 --> 00:28:29,580
some sensors that it has like infrared sensors,

740
00:28:29,580 --> 00:28:31,300
and it has like field of depth sensors,

741
00:28:31,340 --> 00:28:33,820
it has high-resolution cameras, et cetera.

742
00:28:33,820 --> 00:28:35,660
And it's able to determine that there's a real person

743
00:28:35,660 --> 00:28:37,500
in front of the hardware device, the org,

744
00:28:37,500 --> 00:28:39,940
with like a shiny ball, I'll show it in a bit.

745
00:28:39,940 --> 00:28:43,380
And it can also prove the person in front of it is unique.

746
00:28:43,380 --> 00:28:45,740
And the way that it does that is that it takes

747
00:28:45,740 --> 00:28:48,580
a high-resolution image of the person's IRC's,

748
00:28:48,580 --> 00:28:51,620
and it's able to compute a unique representation of them

749
00:28:51,620 --> 00:28:53,020
called an IRS code.

750
00:28:53,020 --> 00:28:55,060
And this IRS code, the good thing about it,

751
00:28:55,060 --> 00:28:56,500
is that it's not deemed personally

752
00:28:56,500 --> 00:28:59,380
that if I put information, it's just the representation

753
00:28:59,380 --> 00:29:03,500
of the uniqueness or of the randomness of a person's IRS,

754
00:29:03,500 --> 00:29:06,180
and I can use that to measure how unique they are.

755
00:29:06,180 --> 00:29:08,580
And if the distance between two different IRS codes

756
00:29:08,580 --> 00:29:11,780
is big enough, I can prove that this user is unique.

757
00:29:11,780 --> 00:29:13,860
And then once I prove that the person is unique,

758
00:29:13,860 --> 00:29:17,100
I'm able to essentially put them in a set of verified users.

759
00:29:17,100 --> 00:29:20,180
And then what we do is we have a protocol called WorldID,

760
00:29:20,180 --> 00:29:22,660
which allows you to prove that you're a member

761
00:29:22,660 --> 00:29:24,700
of this set of verified users

762
00:29:24,700 --> 00:29:26,660
without revealing which member you are,

763
00:29:26,660 --> 00:29:28,180
using zoological photography as well,

764
00:29:28,180 --> 00:29:31,700
but not ZKML, just traditional zero-knowledge cryptography.

765
00:29:31,700 --> 00:29:34,340
You're able to prove that I am a unique verified human being

766
00:29:34,340 --> 00:29:35,980
without revealing who you are,

767
00:29:35,980 --> 00:29:38,460
and the data that we collect, which is just this IRS code,

768
00:29:38,460 --> 00:29:40,220
is not personally data-fibre information.

769
00:29:40,220 --> 00:29:43,780
We don't collect the raw biometric images, which is cool,

770
00:29:43,780 --> 00:29:46,460
because you're able to essentially leverage modern cryptography,

771
00:29:46,460 --> 00:29:49,900
modern biometric literature, and the modern tools,

772
00:29:49,900 --> 00:29:52,220
like modern hardware like GPUs and everything.

773
00:29:52,220 --> 00:29:53,540
Everything happens client-side,

774
00:29:53,540 --> 00:29:56,060
like within this actual hardware device, right?

775
00:29:56,060 --> 00:29:58,660
So the hardware device does this computation,

776
00:29:58,660 --> 00:30:00,580
nothing leaves the actual orb,

777
00:30:00,580 --> 00:30:04,380
and then the orb deletes everything within its secure enclave

778
00:30:04,380 --> 00:30:06,540
and computational environment.

779
00:30:06,540 --> 00:30:09,060
Within this model of how work can work,

780
00:30:09,060 --> 00:30:12,260
very simplistic model, there's one specific problem,

781
00:30:12,260 --> 00:30:14,460
which in our biometrics pipeline,

782
00:30:14,460 --> 00:30:18,620
if you change the pipeline in any significant way,

783
00:30:18,620 --> 00:30:21,540
you change the outputs of this uniqueness representation,

784
00:30:21,540 --> 00:30:24,500
you change the output space of the IRS codes,

785
00:30:24,500 --> 00:30:26,100
you can think of them as vectors, right?

786
00:30:26,100 --> 00:30:28,700
So you essentially take this vector space,

787
00:30:28,700 --> 00:30:30,380
and you convert it to a different one.

788
00:30:30,380 --> 00:30:33,660
So the same user will have a different representation

789
00:30:33,660 --> 00:30:34,940
in this new space,

790
00:30:34,940 --> 00:30:38,260
therefore you will not be able to measure uniqueness anymore.

791
00:30:38,260 --> 00:30:39,980
So if you ever update the model,

792
00:30:39,980 --> 00:30:42,020
you have to re-sign up all users.

793
00:30:42,020 --> 00:30:44,100
And since you have this physical hardware device

794
00:30:44,100 --> 00:30:45,380
that people have to go to,

795
00:30:45,380 --> 00:30:47,660
it means that all the users that have signed up to date

796
00:30:47,660 --> 00:30:51,660
to WorldID have to go in person again to this hardware device

797
00:30:51,660 --> 00:30:52,940
and get re-signed up.

798
00:30:52,940 --> 00:30:54,140
And this is terrible,

799
00:30:54,140 --> 00:30:56,660
because it's already been really hard enough

800
00:30:56,660 --> 00:30:59,060
for us to get 5 million plus users

801
00:30:59,060 --> 00:31:01,980
and to have to force our users to re-sign up

802
00:31:01,980 --> 00:31:04,380
every single time that we update the biometrics pipeline,

803
00:31:04,380 --> 00:31:06,220
it would be really bad.

804
00:31:06,220 --> 00:31:08,420
And it has like really terrible user experience.

805
00:31:08,420 --> 00:31:10,660
And so this is where one of my coworkers,

806
00:31:10,660 --> 00:31:13,300
his name is Remco, at the WorldCon Foundation,

807
00:31:13,300 --> 00:31:17,740
he came across with a solution or an idea,

808
00:31:17,740 --> 00:31:22,140
which was what if users self-custody their own biometrics,

809
00:31:22,140 --> 00:31:23,660
meaning that the orb,

810
00:31:23,660 --> 00:31:26,020
which has essentially a secure enclave

811
00:31:26,020 --> 00:31:28,020
and a trusted execution environment.

812
00:31:28,020 --> 00:31:30,740
So essentially these two pieces of chips

813
00:31:30,740 --> 00:31:33,540
or these two chips allow you to sign things.

814
00:31:33,540 --> 00:31:35,300
So I'm able to cryptograph a big sign,

815
00:31:35,300 --> 00:31:37,380
something that the orb sees.

816
00:31:37,380 --> 00:31:39,020
So whenever the user gets verified

817
00:31:39,020 --> 00:31:41,340
that they're a real and unique person,

818
00:31:41,340 --> 00:31:43,260
the orb can sign their raw biometric,

819
00:31:43,260 --> 00:31:46,420
which it has in its memory for a given lifetime,

820
00:31:46,420 --> 00:31:48,460
and it can give it to the user,

821
00:31:48,460 --> 00:31:51,660
and the user can store their own biometrics

822
00:31:51,660 --> 00:31:54,780
in their phone and they can encrypt them, of course,

823
00:31:54,780 --> 00:31:56,460
store them safely in an encrypted fashion

824
00:31:56,460 --> 00:31:59,580
on their own phone or cloud or whatever they prefer.

825
00:31:59,580 --> 00:32:02,540
And they would be able to then have a signature

826
00:32:02,540 --> 00:32:04,900
from the orb on the actual biometric, right?

827
00:32:04,900 --> 00:32:08,620
You know that this image was seen at one point by the orb

828
00:32:08,620 --> 00:32:10,860
and it said that this is a unique human being

829
00:32:10,860 --> 00:32:12,180
and this is a real human being,

830
00:32:12,180 --> 00:32:14,100
most importantly is the real part.

831
00:32:14,100 --> 00:32:17,220
Whenever we want to update the model,

832
00:32:17,220 --> 00:32:19,380
what the user could do is they would be able

833
00:32:19,420 --> 00:32:22,140
to download the new model, the weights of the model,

834
00:32:22,140 --> 00:32:25,100
and they seek the approving library for that specific model

835
00:32:25,100 --> 00:32:26,500
and they would be able to create a group

836
00:32:26,500 --> 00:32:31,060
that created this iris code within a zero-knowledge environment.

837
00:32:31,060 --> 00:32:33,140
So they would be able to create a zero-knowledge proof

838
00:32:33,140 --> 00:32:35,100
that they've created a valid iris code

839
00:32:35,100 --> 00:32:38,220
from an input image, which was attested to by the orb.

840
00:32:38,220 --> 00:32:41,820
So essentially the pipeline of trust here is not broke, right?

841
00:32:41,820 --> 00:32:44,020
I know that I've created an iris code

842
00:32:44,020 --> 00:32:45,100
from an original biometric,

843
00:32:45,100 --> 00:32:47,180
which was verified by the orb to be unique.

844
00:32:47,220 --> 00:32:50,740
And with this, I'm able to permissionlessly

845
00:32:50,740 --> 00:32:52,420
or out of my own accord,

846
00:32:52,420 --> 00:32:55,020
I'm able to permissionlessly insert myself

847
00:32:55,020 --> 00:32:56,900
into the set of verified users

848
00:32:56,900 --> 00:32:58,660
without having to go to the orb again

849
00:32:58,660 --> 00:33:01,100
because I have the entire set of steps that I need

850
00:33:01,100 --> 00:33:03,740
in order to prove to the world ID protocol

851
00:33:03,740 --> 00:33:06,260
that I'm a unique user without revealing who I am again.

852
00:33:06,260 --> 00:33:09,300
I just proved to you that, hey, the orb saw me at one point in time,

853
00:33:09,300 --> 00:33:12,820
the orb did indeed sign this my image, I store my images,

854
00:33:12,820 --> 00:33:13,660
and then I make a proof

855
00:33:13,660 --> 00:33:16,180
that I've created this derived representation of uniqueness

856
00:33:16,180 --> 00:33:18,020
for my biometrics,

857
00:33:18,020 --> 00:33:19,660
and I can prove to them I'm a unique human

858
00:33:19,660 --> 00:33:21,940
in this new representation and this new model

859
00:33:21,940 --> 00:33:24,020
without revealing who I am again, right?

860
00:33:24,020 --> 00:33:26,060
So this is like perfect things,

861
00:33:26,060 --> 00:33:27,500
like a perfect solution for us.

862
00:33:27,500 --> 00:33:32,500
It's actually quite crazy that this problem didn't exist,

863
00:33:33,500 --> 00:33:37,260
at least that's what I felt when I first covered it through Remco.

864
00:33:37,260 --> 00:33:38,900
And so right now, for example,

865
00:33:38,900 --> 00:33:40,300
we're working with one of the companies

866
00:33:40,300 --> 00:33:41,380
which I mentioned earlier,

867
00:33:41,380 --> 00:33:44,940
Modulus to essentially do this client-side

868
00:33:44,940 --> 00:33:46,860
zero-knowledge machine learning proving

869
00:33:46,860 --> 00:33:48,580
inside of a user's phone, right?

870
00:33:48,580 --> 00:33:50,580
So that people can self-cassellate the biometrics

871
00:33:50,580 --> 00:33:52,460
and permissionlessly insert themselves.

872
00:33:52,460 --> 00:33:53,660
It's like very early stages,

873
00:33:53,660 --> 00:33:55,140
R&D is not yet in production,

874
00:33:55,140 --> 00:33:57,260
but there's been a lot of good progress here.

875
00:33:57,260 --> 00:33:59,500
And two years ago, it seemed like sci-fi,

876
00:33:59,500 --> 00:34:02,020
now there's already like concrete proof concepts

877
00:34:02,020 --> 00:34:04,860
and implementation and there's benchmarks

878
00:34:04,860 --> 00:34:06,620
and things that are improving.

879
00:34:06,620 --> 00:34:09,500
But yeah, this is like one of the things that I saw.

880
00:34:10,980 --> 00:34:12,580
One last thing that I do want to mention

881
00:34:12,580 --> 00:34:15,380
before I leave you to ask me questions

882
00:34:15,380 --> 00:34:17,940
and for me to go grab my orb as well

883
00:34:17,940 --> 00:34:19,580
is technical bottlenecks.

884
00:34:19,580 --> 00:34:20,980
Zero-knowledge machine learning, right?

885
00:34:20,980 --> 00:34:22,180
We've seen some use cases,

886
00:34:22,180 --> 00:34:24,220
we've seen what people are working on,

887
00:34:24,220 --> 00:34:25,580
what people are doing, what it is,

888
00:34:25,580 --> 00:34:27,380
some of the things that we are doing,

889
00:34:27,380 --> 00:34:28,860
but where do we go now, right?

890
00:34:28,860 --> 00:34:30,860
If you're someone who is interested in this topic,

891
00:34:30,860 --> 00:34:32,660
where could you contribute if you want to,

892
00:34:32,660 --> 00:34:34,020
if you end up learning more?

893
00:34:34,020 --> 00:34:35,660
How do you contribute to these?

894
00:34:36,540 --> 00:34:38,380
Or what are the problems that are hard

895
00:34:38,380 --> 00:34:40,940
and that would help us improve in the front?

896
00:34:40,940 --> 00:34:44,060
So one is better cryptography, right?

897
00:34:44,060 --> 00:34:45,980
Because it's better ZK.

898
00:34:45,980 --> 00:34:48,620
As I mentioned, the worst in ZK and the worst of ML

899
00:34:48,620 --> 00:34:49,980
create a joint bottleneck.

900
00:34:49,980 --> 00:34:52,420
So if you improve ZK or if you improve ML,

901
00:34:52,420 --> 00:34:53,900
you improve the KML.

902
00:34:53,900 --> 00:34:55,980
But there is also an intersection

903
00:34:55,980 --> 00:34:58,380
where if you just focus on the ZK parts

904
00:34:58,380 --> 00:34:59,420
that would make ML better

905
00:34:59,420 --> 00:35:01,700
and on the ML parts that would make ZK better

906
00:35:01,700 --> 00:35:05,100
or simpler, that's the most focused effort

907
00:35:05,100 --> 00:35:08,260
that you can make to essentially improve everything.

908
00:35:08,260 --> 00:35:09,860
The one is better cryptography.

909
00:35:09,860 --> 00:35:11,340
So remainder, for example,

910
00:35:11,340 --> 00:35:12,700
the thing that I mentioned here,

911
00:35:12,700 --> 00:35:14,220
remainder is a proving library

912
00:35:14,220 --> 00:35:17,620
that is built by modulus labs or modulus,

913
00:35:17,620 --> 00:35:20,740
which essentially uses a type of cryptography

914
00:35:20,740 --> 00:35:22,980
which better models the structured nature

915
00:35:22,980 --> 00:35:24,300
of machine learning computing.

916
00:35:24,300 --> 00:35:25,660
Where like machine learning usually have

917
00:35:25,660 --> 00:35:27,340
matrix multiplication.

918
00:35:27,340 --> 00:35:29,220
They have some non-linearities.

919
00:35:29,220 --> 00:35:32,060
So like functions that are non-linear, in this case,

920
00:35:32,060 --> 00:35:33,620
there's like activation functions

921
00:35:33,620 --> 00:35:35,060
or like a good example of this.

922
00:35:35,060 --> 00:35:37,300
So there's things like ReLU,

923
00:35:37,300 --> 00:35:38,860
which is one of the most popular ones,

924
00:35:39,420 --> 00:35:41,820
defined linear unit, something like that.

925
00:35:41,820 --> 00:35:43,740
Like tanh, there's a bunch of activation functions,

926
00:35:43,740 --> 00:35:44,980
non-linear function.

927
00:35:44,980 --> 00:35:47,980
So they built a cryptographic system

928
00:35:47,980 --> 00:35:52,060
which is able to represent the structured computation

929
00:35:52,060 --> 00:35:54,420
in a much more efficient way.

930
00:35:54,420 --> 00:35:58,220
So when it comes to proving these structured computations,

931
00:35:58,220 --> 00:36:00,420
it takes a lot less computational power to do so

932
00:36:00,420 --> 00:36:03,260
because the representation is much more succinct

933
00:36:03,260 --> 00:36:04,620
and much more efficient.

934
00:36:04,620 --> 00:36:06,300
And so it makes it a lot faster

935
00:36:06,300 --> 00:36:07,660
and a lot more performant

936
00:36:07,660 --> 00:36:09,700
and less computationally intensive.

937
00:36:09,700 --> 00:36:12,260
So this would potentially make it feasible

938
00:36:12,260 --> 00:36:14,620
to run a DK machine learning prover

939
00:36:14,620 --> 00:36:17,380
on a personal phone, for example.

940
00:36:17,380 --> 00:36:18,860
Another one is better hardware.

941
00:36:18,860 --> 00:36:21,420
So hardware and specialized hardware

942
00:36:21,420 --> 00:36:24,260
is one of the things that modern science

943
00:36:24,260 --> 00:36:25,860
has benefited from most.

944
00:36:25,860 --> 00:36:28,100
We've seen the transistor consistently shrinking

945
00:36:28,100 --> 00:36:28,940
and shrinking.

946
00:36:28,940 --> 00:36:30,620
We fit more transistors on a chip,

947
00:36:30,620 --> 00:36:32,580
almost like 2X every 18 months, right?

948
00:36:32,580 --> 00:36:35,180
There's Moore's Law, which goes exponentially.

949
00:36:35,180 --> 00:36:37,300
And now we're at like the two nanometer scale

950
00:36:37,300 --> 00:36:39,660
where we have transistors that are two nanometers wide

951
00:36:39,660 --> 00:36:42,460
and we're able to pack trillions of them on modern GPUs.

952
00:36:42,460 --> 00:36:44,860
And for example, in the context of machine learning,

953
00:36:44,860 --> 00:36:46,780
machine learning was really terrible

954
00:36:46,780 --> 00:36:49,580
on traditional computers like CPUs back in the day,

955
00:36:49,580 --> 00:36:51,580
like in the 60s and 70s and 90s.

956
00:36:51,580 --> 00:36:53,820
So no one actually did machine learning back then.

957
00:36:53,820 --> 00:36:57,180
But when these people were playing video game for some reason,

958
00:36:57,180 --> 00:36:58,940
people started building chips

959
00:36:58,940 --> 00:37:02,820
that represent graphical interfaces a lot better.

960
00:37:02,820 --> 00:37:06,780
And it happens that there's an overlap of the mathematics

961
00:37:06,780 --> 00:37:10,300
that are used to represent graphics and graphics card

962
00:37:10,300 --> 00:37:12,540
and the machine learning, right?

963
00:37:12,540 --> 00:37:14,660
Machine learning is the matrix multiplication

964
00:37:14,660 --> 00:37:17,500
and the way that you represent pictures is matrices, right?

965
00:37:17,500 --> 00:37:20,580
It's just zeros and one that represent the RGB values

966
00:37:20,580 --> 00:37:22,660
of every single pixel on the screen

967
00:37:22,660 --> 00:37:24,220
and transformations between them.

968
00:37:24,220 --> 00:37:25,660
And so you have to do these operations

969
00:37:25,660 --> 00:37:26,860
between pixels really fast.

970
00:37:26,860 --> 00:37:28,300
And it just happened that it's the same thing

971
00:37:28,300 --> 00:37:30,820
as doing machine learning like neural network

972
00:37:30,820 --> 00:37:33,900
fast multiplication across multiple connected layers.

973
00:37:33,900 --> 00:37:35,420
It's like very similar structure.

974
00:37:35,420 --> 00:37:38,980
And so people start using GPUs to speed up machine learning

975
00:37:38,980 --> 00:37:41,780
and machine learning became feasible all of a sudden in 2012

976
00:37:41,780 --> 00:37:43,180
with convolutional neural networks

977
00:37:43,180 --> 00:37:46,260
and all these new like booms that we've been writing

978
00:37:46,260 --> 00:37:47,900
until now with modern LLMs.

979
00:37:47,900 --> 00:37:50,380
Like LLMs and all these new generative AI models

980
00:37:50,380 --> 00:37:52,580
are only possible because of this specialized hardware

981
00:37:52,580 --> 00:37:56,540
that come from NVIDIA, DCMC, AMD, ASML,

982
00:37:56,540 --> 00:37:58,780
like all these like transistor manufacturers,

983
00:37:58,780 --> 00:38:01,860
graphic car manufacturers, specialized hardware manufacturers.

984
00:38:01,860 --> 00:38:02,980
These ones are for machine learning,

985
00:38:02,980 --> 00:38:04,940
GPUs and tensor processing unit,

986
00:38:04,940 --> 00:38:07,540
GPUs, cryptography on the other hand,

987
00:38:07,540 --> 00:38:09,340
they work with a different type of math.

988
00:38:09,340 --> 00:38:11,780
Instead of working with floating points or arithmetic,

989
00:38:11,780 --> 00:38:15,340
they work with finite fields and sixth point arithmetic.

990
00:38:15,340 --> 00:38:17,820
And so you need to design fundamentally different hardware.

991
00:38:17,820 --> 00:38:19,380
And so we need to build better hardware

992
00:38:19,380 --> 00:38:22,340
to improve the computational capabilities

993
00:38:22,340 --> 00:38:24,100
of zero knowledge machine learning

994
00:38:24,100 --> 00:38:26,700
or just zero knowledge cryptography in this then.

995
00:38:26,700 --> 00:38:28,300
So there's lots of things to be done here.

996
00:38:28,300 --> 00:38:30,580
So I'm, for example, I'm also an investor in Fabric,

997
00:38:30,580 --> 00:38:31,420
I'm sorry for that,

998
00:38:31,420 --> 00:38:34,700
but Fabric is one of the ZK hardware company.

999
00:38:34,700 --> 00:38:37,020
In GoNyama, not size thick, it's size thick,

1000
00:38:37,020 --> 00:38:39,460
sorry about that, some misspelling without the T.

1001
00:38:39,460 --> 00:38:40,380
And irreducible,

1002
00:38:40,380 --> 00:38:43,260
there's some of the biggest ZK hardware companies.

1003
00:38:43,260 --> 00:38:45,740
And yeah, so these are trying to essentially model

1004
00:38:45,740 --> 00:38:48,140
the software in hardware so that it's faster

1005
00:38:48,140 --> 00:38:49,740
and there's less overhead.

1006
00:38:49,740 --> 00:38:51,100
Another one is better tooling.

1007
00:38:51,100 --> 00:38:52,540
So I mentioned Ezekiel and Giza.

1008
00:38:52,540 --> 00:38:54,180
They're building tooling that makes it easier

1009
00:38:54,180 --> 00:38:56,820
for developers to use ZK.

1010
00:38:56,820 --> 00:38:58,260
And if I'm a machine learning engineer,

1011
00:38:58,260 --> 00:39:00,940
there's no way in hell I'm gonna spend six years

1012
00:39:00,940 --> 00:39:03,860
learning cryptography and learning the state of the art

1013
00:39:03,860 --> 00:39:05,020
and trying to contribute there

1014
00:39:05,020 --> 00:39:06,980
so that I can prove my machine learning model.

1015
00:39:06,980 --> 00:39:08,100
As a machine learning engineer,

1016
00:39:08,100 --> 00:39:11,340
I just care about something that ZK can bring to me.

1017
00:39:11,340 --> 00:39:12,980
And vice versa, if I'm a ZK guy,

1018
00:39:12,980 --> 00:39:15,220
I just care about something that ML can bring to me

1019
00:39:15,220 --> 00:39:18,440
to get better or like somehow make it on chain.

1020
00:39:18,440 --> 00:39:21,180
So whenever we've brought down the cost of barriers,

1021
00:39:21,180 --> 00:39:24,140
like barriers that the cost barriers

1022
00:39:24,140 --> 00:39:26,380
that prevent us from doing something,

1023
00:39:26,380 --> 00:39:27,660
people start experimenting, right?

1024
00:39:27,660 --> 00:39:30,500
Like same thing happened with the web.

1025
00:39:30,500 --> 00:39:32,260
Like anyone can build a website nowadays

1026
00:39:32,260 --> 00:39:33,180
and you can build a business,

1027
00:39:33,180 --> 00:39:34,260
you can just be Shopify.

1028
00:39:34,260 --> 00:39:35,420
And if I'm a business guy,

1029
00:39:35,420 --> 00:39:36,780
I don't need to know web development.

1030
00:39:36,780 --> 00:39:38,060
Shopify and I have my store

1031
00:39:38,060 --> 00:39:40,020
and I can process millions of dollars of payment.

1032
00:39:40,020 --> 00:39:42,860
I can have a truly user and everything.

1033
00:39:42,860 --> 00:39:44,900
And otherwise I would have to learn web development,

1034
00:39:44,900 --> 00:39:45,980
servers, everything.

1035
00:39:45,980 --> 00:39:46,940
I don't have to care about that.

1036
00:39:46,940 --> 00:39:47,780
I just do my business

1037
00:39:47,780 --> 00:39:50,340
and I use web technology without having to know how it works.

1038
00:39:50,340 --> 00:39:52,980
So the same thing applies to KML of course.

1039
00:39:52,980 --> 00:39:55,020
More robust than secure implementation.

1040
00:39:55,020 --> 00:39:57,060
That one is a bit like self-explanatory

1041
00:39:57,060 --> 00:39:58,980
but essentially like the more security

1042
00:39:58,980 --> 00:40:02,380
the less prevent like if we can prevent hacks and exploit

1043
00:40:02,380 --> 00:40:03,980
then if it's more robust,

1044
00:40:03,980 --> 00:40:06,460
it can sustain more users, et cetera.

1045
00:40:06,460 --> 00:40:08,340
And the other one is like what I mentioned before

1046
00:40:08,340 --> 00:40:09,420
pretty much at the same point,

1047
00:40:09,420 --> 00:40:11,620
like better tooling and easier interfaces

1048
00:40:11,620 --> 00:40:12,660
is pretty much the same thing

1049
00:40:12,660 --> 00:40:14,260
because the easier it is to use,

1050
00:40:14,260 --> 00:40:16,460
the more experimentation there for the more products,

1051
00:40:16,460 --> 00:40:17,660
the more product market fits,

1052
00:40:17,660 --> 00:40:18,940
the more businesses can build

1053
00:40:18,940 --> 00:40:21,220
and the more technology can accelerate

1054
00:40:21,220 --> 00:40:24,180
towards the direction of growth.

1055
00:40:24,180 --> 00:40:27,020
So yeah, that's everything about my presentation

1056
00:40:27,020 --> 00:40:31,540
and I would love to answer any of your questions.

1057
00:40:31,540 --> 00:40:33,060
I don't know how long we have.

1058
00:40:33,060 --> 00:40:35,260
I think it's 14 minutes for FAQ.

1059
00:40:35,260 --> 00:40:38,260
I can also go run, get the orb if you guys wanna see it.

1060
00:40:38,260 --> 00:40:40,540
And thank you for having me.

1061
00:40:40,540 --> 00:40:41,380
This was fantastic.

1062
00:40:41,380 --> 00:40:42,380
Thank you so much.

1063
00:40:42,380 --> 00:40:43,220
What a world.

1064
00:40:43,220 --> 00:40:45,100
And we have a few questions already here

1065
00:40:45,100 --> 00:40:46,260
from people in the chat

1066
00:40:46,260 --> 00:40:48,500
and then maybe after a few we give you some time to breathe

1067
00:40:48,500 --> 00:40:50,620
and get the orb, that would be great.

1068
00:40:50,620 --> 00:40:52,100
Okay, so first one, Shadi,

1069
00:40:52,100 --> 00:40:54,420
if you wanna unmute your first.

1070
00:40:54,420 --> 00:40:56,300
Hi, yeah, thanks for the great presentation.

1071
00:40:56,380 --> 00:40:57,580
Very informative.

1072
00:40:57,580 --> 00:41:00,740
I had a question about the personally identifying information

1073
00:41:00,740 --> 00:41:04,420
from the hash from the iris biometrics.

1074
00:41:04,420 --> 00:41:07,820
Isn't a hash or iris still uniquely identifying

1075
00:41:07,820 --> 00:41:11,500
if you know the hashing function to produce that digest?

1076
00:41:11,500 --> 00:41:14,700
Or did you mean that make the function is kept secret

1077
00:41:14,700 --> 00:41:18,860
and nobody can easily take like a photograph of someone

1078
00:41:18,860 --> 00:41:22,100
and then produce the same hash and that look on chain,

1079
00:41:22,100 --> 00:41:23,460
for example, I don't think you posted on chain

1080
00:41:23,460 --> 00:41:26,220
but look on chain, for example, to try to match that.

1081
00:41:26,940 --> 00:41:30,380
Yeah, there's one unfortunate naming collision here.

1082
00:41:30,380 --> 00:41:31,740
So in biometric literature,

1083
00:41:31,740 --> 00:41:34,780
people use a hash in a non-urgorous way.

1084
00:41:34,780 --> 00:41:36,180
And so what we mean here,

1085
00:41:36,180 --> 00:41:37,260
or what we used to mean,

1086
00:41:37,260 --> 00:41:39,900
we've changed the way that we explain these things.

1087
00:41:39,900 --> 00:41:41,700
We no longer use the terminology of hash

1088
00:41:41,700 --> 00:41:45,500
because we work in the intersection of AI and cryptography

1089
00:41:45,500 --> 00:41:47,900
and if you use a term that means a different thing in both,

1090
00:41:47,900 --> 00:41:51,420
it's like ambiguous and it can cause problems

1091
00:41:51,420 --> 00:41:53,100
like this one right now.

1092
00:41:53,100 --> 00:41:56,780
Actually, the way the biometrics pipeline works

1093
00:41:56,780 --> 00:42:00,020
is that there's this essentially convolution-like algorithm.

1094
00:42:00,020 --> 00:42:03,020
It's called the GABER wavelet or GABER filter,

1095
00:42:03,020 --> 00:42:04,660
which essentially applies convolutions

1096
00:42:04,660 --> 00:42:06,660
into original biometrics many times over

1097
00:42:06,660 --> 00:42:10,500
and it's able to compute like a randomness representation.

1098
00:42:10,500 --> 00:42:14,460
And this one essentially compresses the image so much,

1099
00:42:14,460 --> 00:42:16,300
like after performing all these operations,

1100
00:42:16,300 --> 00:42:20,820
you end up with a pretty much a small representation

1101
00:42:20,820 --> 00:42:22,660
of a few bits, like I think it's 200,

1102
00:42:22,660 --> 00:42:24,860
something that, so the vector in the end,

1103
00:42:24,860 --> 00:42:26,660
like the embedding in the end is like a few bit.

1104
00:42:26,660 --> 00:42:29,980
And this one is not able to be reconstructed

1105
00:42:30,980 --> 00:42:33,660
to its original, at least like a lossy function, right?

1106
00:42:33,660 --> 00:42:36,140
If I go from a compressed representation

1107
00:42:36,140 --> 00:42:38,580
to a fully, try to expand it back,

1108
00:42:38,580 --> 00:42:39,900
I lose information in the process

1109
00:42:39,900 --> 00:42:41,940
of converting it to this compressed representation.

1110
00:42:41,940 --> 00:42:43,980
Therefore, I'm not able to reconstruct the same one.

1111
00:42:43,980 --> 00:42:47,060
And the good part of this is that I'm able to,

1112
00:42:47,060 --> 00:42:48,860
I'm able to reconstruct something similar,

1113
00:42:48,860 --> 00:42:51,300
but it's not personalized identifiable,

1114
00:42:51,300 --> 00:42:54,340
at least not considered so in modern literature, right?

1115
00:42:54,340 --> 00:42:56,860
This may change and this is why we've been working

1116
00:42:56,860 --> 00:42:58,580
on a lot of other things within world economy,

1117
00:42:58,580 --> 00:43:01,380
like more of the party computation solutions and whatnot.

1118
00:43:01,380 --> 00:43:03,180
We're gonna be publishing a lot about this

1119
00:43:03,180 --> 00:43:05,180
in the coming month, but if you're interested

1120
00:43:05,180 --> 00:43:08,060
in like follow this, the biometrics pipeline works

1121
00:43:08,060 --> 00:43:10,140
and have the definition of it and how it works

1122
00:43:10,140 --> 00:43:11,500
and what is actually going on,

1123
00:43:11,500 --> 00:43:13,740
I recommend going to the link I just said in the chat,

1124
00:43:13,740 --> 00:43:15,300
my paper that work in the org.

1125
00:43:15,300 --> 00:43:17,260
Also, one of my teammates is in the,

1126
00:43:17,260 --> 00:43:19,460
actually one of the former teammates,

1127
00:43:19,460 --> 00:43:20,820
he's at Tool for Humanity,

1128
00:43:20,820 --> 00:43:22,220
which is the labs entity.

1129
00:43:22,220 --> 00:43:24,620
I'm at the foundation of different legal entities,

1130
00:43:24,620 --> 00:43:26,740
but they're both contributing to the world team project.

1131
00:43:26,740 --> 00:43:28,380
His name is Daniel Gershiewicz.

1132
00:43:28,380 --> 00:43:29,660
He is in the cause law.

1133
00:43:29,660 --> 00:43:31,700
So he's also able to explain a bit more.

1134
00:43:31,700 --> 00:43:32,860
He's on the org software team.

1135
00:43:32,860 --> 00:43:36,140
So he works a lot more with the biometrics pipeline than I do.

1136
00:43:36,140 --> 00:43:37,740
I'm more still in the cryptography

1137
00:43:37,740 --> 00:43:38,980
protocol side of thing.

1138
00:43:38,980 --> 00:43:40,460
But yeah, within the white paper,

1139
00:43:40,460 --> 00:43:41,900
white paper.worldcoin.org,

1140
00:43:41,900 --> 00:43:43,300
you have a biometric action

1141
00:43:43,300 --> 00:43:44,380
and you have the third definition

1142
00:43:44,380 --> 00:43:45,660
of what it is that we're doing

1143
00:43:45,660 --> 00:43:47,260
and how we preserve privacy.

1144
00:43:47,260 --> 00:43:49,900
So to answer your question in a specific way,

1145
00:43:49,900 --> 00:43:51,620
it's not a hash, it's not a cryptographic hash.

1146
00:43:51,620 --> 00:43:53,060
There's no digest, there's no plaintext.

1147
00:43:53,060 --> 00:43:55,660
It's essentially a convolutional like operation

1148
00:43:55,660 --> 00:43:56,700
which happens many times

1149
00:43:56,700 --> 00:43:58,300
and it leaves the input unrecognizable

1150
00:43:58,300 --> 00:43:59,380
and you compress certain information

1151
00:43:59,380 --> 00:44:01,100
of the randomness that you get.

1152
00:44:01,100 --> 00:44:03,340
You cannot use that to reconstruct the original thing

1153
00:44:03,340 --> 00:44:04,380
that you put into this function

1154
00:44:04,380 --> 00:44:05,980
because it's a very lofty function.

1155
00:44:05,980 --> 00:44:08,780
And this is good enough to prevent

1156
00:44:08,780 --> 00:44:12,060
like getting the raw biometric out again.

1157
00:44:13,180 --> 00:44:14,020
Got it.

1158
00:44:14,020 --> 00:44:16,420
So the idea is even if I had access

1159
00:44:16,420 --> 00:44:19,060
to the kernels that you used to train,

1160
00:44:19,220 --> 00:44:24,220
then I wouldn't be able to deconvolute the output.

1161
00:44:25,740 --> 00:44:26,580
I see.

1162
00:44:26,580 --> 00:44:30,500
Ideally to try and break our own assumptions

1163
00:44:30,500 --> 00:44:31,700
and try to reverse engineer

1164
00:44:31,700 --> 00:44:33,220
and actually get the original image.

1165
00:44:33,220 --> 00:44:35,420
And now we've gone ahead a step further

1166
00:44:35,420 --> 00:44:37,100
because if it was possible,

1167
00:44:37,100 --> 00:44:38,100
we've gone a step further

1168
00:44:38,100 --> 00:44:39,940
and we're now storing everything in ciphertext

1169
00:44:39,940 --> 00:44:41,300
and the uniqueness check,

1170
00:44:41,300 --> 00:44:44,060
it's happening on ciphertext with multi-party computation.

1171
00:44:44,060 --> 00:44:46,860
So yeah, that's like cool, cool new research stuff.

1172
00:44:47,820 --> 00:44:48,660
Love it.

1173
00:44:48,660 --> 00:44:50,100
Dan also shared, I think the white paper

1174
00:44:50,100 --> 00:44:51,700
that you referenced directly here in the chat

1175
00:44:51,700 --> 00:44:53,340
already a little further up.

1176
00:44:53,340 --> 00:44:54,420
Thanks for that, Dan.

1177
00:44:54,420 --> 00:44:57,380
Next one up we have Richard and then we have Micah.

1178
00:44:58,540 --> 00:45:00,620
Yeah, I think the previous discussion

1179
00:45:00,620 --> 00:45:01,780
answered my question there.

1180
00:45:01,780 --> 00:45:03,020
Thank you.

1181
00:45:03,020 --> 00:45:04,060
Awesome.

1182
00:45:04,060 --> 00:45:04,900
Wonderful.

1183
00:45:04,900 --> 00:45:06,340
Micah, you go.

1184
00:45:06,340 --> 00:45:07,540
Micah, we can't hear you.

1185
00:45:07,540 --> 00:45:09,740
Feel free if you can't unmute to put your chat,

1186
00:45:09,740 --> 00:45:11,700
your question in the chat.

1187
00:45:11,700 --> 00:45:13,420
Okay, he's going to rejoin.

1188
00:45:13,420 --> 00:45:15,860
This could be a great opportunity for you to get the orb.

1189
00:45:15,860 --> 00:45:19,780
I also have a few questions, but God, you go.

1190
00:45:20,620 --> 00:45:21,460
Can you hear me?

1191
00:45:22,580 --> 00:45:24,020
Yes, Dan, we can hear you.

1192
00:45:25,300 --> 00:45:27,180
I want to go back, there was this question about

1193
00:45:27,180 --> 00:45:29,740
and things being personally identifiable

1194
00:45:29,740 --> 00:45:31,820
or uniquely identifying information.

1195
00:45:31,820 --> 00:45:34,540
And then the question turned into ashes

1196
00:45:34,540 --> 00:45:37,420
versus wavelet encodings.

1197
00:45:38,500 --> 00:45:39,340
I don't know.

1198
00:45:39,340 --> 00:45:41,820
I think the question actually got lots of discussions.

1199
00:45:41,820 --> 00:45:44,740
And the interesting thing is that even if you've had

1200
00:45:44,740 --> 00:45:46,220
either a hash or an encoding,

1201
00:45:46,220 --> 00:45:49,580
and you somehow broke this and could reverse that image,

1202
00:45:50,580 --> 00:45:52,940
actually the privacy comes from

1203
00:45:52,940 --> 00:45:54,340
what was briefly mentioned in the talk,

1204
00:45:54,340 --> 00:45:58,900
which is that when you prove your ownership of such,

1205
00:45:58,900 --> 00:46:01,140
you're proving ownership of a key

1206
00:46:01,140 --> 00:46:05,780
that was linked to this biometric encoding.

1207
00:46:05,780 --> 00:46:07,260
So when you prove ownership of that key,

1208
00:46:07,260 --> 00:46:09,500
you're not pointing to which encoding is yours.

1209
00:46:09,500 --> 00:46:10,420
So you're a member of the set

1210
00:46:10,420 --> 00:46:12,220
without revealing which member.

1211
00:46:12,220 --> 00:46:13,420
And that means that these encodings

1212
00:46:13,420 --> 00:46:15,540
are cryptographically delinked from anything else,

1213
00:46:15,540 --> 00:46:17,580
your transactions, your accounts.

1214
00:46:17,580 --> 00:46:18,540
Nothing can be linked back.

1215
00:46:18,540 --> 00:46:23,180
So if you did reverse those codes, you wouldn't know.

1216
00:46:23,180 --> 00:46:25,260
Also, one additional thing is that

1217
00:46:25,260 --> 00:46:27,500
these encodings are not public.

1218
00:46:27,500 --> 00:46:30,340
They're hidden in a database that we have.

1219
00:46:30,340 --> 00:46:33,020
The thing that is public is the public key

1220
00:46:33,020 --> 00:46:36,220
associated with the user that has undergone a unique question.

1221
00:46:36,220 --> 00:46:38,380
So if I have this unique coding,

1222
00:46:38,380 --> 00:46:41,460
and I prove that I'm a unique within the coding set,

1223
00:46:41,500 --> 00:46:44,500
which is kept not on any public sphere,

1224
00:46:44,500 --> 00:46:46,980
it's now kept in this multi-party computation

1225
00:46:46,980 --> 00:46:48,500
encrypted environment in a database

1226
00:46:48,500 --> 00:46:51,380
that is run by three different parties

1227
00:46:51,380 --> 00:46:54,340
in an MPC setting, again, multi-party.

1228
00:46:54,340 --> 00:46:56,660
And when the user is verified to be unique,

1229
00:46:56,660 --> 00:46:58,060
we take the user's public key,

1230
00:46:58,060 --> 00:46:59,660
which was generated by the World app,

1231
00:46:59,660 --> 00:47:01,620
which is the way that you interface with World ID

1232
00:47:01,620 --> 00:47:03,980
and the wallet and a bunch of other things that we're building.

1233
00:47:03,980 --> 00:47:05,460
Essentially, the public key that was generated

1234
00:47:05,460 --> 00:47:07,300
by the World app, by the user,

1235
00:47:07,300 --> 00:47:09,100
which is a unique person that's been just verified

1236
00:47:09,100 --> 00:47:12,780
by the World, gets inserted into the set of verified users,

1237
00:47:12,780 --> 00:47:14,860
and then I'm able to make a knowledge proof

1238
00:47:14,860 --> 00:47:17,820
that I own a private key to a public key

1239
00:47:17,820 --> 00:47:19,420
and the set of verified users.

1240
00:47:19,420 --> 00:47:21,220
So even then, there's one more step

1241
00:47:21,220 --> 00:47:24,100
that removed from your biometric completely,

1242
00:47:24,100 --> 00:47:26,300
because a public key is just random,

1243
00:47:26,300 --> 00:47:29,420
cryptographical, gibberish that I can make proofs about,

1244
00:47:29,420 --> 00:47:31,420
and I'm able to prove to you that I'm a unique member

1245
00:47:31,420 --> 00:47:32,500
of the set because I own a private key

1246
00:47:32,500 --> 00:47:35,020
to a public key in the set, but I don't know which one.

1247
00:47:35,020 --> 00:47:36,540
And there's another cool part,

1248
00:47:36,540 --> 00:47:38,660
which is the nullifier scheme that we have,

1249
00:47:38,660 --> 00:47:41,100
which allows you to represent unique actions.

1250
00:47:41,100 --> 00:47:43,700
For example, one is like unique governance,

1251
00:47:43,700 --> 00:47:46,220
like one person, one vote, digital governance,

1252
00:47:46,220 --> 00:47:47,820
or voting protocol.

1253
00:47:47,820 --> 00:47:48,980
Currently, there's no way to prove

1254
00:47:48,980 --> 00:47:50,580
that you're not a bot online.

1255
00:47:50,580 --> 00:47:52,620
So if you, for example, let's say, I don't know,

1256
00:47:52,620 --> 00:47:55,780
Elon Musk puts a poll on Twitter or on X

1257
00:47:55,780 --> 00:47:58,380
that, hey, is this doc cute or no?

1258
00:47:58,380 --> 00:48:03,100
I can create a bajillion X accounts and vote for no, right?

1259
00:48:03,100 --> 00:48:04,300
There's no way for me to prove

1260
00:48:04,300 --> 00:48:05,940
that this is a one person, one vote.

1261
00:48:05,940 --> 00:48:08,420
So whomever who posts a poll on whatever thing

1262
00:48:08,460 --> 00:48:10,220
doesn't matter, like the opinion doesn't matter,

1263
00:48:10,220 --> 00:48:11,820
the result of the poll doesn't matter.

1264
00:48:11,820 --> 00:48:13,580
There's million bots that have incentives

1265
00:48:13,580 --> 00:48:15,740
and both, like presidential elections,

1266
00:48:15,740 --> 00:48:18,140
if Elon says, is this candidate a good guy?

1267
00:48:19,100 --> 00:48:21,100
People can vote yes, but it can be like a third,

1268
00:48:21,100 --> 00:48:24,380
like external nation state actor trying to just

1269
00:48:24,380 --> 00:48:26,740
civil attack, which means like attack a protocol

1270
00:48:26,740 --> 00:48:29,100
where you need unique members in a way

1271
00:48:29,100 --> 00:48:31,340
that just make the protocol broken

1272
00:48:31,340 --> 00:48:32,940
completely beyond repair.

1273
00:48:32,940 --> 00:48:34,140
So this is where we step in,

1274
00:48:34,140 --> 00:48:36,780
where we create a unit of account of uniqueness

1275
00:48:36,780 --> 00:48:39,140
for humans in a digital environment,

1276
00:48:39,140 --> 00:48:41,620
whether it's on chain or it's off chain doesn't matter.

1277
00:48:41,620 --> 00:48:43,300
As long as you're able to make these cryptographic

1278
00:48:43,300 --> 00:48:44,980
at the station that I am a unique person

1279
00:48:44,980 --> 00:48:46,820
and I've not done an action before,

1280
00:48:46,820 --> 00:48:49,260
so I'm able to prove that I'm a unique actor.

1281
00:48:49,260 --> 00:48:51,420
I'm a unique member of this protocol

1282
00:48:51,420 --> 00:48:53,020
and I only voted once.

1283
00:48:53,020 --> 00:48:56,420
So I can say that this dog was cute only once.

1284
00:48:56,420 --> 00:48:57,940
And if I want to weigh the outcome,

1285
00:48:57,940 --> 00:48:59,660
the only way to weigh the outcome is that I need

1286
00:48:59,660 --> 00:49:01,340
to convince a thousand other members

1287
00:49:01,340 --> 00:49:02,460
to vote for the same thing,

1288
00:49:02,460 --> 00:49:04,660
but I'm not able to just create a million accounts

1289
00:49:04,660 --> 00:49:07,620
and vote for a same thing to weigh the outcome.

1290
00:49:07,620 --> 00:49:08,460
Yeah.

1291
00:49:08,460 --> 00:49:09,300
Awesome.

1292
00:49:09,300 --> 00:49:10,340
Yeah, I think Bramco talked a little bit about that,

1293
00:49:10,340 --> 00:49:12,340
especially like with possible future applications

1294
00:49:12,340 --> 00:49:14,380
also that you also listed very briefly,

1295
00:49:14,380 --> 00:49:16,580
including in medicine and so forth

1296
00:49:16,580 --> 00:49:19,020
that I think these groups are just like really incredible for

1297
00:49:19,020 --> 00:49:21,260
because it can't for medicine, for financial risk,

1298
00:49:21,260 --> 00:49:22,100
for insurance and stuff,

1299
00:49:22,100 --> 00:49:25,220
you just can't really access the data any other way.

1300
00:49:25,220 --> 00:49:28,020
Or you just can't do too much anyways with the information.

1301
00:49:28,020 --> 00:49:29,140
Okay, we have another question,

1302
00:49:29,140 --> 00:49:31,540
but you also have the orb now or?

1303
00:49:31,540 --> 00:49:32,780
It's right here, my lap.

1304
00:49:34,740 --> 00:49:36,140
Wonderful.

1305
00:49:36,140 --> 00:49:38,100
By the call, the battery,

1306
00:49:39,500 --> 00:49:40,340
at least.

1307
00:49:41,500 --> 00:49:42,540
All right, sorry.

1308
00:49:42,540 --> 00:49:44,700
I'm gonna unbler my background.

1309
00:49:44,700 --> 00:49:46,660
I do have a, I just moved into a new apartment,

1310
00:49:46,660 --> 00:49:48,300
so forgive me for,

1311
00:49:50,060 --> 00:49:55,060
but yeah, the battery right here.

1312
00:49:55,300 --> 00:49:57,940
Yeah, that is able to say a lot more about the orb than I can.

1313
00:49:57,940 --> 00:49:59,900
If you work on the orb software team,

1314
00:49:59,900 --> 00:50:03,300
you've been working on this for three years plus.

1315
00:50:03,300 --> 00:50:04,140
Yeah.

1316
00:50:04,940 --> 00:50:08,300
Yeah, I've come in multiple close contacts with the orb already

1317
00:50:08,300 --> 00:50:11,020
and I think in 50 years you even have it like taken apart,

1318
00:50:11,020 --> 00:50:12,180
you know, and it's different components,

1319
00:50:12,180 --> 00:50:13,620
which is really fun to see.

1320
00:50:13,620 --> 00:50:15,340
So yeah, thanks.

1321
00:50:15,340 --> 00:50:17,740
The orb hardware specs are publicly available

1322
00:50:17,740 --> 00:50:18,940
on GitHub as well.

1323
00:50:18,940 --> 00:50:20,700
So people can see the PCB design,

1324
00:50:20,700 --> 00:50:22,700
they can see like what components it's made out of.

1325
00:50:22,700 --> 00:50:23,900
There's also an hour paper,

1326
00:50:23,900 --> 00:50:26,980
there's like an annotated set of every single component

1327
00:50:26,980 --> 00:50:29,940
and like what it does, how it works, et cetera.

1328
00:50:29,940 --> 00:50:31,140
Yeah, I've been following like

1329
00:50:31,140 --> 00:50:32,380
just how many people are signing up

1330
00:50:32,380 --> 00:50:34,580
and like the very, very long lines.

1331
00:50:35,340 --> 00:50:38,060
Sign up stations, which has been really interesting.

1332
00:50:38,060 --> 00:50:40,700
Okay, Micah, you rejoined and you raised your hand.

1333
00:50:40,700 --> 00:50:42,940
Do you want to ask you a final question?

1334
00:50:42,940 --> 00:50:44,140
Testing, can you hear me?

1335
00:50:45,540 --> 00:50:46,580
Yep.

1336
00:50:46,580 --> 00:50:48,780
Quick comment and then a question after that.

1337
00:50:48,780 --> 00:50:51,700
The, I believe that while the transactions,

1338
00:50:51,700 --> 00:50:54,660
your transactions made using your unique ID

1339
00:50:54,660 --> 00:50:55,820
can't be linked back to you.

1340
00:50:55,820 --> 00:50:57,580
You can be linked back to your transaction.

1341
00:50:57,580 --> 00:51:00,060
Someone has an orb or the algorithm in the orb

1342
00:51:00,060 --> 00:51:01,940
and they can get a picture of you, so to speak.

1343
00:51:01,940 --> 00:51:04,500
They can then regenerate your unique ID

1344
00:51:04,500 --> 00:51:07,180
and this is an unnecessary piece.

1345
00:51:07,180 --> 00:51:09,420
You can't get rid of it because in order to have

1346
00:51:09,420 --> 00:51:11,820
a unique human, you need to be able to verify.

1347
00:51:11,820 --> 00:51:13,620
There needs to be only one outcome.

1348
00:51:13,620 --> 00:51:15,380
You can't introduce randomness here, right?

1349
00:51:15,380 --> 00:51:19,740
And so if your goal is to not have someone be able

1350
00:51:19,740 --> 00:51:21,700
to tell which transactions you did,

1351
00:51:21,700 --> 00:51:22,660
that is not possible here.

1352
00:51:22,660 --> 00:51:25,980
But someone can't tell just by looking at the transactions

1353
00:51:25,980 --> 00:51:26,820
that they were yours.

1354
00:51:26,820 --> 00:51:28,220
It's a one-way thing.

1355
00:51:28,220 --> 00:51:29,980
This one held you down and put an orb in front of your eye,

1356
00:51:29,980 --> 00:51:31,600
they can then figure out all your transactions,

1357
00:51:31,600 --> 00:51:33,260
but they couldn't look at your transaction

1358
00:51:33,260 --> 00:51:36,620
and figure out which eye they belong to, so to speak.

1359
00:51:36,620 --> 00:51:40,260
Yes and no, there's one step that helps us mitigate this,

1360
00:51:40,260 --> 00:51:42,180
which is the separation of the public key, right?

1361
00:51:42,180 --> 00:51:43,900
Like your transactions are not being done

1362
00:51:43,900 --> 00:51:45,860
by your iris code or whatever.

1363
00:51:45,860 --> 00:51:47,940
The transactions are being done by a public key

1364
00:51:47,940 --> 00:51:49,220
which was owned by a user,

1365
00:51:49,220 --> 00:51:51,900
which just happened to verify at the orb, right?

1366
00:51:51,900 --> 00:51:54,580
You would have to get the user's private key

1367
00:51:54,580 --> 00:51:56,500
to learn what they did on the game.

1368
00:51:56,500 --> 00:51:58,460
And then you would also have to get their bandwidth forked

1369
00:51:58,460 --> 00:52:00,820
to try and interlink too, right?

1370
00:52:00,820 --> 00:52:02,060
You'd have to get their bandwidth forked,

1371
00:52:02,060 --> 00:52:03,220
you'd generate the iris code,

1372
00:52:03,220 --> 00:52:05,780
and then get somehow steal from them their private key.

1373
00:52:05,780 --> 00:52:06,980
And then with a private key,

1374
00:52:06,980 --> 00:52:10,100
you're able to de-anonymize the on-chain state

1375
00:52:10,100 --> 00:52:11,700
that they performed in a DK way

1376
00:52:11,700 --> 00:52:14,340
because you're not able to just get the live iris.

1377
00:52:14,340 --> 00:52:15,960
You know you can generate them.

1378
00:52:15,960 --> 00:52:19,780
And so there's two things that you need to compromise there.

1379
00:52:19,780 --> 00:52:20,980
I'll just, my actual question,

1380
00:52:20,980 --> 00:52:21,820
I'll try to keep it,

1381
00:52:21,820 --> 00:52:23,460
I know I've got one minute left.

1382
00:52:23,460 --> 00:52:26,180
Last I checked, DK proof of an execution takes

1383
00:52:26,180 --> 00:52:28,740
on the order of a thousand times or so,

1384
00:52:28,740 --> 00:52:31,580
executing the same thing without a DK proof.

1385
00:52:31,580 --> 00:52:33,740
Even though inference is significantly cheaper

1386
00:52:33,740 --> 00:52:36,700
than training, execution costs is still very non-trivial.

1387
00:52:36,700 --> 00:52:39,340
That's why you need giant GPUs and whatnot,

1388
00:52:39,340 --> 00:52:41,220
just to do inference.

1389
00:52:41,220 --> 00:52:42,620
The use cases you're thinking of,

1390
00:52:42,620 --> 00:52:45,580
are they all things that are like become useful

1391
00:52:45,580 --> 00:52:49,180
once we can get the DK proofing costs down by a hundred times?

1392
00:52:49,180 --> 00:52:51,460
Or do you think there's some things that are usable

1393
00:52:51,460 --> 00:52:54,460
even with that thousand increase in execution costs?

1394
00:52:54,460 --> 00:52:57,300
Right now there's already like DK use cases on-chain, right?

1395
00:52:57,300 --> 00:53:00,460
And there's equally expensive in the ML lens,

1396
00:53:00,460 --> 00:53:04,020
like already proved a hundred million like parameter models

1397
00:53:04,020 --> 00:53:05,700
in an inexpensive way, right?

1398
00:53:05,700 --> 00:53:07,100
In a usable way, right?

1399
00:53:07,100 --> 00:53:09,220
Let's say you have a small convolutional neural network

1400
00:53:09,220 --> 00:53:12,500
classifier with 200 million like weights,

1401
00:53:12,500 --> 00:53:13,580
like flowing point,

1402
00:53:13,580 --> 00:53:16,340
or in this case for a ZKML with field elements,

1403
00:53:16,340 --> 00:53:18,820
but you're able to make proofs in reasonable time,

1404
00:53:18,820 --> 00:53:21,020
one to two minutes for inference, right?

1405
00:53:21,020 --> 00:53:24,540
Where the evaluation of it in the normal world

1406
00:53:24,540 --> 00:53:25,700
is a thousand nights less,

1407
00:53:25,700 --> 00:53:28,740
two millisecond, 20 millisecond, like point two second,

1408
00:53:28,740 --> 00:53:30,340
or 200 million, my bad.

1409
00:53:30,340 --> 00:53:32,780
So yeah, like this is like the costly incur,

1410
00:53:32,780 --> 00:53:34,740
but it makes sense for some things.

1411
00:53:34,740 --> 00:53:36,820
And right now, as I mentioned,

1412
00:53:36,820 --> 00:53:38,300
like the things that we're doing could prove the thing,

1413
00:53:38,300 --> 00:53:40,140
like cryptography, better implementation,

1414
00:53:40,140 --> 00:53:41,900
better hardware, specialized hardware, et cetera,

1415
00:53:41,900 --> 00:53:43,620
they're gonna bring down this cost significantly,

1416
00:53:43,620 --> 00:53:45,460
it's gonna make more things feasible.

1417
00:53:45,460 --> 00:53:47,220
Like now we can maybe prove an LLM,

1418
00:53:47,220 --> 00:53:49,140
it may take 10 minutes,

1419
00:53:49,140 --> 00:53:51,100
but maybe proving that LLM once

1420
00:53:51,100 --> 00:53:54,700
for something that's really important enables a new thing.

1421
00:53:54,700 --> 00:53:55,900
And it's always happened like this,

1422
00:53:55,900 --> 00:53:57,620
that like the use case and the demand for it

1423
00:53:57,660 --> 00:53:59,060
and bring the proving time down,

1424
00:53:59,060 --> 00:54:00,580
the overhead down, the performance up,

1425
00:54:00,580 --> 00:54:03,060
and we're still like have a bunch of things to do.

1426
00:54:03,060 --> 00:54:05,260
So it should work out eventually.

1427
00:54:06,340 --> 00:54:07,180
Love it.

1428
00:54:07,180 --> 00:54:08,020
Any final words?

1429
00:54:08,020 --> 00:54:08,980
How can people find out more?

1430
00:54:08,980 --> 00:54:10,300
I know that you said, for example,

1431
00:54:10,300 --> 00:54:11,700
there's an announcement coming on soon,

1432
00:54:11,700 --> 00:54:13,100
but if people are really excited about this

1433
00:54:13,100 --> 00:54:14,300
or they just wanna learn more,

1434
00:54:14,300 --> 00:54:17,060
what are any possible action items that people can take?

1435
00:54:17,060 --> 00:54:18,220
So action items.

1436
00:54:18,220 --> 00:54:20,500
So if you have a specific question about this presentation,

1437
00:54:20,500 --> 00:54:22,980
you wanna ask me, I think my Twitter or my Telegram,

1438
00:54:22,980 --> 00:54:24,940
or like my ex and my Telegram are the best.

1439
00:54:24,940 --> 00:54:27,500
So my handle is DC build 3R.

1440
00:54:27,540 --> 00:54:31,820
So DC builder, but with the 3 instead of an E at the end.

1441
00:54:31,820 --> 00:54:33,500
So that is for asking me questions.

1442
00:54:33,500 --> 00:54:36,660
If you were interested in ZKML itself,

1443
00:54:36,660 --> 00:54:40,940
I do have a resource aggregator for ZKML things.

1444
00:54:40,940 --> 00:54:43,540
It's on my, or one of my GitHub's,

1445
00:54:43,540 --> 00:54:48,540
which is github.com slash ZKML dash community slash

1446
00:54:48,860 --> 00:54:50,860
awesome dash ZKML.

1447
00:54:50,860 --> 00:54:53,940
I'm able to leave the link in the chat real quick,

1448
00:54:53,940 --> 00:54:56,380
but I think like the spelling makes sense.

1449
00:54:56,420 --> 00:54:59,380
Besides that, there's a bunch of startups working in ZKML,

1450
00:54:59,380 --> 00:55:03,820
mostly like what I mentioned, like Modulus, Giza, and Ezekio.

1451
00:55:03,820 --> 00:55:06,940
And these three keep coming out with new developments,

1452
00:55:06,940 --> 00:55:08,900
new things, new announcements, et cetera.

1453
00:55:08,900 --> 00:55:11,300
There's cryptographic papers coming out on ZKML,

1454
00:55:11,300 --> 00:55:13,820
which I also try and keep up to date on my resource.

1455
00:55:13,820 --> 00:55:16,900
So yeah, those are like the best ones, I think.

1456
00:55:17,740 --> 00:55:18,580
Love it.

1457
00:55:18,580 --> 00:55:19,580
And I just saw from Dan that he's bringing

1458
00:55:19,580 --> 00:55:21,580
up to our upcoming May workshop though.

1459
00:55:21,580 --> 00:55:24,020
If you're going to that one, you may be able to try it.

1460
00:55:24,020 --> 00:55:24,980
Hey, thank you so much.

1461
00:55:24,980 --> 00:55:26,220
This was really fantastic.

1462
00:55:26,260 --> 00:55:27,820
Thanks for staying on three minutes longer.

1463
00:55:27,820 --> 00:55:28,740
I really appreciated it.

1464
00:55:28,740 --> 00:55:30,380
Thanks for all of your great questions, everyone,

1465
00:55:30,380 --> 00:55:31,860
and I hope to see you guys soon.

1466
00:55:31,860 --> 00:55:32,700
Bye-bye.

