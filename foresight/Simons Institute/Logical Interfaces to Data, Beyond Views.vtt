WEBVTT

00:00.000 --> 00:04.000
Oh, there was one that your colleague helped me with earlier, it's now gone.

00:04.000 --> 00:05.000
No, no, that's right.

00:11.000 --> 00:12.000
Of course.

00:30.000 --> 00:49.000
Can you hear me?

00:49.000 --> 00:55.000
Most of you have heard about this notion of great thoughts time.

00:55.000 --> 01:02.000
We were discussing it with what kind of at much ideas you have imposed a discipline on Friday afternoons after lunch.

01:02.000 --> 01:05.000
You only think about great thoughts.

01:05.000 --> 01:16.000
And I had the notion that I and also with you, I think great thoughts about the foundations of data interfaces.

01:16.000 --> 01:21.000
And that radically rethinking the notion of logical interface to data.

01:21.000 --> 01:23.000
Friday afternoon.

01:24.000 --> 01:26.000
Thursday.

01:26.000 --> 01:36.000
I'm not Richard hamming, so I need some kind of warm up thinking maybe some trivial thoughts, maybe mediocre thoughts as a kind of stretching exercise.

01:36.000 --> 01:38.000
And so that's what this talk is.

01:38.000 --> 01:46.000
I'm going to go over some projects which I think will will maybe give the notion of the goal of rethinking interfaces to data.

01:46.000 --> 01:49.000
And that will prime the pump for not even for questions.

01:49.000 --> 01:51.000
I won't be at peak.

01:51.000 --> 01:55.000
Great thoughts time by question time, but maybe by tomorrow afternoon.

01:55.000 --> 01:57.000
I'll be ready for great thoughts.

01:57.000 --> 02:03.000
So first I have to explain what I mean by an interface to data because this is what I want to rethink.

02:03.000 --> 02:10.000
Well, an interface to data in general is something you have a class of users and you want to restrict you have some source data.

02:10.000 --> 02:17.000
And you want to restrict the kind of queries for that class of users that they can answer.

02:17.000 --> 02:19.000
So I'll give some examples of this later.

02:19.000 --> 02:22.000
This is not what we normally think of.

02:22.000 --> 02:25.000
Maybe this is not even the best way to think of an interface.

02:25.000 --> 02:34.000
You normally think of an interface as maybe a layer like an anthology layer where you have a different vocabulary, different data model or different API that users have.

02:34.000 --> 02:39.000
But from the point of view of expressiveness, this is, I think, you know, one way to think of these interfaces.

02:39.000 --> 02:47.000
The bottom line of whatever you give to users, restricted language, different data model is that there's a limit on what they can ask to the source data.

02:47.000 --> 02:52.000
And you can begin to compare different interfaces this way.

02:52.000 --> 02:57.000
You know, one person uses this vocabulary, one uses this data model, one uses this amount.

02:57.000 --> 03:08.000
If you want to compare them, you'd compare based on what class of queries the user can extract, what information they can extract from the source database.

03:08.000 --> 03:14.000
And we'll also look at this in the setting of multiple databases, autonomous distributed over the world.

03:14.000 --> 03:21.000
Then an interface will be a restriction on what users can ask to the global database, the union of the sources.

03:21.000 --> 03:25.000
But it will have to be compatible with this notion of autonomy.

03:25.000 --> 03:31.000
It should be something that factors into an interface at each source.

03:31.000 --> 03:37.000
So there'll be examples later, but the canonical example is traditional database views, say SQL views.

03:37.000 --> 03:43.000
This is an interface at least based logically on making some derived data available.

03:43.000 --> 03:54.000
So you say, well, here you, class of users, here's the stuff that you're able to see go wild with any query that you can do that only uses this data.

03:54.000 --> 03:55.000
That's a traditional view database.

03:55.000 --> 03:57.000
Abstractly, you can think of a view-based databases.

03:57.000 --> 04:04.000
You have some function on the source instance or in the case of distributed views on the source instances.

04:04.000 --> 04:06.000
And this function extracts some data.

04:06.000 --> 04:09.000
That's the stuff that the user can see.

04:09.000 --> 04:15.000
Any query that only uses that stuff or is answerable based on that stuff is the restriction on queries.

04:15.000 --> 04:19.000
So I'll use some terminology in the distributed case.

04:19.000 --> 04:21.000
I'll talk about distributed views.

04:21.000 --> 04:30.000
A distributed view is just, and every local source, I have some derived data that I at least logically export from that local source.

04:30.000 --> 04:33.000
Okay, so views can be in these arbitrary functions.

04:33.000 --> 04:39.000
We'll be interested often in classes of views, like, say, CQ views.

04:39.000 --> 04:47.000
CQ, a conjunctive query D view is at every local source, I have a conjunctive query over the atoms known to that source.

04:47.000 --> 04:53.000
That's what that local data source is exploring.

04:53.000 --> 04:58.000
So the idea of this great thought exercise is to try and go beyond views.

04:58.000 --> 05:01.000
And lots of people have gone there before.

05:01.000 --> 05:05.000
And you can begin to think of lots of mechanisms that have been proposed.

05:05.000 --> 05:07.000
I mentioned some of them, access patterns.

05:07.000 --> 05:14.000
This is another way of restricting what a class of users can see that's not derived data.

05:14.000 --> 05:21.000
You say, okay, you need to give this value here to access this data from this functional API.

05:21.000 --> 05:23.000
That's different from derived data.

05:23.000 --> 05:30.000
And then, oh, so that's something that has been studied in the database literature Alan Nash and his colleagues, people at Stanford,

05:30.000 --> 05:33.000
Chen Li and Edward Chang, Deutsche National Literature.

05:33.000 --> 05:38.000
Views with access patterns is something that hasn't gotten that much study.

05:38.000 --> 05:44.000
Nash, again, and his colleagues, Antoine and some colleagues at Telecom studied this.

05:44.000 --> 05:52.000
You say you have logically some derived data, but you restrict access to traditional access methods, disciplines.

05:52.000 --> 05:56.000
Various data exchange, virtual data integration mechanisms.

05:56.000 --> 05:59.000
There's lots and lots of them in the history of databases.

05:59.000 --> 06:03.000
These can be thought of from the point of view as trying to get beyond views.

06:03.000 --> 06:08.000
There's an interesting formalism from Kautus, Deutsche, and Anose,

06:08.000 --> 06:12.000
query specification, pattern language, something like that,

06:12.000 --> 06:17.000
where you use a restriction and automaton running over the syntax tree.

06:17.000 --> 06:20.000
And you say, here are a class of users.

06:20.000 --> 06:23.000
Here are the things that you're allowed to see.

06:23.000 --> 06:24.000
Here's a number of queries.

06:24.000 --> 06:25.000
This is going beyond views.

06:25.000 --> 06:31.000
They talk about this as exporting an infinite class of views.

06:31.000 --> 06:34.000
And so this is the kind of thing I'd like to look at.

06:34.000 --> 06:38.000
I mean, I'll talk about two projects, one from a couple of years ago with Per,

06:38.000 --> 06:44.000
Lewis, Chiquet, and F.E.Somora, and another that's current work with Udy Roshovsky at Oxford,

06:44.000 --> 06:50.000
that are in the space of how do we get mechanisms that go beyond views.

06:50.000 --> 06:55.000
Okay, the first kind of mechanism, this first project,

06:55.000 --> 06:58.000
it's based on the notion of minimally informative query answering.

06:58.000 --> 07:01.000
The notion here is we specify a set of queries.

07:01.000 --> 07:03.000
We call them in the paper utility queries.

07:03.000 --> 07:07.000
These are the things that we want the user to answer.

07:07.000 --> 07:11.000
But we don't want to give a mechanism that just says you can only ask these five queries.

07:11.000 --> 07:13.000
We want something more robust.

07:13.000 --> 07:17.000
So what we say is, well, let's give out the minimally informative traditional views

07:17.000 --> 07:19.000
within a class that support these queries.

07:19.000 --> 07:21.000
I'll give an example in this slide.

07:21.000 --> 07:25.000
So here, this is something we've also discussed extensively at lunch.

07:25.000 --> 07:27.000
Dodge tool versus science.

07:27.000 --> 07:31.000
Computer science, conference centers, very theory friendly.

07:31.000 --> 07:37.000
They both have programs with different participants.

07:37.000 --> 07:39.000
Many people here have gone to both.

07:39.000 --> 07:43.000
And they have both autonomous data stores that store names of participants,

07:43.000 --> 07:44.000
which program, which year.

07:44.000 --> 07:48.000
And they get together and they say, we're going to create an interface.

07:49.000 --> 07:53.000
And we want our interfaces to support some queries that span the sources.

07:53.000 --> 07:59.000
Like, are there researchers who are attending both programs in the same year?

07:59.000 --> 08:03.000
You can write this as a conjunctive query over the union of the schemas.

08:03.000 --> 08:08.000
So it's a join between Simons participants.

08:08.000 --> 08:10.000
And we want a mechanism that will support this query,

08:10.000 --> 08:15.000
but give out the minimal information among distributed views that will support this join.

08:16.000 --> 08:20.000
So we have to formalize this notion of what it means to support a query

08:20.000 --> 08:22.000
and what minimal information means.

08:22.000 --> 08:25.000
And I've seen, I'm coming late to this program,

08:25.000 --> 08:30.000
but I've seen that a recurrent theme in this program is information,

08:30.000 --> 08:35.000
and information theory in Shannon, relative information.

08:35.000 --> 08:38.000
We're not going to use any of that.

08:38.000 --> 08:44.000
We're going to do something less quantitative

08:44.000 --> 08:47.000
because one of the things I'd like to advertise,

08:47.000 --> 08:50.000
it's Sugafan and Vianu's notion of determinacy.

08:50.000 --> 08:54.000
Sometimes in some of Dan and Paris' papers,

08:54.000 --> 08:57.000
they emphasize information theoretic determinacy.

08:57.000 --> 09:00.000
So it has a similar feel.

09:00.000 --> 09:01.000
What is determinacy?

09:01.000 --> 09:04.000
You have a query and you have a bunch of views.

09:04.000 --> 09:06.000
You say the query is determined by views.

09:06.000 --> 09:10.000
If any database, two databases that agree on the view agree on the query.

09:10.000 --> 09:12.000
Very simple definition.

09:12.000 --> 09:18.000
Another way to think of this is that the query output is a function of the view output.

09:18.000 --> 09:23.000
So we'll say that a distributed view supports a query if the query is determined by the view.

09:23.000 --> 09:27.000
But the way you want to think of determinacy is information theoretically.

09:27.000 --> 09:32.000
It says, well, these views contain all the information you need.

09:32.000 --> 09:36.000
These views have more information than you have.

09:36.000 --> 09:41.000
And the information theoretic notion is you don't care about the computation.

09:41.000 --> 09:46.000
How complex it is to reconstruct Q from V1 through VT.

09:46.000 --> 09:48.000
Who cares? V1 through VT.

09:48.000 --> 09:52.000
Have enough information to answer Q.

09:52.000 --> 09:55.000
And we'll formalize the notion that the views are minimally informative,

09:55.000 --> 09:58.000
again, using Sugafan and Vianu's notion of determinacy.

09:58.000 --> 10:05.000
We say a distributed view is minimally informative, supporting Q.

10:05.000 --> 10:10.000
Within a class of queries, see if the view supports the query.

10:10.000 --> 10:14.000
Using determinacy, Q is a function of the views.

10:14.000 --> 10:16.000
The view has to be based on queries in C.

10:16.000 --> 10:20.000
And any other distributed view, V prime, that uses queries from C,

10:20.000 --> 10:22.000
it has more information.

10:22.000 --> 10:26.000
That means that other view, V prime, determines each view in V.

10:26.000 --> 10:31.000
So remember, the notion of determinacy, if V prime determines each view in V,

10:31.000 --> 10:35.000
that somehow says V prime has more information than each view in V.

10:35.000 --> 10:37.000
And so this is the natural way.

10:37.000 --> 10:42.000
If you accept determinacy as the notion of information, capacity of a view,

10:42.000 --> 10:47.000
this is the natural way to say that these views are minimal information.

10:47.000 --> 10:51.000
So let's go to Simon's and Don's tool.

10:51.000 --> 10:56.000
At least in our minds, go to Simon's and Don's tool.

10:56.000 --> 11:01.000
They wanted to support this interface that supports this join

11:01.000 --> 11:04.000
and give the minimal information that does this.

11:04.000 --> 11:09.000
It's pretty obvious intuitively what the minimal information you need to support this query is.

11:09.000 --> 11:15.000
You need to know Simon's needs to reveal the name and the year to support this join

11:15.000 --> 11:18.000
because name and year are the join variables.

11:18.000 --> 11:20.000
They cross the join.

11:20.000 --> 11:23.000
Don's tool also has to reveal the name and year.

11:23.000 --> 11:28.000
And so what Simon's should do is they should publish the projection on name and year.

11:28.000 --> 11:31.000
And Don's tool should do the same.

11:31.000 --> 11:33.000
Give the projection on name and year.

11:33.000 --> 11:35.000
Intuitively, that's the minimal information.

11:35.000 --> 11:39.000
And in our formalism using determinacy, that's the minimal information.

11:39.000 --> 11:43.000
Does this make sense?

11:43.000 --> 11:47.000
The minimal information is just true or false.

11:47.000 --> 11:52.000
The answer to that query, it's a static notion.

11:52.000 --> 11:56.000
This is not instance determinacy.

11:56.000 --> 11:59.000
It's determinacy over all instances.

11:59.000 --> 12:04.000
That back in our notion of determinacy, it's over all d1, d and d prime.

12:04.000 --> 12:05.000
So it's a static.

12:05.000 --> 12:10.000
It's a data independent notion.

12:10.000 --> 12:15.000
So on a given instance, of course, I could say the answer is true or false and so on.

12:15.000 --> 12:19.000
But the minimal information views are views that will have the minimal information

12:19.000 --> 12:24.000
defined in terms of instance independent determinacy.

12:24.000 --> 12:26.000
I can play the same game.

12:26.000 --> 12:27.000
You give me your instance.

12:27.000 --> 12:32.000
I'm going to compute the view, which is just the answer to your query.

12:32.000 --> 12:34.000
These are autonomous data sources.

12:34.000 --> 12:37.000
These views, the distributive views are views at each source.

12:37.000 --> 12:43.000
So I can't go, Simon's is not allowed at data time, at query time, to go to Dogstool

12:43.000 --> 12:49.000
and say, you know, tell me what's going on and then export the data.

12:49.000 --> 12:55.000
This notion of distributive view says that each source has to do its own thing.

12:55.000 --> 12:56.000
It makes a lot of sense.

12:56.000 --> 12:57.000
Thank you.

12:57.000 --> 12:59.000
Yeah, but if I may.

12:59.000 --> 13:04.000
So I mean, it seems in this particular context, you want to be as respective as possible,

13:04.000 --> 13:05.000
right?

13:05.000 --> 13:07.000
So the instance level seems to be what you want to go into.

13:07.000 --> 13:11.000
And it could be something like a zero-knowledge proof like thing that's in a protocol between

13:11.000 --> 13:13.000
Simon's and Dogstool, right?

13:13.000 --> 13:14.000
Yeah.

13:14.000 --> 13:17.000
I talked, so the question about what happens.

13:17.000 --> 13:23.000
So, okay, the first thing is, so of course, if you do instance dependent things here,

13:23.000 --> 13:27.000
there's also some questions about these epistemic paradoxes.

13:27.000 --> 13:34.000
You say, no, I can't answer your query, because that would be giving out too much information.

13:34.000 --> 13:40.000
But, okay, so here there's a question about whether other mechanisms could do more than

13:40.000 --> 13:43.000
these views, which is a question I'll get to.

13:43.000 --> 13:50.000
Crypto people have looked at it, and actually, well, I've looked at it too in a couple of

13:50.000 --> 13:51.000
slides.

13:51.000 --> 14:00.000
So, okay, what's an example of our results?

14:00.000 --> 14:06.000
I won't, of course, suggest completely address your question in a couple of slides, but maybe

14:06.000 --> 14:08.000
it would be more clear.

14:08.000 --> 14:12.000
So in this paper, one of the results says you take any utility query.

14:12.000 --> 14:17.000
Not necessarily conjunct for an SQL arbitrary function on the global schema.

14:17.000 --> 14:20.000
Then these minimum of informative devues exist.

14:20.000 --> 14:25.000
I'll say a little bit more about what they look like in a few slides.

14:25.000 --> 14:32.000
For CQ utility queries, they're expressible as traditional views in relational algebra.

14:32.000 --> 14:36.000
And we show that the same holds in the presence of integrity constraints on each local source

14:36.000 --> 14:38.000
like TGDs, EGDs.

14:38.000 --> 14:42.000
So you always have these minimally informative things.

14:42.000 --> 14:49.000
And sometimes they're expressible in relational algebra, but there are CQ utility views where

14:49.000 --> 14:53.000
the minimally informative devues are not CQs themselves.

14:53.000 --> 14:56.000
So in particular, you don't know, they're not always the obvious ones, like in the previous

14:56.000 --> 14:57.000
example.

14:57.000 --> 15:02.000
I may be able, if we have time, I can give an example.

15:02.000 --> 15:06.000
We also look, within the class of CQ views, say you're committed that you're going to

15:06.000 --> 15:11.000
use CQ views, basic SQL queries, set semantics.

15:11.000 --> 15:16.000
There's, for CQ utility queries, you have minimally informative CQ views.

15:16.000 --> 15:18.000
And these are almost the obvious ones.

15:18.000 --> 15:26.000
After you minimize the utility query, they turn out to be the same as the obvious ones.

15:26.000 --> 15:29.000
So I'll come back to this a little bit later.

15:29.000 --> 15:35.000
But I wanted to say what we were doing in this paper, the perspective was to analyze the tradeoffs

15:35.000 --> 15:37.000
in view design.

15:37.000 --> 15:41.000
You look at questions of the form, are there distributed views that support this query,

15:41.000 --> 15:44.000
but which do not reveal any information about this other query?

15:44.000 --> 15:46.000
This is what we were interested here.

15:46.000 --> 15:50.000
So back to Simon's and Dogstool, but making it a little bit more abstract.

15:50.000 --> 15:54.000
Simon's has a binary relation R.

15:54.000 --> 15:57.000
Schostockstuhl has S and T binary relations.

15:57.000 --> 16:01.000
And I'm interested in supporting the intersection query.

16:01.000 --> 16:03.000
Well, obviously I could support this.

16:03.000 --> 16:07.000
I could design sources to answer Q.

16:07.000 --> 16:11.000
Each source just exports its data, all of R, all of S, all of T.

16:11.000 --> 16:15.000
But I want to know, well, is there some way to do this while keeping the query,

16:15.000 --> 16:17.000
there exists XRXX private?

16:17.000 --> 16:22.000
We analyze this for several notions of privacy, but one notion of privacy would be,

16:22.000 --> 16:29.000
on no instance, shouldn't the attacker be, should the external party know whether there exists XRXX is true?

16:29.000 --> 16:34.000
It's sort of a negative version of privacy that has been in the database theory literature.

16:34.000 --> 16:38.000
I think it goes back to Mendelssohn as a student.

16:38.000 --> 16:45.000
So intuitively, any views that support Q must disclose P on some instance.

16:45.000 --> 16:50.000
And okay, it's actually not so, this example with no integrity constraints is not so difficult,

16:50.000 --> 16:54.000
but using the prior results, we can compute the minimal information views,

16:54.000 --> 16:57.000
show that the minimal information views disclose this thing,

16:57.000 --> 17:01.000
and therefore, nothing you can do that supports Q,

17:01.000 --> 17:06.000
there's nothing you can do that can support Q, but make P a secret.

17:06.000 --> 17:08.000
That's a simple case.

17:08.000 --> 17:16.000
We also, well, we have several examples where the privacy utility query is less trivial.

17:16.000 --> 17:21.000
Here's one of them, we look at the case where there's partial synchronization mechanisms.

17:22.000 --> 17:25.000
We look mostly at replication as a synchronization mechanism.

17:25.000 --> 17:28.000
Now Simons and Dogstall are not completely autonomous.

17:28.000 --> 17:36.000
There's a relation S, the relation S that is in the query is replicated between Simons and Dogstall.

17:36.000 --> 17:38.000
But nothing else, there's no other mechanism.

17:38.000 --> 17:43.000
So obviously they need to communicate as data updates come in in order to do this.

17:43.000 --> 17:47.000
And we have the same utility query, and now we ask the same question,

17:47.000 --> 17:53.000
can we support this query while keeping this, there exists XRX private?

17:53.000 --> 17:59.000
And the answer now turns out to be yes, there is an interface mechanism,

17:59.000 --> 18:04.000
actually a view of a certain sort that can achieve this trade-off.

18:04.000 --> 18:09.000
It can support Q while keeping P a secret.

18:09.000 --> 18:16.000
So this is just meant like what were we trying to do and what kinds of results we have.

18:16.000 --> 18:21.000
We actually have a general result about what you can do with certain kinds of replication

18:21.000 --> 18:26.000
in managing these trade-offs between utility and secrecy.

18:26.000 --> 18:30.000
So what is the moral I wanted to give?

18:30.000 --> 18:38.000
Well, first, it's not really an answer, but it's my attempt at an answer.

18:38.000 --> 18:43.000
We were getting at the idea of comparing the expressiveness of different interface mechanisms.

18:43.000 --> 18:50.000
So in this case, what can you do with a CQ view versus what can you do with relational algebra views?

18:50.000 --> 18:52.000
What can you do with arbitrary functions?

18:52.000 --> 18:57.000
I thought this is something that is an interesting direction that I haven't seen much of.

18:57.000 --> 19:01.000
And you can look at the same thing with more interactive method mechanism.

19:01.000 --> 19:05.000
We didn't do it, but it was an obvious thing as well.

19:05.000 --> 19:11.000
Suppose you have access methods, for instance, you can now, and now you can interactively ask multiple queries.

19:11.000 --> 19:14.000
And then you achieve these other kinds of trade-offs.

19:14.000 --> 19:19.000
And then the second thing I want to highlight is this notion of information theoretic determinacy,

19:19.000 --> 19:23.000
the database theorists information theory.

19:23.000 --> 19:28.000
This has been used certainly by a number of people.

19:28.000 --> 19:34.000
Paris and Dan and other people at Washington used it in the pre-oppressing work.

19:34.000 --> 19:43.000
I've used it in many papers, but quickly on information disclosure with Balder, Pierre, other people, also KR people at Oxford.

19:43.000 --> 19:46.000
I think also Daniel Kieffer in some of his work.

19:46.000 --> 19:48.000
Yes, yes.

19:48.000 --> 19:51.000
But I don't think it's really been developed rigorously and uniformly.

19:51.000 --> 19:55.000
Here you have some information lattice on views.

19:55.000 --> 20:00.000
That's the idea actually in the pricing work and in our work.

20:00.000 --> 20:03.000
And you can begin to explore this.

20:04.000 --> 20:13.000
So I'll come back to this in a little bit, but I want to talk now a little bit about what's the idea of this other work about indistinguishability this year.

20:13.000 --> 20:15.000
And it's motivated.

20:15.000 --> 20:21.000
Okay, so first, an indistinguishability relation is just an equivalence relation on databases.

20:21.000 --> 20:27.000
I say here are the two, here's the pairs of databases that are equivalent.

20:27.000 --> 20:30.000
And this gives an interface.

20:30.000 --> 20:32.000
Somebody is interacting with the database.

20:32.000 --> 20:34.000
What is the queries they could answer?

20:34.000 --> 20:36.000
Well, there's two possible semantics.

20:36.000 --> 20:46.000
One is that they can answer any query using the certain answer semantics and the certain answer semantics would be, well, what they're really seeing is the entire equivalence class of this database.

20:46.000 --> 20:50.000
And they get the intersection of the answers of the database.

20:50.000 --> 20:53.000
There's another semantics which says, oh, it's the answerability semantics.

20:53.000 --> 20:59.000
They can only ask queries where the answer is invariant under this equivalence relation.

20:59.000 --> 21:06.000
So this would be more like what's called feasibility in access patterns or answerability in views.

21:06.000 --> 21:10.000
So the main point is you have some way of specifying an equivalence relation.

21:10.000 --> 21:14.000
I'll talk about some ways you could specify an equivalence relation that's giving you an interface.

21:14.000 --> 21:22.000
And it's interesting in that it's a way of giving an interface that's different from what we're used to.

21:22.000 --> 21:25.000
Okay, you can of course think of this as a view.

21:25.000 --> 21:33.000
A view, I said from this general mathematical point of view, it's a function on the instance or the local instance that exports some stuff.

21:33.000 --> 21:37.000
And you can say what I'm exporting is the equivalence class.

21:37.000 --> 21:39.000
But of course, we're representing it differently.

21:39.000 --> 21:43.000
Let's give you an example.

21:43.000 --> 21:49.000
I can say G and G prime are indistinguishable if they have the same triangles.

21:49.000 --> 21:52.000
So these are two graph databases.

21:52.000 --> 22:01.000
I can say for all x1, x2, x3, they're a triangle in database G if and only if they're a triangle in G prime.

22:01.000 --> 22:05.000
And this, that's an equivalence relation.

22:05.000 --> 22:08.000
It's actually a first order indistinguishability relation.

22:08.000 --> 22:13.000
It's given by a first order sentence in the language of two copies of the schema.

22:13.000 --> 22:17.000
So it's first order, not in the sense of what we usually say.

22:17.000 --> 22:24.000
Now, if you take a typical first order sentence in the language of two schemas, it's not going to define an equivalence relation.

22:24.000 --> 22:27.000
This is a semantic property.

22:27.000 --> 22:36.000
These things for all x1, x2, x3, and if and only if between G and G prime, that's going to be an equivalence relation, but other things are not.

22:36.000 --> 22:42.000
So I'm interested in the first order sentences in two schemas that will do this.

22:42.000 --> 22:46.000
And I can generalize whether triangle example is one of them.

22:46.000 --> 22:48.000
You can give me any relational algebra views.

22:48.000 --> 22:52.000
They give a first order indistinguishability relation, the same kind of thing.

22:52.000 --> 22:55.000
Well, one database satisfies the views.

22:55.000 --> 23:03.000
For every tuple in the union of the databases, it's in the view result in one if and only if it's the view result of the other.

23:03.000 --> 23:12.000
I'm using this prime notation just like the G and G prime to say the prime copy of the database agrees with the unprime copy on this derived data.

23:12.000 --> 23:13.000
Michael?

23:13.000 --> 23:14.000
Yeah?

23:14.000 --> 23:17.000
The universal quantifiers, are they quantifying over which domain?

23:17.000 --> 23:23.000
They're quantifying over the union of the active domains.

23:23.000 --> 23:25.000
So this came up in the prior work.

23:25.000 --> 23:31.000
I said these minimally informative views exist for arbitrary utility queries.

23:31.000 --> 23:32.000
How do they work?

23:32.000 --> 23:37.000
Actually, the way we can present them is, as I said, indistinguishability relation.

23:37.000 --> 23:43.000
Obviously, we can show that you can't always get, in very natural cases, you can't get relational algebra.

23:43.000 --> 23:47.000
But you can always get this indistinguishability relation presentation.

23:47.000 --> 23:52.000
Actually, I think a second order indistinguishability relation.

23:52.000 --> 23:55.000
And then there was this example I talked about with replication.

23:55.000 --> 24:00.000
I said, well, we could support Q without revealing P.

24:00.000 --> 24:01.000
How did we do this?

24:01.000 --> 24:04.000
We needed some interface mechanism beyond relational algebra views.

24:04.000 --> 24:07.000
We could show that you couldn't use any generic query to do this.

24:07.000 --> 24:13.000
But we define a simple indistinguishability relation that actually looks at the data values.

24:13.000 --> 24:16.000
And we show that's the way you can achieve this trade-off.

24:16.000 --> 24:25.000
So you can achieve certain trade-offs with indistinguishability that you can't achieve with traditional views.

24:25.000 --> 24:27.000
Okay, this is a super general notion.

24:27.000 --> 24:33.000
We studied this mostly over infinite structures, focusing on first order and infinitary logic.

24:33.000 --> 24:43.000
There are a few results that I can mention that apply to the finite case, to finite models, to databases.

24:43.000 --> 24:47.000
I said that traditional relational algebra views give a first order indistinguishability relation.

24:47.000 --> 24:52.000
And you can ask, well, what are the other first order indistinguishability relations?

24:52.000 --> 24:59.000
Well, nested relational calculus gives you another class of first order indistinguishability relations.

24:59.000 --> 25:04.000
I don't want to explain what nested data is, a nested relational calculus, but I'll explain by example.

25:04.000 --> 25:11.000
If I have a binary relation, rxy, I want to export all the adjacency sets of elements in my database.

25:11.000 --> 25:14.000
This is a set of sets for every element.

25:14.000 --> 25:17.000
I take the set of things that are adjacent to it.

25:17.000 --> 25:20.000
And then I take the set of sets by varying the x.

25:20.000 --> 25:21.000
Well, that's a set of sets.

25:21.000 --> 25:29.000
I can say two databases agree on the set of sets in first order logic in this dual signature, the r and r prime signature.

25:29.000 --> 25:32.000
For all x, there exists x prime.

25:32.000 --> 25:39.000
For every node in one, there's a node in the other database whose adjacency set agrees.

25:39.000 --> 25:46.000
So in general, okay, I can do sets of sets of sets in the same way.

25:46.000 --> 25:48.000
That's the general idea of nested relational calculus.

25:48.000 --> 25:50.000
I build up these sets of sets of sets.

25:50.000 --> 25:55.000
You know, it's a different query language and agreement on a nested relational calculus query.

25:55.000 --> 26:04.000
So let me jump since I'm running low on time to the open question here.

26:04.000 --> 26:08.000
We have various results about this, but an intriguing open question is,

26:08.000 --> 26:14.000
is every first order indistinguishability relation given by nested relational calculus?

26:14.000 --> 26:20.000
We look at the infinite case where this is not true and we find lots of phenomenon that go beyond nested relational calculus.

26:20.000 --> 26:27.000
And of course, we don't use the word nested relational calculus because it's geared towards a different audience.

26:27.000 --> 26:30.000
This is a preservation question.

26:30.000 --> 26:33.000
I have a first order sentence in the language of two schemas.

26:33.000 --> 26:35.000
I impose some semantic property.

26:35.000 --> 26:39.000
Here's a syntax, nested relational calculus views that enforces it.

26:39.000 --> 26:45.000
I want to know if everything that has this semantic property is enforced by this text.

26:45.000 --> 26:52.000
Okay, so first I'll say this indistinguishability, the bottom line, this indistinguishability relations.

26:52.000 --> 27:02.000
They make the world of traditional views look very small because you can begin to see lots of other ways of creating interfaces that are beyond views.

27:02.000 --> 27:09.000
And it gets at this issue that comes up often in descriptive complexity theory and descriptive set theory,

27:09.000 --> 27:13.000
of going from an equivalence relation to a canonical representative.

27:13.000 --> 27:18.000
For instance, if you look at various notions of elementary equivalence, like n variable equivalence,

27:18.000 --> 27:21.000
you have a nicely described equivalence relation.

27:21.000 --> 27:26.000
You want to know how efficient it is to export a representative of this equivalence relation.

27:26.000 --> 27:30.000
You have a nice representation of sort of the dynamic notion.

27:30.000 --> 27:33.000
You want to know, does that mean that there's a nice representative?

27:33.000 --> 27:37.000
You can choose a representative concisely.

27:37.000 --> 27:43.000
So I want to stop now with the great thoughts stuff, if you can give me a second to do it.

27:43.000 --> 27:48.000
Okay, so I want to go back to great thoughts.

27:48.000 --> 27:51.000
And the truth of it is, I saw Mulham's talk last week,

27:51.000 --> 27:57.000
and he gave an overview of relational databases, and it led to some great pronouncement.

27:57.000 --> 28:02.000
You know, relational AI is great by relational AI, and other profound thoughts.

28:02.000 --> 28:08.000
And then I saw Joe's talk, and he overviewed relational databases for 15 years,

28:08.000 --> 28:11.000
and he gave his own pronouncements.

28:11.000 --> 28:18.000
Morals, I love Hasselt, and there's important problems with synchronization

28:18.000 --> 28:21.000
that need to be studied, and deadline is great.

28:21.000 --> 28:24.000
And I thought I should have a slide that talks about 15 years databases,

28:24.000 --> 28:27.000
and then has some profound conclusion.

28:27.000 --> 28:33.000
What I want to say is, well, in the first 40 years, this notion of logical interface,

28:33.000 --> 28:40.000
expanding it, and notions of comparing interfaces, you find it relatively often in pods.

28:40.000 --> 28:46.000
You know, Rick Hall did some various things about the notion of information capacity

28:46.000 --> 28:50.000
that I find very interesting at the level of comparing schemas.

28:50.000 --> 28:54.000
And then, of course, there's been a lot of work over 40 years

28:54.000 --> 28:58.000
at looking at funky new ways of defining interfaces.

28:58.000 --> 29:02.000
But in the last, I'd say, certainly five years, not so much.

29:02.000 --> 29:05.000
So I think there is some need to look at this.

29:05.000 --> 29:09.000
I wouldn't say, you know, looking at the work in this workshop,

29:09.000 --> 29:14.000
I don't say that people should stop working on machine learning

29:14.000 --> 29:17.000
and relational algebra like Zach is, and look about this.

29:17.000 --> 29:21.000
A little bit maybe goes a long way, and maybe there was too much of this at one point.

29:21.000 --> 29:26.000
But I think going back every few years and looking at this is a good thing to do.

29:26.000 --> 29:30.000
Certainly, this work has been very influential outside of databases.

29:30.000 --> 29:31.000
Thank you.

29:31.000 --> 29:57.000
So we haven't looked in this. I think this model is just, you know,

29:57.000 --> 30:01.000
I've shown this stuff to some people who work on privacy

30:01.000 --> 30:05.000
say this is ridiculously restrictive, which I think is the right answer.

30:05.000 --> 30:10.000
I mean, our notion that I showed you of keeping something secret

30:10.000 --> 30:14.000
is on no instance should the attacker learn the database,

30:14.000 --> 30:18.000
which is something that comes in the database theory literature.

30:18.000 --> 30:20.000
Also, it's in the KR literature.

30:20.000 --> 30:26.000
But of course, in the end, differential privacy is much weaker,

30:27.000 --> 30:30.000
and in general, the reaction is, look, you know,

30:30.000 --> 30:34.000
I don't care that there's some one database out there in the world.

30:34.000 --> 30:37.000
It's mostly used for aggregated queries.

30:37.000 --> 30:43.000
So if you have views like non-aggregated views, the notion is not obvious, but yeah.

30:46.000 --> 30:49.000
Yeah, so first of all, very interesting.

30:49.000 --> 30:51.000
So I got your framework and the results.

30:51.000 --> 30:52.000
It was amazing.

30:53.000 --> 30:54.000
Quick question.

30:54.000 --> 30:57.000
I didn't get a chance to do justice to the distinguishly results,

30:57.000 --> 30:59.000
but I can tell that it's not important.

30:59.000 --> 31:02.000
But can you do justice to communication complexity?

31:02.000 --> 31:03.000
Have you looked into this?

31:03.000 --> 31:07.000
Yeah, I mean, this, so no, well, not really.

31:07.000 --> 31:10.000
I mean, the proofs have a very similar feel to communication.

31:10.000 --> 31:13.000
We're exploiting autonomy of this.

31:13.000 --> 31:18.000
And you would think once we put in some interaction between the two sources,

31:18.000 --> 31:21.000
we're in extreme case of communication complexity.

31:21.000 --> 31:24.000
Because there's no communication between the sources at all.

31:24.000 --> 31:30.000
Well, they both published something in common, so they can compute a few.

31:30.000 --> 31:32.000
Maybe it's a one round, a half round.

31:32.000 --> 31:33.000
I don't know.

31:33.000 --> 31:36.000
They looked at all sorts of variations, which I'm not familiar with.

31:36.000 --> 31:37.000
Yeah, I agree.

31:37.000 --> 31:39.000
It's on my radar to look at.

31:45.000 --> 31:48.000
So, like, I had a similar question before, right?

31:49.000 --> 31:53.000
Like, yes, it's a differential privacy as a weaker model

31:53.000 --> 31:56.000
because we only have probabilistic guarantees.

31:56.000 --> 32:00.000
So, but your model is also in another way more expressive, right?

32:00.000 --> 32:02.000
This indistinguishability in relation to autonomy.

32:02.000 --> 32:06.000
Like, differential privacy is essentially like a very simple

32:06.000 --> 32:08.000
in what sort of distinguishability we're like.

32:08.000 --> 32:10.000
But there's still no probabilities involved,

32:10.000 --> 32:13.000
even in the indistinguishability notion, right?

32:13.000 --> 32:14.000
No, no, I know, right?

32:14.000 --> 32:18.000
I mean, like, right, your model is not just stricter,

32:18.000 --> 32:23.000
but also more expressive in what we consider to be indistinguishable, right?

32:23.000 --> 32:24.000
Yeah.

32:24.000 --> 32:27.000
But there's, I'm mangling two works, right?

32:27.000 --> 32:30.000
So, on the one hand, you have this notion of privacy.

32:30.000 --> 32:31.000
That's it.

32:31.000 --> 32:32.000
Yeah.

32:32.000 --> 32:35.000
On the other hand, we can be flexible about the view mechanisms

32:35.000 --> 32:39.000
and look at these more powerful mechanisms, right?

32:39.000 --> 32:41.000
So, that's true.

32:41.000 --> 32:44.000
Some of it, I just want to make clear that some of this trade-off

32:44.000 --> 32:45.000
is in two different works.

32:45.000 --> 32:46.000
But go ahead.

32:46.000 --> 32:48.000
Yes, I agree, right?

32:48.000 --> 32:51.000
So, I know that indistinguishability was basically like a query,

32:51.000 --> 32:53.000
like a trust with the privacy.

32:53.000 --> 32:54.000
Yeah.

32:54.000 --> 32:59.000
But it could also be, obviously, used for like a privacy mechanism.

32:59.000 --> 33:00.000
Yeah.

33:02.000 --> 33:05.000
I remember I said that I won't be ready for great thoughts

33:05.000 --> 33:10.000
tomorrow afternoon, or possibly Monday, or maybe next week.

33:10.000 --> 33:11.000
Yeah.

33:11.000 --> 33:14.000
So, can you comment a bit about the complexity of computing

33:14.000 --> 33:18.000
that is used, because the term is unsilable, right?

33:18.000 --> 33:20.000
So, in the...

33:20.000 --> 33:23.000
Well, rather than very easy, you can just compute that.

33:23.000 --> 33:24.000
You can just...

33:24.000 --> 33:26.000
So, in the case of CQ utility queries, you don't need to decide

33:26.000 --> 33:29.000
the term as CQ, you can get these minimal information use,

33:29.000 --> 33:33.000
and actually, in key time, you can create.

33:33.000 --> 33:35.000
For other queries?

33:35.000 --> 33:38.000
Well, for other queries, so, for other queries,

33:38.000 --> 33:40.000
you don't actually know what the representation is.

33:40.000 --> 33:42.000
So, Pierre, do you want to contradict this?

33:42.000 --> 33:44.000
Minimization of the term.

33:44.000 --> 33:45.000
Okay.

33:45.000 --> 33:46.000
So, yeah.

33:46.000 --> 33:47.000
So, actually...

33:47.000 --> 33:48.000
So, if the...

33:48.000 --> 33:49.000
If...

33:49.000 --> 33:50.000
Well, okay.

33:50.000 --> 33:51.000
So...

33:51.000 --> 33:52.000
Well, I mean...

33:52.000 --> 33:53.000
Okay.

33:53.000 --> 33:55.000
So, you can get relational algebra views without doing minimum...

33:55.000 --> 33:56.000
Minimization.

33:56.000 --> 33:57.000
Pierre.

33:57.000 --> 33:58.000
Yeah, but you...

33:58.000 --> 33:59.000
If you want to get the CQ...

33:59.000 --> 34:02.000
So, it depends what format you want the views in.

34:02.000 --> 34:03.000
You can...

34:03.000 --> 34:04.000
Yeah.

34:06.000 --> 34:07.000
You do get the minimal one.

34:07.000 --> 34:09.000
You just don't have it as a CQ.

34:09.000 --> 34:11.000
So, it depends on what represent...

34:11.000 --> 34:14.000
I mean, you know, if I've understood your comment correctly,

34:14.000 --> 34:15.000
there's two results.

34:15.000 --> 34:17.000
One, it says, okay, I...

34:17.000 --> 34:19.000
I can get these relational algebra views.

34:19.000 --> 34:21.000
And there, we use this...

34:21.000 --> 34:25.000
This construction about getting these samples.

34:25.000 --> 34:27.000
And I think you can do this in key time.

34:27.000 --> 34:28.000
It's...

34:28.000 --> 34:29.000
It is minimal information.

34:29.000 --> 34:30.000
It's just...

34:30.000 --> 34:31.000
If you want to...

34:31.000 --> 34:33.000
There's another result that says I can get CQ views,

34:33.000 --> 34:35.000
and there I need to minimize the global word,

34:35.000 --> 34:37.000
which, yes, Pierre said, is expensive.

34:37.000 --> 34:40.000
But then, after you get these minimal views,

34:40.000 --> 34:43.000
you have to see whether you can do disclosure.

34:43.000 --> 34:48.000
And there, we have some results on this for the case

34:48.000 --> 34:50.000
without constraints.

34:50.000 --> 34:52.000
We know how to do it.

34:52.000 --> 34:54.000
I mean, we know there you just look at the minimal...

34:54.000 --> 34:55.000
At the...

34:55.000 --> 34:56.000
At this canonical...

34:56.000 --> 34:59.000
The canonical instance.

34:59.000 --> 35:01.000
And then with constraints,

35:01.000 --> 35:04.000
I don't remember whether we have complexity.

35:04.000 --> 35:05.000
Yes, yeah.

35:05.000 --> 35:07.000
We have some abstracting constraints.

35:07.000 --> 35:09.000
Like guarded constraints.

35:09.000 --> 35:11.000
If you got a little bit of...

