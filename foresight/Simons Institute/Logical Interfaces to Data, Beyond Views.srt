1
00:00:00,000 --> 00:00:04,000
Oh, there was one that your colleague helped me with earlier, it's now gone.

2
00:00:04,000 --> 00:00:05,000
No, no, that's right.

3
00:00:11,000 --> 00:00:12,000
Of course.

4
00:00:30,000 --> 00:00:49,000
Can you hear me?

5
00:00:49,000 --> 00:00:55,000
Most of you have heard about this notion of great thoughts time.

6
00:00:55,000 --> 00:01:02,000
We were discussing it with what kind of at much ideas you have imposed a discipline on Friday afternoons after lunch.

7
00:01:02,000 --> 00:01:05,000
You only think about great thoughts.

8
00:01:05,000 --> 00:01:16,000
And I had the notion that I and also with you, I think great thoughts about the foundations of data interfaces.

9
00:01:16,000 --> 00:01:21,000
And that radically rethinking the notion of logical interface to data.

10
00:01:21,000 --> 00:01:23,000
Friday afternoon.

11
00:01:24,000 --> 00:01:26,000
Thursday.

12
00:01:26,000 --> 00:01:36,000
I'm not Richard hamming, so I need some kind of warm up thinking maybe some trivial thoughts, maybe mediocre thoughts as a kind of stretching exercise.

13
00:01:36,000 --> 00:01:38,000
And so that's what this talk is.

14
00:01:38,000 --> 00:01:46,000
I'm going to go over some projects which I think will will maybe give the notion of the goal of rethinking interfaces to data.

15
00:01:46,000 --> 00:01:49,000
And that will prime the pump for not even for questions.

16
00:01:49,000 --> 00:01:51,000
I won't be at peak.

17
00:01:51,000 --> 00:01:55,000
Great thoughts time by question time, but maybe by tomorrow afternoon.

18
00:01:55,000 --> 00:01:57,000
I'll be ready for great thoughts.

19
00:01:57,000 --> 00:02:03,000
So first I have to explain what I mean by an interface to data because this is what I want to rethink.

20
00:02:03,000 --> 00:02:10,000
Well, an interface to data in general is something you have a class of users and you want to restrict you have some source data.

21
00:02:10,000 --> 00:02:17,000
And you want to restrict the kind of queries for that class of users that they can answer.

22
00:02:17,000 --> 00:02:19,000
So I'll give some examples of this later.

23
00:02:19,000 --> 00:02:22,000
This is not what we normally think of.

24
00:02:22,000 --> 00:02:25,000
Maybe this is not even the best way to think of an interface.

25
00:02:25,000 --> 00:02:34,000
You normally think of an interface as maybe a layer like an anthology layer where you have a different vocabulary, different data model or different API that users have.

26
00:02:34,000 --> 00:02:39,000
But from the point of view of expressiveness, this is, I think, you know, one way to think of these interfaces.

27
00:02:39,000 --> 00:02:47,000
The bottom line of whatever you give to users, restricted language, different data model is that there's a limit on what they can ask to the source data.

28
00:02:47,000 --> 00:02:52,000
And you can begin to compare different interfaces this way.

29
00:02:52,000 --> 00:02:57,000
You know, one person uses this vocabulary, one uses this data model, one uses this amount.

30
00:02:57,000 --> 00:03:08,000
If you want to compare them, you'd compare based on what class of queries the user can extract, what information they can extract from the source database.

31
00:03:08,000 --> 00:03:14,000
And we'll also look at this in the setting of multiple databases, autonomous distributed over the world.

32
00:03:14,000 --> 00:03:21,000
Then an interface will be a restriction on what users can ask to the global database, the union of the sources.

33
00:03:21,000 --> 00:03:25,000
But it will have to be compatible with this notion of autonomy.

34
00:03:25,000 --> 00:03:31,000
It should be something that factors into an interface at each source.

35
00:03:31,000 --> 00:03:37,000
So there'll be examples later, but the canonical example is traditional database views, say SQL views.

36
00:03:37,000 --> 00:03:43,000
This is an interface at least based logically on making some derived data available.

37
00:03:43,000 --> 00:03:54,000
So you say, well, here you, class of users, here's the stuff that you're able to see go wild with any query that you can do that only uses this data.

38
00:03:54,000 --> 00:03:55,000
That's a traditional view database.

39
00:03:55,000 --> 00:03:57,000
Abstractly, you can think of a view-based databases.

40
00:03:57,000 --> 00:04:04,000
You have some function on the source instance or in the case of distributed views on the source instances.

41
00:04:04,000 --> 00:04:06,000
And this function extracts some data.

42
00:04:06,000 --> 00:04:09,000
That's the stuff that the user can see.

43
00:04:09,000 --> 00:04:15,000
Any query that only uses that stuff or is answerable based on that stuff is the restriction on queries.

44
00:04:15,000 --> 00:04:19,000
So I'll use some terminology in the distributed case.

45
00:04:19,000 --> 00:04:21,000
I'll talk about distributed views.

46
00:04:21,000 --> 00:04:30,000
A distributed view is just, and every local source, I have some derived data that I at least logically export from that local source.

47
00:04:30,000 --> 00:04:33,000
Okay, so views can be in these arbitrary functions.

48
00:04:33,000 --> 00:04:39,000
We'll be interested often in classes of views, like, say, CQ views.

49
00:04:39,000 --> 00:04:47,000
CQ, a conjunctive query D view is at every local source, I have a conjunctive query over the atoms known to that source.

50
00:04:47,000 --> 00:04:53,000
That's what that local data source is exploring.

51
00:04:53,000 --> 00:04:58,000
So the idea of this great thought exercise is to try and go beyond views.

52
00:04:58,000 --> 00:05:01,000
And lots of people have gone there before.

53
00:05:01,000 --> 00:05:05,000
And you can begin to think of lots of mechanisms that have been proposed.

54
00:05:05,000 --> 00:05:07,000
I mentioned some of them, access patterns.

55
00:05:07,000 --> 00:05:14,000
This is another way of restricting what a class of users can see that's not derived data.

56
00:05:14,000 --> 00:05:21,000
You say, okay, you need to give this value here to access this data from this functional API.

57
00:05:21,000 --> 00:05:23,000
That's different from derived data.

58
00:05:23,000 --> 00:05:30,000
And then, oh, so that's something that has been studied in the database literature Alan Nash and his colleagues, people at Stanford,

59
00:05:30,000 --> 00:05:33,000
Chen Li and Edward Chang, Deutsche National Literature.

60
00:05:33,000 --> 00:05:38,000
Views with access patterns is something that hasn't gotten that much study.

61
00:05:38,000 --> 00:05:44,000
Nash, again, and his colleagues, Antoine and some colleagues at Telecom studied this.

62
00:05:44,000 --> 00:05:52,000
You say you have logically some derived data, but you restrict access to traditional access methods, disciplines.

63
00:05:52,000 --> 00:05:56,000
Various data exchange, virtual data integration mechanisms.

64
00:05:56,000 --> 00:05:59,000
There's lots and lots of them in the history of databases.

65
00:05:59,000 --> 00:06:03,000
These can be thought of from the point of view as trying to get beyond views.

66
00:06:03,000 --> 00:06:08,000
There's an interesting formalism from Kautus, Deutsche, and Anose,

67
00:06:08,000 --> 00:06:12,000
query specification, pattern language, something like that,

68
00:06:12,000 --> 00:06:17,000
where you use a restriction and automaton running over the syntax tree.

69
00:06:17,000 --> 00:06:20,000
And you say, here are a class of users.

70
00:06:20,000 --> 00:06:23,000
Here are the things that you're allowed to see.

71
00:06:23,000 --> 00:06:24,000
Here's a number of queries.

72
00:06:24,000 --> 00:06:25,000
This is going beyond views.

73
00:06:25,000 --> 00:06:31,000
They talk about this as exporting an infinite class of views.

74
00:06:31,000 --> 00:06:34,000
And so this is the kind of thing I'd like to look at.

75
00:06:34,000 --> 00:06:38,000
I mean, I'll talk about two projects, one from a couple of years ago with Per,

76
00:06:38,000 --> 00:06:44,000
Lewis, Chiquet, and F.E.Somora, and another that's current work with Udy Roshovsky at Oxford,

77
00:06:44,000 --> 00:06:50,000
that are in the space of how do we get mechanisms that go beyond views.

78
00:06:50,000 --> 00:06:55,000
Okay, the first kind of mechanism, this first project,

79
00:06:55,000 --> 00:06:58,000
it's based on the notion of minimally informative query answering.

80
00:06:58,000 --> 00:07:01,000
The notion here is we specify a set of queries.

81
00:07:01,000 --> 00:07:03,000
We call them in the paper utility queries.

82
00:07:03,000 --> 00:07:07,000
These are the things that we want the user to answer.

83
00:07:07,000 --> 00:07:11,000
But we don't want to give a mechanism that just says you can only ask these five queries.

84
00:07:11,000 --> 00:07:13,000
We want something more robust.

85
00:07:13,000 --> 00:07:17,000
So what we say is, well, let's give out the minimally informative traditional views

86
00:07:17,000 --> 00:07:19,000
within a class that support these queries.

87
00:07:19,000 --> 00:07:21,000
I'll give an example in this slide.

88
00:07:21,000 --> 00:07:25,000
So here, this is something we've also discussed extensively at lunch.

89
00:07:25,000 --> 00:07:27,000
Dodge tool versus science.

90
00:07:27,000 --> 00:07:31,000
Computer science, conference centers, very theory friendly.

91
00:07:31,000 --> 00:07:37,000
They both have programs with different participants.

92
00:07:37,000 --> 00:07:39,000
Many people here have gone to both.

93
00:07:39,000 --> 00:07:43,000
And they have both autonomous data stores that store names of participants,

94
00:07:43,000 --> 00:07:44,000
which program, which year.

95
00:07:44,000 --> 00:07:48,000
And they get together and they say, we're going to create an interface.

96
00:07:49,000 --> 00:07:53,000
And we want our interfaces to support some queries that span the sources.

97
00:07:53,000 --> 00:07:59,000
Like, are there researchers who are attending both programs in the same year?

98
00:07:59,000 --> 00:08:03,000
You can write this as a conjunctive query over the union of the schemas.

99
00:08:03,000 --> 00:08:08,000
So it's a join between Simons participants.

100
00:08:08,000 --> 00:08:10,000
And we want a mechanism that will support this query,

101
00:08:10,000 --> 00:08:15,000
but give out the minimal information among distributed views that will support this join.

102
00:08:16,000 --> 00:08:20,000
So we have to formalize this notion of what it means to support a query

103
00:08:20,000 --> 00:08:22,000
and what minimal information means.

104
00:08:22,000 --> 00:08:25,000
And I've seen, I'm coming late to this program,

105
00:08:25,000 --> 00:08:30,000
but I've seen that a recurrent theme in this program is information,

106
00:08:30,000 --> 00:08:35,000
and information theory in Shannon, relative information.

107
00:08:35,000 --> 00:08:38,000
We're not going to use any of that.

108
00:08:38,000 --> 00:08:44,000
We're going to do something less quantitative

109
00:08:44,000 --> 00:08:47,000
because one of the things I'd like to advertise,

110
00:08:47,000 --> 00:08:50,000
it's Sugafan and Vianu's notion of determinacy.

111
00:08:50,000 --> 00:08:54,000
Sometimes in some of Dan and Paris' papers,

112
00:08:54,000 --> 00:08:57,000
they emphasize information theoretic determinacy.

113
00:08:57,000 --> 00:09:00,000
So it has a similar feel.

114
00:09:00,000 --> 00:09:01,000
What is determinacy?

115
00:09:01,000 --> 00:09:04,000
You have a query and you have a bunch of views.

116
00:09:04,000 --> 00:09:06,000
You say the query is determined by views.

117
00:09:06,000 --> 00:09:10,000
If any database, two databases that agree on the view agree on the query.

118
00:09:10,000 --> 00:09:12,000
Very simple definition.

119
00:09:12,000 --> 00:09:18,000
Another way to think of this is that the query output is a function of the view output.

120
00:09:18,000 --> 00:09:23,000
So we'll say that a distributed view supports a query if the query is determined by the view.

121
00:09:23,000 --> 00:09:27,000
But the way you want to think of determinacy is information theoretically.

122
00:09:27,000 --> 00:09:32,000
It says, well, these views contain all the information you need.

123
00:09:32,000 --> 00:09:36,000
These views have more information than you have.

124
00:09:36,000 --> 00:09:41,000
And the information theoretic notion is you don't care about the computation.

125
00:09:41,000 --> 00:09:46,000
How complex it is to reconstruct Q from V1 through VT.

126
00:09:46,000 --> 00:09:48,000
Who cares? V1 through VT.

127
00:09:48,000 --> 00:09:52,000
Have enough information to answer Q.

128
00:09:52,000 --> 00:09:55,000
And we'll formalize the notion that the views are minimally informative,

129
00:09:55,000 --> 00:09:58,000
again, using Sugafan and Vianu's notion of determinacy.

130
00:09:58,000 --> 00:10:05,000
We say a distributed view is minimally informative, supporting Q.

131
00:10:05,000 --> 00:10:10,000
Within a class of queries, see if the view supports the query.

132
00:10:10,000 --> 00:10:14,000
Using determinacy, Q is a function of the views.

133
00:10:14,000 --> 00:10:16,000
The view has to be based on queries in C.

134
00:10:16,000 --> 00:10:20,000
And any other distributed view, V prime, that uses queries from C,

135
00:10:20,000 --> 00:10:22,000
it has more information.

136
00:10:22,000 --> 00:10:26,000
That means that other view, V prime, determines each view in V.

137
00:10:26,000 --> 00:10:31,000
So remember, the notion of determinacy, if V prime determines each view in V,

138
00:10:31,000 --> 00:10:35,000
that somehow says V prime has more information than each view in V.

139
00:10:35,000 --> 00:10:37,000
And so this is the natural way.

140
00:10:37,000 --> 00:10:42,000
If you accept determinacy as the notion of information, capacity of a view,

141
00:10:42,000 --> 00:10:47,000
this is the natural way to say that these views are minimal information.

142
00:10:47,000 --> 00:10:51,000
So let's go to Simon's and Don's tool.

143
00:10:51,000 --> 00:10:56,000
At least in our minds, go to Simon's and Don's tool.

144
00:10:56,000 --> 00:11:01,000
They wanted to support this interface that supports this join

145
00:11:01,000 --> 00:11:04,000
and give the minimal information that does this.

146
00:11:04,000 --> 00:11:09,000
It's pretty obvious intuitively what the minimal information you need to support this query is.

147
00:11:09,000 --> 00:11:15,000
You need to know Simon's needs to reveal the name and the year to support this join

148
00:11:15,000 --> 00:11:18,000
because name and year are the join variables.

149
00:11:18,000 --> 00:11:20,000
They cross the join.

150
00:11:20,000 --> 00:11:23,000
Don's tool also has to reveal the name and year.

151
00:11:23,000 --> 00:11:28,000
And so what Simon's should do is they should publish the projection on name and year.

152
00:11:28,000 --> 00:11:31,000
And Don's tool should do the same.

153
00:11:31,000 --> 00:11:33,000
Give the projection on name and year.

154
00:11:33,000 --> 00:11:35,000
Intuitively, that's the minimal information.

155
00:11:35,000 --> 00:11:39,000
And in our formalism using determinacy, that's the minimal information.

156
00:11:39,000 --> 00:11:43,000
Does this make sense?

157
00:11:43,000 --> 00:11:47,000
The minimal information is just true or false.

158
00:11:47,000 --> 00:11:52,000
The answer to that query, it's a static notion.

159
00:11:52,000 --> 00:11:56,000
This is not instance determinacy.

160
00:11:56,000 --> 00:11:59,000
It's determinacy over all instances.

161
00:11:59,000 --> 00:12:04,000
That back in our notion of determinacy, it's over all d1, d and d prime.

162
00:12:04,000 --> 00:12:05,000
So it's a static.

163
00:12:05,000 --> 00:12:10,000
It's a data independent notion.

164
00:12:10,000 --> 00:12:15,000
So on a given instance, of course, I could say the answer is true or false and so on.

165
00:12:15,000 --> 00:12:19,000
But the minimal information views are views that will have the minimal information

166
00:12:19,000 --> 00:12:24,000
defined in terms of instance independent determinacy.

167
00:12:24,000 --> 00:12:26,000
I can play the same game.

168
00:12:26,000 --> 00:12:27,000
You give me your instance.

169
00:12:27,000 --> 00:12:32,000
I'm going to compute the view, which is just the answer to your query.

170
00:12:32,000 --> 00:12:34,000
These are autonomous data sources.

171
00:12:34,000 --> 00:12:37,000
These views, the distributive views are views at each source.

172
00:12:37,000 --> 00:12:43,000
So I can't go, Simon's is not allowed at data time, at query time, to go to Dogstool

173
00:12:43,000 --> 00:12:49,000
and say, you know, tell me what's going on and then export the data.

174
00:12:49,000 --> 00:12:55,000
This notion of distributive view says that each source has to do its own thing.

175
00:12:55,000 --> 00:12:56,000
It makes a lot of sense.

176
00:12:56,000 --> 00:12:57,000
Thank you.

177
00:12:57,000 --> 00:12:59,000
Yeah, but if I may.

178
00:12:59,000 --> 00:13:04,000
So I mean, it seems in this particular context, you want to be as respective as possible,

179
00:13:04,000 --> 00:13:05,000
right?

180
00:13:05,000 --> 00:13:07,000
So the instance level seems to be what you want to go into.

181
00:13:07,000 --> 00:13:11,000
And it could be something like a zero-knowledge proof like thing that's in a protocol between

182
00:13:11,000 --> 00:13:13,000
Simon's and Dogstool, right?

183
00:13:13,000 --> 00:13:14,000
Yeah.

184
00:13:14,000 --> 00:13:17,000
I talked, so the question about what happens.

185
00:13:17,000 --> 00:13:23,000
So, okay, the first thing is, so of course, if you do instance dependent things here,

186
00:13:23,000 --> 00:13:27,000
there's also some questions about these epistemic paradoxes.

187
00:13:27,000 --> 00:13:34,000
You say, no, I can't answer your query, because that would be giving out too much information.

188
00:13:34,000 --> 00:13:40,000
But, okay, so here there's a question about whether other mechanisms could do more than

189
00:13:40,000 --> 00:13:43,000
these views, which is a question I'll get to.

190
00:13:43,000 --> 00:13:50,000
Crypto people have looked at it, and actually, well, I've looked at it too in a couple of

191
00:13:50,000 --> 00:13:51,000
slides.

192
00:13:51,000 --> 00:14:00,000
So, okay, what's an example of our results?

193
00:14:00,000 --> 00:14:06,000
I won't, of course, suggest completely address your question in a couple of slides, but maybe

194
00:14:06,000 --> 00:14:08,000
it would be more clear.

195
00:14:08,000 --> 00:14:12,000
So in this paper, one of the results says you take any utility query.

196
00:14:12,000 --> 00:14:17,000
Not necessarily conjunct for an SQL arbitrary function on the global schema.

197
00:14:17,000 --> 00:14:20,000
Then these minimum of informative devues exist.

198
00:14:20,000 --> 00:14:25,000
I'll say a little bit more about what they look like in a few slides.

199
00:14:25,000 --> 00:14:32,000
For CQ utility queries, they're expressible as traditional views in relational algebra.

200
00:14:32,000 --> 00:14:36,000
And we show that the same holds in the presence of integrity constraints on each local source

201
00:14:36,000 --> 00:14:38,000
like TGDs, EGDs.

202
00:14:38,000 --> 00:14:42,000
So you always have these minimally informative things.

203
00:14:42,000 --> 00:14:49,000
And sometimes they're expressible in relational algebra, but there are CQ utility views where

204
00:14:49,000 --> 00:14:53,000
the minimally informative devues are not CQs themselves.

205
00:14:53,000 --> 00:14:56,000
So in particular, you don't know, they're not always the obvious ones, like in the previous

206
00:14:56,000 --> 00:14:57,000
example.

207
00:14:57,000 --> 00:15:02,000
I may be able, if we have time, I can give an example.

208
00:15:02,000 --> 00:15:06,000
We also look, within the class of CQ views, say you're committed that you're going to

209
00:15:06,000 --> 00:15:11,000
use CQ views, basic SQL queries, set semantics.

210
00:15:11,000 --> 00:15:16,000
There's, for CQ utility queries, you have minimally informative CQ views.

211
00:15:16,000 --> 00:15:18,000
And these are almost the obvious ones.

212
00:15:18,000 --> 00:15:26,000
After you minimize the utility query, they turn out to be the same as the obvious ones.

213
00:15:26,000 --> 00:15:29,000
So I'll come back to this a little bit later.

214
00:15:29,000 --> 00:15:35,000
But I wanted to say what we were doing in this paper, the perspective was to analyze the tradeoffs

215
00:15:35,000 --> 00:15:37,000
in view design.

216
00:15:37,000 --> 00:15:41,000
You look at questions of the form, are there distributed views that support this query,

217
00:15:41,000 --> 00:15:44,000
but which do not reveal any information about this other query?

218
00:15:44,000 --> 00:15:46,000
This is what we were interested here.

219
00:15:46,000 --> 00:15:50,000
So back to Simon's and Dogstool, but making it a little bit more abstract.

220
00:15:50,000 --> 00:15:54,000
Simon's has a binary relation R.

221
00:15:54,000 --> 00:15:57,000
Schostockstuhl has S and T binary relations.

222
00:15:57,000 --> 00:16:01,000
And I'm interested in supporting the intersection query.

223
00:16:01,000 --> 00:16:03,000
Well, obviously I could support this.

224
00:16:03,000 --> 00:16:07,000
I could design sources to answer Q.

225
00:16:07,000 --> 00:16:11,000
Each source just exports its data, all of R, all of S, all of T.

226
00:16:11,000 --> 00:16:15,000
But I want to know, well, is there some way to do this while keeping the query,

227
00:16:15,000 --> 00:16:17,000
there exists XRXX private?

228
00:16:17,000 --> 00:16:22,000
We analyze this for several notions of privacy, but one notion of privacy would be,

229
00:16:22,000 --> 00:16:29,000
on no instance, shouldn't the attacker be, should the external party know whether there exists XRXX is true?

230
00:16:29,000 --> 00:16:34,000
It's sort of a negative version of privacy that has been in the database theory literature.

231
00:16:34,000 --> 00:16:38,000
I think it goes back to Mendelssohn as a student.

232
00:16:38,000 --> 00:16:45,000
So intuitively, any views that support Q must disclose P on some instance.

233
00:16:45,000 --> 00:16:50,000
And okay, it's actually not so, this example with no integrity constraints is not so difficult,

234
00:16:50,000 --> 00:16:54,000
but using the prior results, we can compute the minimal information views,

235
00:16:54,000 --> 00:16:57,000
show that the minimal information views disclose this thing,

236
00:16:57,000 --> 00:17:01,000
and therefore, nothing you can do that supports Q,

237
00:17:01,000 --> 00:17:06,000
there's nothing you can do that can support Q, but make P a secret.

238
00:17:06,000 --> 00:17:08,000
That's a simple case.

239
00:17:08,000 --> 00:17:16,000
We also, well, we have several examples where the privacy utility query is less trivial.

240
00:17:16,000 --> 00:17:21,000
Here's one of them, we look at the case where there's partial synchronization mechanisms.

241
00:17:22,000 --> 00:17:25,000
We look mostly at replication as a synchronization mechanism.

242
00:17:25,000 --> 00:17:28,000
Now Simons and Dogstall are not completely autonomous.

243
00:17:28,000 --> 00:17:36,000
There's a relation S, the relation S that is in the query is replicated between Simons and Dogstall.

244
00:17:36,000 --> 00:17:38,000
But nothing else, there's no other mechanism.

245
00:17:38,000 --> 00:17:43,000
So obviously they need to communicate as data updates come in in order to do this.

246
00:17:43,000 --> 00:17:47,000
And we have the same utility query, and now we ask the same question,

247
00:17:47,000 --> 00:17:53,000
can we support this query while keeping this, there exists XRX private?

248
00:17:53,000 --> 00:17:59,000
And the answer now turns out to be yes, there is an interface mechanism,

249
00:17:59,000 --> 00:18:04,000
actually a view of a certain sort that can achieve this trade-off.

250
00:18:04,000 --> 00:18:09,000
It can support Q while keeping P a secret.

251
00:18:09,000 --> 00:18:16,000
So this is just meant like what were we trying to do and what kinds of results we have.

252
00:18:16,000 --> 00:18:21,000
We actually have a general result about what you can do with certain kinds of replication

253
00:18:21,000 --> 00:18:26,000
in managing these trade-offs between utility and secrecy.

254
00:18:26,000 --> 00:18:30,000
So what is the moral I wanted to give?

255
00:18:30,000 --> 00:18:38,000
Well, first, it's not really an answer, but it's my attempt at an answer.

256
00:18:38,000 --> 00:18:43,000
We were getting at the idea of comparing the expressiveness of different interface mechanisms.

257
00:18:43,000 --> 00:18:50,000
So in this case, what can you do with a CQ view versus what can you do with relational algebra views?

258
00:18:50,000 --> 00:18:52,000
What can you do with arbitrary functions?

259
00:18:52,000 --> 00:18:57,000
I thought this is something that is an interesting direction that I haven't seen much of.

260
00:18:57,000 --> 00:19:01,000
And you can look at the same thing with more interactive method mechanism.

261
00:19:01,000 --> 00:19:05,000
We didn't do it, but it was an obvious thing as well.

262
00:19:05,000 --> 00:19:11,000
Suppose you have access methods, for instance, you can now, and now you can interactively ask multiple queries.

263
00:19:11,000 --> 00:19:14,000
And then you achieve these other kinds of trade-offs.

264
00:19:14,000 --> 00:19:19,000
And then the second thing I want to highlight is this notion of information theoretic determinacy,

265
00:19:19,000 --> 00:19:23,000
the database theorists information theory.

266
00:19:23,000 --> 00:19:28,000
This has been used certainly by a number of people.

267
00:19:28,000 --> 00:19:34,000
Paris and Dan and other people at Washington used it in the pre-oppressing work.

268
00:19:34,000 --> 00:19:43,000
I've used it in many papers, but quickly on information disclosure with Balder, Pierre, other people, also KR people at Oxford.

269
00:19:43,000 --> 00:19:46,000
I think also Daniel Kieffer in some of his work.

270
00:19:46,000 --> 00:19:48,000
Yes, yes.

271
00:19:48,000 --> 00:19:51,000
But I don't think it's really been developed rigorously and uniformly.

272
00:19:51,000 --> 00:19:55,000
Here you have some information lattice on views.

273
00:19:55,000 --> 00:20:00,000
That's the idea actually in the pricing work and in our work.

274
00:20:00,000 --> 00:20:03,000
And you can begin to explore this.

275
00:20:04,000 --> 00:20:13,000
So I'll come back to this in a little bit, but I want to talk now a little bit about what's the idea of this other work about indistinguishability this year.

276
00:20:13,000 --> 00:20:15,000
And it's motivated.

277
00:20:15,000 --> 00:20:21,000
Okay, so first, an indistinguishability relation is just an equivalence relation on databases.

278
00:20:21,000 --> 00:20:27,000
I say here are the two, here's the pairs of databases that are equivalent.

279
00:20:27,000 --> 00:20:30,000
And this gives an interface.

280
00:20:30,000 --> 00:20:32,000
Somebody is interacting with the database.

281
00:20:32,000 --> 00:20:34,000
What is the queries they could answer?

282
00:20:34,000 --> 00:20:36,000
Well, there's two possible semantics.

283
00:20:36,000 --> 00:20:46,000
One is that they can answer any query using the certain answer semantics and the certain answer semantics would be, well, what they're really seeing is the entire equivalence class of this database.

284
00:20:46,000 --> 00:20:50,000
And they get the intersection of the answers of the database.

285
00:20:50,000 --> 00:20:53,000
There's another semantics which says, oh, it's the answerability semantics.

286
00:20:53,000 --> 00:20:59,000
They can only ask queries where the answer is invariant under this equivalence relation.

287
00:20:59,000 --> 00:21:06,000
So this would be more like what's called feasibility in access patterns or answerability in views.

288
00:21:06,000 --> 00:21:10,000
So the main point is you have some way of specifying an equivalence relation.

289
00:21:10,000 --> 00:21:14,000
I'll talk about some ways you could specify an equivalence relation that's giving you an interface.

290
00:21:14,000 --> 00:21:22,000
And it's interesting in that it's a way of giving an interface that's different from what we're used to.

291
00:21:22,000 --> 00:21:25,000
Okay, you can of course think of this as a view.

292
00:21:25,000 --> 00:21:33,000
A view, I said from this general mathematical point of view, it's a function on the instance or the local instance that exports some stuff.

293
00:21:33,000 --> 00:21:37,000
And you can say what I'm exporting is the equivalence class.

294
00:21:37,000 --> 00:21:39,000
But of course, we're representing it differently.

295
00:21:39,000 --> 00:21:43,000
Let's give you an example.

296
00:21:43,000 --> 00:21:49,000
I can say G and G prime are indistinguishable if they have the same triangles.

297
00:21:49,000 --> 00:21:52,000
So these are two graph databases.

298
00:21:52,000 --> 00:22:01,000
I can say for all x1, x2, x3, they're a triangle in database G if and only if they're a triangle in G prime.

299
00:22:01,000 --> 00:22:05,000
And this, that's an equivalence relation.

300
00:22:05,000 --> 00:22:08,000
It's actually a first order indistinguishability relation.

301
00:22:08,000 --> 00:22:13,000
It's given by a first order sentence in the language of two copies of the schema.

302
00:22:13,000 --> 00:22:17,000
So it's first order, not in the sense of what we usually say.

303
00:22:17,000 --> 00:22:24,000
Now, if you take a typical first order sentence in the language of two schemas, it's not going to define an equivalence relation.

304
00:22:24,000 --> 00:22:27,000
This is a semantic property.

305
00:22:27,000 --> 00:22:36,000
These things for all x1, x2, x3, and if and only if between G and G prime, that's going to be an equivalence relation, but other things are not.

306
00:22:36,000 --> 00:22:42,000
So I'm interested in the first order sentences in two schemas that will do this.

307
00:22:42,000 --> 00:22:46,000
And I can generalize whether triangle example is one of them.

308
00:22:46,000 --> 00:22:48,000
You can give me any relational algebra views.

309
00:22:48,000 --> 00:22:52,000
They give a first order indistinguishability relation, the same kind of thing.

310
00:22:52,000 --> 00:22:55,000
Well, one database satisfies the views.

311
00:22:55,000 --> 00:23:03,000
For every tuple in the union of the databases, it's in the view result in one if and only if it's the view result of the other.

312
00:23:03,000 --> 00:23:12,000
I'm using this prime notation just like the G and G prime to say the prime copy of the database agrees with the unprime copy on this derived data.

313
00:23:12,000 --> 00:23:13,000
Michael?

314
00:23:13,000 --> 00:23:14,000
Yeah?

315
00:23:14,000 --> 00:23:17,000
The universal quantifiers, are they quantifying over which domain?

316
00:23:17,000 --> 00:23:23,000
They're quantifying over the union of the active domains.

317
00:23:23,000 --> 00:23:25,000
So this came up in the prior work.

318
00:23:25,000 --> 00:23:31,000
I said these minimally informative views exist for arbitrary utility queries.

319
00:23:31,000 --> 00:23:32,000
How do they work?

320
00:23:32,000 --> 00:23:37,000
Actually, the way we can present them is, as I said, indistinguishability relation.

321
00:23:37,000 --> 00:23:43,000
Obviously, we can show that you can't always get, in very natural cases, you can't get relational algebra.

322
00:23:43,000 --> 00:23:47,000
But you can always get this indistinguishability relation presentation.

323
00:23:47,000 --> 00:23:52,000
Actually, I think a second order indistinguishability relation.

324
00:23:52,000 --> 00:23:55,000
And then there was this example I talked about with replication.

325
00:23:55,000 --> 00:24:00,000
I said, well, we could support Q without revealing P.

326
00:24:00,000 --> 00:24:01,000
How did we do this?

327
00:24:01,000 --> 00:24:04,000
We needed some interface mechanism beyond relational algebra views.

328
00:24:04,000 --> 00:24:07,000
We could show that you couldn't use any generic query to do this.

329
00:24:07,000 --> 00:24:13,000
But we define a simple indistinguishability relation that actually looks at the data values.

330
00:24:13,000 --> 00:24:16,000
And we show that's the way you can achieve this trade-off.

331
00:24:16,000 --> 00:24:25,000
So you can achieve certain trade-offs with indistinguishability that you can't achieve with traditional views.

332
00:24:25,000 --> 00:24:27,000
Okay, this is a super general notion.

333
00:24:27,000 --> 00:24:33,000
We studied this mostly over infinite structures, focusing on first order and infinitary logic.

334
00:24:33,000 --> 00:24:43,000
There are a few results that I can mention that apply to the finite case, to finite models, to databases.

335
00:24:43,000 --> 00:24:47,000
I said that traditional relational algebra views give a first order indistinguishability relation.

336
00:24:47,000 --> 00:24:52,000
And you can ask, well, what are the other first order indistinguishability relations?

337
00:24:52,000 --> 00:24:59,000
Well, nested relational calculus gives you another class of first order indistinguishability relations.

338
00:24:59,000 --> 00:25:04,000
I don't want to explain what nested data is, a nested relational calculus, but I'll explain by example.

339
00:25:04,000 --> 00:25:11,000
If I have a binary relation, rxy, I want to export all the adjacency sets of elements in my database.

340
00:25:11,000 --> 00:25:14,000
This is a set of sets for every element.

341
00:25:14,000 --> 00:25:17,000
I take the set of things that are adjacent to it.

342
00:25:17,000 --> 00:25:20,000
And then I take the set of sets by varying the x.

343
00:25:20,000 --> 00:25:21,000
Well, that's a set of sets.

344
00:25:21,000 --> 00:25:29,000
I can say two databases agree on the set of sets in first order logic in this dual signature, the r and r prime signature.

345
00:25:29,000 --> 00:25:32,000
For all x, there exists x prime.

346
00:25:32,000 --> 00:25:39,000
For every node in one, there's a node in the other database whose adjacency set agrees.

347
00:25:39,000 --> 00:25:46,000
So in general, okay, I can do sets of sets of sets in the same way.

348
00:25:46,000 --> 00:25:48,000
That's the general idea of nested relational calculus.

349
00:25:48,000 --> 00:25:50,000
I build up these sets of sets of sets.

350
00:25:50,000 --> 00:25:55,000
You know, it's a different query language and agreement on a nested relational calculus query.

351
00:25:55,000 --> 00:26:04,000
So let me jump since I'm running low on time to the open question here.

352
00:26:04,000 --> 00:26:08,000
We have various results about this, but an intriguing open question is,

353
00:26:08,000 --> 00:26:14,000
is every first order indistinguishability relation given by nested relational calculus?

354
00:26:14,000 --> 00:26:20,000
We look at the infinite case where this is not true and we find lots of phenomenon that go beyond nested relational calculus.

355
00:26:20,000 --> 00:26:27,000
And of course, we don't use the word nested relational calculus because it's geared towards a different audience.

356
00:26:27,000 --> 00:26:30,000
This is a preservation question.

357
00:26:30,000 --> 00:26:33,000
I have a first order sentence in the language of two schemas.

358
00:26:33,000 --> 00:26:35,000
I impose some semantic property.

359
00:26:35,000 --> 00:26:39,000
Here's a syntax, nested relational calculus views that enforces it.

360
00:26:39,000 --> 00:26:45,000
I want to know if everything that has this semantic property is enforced by this text.

361
00:26:45,000 --> 00:26:52,000
Okay, so first I'll say this indistinguishability, the bottom line, this indistinguishability relations.

362
00:26:52,000 --> 00:27:02,000
They make the world of traditional views look very small because you can begin to see lots of other ways of creating interfaces that are beyond views.

363
00:27:02,000 --> 00:27:09,000
And it gets at this issue that comes up often in descriptive complexity theory and descriptive set theory,

364
00:27:09,000 --> 00:27:13,000
of going from an equivalence relation to a canonical representative.

365
00:27:13,000 --> 00:27:18,000
For instance, if you look at various notions of elementary equivalence, like n variable equivalence,

366
00:27:18,000 --> 00:27:21,000
you have a nicely described equivalence relation.

367
00:27:21,000 --> 00:27:26,000
You want to know how efficient it is to export a representative of this equivalence relation.

368
00:27:26,000 --> 00:27:30,000
You have a nice representation of sort of the dynamic notion.

369
00:27:30,000 --> 00:27:33,000
You want to know, does that mean that there's a nice representative?

370
00:27:33,000 --> 00:27:37,000
You can choose a representative concisely.

371
00:27:37,000 --> 00:27:43,000
So I want to stop now with the great thoughts stuff, if you can give me a second to do it.

372
00:27:43,000 --> 00:27:48,000
Okay, so I want to go back to great thoughts.

373
00:27:48,000 --> 00:27:51,000
And the truth of it is, I saw Mulham's talk last week,

374
00:27:51,000 --> 00:27:57,000
and he gave an overview of relational databases, and it led to some great pronouncement.

375
00:27:57,000 --> 00:28:02,000
You know, relational AI is great by relational AI, and other profound thoughts.

376
00:28:02,000 --> 00:28:08,000
And then I saw Joe's talk, and he overviewed relational databases for 15 years,

377
00:28:08,000 --> 00:28:11,000
and he gave his own pronouncements.

378
00:28:11,000 --> 00:28:18,000
Morals, I love Hasselt, and there's important problems with synchronization

379
00:28:18,000 --> 00:28:21,000
that need to be studied, and deadline is great.

380
00:28:21,000 --> 00:28:24,000
And I thought I should have a slide that talks about 15 years databases,

381
00:28:24,000 --> 00:28:27,000
and then has some profound conclusion.

382
00:28:27,000 --> 00:28:33,000
What I want to say is, well, in the first 40 years, this notion of logical interface,

383
00:28:33,000 --> 00:28:40,000
expanding it, and notions of comparing interfaces, you find it relatively often in pods.

384
00:28:40,000 --> 00:28:46,000
You know, Rick Hall did some various things about the notion of information capacity

385
00:28:46,000 --> 00:28:50,000
that I find very interesting at the level of comparing schemas.

386
00:28:50,000 --> 00:28:54,000
And then, of course, there's been a lot of work over 40 years

387
00:28:54,000 --> 00:28:58,000
at looking at funky new ways of defining interfaces.

388
00:28:58,000 --> 00:29:02,000
But in the last, I'd say, certainly five years, not so much.

389
00:29:02,000 --> 00:29:05,000
So I think there is some need to look at this.

390
00:29:05,000 --> 00:29:09,000
I wouldn't say, you know, looking at the work in this workshop,

391
00:29:09,000 --> 00:29:14,000
I don't say that people should stop working on machine learning

392
00:29:14,000 --> 00:29:17,000
and relational algebra like Zach is, and look about this.

393
00:29:17,000 --> 00:29:21,000
A little bit maybe goes a long way, and maybe there was too much of this at one point.

394
00:29:21,000 --> 00:29:26,000
But I think going back every few years and looking at this is a good thing to do.

395
00:29:26,000 --> 00:29:30,000
Certainly, this work has been very influential outside of databases.

396
00:29:30,000 --> 00:29:31,000
Thank you.

397
00:29:31,000 --> 00:29:57,000
So we haven't looked in this. I think this model is just, you know,

398
00:29:57,000 --> 00:30:01,000
I've shown this stuff to some people who work on privacy

399
00:30:01,000 --> 00:30:05,000
say this is ridiculously restrictive, which I think is the right answer.

400
00:30:05,000 --> 00:30:10,000
I mean, our notion that I showed you of keeping something secret

401
00:30:10,000 --> 00:30:14,000
is on no instance should the attacker learn the database,

402
00:30:14,000 --> 00:30:18,000
which is something that comes in the database theory literature.

403
00:30:18,000 --> 00:30:20,000
Also, it's in the KR literature.

404
00:30:20,000 --> 00:30:26,000
But of course, in the end, differential privacy is much weaker,

405
00:30:27,000 --> 00:30:30,000
and in general, the reaction is, look, you know,

406
00:30:30,000 --> 00:30:34,000
I don't care that there's some one database out there in the world.

407
00:30:34,000 --> 00:30:37,000
It's mostly used for aggregated queries.

408
00:30:37,000 --> 00:30:43,000
So if you have views like non-aggregated views, the notion is not obvious, but yeah.

409
00:30:46,000 --> 00:30:49,000
Yeah, so first of all, very interesting.

410
00:30:49,000 --> 00:30:51,000
So I got your framework and the results.

411
00:30:51,000 --> 00:30:52,000
It was amazing.

412
00:30:53,000 --> 00:30:54,000
Quick question.

413
00:30:54,000 --> 00:30:57,000
I didn't get a chance to do justice to the distinguishly results,

414
00:30:57,000 --> 00:30:59,000
but I can tell that it's not important.

415
00:30:59,000 --> 00:31:02,000
But can you do justice to communication complexity?

416
00:31:02,000 --> 00:31:03,000
Have you looked into this?

417
00:31:03,000 --> 00:31:07,000
Yeah, I mean, this, so no, well, not really.

418
00:31:07,000 --> 00:31:10,000
I mean, the proofs have a very similar feel to communication.

419
00:31:10,000 --> 00:31:13,000
We're exploiting autonomy of this.

420
00:31:13,000 --> 00:31:18,000
And you would think once we put in some interaction between the two sources,

421
00:31:18,000 --> 00:31:21,000
we're in extreme case of communication complexity.

422
00:31:21,000 --> 00:31:24,000
Because there's no communication between the sources at all.

423
00:31:24,000 --> 00:31:30,000
Well, they both published something in common, so they can compute a few.

424
00:31:30,000 --> 00:31:32,000
Maybe it's a one round, a half round.

425
00:31:32,000 --> 00:31:33,000
I don't know.

426
00:31:33,000 --> 00:31:36,000
They looked at all sorts of variations, which I'm not familiar with.

427
00:31:36,000 --> 00:31:37,000
Yeah, I agree.

428
00:31:37,000 --> 00:31:39,000
It's on my radar to look at.

429
00:31:45,000 --> 00:31:48,000
So, like, I had a similar question before, right?

430
00:31:49,000 --> 00:31:53,000
Like, yes, it's a differential privacy as a weaker model

431
00:31:53,000 --> 00:31:56,000
because we only have probabilistic guarantees.

432
00:31:56,000 --> 00:32:00,000
So, but your model is also in another way more expressive, right?

433
00:32:00,000 --> 00:32:02,000
This indistinguishability in relation to autonomy.

434
00:32:02,000 --> 00:32:06,000
Like, differential privacy is essentially like a very simple

435
00:32:06,000 --> 00:32:08,000
in what sort of distinguishability we're like.

436
00:32:08,000 --> 00:32:10,000
But there's still no probabilities involved,

437
00:32:10,000 --> 00:32:13,000
even in the indistinguishability notion, right?

438
00:32:13,000 --> 00:32:14,000
No, no, I know, right?

439
00:32:14,000 --> 00:32:18,000
I mean, like, right, your model is not just stricter,

440
00:32:18,000 --> 00:32:23,000
but also more expressive in what we consider to be indistinguishable, right?

441
00:32:23,000 --> 00:32:24,000
Yeah.

442
00:32:24,000 --> 00:32:27,000
But there's, I'm mangling two works, right?

443
00:32:27,000 --> 00:32:30,000
So, on the one hand, you have this notion of privacy.

444
00:32:30,000 --> 00:32:31,000
That's it.

445
00:32:31,000 --> 00:32:32,000
Yeah.

446
00:32:32,000 --> 00:32:35,000
On the other hand, we can be flexible about the view mechanisms

447
00:32:35,000 --> 00:32:39,000
and look at these more powerful mechanisms, right?

448
00:32:39,000 --> 00:32:41,000
So, that's true.

449
00:32:41,000 --> 00:32:44,000
Some of it, I just want to make clear that some of this trade-off

450
00:32:44,000 --> 00:32:45,000
is in two different works.

451
00:32:45,000 --> 00:32:46,000
But go ahead.

452
00:32:46,000 --> 00:32:48,000
Yes, I agree, right?

453
00:32:48,000 --> 00:32:51,000
So, I know that indistinguishability was basically like a query,

454
00:32:51,000 --> 00:32:53,000
like a trust with the privacy.

455
00:32:53,000 --> 00:32:54,000
Yeah.

456
00:32:54,000 --> 00:32:59,000
But it could also be, obviously, used for like a privacy mechanism.

457
00:32:59,000 --> 00:33:00,000
Yeah.

458
00:33:02,000 --> 00:33:05,000
I remember I said that I won't be ready for great thoughts

459
00:33:05,000 --> 00:33:10,000
tomorrow afternoon, or possibly Monday, or maybe next week.

460
00:33:10,000 --> 00:33:11,000
Yeah.

461
00:33:11,000 --> 00:33:14,000
So, can you comment a bit about the complexity of computing

462
00:33:14,000 --> 00:33:18,000
that is used, because the term is unsilable, right?

463
00:33:18,000 --> 00:33:20,000
So, in the...

464
00:33:20,000 --> 00:33:23,000
Well, rather than very easy, you can just compute that.

465
00:33:23,000 --> 00:33:24,000
You can just...

466
00:33:24,000 --> 00:33:26,000
So, in the case of CQ utility queries, you don't need to decide

467
00:33:26,000 --> 00:33:29,000
the term as CQ, you can get these minimal information use,

468
00:33:29,000 --> 00:33:33,000
and actually, in key time, you can create.

469
00:33:33,000 --> 00:33:35,000
For other queries?

470
00:33:35,000 --> 00:33:38,000
Well, for other queries, so, for other queries,

471
00:33:38,000 --> 00:33:40,000
you don't actually know what the representation is.

472
00:33:40,000 --> 00:33:42,000
So, Pierre, do you want to contradict this?

473
00:33:42,000 --> 00:33:44,000
Minimization of the term.

474
00:33:44,000 --> 00:33:45,000
Okay.

475
00:33:45,000 --> 00:33:46,000
So, yeah.

476
00:33:46,000 --> 00:33:47,000
So, actually...

477
00:33:47,000 --> 00:33:48,000
So, if the...

478
00:33:48,000 --> 00:33:49,000
If...

479
00:33:49,000 --> 00:33:50,000
Well, okay.

480
00:33:50,000 --> 00:33:51,000
So...

481
00:33:51,000 --> 00:33:52,000
Well, I mean...

482
00:33:52,000 --> 00:33:53,000
Okay.

483
00:33:53,000 --> 00:33:55,000
So, you can get relational algebra views without doing minimum...

484
00:33:55,000 --> 00:33:56,000
Minimization.

485
00:33:56,000 --> 00:33:57,000
Pierre.

486
00:33:57,000 --> 00:33:58,000
Yeah, but you...

487
00:33:58,000 --> 00:33:59,000
If you want to get the CQ...

488
00:33:59,000 --> 00:34:02,000
So, it depends what format you want the views in.

489
00:34:02,000 --> 00:34:03,000
You can...

490
00:34:03,000 --> 00:34:04,000
Yeah.

491
00:34:06,000 --> 00:34:07,000
You do get the minimal one.

492
00:34:07,000 --> 00:34:09,000
You just don't have it as a CQ.

493
00:34:09,000 --> 00:34:11,000
So, it depends on what represent...

494
00:34:11,000 --> 00:34:14,000
I mean, you know, if I've understood your comment correctly,

495
00:34:14,000 --> 00:34:15,000
there's two results.

496
00:34:15,000 --> 00:34:17,000
One, it says, okay, I...

497
00:34:17,000 --> 00:34:19,000
I can get these relational algebra views.

498
00:34:19,000 --> 00:34:21,000
And there, we use this...

499
00:34:21,000 --> 00:34:25,000
This construction about getting these samples.

500
00:34:25,000 --> 00:34:27,000
And I think you can do this in key time.

501
00:34:27,000 --> 00:34:28,000
It's...

502
00:34:28,000 --> 00:34:29,000
It is minimal information.

503
00:34:29,000 --> 00:34:30,000
It's just...

504
00:34:30,000 --> 00:34:31,000
If you want to...

505
00:34:31,000 --> 00:34:33,000
There's another result that says I can get CQ views,

506
00:34:33,000 --> 00:34:35,000
and there I need to minimize the global word,

507
00:34:35,000 --> 00:34:37,000
which, yes, Pierre said, is expensive.

508
00:34:37,000 --> 00:34:40,000
But then, after you get these minimal views,

509
00:34:40,000 --> 00:34:43,000
you have to see whether you can do disclosure.

510
00:34:43,000 --> 00:34:48,000
And there, we have some results on this for the case

511
00:34:48,000 --> 00:34:50,000
without constraints.

512
00:34:50,000 --> 00:34:52,000
We know how to do it.

513
00:34:52,000 --> 00:34:54,000
I mean, we know there you just look at the minimal...

514
00:34:54,000 --> 00:34:55,000
At the...

515
00:34:55,000 --> 00:34:56,000
At this canonical...

516
00:34:56,000 --> 00:34:59,000
The canonical instance.

517
00:34:59,000 --> 00:35:01,000
And then with constraints,

518
00:35:01,000 --> 00:35:04,000
I don't remember whether we have complexity.

519
00:35:04,000 --> 00:35:05,000
Yes, yeah.

520
00:35:05,000 --> 00:35:07,000
We have some abstracting constraints.

521
00:35:07,000 --> 00:35:09,000
Like guarded constraints.

522
00:35:09,000 --> 00:35:11,000
If you got a little bit of...

