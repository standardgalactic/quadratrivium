1
00:00:00,000 --> 00:00:05,000
Okay, welcome everybody.

2
00:00:05,000 --> 00:00:07,000
Very glad you could make it for this talk.

3
00:00:07,000 --> 00:00:09,000
I've been working on this for a while.

4
00:00:09,000 --> 00:00:10,000
I'm really excited about it.

5
00:00:10,000 --> 00:00:14,000
If you don't know me, I am Gabriel,

6
00:00:14,000 --> 00:00:17,000
and I'm an instructor here at Fullstack Academy of Code.

7
00:00:17,000 --> 00:00:20,000
My social media presence is G. Lebec everywhere,

8
00:00:20,000 --> 00:00:23,000
except, unfortunately, and somewhat ironically,

9
00:00:23,000 --> 00:00:25,000
given the subject of this talk at Twitter,

10
00:00:25,000 --> 00:00:27,000
where I was forced to use an underscore.

11
00:00:27,000 --> 00:00:30,000
There's going to be resources available on my GitHub

12
00:00:30,000 --> 00:00:32,000
at slash G. Lebec slash Lambda Talk,

13
00:00:32,000 --> 00:00:35,000
so you can go find additional stuff after this.

14
00:00:35,000 --> 00:00:38,000
All right, so let's just dive in and get started.

15
00:00:38,000 --> 00:00:41,000
I want to start by pointing out a minute node ripple here.

16
00:00:41,000 --> 00:00:44,000
I can do kind of typical JavaScript-y stuff,

17
00:00:44,000 --> 00:00:47,000
but we're going to avoid JavaScript in the sort of classical sense

18
00:00:47,000 --> 00:00:50,000
as much as possible, and start off with this function

19
00:00:50,000 --> 00:00:53,000
called I or identity.

20
00:00:53,000 --> 00:00:55,000
Now, just looking at the function,

21
00:00:55,000 --> 00:00:57,000
if I invoke it with some value,

22
00:00:57,000 --> 00:00:59,000
what am I going to get back here?

23
00:00:59,000 --> 00:01:04,000
Yeah, identity of one is one, identity of two is two.

24
00:01:04,000 --> 00:01:08,000
What about the identity of identity?

25
00:01:08,000 --> 00:01:11,000
Yeah, it's the identity function.

26
00:01:11,000 --> 00:01:14,000
So, very simply, the identity combinator

27
00:01:14,000 --> 00:01:19,000
is a function that takes in an input A

28
00:01:19,000 --> 00:01:21,000
and it returns an output A.

29
00:01:21,000 --> 00:01:24,000
Basically, it just reflects back a value.

30
00:01:24,000 --> 00:01:26,000
So, the identity of any X is X,

31
00:01:26,000 --> 00:01:28,000
and we saw that in this particular paradigm,

32
00:01:28,000 --> 00:01:31,000
we're allowed to use functions as arguments.

33
00:01:31,000 --> 00:01:33,000
Verbs are nouns and nouns are verbs,

34
00:01:33,000 --> 00:01:37,000
so the identity of identity is itself.

35
00:01:37,000 --> 00:01:40,000
In Haskell, this is actually built into the Prelude module,

36
00:01:40,000 --> 00:01:43,000
which is the base standard module for the language,

37
00:01:43,000 --> 00:01:45,000
as the ID function.

38
00:01:45,000 --> 00:01:47,000
As you can see, it takes an argument five

39
00:01:47,000 --> 00:01:49,000
and gives you back five.

40
00:01:49,000 --> 00:01:52,000
So, looking at this, I just flashed a bunch of stuff on the screen.

41
00:01:52,000 --> 00:01:54,000
You might be thinking, what's this lambda stuff

42
00:01:54,000 --> 00:01:56,000
that's sitting up here?

43
00:01:56,000 --> 00:01:58,000
So, lambda is a signifier.

44
00:01:58,000 --> 00:02:00,000
It's a notation that we're going to use

45
00:02:00,000 --> 00:02:03,000
to indicate that we're starting the definition of a function.

46
00:02:03,000 --> 00:02:07,000
So, we can read this as we're starting to define a function,

47
00:02:07,000 --> 00:02:10,000
which takes a single input or parameter,

48
00:02:10,000 --> 00:02:13,000
and it returns some expression, some body.

49
00:02:13,000 --> 00:02:16,000
And this whole thing is called a lambda abstraction

50
00:02:16,000 --> 00:02:17,000
in the lambda calculus,

51
00:02:17,000 --> 00:02:21,000
but it basically just means it's a unary anonymous function.

52
00:02:21,000 --> 00:02:24,000
Unary meaning it takes a single input.

53
00:02:24,000 --> 00:02:29,000
The lambda calculus is a really tiny symbol manipulation framework.

54
00:02:29,000 --> 00:02:33,000
A calculus is just a way of moving around symbols on a page.

55
00:02:33,000 --> 00:02:37,000
The subject that you may have learned in school called calculus

56
00:02:37,000 --> 00:02:40,000
is a specific calculus for things like differentials

57
00:02:40,000 --> 00:02:44,000
and integrals and stuff like that, derivatives.

58
00:02:44,000 --> 00:02:47,000
And so, this calculus is about something else.

59
00:02:47,000 --> 00:02:52,000
This calculus is about evaluating and defining functions.

60
00:02:52,000 --> 00:02:55,000
So, in the lambda calculus, we have variables,

61
00:02:55,000 --> 00:02:57,000
which are pretty boring.

62
00:02:57,000 --> 00:02:58,000
Please come in.

63
00:02:58,000 --> 00:03:00,000
We've got expressions,

64
00:03:00,000 --> 00:03:05,000
which are the application of some function to its argument.

65
00:03:05,000 --> 00:03:09,000
We've got an expression that is itself a function definition,

66
00:03:09,000 --> 00:03:13,000
an abstraction instead of a concrete thing like 1 plus 5,

67
00:03:13,000 --> 00:03:15,000
1 plus 6, 1 plus 7.

68
00:03:15,000 --> 00:03:18,000
We have something like 1 plus A.

69
00:03:18,000 --> 00:03:20,000
And A can be anything.

70
00:03:20,000 --> 00:03:22,000
It's become abstracted.

71
00:03:22,000 --> 00:03:25,000
And we have groupings to disambiguate the order

72
00:03:25,000 --> 00:03:28,000
in which we should be doing certain operations.

73
00:03:28,000 --> 00:03:30,000
This is the entire lambda calculus.

74
00:03:30,000 --> 00:03:31,000
All right.

75
00:03:31,000 --> 00:03:32,000
So, talk's over.

76
00:03:32,000 --> 00:03:33,000
I can go home now.

77
00:03:33,000 --> 00:03:35,000
No, we're going to see some examples of this.

78
00:03:35,000 --> 00:03:39,000
So, let's start with just a couple of cross comparisons here.

79
00:03:39,000 --> 00:03:43,000
Variables in the lambda calculus, as I mentioned, are extremely boring.

80
00:03:43,000 --> 00:03:47,000
One thing to note here is that these variables are immutable.

81
00:03:47,000 --> 00:03:49,000
They cannot be changed after the fact.

82
00:03:49,000 --> 00:03:53,000
There's no concept of assignment, per se, in the lambda calculus.

83
00:03:53,000 --> 00:03:55,000
There is binding, which we'll see shortly.

84
00:03:55,000 --> 00:03:58,000
But if this variable is bound to a value,

85
00:03:58,000 --> 00:04:02,000
that's its value for now and forevermore.

86
00:04:02,000 --> 00:04:05,000
So, no, let all const.

87
00:04:05,000 --> 00:04:07,000
Applications are slightly more interesting.

88
00:04:07,000 --> 00:04:09,000
This is applying a function to its arguments.

89
00:04:09,000 --> 00:04:12,000
And in the lambda calculus, that's just juxtaposition.

90
00:04:12,000 --> 00:04:14,000
It's just a space.

91
00:04:14,000 --> 00:04:16,000
There's no parens for invocation,

92
00:04:16,000 --> 00:04:19,000
which at first, if you're used to something like JavaScript,

93
00:04:19,000 --> 00:04:21,000
it's a little disconcerting.

94
00:04:21,000 --> 00:04:25,000
But in reality, it ends up removing a lot of noise from our expressions.

95
00:04:25,000 --> 00:04:26,000
And as this talk goes on,

96
00:04:26,000 --> 00:04:30,000
you're probably going to see it's becoming easier and easier to read the lambda calculus

97
00:04:30,000 --> 00:04:33,000
rather than trying to parse the JavaScript.

98
00:04:33,000 --> 00:04:36,000
So, here we apply a function f to its argument a.

99
00:04:36,000 --> 00:04:38,000
We can apply multiple arguments,

100
00:04:38,000 --> 00:04:41,000
but in the lambda calculus, all functions are unary.

101
00:04:41,000 --> 00:04:43,000
So, this is really a curried function.

102
00:04:43,000 --> 00:04:45,000
This is an f that takes an a,

103
00:04:45,000 --> 00:04:47,000
and that returns a new function,

104
00:04:47,000 --> 00:04:50,000
which is not written down, which takes a b.

105
00:04:50,000 --> 00:04:52,000
Let's try this out.

106
00:04:52,000 --> 00:04:56,000
Let's do kind of a classic example of a curried addition function.

107
00:04:56,000 --> 00:04:58,000
We'll say that add takes an a,

108
00:04:58,000 --> 00:05:03,000
and it takes a b, and it returns a plus b.

109
00:05:03,000 --> 00:05:08,000
So, if we call add with just some single argument,

110
00:05:08,000 --> 00:05:10,000
we get back some function.

111
00:05:10,000 --> 00:05:13,000
If we call that function with an additional argument,

112
00:05:13,000 --> 00:05:16,000
now we get the final result.

113
00:05:16,000 --> 00:05:19,000
Pretty familiar stuff, I think, for this crowd.

114
00:05:19,000 --> 00:05:23,000
So, f a b, you can read that as first it takes an a,

115
00:05:23,000 --> 00:05:25,000
and then a b, and if there are more arguments,

116
00:05:25,000 --> 00:05:27,000
they get fed in one by one,

117
00:05:27,000 --> 00:05:31,000
going from the leftmost argument onwards,

118
00:05:31,000 --> 00:05:33,000
marching kind of toward the right.

119
00:05:33,000 --> 00:05:36,000
We can make this clear with parentheses.

120
00:05:36,000 --> 00:05:39,000
We can say, first apply f to a,

121
00:05:39,000 --> 00:05:41,000
and then apply the result of that to b,

122
00:05:41,000 --> 00:05:43,000
but this isn't necessary because we say

123
00:05:43,000 --> 00:05:45,000
that function application is left associative.

124
00:05:45,000 --> 00:05:47,000
So, these are really useless parentheses,

125
00:05:47,000 --> 00:05:51,000
and we'll omit them in most of our examples.

126
00:05:51,000 --> 00:05:54,000
Finally, we can use parentheses to force evaluations

127
00:05:54,000 --> 00:05:56,000
to occur in a different order.

128
00:05:56,000 --> 00:05:58,000
So, here this is actually a different expression.

129
00:05:58,000 --> 00:06:01,000
This means something else in the lambda calculus.

130
00:06:01,000 --> 00:06:03,000
It means we're going to first apply a to b,

131
00:06:03,000 --> 00:06:07,000
and the result of that will be the argument to f.

132
00:06:07,000 --> 00:06:09,000
Hi, hello.

133
00:06:09,000 --> 00:06:11,000
Welcome.

134
00:06:11,000 --> 00:06:16,000
So, just to summarize for everybody who's just arrived,

135
00:06:16,000 --> 00:06:18,000
we're starting to define the syntax

136
00:06:18,000 --> 00:06:22,000
of a very small language called the lambda calculus.

137
00:06:22,000 --> 00:06:25,000
And this is just something that takes functions,

138
00:06:25,000 --> 00:06:27,000
applications of functions to arguments,

139
00:06:27,000 --> 00:06:29,000
and parentheses for grouping.

140
00:06:29,000 --> 00:06:31,000
That's really it.

141
00:06:31,000 --> 00:06:34,000
So, really high level review of just this last slide.

142
00:06:34,000 --> 00:06:37,000
F a means invoke f with a,

143
00:06:37,000 --> 00:06:40,000
and you'll get more as we go.

144
00:06:40,000 --> 00:06:43,000
So, let's talk about function definition in the lambda calculus.

145
00:06:43,000 --> 00:06:45,000
As I said before, we use a lambda to indicate

146
00:06:45,000 --> 00:06:47,000
that we're defining a new function.

147
00:06:47,000 --> 00:06:49,000
So, we got lambda calculus on the left,

148
00:06:49,000 --> 00:06:50,000
JavaScript on the right.

149
00:06:50,000 --> 00:06:53,000
This is a function that takes an a and returns whatever b is.

150
00:06:53,000 --> 00:06:55,000
Sort of throws away a,

151
00:06:55,000 --> 00:06:58,000
a b becomes irrelevant in this expression.

152
00:06:58,000 --> 00:07:01,000
The function abstraction like this is greedy.

153
00:07:01,000 --> 00:07:05,000
The body swallows up as much stuff to the right as it can,

154
00:07:05,000 --> 00:07:08,000
and that's all included in the body of this lambda abstraction.

155
00:07:08,000 --> 00:07:11,000
So, up into the point where it would stop making sense,

156
00:07:11,000 --> 00:07:16,000
like if you're using parens to force things to be evaluated differently.

157
00:07:16,000 --> 00:07:19,000
So, this indicates a function that takes an a,

158
00:07:19,000 --> 00:07:23,000
and it invokes b with x as its argument.

159
00:07:23,000 --> 00:07:25,000
We can disambiguate this with parentheses,

160
00:07:25,000 --> 00:07:28,000
but as I said, since lambda abstractions

161
00:07:28,000 --> 00:07:30,000
greedily swallow up everything to the right,

162
00:07:30,000 --> 00:07:32,000
these are actually useless parentheses,

163
00:07:32,000 --> 00:07:37,000
and we'll not really show them in most of the upcoming examples.

164
00:07:37,000 --> 00:07:39,000
On the other hand, if we use parentheses

165
00:07:39,000 --> 00:07:42,000
to force the thing on the left to be a function with a body

166
00:07:42,000 --> 00:07:45,000
that's just the b variable,

167
00:07:45,000 --> 00:07:48,000
now this is a different expression.

168
00:07:48,000 --> 00:07:51,000
Now we're saying take a function that goes from a to b

169
00:07:51,000 --> 00:07:56,000
and apply it to the argument x.

170
00:07:56,000 --> 00:07:59,000
As we saw a second ago in a demonstration

171
00:07:59,000 --> 00:08:02,000
in the lambda calculus we're allowed to nest functions.

172
00:08:02,000 --> 00:08:05,000
So, this is a function that takes an a

173
00:08:05,000 --> 00:08:09,000
and returns a new function that new function takes a b

174
00:08:09,000 --> 00:08:12,000
and that function returns an a.

175
00:08:12,000 --> 00:08:16,000
So, just to reprise our curried addition function from a second ago,

176
00:08:16,000 --> 00:08:19,000
we have this function that takes an a,

177
00:08:19,000 --> 00:08:21,000
returns a function that takes a b,

178
00:08:21,000 --> 00:08:23,000
and that returns a plus b.

179
00:08:23,000 --> 00:08:28,000
So, we have to feed out the arguments not like this all at once,

180
00:08:28,000 --> 00:08:32,000
but rather each argument one at a time

181
00:08:32,000 --> 00:08:36,000
in a successive invocations,

182
00:08:36,000 --> 00:08:41,000
and we get the result we want, known as currying.

183
00:08:41,000 --> 00:08:44,000
Again, we can clarify this using parentheses.

184
00:08:44,000 --> 00:08:47,000
The lambda on the left returns the inner lambda,

185
00:08:47,000 --> 00:08:49,000
and then we can use that.

186
00:08:49,000 --> 00:08:51,000
But since these are useless parentheses,

187
00:08:51,000 --> 00:08:55,000
we'll omit them in most of the examples.

188
00:08:55,000 --> 00:08:56,000
How are we doing so far?

189
00:08:56,000 --> 00:09:00,000
Questions about the bare syntax of the lambda calculus?

190
00:09:00,000 --> 00:09:03,000
As you can see, it's very similar to JavaScript,

191
00:09:03,000 --> 00:09:06,000
except you don't have parentheses around function invocation.

192
00:09:06,000 --> 00:09:08,000
You just put things next to each other,

193
00:09:08,000 --> 00:09:10,000
and that indicates apply a function on the left

194
00:09:10,000 --> 00:09:14,000
to the argument on the right.

195
00:09:14,000 --> 00:09:16,000
Cool.

196
00:09:16,000 --> 00:09:17,000
All right.

197
00:09:17,000 --> 00:09:19,000
So, I swear this is going to be the most complicated bit

198
00:09:19,000 --> 00:09:21,000
of lambda calculus syntax we have to deal with.

199
00:09:21,000 --> 00:09:23,000
It's called beta reduction.

200
00:09:23,000 --> 00:09:26,000
It's got a scary name, but it really just means

201
00:09:26,000 --> 00:09:30,000
tracing the logic, evaluating the function invocations,

202
00:09:30,000 --> 00:09:32,000
seeing what we end up with.

203
00:09:32,000 --> 00:09:36,000
So beta reduction is just the act of taking a function

204
00:09:36,000 --> 00:09:39,000
and applying it to its argument.

205
00:09:39,000 --> 00:09:41,000
So here we've got this function in red

206
00:09:41,000 --> 00:09:43,000
applied to the argument underlined.

207
00:09:43,000 --> 00:09:45,000
What we do is we take the argument,

208
00:09:45,000 --> 00:09:48,000
and it comes in as the parameter of the function.

209
00:09:48,000 --> 00:09:51,000
This is a function that takes an A and returns an A.

210
00:09:52,000 --> 00:09:55,000
So this argument, the BCB function,

211
00:09:55,000 --> 00:09:59,000
is going to replace in the body of the function every A.

212
00:09:59,000 --> 00:10:01,000
We go look in the body, find all the As,

213
00:10:01,000 --> 00:10:04,000
and we substitute in this other expression.

214
00:10:04,000 --> 00:10:09,000
And that gives us this first simplification.

215
00:10:09,000 --> 00:10:11,000
Well, we continue doing this.

216
00:10:11,000 --> 00:10:13,000
We've got a new function, the BCB function,

217
00:10:13,000 --> 00:10:16,000
being applied to another argument, the X argument.

218
00:10:16,000 --> 00:10:18,000
So we're going to take the X argument

219
00:10:18,000 --> 00:10:22,000
and substitute it in as the parameter to the function.

220
00:10:22,000 --> 00:10:24,000
So we go look inside the function body,

221
00:10:24,000 --> 00:10:27,000
find all the B's, and replace them all with X's.

222
00:10:27,000 --> 00:10:31,000
And we get this new function as a result.

223
00:10:31,000 --> 00:10:33,000
Once again, we've got a function

224
00:10:33,000 --> 00:10:35,000
that we're going to apply to an argument.

225
00:10:35,000 --> 00:10:39,000
We take the argument, we pass it into the function's parameter.

226
00:10:39,000 --> 00:10:41,000
We go look in the body for all the C's.

227
00:10:41,000 --> 00:10:43,000
There are no C's in this body.

228
00:10:43,000 --> 00:10:45,000
We replace all the C's with that argument,

229
00:10:45,000 --> 00:10:48,000
and that gives us this simplification.

230
00:10:48,000 --> 00:10:50,000
At this point, we've got nothing left to do.

231
00:10:50,000 --> 00:10:52,000
There are no more reducible expressions.

232
00:10:52,000 --> 00:10:54,000
So we say this is in beta normal form,

233
00:10:54,000 --> 00:10:56,000
which is just a hilarious way of saying

234
00:10:56,000 --> 00:11:01,000
we've fully evaluated the function in a terminal way.

235
00:11:01,000 --> 00:11:04,000
So it looks a little dense

236
00:11:04,000 --> 00:11:06,000
compared to what you're used to with JavaScript,

237
00:11:06,000 --> 00:11:11,000
but it's really nothing that we haven't done many times in JavaScript.

238
00:11:11,000 --> 00:11:14,000
Taking a function, passing in arguments as the parameters,

239
00:11:14,000 --> 00:11:17,000
and then in the body, everywhere that parameter exists,

240
00:11:17,000 --> 00:11:20,000
it's been replaced by a value.

241
00:11:20,000 --> 00:11:22,000
There's some caveats here.

242
00:11:22,000 --> 00:11:24,000
I'm not going to cover in this presentation.

243
00:11:24,000 --> 00:11:26,000
If you could do multiple reductions

244
00:11:26,000 --> 00:11:29,000
in different places in the expression simultaneously,

245
00:11:29,000 --> 00:11:33,000
there are caveats and strategies to which ones you should do first.

246
00:11:33,000 --> 00:11:37,000
And there's also possible ways that two separate functions

247
00:11:37,000 --> 00:11:39,000
that coincidentally share the same variable names,

248
00:11:39,000 --> 00:11:42,000
you want to avoid conflating those two variables,

249
00:11:42,000 --> 00:11:43,000
which mean different things.

250
00:11:43,000 --> 00:11:45,000
So there are some gotchas,

251
00:11:45,000 --> 00:11:49,000
but they're kind of outside the scope of this talk.

252
00:11:49,000 --> 00:11:52,000
Let's see another combinator here, the mockingbird.

253
00:11:52,000 --> 00:11:54,000
This is a fun function.

254
00:11:54,000 --> 00:11:56,000
It takes a function as input,

255
00:11:56,000 --> 00:12:01,000
and it invokes that function passing in itself.

256
00:12:01,000 --> 00:12:05,000
This is the self-application combinator.

257
00:12:05,000 --> 00:12:06,000
Whoa, what's happening here?

258
00:12:06,000 --> 00:12:07,000
This is craziness.

259
00:12:07,000 --> 00:12:08,000
Let's try it out.

260
00:12:08,000 --> 00:12:11,000
The mockingbird is a function that takes a function,

261
00:12:11,000 --> 00:12:14,000
calls the function on itself.

262
00:12:14,000 --> 00:12:17,000
What might the mockingbird of identity be?

263
00:12:17,000 --> 00:12:23,000
Somebody walked me through the logic here.

264
00:12:23,000 --> 00:12:26,000
What's f in this function?

265
00:12:26,000 --> 00:12:28,000
It's the identity.

266
00:12:28,000 --> 00:12:30,000
What are we doing with it?

267
00:12:30,000 --> 00:12:35,000
Identity of identity.

268
00:12:35,000 --> 00:12:37,000
We already solved that before, right?

269
00:12:37,000 --> 00:12:38,000
What is the answer?

270
00:12:38,000 --> 00:12:40,000
It's the identity.

271
00:12:40,000 --> 00:12:42,000
The self-application of identity is identity.

272
00:12:42,000 --> 00:12:45,000
We saw that earlier.

273
00:12:45,000 --> 00:12:48,000
This one's going to be a little bit more disconcerting.

274
00:12:48,000 --> 00:12:53,000
What is the self-application of self-application?

275
00:12:53,000 --> 00:12:56,000
Feel free to yell it out if you think you got it.

276
00:12:56,000 --> 00:13:05,000
It may be hinted at by the fact that I'm putting this in a try-catch block.

277
00:13:05,000 --> 00:13:10,000
Any takers?

278
00:13:10,000 --> 00:13:12,000
Call stack size exceeded.

279
00:13:12,000 --> 00:13:14,000
What just happened?

280
00:13:14,000 --> 00:13:19,000
Well, mockingbird of identity is identity of identity, self-application.

281
00:13:19,000 --> 00:13:23,000
We already know that that is identity, so that made sense.

282
00:13:23,000 --> 00:13:26,000
That does reduce to a better normal form.

283
00:13:26,000 --> 00:13:31,000
But the mockingbird of the mockingbird is the self-application of self-application.

284
00:13:31,000 --> 00:13:35,000
So we take self-application and we apply it to itself.

285
00:13:35,000 --> 00:13:39,000
But if we're going to evaluate that, that's the self-application of self-application.

286
00:13:39,000 --> 00:13:45,000
So we take the self-application and uh-oh, it just goes on forever.

287
00:13:45,000 --> 00:13:47,000
This is a problem.

288
00:13:47,000 --> 00:13:53,000
The problem is we don't always know if some lambda term is going to have a beta normal form.

289
00:13:53,000 --> 00:13:56,000
We don't know if this process ends or not.

290
00:13:56,000 --> 00:13:58,000
Sometimes it doesn't end.

291
00:13:58,000 --> 00:14:02,000
Sometimes it diverges, which means it goes on forever.

292
00:14:02,000 --> 00:14:07,000
And in fact, there's no way to know in a general way if a given expression,

293
00:14:07,000 --> 00:14:12,000
there's no single algorithm that can tell you whether or not one of these expressions will stop.

294
00:14:12,000 --> 00:14:15,000
That's known as the halting problem and Alan Turing figured it out.

295
00:14:15,000 --> 00:14:21,000
Now for an individual one, you can prove through ad hoc means that, yeah,

296
00:14:21,000 --> 00:14:23,000
for instance, this one is going to go on forever.

297
00:14:23,000 --> 00:14:28,000
So it's not that it's always unanswerable, just that there's no one set of steps that you can take

298
00:14:28,000 --> 00:14:34,000
that will cause that, that you will know whether or not it halts.

299
00:14:34,000 --> 00:14:39,000
This particular divergent term, by the way, is called the omega combinator.

300
00:14:39,000 --> 00:14:44,000
Omega because it's like the end, alpha and the omega.

301
00:14:44,000 --> 00:14:48,000
And sometimes the mockingbird as a result is called little omega.

302
00:14:48,000 --> 00:14:52,000
One of the problems you'll find if you start going out and reading about all this stuff

303
00:14:52,000 --> 00:14:56,000
is that a lot of different mathematicians and programmers and people have worked on it over time

304
00:14:56,000 --> 00:14:59,000
and they've all given their own pet names to these things.

305
00:14:59,000 --> 00:15:05,000
So there's a lot of synonyms and sometimes even intersection.

306
00:15:05,000 --> 00:15:10,000
Okay, we're almost done with lambda calculus syntax, but I lied before and I said it was the end.

307
00:15:10,000 --> 00:15:13,000
There's one more thing I want to show you about syntax here.

308
00:15:13,000 --> 00:15:17,000
We can do, as I said before, these nested lambdas.

309
00:15:17,000 --> 00:15:22,000
We could say there's a function that takes an A and that returns a function that takes a B,

310
00:15:22,000 --> 00:15:26,000
which returns a function that takes a C, which finally returns a B.

311
00:15:26,000 --> 00:15:31,000
But the way we're using these functions, we just kind of think of, well,

312
00:15:31,000 --> 00:15:35,000
we're going to call it with both arguments at once in quotes,

313
00:15:35,000 --> 00:15:38,000
really meaning we feed it the first argument then the second argument.

314
00:15:38,000 --> 00:15:42,000
But we think of it as taking two arguments just in a curried way.

315
00:15:42,000 --> 00:15:47,000
So in order to kind of make it easier to write this stuff down and parse it,

316
00:15:47,000 --> 00:15:51,000
there's a little bit of a shorthand where we just condense all the nested lambdas

317
00:15:51,000 --> 00:15:53,000
and say, here's a ternary function.

318
00:15:53,000 --> 00:15:56,000
Here's a function that takes three inputs and returns something.

319
00:15:56,000 --> 00:15:58,000
But don't get fooled.

320
00:15:58,000 --> 00:16:01,000
These don't come in all simultaneously.

321
00:16:01,000 --> 00:16:05,000
We feed them into the function one after the other.

322
00:16:05,000 --> 00:16:09,000
So this still means nested lambda expressions.

323
00:16:09,000 --> 00:16:14,000
It's just a convenient shorthand for indicating that they're curried.

324
00:16:14,000 --> 00:16:17,000
I'm not going to go through all of the logic of this again.

325
00:16:17,000 --> 00:16:22,000
It's the exact same example we saw before of feeding an argument into its parameter

326
00:16:22,000 --> 00:16:26,000
and replacing the parameter in the body, feeding an argument into its parameter

327
00:16:26,000 --> 00:16:29,000
and replacing the parameter in the body.

328
00:16:29,000 --> 00:16:35,000
But this time I've used the syntax shorthand to show those nested lambdas.

329
00:16:35,000 --> 00:16:40,000
So the body of this one is another lambda and then we proceed as normal

330
00:16:40,000 --> 00:16:44,000
and the rest of this is exactly identical to what we saw before.

331
00:16:44,000 --> 00:16:46,000
So just a shorthand.

332
00:16:46,000 --> 00:16:49,000
Don't get too tripped up over it, but it's going to be convenient for us

333
00:16:49,000 --> 00:16:53,000
to be able to think conceptually of functions that take multiple arguments

334
00:16:53,000 --> 00:16:58,000
even though we know, we'll just keep that as a footnote, that they're all curried functions.

335
00:16:58,000 --> 00:17:01,000
Are you ready for the next combinator?

336
00:17:01,000 --> 00:17:04,000
Let's talk about the kestrel.

337
00:17:04,000 --> 00:17:10,000
The kestrel takes an A and a B and it returns A.

338
00:17:10,000 --> 00:17:15,000
Let's try that out.

339
00:17:15,000 --> 00:17:19,000
Takes an A, takes a B, returns A.

340
00:17:19,000 --> 00:17:23,000
What is the kestrel of the identity in the mockingbird?

341
00:17:23,000 --> 00:17:26,000
Yeah.

342
00:17:26,000 --> 00:17:31,000
What about the kestrel of the kestrel in the mockingbird?

343
00:17:31,000 --> 00:17:34,000
Right.

344
00:17:34,000 --> 00:17:38,000
It doesn't matter what the second thing is, it's irrelevant.

345
00:17:38,000 --> 00:17:48,000
The kestrel just takes two things and returns the first one.

346
00:17:48,000 --> 00:17:52,000
So we just saw that here.

347
00:17:52,000 --> 00:17:57,000
In Haskell, this is built into the base language as the const function.

348
00:17:57,000 --> 00:17:59,000
Why is it called const in Haskell?

349
00:17:59,000 --> 00:18:01,000
Let's try something interesting here.

350
00:18:01,000 --> 00:18:09,000
I'm going to say k5 is the function you get when you call k with only one of its arguments.

351
00:18:09,000 --> 00:18:12,000
So normally the kestrel takes two arguments and gives you back the first one,

352
00:18:12,000 --> 00:18:15,000
but I'm only going to give it one of its arguments.

353
00:18:15,000 --> 00:18:21,000
Well, that's interesting, but these are curried functions, so I can give it another argument.

354
00:18:21,000 --> 00:18:23,000
It gives me back the first thing.

355
00:18:23,000 --> 00:18:25,000
I can also give it back some other argument.

356
00:18:25,000 --> 00:18:27,000
It gives me back the first thing.

357
00:18:27,000 --> 00:18:30,000
This is a function that's fixated on a particular value.

358
00:18:30,000 --> 00:18:32,000
It's the constant five function.

359
00:18:32,000 --> 00:18:38,000
No matter how I invoke this function, it always gives me back five.

360
00:18:38,000 --> 00:18:41,000
That's why it's called const in Haskell.

361
00:18:41,000 --> 00:18:44,000
But it's the k-combinator.

362
00:18:44,000 --> 00:18:46,000
Here's a fun one.

363
00:18:46,000 --> 00:18:48,000
I really like this one.

364
00:18:48,000 --> 00:18:52,000
The kestrel of identity and some x is?

365
00:18:52,000 --> 00:18:53,000
Identity.

366
00:18:53,000 --> 00:18:55,000
Identity, makes sense.

367
00:18:55,000 --> 00:18:57,000
This is an algebraic equality.

368
00:18:57,000 --> 00:19:01,000
The thing on the left is the thing on the right and vice versa.

369
00:19:01,000 --> 00:19:04,000
Well, the thing on the right is a function.

370
00:19:04,000 --> 00:19:09,000
And I know in the lambda calculus I'm allowed to apply functions to values.

371
00:19:09,000 --> 00:19:11,000
So I apply this to y.

372
00:19:11,000 --> 00:19:14,000
What do I get?

373
00:19:14,000 --> 00:19:15,000
Yy.

374
00:19:15,000 --> 00:19:17,000
Y, that makes sense.

375
00:19:17,000 --> 00:19:21,000
On the left side equals the middle side equals the right side.

376
00:19:21,000 --> 00:19:23,000
That means I can ignore the thing in the middle,

377
00:19:23,000 --> 00:19:25,000
and the thing on the left equals the thing on the right.

378
00:19:25,000 --> 00:19:28,000
Does anybody see where I'm going with this?

379
00:19:28,000 --> 00:19:34,000
I've got ki of x and y returns y.

380
00:19:34,000 --> 00:19:40,000
Ki of a first argument and a second argument returns the second argument.

381
00:19:40,000 --> 00:19:45,000
I just derived the kite.

382
00:19:46,000 --> 00:19:51,000
The kite combinator takes two arguments.

383
00:19:51,000 --> 00:19:53,000
One and two.

384
00:19:53,000 --> 00:19:56,000
And it gives you back the second one.

385
00:19:56,000 --> 00:19:58,000
Now, I could have done this manually.

386
00:19:58,000 --> 00:20:04,000
I could have said the kite is a function that takes an a,

387
00:20:04,000 --> 00:20:08,000
and it takes a b, and it returns b.

388
00:20:08,000 --> 00:20:12,000
And then I would call the kite on something like four and nine,

389
00:20:12,000 --> 00:20:14,000
and it gives me back nine.

390
00:20:14,000 --> 00:20:20,000
But it's cool to see that from these atomic combinators combined together,

391
00:20:20,000 --> 00:20:23,000
I get these new molecules, which are other combinators.

392
00:20:23,000 --> 00:20:26,000
So some of my combinators can mix and match

393
00:20:26,000 --> 00:20:31,000
and start producing other functions that are useful and interesting in different ways.

394
00:20:31,000 --> 00:20:38,000
So ki of m and ki is?

395
00:20:38,000 --> 00:20:42,000
Yes.

396
00:20:42,000 --> 00:20:45,000
So kite of the mockingbird in the Kestrel's castle.

397
00:20:45,000 --> 00:20:46,000
Flip them around.

398
00:20:46,000 --> 00:20:47,000
You get the other one.

399
00:20:47,000 --> 00:20:49,000
So far, so good.

400
00:20:49,000 --> 00:20:52,000
At this point, probably some of you are wondering,

401
00:20:52,000 --> 00:20:54,000
what's with all the bird names?

402
00:20:54,000 --> 00:20:57,000
Got mockingbird, Kestrel, kite, et cetera.

403
00:20:57,000 --> 00:20:58,000
All right.

404
00:20:58,000 --> 00:21:01,000
So we're going to take a little mental break for a moment and talk about history.

405
00:21:01,000 --> 00:21:04,000
Moses Eliachchenfinkel.

406
00:21:04,000 --> 00:21:07,000
And I can't pronounce German, so please forgive me.

407
00:21:07,000 --> 00:21:10,000
Name these things, long German names.

408
00:21:10,000 --> 00:21:15,000
Like Zussim et Setsum function.

409
00:21:15,000 --> 00:21:18,000
Haskell B. Curry, who came a little bit later,

410
00:21:18,000 --> 00:21:22,000
used some of the same letters, but also some of his own letters,

411
00:21:22,000 --> 00:21:24,000
just to add to the confusion.

412
00:21:24,000 --> 00:21:29,000
And in the 1980s, a logician and puzzle author named Raymond Smullyan

413
00:21:29,000 --> 00:21:32,000
wrote this absolutely wonderful book to mock a mockingbird.

414
00:21:32,000 --> 00:21:37,000
The whole back two thirds of which is about combinatorial logic.

415
00:21:37,000 --> 00:21:42,000
And Smullyan took Curry's combinator names and turned them into birds.

416
00:21:42,000 --> 00:21:47,000
And the reason is because the book doesn't lay a lot of emphasis

417
00:21:47,000 --> 00:21:50,000
on the math from a formal perspective.

418
00:21:50,000 --> 00:21:54,000
Instead, it uses this metaphor of birds in a forest

419
00:21:54,000 --> 00:21:59,000
who hear the songs of other birds and sing back the names of other birds.

420
00:21:59,000 --> 00:22:03,000
So birds creating birds and singing birds and all this kind of stuff.

421
00:22:04,000 --> 00:22:08,000
Now, unfortunately, Smullyan called the identity combinator the idiot bird.

422
00:22:08,000 --> 00:22:10,000
I wish that he had used the ibis.

423
00:22:10,000 --> 00:22:14,000
I used the ibis in my first slide, but we'll forgive him

424
00:22:14,000 --> 00:22:17,000
because the rest of the book is just so wonderful.

425
00:22:17,000 --> 00:22:20,000
Now, he didn't do this totally for no reason.

426
00:22:20,000 --> 00:22:25,000
He actually did it to honor Curry because Curry was himself an avid bird watcher.

427
00:22:25,000 --> 00:22:30,000
And at this point, some of you are thinking, Haskell Curry, who's this guy?

428
00:22:30,000 --> 00:22:32,000
Why do we care about him?

429
00:22:32,000 --> 00:22:35,000
I'm not Sean Finkel or vice versa.

430
00:22:35,000 --> 00:22:40,000
So the next slide is the anti-diversity slide.

431
00:22:40,000 --> 00:22:44,000
This is just the historical nature of mathematics in the 20s and 30s.

432
00:22:44,000 --> 00:22:46,000
It was filled with a lot of white men.

433
00:22:46,000 --> 00:22:49,000
So we'll acknowledge that and move on.

434
00:22:49,000 --> 00:22:52,000
But I'm going to give you a really fast crash course

435
00:22:52,000 --> 00:22:54,000
in the formalization of mathematical logic.

436
00:22:54,000 --> 00:22:58,000
Around the late 19th century, early 20th century,

437
00:22:58,000 --> 00:23:02,000
people were realizing that math, which had seemed on the face of it

438
00:23:02,000 --> 00:23:07,000
so cut and dried and straightforward, was hiding some really nasty paradoxes.

439
00:23:07,000 --> 00:23:10,000
And so people were trying to unify mathematics and figure out

440
00:23:10,000 --> 00:23:15,000
the sufficient axioms that would define all of mathematics in one big tone.

441
00:23:15,000 --> 00:23:18,000
So what was like the real, true system of math?

442
00:23:18,000 --> 00:23:20,000
Bless you.

443
00:23:20,000 --> 00:23:22,000
So I'm going to race through this.

444
00:23:22,000 --> 00:23:23,000
I could do an entire presentation.

445
00:23:23,000 --> 00:23:25,000
That would be two hours on just this.

446
00:23:25,000 --> 00:23:29,000
I'm going to try and keep it to less than five minutes.

447
00:23:29,000 --> 00:23:34,000
In 89, Giuseppe Piano invents his own formal notation for function abstraction.

448
00:23:34,000 --> 00:23:39,000
He also defines arithmetic as the sequence of natural numbers starting from zero,

449
00:23:39,000 --> 00:23:43,000
and then the successor of zero, and then the successor of successor of zero,

450
00:23:43,000 --> 00:23:46,000
and the successor of successor of successor of zero, and so on and so forth.

451
00:23:46,000 --> 00:23:49,000
These are Piano numbers.

452
00:23:49,000 --> 00:23:55,000
The logician Gottlob Frege develops his own function notation,

453
00:23:55,000 --> 00:23:57,000
which uses this really unique graph format.

454
00:23:57,000 --> 00:23:59,000
It's actually really cool to say.

455
00:23:59,000 --> 00:24:01,000
Impossible to read.

456
00:24:01,000 --> 00:24:06,000
But a good idea, a good idea which has better versions that come later.

457
00:24:06,000 --> 00:24:11,000
And most famously, he basically invents quantified axiomatic logic.

458
00:24:11,000 --> 00:24:15,000
So this is the kind of sentence like, for all x in the reals,

459
00:24:15,000 --> 00:24:19,000
there exists a y in the reals such that y is greater than x.

460
00:24:19,000 --> 00:24:22,000
For all, and there exists.

461
00:24:22,000 --> 00:24:26,000
That's the quantification and quantified axiomatic logic.

462
00:24:26,000 --> 00:24:31,000
By the way, Frege, even in 1891, was using curried functions.

463
00:24:31,000 --> 00:24:36,000
In the 1910s, Bertrand Russell, along with Whitehead,

464
00:24:36,000 --> 00:24:38,000
very famously published Principia Mathematica,

465
00:24:38,000 --> 00:24:41,000
an attempt at formalizing all math,

466
00:24:41,000 --> 00:24:45,000
but he also discovered earlier than that, actually, Russell's paradox,

467
00:24:45,000 --> 00:24:49,000
the thing of all sets that do not contain themselves.

468
00:24:49,000 --> 00:24:52,000
Well, is that set in itself or not?

469
00:24:52,000 --> 00:24:55,000
It's a paradox. It's impossible to figure out.

470
00:24:55,000 --> 00:25:00,000
So that made a lot of people really disconcerted,

471
00:25:00,000 --> 00:25:07,000
and they realized that math wasn't quite so perfect in its foundations as first thought.

472
00:25:07,000 --> 00:25:11,000
Schoen Finkl, we talked about, he was an early pioneer in combinatorial logic.

473
00:25:11,000 --> 00:25:16,000
He also used currying and published one paper, and then it was really sad, actually.

474
00:25:16,000 --> 00:25:19,000
The rest of his life really spiraled downhill.

475
00:25:19,000 --> 00:25:24,000
He ended up in a mental asylum, which don't worry,

476
00:25:24,000 --> 00:25:29,000
it's not because of combinatorial logic, I don't think.

477
00:25:29,000 --> 00:25:33,000
Van Neumann, famous mathematician, also later in life,

478
00:25:33,000 --> 00:25:36,000
helped build the first real electric computers.

479
00:25:36,000 --> 00:25:41,000
He also kind of did something that, if you reinterpret it, it's combinatorial logic,

480
00:25:41,000 --> 00:25:45,000
but that was almost by accident, like that wasn't his goal in life.

481
00:25:45,000 --> 00:25:49,000
And then in 26, Haskell Curry starts reinventing combinatorial logic.

482
00:25:49,000 --> 00:25:52,000
He wasn't aware of Schoen Finkl or Frege, well, he was aware of Frege,

483
00:25:52,000 --> 00:25:55,000
but not any kind of link to combinatorics.

484
00:25:55,000 --> 00:25:58,000
And so he does a whole bunch of contributions.

485
00:25:58,000 --> 00:26:05,000
He's a really smart guy at Princeton, and in 1927, he discovers that Schoen Finkl beat him to the punch.

486
00:26:05,000 --> 00:26:09,000
So he forges on nonetheless, which is good for us,

487
00:26:09,000 --> 00:26:12,000
because he develops many, many new theorems.

488
00:26:12,000 --> 00:26:18,000
In 1931, Cort Godot, very famous mathematician,

489
00:26:18,000 --> 00:26:22,000
who kind of plunged a dagger into the very heart of math,

490
00:26:22,000 --> 00:26:29,000
discovers that this race in search for the perfect set of foundations for math is fundamentally flawed.

491
00:26:29,000 --> 00:26:33,000
It's a fool's errand, it's impossible, it's literally impossible,

492
00:26:33,000 --> 00:26:39,000
because every complicated enough system to be interesting by a certain definition of interesting,

493
00:26:39,000 --> 00:26:45,000
such as piano numbers, is either inconsistent or incomplete.

494
00:26:45,000 --> 00:26:49,000
That means there's either logical inconsistencies which make it make no sense,

495
00:26:49,000 --> 00:26:54,000
or there are systems and things inside that language which you can talk about,

496
00:26:54,000 --> 00:26:56,000
but you can't prove or disprove.

497
00:26:56,000 --> 00:26:58,000
There's no way to get to the proof or disprove.

498
00:26:58,000 --> 00:27:01,000
That totally upends math as we know it.

499
00:27:02,000 --> 00:27:08,000
In the 30s, Alonzo Church is trying to figure out a system that's at least good enough

500
00:27:08,000 --> 00:27:12,000
to compute things that are computable in some definition of computable,

501
00:27:12,000 --> 00:27:16,000
and he develops this thing that we've been talking about the whole time, lambda calculus,

502
00:27:16,000 --> 00:27:19,000
this notation system for writing down functions.

503
00:27:19,000 --> 00:27:27,000
Now, it's this tiny, tiny language, and at first, his grad students such as Stephen Klaney and Rosser,

504
00:27:28,000 --> 00:27:32,000
they think that it's not going to really lead too much, like it's just a notation system,

505
00:27:32,000 --> 00:27:35,000
but then they start to realize like it's ballooning outwards,

506
00:27:35,000 --> 00:27:40,000
and it's from this very tiny bit of logic is coming all sorts of interesting results.

507
00:27:40,000 --> 00:27:46,000
They also prove different versions of it are consistent or inconsistent.

508
00:27:46,000 --> 00:27:53,000
Stephen Klaney, by the way, goes on later in life to invent this thing that we use all the time called regular expressions,

509
00:27:53,000 --> 00:27:56,000
so that's fun.

510
00:27:56,000 --> 00:28:04,000
In 1936, Alonzo Church solves a famous unsolved problem, David Hilbert's decision problem.

511
00:28:04,000 --> 00:28:09,000
This is an algorithm problem that says like, well, actually, I can't remember the specifics,

512
00:28:09,000 --> 00:28:11,000
but it's, let me see.

513
00:28:11,000 --> 00:28:15,000
Oh, is there a way to figure out if any given problem does have a solution,

514
00:28:15,000 --> 00:28:18,000
very closely related to, but distinct from the halting problem?

515
00:28:18,000 --> 00:28:22,000
And Church is like, no, there isn't.

516
00:28:22,000 --> 00:28:29,000
But he uses the lambda calculus to solve it, which was hilarious because it started out as three or four lines of notation,

517
00:28:29,000 --> 00:28:35,000
and it turned into a system complicated enough to solve this famous unsolved problem.

518
00:28:35,000 --> 00:28:37,000
Guess what also happens in 1936?

519
00:28:37,000 --> 00:28:41,000
Two months later, Alon Turing solves the problem using something called a Turing machine,

520
00:28:41,000 --> 00:28:46,000
and he publishes his own paper, and then he finds out that Church beat him to the punch by two months,

521
00:28:46,000 --> 00:28:48,000
and he gets really annoyed by that.

522
00:28:48,000 --> 00:28:52,000
He was actually quite disappointed to find out that someone else had raced him

523
00:28:52,000 --> 00:28:55,000
and beat him to solving the decision problem.

524
00:28:55,000 --> 00:28:59,000
But he looks at the paper, he looks at Church's lambda calculus and says, you know what?

525
00:28:59,000 --> 00:29:01,000
These are actually identical.

526
00:29:01,000 --> 00:29:08,000
My Turing machines and Church's lambda calculus are the exact same thing just expressed different ways.

527
00:29:08,000 --> 00:29:15,000
So then he decides, you know what, I'll bury the hatchet, come to Princeton, get a PhD under Church with Church as his advisor.

528
00:29:15,000 --> 00:29:21,000
And in 1937, he publishes the first fixed point combinator.

529
00:29:21,000 --> 00:29:24,000
Okay, that's the history.

530
00:29:24,000 --> 00:29:29,000
In the tiniest nutshell I could manage, or at least bear to part with.

531
00:29:29,000 --> 00:29:32,000
So, combinator.

532
00:29:32,000 --> 00:29:34,000
You keep using that word.

533
00:29:34,000 --> 00:29:36,000
I don't think it means what you think it means.

534
00:29:36,000 --> 00:29:38,000
What is a combinator?

535
00:29:38,000 --> 00:29:41,000
We've said this thing many times, combinator logic and combinator's lambda calculus.

536
00:29:41,000 --> 00:29:43,000
Where's the dividing line?

537
00:29:43,000 --> 00:29:47,000
In reality, they're almost entirely the same thing.

538
00:29:47,000 --> 00:29:51,000
A combinator is a function with no free variables.

539
00:29:51,000 --> 00:29:57,000
A free variable is a variable in a function body that's not bound to some parameter.

540
00:29:57,000 --> 00:30:03,000
So this is a combinator because the B in the body is bound to the B parameter.

541
00:30:03,000 --> 00:30:06,000
Whereas that's not a combinator because A comes from nowhere.

542
00:30:06,000 --> 00:30:10,000
What is A? Who knows? We could make it up. It doesn't matter.

543
00:30:10,000 --> 00:30:15,000
It doesn't matter that we're not using the B. The B is irrelevant. It's a parameter.

544
00:30:15,000 --> 00:30:20,000
Not a combinator because where does the B come from? Don't know.

545
00:30:20,000 --> 00:30:22,000
And even more complicated stuff like this.

546
00:30:22,000 --> 00:30:25,000
Don't get distracted by the E. That's a parameter. It's not a variable.

547
00:30:25,000 --> 00:30:29,000
So everything that appears in the body, C and B, those are bound to parameters.

548
00:30:29,000 --> 00:30:34,000
That's a combinator. You now know what a combinator is.

549
00:30:34,000 --> 00:30:42,000
We've seen a bunch of combinators. Identity, self-application, first or const, second.

550
00:30:42,000 --> 00:30:49,000
And the cool thing is, as I mentioned before, using some of the primitive combinators mixed together,

551
00:30:49,000 --> 00:30:54,000
we start generating some of the more complicated combinators, or at least other combinators,

552
00:30:54,000 --> 00:30:58,000
which is surprising but cool.

553
00:30:58,000 --> 00:31:01,000
Are you ready for the next one?

554
00:31:01,000 --> 00:31:06,000
Let's look at the cardinal. Let's just look at it for a second.

555
00:31:06,000 --> 00:31:11,000
Not the beautiful photo, which I stole from somewhere. I can't remember where.

556
00:31:11,000 --> 00:31:18,000
But the combinator itself, anybody looking at this, can you think conceptually what this actually does

557
00:31:18,000 --> 00:31:24,000
in sort of a use case way?

558
00:31:24,000 --> 00:31:27,000
I'm really pushing you here because we're talking about abstract math,

559
00:31:27,000 --> 00:31:32,000
but we're just keeping you in a land with no JavaScript.

560
00:31:32,000 --> 00:31:40,000
Exactly. It just flips around arguments. It takes a function f that takes two parameters,

561
00:31:40,000 --> 00:31:46,000
and then it calls the function f with both of those parameters, but in the opposite order.

562
00:31:46,000 --> 00:31:53,000
So here's the C combinator, and what if we apply this to a function in two arguments,

563
00:31:53,000 --> 00:31:56,000
which is the kestrel and these other two things that we don't care what they are,

564
00:31:56,000 --> 00:31:58,000
but they're i and m in this case.

565
00:31:58,000 --> 00:32:04,000
The cardinal of the kestrel and the idiot and the mockingbird.

566
00:32:04,000 --> 00:32:09,000
Well, walking through it, it takes three things, the function and two arguments,

567
00:32:09,000 --> 00:32:13,000
and it calls the function. Which is the function here?

568
00:32:13,000 --> 00:32:18,000
k. And it calls them with two arguments. Which are the arguments?

569
00:32:18,000 --> 00:32:24,000
And it calls them in the opposite order. So it's k of m and i, which is?

570
00:32:24,000 --> 00:32:27,000
Yeah.

571
00:32:27,000 --> 00:32:33,000
So we start with the kestrel, and then we put two things into it, but backwards.

572
00:32:33,000 --> 00:32:35,000
That's interesting because look at what we have here.

573
00:32:35,000 --> 00:32:38,000
The cardinal of the kestrel takes two things and returns the second.

574
00:32:38,000 --> 00:32:42,000
Does that sound familiar?

575
00:32:42,000 --> 00:32:44,000
It's the kite.

576
00:32:44,000 --> 00:32:47,000
The cardinal of the kestrel is the kestrel of identity.

577
00:32:47,000 --> 00:32:51,000
The kite is this other thing. They're all the same.

578
00:32:51,000 --> 00:32:53,000
And we can just do this to prove it.

579
00:32:53,000 --> 00:32:56,000
Let's do the cardinal takes a function.

580
00:32:56,000 --> 00:32:59,000
This monitor went away. There we go.

581
00:32:59,000 --> 00:33:03,000
It takes a function, takes an argument, another argument,

582
00:33:03,000 --> 00:33:09,000
calls the argument with the arguments backwards.

583
00:33:09,000 --> 00:33:13,000
Let's get the cardinal of the kestrel.

584
00:33:13,000 --> 00:33:16,000
Apply it to two variables.

585
00:33:16,000 --> 00:33:18,000
The kestrel normally gives you back the first thing,

586
00:33:18,000 --> 00:33:21,000
but the cardinal of the kestrel gives you the second thing.

587
00:33:21,000 --> 00:33:28,000
It works. This isn't pure math. It's also applicable.

588
00:33:28,000 --> 00:33:31,000
So that's kind of fun. Cardinal, if you've got a cardinal,

589
00:33:31,000 --> 00:33:33,000
you can apply it in different ways.

590
00:33:33,000 --> 00:33:36,000
You can flip the kite around to get the kestrel or the kestrel to get the kite.

591
00:33:36,000 --> 00:33:39,000
And in fact, in Haskell, this is built into the base language,

592
00:33:39,000 --> 00:33:41,000
and it's called flip.

593
00:33:41,000 --> 00:33:47,000
And it actually ends up being useful from time to time.

594
00:33:47,000 --> 00:33:49,000
So why? Why are we learning this?

595
00:33:49,000 --> 00:33:51,000
What's actually going on here?

596
00:33:51,000 --> 00:33:54,000
How is this useful? Do we care?

597
00:33:54,000 --> 00:33:57,000
Remember, lambda cacos and Turing machines are equivalent.

598
00:33:57,000 --> 00:34:00,000
Anything one can calculate, the other can calculate.

599
00:34:00,000 --> 00:34:03,000
But Turing machines are exciting because they're these hypothetical devices

600
00:34:03,000 --> 00:34:07,000
that use state information that exists over here, here, here,

601
00:34:07,000 --> 00:34:12,000
and things that change over time to do computations.

602
00:34:12,000 --> 00:34:14,000
And from these hypothetical devices, people said,

603
00:34:14,000 --> 00:34:17,000
wait a second, we could build real machines that do this.

604
00:34:17,000 --> 00:34:19,000
And they use memory and state,

605
00:34:19,000 --> 00:34:21,000
and they do a little bit more complicated stuff

606
00:34:21,000 --> 00:34:24,000
just to make it more performant and easier to work with.

607
00:34:24,000 --> 00:34:27,000
But at their heart, they're really Turing machines.

608
00:34:27,000 --> 00:34:29,000
So they work with machine code,

609
00:34:29,000 --> 00:34:31,000
which means let's flip a whole bunch of physical switches

610
00:34:31,000 --> 00:34:34,000
and then see what electricity and bits come out the other end.

611
00:34:34,000 --> 00:34:38,000
And we abstract that away in a language, a text format called assembly language,

612
00:34:38,000 --> 00:34:43,000
that says things like, move the data in register B to the accumulator register.

613
00:34:43,000 --> 00:34:48,000
Add one to whatever value is in the accumulator register of my memory.

614
00:34:48,000 --> 00:34:52,000
Very stateful, very machine-based, very hard for humans to reason about.

615
00:34:52,000 --> 00:34:56,000
It's not conceptual. It's all about machines.

616
00:34:56,000 --> 00:35:00,000
Well, we build higher-level languages like C that compile into assembly.

617
00:35:00,000 --> 00:35:03,000
But those higher-level languages are still machine-centric.

618
00:35:03,000 --> 00:35:08,000
They still say things like, hey, see, go allocate seven bits of memory over here

619
00:35:08,000 --> 00:35:12,000
and give me back a reference to the pointer of that memory address and so on and so forth.

620
00:35:12,000 --> 00:35:14,000
So then somebody says, well, this is stupid.

621
00:35:14,000 --> 00:35:16,000
We'll make the programming languages do that for us,

622
00:35:16,000 --> 00:35:18,000
and we'll just focus more on concepts.

623
00:35:18,000 --> 00:35:20,000
Like, hey, give me a var x,

624
00:35:20,000 --> 00:35:22,000
and I don't care how you figure out the memory for that,

625
00:35:22,000 --> 00:35:24,000
just go do it yourself.

626
00:35:24,000 --> 00:35:27,000
And then somebody says, why are we even bothering with memory?

627
00:35:27,000 --> 00:35:32,000
Why don't we just have these pure functions that operate on each other?

628
00:35:32,000 --> 00:35:33,000
And wait a second.

629
00:35:33,000 --> 00:35:37,000
This whole time this machine march through abstraction

630
00:35:37,000 --> 00:35:41,000
has been leading us to something that existed before Turing machines existed,

631
00:35:41,000 --> 00:35:43,000
which is the lambda calculus.

632
00:35:43,000 --> 00:35:47,000
Functional programming languages are based on,

633
00:35:47,000 --> 00:35:51,000
slash their backbone is, the lambda calculus.

634
00:35:51,000 --> 00:35:54,000
So if we decide, wait, we're not going to organically evolve

635
00:35:54,000 --> 00:35:57,000
towards this kind of conceptual abstraction,

636
00:35:57,000 --> 00:36:01,000
but let's just start straight from the lambda calculus and go the other direction.

637
00:36:01,000 --> 00:36:04,000
We can start designing purely functional languages

638
00:36:04,000 --> 00:36:09,000
and using all the decades of mathematical research that have gone into LC

639
00:36:09,000 --> 00:36:11,000
to design our language and see what comes out of that

640
00:36:11,000 --> 00:36:13,000
and see if there's anything useful that we could do there.

641
00:36:13,000 --> 00:36:15,000
And then we'll take that pure functional language,

642
00:36:15,000 --> 00:36:22,000
just compile it down to machine code so it runs on our physical Turing machines.

643
00:36:22,000 --> 00:36:25,000
Lambda calculus and Turing machines are equivalent.

644
00:36:25,000 --> 00:36:30,000
Therefore, here's the big theme of the entire talk coming in the next slide.

645
00:36:30,000 --> 00:36:33,000
Everything can be functions.

646
00:36:33,000 --> 00:36:37,000
When I say everything, I mean everything.

647
00:36:37,000 --> 00:36:40,000
Like Booleans.

648
00:36:40,000 --> 00:36:41,000
Whoa.

649
00:36:41,000 --> 00:36:44,000
Here's a JavaScript Boolean expression.

650
00:36:44,000 --> 00:36:50,000
Not X is equal to, that's the double equals, not the assignment equals.

651
00:36:50,000 --> 00:36:55,000
Y or the result of the expression A and Z.

652
00:36:55,000 --> 00:36:57,000
How are we going to do this in lambda calculus?

653
00:36:57,000 --> 00:37:01,000
Well, it's a problem because we don't have negation.

654
00:37:01,000 --> 00:37:04,000
We don't have ors and and operators.

655
00:37:04,000 --> 00:37:07,000
I mean, we don't even have a quality checks in the lambda calculus, right?

656
00:37:07,000 --> 00:37:09,000
That wasn't in the language.

657
00:37:09,000 --> 00:37:11,000
We don't have Booleans.

658
00:37:11,000 --> 00:37:13,000
We do have parentheses.

659
00:37:13,000 --> 00:37:16,000
That's what we got.

660
00:37:16,000 --> 00:37:18,000
We got parens.

661
00:37:18,000 --> 00:37:21,000
All right, so how on earth are we going to do this?

662
00:37:21,000 --> 00:37:25,000
Let's start with the primitive building blocks, the Booleans.

663
00:37:25,000 --> 00:37:27,000
A bool.

664
00:37:27,000 --> 00:37:30,000
What is that used for in JavaScript?

665
00:37:30,000 --> 00:37:33,000
Well, what about selection?

666
00:37:33,000 --> 00:37:36,000
Some result is check a Boolean condition.

667
00:37:36,000 --> 00:37:39,000
If it's true, we'll get the first expression.

668
00:37:39,000 --> 00:37:42,000
If it's false, we'll get the second expression.

669
00:37:42,000 --> 00:37:45,000
Let's start translating this over to lambda calculus.

670
00:37:45,000 --> 00:37:49,000
Well, we got this ternary except, oops, this question mark and colon.

671
00:37:49,000 --> 00:37:51,000
That's not in the lambda calculus syntax.

672
00:37:51,000 --> 00:37:53,000
It's got to go. Bye-bye.

673
00:37:53,000 --> 00:37:55,000
What are we left with?

674
00:37:55,000 --> 00:37:57,000
This is a function application, right?

675
00:37:57,000 --> 00:37:59,000
So bool must be.

676
00:37:59,000 --> 00:38:01,000
What's the theme of the talk?

677
00:38:01,000 --> 00:38:03,000
A function.

678
00:38:03,000 --> 00:38:05,000
And, oh, well, what do we need here?

679
00:38:05,000 --> 00:38:08,000
We need a function that if it's the quote unquote true function,

680
00:38:08,000 --> 00:38:10,000
it selects the first expression.

681
00:38:10,000 --> 00:38:13,000
And if it's the false function, it selects the second expression.

682
00:38:13,000 --> 00:38:16,000
Wait a second. This sounds really familiar to me.

683
00:38:16,000 --> 00:38:20,000
Where have we seen a pair of functions that select either the first or second things?

684
00:38:20,000 --> 00:38:22,000
Yeah.

685
00:38:22,000 --> 00:38:24,000
We already have Booleans.

686
00:38:24,000 --> 00:38:26,000
We didn't even have to reinvent them.

687
00:38:26,000 --> 00:38:29,000
They're already in the language that we've developed so far in this talk.

688
00:38:29,000 --> 00:38:35,000
We'll just encode, in other words, represent Booleans as functions.

689
00:38:35,000 --> 00:38:38,000
We'll say that the kestrel function, the constant function,

690
00:38:38,000 --> 00:38:42,000
the first function is true, quote unquote, and the kite is false.

691
00:38:43,000 --> 00:38:45,000
That's kind of neat.

692
00:38:45,000 --> 00:38:49,000
Let's do that while we're looking at this slide and admiring it.

693
00:38:49,000 --> 00:38:53,000
True is equal to the kestrel.

694
00:38:53,000 --> 00:38:57,000
And false is equal to the kite.

695
00:38:57,000 --> 00:38:59,000
Now, there's a little node trick that I'll use here,

696
00:38:59,000 --> 00:39:03,000
because if I go console log out true, it tells me it's the kestrel,

697
00:39:03,000 --> 00:39:08,000
which is true, but in both senses.

698
00:39:08,000 --> 00:39:12,000
But it's also slightly annoying, like if I'm going to start doing Booleans.

699
00:39:12,000 --> 00:39:13,000
So I'm going to do a little trick here.

700
00:39:13,000 --> 00:39:24,000
I'm going to say t.inspect is a function that returns the string true slash kestrel.

701
00:39:24,000 --> 00:39:33,000
And false.inspect is a function that returns false or the kite.

702
00:39:34,000 --> 00:39:36,000
Now, if I log out t, I get t slash k.

703
00:39:36,000 --> 00:39:40,000
And if I log out false, I get false slash kite.

704
00:39:40,000 --> 00:39:46,000
So that'll be useful going forward in some of these demos.

705
00:39:46,000 --> 00:39:47,000
That wasn't lambda calculus.

706
00:39:47,000 --> 00:39:51,000
The other stuff was, but not the dot.inspect.

707
00:39:51,000 --> 00:39:53,000
OK, so we have true and false.

708
00:39:53,000 --> 00:39:55,000
But true and false on their own are kind of boring, right?

709
00:39:55,000 --> 00:39:57,000
Yeah, so we can select between two things.

710
00:39:57,000 --> 00:39:58,000
What about Boolean logic?

711
00:39:58,000 --> 00:40:01,000
What about vacation?

712
00:40:01,000 --> 00:40:03,000
Let's translate it.

713
00:40:03,000 --> 00:40:05,000
Well, what doesn't belong?

714
00:40:05,000 --> 00:40:08,000
One of these things is not like the others.

715
00:40:08,000 --> 00:40:13,000
The negation, the exclamation mark isn't in the lambda calculus syntax.

716
00:40:13,000 --> 00:40:15,000
What does it got to be instead?

717
00:40:15,000 --> 00:40:17,000
What's the theme of the talk?

718
00:40:17,000 --> 00:40:19,000
A function.

719
00:40:19,000 --> 00:40:20,000
The not function.

720
00:40:20,000 --> 00:40:26,000
The not function will take in a Boolean and it will select between two other Booleans.

721
00:40:26,000 --> 00:40:30,000
If we give it not true, it selects false.

722
00:40:30,000 --> 00:40:34,000
If we give it false, it selects true.

723
00:40:34,000 --> 00:40:36,000
How can we implement the not function?

724
00:40:36,000 --> 00:40:37,000
Well, wait a second.

725
00:40:37,000 --> 00:40:40,000
We just talked about selecting between two things.

726
00:40:40,000 --> 00:40:48,000
What kind of thing selects between two possibilities?

727
00:40:48,000 --> 00:40:49,000
We have a function.

728
00:40:49,000 --> 00:40:50,000
Yes, a function.

729
00:40:50,000 --> 00:40:52,000
That's true.

730
00:40:52,000 --> 00:40:58,000
But specifically, these Booleans that we're using, the kite and the kestrel,

731
00:40:58,000 --> 00:41:02,000
themselves functions that choose between two possibilities.

732
00:41:02,000 --> 00:41:04,000
Look at what I have here, this expression.

733
00:41:04,000 --> 00:41:05,000
An unknown Boolean p.

734
00:41:05,000 --> 00:41:06,000
It might be the kite.

735
00:41:06,000 --> 00:41:07,000
It might be the kestrel.

736
00:41:07,000 --> 00:41:09,000
I don't know which one.

737
00:41:09,000 --> 00:41:16,000
If it's the kestrel or true, which one of those does it select?

738
00:41:16,000 --> 00:41:20,000
The first one, false.

739
00:41:20,000 --> 00:41:27,000
And if my unknown Boolean is the kite, which does it select?

740
00:41:27,000 --> 00:41:29,000
The second one, true.

741
00:41:29,000 --> 00:41:34,000
My unknown Boolean selects its own opposite in this expression.

742
00:41:34,000 --> 00:41:38,000
So we'll turn this into a function and we'll call it not.

743
00:41:38,000 --> 00:41:39,000
That's it.

744
00:41:39,000 --> 00:41:46,000
Not just takes a Boolean and then tells the Boolean select your opposite.

745
00:41:46,000 --> 00:41:49,000
I promise it works.

746
00:41:50,000 --> 00:41:57,000
So not takes, let's say it takes a Boolean and then it calls the Boolean passing in false and true.

747
00:41:57,000 --> 00:42:00,000
So if we say not true, that's false.

748
00:42:00,000 --> 00:42:02,000
And not false is true.

749
00:42:02,000 --> 00:42:05,000
I've not put a single JavaScript Boolean into any of this.

750
00:42:05,000 --> 00:42:06,000
I'm doing negation.

751
00:42:06,000 --> 00:42:13,000
This is like, this should be exciting.

752
00:42:13,000 --> 00:42:14,000
All right.

753
00:42:14,000 --> 00:42:18,000
So our church encodings, which is what these things are called for Booleans now includes

754
00:42:18,000 --> 00:42:19,000
negation.

755
00:42:19,000 --> 00:42:22,000
We saw how we got true and false.

756
00:42:22,000 --> 00:42:24,000
But there's a more exciting way of doing this.

757
00:42:24,000 --> 00:42:26,000
There's an even better way, in my opinion.

758
00:42:26,000 --> 00:42:28,000
A cooler way.

759
00:42:28,000 --> 00:42:31,000
Not true is false and not false is true.

760
00:42:31,000 --> 00:42:35,000
But we said true and false, we're encoding those as the kestrel and the kite.

761
00:42:35,000 --> 00:42:40,000
But if the kestrel and the kite, there's no named functions in lambda calculus.

762
00:42:40,000 --> 00:42:45,000
This is just us writing down a shorthand so that we don't have to remember and read out all the lambdas.

763
00:42:45,000 --> 00:42:50,000
But if we did replace them with their equivalent lambda expressions, that's what we're really looking at.

764
00:42:50,000 --> 00:42:58,000
Now, we're saying the Not function will take at the top there a lambda that takes two arguments and gives you back the first,

765
00:42:58,000 --> 00:43:03,000
and it gives you back a lambda that takes two arguments and gives you back the second.

766
00:43:03,000 --> 00:43:04,000
OK?

767
00:43:04,000 --> 00:43:08,000
And at the bottom, we're saying it takes, you know, two arguments and gives you back the second,

768
00:43:08,000 --> 00:43:14,000
and the Not function will give you back a lambda that takes two arguments and gives you back the first.

769
00:43:14,000 --> 00:43:14,880
Interesting.

770
00:43:17,240 --> 00:43:21,120
So does anyone see, instead of not,

771
00:43:21,120 --> 00:43:22,800
is there a function that we've already

772
00:43:22,800 --> 00:43:26,000
seen that will result in this?

773
00:43:26,000 --> 00:43:30,000
A function that accepts a binary function, a function that

774
00:43:30,000 --> 00:43:36,200
takes two arguments, and it moves the arguments around?

775
00:43:36,200 --> 00:43:38,080
It's the cardinal.

776
00:43:38,080 --> 00:43:41,200
Yeah, the only other one we've seen.

777
00:43:41,200 --> 00:43:43,560
The cardinal already does this behavior.

778
00:43:43,560 --> 00:43:47,680
The cardinal is boolean not.

779
00:43:47,680 --> 00:43:53,240
The flip of true is false, and the flip of false is true.

780
00:43:53,240 --> 00:43:55,000
This monitor is really going to bug me.

781
00:43:55,000 --> 00:43:55,560
There we go.

782
00:43:55,560 --> 00:43:56,440
Stay there.

783
00:43:56,440 --> 00:43:58,400
Don't move.

784
00:43:58,400 --> 00:43:58,960
Let's try it.

785
00:43:58,960 --> 00:44:03,200
Cardinal of true.

786
00:44:03,200 --> 00:44:06,440
Now, unfortunately, look what I'm about to get here.

787
00:44:06,440 --> 00:44:09,440
This isn't quite what I want, just this function.

788
00:44:09,440 --> 00:44:10,600
Well, that's weird.

789
00:44:10,600 --> 00:44:12,280
What if I use this function?

790
00:44:12,280 --> 00:44:15,720
I'll apply it to two things, one and two.

791
00:44:15,720 --> 00:44:17,840
I get back the second thing, which is what I want.

792
00:44:17,840 --> 00:44:21,320
The flip of true is false, so I should get the second thing.

793
00:44:21,320 --> 00:44:25,720
And the flip of false is true, so I should get back

794
00:44:25,720 --> 00:44:27,680
the first thing, which I do.

795
00:44:27,680 --> 00:44:31,520
The problem is, the problem is, and it's not really a problem,

796
00:44:31,520 --> 00:44:35,520
the problem is that the cardinal generates a new function,

797
00:44:35,520 --> 00:44:39,840
unlike my previous implementation of not, which

798
00:44:39,840 --> 00:44:42,960
selects between existing false and true functions,

799
00:44:42,960 --> 00:44:46,800
the cardinal generates a new function that behaves identically

800
00:44:46,800 --> 00:44:48,960
to the kestrel or kite.

801
00:44:48,960 --> 00:44:52,560
This kind of identity crisis is known

802
00:44:52,560 --> 00:44:56,680
as intentional equality versus extensional equality.

803
00:44:56,680 --> 00:44:58,640
Extensional equality, which is the kind of equality

804
00:44:58,640 --> 00:45:02,240
I'll use throughout this talk, means the functions are the same.

805
00:45:02,240 --> 00:45:05,600
If for every input, they generate the same output.

806
00:45:05,600 --> 00:45:07,560
So the cardinal of the kestrel is

807
00:45:07,600 --> 00:45:10,480
extensionally equal to the kite.

808
00:45:10,480 --> 00:45:11,920
They both behave identically.

809
00:45:11,920 --> 00:45:15,160
There's no way to tell them apart from the outside, quote unquote.

810
00:45:15,160 --> 00:45:18,160
Intentional equality is more like, well, where did it come from

811
00:45:18,160 --> 00:45:18,920
and what's inside it?

812
00:45:18,920 --> 00:45:20,760
What are its guts?

813
00:45:20,760 --> 00:45:27,880
I'm not going to focus on that during this talk, but it works.

814
00:45:27,880 --> 00:45:30,920
That's the important thing.

815
00:45:30,920 --> 00:45:36,880
Let's design and together, Boolean and, Boolean conjunction.

816
00:45:36,880 --> 00:45:37,800
We know it's a function, right?

817
00:45:37,800 --> 00:45:39,520
That's the theme of the talk.

818
00:45:39,520 --> 00:45:42,200
How many arguments does it take?

819
00:45:42,200 --> 00:45:43,920
What are these arguments?

820
00:45:43,920 --> 00:45:45,800
What kind of thing are they?

821
00:45:45,800 --> 00:45:47,800
They're Booleans, so they're the kestrel of the kite

822
00:45:47,800 --> 00:45:50,960
or kite and kestrel or kestrel or kestrel or kite and kite,

823
00:45:50,960 --> 00:45:53,240
just to finish it out.

824
00:45:53,240 --> 00:45:55,640
Well, to take in a parameter, you're

825
00:45:55,640 --> 00:45:57,480
probably going to use that parameter somewhere

826
00:45:57,480 --> 00:45:59,040
in the body of your function, right?

827
00:45:59,040 --> 00:46:01,680
So even if we're not quite sure where to go with this,

828
00:46:01,680 --> 00:46:04,600
let's try just using one of these Booleans.

829
00:46:04,600 --> 00:46:08,760
P is a Boolean, so what does it do?

830
00:46:08,760 --> 00:46:11,360
What do these Boolean functions do when I use them?

831
00:46:14,560 --> 00:46:17,400
Yeah, they select between two possibilities,

832
00:46:17,400 --> 00:46:19,000
such as the Spanish question mark.

833
00:46:21,600 --> 00:46:27,520
What if our first argument to and is false?

834
00:46:27,520 --> 00:46:30,560
Which of the two possibilities will P select?

835
00:46:30,560 --> 00:46:31,680
The second one.

836
00:46:31,680 --> 00:46:32,480
But wait a second.

837
00:46:32,480 --> 00:46:34,640
If one of the arguments to and is false,

838
00:46:34,640 --> 00:46:36,960
what should that result of this entire function be?

839
00:46:39,800 --> 00:46:43,160
Yeah, so I'll just put false there.

840
00:46:43,160 --> 00:46:46,560
If P is false, short circuit, don't bother looking at Q.

841
00:46:46,560 --> 00:46:49,160
There's no point where you can know we just select the second

842
00:46:49,160 --> 00:46:51,520
thing, and it's already going to be false.

843
00:46:51,520 --> 00:46:57,520
So we don't even bother checking Q. Well, what if P is true?

844
00:46:57,520 --> 00:47:00,400
It's going to select the first thing, right?

845
00:47:00,400 --> 00:47:01,640
But what is that first thing?

846
00:47:01,640 --> 00:47:03,320
What should it be?

847
00:47:03,320 --> 00:47:04,760
Based on Q?

848
00:47:04,760 --> 00:47:07,440
Yeah, it's got to be Q.

849
00:47:07,440 --> 00:47:11,880
Because if P is true, the and is true only when Q is true,

850
00:47:11,880 --> 00:47:14,040
and the and is false if Q is false.

851
00:47:14,040 --> 00:47:16,960
So once P is true, we have to go look at Q and use Q as our

852
00:47:16,960 --> 00:47:19,520
result.

853
00:47:19,520 --> 00:47:21,960
There's one more small simplification we can actually

854
00:47:21,960 --> 00:47:23,520
make to this that's kind of nice.

855
00:47:23,520 --> 00:47:27,840
I like it in any rate, which is we said that, by the way, P is

856
00:47:27,840 --> 00:47:30,320
a Boolean, so it selects between two possibilities.

857
00:47:30,360 --> 00:47:33,840
If P is false, it should select false.

858
00:47:33,840 --> 00:47:36,480
But I've hard-coded in a false.

859
00:47:36,480 --> 00:47:39,120
There was a way I could do this even more directly or

860
00:47:39,120 --> 00:47:41,640
indirectly, it depends on your perspective.

861
00:47:41,640 --> 00:47:44,600
If P is false and it should select false, P can just

862
00:47:44,600 --> 00:47:47,080
select itself.

863
00:47:47,080 --> 00:47:50,680
If P is false, then return P, which is false.

864
00:47:50,680 --> 00:47:52,760
So I end up with this thing, which is very much a

865
00:47:52,760 --> 00:47:56,560
combinator, PQ, PQP.

866
00:47:56,560 --> 00:47:58,000
That is my and function.

867
00:48:00,400 --> 00:48:04,360
I forget where we're at in our demonstrations of JavaScript.

868
00:48:04,360 --> 00:48:05,840
Do we have not?

869
00:48:05,840 --> 00:48:07,160
We do have not.

870
00:48:07,160 --> 00:48:07,920
What about and?

871
00:48:07,920 --> 00:48:08,440
No, we don't.

872
00:48:08,440 --> 00:48:09,800
OK, let's do that.

873
00:48:09,800 --> 00:48:16,240
And takes a Boolean and another Boolean, and it applies P

874
00:48:16,240 --> 00:48:19,760
to Q to P. PQ, PQP.

875
00:48:19,760 --> 00:48:21,120
That makes sense.

876
00:48:21,120 --> 00:48:26,400
So and of false and true is false.

877
00:48:26,400 --> 00:48:29,120
And of true and true is true.

878
00:48:29,320 --> 00:48:30,960
And false is false.

879
00:48:30,960 --> 00:48:34,040
And false and false is false.

880
00:48:34,040 --> 00:48:36,560
All the things we love and expect from the and function.

881
00:48:39,280 --> 00:48:40,280
That's neat.

882
00:48:40,280 --> 00:48:41,520
Let's do or.

883
00:48:41,520 --> 00:48:44,120
What is or?

884
00:48:44,120 --> 00:48:47,720
Hey, someone's got the theme down.

885
00:48:47,720 --> 00:48:48,520
I cheated ahead.

886
00:48:48,520 --> 00:48:51,000
I jumped ahead and gave you two of the arguments.

887
00:48:51,000 --> 00:48:51,720
Oh, no.

888
00:48:51,720 --> 00:48:52,600
What are we going to do?

889
00:48:52,600 --> 00:48:54,720
P is a Boolean, it selects between two things.

890
00:48:54,720 --> 00:48:56,560
All right, here's where it differs from and.

891
00:48:56,560 --> 00:48:58,160
What if P is true?

892
00:48:58,160 --> 00:49:00,120
Oops, I jumped ahead too much.

893
00:49:00,120 --> 00:49:01,120
P is true.

894
00:49:01,120 --> 00:49:03,520
It selects the first thing, which has got to be true.

895
00:49:03,520 --> 00:49:05,760
If P is true, we don't have to bother looking at Q, because

896
00:49:05,760 --> 00:49:09,640
in or, if one of them is true, then we just result in true.

897
00:49:09,640 --> 00:49:14,560
If P is false, what's the second argument got to be?

898
00:49:14,560 --> 00:49:18,280
Q. It's just the opposite of the thing before.

899
00:49:18,280 --> 00:49:22,840
So we can also simplify our kind of glossed over that, but

900
00:49:22,840 --> 00:49:24,280
it doesn't have to be a hard-coded true.

901
00:49:24,280 --> 00:49:26,360
It can just be P, because we reuse it.

902
00:49:26,440 --> 00:49:30,320
If P is true, just return P.

903
00:49:30,320 --> 00:49:34,040
That fact is actually really fun, because there's another

904
00:49:34,040 --> 00:49:37,400
little thing we can do here that's a trick.

905
00:49:37,400 --> 00:49:42,640
Somebody tell me, if I apply this PQ double PQ function to

906
00:49:42,640 --> 00:49:46,040
X and Y as arguments, what is the resulting

907
00:49:46,040 --> 00:49:47,000
better reduction?

908
00:49:47,000 --> 00:49:50,320
In other words, what is the evaluation of this function?

909
00:49:50,320 --> 00:49:53,920
What do I get as a result?

910
00:49:53,920 --> 00:49:58,040
Remember, X replaces every P in the body, and Y replaces every

911
00:49:58,040 --> 00:49:58,920
Q in the body.

912
00:50:01,440 --> 00:50:03,840
Yep, X, X, Y.

913
00:50:03,840 --> 00:50:06,440
But there's another function we've already seen that does

914
00:50:06,440 --> 00:50:09,120
this.

915
00:50:09,120 --> 00:50:10,160
I'll give you a hint.

916
00:50:10,160 --> 00:50:12,200
What if we ignore the Ys for a second?

917
00:50:15,360 --> 00:50:16,840
Yeah, it's the mockingverd.

918
00:50:16,840 --> 00:50:19,040
It's the self-applicationverd.

919
00:50:19,040 --> 00:50:21,160
The self-application of X is double X.

920
00:50:21,160 --> 00:50:23,600
It's the self-application of X.

921
00:50:23,600 --> 00:50:25,920
But if the thing on the left is equal to the thing on the

922
00:50:25,920 --> 00:50:29,160
right, they're both functions I could apply them to some Y.

923
00:50:29,160 --> 00:50:31,440
And now we see, wait a second, the thing on the top and the

924
00:50:31,440 --> 00:50:32,880
thing on the bottom are actually the same.

925
00:50:32,880 --> 00:50:36,920
The mockingverd works just like this other function.

926
00:50:36,920 --> 00:50:39,000
It looks almost exactly like that, except the other

927
00:50:39,000 --> 00:50:42,120
function is this additional Q on the end, which is useless.

928
00:50:42,120 --> 00:50:44,200
It takes a Q and applies a Q.

929
00:50:44,200 --> 00:50:47,720
This is known as the mockingverd once removed.

930
00:50:47,720 --> 00:50:50,200
So that's what the star means.

931
00:50:50,200 --> 00:50:52,320
It's been given an extra argument.

932
00:50:52,320 --> 00:50:55,160
The mockingverd once removed is extensionally equal to the

933
00:50:55,160 --> 00:50:55,720
mockingverd.

934
00:50:55,720 --> 00:50:58,480
It behaves identically to it.

935
00:50:58,480 --> 00:51:00,560
So have we defined or?

936
00:51:00,560 --> 00:51:01,120
No, we haven't.

937
00:51:01,120 --> 00:51:02,440
Let's do that really quickly.

938
00:51:02,440 --> 00:51:04,680
Or it takes a P and a Q.

939
00:51:04,680 --> 00:51:10,320
And it does P of P and Q.

940
00:51:10,320 --> 00:51:15,840
We can demonstrate that or TF is true, or F is false, or

941
00:51:15,840 --> 00:51:19,560
FT is true, and of course, or TT is true.

942
00:51:19,560 --> 00:51:21,360
But we can also use the mockingverd for that, because

943
00:51:21,360 --> 00:51:23,960
we just proved that the mockingverd outflurrates the

944
00:51:23,960 --> 00:51:25,400
same way here.

945
00:51:25,400 --> 00:51:29,920
So mockingverd of true and false is true.

946
00:51:29,920 --> 00:51:32,200
False and false is false.

947
00:51:32,200 --> 00:51:35,440
False and true is an or statement as well.

948
00:51:35,440 --> 00:51:37,680
And that's also an or statement.

949
00:51:37,680 --> 00:51:39,120
Wow.

950
00:51:39,120 --> 00:51:42,960
Mockingverd, you're multi-talented.

951
00:51:42,960 --> 00:51:45,560
Anybody have an idea what this might be?

952
00:51:52,160 --> 00:51:55,040
Well, it's definitely a function that takes two

953
00:51:55,040 --> 00:51:57,120
arguments.

954
00:51:57,120 --> 00:51:59,360
And I'm going to tell you P and Q are Booleans, just to make

955
00:51:59,360 --> 00:52:01,040
it slightly easier.

956
00:52:01,040 --> 00:52:03,640
But if P and Q are Booleans, what does P do?

957
00:52:07,400 --> 00:52:10,360
It selects between two possibilities.

958
00:52:10,360 --> 00:52:13,160
And if Q is a Boolean, what does it do?

959
00:52:13,160 --> 00:52:15,800
It selects between two possibilities.

960
00:52:15,800 --> 00:52:18,160
Does this make it easier to see what this function does?

961
00:52:18,600 --> 00:52:22,240
Sorry?

962
00:52:22,240 --> 00:52:24,760
You were sure.

963
00:52:24,760 --> 00:52:28,520
Well, if P and Q are the same Boolean, they select true.

964
00:52:28,520 --> 00:52:31,640
If they're the same that way, they also select true.

965
00:52:31,640 --> 00:52:35,440
But if they're different, they select false.

966
00:52:35,440 --> 00:52:38,120
Which function is this?

967
00:52:38,120 --> 00:52:40,400
Sorry?

968
00:52:40,400 --> 00:52:42,040
Oh, is Zor something like that?

969
00:52:42,040 --> 00:52:43,560
Not quite.

970
00:52:43,560 --> 00:52:44,480
Maybe.

971
00:52:44,480 --> 00:52:45,720
I'd have to think about it.

972
00:52:45,720 --> 00:52:46,520
It might be Zor.

973
00:52:46,520 --> 00:52:48,080
Yeah, I'd have to think about it.

974
00:52:49,000 --> 00:52:51,240
Yeah.

975
00:52:51,240 --> 00:52:52,040
That's true.

976
00:52:52,040 --> 00:52:53,240
That's cool.

977
00:52:53,240 --> 00:52:55,480
Yeah, nice work.

978
00:52:55,480 --> 00:52:57,080
I didn't think about that.

979
00:52:57,080 --> 00:52:59,480
There's a simpler thing that we use this with.

980
00:52:59,480 --> 00:53:01,320
If P and Q are the same, we get true.

981
00:53:01,320 --> 00:53:02,520
If they're different, we get false.

982
00:53:02,520 --> 00:53:05,200
That's called equality.

983
00:53:05,200 --> 00:53:11,280
This test, if P and Q are the same Boolean, well, there's a

984
00:53:11,280 --> 00:53:13,480
nice little simplification we can make here.

985
00:53:13,480 --> 00:53:15,160
Q is a Boolean true or false.

986
00:53:15,160 --> 00:53:16,240
If it's true, it selects true.

987
00:53:16,280 --> 00:53:18,280
If it's false, it selects false.

988
00:53:18,280 --> 00:53:19,200
That's redundant.

989
00:53:19,200 --> 00:53:20,640
We could just use Q as it is.

990
00:53:20,640 --> 00:53:22,840
It's already true or false.

991
00:53:22,840 --> 00:53:25,720
And at the bottom, if Q is true, it selects false.

992
00:53:25,720 --> 00:53:28,000
And if it's false, it selects true.

993
00:53:28,000 --> 00:53:29,960
We already have a function that does that.

994
00:53:29,960 --> 00:53:32,000
It's called the not function.

995
00:53:32,000 --> 00:53:36,840
So we can simplify this to P, Q, not Q. And that is our

996
00:53:36,840 --> 00:53:38,840
Boolean equality function.

997
00:53:38,840 --> 00:53:42,960
I'll do that as long as it sets P to Q to P, Q, not Q.

998
00:53:43,000 --> 00:53:47,480
So Boolean equality takes a P and a Q.

999
00:53:47,480 --> 00:53:53,520
And it does P of Q and not Q.

1000
00:53:53,520 --> 00:53:54,200
Try it out.

1001
00:53:54,200 --> 00:53:58,840
Boolean equality of true and true is, of course, true.

1002
00:53:58,840 --> 00:54:00,480
True and false, nope.

1003
00:54:00,480 --> 00:54:02,240
False and false, yes.

1004
00:54:02,240 --> 00:54:04,360
False and true, nope.

1005
00:54:04,360 --> 00:54:06,640
Nice.

1006
00:54:06,640 --> 00:54:08,320
It's always fun to see it actually work.

1007
00:54:08,320 --> 00:54:10,520
Like, you kind of believe it, and then you see it, and

1008
00:54:10,520 --> 00:54:12,600
you're like, oh, I guess it really is true.

1009
00:54:15,600 --> 00:54:17,400
All right, we got church encodings from Booleons.

1010
00:54:21,560 --> 00:54:23,880
I'm not going to do this one out.

1011
00:54:23,880 --> 00:54:26,480
But if you are familiar with Boolean logic, you have heard

1012
00:54:26,480 --> 00:54:28,000
of De Morgan's laws.

1013
00:54:28,000 --> 00:54:30,600
De Morgan's laws are a pair of laws.

1014
00:54:30,600 --> 00:54:31,760
This is only one of them.

1015
00:54:31,760 --> 00:54:38,920
But it says that not P and Q is equal to not P or not Q.

1016
00:54:39,000 --> 00:54:42,320
And we've just expressed that using nothing but functions.

1017
00:54:42,320 --> 00:54:45,200
No Booleans, no ands, no ors.

1018
00:54:45,200 --> 00:54:46,040
I could prove that.

1019
00:54:46,040 --> 00:54:48,520
We'll just take our shorthand and replace it with the

1020
00:54:48,520 --> 00:54:50,320
actual lambda calculus.

1021
00:54:50,320 --> 00:54:56,280
So there's our Boolean equality of not and PQ or not P or

1022
00:54:56,280 --> 00:54:59,000
not Q.

1023
00:54:59,000 --> 00:55:02,480
All right, it's pretty cool.

1024
00:55:02,480 --> 00:55:05,960
Now, I rehearsed this talk last night.

1025
00:55:05,960 --> 00:55:06,880
My fiance made me.

1026
00:55:06,880 --> 00:55:10,040
She said, this talk is way longer than an hour.

1027
00:55:10,040 --> 00:55:11,800
I was like, ah, we'll see how long it is.

1028
00:55:11,800 --> 00:55:13,800
She said, no, no, no, you're going to rehearse.

1029
00:55:13,800 --> 00:55:18,520
And I rehearsed, and it's way longer than an hour.

1030
00:55:18,520 --> 00:55:21,760
But this is a really good stopping point.

1031
00:55:21,760 --> 00:55:23,640
So what I'm going to do is I'm going to give you the

1032
00:55:23,640 --> 00:55:27,320
conclusion of this talk, which works perfectly after this

1033
00:55:27,320 --> 00:55:27,720
slide.

1034
00:55:27,720 --> 00:55:28,440
It fits.

1035
00:55:28,440 --> 00:55:29,680
It makes sense.

1036
00:55:29,680 --> 00:55:33,880
And anyone who would like to is welcome to stay another

1037
00:55:33,880 --> 00:55:35,080
30-ish minutes.

1038
00:55:35,080 --> 00:55:37,200
I'm going to go into another room, because Mark has to

1039
00:55:37,200 --> 00:55:40,960
come in here and get this room ready for demo day.

1040
00:55:40,960 --> 00:55:45,440
And I'll show them numbers in the lambda calculus.

1041
00:55:45,440 --> 00:55:47,800
But before we do that, I'm going to conclude this talk.

1042
00:55:47,800 --> 00:55:51,280
So let me skip way down to the bottom of my deck here.

1043
00:55:51,280 --> 00:55:53,200
If I can find my mouse, there it is.

1044
00:55:57,920 --> 00:56:00,680
Nope, further.

1045
00:56:00,680 --> 00:56:04,600
Nope, more than that.

1046
00:56:04,640 --> 00:56:07,000
Keep going.

1047
00:56:07,000 --> 00:56:10,440
Try to remember where this slide starts.

1048
00:56:10,440 --> 00:56:11,800
Almost there.

1049
00:56:20,520 --> 00:56:22,360
So a small preview.

1050
00:56:28,400 --> 00:56:31,400
This isn't even the only table in this talk.

1051
00:56:31,400 --> 00:56:33,560
These are just the combinators, let alone the

1052
00:56:33,560 --> 00:56:36,760
Boolean equality, the arithmetic, the numerals, and

1053
00:56:36,760 --> 00:56:41,000
the arithmetic operations that yield Booleans.

1054
00:56:41,000 --> 00:56:43,760
So lots of stuff that I am cutting out in the

1055
00:56:43,760 --> 00:56:45,000
interest of time.

1056
00:56:45,000 --> 00:56:48,680
But yeah, I know.

1057
00:56:48,680 --> 00:56:51,040
Here's where I want to conclude, and I want to give you a

1058
00:56:51,040 --> 00:56:52,880
couple little small addendums.

1059
00:56:52,880 --> 00:56:56,320
The first is I emphasized early on that from primitive

1060
00:56:56,320 --> 00:56:59,400
combinators come other combinators.

1061
00:56:59,400 --> 00:57:02,760
And this is a really cool sort of atom to molecule sort of

1062
00:57:02,760 --> 00:57:03,840
situation.

1063
00:57:03,840 --> 00:57:07,280
And it begs the question, how many combinators do we need

1064
00:57:07,280 --> 00:57:11,560
and which ones to generate all the other ones?

1065
00:57:11,560 --> 00:57:12,880
Is it even possible to do that?

1066
00:57:12,880 --> 00:57:15,840
Do we need an infinite number of them?

1067
00:57:15,840 --> 00:57:19,720
20, 10, 5?

1068
00:57:19,720 --> 00:57:21,320
Just two.

1069
00:57:21,320 --> 00:57:22,160
Not even identity.

1070
00:57:22,160 --> 00:57:23,400
Identity isn't on the board.

1071
00:57:23,400 --> 00:57:24,520
These are the only two you need.

1072
00:57:24,520 --> 00:57:26,520
You can make identity out of this, the

1073
00:57:26,520 --> 00:57:28,520
Starling and the Kestrel.

1074
00:57:28,520 --> 00:57:30,080
The Starling is a weird one.

1075
00:57:30,200 --> 00:57:32,880
I actually don't really like the SK

1076
00:57:32,880 --> 00:57:37,000
Combinator Calculus, which is what it is called.

1077
00:57:37,000 --> 00:57:42,520
I really like the BCKIM Combinator Calculus.

1078
00:57:42,520 --> 00:57:44,880
If I just added m to this, this would actually suffice

1079
00:57:44,880 --> 00:57:45,680
five of them.

1080
00:57:45,680 --> 00:57:47,480
And that was the one that Curry used.

1081
00:57:47,480 --> 00:57:49,760
I find this far easier to use than the SK

1082
00:57:49,760 --> 00:57:52,040
Combinator Calculus.

1083
00:57:52,040 --> 00:57:53,960
For instance, the identity in the SK

1084
00:57:53,960 --> 00:57:56,160
Combinator Calculus is S of KK.

1085
00:57:56,160 --> 00:57:58,320
It's also SKS.

1086
00:57:58,320 --> 00:58:01,000
Those are extensionally equal.

1087
00:58:01,000 --> 00:58:03,480
You didn't get a chance to see the Vario, but the Vario

1088
00:58:03,480 --> 00:58:05,320
is the world's smallest data structure.

1089
00:58:05,320 --> 00:58:05,760
That's right.

1090
00:58:05,760 --> 00:58:08,200
I'm putting data structures in lambda calculus.

1091
00:58:08,200 --> 00:58:11,120
Here it is in the SK Combinator Calculus.

1092
00:58:11,120 --> 00:58:15,960
And this is not even close to how complicated it can get.

1093
00:58:15,960 --> 00:58:17,520
So really, why?

1094
00:58:17,520 --> 00:58:18,640
What is what?

1095
00:58:18,640 --> 00:58:20,600
What?

1096
00:58:20,600 --> 00:58:21,520
All right.

1097
00:58:21,520 --> 00:58:24,880
To begin with, in my opinion, I was searching for the

1098
00:58:24,880 --> 00:58:26,360
answer to this why question.

1099
00:58:26,360 --> 00:58:30,520
I was trying to think, am I trying to evangelize like

1100
00:58:30,520 --> 00:58:33,120
learning abstract math or this and that?

1101
00:58:33,120 --> 00:58:34,000
Then I realized, you know what?

1102
00:58:34,000 --> 00:58:37,560
The honest answer for myself is, it's just fun.

1103
00:58:37,560 --> 00:58:38,720
I enjoy this.

1104
00:58:38,720 --> 00:58:41,800
I hope that you might enjoy it too.

1105
00:58:41,800 --> 00:58:45,760
That's the entire basis of the book to Maka Making Bird.

1106
00:58:45,760 --> 00:58:48,880
It's a book of logic puzzles and games.

1107
00:58:48,880 --> 00:58:54,160
It was written to act as a series of fun challenges.

1108
00:58:54,200 --> 00:58:56,760
It's a great mental workout.

1109
00:58:56,760 --> 00:58:59,800
Thinking along these patterns, let's you think about, oh

1110
00:58:59,800 --> 00:59:01,720
my gosh, I have to think of where nouns are verbs and

1111
00:59:01,720 --> 00:59:03,040
verbs are nouns.

1112
00:59:03,040 --> 00:59:05,920
And I've got to be able to think about partially applied

1113
00:59:05,920 --> 00:59:08,760
functions, curried functions, higher order functions.

1114
00:59:08,760 --> 00:59:10,760
There's a lot of spaghetti.

1115
00:59:10,760 --> 00:59:15,360
So it's really laying down the neurological groundwork for

1116
00:59:15,360 --> 00:59:18,440
understanding functional programming in general.

1117
00:59:18,440 --> 00:59:21,440
The lambda calculus, as I said before, being the basis of

1118
00:59:21,440 --> 00:59:26,360
languages like Miranda and Lisp and Haskell, means that

1119
00:59:26,360 --> 00:59:29,360
those languages, if you know this kind of

1120
00:59:29,360 --> 00:59:34,160
combinatorial logic, it sets you up for success in those

1121
00:59:34,160 --> 00:59:35,440
kinds of languages.

1122
00:59:35,440 --> 00:59:38,640
Because even though you're not required to think entirely

1123
00:59:38,640 --> 00:59:41,800
that way, there's a large portion of those languages

1124
00:59:41,800 --> 00:59:46,240
that assumes you are comfortable with that.

1125
00:59:46,240 --> 00:59:49,320
And from that, we get all sorts of real world practical

1126
00:59:49,320 --> 00:59:50,240
benefits.

1127
00:59:50,320 --> 00:59:52,120
So I started writing them down.

1128
00:59:52,120 --> 00:59:54,320
A lot of them are intersections with just functional

1129
00:59:54,320 --> 00:59:55,200
programming in general.

1130
00:59:55,200 --> 00:59:58,480
But many of these come directly from the lambda calculus.

1131
00:59:58,480 --> 01:00:02,880
Closures, higher order functions, laziness,

1132
01:00:02,880 --> 01:00:06,120
infinite data structures, garbage collection, function

1133
01:00:06,120 --> 01:00:10,360
graph reduction, type theory, provable programming code,

1134
01:00:10,360 --> 01:00:13,440
parallel processing for free, parametric polymorphism.

1135
01:00:13,440 --> 01:00:15,600
I mean, it just keeps going on and on and on.

1136
01:00:15,640 --> 01:00:19,800
And this all derives straight out of purely mathematical

1137
01:00:19,800 --> 01:00:24,000
fields that existed even before computers did.

1138
01:00:24,000 --> 01:00:26,000
But at the end of the day, I really just think that there's

1139
01:00:26,000 --> 01:00:28,440
a lot of elegant mathematical beauty to it.

1140
01:00:28,440 --> 01:00:30,520
And it's kind of art for art's sake.

1141
01:00:30,520 --> 01:00:33,680
I hope that this has inspired you to become interested in

1142
01:00:33,680 --> 01:00:38,080
this topic and maybe to go read some more about it.

1143
01:00:38,080 --> 01:00:41,200
Find a little bit of slides.

1144
01:00:41,200 --> 01:00:42,520
Here are all the combinators.

1145
01:00:42,520 --> 01:00:43,960
Here are all the booleans.

1146
01:00:44,000 --> 01:00:47,400
The numerals, church arithmetic, boolean ops in the

1147
01:00:47,400 --> 01:00:49,960
church arithmetic, data structures.

1148
01:00:49,960 --> 01:00:52,280
All of this is in the deck.

1149
01:00:52,280 --> 01:00:54,800
It's not an hour-long talk, is it?

1150
01:00:54,800 --> 01:00:57,480
And you've probably all been wondering, wait a second.

1151
01:00:57,480 --> 01:01:00,120
Where's the most famous combinator of all, the Y

1152
01:01:00,120 --> 01:01:01,120
combinator?

1153
01:01:01,120 --> 01:01:03,120
Well, there's the Y combinator.

1154
01:01:03,120 --> 01:01:04,400
What does it do?

1155
01:01:04,400 --> 01:01:06,800
I'll just leave you with this as a brain teaser.

1156
01:01:06,800 --> 01:01:10,440
The lambda calculus has neither loops nor recursion.

1157
01:01:10,440 --> 01:01:12,600
So how does it do either of those things?

1158
01:01:12,600 --> 01:01:15,120
Because it can calculate anything calculable.

1159
01:01:15,120 --> 01:01:16,040
This is the answer.

1160
01:01:16,040 --> 01:01:20,440
The Y combinator allows for recursion in a language that

1161
01:01:20,440 --> 01:01:23,120
doesn't have recursion built into it.

1162
01:01:23,120 --> 01:01:26,280
Unfortunately, I cannot demonstrate this in JavaScript

1163
01:01:26,280 --> 01:01:29,480
because it goes on forever.

1164
01:01:29,480 --> 01:01:30,920
This is a fixed point combinator.

1165
01:01:30,920 --> 01:01:34,080
It infinitely just keeps evaluating itself, which works

1166
01:01:34,080 --> 01:01:36,680
in a lazy language like Haskell or the lambda calculus

1167
01:01:36,680 --> 01:01:37,680
itself.

1168
01:01:37,680 --> 01:01:41,360
So unfortunately, because JavaScript is like the thing

1169
01:01:41,360 --> 01:01:43,720
on the right and not like the thing on the left,

1170
01:01:43,720 --> 01:01:46,080
we need a slight variation on the Y combinator

1171
01:01:46,080 --> 01:01:49,240
called the Z combinator, which is the exact same as the Y

1172
01:01:49,240 --> 01:01:51,000
combinator except the middle of it

1173
01:01:51,000 --> 01:01:55,440
has a funk, which defers calculation until required.

1174
01:01:55,440 --> 01:01:58,080
So the Z combinator I could demo if I wanted to,

1175
01:01:58,080 --> 01:02:02,200
but I haven't set that up in my code so I won't today.

1176
01:02:02,200 --> 01:02:03,840
All right, that is the talk.

1177
01:02:03,840 --> 01:02:04,640
Thank you very much.

1178
01:02:04,640 --> 01:02:05,440
Any questions?

