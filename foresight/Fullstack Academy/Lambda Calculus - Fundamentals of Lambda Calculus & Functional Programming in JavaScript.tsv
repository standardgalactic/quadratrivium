start	end	text
0	5000	Okay, welcome everybody.
5000	7000	Very glad you could make it for this talk.
7000	9000	I've been working on this for a while.
9000	10000	I'm really excited about it.
10000	14000	If you don't know me, I am Gabriel,
14000	17000	and I'm an instructor here at Fullstack Academy of Code.
17000	20000	My social media presence is G. Lebec everywhere,
20000	23000	except, unfortunately, and somewhat ironically,
23000	25000	given the subject of this talk at Twitter,
25000	27000	where I was forced to use an underscore.
27000	30000	There's going to be resources available on my GitHub
30000	32000	at slash G. Lebec slash Lambda Talk,
32000	35000	so you can go find additional stuff after this.
35000	38000	All right, so let's just dive in and get started.
38000	41000	I want to start by pointing out a minute node ripple here.
41000	44000	I can do kind of typical JavaScript-y stuff,
44000	47000	but we're going to avoid JavaScript in the sort of classical sense
47000	50000	as much as possible, and start off with this function
50000	53000	called I or identity.
53000	55000	Now, just looking at the function,
55000	57000	if I invoke it with some value,
57000	59000	what am I going to get back here?
59000	64000	Yeah, identity of one is one, identity of two is two.
64000	68000	What about the identity of identity?
68000	71000	Yeah, it's the identity function.
71000	74000	So, very simply, the identity combinator
74000	79000	is a function that takes in an input A
79000	81000	and it returns an output A.
81000	84000	Basically, it just reflects back a value.
84000	86000	So, the identity of any X is X,
86000	88000	and we saw that in this particular paradigm,
88000	91000	we're allowed to use functions as arguments.
91000	93000	Verbs are nouns and nouns are verbs,
93000	97000	so the identity of identity is itself.
97000	100000	In Haskell, this is actually built into the Prelude module,
100000	103000	which is the base standard module for the language,
103000	105000	as the ID function.
105000	107000	As you can see, it takes an argument five
107000	109000	and gives you back five.
109000	112000	So, looking at this, I just flashed a bunch of stuff on the screen.
112000	114000	You might be thinking, what's this lambda stuff
114000	116000	that's sitting up here?
116000	118000	So, lambda is a signifier.
118000	120000	It's a notation that we're going to use
120000	123000	to indicate that we're starting the definition of a function.
123000	127000	So, we can read this as we're starting to define a function,
127000	130000	which takes a single input or parameter,
130000	133000	and it returns some expression, some body.
133000	136000	And this whole thing is called a lambda abstraction
136000	137000	in the lambda calculus,
137000	141000	but it basically just means it's a unary anonymous function.
141000	144000	Unary meaning it takes a single input.
144000	149000	The lambda calculus is a really tiny symbol manipulation framework.
149000	153000	A calculus is just a way of moving around symbols on a page.
153000	157000	The subject that you may have learned in school called calculus
157000	160000	is a specific calculus for things like differentials
160000	164000	and integrals and stuff like that, derivatives.
164000	167000	And so, this calculus is about something else.
167000	172000	This calculus is about evaluating and defining functions.
172000	175000	So, in the lambda calculus, we have variables,
175000	177000	which are pretty boring.
177000	178000	Please come in.
178000	180000	We've got expressions,
180000	185000	which are the application of some function to its argument.
185000	189000	We've got an expression that is itself a function definition,
189000	193000	an abstraction instead of a concrete thing like 1 plus 5,
193000	195000	1 plus 6, 1 plus 7.
195000	198000	We have something like 1 plus A.
198000	200000	And A can be anything.
200000	202000	It's become abstracted.
202000	205000	And we have groupings to disambiguate the order
205000	208000	in which we should be doing certain operations.
208000	210000	This is the entire lambda calculus.
210000	211000	All right.
211000	212000	So, talk's over.
212000	213000	I can go home now.
213000	215000	No, we're going to see some examples of this.
215000	219000	So, let's start with just a couple of cross comparisons here.
219000	223000	Variables in the lambda calculus, as I mentioned, are extremely boring.
223000	227000	One thing to note here is that these variables are immutable.
227000	229000	They cannot be changed after the fact.
229000	233000	There's no concept of assignment, per se, in the lambda calculus.
233000	235000	There is binding, which we'll see shortly.
235000	238000	But if this variable is bound to a value,
238000	242000	that's its value for now and forevermore.
242000	245000	So, no, let all const.
245000	247000	Applications are slightly more interesting.
247000	249000	This is applying a function to its arguments.
249000	252000	And in the lambda calculus, that's just juxtaposition.
252000	254000	It's just a space.
254000	256000	There's no parens for invocation,
256000	259000	which at first, if you're used to something like JavaScript,
259000	261000	it's a little disconcerting.
261000	265000	But in reality, it ends up removing a lot of noise from our expressions.
265000	266000	And as this talk goes on,
266000	270000	you're probably going to see it's becoming easier and easier to read the lambda calculus
270000	273000	rather than trying to parse the JavaScript.
273000	276000	So, here we apply a function f to its argument a.
276000	278000	We can apply multiple arguments,
278000	281000	but in the lambda calculus, all functions are unary.
281000	283000	So, this is really a curried function.
283000	285000	This is an f that takes an a,
285000	287000	and that returns a new function,
287000	290000	which is not written down, which takes a b.
290000	292000	Let's try this out.
292000	296000	Let's do kind of a classic example of a curried addition function.
296000	298000	We'll say that add takes an a,
298000	303000	and it takes a b, and it returns a plus b.
303000	308000	So, if we call add with just some single argument,
308000	310000	we get back some function.
310000	313000	If we call that function with an additional argument,
313000	316000	now we get the final result.
316000	319000	Pretty familiar stuff, I think, for this crowd.
319000	323000	So, f a b, you can read that as first it takes an a,
323000	325000	and then a b, and if there are more arguments,
325000	327000	they get fed in one by one,
327000	331000	going from the leftmost argument onwards,
331000	333000	marching kind of toward the right.
333000	336000	We can make this clear with parentheses.
336000	339000	We can say, first apply f to a,
339000	341000	and then apply the result of that to b,
341000	343000	but this isn't necessary because we say
343000	345000	that function application is left associative.
345000	347000	So, these are really useless parentheses,
347000	351000	and we'll omit them in most of our examples.
351000	354000	Finally, we can use parentheses to force evaluations
354000	356000	to occur in a different order.
356000	358000	So, here this is actually a different expression.
358000	361000	This means something else in the lambda calculus.
361000	363000	It means we're going to first apply a to b,
363000	367000	and the result of that will be the argument to f.
367000	369000	Hi, hello.
369000	371000	Welcome.
371000	376000	So, just to summarize for everybody who's just arrived,
376000	378000	we're starting to define the syntax
378000	382000	of a very small language called the lambda calculus.
382000	385000	And this is just something that takes functions,
385000	387000	applications of functions to arguments,
387000	389000	and parentheses for grouping.
389000	391000	That's really it.
391000	394000	So, really high level review of just this last slide.
394000	397000	F a means invoke f with a,
397000	400000	and you'll get more as we go.
400000	403000	So, let's talk about function definition in the lambda calculus.
403000	405000	As I said before, we use a lambda to indicate
405000	407000	that we're defining a new function.
407000	409000	So, we got lambda calculus on the left,
409000	410000	JavaScript on the right.
410000	413000	This is a function that takes an a and returns whatever b is.
413000	415000	Sort of throws away a,
415000	418000	a b becomes irrelevant in this expression.
418000	421000	The function abstraction like this is greedy.
421000	425000	The body swallows up as much stuff to the right as it can,
425000	428000	and that's all included in the body of this lambda abstraction.
428000	431000	So, up into the point where it would stop making sense,
431000	436000	like if you're using parens to force things to be evaluated differently.
436000	439000	So, this indicates a function that takes an a,
439000	443000	and it invokes b with x as its argument.
443000	445000	We can disambiguate this with parentheses,
445000	448000	but as I said, since lambda abstractions
448000	450000	greedily swallow up everything to the right,
450000	452000	these are actually useless parentheses,
452000	457000	and we'll not really show them in most of the upcoming examples.
457000	459000	On the other hand, if we use parentheses
459000	462000	to force the thing on the left to be a function with a body
462000	465000	that's just the b variable,
465000	468000	now this is a different expression.
468000	471000	Now we're saying take a function that goes from a to b
471000	476000	and apply it to the argument x.
476000	479000	As we saw a second ago in a demonstration
479000	482000	in the lambda calculus we're allowed to nest functions.
482000	485000	So, this is a function that takes an a
485000	489000	and returns a new function that new function takes a b
489000	492000	and that function returns an a.
492000	496000	So, just to reprise our curried addition function from a second ago,
496000	499000	we have this function that takes an a,
499000	501000	returns a function that takes a b,
501000	503000	and that returns a plus b.
503000	508000	So, we have to feed out the arguments not like this all at once,
508000	512000	but rather each argument one at a time
512000	516000	in a successive invocations,
516000	521000	and we get the result we want, known as currying.
521000	524000	Again, we can clarify this using parentheses.
524000	527000	The lambda on the left returns the inner lambda,
527000	529000	and then we can use that.
529000	531000	But since these are useless parentheses,
531000	535000	we'll omit them in most of the examples.
535000	536000	How are we doing so far?
536000	540000	Questions about the bare syntax of the lambda calculus?
540000	543000	As you can see, it's very similar to JavaScript,
543000	546000	except you don't have parentheses around function invocation.
546000	548000	You just put things next to each other,
548000	550000	and that indicates apply a function on the left
550000	554000	to the argument on the right.
554000	556000	Cool.
556000	557000	All right.
557000	559000	So, I swear this is going to be the most complicated bit
559000	561000	of lambda calculus syntax we have to deal with.
561000	563000	It's called beta reduction.
563000	566000	It's got a scary name, but it really just means
566000	570000	tracing the logic, evaluating the function invocations,
570000	572000	seeing what we end up with.
572000	576000	So beta reduction is just the act of taking a function
576000	579000	and applying it to its argument.
579000	581000	So here we've got this function in red
581000	583000	applied to the argument underlined.
583000	585000	What we do is we take the argument,
585000	588000	and it comes in as the parameter of the function.
588000	591000	This is a function that takes an A and returns an A.
592000	595000	So this argument, the BCB function,
595000	599000	is going to replace in the body of the function every A.
599000	601000	We go look in the body, find all the As,
601000	604000	and we substitute in this other expression.
604000	609000	And that gives us this first simplification.
609000	611000	Well, we continue doing this.
611000	613000	We've got a new function, the BCB function,
613000	616000	being applied to another argument, the X argument.
616000	618000	So we're going to take the X argument
618000	622000	and substitute it in as the parameter to the function.
622000	624000	So we go look inside the function body,
624000	627000	find all the B's, and replace them all with X's.
627000	631000	And we get this new function as a result.
631000	633000	Once again, we've got a function
633000	635000	that we're going to apply to an argument.
635000	639000	We take the argument, we pass it into the function's parameter.
639000	641000	We go look in the body for all the C's.
641000	643000	There are no C's in this body.
643000	645000	We replace all the C's with that argument,
645000	648000	and that gives us this simplification.
648000	650000	At this point, we've got nothing left to do.
650000	652000	There are no more reducible expressions.
652000	654000	So we say this is in beta normal form,
654000	656000	which is just a hilarious way of saying
656000	661000	we've fully evaluated the function in a terminal way.
661000	664000	So it looks a little dense
664000	666000	compared to what you're used to with JavaScript,
666000	671000	but it's really nothing that we haven't done many times in JavaScript.
671000	674000	Taking a function, passing in arguments as the parameters,
674000	677000	and then in the body, everywhere that parameter exists,
677000	680000	it's been replaced by a value.
680000	682000	There's some caveats here.
682000	684000	I'm not going to cover in this presentation.
684000	686000	If you could do multiple reductions
686000	689000	in different places in the expression simultaneously,
689000	693000	there are caveats and strategies to which ones you should do first.
693000	697000	And there's also possible ways that two separate functions
697000	699000	that coincidentally share the same variable names,
699000	702000	you want to avoid conflating those two variables,
702000	703000	which mean different things.
703000	705000	So there are some gotchas,
705000	709000	but they're kind of outside the scope of this talk.
709000	712000	Let's see another combinator here, the mockingbird.
712000	714000	This is a fun function.
714000	716000	It takes a function as input,
716000	721000	and it invokes that function passing in itself.
721000	725000	This is the self-application combinator.
725000	726000	Whoa, what's happening here?
726000	727000	This is craziness.
727000	728000	Let's try it out.
728000	731000	The mockingbird is a function that takes a function,
731000	734000	calls the function on itself.
734000	737000	What might the mockingbird of identity be?
737000	743000	Somebody walked me through the logic here.
743000	746000	What's f in this function?
746000	748000	It's the identity.
748000	750000	What are we doing with it?
750000	755000	Identity of identity.
755000	757000	We already solved that before, right?
757000	758000	What is the answer?
758000	760000	It's the identity.
760000	762000	The self-application of identity is identity.
762000	765000	We saw that earlier.
765000	768000	This one's going to be a little bit more disconcerting.
768000	773000	What is the self-application of self-application?
773000	776000	Feel free to yell it out if you think you got it.
776000	785000	It may be hinted at by the fact that I'm putting this in a try-catch block.
785000	790000	Any takers?
790000	792000	Call stack size exceeded.
792000	794000	What just happened?
794000	799000	Well, mockingbird of identity is identity of identity, self-application.
799000	803000	We already know that that is identity, so that made sense.
803000	806000	That does reduce to a better normal form.
806000	811000	But the mockingbird of the mockingbird is the self-application of self-application.
811000	815000	So we take self-application and we apply it to itself.
815000	819000	But if we're going to evaluate that, that's the self-application of self-application.
819000	825000	So we take the self-application and uh-oh, it just goes on forever.
825000	827000	This is a problem.
827000	833000	The problem is we don't always know if some lambda term is going to have a beta normal form.
833000	836000	We don't know if this process ends or not.
836000	838000	Sometimes it doesn't end.
838000	842000	Sometimes it diverges, which means it goes on forever.
842000	847000	And in fact, there's no way to know in a general way if a given expression,
847000	852000	there's no single algorithm that can tell you whether or not one of these expressions will stop.
852000	855000	That's known as the halting problem and Alan Turing figured it out.
855000	861000	Now for an individual one, you can prove through ad hoc means that, yeah,
861000	863000	for instance, this one is going to go on forever.
863000	868000	So it's not that it's always unanswerable, just that there's no one set of steps that you can take
868000	874000	that will cause that, that you will know whether or not it halts.
874000	879000	This particular divergent term, by the way, is called the omega combinator.
879000	884000	Omega because it's like the end, alpha and the omega.
884000	888000	And sometimes the mockingbird as a result is called little omega.
888000	892000	One of the problems you'll find if you start going out and reading about all this stuff
892000	896000	is that a lot of different mathematicians and programmers and people have worked on it over time
896000	899000	and they've all given their own pet names to these things.
899000	905000	So there's a lot of synonyms and sometimes even intersection.
905000	910000	Okay, we're almost done with lambda calculus syntax, but I lied before and I said it was the end.
910000	913000	There's one more thing I want to show you about syntax here.
913000	917000	We can do, as I said before, these nested lambdas.
917000	922000	We could say there's a function that takes an A and that returns a function that takes a B,
922000	926000	which returns a function that takes a C, which finally returns a B.
926000	931000	But the way we're using these functions, we just kind of think of, well,
931000	935000	we're going to call it with both arguments at once in quotes,
935000	938000	really meaning we feed it the first argument then the second argument.
938000	942000	But we think of it as taking two arguments just in a curried way.
942000	947000	So in order to kind of make it easier to write this stuff down and parse it,
947000	951000	there's a little bit of a shorthand where we just condense all the nested lambdas
951000	953000	and say, here's a ternary function.
953000	956000	Here's a function that takes three inputs and returns something.
956000	958000	But don't get fooled.
958000	961000	These don't come in all simultaneously.
961000	965000	We feed them into the function one after the other.
965000	969000	So this still means nested lambda expressions.
969000	974000	It's just a convenient shorthand for indicating that they're curried.
974000	977000	I'm not going to go through all of the logic of this again.
977000	982000	It's the exact same example we saw before of feeding an argument into its parameter
982000	986000	and replacing the parameter in the body, feeding an argument into its parameter
986000	989000	and replacing the parameter in the body.
989000	995000	But this time I've used the syntax shorthand to show those nested lambdas.
995000	1000000	So the body of this one is another lambda and then we proceed as normal
1000000	1004000	and the rest of this is exactly identical to what we saw before.
1004000	1006000	So just a shorthand.
1006000	1009000	Don't get too tripped up over it, but it's going to be convenient for us
1009000	1013000	to be able to think conceptually of functions that take multiple arguments
1013000	1018000	even though we know, we'll just keep that as a footnote, that they're all curried functions.
1018000	1021000	Are you ready for the next combinator?
1021000	1024000	Let's talk about the kestrel.
1024000	1030000	The kestrel takes an A and a B and it returns A.
1030000	1035000	Let's try that out.
1035000	1039000	Takes an A, takes a B, returns A.
1039000	1043000	What is the kestrel of the identity in the mockingbird?
1043000	1046000	Yeah.
1046000	1051000	What about the kestrel of the kestrel in the mockingbird?
1051000	1054000	Right.
1054000	1058000	It doesn't matter what the second thing is, it's irrelevant.
1058000	1068000	The kestrel just takes two things and returns the first one.
1068000	1072000	So we just saw that here.
1072000	1077000	In Haskell, this is built into the base language as the const function.
1077000	1079000	Why is it called const in Haskell?
1079000	1081000	Let's try something interesting here.
1081000	1089000	I'm going to say k5 is the function you get when you call k with only one of its arguments.
1089000	1092000	So normally the kestrel takes two arguments and gives you back the first one,
1092000	1095000	but I'm only going to give it one of its arguments.
1095000	1101000	Well, that's interesting, but these are curried functions, so I can give it another argument.
1101000	1103000	It gives me back the first thing.
1103000	1105000	I can also give it back some other argument.
1105000	1107000	It gives me back the first thing.
1107000	1110000	This is a function that's fixated on a particular value.
1110000	1112000	It's the constant five function.
1112000	1118000	No matter how I invoke this function, it always gives me back five.
1118000	1121000	That's why it's called const in Haskell.
1121000	1124000	But it's the k-combinator.
1124000	1126000	Here's a fun one.
1126000	1128000	I really like this one.
1128000	1132000	The kestrel of identity and some x is?
1132000	1133000	Identity.
1133000	1135000	Identity, makes sense.
1135000	1137000	This is an algebraic equality.
1137000	1141000	The thing on the left is the thing on the right and vice versa.
1141000	1144000	Well, the thing on the right is a function.
1144000	1149000	And I know in the lambda calculus I'm allowed to apply functions to values.
1149000	1151000	So I apply this to y.
1151000	1154000	What do I get?
1154000	1155000	Yy.
1155000	1157000	Y, that makes sense.
1157000	1161000	On the left side equals the middle side equals the right side.
1161000	1163000	That means I can ignore the thing in the middle,
1163000	1165000	and the thing on the left equals the thing on the right.
1165000	1168000	Does anybody see where I'm going with this?
1168000	1174000	I've got ki of x and y returns y.
1174000	1180000	Ki of a first argument and a second argument returns the second argument.
1180000	1185000	I just derived the kite.
1186000	1191000	The kite combinator takes two arguments.
1191000	1193000	One and two.
1193000	1196000	And it gives you back the second one.
1196000	1198000	Now, I could have done this manually.
1198000	1204000	I could have said the kite is a function that takes an a,
1204000	1208000	and it takes a b, and it returns b.
1208000	1212000	And then I would call the kite on something like four and nine,
1212000	1214000	and it gives me back nine.
1214000	1220000	But it's cool to see that from these atomic combinators combined together,
1220000	1223000	I get these new molecules, which are other combinators.
1223000	1226000	So some of my combinators can mix and match
1226000	1231000	and start producing other functions that are useful and interesting in different ways.
1231000	1238000	So ki of m and ki is?
1238000	1242000	Yes.
1242000	1245000	So kite of the mockingbird in the Kestrel's castle.
1245000	1246000	Flip them around.
1246000	1247000	You get the other one.
1247000	1249000	So far, so good.
1249000	1252000	At this point, probably some of you are wondering,
1252000	1254000	what's with all the bird names?
1254000	1257000	Got mockingbird, Kestrel, kite, et cetera.
1257000	1258000	All right.
1258000	1261000	So we're going to take a little mental break for a moment and talk about history.
1261000	1264000	Moses Eliachchenfinkel.
1264000	1267000	And I can't pronounce German, so please forgive me.
1267000	1270000	Name these things, long German names.
1270000	1275000	Like Zussim et Setsum function.
1275000	1278000	Haskell B. Curry, who came a little bit later,
1278000	1282000	used some of the same letters, but also some of his own letters,
1282000	1284000	just to add to the confusion.
1284000	1289000	And in the 1980s, a logician and puzzle author named Raymond Smullyan
1289000	1292000	wrote this absolutely wonderful book to mock a mockingbird.
1292000	1297000	The whole back two thirds of which is about combinatorial logic.
1297000	1302000	And Smullyan took Curry's combinator names and turned them into birds.
1302000	1307000	And the reason is because the book doesn't lay a lot of emphasis
1307000	1310000	on the math from a formal perspective.
1310000	1314000	Instead, it uses this metaphor of birds in a forest
1314000	1319000	who hear the songs of other birds and sing back the names of other birds.
1319000	1323000	So birds creating birds and singing birds and all this kind of stuff.
1324000	1328000	Now, unfortunately, Smullyan called the identity combinator the idiot bird.
1328000	1330000	I wish that he had used the ibis.
1330000	1334000	I used the ibis in my first slide, but we'll forgive him
1334000	1337000	because the rest of the book is just so wonderful.
1337000	1340000	Now, he didn't do this totally for no reason.
1340000	1345000	He actually did it to honor Curry because Curry was himself an avid bird watcher.
1345000	1350000	And at this point, some of you are thinking, Haskell Curry, who's this guy?
1350000	1352000	Why do we care about him?
1352000	1355000	I'm not Sean Finkel or vice versa.
1355000	1360000	So the next slide is the anti-diversity slide.
1360000	1364000	This is just the historical nature of mathematics in the 20s and 30s.
1364000	1366000	It was filled with a lot of white men.
1366000	1369000	So we'll acknowledge that and move on.
1369000	1372000	But I'm going to give you a really fast crash course
1372000	1374000	in the formalization of mathematical logic.
1374000	1378000	Around the late 19th century, early 20th century,
1378000	1382000	people were realizing that math, which had seemed on the face of it
1382000	1387000	so cut and dried and straightforward, was hiding some really nasty paradoxes.
1387000	1390000	And so people were trying to unify mathematics and figure out
1390000	1395000	the sufficient axioms that would define all of mathematics in one big tone.
1395000	1398000	So what was like the real, true system of math?
1398000	1400000	Bless you.
1400000	1402000	So I'm going to race through this.
1402000	1403000	I could do an entire presentation.
1403000	1405000	That would be two hours on just this.
1405000	1409000	I'm going to try and keep it to less than five minutes.
1409000	1414000	In 89, Giuseppe Piano invents his own formal notation for function abstraction.
1414000	1419000	He also defines arithmetic as the sequence of natural numbers starting from zero,
1419000	1423000	and then the successor of zero, and then the successor of successor of zero,
1423000	1426000	and the successor of successor of successor of zero, and so on and so forth.
1426000	1429000	These are Piano numbers.
1429000	1435000	The logician Gottlob Frege develops his own function notation,
1435000	1437000	which uses this really unique graph format.
1437000	1439000	It's actually really cool to say.
1439000	1441000	Impossible to read.
1441000	1446000	But a good idea, a good idea which has better versions that come later.
1446000	1451000	And most famously, he basically invents quantified axiomatic logic.
1451000	1455000	So this is the kind of sentence like, for all x in the reals,
1455000	1459000	there exists a y in the reals such that y is greater than x.
1459000	1462000	For all, and there exists.
1462000	1466000	That's the quantification and quantified axiomatic logic.
1466000	1471000	By the way, Frege, even in 1891, was using curried functions.
1471000	1476000	In the 1910s, Bertrand Russell, along with Whitehead,
1476000	1478000	very famously published Principia Mathematica,
1478000	1481000	an attempt at formalizing all math,
1481000	1485000	but he also discovered earlier than that, actually, Russell's paradox,
1485000	1489000	the thing of all sets that do not contain themselves.
1489000	1492000	Well, is that set in itself or not?
1492000	1495000	It's a paradox. It's impossible to figure out.
1495000	1500000	So that made a lot of people really disconcerted,
1500000	1507000	and they realized that math wasn't quite so perfect in its foundations as first thought.
1507000	1511000	Schoen Finkl, we talked about, he was an early pioneer in combinatorial logic.
1511000	1516000	He also used currying and published one paper, and then it was really sad, actually.
1516000	1519000	The rest of his life really spiraled downhill.
1519000	1524000	He ended up in a mental asylum, which don't worry,
1524000	1529000	it's not because of combinatorial logic, I don't think.
1529000	1533000	Van Neumann, famous mathematician, also later in life,
1533000	1536000	helped build the first real electric computers.
1536000	1541000	He also kind of did something that, if you reinterpret it, it's combinatorial logic,
1541000	1545000	but that was almost by accident, like that wasn't his goal in life.
1545000	1549000	And then in 26, Haskell Curry starts reinventing combinatorial logic.
1549000	1552000	He wasn't aware of Schoen Finkl or Frege, well, he was aware of Frege,
1552000	1555000	but not any kind of link to combinatorics.
1555000	1558000	And so he does a whole bunch of contributions.
1558000	1565000	He's a really smart guy at Princeton, and in 1927, he discovers that Schoen Finkl beat him to the punch.
1565000	1569000	So he forges on nonetheless, which is good for us,
1569000	1572000	because he develops many, many new theorems.
1572000	1578000	In 1931, Cort Godot, very famous mathematician,
1578000	1582000	who kind of plunged a dagger into the very heart of math,
1582000	1589000	discovers that this race in search for the perfect set of foundations for math is fundamentally flawed.
1589000	1593000	It's a fool's errand, it's impossible, it's literally impossible,
1593000	1599000	because every complicated enough system to be interesting by a certain definition of interesting,
1599000	1605000	such as piano numbers, is either inconsistent or incomplete.
1605000	1609000	That means there's either logical inconsistencies which make it make no sense,
1609000	1614000	or there are systems and things inside that language which you can talk about,
1614000	1616000	but you can't prove or disprove.
1616000	1618000	There's no way to get to the proof or disprove.
1618000	1621000	That totally upends math as we know it.
1622000	1628000	In the 30s, Alonzo Church is trying to figure out a system that's at least good enough
1628000	1632000	to compute things that are computable in some definition of computable,
1632000	1636000	and he develops this thing that we've been talking about the whole time, lambda calculus,
1636000	1639000	this notation system for writing down functions.
1639000	1647000	Now, it's this tiny, tiny language, and at first, his grad students such as Stephen Klaney and Rosser,
1648000	1652000	they think that it's not going to really lead too much, like it's just a notation system,
1652000	1655000	but then they start to realize like it's ballooning outwards,
1655000	1660000	and it's from this very tiny bit of logic is coming all sorts of interesting results.
1660000	1666000	They also prove different versions of it are consistent or inconsistent.
1666000	1673000	Stephen Klaney, by the way, goes on later in life to invent this thing that we use all the time called regular expressions,
1673000	1676000	so that's fun.
1676000	1684000	In 1936, Alonzo Church solves a famous unsolved problem, David Hilbert's decision problem.
1684000	1689000	This is an algorithm problem that says like, well, actually, I can't remember the specifics,
1689000	1691000	but it's, let me see.
1691000	1695000	Oh, is there a way to figure out if any given problem does have a solution,
1695000	1698000	very closely related to, but distinct from the halting problem?
1698000	1702000	And Church is like, no, there isn't.
1702000	1709000	But he uses the lambda calculus to solve it, which was hilarious because it started out as three or four lines of notation,
1709000	1715000	and it turned into a system complicated enough to solve this famous unsolved problem.
1715000	1717000	Guess what also happens in 1936?
1717000	1721000	Two months later, Alon Turing solves the problem using something called a Turing machine,
1721000	1726000	and he publishes his own paper, and then he finds out that Church beat him to the punch by two months,
1726000	1728000	and he gets really annoyed by that.
1728000	1732000	He was actually quite disappointed to find out that someone else had raced him
1732000	1735000	and beat him to solving the decision problem.
1735000	1739000	But he looks at the paper, he looks at Church's lambda calculus and says, you know what?
1739000	1741000	These are actually identical.
1741000	1748000	My Turing machines and Church's lambda calculus are the exact same thing just expressed different ways.
1748000	1755000	So then he decides, you know what, I'll bury the hatchet, come to Princeton, get a PhD under Church with Church as his advisor.
1755000	1761000	And in 1937, he publishes the first fixed point combinator.
1761000	1764000	Okay, that's the history.
1764000	1769000	In the tiniest nutshell I could manage, or at least bear to part with.
1769000	1772000	So, combinator.
1772000	1774000	You keep using that word.
1774000	1776000	I don't think it means what you think it means.
1776000	1778000	What is a combinator?
1778000	1781000	We've said this thing many times, combinator logic and combinator's lambda calculus.
1781000	1783000	Where's the dividing line?
1783000	1787000	In reality, they're almost entirely the same thing.
1787000	1791000	A combinator is a function with no free variables.
1791000	1797000	A free variable is a variable in a function body that's not bound to some parameter.
1797000	1803000	So this is a combinator because the B in the body is bound to the B parameter.
1803000	1806000	Whereas that's not a combinator because A comes from nowhere.
1806000	1810000	What is A? Who knows? We could make it up. It doesn't matter.
1810000	1815000	It doesn't matter that we're not using the B. The B is irrelevant. It's a parameter.
1815000	1820000	Not a combinator because where does the B come from? Don't know.
1820000	1822000	And even more complicated stuff like this.
1822000	1825000	Don't get distracted by the E. That's a parameter. It's not a variable.
1825000	1829000	So everything that appears in the body, C and B, those are bound to parameters.
1829000	1834000	That's a combinator. You now know what a combinator is.
1834000	1842000	We've seen a bunch of combinators. Identity, self-application, first or const, second.
1842000	1849000	And the cool thing is, as I mentioned before, using some of the primitive combinators mixed together,
1849000	1854000	we start generating some of the more complicated combinators, or at least other combinators,
1854000	1858000	which is surprising but cool.
1858000	1861000	Are you ready for the next one?
1861000	1866000	Let's look at the cardinal. Let's just look at it for a second.
1866000	1871000	Not the beautiful photo, which I stole from somewhere. I can't remember where.
1871000	1878000	But the combinator itself, anybody looking at this, can you think conceptually what this actually does
1878000	1884000	in sort of a use case way?
1884000	1887000	I'm really pushing you here because we're talking about abstract math,
1887000	1892000	but we're just keeping you in a land with no JavaScript.
1892000	1900000	Exactly. It just flips around arguments. It takes a function f that takes two parameters,
1900000	1906000	and then it calls the function f with both of those parameters, but in the opposite order.
1906000	1913000	So here's the C combinator, and what if we apply this to a function in two arguments,
1913000	1916000	which is the kestrel and these other two things that we don't care what they are,
1916000	1918000	but they're i and m in this case.
1918000	1924000	The cardinal of the kestrel and the idiot and the mockingbird.
1924000	1929000	Well, walking through it, it takes three things, the function and two arguments,
1929000	1933000	and it calls the function. Which is the function here?
1933000	1938000	k. And it calls them with two arguments. Which are the arguments?
1938000	1944000	And it calls them in the opposite order. So it's k of m and i, which is?
1944000	1947000	Yeah.
1947000	1953000	So we start with the kestrel, and then we put two things into it, but backwards.
1953000	1955000	That's interesting because look at what we have here.
1955000	1958000	The cardinal of the kestrel takes two things and returns the second.
1958000	1962000	Does that sound familiar?
1962000	1964000	It's the kite.
1964000	1967000	The cardinal of the kestrel is the kestrel of identity.
1967000	1971000	The kite is this other thing. They're all the same.
1971000	1973000	And we can just do this to prove it.
1973000	1976000	Let's do the cardinal takes a function.
1976000	1979000	This monitor went away. There we go.
1979000	1983000	It takes a function, takes an argument, another argument,
1983000	1989000	calls the argument with the arguments backwards.
1989000	1993000	Let's get the cardinal of the kestrel.
1993000	1996000	Apply it to two variables.
1996000	1998000	The kestrel normally gives you back the first thing,
1998000	2001000	but the cardinal of the kestrel gives you the second thing.
2001000	2008000	It works. This isn't pure math. It's also applicable.
2008000	2011000	So that's kind of fun. Cardinal, if you've got a cardinal,
2011000	2013000	you can apply it in different ways.
2013000	2016000	You can flip the kite around to get the kestrel or the kestrel to get the kite.
2016000	2019000	And in fact, in Haskell, this is built into the base language,
2019000	2021000	and it's called flip.
2021000	2027000	And it actually ends up being useful from time to time.
2027000	2029000	So why? Why are we learning this?
2029000	2031000	What's actually going on here?
2031000	2034000	How is this useful? Do we care?
2034000	2037000	Remember, lambda cacos and Turing machines are equivalent.
2037000	2040000	Anything one can calculate, the other can calculate.
2040000	2043000	But Turing machines are exciting because they're these hypothetical devices
2043000	2047000	that use state information that exists over here, here, here,
2047000	2052000	and things that change over time to do computations.
2052000	2054000	And from these hypothetical devices, people said,
2054000	2057000	wait a second, we could build real machines that do this.
2057000	2059000	And they use memory and state,
2059000	2061000	and they do a little bit more complicated stuff
2061000	2064000	just to make it more performant and easier to work with.
2064000	2067000	But at their heart, they're really Turing machines.
2067000	2069000	So they work with machine code,
2069000	2071000	which means let's flip a whole bunch of physical switches
2071000	2074000	and then see what electricity and bits come out the other end.
2074000	2078000	And we abstract that away in a language, a text format called assembly language,
2078000	2083000	that says things like, move the data in register B to the accumulator register.
2083000	2088000	Add one to whatever value is in the accumulator register of my memory.
2088000	2092000	Very stateful, very machine-based, very hard for humans to reason about.
2092000	2096000	It's not conceptual. It's all about machines.
2096000	2100000	Well, we build higher-level languages like C that compile into assembly.
2100000	2103000	But those higher-level languages are still machine-centric.
2103000	2108000	They still say things like, hey, see, go allocate seven bits of memory over here
2108000	2112000	and give me back a reference to the pointer of that memory address and so on and so forth.
2112000	2114000	So then somebody says, well, this is stupid.
2114000	2116000	We'll make the programming languages do that for us,
2116000	2118000	and we'll just focus more on concepts.
2118000	2120000	Like, hey, give me a var x,
2120000	2122000	and I don't care how you figure out the memory for that,
2122000	2124000	just go do it yourself.
2124000	2127000	And then somebody says, why are we even bothering with memory?
2127000	2132000	Why don't we just have these pure functions that operate on each other?
2132000	2133000	And wait a second.
2133000	2137000	This whole time this machine march through abstraction
2137000	2141000	has been leading us to something that existed before Turing machines existed,
2141000	2143000	which is the lambda calculus.
2143000	2147000	Functional programming languages are based on,
2147000	2151000	slash their backbone is, the lambda calculus.
2151000	2154000	So if we decide, wait, we're not going to organically evolve
2154000	2157000	towards this kind of conceptual abstraction,
2157000	2161000	but let's just start straight from the lambda calculus and go the other direction.
2161000	2164000	We can start designing purely functional languages
2164000	2169000	and using all the decades of mathematical research that have gone into LC
2169000	2171000	to design our language and see what comes out of that
2171000	2173000	and see if there's anything useful that we could do there.
2173000	2175000	And then we'll take that pure functional language,
2175000	2182000	just compile it down to machine code so it runs on our physical Turing machines.
2182000	2185000	Lambda calculus and Turing machines are equivalent.
2185000	2190000	Therefore, here's the big theme of the entire talk coming in the next slide.
2190000	2193000	Everything can be functions.
2193000	2197000	When I say everything, I mean everything.
2197000	2200000	Like Booleans.
2200000	2201000	Whoa.
2201000	2204000	Here's a JavaScript Boolean expression.
2204000	2210000	Not X is equal to, that's the double equals, not the assignment equals.
2210000	2215000	Y or the result of the expression A and Z.
2215000	2217000	How are we going to do this in lambda calculus?
2217000	2221000	Well, it's a problem because we don't have negation.
2221000	2224000	We don't have ors and and operators.
2224000	2227000	I mean, we don't even have a quality checks in the lambda calculus, right?
2227000	2229000	That wasn't in the language.
2229000	2231000	We don't have Booleans.
2231000	2233000	We do have parentheses.
2233000	2236000	That's what we got.
2236000	2238000	We got parens.
2238000	2241000	All right, so how on earth are we going to do this?
2241000	2245000	Let's start with the primitive building blocks, the Booleans.
2245000	2247000	A bool.
2247000	2250000	What is that used for in JavaScript?
2250000	2253000	Well, what about selection?
2253000	2256000	Some result is check a Boolean condition.
2256000	2259000	If it's true, we'll get the first expression.
2259000	2262000	If it's false, we'll get the second expression.
2262000	2265000	Let's start translating this over to lambda calculus.
2265000	2269000	Well, we got this ternary except, oops, this question mark and colon.
2269000	2271000	That's not in the lambda calculus syntax.
2271000	2273000	It's got to go. Bye-bye.
2273000	2275000	What are we left with?
2275000	2277000	This is a function application, right?
2277000	2279000	So bool must be.
2279000	2281000	What's the theme of the talk?
2281000	2283000	A function.
2283000	2285000	And, oh, well, what do we need here?
2285000	2288000	We need a function that if it's the quote unquote true function,
2288000	2290000	it selects the first expression.
2290000	2293000	And if it's the false function, it selects the second expression.
2293000	2296000	Wait a second. This sounds really familiar to me.
2296000	2300000	Where have we seen a pair of functions that select either the first or second things?
2300000	2302000	Yeah.
2302000	2304000	We already have Booleans.
2304000	2306000	We didn't even have to reinvent them.
2306000	2309000	They're already in the language that we've developed so far in this talk.
2309000	2315000	We'll just encode, in other words, represent Booleans as functions.
2315000	2318000	We'll say that the kestrel function, the constant function,
2318000	2322000	the first function is true, quote unquote, and the kite is false.
2323000	2325000	That's kind of neat.
2325000	2329000	Let's do that while we're looking at this slide and admiring it.
2329000	2333000	True is equal to the kestrel.
2333000	2337000	And false is equal to the kite.
2337000	2339000	Now, there's a little node trick that I'll use here,
2339000	2343000	because if I go console log out true, it tells me it's the kestrel,
2343000	2348000	which is true, but in both senses.
2348000	2352000	But it's also slightly annoying, like if I'm going to start doing Booleans.
2352000	2353000	So I'm going to do a little trick here.
2353000	2364000	I'm going to say t.inspect is a function that returns the string true slash kestrel.
2364000	2373000	And false.inspect is a function that returns false or the kite.
2374000	2376000	Now, if I log out t, I get t slash k.
2376000	2380000	And if I log out false, I get false slash kite.
2380000	2386000	So that'll be useful going forward in some of these demos.
2386000	2387000	That wasn't lambda calculus.
2387000	2391000	The other stuff was, but not the dot.inspect.
2391000	2393000	OK, so we have true and false.
2393000	2395000	But true and false on their own are kind of boring, right?
2395000	2397000	Yeah, so we can select between two things.
2397000	2398000	What about Boolean logic?
2398000	2401000	What about vacation?
2401000	2403000	Let's translate it.
2403000	2405000	Well, what doesn't belong?
2405000	2408000	One of these things is not like the others.
2408000	2413000	The negation, the exclamation mark isn't in the lambda calculus syntax.
2413000	2415000	What does it got to be instead?
2415000	2417000	What's the theme of the talk?
2417000	2419000	A function.
2419000	2420000	The not function.
2420000	2426000	The not function will take in a Boolean and it will select between two other Booleans.
2426000	2430000	If we give it not true, it selects false.
2430000	2434000	If we give it false, it selects true.
2434000	2436000	How can we implement the not function?
2436000	2437000	Well, wait a second.
2437000	2440000	We just talked about selecting between two things.
2440000	2448000	What kind of thing selects between two possibilities?
2448000	2449000	We have a function.
2449000	2450000	Yes, a function.
2450000	2452000	That's true.
2452000	2458000	But specifically, these Booleans that we're using, the kite and the kestrel,
2458000	2462000	themselves functions that choose between two possibilities.
2462000	2464000	Look at what I have here, this expression.
2464000	2465000	An unknown Boolean p.
2465000	2466000	It might be the kite.
2466000	2467000	It might be the kestrel.
2467000	2469000	I don't know which one.
2469000	2476000	If it's the kestrel or true, which one of those does it select?
2476000	2480000	The first one, false.
2480000	2487000	And if my unknown Boolean is the kite, which does it select?
2487000	2489000	The second one, true.
2489000	2494000	My unknown Boolean selects its own opposite in this expression.
2494000	2498000	So we'll turn this into a function and we'll call it not.
2498000	2499000	That's it.
2499000	2506000	Not just takes a Boolean and then tells the Boolean select your opposite.
2506000	2509000	I promise it works.
2510000	2517000	So not takes, let's say it takes a Boolean and then it calls the Boolean passing in false and true.
2517000	2520000	So if we say not true, that's false.
2520000	2522000	And not false is true.
2522000	2525000	I've not put a single JavaScript Boolean into any of this.
2525000	2526000	I'm doing negation.
2526000	2533000	This is like, this should be exciting.
2533000	2534000	All right.
2534000	2538000	So our church encodings, which is what these things are called for Booleans now includes
2538000	2539000	negation.
2539000	2542000	We saw how we got true and false.
2542000	2544000	But there's a more exciting way of doing this.
2544000	2546000	There's an even better way, in my opinion.
2546000	2548000	A cooler way.
2548000	2551000	Not true is false and not false is true.
2551000	2555000	But we said true and false, we're encoding those as the kestrel and the kite.
2555000	2560000	But if the kestrel and the kite, there's no named functions in lambda calculus.
2560000	2565000	This is just us writing down a shorthand so that we don't have to remember and read out all the lambdas.
2565000	2570000	But if we did replace them with their equivalent lambda expressions, that's what we're really looking at.
2570000	2578000	Now, we're saying the Not function will take at the top there a lambda that takes two arguments and gives you back the first,
2578000	2583000	and it gives you back a lambda that takes two arguments and gives you back the second.
2583000	2584000	OK?
2584000	2588000	And at the bottom, we're saying it takes, you know, two arguments and gives you back the second,
2588000	2594000	and the Not function will give you back a lambda that takes two arguments and gives you back the first.
2594000	2594880	Interesting.
2597240	2601120	So does anyone see, instead of not,
2601120	2602800	is there a function that we've already
2602800	2606000	seen that will result in this?
2606000	2610000	A function that accepts a binary function, a function that
2610000	2616200	takes two arguments, and it moves the arguments around?
2616200	2618080	It's the cardinal.
2618080	2621200	Yeah, the only other one we've seen.
2621200	2623560	The cardinal already does this behavior.
2623560	2627680	The cardinal is boolean not.
2627680	2633240	The flip of true is false, and the flip of false is true.
2633240	2635000	This monitor is really going to bug me.
2635000	2635560	There we go.
2635560	2636440	Stay there.
2636440	2638400	Don't move.
2638400	2638960	Let's try it.
2638960	2643200	Cardinal of true.
2643200	2646440	Now, unfortunately, look what I'm about to get here.
2646440	2649440	This isn't quite what I want, just this function.
2649440	2650600	Well, that's weird.
2650600	2652280	What if I use this function?
2652280	2655720	I'll apply it to two things, one and two.
2655720	2657840	I get back the second thing, which is what I want.
2657840	2661320	The flip of true is false, so I should get the second thing.
2661320	2665720	And the flip of false is true, so I should get back
2665720	2667680	the first thing, which I do.
2667680	2671520	The problem is, the problem is, and it's not really a problem,
2671520	2675520	the problem is that the cardinal generates a new function,
2675520	2679840	unlike my previous implementation of not, which
2679840	2682960	selects between existing false and true functions,
2682960	2686800	the cardinal generates a new function that behaves identically
2686800	2688960	to the kestrel or kite.
2688960	2692560	This kind of identity crisis is known
2692560	2696680	as intentional equality versus extensional equality.
2696680	2698640	Extensional equality, which is the kind of equality
2698640	2702240	I'll use throughout this talk, means the functions are the same.
2702240	2705600	If for every input, they generate the same output.
2705600	2707560	So the cardinal of the kestrel is
2707600	2710480	extensionally equal to the kite.
2710480	2711920	They both behave identically.
2711920	2715160	There's no way to tell them apart from the outside, quote unquote.
2715160	2718160	Intentional equality is more like, well, where did it come from
2718160	2718920	and what's inside it?
2718920	2720760	What are its guts?
2720760	2727880	I'm not going to focus on that during this talk, but it works.
2727880	2730920	That's the important thing.
2730920	2736880	Let's design and together, Boolean and, Boolean conjunction.
2736880	2737800	We know it's a function, right?
2737800	2739520	That's the theme of the talk.
2739520	2742200	How many arguments does it take?
2742200	2743920	What are these arguments?
2743920	2745800	What kind of thing are they?
2745800	2747800	They're Booleans, so they're the kestrel of the kite
2747800	2750960	or kite and kestrel or kestrel or kestrel or kite and kite,
2750960	2753240	just to finish it out.
2753240	2755640	Well, to take in a parameter, you're
2755640	2757480	probably going to use that parameter somewhere
2757480	2759040	in the body of your function, right?
2759040	2761680	So even if we're not quite sure where to go with this,
2761680	2764600	let's try just using one of these Booleans.
2764600	2768760	P is a Boolean, so what does it do?
2768760	2771360	What do these Boolean functions do when I use them?
2774560	2777400	Yeah, they select between two possibilities,
2777400	2779000	such as the Spanish question mark.
2781600	2787520	What if our first argument to and is false?
2787520	2790560	Which of the two possibilities will P select?
2790560	2791680	The second one.
2791680	2792480	But wait a second.
2792480	2794640	If one of the arguments to and is false,
2794640	2796960	what should that result of this entire function be?
2799800	2803160	Yeah, so I'll just put false there.
2803160	2806560	If P is false, short circuit, don't bother looking at Q.
2806560	2809160	There's no point where you can know we just select the second
2809160	2811520	thing, and it's already going to be false.
2811520	2817520	So we don't even bother checking Q. Well, what if P is true?
2817520	2820400	It's going to select the first thing, right?
2820400	2821640	But what is that first thing?
2821640	2823320	What should it be?
2823320	2824760	Based on Q?
2824760	2827440	Yeah, it's got to be Q.
2827440	2831880	Because if P is true, the and is true only when Q is true,
2831880	2834040	and the and is false if Q is false.
2834040	2836960	So once P is true, we have to go look at Q and use Q as our
2836960	2839520	result.
2839520	2841960	There's one more small simplification we can actually
2841960	2843520	make to this that's kind of nice.
2843520	2847840	I like it in any rate, which is we said that, by the way, P is
2847840	2850320	a Boolean, so it selects between two possibilities.
2850360	2853840	If P is false, it should select false.
2853840	2856480	But I've hard-coded in a false.
2856480	2859120	There was a way I could do this even more directly or
2859120	2861640	indirectly, it depends on your perspective.
2861640	2864600	If P is false and it should select false, P can just
2864600	2867080	select itself.
2867080	2870680	If P is false, then return P, which is false.
2870680	2872760	So I end up with this thing, which is very much a
2872760	2876560	combinator, PQ, PQP.
2876560	2878000	That is my and function.
2880400	2884360	I forget where we're at in our demonstrations of JavaScript.
2884360	2885840	Do we have not?
2885840	2887160	We do have not.
2887160	2887920	What about and?
2887920	2888440	No, we don't.
2888440	2889800	OK, let's do that.
2889800	2896240	And takes a Boolean and another Boolean, and it applies P
2896240	2899760	to Q to P. PQ, PQP.
2899760	2901120	That makes sense.
2901120	2906400	So and of false and true is false.
2906400	2909120	And of true and true is true.
2909320	2910960	And false is false.
2910960	2914040	And false and false is false.
2914040	2916560	All the things we love and expect from the and function.
2919280	2920280	That's neat.
2920280	2921520	Let's do or.
2921520	2924120	What is or?
2924120	2927720	Hey, someone's got the theme down.
2927720	2928520	I cheated ahead.
2928520	2931000	I jumped ahead and gave you two of the arguments.
2931000	2931720	Oh, no.
2931720	2932600	What are we going to do?
2932600	2934720	P is a Boolean, it selects between two things.
2934720	2936560	All right, here's where it differs from and.
2936560	2938160	What if P is true?
2938160	2940120	Oops, I jumped ahead too much.
2940120	2941120	P is true.
2941120	2943520	It selects the first thing, which has got to be true.
2943520	2945760	If P is true, we don't have to bother looking at Q, because
2945760	2949640	in or, if one of them is true, then we just result in true.
2949640	2954560	If P is false, what's the second argument got to be?
2954560	2958280	Q. It's just the opposite of the thing before.
2958280	2962840	So we can also simplify our kind of glossed over that, but
2962840	2964280	it doesn't have to be a hard-coded true.
2964280	2966360	It can just be P, because we reuse it.
2966440	2970320	If P is true, just return P.
2970320	2974040	That fact is actually really fun, because there's another
2974040	2977400	little thing we can do here that's a trick.
2977400	2982640	Somebody tell me, if I apply this PQ double PQ function to
2982640	2986040	X and Y as arguments, what is the resulting
2986040	2987000	better reduction?
2987000	2990320	In other words, what is the evaluation of this function?
2990320	2993920	What do I get as a result?
2993920	2998040	Remember, X replaces every P in the body, and Y replaces every
2998040	2998920	Q in the body.
3001440	3003840	Yep, X, X, Y.
3003840	3006440	But there's another function we've already seen that does
3006440	3009120	this.
3009120	3010160	I'll give you a hint.
3010160	3012200	What if we ignore the Ys for a second?
3015360	3016840	Yeah, it's the mockingverd.
3016840	3019040	It's the self-applicationverd.
3019040	3021160	The self-application of X is double X.
3021160	3023600	It's the self-application of X.
3023600	3025920	But if the thing on the left is equal to the thing on the
3025920	3029160	right, they're both functions I could apply them to some Y.
3029160	3031440	And now we see, wait a second, the thing on the top and the
3031440	3032880	thing on the bottom are actually the same.
3032880	3036920	The mockingverd works just like this other function.
3036920	3039000	It looks almost exactly like that, except the other
3039000	3042120	function is this additional Q on the end, which is useless.
3042120	3044200	It takes a Q and applies a Q.
3044200	3047720	This is known as the mockingverd once removed.
3047720	3050200	So that's what the star means.
3050200	3052320	It's been given an extra argument.
3052320	3055160	The mockingverd once removed is extensionally equal to the
3055160	3055720	mockingverd.
3055720	3058480	It behaves identically to it.
3058480	3060560	So have we defined or?
3060560	3061120	No, we haven't.
3061120	3062440	Let's do that really quickly.
3062440	3064680	Or it takes a P and a Q.
3064680	3070320	And it does P of P and Q.
3070320	3075840	We can demonstrate that or TF is true, or F is false, or
3075840	3079560	FT is true, and of course, or TT is true.
3079560	3081360	But we can also use the mockingverd for that, because
3081360	3083960	we just proved that the mockingverd outflurrates the
3083960	3085400	same way here.
3085400	3089920	So mockingverd of true and false is true.
3089920	3092200	False and false is false.
3092200	3095440	False and true is an or statement as well.
3095440	3097680	And that's also an or statement.
3097680	3099120	Wow.
3099120	3102960	Mockingverd, you're multi-talented.
3102960	3105560	Anybody have an idea what this might be?
3112160	3115040	Well, it's definitely a function that takes two
3115040	3117120	arguments.
3117120	3119360	And I'm going to tell you P and Q are Booleans, just to make
3119360	3121040	it slightly easier.
3121040	3123640	But if P and Q are Booleans, what does P do?
3127400	3130360	It selects between two possibilities.
3130360	3133160	And if Q is a Boolean, what does it do?
3133160	3135800	It selects between two possibilities.
3135800	3138160	Does this make it easier to see what this function does?
3138600	3142240	Sorry?
3142240	3144760	You were sure.
3144760	3148520	Well, if P and Q are the same Boolean, they select true.
3148520	3151640	If they're the same that way, they also select true.
3151640	3155440	But if they're different, they select false.
3155440	3158120	Which function is this?
3158120	3160400	Sorry?
3160400	3162040	Oh, is Zor something like that?
3162040	3163560	Not quite.
3163560	3164480	Maybe.
3164480	3165720	I'd have to think about it.
3165720	3166520	It might be Zor.
3166520	3168080	Yeah, I'd have to think about it.
3169000	3171240	Yeah.
3171240	3172040	That's true.
3172040	3173240	That's cool.
3173240	3175480	Yeah, nice work.
3175480	3177080	I didn't think about that.
3177080	3179480	There's a simpler thing that we use this with.
3179480	3181320	If P and Q are the same, we get true.
3181320	3182520	If they're different, we get false.
3182520	3185200	That's called equality.
3185200	3191280	This test, if P and Q are the same Boolean, well, there's a
3191280	3193480	nice little simplification we can make here.
3193480	3195160	Q is a Boolean true or false.
3195160	3196240	If it's true, it selects true.
3196280	3198280	If it's false, it selects false.
3198280	3199200	That's redundant.
3199200	3200640	We could just use Q as it is.
3200640	3202840	It's already true or false.
3202840	3205720	And at the bottom, if Q is true, it selects false.
3205720	3208000	And if it's false, it selects true.
3208000	3209960	We already have a function that does that.
3209960	3212000	It's called the not function.
3212000	3216840	So we can simplify this to P, Q, not Q. And that is our
3216840	3218840	Boolean equality function.
3218840	3222960	I'll do that as long as it sets P to Q to P, Q, not Q.
3223000	3227480	So Boolean equality takes a P and a Q.
3227480	3233520	And it does P of Q and not Q.
3233520	3234200	Try it out.
3234200	3238840	Boolean equality of true and true is, of course, true.
3238840	3240480	True and false, nope.
3240480	3242240	False and false, yes.
3242240	3244360	False and true, nope.
3244360	3246640	Nice.
3246640	3248320	It's always fun to see it actually work.
3248320	3250520	Like, you kind of believe it, and then you see it, and
3250520	3252600	you're like, oh, I guess it really is true.
3255600	3257400	All right, we got church encodings from Booleons.
3261560	3263880	I'm not going to do this one out.
3263880	3266480	But if you are familiar with Boolean logic, you have heard
3266480	3268000	of De Morgan's laws.
3268000	3270600	De Morgan's laws are a pair of laws.
3270600	3271760	This is only one of them.
3271760	3278920	But it says that not P and Q is equal to not P or not Q.
3279000	3282320	And we've just expressed that using nothing but functions.
3282320	3285200	No Booleans, no ands, no ors.
3285200	3286040	I could prove that.
3286040	3288520	We'll just take our shorthand and replace it with the
3288520	3290320	actual lambda calculus.
3290320	3296280	So there's our Boolean equality of not and PQ or not P or
3296280	3299000	not Q.
3299000	3302480	All right, it's pretty cool.
3302480	3305960	Now, I rehearsed this talk last night.
3305960	3306880	My fiance made me.
3306880	3310040	She said, this talk is way longer than an hour.
3310040	3311800	I was like, ah, we'll see how long it is.
3311800	3313800	She said, no, no, no, you're going to rehearse.
3313800	3318520	And I rehearsed, and it's way longer than an hour.
3318520	3321760	But this is a really good stopping point.
3321760	3323640	So what I'm going to do is I'm going to give you the
3323640	3327320	conclusion of this talk, which works perfectly after this
3327320	3327720	slide.
3327720	3328440	It fits.
3328440	3329680	It makes sense.
3329680	3333880	And anyone who would like to is welcome to stay another
3333880	3335080	30-ish minutes.
3335080	3337200	I'm going to go into another room, because Mark has to
3337200	3340960	come in here and get this room ready for demo day.
3340960	3345440	And I'll show them numbers in the lambda calculus.
3345440	3347800	But before we do that, I'm going to conclude this talk.
3347800	3351280	So let me skip way down to the bottom of my deck here.
3351280	3353200	If I can find my mouse, there it is.
3357920	3360680	Nope, further.
3360680	3364600	Nope, more than that.
3364640	3367000	Keep going.
3367000	3370440	Try to remember where this slide starts.
3370440	3371800	Almost there.
3380520	3382360	So a small preview.
3388400	3391400	This isn't even the only table in this talk.
3391400	3393560	These are just the combinators, let alone the
3393560	3396760	Boolean equality, the arithmetic, the numerals, and
3396760	3401000	the arithmetic operations that yield Booleans.
3401000	3403760	So lots of stuff that I am cutting out in the
3403760	3405000	interest of time.
3405000	3408680	But yeah, I know.
3408680	3411040	Here's where I want to conclude, and I want to give you a
3411040	3412880	couple little small addendums.
3412880	3416320	The first is I emphasized early on that from primitive
3416320	3419400	combinators come other combinators.
3419400	3422760	And this is a really cool sort of atom to molecule sort of
3422760	3423840	situation.
3423840	3427280	And it begs the question, how many combinators do we need
3427280	3431560	and which ones to generate all the other ones?
3431560	3432880	Is it even possible to do that?
3432880	3435840	Do we need an infinite number of them?
3435840	3439720	20, 10, 5?
3439720	3441320	Just two.
3441320	3442160	Not even identity.
3442160	3443400	Identity isn't on the board.
3443400	3444520	These are the only two you need.
3444520	3446520	You can make identity out of this, the
3446520	3448520	Starling and the Kestrel.
3448520	3450080	The Starling is a weird one.
3450200	3452880	I actually don't really like the SK
3452880	3457000	Combinator Calculus, which is what it is called.
3457000	3462520	I really like the BCKIM Combinator Calculus.
3462520	3464880	If I just added m to this, this would actually suffice
3464880	3465680	five of them.
3465680	3467480	And that was the one that Curry used.
3467480	3469760	I find this far easier to use than the SK
3469760	3472040	Combinator Calculus.
3472040	3473960	For instance, the identity in the SK
3473960	3476160	Combinator Calculus is S of KK.
3476160	3478320	It's also SKS.
3478320	3481000	Those are extensionally equal.
3481000	3483480	You didn't get a chance to see the Vario, but the Vario
3483480	3485320	is the world's smallest data structure.
3485320	3485760	That's right.
3485760	3488200	I'm putting data structures in lambda calculus.
3488200	3491120	Here it is in the SK Combinator Calculus.
3491120	3495960	And this is not even close to how complicated it can get.
3495960	3497520	So really, why?
3497520	3498640	What is what?
3498640	3500600	What?
3500600	3501520	All right.
3501520	3504880	To begin with, in my opinion, I was searching for the
3504880	3506360	answer to this why question.
3506360	3510520	I was trying to think, am I trying to evangelize like
3510520	3513120	learning abstract math or this and that?
3513120	3514000	Then I realized, you know what?
3514000	3517560	The honest answer for myself is, it's just fun.
3517560	3518720	I enjoy this.
3518720	3521800	I hope that you might enjoy it too.
3521800	3525760	That's the entire basis of the book to Maka Making Bird.
3525760	3528880	It's a book of logic puzzles and games.
3528880	3534160	It was written to act as a series of fun challenges.
3534200	3536760	It's a great mental workout.
3536760	3539800	Thinking along these patterns, let's you think about, oh
3539800	3541720	my gosh, I have to think of where nouns are verbs and
3541720	3543040	verbs are nouns.
3543040	3545920	And I've got to be able to think about partially applied
3545920	3548760	functions, curried functions, higher order functions.
3548760	3550760	There's a lot of spaghetti.
3550760	3555360	So it's really laying down the neurological groundwork for
3555360	3558440	understanding functional programming in general.
3558440	3561440	The lambda calculus, as I said before, being the basis of
3561440	3566360	languages like Miranda and Lisp and Haskell, means that
3566360	3569360	those languages, if you know this kind of
3569360	3574160	combinatorial logic, it sets you up for success in those
3574160	3575440	kinds of languages.
3575440	3578640	Because even though you're not required to think entirely
3578640	3581800	that way, there's a large portion of those languages
3581800	3586240	that assumes you are comfortable with that.
3586240	3589320	And from that, we get all sorts of real world practical
3589320	3590240	benefits.
3590320	3592120	So I started writing them down.
3592120	3594320	A lot of them are intersections with just functional
3594320	3595200	programming in general.
3595200	3598480	But many of these come directly from the lambda calculus.
3598480	3602880	Closures, higher order functions, laziness,
3602880	3606120	infinite data structures, garbage collection, function
3606120	3610360	graph reduction, type theory, provable programming code,
3610360	3613440	parallel processing for free, parametric polymorphism.
3613440	3615600	I mean, it just keeps going on and on and on.
3615640	3619800	And this all derives straight out of purely mathematical
3619800	3624000	fields that existed even before computers did.
3624000	3626000	But at the end of the day, I really just think that there's
3626000	3628440	a lot of elegant mathematical beauty to it.
3628440	3630520	And it's kind of art for art's sake.
3630520	3633680	I hope that this has inspired you to become interested in
3633680	3638080	this topic and maybe to go read some more about it.
3638080	3641200	Find a little bit of slides.
3641200	3642520	Here are all the combinators.
3642520	3643960	Here are all the booleans.
3644000	3647400	The numerals, church arithmetic, boolean ops in the
3647400	3649960	church arithmetic, data structures.
3649960	3652280	All of this is in the deck.
3652280	3654800	It's not an hour-long talk, is it?
3654800	3657480	And you've probably all been wondering, wait a second.
3657480	3660120	Where's the most famous combinator of all, the Y
3660120	3661120	combinator?
3661120	3663120	Well, there's the Y combinator.
3663120	3664400	What does it do?
3664400	3666800	I'll just leave you with this as a brain teaser.
3666800	3670440	The lambda calculus has neither loops nor recursion.
3670440	3672600	So how does it do either of those things?
3672600	3675120	Because it can calculate anything calculable.
3675120	3676040	This is the answer.
3676040	3680440	The Y combinator allows for recursion in a language that
3680440	3683120	doesn't have recursion built into it.
3683120	3686280	Unfortunately, I cannot demonstrate this in JavaScript
3686280	3689480	because it goes on forever.
3689480	3690920	This is a fixed point combinator.
3690920	3694080	It infinitely just keeps evaluating itself, which works
3694080	3696680	in a lazy language like Haskell or the lambda calculus
3696680	3697680	itself.
3697680	3701360	So unfortunately, because JavaScript is like the thing
3701360	3703720	on the right and not like the thing on the left,
3703720	3706080	we need a slight variation on the Y combinator
3706080	3709240	called the Z combinator, which is the exact same as the Y
3709240	3711000	combinator except the middle of it
3711000	3715440	has a funk, which defers calculation until required.
3715440	3718080	So the Z combinator I could demo if I wanted to,
3718080	3722200	but I haven't set that up in my code so I won't today.
3722200	3723840	All right, that is the talk.
3723840	3724640	Thank you very much.
3724640	3725440	Any questions?
