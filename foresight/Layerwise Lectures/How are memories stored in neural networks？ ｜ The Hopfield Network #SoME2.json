{"text": " The amount of random access memory, RAM, in a typical laptop is probably around 8 to 32GB. That's the part that directly interacts with the CPU. Aside from that, your hard disk might have, say, another terabyte or so of memory. But how much memory do you, that's to say, the human brain have? And can we even measure it in bytes? But maybe that's not even the first question we should ask. However much memory the brain has, where is it? Because every piece of memory in a computer has a physical location. To access a piece of data in RAM, for example, you have to know the binary address associated with that location. In fact, for the CPU, this really comes down to turning on just the right wires to retrieve the bits at the desired location. Now imagine a different kind of memory. Instead of specifying the where of a memory, its binary address, how about we could specify the what? Its content. A memory system, where if we provide an incomplete version of the memory, it just sort of autocompletes. Of course, with the right software, your computer can already do this. But it's not how computer memory works on its basic level. The point of this video is to convince you that autocompleting memories, also known as associative memory, is a kind of natural behavior of networks of neurons. With that, it'll become clear that it doesn't really make sense to measure memory capacity in networks of neurons in the same way we measure computer memory. The biggest difference might be computer memories have a place, a fixed location, but as we'll see, the memories in an associative network rather have a time. Computer memory is measured in bits, binary switches of ones and zeros. A string of eight such bits can represent anything from letters to integers. For our purposes, let's visualize them as patterns of this kind, like these 64 bits representing this 8x8 image of binary pixels. I always find that there's a piece missing from the story of bits as memory, and that's the following. How do I get to a memory once it's saved, say, in RAM? Because on its own, it doesn't do much. It's only when we retrieve it that it becomes useful. So how do we? Well, broadly speaking, and I'm glossing over tons of technical detail here, every piece of data in RAM is matched to a binary address. And this binary address really eventually boils down to a set of wires, in this case eight, that are either turned on or off. Each piece of data is in a different physical location, and can only be retrieved by knowing its address. How the reading and writing of memories is accomplished is really the meat of programming and is another story. What I want you to remember is the peculiar fact that memories are matched to addresses, and that's ultimately the only way to retrieve them. Contrast this with what we believe about the brain. There isn't a central orchestrator, like a CPU, and there aren't any addresses. Rather, there is a constant buzz of activity of many independent units called neurons. In this video, we'll try to make some sense of the buzzing of activity of networks of neurons by introducing a mathematical model called the Hopfield Network, named after the author of this 1982 paper. And as much as this has to do with memory, more generally, this video aims to be a lesson in modeling itself, which I always think of as the art of the essential. This is a neuron. I'm almost certain you've seen something like this before, but it sometimes pays to remember why we always come back to this when we want to understand things about the brain. The reason is, I think, that it has a rather simple behavior. It integrates electrical signals from other neurons to determine its own activity, and then it broadcasts that activity back to the network. Mathematically, the story goes something like this. There's electrical signals coming in from other neurons, which we will say are just some numbers. Then the synapses act as multipliers on these signals, another set of numbers. And then the activity of the neuron is based on the sum of the weighted inputs. And by based on, I mean that it's fine to apply some function after computing the sum. And that's it. So it gets interesting once we turn this into a network, connecting the outputs of neurons to the inputs of other neurons. This is a special type of neural network. It's a recurrent network, meaning that there are back and forth connections between the neurons. I haven't drawn them, but remember that any such edge is actually two edges, so that the two neurons influence each other. Okay, there's details here that we need to get into. But first, what does this have to do with memory? Well, it needs to be somewhere in here, doesn't it? Where? Remember the idea of an associative memory, which is the ability of a system to sort of pattern autocomplete? Let's try a definition of memory that's slightly wider than maybe what we're used to. Let a memory system be a system, that after having been in a certain state, a configuration, it has the ability to return to that state later on. Now, our computer memory from earlier actually has this property, if we include the CPU into the memory system. Our network seems different, though. So let's get creative. There's other things in our everyday lives that fall under our definition of memory. And one might be, and hear me out on this, a simple plastic bottle. If it's crushed, in other words, its configuration changed, it can sometimes return to its earlier state, which in that sense could be said to have been memorized. And the metaphor is not arbitrary. I actually do think that networks of neurons are kind of like that. What I mean is a neural network is a system with a pattern of activity that dynamically evolves. If somehow we could construct our network such that it would have some preferred state and would return to that state over time, if it was perturbed, then that could reasonably be qualified as a memory. This is a network of 64 neurons that I cleverly constructed such that it memorized this pattern of 8x8 binary pixels. So what's going on? To describe what this model is actually doing, we need to take the following steps. Remember I said time was important? We need to describe how the activity of the network changes over time. And then there's the question of learning. How do we actually imprint memories into the network? And this will have to do with the connections between the neurons. Finally, we need to understand if and when the network converges to its memory states. The crucial ingredient of our network really is the fact that it is a dynamical system. Its activity changes over time. By activity, we mean that each of the now 16 neurons in the network is described by a number and that this number is a function of time. And let's just assume that time moves forward in discrete steps. Furthermore, since we are interested in binary memory states, we will assume that activity means that the neurons can only be in one of two states, inactive, say minus one, and active, say plus one. Anyway, this all leaves us with 16 minus or plus ones at any given time, which we will call the state of the network. What actually happens if we increase time by one step? Imagine folding out the time dimension in space. Now we select one of the neurons at random and update its state according to the input of all other neurons in the network. The rest of the neurons stay the same. And this we simply continue. But hold on, you might ask. How do we update the state exactly? And why update only one neuron at a time? Well, for the second question, we could in fact update all neurons at once. But the issue here is plausibility, because that would require a global updating signal, almost like a clock, instructing all neurons to update simultaneously. It's slightly more realistic, although not too much to be honest, to let them update asynchronously. Okay, and for the other question, yes, what is the actual update equation? Well, it's remarkably simple. It's a weighted sum of the states of the other neurons. Weighted meaning that each state is multiplied by the strength of the connection between the neurons. And since the connections, in that sense, weigh the inputs, from now on, I'm actually going to call them weights. But then of course, to ensure that the result is plus one or minus one again, we'll make use of that function I mentioned earlier, F. And that's it. Those of you familiar with linear algebra will have recognized this as computing the dot product between the vector of neuron states and the vector of connection weights. This is a network of 64 neurons. And I'm just going to tell you without explaining how that it has memorized this pattern, starting it off in different initial states, and then running the equations I just described, selecting one neuron at a time at random and updating its activity. And wait, let's just make this a little simpler. We can see that the network really has this intriguing property that it gravitates towards the memory pattern in all cases. Or well, it ends up with the anti memory in some cases, we'll ignore that it has to do with a certain symmetry in the network that we will get to. Moreover, once it's settled into that state, it doesn't change anymore. The memory pattern is what is called a stable state of the network. So can we be sure that this always happens? Well, no. For example, things start to get complicated when there is more than one memory stored in the network. We'll get to that. But for the simple case of just a single memory, yeah, the network will converge to either the memory or its anti memory or as an edge case to the completely inactive state. So let's recap. Networks are just vectors that evolve in time and we update their elements asynchronously. Given some configuration of weights, there are stable states in the network, which we call memory states. And we have seen, although not proved, that the network is kind of attracted to these states. That leaves the following question. How do we make the network memorize a certain pattern? In other words, how can we design the stable states of the network? This amounts to setting the weights of the network, which turns out to be a matrix with as many rows and columns as there are neurons. For example, the state of this neuron is determined by the weights in this row of the matrix. At first, this might seem impossible, especially if we wish to store more than one memory in the network. So I'm just going to tell you the magic rule and then I'll motivate it. Given a desired memory state with, say, eight elements, we are looking for an eight by eight matrix. We will just say, seemingly out of nowhere, that the weight between two neurons, i, j in general, is determined by the product of their states in the memory. For all of you keen on linear algebra, this means that the matrix is an outer product of the memory vector with itself, except for the diagonal, which we set to zero, since we don't want any self-reinforcement. But why? Think of it this way. Our whole approach was in some sense to build something interesting from many simple parts. So there really should be a way for the two neurons to determine the weight between them, independent of the rest of the network. This is a principle called Hebbian learning, and it is exceedingly plausible, because remember that weights are supposed to be synapses? And synapses in actual neurons also would have no way of knowing what goes on in the broader network. And so why the multiplication? Well, here comes the reason I called it the binary states, minus one and plus one. If you map out all four combinations of states of the neurons, you'll see that the weight will have positive sign whenever the neurons in their memory state agree and negative if they disagree. And this should make sense, because a positive weight lets a neuron project its state onto other neurons, and a negative weight lets a neuron flip the state of other neurons. It's almost like the neurons behave like charged particles, maybe. One last question before we can see it in action, and that's how do we store multiple patterns at once in the same network? We do it by computing the outer products for all desired memory patterns, this gives us a matrix for each, and then we average those matrices. This gives finer and finer gradations of the weights. Now, however, things start to become a little bit more complicated. There's no way to guarantee that all memory patterns are stable states. The memories will start talking to each other, fusing into new memories, which I find frustrating and super interesting at the same time. Here's the network with four memories again. It sometimes converges to one of the memory states, yes, but in other cases, it converges to something in between, a merging of memories, which I find, well, almost a kind of human mistake. And with this, we are finally making some progress on our question from the very beginning of the video. How much memory do you have? Originally, we might have answered this by giving some number of bytes. But now the question presents itself very differently. It's more like, how many memory patterns can we store in a recurrent network of a given size, such that they are stable states of the network? And the answer is, at least for this model, not very many. The original paper showed that this model has only linear memory capacity. That's to say, the number of stable states grows as a linear function of the size of the network. Plus, there's a hidden assumption in this graph too, which is that all memory states are uncorrelated, which, for any set of pictures like this, is totally not the case. I tried my best picking out some not-so-correlated images to really show what this network can do, and the results are, well, see for yourself. Realistically, that means that this model is maybe too simple after all. And that's not surprising given all the violence we did to these networks with our many simplifications. But the goal of this video wasn't to convince you that this model can be used in any practical sense anyway. Although, in a follow-up video, I want to tell you what steps people took to make this model actually useful for deep neural networks. What I wanted to achieve with this video is, first, to warn you of false comparisons. Networks of neurons don't behave like USB sticks, and why should they? But secondly, it's to show you how with modeling approaches, walking a very thin line between complexity and simplicity, we can sometimes start to conceive of the world differently than otherwise we would have. You might have set out picturing memory as something static, but I'm hoping now you're willing to consider that it might be something dynamic, the invisible, stable states of a network buzzing with activity.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 6.88, "text": " The amount of random access memory, RAM, in a typical laptop is probably around 8 to 32GB.", "tokens": [50364, 440, 2372, 295, 4974, 2105, 4675, 11, 14561, 11, 294, 257, 7476, 10732, 307, 1391, 926, 1649, 281, 8858, 8769, 13, 50708], "temperature": 0.0, "avg_logprob": -0.15124156258322977, "compression_ratio": 1.5118110236220472, "no_speech_prob": 0.0025499213952571154}, {"id": 1, "seek": 0, "start": 6.88, "end": 12.0, "text": " That's the part that directly interacts with the CPU. Aside from that, your hard disk might have,", "tokens": [50708, 663, 311, 264, 644, 300, 3838, 43582, 365, 264, 13199, 13, 33726, 490, 300, 11, 428, 1152, 12355, 1062, 362, 11, 50964], "temperature": 0.0, "avg_logprob": -0.15124156258322977, "compression_ratio": 1.5118110236220472, "no_speech_prob": 0.0025499213952571154}, {"id": 2, "seek": 0, "start": 12.0, "end": 18.48, "text": " say, another terabyte or so of memory. But how much memory do you, that's to say, the human brain", "tokens": [50964, 584, 11, 1071, 1796, 34529, 420, 370, 295, 4675, 13, 583, 577, 709, 4675, 360, 291, 11, 300, 311, 281, 584, 11, 264, 1952, 3567, 51288], "temperature": 0.0, "avg_logprob": -0.15124156258322977, "compression_ratio": 1.5118110236220472, "no_speech_prob": 0.0025499213952571154}, {"id": 3, "seek": 0, "start": 18.48, "end": 24.32, "text": " have? And can we even measure it in bytes? But maybe that's not even the first question we should", "tokens": [51288, 362, 30, 400, 393, 321, 754, 3481, 309, 294, 36088, 30, 583, 1310, 300, 311, 406, 754, 264, 700, 1168, 321, 820, 51580], "temperature": 0.0, "avg_logprob": -0.15124156258322977, "compression_ratio": 1.5118110236220472, "no_speech_prob": 0.0025499213952571154}, {"id": 4, "seek": 2432, "start": 24.32, "end": 31.76, "text": " ask. However much memory the brain has, where is it? Because every piece of memory in a computer", "tokens": [50364, 1029, 13, 2908, 709, 4675, 264, 3567, 575, 11, 689, 307, 309, 30, 1436, 633, 2522, 295, 4675, 294, 257, 3820, 50736], "temperature": 0.0, "avg_logprob": -0.07575874538212032, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.04145026206970215}, {"id": 5, "seek": 2432, "start": 31.76, "end": 37.28, "text": " has a physical location. To access a piece of data in RAM, for example, you have to know the", "tokens": [50736, 575, 257, 4001, 4914, 13, 1407, 2105, 257, 2522, 295, 1412, 294, 14561, 11, 337, 1365, 11, 291, 362, 281, 458, 264, 51012], "temperature": 0.0, "avg_logprob": -0.07575874538212032, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.04145026206970215}, {"id": 6, "seek": 2432, "start": 37.28, "end": 42.8, "text": " binary address associated with that location. In fact, for the CPU, this really comes down to", "tokens": [51012, 17434, 2985, 6615, 365, 300, 4914, 13, 682, 1186, 11, 337, 264, 13199, 11, 341, 534, 1487, 760, 281, 51288], "temperature": 0.0, "avg_logprob": -0.07575874538212032, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.04145026206970215}, {"id": 7, "seek": 2432, "start": 42.8, "end": 48.72, "text": " turning on just the right wires to retrieve the bits at the desired location. Now imagine a different", "tokens": [51288, 6246, 322, 445, 264, 558, 15537, 281, 30254, 264, 9239, 412, 264, 14721, 4914, 13, 823, 3811, 257, 819, 51584], "temperature": 0.0, "avg_logprob": -0.07575874538212032, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.04145026206970215}, {"id": 8, "seek": 4872, "start": 48.72, "end": 54.96, "text": " kind of memory. Instead of specifying the where of a memory, its binary address, how about we could", "tokens": [50364, 733, 295, 4675, 13, 7156, 295, 1608, 5489, 264, 689, 295, 257, 4675, 11, 1080, 17434, 2985, 11, 577, 466, 321, 727, 50676], "temperature": 0.0, "avg_logprob": -0.0793873452648674, "compression_ratio": 1.6540084388185654, "no_speech_prob": 0.08266779035329819}, {"id": 9, "seek": 4872, "start": 54.96, "end": 62.4, "text": " specify the what? Its content. A memory system, where if we provide an incomplete version of the", "tokens": [50676, 16500, 264, 437, 30, 6953, 2701, 13, 316, 4675, 1185, 11, 689, 498, 321, 2893, 364, 31709, 3037, 295, 264, 51048], "temperature": 0.0, "avg_logprob": -0.0793873452648674, "compression_ratio": 1.6540084388185654, "no_speech_prob": 0.08266779035329819}, {"id": 10, "seek": 4872, "start": 62.4, "end": 68.32, "text": " memory, it just sort of autocompletes. Of course, with the right software, your computer can already", "tokens": [51048, 4675, 11, 309, 445, 1333, 295, 45833, 298, 14657, 279, 13, 2720, 1164, 11, 365, 264, 558, 4722, 11, 428, 3820, 393, 1217, 51344], "temperature": 0.0, "avg_logprob": -0.0793873452648674, "compression_ratio": 1.6540084388185654, "no_speech_prob": 0.08266779035329819}, {"id": 11, "seek": 4872, "start": 68.32, "end": 73.84, "text": " do this. But it's not how computer memory works on its basic level. The point of this video is", "tokens": [51344, 360, 341, 13, 583, 309, 311, 406, 577, 3820, 4675, 1985, 322, 1080, 3875, 1496, 13, 440, 935, 295, 341, 960, 307, 51620], "temperature": 0.0, "avg_logprob": -0.0793873452648674, "compression_ratio": 1.6540084388185654, "no_speech_prob": 0.08266779035329819}, {"id": 12, "seek": 7384, "start": 73.84, "end": 79.68, "text": " to convince you that autocompleting memories, also known as associative memory, is a kind of", "tokens": [50364, 281, 13447, 291, 300, 45833, 298, 564, 9880, 8495, 11, 611, 2570, 382, 4180, 1166, 4675, 11, 307, 257, 733, 295, 50656], "temperature": 0.0, "avg_logprob": -0.0788112296614536, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.013221618719398975}, {"id": 13, "seek": 7384, "start": 79.68, "end": 84.80000000000001, "text": " natural behavior of networks of neurons. With that, it'll become clear that it doesn't really", "tokens": [50656, 3303, 5223, 295, 9590, 295, 22027, 13, 2022, 300, 11, 309, 603, 1813, 1850, 300, 309, 1177, 380, 534, 50912], "temperature": 0.0, "avg_logprob": -0.0788112296614536, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.013221618719398975}, {"id": 14, "seek": 7384, "start": 84.80000000000001, "end": 89.92, "text": " make sense to measure memory capacity in networks of neurons in the same way we measure computer", "tokens": [50912, 652, 2020, 281, 3481, 4675, 6042, 294, 9590, 295, 22027, 294, 264, 912, 636, 321, 3481, 3820, 51168], "temperature": 0.0, "avg_logprob": -0.0788112296614536, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.013221618719398975}, {"id": 15, "seek": 7384, "start": 89.92, "end": 95.52000000000001, "text": " memory. The biggest difference might be computer memories have a place, a fixed location, but as", "tokens": [51168, 4675, 13, 440, 3880, 2649, 1062, 312, 3820, 8495, 362, 257, 1081, 11, 257, 6806, 4914, 11, 457, 382, 51448], "temperature": 0.0, "avg_logprob": -0.0788112296614536, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.013221618719398975}, {"id": 16, "seek": 9552, "start": 95.52, "end": 99.36, "text": " we'll see, the memories in an associative network rather have a time.", "tokens": [50364, 321, 603, 536, 11, 264, 8495, 294, 364, 4180, 1166, 3209, 2831, 362, 257, 565, 13, 50556], "temperature": 0.0, "avg_logprob": -0.09743754456682903, "compression_ratio": 1.5398230088495575, "no_speech_prob": 0.00010554640903137624}, {"id": 17, "seek": 9552, "start": 106.88, "end": 112.08, "text": " Computer memory is measured in bits, binary switches of ones and zeros. A string of eight", "tokens": [50932, 22289, 4675, 307, 12690, 294, 9239, 11, 17434, 19458, 295, 2306, 293, 35193, 13, 316, 6798, 295, 3180, 51192], "temperature": 0.0, "avg_logprob": -0.09743754456682903, "compression_ratio": 1.5398230088495575, "no_speech_prob": 0.00010554640903137624}, {"id": 18, "seek": 9552, "start": 112.08, "end": 118.16, "text": " such bits can represent anything from letters to integers. For our purposes, let's visualize them", "tokens": [51192, 1270, 9239, 393, 2906, 1340, 490, 7825, 281, 41674, 13, 1171, 527, 9932, 11, 718, 311, 23273, 552, 51496], "temperature": 0.0, "avg_logprob": -0.09743754456682903, "compression_ratio": 1.5398230088495575, "no_speech_prob": 0.00010554640903137624}, {"id": 19, "seek": 9552, "start": 118.16, "end": 124.24, "text": " as patterns of this kind, like these 64 bits representing this 8x8 image of binary pixels.", "tokens": [51496, 382, 8294, 295, 341, 733, 11, 411, 613, 12145, 9239, 13460, 341, 1649, 87, 23, 3256, 295, 17434, 18668, 13, 51800], "temperature": 0.0, "avg_logprob": -0.09743754456682903, "compression_ratio": 1.5398230088495575, "no_speech_prob": 0.00010554640903137624}, {"id": 20, "seek": 12424, "start": 125.19999999999999, "end": 128.96, "text": " I always find that there's a piece missing from the story of bits as memory,", "tokens": [50412, 286, 1009, 915, 300, 456, 311, 257, 2522, 5361, 490, 264, 1657, 295, 9239, 382, 4675, 11, 50600], "temperature": 0.0, "avg_logprob": -0.0696798324584961, "compression_ratio": 1.6179775280898876, "no_speech_prob": 0.0015011364594101906}, {"id": 21, "seek": 12424, "start": 128.96, "end": 134.88, "text": " and that's the following. How do I get to a memory once it's saved, say, in RAM? Because", "tokens": [50600, 293, 300, 311, 264, 3480, 13, 1012, 360, 286, 483, 281, 257, 4675, 1564, 309, 311, 6624, 11, 584, 11, 294, 14561, 30, 1436, 50896], "temperature": 0.0, "avg_logprob": -0.0696798324584961, "compression_ratio": 1.6179775280898876, "no_speech_prob": 0.0015011364594101906}, {"id": 22, "seek": 12424, "start": 134.88, "end": 140.64, "text": " on its own, it doesn't do much. It's only when we retrieve it that it becomes useful.", "tokens": [50896, 322, 1080, 1065, 11, 309, 1177, 380, 360, 709, 13, 467, 311, 787, 562, 321, 30254, 309, 300, 309, 3643, 4420, 13, 51184], "temperature": 0.0, "avg_logprob": -0.0696798324584961, "compression_ratio": 1.6179775280898876, "no_speech_prob": 0.0015011364594101906}, {"id": 23, "seek": 12424, "start": 141.35999999999999, "end": 146.4, "text": " So how do we? Well, broadly speaking, and I'm glossing over tons of technical detail here,", "tokens": [51220, 407, 577, 360, 321, 30, 1042, 11, 19511, 4124, 11, 293, 286, 478, 19574, 278, 670, 9131, 295, 6191, 2607, 510, 11, 51472], "temperature": 0.0, "avg_logprob": -0.0696798324584961, "compression_ratio": 1.6179775280898876, "no_speech_prob": 0.0015011364594101906}, {"id": 24, "seek": 12424, "start": 146.4, "end": 152.24, "text": " every piece of data in RAM is matched to a binary address. And this binary address really", "tokens": [51472, 633, 2522, 295, 1412, 294, 14561, 307, 21447, 281, 257, 17434, 2985, 13, 400, 341, 17434, 2985, 534, 51764], "temperature": 0.0, "avg_logprob": -0.0696798324584961, "compression_ratio": 1.6179775280898876, "no_speech_prob": 0.0015011364594101906}, {"id": 25, "seek": 15224, "start": 152.24, "end": 157.60000000000002, "text": " eventually boils down to a set of wires, in this case eight, that are either turned on or off.", "tokens": [50364, 4728, 35049, 760, 281, 257, 992, 295, 15537, 11, 294, 341, 1389, 3180, 11, 300, 366, 2139, 3574, 322, 420, 766, 13, 50632], "temperature": 0.0, "avg_logprob": -0.05889998100422047, "compression_ratio": 1.6832740213523132, "no_speech_prob": 0.0008830264559946954}, {"id": 26, "seek": 15224, "start": 158.16, "end": 163.12, "text": " Each piece of data is in a different physical location, and can only be retrieved by knowing", "tokens": [50660, 6947, 2522, 295, 1412, 307, 294, 257, 819, 4001, 4914, 11, 293, 393, 787, 312, 19817, 937, 538, 5276, 50908], "temperature": 0.0, "avg_logprob": -0.05889998100422047, "compression_ratio": 1.6832740213523132, "no_speech_prob": 0.0008830264559946954}, {"id": 27, "seek": 15224, "start": 163.12, "end": 168.08, "text": " its address. How the reading and writing of memories is accomplished is really the meat of", "tokens": [50908, 1080, 2985, 13, 1012, 264, 3760, 293, 3579, 295, 8495, 307, 15419, 307, 534, 264, 4615, 295, 51156], "temperature": 0.0, "avg_logprob": -0.05889998100422047, "compression_ratio": 1.6832740213523132, "no_speech_prob": 0.0008830264559946954}, {"id": 28, "seek": 15224, "start": 168.08, "end": 173.84, "text": " programming and is another story. What I want you to remember is the peculiar fact that memories", "tokens": [51156, 9410, 293, 307, 1071, 1657, 13, 708, 286, 528, 291, 281, 1604, 307, 264, 27149, 1186, 300, 8495, 51444], "temperature": 0.0, "avg_logprob": -0.05889998100422047, "compression_ratio": 1.6832740213523132, "no_speech_prob": 0.0008830264559946954}, {"id": 29, "seek": 15224, "start": 173.84, "end": 179.60000000000002, "text": " are matched to addresses, and that's ultimately the only way to retrieve them. Contrast this with", "tokens": [51444, 366, 21447, 281, 16862, 11, 293, 300, 311, 6284, 264, 787, 636, 281, 30254, 552, 13, 4839, 4148, 341, 365, 51732], "temperature": 0.0, "avg_logprob": -0.05889998100422047, "compression_ratio": 1.6832740213523132, "no_speech_prob": 0.0008830264559946954}, {"id": 30, "seek": 17960, "start": 179.6, "end": 184.88, "text": " what we believe about the brain. There isn't a central orchestrator, like a CPU, and there aren't", "tokens": [50364, 437, 321, 1697, 466, 264, 3567, 13, 821, 1943, 380, 257, 5777, 14161, 19802, 11, 411, 257, 13199, 11, 293, 456, 3212, 380, 50628], "temperature": 0.0, "avg_logprob": -0.06261497133233573, "compression_ratio": 1.6074380165289257, "no_speech_prob": 0.005910573527216911}, {"id": 31, "seek": 17960, "start": 184.88, "end": 192.0, "text": " any addresses. Rather, there is a constant buzz of activity of many independent units called neurons.", "tokens": [50628, 604, 16862, 13, 16571, 11, 456, 307, 257, 5754, 13036, 295, 5191, 295, 867, 6695, 6815, 1219, 22027, 13, 50984], "temperature": 0.0, "avg_logprob": -0.06261497133233573, "compression_ratio": 1.6074380165289257, "no_speech_prob": 0.005910573527216911}, {"id": 32, "seek": 17960, "start": 192.0, "end": 197.28, "text": " In this video, we'll try to make some sense of the buzzing of activity of networks of neurons", "tokens": [50984, 682, 341, 960, 11, 321, 603, 853, 281, 652, 512, 2020, 295, 264, 29659, 295, 5191, 295, 9590, 295, 22027, 51248], "temperature": 0.0, "avg_logprob": -0.06261497133233573, "compression_ratio": 1.6074380165289257, "no_speech_prob": 0.005910573527216911}, {"id": 33, "seek": 17960, "start": 197.28, "end": 203.51999999999998, "text": " by introducing a mathematical model called the Hopfield Network, named after the author of this", "tokens": [51248, 538, 15424, 257, 18894, 2316, 1219, 264, 13438, 7610, 12640, 11, 4926, 934, 264, 3793, 295, 341, 51560], "temperature": 0.0, "avg_logprob": -0.06261497133233573, "compression_ratio": 1.6074380165289257, "no_speech_prob": 0.005910573527216911}, {"id": 34, "seek": 20352, "start": 203.60000000000002, "end": 209.36, "text": " 1982 paper. And as much as this has to do with memory, more generally, this video aims to be a", "tokens": [50368, 31352, 3035, 13, 400, 382, 709, 382, 341, 575, 281, 360, 365, 4675, 11, 544, 5101, 11, 341, 960, 24683, 281, 312, 257, 50656], "temperature": 0.0, "avg_logprob": -0.0764248972353728, "compression_ratio": 1.6394557823129252, "no_speech_prob": 0.011686108075082302}, {"id": 35, "seek": 20352, "start": 209.36, "end": 216.64000000000001, "text": " lesson in modeling itself, which I always think of as the art of the essential. This is a neuron.", "tokens": [50656, 6898, 294, 15983, 2564, 11, 597, 286, 1009, 519, 295, 382, 264, 1523, 295, 264, 7115, 13, 639, 307, 257, 34090, 13, 51020], "temperature": 0.0, "avg_logprob": -0.0764248972353728, "compression_ratio": 1.6394557823129252, "no_speech_prob": 0.011686108075082302}, {"id": 36, "seek": 20352, "start": 216.64000000000001, "end": 220.88, "text": " I'm almost certain you've seen something like this before, but it sometimes pays to remember", "tokens": [51020, 286, 478, 1920, 1629, 291, 600, 1612, 746, 411, 341, 949, 11, 457, 309, 2171, 10604, 281, 1604, 51232], "temperature": 0.0, "avg_logprob": -0.0764248972353728, "compression_ratio": 1.6394557823129252, "no_speech_prob": 0.011686108075082302}, {"id": 37, "seek": 20352, "start": 220.88, "end": 225.68, "text": " why we always come back to this when we want to understand things about the brain. The reason is,", "tokens": [51232, 983, 321, 1009, 808, 646, 281, 341, 562, 321, 528, 281, 1223, 721, 466, 264, 3567, 13, 440, 1778, 307, 11, 51472], "temperature": 0.0, "avg_logprob": -0.0764248972353728, "compression_ratio": 1.6394557823129252, "no_speech_prob": 0.011686108075082302}, {"id": 38, "seek": 20352, "start": 225.68, "end": 231.52, "text": " I think, that it has a rather simple behavior. It integrates electrical signals from other neurons", "tokens": [51472, 286, 519, 11, 300, 309, 575, 257, 2831, 2199, 5223, 13, 467, 3572, 1024, 12147, 12354, 490, 661, 22027, 51764], "temperature": 0.0, "avg_logprob": -0.0764248972353728, "compression_ratio": 1.6394557823129252, "no_speech_prob": 0.011686108075082302}, {"id": 39, "seek": 23152, "start": 231.52, "end": 236.24, "text": " to determine its own activity, and then it broadcasts that activity back to the network.", "tokens": [50364, 281, 6997, 1080, 1065, 5191, 11, 293, 550, 309, 9975, 82, 300, 5191, 646, 281, 264, 3209, 13, 50600], "temperature": 0.0, "avg_logprob": -0.06289894208995574, "compression_ratio": 1.7320754716981133, "no_speech_prob": 0.004331248812377453}, {"id": 40, "seek": 23152, "start": 236.88000000000002, "end": 241.52, "text": " Mathematically, the story goes something like this. There's electrical signals coming in from", "tokens": [50632, 15776, 40197, 11, 264, 1657, 1709, 746, 411, 341, 13, 821, 311, 12147, 12354, 1348, 294, 490, 50864], "temperature": 0.0, "avg_logprob": -0.06289894208995574, "compression_ratio": 1.7320754716981133, "no_speech_prob": 0.004331248812377453}, {"id": 41, "seek": 23152, "start": 241.52, "end": 247.12, "text": " other neurons, which we will say are just some numbers. Then the synapses act as multipliers", "tokens": [50864, 661, 22027, 11, 597, 321, 486, 584, 366, 445, 512, 3547, 13, 1396, 264, 5451, 2382, 279, 605, 382, 12788, 4890, 51144], "temperature": 0.0, "avg_logprob": -0.06289894208995574, "compression_ratio": 1.7320754716981133, "no_speech_prob": 0.004331248812377453}, {"id": 42, "seek": 23152, "start": 247.12, "end": 252.8, "text": " on these signals, another set of numbers. And then the activity of the neuron is based on the sum", "tokens": [51144, 322, 613, 12354, 11, 1071, 992, 295, 3547, 13, 400, 550, 264, 5191, 295, 264, 34090, 307, 2361, 322, 264, 2408, 51428], "temperature": 0.0, "avg_logprob": -0.06289894208995574, "compression_ratio": 1.7320754716981133, "no_speech_prob": 0.004331248812377453}, {"id": 43, "seek": 23152, "start": 252.8, "end": 258.40000000000003, "text": " of the weighted inputs. And by based on, I mean that it's fine to apply some function", "tokens": [51428, 295, 264, 32807, 15743, 13, 400, 538, 2361, 322, 11, 286, 914, 300, 309, 311, 2489, 281, 3079, 512, 2445, 51708], "temperature": 0.0, "avg_logprob": -0.06289894208995574, "compression_ratio": 1.7320754716981133, "no_speech_prob": 0.004331248812377453}, {"id": 44, "seek": 25840, "start": 258.4, "end": 263.52, "text": " after computing the sum. And that's it. So it gets interesting once we turn this into a network,", "tokens": [50364, 934, 15866, 264, 2408, 13, 400, 300, 311, 309, 13, 407, 309, 2170, 1880, 1564, 321, 1261, 341, 666, 257, 3209, 11, 50620], "temperature": 0.0, "avg_logprob": -0.048380942180238924, "compression_ratio": 1.7745454545454546, "no_speech_prob": 0.002251701196655631}, {"id": 45, "seek": 25840, "start": 263.52, "end": 268.71999999999997, "text": " connecting the outputs of neurons to the inputs of other neurons. This is a special type of neural", "tokens": [50620, 11015, 264, 23930, 295, 22027, 281, 264, 15743, 295, 661, 22027, 13, 639, 307, 257, 2121, 2010, 295, 18161, 50880], "temperature": 0.0, "avg_logprob": -0.048380942180238924, "compression_ratio": 1.7745454545454546, "no_speech_prob": 0.002251701196655631}, {"id": 46, "seek": 25840, "start": 268.71999999999997, "end": 273.52, "text": " network. It's a recurrent network, meaning that there are back and forth connections between the", "tokens": [50880, 3209, 13, 467, 311, 257, 18680, 1753, 3209, 11, 3620, 300, 456, 366, 646, 293, 5220, 9271, 1296, 264, 51120], "temperature": 0.0, "avg_logprob": -0.048380942180238924, "compression_ratio": 1.7745454545454546, "no_speech_prob": 0.002251701196655631}, {"id": 47, "seek": 25840, "start": 273.52, "end": 279.52, "text": " neurons. I haven't drawn them, but remember that any such edge is actually two edges, so that the", "tokens": [51120, 22027, 13, 286, 2378, 380, 10117, 552, 11, 457, 1604, 300, 604, 1270, 4691, 307, 767, 732, 8819, 11, 370, 300, 264, 51420], "temperature": 0.0, "avg_logprob": -0.048380942180238924, "compression_ratio": 1.7745454545454546, "no_speech_prob": 0.002251701196655631}, {"id": 48, "seek": 25840, "start": 279.52, "end": 286.56, "text": " two neurons influence each other. Okay, there's details here that we need to get into. But first,", "tokens": [51420, 732, 22027, 6503, 1184, 661, 13, 1033, 11, 456, 311, 4365, 510, 300, 321, 643, 281, 483, 666, 13, 583, 700, 11, 51772], "temperature": 0.0, "avg_logprob": -0.048380942180238924, "compression_ratio": 1.7745454545454546, "no_speech_prob": 0.002251701196655631}, {"id": 49, "seek": 28656, "start": 286.56, "end": 291.2, "text": " what does this have to do with memory? Well, it needs to be somewhere in here, doesn't it?", "tokens": [50364, 437, 775, 341, 362, 281, 360, 365, 4675, 30, 1042, 11, 309, 2203, 281, 312, 4079, 294, 510, 11, 1177, 380, 309, 30, 50596], "temperature": 0.0, "avg_logprob": -0.062068454424540204, "compression_ratio": 1.7112676056338028, "no_speech_prob": 0.000883025408256799}, {"id": 50, "seek": 28656, "start": 291.76, "end": 297.52, "text": " Where? Remember the idea of an associative memory, which is the ability of a system to sort of pattern", "tokens": [50624, 2305, 30, 5459, 264, 1558, 295, 364, 4180, 1166, 4675, 11, 597, 307, 264, 3485, 295, 257, 1185, 281, 1333, 295, 5102, 50912], "temperature": 0.0, "avg_logprob": -0.062068454424540204, "compression_ratio": 1.7112676056338028, "no_speech_prob": 0.000883025408256799}, {"id": 51, "seek": 28656, "start": 297.52, "end": 303.12, "text": " autocomplete? Let's try a definition of memory that's slightly wider than maybe what we're used to.", "tokens": [50912, 45833, 298, 17220, 30, 961, 311, 853, 257, 7123, 295, 4675, 300, 311, 4748, 11842, 813, 1310, 437, 321, 434, 1143, 281, 13, 51192], "temperature": 0.0, "avg_logprob": -0.062068454424540204, "compression_ratio": 1.7112676056338028, "no_speech_prob": 0.000883025408256799}, {"id": 52, "seek": 28656, "start": 303.12, "end": 308.08, "text": " Let a memory system be a system, that after having been in a certain state, a configuration,", "tokens": [51192, 961, 257, 4675, 1185, 312, 257, 1185, 11, 300, 934, 1419, 668, 294, 257, 1629, 1785, 11, 257, 11694, 11, 51440], "temperature": 0.0, "avg_logprob": -0.062068454424540204, "compression_ratio": 1.7112676056338028, "no_speech_prob": 0.000883025408256799}, {"id": 53, "seek": 28656, "start": 308.08, "end": 314.4, "text": " it has the ability to return to that state later on. Now, our computer memory from earlier actually", "tokens": [51440, 309, 575, 264, 3485, 281, 2736, 281, 300, 1785, 1780, 322, 13, 823, 11, 527, 3820, 4675, 490, 3071, 767, 51756], "temperature": 0.0, "avg_logprob": -0.062068454424540204, "compression_ratio": 1.7112676056338028, "no_speech_prob": 0.000883025408256799}, {"id": 54, "seek": 31440, "start": 314.4, "end": 320.71999999999997, "text": " has this property, if we include the CPU into the memory system. Our network seems different, though.", "tokens": [50364, 575, 341, 4707, 11, 498, 321, 4090, 264, 13199, 666, 264, 4675, 1185, 13, 2621, 3209, 2544, 819, 11, 1673, 13, 50680], "temperature": 0.0, "avg_logprob": -0.05718677655785485, "compression_ratio": 1.5919732441471572, "no_speech_prob": 0.0012065712362527847}, {"id": 55, "seek": 31440, "start": 321.28, "end": 326.4, "text": " So let's get creative. There's other things in our everyday lives that fall under our definition", "tokens": [50708, 407, 718, 311, 483, 5880, 13, 821, 311, 661, 721, 294, 527, 7429, 2909, 300, 2100, 833, 527, 7123, 50964], "temperature": 0.0, "avg_logprob": -0.05718677655785485, "compression_ratio": 1.5919732441471572, "no_speech_prob": 0.0012065712362527847}, {"id": 56, "seek": 31440, "start": 326.4, "end": 332.56, "text": " of memory. And one might be, and hear me out on this, a simple plastic bottle. If it's crushed,", "tokens": [50964, 295, 4675, 13, 400, 472, 1062, 312, 11, 293, 1568, 385, 484, 322, 341, 11, 257, 2199, 5900, 7817, 13, 759, 309, 311, 19889, 11, 51272], "temperature": 0.0, "avg_logprob": -0.05718677655785485, "compression_ratio": 1.5919732441471572, "no_speech_prob": 0.0012065712362527847}, {"id": 57, "seek": 31440, "start": 332.56, "end": 337.52, "text": " in other words, its configuration changed, it can sometimes return to its earlier state,", "tokens": [51272, 294, 661, 2283, 11, 1080, 11694, 3105, 11, 309, 393, 2171, 2736, 281, 1080, 3071, 1785, 11, 51520], "temperature": 0.0, "avg_logprob": -0.05718677655785485, "compression_ratio": 1.5919732441471572, "no_speech_prob": 0.0012065712362527847}, {"id": 58, "seek": 31440, "start": 337.52, "end": 342.4, "text": " which in that sense could be said to have been memorized. And the metaphor is not arbitrary.", "tokens": [51520, 597, 294, 300, 2020, 727, 312, 848, 281, 362, 668, 46677, 13, 400, 264, 19157, 307, 406, 23211, 13, 51764], "temperature": 0.0, "avg_logprob": -0.05718677655785485, "compression_ratio": 1.5919732441471572, "no_speech_prob": 0.0012065712362527847}, {"id": 59, "seek": 34240, "start": 342.4, "end": 348.23999999999995, "text": " I actually do think that networks of neurons are kind of like that. What I mean is a neural network", "tokens": [50364, 286, 767, 360, 519, 300, 9590, 295, 22027, 366, 733, 295, 411, 300, 13, 708, 286, 914, 307, 257, 18161, 3209, 50656], "temperature": 0.0, "avg_logprob": -0.05773878556031447, "compression_ratio": 1.7604562737642586, "no_speech_prob": 0.0004728483909275383}, {"id": 60, "seek": 34240, "start": 348.23999999999995, "end": 353.84, "text": " is a system with a pattern of activity that dynamically evolves. If somehow we could construct", "tokens": [50656, 307, 257, 1185, 365, 257, 5102, 295, 5191, 300, 43492, 43737, 13, 759, 6063, 321, 727, 7690, 50936], "temperature": 0.0, "avg_logprob": -0.05773878556031447, "compression_ratio": 1.7604562737642586, "no_speech_prob": 0.0004728483909275383}, {"id": 61, "seek": 34240, "start": 353.84, "end": 359.28, "text": " our network such that it would have some preferred state and would return to that state over time,", "tokens": [50936, 527, 3209, 1270, 300, 309, 576, 362, 512, 16494, 1785, 293, 576, 2736, 281, 300, 1785, 670, 565, 11, 51208], "temperature": 0.0, "avg_logprob": -0.05773878556031447, "compression_ratio": 1.7604562737642586, "no_speech_prob": 0.0004728483909275383}, {"id": 62, "seek": 34240, "start": 359.28, "end": 363.59999999999997, "text": " if it was perturbed, then that could reasonably be qualified as a memory.", "tokens": [51208, 498, 309, 390, 13269, 374, 2883, 11, 550, 300, 727, 23551, 312, 15904, 382, 257, 4675, 13, 51424], "temperature": 0.0, "avg_logprob": -0.05773878556031447, "compression_ratio": 1.7604562737642586, "no_speech_prob": 0.0004728483909275383}, {"id": 63, "seek": 34240, "start": 364.96, "end": 370.71999999999997, "text": " This is a network of 64 neurons that I cleverly constructed such that it memorized this pattern", "tokens": [51492, 639, 307, 257, 3209, 295, 12145, 22027, 300, 286, 13494, 356, 17083, 1270, 300, 309, 46677, 341, 5102, 51780], "temperature": 0.0, "avg_logprob": -0.05773878556031447, "compression_ratio": 1.7604562737642586, "no_speech_prob": 0.0004728483909275383}, {"id": 64, "seek": 37072, "start": 370.72, "end": 376.88000000000005, "text": " of 8x8 binary pixels. So what's going on? To describe what this model is actually doing,", "tokens": [50364, 295, 1649, 87, 23, 17434, 18668, 13, 407, 437, 311, 516, 322, 30, 1407, 6786, 437, 341, 2316, 307, 767, 884, 11, 50672], "temperature": 0.0, "avg_logprob": -0.06368521527127102, "compression_ratio": 1.6843971631205674, "no_speech_prob": 0.0006461873999796808}, {"id": 65, "seek": 37072, "start": 376.88000000000005, "end": 381.92, "text": " we need to take the following steps. Remember I said time was important? We need to describe how", "tokens": [50672, 321, 643, 281, 747, 264, 3480, 4439, 13, 5459, 286, 848, 565, 390, 1021, 30, 492, 643, 281, 6786, 577, 50924], "temperature": 0.0, "avg_logprob": -0.06368521527127102, "compression_ratio": 1.6843971631205674, "no_speech_prob": 0.0006461873999796808}, {"id": 66, "seek": 37072, "start": 381.92, "end": 387.12, "text": " the activity of the network changes over time. And then there's the question of learning. How do", "tokens": [50924, 264, 5191, 295, 264, 3209, 2962, 670, 565, 13, 400, 550, 456, 311, 264, 1168, 295, 2539, 13, 1012, 360, 51184], "temperature": 0.0, "avg_logprob": -0.06368521527127102, "compression_ratio": 1.6843971631205674, "no_speech_prob": 0.0006461873999796808}, {"id": 67, "seek": 37072, "start": 387.12, "end": 392.08000000000004, "text": " we actually imprint memories into the network? And this will have to do with the connections", "tokens": [51184, 321, 767, 44615, 8495, 666, 264, 3209, 30, 400, 341, 486, 362, 281, 360, 365, 264, 9271, 51432], "temperature": 0.0, "avg_logprob": -0.06368521527127102, "compression_ratio": 1.6843971631205674, "no_speech_prob": 0.0006461873999796808}, {"id": 68, "seek": 37072, "start": 392.08000000000004, "end": 397.28000000000003, "text": " between the neurons. Finally, we need to understand if and when the network converges to its memory", "tokens": [51432, 1296, 264, 22027, 13, 6288, 11, 321, 643, 281, 1223, 498, 293, 562, 264, 3209, 9652, 2880, 281, 1080, 4675, 51692], "temperature": 0.0, "avg_logprob": -0.06368521527127102, "compression_ratio": 1.6843971631205674, "no_speech_prob": 0.0006461873999796808}, {"id": 69, "seek": 39728, "start": 397.28, "end": 404.0, "text": " states. The crucial ingredient of our network really is the fact that it is a dynamical system.", "tokens": [50364, 4368, 13, 440, 11462, 14751, 295, 527, 3209, 534, 307, 264, 1186, 300, 309, 307, 257, 5999, 804, 1185, 13, 50700], "temperature": 0.0, "avg_logprob": -0.0687229934780077, "compression_ratio": 1.5798319327731092, "no_speech_prob": 0.00047284929314628243}, {"id": 70, "seek": 39728, "start": 404.0, "end": 410.08, "text": " Its activity changes over time. By activity, we mean that each of the now 16 neurons in the", "tokens": [50700, 6953, 5191, 2962, 670, 565, 13, 3146, 5191, 11, 321, 914, 300, 1184, 295, 264, 586, 3165, 22027, 294, 264, 51004], "temperature": 0.0, "avg_logprob": -0.0687229934780077, "compression_ratio": 1.5798319327731092, "no_speech_prob": 0.00047284929314628243}, {"id": 71, "seek": 39728, "start": 410.08, "end": 415.76, "text": " network is described by a number and that this number is a function of time. And let's just", "tokens": [51004, 3209, 307, 7619, 538, 257, 1230, 293, 300, 341, 1230, 307, 257, 2445, 295, 565, 13, 400, 718, 311, 445, 51288], "temperature": 0.0, "avg_logprob": -0.0687229934780077, "compression_ratio": 1.5798319327731092, "no_speech_prob": 0.00047284929314628243}, {"id": 72, "seek": 39728, "start": 415.76, "end": 421.35999999999996, "text": " assume that time moves forward in discrete steps. Furthermore, since we are interested in binary", "tokens": [51288, 6552, 300, 565, 6067, 2128, 294, 27706, 4439, 13, 23999, 11, 1670, 321, 366, 3102, 294, 17434, 51568], "temperature": 0.0, "avg_logprob": -0.0687229934780077, "compression_ratio": 1.5798319327731092, "no_speech_prob": 0.00047284929314628243}, {"id": 73, "seek": 42136, "start": 421.36, "end": 427.28000000000003, "text": " memory states, we will assume that activity means that the neurons can only be in one of two states,", "tokens": [50364, 4675, 4368, 11, 321, 486, 6552, 300, 5191, 1355, 300, 264, 22027, 393, 787, 312, 294, 472, 295, 732, 4368, 11, 50660], "temperature": 0.0, "avg_logprob": -0.09294513903166118, "compression_ratio": 1.6609442060085837, "no_speech_prob": 0.0027149466332048178}, {"id": 74, "seek": 42136, "start": 427.28000000000003, "end": 434.88, "text": " inactive, say minus one, and active, say plus one. Anyway, this all leaves us with 16 minus or", "tokens": [50660, 294, 12596, 11, 584, 3175, 472, 11, 293, 4967, 11, 584, 1804, 472, 13, 5684, 11, 341, 439, 5510, 505, 365, 3165, 3175, 420, 51040], "temperature": 0.0, "avg_logprob": -0.09294513903166118, "compression_ratio": 1.6609442060085837, "no_speech_prob": 0.0027149466332048178}, {"id": 75, "seek": 42136, "start": 434.88, "end": 442.56, "text": " plus ones at any given time, which we will call the state of the network. What actually happens", "tokens": [51040, 1804, 2306, 412, 604, 2212, 565, 11, 597, 321, 486, 818, 264, 1785, 295, 264, 3209, 13, 708, 767, 2314, 51424], "temperature": 0.0, "avg_logprob": -0.09294513903166118, "compression_ratio": 1.6609442060085837, "no_speech_prob": 0.0027149466332048178}, {"id": 76, "seek": 42136, "start": 442.56, "end": 449.44, "text": " if we increase time by one step? Imagine folding out the time dimension in space. Now we select", "tokens": [51424, 498, 321, 3488, 565, 538, 472, 1823, 30, 11739, 25335, 484, 264, 565, 10139, 294, 1901, 13, 823, 321, 3048, 51768], "temperature": 0.0, "avg_logprob": -0.09294513903166118, "compression_ratio": 1.6609442060085837, "no_speech_prob": 0.0027149466332048178}, {"id": 77, "seek": 44944, "start": 449.44, "end": 455.12, "text": " one of the neurons at random and update its state according to the input of all other neurons", "tokens": [50364, 472, 295, 264, 22027, 412, 4974, 293, 5623, 1080, 1785, 4650, 281, 264, 4846, 295, 439, 661, 22027, 50648], "temperature": 0.0, "avg_logprob": -0.07887284986434444, "compression_ratio": 1.7031963470319635, "no_speech_prob": 0.0005033275811001658}, {"id": 78, "seek": 44944, "start": 455.12, "end": 461.6, "text": " in the network. The rest of the neurons stay the same. And this we simply continue.", "tokens": [50648, 294, 264, 3209, 13, 440, 1472, 295, 264, 22027, 1754, 264, 912, 13, 400, 341, 321, 2935, 2354, 13, 50972], "temperature": 0.0, "avg_logprob": -0.07887284986434444, "compression_ratio": 1.7031963470319635, "no_speech_prob": 0.0005033275811001658}, {"id": 79, "seek": 44944, "start": 465.04, "end": 471.12, "text": " But hold on, you might ask. How do we update the state exactly? And why update only one neuron at", "tokens": [51144, 583, 1797, 322, 11, 291, 1062, 1029, 13, 1012, 360, 321, 5623, 264, 1785, 2293, 30, 400, 983, 5623, 787, 472, 34090, 412, 51448], "temperature": 0.0, "avg_logprob": -0.07887284986434444, "compression_ratio": 1.7031963470319635, "no_speech_prob": 0.0005033275811001658}, {"id": 80, "seek": 44944, "start": 471.12, "end": 476.88, "text": " a time? Well, for the second question, we could in fact update all neurons at once. But the issue", "tokens": [51448, 257, 565, 30, 1042, 11, 337, 264, 1150, 1168, 11, 321, 727, 294, 1186, 5623, 439, 22027, 412, 1564, 13, 583, 264, 2734, 51736], "temperature": 0.0, "avg_logprob": -0.07887284986434444, "compression_ratio": 1.7031963470319635, "no_speech_prob": 0.0005033275811001658}, {"id": 81, "seek": 47688, "start": 476.88, "end": 482.48, "text": " here is plausibility, because that would require a global updating signal, almost like a clock,", "tokens": [50364, 510, 307, 34946, 2841, 11, 570, 300, 576, 3651, 257, 4338, 25113, 6358, 11, 1920, 411, 257, 7830, 11, 50644], "temperature": 0.0, "avg_logprob": -0.06778431797886754, "compression_ratio": 1.7062937062937062, "no_speech_prob": 0.0012842814903706312}, {"id": 82, "seek": 47688, "start": 482.48, "end": 488.56, "text": " instructing all neurons to update simultaneously. It's slightly more realistic, although not too", "tokens": [50644, 7232, 278, 439, 22027, 281, 5623, 16561, 13, 467, 311, 4748, 544, 12465, 11, 4878, 406, 886, 50948], "temperature": 0.0, "avg_logprob": -0.06778431797886754, "compression_ratio": 1.7062937062937062, "no_speech_prob": 0.0012842814903706312}, {"id": 83, "seek": 47688, "start": 488.56, "end": 494.32, "text": " much to be honest, to let them update asynchronously. Okay, and for the other question, yes, what is the", "tokens": [50948, 709, 281, 312, 3245, 11, 281, 718, 552, 5623, 42642, 5098, 13, 1033, 11, 293, 337, 264, 661, 1168, 11, 2086, 11, 437, 307, 264, 51236], "temperature": 0.0, "avg_logprob": -0.06778431797886754, "compression_ratio": 1.7062937062937062, "no_speech_prob": 0.0012842814903706312}, {"id": 84, "seek": 47688, "start": 494.32, "end": 499.76, "text": " actual update equation? Well, it's remarkably simple. It's a weighted sum of the states of the", "tokens": [51236, 3539, 5623, 5367, 30, 1042, 11, 309, 311, 37381, 2199, 13, 467, 311, 257, 32807, 2408, 295, 264, 4368, 295, 264, 51508], "temperature": 0.0, "avg_logprob": -0.06778431797886754, "compression_ratio": 1.7062937062937062, "no_speech_prob": 0.0012842814903706312}, {"id": 85, "seek": 47688, "start": 499.76, "end": 505.36, "text": " other neurons. Weighted meaning that each state is multiplied by the strength of the connection", "tokens": [51508, 661, 22027, 13, 44464, 292, 3620, 300, 1184, 1785, 307, 17207, 538, 264, 3800, 295, 264, 4984, 51788], "temperature": 0.0, "avg_logprob": -0.06778431797886754, "compression_ratio": 1.7062937062937062, "no_speech_prob": 0.0012842814903706312}, {"id": 86, "seek": 50536, "start": 505.36, "end": 511.12, "text": " between the neurons. And since the connections, in that sense, weigh the inputs, from now on,", "tokens": [50364, 1296, 264, 22027, 13, 400, 1670, 264, 9271, 11, 294, 300, 2020, 11, 13843, 264, 15743, 11, 490, 586, 322, 11, 50652], "temperature": 0.0, "avg_logprob": -0.10355040291759456, "compression_ratio": 1.6940298507462686, "no_speech_prob": 0.01098611205816269}, {"id": 87, "seek": 50536, "start": 511.12, "end": 516.16, "text": " I'm actually going to call them weights. But then of course, to ensure that the result is plus one", "tokens": [50652, 286, 478, 767, 516, 281, 818, 552, 17443, 13, 583, 550, 295, 1164, 11, 281, 5586, 300, 264, 1874, 307, 1804, 472, 50904], "temperature": 0.0, "avg_logprob": -0.10355040291759456, "compression_ratio": 1.6940298507462686, "no_speech_prob": 0.01098611205816269}, {"id": 88, "seek": 50536, "start": 516.16, "end": 521.44, "text": " or minus one again, we'll make use of that function I mentioned earlier, F. And that's it.", "tokens": [50904, 420, 3175, 472, 797, 11, 321, 603, 652, 764, 295, 300, 2445, 286, 2835, 3071, 11, 479, 13, 400, 300, 311, 309, 13, 51168], "temperature": 0.0, "avg_logprob": -0.10355040291759456, "compression_ratio": 1.6940298507462686, "no_speech_prob": 0.01098611205816269}, {"id": 89, "seek": 50536, "start": 521.44, "end": 526.5600000000001, "text": " Those of you familiar with linear algebra will have recognized this as computing the dot product", "tokens": [51168, 3950, 295, 291, 4963, 365, 8213, 21989, 486, 362, 9823, 341, 382, 15866, 264, 5893, 1674, 51424], "temperature": 0.0, "avg_logprob": -0.10355040291759456, "compression_ratio": 1.6940298507462686, "no_speech_prob": 0.01098611205816269}, {"id": 90, "seek": 50536, "start": 526.5600000000001, "end": 530.5600000000001, "text": " between the vector of neuron states and the vector of connection weights.", "tokens": [51424, 1296, 264, 8062, 295, 34090, 4368, 293, 264, 8062, 295, 4984, 17443, 13, 51624], "temperature": 0.0, "avg_logprob": -0.10355040291759456, "compression_ratio": 1.6940298507462686, "no_speech_prob": 0.01098611205816269}, {"id": 91, "seek": 53056, "start": 530.9599999999999, "end": 538.2399999999999, "text": " This is a network of 64 neurons. And I'm just going to tell you without explaining how", "tokens": [50384, 639, 307, 257, 3209, 295, 12145, 22027, 13, 400, 286, 478, 445, 516, 281, 980, 291, 1553, 13468, 577, 50748], "temperature": 0.0, "avg_logprob": -0.1153121707083165, "compression_ratio": 1.590717299578059, "no_speech_prob": 0.0008040761458687484}, {"id": 92, "seek": 53056, "start": 538.2399999999999, "end": 544.16, "text": " that it has memorized this pattern, starting it off in different initial states, and then running the", "tokens": [50748, 300, 309, 575, 46677, 341, 5102, 11, 2891, 309, 766, 294, 819, 5883, 4368, 11, 293, 550, 2614, 264, 51044], "temperature": 0.0, "avg_logprob": -0.1153121707083165, "compression_ratio": 1.590717299578059, "no_speech_prob": 0.0008040761458687484}, {"id": 93, "seek": 53056, "start": 544.16, "end": 549.92, "text": " equations I just described, selecting one neuron at a time at random and updating its activity.", "tokens": [51044, 11787, 286, 445, 7619, 11, 18182, 472, 34090, 412, 257, 565, 412, 4974, 293, 25113, 1080, 5191, 13, 51332], "temperature": 0.0, "avg_logprob": -0.1153121707083165, "compression_ratio": 1.590717299578059, "no_speech_prob": 0.0008040761458687484}, {"id": 94, "seek": 53056, "start": 549.92, "end": 554.7199999999999, "text": " And wait, let's just make this a little simpler. We can see that the network really has this", "tokens": [51332, 400, 1699, 11, 718, 311, 445, 652, 341, 257, 707, 18587, 13, 492, 393, 536, 300, 264, 3209, 534, 575, 341, 51572], "temperature": 0.0, "avg_logprob": -0.1153121707083165, "compression_ratio": 1.590717299578059, "no_speech_prob": 0.0008040761458687484}, {"id": 95, "seek": 55472, "start": 554.72, "end": 561.44, "text": " intriguing property that it gravitates towards the memory pattern in all cases. Or well, it ends", "tokens": [50364, 32503, 4707, 300, 309, 26048, 1024, 3030, 264, 4675, 5102, 294, 439, 3331, 13, 1610, 731, 11, 309, 5314, 50700], "temperature": 0.0, "avg_logprob": -0.07518571965834674, "compression_ratio": 1.74822695035461, "no_speech_prob": 0.012820545583963394}, {"id": 96, "seek": 55472, "start": 561.44, "end": 565.6800000000001, "text": " up with the anti memory in some cases, we'll ignore that it has to do with a certain symmetry in the", "tokens": [50700, 493, 365, 264, 6061, 4675, 294, 512, 3331, 11, 321, 603, 11200, 300, 309, 575, 281, 360, 365, 257, 1629, 25440, 294, 264, 50912], "temperature": 0.0, "avg_logprob": -0.07518571965834674, "compression_ratio": 1.74822695035461, "no_speech_prob": 0.012820545583963394}, {"id": 97, "seek": 55472, "start": 565.6800000000001, "end": 572.1600000000001, "text": " network that we will get to. Moreover, once it's settled into that state, it doesn't change anymore.", "tokens": [50912, 3209, 300, 321, 486, 483, 281, 13, 19838, 11, 1564, 309, 311, 14819, 666, 300, 1785, 11, 309, 1177, 380, 1319, 3602, 13, 51236], "temperature": 0.0, "avg_logprob": -0.07518571965834674, "compression_ratio": 1.74822695035461, "no_speech_prob": 0.012820545583963394}, {"id": 98, "seek": 55472, "start": 572.1600000000001, "end": 578.1600000000001, "text": " The memory pattern is what is called a stable state of the network. So can we be sure that this", "tokens": [51236, 440, 4675, 5102, 307, 437, 307, 1219, 257, 8351, 1785, 295, 264, 3209, 13, 407, 393, 321, 312, 988, 300, 341, 51536], "temperature": 0.0, "avg_logprob": -0.07518571965834674, "compression_ratio": 1.74822695035461, "no_speech_prob": 0.012820545583963394}, {"id": 99, "seek": 55472, "start": 578.1600000000001, "end": 582.96, "text": " always happens? Well, no. For example, things start to get complicated when there is more than one", "tokens": [51536, 1009, 2314, 30, 1042, 11, 572, 13, 1171, 1365, 11, 721, 722, 281, 483, 6179, 562, 456, 307, 544, 813, 472, 51776], "temperature": 0.0, "avg_logprob": -0.07518571965834674, "compression_ratio": 1.74822695035461, "no_speech_prob": 0.012820545583963394}, {"id": 100, "seek": 58296, "start": 582.96, "end": 587.9200000000001, "text": " memory stored in the network. We'll get to that. But for the simple case of just a single memory,", "tokens": [50364, 4675, 12187, 294, 264, 3209, 13, 492, 603, 483, 281, 300, 13, 583, 337, 264, 2199, 1389, 295, 445, 257, 2167, 4675, 11, 50612], "temperature": 0.0, "avg_logprob": -0.06460102966853551, "compression_ratio": 1.7050359712230216, "no_speech_prob": 0.003707082709297538}, {"id": 101, "seek": 58296, "start": 587.9200000000001, "end": 593.12, "text": " yeah, the network will converge to either the memory or its anti memory or as an edge case", "tokens": [50612, 1338, 11, 264, 3209, 486, 41881, 281, 2139, 264, 4675, 420, 1080, 6061, 4675, 420, 382, 364, 4691, 1389, 50872], "temperature": 0.0, "avg_logprob": -0.06460102966853551, "compression_ratio": 1.7050359712230216, "no_speech_prob": 0.003707082709297538}, {"id": 102, "seek": 58296, "start": 593.12, "end": 599.0400000000001, "text": " to the completely inactive state. So let's recap. Networks are just vectors that evolve in time and", "tokens": [50872, 281, 264, 2584, 294, 12596, 1785, 13, 407, 718, 311, 20928, 13, 12640, 82, 366, 445, 18875, 300, 16693, 294, 565, 293, 51168], "temperature": 0.0, "avg_logprob": -0.06460102966853551, "compression_ratio": 1.7050359712230216, "no_speech_prob": 0.003707082709297538}, {"id": 103, "seek": 58296, "start": 599.0400000000001, "end": 604.4000000000001, "text": " we update their elements asynchronously. Given some configuration of weights, there are stable", "tokens": [51168, 321, 5623, 641, 4959, 42642, 5098, 13, 18600, 512, 11694, 295, 17443, 11, 456, 366, 8351, 51436], "temperature": 0.0, "avg_logprob": -0.06460102966853551, "compression_ratio": 1.7050359712230216, "no_speech_prob": 0.003707082709297538}, {"id": 104, "seek": 58296, "start": 604.4000000000001, "end": 609.6800000000001, "text": " states in the network, which we call memory states. And we have seen, although not proved,", "tokens": [51436, 4368, 294, 264, 3209, 11, 597, 321, 818, 4675, 4368, 13, 400, 321, 362, 1612, 11, 4878, 406, 14617, 11, 51700], "temperature": 0.0, "avg_logprob": -0.06460102966853551, "compression_ratio": 1.7050359712230216, "no_speech_prob": 0.003707082709297538}, {"id": 105, "seek": 60968, "start": 609.68, "end": 614.4799999999999, "text": " that the network is kind of attracted to these states. That leaves the following question.", "tokens": [50364, 300, 264, 3209, 307, 733, 295, 15912, 281, 613, 4368, 13, 663, 5510, 264, 3480, 1168, 13, 50604], "temperature": 0.0, "avg_logprob": -0.04276797578141496, "compression_ratio": 1.7582417582417582, "no_speech_prob": 0.0019877201411873102}, {"id": 106, "seek": 60968, "start": 614.4799999999999, "end": 619.76, "text": " How do we make the network memorize a certain pattern? In other words, how can we design the", "tokens": [50604, 1012, 360, 321, 652, 264, 3209, 27478, 257, 1629, 5102, 30, 682, 661, 2283, 11, 577, 393, 321, 1715, 264, 50868], "temperature": 0.0, "avg_logprob": -0.04276797578141496, "compression_ratio": 1.7582417582417582, "no_speech_prob": 0.0019877201411873102}, {"id": 107, "seek": 60968, "start": 619.76, "end": 624.7199999999999, "text": " stable states of the network? This amounts to setting the weights of the network, which turns", "tokens": [50868, 8351, 4368, 295, 264, 3209, 30, 639, 11663, 281, 3287, 264, 17443, 295, 264, 3209, 11, 597, 4523, 51116], "temperature": 0.0, "avg_logprob": -0.04276797578141496, "compression_ratio": 1.7582417582417582, "no_speech_prob": 0.0019877201411873102}, {"id": 108, "seek": 60968, "start": 624.7199999999999, "end": 630.88, "text": " out to be a matrix with as many rows and columns as there are neurons. For example, the state of", "tokens": [51116, 484, 281, 312, 257, 8141, 365, 382, 867, 13241, 293, 13766, 382, 456, 366, 22027, 13, 1171, 1365, 11, 264, 1785, 295, 51424], "temperature": 0.0, "avg_logprob": -0.04276797578141496, "compression_ratio": 1.7582417582417582, "no_speech_prob": 0.0019877201411873102}, {"id": 109, "seek": 60968, "start": 630.88, "end": 637.68, "text": " this neuron is determined by the weights in this row of the matrix. At first, this might seem impossible,", "tokens": [51424, 341, 34090, 307, 9540, 538, 264, 17443, 294, 341, 5386, 295, 264, 8141, 13, 1711, 700, 11, 341, 1062, 1643, 6243, 11, 51764], "temperature": 0.0, "avg_logprob": -0.04276797578141496, "compression_ratio": 1.7582417582417582, "no_speech_prob": 0.0019877201411873102}, {"id": 110, "seek": 63768, "start": 637.68, "end": 640.64, "text": " especially if we wish to store more than one memory in the network.", "tokens": [50364, 2318, 498, 321, 3172, 281, 3531, 544, 813, 472, 4675, 294, 264, 3209, 13, 50512], "temperature": 0.0, "avg_logprob": -0.06925662074770246, "compression_ratio": 1.6654275092936803, "no_speech_prob": 0.00017400315846316516}, {"id": 111, "seek": 63768, "start": 642.8, "end": 647.92, "text": " So I'm just going to tell you the magic rule and then I'll motivate it. Given a desired memory", "tokens": [50620, 407, 286, 478, 445, 516, 281, 980, 291, 264, 5585, 4978, 293, 550, 286, 603, 28497, 309, 13, 18600, 257, 14721, 4675, 50876], "temperature": 0.0, "avg_logprob": -0.06925662074770246, "compression_ratio": 1.6654275092936803, "no_speech_prob": 0.00017400315846316516}, {"id": 112, "seek": 63768, "start": 647.92, "end": 654.0, "text": " state with, say, eight elements, we are looking for an eight by eight matrix. We will just say,", "tokens": [50876, 1785, 365, 11, 584, 11, 3180, 4959, 11, 321, 366, 1237, 337, 364, 3180, 538, 3180, 8141, 13, 492, 486, 445, 584, 11, 51180], "temperature": 0.0, "avg_logprob": -0.06925662074770246, "compression_ratio": 1.6654275092936803, "no_speech_prob": 0.00017400315846316516}, {"id": 113, "seek": 63768, "start": 654.0, "end": 660.4, "text": " seemingly out of nowhere, that the weight between two neurons, i, j in general, is determined by", "tokens": [51180, 18709, 484, 295, 11159, 11, 300, 264, 3364, 1296, 732, 22027, 11, 741, 11, 361, 294, 2674, 11, 307, 9540, 538, 51500], "temperature": 0.0, "avg_logprob": -0.06925662074770246, "compression_ratio": 1.6654275092936803, "no_speech_prob": 0.00017400315846316516}, {"id": 114, "seek": 63768, "start": 660.4, "end": 665.92, "text": " the product of their states in the memory. For all of you keen on linear algebra, this means", "tokens": [51500, 264, 1674, 295, 641, 4368, 294, 264, 4675, 13, 1171, 439, 295, 291, 20297, 322, 8213, 21989, 11, 341, 1355, 51776], "temperature": 0.0, "avg_logprob": -0.06925662074770246, "compression_ratio": 1.6654275092936803, "no_speech_prob": 0.00017400315846316516}, {"id": 115, "seek": 66592, "start": 665.92, "end": 671.4399999999999, "text": " that the matrix is an outer product of the memory vector with itself, except for the diagonal,", "tokens": [50364, 300, 264, 8141, 307, 364, 10847, 1674, 295, 264, 4675, 8062, 365, 2564, 11, 3993, 337, 264, 21539, 11, 50640], "temperature": 0.0, "avg_logprob": -0.07604806206443093, "compression_ratio": 1.6013986013986015, "no_speech_prob": 0.0002098799159284681}, {"id": 116, "seek": 66592, "start": 671.4399999999999, "end": 679.04, "text": " which we set to zero, since we don't want any self-reinforcement. But why? Think of it this way.", "tokens": [50640, 597, 321, 992, 281, 4018, 11, 1670, 321, 500, 380, 528, 604, 2698, 12, 265, 259, 9382, 13, 583, 983, 30, 6557, 295, 309, 341, 636, 13, 51020], "temperature": 0.0, "avg_logprob": -0.07604806206443093, "compression_ratio": 1.6013986013986015, "no_speech_prob": 0.0002098799159284681}, {"id": 117, "seek": 66592, "start": 679.04, "end": 683.52, "text": " Our whole approach was in some sense to build something interesting from many simple parts.", "tokens": [51020, 2621, 1379, 3109, 390, 294, 512, 2020, 281, 1322, 746, 1880, 490, 867, 2199, 3166, 13, 51244], "temperature": 0.0, "avg_logprob": -0.07604806206443093, "compression_ratio": 1.6013986013986015, "no_speech_prob": 0.0002098799159284681}, {"id": 118, "seek": 66592, "start": 684.4, "end": 689.04, "text": " So there really should be a way for the two neurons to determine the weight between them,", "tokens": [51288, 407, 456, 534, 820, 312, 257, 636, 337, 264, 732, 22027, 281, 6997, 264, 3364, 1296, 552, 11, 51520], "temperature": 0.0, "avg_logprob": -0.07604806206443093, "compression_ratio": 1.6013986013986015, "no_speech_prob": 0.0002098799159284681}, {"id": 119, "seek": 66592, "start": 689.04, "end": 693.92, "text": " independent of the rest of the network. This is a principle called Hebbian learning,", "tokens": [51520, 6695, 295, 264, 1472, 295, 264, 3209, 13, 639, 307, 257, 8665, 1219, 634, 6692, 952, 2539, 11, 51764], "temperature": 0.0, "avg_logprob": -0.07604806206443093, "compression_ratio": 1.6013986013986015, "no_speech_prob": 0.0002098799159284681}, {"id": 120, "seek": 69392, "start": 693.92, "end": 698.4799999999999, "text": " and it is exceedingly plausible, because remember that weights are supposed to be synapses?", "tokens": [50364, 293, 309, 307, 14048, 12163, 39925, 11, 570, 1604, 300, 17443, 366, 3442, 281, 312, 5451, 2382, 279, 30, 50592], "temperature": 0.0, "avg_logprob": -0.07103798124525282, "compression_ratio": 1.681159420289855, "no_speech_prob": 0.0010004882933571935}, {"id": 121, "seek": 69392, "start": 699.04, "end": 704.0, "text": " And synapses in actual neurons also would have no way of knowing what goes on in the broader", "tokens": [50620, 400, 5451, 2382, 279, 294, 3539, 22027, 611, 576, 362, 572, 636, 295, 5276, 437, 1709, 322, 294, 264, 13227, 50868], "temperature": 0.0, "avg_logprob": -0.07103798124525282, "compression_ratio": 1.681159420289855, "no_speech_prob": 0.0010004882933571935}, {"id": 122, "seek": 69392, "start": 704.0, "end": 710.4799999999999, "text": " network. And so why the multiplication? Well, here comes the reason I called it the binary states,", "tokens": [50868, 3209, 13, 400, 370, 983, 264, 27290, 30, 1042, 11, 510, 1487, 264, 1778, 286, 1219, 309, 264, 17434, 4368, 11, 51192], "temperature": 0.0, "avg_logprob": -0.07103798124525282, "compression_ratio": 1.681159420289855, "no_speech_prob": 0.0010004882933571935}, {"id": 123, "seek": 69392, "start": 710.4799999999999, "end": 714.9599999999999, "text": " minus one and plus one. If you map out all four combinations of states of the neurons,", "tokens": [51192, 3175, 472, 293, 1804, 472, 13, 759, 291, 4471, 484, 439, 1451, 21267, 295, 4368, 295, 264, 22027, 11, 51416], "temperature": 0.0, "avg_logprob": -0.07103798124525282, "compression_ratio": 1.681159420289855, "no_speech_prob": 0.0010004882933571935}, {"id": 124, "seek": 69392, "start": 715.52, "end": 720.3199999999999, "text": " you'll see that the weight will have positive sign whenever the neurons in their memory state", "tokens": [51444, 291, 603, 536, 300, 264, 3364, 486, 362, 3353, 1465, 5699, 264, 22027, 294, 641, 4675, 1785, 51684], "temperature": 0.0, "avg_logprob": -0.07103798124525282, "compression_ratio": 1.681159420289855, "no_speech_prob": 0.0010004882933571935}, {"id": 125, "seek": 72032, "start": 720.32, "end": 726.48, "text": " agree and negative if they disagree. And this should make sense, because a positive weight", "tokens": [50364, 3986, 293, 3671, 498, 436, 14091, 13, 400, 341, 820, 652, 2020, 11, 570, 257, 3353, 3364, 50672], "temperature": 0.0, "avg_logprob": -0.07067782934321913, "compression_ratio": 1.7008928571428572, "no_speech_prob": 0.001367003656923771}, {"id": 126, "seek": 72032, "start": 726.48, "end": 734.24, "text": " lets a neuron project its state onto other neurons, and a negative weight lets a neuron flip the state", "tokens": [50672, 6653, 257, 34090, 1716, 1080, 1785, 3911, 661, 22027, 11, 293, 257, 3671, 3364, 6653, 257, 34090, 7929, 264, 1785, 51060], "temperature": 0.0, "avg_logprob": -0.07067782934321913, "compression_ratio": 1.7008928571428572, "no_speech_prob": 0.001367003656923771}, {"id": 127, "seek": 72032, "start": 734.24, "end": 742.08, "text": " of other neurons. It's almost like the neurons behave like charged particles, maybe. One last", "tokens": [51060, 295, 661, 22027, 13, 467, 311, 1920, 411, 264, 22027, 15158, 411, 11109, 10007, 11, 1310, 13, 1485, 1036, 51452], "temperature": 0.0, "avg_logprob": -0.07067782934321913, "compression_ratio": 1.7008928571428572, "no_speech_prob": 0.001367003656923771}, {"id": 128, "seek": 72032, "start": 742.08, "end": 746.72, "text": " question before we can see it in action, and that's how do we store multiple patterns at once", "tokens": [51452, 1168, 949, 321, 393, 536, 309, 294, 3069, 11, 293, 300, 311, 577, 360, 321, 3531, 3866, 8294, 412, 1564, 51684], "temperature": 0.0, "avg_logprob": -0.07067782934321913, "compression_ratio": 1.7008928571428572, "no_speech_prob": 0.001367003656923771}, {"id": 129, "seek": 74672, "start": 746.72, "end": 752.0, "text": " in the same network? We do it by computing the outer products for all desired memory patterns,", "tokens": [50364, 294, 264, 912, 3209, 30, 492, 360, 309, 538, 15866, 264, 10847, 3383, 337, 439, 14721, 4675, 8294, 11, 50628], "temperature": 0.0, "avg_logprob": -0.047811643132623635, "compression_ratio": 1.690909090909091, "no_speech_prob": 0.003707083174958825}, {"id": 130, "seek": 74672, "start": 752.0, "end": 757.84, "text": " this gives us a matrix for each, and then we average those matrices. This gives finer and", "tokens": [50628, 341, 2709, 505, 257, 8141, 337, 1184, 11, 293, 550, 321, 4274, 729, 32284, 13, 639, 2709, 39130, 293, 50920], "temperature": 0.0, "avg_logprob": -0.047811643132623635, "compression_ratio": 1.690909090909091, "no_speech_prob": 0.003707083174958825}, {"id": 131, "seek": 74672, "start": 757.84, "end": 763.12, "text": " finer gradations of the weights. Now, however, things start to become a little bit more complicated.", "tokens": [50920, 39130, 2771, 763, 295, 264, 17443, 13, 823, 11, 4461, 11, 721, 722, 281, 1813, 257, 707, 857, 544, 6179, 13, 51184], "temperature": 0.0, "avg_logprob": -0.047811643132623635, "compression_ratio": 1.690909090909091, "no_speech_prob": 0.003707083174958825}, {"id": 132, "seek": 74672, "start": 763.6800000000001, "end": 768.8000000000001, "text": " There's no way to guarantee that all memory patterns are stable states. The memories will", "tokens": [51212, 821, 311, 572, 636, 281, 10815, 300, 439, 4675, 8294, 366, 8351, 4368, 13, 440, 8495, 486, 51468], "temperature": 0.0, "avg_logprob": -0.047811643132623635, "compression_ratio": 1.690909090909091, "no_speech_prob": 0.003707083174958825}, {"id": 133, "seek": 74672, "start": 768.8000000000001, "end": 774.88, "text": " start talking to each other, fusing into new memories, which I find frustrating and super", "tokens": [51468, 722, 1417, 281, 1184, 661, 11, 283, 7981, 666, 777, 8495, 11, 597, 286, 915, 16522, 293, 1687, 51772], "temperature": 0.0, "avg_logprob": -0.047811643132623635, "compression_ratio": 1.690909090909091, "no_speech_prob": 0.003707083174958825}, {"id": 134, "seek": 77488, "start": 774.88, "end": 780.0, "text": " interesting at the same time. Here's the network with four memories again. It sometimes converges", "tokens": [50364, 1880, 412, 264, 912, 565, 13, 1692, 311, 264, 3209, 365, 1451, 8495, 797, 13, 467, 2171, 9652, 2880, 50620], "temperature": 0.0, "avg_logprob": -0.06508666385303843, "compression_ratio": 1.684981684981685, "no_speech_prob": 0.0033764182589948177}, {"id": 135, "seek": 77488, "start": 780.0, "end": 785.68, "text": " to one of the memory states, yes, but in other cases, it converges to something in between,", "tokens": [50620, 281, 472, 295, 264, 4675, 4368, 11, 2086, 11, 457, 294, 661, 3331, 11, 309, 9652, 2880, 281, 746, 294, 1296, 11, 50904], "temperature": 0.0, "avg_logprob": -0.06508666385303843, "compression_ratio": 1.684981684981685, "no_speech_prob": 0.0033764182589948177}, {"id": 136, "seek": 77488, "start": 786.32, "end": 791.84, "text": " a merging of memories, which I find, well, almost a kind of human mistake.", "tokens": [50936, 257, 44559, 295, 8495, 11, 597, 286, 915, 11, 731, 11, 1920, 257, 733, 295, 1952, 6146, 13, 51212], "temperature": 0.0, "avg_logprob": -0.06508666385303843, "compression_ratio": 1.684981684981685, "no_speech_prob": 0.0033764182589948177}, {"id": 137, "seek": 77488, "start": 793.2, "end": 797.84, "text": " And with this, we are finally making some progress on our question from the very beginning of the", "tokens": [51280, 400, 365, 341, 11, 321, 366, 2721, 1455, 512, 4205, 322, 527, 1168, 490, 264, 588, 2863, 295, 264, 51512], "temperature": 0.0, "avg_logprob": -0.06508666385303843, "compression_ratio": 1.684981684981685, "no_speech_prob": 0.0033764182589948177}, {"id": 138, "seek": 77488, "start": 797.84, "end": 804.08, "text": " video. How much memory do you have? Originally, we might have answered this by giving some number", "tokens": [51512, 960, 13, 1012, 709, 4675, 360, 291, 362, 30, 28696, 11, 321, 1062, 362, 10103, 341, 538, 2902, 512, 1230, 51824], "temperature": 0.0, "avg_logprob": -0.06508666385303843, "compression_ratio": 1.684981684981685, "no_speech_prob": 0.0033764182589948177}, {"id": 139, "seek": 80408, "start": 804.08, "end": 809.12, "text": " of bytes. But now the question presents itself very differently. It's more like, how many", "tokens": [50364, 295, 36088, 13, 583, 586, 264, 1168, 13533, 2564, 588, 7614, 13, 467, 311, 544, 411, 11, 577, 867, 50616], "temperature": 0.0, "avg_logprob": -0.06223269690454534, "compression_ratio": 1.7075812274368232, "no_speech_prob": 0.001501134131103754}, {"id": 140, "seek": 80408, "start": 809.12, "end": 815.6, "text": " memory patterns can we store in a recurrent network of a given size, such that they are stable states", "tokens": [50616, 4675, 8294, 393, 321, 3531, 294, 257, 18680, 1753, 3209, 295, 257, 2212, 2744, 11, 1270, 300, 436, 366, 8351, 4368, 50940], "temperature": 0.0, "avg_logprob": -0.06223269690454534, "compression_ratio": 1.7075812274368232, "no_speech_prob": 0.001501134131103754}, {"id": 141, "seek": 80408, "start": 815.6, "end": 821.6, "text": " of the network? And the answer is, at least for this model, not very many. The original paper", "tokens": [50940, 295, 264, 3209, 30, 400, 264, 1867, 307, 11, 412, 1935, 337, 341, 2316, 11, 406, 588, 867, 13, 440, 3380, 3035, 51240], "temperature": 0.0, "avg_logprob": -0.06223269690454534, "compression_ratio": 1.7075812274368232, "no_speech_prob": 0.001501134131103754}, {"id": 142, "seek": 80408, "start": 821.6, "end": 826.08, "text": " showed that this model has only linear memory capacity. That's to say, the number of stable", "tokens": [51240, 4712, 300, 341, 2316, 575, 787, 8213, 4675, 6042, 13, 663, 311, 281, 584, 11, 264, 1230, 295, 8351, 51464], "temperature": 0.0, "avg_logprob": -0.06223269690454534, "compression_ratio": 1.7075812274368232, "no_speech_prob": 0.001501134131103754}, {"id": 143, "seek": 80408, "start": 826.08, "end": 831.2, "text": " states grows as a linear function of the size of the network. Plus, there's a hidden assumption", "tokens": [51464, 4368, 13156, 382, 257, 8213, 2445, 295, 264, 2744, 295, 264, 3209, 13, 7721, 11, 456, 311, 257, 7633, 15302, 51720], "temperature": 0.0, "avg_logprob": -0.06223269690454534, "compression_ratio": 1.7075812274368232, "no_speech_prob": 0.001501134131103754}, {"id": 144, "seek": 83120, "start": 831.2800000000001, "end": 836.0, "text": " in this graph too, which is that all memory states are uncorrelated, which, for any set of", "tokens": [50368, 294, 341, 4295, 886, 11, 597, 307, 300, 439, 4675, 4368, 366, 6219, 284, 12004, 11, 597, 11, 337, 604, 992, 295, 50604], "temperature": 0.0, "avg_logprob": -0.08126427642012064, "compression_ratio": 1.673992673992674, "no_speech_prob": 0.002050681272521615}, {"id": 145, "seek": 83120, "start": 836.0, "end": 841.2800000000001, "text": " pictures like this, is totally not the case. I tried my best picking out some not-so-correlated", "tokens": [50604, 5242, 411, 341, 11, 307, 3879, 406, 264, 1389, 13, 286, 3031, 452, 1151, 8867, 484, 512, 406, 12, 539, 12, 19558, 12004, 50868], "temperature": 0.0, "avg_logprob": -0.08126427642012064, "compression_ratio": 1.673992673992674, "no_speech_prob": 0.002050681272521615}, {"id": 146, "seek": 83120, "start": 841.2800000000001, "end": 845.76, "text": " images to really show what this network can do, and the results are, well, see for yourself.", "tokens": [50868, 5267, 281, 534, 855, 437, 341, 3209, 393, 360, 11, 293, 264, 3542, 366, 11, 731, 11, 536, 337, 1803, 13, 51092], "temperature": 0.0, "avg_logprob": -0.08126427642012064, "compression_ratio": 1.673992673992674, "no_speech_prob": 0.002050681272521615}, {"id": 147, "seek": 83120, "start": 850.1600000000001, "end": 855.5200000000001, "text": " Realistically, that means that this model is maybe too simple after all. And that's not", "tokens": [51312, 8467, 20458, 11, 300, 1355, 300, 341, 2316, 307, 1310, 886, 2199, 934, 439, 13, 400, 300, 311, 406, 51580], "temperature": 0.0, "avg_logprob": -0.08126427642012064, "compression_ratio": 1.673992673992674, "no_speech_prob": 0.002050681272521615}, {"id": 148, "seek": 83120, "start": 855.5200000000001, "end": 860.0, "text": " surprising given all the violence we did to these networks with our many simplifications.", "tokens": [51580, 8830, 2212, 439, 264, 6270, 321, 630, 281, 613, 9590, 365, 527, 867, 6883, 7833, 13, 51804], "temperature": 0.0, "avg_logprob": -0.08126427642012064, "compression_ratio": 1.673992673992674, "no_speech_prob": 0.002050681272521615}, {"id": 149, "seek": 86000, "start": 860.0, "end": 863.92, "text": " But the goal of this video wasn't to convince you that this model can be used in any practical", "tokens": [50364, 583, 264, 3387, 295, 341, 960, 2067, 380, 281, 13447, 291, 300, 341, 2316, 393, 312, 1143, 294, 604, 8496, 50560], "temperature": 0.0, "avg_logprob": -0.0632626367651898, "compression_ratio": 1.63013698630137, "no_speech_prob": 0.0007321644807234406}, {"id": 150, "seek": 86000, "start": 863.92, "end": 868.56, "text": " sense anyway. Although, in a follow-up video, I want to tell you what steps people took to", "tokens": [50560, 2020, 4033, 13, 5780, 11, 294, 257, 1524, 12, 1010, 960, 11, 286, 528, 281, 980, 291, 437, 4439, 561, 1890, 281, 50792], "temperature": 0.0, "avg_logprob": -0.0632626367651898, "compression_ratio": 1.63013698630137, "no_speech_prob": 0.0007321644807234406}, {"id": 151, "seek": 86000, "start": 868.56, "end": 873.12, "text": " make this model actually useful for deep neural networks. What I wanted to achieve with this", "tokens": [50792, 652, 341, 2316, 767, 4420, 337, 2452, 18161, 9590, 13, 708, 286, 1415, 281, 4584, 365, 341, 51020], "temperature": 0.0, "avg_logprob": -0.0632626367651898, "compression_ratio": 1.63013698630137, "no_speech_prob": 0.0007321644807234406}, {"id": 152, "seek": 86000, "start": 873.12, "end": 880.64, "text": " video is, first, to warn you of false comparisons. Networks of neurons don't behave like USB sticks,", "tokens": [51020, 960, 307, 11, 700, 11, 281, 12286, 291, 295, 7908, 33157, 13, 12640, 82, 295, 22027, 500, 380, 15158, 411, 10109, 12518, 11, 51396], "temperature": 0.0, "avg_logprob": -0.0632626367651898, "compression_ratio": 1.63013698630137, "no_speech_prob": 0.0007321644807234406}, {"id": 153, "seek": 86000, "start": 880.64, "end": 886.72, "text": " and why should they? But secondly, it's to show you how with modeling approaches, walking a very", "tokens": [51396, 293, 983, 820, 436, 30, 583, 26246, 11, 309, 311, 281, 855, 291, 577, 365, 15983, 11587, 11, 4494, 257, 588, 51700], "temperature": 0.0, "avg_logprob": -0.0632626367651898, "compression_ratio": 1.63013698630137, "no_speech_prob": 0.0007321644807234406}, {"id": 154, "seek": 88672, "start": 886.8000000000001, "end": 891.84, "text": " thin line between complexity and simplicity, we can sometimes start to conceive of the world", "tokens": [50368, 5862, 1622, 1296, 14024, 293, 25632, 11, 321, 393, 2171, 722, 281, 48605, 295, 264, 1002, 50620], "temperature": 0.0, "avg_logprob": -0.12925300859425165, "compression_ratio": 1.5545454545454545, "no_speech_prob": 0.08626093715429306}, {"id": 155, "seek": 88672, "start": 891.84, "end": 896.8000000000001, "text": " differently than otherwise we would have. You might have set out picturing memory as", "tokens": [50620, 7614, 813, 5911, 321, 576, 362, 13, 509, 1062, 362, 992, 484, 2317, 1345, 4675, 382, 50868], "temperature": 0.0, "avg_logprob": -0.12925300859425165, "compression_ratio": 1.5545454545454545, "no_speech_prob": 0.08626093715429306}, {"id": 156, "seek": 88672, "start": 896.8000000000001, "end": 902.24, "text": " something static, but I'm hoping now you're willing to consider that it might be something dynamic,", "tokens": [50868, 746, 13437, 11, 457, 286, 478, 7159, 586, 291, 434, 4950, 281, 1949, 300, 309, 1062, 312, 746, 8546, 11, 51140], "temperature": 0.0, "avg_logprob": -0.12925300859425165, "compression_ratio": 1.5545454545454545, "no_speech_prob": 0.08626093715429306}, {"id": 157, "seek": 88672, "start": 902.88, "end": 908.24, "text": " the invisible, stable states of a network buzzing with activity.", "tokens": [51172, 264, 14603, 11, 8351, 4368, 295, 257, 3209, 29659, 365, 5191, 13, 51440], "temperature": 0.0, "avg_logprob": -0.12925300859425165, "compression_ratio": 1.5545454545454545, "no_speech_prob": 0.08626093715429306}], "language": "en"}