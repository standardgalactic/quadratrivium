WEBVTT

00:00.000 --> 00:05.000
We'll see you in the next video.

00:05.000 --> 00:10.000
Good morning, everyone.

00:10.000 --> 00:11.000
Wait.

00:11.000 --> 00:13.000
Don't cheer us.

00:13.000 --> 00:15.000
Cheer the next speakers.

00:15.000 --> 00:18.000
So I'm from the representing the platform team on Android.

00:18.000 --> 00:21.000
And this is representing the tools team.

00:21.000 --> 00:22.000
But you're not here for us.

00:22.000 --> 00:24.000
You're here for very special speakers.

00:24.000 --> 00:25.000
Yeah.

00:25.000 --> 00:28.000
So Roman and I have been incredibly excited about this official

00:28.000 --> 00:29.000
announcement of Kotlin.

00:29.000 --> 00:32.000
We both love Kotlin in case you haven't noticed already.

00:32.000 --> 00:35.000
And we don't want to take any more time from the speakers of honor.

00:35.000 --> 00:38.000
So without further ado, here they are.

00:38.000 --> 00:54.000
So hello, everyone.

00:54.000 --> 00:56.000
Oh, that's nice.

00:56.000 --> 00:58.000
So you know, I was thinking the other day,

00:58.000 --> 01:00.000
the first time that I ever did a talk in Kotlin,

01:00.000 --> 01:03.000
it was like four and a half years ago.

01:03.000 --> 01:05.000
And they gave me a room for 900 people,

01:05.000 --> 01:08.000
and seven people showed up.

01:08.000 --> 01:11.000
So it's kind of nice to see more of you show up today.

01:11.000 --> 01:16.000
Thank you.

01:16.000 --> 01:20.000
Anyway, I've got roughly around 30 minutes,

01:20.000 --> 01:23.000
actually 30, a little bit less,

01:23.000 --> 01:25.000
28 minutes to give you a whirlwind tour of Kotlin.

01:25.000 --> 01:27.000
So I'm not going to cover the entire language.

01:27.000 --> 01:31.000
I'm going to try and show you as much as I possibly can

01:31.000 --> 01:34.000
and how you can use it and where it provides you with some benefits.

01:34.000 --> 01:37.000
OK, so I'm going to try and do it all with live coding.

01:37.000 --> 01:41.000
So if it all goes terribly wrong, there's a Google video.

01:41.000 --> 01:44.000
I mean, there's a YouTube video of this somewhere as well.

01:44.000 --> 01:46.000
So you can watch that.

01:46.000 --> 01:48.000
OK, so we're going to start with something very simple

01:48.000 --> 01:50.000
that you've already seen, data class.

01:50.000 --> 01:54.000
And I'm in a file called main, right?

01:54.000 --> 01:57.000
So data class, I'm going to create a new type called money,

01:57.000 --> 02:00.000
and it's going to have an amount, which is of type int.

02:00.000 --> 02:02.000
I know, don't say anything for now.

02:02.000 --> 02:07.000
And it's going to have a currency of type string, OK?

02:07.000 --> 02:09.000
And this is both properties,

02:09.000 --> 02:11.000
and they're going to be read-only properties.

02:11.000 --> 02:13.000
So this is something that you're already familiar with.

02:13.000 --> 02:15.000
It's essentially a data class.

02:15.000 --> 02:21.000
Let's go ahead and compare that to a Java one that I have done earlier.

02:21.000 --> 02:23.000
So split vertically.

02:23.000 --> 02:25.000
And let's get the Java money up.

02:25.000 --> 02:28.000
Actually, let's get it on this side.

02:28.000 --> 02:30.000
Java money.

02:30.000 --> 02:32.000
So there you go.

02:32.000 --> 02:35.000
That's kind of the equivalent of what I've just written, right?

02:35.000 --> 02:39.000
A Java being essentially a data class that provides two getters.

02:39.000 --> 02:42.000
They're immutable, so they're read-only.

02:42.000 --> 02:45.000
And this data modifier over here, what that's doing is essentially

02:45.000 --> 02:47.000
giving me a whole bunch of things like the two string.

02:47.000 --> 02:51.000
It's giving me the clone, which in Kotlin is called copy.

02:51.000 --> 02:53.000
It's doing the equals.

02:53.000 --> 02:54.000
It's doing the hash code.

02:54.000 --> 02:56.000
Now you say, OK, well, that's great.

02:56.000 --> 02:57.000
Brilliant.

02:57.000 --> 02:58.000
But why do I need that?

02:58.000 --> 03:01.000
Because any good IDE is going to generate that for me.

03:01.000 --> 03:02.000
It is true.

03:02.000 --> 03:03.000
It does.

03:03.000 --> 03:05.000
But the problem is that that's code you're going to have to maintain.

03:05.000 --> 03:06.000
And every time you add a new property,

03:06.000 --> 03:08.000
you're going to have to go back and change that code.

03:08.000 --> 03:10.000
And the other issue you're going to have is you don't know,

03:10.000 --> 03:13.000
in fact, if that code is the standard stuff

03:13.000 --> 03:17.000
that your IDE has generated for you,

03:17.000 --> 03:19.000
or you've tweaked it a little bit, OK?

03:19.000 --> 03:23.000
So it's not just about saving on typing on the first slide.

03:23.000 --> 03:24.000
Right.

03:24.000 --> 03:27.000
Now what I'm going to do is go ahead and create a function main.

03:27.000 --> 03:29.000
Let's close this guy over here.

03:29.000 --> 03:31.000
And this is like the top entry point of Kotlin.

03:31.000 --> 03:35.000
So you have a public static void main in a class.

03:35.000 --> 03:37.000
You don't need that in Kotlin.

03:37.000 --> 03:39.000
So in Kotlin, you can put everything in the top level.

03:39.000 --> 03:42.000
It's kind of like JavaScript in a good way.

03:42.000 --> 03:48.000
And so you don't have to, and just I want to reiterate,

03:48.000 --> 03:50.000
like every function and everything that I'll show you today,

03:50.000 --> 03:53.000
I'm going to just add it in the file as a top level thing.

03:53.000 --> 03:57.000
But that doesn't mean that you don't have any more member functions.

03:57.000 --> 04:00.000
Anything, any class, even a data class can have member functions.

04:00.000 --> 04:03.000
But for brevity and for the purpose of what I'm showing you,

04:03.000 --> 04:06.000
I'm just going to put it as top level, OK?

04:06.000 --> 04:08.000
So I'm going to create a new instance of money.

04:08.000 --> 04:11.000
We're going to call it, for example, tickets.

04:11.000 --> 04:13.000
And I'll say money, 100.

04:13.000 --> 04:16.000
And it's going to be dollars, right?

04:16.000 --> 04:20.000
And I'll get into the explicit type here.

04:20.000 --> 04:22.000
But essentially here, what I'm doing is type inference.

04:22.000 --> 04:24.000
So Kotlin is very strong in type inference.

04:24.000 --> 04:26.000
And as much as it can infer, it will for you.

04:26.000 --> 04:29.000
So you don't have to explicitly tell the type.

04:29.000 --> 04:32.000
And then I'll say, for example, popcorn.

04:32.000 --> 04:37.000
Let's say tickets, copy, right?

04:37.000 --> 04:42.000
So that's what that's going to do is basically copy the previous one for me

04:42.000 --> 04:44.000
and all of the properties.

04:44.000 --> 04:47.000
So if I don't pass any parameters in,

04:47.000 --> 04:50.000
it's going to just take the same values as it has before, OK?

04:50.000 --> 04:53.000
So I can pass in a new parameter, say, like, you know, I mean, in Spain,

04:53.000 --> 04:57.000
for example, popcorn is seven times the price of the entry of the cinema.

04:57.000 --> 05:01.000
So that's going to be like 500 euros, right?

05:01.000 --> 05:04.000
And now I can do things like, for instance, you know,

05:04.000 --> 05:10.000
if tickets is not equal to popcorn,

05:10.000 --> 05:16.000
then print line, they are different, right?

05:16.000 --> 05:20.000
So what this is doing is a property comparison one by one.

05:20.000 --> 05:22.000
It's not doing a pointer comparison.

05:22.000 --> 05:25.000
For pointer comparisons, we have the triple equal, right?

05:25.000 --> 05:29.000
Different to JavaScript, there isn't like a chart of 600 different positions

05:29.000 --> 05:30.000
you have to remember.

05:30.000 --> 05:34.000
So, and this, by the way, is font ligatures.

05:34.000 --> 05:35.000
So don't get confused with that.

05:35.000 --> 05:37.000
We didn't introduce a new symbol.

05:37.000 --> 05:38.000
OK.

05:38.000 --> 05:44.000
So I can go ahead and just, like, run this and I get they are different.

05:44.000 --> 05:50.000
And if I change this to 100 and I put this as dollars and I run this,

05:50.000 --> 05:54.000
it's going to say to you that nothing, because they are the same, OK?

05:54.000 --> 05:59.000
Now, one of the features we keep boosting about is the interop between Java and Kotlin.

05:59.000 --> 06:02.000
So we have this Java money one over here.

06:02.000 --> 06:05.000
So I'm going to go ahead and create an instance of it.

06:05.000 --> 06:10.000
And I'll say Java money equals Java money.

06:10.000 --> 06:13.000
And it will be 100 and it will be dollars.

06:13.000 --> 06:19.000
And then if I do Java money, you can see that I don't have any getters.

06:19.000 --> 06:23.000
Well, I do have actually a getter, so I can do get amount.

06:23.000 --> 06:28.000
But if I write get amount, completed, the ID is already going to replace that for property

06:28.000 --> 06:30.000
because we don't have really, like, getters and setters.

06:30.000 --> 06:32.000
We just have properties.

06:32.000 --> 06:36.000
So that's consuming Java from Kotlin.

06:36.000 --> 06:41.000
And if I go over to the Java over here and let's go ahead and create a public static void main

06:41.000 --> 06:52.000
and I'll do, so let's see, I've got a declarer type, money equals new money 100 and dollars.

06:52.000 --> 06:54.000
And, oh, OK.

06:54.000 --> 06:57.000
That's the other thing.

06:57.000 --> 07:00.000
The semicolons in Kotlin are optional.

07:00.000 --> 07:08.000
And the reason they're optional is so that you can have endless arguments over whether you should use them or not.

07:08.000 --> 07:10.000
We're trying to compete with JavaScript there.

07:10.000 --> 07:12.000
OK, so money.get amount.

07:12.000 --> 07:17.000
So now I'm using a Kotlin type from Java, so I'm getting the getters and the setters.

07:17.000 --> 07:22.000
So idiomatic, depending on how you are using it.

07:22.000 --> 07:29.000
And that's just different Java files, different Kotlin files in a single project working seamlessly without any issues.

07:29.000 --> 07:33.000
Right, so now let's go ahead and create some functions.

07:33.000 --> 07:42.000
So I'm going to create a function called send payment that takes some money and money and it's going to print line the money out.

07:42.000 --> 07:48.000
And of course we have string interpolation, so I can say sending money.amount.

07:48.000 --> 07:53.000
And you don't have to put these curly braces if it's just a single property that you're passing in, as we'll just see in a moment.

07:53.000 --> 07:57.000
So now I can call this and say, for example, send payment, tickets.

07:57.000 --> 08:04.000
Right, now Kotlin we also have, notice one thing here, I'm not defining the return type.

08:04.000 --> 08:08.000
OK, by default it's unit, which is kind of like void, but it's not.

08:08.000 --> 08:14.000
It's actually object, which is essentially a singleton and single instance of an object.

08:14.000 --> 08:18.000
And if it is a unit, you don't have to put it there, right?

08:18.000 --> 08:27.000
So I'm going to add a new parameter here, and I'm going to say, for example, with message, and this is going to have string, and you can have default parameters.

08:27.000 --> 08:31.000
So here, notice that there's no compilation error because I made a default parameter.

08:31.000 --> 08:35.000
This saves you a lot in terms of overloaded function, overloaded member functions, right?

08:35.000 --> 08:39.000
I can just, you know, have default parameters and then do what I want.

08:39.000 --> 08:50.000
And you can have multiple default parameters, and since you can have multiple default parameters and you can, you know, alternate which one you want to pass in, you can also do named parameters.

08:50.000 --> 08:59.000
So in fact, I could say message equals good luck, and money equals tickets, right?

08:59.000 --> 09:07.000
And this is kind of useful as well when you are using, you're talking to legacy code, for example, you know, some function that you can't modify,

09:07.000 --> 09:13.000
and it's got 600 parameters, and there are probably 500 of them are true and false Booleans.

09:13.000 --> 09:22.000
It kind of gives you some insight into what parameters I'm passing in in every position.

09:22.000 --> 09:26.000
Oh, yeah. I love it when people clap.

09:26.000 --> 09:37.000
And I'm thinking to myself, well, this is going well.

09:37.000 --> 09:43.000
Anyway, right. Let's go edit that out, like adult supervision.

09:43.000 --> 09:55.000
Right. One other thing with Kotlin is that when we have functions that are really, really easy, like essentially returning a single value, you can just do single expression functions.

09:55.000 --> 10:04.000
So I omit the return type explicitly, I omit the curly braces, and I just return the actual function that I want to do, okay?

10:04.000 --> 10:10.000
So in fact, this is like the concept of expression comes in many places in Kotlin.

10:10.000 --> 10:13.000
So for instance, let's create another function that's called convert to dollars.

10:13.000 --> 10:22.000
Convert to dollars, and this is going to take money, money, and it's going to return money.

10:22.000 --> 10:25.000
And then what we're going to do here is a when statement.

10:25.000 --> 10:27.000
So that's essentially a case, right?

10:27.000 --> 10:38.000
So when money currency is dollars, then we'll do return money as is, right?

10:38.000 --> 10:40.000
Because I don't need to do anything.

10:40.000 --> 10:43.000
And if it's euros, then what I'm going to do is return.

10:43.000 --> 10:53.000
We're going to do money amount times, sorry, I've got to create a new instance, money.

10:53.000 --> 11:04.000
And then it's going to be money amount times big decimal, 1.10, and then that's going to be dollars, right?

11:04.000 --> 11:14.000
And else, throw illegal argument exception, not the currency you're interested in.

11:14.000 --> 11:18.000
Okay, so this, you can actually treat a when as an expression.

11:18.000 --> 11:24.000
So I can remove this return over here, remove this return over here, put it just here,

11:24.000 --> 11:29.000
and then this just makes the when always return an expression.

11:29.000 --> 11:36.000
And in fact, you can even remove the return here, return, remove the money here,

11:36.000 --> 11:40.000
and remove that there, and you get a single expression, okay?

11:40.000 --> 11:42.000
Single expression function.

11:42.000 --> 11:45.000
Now, one thing that you'll notice here that this is giving me an error,

11:45.000 --> 11:49.000
because this is, you know, I'm trying to operate a big decimal with an int.

11:49.000 --> 11:51.000
So we're going to go and refactor this.

11:51.000 --> 11:54.000
I'm going to call it big decimal, okay?

11:54.000 --> 11:57.000
Now, talking about big decimal, oh, here we go.

11:57.000 --> 12:06.000
Big decimal, big decimal, 100, and big decimal.

12:06.000 --> 12:08.000
I love typing big decimal.

12:08.000 --> 12:11.000
I love it, okay?

12:11.000 --> 12:14.000
So we've got this over here.

12:14.000 --> 12:19.000
Now, if you look at actually big decimal, so if I create a new big decimal,

12:19.000 --> 12:23.000
we'll call it bd1 equals big decimal, 100.

12:23.000 --> 12:26.000
And you can see that bd1 gives me a whole bunch of functions,

12:26.000 --> 12:28.000
like divide, multiply, all of these things.

12:28.000 --> 12:30.000
What if I wanted to do something like a percent?

12:30.000 --> 12:33.000
I wanted to do a percentage of big decimal.

12:33.000 --> 12:38.000
Now, normally you would basically inherit from that

12:38.000 --> 12:40.000
and then create your own version and have all of these things,

12:40.000 --> 12:42.000
but in Kotlin, one of the features that we've added,

12:42.000 --> 12:45.000
and if you're familiar with C sharp, it's called extension functions,

12:45.000 --> 12:48.000
which essentially means that you can take any class, any type, and extend it.

12:48.000 --> 12:51.000
So I can take a function big decimal,

12:51.000 --> 12:53.000
I put the name of the class that I want to extend,

12:53.000 --> 12:55.000
and I say I want to do a percent,

12:55.000 --> 12:59.000
and what is the percentage that I want to do, for example, an integer,

12:59.000 --> 13:01.000
and then it would be, let's see.

13:01.000 --> 13:04.000
So given that this is an extension function,

13:04.000 --> 13:08.000
it's going to have an instance of that class, of that object, right?

13:08.000 --> 13:10.000
So I can use that, reference that with this.

13:10.000 --> 13:16.000
And I say this, multiply by the percentage,

13:16.000 --> 13:20.000
and then this has got to be wrapped in a big decimal again, percentage,

13:20.000 --> 13:29.000
and then that divides, and then another big decimal, 100.

13:29.000 --> 13:33.000
And what's wrong with this? That should be percentage.

13:33.000 --> 13:37.000
So percentage, okay?

13:37.000 --> 13:43.000
So now, what happens is that on BD1, I have percentage, okay?

13:43.000 --> 13:47.000
And I can do percent seven, and that would give me a seven percent.

13:47.000 --> 13:52.000
And that extension function gets included anywhere where it is defined in the package, right?

13:52.000 --> 13:55.000
So here in this case, I have it in com.getbrains.go,

13:55.000 --> 13:57.000
and that will get included there, right?

13:57.000 --> 13:59.000
So you can create extension functions,

13:59.000 --> 14:03.000
and we'll see that the standard library actually consists of a whole bunch of extension functions.

14:03.000 --> 14:06.000
Now, we'll take this one step further, because I can actually extend everything.

14:06.000 --> 14:09.000
So let's go ahead and extend an integer.

14:09.000 --> 14:16.000
So I'll say fun, int, percent of, and here we'll do the reverse.

14:16.000 --> 14:19.000
I want, like, 10% of something, right?

14:19.000 --> 14:22.000
So I'll say money, for instance, I want 10% of money,

14:22.000 --> 14:30.000
and that's going to return the, let's see, it's going to return money, right?

14:30.000 --> 14:33.000
Then it will be amount, multiply,

14:33.000 --> 14:36.000
and then here it's going to reference the actual instance,

14:36.000 --> 14:42.000
so it will be this, and again, this has to be wrapped in big decimal,

14:42.000 --> 14:47.000
and then divide by 100, okay?

14:47.000 --> 14:50.000
And I think I got that in the right order.

14:50.000 --> 14:53.000
If the implementation is wrong, it doesn't matter who cares.

14:53.000 --> 14:57.000
Anyway, so now what I can do is something like this,

14:57.000 --> 15:05.000
7% of big decimal 100, okay?

15:05.000 --> 15:07.000
Oh, no, sorry, money.

15:07.000 --> 15:08.000
So I can do money.

15:08.000 --> 15:10.000
No, don't clap yet.

15:11.000 --> 15:12.000
Money.

15:12.000 --> 15:14.000
Oh, let's just take the money I have.

15:14.000 --> 15:16.000
7% of popcorn, okay?

15:16.000 --> 15:17.000
Nice.

15:17.000 --> 15:22.000
Let's do a little bit nicer.

15:22.000 --> 15:25.000
What I want to do is, in fact, something like this,

15:25.000 --> 15:29.000
I want to do 7% of popcorn.

15:29.000 --> 15:31.000
That would be nice, and you can actually do that.

15:31.000 --> 15:32.000
You see that little wiggly there?

15:32.000 --> 15:33.000
It's wiggly.

15:33.000 --> 15:35.000
Alt, enter, add, infix.

15:35.000 --> 15:37.000
There you go, okay?

15:37.000 --> 15:41.000
So any extension function that has a single parameter

15:41.000 --> 15:43.000
can be called an infix notation,

15:43.000 --> 15:46.000
and what I've done is essentially add the infix over there.

15:46.000 --> 15:49.000
And this is some of the things that allow you now with Kotlin

15:49.000 --> 15:53.000
to kind of create the whole DSL approach to things.

15:53.000 --> 15:56.000
Right, so one thing that I hate doing here

15:56.000 --> 15:58.000
is all of this big decimal.

15:58.000 --> 16:00.000
That's a pain, right?

16:00.000 --> 16:03.000
And in Kotlin, when you want to create a value of type long,

16:03.000 --> 16:06.000
you can say long 100L, and that will be of type long.

16:06.000 --> 16:08.000
That would be awesome if I could do like,

16:08.000 --> 16:13.000
well, bd2 equals 100 bd, but you can't,

16:13.000 --> 16:14.000
and we don't have that built in.

16:14.000 --> 16:17.000
But what we do have in Kotlin is called extension properties.

16:17.000 --> 16:19.000
So they're exactly like extension functions,

16:19.000 --> 16:22.000
except they extend with properties.

16:22.000 --> 16:27.000
So I could do something like .bd, right?

16:27.000 --> 16:30.000
And now, or let's, yeah.

16:30.000 --> 16:32.000
So now, see, it even says, hey,

16:32.000 --> 16:35.000
do you want to create an extension property on type integer?

16:35.000 --> 16:39.000
So this is going to return a big decimal, right?

16:39.000 --> 16:47.000
And then, here, I'm going to do return, big decimal,

16:47.000 --> 16:49.000
and this, which is the instance, right?

16:49.000 --> 16:51.000
And I can, in fact, convert this to an expression

16:51.000 --> 16:53.000
to make it easier, right?

16:53.000 --> 16:54.000
So there you go.

16:54.000 --> 16:57.000
Now I have 100.bd.

16:57.000 --> 16:58.000
So when I'm passing that in,

16:58.000 --> 17:00.000
it looks much nicer than big decimal.

17:00.000 --> 17:04.000
I could just do 100.bd, okay?

17:04.000 --> 17:13.000
And one other thing around functions that you can do

17:13.000 --> 17:16.000
is there are certain operators that you can extend.

17:16.000 --> 17:19.000
So you can extend, for example, the plus operator.

17:19.000 --> 17:21.000
And what I'm going to do is I'm not going to type this out.

17:21.000 --> 17:24.000
I've just got a nice little thingy that has done that for me.

17:24.000 --> 17:26.000
See how fast I am at typing.

17:26.000 --> 17:28.000
So what I've essentially done is now

17:28.000 --> 17:30.000
override the plus operator for money.

17:30.000 --> 17:38.000
So now I can say cost equals tickets plus popcorn, right?

17:38.000 --> 17:41.000
And that allows me to add to monetary amounts, okay?

17:41.000 --> 17:43.000
And you can do that with plus, minus, multiply.

17:43.000 --> 17:46.000
A bunch of built-in conventions that you can follow

17:46.000 --> 17:50.000
for certain operators that allow you to do that.

17:50.000 --> 17:51.000
Okay.

17:51.000 --> 17:53.000
So we've been creating a whole bunch of types here.

17:53.000 --> 17:57.000
And let me go ahead and delete all this stuff so we can focus.

17:57.000 --> 17:59.000
We've been creating a bunch of types here.

17:59.000 --> 18:01.000
Notice that in any of these types that I've created,

18:01.000 --> 18:04.000
I've never actually specified the type.

18:04.000 --> 18:05.000
And you can.

18:05.000 --> 18:11.000
So I can do, for instance, val, train costs, for example,

18:11.000 --> 18:17.000
train is of type money, and then initialize it to some new value,

18:17.000 --> 18:18.000
right?

18:18.000 --> 18:22.000
100.pd and then dollars.

18:22.000 --> 18:25.000
Now, if I go ahead and do train equals null,

18:25.000 --> 18:26.000
it's going to give me an error.

18:26.000 --> 18:28.000
And it's going to give me actually two errors.

18:28.000 --> 18:31.000
One of them is because that's immutable variable.

18:31.000 --> 18:32.000
So I can fix that.

18:32.000 --> 18:34.000
I've now made this mutable.

18:34.000 --> 18:36.000
You see that the ID underlines it.

18:36.000 --> 18:38.000
So it kind of, like, wants to point it out that, you know,

18:38.000 --> 18:41.000
this is really something you're going to shy away from.

18:41.000 --> 18:43.000
We don't enforce immutability in Kotlin,

18:43.000 --> 18:45.000
but we kind of do recommend it.

18:45.000 --> 18:49.000
Like, all of the lists and all of these things are immutable by default.

18:49.000 --> 18:54.000
So I can't assign null in Kotlin because Kotlin tries to get rid of the null

18:54.000 --> 18:57.000
pointer exception by saying that types aren't nullable by default,

18:57.000 --> 18:58.000
right?

18:58.000 --> 19:01.000
But there are times when you want to have a type that is nullable

19:01.000 --> 19:06.000
for whatever reason, you're bored, and you can add a question mark,

19:06.000 --> 19:10.000
and then that will give you the ability to assign null to that type,

19:10.000 --> 19:11.000
right?

19:11.000 --> 19:12.000
Now, normally, when you're working with Kotlin,

19:12.000 --> 19:13.000
you probably don't want to do this.

19:13.000 --> 19:15.000
You probably don't want to have nullable types.

19:15.000 --> 19:21.000
But since we're interupping with Java, Java can be null.

19:21.000 --> 19:25.000
So if I create a function here that is, for instance,

19:25.000 --> 19:31.000
fun Java money, and that takes money of type Java money

19:31.000 --> 19:34.000
and does whatever with it, right?

19:34.000 --> 19:44.000
So let's say I do print line money.amount is valid.

19:44.000 --> 19:47.000
So this can be null.

19:47.000 --> 19:50.000
It could, you know, if it's called by an instance that a function that,

19:50.000 --> 19:52.000
for example, is returning this type, it could be null.

19:52.000 --> 19:55.000
And you can indicate that by adding the question mark.

19:55.000 --> 19:59.000
When you do that, you can see that the IDE is going to give you an error,

19:59.000 --> 20:00.000
right?

20:00.000 --> 20:03.000
It says only safe operators or the double exclamation mark are valid here,

20:03.000 --> 20:06.000
because it's essentially saying you're going to run into a null reference

20:06.000 --> 20:07.000
exception.

20:07.000 --> 20:08.000
So there's two ways you can solve this.

20:08.000 --> 20:12.000
First of all, you can say, for example, money, not null,

20:12.000 --> 20:16.000
and then do, like, if not null, then go ahead and operate with it.

20:16.000 --> 20:21.000
You know, put this one upstairs in there, OK?

20:21.000 --> 20:22.000
That's one way.

20:22.000 --> 20:27.000
Or the shorter way is just to use the safe operator or Elvis operator,

20:27.000 --> 20:28.000
which is over here.

20:28.000 --> 20:33.000
So now we just say, if money is not null, then do something.

20:33.000 --> 20:36.000
Now, if you want to have fun, you can also do that.

20:36.000 --> 20:41.000
And that says, I know it's null, but I want to shoot myself in the foot, OK?

20:41.000 --> 20:44.000
And you've got to be careful with that, because a lot of times when people

20:44.000 --> 20:48.000
start with Kotlin, they get all of these little squigglies over here,

20:48.000 --> 20:50.000
and they're like, well, I actually don't know if it's going to be null,

20:50.000 --> 20:52.000
because I really want it to not be null.

20:52.000 --> 20:56.000
So I'm not going to handle the case where it's not null, so I'll just do that.

20:56.000 --> 20:58.000
And then they run the app, and they're like, wait a minute,

20:58.000 --> 21:01.000
you said Kotlin got rid of null reference exceptions.

21:01.000 --> 21:04.000
Yes.

21:04.000 --> 21:06.000
OK.

21:06.000 --> 21:07.000
What else?

21:07.000 --> 21:08.000
Right.

21:08.000 --> 21:11.000
So let's switch to some other stuff, like higher order functions.

21:11.000 --> 21:13.000
Now, you're all familiar with a higher order function,

21:13.000 --> 21:16.000
which is basically a function that takes a function or returns a function.

21:16.000 --> 21:18.000
And we have those in Kotlin.

21:18.000 --> 21:22.000
So we can say, find emails, users, list of user,

21:22.000 --> 21:25.000
and then I'll create a new function, which is a predicate.

21:25.000 --> 21:28.000
So I'm passing in a function here, a function that takes a string

21:28.000 --> 21:31.000
and returns a boolean, OK?

21:31.000 --> 21:35.000
And then this probably is going to return a list of users.

21:35.000 --> 21:39.000
So essentially what I'm doing is I'm filtering on a list of users, right?

21:39.000 --> 21:42.000
So I'll do this later.

21:43.000 --> 21:46.000
To do, later.

21:46.000 --> 21:47.000
OK.

21:47.000 --> 21:49.000
This to do, by the way, is built in.

21:49.000 --> 21:51.000
You can use it instead of non-implemented exception,

21:51.000 --> 21:55.000
a non-implemented error, and it does an additional thing that we won't get into.

21:55.000 --> 21:58.000
But nothing is actually very nice in Kotlin,

21:58.000 --> 22:02.000
but we won't cover that now.

22:02.000 --> 22:06.000
It's nothing to worry about.

22:06.000 --> 22:07.000
I just made that up.

22:07.000 --> 22:08.000
OK.

22:08.000 --> 22:09.000
Good.

22:09.000 --> 22:10.000
OK.

22:10.000 --> 22:11.000
Thank you.

22:12.000 --> 22:13.000
Now, how do I use this?

22:13.000 --> 22:16.000
So I can do find emails, right?

22:16.000 --> 22:18.000
And I'll say, I actually have a user.

22:18.000 --> 22:20.000
Let's create some users here.

22:20.000 --> 22:23.000
So users from JSON file, and I have some users over here.

22:23.000 --> 22:24.000
So users JSON.

22:24.000 --> 22:28.000
So this is actually a function that I have ready,

22:28.000 --> 22:31.000
which is basically using JSON to read some users from a file.

22:31.000 --> 22:34.000
And this is a typical data class that you've already seen.

22:34.000 --> 22:40.000
The only new thing here is that this also got an enum class with a property role, OK?

22:40.000 --> 22:45.000
So now I can do users, and then I'll pass in that function.

22:45.000 --> 22:48.000
Now I can pass in the name function by using the colon, colon reference,

22:48.000 --> 22:50.000
or I can pass in a lambda.

22:50.000 --> 22:52.000
And in Kotlin, lambda follows this syntax.

22:52.000 --> 22:57.000
You pass in the parameter name, and then you say, for example,

22:57.000 --> 23:01.000
the parameter name ends with .com, right?

23:01.000 --> 23:04.000
So I'm getting a list of users that end with .com.

23:05.000 --> 23:09.000
Now, when you have a single parameter in Kotlin,

23:09.000 --> 23:15.000
you can actually admit having to explicitly mention it and replace it with it, OK?

23:15.000 --> 23:17.000
So similar to Groovy, you can just use it.

23:17.000 --> 23:22.000
The other thing that you can do in Kotlin is when the last parameter to a function is another function,

23:22.000 --> 23:28.000
you can actually not include it in the brackets.

23:28.000 --> 23:32.000
So it feels a little bit like it's outside.

23:32.000 --> 23:36.000
This is, again, one of the characteristics that allow us to create nice DSLs,

23:36.000 --> 23:38.000
and you can even do this like multi-line.

23:38.000 --> 23:44.000
So if you look at fine emails now, in a sense, it could actually feel like it's part of the language,

23:44.000 --> 23:46.000
but it isn't. It's actually a function.

23:46.000 --> 23:53.000
And when we implemented asynchronous programming with coroutines,

23:53.000 --> 23:55.000
we didn't like, you know, if you're familiar with C-sharp,

23:55.000 --> 23:58.000
C-sharp does that sync a weight, the keywords in the language.

23:58.000 --> 24:01.000
In Kotlin, they're not. They're essentially just functions, OK?

24:01.000 --> 24:06.000
That gives you the flexibility of deciding how you want to do different things.

24:06.000 --> 24:10.000
Now, you don't have to do all of these things because all of these things are built in.

24:10.000 --> 24:14.000
So for example, if I say .com users, I say users, filter,

24:14.000 --> 24:20.000
and you can see that as I complete this, it actually opts for the version of including out of the parameter.

24:20.000 --> 24:27.000
So I can say the email ends with .com,

24:27.000 --> 24:32.000
and then I can go and sort by it.id,

24:32.000 --> 24:45.000
and then let's go ahead and do, for example, map that to a pair of it.email and it.username, OK?

24:45.000 --> 24:49.000
So all of these functions are actually built in in that small standard library that ships

24:49.000 --> 24:51.000
but you're not going to have problems on Android. It's very small.

24:51.000 --> 24:58.000
And they're all essentially extension functions on top of collections, generic collections, right?

24:58.000 --> 25:05.000
So you have all of those functional things that, you know, are very in fashion these days.

25:05.000 --> 25:10.000
And so this obviously gives me a pair,

25:10.000 --> 25:18.000
and in fact, you can do this even nicer if instead of doing pair, it to so a map,

25:18.000 --> 25:21.000
email to username, and guess what it is?

25:21.000 --> 25:27.000
It's just an infix function that creates a pair, OK?

25:27.000 --> 25:29.000
Now, sometimes I don't want to go through the whole map.

25:29.000 --> 25:33.000
I just want to, for example, say get back a single element.

25:33.000 --> 25:39.000
And what you can also do is destructure classes, data classes in Kotlin.

25:39.000 --> 25:44.000
So I could do something like ID, username, and email, OK?

25:44.000 --> 25:47.000
And then I could just, like, you know, use the ID.

25:47.000 --> 25:51.000
And this is great, but then the IDE complains and says, well, this variable is never used.

25:51.000 --> 25:56.000
In that case, you can actually replace that with an underscore, right?

25:56.000 --> 25:58.000
So there you go.

25:58.000 --> 26:01.000
And you can destructure the values you want, anything that you don't want to use,

26:01.000 --> 26:04.000
replace with an underscore, and you're good to go.

26:04.000 --> 26:08.000
Right. So what else can I show you?

26:08.000 --> 26:11.000
OK, so I've got some other code here.

26:11.000 --> 26:16.000
If you're familiar with the concept of algebraic data types, it's essentially one type,

26:16.000 --> 26:19.000
a type that can be of one type or another, like, for instance, a Boolean.

26:19.000 --> 26:22.000
Now, in Kotlin, the way that we do that is with seal classes.

26:22.000 --> 26:25.000
But before I get into that, let me go ahead and do an open here, right?

26:25.000 --> 26:29.000
Notice the first thing here that user result is giving me an error,

26:29.000 --> 26:33.000
because by default in Kotlin, you cannot inherit from classes.

26:33.000 --> 26:35.000
So all classes are essentially final.

26:35.000 --> 26:41.000
If you want to inherit from classes, you have to use the open modifier, right?

26:41.000 --> 26:43.000
Now, I've used the sealed.

26:43.000 --> 26:48.000
And the sealed is essentially saying that this is the hierarchy that user result has.

26:48.000 --> 26:54.000
Like, there's not going to be any other class anywhere that is going to inherit from user result.

26:54.000 --> 26:58.000
Everything that's going to inherit from user result has to be in the same file,

26:58.000 --> 27:01.000
or you can make these, of course, subclasses.

27:01.000 --> 27:06.000
So I could move this up there, and this would be a subclass,

27:06.000 --> 27:10.000
but then I would have to prefix it with user result, right?

27:10.000 --> 27:16.000
Okay, now, I've just created it as classes outside.

27:16.000 --> 27:20.000
So why would I want to do this?

27:20.000 --> 27:22.000
Because it looks good.

27:22.000 --> 27:25.000
Well, this is actually good, because when you're doing some things,

27:25.000 --> 27:28.000
it's often like you're invoking a function and you're like,

27:28.000 --> 27:31.000
okay, well, if it's successful, I want it to return a value.

27:31.000 --> 27:33.000
If it's not, I'm going to pass in a message,

27:33.000 --> 27:38.000
and then you get up this type that contains the values that you want to return when it's successful,

27:38.000 --> 27:41.000
it contains the types that you want to return when there's a message,

27:41.000 --> 27:47.000
and then you've got to figure out the semantics of which properties are applied to an error situation,

27:47.000 --> 27:49.000
which properties are applied to a non-error situation,

27:49.000 --> 27:51.000
or you can just throw an exception.

27:51.000 --> 27:55.000
In this case, you can use a function that basically returns two types,

27:55.000 --> 27:58.000
and then, based on the result, do different things.

27:58.000 --> 28:01.000
So here, I say, for instance, when...

28:01.000 --> 28:08.000
Let's create an instant value result equals user result.

28:08.000 --> 28:10.000
Sorry, retrieve users.

28:10.000 --> 28:17.000
Okay, so now I can do when result is success,

28:17.000 --> 28:21.000
then we're going to do, for instance, well, we're going to get the result,

28:21.000 --> 28:26.000
and then we're going to do users for each...

28:26.000 --> 28:33.000
Oh, for each print line, the name, okay?

28:33.000 --> 28:36.000
User name.

28:36.000 --> 28:46.000
And then we're going to do a failure result print line result.message, okay?

28:46.000 --> 28:50.000
So now, based on the result, based on the type that is returned to me,

28:50.000 --> 28:52.000
I can do different things.

28:52.000 --> 28:55.000
And notice one thing over here, that this is gone green.

28:55.000 --> 28:57.000
I don't know if you see it on the big screen, but this is gone green.

28:57.000 --> 29:00.000
And this is a smart cast, so that's another thing that we have in Kotlin,

29:00.000 --> 29:05.000
and you saw that when I was doing the null check that it said this is not null

29:05.000 --> 29:09.000
because it's smart casting, so you don't have to explicitly come over here again

29:09.000 --> 29:13.000
and say, oh, you know, I know that this is of type success,

29:13.000 --> 29:17.000
let me go ahead and cast this to type success to then access the property.

29:17.000 --> 29:19.000
The compiler will do that for you.

29:19.000 --> 29:22.000
That's what the smart casting is.

29:22.000 --> 29:23.000
Right.

29:23.000 --> 29:27.000
And last but not least, before I hand it off to Andre, quickly just mention also

29:27.000 --> 29:30.000
that a lot of the things that you've been seeing with the filter map,

29:30.000 --> 29:36.000
all of those things, those are essentially eager evaluation, right?

29:36.000 --> 29:39.000
But we also have the ability to do lazy evaluation.

29:39.000 --> 29:43.000
So I can do val, for example, sorry, generate sequence,

29:43.000 --> 29:46.000
and then have something, for instance, one.

29:46.000 --> 29:57.000
And then here we'll do it times 10, and then we'll do values, right?

29:57.000 --> 30:07.000
Now I'll say values, take 10, and then for each, print line it.

30:07.000 --> 30:11.000
Now this is essentially creating a sequence, a generator that is infinite.

30:11.000 --> 30:12.000
It's never going to stop.

30:12.000 --> 30:14.000
It's going to start at 1 and multiply by 10.

30:14.000 --> 30:19.000
But what I'm saying here is that I just want to take 10 elements and then print them out.

30:19.000 --> 30:28.000
And what it will do is basically consume that until it hits 10, it prints out, go away.

30:28.000 --> 30:35.000
It prints out a beautiful Christmas tree that's one-sided.

30:36.000 --> 30:39.000
Pyramid, whatever, and stops there.

30:39.000 --> 30:43.000
And anything that you have, like, for example, the users that we had,

30:43.000 --> 30:50.000
you know, users from JSON, users.json, you can say as sequence

30:50.000 --> 30:52.000
and convert it into lazy evaluation as well.

30:52.000 --> 30:55.000
Okay, that's all we have the time to show you today.

30:55.000 --> 30:57.000
Obviously there's way more to the language.

30:57.000 --> 31:01.000
Go online, learn everything about it, and thank you very much,

31:01.000 --> 31:02.000
and I'll hand it off to Andre.

31:02.000 --> 31:07.000
Thank you, Hadi.

31:07.000 --> 31:09.000
Hello, everybody.

31:09.000 --> 31:14.000
So as you've seen, Kotlin already has many things in store,

31:14.000 --> 31:19.000
but I'm the nasty person who adds new features before you learn the existing ones.

31:19.000 --> 31:23.000
So I'll be telling you stories now, but I'll need to find a clicker.

31:23.000 --> 31:25.000
You have a clicker?

31:25.000 --> 31:26.000
No.

31:26.000 --> 31:27.000
Okay.

31:27.000 --> 31:30.000
Okay, so I'll be telling stories without a clicker.

31:31.000 --> 31:36.000
So my job here is to tell you about what we're going to have in the future versions of Kotlin.

31:36.000 --> 31:38.000
Oh, thank you very much.

31:38.000 --> 31:40.000
Okay.

31:40.000 --> 31:46.000
And the first big thing we're working on now is platforms,

31:46.000 --> 31:48.000
supporting different platforms.

31:48.000 --> 31:52.000
So historically, Kotlin compiles to JVM bytecode,

31:52.000 --> 31:54.000
same as the Java programming language.

31:54.000 --> 32:00.000
So we can run on the server, on the desktop, and of course on Android.

32:00.000 --> 32:03.000
And it's just the same bytecode everywhere.

32:03.000 --> 32:07.000
This is why we can run all versions of Android as well as new ones.

32:07.000 --> 32:11.000
But the story doesn't end there because we're adding new platforms,

32:11.000 --> 32:15.000
and recently we've added...

32:15.000 --> 32:19.000
The God doesn't like platforms.

32:19.000 --> 32:21.000
Recently, we added JavaScript,

32:21.000 --> 32:24.000
which means Kotlin can now compile to JavaScript code

32:24.000 --> 32:27.000
and run in the browser or on Node.js.

32:27.000 --> 32:32.000
So now we support three major, very popular virtual machines,

32:32.000 --> 32:36.000
JVM, Android, Dalvik, and JavaScript VMs.

32:36.000 --> 32:40.000
But there are many use cases where a virtual machine is not practical

32:40.000 --> 32:42.000
or is simply unavailable.

32:42.000 --> 32:47.000
For example, for iOS, virtual machines are severely restricted.

32:47.000 --> 32:49.000
You can do dynamic code generation.

32:49.000 --> 32:52.000
Or for a small embedded system, a VM doesn't fit in.

32:52.000 --> 32:59.000
Or for, say, a Linux command-line tool, the VM will be starting to for too long.

32:59.000 --> 33:01.000
So let's now go there.

33:01.000 --> 33:04.000
And that's why we're working on something called Kotlin Native.

33:04.000 --> 33:07.000
It's currently available as a technology preview.

33:07.000 --> 33:12.000
And there, we basically use LLVM to compile Kotlin down to native code

33:12.000 --> 33:15.000
to standalone binaries that can run on different platforms.

33:15.000 --> 33:18.000
Currently, we support iOS, Linux, and Mac.

33:18.000 --> 33:21.000
And Windows is in the works.

33:21.000 --> 33:26.000
So this is taking us to this vision with Kotlin

33:26.000 --> 33:31.000
when it can run inside every component of a modern application

33:31.000 --> 33:33.000
on any platform you like.

33:33.000 --> 33:38.000
So think full-stack web applications with the server and the client,

33:38.000 --> 33:40.000
both written in Kotlin.

33:40.000 --> 33:44.000
Or think we use code between mobile platforms, Android and iOS

33:44.000 --> 33:48.000
for example, or mix the two previous use cases

33:48.000 --> 33:51.000
and get a real multi-platform scenario.

33:51.000 --> 33:57.000
So our vision for Kotlin is having different modules in the same project

33:57.000 --> 34:00.000
compiled to different platforms.

34:00.000 --> 34:02.000
And of course, you want to share code there, right?

34:02.000 --> 34:05.000
Because if you support so many different things,

34:05.000 --> 34:07.000
you want to run the same code in different places.

34:07.000 --> 34:10.000
And we're working on making that possible.

34:10.000 --> 34:13.000
But there is a very important thing

34:13.000 --> 34:18.000
because previously, many projects tried to unify platforms.

34:18.000 --> 34:22.000
And this often ends up being like the least common denominator.

34:22.000 --> 34:26.000
When you take only things that are available on all platforms,

34:26.000 --> 34:29.000
you're basically stuck with a minimal interface.

34:29.000 --> 34:31.000
And that's something we don't want to have there.

34:31.000 --> 34:35.000
So we want you to be able to use all the platform-specific fancy APIs

34:35.000 --> 34:38.000
like the newest version of Android or something else,

34:38.000 --> 34:40.000
as much as you like.

34:40.000 --> 34:42.000
And if you want to share some code,

34:42.000 --> 34:47.000
only then you have to resort to some common APIs.

34:47.000 --> 34:49.000
So the idea there is that you have a common module

34:49.000 --> 34:52.000
with lots of business logic and stuff.

34:52.000 --> 34:55.000
And it can work side by side with a platform-specific module

34:55.000 --> 34:57.000
written also in Kotlin.

34:57.000 --> 34:59.000
And those two can talk to each other.

34:59.000 --> 35:02.000
So when you need, you leverage the platform API

35:02.000 --> 35:05.000
and when you need, you use the common code.

35:05.000 --> 35:10.000
So take away here, our future is multi-platform.

35:10.000 --> 35:12.000
Next...

35:12.000 --> 35:14.000
Oh.

35:14.000 --> 35:16.000
Yeah.

35:16.000 --> 35:20.000
And next big thing is coroutines.

35:20.000 --> 35:24.000
So the rationale there is pretty straightforward.

35:24.000 --> 35:27.000
Everybody needs to write a synchronous code, right?

35:27.000 --> 35:31.000
Because the world is too big now for sequential execution.

35:31.000 --> 35:36.000
And it's, yeah, it's our reality, but it's hard, right?

35:36.000 --> 35:39.000
Who has written a synchronous code?

35:39.000 --> 35:41.000
Quite so many hands.

35:41.000 --> 35:46.000
Those of you who don't actually will be doing this very soon.

35:46.000 --> 35:48.000
And the problem is that it's rather hard, actually,

35:48.000 --> 35:50.000
to write sequential code.

35:50.000 --> 35:55.000
Or it was hard before languages learned to support you in doing that

35:55.000 --> 35:57.000
because the language can help you there a lot.

35:57.000 --> 36:00.000
So basically, what we have with coroutines in Kotlin,

36:00.000 --> 36:04.000
you write asynchronous code the same way you write synchronous code.

36:04.000 --> 36:06.000
So what do you use in synchronous code?

36:06.000 --> 36:10.000
Loops, ifs, breaks and continues, things like that, right?

36:10.000 --> 36:15.000
And it's the same things you're using with coroutines for asynchronous code

36:15.000 --> 36:19.000
so that the language keeps track of everything

36:19.000 --> 36:22.000
and you don't have to express any intricate control flow

36:22.000 --> 36:25.000
for asynchronous computation in your code.

36:25.000 --> 36:29.000
No callbacks, no fancy functional structures.

36:29.000 --> 36:34.000
It's just plain old sequential looking code.

36:34.000 --> 36:36.000
And isn't it cool?

36:36.000 --> 36:40.000
Thank you.

36:40.000 --> 36:46.000
Yeah, so the idea with coroutines is that you basically have the same abstraction

36:46.000 --> 36:48.000
for asynchronous and synchronous.

36:48.000 --> 36:54.000
And also, it's a nice metaphor to think of them as almost free threads.

36:54.000 --> 36:58.000
Like here's the only code example I'm showing you.

36:59.000 --> 37:02.000
Basically, very many things that are traditionally done with threads

37:02.000 --> 37:05.000
can be done with coroutines, but coroutines are extremely cheap.

37:05.000 --> 37:10.000
So here on the slide, I have a code that creates 100,000 coroutines.

37:10.000 --> 37:11.000
Think about that.

37:11.000 --> 37:14.000
100,000 coroutines existing in parallel

37:14.000 --> 37:18.000
and each one of them waits for one second and returns one.

37:18.000 --> 37:25.000
So this program completes in one second,

37:26.000 --> 37:30.000
almost one second, because all the coroutines wait in parallel, of course.

37:30.000 --> 37:35.000
But if you try to do this with threads, it just doesn't work.

37:35.000 --> 37:38.000
100,000 threads don't fit into memory.

37:38.000 --> 37:39.000
That's it.

37:39.000 --> 37:42.000
So with coroutines, it's a win-win situation.

37:42.000 --> 37:46.000
You get lots of performance, so it's very efficient,

37:46.000 --> 37:48.000
and the code is simple.

37:48.000 --> 37:50.000
So take away here.

37:50.000 --> 37:54.000
Check out coroutines because our future will likely be even more asynchronous

37:54.000 --> 37:55.000
than our present.

37:57.000 --> 38:01.000
So I'm almost done, and if you want to learn more about Kotlin,

38:01.000 --> 38:02.000
check out our website.

38:02.000 --> 38:04.000
We have a section for Android.

38:04.000 --> 38:10.000
And also, we'll have a question-and-answer session right after this talk.

38:10.000 --> 38:15.000
So come over to the developer sandbox, section C.

38:15.000 --> 38:18.000
Myself and Hadi will be answering questions there.

38:18.000 --> 38:20.000
So thank you very much for your attention.

38:20.000 --> 38:21.000
Thank you.

