1
00:00:00,000 --> 00:00:05,000
We'll see you in the next video.

2
00:00:05,000 --> 00:00:10,000
Good morning, everyone.

3
00:00:10,000 --> 00:00:11,000
Wait.

4
00:00:11,000 --> 00:00:13,000
Don't cheer us.

5
00:00:13,000 --> 00:00:15,000
Cheer the next speakers.

6
00:00:15,000 --> 00:00:18,000
So I'm from the representing the platform team on Android.

7
00:00:18,000 --> 00:00:21,000
And this is representing the tools team.

8
00:00:21,000 --> 00:00:22,000
But you're not here for us.

9
00:00:22,000 --> 00:00:24,000
You're here for very special speakers.

10
00:00:24,000 --> 00:00:25,000
Yeah.

11
00:00:25,000 --> 00:00:28,000
So Roman and I have been incredibly excited about this official

12
00:00:28,000 --> 00:00:29,000
announcement of Kotlin.

13
00:00:29,000 --> 00:00:32,000
We both love Kotlin in case you haven't noticed already.

14
00:00:32,000 --> 00:00:35,000
And we don't want to take any more time from the speakers of honor.

15
00:00:35,000 --> 00:00:38,000
So without further ado, here they are.

16
00:00:38,000 --> 00:00:54,000
So hello, everyone.

17
00:00:54,000 --> 00:00:56,000
Oh, that's nice.

18
00:00:56,000 --> 00:00:58,000
So you know, I was thinking the other day,

19
00:00:58,000 --> 00:01:00,000
the first time that I ever did a talk in Kotlin,

20
00:01:00,000 --> 00:01:03,000
it was like four and a half years ago.

21
00:01:03,000 --> 00:01:05,000
And they gave me a room for 900 people,

22
00:01:05,000 --> 00:01:08,000
and seven people showed up.

23
00:01:08,000 --> 00:01:11,000
So it's kind of nice to see more of you show up today.

24
00:01:11,000 --> 00:01:16,000
Thank you.

25
00:01:16,000 --> 00:01:20,000
Anyway, I've got roughly around 30 minutes,

26
00:01:20,000 --> 00:01:23,000
actually 30, a little bit less,

27
00:01:23,000 --> 00:01:25,000
28 minutes to give you a whirlwind tour of Kotlin.

28
00:01:25,000 --> 00:01:27,000
So I'm not going to cover the entire language.

29
00:01:27,000 --> 00:01:31,000
I'm going to try and show you as much as I possibly can

30
00:01:31,000 --> 00:01:34,000
and how you can use it and where it provides you with some benefits.

31
00:01:34,000 --> 00:01:37,000
OK, so I'm going to try and do it all with live coding.

32
00:01:37,000 --> 00:01:41,000
So if it all goes terribly wrong, there's a Google video.

33
00:01:41,000 --> 00:01:44,000
I mean, there's a YouTube video of this somewhere as well.

34
00:01:44,000 --> 00:01:46,000
So you can watch that.

35
00:01:46,000 --> 00:01:48,000
OK, so we're going to start with something very simple

36
00:01:48,000 --> 00:01:50,000
that you've already seen, data class.

37
00:01:50,000 --> 00:01:54,000
And I'm in a file called main, right?

38
00:01:54,000 --> 00:01:57,000
So data class, I'm going to create a new type called money,

39
00:01:57,000 --> 00:02:00,000
and it's going to have an amount, which is of type int.

40
00:02:00,000 --> 00:02:02,000
I know, don't say anything for now.

41
00:02:02,000 --> 00:02:07,000
And it's going to have a currency of type string, OK?

42
00:02:07,000 --> 00:02:09,000
And this is both properties,

43
00:02:09,000 --> 00:02:11,000
and they're going to be read-only properties.

44
00:02:11,000 --> 00:02:13,000
So this is something that you're already familiar with.

45
00:02:13,000 --> 00:02:15,000
It's essentially a data class.

46
00:02:15,000 --> 00:02:21,000
Let's go ahead and compare that to a Java one that I have done earlier.

47
00:02:21,000 --> 00:02:23,000
So split vertically.

48
00:02:23,000 --> 00:02:25,000
And let's get the Java money up.

49
00:02:25,000 --> 00:02:28,000
Actually, let's get it on this side.

50
00:02:28,000 --> 00:02:30,000
Java money.

51
00:02:30,000 --> 00:02:32,000
So there you go.

52
00:02:32,000 --> 00:02:35,000
That's kind of the equivalent of what I've just written, right?

53
00:02:35,000 --> 00:02:39,000
A Java being essentially a data class that provides two getters.

54
00:02:39,000 --> 00:02:42,000
They're immutable, so they're read-only.

55
00:02:42,000 --> 00:02:45,000
And this data modifier over here, what that's doing is essentially

56
00:02:45,000 --> 00:02:47,000
giving me a whole bunch of things like the two string.

57
00:02:47,000 --> 00:02:51,000
It's giving me the clone, which in Kotlin is called copy.

58
00:02:51,000 --> 00:02:53,000
It's doing the equals.

59
00:02:53,000 --> 00:02:54,000
It's doing the hash code.

60
00:02:54,000 --> 00:02:56,000
Now you say, OK, well, that's great.

61
00:02:56,000 --> 00:02:57,000
Brilliant.

62
00:02:57,000 --> 00:02:58,000
But why do I need that?

63
00:02:58,000 --> 00:03:01,000
Because any good IDE is going to generate that for me.

64
00:03:01,000 --> 00:03:02,000
It is true.

65
00:03:02,000 --> 00:03:03,000
It does.

66
00:03:03,000 --> 00:03:05,000
But the problem is that that's code you're going to have to maintain.

67
00:03:05,000 --> 00:03:06,000
And every time you add a new property,

68
00:03:06,000 --> 00:03:08,000
you're going to have to go back and change that code.

69
00:03:08,000 --> 00:03:10,000
And the other issue you're going to have is you don't know,

70
00:03:10,000 --> 00:03:13,000
in fact, if that code is the standard stuff

71
00:03:13,000 --> 00:03:17,000
that your IDE has generated for you,

72
00:03:17,000 --> 00:03:19,000
or you've tweaked it a little bit, OK?

73
00:03:19,000 --> 00:03:23,000
So it's not just about saving on typing on the first slide.

74
00:03:23,000 --> 00:03:24,000
Right.

75
00:03:24,000 --> 00:03:27,000
Now what I'm going to do is go ahead and create a function main.

76
00:03:27,000 --> 00:03:29,000
Let's close this guy over here.

77
00:03:29,000 --> 00:03:31,000
And this is like the top entry point of Kotlin.

78
00:03:31,000 --> 00:03:35,000
So you have a public static void main in a class.

79
00:03:35,000 --> 00:03:37,000
You don't need that in Kotlin.

80
00:03:37,000 --> 00:03:39,000
So in Kotlin, you can put everything in the top level.

81
00:03:39,000 --> 00:03:42,000
It's kind of like JavaScript in a good way.

82
00:03:42,000 --> 00:03:48,000
And so you don't have to, and just I want to reiterate,

83
00:03:48,000 --> 00:03:50,000
like every function and everything that I'll show you today,

84
00:03:50,000 --> 00:03:53,000
I'm going to just add it in the file as a top level thing.

85
00:03:53,000 --> 00:03:57,000
But that doesn't mean that you don't have any more member functions.

86
00:03:57,000 --> 00:04:00,000
Anything, any class, even a data class can have member functions.

87
00:04:00,000 --> 00:04:03,000
But for brevity and for the purpose of what I'm showing you,

88
00:04:03,000 --> 00:04:06,000
I'm just going to put it as top level, OK?

89
00:04:06,000 --> 00:04:08,000
So I'm going to create a new instance of money.

90
00:04:08,000 --> 00:04:11,000
We're going to call it, for example, tickets.

91
00:04:11,000 --> 00:04:13,000
And I'll say money, 100.

92
00:04:13,000 --> 00:04:16,000
And it's going to be dollars, right?

93
00:04:16,000 --> 00:04:20,000
And I'll get into the explicit type here.

94
00:04:20,000 --> 00:04:22,000
But essentially here, what I'm doing is type inference.

95
00:04:22,000 --> 00:04:24,000
So Kotlin is very strong in type inference.

96
00:04:24,000 --> 00:04:26,000
And as much as it can infer, it will for you.

97
00:04:26,000 --> 00:04:29,000
So you don't have to explicitly tell the type.

98
00:04:29,000 --> 00:04:32,000
And then I'll say, for example, popcorn.

99
00:04:32,000 --> 00:04:37,000
Let's say tickets, copy, right?

100
00:04:37,000 --> 00:04:42,000
So that's what that's going to do is basically copy the previous one for me

101
00:04:42,000 --> 00:04:44,000
and all of the properties.

102
00:04:44,000 --> 00:04:47,000
So if I don't pass any parameters in,

103
00:04:47,000 --> 00:04:50,000
it's going to just take the same values as it has before, OK?

104
00:04:50,000 --> 00:04:53,000
So I can pass in a new parameter, say, like, you know, I mean, in Spain,

105
00:04:53,000 --> 00:04:57,000
for example, popcorn is seven times the price of the entry of the cinema.

106
00:04:57,000 --> 00:05:01,000
So that's going to be like 500 euros, right?

107
00:05:01,000 --> 00:05:04,000
And now I can do things like, for instance, you know,

108
00:05:04,000 --> 00:05:10,000
if tickets is not equal to popcorn,

109
00:05:10,000 --> 00:05:16,000
then print line, they are different, right?

110
00:05:16,000 --> 00:05:20,000
So what this is doing is a property comparison one by one.

111
00:05:20,000 --> 00:05:22,000
It's not doing a pointer comparison.

112
00:05:22,000 --> 00:05:25,000
For pointer comparisons, we have the triple equal, right?

113
00:05:25,000 --> 00:05:29,000
Different to JavaScript, there isn't like a chart of 600 different positions

114
00:05:29,000 --> 00:05:30,000
you have to remember.

115
00:05:30,000 --> 00:05:34,000
So, and this, by the way, is font ligatures.

116
00:05:34,000 --> 00:05:35,000
So don't get confused with that.

117
00:05:35,000 --> 00:05:37,000
We didn't introduce a new symbol.

118
00:05:37,000 --> 00:05:38,000
OK.

119
00:05:38,000 --> 00:05:44,000
So I can go ahead and just, like, run this and I get they are different.

120
00:05:44,000 --> 00:05:50,000
And if I change this to 100 and I put this as dollars and I run this,

121
00:05:50,000 --> 00:05:54,000
it's going to say to you that nothing, because they are the same, OK?

122
00:05:54,000 --> 00:05:59,000
Now, one of the features we keep boosting about is the interop between Java and Kotlin.

123
00:05:59,000 --> 00:06:02,000
So we have this Java money one over here.

124
00:06:02,000 --> 00:06:05,000
So I'm going to go ahead and create an instance of it.

125
00:06:05,000 --> 00:06:10,000
And I'll say Java money equals Java money.

126
00:06:10,000 --> 00:06:13,000
And it will be 100 and it will be dollars.

127
00:06:13,000 --> 00:06:19,000
And then if I do Java money, you can see that I don't have any getters.

128
00:06:19,000 --> 00:06:23,000
Well, I do have actually a getter, so I can do get amount.

129
00:06:23,000 --> 00:06:28,000
But if I write get amount, completed, the ID is already going to replace that for property

130
00:06:28,000 --> 00:06:30,000
because we don't have really, like, getters and setters.

131
00:06:30,000 --> 00:06:32,000
We just have properties.

132
00:06:32,000 --> 00:06:36,000
So that's consuming Java from Kotlin.

133
00:06:36,000 --> 00:06:41,000
And if I go over to the Java over here and let's go ahead and create a public static void main

134
00:06:41,000 --> 00:06:52,000
and I'll do, so let's see, I've got a declarer type, money equals new money 100 and dollars.

135
00:06:52,000 --> 00:06:54,000
And, oh, OK.

136
00:06:54,000 --> 00:06:57,000
That's the other thing.

137
00:06:57,000 --> 00:07:00,000
The semicolons in Kotlin are optional.

138
00:07:00,000 --> 00:07:08,000
And the reason they're optional is so that you can have endless arguments over whether you should use them or not.

139
00:07:08,000 --> 00:07:10,000
We're trying to compete with JavaScript there.

140
00:07:10,000 --> 00:07:12,000
OK, so money.get amount.

141
00:07:12,000 --> 00:07:17,000
So now I'm using a Kotlin type from Java, so I'm getting the getters and the setters.

142
00:07:17,000 --> 00:07:22,000
So idiomatic, depending on how you are using it.

143
00:07:22,000 --> 00:07:29,000
And that's just different Java files, different Kotlin files in a single project working seamlessly without any issues.

144
00:07:29,000 --> 00:07:33,000
Right, so now let's go ahead and create some functions.

145
00:07:33,000 --> 00:07:42,000
So I'm going to create a function called send payment that takes some money and money and it's going to print line the money out.

146
00:07:42,000 --> 00:07:48,000
And of course we have string interpolation, so I can say sending money.amount.

147
00:07:48,000 --> 00:07:53,000
And you don't have to put these curly braces if it's just a single property that you're passing in, as we'll just see in a moment.

148
00:07:53,000 --> 00:07:57,000
So now I can call this and say, for example, send payment, tickets.

149
00:07:57,000 --> 00:08:04,000
Right, now Kotlin we also have, notice one thing here, I'm not defining the return type.

150
00:08:04,000 --> 00:08:08,000
OK, by default it's unit, which is kind of like void, but it's not.

151
00:08:08,000 --> 00:08:14,000
It's actually object, which is essentially a singleton and single instance of an object.

152
00:08:14,000 --> 00:08:18,000
And if it is a unit, you don't have to put it there, right?

153
00:08:18,000 --> 00:08:27,000
So I'm going to add a new parameter here, and I'm going to say, for example, with message, and this is going to have string, and you can have default parameters.

154
00:08:27,000 --> 00:08:31,000
So here, notice that there's no compilation error because I made a default parameter.

155
00:08:31,000 --> 00:08:35,000
This saves you a lot in terms of overloaded function, overloaded member functions, right?

156
00:08:35,000 --> 00:08:39,000
I can just, you know, have default parameters and then do what I want.

157
00:08:39,000 --> 00:08:50,000
And you can have multiple default parameters, and since you can have multiple default parameters and you can, you know, alternate which one you want to pass in, you can also do named parameters.

158
00:08:50,000 --> 00:08:59,000
So in fact, I could say message equals good luck, and money equals tickets, right?

159
00:08:59,000 --> 00:09:07,000
And this is kind of useful as well when you are using, you're talking to legacy code, for example, you know, some function that you can't modify,

160
00:09:07,000 --> 00:09:13,000
and it's got 600 parameters, and there are probably 500 of them are true and false Booleans.

161
00:09:13,000 --> 00:09:22,000
It kind of gives you some insight into what parameters I'm passing in in every position.

162
00:09:22,000 --> 00:09:26,000
Oh, yeah. I love it when people clap.

163
00:09:26,000 --> 00:09:37,000
And I'm thinking to myself, well, this is going well.

164
00:09:37,000 --> 00:09:43,000
Anyway, right. Let's go edit that out, like adult supervision.

165
00:09:43,000 --> 00:09:55,000
Right. One other thing with Kotlin is that when we have functions that are really, really easy, like essentially returning a single value, you can just do single expression functions.

166
00:09:55,000 --> 00:10:04,000
So I omit the return type explicitly, I omit the curly braces, and I just return the actual function that I want to do, okay?

167
00:10:04,000 --> 00:10:10,000
So in fact, this is like the concept of expression comes in many places in Kotlin.

168
00:10:10,000 --> 00:10:13,000
So for instance, let's create another function that's called convert to dollars.

169
00:10:13,000 --> 00:10:22,000
Convert to dollars, and this is going to take money, money, and it's going to return money.

170
00:10:22,000 --> 00:10:25,000
And then what we're going to do here is a when statement.

171
00:10:25,000 --> 00:10:27,000
So that's essentially a case, right?

172
00:10:27,000 --> 00:10:38,000
So when money currency is dollars, then we'll do return money as is, right?

173
00:10:38,000 --> 00:10:40,000
Because I don't need to do anything.

174
00:10:40,000 --> 00:10:43,000
And if it's euros, then what I'm going to do is return.

175
00:10:43,000 --> 00:10:53,000
We're going to do money amount times, sorry, I've got to create a new instance, money.

176
00:10:53,000 --> 00:11:04,000
And then it's going to be money amount times big decimal, 1.10, and then that's going to be dollars, right?

177
00:11:04,000 --> 00:11:14,000
And else, throw illegal argument exception, not the currency you're interested in.

178
00:11:14,000 --> 00:11:18,000
Okay, so this, you can actually treat a when as an expression.

179
00:11:18,000 --> 00:11:24,000
So I can remove this return over here, remove this return over here, put it just here,

180
00:11:24,000 --> 00:11:29,000
and then this just makes the when always return an expression.

181
00:11:29,000 --> 00:11:36,000
And in fact, you can even remove the return here, return, remove the money here,

182
00:11:36,000 --> 00:11:40,000
and remove that there, and you get a single expression, okay?

183
00:11:40,000 --> 00:11:42,000
Single expression function.

184
00:11:42,000 --> 00:11:45,000
Now, one thing that you'll notice here that this is giving me an error,

185
00:11:45,000 --> 00:11:49,000
because this is, you know, I'm trying to operate a big decimal with an int.

186
00:11:49,000 --> 00:11:51,000
So we're going to go and refactor this.

187
00:11:51,000 --> 00:11:54,000
I'm going to call it big decimal, okay?

188
00:11:54,000 --> 00:11:57,000
Now, talking about big decimal, oh, here we go.

189
00:11:57,000 --> 00:12:06,000
Big decimal, big decimal, 100, and big decimal.

190
00:12:06,000 --> 00:12:08,000
I love typing big decimal.

191
00:12:08,000 --> 00:12:11,000
I love it, okay?

192
00:12:11,000 --> 00:12:14,000
So we've got this over here.

193
00:12:14,000 --> 00:12:19,000
Now, if you look at actually big decimal, so if I create a new big decimal,

194
00:12:19,000 --> 00:12:23,000
we'll call it bd1 equals big decimal, 100.

195
00:12:23,000 --> 00:12:26,000
And you can see that bd1 gives me a whole bunch of functions,

196
00:12:26,000 --> 00:12:28,000
like divide, multiply, all of these things.

197
00:12:28,000 --> 00:12:30,000
What if I wanted to do something like a percent?

198
00:12:30,000 --> 00:12:33,000
I wanted to do a percentage of big decimal.

199
00:12:33,000 --> 00:12:38,000
Now, normally you would basically inherit from that

200
00:12:38,000 --> 00:12:40,000
and then create your own version and have all of these things,

201
00:12:40,000 --> 00:12:42,000
but in Kotlin, one of the features that we've added,

202
00:12:42,000 --> 00:12:45,000
and if you're familiar with C sharp, it's called extension functions,

203
00:12:45,000 --> 00:12:48,000
which essentially means that you can take any class, any type, and extend it.

204
00:12:48,000 --> 00:12:51,000
So I can take a function big decimal,

205
00:12:51,000 --> 00:12:53,000
I put the name of the class that I want to extend,

206
00:12:53,000 --> 00:12:55,000
and I say I want to do a percent,

207
00:12:55,000 --> 00:12:59,000
and what is the percentage that I want to do, for example, an integer,

208
00:12:59,000 --> 00:13:01,000
and then it would be, let's see.

209
00:13:01,000 --> 00:13:04,000
So given that this is an extension function,

210
00:13:04,000 --> 00:13:08,000
it's going to have an instance of that class, of that object, right?

211
00:13:08,000 --> 00:13:10,000
So I can use that, reference that with this.

212
00:13:10,000 --> 00:13:16,000
And I say this, multiply by the percentage,

213
00:13:16,000 --> 00:13:20,000
and then this has got to be wrapped in a big decimal again, percentage,

214
00:13:20,000 --> 00:13:29,000
and then that divides, and then another big decimal, 100.

215
00:13:29,000 --> 00:13:33,000
And what's wrong with this? That should be percentage.

216
00:13:33,000 --> 00:13:37,000
So percentage, okay?

217
00:13:37,000 --> 00:13:43,000
So now, what happens is that on BD1, I have percentage, okay?

218
00:13:43,000 --> 00:13:47,000
And I can do percent seven, and that would give me a seven percent.

219
00:13:47,000 --> 00:13:52,000
And that extension function gets included anywhere where it is defined in the package, right?

220
00:13:52,000 --> 00:13:55,000
So here in this case, I have it in com.getbrains.go,

221
00:13:55,000 --> 00:13:57,000
and that will get included there, right?

222
00:13:57,000 --> 00:13:59,000
So you can create extension functions,

223
00:13:59,000 --> 00:14:03,000
and we'll see that the standard library actually consists of a whole bunch of extension functions.

224
00:14:03,000 --> 00:14:06,000
Now, we'll take this one step further, because I can actually extend everything.

225
00:14:06,000 --> 00:14:09,000
So let's go ahead and extend an integer.

226
00:14:09,000 --> 00:14:16,000
So I'll say fun, int, percent of, and here we'll do the reverse.

227
00:14:16,000 --> 00:14:19,000
I want, like, 10% of something, right?

228
00:14:19,000 --> 00:14:22,000
So I'll say money, for instance, I want 10% of money,

229
00:14:22,000 --> 00:14:30,000
and that's going to return the, let's see, it's going to return money, right?

230
00:14:30,000 --> 00:14:33,000
Then it will be amount, multiply,

231
00:14:33,000 --> 00:14:36,000
and then here it's going to reference the actual instance,

232
00:14:36,000 --> 00:14:42,000
so it will be this, and again, this has to be wrapped in big decimal,

233
00:14:42,000 --> 00:14:47,000
and then divide by 100, okay?

234
00:14:47,000 --> 00:14:50,000
And I think I got that in the right order.

235
00:14:50,000 --> 00:14:53,000
If the implementation is wrong, it doesn't matter who cares.

236
00:14:53,000 --> 00:14:57,000
Anyway, so now what I can do is something like this,

237
00:14:57,000 --> 00:15:05,000
7% of big decimal 100, okay?

238
00:15:05,000 --> 00:15:07,000
Oh, no, sorry, money.

239
00:15:07,000 --> 00:15:08,000
So I can do money.

240
00:15:08,000 --> 00:15:10,000
No, don't clap yet.

241
00:15:11,000 --> 00:15:12,000
Money.

242
00:15:12,000 --> 00:15:14,000
Oh, let's just take the money I have.

243
00:15:14,000 --> 00:15:16,000
7% of popcorn, okay?

244
00:15:16,000 --> 00:15:17,000
Nice.

245
00:15:17,000 --> 00:15:22,000
Let's do a little bit nicer.

246
00:15:22,000 --> 00:15:25,000
What I want to do is, in fact, something like this,

247
00:15:25,000 --> 00:15:29,000
I want to do 7% of popcorn.

248
00:15:29,000 --> 00:15:31,000
That would be nice, and you can actually do that.

249
00:15:31,000 --> 00:15:32,000
You see that little wiggly there?

250
00:15:32,000 --> 00:15:33,000
It's wiggly.

251
00:15:33,000 --> 00:15:35,000
Alt, enter, add, infix.

252
00:15:35,000 --> 00:15:37,000
There you go, okay?

253
00:15:37,000 --> 00:15:41,000
So any extension function that has a single parameter

254
00:15:41,000 --> 00:15:43,000
can be called an infix notation,

255
00:15:43,000 --> 00:15:46,000
and what I've done is essentially add the infix over there.

256
00:15:46,000 --> 00:15:49,000
And this is some of the things that allow you now with Kotlin

257
00:15:49,000 --> 00:15:53,000
to kind of create the whole DSL approach to things.

258
00:15:53,000 --> 00:15:56,000
Right, so one thing that I hate doing here

259
00:15:56,000 --> 00:15:58,000
is all of this big decimal.

260
00:15:58,000 --> 00:16:00,000
That's a pain, right?

261
00:16:00,000 --> 00:16:03,000
And in Kotlin, when you want to create a value of type long,

262
00:16:03,000 --> 00:16:06,000
you can say long 100L, and that will be of type long.

263
00:16:06,000 --> 00:16:08,000
That would be awesome if I could do like,

264
00:16:08,000 --> 00:16:13,000
well, bd2 equals 100 bd, but you can't,

265
00:16:13,000 --> 00:16:14,000
and we don't have that built in.

266
00:16:14,000 --> 00:16:17,000
But what we do have in Kotlin is called extension properties.

267
00:16:17,000 --> 00:16:19,000
So they're exactly like extension functions,

268
00:16:19,000 --> 00:16:22,000
except they extend with properties.

269
00:16:22,000 --> 00:16:27,000
So I could do something like .bd, right?

270
00:16:27,000 --> 00:16:30,000
And now, or let's, yeah.

271
00:16:30,000 --> 00:16:32,000
So now, see, it even says, hey,

272
00:16:32,000 --> 00:16:35,000
do you want to create an extension property on type integer?

273
00:16:35,000 --> 00:16:39,000
So this is going to return a big decimal, right?

274
00:16:39,000 --> 00:16:47,000
And then, here, I'm going to do return, big decimal,

275
00:16:47,000 --> 00:16:49,000
and this, which is the instance, right?

276
00:16:49,000 --> 00:16:51,000
And I can, in fact, convert this to an expression

277
00:16:51,000 --> 00:16:53,000
to make it easier, right?

278
00:16:53,000 --> 00:16:54,000
So there you go.

279
00:16:54,000 --> 00:16:57,000
Now I have 100.bd.

280
00:16:57,000 --> 00:16:58,000
So when I'm passing that in,

281
00:16:58,000 --> 00:17:00,000
it looks much nicer than big decimal.

282
00:17:00,000 --> 00:17:04,000
I could just do 100.bd, okay?

283
00:17:04,000 --> 00:17:13,000
And one other thing around functions that you can do

284
00:17:13,000 --> 00:17:16,000
is there are certain operators that you can extend.

285
00:17:16,000 --> 00:17:19,000
So you can extend, for example, the plus operator.

286
00:17:19,000 --> 00:17:21,000
And what I'm going to do is I'm not going to type this out.

287
00:17:21,000 --> 00:17:24,000
I've just got a nice little thingy that has done that for me.

288
00:17:24,000 --> 00:17:26,000
See how fast I am at typing.

289
00:17:26,000 --> 00:17:28,000
So what I've essentially done is now

290
00:17:28,000 --> 00:17:30,000
override the plus operator for money.

291
00:17:30,000 --> 00:17:38,000
So now I can say cost equals tickets plus popcorn, right?

292
00:17:38,000 --> 00:17:41,000
And that allows me to add to monetary amounts, okay?

293
00:17:41,000 --> 00:17:43,000
And you can do that with plus, minus, multiply.

294
00:17:43,000 --> 00:17:46,000
A bunch of built-in conventions that you can follow

295
00:17:46,000 --> 00:17:50,000
for certain operators that allow you to do that.

296
00:17:50,000 --> 00:17:51,000
Okay.

297
00:17:51,000 --> 00:17:53,000
So we've been creating a whole bunch of types here.

298
00:17:53,000 --> 00:17:57,000
And let me go ahead and delete all this stuff so we can focus.

299
00:17:57,000 --> 00:17:59,000
We've been creating a bunch of types here.

300
00:17:59,000 --> 00:18:01,000
Notice that in any of these types that I've created,

301
00:18:01,000 --> 00:18:04,000
I've never actually specified the type.

302
00:18:04,000 --> 00:18:05,000
And you can.

303
00:18:05,000 --> 00:18:11,000
So I can do, for instance, val, train costs, for example,

304
00:18:11,000 --> 00:18:17,000
train is of type money, and then initialize it to some new value,

305
00:18:17,000 --> 00:18:18,000
right?

306
00:18:18,000 --> 00:18:22,000
100.pd and then dollars.

307
00:18:22,000 --> 00:18:25,000
Now, if I go ahead and do train equals null,

308
00:18:25,000 --> 00:18:26,000
it's going to give me an error.

309
00:18:26,000 --> 00:18:28,000
And it's going to give me actually two errors.

310
00:18:28,000 --> 00:18:31,000
One of them is because that's immutable variable.

311
00:18:31,000 --> 00:18:32,000
So I can fix that.

312
00:18:32,000 --> 00:18:34,000
I've now made this mutable.

313
00:18:34,000 --> 00:18:36,000
You see that the ID underlines it.

314
00:18:36,000 --> 00:18:38,000
So it kind of, like, wants to point it out that, you know,

315
00:18:38,000 --> 00:18:41,000
this is really something you're going to shy away from.

316
00:18:41,000 --> 00:18:43,000
We don't enforce immutability in Kotlin,

317
00:18:43,000 --> 00:18:45,000
but we kind of do recommend it.

318
00:18:45,000 --> 00:18:49,000
Like, all of the lists and all of these things are immutable by default.

319
00:18:49,000 --> 00:18:54,000
So I can't assign null in Kotlin because Kotlin tries to get rid of the null

320
00:18:54,000 --> 00:18:57,000
pointer exception by saying that types aren't nullable by default,

321
00:18:57,000 --> 00:18:58,000
right?

322
00:18:58,000 --> 00:19:01,000
But there are times when you want to have a type that is nullable

323
00:19:01,000 --> 00:19:06,000
for whatever reason, you're bored, and you can add a question mark,

324
00:19:06,000 --> 00:19:10,000
and then that will give you the ability to assign null to that type,

325
00:19:10,000 --> 00:19:11,000
right?

326
00:19:11,000 --> 00:19:12,000
Now, normally, when you're working with Kotlin,

327
00:19:12,000 --> 00:19:13,000
you probably don't want to do this.

328
00:19:13,000 --> 00:19:15,000
You probably don't want to have nullable types.

329
00:19:15,000 --> 00:19:21,000
But since we're interupping with Java, Java can be null.

330
00:19:21,000 --> 00:19:25,000
So if I create a function here that is, for instance,

331
00:19:25,000 --> 00:19:31,000
fun Java money, and that takes money of type Java money

332
00:19:31,000 --> 00:19:34,000
and does whatever with it, right?

333
00:19:34,000 --> 00:19:44,000
So let's say I do print line money.amount is valid.

334
00:19:44,000 --> 00:19:47,000
So this can be null.

335
00:19:47,000 --> 00:19:50,000
It could, you know, if it's called by an instance that a function that,

336
00:19:50,000 --> 00:19:52,000
for example, is returning this type, it could be null.

337
00:19:52,000 --> 00:19:55,000
And you can indicate that by adding the question mark.

338
00:19:55,000 --> 00:19:59,000
When you do that, you can see that the IDE is going to give you an error,

339
00:19:59,000 --> 00:20:00,000
right?

340
00:20:00,000 --> 00:20:03,000
It says only safe operators or the double exclamation mark are valid here,

341
00:20:03,000 --> 00:20:06,000
because it's essentially saying you're going to run into a null reference

342
00:20:06,000 --> 00:20:07,000
exception.

343
00:20:07,000 --> 00:20:08,000
So there's two ways you can solve this.

344
00:20:08,000 --> 00:20:12,000
First of all, you can say, for example, money, not null,

345
00:20:12,000 --> 00:20:16,000
and then do, like, if not null, then go ahead and operate with it.

346
00:20:16,000 --> 00:20:21,000
You know, put this one upstairs in there, OK?

347
00:20:21,000 --> 00:20:22,000
That's one way.

348
00:20:22,000 --> 00:20:27,000
Or the shorter way is just to use the safe operator or Elvis operator,

349
00:20:27,000 --> 00:20:28,000
which is over here.

350
00:20:28,000 --> 00:20:33,000
So now we just say, if money is not null, then do something.

351
00:20:33,000 --> 00:20:36,000
Now, if you want to have fun, you can also do that.

352
00:20:36,000 --> 00:20:41,000
And that says, I know it's null, but I want to shoot myself in the foot, OK?

353
00:20:41,000 --> 00:20:44,000
And you've got to be careful with that, because a lot of times when people

354
00:20:44,000 --> 00:20:48,000
start with Kotlin, they get all of these little squigglies over here,

355
00:20:48,000 --> 00:20:50,000
and they're like, well, I actually don't know if it's going to be null,

356
00:20:50,000 --> 00:20:52,000
because I really want it to not be null.

357
00:20:52,000 --> 00:20:56,000
So I'm not going to handle the case where it's not null, so I'll just do that.

358
00:20:56,000 --> 00:20:58,000
And then they run the app, and they're like, wait a minute,

359
00:20:58,000 --> 00:21:01,000
you said Kotlin got rid of null reference exceptions.

360
00:21:01,000 --> 00:21:04,000
Yes.

361
00:21:04,000 --> 00:21:06,000
OK.

362
00:21:06,000 --> 00:21:07,000
What else?

363
00:21:07,000 --> 00:21:08,000
Right.

364
00:21:08,000 --> 00:21:11,000
So let's switch to some other stuff, like higher order functions.

365
00:21:11,000 --> 00:21:13,000
Now, you're all familiar with a higher order function,

366
00:21:13,000 --> 00:21:16,000
which is basically a function that takes a function or returns a function.

367
00:21:16,000 --> 00:21:18,000
And we have those in Kotlin.

368
00:21:18,000 --> 00:21:22,000
So we can say, find emails, users, list of user,

369
00:21:22,000 --> 00:21:25,000
and then I'll create a new function, which is a predicate.

370
00:21:25,000 --> 00:21:28,000
So I'm passing in a function here, a function that takes a string

371
00:21:28,000 --> 00:21:31,000
and returns a boolean, OK?

372
00:21:31,000 --> 00:21:35,000
And then this probably is going to return a list of users.

373
00:21:35,000 --> 00:21:39,000
So essentially what I'm doing is I'm filtering on a list of users, right?

374
00:21:39,000 --> 00:21:42,000
So I'll do this later.

375
00:21:43,000 --> 00:21:46,000
To do, later.

376
00:21:46,000 --> 00:21:47,000
OK.

377
00:21:47,000 --> 00:21:49,000
This to do, by the way, is built in.

378
00:21:49,000 --> 00:21:51,000
You can use it instead of non-implemented exception,

379
00:21:51,000 --> 00:21:55,000
a non-implemented error, and it does an additional thing that we won't get into.

380
00:21:55,000 --> 00:21:58,000
But nothing is actually very nice in Kotlin,

381
00:21:58,000 --> 00:22:02,000
but we won't cover that now.

382
00:22:02,000 --> 00:22:06,000
It's nothing to worry about.

383
00:22:06,000 --> 00:22:07,000
I just made that up.

384
00:22:07,000 --> 00:22:08,000
OK.

385
00:22:08,000 --> 00:22:09,000
Good.

386
00:22:09,000 --> 00:22:10,000
OK.

387
00:22:10,000 --> 00:22:11,000
Thank you.

388
00:22:12,000 --> 00:22:13,000
Now, how do I use this?

389
00:22:13,000 --> 00:22:16,000
So I can do find emails, right?

390
00:22:16,000 --> 00:22:18,000
And I'll say, I actually have a user.

391
00:22:18,000 --> 00:22:20,000
Let's create some users here.

392
00:22:20,000 --> 00:22:23,000
So users from JSON file, and I have some users over here.

393
00:22:23,000 --> 00:22:24,000
So users JSON.

394
00:22:24,000 --> 00:22:28,000
So this is actually a function that I have ready,

395
00:22:28,000 --> 00:22:31,000
which is basically using JSON to read some users from a file.

396
00:22:31,000 --> 00:22:34,000
And this is a typical data class that you've already seen.

397
00:22:34,000 --> 00:22:40,000
The only new thing here is that this also got an enum class with a property role, OK?

398
00:22:40,000 --> 00:22:45,000
So now I can do users, and then I'll pass in that function.

399
00:22:45,000 --> 00:22:48,000
Now I can pass in the name function by using the colon, colon reference,

400
00:22:48,000 --> 00:22:50,000
or I can pass in a lambda.

401
00:22:50,000 --> 00:22:52,000
And in Kotlin, lambda follows this syntax.

402
00:22:52,000 --> 00:22:57,000
You pass in the parameter name, and then you say, for example,

403
00:22:57,000 --> 00:23:01,000
the parameter name ends with .com, right?

404
00:23:01,000 --> 00:23:04,000
So I'm getting a list of users that end with .com.

405
00:23:05,000 --> 00:23:09,000
Now, when you have a single parameter in Kotlin,

406
00:23:09,000 --> 00:23:15,000
you can actually admit having to explicitly mention it and replace it with it, OK?

407
00:23:15,000 --> 00:23:17,000
So similar to Groovy, you can just use it.

408
00:23:17,000 --> 00:23:22,000
The other thing that you can do in Kotlin is when the last parameter to a function is another function,

409
00:23:22,000 --> 00:23:28,000
you can actually not include it in the brackets.

410
00:23:28,000 --> 00:23:32,000
So it feels a little bit like it's outside.

411
00:23:32,000 --> 00:23:36,000
This is, again, one of the characteristics that allow us to create nice DSLs,

412
00:23:36,000 --> 00:23:38,000
and you can even do this like multi-line.

413
00:23:38,000 --> 00:23:44,000
So if you look at fine emails now, in a sense, it could actually feel like it's part of the language,

414
00:23:44,000 --> 00:23:46,000
but it isn't. It's actually a function.

415
00:23:46,000 --> 00:23:53,000
And when we implemented asynchronous programming with coroutines,

416
00:23:53,000 --> 00:23:55,000
we didn't like, you know, if you're familiar with C-sharp,

417
00:23:55,000 --> 00:23:58,000
C-sharp does that sync a weight, the keywords in the language.

418
00:23:58,000 --> 00:24:01,000
In Kotlin, they're not. They're essentially just functions, OK?

419
00:24:01,000 --> 00:24:06,000
That gives you the flexibility of deciding how you want to do different things.

420
00:24:06,000 --> 00:24:10,000
Now, you don't have to do all of these things because all of these things are built in.

421
00:24:10,000 --> 00:24:14,000
So for example, if I say .com users, I say users, filter,

422
00:24:14,000 --> 00:24:20,000
and you can see that as I complete this, it actually opts for the version of including out of the parameter.

423
00:24:20,000 --> 00:24:27,000
So I can say the email ends with .com,

424
00:24:27,000 --> 00:24:32,000
and then I can go and sort by it.id,

425
00:24:32,000 --> 00:24:45,000
and then let's go ahead and do, for example, map that to a pair of it.email and it.username, OK?

426
00:24:45,000 --> 00:24:49,000
So all of these functions are actually built in in that small standard library that ships

427
00:24:49,000 --> 00:24:51,000
but you're not going to have problems on Android. It's very small.

428
00:24:51,000 --> 00:24:58,000
And they're all essentially extension functions on top of collections, generic collections, right?

429
00:24:58,000 --> 00:25:05,000
So you have all of those functional things that, you know, are very in fashion these days.

430
00:25:05,000 --> 00:25:10,000
And so this obviously gives me a pair,

431
00:25:10,000 --> 00:25:18,000
and in fact, you can do this even nicer if instead of doing pair, it to so a map,

432
00:25:18,000 --> 00:25:21,000
email to username, and guess what it is?

433
00:25:21,000 --> 00:25:27,000
It's just an infix function that creates a pair, OK?

434
00:25:27,000 --> 00:25:29,000
Now, sometimes I don't want to go through the whole map.

435
00:25:29,000 --> 00:25:33,000
I just want to, for example, say get back a single element.

436
00:25:33,000 --> 00:25:39,000
And what you can also do is destructure classes, data classes in Kotlin.

437
00:25:39,000 --> 00:25:44,000
So I could do something like ID, username, and email, OK?

438
00:25:44,000 --> 00:25:47,000
And then I could just, like, you know, use the ID.

439
00:25:47,000 --> 00:25:51,000
And this is great, but then the IDE complains and says, well, this variable is never used.

440
00:25:51,000 --> 00:25:56,000
In that case, you can actually replace that with an underscore, right?

441
00:25:56,000 --> 00:25:58,000
So there you go.

442
00:25:58,000 --> 00:26:01,000
And you can destructure the values you want, anything that you don't want to use,

443
00:26:01,000 --> 00:26:04,000
replace with an underscore, and you're good to go.

444
00:26:04,000 --> 00:26:08,000
Right. So what else can I show you?

445
00:26:08,000 --> 00:26:11,000
OK, so I've got some other code here.

446
00:26:11,000 --> 00:26:16,000
If you're familiar with the concept of algebraic data types, it's essentially one type,

447
00:26:16,000 --> 00:26:19,000
a type that can be of one type or another, like, for instance, a Boolean.

448
00:26:19,000 --> 00:26:22,000
Now, in Kotlin, the way that we do that is with seal classes.

449
00:26:22,000 --> 00:26:25,000
But before I get into that, let me go ahead and do an open here, right?

450
00:26:25,000 --> 00:26:29,000
Notice the first thing here that user result is giving me an error,

451
00:26:29,000 --> 00:26:33,000
because by default in Kotlin, you cannot inherit from classes.

452
00:26:33,000 --> 00:26:35,000
So all classes are essentially final.

453
00:26:35,000 --> 00:26:41,000
If you want to inherit from classes, you have to use the open modifier, right?

454
00:26:41,000 --> 00:26:43,000
Now, I've used the sealed.

455
00:26:43,000 --> 00:26:48,000
And the sealed is essentially saying that this is the hierarchy that user result has.

456
00:26:48,000 --> 00:26:54,000
Like, there's not going to be any other class anywhere that is going to inherit from user result.

457
00:26:54,000 --> 00:26:58,000
Everything that's going to inherit from user result has to be in the same file,

458
00:26:58,000 --> 00:27:01,000
or you can make these, of course, subclasses.

459
00:27:01,000 --> 00:27:06,000
So I could move this up there, and this would be a subclass,

460
00:27:06,000 --> 00:27:10,000
but then I would have to prefix it with user result, right?

461
00:27:10,000 --> 00:27:16,000
Okay, now, I've just created it as classes outside.

462
00:27:16,000 --> 00:27:20,000
So why would I want to do this?

463
00:27:20,000 --> 00:27:22,000
Because it looks good.

464
00:27:22,000 --> 00:27:25,000
Well, this is actually good, because when you're doing some things,

465
00:27:25,000 --> 00:27:28,000
it's often like you're invoking a function and you're like,

466
00:27:28,000 --> 00:27:31,000
okay, well, if it's successful, I want it to return a value.

467
00:27:31,000 --> 00:27:33,000
If it's not, I'm going to pass in a message,

468
00:27:33,000 --> 00:27:38,000
and then you get up this type that contains the values that you want to return when it's successful,

469
00:27:38,000 --> 00:27:41,000
it contains the types that you want to return when there's a message,

470
00:27:41,000 --> 00:27:47,000
and then you've got to figure out the semantics of which properties are applied to an error situation,

471
00:27:47,000 --> 00:27:49,000
which properties are applied to a non-error situation,

472
00:27:49,000 --> 00:27:51,000
or you can just throw an exception.

473
00:27:51,000 --> 00:27:55,000
In this case, you can use a function that basically returns two types,

474
00:27:55,000 --> 00:27:58,000
and then, based on the result, do different things.

475
00:27:58,000 --> 00:28:01,000
So here, I say, for instance, when...

476
00:28:01,000 --> 00:28:08,000
Let's create an instant value result equals user result.

477
00:28:08,000 --> 00:28:10,000
Sorry, retrieve users.

478
00:28:10,000 --> 00:28:17,000
Okay, so now I can do when result is success,

479
00:28:17,000 --> 00:28:21,000
then we're going to do, for instance, well, we're going to get the result,

480
00:28:21,000 --> 00:28:26,000
and then we're going to do users for each...

481
00:28:26,000 --> 00:28:33,000
Oh, for each print line, the name, okay?

482
00:28:33,000 --> 00:28:36,000
User name.

483
00:28:36,000 --> 00:28:46,000
And then we're going to do a failure result print line result.message, okay?

484
00:28:46,000 --> 00:28:50,000
So now, based on the result, based on the type that is returned to me,

485
00:28:50,000 --> 00:28:52,000
I can do different things.

486
00:28:52,000 --> 00:28:55,000
And notice one thing over here, that this is gone green.

487
00:28:55,000 --> 00:28:57,000
I don't know if you see it on the big screen, but this is gone green.

488
00:28:57,000 --> 00:29:00,000
And this is a smart cast, so that's another thing that we have in Kotlin,

489
00:29:00,000 --> 00:29:05,000
and you saw that when I was doing the null check that it said this is not null

490
00:29:05,000 --> 00:29:09,000
because it's smart casting, so you don't have to explicitly come over here again

491
00:29:09,000 --> 00:29:13,000
and say, oh, you know, I know that this is of type success,

492
00:29:13,000 --> 00:29:17,000
let me go ahead and cast this to type success to then access the property.

493
00:29:17,000 --> 00:29:19,000
The compiler will do that for you.

494
00:29:19,000 --> 00:29:22,000
That's what the smart casting is.

495
00:29:22,000 --> 00:29:23,000
Right.

496
00:29:23,000 --> 00:29:27,000
And last but not least, before I hand it off to Andre, quickly just mention also

497
00:29:27,000 --> 00:29:30,000
that a lot of the things that you've been seeing with the filter map,

498
00:29:30,000 --> 00:29:36,000
all of those things, those are essentially eager evaluation, right?

499
00:29:36,000 --> 00:29:39,000
But we also have the ability to do lazy evaluation.

500
00:29:39,000 --> 00:29:43,000
So I can do val, for example, sorry, generate sequence,

501
00:29:43,000 --> 00:29:46,000
and then have something, for instance, one.

502
00:29:46,000 --> 00:29:57,000
And then here we'll do it times 10, and then we'll do values, right?

503
00:29:57,000 --> 00:30:07,000
Now I'll say values, take 10, and then for each, print line it.

504
00:30:07,000 --> 00:30:11,000
Now this is essentially creating a sequence, a generator that is infinite.

505
00:30:11,000 --> 00:30:12,000
It's never going to stop.

506
00:30:12,000 --> 00:30:14,000
It's going to start at 1 and multiply by 10.

507
00:30:14,000 --> 00:30:19,000
But what I'm saying here is that I just want to take 10 elements and then print them out.

508
00:30:19,000 --> 00:30:28,000
And what it will do is basically consume that until it hits 10, it prints out, go away.

509
00:30:28,000 --> 00:30:35,000
It prints out a beautiful Christmas tree that's one-sided.

510
00:30:36,000 --> 00:30:39,000
Pyramid, whatever, and stops there.

511
00:30:39,000 --> 00:30:43,000
And anything that you have, like, for example, the users that we had,

512
00:30:43,000 --> 00:30:50,000
you know, users from JSON, users.json, you can say as sequence

513
00:30:50,000 --> 00:30:52,000
and convert it into lazy evaluation as well.

514
00:30:52,000 --> 00:30:55,000
Okay, that's all we have the time to show you today.

515
00:30:55,000 --> 00:30:57,000
Obviously there's way more to the language.

516
00:30:57,000 --> 00:31:01,000
Go online, learn everything about it, and thank you very much,

517
00:31:01,000 --> 00:31:02,000
and I'll hand it off to Andre.

518
00:31:02,000 --> 00:31:07,000
Thank you, Hadi.

519
00:31:07,000 --> 00:31:09,000
Hello, everybody.

520
00:31:09,000 --> 00:31:14,000
So as you've seen, Kotlin already has many things in store,

521
00:31:14,000 --> 00:31:19,000
but I'm the nasty person who adds new features before you learn the existing ones.

522
00:31:19,000 --> 00:31:23,000
So I'll be telling you stories now, but I'll need to find a clicker.

523
00:31:23,000 --> 00:31:25,000
You have a clicker?

524
00:31:25,000 --> 00:31:26,000
No.

525
00:31:26,000 --> 00:31:27,000
Okay.

526
00:31:27,000 --> 00:31:30,000
Okay, so I'll be telling stories without a clicker.

527
00:31:31,000 --> 00:31:36,000
So my job here is to tell you about what we're going to have in the future versions of Kotlin.

528
00:31:36,000 --> 00:31:38,000
Oh, thank you very much.

529
00:31:38,000 --> 00:31:40,000
Okay.

530
00:31:40,000 --> 00:31:46,000
And the first big thing we're working on now is platforms,

531
00:31:46,000 --> 00:31:48,000
supporting different platforms.

532
00:31:48,000 --> 00:31:52,000
So historically, Kotlin compiles to JVM bytecode,

533
00:31:52,000 --> 00:31:54,000
same as the Java programming language.

534
00:31:54,000 --> 00:32:00,000
So we can run on the server, on the desktop, and of course on Android.

535
00:32:00,000 --> 00:32:03,000
And it's just the same bytecode everywhere.

536
00:32:03,000 --> 00:32:07,000
This is why we can run all versions of Android as well as new ones.

537
00:32:07,000 --> 00:32:11,000
But the story doesn't end there because we're adding new platforms,

538
00:32:11,000 --> 00:32:15,000
and recently we've added...

539
00:32:15,000 --> 00:32:19,000
The God doesn't like platforms.

540
00:32:19,000 --> 00:32:21,000
Recently, we added JavaScript,

541
00:32:21,000 --> 00:32:24,000
which means Kotlin can now compile to JavaScript code

542
00:32:24,000 --> 00:32:27,000
and run in the browser or on Node.js.

543
00:32:27,000 --> 00:32:32,000
So now we support three major, very popular virtual machines,

544
00:32:32,000 --> 00:32:36,000
JVM, Android, Dalvik, and JavaScript VMs.

545
00:32:36,000 --> 00:32:40,000
But there are many use cases where a virtual machine is not practical

546
00:32:40,000 --> 00:32:42,000
or is simply unavailable.

547
00:32:42,000 --> 00:32:47,000
For example, for iOS, virtual machines are severely restricted.

548
00:32:47,000 --> 00:32:49,000
You can do dynamic code generation.

549
00:32:49,000 --> 00:32:52,000
Or for a small embedded system, a VM doesn't fit in.

550
00:32:52,000 --> 00:32:59,000
Or for, say, a Linux command-line tool, the VM will be starting to for too long.

551
00:32:59,000 --> 00:33:01,000
So let's now go there.

552
00:33:01,000 --> 00:33:04,000
And that's why we're working on something called Kotlin Native.

553
00:33:04,000 --> 00:33:07,000
It's currently available as a technology preview.

554
00:33:07,000 --> 00:33:12,000
And there, we basically use LLVM to compile Kotlin down to native code

555
00:33:12,000 --> 00:33:15,000
to standalone binaries that can run on different platforms.

556
00:33:15,000 --> 00:33:18,000
Currently, we support iOS, Linux, and Mac.

557
00:33:18,000 --> 00:33:21,000
And Windows is in the works.

558
00:33:21,000 --> 00:33:26,000
So this is taking us to this vision with Kotlin

559
00:33:26,000 --> 00:33:31,000
when it can run inside every component of a modern application

560
00:33:31,000 --> 00:33:33,000
on any platform you like.

561
00:33:33,000 --> 00:33:38,000
So think full-stack web applications with the server and the client,

562
00:33:38,000 --> 00:33:40,000
both written in Kotlin.

563
00:33:40,000 --> 00:33:44,000
Or think we use code between mobile platforms, Android and iOS

564
00:33:44,000 --> 00:33:48,000
for example, or mix the two previous use cases

565
00:33:48,000 --> 00:33:51,000
and get a real multi-platform scenario.

566
00:33:51,000 --> 00:33:57,000
So our vision for Kotlin is having different modules in the same project

567
00:33:57,000 --> 00:34:00,000
compiled to different platforms.

568
00:34:00,000 --> 00:34:02,000
And of course, you want to share code there, right?

569
00:34:02,000 --> 00:34:05,000
Because if you support so many different things,

570
00:34:05,000 --> 00:34:07,000
you want to run the same code in different places.

571
00:34:07,000 --> 00:34:10,000
And we're working on making that possible.

572
00:34:10,000 --> 00:34:13,000
But there is a very important thing

573
00:34:13,000 --> 00:34:18,000
because previously, many projects tried to unify platforms.

574
00:34:18,000 --> 00:34:22,000
And this often ends up being like the least common denominator.

575
00:34:22,000 --> 00:34:26,000
When you take only things that are available on all platforms,

576
00:34:26,000 --> 00:34:29,000
you're basically stuck with a minimal interface.

577
00:34:29,000 --> 00:34:31,000
And that's something we don't want to have there.

578
00:34:31,000 --> 00:34:35,000
So we want you to be able to use all the platform-specific fancy APIs

579
00:34:35,000 --> 00:34:38,000
like the newest version of Android or something else,

580
00:34:38,000 --> 00:34:40,000
as much as you like.

581
00:34:40,000 --> 00:34:42,000
And if you want to share some code,

582
00:34:42,000 --> 00:34:47,000
only then you have to resort to some common APIs.

583
00:34:47,000 --> 00:34:49,000
So the idea there is that you have a common module

584
00:34:49,000 --> 00:34:52,000
with lots of business logic and stuff.

585
00:34:52,000 --> 00:34:55,000
And it can work side by side with a platform-specific module

586
00:34:55,000 --> 00:34:57,000
written also in Kotlin.

587
00:34:57,000 --> 00:34:59,000
And those two can talk to each other.

588
00:34:59,000 --> 00:35:02,000
So when you need, you leverage the platform API

589
00:35:02,000 --> 00:35:05,000
and when you need, you use the common code.

590
00:35:05,000 --> 00:35:10,000
So take away here, our future is multi-platform.

591
00:35:10,000 --> 00:35:12,000
Next...

592
00:35:12,000 --> 00:35:14,000
Oh.

593
00:35:14,000 --> 00:35:16,000
Yeah.

594
00:35:16,000 --> 00:35:20,000
And next big thing is coroutines.

595
00:35:20,000 --> 00:35:24,000
So the rationale there is pretty straightforward.

596
00:35:24,000 --> 00:35:27,000
Everybody needs to write a synchronous code, right?

597
00:35:27,000 --> 00:35:31,000
Because the world is too big now for sequential execution.

598
00:35:31,000 --> 00:35:36,000
And it's, yeah, it's our reality, but it's hard, right?

599
00:35:36,000 --> 00:35:39,000
Who has written a synchronous code?

600
00:35:39,000 --> 00:35:41,000
Quite so many hands.

601
00:35:41,000 --> 00:35:46,000
Those of you who don't actually will be doing this very soon.

602
00:35:46,000 --> 00:35:48,000
And the problem is that it's rather hard, actually,

603
00:35:48,000 --> 00:35:50,000
to write sequential code.

604
00:35:50,000 --> 00:35:55,000
Or it was hard before languages learned to support you in doing that

605
00:35:55,000 --> 00:35:57,000
because the language can help you there a lot.

606
00:35:57,000 --> 00:36:00,000
So basically, what we have with coroutines in Kotlin,

607
00:36:00,000 --> 00:36:04,000
you write asynchronous code the same way you write synchronous code.

608
00:36:04,000 --> 00:36:06,000
So what do you use in synchronous code?

609
00:36:06,000 --> 00:36:10,000
Loops, ifs, breaks and continues, things like that, right?

610
00:36:10,000 --> 00:36:15,000
And it's the same things you're using with coroutines for asynchronous code

611
00:36:15,000 --> 00:36:19,000
so that the language keeps track of everything

612
00:36:19,000 --> 00:36:22,000
and you don't have to express any intricate control flow

613
00:36:22,000 --> 00:36:25,000
for asynchronous computation in your code.

614
00:36:25,000 --> 00:36:29,000
No callbacks, no fancy functional structures.

615
00:36:29,000 --> 00:36:34,000
It's just plain old sequential looking code.

616
00:36:34,000 --> 00:36:36,000
And isn't it cool?

617
00:36:36,000 --> 00:36:40,000
Thank you.

618
00:36:40,000 --> 00:36:46,000
Yeah, so the idea with coroutines is that you basically have the same abstraction

619
00:36:46,000 --> 00:36:48,000
for asynchronous and synchronous.

620
00:36:48,000 --> 00:36:54,000
And also, it's a nice metaphor to think of them as almost free threads.

621
00:36:54,000 --> 00:36:58,000
Like here's the only code example I'm showing you.

622
00:36:59,000 --> 00:37:02,000
Basically, very many things that are traditionally done with threads

623
00:37:02,000 --> 00:37:05,000
can be done with coroutines, but coroutines are extremely cheap.

624
00:37:05,000 --> 00:37:10,000
So here on the slide, I have a code that creates 100,000 coroutines.

625
00:37:10,000 --> 00:37:11,000
Think about that.

626
00:37:11,000 --> 00:37:14,000
100,000 coroutines existing in parallel

627
00:37:14,000 --> 00:37:18,000
and each one of them waits for one second and returns one.

628
00:37:18,000 --> 00:37:25,000
So this program completes in one second,

629
00:37:26,000 --> 00:37:30,000
almost one second, because all the coroutines wait in parallel, of course.

630
00:37:30,000 --> 00:37:35,000
But if you try to do this with threads, it just doesn't work.

631
00:37:35,000 --> 00:37:38,000
100,000 threads don't fit into memory.

632
00:37:38,000 --> 00:37:39,000
That's it.

633
00:37:39,000 --> 00:37:42,000
So with coroutines, it's a win-win situation.

634
00:37:42,000 --> 00:37:46,000
You get lots of performance, so it's very efficient,

635
00:37:46,000 --> 00:37:48,000
and the code is simple.

636
00:37:48,000 --> 00:37:50,000
So take away here.

637
00:37:50,000 --> 00:37:54,000
Check out coroutines because our future will likely be even more asynchronous

638
00:37:54,000 --> 00:37:55,000
than our present.

639
00:37:57,000 --> 00:38:01,000
So I'm almost done, and if you want to learn more about Kotlin,

640
00:38:01,000 --> 00:38:02,000
check out our website.

641
00:38:02,000 --> 00:38:04,000
We have a section for Android.

642
00:38:04,000 --> 00:38:10,000
And also, we'll have a question-and-answer session right after this talk.

643
00:38:10,000 --> 00:38:15,000
So come over to the developer sandbox, section C.

644
00:38:15,000 --> 00:38:18,000
Myself and Hadi will be answering questions there.

645
00:38:18,000 --> 00:38:20,000
So thank you very much for your attention.

646
00:38:20,000 --> 00:38:21,000
Thank you.

