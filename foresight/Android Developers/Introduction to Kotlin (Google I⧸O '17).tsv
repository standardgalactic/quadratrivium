start	end	text
0	5000	We'll see you in the next video.
5000	10000	Good morning, everyone.
10000	11000	Wait.
11000	13000	Don't cheer us.
13000	15000	Cheer the next speakers.
15000	18000	So I'm from the representing the platform team on Android.
18000	21000	And this is representing the tools team.
21000	22000	But you're not here for us.
22000	24000	You're here for very special speakers.
24000	25000	Yeah.
25000	28000	So Roman and I have been incredibly excited about this official
28000	29000	announcement of Kotlin.
29000	32000	We both love Kotlin in case you haven't noticed already.
32000	35000	And we don't want to take any more time from the speakers of honor.
35000	38000	So without further ado, here they are.
38000	54000	So hello, everyone.
54000	56000	Oh, that's nice.
56000	58000	So you know, I was thinking the other day,
58000	60000	the first time that I ever did a talk in Kotlin,
60000	63000	it was like four and a half years ago.
63000	65000	And they gave me a room for 900 people,
65000	68000	and seven people showed up.
68000	71000	So it's kind of nice to see more of you show up today.
71000	76000	Thank you.
76000	80000	Anyway, I've got roughly around 30 minutes,
80000	83000	actually 30, a little bit less,
83000	85000	28 minutes to give you a whirlwind tour of Kotlin.
85000	87000	So I'm not going to cover the entire language.
87000	91000	I'm going to try and show you as much as I possibly can
91000	94000	and how you can use it and where it provides you with some benefits.
94000	97000	OK, so I'm going to try and do it all with live coding.
97000	101000	So if it all goes terribly wrong, there's a Google video.
101000	104000	I mean, there's a YouTube video of this somewhere as well.
104000	106000	So you can watch that.
106000	108000	OK, so we're going to start with something very simple
108000	110000	that you've already seen, data class.
110000	114000	And I'm in a file called main, right?
114000	117000	So data class, I'm going to create a new type called money,
117000	120000	and it's going to have an amount, which is of type int.
120000	122000	I know, don't say anything for now.
122000	127000	And it's going to have a currency of type string, OK?
127000	129000	And this is both properties,
129000	131000	and they're going to be read-only properties.
131000	133000	So this is something that you're already familiar with.
133000	135000	It's essentially a data class.
135000	141000	Let's go ahead and compare that to a Java one that I have done earlier.
141000	143000	So split vertically.
143000	145000	And let's get the Java money up.
145000	148000	Actually, let's get it on this side.
148000	150000	Java money.
150000	152000	So there you go.
152000	155000	That's kind of the equivalent of what I've just written, right?
155000	159000	A Java being essentially a data class that provides two getters.
159000	162000	They're immutable, so they're read-only.
162000	165000	And this data modifier over here, what that's doing is essentially
165000	167000	giving me a whole bunch of things like the two string.
167000	171000	It's giving me the clone, which in Kotlin is called copy.
171000	173000	It's doing the equals.
173000	174000	It's doing the hash code.
174000	176000	Now you say, OK, well, that's great.
176000	177000	Brilliant.
177000	178000	But why do I need that?
178000	181000	Because any good IDE is going to generate that for me.
181000	182000	It is true.
182000	183000	It does.
183000	185000	But the problem is that that's code you're going to have to maintain.
185000	186000	And every time you add a new property,
186000	188000	you're going to have to go back and change that code.
188000	190000	And the other issue you're going to have is you don't know,
190000	193000	in fact, if that code is the standard stuff
193000	197000	that your IDE has generated for you,
197000	199000	or you've tweaked it a little bit, OK?
199000	203000	So it's not just about saving on typing on the first slide.
203000	204000	Right.
204000	207000	Now what I'm going to do is go ahead and create a function main.
207000	209000	Let's close this guy over here.
209000	211000	And this is like the top entry point of Kotlin.
211000	215000	So you have a public static void main in a class.
215000	217000	You don't need that in Kotlin.
217000	219000	So in Kotlin, you can put everything in the top level.
219000	222000	It's kind of like JavaScript in a good way.
222000	228000	And so you don't have to, and just I want to reiterate,
228000	230000	like every function and everything that I'll show you today,
230000	233000	I'm going to just add it in the file as a top level thing.
233000	237000	But that doesn't mean that you don't have any more member functions.
237000	240000	Anything, any class, even a data class can have member functions.
240000	243000	But for brevity and for the purpose of what I'm showing you,
243000	246000	I'm just going to put it as top level, OK?
246000	248000	So I'm going to create a new instance of money.
248000	251000	We're going to call it, for example, tickets.
251000	253000	And I'll say money, 100.
253000	256000	And it's going to be dollars, right?
256000	260000	And I'll get into the explicit type here.
260000	262000	But essentially here, what I'm doing is type inference.
262000	264000	So Kotlin is very strong in type inference.
264000	266000	And as much as it can infer, it will for you.
266000	269000	So you don't have to explicitly tell the type.
269000	272000	And then I'll say, for example, popcorn.
272000	277000	Let's say tickets, copy, right?
277000	282000	So that's what that's going to do is basically copy the previous one for me
282000	284000	and all of the properties.
284000	287000	So if I don't pass any parameters in,
287000	290000	it's going to just take the same values as it has before, OK?
290000	293000	So I can pass in a new parameter, say, like, you know, I mean, in Spain,
293000	297000	for example, popcorn is seven times the price of the entry of the cinema.
297000	301000	So that's going to be like 500 euros, right?
301000	304000	And now I can do things like, for instance, you know,
304000	310000	if tickets is not equal to popcorn,
310000	316000	then print line, they are different, right?
316000	320000	So what this is doing is a property comparison one by one.
320000	322000	It's not doing a pointer comparison.
322000	325000	For pointer comparisons, we have the triple equal, right?
325000	329000	Different to JavaScript, there isn't like a chart of 600 different positions
329000	330000	you have to remember.
330000	334000	So, and this, by the way, is font ligatures.
334000	335000	So don't get confused with that.
335000	337000	We didn't introduce a new symbol.
337000	338000	OK.
338000	344000	So I can go ahead and just, like, run this and I get they are different.
344000	350000	And if I change this to 100 and I put this as dollars and I run this,
350000	354000	it's going to say to you that nothing, because they are the same, OK?
354000	359000	Now, one of the features we keep boosting about is the interop between Java and Kotlin.
359000	362000	So we have this Java money one over here.
362000	365000	So I'm going to go ahead and create an instance of it.
365000	370000	And I'll say Java money equals Java money.
370000	373000	And it will be 100 and it will be dollars.
373000	379000	And then if I do Java money, you can see that I don't have any getters.
379000	383000	Well, I do have actually a getter, so I can do get amount.
383000	388000	But if I write get amount, completed, the ID is already going to replace that for property
388000	390000	because we don't have really, like, getters and setters.
390000	392000	We just have properties.
392000	396000	So that's consuming Java from Kotlin.
396000	401000	And if I go over to the Java over here and let's go ahead and create a public static void main
401000	412000	and I'll do, so let's see, I've got a declarer type, money equals new money 100 and dollars.
412000	414000	And, oh, OK.
414000	417000	That's the other thing.
417000	420000	The semicolons in Kotlin are optional.
420000	428000	And the reason they're optional is so that you can have endless arguments over whether you should use them or not.
428000	430000	We're trying to compete with JavaScript there.
430000	432000	OK, so money.get amount.
432000	437000	So now I'm using a Kotlin type from Java, so I'm getting the getters and the setters.
437000	442000	So idiomatic, depending on how you are using it.
442000	449000	And that's just different Java files, different Kotlin files in a single project working seamlessly without any issues.
449000	453000	Right, so now let's go ahead and create some functions.
453000	462000	So I'm going to create a function called send payment that takes some money and money and it's going to print line the money out.
462000	468000	And of course we have string interpolation, so I can say sending money.amount.
468000	473000	And you don't have to put these curly braces if it's just a single property that you're passing in, as we'll just see in a moment.
473000	477000	So now I can call this and say, for example, send payment, tickets.
477000	484000	Right, now Kotlin we also have, notice one thing here, I'm not defining the return type.
484000	488000	OK, by default it's unit, which is kind of like void, but it's not.
488000	494000	It's actually object, which is essentially a singleton and single instance of an object.
494000	498000	And if it is a unit, you don't have to put it there, right?
498000	507000	So I'm going to add a new parameter here, and I'm going to say, for example, with message, and this is going to have string, and you can have default parameters.
507000	511000	So here, notice that there's no compilation error because I made a default parameter.
511000	515000	This saves you a lot in terms of overloaded function, overloaded member functions, right?
515000	519000	I can just, you know, have default parameters and then do what I want.
519000	530000	And you can have multiple default parameters, and since you can have multiple default parameters and you can, you know, alternate which one you want to pass in, you can also do named parameters.
530000	539000	So in fact, I could say message equals good luck, and money equals tickets, right?
539000	547000	And this is kind of useful as well when you are using, you're talking to legacy code, for example, you know, some function that you can't modify,
547000	553000	and it's got 600 parameters, and there are probably 500 of them are true and false Booleans.
553000	562000	It kind of gives you some insight into what parameters I'm passing in in every position.
562000	566000	Oh, yeah. I love it when people clap.
566000	577000	And I'm thinking to myself, well, this is going well.
577000	583000	Anyway, right. Let's go edit that out, like adult supervision.
583000	595000	Right. One other thing with Kotlin is that when we have functions that are really, really easy, like essentially returning a single value, you can just do single expression functions.
595000	604000	So I omit the return type explicitly, I omit the curly braces, and I just return the actual function that I want to do, okay?
604000	610000	So in fact, this is like the concept of expression comes in many places in Kotlin.
610000	613000	So for instance, let's create another function that's called convert to dollars.
613000	622000	Convert to dollars, and this is going to take money, money, and it's going to return money.
622000	625000	And then what we're going to do here is a when statement.
625000	627000	So that's essentially a case, right?
627000	638000	So when money currency is dollars, then we'll do return money as is, right?
638000	640000	Because I don't need to do anything.
640000	643000	And if it's euros, then what I'm going to do is return.
643000	653000	We're going to do money amount times, sorry, I've got to create a new instance, money.
653000	664000	And then it's going to be money amount times big decimal, 1.10, and then that's going to be dollars, right?
664000	674000	And else, throw illegal argument exception, not the currency you're interested in.
674000	678000	Okay, so this, you can actually treat a when as an expression.
678000	684000	So I can remove this return over here, remove this return over here, put it just here,
684000	689000	and then this just makes the when always return an expression.
689000	696000	And in fact, you can even remove the return here, return, remove the money here,
696000	700000	and remove that there, and you get a single expression, okay?
700000	702000	Single expression function.
702000	705000	Now, one thing that you'll notice here that this is giving me an error,
705000	709000	because this is, you know, I'm trying to operate a big decimal with an int.
709000	711000	So we're going to go and refactor this.
711000	714000	I'm going to call it big decimal, okay?
714000	717000	Now, talking about big decimal, oh, here we go.
717000	726000	Big decimal, big decimal, 100, and big decimal.
726000	728000	I love typing big decimal.
728000	731000	I love it, okay?
731000	734000	So we've got this over here.
734000	739000	Now, if you look at actually big decimal, so if I create a new big decimal,
739000	743000	we'll call it bd1 equals big decimal, 100.
743000	746000	And you can see that bd1 gives me a whole bunch of functions,
746000	748000	like divide, multiply, all of these things.
748000	750000	What if I wanted to do something like a percent?
750000	753000	I wanted to do a percentage of big decimal.
753000	758000	Now, normally you would basically inherit from that
758000	760000	and then create your own version and have all of these things,
760000	762000	but in Kotlin, one of the features that we've added,
762000	765000	and if you're familiar with C sharp, it's called extension functions,
765000	768000	which essentially means that you can take any class, any type, and extend it.
768000	771000	So I can take a function big decimal,
771000	773000	I put the name of the class that I want to extend,
773000	775000	and I say I want to do a percent,
775000	779000	and what is the percentage that I want to do, for example, an integer,
779000	781000	and then it would be, let's see.
781000	784000	So given that this is an extension function,
784000	788000	it's going to have an instance of that class, of that object, right?
788000	790000	So I can use that, reference that with this.
790000	796000	And I say this, multiply by the percentage,
796000	800000	and then this has got to be wrapped in a big decimal again, percentage,
800000	809000	and then that divides, and then another big decimal, 100.
809000	813000	And what's wrong with this? That should be percentage.
813000	817000	So percentage, okay?
817000	823000	So now, what happens is that on BD1, I have percentage, okay?
823000	827000	And I can do percent seven, and that would give me a seven percent.
827000	832000	And that extension function gets included anywhere where it is defined in the package, right?
832000	835000	So here in this case, I have it in com.getbrains.go,
835000	837000	and that will get included there, right?
837000	839000	So you can create extension functions,
839000	843000	and we'll see that the standard library actually consists of a whole bunch of extension functions.
843000	846000	Now, we'll take this one step further, because I can actually extend everything.
846000	849000	So let's go ahead and extend an integer.
849000	856000	So I'll say fun, int, percent of, and here we'll do the reverse.
856000	859000	I want, like, 10% of something, right?
859000	862000	So I'll say money, for instance, I want 10% of money,
862000	870000	and that's going to return the, let's see, it's going to return money, right?
870000	873000	Then it will be amount, multiply,
873000	876000	and then here it's going to reference the actual instance,
876000	882000	so it will be this, and again, this has to be wrapped in big decimal,
882000	887000	and then divide by 100, okay?
887000	890000	And I think I got that in the right order.
890000	893000	If the implementation is wrong, it doesn't matter who cares.
893000	897000	Anyway, so now what I can do is something like this,
897000	905000	7% of big decimal 100, okay?
905000	907000	Oh, no, sorry, money.
907000	908000	So I can do money.
908000	910000	No, don't clap yet.
911000	912000	Money.
912000	914000	Oh, let's just take the money I have.
914000	916000	7% of popcorn, okay?
916000	917000	Nice.
917000	922000	Let's do a little bit nicer.
922000	925000	What I want to do is, in fact, something like this,
925000	929000	I want to do 7% of popcorn.
929000	931000	That would be nice, and you can actually do that.
931000	932000	You see that little wiggly there?
932000	933000	It's wiggly.
933000	935000	Alt, enter, add, infix.
935000	937000	There you go, okay?
937000	941000	So any extension function that has a single parameter
941000	943000	can be called an infix notation,
943000	946000	and what I've done is essentially add the infix over there.
946000	949000	And this is some of the things that allow you now with Kotlin
949000	953000	to kind of create the whole DSL approach to things.
953000	956000	Right, so one thing that I hate doing here
956000	958000	is all of this big decimal.
958000	960000	That's a pain, right?
960000	963000	And in Kotlin, when you want to create a value of type long,
963000	966000	you can say long 100L, and that will be of type long.
966000	968000	That would be awesome if I could do like,
968000	973000	well, bd2 equals 100 bd, but you can't,
973000	974000	and we don't have that built in.
974000	977000	But what we do have in Kotlin is called extension properties.
977000	979000	So they're exactly like extension functions,
979000	982000	except they extend with properties.
982000	987000	So I could do something like .bd, right?
987000	990000	And now, or let's, yeah.
990000	992000	So now, see, it even says, hey,
992000	995000	do you want to create an extension property on type integer?
995000	999000	So this is going to return a big decimal, right?
999000	1007000	And then, here, I'm going to do return, big decimal,
1007000	1009000	and this, which is the instance, right?
1009000	1011000	And I can, in fact, convert this to an expression
1011000	1013000	to make it easier, right?
1013000	1014000	So there you go.
1014000	1017000	Now I have 100.bd.
1017000	1018000	So when I'm passing that in,
1018000	1020000	it looks much nicer than big decimal.
1020000	1024000	I could just do 100.bd, okay?
1024000	1033000	And one other thing around functions that you can do
1033000	1036000	is there are certain operators that you can extend.
1036000	1039000	So you can extend, for example, the plus operator.
1039000	1041000	And what I'm going to do is I'm not going to type this out.
1041000	1044000	I've just got a nice little thingy that has done that for me.
1044000	1046000	See how fast I am at typing.
1046000	1048000	So what I've essentially done is now
1048000	1050000	override the plus operator for money.
1050000	1058000	So now I can say cost equals tickets plus popcorn, right?
1058000	1061000	And that allows me to add to monetary amounts, okay?
1061000	1063000	And you can do that with plus, minus, multiply.
1063000	1066000	A bunch of built-in conventions that you can follow
1066000	1070000	for certain operators that allow you to do that.
1070000	1071000	Okay.
1071000	1073000	So we've been creating a whole bunch of types here.
1073000	1077000	And let me go ahead and delete all this stuff so we can focus.
1077000	1079000	We've been creating a bunch of types here.
1079000	1081000	Notice that in any of these types that I've created,
1081000	1084000	I've never actually specified the type.
1084000	1085000	And you can.
1085000	1091000	So I can do, for instance, val, train costs, for example,
1091000	1097000	train is of type money, and then initialize it to some new value,
1097000	1098000	right?
1098000	1102000	100.pd and then dollars.
1102000	1105000	Now, if I go ahead and do train equals null,
1105000	1106000	it's going to give me an error.
1106000	1108000	And it's going to give me actually two errors.
1108000	1111000	One of them is because that's immutable variable.
1111000	1112000	So I can fix that.
1112000	1114000	I've now made this mutable.
1114000	1116000	You see that the ID underlines it.
1116000	1118000	So it kind of, like, wants to point it out that, you know,
1118000	1121000	this is really something you're going to shy away from.
1121000	1123000	We don't enforce immutability in Kotlin,
1123000	1125000	but we kind of do recommend it.
1125000	1129000	Like, all of the lists and all of these things are immutable by default.
1129000	1134000	So I can't assign null in Kotlin because Kotlin tries to get rid of the null
1134000	1137000	pointer exception by saying that types aren't nullable by default,
1137000	1138000	right?
1138000	1141000	But there are times when you want to have a type that is nullable
1141000	1146000	for whatever reason, you're bored, and you can add a question mark,
1146000	1150000	and then that will give you the ability to assign null to that type,
1150000	1151000	right?
1151000	1152000	Now, normally, when you're working with Kotlin,
1152000	1153000	you probably don't want to do this.
1153000	1155000	You probably don't want to have nullable types.
1155000	1161000	But since we're interupping with Java, Java can be null.
1161000	1165000	So if I create a function here that is, for instance,
1165000	1171000	fun Java money, and that takes money of type Java money
1171000	1174000	and does whatever with it, right?
1174000	1184000	So let's say I do print line money.amount is valid.
1184000	1187000	So this can be null.
1187000	1190000	It could, you know, if it's called by an instance that a function that,
1190000	1192000	for example, is returning this type, it could be null.
1192000	1195000	And you can indicate that by adding the question mark.
1195000	1199000	When you do that, you can see that the IDE is going to give you an error,
1199000	1200000	right?
1200000	1203000	It says only safe operators or the double exclamation mark are valid here,
1203000	1206000	because it's essentially saying you're going to run into a null reference
1206000	1207000	exception.
1207000	1208000	So there's two ways you can solve this.
1208000	1212000	First of all, you can say, for example, money, not null,
1212000	1216000	and then do, like, if not null, then go ahead and operate with it.
1216000	1221000	You know, put this one upstairs in there, OK?
1221000	1222000	That's one way.
1222000	1227000	Or the shorter way is just to use the safe operator or Elvis operator,
1227000	1228000	which is over here.
1228000	1233000	So now we just say, if money is not null, then do something.
1233000	1236000	Now, if you want to have fun, you can also do that.
1236000	1241000	And that says, I know it's null, but I want to shoot myself in the foot, OK?
1241000	1244000	And you've got to be careful with that, because a lot of times when people
1244000	1248000	start with Kotlin, they get all of these little squigglies over here,
1248000	1250000	and they're like, well, I actually don't know if it's going to be null,
1250000	1252000	because I really want it to not be null.
1252000	1256000	So I'm not going to handle the case where it's not null, so I'll just do that.
1256000	1258000	And then they run the app, and they're like, wait a minute,
1258000	1261000	you said Kotlin got rid of null reference exceptions.
1261000	1264000	Yes.
1264000	1266000	OK.
1266000	1267000	What else?
1267000	1268000	Right.
1268000	1271000	So let's switch to some other stuff, like higher order functions.
1271000	1273000	Now, you're all familiar with a higher order function,
1273000	1276000	which is basically a function that takes a function or returns a function.
1276000	1278000	And we have those in Kotlin.
1278000	1282000	So we can say, find emails, users, list of user,
1282000	1285000	and then I'll create a new function, which is a predicate.
1285000	1288000	So I'm passing in a function here, a function that takes a string
1288000	1291000	and returns a boolean, OK?
1291000	1295000	And then this probably is going to return a list of users.
1295000	1299000	So essentially what I'm doing is I'm filtering on a list of users, right?
1299000	1302000	So I'll do this later.
1303000	1306000	To do, later.
1306000	1307000	OK.
1307000	1309000	This to do, by the way, is built in.
1309000	1311000	You can use it instead of non-implemented exception,
1311000	1315000	a non-implemented error, and it does an additional thing that we won't get into.
1315000	1318000	But nothing is actually very nice in Kotlin,
1318000	1322000	but we won't cover that now.
1322000	1326000	It's nothing to worry about.
1326000	1327000	I just made that up.
1327000	1328000	OK.
1328000	1329000	Good.
1329000	1330000	OK.
1330000	1331000	Thank you.
1332000	1333000	Now, how do I use this?
1333000	1336000	So I can do find emails, right?
1336000	1338000	And I'll say, I actually have a user.
1338000	1340000	Let's create some users here.
1340000	1343000	So users from JSON file, and I have some users over here.
1343000	1344000	So users JSON.
1344000	1348000	So this is actually a function that I have ready,
1348000	1351000	which is basically using JSON to read some users from a file.
1351000	1354000	And this is a typical data class that you've already seen.
1354000	1360000	The only new thing here is that this also got an enum class with a property role, OK?
1360000	1365000	So now I can do users, and then I'll pass in that function.
1365000	1368000	Now I can pass in the name function by using the colon, colon reference,
1368000	1370000	or I can pass in a lambda.
1370000	1372000	And in Kotlin, lambda follows this syntax.
1372000	1377000	You pass in the parameter name, and then you say, for example,
1377000	1381000	the parameter name ends with .com, right?
1381000	1384000	So I'm getting a list of users that end with .com.
1385000	1389000	Now, when you have a single parameter in Kotlin,
1389000	1395000	you can actually admit having to explicitly mention it and replace it with it, OK?
1395000	1397000	So similar to Groovy, you can just use it.
1397000	1402000	The other thing that you can do in Kotlin is when the last parameter to a function is another function,
1402000	1408000	you can actually not include it in the brackets.
1408000	1412000	So it feels a little bit like it's outside.
1412000	1416000	This is, again, one of the characteristics that allow us to create nice DSLs,
1416000	1418000	and you can even do this like multi-line.
1418000	1424000	So if you look at fine emails now, in a sense, it could actually feel like it's part of the language,
1424000	1426000	but it isn't. It's actually a function.
1426000	1433000	And when we implemented asynchronous programming with coroutines,
1433000	1435000	we didn't like, you know, if you're familiar with C-sharp,
1435000	1438000	C-sharp does that sync a weight, the keywords in the language.
1438000	1441000	In Kotlin, they're not. They're essentially just functions, OK?
1441000	1446000	That gives you the flexibility of deciding how you want to do different things.
1446000	1450000	Now, you don't have to do all of these things because all of these things are built in.
1450000	1454000	So for example, if I say .com users, I say users, filter,
1454000	1460000	and you can see that as I complete this, it actually opts for the version of including out of the parameter.
1460000	1467000	So I can say the email ends with .com,
1467000	1472000	and then I can go and sort by it.id,
1472000	1485000	and then let's go ahead and do, for example, map that to a pair of it.email and it.username, OK?
1485000	1489000	So all of these functions are actually built in in that small standard library that ships
1489000	1491000	but you're not going to have problems on Android. It's very small.
1491000	1498000	And they're all essentially extension functions on top of collections, generic collections, right?
1498000	1505000	So you have all of those functional things that, you know, are very in fashion these days.
1505000	1510000	And so this obviously gives me a pair,
1510000	1518000	and in fact, you can do this even nicer if instead of doing pair, it to so a map,
1518000	1521000	email to username, and guess what it is?
1521000	1527000	It's just an infix function that creates a pair, OK?
1527000	1529000	Now, sometimes I don't want to go through the whole map.
1529000	1533000	I just want to, for example, say get back a single element.
1533000	1539000	And what you can also do is destructure classes, data classes in Kotlin.
1539000	1544000	So I could do something like ID, username, and email, OK?
1544000	1547000	And then I could just, like, you know, use the ID.
1547000	1551000	And this is great, but then the IDE complains and says, well, this variable is never used.
1551000	1556000	In that case, you can actually replace that with an underscore, right?
1556000	1558000	So there you go.
1558000	1561000	And you can destructure the values you want, anything that you don't want to use,
1561000	1564000	replace with an underscore, and you're good to go.
1564000	1568000	Right. So what else can I show you?
1568000	1571000	OK, so I've got some other code here.
1571000	1576000	If you're familiar with the concept of algebraic data types, it's essentially one type,
1576000	1579000	a type that can be of one type or another, like, for instance, a Boolean.
1579000	1582000	Now, in Kotlin, the way that we do that is with seal classes.
1582000	1585000	But before I get into that, let me go ahead and do an open here, right?
1585000	1589000	Notice the first thing here that user result is giving me an error,
1589000	1593000	because by default in Kotlin, you cannot inherit from classes.
1593000	1595000	So all classes are essentially final.
1595000	1601000	If you want to inherit from classes, you have to use the open modifier, right?
1601000	1603000	Now, I've used the sealed.
1603000	1608000	And the sealed is essentially saying that this is the hierarchy that user result has.
1608000	1614000	Like, there's not going to be any other class anywhere that is going to inherit from user result.
1614000	1618000	Everything that's going to inherit from user result has to be in the same file,
1618000	1621000	or you can make these, of course, subclasses.
1621000	1626000	So I could move this up there, and this would be a subclass,
1626000	1630000	but then I would have to prefix it with user result, right?
1630000	1636000	Okay, now, I've just created it as classes outside.
1636000	1640000	So why would I want to do this?
1640000	1642000	Because it looks good.
1642000	1645000	Well, this is actually good, because when you're doing some things,
1645000	1648000	it's often like you're invoking a function and you're like,
1648000	1651000	okay, well, if it's successful, I want it to return a value.
1651000	1653000	If it's not, I'm going to pass in a message,
1653000	1658000	and then you get up this type that contains the values that you want to return when it's successful,
1658000	1661000	it contains the types that you want to return when there's a message,
1661000	1667000	and then you've got to figure out the semantics of which properties are applied to an error situation,
1667000	1669000	which properties are applied to a non-error situation,
1669000	1671000	or you can just throw an exception.
1671000	1675000	In this case, you can use a function that basically returns two types,
1675000	1678000	and then, based on the result, do different things.
1678000	1681000	So here, I say, for instance, when...
1681000	1688000	Let's create an instant value result equals user result.
1688000	1690000	Sorry, retrieve users.
1690000	1697000	Okay, so now I can do when result is success,
1697000	1701000	then we're going to do, for instance, well, we're going to get the result,
1701000	1706000	and then we're going to do users for each...
1706000	1713000	Oh, for each print line, the name, okay?
1713000	1716000	User name.
1716000	1726000	And then we're going to do a failure result print line result.message, okay?
1726000	1730000	So now, based on the result, based on the type that is returned to me,
1730000	1732000	I can do different things.
1732000	1735000	And notice one thing over here, that this is gone green.
1735000	1737000	I don't know if you see it on the big screen, but this is gone green.
1737000	1740000	And this is a smart cast, so that's another thing that we have in Kotlin,
1740000	1745000	and you saw that when I was doing the null check that it said this is not null
1745000	1749000	because it's smart casting, so you don't have to explicitly come over here again
1749000	1753000	and say, oh, you know, I know that this is of type success,
1753000	1757000	let me go ahead and cast this to type success to then access the property.
1757000	1759000	The compiler will do that for you.
1759000	1762000	That's what the smart casting is.
1762000	1763000	Right.
1763000	1767000	And last but not least, before I hand it off to Andre, quickly just mention also
1767000	1770000	that a lot of the things that you've been seeing with the filter map,
1770000	1776000	all of those things, those are essentially eager evaluation, right?
1776000	1779000	But we also have the ability to do lazy evaluation.
1779000	1783000	So I can do val, for example, sorry, generate sequence,
1783000	1786000	and then have something, for instance, one.
1786000	1797000	And then here we'll do it times 10, and then we'll do values, right?
1797000	1807000	Now I'll say values, take 10, and then for each, print line it.
1807000	1811000	Now this is essentially creating a sequence, a generator that is infinite.
1811000	1812000	It's never going to stop.
1812000	1814000	It's going to start at 1 and multiply by 10.
1814000	1819000	But what I'm saying here is that I just want to take 10 elements and then print them out.
1819000	1828000	And what it will do is basically consume that until it hits 10, it prints out, go away.
1828000	1835000	It prints out a beautiful Christmas tree that's one-sided.
1836000	1839000	Pyramid, whatever, and stops there.
1839000	1843000	And anything that you have, like, for example, the users that we had,
1843000	1850000	you know, users from JSON, users.json, you can say as sequence
1850000	1852000	and convert it into lazy evaluation as well.
1852000	1855000	Okay, that's all we have the time to show you today.
1855000	1857000	Obviously there's way more to the language.
1857000	1861000	Go online, learn everything about it, and thank you very much,
1861000	1862000	and I'll hand it off to Andre.
1862000	1867000	Thank you, Hadi.
1867000	1869000	Hello, everybody.
1869000	1874000	So as you've seen, Kotlin already has many things in store,
1874000	1879000	but I'm the nasty person who adds new features before you learn the existing ones.
1879000	1883000	So I'll be telling you stories now, but I'll need to find a clicker.
1883000	1885000	You have a clicker?
1885000	1886000	No.
1886000	1887000	Okay.
1887000	1890000	Okay, so I'll be telling stories without a clicker.
1891000	1896000	So my job here is to tell you about what we're going to have in the future versions of Kotlin.
1896000	1898000	Oh, thank you very much.
1898000	1900000	Okay.
1900000	1906000	And the first big thing we're working on now is platforms,
1906000	1908000	supporting different platforms.
1908000	1912000	So historically, Kotlin compiles to JVM bytecode,
1912000	1914000	same as the Java programming language.
1914000	1920000	So we can run on the server, on the desktop, and of course on Android.
1920000	1923000	And it's just the same bytecode everywhere.
1923000	1927000	This is why we can run all versions of Android as well as new ones.
1927000	1931000	But the story doesn't end there because we're adding new platforms,
1931000	1935000	and recently we've added...
1935000	1939000	The God doesn't like platforms.
1939000	1941000	Recently, we added JavaScript,
1941000	1944000	which means Kotlin can now compile to JavaScript code
1944000	1947000	and run in the browser or on Node.js.
1947000	1952000	So now we support three major, very popular virtual machines,
1952000	1956000	JVM, Android, Dalvik, and JavaScript VMs.
1956000	1960000	But there are many use cases where a virtual machine is not practical
1960000	1962000	or is simply unavailable.
1962000	1967000	For example, for iOS, virtual machines are severely restricted.
1967000	1969000	You can do dynamic code generation.
1969000	1972000	Or for a small embedded system, a VM doesn't fit in.
1972000	1979000	Or for, say, a Linux command-line tool, the VM will be starting to for too long.
1979000	1981000	So let's now go there.
1981000	1984000	And that's why we're working on something called Kotlin Native.
1984000	1987000	It's currently available as a technology preview.
1987000	1992000	And there, we basically use LLVM to compile Kotlin down to native code
1992000	1995000	to standalone binaries that can run on different platforms.
1995000	1998000	Currently, we support iOS, Linux, and Mac.
1998000	2001000	And Windows is in the works.
2001000	2006000	So this is taking us to this vision with Kotlin
2006000	2011000	when it can run inside every component of a modern application
2011000	2013000	on any platform you like.
2013000	2018000	So think full-stack web applications with the server and the client,
2018000	2020000	both written in Kotlin.
2020000	2024000	Or think we use code between mobile platforms, Android and iOS
2024000	2028000	for example, or mix the two previous use cases
2028000	2031000	and get a real multi-platform scenario.
2031000	2037000	So our vision for Kotlin is having different modules in the same project
2037000	2040000	compiled to different platforms.
2040000	2042000	And of course, you want to share code there, right?
2042000	2045000	Because if you support so many different things,
2045000	2047000	you want to run the same code in different places.
2047000	2050000	And we're working on making that possible.
2050000	2053000	But there is a very important thing
2053000	2058000	because previously, many projects tried to unify platforms.
2058000	2062000	And this often ends up being like the least common denominator.
2062000	2066000	When you take only things that are available on all platforms,
2066000	2069000	you're basically stuck with a minimal interface.
2069000	2071000	And that's something we don't want to have there.
2071000	2075000	So we want you to be able to use all the platform-specific fancy APIs
2075000	2078000	like the newest version of Android or something else,
2078000	2080000	as much as you like.
2080000	2082000	And if you want to share some code,
2082000	2087000	only then you have to resort to some common APIs.
2087000	2089000	So the idea there is that you have a common module
2089000	2092000	with lots of business logic and stuff.
2092000	2095000	And it can work side by side with a platform-specific module
2095000	2097000	written also in Kotlin.
2097000	2099000	And those two can talk to each other.
2099000	2102000	So when you need, you leverage the platform API
2102000	2105000	and when you need, you use the common code.
2105000	2110000	So take away here, our future is multi-platform.
2110000	2112000	Next...
2112000	2114000	Oh.
2114000	2116000	Yeah.
2116000	2120000	And next big thing is coroutines.
2120000	2124000	So the rationale there is pretty straightforward.
2124000	2127000	Everybody needs to write a synchronous code, right?
2127000	2131000	Because the world is too big now for sequential execution.
2131000	2136000	And it's, yeah, it's our reality, but it's hard, right?
2136000	2139000	Who has written a synchronous code?
2139000	2141000	Quite so many hands.
2141000	2146000	Those of you who don't actually will be doing this very soon.
2146000	2148000	And the problem is that it's rather hard, actually,
2148000	2150000	to write sequential code.
2150000	2155000	Or it was hard before languages learned to support you in doing that
2155000	2157000	because the language can help you there a lot.
2157000	2160000	So basically, what we have with coroutines in Kotlin,
2160000	2164000	you write asynchronous code the same way you write synchronous code.
2164000	2166000	So what do you use in synchronous code?
2166000	2170000	Loops, ifs, breaks and continues, things like that, right?
2170000	2175000	And it's the same things you're using with coroutines for asynchronous code
2175000	2179000	so that the language keeps track of everything
2179000	2182000	and you don't have to express any intricate control flow
2182000	2185000	for asynchronous computation in your code.
2185000	2189000	No callbacks, no fancy functional structures.
2189000	2194000	It's just plain old sequential looking code.
2194000	2196000	And isn't it cool?
2196000	2200000	Thank you.
2200000	2206000	Yeah, so the idea with coroutines is that you basically have the same abstraction
2206000	2208000	for asynchronous and synchronous.
2208000	2214000	And also, it's a nice metaphor to think of them as almost free threads.
2214000	2218000	Like here's the only code example I'm showing you.
2219000	2222000	Basically, very many things that are traditionally done with threads
2222000	2225000	can be done with coroutines, but coroutines are extremely cheap.
2225000	2230000	So here on the slide, I have a code that creates 100,000 coroutines.
2230000	2231000	Think about that.
2231000	2234000	100,000 coroutines existing in parallel
2234000	2238000	and each one of them waits for one second and returns one.
2238000	2245000	So this program completes in one second,
2246000	2250000	almost one second, because all the coroutines wait in parallel, of course.
2250000	2255000	But if you try to do this with threads, it just doesn't work.
2255000	2258000	100,000 threads don't fit into memory.
2258000	2259000	That's it.
2259000	2262000	So with coroutines, it's a win-win situation.
2262000	2266000	You get lots of performance, so it's very efficient,
2266000	2268000	and the code is simple.
2268000	2270000	So take away here.
2270000	2274000	Check out coroutines because our future will likely be even more asynchronous
2274000	2275000	than our present.
2277000	2281000	So I'm almost done, and if you want to learn more about Kotlin,
2281000	2282000	check out our website.
2282000	2284000	We have a section for Android.
2284000	2290000	And also, we'll have a question-and-answer session right after this talk.
2290000	2295000	So come over to the developer sandbox, section C.
2295000	2298000	Myself and Hadi will be answering questions there.
2298000	2300000	So thank you very much for your attention.
2300000	2301000	Thank you.
