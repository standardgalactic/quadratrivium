{"text": " Hi everyone, and welcome to lecture 4 of MIT 6S191. In today's lecture, we're going to be talking about how we can use deep learning and neural networks to build systems that not only look for patterns in data, but actually can go a step beyond this to generate brand new synthetic examples based on those learned patterns. And this, I think, is an incredibly powerful idea, and it's a particular subfield of deep learning that has enjoyed a lot of success and gotten a lot of interest in the past couple of years, but I think there's still tremendous, tremendous potential of this field of deep generative modeling in the future and in the years to come, particularly as we see these types of models and the types of problems that they tackle becoming more and more relevant in a variety of application areas. All right, so to get started, I'd like to consider a quick question for each of you. Here we have three photos of faces, and I want you all to take a moment, look at these faces, study them, and think about which of these faces you think is real. Is it the face on the left? Is it the face in the center? Is it the face on the right? Which of these is real? Well, in truth, each of these faces are not real. They are all fake. These are all images that were synthetically generated by a deep neural network. None of these people actually exist in the real world. And hopefully, I think you all have appreciated the realism of each of these synthetic images, and this to me highlights the incredible power of deep generative modeling. And not only does it highlight the power of these types of algorithms and these types of models, but it raises a lot of questions about how we can consider the fair use and the ethical use of such algorithms as they are being deployed in the real world. So by setting this up and motivating in this way, I'd first, I now like to take a step back and consider fundamentally what is the type of learning that can occur when we are training neural networks to perform tasks such as these. So so far in this course, we've been considering what we call supervised learning problems, instances in which we are given a set of data and a set of labels associated with that data. And our goal is to learn a functional mapping that moves from data to labels. And those labels can be class labels or continuous values. And in this course, we've been concerned primarily with developing these functional mappings that can be described by deep neural networks. But at their core, these mappings could be anything, you know, any sort of statistical function. The topic of today's lecture is going to focus on what we call unsupervised learning, which is a new class of learning problems. And in contrast to supervised settings where we're given data and labels in unsupervised learning, we're given only data, no labels. And our goal is to train a machine learning or deep learning model to understand or build up a representation of the hidden and underlying structure in that data. And what this can do is it can allow sort of an insight into the foundational structure of the data. And then in turn, we can use this understanding to actually generate synthetic examples. And unsupervised learning beyond this domain of deep generative modeling also extends to other types of problems and example applications, which you may be familiar with, such as clustering algorithms or dimensionality reduction algorithms. Generative modeling is one example of unsupervised learning. And our goal in this case is to take as input examples from a training set and learn a model that represents the distribution of the data that is input to that model. And this can be achieved in two principal ways. The first is through what is called density estimation, where let's say we are given a set of data samples and they fall according to some density. The task for building a deep generative model applied to these samples is to learn the underlying probability density function that describes how and where these data fall along this distribution. And we can not only just estimate the density of such a probability density function, but actually use this information to generate new synthetic samples, where again we are considering some input examples that fall and are drawn from some training data distribution. And after building up a model using that data, our goal is now to generate synthetic examples that can be described as falling within the data distribution modeled by our model. So the key idea in both these instances is this question of how can we learn a probability distribution using our model, which we call P model of X, that is so similar to the true data distribution, which we call P data of X. This will not only enable us to effectively estimate these probability density functions, but also generate new synthetic samples that are realistic and match the distribution of the data we're considering. So this I think summarizes concretely what are the key principles behind generative modeling. But to understand that how generative modeling may be informative and also impactful, let's take this idea step further and consider what could be potential impactful applications and real world use cases of generative modeling. What generative models enable us as the users to do is to automatically uncover the underlying structure and features in a data set. The reason this can be really important and really powerful is often we do not know how those features are distributed within a particular data set of interest. So let's say we're trying to build up a facial detection classifier and we're given a data set of faces, for which we may not know the exact distribution of these faces with respect to key features like skin tone or pose or clothing items. And without going through our data set and manually inspecting each of these instances, our training data may actually be very biased with respect to some of these features without us even knowing it. And as you'll see in this lecture and in today's lab, what we can actually do is train generative models that can automatically learn the landscape of the features in a data set like these, like that of faces. And by doing so, actually uncover the regions of the training distribution that are underrepresented and overrepresented with respect to particular features such as skin tone. And the reason why this is so powerful is we can actually now use this information to actually adjust how the data is sampled during training to ultimately build up a more fair and more representative data set that then will lead to a more fair and unbiased model. And you'll get practice doing exactly this and implementing this idea in today's lab exercise. Another great example in use case where generative models are exceptionally powerful is this broad class of problems that can be considered outlier or anomaly detection. One example is in the case of self-driving cars where it's going to be really critical to ensure that an autonomous vehicle governed and operated by a deep neural network is able to handle all of the cases that it may encounter on the road, not just, you know, the straight freeway driving that is going to be the majority of the training data and the majority of the time the car experiences on the road. So generative models can actually be used to detect outliers within training distributions and use this to, again, improve the training process so that the resulting model can be better equipped to handle these edge cases and rare events. All right, so hopefully that motivates why and how generative models can be exceptionally powerful and useful for a variety of real world applications. To dive into the bulk of the technical content for today's lecture, we're going to discuss two classes of what we call latent variable models. Specifically we'll look at autoencoders and generative adversarial networks or GANs. But before we get into that, I'd like to first begin by discussing why these are called latent variable models and what we actually mean when we use this word latent. And to do so, I think really the best example that I've personally come across for understanding what a latent variable is, is this story that is from Plato's work, the Republic. And this story is called the myth of the cave or the parable of the cave. And the story is as follows. In this myth, there are a group of prisoners and these prisoners are constrained as part of their prison punishment to face a wall. And the only things that they can see on this wall are the shadows of particular objects that are being passed in front of a fire that's behind them. So behind their heads and out of their line of sight. And the prisoners, the only thing they're really observing are these shadows on the wall. And so to them, that's what they can see. That's what they can measure and that's what they can give names to. That's really their reality. These are their observed variables. But they can't actually directly observe or measure the physical objects themselves that are actually casting these shadows. So those objects are effectively what we can analyze like latent variables. They're the variables that are not directly observable, but they're the true explanatory factors that are creating the observable variables, which in this case, the prisoners are seeing, like the shadows cast on the wall. And so our question in generative modeling broadly is to find ways of actually learning these underlying and hidden latent variables in the data, even when we're only given the observations that are made. And this is an extremely, extremely complex problem that is very well suited to learning by neural networks because of their power to handle multidimensional data sets and to learn combinations of nonlinear functions that can approximate really complex data distributions. All right. So we'll first begin by discussing a simple and foundational generative model, which tries to build up these latent variable representation by actually self encoding the input. And these models are known as auto encoders. What an auto encoder is, is it's an approach for learning a lower dimensional latent space from raw data. To understand how it works, what we do is we feed in as input raw data, for example, this image of a two, that's going to be passed through many successive deep neural network layers. And at the output of that succession of neural network layers, what we're going to generate is a low dimensional latent space, a feature representation. And that's really the goal that we're trying to predict. And so we can call this portion of the network an encoder, since it's mapping the data, x, into a encoded vector of latent variables, z. So let's consider this latent space, z. If you've noticed, I've represented z as having a smaller size, a smaller dimensionality as the input x, why would it be important to ensure the low dimensionality of this latent space, z? Having a low dimensional latent space means that we are able to compress the data, which in the case of image data can be, you know, on the order of many, many, many dimensions, we can compress the data into a small latent vector, where we can learn a very compact and rich feature representation. So how can we actually train this model? Are we going to be able to supervise for the particular latent variables that we're interested in? Well, remember that this is an unsupervised problem, where we have training data, but no labels for the latent space, z. So in order to actually train such a model, what we can do is learn a decoder network and build up a decoder network that is used to actually reconstruct the original image starting from this lower dimensional latent space. And again, this decoder portion of our autoencoder network is going to be a series of layers, neural network layers like convolutional layers, that's going to then take this hidden latent vector and map it back up to the input space. And we call our reconstructed output x hat, because it's our prediction and it's an imperfect reconstruction of our input x. And the way that we can actually train this network is by looking at the original input x and our reconstructed output x hat and simply comparing the two and minimizing the distance between these two images. So for example, we could consider the mean squared error, which in the case of images means effectively subtracting one image from another and squaring the difference, which is effectively the pixel wise difference between the input and reconstruction, measuring how faithful our reconstruction is to the original input. And again, notice that by using this reconstruction loss, this difference between the reconstructed output and our original input, we do not require any labels for our data beyond the data itself. So we can simplify this diagram just a little bit by abstracting away these individual layers in the encoder and decoder components. And again, note once again that this loss function does not require any labels, it is just using the raw data to supervise itself on the output. And this is a truly powerful idea and a transformative idea because it enables the model to learn a quantity, the latent variables z, that we're fundamentally interested in, but we cannot simply observe or cannot readily model. And when we constrain this latent space to a lower dimensionality, that affects the degree to which and the faithfulness to which we can actually reconstruct the input. And the way you can think of this is as imposing a sort of information bottleneck during the models training and learning process. And effectively, what this bottleneck does is a form of compression, right? We're taking the input data, compressing it down to a much smaller latent space, and then building back up a reconstruction. And in practice, what this results in is that the lower the dimensionality of your latent space, the poorer and worse quality reconstruction you're going to get out. All right. So in summary, these autoencoder structures use this sort of bottlenecking hidden layer to learn a compressed latent representation of the data. And we can self-supervise the training of this network by using what we call a reconstruction loss that forces the autoencoder network to encode as much information about the data as possible into a lower dimensional latent space while still being able to build up faithful reconstructions. So the way I like to think of this is automatically encoding information from the data into a lower dimensional latent space. Let's now expand upon this idea a bit more and introduce this concept and architecture of variational autoencoders or VAEs. So as we just saw, traditional autoencoders go from input to reconstructed output. And if we pay closer attention to this latent layer denoted to here in orange, what you can hopefully realize is that this is just a normal layer in a neural network, just like any other layer. It's deterministic. If you're going to feed in a particular input to this network, you're going to get the same output so long as the weights are the same. So effectively, a traditional autoencoder learns this deterministic encoding, which allows for reconstruction and reproduction of the input. In contrast, variational autoencoders impose a stochastic or variational twist on this architecture. And the idea behind doing so is to generate smoother representations of the input data and improve the quality of the not only of reconstructions, but also to actually generate new images that are similar to the input data set, but not direct reconstructions of the input data. And the way this is achieved is that variational autoencoders replace that deterministic layer Z with a stochastic sampling operation. What this means is that instead of learning the latent variables Z directly, for each variable, the variational autoencoder learns a mean and a variance associated with that latent variable. And what those means and variances do is that they parametrize a probability distribution for that latent variable. So what we've done in going from an autoencoder to a variational autoencoder is going from a vector of latent variables Z to learning a vector of means mu and a vector of variances sigma, sigma squared, that parametrize these variables and define probability distributions for each of our latent variables. And the way we can actually generate new data instances is by sampling from the distribution defined by these mus and sigmas to generate a latent sample and get probabilistic representations of the latent space. And what I'd like you to appreciate about this network architecture is that it's very similar to the autoencoder I previously introduced, just that we have this probabilistic twist where we're now performing the sampling operation to compute samples from each of the latent variables. All right, so now because we've introduced this sampling operation, this stochasticity into our model, what this means for the actual computation and learning process of the network, the encoder and decoder, is that they're now probabilistic in their nature. And the way you can think of this is that our encoder is going to be trying to learn a probability distribution of the latent space Z given the input data X, while the decoder is going to take that learned latent representation and compute a new probability distribution of the input X given that latent distribution Z. And these networks, the encoder, the decoder, are going to be defined by separate sets of weights, phi and theta. And the way that we can train this variational autoencoder is by defining a loss function that's going to be a function of the data X as well as the sets of weights phi and theta. And what's key to how VAEs can be optimized is that this loss function is now comprised of two terms instead of just one. We have the reconstruction loss just as before, which again is going to capture this difference between the input and the reconstructed output, and also a new term to our loss, which we call the regularization loss, also called the VAE loss. And to take a look in more detail at why each of these loss terms represents, let's first emphasize again that our overall loss function is going to be defined and taken with respect to the sets of weights of the encoder and decoder and the input X. The reconstruction loss is very similar to before, right? And you can think of it as being driven by a log likelihood function, for example, for image data, the mean squared error between the input and the output. And we can self-supervise the reconstruction loss just as before to force the latent space to learn and represent faithful representations of the input data, ultimately resulting in faithful reconstructions. The new term here, the regularization term, is a bit more interesting and completely new at this stage, so we're going to dive in and discuss it further in a bit more detail. So our probability distribution that's going to be computed by our encoder, q phi of z of x, is a distribution on the latent space z given the data x. And what regularization enforces is that as a part of this learning process, we're going to place a prior on the latent space z, which is effectively some initial hypothesis about what we expect the distributions of z to actually look like. And by imposing this regularization term, what we can achieve is that the model will try to enforce the z's that it learns to follow this prior distribution. And we're going to denote this prior as p of z. This term here, d, is the regularization term. And what it's going to do is it's going to try to enforce a minimization of the divergence or the difference between what the encoder is trying to infer, the probability distribution of z given x, and that prior that we're going to place on the latent variables p of z. And the idea here is that by imposing this regularization factor, we can try to keep the network from overfitting on certain parts of the latent space by enforcing the fact that we want to encourage the latent variables to adopt a distribution that's similar to our prior. So we're going to go through now, you know, both the mathematical basis for this regularization term as well as a really intuitive walkthrough of what regularization achieves to help give you a concrete understanding and an intuitive understanding about why regularization is important and why placing a prior is important. So let's first consider, yeah, so to re-emphasize once again, this regularization term is going to consider the divergence between our inferred latent distribution and the fixed prior we're going to place. So before we to get into this, let's consider what could be a good choice of prior for each of these latent variables. How do we select p of z? I'll first tell you what's commonly done. The common choice that's used very extensively in the community is to enforce the latent variables to roughly follow normal Gaussian distributions, which means that they're going to be a normal distribution centered around mean zero and have a standard deviation and variance of one. By placing these normal Gaussian priors on each of the latent variables and therefore on our latent distribution overall, what this encourages is that the learned encodings learned by the encoder portion of our VAE are going to be sort of distributed evenly around the center of each of the latent variables. And if you can imagine and picture when you have sort of a roughly even distribution around the center of a particular region of the latent space, what this means is that outside of this region, far away, there's going to be a greater penalty and this can result in instances from instances where the network is trying to cheat and try to cluster particular points outside the center, these centers in the latent space, like if it was trying to memorize particular outliers or edge cases in the data. After we place a normal Gaussian prior on our latent variables, we can now begin to concretely define the regularization term component of our loss function. This loss, this term to the loss is very similar in principle to a cross entropy loss that we saw before, where the key is that we're going to be defining the distance function that describes the difference or the divergence between the inferred latent distribution q, phi of z given x and the prior that we're going to be placing p of z. And this term is called the Kublack-Liebler or KL divergence. And when we choose a normal Gaussian prior, we, this results in the KL divergence taking this particular form of this equation here, where we're using the means and sigmas as input and computing this distance metric that captures the divergence of that learned latent variable distribution from the normal Gaussian. All right. So now I really want to spend a bit of time to get some, build up some intuition about how this regularization and works and why we actually want to regularize our VAE and then also why we select a normal prior. All right. So to do this, let's, let's consider the following question. What properties do we want this to achieve from regularization? Why are we actually regularizing our, our network in the first place? The first key property that we want for a generative model like a VAE is what I can, what I like to think of as continuity, which means that if there are points that are represented closely in the latent space, they should also result in similar reconstructions, similar outputs, similar content after they are decoded. You would expect intuitively that regions in the latent space have some notion of distance or similarity to each other. And this indeed is a really key property that we want to achieve with our generative model. The second property is completeness and it's very related to continuity. And what this means is that when we sample from the latent space to decode the latent space into an output, that should result in a meaningful reconstruction, a meaningful, uh, sampled content that is, you know, resembling the original data distribution. You can imagine that if we're sampling from the latent space and just getting garbage out that has no relationship to our input, this could be a huge, huge problem for our model. All right. So with these two properties in mind, continuity and completeness, let's consider the consequences of what can occur if we do not regularize our model. Well, without regularization, what could end up happening with respect to these two properties is that there could be instances of points that are close in latent space, but not similarly decoded. So I'm using this really intuitive illustration where these dots represent abstracted away sort of regions in the latent space. And the shapes that they relate to, you can think of as what is going to be decoded after those instances in the latent space are passed through the decoder. So in this example, we have these two dots, the greenish dot and the reddish dot, that are physically close in latent space, but result in completely different shapes when they're decoded. We also have an instance of this purple point, which when it's decoded, it doesn't result in a meaningful content. It's just a scribble. So by not regularizing, and I'm abstracting a lot away here, and that's on purpose, we could have these instances where we don't have continuity and we don't have completeness. Therefore, our goal with regularization is to be able to realize a model where points that are close in the latent space are not only similarly decoded, but also meaningfully decoded. So for example, here, we have the red dot and the orange dot, which result in both triangle-like shapes, but with slight variations on the on the triangle itself. So this is the intuition about what regularization can enable us to achieve and what are desired properties for these generative models. Okay, how can we actually achieve this regularization? And how does the normal prior fit in? As I mentioned, right, VAEs, they don't just learn the latent variable Z directly. They're trying to encode the inputs as distributions that are defined by mean and variance. So my first question to you is, is it going to be sufficient to just learn mean and variance, learn these distributions? Can that guarantee continuity and completeness? No, and let's understand why. All right, without any sort of regularization, what could the model try to resort to? Remember that the VAE or that the VAE, the loss function is defined by both a reconstruction term and a regularization term. If there is no regularization, you can bet that the model is going to just try to optimize that reconstruction term. So it's effectively going to learn to minimize the reconstruction loss, even though we're encoding the latent variables via mean and variance. And two instances, two consequences of that is that you can have instances where these learned variances for the latent variable end up being very, very, very small, effectively resulting in pointed distributions. And you can also have means that are totally divergent from each other, which result in discontinuities in the latent space. And this can occur while still trying to optimize that reconstruction loss, direct consequence of not regularizing. By, in order to overcome these problems, we need to regularize the variance and the mean of these distributions that are being returned by the encoder. And the normal prior, placing that normal Gaussian distribution as our prior helps us achieve this. And to understand why exactly this occurs, is that effectively the normal prior is going to encourage these learned latent variable distributions to overlap in latent space. Recall, right? Mean zero, variance of one. That means all the, all the latent variables are going to be enforced to try to have the same mean, a centered mean, and all the variances are going to be regularized for each and every of the latent variable distributions. And so this will ensure a smoothness and a regularity and an overlap in the latent space, which will be very effective in helping us achieve these properties of continuity and completeness. Centering the means, regularizing the variances. So the regularization via this normal prior, by centering each of these latent variables, regularizing their, their variances, is that it helps enforce this continuous and complete gradient of information. Represented in the latent space, where again points and distances in the latent space have some relationship to the reconstructions and the content of the reconstructions that result. Note though that there's going to be a tradeoff between regularizing and reconstructing. The more we regularize, there's also a risk of suffering, the quality of the reconstruction and the generation process itself. So in optimizing gaze, there's going to be this tradeoff that's going to try to be tuned to fit the problem of interest. All right. So hopefully by walking through this, this example, and considering these points, you've built up a more intuition about why regularization is important and how specifically the normal prior can help us regularize. Great. So now we've defined our loss function, we know that we can reconstruct the inputs, we've understood how we can regularize learning and achieve continuity and completeness via this normal prior. These are all the components that define a forward pass through the network, going from input to encoding to decoded reconstruction. But we're still missing a critical step in putting the whole picture together. And that's, that's a critical step putting the whole picture together. And that's a back propagation. And the key here is that because of this fact that we've introduced this stochastic sampling layer, we now have a problem where we can't back propagate gradients through a sampling layer that has this element of stochasticity. Back propagation requires deterministic nodes, deterministic layers for which we can iteratively apply the chain rule to optimize gradients. Optimize the loss via gradient descent. All right. VAEs introduced sort of a breakthrough idea that solved this issue of not being able to back propagate through a sampling layer. And the key idea was to actually subtly reparameterize the sampling operation such that the network could be trained completely end to end. So as we, as we already learned, right, we're trying to build up this latent distribution defined by these variables z define it placing a normal prior defined by a mean and a variance. And we can't simply back propagate gradients through the sampling layer because we can't compute gradients through this stochastic sample. The key idea instead is to try to consider the sampled latent vector z as a sum defined by a fixed mu a fixed sigma vector and scale that sigma vector by random constants that are going to be drawn from a prior distribution such as a normal Gaussian. And by reparameterizing the sampling operation as, as so, we still have this element of stochasticity, but that stochasticity is introduced by this random constant epsilon, which is not occurring within the bottleneck latent layer itself. We've reparameterized and distributed it elsewhere. To visualize how this looks, let's consider it the following where originally in the original form of the VAE, we had this deterministic nodes, which are the weights of the network, as well as an input vector, and we are trying to back propagate through the stochastic sampling node z. But we can't do that. So now, by reparameterization, what we've achieved is the following form where our latent variable z are defined with respect to mu sigma squared, as well as these noise factor epsilon, such that when we want to do back propagation through the network to update, we can directly back propagate through z defined by mu and sigma squared, because this epsilon value is just taken as a constant, it's reparameterized elsewhere. And this is a very, very powerful trick, the reparameterization trick, because it enables us to train variational auto encoders end to end by back propagating with respect to z and with respect to the actual weights of the encoder network. All right. One side effect and one consequence of imposing these distributional priors on the latent variable is that we can actually sample from these latent variables and individually tune them while keeping all of the other variables fixed. And what you can do is you can tune the value of a particular latent variable and run the decoder each time that variable is changed, each time that variable is perturbed to generate a new reconstructed output. So an example of that result is in the following, where this perturbation of the latent variables results in a representation that has some semantic meaning about what the network is maybe learning. So in this example, these images show variation in head pose. And the different dimensions of z, the latent space, the different latent variables, are in this way encoding different latent features that can be interpreted by keeping all other variables fixed and perturbing the value of one individual latent variable. Ideally, in order to optimize VAEs and try to maximize the information that they encode, we want these latent variables to be uncorrelated with each other, effectively disentangled. And what that could enable us to achieve is to learn the richest and most compact latent representation possible. So in this case, we have head pose on the x axis and smile on the y axis. And we want these to be as uncorrelated with each other as possible. One way we can achieve this, that's been shown to achieve this disentanglement, is rather a quite straightforward approach called beta VAEs. So if we consider the loss of a standard VAE, again, we have this reconstruction term defined by a log likelihood and a regularization term defined by the KL divergence. Beta VAEs introduce a new hyper parameter beta, which controls the strength of this regularization term. And it's been shown mathematically that by increasing beta, the effect is to place constraints on the latent encoding, such as to encourage disentanglement. And there have been extensive proofs and discussions as to how exactly this is achieved. But to consider the results, let's again consider the problem of face reconstruction. Where using a standard VAE, if we consider the latent variable of head pose or rotation, in this case where beta equals one, what you can hopefully appreciate is that as the face pose is changing, the smile of some of these faces is also changing. In contrast, by enforcing a beta much larger than one, what is able to be achieved is that the smile remains relatively constant while we can perturb the single latent variable of the head rotation and achieve perturbations with respect to head rotation alone. All right. So as I motivated and introduced in the beginning and the introduction of this lecture, one powerful application of generative models and latent variable models is in model debiasing. And in today's lab, you're actually going to get real hands-on experience in building a variational autoencoder that can be used to achieve automatic debiasing of facial classification systems, facial detection systems. And the power and the idea of this approach is to build up a representation, a learned latent distribution of face data, and use this to identify regions of that latent space that are going to be overrepresented or underrepresented. And that's going to all be taken with respect to particular learned features such as skin tone, pose, objects, clothing. And then from these learned distributions, we can actually adjust the training process such that we can place greater weight and greater sampling on those images and on those faces the fall in the regions of the latent space that are underrepresented automatically. And what's really, really cool about deploying a VAE or a latent variable model for an application like model debiasing is that there's no need for us to annotate and prescribe the features that are important to actually debize against. The model learns them automatically. And this is going to be the topic of today's lab. And it also opens the door to a much broader space that's going to be explored further in a later spotlight lecture that's going to focus on algorithmic bias and machine learning fairness. All right, so to summarize the key points on VAEs, they compress representation of data into an encoded representation. Reconstruction of the data input allows for unsupervised learning without labels. We can use the reparameterization trick to train VAEs end to end. We can take hidden latent variables, perturb them to interpret their content and their meaning. And finally, we can sample from the latent space to generate new examples. But what if we wanted to focus on generating samples and synthetic samples that were as faithful to a data distribution generally as possible? To understand how we can achieve this, we're going to transition to discuss a new type of generative model called a generative adversarial network or GAN for short. The idea here is that we don't want to explicitly model the density or the or the distribution underlying some data, but instead just learn a representation that can be successful in generating new instances that are similar to the data, which means that we want to optimize to sample from a very, very complex distribution, which cannot be learned and modeled directly. Instead, we're going to have to build up some approximation of this distribution. And the really cool and breakthrough idea of GANs is to start from something extremely, extremely simple, just random noise and try to build a neural network, a generative neural network that can learn a functional transformation that goes from noise to the data distribution. And by learning this functional generative mapping, we can then sample in order to generate fake instances, synthetic instances that are going to be as close to the real data distribution as possible. The breakthrough to achieving this was this structure called GANs, where the key component is to have two neural networks, a generator network and a discriminator network that are effectively competing against each other, their adversaries. Specifically, we have a generator network, which I'm going to denote here on out by G, that's going to be trained to go from random noise to produce an imitation of the data. And then the discriminator is going to take that synthetic fake data, as well as real data, and be trained to actually distinguish between fake and real. And in training, these two networks are going to be competing against each other. And so in doing so, overall, the effect is that the discriminator is going to get better and better at learning how to classify real and fake. And the better it becomes at doing that, it's going to force the generator to try to produce better and better synthetic data to try to fool the discriminator back and forth, back and forth. So let's now break this down and go from a very simple toy example to get more intuition about how these GANs work. The generator is going to start, again, from some completely random noise and produce fake data. And I'm going to show that here by representing these data as points on a one-dimensional line. The discriminator is then going to see these points, as well as real data. And then it's going to be trained to output a probability that the data it sees are real, or if they are fake. And in the beginning, it's not going to be trained very well, right? So its predictions are not going to be very good. But then you're going to train it, and you're going to train it. And it's going to start increasing the probabilities of real versus not real appropriately, such that you get this perfect separation where the discriminator is able to perfectly distinguish what is real and what is fake. Now it's back to the generator. And the generator is going to come back. It's going to take instances of where the real data lie as inputs to train. And then it's going to try to improve its imitation of the data, trying to move the fake data, the synthetic data that is generated closer and closer to the real data. And once again, the discriminator is now going to receive these new points. And it's going to estimate a probability that each of these points is real. And again, learn to decrease the probability of the fake points being real, further and further. And now we're going to repeat again. And one last time, the generator is going to start moving these fake points closer and closer to the real data, such that the fake data are almost following the distribution of the real data. At this point, it's going to be really, really hard for the discriminator to effectively distinguish between what is real and what is fake. While the generator is going to continue to try to create fake data instances to fool the discriminator. And this is really the key intuition behind how these two components of GANs are essentially competing with each other. All right. So to summarize how we train GANs, the generator is going to try to synthesize fake instances to fool a discriminator, which is going to be trained to identify the synthesized instances and discriminate these as fake. To actually train, we're going to see that we are going to define a loss function that defines competing and adversarial objectives for each of the discriminator and the generator. And a global optimum, the best we could possibly do would mean that the generator could perfectly reproduce the true data distribution, such that the discriminator absolutely cannot tell what's synthetic versus what's real. So let's go through how the loss function for GAN breaks down. The loss term for GAN is based on that familiar cross entropy loss. And it's going to now be defined between the true and generated distributions. So we're first going to consider the loss from the perspective of the discriminator. We want to try to maximize the probability that the fake data is identified as fake. And so to break this down here, G of Z defines the generator's output. And so D of G of Z is the discriminator's estimate of the probability that a fake instance is actually fake. D of X is the discriminator's estimate of the probability that a real instance is fake. So 1 minus D of X is its probability estimate that a real instance is real. So together, from the point of view of the discriminator, we want to maximize this probability. Maximize probability fake is fake. Maximize the estimate of probability real is real. Now let's turn our attention to the generator. Remember that the generator is taking random noise and generating an instance. It cannot directly affect the term D of X, which shows up in the loss, right? Because D of X is solely based on the discriminator's operation on the real data. So for the generator, the generator is going to have the adversarial objective to the discriminator, which means it's going to try to minimize this term. Effectively minimizing the probability that the discriminator can distinguish its generated data as fake. D of G of Z. And the goal for the generator is to minimize this term of the objective. So the objective of the generator is to try to synthesize fake instances that fool the discriminator. And eventually, over the course of training the discriminator, the discriminator is going to be as best as it possibly can be at discriminating real versus fake. Therefore, the ultimate goal of the generator is to synthesize fake instances that fool the best discriminator. And this is all put together in this min max objective function, which has these two components optimized adversarily. And then after training, we can actually use the generator network, which is now fully trained to produce new data instances that have never been seen before. So we're going to focus on that now. And what is really cool is that when the trained generator of again, synthesizes new instances, it's effectively learning a transformation from a distribution of noise to a target data distribution. And that transformation, that mapping is going to be what's learned over the course of training. So if we consider one point from a latent noise distribution, it's going to result in a particular output in the target data space. And if we consider another point of random noise, feed it through the generator, it's going to result in a new instance that and that new instance is going to fall somewhere else on the data manifold. And indeed, what we can actually do is interpolate and trans and traverse in the space of Gaussian noise to result in interpolation in the target space. And you can see an example of this result here, where a transformation in series reflects a traversal across the target data manifold. And that's produced in the synthetic examples that are outputted by the generator. All right. So in the final few minutes of this lecture, I'm going to highlight some of the recent advances in GANs and hopefully motivate even further why this approach is so powerful. So one idea that's been extremely, extremely powerful is this idea of progressive GANs, progressive growing, which means that we can iteratively build more detail into the generated instances that are produced. And this is done by progressively adding layers of increasing spatial resolution in the case of image data. And by incrementally building up both the generator and discriminator networks in this way as training progresses, it results in very well resolved synthetic images that are output ultimately by the generator. So some results of this idea of progressive, a progressive GAN are displayed here. Another idea that has also led to tremendous improvement in the quality of synthetic examples generated by GANs is a architecture improvement called style GAN, which combines this idea of progressive growing that I introduced earlier with principles of style transfer, which means trying to compose an image in the style of another image. So for example, what we can now achieve is to map input images source A using application of coarse grained styles from secondary sources onto those targets to generate new instances that mimic the style of source B. And that result is shown here. And hopefully you can appreciate that these coarse grained features, these coarse grained styles like age, facial structure, things like that can be reflected in these synthetic examples. This same style GAN system has led to tremendously realistic synthetic images in the areas of both face synthesis as well as for animals, other objects as well. Another extension to the GAN architecture that has enabled particularly powerful applications for select problems and tasks is this idea of conditioning, which imposes a bit of additional further structure on the types of outputs that can be synthesized by GAN. So the idea here is to condition on a particular label by supplying what is called a conditioning factor denoted here as C. And what this allows us to achieve is instances like that of paired translation in the case of image synthesis, where now instead of a single input as training data for our generator, we have pairs of inputs. So for example here we consider both a driving scene and a corresponding segmentation map to that driving scene. And the discriminator can in turn be trained to classify fake and real pairs of data. And again the generator is going to be trained to try to fool the discriminator. Example applications of this idea are seen as follows where we can now go from an input of a semantic segmentation map to generate a synthetic street scene mapping according to that segmentation. Or we can go from an aerial view from a satellite image to a street map view or from particular labels of an architectural building to a synthetic architectural facade or day to night, black and white to color, edges to photos, different instances of paired translation that are achieved by conditioning on particular labels. So another example which I think is really cool and interesting is translating from Google Street View to a satellite view and vice versa. And we can also achieve this dynamically. So for example in coloring given an edge input, the network can be trained to actually synthetically color in the artwork that is resulting from this particular edge sketch. Another idea instead of paired translation is that of unpaired image to image translation. And this is going to be achieved by a network architecture called CycleGAN where the model is taking as input images from one domain and is able to learn a mapping that translates to another domain without having a paired corresponding image in that other domain. So the idea here is to transfer the style and the distribution from one domain to another. And this is achieved by introducing the cyclic relationship and a cyclic loss function where we can go back and forth between a domain x and a domain y. And in this system there are actually two generators and two discriminators that are going to be trained on their respective generation and discrimination tasks. In this example the CycleGAN has been trained to try to translate from the domain of horses to the domain of zebras. And hopefully you can appreciate that in this example there's a transformation of the skin of the horse from brown to a zebra-like skin in stripes. And beyond this there's also a transformation of the surrounding area from green grass to something that's more brown in the case of the zebra. And I think to get an intuition about how this CycleGAN transformation is going is working. Let's go back to the idea that conventional GANs are moving from a distribution of Gaussian noise to some target data manifold. With CycleGANs the goal is to go from a particular data manifold x to another data manifold y. And in both cases and I think the underlying concept that makes GANs so powerful is that they function as very very effective distribution transformers and it can achieve these distribution transformations. Finally I'd like to consider one additional application that you may be familiar with of using CycleGANs and that's to transform speech and to actually use this CycleGAN technique to synthesize speech in someone else's voice. And the way this is done is by taking a bunch of audio recordings in one voice and audio recordings in another voice and converting those audio waveforms into an image representation which was called a spectrogram. We can then train a CycleGAN to operate on these spectrogram images to transform representations from voice A to make them appear like they appear that they are from another voice, voice B. And this is exactly how we did the speech transformation for the synthesis of Obama's voice in the demonstration that Alexander gave in the first lecture. So to inspect this further let's compare side by side the original audio from Alexander as well as the synthesized version in Obama's voice that was generated using a CycleGAN. Hi everybody and welcome to MIT 6S191, you know, facial introductory course on speech learning here at MIT. So notice that the spectrogram that results for Obama's voice is actually generated by an operation on Alexander's voice and effectively learning a domain transformation from Obama domain onto the domain of Alexander domain and the end result is that we create and synthesize something that's more Obama-like. All right so to summarize hopefully over the course of this lecture you built up understanding of generative modeling and classes of generative models that are particularly powerful in enabling probabilistic density estimation as well as sample generation. And with that I'd like to close the lecture and introduce you to the remainder of today's course which is going to focus on our second lab on computer vision, specifically exploring this question of debiasing in facial detection systems and using variational autoencoders to actually achieve an approach for automatic debiasing of classification systems. So I encourage you to come to the class gather town to have your questions on the lab's answered and to discuss further with any of us. Thank you.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 15.44, "text": " Hi everyone, and welcome to lecture 4 of MIT 6S191.", "tokens": [50364, 2421, 1518, 11, 293, 2928, 281, 7991, 1017, 295, 13100, 1386, 50, 3405, 16, 13, 51136], "temperature": 0.0, "avg_logprob": -0.18654982248942056, "compression_ratio": 1.3529411764705883, "no_speech_prob": 0.028386190533638}, {"id": 1, "seek": 0, "start": 15.44, "end": 19.64, "text": " In today's lecture, we're going to be talking about how we can use deep learning and neural", "tokens": [51136, 682, 965, 311, 7991, 11, 321, 434, 516, 281, 312, 1417, 466, 577, 321, 393, 764, 2452, 2539, 293, 18161, 51346], "temperature": 0.0, "avg_logprob": -0.18654982248942056, "compression_ratio": 1.3529411764705883, "no_speech_prob": 0.028386190533638}, {"id": 2, "seek": 0, "start": 19.64, "end": 24.8, "text": " networks to build systems that not only look for patterns in data, but actually can go", "tokens": [51346, 9590, 281, 1322, 3652, 300, 406, 787, 574, 337, 8294, 294, 1412, 11, 457, 767, 393, 352, 51604], "temperature": 0.0, "avg_logprob": -0.18654982248942056, "compression_ratio": 1.3529411764705883, "no_speech_prob": 0.028386190533638}, {"id": 3, "seek": 2480, "start": 24.8, "end": 31.76, "text": " a step beyond this to generate brand new synthetic examples based on those learned patterns.", "tokens": [50364, 257, 1823, 4399, 341, 281, 8460, 3360, 777, 23420, 5110, 2361, 322, 729, 3264, 8294, 13, 50712], "temperature": 0.0, "avg_logprob": -0.15194238273842822, "compression_ratio": 1.755813953488372, "no_speech_prob": 0.40691766142845154}, {"id": 4, "seek": 2480, "start": 31.76, "end": 36.84, "text": " And this, I think, is an incredibly powerful idea, and it's a particular subfield of deep", "tokens": [50712, 400, 341, 11, 286, 519, 11, 307, 364, 6252, 4005, 1558, 11, 293, 309, 311, 257, 1729, 1422, 7610, 295, 2452, 50966], "temperature": 0.0, "avg_logprob": -0.15194238273842822, "compression_ratio": 1.755813953488372, "no_speech_prob": 0.40691766142845154}, {"id": 5, "seek": 2480, "start": 36.84, "end": 42.040000000000006, "text": " learning that has enjoyed a lot of success and gotten a lot of interest in the past couple", "tokens": [50966, 2539, 300, 575, 4626, 257, 688, 295, 2245, 293, 5768, 257, 688, 295, 1179, 294, 264, 1791, 1916, 51226], "temperature": 0.0, "avg_logprob": -0.15194238273842822, "compression_ratio": 1.755813953488372, "no_speech_prob": 0.40691766142845154}, {"id": 6, "seek": 2480, "start": 42.040000000000006, "end": 47.519999999999996, "text": " of years, but I think there's still tremendous, tremendous potential of this field of deep", "tokens": [51226, 295, 924, 11, 457, 286, 519, 456, 311, 920, 10048, 11, 10048, 3995, 295, 341, 2519, 295, 2452, 51500], "temperature": 0.0, "avg_logprob": -0.15194238273842822, "compression_ratio": 1.755813953488372, "no_speech_prob": 0.40691766142845154}, {"id": 7, "seek": 2480, "start": 47.519999999999996, "end": 52.18, "text": " generative modeling in the future and in the years to come, particularly as we see these", "tokens": [51500, 1337, 1166, 15983, 294, 264, 2027, 293, 294, 264, 924, 281, 808, 11, 4098, 382, 321, 536, 613, 51733], "temperature": 0.0, "avg_logprob": -0.15194238273842822, "compression_ratio": 1.755813953488372, "no_speech_prob": 0.40691766142845154}, {"id": 8, "seek": 5218, "start": 52.18, "end": 57.54, "text": " types of models and the types of problems that they tackle becoming more and more relevant", "tokens": [50364, 3467, 295, 5245, 293, 264, 3467, 295, 2740, 300, 436, 14896, 5617, 544, 293, 544, 7340, 50632], "temperature": 0.0, "avg_logprob": -0.1283553930429312, "compression_ratio": 1.6528925619834711, "no_speech_prob": 0.01132375281304121}, {"id": 9, "seek": 5218, "start": 57.54, "end": 60.54, "text": " in a variety of application areas.", "tokens": [50632, 294, 257, 5673, 295, 3861, 3179, 13, 50782], "temperature": 0.0, "avg_logprob": -0.1283553930429312, "compression_ratio": 1.6528925619834711, "no_speech_prob": 0.01132375281304121}, {"id": 10, "seek": 5218, "start": 60.54, "end": 68.0, "text": " All right, so to get started, I'd like to consider a quick question for each of you.", "tokens": [50782, 1057, 558, 11, 370, 281, 483, 1409, 11, 286, 1116, 411, 281, 1949, 257, 1702, 1168, 337, 1184, 295, 291, 13, 51155], "temperature": 0.0, "avg_logprob": -0.1283553930429312, "compression_ratio": 1.6528925619834711, "no_speech_prob": 0.01132375281304121}, {"id": 11, "seek": 5218, "start": 68.0, "end": 73.5, "text": " Here we have three photos of faces, and I want you all to take a moment, look at these", "tokens": [51155, 1692, 321, 362, 1045, 5787, 295, 8475, 11, 293, 286, 528, 291, 439, 281, 747, 257, 1623, 11, 574, 412, 613, 51430], "temperature": 0.0, "avg_logprob": -0.1283553930429312, "compression_ratio": 1.6528925619834711, "no_speech_prob": 0.01132375281304121}, {"id": 12, "seek": 5218, "start": 73.5, "end": 78.9, "text": " faces, study them, and think about which of these faces you think is real.", "tokens": [51430, 8475, 11, 2979, 552, 11, 293, 519, 466, 597, 295, 613, 8475, 291, 519, 307, 957, 13, 51700], "temperature": 0.0, "avg_logprob": -0.1283553930429312, "compression_ratio": 1.6528925619834711, "no_speech_prob": 0.01132375281304121}, {"id": 13, "seek": 5218, "start": 78.9, "end": 80.74000000000001, "text": " Is it the face on the left?", "tokens": [51700, 1119, 309, 264, 1851, 322, 264, 1411, 30, 51792], "temperature": 0.0, "avg_logprob": -0.1283553930429312, "compression_ratio": 1.6528925619834711, "no_speech_prob": 0.01132375281304121}, {"id": 14, "seek": 8074, "start": 80.74, "end": 83.14, "text": " Is it the face in the center?", "tokens": [50364, 1119, 309, 264, 1851, 294, 264, 3056, 30, 50484], "temperature": 0.0, "avg_logprob": -0.13563862033918792, "compression_ratio": 1.76036866359447, "no_speech_prob": 0.0005192607059143484}, {"id": 15, "seek": 8074, "start": 83.14, "end": 85.3, "text": " Is it the face on the right?", "tokens": [50484, 1119, 309, 264, 1851, 322, 264, 558, 30, 50592], "temperature": 0.0, "avg_logprob": -0.13563862033918792, "compression_ratio": 1.76036866359447, "no_speech_prob": 0.0005192607059143484}, {"id": 16, "seek": 8074, "start": 85.3, "end": 87.5, "text": " Which of these is real?", "tokens": [50592, 3013, 295, 613, 307, 957, 30, 50702], "temperature": 0.0, "avg_logprob": -0.13563862033918792, "compression_ratio": 1.76036866359447, "no_speech_prob": 0.0005192607059143484}, {"id": 17, "seek": 8074, "start": 87.5, "end": 93.33999999999999, "text": " Well, in truth, each of these faces are not real.", "tokens": [50702, 1042, 11, 294, 3494, 11, 1184, 295, 613, 8475, 366, 406, 957, 13, 50994], "temperature": 0.0, "avg_logprob": -0.13563862033918792, "compression_ratio": 1.76036866359447, "no_speech_prob": 0.0005192607059143484}, {"id": 18, "seek": 8074, "start": 93.33999999999999, "end": 94.46, "text": " They are all fake.", "tokens": [50994, 814, 366, 439, 7592, 13, 51050], "temperature": 0.0, "avg_logprob": -0.13563862033918792, "compression_ratio": 1.76036866359447, "no_speech_prob": 0.0005192607059143484}, {"id": 19, "seek": 8074, "start": 94.46, "end": 100.03999999999999, "text": " These are all images that were synthetically generated by a deep neural network.", "tokens": [51050, 1981, 366, 439, 5267, 300, 645, 10657, 22652, 10833, 538, 257, 2452, 18161, 3209, 13, 51329], "temperature": 0.0, "avg_logprob": -0.13563862033918792, "compression_ratio": 1.76036866359447, "no_speech_prob": 0.0005192607059143484}, {"id": 20, "seek": 8074, "start": 100.03999999999999, "end": 103.66, "text": " None of these people actually exist in the real world.", "tokens": [51329, 14492, 295, 613, 561, 767, 2514, 294, 264, 957, 1002, 13, 51510], "temperature": 0.0, "avg_logprob": -0.13563862033918792, "compression_ratio": 1.76036866359447, "no_speech_prob": 0.0005192607059143484}, {"id": 21, "seek": 8074, "start": 103.66, "end": 110.16, "text": " And hopefully, I think you all have appreciated the realism of each of these synthetic images,", "tokens": [51510, 400, 4696, 11, 286, 519, 291, 439, 362, 17169, 264, 38484, 295, 1184, 295, 613, 23420, 5267, 11, 51835], "temperature": 0.0, "avg_logprob": -0.13563862033918792, "compression_ratio": 1.76036866359447, "no_speech_prob": 0.0005192607059143484}, {"id": 22, "seek": 11016, "start": 110.16, "end": 114.8, "text": " and this to me highlights the incredible power of deep generative modeling.", "tokens": [50364, 293, 341, 281, 385, 14254, 264, 4651, 1347, 295, 2452, 1337, 1166, 15983, 13, 50596], "temperature": 0.0, "avg_logprob": -0.11675904977201211, "compression_ratio": 1.6979591836734693, "no_speech_prob": 0.0006070173112675548}, {"id": 23, "seek": 11016, "start": 114.8, "end": 117.96, "text": " And not only does it highlight the power of these types of algorithms and these types", "tokens": [50596, 400, 406, 787, 775, 309, 5078, 264, 1347, 295, 613, 3467, 295, 14642, 293, 613, 3467, 50754], "temperature": 0.0, "avg_logprob": -0.11675904977201211, "compression_ratio": 1.6979591836734693, "no_speech_prob": 0.0006070173112675548}, {"id": 24, "seek": 11016, "start": 117.96, "end": 124.56, "text": " of models, but it raises a lot of questions about how we can consider the fair use and", "tokens": [50754, 295, 5245, 11, 457, 309, 19658, 257, 688, 295, 1651, 466, 577, 321, 393, 1949, 264, 3143, 764, 293, 51084], "temperature": 0.0, "avg_logprob": -0.11675904977201211, "compression_ratio": 1.6979591836734693, "no_speech_prob": 0.0006070173112675548}, {"id": 25, "seek": 11016, "start": 124.56, "end": 130.6, "text": " the ethical use of such algorithms as they are being deployed in the real world.", "tokens": [51084, 264, 18890, 764, 295, 1270, 14642, 382, 436, 366, 885, 17826, 294, 264, 957, 1002, 13, 51386], "temperature": 0.0, "avg_logprob": -0.11675904977201211, "compression_ratio": 1.6979591836734693, "no_speech_prob": 0.0006070173112675548}, {"id": 26, "seek": 11016, "start": 130.6, "end": 137.48, "text": " So by setting this up and motivating in this way, I'd first, I now like to take a step", "tokens": [51386, 407, 538, 3287, 341, 493, 293, 41066, 294, 341, 636, 11, 286, 1116, 700, 11, 286, 586, 411, 281, 747, 257, 1823, 51730], "temperature": 0.0, "avg_logprob": -0.11675904977201211, "compression_ratio": 1.6979591836734693, "no_speech_prob": 0.0006070173112675548}, {"id": 27, "seek": 13748, "start": 137.48, "end": 143.07999999999998, "text": " back and consider fundamentally what is the type of learning that can occur when we are", "tokens": [50364, 646, 293, 1949, 17879, 437, 307, 264, 2010, 295, 2539, 300, 393, 5160, 562, 321, 366, 50644], "temperature": 0.0, "avg_logprob": -0.12886810302734375, "compression_ratio": 1.6680327868852458, "no_speech_prob": 0.12241849303245544}, {"id": 28, "seek": 13748, "start": 143.07999999999998, "end": 147.33999999999997, "text": " training neural networks to perform tasks such as these.", "tokens": [50644, 3097, 18161, 9590, 281, 2042, 9608, 1270, 382, 613, 13, 50857], "temperature": 0.0, "avg_logprob": -0.12886810302734375, "compression_ratio": 1.6680327868852458, "no_speech_prob": 0.12241849303245544}, {"id": 29, "seek": 13748, "start": 147.33999999999997, "end": 152.51999999999998, "text": " So so far in this course, we've been considering what we call supervised learning problems,", "tokens": [50857, 407, 370, 1400, 294, 341, 1164, 11, 321, 600, 668, 8079, 437, 321, 818, 46533, 2539, 2740, 11, 51116], "temperature": 0.0, "avg_logprob": -0.12886810302734375, "compression_ratio": 1.6680327868852458, "no_speech_prob": 0.12241849303245544}, {"id": 30, "seek": 13748, "start": 152.51999999999998, "end": 158.76, "text": " instances in which we are given a set of data and a set of labels associated with that data.", "tokens": [51116, 14519, 294, 597, 321, 366, 2212, 257, 992, 295, 1412, 293, 257, 992, 295, 16949, 6615, 365, 300, 1412, 13, 51428], "temperature": 0.0, "avg_logprob": -0.12886810302734375, "compression_ratio": 1.6680327868852458, "no_speech_prob": 0.12241849303245544}, {"id": 31, "seek": 13748, "start": 158.76, "end": 164.23999999999998, "text": " And our goal is to learn a functional mapping that moves from data to labels.", "tokens": [51428, 400, 527, 3387, 307, 281, 1466, 257, 11745, 18350, 300, 6067, 490, 1412, 281, 16949, 13, 51702], "temperature": 0.0, "avg_logprob": -0.12886810302734375, "compression_ratio": 1.6680327868852458, "no_speech_prob": 0.12241849303245544}, {"id": 32, "seek": 16424, "start": 164.24, "end": 167.72, "text": " And those labels can be class labels or continuous values.", "tokens": [50364, 400, 729, 16949, 393, 312, 1508, 16949, 420, 10957, 4190, 13, 50538], "temperature": 0.0, "avg_logprob": -0.11190780485519256, "compression_ratio": 1.6307692307692307, "no_speech_prob": 0.00057029421441257}, {"id": 33, "seek": 16424, "start": 167.72, "end": 173.12, "text": " And in this course, we've been concerned primarily with developing these functional", "tokens": [50538, 400, 294, 341, 1164, 11, 321, 600, 668, 5922, 10029, 365, 6416, 613, 11745, 50808], "temperature": 0.0, "avg_logprob": -0.11190780485519256, "compression_ratio": 1.6307692307692307, "no_speech_prob": 0.00057029421441257}, {"id": 34, "seek": 16424, "start": 173.12, "end": 177.20000000000002, "text": " mappings that can be described by deep neural networks.", "tokens": [50808, 463, 28968, 300, 393, 312, 7619, 538, 2452, 18161, 9590, 13, 51012], "temperature": 0.0, "avg_logprob": -0.11190780485519256, "compression_ratio": 1.6307692307692307, "no_speech_prob": 0.00057029421441257}, {"id": 35, "seek": 16424, "start": 177.20000000000002, "end": 183.88, "text": " But at their core, these mappings could be anything, you know, any sort of statistical function.", "tokens": [51012, 583, 412, 641, 4965, 11, 613, 463, 28968, 727, 312, 1340, 11, 291, 458, 11, 604, 1333, 295, 22820, 2445, 13, 51346], "temperature": 0.0, "avg_logprob": -0.11190780485519256, "compression_ratio": 1.6307692307692307, "no_speech_prob": 0.00057029421441257}, {"id": 36, "seek": 16424, "start": 183.88, "end": 189.12, "text": " The topic of today's lecture is going to focus on what we call unsupervised learning, which", "tokens": [51346, 440, 4829, 295, 965, 311, 7991, 307, 516, 281, 1879, 322, 437, 321, 818, 2693, 12879, 24420, 2539, 11, 597, 51608], "temperature": 0.0, "avg_logprob": -0.11190780485519256, "compression_ratio": 1.6307692307692307, "no_speech_prob": 0.00057029421441257}, {"id": 37, "seek": 16424, "start": 189.12, "end": 192.72, "text": " is a new class of learning problems.", "tokens": [51608, 307, 257, 777, 1508, 295, 2539, 2740, 13, 51788], "temperature": 0.0, "avg_logprob": -0.11190780485519256, "compression_ratio": 1.6307692307692307, "no_speech_prob": 0.00057029421441257}, {"id": 38, "seek": 19272, "start": 192.72, "end": 197.6, "text": " And in contrast to supervised settings where we're given data and labels in unsupervised", "tokens": [50364, 400, 294, 8712, 281, 46533, 6257, 689, 321, 434, 2212, 1412, 293, 16949, 294, 2693, 12879, 24420, 50608], "temperature": 0.0, "avg_logprob": -0.11239954220351353, "compression_ratio": 1.76, "no_speech_prob": 0.012429943308234215}, {"id": 39, "seek": 19272, "start": 197.6, "end": 200.8, "text": " learning, we're given only data, no labels.", "tokens": [50608, 2539, 11, 321, 434, 2212, 787, 1412, 11, 572, 16949, 13, 50768], "temperature": 0.0, "avg_logprob": -0.11239954220351353, "compression_ratio": 1.76, "no_speech_prob": 0.012429943308234215}, {"id": 40, "seek": 19272, "start": 200.8, "end": 205.4, "text": " And our goal is to train a machine learning or deep learning model to understand or build", "tokens": [50768, 400, 527, 3387, 307, 281, 3847, 257, 3479, 2539, 420, 2452, 2539, 2316, 281, 1223, 420, 1322, 50998], "temperature": 0.0, "avg_logprob": -0.11239954220351353, "compression_ratio": 1.76, "no_speech_prob": 0.012429943308234215}, {"id": 41, "seek": 19272, "start": 205.4, "end": 210.64, "text": " up a representation of the hidden and underlying structure in that data.", "tokens": [50998, 493, 257, 10290, 295, 264, 7633, 293, 14217, 3877, 294, 300, 1412, 13, 51260], "temperature": 0.0, "avg_logprob": -0.11239954220351353, "compression_ratio": 1.76, "no_speech_prob": 0.012429943308234215}, {"id": 42, "seek": 19272, "start": 210.64, "end": 216.76, "text": " And what this can do is it can allow sort of an insight into the foundational structure", "tokens": [51260, 400, 437, 341, 393, 360, 307, 309, 393, 2089, 1333, 295, 364, 11269, 666, 264, 32195, 3877, 51566], "temperature": 0.0, "avg_logprob": -0.11239954220351353, "compression_ratio": 1.76, "no_speech_prob": 0.012429943308234215}, {"id": 43, "seek": 19272, "start": 216.76, "end": 218.07999999999998, "text": " of the data.", "tokens": [51566, 295, 264, 1412, 13, 51632], "temperature": 0.0, "avg_logprob": -0.11239954220351353, "compression_ratio": 1.76, "no_speech_prob": 0.012429943308234215}, {"id": 44, "seek": 21808, "start": 218.08, "end": 224.96, "text": " And then in turn, we can use this understanding to actually generate synthetic examples.", "tokens": [50364, 400, 550, 294, 1261, 11, 321, 393, 764, 341, 3701, 281, 767, 8460, 23420, 5110, 13, 50708], "temperature": 0.0, "avg_logprob": -0.08103705034023378, "compression_ratio": 1.7410714285714286, "no_speech_prob": 0.0007793320692144334}, {"id": 45, "seek": 21808, "start": 224.96, "end": 230.72000000000003, "text": " And unsupervised learning beyond this domain of deep generative modeling also extends", "tokens": [50708, 400, 2693, 12879, 24420, 2539, 4399, 341, 9274, 295, 2452, 1337, 1166, 15983, 611, 26448, 50996], "temperature": 0.0, "avg_logprob": -0.08103705034023378, "compression_ratio": 1.7410714285714286, "no_speech_prob": 0.0007793320692144334}, {"id": 46, "seek": 21808, "start": 230.72000000000003, "end": 236.48000000000002, "text": " to other types of problems and example applications, which you may be familiar with, such as clustering", "tokens": [50996, 281, 661, 3467, 295, 2740, 293, 1365, 5821, 11, 597, 291, 815, 312, 4963, 365, 11, 1270, 382, 596, 48673, 51284], "temperature": 0.0, "avg_logprob": -0.08103705034023378, "compression_ratio": 1.7410714285714286, "no_speech_prob": 0.0007793320692144334}, {"id": 47, "seek": 21808, "start": 236.48000000000002, "end": 240.88000000000002, "text": " algorithms or dimensionality reduction algorithms.", "tokens": [51284, 14642, 420, 10139, 1860, 11004, 14642, 13, 51504], "temperature": 0.0, "avg_logprob": -0.08103705034023378, "compression_ratio": 1.7410714285714286, "no_speech_prob": 0.0007793320692144334}, {"id": 48, "seek": 21808, "start": 240.88000000000002, "end": 244.64000000000001, "text": " Generative modeling is one example of unsupervised learning.", "tokens": [51504, 15409, 1166, 15983, 307, 472, 1365, 295, 2693, 12879, 24420, 2539, 13, 51692], "temperature": 0.0, "avg_logprob": -0.08103705034023378, "compression_ratio": 1.7410714285714286, "no_speech_prob": 0.0007793320692144334}, {"id": 49, "seek": 24464, "start": 244.64, "end": 252.04, "text": " And our goal in this case is to take as input examples from a training set and learn a model", "tokens": [50364, 400, 527, 3387, 294, 341, 1389, 307, 281, 747, 382, 4846, 5110, 490, 257, 3097, 992, 293, 1466, 257, 2316, 50734], "temperature": 0.0, "avg_logprob": -0.09841362265653389, "compression_ratio": 1.6233183856502242, "no_speech_prob": 0.0014549664920195937}, {"id": 50, "seek": 24464, "start": 252.04, "end": 258.44, "text": " that represents the distribution of the data that is input to that model.", "tokens": [50734, 300, 8855, 264, 7316, 295, 264, 1412, 300, 307, 4846, 281, 300, 2316, 13, 51054], "temperature": 0.0, "avg_logprob": -0.09841362265653389, "compression_ratio": 1.6233183856502242, "no_speech_prob": 0.0014549664920195937}, {"id": 51, "seek": 24464, "start": 258.44, "end": 261.28, "text": " And this can be achieved in two principal ways.", "tokens": [51054, 400, 341, 393, 312, 11042, 294, 732, 9716, 2098, 13, 51196], "temperature": 0.0, "avg_logprob": -0.09841362265653389, "compression_ratio": 1.6233183856502242, "no_speech_prob": 0.0014549664920195937}, {"id": 52, "seek": 24464, "start": 261.28, "end": 265.59999999999997, "text": " The first is through what is called density estimation, where let's say we are given a", "tokens": [51196, 440, 700, 307, 807, 437, 307, 1219, 10305, 35701, 11, 689, 718, 311, 584, 321, 366, 2212, 257, 51412], "temperature": 0.0, "avg_logprob": -0.09841362265653389, "compression_ratio": 1.6233183856502242, "no_speech_prob": 0.0014549664920195937}, {"id": 53, "seek": 24464, "start": 265.59999999999997, "end": 271.08, "text": " set of data samples and they fall according to some density.", "tokens": [51412, 992, 295, 1412, 10938, 293, 436, 2100, 4650, 281, 512, 10305, 13, 51686], "temperature": 0.0, "avg_logprob": -0.09841362265653389, "compression_ratio": 1.6233183856502242, "no_speech_prob": 0.0014549664920195937}, {"id": 54, "seek": 27108, "start": 271.12, "end": 277.84, "text": " The task for building a deep generative model applied to these samples is to learn the underlying", "tokens": [50366, 440, 5633, 337, 2390, 257, 2452, 1337, 1166, 2316, 6456, 281, 613, 10938, 307, 281, 1466, 264, 14217, 50702], "temperature": 0.0, "avg_logprob": -0.11183799743652344, "compression_ratio": 1.7130044843049328, "no_speech_prob": 0.0015011351788416505}, {"id": 55, "seek": 27108, "start": 277.84, "end": 285.24, "text": " probability density function that describes how and where these data fall along this distribution.", "tokens": [50702, 8482, 10305, 2445, 300, 15626, 577, 293, 689, 613, 1412, 2100, 2051, 341, 7316, 13, 51072], "temperature": 0.0, "avg_logprob": -0.11183799743652344, "compression_ratio": 1.7130044843049328, "no_speech_prob": 0.0015011351788416505}, {"id": 56, "seek": 27108, "start": 285.24, "end": 291.47999999999996, "text": " And we can not only just estimate the density of such a probability density function, but", "tokens": [51072, 400, 321, 393, 406, 787, 445, 12539, 264, 10305, 295, 1270, 257, 8482, 10305, 2445, 11, 457, 51384], "temperature": 0.0, "avg_logprob": -0.11183799743652344, "compression_ratio": 1.7130044843049328, "no_speech_prob": 0.0015011351788416505}, {"id": 57, "seek": 27108, "start": 291.47999999999996, "end": 298.32, "text": " actually use this information to generate new synthetic samples, where again we are considering", "tokens": [51384, 767, 764, 341, 1589, 281, 8460, 777, 23420, 10938, 11, 689, 797, 321, 366, 8079, 51726], "temperature": 0.0, "avg_logprob": -0.11183799743652344, "compression_ratio": 1.7130044843049328, "no_speech_prob": 0.0015011351788416505}, {"id": 58, "seek": 29832, "start": 298.32, "end": 304.48, "text": " some input examples that fall and are drawn from some training data distribution.", "tokens": [50364, 512, 4846, 5110, 300, 2100, 293, 366, 10117, 490, 512, 3097, 1412, 7316, 13, 50672], "temperature": 0.0, "avg_logprob": -0.0794923718770345, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.0007096349145285785}, {"id": 59, "seek": 29832, "start": 304.48, "end": 311.48, "text": " And after building up a model using that data, our goal is now to generate synthetic examples", "tokens": [50672, 400, 934, 2390, 493, 257, 2316, 1228, 300, 1412, 11, 527, 3387, 307, 586, 281, 8460, 23420, 5110, 51022], "temperature": 0.0, "avg_logprob": -0.0794923718770345, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.0007096349145285785}, {"id": 60, "seek": 29832, "start": 311.48, "end": 318.92, "text": " that can be described as falling within the data distribution modeled by our model.", "tokens": [51022, 300, 393, 312, 7619, 382, 7440, 1951, 264, 1412, 7316, 37140, 538, 527, 2316, 13, 51394], "temperature": 0.0, "avg_logprob": -0.0794923718770345, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.0007096349145285785}, {"id": 61, "seek": 29832, "start": 318.92, "end": 327.84, "text": " So the key idea in both these instances is this question of how can we learn a probability", "tokens": [51394, 407, 264, 2141, 1558, 294, 1293, 613, 14519, 307, 341, 1168, 295, 577, 393, 321, 1466, 257, 8482, 51840], "temperature": 0.0, "avg_logprob": -0.0794923718770345, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.0007096349145285785}, {"id": 62, "seek": 32784, "start": 327.88, "end": 336.15999999999997, "text": " distribution using our model, which we call P model of X, that is so similar to the true", "tokens": [50366, 7316, 1228, 527, 2316, 11, 597, 321, 818, 430, 2316, 295, 1783, 11, 300, 307, 370, 2531, 281, 264, 2074, 50780], "temperature": 0.0, "avg_logprob": -0.12858028411865235, "compression_ratio": 1.6634146341463414, "no_speech_prob": 0.0015977693255990744}, {"id": 63, "seek": 32784, "start": 336.15999999999997, "end": 343.76, "text": " data distribution, which we call P data of X. This will not only enable us to effectively", "tokens": [50780, 1412, 7316, 11, 597, 321, 818, 430, 1412, 295, 1783, 13, 639, 486, 406, 787, 9528, 505, 281, 8659, 51160], "temperature": 0.0, "avg_logprob": -0.12858028411865235, "compression_ratio": 1.6634146341463414, "no_speech_prob": 0.0015977693255990744}, {"id": 64, "seek": 32784, "start": 343.76, "end": 349.44, "text": " estimate these probability density functions, but also generate new synthetic samples that", "tokens": [51160, 12539, 613, 8482, 10305, 6828, 11, 457, 611, 8460, 777, 23420, 10938, 300, 51444], "temperature": 0.0, "avg_logprob": -0.12858028411865235, "compression_ratio": 1.6634146341463414, "no_speech_prob": 0.0015977693255990744}, {"id": 65, "seek": 32784, "start": 349.44, "end": 356.0, "text": " are realistic and match the distribution of the data we're considering.", "tokens": [51444, 366, 12465, 293, 2995, 264, 7316, 295, 264, 1412, 321, 434, 8079, 13, 51772], "temperature": 0.0, "avg_logprob": -0.12858028411865235, "compression_ratio": 1.6634146341463414, "no_speech_prob": 0.0015977693255990744}, {"id": 66, "seek": 35600, "start": 356.0, "end": 364.08, "text": " So this I think summarizes concretely what are the key principles behind generative modeling.", "tokens": [50364, 407, 341, 286, 519, 14611, 5660, 39481, 736, 437, 366, 264, 2141, 9156, 2261, 1337, 1166, 15983, 13, 50768], "temperature": 0.0, "avg_logprob": -0.1389769245596493, "compression_ratio": 1.6597938144329898, "no_speech_prob": 0.00013134798791725188}, {"id": 67, "seek": 35600, "start": 364.08, "end": 370.84, "text": " But to understand that how generative modeling may be informative and also impactful, let's", "tokens": [50768, 583, 281, 1223, 300, 577, 1337, 1166, 15983, 815, 312, 27759, 293, 611, 30842, 11, 718, 311, 51106], "temperature": 0.0, "avg_logprob": -0.1389769245596493, "compression_ratio": 1.6597938144329898, "no_speech_prob": 0.00013134798791725188}, {"id": 68, "seek": 35600, "start": 370.84, "end": 377.2, "text": " take this idea step further and consider what could be potential impactful applications", "tokens": [51106, 747, 341, 1558, 1823, 3052, 293, 1949, 437, 727, 312, 3995, 30842, 5821, 51424], "temperature": 0.0, "avg_logprob": -0.1389769245596493, "compression_ratio": 1.6597938144329898, "no_speech_prob": 0.00013134798791725188}, {"id": 69, "seek": 35600, "start": 377.2, "end": 381.04, "text": " and real world use cases of generative modeling.", "tokens": [51424, 293, 957, 1002, 764, 3331, 295, 1337, 1166, 15983, 13, 51616], "temperature": 0.0, "avg_logprob": -0.1389769245596493, "compression_ratio": 1.6597938144329898, "no_speech_prob": 0.00013134798791725188}, {"id": 70, "seek": 38104, "start": 381.04, "end": 387.64000000000004, "text": " What generative models enable us as the users to do is to automatically uncover the underlying", "tokens": [50364, 708, 1337, 1166, 5245, 9528, 505, 382, 264, 5022, 281, 360, 307, 281, 6772, 21694, 264, 14217, 50694], "temperature": 0.0, "avg_logprob": -0.10998243573068202, "compression_ratio": 1.641025641025641, "no_speech_prob": 0.06006729602813721}, {"id": 71, "seek": 38104, "start": 387.64000000000004, "end": 390.48, "text": " structure and features in a data set.", "tokens": [50694, 3877, 293, 4122, 294, 257, 1412, 992, 13, 50836], "temperature": 0.0, "avg_logprob": -0.10998243573068202, "compression_ratio": 1.641025641025641, "no_speech_prob": 0.06006729602813721}, {"id": 72, "seek": 38104, "start": 390.48, "end": 395.68, "text": " The reason this can be really important and really powerful is often we do not know how", "tokens": [50836, 440, 1778, 341, 393, 312, 534, 1021, 293, 534, 4005, 307, 2049, 321, 360, 406, 458, 577, 51096], "temperature": 0.0, "avg_logprob": -0.10998243573068202, "compression_ratio": 1.641025641025641, "no_speech_prob": 0.06006729602813721}, {"id": 73, "seek": 38104, "start": 395.68, "end": 400.48, "text": " those features are distributed within a particular data set of interest.", "tokens": [51096, 729, 4122, 366, 12631, 1951, 257, 1729, 1412, 992, 295, 1179, 13, 51336], "temperature": 0.0, "avg_logprob": -0.10998243573068202, "compression_ratio": 1.641025641025641, "no_speech_prob": 0.06006729602813721}, {"id": 74, "seek": 38104, "start": 400.48, "end": 405.84000000000003, "text": " So let's say we're trying to build up a facial detection classifier and we're given a data", "tokens": [51336, 407, 718, 311, 584, 321, 434, 1382, 281, 1322, 493, 257, 15642, 17784, 1508, 9902, 293, 321, 434, 2212, 257, 1412, 51604], "temperature": 0.0, "avg_logprob": -0.10998243573068202, "compression_ratio": 1.641025641025641, "no_speech_prob": 0.06006729602813721}, {"id": 75, "seek": 40584, "start": 405.84, "end": 412.08, "text": " set of faces, for which we may not know the exact distribution of these faces with respect", "tokens": [50364, 992, 295, 8475, 11, 337, 597, 321, 815, 406, 458, 264, 1900, 7316, 295, 613, 8475, 365, 3104, 50676], "temperature": 0.0, "avg_logprob": -0.10671695274642751, "compression_ratio": 1.7277227722772277, "no_speech_prob": 0.027577394619584084}, {"id": 76, "seek": 40584, "start": 412.08, "end": 418.08, "text": " to key features like skin tone or pose or clothing items.", "tokens": [50676, 281, 2141, 4122, 411, 3178, 8027, 420, 10774, 420, 11502, 4754, 13, 50976], "temperature": 0.0, "avg_logprob": -0.10671695274642751, "compression_ratio": 1.7277227722772277, "no_speech_prob": 0.027577394619584084}, {"id": 77, "seek": 40584, "start": 418.08, "end": 425.67999999999995, "text": " And without going through our data set and manually inspecting each of these instances,", "tokens": [50976, 400, 1553, 516, 807, 527, 1412, 992, 293, 16945, 15018, 278, 1184, 295, 613, 14519, 11, 51356], "temperature": 0.0, "avg_logprob": -0.10671695274642751, "compression_ratio": 1.7277227722772277, "no_speech_prob": 0.027577394619584084}, {"id": 78, "seek": 40584, "start": 425.67999999999995, "end": 430.64, "text": " our training data may actually be very biased with respect to some of these features without", "tokens": [51356, 527, 3097, 1412, 815, 767, 312, 588, 28035, 365, 3104, 281, 512, 295, 613, 4122, 1553, 51604], "temperature": 0.0, "avg_logprob": -0.10671695274642751, "compression_ratio": 1.7277227722772277, "no_speech_prob": 0.027577394619584084}, {"id": 79, "seek": 40584, "start": 430.64, "end": 432.96, "text": " us even knowing it.", "tokens": [51604, 505, 754, 5276, 309, 13, 51720], "temperature": 0.0, "avg_logprob": -0.10671695274642751, "compression_ratio": 1.7277227722772277, "no_speech_prob": 0.027577394619584084}, {"id": 80, "seek": 43296, "start": 432.96, "end": 439.15999999999997, "text": " And as you'll see in this lecture and in today's lab, what we can actually do is train generative", "tokens": [50364, 400, 382, 291, 603, 536, 294, 341, 7991, 293, 294, 965, 311, 2715, 11, 437, 321, 393, 767, 360, 307, 3847, 1337, 1166, 50674], "temperature": 0.0, "avg_logprob": -0.12376216362262595, "compression_ratio": 1.711111111111111, "no_speech_prob": 0.0015486663905903697}, {"id": 81, "seek": 43296, "start": 439.15999999999997, "end": 445.88, "text": " models that can automatically learn the landscape of the features in a data set like these,", "tokens": [50674, 5245, 300, 393, 6772, 1466, 264, 9661, 295, 264, 4122, 294, 257, 1412, 992, 411, 613, 11, 51010], "temperature": 0.0, "avg_logprob": -0.12376216362262595, "compression_ratio": 1.711111111111111, "no_speech_prob": 0.0015486663905903697}, {"id": 82, "seek": 43296, "start": 445.88, "end": 447.59999999999997, "text": " like that of faces.", "tokens": [51010, 411, 300, 295, 8475, 13, 51096], "temperature": 0.0, "avg_logprob": -0.12376216362262595, "compression_ratio": 1.711111111111111, "no_speech_prob": 0.0015486663905903697}, {"id": 83, "seek": 43296, "start": 447.59999999999997, "end": 453.67999999999995, "text": " And by doing so, actually uncover the regions of the training distribution that are underrepresented", "tokens": [51096, 400, 538, 884, 370, 11, 767, 21694, 264, 10682, 295, 264, 3097, 7316, 300, 366, 833, 38293, 51400], "temperature": 0.0, "avg_logprob": -0.12376216362262595, "compression_ratio": 1.711111111111111, "no_speech_prob": 0.0015486663905903697}, {"id": 84, "seek": 43296, "start": 453.67999999999995, "end": 459.4, "text": " and overrepresented with respect to particular features such as skin tone.", "tokens": [51400, 293, 670, 38293, 365, 3104, 281, 1729, 4122, 1270, 382, 3178, 8027, 13, 51686], "temperature": 0.0, "avg_logprob": -0.12376216362262595, "compression_ratio": 1.711111111111111, "no_speech_prob": 0.0015486663905903697}, {"id": 85, "seek": 45940, "start": 459.4, "end": 465.64, "text": " And the reason why this is so powerful is we can actually now use this information to", "tokens": [50364, 400, 264, 1778, 983, 341, 307, 370, 4005, 307, 321, 393, 767, 586, 764, 341, 1589, 281, 50676], "temperature": 0.0, "avg_logprob": -0.10916876505656414, "compression_ratio": 1.6775700934579438, "no_speech_prob": 0.0013249646872282028}, {"id": 86, "seek": 45940, "start": 465.64, "end": 472.28, "text": " actually adjust how the data is sampled during training to ultimately build up a more fair", "tokens": [50676, 767, 4369, 577, 264, 1412, 307, 3247, 15551, 1830, 3097, 281, 6284, 1322, 493, 257, 544, 3143, 51008], "temperature": 0.0, "avg_logprob": -0.10916876505656414, "compression_ratio": 1.6775700934579438, "no_speech_prob": 0.0013249646872282028}, {"id": 87, "seek": 45940, "start": 472.28, "end": 479.0, "text": " and more representative data set that then will lead to a more fair and unbiased model.", "tokens": [51008, 293, 544, 12424, 1412, 992, 300, 550, 486, 1477, 281, 257, 544, 3143, 293, 517, 5614, 1937, 2316, 13, 51344], "temperature": 0.0, "avg_logprob": -0.10916876505656414, "compression_ratio": 1.6775700934579438, "no_speech_prob": 0.0013249646872282028}, {"id": 88, "seek": 45940, "start": 479.0, "end": 483.59999999999997, "text": " And you'll get practice doing exactly this and implementing this idea in today's lab", "tokens": [51344, 400, 291, 603, 483, 3124, 884, 2293, 341, 293, 18114, 341, 1558, 294, 965, 311, 2715, 51574], "temperature": 0.0, "avg_logprob": -0.10916876505656414, "compression_ratio": 1.6775700934579438, "no_speech_prob": 0.0013249646872282028}, {"id": 89, "seek": 45940, "start": 483.59999999999997, "end": 486.12, "text": " exercise.", "tokens": [51574, 5380, 13, 51700], "temperature": 0.0, "avg_logprob": -0.10916876505656414, "compression_ratio": 1.6775700934579438, "no_speech_prob": 0.0013249646872282028}, {"id": 90, "seek": 48612, "start": 486.12, "end": 491.56, "text": " Another great example in use case where generative models are exceptionally powerful is this", "tokens": [50364, 3996, 869, 1365, 294, 764, 1389, 689, 1337, 1166, 5245, 366, 37807, 4005, 307, 341, 50636], "temperature": 0.0, "avg_logprob": -0.10027575979427415, "compression_ratio": 1.6346863468634687, "no_speech_prob": 0.14793607592582703}, {"id": 91, "seek": 48612, "start": 491.56, "end": 496.48, "text": " broad class of problems that can be considered outlier or anomaly detection.", "tokens": [50636, 4152, 1508, 295, 2740, 300, 393, 312, 4888, 484, 2753, 420, 42737, 17784, 13, 50882], "temperature": 0.0, "avg_logprob": -0.10027575979427415, "compression_ratio": 1.6346863468634687, "no_speech_prob": 0.14793607592582703}, {"id": 92, "seek": 48612, "start": 496.48, "end": 501.28000000000003, "text": " One example is in the case of self-driving cars where it's going to be really critical", "tokens": [50882, 1485, 1365, 307, 294, 264, 1389, 295, 2698, 12, 47094, 5163, 689, 309, 311, 516, 281, 312, 534, 4924, 51122], "temperature": 0.0, "avg_logprob": -0.10027575979427415, "compression_ratio": 1.6346863468634687, "no_speech_prob": 0.14793607592582703}, {"id": 93, "seek": 48612, "start": 501.28000000000003, "end": 507.4, "text": " to ensure that an autonomous vehicle governed and operated by a deep neural network is able", "tokens": [51122, 281, 5586, 300, 364, 23797, 5864, 35529, 293, 20826, 538, 257, 2452, 18161, 3209, 307, 1075, 51428], "temperature": 0.0, "avg_logprob": -0.10027575979427415, "compression_ratio": 1.6346863468634687, "no_speech_prob": 0.14793607592582703}, {"id": 94, "seek": 48612, "start": 507.4, "end": 513.24, "text": " to handle all of the cases that it may encounter on the road, not just, you know, the straight", "tokens": [51428, 281, 4813, 439, 295, 264, 3331, 300, 309, 815, 8593, 322, 264, 3060, 11, 406, 445, 11, 291, 458, 11, 264, 2997, 51720], "temperature": 0.0, "avg_logprob": -0.10027575979427415, "compression_ratio": 1.6346863468634687, "no_speech_prob": 0.14793607592582703}, {"id": 95, "seek": 51324, "start": 513.24, "end": 517.8, "text": " freeway driving that is going to be the majority of the training data and the majority of the", "tokens": [50364, 1737, 676, 4840, 300, 307, 516, 281, 312, 264, 6286, 295, 264, 3097, 1412, 293, 264, 6286, 295, 264, 50592], "temperature": 0.0, "avg_logprob": -0.13007275420840425, "compression_ratio": 1.8326693227091633, "no_speech_prob": 0.032095812261104584}, {"id": 96, "seek": 51324, "start": 517.8, "end": 520.88, "text": " time the car experiences on the road.", "tokens": [50592, 565, 264, 1032, 5235, 322, 264, 3060, 13, 50746], "temperature": 0.0, "avg_logprob": -0.13007275420840425, "compression_ratio": 1.8326693227091633, "no_speech_prob": 0.032095812261104584}, {"id": 97, "seek": 51324, "start": 520.88, "end": 526.24, "text": " So generative models can actually be used to detect outliers within training distributions", "tokens": [50746, 407, 1337, 1166, 5245, 393, 767, 312, 1143, 281, 5531, 484, 23646, 1951, 3097, 37870, 51014], "temperature": 0.0, "avg_logprob": -0.13007275420840425, "compression_ratio": 1.8326693227091633, "no_speech_prob": 0.032095812261104584}, {"id": 98, "seek": 51324, "start": 526.24, "end": 531.88, "text": " and use this to, again, improve the training process so that the resulting model can be", "tokens": [51014, 293, 764, 341, 281, 11, 797, 11, 3470, 264, 3097, 1399, 370, 300, 264, 16505, 2316, 393, 312, 51296], "temperature": 0.0, "avg_logprob": -0.13007275420840425, "compression_ratio": 1.8326693227091633, "no_speech_prob": 0.032095812261104584}, {"id": 99, "seek": 51324, "start": 531.88, "end": 536.48, "text": " better equipped to handle these edge cases and rare events.", "tokens": [51296, 1101, 15218, 281, 4813, 613, 4691, 3331, 293, 5892, 3931, 13, 51526], "temperature": 0.0, "avg_logprob": -0.13007275420840425, "compression_ratio": 1.8326693227091633, "no_speech_prob": 0.032095812261104584}, {"id": 100, "seek": 51324, "start": 536.48, "end": 542.28, "text": " All right, so hopefully that motivates why and how generative models can be exceptionally", "tokens": [51526, 1057, 558, 11, 370, 4696, 300, 42569, 983, 293, 577, 1337, 1166, 5245, 393, 312, 37807, 51816], "temperature": 0.0, "avg_logprob": -0.13007275420840425, "compression_ratio": 1.8326693227091633, "no_speech_prob": 0.032095812261104584}, {"id": 101, "seek": 54228, "start": 542.28, "end": 546.68, "text": " powerful and useful for a variety of real world applications.", "tokens": [50364, 4005, 293, 4420, 337, 257, 5673, 295, 957, 1002, 5821, 13, 50584], "temperature": 0.0, "avg_logprob": -0.11813630228457243, "compression_ratio": 1.5673469387755101, "no_speech_prob": 0.009706482291221619}, {"id": 102, "seek": 54228, "start": 546.68, "end": 551.52, "text": " To dive into the bulk of the technical content for today's lecture, we're going to discuss", "tokens": [50584, 1407, 9192, 666, 264, 16139, 295, 264, 6191, 2701, 337, 965, 311, 7991, 11, 321, 434, 516, 281, 2248, 50826], "temperature": 0.0, "avg_logprob": -0.11813630228457243, "compression_ratio": 1.5673469387755101, "no_speech_prob": 0.009706482291221619}, {"id": 103, "seek": 54228, "start": 551.52, "end": 554.9599999999999, "text": " two classes of what we call latent variable models.", "tokens": [50826, 732, 5359, 295, 437, 321, 818, 48994, 7006, 5245, 13, 50998], "temperature": 0.0, "avg_logprob": -0.11813630228457243, "compression_ratio": 1.5673469387755101, "no_speech_prob": 0.009706482291221619}, {"id": 104, "seek": 54228, "start": 554.9599999999999, "end": 560.12, "text": " Specifically we'll look at autoencoders and generative adversarial networks or GANs.", "tokens": [50998, 26058, 321, 603, 574, 412, 8399, 22660, 378, 433, 293, 1337, 1166, 17641, 44745, 9590, 420, 460, 1770, 82, 13, 51256], "temperature": 0.0, "avg_logprob": -0.11813630228457243, "compression_ratio": 1.5673469387755101, "no_speech_prob": 0.009706482291221619}, {"id": 105, "seek": 54228, "start": 560.12, "end": 565.56, "text": " But before we get into that, I'd like to first begin by discussing why these are called latent", "tokens": [51256, 583, 949, 321, 483, 666, 300, 11, 286, 1116, 411, 281, 700, 1841, 538, 10850, 983, 613, 366, 1219, 48994, 51528], "temperature": 0.0, "avg_logprob": -0.11813630228457243, "compression_ratio": 1.5673469387755101, "no_speech_prob": 0.009706482291221619}, {"id": 106, "seek": 56556, "start": 565.56, "end": 572.4399999999999, "text": " variable models and what we actually mean when we use this word latent.", "tokens": [50364, 7006, 5245, 293, 437, 321, 767, 914, 562, 321, 764, 341, 1349, 48994, 13, 50708], "temperature": 0.0, "avg_logprob": -0.15231137805514866, "compression_ratio": 1.7609561752988048, "no_speech_prob": 0.16877184808254242}, {"id": 107, "seek": 56556, "start": 572.4399999999999, "end": 577.0799999999999, "text": " And to do so, I think really the best example that I've personally come across for understanding", "tokens": [50708, 400, 281, 360, 370, 11, 286, 519, 534, 264, 1151, 1365, 300, 286, 600, 5665, 808, 2108, 337, 3701, 50940], "temperature": 0.0, "avg_logprob": -0.15231137805514866, "compression_ratio": 1.7609561752988048, "no_speech_prob": 0.16877184808254242}, {"id": 108, "seek": 56556, "start": 577.0799999999999, "end": 583.0, "text": " what a latent variable is, is this story that is from Plato's work, the Republic.", "tokens": [50940, 437, 257, 48994, 7006, 307, 11, 307, 341, 1657, 300, 307, 490, 43027, 311, 589, 11, 264, 5564, 13, 51236], "temperature": 0.0, "avg_logprob": -0.15231137805514866, "compression_ratio": 1.7609561752988048, "no_speech_prob": 0.16877184808254242}, {"id": 109, "seek": 56556, "start": 583.0, "end": 586.28, "text": " And this story is called the myth of the cave or the parable of the cave.", "tokens": [51236, 400, 341, 1657, 307, 1219, 264, 9474, 295, 264, 11730, 420, 264, 971, 712, 295, 264, 11730, 13, 51400], "temperature": 0.0, "avg_logprob": -0.15231137805514866, "compression_ratio": 1.7609561752988048, "no_speech_prob": 0.16877184808254242}, {"id": 110, "seek": 56556, "start": 586.28, "end": 588.54, "text": " And the story is as follows.", "tokens": [51400, 400, 264, 1657, 307, 382, 10002, 13, 51513], "temperature": 0.0, "avg_logprob": -0.15231137805514866, "compression_ratio": 1.7609561752988048, "no_speech_prob": 0.16877184808254242}, {"id": 111, "seek": 56556, "start": 588.54, "end": 594.0799999999999, "text": " In this myth, there are a group of prisoners and these prisoners are constrained as part", "tokens": [51513, 682, 341, 9474, 11, 456, 366, 257, 1594, 295, 20417, 293, 613, 20417, 366, 38901, 382, 644, 51790], "temperature": 0.0, "avg_logprob": -0.15231137805514866, "compression_ratio": 1.7609561752988048, "no_speech_prob": 0.16877184808254242}, {"id": 112, "seek": 59408, "start": 594.08, "end": 597.2, "text": " of their prison punishment to face a wall.", "tokens": [50364, 295, 641, 6168, 14133, 281, 1851, 257, 2929, 13, 50520], "temperature": 0.0, "avg_logprob": -0.09232688719226469, "compression_ratio": 2.0084388185654007, "no_speech_prob": 0.008060538209974766}, {"id": 113, "seek": 59408, "start": 597.2, "end": 602.72, "text": " And the only things that they can see on this wall are the shadows of particular objects", "tokens": [50520, 400, 264, 787, 721, 300, 436, 393, 536, 322, 341, 2929, 366, 264, 14740, 295, 1729, 6565, 50796], "temperature": 0.0, "avg_logprob": -0.09232688719226469, "compression_ratio": 2.0084388185654007, "no_speech_prob": 0.008060538209974766}, {"id": 114, "seek": 59408, "start": 602.72, "end": 606.0, "text": " that are being passed in front of a fire that's behind them.", "tokens": [50796, 300, 366, 885, 4678, 294, 1868, 295, 257, 2610, 300, 311, 2261, 552, 13, 50960], "temperature": 0.0, "avg_logprob": -0.09232688719226469, "compression_ratio": 2.0084388185654007, "no_speech_prob": 0.008060538209974766}, {"id": 115, "seek": 59408, "start": 606.0, "end": 610.2, "text": " So behind their heads and out of their line of sight.", "tokens": [50960, 407, 2261, 641, 8050, 293, 484, 295, 641, 1622, 295, 7860, 13, 51170], "temperature": 0.0, "avg_logprob": -0.09232688719226469, "compression_ratio": 2.0084388185654007, "no_speech_prob": 0.008060538209974766}, {"id": 116, "seek": 59408, "start": 610.2, "end": 613.5200000000001, "text": " And the prisoners, the only thing they're really observing are these shadows on the", "tokens": [51170, 400, 264, 20417, 11, 264, 787, 551, 436, 434, 534, 22107, 366, 613, 14740, 322, 264, 51336], "temperature": 0.0, "avg_logprob": -0.09232688719226469, "compression_ratio": 2.0084388185654007, "no_speech_prob": 0.008060538209974766}, {"id": 117, "seek": 59408, "start": 613.5200000000001, "end": 614.5200000000001, "text": " wall.", "tokens": [51336, 2929, 13, 51386], "temperature": 0.0, "avg_logprob": -0.09232688719226469, "compression_ratio": 2.0084388185654007, "no_speech_prob": 0.008060538209974766}, {"id": 118, "seek": 59408, "start": 614.5200000000001, "end": 616.8000000000001, "text": " And so to them, that's what they can see.", "tokens": [51386, 400, 370, 281, 552, 11, 300, 311, 437, 436, 393, 536, 13, 51500], "temperature": 0.0, "avg_logprob": -0.09232688719226469, "compression_ratio": 2.0084388185654007, "no_speech_prob": 0.008060538209974766}, {"id": 119, "seek": 59408, "start": 616.8000000000001, "end": 619.6800000000001, "text": " That's what they can measure and that's what they can give names to.", "tokens": [51500, 663, 311, 437, 436, 393, 3481, 293, 300, 311, 437, 436, 393, 976, 5288, 281, 13, 51644], "temperature": 0.0, "avg_logprob": -0.09232688719226469, "compression_ratio": 2.0084388185654007, "no_speech_prob": 0.008060538209974766}, {"id": 120, "seek": 59408, "start": 619.6800000000001, "end": 621.32, "text": " That's really their reality.", "tokens": [51644, 663, 311, 534, 641, 4103, 13, 51726], "temperature": 0.0, "avg_logprob": -0.09232688719226469, "compression_ratio": 2.0084388185654007, "no_speech_prob": 0.008060538209974766}, {"id": 121, "seek": 62132, "start": 621.32, "end": 624.2, "text": " These are their observed variables.", "tokens": [50364, 1981, 366, 641, 13095, 9102, 13, 50508], "temperature": 0.0, "avg_logprob": -0.13559747016292878, "compression_ratio": 1.8681818181818182, "no_speech_prob": 0.003706923918798566}, {"id": 122, "seek": 62132, "start": 624.2, "end": 629.88, "text": " But they can't actually directly observe or measure the physical objects themselves", "tokens": [50508, 583, 436, 393, 380, 767, 3838, 11441, 420, 3481, 264, 4001, 6565, 2969, 50792], "temperature": 0.0, "avg_logprob": -0.13559747016292878, "compression_ratio": 1.8681818181818182, "no_speech_prob": 0.003706923918798566}, {"id": 123, "seek": 62132, "start": 629.88, "end": 632.2800000000001, "text": " that are actually casting these shadows.", "tokens": [50792, 300, 366, 767, 17301, 613, 14740, 13, 50912], "temperature": 0.0, "avg_logprob": -0.13559747016292878, "compression_ratio": 1.8681818181818182, "no_speech_prob": 0.003706923918798566}, {"id": 124, "seek": 62132, "start": 632.2800000000001, "end": 638.6400000000001, "text": " So those objects are effectively what we can analyze like latent variables.", "tokens": [50912, 407, 729, 6565, 366, 8659, 437, 321, 393, 12477, 411, 48994, 9102, 13, 51230], "temperature": 0.0, "avg_logprob": -0.13559747016292878, "compression_ratio": 1.8681818181818182, "no_speech_prob": 0.003706923918798566}, {"id": 125, "seek": 62132, "start": 638.6400000000001, "end": 643.5600000000001, "text": " They're the variables that are not directly observable, but they're the true explanatory", "tokens": [51230, 814, 434, 264, 9102, 300, 366, 406, 3838, 9951, 712, 11, 457, 436, 434, 264, 2074, 9045, 4745, 51476], "temperature": 0.0, "avg_logprob": -0.13559747016292878, "compression_ratio": 1.8681818181818182, "no_speech_prob": 0.003706923918798566}, {"id": 126, "seek": 62132, "start": 643.5600000000001, "end": 648.24, "text": " factors that are creating the observable variables, which in this case, the prisoners", "tokens": [51476, 6771, 300, 366, 4084, 264, 9951, 712, 9102, 11, 597, 294, 341, 1389, 11, 264, 20417, 51710], "temperature": 0.0, "avg_logprob": -0.13559747016292878, "compression_ratio": 1.8681818181818182, "no_speech_prob": 0.003706923918798566}, {"id": 127, "seek": 64824, "start": 648.24, "end": 652.6800000000001, "text": " are seeing, like the shadows cast on the wall.", "tokens": [50364, 366, 2577, 11, 411, 264, 14740, 4193, 322, 264, 2929, 13, 50586], "temperature": 0.0, "avg_logprob": -0.13253555050143948, "compression_ratio": 1.5740740740740742, "no_speech_prob": 0.0026314915157854557}, {"id": 128, "seek": 64824, "start": 652.6800000000001, "end": 659.44, "text": " And so our question in generative modeling broadly is to find ways of actually learning", "tokens": [50586, 400, 370, 527, 1168, 294, 1337, 1166, 15983, 19511, 307, 281, 915, 2098, 295, 767, 2539, 50924], "temperature": 0.0, "avg_logprob": -0.13253555050143948, "compression_ratio": 1.5740740740740742, "no_speech_prob": 0.0026314915157854557}, {"id": 129, "seek": 64824, "start": 659.44, "end": 665.32, "text": " these underlying and hidden latent variables in the data, even when we're only given the", "tokens": [50924, 613, 14217, 293, 7633, 48994, 9102, 294, 264, 1412, 11, 754, 562, 321, 434, 787, 2212, 264, 51218], "temperature": 0.0, "avg_logprob": -0.13253555050143948, "compression_ratio": 1.5740740740740742, "no_speech_prob": 0.0026314915157854557}, {"id": 130, "seek": 64824, "start": 665.32, "end": 667.6800000000001, "text": " observations that are made.", "tokens": [51218, 18163, 300, 366, 1027, 13, 51336], "temperature": 0.0, "avg_logprob": -0.13253555050143948, "compression_ratio": 1.5740740740740742, "no_speech_prob": 0.0026314915157854557}, {"id": 131, "seek": 64824, "start": 667.6800000000001, "end": 674.72, "text": " And this is an extremely, extremely complex problem that is very well suited to learning", "tokens": [51336, 400, 341, 307, 364, 4664, 11, 4664, 3997, 1154, 300, 307, 588, 731, 24736, 281, 2539, 51688], "temperature": 0.0, "avg_logprob": -0.13253555050143948, "compression_ratio": 1.5740740740740742, "no_speech_prob": 0.0026314915157854557}, {"id": 132, "seek": 67472, "start": 674.72, "end": 680.8000000000001, "text": " by neural networks because of their power to handle multidimensional data sets and to", "tokens": [50364, 538, 18161, 9590, 570, 295, 641, 1347, 281, 4813, 2120, 327, 332, 11075, 1412, 6352, 293, 281, 50668], "temperature": 0.0, "avg_logprob": -0.14782879087660047, "compression_ratio": 1.606177606177606, "no_speech_prob": 0.13288819789886475}, {"id": 133, "seek": 67472, "start": 680.8000000000001, "end": 686.84, "text": " learn combinations of nonlinear functions that can approximate really complex data distributions.", "tokens": [50668, 1466, 21267, 295, 2107, 28263, 6828, 300, 393, 30874, 534, 3997, 1412, 37870, 13, 50970], "temperature": 0.0, "avg_logprob": -0.14782879087660047, "compression_ratio": 1.606177606177606, "no_speech_prob": 0.13288819789886475}, {"id": 134, "seek": 67472, "start": 686.84, "end": 688.48, "text": " All right.", "tokens": [50970, 1057, 558, 13, 51052], "temperature": 0.0, "avg_logprob": -0.14782879087660047, "compression_ratio": 1.606177606177606, "no_speech_prob": 0.13288819789886475}, {"id": 135, "seek": 67472, "start": 688.48, "end": 694.0400000000001, "text": " So we'll first begin by discussing a simple and foundational generative model, which tries", "tokens": [51052, 407, 321, 603, 700, 1841, 538, 10850, 257, 2199, 293, 32195, 1337, 1166, 2316, 11, 597, 9898, 51330], "temperature": 0.0, "avg_logprob": -0.14782879087660047, "compression_ratio": 1.606177606177606, "no_speech_prob": 0.13288819789886475}, {"id": 136, "seek": 67472, "start": 694.0400000000001, "end": 700.2, "text": " to build up these latent variable representation by actually self encoding the input.", "tokens": [51330, 281, 1322, 493, 613, 48994, 7006, 10290, 538, 767, 2698, 43430, 264, 4846, 13, 51638], "temperature": 0.0, "avg_logprob": -0.14782879087660047, "compression_ratio": 1.606177606177606, "no_speech_prob": 0.13288819789886475}, {"id": 137, "seek": 67472, "start": 700.2, "end": 703.6800000000001, "text": " And these models are known as auto encoders.", "tokens": [51638, 400, 613, 5245, 366, 2570, 382, 8399, 2058, 378, 433, 13, 51812], "temperature": 0.0, "avg_logprob": -0.14782879087660047, "compression_ratio": 1.606177606177606, "no_speech_prob": 0.13288819789886475}, {"id": 138, "seek": 70368, "start": 703.68, "end": 710.28, "text": " What an auto encoder is, is it's an approach for learning a lower dimensional latent space", "tokens": [50364, 708, 364, 8399, 2058, 19866, 307, 11, 307, 309, 311, 364, 3109, 337, 2539, 257, 3126, 18795, 48994, 1901, 50694], "temperature": 0.0, "avg_logprob": -0.14632004499435425, "compression_ratio": 1.6710526315789473, "no_speech_prob": 0.004069571383297443}, {"id": 139, "seek": 70368, "start": 710.28, "end": 712.76, "text": " from raw data.", "tokens": [50694, 490, 8936, 1412, 13, 50818], "temperature": 0.0, "avg_logprob": -0.14632004499435425, "compression_ratio": 1.6710526315789473, "no_speech_prob": 0.004069571383297443}, {"id": 140, "seek": 70368, "start": 712.76, "end": 718.8, "text": " To understand how it works, what we do is we feed in as input raw data, for example,", "tokens": [50818, 1407, 1223, 577, 309, 1985, 11, 437, 321, 360, 307, 321, 3154, 294, 382, 4846, 8936, 1412, 11, 337, 1365, 11, 51120], "temperature": 0.0, "avg_logprob": -0.14632004499435425, "compression_ratio": 1.6710526315789473, "no_speech_prob": 0.004069571383297443}, {"id": 141, "seek": 70368, "start": 718.8, "end": 723.12, "text": " this image of a two, that's going to be passed through many successive deep neural network", "tokens": [51120, 341, 3256, 295, 257, 732, 11, 300, 311, 516, 281, 312, 4678, 807, 867, 48043, 2452, 18161, 3209, 51336], "temperature": 0.0, "avg_logprob": -0.14632004499435425, "compression_ratio": 1.6710526315789473, "no_speech_prob": 0.004069571383297443}, {"id": 142, "seek": 70368, "start": 723.12, "end": 724.28, "text": " layers.", "tokens": [51336, 7914, 13, 51394], "temperature": 0.0, "avg_logprob": -0.14632004499435425, "compression_ratio": 1.6710526315789473, "no_speech_prob": 0.004069571383297443}, {"id": 143, "seek": 70368, "start": 724.28, "end": 729.3199999999999, "text": " And at the output of that succession of neural network layers, what we're going to generate", "tokens": [51394, 400, 412, 264, 5598, 295, 300, 36624, 295, 18161, 3209, 7914, 11, 437, 321, 434, 516, 281, 8460, 51646], "temperature": 0.0, "avg_logprob": -0.14632004499435425, "compression_ratio": 1.6710526315789473, "no_speech_prob": 0.004069571383297443}, {"id": 144, "seek": 72932, "start": 729.32, "end": 733.7600000000001, "text": " is a low dimensional latent space, a feature representation.", "tokens": [50364, 307, 257, 2295, 18795, 48994, 1901, 11, 257, 4111, 10290, 13, 50586], "temperature": 0.0, "avg_logprob": -0.14945070814378192, "compression_ratio": 1.6652173913043478, "no_speech_prob": 0.023683825507760048}, {"id": 145, "seek": 72932, "start": 733.7600000000001, "end": 737.24, "text": " And that's really the goal that we're trying to predict.", "tokens": [50586, 400, 300, 311, 534, 264, 3387, 300, 321, 434, 1382, 281, 6069, 13, 50760], "temperature": 0.0, "avg_logprob": -0.14945070814378192, "compression_ratio": 1.6652173913043478, "no_speech_prob": 0.023683825507760048}, {"id": 146, "seek": 72932, "start": 737.24, "end": 742.08, "text": " And so we can call this portion of the network an encoder, since it's mapping the data,", "tokens": [50760, 400, 370, 321, 393, 818, 341, 8044, 295, 264, 3209, 364, 2058, 19866, 11, 1670, 309, 311, 18350, 264, 1412, 11, 51002], "temperature": 0.0, "avg_logprob": -0.14945070814378192, "compression_ratio": 1.6652173913043478, "no_speech_prob": 0.023683825507760048}, {"id": 147, "seek": 72932, "start": 742.08, "end": 747.96, "text": " x, into a encoded vector of latent variables, z.", "tokens": [51002, 2031, 11, 666, 257, 2058, 12340, 8062, 295, 48994, 9102, 11, 710, 13, 51296], "temperature": 0.0, "avg_logprob": -0.14945070814378192, "compression_ratio": 1.6652173913043478, "no_speech_prob": 0.023683825507760048}, {"id": 148, "seek": 72932, "start": 747.96, "end": 752.2, "text": " So let's consider this latent space, z.", "tokens": [51296, 407, 718, 311, 1949, 341, 48994, 1901, 11, 710, 13, 51508], "temperature": 0.0, "avg_logprob": -0.14945070814378192, "compression_ratio": 1.6652173913043478, "no_speech_prob": 0.023683825507760048}, {"id": 149, "seek": 72932, "start": 752.2, "end": 757.44, "text": " If you've noticed, I've represented z as having a smaller size, a smaller dimensionality", "tokens": [51508, 759, 291, 600, 5694, 11, 286, 600, 10379, 710, 382, 1419, 257, 4356, 2744, 11, 257, 4356, 10139, 1860, 51770], "temperature": 0.0, "avg_logprob": -0.14945070814378192, "compression_ratio": 1.6652173913043478, "no_speech_prob": 0.023683825507760048}, {"id": 150, "seek": 75744, "start": 757.44, "end": 763.84, "text": " as the input x, why would it be important to ensure the low dimensionality of this latent", "tokens": [50364, 382, 264, 4846, 2031, 11, 983, 576, 309, 312, 1021, 281, 5586, 264, 2295, 10139, 1860, 295, 341, 48994, 50684], "temperature": 0.0, "avg_logprob": -0.1152089500427246, "compression_ratio": 1.812785388127854, "no_speech_prob": 0.00030533908284269273}, {"id": 151, "seek": 75744, "start": 763.84, "end": 767.12, "text": " space, z?", "tokens": [50684, 1901, 11, 710, 30, 50848], "temperature": 0.0, "avg_logprob": -0.1152089500427246, "compression_ratio": 1.812785388127854, "no_speech_prob": 0.00030533908284269273}, {"id": 152, "seek": 75744, "start": 767.12, "end": 771.8800000000001, "text": " Having a low dimensional latent space means that we are able to compress the data, which", "tokens": [50848, 10222, 257, 2295, 18795, 48994, 1901, 1355, 300, 321, 366, 1075, 281, 14778, 264, 1412, 11, 597, 51086], "temperature": 0.0, "avg_logprob": -0.1152089500427246, "compression_ratio": 1.812785388127854, "no_speech_prob": 0.00030533908284269273}, {"id": 153, "seek": 75744, "start": 771.8800000000001, "end": 777.12, "text": " in the case of image data can be, you know, on the order of many, many, many dimensions,", "tokens": [51086, 294, 264, 1389, 295, 3256, 1412, 393, 312, 11, 291, 458, 11, 322, 264, 1668, 295, 867, 11, 867, 11, 867, 12819, 11, 51348], "temperature": 0.0, "avg_logprob": -0.1152089500427246, "compression_ratio": 1.812785388127854, "no_speech_prob": 0.00030533908284269273}, {"id": 154, "seek": 75744, "start": 777.12, "end": 783.1600000000001, "text": " we can compress the data into a small latent vector, where we can learn a very compact and", "tokens": [51348, 321, 393, 14778, 264, 1412, 666, 257, 1359, 48994, 8062, 11, 689, 321, 393, 1466, 257, 588, 14679, 293, 51650], "temperature": 0.0, "avg_logprob": -0.1152089500427246, "compression_ratio": 1.812785388127854, "no_speech_prob": 0.00030533908284269273}, {"id": 155, "seek": 75744, "start": 783.1600000000001, "end": 786.6, "text": " rich feature representation.", "tokens": [51650, 4593, 4111, 10290, 13, 51822], "temperature": 0.0, "avg_logprob": -0.1152089500427246, "compression_ratio": 1.812785388127854, "no_speech_prob": 0.00030533908284269273}, {"id": 156, "seek": 78660, "start": 786.6, "end": 789.64, "text": " So how can we actually train this model?", "tokens": [50364, 407, 577, 393, 321, 767, 3847, 341, 2316, 30, 50516], "temperature": 0.0, "avg_logprob": -0.12367806067833534, "compression_ratio": 1.6168224299065421, "no_speech_prob": 0.00648735836148262}, {"id": 157, "seek": 78660, "start": 789.64, "end": 794.96, "text": " Are we going to be able to supervise for the particular latent variables that we're interested", "tokens": [50516, 2014, 321, 516, 281, 312, 1075, 281, 37971, 908, 337, 264, 1729, 48994, 9102, 300, 321, 434, 3102, 50782], "temperature": 0.0, "avg_logprob": -0.12367806067833534, "compression_ratio": 1.6168224299065421, "no_speech_prob": 0.00648735836148262}, {"id": 158, "seek": 78660, "start": 794.96, "end": 795.96, "text": " in?", "tokens": [50782, 294, 30, 50832], "temperature": 0.0, "avg_logprob": -0.12367806067833534, "compression_ratio": 1.6168224299065421, "no_speech_prob": 0.00648735836148262}, {"id": 159, "seek": 78660, "start": 795.96, "end": 801.96, "text": " Well, remember that this is an unsupervised problem, where we have training data, but", "tokens": [50832, 1042, 11, 1604, 300, 341, 307, 364, 2693, 12879, 24420, 1154, 11, 689, 321, 362, 3097, 1412, 11, 457, 51132], "temperature": 0.0, "avg_logprob": -0.12367806067833534, "compression_ratio": 1.6168224299065421, "no_speech_prob": 0.00648735836148262}, {"id": 160, "seek": 78660, "start": 801.96, "end": 805.32, "text": " no labels for the latent space, z.", "tokens": [51132, 572, 16949, 337, 264, 48994, 1901, 11, 710, 13, 51300], "temperature": 0.0, "avg_logprob": -0.12367806067833534, "compression_ratio": 1.6168224299065421, "no_speech_prob": 0.00648735836148262}, {"id": 161, "seek": 78660, "start": 805.32, "end": 811.28, "text": " So in order to actually train such a model, what we can do is learn a decoder network", "tokens": [51300, 407, 294, 1668, 281, 767, 3847, 1270, 257, 2316, 11, 437, 321, 393, 360, 307, 1466, 257, 979, 19866, 3209, 51598], "temperature": 0.0, "avg_logprob": -0.12367806067833534, "compression_ratio": 1.6168224299065421, "no_speech_prob": 0.00648735836148262}, {"id": 162, "seek": 81128, "start": 811.28, "end": 816.64, "text": " and build up a decoder network that is used to actually reconstruct the original image", "tokens": [50364, 293, 1322, 493, 257, 979, 19866, 3209, 300, 307, 1143, 281, 767, 31499, 264, 3380, 3256, 50632], "temperature": 0.0, "avg_logprob": -0.10643451302139847, "compression_ratio": 1.802325581395349, "no_speech_prob": 0.36640676856040955}, {"id": 163, "seek": 81128, "start": 816.64, "end": 820.1999999999999, "text": " starting from this lower dimensional latent space.", "tokens": [50632, 2891, 490, 341, 3126, 18795, 48994, 1901, 13, 50810], "temperature": 0.0, "avg_logprob": -0.10643451302139847, "compression_ratio": 1.802325581395349, "no_speech_prob": 0.36640676856040955}, {"id": 164, "seek": 81128, "start": 820.1999999999999, "end": 826.16, "text": " And again, this decoder portion of our autoencoder network is going to be a series of layers,", "tokens": [50810, 400, 797, 11, 341, 979, 19866, 8044, 295, 527, 8399, 22660, 19866, 3209, 307, 516, 281, 312, 257, 2638, 295, 7914, 11, 51108], "temperature": 0.0, "avg_logprob": -0.10643451302139847, "compression_ratio": 1.802325581395349, "no_speech_prob": 0.36640676856040955}, {"id": 165, "seek": 81128, "start": 826.16, "end": 831.24, "text": " neural network layers like convolutional layers, that's going to then take this hidden latent", "tokens": [51108, 18161, 3209, 7914, 411, 45216, 304, 7914, 11, 300, 311, 516, 281, 550, 747, 341, 7633, 48994, 51362], "temperature": 0.0, "avg_logprob": -0.10643451302139847, "compression_ratio": 1.802325581395349, "no_speech_prob": 0.36640676856040955}, {"id": 166, "seek": 81128, "start": 831.24, "end": 835.76, "text": " vector and map it back up to the input space.", "tokens": [51362, 8062, 293, 4471, 309, 646, 493, 281, 264, 4846, 1901, 13, 51588], "temperature": 0.0, "avg_logprob": -0.10643451302139847, "compression_ratio": 1.802325581395349, "no_speech_prob": 0.36640676856040955}, {"id": 167, "seek": 81128, "start": 835.76, "end": 840.52, "text": " And we call our reconstructed output x hat, because it's our prediction and it's an imperfect", "tokens": [51588, 400, 321, 818, 527, 31499, 292, 5598, 2031, 2385, 11, 570, 309, 311, 527, 17630, 293, 309, 311, 364, 26714, 51826], "temperature": 0.0, "avg_logprob": -0.10643451302139847, "compression_ratio": 1.802325581395349, "no_speech_prob": 0.36640676856040955}, {"id": 168, "seek": 84052, "start": 840.52, "end": 845.36, "text": " reconstruction of our input x.", "tokens": [50364, 31565, 295, 527, 4846, 2031, 13, 50606], "temperature": 0.0, "avg_logprob": -0.10883405049641927, "compression_ratio": 1.62, "no_speech_prob": 0.0017545316368341446}, {"id": 169, "seek": 84052, "start": 845.36, "end": 849.92, "text": " And the way that we can actually train this network is by looking at the original input", "tokens": [50606, 400, 264, 636, 300, 321, 393, 767, 3847, 341, 3209, 307, 538, 1237, 412, 264, 3380, 4846, 50834], "temperature": 0.0, "avg_logprob": -0.10883405049641927, "compression_ratio": 1.62, "no_speech_prob": 0.0017545316368341446}, {"id": 170, "seek": 84052, "start": 849.92, "end": 856.48, "text": " x and our reconstructed output x hat and simply comparing the two and minimizing the distance", "tokens": [50834, 2031, 293, 527, 31499, 292, 5598, 2031, 2385, 293, 2935, 15763, 264, 732, 293, 46608, 264, 4560, 51162], "temperature": 0.0, "avg_logprob": -0.10883405049641927, "compression_ratio": 1.62, "no_speech_prob": 0.0017545316368341446}, {"id": 171, "seek": 84052, "start": 856.48, "end": 860.04, "text": " between these two images.", "tokens": [51162, 1296, 613, 732, 5267, 13, 51340], "temperature": 0.0, "avg_logprob": -0.10883405049641927, "compression_ratio": 1.62, "no_speech_prob": 0.0017545316368341446}, {"id": 172, "seek": 84052, "start": 860.04, "end": 865.12, "text": " So for example, we could consider the mean squared error, which in the case of images", "tokens": [51340, 407, 337, 1365, 11, 321, 727, 1949, 264, 914, 8889, 6713, 11, 597, 294, 264, 1389, 295, 5267, 51594], "temperature": 0.0, "avg_logprob": -0.10883405049641927, "compression_ratio": 1.62, "no_speech_prob": 0.0017545316368341446}, {"id": 173, "seek": 86512, "start": 865.12, "end": 871.52, "text": " means effectively subtracting one image from another and squaring the difference, which", "tokens": [50364, 1355, 8659, 16390, 278, 472, 3256, 490, 1071, 293, 2339, 1921, 264, 2649, 11, 597, 50684], "temperature": 0.0, "avg_logprob": -0.10894186743374529, "compression_ratio": 1.9155555555555555, "no_speech_prob": 0.005554491188377142}, {"id": 174, "seek": 86512, "start": 871.52, "end": 876.52, "text": " is effectively the pixel wise difference between the input and reconstruction, measuring how", "tokens": [50684, 307, 8659, 264, 19261, 10829, 2649, 1296, 264, 4846, 293, 31565, 11, 13389, 577, 50934], "temperature": 0.0, "avg_logprob": -0.10894186743374529, "compression_ratio": 1.9155555555555555, "no_speech_prob": 0.005554491188377142}, {"id": 175, "seek": 86512, "start": 876.52, "end": 881.0, "text": " faithful our reconstruction is to the original input.", "tokens": [50934, 17808, 527, 31565, 307, 281, 264, 3380, 4846, 13, 51158], "temperature": 0.0, "avg_logprob": -0.10894186743374529, "compression_ratio": 1.9155555555555555, "no_speech_prob": 0.005554491188377142}, {"id": 176, "seek": 86512, "start": 881.0, "end": 887.36, "text": " And again, notice that by using this reconstruction loss, this difference between the reconstructed", "tokens": [51158, 400, 797, 11, 3449, 300, 538, 1228, 341, 31565, 4470, 11, 341, 2649, 1296, 264, 31499, 292, 51476], "temperature": 0.0, "avg_logprob": -0.10894186743374529, "compression_ratio": 1.9155555555555555, "no_speech_prob": 0.005554491188377142}, {"id": 177, "seek": 86512, "start": 887.36, "end": 895.08, "text": " output and our original input, we do not require any labels for our data beyond the data itself.", "tokens": [51476, 5598, 293, 527, 3380, 4846, 11, 321, 360, 406, 3651, 604, 16949, 337, 527, 1412, 4399, 264, 1412, 2564, 13, 51862], "temperature": 0.0, "avg_logprob": -0.10894186743374529, "compression_ratio": 1.9155555555555555, "no_speech_prob": 0.005554491188377142}, {"id": 178, "seek": 89508, "start": 896.08, "end": 905.08, "text": " So we can simplify this diagram just a little bit by abstracting away these individual layers", "tokens": [50414, 407, 321, 393, 20460, 341, 10686, 445, 257, 707, 857, 538, 12649, 278, 1314, 613, 2609, 7914, 50864], "temperature": 0.0, "avg_logprob": -0.13753349479587598, "compression_ratio": 1.6233766233766234, "no_speech_prob": 0.002396433847025037}, {"id": 179, "seek": 89508, "start": 905.08, "end": 907.72, "text": " in the encoder and decoder components.", "tokens": [50864, 294, 264, 2058, 19866, 293, 979, 19866, 6677, 13, 50996], "temperature": 0.0, "avg_logprob": -0.13753349479587598, "compression_ratio": 1.6233766233766234, "no_speech_prob": 0.002396433847025037}, {"id": 180, "seek": 89508, "start": 907.72, "end": 913.84, "text": " And again, note once again that this loss function does not require any labels, it is", "tokens": [50996, 400, 797, 11, 3637, 1564, 797, 300, 341, 4470, 2445, 775, 406, 3651, 604, 16949, 11, 309, 307, 51302], "temperature": 0.0, "avg_logprob": -0.13753349479587598, "compression_ratio": 1.6233766233766234, "no_speech_prob": 0.002396433847025037}, {"id": 181, "seek": 89508, "start": 913.84, "end": 918.2800000000001, "text": " just using the raw data to supervise itself on the output.", "tokens": [51302, 445, 1228, 264, 8936, 1412, 281, 37971, 908, 2564, 322, 264, 5598, 13, 51524], "temperature": 0.0, "avg_logprob": -0.13753349479587598, "compression_ratio": 1.6233766233766234, "no_speech_prob": 0.002396433847025037}, {"id": 182, "seek": 89508, "start": 918.2800000000001, "end": 924.6, "text": " And this is a truly powerful idea and a transformative idea because it enables the model to learn", "tokens": [51524, 400, 341, 307, 257, 4908, 4005, 1558, 293, 257, 36070, 1558, 570, 309, 17077, 264, 2316, 281, 1466, 51840], "temperature": 0.0, "avg_logprob": -0.13753349479587598, "compression_ratio": 1.6233766233766234, "no_speech_prob": 0.002396433847025037}, {"id": 183, "seek": 92460, "start": 924.6, "end": 930.9200000000001, "text": " a quantity, the latent variables z, that we're fundamentally interested in, but we", "tokens": [50364, 257, 11275, 11, 264, 48994, 9102, 710, 11, 300, 321, 434, 17879, 3102, 294, 11, 457, 321, 50680], "temperature": 0.0, "avg_logprob": -0.12470248575960652, "compression_ratio": 1.6638297872340426, "no_speech_prob": 0.00035693173413164914}, {"id": 184, "seek": 92460, "start": 930.9200000000001, "end": 935.36, "text": " cannot simply observe or cannot readily model.", "tokens": [50680, 2644, 2935, 11441, 420, 2644, 26336, 2316, 13, 50902], "temperature": 0.0, "avg_logprob": -0.12470248575960652, "compression_ratio": 1.6638297872340426, "no_speech_prob": 0.00035693173413164914}, {"id": 185, "seek": 92460, "start": 935.36, "end": 943.16, "text": " And when we constrain this latent space to a lower dimensionality, that affects the degree", "tokens": [50902, 400, 562, 321, 1817, 7146, 341, 48994, 1901, 281, 257, 3126, 10139, 1860, 11, 300, 11807, 264, 4314, 51292], "temperature": 0.0, "avg_logprob": -0.12470248575960652, "compression_ratio": 1.6638297872340426, "no_speech_prob": 0.00035693173413164914}, {"id": 186, "seek": 92460, "start": 943.16, "end": 947.44, "text": " to which and the faithfulness to which we can actually reconstruct the input.", "tokens": [51292, 281, 597, 293, 264, 17808, 1287, 281, 597, 321, 393, 767, 31499, 264, 4846, 13, 51506], "temperature": 0.0, "avg_logprob": -0.12470248575960652, "compression_ratio": 1.6638297872340426, "no_speech_prob": 0.00035693173413164914}, {"id": 187, "seek": 92460, "start": 947.44, "end": 953.1600000000001, "text": " And the way you can think of this is as imposing a sort of information bottleneck during the", "tokens": [51506, 400, 264, 636, 291, 393, 519, 295, 341, 307, 382, 40288, 257, 1333, 295, 1589, 44641, 547, 1830, 264, 51792], "temperature": 0.0, "avg_logprob": -0.12470248575960652, "compression_ratio": 1.6638297872340426, "no_speech_prob": 0.00035693173413164914}, {"id": 188, "seek": 95316, "start": 953.16, "end": 955.7199999999999, "text": " models training and learning process.", "tokens": [50364, 5245, 3097, 293, 2539, 1399, 13, 50492], "temperature": 0.0, "avg_logprob": -0.1676906394958496, "compression_ratio": 1.7078189300411524, "no_speech_prob": 0.000911009032279253}, {"id": 189, "seek": 95316, "start": 955.7199999999999, "end": 960.4399999999999, "text": " And effectively, what this bottleneck does is a form of compression, right?", "tokens": [50492, 400, 8659, 11, 437, 341, 44641, 547, 775, 307, 257, 1254, 295, 19355, 11, 558, 30, 50728], "temperature": 0.0, "avg_logprob": -0.1676906394958496, "compression_ratio": 1.7078189300411524, "no_speech_prob": 0.000911009032279253}, {"id": 190, "seek": 95316, "start": 960.4399999999999, "end": 966.28, "text": " We're taking the input data, compressing it down to a much smaller latent space, and", "tokens": [50728, 492, 434, 1940, 264, 4846, 1412, 11, 14778, 278, 309, 760, 281, 257, 709, 4356, 48994, 1901, 11, 293, 51020], "temperature": 0.0, "avg_logprob": -0.1676906394958496, "compression_ratio": 1.7078189300411524, "no_speech_prob": 0.000911009032279253}, {"id": 191, "seek": 95316, "start": 966.28, "end": 969.12, "text": " then building back up a reconstruction.", "tokens": [51020, 550, 2390, 646, 493, 257, 31565, 13, 51162], "temperature": 0.0, "avg_logprob": -0.1676906394958496, "compression_ratio": 1.7078189300411524, "no_speech_prob": 0.000911009032279253}, {"id": 192, "seek": 95316, "start": 969.12, "end": 973.48, "text": " And in practice, what this results in is that the lower the dimensionality of your latent", "tokens": [51162, 400, 294, 3124, 11, 437, 341, 3542, 294, 307, 300, 264, 3126, 264, 10139, 1860, 295, 428, 48994, 51380], "temperature": 0.0, "avg_logprob": -0.1676906394958496, "compression_ratio": 1.7078189300411524, "no_speech_prob": 0.000911009032279253}, {"id": 193, "seek": 95316, "start": 973.48, "end": 978.76, "text": " space, the poorer and worse quality reconstruction you're going to get out.", "tokens": [51380, 1901, 11, 264, 49740, 293, 5324, 3125, 31565, 291, 434, 516, 281, 483, 484, 13, 51644], "temperature": 0.0, "avg_logprob": -0.1676906394958496, "compression_ratio": 1.7078189300411524, "no_speech_prob": 0.000911009032279253}, {"id": 194, "seek": 95316, "start": 978.76, "end": 980.52, "text": " All right.", "tokens": [51644, 1057, 558, 13, 51732], "temperature": 0.0, "avg_logprob": -0.1676906394958496, "compression_ratio": 1.7078189300411524, "no_speech_prob": 0.000911009032279253}, {"id": 195, "seek": 98052, "start": 980.52, "end": 985.96, "text": " So in summary, these autoencoder structures use this sort of bottlenecking hidden layer", "tokens": [50364, 407, 294, 12691, 11, 613, 8399, 22660, 19866, 9227, 764, 341, 1333, 295, 44641, 25723, 7633, 4583, 50636], "temperature": 0.0, "avg_logprob": -0.12069168298140816, "compression_ratio": 1.685483870967742, "no_speech_prob": 0.0006263118120841682}, {"id": 196, "seek": 98052, "start": 985.96, "end": 990.04, "text": " to learn a compressed latent representation of the data.", "tokens": [50636, 281, 1466, 257, 30353, 48994, 10290, 295, 264, 1412, 13, 50840], "temperature": 0.0, "avg_logprob": -0.12069168298140816, "compression_ratio": 1.685483870967742, "no_speech_prob": 0.0006263118120841682}, {"id": 197, "seek": 98052, "start": 990.04, "end": 994.76, "text": " And we can self-supervise the training of this network by using what we call a reconstruction", "tokens": [50840, 400, 321, 393, 2698, 12, 48172, 85, 908, 264, 3097, 295, 341, 3209, 538, 1228, 437, 321, 818, 257, 31565, 51076], "temperature": 0.0, "avg_logprob": -0.12069168298140816, "compression_ratio": 1.685483870967742, "no_speech_prob": 0.0006263118120841682}, {"id": 198, "seek": 98052, "start": 994.76, "end": 1002.56, "text": " loss that forces the autoencoder network to encode as much information about the data", "tokens": [51076, 4470, 300, 5874, 264, 8399, 22660, 19866, 3209, 281, 2058, 1429, 382, 709, 1589, 466, 264, 1412, 51466], "temperature": 0.0, "avg_logprob": -0.12069168298140816, "compression_ratio": 1.685483870967742, "no_speech_prob": 0.0006263118120841682}, {"id": 199, "seek": 98052, "start": 1002.56, "end": 1008.84, "text": " as possible into a lower dimensional latent space while still being able to build up faithful", "tokens": [51466, 382, 1944, 666, 257, 3126, 18795, 48994, 1901, 1339, 920, 885, 1075, 281, 1322, 493, 17808, 51780], "temperature": 0.0, "avg_logprob": -0.12069168298140816, "compression_ratio": 1.685483870967742, "no_speech_prob": 0.0006263118120841682}, {"id": 200, "seek": 100884, "start": 1009.0400000000001, "end": 1010.5600000000001, "text": " reconstructions.", "tokens": [50374, 31499, 626, 13, 50450], "temperature": 0.0, "avg_logprob": -0.12494275736254315, "compression_ratio": 1.6009174311926606, "no_speech_prob": 0.011330276727676392}, {"id": 201, "seek": 100884, "start": 1010.5600000000001, "end": 1016.6800000000001, "text": " So the way I like to think of this is automatically encoding information from the data into a", "tokens": [50450, 407, 264, 636, 286, 411, 281, 519, 295, 341, 307, 6772, 43430, 1589, 490, 264, 1412, 666, 257, 50756], "temperature": 0.0, "avg_logprob": -0.12494275736254315, "compression_ratio": 1.6009174311926606, "no_speech_prob": 0.011330276727676392}, {"id": 202, "seek": 100884, "start": 1016.6800000000001, "end": 1020.64, "text": " lower dimensional latent space.", "tokens": [50756, 3126, 18795, 48994, 1901, 13, 50954], "temperature": 0.0, "avg_logprob": -0.12494275736254315, "compression_ratio": 1.6009174311926606, "no_speech_prob": 0.011330276727676392}, {"id": 203, "seek": 100884, "start": 1020.64, "end": 1026.04, "text": " Let's now expand upon this idea a bit more and introduce this concept and architecture", "tokens": [50954, 961, 311, 586, 5268, 3564, 341, 1558, 257, 857, 544, 293, 5366, 341, 3410, 293, 9482, 51224], "temperature": 0.0, "avg_logprob": -0.12494275736254315, "compression_ratio": 1.6009174311926606, "no_speech_prob": 0.011330276727676392}, {"id": 204, "seek": 100884, "start": 1026.04, "end": 1031.4, "text": " of variational autoencoders or VAEs.", "tokens": [51224, 295, 3034, 1478, 8399, 22660, 378, 433, 420, 18527, 20442, 13, 51492], "temperature": 0.0, "avg_logprob": -0.12494275736254315, "compression_ratio": 1.6009174311926606, "no_speech_prob": 0.011330276727676392}, {"id": 205, "seek": 100884, "start": 1031.4, "end": 1038.2, "text": " So as we just saw, traditional autoencoders go from input to reconstructed output.", "tokens": [51492, 407, 382, 321, 445, 1866, 11, 5164, 8399, 22660, 378, 433, 352, 490, 4846, 281, 31499, 292, 5598, 13, 51832], "temperature": 0.0, "avg_logprob": -0.12494275736254315, "compression_ratio": 1.6009174311926606, "no_speech_prob": 0.011330276727676392}, {"id": 206, "seek": 103820, "start": 1038.2, "end": 1044.0, "text": " And if we pay closer attention to this latent layer denoted to here in orange, what you", "tokens": [50364, 400, 498, 321, 1689, 4966, 3202, 281, 341, 48994, 4583, 1441, 23325, 281, 510, 294, 7671, 11, 437, 291, 50654], "temperature": 0.0, "avg_logprob": -0.11635194505964007, "compression_ratio": 1.7437722419928825, "no_speech_prob": 0.0040693748742341995}, {"id": 207, "seek": 103820, "start": 1044.0, "end": 1048.64, "text": " can hopefully realize is that this is just a normal layer in a neural network, just", "tokens": [50654, 393, 4696, 4325, 307, 300, 341, 307, 445, 257, 2710, 4583, 294, 257, 18161, 3209, 11, 445, 50886], "temperature": 0.0, "avg_logprob": -0.11635194505964007, "compression_ratio": 1.7437722419928825, "no_speech_prob": 0.0040693748742341995}, {"id": 208, "seek": 103820, "start": 1048.64, "end": 1050.0, "text": " like any other layer.", "tokens": [50886, 411, 604, 661, 4583, 13, 50954], "temperature": 0.0, "avg_logprob": -0.11635194505964007, "compression_ratio": 1.7437722419928825, "no_speech_prob": 0.0040693748742341995}, {"id": 209, "seek": 103820, "start": 1050.0, "end": 1051.4, "text": " It's deterministic.", "tokens": [50954, 467, 311, 15957, 3142, 13, 51024], "temperature": 0.0, "avg_logprob": -0.11635194505964007, "compression_ratio": 1.7437722419928825, "no_speech_prob": 0.0040693748742341995}, {"id": 210, "seek": 103820, "start": 1051.4, "end": 1055.0800000000002, "text": " If you're going to feed in a particular input to this network, you're going to get the", "tokens": [51024, 759, 291, 434, 516, 281, 3154, 294, 257, 1729, 4846, 281, 341, 3209, 11, 291, 434, 516, 281, 483, 264, 51208], "temperature": 0.0, "avg_logprob": -0.11635194505964007, "compression_ratio": 1.7437722419928825, "no_speech_prob": 0.0040693748742341995}, {"id": 211, "seek": 103820, "start": 1055.0800000000002, "end": 1058.28, "text": " same output so long as the weights are the same.", "tokens": [51208, 912, 5598, 370, 938, 382, 264, 17443, 366, 264, 912, 13, 51368], "temperature": 0.0, "avg_logprob": -0.11635194505964007, "compression_ratio": 1.7437722419928825, "no_speech_prob": 0.0040693748742341995}, {"id": 212, "seek": 103820, "start": 1058.28, "end": 1063.8, "text": " So effectively, a traditional autoencoder learns this deterministic encoding, which allows", "tokens": [51368, 407, 8659, 11, 257, 5164, 8399, 22660, 19866, 27152, 341, 15957, 3142, 43430, 11, 597, 4045, 51644], "temperature": 0.0, "avg_logprob": -0.11635194505964007, "compression_ratio": 1.7437722419928825, "no_speech_prob": 0.0040693748742341995}, {"id": 213, "seek": 103820, "start": 1063.8, "end": 1068.0, "text": " for reconstruction and reproduction of the input.", "tokens": [51644, 337, 31565, 293, 33934, 295, 264, 4846, 13, 51854], "temperature": 0.0, "avg_logprob": -0.11635194505964007, "compression_ratio": 1.7437722419928825, "no_speech_prob": 0.0040693748742341995}, {"id": 214, "seek": 106800, "start": 1068.0, "end": 1075.6, "text": " In contrast, variational autoencoders impose a stochastic or variational twist on this", "tokens": [50364, 682, 8712, 11, 3034, 1478, 8399, 22660, 378, 433, 26952, 257, 342, 8997, 2750, 420, 3034, 1478, 8203, 322, 341, 50744], "temperature": 0.0, "avg_logprob": -0.11846497353543056, "compression_ratio": 1.8173076923076923, "no_speech_prob": 0.00030533361132256687}, {"id": 215, "seek": 106800, "start": 1075.6, "end": 1077.2, "text": " architecture.", "tokens": [50744, 9482, 13, 50824], "temperature": 0.0, "avg_logprob": -0.11846497353543056, "compression_ratio": 1.8173076923076923, "no_speech_prob": 0.00030533361132256687}, {"id": 216, "seek": 106800, "start": 1077.2, "end": 1083.88, "text": " And the idea behind doing so is to generate smoother representations of the input data", "tokens": [50824, 400, 264, 1558, 2261, 884, 370, 307, 281, 8460, 28640, 33358, 295, 264, 4846, 1412, 51158], "temperature": 0.0, "avg_logprob": -0.11846497353543056, "compression_ratio": 1.8173076923076923, "no_speech_prob": 0.00030533361132256687}, {"id": 217, "seek": 106800, "start": 1083.88, "end": 1090.6, "text": " and improve the quality of the not only of reconstructions, but also to actually generate", "tokens": [51158, 293, 3470, 264, 3125, 295, 264, 406, 787, 295, 31499, 626, 11, 457, 611, 281, 767, 8460, 51494], "temperature": 0.0, "avg_logprob": -0.11846497353543056, "compression_ratio": 1.8173076923076923, "no_speech_prob": 0.00030533361132256687}, {"id": 218, "seek": 106800, "start": 1090.6, "end": 1096.32, "text": " new images that are similar to the input data set, but not direct reconstructions of the", "tokens": [51494, 777, 5267, 300, 366, 2531, 281, 264, 4846, 1412, 992, 11, 457, 406, 2047, 31499, 626, 295, 264, 51780], "temperature": 0.0, "avg_logprob": -0.11846497353543056, "compression_ratio": 1.8173076923076923, "no_speech_prob": 0.00030533361132256687}, {"id": 219, "seek": 106800, "start": 1096.32, "end": 1097.8, "text": " input data.", "tokens": [51780, 4846, 1412, 13, 51854], "temperature": 0.0, "avg_logprob": -0.11846497353543056, "compression_ratio": 1.8173076923076923, "no_speech_prob": 0.00030533361132256687}, {"id": 220, "seek": 109780, "start": 1097.8, "end": 1104.04, "text": " And the way this is achieved is that variational autoencoders replace that deterministic layer", "tokens": [50364, 400, 264, 636, 341, 307, 11042, 307, 300, 3034, 1478, 8399, 22660, 378, 433, 7406, 300, 15957, 3142, 4583, 50676], "temperature": 0.0, "avg_logprob": -0.12030287583669026, "compression_ratio": 1.8043478260869565, "no_speech_prob": 0.0003053405089303851}, {"id": 221, "seek": 109780, "start": 1104.04, "end": 1108.6, "text": " Z with a stochastic sampling operation.", "tokens": [50676, 1176, 365, 257, 342, 8997, 2750, 21179, 6916, 13, 50904], "temperature": 0.0, "avg_logprob": -0.12030287583669026, "compression_ratio": 1.8043478260869565, "no_speech_prob": 0.0003053405089303851}, {"id": 222, "seek": 109780, "start": 1108.6, "end": 1114.12, "text": " What this means is that instead of learning the latent variables Z directly, for each", "tokens": [50904, 708, 341, 1355, 307, 300, 2602, 295, 2539, 264, 48994, 9102, 1176, 3838, 11, 337, 1184, 51180], "temperature": 0.0, "avg_logprob": -0.12030287583669026, "compression_ratio": 1.8043478260869565, "no_speech_prob": 0.0003053405089303851}, {"id": 223, "seek": 109780, "start": 1114.12, "end": 1120.68, "text": " variable, the variational autoencoder learns a mean and a variance associated with that", "tokens": [51180, 7006, 11, 264, 3034, 1478, 8399, 22660, 19866, 27152, 257, 914, 293, 257, 21977, 6615, 365, 300, 51508], "temperature": 0.0, "avg_logprob": -0.12030287583669026, "compression_ratio": 1.8043478260869565, "no_speech_prob": 0.0003053405089303851}, {"id": 224, "seek": 109780, "start": 1120.68, "end": 1122.28, "text": " latent variable.", "tokens": [51508, 48994, 7006, 13, 51588], "temperature": 0.0, "avg_logprob": -0.12030287583669026, "compression_ratio": 1.8043478260869565, "no_speech_prob": 0.0003053405089303851}, {"id": 225, "seek": 109780, "start": 1122.28, "end": 1127.32, "text": " And what those means and variances do is that they parametrize a probability distribution", "tokens": [51588, 400, 437, 729, 1355, 293, 1374, 21518, 360, 307, 300, 436, 6220, 302, 470, 1381, 257, 8482, 7316, 51840], "temperature": 0.0, "avg_logprob": -0.12030287583669026, "compression_ratio": 1.8043478260869565, "no_speech_prob": 0.0003053405089303851}, {"id": 226, "seek": 112732, "start": 1127.32, "end": 1129.48, "text": " for that latent variable.", "tokens": [50364, 337, 300, 48994, 7006, 13, 50472], "temperature": 0.0, "avg_logprob": -0.1258530440153899, "compression_ratio": 1.8241758241758241, "no_speech_prob": 0.00382413063198328}, {"id": 227, "seek": 112732, "start": 1129.48, "end": 1135.6, "text": " So what we've done in going from an autoencoder to a variational autoencoder is going from", "tokens": [50472, 407, 437, 321, 600, 1096, 294, 516, 490, 364, 8399, 22660, 19866, 281, 257, 3034, 1478, 8399, 22660, 19866, 307, 516, 490, 50778], "temperature": 0.0, "avg_logprob": -0.1258530440153899, "compression_ratio": 1.8241758241758241, "no_speech_prob": 0.00382413063198328}, {"id": 228, "seek": 112732, "start": 1135.6, "end": 1142.6, "text": " a vector of latent variables Z to learning a vector of means mu and a vector of variances", "tokens": [50778, 257, 8062, 295, 48994, 9102, 1176, 281, 2539, 257, 8062, 295, 1355, 2992, 293, 257, 8062, 295, 1374, 21518, 51128], "temperature": 0.0, "avg_logprob": -0.1258530440153899, "compression_ratio": 1.8241758241758241, "no_speech_prob": 0.00382413063198328}, {"id": 229, "seek": 112732, "start": 1142.6, "end": 1150.6799999999998, "text": " sigma, sigma squared, that parametrize these variables and define probability distributions", "tokens": [51128, 12771, 11, 12771, 8889, 11, 300, 6220, 302, 470, 1381, 613, 9102, 293, 6964, 8482, 37870, 51532], "temperature": 0.0, "avg_logprob": -0.1258530440153899, "compression_ratio": 1.8241758241758241, "no_speech_prob": 0.00382413063198328}, {"id": 230, "seek": 112732, "start": 1150.6799999999998, "end": 1153.8, "text": " for each of our latent variables.", "tokens": [51532, 337, 1184, 295, 527, 48994, 9102, 13, 51688], "temperature": 0.0, "avg_logprob": -0.1258530440153899, "compression_ratio": 1.8241758241758241, "no_speech_prob": 0.00382413063198328}, {"id": 231, "seek": 115380, "start": 1153.8, "end": 1160.24, "text": " And the way we can actually generate new data instances is by sampling from the distribution", "tokens": [50364, 400, 264, 636, 321, 393, 767, 8460, 777, 1412, 14519, 307, 538, 21179, 490, 264, 7316, 50686], "temperature": 0.0, "avg_logprob": -0.09982652103199678, "compression_ratio": 1.6333333333333333, "no_speech_prob": 0.0033763721585273743}, {"id": 232, "seek": 115380, "start": 1160.24, "end": 1169.84, "text": " defined by these mus and sigmas to generate a latent sample and get probabilistic representations", "tokens": [50686, 7642, 538, 613, 1038, 293, 4556, 3799, 281, 8460, 257, 48994, 6889, 293, 483, 31959, 3142, 33358, 51166], "temperature": 0.0, "avg_logprob": -0.09982652103199678, "compression_ratio": 1.6333333333333333, "no_speech_prob": 0.0033763721585273743}, {"id": 233, "seek": 115380, "start": 1169.84, "end": 1172.28, "text": " of the latent space.", "tokens": [51166, 295, 264, 48994, 1901, 13, 51288], "temperature": 0.0, "avg_logprob": -0.09982652103199678, "compression_ratio": 1.6333333333333333, "no_speech_prob": 0.0033763721585273743}, {"id": 234, "seek": 115380, "start": 1172.28, "end": 1175.96, "text": " And what I'd like you to appreciate about this network architecture is that it's very", "tokens": [51288, 400, 437, 286, 1116, 411, 291, 281, 4449, 466, 341, 3209, 9482, 307, 300, 309, 311, 588, 51472], "temperature": 0.0, "avg_logprob": -0.09982652103199678, "compression_ratio": 1.6333333333333333, "no_speech_prob": 0.0033763721585273743}, {"id": 235, "seek": 115380, "start": 1175.96, "end": 1181.72, "text": " similar to the autoencoder I previously introduced, just that we have this probabilistic twist", "tokens": [51472, 2531, 281, 264, 8399, 22660, 19866, 286, 8046, 7268, 11, 445, 300, 321, 362, 341, 31959, 3142, 8203, 51760], "temperature": 0.0, "avg_logprob": -0.09982652103199678, "compression_ratio": 1.6333333333333333, "no_speech_prob": 0.0033763721585273743}, {"id": 236, "seek": 118172, "start": 1181.8, "end": 1187.76, "text": " where we're now performing the sampling operation to compute samples from each of the latent", "tokens": [50368, 689, 321, 434, 586, 10205, 264, 21179, 6916, 281, 14722, 10938, 490, 1184, 295, 264, 48994, 50666], "temperature": 0.0, "avg_logprob": -0.16964210782732284, "compression_ratio": 1.7156398104265402, "no_speech_prob": 0.002550724660977721}, {"id": 237, "seek": 118172, "start": 1187.76, "end": 1189.76, "text": " variables.", "tokens": [50666, 9102, 13, 50766], "temperature": 0.0, "avg_logprob": -0.16964210782732284, "compression_ratio": 1.7156398104265402, "no_speech_prob": 0.002550724660977721}, {"id": 238, "seek": 118172, "start": 1189.76, "end": 1197.44, "text": " All right, so now because we've introduced this sampling operation, this stochasticity", "tokens": [50766, 1057, 558, 11, 370, 586, 570, 321, 600, 7268, 341, 21179, 6916, 11, 341, 342, 8997, 2750, 507, 51150], "temperature": 0.0, "avg_logprob": -0.16964210782732284, "compression_ratio": 1.7156398104265402, "no_speech_prob": 0.002550724660977721}, {"id": 239, "seek": 118172, "start": 1197.44, "end": 1203.64, "text": " into our model, what this means for the actual computation and learning process of the network,", "tokens": [51150, 666, 527, 2316, 11, 437, 341, 1355, 337, 264, 3539, 24903, 293, 2539, 1399, 295, 264, 3209, 11, 51460], "temperature": 0.0, "avg_logprob": -0.16964210782732284, "compression_ratio": 1.7156398104265402, "no_speech_prob": 0.002550724660977721}, {"id": 240, "seek": 118172, "start": 1203.64, "end": 1209.48, "text": " the encoder and decoder, is that they're now probabilistic in their nature.", "tokens": [51460, 264, 2058, 19866, 293, 979, 19866, 11, 307, 300, 436, 434, 586, 31959, 3142, 294, 641, 3687, 13, 51752], "temperature": 0.0, "avg_logprob": -0.16964210782732284, "compression_ratio": 1.7156398104265402, "no_speech_prob": 0.002550724660977721}, {"id": 241, "seek": 120948, "start": 1209.52, "end": 1214.8, "text": " And the way you can think of this is that our encoder is going to be trying to learn", "tokens": [50366, 400, 264, 636, 291, 393, 519, 295, 341, 307, 300, 527, 2058, 19866, 307, 516, 281, 312, 1382, 281, 1466, 50630], "temperature": 0.0, "avg_logprob": -0.10926060927541632, "compression_ratio": 1.92018779342723, "no_speech_prob": 0.004609112627804279}, {"id": 242, "seek": 120948, "start": 1214.8, "end": 1223.0, "text": " a probability distribution of the latent space Z given the input data X, while the decoder", "tokens": [50630, 257, 8482, 7316, 295, 264, 48994, 1901, 1176, 2212, 264, 4846, 1412, 1783, 11, 1339, 264, 979, 19866, 51040], "temperature": 0.0, "avg_logprob": -0.10926060927541632, "compression_ratio": 1.92018779342723, "no_speech_prob": 0.004609112627804279}, {"id": 243, "seek": 120948, "start": 1223.0, "end": 1229.44, "text": " is going to take that learned latent representation and compute a new probability distribution", "tokens": [51040, 307, 516, 281, 747, 300, 3264, 48994, 10290, 293, 14722, 257, 777, 8482, 7316, 51362], "temperature": 0.0, "avg_logprob": -0.10926060927541632, "compression_ratio": 1.92018779342723, "no_speech_prob": 0.004609112627804279}, {"id": 244, "seek": 120948, "start": 1229.44, "end": 1233.8, "text": " of the input X given that latent distribution Z.", "tokens": [51362, 295, 264, 4846, 1783, 2212, 300, 48994, 7316, 1176, 13, 51580], "temperature": 0.0, "avg_logprob": -0.10926060927541632, "compression_ratio": 1.92018779342723, "no_speech_prob": 0.004609112627804279}, {"id": 245, "seek": 120948, "start": 1233.8, "end": 1239.4, "text": " And these networks, the encoder, the decoder, are going to be defined by separate sets of", "tokens": [51580, 400, 613, 9590, 11, 264, 2058, 19866, 11, 264, 979, 19866, 11, 366, 516, 281, 312, 7642, 538, 4994, 6352, 295, 51860], "temperature": 0.0, "avg_logprob": -0.10926060927541632, "compression_ratio": 1.92018779342723, "no_speech_prob": 0.004609112627804279}, {"id": 246, "seek": 123940, "start": 1239.44, "end": 1242.48, "text": " weights, phi and theta.", "tokens": [50366, 17443, 11, 13107, 293, 9725, 13, 50518], "temperature": 0.0, "avg_logprob": -0.09896515691003134, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.000503318035043776}, {"id": 247, "seek": 123940, "start": 1242.48, "end": 1248.92, "text": " And the way that we can train this variational autoencoder is by defining a loss function", "tokens": [50518, 400, 264, 636, 300, 321, 393, 3847, 341, 3034, 1478, 8399, 22660, 19866, 307, 538, 17827, 257, 4470, 2445, 50840], "temperature": 0.0, "avg_logprob": -0.09896515691003134, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.000503318035043776}, {"id": 248, "seek": 123940, "start": 1248.92, "end": 1255.92, "text": " that's going to be a function of the data X as well as the sets of weights phi and theta.", "tokens": [50840, 300, 311, 516, 281, 312, 257, 2445, 295, 264, 1412, 1783, 382, 731, 382, 264, 6352, 295, 17443, 13107, 293, 9725, 13, 51190], "temperature": 0.0, "avg_logprob": -0.09896515691003134, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.000503318035043776}, {"id": 249, "seek": 123940, "start": 1255.92, "end": 1262.68, "text": " And what's key to how VAEs can be optimized is that this loss function is now comprised", "tokens": [51190, 400, 437, 311, 2141, 281, 577, 18527, 20442, 393, 312, 26941, 307, 300, 341, 4470, 2445, 307, 586, 38062, 51528], "temperature": 0.0, "avg_logprob": -0.09896515691003134, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.000503318035043776}, {"id": 250, "seek": 123940, "start": 1262.68, "end": 1265.16, "text": " of two terms instead of just one.", "tokens": [51528, 295, 732, 2115, 2602, 295, 445, 472, 13, 51652], "temperature": 0.0, "avg_logprob": -0.09896515691003134, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.000503318035043776}, {"id": 251, "seek": 126516, "start": 1265.16, "end": 1270.8000000000002, "text": " We have the reconstruction loss just as before, which again is going to capture this difference", "tokens": [50364, 492, 362, 264, 31565, 4470, 445, 382, 949, 11, 597, 797, 307, 516, 281, 7983, 341, 2649, 50646], "temperature": 0.0, "avg_logprob": -0.11316361427307128, "compression_ratio": 1.6146341463414635, "no_speech_prob": 0.000607060908805579}, {"id": 252, "seek": 126516, "start": 1270.8000000000002, "end": 1276.92, "text": " between the input and the reconstructed output, and also a new term to our loss, which we", "tokens": [50646, 1296, 264, 4846, 293, 264, 31499, 292, 5598, 11, 293, 611, 257, 777, 1433, 281, 527, 4470, 11, 597, 321, 50952], "temperature": 0.0, "avg_logprob": -0.11316361427307128, "compression_ratio": 1.6146341463414635, "no_speech_prob": 0.000607060908805579}, {"id": 253, "seek": 126516, "start": 1276.92, "end": 1282.92, "text": " call the regularization loss, also called the VAE loss.", "tokens": [50952, 818, 264, 3890, 2144, 4470, 11, 611, 1219, 264, 18527, 36, 4470, 13, 51252], "temperature": 0.0, "avg_logprob": -0.11316361427307128, "compression_ratio": 1.6146341463414635, "no_speech_prob": 0.000607060908805579}, {"id": 254, "seek": 126516, "start": 1282.92, "end": 1289.92, "text": " And to take a look in more detail at why each of these loss terms represents, let's first", "tokens": [51252, 400, 281, 747, 257, 574, 294, 544, 2607, 412, 983, 1184, 295, 613, 4470, 2115, 8855, 11, 718, 311, 700, 51602], "temperature": 0.0, "avg_logprob": -0.11316361427307128, "compression_ratio": 1.6146341463414635, "no_speech_prob": 0.000607060908805579}, {"id": 255, "seek": 128992, "start": 1289.96, "end": 1296.3200000000002, "text": " emphasize again that our overall loss function is going to be defined and taken with respect", "tokens": [50366, 16078, 797, 300, 527, 4787, 4470, 2445, 307, 516, 281, 312, 7642, 293, 2726, 365, 3104, 50684], "temperature": 0.0, "avg_logprob": -0.10174953803587496, "compression_ratio": 1.6217391304347826, "no_speech_prob": 0.0006878326530568302}, {"id": 256, "seek": 128992, "start": 1296.3200000000002, "end": 1302.3200000000002, "text": " to the sets of weights of the encoder and decoder and the input X.", "tokens": [50684, 281, 264, 6352, 295, 17443, 295, 264, 2058, 19866, 293, 979, 19866, 293, 264, 4846, 1783, 13, 50984], "temperature": 0.0, "avg_logprob": -0.10174953803587496, "compression_ratio": 1.6217391304347826, "no_speech_prob": 0.0006878326530568302}, {"id": 257, "seek": 128992, "start": 1302.3200000000002, "end": 1306.0800000000002, "text": " The reconstruction loss is very similar to before, right?", "tokens": [50984, 440, 31565, 4470, 307, 588, 2531, 281, 949, 11, 558, 30, 51172], "temperature": 0.0, "avg_logprob": -0.10174953803587496, "compression_ratio": 1.6217391304347826, "no_speech_prob": 0.0006878326530568302}, {"id": 258, "seek": 128992, "start": 1306.0800000000002, "end": 1311.8400000000001, "text": " And you can think of it as being driven by a log likelihood function, for example, for", "tokens": [51172, 400, 291, 393, 519, 295, 309, 382, 885, 9555, 538, 257, 3565, 22119, 2445, 11, 337, 1365, 11, 337, 51460], "temperature": 0.0, "avg_logprob": -0.10174953803587496, "compression_ratio": 1.6217391304347826, "no_speech_prob": 0.0006878326530568302}, {"id": 259, "seek": 128992, "start": 1311.8400000000001, "end": 1316.88, "text": " image data, the mean squared error between the input and the output.", "tokens": [51460, 3256, 1412, 11, 264, 914, 8889, 6713, 1296, 264, 4846, 293, 264, 5598, 13, 51712], "temperature": 0.0, "avg_logprob": -0.10174953803587496, "compression_ratio": 1.6217391304347826, "no_speech_prob": 0.0006878326530568302}, {"id": 260, "seek": 131688, "start": 1316.88, "end": 1322.4, "text": " And we can self-supervise the reconstruction loss just as before to force the latent space", "tokens": [50364, 400, 321, 393, 2698, 12, 48172, 85, 908, 264, 31565, 4470, 445, 382, 949, 281, 3464, 264, 48994, 1901, 50640], "temperature": 0.0, "avg_logprob": -0.11270973899147728, "compression_ratio": 1.6977777777777778, "no_speech_prob": 0.0029808231629431248}, {"id": 261, "seek": 131688, "start": 1322.4, "end": 1328.8000000000002, "text": " to learn and represent faithful representations of the input data, ultimately resulting in", "tokens": [50640, 281, 1466, 293, 2906, 17808, 33358, 295, 264, 4846, 1412, 11, 6284, 16505, 294, 50960], "temperature": 0.0, "avg_logprob": -0.11270973899147728, "compression_ratio": 1.6977777777777778, "no_speech_prob": 0.0029808231629431248}, {"id": 262, "seek": 131688, "start": 1328.8000000000002, "end": 1331.5200000000002, "text": " faithful reconstructions.", "tokens": [50960, 17808, 31499, 626, 13, 51096], "temperature": 0.0, "avg_logprob": -0.11270973899147728, "compression_ratio": 1.6977777777777778, "no_speech_prob": 0.0029808231629431248}, {"id": 263, "seek": 131688, "start": 1331.5200000000002, "end": 1337.1200000000001, "text": " The new term here, the regularization term, is a bit more interesting and completely new", "tokens": [51096, 440, 777, 1433, 510, 11, 264, 3890, 2144, 1433, 11, 307, 257, 857, 544, 1880, 293, 2584, 777, 51376], "temperature": 0.0, "avg_logprob": -0.11270973899147728, "compression_ratio": 1.6977777777777778, "no_speech_prob": 0.0029808231629431248}, {"id": 264, "seek": 131688, "start": 1337.1200000000001, "end": 1343.0800000000002, "text": " at this stage, so we're going to dive in and discuss it further in a bit more detail.", "tokens": [51376, 412, 341, 3233, 11, 370, 321, 434, 516, 281, 9192, 294, 293, 2248, 309, 3052, 294, 257, 857, 544, 2607, 13, 51674], "temperature": 0.0, "avg_logprob": -0.11270973899147728, "compression_ratio": 1.6977777777777778, "no_speech_prob": 0.0029808231629431248}, {"id": 265, "seek": 134308, "start": 1343.08, "end": 1348.84, "text": " So our probability distribution that's going to be computed by our encoder, q phi of z", "tokens": [50364, 407, 527, 8482, 7316, 300, 311, 516, 281, 312, 40610, 538, 527, 2058, 19866, 11, 9505, 13107, 295, 710, 50652], "temperature": 0.0, "avg_logprob": -0.19768651326497397, "compression_ratio": 1.625615763546798, "no_speech_prob": 0.02842843532562256}, {"id": 266, "seek": 134308, "start": 1348.84, "end": 1354.84, "text": " of x, is a distribution on the latent space z given the data x.", "tokens": [50652, 295, 2031, 11, 307, 257, 7316, 322, 264, 48994, 1901, 710, 2212, 264, 1412, 2031, 13, 50952], "temperature": 0.0, "avg_logprob": -0.19768651326497397, "compression_ratio": 1.625615763546798, "no_speech_prob": 0.02842843532562256}, {"id": 267, "seek": 134308, "start": 1354.84, "end": 1361.4399999999998, "text": " And what regularization enforces is that as a part of this learning process, we're going", "tokens": [50952, 400, 437, 3890, 2144, 25495, 887, 307, 300, 382, 257, 644, 295, 341, 2539, 1399, 11, 321, 434, 516, 51282], "temperature": 0.0, "avg_logprob": -0.19768651326497397, "compression_ratio": 1.625615763546798, "no_speech_prob": 0.02842843532562256}, {"id": 268, "seek": 134308, "start": 1361.4399999999998, "end": 1368.4399999999998, "text": " to place a prior on the latent space z, which is effectively some initial hypothesis about", "tokens": [51282, 281, 1081, 257, 4059, 322, 264, 48994, 1901, 710, 11, 597, 307, 8659, 512, 5883, 17291, 466, 51632], "temperature": 0.0, "avg_logprob": -0.19768651326497397, "compression_ratio": 1.625615763546798, "no_speech_prob": 0.02842843532562256}, {"id": 269, "seek": 136844, "start": 1369.16, "end": 1373.56, "text": " what we expect the distributions of z to actually look like.", "tokens": [50400, 437, 321, 2066, 264, 37870, 295, 710, 281, 767, 574, 411, 13, 50620], "temperature": 0.0, "avg_logprob": -0.12206376629111207, "compression_ratio": 1.6648936170212767, "no_speech_prob": 0.0005033230409026146}, {"id": 270, "seek": 136844, "start": 1373.56, "end": 1379.16, "text": " And by imposing this regularization term, what we can achieve is that the model will", "tokens": [50620, 400, 538, 40288, 341, 3890, 2144, 1433, 11, 437, 321, 393, 4584, 307, 300, 264, 2316, 486, 50900], "temperature": 0.0, "avg_logprob": -0.12206376629111207, "compression_ratio": 1.6648936170212767, "no_speech_prob": 0.0005033230409026146}, {"id": 271, "seek": 136844, "start": 1379.16, "end": 1384.6000000000001, "text": " try to enforce the z's that it learns to follow this prior distribution.", "tokens": [50900, 853, 281, 24825, 264, 710, 311, 300, 309, 27152, 281, 1524, 341, 4059, 7316, 13, 51172], "temperature": 0.0, "avg_logprob": -0.12206376629111207, "compression_ratio": 1.6648936170212767, "no_speech_prob": 0.0005033230409026146}, {"id": 272, "seek": 136844, "start": 1384.6000000000001, "end": 1388.3600000000001, "text": " And we're going to denote this prior as p of z.", "tokens": [51172, 400, 321, 434, 516, 281, 45708, 341, 4059, 382, 280, 295, 710, 13, 51360], "temperature": 0.0, "avg_logprob": -0.12206376629111207, "compression_ratio": 1.6648936170212767, "no_speech_prob": 0.0005033230409026146}, {"id": 273, "seek": 136844, "start": 1388.3600000000001, "end": 1392.52, "text": " This term here, d, is the regularization term.", "tokens": [51360, 639, 1433, 510, 11, 274, 11, 307, 264, 3890, 2144, 1433, 13, 51568], "temperature": 0.0, "avg_logprob": -0.12206376629111207, "compression_ratio": 1.6648936170212767, "no_speech_prob": 0.0005033230409026146}, {"id": 274, "seek": 139252, "start": 1392.6, "end": 1400.12, "text": " And what it's going to do is it's going to try to enforce a minimization of the divergence", "tokens": [50368, 400, 437, 309, 311, 516, 281, 360, 307, 309, 311, 516, 281, 853, 281, 24825, 257, 4464, 2144, 295, 264, 47387, 50744], "temperature": 0.0, "avg_logprob": -0.11190924861214378, "compression_ratio": 1.7129186602870814, "no_speech_prob": 0.0038242200389504433}, {"id": 275, "seek": 139252, "start": 1400.12, "end": 1406.04, "text": " or the difference between what the encoder is trying to infer, the probability distribution", "tokens": [50744, 420, 264, 2649, 1296, 437, 264, 2058, 19866, 307, 1382, 281, 13596, 11, 264, 8482, 7316, 51040], "temperature": 0.0, "avg_logprob": -0.11190924861214378, "compression_ratio": 1.7129186602870814, "no_speech_prob": 0.0038242200389504433}, {"id": 276, "seek": 139252, "start": 1406.04, "end": 1413.0, "text": " of z given x, and that prior that we're going to place on the latent variables p of z.", "tokens": [51040, 295, 710, 2212, 2031, 11, 293, 300, 4059, 300, 321, 434, 516, 281, 1081, 322, 264, 48994, 9102, 280, 295, 710, 13, 51388], "temperature": 0.0, "avg_logprob": -0.11190924861214378, "compression_ratio": 1.7129186602870814, "no_speech_prob": 0.0038242200389504433}, {"id": 277, "seek": 139252, "start": 1413.72, "end": 1420.04, "text": " And the idea here is that by imposing this regularization factor, we can try to keep the", "tokens": [51424, 400, 264, 1558, 510, 307, 300, 538, 40288, 341, 3890, 2144, 5952, 11, 321, 393, 853, 281, 1066, 264, 51740], "temperature": 0.0, "avg_logprob": -0.11190924861214378, "compression_ratio": 1.7129186602870814, "no_speech_prob": 0.0038242200389504433}, {"id": 278, "seek": 142004, "start": 1420.04, "end": 1425.6399999999999, "text": " network from overfitting on certain parts of the latent space by enforcing the fact that", "tokens": [50364, 3209, 490, 670, 69, 2414, 322, 1629, 3166, 295, 264, 48994, 1901, 538, 25495, 2175, 264, 1186, 300, 50644], "temperature": 0.0, "avg_logprob": -0.08204073129698287, "compression_ratio": 1.6607929515418502, "no_speech_prob": 0.003123427042737603}, {"id": 279, "seek": 142004, "start": 1425.6399999999999, "end": 1431.24, "text": " we want to encourage the latent variables to adopt a distribution that's similar to our prior.", "tokens": [50644, 321, 528, 281, 5373, 264, 48994, 9102, 281, 6878, 257, 7316, 300, 311, 2531, 281, 527, 4059, 13, 50924], "temperature": 0.0, "avg_logprob": -0.08204073129698287, "compression_ratio": 1.6607929515418502, "no_speech_prob": 0.003123427042737603}, {"id": 280, "seek": 142004, "start": 1431.96, "end": 1437.6399999999999, "text": " So we're going to go through now, you know, both the mathematical basis for this regularization", "tokens": [50960, 407, 321, 434, 516, 281, 352, 807, 586, 11, 291, 458, 11, 1293, 264, 18894, 5143, 337, 341, 3890, 2144, 51244], "temperature": 0.0, "avg_logprob": -0.08204073129698287, "compression_ratio": 1.6607929515418502, "no_speech_prob": 0.003123427042737603}, {"id": 281, "seek": 142004, "start": 1437.6399999999999, "end": 1444.2, "text": " term as well as a really intuitive walkthrough of what regularization achieves to help give you a", "tokens": [51244, 1433, 382, 731, 382, 257, 534, 21769, 1792, 11529, 295, 437, 3890, 2144, 3538, 977, 281, 854, 976, 291, 257, 51572], "temperature": 0.0, "avg_logprob": -0.08204073129698287, "compression_ratio": 1.6607929515418502, "no_speech_prob": 0.003123427042737603}, {"id": 282, "seek": 144420, "start": 1444.2, "end": 1449.0800000000002, "text": " concrete understanding and an intuitive understanding about why regularization is", "tokens": [50364, 9859, 3701, 293, 364, 21769, 3701, 466, 983, 3890, 2144, 307, 50608], "temperature": 0.0, "avg_logprob": -0.1081045962668754, "compression_ratio": 1.6919191919191918, "no_speech_prob": 0.000842618232127279}, {"id": 283, "seek": 144420, "start": 1449.0800000000002, "end": 1455.88, "text": " important and why placing a prior is important. So let's first consider,", "tokens": [50608, 1021, 293, 983, 17221, 257, 4059, 307, 1021, 13, 407, 718, 311, 700, 1949, 11, 50948], "temperature": 0.0, "avg_logprob": -0.1081045962668754, "compression_ratio": 1.6919191919191918, "no_speech_prob": 0.000842618232127279}, {"id": 284, "seek": 144420, "start": 1458.3600000000001, "end": 1463.32, "text": " yeah, so to re-emphasize once again, this regularization term is going to consider", "tokens": [51072, 1338, 11, 370, 281, 319, 12, 443, 7485, 1125, 1564, 797, 11, 341, 3890, 2144, 1433, 307, 516, 281, 1949, 51320], "temperature": 0.0, "avg_logprob": -0.1081045962668754, "compression_ratio": 1.6919191919191918, "no_speech_prob": 0.000842618232127279}, {"id": 285, "seek": 144420, "start": 1463.32, "end": 1468.6000000000001, "text": " the divergence between our inferred latent distribution and the fixed prior we're going to place.", "tokens": [51320, 264, 47387, 1296, 527, 13596, 986, 48994, 7316, 293, 264, 6806, 4059, 321, 434, 516, 281, 1081, 13, 51584], "temperature": 0.0, "avg_logprob": -0.1081045962668754, "compression_ratio": 1.6919191919191918, "no_speech_prob": 0.000842618232127279}, {"id": 286, "seek": 146860, "start": 1469.56, "end": 1477.48, "text": " So before we to get into this, let's consider what could be a good choice of prior for each of", "tokens": [50412, 407, 949, 321, 281, 483, 666, 341, 11, 718, 311, 1949, 437, 727, 312, 257, 665, 3922, 295, 4059, 337, 1184, 295, 50808], "temperature": 0.0, "avg_logprob": -0.13830240206284958, "compression_ratio": 1.6127659574468085, "no_speech_prob": 0.0003740894317161292}, {"id": 287, "seek": 146860, "start": 1477.48, "end": 1484.84, "text": " these latent variables. How do we select p of z? I'll first tell you what's commonly done.", "tokens": [50808, 613, 48994, 9102, 13, 1012, 360, 321, 3048, 280, 295, 710, 30, 286, 603, 700, 980, 291, 437, 311, 12719, 1096, 13, 51176], "temperature": 0.0, "avg_logprob": -0.13830240206284958, "compression_ratio": 1.6127659574468085, "no_speech_prob": 0.0003740894317161292}, {"id": 288, "seek": 146860, "start": 1485.7199999999998, "end": 1491.56, "text": " The common choice that's used very extensively in the community is to enforce the latent variables", "tokens": [51220, 440, 2689, 3922, 300, 311, 1143, 588, 32636, 294, 264, 1768, 307, 281, 24825, 264, 48994, 9102, 51512], "temperature": 0.0, "avg_logprob": -0.13830240206284958, "compression_ratio": 1.6127659574468085, "no_speech_prob": 0.0003740894317161292}, {"id": 289, "seek": 146860, "start": 1491.56, "end": 1496.6, "text": " to roughly follow normal Gaussian distributions, which means that they're going to be a normal", "tokens": [51512, 281, 9810, 1524, 2710, 39148, 37870, 11, 597, 1355, 300, 436, 434, 516, 281, 312, 257, 2710, 51764], "temperature": 0.0, "avg_logprob": -0.13830240206284958, "compression_ratio": 1.6127659574468085, "no_speech_prob": 0.0003740894317161292}, {"id": 290, "seek": 149660, "start": 1497.1599999999999, "end": 1503.32, "text": " distribution centered around mean zero and have a standard deviation and variance of one.", "tokens": [50392, 7316, 18988, 926, 914, 4018, 293, 362, 257, 3832, 25163, 293, 21977, 295, 472, 13, 50700], "temperature": 0.0, "avg_logprob": -0.07982015609741211, "compression_ratio": 1.7188940092165899, "no_speech_prob": 0.0010004418436437845}, {"id": 291, "seek": 149660, "start": 1504.6, "end": 1510.6799999999998, "text": " By placing these normal Gaussian priors on each of the latent variables and therefore on our", "tokens": [50764, 3146, 17221, 613, 2710, 39148, 1790, 830, 322, 1184, 295, 264, 48994, 9102, 293, 4412, 322, 527, 51068], "temperature": 0.0, "avg_logprob": -0.07982015609741211, "compression_ratio": 1.7188940092165899, "no_speech_prob": 0.0010004418436437845}, {"id": 292, "seek": 149660, "start": 1510.6799999999998, "end": 1516.52, "text": " latent distribution overall, what this encourages is that the learned encodings learned by the", "tokens": [51068, 48994, 7316, 4787, 11, 437, 341, 28071, 307, 300, 264, 3264, 2058, 378, 1109, 3264, 538, 264, 51360], "temperature": 0.0, "avg_logprob": -0.07982015609741211, "compression_ratio": 1.7188940092165899, "no_speech_prob": 0.0010004418436437845}, {"id": 293, "seek": 149660, "start": 1516.52, "end": 1523.3999999999999, "text": " encoder portion of our VAE are going to be sort of distributed evenly around the center of each", "tokens": [51360, 2058, 19866, 8044, 295, 527, 18527, 36, 366, 516, 281, 312, 1333, 295, 12631, 17658, 926, 264, 3056, 295, 1184, 51704], "temperature": 0.0, "avg_logprob": -0.07982015609741211, "compression_ratio": 1.7188940092165899, "no_speech_prob": 0.0010004418436437845}, {"id": 294, "seek": 152340, "start": 1523.4, "end": 1530.76, "text": " of the latent variables. And if you can imagine and picture when you have sort of a roughly even", "tokens": [50364, 295, 264, 48994, 9102, 13, 400, 498, 291, 393, 3811, 293, 3036, 562, 291, 362, 1333, 295, 257, 9810, 754, 50732], "temperature": 0.0, "avg_logprob": -0.062484423319498696, "compression_ratio": 1.7130044843049328, "no_speech_prob": 0.0017005768604576588}, {"id": 295, "seek": 152340, "start": 1530.76, "end": 1537.4, "text": " distribution around the center of a particular region of the latent space, what this means is", "tokens": [50732, 7316, 926, 264, 3056, 295, 257, 1729, 4458, 295, 264, 48994, 1901, 11, 437, 341, 1355, 307, 51064], "temperature": 0.0, "avg_logprob": -0.062484423319498696, "compression_ratio": 1.7130044843049328, "no_speech_prob": 0.0017005768604576588}, {"id": 296, "seek": 152340, "start": 1537.4, "end": 1543.8000000000002, "text": " that outside of this region, far away, there's going to be a greater penalty and this can result", "tokens": [51064, 300, 2380, 295, 341, 4458, 11, 1400, 1314, 11, 456, 311, 516, 281, 312, 257, 5044, 16263, 293, 341, 393, 1874, 51384], "temperature": 0.0, "avg_logprob": -0.062484423319498696, "compression_ratio": 1.7130044843049328, "no_speech_prob": 0.0017005768604576588}, {"id": 297, "seek": 152340, "start": 1543.8000000000002, "end": 1550.3600000000001, "text": " in instances from instances where the network is trying to cheat and try to cluster particular", "tokens": [51384, 294, 14519, 490, 14519, 689, 264, 3209, 307, 1382, 281, 17470, 293, 853, 281, 13630, 1729, 51712], "temperature": 0.0, "avg_logprob": -0.062484423319498696, "compression_ratio": 1.7130044843049328, "no_speech_prob": 0.0017005768604576588}, {"id": 298, "seek": 155036, "start": 1550.36, "end": 1556.1999999999998, "text": " points outside the center, these centers in the latent space, like if it was trying to memorize", "tokens": [50364, 2793, 2380, 264, 3056, 11, 613, 10898, 294, 264, 48994, 1901, 11, 411, 498, 309, 390, 1382, 281, 27478, 50656], "temperature": 0.0, "avg_logprob": -0.05989000963610272, "compression_ratio": 1.6422413793103448, "no_speech_prob": 0.00040446975617669523}, {"id": 299, "seek": 155036, "start": 1556.1999999999998, "end": 1563.1599999999999, "text": " particular outliers or edge cases in the data. After we place a normal Gaussian prior on our", "tokens": [50656, 1729, 484, 23646, 420, 4691, 3331, 294, 264, 1412, 13, 2381, 321, 1081, 257, 2710, 39148, 4059, 322, 527, 51004], "temperature": 0.0, "avg_logprob": -0.05989000963610272, "compression_ratio": 1.6422413793103448, "no_speech_prob": 0.00040446975617669523}, {"id": 300, "seek": 155036, "start": 1563.1599999999999, "end": 1570.12, "text": " latent variables, we can now begin to concretely define the regularization term component of our", "tokens": [51004, 48994, 9102, 11, 321, 393, 586, 1841, 281, 39481, 736, 6964, 264, 3890, 2144, 1433, 6542, 295, 527, 51352], "temperature": 0.0, "avg_logprob": -0.05989000963610272, "compression_ratio": 1.6422413793103448, "no_speech_prob": 0.00040446975617669523}, {"id": 301, "seek": 155036, "start": 1570.12, "end": 1577.1599999999999, "text": " loss function. This loss, this term to the loss is very similar in principle to a cross entropy", "tokens": [51352, 4470, 2445, 13, 639, 4470, 11, 341, 1433, 281, 264, 4470, 307, 588, 2531, 294, 8665, 281, 257, 3278, 30867, 51704], "temperature": 0.0, "avg_logprob": -0.05989000963610272, "compression_ratio": 1.6422413793103448, "no_speech_prob": 0.00040446975617669523}, {"id": 302, "seek": 157716, "start": 1577.16, "end": 1584.3600000000001, "text": " loss that we saw before, where the key is that we're going to be defining the distance function", "tokens": [50364, 4470, 300, 321, 1866, 949, 11, 689, 264, 2141, 307, 300, 321, 434, 516, 281, 312, 17827, 264, 4560, 2445, 50724], "temperature": 0.0, "avg_logprob": -0.09512549727710325, "compression_ratio": 1.6927710843373494, "no_speech_prob": 0.0012065540067851543}, {"id": 303, "seek": 157716, "start": 1584.3600000000001, "end": 1591.72, "text": " that describes the difference or the divergence between the inferred latent distribution q,", "tokens": [50724, 300, 15626, 264, 2649, 420, 264, 47387, 1296, 264, 13596, 986, 48994, 7316, 9505, 11, 51092], "temperature": 0.0, "avg_logprob": -0.09512549727710325, "compression_ratio": 1.6927710843373494, "no_speech_prob": 0.0012065540067851543}, {"id": 304, "seek": 157716, "start": 1591.72, "end": 1598.6000000000001, "text": " phi of z given x and the prior that we're going to be placing p of z. And this term is called", "tokens": [51092, 13107, 295, 710, 2212, 2031, 293, 264, 4059, 300, 321, 434, 516, 281, 312, 17221, 280, 295, 710, 13, 400, 341, 1433, 307, 1219, 51436], "temperature": 0.0, "avg_logprob": -0.09512549727710325, "compression_ratio": 1.6927710843373494, "no_speech_prob": 0.0012065540067851543}, {"id": 305, "seek": 159860, "start": 1598.6, "end": 1604.52, "text": " the Kublack-Liebler or KL divergence. And when we choose a normal Gaussian prior,", "tokens": [50364, 264, 35805, 75, 501, 12, 43, 414, 65, 1918, 420, 47991, 47387, 13, 400, 562, 321, 2826, 257, 2710, 39148, 4059, 11, 50660], "temperature": 0.0, "avg_logprob": -0.13001168966293336, "compression_ratio": 1.6572769953051643, "no_speech_prob": 0.0053846887312829494}, {"id": 306, "seek": 159860, "start": 1605.8, "end": 1612.9199999999998, "text": " we, this results in the KL divergence taking this particular form of this equation here,", "tokens": [50724, 321, 11, 341, 3542, 294, 264, 47991, 47387, 1940, 341, 1729, 1254, 295, 341, 5367, 510, 11, 51080], "temperature": 0.0, "avg_logprob": -0.13001168966293336, "compression_ratio": 1.6572769953051643, "no_speech_prob": 0.0053846887312829494}, {"id": 307, "seek": 159860, "start": 1612.9199999999998, "end": 1619.24, "text": " where we're using the means and sigmas as input and computing this distance metric that captures", "tokens": [51080, 689, 321, 434, 1228, 264, 1355, 293, 4556, 3799, 382, 4846, 293, 15866, 341, 4560, 20678, 300, 27986, 51396], "temperature": 0.0, "avg_logprob": -0.13001168966293336, "compression_ratio": 1.6572769953051643, "no_speech_prob": 0.0053846887312829494}, {"id": 308, "seek": 159860, "start": 1619.24, "end": 1624.6799999999998, "text": " the divergence of that learned latent variable distribution from the normal Gaussian.", "tokens": [51396, 264, 47387, 295, 300, 3264, 48994, 7006, 7316, 490, 264, 2710, 39148, 13, 51668], "temperature": 0.0, "avg_logprob": -0.13001168966293336, "compression_ratio": 1.6572769953051643, "no_speech_prob": 0.0053846887312829494}, {"id": 309, "seek": 162468, "start": 1625.3200000000002, "end": 1631.16, "text": " All right. So now I really want to spend a bit of time to get some, build up some intuition about", "tokens": [50396, 1057, 558, 13, 407, 586, 286, 534, 528, 281, 3496, 257, 857, 295, 565, 281, 483, 512, 11, 1322, 493, 512, 24002, 466, 50688], "temperature": 0.0, "avg_logprob": -0.18910964330037436, "compression_ratio": 1.722466960352423, "no_speech_prob": 0.0035934054758399725}, {"id": 310, "seek": 162468, "start": 1631.16, "end": 1638.68, "text": " how this regularization and works and why we actually want to regularize our VAE and then also", "tokens": [50688, 577, 341, 3890, 2144, 293, 1985, 293, 983, 321, 767, 528, 281, 3890, 1125, 527, 18527, 36, 293, 550, 611, 51064], "temperature": 0.0, "avg_logprob": -0.18910964330037436, "compression_ratio": 1.722466960352423, "no_speech_prob": 0.0035934054758399725}, {"id": 311, "seek": 162468, "start": 1638.68, "end": 1645.48, "text": " why we select a normal prior. All right. So to do this, let's, let's consider the following question.", "tokens": [51064, 983, 321, 3048, 257, 2710, 4059, 13, 1057, 558, 13, 407, 281, 360, 341, 11, 718, 311, 11, 718, 311, 1949, 264, 3480, 1168, 13, 51404], "temperature": 0.0, "avg_logprob": -0.18910964330037436, "compression_ratio": 1.722466960352423, "no_speech_prob": 0.0035934054758399725}, {"id": 312, "seek": 162468, "start": 1645.48, "end": 1652.04, "text": " What properties do we want this to achieve from regularization? Why are we actually regularizing", "tokens": [51404, 708, 7221, 360, 321, 528, 341, 281, 4584, 490, 3890, 2144, 30, 1545, 366, 321, 767, 3890, 3319, 51732], "temperature": 0.0, "avg_logprob": -0.18910964330037436, "compression_ratio": 1.722466960352423, "no_speech_prob": 0.0035934054758399725}, {"id": 313, "seek": 165204, "start": 1652.76, "end": 1660.68, "text": " our, our network in the first place? The first key property that we want for a generative model like", "tokens": [50400, 527, 11, 527, 3209, 294, 264, 700, 1081, 30, 440, 700, 2141, 4707, 300, 321, 528, 337, 257, 1337, 1166, 2316, 411, 50796], "temperature": 0.0, "avg_logprob": -0.12731686067045406, "compression_ratio": 1.6382978723404256, "no_speech_prob": 0.00039202519110403955}, {"id": 314, "seek": 165204, "start": 1660.68, "end": 1667.48, "text": " a VAE is what I can, what I like to think of as continuity, which means that if there are points", "tokens": [50796, 257, 18527, 36, 307, 437, 286, 393, 11, 437, 286, 411, 281, 519, 295, 382, 23807, 11, 597, 1355, 300, 498, 456, 366, 2793, 51136], "temperature": 0.0, "avg_logprob": -0.12731686067045406, "compression_ratio": 1.6382978723404256, "no_speech_prob": 0.00039202519110403955}, {"id": 315, "seek": 165204, "start": 1667.48, "end": 1673.1599999999999, "text": " that are represented closely in the latent space, they should also result in similar", "tokens": [51136, 300, 366, 10379, 8185, 294, 264, 48994, 1901, 11, 436, 820, 611, 1874, 294, 2531, 51420], "temperature": 0.0, "avg_logprob": -0.12731686067045406, "compression_ratio": 1.6382978723404256, "no_speech_prob": 0.00039202519110403955}, {"id": 316, "seek": 165204, "start": 1673.8, "end": 1680.76, "text": " reconstructions, similar outputs, similar content after they are decoded. You would expect intuitively", "tokens": [51452, 31499, 626, 11, 2531, 23930, 11, 2531, 2701, 934, 436, 366, 979, 12340, 13, 509, 576, 2066, 46506, 51800], "temperature": 0.0, "avg_logprob": -0.12731686067045406, "compression_ratio": 1.6382978723404256, "no_speech_prob": 0.00039202519110403955}, {"id": 317, "seek": 168076, "start": 1680.76, "end": 1687.0, "text": " that regions in the latent space have some notion of distance or similarity to each other. And this", "tokens": [50364, 300, 10682, 294, 264, 48994, 1901, 362, 512, 10710, 295, 4560, 420, 32194, 281, 1184, 661, 13, 400, 341, 50676], "temperature": 0.0, "avg_logprob": -0.06277448631996332, "compression_ratio": 1.7053571428571428, "no_speech_prob": 0.00010889535042224452}, {"id": 318, "seek": 168076, "start": 1687.0, "end": 1693.08, "text": " indeed is a really key property that we want to achieve with our generative model. The second", "tokens": [50676, 6451, 307, 257, 534, 2141, 4707, 300, 321, 528, 281, 4584, 365, 527, 1337, 1166, 2316, 13, 440, 1150, 50980], "temperature": 0.0, "avg_logprob": -0.06277448631996332, "compression_ratio": 1.7053571428571428, "no_speech_prob": 0.00010889535042224452}, {"id": 319, "seek": 168076, "start": 1693.08, "end": 1700.04, "text": " property is completeness and it's very related to continuity. And what this means is that when", "tokens": [50980, 4707, 307, 1557, 15264, 293, 309, 311, 588, 4077, 281, 23807, 13, 400, 437, 341, 1355, 307, 300, 562, 51328], "temperature": 0.0, "avg_logprob": -0.06277448631996332, "compression_ratio": 1.7053571428571428, "no_speech_prob": 0.00010889535042224452}, {"id": 320, "seek": 168076, "start": 1700.04, "end": 1707.64, "text": " we sample from the latent space to decode the latent space into an output, that should result", "tokens": [51328, 321, 6889, 490, 264, 48994, 1901, 281, 979, 1429, 264, 48994, 1901, 666, 364, 5598, 11, 300, 820, 1874, 51708], "temperature": 0.0, "avg_logprob": -0.06277448631996332, "compression_ratio": 1.7053571428571428, "no_speech_prob": 0.00010889535042224452}, {"id": 321, "seek": 170764, "start": 1707.64, "end": 1714.44, "text": " in a meaningful reconstruction, a meaningful, uh, sampled content that is, you know, resembling", "tokens": [50364, 294, 257, 10995, 31565, 11, 257, 10995, 11, 2232, 11, 3247, 15551, 2701, 300, 307, 11, 291, 458, 11, 20695, 1688, 50704], "temperature": 0.0, "avg_logprob": -0.056305285250202994, "compression_ratio": 1.5933609958506223, "no_speech_prob": 0.0007096495246514678}, {"id": 322, "seek": 170764, "start": 1714.44, "end": 1720.92, "text": " the original data distribution. You can imagine that if we're sampling from the latent space and", "tokens": [50704, 264, 3380, 1412, 7316, 13, 509, 393, 3811, 300, 498, 321, 434, 21179, 490, 264, 48994, 1901, 293, 51028], "temperature": 0.0, "avg_logprob": -0.056305285250202994, "compression_ratio": 1.5933609958506223, "no_speech_prob": 0.0007096495246514678}, {"id": 323, "seek": 170764, "start": 1720.92, "end": 1727.72, "text": " just getting garbage out that has no relationship to our input, this could be a huge, huge problem", "tokens": [51028, 445, 1242, 14150, 484, 300, 575, 572, 2480, 281, 527, 4846, 11, 341, 727, 312, 257, 2603, 11, 2603, 1154, 51368], "temperature": 0.0, "avg_logprob": -0.056305285250202994, "compression_ratio": 1.5933609958506223, "no_speech_prob": 0.0007096495246514678}, {"id": 324, "seek": 170764, "start": 1727.72, "end": 1734.1200000000001, "text": " for our model. All right. So with these two properties in mind, continuity and completeness,", "tokens": [51368, 337, 527, 2316, 13, 1057, 558, 13, 407, 365, 613, 732, 7221, 294, 1575, 11, 23807, 293, 1557, 15264, 11, 51688], "temperature": 0.0, "avg_logprob": -0.056305285250202994, "compression_ratio": 1.5933609958506223, "no_speech_prob": 0.0007096495246514678}, {"id": 325, "seek": 173412, "start": 1734.84, "end": 1740.4399999999998, "text": " let's consider the consequences of what can occur if we do not regularize our model.", "tokens": [50400, 718, 311, 1949, 264, 10098, 295, 437, 393, 5160, 498, 321, 360, 406, 3890, 1125, 527, 2316, 13, 50680], "temperature": 0.0, "avg_logprob": -0.05086129307746887, "compression_ratio": 1.6238938053097345, "no_speech_prob": 0.00033014517975971103}, {"id": 326, "seek": 173412, "start": 1742.04, "end": 1747.7199999999998, "text": " Well, without regularization, what could end up happening with respect to these two properties", "tokens": [50760, 1042, 11, 1553, 3890, 2144, 11, 437, 727, 917, 493, 2737, 365, 3104, 281, 613, 732, 7221, 51044], "temperature": 0.0, "avg_logprob": -0.05086129307746887, "compression_ratio": 1.6238938053097345, "no_speech_prob": 0.00033014517975971103}, {"id": 327, "seek": 173412, "start": 1747.7199999999998, "end": 1754.04, "text": " is that there could be instances of points that are close in latent space, but not similarly", "tokens": [51044, 307, 300, 456, 727, 312, 14519, 295, 2793, 300, 366, 1998, 294, 48994, 1901, 11, 457, 406, 14138, 51360], "temperature": 0.0, "avg_logprob": -0.05086129307746887, "compression_ratio": 1.6238938053097345, "no_speech_prob": 0.00033014517975971103}, {"id": 328, "seek": 173412, "start": 1754.04, "end": 1761.1599999999999, "text": " decoded. So I'm using this really intuitive illustration where these dots represent abstracted", "tokens": [51360, 979, 12340, 13, 407, 286, 478, 1228, 341, 534, 21769, 22645, 689, 613, 15026, 2906, 12649, 292, 51716], "temperature": 0.0, "avg_logprob": -0.05086129307746887, "compression_ratio": 1.6238938053097345, "no_speech_prob": 0.00033014517975971103}, {"id": 329, "seek": 176116, "start": 1761.16, "end": 1767.88, "text": " away sort of regions in the latent space. And the shapes that they relate to, you can think of as", "tokens": [50364, 1314, 1333, 295, 10682, 294, 264, 48994, 1901, 13, 400, 264, 10854, 300, 436, 10961, 281, 11, 291, 393, 519, 295, 382, 50700], "temperature": 0.0, "avg_logprob": -0.0703047513961792, "compression_ratio": 1.7428571428571429, "no_speech_prob": 0.0008830250590108335}, {"id": 330, "seek": 176116, "start": 1767.88, "end": 1774.44, "text": " what is going to be decoded after those instances in the latent space are passed through the decoder.", "tokens": [50700, 437, 307, 516, 281, 312, 979, 12340, 934, 729, 14519, 294, 264, 48994, 1901, 366, 4678, 807, 264, 979, 19866, 13, 51028], "temperature": 0.0, "avg_logprob": -0.0703047513961792, "compression_ratio": 1.7428571428571429, "no_speech_prob": 0.0008830250590108335}, {"id": 331, "seek": 176116, "start": 1775.3200000000002, "end": 1781.16, "text": " So in this example, we have these two dots, the greenish dot and the reddish dot,", "tokens": [51072, 407, 294, 341, 1365, 11, 321, 362, 613, 732, 15026, 11, 264, 3092, 742, 5893, 293, 264, 2182, 40974, 5893, 11, 51364], "temperature": 0.0, "avg_logprob": -0.0703047513961792, "compression_ratio": 1.7428571428571429, "no_speech_prob": 0.0008830250590108335}, {"id": 332, "seek": 176116, "start": 1781.16, "end": 1785.72, "text": " that are physically close in latent space, but result in completely different shapes", "tokens": [51364, 300, 366, 9762, 1998, 294, 48994, 1901, 11, 457, 1874, 294, 2584, 819, 10854, 51592], "temperature": 0.0, "avg_logprob": -0.0703047513961792, "compression_ratio": 1.7428571428571429, "no_speech_prob": 0.0008830250590108335}, {"id": 333, "seek": 178572, "start": 1785.8, "end": 1792.68, "text": " when they're decoded. We also have an instance of this purple point, which when it's decoded,", "tokens": [50368, 562, 436, 434, 979, 12340, 13, 492, 611, 362, 364, 5197, 295, 341, 9656, 935, 11, 597, 562, 309, 311, 979, 12340, 11, 50712], "temperature": 0.0, "avg_logprob": -0.06591307256639618, "compression_ratio": 1.6163793103448276, "no_speech_prob": 0.0024724570102989674}, {"id": 334, "seek": 178572, "start": 1792.68, "end": 1799.56, "text": " it doesn't result in a meaningful content. It's just a scribble. So by not regularizing,", "tokens": [50712, 309, 1177, 380, 1874, 294, 257, 10995, 2701, 13, 467, 311, 445, 257, 39435, 638, 13, 407, 538, 406, 3890, 3319, 11, 51056], "temperature": 0.0, "avg_logprob": -0.06591307256639618, "compression_ratio": 1.6163793103448276, "no_speech_prob": 0.0024724570102989674}, {"id": 335, "seek": 178572, "start": 1799.56, "end": 1805.8, "text": " and I'm abstracting a lot away here, and that's on purpose, we could have these instances where", "tokens": [51056, 293, 286, 478, 12649, 278, 257, 688, 1314, 510, 11, 293, 300, 311, 322, 4334, 11, 321, 727, 362, 613, 14519, 689, 51368], "temperature": 0.0, "avg_logprob": -0.06591307256639618, "compression_ratio": 1.6163793103448276, "no_speech_prob": 0.0024724570102989674}, {"id": 336, "seek": 178572, "start": 1805.8, "end": 1812.44, "text": " we don't have continuity and we don't have completeness. Therefore, our goal with regularization", "tokens": [51368, 321, 500, 380, 362, 23807, 293, 321, 500, 380, 362, 1557, 15264, 13, 7504, 11, 527, 3387, 365, 3890, 2144, 51700], "temperature": 0.0, "avg_logprob": -0.06591307256639618, "compression_ratio": 1.6163793103448276, "no_speech_prob": 0.0024724570102989674}, {"id": 337, "seek": 181244, "start": 1812.44, "end": 1819.64, "text": " is to be able to realize a model where points that are close in the latent space are not only", "tokens": [50364, 307, 281, 312, 1075, 281, 4325, 257, 2316, 689, 2793, 300, 366, 1998, 294, 264, 48994, 1901, 366, 406, 787, 50724], "temperature": 0.0, "avg_logprob": -0.0742717418041858, "compression_ratio": 1.6608695652173913, "no_speech_prob": 0.00023049938317853957}, {"id": 338, "seek": 181244, "start": 1819.64, "end": 1825.4, "text": " similarly decoded, but also meaningfully decoded. So for example, here, we have the red dot and the", "tokens": [50724, 14138, 979, 12340, 11, 457, 611, 3620, 2277, 979, 12340, 13, 407, 337, 1365, 11, 510, 11, 321, 362, 264, 2182, 5893, 293, 264, 51012], "temperature": 0.0, "avg_logprob": -0.0742717418041858, "compression_ratio": 1.6608695652173913, "no_speech_prob": 0.00023049938317853957}, {"id": 339, "seek": 181244, "start": 1825.4, "end": 1831.72, "text": " orange dot, which result in both triangle-like shapes, but with slight variations on the on the", "tokens": [51012, 7671, 5893, 11, 597, 1874, 294, 1293, 13369, 12, 4092, 10854, 11, 457, 365, 4036, 17840, 322, 264, 322, 264, 51328], "temperature": 0.0, "avg_logprob": -0.0742717418041858, "compression_ratio": 1.6608695652173913, "no_speech_prob": 0.00023049938317853957}, {"id": 340, "seek": 181244, "start": 1831.72, "end": 1838.52, "text": " triangle itself. So this is the intuition about what regularization can enable us to achieve", "tokens": [51328, 13369, 2564, 13, 407, 341, 307, 264, 24002, 466, 437, 3890, 2144, 393, 9528, 505, 281, 4584, 51668], "temperature": 0.0, "avg_logprob": -0.0742717418041858, "compression_ratio": 1.6608695652173913, "no_speech_prob": 0.00023049938317853957}, {"id": 341, "seek": 183852, "start": 1838.52, "end": 1845.8, "text": " and what are desired properties for these generative models. Okay, how can we actually", "tokens": [50364, 293, 437, 366, 14721, 7221, 337, 613, 1337, 1166, 5245, 13, 1033, 11, 577, 393, 321, 767, 50728], "temperature": 0.0, "avg_logprob": -0.11522967239906048, "compression_ratio": 1.487603305785124, "no_speech_prob": 0.0005357656045816839}, {"id": 342, "seek": 183852, "start": 1845.8, "end": 1853.0, "text": " achieve this regularization? And how does the normal prior fit in? As I mentioned, right,", "tokens": [50728, 4584, 341, 3890, 2144, 30, 400, 577, 775, 264, 2710, 4059, 3318, 294, 30, 1018, 286, 2835, 11, 558, 11, 51088], "temperature": 0.0, "avg_logprob": -0.11522967239906048, "compression_ratio": 1.487603305785124, "no_speech_prob": 0.0005357656045816839}, {"id": 343, "seek": 183852, "start": 1853.0, "end": 1859.8, "text": " VAEs, they don't just learn the latent variable Z directly. They're trying to encode the inputs", "tokens": [51088, 18527, 20442, 11, 436, 500, 380, 445, 1466, 264, 48994, 7006, 1176, 3838, 13, 814, 434, 1382, 281, 2058, 1429, 264, 15743, 51428], "temperature": 0.0, "avg_logprob": -0.11522967239906048, "compression_ratio": 1.487603305785124, "no_speech_prob": 0.0005357656045816839}, {"id": 344, "seek": 183852, "start": 1859.8, "end": 1865.4, "text": " as distributions that are defined by mean and variance. So my first question to you is,", "tokens": [51428, 382, 37870, 300, 366, 7642, 538, 914, 293, 21977, 13, 407, 452, 700, 1168, 281, 291, 307, 11, 51708], "temperature": 0.0, "avg_logprob": -0.11522967239906048, "compression_ratio": 1.487603305785124, "no_speech_prob": 0.0005357656045816839}, {"id": 345, "seek": 186540, "start": 1865.4, "end": 1870.2, "text": " is it going to be sufficient to just learn mean and variance, learn these distributions?", "tokens": [50364, 307, 309, 516, 281, 312, 11563, 281, 445, 1466, 914, 293, 21977, 11, 1466, 613, 37870, 30, 50604], "temperature": 0.0, "avg_logprob": -0.10154674111343012, "compression_ratio": 1.5401785714285714, "no_speech_prob": 0.00011591798829613253}, {"id": 346, "seek": 186540, "start": 1870.92, "end": 1877.4, "text": " Can that guarantee continuity and completeness? No, and let's understand why.", "tokens": [50640, 1664, 300, 10815, 23807, 293, 1557, 15264, 30, 883, 11, 293, 718, 311, 1223, 983, 13, 50964], "temperature": 0.0, "avg_logprob": -0.10154674111343012, "compression_ratio": 1.5401785714285714, "no_speech_prob": 0.00011591798829613253}, {"id": 347, "seek": 186540, "start": 1879.24, "end": 1885.72, "text": " All right, without any sort of regularization, what could the model try to resort to?", "tokens": [51056, 1057, 558, 11, 1553, 604, 1333, 295, 3890, 2144, 11, 437, 727, 264, 2316, 853, 281, 19606, 281, 30, 51380], "temperature": 0.0, "avg_logprob": -0.10154674111343012, "compression_ratio": 1.5401785714285714, "no_speech_prob": 0.00011591798829613253}, {"id": 348, "seek": 186540, "start": 1887.0, "end": 1894.6000000000001, "text": " Remember that the VAE or that the VAE, the loss function is defined by both a reconstruction", "tokens": [51444, 5459, 300, 264, 18527, 36, 420, 300, 264, 18527, 36, 11, 264, 4470, 2445, 307, 7642, 538, 1293, 257, 31565, 51824], "temperature": 0.0, "avg_logprob": -0.10154674111343012, "compression_ratio": 1.5401785714285714, "no_speech_prob": 0.00011591798829613253}, {"id": 349, "seek": 189460, "start": 1894.6, "end": 1900.52, "text": " term and a regularization term. If there is no regularization, you can bet that the model", "tokens": [50364, 1433, 293, 257, 3890, 2144, 1433, 13, 759, 456, 307, 572, 3890, 2144, 11, 291, 393, 778, 300, 264, 2316, 50660], "temperature": 0.0, "avg_logprob": -0.0606889035328325, "compression_ratio": 1.75, "no_speech_prob": 0.00015843399160075933}, {"id": 350, "seek": 189460, "start": 1900.52, "end": 1906.28, "text": " is going to just try to optimize that reconstruction term. So it's effectively going to learn to", "tokens": [50660, 307, 516, 281, 445, 853, 281, 19719, 300, 31565, 1433, 13, 407, 309, 311, 8659, 516, 281, 1466, 281, 50948], "temperature": 0.0, "avg_logprob": -0.0606889035328325, "compression_ratio": 1.75, "no_speech_prob": 0.00015843399160075933}, {"id": 351, "seek": 189460, "start": 1906.28, "end": 1912.9199999999998, "text": " minimize the reconstruction loss, even though we're encoding the latent variables via mean and variance.", "tokens": [50948, 17522, 264, 31565, 4470, 11, 754, 1673, 321, 434, 43430, 264, 48994, 9102, 5766, 914, 293, 21977, 13, 51280], "temperature": 0.0, "avg_logprob": -0.0606889035328325, "compression_ratio": 1.75, "no_speech_prob": 0.00015843399160075933}, {"id": 352, "seek": 189460, "start": 1914.36, "end": 1921.24, "text": " And two instances, two consequences of that is that you can have instances where these", "tokens": [51352, 400, 732, 14519, 11, 732, 10098, 295, 300, 307, 300, 291, 393, 362, 14519, 689, 613, 51696], "temperature": 0.0, "avg_logprob": -0.0606889035328325, "compression_ratio": 1.75, "no_speech_prob": 0.00015843399160075933}, {"id": 353, "seek": 192124, "start": 1921.24, "end": 1925.96, "text": " learned variances for the latent variable end up being very, very, very small,", "tokens": [50364, 3264, 1374, 21518, 337, 264, 48994, 7006, 917, 493, 885, 588, 11, 588, 11, 588, 1359, 11, 50600], "temperature": 0.0, "avg_logprob": -0.0814296746555763, "compression_ratio": 1.6238938053097345, "no_speech_prob": 0.00017952542111743242}, {"id": 354, "seek": 192124, "start": 1926.52, "end": 1932.28, "text": " effectively resulting in pointed distributions. And you can also have means that are totally", "tokens": [50628, 8659, 16505, 294, 10932, 37870, 13, 400, 291, 393, 611, 362, 1355, 300, 366, 3879, 50916], "temperature": 0.0, "avg_logprob": -0.0814296746555763, "compression_ratio": 1.6238938053097345, "no_speech_prob": 0.00017952542111743242}, {"id": 355, "seek": 192124, "start": 1932.28, "end": 1937.4, "text": " divergent from each other, which result in discontinuities in the latent space. And this can", "tokens": [50916, 18558, 6930, 490, 1184, 661, 11, 597, 1874, 294, 31420, 84, 1088, 294, 264, 48994, 1901, 13, 400, 341, 393, 51172], "temperature": 0.0, "avg_logprob": -0.0814296746555763, "compression_ratio": 1.6238938053097345, "no_speech_prob": 0.00017952542111743242}, {"id": 356, "seek": 192124, "start": 1937.4, "end": 1945.24, "text": " occur while still trying to optimize that reconstruction loss, direct consequence of not regularizing.", "tokens": [51172, 5160, 1339, 920, 1382, 281, 19719, 300, 31565, 4470, 11, 2047, 18326, 295, 406, 3890, 3319, 13, 51564], "temperature": 0.0, "avg_logprob": -0.0814296746555763, "compression_ratio": 1.6238938053097345, "no_speech_prob": 0.00017952542111743242}, {"id": 357, "seek": 194524, "start": 1945.32, "end": 1952.1200000000001, "text": " By, in order to overcome these problems, we need to regularize the variance and the mean of these", "tokens": [50368, 3146, 11, 294, 1668, 281, 10473, 613, 2740, 11, 321, 643, 281, 3890, 1125, 264, 21977, 293, 264, 914, 295, 613, 50708], "temperature": 0.0, "avg_logprob": -0.1732571840286255, "compression_ratio": 1.7155963302752293, "no_speech_prob": 0.00045830075396224856}, {"id": 358, "seek": 194524, "start": 1952.1200000000001, "end": 1957.72, "text": " distributions that are being returned by the encoder. And the normal prior, placing that", "tokens": [50708, 37870, 300, 366, 885, 8752, 538, 264, 2058, 19866, 13, 400, 264, 2710, 4059, 11, 17221, 300, 50988], "temperature": 0.0, "avg_logprob": -0.1732571840286255, "compression_ratio": 1.7155963302752293, "no_speech_prob": 0.00045830075396224856}, {"id": 359, "seek": 194524, "start": 1957.72, "end": 1965.56, "text": " normal Gaussian distribution as our prior helps us achieve this. And to understand why exactly", "tokens": [50988, 2710, 39148, 7316, 382, 527, 4059, 3665, 505, 4584, 341, 13, 400, 281, 1223, 983, 2293, 51380], "temperature": 0.0, "avg_logprob": -0.1732571840286255, "compression_ratio": 1.7155963302752293, "no_speech_prob": 0.00045830075396224856}, {"id": 360, "seek": 194524, "start": 1965.56, "end": 1971.56, "text": " this occurs, is that effectively the normal prior is going to encourage these learned latent", "tokens": [51380, 341, 11843, 11, 307, 300, 8659, 264, 2710, 4059, 307, 516, 281, 5373, 613, 3264, 48994, 51680], "temperature": 0.0, "avg_logprob": -0.1732571840286255, "compression_ratio": 1.7155963302752293, "no_speech_prob": 0.00045830075396224856}, {"id": 361, "seek": 197156, "start": 1971.56, "end": 1978.84, "text": " variable distributions to overlap in latent space. Recall, right? Mean zero, variance of one. That", "tokens": [50364, 7006, 37870, 281, 19959, 294, 48994, 1901, 13, 9647, 336, 11, 558, 30, 12302, 4018, 11, 21977, 295, 472, 13, 663, 50728], "temperature": 0.0, "avg_logprob": -0.19431684350454678, "compression_ratio": 1.8262910798122065, "no_speech_prob": 0.007231967523694038}, {"id": 362, "seek": 197156, "start": 1978.84, "end": 1984.76, "text": " means all the, all the latent variables are going to be enforced to try to have the same mean, a", "tokens": [50728, 1355, 439, 264, 11, 439, 264, 48994, 9102, 366, 516, 281, 312, 40953, 281, 853, 281, 362, 264, 912, 914, 11, 257, 51024], "temperature": 0.0, "avg_logprob": -0.19431684350454678, "compression_ratio": 1.8262910798122065, "no_speech_prob": 0.007231967523694038}, {"id": 363, "seek": 197156, "start": 1984.76, "end": 1990.12, "text": " centered mean, and all the variances are going to be regularized for each and every of the latent", "tokens": [51024, 18988, 914, 11, 293, 439, 264, 1374, 21518, 366, 516, 281, 312, 3890, 1602, 337, 1184, 293, 633, 295, 264, 48994, 51292], "temperature": 0.0, "avg_logprob": -0.19431684350454678, "compression_ratio": 1.8262910798122065, "no_speech_prob": 0.007231967523694038}, {"id": 364, "seek": 197156, "start": 1990.12, "end": 1996.28, "text": " variable distributions. And so this will ensure a smoothness and a regularity and an overlap in", "tokens": [51292, 7006, 37870, 13, 400, 370, 341, 486, 5586, 257, 5508, 1287, 293, 257, 3890, 507, 293, 364, 19959, 294, 51600], "temperature": 0.0, "avg_logprob": -0.19431684350454678, "compression_ratio": 1.8262910798122065, "no_speech_prob": 0.007231967523694038}, {"id": 365, "seek": 199628, "start": 1996.28, "end": 2003.0, "text": " the latent space, which will be very effective in helping us achieve these properties of continuity", "tokens": [50364, 264, 48994, 1901, 11, 597, 486, 312, 588, 4942, 294, 4315, 505, 4584, 613, 7221, 295, 23807, 50700], "temperature": 0.0, "avg_logprob": -0.2181296642915702, "compression_ratio": 1.7547169811320755, "no_speech_prob": 0.0002611844683997333}, {"id": 366, "seek": 199628, "start": 2003.0, "end": 2012.2, "text": " and completeness. Centering the means, regularizing the variances. So the regularization via this", "tokens": [50700, 293, 1557, 15264, 13, 3408, 1794, 264, 1355, 11, 3890, 3319, 264, 1374, 21518, 13, 407, 264, 3890, 2144, 5766, 341, 51160], "temperature": 0.0, "avg_logprob": -0.2181296642915702, "compression_ratio": 1.7547169811320755, "no_speech_prob": 0.0002611844683997333}, {"id": 367, "seek": 199628, "start": 2012.2, "end": 2019.24, "text": " normal prior, by centering each of these latent variables, regularizing their, their variances,", "tokens": [51160, 2710, 4059, 11, 538, 1489, 1794, 1184, 295, 613, 48994, 9102, 11, 3890, 3319, 641, 11, 641, 1374, 21518, 11, 51512], "temperature": 0.0, "avg_logprob": -0.2181296642915702, "compression_ratio": 1.7547169811320755, "no_speech_prob": 0.0002611844683997333}, {"id": 368, "seek": 199628, "start": 2019.24, "end": 2024.36, "text": " is that it helps enforce this continuous and complete gradient of information.", "tokens": [51512, 307, 300, 309, 3665, 24825, 341, 10957, 293, 3566, 16235, 295, 1589, 13, 51768], "temperature": 0.0, "avg_logprob": -0.2181296642915702, "compression_ratio": 1.7547169811320755, "no_speech_prob": 0.0002611844683997333}, {"id": 369, "seek": 202436, "start": 2024.4399999999998, "end": 2029.8799999999999, "text": " Represented in the latent space, where again points and distances in the latent space have", "tokens": [50368, 3696, 495, 6003, 294, 264, 48994, 1901, 11, 689, 797, 2793, 293, 22182, 294, 264, 48994, 1901, 362, 50640], "temperature": 0.0, "avg_logprob": -0.2532550670482494, "compression_ratio": 1.8571428571428572, "no_speech_prob": 0.00150112877599895}, {"id": 370, "seek": 202436, "start": 2029.8799999999999, "end": 2035.6399999999999, "text": " some relationship to the reconstructions and the content of the reconstructions that result.", "tokens": [50640, 512, 2480, 281, 264, 31499, 626, 293, 264, 2701, 295, 264, 31499, 626, 300, 1874, 13, 50928], "temperature": 0.0, "avg_logprob": -0.2532550670482494, "compression_ratio": 1.8571428571428572, "no_speech_prob": 0.00150112877599895}, {"id": 371, "seek": 202436, "start": 2037.0, "end": 2044.04, "text": " Note though that there's going to be a tradeoff between regularizing and reconstructing. The", "tokens": [50996, 11633, 1673, 300, 456, 311, 516, 281, 312, 257, 4923, 4506, 1296, 3890, 3319, 293, 31499, 278, 13, 440, 51348], "temperature": 0.0, "avg_logprob": -0.2532550670482494, "compression_ratio": 1.8571428571428572, "no_speech_prob": 0.00150112877599895}, {"id": 372, "seek": 202436, "start": 2044.04, "end": 2050.3599999999997, "text": " more we regularize, there's also a risk of suffering, the quality of the reconstruction", "tokens": [51348, 544, 321, 3890, 1125, 11, 456, 311, 611, 257, 3148, 295, 7755, 11, 264, 3125, 295, 264, 31565, 51664], "temperature": 0.0, "avg_logprob": -0.2532550670482494, "compression_ratio": 1.8571428571428572, "no_speech_prob": 0.00150112877599895}, {"id": 373, "seek": 205036, "start": 2050.44, "end": 2056.1200000000003, "text": " and the generation process itself. So in optimizing gaze, there's going to be this tradeoff that's", "tokens": [50368, 293, 264, 5125, 1399, 2564, 13, 407, 294, 40425, 24294, 11, 456, 311, 516, 281, 312, 341, 4923, 4506, 300, 311, 50652], "temperature": 0.0, "avg_logprob": -0.20339097647831358, "compression_ratio": 1.6075949367088607, "no_speech_prob": 0.0019266344606876373}, {"id": 374, "seek": 205036, "start": 2056.1200000000003, "end": 2063.2400000000002, "text": " going to try to be tuned to fit the problem of interest. All right. So hopefully by walking", "tokens": [50652, 516, 281, 853, 281, 312, 10870, 281, 3318, 264, 1154, 295, 1179, 13, 1057, 558, 13, 407, 4696, 538, 4494, 51008], "temperature": 0.0, "avg_logprob": -0.20339097647831358, "compression_ratio": 1.6075949367088607, "no_speech_prob": 0.0019266344606876373}, {"id": 375, "seek": 205036, "start": 2063.2400000000002, "end": 2068.6, "text": " through this, this example, and considering these points, you've built up a more intuition about", "tokens": [51008, 807, 341, 11, 341, 1365, 11, 293, 8079, 613, 2793, 11, 291, 600, 3094, 493, 257, 544, 24002, 466, 51276], "temperature": 0.0, "avg_logprob": -0.20339097647831358, "compression_ratio": 1.6075949367088607, "no_speech_prob": 0.0019266344606876373}, {"id": 376, "seek": 205036, "start": 2068.6, "end": 2074.2000000000003, "text": " why regularization is important and how specifically the normal prior can help us regularize.", "tokens": [51276, 983, 3890, 2144, 307, 1021, 293, 577, 4682, 264, 2710, 4059, 393, 854, 505, 3890, 1125, 13, 51556], "temperature": 0.0, "avg_logprob": -0.20339097647831358, "compression_ratio": 1.6075949367088607, "no_speech_prob": 0.0019266344606876373}, {"id": 377, "seek": 207420, "start": 2074.6, "end": 2079.72, "text": " Great. So now we've defined our loss function, we know that we can reconstruct the inputs,", "tokens": [50384, 3769, 13, 407, 586, 321, 600, 7642, 527, 4470, 2445, 11, 321, 458, 300, 321, 393, 31499, 264, 15743, 11, 50640], "temperature": 0.0, "avg_logprob": -0.24576641082763673, "compression_ratio": 1.6654275092936803, "no_speech_prob": 0.009707686491310596}, {"id": 378, "seek": 207420, "start": 2079.72, "end": 2085.08, "text": " we've understood how we can regularize learning and achieve continuity and completeness via", "tokens": [50640, 321, 600, 7320, 577, 321, 393, 3890, 1125, 2539, 293, 4584, 23807, 293, 1557, 15264, 5766, 50908], "temperature": 0.0, "avg_logprob": -0.24576641082763673, "compression_ratio": 1.6654275092936803, "no_speech_prob": 0.009707686491310596}, {"id": 379, "seek": 207420, "start": 2085.08, "end": 2091.0, "text": " this normal prior. These are all the components that define a forward pass through the network,", "tokens": [50908, 341, 2710, 4059, 13, 1981, 366, 439, 264, 6677, 300, 6964, 257, 2128, 1320, 807, 264, 3209, 11, 51204], "temperature": 0.0, "avg_logprob": -0.24576641082763673, "compression_ratio": 1.6654275092936803, "no_speech_prob": 0.009707686491310596}, {"id": 380, "seek": 207420, "start": 2091.7999999999997, "end": 2097.48, "text": " going from input to encoding to decoded reconstruction. But we're still missing a", "tokens": [51244, 516, 490, 4846, 281, 43430, 281, 979, 12340, 31565, 13, 583, 321, 434, 920, 5361, 257, 51528], "temperature": 0.0, "avg_logprob": -0.24576641082763673, "compression_ratio": 1.6654275092936803, "no_speech_prob": 0.009707686491310596}, {"id": 381, "seek": 207420, "start": 2097.48, "end": 2101.8799999999997, "text": " critical step in putting the whole picture together. And that's, that's a critical step", "tokens": [51528, 4924, 1823, 294, 3372, 264, 1379, 3036, 1214, 13, 400, 300, 311, 11, 300, 311, 257, 4924, 1823, 51748], "temperature": 0.0, "avg_logprob": -0.24576641082763673, "compression_ratio": 1.6654275092936803, "no_speech_prob": 0.009707686491310596}, {"id": 382, "seek": 210188, "start": 2101.88, "end": 2107.8, "text": " putting the whole picture together. And that's a back propagation. And the key here is that", "tokens": [50364, 3372, 264, 1379, 3036, 1214, 13, 400, 300, 311, 257, 646, 38377, 13, 400, 264, 2141, 510, 307, 300, 50660], "temperature": 0.0, "avg_logprob": -0.07854192558376269, "compression_ratio": 1.7972350230414746, "no_speech_prob": 0.002631486626341939}, {"id": 383, "seek": 210188, "start": 2107.8, "end": 2114.04, "text": " because of this fact that we've introduced this stochastic sampling layer, we now have a problem", "tokens": [50660, 570, 295, 341, 1186, 300, 321, 600, 7268, 341, 342, 8997, 2750, 21179, 4583, 11, 321, 586, 362, 257, 1154, 50972], "temperature": 0.0, "avg_logprob": -0.07854192558376269, "compression_ratio": 1.7972350230414746, "no_speech_prob": 0.002631486626341939}, {"id": 384, "seek": 210188, "start": 2114.04, "end": 2119.7200000000003, "text": " where we can't back propagate gradients through a sampling layer that has this element of stochasticity.", "tokens": [50972, 689, 321, 393, 380, 646, 48256, 2771, 2448, 807, 257, 21179, 4583, 300, 575, 341, 4478, 295, 342, 8997, 2750, 507, 13, 51256], "temperature": 0.0, "avg_logprob": -0.07854192558376269, "compression_ratio": 1.7972350230414746, "no_speech_prob": 0.002631486626341939}, {"id": 385, "seek": 210188, "start": 2120.84, "end": 2126.36, "text": " Back propagation requires deterministic nodes, deterministic layers for which we can iteratively", "tokens": [51312, 5833, 38377, 7029, 15957, 3142, 13891, 11, 15957, 3142, 7914, 337, 597, 321, 393, 17138, 19020, 51588], "temperature": 0.0, "avg_logprob": -0.07854192558376269, "compression_ratio": 1.7972350230414746, "no_speech_prob": 0.002631486626341939}, {"id": 386, "seek": 212636, "start": 2126.36, "end": 2132.44, "text": " apply the chain rule to optimize gradients. Optimize the loss via gradient descent.", "tokens": [50364, 3079, 264, 5021, 4978, 281, 19719, 2771, 2448, 13, 35013, 1125, 264, 4470, 5766, 16235, 23475, 13, 50668], "temperature": 0.0, "avg_logprob": -0.10173698750937857, "compression_ratio": 1.6278026905829597, "no_speech_prob": 0.0005357671761885285}, {"id": 387, "seek": 212636, "start": 2133.7200000000003, "end": 2141.32, "text": " All right. VAEs introduced sort of a breakthrough idea that solved this issue of not being able", "tokens": [50732, 1057, 558, 13, 18527, 20442, 7268, 1333, 295, 257, 22397, 1558, 300, 13041, 341, 2734, 295, 406, 885, 1075, 51112], "temperature": 0.0, "avg_logprob": -0.10173698750937857, "compression_ratio": 1.6278026905829597, "no_speech_prob": 0.0005357671761885285}, {"id": 388, "seek": 212636, "start": 2141.32, "end": 2147.4, "text": " to back propagate through a sampling layer. And the key idea was to actually subtly", "tokens": [51112, 281, 646, 48256, 807, 257, 21179, 4583, 13, 400, 264, 2141, 1558, 390, 281, 767, 7257, 356, 51416], "temperature": 0.0, "avg_logprob": -0.10173698750937857, "compression_ratio": 1.6278026905829597, "no_speech_prob": 0.0005357671761885285}, {"id": 389, "seek": 212636, "start": 2147.4, "end": 2153.08, "text": " reparameterize the sampling operation such that the network could be trained completely end to end.", "tokens": [51416, 1085, 12835, 2398, 1125, 264, 21179, 6916, 1270, 300, 264, 3209, 727, 312, 8895, 2584, 917, 281, 917, 13, 51700], "temperature": 0.0, "avg_logprob": -0.10173698750937857, "compression_ratio": 1.6278026905829597, "no_speech_prob": 0.0005357671761885285}, {"id": 390, "seek": 215308, "start": 2154.04, "end": 2159.48, "text": " So as we, as we already learned, right, we're trying to build up this latent distribution", "tokens": [50412, 407, 382, 321, 11, 382, 321, 1217, 3264, 11, 558, 11, 321, 434, 1382, 281, 1322, 493, 341, 48994, 7316, 50684], "temperature": 0.0, "avg_logprob": -0.13649045589358308, "compression_ratio": 1.6488888888888888, "no_speech_prob": 0.00014425799599848688}, {"id": 391, "seek": 215308, "start": 2159.48, "end": 2166.92, "text": " defined by these variables z define it placing a normal prior defined by a mean and a variance.", "tokens": [50684, 7642, 538, 613, 9102, 710, 6964, 309, 17221, 257, 2710, 4059, 7642, 538, 257, 914, 293, 257, 21977, 13, 51056], "temperature": 0.0, "avg_logprob": -0.13649045589358308, "compression_ratio": 1.6488888888888888, "no_speech_prob": 0.00014425799599848688}, {"id": 392, "seek": 215308, "start": 2166.92, "end": 2173.48, "text": " And we can't simply back propagate gradients through the sampling layer because we can't compute", "tokens": [51056, 400, 321, 393, 380, 2935, 646, 48256, 2771, 2448, 807, 264, 21179, 4583, 570, 321, 393, 380, 14722, 51384], "temperature": 0.0, "avg_logprob": -0.13649045589358308, "compression_ratio": 1.6488888888888888, "no_speech_prob": 0.00014425799599848688}, {"id": 393, "seek": 215308, "start": 2174.04, "end": 2181.16, "text": " gradients through this stochastic sample. The key idea instead is to try to consider the", "tokens": [51412, 2771, 2448, 807, 341, 342, 8997, 2750, 6889, 13, 440, 2141, 1558, 2602, 307, 281, 853, 281, 1949, 264, 51768], "temperature": 0.0, "avg_logprob": -0.13649045589358308, "compression_ratio": 1.6488888888888888, "no_speech_prob": 0.00014425799599848688}, {"id": 394, "seek": 218116, "start": 2181.24, "end": 2191.48, "text": " sampled latent vector z as a sum defined by a fixed mu a fixed sigma vector and scale that sigma", "tokens": [50368, 3247, 15551, 48994, 8062, 710, 382, 257, 2408, 7642, 538, 257, 6806, 2992, 257, 6806, 12771, 8062, 293, 4373, 300, 12771, 50880], "temperature": 0.0, "avg_logprob": -0.11974573135375977, "compression_ratio": 1.5824175824175823, "no_speech_prob": 4.985928535461426e-05}, {"id": 395, "seek": 218116, "start": 2191.48, "end": 2198.2799999999997, "text": " vector by random constants that are going to be drawn from a prior distribution such as a normal", "tokens": [50880, 8062, 538, 4974, 35870, 300, 366, 516, 281, 312, 10117, 490, 257, 4059, 7316, 1270, 382, 257, 2710, 51220], "temperature": 0.0, "avg_logprob": -0.11974573135375977, "compression_ratio": 1.5824175824175823, "no_speech_prob": 4.985928535461426e-05}, {"id": 396, "seek": 218116, "start": 2198.2799999999997, "end": 2206.12, "text": " Gaussian. And by reparameterizing the sampling operation as, as so, we still have this element", "tokens": [51220, 39148, 13, 400, 538, 1085, 12835, 2398, 3319, 264, 21179, 6916, 382, 11, 382, 370, 11, 321, 920, 362, 341, 4478, 51612], "temperature": 0.0, "avg_logprob": -0.11974573135375977, "compression_ratio": 1.5824175824175823, "no_speech_prob": 4.985928535461426e-05}, {"id": 397, "seek": 220612, "start": 2206.12, "end": 2212.68, "text": " of stochasticity, but that stochasticity is introduced by this random constant epsilon,", "tokens": [50364, 295, 342, 8997, 2750, 507, 11, 457, 300, 342, 8997, 2750, 507, 307, 7268, 538, 341, 4974, 5754, 17889, 11, 50692], "temperature": 0.0, "avg_logprob": -0.09728482257888978, "compression_ratio": 1.5580357142857142, "no_speech_prob": 0.0008040661923587322}, {"id": 398, "seek": 220612, "start": 2212.68, "end": 2218.3599999999997, "text": " which is not occurring within the bottleneck latent layer itself. We've reparameterized", "tokens": [50692, 597, 307, 406, 18386, 1951, 264, 44641, 547, 48994, 4583, 2564, 13, 492, 600, 1085, 12835, 2398, 1602, 50976], "temperature": 0.0, "avg_logprob": -0.09728482257888978, "compression_ratio": 1.5580357142857142, "no_speech_prob": 0.0008040661923587322}, {"id": 399, "seek": 220612, "start": 2218.3599999999997, "end": 2224.8399999999997, "text": " and distributed it elsewhere. To visualize how this looks, let's consider it the following", "tokens": [50976, 293, 12631, 309, 14517, 13, 1407, 23273, 577, 341, 1542, 11, 718, 311, 1949, 309, 264, 3480, 51300], "temperature": 0.0, "avg_logprob": -0.09728482257888978, "compression_ratio": 1.5580357142857142, "no_speech_prob": 0.0008040661923587322}, {"id": 400, "seek": 220612, "start": 2224.8399999999997, "end": 2232.2799999999997, "text": " where originally in the original form of the VAE, we had this deterministic nodes,", "tokens": [51300, 689, 7993, 294, 264, 3380, 1254, 295, 264, 18527, 36, 11, 321, 632, 341, 15957, 3142, 13891, 11, 51672], "temperature": 0.0, "avg_logprob": -0.09728482257888978, "compression_ratio": 1.5580357142857142, "no_speech_prob": 0.0008040661923587322}, {"id": 401, "seek": 223228, "start": 2232.28, "end": 2236.92, "text": " which are the weights of the network, as well as an input vector, and we are trying to", "tokens": [50364, 597, 366, 264, 17443, 295, 264, 3209, 11, 382, 731, 382, 364, 4846, 8062, 11, 293, 321, 366, 1382, 281, 50596], "temperature": 0.0, "avg_logprob": -0.13276209776428924, "compression_ratio": 1.5442477876106195, "no_speech_prob": 0.00026118586538359523}, {"id": 402, "seek": 223228, "start": 2236.92, "end": 2243.6400000000003, "text": " back propagate through the stochastic sampling node z. But we can't do that. So now,", "tokens": [50596, 646, 48256, 807, 264, 342, 8997, 2750, 21179, 9984, 710, 13, 583, 321, 393, 380, 360, 300, 13, 407, 586, 11, 50932], "temperature": 0.0, "avg_logprob": -0.13276209776428924, "compression_ratio": 1.5442477876106195, "no_speech_prob": 0.00026118586538359523}, {"id": 403, "seek": 223228, "start": 2243.6400000000003, "end": 2251.7200000000003, "text": " by reparameterization, what we've achieved is the following form where our latent variable z", "tokens": [50932, 538, 1085, 12835, 2398, 2144, 11, 437, 321, 600, 11042, 307, 264, 3480, 1254, 689, 527, 48994, 7006, 710, 51336], "temperature": 0.0, "avg_logprob": -0.13276209776428924, "compression_ratio": 1.5442477876106195, "no_speech_prob": 0.00026118586538359523}, {"id": 404, "seek": 223228, "start": 2251.7200000000003, "end": 2261.2400000000002, "text": " are defined with respect to mu sigma squared, as well as these noise factor epsilon,", "tokens": [51336, 366, 7642, 365, 3104, 281, 2992, 12771, 8889, 11, 382, 731, 382, 613, 5658, 5952, 17889, 11, 51812], "temperature": 0.0, "avg_logprob": -0.13276209776428924, "compression_ratio": 1.5442477876106195, "no_speech_prob": 0.00026118586538359523}, {"id": 405, "seek": 226124, "start": 2261.3199999999997, "end": 2267.24, "text": " such that when we want to do back propagation through the network to update, we can directly", "tokens": [50368, 1270, 300, 562, 321, 528, 281, 360, 646, 38377, 807, 264, 3209, 281, 5623, 11, 321, 393, 3838, 50664], "temperature": 0.0, "avg_logprob": -0.0811883290608724, "compression_ratio": 1.6535087719298245, "no_speech_prob": 0.0006263168179430068}, {"id": 406, "seek": 226124, "start": 2267.24, "end": 2273.0, "text": " back propagate through z defined by mu and sigma squared, because this epsilon value is just taken", "tokens": [50664, 646, 48256, 807, 710, 7642, 538, 2992, 293, 12771, 8889, 11, 570, 341, 17889, 2158, 307, 445, 2726, 50952], "temperature": 0.0, "avg_logprob": -0.0811883290608724, "compression_ratio": 1.6535087719298245, "no_speech_prob": 0.0006263168179430068}, {"id": 407, "seek": 226124, "start": 2273.0, "end": 2279.4799999999996, "text": " as a constant, it's reparameterized elsewhere. And this is a very, very powerful trick, the", "tokens": [50952, 382, 257, 5754, 11, 309, 311, 1085, 12835, 2398, 1602, 14517, 13, 400, 341, 307, 257, 588, 11, 588, 4005, 4282, 11, 264, 51276], "temperature": 0.0, "avg_logprob": -0.0811883290608724, "compression_ratio": 1.6535087719298245, "no_speech_prob": 0.0006263168179430068}, {"id": 408, "seek": 226124, "start": 2279.4799999999996, "end": 2285.3199999999997, "text": " reparameterization trick, because it enables us to train variational auto encoders end to end", "tokens": [51276, 1085, 12835, 2398, 2144, 4282, 11, 570, 309, 17077, 505, 281, 3847, 3034, 1478, 8399, 2058, 378, 433, 917, 281, 917, 51568], "temperature": 0.0, "avg_logprob": -0.0811883290608724, "compression_ratio": 1.6535087719298245, "no_speech_prob": 0.0006263168179430068}, {"id": 409, "seek": 228532, "start": 2285.32, "end": 2292.36, "text": " by back propagating with respect to z and with respect to the actual weights of the encoder", "tokens": [50364, 538, 646, 12425, 990, 365, 3104, 281, 710, 293, 365, 3104, 281, 264, 3539, 17443, 295, 264, 2058, 19866, 50716], "temperature": 0.0, "avg_logprob": -0.07328466222256044, "compression_ratio": 1.6930232558139535, "no_speech_prob": 0.00043054638081230223}, {"id": 410, "seek": 228532, "start": 2292.36, "end": 2300.92, "text": " network. All right. One side effect and one consequence of imposing these distributional", "tokens": [50716, 3209, 13, 1057, 558, 13, 1485, 1252, 1802, 293, 472, 18326, 295, 40288, 613, 7316, 304, 51144], "temperature": 0.0, "avg_logprob": -0.07328466222256044, "compression_ratio": 1.6930232558139535, "no_speech_prob": 0.00043054638081230223}, {"id": 411, "seek": 228532, "start": 2300.92, "end": 2306.44, "text": " priors on the latent variable is that we can actually sample from these latent variables", "tokens": [51144, 1790, 830, 322, 264, 48994, 7006, 307, 300, 321, 393, 767, 6889, 490, 613, 48994, 9102, 51420], "temperature": 0.0, "avg_logprob": -0.07328466222256044, "compression_ratio": 1.6930232558139535, "no_speech_prob": 0.00043054638081230223}, {"id": 412, "seek": 228532, "start": 2306.44, "end": 2313.32, "text": " and individually tune them while keeping all of the other variables fixed. And what you can do", "tokens": [51420, 293, 16652, 10864, 552, 1339, 5145, 439, 295, 264, 661, 9102, 6806, 13, 400, 437, 291, 393, 360, 51764], "temperature": 0.0, "avg_logprob": -0.07328466222256044, "compression_ratio": 1.6930232558139535, "no_speech_prob": 0.00043054638081230223}, {"id": 413, "seek": 231332, "start": 2313.32, "end": 2318.76, "text": " is you can tune the value of a particular latent variable and run the decoder each time that variable", "tokens": [50364, 307, 291, 393, 10864, 264, 2158, 295, 257, 1729, 48994, 7006, 293, 1190, 264, 979, 19866, 1184, 565, 300, 7006, 50636], "temperature": 0.0, "avg_logprob": -0.05340030823630848, "compression_ratio": 1.811926605504587, "no_speech_prob": 0.00034598330967128277}, {"id": 414, "seek": 231332, "start": 2318.76, "end": 2325.96, "text": " is changed, each time that variable is perturbed to generate a new reconstructed output. So an", "tokens": [50636, 307, 3105, 11, 1184, 565, 300, 7006, 307, 13269, 374, 2883, 281, 8460, 257, 777, 31499, 292, 5598, 13, 407, 364, 50996], "temperature": 0.0, "avg_logprob": -0.05340030823630848, "compression_ratio": 1.811926605504587, "no_speech_prob": 0.00034598330967128277}, {"id": 415, "seek": 231332, "start": 2325.96, "end": 2333.0, "text": " example of that result is in the following, where this perturbation of the latent variables results", "tokens": [50996, 1365, 295, 300, 1874, 307, 294, 264, 3480, 11, 689, 341, 40468, 399, 295, 264, 48994, 9102, 3542, 51348], "temperature": 0.0, "avg_logprob": -0.05340030823630848, "compression_ratio": 1.811926605504587, "no_speech_prob": 0.00034598330967128277}, {"id": 416, "seek": 231332, "start": 2333.0, "end": 2340.04, "text": " in a representation that has some semantic meaning about what the network is maybe learning. So in", "tokens": [51348, 294, 257, 10290, 300, 575, 512, 47982, 3620, 466, 437, 264, 3209, 307, 1310, 2539, 13, 407, 294, 51700], "temperature": 0.0, "avg_logprob": -0.05340030823630848, "compression_ratio": 1.811926605504587, "no_speech_prob": 0.00034598330967128277}, {"id": 417, "seek": 234004, "start": 2340.04, "end": 2346.92, "text": " this example, these images show variation in head pose. And the different dimensions of z,", "tokens": [50364, 341, 1365, 11, 613, 5267, 855, 12990, 294, 1378, 10774, 13, 400, 264, 819, 12819, 295, 710, 11, 50708], "temperature": 0.0, "avg_logprob": -0.062209753342616705, "compression_ratio": 1.6946902654867257, "no_speech_prob": 0.00013134985056240112}, {"id": 418, "seek": 234004, "start": 2346.92, "end": 2353.8, "text": " the latent space, the different latent variables, are in this way encoding different latent features", "tokens": [50708, 264, 48994, 1901, 11, 264, 819, 48994, 9102, 11, 366, 294, 341, 636, 43430, 819, 48994, 4122, 51052], "temperature": 0.0, "avg_logprob": -0.062209753342616705, "compression_ratio": 1.6946902654867257, "no_speech_prob": 0.00013134985056240112}, {"id": 419, "seek": 234004, "start": 2353.8, "end": 2360.2799999999997, "text": " that can be interpreted by keeping all other variables fixed and perturbing the value of", "tokens": [51052, 300, 393, 312, 26749, 538, 5145, 439, 661, 9102, 6806, 293, 13269, 374, 4324, 264, 2158, 295, 51376], "temperature": 0.0, "avg_logprob": -0.062209753342616705, "compression_ratio": 1.6946902654867257, "no_speech_prob": 0.00013134985056240112}, {"id": 420, "seek": 234004, "start": 2360.2799999999997, "end": 2369.64, "text": " one individual latent variable. Ideally, in order to optimize VAEs and try to maximize the information", "tokens": [51376, 472, 2609, 48994, 7006, 13, 40817, 11, 294, 1668, 281, 19719, 18527, 20442, 293, 853, 281, 19874, 264, 1589, 51844], "temperature": 0.0, "avg_logprob": -0.062209753342616705, "compression_ratio": 1.6946902654867257, "no_speech_prob": 0.00013134985056240112}, {"id": 421, "seek": 236964, "start": 2369.64, "end": 2376.12, "text": " that they encode, we want these latent variables to be uncorrelated with each other, effectively", "tokens": [50364, 300, 436, 2058, 1429, 11, 321, 528, 613, 48994, 9102, 281, 312, 6219, 284, 12004, 365, 1184, 661, 11, 8659, 50688], "temperature": 0.0, "avg_logprob": -0.05795244152626295, "compression_ratio": 1.8078817733990147, "no_speech_prob": 0.005554255563765764}, {"id": 422, "seek": 236964, "start": 2376.12, "end": 2382.12, "text": " disentangled. And what that could enable us to achieve is to learn the richest and most", "tokens": [50688, 37313, 39101, 13, 400, 437, 300, 727, 9528, 505, 281, 4584, 307, 281, 1466, 264, 35098, 293, 881, 50988], "temperature": 0.0, "avg_logprob": -0.05795244152626295, "compression_ratio": 1.8078817733990147, "no_speech_prob": 0.005554255563765764}, {"id": 423, "seek": 236964, "start": 2382.12, "end": 2389.0, "text": " compact latent representation possible. So in this case, we have head pose on the x axis", "tokens": [50988, 14679, 48994, 10290, 1944, 13, 407, 294, 341, 1389, 11, 321, 362, 1378, 10774, 322, 264, 2031, 10298, 51332], "temperature": 0.0, "avg_logprob": -0.05795244152626295, "compression_ratio": 1.8078817733990147, "no_speech_prob": 0.005554255563765764}, {"id": 424, "seek": 236964, "start": 2389.0, "end": 2395.16, "text": " and smile on the y axis. And we want these to be as uncorrelated with each other as possible.", "tokens": [51332, 293, 7563, 322, 264, 288, 10298, 13, 400, 321, 528, 613, 281, 312, 382, 6219, 284, 12004, 365, 1184, 661, 382, 1944, 13, 51640], "temperature": 0.0, "avg_logprob": -0.05795244152626295, "compression_ratio": 1.8078817733990147, "no_speech_prob": 0.005554255563765764}, {"id": 425, "seek": 239516, "start": 2395.7999999999997, "end": 2401.3199999999997, "text": " One way we can achieve this, that's been shown to achieve this disentanglement,", "tokens": [50396, 1485, 636, 321, 393, 4584, 341, 11, 300, 311, 668, 4898, 281, 4584, 341, 37313, 656, 3054, 11, 50672], "temperature": 0.0, "avg_logprob": -0.10438069843110584, "compression_ratio": 1.5701754385964912, "no_speech_prob": 0.0026314938440918922}, {"id": 426, "seek": 239516, "start": 2401.3199999999997, "end": 2407.64, "text": " is rather a quite straightforward approach called beta VAEs. So if we consider the loss of a standard", "tokens": [50672, 307, 2831, 257, 1596, 15325, 3109, 1219, 9861, 18527, 20442, 13, 407, 498, 321, 1949, 264, 4470, 295, 257, 3832, 50988], "temperature": 0.0, "avg_logprob": -0.10438069843110584, "compression_ratio": 1.5701754385964912, "no_speech_prob": 0.0026314938440918922}, {"id": 427, "seek": 239516, "start": 2407.64, "end": 2413.7999999999997, "text": " VAE, again, we have this reconstruction term defined by a log likelihood and a regularization term", "tokens": [50988, 18527, 36, 11, 797, 11, 321, 362, 341, 31565, 1433, 7642, 538, 257, 3565, 22119, 293, 257, 3890, 2144, 1433, 51296], "temperature": 0.0, "avg_logprob": -0.10438069843110584, "compression_ratio": 1.5701754385964912, "no_speech_prob": 0.0026314938440918922}, {"id": 428, "seek": 239516, "start": 2413.7999999999997, "end": 2420.3599999999997, "text": " defined by the KL divergence. Beta VAEs introduce a new hyper parameter beta,", "tokens": [51296, 7642, 538, 264, 47991, 47387, 13, 33286, 18527, 20442, 5366, 257, 777, 9848, 13075, 9861, 11, 51624], "temperature": 0.0, "avg_logprob": -0.10438069843110584, "compression_ratio": 1.5701754385964912, "no_speech_prob": 0.0026314938440918922}, {"id": 429, "seek": 242036, "start": 2420.36, "end": 2426.44, "text": " which controls the strength of this regularization term. And it's been shown mathematically that", "tokens": [50364, 597, 9003, 264, 3800, 295, 341, 3890, 2144, 1433, 13, 400, 309, 311, 668, 4898, 44003, 300, 50668], "temperature": 0.0, "avg_logprob": -0.06623451209362642, "compression_ratio": 1.6103896103896105, "no_speech_prob": 0.0005357603076845407}, {"id": 430, "seek": 242036, "start": 2426.44, "end": 2432.52, "text": " by increasing beta, the effect is to place constraints on the latent encoding, such as to", "tokens": [50668, 538, 5662, 9861, 11, 264, 1802, 307, 281, 1081, 18491, 322, 264, 48994, 43430, 11, 1270, 382, 281, 50972], "temperature": 0.0, "avg_logprob": -0.06623451209362642, "compression_ratio": 1.6103896103896105, "no_speech_prob": 0.0005357603076845407}, {"id": 431, "seek": 242036, "start": 2432.52, "end": 2437.88, "text": " encourage disentanglement. And there have been extensive proofs and discussions as to how exactly", "tokens": [50972, 5373, 37313, 656, 3054, 13, 400, 456, 362, 668, 13246, 8177, 82, 293, 11088, 382, 281, 577, 2293, 51240], "temperature": 0.0, "avg_logprob": -0.06623451209362642, "compression_ratio": 1.6103896103896105, "no_speech_prob": 0.0005357603076845407}, {"id": 432, "seek": 242036, "start": 2437.88, "end": 2444.1200000000003, "text": " this is achieved. But to consider the results, let's again consider the problem of face", "tokens": [51240, 341, 307, 11042, 13, 583, 281, 1949, 264, 3542, 11, 718, 311, 797, 1949, 264, 1154, 295, 1851, 51552], "temperature": 0.0, "avg_logprob": -0.06623451209362642, "compression_ratio": 1.6103896103896105, "no_speech_prob": 0.0005357603076845407}, {"id": 433, "seek": 244412, "start": 2444.12, "end": 2451.72, "text": " reconstruction. Where using a standard VAE, if we consider the latent variable of head pose", "tokens": [50364, 31565, 13, 2305, 1228, 257, 3832, 18527, 36, 11, 498, 321, 1949, 264, 48994, 7006, 295, 1378, 10774, 50744], "temperature": 0.0, "avg_logprob": -0.06310847100247158, "compression_ratio": 1.6724890829694323, "no_speech_prob": 0.008061490021646023}, {"id": 434, "seek": 244412, "start": 2451.72, "end": 2457.4, "text": " or rotation, in this case where beta equals one, what you can hopefully appreciate is that as the", "tokens": [50744, 420, 12447, 11, 294, 341, 1389, 689, 9861, 6915, 472, 11, 437, 291, 393, 4696, 4449, 307, 300, 382, 264, 51028], "temperature": 0.0, "avg_logprob": -0.06310847100247158, "compression_ratio": 1.6724890829694323, "no_speech_prob": 0.008061490021646023}, {"id": 435, "seek": 244412, "start": 2457.4, "end": 2466.12, "text": " face pose is changing, the smile of some of these faces is also changing. In contrast, by enforcing", "tokens": [51028, 1851, 10774, 307, 4473, 11, 264, 7563, 295, 512, 295, 613, 8475, 307, 611, 4473, 13, 682, 8712, 11, 538, 25495, 2175, 51464], "temperature": 0.0, "avg_logprob": -0.06310847100247158, "compression_ratio": 1.6724890829694323, "no_speech_prob": 0.008061490021646023}, {"id": 436, "seek": 244412, "start": 2466.12, "end": 2473.08, "text": " a beta much larger than one, what is able to be achieved is that the smile remains relatively", "tokens": [51464, 257, 9861, 709, 4833, 813, 472, 11, 437, 307, 1075, 281, 312, 11042, 307, 300, 264, 7563, 7023, 7226, 51812], "temperature": 0.0, "avg_logprob": -0.06310847100247158, "compression_ratio": 1.6724890829694323, "no_speech_prob": 0.008061490021646023}, {"id": 437, "seek": 247308, "start": 2473.08, "end": 2479.96, "text": " constant while we can perturb the single latent variable of the head rotation and achieve perturbations", "tokens": [50364, 5754, 1339, 321, 393, 40468, 264, 2167, 48994, 7006, 295, 264, 1378, 12447, 293, 4584, 40468, 763, 50708], "temperature": 0.0, "avg_logprob": -0.0940462638591898, "compression_ratio": 1.7304347826086957, "no_speech_prob": 0.0002737099421210587}, {"id": 438, "seek": 247308, "start": 2479.96, "end": 2487.88, "text": " with respect to head rotation alone. All right. So as I motivated and introduced in the beginning", "tokens": [50708, 365, 3104, 281, 1378, 12447, 3312, 13, 1057, 558, 13, 407, 382, 286, 14515, 293, 7268, 294, 264, 2863, 51104], "temperature": 0.0, "avg_logprob": -0.0940462638591898, "compression_ratio": 1.7304347826086957, "no_speech_prob": 0.0002737099421210587}, {"id": 439, "seek": 247308, "start": 2487.88, "end": 2493.16, "text": " and the introduction of this lecture, one powerful application of generative models and latent", "tokens": [51104, 293, 264, 9339, 295, 341, 7991, 11, 472, 4005, 3861, 295, 1337, 1166, 5245, 293, 48994, 51368], "temperature": 0.0, "avg_logprob": -0.0940462638591898, "compression_ratio": 1.7304347826086957, "no_speech_prob": 0.0002737099421210587}, {"id": 440, "seek": 247308, "start": 2493.16, "end": 2499.4, "text": " variable models is in model debiasing. And in today's lab, you're actually going to get real hands-on", "tokens": [51368, 7006, 5245, 307, 294, 2316, 3001, 72, 3349, 13, 400, 294, 965, 311, 2715, 11, 291, 434, 767, 516, 281, 483, 957, 2377, 12, 266, 51680], "temperature": 0.0, "avg_logprob": -0.0940462638591898, "compression_ratio": 1.7304347826086957, "no_speech_prob": 0.0002737099421210587}, {"id": 441, "seek": 249940, "start": 2499.4, "end": 2506.12, "text": " experience in building a variational autoencoder that can be used to achieve automatic debiasing", "tokens": [50364, 1752, 294, 2390, 257, 3034, 1478, 8399, 22660, 19866, 300, 393, 312, 1143, 281, 4584, 12509, 3001, 72, 3349, 50700], "temperature": 0.0, "avg_logprob": -0.07757500757144976, "compression_ratio": 1.7116279069767442, "no_speech_prob": 0.005059727001935244}, {"id": 442, "seek": 249940, "start": 2506.12, "end": 2511.48, "text": " of facial classification systems, facial detection systems. And the power and the idea of this", "tokens": [50700, 295, 15642, 21538, 3652, 11, 15642, 17784, 3652, 13, 400, 264, 1347, 293, 264, 1558, 295, 341, 50968], "temperature": 0.0, "avg_logprob": -0.07757500757144976, "compression_ratio": 1.7116279069767442, "no_speech_prob": 0.005059727001935244}, {"id": 443, "seek": 249940, "start": 2512.04, "end": 2519.1600000000003, "text": " approach is to build up a representation, a learned latent distribution of face data,", "tokens": [50996, 3109, 307, 281, 1322, 493, 257, 10290, 11, 257, 3264, 48994, 7316, 295, 1851, 1412, 11, 51352], "temperature": 0.0, "avg_logprob": -0.07757500757144976, "compression_ratio": 1.7116279069767442, "no_speech_prob": 0.005059727001935244}, {"id": 444, "seek": 249940, "start": 2519.88, "end": 2525.7200000000003, "text": " and use this to identify regions of that latent space that are going to be overrepresented", "tokens": [51388, 293, 764, 341, 281, 5876, 10682, 295, 300, 48994, 1901, 300, 366, 516, 281, 312, 670, 38293, 51680], "temperature": 0.0, "avg_logprob": -0.07757500757144976, "compression_ratio": 1.7116279069767442, "no_speech_prob": 0.005059727001935244}, {"id": 445, "seek": 252572, "start": 2525.72, "end": 2530.12, "text": " or underrepresented. And that's going to all be taken with respect to particular", "tokens": [50364, 420, 833, 38293, 13, 400, 300, 311, 516, 281, 439, 312, 2726, 365, 3104, 281, 1729, 50584], "temperature": 0.0, "avg_logprob": -0.07226673552864477, "compression_ratio": 1.6462264150943395, "no_speech_prob": 0.0031723626889288425}, {"id": 446, "seek": 252572, "start": 2530.12, "end": 2537.56, "text": " learned features such as skin tone, pose, objects, clothing. And then from these learned", "tokens": [50584, 3264, 4122, 1270, 382, 3178, 8027, 11, 10774, 11, 6565, 11, 11502, 13, 400, 550, 490, 613, 3264, 50956], "temperature": 0.0, "avg_logprob": -0.07226673552864477, "compression_ratio": 1.6462264150943395, "no_speech_prob": 0.0031723626889288425}, {"id": 447, "seek": 252572, "start": 2537.56, "end": 2544.7599999999998, "text": " distributions, we can actually adjust the training process such that we can place greater", "tokens": [50956, 37870, 11, 321, 393, 767, 4369, 264, 3097, 1399, 1270, 300, 321, 393, 1081, 5044, 51316], "temperature": 0.0, "avg_logprob": -0.07226673552864477, "compression_ratio": 1.6462264150943395, "no_speech_prob": 0.0031723626889288425}, {"id": 448, "seek": 252572, "start": 2545.64, "end": 2551.56, "text": " weight and greater sampling on those images and on those faces the fall in the regions of", "tokens": [51360, 3364, 293, 5044, 21179, 322, 729, 5267, 293, 322, 729, 8475, 264, 2100, 294, 264, 10682, 295, 51656], "temperature": 0.0, "avg_logprob": -0.07226673552864477, "compression_ratio": 1.6462264150943395, "no_speech_prob": 0.0031723626889288425}, {"id": 449, "seek": 255156, "start": 2551.56, "end": 2557.08, "text": " the latent space that are underrepresented automatically. And what's really, really cool", "tokens": [50364, 264, 48994, 1901, 300, 366, 833, 38293, 6772, 13, 400, 437, 311, 534, 11, 534, 1627, 50640], "temperature": 0.0, "avg_logprob": -0.06762731222458827, "compression_ratio": 1.6543778801843319, "no_speech_prob": 0.00036828979500569403}, {"id": 450, "seek": 255156, "start": 2557.96, "end": 2563.7999999999997, "text": " about deploying a VAE or a latent variable model for an application like model debiasing", "tokens": [50684, 466, 34198, 257, 18527, 36, 420, 257, 48994, 7006, 2316, 337, 364, 3861, 411, 2316, 3001, 72, 3349, 50976], "temperature": 0.0, "avg_logprob": -0.06762731222458827, "compression_ratio": 1.6543778801843319, "no_speech_prob": 0.00036828979500569403}, {"id": 451, "seek": 255156, "start": 2563.7999999999997, "end": 2569.64, "text": " is that there's no need for us to annotate and prescribe the features that are important", "tokens": [50976, 307, 300, 456, 311, 572, 643, 337, 505, 281, 25339, 473, 293, 49292, 264, 4122, 300, 366, 1021, 51268], "temperature": 0.0, "avg_logprob": -0.06762731222458827, "compression_ratio": 1.6543778801843319, "no_speech_prob": 0.00036828979500569403}, {"id": 452, "seek": 255156, "start": 2569.64, "end": 2575.0, "text": " to actually debize against. The model learns them automatically. And this is going to be the", "tokens": [51268, 281, 767, 3001, 1125, 1970, 13, 440, 2316, 27152, 552, 6772, 13, 400, 341, 307, 516, 281, 312, 264, 51536], "temperature": 0.0, "avg_logprob": -0.06762731222458827, "compression_ratio": 1.6543778801843319, "no_speech_prob": 0.00036828979500569403}, {"id": 453, "seek": 257500, "start": 2575.0, "end": 2582.12, "text": " topic of today's lab. And it also opens the door to a much broader space that's going to", "tokens": [50364, 4829, 295, 965, 311, 2715, 13, 400, 309, 611, 9870, 264, 2853, 281, 257, 709, 13227, 1901, 300, 311, 516, 281, 50720], "temperature": 0.0, "avg_logprob": -0.1185438688411269, "compression_ratio": 1.6120689655172413, "no_speech_prob": 0.009411103092133999}, {"id": 454, "seek": 257500, "start": 2582.12, "end": 2587.4, "text": " be explored further in a later spotlight lecture that's going to focus on algorithmic bias and", "tokens": [50720, 312, 24016, 3052, 294, 257, 1780, 24656, 7991, 300, 311, 516, 281, 1879, 322, 9284, 299, 12577, 293, 50984], "temperature": 0.0, "avg_logprob": -0.1185438688411269, "compression_ratio": 1.6120689655172413, "no_speech_prob": 0.009411103092133999}, {"id": 455, "seek": 257500, "start": 2587.4, "end": 2594.2, "text": " machine learning fairness. All right, so to summarize the key points on VAEs, they compress", "tokens": [50984, 3479, 2539, 29765, 13, 1057, 558, 11, 370, 281, 20858, 264, 2141, 2793, 322, 18527, 20442, 11, 436, 14778, 51324], "temperature": 0.0, "avg_logprob": -0.1185438688411269, "compression_ratio": 1.6120689655172413, "no_speech_prob": 0.009411103092133999}, {"id": 456, "seek": 257500, "start": 2594.2, "end": 2601.56, "text": " representation of data into an encoded representation. Reconstruction of the data input allows for", "tokens": [51324, 10290, 295, 1412, 666, 364, 2058, 12340, 10290, 13, 1300, 25279, 3826, 295, 264, 1412, 4846, 4045, 337, 51692], "temperature": 0.0, "avg_logprob": -0.1185438688411269, "compression_ratio": 1.6120689655172413, "no_speech_prob": 0.009411103092133999}, {"id": 457, "seek": 260156, "start": 2601.56, "end": 2609.4, "text": " unsupervised learning without labels. We can use the reparameterization trick to train", "tokens": [50364, 2693, 12879, 24420, 2539, 1553, 16949, 13, 492, 393, 764, 264, 1085, 12835, 2398, 2144, 4282, 281, 3847, 50756], "temperature": 0.0, "avg_logprob": -0.08242337703704834, "compression_ratio": 1.6164383561643836, "no_speech_prob": 0.0013249502517282963}, {"id": 458, "seek": 260156, "start": 2609.4, "end": 2616.2, "text": " VAEs end to end. We can take hidden latent variables, perturb them to interpret their", "tokens": [50756, 18527, 20442, 917, 281, 917, 13, 492, 393, 747, 7633, 48994, 9102, 11, 40468, 552, 281, 7302, 641, 51096], "temperature": 0.0, "avg_logprob": -0.08242337703704834, "compression_ratio": 1.6164383561643836, "no_speech_prob": 0.0013249502517282963}, {"id": 459, "seek": 260156, "start": 2616.2, "end": 2621.4, "text": " content and their meaning. And finally, we can sample from the latent space to generate new", "tokens": [51096, 2701, 293, 641, 3620, 13, 400, 2721, 11, 321, 393, 6889, 490, 264, 48994, 1901, 281, 8460, 777, 51356], "temperature": 0.0, "avg_logprob": -0.08242337703704834, "compression_ratio": 1.6164383561643836, "no_speech_prob": 0.0013249502517282963}, {"id": 460, "seek": 260156, "start": 2621.4, "end": 2629.0, "text": " examples. But what if we wanted to focus on generating samples and synthetic samples that", "tokens": [51356, 5110, 13, 583, 437, 498, 321, 1415, 281, 1879, 322, 17746, 10938, 293, 23420, 10938, 300, 51736], "temperature": 0.0, "avg_logprob": -0.08242337703704834, "compression_ratio": 1.6164383561643836, "no_speech_prob": 0.0013249502517282963}, {"id": 461, "seek": 262900, "start": 2629.0, "end": 2635.64, "text": " were as faithful to a data distribution generally as possible? To understand how we can achieve", "tokens": [50364, 645, 382, 17808, 281, 257, 1412, 7316, 5101, 382, 1944, 30, 1407, 1223, 577, 321, 393, 4584, 50696], "temperature": 0.0, "avg_logprob": -0.06196691288667567, "compression_ratio": 1.606694560669456, "no_speech_prob": 0.0006070470553822815}, {"id": 462, "seek": 262900, "start": 2635.64, "end": 2640.2, "text": " this, we're going to transition to discuss a new type of generative model called a generative", "tokens": [50696, 341, 11, 321, 434, 516, 281, 6034, 281, 2248, 257, 777, 2010, 295, 1337, 1166, 2316, 1219, 257, 1337, 1166, 50924], "temperature": 0.0, "avg_logprob": -0.06196691288667567, "compression_ratio": 1.606694560669456, "no_speech_prob": 0.0006070470553822815}, {"id": 463, "seek": 262900, "start": 2640.2, "end": 2650.04, "text": " adversarial network or GAN for short. The idea here is that we don't want to explicitly model", "tokens": [50924, 17641, 44745, 3209, 420, 460, 1770, 337, 2099, 13, 440, 1558, 510, 307, 300, 321, 500, 380, 528, 281, 20803, 2316, 51416], "temperature": 0.0, "avg_logprob": -0.06196691288667567, "compression_ratio": 1.606694560669456, "no_speech_prob": 0.0006070470553822815}, {"id": 464, "seek": 262900, "start": 2650.04, "end": 2656.6, "text": " the density or the or the distribution underlying some data, but instead just learn a representation", "tokens": [51416, 264, 10305, 420, 264, 420, 264, 7316, 14217, 512, 1412, 11, 457, 2602, 445, 1466, 257, 10290, 51744], "temperature": 0.0, "avg_logprob": -0.06196691288667567, "compression_ratio": 1.606694560669456, "no_speech_prob": 0.0006070470553822815}, {"id": 465, "seek": 265660, "start": 2656.6, "end": 2661.72, "text": " that can be successful in generating new instances that are similar to the data,", "tokens": [50364, 300, 393, 312, 4406, 294, 17746, 777, 14519, 300, 366, 2531, 281, 264, 1412, 11, 50620], "temperature": 0.0, "avg_logprob": -0.05470075235738383, "compression_ratio": 1.547085201793722, "no_speech_prob": 0.0006070472300052643}, {"id": 466, "seek": 265660, "start": 2663.0, "end": 2668.7599999999998, "text": " which means that we want to optimize to sample from a very, very complex distribution,", "tokens": [50684, 597, 1355, 300, 321, 528, 281, 19719, 281, 6889, 490, 257, 588, 11, 588, 3997, 7316, 11, 50972], "temperature": 0.0, "avg_logprob": -0.05470075235738383, "compression_ratio": 1.547085201793722, "no_speech_prob": 0.0006070472300052643}, {"id": 467, "seek": 265660, "start": 2669.4, "end": 2675.0, "text": " which cannot be learned and modeled directly. Instead, we're going to have to build up some", "tokens": [51004, 597, 2644, 312, 3264, 293, 37140, 3838, 13, 7156, 11, 321, 434, 516, 281, 362, 281, 1322, 493, 512, 51284], "temperature": 0.0, "avg_logprob": -0.05470075235738383, "compression_ratio": 1.547085201793722, "no_speech_prob": 0.0006070472300052643}, {"id": 468, "seek": 265660, "start": 2675.0, "end": 2682.44, "text": " approximation of this distribution. And the really cool and breakthrough idea of GANs", "tokens": [51284, 28023, 295, 341, 7316, 13, 400, 264, 534, 1627, 293, 22397, 1558, 295, 460, 1770, 82, 51656], "temperature": 0.0, "avg_logprob": -0.05470075235738383, "compression_ratio": 1.547085201793722, "no_speech_prob": 0.0006070472300052643}, {"id": 469, "seek": 268244, "start": 2682.44, "end": 2689.32, "text": " is to start from something extremely, extremely simple, just random noise and try to build a", "tokens": [50364, 307, 281, 722, 490, 746, 4664, 11, 4664, 2199, 11, 445, 4974, 5658, 293, 853, 281, 1322, 257, 50708], "temperature": 0.0, "avg_logprob": -0.07167099651537444, "compression_ratio": 1.7740384615384615, "no_speech_prob": 0.0010649214964359999}, {"id": 470, "seek": 268244, "start": 2689.32, "end": 2695.48, "text": " neural network, a generative neural network that can learn a functional transformation", "tokens": [50708, 18161, 3209, 11, 257, 1337, 1166, 18161, 3209, 300, 393, 1466, 257, 11745, 9887, 51016], "temperature": 0.0, "avg_logprob": -0.07167099651537444, "compression_ratio": 1.7740384615384615, "no_speech_prob": 0.0010649214964359999}, {"id": 471, "seek": 268244, "start": 2695.48, "end": 2703.88, "text": " that goes from noise to the data distribution. And by learning this functional generative mapping,", "tokens": [51016, 300, 1709, 490, 5658, 281, 264, 1412, 7316, 13, 400, 538, 2539, 341, 11745, 1337, 1166, 18350, 11, 51436], "temperature": 0.0, "avg_logprob": -0.07167099651537444, "compression_ratio": 1.7740384615384615, "no_speech_prob": 0.0010649214964359999}, {"id": 472, "seek": 268244, "start": 2703.88, "end": 2710.2000000000003, "text": " we can then sample in order to generate fake instances, synthetic instances that are going", "tokens": [51436, 321, 393, 550, 6889, 294, 1668, 281, 8460, 7592, 14519, 11, 23420, 14519, 300, 366, 516, 51752], "temperature": 0.0, "avg_logprob": -0.07167099651537444, "compression_ratio": 1.7740384615384615, "no_speech_prob": 0.0010649214964359999}, {"id": 473, "seek": 271020, "start": 2710.2, "end": 2717.3999999999996, "text": " to be as close to the real data distribution as possible. The breakthrough to achieving this", "tokens": [50364, 281, 312, 382, 1998, 281, 264, 957, 1412, 7316, 382, 1944, 13, 440, 22397, 281, 19626, 341, 50724], "temperature": 0.0, "avg_logprob": -0.04986090958118439, "compression_ratio": 1.6026200873362446, "no_speech_prob": 0.0015010619536042213}, {"id": 474, "seek": 271020, "start": 2717.3999999999996, "end": 2723.8799999999997, "text": " was this structure called GANs, where the key component is to have two neural networks,", "tokens": [50724, 390, 341, 3877, 1219, 460, 1770, 82, 11, 689, 264, 2141, 6542, 307, 281, 362, 732, 18161, 9590, 11, 51048], "temperature": 0.0, "avg_logprob": -0.04986090958118439, "compression_ratio": 1.6026200873362446, "no_speech_prob": 0.0015010619536042213}, {"id": 475, "seek": 271020, "start": 2723.8799999999997, "end": 2729.16, "text": " a generator network and a discriminator network that are effectively competing against each other,", "tokens": [51048, 257, 19265, 3209, 293, 257, 20828, 1639, 3209, 300, 366, 8659, 15439, 1970, 1184, 661, 11, 51312], "temperature": 0.0, "avg_logprob": -0.04986090958118439, "compression_ratio": 1.6026200873362446, "no_speech_prob": 0.0015010619536042213}, {"id": 476, "seek": 271020, "start": 2729.16, "end": 2734.7599999999998, "text": " their adversaries. Specifically, we have a generator network, which I'm going to denote", "tokens": [51312, 641, 17641, 4889, 13, 26058, 11, 321, 362, 257, 19265, 3209, 11, 597, 286, 478, 516, 281, 45708, 51592], "temperature": 0.0, "avg_logprob": -0.04986090958118439, "compression_ratio": 1.6026200873362446, "no_speech_prob": 0.0015010619536042213}, {"id": 477, "seek": 273476, "start": 2734.76, "end": 2740.92, "text": " here on out by G, that's going to be trained to go from random noise to produce an imitation of", "tokens": [50364, 510, 322, 484, 538, 460, 11, 300, 311, 516, 281, 312, 8895, 281, 352, 490, 4974, 5658, 281, 5258, 364, 47624, 295, 50672], "temperature": 0.0, "avg_logprob": -0.059868263161700706, "compression_ratio": 1.7477064220183487, "no_speech_prob": 0.044668879359960556}, {"id": 478, "seek": 273476, "start": 2740.92, "end": 2747.88, "text": " the data. And then the discriminator is going to take that synthetic fake data, as well as real", "tokens": [50672, 264, 1412, 13, 400, 550, 264, 20828, 1639, 307, 516, 281, 747, 300, 23420, 7592, 1412, 11, 382, 731, 382, 957, 51020], "temperature": 0.0, "avg_logprob": -0.059868263161700706, "compression_ratio": 1.7477064220183487, "no_speech_prob": 0.044668879359960556}, {"id": 479, "seek": 273476, "start": 2747.88, "end": 2753.7200000000003, "text": " data, and be trained to actually distinguish between fake and real. And in training, these two", "tokens": [51020, 1412, 11, 293, 312, 8895, 281, 767, 20206, 1296, 7592, 293, 957, 13, 400, 294, 3097, 11, 613, 732, 51312], "temperature": 0.0, "avg_logprob": -0.059868263161700706, "compression_ratio": 1.7477064220183487, "no_speech_prob": 0.044668879359960556}, {"id": 480, "seek": 273476, "start": 2753.7200000000003, "end": 2760.1200000000003, "text": " networks are going to be competing against each other. And so in doing so, overall, the effect", "tokens": [51312, 9590, 366, 516, 281, 312, 15439, 1970, 1184, 661, 13, 400, 370, 294, 884, 370, 11, 4787, 11, 264, 1802, 51632], "temperature": 0.0, "avg_logprob": -0.059868263161700706, "compression_ratio": 1.7477064220183487, "no_speech_prob": 0.044668879359960556}, {"id": 481, "seek": 276012, "start": 2760.12, "end": 2765.0, "text": " is that the discriminator is going to get better and better at learning how to classify real and", "tokens": [50364, 307, 300, 264, 20828, 1639, 307, 516, 281, 483, 1101, 293, 1101, 412, 2539, 577, 281, 33872, 957, 293, 50608], "temperature": 0.0, "avg_logprob": -0.05543894516794305, "compression_ratio": 1.864864864864865, "no_speech_prob": 0.006692148745059967}, {"id": 482, "seek": 276012, "start": 2765.0, "end": 2769.88, "text": " fake. And the better it becomes at doing that, it's going to force the generator to try to produce", "tokens": [50608, 7592, 13, 400, 264, 1101, 309, 3643, 412, 884, 300, 11, 309, 311, 516, 281, 3464, 264, 19265, 281, 853, 281, 5258, 50852], "temperature": 0.0, "avg_logprob": -0.05543894516794305, "compression_ratio": 1.864864864864865, "no_speech_prob": 0.006692148745059967}, {"id": 483, "seek": 276012, "start": 2769.88, "end": 2774.8399999999997, "text": " better and better synthetic data to try to fool the discriminator back and forth, back and forth.", "tokens": [50852, 1101, 293, 1101, 23420, 1412, 281, 853, 281, 7979, 264, 20828, 1639, 646, 293, 5220, 11, 646, 293, 5220, 13, 51100], "temperature": 0.0, "avg_logprob": -0.05543894516794305, "compression_ratio": 1.864864864864865, "no_speech_prob": 0.006692148745059967}, {"id": 484, "seek": 276012, "start": 2775.7999999999997, "end": 2782.8399999999997, "text": " So let's now break this down and go from a very simple toy example to get more intuition", "tokens": [51148, 407, 718, 311, 586, 1821, 341, 760, 293, 352, 490, 257, 588, 2199, 12058, 1365, 281, 483, 544, 24002, 51500], "temperature": 0.0, "avg_logprob": -0.05543894516794305, "compression_ratio": 1.864864864864865, "no_speech_prob": 0.006692148745059967}, {"id": 485, "seek": 276012, "start": 2782.8399999999997, "end": 2789.56, "text": " about how these GANs work. The generator is going to start, again, from some completely random noise", "tokens": [51500, 466, 577, 613, 460, 1770, 82, 589, 13, 440, 19265, 307, 516, 281, 722, 11, 797, 11, 490, 512, 2584, 4974, 5658, 51836], "temperature": 0.0, "avg_logprob": -0.05543894516794305, "compression_ratio": 1.864864864864865, "no_speech_prob": 0.006692148745059967}, {"id": 486, "seek": 278956, "start": 2789.56, "end": 2794.84, "text": " and produce fake data. And I'm going to show that here by representing these data as points on a", "tokens": [50364, 293, 5258, 7592, 1412, 13, 400, 286, 478, 516, 281, 855, 300, 510, 538, 13460, 613, 1412, 382, 2793, 322, 257, 50628], "temperature": 0.0, "avg_logprob": -0.0734384136815225, "compression_ratio": 1.890625, "no_speech_prob": 0.0009109849343076348}, {"id": 487, "seek": 278956, "start": 2794.84, "end": 2800.92, "text": " one-dimensional line. The discriminator is then going to see these points, as well as real data.", "tokens": [50628, 472, 12, 18759, 1622, 13, 440, 20828, 1639, 307, 550, 516, 281, 536, 613, 2793, 11, 382, 731, 382, 957, 1412, 13, 50932], "temperature": 0.0, "avg_logprob": -0.0734384136815225, "compression_ratio": 1.890625, "no_speech_prob": 0.0009109849343076348}, {"id": 488, "seek": 278956, "start": 2801.88, "end": 2807.96, "text": " And then it's going to be trained to output a probability that the data it sees are real,", "tokens": [50980, 400, 550, 309, 311, 516, 281, 312, 8895, 281, 5598, 257, 8482, 300, 264, 1412, 309, 8194, 366, 957, 11, 51284], "temperature": 0.0, "avg_logprob": -0.0734384136815225, "compression_ratio": 1.890625, "no_speech_prob": 0.0009109849343076348}, {"id": 489, "seek": 278956, "start": 2808.6, "end": 2813.56, "text": " or if they are fake. And in the beginning, it's not going to be trained very well, right? So its", "tokens": [51316, 420, 498, 436, 366, 7592, 13, 400, 294, 264, 2863, 11, 309, 311, 406, 516, 281, 312, 8895, 588, 731, 11, 558, 30, 407, 1080, 51564], "temperature": 0.0, "avg_logprob": -0.0734384136815225, "compression_ratio": 1.890625, "no_speech_prob": 0.0009109849343076348}, {"id": 490, "seek": 278956, "start": 2813.56, "end": 2818.2, "text": " predictions are not going to be very good. But then you're going to train it, and you're going to train", "tokens": [51564, 21264, 366, 406, 516, 281, 312, 588, 665, 13, 583, 550, 291, 434, 516, 281, 3847, 309, 11, 293, 291, 434, 516, 281, 3847, 51796], "temperature": 0.0, "avg_logprob": -0.0734384136815225, "compression_ratio": 1.890625, "no_speech_prob": 0.0009109849343076348}, {"id": 491, "seek": 281820, "start": 2818.2, "end": 2825.56, "text": " it. And it's going to start increasing the probabilities of real versus not real appropriately,", "tokens": [50364, 309, 13, 400, 309, 311, 516, 281, 722, 5662, 264, 33783, 295, 957, 5717, 406, 957, 23505, 11, 50732], "temperature": 0.0, "avg_logprob": -0.08056630558437772, "compression_ratio": 1.7798165137614679, "no_speech_prob": 0.000882997119333595}, {"id": 492, "seek": 281820, "start": 2825.56, "end": 2831.0, "text": " such that you get this perfect separation where the discriminator is able to perfectly distinguish", "tokens": [50732, 1270, 300, 291, 483, 341, 2176, 14634, 689, 264, 20828, 1639, 307, 1075, 281, 6239, 20206, 51004], "temperature": 0.0, "avg_logprob": -0.08056630558437772, "compression_ratio": 1.7798165137614679, "no_speech_prob": 0.000882997119333595}, {"id": 493, "seek": 281820, "start": 2831.0, "end": 2837.16, "text": " what is real and what is fake. Now it's back to the generator. And the generator is going to come", "tokens": [51004, 437, 307, 957, 293, 437, 307, 7592, 13, 823, 309, 311, 646, 281, 264, 19265, 13, 400, 264, 19265, 307, 516, 281, 808, 51312], "temperature": 0.0, "avg_logprob": -0.08056630558437772, "compression_ratio": 1.7798165137614679, "no_speech_prob": 0.000882997119333595}, {"id": 494, "seek": 281820, "start": 2837.16, "end": 2844.68, "text": " back. It's going to take instances of where the real data lie as inputs to train. And then it's", "tokens": [51312, 646, 13, 467, 311, 516, 281, 747, 14519, 295, 689, 264, 957, 1412, 4544, 382, 15743, 281, 3847, 13, 400, 550, 309, 311, 51688], "temperature": 0.0, "avg_logprob": -0.08056630558437772, "compression_ratio": 1.7798165137614679, "no_speech_prob": 0.000882997119333595}, {"id": 495, "seek": 284468, "start": 2844.68, "end": 2850.8399999999997, "text": " going to try to improve its imitation of the data, trying to move the fake data, the synthetic data", "tokens": [50364, 516, 281, 853, 281, 3470, 1080, 47624, 295, 264, 1412, 11, 1382, 281, 1286, 264, 7592, 1412, 11, 264, 23420, 1412, 50672], "temperature": 0.0, "avg_logprob": -0.05719574917568249, "compression_ratio": 1.8768472906403941, "no_speech_prob": 0.0005357616464607418}, {"id": 496, "seek": 284468, "start": 2850.8399999999997, "end": 2857.24, "text": " that is generated closer and closer to the real data. And once again, the discriminator is now", "tokens": [50672, 300, 307, 10833, 4966, 293, 4966, 281, 264, 957, 1412, 13, 400, 1564, 797, 11, 264, 20828, 1639, 307, 586, 50992], "temperature": 0.0, "avg_logprob": -0.05719574917568249, "compression_ratio": 1.8768472906403941, "no_speech_prob": 0.0005357616464607418}, {"id": 497, "seek": 284468, "start": 2857.24, "end": 2862.6, "text": " going to receive these new points. And it's going to estimate a probability that each of these points", "tokens": [50992, 516, 281, 4774, 613, 777, 2793, 13, 400, 309, 311, 516, 281, 12539, 257, 8482, 300, 1184, 295, 613, 2793, 51260], "temperature": 0.0, "avg_logprob": -0.05719574917568249, "compression_ratio": 1.8768472906403941, "no_speech_prob": 0.0005357616464607418}, {"id": 498, "seek": 284468, "start": 2862.6, "end": 2868.6, "text": " is real. And again, learn to decrease the probability of the fake points being real,", "tokens": [51260, 307, 957, 13, 400, 797, 11, 1466, 281, 11514, 264, 8482, 295, 264, 7592, 2793, 885, 957, 11, 51560], "temperature": 0.0, "avg_logprob": -0.05719574917568249, "compression_ratio": 1.8768472906403941, "no_speech_prob": 0.0005357616464607418}, {"id": 499, "seek": 286860, "start": 2869.24, "end": 2875.3199999999997, "text": " further and further. And now we're going to repeat again. And one last time, the generator is going", "tokens": [50396, 3052, 293, 3052, 13, 400, 586, 321, 434, 516, 281, 7149, 797, 13, 400, 472, 1036, 565, 11, 264, 19265, 307, 516, 50700], "temperature": 0.0, "avg_logprob": -0.05159160326111992, "compression_ratio": 1.8906882591093117, "no_speech_prob": 0.0017006432171911001}, {"id": 500, "seek": 286860, "start": 2875.3199999999997, "end": 2881.4, "text": " to start moving these fake points closer and closer to the real data, such that the fake", "tokens": [50700, 281, 722, 2684, 613, 7592, 2793, 4966, 293, 4966, 281, 264, 957, 1412, 11, 1270, 300, 264, 7592, 51004], "temperature": 0.0, "avg_logprob": -0.05159160326111992, "compression_ratio": 1.8906882591093117, "no_speech_prob": 0.0017006432171911001}, {"id": 501, "seek": 286860, "start": 2881.4, "end": 2887.24, "text": " data are almost following the distribution of the real data. At this point, it's going to be", "tokens": [51004, 1412, 366, 1920, 3480, 264, 7316, 295, 264, 957, 1412, 13, 1711, 341, 935, 11, 309, 311, 516, 281, 312, 51296], "temperature": 0.0, "avg_logprob": -0.05159160326111992, "compression_ratio": 1.8906882591093117, "no_speech_prob": 0.0017006432171911001}, {"id": 502, "seek": 286860, "start": 2887.24, "end": 2892.12, "text": " really, really hard for the discriminator to effectively distinguish between what is real", "tokens": [51296, 534, 11, 534, 1152, 337, 264, 20828, 1639, 281, 8659, 20206, 1296, 437, 307, 957, 51540], "temperature": 0.0, "avg_logprob": -0.05159160326111992, "compression_ratio": 1.8906882591093117, "no_speech_prob": 0.0017006432171911001}, {"id": 503, "seek": 286860, "start": 2892.12, "end": 2897.88, "text": " and what is fake. While the generator is going to continue to try to create fake data instances", "tokens": [51540, 293, 437, 307, 7592, 13, 3987, 264, 19265, 307, 516, 281, 2354, 281, 853, 281, 1884, 7592, 1412, 14519, 51828], "temperature": 0.0, "avg_logprob": -0.05159160326111992, "compression_ratio": 1.8906882591093117, "no_speech_prob": 0.0017006432171911001}, {"id": 504, "seek": 289788, "start": 2897.88, "end": 2904.28, "text": " to fool the discriminator. And this is really the key intuition behind how these two components of", "tokens": [50364, 281, 7979, 264, 20828, 1639, 13, 400, 341, 307, 534, 264, 2141, 24002, 2261, 577, 613, 732, 6677, 295, 50684], "temperature": 0.0, "avg_logprob": -0.07906543249371407, "compression_ratio": 1.7361111111111112, "no_speech_prob": 0.001032171887345612}, {"id": 505, "seek": 289788, "start": 2904.28, "end": 2912.12, "text": " GANs are essentially competing with each other. All right. So to summarize how we train GANs,", "tokens": [50684, 460, 1770, 82, 366, 4476, 15439, 365, 1184, 661, 13, 1057, 558, 13, 407, 281, 20858, 577, 321, 3847, 460, 1770, 82, 11, 51076], "temperature": 0.0, "avg_logprob": -0.07906543249371407, "compression_ratio": 1.7361111111111112, "no_speech_prob": 0.001032171887345612}, {"id": 506, "seek": 289788, "start": 2912.12, "end": 2917.7200000000003, "text": " the generator is going to try to synthesize fake instances to fool a discriminator, which is going", "tokens": [51076, 264, 19265, 307, 516, 281, 853, 281, 26617, 1125, 7592, 14519, 281, 7979, 257, 20828, 1639, 11, 597, 307, 516, 51356], "temperature": 0.0, "avg_logprob": -0.07906543249371407, "compression_ratio": 1.7361111111111112, "no_speech_prob": 0.001032171887345612}, {"id": 507, "seek": 289788, "start": 2917.7200000000003, "end": 2922.92, "text": " to be trained to identify the synthesized instances and discriminate these as fake.", "tokens": [51356, 281, 312, 8895, 281, 5876, 264, 26617, 1602, 14519, 293, 47833, 613, 382, 7592, 13, 51616], "temperature": 0.0, "avg_logprob": -0.07906543249371407, "compression_ratio": 1.7361111111111112, "no_speech_prob": 0.001032171887345612}, {"id": 508, "seek": 292292, "start": 2922.92, "end": 2929.32, "text": " To actually train, we're going to see that we are going to define a loss function that defines", "tokens": [50364, 1407, 767, 3847, 11, 321, 434, 516, 281, 536, 300, 321, 366, 516, 281, 6964, 257, 4470, 2445, 300, 23122, 50684], "temperature": 0.0, "avg_logprob": -0.11173975312864626, "compression_ratio": 1.7311320754716981, "no_speech_prob": 0.0010322043672204018}, {"id": 509, "seek": 292292, "start": 2930.36, "end": 2935.0, "text": " competing and adversarial objectives for each of the discriminator and the generator.", "tokens": [50736, 15439, 293, 17641, 44745, 15961, 337, 1184, 295, 264, 20828, 1639, 293, 264, 19265, 13, 50968], "temperature": 0.0, "avg_logprob": -0.11173975312864626, "compression_ratio": 1.7311320754716981, "no_speech_prob": 0.0010322043672204018}, {"id": 510, "seek": 292292, "start": 2935.7200000000003, "end": 2941.7200000000003, "text": " And a global optimum, the best we could possibly do would mean that the generator could perfectly", "tokens": [51004, 400, 257, 4338, 39326, 11, 264, 1151, 321, 727, 6264, 360, 576, 914, 300, 264, 19265, 727, 6239, 51304], "temperature": 0.0, "avg_logprob": -0.11173975312864626, "compression_ratio": 1.7311320754716981, "no_speech_prob": 0.0010322043672204018}, {"id": 511, "seek": 292292, "start": 2941.7200000000003, "end": 2947.0, "text": " reproduce the true data distribution, such that the discriminator absolutely cannot tell", "tokens": [51304, 29501, 264, 2074, 1412, 7316, 11, 1270, 300, 264, 20828, 1639, 3122, 2644, 980, 51568], "temperature": 0.0, "avg_logprob": -0.11173975312864626, "compression_ratio": 1.7311320754716981, "no_speech_prob": 0.0010322043672204018}, {"id": 512, "seek": 294700, "start": 2947.0, "end": 2952.2, "text": " what's synthetic versus what's real. So let's go through how the loss function", "tokens": [50364, 437, 311, 23420, 5717, 437, 311, 957, 13, 407, 718, 311, 352, 807, 577, 264, 4470, 2445, 50624], "temperature": 0.0, "avg_logprob": -0.06881110072135925, "compression_ratio": 1.5913461538461537, "no_speech_prob": 0.0005033233319409192}, {"id": 513, "seek": 294700, "start": 2952.2, "end": 2960.28, "text": " for GAN breaks down. The loss term for GAN is based on that familiar cross entropy loss.", "tokens": [50624, 337, 460, 1770, 9857, 760, 13, 440, 4470, 1433, 337, 460, 1770, 307, 2361, 322, 300, 4963, 3278, 30867, 4470, 13, 51028], "temperature": 0.0, "avg_logprob": -0.06881110072135925, "compression_ratio": 1.5913461538461537, "no_speech_prob": 0.0005033233319409192}, {"id": 514, "seek": 294700, "start": 2960.28, "end": 2965.8, "text": " And it's going to now be defined between the true and generated distributions.", "tokens": [51028, 400, 309, 311, 516, 281, 586, 312, 7642, 1296, 264, 2074, 293, 10833, 37870, 13, 51304], "temperature": 0.0, "avg_logprob": -0.06881110072135925, "compression_ratio": 1.5913461538461537, "no_speech_prob": 0.0005033233319409192}, {"id": 515, "seek": 294700, "start": 2965.8, "end": 2970.28, "text": " So we're first going to consider the loss from the perspective of the discriminator.", "tokens": [51304, 407, 321, 434, 700, 516, 281, 1949, 264, 4470, 490, 264, 4585, 295, 264, 20828, 1639, 13, 51528], "temperature": 0.0, "avg_logprob": -0.06881110072135925, "compression_ratio": 1.5913461538461537, "no_speech_prob": 0.0005033233319409192}, {"id": 516, "seek": 297028, "start": 2970.92, "end": 2978.0400000000004, "text": " We want to try to maximize the probability that the fake data is identified as fake.", "tokens": [50396, 492, 528, 281, 853, 281, 19874, 264, 8482, 300, 264, 7592, 1412, 307, 9234, 382, 7592, 13, 50752], "temperature": 0.0, "avg_logprob": -0.11445953106058054, "compression_ratio": 1.9447513812154695, "no_speech_prob": 0.003483295440673828}, {"id": 517, "seek": 297028, "start": 2978.76, "end": 2985.6400000000003, "text": " And so to break this down here, G of Z defines the generator's output. And so D of G of Z", "tokens": [50788, 400, 370, 281, 1821, 341, 760, 510, 11, 460, 295, 1176, 23122, 264, 19265, 311, 5598, 13, 400, 370, 413, 295, 460, 295, 1176, 51132], "temperature": 0.0, "avg_logprob": -0.11445953106058054, "compression_ratio": 1.9447513812154695, "no_speech_prob": 0.003483295440673828}, {"id": 518, "seek": 297028, "start": 2986.28, "end": 2991.2400000000002, "text": " is the discriminator's estimate of the probability that a fake instance is actually fake.", "tokens": [51164, 307, 264, 20828, 1639, 311, 12539, 295, 264, 8482, 300, 257, 7592, 5197, 307, 767, 7592, 13, 51412], "temperature": 0.0, "avg_logprob": -0.11445953106058054, "compression_ratio": 1.9447513812154695, "no_speech_prob": 0.003483295440673828}, {"id": 519, "seek": 297028, "start": 2992.6000000000004, "end": 2998.0400000000004, "text": " D of X is the discriminator's estimate of the probability that a real instance is fake.", "tokens": [51480, 413, 295, 1783, 307, 264, 20828, 1639, 311, 12539, 295, 264, 8482, 300, 257, 957, 5197, 307, 7592, 13, 51752], "temperature": 0.0, "avg_logprob": -0.11445953106058054, "compression_ratio": 1.9447513812154695, "no_speech_prob": 0.003483295440673828}, {"id": 520, "seek": 299804, "start": 2998.04, "end": 3003.48, "text": " So 1 minus D of X is its probability estimate that a real instance is real.", "tokens": [50364, 407, 502, 3175, 413, 295, 1783, 307, 1080, 8482, 12539, 300, 257, 957, 5197, 307, 957, 13, 50636], "temperature": 0.0, "avg_logprob": -0.09107840657234192, "compression_ratio": 1.7448979591836735, "no_speech_prob": 4.832489867112599e-05}, {"id": 521, "seek": 299804, "start": 3004.44, "end": 3009.64, "text": " So together, from the point of view of the discriminator, we want to maximize this probability.", "tokens": [50684, 407, 1214, 11, 490, 264, 935, 295, 1910, 295, 264, 20828, 1639, 11, 321, 528, 281, 19874, 341, 8482, 13, 50944], "temperature": 0.0, "avg_logprob": -0.09107840657234192, "compression_ratio": 1.7448979591836735, "no_speech_prob": 4.832489867112599e-05}, {"id": 522, "seek": 299804, "start": 3010.2, "end": 3014.92, "text": " Maximize probability fake is fake. Maximize the estimate of probability real is real.", "tokens": [50972, 29076, 1125, 8482, 7592, 307, 7592, 13, 29076, 1125, 264, 12539, 295, 8482, 957, 307, 957, 13, 51208], "temperature": 0.0, "avg_logprob": -0.09107840657234192, "compression_ratio": 1.7448979591836735, "no_speech_prob": 4.832489867112599e-05}, {"id": 523, "seek": 299804, "start": 3016.52, "end": 3021.32, "text": " Now let's turn our attention to the generator. Remember that the generator is taking", "tokens": [51288, 823, 718, 311, 1261, 527, 3202, 281, 264, 19265, 13, 5459, 300, 264, 19265, 307, 1940, 51528], "temperature": 0.0, "avg_logprob": -0.09107840657234192, "compression_ratio": 1.7448979591836735, "no_speech_prob": 4.832489867112599e-05}, {"id": 524, "seek": 302132, "start": 3021.88, "end": 3028.1200000000003, "text": " random noise and generating an instance. It cannot directly affect the term D of X,", "tokens": [50392, 4974, 5658, 293, 17746, 364, 5197, 13, 467, 2644, 3838, 3345, 264, 1433, 413, 295, 1783, 11, 50704], "temperature": 0.0, "avg_logprob": -0.06732074050016182, "compression_ratio": 1.6619718309859155, "no_speech_prob": 0.010651825927197933}, {"id": 525, "seek": 302132, "start": 3028.76, "end": 3034.84, "text": " which shows up in the loss, right? Because D of X is solely based on the discriminator's operation", "tokens": [50736, 597, 3110, 493, 294, 264, 4470, 11, 558, 30, 1436, 413, 295, 1783, 307, 23309, 2361, 322, 264, 20828, 1639, 311, 6916, 51040], "temperature": 0.0, "avg_logprob": -0.06732074050016182, "compression_ratio": 1.6619718309859155, "no_speech_prob": 0.010651825927197933}, {"id": 526, "seek": 302132, "start": 3034.84, "end": 3039.88, "text": " on the real data. So for the generator, the generator is going to have the adversarial", "tokens": [51040, 322, 264, 957, 1412, 13, 407, 337, 264, 19265, 11, 264, 19265, 307, 516, 281, 362, 264, 17641, 44745, 51292], "temperature": 0.0, "avg_logprob": -0.06732074050016182, "compression_ratio": 1.6619718309859155, "no_speech_prob": 0.010651825927197933}, {"id": 527, "seek": 302132, "start": 3039.88, "end": 3045.1600000000003, "text": " objective to the discriminator, which means it's going to try to minimize this term.", "tokens": [51292, 10024, 281, 264, 20828, 1639, 11, 597, 1355, 309, 311, 516, 281, 853, 281, 17522, 341, 1433, 13, 51556], "temperature": 0.0, "avg_logprob": -0.06732074050016182, "compression_ratio": 1.6619718309859155, "no_speech_prob": 0.010651825927197933}, {"id": 528, "seek": 304516, "start": 3046.12, "end": 3055.0, "text": " Effectively minimizing the probability that the discriminator can distinguish its generated data", "tokens": [50412, 17764, 3413, 46608, 264, 8482, 300, 264, 20828, 1639, 393, 20206, 1080, 10833, 1412, 50856], "temperature": 0.0, "avg_logprob": -0.17095333735148113, "compression_ratio": 1.6459627329192548, "no_speech_prob": 0.0006070572417229414}, {"id": 529, "seek": 304516, "start": 3055.96, "end": 3065.16, "text": " as fake. D of G of Z. And the goal for the generator is to minimize this term of the objective.", "tokens": [50904, 382, 7592, 13, 413, 295, 460, 295, 1176, 13, 400, 264, 3387, 337, 264, 19265, 307, 281, 17522, 341, 1433, 295, 264, 10024, 13, 51364], "temperature": 0.0, "avg_logprob": -0.17095333735148113, "compression_ratio": 1.6459627329192548, "no_speech_prob": 0.0006070572417229414}, {"id": 530, "seek": 304516, "start": 3067.72, "end": 3073.72, "text": " So the objective of the generator is to try to synthesize fake instances", "tokens": [51492, 407, 264, 10024, 295, 264, 19265, 307, 281, 853, 281, 26617, 1125, 7592, 14519, 51792], "temperature": 0.0, "avg_logprob": -0.17095333735148113, "compression_ratio": 1.6459627329192548, "no_speech_prob": 0.0006070572417229414}, {"id": 531, "seek": 307372, "start": 3073.72, "end": 3078.6, "text": " that fool the discriminator. And eventually, over the course of training the discriminator,", "tokens": [50364, 300, 7979, 264, 20828, 1639, 13, 400, 4728, 11, 670, 264, 1164, 295, 3097, 264, 20828, 1639, 11, 50608], "temperature": 0.0, "avg_logprob": -0.08122349702394925, "compression_ratio": 1.8503937007874016, "no_speech_prob": 0.0033761262893676758}, {"id": 532, "seek": 307372, "start": 3078.6, "end": 3084.52, "text": " the discriminator is going to be as best as it possibly can be at discriminating real versus", "tokens": [50608, 264, 20828, 1639, 307, 516, 281, 312, 382, 1151, 382, 309, 6264, 393, 312, 412, 20828, 990, 957, 5717, 50904], "temperature": 0.0, "avg_logprob": -0.08122349702394925, "compression_ratio": 1.8503937007874016, "no_speech_prob": 0.0033761262893676758}, {"id": 533, "seek": 307372, "start": 3084.52, "end": 3090.4399999999996, "text": " fake. Therefore, the ultimate goal of the generator is to synthesize fake instances that fool the", "tokens": [50904, 7592, 13, 7504, 11, 264, 9705, 3387, 295, 264, 19265, 307, 281, 26617, 1125, 7592, 14519, 300, 7979, 264, 51200], "temperature": 0.0, "avg_logprob": -0.08122349702394925, "compression_ratio": 1.8503937007874016, "no_speech_prob": 0.0033761262893676758}, {"id": 534, "seek": 307372, "start": 3090.4399999999996, "end": 3096.52, "text": " best discriminator. And this is all put together in this min max objective function, which has", "tokens": [51200, 1151, 20828, 1639, 13, 400, 341, 307, 439, 829, 1214, 294, 341, 923, 11469, 10024, 2445, 11, 597, 575, 51504], "temperature": 0.0, "avg_logprob": -0.08122349702394925, "compression_ratio": 1.8503937007874016, "no_speech_prob": 0.0033761262893676758}, {"id": 535, "seek": 307372, "start": 3096.52, "end": 3102.68, "text": " these two components optimized adversarily. And then after training, we can actually use the", "tokens": [51504, 613, 732, 6677, 26941, 17641, 3289, 13, 400, 550, 934, 3097, 11, 321, 393, 767, 764, 264, 51812], "temperature": 0.0, "avg_logprob": -0.08122349702394925, "compression_ratio": 1.8503937007874016, "no_speech_prob": 0.0033761262893676758}, {"id": 536, "seek": 310268, "start": 3102.68, "end": 3108.3599999999997, "text": " generator network, which is now fully trained to produce new data instances that have never been", "tokens": [50364, 19265, 3209, 11, 597, 307, 586, 4498, 8895, 281, 5258, 777, 1412, 14519, 300, 362, 1128, 668, 50648], "temperature": 0.0, "avg_logprob": -0.069321590311387, "compression_ratio": 1.7709923664122138, "no_speech_prob": 0.0010321661829948425}, {"id": 537, "seek": 310268, "start": 3108.3599999999997, "end": 3114.8399999999997, "text": " seen before. So we're going to focus on that now. And what is really cool is that when the", "tokens": [50648, 1612, 949, 13, 407, 321, 434, 516, 281, 1879, 322, 300, 586, 13, 400, 437, 307, 534, 1627, 307, 300, 562, 264, 50972], "temperature": 0.0, "avg_logprob": -0.069321590311387, "compression_ratio": 1.7709923664122138, "no_speech_prob": 0.0010321661829948425}, {"id": 538, "seek": 310268, "start": 3114.8399999999997, "end": 3121.48, "text": " trained generator of again, synthesizes new instances, it's effectively learning a transformation", "tokens": [50972, 8895, 19265, 295, 797, 11, 26617, 5660, 777, 14519, 11, 309, 311, 8659, 2539, 257, 9887, 51304], "temperature": 0.0, "avg_logprob": -0.069321590311387, "compression_ratio": 1.7709923664122138, "no_speech_prob": 0.0010321661829948425}, {"id": 539, "seek": 310268, "start": 3121.48, "end": 3127.24, "text": " from a distribution of noise to a target data distribution. And that transformation,", "tokens": [51304, 490, 257, 7316, 295, 5658, 281, 257, 3779, 1412, 7316, 13, 400, 300, 9887, 11, 51592], "temperature": 0.0, "avg_logprob": -0.069321590311387, "compression_ratio": 1.7709923664122138, "no_speech_prob": 0.0010321661829948425}, {"id": 540, "seek": 310268, "start": 3127.24, "end": 3132.2, "text": " that mapping is going to be what's learned over the course of training. So if we consider one", "tokens": [51592, 300, 18350, 307, 516, 281, 312, 437, 311, 3264, 670, 264, 1164, 295, 3097, 13, 407, 498, 321, 1949, 472, 51840], "temperature": 0.0, "avg_logprob": -0.069321590311387, "compression_ratio": 1.7709923664122138, "no_speech_prob": 0.0010321661829948425}, {"id": 541, "seek": 313220, "start": 3132.2, "end": 3137.56, "text": " point from a latent noise distribution, it's going to result in a particular output in the", "tokens": [50364, 935, 490, 257, 48994, 5658, 7316, 11, 309, 311, 516, 281, 1874, 294, 257, 1729, 5598, 294, 264, 50632], "temperature": 0.0, "avg_logprob": -0.06325154412876476, "compression_ratio": 1.7777777777777777, "no_speech_prob": 0.0017005280824378133}, {"id": 542, "seek": 313220, "start": 3137.56, "end": 3143.7999999999997, "text": " target data space. And if we consider another point of random noise, feed it through the generator,", "tokens": [50632, 3779, 1412, 1901, 13, 400, 498, 321, 1949, 1071, 935, 295, 4974, 5658, 11, 3154, 309, 807, 264, 19265, 11, 50944], "temperature": 0.0, "avg_logprob": -0.06325154412876476, "compression_ratio": 1.7777777777777777, "no_speech_prob": 0.0017005280824378133}, {"id": 543, "seek": 313220, "start": 3143.7999999999997, "end": 3149.16, "text": " it's going to result in a new instance that and that new instance is going to fall somewhere else", "tokens": [50944, 309, 311, 516, 281, 1874, 294, 257, 777, 5197, 300, 293, 300, 777, 5197, 307, 516, 281, 2100, 4079, 1646, 51212], "temperature": 0.0, "avg_logprob": -0.06325154412876476, "compression_ratio": 1.7777777777777777, "no_speech_prob": 0.0017005280824378133}, {"id": 544, "seek": 313220, "start": 3149.16, "end": 3156.2799999999997, "text": " on the data manifold. And indeed, what we can actually do is interpolate and trans and traverse", "tokens": [51212, 322, 264, 1412, 47138, 13, 400, 6451, 11, 437, 321, 393, 767, 360, 307, 44902, 473, 293, 1145, 293, 45674, 51568], "temperature": 0.0, "avg_logprob": -0.06325154412876476, "compression_ratio": 1.7777777777777777, "no_speech_prob": 0.0017005280824378133}, {"id": 545, "seek": 315628, "start": 3156.28, "end": 3162.1200000000003, "text": " in the space of Gaussian noise to result in interpolation in the target space. And you can", "tokens": [50364, 294, 264, 1901, 295, 39148, 5658, 281, 1874, 294, 44902, 399, 294, 264, 3779, 1901, 13, 400, 291, 393, 50656], "temperature": 0.0, "avg_logprob": -0.08616825552547679, "compression_ratio": 1.6743119266055047, "no_speech_prob": 0.0030752280727028847}, {"id": 546, "seek": 315628, "start": 3162.1200000000003, "end": 3168.44, "text": " see an example of this result here, where a transformation in series reflects a traversal", "tokens": [50656, 536, 364, 1365, 295, 341, 1874, 510, 11, 689, 257, 9887, 294, 2638, 18926, 257, 23149, 304, 50972], "temperature": 0.0, "avg_logprob": -0.08616825552547679, "compression_ratio": 1.6743119266055047, "no_speech_prob": 0.0030752280727028847}, {"id": 547, "seek": 315628, "start": 3168.44, "end": 3175.32, "text": " across the target data manifold. And that's produced in the synthetic examples that are", "tokens": [50972, 2108, 264, 3779, 1412, 47138, 13, 400, 300, 311, 7126, 294, 264, 23420, 5110, 300, 366, 51316], "temperature": 0.0, "avg_logprob": -0.08616825552547679, "compression_ratio": 1.6743119266055047, "no_speech_prob": 0.0030752280727028847}, {"id": 548, "seek": 315628, "start": 3175.32, "end": 3181.1600000000003, "text": " outputted by the generator. All right. So in the final few minutes of this lecture, I'm going to", "tokens": [51316, 5598, 14727, 538, 264, 19265, 13, 1057, 558, 13, 407, 294, 264, 2572, 1326, 2077, 295, 341, 7991, 11, 286, 478, 516, 281, 51608], "temperature": 0.0, "avg_logprob": -0.08616825552547679, "compression_ratio": 1.6743119266055047, "no_speech_prob": 0.0030752280727028847}, {"id": 549, "seek": 318116, "start": 3181.16, "end": 3187.56, "text": " highlight some of the recent advances in GANs and hopefully motivate even further why this approach", "tokens": [50364, 5078, 512, 295, 264, 5162, 25297, 294, 460, 1770, 82, 293, 4696, 28497, 754, 3052, 983, 341, 3109, 50684], "temperature": 0.0, "avg_logprob": -0.06696308531412264, "compression_ratio": 1.6440677966101696, "no_speech_prob": 0.0014102981658652425}, {"id": 550, "seek": 318116, "start": 3187.56, "end": 3194.52, "text": " is so powerful. So one idea that's been extremely, extremely powerful is this idea of progressive", "tokens": [50684, 307, 370, 4005, 13, 407, 472, 1558, 300, 311, 668, 4664, 11, 4664, 4005, 307, 341, 1558, 295, 16131, 51032], "temperature": 0.0, "avg_logprob": -0.06696308531412264, "compression_ratio": 1.6440677966101696, "no_speech_prob": 0.0014102981658652425}, {"id": 551, "seek": 318116, "start": 3194.52, "end": 3200.8399999999997, "text": " GANs, progressive growing, which means that we can iteratively build more detail into the", "tokens": [51032, 460, 1770, 82, 11, 16131, 4194, 11, 597, 1355, 300, 321, 393, 17138, 19020, 1322, 544, 2607, 666, 264, 51348], "temperature": 0.0, "avg_logprob": -0.06696308531412264, "compression_ratio": 1.6440677966101696, "no_speech_prob": 0.0014102981658652425}, {"id": 552, "seek": 318116, "start": 3200.8399999999997, "end": 3208.2799999999997, "text": " generated instances that are produced. And this is done by progressively adding layers of increasing", "tokens": [51348, 10833, 14519, 300, 366, 7126, 13, 400, 341, 307, 1096, 538, 46667, 5127, 7914, 295, 5662, 51720], "temperature": 0.0, "avg_logprob": -0.06696308531412264, "compression_ratio": 1.6440677966101696, "no_speech_prob": 0.0014102981658652425}, {"id": 553, "seek": 320828, "start": 3208.28, "end": 3215.1600000000003, "text": " spatial resolution in the case of image data. And by incrementally building up both the generator", "tokens": [50364, 23598, 8669, 294, 264, 1389, 295, 3256, 1412, 13, 400, 538, 26200, 379, 2390, 493, 1293, 264, 19265, 50708], "temperature": 0.0, "avg_logprob": -0.07849296927452087, "compression_ratio": 1.6652173913043478, "no_speech_prob": 0.0007321473676711321}, {"id": 554, "seek": 320828, "start": 3215.1600000000003, "end": 3221.2400000000002, "text": " and discriminator networks in this way as training progresses, it results in very well resolved", "tokens": [50708, 293, 20828, 1639, 9590, 294, 341, 636, 382, 3097, 41929, 11, 309, 3542, 294, 588, 731, 20772, 51012], "temperature": 0.0, "avg_logprob": -0.07849296927452087, "compression_ratio": 1.6652173913043478, "no_speech_prob": 0.0007321473676711321}, {"id": 555, "seek": 320828, "start": 3221.2400000000002, "end": 3227.48, "text": " synthetic images that are output ultimately by the generator. So some results of this idea of", "tokens": [51012, 23420, 5267, 300, 366, 5598, 6284, 538, 264, 19265, 13, 407, 512, 3542, 295, 341, 1558, 295, 51324], "temperature": 0.0, "avg_logprob": -0.07849296927452087, "compression_ratio": 1.6652173913043478, "no_speech_prob": 0.0007321473676711321}, {"id": 556, "seek": 320828, "start": 3227.48, "end": 3234.76, "text": " progressive, a progressive GAN are displayed here. Another idea that has also led to tremendous", "tokens": [51324, 16131, 11, 257, 16131, 460, 1770, 366, 16372, 510, 13, 3996, 1558, 300, 575, 611, 4684, 281, 10048, 51688], "temperature": 0.0, "avg_logprob": -0.07849296927452087, "compression_ratio": 1.6652173913043478, "no_speech_prob": 0.0007321473676711321}, {"id": 557, "seek": 323476, "start": 3234.76, "end": 3241.0, "text": " improvement in the quality of synthetic examples generated by GANs is a architecture improvement", "tokens": [50364, 10444, 294, 264, 3125, 295, 23420, 5110, 10833, 538, 460, 1770, 82, 307, 257, 9482, 10444, 50676], "temperature": 0.0, "avg_logprob": -0.07265717306254822, "compression_ratio": 1.6150627615062763, "no_speech_prob": 0.0014102946734055877}, {"id": 558, "seek": 323476, "start": 3241.0, "end": 3246.44, "text": " called style GAN, which combines this idea of progressive growing that I introduced earlier", "tokens": [50676, 1219, 3758, 460, 1770, 11, 597, 29520, 341, 1558, 295, 16131, 4194, 300, 286, 7268, 3071, 50948], "temperature": 0.0, "avg_logprob": -0.07265717306254822, "compression_ratio": 1.6150627615062763, "no_speech_prob": 0.0014102946734055877}, {"id": 559, "seek": 323476, "start": 3246.44, "end": 3253.0, "text": " with principles of style transfer, which means trying to compose an image in the style of another", "tokens": [50948, 365, 9156, 295, 3758, 5003, 11, 597, 1355, 1382, 281, 35925, 364, 3256, 294, 264, 3758, 295, 1071, 51276], "temperature": 0.0, "avg_logprob": -0.07265717306254822, "compression_ratio": 1.6150627615062763, "no_speech_prob": 0.0014102946734055877}, {"id": 560, "seek": 323476, "start": 3253.0, "end": 3262.5200000000004, "text": " image. So for example, what we can now achieve is to map input images source A using application of", "tokens": [51276, 3256, 13, 407, 337, 1365, 11, 437, 321, 393, 586, 4584, 307, 281, 4471, 4846, 5267, 4009, 316, 1228, 3861, 295, 51752], "temperature": 0.0, "avg_logprob": -0.07265717306254822, "compression_ratio": 1.6150627615062763, "no_speech_prob": 0.0014102946734055877}, {"id": 561, "seek": 326252, "start": 3262.52, "end": 3269.08, "text": " coarse grained styles from secondary sources onto those targets to generate new instances", "tokens": [50364, 39312, 1295, 2001, 13273, 490, 11396, 7139, 3911, 729, 12911, 281, 8460, 777, 14519, 50692], "temperature": 0.0, "avg_logprob": -0.0677478680243859, "compression_ratio": 1.691588785046729, "no_speech_prob": 0.00037997463368810713}, {"id": 562, "seek": 326252, "start": 3269.08, "end": 3277.08, "text": " that mimic the style of source B. And that result is shown here. And hopefully you can", "tokens": [50692, 300, 31075, 264, 3758, 295, 4009, 363, 13, 400, 300, 1874, 307, 4898, 510, 13, 400, 4696, 291, 393, 51092], "temperature": 0.0, "avg_logprob": -0.0677478680243859, "compression_ratio": 1.691588785046729, "no_speech_prob": 0.00037997463368810713}, {"id": 563, "seek": 326252, "start": 3277.08, "end": 3282.68, "text": " appreciate that these coarse grained features, these coarse grained styles like age, facial", "tokens": [51092, 4449, 300, 613, 39312, 1295, 2001, 4122, 11, 613, 39312, 1295, 2001, 13273, 411, 3205, 11, 15642, 51372], "temperature": 0.0, "avg_logprob": -0.0677478680243859, "compression_ratio": 1.691588785046729, "no_speech_prob": 0.00037997463368810713}, {"id": 564, "seek": 326252, "start": 3282.68, "end": 3290.2, "text": " structure, things like that can be reflected in these synthetic examples. This same style GAN", "tokens": [51372, 3877, 11, 721, 411, 300, 393, 312, 15502, 294, 613, 23420, 5110, 13, 639, 912, 3758, 460, 1770, 51748], "temperature": 0.0, "avg_logprob": -0.0677478680243859, "compression_ratio": 1.691588785046729, "no_speech_prob": 0.00037997463368810713}, {"id": 565, "seek": 329020, "start": 3290.2, "end": 3298.4399999999996, "text": " system has led to tremendously realistic synthetic images in the areas of both face", "tokens": [50364, 1185, 575, 4684, 281, 27985, 12465, 23420, 5267, 294, 264, 3179, 295, 1293, 1851, 50776], "temperature": 0.0, "avg_logprob": -0.06466256459554036, "compression_ratio": 1.6163793103448276, "no_speech_prob": 4.400031684781425e-05}, {"id": 566, "seek": 329020, "start": 3298.4399999999996, "end": 3306.9199999999996, "text": " synthesis as well as for animals, other objects as well. Another extension to the GAN architecture", "tokens": [50776, 30252, 382, 731, 382, 337, 4882, 11, 661, 6565, 382, 731, 13, 3996, 10320, 281, 264, 460, 1770, 9482, 51200], "temperature": 0.0, "avg_logprob": -0.06466256459554036, "compression_ratio": 1.6163793103448276, "no_speech_prob": 4.400031684781425e-05}, {"id": 567, "seek": 329020, "start": 3306.9199999999996, "end": 3313.8799999999997, "text": " that has enabled particularly powerful applications for select problems and tasks is this idea of", "tokens": [51200, 300, 575, 15172, 4098, 4005, 5821, 337, 3048, 2740, 293, 9608, 307, 341, 1558, 295, 51548], "temperature": 0.0, "avg_logprob": -0.06466256459554036, "compression_ratio": 1.6163793103448276, "no_speech_prob": 4.400031684781425e-05}, {"id": 568, "seek": 329020, "start": 3313.8799999999997, "end": 3319.8799999999997, "text": " conditioning, which imposes a bit of additional further structure on the types of outputs that", "tokens": [51548, 21901, 11, 597, 704, 4201, 257, 857, 295, 4497, 3052, 3877, 322, 264, 3467, 295, 23930, 300, 51848], "temperature": 0.0, "avg_logprob": -0.06466256459554036, "compression_ratio": 1.6163793103448276, "no_speech_prob": 4.400031684781425e-05}, {"id": 569, "seek": 331988, "start": 3319.88, "end": 3327.2400000000002, "text": " can be synthesized by GAN. So the idea here is to condition on a particular label by supplying", "tokens": [50364, 393, 312, 26617, 1602, 538, 460, 1770, 13, 407, 264, 1558, 510, 307, 281, 4188, 322, 257, 1729, 7645, 538, 46815, 50732], "temperature": 0.0, "avg_logprob": -0.07979303857554561, "compression_ratio": 1.5360824742268042, "no_speech_prob": 7.141623791540042e-05}, {"id": 570, "seek": 331988, "start": 3327.2400000000002, "end": 3335.32, "text": " what is called a conditioning factor denoted here as C. And what this allows us to achieve is instances", "tokens": [50732, 437, 307, 1219, 257, 21901, 5952, 1441, 23325, 510, 382, 383, 13, 400, 437, 341, 4045, 505, 281, 4584, 307, 14519, 51136], "temperature": 0.0, "avg_logprob": -0.07979303857554561, "compression_ratio": 1.5360824742268042, "no_speech_prob": 7.141623791540042e-05}, {"id": 571, "seek": 331988, "start": 3335.32, "end": 3343.32, "text": " like that of paired translation in the case of image synthesis, where now instead of a single input", "tokens": [51136, 411, 300, 295, 25699, 12853, 294, 264, 1389, 295, 3256, 30252, 11, 689, 586, 2602, 295, 257, 2167, 4846, 51536], "temperature": 0.0, "avg_logprob": -0.07979303857554561, "compression_ratio": 1.5360824742268042, "no_speech_prob": 7.141623791540042e-05}, {"id": 572, "seek": 334332, "start": 3343.96, "end": 3350.04, "text": " as training data for our generator, we have pairs of inputs. So for example here we consider", "tokens": [50396, 382, 3097, 1412, 337, 527, 19265, 11, 321, 362, 15494, 295, 15743, 13, 407, 337, 1365, 510, 321, 1949, 50700], "temperature": 0.0, "avg_logprob": -0.07793578540577609, "compression_ratio": 1.75, "no_speech_prob": 0.01854410022497177}, {"id": 573, "seek": 334332, "start": 3350.04, "end": 3356.6800000000003, "text": " both a driving scene and a corresponding segmentation map to that driving scene. And the discriminator", "tokens": [50700, 1293, 257, 4840, 4145, 293, 257, 11760, 9469, 399, 4471, 281, 300, 4840, 4145, 13, 400, 264, 20828, 1639, 51032], "temperature": 0.0, "avg_logprob": -0.07793578540577609, "compression_ratio": 1.75, "no_speech_prob": 0.01854410022497177}, {"id": 574, "seek": 334332, "start": 3356.6800000000003, "end": 3364.44, "text": " can in turn be trained to classify fake and real pairs of data. And again the generator is going", "tokens": [51032, 393, 294, 1261, 312, 8895, 281, 33872, 7592, 293, 957, 15494, 295, 1412, 13, 400, 797, 264, 19265, 307, 516, 51420], "temperature": 0.0, "avg_logprob": -0.07793578540577609, "compression_ratio": 1.75, "no_speech_prob": 0.01854410022497177}, {"id": 575, "seek": 334332, "start": 3364.44, "end": 3373.0800000000004, "text": " to be trained to try to fool the discriminator. Example applications of this idea are", "tokens": [51420, 281, 312, 8895, 281, 853, 281, 7979, 264, 20828, 1639, 13, 24755, 781, 5821, 295, 341, 1558, 366, 51852], "temperature": 0.0, "avg_logprob": -0.07793578540577609, "compression_ratio": 1.75, "no_speech_prob": 0.01854410022497177}, {"id": 576, "seek": 337332, "start": 3374.28, "end": 3380.92, "text": " seen as follows where we can now go from an input of a semantic segmentation map to generate a", "tokens": [50412, 1612, 382, 10002, 689, 321, 393, 586, 352, 490, 364, 4846, 295, 257, 47982, 9469, 399, 4471, 281, 8460, 257, 50744], "temperature": 0.0, "avg_logprob": -0.1259450912475586, "compression_ratio": 1.7777777777777777, "no_speech_prob": 0.0038239615969359875}, {"id": 577, "seek": 337332, "start": 3380.92, "end": 3389.0, "text": " synthetic street scene mapping according to that segmentation. Or we can go from an aerial view", "tokens": [50744, 23420, 4838, 4145, 18350, 4650, 281, 300, 9469, 399, 13, 1610, 321, 393, 352, 490, 364, 31026, 1910, 51148], "temperature": 0.0, "avg_logprob": -0.1259450912475586, "compression_ratio": 1.7777777777777777, "no_speech_prob": 0.0038239615969359875}, {"id": 578, "seek": 337332, "start": 3389.0, "end": 3395.1600000000003, "text": " from a satellite image to a street map view or from particular labels of an architectural", "tokens": [51148, 490, 257, 16016, 3256, 281, 257, 4838, 4471, 1910, 420, 490, 1729, 16949, 295, 364, 26621, 51456], "temperature": 0.0, "avg_logprob": -0.1259450912475586, "compression_ratio": 1.7777777777777777, "no_speech_prob": 0.0038239615969359875}, {"id": 579, "seek": 337332, "start": 3395.1600000000003, "end": 3401.4, "text": " building to a synthetic architectural facade or day to night, black and white to color,", "tokens": [51456, 2390, 281, 257, 23420, 26621, 46261, 420, 786, 281, 1818, 11, 2211, 293, 2418, 281, 2017, 11, 51768], "temperature": 0.0, "avg_logprob": -0.1259450912475586, "compression_ratio": 1.7777777777777777, "no_speech_prob": 0.0038239615969359875}, {"id": 580, "seek": 340140, "start": 3401.48, "end": 3406.92, "text": " edges to photos, different instances of paired translation that are achieved by conditioning", "tokens": [50368, 8819, 281, 5787, 11, 819, 14519, 295, 25699, 12853, 300, 366, 11042, 538, 21901, 50640], "temperature": 0.0, "avg_logprob": -0.09811633593076236, "compression_ratio": 1.5940170940170941, "no_speech_prob": 0.000487822835566476}, {"id": 581, "seek": 340140, "start": 3406.92, "end": 3413.88, "text": " on particular labels. So another example which I think is really cool and interesting is", "tokens": [50640, 322, 1729, 16949, 13, 407, 1071, 1365, 597, 286, 519, 307, 534, 1627, 293, 1880, 307, 50988], "temperature": 0.0, "avg_logprob": -0.09811633593076236, "compression_ratio": 1.5940170940170941, "no_speech_prob": 0.000487822835566476}, {"id": 582, "seek": 340140, "start": 3413.88, "end": 3421.7200000000003, "text": " translating from Google Street View to a satellite view and vice versa. And we can also achieve this", "tokens": [50988, 35030, 490, 3329, 7638, 13909, 281, 257, 16016, 1910, 293, 11964, 25650, 13, 400, 321, 393, 611, 4584, 341, 51380], "temperature": 0.0, "avg_logprob": -0.09811633593076236, "compression_ratio": 1.5940170940170941, "no_speech_prob": 0.000487822835566476}, {"id": 583, "seek": 340140, "start": 3421.7200000000003, "end": 3428.12, "text": " dynamically. So for example in coloring given an edge input, the network can be trained to", "tokens": [51380, 43492, 13, 407, 337, 1365, 294, 23198, 2212, 364, 4691, 4846, 11, 264, 3209, 393, 312, 8895, 281, 51700], "temperature": 0.0, "avg_logprob": -0.09811633593076236, "compression_ratio": 1.5940170940170941, "no_speech_prob": 0.000487822835566476}, {"id": 584, "seek": 342812, "start": 3428.12, "end": 3434.68, "text": " actually synthetically color in the artwork that is resulting from this particular edge sketch.", "tokens": [50364, 767, 10657, 22652, 2017, 294, 264, 15829, 300, 307, 16505, 490, 341, 1729, 4691, 12325, 13, 50692], "temperature": 0.0, "avg_logprob": -0.07320322567903542, "compression_ratio": 1.669683257918552, "no_speech_prob": 0.00020662120368797332}, {"id": 585, "seek": 342812, "start": 3437.24, "end": 3442.7599999999998, "text": " Another idea instead of paired translation is that of unpaired image to image translation.", "tokens": [50820, 3996, 1558, 2602, 295, 25699, 12853, 307, 300, 295, 517, 4306, 1824, 3256, 281, 3256, 12853, 13, 51096], "temperature": 0.0, "avg_logprob": -0.07320322567903542, "compression_ratio": 1.669683257918552, "no_speech_prob": 0.00020662120368797332}, {"id": 586, "seek": 342812, "start": 3442.7599999999998, "end": 3448.44, "text": " And this is going to be achieved by a network architecture called CycleGAN where the model", "tokens": [51096, 400, 341, 307, 516, 281, 312, 11042, 538, 257, 3209, 9482, 1219, 10295, 2160, 27699, 689, 264, 2316, 51380], "temperature": 0.0, "avg_logprob": -0.07320322567903542, "compression_ratio": 1.669683257918552, "no_speech_prob": 0.00020662120368797332}, {"id": 587, "seek": 342812, "start": 3448.44, "end": 3455.64, "text": " is taking as input images from one domain and is able to learn a mapping that translates to", "tokens": [51380, 307, 1940, 382, 4846, 5267, 490, 472, 9274, 293, 307, 1075, 281, 1466, 257, 18350, 300, 28468, 281, 51740], "temperature": 0.0, "avg_logprob": -0.07320322567903542, "compression_ratio": 1.669683257918552, "no_speech_prob": 0.00020662120368797332}, {"id": 588, "seek": 345564, "start": 3455.72, "end": 3460.2, "text": " another domain without having a paired corresponding image in that other domain.", "tokens": [50368, 1071, 9274, 1553, 1419, 257, 25699, 11760, 3256, 294, 300, 661, 9274, 13, 50592], "temperature": 0.0, "avg_logprob": -0.08175715804100037, "compression_ratio": 1.691588785046729, "no_speech_prob": 0.0015486925840377808}, {"id": 589, "seek": 345564, "start": 3461.24, "end": 3468.12, "text": " So the idea here is to transfer the style and the distribution from one domain to another.", "tokens": [50644, 407, 264, 1558, 510, 307, 281, 5003, 264, 3758, 293, 264, 7316, 490, 472, 9274, 281, 1071, 13, 50988], "temperature": 0.0, "avg_logprob": -0.08175715804100037, "compression_ratio": 1.691588785046729, "no_speech_prob": 0.0015486925840377808}, {"id": 590, "seek": 345564, "start": 3468.8399999999997, "end": 3475.64, "text": " And this is achieved by introducing the cyclic relationship and a cyclic loss function where", "tokens": [51024, 400, 341, 307, 11042, 538, 15424, 264, 38154, 1050, 2480, 293, 257, 38154, 1050, 4470, 2445, 689, 51364], "temperature": 0.0, "avg_logprob": -0.08175715804100037, "compression_ratio": 1.691588785046729, "no_speech_prob": 0.0015486925840377808}, {"id": 591, "seek": 345564, "start": 3475.64, "end": 3482.52, "text": " we can go back and forth between a domain x and a domain y. And in this system there are actually", "tokens": [51364, 321, 393, 352, 646, 293, 5220, 1296, 257, 9274, 2031, 293, 257, 9274, 288, 13, 400, 294, 341, 1185, 456, 366, 767, 51708], "temperature": 0.0, "avg_logprob": -0.08175715804100037, "compression_ratio": 1.691588785046729, "no_speech_prob": 0.0015486925840377808}, {"id": 592, "seek": 348252, "start": 3482.52, "end": 3486.92, "text": " two generators and two discriminators that are going to be trained on their respective", "tokens": [50364, 732, 38662, 293, 732, 20828, 3391, 300, 366, 516, 281, 312, 8895, 322, 641, 23649, 50584], "temperature": 0.0, "avg_logprob": -0.05754030181700925, "compression_ratio": 1.7407407407407407, "no_speech_prob": 0.003172193421050906}, {"id": 593, "seek": 348252, "start": 3486.92, "end": 3494.2, "text": " generation and discrimination tasks. In this example the CycleGAN has been trained to try to", "tokens": [50584, 5125, 293, 15973, 9608, 13, 682, 341, 1365, 264, 10295, 2160, 27699, 575, 668, 8895, 281, 853, 281, 50948], "temperature": 0.0, "avg_logprob": -0.05754030181700925, "compression_ratio": 1.7407407407407407, "no_speech_prob": 0.003172193421050906}, {"id": 594, "seek": 348252, "start": 3494.2, "end": 3500.52, "text": " translate from the domain of horses to the domain of zebras. And hopefully you can appreciate that", "tokens": [50948, 13799, 490, 264, 9274, 295, 13112, 281, 264, 9274, 295, 5277, 38182, 13, 400, 4696, 291, 393, 4449, 300, 51264], "temperature": 0.0, "avg_logprob": -0.05754030181700925, "compression_ratio": 1.7407407407407407, "no_speech_prob": 0.003172193421050906}, {"id": 595, "seek": 348252, "start": 3500.52, "end": 3507.48, "text": " in this example there's a transformation of the skin of the horse from brown to a zebra-like skin", "tokens": [51264, 294, 341, 1365, 456, 311, 257, 9887, 295, 264, 3178, 295, 264, 6832, 490, 6292, 281, 257, 47060, 12, 4092, 3178, 51612], "temperature": 0.0, "avg_logprob": -0.05754030181700925, "compression_ratio": 1.7407407407407407, "no_speech_prob": 0.003172193421050906}, {"id": 596, "seek": 350748, "start": 3507.48, "end": 3512.44, "text": " in stripes. And beyond this there's also a transformation of the surrounding area", "tokens": [50364, 294, 27308, 13, 400, 4399, 341, 456, 311, 611, 257, 9887, 295, 264, 11498, 1859, 50612], "temperature": 0.0, "avg_logprob": -0.07572444073565594, "compression_ratio": 1.587378640776699, "no_speech_prob": 0.001987630734220147}, {"id": 597, "seek": 350748, "start": 3512.44, "end": 3516.92, "text": " from green grass to something that's more brown in the case of the zebra.", "tokens": [50612, 490, 3092, 8054, 281, 746, 300, 311, 544, 6292, 294, 264, 1389, 295, 264, 47060, 13, 50836], "temperature": 0.0, "avg_logprob": -0.07572444073565594, "compression_ratio": 1.587378640776699, "no_speech_prob": 0.001987630734220147}, {"id": 598, "seek": 350748, "start": 3518.6, "end": 3523.08, "text": " And I think to get an intuition about how this CycleGAN transformation is going", "tokens": [50920, 400, 286, 519, 281, 483, 364, 24002, 466, 577, 341, 10295, 2160, 27699, 9887, 307, 516, 51144], "temperature": 0.0, "avg_logprob": -0.07572444073565594, "compression_ratio": 1.587378640776699, "no_speech_prob": 0.001987630734220147}, {"id": 599, "seek": 350748, "start": 3523.72, "end": 3531.0, "text": " is working. Let's go back to the idea that conventional GANs are moving from a distribution", "tokens": [51176, 307, 1364, 13, 961, 311, 352, 646, 281, 264, 1558, 300, 16011, 460, 1770, 82, 366, 2684, 490, 257, 7316, 51540], "temperature": 0.0, "avg_logprob": -0.07572444073565594, "compression_ratio": 1.587378640776699, "no_speech_prob": 0.001987630734220147}, {"id": 600, "seek": 353100, "start": 3531.0, "end": 3537.48, "text": " of Gaussian noise to some target data manifold. With CycleGANs the goal is to go from a particular", "tokens": [50364, 295, 39148, 5658, 281, 512, 3779, 1412, 47138, 13, 2022, 10295, 2160, 27699, 82, 264, 3387, 307, 281, 352, 490, 257, 1729, 50688], "temperature": 0.0, "avg_logprob": -0.08296370815921139, "compression_ratio": 1.6778846153846154, "no_speech_prob": 0.022624842822551727}, {"id": 601, "seek": 353100, "start": 3537.48, "end": 3545.08, "text": " data manifold x to another data manifold y. And in both cases and I think the underlying", "tokens": [50688, 1412, 47138, 2031, 281, 1071, 1412, 47138, 288, 13, 400, 294, 1293, 3331, 293, 286, 519, 264, 14217, 51068], "temperature": 0.0, "avg_logprob": -0.08296370815921139, "compression_ratio": 1.6778846153846154, "no_speech_prob": 0.022624842822551727}, {"id": 602, "seek": 353100, "start": 3545.08, "end": 3550.68, "text": " concept that makes GANs so powerful is that they function as very very effective distribution", "tokens": [51068, 3410, 300, 1669, 460, 1770, 82, 370, 4005, 307, 300, 436, 2445, 382, 588, 588, 4942, 7316, 51348], "temperature": 0.0, "avg_logprob": -0.08296370815921139, "compression_ratio": 1.6778846153846154, "no_speech_prob": 0.022624842822551727}, {"id": 603, "seek": 353100, "start": 3550.68, "end": 3555.32, "text": " transformers and it can achieve these distribution transformations.", "tokens": [51348, 4088, 433, 293, 309, 393, 4584, 613, 7316, 34852, 13, 51580], "temperature": 0.0, "avg_logprob": -0.08296370815921139, "compression_ratio": 1.6778846153846154, "no_speech_prob": 0.022624842822551727}, {"id": 604, "seek": 355532, "start": 3555.48, "end": 3563.7200000000003, "text": " Finally I'd like to consider one additional application that you may be familiar with", "tokens": [50372, 6288, 286, 1116, 411, 281, 1949, 472, 4497, 3861, 300, 291, 815, 312, 4963, 365, 50784], "temperature": 0.0, "avg_logprob": -0.09028116674984203, "compression_ratio": 1.662280701754386, "no_speech_prob": 0.0006986116641201079}, {"id": 605, "seek": 355532, "start": 3564.44, "end": 3570.76, "text": " of using CycleGANs and that's to transform speech and to actually use this CycleGAN technique to", "tokens": [50820, 295, 1228, 10295, 2160, 27699, 82, 293, 300, 311, 281, 4088, 6218, 293, 281, 767, 764, 341, 10295, 2160, 27699, 6532, 281, 51136], "temperature": 0.0, "avg_logprob": -0.09028116674984203, "compression_ratio": 1.662280701754386, "no_speech_prob": 0.0006986116641201079}, {"id": 606, "seek": 355532, "start": 3570.76, "end": 3576.28, "text": " synthesize speech in someone else's voice. And the way this is done is by taking a bunch of audio", "tokens": [51136, 26617, 1125, 6218, 294, 1580, 1646, 311, 3177, 13, 400, 264, 636, 341, 307, 1096, 307, 538, 1940, 257, 3840, 295, 6278, 51412], "temperature": 0.0, "avg_logprob": -0.09028116674984203, "compression_ratio": 1.662280701754386, "no_speech_prob": 0.0006986116641201079}, {"id": 607, "seek": 355532, "start": 3576.28, "end": 3582.84, "text": " recordings in one voice and audio recordings in another voice and converting those audio waveforms", "tokens": [51412, 25162, 294, 472, 3177, 293, 6278, 25162, 294, 1071, 3177, 293, 29942, 729, 6278, 36512, 82, 51740], "temperature": 0.0, "avg_logprob": -0.09028116674984203, "compression_ratio": 1.662280701754386, "no_speech_prob": 0.0006986116641201079}, {"id": 608, "seek": 358284, "start": 3582.84, "end": 3591.08, "text": " into an image representation which was called a spectrogram. We can then train a CycleGAN to", "tokens": [50364, 666, 364, 3256, 10290, 597, 390, 1219, 257, 6177, 340, 1342, 13, 492, 393, 550, 3847, 257, 10295, 2160, 27699, 281, 50776], "temperature": 0.0, "avg_logprob": -0.07683840358958524, "compression_ratio": 1.7232142857142858, "no_speech_prob": 0.000767212244682014}, {"id": 609, "seek": 358284, "start": 3591.08, "end": 3598.84, "text": " operate on these spectrogram images to transform representations from voice A to make them appear", "tokens": [50776, 9651, 322, 613, 6177, 340, 1342, 5267, 281, 4088, 33358, 490, 3177, 316, 281, 652, 552, 4204, 51164], "temperature": 0.0, "avg_logprob": -0.07683840358958524, "compression_ratio": 1.7232142857142858, "no_speech_prob": 0.000767212244682014}, {"id": 610, "seek": 358284, "start": 3598.84, "end": 3605.48, "text": " like they appear that they are from another voice, voice B. And this is exactly how we did the", "tokens": [51164, 411, 436, 4204, 300, 436, 366, 490, 1071, 3177, 11, 3177, 363, 13, 400, 341, 307, 2293, 577, 321, 630, 264, 51496], "temperature": 0.0, "avg_logprob": -0.07683840358958524, "compression_ratio": 1.7232142857142858, "no_speech_prob": 0.000767212244682014}, {"id": 611, "seek": 358284, "start": 3605.48, "end": 3611.8, "text": " speech transformation for the synthesis of Obama's voice in the demonstration that Alexander gave in", "tokens": [51496, 6218, 9887, 337, 264, 30252, 295, 9560, 311, 3177, 294, 264, 16520, 300, 14845, 2729, 294, 51812], "temperature": 0.0, "avg_logprob": -0.07683840358958524, "compression_ratio": 1.7232142857142858, "no_speech_prob": 0.000767212244682014}, {"id": 612, "seek": 361180, "start": 3611.8, "end": 3618.6800000000003, "text": " the first lecture. So to inspect this further let's compare side by side the original audio", "tokens": [50364, 264, 700, 7991, 13, 407, 281, 15018, 341, 3052, 718, 311, 6794, 1252, 538, 1252, 264, 3380, 6278, 50708], "temperature": 0.0, "avg_logprob": -0.15269457010122445, "compression_ratio": 1.3482587064676617, "no_speech_prob": 0.0011877205688506365}, {"id": 613, "seek": 361180, "start": 3618.6800000000003, "end": 3624.84, "text": " from Alexander as well as the synthesized version in Obama's voice that was generated using a CycleGAN.", "tokens": [50708, 490, 14845, 382, 731, 382, 264, 26617, 1602, 3037, 294, 9560, 311, 3177, 300, 390, 10833, 1228, 257, 10295, 2160, 27699, 13, 51016], "temperature": 0.0, "avg_logprob": -0.15269457010122445, "compression_ratio": 1.3482587064676617, "no_speech_prob": 0.0011877205688506365}, {"id": 614, "seek": 361180, "start": 3626.76, "end": 3634.1200000000003, "text": " Hi everybody and welcome to MIT 6S191, you know, facial introductory course", "tokens": [51112, 2421, 2201, 293, 2928, 281, 13100, 1386, 50, 3405, 16, 11, 291, 458, 11, 15642, 39048, 1164, 51480], "temperature": 0.0, "avg_logprob": -0.15269457010122445, "compression_ratio": 1.3482587064676617, "no_speech_prob": 0.0011877205688506365}, {"id": 615, "seek": 363412, "start": 3634.12, "end": 3644.12, "text": " on speech learning here at MIT. So notice that the spectrogram that results for Obama's voice", "tokens": [50364, 322, 6218, 2539, 510, 412, 13100, 13, 407, 3449, 300, 264, 6177, 340, 1342, 300, 3542, 337, 9560, 311, 3177, 50864], "temperature": 0.0, "avg_logprob": -0.12979800701141359, "compression_ratio": 1.668141592920354, "no_speech_prob": 0.001304321805946529}, {"id": 616, "seek": 363412, "start": 3644.68, "end": 3650.7599999999998, "text": " is actually generated by an operation on Alexander's voice and effectively learning a domain", "tokens": [50892, 307, 767, 10833, 538, 364, 6916, 322, 14845, 311, 3177, 293, 8659, 2539, 257, 9274, 51196], "temperature": 0.0, "avg_logprob": -0.12979800701141359, "compression_ratio": 1.668141592920354, "no_speech_prob": 0.001304321805946529}, {"id": 617, "seek": 363412, "start": 3650.7599999999998, "end": 3656.68, "text": " transformation from Obama domain onto the domain of Alexander domain and the end result is that we", "tokens": [51196, 9887, 490, 9560, 9274, 3911, 264, 9274, 295, 14845, 9274, 293, 264, 917, 1874, 307, 300, 321, 51492], "temperature": 0.0, "avg_logprob": -0.12979800701141359, "compression_ratio": 1.668141592920354, "no_speech_prob": 0.001304321805946529}, {"id": 618, "seek": 363412, "start": 3656.68, "end": 3663.24, "text": " create and synthesize something that's more Obama-like. All right so to summarize hopefully", "tokens": [51492, 1884, 293, 26617, 1125, 746, 300, 311, 544, 9560, 12, 4092, 13, 1057, 558, 370, 281, 20858, 4696, 51820], "temperature": 0.0, "avg_logprob": -0.12979800701141359, "compression_ratio": 1.668141592920354, "no_speech_prob": 0.001304321805946529}, {"id": 619, "seek": 366324, "start": 3663.24, "end": 3668.3599999999997, "text": " over the course of this lecture you built up understanding of generative modeling and classes", "tokens": [50364, 670, 264, 1164, 295, 341, 7991, 291, 3094, 493, 3701, 295, 1337, 1166, 15983, 293, 5359, 50620], "temperature": 0.0, "avg_logprob": -0.05189243751236155, "compression_ratio": 1.6478260869565218, "no_speech_prob": 0.0018100752495229244}, {"id": 620, "seek": 366324, "start": 3668.3599999999997, "end": 3674.9199999999996, "text": " of generative models that are particularly powerful in enabling probabilistic density estimation", "tokens": [50620, 295, 1337, 1166, 5245, 300, 366, 4098, 4005, 294, 23148, 31959, 3142, 10305, 35701, 50948], "temperature": 0.0, "avg_logprob": -0.05189243751236155, "compression_ratio": 1.6478260869565218, "no_speech_prob": 0.0018100752495229244}, {"id": 621, "seek": 366324, "start": 3674.9199999999996, "end": 3683.0, "text": " as well as sample generation. And with that I'd like to close the lecture and introduce you to", "tokens": [50948, 382, 731, 382, 6889, 5125, 13, 400, 365, 300, 286, 1116, 411, 281, 1998, 264, 7991, 293, 5366, 291, 281, 51352], "temperature": 0.0, "avg_logprob": -0.05189243751236155, "compression_ratio": 1.6478260869565218, "no_speech_prob": 0.0018100752495229244}, {"id": 622, "seek": 366324, "start": 3683.0, "end": 3689.3999999999996, "text": " the remainder of today's course which is going to focus on our second lab on computer vision,", "tokens": [51352, 264, 29837, 295, 965, 311, 1164, 597, 307, 516, 281, 1879, 322, 527, 1150, 2715, 322, 3820, 5201, 11, 51672], "temperature": 0.0, "avg_logprob": -0.05189243751236155, "compression_ratio": 1.6478260869565218, "no_speech_prob": 0.0018100752495229244}, {"id": 623, "seek": 368940, "start": 3690.28, "end": 3695.7200000000003, "text": " specifically exploring this question of debiasing in facial detection systems", "tokens": [50408, 4682, 12736, 341, 1168, 295, 3001, 72, 3349, 294, 15642, 17784, 3652, 50680], "temperature": 0.0, "avg_logprob": -0.10546248813845077, "compression_ratio": 1.5833333333333333, "no_speech_prob": 0.0015244957758113742}, {"id": 624, "seek": 368940, "start": 3695.7200000000003, "end": 3701.2400000000002, "text": " and using variational autoencoders to actually achieve an approach for automatic", "tokens": [50680, 293, 1228, 3034, 1478, 8399, 22660, 378, 433, 281, 767, 4584, 364, 3109, 337, 12509, 50956], "temperature": 0.0, "avg_logprob": -0.10546248813845077, "compression_ratio": 1.5833333333333333, "no_speech_prob": 0.0015244957758113742}, {"id": 625, "seek": 368940, "start": 3701.2400000000002, "end": 3706.6, "text": " debiasing of classification systems. So I encourage you to come to the class gather town", "tokens": [50956, 3001, 72, 3349, 295, 21538, 3652, 13, 407, 286, 5373, 291, 281, 808, 281, 264, 1508, 5448, 3954, 51224], "temperature": 0.0, "avg_logprob": -0.10546248813845077, "compression_ratio": 1.5833333333333333, "no_speech_prob": 0.0015244957758113742}, {"id": 626, "seek": 370660, "start": 3706.6, "end": 3713.7999999999997, "text": " to have your questions on the lab's answered and to discuss further with any of us. Thank you.", "tokens": [50364, 281, 362, 428, 1651, 322, 264, 2715, 311, 10103, 293, 281, 2248, 3052, 365, 604, 295, 505, 13, 1044, 291, 13, 50724], "temperature": 0.0, "avg_logprob": -0.27147185802459717, "compression_ratio": 1.1058823529411765, "no_speech_prob": 0.08748038858175278}], "language": "en"}