{"text": " The world of algorithms is vast, but we can often split them into two distinct classes. The first class is those that are inherently useful. Think of your standard graph algorithms like DFS or BFS. These algorithms show up all over the place, they are efficient, and as a result we like to understand them. The second class of algorithms we study are ones that are just purely beautiful. Think of the first time you saw the incredibly simple recursive implementation of towers of annoy. If you have a soul, you feel a sense of wonder, a sense of awe at the elegance of such an algorithm. It happens to not actually be that useful or efficient as a matter of fact, but we still study it just as we like to read a work of fiction. It inspires us and motivates out-of-the-box thinking. Today I want to talk about an algorithm that rightfully belongs in both classes and my personal favorite algorithm, the fast Fourier transform. The fast Fourier transform or FFT is without exaggeration one of the most important algorithms created in the last century. So much of the modern technology that we have today such as wireless communication, GPS, and in fact anything related to the vast field of signal processing relies on the insights of the FFT. But it's also one of the most beautiful algorithms you ever see. The depth and sheer number of brilliant ideas that went into it is just astounding. It's easy to miss the beauty aspect of the FFT since it's often introduced in fairly complex settings that require a lot of prerequisite knowledge such as the discrete Fourier transform, time domain to frequency domain conversions, and much more. And to be fair, to get a full appreciation of the applications of the FFT you can't really avoid any of these ideas. But I want to do something a little different. We'll take a discovery-based approach to learning about the FFT in a context that you are all familiar with, polynomial multiplication. The way I see the structure of this video, it's all about starting with some common ground and then slowly asking questions that will hopefully prompt you to discover the truly ingenious ideas behind the FFT. Alright, let's get started. The setup here is simple. We're given two polynomials and want to find the product. Our task will be to design an efficient algorithm for this problem. Mathematically, we know one algorithm to multiply polynomials by repeatedly applying the distributed property. All of you have perhaps instinctively been applying this algorithm since any algebra class. Before we try this idea though, the first question we have to address is representation of polynomials in a computer. The most natural way to represent them is through coefficients, where we map coefficients to lists. It helps to arrange our coefficients in the following order, mainly because now the coefficient of the kth index is mapped to the coefficient of the kth degree term. We will refer to this representation as the coefficient representation of polynomials. In general, given 2d degree polynomials, the product will have a degree of 2 times d. And the running time of this algorithm, if we actually went about implementing it with the most natural distributed property approach, will be O of d squared, since each term in polynomial a will have to be multiplied by all terms in polynomial b. The question now is, can we do better? The first really clever idea comes from thinking about polynomials a little bit differently. To see the key inside here, let's take a look at one of the simplest polynomials, a degree 1 polynomial or a linear function. We can represent any line with exactly two coefficients, one for the degree 0 term and one for the degree 1 term. The key part that makes this representation valid is that every representation has a one to one mapping to a unique line. What other representations of a line have this property? There are actually several reasonable representations, but the one that we are going to use is the two point representation. We know from geometry that any line can be represented by two distinct points. And turns out that there is a neat extension of this for general polynomials, which I will state here. Any polynomial of degree d can be uniquely represented by d plus one points. For example, if I gave you three random points, this means that there is exactly one quadratic function that goes through all three of these points. If I give you four points, there is exactly one cubic function that goes through all these points. This statement is perhaps a little surprising, so it deserves a proof. Suppose I give you d plus one unique points of a d degree polynomial p of x. We want to show that for these set of points, there is only one set of coefficients. So if we actually evaluate our polynomial at each of these points, we get the following set of system of equations. Whenever you have a system of equations, writing it as a matrix vector product is almost always helpful for analysis. One nice property of this matrix is that if each of our original points is unique, as it is in this case, the matrix will always be invertible. The easiest way to show this is by calculating the determinant, which you will find is non-zero, but I'll link a nice linear algebraic proof of this fact in the description as well for those interested. Anyways, what this means is that for every set of points, there exists a unique set of coefficients and consequently a unique polynomial. Taking a step back, what this means is that there are actually two ways to represent polynomials of degree d, the first of which is the coefficient representation and the second with just d plus one points, which we will call the value representation. A nice property of using the value representation is multiplication of polynomials is much easier. Let's say I ask you to multiply these two polynomials a of x and b of x. We know the resulting polynomial c of x will be of degree four, so we'll need five points to uniquely represent the product. What we can now do is take five points from each of the two polynomials and then simply multiply the function values one by one to get the value representation of the product of the two polynomials. Following our earlier rule, there is only one degree four polynomial that passes through these points. That polynomial happens to be the following in the coefficient representation and this is indeed the product of our original a of x and b of x polynomials. With the multiplication operation being performed using the value representation, we've now reduced the time for multiplication from our original d squared operations to the order of only degree d operations. Okay, so let's propose a plan for an improvement to polynomial multiplication. We are given two polynomials in the coefficient representation of degree d each. We know multiplication is faster using the value representation, so what we'll do is evaluate each of these polynomials at 2d plus one points, multiply each of these points pairwise to get the value representation of the product polynomial, and then finally somehow convert the value representation back to the final coefficient representation. This is the grand plan, but there are several pieces of the puzzle we haven't figured out. What we're missing is really some sort of magic box that could take polynomials in the coefficient representation and convert them to the value representation and then vice versa. That magic box my friends and trust me it is truly magical is the fast Fourier transform. Let's first focus on taking polynomials from the coefficient representation to the value representation, which we will call evaluation. We have a degree d polynomial and we want to evaluate the polynomial at n points where n is some number greater than d plus one. Let's think about the most straightforward way to do this. We can pick n random x coordinates and simply calculate the respective y coordinate. This works, but when we deconstruct what's actually going on here, we run into our old foe. Each evaluation will take o of d operations, making this method run in o of n times d time, which ends up being o of d squared to evaluate all n points. So we're back to where we started. Can we find a way to optimize this? Let's try to simplify the problem. Let's say instead of considering a general polynomial, we wanted to instead just evaluate a simple polynomial like p of x is equal to x squared at eight points. The question now is, which points should we pick? Is there any set of points when knowing the value of one point immediately implies the value of another? In fact, there is. If we pick the point x equals one, we immediately know the value of the point x equals negative one. Similarly, if we pick x equals two, we automatically know x equals negative two will have the same value. Extending this idea, the key property we want here is that our eight points should be positive negative pairs. The reason this works is due to the property of even functions where a function evaluated at negative x is going to equal the function evaluated at positive x. Okay, but then the next immediate question is, what about functions like x cubed? Does the same trick work? It actually kind of does, but with one caveat. Each positive x value will have the same value as the negative x value, but with the sign flipped. So in these two cases of odd and even degree single term polynomials, instead of evaluating eight individual points, we can actually get away with evaluating exactly four positive points, from which we immediately know the value of the respective negative points. Let's see if we can extend this idea to a more general polynomial, taking inspiration from our early exploration, let's split our polynomial into even and odd degree terms. If we factor an x from the odd degree terms, we end up having two new polynomials, where these new polynomials have only even degree terms. Let's actually give these polynomials formal names, the first representing the even terms and the second representing odd terms after factoring out x. This fact allows us to recycle a lot of computation between positive and negative pairs of points. A bonus fact is that since these even and odd polynomials are functions of x squared, they are polynomials of degree two, which is a much simpler problem than our original degree five polynomial. Generalizing these observations, if we have an n minus one degree polynomial that we want to evaluate at n points, we can split the polynomial into even and odd terms with these two smaller polynomials now having degree n over two minus one. So, how do we evaluate these polynomials with half the degree of our original polynomial? Well, what's beautiful here is that this is just another evaluation problem, but this time we need to evaluate the polynomials at each of our original inputs squared. And this works out nicely since our original points were positive negative pairs, so if we originally had n points, we now only end up having n over two points. This is starting to smell like the start of a recursive algorithm. Let's take a look at the bigger picture. We want to evaluate a polynomial p of x at n points where the n points are positive negative paired. We split the polynomial into odd and even degree components where we now have two simpler polynomials of degree n over two minus one that only need n over two points to evaluate. Once we recursively evaluate these smaller polynomials, we can then go through every point in our original set of n points and calculate the respective values by utilizing the relationship between the positive and negative paired points. This gives us the value representation of our original polynomial. If we can get this to work, this means we have an O of n log n recursive algorithm since the two recursive sub problems have half the size of the original problem and take linear time to evaluate the n points. This would be a huge improvement from our earlier quadratic running time, but there is one major problem. Can you spot the issue? The problem occurs at the recursive step. The entire scheme relies on the fact that the polynomial will have positive and negative paired points for evaluation. This works at the top level, but the next level we are evaluating n over two points where each point is a squared value. These all end up being positive so the recursion breaks. So then the natural question is, can we make these new set of points positive negative paired? Some of you may already see it, but this actually leads to the third absolutely ingenious idea behind the FFT. The only way this is possible is if we expand the domain of possible initial points to include complex numbers. For a special choice of complex numbers, the recursive relation works perfectly where every subsequent set of points will contain positive negative pairs. What possible set of initial n points has this property? This is a hard question and to answer it we are going to do a little bit of reverse engineering with an example. Let's say we have a degree 3 polynomial which requires at least n equals 4 points for its value representation. These points need to be positive negative pairs so we can write them as x1, negative x1, x2, and negative x2. We know that the recursive step will require that we evaluate the odd and even splits of the polynomial at two points, x1 squared and x2 squared. Now the key constraint here is that for the recursion to work, these two points also have to be positive negative pairs. So we have an equivalence between x2 squared and negative x1 squared. At the bottom level of the recursion we'll have a single point x1 to the power of 4. Now what's nice is that we get to choose these points. Let's see what happens if we pick our initial x1 to be 1. This means two of our initial points are 1 and negative 1 which at the next level of recursion means that x1 squared and negative x1 squared also have to be 1 and negative 1 respectively. And at the bottom layer we have only one point which ends up being 1. Now the question becomes what x2 should we choose so that when we square x2 we end up with negative 1. The answer to that is the complex number i which means that the four points that we need to evaluate this polynomial at are 1, negative 1, i and negative i. An alternate perspective to what we just did here is that we essentially just solved the equation x to the power of 4 equals 1. Since at the bottom layer of the recursion the value of any of our original points to the power of 4 was 1. We know this equation has four solutions all of which are encompassed by a special set of points called the fourth roots of unity. Let's see if this generalizes. If given a degree 5 polynomial we'll need n is greater than or equal to six points. Since our recursive method is splitting each problem in half it's convenient to just pick a power of 2 so let's pick n equals 8. Now what we need to do is to find eight points that are positive negative paired such that each of these points when raised to the eighth power is equal to 1. We see that the right points are the eighth roots of unity. Generalizing this to any d degree polynomial what we will do is pick n is greater than or equal to d plus 1 points such that n is the power of 2 and the points that we should choose are the nth roots of unity. This fact deserves a little bit more explanation. Why does this work? Before we answer that question let's formalize a few things. The nth roots of unity are the solution to the following equation and they are best visualized as equally spaced points on the unit circle. The angle between these points is 2 pi over n. With this fact a nice way to compactly write these points is with complex exponential notation through Euler's formula. One standard way to define the roots of unity is by defining this omega term as e to the power of 2 pi i over n and then what this allows us to do is define individual roots of unity quite compactly. Here are some examples. So now when we say we want to evaluate a polynomial at the nth roots of unity what that really means is we want to evaluate it at omega to the power of 0, omega to the power of 1, so on and so forth until omega to the power of n minus 1. So going back to our original question of why evaluating the polynomial p of x at the nth roots of unity works for a recursive algorithm there are two key properties at play here. For one our original set of points are positive negative paired where for the jth root omega to the power of j omega to the power of j plus n over 2 is going to be the corresponding pair. Now in our recursive step we will be squaring each of these points and passing them on to the even and odd degree polynomials. This is what happens when we square our original nth roots of unity. This reveals the second key property of the nth roots of unity. When we square the nth roots of unity we end up with the n over 2 roots of unity which are also positive negative paired and are just the right number of points for the two new polynomials of half the degree. This same pattern holds at every level of the recursion until we end up with just one point. How beautiful is that? All right we are now ready to outline the core fast Fourier transform algorithm. The FFT will take in a coefficient representation of a degree n minus one polynomial where n is the power of two. We will define omega as e to the power of two pi i over n to allow us to define roots of unity easily. The first case we need to handle is the base case which is going to be when n is equal to one. All this means is that we are evaluating the polynomial at one point. Our recursive case is two calls to the FFT. One on even degree terms and one on odd degree terms. The intention is that these polynomials are now half the degree of our original polynomial so they only need to be evaluated at n over two roots of unity. Assuming the recursion works the output of these calls will be the corresponding value representation of these even and odd degree term polynomials which we will label as y e and y o. Now on to the tricky part which is to take the output from these recursive calls and combine them to get the value representation of our original degree n minus one polynomial. We saw earlier that the key idea was to use the relationship between positive and negative pairs but now we have to slightly modify this logic for our roots of unity inputs. As a quick note yes I did modify the indexing to zero indexing because we're getting ready to write some code. We know the jth input point will correspond to jth root of unity which results in the following relationship. We also saw earlier that the paired point negative omega to the power of j is equal to omega to the power of j plus n over two due to the properties of the roots of unity. Using this fact we can modify the second equation as follows. And lastly one more fact that's nice is that the jth index in our y e and y o list correspond to the even and odd polynomials evaluated at omega to the power of two times j. What this allows us to do is rewrite our equations as follows which makes it much easier to implement code. As mentioned this part is tricky so I encourage you to take your time and verify that each of these steps is indeed true. The final step in the FFT algorithm is to then return the values of a polynomial p evaluated at the nth roots of unity. Let's now translate this outlined logic into code. Our function FFT will take an input p which is the coefficient representation of a polynomial p. We first define n as the length of p and we will assume that n is a power of two. Just to be clear there are implementations of the FFT that can handle n not being a power of two but those are way more complicated. The power of two cases encompass the core ideas of the algorithm. We now handle the base case which is just a matter of returning our original p. This makes sense since we only have one element making p a degree zero polynomial or constant. Otherwise we define omega as we have outlined and then proceed with the recursive step. The first part of the recursive step requires splitting the polynomial into even and odd degree terms which is quite easy to do. Then we recursively call our FFT function on these polynomials that now have half the degree of our original polynomial. We denote the outputs as y e and y o as we have done in the outline. Now it's time to put this all together. We initialize our output list which will contain the final value representation. Then for all j up to n over two we calculate the value representations as we have outlined. After populating all values in our list we then return that list and that's the FFT. Overall pretty crazy how all the ideas we talked about end up coming together in eleven lines of truly elegant code. Let's now take a larger look at our original problem of polynomial multiplication and see where we are. We now have a way to convert coefficient representations to value representations efficiently using the FFT. So now the only missing piece is the reverse process of converting from value representations to coefficient representations which is formally called interpolation. This is where things get really wild. On the surface the idea of reversing evaluation feels like a significantly harder task. Let's take a step back and look at this problem from another perspective. Evaluation and interpolation are closely connected and as we saw earlier we can express evaluation as a matrix vector product. We have a vector of coefficients multiplied by a matrix of our evaluation points to give us the value representation. Now in the FFT algorithm the kth evaluation point was a corresponding root of unity which allows us to rewrite the matrix vector product as follows. This particular matrix has a special name the discrete Fourier transform or DFT matrix. In most textbooks and references the FFT at its core is an algorithm for calculating these types of matrix vector products efficiently. Polynomial evaluation at the roots of unity happens to be one case where this type of matrix vector product shows up so that's why we can use the FFT. Anyways the nice fact about the FFT and evaluation in this context is that interpolation is much easier to understand. Interpolation requires inversing this DFT matrix. For interpolation we are given a value representation of our polynomial and we want to find the coefficient representation which means we have to multiply the value representation by the inverse of the DFT matrix. So let me show you what the inverse of this matrix looks like. I'm purposefully skipping a lot of important linear algebra facts here since that would be an entirely different video but given that this is the inverse matrix what stands out to you? It's really quite amazing but this inverse matrix looks almost the same as our original DFT matrix. In fact the only difference is that every single omega in our original DFT matrix is now just replaced with omega to the power of negative 1 with a normalization factor of 1 over n. This indicates a potential to reuse the FFT logic for interpolation since the matrix structure is basically the same. Let's formalize this suspicion by doing a direct comparison. In evaluation which involved the FFT we are given a set of coefficients and evaluate the polynomial at the roots of unity to get a value representation. This involved the following matrix vector product where we define omega as e to the power of 2 pi i divided by n. Looking at interpolation we now want to define what is formally called the inverse FFT algorithm. The inverse FFT will take a value representation where each value was evaluated at the roots of unity and gives you a set of coefficients for the original polynomial basically reversing what the original FFT did. As we just saw this requires multiplying by the inverse of the DFT matrix. We noted that each omega in our original DFT matrix now corresponds to 1 over n times omega to the power of negative 1. Now the punchline here is that what this means is we can define the inverse FFT as the same FFT function but now called on the value representation with omega defined as 1 over n times e to the negative 2 pi i divided by n. That's it. With those small changes we have an inverse FFT that performs interpolation. Just so we are super clear on what sorcery just happened let me remind you of the original FFT implementation and now let me show you the inverse FFT implementation which takes the value representation as an input. What we literally do is copy our FFT implementation, change the name of the recursive calls to match and then literally change one line of code. One line and that's all there is to it. So if your mind isn't blown you haven't been paying attention. Let's take a look at what we just did. We motivated the FFT through the problem of polynomial multiplication where the first brilliant idea came from representing and multiplying polynomials using the value representation. Converting polynomials to a value representation required us to come up with an appropriate set of evaluation points. Our first attempts at solving this problem inspired the clever idea of using positive negative pairs but the recursion didn't quite work unless we expanded the domain to complex numbers. The next brilliant idea came from using the nth roots of unity where the points at every level of recursion are positive negative paired. This evaluation scheme using the roots of unity encompassed the essence of the FFT algorithm. When confronted with the problem of reversing the process using interpolation we discovered something truly astounding. The inverse FFT is the same algorithm but with one minor adjustment. So if we take a look at what we just did here there's not one, not two, not three, but four absolutely mind-blowing ideas that come together to make this work. Do I really need to say more on why this is my favorite algorithm? That's all for this video and thanks for watching. If you enjoyed the content please hit the like button so that this content will be recommended to more people. If you want to see more content like this please don't forget to hit the subscribe button and if you want to more directly support the work of this channel please check out the Patreon page linked in the description below. I'll see you all in the next video.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 5.68, "text": " The world of algorithms is vast, but we can often split them into two distinct classes.", "tokens": [50364, 440, 1002, 295, 14642, 307, 8369, 11, 457, 321, 393, 2049, 7472, 552, 666, 732, 10644, 5359, 13, 50648], "temperature": 0.0, "avg_logprob": -0.06824531177482983, "compression_ratio": 1.743083003952569, "no_speech_prob": 0.0010814956622198224}, {"id": 1, "seek": 0, "start": 5.68, "end": 10.08, "text": " The first class is those that are inherently useful. Think of your standard graph algorithms", "tokens": [50648, 440, 700, 1508, 307, 729, 300, 366, 27993, 4420, 13, 6557, 295, 428, 3832, 4295, 14642, 50868], "temperature": 0.0, "avg_logprob": -0.06824531177482983, "compression_ratio": 1.743083003952569, "no_speech_prob": 0.0010814956622198224}, {"id": 2, "seek": 0, "start": 10.08, "end": 15.280000000000001, "text": " like DFS or BFS. These algorithms show up all over the place, they are efficient,", "tokens": [50868, 411, 413, 29318, 420, 363, 29318, 13, 1981, 14642, 855, 493, 439, 670, 264, 1081, 11, 436, 366, 7148, 11, 51128], "temperature": 0.0, "avg_logprob": -0.06824531177482983, "compression_ratio": 1.743083003952569, "no_speech_prob": 0.0010814956622198224}, {"id": 3, "seek": 0, "start": 15.280000000000001, "end": 19.36, "text": " and as a result we like to understand them. The second class of algorithms we study are", "tokens": [51128, 293, 382, 257, 1874, 321, 411, 281, 1223, 552, 13, 440, 1150, 1508, 295, 14642, 321, 2979, 366, 51332], "temperature": 0.0, "avg_logprob": -0.06824531177482983, "compression_ratio": 1.743083003952569, "no_speech_prob": 0.0010814956622198224}, {"id": 4, "seek": 0, "start": 19.36, "end": 24.400000000000002, "text": " ones that are just purely beautiful. Think of the first time you saw the incredibly simple", "tokens": [51332, 2306, 300, 366, 445, 17491, 2238, 13, 6557, 295, 264, 700, 565, 291, 1866, 264, 6252, 2199, 51584], "temperature": 0.0, "avg_logprob": -0.06824531177482983, "compression_ratio": 1.743083003952569, "no_speech_prob": 0.0010814956622198224}, {"id": 5, "seek": 2440, "start": 24.4, "end": 30.08, "text": " recursive implementation of towers of annoy. If you have a soul, you feel a sense of wonder,", "tokens": [50364, 20560, 488, 11420, 295, 25045, 295, 8759, 13, 759, 291, 362, 257, 5133, 11, 291, 841, 257, 2020, 295, 2441, 11, 50648], "temperature": 0.0, "avg_logprob": -0.09574649251740554, "compression_ratio": 1.6654929577464788, "no_speech_prob": 0.019121017307043076}, {"id": 6, "seek": 2440, "start": 30.08, "end": 35.44, "text": " a sense of awe at the elegance of such an algorithm. It happens to not actually be that", "tokens": [50648, 257, 2020, 295, 30912, 412, 264, 14459, 719, 295, 1270, 364, 9284, 13, 467, 2314, 281, 406, 767, 312, 300, 50916], "temperature": 0.0, "avg_logprob": -0.09574649251740554, "compression_ratio": 1.6654929577464788, "no_speech_prob": 0.019121017307043076}, {"id": 7, "seek": 2440, "start": 35.44, "end": 40.4, "text": " useful or efficient as a matter of fact, but we still study it just as we like to read a work", "tokens": [50916, 4420, 420, 7148, 382, 257, 1871, 295, 1186, 11, 457, 321, 920, 2979, 309, 445, 382, 321, 411, 281, 1401, 257, 589, 51164], "temperature": 0.0, "avg_logprob": -0.09574649251740554, "compression_ratio": 1.6654929577464788, "no_speech_prob": 0.019121017307043076}, {"id": 8, "seek": 2440, "start": 40.4, "end": 46.72, "text": " of fiction. It inspires us and motivates out-of-the-box thinking. Today I want to talk about an algorithm", "tokens": [51164, 295, 13266, 13, 467, 32566, 505, 293, 42569, 484, 12, 2670, 12, 3322, 12, 4995, 1953, 13, 2692, 286, 528, 281, 751, 466, 364, 9284, 51480], "temperature": 0.0, "avg_logprob": -0.09574649251740554, "compression_ratio": 1.6654929577464788, "no_speech_prob": 0.019121017307043076}, {"id": 9, "seek": 2440, "start": 46.72, "end": 52.16, "text": " that rightfully belongs in both classes and my personal favorite algorithm, the fast Fourier", "tokens": [51480, 300, 558, 2277, 12953, 294, 1293, 5359, 293, 452, 2973, 2954, 9284, 11, 264, 2370, 36810, 51752], "temperature": 0.0, "avg_logprob": -0.09574649251740554, "compression_ratio": 1.6654929577464788, "no_speech_prob": 0.019121017307043076}, {"id": 10, "seek": 5216, "start": 52.16, "end": 59.12, "text": " transform. The fast Fourier transform or FFT is without exaggeration one of the most important", "tokens": [50364, 4088, 13, 440, 2370, 36810, 4088, 420, 479, 25469, 307, 1553, 19123, 399, 472, 295, 264, 881, 1021, 50712], "temperature": 0.0, "avg_logprob": -0.08730931054978143, "compression_ratio": 1.6843971631205674, "no_speech_prob": 0.0017544410657137632}, {"id": 11, "seek": 5216, "start": 59.12, "end": 63.839999999999996, "text": " algorithms created in the last century. So much of the modern technology that we have today such as", "tokens": [50712, 14642, 2942, 294, 264, 1036, 4901, 13, 407, 709, 295, 264, 4363, 2899, 300, 321, 362, 965, 1270, 382, 50948], "temperature": 0.0, "avg_logprob": -0.08730931054978143, "compression_ratio": 1.6843971631205674, "no_speech_prob": 0.0017544410657137632}, {"id": 12, "seek": 5216, "start": 63.839999999999996, "end": 69.52, "text": " wireless communication, GPS, and in fact anything related to the vast field of signal processing", "tokens": [50948, 14720, 6101, 11, 19462, 11, 293, 294, 1186, 1340, 4077, 281, 264, 8369, 2519, 295, 6358, 9007, 51232], "temperature": 0.0, "avg_logprob": -0.08730931054978143, "compression_ratio": 1.6843971631205674, "no_speech_prob": 0.0017544410657137632}, {"id": 13, "seek": 5216, "start": 69.52, "end": 76.64, "text": " relies on the insights of the FFT. But it's also one of the most beautiful algorithms you ever see.", "tokens": [51232, 30910, 322, 264, 14310, 295, 264, 479, 25469, 13, 583, 309, 311, 611, 472, 295, 264, 881, 2238, 14642, 291, 1562, 536, 13, 51588], "temperature": 0.0, "avg_logprob": -0.08730931054978143, "compression_ratio": 1.6843971631205674, "no_speech_prob": 0.0017544410657137632}, {"id": 14, "seek": 5216, "start": 76.64, "end": 81.6, "text": " The depth and sheer number of brilliant ideas that went into it is just astounding.", "tokens": [51588, 440, 7161, 293, 23061, 1230, 295, 10248, 3487, 300, 1437, 666, 309, 307, 445, 5357, 24625, 13, 51836], "temperature": 0.0, "avg_logprob": -0.08730931054978143, "compression_ratio": 1.6843971631205674, "no_speech_prob": 0.0017544410657137632}, {"id": 15, "seek": 8216, "start": 82.96, "end": 88.16, "text": " It's easy to miss the beauty aspect of the FFT since it's often introduced in fairly complex", "tokens": [50404, 467, 311, 1858, 281, 1713, 264, 6643, 4171, 295, 264, 479, 25469, 1670, 309, 311, 2049, 7268, 294, 6457, 3997, 50664], "temperature": 0.0, "avg_logprob": -0.06673540709153661, "compression_ratio": 1.619718309859155, "no_speech_prob": 0.0002694716094993055}, {"id": 16, "seek": 8216, "start": 88.16, "end": 92.96, "text": " settings that require a lot of prerequisite knowledge such as the discrete Fourier transform,", "tokens": [50664, 6257, 300, 3651, 257, 688, 295, 38333, 34152, 3601, 1270, 382, 264, 27706, 36810, 4088, 11, 50904], "temperature": 0.0, "avg_logprob": -0.06673540709153661, "compression_ratio": 1.619718309859155, "no_speech_prob": 0.0002694716094993055}, {"id": 17, "seek": 8216, "start": 92.96, "end": 99.03999999999999, "text": " time domain to frequency domain conversions, and much more. And to be fair, to get a full", "tokens": [50904, 565, 9274, 281, 7893, 9274, 42256, 11, 293, 709, 544, 13, 400, 281, 312, 3143, 11, 281, 483, 257, 1577, 51208], "temperature": 0.0, "avg_logprob": -0.06673540709153661, "compression_ratio": 1.619718309859155, "no_speech_prob": 0.0002694716094993055}, {"id": 18, "seek": 8216, "start": 99.03999999999999, "end": 103.52, "text": " appreciation of the applications of the FFT you can't really avoid any of these ideas.", "tokens": [51208, 18909, 295, 264, 5821, 295, 264, 479, 25469, 291, 393, 380, 534, 5042, 604, 295, 613, 3487, 13, 51432], "temperature": 0.0, "avg_logprob": -0.06673540709153661, "compression_ratio": 1.619718309859155, "no_speech_prob": 0.0002694716094993055}, {"id": 19, "seek": 8216, "start": 104.08, "end": 108.88, "text": " But I want to do something a little different. We'll take a discovery-based approach to learning", "tokens": [51460, 583, 286, 528, 281, 360, 746, 257, 707, 819, 13, 492, 603, 747, 257, 12114, 12, 6032, 3109, 281, 2539, 51700], "temperature": 0.0, "avg_logprob": -0.06673540709153661, "compression_ratio": 1.619718309859155, "no_speech_prob": 0.0002694716094993055}, {"id": 20, "seek": 10888, "start": 108.88, "end": 114.47999999999999, "text": " about the FFT in a context that you are all familiar with, polynomial multiplication.", "tokens": [50364, 466, 264, 479, 25469, 294, 257, 4319, 300, 291, 366, 439, 4963, 365, 11, 26110, 27290, 13, 50644], "temperature": 0.0, "avg_logprob": -0.07085947912247455, "compression_ratio": 1.4787234042553192, "no_speech_prob": 0.004467989318072796}, {"id": 21, "seek": 10888, "start": 114.47999999999999, "end": 119.36, "text": " The way I see the structure of this video, it's all about starting with some common ground and", "tokens": [50644, 440, 636, 286, 536, 264, 3877, 295, 341, 960, 11, 309, 311, 439, 466, 2891, 365, 512, 2689, 2727, 293, 50888], "temperature": 0.0, "avg_logprob": -0.07085947912247455, "compression_ratio": 1.4787234042553192, "no_speech_prob": 0.004467989318072796}, {"id": 22, "seek": 10888, "start": 119.36, "end": 125.12, "text": " then slowly asking questions that will hopefully prompt you to discover the truly ingenious ideas", "tokens": [50888, 550, 5692, 3365, 1651, 300, 486, 4696, 12391, 291, 281, 4411, 264, 4908, 21600, 851, 3487, 51176], "temperature": 0.0, "avg_logprob": -0.07085947912247455, "compression_ratio": 1.4787234042553192, "no_speech_prob": 0.004467989318072796}, {"id": 23, "seek": 12512, "start": 125.2, "end": 128.8, "text": " behind the FFT. Alright, let's get started.", "tokens": [50368, 2261, 264, 479, 25469, 13, 2798, 11, 718, 311, 483, 1409, 13, 50548], "temperature": 0.0, "avg_logprob": -0.13530241118537056, "compression_ratio": 1.4782608695652173, "no_speech_prob": 0.004070061258971691}, {"id": 24, "seek": 12512, "start": 138.96, "end": 144.4, "text": " The setup here is simple. We're given two polynomials and want to find the product.", "tokens": [51056, 440, 8657, 510, 307, 2199, 13, 492, 434, 2212, 732, 22560, 12356, 293, 528, 281, 915, 264, 1674, 13, 51328], "temperature": 0.0, "avg_logprob": -0.13530241118537056, "compression_ratio": 1.4782608695652173, "no_speech_prob": 0.004070061258971691}, {"id": 25, "seek": 12512, "start": 144.4, "end": 149.12, "text": " Our task will be to design an efficient algorithm for this problem. Mathematically,", "tokens": [51328, 2621, 5633, 486, 312, 281, 1715, 364, 7148, 9284, 337, 341, 1154, 13, 15776, 40197, 11, 51564], "temperature": 0.0, "avg_logprob": -0.13530241118537056, "compression_ratio": 1.4782608695652173, "no_speech_prob": 0.004070061258971691}, {"id": 26, "seek": 12512, "start": 149.12, "end": 154.64000000000001, "text": " we know one algorithm to multiply polynomials by repeatedly applying the distributed property.", "tokens": [51564, 321, 458, 472, 9284, 281, 12972, 22560, 12356, 538, 18227, 9275, 264, 12631, 4707, 13, 51840], "temperature": 0.0, "avg_logprob": -0.13530241118537056, "compression_ratio": 1.4782608695652173, "no_speech_prob": 0.004070061258971691}, {"id": 27, "seek": 15464, "start": 154.64, "end": 158.79999999999998, "text": " All of you have perhaps instinctively been applying this algorithm since any algebra class.", "tokens": [50364, 1057, 295, 291, 362, 4317, 16556, 3413, 668, 9275, 341, 9284, 1670, 604, 21989, 1508, 13, 50572], "temperature": 0.0, "avg_logprob": -0.07371986755216965, "compression_ratio": 1.7701149425287357, "no_speech_prob": 0.00015843276923988014}, {"id": 28, "seek": 15464, "start": 159.6, "end": 164.23999999999998, "text": " Before we try this idea though, the first question we have to address is representation", "tokens": [50612, 4546, 321, 853, 341, 1558, 1673, 11, 264, 700, 1168, 321, 362, 281, 2985, 307, 10290, 50844], "temperature": 0.0, "avg_logprob": -0.07371986755216965, "compression_ratio": 1.7701149425287357, "no_speech_prob": 0.00015843276923988014}, {"id": 29, "seek": 15464, "start": 164.23999999999998, "end": 170.23999999999998, "text": " of polynomials in a computer. The most natural way to represent them is through coefficients,", "tokens": [50844, 295, 22560, 12356, 294, 257, 3820, 13, 440, 881, 3303, 636, 281, 2906, 552, 307, 807, 31994, 11, 51144], "temperature": 0.0, "avg_logprob": -0.07371986755216965, "compression_ratio": 1.7701149425287357, "no_speech_prob": 0.00015843276923988014}, {"id": 30, "seek": 15464, "start": 170.23999999999998, "end": 175.83999999999997, "text": " where we map coefficients to lists. It helps to arrange our coefficients in the following order,", "tokens": [51144, 689, 321, 4471, 31994, 281, 14511, 13, 467, 3665, 281, 9424, 527, 31994, 294, 264, 3480, 1668, 11, 51424], "temperature": 0.0, "avg_logprob": -0.07371986755216965, "compression_ratio": 1.7701149425287357, "no_speech_prob": 0.00015843276923988014}, {"id": 31, "seek": 15464, "start": 175.83999999999997, "end": 181.51999999999998, "text": " mainly because now the coefficient of the kth index is mapped to the coefficient of the kth", "tokens": [51424, 8704, 570, 586, 264, 17619, 295, 264, 350, 392, 8186, 307, 33318, 281, 264, 17619, 295, 264, 350, 392, 51708], "temperature": 0.0, "avg_logprob": -0.07371986755216965, "compression_ratio": 1.7701149425287357, "no_speech_prob": 0.00015843276923988014}, {"id": 32, "seek": 18152, "start": 181.52, "end": 187.20000000000002, "text": " degree term. We will refer to this representation as the coefficient representation of polynomials.", "tokens": [50364, 4314, 1433, 13, 492, 486, 2864, 281, 341, 10290, 382, 264, 17619, 10290, 295, 22560, 12356, 13, 50648], "temperature": 0.0, "avg_logprob": -0.12696335736443015, "compression_ratio": 1.6493506493506493, "no_speech_prob": 0.00033534536487422884}, {"id": 33, "seek": 18152, "start": 191.52, "end": 197.12, "text": " In general, given 2d degree polynomials, the product will have a degree of 2 times d.", "tokens": [50864, 682, 2674, 11, 2212, 568, 67, 4314, 22560, 12356, 11, 264, 1674, 486, 362, 257, 4314, 295, 568, 1413, 274, 13, 51144], "temperature": 0.0, "avg_logprob": -0.12696335736443015, "compression_ratio": 1.6493506493506493, "no_speech_prob": 0.00033534536487422884}, {"id": 34, "seek": 18152, "start": 197.12, "end": 201.84, "text": " And the running time of this algorithm, if we actually went about implementing it with the most", "tokens": [51144, 400, 264, 2614, 565, 295, 341, 9284, 11, 498, 321, 767, 1437, 466, 18114, 309, 365, 264, 881, 51380], "temperature": 0.0, "avg_logprob": -0.12696335736443015, "compression_ratio": 1.6493506493506493, "no_speech_prob": 0.00033534536487422884}, {"id": 35, "seek": 18152, "start": 201.84, "end": 208.32000000000002, "text": " natural distributed property approach, will be O of d squared, since each term in polynomial a will", "tokens": [51380, 3303, 12631, 4707, 3109, 11, 486, 312, 422, 295, 274, 8889, 11, 1670, 1184, 1433, 294, 26110, 257, 486, 51704], "temperature": 0.0, "avg_logprob": -0.12696335736443015, "compression_ratio": 1.6493506493506493, "no_speech_prob": 0.00033534536487422884}, {"id": 36, "seek": 20832, "start": 208.32, "end": 214.48, "text": " have to be multiplied by all terms in polynomial b. The question now is, can we do better?", "tokens": [50364, 362, 281, 312, 17207, 538, 439, 2115, 294, 26110, 272, 13, 440, 1168, 586, 307, 11, 393, 321, 360, 1101, 30, 50672], "temperature": 0.0, "avg_logprob": -0.07121918134600203, "compression_ratio": 1.7126436781609196, "no_speech_prob": 0.0005033263587392867}, {"id": 37, "seek": 20832, "start": 216.07999999999998, "end": 221.12, "text": " The first really clever idea comes from thinking about polynomials a little bit differently.", "tokens": [50752, 440, 700, 534, 13494, 1558, 1487, 490, 1953, 466, 22560, 12356, 257, 707, 857, 7614, 13, 51004], "temperature": 0.0, "avg_logprob": -0.07121918134600203, "compression_ratio": 1.7126436781609196, "no_speech_prob": 0.0005033263587392867}, {"id": 38, "seek": 20832, "start": 221.76, "end": 226.0, "text": " To see the key inside here, let's take a look at one of the simplest polynomials,", "tokens": [51036, 1407, 536, 264, 2141, 1854, 510, 11, 718, 311, 747, 257, 574, 412, 472, 295, 264, 22811, 22560, 12356, 11, 51248], "temperature": 0.0, "avg_logprob": -0.07121918134600203, "compression_ratio": 1.7126436781609196, "no_speech_prob": 0.0005033263587392867}, {"id": 39, "seek": 20832, "start": 226.0, "end": 231.76, "text": " a degree 1 polynomial or a linear function. We can represent any line with exactly two", "tokens": [51248, 257, 4314, 502, 26110, 420, 257, 8213, 2445, 13, 492, 393, 2906, 604, 1622, 365, 2293, 732, 51536], "temperature": 0.0, "avg_logprob": -0.07121918134600203, "compression_ratio": 1.7126436781609196, "no_speech_prob": 0.0005033263587392867}, {"id": 40, "seek": 20832, "start": 231.76, "end": 237.76, "text": " coefficients, one for the degree 0 term and one for the degree 1 term. The key part that makes", "tokens": [51536, 31994, 11, 472, 337, 264, 4314, 1958, 1433, 293, 472, 337, 264, 4314, 502, 1433, 13, 440, 2141, 644, 300, 1669, 51836], "temperature": 0.0, "avg_logprob": -0.07121918134600203, "compression_ratio": 1.7126436781609196, "no_speech_prob": 0.0005033263587392867}, {"id": 41, "seek": 23776, "start": 237.76, "end": 244.0, "text": " this representation valid is that every representation has a one to one mapping to a unique line.", "tokens": [50364, 341, 10290, 7363, 307, 300, 633, 10290, 575, 257, 472, 281, 472, 18350, 281, 257, 3845, 1622, 13, 50676], "temperature": 0.0, "avg_logprob": -0.06996834880173808, "compression_ratio": 1.8366533864541832, "no_speech_prob": 0.00033534420072101057}, {"id": 42, "seek": 23776, "start": 244.0, "end": 249.12, "text": " What other representations of a line have this property? There are actually several", "tokens": [50676, 708, 661, 33358, 295, 257, 1622, 362, 341, 4707, 30, 821, 366, 767, 2940, 50932], "temperature": 0.0, "avg_logprob": -0.06996834880173808, "compression_ratio": 1.8366533864541832, "no_speech_prob": 0.00033534420072101057}, {"id": 43, "seek": 23776, "start": 249.12, "end": 254.95999999999998, "text": " reasonable representations, but the one that we are going to use is the two point representation.", "tokens": [50932, 10585, 33358, 11, 457, 264, 472, 300, 321, 366, 516, 281, 764, 307, 264, 732, 935, 10290, 13, 51224], "temperature": 0.0, "avg_logprob": -0.06996834880173808, "compression_ratio": 1.8366533864541832, "no_speech_prob": 0.00033534420072101057}, {"id": 44, "seek": 23776, "start": 254.95999999999998, "end": 259.28, "text": " We know from geometry that any line can be represented by two distinct points.", "tokens": [51224, 492, 458, 490, 18426, 300, 604, 1622, 393, 312, 10379, 538, 732, 10644, 2793, 13, 51440], "temperature": 0.0, "avg_logprob": -0.06996834880173808, "compression_ratio": 1.8366533864541832, "no_speech_prob": 0.00033534420072101057}, {"id": 45, "seek": 23776, "start": 259.28, "end": 263.92, "text": " And turns out that there is a neat extension of this for general polynomials, which I will state here.", "tokens": [51440, 400, 4523, 484, 300, 456, 307, 257, 10654, 10320, 295, 341, 337, 2674, 22560, 12356, 11, 597, 286, 486, 1785, 510, 13, 51672], "temperature": 0.0, "avg_logprob": -0.06996834880173808, "compression_ratio": 1.8366533864541832, "no_speech_prob": 0.00033534420072101057}, {"id": 46, "seek": 26392, "start": 264.8, "end": 271.6, "text": " Any polynomial of degree d can be uniquely represented by d plus one points. For example,", "tokens": [50408, 2639, 26110, 295, 4314, 274, 393, 312, 31474, 10379, 538, 274, 1804, 472, 2793, 13, 1171, 1365, 11, 50748], "temperature": 0.0, "avg_logprob": -0.07313162750667995, "compression_ratio": 1.895582329317269, "no_speech_prob": 0.0023966715671122074}, {"id": 47, "seek": 26392, "start": 271.6, "end": 277.04, "text": " if I gave you three random points, this means that there is exactly one quadratic function", "tokens": [50748, 498, 286, 2729, 291, 1045, 4974, 2793, 11, 341, 1355, 300, 456, 307, 2293, 472, 37262, 2445, 51020], "temperature": 0.0, "avg_logprob": -0.07313162750667995, "compression_ratio": 1.895582329317269, "no_speech_prob": 0.0023966715671122074}, {"id": 48, "seek": 26392, "start": 277.04, "end": 282.56, "text": " that goes through all three of these points. If I give you four points, there is exactly one", "tokens": [51020, 300, 1709, 807, 439, 1045, 295, 613, 2793, 13, 759, 286, 976, 291, 1451, 2793, 11, 456, 307, 2293, 472, 51296], "temperature": 0.0, "avg_logprob": -0.07313162750667995, "compression_ratio": 1.895582329317269, "no_speech_prob": 0.0023966715671122074}, {"id": 49, "seek": 26392, "start": 282.56, "end": 287.20000000000005, "text": " cubic function that goes through all these points. This statement is perhaps a little surprising,", "tokens": [51296, 28733, 2445, 300, 1709, 807, 439, 613, 2793, 13, 639, 5629, 307, 4317, 257, 707, 8830, 11, 51528], "temperature": 0.0, "avg_logprob": -0.07313162750667995, "compression_ratio": 1.895582329317269, "no_speech_prob": 0.0023966715671122074}, {"id": 50, "seek": 26392, "start": 287.20000000000005, "end": 293.28000000000003, "text": " so it deserves a proof. Suppose I give you d plus one unique points of a d degree polynomial p of x.", "tokens": [51528, 370, 309, 17037, 257, 8177, 13, 21360, 286, 976, 291, 274, 1804, 472, 3845, 2793, 295, 257, 274, 4314, 26110, 280, 295, 2031, 13, 51832], "temperature": 0.0, "avg_logprob": -0.07313162750667995, "compression_ratio": 1.895582329317269, "no_speech_prob": 0.0023966715671122074}, {"id": 51, "seek": 29328, "start": 293.28, "end": 297.28, "text": " We want to show that for these set of points, there is only one set of coefficients.", "tokens": [50364, 492, 528, 281, 855, 300, 337, 613, 992, 295, 2793, 11, 456, 307, 787, 472, 992, 295, 31994, 13, 50564], "temperature": 0.0, "avg_logprob": -0.07989501953125, "compression_ratio": 1.7633587786259541, "no_speech_prob": 9.610159759176895e-05}, {"id": 52, "seek": 29328, "start": 297.84, "end": 301.76, "text": " So if we actually evaluate our polynomial at each of these points,", "tokens": [50592, 407, 498, 321, 767, 13059, 527, 26110, 412, 1184, 295, 613, 2793, 11, 50788], "temperature": 0.0, "avg_logprob": -0.07989501953125, "compression_ratio": 1.7633587786259541, "no_speech_prob": 9.610159759176895e-05}, {"id": 53, "seek": 29328, "start": 301.76, "end": 306.96, "text": " we get the following set of system of equations. Whenever you have a system of equations,", "tokens": [50788, 321, 483, 264, 3480, 992, 295, 1185, 295, 11787, 13, 14159, 291, 362, 257, 1185, 295, 11787, 11, 51048], "temperature": 0.0, "avg_logprob": -0.07989501953125, "compression_ratio": 1.7633587786259541, "no_speech_prob": 9.610159759176895e-05}, {"id": 54, "seek": 29328, "start": 306.96, "end": 311.03999999999996, "text": " writing it as a matrix vector product is almost always helpful for analysis.", "tokens": [51048, 3579, 309, 382, 257, 8141, 8062, 1674, 307, 1920, 1009, 4961, 337, 5215, 13, 51252], "temperature": 0.0, "avg_logprob": -0.07989501953125, "compression_ratio": 1.7633587786259541, "no_speech_prob": 9.610159759176895e-05}, {"id": 55, "seek": 29328, "start": 312.23999999999995, "end": 316.88, "text": " One nice property of this matrix is that if each of our original points is unique,", "tokens": [51312, 1485, 1481, 4707, 295, 341, 8141, 307, 300, 498, 1184, 295, 527, 3380, 2793, 307, 3845, 11, 51544], "temperature": 0.0, "avg_logprob": -0.07989501953125, "compression_ratio": 1.7633587786259541, "no_speech_prob": 9.610159759176895e-05}, {"id": 56, "seek": 29328, "start": 316.88, "end": 320.55999999999995, "text": " as it is in this case, the matrix will always be invertible.", "tokens": [51544, 382, 309, 307, 294, 341, 1389, 11, 264, 8141, 486, 1009, 312, 33966, 964, 13, 51728], "temperature": 0.0, "avg_logprob": -0.07989501953125, "compression_ratio": 1.7633587786259541, "no_speech_prob": 9.610159759176895e-05}, {"id": 57, "seek": 32056, "start": 320.56, "end": 326.16, "text": " The easiest way to show this is by calculating the determinant, which you will find is non-zero,", "tokens": [50364, 440, 12889, 636, 281, 855, 341, 307, 538, 28258, 264, 41296, 11, 597, 291, 486, 915, 307, 2107, 12, 32226, 11, 50644], "temperature": 0.0, "avg_logprob": -0.08129584461177161, "compression_ratio": 1.710144927536232, "no_speech_prob": 0.000404472928494215}, {"id": 58, "seek": 32056, "start": 326.16, "end": 331.44, "text": " but I'll link a nice linear algebraic proof of this fact in the description as well for those", "tokens": [50644, 457, 286, 603, 2113, 257, 1481, 8213, 21989, 299, 8177, 295, 341, 1186, 294, 264, 3855, 382, 731, 337, 729, 50908], "temperature": 0.0, "avg_logprob": -0.08129584461177161, "compression_ratio": 1.710144927536232, "no_speech_prob": 0.000404472928494215}, {"id": 59, "seek": 32056, "start": 331.44, "end": 337.6, "text": " interested. Anyways, what this means is that for every set of points, there exists a unique set", "tokens": [50908, 3102, 13, 15585, 11, 437, 341, 1355, 307, 300, 337, 633, 992, 295, 2793, 11, 456, 8198, 257, 3845, 992, 51216], "temperature": 0.0, "avg_logprob": -0.08129584461177161, "compression_ratio": 1.710144927536232, "no_speech_prob": 0.000404472928494215}, {"id": 60, "seek": 32056, "start": 337.6, "end": 345.2, "text": " of coefficients and consequently a unique polynomial. Taking a step back, what this means", "tokens": [51216, 295, 31994, 293, 47259, 257, 3845, 26110, 13, 17837, 257, 1823, 646, 11, 437, 341, 1355, 51596], "temperature": 0.0, "avg_logprob": -0.08129584461177161, "compression_ratio": 1.710144927536232, "no_speech_prob": 0.000404472928494215}, {"id": 61, "seek": 32056, "start": 345.2, "end": 350.24, "text": " is that there are actually two ways to represent polynomials of degree d, the first of which is", "tokens": [51596, 307, 300, 456, 366, 767, 732, 2098, 281, 2906, 22560, 12356, 295, 4314, 274, 11, 264, 700, 295, 597, 307, 51848], "temperature": 0.0, "avg_logprob": -0.08129584461177161, "compression_ratio": 1.710144927536232, "no_speech_prob": 0.000404472928494215}, {"id": 62, "seek": 35024, "start": 350.24, "end": 356.0, "text": " the coefficient representation and the second with just d plus one points, which we will call", "tokens": [50364, 264, 17619, 10290, 293, 264, 1150, 365, 445, 274, 1804, 472, 2793, 11, 597, 321, 486, 818, 50652], "temperature": 0.0, "avg_logprob": -0.08672934016962161, "compression_ratio": 1.7155963302752293, "no_speech_prob": 6.814773223595694e-05}, {"id": 63, "seek": 35024, "start": 356.0, "end": 363.04, "text": " the value representation. A nice property of using the value representation is multiplication", "tokens": [50652, 264, 2158, 10290, 13, 316, 1481, 4707, 295, 1228, 264, 2158, 10290, 307, 27290, 51004], "temperature": 0.0, "avg_logprob": -0.08672934016962161, "compression_ratio": 1.7155963302752293, "no_speech_prob": 6.814773223595694e-05}, {"id": 64, "seek": 35024, "start": 363.04, "end": 369.28000000000003, "text": " of polynomials is much easier. Let's say I ask you to multiply these two polynomials a of x", "tokens": [51004, 295, 22560, 12356, 307, 709, 3571, 13, 961, 311, 584, 286, 1029, 291, 281, 12972, 613, 732, 22560, 12356, 257, 295, 2031, 51316], "temperature": 0.0, "avg_logprob": -0.08672934016962161, "compression_ratio": 1.7155963302752293, "no_speech_prob": 6.814773223595694e-05}, {"id": 65, "seek": 35024, "start": 369.28000000000003, "end": 376.24, "text": " and b of x. We know the resulting polynomial c of x will be of degree four, so we'll need five", "tokens": [51316, 293, 272, 295, 2031, 13, 492, 458, 264, 16505, 26110, 269, 295, 2031, 486, 312, 295, 4314, 1451, 11, 370, 321, 603, 643, 1732, 51664], "temperature": 0.0, "avg_logprob": -0.08672934016962161, "compression_ratio": 1.7155963302752293, "no_speech_prob": 6.814773223595694e-05}, {"id": 66, "seek": 37624, "start": 376.24, "end": 382.32, "text": " points to uniquely represent the product. What we can now do is take five points from each of the", "tokens": [50364, 2793, 281, 31474, 2906, 264, 1674, 13, 708, 321, 393, 586, 360, 307, 747, 1732, 2793, 490, 1184, 295, 264, 50668], "temperature": 0.0, "avg_logprob": -0.05210321000281801, "compression_ratio": 1.8755186721991701, "no_speech_prob": 0.0010004752548411489}, {"id": 67, "seek": 37624, "start": 382.32, "end": 387.6, "text": " two polynomials and then simply multiply the function values one by one to get the value", "tokens": [50668, 732, 22560, 12356, 293, 550, 2935, 12972, 264, 2445, 4190, 472, 538, 472, 281, 483, 264, 2158, 50932], "temperature": 0.0, "avg_logprob": -0.05210321000281801, "compression_ratio": 1.8755186721991701, "no_speech_prob": 0.0010004752548411489}, {"id": 68, "seek": 37624, "start": 387.6, "end": 394.48, "text": " representation of the product of the two polynomials. Following our earlier rule,", "tokens": [50932, 10290, 295, 264, 1674, 295, 264, 732, 22560, 12356, 13, 19192, 527, 3071, 4978, 11, 51276], "temperature": 0.0, "avg_logprob": -0.05210321000281801, "compression_ratio": 1.8755186721991701, "no_speech_prob": 0.0010004752548411489}, {"id": 69, "seek": 37624, "start": 394.48, "end": 399.52, "text": " there is only one degree four polynomial that passes through these points. That polynomial", "tokens": [51276, 456, 307, 787, 472, 4314, 1451, 26110, 300, 11335, 807, 613, 2793, 13, 663, 26110, 51528], "temperature": 0.0, "avg_logprob": -0.05210321000281801, "compression_ratio": 1.8755186721991701, "no_speech_prob": 0.0010004752548411489}, {"id": 70, "seek": 37624, "start": 399.52, "end": 404.16, "text": " happens to be the following in the coefficient representation and this is indeed the product", "tokens": [51528, 2314, 281, 312, 264, 3480, 294, 264, 17619, 10290, 293, 341, 307, 6451, 264, 1674, 51760], "temperature": 0.0, "avg_logprob": -0.05210321000281801, "compression_ratio": 1.8755186721991701, "no_speech_prob": 0.0010004752548411489}, {"id": 71, "seek": 40416, "start": 404.16, "end": 410.64000000000004, "text": " of our original a of x and b of x polynomials. With the multiplication operation being performed", "tokens": [50364, 295, 527, 3380, 257, 295, 2031, 293, 272, 295, 2031, 22560, 12356, 13, 2022, 264, 27290, 6916, 885, 10332, 50688], "temperature": 0.0, "avg_logprob": -0.05918378005793065, "compression_ratio": 1.7934272300469483, "no_speech_prob": 0.00047284134780056775}, {"id": 72, "seek": 40416, "start": 410.64000000000004, "end": 416.16, "text": " using the value representation, we've now reduced the time for multiplication from our original", "tokens": [50688, 1228, 264, 2158, 10290, 11, 321, 600, 586, 9212, 264, 565, 337, 27290, 490, 527, 3380, 50964], "temperature": 0.0, "avg_logprob": -0.05918378005793065, "compression_ratio": 1.7934272300469483, "no_speech_prob": 0.00047284134780056775}, {"id": 73, "seek": 40416, "start": 416.16, "end": 424.72, "text": " d squared operations to the order of only degree d operations. Okay, so let's propose a plan for", "tokens": [50964, 274, 8889, 7705, 281, 264, 1668, 295, 787, 4314, 274, 7705, 13, 1033, 11, 370, 718, 311, 17421, 257, 1393, 337, 51392], "temperature": 0.0, "avg_logprob": -0.05918378005793065, "compression_ratio": 1.7934272300469483, "no_speech_prob": 0.00047284134780056775}, {"id": 74, "seek": 40416, "start": 424.72, "end": 429.84000000000003, "text": " an improvement to polynomial multiplication. We are given two polynomials in the coefficient", "tokens": [51392, 364, 10444, 281, 26110, 27290, 13, 492, 366, 2212, 732, 22560, 12356, 294, 264, 17619, 51648], "temperature": 0.0, "avg_logprob": -0.05918378005793065, "compression_ratio": 1.7934272300469483, "no_speech_prob": 0.00047284134780056775}, {"id": 75, "seek": 42984, "start": 429.84, "end": 435.91999999999996, "text": " representation of degree d each. We know multiplication is faster using the value representation,", "tokens": [50364, 10290, 295, 4314, 274, 1184, 13, 492, 458, 27290, 307, 4663, 1228, 264, 2158, 10290, 11, 50668], "temperature": 0.0, "avg_logprob": -0.08391823719457253, "compression_ratio": 1.9053497942386832, "no_speech_prob": 0.009411903098225594}, {"id": 76, "seek": 42984, "start": 435.91999999999996, "end": 441.67999999999995, "text": " so what we'll do is evaluate each of these polynomials at 2d plus one points, multiply each", "tokens": [50668, 370, 437, 321, 603, 360, 307, 13059, 1184, 295, 613, 22560, 12356, 412, 568, 67, 1804, 472, 2793, 11, 12972, 1184, 50956], "temperature": 0.0, "avg_logprob": -0.08391823719457253, "compression_ratio": 1.9053497942386832, "no_speech_prob": 0.009411903098225594}, {"id": 77, "seek": 42984, "start": 441.67999999999995, "end": 446.47999999999996, "text": " of these points pairwise to get the value representation of the product polynomial,", "tokens": [50956, 295, 613, 2793, 6119, 3711, 281, 483, 264, 2158, 10290, 295, 264, 1674, 26110, 11, 51196], "temperature": 0.0, "avg_logprob": -0.08391823719457253, "compression_ratio": 1.9053497942386832, "no_speech_prob": 0.009411903098225594}, {"id": 78, "seek": 42984, "start": 446.47999999999996, "end": 452.71999999999997, "text": " and then finally somehow convert the value representation back to the final coefficient", "tokens": [51196, 293, 550, 2721, 6063, 7620, 264, 2158, 10290, 646, 281, 264, 2572, 17619, 51508], "temperature": 0.0, "avg_logprob": -0.08391823719457253, "compression_ratio": 1.9053497942386832, "no_speech_prob": 0.009411903098225594}, {"id": 79, "seek": 42984, "start": 452.71999999999997, "end": 457.91999999999996, "text": " representation. This is the grand plan, but there are several pieces of the puzzle we haven't figured", "tokens": [51508, 10290, 13, 639, 307, 264, 2697, 1393, 11, 457, 456, 366, 2940, 3755, 295, 264, 12805, 321, 2378, 380, 8932, 51768], "temperature": 0.0, "avg_logprob": -0.08391823719457253, "compression_ratio": 1.9053497942386832, "no_speech_prob": 0.009411903098225594}, {"id": 80, "seek": 45792, "start": 457.92, "end": 463.36, "text": " out. What we're missing is really some sort of magic box that could take polynomials in the", "tokens": [50364, 484, 13, 708, 321, 434, 5361, 307, 534, 512, 1333, 295, 5585, 2424, 300, 727, 747, 22560, 12356, 294, 264, 50636], "temperature": 0.0, "avg_logprob": -0.07264225823538643, "compression_ratio": 1.7881773399014778, "no_speech_prob": 0.0017006642883643508}, {"id": 81, "seek": 45792, "start": 463.36, "end": 469.12, "text": " coefficient representation and convert them to the value representation and then vice versa.", "tokens": [50636, 17619, 10290, 293, 7620, 552, 281, 264, 2158, 10290, 293, 550, 11964, 25650, 13, 50924], "temperature": 0.0, "avg_logprob": -0.07264225823538643, "compression_ratio": 1.7881773399014778, "no_speech_prob": 0.0017006642883643508}, {"id": 82, "seek": 45792, "start": 469.12, "end": 474.8, "text": " That magic box my friends and trust me it is truly magical is the fast Fourier transform.", "tokens": [50924, 663, 5585, 2424, 452, 1855, 293, 3361, 385, 309, 307, 4908, 12066, 307, 264, 2370, 36810, 4088, 13, 51208], "temperature": 0.0, "avg_logprob": -0.07264225823538643, "compression_ratio": 1.7881773399014778, "no_speech_prob": 0.0017006642883643508}, {"id": 83, "seek": 45792, "start": 476.24, "end": 481.28000000000003, "text": " Let's first focus on taking polynomials from the coefficient representation to the value", "tokens": [51280, 961, 311, 700, 1879, 322, 1940, 22560, 12356, 490, 264, 17619, 10290, 281, 264, 2158, 51532], "temperature": 0.0, "avg_logprob": -0.07264225823538643, "compression_ratio": 1.7881773399014778, "no_speech_prob": 0.0017006642883643508}, {"id": 84, "seek": 48128, "start": 481.28, "end": 487.67999999999995, "text": " representation, which we will call evaluation. We have a degree d polynomial and we want to", "tokens": [50364, 10290, 11, 597, 321, 486, 818, 13344, 13, 492, 362, 257, 4314, 274, 26110, 293, 321, 528, 281, 50684], "temperature": 0.0, "avg_logprob": -0.05814312725532346, "compression_ratio": 1.5947136563876652, "no_speech_prob": 0.002396687399595976}, {"id": 85, "seek": 48128, "start": 487.67999999999995, "end": 493.28, "text": " evaluate the polynomial at n points where n is some number greater than d plus one.", "tokens": [50684, 13059, 264, 26110, 412, 297, 2793, 689, 297, 307, 512, 1230, 5044, 813, 274, 1804, 472, 13, 50964], "temperature": 0.0, "avg_logprob": -0.05814312725532346, "compression_ratio": 1.5947136563876652, "no_speech_prob": 0.002396687399595976}, {"id": 86, "seek": 48128, "start": 493.28, "end": 498.88, "text": " Let's think about the most straightforward way to do this. We can pick n random x coordinates", "tokens": [50964, 961, 311, 519, 466, 264, 881, 15325, 636, 281, 360, 341, 13, 492, 393, 1888, 297, 4974, 2031, 21056, 51244], "temperature": 0.0, "avg_logprob": -0.05814312725532346, "compression_ratio": 1.5947136563876652, "no_speech_prob": 0.002396687399595976}, {"id": 87, "seek": 48128, "start": 498.88, "end": 505.03999999999996, "text": " and simply calculate the respective y coordinate. This works, but when we deconstruct what's", "tokens": [51244, 293, 2935, 8873, 264, 23649, 288, 15670, 13, 639, 1985, 11, 457, 562, 321, 49473, 1757, 437, 311, 51552], "temperature": 0.0, "avg_logprob": -0.05814312725532346, "compression_ratio": 1.5947136563876652, "no_speech_prob": 0.002396687399595976}, {"id": 88, "seek": 50504, "start": 505.04, "end": 511.76000000000005, "text": " actually going on here, we run into our old foe. Each evaluation will take o of d operations,", "tokens": [50364, 767, 516, 322, 510, 11, 321, 1190, 666, 527, 1331, 726, 68, 13, 6947, 13344, 486, 747, 277, 295, 274, 7705, 11, 50700], "temperature": 0.0, "avg_logprob": -0.08360975346666702, "compression_ratio": 1.553648068669528, "no_speech_prob": 0.0021826939191669226}, {"id": 89, "seek": 50504, "start": 511.76000000000005, "end": 517.9200000000001, "text": " making this method run in o of n times d time, which ends up being o of d squared to evaluate", "tokens": [50700, 1455, 341, 3170, 1190, 294, 277, 295, 297, 1413, 274, 565, 11, 597, 5314, 493, 885, 277, 295, 274, 8889, 281, 13059, 51008], "temperature": 0.0, "avg_logprob": -0.08360975346666702, "compression_ratio": 1.553648068669528, "no_speech_prob": 0.0021826939191669226}, {"id": 90, "seek": 50504, "start": 517.9200000000001, "end": 523.6, "text": " all n points. So we're back to where we started. Can we find a way to optimize this?", "tokens": [51008, 439, 297, 2793, 13, 407, 321, 434, 646, 281, 689, 321, 1409, 13, 1664, 321, 915, 257, 636, 281, 19719, 341, 30, 51292], "temperature": 0.0, "avg_logprob": -0.08360975346666702, "compression_ratio": 1.553648068669528, "no_speech_prob": 0.0021826939191669226}, {"id": 91, "seek": 50504, "start": 525.04, "end": 530.0, "text": " Let's try to simplify the problem. Let's say instead of considering a general polynomial,", "tokens": [51364, 961, 311, 853, 281, 20460, 264, 1154, 13, 961, 311, 584, 2602, 295, 8079, 257, 2674, 26110, 11, 51612], "temperature": 0.0, "avg_logprob": -0.08360975346666702, "compression_ratio": 1.553648068669528, "no_speech_prob": 0.0021826939191669226}, {"id": 92, "seek": 53000, "start": 530.0, "end": 534.72, "text": " we wanted to instead just evaluate a simple polynomial like p of x is equal to x squared", "tokens": [50364, 321, 1415, 281, 2602, 445, 13059, 257, 2199, 26110, 411, 280, 295, 2031, 307, 2681, 281, 2031, 8889, 50600], "temperature": 0.0, "avg_logprob": -0.06912367748764325, "compression_ratio": 1.8487394957983194, "no_speech_prob": 0.000804071722086519}, {"id": 93, "seek": 53000, "start": 534.72, "end": 540.4, "text": " at eight points. The question now is, which points should we pick? Is there any set of", "tokens": [50600, 412, 3180, 2793, 13, 440, 1168, 586, 307, 11, 597, 2793, 820, 321, 1888, 30, 1119, 456, 604, 992, 295, 50884], "temperature": 0.0, "avg_logprob": -0.06912367748764325, "compression_ratio": 1.8487394957983194, "no_speech_prob": 0.000804071722086519}, {"id": 94, "seek": 53000, "start": 540.4, "end": 544.96, "text": " points when knowing the value of one point immediately implies the value of another?", "tokens": [50884, 2793, 562, 5276, 264, 2158, 295, 472, 935, 4258, 18779, 264, 2158, 295, 1071, 30, 51112], "temperature": 0.0, "avg_logprob": -0.06912367748764325, "compression_ratio": 1.8487394957983194, "no_speech_prob": 0.000804071722086519}, {"id": 95, "seek": 53000, "start": 546.48, "end": 551.6, "text": " In fact, there is. If we pick the point x equals one, we immediately know the value", "tokens": [51188, 682, 1186, 11, 456, 307, 13, 759, 321, 1888, 264, 935, 2031, 6915, 472, 11, 321, 4258, 458, 264, 2158, 51444], "temperature": 0.0, "avg_logprob": -0.06912367748764325, "compression_ratio": 1.8487394957983194, "no_speech_prob": 0.000804071722086519}, {"id": 96, "seek": 53000, "start": 551.6, "end": 557.36, "text": " of the point x equals negative one. Similarly, if we pick x equals two, we automatically know x", "tokens": [51444, 295, 264, 935, 2031, 6915, 3671, 472, 13, 13157, 11, 498, 321, 1888, 2031, 6915, 732, 11, 321, 6772, 458, 2031, 51732], "temperature": 0.0, "avg_logprob": -0.06912367748764325, "compression_ratio": 1.8487394957983194, "no_speech_prob": 0.000804071722086519}, {"id": 97, "seek": 55736, "start": 557.36, "end": 562.8000000000001, "text": " equals negative two will have the same value. Extending this idea, the key property we want", "tokens": [50364, 6915, 3671, 732, 486, 362, 264, 912, 2158, 13, 9881, 2029, 341, 1558, 11, 264, 2141, 4707, 321, 528, 50636], "temperature": 0.0, "avg_logprob": -0.07923612861989815, "compression_ratio": 1.7640449438202248, "no_speech_prob": 0.0011694785207509995}, {"id": 98, "seek": 55736, "start": 562.8000000000001, "end": 568.16, "text": " here is that our eight points should be positive negative pairs. The reason this works is due to", "tokens": [50636, 510, 307, 300, 527, 3180, 2793, 820, 312, 3353, 3671, 15494, 13, 440, 1778, 341, 1985, 307, 3462, 281, 50904], "temperature": 0.0, "avg_logprob": -0.07923612861989815, "compression_ratio": 1.7640449438202248, "no_speech_prob": 0.0011694785207509995}, {"id": 99, "seek": 55736, "start": 568.16, "end": 573.12, "text": " the property of even functions where a function evaluated at negative x is going to equal the", "tokens": [50904, 264, 4707, 295, 754, 6828, 689, 257, 2445, 25509, 412, 3671, 2031, 307, 516, 281, 2681, 264, 51152], "temperature": 0.0, "avg_logprob": -0.07923612861989815, "compression_ratio": 1.7640449438202248, "no_speech_prob": 0.0011694785207509995}, {"id": 100, "seek": 55736, "start": 573.12, "end": 579.76, "text": " function evaluated at positive x. Okay, but then the next immediate question is, what about functions", "tokens": [51152, 2445, 25509, 412, 3353, 2031, 13, 1033, 11, 457, 550, 264, 958, 11629, 1168, 307, 11, 437, 466, 6828, 51484], "temperature": 0.0, "avg_logprob": -0.07923612861989815, "compression_ratio": 1.7640449438202248, "no_speech_prob": 0.0011694785207509995}, {"id": 101, "seek": 55736, "start": 579.76, "end": 586.24, "text": " like x cubed? Does the same trick work? It actually kind of does, but with one caveat.", "tokens": [51484, 411, 2031, 36510, 30, 4402, 264, 912, 4282, 589, 30, 467, 767, 733, 295, 775, 11, 457, 365, 472, 43012, 13, 51808], "temperature": 0.0, "avg_logprob": -0.07923612861989815, "compression_ratio": 1.7640449438202248, "no_speech_prob": 0.0011694785207509995}, {"id": 102, "seek": 58624, "start": 586.24, "end": 591.6800000000001, "text": " Each positive x value will have the same value as the negative x value, but with the sign flipped.", "tokens": [50364, 6947, 3353, 2031, 2158, 486, 362, 264, 912, 2158, 382, 264, 3671, 2031, 2158, 11, 457, 365, 264, 1465, 26273, 13, 50636], "temperature": 0.0, "avg_logprob": -0.06397001868800113, "compression_ratio": 1.7439024390243902, "no_speech_prob": 0.00010554574691923335}, {"id": 103, "seek": 58624, "start": 592.5600000000001, "end": 598.08, "text": " So in these two cases of odd and even degree single term polynomials, instead of evaluating", "tokens": [50680, 407, 294, 613, 732, 3331, 295, 7401, 293, 754, 4314, 2167, 1433, 22560, 12356, 11, 2602, 295, 27479, 50956], "temperature": 0.0, "avg_logprob": -0.06397001868800113, "compression_ratio": 1.7439024390243902, "no_speech_prob": 0.00010554574691923335}, {"id": 104, "seek": 58624, "start": 598.08, "end": 604.4, "text": " eight individual points, we can actually get away with evaluating exactly four positive points,", "tokens": [50956, 3180, 2609, 2793, 11, 321, 393, 767, 483, 1314, 365, 27479, 2293, 1451, 3353, 2793, 11, 51272], "temperature": 0.0, "avg_logprob": -0.06397001868800113, "compression_ratio": 1.7439024390243902, "no_speech_prob": 0.00010554574691923335}, {"id": 105, "seek": 58624, "start": 604.4, "end": 608.48, "text": " from which we immediately know the value of the respective negative points.", "tokens": [51272, 490, 597, 321, 4258, 458, 264, 2158, 295, 264, 23649, 3671, 2793, 13, 51476], "temperature": 0.0, "avg_logprob": -0.06397001868800113, "compression_ratio": 1.7439024390243902, "no_speech_prob": 0.00010554574691923335}, {"id": 106, "seek": 58624, "start": 610.08, "end": 613.6800000000001, "text": " Let's see if we can extend this idea to a more general polynomial,", "tokens": [51556, 961, 311, 536, 498, 321, 393, 10101, 341, 1558, 281, 257, 544, 2674, 26110, 11, 51736], "temperature": 0.0, "avg_logprob": -0.06397001868800113, "compression_ratio": 1.7439024390243902, "no_speech_prob": 0.00010554574691923335}, {"id": 107, "seek": 61368, "start": 614.3199999999999, "end": 619.3599999999999, "text": " taking inspiration from our early exploration, let's split our polynomial into even and odd", "tokens": [50396, 1940, 10249, 490, 527, 2440, 16197, 11, 718, 311, 7472, 527, 26110, 666, 754, 293, 7401, 50648], "temperature": 0.0, "avg_logprob": -0.07109953842911065, "compression_ratio": 1.86, "no_speech_prob": 0.0007096604676917195}, {"id": 108, "seek": 61368, "start": 619.3599999999999, "end": 625.76, "text": " degree terms. If we factor an x from the odd degree terms, we end up having two new polynomials,", "tokens": [50648, 4314, 2115, 13, 759, 321, 5952, 364, 2031, 490, 264, 7401, 4314, 2115, 11, 321, 917, 493, 1419, 732, 777, 22560, 12356, 11, 50968], "temperature": 0.0, "avg_logprob": -0.07109953842911065, "compression_ratio": 1.86, "no_speech_prob": 0.0007096604676917195}, {"id": 109, "seek": 61368, "start": 625.76, "end": 630.56, "text": " where these new polynomials have only even degree terms. Let's actually give these", "tokens": [50968, 689, 613, 777, 22560, 12356, 362, 787, 754, 4314, 2115, 13, 961, 311, 767, 976, 613, 51208], "temperature": 0.0, "avg_logprob": -0.07109953842911065, "compression_ratio": 1.86, "no_speech_prob": 0.0007096604676917195}, {"id": 110, "seek": 61368, "start": 630.56, "end": 636.0, "text": " polynomials formal names, the first representing the even terms and the second representing", "tokens": [51208, 22560, 12356, 9860, 5288, 11, 264, 700, 13460, 264, 754, 2115, 293, 264, 1150, 13460, 51480], "temperature": 0.0, "avg_logprob": -0.07109953842911065, "compression_ratio": 1.86, "no_speech_prob": 0.0007096604676917195}, {"id": 111, "seek": 61368, "start": 636.0, "end": 642.4799999999999, "text": " odd terms after factoring out x. This fact allows us to recycle a lot of computation between positive", "tokens": [51480, 7401, 2115, 934, 1186, 3662, 484, 2031, 13, 639, 1186, 4045, 505, 281, 32162, 257, 688, 295, 24903, 1296, 3353, 51804], "temperature": 0.0, "avg_logprob": -0.07109953842911065, "compression_ratio": 1.86, "no_speech_prob": 0.0007096604676917195}, {"id": 112, "seek": 64248, "start": 642.48, "end": 647.9200000000001, "text": " and negative pairs of points. A bonus fact is that since these even and odd polynomials are", "tokens": [50364, 293, 3671, 15494, 295, 2793, 13, 316, 10882, 1186, 307, 300, 1670, 613, 754, 293, 7401, 22560, 12356, 366, 50636], "temperature": 0.0, "avg_logprob": -0.06138125587912167, "compression_ratio": 1.7104072398190044, "no_speech_prob": 0.00023050438903737813}, {"id": 113, "seek": 64248, "start": 647.9200000000001, "end": 653.28, "text": " functions of x squared, they are polynomials of degree two, which is a much simpler problem than", "tokens": [50636, 6828, 295, 2031, 8889, 11, 436, 366, 22560, 12356, 295, 4314, 732, 11, 597, 307, 257, 709, 18587, 1154, 813, 50904], "temperature": 0.0, "avg_logprob": -0.06138125587912167, "compression_ratio": 1.7104072398190044, "no_speech_prob": 0.00023050438903737813}, {"id": 114, "seek": 64248, "start": 653.28, "end": 660.8000000000001, "text": " our original degree five polynomial. Generalizing these observations, if we have an n minus one", "tokens": [50904, 527, 3380, 4314, 1732, 26110, 13, 6996, 3319, 613, 18163, 11, 498, 321, 362, 364, 297, 3175, 472, 51280], "temperature": 0.0, "avg_logprob": -0.06138125587912167, "compression_ratio": 1.7104072398190044, "no_speech_prob": 0.00023050438903737813}, {"id": 115, "seek": 64248, "start": 660.8000000000001, "end": 667.12, "text": " degree polynomial that we want to evaluate at n points, we can split the polynomial into even", "tokens": [51280, 4314, 26110, 300, 321, 528, 281, 13059, 412, 297, 2793, 11, 321, 393, 7472, 264, 26110, 666, 754, 51596], "temperature": 0.0, "avg_logprob": -0.06138125587912167, "compression_ratio": 1.7104072398190044, "no_speech_prob": 0.00023050438903737813}, {"id": 116, "seek": 66712, "start": 667.12, "end": 673.52, "text": " and odd terms with these two smaller polynomials now having degree n over two minus one. So,", "tokens": [50364, 293, 7401, 2115, 365, 613, 732, 4356, 22560, 12356, 586, 1419, 4314, 297, 670, 732, 3175, 472, 13, 407, 11, 50684], "temperature": 0.0, "avg_logprob": -0.07054917789199977, "compression_ratio": 1.793774319066148, "no_speech_prob": 0.0010987126734107733}, {"id": 117, "seek": 66712, "start": 673.52, "end": 678.16, "text": " how do we evaluate these polynomials with half the degree of our original polynomial?", "tokens": [50684, 577, 360, 321, 13059, 613, 22560, 12356, 365, 1922, 264, 4314, 295, 527, 3380, 26110, 30, 50916], "temperature": 0.0, "avg_logprob": -0.07054917789199977, "compression_ratio": 1.793774319066148, "no_speech_prob": 0.0010987126734107733}, {"id": 118, "seek": 66712, "start": 678.16, "end": 683.76, "text": " Well, what's beautiful here is that this is just another evaluation problem, but this time", "tokens": [50916, 1042, 11, 437, 311, 2238, 510, 307, 300, 341, 307, 445, 1071, 13344, 1154, 11, 457, 341, 565, 51196], "temperature": 0.0, "avg_logprob": -0.07054917789199977, "compression_ratio": 1.793774319066148, "no_speech_prob": 0.0010987126734107733}, {"id": 119, "seek": 66712, "start": 683.76, "end": 689.6, "text": " we need to evaluate the polynomials at each of our original inputs squared. And this works out", "tokens": [51196, 321, 643, 281, 13059, 264, 22560, 12356, 412, 1184, 295, 527, 3380, 15743, 8889, 13, 400, 341, 1985, 484, 51488], "temperature": 0.0, "avg_logprob": -0.07054917789199977, "compression_ratio": 1.793774319066148, "no_speech_prob": 0.0010987126734107733}, {"id": 120, "seek": 66712, "start": 689.6, "end": 695.44, "text": " nicely since our original points were positive negative pairs, so if we originally had n points,", "tokens": [51488, 9594, 1670, 527, 3380, 2793, 645, 3353, 3671, 15494, 11, 370, 498, 321, 7993, 632, 297, 2793, 11, 51780], "temperature": 0.0, "avg_logprob": -0.07054917789199977, "compression_ratio": 1.793774319066148, "no_speech_prob": 0.0010987126734107733}, {"id": 121, "seek": 69544, "start": 695.5200000000001, "end": 700.96, "text": " we now only end up having n over two points. This is starting to smell like the start of", "tokens": [50368, 321, 586, 787, 917, 493, 1419, 297, 670, 732, 2793, 13, 639, 307, 2891, 281, 4316, 411, 264, 722, 295, 50640], "temperature": 0.0, "avg_logprob": -0.07286496214814238, "compression_ratio": 1.7155555555555555, "no_speech_prob": 7.254297815961763e-05}, {"id": 122, "seek": 69544, "start": 700.96, "end": 707.6, "text": " a recursive algorithm. Let's take a look at the bigger picture. We want to evaluate a polynomial", "tokens": [50640, 257, 20560, 488, 9284, 13, 961, 311, 747, 257, 574, 412, 264, 3801, 3036, 13, 492, 528, 281, 13059, 257, 26110, 50972], "temperature": 0.0, "avg_logprob": -0.07286496214814238, "compression_ratio": 1.7155555555555555, "no_speech_prob": 7.254297815961763e-05}, {"id": 123, "seek": 69544, "start": 707.6, "end": 714.96, "text": " p of x at n points where the n points are positive negative paired. We split the polynomial into odd", "tokens": [50972, 280, 295, 2031, 412, 297, 2793, 689, 264, 297, 2793, 366, 3353, 3671, 25699, 13, 492, 7472, 264, 26110, 666, 7401, 51340], "temperature": 0.0, "avg_logprob": -0.07286496214814238, "compression_ratio": 1.7155555555555555, "no_speech_prob": 7.254297815961763e-05}, {"id": 124, "seek": 69544, "start": 714.96, "end": 721.12, "text": " and even degree components where we now have two simpler polynomials of degree n over two minus one", "tokens": [51340, 293, 754, 4314, 6677, 689, 321, 586, 362, 732, 18587, 22560, 12356, 295, 4314, 297, 670, 732, 3175, 472, 51648], "temperature": 0.0, "avg_logprob": -0.07286496214814238, "compression_ratio": 1.7155555555555555, "no_speech_prob": 7.254297815961763e-05}, {"id": 125, "seek": 72112, "start": 721.12, "end": 727.28, "text": " that only need n over two points to evaluate. Once we recursively evaluate these smaller", "tokens": [50364, 300, 787, 643, 297, 670, 732, 2793, 281, 13059, 13, 3443, 321, 20560, 3413, 13059, 613, 4356, 50672], "temperature": 0.0, "avg_logprob": -0.058670371770858765, "compression_ratio": 1.6875, "no_speech_prob": 0.0003353451029397547}, {"id": 126, "seek": 72112, "start": 727.28, "end": 732.08, "text": " polynomials, we can then go through every point in our original set of n points and calculate the", "tokens": [50672, 22560, 12356, 11, 321, 393, 550, 352, 807, 633, 935, 294, 527, 3380, 992, 295, 297, 2793, 293, 8873, 264, 50912], "temperature": 0.0, "avg_logprob": -0.058670371770858765, "compression_ratio": 1.6875, "no_speech_prob": 0.0003353451029397547}, {"id": 127, "seek": 72112, "start": 732.08, "end": 737.2, "text": " respective values by utilizing the relationship between the positive and negative paired points.", "tokens": [50912, 23649, 4190, 538, 26775, 264, 2480, 1296, 264, 3353, 293, 3671, 25699, 2793, 13, 51168], "temperature": 0.0, "avg_logprob": -0.058670371770858765, "compression_ratio": 1.6875, "no_speech_prob": 0.0003353451029397547}, {"id": 128, "seek": 72112, "start": 738.64, "end": 745.04, "text": " This gives us the value representation of our original polynomial. If we can get this to work,", "tokens": [51240, 639, 2709, 505, 264, 2158, 10290, 295, 527, 3380, 26110, 13, 759, 321, 393, 483, 341, 281, 589, 11, 51560], "temperature": 0.0, "avg_logprob": -0.058670371770858765, "compression_ratio": 1.6875, "no_speech_prob": 0.0003353451029397547}, {"id": 129, "seek": 74504, "start": 745.04, "end": 750.9599999999999, "text": " this means we have an O of n log n recursive algorithm since the two recursive sub problems", "tokens": [50364, 341, 1355, 321, 362, 364, 422, 295, 297, 3565, 297, 20560, 488, 9284, 1670, 264, 732, 20560, 488, 1422, 2740, 50660], "temperature": 0.0, "avg_logprob": -0.07827036795408829, "compression_ratio": 1.652542372881356, "no_speech_prob": 0.00023782040807418525}, {"id": 130, "seek": 74504, "start": 750.9599999999999, "end": 756.64, "text": " have half the size of the original problem and take linear time to evaluate the n points.", "tokens": [50660, 362, 1922, 264, 2744, 295, 264, 3380, 1154, 293, 747, 8213, 565, 281, 13059, 264, 297, 2793, 13, 50944], "temperature": 0.0, "avg_logprob": -0.07827036795408829, "compression_ratio": 1.652542372881356, "no_speech_prob": 0.00023782040807418525}, {"id": 131, "seek": 74504, "start": 756.64, "end": 760.3199999999999, "text": " This would be a huge improvement from our earlier quadratic running time,", "tokens": [50944, 639, 576, 312, 257, 2603, 10444, 490, 527, 3071, 37262, 2614, 565, 11, 51128], "temperature": 0.0, "avg_logprob": -0.07827036795408829, "compression_ratio": 1.652542372881356, "no_speech_prob": 0.00023782040807418525}, {"id": 132, "seek": 74504, "start": 760.3199999999999, "end": 763.76, "text": " but there is one major problem. Can you spot the issue?", "tokens": [51128, 457, 456, 307, 472, 2563, 1154, 13, 1664, 291, 4008, 264, 2734, 30, 51300], "temperature": 0.0, "avg_logprob": -0.07827036795408829, "compression_ratio": 1.652542372881356, "no_speech_prob": 0.00023782040807418525}, {"id": 133, "seek": 74504, "start": 766.0, "end": 771.12, "text": " The problem occurs at the recursive step. The entire scheme relies on the fact", "tokens": [51412, 440, 1154, 11843, 412, 264, 20560, 488, 1823, 13, 440, 2302, 12232, 30910, 322, 264, 1186, 51668], "temperature": 0.0, "avg_logprob": -0.07827036795408829, "compression_ratio": 1.652542372881356, "no_speech_prob": 0.00023782040807418525}, {"id": 134, "seek": 77112, "start": 771.12, "end": 775.6, "text": " that the polynomial will have positive and negative paired points for evaluation.", "tokens": [50364, 300, 264, 26110, 486, 362, 3353, 293, 3671, 25699, 2793, 337, 13344, 13, 50588], "temperature": 0.0, "avg_logprob": -0.09099325853235582, "compression_ratio": 1.726027397260274, "no_speech_prob": 0.0006666853441856802}, {"id": 135, "seek": 77112, "start": 776.16, "end": 781.52, "text": " This works at the top level, but the next level we are evaluating n over two points where each", "tokens": [50616, 639, 1985, 412, 264, 1192, 1496, 11, 457, 264, 958, 1496, 321, 366, 27479, 297, 670, 732, 2793, 689, 1184, 50884], "temperature": 0.0, "avg_logprob": -0.09099325853235582, "compression_ratio": 1.726027397260274, "no_speech_prob": 0.0006666853441856802}, {"id": 136, "seek": 77112, "start": 781.52, "end": 788.32, "text": " point is a squared value. These all end up being positive so the recursion breaks. So then the natural", "tokens": [50884, 935, 307, 257, 8889, 2158, 13, 1981, 439, 917, 493, 885, 3353, 370, 264, 20560, 313, 9857, 13, 407, 550, 264, 3303, 51224], "temperature": 0.0, "avg_logprob": -0.09099325853235582, "compression_ratio": 1.726027397260274, "no_speech_prob": 0.0006666853441856802}, {"id": 137, "seek": 77112, "start": 788.32, "end": 795.04, "text": " question is, can we make these new set of points positive negative paired? Some of you may already", "tokens": [51224, 1168, 307, 11, 393, 321, 652, 613, 777, 992, 295, 2793, 3353, 3671, 25699, 30, 2188, 295, 291, 815, 1217, 51560], "temperature": 0.0, "avg_logprob": -0.09099325853235582, "compression_ratio": 1.726027397260274, "no_speech_prob": 0.0006666853441856802}, {"id": 138, "seek": 79504, "start": 795.04, "end": 800.4, "text": " see it, but this actually leads to the third absolutely ingenious idea behind the FFT.", "tokens": [50364, 536, 309, 11, 457, 341, 767, 6689, 281, 264, 2636, 3122, 21600, 851, 1558, 2261, 264, 479, 25469, 13, 50632], "temperature": 0.0, "avg_logprob": -0.06292477082670404, "compression_ratio": 1.6942148760330578, "no_speech_prob": 0.005384757183492184}, {"id": 139, "seek": 79504, "start": 800.9599999999999, "end": 807.68, "text": " The only way this is possible is if we expand the domain of possible initial points to include", "tokens": [50660, 440, 787, 636, 341, 307, 1944, 307, 498, 321, 5268, 264, 9274, 295, 1944, 5883, 2793, 281, 4090, 50996], "temperature": 0.0, "avg_logprob": -0.06292477082670404, "compression_ratio": 1.6942148760330578, "no_speech_prob": 0.005384757183492184}, {"id": 140, "seek": 79504, "start": 807.68, "end": 814.16, "text": " complex numbers. For a special choice of complex numbers, the recursive relation works perfectly", "tokens": [50996, 3997, 3547, 13, 1171, 257, 2121, 3922, 295, 3997, 3547, 11, 264, 20560, 488, 9721, 1985, 6239, 51320], "temperature": 0.0, "avg_logprob": -0.06292477082670404, "compression_ratio": 1.6942148760330578, "no_speech_prob": 0.005384757183492184}, {"id": 141, "seek": 79504, "start": 814.16, "end": 818.4, "text": " where every subsequent set of points will contain positive negative pairs.", "tokens": [51320, 689, 633, 19962, 992, 295, 2793, 486, 5304, 3353, 3671, 15494, 13, 51532], "temperature": 0.0, "avg_logprob": -0.06292477082670404, "compression_ratio": 1.6942148760330578, "no_speech_prob": 0.005384757183492184}, {"id": 142, "seek": 79504, "start": 819.36, "end": 822.48, "text": " What possible set of initial n points has this property?", "tokens": [51580, 708, 1944, 992, 295, 5883, 297, 2793, 575, 341, 4707, 30, 51736], "temperature": 0.0, "avg_logprob": -0.06292477082670404, "compression_ratio": 1.6942148760330578, "no_speech_prob": 0.005384757183492184}, {"id": 143, "seek": 82248, "start": 823.36, "end": 827.44, "text": " This is a hard question and to answer it we are going to do a little bit of reverse", "tokens": [50408, 639, 307, 257, 1152, 1168, 293, 281, 1867, 309, 321, 366, 516, 281, 360, 257, 707, 857, 295, 9943, 50612], "temperature": 0.0, "avg_logprob": -0.09357986793861733, "compression_ratio": 1.6715867158671587, "no_speech_prob": 0.00048784440150484443}, {"id": 144, "seek": 82248, "start": 827.44, "end": 832.72, "text": " engineering with an example. Let's say we have a degree 3 polynomial which requires at least", "tokens": [50612, 7043, 365, 364, 1365, 13, 961, 311, 584, 321, 362, 257, 4314, 805, 26110, 597, 7029, 412, 1935, 50876], "temperature": 0.0, "avg_logprob": -0.09357986793861733, "compression_ratio": 1.6715867158671587, "no_speech_prob": 0.00048784440150484443}, {"id": 145, "seek": 82248, "start": 832.72, "end": 838.4, "text": " n equals 4 points for its value representation. These points need to be positive negative pairs", "tokens": [50876, 297, 6915, 1017, 2793, 337, 1080, 2158, 10290, 13, 1981, 2793, 643, 281, 312, 3353, 3671, 15494, 51160], "temperature": 0.0, "avg_logprob": -0.09357986793861733, "compression_ratio": 1.6715867158671587, "no_speech_prob": 0.00048784440150484443}, {"id": 146, "seek": 82248, "start": 838.4, "end": 845.52, "text": " so we can write them as x1, negative x1, x2, and negative x2. We know that the recursive step", "tokens": [51160, 370, 321, 393, 2464, 552, 382, 2031, 16, 11, 3671, 2031, 16, 11, 2031, 17, 11, 293, 3671, 2031, 17, 13, 492, 458, 300, 264, 20560, 488, 1823, 51516], "temperature": 0.0, "avg_logprob": -0.09357986793861733, "compression_ratio": 1.6715867158671587, "no_speech_prob": 0.00048784440150484443}, {"id": 147, "seek": 82248, "start": 845.52, "end": 850.8000000000001, "text": " will require that we evaluate the odd and even splits of the polynomial at two points,", "tokens": [51516, 486, 3651, 300, 321, 13059, 264, 7401, 293, 754, 37741, 295, 264, 26110, 412, 732, 2793, 11, 51780], "temperature": 0.0, "avg_logprob": -0.09357986793861733, "compression_ratio": 1.6715867158671587, "no_speech_prob": 0.00048784440150484443}, {"id": 148, "seek": 85080, "start": 850.88, "end": 857.1999999999999, "text": " x1 squared and x2 squared. Now the key constraint here is that for the recursion to work,", "tokens": [50368, 2031, 16, 8889, 293, 2031, 17, 8889, 13, 823, 264, 2141, 25534, 510, 307, 300, 337, 264, 20560, 313, 281, 589, 11, 50684], "temperature": 0.0, "avg_logprob": -0.08031016166764077, "compression_ratio": 1.704035874439462, "no_speech_prob": 0.0008040638640522957}, {"id": 149, "seek": 85080, "start": 857.1999999999999, "end": 863.52, "text": " these two points also have to be positive negative pairs. So we have an equivalence between x2", "tokens": [50684, 613, 732, 2793, 611, 362, 281, 312, 3353, 3671, 15494, 13, 407, 321, 362, 364, 9052, 655, 1296, 2031, 17, 51000], "temperature": 0.0, "avg_logprob": -0.08031016166764077, "compression_ratio": 1.704035874439462, "no_speech_prob": 0.0008040638640522957}, {"id": 150, "seek": 85080, "start": 863.52, "end": 870.3199999999999, "text": " squared and negative x1 squared. At the bottom level of the recursion we'll have a single point", "tokens": [51000, 8889, 293, 3671, 2031, 16, 8889, 13, 1711, 264, 2767, 1496, 295, 264, 20560, 313, 321, 603, 362, 257, 2167, 935, 51340], "temperature": 0.0, "avg_logprob": -0.08031016166764077, "compression_ratio": 1.704035874439462, "no_speech_prob": 0.0008040638640522957}, {"id": 151, "seek": 85080, "start": 870.3199999999999, "end": 877.12, "text": " x1 to the power of 4. Now what's nice is that we get to choose these points. Let's see what happens", "tokens": [51340, 2031, 16, 281, 264, 1347, 295, 1017, 13, 823, 437, 311, 1481, 307, 300, 321, 483, 281, 2826, 613, 2793, 13, 961, 311, 536, 437, 2314, 51680], "temperature": 0.0, "avg_logprob": -0.08031016166764077, "compression_ratio": 1.704035874439462, "no_speech_prob": 0.0008040638640522957}, {"id": 152, "seek": 87712, "start": 877.12, "end": 884.48, "text": " if we pick our initial x1 to be 1. This means two of our initial points are 1 and negative 1", "tokens": [50364, 498, 321, 1888, 527, 5883, 2031, 16, 281, 312, 502, 13, 639, 1355, 732, 295, 527, 5883, 2793, 366, 502, 293, 3671, 502, 50732], "temperature": 0.0, "avg_logprob": -0.04778203672292281, "compression_ratio": 1.7488584474885844, "no_speech_prob": 0.00047284550964832306}, {"id": 153, "seek": 87712, "start": 884.48, "end": 890.16, "text": " which at the next level of recursion means that x1 squared and negative x1 squared also have to be", "tokens": [50732, 597, 412, 264, 958, 1496, 295, 20560, 313, 1355, 300, 2031, 16, 8889, 293, 3671, 2031, 16, 8889, 611, 362, 281, 312, 51016], "temperature": 0.0, "avg_logprob": -0.04778203672292281, "compression_ratio": 1.7488584474885844, "no_speech_prob": 0.00047284550964832306}, {"id": 154, "seek": 87712, "start": 890.16, "end": 896.8, "text": " 1 and negative 1 respectively. And at the bottom layer we have only one point which ends up being", "tokens": [51016, 502, 293, 3671, 502, 25009, 13, 400, 412, 264, 2767, 4583, 321, 362, 787, 472, 935, 597, 5314, 493, 885, 51348], "temperature": 0.0, "avg_logprob": -0.04778203672292281, "compression_ratio": 1.7488584474885844, "no_speech_prob": 0.00047284550964832306}, {"id": 155, "seek": 87712, "start": 896.8, "end": 904.24, "text": " 1. Now the question becomes what x2 should we choose so that when we square x2 we end up with", "tokens": [51348, 502, 13, 823, 264, 1168, 3643, 437, 2031, 17, 820, 321, 2826, 370, 300, 562, 321, 3732, 2031, 17, 321, 917, 493, 365, 51720], "temperature": 0.0, "avg_logprob": -0.04778203672292281, "compression_ratio": 1.7488584474885844, "no_speech_prob": 0.00047284550964832306}, {"id": 156, "seek": 90424, "start": 904.24, "end": 909.52, "text": " negative 1. The answer to that is the complex number i which means that the four points that", "tokens": [50364, 3671, 502, 13, 440, 1867, 281, 300, 307, 264, 3997, 1230, 741, 597, 1355, 300, 264, 1451, 2793, 300, 50628], "temperature": 0.0, "avg_logprob": -0.09427218003706499, "compression_ratio": 1.6575342465753424, "no_speech_prob": 0.00017400344950146973}, {"id": 157, "seek": 90424, "start": 909.52, "end": 915.04, "text": " we need to evaluate this polynomial at are 1, negative 1, i and negative i.", "tokens": [50628, 321, 643, 281, 13059, 341, 26110, 412, 366, 502, 11, 3671, 502, 11, 741, 293, 3671, 741, 13, 50904], "temperature": 0.0, "avg_logprob": -0.09427218003706499, "compression_ratio": 1.6575342465753424, "no_speech_prob": 0.00017400344950146973}, {"id": 158, "seek": 90424, "start": 917.28, "end": 922.48, "text": " An alternate perspective to what we just did here is that we essentially just solved the equation", "tokens": [51016, 1107, 18873, 4585, 281, 437, 321, 445, 630, 510, 307, 300, 321, 4476, 445, 13041, 264, 5367, 51276], "temperature": 0.0, "avg_logprob": -0.09427218003706499, "compression_ratio": 1.6575342465753424, "no_speech_prob": 0.00017400344950146973}, {"id": 159, "seek": 90424, "start": 922.48, "end": 927.92, "text": " x to the power of 4 equals 1. Since at the bottom layer of the recursion the value of any of our", "tokens": [51276, 2031, 281, 264, 1347, 295, 1017, 6915, 502, 13, 4162, 412, 264, 2767, 4583, 295, 264, 20560, 313, 264, 2158, 295, 604, 295, 527, 51548], "temperature": 0.0, "avg_logprob": -0.09427218003706499, "compression_ratio": 1.6575342465753424, "no_speech_prob": 0.00017400344950146973}, {"id": 160, "seek": 92792, "start": 927.92, "end": 935.36, "text": " original points to the power of 4 was 1. We know this equation has four solutions all of which", "tokens": [50364, 3380, 2793, 281, 264, 1347, 295, 1017, 390, 502, 13, 492, 458, 341, 5367, 575, 1451, 6547, 439, 295, 597, 50736], "temperature": 0.0, "avg_logprob": -0.06777610778808593, "compression_ratio": 1.5537190082644627, "no_speech_prob": 0.0007553972536697984}, {"id": 161, "seek": 92792, "start": 935.36, "end": 942.0, "text": " are encompassed by a special set of points called the fourth roots of unity. Let's see if this", "tokens": [50736, 366, 28268, 292, 538, 257, 2121, 992, 295, 2793, 1219, 264, 6409, 10669, 295, 18205, 13, 961, 311, 536, 498, 341, 51068], "temperature": 0.0, "avg_logprob": -0.06777610778808593, "compression_ratio": 1.5537190082644627, "no_speech_prob": 0.0007553972536697984}, {"id": 162, "seek": 92792, "start": 942.0, "end": 949.12, "text": " generalizes. If given a degree 5 polynomial we'll need n is greater than or equal to six points.", "tokens": [51068, 2674, 5660, 13, 759, 2212, 257, 4314, 1025, 26110, 321, 603, 643, 297, 307, 5044, 813, 420, 2681, 281, 2309, 2793, 13, 51424], "temperature": 0.0, "avg_logprob": -0.06777610778808593, "compression_ratio": 1.5537190082644627, "no_speech_prob": 0.0007553972536697984}, {"id": 163, "seek": 92792, "start": 949.12, "end": 954.0, "text": " Since our recursive method is splitting each problem in half it's convenient to just pick", "tokens": [51424, 4162, 527, 20560, 488, 3170, 307, 30348, 1184, 1154, 294, 1922, 309, 311, 10851, 281, 445, 1888, 51668], "temperature": 0.0, "avg_logprob": -0.06777610778808593, "compression_ratio": 1.5537190082644627, "no_speech_prob": 0.0007553972536697984}, {"id": 164, "seek": 95400, "start": 954.0, "end": 959.44, "text": " a power of 2 so let's pick n equals 8. Now what we need to do is to find eight points that are", "tokens": [50364, 257, 1347, 295, 568, 370, 718, 311, 1888, 297, 6915, 1649, 13, 823, 437, 321, 643, 281, 360, 307, 281, 915, 3180, 2793, 300, 366, 50636], "temperature": 0.0, "avg_logprob": -0.06614267211599448, "compression_ratio": 1.7671232876712328, "no_speech_prob": 0.0024725506082177162}, {"id": 165, "seek": 95400, "start": 959.44, "end": 965.36, "text": " positive negative paired such that each of these points when raised to the eighth power is equal", "tokens": [50636, 3353, 3671, 25699, 1270, 300, 1184, 295, 613, 2793, 562, 6005, 281, 264, 19495, 1347, 307, 2681, 50932], "temperature": 0.0, "avg_logprob": -0.06614267211599448, "compression_ratio": 1.7671232876712328, "no_speech_prob": 0.0024725506082177162}, {"id": 166, "seek": 95400, "start": 965.36, "end": 972.48, "text": " to 1. We see that the right points are the eighth roots of unity. Generalizing this to any d degree", "tokens": [50932, 281, 502, 13, 492, 536, 300, 264, 558, 2793, 366, 264, 19495, 10669, 295, 18205, 13, 6996, 3319, 341, 281, 604, 274, 4314, 51288], "temperature": 0.0, "avg_logprob": -0.06614267211599448, "compression_ratio": 1.7671232876712328, "no_speech_prob": 0.0024725506082177162}, {"id": 167, "seek": 95400, "start": 972.48, "end": 978.48, "text": " polynomial what we will do is pick n is greater than or equal to d plus 1 points such that n is", "tokens": [51288, 26110, 437, 321, 486, 360, 307, 1888, 297, 307, 5044, 813, 420, 2681, 281, 274, 1804, 502, 2793, 1270, 300, 297, 307, 51588], "temperature": 0.0, "avg_logprob": -0.06614267211599448, "compression_ratio": 1.7671232876712328, "no_speech_prob": 0.0024725506082177162}, {"id": 168, "seek": 97848, "start": 978.48, "end": 984.5600000000001, "text": " the power of 2 and the points that we should choose are the nth roots of unity. This fact", "tokens": [50364, 264, 1347, 295, 568, 293, 264, 2793, 300, 321, 820, 2826, 366, 264, 297, 392, 10669, 295, 18205, 13, 639, 1186, 50668], "temperature": 0.0, "avg_logprob": -0.054075808138460725, "compression_ratio": 1.7739463601532568, "no_speech_prob": 0.0018101854948326945}, {"id": 169, "seek": 97848, "start": 984.5600000000001, "end": 990.32, "text": " deserves a little bit more explanation. Why does this work? Before we answer that question let's", "tokens": [50668, 17037, 257, 707, 857, 544, 10835, 13, 1545, 775, 341, 589, 30, 4546, 321, 1867, 300, 1168, 718, 311, 50956], "temperature": 0.0, "avg_logprob": -0.054075808138460725, "compression_ratio": 1.7739463601532568, "no_speech_prob": 0.0018101854948326945}, {"id": 170, "seek": 97848, "start": 990.32, "end": 995.44, "text": " formalize a few things. The nth roots of unity are the solution to the following equation", "tokens": [50956, 9860, 1125, 257, 1326, 721, 13, 440, 297, 392, 10669, 295, 18205, 366, 264, 3827, 281, 264, 3480, 5367, 51212], "temperature": 0.0, "avg_logprob": -0.054075808138460725, "compression_ratio": 1.7739463601532568, "no_speech_prob": 0.0018101854948326945}, {"id": 171, "seek": 97848, "start": 995.44, "end": 1000.32, "text": " and they are best visualized as equally spaced points on the unit circle. The angle between", "tokens": [51212, 293, 436, 366, 1151, 5056, 1602, 382, 12309, 43766, 2793, 322, 264, 4985, 6329, 13, 440, 5802, 1296, 51456], "temperature": 0.0, "avg_logprob": -0.054075808138460725, "compression_ratio": 1.7739463601532568, "no_speech_prob": 0.0018101854948326945}, {"id": 172, "seek": 97848, "start": 1000.32, "end": 1007.2, "text": " these points is 2 pi over n. With this fact a nice way to compactly write these points is with", "tokens": [51456, 613, 2793, 307, 568, 3895, 670, 297, 13, 2022, 341, 1186, 257, 1481, 636, 281, 14679, 356, 2464, 613, 2793, 307, 365, 51800], "temperature": 0.0, "avg_logprob": -0.054075808138460725, "compression_ratio": 1.7739463601532568, "no_speech_prob": 0.0018101854948326945}, {"id": 173, "seek": 100720, "start": 1007.2, "end": 1012.96, "text": " complex exponential notation through Euler's formula. One standard way to define the roots of", "tokens": [50364, 3997, 21510, 24657, 807, 462, 26318, 311, 8513, 13, 1485, 3832, 636, 281, 6964, 264, 10669, 295, 50652], "temperature": 0.0, "avg_logprob": -0.05262893570793999, "compression_ratio": 1.6293103448275863, "no_speech_prob": 0.00032503088004887104}, {"id": 174, "seek": 100720, "start": 1012.96, "end": 1019.76, "text": " unity is by defining this omega term as e to the power of 2 pi i over n and then what this allows", "tokens": [50652, 18205, 307, 538, 17827, 341, 10498, 1433, 382, 308, 281, 264, 1347, 295, 568, 3895, 741, 670, 297, 293, 550, 437, 341, 4045, 50992], "temperature": 0.0, "avg_logprob": -0.05262893570793999, "compression_ratio": 1.6293103448275863, "no_speech_prob": 0.00032503088004887104}, {"id": 175, "seek": 100720, "start": 1019.76, "end": 1025.3600000000001, "text": " us to do is define individual roots of unity quite compactly. Here are some examples.", "tokens": [50992, 505, 281, 360, 307, 6964, 2609, 10669, 295, 18205, 1596, 14679, 356, 13, 1692, 366, 512, 5110, 13, 51272], "temperature": 0.0, "avg_logprob": -0.05262893570793999, "compression_ratio": 1.6293103448275863, "no_speech_prob": 0.00032503088004887104}, {"id": 176, "seek": 100720, "start": 1028.24, "end": 1033.92, "text": " So now when we say we want to evaluate a polynomial at the nth roots of unity what that really means", "tokens": [51416, 407, 586, 562, 321, 584, 321, 528, 281, 13059, 257, 26110, 412, 264, 297, 392, 10669, 295, 18205, 437, 300, 534, 1355, 51700], "temperature": 0.0, "avg_logprob": -0.05262893570793999, "compression_ratio": 1.6293103448275863, "no_speech_prob": 0.00032503088004887104}, {"id": 177, "seek": 103392, "start": 1033.92, "end": 1039.52, "text": " is we want to evaluate it at omega to the power of 0, omega to the power of 1, so on and so forth", "tokens": [50364, 307, 321, 528, 281, 13059, 309, 412, 10498, 281, 264, 1347, 295, 1958, 11, 10498, 281, 264, 1347, 295, 502, 11, 370, 322, 293, 370, 5220, 50644], "temperature": 0.0, "avg_logprob": -0.07561427668521278, "compression_ratio": 1.7625570776255708, "no_speech_prob": 0.00017400251817889512}, {"id": 178, "seek": 103392, "start": 1039.52, "end": 1047.68, "text": " until omega to the power of n minus 1. So going back to our original question of why evaluating", "tokens": [50644, 1826, 10498, 281, 264, 1347, 295, 297, 3175, 502, 13, 407, 516, 646, 281, 527, 3380, 1168, 295, 983, 27479, 51052], "temperature": 0.0, "avg_logprob": -0.07561427668521278, "compression_ratio": 1.7625570776255708, "no_speech_prob": 0.00017400251817889512}, {"id": 179, "seek": 103392, "start": 1047.68, "end": 1053.52, "text": " the polynomial p of x at the nth roots of unity works for a recursive algorithm there are two", "tokens": [51052, 264, 26110, 280, 295, 2031, 412, 264, 297, 392, 10669, 295, 18205, 1985, 337, 257, 20560, 488, 9284, 456, 366, 732, 51344], "temperature": 0.0, "avg_logprob": -0.07561427668521278, "compression_ratio": 1.7625570776255708, "no_speech_prob": 0.00017400251817889512}, {"id": 180, "seek": 103392, "start": 1053.52, "end": 1059.3600000000001, "text": " key properties at play here. For one our original set of points are positive negative paired where", "tokens": [51344, 2141, 7221, 412, 862, 510, 13, 1171, 472, 527, 3380, 992, 295, 2793, 366, 3353, 3671, 25699, 689, 51636], "temperature": 0.0, "avg_logprob": -0.07561427668521278, "compression_ratio": 1.7625570776255708, "no_speech_prob": 0.00017400251817889512}, {"id": 181, "seek": 105936, "start": 1059.36, "end": 1065.52, "text": " for the jth root omega to the power of j omega to the power of j plus n over 2 is going to be the", "tokens": [50364, 337, 264, 361, 392, 5593, 10498, 281, 264, 1347, 295, 361, 10498, 281, 264, 1347, 295, 361, 1804, 297, 670, 568, 307, 516, 281, 312, 264, 50672], "temperature": 0.0, "avg_logprob": -0.04434947293214123, "compression_ratio": 1.8064516129032258, "no_speech_prob": 0.0012448173947632313}, {"id": 182, "seek": 105936, "start": 1065.52, "end": 1071.9199999999998, "text": " corresponding pair. Now in our recursive step we will be squaring each of these points and passing", "tokens": [50672, 11760, 6119, 13, 823, 294, 527, 20560, 488, 1823, 321, 486, 312, 2339, 1921, 1184, 295, 613, 2793, 293, 8437, 50992], "temperature": 0.0, "avg_logprob": -0.04434947293214123, "compression_ratio": 1.8064516129032258, "no_speech_prob": 0.0012448173947632313}, {"id": 183, "seek": 105936, "start": 1071.9199999999998, "end": 1077.9199999999998, "text": " them on to the even and odd degree polynomials. This is what happens when we square our original", "tokens": [50992, 552, 322, 281, 264, 754, 293, 7401, 4314, 22560, 12356, 13, 639, 307, 437, 2314, 562, 321, 3732, 527, 3380, 51292], "temperature": 0.0, "avg_logprob": -0.04434947293214123, "compression_ratio": 1.8064516129032258, "no_speech_prob": 0.0012448173947632313}, {"id": 184, "seek": 105936, "start": 1077.9199999999998, "end": 1084.8, "text": " nth roots of unity. This reveals the second key property of the nth roots of unity. When we square", "tokens": [51292, 297, 392, 10669, 295, 18205, 13, 639, 20893, 264, 1150, 2141, 4707, 295, 264, 297, 392, 10669, 295, 18205, 13, 1133, 321, 3732, 51636], "temperature": 0.0, "avg_logprob": -0.04434947293214123, "compression_ratio": 1.8064516129032258, "no_speech_prob": 0.0012448173947632313}, {"id": 185, "seek": 108480, "start": 1084.8, "end": 1090.72, "text": " the nth roots of unity we end up with the n over 2 roots of unity which are also positive negative", "tokens": [50364, 264, 297, 392, 10669, 295, 18205, 321, 917, 493, 365, 264, 297, 670, 568, 10669, 295, 18205, 597, 366, 611, 3353, 3671, 50660], "temperature": 0.0, "avg_logprob": -0.08211518337852076, "compression_ratio": 1.6554621848739495, "no_speech_prob": 0.000127309889649041}, {"id": 186, "seek": 108480, "start": 1090.72, "end": 1096.08, "text": " paired and are just the right number of points for the two new polynomials of half the degree.", "tokens": [50660, 25699, 293, 366, 445, 264, 558, 1230, 295, 2793, 337, 264, 732, 777, 22560, 12356, 295, 1922, 264, 4314, 13, 50928], "temperature": 0.0, "avg_logprob": -0.08211518337852076, "compression_ratio": 1.6554621848739495, "no_speech_prob": 0.000127309889649041}, {"id": 187, "seek": 108480, "start": 1096.08, "end": 1101.44, "text": " This same pattern holds at every level of the recursion until we end up with just one point.", "tokens": [50928, 639, 912, 5102, 9190, 412, 633, 1496, 295, 264, 20560, 313, 1826, 321, 917, 493, 365, 445, 472, 935, 13, 51196], "temperature": 0.0, "avg_logprob": -0.08211518337852076, "compression_ratio": 1.6554621848739495, "no_speech_prob": 0.000127309889649041}, {"id": 188, "seek": 108480, "start": 1101.44, "end": 1102.56, "text": " How beautiful is that?", "tokens": [51196, 1012, 2238, 307, 300, 30, 51252], "temperature": 0.0, "avg_logprob": -0.08211518337852076, "compression_ratio": 1.6554621848739495, "no_speech_prob": 0.000127309889649041}, {"id": 189, "seek": 108480, "start": 1108.48, "end": 1113.6, "text": " All right we are now ready to outline the core fast Fourier transform algorithm. The", "tokens": [51548, 1057, 558, 321, 366, 586, 1919, 281, 16387, 264, 4965, 2370, 36810, 4088, 9284, 13, 440, 51804], "temperature": 0.0, "avg_logprob": -0.08211518337852076, "compression_ratio": 1.6554621848739495, "no_speech_prob": 0.000127309889649041}, {"id": 190, "seek": 111360, "start": 1113.6, "end": 1119.4399999999998, "text": " FFT will take in a coefficient representation of a degree n minus one polynomial where n is the power", "tokens": [50364, 479, 25469, 486, 747, 294, 257, 17619, 10290, 295, 257, 4314, 297, 3175, 472, 26110, 689, 297, 307, 264, 1347, 50656], "temperature": 0.0, "avg_logprob": -0.05661972045898438, "compression_ratio": 1.705128205128205, "no_speech_prob": 3.7635862099705264e-05}, {"id": 191, "seek": 111360, "start": 1119.4399999999998, "end": 1126.8, "text": " of two. We will define omega as e to the power of two pi i over n to allow us to define roots of", "tokens": [50656, 295, 732, 13, 492, 486, 6964, 10498, 382, 308, 281, 264, 1347, 295, 732, 3895, 741, 670, 297, 281, 2089, 505, 281, 6964, 10669, 295, 51024], "temperature": 0.0, "avg_logprob": -0.05661972045898438, "compression_ratio": 1.705128205128205, "no_speech_prob": 3.7635862099705264e-05}, {"id": 192, "seek": 111360, "start": 1126.8, "end": 1132.6399999999999, "text": " unity easily. The first case we need to handle is the base case which is going to be when n is equal", "tokens": [51024, 18205, 3612, 13, 440, 700, 1389, 321, 643, 281, 4813, 307, 264, 3096, 1389, 597, 307, 516, 281, 312, 562, 297, 307, 2681, 51316], "temperature": 0.0, "avg_logprob": -0.05661972045898438, "compression_ratio": 1.705128205128205, "no_speech_prob": 3.7635862099705264e-05}, {"id": 193, "seek": 111360, "start": 1132.6399999999999, "end": 1139.04, "text": " to one. All this means is that we are evaluating the polynomial at one point. Our recursive case is", "tokens": [51316, 281, 472, 13, 1057, 341, 1355, 307, 300, 321, 366, 27479, 264, 26110, 412, 472, 935, 13, 2621, 20560, 488, 1389, 307, 51636], "temperature": 0.0, "avg_logprob": -0.05661972045898438, "compression_ratio": 1.705128205128205, "no_speech_prob": 3.7635862099705264e-05}, {"id": 194, "seek": 113904, "start": 1139.04, "end": 1145.76, "text": " two calls to the FFT. One on even degree terms and one on odd degree terms. The intention is that", "tokens": [50364, 732, 5498, 281, 264, 479, 25469, 13, 1485, 322, 754, 4314, 2115, 293, 472, 322, 7401, 4314, 2115, 13, 440, 7789, 307, 300, 50700], "temperature": 0.0, "avg_logprob": -0.05088752110799154, "compression_ratio": 1.768888888888889, "no_speech_prob": 0.0004878522886428982}, {"id": 195, "seek": 113904, "start": 1145.76, "end": 1151.12, "text": " these polynomials are now half the degree of our original polynomial so they only need to be evaluated", "tokens": [50700, 613, 22560, 12356, 366, 586, 1922, 264, 4314, 295, 527, 3380, 26110, 370, 436, 787, 643, 281, 312, 25509, 50968], "temperature": 0.0, "avg_logprob": -0.05088752110799154, "compression_ratio": 1.768888888888889, "no_speech_prob": 0.0004878522886428982}, {"id": 196, "seek": 113904, "start": 1151.12, "end": 1156.8, "text": " at n over two roots of unity. Assuming the recursion works the output of these calls will be the", "tokens": [50968, 412, 297, 670, 732, 10669, 295, 18205, 13, 6281, 24919, 264, 20560, 313, 1985, 264, 5598, 295, 613, 5498, 486, 312, 264, 51252], "temperature": 0.0, "avg_logprob": -0.05088752110799154, "compression_ratio": 1.768888888888889, "no_speech_prob": 0.0004878522886428982}, {"id": 197, "seek": 113904, "start": 1156.8, "end": 1162.3999999999999, "text": " corresponding value representation of these even and odd degree term polynomials which we will label", "tokens": [51252, 11760, 2158, 10290, 295, 613, 754, 293, 7401, 4314, 1433, 22560, 12356, 597, 321, 486, 7645, 51532], "temperature": 0.0, "avg_logprob": -0.05088752110799154, "compression_ratio": 1.768888888888889, "no_speech_prob": 0.0004878522886428982}, {"id": 198, "seek": 116240, "start": 1162.4, "end": 1169.76, "text": " as y e and y o. Now on to the tricky part which is to take the output from these recursive calls", "tokens": [50364, 382, 288, 308, 293, 288, 277, 13, 823, 322, 281, 264, 12414, 644, 597, 307, 281, 747, 264, 5598, 490, 613, 20560, 488, 5498, 50732], "temperature": 0.0, "avg_logprob": -0.06304831396449696, "compression_ratio": 1.5916666666666666, "no_speech_prob": 0.0008040741086006165}, {"id": 199, "seek": 116240, "start": 1169.76, "end": 1176.0, "text": " and combine them to get the value representation of our original degree n minus one polynomial.", "tokens": [50732, 293, 10432, 552, 281, 483, 264, 2158, 10290, 295, 527, 3380, 4314, 297, 3175, 472, 26110, 13, 51044], "temperature": 0.0, "avg_logprob": -0.06304831396449696, "compression_ratio": 1.5916666666666666, "no_speech_prob": 0.0008040741086006165}, {"id": 200, "seek": 116240, "start": 1176.64, "end": 1181.76, "text": " We saw earlier that the key idea was to use the relationship between positive and negative pairs", "tokens": [51076, 492, 1866, 3071, 300, 264, 2141, 1558, 390, 281, 764, 264, 2480, 1296, 3353, 293, 3671, 15494, 51332], "temperature": 0.0, "avg_logprob": -0.06304831396449696, "compression_ratio": 1.5916666666666666, "no_speech_prob": 0.0008040741086006165}, {"id": 201, "seek": 116240, "start": 1181.76, "end": 1187.76, "text": " but now we have to slightly modify this logic for our roots of unity inputs. As a quick note", "tokens": [51332, 457, 586, 321, 362, 281, 4748, 16927, 341, 9952, 337, 527, 10669, 295, 18205, 15743, 13, 1018, 257, 1702, 3637, 51632], "temperature": 0.0, "avg_logprob": -0.06304831396449696, "compression_ratio": 1.5916666666666666, "no_speech_prob": 0.0008040741086006165}, {"id": 202, "seek": 118776, "start": 1187.76, "end": 1192.8, "text": " yes I did modify the indexing to zero indexing because we're getting ready to write some code.", "tokens": [50364, 2086, 286, 630, 16927, 264, 8186, 278, 281, 4018, 8186, 278, 570, 321, 434, 1242, 1919, 281, 2464, 512, 3089, 13, 50616], "temperature": 0.0, "avg_logprob": -0.056407205520137664, "compression_ratio": 1.7276785714285714, "no_speech_prob": 6.014114114805125e-05}, {"id": 203, "seek": 118776, "start": 1192.8, "end": 1198.08, "text": " We know the jth input point will correspond to jth root of unity which results in the following", "tokens": [50616, 492, 458, 264, 361, 392, 4846, 935, 486, 6805, 281, 361, 392, 5593, 295, 18205, 597, 3542, 294, 264, 3480, 50880], "temperature": 0.0, "avg_logprob": -0.056407205520137664, "compression_ratio": 1.7276785714285714, "no_speech_prob": 6.014114114805125e-05}, {"id": 204, "seek": 118776, "start": 1198.08, "end": 1205.6, "text": " relationship. We also saw earlier that the paired point negative omega to the power of j is equal", "tokens": [50880, 2480, 13, 492, 611, 1866, 3071, 300, 264, 25699, 935, 3671, 10498, 281, 264, 1347, 295, 361, 307, 2681, 51256], "temperature": 0.0, "avg_logprob": -0.056407205520137664, "compression_ratio": 1.7276785714285714, "no_speech_prob": 6.014114114805125e-05}, {"id": 205, "seek": 118776, "start": 1205.6, "end": 1211.68, "text": " to omega to the power of j plus n over two due to the properties of the roots of unity. Using this", "tokens": [51256, 281, 10498, 281, 264, 1347, 295, 361, 1804, 297, 670, 732, 3462, 281, 264, 7221, 295, 264, 10669, 295, 18205, 13, 11142, 341, 51560], "temperature": 0.0, "avg_logprob": -0.056407205520137664, "compression_ratio": 1.7276785714285714, "no_speech_prob": 6.014114114805125e-05}, {"id": 206, "seek": 121168, "start": 1211.68, "end": 1218.3200000000002, "text": " fact we can modify the second equation as follows. And lastly one more fact that's nice is that the", "tokens": [50364, 1186, 321, 393, 16927, 264, 1150, 5367, 382, 10002, 13, 400, 16386, 472, 544, 1186, 300, 311, 1481, 307, 300, 264, 50696], "temperature": 0.0, "avg_logprob": -0.04388209751674107, "compression_ratio": 1.6309012875536482, "no_speech_prob": 0.0012842874275520444}, {"id": 207, "seek": 121168, "start": 1218.3200000000002, "end": 1226.5600000000002, "text": " jth index in our y e and y o list correspond to the even and odd polynomials evaluated at omega", "tokens": [50696, 361, 392, 8186, 294, 527, 288, 308, 293, 288, 277, 1329, 6805, 281, 264, 754, 293, 7401, 22560, 12356, 25509, 412, 10498, 51108], "temperature": 0.0, "avg_logprob": -0.04388209751674107, "compression_ratio": 1.6309012875536482, "no_speech_prob": 0.0012842874275520444}, {"id": 208, "seek": 121168, "start": 1226.5600000000002, "end": 1232.5600000000002, "text": " to the power of two times j. What this allows us to do is rewrite our equations as follows", "tokens": [51108, 281, 264, 1347, 295, 732, 1413, 361, 13, 708, 341, 4045, 505, 281, 360, 307, 28132, 527, 11787, 382, 10002, 51408], "temperature": 0.0, "avg_logprob": -0.04388209751674107, "compression_ratio": 1.6309012875536482, "no_speech_prob": 0.0012842874275520444}, {"id": 209, "seek": 121168, "start": 1232.5600000000002, "end": 1238.24, "text": " which makes it much easier to implement code. As mentioned this part is tricky so I encourage", "tokens": [51408, 597, 1669, 309, 709, 3571, 281, 4445, 3089, 13, 1018, 2835, 341, 644, 307, 12414, 370, 286, 5373, 51692], "temperature": 0.0, "avg_logprob": -0.04388209751674107, "compression_ratio": 1.6309012875536482, "no_speech_prob": 0.0012842874275520444}, {"id": 210, "seek": 123824, "start": 1238.24, "end": 1244.8, "text": " you to take your time and verify that each of these steps is indeed true. The final step in the", "tokens": [50364, 291, 281, 747, 428, 565, 293, 16888, 300, 1184, 295, 613, 4439, 307, 6451, 2074, 13, 440, 2572, 1823, 294, 264, 50692], "temperature": 0.0, "avg_logprob": -0.0630940427171423, "compression_ratio": 1.625, "no_speech_prob": 0.0011335252784192562}, {"id": 211, "seek": 123824, "start": 1244.8, "end": 1251.36, "text": " FFT algorithm is to then return the values of a polynomial p evaluated at the nth roots of unity.", "tokens": [50692, 479, 25469, 9284, 307, 281, 550, 2736, 264, 4190, 295, 257, 26110, 280, 25509, 412, 264, 297, 392, 10669, 295, 18205, 13, 51020], "temperature": 0.0, "avg_logprob": -0.0630940427171423, "compression_ratio": 1.625, "no_speech_prob": 0.0011335252784192562}, {"id": 212, "seek": 123824, "start": 1252.0, "end": 1258.4, "text": " Let's now translate this outlined logic into code. Our function FFT will take an input p which is", "tokens": [51052, 961, 311, 586, 13799, 341, 27412, 9952, 666, 3089, 13, 2621, 2445, 479, 25469, 486, 747, 364, 4846, 280, 597, 307, 51372], "temperature": 0.0, "avg_logprob": -0.0630940427171423, "compression_ratio": 1.625, "no_speech_prob": 0.0011335252784192562}, {"id": 213, "seek": 123824, "start": 1258.4, "end": 1265.68, "text": " the coefficient representation of a polynomial p. We first define n as the length of p and we will", "tokens": [51372, 264, 17619, 10290, 295, 257, 26110, 280, 13, 492, 700, 6964, 297, 382, 264, 4641, 295, 280, 293, 321, 486, 51736], "temperature": 0.0, "avg_logprob": -0.0630940427171423, "compression_ratio": 1.625, "no_speech_prob": 0.0011335252784192562}, {"id": 214, "seek": 126568, "start": 1265.68, "end": 1272.24, "text": " assume that n is a power of two. Just to be clear there are implementations of the FFT that can handle", "tokens": [50364, 6552, 300, 297, 307, 257, 1347, 295, 732, 13, 1449, 281, 312, 1850, 456, 366, 4445, 763, 295, 264, 479, 25469, 300, 393, 4813, 50692], "temperature": 0.0, "avg_logprob": -0.04156553617087744, "compression_ratio": 1.6866952789699572, "no_speech_prob": 0.0003569673281162977}, {"id": 215, "seek": 126568, "start": 1272.24, "end": 1278.8, "text": " n not being a power of two but those are way more complicated. The power of two cases encompass the", "tokens": [50692, 297, 406, 885, 257, 1347, 295, 732, 457, 729, 366, 636, 544, 6179, 13, 440, 1347, 295, 732, 3331, 28268, 264, 51020], "temperature": 0.0, "avg_logprob": -0.04156553617087744, "compression_ratio": 1.6866952789699572, "no_speech_prob": 0.0003569673281162977}, {"id": 216, "seek": 126568, "start": 1278.8, "end": 1284.8, "text": " core ideas of the algorithm. We now handle the base case which is just a matter of returning our", "tokens": [51020, 4965, 3487, 295, 264, 9284, 13, 492, 586, 4813, 264, 3096, 1389, 597, 307, 445, 257, 1871, 295, 12678, 527, 51320], "temperature": 0.0, "avg_logprob": -0.04156553617087744, "compression_ratio": 1.6866952789699572, "no_speech_prob": 0.0003569673281162977}, {"id": 217, "seek": 126568, "start": 1284.8, "end": 1291.3600000000001, "text": " original p. This makes sense since we only have one element making p a degree zero polynomial", "tokens": [51320, 3380, 280, 13, 639, 1669, 2020, 1670, 321, 787, 362, 472, 4478, 1455, 280, 257, 4314, 4018, 26110, 51648], "temperature": 0.0, "avg_logprob": -0.04156553617087744, "compression_ratio": 1.6866952789699572, "no_speech_prob": 0.0003569673281162977}, {"id": 218, "seek": 129136, "start": 1291.36, "end": 1297.4399999999998, "text": " or constant. Otherwise we define omega as we have outlined and then proceed with the recursive step.", "tokens": [50364, 420, 5754, 13, 10328, 321, 6964, 10498, 382, 321, 362, 27412, 293, 550, 8991, 365, 264, 20560, 488, 1823, 13, 50668], "temperature": 0.0, "avg_logprob": -0.05368441769054958, "compression_ratio": 1.758364312267658, "no_speech_prob": 0.0028894925490021706}, {"id": 219, "seek": 129136, "start": 1297.4399999999998, "end": 1302.24, "text": " The first part of the recursive step requires splitting the polynomial into even and odd", "tokens": [50668, 440, 700, 644, 295, 264, 20560, 488, 1823, 7029, 30348, 264, 26110, 666, 754, 293, 7401, 50908], "temperature": 0.0, "avg_logprob": -0.05368441769054958, "compression_ratio": 1.758364312267658, "no_speech_prob": 0.0028894925490021706}, {"id": 220, "seek": 129136, "start": 1302.24, "end": 1307.6, "text": " degree terms which is quite easy to do. Then we recursively call our FFT function on these", "tokens": [50908, 4314, 2115, 597, 307, 1596, 1858, 281, 360, 13, 1396, 321, 20560, 3413, 818, 527, 479, 25469, 2445, 322, 613, 51176], "temperature": 0.0, "avg_logprob": -0.05368441769054958, "compression_ratio": 1.758364312267658, "no_speech_prob": 0.0028894925490021706}, {"id": 221, "seek": 129136, "start": 1307.6, "end": 1312.8799999999999, "text": " polynomials that now have half the degree of our original polynomial. We denote the outputs as", "tokens": [51176, 22560, 12356, 300, 586, 362, 1922, 264, 4314, 295, 527, 3380, 26110, 13, 492, 45708, 264, 23930, 382, 51440], "temperature": 0.0, "avg_logprob": -0.05368441769054958, "compression_ratio": 1.758364312267658, "no_speech_prob": 0.0028894925490021706}, {"id": 222, "seek": 129136, "start": 1312.8799999999999, "end": 1319.9199999999998, "text": " y e and y o as we have done in the outline. Now it's time to put this all together. We initialize", "tokens": [51440, 288, 308, 293, 288, 277, 382, 321, 362, 1096, 294, 264, 16387, 13, 823, 309, 311, 565, 281, 829, 341, 439, 1214, 13, 492, 5883, 1125, 51792], "temperature": 0.0, "avg_logprob": -0.05368441769054958, "compression_ratio": 1.758364312267658, "no_speech_prob": 0.0028894925490021706}, {"id": 223, "seek": 131992, "start": 1319.92, "end": 1327.44, "text": " our output list which will contain the final value representation. Then for all j up to n over two", "tokens": [50364, 527, 5598, 1329, 597, 486, 5304, 264, 2572, 2158, 10290, 13, 1396, 337, 439, 361, 493, 281, 297, 670, 732, 50740], "temperature": 0.0, "avg_logprob": -0.05519107255068692, "compression_ratio": 1.648068669527897, "no_speech_prob": 0.0007321725133806467}, {"id": 224, "seek": 131992, "start": 1327.44, "end": 1333.44, "text": " we calculate the value representations as we have outlined. After populating all values in our list", "tokens": [50740, 321, 8873, 264, 2158, 33358, 382, 321, 362, 27412, 13, 2381, 1665, 12162, 439, 4190, 294, 527, 1329, 51040], "temperature": 0.0, "avg_logprob": -0.05519107255068692, "compression_ratio": 1.648068669527897, "no_speech_prob": 0.0007321725133806467}, {"id": 225, "seek": 131992, "start": 1333.44, "end": 1339.8400000000001, "text": " we then return that list and that's the FFT. Overall pretty crazy how all the ideas we talked", "tokens": [51040, 321, 550, 2736, 300, 1329, 293, 300, 311, 264, 479, 25469, 13, 18420, 1238, 3219, 577, 439, 264, 3487, 321, 2825, 51360], "temperature": 0.0, "avg_logprob": -0.05519107255068692, "compression_ratio": 1.648068669527897, "no_speech_prob": 0.0007321725133806467}, {"id": 226, "seek": 131992, "start": 1339.8400000000001, "end": 1346.96, "text": " about end up coming together in eleven lines of truly elegant code. Let's now take a larger", "tokens": [51360, 466, 917, 493, 1348, 1214, 294, 21090, 3876, 295, 4908, 21117, 3089, 13, 961, 311, 586, 747, 257, 4833, 51716], "temperature": 0.0, "avg_logprob": -0.05519107255068692, "compression_ratio": 1.648068669527897, "no_speech_prob": 0.0007321725133806467}, {"id": 227, "seek": 134696, "start": 1346.96, "end": 1351.76, "text": " look at our original problem of polynomial multiplication and see where we are. We now", "tokens": [50364, 574, 412, 527, 3380, 1154, 295, 26110, 27290, 293, 536, 689, 321, 366, 13, 492, 586, 50604], "temperature": 0.0, "avg_logprob": -0.05329358193182176, "compression_ratio": 1.8494208494208495, "no_speech_prob": 0.0010649479227140546}, {"id": 228, "seek": 134696, "start": 1351.76, "end": 1358.08, "text": " have a way to convert coefficient representations to value representations efficiently using the FFT.", "tokens": [50604, 362, 257, 636, 281, 7620, 17619, 33358, 281, 2158, 33358, 19621, 1228, 264, 479, 25469, 13, 50920], "temperature": 0.0, "avg_logprob": -0.05329358193182176, "compression_ratio": 1.8494208494208495, "no_speech_prob": 0.0010649479227140546}, {"id": 229, "seek": 134696, "start": 1358.08, "end": 1363.28, "text": " So now the only missing piece is the reverse process of converting from value representations", "tokens": [50920, 407, 586, 264, 787, 5361, 2522, 307, 264, 9943, 1399, 295, 29942, 490, 2158, 33358, 51180], "temperature": 0.0, "avg_logprob": -0.05329358193182176, "compression_ratio": 1.8494208494208495, "no_speech_prob": 0.0010649479227140546}, {"id": 230, "seek": 134696, "start": 1363.28, "end": 1368.88, "text": " to coefficient representations which is formally called interpolation. This is where things get", "tokens": [51180, 281, 17619, 33358, 597, 307, 25983, 1219, 44902, 399, 13, 639, 307, 689, 721, 483, 51460], "temperature": 0.0, "avg_logprob": -0.05329358193182176, "compression_ratio": 1.8494208494208495, "no_speech_prob": 0.0010649479227140546}, {"id": 231, "seek": 134696, "start": 1368.88, "end": 1376.4, "text": " really wild. On the surface the idea of reversing evaluation feels like a significantly harder task.", "tokens": [51460, 534, 4868, 13, 1282, 264, 3753, 264, 1558, 295, 14582, 278, 13344, 3417, 411, 257, 10591, 6081, 5633, 13, 51836], "temperature": 0.0, "avg_logprob": -0.05329358193182176, "compression_ratio": 1.8494208494208495, "no_speech_prob": 0.0010649479227140546}, {"id": 232, "seek": 137640, "start": 1376.4, "end": 1379.76, "text": " Let's take a step back and look at this problem from another perspective.", "tokens": [50364, 961, 311, 747, 257, 1823, 646, 293, 574, 412, 341, 1154, 490, 1071, 4585, 13, 50532], "temperature": 0.0, "avg_logprob": -0.06242885715083072, "compression_ratio": 1.613953488372093, "no_speech_prob": 3.42682033078745e-05}, {"id": 233, "seek": 137640, "start": 1380.4, "end": 1385.92, "text": " Evaluation and interpolation are closely connected and as we saw earlier we can express", "tokens": [50564, 462, 46504, 293, 44902, 399, 366, 8185, 4582, 293, 382, 321, 1866, 3071, 321, 393, 5109, 50840], "temperature": 0.0, "avg_logprob": -0.06242885715083072, "compression_ratio": 1.613953488372093, "no_speech_prob": 3.42682033078745e-05}, {"id": 234, "seek": 137640, "start": 1385.92, "end": 1393.68, "text": " evaluation as a matrix vector product. We have a vector of coefficients multiplied by a matrix", "tokens": [50840, 13344, 382, 257, 8141, 8062, 1674, 13, 492, 362, 257, 8062, 295, 31994, 17207, 538, 257, 8141, 51228], "temperature": 0.0, "avg_logprob": -0.06242885715083072, "compression_ratio": 1.613953488372093, "no_speech_prob": 3.42682033078745e-05}, {"id": 235, "seek": 137640, "start": 1393.68, "end": 1400.3200000000002, "text": " of our evaluation points to give us the value representation. Now in the FFT algorithm the", "tokens": [51228, 295, 527, 13344, 2793, 281, 976, 505, 264, 2158, 10290, 13, 823, 294, 264, 479, 25469, 9284, 264, 51560], "temperature": 0.0, "avg_logprob": -0.06242885715083072, "compression_ratio": 1.613953488372093, "no_speech_prob": 3.42682033078745e-05}, {"id": 236, "seek": 140032, "start": 1400.32, "end": 1406.32, "text": " kth evaluation point was a corresponding root of unity which allows us to rewrite the matrix", "tokens": [50364, 350, 392, 13344, 935, 390, 257, 11760, 5593, 295, 18205, 597, 4045, 505, 281, 28132, 264, 8141, 50664], "temperature": 0.0, "avg_logprob": -0.0738912152081001, "compression_ratio": 1.6527196652719665, "no_speech_prob": 0.00014883748372085392}, {"id": 237, "seek": 140032, "start": 1406.32, "end": 1413.6, "text": " vector product as follows. This particular matrix has a special name the discrete Fourier transform", "tokens": [50664, 8062, 1674, 382, 10002, 13, 639, 1729, 8141, 575, 257, 2121, 1315, 264, 27706, 36810, 4088, 51028], "temperature": 0.0, "avg_logprob": -0.0738912152081001, "compression_ratio": 1.6527196652719665, "no_speech_prob": 0.00014883748372085392}, {"id": 238, "seek": 140032, "start": 1413.6, "end": 1421.52, "text": " or DFT matrix. In most textbooks and references the FFT at its core is an algorithm for calculating", "tokens": [51028, 420, 413, 25469, 8141, 13, 682, 881, 33587, 293, 15400, 264, 479, 25469, 412, 1080, 4965, 307, 364, 9284, 337, 28258, 51424], "temperature": 0.0, "avg_logprob": -0.0738912152081001, "compression_ratio": 1.6527196652719665, "no_speech_prob": 0.00014883748372085392}, {"id": 239, "seek": 140032, "start": 1421.52, "end": 1428.0, "text": " these types of matrix vector products efficiently. Polynomial evaluation at the roots of unity happens", "tokens": [51424, 613, 3467, 295, 8141, 8062, 3383, 19621, 13, 6165, 9896, 47429, 13344, 412, 264, 10669, 295, 18205, 2314, 51748], "temperature": 0.0, "avg_logprob": -0.0738912152081001, "compression_ratio": 1.6527196652719665, "no_speech_prob": 0.00014883748372085392}, {"id": 240, "seek": 142800, "start": 1428.0, "end": 1433.2, "text": " to be one case where this type of matrix vector product shows up so that's why we can use the", "tokens": [50364, 281, 312, 472, 1389, 689, 341, 2010, 295, 8141, 8062, 1674, 3110, 493, 370, 300, 311, 983, 321, 393, 764, 264, 50624], "temperature": 0.0, "avg_logprob": -0.03362303972244263, "compression_ratio": 1.6810344827586208, "no_speech_prob": 0.0009110241080634296}, {"id": 241, "seek": 142800, "start": 1433.2, "end": 1439.84, "text": " FFT. Anyways the nice fact about the FFT and evaluation in this context is that interpolation", "tokens": [50624, 479, 25469, 13, 15585, 264, 1481, 1186, 466, 264, 479, 25469, 293, 13344, 294, 341, 4319, 307, 300, 44902, 399, 50956], "temperature": 0.0, "avg_logprob": -0.03362303972244263, "compression_ratio": 1.6810344827586208, "no_speech_prob": 0.0009110241080634296}, {"id": 242, "seek": 142800, "start": 1439.84, "end": 1447.52, "text": " is much easier to understand. Interpolation requires inversing this DFT matrix. For interpolation we are", "tokens": [50956, 307, 709, 3571, 281, 1223, 13, 5751, 12892, 399, 7029, 21378, 278, 341, 413, 25469, 8141, 13, 1171, 44902, 399, 321, 366, 51340], "temperature": 0.0, "avg_logprob": -0.03362303972244263, "compression_ratio": 1.6810344827586208, "no_speech_prob": 0.0009110241080634296}, {"id": 243, "seek": 142800, "start": 1447.52, "end": 1453.36, "text": " given a value representation of our polynomial and we want to find the coefficient representation", "tokens": [51340, 2212, 257, 2158, 10290, 295, 527, 26110, 293, 321, 528, 281, 915, 264, 17619, 10290, 51632], "temperature": 0.0, "avg_logprob": -0.03362303972244263, "compression_ratio": 1.6810344827586208, "no_speech_prob": 0.0009110241080634296}, {"id": 244, "seek": 145336, "start": 1453.36, "end": 1459.12, "text": " which means we have to multiply the value representation by the inverse of the DFT matrix.", "tokens": [50364, 597, 1355, 321, 362, 281, 12972, 264, 2158, 10290, 538, 264, 17340, 295, 264, 413, 25469, 8141, 13, 50652], "temperature": 0.0, "avg_logprob": -0.06513500715556898, "compression_ratio": 1.6705882352941177, "no_speech_prob": 0.00023781924392096698}, {"id": 245, "seek": 145336, "start": 1460.0, "end": 1464.56, "text": " So let me show you what the inverse of this matrix looks like. I'm purposefully skipping", "tokens": [50696, 407, 718, 385, 855, 291, 437, 264, 17340, 295, 341, 8141, 1542, 411, 13, 286, 478, 4334, 2277, 31533, 50924], "temperature": 0.0, "avg_logprob": -0.06513500715556898, "compression_ratio": 1.6705882352941177, "no_speech_prob": 0.00023781924392096698}, {"id": 246, "seek": 145336, "start": 1464.56, "end": 1469.4399999999998, "text": " a lot of important linear algebra facts here since that would be an entirely different video", "tokens": [50924, 257, 688, 295, 1021, 8213, 21989, 9130, 510, 1670, 300, 576, 312, 364, 7696, 819, 960, 51168], "temperature": 0.0, "avg_logprob": -0.06513500715556898, "compression_ratio": 1.6705882352941177, "no_speech_prob": 0.00023781924392096698}, {"id": 247, "seek": 145336, "start": 1469.4399999999998, "end": 1473.52, "text": " but given that this is the inverse matrix what stands out to you?", "tokens": [51168, 457, 2212, 300, 341, 307, 264, 17340, 8141, 437, 7382, 484, 281, 291, 30, 51372], "temperature": 0.0, "avg_logprob": -0.06513500715556898, "compression_ratio": 1.6705882352941177, "no_speech_prob": 0.00023781924392096698}, {"id": 248, "seek": 145336, "start": 1476.1599999999999, "end": 1481.1999999999998, "text": " It's really quite amazing but this inverse matrix looks almost the same as our original", "tokens": [51504, 467, 311, 534, 1596, 2243, 457, 341, 17340, 8141, 1542, 1920, 264, 912, 382, 527, 3380, 51756], "temperature": 0.0, "avg_logprob": -0.06513500715556898, "compression_ratio": 1.6705882352941177, "no_speech_prob": 0.00023781924392096698}, {"id": 249, "seek": 148120, "start": 1481.2, "end": 1487.8400000000001, "text": " DFT matrix. In fact the only difference is that every single omega in our original DFT matrix", "tokens": [50364, 413, 25469, 8141, 13, 682, 1186, 264, 787, 2649, 307, 300, 633, 2167, 10498, 294, 527, 3380, 413, 25469, 8141, 50696], "temperature": 0.0, "avg_logprob": -0.05099022525480424, "compression_ratio": 1.5822784810126582, "no_speech_prob": 0.0010649210307747126}, {"id": 250, "seek": 148120, "start": 1487.8400000000001, "end": 1494.0, "text": " is now just replaced with omega to the power of negative 1 with a normalization factor of 1 over", "tokens": [50696, 307, 586, 445, 10772, 365, 10498, 281, 264, 1347, 295, 3671, 502, 365, 257, 2710, 2144, 5952, 295, 502, 670, 51004], "temperature": 0.0, "avg_logprob": -0.05099022525480424, "compression_ratio": 1.5822784810126582, "no_speech_prob": 0.0010649210307747126}, {"id": 251, "seek": 148120, "start": 1494.0, "end": 1500.4, "text": " n. This indicates a potential to reuse the FFT logic for interpolation since the matrix structure", "tokens": [51004, 297, 13, 639, 16203, 257, 3995, 281, 26225, 264, 479, 25469, 9952, 337, 44902, 399, 1670, 264, 8141, 3877, 51324], "temperature": 0.0, "avg_logprob": -0.05099022525480424, "compression_ratio": 1.5822784810126582, "no_speech_prob": 0.0010649210307747126}, {"id": 252, "seek": 148120, "start": 1500.4, "end": 1506.4, "text": " is basically the same. Let's formalize this suspicion by doing a direct comparison. In", "tokens": [51324, 307, 1936, 264, 912, 13, 961, 311, 9860, 1125, 341, 32020, 538, 884, 257, 2047, 9660, 13, 682, 51624], "temperature": 0.0, "avg_logprob": -0.05099022525480424, "compression_ratio": 1.5822784810126582, "no_speech_prob": 0.0010649210307747126}, {"id": 253, "seek": 150640, "start": 1506.4, "end": 1512.24, "text": " evaluation which involved the FFT we are given a set of coefficients and evaluate the polynomial", "tokens": [50364, 13344, 597, 3288, 264, 479, 25469, 321, 366, 2212, 257, 992, 295, 31994, 293, 13059, 264, 26110, 50656], "temperature": 0.0, "avg_logprob": -0.0633523812454738, "compression_ratio": 1.6808510638297873, "no_speech_prob": 6.605107773793861e-05}, {"id": 254, "seek": 150640, "start": 1512.24, "end": 1517.68, "text": " at the roots of unity to get a value representation. This involved the following matrix vector product", "tokens": [50656, 412, 264, 10669, 295, 18205, 281, 483, 257, 2158, 10290, 13, 639, 3288, 264, 3480, 8141, 8062, 1674, 50928], "temperature": 0.0, "avg_logprob": -0.0633523812454738, "compression_ratio": 1.6808510638297873, "no_speech_prob": 6.605107773793861e-05}, {"id": 255, "seek": 150640, "start": 1517.68, "end": 1524.3200000000002, "text": " where we define omega as e to the power of 2 pi i divided by n. Looking at interpolation we now", "tokens": [50928, 689, 321, 6964, 10498, 382, 308, 281, 264, 1347, 295, 568, 3895, 741, 6666, 538, 297, 13, 11053, 412, 44902, 399, 321, 586, 51260], "temperature": 0.0, "avg_logprob": -0.0633523812454738, "compression_ratio": 1.6808510638297873, "no_speech_prob": 6.605107773793861e-05}, {"id": 256, "seek": 150640, "start": 1524.3200000000002, "end": 1530.8000000000002, "text": " want to define what is formally called the inverse FFT algorithm. The inverse FFT will take a value", "tokens": [51260, 528, 281, 6964, 437, 307, 25983, 1219, 264, 17340, 479, 25469, 9284, 13, 440, 17340, 479, 25469, 486, 747, 257, 2158, 51584], "temperature": 0.0, "avg_logprob": -0.0633523812454738, "compression_ratio": 1.6808510638297873, "no_speech_prob": 6.605107773793861e-05}, {"id": 257, "seek": 153080, "start": 1530.8799999999999, "end": 1536.1599999999999, "text": " representation where each value was evaluated at the roots of unity and gives you a set of", "tokens": [50368, 10290, 689, 1184, 2158, 390, 25509, 412, 264, 10669, 295, 18205, 293, 2709, 291, 257, 992, 295, 50632], "temperature": 0.0, "avg_logprob": -0.05226241406940278, "compression_ratio": 1.6008583690987124, "no_speech_prob": 0.0017545823939144611}, {"id": 258, "seek": 153080, "start": 1536.1599999999999, "end": 1541.36, "text": " coefficients for the original polynomial basically reversing what the original FFT did.", "tokens": [50632, 31994, 337, 264, 3380, 26110, 1936, 14582, 278, 437, 264, 3380, 479, 25469, 630, 13, 50892], "temperature": 0.0, "avg_logprob": -0.05226241406940278, "compression_ratio": 1.6008583690987124, "no_speech_prob": 0.0017545823939144611}, {"id": 259, "seek": 153080, "start": 1541.36, "end": 1547.28, "text": " As we just saw this requires multiplying by the inverse of the DFT matrix. We noted that each", "tokens": [50892, 1018, 321, 445, 1866, 341, 7029, 30955, 538, 264, 17340, 295, 264, 413, 25469, 8141, 13, 492, 12964, 300, 1184, 51188], "temperature": 0.0, "avg_logprob": -0.05226241406940278, "compression_ratio": 1.6008583690987124, "no_speech_prob": 0.0017545823939144611}, {"id": 260, "seek": 153080, "start": 1547.28, "end": 1554.0, "text": " omega in our original DFT matrix now corresponds to 1 over n times omega to the power of negative 1.", "tokens": [51188, 10498, 294, 527, 3380, 413, 25469, 8141, 586, 23249, 281, 502, 670, 297, 1413, 10498, 281, 264, 1347, 295, 3671, 502, 13, 51524], "temperature": 0.0, "avg_logprob": -0.05226241406940278, "compression_ratio": 1.6008583690987124, "no_speech_prob": 0.0017545823939144611}, {"id": 261, "seek": 155400, "start": 1554.0, "end": 1560.0, "text": " Now the punchline here is that what this means is we can define the inverse FFT", "tokens": [50364, 823, 264, 8135, 1889, 510, 307, 300, 437, 341, 1355, 307, 321, 393, 6964, 264, 17340, 479, 25469, 50664], "temperature": 0.0, "avg_logprob": -0.05240929781735598, "compression_ratio": 1.5862068965517242, "no_speech_prob": 0.0004583077388815582}, {"id": 262, "seek": 155400, "start": 1560.0, "end": 1567.44, "text": " as the same FFT function but now called on the value representation with omega defined as 1 over", "tokens": [50664, 382, 264, 912, 479, 25469, 2445, 457, 586, 1219, 322, 264, 2158, 10290, 365, 10498, 7642, 382, 502, 670, 51036], "temperature": 0.0, "avg_logprob": -0.05240929781735598, "compression_ratio": 1.5862068965517242, "no_speech_prob": 0.0004583077388815582}, {"id": 263, "seek": 155400, "start": 1567.44, "end": 1574.64, "text": " n times e to the negative 2 pi i divided by n. That's it. With those small changes we have", "tokens": [51036, 297, 1413, 308, 281, 264, 3671, 568, 3895, 741, 6666, 538, 297, 13, 663, 311, 309, 13, 2022, 729, 1359, 2962, 321, 362, 51396], "temperature": 0.0, "avg_logprob": -0.05240929781735598, "compression_ratio": 1.5862068965517242, "no_speech_prob": 0.0004583077388815582}, {"id": 264, "seek": 155400, "start": 1574.64, "end": 1581.04, "text": " an inverse FFT that performs interpolation. Just so we are super clear on what sorcery just happened", "tokens": [51396, 364, 17340, 479, 25469, 300, 26213, 44902, 399, 13, 1449, 370, 321, 366, 1687, 1850, 322, 437, 41349, 88, 445, 2011, 51716], "temperature": 0.0, "avg_logprob": -0.05240929781735598, "compression_ratio": 1.5862068965517242, "no_speech_prob": 0.0004583077388815582}, {"id": 265, "seek": 158104, "start": 1581.04, "end": 1585.84, "text": " let me remind you of the original FFT implementation and now let me show you the", "tokens": [50364, 718, 385, 4160, 291, 295, 264, 3380, 479, 25469, 11420, 293, 586, 718, 385, 855, 291, 264, 50604], "temperature": 0.0, "avg_logprob": -0.08808536349602465, "compression_ratio": 1.7630522088353413, "no_speech_prob": 0.0006986527005210519}, {"id": 266, "seek": 158104, "start": 1585.84, "end": 1590.6399999999999, "text": " inverse FFT implementation which takes the value representation as an input.", "tokens": [50604, 17340, 479, 25469, 11420, 597, 2516, 264, 2158, 10290, 382, 364, 4846, 13, 50844], "temperature": 0.0, "avg_logprob": -0.08808536349602465, "compression_ratio": 1.7630522088353413, "no_speech_prob": 0.0006986527005210519}, {"id": 267, "seek": 158104, "start": 1591.92, "end": 1597.68, "text": " What we literally do is copy our FFT implementation, change the name of the recursive calls to", "tokens": [50908, 708, 321, 3736, 360, 307, 5055, 527, 479, 25469, 11420, 11, 1319, 264, 1315, 295, 264, 20560, 488, 5498, 281, 51196], "temperature": 0.0, "avg_logprob": -0.08808536349602465, "compression_ratio": 1.7630522088353413, "no_speech_prob": 0.0006986527005210519}, {"id": 268, "seek": 158104, "start": 1597.68, "end": 1603.68, "text": " match and then literally change one line of code. One line and that's all there is to it.", "tokens": [51196, 2995, 293, 550, 3736, 1319, 472, 1622, 295, 3089, 13, 1485, 1622, 293, 300, 311, 439, 456, 307, 281, 309, 13, 51496], "temperature": 0.0, "avg_logprob": -0.08808536349602465, "compression_ratio": 1.7630522088353413, "no_speech_prob": 0.0006986527005210519}, {"id": 269, "seek": 158104, "start": 1604.6399999999999, "end": 1609.68, "text": " So if your mind isn't blown you haven't been paying attention. Let's take a look at what we just", "tokens": [51544, 407, 498, 428, 1575, 1943, 380, 16479, 291, 2378, 380, 668, 6229, 3202, 13, 961, 311, 747, 257, 574, 412, 437, 321, 445, 51796], "temperature": 0.0, "avg_logprob": -0.08808536349602465, "compression_ratio": 1.7630522088353413, "no_speech_prob": 0.0006986527005210519}, {"id": 270, "seek": 160968, "start": 1609.68, "end": 1615.44, "text": " did. We motivated the FFT through the problem of polynomial multiplication where the first", "tokens": [50364, 630, 13, 492, 14515, 264, 479, 25469, 807, 264, 1154, 295, 26110, 27290, 689, 264, 700, 50652], "temperature": 0.0, "avg_logprob": -0.046275333691668766, "compression_ratio": 1.7984790874524714, "no_speech_prob": 0.0004044713859912008}, {"id": 271, "seek": 160968, "start": 1615.44, "end": 1620.64, "text": " brilliant idea came from representing and multiplying polynomials using the value representation.", "tokens": [50652, 10248, 1558, 1361, 490, 13460, 293, 30955, 22560, 12356, 1228, 264, 2158, 10290, 13, 50912], "temperature": 0.0, "avg_logprob": -0.046275333691668766, "compression_ratio": 1.7984790874524714, "no_speech_prob": 0.0004044713859912008}, {"id": 272, "seek": 160968, "start": 1621.3600000000001, "end": 1625.68, "text": " Converting polynomials to a value representation required us to come up with an appropriate", "tokens": [50948, 2656, 331, 783, 22560, 12356, 281, 257, 2158, 10290, 4739, 505, 281, 808, 493, 365, 364, 6854, 51164], "temperature": 0.0, "avg_logprob": -0.046275333691668766, "compression_ratio": 1.7984790874524714, "no_speech_prob": 0.0004044713859912008}, {"id": 273, "seek": 160968, "start": 1625.68, "end": 1631.68, "text": " set of evaluation points. Our first attempts at solving this problem inspired the clever idea of", "tokens": [51164, 992, 295, 13344, 2793, 13, 2621, 700, 15257, 412, 12606, 341, 1154, 7547, 264, 13494, 1558, 295, 51464], "temperature": 0.0, "avg_logprob": -0.046275333691668766, "compression_ratio": 1.7984790874524714, "no_speech_prob": 0.0004044713859912008}, {"id": 274, "seek": 160968, "start": 1631.68, "end": 1637.44, "text": " using positive negative pairs but the recursion didn't quite work unless we expanded the domain", "tokens": [51464, 1228, 3353, 3671, 15494, 457, 264, 20560, 313, 994, 380, 1596, 589, 5969, 321, 14342, 264, 9274, 51752], "temperature": 0.0, "avg_logprob": -0.046275333691668766, "compression_ratio": 1.7984790874524714, "no_speech_prob": 0.0004044713859912008}, {"id": 275, "seek": 163744, "start": 1637.44, "end": 1643.1200000000001, "text": " to complex numbers. The next brilliant idea came from using the nth roots of unity where the points", "tokens": [50364, 281, 3997, 3547, 13, 440, 958, 10248, 1558, 1361, 490, 1228, 264, 297, 392, 10669, 295, 18205, 689, 264, 2793, 50648], "temperature": 0.0, "avg_logprob": -0.061725496088416834, "compression_ratio": 1.737037037037037, "no_speech_prob": 0.0009110221872106194}, {"id": 276, "seek": 163744, "start": 1643.1200000000001, "end": 1648.48, "text": " at every level of recursion are positive negative paired. This evaluation scheme using the roots", "tokens": [50648, 412, 633, 1496, 295, 20560, 313, 366, 3353, 3671, 25699, 13, 639, 13344, 12232, 1228, 264, 10669, 50916], "temperature": 0.0, "avg_logprob": -0.061725496088416834, "compression_ratio": 1.737037037037037, "no_speech_prob": 0.0009110221872106194}, {"id": 277, "seek": 163744, "start": 1648.48, "end": 1653.92, "text": " of unity encompassed the essence of the FFT algorithm. When confronted with the problem", "tokens": [50916, 295, 18205, 28268, 292, 264, 12801, 295, 264, 479, 25469, 9284, 13, 1133, 31257, 365, 264, 1154, 51188], "temperature": 0.0, "avg_logprob": -0.061725496088416834, "compression_ratio": 1.737037037037037, "no_speech_prob": 0.0009110221872106194}, {"id": 278, "seek": 163744, "start": 1653.92, "end": 1659.04, "text": " of reversing the process using interpolation we discovered something truly astounding.", "tokens": [51188, 295, 14582, 278, 264, 1399, 1228, 44902, 399, 321, 6941, 746, 4908, 5357, 24625, 13, 51444], "temperature": 0.0, "avg_logprob": -0.061725496088416834, "compression_ratio": 1.737037037037037, "no_speech_prob": 0.0009110221872106194}, {"id": 279, "seek": 163744, "start": 1659.04, "end": 1666.0, "text": " The inverse FFT is the same algorithm but with one minor adjustment. So if we take a look at what", "tokens": [51444, 440, 17340, 479, 25469, 307, 264, 912, 9284, 457, 365, 472, 6696, 17132, 13, 407, 498, 321, 747, 257, 574, 412, 437, 51792], "temperature": 0.0, "avg_logprob": -0.061725496088416834, "compression_ratio": 1.737037037037037, "no_speech_prob": 0.0009110221872106194}, {"id": 280, "seek": 166600, "start": 1666.0, "end": 1672.24, "text": " we just did here there's not one, not two, not three, but four absolutely mind-blowing ideas", "tokens": [50364, 321, 445, 630, 510, 456, 311, 406, 472, 11, 406, 732, 11, 406, 1045, 11, 457, 1451, 3122, 1575, 12, 43788, 3487, 50676], "temperature": 0.0, "avg_logprob": -0.07370455775942121, "compression_ratio": 1.7462686567164178, "no_speech_prob": 0.0019266457529738545}, {"id": 281, "seek": 166600, "start": 1672.24, "end": 1677.68, "text": " that come together to make this work. Do I really need to say more on why this is my favorite algorithm?", "tokens": [50676, 300, 808, 1214, 281, 652, 341, 589, 13, 1144, 286, 534, 643, 281, 584, 544, 322, 983, 341, 307, 452, 2954, 9284, 30, 50948], "temperature": 0.0, "avg_logprob": -0.07370455775942121, "compression_ratio": 1.7462686567164178, "no_speech_prob": 0.0019266457529738545}, {"id": 282, "seek": 166600, "start": 1681.28, "end": 1685.36, "text": " That's all for this video and thanks for watching. If you enjoyed the content please", "tokens": [51128, 663, 311, 439, 337, 341, 960, 293, 3231, 337, 1976, 13, 759, 291, 4626, 264, 2701, 1767, 51332], "temperature": 0.0, "avg_logprob": -0.07370455775942121, "compression_ratio": 1.7462686567164178, "no_speech_prob": 0.0019266457529738545}, {"id": 283, "seek": 166600, "start": 1685.36, "end": 1690.0, "text": " hit the like button so that this content will be recommended to more people. If you want to", "tokens": [51332, 2045, 264, 411, 2960, 370, 300, 341, 2701, 486, 312, 9628, 281, 544, 561, 13, 759, 291, 528, 281, 51564], "temperature": 0.0, "avg_logprob": -0.07370455775942121, "compression_ratio": 1.7462686567164178, "no_speech_prob": 0.0019266457529738545}, {"id": 284, "seek": 166600, "start": 1690.0, "end": 1694.48, "text": " see more content like this please don't forget to hit the subscribe button and if you want to", "tokens": [51564, 536, 544, 2701, 411, 341, 1767, 500, 380, 2870, 281, 2045, 264, 3022, 2960, 293, 498, 291, 528, 281, 51788], "temperature": 0.0, "avg_logprob": -0.07370455775942121, "compression_ratio": 1.7462686567164178, "no_speech_prob": 0.0019266457529738545}, {"id": 285, "seek": 169448, "start": 1694.48, "end": 1698.96, "text": " more directly support the work of this channel please check out the Patreon page linked in the", "tokens": [50364, 544, 3838, 1406, 264, 589, 295, 341, 2269, 1767, 1520, 484, 264, 15692, 3028, 9408, 294, 264, 50588], "temperature": 0.0, "avg_logprob": -0.13322110857282365, "compression_ratio": 1.3070175438596492, "no_speech_prob": 0.09943237155675888}, {"id": 286, "seek": 169448, "start": 1698.96, "end": 1702.24, "text": " description below. I'll see you all in the next video.", "tokens": [50588, 3855, 2507, 13, 286, 603, 536, 291, 439, 294, 264, 958, 960, 13, 50752], "temperature": 0.0, "avg_logprob": -0.13322110857282365, "compression_ratio": 1.3070175438596492, "no_speech_prob": 0.09943237155675888}], "language": "en"}