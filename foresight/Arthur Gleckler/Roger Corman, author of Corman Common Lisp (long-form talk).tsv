start	end	text
0	9560	When I was a kid, I believed in Santa Claus, I believed in magic, I believed magicians
9560	14400	were really doing magic when they were on stage, and I believed in the Easter Bunny
14400	17920	and all those magical things.
17920	26960	And when I learned Little Older, like, probably I'll have a similar story, there was no magic,
26960	34160	and it was kind of sad, and some years later, I feel like the magic came back.
34160	41440	And to me, tech, you know, the internet, I mean, it's so far beyond anything I could
41440	47480	have imagined and considered magical, you know, and I always talk about magic when I
47480	55120	talk about tech stuff, because to me I'm still in awe, and it's just amazing to the
55120	60240	more you learn, the more you're in awe of all of these things.
60240	68920	And I've been fascinated with Lisp machines, you know, ever since I got into programming.
68920	74640	It's just really great to be here today, I'm so glad to have been asked, and that you've
74640	78880	got such a great group and all these Lisp people here.
78880	85720	I certainly have always felt that the Lisp programmers that I know, the people that are
85720	89840	in the Lisp are the most brilliant software engineers.
89840	95400	I think you know what I'm talking about, it's like people that really are creative, understand
95400	101520	a lot of things, and it's so just awesome to be here with all of you, to meet a lot
101520	105200	of you tonight.
105200	115000	So I spent a lot of years, thirty-five years now, programming Lisp, programming Lisp systems,
115000	120600	and in talking, working out what I was going to talk about, sounded like there was some
120600	126560	interest in, you know, how Cormin Lisp got built and why, and so I'm going to get into
126560	132840	that some, but I also built two other Lisp's, and I think that it's kind of interesting
132840	137800	to talk about that, and I also want to talk a little bit about some projects that I've
137800	142600	done and am working on now, and I didn't really know how to put all that together other than
142600	148480	in a sort of a chronological thing, so I don't want it to be like a scrapbook or something,
148480	154000	I mean I want it, hopefully there's some kind of message you get out of here, and I'm not
154000	158160	just preaching to the choir because I do start to evangelize about Lisp, and I know there's
158160	172280	not a need for that here, but anyway, I will start with where I started, a few things we'll
172280	181160	touch on, why did I develop three Lisp's, I learned Lisp from a musician through essentially
181200	189640	correspondence, of course through the mail, kind of weird, Franz kind of convinced me to
189640	195160	create my own Lisp, and then I think they regretted it later, so this is kind of interesting,
195160	202040	I like Cormin Lisp, what I would say is great about it is I think it's great for hacking,
202360	212280	hacking in the good sense, the white hat sense, I'm interested in other Lisp's, lots of Lisp's
212280	220720	to me, the fact that there's like so many Lisp's, closure and scheme, and whatever Lisp's that are
220720	227160	non-conformant, and ones that people are inventing, to me that's a feature, not a bug, I mean what
227160	233440	other language can you say this about, you know where you could just say a name, a simple name
233440	238720	that describes a whole bunch of languages, and everybody pretty much agrees that they all are
238720	247240	part of that family, and why is the current project I'm working on using a trampoline,
247240	256360	I might get to that if I make it through the slides, so before I got into computing,
257000	265560	I was a musician, a jazz pianist, and I still play, I still do gigs, managed to keep that up over
265560	271720	the years, mostly that was while I was in college that I was doing it professionally, but I was
271720	282440	studying music and computer science at Sonoma State, and computer science classes, I started in
282520	289920	with that and learning Pascal, and it was fun, it was easy, but nothing exciting about it, and my
289920	300840	music professor, Arthur Hills, took a year off, he's an organist and into medieval music, he
300880	310760	took a year off to go study Lisb, and for a sabbatical, and write a Gregorian chant generator,
310760	318720	that's what he did for a year, right, and so he kind of got back in touch, during that year he
318720	322920	got in touch with the people in the music department, and said Sonoma State, and all the other
322920	326960	professors, and said, oh this is great, you got to learn this new language, you got to learn
327000	334240	computer programming, this is in 1981, 1982, and none of them, including him, had done anything with
334240	340000	computers, and he asked me, I wasn't a teacher, but he asked me, because I was a student, a computer
340000	352040	student too, so, I mean yeah, okay, and you know, we started programming on the cyber, it's like a
352080	358080	supercomputer that Sonoma State had, I mean it's designed by Cray, but at very weird architecture
358080	364520	with six-bit bytes, and 60-bit word lengths, and it took two bytes to store a lowercase character,
364520	373560	and one byte to store an uppercase character, and so Art, since he lived, was living in San
373600	381040	Francisco, he would, basically it came down to mostly me and him, he would start to send me
381040	389960	letters, and he would write out longhand these letters about Lisp functions, you know, some code
389960	395520	he was working on with his Gregorian chant generator, or some new, you know, new feature that he
395520	401080	learned, that he wanted to share with me, and sometimes he would take a tractor feed print
401080	405360	out, you know, they're really wide, and fold it all up, and stuff it in the envelope, along with a
405360	411000	handwritten, or typed on his typewriter with lots of corrections, and so this is an example, this
411000	418200	was a postcard, he'd send, hi Roger, I've already conceived improvements of my own, I haven't tried
418200	423400	these yet, but surely they'll work for A-mean, and G-mean, and here's all this code, and after the
423400	429000	last parenthesis, he even signs his name, Arthur, down in the corner, in case I don't know who's
429040	435560	sending me this Lisp code, right, and if you look at the postmarket, it's hard to read, but it's July
435560	443600	17th, 1982, which just about 35 years ago today, so I think that proves I've been using Lisp for that
443600	455800	long, so we, this was basically Lisp 1.5 back in those days, and I just couldn't not believe how
455840	464520	magical it was, how amazing it was to do symbolic computation, and no numbers, you know, I think
464520	470440	worked with Pascal, and with C, you know, everything's a number really, and your C program, your
470440	475920	characters are numbers, and you know, functions are really, you know, addresses, and addresses are
475920	480160	numbers, and you know, just across the board, and you know that, and you have to know that,
480200	486920	and you have to understand to work with it back then, but in Lisp, God, I wrote lots of programs
486920	492880	with no numbers, just lots of lists, and random selections, and application, and I made my own
492880	500000	rules engine, and I worked on a rules engine to do something more original, like it generated
500160	505600	jazz compositions. Okay, Arthur was doing Gregorian chants, I was doing jazz compositions,
509360	516480	but this machine that was like a supercomputer was so fast, it would compile, you know, 5,000 line
516480	523280	Pascal program in a second, you know, and run everything so quickly, my jazz composer generator
524000	528320	would just bring the thing to its knees, you know, it would be like, it would sit there for 30 seconds,
528320	532000	and the other people in the computer lab are complaining that the computer's frozen, and
532000	538480	finally it would time out, and it was working, it's just that it was, I was doing, you know,
538480	543200	multiple levels of recursion and all kinds of stuff that were very inefficient, it was my
543200	548960	own algorithms, my own fault, wasn't the computer's fault, but that got me like, well, how does this
548960	555600	work, you know, disassembling the code, and looking at how, you know, and I found out that like
555680	560800	car and cutter were like two instructions or something on that machine, I mean, it was amazing,
561360	563760	it was amazingly efficient when you started looking at it.
569600	576320	After college, I went to work on microcomputers, 8-bit, 16-bit, very little memory,
578000	582800	I just assumed there was no way you could use lisp on those, after my experience with the
582800	590320	performance thing, I said, okay, you know, I mean, we can use basic or fourth or C, but there was no
590320	597840	way a lisp could possibly run on 64k, but it wasn't entirely true, and after, you know, a couple
597840	603360	years, I started writing my own little lisp interpreters, and using them as scripting languages
603360	612480	inside my C programs, just as AutoCAD or Emacs uses lisp for scripting, and today we would say,
612480	617680	you know, you could use it as for automated testing, and, you know, macros and things like
617680	622560	that, lisp was good for that, and so I started putting them into lots of my, you know, I was doing
622560	629280	computer graphics applications, and so that was useful, and they didn't have to be big,
629280	633920	they just had to be big enough to sort of run the different functions of the application
633920	639840	that they were embedded in, but that's how I learned about how you implement a simple lisp,
639840	643760	I mean, lisp is simple, right, it is simple to make a lisp interpreter.
648400	653120	I didn't really understand how garbage collection worked, that was kind of the hardest part of it,
653120	658320	if you've ever written a garbage collection collector, you know, it's like, that's not so easy,
658880	663760	you got to deal with registers and stacks and all kinds of low level things,
663760	675600	but anyway, that was kind of my first exposure, first use of lisp on, on PCs, and when I moved to
675600	683600	the Mac, fortunately, because the Mac had more memory and was more powerful around that time,
683600	692160	around 1990, I actually saw Mac common lisp in action, and some of you, I'm sure, know Mac common
692720	699120	lisp, coral common lisp, now it's called closure with a Z, and it was an amazing
699760	707360	kind of experience, and it kind of made me realize, wow, lisp could be really, really fast,
708000	714720	I mean, honestly, it seemed like it was as fast as C, and how does that work?
715680	721520	And I would start, you know, read all of their documentation, and like trying to figure out how,
721520	724720	how could, is it, is it really doing what it seems like it's doing?
726720	734080	And it cost $500, and I didn't have $500 to spend on, you know, on a license, since it was more of
734640	738880	less a hobby, at that point, I didn't have a job doing lisp programming,
739840	745920	so I ported over my PC code, and started running that on a Mac, and then started adding all the
745920	752880	common lisp features, because I like the common lisp spec better than the lisp 1.5 spec that I've
752880	762560	been working with, and Mac was big enough to support it, and I ended up developing a pretty
762560	771600	full common lisp, and adding class, and adding, you know, loop, and an editor that was built from
771600	777680	scratch, because we didn't have like, you couldn't just like, take modules, and programs that other
777680	781120	people had written the way you can today, you know, it's like, if you want an editor, basically,
781120	788160	you're going to write it yourself. MarketSweep Collector, had a full 80, 68k,
788480	795520	compiler, code generator, assembler, disassembler, spent years on this,
796640	806080	and it was a lot of fun, release it as shareware, and a lot of people use it, AOL in those days,
806080	814160	we distributed it on AOL, because we didn't have the web yet, and Apple picked it up, and put it
814160	819920	on their developer disk, which was nice, so every month it got sent out to all the Apple developers,
821520	829280	a little notoriety from that. It still didn't begin to compete with Mac common lisp, and speed,
829280	832960	it was cheaper, but it was not anywhere near as fast.
833120	845120	So here it is, running on a PowerBook 170, this is what I developed it, I called it PowerLisp,
845120	851600	because it was developed on a PowerBook, and lest you think this is like an old picture,
851600	856880	I took this two days ago in my office, because that machine still runs, it's a
857600	865360	26 year old machine, and I have to sort of plop it on the table top to get the hard drive to
865360	869520	spin up, I have to sort of knock it around a little bit, but then it gets going and it's pretty good,
870960	878160	surprising what it does, and you can see I got the little disassembly there,
878240	888880	and PowerPC came out, and I redid it for PowerPC, and got into risk architecture,
888880	894000	and learned how all that instruction set, and how arguments are passed, and that was very different,
895440	900880	but you sort of had to do that, if you're on Apple in those days, you had to rewrite your stuff for
900880	909600	PowerPC, and did that, released fat versions of it, fat version meant it would run on PowerPC,
909600	918960	or 68000 max. Questions are fine. How much of the code was actually a assembler versus everything
918960	925200	that you could write on top of it, you were writing a common list, right? So there was a basic,
925440	937360	there was very little assembler in this, mostly a C++ kernel, and then like the compiler, and the
937360	945600	assembler, and all these other parts were all written in Lisp, so mostly Lisp after the kernel,
945600	951920	but it had quite a lot in C++, and I didn't like that, and when I came along later and did another
951920	961440	one, I got rid of most of that, and recoded stuff in Lisp, so kind of a diversion from that path.
962240	970160	Now, I've never really been able to develop Lisp systems for my main job, right? It's always been
970160	976880	kind of a sideline, kind of a hobby. I always had to make money, and there's not that much money,
976880	986480	and that's, I just kept doing it in my evenings, you know, long nights, and at one point I got an
986480	996560	opportunity to build a decision support system for hospital software, which was pretty cool. It was
996560	1003520	kind of an AI thing, kind of an expert system to alert physicians to medical problems, and to run
1003520	1009360	rules that were written in this language called Arden syntax, which is a standard for medical rules,
1009360	1018880	medical logic, and so I, because I wrote compilers, I got the job, and immediately, you know,
1018880	1026640	had to build something quickly, and the spec for this language, Arden, was basically, you know,
1026640	1031760	weakly typed, you know, dynamic typing, it needed garbage collection, it needed a lot of features,
1032240	1038160	no way I was just going to write this in C, you know, and generate code in C. It just would have
1038160	1044240	been very inefficient, you know, and you wanted to be able to load rules on the fly, update rules
1044240	1048960	on the fly, you know, all this stuff, but I thought it would be simple to do this in Lisp, you know,
1048960	1054800	I could easily generate a Lisp function from these rules, and then those Lisp functions would all
1054800	1059600	run, and I'd have all the features I needed, and that turned out to have been a very good decision,
1059600	1068720	so then the problem was, this was back in the mid-90s, companies didn't want you to use any
1068720	1074560	other language in C++ in those days, it was like the company I was working with at the time just
1074560	1079200	was like, no, everything's C++, that's just the way it's going to be, you know, there was this idea
1079200	1082960	that someday everybody was going to be using the same language, that all programming languages
1082960	1088880	were going to converge, which seems ludicrous today, but that was a thought for a long time,
1089920	1096560	and so I kind of snuck it in, I just sort of like brought over my code from the Mac,
1097360	1102560	my Lisp system from the Mac, translated it back to Windows, stripped out a bunch of stuff I didn't
1102560	1115680	need, and embedded it into the code and said, it's C++, it's all C++, right, and truly that system,
1115680	1123360	that Arden compiler and everything was mostly written in C++, but the rules all get generated,
1123360	1130240	all get translated into Lisp, and all get run as Lisp functions, and this system's been very
1130240	1137120	successful, I can't tell you how successful it's been, and it's definitely the most successful
1137120	1146640	thing I've worked on. It's still in the top two or three US hospital systems and used today,
1147840	1153520	I know what it's doing and how it's being used, and we kept expanding it and expanding it to be
1153520	1159440	used basically as a scripting language for the whole system, so rules don't just alert physicians,
1159440	1164720	but rules actually fill out forms, you know, look up data in the database and fill out default
1164720	1170720	values or, you know, prompt the user, there's all kinds of things they do, and I've had the
1170720	1176800	luck to be sort of work on it over the years and maintaining it, and I've also built a system that
1176800	1184720	monitors the use of this system in hospitals and logs it, and in one hospital alone, millions of
1184720	1188800	rules a day are triggered, you know, millions of these Lisp functions a day are triggered,
1188800	1192960	every single thing that goes into every single patient record goes through all these rules,
1193120	1199920	and that's the reason that that system is still around 20 years later, because it's getting kind
1199920	1206800	of, you know, archaic in terms of its age, but it's, we did port it to .NET at one point, so it's
1206800	1216480	no longer, so it's no longer native code. This is a screenshot of the editor for that system
1216480	1221120	that's still in use today, it looks old, you know, the user interface looks old because it is,
1221840	1228240	but it's, if you can see off on the bottom part on the left, there's part of a rule here, there's
1228240	1235840	not much showing, but the function definition actually shows on that panel on the right,
1236400	1242000	and you can see that there's a lambda definition, so that's the Lisp code that got generated from
1242000	1250080	that rule, and this isn't documented and nobody really knows this there, so, but thousands of
1250080	1256320	users are writing these rules, and the fact that Lisp is in there is completely unknown, most of them.
1257680	1262240	In fact, if you went to the next tab over the execute tab, there's a repel, there's a hidden
1262240	1267440	repel, and so I could go in there and like just start executing all kinds of lists, nobody even
1267440	1279360	knows it's there, right, so it's just kind of interesting. This is just some of the hospitals
1279360	1284160	that it's running in, New York Presbyterian, Columbia University Cornell, Johns Hopkins,
1284160	1289840	Cleveland Clinic, Memorial Sloan Kettering, Cancer, National Institute of Health, I mean,
1290640	1294960	that's just the beginning, but it's, you could tell it's, these are big places, so it's,
1296080	1298720	you know, we've got Lisp running in those things, and I think that's cool.
1299680	1310000	There, all scripts has been high on the list of hospitals, software that actually get used by
1310000	1318000	physicians, as what this is, what CPOE is, physician order entry, or care provider order entry,
1318960	1320320	so it's been very successful.
1324000	1326400	Any, any questions, any questions before I move on?
1327360	1330800	What I'm doing on time? How long am I supposed to talk?
1333600	1339440	Okay, I'll just, I'll just keep going. I just want to, I probably won't get through all my slides,
1339440	1350400	but around 1996, I'd say Fritz Kunze, who was the CEO of Franz, makers of Allegro Common Lisp,
1350400	1357920	contacted me and said, well, why don't you come, come meet me, and you know, in our office,
1357920	1362400	I have something I want to ask you about, and I, that was great. I got to go down to Franz,
1362400	1369440	to their office, and, and talk, and what they wanted me to do was pour Allegro Common Lisp to Mac,
1370480	1376080	because they decided they needed a Mac version, and I'd written a Mac version of Lisp, so I was
1376080	1382640	a good candidate for that. And so I made them some kind of a bid, like six months or something, you
1382640	1387840	know, I, no idea how long it was really going to take, but, and, and they never took me up on it,
1387840	1394560	I think they thought it was too expensive. I don't know, but in the process, they gave me a copy of,
1395120	1401440	of Allegro Common Lisp for Windows, and it was a big box with a ton of manuals and cost a thousand
1401440	1408320	dollars, like no way I could ever afford to buy that for myself. Again, you know, unless I was
1408320	1414080	professional, you know, for professional purpose, but I was very happy, they just gave it to me,
1414800	1423440	and, and I, I love all the people at Franz are awesome, but when I played with it, this was,
1423440	1431120	it was crazy, it was like 16-bit fixnums, which was, I think, a holdover from DOS,
1431840	1437200	you know, and, and this was, this was, you know, Windows 95 was out and Windows NT, and they had
1437200	1442800	preemptive multi-threading and tons of memory, all these features, and here they were marketing this
1442800	1449920	system that 16-bit fixnums and eight character limit on filenames, I mean, they were like way
1449920	1456080	behind the times, and they knew that, I mean, they were like, yeah, well, they had bought it from
1456080	1465600	some other company, so that they'd have a Windows version, but okay, that, anyway, that was the
1465600	1470640	state of that, and I, and I was kind of like, well, why don't you guys have your main system
1470640	1475280	running on it, and they, well, we don't really think Windows is a serious platform, you know,
1475280	1479760	we've got Unix, you know, our Unix systems is what all the people are really seriously using, and
1481360	1486240	the Mac one will just be kind of like, you know, we'll see if anybody wants it, but Windows was
1486240	1492480	not of interest, and then I started going around and going, well, what LISPs are running on Windows,
1493040	1498480	because at that point in the late 90s, it looked like Windows was the platform, I mean, Windows was
1498480	1503360	taken off like crazy, and it really was powerful, it was at that point, it got a lot better than the
1503360	1513840	Mac for some years before OS X, and so LispWorks wasn't running on Windows, they'd see Lisp,
1513840	1518080	but that was kind of just a port of, you know, something, you know, bytecode compiler,
1518960	1525600	and it was like, you know, there's a market for here for like a serious Lisp on Windows.
1526080	1534240	I remember Gold Hill, but I don't think that it got, I think it might have been on
1534240	1544720	like Windows 3, but not on like Windows 90, I mean, it could have been that that still existed,
1544720	1550000	I never played with it. In any case, it looked at me like there was a big opportunity for a good
1550000	1557440	Lisp, so that was when I just decided to get serious and do something like as good as trying
1557440	1563840	to do something as good as Mac common Lisp in terms of performance, and it had to be a complete
1563840	1569120	rewrite because I was never going to be able to do it with the code that I built already,
1570000	1576960	and I knew it needed like a good garbage collector, like a generational garbage collector with
1577040	1584560	taking advantage of real, you know, hardware virtual memory and, you know, fully tagged.
1592240	1598400	I kind of modeled it on, in all ways, pretty on what I'd read in Mac common Lisp's
1599200	1606240	manuals, which are extensive and very enlightening, and again, you know, it wasn't that easy to find
1606240	1612320	stuff like this, like finding stuff about garbage collectors had been impossible in the 80s, and
1612320	1619120	in the 90s, it was possible, but mostly it was just some papers that like Henry Baker had written,
1619120	1626240	like you could find a few papers here and there, but figuring out how to build some of this, and I
1626240	1633360	wanted to do stew 100% compiled, native compiled, with no interpreter, because actually that's one
1633360	1641040	of the things I hate about common Lisp is the interpreter slash compiled dual execution path.
1644560	1650960	So, to step back, everybody's got their own ideas, what they like, and I'd say my favorite things
1651520	1657920	about Lisp, these are the things I think that make Lisp amazing.
1658880	1665520	S expressions, is there still not another language that has anything like S expressions,
1665520	1668320	you know, where the code and the data are the same format?
1670560	1676720	XSLT, okay, yeah, not as elegant, but okay, yeah.
1677520	1687600	The Kanzing engine, by Kanzing engine, I mean generates Kanza's fast, doesn't, you know,
1687600	1693680	you've got a garbage collector to match, it's like every other language can't compete with
1693680	1701440	a good Lisp in terms of like allocating heap stuff, little heap objects. I found Java VMs,
1701440	1707600	usually orders of magnitude slower at generating tons of little things, and so the fact that a
1707600	1713600	Lisp can like generate Kanza's, you know, these eight byte or 16 byte little pieces or small,
1714800	1719840	you know, tag floats or whatever, can generate those, you know, generate the heap for those and
1719840	1727760	then clean them up when you throw them away, you know, really fast is a really key element of Lisp
1727760	1734000	to me, and the fact that you could build any data structure out of Kanza's is great.
1738720	1745600	I know, I know, yeah, yeah, that's one of the things I don't like about Closure, I guess I'd say,
1746480	1756160	but macros, well, I've said I guess there's been so many great stuff written about macros and so
1756240	1762640	many great macros written. Everybody's got garbage collection these days, that's not such a big deal
1762640	1772160	anymore, but a really efficient one, as I said, for getting rid of tons of, tons of, people worry
1772160	1777280	about, people were always worrying about Kanzing, you know, when Lisp people were writing, oh, don't
1777280	1784240	do this, it'll generate too much Kanza, well a good garbage collector is, you know, the amount
1784320	1787920	of time it takes is relative to the amount of live stuff that you're keeping around,
1789040	1794880	if it's written right, it's not based on how much stuff you're throwing away, in fact, the one I
1794880	1801120	wrote takes zero time to throw away, to delete something, I mean, it's all it does is pick up
1801120	1807280	the live objects and defragment them and move them to a different heap, and zero time is spent,
1807280	1813840	you know, deleting the dead objects, so you could generate millions of Kanza's and not worry about
1813840	1821040	garbage collection times, and I really like the multi-paradigm aspects of common Lisp anyway,
1821840	1828000	you can get, you know, objects if you want, object-oriented paradigms, there it's great,
1828000	1832880	it's like one of the best, but you don't have to use them, you can use functional, you can use
1833600	1839840	just simple, you know, procedural programming, works great, whatever you want to do, declarative,
1839840	1845920	you could make your domain-specific language, just a lot of different, I love that, you know,
1845920	1850080	I just love not being constricted and having that flexibility.
1857280	1862400	Some things I don't like about common Lisp, and I'm bringing these up because if you ever used
1862400	1870320	my system, you'll notice, you'll probably notice, but I don't like the interpreted compile or
1870320	1877040	compiled model, oh, I'm a Lisp programmer and I write a function, oh, and I run it, oh, well,
1877040	1881520	but it's not as fast as it should be, oh, well, that's because I didn't compile it, okay, I compile
1881520	1886480	it, now it does the same thing, but faster, well, why didn't it compile it in the first place,
1886480	1889840	I didn't get the, oh, because then you wouldn't be able to step through it or something, you wouldn't
1889840	1895920	mail the trace, you know, to me, that's just crazy, you know, all the common Lisp, all any
1895920	1901600	language should do is it should make your program run as best it can, you know, when you enter it.
1902480	1902960	Yeah.
1915440	1922960	And don't have an interpreter? I don't know why you say that because Frans doesn't do, I mean,
1922960	1928640	Frans, Allegro interprets and compiles, I mean, I spent three years working with that recently.
1932320	1935040	You could change the default?
1952160	1956480	All right, I'm glad you told me that, so I'll remember that next time I'm using it.
1957360	1967440	And as I said, Frans is like everybody, I love everybody at Frans and they have such a great
1967440	1974000	compiler, it's the class in common Lisp compilers, my opinion, and I did end up spending $5,000 on
1974000	1984400	a copy of it when I needed it for a job. I think that the declaration in syntax is atrocious,
1984400	1989760	unless I just hate declarations, like they just look ugly, they get in the way of perfectly
1989760	1994720	good code. It's a bunch of stuff that the compiler writer, I mean, that the programmer is supposed
1994720	2000320	to do to give hints, but you know, what does they know? What does the programmer know about that?
2000320	2006480	I don't know, it's like, why should they have to worry about that? It's such a huge language that
2006480	2012160	it's almost impossible to implement. I mean, having worked 10 years implementing when I say that,
2012160	2019600	it's like ridiculously big. Yes, anybody who has, it's ridiculously big. I mean,
2021280	2027200	I would never ever take it on again, but I got it, you know, at first, common Lisp, the language
2027200	2032400	one wasn't that bad, right? But I mean, I'd barely finished implementing that in common Lisp,
2032400	2037520	the language two came out, and it was twice as big, suddenly, and then I started implementing
2037520	2045280	that, and then the ANSI spec comes out, and it's like twice as big again. I mean, I'm a guy who
2045280	2051440	likes a big toolbox. I like a programming language. I don't mind that there's different ways to do
2051440	2058560	things. I think that's all fine, but it almost is impossible to implement. I mean, it takes a big
2058560	2061280	organization now. One person cannot do it.
2070480	2081040	Partly that, you know, you would say it's, nowadays, tons of common Lisp standard would be
2081760	2088240	in libraries and not just, you know, and so they would be more optional. Like, if there was a
2088240	2095600	commonly agreed-on subset that was useful, implementers wouldn't have a problem. They
2095600	2099600	could start with that, right? And then they'd have a useful language, and then, you know, that
2099600	2105920	could be like the first phase, and they could go on and implement the rest. But as it stands now,
2106000	2114240	if you don't implement, like, pretty close to 100%, tons of people are going to have, you know,
2114240	2118640	tons of common Lisp packages that are out there aren't going to work, because they use everything.
2119680	2125280	There's not a commonly agreed-on set of things. I mean, it all gets used, you know? I mean,
2125280	2129520	that's a tribute to the people that are doing it. They know their language, and they know what they've
2129520	2136160	found, these tools, they use them. But it's, I don't like the loop syntax. We were talking about
2136160	2144000	that a little, you know, to me, it's not Lispy. So, I put in, I just, I think I stole it from,
2145200	2152320	from SteelBank common Lisp or something, you know, like it's, like, public domain. So, I didn't
2152320	2159520	write it myself. But, and the whole, the implementation is smart enough to do X, you know?
2159520	2163440	It's kind of like the people that designed the language weren't really sure how something would
2163440	2166640	work, and they realized that it was awfully complicated, and it looked like it was going to
2166640	2170880	perform pretty badly. But, well, those compiler writers in the future, they'll be smart. They'll
2170880	2176640	figure out some way to, to implement around that. You know, it's like, oh, so many times I bump into
2176640	2193280	that in the spec. Oh, yeah, well, C loss, I, I think it's the greatest object system there is,
2194240	2201360	and it's also, in some ways, one of the worst. I, I mean, it does everything, and that's awesome,
2201360	2206240	and you can hold it up. Anything, anybody else's object system can do, it can do better,
2206640	2212240	multi-methods and everything else. But, partly, again, that implementing it and making it efficient
2212240	2217840	is, like, so hard, and then being a programmer and trying to, like, get your, you know, understand
2218640	2225520	how to make it work, and to make it work well is so complex. And honestly, I'm most of the time,
2225520	2230640	I just use def struct. Like, structures are great. They're efficient. I know exactly what
2230640	2235680	they're doing. There's nothing complicated about them. I don't know. I'm just not a big fan.
2237280	2248640	It took, it took a long time to get the garbage collector working. At least a year, you know,
2248640	2253440	reading everything I could find about garbage collectors and all the different ways that you
2253440	2261120	make them work and copy in collectors, and there was, Henry Baker wrote a ton of papers that were
2261120	2272800	really cool, you know, really useful. And finally, I mean, I built, basically built an IDE, built the
2272800	2282880	code generator, the assembler for, for Intel, built an FFI based on kind of the, the API that
2282880	2290160	fonts used in the old version of, the old bad version of Allegro for Windows, which they,
2290960	2296160	they kind of spanked before when they, when they found out that I'd done it because they have a
2296160	2306880	better one, but, but it works. And, and release this around 2000. My, my son, when he was a
2306880	2311360	young, he was somewhat of an artist and he, he made this picture. I thought that, that was
2311360	2316560	appropriate, that sort of looked like, you know, my, I've been on the keyboard too long and my
2316560	2321760	fingers are kind of filed down to points and my hair is spikier than usual.
2331120	2336800	So when I, I'm about ready to like do a first release, and this is a single threaded lisp,
2336800	2342640	and, and Reiner Joswig, you know, is emailing me and going, you should do multiple threads. You
2342640	2346640	have to do multiple threads if you're coming out with a new lisp. And I immediately knew he was
2346640	2353280	right. Like, because I was already using threads in my C++ programs and stuff. And I said, yeah,
2353280	2359920	but all the lisp's I knew you were, were using lisp threads, you know, sort of cooperative threads
2359920	2364960	that you could start and stop easily and, you know, manage in the lisp system. It was really one big
2364960	2372080	thread by the operating system. And I think that was not, not right. I mean, I, I did, I knew enough
2372080	2376880	about working with threads at that point that I knew you had to use the OS threads. You had to
2376880	2382640	support that. Windows supports it very well. And, you know, the lisp threads had to be real OS threads
2382640	2389280	or, or was not competitive with something like C++. And that way, if you've got a multi-processor
2389280	2394080	machine, which are not too common back then, but coming along, you have parallel execution,
2394160	2400880	you know, real parallel execution. And that was awesome. I mean, I, I decided to do that.
2402000	2407440	And it changed practically everything. I mean, it really had to redo almost everything to add
2407440	2414640	thread support. But I may have been the first or one of the first to actually have, you know,
2414640	2420560	OS level thread, threading in common lisp. I hate without interrupts. That's one of those things
2420560	2424560	that you see in a lot of lisp code that uses these lisp threads. It's like always, oh, well,
2424560	2429760	my synchronization method is that I'm going to basically turn off all the other threads when
2429760	2435840	I change this variable. You know, and in, in, in Windows, in OS threads, you just can't do that.
2435840	2440240	You know, you can't just like arbitrarily keep switching threads on and off. You know, you've
2440240	2443600	got to send them a message or you've got to kill them or something, but they, they're running on
2443600	2450240	their own. You know, you don't have control, that kind of control. So I think CormidLisp has
2450320	2456160	a without interrupts in it, but it's kind of not probably really that good to use, not that safe or
2456160	2465440	efficient. Just to give you an example of all the things had to be changed to support threads,
2466080	2470880	special variable bindings. You know, I love special variables. I think they're an awesome
2470880	2478000	feature of lisp. I should add that to that list, that list actually. But according to the common lisp
2478080	2484480	spec, it, you know, the common lisp spec doesn't address threads. And, and if you read it
2485200	2492720	precisely, it even basically, you know, says that, you know, when you bind a variable,
2492720	2498160	it says all programs. It says all lisp programs will now see the new binding.
2499680	2504160	And, and that, I just realized that can't work. That can't work in a threaded system. Each thread
2504160	2509840	has to have its own bindings. And I, and I don't, I haven't looked into what other lisps do with
2509840	2515600	this, but I just implemented every thread has its own bindings. You know, I think that's the only
2515600	2520960	way to do it personally. But, but once you do it, it's like magic. It's like, once you do it now,
2520960	2528880	you can have local per thread global variables, special variables as easy as using let. I mean,
2528880	2535520	it's like, you use them, it makes writing thread safe code actually very easy. Just rebind the
2535520	2540960	variables using let to themselves or whatever, rebind them at the beginning of your thread.
2541520	2547200	And then you're good. You have your own copies that only your thread knows about. It's very efficient
2547200	2556640	and very easy. Heep design and access is affected. You know, you've got to make sure that you
2557600	2562960	different threads or any thread can trigger garbage collection, right? Could make a memory call,
2562960	2568320	triggers garbage collection. That means any other thread between any two instructions can,
2568960	2574160	can have the whole world swept away. That's how the code, that's how the code is. Eating any
2574160	2580160	two instructions, hardware instructions, the garbage collector can try to like. And when the
2580160	2584800	garbage collector runs, it moves everything and every address changes. Every function address
2584800	2592320	changes. The whole world changes. Stack updated, you know. So it's kind of hard to write code,
2592320	2597680	to generate code that's safe in that kind of an environment when that can happen at any moment.
2597680	2601360	And a lot of stuff had to be figured out to make that, make that work.
2603840	2609680	Foreign calls and callbacks. Threads make that more complicated. Your foreign libraries might
2609680	2617040	not support threads. Who knows? Code generation. Can you generate code in parallel on multiple
2617040	2621120	threads or should you? You know, they might be trying to update the same functions.
2622720	2629360	Debugging, of course. Multiple threads. Lisp image saving and loading. If you got a bunch of threads
2629360	2634880	running and you save the image, you know, are you going to try to restart all those processes when
2634960	2642160	you load the image? And, you know, thread can come in and call your list code that's not even a
2642160	2648960	thread you've seen before. It's like one that, you know, where that come from. Now you have to
2648960	2655040	initialize yourself with your list variable bindings or something. You have problems with
2655040	2661680	machine architectures that when you're doing a set that they, a simultaneous read can get a different
2661760	2669840	set of bytes out of the same variable. There's problems where that happens. Yeah, I can imagine.
2671840	2676160	And this is just a simple, or this is just an example of special variable binding
2678800	2686080	in Corman list. But, you know, if you've got, instead of just having a slot in a symbol that has the
2686160	2692720	global variable binding, really those have to be sort of compiled into a table. They're not on the
2692720	2698160	symbol anymore. They're in their own table. And you don't want to put every symbol in this table
2698880	2703120	because, you know, if you've got, you might have hundreds of thousands of symbols in your, in your
2703120	2709840	running system. And most of them, 90% of them, you're never going to rebind. So we only care
2709840	2714960	about the ones that you're going to bind dynamically. So the compiler and the runtime system needs to
2714960	2722320	maintain a symbol table that can grow that only has the variable bindings that you need.
2723600	2731520	And then every thread has to have its own copy of this table so that it can, you know, this thread
2731520	2738240	can have its own local bindings of those variables, whereas these are still referring to the global
2738240	2743920	bindings. So that, that's how Corman list dynamic variable binding works basically.
2753200	2759520	I like getting down and dirty in code. I like just like, as you could tell from what I've told you,
2759520	2767600	I mean, I like disassembling stuff. I like seeing how things work. I like if somebody has some new
2767600	2774000	API or some new DLLs or some library, I'd like to be able to just write some Lisp code that calls it.
2774960	2780560	And it's just really important to me to be able to do anything I could do in like C.
2782880	2789200	And so Lisp, Corman Lisp really brought out the sort of the low level
2790000	2795040	ability. The fact that it's only on Windows made this possible, right? If I was trying to support
2795040	2800400	a bunch of platforms, like say Franz does, I probably wouldn't have done this. But we,
2801200	2808960	I basically built a lot of different ways to call assembly language, extend the assembler,
2808960	2815520	you know, to make new operations, which generated code in different ways. A lot of like hacky kind
2815520	2821360	of things that you could do. So you could easily use it to use, deal with comm objects in, in,
2821920	2827520	the Windows world comms a big deal. These certain kind of a, you know, built-in object model in
2827520	2833440	Windows. Def Code Gen lets you define your own sort of code generators, almost like it's,
2833440	2842160	what a special form would be. And so here's an example of a, just a function, def ASM,
2842800	2850800	that's all written in assembler, but right in the Lisp file. And the curly braces are used to
2850800	2855920	designate an assembler block. And as you can see, it looks like, just like Intel assembler, basically,
2856720	2860720	other than the, you know, the macro, the args offset macro, and a couple things like that.
2862000	2865520	And if you want to mix assembler right into a Lisp function, you can do that too.
2866400	2873440	I use the double curly braces in that case. But that's just an example that, it's a normal Lisp
2873440	2878720	function, it does some Lisp stuff, and then it does some assembler. So you can probably imagine,
2879280	2881600	if you know what you're doing, you could do almost anything with this.
2885760	2892320	The assembler has macros. So this is how you define an assembly macro. This particular macro is
2893840	2901680	the call. It's the way that most Lisp functions get called through callf. And callf pushes a,
2901680	2906960	pushes the environment, you know, lexical environment on, it will actually puts it in the
2906960	2911360	DI register and then calls the function. So it's a,
2915680	2924000	and then we added a way to just basically take big chunks of C headers and bring them in, you know,
2924000	2930800	so that instead of having to, you know, write Lisp code to, to make the wrappers and bindings on
2930800	2935840	all of the C functions or the, you know, and this, this thing, it doesn't show it here, but it handles
2935840	2943920	structures and a lot of macros, defines lots of things. You could just bring direct.h files over
2943920	2949440	and it will, you know, pull them in and let you call the functions in Lisp. It's very easy.
2951280	2956880	So I think between all of those things, you know, it makes it easy to use it for, I can make a
2956880	2963760	Photoshop plugin out of, out of Cormand Lisp, you know, I could generate a DLL that, that could be
2963760	2975760	used as a plug-in. What's that? I haven't tried, but probably.
2980560	2985040	I don't know. We can talk about it.
2986000	2996880	I'll give a little quick demo here of Cormand Lisp running. Nothing too, you know, it's kind of hard
2996880	3004640	to show this kind of thing, but I have to stop my slideshow, otherwise you won't be able to see it.
3004640	3008720	Oh, what's Cormand, what's that complaining about?
3012000	3017280	Remind me later. When you have Windows, when you have a Windows running on a Mac,
3018000	3024480	it never stops trying to update stuff. You know, it's like, it just drives you crazy.
3024480	3036720	So, I'm going to put this down for a minute. It's not showing up over there. Oh, it's not.
3036720	3044800	Okay, so why did it not show up? Just a second. Let's go to displays. Let's say
3044800	3059920	arrangement, mirror displays. Okay, and it's showing up now, right? Okay.
3060800	3075680	Now, okay. I just made a program called Minds. I took a program that I found online that's kind
3075680	3082480	of interesting, and a lot of people have sort of ported it to different languages. It's called
3082480	3094720	Mind Sweepers, and so I just, for fun recently, ported it from C++ to Lisp, and we've got,
3095920	3098400	if you look in here, it's got some interesting
3101440	3107040	bunch of matrix math stuff that we carried over, and it's got neural nets.
3108000	3113680	The idea is these Mind Sweepers are really dumb when you first turn them on,
3114400	3120000	and then as they successfully find the minds, they get smarter. And then there's a genetic
3120000	3126880	algorithm in it, too, that sort of has a random bit pattern that allows it to, you combine those
3126880	3132960	between different successful Mind Sweepers and they create new ones. So, it combines neural net
3133040	3139920	and genetic algorithm, and it's kind of cool. So, I'm just going to execute this and run that in a
3139920	3162240	separate thread, th, create thread, and you see you've got these little guys.
3162960	3170160	I can change the size, and it'll start to put minds in the other part of the window.
3171360	3178720	They're really stupidly just going around randomly now. They're not going toward the minds,
3178720	3182880	particularly, but once in a while they accidentally get one, and they'll go through generations,
3182880	3187040	and you can go hundreds of generations, and after hundreds of generations, it will start to,
3188000	3192880	they'll start to be smarter. It seems like it takes too long to me. I think that the
3192880	3199280	algorithms could be tweaked to have them learn faster, but kind of interesting if we took,
3200080	3206160	if we wanted to just make some little dynamic changes. Let's see where we are.
3206480	3213280	I've got a couple of variables here. If we just take,
3215920	3220640	let's see, Sweeper Scale. I'll take like the Sweeper Scale for controlling the size,
3221360	3228480	and we just, we wanted to just make it a little bigger on the fly.
3229040	3242480	You see they got bigger. Do they have senses? They know where the closest mine is,
3244080	3248800	but what they're not programmed to do is go toward it. Like they have to learn how to go
3248800	3257040	toward it. You see a lot of them just like turning in circles, but just show you. I mean,
3257120	3261280	again, we've got fully compiled code, and we can modify it on the fly, and that's pretty cool,
3261280	3268160	and I can save it as an application. If I was developing a game, I think it'd be pretty nice,
3269200	3272160	pretty nice interactive development environment.
3277600	3284560	If we up at the top, you see the little animation Gen 0, Gen 1, that's the garbage collector.
3285360	3292080	It's mostly just Generation 0. It's just the ephemeral collector. It's got one generation
3292080	3298640	that keeps getting collected. Generation 1 fills up a lot slower, and then the main one,
3298640	3303200	you'll hardly notice it growing at all, because most of this stuff gets thrown away.
3303760	3318080	By the way, on the threads, each thread has its own heap, because otherwise we have to
3318080	3325120	synchronize around cons, and we don't like to do that. So cons is really fast, because each thread
3325120	3331680	gets its own sort of mini heap that it keeps refilling from the ephemeral thread, and so they
3331680	3336880	can allocate small things really quickly. If they allocate something too big, then they go,
3336880	3345920	then they have to synchronize. I'm having a hard time hearing.
3346240	3352160	Can a thread be handed a cons or anything else that belongs to another thread?
3355120	3366560	It can be handed a cons, yes. For example, if you didn't rebind a special variable,
3367680	3370960	those special variable bindings are shared by all the threads,
3371360	3379760	and so they're certainly sharing can occur. Since common list doesn't define what things,
3379760	3384560	like packages and hash tables, and stuff, it doesn't define whether those are thread safe,
3384560	3389520	because there's no concept of threads. I had to make a lot of just decisions about what to do.
3390160	3397200	I made hash tables synchronized so that threads couldn't share a hash table, and they wouldn't
3398160	3405520	have problems, but there's a little overhead there. Probably packages should be synchronized,
3405520	3410080	and I'm not sure if they are. There's more things that could be synchronized, but generally,
3410080	3417040	I think you all know you don't want to do that. Generally, we try to avoid sharing between threads,
3417040	3420560	and if you get an enclosure, they enforce that a lot better.
3420960	3438560	I don't have too much more anything interesting to demo there, but it's got some nice features
3438560	3445440	where you can, if I wanted to find the code or do anything, I get a little tool tip there,
3446080	3451360	and I can also right-click on it and look up the source. Since we include the source to everything,
3453040	3458880	you can always look up the source to every Lisp function. Here, I just looked up the source to
3458880	3468240	DefVar, just a macro. For me, I really like to be able to look up the source to all the Lisp
3468240	3473840	operators in any Lisp I use. You could disassemble it too, but with a macro, that would disassembly
3473840	3483040	wouldn't do you any good. Any questions on Corman Lisp?
3492480	3498240	I have a few more slides I could get to, but I know we've gone pretty long here, so I definitely
3498240	3527920	have gone. I agree with you on that. I certainly feel like Lisp is
3528320	3534960	so easy to modify and so easy to make it be whatever you want it to be. That's why I say it's a family
3534960	3540800	of languages. If it doesn't have a particular feature of another Lisp you like, and Corman Lisp,
3540800	3549120	especially Corman Lisp, is just easy to implement anything. I feel like Closure has a lot of nice
3549120	3555040	features, say, but I could implement those Closure features in Corman Lisp pretty easily,
3555120	3563200	I think. I know there are some parts of language that wouldn't be as easy, and the Java VM
3563200	3572640	interface, obviously. Two questions. In creating your own Lisp, did you make any innovations
3572640	3578400	around IDE in your own development environment, such as slide and standard stuff for your own thing?
3579040	3586080	Well, I built this IDE on the Windows Rich Text Edit, which is built into Windows,
3586720	3595360	so the text windows themselves are all rich text edits, which are calm objects, which Corman Lisp
3595360	3600880	then calls. When we see a lot of these editor features, those are all written in Lisp and running
3600880	3611200	in Lisp, the syntax, coloring, and stuff like that. Then it's a C++ Microsoft Foundation Class's
3611200	3621120	MFC framework. I'm not a very much of a UI programmer, and my UIs always suck. They're
3621120	3627440	not really beautiful, and that's not where I spend my time. There's nothing really fancy here,
3627440	3633280	and it looks outdated now. I would like to rewrite the whole editor in Lisp, and that would not be
3633280	3641920	hard to do, but it's like I needed this to build it. I needed something that it worked with nicely
3641920	3648160	to build it. When I started, I started with C++ editor.
3648240	3654640	And then the follow-up question, the same question about around the database,
3654640	3659840	what should you typically use for your software and stuff like that?
3661840	3665760	For the database? Did you make something like your own version of LEGO Cache,
3665760	3670720	or did you just make a connector to a relational database and just use that when you build applications?
3671600	3677280	I've tended to use SQL databases for most of my projects.
3679600	3684720	To me, SQL is kind of like Lisp. I mean, SQL relational database is kind of like Lisp in that
3685360	3693200	they started off really amazing and theoretical, but they sucked performance-wise,
3693760	3697520	and then people just kept putting more and more and more and more effort into them, and they got
3697520	3703040	better and better. And now you have these amazing relational databases, and you have these amazing
3703040	3709920	Lisp systems that so many man-hours and effort went into. And I think SQL database, you know,
3709920	3714320	they're kind of getting a bad rap now with everybody wanting to go to object databases,
3714320	3724960	and no SQL and whatever, but generally I'm still content with modern relational databases,
3724960	3729600	and that's what I've used. I'd like to do something with the LEGO Cache. I think that's an awesome system too.
3735760	3742560	I definitely recommend a LEGO Cache for any system where you didn't need SQL, you didn't want it.
3747200	3747680	Yeah.
3747680	3753360	So what's next? I mean, are you going to sort of just keep proliferating different kinds of
3753440	3755600	formulas? Are you going to do more DSLs?
3756400	3764320	Okay, so I might have an interesting slider to left, so I'm going to go ahead and restart this here.
3767840	3777520	I kind of stopped working on it. Well, I did stop working on it for a long time because I,
3777760	3784160	the recession hit and our business was, you know, I have a software company and sort of,
3784160	3790320	we've been an independent software company for 15 years, but it just, you know, all our clients
3790320	3796640	and contracts went away in 2008, 2009, 2010, and we were kind of hanging on for dear life,
3797360	3804160	and I just couldn't justify these, you know, nights and effort spent enhancing Corman Lisp,
3804240	3811920	which I knew was never going to be profitable. And, you know, we just, I just said, and I couldn't
3811920	3816320	keep, you know, and, you know, the certain amount of client support calls you get and stuff, I just,
3816320	3822800	so I just, I just stopped doing it. And, you know, a couple, you know, people started letting me know,
3822800	3827520	yeah, what's going on with Corman Lisp? And I would always say, well, it's on hold for now.
3827520	3834000	You know, I don't know. And, and that's kind of where it stayed for, for like six years until
3834000	3838960	Zach Bean came along and said, well, why don't you just open source it? So, you know, people,
3838960	3843440	other people can work on it. And I said, that sounds great because I'd rather other people
3843440	3849760	worked on it and it continued to evolve. I think the code's written well, you know, but on the
3849760	3855280	other hand, it's incredibly complex. And I always kind of wondered, could anybody else work on it?
3855280	3860560	You know, could anybody figure it out to like fix the bugs that come up in the garbage collector
3860560	3866400	or whatever? I can barely remember or figure some of that stuff out. But once I open sourced it,
3866400	3872640	it's an MIT license now. Zach did the work kind of like, you know, getting rid of the licensing
3872640	3881760	stuff that was in there and everything. And one Artem Boldarev, I think that's his name right,
3881760	3888640	he's a Ukrainian guy, a young guy. He, he's been taking, kind of taken over, done a lot of stuff
3888640	3896080	on it. And he fixed a really significant bug that I had with 64-bit windows. Like, like, mostly
3896080	3901280	every program out there that runs on 32-bit windows will run on 64-bit windows as a six,
3901280	3909040	as a 32-bit process. This was one that had some problems. And it turns out it has to do with
3909040	3918080	the thunking between the 34 and 60, the 32 and 64-bit layers. When you are calling out to a
3918080	3926080	OS call, it's actually always thunking the 64 bits and then coming back to 32 bits. And structured
3926080	3933200	exceptions don't propagate properly across that thunk. And we were relying on structured exceptions
3933280	3939040	to implement the right barrier that the, that the garbage collector use. You probably don't know
3939040	3943040	what a right barrier is, but that's something that has to do with the virtual memory system and
3943040	3949520	makes the garbage collector really fast. And that was like crashing when you were in a 64-bit
3949520	3956560	OS and you were doing, you know, FFI calls and callbacks, you know, and he tracked that down.
3956560	3962400	And I was very impressed. He tracked it down and figured out how to catch the exceptions and how to,
3962400	3968800	you know, repropagate them and got it working again, you know, in 64-bit. And so then I said,
3969840	3976160	okay, I want to work on it now. And I've been, I've kind of gotten back into it in the last,
3976160	3982240	in the last year. Having someone else to work on it with is really great. And of course,
3982240	3988400	that's the beauty of open source. You can find, I've got somebody from Ukraine. A lot of the work
3988400	3996640	was done by Vasily Baikov in the earlier days, who's Russian. And he did tons of, he did tons of
3996640	4004240	stuff in Common Lisp. And it kind of sounds like I'm colluding with the Russians, which I am.
4006000	4014000	But then basically since then, I've started to use Clojure. I like Common Lisp, but I'm,
4014560	4021280	I will, I'll never, as much as I love Lisp and I evangelize about it, I won't,
4022640	4026400	I won't promote it to a client if I don't think it's the right tool for the job.
4027280	4032400	And a lot of times I think Clojure is a better tool for the job these days. More,
4033840	4039200	more people are getting into it. The fact that it runs on the Java VM and can run everywhere.
4039680	4047040	The fact that it's simpler, it's a simpler language. The fact that it can run on the .NET,
4047040	4051600	which is a platform I've been heavily involved with, the .NET version of Clojure.
4053280	4058160	There's a lot to like about it. Macros are good enough for me, the way they did macros,
4058160	4064400	it's, you could do what you want with them. As we said, the S expressions are a little different,
4065200	4072000	everything's like, there's no dot pairs. You can't put whatever you want on the right side of a
4072000	4079680	con's call, which is kind of weird. Weird and good, depending on your perspective.
4087120	4091600	I've never really used Scheme very much, but I'm really interested in it.
4092400	4097280	And I don't know why, I just, I got into Common Lisp early and I just,
4098400	4104240	you know, but one of my favorite books in the world is Christian Kennecks Lisp in Small Pieces,
4105120	4110240	which if you've ever read, you know, he's a Scheme guy and he writes like 30 different
4111520	4117520	Scheme, Lisp and Scheme interpreters and compilers that he presents in this book. And it's,
4118240	4121120	for me, it was nice bedside reading.
4124880	4129920	So I'm building another version of my Arden syntax compiler, this one that I own,
4130960	4137120	using Clojure. And it was kind of neat because we could take, if you know how you build a compiler,
4137120	4144960	you have these Bacchus Naur forms. And I just took what you see in comments there is straight
4144960	4151600	out of the spec for Arden syntax, the BNF straight out of the spec. And then I sort of just
4151600	4157760	made the, you know, made a macro, a macro parse rule that takes the language as it shows up in
4157760	4163760	the spec and turns it into a code generator, a parser and a code generator. And the next
4163760	4170480	expression there is the generated code basically in Clojure. And so this parser actually works
4171200	4176720	just off of these. And it makes it, you know, pretty easy to write the parser and pretty easy
4176720	4181040	to update it. And if the spec changes, it's pretty easy to see when it diverges or when, you know,
4181040	4187600	where you have to change. It's slower than my hand coded C++ parser that I wrote before, but
4189440	4194720	I, you know, probably could still make it faster. But it was a nice project to do in Clojure. And
4194800	4199840	I've liked it for that. I could do it in Common Lisp too. It would probably be even, you know,
4199840	4204800	could probably have written it more easily. But again, I wanted to run a .NET. And
4208720	4212160	so if I said what I like about Clojure, all those things that I liked about Lisp,
4213600	4219520	S expressions, consing engine, macros, garbage collection, functional paradigm, not so much on
4219520	4227360	the object oriented paradigm or the procedural, the fact that it has such a user base and very
4227360	4237280	good implementation and runs on practically every platform. I say, I think all Lisp languages are
4237280	4244960	Lisp family. They're all part of the same family. And to me, if I love one, I love them all. And I
4245840	4252000	with macros, I could make Clojure do what I want. I'm sure of that. It does take some getting used
4252000	4259600	to not being able to mutate variables, getting rid of set Q basically. And you could get around it
4259600	4265360	by just creating a single cell Java arrays and using those for your mutatable variables that
4265360	4270480	can be shared. You know, if you have to, it's pretty easy to get around. So it's not like,
4271120	4274880	but of course, it's kind of ugly. The whole Java interface part of it's,
4275600	4279280	you know, it's, you have to use it too many places, I think. But
4283600	4288480	and the last thing I had here, I was going to mention is I'm getting into continuations now,
4288480	4293280	which I never did. You know, all these years of doing common Lisp, I never used continuations.
4294240	4298640	And I, all I thought was like, I'd never wanted to try to implement them because it seemed too
4298640	4305440	hard or too inefficient to be saving and restoring the stack all the time. And so
4306640	4312160	now I have a language I'm implementing and this uses fuzzy logic new version of Arden 2.9.
4312960	4318320	And the control flow is fuzzy. So if you have an if statement and the condition is
4319680	4328080	somewhere between true and false, it splits into two paths of execution. And so this kind of an
4328080	4335200	execution model requires backtracking and something that continuations can do. And I don't know what
4335200	4343520	else could, you know, and the only other alternative that I've come up with is to do in continuations
4343520	4350160	is to use continuation passing style, you know, where you, every function gets a continuation
4350160	4355840	passed in and returns a continuation. And then you use a trampoline, which is just a little loop
4355840	4361040	that just keeps calls, gets a continuation back, calls that continuation back, gets a
4361040	4365840	continuation back. In the end, you have no stack. So your continuations don't have to worry about
4365840	4371920	saving and restoring the stack. I mean, you, you, you avoid that problem, which is what's hard about
4371920	4377040	continuations, saving and restoring the stack. And you cannot do them on the, you cannot do that on
4377040	4381920	Java VM or CLR to my knowledge. It doesn't, doesn't support that.
4382880	4391360	Have you considered rewriting some of those algorithms and say using a star or some other
4392240	4399840	form other than continuation? You know, I don't know exactly the details of the problem you're
4399840	4405120	trying to solve, but maybe you're out with the wrong algorithm. Yeah, and I bet you, you could
4405120	4409920	help me with that. It's actually one of the first problems I've ever bumped into that I didn't,
4410720	4414640	you know, I still haven't solved. I mean, it was very, I'm having a tough time with it.
4415600	4426160	So I'm open to suggestions and advice. Okay, so I know all of you have like great stories about
4426160	4432160	what you've done with Lisp. And I'd love to know more about them. And I'm really, really happy. I
4432160	4438400	got to be the one up here today, talking about my story, not that it's any better than anybody else's
4438400	4444240	story. But I'm thankful that I had the chance because normally I never find anybody that wants to
4444240	4450800	talk about this stuff or hear about it, right? In my regular life, right? So getting to meet,
4450800	4457360	you know, be with this many Lisp programmers at once is, is really unusual and just great for me.
4458080	4463760	So thanks a lot. And I hope you've learned something, something of value tonight.
4463760	4471620	Thank you.
