WEBVTT

00:00.000 --> 00:09.560
When I was a kid, I believed in Santa Claus, I believed in magic, I believed magicians

00:09.560 --> 00:14.400
were really doing magic when they were on stage, and I believed in the Easter Bunny

00:14.400 --> 00:17.920
and all those magical things.

00:17.920 --> 00:26.960
And when I learned Little Older, like, probably I'll have a similar story, there was no magic,

00:26.960 --> 00:34.160
and it was kind of sad, and some years later, I feel like the magic came back.

00:34.160 --> 00:41.440
And to me, tech, you know, the internet, I mean, it's so far beyond anything I could

00:41.440 --> 00:47.480
have imagined and considered magical, you know, and I always talk about magic when I

00:47.480 --> 00:55.120
talk about tech stuff, because to me I'm still in awe, and it's just amazing to the

00:55.120 --> 01:00.240
more you learn, the more you're in awe of all of these things.

01:00.240 --> 01:08.920
And I've been fascinated with Lisp machines, you know, ever since I got into programming.

01:08.920 --> 01:14.640
It's just really great to be here today, I'm so glad to have been asked, and that you've

01:14.640 --> 01:18.880
got such a great group and all these Lisp people here.

01:18.880 --> 01:25.720
I certainly have always felt that the Lisp programmers that I know, the people that are

01:25.720 --> 01:29.840
in the Lisp are the most brilliant software engineers.

01:29.840 --> 01:35.400
I think you know what I'm talking about, it's like people that really are creative, understand

01:35.400 --> 01:41.520
a lot of things, and it's so just awesome to be here with all of you, to meet a lot

01:41.520 --> 01:45.200
of you tonight.

01:45.200 --> 01:55.000
So I spent a lot of years, thirty-five years now, programming Lisp, programming Lisp systems,

01:55.000 --> 02:00.600
and in talking, working out what I was going to talk about, sounded like there was some

02:00.600 --> 02:06.560
interest in, you know, how Cormin Lisp got built and why, and so I'm going to get into

02:06.560 --> 02:12.840
that some, but I also built two other Lisp's, and I think that it's kind of interesting

02:12.840 --> 02:17.800
to talk about that, and I also want to talk a little bit about some projects that I've

02:17.800 --> 02:22.600
done and am working on now, and I didn't really know how to put all that together other than

02:22.600 --> 02:28.480
in a sort of a chronological thing, so I don't want it to be like a scrapbook or something,

02:28.480 --> 02:34.000
I mean I want it, hopefully there's some kind of message you get out of here, and I'm not

02:34.000 --> 02:38.160
just preaching to the choir because I do start to evangelize about Lisp, and I know there's

02:38.160 --> 02:52.280
not a need for that here, but anyway, I will start with where I started, a few things we'll

02:52.280 --> 03:01.160
touch on, why did I develop three Lisp's, I learned Lisp from a musician through essentially

03:01.200 --> 03:09.640
correspondence, of course through the mail, kind of weird, Franz kind of convinced me to

03:09.640 --> 03:15.160
create my own Lisp, and then I think they regretted it later, so this is kind of interesting,

03:15.160 --> 03:22.040
I like Cormin Lisp, what I would say is great about it is I think it's great for hacking,

03:22.360 --> 03:32.280
hacking in the good sense, the white hat sense, I'm interested in other Lisp's, lots of Lisp's

03:32.280 --> 03:40.720
to me, the fact that there's like so many Lisp's, closure and scheme, and whatever Lisp's that are

03:40.720 --> 03:47.160
non-conformant, and ones that people are inventing, to me that's a feature, not a bug, I mean what

03:47.160 --> 03:53.440
other language can you say this about, you know where you could just say a name, a simple name

03:53.440 --> 03:58.720
that describes a whole bunch of languages, and everybody pretty much agrees that they all are

03:58.720 --> 04:07.240
part of that family, and why is the current project I'm working on using a trampoline,

04:07.240 --> 04:16.360
I might get to that if I make it through the slides, so before I got into computing,

04:17.000 --> 04:25.560
I was a musician, a jazz pianist, and I still play, I still do gigs, managed to keep that up over

04:25.560 --> 04:31.720
the years, mostly that was while I was in college that I was doing it professionally, but I was

04:31.720 --> 04:42.440
studying music and computer science at Sonoma State, and computer science classes, I started in

04:42.520 --> 04:49.920
with that and learning Pascal, and it was fun, it was easy, but nothing exciting about it, and my

04:49.920 --> 05:00.840
music professor, Arthur Hills, took a year off, he's an organist and into medieval music, he

05:00.880 --> 05:10.760
took a year off to go study Lisb, and for a sabbatical, and write a Gregorian chant generator,

05:10.760 --> 05:18.720
that's what he did for a year, right, and so he kind of got back in touch, during that year he

05:18.720 --> 05:22.920
got in touch with the people in the music department, and said Sonoma State, and all the other

05:22.920 --> 05:26.960
professors, and said, oh this is great, you got to learn this new language, you got to learn

05:27.000 --> 05:34.240
computer programming, this is in 1981, 1982, and none of them, including him, had done anything with

05:34.240 --> 05:40.000
computers, and he asked me, I wasn't a teacher, but he asked me, because I was a student, a computer

05:40.000 --> 05:52.040
student too, so, I mean yeah, okay, and you know, we started programming on the cyber, it's like a

05:52.080 --> 05:58.080
supercomputer that Sonoma State had, I mean it's designed by Cray, but at very weird architecture

05:58.080 --> 06:04.520
with six-bit bytes, and 60-bit word lengths, and it took two bytes to store a lowercase character,

06:04.520 --> 06:13.560
and one byte to store an uppercase character, and so Art, since he lived, was living in San

06:13.600 --> 06:21.040
Francisco, he would, basically it came down to mostly me and him, he would start to send me

06:21.040 --> 06:29.960
letters, and he would write out longhand these letters about Lisp functions, you know, some code

06:29.960 --> 06:35.520
he was working on with his Gregorian chant generator, or some new, you know, new feature that he

06:35.520 --> 06:41.080
learned, that he wanted to share with me, and sometimes he would take a tractor feed print

06:41.080 --> 06:45.360
out, you know, they're really wide, and fold it all up, and stuff it in the envelope, along with a

06:45.360 --> 06:51.000
handwritten, or typed on his typewriter with lots of corrections, and so this is an example, this

06:51.000 --> 06:58.200
was a postcard, he'd send, hi Roger, I've already conceived improvements of my own, I haven't tried

06:58.200 --> 07:03.400
these yet, but surely they'll work for A-mean, and G-mean, and here's all this code, and after the

07:03.400 --> 07:09.000
last parenthesis, he even signs his name, Arthur, down in the corner, in case I don't know who's

07:09.040 --> 07:15.560
sending me this Lisp code, right, and if you look at the postmarket, it's hard to read, but it's July

07:15.560 --> 07:23.600
17th, 1982, which just about 35 years ago today, so I think that proves I've been using Lisp for that

07:23.600 --> 07:35.800
long, so we, this was basically Lisp 1.5 back in those days, and I just couldn't not believe how

07:35.840 --> 07:44.520
magical it was, how amazing it was to do symbolic computation, and no numbers, you know, I think

07:44.520 --> 07:50.440
worked with Pascal, and with C, you know, everything's a number really, and your C program, your

07:50.440 --> 07:55.920
characters are numbers, and you know, functions are really, you know, addresses, and addresses are

07:55.920 --> 08:00.160
numbers, and you know, just across the board, and you know that, and you have to know that,

08:00.200 --> 08:06.920
and you have to understand to work with it back then, but in Lisp, God, I wrote lots of programs

08:06.920 --> 08:12.880
with no numbers, just lots of lists, and random selections, and application, and I made my own

08:12.880 --> 08:20.000
rules engine, and I worked on a rules engine to do something more original, like it generated

08:20.160 --> 08:25.600
jazz compositions. Okay, Arthur was doing Gregorian chants, I was doing jazz compositions,

08:29.360 --> 08:36.480
but this machine that was like a supercomputer was so fast, it would compile, you know, 5,000 line

08:36.480 --> 08:43.280
Pascal program in a second, you know, and run everything so quickly, my jazz composer generator

08:44.000 --> 08:48.320
would just bring the thing to its knees, you know, it would be like, it would sit there for 30 seconds,

08:48.320 --> 08:52.000
and the other people in the computer lab are complaining that the computer's frozen, and

08:52.000 --> 08:58.480
finally it would time out, and it was working, it's just that it was, I was doing, you know,

08:58.480 --> 09:03.200
multiple levels of recursion and all kinds of stuff that were very inefficient, it was my

09:03.200 --> 09:08.960
own algorithms, my own fault, wasn't the computer's fault, but that got me like, well, how does this

09:08.960 --> 09:15.600
work, you know, disassembling the code, and looking at how, you know, and I found out that like

09:15.680 --> 09:20.800
car and cutter were like two instructions or something on that machine, I mean, it was amazing,

09:21.360 --> 09:23.760
it was amazingly efficient when you started looking at it.

09:29.600 --> 09:36.320
After college, I went to work on microcomputers, 8-bit, 16-bit, very little memory,

09:38.000 --> 09:42.800
I just assumed there was no way you could use lisp on those, after my experience with the

09:42.800 --> 09:50.320
performance thing, I said, okay, you know, I mean, we can use basic or fourth or C, but there was no

09:50.320 --> 09:57.840
way a lisp could possibly run on 64k, but it wasn't entirely true, and after, you know, a couple

09:57.840 --> 10:03.360
years, I started writing my own little lisp interpreters, and using them as scripting languages

10:03.360 --> 10:12.480
inside my C programs, just as AutoCAD or Emacs uses lisp for scripting, and today we would say,

10:12.480 --> 10:17.680
you know, you could use it as for automated testing, and, you know, macros and things like

10:17.680 --> 10:22.560
that, lisp was good for that, and so I started putting them into lots of my, you know, I was doing

10:22.560 --> 10:29.280
computer graphics applications, and so that was useful, and they didn't have to be big,

10:29.280 --> 10:33.920
they just had to be big enough to sort of run the different functions of the application

10:33.920 --> 10:39.840
that they were embedded in, but that's how I learned about how you implement a simple lisp,

10:39.840 --> 10:43.760
I mean, lisp is simple, right, it is simple to make a lisp interpreter.

10:48.400 --> 10:53.120
I didn't really understand how garbage collection worked, that was kind of the hardest part of it,

10:53.120 --> 10:58.320
if you've ever written a garbage collection collector, you know, it's like, that's not so easy,

10:58.880 --> 11:03.760
you got to deal with registers and stacks and all kinds of low level things,

11:03.760 --> 11:15.600
but anyway, that was kind of my first exposure, first use of lisp on, on PCs, and when I moved to

11:15.600 --> 11:23.600
the Mac, fortunately, because the Mac had more memory and was more powerful around that time,

11:23.600 --> 11:32.160
around 1990, I actually saw Mac common lisp in action, and some of you, I'm sure, know Mac common

11:32.720 --> 11:39.120
lisp, coral common lisp, now it's called closure with a Z, and it was an amazing

11:39.760 --> 11:47.360
kind of experience, and it kind of made me realize, wow, lisp could be really, really fast,

11:48.000 --> 11:54.720
I mean, honestly, it seemed like it was as fast as C, and how does that work?

11:55.680 --> 12:01.520
And I would start, you know, read all of their documentation, and like trying to figure out how,

12:01.520 --> 12:04.720
how could, is it, is it really doing what it seems like it's doing?

12:06.720 --> 12:14.080
And it cost $500, and I didn't have $500 to spend on, you know, on a license, since it was more of

12:14.640 --> 12:18.880
less a hobby, at that point, I didn't have a job doing lisp programming,

12:19.840 --> 12:25.920
so I ported over my PC code, and started running that on a Mac, and then started adding all the

12:25.920 --> 12:32.880
common lisp features, because I like the common lisp spec better than the lisp 1.5 spec that I've

12:32.880 --> 12:42.560
been working with, and Mac was big enough to support it, and I ended up developing a pretty

12:42.560 --> 12:51.600
full common lisp, and adding class, and adding, you know, loop, and an editor that was built from

12:51.600 --> 12:57.680
scratch, because we didn't have like, you couldn't just like, take modules, and programs that other

12:57.680 --> 13:01.120
people had written the way you can today, you know, it's like, if you want an editor, basically,

13:01.120 --> 13:08.160
you're going to write it yourself. MarketSweep Collector, had a full 80, 68k,

13:08.480 --> 13:15.520
compiler, code generator, assembler, disassembler, spent years on this,

13:16.640 --> 13:26.080
and it was a lot of fun, release it as shareware, and a lot of people use it, AOL in those days,

13:26.080 --> 13:34.160
we distributed it on AOL, because we didn't have the web yet, and Apple picked it up, and put it

13:34.160 --> 13:39.920
on their developer disk, which was nice, so every month it got sent out to all the Apple developers,

13:41.520 --> 13:49.280
a little notoriety from that. It still didn't begin to compete with Mac common lisp, and speed,

13:49.280 --> 13:52.960
it was cheaper, but it was not anywhere near as fast.

13:53.120 --> 14:05.120
So here it is, running on a PowerBook 170, this is what I developed it, I called it PowerLisp,

14:05.120 --> 14:11.600
because it was developed on a PowerBook, and lest you think this is like an old picture,

14:11.600 --> 14:16.880
I took this two days ago in my office, because that machine still runs, it's a

14:17.600 --> 14:25.360
26 year old machine, and I have to sort of plop it on the table top to get the hard drive to

14:25.360 --> 14:29.520
spin up, I have to sort of knock it around a little bit, but then it gets going and it's pretty good,

14:30.960 --> 14:38.160
surprising what it does, and you can see I got the little disassembly there,

14:38.240 --> 14:48.880
and PowerPC came out, and I redid it for PowerPC, and got into risk architecture,

14:48.880 --> 14:54.000
and learned how all that instruction set, and how arguments are passed, and that was very different,

14:55.440 --> 15:00.880
but you sort of had to do that, if you're on Apple in those days, you had to rewrite your stuff for

15:00.880 --> 15:09.600
PowerPC, and did that, released fat versions of it, fat version meant it would run on PowerPC,

15:09.600 --> 15:18.960
or 68000 max. Questions are fine. How much of the code was actually a assembler versus everything

15:18.960 --> 15:25.200
that you could write on top of it, you were writing a common list, right? So there was a basic,

15:25.440 --> 15:37.360
there was very little assembler in this, mostly a C++ kernel, and then like the compiler, and the

15:37.360 --> 15:45.600
assembler, and all these other parts were all written in Lisp, so mostly Lisp after the kernel,

15:45.600 --> 15:51.920
but it had quite a lot in C++, and I didn't like that, and when I came along later and did another

15:51.920 --> 16:01.440
one, I got rid of most of that, and recoded stuff in Lisp, so kind of a diversion from that path.

16:02.240 --> 16:10.160
Now, I've never really been able to develop Lisp systems for my main job, right? It's always been

16:10.160 --> 16:16.880
kind of a sideline, kind of a hobby. I always had to make money, and there's not that much money,

16:16.880 --> 16:26.480
and that's, I just kept doing it in my evenings, you know, long nights, and at one point I got an

16:26.480 --> 16:36.560
opportunity to build a decision support system for hospital software, which was pretty cool. It was

16:36.560 --> 16:43.520
kind of an AI thing, kind of an expert system to alert physicians to medical problems, and to run

16:43.520 --> 16:49.360
rules that were written in this language called Arden syntax, which is a standard for medical rules,

16:49.360 --> 16:58.880
medical logic, and so I, because I wrote compilers, I got the job, and immediately, you know,

16:58.880 --> 17:06.640
had to build something quickly, and the spec for this language, Arden, was basically, you know,

17:06.640 --> 17:11.760
weakly typed, you know, dynamic typing, it needed garbage collection, it needed a lot of features,

17:12.240 --> 17:18.160
no way I was just going to write this in C, you know, and generate code in C. It just would have

17:18.160 --> 17:24.240
been very inefficient, you know, and you wanted to be able to load rules on the fly, update rules

17:24.240 --> 17:28.960
on the fly, you know, all this stuff, but I thought it would be simple to do this in Lisp, you know,

17:28.960 --> 17:34.800
I could easily generate a Lisp function from these rules, and then those Lisp functions would all

17:34.800 --> 17:39.600
run, and I'd have all the features I needed, and that turned out to have been a very good decision,

17:39.600 --> 17:48.720
so then the problem was, this was back in the mid-90s, companies didn't want you to use any

17:48.720 --> 17:54.560
other language in C++ in those days, it was like the company I was working with at the time just

17:54.560 --> 17:59.200
was like, no, everything's C++, that's just the way it's going to be, you know, there was this idea

17:59.200 --> 18:02.960
that someday everybody was going to be using the same language, that all programming languages

18:02.960 --> 18:08.880
were going to converge, which seems ludicrous today, but that was a thought for a long time,

18:09.920 --> 18:16.560
and so I kind of snuck it in, I just sort of like brought over my code from the Mac,

18:17.360 --> 18:22.560
my Lisp system from the Mac, translated it back to Windows, stripped out a bunch of stuff I didn't

18:22.560 --> 18:35.680
need, and embedded it into the code and said, it's C++, it's all C++, right, and truly that system,

18:35.680 --> 18:43.360
that Arden compiler and everything was mostly written in C++, but the rules all get generated,

18:43.360 --> 18:50.240
all get translated into Lisp, and all get run as Lisp functions, and this system's been very

18:50.240 --> 18:57.120
successful, I can't tell you how successful it's been, and it's definitely the most successful

18:57.120 --> 19:06.640
thing I've worked on. It's still in the top two or three US hospital systems and used today,

19:07.840 --> 19:13.520
I know what it's doing and how it's being used, and we kept expanding it and expanding it to be

19:13.520 --> 19:19.440
used basically as a scripting language for the whole system, so rules don't just alert physicians,

19:19.440 --> 19:24.720
but rules actually fill out forms, you know, look up data in the database and fill out default

19:24.720 --> 19:30.720
values or, you know, prompt the user, there's all kinds of things they do, and I've had the

19:30.720 --> 19:36.800
luck to be sort of work on it over the years and maintaining it, and I've also built a system that

19:36.800 --> 19:44.720
monitors the use of this system in hospitals and logs it, and in one hospital alone, millions of

19:44.720 --> 19:48.800
rules a day are triggered, you know, millions of these Lisp functions a day are triggered,

19:48.800 --> 19:52.960
every single thing that goes into every single patient record goes through all these rules,

19:53.120 --> 19:59.920
and that's the reason that that system is still around 20 years later, because it's getting kind

19:59.920 --> 20:06.800
of, you know, archaic in terms of its age, but it's, we did port it to .NET at one point, so it's

20:06.800 --> 20:16.480
no longer, so it's no longer native code. This is a screenshot of the editor for that system

20:16.480 --> 20:21.120
that's still in use today, it looks old, you know, the user interface looks old because it is,

20:21.840 --> 20:28.240
but it's, if you can see off on the bottom part on the left, there's part of a rule here, there's

20:28.240 --> 20:35.840
not much showing, but the function definition actually shows on that panel on the right,

20:36.400 --> 20:42.000
and you can see that there's a lambda definition, so that's the Lisp code that got generated from

20:42.000 --> 20:50.080
that rule, and this isn't documented and nobody really knows this there, so, but thousands of

20:50.080 --> 20:56.320
users are writing these rules, and the fact that Lisp is in there is completely unknown, most of them.

20:57.680 --> 21:02.240
In fact, if you went to the next tab over the execute tab, there's a repel, there's a hidden

21:02.240 --> 21:07.440
repel, and so I could go in there and like just start executing all kinds of lists, nobody even

21:07.440 --> 21:19.360
knows it's there, right, so it's just kind of interesting. This is just some of the hospitals

21:19.360 --> 21:24.160
that it's running in, New York Presbyterian, Columbia University Cornell, Johns Hopkins,

21:24.160 --> 21:29.840
Cleveland Clinic, Memorial Sloan Kettering, Cancer, National Institute of Health, I mean,

21:30.640 --> 21:34.960
that's just the beginning, but it's, you could tell it's, these are big places, so it's,

21:36.080 --> 21:38.720
you know, we've got Lisp running in those things, and I think that's cool.

21:39.680 --> 21:50.000
There, all scripts has been high on the list of hospitals, software that actually get used by

21:50.000 --> 21:58.000
physicians, as what this is, what CPOE is, physician order entry, or care provider order entry,

21:58.960 --> 22:00.320
so it's been very successful.

22:04.000 --> 22:06.400
Any, any questions, any questions before I move on?

22:07.360 --> 22:10.800
What I'm doing on time? How long am I supposed to talk?

22:13.600 --> 22:19.440
Okay, I'll just, I'll just keep going. I just want to, I probably won't get through all my slides,

22:19.440 --> 22:30.400
but around 1996, I'd say Fritz Kunze, who was the CEO of Franz, makers of Allegro Common Lisp,

22:30.400 --> 22:37.920
contacted me and said, well, why don't you come, come meet me, and you know, in our office,

22:37.920 --> 22:42.400
I have something I want to ask you about, and I, that was great. I got to go down to Franz,

22:42.400 --> 22:49.440
to their office, and, and talk, and what they wanted me to do was pour Allegro Common Lisp to Mac,

22:50.480 --> 22:56.080
because they decided they needed a Mac version, and I'd written a Mac version of Lisp, so I was

22:56.080 --> 23:02.640
a good candidate for that. And so I made them some kind of a bid, like six months or something, you

23:02.640 --> 23:07.840
know, I, no idea how long it was really going to take, but, and, and they never took me up on it,

23:07.840 --> 23:14.560
I think they thought it was too expensive. I don't know, but in the process, they gave me a copy of,

23:15.120 --> 23:21.440
of Allegro Common Lisp for Windows, and it was a big box with a ton of manuals and cost a thousand

23:21.440 --> 23:28.320
dollars, like no way I could ever afford to buy that for myself. Again, you know, unless I was

23:28.320 --> 23:34.080
professional, you know, for professional purpose, but I was very happy, they just gave it to me,

23:34.800 --> 23:43.440
and, and I, I love all the people at Franz are awesome, but when I played with it, this was,

23:43.440 --> 23:51.120
it was crazy, it was like 16-bit fixnums, which was, I think, a holdover from DOS,

23:51.840 --> 23:57.200
you know, and, and this was, this was, you know, Windows 95 was out and Windows NT, and they had

23:57.200 --> 24:02.800
preemptive multi-threading and tons of memory, all these features, and here they were marketing this

24:02.800 --> 24:09.920
system that 16-bit fixnums and eight character limit on filenames, I mean, they were like way

24:09.920 --> 24:16.080
behind the times, and they knew that, I mean, they were like, yeah, well, they had bought it from

24:16.080 --> 24:25.600
some other company, so that they'd have a Windows version, but okay, that, anyway, that was the

24:25.600 --> 24:30.640
state of that, and I, and I was kind of like, well, why don't you guys have your main system

24:30.640 --> 24:35.280
running on it, and they, well, we don't really think Windows is a serious platform, you know,

24:35.280 --> 24:39.760
we've got Unix, you know, our Unix systems is what all the people are really seriously using, and

24:41.360 --> 24:46.240
the Mac one will just be kind of like, you know, we'll see if anybody wants it, but Windows was

24:46.240 --> 24:52.480
not of interest, and then I started going around and going, well, what LISPs are running on Windows,

24:53.040 --> 24:58.480
because at that point in the late 90s, it looked like Windows was the platform, I mean, Windows was

24:58.480 --> 25:03.360
taken off like crazy, and it really was powerful, it was at that point, it got a lot better than the

25:03.360 --> 25:13.840
Mac for some years before OS X, and so LispWorks wasn't running on Windows, they'd see Lisp,

25:13.840 --> 25:18.080
but that was kind of just a port of, you know, something, you know, bytecode compiler,

25:18.960 --> 25:25.600
and it was like, you know, there's a market for here for like a serious Lisp on Windows.

25:26.080 --> 25:34.240
I remember Gold Hill, but I don't think that it got, I think it might have been on

25:34.240 --> 25:44.720
like Windows 3, but not on like Windows 90, I mean, it could have been that that still existed,

25:44.720 --> 25:50.000
I never played with it. In any case, it looked at me like there was a big opportunity for a good

25:50.000 --> 25:57.440
Lisp, so that was when I just decided to get serious and do something like as good as trying

25:57.440 --> 26:03.840
to do something as good as Mac common Lisp in terms of performance, and it had to be a complete

26:03.840 --> 26:09.120
rewrite because I was never going to be able to do it with the code that I built already,

26:10.000 --> 26:16.960
and I knew it needed like a good garbage collector, like a generational garbage collector with

26:17.040 --> 26:24.560
taking advantage of real, you know, hardware virtual memory and, you know, fully tagged.

26:32.240 --> 26:38.400
I kind of modeled it on, in all ways, pretty on what I'd read in Mac common Lisp's

26:39.200 --> 26:46.240
manuals, which are extensive and very enlightening, and again, you know, it wasn't that easy to find

26:46.240 --> 26:52.320
stuff like this, like finding stuff about garbage collectors had been impossible in the 80s, and

26:52.320 --> 26:59.120
in the 90s, it was possible, but mostly it was just some papers that like Henry Baker had written,

26:59.120 --> 27:06.240
like you could find a few papers here and there, but figuring out how to build some of this, and I

27:06.240 --> 27:13.360
wanted to do stew 100% compiled, native compiled, with no interpreter, because actually that's one

27:13.360 --> 27:21.040
of the things I hate about common Lisp is the interpreter slash compiled dual execution path.

27:24.560 --> 27:30.960
So, to step back, everybody's got their own ideas, what they like, and I'd say my favorite things

27:31.520 --> 27:37.920
about Lisp, these are the things I think that make Lisp amazing.

27:38.880 --> 27:45.520
S expressions, is there still not another language that has anything like S expressions,

27:45.520 --> 27:48.320
you know, where the code and the data are the same format?

27:50.560 --> 27:56.720
XSLT, okay, yeah, not as elegant, but okay, yeah.

27:57.520 --> 28:07.600
The Kanzing engine, by Kanzing engine, I mean generates Kanza's fast, doesn't, you know,

28:07.600 --> 28:13.680
you've got a garbage collector to match, it's like every other language can't compete with

28:13.680 --> 28:21.440
a good Lisp in terms of like allocating heap stuff, little heap objects. I found Java VMs,

28:21.440 --> 28:27.600
usually orders of magnitude slower at generating tons of little things, and so the fact that a

28:27.600 --> 28:33.600
Lisp can like generate Kanza's, you know, these eight byte or 16 byte little pieces or small,

28:34.800 --> 28:39.840
you know, tag floats or whatever, can generate those, you know, generate the heap for those and

28:39.840 --> 28:47.760
then clean them up when you throw them away, you know, really fast is a really key element of Lisp

28:47.760 --> 28:54.000
to me, and the fact that you could build any data structure out of Kanza's is great.

28:58.720 --> 29:05.600
I know, I know, yeah, yeah, that's one of the things I don't like about Closure, I guess I'd say,

29:06.480 --> 29:16.160
but macros, well, I've said I guess there's been so many great stuff written about macros and so

29:16.240 --> 29:22.640
many great macros written. Everybody's got garbage collection these days, that's not such a big deal

29:22.640 --> 29:32.160
anymore, but a really efficient one, as I said, for getting rid of tons of, tons of, people worry

29:32.160 --> 29:37.280
about, people were always worrying about Kanzing, you know, when Lisp people were writing, oh, don't

29:37.280 --> 29:44.240
do this, it'll generate too much Kanza, well a good garbage collector is, you know, the amount

29:44.320 --> 29:47.920
of time it takes is relative to the amount of live stuff that you're keeping around,

29:49.040 --> 29:54.880
if it's written right, it's not based on how much stuff you're throwing away, in fact, the one I

29:54.880 --> 30:01.120
wrote takes zero time to throw away, to delete something, I mean, it's all it does is pick up

30:01.120 --> 30:07.280
the live objects and defragment them and move them to a different heap, and zero time is spent,

30:07.280 --> 30:13.840
you know, deleting the dead objects, so you could generate millions of Kanza's and not worry about

30:13.840 --> 30:21.040
garbage collection times, and I really like the multi-paradigm aspects of common Lisp anyway,

30:21.840 --> 30:28.000
you can get, you know, objects if you want, object-oriented paradigms, there it's great,

30:28.000 --> 30:32.880
it's like one of the best, but you don't have to use them, you can use functional, you can use

30:33.600 --> 30:39.840
just simple, you know, procedural programming, works great, whatever you want to do, declarative,

30:39.840 --> 30:45.920
you could make your domain-specific language, just a lot of different, I love that, you know,

30:45.920 --> 30:50.080
I just love not being constricted and having that flexibility.

30:57.280 --> 31:02.400
Some things I don't like about common Lisp, and I'm bringing these up because if you ever used

31:02.400 --> 31:10.320
my system, you'll notice, you'll probably notice, but I don't like the interpreted compile or

31:10.320 --> 31:17.040
compiled model, oh, I'm a Lisp programmer and I write a function, oh, and I run it, oh, well,

31:17.040 --> 31:21.520
but it's not as fast as it should be, oh, well, that's because I didn't compile it, okay, I compile

31:21.520 --> 31:26.480
it, now it does the same thing, but faster, well, why didn't it compile it in the first place,

31:26.480 --> 31:29.840
I didn't get the, oh, because then you wouldn't be able to step through it or something, you wouldn't

31:29.840 --> 31:35.920
mail the trace, you know, to me, that's just crazy, you know, all the common Lisp, all any

31:35.920 --> 31:41.600
language should do is it should make your program run as best it can, you know, when you enter it.

31:42.480 --> 31:42.960
Yeah.

31:55.440 --> 32:02.960
And don't have an interpreter? I don't know why you say that because Frans doesn't do, I mean,

32:02.960 --> 32:08.640
Frans, Allegro interprets and compiles, I mean, I spent three years working with that recently.

32:12.320 --> 32:15.040
You could change the default?

32:32.160 --> 32:36.480
All right, I'm glad you told me that, so I'll remember that next time I'm using it.

32:37.360 --> 32:47.440
And as I said, Frans is like everybody, I love everybody at Frans and they have such a great

32:47.440 --> 32:54.000
compiler, it's the class in common Lisp compilers, my opinion, and I did end up spending $5,000 on

32:54.000 --> 33:04.400
a copy of it when I needed it for a job. I think that the declaration in syntax is atrocious,

33:04.400 --> 33:09.760
unless I just hate declarations, like they just look ugly, they get in the way of perfectly

33:09.760 --> 33:14.720
good code. It's a bunch of stuff that the compiler writer, I mean, that the programmer is supposed

33:14.720 --> 33:20.320
to do to give hints, but you know, what does they know? What does the programmer know about that?

33:20.320 --> 33:26.480
I don't know, it's like, why should they have to worry about that? It's such a huge language that

33:26.480 --> 33:32.160
it's almost impossible to implement. I mean, having worked 10 years implementing when I say that,

33:32.160 --> 33:39.600
it's like ridiculously big. Yes, anybody who has, it's ridiculously big. I mean,

33:41.280 --> 33:47.200
I would never ever take it on again, but I got it, you know, at first, common Lisp, the language

33:47.200 --> 33:52.400
one wasn't that bad, right? But I mean, I'd barely finished implementing that in common Lisp,

33:52.400 --> 33:57.520
the language two came out, and it was twice as big, suddenly, and then I started implementing

33:57.520 --> 34:05.280
that, and then the ANSI spec comes out, and it's like twice as big again. I mean, I'm a guy who

34:05.280 --> 34:11.440
likes a big toolbox. I like a programming language. I don't mind that there's different ways to do

34:11.440 --> 34:18.560
things. I think that's all fine, but it almost is impossible to implement. I mean, it takes a big

34:18.560 --> 34:21.280
organization now. One person cannot do it.

34:30.480 --> 34:41.040
Partly that, you know, you would say it's, nowadays, tons of common Lisp standard would be

34:41.760 --> 34:48.240
in libraries and not just, you know, and so they would be more optional. Like, if there was a

34:48.240 --> 34:55.600
commonly agreed-on subset that was useful, implementers wouldn't have a problem. They

34:55.600 --> 34:59.600
could start with that, right? And then they'd have a useful language, and then, you know, that

34:59.600 --> 35:05.920
could be like the first phase, and they could go on and implement the rest. But as it stands now,

35:06.000 --> 35:14.240
if you don't implement, like, pretty close to 100%, tons of people are going to have, you know,

35:14.240 --> 35:18.640
tons of common Lisp packages that are out there aren't going to work, because they use everything.

35:19.680 --> 35:25.280
There's not a commonly agreed-on set of things. I mean, it all gets used, you know? I mean,

35:25.280 --> 35:29.520
that's a tribute to the people that are doing it. They know their language, and they know what they've

35:29.520 --> 35:36.160
found, these tools, they use them. But it's, I don't like the loop syntax. We were talking about

35:36.160 --> 35:44.000
that a little, you know, to me, it's not Lispy. So, I put in, I just, I think I stole it from,

35:45.200 --> 35:52.320
from SteelBank common Lisp or something, you know, like it's, like, public domain. So, I didn't

35:52.320 --> 35:59.520
write it myself. But, and the whole, the implementation is smart enough to do X, you know?

35:59.520 --> 36:03.440
It's kind of like the people that designed the language weren't really sure how something would

36:03.440 --> 36:06.640
work, and they realized that it was awfully complicated, and it looked like it was going to

36:06.640 --> 36:10.880
perform pretty badly. But, well, those compiler writers in the future, they'll be smart. They'll

36:10.880 --> 36:16.640
figure out some way to, to implement around that. You know, it's like, oh, so many times I bump into

36:16.640 --> 36:33.280
that in the spec. Oh, yeah, well, C loss, I, I think it's the greatest object system there is,

36:34.240 --> 36:41.360
and it's also, in some ways, one of the worst. I, I mean, it does everything, and that's awesome,

36:41.360 --> 36:46.240
and you can hold it up. Anything, anybody else's object system can do, it can do better,

36:46.640 --> 36:52.240
multi-methods and everything else. But, partly, again, that implementing it and making it efficient

36:52.240 --> 36:57.840
is, like, so hard, and then being a programmer and trying to, like, get your, you know, understand

36:58.640 --> 37:05.520
how to make it work, and to make it work well is so complex. And honestly, I'm most of the time,

37:05.520 --> 37:10.640
I just use def struct. Like, structures are great. They're efficient. I know exactly what

37:10.640 --> 37:15.680
they're doing. There's nothing complicated about them. I don't know. I'm just not a big fan.

37:17.280 --> 37:28.640
It took, it took a long time to get the garbage collector working. At least a year, you know,

37:28.640 --> 37:33.440
reading everything I could find about garbage collectors and all the different ways that you

37:33.440 --> 37:41.120
make them work and copy in collectors, and there was, Henry Baker wrote a ton of papers that were

37:41.120 --> 37:52.800
really cool, you know, really useful. And finally, I mean, I built, basically built an IDE, built the

37:52.800 --> 38:02.880
code generator, the assembler for, for Intel, built an FFI based on kind of the, the API that

38:02.880 --> 38:10.160
fonts used in the old version of, the old bad version of Allegro for Windows, which they,

38:10.960 --> 38:16.160
they kind of spanked before when they, when they found out that I'd done it because they have a

38:16.160 --> 38:26.880
better one, but, but it works. And, and release this around 2000. My, my son, when he was a

38:26.880 --> 38:31.360
young, he was somewhat of an artist and he, he made this picture. I thought that, that was

38:31.360 --> 38:36.560
appropriate, that sort of looked like, you know, my, I've been on the keyboard too long and my

38:36.560 --> 38:41.760
fingers are kind of filed down to points and my hair is spikier than usual.

38:51.120 --> 38:56.800
So when I, I'm about ready to like do a first release, and this is a single threaded lisp,

38:56.800 --> 39:02.640
and, and Reiner Joswig, you know, is emailing me and going, you should do multiple threads. You

39:02.640 --> 39:06.640
have to do multiple threads if you're coming out with a new lisp. And I immediately knew he was

39:06.640 --> 39:13.280
right. Like, because I was already using threads in my C++ programs and stuff. And I said, yeah,

39:13.280 --> 39:19.920
but all the lisp's I knew you were, were using lisp threads, you know, sort of cooperative threads

39:19.920 --> 39:24.960
that you could start and stop easily and, you know, manage in the lisp system. It was really one big

39:24.960 --> 39:32.080
thread by the operating system. And I think that was not, not right. I mean, I, I did, I knew enough

39:32.080 --> 39:36.880
about working with threads at that point that I knew you had to use the OS threads. You had to

39:36.880 --> 39:42.640
support that. Windows supports it very well. And, you know, the lisp threads had to be real OS threads

39:42.640 --> 39:49.280
or, or was not competitive with something like C++. And that way, if you've got a multi-processor

39:49.280 --> 39:54.080
machine, which are not too common back then, but coming along, you have parallel execution,

39:54.160 --> 40:00.880
you know, real parallel execution. And that was awesome. I mean, I, I decided to do that.

40:02.000 --> 40:07.440
And it changed practically everything. I mean, it really had to redo almost everything to add

40:07.440 --> 40:14.640
thread support. But I may have been the first or one of the first to actually have, you know,

40:14.640 --> 40:20.560
OS level thread, threading in common lisp. I hate without interrupts. That's one of those things

40:20.560 --> 40:24.560
that you see in a lot of lisp code that uses these lisp threads. It's like always, oh, well,

40:24.560 --> 40:29.760
my synchronization method is that I'm going to basically turn off all the other threads when

40:29.760 --> 40:35.840
I change this variable. You know, and in, in, in Windows, in OS threads, you just can't do that.

40:35.840 --> 40:40.240
You know, you can't just like arbitrarily keep switching threads on and off. You know, you've

40:40.240 --> 40:43.600
got to send them a message or you've got to kill them or something, but they, they're running on

40:43.600 --> 40:50.240
their own. You know, you don't have control, that kind of control. So I think CormidLisp has

40:50.320 --> 40:56.160
a without interrupts in it, but it's kind of not probably really that good to use, not that safe or

40:56.160 --> 41:05.440
efficient. Just to give you an example of all the things had to be changed to support threads,

41:06.080 --> 41:10.880
special variable bindings. You know, I love special variables. I think they're an awesome

41:10.880 --> 41:18.000
feature of lisp. I should add that to that list, that list actually. But according to the common lisp

41:18.080 --> 41:24.480
spec, it, you know, the common lisp spec doesn't address threads. And, and if you read it

41:25.200 --> 41:32.720
precisely, it even basically, you know, says that, you know, when you bind a variable,

41:32.720 --> 41:38.160
it says all programs. It says all lisp programs will now see the new binding.

41:39.680 --> 41:44.160
And, and that, I just realized that can't work. That can't work in a threaded system. Each thread

41:44.160 --> 41:49.840
has to have its own bindings. And I, and I don't, I haven't looked into what other lisps do with

41:49.840 --> 41:55.600
this, but I just implemented every thread has its own bindings. You know, I think that's the only

41:55.600 --> 42:00.960
way to do it personally. But, but once you do it, it's like magic. It's like, once you do it now,

42:00.960 --> 42:08.880
you can have local per thread global variables, special variables as easy as using let. I mean,

42:08.880 --> 42:15.520
it's like, you use them, it makes writing thread safe code actually very easy. Just rebind the

42:15.520 --> 42:20.960
variables using let to themselves or whatever, rebind them at the beginning of your thread.

42:21.520 --> 42:27.200
And then you're good. You have your own copies that only your thread knows about. It's very efficient

42:27.200 --> 42:36.640
and very easy. Heep design and access is affected. You know, you've got to make sure that you

42:37.600 --> 42:42.960
different threads or any thread can trigger garbage collection, right? Could make a memory call,

42:42.960 --> 42:48.320
triggers garbage collection. That means any other thread between any two instructions can,

42:48.960 --> 42:54.160
can have the whole world swept away. That's how the code, that's how the code is. Eating any

42:54.160 --> 43:00.160
two instructions, hardware instructions, the garbage collector can try to like. And when the

43:00.160 --> 43:04.800
garbage collector runs, it moves everything and every address changes. Every function address

43:04.800 --> 43:12.320
changes. The whole world changes. Stack updated, you know. So it's kind of hard to write code,

43:12.320 --> 43:17.680
to generate code that's safe in that kind of an environment when that can happen at any moment.

43:17.680 --> 43:21.360
And a lot of stuff had to be figured out to make that, make that work.

43:23.840 --> 43:29.680
Foreign calls and callbacks. Threads make that more complicated. Your foreign libraries might

43:29.680 --> 43:37.040
not support threads. Who knows? Code generation. Can you generate code in parallel on multiple

43:37.040 --> 43:41.120
threads or should you? You know, they might be trying to update the same functions.

43:42.720 --> 43:49.360
Debugging, of course. Multiple threads. Lisp image saving and loading. If you got a bunch of threads

43:49.360 --> 43:54.880
running and you save the image, you know, are you going to try to restart all those processes when

43:54.960 --> 44:02.160
you load the image? And, you know, thread can come in and call your list code that's not even a

44:02.160 --> 44:08.960
thread you've seen before. It's like one that, you know, where that come from. Now you have to

44:08.960 --> 44:15.040
initialize yourself with your list variable bindings or something. You have problems with

44:15.040 --> 44:21.680
machine architectures that when you're doing a set that they, a simultaneous read can get a different

44:21.760 --> 44:29.840
set of bytes out of the same variable. There's problems where that happens. Yeah, I can imagine.

44:31.840 --> 44:36.160
And this is just a simple, or this is just an example of special variable binding

44:38.800 --> 44:46.080
in Corman list. But, you know, if you've got, instead of just having a slot in a symbol that has the

44:46.160 --> 44:52.720
global variable binding, really those have to be sort of compiled into a table. They're not on the

44:52.720 --> 44:58.160
symbol anymore. They're in their own table. And you don't want to put every symbol in this table

44:58.880 --> 45:03.120
because, you know, if you've got, you might have hundreds of thousands of symbols in your, in your

45:03.120 --> 45:09.840
running system. And most of them, 90% of them, you're never going to rebind. So we only care

45:09.840 --> 45:14.960
about the ones that you're going to bind dynamically. So the compiler and the runtime system needs to

45:14.960 --> 45:22.320
maintain a symbol table that can grow that only has the variable bindings that you need.

45:23.600 --> 45:31.520
And then every thread has to have its own copy of this table so that it can, you know, this thread

45:31.520 --> 45:38.240
can have its own local bindings of those variables, whereas these are still referring to the global

45:38.240 --> 45:43.920
bindings. So that, that's how Corman list dynamic variable binding works basically.

45:53.200 --> 45:59.520
I like getting down and dirty in code. I like just like, as you could tell from what I've told you,

45:59.520 --> 46:07.600
I mean, I like disassembling stuff. I like seeing how things work. I like if somebody has some new

46:07.600 --> 46:14.000
API or some new DLLs or some library, I'd like to be able to just write some Lisp code that calls it.

46:14.960 --> 46:20.560
And it's just really important to me to be able to do anything I could do in like C.

46:22.880 --> 46:29.200
And so Lisp, Corman Lisp really brought out the sort of the low level

46:30.000 --> 46:35.040
ability. The fact that it's only on Windows made this possible, right? If I was trying to support

46:35.040 --> 46:40.400
a bunch of platforms, like say Franz does, I probably wouldn't have done this. But we,

46:41.200 --> 46:48.960
I basically built a lot of different ways to call assembly language, extend the assembler,

46:48.960 --> 46:55.520
you know, to make new operations, which generated code in different ways. A lot of like hacky kind

46:55.520 --> 47:01.360
of things that you could do. So you could easily use it to use, deal with comm objects in, in,

47:01.920 --> 47:07.520
the Windows world comms a big deal. These certain kind of a, you know, built-in object model in

47:07.520 --> 47:13.440
Windows. Def Code Gen lets you define your own sort of code generators, almost like it's,

47:13.440 --> 47:22.160
what a special form would be. And so here's an example of a, just a function, def ASM,

47:22.800 --> 47:30.800
that's all written in assembler, but right in the Lisp file. And the curly braces are used to

47:30.800 --> 47:35.920
designate an assembler block. And as you can see, it looks like, just like Intel assembler, basically,

47:36.720 --> 47:40.720
other than the, you know, the macro, the args offset macro, and a couple things like that.

47:42.000 --> 47:45.520
And if you want to mix assembler right into a Lisp function, you can do that too.

47:46.400 --> 47:53.440
I use the double curly braces in that case. But that's just an example that, it's a normal Lisp

47:53.440 --> 47:58.720
function, it does some Lisp stuff, and then it does some assembler. So you can probably imagine,

47:59.280 --> 48:01.600
if you know what you're doing, you could do almost anything with this.

48:05.760 --> 48:12.320
The assembler has macros. So this is how you define an assembly macro. This particular macro is

48:13.840 --> 48:21.680
the call. It's the way that most Lisp functions get called through callf. And callf pushes a,

48:21.680 --> 48:26.960
pushes the environment, you know, lexical environment on, it will actually puts it in the

48:26.960 --> 48:31.360
DI register and then calls the function. So it's a,

48:35.680 --> 48:44.000
and then we added a way to just basically take big chunks of C headers and bring them in, you know,

48:44.000 --> 48:50.800
so that instead of having to, you know, write Lisp code to, to make the wrappers and bindings on

48:50.800 --> 48:55.840
all of the C functions or the, you know, and this, this thing, it doesn't show it here, but it handles

48:55.840 --> 49:03.920
structures and a lot of macros, defines lots of things. You could just bring direct.h files over

49:03.920 --> 49:09.440
and it will, you know, pull them in and let you call the functions in Lisp. It's very easy.

49:11.280 --> 49:16.880
So I think between all of those things, you know, it makes it easy to use it for, I can make a

49:16.880 --> 49:23.760
Photoshop plugin out of, out of Cormand Lisp, you know, I could generate a DLL that, that could be

49:23.760 --> 49:35.760
used as a plug-in. What's that? I haven't tried, but probably.

49:40.560 --> 49:45.040
I don't know. We can talk about it.

49:46.000 --> 49:56.880
I'll give a little quick demo here of Cormand Lisp running. Nothing too, you know, it's kind of hard

49:56.880 --> 50:04.640
to show this kind of thing, but I have to stop my slideshow, otherwise you won't be able to see it.

50:04.640 --> 50:08.720
Oh, what's Cormand, what's that complaining about?

50:12.000 --> 50:17.280
Remind me later. When you have Windows, when you have a Windows running on a Mac,

50:18.000 --> 50:24.480
it never stops trying to update stuff. You know, it's like, it just drives you crazy.

50:24.480 --> 50:36.720
So, I'm going to put this down for a minute. It's not showing up over there. Oh, it's not.

50:36.720 --> 50:44.800
Okay, so why did it not show up? Just a second. Let's go to displays. Let's say

50:44.800 --> 50:59.920
arrangement, mirror displays. Okay, and it's showing up now, right? Okay.

51:00.800 --> 51:15.680
Now, okay. I just made a program called Minds. I took a program that I found online that's kind

51:15.680 --> 51:22.480
of interesting, and a lot of people have sort of ported it to different languages. It's called

51:22.480 --> 51:34.720
Mind Sweepers, and so I just, for fun recently, ported it from C++ to Lisp, and we've got,

51:35.920 --> 51:38.400
if you look in here, it's got some interesting

51:41.440 --> 51:47.040
bunch of matrix math stuff that we carried over, and it's got neural nets.

51:48.000 --> 51:53.680
The idea is these Mind Sweepers are really dumb when you first turn them on,

51:54.400 --> 52:00.000
and then as they successfully find the minds, they get smarter. And then there's a genetic

52:00.000 --> 52:06.880
algorithm in it, too, that sort of has a random bit pattern that allows it to, you combine those

52:06.880 --> 52:12.960
between different successful Mind Sweepers and they create new ones. So, it combines neural net

52:13.040 --> 52:19.920
and genetic algorithm, and it's kind of cool. So, I'm just going to execute this and run that in a

52:19.920 --> 52:42.240
separate thread, th, create thread, and you see you've got these little guys.

52:42.960 --> 52:50.160
I can change the size, and it'll start to put minds in the other part of the window.

52:51.360 --> 52:58.720
They're really stupidly just going around randomly now. They're not going toward the minds,

52:58.720 --> 53:02.880
particularly, but once in a while they accidentally get one, and they'll go through generations,

53:02.880 --> 53:07.040
and you can go hundreds of generations, and after hundreds of generations, it will start to,

53:08.000 --> 53:12.880
they'll start to be smarter. It seems like it takes too long to me. I think that the

53:12.880 --> 53:19.280
algorithms could be tweaked to have them learn faster, but kind of interesting if we took,

53:20.080 --> 53:26.160
if we wanted to just make some little dynamic changes. Let's see where we are.

53:26.480 --> 53:33.280
I've got a couple of variables here. If we just take,

53:35.920 --> 53:40.640
let's see, Sweeper Scale. I'll take like the Sweeper Scale for controlling the size,

53:41.360 --> 53:48.480
and we just, we wanted to just make it a little bigger on the fly.

53:49.040 --> 54:02.480
You see they got bigger. Do they have senses? They know where the closest mine is,

54:04.080 --> 54:08.800
but what they're not programmed to do is go toward it. Like they have to learn how to go

54:08.800 --> 54:17.040
toward it. You see a lot of them just like turning in circles, but just show you. I mean,

54:17.120 --> 54:21.280
again, we've got fully compiled code, and we can modify it on the fly, and that's pretty cool,

54:21.280 --> 54:28.160
and I can save it as an application. If I was developing a game, I think it'd be pretty nice,

54:29.200 --> 54:32.160
pretty nice interactive development environment.

54:37.600 --> 54:44.560
If we up at the top, you see the little animation Gen 0, Gen 1, that's the garbage collector.

54:45.360 --> 54:52.080
It's mostly just Generation 0. It's just the ephemeral collector. It's got one generation

54:52.080 --> 54:58.640
that keeps getting collected. Generation 1 fills up a lot slower, and then the main one,

54:58.640 --> 55:03.200
you'll hardly notice it growing at all, because most of this stuff gets thrown away.

55:03.760 --> 55:18.080
By the way, on the threads, each thread has its own heap, because otherwise we have to

55:18.080 --> 55:25.120
synchronize around cons, and we don't like to do that. So cons is really fast, because each thread

55:25.120 --> 55:31.680
gets its own sort of mini heap that it keeps refilling from the ephemeral thread, and so they

55:31.680 --> 55:36.880
can allocate small things really quickly. If they allocate something too big, then they go,

55:36.880 --> 55:45.920
then they have to synchronize. I'm having a hard time hearing.

55:46.240 --> 55:52.160
Can a thread be handed a cons or anything else that belongs to another thread?

55:55.120 --> 56:06.560
It can be handed a cons, yes. For example, if you didn't rebind a special variable,

56:07.680 --> 56:10.960
those special variable bindings are shared by all the threads,

56:11.360 --> 56:19.760
and so they're certainly sharing can occur. Since common list doesn't define what things,

56:19.760 --> 56:24.560
like packages and hash tables, and stuff, it doesn't define whether those are thread safe,

56:24.560 --> 56:29.520
because there's no concept of threads. I had to make a lot of just decisions about what to do.

56:30.160 --> 56:37.200
I made hash tables synchronized so that threads couldn't share a hash table, and they wouldn't

56:38.160 --> 56:45.520
have problems, but there's a little overhead there. Probably packages should be synchronized,

56:45.520 --> 56:50.080
and I'm not sure if they are. There's more things that could be synchronized, but generally,

56:50.080 --> 56:57.040
I think you all know you don't want to do that. Generally, we try to avoid sharing between threads,

56:57.040 --> 57:00.560
and if you get an enclosure, they enforce that a lot better.

57:00.960 --> 57:18.560
I don't have too much more anything interesting to demo there, but it's got some nice features

57:18.560 --> 57:25.440
where you can, if I wanted to find the code or do anything, I get a little tool tip there,

57:26.080 --> 57:31.360
and I can also right-click on it and look up the source. Since we include the source to everything,

57:33.040 --> 57:38.880
you can always look up the source to every Lisp function. Here, I just looked up the source to

57:38.880 --> 57:48.240
DefVar, just a macro. For me, I really like to be able to look up the source to all the Lisp

57:48.240 --> 57:53.840
operators in any Lisp I use. You could disassemble it too, but with a macro, that would disassembly

57:53.840 --> 58:03.040
wouldn't do you any good. Any questions on Corman Lisp?

58:12.480 --> 58:18.240
I have a few more slides I could get to, but I know we've gone pretty long here, so I definitely

58:18.240 --> 58:47.920
have gone. I agree with you on that. I certainly feel like Lisp is

58:48.320 --> 58:54.960
so easy to modify and so easy to make it be whatever you want it to be. That's why I say it's a family

58:54.960 --> 59:00.800
of languages. If it doesn't have a particular feature of another Lisp you like, and Corman Lisp,

59:00.800 --> 59:09.120
especially Corman Lisp, is just easy to implement anything. I feel like Closure has a lot of nice

59:09.120 --> 59:15.040
features, say, but I could implement those Closure features in Corman Lisp pretty easily,

59:15.120 --> 59:23.200
I think. I know there are some parts of language that wouldn't be as easy, and the Java VM

59:23.200 --> 59:32.640
interface, obviously. Two questions. In creating your own Lisp, did you make any innovations

59:32.640 --> 59:38.400
around IDE in your own development environment, such as slide and standard stuff for your own thing?

59:39.040 --> 59:46.080
Well, I built this IDE on the Windows Rich Text Edit, which is built into Windows,

59:46.720 --> 59:55.360
so the text windows themselves are all rich text edits, which are calm objects, which Corman Lisp

59:55.360 --> 01:00:00.880
then calls. When we see a lot of these editor features, those are all written in Lisp and running

01:00:00.880 --> 01:00:11.200
in Lisp, the syntax, coloring, and stuff like that. Then it's a C++ Microsoft Foundation Class's

01:00:11.200 --> 01:00:21.120
MFC framework. I'm not a very much of a UI programmer, and my UIs always suck. They're

01:00:21.120 --> 01:00:27.440
not really beautiful, and that's not where I spend my time. There's nothing really fancy here,

01:00:27.440 --> 01:00:33.280
and it looks outdated now. I would like to rewrite the whole editor in Lisp, and that would not be

01:00:33.280 --> 01:00:41.920
hard to do, but it's like I needed this to build it. I needed something that it worked with nicely

01:00:41.920 --> 01:00:48.160
to build it. When I started, I started with C++ editor.

01:00:48.240 --> 01:00:54.640
And then the follow-up question, the same question about around the database,

01:00:54.640 --> 01:00:59.840
what should you typically use for your software and stuff like that?

01:01:01.840 --> 01:01:05.760
For the database? Did you make something like your own version of LEGO Cache,

01:01:05.760 --> 01:01:10.720
or did you just make a connector to a relational database and just use that when you build applications?

01:01:11.600 --> 01:01:17.280
I've tended to use SQL databases for most of my projects.

01:01:19.600 --> 01:01:24.720
To me, SQL is kind of like Lisp. I mean, SQL relational database is kind of like Lisp in that

01:01:25.360 --> 01:01:33.200
they started off really amazing and theoretical, but they sucked performance-wise,

01:01:33.760 --> 01:01:37.520
and then people just kept putting more and more and more and more effort into them, and they got

01:01:37.520 --> 01:01:43.040
better and better. And now you have these amazing relational databases, and you have these amazing

01:01:43.040 --> 01:01:49.920
Lisp systems that so many man-hours and effort went into. And I think SQL database, you know,

01:01:49.920 --> 01:01:54.320
they're kind of getting a bad rap now with everybody wanting to go to object databases,

01:01:54.320 --> 01:02:04.960
and no SQL and whatever, but generally I'm still content with modern relational databases,

01:02:04.960 --> 01:02:09.600
and that's what I've used. I'd like to do something with the LEGO Cache. I think that's an awesome system too.

01:02:15.760 --> 01:02:22.560
I definitely recommend a LEGO Cache for any system where you didn't need SQL, you didn't want it.

01:02:27.200 --> 01:02:27.680
Yeah.

01:02:27.680 --> 01:02:33.360
So what's next? I mean, are you going to sort of just keep proliferating different kinds of

01:02:33.440 --> 01:02:35.600
formulas? Are you going to do more DSLs?

01:02:36.400 --> 01:02:44.320
Okay, so I might have an interesting slider to left, so I'm going to go ahead and restart this here.

01:02:47.840 --> 01:02:57.520
I kind of stopped working on it. Well, I did stop working on it for a long time because I,

01:02:57.760 --> 01:03:04.160
the recession hit and our business was, you know, I have a software company and sort of,

01:03:04.160 --> 01:03:10.320
we've been an independent software company for 15 years, but it just, you know, all our clients

01:03:10.320 --> 01:03:16.640
and contracts went away in 2008, 2009, 2010, and we were kind of hanging on for dear life,

01:03:17.360 --> 01:03:24.160
and I just couldn't justify these, you know, nights and effort spent enhancing Corman Lisp,

01:03:24.240 --> 01:03:31.920
which I knew was never going to be profitable. And, you know, we just, I just said, and I couldn't

01:03:31.920 --> 01:03:36.320
keep, you know, and, you know, the certain amount of client support calls you get and stuff, I just,

01:03:36.320 --> 01:03:42.800
so I just, I just stopped doing it. And, you know, a couple, you know, people started letting me know,

01:03:42.800 --> 01:03:47.520
yeah, what's going on with Corman Lisp? And I would always say, well, it's on hold for now.

01:03:47.520 --> 01:03:54.000
You know, I don't know. And, and that's kind of where it stayed for, for like six years until

01:03:54.000 --> 01:03:58.960
Zach Bean came along and said, well, why don't you just open source it? So, you know, people,

01:03:58.960 --> 01:04:03.440
other people can work on it. And I said, that sounds great because I'd rather other people

01:04:03.440 --> 01:04:09.760
worked on it and it continued to evolve. I think the code's written well, you know, but on the

01:04:09.760 --> 01:04:15.280
other hand, it's incredibly complex. And I always kind of wondered, could anybody else work on it?

01:04:15.280 --> 01:04:20.560
You know, could anybody figure it out to like fix the bugs that come up in the garbage collector

01:04:20.560 --> 01:04:26.400
or whatever? I can barely remember or figure some of that stuff out. But once I open sourced it,

01:04:26.400 --> 01:04:32.640
it's an MIT license now. Zach did the work kind of like, you know, getting rid of the licensing

01:04:32.640 --> 01:04:41.760
stuff that was in there and everything. And one Artem Boldarev, I think that's his name right,

01:04:41.760 --> 01:04:48.640
he's a Ukrainian guy, a young guy. He, he's been taking, kind of taken over, done a lot of stuff

01:04:48.640 --> 01:04:56.080
on it. And he fixed a really significant bug that I had with 64-bit windows. Like, like, mostly

01:04:56.080 --> 01:05:01.280
every program out there that runs on 32-bit windows will run on 64-bit windows as a six,

01:05:01.280 --> 01:05:09.040
as a 32-bit process. This was one that had some problems. And it turns out it has to do with

01:05:09.040 --> 01:05:18.080
the thunking between the 34 and 60, the 32 and 64-bit layers. When you are calling out to a

01:05:18.080 --> 01:05:26.080
OS call, it's actually always thunking the 64 bits and then coming back to 32 bits. And structured

01:05:26.080 --> 01:05:33.200
exceptions don't propagate properly across that thunk. And we were relying on structured exceptions

01:05:33.280 --> 01:05:39.040
to implement the right barrier that the, that the garbage collector use. You probably don't know

01:05:39.040 --> 01:05:43.040
what a right barrier is, but that's something that has to do with the virtual memory system and

01:05:43.040 --> 01:05:49.520
makes the garbage collector really fast. And that was like crashing when you were in a 64-bit

01:05:49.520 --> 01:05:56.560
OS and you were doing, you know, FFI calls and callbacks, you know, and he tracked that down.

01:05:56.560 --> 01:06:02.400
And I was very impressed. He tracked it down and figured out how to catch the exceptions and how to,

01:06:02.400 --> 01:06:08.800
you know, repropagate them and got it working again, you know, in 64-bit. And so then I said,

01:06:09.840 --> 01:06:16.160
okay, I want to work on it now. And I've been, I've kind of gotten back into it in the last,

01:06:16.160 --> 01:06:22.240
in the last year. Having someone else to work on it with is really great. And of course,

01:06:22.240 --> 01:06:28.400
that's the beauty of open source. You can find, I've got somebody from Ukraine. A lot of the work

01:06:28.400 --> 01:06:36.640
was done by Vasily Baikov in the earlier days, who's Russian. And he did tons of, he did tons of

01:06:36.640 --> 01:06:44.240
stuff in Common Lisp. And it kind of sounds like I'm colluding with the Russians, which I am.

01:06:46.000 --> 01:06:54.000
But then basically since then, I've started to use Clojure. I like Common Lisp, but I'm,

01:06:54.560 --> 01:07:01.280
I will, I'll never, as much as I love Lisp and I evangelize about it, I won't,

01:07:02.640 --> 01:07:06.400
I won't promote it to a client if I don't think it's the right tool for the job.

01:07:07.280 --> 01:07:12.400
And a lot of times I think Clojure is a better tool for the job these days. More,

01:07:13.840 --> 01:07:19.200
more people are getting into it. The fact that it runs on the Java VM and can run everywhere.

01:07:19.680 --> 01:07:27.040
The fact that it's simpler, it's a simpler language. The fact that it can run on the .NET,

01:07:27.040 --> 01:07:31.600
which is a platform I've been heavily involved with, the .NET version of Clojure.

01:07:33.280 --> 01:07:38.160
There's a lot to like about it. Macros are good enough for me, the way they did macros,

01:07:38.160 --> 01:07:44.400
it's, you could do what you want with them. As we said, the S expressions are a little different,

01:07:45.200 --> 01:07:52.000
everything's like, there's no dot pairs. You can't put whatever you want on the right side of a

01:07:52.000 --> 01:07:59.680
con's call, which is kind of weird. Weird and good, depending on your perspective.

01:08:07.120 --> 01:08:11.600
I've never really used Scheme very much, but I'm really interested in it.

01:08:12.400 --> 01:08:17.280
And I don't know why, I just, I got into Common Lisp early and I just,

01:08:18.400 --> 01:08:24.240
you know, but one of my favorite books in the world is Christian Kennecks Lisp in Small Pieces,

01:08:25.120 --> 01:08:30.240
which if you've ever read, you know, he's a Scheme guy and he writes like 30 different

01:08:31.520 --> 01:08:37.520
Scheme, Lisp and Scheme interpreters and compilers that he presents in this book. And it's,

01:08:38.240 --> 01:08:41.120
for me, it was nice bedside reading.

01:08:44.880 --> 01:08:49.920
So I'm building another version of my Arden syntax compiler, this one that I own,

01:08:50.960 --> 01:08:57.120
using Clojure. And it was kind of neat because we could take, if you know how you build a compiler,

01:08:57.120 --> 01:09:04.960
you have these Bacchus Naur forms. And I just took what you see in comments there is straight

01:09:04.960 --> 01:09:11.600
out of the spec for Arden syntax, the BNF straight out of the spec. And then I sort of just

01:09:11.600 --> 01:09:17.760
made the, you know, made a macro, a macro parse rule that takes the language as it shows up in

01:09:17.760 --> 01:09:23.760
the spec and turns it into a code generator, a parser and a code generator. And the next

01:09:23.760 --> 01:09:30.480
expression there is the generated code basically in Clojure. And so this parser actually works

01:09:31.200 --> 01:09:36.720
just off of these. And it makes it, you know, pretty easy to write the parser and pretty easy

01:09:36.720 --> 01:09:41.040
to update it. And if the spec changes, it's pretty easy to see when it diverges or when, you know,

01:09:41.040 --> 01:09:47.600
where you have to change. It's slower than my hand coded C++ parser that I wrote before, but

01:09:49.440 --> 01:09:54.720
I, you know, probably could still make it faster. But it was a nice project to do in Clojure. And

01:09:54.800 --> 01:09:59.840
I've liked it for that. I could do it in Common Lisp too. It would probably be even, you know,

01:09:59.840 --> 01:10:04.800
could probably have written it more easily. But again, I wanted to run a .NET. And

01:10:08.720 --> 01:10:12.160
so if I said what I like about Clojure, all those things that I liked about Lisp,

01:10:13.600 --> 01:10:19.520
S expressions, consing engine, macros, garbage collection, functional paradigm, not so much on

01:10:19.520 --> 01:10:27.360
the object oriented paradigm or the procedural, the fact that it has such a user base and very

01:10:27.360 --> 01:10:37.280
good implementation and runs on practically every platform. I say, I think all Lisp languages are

01:10:37.280 --> 01:10:44.960
Lisp family. They're all part of the same family. And to me, if I love one, I love them all. And I

01:10:45.840 --> 01:10:52.000
with macros, I could make Clojure do what I want. I'm sure of that. It does take some getting used

01:10:52.000 --> 01:10:59.600
to not being able to mutate variables, getting rid of set Q basically. And you could get around it

01:10:59.600 --> 01:11:05.360
by just creating a single cell Java arrays and using those for your mutatable variables that

01:11:05.360 --> 01:11:10.480
can be shared. You know, if you have to, it's pretty easy to get around. So it's not like,

01:11:11.120 --> 01:11:14.880
but of course, it's kind of ugly. The whole Java interface part of it's,

01:11:15.600 --> 01:11:19.280
you know, it's, you have to use it too many places, I think. But

01:11:23.600 --> 01:11:28.480
and the last thing I had here, I was going to mention is I'm getting into continuations now,

01:11:28.480 --> 01:11:33.280
which I never did. You know, all these years of doing common Lisp, I never used continuations.

01:11:34.240 --> 01:11:38.640
And I, all I thought was like, I'd never wanted to try to implement them because it seemed too

01:11:38.640 --> 01:11:45.440
hard or too inefficient to be saving and restoring the stack all the time. And so

01:11:46.640 --> 01:11:52.160
now I have a language I'm implementing and this uses fuzzy logic new version of Arden 2.9.

01:11:52.960 --> 01:11:58.320
And the control flow is fuzzy. So if you have an if statement and the condition is

01:11:59.680 --> 01:12:08.080
somewhere between true and false, it splits into two paths of execution. And so this kind of an

01:12:08.080 --> 01:12:15.200
execution model requires backtracking and something that continuations can do. And I don't know what

01:12:15.200 --> 01:12:23.520
else could, you know, and the only other alternative that I've come up with is to do in continuations

01:12:23.520 --> 01:12:30.160
is to use continuation passing style, you know, where you, every function gets a continuation

01:12:30.160 --> 01:12:35.840
passed in and returns a continuation. And then you use a trampoline, which is just a little loop

01:12:35.840 --> 01:12:41.040
that just keeps calls, gets a continuation back, calls that continuation back, gets a

01:12:41.040 --> 01:12:45.840
continuation back. In the end, you have no stack. So your continuations don't have to worry about

01:12:45.840 --> 01:12:51.920
saving and restoring the stack. I mean, you, you, you avoid that problem, which is what's hard about

01:12:51.920 --> 01:12:57.040
continuations, saving and restoring the stack. And you cannot do them on the, you cannot do that on

01:12:57.040 --> 01:13:01.920
Java VM or CLR to my knowledge. It doesn't, doesn't support that.

01:13:02.880 --> 01:13:11.360
Have you considered rewriting some of those algorithms and say using a star or some other

01:13:12.240 --> 01:13:19.840
form other than continuation? You know, I don't know exactly the details of the problem you're

01:13:19.840 --> 01:13:25.120
trying to solve, but maybe you're out with the wrong algorithm. Yeah, and I bet you, you could

01:13:25.120 --> 01:13:29.920
help me with that. It's actually one of the first problems I've ever bumped into that I didn't,

01:13:30.720 --> 01:13:34.640
you know, I still haven't solved. I mean, it was very, I'm having a tough time with it.

01:13:35.600 --> 01:13:46.160
So I'm open to suggestions and advice. Okay, so I know all of you have like great stories about

01:13:46.160 --> 01:13:52.160
what you've done with Lisp. And I'd love to know more about them. And I'm really, really happy. I

01:13:52.160 --> 01:13:58.400
got to be the one up here today, talking about my story, not that it's any better than anybody else's

01:13:58.400 --> 01:14:04.240
story. But I'm thankful that I had the chance because normally I never find anybody that wants to

01:14:04.240 --> 01:14:10.800
talk about this stuff or hear about it, right? In my regular life, right? So getting to meet,

01:14:10.800 --> 01:14:17.360
you know, be with this many Lisp programmers at once is, is really unusual and just great for me.

01:14:18.080 --> 01:14:23.760
So thanks a lot. And I hope you've learned something, something of value tonight.

01:14:23.760 --> 01:14:31.620
Thank you.

